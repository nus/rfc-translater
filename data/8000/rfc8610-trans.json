{
  "title": {
    "text": "RFC 8610 - Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures",
    "ja": "RFC 8610 - 簡潔なデータ定義言語（CDDL）：簡潔なバイナリオブジェクト表現（CBOR）およびJSONデータ構造を表現する表記規則"
  },
  "number": 8610,
  "created_at": "2019-11-05 15:25:57.120396+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       H. Birkholz\nRequest for Comments: 8610                                Fraunhofer SIT\nCategory: Standards Track                                      C. Vigano\nISSN: 2070-1721                                      Universitaet Bremen\n                                                              C. Bormann\n                                                 Universitaet Bremen TZI\n                                                               June 2019",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Concise Data Definition Language (CDDL): A Notational Convention\n     to Express Concise Binary Object Representation (CBOR)\n                    and JSON Data Structures",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049). Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.",
      "ja": "このドキュメントは、簡潔なバイナリオブジェクト表現（CBOR）データ構造（RFC 7049）を表現する表記規則を提案します。 その主な目標は、CBORまたはJSONを使用するプロトコルメッセージおよびデータ形式の構造を表現する簡単で明確な方法を提供することです。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 インターネット標準の詳細については、RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8610.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8610で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2019 IETF Trustおよび文書の著者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書は、この文書の発行日に有効なBCP 78およびIETF文書に関するIETFトラストの法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Requirements Notation ......................................5\n   1.2. Terminology ................................................5\n2. The Style of Data Structure Specification .......................5\n   2.1. Groups and Composition in CDDL .............................7\n        2.1.1. Usage ..............................................10\n        2.1.2. Syntax .............................................10\n   2.2. Types .....................................................11\n        2.2.1. Values .............................................11\n        2.2.2. Choices ............................................11\n        2.2.3. Representation Types ...............................13\n        2.2.4. Root Type ..........................................14\n3. Syntax .........................................................15\n   3.1. General Conventions .......................................15\n   3.2. Occurrence ................................................16\n   3.3. Predefined Names for Types ................................17\n   3.4. Arrays ....................................................18\n   3.5. Maps ......................................................19\n        3.5.1. Structs ............................................19\n        3.5.2. Tables .............................................22\n        3.5.3. Non-deterministic Order ............................23\n        3.5.4. Cuts in Maps .......................................24\n   3.6. Tags ......................................................25\n   3.7. Unwrapping ................................................26\n   3.8. Controls ..................................................27\n        3.8.1. Control Operator .size .............................27\n        3.8.2. Control Operator .bits .............................28\n        3.8.3. Control Operator .regexp ...........................29",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        3.8.4. Control Operators .cbor and .cborseq ...............30\n        3.8.5. Control Operators .within and .and .................30\n        3.8.6. Control Operators .lt, .le, .gt, .ge, .eq,\n               .ne, and .default ..................................31\n   3.9. Socket/Plug ...............................................32\n   3.10. Generics .................................................33\n   3.11. Operator Precedence ......................................34\n4. Making Use of CDDL .............................................36\n   4.1. As a Guide for a Human User ...............................36\n   4.2. For Automated Checking of CBOR Data Structures ............36\n   4.3. For Data Analysis Tools ...................................37\n5. Security Considerations ........................................37\n6. IANA Considerations ............................................38\n   6.1. CDDL Control Operators Registry ...........................38\n7. References .....................................................40\n   7.1. Normative References ......................................40\n   7.2. Informative References ....................................41\nAppendix A. Parsing Expression Grammars (PEGs) ....................43\nAppendix B. ABNF Grammar ..........................................45\nAppendix C. Matching Rules ........................................47\nAppendix D. Standard Prelude ......................................52\nAppendix E. Use with JSON .........................................53\nAppendix F. A CDDL Tool ...........................................56\nAppendix G. Extended Diagnostic Notation ..........................56\n  G.1. Whitespace in Byte String Notation .........................57\n  G.2. Text in Byte String Notation ...............................57\n  G.3. Embedded CBOR and CBOR Sequences in Byte Strings ...........57\n  G.4. Concatenated Strings .......................................58\n  G.5. Hexadecimal, Octal, and Binary Numbers .....................59\n  G.6. Comments ...................................................59\nAppendix H. Examples ..............................................60\nAcknowledgements ..................................................63\nContributors ......................................................63\nAuthors' Addresses ................................................64",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In this document, a notational convention to express Concise Binary Object Representation (CBOR) data structures [RFC7049] is defined.",
      "ja": "このドキュメントでは、Concise Binary Object Representation（CBOR）データ構造[RFC7049]を表現する表記規則が定義されています。"
    },
    {
      "indent": 3,
      "text": "The main goal for the convention is to provide a unified notation that can be used when defining protocols that use CBOR. We term the convention \"Concise Data Definition Language\", or CDDL.",
      "ja": "この規則の主な目標は、CBORを使用するプロトコルを定義するときに使用できる統一表記法を提供することです。 規約を「簡潔なデータ定義言語」またはCDDLと呼びます。"
    },
    {
      "indent": 3,
      "text": "The CBOR notational convention has the following goals:",
      "ja": "CBOR表記規則には次の目標があります。"
    },
    {
      "indent": 3,
      "text": "(G1) Provide an unambiguous description of the overall structure of a CBOR data item.",
      "ja": "（G1）CBORデータ項目の全体構造の明確な説明を提供します。"
    },
    {
      "indent": 3,
      "text": "(G2) Be flexible in expressing the multiple ways in which data can be represented in the CBOR data format.",
      "ja": "（G2）CBORデータ形式でデータを表現できる複数の方法を柔軟に表現できます。"
    },
    {
      "indent": 3,
      "text": "(G3) Be able to express common CBOR datatypes and structures.",
      "ja": "（G3）一般的なCBORデータ型と構造を表現できる。"
    },
    {
      "indent": 3,
      "text": "(G4) Provide a single format that is both readable and editable for humans and processable by a machine.",
      "ja": "（G4）人間が読み取りおよび編集でき、マシンで処理できる単一の形式を提供します。"
    },
    {
      "indent": 3,
      "text": "(G5) Enable automatic checking of CBOR data items for data format compliance.",
      "ja": "（G5）データ形式に準拠するために、CBORデータ項目の自動チェックを有効にします。"
    },
    {
      "indent": 3,
      "text": "(G6) Enable extraction of specific elements from CBOR data for further processing.",
      "ja": "（G6）さらに処理するために、CBORデータから特定の要素を抽出できるようにします。"
    },
    {
      "indent": 3,
      "text": "Not an original goal per se, but a convenient side effect of the JSON generic data model being a subset of the CBOR generic data model, is the fact that CDDL can also be used for describing JSON data structures (see Appendix E).",
      "ja": "本来の目標自体ではありませんが、JSON汎用データモデルのサブセットであるJSON汎用データモデルの便利な副作用は、JSONデータ構造の記述にもCDDLを使用できるという事実です（付録Eを参照）。"
    },
    {
      "indent": 3,
      "text": "This document has the following structure:",
      "ja": "このドキュメントの構造は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "The syntax of CDDL is defined in Section 3. Examples of CDDL and a related CBOR data item (\"instance\"), some of which use the JSON form, are described in Appendix H. Section 4 discusses usage of CDDL. Examples are provided throughout the text to better illustrate concept definitions. A formal definition of CDDL using ABNF grammar [RFC5234] is provided in Appendix B. Finally, a _prelude_ of standard CDDL definitions that is automatically prepended to, and thus available in, every CDDL specification is listed in Appendix D.",
      "ja": "CDDLの構文はセクション3で定義されています。CDDLおよび関連するCBORデータ項目（「インスタンス」）の例（一部はJSON形式を使用）は付録Hで説明されています。セクション4ではCDDLの使用について説明します。 概念の定義をわかりやすく説明するために、テキスト全体に例を示します。 ABNF文法[RFC5234]を使用したCDDLの正式な定義は、付録Bに記載されています。最後に、すべてのCDDL仕様に自動的に追加される標準CDDL定義の_prelude_が付録Dにリストされています。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Notation",
      "ja": "1.1. 要件の表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「NOT RECOMMENDED」、「MAY」、「OPTIONAL」 この文書の「」は、BCP 14 [RFC2119] [RFC8174]で説明されているように、ここに示すようにすべての大文字で表示される場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "ja": "1.2. 用語"
    },
    {
      "indent": 3,
      "text": "New terms are introduced in _cursive_, which is rendered in plain text as the new term surrounded by underscores. CDDL text in the running text is in \"typewriter\", which is rendered in plain text as the CDDL text in double quotes (double quotes are also used in the usual English sense; the reader is expected to disambiguate this by context).",
      "ja": "新しい用語が_cursive_に導入され、アンダースコアで囲まれた新しい用語としてプレーンテキストでレンダリングされます。 実行中のテキストのCDDLテキストは「タイプライター」であり、二重引用符で囲まれたCDDLテキストとしてプレーンテキストでレンダリングされます（二重引用符は通常の英語の意味でも使用されます。"
    },
    {
      "indent": 3,
      "text": "In this specification, the term \"byte\" is used in its now-customary sense as a synonym for \"octet\".",
      "ja": "この仕様では、「バイト」という用語は「オクテット」の同義語として現在では慣習的な意味で使用されています。"
    },
    {
      "indent": 0,
      "text": "2. The Style of Data Structure Specification",
      "section_title": true,
      "ja": "2. データ構造仕様のスタイル"
    },
    {
      "indent": 3,
      "text": "CDDL focuses on styles of specification that are in use in the community employing the data model as pioneered by JSON and now refined in CBOR.",
      "ja": "CDDLは、JSONによって開拓され、現在CBORで改良されたデータモデルを採用しているコミュニティで使用されている仕様のスタイルに焦点を当てています。"
    },
    {
      "indent": 3,
      "text": "There are a number of more or less atomic elements of a CBOR data model, such as numbers, simple values (false, true, nil), text strings, and byte strings; CDDL does not focus on specifying their structure. CDDL of course also allows adding a CBOR tag to a data item.",
      "ja": "CBORデータモデルには、数値、単純な値（false、true、nil）、テキスト文字列、バイト文字列など、多くの多かれ少なかれアトミックな要素があります。 CDDLは、その構造の指定に焦点を合わせていません。 もちろん、CDDLでは、データ項目にCBORタグを追加することもできます。"
    },
    {
      "indent": 3,
      "text": "Beyond those atomic elements, further components of a data structure definition language are the datatypes used for composition: arrays and maps in CBOR (called \"arrays\" and \"objects\" in JSON). While these are only two representation formats, they are used to specify four loosely distinguishable styles of composition:",
      "ja": "これらのアトミック要素以外に、データ構造定義言語のその他のコンポーネントは、合成に使用されるデータ型です：CBORの配列とマップ（JSONでは「配列」および「オブジェクト」と呼ばれます）。 これらは2つの表現形式にすぎませんが、大まかに区別できる4つの構成スタイルを指定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "o A _vector_: an array of elements that are mostly of the same semantics. The set of signatures associated with a signed data item is a typical application of a vector.",
      "ja": "o _vector_：ほとんど同じセマンティクスである要素の配列。 署名されたデータ項目に関連付けられた一連の署名は、ベクターの典型的なアプリケーションです。"
    },
    {
      "indent": 3,
      "text": "o A _record_: an array the elements of which have different, positionally defined semantics, as detailed in the data structure definition. A 2D point, specified as an array of an x coordinate (which comes first) and a y coordinate (coming second), is an example of a record, as is the pair of exponent (first) and mantissa (second) in a CBOR decimal fraction.",
      "ja": "o _record_：データ構造の定義で詳述されているように、その要素が異なる位置的に定義されたセマンティクスを持つ配列。 x座標（最初に来る）とy座標（2番目に来る）の配列として指定される2Dポイントは、CBOR 10進数の指数（最初）と仮数（2番目）のペアと同様に、レコードの例です。 分数。"
    },
    {
      "indent": 3,
      "text": "o A _table_: a map from a domain of map keys to a domain of map values, that are mostly of the same semantics. A set of language tags, each mapped to a text string translated to that specific language, is an example of a table. The key domain is usually not limited to a specific set by the specification but is open for the application, e.g., in a table mapping IP addresses to Media Access Control (MAC) addresses, the specification does not attempt to foresee all possible IP addresses. In a language such as JavaScript, a \"Map\" (as opposed to a plain \"Object\") would often be employed to achieve the generality of the key domain.",
      "ja": "o _table_：マップキーのドメインからマップ値のドメインへのマップ。これらはほとんど同じセマンティクスです。 言語タグのセットは、それぞれが特定の言語に翻訳されたテキスト文字列にマッピングされており、表の例です。 鍵ドメインは通常、仕様によって特定のセットに限定されませんが、たとえば、IPアドレスをMedia Access Control（MAC）アドレスにマッピングするテーブルで、アプリケーションに対して開かれています。仕様は、考えられるすべてのIPアドレスを予測しようとしません。 JavaScriptなどの言語では、キードメインの一般性を実現するために、「プレーン」（プレーンな「オブジェクト」とは対照的に）がしばしば使用されます。"
    },
    {
      "indent": 3,
      "text": "o A _struct_: a map from a domain of map keys as defined by the specification to a domain of map values the semantics of each of which is bound to a specific map key. This is what many people have in mind when they think about JSON objects; CBOR adds the ability to use map keys that are not just text strings. Structs can be used to solve problems similar to those records are used for; the use of explicit map keys facilitates optionality and extensibility.",
      "ja": "o _struct_：仕様で定義されているマップキーのドメインから、それぞれのセマンティクスが特定のマップキーにバインドされているマップ値のドメインへのマップ。 これは、多くの人がJSONオブジェクトについて考えるときに念頭に置いているものです。 CBORは、単なるテキスト文字列ではないマップキーを使用する機能を追加します。 構造体を使用して、これらのレコードが使用されるのと同様の問題を解決できます。 明示的なマップキーを使用すると、オプション性と拡張性が促進されます。"
    },
    {
      "indent": 3,
      "text": "Two important concepts provide the foundation for CDDL:",
      "ja": "2つの重要な概念がCDDLの基盤を提供します。"
    },
    {
      "indent": 3,
      "text": "1. Instead of defining all four types of composition in CDDL separately, or even defining one kind for arrays (vectors and records) and one kind for maps (tables and structs), there is only one kind of composition in CDDL: the _group_ (Section 2.1).",
      "ja": "1. CDDLで4種類すべての構成を個別に定義したり、配列（ベクトルとレコード）に1種類、マップ（テーブルと構造体）に1種類を定義する代わりに、CDDLには1種類の構成：_group_（セクション2.1 ）。"
    },
    {
      "indent": 3,
      "text": "2. The other important concept is that of a _type_. The entire CDDL specification defines a type (the one defined by its first _rule_), which formally is the set of CBOR data items that are acceptable as \"instances\" for this specification. CDDL predefines a number of basic types such as \"uint\" (unsigned integer) or \"tstr\" (text string), often making use of a simple formal notation for CBOR data items. Each value that can be expressed as a CBOR data item is also a type in its own right, e.g., \"1\". A type can be built as a _choice_ of other types, e.g., an \"int\" is either a \"uint\" or a \"nint\" (negative integer). Finally, a type can be built as an array or a map from a group.",
      "ja": "2. 他の重要な概念は、_type_の概念です。 CDDL仕様全体では、タイプ（最初の_rule_で定義されているタイプ）を定義しています。これは、この仕様の「インスタンス」として受け入れられるCBORデータ項目のセットです。 CDDLは、「uint」（符号なし整数）や「tstr」（テキスト文字列）などの多くの基本型を事前定義し、多くの場合、CBORデータ項目に単純な形式表記を使用します。 CBORデータ項目として表現できる各値も、それ自体が型（「1」など）です。 タイプは、他のタイプの_choice_として構築できます。たとえば、「int」は「uint」または「nint」（負の整数）です。 最後に、タイプは配列またはグループからのマップとして構築できます。"
    },
    {
      "indent": 3,
      "text": "The rest of this section introduces a number of basic concepts of CDDL, and Section 3 defines additional syntax. Appendix C gives a concise summary of the semantics of CDDL.",
      "ja": "このセクションの残りの部分では、CDDLの基本的な概念をいくつか紹介し、セクション3では追加の構文を定義します。 付録Cは、CDDLのセマンティクスの簡潔な要約を示しています。"
    },
    {
      "indent": 0,
      "text": "2.1. Groups and Composition in CDDL",
      "ja": "2.1. CDDLのグループと構成"
    },
    {
      "indent": 3,
      "text": "CDDL groups are lists of group _entries_, each of which can be a name/value pair or a more complex group expression (which then in turn stands for a sequence of name/value pairs). A CDDL group is a production in a grammar that matches certain sequences of name/value pairs but not others. The grammar is based on the concepts of Parsing Expression Grammars (PEGs) (see Appendix A).",
      "ja": "CDDLグループは、グループ_entries_のリストです。各リストは、名前/値のペア、またはより複雑なグループ式（順番に一連の名前/値のペア）にすることができます。 CDDLグループは、特定の名前/値ペアのシーケンスに一致するが、他のシーケンスには一致しない、文法の生成物です。 文法は、式構文解析（PEG）の概念に基づいています（付録Aを参照）。"
    },
    {
      "indent": 3,
      "text": "In an array context, only the value of the name/value pair is represented; the name is annotation only (and can be left off from the group specification if not needed). In a map context, the names become the map keys (\"member keys\").",
      "ja": "配列コンテキストでは、名前/値のペアの値のみが表されます。 名前は注釈のみです（必要ない場合はグループ仕様から除外することができます）。 マップコンテキストでは、名前はマップキー（「メンバーキー」）になります。"
    },
    {
      "indent": 3,
      "text": "In an array context, the actual sequence of elements in the group is important, as that sequence is the information that allows associating actual array elements with entries in the group. In a map context, the sequence of entries in a group is not relevant (but there is still a need to write down group entries in a sequence).",
      "ja": "配列コンテキストでは、グループ内の要素の実際のシーケンスが重要です。そのシーケンスは、実際の配列要素をグループ内のエントリに関連付けることができる情報であるためです。 マップコンテキストでは、グループ内のエントリのシーケンスは関係ありません（ただし、グループエントリをシーケンスに書き留める必要があります）。"
    },
    {
      "indent": 3,
      "text": "An array matches a specification given as a group when the group matches a sequence of name/value pairs the value parts of which exactly match the elements of the array in order.",
      "ja": "グループが名前/値のペアのシーケンスと一致し、その値の部分が配列の要素と順番に完全に一致する場合、配列はグループとして指定された仕様と一致します。"
    },
    {
      "indent": 3,
      "text": "A map matches a specification given as a group when the group matches a sequence of name/value pairs such that all of these name/value pairs are present in the map and the map has no name/value pair that is not covered by the group.",
      "ja": "これらのすべての名前/値のペアがマップに存在し、マップがグループによってカバーされていない名前/値のペアを持たないように、グループが名前/値のペアのシーケンスと一致する場合、マップはグループとして指定された仕様と一致します 。"
    },
    {
      "indent": 3,
      "text": "A simple example of using a group directly in a map definition is:",
      "ja": "マップ定義でグループを直接使用する簡単な例は次のとおりです。"
    },
    {
      "indent": 29,
      "text": "person = {\n  age: int,\n  name: tstr,\n  employer: tstr,\n}",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 1: Using a Group Directly in a Map",
      "ja": "図1：マップでグループを直接使用する"
    },
    {
      "indent": 3,
      "text": "The three entries of the group are written between the curly braces that create the map: here, \"age\", \"name\", and \"employer\" are the names that turn into the map key text strings, and \"int\" and \"tstr\" (text string) are the types of the map values under these keys.",
      "ja": "グループの3つのエントリは、マップを作成する中括弧の間に書き込まれます。ここで、「年齢」、「名前」、および「雇用者」は、マップのキーテキスト文字列、および「int」および「tstr \"（テキスト文字列）は、これらのキーの下のマップ値のタイプです。"
    },
    {
      "indent": 3,
      "text": "A group by itself (without creating a map around it) can be placed in (round) parentheses and given a name by using it in a rule:",
      "ja": "グループは（それを囲むマップを作成せずに）単独で（丸い）括弧内に配置し、ルールで使用することで名前を付けることができます。"
    },
    {
      "indent": 29,
      "text": "pii = (\n  age: int,\n  name: tstr,\n  employer: tstr,\n)",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Figure 2: A Basic Group",
      "ja": "図2：基本的なグループ"
    },
    {
      "indent": 3,
      "text": "This separate, named group definition allows us to rephrase Figure 1 as:",
      "ja": "この個別の名前付きグループ定義により、図1を次のように言い換えることができます。"
    },
    {
      "indent": 32,
      "text": "person = {\n  pii\n}",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 3: Using a Group by Name",
      "ja": "図3：名前によるグループの使用"
    },
    {
      "indent": 3,
      "text": "Note that the (curly) braces signify the creation of a map; the groups themselves are neutral as to whether they will be used in a map or an array.",
      "ja": "（中括弧）はマップの作成を意味することに注意してください。 グループ自体は、マップまたはアレイのどちらで使用されるかについて中立です。"
    },
    {
      "indent": 3,
      "text": "As shown in Figure 1, the parentheses for groups are optional when there is some other set of brackets present. Note that they can still be used, leading to this not-so-realistic, but perfectly valid, example:",
      "ja": "図1に示すように、他のブラケットセットが存在する場合、グループの括弧はオプションです。 これらはまだ使用可能であり、それほど現実的ではないが完全に有効な例につながることに注意してください。"
    },
    {
      "indent": 29,
      "text": "person = {(\n  age: int,\n  name: tstr,\n  employer: tstr,\n)}",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 4: Using a Parenthesized Group in a Map",
      "ja": "図4：マップでのかっこ付きグループの使用"
    },
    {
      "indent": 3,
      "text": "Groups can be used to factor out common parts of structs, e.g., instead of writing specifications in copy/paste style, such as in Figure 5, one can factor out the common subgroup, choose a name for it, and write only the specific parts into the individual maps (Figure 6).",
      "ja": "グループを使用して、構造体の共通部分を抽出できます。たとえば、図5のようにコピー/貼り付けスタイルで仕様を記述する代わりに、共通サブグループを抽出し、名前を選択して、特定の部分のみを記述できます 個々のマップに追加します（図6）。"
    },
    {
      "indent": 26,
      "text": "person = {\n  age: int,\n  name: tstr,\n  employer: tstr,\n}",
      "raw": true
    },
    {
      "indent": 26,
      "text": "dog = {\n  age: int,\n  name: tstr,\n  leash-length: float,\n}",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 5: Maps with Copy/Paste",
      "ja": "図5：コピー/貼り付けを使用したマップ"
    },
    {
      "indent": 26,
      "text": "person = {\n  identity,\n  employer: tstr,\n}",
      "raw": true
    },
    {
      "indent": 26,
      "text": "dog = {\n  identity,\n  leash-length: float,\n}",
      "raw": true
    },
    {
      "indent": 26,
      "text": "identity = (\n  age: int,\n  name: tstr,\n)",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 6: Using a Group for Factorization",
      "ja": "図6：因子分解にグループを使用"
    },
    {
      "indent": 3,
      "text": "Note that the lists inside the braces in the above definitions constitute (anonymous) groups, while \"identity\" is a named group, which can then be included as part of other groups (anonymous as in the example, or themselves named).",
      "ja": "上記の定義の中括弧内のリストは（匿名）グループを構成しますが、「アイデンティティ」は名前付きグループであり、他のグループの一部として含めることができます（例のように匿名、または名前自体）。"
    },
    {
      "indent": 0,
      "text": "2.1.1. Usage",
      "ja": "2.1.1. 使用法"
    },
    {
      "indent": 3,
      "text": "Groups are the instrument used in composing data structures with CDDL. It is a matter of style in defining those structures whether to define groups (anonymously) right in their contexts or whether to define them in a separate rule and to reference them with their respective name (possibly more than once).",
      "ja": "グループは、CDDLでデータ構造を構成する際に使用される手段です。 コンテキストでグループを（匿名で）定義するか、別のルールでグループを定義し、それぞれの名前（複数回）で参照するかは、これらの構造を定義する際のスタイルの問題です。"
    },
    {
      "indent": 3,
      "text": "With this, one is allowed to define all small parts of their data structures and compose bigger protocol data units with those or to have only one big protocol data unit that has all definitions ad hoc where needed.",
      "ja": "これにより、データ構造の小さな部分をすべて定義し、それらで大きなプロトコルデータユニットを構成したり、必要に応じてすべての定義をアドホックにした大きなプロトコルデータユニットを1つだけ持つことができます。"
    },
    {
      "indent": 0,
      "text": "2.1.2. Syntax",
      "ja": "2.1.2. 構文"
    },
    {
      "indent": 3,
      "text": "The composition syntax is intended to be concise and easy to read:",
      "ja": "構成構文は、簡潔で読みやすいように意図されています。"
    },
    {
      "indent": 3,
      "text": "o The start and end of a group can be marked by \"(\" and \")\".",
      "ja": "o グループの開始と終了は、「（」と「）」でマークできます。"
    },
    {
      "indent": 3,
      "text": "o Definitions of entries inside of a group are noted as follows: _keytype => valuetype,_ (read \"keytype maps to valuetype\"). The comma is actually optional (not just in the final entry), but it is considered good style to set it. The double arrow can be replaced by a colon in the common case of directly using a text string or integer literal as a key; see Section 3.5.1. This is also the common way of naming elements of an array just for documentation; see Section 3.4.",
      "ja": "o グループ内のエントリの定義は、次のように記載されています。_keytype=> valuetype、_（「keytype maps to valuetype」を参照）。 コンマは実際にはオプションです（最後のエントリだけでなく）が、設定するのに適したスタイルと見なされます。 二重矢印は、テキスト文字列または整数リテラルをキーとして直接使用する一般的なケースではコロンに置き換えることができます。 セクション3.5.1。を参照してください。 これは、ドキュメント化のためだけに配列の要素に名前を付ける一般的な方法でもあります。 セクション3.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "A basic entry consists of a _keytype_ and a _valuetype_, both of which are types (Section 2.2); this entry matches any name/value pair the name of which is in the keytype and the value of which is in the valuetype.",
      "ja": "基本的なエントリは_keytype_と_valuetype_で構成され、どちらもタイプです（セクション2.2）。 このエントリは、名前がキータイプにあり、値が値タイプにある名前/値のペアと一致します。"
    },
    {
      "indent": 3,
      "text": "A group defined as a sequence of group entries matches any sequence of name/value pairs that is composed by concatenation in order of what the entries match.",
      "ja": "グループエントリのシーケンスとして定義されたグループは、エントリが一致する順序で連結によって構成される名前/値のペアのシーケンスと一致します。"
    },
    {
      "indent": 3,
      "text": "A group definition can also contain choices between groups; see Section 2.2.2.",
      "ja": "グループ定義には、グループ間の選択肢を含めることもできます。 セクション2.2.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.2. Types",
      "ja": "2.2. タイプ"
    },
    {
      "indent": 0,
      "text": "2.2.1. Values",
      "ja": "2.2.1. 値"
    },
    {
      "indent": 3,
      "text": "Values such as numbers and strings can be used in place of a type. (For instance, this is a very common thing to do for a key type, common enough that CDDL provides additional convenience syntax for this.)",
      "ja": "型の代わりに数値や文字列などの値を使用できます。 （たとえば、これはキータイプに対して行う非常に一般的なことであり、CDDLが追加の便利な構文を提供するのに十分なほど一般的です。）"
    },
    {
      "indent": 3,
      "text": "The value notation is based on the C language, but does not offer all the syntactic variations (see Appendix B for details). The value notation for numbers inherits from C the distinction between integer values (no fractional part or exponent given -- NR1 [ISO6093]; \"NR\" stands for \"numerical representation\") and floating-point values (where a fractional part, an exponent, or both are present -- NR2 or NR3), so the type \"1\" does not include any floating-point numbers while the types \"1e3\" and \"1.5\" are both floating-point numbers and do not include any integer numbers.",
      "ja": "値の表記はC言語に基づいていますが、すべての構文のバリエーションを提供しているわけではありません（詳細については、付録Bを参照してください）。 数値の値表記は、Cから整数値（小数部または指数の指定なし-NR1 [ISO6093];「NR」は「数値表現」を表す）と浮動小数点値（小数部、指数 、または両方が存在します-NR2またはNR3）。したがって、タイプ \"1\"には浮動小数点数は含まれませんが、タイプ \"1e3\"および \"1.5\"は両方とも浮動小数点数であり、整数を含みません。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Choices",
      "ja": "2.2.2. 選択肢"
    },
    {
      "indent": 3,
      "text": "Many places that allow a type also allow a choice between types, delimited by a \"/\" (slash). The entire choice construct can be put into parentheses if this is required to make the construction unambiguous (please see Appendix B for details of the CDDL grammar).",
      "ja": "タイプを許可する多くの場所では、「/」（スラッシュ）で区切られたタイプの選択も許可されます。 構造を明確にするために必要な場合は、選択構造全体を括弧に入れることができます（CDDL文法の詳細については、付録Bを参照してください）。"
    },
    {
      "indent": 3,
      "text": "Choices of values can be used to express enumerations:",
      "ja": "値の選択を使用して、列挙を表現できます。"
    },
    {
      "indent": 12,
      "text": "attire = \"bow tie\" / \"necktie\" / \"Internet attire\"\nprotocol = 6 / 17",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Analogous to types, CDDL also allows choices between groups, delimited by a \"//\" (double slash). Note that the \"//\" operator binds much more weakly than the other CDDL operators, so each line within \"delivery\" in the following example is its own alternative in the group choice:",
      "ja": "タイプと同様に、CDDLでは「//」（ダブルスラッシュ）で区切られたグループ間の選択も可能です。 「//」演算子は、他のCDDL演算子よりもはるかに弱くバインドするため、次の例の「配信」内の各行は、グループ選択における独自の代替であることに注意してください。"
    },
    {
      "indent": 19,
      "text": "address = { delivery }",
      "raw": true
    },
    {
      "indent": 19,
      "text": "delivery = (\nstreet: tstr, ? number: uint, city //\npo-box: uint, city //\nper-pickup: true )",
      "raw": true
    },
    {
      "indent": 19,
      "text": "city = (\nname: tstr, zip-code: uint\n)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A group choice matches the union of the sets of name/value pair sequences that the alternatives in the choice can.",
      "ja": "グループの選択肢は、選択肢の選択肢ができる名前/値のペアのシーケンスの集合の和集合に一致します。"
    },
    {
      "indent": 3,
      "text": "For both type choices and group choices, additional alternatives can be added to a rule later in separate rules by using \"/=\" and \"//=\", respectively, instead of \"=\":",
      "ja": "タイプの選択とグループの選択の両方について、「=」の代わりに「/ =」と「// =」をそれぞれ使用することにより、後で別のルールで追加の代替をルールに追加できます。"
    },
    {
      "indent": 17,
      "text": "attire /= \"swimwear\"",
      "ja": "服装/ = \"水着\""
    },
    {
      "indent": 17,
      "text": "delivery //= (\nlat: float, long: float, drone-type: tstr\n)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "It is not an error if a name is first used with a \"/=\" or \"//=\" (there is no need to \"create it\" with \"=\").",
      "ja": "最初に「/ =」または「// =」で名前を使用する場合はエラーではありません（「=」で「作成」する必要はありません）。"
    },
    {
      "indent": 0,
      "text": "2.2.2.1. Ranges",
      "ja": "2.2.2.1. 範囲"
    },
    {
      "indent": 3,
      "text": "Instead of naming all the values that make up a choice, CDDL allows building a _range_ out of two values that are in an ordering relationship: a lower bound (first value) and an upper bound (second value). A range can be inclusive of both bounds given (denoted by joining two values by \"..\"), or it can include the lower bound and exclude the upper bound (denoted by instead using \"...\"). If the lower bound exceeds the upper bound, the resulting type is the empty set (this behavior can be desirable when generics (Section 3.10) are being used).",
      "ja": "CDDLでは、選択肢を構成するすべての値に名前を付ける代わりに、順序関係にある2つの値（下限（最初の値）と上限（2番目の値））から_range_を構築できます。 範囲には、指定された両方の境界を含めることができます（「..」で2つの値を結合することによって示されます）。 下限が上限を超える場合、結果の型は空のセットになります（ジェネリック（セクション3.10）が使用されている場合、この動作は望ましい場合があります）。"
    },
    {
      "indent": 9,
      "text": "device-address = byte\nmax-byte = 255\nbyte = 0..max-byte ; inclusive range\nfirst-non-byte = 256\nbyte1 = 0...first-non-byte ; byte1 is equivalent to byte",
      "raw": true
    },
    {
      "indent": 3,
      "text": "CDDL currently only allows ranges between integers (matching integer values) or between floating-point values (matching floating-point values). If both are needed in a type, a type choice between the two kinds of ranges can be (clumsily) used:",
      "ja": "CDDLは現在、整数間の範囲（整数値と一致）または浮動小数点値間の範囲（浮動小数点値と一致）のみを許可しています。 型で両方が必要な場合は、2種類の範囲の間の型の選択を（不便に）使用できます。"
    },
    {
      "indent": 16,
      "text": "int-range = 0..10 ; only integers match\nfloat-range = 0.0..10.0 ; only floats match\nBAD-range1 = 0..10.0 ; NOT DEFINED\nBAD-range2 = 0.0..10 ; NOT DEFINED\nnumeric-range = int-range / float-range",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(See also the control operators .lt/.ge and .le/.gt in Section 3.8.6.)",
      "ja": "（セクション3.8.6の制御演算子.lt / .geおよび.le / .gtも参照してください。）"
    },
    {
      "indent": 3,
      "text": "Note that the dot is a valid name continuation character in CDDL, so",
      "ja": "ドットはCDDLで有効な名前継続文字であることに注意してください。"
    },
    {
      "indent": 6,
      "text": "min..max",
      "ja": "最小。最大"
    },
    {
      "indent": 3,
      "text": "is not a range expression but a single name. When using a name as the left-hand side of a range operator, use spacing as in",
      "ja": "範囲式ではなく、単一の名前です。 範囲演算子の左側に名前を使用する場合は、次のようにスペースを使用します"
    },
    {
      "indent": 6,
      "text": "min .. max",
      "ja": "最小..最大"
    },
    {
      "indent": 3,
      "text": "to separate off the range operator.",
      "ja": "範囲演算子を分離します。"
    },
    {
      "indent": 0,
      "text": "2.2.2.2. Turning a Group into a Choice",
      "ja": "2.2.2.2. グループを選択に変える"
    },
    {
      "indent": 3,
      "text": "Some choices are built out of large numbers of values, often integers, each of which is best given a semantic name in the specification. Instead of naming each of these integers and then accumulating them into a choice, CDDL allows building a choice from a group by prefixing it with an \"&\" character:",
      "ja": "いくつかの選択肢は、多くの場合整数である値から構築されます。それぞれの値には、仕様でセマンティック名を付けるのが最適です。 これらの整数のそれぞれに名前を付けてから選択項目に蓄積する代わりに、CDDLは「＆」文字を接頭辞としてグループから選択項目を作成できます。"
    },
    {
      "indent": 14,
      "text": "terminal-color = &basecolors\nbasecolors = (\n  black: 0,  red: 1,  green: 2,  yellow: 3,\n  blue: 4,  magenta: 5,  cyan: 6,  white: 7,\n)\nextended-color = &(\n  basecolors,\n  orange: 8,  pink: 9,  purple: 10,  brown: 11,\n)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "As with the use of groups in arrays (Section 3.4), the member names have only documentary value (in particular, they might be used by a tool when displaying integers that are taken from that choice).",
      "ja": "配列でのグループの使用（セクション3.4）の場合と同様に、メンバー名にはドキュメンタリー値のみが含まれます（特に、その選択から取得された整数を表示するときにツールによって使用される場合があります）。"
    },
    {
      "indent": 0,
      "text": "2.2.3. Representation Types",
      "ja": "2.2.3. 表現タイプ"
    },
    {
      "indent": 3,
      "text": "CDDL allows the specification of a data item type by referring to the CBOR representation (specifically, to major types and additional information; see Section 2 of [RFC7049]). How this is used should be evident from the prelude (Appendix D): a hash mark (\"#\") optionally followed by a number from 0 to 7 identifying the major type, which then can be followed by a dot and a number specifying the additional information. This construction specifies the set of values that can be serialized in CBOR (i.e., \"any\"), by the given major type if one is given, or by the given major type with the additional information if both are given. Where a major type of 6 (Tag) is used, the type of the tagged item can be specified by appending it in parentheses.",
      "ja": "CDDLでは、CBOR表現（特に、主要なタイプと追加情報。[RFC7049]のセクション2を参照）を参照することにより、データ項目タイプを指定できます。 これがどのように使用されるかは、プレリュード（付録D）から明らかです。ハッシュマーク（「＃」）には、オプションでメジャータイプを識別する0から7までの数字が続き、その後にドットと数字を指定できます 追加情報。 この構造は、CBORでシリアル化できる値のセット（つまり、「any」）、指定されたメジャータイプ（指定されている場合）、または指定されたメジャータイプと追加情報（両方が指定されている場合）を指定します。 メジャータイプ6（タグ）が使用されている場合、タグ付きアイテムのタイプは、かっこで追加することで指定できます。"
    },
    {
      "indent": 3,
      "text": "Note that although this notation is based on the CBOR serialization, it is about a set of values at the data model level, e.g., \"#7.25\" specifies the set of values that can be represented as half-precision floats; it does not mandate that these values also do have to be serialized as half-precision floats: CDDL does not provide any language means to restrict the choice of serialization variants. This also enables the use of CDDL with JSON, which uses a fundamentally different way of serializing (some of) the same values.",
      "ja": "この表記はCBORシリアル化に基づいていますが、データモデルレベルの値のセットに関するものであることに注意してください。たとえば、「＃7.25」は半精度の浮動小数点として表現できる値のセットを指定します。 これらの値も半精度浮動小数点数としてシリアル化する必要はありません。CDDLは、シリアル化バリアントの選択を制限する言語手段を提供しません。 これにより、JSONでCDDLを使用することも可能になり、同じ値（の一部）をシリアル化する根本的に異なる方法が使用されます。"
    },
    {
      "indent": 3,
      "text": "It may be necessary to make use of representation types outside the prelude, e.g., a specification could start by making use of an existing tag in a more specific way or could define a new tag not defined in the prelude:",
      "ja": "プレリュード以外の表現タイプを使用する必要がある場合があります。たとえば、より具体的な方法で既存のタグを使用することで仕様を開始したり、プレリュードで定義されていない新しいタグを定義したりできます。"
    },
    {
      "indent": 6,
      "text": "my_breakfast = #6.55799(breakfast)   ; cbor-any is too general!\nbreakfast = cereal / porridge\ncereal = #6.998(tstr)\nporridge = #6.999([liquid, solid])\nliquid = milk / water\nmilk = 0\nwater = 1\nsolid = tstr",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.2.4. Root Type",
      "ja": "2.2.4. ルートタイプ"
    },
    {
      "indent": 3,
      "text": "There is no special syntax to identify the root of a CDDL data structure definition: that role is simply taken by the first rule defined in the file.",
      "ja": "CDDLデータ構造定義のルートを識別するための特別な構文はありません。その役割は、ファイルで定義された最初のルールによって単純に引き受けられます。"
    },
    {
      "indent": 3,
      "text": "This is motivated by the usual top-down approach for defining data structures, decomposing a big data structure unit into smaller parts; however, except for the root type, there is no need to strictly follow this sequence.",
      "ja": "これは、データ構造を定義し、大きなデータ構造単位を小さな部分に分解するための通常のトップダウンアプローチが動機となっています。 ただし、ルートタイプを除いて、厳密にこのシーケンスに従う必要はありません。"
    },
    {
      "indent": 3,
      "text": "(Note that there is no way to use a group as a root -- it must be a type.)",
      "ja": "（グループをルートとして使用する方法はないことに注意してください。それはタイプでなければなりません。）"
    },
    {
      "indent": 0,
      "text": "3. Syntax",
      "section_title": true,
      "ja": "3. 構文"
    },
    {
      "indent": 3,
      "text": "In this section, the overall syntax of CDDL is shown, alongside some examples just illustrating syntax. (The definition does not attempt to be overly formal; refer to Appendix B for details.)",
      "ja": "このセクションでは、CDDLの全体的な構文と、構文を示したいくつかの例を示します。 （定義は過度に正式なものではありません。詳細については、付録Bを参照してください。）"
    },
    {
      "indent": 0,
      "text": "3.1. General Conventions",
      "ja": "3.1. 一般的な規約"
    },
    {
      "indent": 3,
      "text": "The basic syntax is inspired by ABNF [RFC5234], with the following:",
      "ja": "基本的な構文は、ABNF [RFC5234]に触発されており、次のものがあります。"
    },
    {
      "indent": 3,
      "text": "o Rules, whether they define groups or types, are defined with a name, followed by an equals sign \"=\" and the actual definition according to the respective syntactic rules of that definition.",
      "ja": "o グループまたはタイプを定義するルールは、名前で定義され、その後に等号「=」とその定義のそれぞれの構文ルールに従った実際の定義が続きます。"
    },
    {
      "indent": 3,
      "text": "o A name can consist of any of the characters from the set {\"A\" to \"Z\", \"a\" to \"z\", \"0\" to \"9\", \"_\", \"-\", \"@\", \".\", \"$\"}, starting with an alphabetic character (including \"@\", \"_\", \"$\") and ending in such a character or a digit.",
      "ja": "o 名前は、{\"A\"から \"Z\"、 \"a\"から \"z\"、 \"0\"から \"9\"、 \"_\"、 \"-\"、 \"@\"、 \"のいずれかの文字で構成できます。 。 \"、\" $ \"}、アルファベット文字（\" @ \"、\" _ \"、\" $ \"を含む）で始まり、そのような文字または数字で終わる。"
    },
    {
      "indent": 6,
      "text": "* Names are case sensitive.",
      "ja": "* 名前は大文字と小文字が区別されます。"
    },
    {
      "indent": 6,
      "text": "* It is preferred style to start a name with a lowercase letter.",
      "ja": "* 小文字で名前を開始するのが好ましいスタイルです。"
    },
    {
      "indent": 6,
      "text": "* The hyphen is preferred over the underscore (except in a \"bareword\" (Section 3.5.1), where the semantics may actually require an underscore).",
      "ja": "* ハイフンはアンダースコアよりも優先されます（セマンティクスが実際にアンダースコアを必要とする可能性がある「ベアワード」（セクション3.5.1）を除く）。"
    },
    {
      "indent": 6,
      "text": "* The period may be useful for larger specifications, to express some module structure (as in \"tcp.throughput\" vs. \"udp.throughput\").",
      "ja": "* ピリオドは、より大きな仕様で、いくつかのモジュール構造を表現するのに役立ちます（「tcp.throughput」と「udp.throughput」のように）。"
    },
    {
      "indent": 6,
      "text": "* A number of names are predefined in the CDDL prelude, as listed in Appendix D.",
      "ja": "* 付録Dにリストされているように、CDDLプレリュードには多くの名前が事前定義されています。"
    },
    {
      "indent": 6,
      "text": "* Rule names (types or groups) do not appear in the actual CBOR encoding, but names used as \"barewords\" in member keys do.",
      "ja": "* ルール名（タイプまたはグループ）は実際のCBORエンコーディングには表示されませんが、メンバーキーで「ベアワード」として使用される名前は表示されます。"
    },
    {
      "indent": 3,
      "text": "o Comments are started by a \";\" (semicolon) character and finish at the end of a line (LF or CRLF).",
      "ja": "o コメントは「;」で始まります （セミコロン）文字と行の終わり（LFまたはCRLF）で終了します。"
    },
    {
      "indent": 3,
      "text": "o Except within strings, whitespace (spaces, newlines, and comments) is used to separate syntactic elements for readability (and to separate identifiers, range operators, or numbers that follow each other); it is otherwise completely optional.",
      "ja": "o 文字列内を除き、空白（スペース、改行、コメント）を使用して、読みやすくするために構文要素を分離します（さらに、識別子、範囲演算子、または連続する数字を分離します）。 それ以外は完全にオプションです。"
    },
    {
      "indent": 3,
      "text": "o Hexadecimal numbers are preceded by \"0x\" (without quotes) and are case insensitive. Similarly, binary numbers are preceded by \"0b\".",
      "ja": "o 16進数の前には \"0x\"（引用符なし）が付き、大文字と小文字は区別されません。 同様に、2進数の前には「0b」が付きます。"
    },
    {
      "indent": 3,
      "text": "o Text strings are enclosed by double quotation '\"' characters. They follow the conventions for strings as defined in Section 7 of [RFC8259]. (ABNF users may want to note that there is no support in CDDL for the concept of case insensitivity in text strings; if necessary, regular expressions can be used (Section 3.8.3).)",
      "ja": "o テキスト文字列は、二重引用符「 \"」文字で囲まれています。[RFC8259]のセクション7で定義されている文字列の規則に従います。 文字列;必要に応じて、正規表現を使用できます（セクション3.8.3）。"
    },
    {
      "indent": 3,
      "text": "o Byte strings are enclosed by single quotation \"'\" characters and may be prefixed by \"h\" or \"b64\". If unprefixed, the string is interpreted as with a text string, except that single quotes must be escaped and that the resulting UTF-8 bytes are marked as a byte string (major type 2). If prefixed as \"h\" or \"b64\", the string is interpreted as a sequence of pairs of hex digits (base16; see Section 8 of [RFC4648]) or a base64(url) string (Section 4 or Section 5 of [RFC4648]), respectively (as with the diagnostic notation in Section 6 of [RFC7049]; cf. Appendix G.2); any whitespace present within the string (including comments) is ignored in the prefixed case.",
      "ja": "o バイト文字列は、単一引用符「 '」文字で囲まれ、「h」または「b64」が前に付く場合があります。 接頭辞を付けない場合、文字列はテキスト文字列と解釈されますが、単一引用符をエスケープする必要があり、結果のUTF-8バイトがバイト文字列（メジャータイプ2）としてマークされる点が異なります。 「h」または「b64」のプレフィックスが付いている場合、文字列は16進数のペアのシーケンス（base16。[RFC4648]のセクション8を参照）またはbase64（url）ストリング（[RFC4648のセクション4またはセクション5 ]）、それぞれ（[RFC7049]のセクション6の診断表記と同様、付録G.2を参照）; 文字列内に存在する空白（コメントを含む）は、接頭辞付きのケースでは無視されます。"
    },
    {
      "indent": 3,
      "text": "o CDDL uses UTF-8 [RFC3629] for its encoding. Processing of CDDL does not involve Unicode normalization processes.",
      "ja": "o CDDLは、エンコードにUTF-8 [RFC3629]を使用します。 CDDLの処理には、Unicode正規化プロセスは含まれません。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 20,
      "text": "; This is a comment\nperson = { g }",
      "raw": true
    },
    {
      "indent": 20,
      "text": "g = (\n  \"name\": tstr,\n  age: int,  ; \"age\" is a bareword\n)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2. Occurrence",
      "ja": "3.2. 発生"
    },
    {
      "indent": 3,
      "text": "An optional _occurrence_ indicator can be given in front of a group entry. It is either (1) one of the characters \"?\" (optional), \"*\" (zero or more), or \"+\" (one or more) or (2) of the form n*m, where n and m are optional unsigned integers and n is the lower limit (default 0) and m is the upper limit (default no limit) of occurrences.",
      "ja": "オプションの_occurrence_インジケータは、グループエントリの前に指定できます。 （1）文字「？」のいずれかです。 （オプション）、「*」（ゼロ以上）、または「+」（1つ以上）または（2）形式のn * m。ここで、nおよびmはオプションの符号なし整数で、nは下限（デフォルトは0） ）およびmは、オカレンスの上限（デフォルトは無制限）です。"
    },
    {
      "indent": 3,
      "text": "If no occurrence indicator is specified, the group entry is to occur exactly once (as if 1*1 were specified). A group entry with an occurrence indicator matches sequences of name/value pairs that are composed by concatenating a number of sequences that the basic group entry matches, where the number needs to be allowed by the occurrence indicator.",
      "ja": "オカレンスインジケータが指定されていない場合、グループエントリは1回だけ発生します（1 * 1が指定された場合）。 オカレンスインジケータを持つグループエントリは、基本グループエントリが一致するシーケンスの数を連結することで構成される名前/値のペアのシーケンスに一致します。この番号は、オカレンスインジケータによって許可される必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that CDDL, outside any directives/annotations that could possibly be defined, does not make any prescription as to whether arrays or maps use definite-length or indefinite-length encoding. That is, there is no correlation between leaving the size of an array \"open\" in the spec and the fact that it is then interchanged with definite or indefinite length.",
      "ja": "CDDLは、定義される可能性のあるディレクティブ/注釈の外側で、配列またはマップが定長または不定長エンコードを使用するかどうかに関する規定を作成しないことに注意してください。 つまり、仕様で配列のサイズを「開いた」ままにしておくことと、その配列が確定または不定の長さと交換されるという事実との間に相関関係はありません。"
    },
    {
      "indent": 3,
      "text": "Please also note that CDDL can describe flexibility that the data model of the target representation does not have. This is rather obvious for JSON but is also relevant for CBOR:",
      "ja": "また、CDDLは、ターゲット表現のデータモデルにはない柔軟性を記述することができることに注意してください。 これはJSONではかなり明白ですが、CBORにも関連しています。"
    },
    {
      "indent": 27,
      "text": "apartment = {\n  kitchen: size,\n  * bedroom: size,\n}\nsize = float ; in m2",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The previous specification does not mean that CBOR is changed to allow using the key \"bedroom\" more than once. In other words, due to the restrictions imposed by the data model, the third line pretty much turns into:",
      "ja": "以前の仕様では、CBORが変更されて、キー「ベッドルーム」を複数回使用できるようになったわけではありません。 つまり、データモデルによって課せられる制限のため、3行目は次のようになります。"
    },
    {
      "indent": 29,
      "text": "? bedroom: size,",
      "ja": "？ ベッドルーム：サイズ、"
    },
    {
      "indent": 3,
      "text": "(Occurrence indicators beyond one are still useful in maps for groups that allow a variety of keys.)",
      "ja": "（1を超えるオカレンスインジケータは、さまざまなキーを許可するグループのマップで引き続き有用です。）"
    },
    {
      "indent": 0,
      "text": "3.3. Predefined Names for Types",
      "ja": "3.3. 型の事前定義された名前"
    },
    {
      "indent": 3,
      "text": "CDDL predefines a number of names. This subsection summarizes these names, but please see Appendix D for the exact definitions.",
      "ja": "CDDLは多くの名前を事前に定義しています。 このサブセクションではこれらの名前を要約していますが、正確な定義については付録Dをご覧ください。"
    },
    {
      "indent": 3,
      "text": "The following keywords for primitive datatypes are defined:",
      "ja": "プリミティブデータ型の次のキーワードが定義されています。"
    },
    {
      "indent": 3,
      "text": "\"bool\" Boolean value (major type 7, additional information 20 or 21).",
      "ja": "\"bool\"ブール値（メジャータイプ7、追加情報20または21）。"
    },
    {
      "indent": 3,
      "text": "\"uint\" An unsigned integer (major type 0).",
      "ja": "\"uint\"符号なし整数（メジャータイプ0）。"
    },
    {
      "indent": 3,
      "text": "\"nint\" A negative integer (major type 1).",
      "ja": "\"nint\"負の整数（メジャータイプ1）。"
    },
    {
      "indent": 3,
      "text": "\"int\" An unsigned integer or a negative integer.",
      "ja": "\"int\"符号なし整数または負の整数。"
    },
    {
      "indent": 3,
      "text": "\"float16\" A number representable as a half-precision float [IEEE754] (major type 7, additional information 25).",
      "ja": "\"float16\"半精度浮動小数点数として表現できる数値[IEEE754]（メジャータイプ7、追加情報25）。"
    },
    {
      "indent": 3,
      "text": "\"float32\" A number representable as a single-precision float [IEEE754] (major type 7, additional information 26).",
      "ja": "\"float32\"単精度浮動小数点数として表現できる数値[IEEE754]（メジャータイプ7、追加情報26）。"
    },
    {
      "indent": 3,
      "text": "\"float64\" A number representable as a double-precision float [IEEE754] (major type 7, additional information 27).",
      "ja": "\"float64\"倍精度浮動小数点数として表現可能な数値[IEEE754]（メジャータイプ7、追加情報27）。"
    },
    {
      "indent": 3,
      "text": "\"float\" One of float16, float32, or float64.",
      "ja": "\"float\" float16、float32、またはfloat64のいずれか。"
    },
    {
      "indent": 3,
      "text": "\"bstr\" or \"bytes\" A byte string (major type 2).",
      "ja": "\"bstr\"または \"bytes\"バイト文字列（メジャータイプ2）。"
    },
    {
      "indent": 3,
      "text": "\"tstr\" or \"text\" Text string (major type 3).",
      "ja": "「tstr」または「text」テキスト文字列（メジャータイプ3）。"
    },
    {
      "indent": 3,
      "text": "(Note that there are no predefined names for arrays or maps; these are defined with the syntax given below.)",
      "ja": "（配列またはマップには事前定義された名前はないことに注意してください。これらは以下に示す構文で定義されています。）"
    },
    {
      "indent": 3,
      "text": "In addition, a number of types are defined in the prelude that are associated with CBOR tags, such as \"tdate\", \"bigint\", \"regexp\", etc.",
      "ja": "さらに、「tdate」、「bigint」、「regexp」など、CBORタグに関連付けられたプレリュードで多くのタイプが定義されています。"
    },
    {
      "indent": 0,
      "text": "3.4. Arrays",
      "ja": "3.4. 配列"
    },
    {
      "indent": 3,
      "text": "Array definitions surround a group with square brackets.",
      "ja": "配列定義は、グループを角括弧で囲みます。"
    },
    {
      "indent": 3,
      "text": "For each entry, an occurrence indicator as specified in Section 3.2 is permitted.",
      "ja": "各エントリについて、セクション3.2で指定されているオカレンスインジケータが許可されます。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 21,
      "text": "unlimited-people = [* person]\none-or-two-people = [1*2 person]\nat-least-two-people = [2* person]\nperson = (\n    name: tstr,\n    age: uint,\n)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The group \"person\" is defined in such a way that repeating it in the array each time generates alternating names and ages, so these are four valid values for a data item of type \"unlimited-people\":",
      "ja": "グループ「person」は、配列でそれを繰り返すたびに名前と年齢が交互に生成されるように定義されているため、「unlimited-people」タイプのデータ項目の有効な値は4つです。"
    },
    {
      "indent": 6,
      "text": "[\"roundlet\", 1047, \"psychurgy\", 2204, \"extrarhythmical\", 2231] [] [\"aluminize\", 212, \"climograph\", 4124] [\"penintime\", 1513, \"endocarditis\", 4084, \"impermeator\", 1669, \"coextension\", 865]",
      "ja": "[「ラウンドレット」、1047、「精神医学」、2204、「異常な」、2231] [] [「アルミ化」、212、「クリモグラフ」、4124] [「ペニンタイム」、1513、「心内膜炎」、4084、「不浸透」 、1669、「共延長」、865]"
    },
    {
      "indent": 0,
      "text": "3.5. Maps",
      "ja": "3.5. 地図"
    },
    {
      "indent": 3,
      "text": "The syntax for specifying maps merits special attention, as well as a number of optimizations and conveniences, as it is likely to be the focal point of many specifications employing CDDL. While the syntax does not strictly distinguish struct and table usage of maps, it caters specifically to each of them.",
      "ja": "マップを指定する構文は、CDDLを使用する多くの仕様の中心となる可能性が高いため、多くの最適化と利便性だけでなく、特別な注意に値します。 構文では、マップの構造体とテーブルの使用法を厳密に区別していませんが、それぞれに明確に対応しています。"
    },
    {
      "indent": 3,
      "text": "But first, let's reiterate a feature of CBOR that it has inherited from JSON: the key/value pairs in CBOR maps have no fixed ordering. (One could imagine situations where fixing the ordering may be of use. For example, a decoder could look for values related with integer keys 1, 3, and 7. If the order were fixed and the decoder encounters the key 4 without having encountered key 3, it could conclude that key 3 is not available without doing more complicated bookkeeping. Unfortunately, neither JSON nor CBOR supports this, so no attempt was made to support this in CDDL either.)",
      "ja": "ただし、最初に、JSONから継承したCBORの機能を繰り返しましょう。CBORマップのキー/値のペアには固定の順序がありません。 （順序の修正が役立つ状況を想像できます。たとえば、デコーダは整数キー1、3、および7に関連する値を探すことができます。順序が修正され、デコーダがキーに出会わずにキー4に出会う場合 3、キー3はより複雑なブックキーピングを行わないと利用できないと結論付けることができます。残念ながら、JSONもCBORもこれをサポートしていないため、CDDLでもこれをサポートする試みは行われませんでした。"
    },
    {
      "indent": 0,
      "text": "3.5.1. Structs",
      "ja": "3.5.1. 構造"
    },
    {
      "indent": 3,
      "text": "The \"struct\" usage of maps is similar to the way JSON objects are used in many JSON applications.",
      "ja": "マップの「構造」の使用法は、JSONオブジェクトが多くのJSONアプリケーションで使用される方法に似ています。"
    },
    {
      "indent": 3,
      "text": "A map is defined in the same way as that for defining an array (see Section 3.4), except for using curly braces \"{}\" instead of square brackets \"[]\".",
      "ja": "マップは、角括弧 \"[]\"の代わりに中括弧 \"{}\"を使用することを除いて、配列の定義と同じ方法で定義されます（セクション3.4を参照）。"
    },
    {
      "indent": 3,
      "text": "An occurrence indicator as specified in Section 3.2 is permitted for each group entry.",
      "ja": "セクション3.2で指定されているオカレンスインジケータは、各グループエントリに許可されます。"
    },
    {
      "indent": 3,
      "text": "The following is an example of a record with a structure embedded:",
      "ja": "以下は、構造が埋め込まれたレコードの例です。"
    },
    {
      "indent": 7,
      "text": "Geography = [\n  city           : tstr,\n  gpsCoordinates : GpsCoordinates,\n]",
      "raw": true
    },
    {
      "indent": 7,
      "text": "GpsCoordinates = {\n  longitude      : uint,            ; degrees, scaled by 10^7\n  latitude       : uint,            ; degrees, scaled by 10^7\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When encoding, the Geography record is encoded using a CBOR array with two members (the keys for the group entries are ignored), whereas the GpsCoordinates structure is encoded as a CBOR map with two key/value pairs.",
      "ja": "エンコード時に、Geographyレコードは2つのメンバーを持つCBOR配列を使用してエンコードされます（グループエントリのキーは無視されます）が、GpsCoordinates構造は2つのキー/値ペアを持つCBORマップとしてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Types used in a structure can be defined in separate rules or just in place (potentially placed inside parentheses, such as for choices). For example:",
      "ja": "構造体で使用される型は、個別のルールで定義することも、所定の位置（選択項目などの括弧内に配置される可能性がある）で定義することもできます。 例えば："
    },
    {
      "indent": 27,
      "text": "located-samples = {\n  sample-point: int,\n  samples: [+ float],\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where \"located-samples\" is the datatype to be used when referring to the struct, and \"sample-point\" and \"samples\" are the keys to be used. This is actually a complete example: an identifier that is followed by a colon can be directly used as the text string for a member key (we speak of a \"bareword\" member key), as can a double-quoted string or a number. (When other types -- in particular, types that contain more than one value -- are used as the types of keys, they are followed by a double arrow; see below.)",
      "ja": "ここで、「located-samples」は構造体を参照するときに使用されるデータ型であり、「sample-point」と「samples」は使用されるキーです。 これは実際には完全な例です。コロンが後に続く識別子は、二重引用符で囲まれた文字列または数字と同様に、メンバーキーのテキスト文字列（「bareword」メンバーキーと言います）として直接使用できます。 （他のタイプ（特に、複数の値を含むタイプ）がキーのタイプとして使用される場合、二重矢印が続きます。以下を参照してください。）"
    },
    {
      "indent": 3,
      "text": "If a text string key does not match the syntax for an identifier (or if the specifier just happens to prefer using double quotes), the text string syntax can also be used in the member key position, followed by a colon. The above example could therefore have been written with quoted strings in the member key positions.",
      "ja": "テキスト文字列キーが識別子の構文と一致しない場合（または指定子がたまたま二重引用符を使用することを好む場合）、テキスト文字列構文はメンバーキーの位置で使用でき、その後にコロンが続きます。 したがって、上記の例は、メンバーキーの位置に引用符で囲まれた文字列を使用して記述できます。"
    },
    {
      "indent": 3,
      "text": "More generally, types specified in ways other than those listed for the cases described above can be used in a key-type position by following them with a double arrow -- in particular, the double arrow is necessary if a type is named by an identifier (which, when followed by a colon, would be interpreted as a \"bareword\" and turned into a text string). A literal text string also gives rise to a type (which contains a single value only -- the given string), so another form for this example is:",
      "ja": "より一般的には、上記の場合にリストされた方法以外の方法で指定されたタイプは、二重矢印でそれらをたどることでキータイプの位置で使用できます-特に、タイプが識別子によって命名される場合は二重矢印が必要です （コロンが続く場合、「ベアワード」として解釈され、テキスト文字列に変換されます）。 リテラルテキスト文字列は、型（単一の値のみを含む-指定された文字列）も生成するため、この例の別の形式は次のとおりです。"
    },
    {
      "indent": 25,
      "text": "located-samples = {\n  \"sample-point\" => int,\n  \"samples\" => [+ float],\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "See Section 3.5.4 below for how the colon (\":\") shortcut described here also adds some implied semantics.",
      "ja": "ここで説明するコロン（ \"：\"）ショートカットが暗黙的なセマンティクスを追加する方法については、以下のセクション3.5.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "A better way to demonstrate the use of the double arrow may be:",
      "ja": "二重矢印の使用を示すより良い方法は次のとおりです。"
    },
    {
      "indent": 13,
      "text": "located-samples = {\n  sample-point: int,\n  samples: [+ float],\n  * equipment-type => equipment-tolerances,\n}\nequipment-type = [name: tstr, manufacturer: tstr]\nequipment-tolerances = [+ [float, float]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The example below defines a struct with optional entries: display name (as a text string), the name components first name and family name (as text strings), and age information (as an unsigned integer).",
      "ja": "以下の例では、オプションのエントリを持つ構造体を定義しています。表示名（テキスト文字列として）、名前コンポーネントの名と姓（テキスト文字列として）、年齢情報（符号なし整数として）。"
    },
    {
      "indent": 26,
      "text": "PersonalData = {\n  ? displayName: tstr,\n  NameComponents,\n  ? age: uint,\n}",
      "raw": true
    },
    {
      "indent": 26,
      "text": "NameComponents = (\n  ? firstName: tstr,\n  ? familyName: tstr,\n)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that the group definition for NameComponents does not generate another map; instead, all four keys are directly in the struct built by PersonalData.",
      "ja": "NameComponentsのグループ定義は別のマップを生成しないことに注意してください。 代わりに、4つのキーすべてがPersonalDataによって構築された構造体に直接あります。"
    },
    {
      "indent": 3,
      "text": "In this example, all key/value pairs are optional from the perspective of CDDL. With no occurrence indicator, an entry is mandatory.",
      "ja": "この例では、CDDLの観点から、すべてのキー/値のペアはオプションです。 オカレンスインジケータがない場合、エントリは必須です。"
    },
    {
      "indent": 3,
      "text": "If the addition of more entries not specified by the current specification is desired, one can add this possibility explicitly:",
      "ja": "現在の仕様で指定されていないエントリの追加が必要な場合は、この可能性を明示的に追加できます。"
    },
    {
      "indent": 26,
      "text": "PersonalData = {\n  ? displayName: tstr,\n  NameComponents,\n  ? age: uint,\n  * tstr => any\n}",
      "raw": true
    },
    {
      "indent": 26,
      "text": "NameComponents = (\n  ? firstName: tstr,\n  ? familyName: tstr,\n)",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 7: Personal Data: Example for Extensibility",
      "ja": "図7：個人データ：拡張性の例"
    },
    {
      "indent": 3,
      "text": "The CDDL tool described in Appendix F generated the following as one acceptable instance for this specification:",
      "ja": "付録Fで説明されているCDDLツールは、この仕様の1つの許容可能なインスタンスとして以下を生成しました。"
    },
    {
      "indent": 9,
      "text": "{\"familyName\": \"agust\", \"antiforeignism\": \"pretzel\",\n \"springbuck\": \"illuminatingly\", \"exuviae\": \"ephemeris\",\n \"kilometrage\": \"frogfish\"}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(See Section 3.9 for one way to explicitly identify an extension point.)",
      "ja": "（拡張ポイントを明示的に識別する方法については、セクション3.9を参照してください。）"
    },
    {
      "indent": 0,
      "text": "3.5.2. Tables",
      "ja": "3.5.2. テーブル"
    },
    {
      "indent": 3,
      "text": "A table can be specified by defining a map with entries where the key type allows more than just a single value; for example:",
      "ja": "テーブルは、キータイプが単一の値以上のものを許可するエントリを持つマップを定義することで指定できます。 例えば："
    },
    {
      "indent": 25,
      "text": "square-roots = {* x => y}\nx = int\ny = float",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here, the key in each key/value pair has datatype x (defined as int), and the value has datatype y (defined as float).",
      "ja": "ここで、各キー/値ペアのキーのデータ型はx（intとして定義）で、値のデータ型はy（floatとして定義）です。"
    },
    {
      "indent": 3,
      "text": "If the specification does not need to restrict one of x or y (i.e., the application is free to choose per entry), it can be replaced by the predefined name \"any\".",
      "ja": "仕様でxまたはyのいずれかを制限する必要がない場合（つまり、アプリケーションはエントリごとに自由に選択できます）、定義済みの名前「any」に置き換えることができます。"
    },
    {
      "indent": 3,
      "text": "As another example, the following could be used as a conversion table converting from an integer or float to a string:",
      "ja": "別の例として、以下を整数または浮動小数点数から文字列に変換する変換テーブルとして使用できます。"
    },
    {
      "indent": 22,
      "text": "tostring = {* mynumber => tstr}\nmynumber = int / float",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.5.3. Non-deterministic Order",
      "ja": "3.5.3. 非決定的順序"
    },
    {
      "indent": 3,
      "text": "While the way arrays are matched is fully determined by the PEG formalism (see Appendix A), matching is more complicated for maps, as maps do not have an inherent order. For each candidate name/value pair that the PEG algorithm would try, a matching member is picked out of the entire map. For certain group expressions, more than one member in the map may match. Most often, this is inconsequential, as the group expression tends to consume all matches:",
      "ja": "配列のマッチング方法はPEG形式によって完全に決定されますが（付録Aを参照）、マップには固有の順序がないため、マップのマッチングはより複雑になります。 PEGアルゴリズムが試行する候補の名前/値のペアごとに、マップ全体から一致するメンバーが選択されます。 特定のグループ式では、マップ内の複数のメンバーが一致する場合があります。 グループ式はすべての一致を消費する傾向があるため、ほとんどの場合、これは重要ではありません。"
    },
    {
      "indent": 28,
      "text": "labeled-values = {\n  ? fritz: number,\n  * label => value\n}\nlabel = text\nvalue = number",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here, if any member with the key \"fritz\" is present, this will be picked by the first entry of the group; all remaining text/number members will be picked by the second entry (and if anything remains unpicked, the map does not match).",
      "ja": "ここで、キー「fritz」を持つメンバーが存在する場合、これはグループの最初のエントリによって選択されます。 残りのすべてのテキスト/番号メンバーは、2番目のエントリによって選択されます（選択されていないものがある場合、マップは一致しません）。"
    },
    {
      "indent": 3,
      "text": "However, it is possible to construct group expressions where what is actually picked is indeterminate, but does matter:",
      "ja": "ただし、実際に選択されるものが不定であるグループ式を構築することは可能ですが、重要です："
    },
    {
      "indent": 28,
      "text": "do-not-do-this = {\n  int => int,\n  int => 6,\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When this expression is matched against \"{3: 5, 4: 6}\", the first group entry might pick off the \"3: 5\", leaving \"4: 6\" for matching the second one. Or it might pick off \"4: 6\", leaving nothing for the second entry. This pathological non-determinism is caused by specifying \"more general\" before \"more specific\" and by having a general rule that only consumes a subset of the map key/value pairs that it is able to match -- both tend not to occur in real-world specifications of maps. At the time of writing, CDDL tools cannot detect such cases automatically, and for the present version of the CDDL specification, the specification writer is simply urged to not write pathologically non-deterministic specifications.",
      "ja": "この式が「{3：5、4：6}」と一致する場合、最初のグループエントリは「3：5」を選択し、「4：6」は2番目のエントリと一致します。 または、「4：6」を選択して、2番目のエントリに何も残さない場合があります。 この病理学的非決定性は、「より一般的」を「より具体的」の前に指定し、一致できるマップキー/値ペアのサブセットのみを消費する一般的なルールがあるために発生します。 マップの実際の仕様。 執筆の時点では、CDDLツールはそのようなケースを自動的に検出できず、CDDL仕様の現在のバージョンでは、仕様作成者は単に病理学的に非決定的な仕様を記述しないように促されます。"
    },
    {
      "indent": 3,
      "text": "(The astute reader will be reminded of what was called \"ambiguous content models\" in the Standard Generalized Markup Language (SGML) and \"non-deterministic content models\" in XML. That problem is related to the one described here, but the problem here is specifically caused by the lack of order in maps, something that the XML schema languages do not have to contend with. Note that RELAX NG's \"interleave\" pattern handles lack of order explicitly on the specification side, while the instances in XML always have determinate order.)",
      "ja": "（賢明な読者は、SGML（Standard Generalized Markup Language）で「曖昧なコンテンツモデル」と呼ばれ、XMLで「非決定的コンテンツモデル」と呼ばれていたものを思い出します。 RELAX NGの「インターリーブ」パターンは、XMLのインスタンスが常に決定的である一方、仕様側で明示的に順序の欠如を処理することに注意してください。 注文。）"
    },
    {
      "indent": 0,
      "text": "3.5.4. Cuts in Maps",
      "ja": "3.5.4. マップのカット"
    },
    {
      "indent": 3,
      "text": "The extensibility idiom discussed above for structs has one problem:",
      "ja": "上記の構造体の拡張性イディオムには1つの問題があります。"
    },
    {
      "indent": 24,
      "text": "extensible-map-example = {\n  ? \"optional-key\" => int,\n  * tstr => any\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In this example, there is one optional key \"optional-key\", which, when present, maps to an integer. There is also a wildcard for any future additions.",
      "ja": "この例では、オプションのキー「optional-key」が1つあり、存在する場合は整数にマッピングされます。 将来の追加のためのワイルドカードもあります。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, the data item",
      "ja": "残念ながら、データ項目"
    },
    {
      "indent": 22,
      "text": "{ \"optional-key\": \"nonsense\" }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "does match this specification: while the first entry of the group does not match, the second one (the wildcard) does. This may very well be desirable (e.g., if a future extension is to be allowed to extend the type of \"optional-key\"), but in many cases it isn't.",
      "ja": "グループの最初のエントリは一致しませんが、2番目のエントリ（ワイルドカード）は一致します。 これは非常に望ましい場合があります（たとえば、将来の拡張で「オプションキー」のタイプを拡張できるようにする場合）が、多くの場合はそうではありません。"
    },
    {
      "indent": 3,
      "text": "In anticipation of a more general potential feature called \"cuts\", CDDL allows inserting a cut \"^\" into the definition of the map entry:",
      "ja": "「カット」と呼ばれるより一般的な潜在的な機能を見越して、CDDLではマップエントリの定義にカット「^」を挿入できます。"
    },
    {
      "indent": 23,
      "text": "extensible-map-example = {\n  ? \"optional-key\" ^ => int,\n  * tstr => any\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A cut in this position means that once the member key matches the name part of an entry that carries a cut, other potential matches for the key of the member that occur in later entries in the group of the map are no longer allowed. In other words, when a group entry would pick a key/value pair based on just a matching key, it \"locks in\" the pick -- this rule applies, independently of whether the value matches as well, so when it does not, the entire map fails to match. In summary, the example above no longer matches the specification as modified with the cut.",
      "ja": "この位置でのカットは、メンバーキーがカットを含むエントリの名前部分と一致すると、マップのグループ内の後のエントリで発生するメンバーのキーの他の潜在的な一致が許可されなくなることを意味します。 つまり、グループエントリが一致するキーのみに基づいてキー/値のペアを選択する場合、選択を「ロック」します。このルールは、値が一致するかどうかに関係なく適用されるため、一致しない場合、 マップ全体が一致しません。 要約すると、上記の例は、カットで変更された仕様と一致しなくなりました。"
    },
    {
      "indent": 3,
      "text": "Since the desire for this kind of exclusive matching is so frequent, the \":\" shortcut is actually defined to include the cut semantics. So, the preceding example (including the cut) can be written more simply as:",
      "ja": "この種の排他的マッチングの要求は頻繁に発生するため、「：」ショートカットは実際にはカットセマンティクスを含むように定義されています。 したがって、前述の例（カットを含む）は、次のように簡単に記述できます。"
    },
    {
      "indent": 24,
      "text": "extensible-map-example = {\n  ? \"optional-key\": int,\n  * tstr => any\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "or even shorter, using a bareword for the key:",
      "ja": "または、さらに短い、キーにベアワードを使用します。"
    },
    {
      "indent": 24,
      "text": "extensible-map-example = {\n  ? optional-key: int,\n  * tstr => any\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.6. Tags",
      "ja": "3.6. タグ"
    },
    {
      "indent": 3,
      "text": "A type can make use of a CBOR tag (major type 6) by using the representation type notation, giving #6.nnn(type) where nnn is an unsigned integer giving the tag number and \"type\" is the type of the data item being tagged.",
      "ja": "タイプは、表現タイプ表記を使用してCBORタグ（メジャータイプ6）を使用できます。＃6.nnn（type）を指定します。ここで、nnnはタグ番号を示す符号なし整数で、「type」はデータ項目のタイプです。 タグ付けされています。"
    },
    {
      "indent": 3,
      "text": "For example, the following line from the CDDL prelude (Appendix D) defines \"biguint\" as a type name for an unsigned bignum N:",
      "ja": "たとえば、CDDLプレリュード（付録D）の次の行では、「biguint」を符号なしbignum Nの型名として定義しています。"
    },
    {
      "indent": 27,
      "text": "biguint = #6.2(bstr)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The tags defined by [RFC7049] are included in the prelude. Additional tags registered since [RFC7049] was written need to be added to a CDDL specification as needed; e.g., a binary Universally Unique Identifier (UUID) tag could be referenced as \"buuid\" in a specification after defining",
      "ja": "[RFC7049]で定義されたタグはプレリュードに含まれています。 [RFC7049]の記述以降に登録された追加タグは、必要に応じてCDDL仕様に追加する必要があります。 例えば、バイナリのUniversally Unique Identifier（UUID）タグは、定義後に仕様で「buuid」として参照できます。"
    },
    {
      "indent": 28,
      "text": "buuid = #6.37(bstr)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the following example, usage of tag 32 for URIs is optional:",
      "ja": "次の例では、URIのタグ32の使用はオプションです。"
    },
    {
      "indent": 24,
      "text": "my_uri = #6.32(tstr) / tstr",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.7. Unwrapping",
      "ja": "3.7. 開封"
    },
    {
      "indent": 3,
      "text": "The group that is used to define a map or an array can often be reused in the definition of another map or array. Similarly, a type defined as a tag carries an internal data item that one would like to refer to. In these cases, it is expedient to simply use the name of the map, array, or tag type as a handle for the group or type defined inside it.",
      "ja": "マップまたは配列の定義に使用されるグループは、多くの場合、別のマップまたは配列の定義で再利用できます。 同様に、タグとして定義された型には、参照したい内部データ項目が含まれています。 これらの場合、マップ、配列、またはタグタイプの名前を、その中に定義されたグループまたはタイプのハンドルとして単純に使用すると便利です。"
    },
    {
      "indent": 3,
      "text": "The \"unwrap\" operator (written by preceding a name by a tilde character \"~\") can be used to strip the type defined for a name by one layer, exposing the underlying group (for maps and arrays) or type (for tags).",
      "ja": "「アンラップ」演算子（名前の前にチルダ文字「〜」を付けて記述）を使用して、名前に定義されたタイプを1レイヤーで除去し、基になるグループ（マップおよび配列の場合）またはタイプ（タグの場合） 。"
    },
    {
      "indent": 3,
      "text": "For example, an application might want to define a basic header and an advanced header. Without unwrapping, this might be done as follows:",
      "ja": "たとえば、アプリケーションで基本的なヘッダーと高度なヘッダーを定義する場合があります。 展開せずに、これは次のように実行できます。"
    },
    {
      "indent": 13,
      "text": "basic-header-group = (\n  field1: int,\n  field2: text,\n)",
      "raw": true
    },
    {
      "indent": 13,
      "text": "basic-header = [ basic-header-group ]",
      "raw": true
    },
    {
      "indent": 13,
      "text": "advanced-header = [\n  basic-header-group,\n  field3: bytes,\n  field4: number, ; as in the tagged type \"time\"\n]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Unwrapping simplifies this to:",
      "ja": "アンラップすると、これが次のように簡単になります。"
    },
    {
      "indent": 28,
      "text": "basic-header = [\n  field1: int,\n  field2: text,\n]",
      "raw": true
    },
    {
      "indent": 28,
      "text": "advanced-header = [\n  ~basic-header,\n  field3: bytes,\n  field4: ~time,\n]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(Note that leaving out the first unwrap operator in the latter example would lead to nesting the basic-header in its own array inside the advanced-header, while, with the unwrapped basic-header, the definition of the group inside basic-header is essentially repeated inside advanced-header, leading to a single array. This can be used for various applications often solved by inheritance in programming languages. The effect of unwrapping can also be described as \"threading in\" the group or type inside the referenced type, which suggested the thread-like \"~\" character.)",
      "ja": "（後者の例で最初のunwrap演算子を省略すると、basic-headerが独自の配列のadvanced-header内にネストされることになりますが、unwrapped basic-headerでは、basic-header内のグループの定義は 高度なヘッダー内で本質的に繰り返され、単一の配列になります。これは、プログラミング言語の継承によって解決されることが多いさまざまなアプリケーションで使用できます。 これは、スレッドのような「〜」文字を示唆していました。）"
    },
    {
      "indent": 0,
      "text": "3.8. Controls",
      "ja": "3.8. コントロール"
    },
    {
      "indent": 3,
      "text": "A _control_ allows relating a _target_ type with a _controller_ type via a _control operator_.",
      "ja": "_control_は、_control operator_を介して_target_型を_controller_型に関連付けることを可能にします。"
    },
    {
      "indent": 3,
      "text": "The syntax for a control type is \"target .control-operator controller\", where control operators are special identifiers prefixed by a dot. (Note that _target_ or _controller_ might need to be parenthesized.)",
      "ja": "制御タイプの構文は「target .control-operator controller」です。制御演算子は、ドットが前に付いた特別な識別子です。 （_target_または_controller_を括弧で囲む必要があるかもしれないことに注意してください。）"
    },
    {
      "indent": 3,
      "text": "A number of control operators are defined at this point. Further control operators may be defined by new versions of this specification or by registering them according to the procedures in Section 6.1.",
      "ja": "この時点で、多くの制御演算子が定義されています。 追加の制御演算子は、この仕様の新しいバージョンまたはセクション6.1の手順に従って登録することで定義できます。"
    },
    {
      "indent": 0,
      "text": "3.8.1. Control Operator .size",
      "ja": "3.8.1. 制御演算子.size"
    },
    {
      "indent": 3,
      "text": "A \".size\" control controls the size of the target in bytes by the control type. The control is defined for text and byte strings, where it directly controls the number of bytes in the string. It is also defined for unsigned integers (see below). Figure 8 shows example usage for byte strings.",
      "ja": "「.size」コントロールは、コントロールタイプごとにターゲットのサイズをバイト単位で制御します。 このコントロールは、テキストおよびバイト文字列に対して定義され、文字列内のバイト数を直接制御します。 また、符号なし整数にも定義されています（以下を参照）。 図8は、バイト文字列の使用例を示しています。"
    },
    {
      "indent": 19,
      "text": "full-address = [[+ label], ip4, ip6]\nip4 = bstr .size 4\nip6 = bstr .size 16\nlabel = bstr .size (1..63)",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 8: Control for Size in Bytes",
      "ja": "図8：バイト単位のサイズの制御"
    },
    {
      "indent": 3,
      "text": "When applied to an unsigned integer, the \".size\" control restricts the range of that integer by giving a maximum number of bytes that should be needed in a computer representation of that unsigned integer. In other words, \"uint .size N\" is equivalent to \"0...BYTES_N\", where BYTES_N == 256**N.",
      "ja": "符号なし整数に適用すると、「。size」コントロールは、その符号なし整数のコンピューター表現に必要な最大バイト数を与えることにより、その整数の範囲を制限します。 つまり、「uint .size N」は「0 ... BYTES_N」と同等です。BYTES_N== 256 ** N。"
    },
    {
      "indent": 5,
      "text": "audio_sample = uint .size 3 ; 24-bit, equivalent to 0...16777216",
      "ja": "audio_sample = uint .size 3; 24ビット、0 ... 16777216と同等"
    },
    {
      "indent": 16,
      "text": "Figure 9: Control for Integer Size in Bytes",
      "ja": "図9：バイト単位の整数サイズの制御"
    },
    {
      "indent": 3,
      "text": "Note that, as with value restrictions in CDDL, this control is not a representation constraint; a number that fits into fewer bytes can still be represented in that form, and an inefficient implementation could use a longer form (unless that is restricted by some format constraints outside of CDDL, such as the rules in Section 3.9 of [RFC7049]).",
      "ja": "CDDLの値の制限と同様に、このコントロールは表現の制約ではないことに注意してください。 より少ないバイトに収まる数は、その形式で表すことができ、非効率的な実装では、より長い形式を使用できます（[RFC7049]のセクション3.9の規則など、CDDL以外の形式の制約によって制限されない限り）"
    },
    {
      "indent": 0,
      "text": "3.8.2. Control Operator .bits",
      "ja": "3.8.2. 制御演算子.bits"
    },
    {
      "indent": 3,
      "text": "A \".bits\" control on a byte string indicates that, in the target, only the bits numbered by a number in the control type are allowed to be set. (Bits are counted the usual way, bit number \"n\" being set in \"str\" meaning that \"(str[n >> 3] & (1 << (n & 7))) != 0\".) Similarly, a \".bits\" control on an unsigned integer \"i\" indicates that for all unsigned integers \"n\" where \"(i & (1 << n)) != 0\", \"n\" must be in the control type.",
      "ja": "バイト文字列の「.bits」コントロールは、ターゲットでは、コントロールタイプの番号で番号付けされたビットのみが設定できることを示します。 （ビットは通常の方法でカウントされ、ビット番号「n」は「str」に設定され、「（str [n >> 3]＆（1 <<（n＆7）））！= 0」を意味します。）同様に、 符号なし整数「i」の「.bits」コントロールは、すべての符号なし整数「n」に対して、「（i＆（1 << n））！= 0」、「n」が制御タイプでなければならないことを示します。"
    },
    {
      "indent": 22,
      "text": "tcpflagbytes = bstr .bits flags\nflags = &(\n  fin: 8,\n  syn: 9,\n  rst: 10,\n  psh: 11,\n  ack: 12,\n  urg: 13,\n  ece: 14,\n  cwr: 15,\n  ns: 0,\n) / (4..7) ; data offset bits",
      "raw": true
    },
    {
      "indent": 22,
      "text": "rwxbits = uint .bits rwx\nrwx = &(r: 2, w: 1, x: 0)",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 10: Control for What Bits Can Be Set",
      "ja": "図10：設定できるビットの制御"
    },
    {
      "indent": 3,
      "text": "The CDDL tool described in Appendix F generates the following ten example instances for \"tcpflagbytes\":",
      "ja": "付録Fで説明されているCDDLツールは、「tcpflagbytes」の次の10のサンプルインスタンスを生成します。"
    },
    {
      "indent": 6,
      "text": "h'906d' h'01fc' h'8145' h'01b7' h'013d' h'409f' h'018e' h'c05f' h'01fa' h'01fe'",
      "ja": "h'906d 'h'01fc' h'8145 'h'01b7' h'013d 'h'409f' h'018e 'h'c05f' h'01fa 'h'01fe'"
    },
    {
      "indent": 3,
      "text": "These examples do not illustrate that the above CDDL specification does not explicitly specify a size of two bytes: a valid all-clear instance of flag bytes could be \"h''\" or \"h'00'\" or even \"h'000000'\" as well.",
      "ja": "これらの例は、上記のCDDL仕様が2バイトのサイズを明示的に指定していないことを示していません。フラグバイトの有効なすべてクリアなインスタンスは、「h」または「h'00 '」または「h'000000」です。 \" 同じように。"
    },
    {
      "indent": 0,
      "text": "3.8.3. Control Operator .regexp",
      "ja": "3.8.3. 制御演算子.regexp"
    },
    {
      "indent": 3,
      "text": "A \".regexp\" control indicates that the text string given as a target needs to match the XML Schema Definition (XSD) regular expression given as a value in the control type. XSD regular expressions are defined in Appendix F of [W3C.REC-xmlschema-2-20041028].",
      "ja": "「.regexp」コントロールは、ターゲットとして指定されたテキスト文字列が、コントロールタイプの値として指定されたXMLスキーマ定義（XSD）正規表現と一致する必要があることを示します。 XSD正規表現は、[W3C.REC-xmlschema-2-20041028]の付録Fで定義されています。"
    },
    {
      "indent": 5,
      "text": "nai = tstr .regexp \"[A-Za-z0-9]+@[A-Za-z0-9]+(\\\\.[A-Za-z0-9]+)+\"",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 11: Control with an XSD regexp",
      "ja": "図11：XSD正規表現による制御"
    },
    {
      "indent": 3,
      "text": "An example matching this regular expression:",
      "ja": "この正規表現に一致する例："
    },
    {
      "indent": 23,
      "text": "\"N1@CH57HF.4Znqe0.dYJRN.igjf\"",
      "ja": "「N1@CH57HF.4Znqe0.dYJRN.igjf」"
    },
    {
      "indent": 0,
      "text": "3.8.3.1. Usage Considerations",
      "ja": "3.8.3.1. 使用上の考慮事項"
    },
    {
      "indent": 3,
      "text": "Note that XSD regular expressions do not support the usual \\x or \\u escapes for hexadecimal expression of bytes or Unicode code points. However, in CDDL the XSD regular expressions are contained in text strings, the literal notation for which provides \\u escapes; this should suffice for most applications that use regular expressions for text strings. (Note that this also means that there is one level of string escaping before the XSD escaping rules are applied.)",
      "ja": "XSD正規表現は、バイトまたはUnicodeコードポイントの16進表現の通常の\\ xまたは\\ uエスケープをサポートしないことに注意してください。 ただし、CDDLでは、XSD正規表現はテキスト文字列に含まれており、\\ uエスケープを提供するリテラル表記です。 これは、テキスト文字列に正規表現を使用するほとんどのアプリケーションで十分です。 （これは、XSDエスケープルールが適用される前に1レベルの文字列エスケープがあることも意味することに注意してください。）"
    },
    {
      "indent": 3,
      "text": "XSD regular expressions support character class subtraction, a feature often not found in regular expression libraries; specification writers may want to use this feature sparingly. Similar considerations apply to Unicode character classes; where these are used, the specification that employs CDDL SHOULD identify which Unicode versions are addressed.",
      "ja": "XSD正規表現は、文字クラスの減算をサポートしています。これは、正規表現ライブラリには見られない機能です。 仕様作成者は、この機能を控えめに使用したい場合があります。 同様の考慮事項がUnicode文字クラスに適用されます。 これらが使用されている場合、CDDLを使用する仕様は、どのUnicodeバージョンが対処されているかを特定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Other surprises for infrequent users of XSD regular expressions may include the following:",
      "ja": "XSD正規表現を頻繁に使用しないユーザーにとってのその他の驚きには、次のようなものがあります。"
    },
    {
      "indent": 3,
      "text": "o No direct support for case insensitivity. While case insensitivity has gone mostly out of fashion in protocol design, it is sometimes needed and then needs to be expressed manually as in \"[Cc][Aa][Ss][Ee]\".",
      "ja": "o 大文字と小文字を区別しない直接的なサポートはありません。 大文字と小文字を区別しないことは、プロトコル設計のほとんどの時代遅れになりましたが、時には必要であり、「[Cc] [Aa] [Ss] [Ee]」のように手動で表現する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The support for popular character classes such as \\w and \\d is based on Unicode character properties; this is often not what is desired in an ASCII-based protocol and thus might lead to surprises. (\\s and \\S do have their more conventional meanings, and \".\" matches any character but the line-ending characters \\r or \\n.)",
      "ja": "o \\ wや\\ dなどの一般的な文字クラスのサポートは、Unicode文字プロパティに基づいています。 これは多くの場合、ASCIIベースのプロトコルで望まれるものではないため、意外な結果になる可能性があります。 （\\ sおよび\\ Sには、より一般的な意味があり、「。」は行末文字\\ rまたは\\ n以外の任意の文字に一致します。）"
    },
    {
      "indent": 0,
      "text": "3.8.3.2. Discussion",
      "ja": "3.8.3.2. 討論"
    },
    {
      "indent": 3,
      "text": "There are many flavors of regular expression in use in the programming community. For instance, Perl-Compatible Regular Expressions (PCREs) are widely used and probably are more useful than XSD regular expressions. However, there is no normative reference for PCREs that could be used in the present document. Instead, we opt for XSD regular expressions for now. There is precedent for that choice in the IETF, e.g., in YANG [RFC7950].",
      "ja": "プログラミングコミュニティでは、さまざまな種類の正規表現が使用されています。 たとえば、Perl互換の正規表現（PCRE）は広く使用されており、おそらくXSD正規表現よりも便利です。 ただし、本書で使用できるPCREの規範的な参照はありません。 代わりに、今のところXSD正規表現を選択します。 IETF、たとえばYANG [RFC7950]には、その選択の先例があります。"
    },
    {
      "indent": 3,
      "text": "Note that CDDL uses controls as its main extension point. This creates the opportunity to add further regular expression formats in addition to the one referenced here, if desired. As an example, a proposal for a \".pcre\" control is defined in [CDDL-Freezer].",
      "ja": "CDDLはメインの拡張ポイントとしてコントロールを使用することに注意してください。 これにより、必要に応じて、ここで参照されている形式に加えて、さらに正規表現形式を追加できます。 例として、「。pcre」コントロールの提案は[CDDL-Freezer]で定義されています。"
    },
    {
      "indent": 0,
      "text": "3.8.4. Control Operators .cbor and .cborseq",
      "ja": "3.8.4. 制御演算子.cborおよび.cborseq"
    },
    {
      "indent": 3,
      "text": "A \".cbor\" control on a byte string indicates that the byte string carries a CBOR-encoded data item. Decoded, the data item matches the type given as the right-hand-side argument (type1 in the following example).",
      "ja": "バイト文字列の「.cbor」コントロールは、バイト文字列がCBORエンコードされたデータ項目を運ぶことを示します。 デコードされたデータ項目は、右側の引数として指定されたタイプ（次の例ではtype1）と一致します。"
    },
    {
      "indent": 6,
      "text": "\"bytes .cbor type1\"",
      "ja": "「bytes .cbor type1」"
    },
    {
      "indent": 3,
      "text": "Similarly, a \".cborseq\" control on a byte string indicates that the byte string carries a sequence of CBOR-encoded data items. When the data items are taken as an array, the array matches the type given as the right-hand-side argument (type2 in the following example).",
      "ja": "同様に、バイト文字列の「.cborseq」コントロールは、バイト文字列がCBORエンコードされたデータ項目のシーケンスを運ぶことを示します。 データ項目が配列として取得される場合、配列は右側の引数として指定された型（次の例ではtype2）と一致します。"
    },
    {
      "indent": 6,
      "text": "\"bytes .cborseq type2\"",
      "ja": "「bytes .cborseq type2」"
    },
    {
      "indent": 3,
      "text": "(The conversion of the encoded sequence to an array can be effected, for instance, by wrapping the byte string between the two bytes 0x9f and 0xff and decoding the wrapped byte string as a CBOR-encoded data item.)",
      "ja": "（エンコードされたシーケンスの配列への変換は、たとえば、バイト文字列を2バイト0x9fと0xffの間でラップし、ラップされたバイト文字列をCBORエンコードされたデータ項目としてデコードすることによって実行できます。）"
    },
    {
      "indent": 0,
      "text": "3.8.5. Control Operators .within and .and",
      "ja": "3.8.5. 制御演算子.withinおよび.and"
    },
    {
      "indent": 3,
      "text": "A \".and\" control on a type indicates that the data item matches both the left-hand-side type and the type given as the right-hand side. (Formally, the resulting type is the intersection of the two types given.)",
      "ja": "型の「.and」コントロールは、データ項目が左側の型と右側に指定された型の両方に一致することを示します。 （正式には、結果の型は指定された2つの型の共通部分です。）"
    },
    {
      "indent": 6,
      "text": "\"type1 .and type2\"",
      "ja": "「type1 .and type2」"
    },
    {
      "indent": 3,
      "text": "A variant of the \".and\" control is the \".within\" control, which expresses an additional intent: the left-hand-side type is meant to be a subset of the right-hand-side type.",
      "ja": "「.and」コントロールのバリアントは「.within」コントロールで、追加の意図を表します。左側のタイプは右側のタイプのサブセットを意味します。"
    },
    {
      "indent": 6,
      "text": "\"type1 .within type2\"",
      "ja": "「タイプ1。タイプ2」"
    },
    {
      "indent": 3,
      "text": "While both forms have the identical formal semantics (intersection), the intention of the \".within\" form is that the right-hand side gives guidance to the types allowed on the left-hand side, which typically is a socket (Section 3.9):",
      "ja": "どちらの形式も同じ形式のセマンティクス（交差）を持っていますが、「。within」形式の意図は、右側が通常ソケットである左側で許可されている型にガイダンスを提供することです（セクション3.9） ："
    },
    {
      "indent": 8,
      "text": "message = $message .within message-structure\nmessage-structure = [message_type, *message_option]\nmessage_type = 0..255\nmessage_option = any",
      "raw": true
    },
    {
      "indent": 8,
      "text": "$message /= [3, dough: text, topping: [* text]]\n$message /= [4, noodles: text, sauce: text, parmesan: bool]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For \".within\", a tool might flag an error if type1 allows data items that are not allowed by type2. In contrast, for \".and\", there is no expectation that type1 is already a subset of type2.",
      "ja": "「.within」の場合、type1がtype2で許可されていないデータ項目を許可すると、ツールはエラーにフラグを立てることがあります 対照的に、「。and」の場合、type1がすでにtype2のサブセットであるという期待はありません。"
    },
    {
      "indent": 0,
      "text": "3.8.6. Control Operators .lt, .le, .gt, .ge, .eq, .ne, and .default",
      "ja": "3.8.6. 制御演算子.lt、.le、.gt、.ge、.eq、.ne、および.default"
    },
    {
      "indent": 3,
      "text": "The controls .lt, .le, .gt, .ge, .eq, and .ne specify a constraint on the left-hand-side type to be a value less than, less than or equal to, greater than, greater than or equal to, equal to, or not equal to a value given as a right-hand-side type (containing just that single value). In the present specification, the first four controls (.lt, .le, .gt, and .ge) are defined only for numeric types, as these have a natural ordering relationship.",
      "ja": "コントロール.lt、.le、.gt、.ge、.eq、および.neは、左側の型の制約を、より小さい、より小さい、等しい、より大きい、より大きい、または 右側の型（その単一の値のみを含む）として指定された値と等しい、等しい、または等しくない。 本仕様では、最初の4つのコントロール（.lt、.le、.gt、および.ge）は自然な順序関係を持っているため、数値型に対してのみ定義されています。"
    },
    {
      "indent": 21,
      "text": "speed = number .ge 0  ; unit: m/s",
      "raw": true
    },
    {
      "indent": 3,
      "text": ".ne and .eq are defined for both numeric values and values of other types. If one of the values is not of a numeric type, equality is determined as follows: text strings are equal (satisfy .eq / do not satisfy .ne) if they are bytewise identical; the same applies for byte strings. Arrays are equal if they have the same number of elements, all of which are equal pairwise in order between the arrays. Maps are equal if they have the same number of key/value pairs, and there is pairwise equality between the key/value pairs between the two maps. Tagged values are equal if they both have the same tag and the values are equal. Values of simple types match if they are the same values. Numeric types that occur within arrays, maps, or tagged values are equal if their numeric value is equal and they are both integers or both floating-point values. All other cases are not equal (e.g., comparing a text string with a byte string).",
      "ja": ".neおよび.eqは、数値と他のタイプの値の両方に対して定義されます。 値の1つが数値型でない場合、等式は次のように決定されます。テキスト文字列は、バイト単位で同一であれば等しい（.eqを満たす/ .neを満たさない）。 同じことがバイト文字列にも当てはまります。 配列の要素数が同じである場合、配列は等しいです。すべての要素は、配列間で順番に等しいです。 キーと値のペアの数が同じ場合、マップは等しく、2つのマップ間のキー/値のペアはペアごとに等しくなります。 両方のタグが同じで値が等しい場合、タグ付きの値は等しくなります。 単純型の値は、同じ値であれば一致します。 配列、マップ、またはタグ付き値内で発生する数値型は、それらの数値が等しく、両方とも整数または両方が浮動小数点値である場合に等しくなります。 他のすべてのケースは等しくありません（たとえば、テキスト文字列とバイト文字列を比較します）。"
    },
    {
      "indent": 3,
      "text": "A variant of the \".ne\" control is the \".default\" control, which expresses an additional intent: the value specified by the right-hand-side type is intended as a default value for the left-hand-side type given, and the implied .ne control is there to prevent this value from being sent over the wire. This control is only meaningful when the control type is used in an optional context; otherwise, there would be no way to make use of the default value.",
      "ja": "「.ne」コントロールのバリアントは「.default」コントロールで、追加の意図を表します。右側のタイプで指定された値は、指定された左側のタイプのデフォルト値として意図されています。 暗黙の.neコントロールは、この値がネットワーク経由で送信されるのを防ぐためにあります。 このコントロールは、コントロールタイプがオプションのコンテキストで使用される場合にのみ意味があります。 そうしないと、デフォルト値を使用する方法がなくなります。"
    },
    {
      "indent": 15,
      "text": "timer = {\n  time: uint,\n  ? displayed-step: (number .gt 0) .default 1\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.9. Socket/Plug",
      "ja": "3.9. ソケット/プラグ"
    },
    {
      "indent": 3,
      "text": "For both type choices and group choices, a mechanism is defined that facilitates starting out with empty choices and assembling them later, potentially in separate files that are concatenated to build the full specification.",
      "ja": "タイプの選択とグループの選択の両方について、空の選択から開始し、後で完全な仕様を構築するために連結される別々のファイルでそれらを組み立てることを容易にするメカニズムが定義されています。"
    },
    {
      "indent": 3,
      "text": "Per convention, CDDL extension points are marked with a leading dollar sign (types) or two leading dollar signs (groups). Tools honor that convention by not raising an error if such a type or group is not defined at all; the symbol is then taken to be an empty type choice (group choice), i.e., no choice is available.",
      "ja": "慣例により、CDDL拡張ポイントには、先頭にドル記号（タイプ）または2つの先頭にドル記号（グループ）が付いています。 ツールは、そのようなタイプまたはグループがまったく定義されていない場合、エラーを発生させないことにより、その規則を尊重します。 シンボルは空のタイプの選択（グループ選択）になります。つまり、選択はできません。"
    },
    {
      "indent": 12,
      "text": "tcp-header = {seq: uint, ack: uint, * $$tcp-option}",
      "raw": true
    },
    {
      "indent": 12,
      "text": "; later, in a different file",
      "ja": "; 後で、別のファイルに"
    },
    {
      "indent": 12,
      "text": "$$tcp-option //= (\nsack: [+(left: uint, right: uint)]\n)",
      "raw": true
    },
    {
      "indent": 12,
      "text": "; and, maybe in another file",
      "ja": "; そして、おそらく別のファイルに"
    },
    {
      "indent": 12,
      "text": "$$tcp-option //= (\nsack-permitted: true\n)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Names that start with a single \"$\" are \"type sockets\", starting out as an empty type, and intended to be extended via \"/=\". Names that start with a double \"$$\" are \"group sockets\", starting out as an empty group choice, and intended to be extended via \"//=\". In either case, it is not an error if there is no definition for a socket at all; this then means there is no way to satisfy the rule (i.e., the choice is empty).",
      "ja": "単一の「$」で始まる名前は「type sockets」であり、空のタイプとして開始され、「/ =」を介して拡張されることを意図しています。 二重の「$$」で始まる名前は「グループソケット」であり、空のグループ選択として開始され、「// =」で拡張することを目的としています。 どちらの場合でも、ソケットの定義がまったくなければエラーではありません。 これは、ルールを満たす方法がないことを意味します（つまり、選択肢が空です）。"
    },
    {
      "indent": 3,
      "text": "As a convention, all definitions (plugs) for socket names must be augmentations, i.e., they must be using \"/=\" and \"//=\", respectively.",
      "ja": "慣例として、ソケット名のすべての定義（プラグ）は拡張である必要があります。つまり、それぞれ「/ =」と「// =」を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "To pick up the example illustrated in Figure 7, the socket/plug mechanism could be used as shown in Figure 12:",
      "ja": "図7に示す例を取り上げるには、図12に示すようにソケット/プラグメカニズムを使用できます。"
    },
    {
      "indent": 21,
      "text": "PersonalData = {\n  ? displayName: tstr,\n  NameComponents,\n  ? age: uint,\n  * $$personaldata-extensions\n}",
      "raw": true
    },
    {
      "indent": 21,
      "text": "NameComponents = (\n  ? firstName: tstr,\n  ? familyName: tstr,\n)",
      "raw": true
    },
    {
      "indent": 21,
      "text": "; The above already works as is. ; But then, we can add later:",
      "ja": "; 上記はすでに機能します。 ; ただし、後で追加できます。"
    },
    {
      "indent": 21,
      "text": "$$personaldata-extensions //= (\n  favorite-salsa: tstr,\n)",
      "raw": true
    },
    {
      "indent": 21,
      "text": "; and again, somewhere else:",
      "ja": "; そして再び、どこか別の場所："
    },
    {
      "indent": 21,
      "text": "$$personaldata-extensions //= (\n  shoesize: uint,\n)",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 12: Personal Data Example: Using Socket/Plug Extensibility",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.10. Generics",
      "ja": "3.10. ジェネリック"
    },
    {
      "indent": 3,
      "text": "Using angle brackets, the left-hand side of a rule can add formal parameters after the name being defined, as in:",
      "ja": "次のように、山括弧を使用して、ルールの左側で、定義する名前の後に仮パラメーターを追加できます。"
    },
    {
      "indent": 6,
      "text": "messages = message<\"reboot\", \"now\"> / message<\"sleep\", 1..100>\nmessage<t, v> = {type: t, value: v}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When using a generic rule, the formal parameters are bound to the actual arguments supplied (also using angle brackets), within the scope of the generic rule (as if there were a rule of the form parameter = argument).",
      "ja": "一般的なルールを使用する場合（フォームパラメータ=引数のルールがあったかのように）、仮パラメータは、汎用ルールの範囲内で、供給された実引数（また、角括弧を使用して）に結合されています。"
    },
    {
      "indent": 3,
      "text": "Generic rules can be used for establishing names for both types and groups.",
      "ja": "タイプとグループの両方の名前を確立するには、一般的なルールを使用できます。"
    },
    {
      "indent": 3,
      "text": "(At this time, there are some limitations to the nesting of generics in the CDDL tool described in Appendix F.)",
      "ja": "（現時点では、付録Fで説明されているCDDLツールのジェネリックのネストにはいくつかの制限があります。）"
    },
    {
      "indent": 0,
      "text": "3.11. Operator Precedence",
      "ja": "3.11. 演算子の優先順位"
    },
    {
      "indent": 3,
      "text": "As with any language that has multiple syntactic features such as prefix and infix operators, CDDL has operators that bind more tightly than others. This is becoming more complicated than, say, in ABNF, as CDDL has both types and groups, with operators that are specific to these concepts. Type operators (such as \"/\" for type choice) operate on types, while group operators (such as \"//\" for group choice) operate on groups. Types can simply be used in groups, but groups need to be bracketed (as arrays or maps) to become types. So, type operators naturally bind closer than group operators.",
      "ja": "プレフィックス演算子やインフィックス演算子などの複数の構文機能を備えた他の言語と同様に、CDDLには他の演算子よりも緊密にバインドする演算子があります。 CDDLにはタイプとグループの両方があり、これらの概念に固有の演算子があるため、これは、たとえばABNFよりも複雑になっています。 タイプ演算子（タイプ選択の「/」など）はタイプに対して機能し、グループ演算子（グループ選択の「//」など）はグループに対して機能します。 型は単にグループで使用できますが、型になるには、グループを（配列またはマップとして）括弧で囲む必要があります。 したがって、タイプ演算子はグループ演算子よりも自然に緊密にバインドします。"
    },
    {
      "indent": 3,
      "text": "For instance, in",
      "ja": "たとえば、"
    },
    {
      "indent": 6,
      "text": "t = [group1]\ngroup1 = (a / b // c / d)\na = 1 b = 2 c = 3 d = 4",
      "raw": true
    },
    {
      "indent": 3,
      "text": "group1 is a group choice between the type choice of a and b and the type choice of c and d. This becomes more relevant once member keys and/or occurrences are added in:",
      "ja": "group1は、aおよびbのタイプ選択とcおよびdのタイプ選択の間のグループ選択です。 これは、メンバーキーやオカレンスが追加されると、より関連性が高くなります。"
    },
    {
      "indent": 6,
      "text": "t = {group2}\ngroup2 = (? ab: a / b // cd: c / d)\na = 1 b = 2 c = 3 d = 4",
      "raw": true
    },
    {
      "indent": 3,
      "text": "is a group choice between the optional member \"ab\" of type a or b and the member \"cd\" of type c or d. Note that the optionality is attached to the first choice (\"ab\"), not to the second choice.",
      "ja": "タイプaまたはbのオプションのメンバー「ab」とタイプcまたはdのメンバー「cd」の間のグループ選択です。 オプション性は、2番目の選択肢ではなく、最初の選択肢（「ab」）に付加されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Similarly, in",
      "ja": "同様に、"
    },
    {
      "indent": 6,
      "text": "t = [group3]\ngroup3 = (+ a / b / c)\na = 1 b = 2 c = 3",
      "raw": true
    },
    {
      "indent": 3,
      "text": "group3 is a repetition of a type choice between a, b, and c; if just a is to be repeatable, a group choice is needed to focus the occurrence:",
      "ja": "group3は、a、b、およびcの間のタイプ選択の繰り返しです。 aのみを繰り返し可能にする場合、発生を集中させるためにグループを選択する必要があります。"
    },
    {
      "indent": 6,
      "text": "t = [group4]\ngroup4 = (+ a // b / c)\na = 1 b = 2 c = 3",
      "raw": true
    },
    {
      "indent": 3,
      "text": "group4 is a group choice between a repeatable a and a single b or c.",
      "ja": "group4は、繰り返し可能なaと単一のbまたはcの間のグループ選択です。"
    },
    {
      "indent": 3,
      "text": "A comment has been that the semantics of group3 could be counterintuitive. In general, as with many other languages with operator precedence rules, the specification writer is encouraged not to rely on them, but to insert parentheses liberally to guide readers that are not familiar with CDDL precedence rules:",
      "ja": "group3のセマンティクスは直観に反する可能性があるというコメントがありました。 一般に、演算子の優先順位ルールを持つ他の多くの言語と同様に、仕様の作成者はそれらに依存せず、CDDLの優先順位ルールに精通していない読者をガイドするために自由に括弧を挿入することが推奨されます。"
    },
    {
      "indent": 6,
      "text": "t = [group4a]\ngroup4a = ((+ a) // (b / c))\na = 1 b = 2 c = 3",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The operator precedences, in sequence of loose to tight binding, are defined in Appendix B and summarized in Table 1. (Arities given are 1 for unary prefix operators and 2 for binary infix operators.)",
      "ja": "演算子の優先順位は、緩い結合から密結合の順に、付録Bで定義され、表1にまとめられています（指定された配列は、単項前置演算子の場合は1、バイナリ中置演算子の場合は2です）。"
    },
    {
      "indent": 7,
      "text": "+----------+-------+---------------------------+------------+\n| Operator | Arity | Operates on               | Precedence |\n+----------+-------+---------------------------+------------+\n|    =     |   2   | name = type, name = group |     1      |\n|    /=    |   2   | name /= type              |     1      |\n|   //=    |   2   | name //= group            |     1      |\n|    //    |   2   | group // group            |     2      |\n|    ,     |   2   | group, group              |     3      |\n|    *     |   1   | * group                   |     4      |\n|   n*m    |   1   | n*m group                 |     4      |\n|    +     |   1   | + group                   |     4      |\n|    ?     |   1   | ? group                   |     4      |\n|    =>    |   2   | type => type              |     5      |\n|    :     |   2   | name: type                |     5      |\n|    /     |   2   | type / type               |     6      |\n|    ..    |   2   | type..type                |     7      |\n|   ...    |   2   | type...type               |     7      |\n|  .ctrl   |   2   | type .ctrl type           |     7      |\n|    &     |   1   | &group                    |     8      |\n|    ~     |   1   | ~type                     |     8      |\n+----------+-------+---------------------------+------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Table 1: Summary of Operator Precedences",
      "ja": "表1：オペレーターの優先順位の要約"
    },
    {
      "indent": 0,
      "text": "4. Making Use of CDDL",
      "section_title": true,
      "ja": "4. CDDLを利用する"
    },
    {
      "indent": 3,
      "text": "In this section, we discuss several potential ways to employ CDDL.",
      "ja": "このセクションでは、CDDLを使用するいくつかの潜在的な方法について説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. As a Guide for a Human User",
      "ja": "4.1. 人間のユーザーのためのガイドとして"
    },
    {
      "indent": 3,
      "text": "CDDL can be used to efficiently define the layout of CBOR data, such that a human implementer can easily see how data is supposed to be encoded.",
      "ja": "CDDLを使用してCBORデータのレイアウトを効率的に定義できるため、人間の実装者はデータのエンコード方法を簡単に確認できます。"
    },
    {
      "indent": 3,
      "text": "Since CDDL maps parts of the CBOR data to human-readable names, tools could be built that use CDDL to provide a human-friendly representation of the CBOR data and allow them to edit such data while remaining compliant with its CDDL definition.",
      "ja": "CDDLはCBORデータの一部を人間が読める名前にマッピングするため、CDDLを使用して人間に優しいCBORデータの表現を提供し、CDDL定義に準拠したままそのようなデータを編集できるツールを構築できます。"
    },
    {
      "indent": 0,
      "text": "4.2. For Automated Checking of CBOR Data Structures",
      "ja": "4.2. CBORデータ構造の自動チェック用"
    },
    {
      "indent": 3,
      "text": "CDDL has been specified such that a machine can handle the CDDL definition and related CBOR data (and, thus, also JSON data). For example, a machine could use CDDL to check whether or not CBOR data is compliant with its definition.",
      "ja": "CDDLは、マシンがCDDL定義および関連するCBORデータ（およびJSONデータ）を処理できるように指定されています。 たとえば、マシンはCDDLを使用して、CBORデータがその定義に準拠しているかどうかを確認できます。"
    },
    {
      "indent": 3,
      "text": "The need for thoroughness of such compliance checking depends on the application. For example, an application may decide not to check the data structure at all and use the CDDL definition solely as a means to indicate the structure of the data to the programmer.",
      "ja": "このようなコンプライアンスチェックの徹底の必要性は、アプリケーションによって異なります。 たとえば、アプリケーションは、データ構造をまったくチェックせず、CDDL定義をプログラマにデータの構造を示す手段としてのみ使用することを決定する場合があります。"
    },
    {
      "indent": 3,
      "text": "On the other hand, the application may also implement a checking mechanism that goes as far as checking that all mandatory map members are available.",
      "ja": "一方、アプリケーションは、すべての必須マップメンバーが利用可能であることを確認する限り、チェックメカニズムを実装することもできます。"
    },
    {
      "indent": 3,
      "text": "The matter of how far the data description must be enforced by an application is left to the designers and implementers of that application, keeping in mind related security considerations.",
      "ja": "アプリケーションがデータ記述をどの程度強制する必要があるかは、関連するセキュリティ上の考慮事項を考慮して、そのアプリケーションの設計者と実装者に任されています。"
    },
    {
      "indent": 3,
      "text": "In no case is it intended that a CDDL tool would be \"writing code\" for an implementation.",
      "ja": "CDDLツールが実装用の「コードを書く」ことを意図したものではありません。"
    },
    {
      "indent": 0,
      "text": "4.3. For Data Analysis Tools",
      "ja": "4.3. データ分析ツール用"
    },
    {
      "indent": 3,
      "text": "In the long run, it can be expected that more and more data will be stored using the CBOR data format.",
      "ja": "長期的には、CBORデータ形式を使用して、より多くのデータが保存されることが予想されます。"
    },
    {
      "indent": 3,
      "text": "Where there is data, there is data analysis and the need to process such data automatically. CDDL can be used for such automated data processing, allowing tools to verify data, clean it, and extract particular parts of interest from it.",
      "ja": "データがある場合、データ分析があり、そのようなデータを自動的に処理する必要があります。 CDDLはそのような自動化されたデータ処理に使用でき、ツールでデータを検証し、データをクリーニングし、データから関心のある特定の部分を抽出できます。"
    },
    {
      "indent": 3,
      "text": "Since CBOR is designed with constrained devices in mind, a likely use of it would be small sensors. An interesting use would thus be automated analysis of sensor data.",
      "ja": "CBORは制約のあるデバイスを念頭に置いて設計されているため、CBORを使用する可能性は小さなセンサーになります。 したがって、興味深い用途は、センサーデータの自動分析です。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document presents a content rules language for expressing CBOR data structures. As such, it does not bring any security issues on itself, although specifications of protocols that use CBOR naturally need security analyses when defined. General guidelines for writing security considerations are defined in [RFC3552] (BCP 72). Specifications using CDDL to define CBOR structures in protocols need to follow those guidelines. Additional topics that could be considered in a security considerations section for a specification that uses CDDL to define CBOR structures include the following:",
      "ja": "このドキュメントは、CBORデータ構造を表現するためのコンテンツルール言語を提示します。 そのため、CBORを使用するプロトコルの仕様は定義時にセキュリティ分析を必要としますが、それ自体にはセキュリティ上の問題はありません。 セキュリティに関する考慮事項を記述するための一般的なガイドラインは、[RFC3552]（BCP 72）で定義されています。 プロトコルでCBOR構造を定義するためにCDDLを使用する仕様は、これらのガイドラインに従う必要があります。 CDDLを使用してCBOR構造を定義する仕様のセキュリティに関する考慮事項セクションで検討できる追加のトピックには、次のものがあります。"
    },
    {
      "indent": 3,
      "text": "o Where could the language maybe cause confusion in a way that will enable security issues?",
      "ja": "o セキュリティの問題を可能にする方法で、言語が混乱を引き起こす可能性があるのはどこですか？"
    },
    {
      "indent": 3,
      "text": "o Where a CDDL matcher is part of the implementation of a system, the security of the system ought not depend on the correctness of the CDDL specification or CDDL implementation without any further defenses in place.",
      "ja": "o CDDLマッチャーがシステムの実装の一部である場合、システムのセキュリティは、CDDL仕様またはCDDL実装の正当性に依存するものであり、さらなる防御は必要ありません。"
    },
    {
      "indent": 3,
      "text": "o Where the CDDL specification includes extension points, the impact of extensions on the security of the system needs to be carefully considered.",
      "ja": "o CDDL仕様に拡張ポイントが含まれる場合、システムのセキュリティに対する拡張の影響を慎重に検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "Writers of CDDL specifications are strongly encouraged to value clarity and transparency of the specification over its elegance. Keep it as simple as possible while still expressing the needed data model.",
      "ja": "CDDL仕様の作成者は、その優雅さよりも仕様の明快さと透明性を重視することを強くお勧めします。 必要なデータモデルを表現しながら、できるだけシンプルに保ちます。"
    },
    {
      "indent": 3,
      "text": "A related observation about formal description techniques in general that is strongly recommended to be kept in mind by writers of CDDL specifications: just because CDDL makes it easier to handle complexity in a specification, that does not make that complexity somehow less bad (except maybe on the level of the humans having to grasp the complex structure while reading the spec).",
      "ja": "CDDL仕様の作成者は、CDDLが仕様の複雑さを簡単に処理できるため、その複雑さを多少悪くすることはないので、覚えておくことを強くお勧めします。 仕様を読みながら複雑な構造を把握しなければならない人間のレベル）。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. CDDL Control Operators Registry",
      "ja": "6.1. CDDLコントロールオペレーターレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry for control operators (Section 3.8). The \"CDDL Control Operators\" registry has been created within the \"Concise Data Definition Language (CDDL)\" registry.",
      "ja": "IANAは、制御オペレーター用のレジストリを作成しました（セクション3.8）。 「CDDL Control Operators」レジストリは、「Concise Data Definition Language（CDDL）」レジストリ内に作成されています。"
    },
    {
      "indent": 3,
      "text": "Each entry in the subregistry must include the name of the control operator (by convention given with the leading dot) and a reference to its documentation. Names must be composed of the leading dot followed by a text string conforming to the production \"id\" in Appendix B.",
      "ja": "サブレジストリ内の各エントリには、制御演算子の名前（先頭にドットを付けて表記）とそのドキュメントへの参照を含める必要があります。 名前は、先頭のドットと、付録Bのプロダクション「id」に準拠したテキスト文字列で構成する必要があります。"
    },
    {
      "indent": 3,
      "text": "Initial entries in this registry are as follows:",
      "ja": "このレジストリの初期エントリは次のとおりです。"
    },
    {
      "indent": 23,
      "text": "+----------+---------------+\n| Name     | Documentation |\n+----------+---------------+\n| .size    | RFC 8610      |\n| .bits    | RFC 8610      |\n| .regexp  | RFC 8610      |\n| .cbor    | RFC 8610      |\n| .cborseq | RFC 8610      |\n| .within  | RFC 8610      |\n| .and     | RFC 8610      |\n| .lt      | RFC 8610      |\n| .le      | RFC 8610      |\n| .gt      | RFC 8610      |\n| .ge      | RFC 8610      |\n| .eq      | RFC 8610      |\n| .ne      | RFC 8610      |\n| .default | RFC 8610      |\n+----------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "All other control operator names are Unassigned.",
      "ja": "他のすべての制御オペレーター名は未割り当てです。"
    },
    {
      "indent": 3,
      "text": "The IANA policy for additions to this registry is \"Specification Required\" as defined in [RFC8126] (which involves an Expert Review) for names that do not include an internal dot and \"IETF Review\" for names that do include an internal dot. The expert reviewer is specifically instructed that other Standards Development Organizations (SDOs) may want to define control operators that are specific to their fields (e.g., based on a binary syntax already in use at the SDO); the review process should strive to facilitate such an undertaking.",
      "ja": "このレジストリに追加するためのIANAポリシーは、[RFC8126]（エキスパートレビューを含む）で定義されているように、内部ドットを含まない名前に対して「仕様が必要」であり、内部ドットを含む名前に対して「IETFレビュー」です。 専門の査読者は、他の標準開発機関（SDO）がそのフィールドに固有の制御演算子を定義したい場合があることを特に指示されています（例えば、SDOですでに使用されているバイナリ構文に基づいて） レビュープロセスは、そのような取り組みを促進するよう努力する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7. 参考文献"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "ja": "7.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[ISO6093] ISO, \"Information processing -- Representation of numerical values in character strings for information interchange\", ISO 6093, 1985.",
      "ja": "[ISO6093] ISO、「情報処理-情報交換のための文字列内の数値の表現」、ISO 6093、1985"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3552] Rescorla, E. and B. Korver, \"Guidelines for Writing RFC Text on Security Considerations\", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003, <https://www.rfc-editor.org/info/rfc3552>.",
      "ja": "[RFC3552] Rescorla、E。、およびB. Korver、「セキュリティに関する考慮事項に関するRFCテキストの作成ガイドライン」、BCP 72、RFC 3552、DOI 10.17487 / RFC3552、2003年7月、<https://www.rfc-editor.org/ info / rfc3552>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <https://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<https://www.rfc-editor.org/info/ rfc3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <https://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson、S。、「The Base16、Base32、およびBase64 Data Encodings」、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<https://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <https://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234] Crocker、D.、Ed。 およびP. Overell、「構文仕様の拡張BNF：ABNF」、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<https://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7049] Bormann, C. and P. Hoffman, \"Concise Binary Object Representation (CBOR)\", RFC 7049, DOI 10.17487/RFC7049, October 2013, <https://www.rfc-editor.org/info/rfc7049>.",
      "ja": "[RFC7049] Bormann、C.およびP. Hoffman、「簡潔なバイナリオブジェクト表現（CBOR）」、RFC 7049、DOI 10.17487 / RFC7049、2013年10月、<https://www.rfc-editor.org/info/rfc7049> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7493] Bray, T., Ed., \"The I-JSON Message Format\", RFC 7493, DOI 10.17487/RFC7493, March 2015, <https://www.rfc-editor.org/info/rfc7493>.",
      "ja": "[RFC7493]ブレイ、T。、エド、「I-JSONメッセージ形式」、RFC 7493、DOI 10.17487 / RFC7493、2015年3月、<https://www.rfc-editor.org/info/rfc7493>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126] Cotton、M.、Leiba、B。、およびT. Narten、「RFCでIANA考慮事項セクションを記述するためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487 / RFC8126、2017年6月、<https：// www .rfc-editor.org / info / rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードでの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8259] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017, <https://www.rfc-editor.org/info/rfc8259>.",
      "ja": "[RFC8259] Bray、T.、Ed。、「JavaScriptオブジェクト表記（JSON）データ交換フォーマット」、STD 90、RFC 8259、DOI 10.17487 / RFC8259、2017年12月、<https://www.rfc-editor.org / info / rfc8259>。"
    },
    {
      "indent": 3,
      "text": "[W3C.REC-xmlschema-2-20041028] Biron, P. and A. Malhotra, \"XML Schema Part 2: Datatypes Second Edition\", World Wide Web Consortium Recommendation REC-xmlschema-2-20041028, October 2004, <https://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.",
      "ja": "[W3C.REC-xmlschema-2-20041028] Biron、P. and A. Malhotra、「XML Schema Part 2：Datatypes Second Edition」、World Wide Web Consortium Recommendation REC-xmlschema-2-20041028、2004年10月、<https： //www.w3.org/TR/2004/REC-xmlschema-2-20041028>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "ja": "7.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CDDL-Freezer] Bormann, C., \"A feature freezer for the Concise Data Definition Language (CDDL)\", Work in Progress, draft-bormann-cbor-cddl-freezer-01, August 2018.",
      "ja": "[CDDL-Freezer] Bormann、C。、「簡潔なデータ定義言語（CDDL）の機能フリーザー」、Work in Progress、draft-bormann-cbor-cddl-freezer-01、2018年8月。"
    },
    {
      "indent": 3,
      "text": "[GRASP] Bormann, C., Carpenter, B., Ed., and B. Liu, Ed., \"A Generic Autonomic Signaling Protocol (GRASP)\", Work in Progress, draft-ietf-anima-grasp-15, July 2017.",
      "ja": "[GRASP] Bormann、C.、Carpenter、B.、Ed。、およびB.Liu、Ed。、「A Generic Autonomic Signaling Protocol（GRASP）」、Work in Progress、draft-ietf-anima-grasp-15、7月 2017年。"
    },
    {
      "indent": 3,
      "text": "[IEEE754] IEEE, \"IEEE Standard for Floating-Point Arithmetic\", IEEE Std 754-2008.",
      "ja": "[IEEE754] IEEE、「浮動小数点演算のIEEE標準」、IEEE Std 754-2008。"
    },
    {
      "indent": 3,
      "text": "[JCR] Newton, A. and P. Cordell, \"A Language for Rules Describing JSON Content\", Work in Progress, draft-newton-json-content-rules-09, September 2017.",
      "ja": "[JCR] Newton、A.およびP. Cordell、「JSONコンテンツを記述するルールの言語」、Work in Progress、draft-newton-json-content-rules-09、2017年9月。"
    },
    {
      "indent": 3,
      "text": "[PEG] Ford, B., \"Parsing expression grammars: a recognition-based syntactic foundation\", Proceedings of the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL '04, DOI 10.1145/964001.964011, January 2004.",
      "ja": "[PEG] Ford、B.、「構文解析構文：認識ベースの構文基盤」、プログラミング言語の原則に関する第31回ACM SIGPLAN-SIGACTシンポジウムの議事録-POPL '04、DOI 10.1145 / 964001.964011、2004年1月。"
    },
    {
      "indent": 3,
      "text": "[RELAXNG] ISO/IEC, \"Information technology -- Document Schema Definition Language (DSDL) -- Part 2: Regular-grammar-based validation -- RELAX NG\", ISO/IEC 19757-2, December 2008.",
      "ja": "[RELAXNG] ISO / IEC、「情報技術-ドキュメントスキーマ定義言語（DSDL）-パート2：正規文法ベースの検証-RELAX NG」、ISO / IEC 19757-2、2008年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC7071] Borenstein, N. and M. Kucherawy, \"A Media Type for Reputation Interchange\", RFC 7071, DOI 10.17487/RFC7071, November 2013, <https://www.rfc-editor.org/info/rfc7071>.",
      "ja": "[RFC7071] Borenstein、N.およびM. Kucherawy、\"評判交換用メディアタイプ\"、RFC7071、DOI10.17487/ RFC7071、2013年11月、<https://www.rfc-editor.org/info/rfc7071>。"
    },
    {
      "indent": 3,
      "text": "[RFC7950] Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\", RFC 7950, DOI 10.17487/RFC7950, August 2016, <https://www.rfc-editor.org/info/rfc7950>.",
      "ja": "[RFC7950] Bjorklund、M.、Ed。、「YANG 1.1データモデリング言語」、RFC 7950、DOI 10.17487 / RFC7950、2016年8月、<https://www.rfc-editor.org/info/rfc7950>。"
    },
    {
      "indent": 3,
      "text": "[RFC8007] Murray, R. and B. Niven-Jenkins, \"Content Delivery Network Interconnection (CDNI) Control Interface / Triggers\", RFC 8007, DOI 10.17487/RFC8007, December 2016, <https://www.rfc-editor.org/info/rfc8007>.",
      "ja": "[RFC8007] Murray、R。、およびB. Niven-Jenkins、「コンテンツ配信ネットワーク相互接続（CDNI）制御インターフェイス/トリガー」、RFC 8007、DOI 10.17487 / RFC8007、2016年12月、<https：//www.rfc-editor。 org / info / rfc8007>。"
    },
    {
      "indent": 3,
      "text": "[RFC8152] Schaad, J., \"CBOR Object Signing and Encryption (COSE)\", RFC 8152, DOI 10.17487/RFC8152, July 2017, <https://www.rfc-editor.org/info/rfc8152>.",
      "ja": "[RFC8152] Schaad、J。、「CBORオブジェクト署名および暗号化（COSE）」、RFC 8152、DOI 10.17487 / RFC8152、2017年7月、<https://www.rfc-editor.org/info/rfc8152>。"
    },
    {
      "indent": 3,
      "text": "[RFC8428] Jennings, C., Shelby, Z., Arkko, J., Keranen, A., and C. Bormann, \"Sensor Measurement Lists (SenML)\", RFC 8428, DOI 10.17487/RFC8428, August 2018, <https://www.rfc-editor.org/info/rfc8428>.",
      "ja": "[RFC8428] Jennings、C.、Shelby、Z.、Arkko、J.、Kerenen、A。、およびC. Bormann、「センサー測定リスト（SenML）」、RFC 8428、DOI 10.17487 / RFC8428、2018年8月、<https ：//www.rfc-editor.org/info/rfc8428>。"
    },
    {
      "indent": 3,
      "text": "[YAML] Ben-Kiki, O., Evans, C., and I. Net, \"YAML Ain't Markup Language (YAML[TM]) Version 1.2\", 3rd Edition, October 2009, <https://yaml.org/spec/1.2/spec.html>.",
      "ja": "[YAML] Ben-Kiki、O.、Evans、C。、およびI. Net、「YAML Ai n't Markup Language（YAML [TM]）Version 1.2」、第3版、2009年10月、<https：// yaml。 org / spec / 1.2 / spec.html>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Parsing Expression Grammars (PEGs)",
      "section_title": true,
      "ja": "付録A.式文法（PEG）の解析"
    },
    {
      "indent": 3,
      "text": "This appendix is normative.",
      "ja": "この付録は規範です。"
    },
    {
      "indent": 3,
      "text": "Since the 1950s, many grammar notations are based on Backus-Naur Form (BNF), a notation for context-free grammars (CFGs) within Chomsky's generative system of grammars. The Augmented Backus-Naur Form (ABNF) [RFC5234], widely used in IETF specifications and also inspiring the syntax of CDDL, is an example of this.",
      "ja": "1950年代以来、多くの文法表記は、バッカスナウア形式（BNF）に基づいています。これは、チョムスキーの文法生成システム内のコンテキストフリー文法（CFG）の表記です。 IETF仕様で広く使用され、CDDLの構文をインスパイアする拡張バッカスナウア形式（ABNF）[RFC5234]は、この例です。"
    },
    {
      "indent": 3,
      "text": "Generative grammars can express ambiguity well, but this very property may make them hard to use in recognition systems, spawning a number of subdialects that pose constraints on generative grammars to be used with parser generators; this scenario may be hard for the specification writer to manage.",
      "ja": "生成文法はあいまいさをうまく表現できますが、この特性により、認識システムでの使用が難しくなり、パーサージェネレータで使用される生成文法に制約を課す多くの副弁法が生まれます。仕様の作家が管理するため、このシナリオは難しいかもしれません。"
    },
    {
      "indent": 3,
      "text": "PEGs [PEG] provide an alternative formal foundation for describing grammars that emphasizes recognition over generation and resolves what would have been ambiguity in generative systems by introducing the concept of \"prioritized choice\".",
      "ja": "PEG [PEG]は、世代を超えた認識を強調し、「優先選択」の概念を導入することで生成システムのあいまいさを解決する文法を記述するための代替形式的基盤を提供します。"
    },
    {
      "indent": 3,
      "text": "The notation for PEGs is quite close to BNF, with the usual \"Extended BNF\" features, such as repetition, added. However, where BNF uses the unordered (symmetrical) choice operator \"|\" (incidentally notated as \"/\" in ABNF), PEG provides a prioritized choice operator \"/\". The two alternatives listed are to be tested in left-to-right order, locking in the first successful match and disregarding any further potential matches within the choice (but not disabling alternatives in choices containing this choice, as a cut (Section 3.5.4) would).",
      "ja": "PEGの表記はBNFに非常に近く、繰り返しなどの通常の「拡張BNF」機能が追加されています。 ただし、BNFが順不同（対称）選択演算子「|」を使用する場合 （偶然ABNFで「/」と表記されます）、PEGは優先順位付けされた選択演算子「/」を提供します。 リストされている2つの選択肢は、左から右の順序でテストされ、最初に成功したマッチをロックし、選択肢内の潜在的なマッチを無視します（ただし、この選択肢を含む選択肢の選択肢を無効にしないでください（セクション3.5.4 ）だろう）。"
    },
    {
      "indent": 3,
      "text": "For example, the ABNF expressions",
      "ja": "たとえば、ABNF式"
    },
    {
      "indent": 6,
      "text": "A = \"a\" \"b\" / \"a\"    (1)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "A = \"a\" / \"a\" \"b\"    (2)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "are equivalent in ABNF's original generative framework but are very different in PEG: in (2), the second alternative will never match, as any input string starting with an \"a\" will already succeed in the first alternative, locking in the match.",
      "ja": "ABNFの元の生成フレームワークでは同等ですが、PEGでは大きく異なります。（2）では、「a」で始まる入力文字列は最初の選択肢ですでに成功し、一致をロックするため、2番目の選択肢は一致しません。"
    },
    {
      "indent": 3,
      "text": "Similarly, the occurrence indicators (\"?\", \"*\", \"+\") are \"greedy\" in PEG, i.e., they consume as much input as they match (and, as a consequence, \"a* a\" in PEG notation or \"*a a\" in CDDL syntax never can match anything, as all input matching \"a\" is already consumed by the initial \"a*\", leaving nothing to match the second \"a\").",
      "ja": "同様に、発生インジケータ（「？」、「*」、「+」）はPEGでは「貪欲」です。つまり、一致するだけの入力を消費します（その結果、PEG表記では「a * a」になります） または、CDDL構文の「* aa」は、「a」に一致するすべての入力がすでに最初の「a *」によって消費され、2番目の「a」に一致するものは何も残さないため、何にも一致しません。"
    },
    {
      "indent": 3,
      "text": "Incidentally, the grammar of CDDL itself, as written in ABNF in Appendix B, can be interpreted both (1) in the generative framework on which RFC 5234 is based and (2) as a PEG. This was made possible by ordering the choices in the grammar such that a successful match made on the left-hand side of a \"/\" operator is always the intended match, instead of relying on the power of symmetrical choices (for example, note the sequence of alternatives in the rule for \"uint\", where the lone zero is behind the longer match alternatives that start with a zero).",
      "ja": "ちなみに、付録BのABNFに記述されているCDDL自体の文法は、（1）RFC 5234の基になっている生成フレームワークと（2）PEGの両方として解釈できます。 これは、対称選択の力に頼るのではなく、「/」演算子の左側で成功した一致が常に意図した一致になるように、文法の選択肢を並べることによって可能になりました（たとえば、 「uint」のルールにおける代替のシーケンス。ここで、ゼロで始まる長い一致代替の後ろに孤立したゼロがあります）。"
    },
    {
      "indent": 3,
      "text": "The syntax used for expressing the PEG component of CDDL is based on ABNF, interpreted in the obvious way with PEG semantics. The ABNF convention of notating occurrence indicators before the controlled primary, and of allowing numeric values for minimum and maximum occurrence around a \"*\" sign, is copied. While PEG is only about characters, CDDL has a richer set of elements, such as types and groups. Specifically, the following constructs map:",
      "ja": "CDDLのPEGコンポーネントを表現するために使用される構文はABNFに基づいており、PEGセマンティクスで明白な方法で解釈されます。 制御されたプライマリの前にオカレンスインジケータを表記し、「*」記号の前後の最小および最大オカレンスの数値を許可するABNF規則がコピーされます。 PEGは文字のみに関するものですが、CDDLには、タイプやグループなど、より豊富な要素セットがあります。 具体的には、次の構成体がマップします。"
    },
    {
      "indent": 7,
      "text": "+-------+-------+-------------------------------------------+\n| CDDL  | PEG   | Remark                                    |\n+-------+-------+-------------------------------------------+\n| \"=\"   | \"<-\"  | /= and //= are abbreviations              |\n| \"//\"  | \"/\"   | prioritized choice                        |\n| \"/\"   | \"/\"   | prioritized choice, limited to types only |\n| \"?\" P | P \"?\" | zero or one                               |\n| \"*\" P | P \"*\" | zero or more                              |\n| \"+\" P | P \"+\" | one or more                               |\n| A B   | A B   | sequence                                  |\n| A, B  | A B   | sequence, comma is decoration only        |\n+-------+-------+-------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The literal notation and the use of square brackets, curly braces, tildes, ampersands, and hash marks are specific to CDDL and unrelated to the conventional PEG notation. The DOT (\".\") from PEG is replaced by the unadorned \"#\" or its alias \"any\". Also, CDDL does not provide the syntactic predicate operators NOT (\"!\") or AND (\"&\") from PEG, reducing expressiveness as well as complexity.",
      "ja": "リテラル表記と角括弧、中括弧、チルダ、アンパサンド、およびハッシュマークの使用は、CDDLに固有であり、従来のPEG表記とは無関係です。 PEGのDOT（ \"。\"）は、装飾されていない \"＃\"またはそのエイリアス \"any\"に置き換えられます。 また、CDDLは、PEGの構文述語演算子NOT（ \"！\"）またはAND（ \"＆\"）を提供しないため、表現力と複雑さを軽減します。"
    },
    {
      "indent": 3,
      "text": "For more details about PEG's theoretical foundation and interesting properties of the operators such as associativity and distributivity, the reader is referred to [PEG].",
      "ja": "PEGの理論的基礎および結合性や分布性などの演算子の興味深い特性の詳細については、[PEG]を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix B. ABNF Grammar",
      "section_title": true,
      "ja": "付録B. ABNF文法"
    },
    {
      "indent": 3,
      "text": "This appendix is normative.",
      "ja": "この付録は規範です。"
    },
    {
      "indent": 3,
      "text": "The following is a formal definition of the CDDL syntax in ABNF [RFC5234]. Note that, as is defined in ABNF, the quote-delimited strings below are case insensitive (while string values and names are case sensitive in CDDL).",
      "ja": "以下は、ABNF [RFC5234]のCDDL構文の正式な定義です。 ABNFで定義されているように、以下の引用符で区切られた文字列は大文字と小文字を区別しません（CDDLでは文字列の値と名前は大文字と小文字を区別します）。"
    },
    {
      "indent": 5,
      "text": "cddl = S 1*(rule S)\nrule = typename [genericparm] S assignt S type\n     / groupname [genericparm] S assigng S grpent",
      "raw": true
    },
    {
      "indent": 5,
      "text": "typename = id groupname = id",
      "ja": "タイプ名= idグループ名= id"
    },
    {
      "indent": 5,
      "text": "assignt = \"=\" / \"/=\"\nassigng = \"=\" / \"//=\"",
      "raw": true
    },
    {
      "indent": 5,
      "text": "genericparm = \"<\" S id S *(\",\" S id S ) \">\"\ngenericarg = \"<\" S type1 S *(\",\" S type1 S ) \">\"",
      "raw": true
    },
    {
      "indent": 5,
      "text": "type = type1 *(S \"/\" S type1)",
      "raw": true
    },
    {
      "indent": 5,
      "text": "type1 = type2 [S (rangeop / ctlop) S type2]\n; space may be needed before the operator if type2 ends in a name",
      "raw": true
    },
    {
      "indent": 5,
      "text": "type2 = value\n      / typename [genericarg]\n      / \"(\" S type S \")\"\n      / \"{\" S group S \"}\"\n      / \"[\" S group S \"]\"\n      / \"~\" S typename [genericarg]\n      / \"&\" S \"(\" S group S \")\"\n      / \"&\" S groupname [genericarg]\n      / \"#\" \"6\" [\".\" uint] \"(\" S type S \")\"\n      / \"#\" DIGIT [\".\" uint]                ; major/ai\n      / \"#\"                                 ; any",
      "raw": true
    },
    {
      "indent": 5,
      "text": "rangeop = \"...\" / \"..\"",
      "ja": "rangeop = \"...\" / \"..\""
    },
    {
      "indent": 5,
      "text": "ctlop = \".\" id",
      "ja": "ctlop = \"。\" id"
    },
    {
      "indent": 5,
      "text": "group = grpchoice *(S \"//\" S grpchoice)",
      "raw": true
    },
    {
      "indent": 5,
      "text": "grpchoice = *(grpent optcom) grpent = [occur S] [memberkey S] type\n       / [occur S] groupname [genericarg]  ; preempted by above\n       / [occur S] \"(\" S group S \")\"",
      "raw": true
    },
    {
      "indent": 5,
      "text": "memberkey = type1 S [\"^\" S] \"=>\"\n          / bareword S \":\"\n          / value S \":\"",
      "raw": true
    },
    {
      "indent": 5,
      "text": "bareword = id",
      "ja": "bareword = id"
    },
    {
      "indent": 5,
      "text": "optcom = S [\",\" S]",
      "ja": "optcom = S [\"、\" S]"
    },
    {
      "indent": 5,
      "text": "occur = [uint] \"*\" [uint]\n      / \"+\"\n      / \"?\"",
      "raw": true
    },
    {
      "indent": 5,
      "text": "uint = DIGIT1 *DIGIT\n     / \"0x\" 1*HEXDIG\n     / \"0b\" 1*BINDIG\n     / \"0\"",
      "raw": true
    },
    {
      "indent": 5,
      "text": "value = number / text / bytes",
      "ja": "値=数値/テキスト/バイト"
    },
    {
      "indent": 5,
      "text": "int = [\"-\"] uint",
      "raw": true
    },
    {
      "indent": 5,
      "text": "; This is a float if it has fraction or exponent; int otherwise\nnumber = hexfloat / (int [\".\" fraction] [\"e\" exponent ])\nhexfloat = [\"-\"] \"0x\" 1*HEXDIG [\".\" 1*HEXDIG] \"p\" exponent\nfraction = 1*DIGIT\nexponent = [\"+\"/\"-\"] 1*DIGIT",
      "raw": true
    },
    {
      "indent": 5,
      "text": "text = %x22 *SCHAR %x22\nSCHAR = %x20-21 / %x23-5B / %x5D-7E / %x80-10FFFD / SESC\nSESC = \"\\\" (%x20-7E / %x80-10FFFD)",
      "raw": true
    },
    {
      "indent": 5,
      "text": "bytes = [bsqual] %x27 *BCHAR %x27\nBCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF\nbsqual = \"h\" / \"b64\" id = EALPHA *(*(\"-\" / \".\") (EALPHA / DIGIT))\nALPHA = %x41-5A / %x61-7A\nEALPHA = ALPHA / \"@\" / \"_\" / \"$\"\nDIGIT = %x30-39\nDIGIT1 = %x31-39\nHEXDIG = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\nBINDIG = %x30-31",
      "raw": true
    },
    {
      "indent": 5,
      "text": "S = *WS\nWS = SP / NL\nSP = %x20\nNL = COMMENT / CRLF\nCOMMENT = \";\" *PCHAR CRLF\nPCHAR = %x20-7E / %x80-10FFFD\nCRLF = %x0A / %x0D.0A",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 13: CDDL ABNF",
      "ja": "図13：CDDL ABNF"
    },
    {
      "indent": 3,
      "text": "Note that this ABNF does not attempt to reflect the detailed rules of what can be in a prefixed byte string.",
      "ja": "このABNFは、プレフィックス付きバイト文字列の詳細なルールを反映しようとしないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Matching Rules",
      "section_title": true,
      "ja": "付録C.一致規則"
    },
    {
      "indent": 3,
      "text": "This appendix is normative.",
      "ja": "この付録は規範です。"
    },
    {
      "indent": 3,
      "text": "In this appendix, we go through the ABNF syntax rules defined in Appendix B and briefly describe the matching semantics of each syntactic feature. In this context, an instance (data item) \"matches\" a CDDL specification if it is allowed by the CDDL specification; this is then broken down into parts of specifications (type and group expressions) and parts of instances (data items).",
      "ja": "この付録では、付録Bで定義されているABNF構文規則を調べ、各構文機能の一致するセマンティクスについて簡単に説明します。 このコンテキストでは、CDDL仕様で許可されている場合、インスタンス（データ項目）はCDDL仕様に「一致」します。 次に、これは仕様の一部（タイプおよびグループ式）とインスタンスの一部（データ項目）に分割されます。"
    },
    {
      "indent": 3,
      "text": "cddl = S 1*(rule S)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A CDDL specification is a sequence of one or more rules. Each rule gives a name to a right-hand-side expression, either a CDDL type or a CDDL group. Rule names can be used in the rule itself and/or other rules (and tools can output warnings if that is not the case). The order of the rules is significant only in two cases:",
      "ja": "CDDL仕様は、1つ以上のルールのシーケンスです。 各ルールは、CDDLタイプまたはCDDLグループのいずれかの右側の式に名前を付けます。 ルール名は、ルール自体および/または他のルールで使用できます（そうでない場合、ツールは警告を出力できます）。 ルールの順序は、次の2つの場合にのみ重要です。"
    },
    {
      "indent": 3,
      "text": "1. The first rule defines the semantics of the entire specification; hence, there is no need to give that root rule a special name or special syntax in the language (as, for example, with \"start\" in RELAX NG); its name can therefore be chosen to be descriptive. (As with all other rule names, the name of the initial rule may be used in itself or in other rules.)",
      "ja": "1. 最初のルールは、仕様全体のセマンティクスを定義します。 したがって、そのルートルールに言語の特別な名前や特別な構文を与える必要はありません（たとえば、RELAX NGの \"start\"など）。 したがって、その名前は説明的なものに選択できます。 （他のすべてのルール名と同様に、初期ルールの名前は、それ自体または他のルールで使用できます。）"
    },
    {
      "indent": 3,
      "text": "2. Where a rule contributes to a type or group choice (using \"/=\" or \"//=\"), that choice is populated in the order the rules are given; see below.",
      "ja": "2. ルールがタイプまたはグループの選択に寄与する場合（「/ =」または「// =」を使用）、その選択はルールが与えられた順序で取り込まれます。 下記参照。"
    },
    {
      "indent": 3,
      "text": "rule = typename [genericparm] S assignt S type / groupname [genericparm] S assigng S grpent",
      "ja": "rule = typename [generic parm] S assignt S type / group name [generic parm] S assigng S grpent"
    },
    {
      "indent": 3,
      "text": "typename = id groupname = id",
      "ja": "タイプ名= idグループ名= id"
    },
    {
      "indent": 3,
      "text": "A rule defines a name for a type expression (production \"type\") or\nfor a group expression (production \"grpent\"), with the intention that\nthe semantics does not change when the name is replaced by its\n(parenthesized if needed) definition.  Note that whether the name\ndefined by a rule stands for a type or a group isn't always\ndetermined by syntax alone: e.g., \"a = b\" can make \"a\" a type if \"b\"\nis a type, or a group if \"b\" is a group.  More subtly, in \"a = (b)\",\n\"a\" may be used as a type if \"b\" is a type, or as a group both when\n\"b\" is a group and when \"b\" is a type (a good convention to make the\nlatter case stand out to the human reader is to write \"a = (b,)\").\n(Note that the same dual meaning of parentheses applies within an\nexpression but often can be resolved by the context of the\nparenthesized expression.  On the more general point, it may not be\nclear immediately either whether \"b\" stands for a group or a type --\nthis semantic processing may need to span several levels of rule\ndefinitions before a determination can be made.)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "assignt = \"=\" / \"/=\"\nassigng = \"=\" / \"//=\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A plain equals sign defines the rule name as the equivalent of the expression to the right; it is an error if the name was already defined with a different expression. A \"/=\" or \"//=\" extends a named type or a group by additional choices; a number of these could be replaced by collecting all the right-hand sides and creating a single rule with a type choice or a group choice built from the right-hand sides in the order of the rules given. (It is not an error to extend a rule name that has not yet been defined; this makes the right-hand side the first entry in the choice being created.)",
      "ja": "プレーンな等号は、ルール名を右の式に相当するものとして定義します。 名前が別の式で既に定義されている場合はエラーです。 「/ =」または「// =」は、追加の選択肢によって名前付きタイプまたはグループを拡張します。 これらの多くは、すべての右側を収集し、指定されたルールの順序で右側から構築されたタイプ選択またはグループ選択を持つ単一のルールを作成することで置き換えることができます （まだ定義されていないルール名を拡張することはエラーではありません。これにより、右側が作成される選択肢の最初のエントリになります。）"
    },
    {
      "indent": 3,
      "text": "genericparm = \"<\" S id S *(\",\" S id S ) \">\"\ngenericarg = \"<\" S type1 S *(\",\" S type1 S ) \">\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Rule names can have generic parameters, which cause temporary assignments within the right-hand sides to the parameter names from the arguments given when citing the rule name.",
      "ja": "ルール名には汎用パラメーターを含めることができます。これにより、ルール名を引用するときに指定した引数からパラメーター名への右側の一時的な割り当てが発生します。"
    },
    {
      "indent": 3,
      "text": "type = type1 *(S \"/\" S type1)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A type can be given as a choice between one or more types. The choice matches a data item if the data item matches any one of the types given in the choice. The choice uses PEG semantics as discussed in Appendix A: the first choice that matches wins. (As a result, the order of rules that contribute to a single rule name can very well matter.)",
      "ja": "タイプは、1つ以上のタイプの選択肢として指定できます。 データ項目が選択肢で指定されたタイプのいずれかと一致する場合、選択肢はデータ項目と一致します。 この選択では、付録Aで説明したPEGセマンティクスを使用します。最初に一致した選択が優先されます。 （結果として、単一のルール名に寄与するルールの順序は非常に重要になります。）"
    },
    {
      "indent": 3,
      "text": "type1 = type2 [S (rangeop / ctlop) S type2]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Two types can be combined with a range operator (see below) or a control operator (see Section 3.8).",
      "ja": "2つのタイプは、範囲演算子（以下を参照）または制御演算子（セクション3.8を参照）と組み合わせることができます。"
    },
    {
      "indent": 3,
      "text": "type2 = value",
      "ja": "type2 =値"
    },
    {
      "indent": 3,
      "text": "A type can be just a single value (such as 1 or \"icecream\" or h'0815'), which matches only a data item with that specific value (no conversions defined),",
      "ja": "タイプは単一の値（1または \"icecream\"またはh'0815 'など）であり、特定の値を持つデータ項目のみに一致します（変換は定義されません）。"
    },
    {
      "indent": 6,
      "text": "/ typename [genericarg]",
      "ja": "/タイプ名[genericarg]"
    },
    {
      "indent": 3,
      "text": "or be defined by a rule giving a meaning to a name (possibly after supplying generic arguments as required by the generic parameters),",
      "ja": "または、名前に意味を与える規則によって定義される（おそらく、汎用パラメーターで必要な汎用引数を提供した後）"
    },
    {
      "indent": 6,
      "text": "/ \"(\" S type S \")\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "or be defined in a parenthesized type expression (parentheses may be necessary to override some operator precedence), or",
      "ja": "または、括弧で囲まれた型式で定義される（演算子の優先順位をオーバーライドするには括弧が必要な場合があります）、または"
    },
    {
      "indent": 6,
      "text": "/ \"{\" S group S \"}\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "a map expression, which matches a valid CBOR map the key/value pairs of which can be ordered in such a way that the resulting sequence matches the group expression, or",
      "ja": "有効なCBORマップと一致するマップ式。キー/値のペアは、結果のシーケンスがグループ式と一致するように順序付けることができます。または"
    },
    {
      "indent": 6,
      "text": "/ \"[\" S group S \"]\"",
      "ja": "/ \"[\" SグループS \"]\""
    },
    {
      "indent": 3,
      "text": "an array expression, which matches a CBOR array the elements of which -- when taken as values and complemented by a wildcard (matches anything) key each -- match the group, or",
      "ja": "CBOR配列に一致する配列式。その要素は、値として取得され、ワイルドカード（すべてに一致）キーで補完されると、グループに一致します。または"
    },
    {
      "indent": 6,
      "text": "/ \"~\" S typename [genericarg]",
      "ja": "/ \"〜\" Sタイプ名[genericarg]"
    },
    {
      "indent": 3,
      "text": "an \"unwrapped\" group (see Section 3.7), which matches the group inside a type defined as a map or an array by wrapping the group, or",
      "ja": "「ラップされていない」グループ（セクション3.7を参照）。グループをラップすることにより、マップまたは配列として定義されたタイプ内のグループに一致します。"
    },
    {
      "indent": 6,
      "text": "/ \"&\" S \"(\" S group S \")\"\n/ \"&\" S groupname [genericarg]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "an enumeration expression, which matches any value that is within the set of values that the values of the group given can take, or",
      "ja": "指定されたグループの値がとることができる値のセット内にある任意の値に一致する列挙式、または"
    },
    {
      "indent": 6,
      "text": "/ \"#\" \"6\" [\".\" uint] \"(\" S type S \")\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "a tagged data item, tagged with the \"uint\" given and containing the type given as the tagged value, or",
      "ja": "指定された「uint」でタグ付けされ、タグ付き値として指定されたタイプを含むタグ付きデータ項目、または"
    },
    {
      "indent": 6,
      "text": "/ \"#\" DIGIT [\".\" uint]                ; major/ai",
      "raw": true
    },
    {
      "indent": 3,
      "text": "a data item of a major type (given by the DIGIT), optionally constrained to the additional information given by the uint, or",
      "ja": "オプションでuintによって指定された追加情報に制限された、メジャータイプのデータ項目（DIGITによって指定）、または"
    },
    {
      "indent": 6,
      "text": "/ \"#\"                                 ; any",
      "raw": true
    },
    {
      "indent": 3,
      "text": "any data item.",
      "ja": "任意のデータ項目。"
    },
    {
      "indent": 3,
      "text": "rangeop = \"...\" / \"..\"",
      "ja": "rangeop = \"...\" / \"..\""
    },
    {
      "indent": 3,
      "text": "A range operator can be used to join two type expressions that stand for either two integer values or two floating-point values; it matches any value that is between the two values, where the first value is always included in the matching set and the second value is included for \"..\" and excluded for \"...\".",
      "ja": "範囲演算子を使用して、2つの整数値または2つの浮動小数点値を表す2つの型式を結合できます。 2つの値の間の値に一致します。最初の値は常に一致セットに含まれ、2番目の値は「..」に含まれ、「...」に除外されます。"
    },
    {
      "indent": 3,
      "text": "ctlop = \".\" id",
      "ja": "ctlop = \"。\" id"
    },
    {
      "indent": 3,
      "text": "A control operator ties a _target_ type to a _controller_ type as defined in Section 3.8. Note that control operators are an extension point for CDDL; additional documents may want to define additional control operators.",
      "ja": "セクション3.8で定義されているように、制御演算子は_target_型を_controller_型に結び付けます。 制御演算子はCDDLの拡張ポイントであることに注意してください。 追加のドキュメントでは、追加の制御演算子を定義できます。"
    },
    {
      "indent": 3,
      "text": "group = grpchoice *(S \"//\" S grpchoice)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A group matches any sequence of key/value pairs that matches any of the choices given (again using PEG semantics).",
      "ja": "グループは、与えられた選択肢のいずれかに一致するキー/値のペアのシーケンスに一致します（再びPEGセマンティクスを使用）。"
    },
    {
      "indent": 3,
      "text": "grpchoice = *(grpent optcom)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each of the component groups is given as a sequence of group entries. For a match, the sequence of key/value pairs given needs to match the sequence of group entries in the sequence given.",
      "ja": "各コンポーネントグループは、一連のグループエントリとして提供されます。 一致する場合、指定されたキー/値ペアのシーケンスは、指定されたシーケンス内のグループエントリのシーケンスと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "grpent = [occur S] [memberkey S] type",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A group entry can be given by a value type, which needs to be matched by the value part of a single element; and, optionally, a memberkey type, which needs to be matched by the key part of the element, if the memberkey is given. If the memberkey is not given, the entry can only be used for matching arrays, not for maps. (See below for how that is modified by the occurrence indicator.)",
      "ja": "グループエントリは、単一の要素の値部分と一致する必要がある値タイプによって指定できます。 また、オプションで、memberkeyタイプを指定します。これは、memberkeyが指定されている場合、要素のキー部分と一致する必要があります。 memberkeyが指定されていない場合、エントリはマップではなく一致する配列にのみ使用できます。 （発生インジケータによってそれがどのように変更されるかについては、以下を参照してください。）"
    },
    {
      "indent": 7,
      "text": "/ [occur S] groupname [genericarg] ; preempted by above",
      "ja": "/ [オカレンスS]グループ名[genericarg]; 上記に先制"
    },
    {
      "indent": 3,
      "text": "A group entry can be built from a named group, or",
      "ja": "グループエントリは、名前付きグループから構築できます。または"
    },
    {
      "indent": 7,
      "text": "/ [occur S] \"(\" S group S \")\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "from a parenthesized group, again with a possible occurrence indicator.",
      "ja": "かっこで囲まれたグループから、可能性のある発生インジケータを使用して。"
    },
    {
      "indent": 3,
      "text": "memberkey = type1 S [\"^\" S] \"=>\"\n          / bareword S \":\"\n          / value S \":\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Key types can be given by a type expression, a bareword (which stands for a type that just contains a string value created from this bareword), or a value (which stands for a type that just contains this value). A key value matches its key type if the key value is a member of the key type, unless a cut preceding it in the group applies (see Section 3.5.4 for how map matching is influenced by the presence of the cuts denoted by \"^\" or \":\" in previous entries).",
      "ja": "キータイプは、型式、ベアワード（このベアワードから作成された文字列値のみを含む型を表す）、または値（この値のみを含む型を表す）で指定できます。 キー値がキータイプのメンバーである場合、キー値はそのキータイプと一致します。ただし、グループ内でその前にあるカットが適用される場合を除きます（マップマッチングが「^ 前のエントリの「または」:)。"
    },
    {
      "indent": 3,
      "text": "bareword = id",
      "ja": "bareword = id"
    },
    {
      "indent": 3,
      "text": "A bareword is an alternative way to write a type with a single text string value; it can only be used in the syntactic context given above.",
      "ja": "ベアワードは、単一のテキスト文字列値で型を記述するための代替方法です。 上記の構文コンテキストでのみ使用できます。"
    },
    {
      "indent": 3,
      "text": "optcom = S [\",\" S]",
      "ja": "optcom = S [\"、\" S]"
    },
    {
      "indent": 3,
      "text": "(Optional commas do not influence the matching.)",
      "ja": "（オプションのコンマは一致に影響しません。）"
    },
    {
      "indent": 3,
      "text": "occur = [uint] \"*\" [uint]\n      / \"+\"\n      / \"?\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An occurrence indicator modifies the group given to its right by requiring the group to match the sequence to be matched exactly for a certain number of times (see Section 3.2) in sequence, i.e., it acts as a (possibly infinite) group choice that contains choices with the group repeated each of the occurrences times.",
      "ja": "オカレンスインジケータは、グループが特定の回数（セクション3.2を参照）正確に一致するシーケンスに一致することを要求することにより、その権利が与えられたグループを変更します。 グループの選択肢は、各出現回数を繰り返しました。"
    },
    {
      "indent": 3,
      "text": "The rest of the ABNF describes syntax for value notation that should be familiar to readers from programming languages, with the possible exception of h'..' and b64'..' for byte strings, as well as syntactic elements such as comments and line ends.",
      "ja": "ABNFの残りの部分では、バイト文字列のh '..'およびb64 '..'の例外を除き、プログラミング言語の読者に馴染みのある値表記の構文、およびコメントや行などの構文要素について説明します。 終了します。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Standard Prelude",
      "section_title": true,
      "ja": "付録D.標準プレリュード"
    },
    {
      "indent": 3,
      "text": "This appendix is normative.",
      "ja": "この付録は規範です。"
    },
    {
      "indent": 3,
      "text": "The following prelude is automatically added to each CDDL file. (Note that technically, it is a postlude, as it does not disturb the selection of the first rule as the root of the definition.)",
      "ja": "次のプレリュードは、各CDDLファイルに自動的に追加されます。 （技術的には、定義のルートとしての最初のルールの選択を妨げないため、これはポストリュードであることに注意してください。）"
    },
    {
      "indent": 18,
      "text": "any = #",
      "raw": true
    },
    {
      "indent": 18,
      "text": "uint = #0\nnint = #1\nint = uint / nint",
      "raw": true
    },
    {
      "indent": 18,
      "text": "bstr = #2\nbytes = bstr\ntstr = #3\ntext = tstr",
      "raw": true
    },
    {
      "indent": 18,
      "text": "tdate = #6.0(tstr)\ntime = #6.1(number)\nnumber = int / float\nbiguint = #6.2(bstr)\nbignint = #6.3(bstr)\nbigint = biguint / bignint\ninteger = int / bigint\nunsigned = uint / biguint\ndecfrac = #6.4([e10: int, m: integer])\nbigfloat = #6.5([e2: int, m: integer])\neb64url = #6.21(any)\neb64legacy = #6.22(any)\neb16 = #6.23(any)\nencoded-cbor = #6.24(bstr)\nuri = #6.32(tstr)\nb64url = #6.33(tstr)\nb64legacy = #6.34(tstr)\nregexp = #6.35(tstr)\nmime-message = #6.36(tstr)\ncbor-any = #6.55799(any) float16 = #7.25\nfloat32 = #7.26\nfloat64 = #7.27\nfloat16-32 = float16 / float32\nfloat32-64 = float32 / float64\nfloat = float16-32 / float64",
      "raw": true
    },
    {
      "indent": 18,
      "text": "false = #7.20\ntrue = #7.21\nbool = false / true\nnil = #7.22\nnull = nil\nundefined = #7.23",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Figure 14: CDDL Prelude",
      "ja": "図14：CDDLプレリュード"
    },
    {
      "indent": 3,
      "text": "Note that the prelude is deemed to be fixed. This means, for instance, that additional tags beyond those defined in [RFC7049], as registered, need to be defined in each CDDL file that is using them.",
      "ja": "プレリュードは修正されたと見なされることに注意してください。 これは、たとえば、[RFC7049]で定義されているもの以外の追加のタグは、登録済みとして、それらを使用する各CDDLファイルで定義する必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "A common stumbling point is that the prelude does not define a type \"string\". CBOR has byte strings (\"bytes\" in the prelude) and text strings (\"text\"), so a type that is simply called \"string\" would be ambiguous.",
      "ja": "一般的な障害は、プレリュードがタイプ「文字列」を定義しないことです。 CBORにはバイト文字列（プレリュードの「バイト」）とテキスト文字列（「テキスト」）があるため、単に「文字列」と呼ばれるタイプはあいまいになります。"
    },
    {
      "indent": 0,
      "text": "Appendix E. Use with JSON",
      "section_title": true,
      "ja": "付録E. JSONでの使用"
    },
    {
      "indent": 3,
      "text": "This appendix is normative.",
      "ja": "この付録は規範です。"
    },
    {
      "indent": 3,
      "text": "The JSON generic data model (implicit in [RFC8259]) is a subset of the generic data model of CBOR. So, one can use CDDL with JSON by limiting oneself to what can be represented in JSON. Roughly speaking, this means leaving out byte strings, tags, and simple values other than \"false\", \"true\", and \"null\", leading to the following limited prelude:",
      "ja": "JSONの汎用データモデル（[RFC8259]の暗黙）は、CBORの汎用データモデルのサブセットです。 したがって、JSONで表現できるものに制限することにより、JSONでCDDLを使用できます。 大まかに言うと、これは、バイト文字列、タグ、および「false」、「true」、および「null」以外の単純な値を除外することを意味し、次の制限された前奏曲につながります。"
    },
    {
      "indent": 22,
      "text": "any = #",
      "raw": true
    },
    {
      "indent": 22,
      "text": "uint = #0\nnint = #1\nint = uint / nint",
      "raw": true
    },
    {
      "indent": 22,
      "text": "tstr = #3\ntext = tstr",
      "raw": true
    },
    {
      "indent": 22,
      "text": "number = int / float",
      "ja": "数値= int / float"
    },
    {
      "indent": 22,
      "text": "float16 = #7.25\nfloat32 = #7.26\nfloat64 = #7.27\nfloat16-32 = float16 / float32\nfloat32-64 = float32 / float64\nfloat = float16-32 / float64",
      "raw": true
    },
    {
      "indent": 22,
      "text": "false = #7.20\ntrue = #7.21\nbool = false / true\nnil = #7.22\nnull = nil",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 15: JSON-Compatible Subset of CDDL Prelude",
      "ja": "図15：CDDLプレリュードのJSON互換サブセット"
    },
    {
      "indent": 3,
      "text": "(The major types given here do not have a direct meaning in JSON, but they can be interpreted as CBOR major types translated through Section 4 of [RFC7049].)",
      "ja": "（ここで与えられた主要な型はJSONでは直接の意味を持ちませんが、[RFC7049]のセクション4で翻訳されたCBORの主要な型として解釈できます。）"
    },
    {
      "indent": 3,
      "text": "There are a few fine points in using CDDL with JSON. First, JSON does not distinguish between integers and floating-point numbers; there is only one kind of number (which may happen to be integral). In this context, specifying a type as \"uint\", \"nint\", or \"int\" then becomes a predicate that the number be integral. As an example, this means that the following JSON numbers are all matching \"uint\":",
      "ja": "JSONでCDDLを使用する場合、いくつかの細かい点があります。 まず、JSONは整数と浮動小数点数を区別しません。 1種類の数しかない（たまたま整数である可能性がある）。 このコンテキストでは、タイプを「uint」、「nint」、または「int」として指定すると、数値が整数であるという述語になります。 例として、これは次のJSON番号がすべて「uint」に一致することを意味します。"
    },
    {
      "indent": 6,
      "text": "10 10.0 1e1 1.0e1 100e-1",
      "ja": "10 10.0 1e1 1.0e1 100e-1"
    },
    {
      "indent": 3,
      "text": "(The fact that these are all integers may be surprising to users accustomed to the long tradition in programming languages of using decimal points or exponents in a number to indicate a floating-point literal.)",
      "ja": "（これらがすべて整数であるという事実は、浮動小数点リテラルを示すために数字の小数点または指数を使用するプログラミング言語の長い伝統に慣れているユーザーにとって驚くかもしれません。）"
    },
    {
      "indent": 3,
      "text": "CDDL distinguishes the various CBOR number types, but there is only one number type in JSON. The effect of specifying a floating-point precision (float16/float32/float64) is only to restrict the set of permissible values to those expressible with binary16/binary32/ binary64; this is unlikely to be very useful when using CDDL for specifying JSON data structures.",
      "ja": "CDDLはさまざまなCBOR番号タイプを区別しますが、JSONには1つの番号タイプしかありません。 浮動小数点の精度（float16 / float32 / float64）を指定する効果は、許容値のセットをbinary16 / binary32 / binary64で表現できる値に制限することだけです。 JSONデータ構造を指定するためにCDDLを使用する場合、これは非常に有用ではありません。"
    },
    {
      "indent": 3,
      "text": "Fundamentally, the number system of JSON itself is based on decimal numbers and decimal fractions and does not have limits to its precision or range. In practice, JSON numbers are often parsed into a number type that is called \"float64\" here, creating a number of limitations to the generic data model [RFC7493]. In particular, this means that integers can only be expressed with interoperable exactness when they lie in the range [-(2**53)+1, (2**53)-1] -- a smaller range than that covered by CDDL \"int\".",
      "ja": "基本的に、JSON自体の数値システムは10進数と小数に基づいており、その精度や範囲に制限はありません。 実際には、JSON番号は多くの場合、ここで「float64」と呼ばれる番号タイプに解析され、汎用データモデル[RFC7493]にいくつかの制限が生じます。 特に、これは、整数が[-（2 ** 53）+1、（2 ** 53）-1]の範囲にある場合にのみ相互運用可能な正確さで表現できることを意味します-CDDLでカバーされる範囲よりも小さい範囲 「int」。"
    },
    {
      "indent": 3,
      "text": "JSON applications that want to stay compatible with I-JSON (\"Internet JSON\"; see [RFC7493]) may therefore want to define integer types with more limited ranges, such as in Figure 16. Note that the types given here are not part of the prelude; they need to be copied into the CDDL specification if needed.",
      "ja": "したがって、I-JSONとの互換性を維持したいJSONアプリケーション（「インターネットJSON」。[RFC7493]を参照）は、図16のように、より制限された範囲の整数型を定義する場合があります。 プレリュード; 必要に応じて、CDDL仕様にコピーする必要があります。"
    },
    {
      "indent": 15,
      "text": "ij-uint = 0..9007199254740991\nij-nint = -9007199254740991..-1\nij-int = -9007199254740991..9007199254740991",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 16: I-JSON Types for CDDL (Not Part of Prelude)",
      "ja": "図16：CDDLのI-JSONタイプ（プレリュードの一部ではない）"
    },
    {
      "indent": 3,
      "text": "JSON applications that do not need to stay compatible with I-JSON and that actually may need to go beyond the 64-bit unsigned and negative integers supported by \"int\" (= \"uint\"/\"nint\") may want to use the following additional types from the standard prelude, which are expressed in terms of tags but can straightforwardly be mapped into JSON (but not I-JSON) numbers:",
      "ja": "I-JSONとの互換性を維持する必要がなく、実際に「int」（=「uint」/「nint」）でサポートされる64ビットの符号なしおよび負の整数を超える必要があるJSONアプリケーションは、次を使用できます。 標準プレリュードの追加タイプ。タグの観点から表現されますが、JSON（ただしI-JSONではない）番号に直接マッピングできます。"
    },
    {
      "indent": 6,
      "text": "biguint = #6.2(bstr)\nbignint = #6.3(bstr)\nbigint = biguint / bignint\ninteger = int / bigint\nunsigned = uint / biguint",
      "raw": true
    },
    {
      "indent": 3,
      "text": "CDDL at this point does not have a way to express the unlimited floating-point precision that is theoretically possible with JSON; at the time of writing, this is rarely used in protocols in practice.",
      "ja": "この時点でのCDDLには、JSONで理論的に可能な無限の浮動小数点精度を表現する方法がありません。 執筆時点では、これは実際のプロトコルではめったに使用されません。"
    },
    {
      "indent": 3,
      "text": "Note that a data model described in CDDL is always restricted by what can be expressed in the serialization; e.g., floating-point values such as NaN (not a number) and the infinities cannot be represented in JSON even if they are allowed in the CDDL generic data model.",
      "ja": "CDDLで記述されるデータモデルは、シリアル化で表現できるものによって常に制限されることに注意してください。 たとえば、NaDL（数値ではない）や無限大などの浮動小数点値は、CDDL汎用データモデルで許可されている場合でもJSONで表すことはできません。"
    },
    {
      "indent": 0,
      "text": "Appendix F. A CDDL Tool",
      "section_title": true,
      "ja": "付録F. CDDLツール"
    },
    {
      "indent": 3,
      "text": "This appendix is for information only.",
      "ja": "この付録は情報提供のみを目的としています。"
    },
    {
      "indent": 3,
      "text": "A rough CDDL tool is available. For CDDL specifications, it can check the syntax, generate one or more instances (expressed in CBOR diagnostic notation or in pretty-printed JSON), and validate an existing instance against the specification:",
      "ja": "大まかなCDDLツールが利用可能です。 CDDL仕様の場合、構文を確認し、1つ以上のインスタンスを生成（CBOR診断表記法または整形式JSON）し、既存のインスタンスを仕様に対して検証できます。"
    },
    {
      "indent": 19,
      "text": "Usage:\ncddl spec.cddl generate [n]\ncddl spec.cddl json-generate [n]\ncddl spec.cddl validate instance.cbor\ncddl spec.cddl validate instance.json",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 17: CDDL Tool Usage",
      "ja": "図17：CDDLツールの使用"
    },
    {
      "indent": 3,
      "text": "Install on a system with a modern Ruby via:",
      "ja": "次の方法で、最新のRubyを搭載したシステムにインストールします。"
    },
    {
      "indent": 29,
      "text": "gem install cddl",
      "ja": "gemインストールcddl"
    },
    {
      "indent": 21,
      "text": "Figure 18: CDDL Tool Installation",
      "ja": "図18：CDDLツールのインストール"
    },
    {
      "indent": 3,
      "text": "The accompanying CBOR diagnostic tools (which are automatically installed by the above) are described in <https://github.com/cabo/ cbor-diag>; they can be used to convert between binary CBOR, a pretty-printed hexadecimal form of binary CBOR, CBOR diagnostic notation, JSON, and YAML [YAML].",
      "ja": "付属のCBOR診断ツール（上記によって自動的にインストールされます）は、<https://github.com/cabo/ cbor-diag>で説明されています。 バイナリCBOR、バイナリCBORのきれいに印刷された16進形式、CBOR診断表記、JSON、およびYAML [YAML]間の変換に使用できます。"
    },
    {
      "indent": 0,
      "text": "Appendix G. Extended Diagnostic Notation",
      "ja": "付録G.拡張診断表記法"
    },
    {
      "indent": 3,
      "text": "This appendix is normative.",
      "ja": "この付録は規範です。"
    },
    {
      "indent": 3,
      "text": "Section 6 of [RFC7049] defines a \"diagnostic notation\" in order to be able to converse about CBOR data items without having to resort to binary data. Diagnostic notation is based on JSON, with extensions for representing CBOR constructs such as binary data and tags.",
      "ja": "[RFC7049]のセクション6では、バイナリデータに頼らずにCBORデータ項目について会話できるようにするために、「診断表記法」を定義しています。 診断表記法はJSONに基づいており、バイナリデータやタグなどのCBOR構造を表すための拡張機能を備えています。"
    },
    {
      "indent": 3,
      "text": "(Standardizing this together with the actual interchange format does not serve to create another interchange format but enables the use of a shared diagnostic notation in tools for and documents about CBOR.)",
      "ja": "（これを実際のインターチェンジ形式と一緒に標準化しても、別のインターチェンジ形式を作成することはできませんが、CBORに関するツールおよびドキュメントで共有診断表記を使用できます。）"
    },
    {
      "indent": 3,
      "text": "This appendix discusses a few extensions to the diagnostic notation that have turned out to be useful since RFC 7049 was written. We refer to the result as Extended Diagnostic Notation (EDN).",
      "ja": "この付録では、RFC 7049が作成されて以来有用であることが判明した診断表記法のいくつかの拡張について説明します。 結果を拡張診断表記法（EDN）と呼びます。"
    },
    {
      "indent": 0,
      "text": "G.1. Whitespace in Byte String Notation",
      "section_title": true,
      "ja": "G.1。 バイト文字列表記の空白"
    },
    {
      "indent": 3,
      "text": "Examples often benefit from some whitespace (spaces, line breaks) in byte strings. In EDN, whitespace is ignored in prefixed byte strings; for instance, the following are equivalent:",
      "ja": "例では、バイト文字列の空白（スペース、改行）が役立つことがよくあります。 EDNでは、接頭辞付きバイト文字列の空白は無視されます。 たとえば、次は同等です。"
    },
    {
      "indent": 6,
      "text": "h'48656c6c6f20776f726c64' h'48 65 6c 6c 6f 20 77 6f 72 6c 64' h'4 86 56c 6c6f 20776 f726c64'",
      "ja": "h'48656c6c6f20776f726c64 'h'48 65 6c 6c 6f 20 77 6f 72 6c 64' h'4 86 56c 6c6f 20776 f726c64 '"
    },
    {
      "indent": 0,
      "text": "G.2. Text in Byte String Notation",
      "section_title": true,
      "ja": "G.2。 バイト文字列表記のテキスト"
    },
    {
      "indent": 3,
      "text": "Diagnostic notation notates byte strings in one of the base encodings per [RFC4648], enclosed in single quotes, prefixed by >h< for base16, >b32< for base32, >h32< for base32hex, or >b64< for base64 or base64url. Quite often, byte strings carry bytes that are meaningfully interpreted as UTF-8 text. EDN allows the use of single quotes without a prefix to express byte strings with UTF-8 text; for instance, the following are equivalent:",
      "ja": "診断表記法は、[RFC4648]に従って、ベースエンコーディングのいずれかでバイト文字列を表記します。シングルクォートで囲まれ、base16には> h <、base32には> b32 <、base32hexには> h32 <、base64またはbase64urlには> b64 <が先頭に付きます。 多くの場合、バイト文字列には、UTF-8テキストとして有意義に解釈されるバイトが含まれています。 EDNでは、接頭辞なしの単一引用符を使用して、UTF-8テキストでバイト文字列を表現できます。 たとえば、次は同等です。"
    },
    {
      "indent": 6,
      "text": "'hello world' h'68656c6c6f20776f726c64'",
      "ja": "'hello world' h'68656c6c6f20776f726c64 '"
    },
    {
      "indent": 3,
      "text": "The escaping rules of JSON strings are applied equivalently for text-based byte strings, e.g., \"\\\" stands for a single backslash and \"'\" stands for a single quote. Whitespace is included literally, i.e., the previous section does not apply to text-based byte strings.",
      "ja": "JSON文字列のエスケープルールは、テキストベースのバイト文字列にも同様に適用されます。たとえば、「\\」は単一のバックスラッシュを表し、「 '」は一重引用符を表します。 空白は文字通り含まれています。つまり、前のセクションはテキストベースのバイト文字列には適用されません。"
    },
    {
      "indent": 0,
      "text": "G.3. Embedded CBOR and CBOR Sequences in Byte Strings",
      "section_title": true,
      "ja": "G.3。 バイト文字列の埋め込みCBORおよびCBORシーケンス"
    },
    {
      "indent": 3,
      "text": "Where a byte string is to carry an embedded CBOR-encoded item, or more generally a sequence of zero or more such items, the diagnostic notation for these zero or more CBOR data items, separated by commas, can be enclosed in << and >> to notate the byte string resulting from encoding the data items and concatenating the result. For instance, each pair of columns in the following are equivalent:",
      "ja": "バイト文字列が埋め込みCBORエンコードされたアイテム、またはより一般的には0個以上のそのようなアイテムのシーケンスを運ぶ場合、コンマで区切られたこれらの0個以上のCBORデータアイテムの診断表記を<<と>で囲むことができます >データ項目をエンコードし、結果を連結した結果のバイト文字列に表記します。 たとえば、次の列の各ペアは同等です。"
    },
    {
      "indent": 6,
      "text": "<<1>>              h'01'\n<<1, 2>>           h'0102'\n<<\"foo\", null>>    h'63666F6FF6'\n<<>>               h''",
      "raw": true
    },
    {
      "indent": 0,
      "text": "G.4. Concatenated Strings",
      "section_title": true,
      "ja": "G.4。 連結された文字列"
    },
    {
      "indent": 3,
      "text": "While the ability to include whitespace enables line-breaking of encoded byte strings, a mechanism is needed to be able to include text strings as well as byte strings in direct UTF-8 representation into line-based documents (such as RFCs and source code).",
      "ja": "空白を含める機能により、エンコードされたバイト文字列の改行が可能になりますが、テキスト文字列とバイト文字列を直接UTF-8表現で行ベースのドキュメント（RFCやソースコードなど）に含めることができるメカニズムが必要です 。"
    },
    {
      "indent": 3,
      "text": "We extend the diagnostic notation by allowing multiple text strings or multiple byte strings to be notated separated by whitespace; these are then concatenated into a single text or byte string, respectively. Text strings and byte strings do not mix within such a concatenation, except that byte string notation can be used inside a sequence of concatenated text string notation to encode characters that may be better represented in an encoded way. The following four values are equivalent:",
      "ja": "複数のテキスト文字列または複数のバイト文字列を空白で区切って表記できるようにすることで、診断表記法を拡張します。 次に、これらはそれぞれ単一のテキストまたはバイト文字列に連結されます。 テキスト文字列とバイト文字列は、連結されたテキスト文字列表記のシーケンス内でバイト文字表記を使用して、エンコード方法でより適切に表現できる文字をエンコードできることを除いて、このような連結内で混在しません 次の4つの値は同等です。"
    },
    {
      "indent": 6,
      "text": "\"Hello world\" \"Hello \" \"world\" \"Hello\" h'20' \"world\" \"\" h'48656c6c6f20776f726c64' \"\"",
      "ja": "「Hello world」「Hello」「world」「Hello」h'20 '\"world\" \"\" h'48656c6c6f20776f726c64' \""
    },
    {
      "indent": 3,
      "text": "Similarly, the following byte string values are equivalent:",
      "ja": "同様に、次のバイト文字列値は同等です。"
    },
    {
      "indent": 6,
      "text": "'Hello world' 'Hello ' 'world' 'Hello ' h'776f726c64' 'Hello' h'20' 'world' '' h'48656c6c6f20776f726c64' '' b64'' h'4 86 56c 6c6f' h' 20776 f726c64'",
      "ja": "'Hello world' 'Hello' 'world' 'Hello' h'776f726c64 '' Hello 'h'20' 'world' '' h'48656c6c6f20776f726c64 '' 'b64' 'h'4 86 56c 6c6f' h '20776 f726c64'"
    },
    {
      "indent": 3,
      "text": "(Note that the approach of separating by whitespace, while familiar from the C language, requires some attention -- a single comma makes a big difference here.)",
      "ja": "（空白で区切るアプローチは、C言語には馴染みがあるものの、注意が必要であることに注意してください。ここでは、単一のコンマが大きな違いを生みます。）"
    },
    {
      "indent": 0,
      "text": "G.5. Hexadecimal, Octal, and Binary Numbers",
      "section_title": true,
      "ja": "G.5。 16進数、8進数、および2進数"
    },
    {
      "indent": 3,
      "text": "In addition to JSON's decimal numbers, EDN provides hexadecimal, octal, and binary numbers in the usual C-language notation (octal with 0o prefix present only).",
      "ja": "JSONの10進数に加えて、EDNは通常のC言語表記で16進数、8進数、および2進数を提供します（0プレフィックスが付いた8進数のみが存在します）。"
    },
    {
      "indent": 3,
      "text": "The following are equivalent:",
      "ja": "以下は同等です："
    },
    {
      "indent": 6,
      "text": "4711 0x1267 0o11147 0b1001001100111",
      "ja": "4711 0x1267 0o11147 0b1001001100111"
    },
    {
      "indent": 3,
      "text": "As are:",
      "ja": "そのまま："
    },
    {
      "indent": 6,
      "text": "1.5 0x1.8p0 0x18p-4",
      "ja": "1.5 0x1.8p0 0x18p-4"
    },
    {
      "indent": 0,
      "text": "G.6. Comments",
      "section_title": true,
      "ja": "G.6。 コメント"
    },
    {
      "indent": 3,
      "text": "Longer pieces of diagnostic notation may benefit from comments. JSON famously does not provide for comments, and basic diagnostic notation per RFC 7049 inherits this property.",
      "ja": "診断記法の長い部分はコメントから恩恵を受けるかもしれません。 JSONはコメントを提供しないことで有名であり、RFC 7049に基づく基本的な診断表記法はこのプロパティを継承します。"
    },
    {
      "indent": 3,
      "text": "In EDN, comments can be included, delimited by slashes (\"/\"). Any text within and including a pair of slashes is considered a comment.",
      "ja": "EDNには、スラッシュ（「/」）で区切ってコメントを含めることができます。 スラッシュ内のテキストとスラッシュのペアは、コメントと見なされます。"
    },
    {
      "indent": 3,
      "text": "Comments are considered whitespace. Hence, they are allowed in prefixed byte strings; for instance, the following are equivalent:",
      "ja": "コメントは空白と見なされます。 したがって、接頭辞付きのバイト文字列で使用できます。 たとえば、次は同等です。"
    },
    {
      "indent": 6,
      "text": "h'68656c6c6f20776f726c64'\nh'68 65 6c /doubled l!/ 6c 6f /hello/\n  20 /space/\n  77 6f 72 6c 64' /world/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This can be used to annotate a CBOR structure as in:",
      "ja": "これは、次のようにCBOR構造に注釈を付けるために使用できます。"
    },
    {
      "indent": 6,
      "text": "/grasp-message/ [/M_DISCOVERY/ 1, /session-id/ 10584416,\n                 /objective/ [/objective-name/ \"opsonize\",\n                              /D, N, S/ 7, /loop-count/ 105]]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(There are currently no end-of-line comments. If we want to add them, \"//\" sounds like a reasonable delimiter given that we already use slashes for comments, but we could also go, for example, for \"#\".)",
      "ja": "（現在、行末のコメントはありません。コメントを追加する場合、コメントに既にスラッシュを使用しているため、「//」は妥当な区切り記号のように聞こえますが、たとえば「＃」 ）"
    },
    {
      "indent": 0,
      "text": "Appendix H. Examples",
      "ja": "付録H.例"
    },
    {
      "indent": 3,
      "text": "This appendix is for information only.",
      "ja": "この付録は情報提供のみを目的としています。"
    },
    {
      "indent": 3,
      "text": "This appendix contains a few examples of structures defined using CDDL. The theme for the examples is taken from [RFC7071], which defines certain JSON structures in English. For a similar example, it may also be of interest to examine Appendix A of [RFC8007], which contains a CDDL definition for a JSON structure defined in the main body of that RFC.",
      "ja": "この付録には、CDDLを使用して定義された構造のいくつかの例が含まれています。 例のテーマは、英語で特定のJSON構造を定義する[RFC7071]から取られています。 同様の例として、[RFC8007]の付録Aを調べることも興味深いかもしれません。これには、そのRFCの本文で定義されているJSON構造のCDDL定義が含まれています。"
    },
    {
      "indent": 3,
      "text": "These examples all happen to describe data that is interchanged in JSON. Examples for CDDL definitions of data that is interchanged in CBOR can be found in [RFC8152], [GRASP], and [RFC8428].",
      "ja": "これらの例はすべて、JSONで交換されるデータを説明しています。 CBORで交換されるデータのCDDL定義の例は、[RFC8152]、[GRASP]、および[RFC8428]にあります。"
    },
    {
      "indent": 3,
      "text": "[RFC7071] defines the \"reputon\" structure for JSON using somewhat formalized English text. Here is a (somewhat verbose) equivalent definition using the same terms, but notated in CDDL:",
      "ja": "[RFC7071]は、多少形式化された英語テキストを使用してJSONの「レプトン」構造を定義します。 以下は、同じ用語を使用した（多少冗長な）同等の定義ですが、CDDLで表記されています。"
    },
    {
      "indent": 17,
      "text": "reputation-object = {\n  reputation-context,\n  reputon-list\n}",
      "raw": true
    },
    {
      "indent": 17,
      "text": "reputation-context = (\n  application: text\n)",
      "raw": true
    },
    {
      "indent": 17,
      "text": "reputon-list = (\n  reputons: reputon-array\n)",
      "raw": true
    },
    {
      "indent": 17,
      "text": "reputon-array = [* reputon]",
      "raw": true
    },
    {
      "indent": 17,
      "text": "reputon = {\n  rater-value,\n  assertion-value,\n  rated-value,\n  rating-value,\n  ? conf-value,\n  ? normal-value,\n  ? sample-value,\n  ? gen-value,\n  ? expire-value,\n  * ext-value,\n} rater-value = ( rater: text )\nassertion-value = ( assertion: text )\nrated-value = ( rated: text )\nrating-value = ( rating: float16 )\nconf-value = ( confidence: float16 )\nnormal-value = ( normal-rating: float16 )\nsample-value = ( sample-size: uint )\ngen-value = ( generated: uint )\nexpire-value = ( expires: uint )\next-value = ( text => any )",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An equivalent, more compact form of this example would be:",
      "ja": "この例の同等のよりコンパクトな形式は次のとおりです。"
    },
    {
      "indent": 24,
      "text": "reputation-object = {\n  application: text\n  reputons: [* reputon]\n}",
      "raw": true
    },
    {
      "indent": 24,
      "text": "reputon = {\n  rater: text\n  assertion: text\n  rated: text\n  rating: float16\n  ? confidence: float16\n  ? normal-rating: float16\n  ? sample-size: uint\n  ? generated: uint\n  ? expires: uint\n  * text => any\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note how this rather clearly delineates the structure somewhat shrouded by so many words in Section 6.2.2 of [RFC7071]. Also, this definition makes it clear that several ext-values are allowed (by definition with different member names); RFC 7071 could be read to forbid the repetition of ext-value (\"A specific reputon-element MUST NOT appear more than once\" is ambiguous).",
      "ja": "これが、[RFC7071]のセクション6.2.2の非常に多くの単語によって幾分隠されている構造をかなり明確に描写していることに注意してください。 また、この定義により、いくつかのext-valueが許可されていることが明確になります（定義により、異なるメンバー名で）。 RFC 7071は、ext-valueの繰り返しを禁止するために読み取ることができます（「特定のレピュトン要素は複数回出現してはなりません」はあいまいです）。"
    },
    {
      "indent": 3,
      "text": "The CDDL tool described in Appendix F generates as one example:",
      "ja": "付録Fで説明されているCDDLツールは、一例として生成されます。"
    },
    {
      "indent": 18,
      "text": "{\n  \"application\": \"conchometry\",\n  \"reputons\": [\n    {\n      \"rater\": \"Ephthianura\",\n      \"assertion\": \"codding\",\n      \"rated\": \"sphaerolitic\",\n      \"rating\": 0.34133473256800795,\n      \"confidence\": 0.9481983064298332,\n      \"expires\": 1568,\n      \"unplaster\": \"grassy\"\n    },\n    {\n      \"rater\": \"nonchargeable\",\n      \"assertion\": \"raglan\",\n      \"rated\": \"alienage\",\n      \"rating\": 0.5724646875815566,\n      \"sample-size\": 3514,\n      \"Aldebaran\": \"unchurched\",\n      \"puruloid\": \"impersonable\",\n      \"uninfracted\": \"pericarpoidal\",\n      \"schorl\": \"Caro\"\n    },\n    {\n      \"rater\": \"precollectable\",\n      \"assertion\": \"Merat\",\n      \"rated\": \"thermonatrite\",\n      \"rating\": 0.19164006323936977,\n      \"confidence\": 0.6065252103391268,\n      \"normal-rating\": 0.5187773690879303,\n      \"generated\": 899,\n      \"speedy\": \"solidungular\",\n      \"noviceship\": \"medicine\",\n      \"checkrow\": \"epidictic\"\n    }\n  ]\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Inspiration was taken from the C and Pascal languages, MPEG's conventions for describing structures in the ISO base media file format, RELAX NG and its compact syntax [RELAXNG], and, in particular, Andrew Lee Newton's early proposals on JSON Content Rules (JCR) as found in draft version four (-04) of [JCR].",
      "ja": "CおよびPascal言語、ISOベースメディアファイル形式で構造を記述するためのMPEGの規則、RELAX NGおよびそのコンパクトな構文[RELAXNG]、特にAndrew ContentによるJSONコンテンツルール（JCR）の初期提案からインスピレーションを得ました。 [JCR]のドラフトバージョン4（-04）にあります。"
    },
    {
      "indent": 3,
      "text": "Lots of highly useful feedback came from members of the IETF CBOR WG -- in particular, Ari Keranen, Brian Carpenter, Burt Harris, Jeffrey Yasskin, Jim Hague, Jim Schaad, Joe Hildebrand, Max Pritikin, Michael Richardson, Pete Cordell, Sean Leonard, and Yaron Sheffer. Also, Francesca Palombini and Joe volunteered to chair the WG when it was created, providing the framework for generating and processing this feedback, with Barry Leiba having taken over from Joe since then. Chris Lonvick and Ines Robles provided additional reviews during IESG processing, and Alexey Melnikov steered the process as the responsible Area Director.",
      "ja": "IETF CBOR WGのメンバーから非常に有用なフィードバックが多数寄せられました。特に、Ari Keranen、Brian Carpenter、Burt Harris、Jeffrey Yasskin、Jim Hague、Jim Schaad、Joe Hildebrand、Max Pritikin、Michael Richardson、Pete Cordell、Sean Leonard 、ヤロンシェファー。 また、Francesca PalombiniとJoeは、WGの作成時にボランティアでWGの議長を務め、このフィードバックを生成および処理するためのフレームワークを提供しました。その後、Barry LeibaがJoeを引き継ぎました。 Chris LonvickとInes RoblesがIESG処理中に追加のレビューを提供し、Alexey Melnikovが責任のあるエリアディレクターとしてプロセスを進めました。"
    },
    {
      "indent": 3,
      "text": "The CDDL tool described in Appendix F was written by Carsten Bormann, building on previous work by Troy Heninger and Tom Lord.",
      "ja": "付録Fで説明されているCDDLツールはCarsten Bormannによって作成されたもので、Troy HeningerとTom Lordによる以前の研究に基づいています。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "寄稿者"
    },
    {
      "indent": 3,
      "text": "CDDL was originally conceived by Bert Greevenbosch, who also wrote the original five draft versions of this document.",
      "ja": "CDDLはもともとBert Greevenboschによって考案されました。BertGreevenboschは、このドキュメントの5つのドラフトバージョンも作成しました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Henk Birkholz Fraunhofer SIT Rheinstrasse 75 Darmstadt 64295 Germany",
      "ja": "Henk Birkholz Fraunhofer SIT Rheinstrasse 75ダルムシュタットドイツ"
    },
    {
      "indent": 3,
      "text": "Email: henk.birkholz@sit.fraunhofer.de",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Christoph Vigano Universitaet Bremen",
      "ja": "クリストフ・ヴィガノ・ブレーメン大学"
    },
    {
      "indent": 3,
      "text": "Email: christoph.vigano@uni-bremen.de",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Carsten Bormann Universitaet Bremen TZI Bibliothekstr. 1 Bremen D-28359 Germany",
      "ja": "カールステンボルマン大学ブレーメンTZI Bibliothekstr。 1ブレーメンD-28359ドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49-421-218-63921\nEmail: cabo@tzi.org",
      "raw": true
    }
  ]
}