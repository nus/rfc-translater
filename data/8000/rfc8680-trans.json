{
  "title": {
    "text": "RFC 8680 - Forward Error Correction (FEC) Framework Extension to Sliding Window Codes",
    "ja": "RFC 8680 - スライディングウィンドウコードへの前方誤り訂正（FEC）フレームワーク拡張"
  },
  "number": 8680,
  "created_at": "2020-03-10 13:24:02.665098+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           V. Roca\nRequest for Comments: 8680                                         INRIA\nUpdates: 6363                                                   A. Begen\nCategory: Standards Track                                Networked Media\nISSN: 2070-1721                                             January 2020",
      "raw": true
    },
    {
      "indent": 2,
      "text": "Forward Error Correction (FEC) Framework Extension to Sliding Window Codes",
      "ja": "スライディングウィンドウコードへの前方誤り訂正（FEC）フレームワーク拡張"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "RFC 6363 describes a framework for using Forward Error Correction (FEC) codes to provide protection against packet loss. The framework supports applying FEC to arbitrary packet flows over unreliable transport and is primarily intended for real-time, or streaming, media. However, FECFRAME as per RFC 6363 is restricted to block FEC codes. This document updates RFC 6363 to support FEC codes based on a sliding encoding window, in addition to block FEC codes, in a backward-compatible way. During multicast/broadcast real-time content delivery, the use of sliding window codes significantly improves robustness in harsh environments, with less repair traffic and lower FEC-related added latency.",
      "ja": "RFC 6363は、前方誤り訂正（FEC）コードを使用してパケット損失から保護するためのフレームワークについて説明しています。 このフレームワークは、信頼性の低いトランスポート上の任意のパケットフローへのFECの適用をサポートし、主にリアルタイム（ストリーミング）メディアを対象としています。 ただし、RFC 6363によるFECFRAMEは、ブロックFECコードに制限されています。 このドキュメントは、RFC 6363を更新して、FECコードのブロックに加えて、後方互換性のある方法で、スライディングエンコーディングウィンドウに基づくFECコードをサポートします。 マルチキャスト/ブロードキャストのリアルタイムコンテンツ配信中に、スライディングウィンドウコードを使用することで、過酷な環境での堅牢性が大幅に向上し、修理トラフィックが少なくなり、FEC関連の追加遅延が減少します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これはインターネット標準化過程の文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、Internet Engineering Task Force（IETF）の製品です。 IETFコミュニティのコンセンサスを表しています。 これは公開レビューを受けており、Internet Engineering Steering Group（IESG）による公開が承認されています。 インターネット標準の詳細については、RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8680.",
      "ja": "このドキュメントの現在のステータス、エラータ、およびフィードバックの提供方法に関する情報は、https：//www.rfc-editor.org/info/rfc8680で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2020 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2020 IETF Trustおよび文書作成者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの公開日に有効なBCP 78およびIETFトラストのIETFドキュメントに関連する法的条項（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust Legal Provisionsのセクション4.eに記載されているSimplified BSD Licenseテキストを含める必要があり、Simplified BSD Licenseに記載されている保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction 2. Terminology 2.1. Definitions and Abbreviations 2.2. Requirements Language 3. Summary of Architecture Overview 4. Procedural Overview 4.1. General 4.2. Sender Operation with Sliding Window FEC Codes 4.3. Receiver Operation with Sliding Window FEC Codes 5. Protocol Specification 5.1. General 5.2. FEC Framework Configuration Information 5.3. FEC Scheme Requirements 6. Feedback 7. Transport Protocols 8. Congestion Control 9. Security Considerations 10. Operations and Management Considerations 11. IANA Considerations 12. References 12.1. Normative References 12.2. Informative References Appendix A. About Sliding Encoding Window Management (Informational) Acknowledgments Authors' Addresses",
      "ja": "1. はじめに2.用語2.1。 定義と略語2.2。 要件言語3.アーキテクチャの概要の概要4.手順の概要4.1。 全般4.2。 スライディングウィンドウFECコードを使用した送信者操作4.3。 スライディングウィンドウFECコードを使用した受信機の操作5.プロトコル仕様5.1。 全般5.2。 FECフレームワーク設定情報5.3。 FECスキームの要件6.フィードバック7.トランスポートプロトコル8.輻輳制御9.セキュリティに関する考慮事項10.運用と管理に関する考慮事項11. IANAに関する考慮事項12.参考文献12.1。 規範的参考文献12.2。 参考資料付録A.スライドエンコーディングウィンドウ管理について（情報）謝辞著者のアドレス"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Many applications need to transport a continuous stream of packetized data from a source (sender) to one or more destinations (receivers) over networks that do not provide guaranteed packet delivery. In particular, packets may be lost, which is strictly the focus of this document: we assume that transmitted packets are either lost (e.g., because of a congested router, a poor signal-to-noise ratio in a wireless network, or because the number of bit errors exceeds the correction capabilities of the physical-layer error-correcting code) or were received by the transport protocol without any corruption (i.e., the bit errors, if any, have been fixed by the physical-layer error-correcting code and therefore are hidden to the upper layers).",
      "ja": "多くのアプリケーションは、パケット化されたデータの連続ストリームを、保証されたパケット配信を提供しないネットワークを介して、ソース（送信者）から1つ以上の宛先（受信者）に転送する必要があります。 特に、パケットが失われる可能性があります。これは厳密にこのドキュメントの焦点です。送信されたパケットは失われると仮定します（たとえば、ルーターの混雑、無線ネットワークでの信号対雑音比の低下、または ビットエラーの数が物理層エラー訂正コードの訂正能力を超えているか、破損せずにトランスポートプロトコルによって受信された（つまり、ビットエラーがあれば、物理層エラー訂正コードによって修正されている） したがって、上層に隠れています）。"
    },
    {
      "indent": 3,
      "text": "For these use cases, Forward Error Correction (FEC) applied within the transport or application layer is an efficient technique to improve packet transmission robustness in the presence of packet losses (or \"erasures\") without going through packet retransmissions that create a delay often incompatible with real-time constraints. The FEC Building Block defined in [RFC5052] provides a framework for the definition of Content Delivery Protocols (CDPs) that make use of separately defined FEC schemes. Any CDP defined according to the requirements of the FEC Building Block can then easily be used with any FEC scheme that is also defined according to the requirements of the FEC Building Block.",
      "ja": "これらのユースケースでは、トランスポート層またはアプリケーション層内で適用される前方誤り訂正（FEC）は、多くの場合互換性のない遅延を引き起こすパケットの再送信を行うことなく、パケット損失（または「消失」）がある場合のパケット伝送の堅牢性を向上させる効率的な手法です リアルタイムの制約があります。 [RFC5052]で定義されたFECビルディングブロックは、個別に定義されたFECスキームを利用するコンテンツ配信プロトコル（CDP）の定義のためのフレームワークを提供します。 FECビルディングブロックの要件に従って定義されたCDPは、FECビルディングブロックの要件に従って定義されたFECスキームでも簡単に使用できます。"
    },
    {
      "indent": 3,
      "text": "Then, FECFRAME [RFC6363] provides a framework to define Content Delivery Protocols (CDPs) that provide FEC protection for arbitrary packet flows over an unreliable datagram service transport, such as UDP. It is primarily intended for real-time or streaming media applications that are using broadcast, multicast, or on-demand delivery. A subset of FECFRAME is currently part of the 3GPP Evolved Multimedia Broadcast/Multicast Service (eMBMS) standard [MBMSTS].",
      "ja": "次に、FECFRAME [RFC6363]は、UDPなどの信頼性の低いデータグラムサービストランスポート上の任意のパケットフローにFEC保護を提供するコンテンツ配信プロトコル（CDP）を定義するフレームワークを提供します。 主に、ブロードキャスト、マルチキャスト、またはオンデマンド配信を使用しているリアルタイムまたはストリーミングメディアアプリケーションを対象としています。 FECFRAMEのサブセットは、現在3GPP Evolved Multimedia Broadcast / Multicast Service（eMBMS）標準[MBMSTS]の一部です。"
    },
    {
      "indent": 3,
      "text": "However, [RFC6363] only considers block FEC schemes defined in accordance with the FEC Building Block [RFC5052] (e.g., [RFC6681], [RFC6816], or [RFC6865]). These codes require the input flow(s) to be segmented into a sequence of blocks. Then, FEC encoding (at a sender or an encoding middlebox) and decoding (at a receiver or a decoding middlebox) are both performed on a per-block basis. For instance, if the current block encompasses the 100's to 119's source symbols (i.e., a block of size 20 symbols) of an input flow, encoding (and decoding) will be performed on this block independently of other blocks. This approach has major impacts on FEC encoding and decoding delays. The data packets of continuous media flow(s) may be passed to the transport layer immediately, without delay. But the block creation time, which depends on the number of source symbols in this block, impacts both the FEC encoding delay (since encoding requires that all source symbols be known) and, mechanically, the packet loss recovery delay at a receiver (since no repair symbol for the current block can be generated and therefore received before that time). Therefore, a good value for the block size is necessarily a balance between the maximum FEC decoding latency at the receivers (which must be in line with the most stringent real-time requirement of the protected flow(s), hence an incentive to reduce the block size) and the desired robustness against long loss bursts (which increases with the block size, hence an incentive to increase this size).",
      "ja": "ただし、[RFC6363]は、FECビルディングブロック[RFC5052]（たとえば、[RFC6681]、[RFC6816]、または[RFC6865]）に従って定義されたブロックFECスキームのみを考慮します。これらのコードでは、入力フローを一連のブロックにセグメント化する必要があります。次に、FECエンコード（送信側またはエンコードミドルボックス）とデコード（受信側またはデコードミドルボックス）の両方がブロックごとに実行されます。たとえば、現在のブロックが入力フローの100から119のソースシンボル（サイズ20のシンボルのブロック）を含む場合、他のブロックとは無関係にこのブロックでエンコード（およびデコード）が実行されます。このアプローチは、FECエンコードおよびデコードの遅延に大きな影響を与えます。連続したメディアフローのデータパケットは、遅延なしですぐにトランスポート層に渡されます。ただし、このブロック内のソースシンボルの数に依存するブロック作成時間は、FECエンコード遅延（エンコードではすべてのソースシンボルを知る必要があるため）と、受信機でのパケット損失回復遅延（いいえ現在のブロックの修復シンボルを生成することができ、その前に受信できます）。したがって、ブロックサイズの適切な値は、受信側での最大FECデコードレイテンシ（保護されたフローの最も厳格なリアルタイム要件と一致している必要があるため、ブロックサイズ）と長い損失バーストに対する望ましい堅牢性（ブロックサイズとともに増加するため、このサイズを大きくするインセンティブ）。"
    },
    {
      "indent": 3,
      "text": "This document updates [RFC6363] in order to also support FEC codes based on a sliding encoding window (a.k.a., convolutional codes) [RFC8406]. This encoding window, either fixed or variable size, slides over the set of source symbols. FEC encoding is launched whenever needed from the set of source symbols present in the sliding encoding window at that time. This approach significantly reduces FEC-related latency, since repair symbols can be generated and passed to the transport layer on the fly at any time and can be regularly received by receivers to quickly recover packet losses. Using sliding window FEC codes is therefore highly beneficial to real-time flows, one of the primary targets of FECFRAME. [RFC8681] provides an example of such a FEC scheme for FECFRAME, which is built upon the simple sliding window Random Linear Code (RLC).",
      "ja": "このドキュメントは、スライディングエンコーディングウィンドウ（別名、畳み込みコード）[RFC8406]に基づくFECコードもサポートするために[RFC6363]を更新します。 このエンコードウィンドウは、固定サイズまたは可変サイズで、ソースシンボルのセット上をスライドします。 その時点でスライディングエンコーディングウィンドウに存在するソースシンボルのセットから、必要に応じてFECエンコーディングが起動されます。 このアプローチは、FEC関連のレイテンシを大幅に削減します。修復シンボルはいつでもオンザフライで生成され、トランスポート層に渡され、受信者が定期的に受信してパケット損失をすばやく回復できるからです。 したがって、スライディングウィンドウFECコードの使用は、FECFRAMEの主要なターゲットの1つであるリアルタイムフローにとって非常に有益です。 [RFC8681]は、単純なスライディングウィンドウランダム線形コード（RLC）に基づいて構築されたFECFRAMEのFECスキームの例を示しています。"
    },
    {
      "indent": 3,
      "text": "This document is fully backward compatible with [RFC6363]. Indeed:",
      "ja": "このドキュメントは[RFC6363]と完全に後方互換性があります。 確かに："
    },
    {
      "indent": 3,
      "text": "* This FECFRAME update does not prevent or compromise in any way the support of block FEC codes. Both types of codes can nicely coexist, just like different block FEC schemes can coexist.",
      "ja": "* このFECFRAMEの更新は、ブロックFECコードのサポートをいかなる方法でも防止または侵害しません。 異なるブロックFECスキームが共存できるように、両方のタイプのコードがうまく共存できます。"
    },
    {
      "indent": 3,
      "text": "* Each sliding window FEC scheme is associated with a specific FEC Encoding ID subject to IANA registration, just like block FEC schemes.",
      "ja": "* 各スライディングウィンドウFECスキームは、ブロックFECスキームと同様に、IANA登録の対象となる特定のFECエンコーディングIDに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "* Any receiver -- for instance, a legacy receiver that only supports block FEC schemes -- can easily identify the FEC scheme used in a FECFRAME session. Indeed, the FEC Encoding ID that identifies the FEC scheme is carried in FEC Framework Configuration Information (see Section 5.5 of [RFC6363]). For instance, when the Session Description Protocol (SDP) is used to carry the FEC Framework Configuration Information, the FEC Encoding ID can be communicated in the \"encoding-id=\" parameter of a \"fec-repair-flow\" attribute [RFC6364]. This mechanism is the basic approach for a FECFRAME receiver to determine whether or not it supports the FEC scheme used in a given FECFRAME session.",
      "ja": "* 任意のレシーバー-たとえば、ブロックFECスキームのみをサポートするレガシーレシーバー-は、FECFRAMEセッションで使用されるFECスキームを簡単に識別できます。 実際、FECスキームを識別するFECエンコーディングIDは、FECフレームワーク構成情報に含まれています（[RFC6363]のセクション5.5を参照）。 たとえば、セッション記述プロトコル（SDP）を使用してFECフレームワーク構成情報を伝達する場合、FECエンコーディングIDは、「fec-repair-flow」属性の「encoding-id =」パラメータで通信できます[RFC6364] 。 このメカニズムは、特定のFECFRAMEセッションで使用されるFECスキームをサポートするかどうかを決定するFECFRAME受信機の基本的なアプローチです。"
    },
    {
      "indent": 3,
      "text": "This document leverages on [RFC6363] and reuses its structure. It proposes new sections specific to sliding window FEC codes whenever required. The only exception is Section 3, which provides a quick summary of FECFRAME in order to facilitate the understanding of this document to readers not familiar with the concepts and terminology.",
      "ja": "このドキュメントは[RFC6363]を活用し、その構造を再利用します。 必要に応じて、スライディングウィンドウFECコードに固有の新しいセクションを提案します。 唯一の例外はセクション3です。これは、概念と用語に精通していない読者にこのドキュメントの理解を促進するために、FECFRAMEの簡単な要約を提供します。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 0,
      "text": "2.1. Definitions and Abbreviations",
      "section_title": true,
      "ja": "2.1. 定義と略語"
    },
    {
      "indent": 3,
      "text": "The following list of definitions and abbreviations is copied from [RFC6363], adding only the Block FEC Code, Sliding Window FEC Code, and Encoding/Decoding Window definitions (tagged with \"ADDED\"):",
      "ja": "次の定義と略語のリストは[RFC6363]からコピーされ、ブロックFECコード、スライディングウィンドウFECコード、およびエンコード/デコードウィンドウ定義（「ADDED」でタグ付けされた）のみを追加します。"
    },
    {
      "indent": 3,
      "text": "Application Data Unit (ADU): The unit of source data provided as a payload to the transport layer. For instance, it can be a payload containing the result of the RTP packetization of a compressed video frame.",
      "ja": "アプリケーションデータユニット（ADU）：トランスポート層にペイロードとして提供されるソースデータのユニット。 たとえば、圧縮ビデオフレームのRTPパケット化の結果を含むペイロードにすることができます。"
    },
    {
      "indent": 3,
      "text": "ADU Flow: A sequence of ADUs associated with a transport-layer flow identifier (such as the standard 5-tuple {source IP address, source port, destination IP address, destination port, transport protocol}).",
      "ja": "ADUフロー：トランスポート層フロー識別子に関連付けられたADUのシーケンス（標準5タプル{送信元IPアドレス、送信元ポート、宛先IPアドレス、宛先ポート、トランスポートプロトコル}など）。"
    },
    {
      "indent": 3,
      "text": "AL-FEC: Application-Layer Forward Error Correction.",
      "ja": "AL-FEC：アプリケーション層の前方誤り訂正。"
    },
    {
      "indent": 3,
      "text": "Application Protocol: Control protocol used to establish and control the source flow being protected, e.g., the Real-Time Streaming Protocol (RTSP).",
      "ja": "アプリケーションプロトコル：保護されているソースフローを確立および制御するために使用される制御プロトコル、たとえば、リアルタイムストリーミングプロトコル（RTSP）。"
    },
    {
      "indent": 3,
      "text": "Content Delivery Protocol (CDP): A complete application protocol specification that, through the use of the framework defined in this document, is able to make use of FEC schemes to provide FEC capabilities.",
      "ja": "コンテンツ配信プロトコル（CDP）：このドキュメントで定義されているフレームワークを使用して、FECスキームを利用してFEC機能を提供できる完全なアプリケーションプロトコル仕様。"
    },
    {
      "indent": 3,
      "text": "FEC Code: An algorithm for encoding data such that the encoded data flow is resilient to data loss. Note that, in general, FEC codes may also be used to make a data flow resilient to corruption, but that is not considered in this document.",
      "ja": "FECコード：エンコードされたデータフローがデータ損失に対して回復力があるようにデータをエンコードするためのアルゴリズム。 一般に、FECコードを使用してデータフローを破損から回復させることもできますが、このドキュメントでは考慮していません。"
    },
    {
      "indent": 3,
      "text": "Block FEC Code: (ADDED) A FEC code that operates on blocks, i.e., for which the input flow MUST be segmented into a sequence of blocks, with FEC encoding and decoding being performed independently on a per-block basis.",
      "ja": "ブロックFECコード：（追加）ブロックで動作するFECコード、つまり入力フローをブロックのシーケンスにセグメント化する必要があり、FECエンコードとデコードはブロックごとに独立して実行される必要があります。"
    },
    {
      "indent": 3,
      "text": "Sliding Window FEC Code: (ADDED) A FEC code that can generate repair symbols on the fly, at any time, from the set of source symbols present in the sliding encoding window at that time. These codes are also known as convolutional codes.",
      "ja": "スライディングウィンドウFECコード：（追加）その時点でスライディングエンコーディングウィンドウに存在するソースシンボルのセットから、いつでもその場で修復シンボルを生成できるFECコード。 これらのコードは、畳み込みコードとも呼ばれます。"
    },
    {
      "indent": 3,
      "text": "FEC Framework: A protocol framework for the definition of Content Delivery Protocols using FEC, such as the framework defined in this document.",
      "ja": "FECフレームワーク：FECを使用してコンテンツ配信プロトコルを定義するためのプロトコルフレームワーク（このドキュメントで定義されているフレームワークなど）。"
    },
    {
      "indent": 3,
      "text": "FEC Framework Configuration Information: Information that controls the operation of the FEC Framework.",
      "ja": "FECフレームワーク構成情報：FECフレームワークの動作を制御する情報。"
    },
    {
      "indent": 3,
      "text": "FEC Payload ID: Information that identifies the contents and provides positional information of a packet with respect to the FEC scheme.",
      "ja": "FECペイロードID：コンテンツを識別し、FECスキームに関してパケットの位置情報を提供する情報。"
    },
    {
      "indent": 3,
      "text": "FEC Repair Packet: At a sender (respectively, at a receiver), a payload submitted to (respectively, received from) the transport protocol containing one or more repair symbols along with a Repair FEC Payload ID and possibly an RTP header.",
      "ja": "FEC修復パケット：送信側（それぞれ、受信側）で、1つ以上の修復シンボルと、修復FECペイロードID、および場合によってはRTPヘッダーを含むトランスポートプロトコルに送信された（それぞれから受信した）ペイロード。"
    },
    {
      "indent": 3,
      "text": "FEC Scheme: A specification that defines the additional protocol aspects required to use a particular FEC code with the FEC Framework.",
      "ja": "FECスキーム：FECフレームワークで特定のFECコードを使用するために必要な追加のプロトコルの側面を定義する仕様。"
    },
    {
      "indent": 3,
      "text": "FEC Source Packet: At a sender (respectively, at a receiver), a payload submitted to (respectively, received from) the transport protocol containing an ADU along with an optional Explicit Source FEC Payload ID.",
      "ja": "FECソースパケット：送信側（それぞれ、受信側）で、オプションの明示的ソースFECペイロードIDとともにADUを含むトランスポートプロトコルに送信された（それぞれから受信した）ペイロード。"
    },
    {
      "indent": 3,
      "text": "Repair Flow: The packet flow carrying FEC data.",
      "ja": "修復フロー：FECデータを伝送するパケットフロー。"
    },
    {
      "indent": 3,
      "text": "Repair FEC Payload ID: A FEC Payload ID specifically for use with repair packets.",
      "ja": "修復FECペイロードID：修復パケットで使用するためのFECペイロードID。"
    },
    {
      "indent": 3,
      "text": "Source Flow: The packet flow to which FEC protection is to be applied. A source flow consists of ADUs.",
      "ja": "ソースフロー：FEC保護が適用されるパケットフロー。 ソースフローはADUで構成されます。"
    },
    {
      "indent": 3,
      "text": "Source FEC Payload ID: A FEC Payload ID specifically for use with source packets.",
      "ja": "ソースFECペイロードID：ソースパケットで使用するためのFECペイロードID。"
    },
    {
      "indent": 3,
      "text": "Source Protocol: A protocol used for the source flow being protected, e.g., RTP.",
      "ja": "ソースプロトコル：保護されているソースフローに使用されるプロトコル（RTPなど）。"
    },
    {
      "indent": 3,
      "text": "Transport Protocol: The protocol used for the transport of the source and repair flows. This protocol needs to provide an unreliable datagram service, as UDP does ([RFC6363], Section 7).",
      "ja": "転送プロトコル：ソースおよび修復フローの転送に使用されるプロトコル。 このプロトコルは、UDPと同様に、信頼性の低いデータグラムサービスを提供する必要があります（[RFC6363]、セクション7）。"
    },
    {
      "indent": 3,
      "text": "Encoding Window: (ADDED) Set of source symbols available at the sender/coding node that are used (with a Sliding Window FEC code) to generate a repair symbol.",
      "ja": "エンコーディングウィンドウ：（追加）修復シンボルを生成するために（スライディングウィンドウFECコードで）使用される送信者/コーディングノードで利用可能なソースシンボルのセット。"
    },
    {
      "indent": 3,
      "text": "Decoding Window: (ADDED) Set of received or decoded source and repair symbols available at a receiver that are used (with a Sliding Window FEC code) to decode lost source symbols.",
      "ja": "デコードウィンドウ：（追加）失われたソースシンボルをデコードするために（スライディングウィンドウFECコードで）使用される、受信側で使用可能な受信またはデコードされたソースおよび修復シンボルのセット。"
    },
    {
      "indent": 3,
      "text": "Code Rate: The ratio between the number of source symbols and the number of encoding symbols. By definition, the code rate is such that 0 < code rate <= 1. A code rate close to 1 indicates that a small number of repair symbols have been produced during the encoding process.",
      "ja": "コードレート：ソースシンボルの数とエンコードシンボルの数の比率。 定義により、コードレートは0 <コードレート<= 1です。1に近いコードレートは、エンコードプロセス中に少数の修復シンボルが生成されたことを示します。"
    },
    {
      "indent": 3,
      "text": "Encoding Symbol: Unit of data generated by the encoding process. With systematic codes, source symbols are part of the encoding symbols.",
      "ja": "エンコードシンボル：エンコードプロセスによって生成されたデータの単位。 体系的なコードでは、ソースシンボルはエンコードシンボルの一部です。"
    },
    {
      "indent": 3,
      "text": "Packet Erasure Channel: A communication path where packets are either lost (e.g., in our case, by a congested router, or because the number of transmission errors exceeds the correction capabilities of the physical-layer code) or received. When a packet is received, it is assumed that this packet is not corrupted (i.e., in our case, the bit errors, if any, are fixed by the physical-layer code and are therefore hidden to the upper layers).",
      "ja": "パケット消去チャネル：パケットが失われる（たとえば、輻輳しているルーターによって、または送信エラーの数が物理層コードの修正機能を超えたため）パケットが失われるか、受信される通信パス。 パケットが受信されるとき、このパケットは破損していないと想定されます（つまり、この場合、ビットエラーは物理層コードによって修正され、したがって上位層に隠されています）。"
    },
    {
      "indent": 3,
      "text": "Repair Symbol: Encoding symbol that is not a source symbol.",
      "ja": "シンボルの修復：ソースシンボルではないエンコードシンボル。"
    },
    {
      "indent": 3,
      "text": "Source Block: Group of ADUs that are to be FEC protected as a single block. This notion is restricted to Block FEC codes.",
      "ja": "ソースブロック：単一ブロックとしてFEC保護されるADUのグループ。 この概念は、ブロックFECコードに制限されています。"
    },
    {
      "indent": 3,
      "text": "Source Symbol: Unit of data used during the encoding process.",
      "ja": "ソースシンボル：エンコードプロセス中に使用されるデータの単位。"
    },
    {
      "indent": 3,
      "text": "Systematic Code: FEC code in which the source symbols are part of the encoding symbols.",
      "ja": "体系的コード：ソースシンボルがエンコードシンボルの一部であるFECコード。"
    },
    {
      "indent": 0,
      "text": "2.2. Requirements Language",
      "section_title": true,
      "ja": "2.2. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Summary of Architecture Overview",
      "section_title": true,
      "ja": "3. アーキテクチャの概要の概要"
    },
    {
      "indent": 3,
      "text": "The architecture of Section 3 of [RFC6363] equally applies to this FECFRAME extension and is not repeated here. However, this section includes a quick summary to facilitate the understanding of this document to readers not familiar with the concepts and terminology.",
      "ja": "[RFC6363]のセクション3のアーキテクチャは、このFECFRAME拡張にも等しく適用され、ここでは繰り返されません。 ただし、このセクションには、概念と用語に精通していない読者にこのドキュメントの理解を促進するための簡単な要約が含まれています。"
    },
    {
      "indent": 3,
      "text": "+----------------------+\n|     Application      |\n+----------------------+\n           |\n           | (1) Application Data Units (ADUs)\n           |\n           v\n+----------------------+                           +----------------+\n|    FEC Framework     |                           |                |\n|                      |-------------------------->|   FEC Scheme   |\n|(2) Construct source  |(3) Source Block           |                |\n|    blocks            |                           |(4) FEC Encoding|\n|(6) Construct FEC     |<--------------------------|                |\n|    Source and Repair |                           |                |\n|    Packets           |(5) Explicit Source FEC    |                |\n+----------------------+    Payload IDs            +----------------+\n           |                Repair FEC Payload IDs\n           |                Repair symbols\n           |\n           |(7) FEC Source and Repair Packets\n           v\n+----------------------+\n|  Transport Protocol  |\n+----------------------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 1: FECFRAME Architecture at a Sender",
      "ja": "図1：送信者のFECFRAMEアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "The FECFRAME architecture is illustrated in Figure 1 for a block FEC scheme from the sender's point of view. It shows an application generating an ADU flow (other flows from other applications may coexist). These ADUs of variable size must be somehow mapped to source symbols of a fixed size (this fixed size is a requirement of all FEC schemes, which comes from the way mathematical operations are applied to the symbols' content). This is the goal of an ADU-to-symbols mapping process that is FEC scheme specific (see below). Once the source block is built, taking into account both the FEC scheme constraints (e.g., in terms of maximum source block size) and the application's flow constraints (e.g., in terms of real-time constraints), the associated source symbols are handed to the FEC scheme in order to produce an appropriate number of repair symbols. FEC Source Packets (containing ADUs) and FEC Repair Packets (containing one or more repair symbols each) are then generated and sent using an appropriate transport protocol (more precisely, Section 7 of [RFC6363] requires a transport protocol providing an unreliable datagram service, such as UDP). In practice, FEC Source Packets may be passed to the transport layer as soon as available without having to wait for FEC encoding to take place. In that case, a copy of the associated source symbols needs to be kept within FECFRAME for future FEC encoding purposes.",
      "ja": "図1に、送信者の観点からのブロックFECスキームのFECFRAMEアーキテクチャを示します。 ADUフローを生成するアプリケーションを示します（他のアプリケーションからの他のフローが共存する場合があります）。これらの可変サイズのADUは、何らかの方法で固定サイズのソースシンボルにマッピングする必要があります（この固定サイズは、シンボルのコンテンツに数学演算を適用する方法に由来するすべてのFECスキームの要件です）。これは、FECスキーム固有のADUからシンボルへのマッピングプロセスの目標です（以下を参照）。ソースブロックが構築されると、FECスキームの制約（最大ソースブロックサイズなど）とアプリケーションのフロー制約（リアルタイム制約など）の両方を考慮して、関連するソースシンボルが渡されます。適切な数の修復シンボルを生成するためのFECスキーム。 FECソースパケット（ADUを含む）とFEC修復パケット（それぞれ1つ以上の修復シンボルを含む）が生成され、適切なトランスポートプロトコルを使用して送信されます（より正確には、[RFC6363]のセクション7は信頼できないデータグラムサービスを提供するトランスポートプロトコルを必要とし、 UDPなど）。実際には、FECエンコードが行われるのを待たずに、FECソースパケットはトランスポートレイヤーに利用可能になるとすぐに渡されます。その場合、関連するソースシンボルのコピーは、将来のFECエンコーディングの目的のためにFECFRAME内に保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "At a receiver (not shown), FECFRAME processing operates in a similar way, taking as input the incoming FEC Source and Repair Packets received. In case of FEC Source Packet losses, the FEC decoding of the associated block may recover all (in case of successful decoding) or a subset that is potentially empty (if decoding fails) of the missing source symbols. After source-symbol-to-ADU mapping, when lost ADUs are recovered, they are then assigned to their respective flow (see below). ADUs are returned to the application(s), either in their initial transmission order (in which case all ADUs received after a lost ADU will be delayed until FEC decoding has taken place) or not (in which case each ADU is returned as soon as it is received or recovered), depending on the application requirements.",
      "ja": "受信機（図示せず）で、FECFRAM処理は同様の方法で動作し、入力として受信FECソースと受信した修復パケットを受け取ります。 FECソースパケット損失の場合、関連するブロックのFECデコードは、欠落したソースシンボルのすべて（デコードが成功した場合）または空の可能性がある（デコードが失敗した場合）サブセットを回復します。 ソースシンボルからADUへのマッピングの後、失われたADUが回復されると、それらはそれぞれのフローに割り当てられます（以下を参照）。 ADUは、最初の送信順序（この場合、失われたADUの後に受信されたすべてのADUは、FECデコードが行われるまで遅延されます）または返されません（この場合、各ADUはすぐに返されます） アプリケーションの要件に応じて、受信または復元されます）。"
    },
    {
      "indent": 3,
      "text": "FECFRAME features two subtle mechanisms whose details are FEC scheme dependent:",
      "ja": "FECFRAMEは、詳細がFECスキームに依存する2つの微妙なメカニズムを備えています。"
    },
    {
      "indent": 3,
      "text": "* ADUs-to-source-symbols mapping: in order to manage variable size ADUs, FECFRAME and FEC schemes can use small, fixed-size symbols and create a mapping between ADUs and symbols. The mapping details are FEC scheme dependent and must be defined in the associated document. For instance, with certain FEC schemes, to each ADU, this mechanism prepends a length field (plus a flow identifier; see below) and pads the result to a multiple of the symbol size. A small ADU may be mapped to a single source symbol, while a large one may be mapped to multiple symbols.",
      "ja": "* ADUからソースシンボルへのマッピング：可変サイズのADUを管理するために、FECFRAMEおよびFECスキームは、小さい固定サイズのシンボルを使用し、ADUとシンボル間のマッピングを作成できます。 マッピングの詳細はFECスキームに依存しており、関連ドキュメントで定義する必要があります。 たとえば、特定のFECスキームでは、このメカニズムは各ADUに長さフィールド（およびフロー識別子。以下を参照）を付加し、結果をシンボルサイズの倍数にパディングします。 小さなADUは単一のソースシンボルにマッピングされ、大きなADUは複数のシンボルにマッピングされます。"
    },
    {
      "indent": 3,
      "text": "* Assignment of decoded ADUs to flows in multi-flow configurations: when multiple flows are multiplexed over the same FECFRAME instance, a problem is to assign a decoded ADU to the right flow (UDP port numbers and IP addresses traditionally used to map incoming ADUs to flows are not recovered during FEC decoding). The mapping details are FEC scheme dependent and must be defined in the associated document. For instance, with certain FEC schemes, to make it possible, at the FECFRAME sending instance, each ADU is prepended with a flow identifier (1 byte) during the ADU-to-source-symbols mapping (see above). The flow identifiers are also shared between all FECFRAME instances as part of the FEC Framework Configuration Information. The ADU Information (ADUI), which includes the flow identifier, length, application payload, and padding, is then FEC protected. Therefore, a decoded ADUI contains enough information to assign the ADU to the right flow. Note that a FEC scheme may also be restricted to the particular case of a single flow over a FECFRAME instance; that would make the above mechanism pointless.",
      "ja": "* マルチフロー構成でのフローへのデコードされたADUの割り当て：複数のフローが同じFECFRAMEインスタンスで多重化されている場合、問題はデコードされたADUを正しいフローに割り当てることです（UDPポート番号と着信ADUをフローにマッピングするために従来使用されていたIPアドレスFECデコード中に復元されません）。マッピングの詳細はFECスキームに依存しており、関連ドキュメントで定義する必要があります。たとえば、特定のFECスキームでは、FECFRAME送信インスタンスで、ADUからソースシンボルへのマッピング中にフロー識別子（1バイト）が先頭に追加されます（上記を参照）。また、フロー識別子は、FECフレームワーク構成情報の一部として、すべてのFECFRAMEインスタンス間で共有されます。次に、フロー識別子、長さ、アプリケーションペイロード、およびパディングを含むADU情報（ADUI）がFECで保護されます。したがって、デコードされたADUIには、ADUを正しいフローに割り当てるのに十分な情報が含まれています。 FECスキームは、FECFRAMEインスタンス上の単一フローの特定のケースに制限される場合があることに注意してください。上記のメカニズムは無意味になります。"
    },
    {
      "indent": 3,
      "text": "A few aspects are not covered by FECFRAME, namely:",
      "ja": "いくつかの側面は、FECFRAMEでカバーされていません。つまり："
    },
    {
      "indent": 3,
      "text": "* Section 8 of [RFC6363] does not detail any congestion control mechanisms and only provides high-level normative requirements.",
      "ja": "* [RFC6363]のセクション8では、輻輳制御メカニズムについて詳しく説明しておらず、高レベルの規範的要件のみを提供しています。"
    },
    {
      "indent": 3,
      "text": "* The possibility of having feedback from receiver(s) is considered out of scope, although such a mechanism may exist within the application (e.g., through RTP Control Protocol (RTCP) messages).",
      "ja": "* 受信者からのフィードバックの可能性は範囲外と見なされますが、そのようなメカニズムはアプリケーション内に存在する可能性があります（たとえば、RTP Control Protocol（RTCP）メッセージを使用）。"
    },
    {
      "indent": 3,
      "text": "* Flow adaptation at a FECFRAME sender (e.g., how to set the FEC code rate based on transmission conditions) is not detailed, but it needs to comply with the congestion control normative requirements (see above).",
      "ja": "* FECFRAME送信者でのフローの適応（送信条件に基づいてFECコードレートを設定する方法など）は詳細ではありませんが、輻輳制御の標準要件（上記を参照）に準拠する必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Procedural Overview",
      "section_title": true,
      "ja": "4. 手順の概要"
    },
    {
      "indent": 0,
      "text": "4.1. General",
      "section_title": true,
      "ja": "4.1. 全般"
    },
    {
      "indent": 3,
      "text": "The general considerations of Section 4.1 of [RFC6363] that are specific to block FEC codes are not repeated here.",
      "ja": "ブロックFECコードに固有の[RFC6363]のセクション4.1の一般的な考慮事項は、ここでは繰り返されません。"
    },
    {
      "indent": 3,
      "text": "With a Sliding Window FEC code, the FEC Source Packet MUST contain information to identify the position occupied by the ADU within the source flow in terms specific to the FEC scheme. This information is known as the Source FEC Payload ID, and the FEC scheme is responsible for defining and interpreting it.",
      "ja": "スライディングウィンドウFECコードでは、FECソースパケットには、ソースフロー内でADUが占める位置をFECスキームに固有の用語で識別するための情報を含める必要があります。 この情報は、ソースFECペイロードIDと呼ばれ、FECスキームはそれを定義および解釈します。"
    },
    {
      "indent": 3,
      "text": "With a Sliding Window FEC code, the FEC Repair Packets MUST contain information that identifies the relationship between the contained repair payloads and the original source symbols used during encoding. This information is known as the Repair FEC Payload ID, and the FEC scheme is responsible for defining and interpreting it.",
      "ja": "スライディングウィンドウFECコードでは、FEC修復パケットには、含まれている修復ペイロードとエンコード中に使用された元のソースシンボルとの関係を識別する情報が含まれている必要があります。 この情報は修復FECペイロードIDと呼ばれ、FECスキームはそれを定義および解釈します。"
    },
    {
      "indent": 3,
      "text": "The sender operation ([RFC6363], Section 4.2) and receiver operation ([RFC6363], Section 4.3) are both specific to block FEC codes and are therefore omitted below. The following two sections detail similar operations for Sliding Window FEC codes.",
      "ja": "送信者操作（[RFC6363]、セクション4.2）および受信者操作（[RFC6363]、セクション4.3）は両方ともブロックFECコードに固有であるため、以下では省略します。 次の2つのセクションでは、スライディングウィンドウFECコードの同様の操作について詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "4.2. Sender Operation with Sliding Window FEC Codes",
      "section_title": true,
      "ja": "4.2. スライディングウィンドウFECコードを使用した送信者操作"
    },
    {
      "indent": 3,
      "text": "With a Sliding Window FEC scheme, the following operations, illustrated in Figure 2 for the generic case (non-RTP repair flows) and in Figure 3 for the case of RTP repair flows, describe a possible way to generate compliant source and repair flows:",
      "ja": "スライディングウィンドウFECスキームでは、一般的な場合（非RTP修復フロー）の図2とRTP修復フローの場合の図3に示す以下の操作で、準拠するソースおよび修復フローを生成する方法を説明します。"
    },
    {
      "indent": 3,
      "text": "1. A new ADU is provided by the application.",
      "ja": "1. 新しいADUがアプリケーションによって提供されます。"
    },
    {
      "indent": 3,
      "text": "2. The FEC Framework communicates this ADU to the FEC scheme.",
      "ja": "2. FECフレームワークは、このADUをFECスキームに伝えます。"
    },
    {
      "indent": 3,
      "text": "3. The sliding encoding window is updated by the FEC scheme. The ADU-to-source-symbol mapping as well as the encoding window management details are both the responsibility of the FEC scheme and MUST be detailed there. Appendix A provides non-normative hints about what FEC scheme designers need to consider.",
      "ja": "3. スライディングエンコーディングウィンドウは、FECスキームによって更新されます。 ADUからソースシンボルへのマッピングとエンコードウィンドウ管理の詳細は、両方ともFECスキームの責任であり、そこで詳述する必要があります。 付録Aは、FECスキームの設計者が考慮する必要のある非規範的なヒントを提供します。"
    },
    {
      "indent": 3,
      "text": "4. The Source FEC Payload ID information of the source packet is determined by the FEC scheme. If required by the FEC scheme, the Source FEC Payload ID is encoded into the Explicit Source FEC Payload ID field and returned to the FEC Framework.",
      "ja": "4. ソースパケットのソースFECペイロードID情報は、FECスキームによって決定されます。 FECスキームで必要な場合、ソースFECペイロードIDは明示的ソースFECペイロードIDフィールドにエンコードされ、FECフレームワークに返されます。"
    },
    {
      "indent": 3,
      "text": "5. The FEC Framework constructs the FEC Source Packet according to Figure 6 in [RFC6363], using the Explicit Source FEC Payload ID provided by the FEC scheme if applicable.",
      "ja": "5. FECフレームワークは、該当する場合、FECスキームによって提供される明示的ソースFECペイロードIDを使用して、[RFC6363]の図6に従ってFECソースパケットを構築します。"
    },
    {
      "indent": 3,
      "text": "6. The FEC Source Packet is sent using normal transport-layer procedures. This packet is sent using the same ADU flow identification information as would have been used for the original source packet if the FEC Framework were not present (e.g., the source and destination addresses and UDP port numbers on the IP datagram carrying the source packet will be the same whether or not the FEC Framework is applied).",
      "ja": "6. FECソースパケットは、通常のトランスポート層手順を使用して送信されます。 このパケットは、FECフレームワークが存在しない場合に元のソースパケットに使用されていたのと同じADUフロー識別情報を使用して送信されます（たとえば、ソースパケットを運ぶIPデータグラムのソースおよび宛先アドレスとUDPポート番号は FECフレームワークが適用されているかどうかに関係なく同じです）。"
    },
    {
      "indent": 3,
      "text": "7. When the FEC Framework needs to send one or several FEC Repair Packets (e.g., according to the target code rate), it asks the FEC scheme to create one or several repair packet payloads from the current sliding encoding window along with their Repair FEC Payload ID.",
      "ja": "7. FECフレームワークが1つまたは複数のFEC修復パケットを送信する必要がある場合（たとえば、ターゲットコードレートに従って）、FECスキームに、現在のスライディングエンコーディングウィンドウから修復FECペイロードIDとともに1つまたは複数の修復パケットペイロードを作成するように依頼 。"
    },
    {
      "indent": 3,
      "text": "8. The Repair FEC Payload IDs and repair packet payloads are provided back by the FEC scheme to the FEC Framework.",
      "ja": "8. 修復FECペイロードIDと修復パケットペイロードは、FECスキームによってFECフレームワークに提供されます。"
    },
    {
      "indent": 3,
      "text": "9. The FEC Framework constructs FEC Repair Packets according to Figure 7 in [RFC6363], using the FEC Payload IDs and repair packet payloads provided by the FEC scheme.",
      "ja": "9. FECフレームワークは、FECペイロードIDとFECスキームによって提供される修復パケットペイロードを使用して、[RFC6363]の図7に従ってFEC修復パケットを構築します。"
    },
    {
      "indent": 3,
      "text": "10. The FEC Repair Packets are sent using normal transport-layer procedures. The port(s) and multicast group(s) to be used for FEC Repair Packets are defined in the FEC Framework Configuration Information.",
      "ja": "10. FEC修復パケットは、通常のトランスポート層手順を使用して送信されます。 FEC修復パケットに使用されるポートとマルチキャストグループは、FECフレームワーク構成情報で定義されます。"
    },
    {
      "indent": 3,
      "text": "+----------------------+\n|     Application      |\n+----------------------+\n           |\n           | (1) New Application Data Unit (ADU)\n           v\n+---------------------+                           +----------------+\n|    FEC Framework    |                           |   FEC Scheme   |\n|                     |-------------------------->|                |\n|                     | (2) New ADU               |(3) Update of   |\n|                     |                           |    encoding    |\n|                     |<--------------------------|    window      |\n|(5) Construct FEC    | (4) Explicit Source       |                |\n|    Source Packet    |     FEC Payload ID(s)     |(7) FEC         |\n|                     |<--------------------------|    encoding    |\n|(9) Construct FEC    | (8) Repair FEC Payload ID |                |\n|    Repair Packet(s) |     + Repair symbol(s)    +----------------+\n+---------------------+\n           |\n           | (6)  FEC Source Packet\n           | (10) FEC Repair Packets\n           v\n+----------------------+\n|  Transport Protocol  |\n+----------------------+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 2: Sender Operation with Sliding Window FEC Codes",
      "ja": "図2：スライディングウィンドウFECコードを使用した送信者操作"
    },
    {
      "indent": 3,
      "text": "+----------------------+\n|     Application      |\n+----------------------+\n           |\n           | (1) New Application Data Unit (ADU)\n           v\n+---------------------+                           +----------------+\n|    FEC Framework    |                           |   FEC Scheme   |\n|                     |-------------------------->|                |\n|                     | (2) New ADU               |(3) Update of   |\n|                     |                           |    encoding    |\n|                     |<--------------------------|    window      |\n|(5) Construct FEC    | (4) Explicit Source       |                |\n|    Source Packet    |     FEC Payload ID(s)     |(7) FEC         |\n|                     |<--------------------------|    encoding    |\n|(9) Construct FEC    | (8) Repair FEC Payload ID |                |\n|    Repair Packet(s) |     + Repair symbol(s)    +----------------+\n+---------------------+\n    |             |\n    |(6) Source   |(10) Repair payloads\n    |    packets  |\n    |      + -- -- -- -- -+\n    |      |     RTP      |\n    |      +-- -- -- -- --+\n    v             v\n+----------------------+\n|  Transport Protocol  |\n+----------------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 3: Sender Operation with Sliding Window FEC Codes and RTP Repair Flows",
      "ja": "図3：スライディングウィンドウFECコードとRTP修復フローを使用した送信者操作"
    },
    {
      "indent": 0,
      "text": "4.3. Receiver Operation with Sliding Window FEC Codes",
      "section_title": true,
      "ja": "4.3. スライディングウィンドウFECコードを使用した受信機の操作"
    },
    {
      "indent": 3,
      "text": "With a Sliding Window FEC scheme, the following operations are illustrated in Figure 4 for the generic case (non-RTP repair flows) and in Figure 5 for the case of RTP repair flows. The only differences with respect to block FEC codes lie in steps (4) and (5). Therefore, this section does not repeat the other steps of Section 4.3 of [RFC6363] (\"Receiver Operation\"). The new steps (4) and (5) are:",
      "ja": "スライディングウィンドウFECスキームでは、一般的なケース（非RTP修復フロー）の場合は図4に、RTP修復フローの場合は図5に次の操作を示します。 ブロックFECコードに関する唯一の違いは、ステップ（4）と（5）にあります。 したがって、このセクションでは、[RFC6363]のセクション4.3の他のステップ（「受信者の操作」）を繰り返しません。 新しい手順（4）と（5）は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "4. The FEC scheme uses the received FEC Payload IDs (and derived FEC Source Payload IDs when the Explicit Source FEC Payload ID field is not used) to insert source and repair packets into the decoding window in the right way. If at least one source packet is missing and at least one repair packet has been received, then FEC decoding is attempted to recover the missing source payloads. The FEC scheme determines whether source packets have been lost and whether enough repair packets have been received to decode any or all of the missing source payloads.",
      "ja": "4. FECスキームは、受信したFECペイロードID（および明示的ソースFECペイロードIDフィールドが使用されていない場合は派生FECソースペイロードID）を使用して、正しい方法でデコードウィンドウにソースおよび修復パケットを挿入します。 少なくとも1つのソースパケットが欠落しており、少なくとも1つの修復パケットが受信されている場合、欠落したソースペイロードを回復するためにFECデコードが試行されます。 FECスキームは、ソースパケットが失われたかどうか、および不足しているソースペイロードの一部またはすべてをデコードするのに十分な修復パケットが受信されたかどうかを判断します。"
    },
    {
      "indent": 3,
      "text": "5. The FEC scheme returns the received and decoded ADUs to the FEC Framework, along with indications of any ADUs that were missing and could not be decoded.",
      "ja": "5. FECスキームは、受信されてデコードされたADUをFECフレームワークに返し、ADUが欠落していてデコードできなかった場合の表示を返します。"
    },
    {
      "indent": 3,
      "text": "+----------------------+\n|     Application      |\n+----------------------+\n           ^\n           |(6) ADUs\n           |\n+----------------------+                           +----------------+\n|    FEC Framework     |                           |   FEC Scheme   |\n|                      |<--------------------------|                |\n|(2)Extract FEC Payload|(5) ADUs                   |(4) FEC Decoding|\n|   IDs and pass IDs & |-------------------------->|                |\n|   payloads to FEC    |(3) Explicit Source FEC    +----------------+\n|   scheme             |            Payload IDs\n+----------------------+    Repair FEC Payload IDs\n           ^                Source payloads\n           |                Repair payloads\n           |(1) FEC Source\n           |    and Repair Packets\n+----------------------+\n|  Transport Protocol  |\n+----------------------+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 4: Receiver Operation with Sliding Window FEC Codes",
      "ja": "図4：スライディングウィンドウFECコードを使用した受信機の操作"
    },
    {
      "indent": 3,
      "text": "+----------------------+\n|     Application      |\n+----------------------+\n           ^\n           |(6) ADUs\n           |\n+----------------------+                           +----------------+\n|    FEC Framework     |                           |   FEC Scheme   |\n|                      |<--------------------------|                |\n|(2)Extract FEC Payload|(5) ADUs                   |(4) FEC Decoding|\n|   IDs and pass IDs & |-------------------------->|                |\n|   payloads to FEC    |(3) Explicit Source FEC    +----------------+\n|   scheme             |            Payload IDs\n+----------------------+    Repair FEC Payload IDs\n    ^             ^         Source payloads\n    |             |         Repair payloads\n    |Source pkts  |Repair payloads\n    |             |\n+-- |- -- -- -- -- -- -+\n|RTP| | RTP Processing |\n|   | +-- -- -- --|-- -+\n| +-- -- -- -- -- |--+ |\n| | RTP Demux        | |\n+-- -- -- -- -- -- -- -+\n           ^\n           |(1) FEC Source and Repair Packets\n           |\n+----------------------+\n|  Transport Protocol  |\n+----------------------+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 5: Receiver Operation with Sliding Window FEC Codes and RTP Repair Flows",
      "ja": "図5：スライディングウィンドウFECコードとRTP修復フローを使用した受信機の操作"
    },
    {
      "indent": 0,
      "text": "5. Protocol Specification",
      "section_title": true,
      "ja": "5. プロトコル仕様"
    },
    {
      "indent": 0,
      "text": "5.1. General",
      "section_title": true,
      "ja": "5.1. 全般"
    },
    {
      "indent": 3,
      "text": "This section discusses the protocol elements for the FEC Framework specific to Sliding Window FEC schemes. The global formats of source data packets (i.e., [RFC6363], Figure 6) and repair data packets (i.e., [RFC6363], Figures 7 and 8) remain the same with Sliding Window FEC codes. They are not repeated here.",
      "ja": "このセクションでは、スライディングウィンドウFECスキームに固有のFECフレームワークのプロトコル要素について説明します。 ソースデータパケット（つまり、[RFC6363]、図6）と修復データパケット（つまり、[RFC6363]、図7および8）のグローバル形式は、スライディングウィンドウFECコードと同じままです。 ここでは繰り返されません。"
    },
    {
      "indent": 0,
      "text": "5.2. FEC Framework Configuration Information",
      "section_title": true,
      "ja": "5.2. FECフレームワークの構成情報"
    },
    {
      "indent": 3,
      "text": "The FEC Framework Configuration Information considerations of Section 5.5 of [RFC6363] equally apply to this FECFRAME extension and are not repeated here.",
      "ja": "[RFC6363]のセクション5.5のFECフレームワーク構成情報の考慮事項は、このFECFRAME拡張にも等しく適用され、ここでは繰り返されません。"
    },
    {
      "indent": 0,
      "text": "5.3. FEC Scheme Requirements",
      "section_title": true,
      "ja": "5.3. FECスキームの要件"
    },
    {
      "indent": 3,
      "text": "The FEC scheme requirements of Section 5.6 of [RFC6363] mostly apply to this FECFRAME extension and are not repeated here. An exception, though, is the \"full specification of the FEC code\", item (4), which is specific to block FEC codes. In case of a Sliding Window FEC scheme, then the following item (4-bis) applies:",
      "ja": "[RFC6363]のセクション5.6のFECスキーム要件は、このFECFRAME拡張にほとんど適用され、ここでは繰り返されません。 ただし、例外は「FECコードの完全な仕様」、項目（4）です。これはブロックFECコードに固有です。 スライディングウィンドウFECスキームの場合、次の項目（4-bis）が適用されます。"
    },
    {
      "indent": 3,
      "text": "4-bis. A full specification of the Sliding Window FEC code.",
      "ja": "4-ビス。 スライディングウィンドウFECコードの完全な仕様。"
    },
    {
      "indent": 7,
      "text": "This specification MUST precisely define the valid FEC-Scheme-Specific Information values, the valid FEC Payload ID values, and the valid packet payload sizes (where \"packet payload\" refers to the space within a packet dedicated to carrying encoding symbols).",
      "ja": "この仕様は、有効なFEC-Scheme-Specific Information値、有効なFECペイロードID値、および有効なパケットペイロードサイズを正確に定義する必要があります（「パケットペイロード」は、エンコードシンボルの搬送専用パケット内のスペースを指します）。"
    },
    {
      "indent": 7,
      "text": "Furthermore, given valid values of the FEC-Scheme-Specific Information, a valid Repair FEC Payload ID value, a valid packet payload size, and a valid encoding window (i.e., a set of source symbols), the specification MUST uniquely define the values of the encoding symbol (or symbols) to be included in the repair packet payload with the given Repair FEC Payload ID value.",
      "ja": "さらに、FECスキーム固有情報の有効な値、有効な修復FECペイロードID値、有効なパケットペイロードサイズ、および有効なエンコードウィンドウ（つまり、ソースシンボルのセット）が与えられると、仕様は値を一意に定義しなければなりません 指定された修復FECペイロードID値を持つ修復パケットペイロードに含まれるエンコードシンボルのシンボル。"
    },
    {
      "indent": 3,
      "text": "Additionally, the FEC scheme associated with a Sliding Window FEC code:",
      "ja": "さらに、スライディングウィンドウFECコードに関連付けられたFECスキーム："
    },
    {
      "indent": 3,
      "text": "* MUST define the relationships between ADUs and the associated source symbols (mapping).",
      "ja": "* ADUと関連するソースシンボル（マッピング）の関係を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "* MUST define the management of the encoding window that slides over the set of ADUs. Appendix A provides non-normative hints about what FEC scheme designers need to consider.",
      "ja": "* ADUのセット上をスライドするエンコードウィンドウの管理を定義する必要があります。 付録Aは、FECスキームの設計者が考慮する必要のある非規範的なヒントを提供します。"
    },
    {
      "indent": 3,
      "text": "* MUST define the management of the decoding window. This usually consists of managing a system of linear equations (for a linear FEC code).",
      "ja": "* デコードウィンドウの管理を定義する必要があります。 これは通常、線形方程式のシステムの管理で構成されます（線形FECコードの場合）。"
    },
    {
      "indent": 0,
      "text": "6. Feedback",
      "section_title": true,
      "ja": "6. フィードバック"
    },
    {
      "indent": 3,
      "text": "The discussion in Section 6 of [RFC6363] equally applies to this FECFRAME extension and is not repeated here.",
      "ja": "[RFC6363]のセクション6の議論は、このFECFRAME拡張にも等しく適用され、ここでは繰り返されません。"
    },
    {
      "indent": 0,
      "text": "7. Transport Protocols",
      "section_title": true,
      "ja": "7. 転送プロトコル"
    },
    {
      "indent": 3,
      "text": "The discussion in Section 7 of [RFC6363] equally applies to this FECFRAME extension and is not repeated here.",
      "ja": "[RFC6363]のセクション7の議論は、このFECFRAME拡張にも等しく適用され、ここでは繰り返されません。"
    },
    {
      "indent": 0,
      "text": "8. Congestion Control",
      "section_title": true,
      "ja": "8. 輻輳制御"
    },
    {
      "indent": 3,
      "text": "The discussion in Section 8 of [RFC6363] equally applies to this FECFRAME extension and is not repeated here.",
      "ja": "[RFC6363]のセクション8の議論は、このFECFRAME拡張に等しく適用され、ここでは繰り返されません。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This FECFRAME extension does not add any new security considerations. All the considerations of Section 9 of [RFC6363] apply to this document as well. However, for the sake of completeness, the following goal can be added to the list provided in Section 9.1 of [RFC6363] (\"Problem Statement\"):",
      "ja": "このFECFRAME拡張は、新しいセキュリティ上の考慮事項を追加しません。 [RFC6363]のセクション9の考慮事項はすべて、この文書にも適用されます。 ただし、完全を期すために、次の目標を[RFC6363]のセクション9.1で提供されているリストに追加することができます（「問題の説明」）。"
    },
    {
      "indent": 3,
      "text": "* Attacks can try to corrupt source flows in order to modify the receiver application's behavior (as opposed to just denying service).",
      "ja": "* 攻撃は、（サービスを単に拒否するのではなく）受信側アプリケーションの動作を変更するためにソースフローを破壊しようとする可能性があります。"
    },
    {
      "indent": 0,
      "text": "10. Operations and Management Considerations",
      "section_title": true,
      "ja": "10. 運用と管理に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This FECFRAME extension does not add any new Operations and Management Considerations. All the considerations of Section 10 of [RFC6363] apply to this document as well.",
      "ja": "このFECFRAME拡張機能は、新しい運用および管理に関する考慮事項を追加しません。 [RFC6363]のセクション10の考慮事項はすべて、この文書にも適用されます。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "このドキュメントにはIANAアクションがありません。"
    },
    {
      "indent": 3,
      "text": "A FEC scheme for use with this FEC Framework is identified via its FEC Encoding ID. It is subject to IANA registration in the \"FEC Framework (FECFRAME) FEC Encoding IDs\" registry. All the rules of Section 11 of [RFC6363] apply and are not repeated here.",
      "ja": "このFECフレームワークで使用するFECスキームは、FECエンコーディングIDを介して識別されます。 「FECフレームワーク（FECFRAME）FECエンコーディングID」レジストリのIANA登録の対象です。 [RFC6363]のセクション11のすべての規則が適用され、ここでは繰り返されません。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12. 参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC6363] Watson, M., Begen, A., and V. Roca, \"Forward Error Correction (FEC) Framework\", RFC 6363, DOI 10.17487/RFC6363, October 2011, <https://www.rfc-editor.org/info/rfc6363>.",
      "ja": "[RFC6363] Watson、M.、Begen、A。、およびV. Roca、「Forward Error Correction（FEC）Framework」、RFC 6363、DOI 10.17487 / RFC6363、2011年10月、<https：//www.rfc-editor。 org / info / rfc6363>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https://www.rfc-editor.org/info/ rfc8174>。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[MBMSTS] 3GPP, \"Multimedia Broadcast/Multicast Service (MBMS); Protocols and codecs\", 3GPP TS 26.346, March 2009, <http://ftp.3gpp.org/specs/html-info/26346.htm>.",
      "ja": "[MBMSTS] 3GPP、「マルチメディアブロードキャスト/マルチキャストサービス（MBMS）;プロトコルとコーデック」、3GPP TS 26.346、2009年3月、<http://ftp.3gpp.org/specs/html-info/26346.htm>。"
    },
    {
      "indent": 3,
      "text": "[RFC5052] Watson, M., Luby, M., and L. Vicisano, \"Forward Error Correction (FEC) Building Block\", RFC 5052, DOI 10.17487/RFC5052, August 2007, <https://www.rfc-editor.org/info/rfc5052>.",
      "ja": "[RFC5052] Watson、M.、Luby、M.、およびL. Vicisano、「Forward Error Correction（FEC）Building Block」、RFC 5052、DOI 10.17487 / RFC5052、2007年8月、<https：//www.rfc-editor .org / info / rfc5052>。"
    },
    {
      "indent": 3,
      "text": "[RFC6364] Begen, A., \"Session Description Protocol Elements for the Forward Error Correction (FEC) Framework\", RFC 6364, DOI 10.17487/RFC6364, October 2011, <https://www.rfc-editor.org/info/rfc6364>.",
      "ja": "[RFC6364] Begen、A。、「前方誤り訂正（FEC）フレームワークのセッション記述プロトコル要素」、RFC 6364、DOI 10.17487 / RFC6364、2011年10月、<https://www.rfc-editor.org/info/ rfc6364>。"
    },
    {
      "indent": 3,
      "text": "[RFC6681] Watson, M., Stockhammer, T., and M. Luby, \"Raptor Forward Error Correction (FEC) Schemes for FECFRAME\", RFC 6681, DOI 10.17487/RFC6681, August 2012, <https://www.rfc-editor.org/info/rfc6681>.",
      "ja": "[RFC6681]ワトソン、M。、ストックハンマー、T。、およびM.ルビー、「FECFRAMEのラプターフォワードエラー訂正（FEC）スキーム」、RFC 6681、DOI 10.17487 / RFC6681、2012年8月、<https：//www.rfc -editor.org/info/rfc6681>。"
    },
    {
      "indent": 3,
      "text": "[RFC6816] Roca, V., Cunche, M., and J. Lacan, \"Simple Low-Density Parity Check (LDPC) Staircase Forward Error Correction (FEC) Scheme for FECFRAME\", RFC 6816, DOI 10.17487/RFC6816, December 2012, <https://www.rfc-editor.org/info/rfc6816>.",
      "ja": "[RFC6816] Roca、V.、Cunche、M。、およびJ. Lacan、「FECFRAMEの簡易低密度パリティチェック（LDPC）階段順方向誤り訂正（FEC）スキーム」、RFC 6816、DOI 10.17487 / RFC6816、2012年12月 、<https://www.rfc-editor.org/info/rfc6816>。"
    },
    {
      "indent": 3,
      "text": "[RFC6865] Roca, V., Cunche, M., Lacan, J., Bouabdallah, A., and K. Matsuzono, \"Simple Reed-Solomon Forward Error Correction (FEC) Scheme for FECFRAME\", RFC 6865, DOI 10.17487/RFC6865, February 2013, <https://www.rfc-editor.org/info/rfc6865>.",
      "ja": "[RFC6865] Roca、V.、Cunche、M.、Lacan、J.、Bouabdallah、A.、K。 RFC6865、2013年2月、<https://www.rfc-editor.org/info/rfc6865>。"
    },
    {
      "indent": 3,
      "text": "[RFC8406] Adamson, B., Adjih, C., Bilbao, J., Firoiu, V., Fitzek, F., Ghanem, S., Lochin, E., Masucci, A., Montpetit, M-J., Pedersen, M., Peralta, G., Roca, V., Ed., Saxena, P., and S. Sivakumar, \"Taxonomy of Coding Techniques for Efficient Network Communications\", RFC 8406, DOI 10.17487/RFC8406, June 2018, <https://www.rfc-editor.org/info/rfc8406>.",
      "ja": "[RFC8406] Adamson、B.、Adjih、C.、Bilbao、J.、Firoiu、V.、Fitzek、F.、Ghanem、S.、Lochin、E.、Masucci、A.、Montpetit、MJ。、Pedersen、 M.、Peralta、G.、Roca、V.、Ed。、Saxena、P。、およびS. Sivakumar、「効率的なネットワーク通信のためのコーディング技術の分類」、RFC 8406、DOI 10.17487 / RFC8406、2018年6月、<https ：//www.rfc-editor.org/info/rfc8406>。"
    },
    {
      "indent": 3,
      "text": "[RFC8681] Roca, V. and B. Teibi, \"Sliding Window Random Linear Code (RLC) Forward Erasure Correction (FEC) Schemes for FECFRAME\", RFC 8681, DOI 10.17487/RFC8681, January 2020, <https://www.rfc-editor.org/info/rfc8681>.",
      "ja": "[RFC8681] Roca、V。、およびB. Teibi、「FECFRAMEのスライディングウィンドウランダム線形コード（RLC）前方消去補正（FEC）スキーム」、RFC 8681、DOI 10.17487 / RFC8681、2020年1月、<https：// www。 rfc-editor.org/info/rfc8681>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. About Sliding Encoding Window Management (Informational)",
      "section_title": true,
      "ja": "付録A.スライドエンコーディングウィンドウ管理について（情報）"
    },
    {
      "indent": 3,
      "text": "The FEC Framework does not specify the management of the sliding encoding window, which is the responsibility of the FEC scheme. This annex only provides a few informational hints.",
      "ja": "FECフレームワークは、FECスキームの責任であるスライディングエンコーディングウィンドウの管理を指定しません。 この附属書は、いくつかの情報ヒントのみを提供します。"
    },
    {
      "indent": 3,
      "text": "Source symbols are added to the sliding encoding window each time a new ADU is available at the sender after the ADU-to-source-symbol mapping specific to the FEC scheme has been done.",
      "ja": "ソースシンボルは、FECスキームに固有のADUからソースシンボルへのマッピングが行われた後、送信側で新しいADUが利用可能になるたびに、スライディングエンコーディングウィンドウに追加されます。"
    },
    {
      "indent": 3,
      "text": "Source symbols are removed from the sliding encoding window. For instance:",
      "ja": "ソースシンボルは、スライディングエンコーディングウィンドウから削除されます。 例えば："
    },
    {
      "indent": 3,
      "text": "* After a certain delay, when an \"old\" ADU of a real-time flow times out. The source symbol retention delay in the sliding encoding window should therefore be initialized according to the real-time features of incoming flow(s) when applicable.",
      "ja": "* 一定の遅延の後、リアルタイムフローの「古い」ADUがタイムアウトしたとき。 したがって、適用可能な場合、スライディングエンコーディングウィンドウのソースシンボル保持遅延は、着信フローのリアルタイム機能に従って初期化する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Once the sliding encoding window has reached its maximum size (there is usually an upper limit to the sliding encoding window size). In that case, the oldest symbol is removed each time a new source symbol is added.",
      "ja": "* スライドエンコーディングウィンドウが最大サイズに達すると（通常、スライドエンコーディングウィンドウのサイズには上限があります）。 その場合、新しいソースシンボルが追加されるたびに、最も古いシンボルが削除されます。"
    },
    {
      "indent": 3,
      "text": "Several considerations can impact the management of this sliding encoding window:",
      "ja": "このスライディングエンコーディングウィンドウの管理には、いくつかの考慮事項が影響する可能性があります。"
    },
    {
      "indent": 3,
      "text": "* At the source flows level: real-time constraints can limit the total time during which source symbols can remain in the encoding window.",
      "ja": "* ソースフローレベル：リアルタイム制約により、ソースシンボルがエンコードウィンドウに留まることができる合計時間を制限できます。"
    },
    {
      "indent": 3,
      "text": "* At the FEC code level: theoretical or practical limitations (e.g., because of computational complexity) can limit the number of source symbols in the encoding window.",
      "ja": "* FECコードレベル：理論的または実際的な制限（計算の複雑さなど）により、エンコーディングウィンドウ内のソースシンボルの数が制限される場合があります。"
    },
    {
      "indent": 3,
      "text": "* At the FEC scheme level: signaling and window management are intrinsically related. For instance, an encoding window composed of a nonsequential set of source symbols requires appropriate signaling to inform a receiver of the composition of the encoding window, and the associated transmission overhead can limit the maximum encoding window size. On the contrary, an encoding window always composed of a sequential set of source symbols simplifies signaling: providing the identity of the first source symbol plus its number is sufficient, which creates a fixed and relatively small transmission overhead.",
      "ja": "* FECスキームレベルでは、シグナリングとウィンドウ管理は本質的に関連しています。 たとえば、ソースシンボルの非シーケンシャルセットで構成されるエンコードウィンドウには、エンコードウィンドウの構成を受信者に通知するための適切なシグナリングが必要であり、関連する送信オーバーヘッドによって最大エンコードウィンドウサイズが制限される場合があります。 それどころか、常にソースシンボルのシーケンシャルセットで構成されるエンコードウィンドウはシグナリングを簡素化します。最初のソースシンボルのIDとその数を提供するだけで十分であり、固定の比較的小さな送信オーバーヘッドが発生します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Christer Holmberg, David Black, Gorry Fairhurst, Emmanuel Lochin, Spencer Dawkins, Ben Campbell, Benjamin Kaduk, Eric Rescorla, Adam Roach, and Greg Skinner for their valuable feedback on this document. This document being an extension of [RFC6363], the authors would also like to thank Mark Watson as the main author of that RFC.",
      "ja": "著者は、この文書に関する貴重なフィードバックについて、クリスター・ホルムバーグ、デビッド・ブラック、ゴーリー・フェアハースト、エマニュエル・ローチン、スペンサー・ドーキンス、ベン・キャンベル、ベンジャミン・カドゥク、エリック・レスコーラ、アダム・ローチ、グレッグ・スキナーに感謝します。 このドキュメントは[RFC6363]の拡張であり、著者はそのRFCの主な著者としてマークワトソンにも感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Vincent Roca INRIA Univ. Grenoble Alpes France",
      "ja": "ヴィンセントロカINRIA大学 グルノーブルアルプフランス"
    },
    {
      "indent": 3,
      "text": "Email: vincent.roca@inria.fr",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Ali Begen Networked Media Konya/ Turkey",
      "ja": "Ali Begen Networked Media Konya /トルコ"
    },
    {
      "indent": 3,
      "text": "Email: ali.begen@networked.media",
      "raw": true
    }
  ]
}