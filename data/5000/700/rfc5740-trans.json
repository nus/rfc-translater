{
  "title": {
    "text": "RFC 5740 - NACK-Oriented Reliable Multicast (NORM) Transport Protocol",
    "ja": "RFC 5740 - NACK指向リライアブルマルチキャスト（NORM）トランスポートプロトコル"
  },
  "number": 5740,
  "created_at": "2019-10-28 05:19:52.700225+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         B. Adamson\nRequest for Comments: 5740                     Naval Research Laboratory\nObsoletes: 3940                                               C. Bormann\nCategory: Standards Track                        Universitaet Bremen TZI\n                                                              M. Handley\n                                               University College London\n                                                               J. Macker\n                                               Naval Research Laboratory\n                                                           November 2009",
      "raw": true
    },
    {
      "indent": 7,
      "text": "NACK-Oriented Reliable Multicast (NORM) Transport Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes the messages and procedures of the Negative-ACKnowledgment (NACK) Oriented Reliable Multicast (NORM) protocol. This protocol can provide end-to-end reliable transport of bulk data objects or streams over generic IP multicast routing and forwarding services. NORM uses a selective, negative acknowledgment mechanism for transport reliability and offers additional protocol mechanisms to allow for operation with minimal a priori coordination among senders and receivers. A congestion control scheme is specified to allow the NORM protocol to fairly share available network bandwidth with other transport protocols such as Transmission Control Protocol (TCP). It is capable of operating with both reciprocal multicast routing among senders and receivers and with asymmetric connectivity (possibly a unicast return path) between the senders and receivers. The protocol offers a number of features to allow different types of applications or possibly other higher-level transport protocols to utilize its service in different ways. The protocol leverages the use of FEC-based (forward error correction) repair and other IETF Reliable Multicast Transport (RMT) building blocks in its design. This document obsoletes RFC 3940.",
      "ja": "この文書では、信頼性の高いマルチキャスト（NORM）プロトコルを指向メッセージと否定応答（NACK）の手順を説明します。このプロトコルは、大量のデータオブジェクトのエンドツーエンドの信頼性の高いトランスポートを提供したり、一般的なIPマルチキャストルーティングおよび転送サービス上にストリームすることができます。 NORMは、輸送の信頼性のための選択的、否定応答機構を使用して送信者と受信者の間で最小の先験的コーディネーションと操作を可能にするために追加のプロトコルメカニズムを提供します。輻輳制御方式はNORMプロトコルはかなりそのような伝送制御プロトコル（TCP）などの他のトランスポートプロトコルで利用可能なネットワーク帯域幅を共有することを可能にするために指定されています。これは、送信者と受信者の間で相互マルチキャストルーティングの両方とし、送信者と受信者との間の非対称接続（おそらくユニキャスト復路）で動作することが可能です。プロトコルは、アプリケーションやおそらく他のより高いレベルのトランスポートプロトコルの異なるタイプが異なる方法でそのサービスを利用できるようにするために多数の機能を提供しています。プロトコルは、FECベース（前方誤り訂正）修理およびその設計の他のIETF信頼できるマルチキャストトランスポート（RMT）のビルディングブロックの使用を活用しています。この文書はRFC 3940を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2009 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2009 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクション4.eに記載されており、BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction and Applicability . . . . . . . . . . . . . . . .  4\n  1.1.  Requirements Language  . . . . . . . . . . . . . . . . . .  5\n  1.2.  NORM Data Delivery Service Model . . . . . . . . . . . . .  5\n  1.3.  NORM Scalability . . . . . . . . . . . . . . . . . . . . .  7\n  1.4.  Environmental Requirements and Considerations  . . . . . .  8\n2.  Architecture Definition  . . . . . . . . . . . . . . . . . . .  8\n  2.1.  Protocol Operation Overview  . . . . . . . . . . . . . . . 10\n  2.2.  Protocol Building Blocks . . . . . . . . . . . . . . . . . 12\n  2.3.  Design Trade-Offs  . . . . . . . . . . . . . . . . . . . . 12\n3.  Conformance Statement  . . . . . . . . . . . . . . . . . . . . 13\n4.  Message Formats  . . . . . . . . . . . . . . . . . . . . . . . 15\n  4.1.  NORM Common Message Header and Extensions  . . . . . . . . 15\n  4.2.  Sender Messages  . . . . . . . . . . . . . . . . . . . . . 18\n    4.2.1.  NORM_DATA Message  . . . . . . . . . . . . . . . . . . 18\n    4.2.2.  NORM_INFO Message  . . . . . . . . . . . . . . . . . . 28\n    4.2.3.  NORM_CMD Messages  . . . . . . . . . . . . . . . . . . 29\n  4.3.  Receiver Messages  . . . . . . . . . . . . . . . . . . . . 47\n    4.3.1.  NORM_NACK Message  . . . . . . . . . . . . . . . . . . 47\n    4.3.2.  NORM_ACK Message . . . . . . . . . . . . . . . . . . . 53\n  4.4.  General Purpose Messages . . . . . . . . . . . . . . . . . 55\n    4.4.1.  NORM_REPORT Message  . . . . . . . . . . . . . . . . . 55\n5.  Detailed Protocol Operation  . . . . . . . . . . . . . . . . . 55\n  5.1.  Sender Initialization and Transmission . . . . . . . . . . 57\n    5.1.1.  Object Segmentation Algorithm  . . . . . . . . . . . . 58",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  5.2.  Receiver Initialization and Reception  . . . . . . . . . . 59\n  5.3.  Receiver NACK Procedure  . . . . . . . . . . . . . . . . . 59\n  5.4.  Sender NACK Processing and Response  . . . . . . . . . . . 62\n    5.4.1.  Sender Repair State Aggregation  . . . . . . . . . . . 62\n    5.4.2.  Sender FEC Repair Transmission Strategy  . . . . . . . 63\n    5.4.3.  Sender NORM_CMD(SQUELCH) Generation  . . . . . . . . . 64\n    5.4.4.  Sender NORM_CMD(REPAIR_ADV) Generation . . . . . . . . 65\n  5.5.  Additional Protocol Mechanisms . . . . . . . . . . . . . . 65\n    5.5.1.  Group Round-Trip Time (GRTT) Collection  . . . . . . . 65\n    5.5.2.  NORM Congestion Control Operation  . . . . . . . . . . 67\n    5.5.3.  NORM Positive Acknowledgment Procedure . . . . . . . . 75\n    5.5.4.  Group Size Estimate  . . . . . . . . . . . . . . . . . 77\n6.  Configurable Elements  . . . . . . . . . . . . . . . . . . . . 77\n7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 80\n  7.1.  Baseline Secure NORM Operation . . . . . . . . . . . . . . 82\n    7.1.1.  IPsec Approach . . . . . . . . . . . . . . . . . . . . 83\n    7.1.2.  IPsec Requirements . . . . . . . . . . . . . . . . . . 85\n8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 86\n  8.1.  Explicit IANA Assignment Guidelines  . . . . . . . . . . . 87\n    8.1.1.  NORM Header Extension Types  . . . . . . . . . . . . . 87\n    8.1.2.  NORM Stream Control Codes  . . . . . . . . . . . . . . 88\n    8.1.3.  NORM_CMD Message Sub-Types . . . . . . . . . . . . . . 88\n9.  Suggested Use  . . . . . . . . . . . . . . . . . . . . . . . . 89\n10. Changes from RFC 3940  . . . . . . . . . . . . . . . . . . . . 90\n11. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 91\n12. References . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n  12.1. Normative References . . . . . . . . . . . . . . . . . . . 91\n  12.2. Informative References . . . . . . . . . . . . . . . . . . 92",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction and Applicability",
      "section_title": true,
      "ja": "1.序論と適用"
    },
    {
      "indent": 3,
      "text": "The Negative-ACKnowledgment (NACK) Oriented Reliable Multicast (NORM) protocol can provide reliable transport of data from one or more senders to a group of receivers over an IP multicast network. The primary design goals of NORM are to provide efficient, scalable, and robust bulk data (e.g., computer files, transmission of persistent data) transfer across possibly heterogeneous IP networks and topologies. The NORM protocol design provides support for distributed multicast session participation with minimal coordination among senders and receivers. NORM allows senders and receivers to dynamically join and leave multicast sessions at will with minimal overhead for control information and timing synchronization among participants. To accommodate this capability, NORM protocol message headers contain some common information allowing receivers to easily synchronize to senders throughout the lifetime of a reliable multicast session. NORM is self-adapting to a wide range of dynamic network conditions with little or no pre-configuration. The protocol is tolerant of inaccurate timing estimations or lossy conditions that can occur in many networks including mobile and wireless. The protocol can also converge and maintain efficient operation even in situations of heavy packet loss and large queuing or transmission delays. This document obsoletes the Experimental RFC 3940 specification.",
      "ja": "高信頼マルチキャスト（NORM）プロトコル指向否定応答（NACK）がIPマルチキャストネットワーク上の受信機のグループに1つ以上の送信者からのデータの信頼性の高いトランスポートを提供することができます。 NORMの主要な設計目標は、効率的でスケーラブル、かつ堅牢な大量のデータを提供している（例えば、コンピュータファイル、永続的なデータの伝送）、おそらく異種IPネットワークおよびトポロジ全体で転送。 NORMプロトコルの設計は、送信側と受信側の間で最小の配位を有する分散マルチキャストセッションへの参加のためのサポートを提供します。 NORMは、送信側と受信側が動的に参加し、参加者間の制御情報とタイミング同期のための最小限のオーバーヘッドでの意志でマルチキャストセッションを残すことができます。この機能に対応するために、NORMプロトコルメッセージヘッダは受信機が容易に信頼性の高いマルチキャストセッションの寿命を通して送信者と同期することを可能にするいくつかの一般的な情報を含んでいます。 NORMは、自己適応ほとんど又は全く事前に構成された動的なネットワーク条件の広い範囲にあります。プロトコルは、モバイルおよび無線を含む多くのネットワークで発生する可能性があり、不正確なタイミング推定又は損失性条件に耐性です。プロトコルはまた、収束とも重いパケットロス及び大イングまたは伝送遅延の状況で効率的な動作を維持することができます。この文書では、実験的RFC 3940の仕様を廃止します。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the IETF RMT working group and follows the guidelines provided in the Author Guidelines for Reliable Multicast Transport (RMT) Building Blocks and Protocol Instantiation documents [RFC3269].",
      "ja": "この文書は、IETF RMTワーキンググループの製品であり、信頼性の高いマルチキャストトランスポート（RMT）ビルディングブロックとプロトコルインスタンス文書[RFC3269]のための著者のガイドラインで提供されるガイドラインに従っています。"
    },
    {
      "indent": 3,
      "text": "Statement of Intent",
      "ja": "主旨書"
    },
    {
      "indent": 3,
      "text": "This memo contains the definitions necessary to fully specify a Reliable Multicast Transport protocol in accordance with the criteria of IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols [RFC2357]. The NORM specification described in this document was previously published in the Experimental Category [RFC3940]. It was the stated intent of the RMT working group to re-submit this specifications as an IETF Proposed Standard in due course. This Proposed Standard specification is thus based on RFC 3940 and has been updated according to accumulated experience and growing protocol maturity since the publication of RFC 3940. Said experience applies both to this specification itself and to congestion control strategies related to the use of this specification. The differences between RFC 3940 and this document are listed in Section 10.",
      "ja": "このメモは、完全に信頼できるマルチキャストトランスポートおよびアプリケーションプロトコル[RFC2357]を評価するためのIETF基準の基準に従って高信頼マルチキャストトランスポートプロトコルを指定するために必要な定義を含みます。この文書で説明NORMの仕様は、以前の実験カテゴリー[RFC3940]に掲載されました。やがて標準提案IETFとしてこの仕様を再提出するRMTワーキンググループの規定の趣旨でした。この提案された標準仕様は、RFC 3940 Saidの経験の出版物は、本明細書自体に、本明細書の使用に関連する輻輳制御戦略の両方に適用されるので、蓄積された経験と成長プロトコル成熟度に応じてこのようRFC 3940に基づいて、更新されました。 RFC 3940と、この文書の違いは、セクション10に記載されています。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. NORM Data Delivery Service Model",
      "section_title": true,
      "ja": "1.2。 NORMデータ配信サービスモデル"
    },
    {
      "indent": 3,
      "text": "A NORM protocol instance (NormSession) is defined within the context of participants communicating connectionless (e.g., Internet Protocol (IP) or User Datagram Protocol (UDP)) packets over a network using pre-determined addresses and host port numbers. Generally, the participants exchange packets using an IP multicast group address, but unicast transport MAY also be established or applied as an adjunct to multicast delivery. In the case of multicast, the participating NormNodes will communicate using a common IP multicast group address and port number chosen via means outside the context of the given NormSession. Other existing IETF data format and protocol standards MAY be applied to describe and convey the necessary a priori information for a specific NormSession (e.g., Session Description Protocol (SDP) [RFC4566], Session Announcement Protocol (SAP) [RFC2974], etc.).",
      "ja": "NORMプロトコルインスタンス（NormSession）が所定のアドレスとホスト・ポート番号を使用してネットワークを介してコネクション（例えば、インターネットプロトコル（IP）またはユーザデータグラムプロトコル（UDP））パケットを通信する参加者のコンテキスト内で定義されています。一般的に、参加者は、IPマルチキャストグループアドレスを使用してパケットを交換するが、ユニキャストトランスポートはまた、確立された、またはマルチキャスト配信の補助として適用することができます。マルチキャストの場合には、参加NormNodesは所与NormSessionのコンテキスト外の手段を介して選択された共通のIPマルチキャストグループアドレスとポート番号を使用して通信します。他の既存のIETFデータフォーマットおよびプロトコル標準が説明及び特定NormSessionに必要な事前情報を伝えるために適用されてもよい（例えば、セッション記述プロトコル（SDP）[RFC4566]、セッションアナウンスメントプロトコル（SAP）[RFC2974]など） 。"
    },
    {
      "indent": 3,
      "text": "The NORM protocol design is principally driven by the assumption of a single sender transmitting bulk data content to a group of receivers. However, the protocol MAY operate with multiple senders within the context of a single NormSession. In initial implementations of this protocol, it is anticipated that multiple senders will transmit independently of one another and receivers will maintain state as necessary for each sender. In future versions of NORM, it is possible some aspects of protocol operation (e.g., round-trip time collection) will provide for alternate modes allowing more efficient performance for applications requiring multiple senders.",
      "ja": "NORMプロトコルの設計は、主に受信機のグループにバルクデータコンテンツを送信する単一の送信者の仮定によって駆動されます。しかし、プロトコルは、単一NormSessionのコンテキスト内で複数の送信者で動作することができます。このプロトコルの初期の実装では、複数の送信者が、互いに独立して送信すると、受信機は、各送信者のために、必要に応じて状態を維持することが予想されます。 NORMの将来のバージョンでは、複数の送信者を必要とするアプリケーションのためのより効率的なパフォーマンスを可能にする代替モードを提供するプロトコルの動作（例えば、ラウンドトリップ時間コレクション）のいくつかの態様が可能です。"
    },
    {
      "indent": 3,
      "text": "NORM provides for three types of bulk data content objects (NormObjects) to be reliably transported. These types include:",
      "ja": "NORMを確実に搬送されるバルクデータコンテンツオブジェクト（NormObjects）の3種類を提供します。これらのタイプは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. static computer memory data content (NORM_OBJECT_DATA type),",
      "section_title": true,
      "ja": "1.スタティックコンピュータ・メモリ・データ・コンテンツ（NORM_OBJECT_DATA型）"
    },
    {
      "indent": 3,
      "text": "2. computer storage files (NORM_OBJECT_FILE type), and",
      "section_title": true,
      "ja": "2.コンピュータストレージファイル（NORM_OBJECT_FILEタイプ）、および"
    },
    {
      "indent": 3,
      "text": "3. non-finite streams of continuous data content (NORM_OBJECT_STREAM type).",
      "ja": "連続データコンテンツ（NORM_OBJECT_STREAM型）の3非有限のストリーム。"
    },
    {
      "indent": 3,
      "text": "The distinction between NORM_OBJECT_DATA and NORM_OBJECT_FILE is simply to provide a hint to receivers in NormSessions serving multiple types of content as to what type of storage to allocate for received content (i.e., memory or file storage). Other than that distinction, the two are identical, providing for reliable transport of finite (but potentially very large) units of content. These static data and file services are anticipated to be useful for multicast-based cache applications with the ability to reliably provide transmission of large quantities of static data. Other types of static data/file delivery services might make use of these transport object types, too. The use of the NORM_OBJECT_STREAM type is at the application's discretion and could be used to carry static data or file content also. The NORM reliable stream service opens up additional possibilities such as serialized reliable messaging or other unbounded, perhaps dynamically produced content. The NORM_OBJECT_STREAM provides for reliable transport analogous to that of the Transmission Control Protocol (TCP), although NORM receivers will be able to begin receiving stream content at any point in time. The applicability of this feature will depend upon the application.",
      "ja": "NORM_OBJECT_DATAとNORM_OBJECT_FILEの区別は、受信したコンテンツ（すなわち、メモリまたはファイルストレージ）に割り当てるストレージの種類に、コンテンツの複数のタイプのサービスを提供NormSessionsに受信機にヒントを提供するだけです。その違い以外、両者はコンテンツの有限の（潜在的に非常に大きい）ユニットの信頼性の高いトランスポートを提供する、同一です。これらの静的なデータやファイルサービスを確実に静的な大量のデータの伝送を提供する能力を持つマルチキャストベースのキャッシュの用途に有用であることが予想されます。静的データ/ファイル配信サービスの他のタイプも、これらのトランスポート・オブジェクト・タイプを利用するかもしれません。 NORM_OBJECT_STREAMタイプの使用は、アプリケーションの裁量であり、また、静的なデータやファイルの内容を運ぶために使用することができます。 NORM信頼性の高いストリームサービスは、このような直列化、信頼性の高いメッセージングや他の無制限、おそらく動的に作成されたコンテンツなどの追加の可能性を開きます。 NORMの受信機は、任意の時点でストリームコンテンツの受信を開始することができるであろうがNORM_OBJECT_STREAMは、伝送制御プロトコル（TCP）のものと類似した信頼性の高いトランスポートを提供します。この機能の適用は、用途に依存します。"
    },
    {
      "indent": 3,
      "text": "The NORM protocol also allows for a small amount of out-of-band data (sent as NORM_INFO messages) to be attached to the data content objects transmitted by the sender. This readily available out-of-band data allows multicast receivers to quickly and efficiently determine the nature of the corresponding data, file, or stream bulk content being transmitted. This allows application-level control of the receiver node's participation in the current transport activity. This also allows the protocol to be flexible with minimal pre-coordination among senders and receivers. The NORM_INFO content is atomic in that its size MUST fit into the payload portion of a single NORM message.",
      "ja": "NORMプロトコルはまた、送信者によって送信されたデータコンテンツオブジェクトに取り付けられる（NORM_INFOメッセージとして送信）帯域外データの少量を可能にします。この容易に利用可能な帯域外データは、マルチキャスト受信機が迅速かつ効率的に対応するデータ、ファイルの性質を決定することができ、又は送信されているバルクコンテンツをストリーミングします。これは、現在の輸送活性における受信ノードの参加のアプリケーションレベルの制御を可能にします。これはまた、プロトコルは、送信側と受信側の間で最小の事前配位を有する柔軟にすることができます。 NORM_INFOコンテンツは、そのサイズが単一NORMメッセージのペイロード部分に適合しなければならないことの原子です。"
    },
    {
      "indent": 3,
      "text": "NORM does NOT provide for global or application-level identification of data content within its message headers. Note the NORM_INFO out-of-band data mechanism can be leveraged by the application for this purpose if desired, or identification can alternatively be embedded within the data content. NORM does identify transmitted content (NormObjects) with transport identifiers that are applicable only while the sender is transmitting and/or repairing the given object. These transport data content identifiers (NormTransportIds) are assigned in a monotonically increasing fashion by each NORM sender during the course of a NormSession. Participants, including senders, in NORM protocol sessions are also identified with unique identifiers (NormNodeIds). Each sender maintains its NormTransportId assignments independently and thus individual NormObjects can be uniquely identified during transport by concatenation of the session-unique sender identifier (NormNodeId) and the assigned NormTransportId. The NormTransportIds are assigned from a large, but fixed, numeric space in increasing order and will be reassigned during long-lived sessions. The NORM protocol provides mechanisms so the sender application can terminate transmission of data content and inform the group of this in an efficient manner. Other similar protocol control mechanisms (e.g., session termination, receiver synchronization, etc.) are specified so reliable multicast application variants can realize different, complete bulk transfer communication models to meet their goals.",
      "ja": "NORMは、メッセージヘッダ内のデータコンテンツのグローバルまたはアプリケーションレベルの識別を提供しません。所望であればNORM_INFO帯域外データメカニズムは、この目的のために、アプリケーションによって活用することができ、または識別は、代替的に、データコンテンツ内に埋め込むことができます。 NORMは、送信者が送信および/または指定されたオブジェクトを修復している間だけ適用されるトランスポート識別子とともに送信されたコンテンツ（NormObjects）を識別し。これらトランスポート・データ・コンテンツ識別子（NormTransportIds）はNormSessionの過程で各NORM送信者によって単調に増加する方式で割り当てられます。 NORMプロトコルセッション中に送信者を含む参加者は、また、ユニークな識別子（NormNodeIds）で識別されます。各送信者は、独立して、そのNormTransportId割り当てを維持し、従って個々NormObjects一意のセッション固有の送信元識別子（NormNodeId）と割り当てNormTransportIdの連結によって輸送中に同定することができます。 NormTransportIdsは大から割り当てられたが、固定、数字のスペースを増やすために、かつ長寿命のセッション中に再割り当てされますされています。送信側アプリケーションは、データコンテンツの送信を終了し、効率的な方法でこのグループに通知することができるように、NORMプロトコルはメカニズムを提供します。他の同様のプロトコル制御機構（例えば、セッション終了、受信機の同期など）は信頼性の高いマルチキャストアプリケーションの変異体は、それらの目標を達成するために異なる、完全バルク転送通信モデルを実現することができる指定されています。"
    },
    {
      "indent": 3,
      "text": "To summarize, the NORM protocol provides reliable transport of different types of data content (including potentially mixed types). The senders enqueue and transmit bulk content in the form of static data or files and/or non-finite, ongoing stream types. NORM senders provide for repair transmission of data and/or FEC content in response to NACK messages received from the receiver group. Mechanisms for out-of-band information and other transport control mechanisms are specified for use by applications to form complete reliable multicast solutions for different purposes.",
      "ja": "要約すると、NORMプロトコルは、（潜在的混合型を含む）のデータ内容の異なる種類の信頼性の高いトランスポートを提供します。送信者は、エンキューおよび静的なデータやファイル、および/または非有限、継続的なストリーム型の形で一括コンテンツを送信します。 NORMの送信者は、受信機グループから受信したNACKメッセージに応答して、データおよび/またはFECコンテンツの修復伝送を提供します。アウト・オブ・バンド情報や他のトランスポート制御機構のためのメカニズムは、異なる目的のために完全な信頼性の高いマルチキャストソリューションを形成するためのアプリケーションによる使用のために指定されています。"
    },
    {
      "indent": 0,
      "text": "1.3. NORM Scalability",
      "section_title": true,
      "ja": "1.3。 NORMスケーラビリティ"
    },
    {
      "indent": 3,
      "text": "Group communication scalability requirements lead to adaptation of NACK-based protocol schemes when feedback for reliability is needed [RmComparison]. NORM is a protocol centered around the use of selective NACKs to request repairs of missing data. NORM provides for the use of packet-level forward error correction (FEC) techniques for efficient multicast repair and OPTIONAL proactive transmission robustness [RFC3453]. FEC-based repair can be used to greatly reduce the quantity of reliable multicast repair requests and repair transmissions [MdpToolkit] in a NACK-oriented protocol. The principal factor in NORM scalability is the volume of feedback traffic generated by the receiver set to facilitate reliability and congestion control. NORM uses probabilistic suppression of redundant feedback based on exponentially distributed random backoff timers. The performance of this type of suppression relative to other techniques is described in [McastFeedback]. NORM dynamically measures the group's round-trip timing status to set its suppression and other protocol timers. This allows NORM to scale well while maintaining reliable data delivery transport with low latency relative to the network topology over which it is operating.",
      "ja": "グループ通信スケーラビリティ要件は、信頼性のためのフィードバック[RmComparison】必要とされるNACKベースのプロトコル方式の適応につながります。 NORMは、欠落データの修理を依頼して、選択NACKの使用を中心とするプロトコルです。 NORMは、効率的なマルチキャスト修復およびOPTIONALプロアクティブ送信ロバスト性[RFC3453]のためのパケットレベルの順方向誤り訂正（FEC）技術の使用を提供します。 FECベースの修復が大きくNACK指向プロトコルの[MdpToolkit】信頼性の高いマルチキャスト修復要求および修復送信の量を減少させるために使用することができます。 NORMスケーラビリティの主要因は、信頼性と輻輳制御を容易にするために、設定受信機によって生成されたフィードバックトラフィックの量です。 NORMは指数関数的に分布するランダムバックオフタイマーに基づく冗長フィードバックの確率抑制を使用します。他の技術に抑制に対するこのタイプの性能は、[McastFeedback]に記載されています。 NORMは、動的に抑制し、他のプロトコルタイマーを設定するには、グループの往復のタイミングの状態を測定します。これは、それが動作している上に、ネットワークトポロジへの低レイテンシ相対有する信頼性の高いデータ配信輸送を維持しながら、NORMがうまくスケーリングすることを可能にします。"
    },
    {
      "indent": 3,
      "text": "Feedback messages can be either multicast to the group at large or sent via unicast routing to the sender. In the case of unicast feedback, the sender relays the feedback state to the group to facilitate feedback suppression. In typical Internet environments, the NORM protocol will readily scale to group sizes on the order of tens of thousands of receivers. A study of the quantity of feedback for this type of protocol is described in [NormFeedback]. NORM is able to operate with a smaller amount of feedback than a single TCP connection, even with relatively large numbers of receivers. Thus, depending upon the network topology, it is possible for NORM to scale to larger group sizes. With respect to computer resource usage, the",
      "ja": "フィードバックメッセージは大でグループへのマルチキャストまたは送信者へのユニキャストルーティングを介して送信のいずれかであり得ます。ユニキャストフィードバックの場合、送信側はフィードバック抑制を容易にするためにグループにフィードバック状態を中継します。典型的なインターネット環境では、NORMプロトコルは容易に数十受信機の数千のオーダーのグループサイズにスケーリングします。プロトコルのこのタイプのフィードバックの量の研究が[NormFeedback]に記載されています。 NORMも受信機の比較的大きな数と、単一のTCP接続よりもフィードバックの少ない量で動作することが可能です。 NORMが大きなグループサイズにスケーリングするためにこのように、ネットワークトポロジに依存し、それが可能です。コンピュータのリソース使用量に関しては、"
    },
    {
      "indent": 3,
      "text": "NORM protocol does not need state to be kept on all receivers in the group. NORM senders maintain state only for receivers providing explicit congestion control feedback. However, NORM receivers need to maintain state for each active sender. This can constrain the number of simultaneous senders in some uses of NORM.",
      "ja": "NORMプロトコルは、グループ内のすべての受信機に保持される状態を必要としません。 NORMの送信者は、明示的な輻輳制御フィードバックを提供する受信機の状態を維持します。しかし、NORM受信機は、各アクティブな送信者の状態を維持する必要があります。これは、NORMのいくつかの用途での同時送信者の数を制限することができます。"
    },
    {
      "indent": 0,
      "text": "1.4. Environmental Requirements and Considerations",
      "section_title": true,
      "ja": "1.4。環境要件および考慮事項"
    },
    {
      "indent": 3,
      "text": "All of the environmental requirements and considerations that apply to the \"Multicast Negative-Acknowledgment (NACK) Building Blocks\" [RFC5401], \"Forward Error Correction (FEC) Building Block\" [RFC5052], and \"TCP-Friendly Multicast Congestion Control (TFMCC) Protocol Specification\" [RFC4654] also apply to the NORM protocol.",
      "ja": "「マルチキャスト否定応答（NACK）ビルディング・ブロック」[RFC5401]、「前方誤り訂正（FEC）ビルディングブロック」[RFC5052]、および「TCPフレンドリーマルチキャスト輻輳制御に適用される環境要件と考慮事項のすべて（TFMCC ）プロトコル仕様」[RFC4654]もNORMプロトコルに適用します。"
    },
    {
      "indent": 3,
      "text": "The NORM protocol SHALL be capable of operating in an end-to-end fashion with no assistance from intermediate systems beyond basic IP multicast group management, routing, and forwarding services. While the techniques utilized in NORM are principally applicable to flat, end-to-end IP multicast topologies, they could also be applied in the sub-levels of hierarchical (e.g., tree-based) multicast distribution if so desired. NORM can make use of reciprocal (among senders and receivers) multicast communication under the Any-Source Multicast (ASM) model defined in \"Host Extensions for IP Multicasting\" [RFC1112], but it SHALL also be capable of scalable operation in asymmetric topologies such as Source-Specific Multicast (SSM) [RFC4607] where only unicast routing service is available from the receivers to the sender(s).",
      "ja": "NORMプロトコルは、基本的なIPマルチキャストグループ管理、ルーティング、および転送サービスを越えて、中間システムからのない支援を受けて、エンドツーエンド方式で動作可能でなければなりません。 NORMに利用技術はフラット、エンドツーエンドのIPマルチキャストトポロジに主に適用可能であるが、所望であれば、それらはまた、階層（例えば、ツリーベースの）マルチキャスト配信のサブレベルで適用することができます。 NORMは、「IPマルチキャスティングのためのホスト拡大」[RFC1112]で定義された任意の-ソースマルチキャスト（ASM）モデルの下でマルチキャスト通信（送信者と受信者の間で）の逆数を利用することができますが、それはまた、非対称トポロジなどでスケーラブルな動作が可能なものでなければなりませんソース固有マルチキャスト（SSM）[RFC4607]は、ユニキャストルーティングサービスが受信機から送信者（複数可）に利用可能です。"
    },
    {
      "indent": 3,
      "text": "NORM is compatible with IPv4 and IPv6. Additionally, NORM can be used with networks employing Network Address Translation (NAT) provided that the NAT device supports IP multicast and/or can cache UDP traffic source port numbers for remapping feedback traffic from receivers to the sender(s).",
      "ja": "NORMは、IPv4とIPv6と互換性があります。さらに、NORMは、ネットワークアドレス変換（NAT）を使用するネットワークで使用できるNATデバイスは、IPマルチキャストをサポートし、および/または送信者（複数可）に受信機からのフィードバックトラフィックを再マッピングするためにUDPトラフィックの送信元ポート番号をキャッシュできることを条件とします。"
    },
    {
      "indent": 0,
      "text": "2. Architecture Definition",
      "section_title": true,
      "ja": "2.アーキテクチャの定義"
    },
    {
      "indent": 3,
      "text": "A NormSession is comprised of participants (NormNodes) acting as senders and/or receivers. NORM senders transmit data content in the form of NormObjects to the session destination address, and the NORM receivers attempt to reliably receive the transmitted content using negative acknowledgments to request repair. Each NormNode within a NormSession is assumed to have a preselected unique 32-bit identifier (NormNodeId). NormNodes MUST have uniquely assigned identifiers within a single NormSession to distinguish between multiple possible senders and to distinguish feedback information from different receivers. There are two reserved NormNodeId values. A value of 0x00000000 is considered an invalid NormNodeId (NORM_NODE_NONE), and a value of 0xffffffff is a \"wild card\" NormNodeId (NORM_NODE_ANY).",
      "ja": "NormSessionは、送信者及び/又は受信機として動作する参加者（NormNodes）から構成されています。 NORMの送信者は、セッションの宛先アドレスにNormObjectsの形態におけるデータコンテンツを送信し、NORM受信機は確実に修理を要求する否定応答を使用して送信されたコンテンツを受信することを試みます。 NormSession内の各NormNodeは、予め選択された一意の32ビット識別子（NormNodeId）を有するものとします。 NormNodes一意複数の可能な送信者を区別し、異なる受信機からのフィードバック情報を区別するために単一NormSession内に識別子を割り当てておく必要があります。 2つの予約NormNodeId値があります。 0x00000000の値が無効NormNodeId（NORM_NODE_NONE）とみなされ、値0xFFFFFFFFは、「ワイルドカード」NormNodeId（NORM_NODE_ANY）です。"
    },
    {
      "indent": 3,
      "text": "While the protocol does not preclude multiple sender nodes concurrently transmitting within the context of a single NORM session (i.e., many-to-many operation), any type of interactive coordination among NORM senders is assumed to be controlled by the application- or higher-protocol layer. There are some OPTIONAL mechanisms specified in this document that can be leveraged for such application-layer coordination.",
      "ja": "プロトコルは、同時に単一NORMセッションのコンテキスト内で送信する複数の送信ノードを排除するものではないながら（すなわち、多対多の操作）、NORMの送信者の間で対話協調の任意の種類は用途向け又はhigher-によって制御されているものとしますプロトコル層。このようなアプリケーション層の調整のために活用することができ、この文書で指定されたいくつかのオプションメカニズムがあります。"
    },
    {
      "indent": 3,
      "text": "As previously noted, NORM allows for reliable transmission of three different basic types of data content. The first type is NORM_OBJECT_DATA, which is used for static, persistent blocks of data content maintained in the sender's application memory storage. The second type is NORM_OBJECT_FILE, which corresponds to data stored in the sender's non-volatile file system. The NORM_OBJECT_DATA and NORM_OBJECT_FILE types both represent NormObjects of finite but potentially very large size. The third type of data content is NORM_OBJECT_STREAM, which corresponds to an ongoing transmission of undefined length. This is analogous to the reliable stream service provided by TCP for unicast data transport. The format of the stream content is application-defined and can be \"byte\" or \"message\" oriented. The NORM protocol provides for \"flushing\" of the stream to expedite delivery or possibly enforce application message boundaries. NORM protocol implementations MAY offer either (or both) in-order delivery of the stream data to the receive application or out-of-order (more immediate) delivery of received segments of the stream to the receiver application. In either case, NORM sender and receiver implementations provide buffering to facilitate repair of the stream as it is transported.",
      "ja": "先に述べたように、NORMは、データコンテンツの三つの異なる基本的な種類の信頼性のある伝送を可能にします。第一のタイプは、送信者のアプリケーションのメモリ記憶装置内に維持されるデータコンテンツの静的な、永続的なブロックのために使用されるNORM_OBJECT_DATA、です。第二のタイプは、送信者の不揮発性ファイルシステムに格納されたデータに対応NORM_OBJECT_FILE、です。 NORM_OBJECT_DATAとNORM_OBJECT_FILEタイプの両方が有限でなく、潜在的に非常に大きなサイズのNormObjectsを表します。データコンテンツの第三のタイプは、不定長の進行中の送信に対応NORM_OBJECT_STREAM、です。これは、ユニキャストデータ転送のためのTCPが提供する信頼性の高いストリームサービスに類似しています。ストリームコンテンツのフォーマットは、アプリケーション定義され、「バイト」または「メッセージ」配向させることができます。 NORMプロトコルは、送達を促進または可能性アプリケーションメッセージの境界を適用するストリームの「フラッシング」を提供します。 NORMプロトコル実装は、インオーダー受信アプリケーションへのストリームデータの配信または受信機アプリケーションへのストリームの受信セグメントのアウトオブオーダー（より迅速）の送達のいずれか（または両方）を提供することができます。いずれの場合においても、NORMの送信側と受信側の実装は、それが搬送されるストリームの修復を促進するためにバッファリングを提供します。"
    },
    {
      "indent": 3,
      "text": "All NormObjects are logically segmented into FEC coding blocks and symbols for transmission by the sender. In NORM, a FEC encoding symbol directly corresponds to the payload of NORM_DATA messages or \"segment\". Note that when systematic FEC codes are used, the payload of NORM_DATA messages sent for the first portion of a FEC encoding block are source symbols (actual segments of original user data), while the remaining symbols for the block consist of parity symbols generated by FEC encoding. These parity symbols are generally sent in response to repair requests, but some number MAY be sent proactively at the end of each encoding block to increase the robustness of transmission. When non-systematic FEC codes are used, all symbols sent consist of FEC encoding parity content. In this case, the receiver needs to receive a sufficient number of symbols to reconstruct (via FEC decoding) the original user data for the given block.",
      "ja": "すべてのNormObjectsは、論理的に、送信者による送信のためFEC符号化ブロックとシンボルに分割されています。 NORMでは、FEC符号化シンボルは、直接NORM_DATAメッセージのペイロードまたは「セグメント」に相当します。システマティックFEC符号が使用される場合、ブロックの残りのシンボルがFECによって生成されたパリティシンボルで構成しながら、FEC符号化ブロックの最初の部分のために送らNORM_DATAメッセージのペイロードは、ソースシンボル（元のユーザーデータの実際のセグメント）であることに注意してくださいエンコーディング。これらのパリティシンボルは、一般的に修理要求に応じて送信されますが、いくつかの数は伝送の堅牢性を高めるために、各符号化ブロックの最後に積極的に送るかもしれません。非体系的FECコードが使用されている場合は、送信されたすべてのシンボルは、FEC符号化パリティ内容で構成されています。この場合、受信機は、所与のブロックについて（FEC復号化を介して）元のユーザーデータを再構成するシンボルの十分な数を受信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Transmitted NormObjects are temporarily, yet uniquely, identified within the NormSession context using the given sender's NormNodeId, NormInstanceId, and a temporary NormTransportId. Depending upon the implementation, individual NORM senders can manage their NormInstanceIds independently, or a common NormInstanceId could be agreed upon for all participating nodes within a session, if needed, as a session identifier. NORM NormTransportId data content identifiers are sender-assigned and applicable and valid only during a NormObject's actual transport (i.e., for as long as the sender is transmitting and providing repair of the indicated NormObject). For a long-lived session, the NormTransportId field can wrap and previously used identifiers will be re-used. Note that globally unique identification of transported data content is not provided by NORM and, if necessary, is expected to be managed by the NORM application. The individual segments or symbols of the NormObject are further identified with FEC payload identifiers that include coding block and symbol identifiers. These are discussed in detail later in this document.",
      "ja": "送信NormObjectsは一時的にある、まだ一意に、与えられた送信者のNormNodeId、NormInstanceId、一時NormTransportIdを使用してNormSessionコンテキスト内で識別します。実装に応じて、個々のNORMの送信者は、独立して自分のNormInstanceIdsを管理することができ、または必要に応じて共通NormInstanceIdは、セッション識別子として、セッション内のすべての参加ノードのために合意することができます。 NORM NormTransportIdデータコンテンツ識別子のみNormObjectの実際の輸送中に送信者に割り当てられ、該当すると有効である（すなわち、限り、送信者が送信し、指示NormObjectの修復を提供しているようにするため）。長寿命のセッションの場合、NormTransportIdフィールドをラップすることができますし、以前に使用される識別子は再利用されます。伝送されるデータコンテンツのグローバル一意識別子をNORMによって提供されないことに注意し、必要に応じて、NORMアプリケーションによって管理されることが予想されます。 NormObjectの個々のセグメント又はシンボルはさらにブロックとシンボル識別子をコーディング含むFECペイロード識別子で識別されます。これらは、このドキュメントの後半で詳しく説明されています。"
    },
    {
      "indent": 0,
      "text": "2.1. Protocol Operation Overview",
      "section_title": true,
      "ja": "2.1。プロトコルの動作概要"
    },
    {
      "indent": 3,
      "text": "A NORM sender primarily generates messages of type NORM_DATA. These messages carry original data segments or FEC symbols and repair segments/symbols for the bulk data/file or stream NormObjects being transferred. By default, redundant FEC symbols are sent only in response to receiver repair requests (NACKs) and thus normally little or no additional transmission overhead is imposed due to FEC encoding. However, the NORM implementation MAY be configured to proactively transmit some amount of redundant FEC symbols along with the original content to potentially enhance performance (e.g., improved delay) at the cost of additional transmission overhead. This configuration is sensible for certain network conditions and can allow for robust, asymmetric multicast (e.g., unidirectional routing, satellite, cable) [FecHybrid] with reduced receiver feedback, or, in some cases, no feedback.",
      "ja": "NORMの送信者は、主に型NORM_DATAのメッセージを生成します。これらのメッセージは、元のデータセグメント又はFEC記号と転送されるバルクデータ/ファイルまたはストリームNormObjectsの修復セグメント/シンボルを搬送します。デフォルトでは、冗長FECシンボルはリペア要求（NACKを）受信機のみ応答して送信され、従って、通常はほとんどまたは全く追加の送信オーバーヘッドを伴うFEC符号化に課されます。しかし、NORMの実装では、追加の送信オーバーヘッドのコストでの性能（例えば、改善された遅延）を高める積極的に潜在的に元のコンテンツと一緒に冗長FEC記号のある量を送信するように構成され得ます。この構成は、特定のネットワーク条件のために賢明であると還元受信フィードバック、または、いくつかの場合には、フィードバックのない堅固な、非対称マルチキャスト（例えば、一方向ルーティング、衛星、ケーブル）[FecHybrid]を可能にすることができます。"
    },
    {
      "indent": 3,
      "text": "A sender message of type NORM_INFO is also defined and is used to carry OPTIONAL out-of-band context information for a given transport object. A single NORM_INFO message can be associated with a NormObject. Because of its atomic nature, missing NORM_INFO messages can be NACKed and repaired with a slightly lower delay process than NORM's general FEC-encoded data content. The NORM_INFO message can serve special purposes for some bulk transfer, reliable multicast applications where receivers join the group mid-stream and need to ascertain contextual information on the current content being transmitted. The NACK process for NORM_INFO will be described later. When the NORM_INFO message type is used, its transmission SHOULD precede transmission of any NORM_DATA message for the associated NormObject.",
      "ja": "タイプNORM_INFOの送信者メッセージも定義され、所定のトランスポート・オブジェクトのOPTIONALアウトオブバンドコンテキスト情報を搬送するために使用されます。単一NORM_INFOメッセージはNormObjectに関連付けることができます。理由は、その原子の性質上、行方不明NORM_INFOメッセージがNORMの一般的なFEC符号化されたデータの内容よりも若干低い遅延処理でNACKされ、修復することができます。 NORM_INFOメッセージは、いくつかのバルク転送、受信機がグループミッドストリームに参加して送信されている現在のコンテンツのコンテキスト情報を把握する必要がある信頼性の高いマルチキャストアプリケーションのための特別な目的を果たすことができます。 NORM_INFOのためのNACK処理については後述します。 NORM_INFOメッセージタイプを使用した場合、その送信は、関連NormObjectための任意NORM_DATAメッセージの送信に先行すべきです。"
    },
    {
      "indent": 3,
      "text": "The sender also generates messages of type NORM_CMD to assist in certain protocol operations such as congestion control, end-of-transmission flushing, group round-trip time (GRTT) estimation, receiver synchronization, and OPTIONAL positive acknowledgment requests or application-defined commands. The transmission of NORM_CMD messages from the sender is accomplished by one of three different procedures: single, best-effort unreliable transmission of the command; repeated redundant transmissions of the command; and positively acknowledged commands. The transmission technique used for a given command depends upon the function of the command. Several core commands are defined for basic protocol operation. Additionally, implementations MAY wish to consider providing the OPTIONAL application-defined commands that can take advantage of the transmission methodologies available for commands. This allows for application-level session management mechanisms that can make use of information available to the underlying NORM protocol engine (e.g., round-trip timing, transmission rate, etc.). A notable distinction between NORM_DATA message and some NORM_CMD message transmissions is that typically a receiver will need to allocate resources to manage reliable reception when NORM_DATA messages are received. However, some NORM_CMD messages are completely atomic and no specific reliability (buffering) state needs to be kept. Thus, for session management or other purposes, it is possible that even participants acting principally as data receivers MAY transmit NORM_CMD messages. However, it is RECOMMENDED that this is not done within the context of the NORM multicast session unless congestion control is addressed. For example, many receiver nodes transmitting NORM_CMD messages simultaneously can cause congestion for the destination(s).",
      "ja": "送信者はまた、輻輳制御、エンドオブ送信フラッシング、グループラウンドトリップ時間（GRTT）推定、受信機の同期、およびオプションの肯定応答要求またはアプリケーションで定義されたコマンドなどの特定のプロトコル操作を補助するために型NORM_CMDのメッセージを生成します。送信者からのNORM_CMDメッセージの送信は、3つの異なる方法の1つによって達成された：コマンドのシングル、ベストエフォート型の信頼性の低い伝送。コマンドの冗長送信を繰り返しました。そして、積極的にコマンドを認めました。所与のコマンドに使用される伝送技術は、コマンドの機能に依存します。いくつかのコアコマンドは、基本的なプロトコルの動作のために定義されています。また、実装はコマンドの利用可能な伝送方法論を利用することができますオプションのアプリケーション定義コマンドを提供することを検討することを望むかもしれません。これは、基礎となるNORMプロトコルエンジンへの情報の使用は、利用可能にするアプリケーション・レベルのセッション管理メカニズムを可能にする（例えば、往復タイミング、送信レート、等）。 NORM_DATAメッセージといくつかのNORM_CMDメッセージ送信の間の顕著な違いは、通常、受信機がNORM_DATAメッセージを受信したときに確実に受信を管理するためのリソースを割り当てる必要がありますということです。しかし、いくつかのNORM_CMDメッセージは完全に原子であり、具体的な信頼性（バッファリング）状態を維持する必要はありません。このように、セッション管理、または他の目的のために、データ受信機として主に機能するも、参加者がNORM_CMDメッセージを送信する可能性があります。しかし、輻輳制御がアドレス指定されない限り、これはNORMのマルチキャストセッションのコンテキスト内で実行されていないことが推奨されます。例えば、同時にNORM_CMDメッセージを送信する多くの受信ノードが宛先（S）のための輻輳を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "All sender transmissions are subject to rate control governed by a peak transmission rate set for each participant by the application. This can be used to limit the quantity of multicast data transmitted by the group. When NORM's congestion control algorithm is enabled, the rate for senders is automatically adjusted. In some networks, it is desirable to establish minimum and maximum bounds for the rate adjustment depending upon the application even when dynamic congestion control is enabled. However, in the case of the general Internet, congestion control policy SHALL be observed that is compatible with coexistent TCP flows.",
      "ja": "すべての送信者の送信は、アプリケーションによって、各参加者のために設定されたピーク伝送速度に支配制御を評価することがあります。これは、グループによって送信されたマルチキャストデータの量を制限するために使用することができます。 NORMの輻輳制御アルゴリズムを有効にすると、送信者のためのレートが自動的に調整されます。一部のネットワークでは、動的な輻輳制御が有効になっても、用途に応じて速度調整の最小と最大の境界を確立することが望ましいです。しかし、一般的なインターネットの場合には、輻輳制御ポリシーが共存TCPフローと互換性のある観察します。"
    },
    {
      "indent": 3,
      "text": "NORM receivers generate messages of type NORM_NACK or NORM_ACK in response to transmissions of data and commands from a sender. The NORM_NACK messages are generated to request repair of detected data transmission losses. Receivers generally detect losses by tracking the sequence of transmission from a sender. Sequencing information is embedded in the transmitted data packets and end-of-transmission commands from the sender. NORM_ACK messages are generated in response to certain commands transmitted by the sender. In the general (and most scalable) protocol mode, NORM_ACK messages are sent only in response to congestion control commands from the sender. The feedback volume of these congestion control NORM_ACK messages is controlled using the same timer-based probabilistic suppression techniques as for NORM_NACK messages to avoid feedback implosion. In order to meet potential application requirements for positive acknowledgment from receivers, other NORM_ACK messages are defined and are available for use.",
      "ja": "NORM受信機は、送信者からのデータやコマンドの送信に応じて、型NORM_NACKまたはNORM_ACKのメッセージを生成します。 NORM_NACKメッセージが検出されたデータ伝送損失の修理を依頼するために生成されます。受信機は、一般的に、送信者からの送信の順序を追跡することによって損失を検出します。シーケンシング情報は、送信者から送信されるデータパケットと終了の送信コマンドに埋め込まれています。 NORM_ACKメッセージは送信者によって送信された特定のコマンドに応答して生成されます。一般的な（そして最もスケーラブルな）プロトコルモードでは、NORM_ACKメッセージは送信者だけから輻輳制御コマンドに応答して送信されます。これらの輻輳制御NORM_ACKメッセージのフィードバック量は、フィードバック内部破裂を避けるためにNORM_NACKメッセージのと同じタイマによる確率的抑制技術を使用して制御されます。受信機からの肯定応答のための潜在的なアプリケーション要件を満たすために、他のNORM_ACKメッセージが定義されており、使用のために用意されています。"
    },
    {
      "indent": 0,
      "text": "2.2. Protocol Building Blocks",
      "section_title": true,
      "ja": "2.2。プロトコル・ビルディング・ブロック"
    },
    {
      "indent": 3,
      "text": "The operation of the NORM protocol is based primarily upon the concepts presented in the Multicast NACK Building Block [RFC5401] document. This includes the basic NORM architecture and the data transmission, repair, and feedback strategies discussed in that document. The reliable multicast building block approach, as described in \"Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer\" [RFC3048], is applied in creating the full NORM protocol instantiation. NORM also makes use of the parity-based encoding techniques for repair messaging and added transmission robustness as described in \"The Use of Forward Error Correction (FEC) in Reliable Multicast\" [RFC3453]. NORM uses the FEC Payload ID as specified by the FEC Building Block document [RFC5052]. Additionally, for congestion control, this document fully specifies a baseline congestion control mechanism (NORM-CC) based on the TCP-Friendly Multicast Congestion Control (TFMCC) scheme [TfmccPaper], [RFC4654].",
      "ja": "NORMプロトコルの動作は、主にマルチキャストNACKビルディングブロック[RFC5401]文書の概念に基づいています。これは、その文書で説明する基本的なNORMアーキテクチャとデータ伝送、修理、およびフィードバック戦略が含まれています。 [RFC3048]「一対多バルクデータ転送のための信頼できるマルチキャストトランスポート・ビルディング・ブロック」に記載されているように信頼性の高いマルチキャスト・ビルディング・ブロック・アプローチは、完全NORMプロトコルインスタンスを作成する際に適用されます。 [RFC3453]「前方誤り訂正高信頼マルチキャストで（FEC）の使用」に記載されているようにNORMはまた、修復メッセージングおよび添加送信ロバスト性のためのパリティ・ベースの符号化技術を利用します。 FECビルディングブロック文献[RFC5052]で指定されたノルムはFECペイロードIDを使用します。また、輻輳制御のために、この文書は、完全TCPフレンドリーマルチキャスト輻輳制御（TFMCC）方式[TfmccPaper]、[RFC4654]に基づいて、基準輻輳制御機構（NORM-CC）を指定します。"
    },
    {
      "indent": 0,
      "text": "2.3. Design Trade-Offs",
      "section_title": true,
      "ja": "2.3。デザインのトレードオフ"
    },
    {
      "indent": 3,
      "text": "While the various features of NORM provide some measure of general purpose utility, it is important to emphasize the understanding that \"no one size fits all\" in the reliable multicast transport arena. There are numerous engineering trade-offs involved in reliable multicast transport design and this necessitates an increased awareness of application and network architecture considerations. Performance requirements affecting design can include: group size, heterogeneity (e.g., capacity and/or delay), asymmetric delivery, data ordering, delivery delay, group dynamics, mobility, congestion control, and transport across low-capacity connections. NORM contains various parameters to accommodate many of these differing requirements. The NORM protocol and its mechanisms MAY be applied in multicast applications outside of bulk data transfer, but there is an assumed model of bulk transfer transport service that drives the trade-offs that determine the scalability and performance described in this document.",
      "ja": "NORMのさまざまな機能が汎用ユーティリティのいくつかの指標を提供しているが、信頼性の高いマルチキャストトランスポートアリーナで「誰のサイズはすべてに適合しない」という理解を強調することが重要です。そこ信頼性の高いマルチキャストトランスポート・デザインに関わる数々のエンジニアリング・トレードオフがあり、これは、アプリケーションとネットワークアーキテクチャの配慮の意識向上が必要となります。デザインに影響を与えるパフォーマンスの要件は含めることができます。低容量の接​​続間グループサイズ、異質性（例えば、容量および/または遅延）、非対称配信、データ発注、配達遅延、グループダイナミックス、モビリティ、輻輳制御、および輸送を。 NORMは、これらの異なる要件の多くに対応するために様々なパラメータが含まれています。 NORMプロトコルとそのメカニズムは、バルクデータ転送の外側マルチキャストアプリケーションに適用することができるが、この文書に記載さスケーラビリティとパフォーマンスを決定するトレードオフを駆動するバルク転送輸送サービスの仮定されたモデルがあります。"
    },
    {
      "indent": 3,
      "text": "The ability of NORM to provide reliable data delivery is also governed by any buffer constraints of the sender and receiver applications. NORM protocol implementations SHOULD operate with the greatest efficiency and robustness possible within application-defined buffer constraints. Buffer requirements for reliability, as always, are a function of the delay-bandwidth product of the network topology. NORM performs best when allowed more buffering resources than typical point-to-point transport protocols. This is because NORM feedback suppression is based upon randomly delayed transmissions from the receiver set, rather than immediately transmitted feedback. There are definitive trade-offs between buffer utilization, group size scalability, and efficiency of performance. Large buffer sizes allow the NORM protocol to perform most efficiently in large delay-bandwidth topologies and allow for longer feedback suppression backoff timeouts. This yields improved group size scalability. NORM can operate with reduced buffering but at a cost of decreased efficiency (lower relative goodput) and reduced group size scalability.",
      "ja": "信頼性の高いデータ配信を提供するために、NORMの能力も、送信側と受信側のアプリケーションのいずれかのバッファの制約によって支配されています。 NORMプロトコル実装が最大効率とアプリケーション定義のバッファの制約内で可能な堅牢で動作しなければなりません。バッファ要件は、信頼性のために、いつものように、ネットワークトポロジの遅延帯域幅積の関数です。典型的なポイントツーポイントのトランスポートプロトコルよりも多くのバッファリング資源を許可するときNORMは、最高の性能が得られます。 NORMフィードバック抑制が受信機セットではなく、すぐに送信されたフィードバックからランダム遅延の伝送に基づいているためです。バッファ利用、グループサイズの拡張性、およびパフォーマンスの効率性との間に決定的なトレードオフがあります。大きなバッファサイズがNORMプロトコルは大きな遅延帯域トポロジで最も効率的に実行し、より長いフィードバック抑制バックオフタイムアウトを可能にすることを可能にします。これは、改善グループサイズのスケーラビリティが得られます。 NORMは減少バッファで動作するが、減少した効率（低い相対グッドプット）と減少グループサイズのスケーラビリティを犠牲にすることができます。"
    },
    {
      "indent": 0,
      "text": "3. Conformance Statement",
      "section_title": true,
      "ja": "3.適合性宣言"
    },
    {
      "indent": 3,
      "text": "This RMT Protocol Instantiation document, in conjunction with the \"Multicast Negative-Acknowledgment (NACK) Building Blocks\" [RFC5401] and \"Forward Error Correction (FEC) Building Block\" [RFC5052] Building Blocks, completely specifies a working reliable multicast transport protocol that conforms to the requirements described in RFC 2357.",
      "ja": "このRMTプロトコルインスタンス文書は、「マルチキャスト否定応答（NACK）ビルディング・ブロック」[RFC5401]と「前方誤り訂正（FEC）ビルディングブロック」[RFC5052]ビルディング・ブロックと組み合わせて、完全に働いて信頼性の高いマルチキャストトランスポートプロトコルを指定することRFC 2357で説明した要件に準拠しています。"
    },
    {
      "indent": 3,
      "text": "This document specifies the following message types and mechanisms that are REQUIRED in complying NORM protocol implementations:",
      "ja": "この文書は、NORMプロトコル実装を準拠に必要とされる次のメッセージタイプおよびメカニズムを指定します。"
    },
    {
      "indent": 3,
      "text": "+----------------------+--------------------------------------------+\n| Message Type         | Purpose                                    |\n+----------------------+--------------------------------------------+\n| NORM_DATA            | Sender message for application data        |\n|                      | transmission.  Implementations MUST        |\n|                      | support at least one of the                |\n|                      | NORM_OBJECT_DATA, NORM_OBJECT_FILE, or     |\n|                      | NORM_OBJECT_STREAM delivery services.  The |\n|                      | use of the NORM FEC Object Transmission    |\n|                      | Information header extension is OPTIONAL   |\n|                      | with NORM_DATA messages.                   |\n| NORM_CMD(FLUSH)      | Sender command to excite receivers for     |\n|                      | repair requests in lieu of ongoing         |\n|                      | NORM_DATA transmissions.  Note the use of  |\n|                      | the NORM_CMD(FLUSH) for positive           |\n|                      | acknowledgment of data receipt is          |\n|                      | OPTIONAL.                                  |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| NORM_CMD(SQUELCH)    | Sender command to advertise its current    |\n|                      | valid repair window in response to invalid |\n|                      | requests for repair.                       |\n| NORM_CMD(REPAIR_ADV) | Sender command to advertise current repair |\n|                      | (and congestion control state) to group    |\n|                      | when unicast feedback messages are         |\n|                      | detected.  Used to control/suppress        |\n|                      | excessive receiver feedback in asymmetric  |\n|                      | multicast topologies.                      |\n| NORM_CMD(CC)         | Sender command used in collection of       |\n|                      | round-trip timing and congestion control   |\n|                      | status from group (this is OPTIONAL if     |\n|                      | alternative congestion control mechanism   |\n|                      | and round-trip timing collection is used). |\n| NORM_NACK            | Receiver message used to request repair of |\n|                      | missing transmitted content.               |\n| NORM_ACK             | Receiver message used to proactively       |\n|                      | provide feedback for congestion control    |\n|                      | purposes.  Also used with the OPTIONAL     |\n|                      | NORM Positive Acknowledgment Process.      |\n+----------------------+--------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This document also describes the following message types and associated mechanisms that are OPTIONAL for complying NORM protocol implementations:",
      "ja": "この文書はまた、NORMプロトコルの実装を遵守するためのオプションで、次のメッセージタイプおよび関連する機構について説明します。"
    },
    {
      "indent": 3,
      "text": "+-----------------------+-------------------------------------------+\n| Message Type          | Purpose                                   |\n+-----------------------+-------------------------------------------+\n| NORM_INFO             | Sender message for providing ancillary    |\n|                       | context information associated with NORM  |\n|                       | transport objects.  The use of the NORM   |\n|                       | FEC Object Transmission Information       |\n|                       | header extension is OPTIONAL with         |\n|                       | NORM_INFO messages.                       |\n| NORM_CMD(EOT)         | Sender command to indicate it has reached |\n|                       | end-of-transmission and will no longer    |\n|                       | respond to repair requests.               |\n| NORM_CMD(ACK_REQ)     | Sender command to support                 |\n|                       | application-defined, positively           |\n|                       | acknowledged commands sent outside of the |\n|                       | context of the bulk data content being    |\n|                       | transmitted.  The NORM Positive           |\n|                       | Acknowledgment Procedure associated with  |\n|                       | this message type is OPTIONAL.            |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| NORM_CMD(APPLICATION) | Sender command containing                 |\n|                       | application-defined commands sent outside |\n|                       | of the context of the bulk data content   |\n|                       | being transmitted.                        |\n| NORM_REPORT           | Optional message type reserved for        |\n|                       | experimental implementations of the NORM  |\n|                       | protocol.                                 |\n+-----------------------+-------------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4. Message Formats",
      "section_title": true,
      "ja": "4.メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "There are two primary classes of NORM messages (see Section 2.1): sender messages and receiver messages. NORM_CMD, NORM_INFO, and NORM_DATA message types are generated by senders of data content, and NORM_NACK and NORM_ACK messages generated by receivers within a NormSession. Sender messages SHALL be governed by congestion control for Internet use. For session management or other purposes, receivers can also employ NORM_CMD message transmissions. The principal rationale for distinguishing sender and receiver messages is that receivers will typically need to allocate resources to support reliable reception from sender(s) and NORM sender messages are subject to congestion control. NORM receivers MAY employ the NORM_CMD message type for application-defined purposes, but it is RECOMMENDED that congestion control and feedback implosion issues be addressed. Additionally, an auxiliary message type of NORM_REPORT is also provided for experimental purposes. This section describes the message formats used by the NORM protocol. These messages and their fields are referenced in the detailed functional description of the NORM protocol given in Section 5. Individual NORM messages are compatible with the Maximum Transmission Unit (MTU) limitations of encapsulating Internet protocols including IPv4, IPv6, and UDP. The current NORM protocol specification assumes UDP encapsulation and leverages the transport features of UDP. The NORM messages are independent of network addresses and can be used in IPv4 and IPv6 networks.",
      "ja": "送信者のメッセージと受信メッセージ：NORMメッセージ（2.1節を参照）の二つの主要なクラスがあります。 NORM_CMD、NORM_INFO、及びNORM_DATAメッセージタイプはNormSession内の受信機によって生成されたデータコンテンツの送信者、およびNORM_NACKとNORM_ACKメッセージによって生成されます。送信者のメッセージは、インターネット利用のための輻輳制御に準拠するものとします。セッション管理または他の目的のために、受信機はまたNORM_CMDメッセージの送信を採用することができます。送信者と受信者のメッセージを区別するための主要な理由は、受信機は、典型的には、送信者（S）とNORM送信者メッセージの確実な受信をサポートするためのリソースを割り当てる必要が輻輳制御の対象となっていることです。 NORM受信機は、アプリケーション定義の目的のためにNORM_CMDメッセージタイプを採用してもよいが、輻輳制御とフィードバック爆縮の問題に対処することが推奨されます。また、NORM_REPORTの補助メッセージタイプは、実験目的のために提供されます。このセクションでは、NORMプロトコルによって使用されるメッセージフォーマットを記載しています。これらのメッセージとそのフィールドは、前記個々のNORMメッセージが最大伝送単位（MTU）のIPv4、IPv6、およびUDPを含むインターネット・プロトコルをカプセル化の制限と互換性のあるセクションで与えられたNORMプロトコルの詳細な機能の説明において参照されます。現在NORMプロトコル仕様は、UDPカプセル化を想定し、UDPのトランスポート機能を活用しています。 NORMメッセージは、ネットワークアドレスの独立しており、IPv4とIPv6のネットワークで使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.1. NORM Common Message Header and Extensions",
      "section_title": true,
      "ja": "4.1。 NORM共通メッセージのヘッダーと拡張機能"
    },
    {
      "indent": 3,
      "text": "There are some common message fields contained in all NORM message types. Additionally, a header extension mechanism is defined to expand the functionality of the NORM protocol without revision to this document. All NORM protocol messages begin with a common header with information fields as follows:",
      "ja": "すべてNORMメッセージタイプに含まれるいくつかの一般的なメッセージのフィールドがあります。また、ヘッダ拡張機構は、この文書に改訂することなく、NORMプロトコルの機能を拡張するために定義されています。次のようにすべてのNORMプロトコルメッセージは、情報フィールドと共通ヘッダーで始まります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|version|  type |    hdr_len    |          sequence             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           source_id                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 1: NORM Common Message Header Format",
      "ja": "図1：NORM一般的なメッセージヘッダのフォーマット"
    },
    {
      "indent": 3,
      "text": "The \"version\" field is a 4-bit value indicating the protocol version number. NORM implementations SHOULD ignore received messages with version numbers different from their own. This number is intended to indicate and distinguish upgrades of the protocol that are non-interoperable. The NORM version number for this specification is 1.",
      "ja": "「バージョン」フィールドは、プロトコルのバージョン番号を示す4ビットの値です。 NORMの実装は、独自の異なるバージョン番号が受信したメッセージを無視します。この番号は、非相互運用プロトコルのアップグレードを示し、区別するために意図されます。この仕様のためNORMのバージョン番号は1です。"
    },
    {
      "indent": 3,
      "text": "The message \"type\" field is a 4-bit value indicating the NORM protocol message type. These types are defined as follows:",
      "ja": "メッセージ「タイプ」フィールドはNORMプロトコルメッセージのタイプを示す4ビットの値です。次のようにこれらのタイプは定義されています。"
    },
    {
      "indent": 18,
      "text": "+------------------+------------------+\n| Message          |       Value      |\n+------------------+------------------+\n| NORM_INFO        |         1        |\n| NORM_DATA        |         2        |\n| NORM_CMD         |         3        |\n| NORM_NACK        |         4        |\n| NORM_ACK         |         5        |\n| NORM_REPORT      |         6        |\n+------------------+------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The 8-bit \"hdr_len\" field indicates the number of 32-bit words that comprise the given message's header portion. This is used to facilitate the addition of header extensions. The presence of header extensions is implied when the \"hdr_len\" value is greater than the base value for the given message \"type\".",
      "ja": "8ビットの「hdr_len」フィールドは、指定されたメッセージのヘッダー部分を含む32ビット・ワードの数を示します。これはヘッダ拡張の追加を容易にするために使用されます。 「hdr_len」値が与えられたメッセージ「タイプ」の基準値よりも大きい場合に、ヘッダ拡張の存在が示唆されます。"
    },
    {
      "indent": 3,
      "text": "The \"sequence\" field is a 16-bit value that is set by the message originator. The \"sequence\" field serves two separate purposes, depending upon the message type:",
      "ja": "「配列」フィールドは、メッセージの発信者によって設定された16ビットの値です。 「配列」フィールドは、メッセージのタイプに応じて、二つの別々の目的を果たします。"
    },
    {
      "indent": 3,
      "text": "1. NORM senders MUST set the \"sequence\" field of sender messages (NORM_INFO, NORM_DATA, and NORM_CMD) so that receivers can monitor the \"sequence\" value to maintain an estimate of packet loss that can be used for congestion control purposes (see Section 5.5.2 for a detailed description of NORM Congestion Control operation). A monotonically increasing sequence number space MUST be maintained to mark NORM sender messages in this way. Note that this \"sequence\" number is explicitly NOT used in",
      "ja": "受信機が輻輳制御の目的で使用することができるパケット損失の推定値を維持するために、「配列」の値を監視することができるように、1 NORMの送信者は、セクションを参照して（送信メッセージ（NORM_INFO、NORM_DATA、及びNORM_CMD）の「配列」フィールドを設定しなければなりませんNORM輻輳制御動作の詳細については5.5.2）。単調に増加するシーケンス番号空間は、このようにNORM送信者のメッセージをマークするために維持しなければなりません。この「シーケンス」番号が明示的に使用されていないことに注意してください"
    },
    {
      "indent": 7,
      "text": "NORM as part of its reliability procedures.  The NORM object and\nFEC payload identifiers are used to detect missing content for\nreliable transfer purposes.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. NORM receivers SHOULD set the \"sequence\" field to support protection from message replay attacks of NORM_NACK or NORM_NACK messages. Note that, depending upon configuration, NORM feedback messages are sent to the session multicast address or the unicast address(es) of the active NORM sender(s). Thus, a separate, monotonically increasing sequence number space MUST be maintained for each destination address to which the NORM receiver is transmitting feedback messages.",
      "ja": "2. NORM受信機はNORM_NACKまたはNORM_NACKメッセージのメッセージリプレイ攻撃からの保護をサポートするために、「順序」フィールドを設定する必要があります。なお、構成に応じて、NORMフィードバックメッセージは、セッションのマルチキャストアドレスまたはアクティブNORM送信者（S）のユニキャストアドレス（複数可）に送信されます。したがって、別個の、単調に増加するシーケンス番号空間はNORM受信機がフィードバック・メッセージを送信された各宛先アドレスのために維持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that these two separate purposes necessitate the maintenance of separate sequence spaces to support the functions described here. And, in the case of NORM receivers, additional sequence spaces are needed when feedback messages are sent to the sender unicast address(es) instead of the session address.",
      "ja": "これら二つの別々の目的は、ここで説明する機能をサポートするために、別のシーケンス空間の整備を必要とすることに注意してください。フィードバックメッセージが送信者のユニキャストアドレス（複数可）の代わりに、セッションのアドレスに送信された場合や、NORM受信機の場合には、追加の配列スペースが必要とされています。"
    },
    {
      "indent": 3,
      "text": "The \"source_id\" field is a 32-bit value that uniquely identifies the node that sent the message within the context of a single NormSession. This value is termed the NORM node identifier (NormNodeId) and unique NormNodeIds MUST be assigned within a single NormSession. In some cases, use of the host IPv4 address or a hash of an address can suffice, but alternative methodologies for assignment and potential collision resolution of node identifiers within a multicast session SHOULD be considered. For example, the techniques for managing the 32-bit \"synchronization source\" (SSRC) identifiers defined in the Real-Time Protocol (RTP) specification [RFC3550] are applicable for use with NORM node identifiers when an ASM traffic model is observed. In most deployments of the NORM protocol to date, the NormNodeId assignments are administratively configured, and this form of NormNodeId assignment is RECOMMENDED for most purposes. NORM sender NormNodeId values MUST be unique within an ASM session so that NORM receiver feedback can be properly demultiplexed by senders, and NORM receiver NormNodeId values MUST also be unique for congestion control operation or when the OPTIONAL positive acknowledgment mechanism is used.",
      "ja": "「SOURCE_ID」フィールドは一意に単一NormSessionのコンテキスト内でメッセージを送信したノードを識別する32ビットの値です。この値は、NORMノード識別子（NormNodeId）と呼ばれるユニークなNormNodeIds単一NormSession内に割り当てなければなりません。いくつかのケースでは、ホストのIPv4アドレスまたはアドレスのハッシュを使用することは十分であり得るが、マルチキャストセッション内で割り当て、ノード識別子の潜在的な衝突解決のための代替方法が考慮されるべきです。 ASMトラフィックモデルが観察される場合、例えば、32ビットの「同期ソース」を管理するための技術リアルタイムプロトコル（RTP）仕様[RFC3550]で定義された（SSRC）識別子は、NORMのノード識別子との使用に適用可能です。現在までNORMプロトコルのほとんどの展開では、NormNodeId割り当ては管理構成され、そしてNormNodeId割り当てのこの形態は、ほとんどの目的のために推奨されます。そのNORM受信フィードバックが正しく送信者で分離することができるように、NORMセンダNormNodeId値はASMセッション内で一意である必要があり、オプションの肯定応答機構を使用した場合NORM受信機は、値はまた、輻輳制御動作のために一意でなければなりませんNormNodeIdまたは。"
    },
    {
      "indent": 3,
      "text": "NORM Header Extensions",
      "ja": "NORMヘッダの拡張"
    },
    {
      "indent": 3,
      "text": "When header extensions are applied, they follow the message type's base header and precede any payload portion. There are two formats for header extensions, both of which begin with an 8-bit \"het\" (header extension type) field. One format is provided for variable-length extensions with \"het\" values in the range from 0 through 127. The other format is for fixed-length (one 32-bit word) extensions with \"het\" values in the range from 128 through 255.",
      "ja": "ヘッダ拡張が適用される場合、それらは、メッセージ・タイプのベースヘッダに従い、任意のペイロード部分に先行します。 8ビットの「HET」（ヘッダ拡張タイプ）フィールドで始まりどちらのヘッダ拡張のための2つの形式があります。一つの形式は、127を介して0からの範囲における「HET」の値を持つ可変長の拡張のために提供される他の形式は、固定長（1つの32ビット・ワード）128から255までの範囲における「HET」値を拡張するためのものです。"
    },
    {
      "indent": 3,
      "text": "For variable-length extensions, the value of the \"hel\" (header extension length) field is the length of the entire header extension, expressed in multiples of 32-bit words. The \"hel\" field MUST be present for variable-length extensions (\"het\" between 0 and 127) and MUST NOT be present for fixed-length extensions (\"het\" between 128 and 255).",
      "ja": "可変長の拡張のために、「HEL」（ヘッダ拡張長さ）フィールドの値は、全体のヘッダ拡張の長さであり、32ビットワードの倍数で表しました。 「HEL」フィールドは、可変長の拡張（0と127との間の「HET」）のために存在しなければならず、固定長の延長部（128と255との間の「HET」）のために存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "The formats of the variable-length and fixed-length header extensions\nare given, respectively, here:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |   het <=127   |      hel      |                               |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |\n  |                    Header Extension Content                   |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 2: NORM Variable-Length Header Extension Format",
      "ja": "図2：NORM可変長ヘッダ拡張フォーマット"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   het >=128   |    reserved   |    Header Extension Content   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 3: NORM Fixed-Length (32-bit) Header Extension Format",
      "ja": "図3：NORM固定長（32ビット）、ヘッダ拡張フォーマット"
    },
    {
      "indent": 3,
      "text": "The \"Header Extension Content\" portion of the header extension is defined for each extension type. Some header extensions are defined within this document for NORM baseline FEC and congestion control operations.",
      "ja": "ヘッダ拡張の「ヘッダ拡張コンテンツ」部分は、各拡張タイプに対して定義されています。いくつかのヘッダ拡張はNORMベースラインFEC及び輻輳制御動作については、この文書内で定義されています。"
    },
    {
      "indent": 0,
      "text": "4.2. Sender Messages",
      "section_title": true,
      "ja": "4.2。メッセージの送信"
    },
    {
      "indent": 3,
      "text": "NORM sender messages include the NORM_DATA type, the NORM_INFO type, and the NORM_CMD type. NORM_DATA and NORM_INFO messages contain application data content while NORM_CMD messages are used for various protocol control functions.",
      "ja": "NORMの送信者のメッセージがNORM_DATAタイプ、NORM_INFOタイプ、およびNORM_CMDタイプが含まれます。 NORM_CMDメッセージは、様々なプロトコルの制御機能のために使用されている間NORM_DATAとNORM_INFOメッセージは、アプリケーション・データ・コンテンツを含みます。"
    },
    {
      "indent": 0,
      "text": "4.2.1. NORM_DATA Message",
      "section_title": true,
      "ja": "4.2.1。 NORM_DATAメッセージ"
    },
    {
      "indent": 3,
      "text": "The NORM_DATA message is generally the predominant type transmitted by NORM senders. These messages are used to encapsulate segmented data content for objects of type NORM_OBJECT_DATA, NORM_OBJECT_FILE, and NORM_OBJECT_STREAM. NORM_DATA messages contain original or FEC-encoded application data content.",
      "ja": "NORM_DATAメッセージは、一般にNORM送信者によって送信された優勢なタイプです。これらのメッセージはタイプNORM_OBJECT_DATA、NORM_OBJECT_FILE、およびNORM_OBJECT_STREAMのオブジェクトのためのセグメント化されたデータの内容をカプセル化するために使用されています。 NORM_DATAメッセージは、オリジナルまたはFEC-エンコードされたアプリケーション・データの内容が含まれています。"
    },
    {
      "indent": 3,
      "text": "The format of NORM_DATA messages is comprised of three logical\nportions: 1) a fixed-format NORM_DATA header portion, 2) a FEC\nPayload ID portion with a format dependent upon the FEC encoding\nused, and 3) a payload portion containing source or encoded\napplication data content.  Note for objects of type\nNORM_OBJECT_STREAM, the payload portion contains additional fields\nused to appropriately recover stream content.  NORM implementations\nMAY also extend the NORM_DATA header to include a FEC Object\nTransmission Information (EXT_FTI) header extension.  This allows\nNORM receivers to automatically allocate resources and properly\nperform FEC decoding without the need for pre-configuration or out-\nof-band information.\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |version| type=2|    hdr_len    |          sequence             |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                           source_id                           |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |          instance_id          |     grtt      |backoff| gsize |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |     flags     |    fec_id     |     object_transport_id       |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                         fec_payload_id                        |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                header_extensions (if applicable)              |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |          payload_len*         |       payload_msg_start*      |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                        payload_offset*                        |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                          payload_data*                        |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 4: NORM_DATA Message Format",
      "ja": "図4：NORM_DATAメッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "*IMPORTANT NOTE: The \"payload_len\", \"payload_msg_start\" and \"payload_offset\" fields are present only for objects of type NORM_OBJECT_STREAM. These fields, as with the entire payload, are subject to any FEC encoding used. Thus, when systematic FEC codes are used, these values can be directly interpreted only for packets containing source symbols while packets containing FEC parity content need decoding before these fields can be interpreted.",
      "ja": "*重要な注意：「payload_len」、「payload_msg_start」と「payload_offset」フィールドは唯一のタイプのNORM_OBJECT_STREAMのオブジェクトのために存在しています。これらのフィールドは、全ペイロードと同様に、使用される任意のFEC符号化の対象となっています。システマティックFEC符号が使用される場合、これらのフィールドを解釈することができる前に、FECパリティコンテンツを含むパケットが復号化を必要としつつ、これらの値は、直接のみソースシンボルを含むパケットのために解釈することができます。"
    },
    {
      "indent": 3,
      "text": "The \"version\", \"type\", \"hdr_len\", \"sequence\", and \"source_id\" fields form the NORM common message header as described in Section 4.1. The value of the NORM_DATA \"type\" field is 2. The NORM_DATA base \"hdr_len\" value is 4 (i.e., four 32-bit words) plus the size of the \"fec_payload_id\" field. The \"fec_payload_id\" field size depends upon the FEC encoding type referenced by the \"fec_id\" field. For example, when small block, systematic codes are used, a \"fec_id\" value of 129 is indicated, and the size of the \"fec_payload_id\" is two 32-bit words. In this case the NORM_DATA base \"hdr_len\" value is 6. The cumulative size of any header extensions applied is added into the \"hdr_len\" field.",
      "ja": "「バージョン」、「タイプ」、「hdr_len」、「配列」、および「SOURCE_ID」フィールドセクション4.1に記載されるようにNORM共通のメッセージヘッダーを形成します。 NORM_DATA「タイプ」フィールドの値がNORM_DATA塩基「hdr_len」値は4（すなわち、4つの32ビットワード）プラス「fec_payload_id」フィールドのサイズである2です。 「fec_payload_id」フィールドサイズ「fec_id」フィールドによって参照されるFEC符号化の種類に依存します。小ブロック、系統的符号が使用される場合、例えば、129の「fec_id」値が示され、そして「fec_payload_id」の大きさは、2つの32ビットワードです。この場合NORM_DATA塩基「hdr_len」値が適用されたヘッダ拡張の前記累積サイズが「hdr_len」フィールドに追加されます。"
    },
    {
      "indent": 3,
      "text": "The \"instance_id\" field contains a value generated by the sender to uniquely identify its current instance of participation in the NormSession. This allows receivers to detect when senders have perhaps left and rejoined a session in progress. When a sender (identified by its \"source_id\") is detected to have a new \"instance_id\", the NORM receivers SHOULD drop their previous state on the sender and begin reception anew, or at least treat this \"instance\" as a new, separate sender.",
      "ja": "「INSTANCE_ID」フィールドは、一意NormSessionの参加の現在のインスタンスを識別するために、送信者によって生成された値を含みます。これは、送信者が、おそらく左と進行中のセッションに復帰したときの受信機が検出することができます。 （その「SOURCE_ID」によって識別される）送信者が新しい「INSTANCE_ID」を有すると検出されると、NORM受信機は、送信者に以前の状態を削除し、新たに受信を開始し、または少なくとも新しい、別個のように、この「インスタンス」を扱うべきです送信者。"
    },
    {
      "indent": 3,
      "text": "The \"grtt\" field contains a non-linear quantized representation of the sender's current estimate of group round-trip time (GRTT_sender) (this is also referred to as R_max in [TfmccPaper]). This value is used to control timing of the NACK repair process and other aspects of protocol operation as described in this document. Normally, the advertised \"grtt\" value will correspond to what the sender has measured based on feedback from the group, but, at low transmission rates, the advertised \"grtt\" SHALL be set to MAX(grttMeasured, NormSegmentSize/senderRate) where the NormSegmentSize is the sender's segment size in bytes and the senderRate is the sender's current transmission rate in bytes per second. The algorithm for encoding and decoding this field is described in the Multicast NACK Building Block [RFC5401] document.",
      "ja": "「GRTT」フィールドは、グループラウンドトリップ時間（GRTT_sender）（[TfmccPaper]にこれもR_MAXとも呼ばれる）の送信者の現在の推定値の非線形量子化された表現を含みます。この値は、この文書に記載されているようにNACK修復プロセスおよびプロトコル動作の他の態様のタイミングを制御するために使用されます。通常、アドバタイズ「GRTT」値が低い伝送レートで、送信者がグループからのフィードバックに基づいて測定されたものに対応しますが、アドバタイズ「GRTT」がMAXに設定される（grttMeasured、NormSegmentSize / senderRate）ここNormSegmentSize送信者のセグメントのサイズはバイト単位であり、senderRate 1秒あたりのバイト数、送信者の現在の伝送速度です。符号化と復号化のアルゴリズムは、このフィールドは、マルチキャストNACKビルディングブロック[RFC5401]の文書に記載されています。"
    },
    {
      "indent": 3,
      "text": "The \"backoff\" field value is used by receivers to determine the maximum backoff timer value used in the timer-based NORM NACK feedback suppression. This 4-bit field supports values from 0-15 that are multiplied by GRTT_sender to determine the maximum backoff timeout. The \"backoff\" field informs the receivers of the sender's backoff factor parameter (K_sender). Recommended values and their uses are described in the NORM receiver NACK procedure description in Section 5.3.",
      "ja": "「バックオフ」フィールドの値は、タイマベースNORMのNACKフィードバック抑制に使用される最大のバックオフ・タイマ値を決定するために受信機によって使用されます。この4ビットのフィールドは、最大バックオフタイムアウトを決定するGRTT_sender乗算される0〜15の値をサポートします。 「バックオフ」フィールドには、送信者のバックオフ係数パラメータ（K_sender）の受信機に知らせます。推奨値およびそれらの使用は、セクション5.3でNORM受信NACK手順の説明に記載されています。"
    },
    {
      "indent": 3,
      "text": "The \"gsize\" field contains a representation of the sender's current estimate of group size (GSIZE_sender). This 4-bit field can roughly represent values from ten to 500 million where the most significant bit value of 0 or 1 represents a mantissa of 1 or 5, respectively, and the three least significant bits incremented by one represent a base-10 exponent (order of magnitude). For example, a field value of \"0x0\" represents 1.0e+01 (10), a value of \"0x8\" represents 5.0e+01 (50), a value of \"0x1\" represents 1.0e+02 (100), and a value of \"0xf\" represents 5.0e+08. For NORM feedback suppression purposes, the group size does not need to be represented with a high degree of precision. The group size MAY even be estimated somewhat conservatively (i.e., overestimated) to maintain low levels of feedback traffic. A default group size estimate of 10,000 (\"gsize\" = 0x3) is RECOMMENDED for general purpose reliable multicast applications using the NORM protocol.",
      "ja": "「GSIZE」フィールドには、グループサイズ（GSIZE_sender）の送信者の現在の推定値の表現が含まれています。この4ビットのフィールドは、概ね、それぞれ、10から0又は1の最上位ビットの値が1または5の仮数を表す5億に値を表すことができ、そしてインクリメント3つの最下位ビット（ベース10指数を表します大きさの順）。例えば、 \"は0x0\" のフィールド値が1.0E + 01（10）を表し、 \"0x8という\" の値が5.0E + 01（50）を表し、 \"0x1の\" の値は、1.0E + 02（100）を表し、そして\"0xFの\" の値が5.0E + 08を表しています。 NORMフィードバック抑制のために、グループの大きさは高精度で表現する必要はありません。グループサイズであっても、フィードバックトラフィックの低レベルを維持する（すなわち、過大評価）幾分控えめに推定することができます。 10,000デフォルトのグループサイズの推定値は、（= 0x3の「GSIZE」）NORMプロトコルを使用して汎用高信頼マルチキャストアプリケーションに推奨されています。"
    },
    {
      "indent": 3,
      "text": "The \"flags\" field contains a number of different binary flags providing information and hints for the receiver to appropriately handle the identified object. Defined flags in this field include:",
      "ja": "「フラグ」フィールドは適切識別されたオブジェクトを処理するための受信機のための情報およびヒントを提供異なるバイナリフラグの数を含んでいます。この分野で定義されたフラグは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "+----------------------+-------+------------------------------------+\n| Flag                 | Value | Purpose                            |\n+----------------------+-------+------------------------------------+\n| NORM_FLAG_REPAIR     |  0x01 | Indicates message is a repair      |\n|                      |       | transmission                       |\n| NORM_FLAG_EXPLICIT   |  0x02 | Indicates a repair segment         |\n|                      |       | intended to meet a specific        |\n|                      |       | receiver erasure, as compared to   |\n|                      |       | parity segments provided by the    |\n|                      |       | sender for general purpose (with   |\n|                      |       | respect to a FEC coding block)     |\n|                      |       | erasure filling.                   |\n| NORM_FLAG_INFO       |  0x04 | Indicates availability of          |\n|                      |       | NORM_INFO for object.              |\n| NORM_FLAG_UNRELIABLE |  0x08 | Indicates that repair              |\n|                      |       | transmissions for the specified    |\n|                      |       | object will be unavailable         |\n|                      |       | (one-shot, best-effort             |\n|                      |       | transmission).                     |\n| NORM_FLAG_FILE       |  0x10 | Indicates object is file-based     |\n|                      |       | data (hint to use disk storage for |\n|                      |       | reception).                        |\n| NORM_FLAG_STREAM     |  0x20 | Indicates object is of type        |\n|                      |       | NORM_OBJECT_STREAM.                |\n+----------------------+-------+------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "NORM_FLAG_REPAIR is set when the associated message is a repair transmission. This information can be used by receivers to help observe a join policy where it is desired that newly joining receivers only begin participating in the NACK process upon receipt of new (non-repair) data content. NORM_FLAG_EXPLICIT is used to mark repair messages sent when the data sender has exhausted its ability to provide \"fresh\" (not previously transmitted) parity segments as repair. This flag could possibly be used by intermediate systems implementing functionality to control sub-casting of repair content to different legs of a reliable multicast topology with disparate repair needs. NORM_FLAG_INFO is set only when OPTIONAL NORM_INFO content is actually available for the associated object. Thus, receivers will NACK for retransmission of NORM_INFO only when it is available for a given object. NORM_FLAG_UNRELIABLE is set when the sender wishes to transmit an object with only \"best effort\" delivery and will not supply repair transmissions for the object. NORM receivers SHOULD NOT execute repair requests for objects marked with the NORM_FLAG_UNRELIABLE flag. There are cases where receivers can inadvertently request repair of such objects when all segments (or info content) for those objects are not received (i.e., a gap in the \"object_transport_id\" sequence is noted). In this case, the sender SHALL invoke the NORM_CMD(SQUELCH) process as described in Section 4.2.3.",
      "ja": "関連メッセージが修復送信である場合NORM_FLAG_REPAIRが設定されています。この情報は、新たに参加する受信機が唯一の新しい（非修理）データ・コンテンツの受信時にNACKプロセスへの参加を開始することを希望する参加方針を観察支援するために受信機で使用することができます。 NORM_FLAG_EXPLICITは、データの送信者が修理として（以前に送信されていない）「新鮮」パリティセグメントを提供する能力を使い果たした時に送信され、修復メッセージをマークするために使用されます。このフラグは、おそらく異なる修復ニーズに信頼性の高いマルチキャストトポロジーの異なる脚に修復コンテンツのサブキャスティングを制御する機能を実装する中間システムで使用することができます。 NORM_FLAG_INFOは、オプションNORM_INFOコンテンツは、関連するオブジェクトのために、実際に利用可能であるときにのみ設定されています。これにより、指定されたオブジェクトのために利用可能であるのみNORM_INFOの再送信のための受信機意志NACK。送信者が唯一「ベストエフォート」の配信を持つオブジェクトを送信したいとオブジェクトのための修理送信を供給しないときNORM_FLAG_UNRELIABLEが設定されています。 NORM受信機はNORM_FLAG_UNRELIABLEフラグでマークされたオブジェクトの修復要求を実行すべきではありません。これらのオブジェクトのすべてのセグメント（又は情報コンテンツ）が受信されない場合に受信機が誤ってこのようなオブジェクトの修復を要求することができる場合がある（すなわち、「object_transport_id」配列におけるギャップが注目されます）。セクション4.2.3に記載したように、この場合に、送信者はNORM_CMD（SQUELCH）プロセスを呼び出すものとします。"
    },
    {
      "indent": 3,
      "text": "NORM_FLAG_FILE can be set as a hint from the sender that the associated object SHOULD be stored in non-volatile storage. NORM_FLAG_STREAM is set when the identified object is of type NORM_OBJECT_STREAM. The presence of NORM_FLAG_STREAM overrides that of NORM_FLAG_FILE with respect to interpretation of object size and the format of NORM_DATA messages.",
      "ja": "NORM_FLAG_FILEは、関連するオブジェクトは、不揮発性記憶装置に格納する必要があり、送信者からのヒントとして設定することができます。特定されたオブジェクトの型がNORM_OBJECT_STREAMであるときNORM_FLAG_STREAMが設定されています。 NORM_FLAG_STREAMの存在は、オブジェクトサイズとNORM_DATAメッセージのフォーマットの解釈に関してNORM_FLAG_FILEのものを上書き。"
    },
    {
      "indent": 3,
      "text": "The \"fec_id\" field corresponds to the FEC Encoding Identifier described in the FEC Building Block document [RFC5052]. The \"fec_id\" value implies the format of the \"fec_payload_id\" field and, coupled with FEC Object Transmission Information, the procedures to decode FEC-encoded content. Small block, systematic codes (\"fec_id\" = 129) are expected to be used for most NORM purposes and systematic FEC codes are RECOMMENDED for the most efficient performance of NORM_OBJECT_STREAM transport.",
      "ja": "「fec_id」フィールドは、FEC符号化識別子に対応するには、FECビルディングブロック文献[RFC5052]に記載しました。 「fec_id」値は「fec_payload_id」フィールドの形式を意味し、および、FECオブジェクト伝送情報と結合され、FECエンコードされたコンテンツを復号するための手順。小ブロック、システマティック符号（「fec_id」= 129）NORM_OBJECT_STREAM輸送の最も効率的なパフォーマンスのために推奨される最もNORM目的とシステマティックFEC符号に使用されることが期待されます。"
    },
    {
      "indent": 3,
      "text": "The \"object_transport_id\" field is a monotonically and incrementally increasing value assigned by the sender to NormObjects being transmitted. Transmissions and repair requests related to that object use the same \"object_transport_id\" value. For sessions of very long or indefinite duration, the \"object_transport_id\" field will wrap and be repeated, but it is presumed that the 16-bit field size provides a sufficient sequence space to avoid object confusion amongst receivers and sources (i.e., receivers SHOULD re-synchronize with a server when receiving object sequence identifiers sufficiently out-of-range with the current state kept for a given source). During the course of its transmission within a NORM session, an object is uniquely identified by the concatenation of the sender \"source_id\" and the given \"object_transport_id\". Note that NORM_INFO messages associated with the identified object carry the same \"object_transport_id\" value.",
      "ja": "「object_transport_id」フィールドは、送信されるNormObjectsに送信者によって割り当てられた、単調と増分増加する値です。そのオブジェクトに関連したトランスミッション、修理依頼は、同じ「object_transport_id」の値を使用します。非常に長いまたは無期限のセッションでは、「object_transport_id」フィールドが折り返され、繰り返されるが、16ビットのフィールドのサイズは受信機とソースの間でのオブジェクトの混乱を避けるために十分な配列スペースを提供していると推定される（すなわち、受信機は、再すべきです十分に範囲外の現在の状態が与えられたソースのために保持して）オブジェクトのシーケンス識別子を受信したときにサーバと-synchronize。 NORMセッション内での伝送の過程で、オブジェクトは、一意の送信者「SOURCE_ID」と指定された「object_transport_id」の連結によって識別されます。識別されたオブジェクトに関連付けられたNORM_INFOメッセージは同じ「object_transport_id」値を運ぶことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The \"fec_payload_id\" identifies the attached NORM_DATA \"payload\"\ncontent.  The size and format of the \"fec_payload_id\" field depends\nupon the FEC type indicated by the \"fec_id\" field.  These formats are\ngiven in the descriptions of specific FEC schemes such as those\ndescribed in the FEC Basic Schemes [RFC5445] specification or in\nother FEC Schemes.  As an example, the format of the \"fec_payload_id\"\nformat for Small Block, Systematic codes (\"fec_id\" = 129) from the\nFEC Basic Schemes [RFC5445] specification is given here:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                       source_block_number                     |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |        source_block_len       |      encoding_symbol_id       |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 5: Example: FEC Payload Id Format for 'fec_id' = 129",
      "ja": "図5：例：= 129 'fec_id' のFECペイロードIDフォーマット"
    },
    {
      "indent": 3,
      "text": "In this example, FEC payload identifier, the \"source_block_number\", \"source_block_len\", and \"encoding_symbol_id\" fields correspond to the \"Source Block Number\", \"Source Block Length\", and \"Encoding Symbol ID\" fields of the FEC Payload ID format for Small Block Systematic FEC Schemes identified by a \"fec_id\" value of 129 as specified by the FEC Basic Schemes [RFC5445] specification. The \"source_block_number\" identifies the coding block's relative position with a NormObject. Note that, for NormObjects of type NORM_OBJECT_STREAM, the \"source_block_number\" will wrap for very long-lived sessions. The \"source_block_len\" indicates the number of user data segments in the identified coding block. Given the \"source_block_len\" information of how many symbols of application data are contained in the block, the receiver can determine whether the attached segment is data or parity content and treat it appropriately. Applications MAY dynamically \"shorten\" code blocks when the pending information content is not predictable (e.g., real-time message streams). In that case, the \"source_block_len\" value given for an \"encoding_symbol_id\" that contains FEC parity content SHALL take precedence over the \"source_block_len\" value provided for any packets containing source symbols. Also, the \"source_block_len\" value given for an ordinally higher \"encoding_symbol_id\" SHALL take precedence over the \"source_block_len\" given for prior encoding symbols. The reason for this is that the sender will only know the maximum source block length at the time it is transmitting source symbols, but then subsequently \"shorten\" the code and then provide that last source symbol and/or encoding symbols with FEC parity content. The \"encoding_symbol_id\" identifies which specific symbol (segment) within the coding block the attached payload conveys. Depending upon the value of the \"encoding_symbol_id\" and the associated \"source_block_len\" parameters for the block, the symbol (segment) referenced will be a user data or a FEC parity segment. For systematic codes, encoding symbols numbered less than the source_block_len contain original application data while segments greater than or equal to source_block_len contain parity symbols calculated for the block. The concatenation of object_transport_id:: fec_payload_id can be viewed as a unique transport protocol data unit identifier for the attached segment with respect to the NORM sender's instance within a session.",
      "ja": "この例では、FECペイロード識別子、「source_block_number」、「source_block_len」、および「encoding_symbol_id」フィールドが「ソースブロック番号」、「ソースブロック長」、及びFECペイロードIDフォーマットの「符号化シンボルID」フィールドに対応FEC基本スキーム[RFC5445]仕様によって指定されるように129の「fec_id」値によって識別される小ブロックシステマティックFECスキームのために。 「source_block_numberは」NormObjectと符号化ブロックの相対位置を特定します。型NORM_OBJECT_STREAM、「source_block_number」のNormObjectsのための非常に長命のセッションのためにラップする、ということに注意してください。 「source_block_len」が同定コーディングブロック内のユーザデータセグメントの数を示します。アプリケーションデータのシンボルがブロックに含まれているどのように多くの「source_block_len」情報が与えられると、受信機が接続されたセグメントは、データまたはパリティコンテンツであるか否かを判断し、適切に処理することができます。保留中の情報量が予測できない場合にアプリケーションが動的に（例えば、リアルタイムのメッセージストリーム）のコードブロックを「短縮」MAY。その場合には、FECパリティコンテンツを含む「encoding_symbol_id」に指定された「source_block_len」値は、ソースシンボルを含む任意のパケットのために提供される「source_block_len」値よりも優先する。また、ordinally高い「encoding_symbol_id」に指定された「source_block_len」値は、事前符号化シンボルのために与えられた「source_block_len」優先を講じなければなりません。この理由は、送信者が唯一それがソースシンボルを送信している時の最大ソースブロック長を知っているが、その後のコードを「短縮」してからFECパリティコンテンツにその最後のソースシンボルおよび/または符号化シンボルを提供することです。添付のペイロードが搬送する符号化ブロック内の特定のシンボル（セグメント）「encoding_symbol_id」識別する。 「encoding_symbol_id」とブロックに関連付けられた「source_block_len」パラメータの値に応じて、参照シンボル（セグメント）は、ユーザデータまたはFECパリティセグメントであろう。システマティックコードの場合、符号化シンボルは、以上のセグメントがブロックのために計算されたパリティシンボルを含むsource_block_lenするながらsource_block_lenは、元のアプリケーションデータを含む未満番号。 object_transport_id :: fec_payload_idの連結は、セッション内NORM送信者のインスタンスに対して接続されたセグメントの一意のトランスポートプロトコルデータユニット識別子とみなすことができます。"
    },
    {
      "indent": 3,
      "text": "Additional FEC Object Transmission Information (FTI) (as described in the FEC Building Block [RFC5052]) document is needed to properly receive and decode NORM transport objects. This information MAY be provided as out-of-band session information. In some cases, it will be useful for the sender to include this information \"in-band\" to facilitate receiver operation with minimal pre-configuration. For this purpose, the NORM FEC Object Transmission Information Header Extension (EXT_FTI) is defined. This header extension MAY be applied to NORM_DATA and NORM_INFO messages to provide this necessary information. The format of the EXT_FTI consists of two parts, a general part that contains the size of the associated transport object and a portion that depends upon the FEC scheme being used. The \"fec_id\" field in NORM_DATA and NORM_INFO messages identifies the FEC scheme. The format of the EXT_FTI general part is given here.",
      "ja": "追加のFECオブジェクト伝送情報（FTI）（FECビルディングブロック[RFC5052]に記載されているように）文書が正しくNORMトランスポートオブジェクトを受信し、復号するために必要とされます。この情報は、アウトオブバンドセッション情報として提供することができます。送信者は、最小の事前構成された受信機の動作を容易にするために「インバンド」は、この情報を含むようにするためのいくつかのケースでは、それは有用であろう。この目的のために、NORM FECオブジェクト伝送情報ヘッダ拡張（EXT_FTI）が定義されています。このヘッダー拡張は、この必要な情報を提供するためにNORM_DATAとNORM_INFOメッセージに適用されてもよいです。 EXT_FTIのフォーマットは二つの部分、関連するトランスポート・オブジェクトと使用されているFECスキームに依存する部分の大きさを含んでいる一般的な部分で構成されています。 NORM_DATAとNORM_INFOのメッセージに「fec_id」フィールドは、FECスキームを識別します。 EXT_FTI一般的な一部の形式は、ここで与えられています。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    het = 64   |    hel = 4    |       object_size (msb)       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       object_size (lsb)                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  FEC scheme-specific content ...              |",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 6: EXT_FTI Header Extension General Portion Format",
      "ja": "図6：EXT_FTIヘッダー拡張一般部フォーマット"
    },
    {
      "indent": 3,
      "text": "The header extension type \"het\" field value for the EXT_FTI header extension is 64. The header extension length \"hel\" value depends upon the format of the FTI for encoding type identified by the \"fec_id\" field.",
      "ja": "EXT_FTIヘッダ拡張のためのヘッダ拡張タイプ「HET」フィールドの値は、ヘッダ拡張長さ「HEL」の値が「fec_id」フィールドによって識別される符号化タイプにFTIのフォーマットに依存64です。"
    },
    {
      "indent": 3,
      "text": "The 48-bit \"object_size\" field indicates the total length of the object (in bytes) for the static object types of NORM_OBJECT_FILE and NORM_OBJECT_DATA. This information is used by receivers to determine storage requirements and/or allocate storage for the received object. Receivers with insufficient storage capability might wish to forego reliable reception (i.e., not NACK for) of the indicated object. In the case of objects of type NORM_OBJECT_STREAM, the \"object_size\" field is used by the sender to advertise the size of its stream buffer to the receiver group. In turn, the receivers SHOULD use this information to allocate a stream buffer for reception of corresponding size.",
      "ja": "48ビットの「オブジェクト_」フィールドはNORM_OBJECT_FILEとNORM_OBJECT_DATAの静的オブジェクトタイプの（バイト単位）オブジェクトの全体の長さを示しています。この情報は、ストレージ要件を決定及び/又は受信されたオブジェクトのための記憶域を割り当てるために受信機によって使用されます。不十分な貯蔵能力を有する受信機は、指示されたオブジェクトの（即ちためではなく、NACK）信頼性の高い受信を放棄することを望むかもしれません。型NORM_OBJECT_STREAMのオブジェクトの場合には、「オブジェクト_」フィールドは、受信グループにそのストリームバッファのサイズを通知する送信者によって使用されます。次に、受信機は、対応するサイズの受信用ストリームバッファを割り当てるためにこの情報を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "As noted, the format of the extension depends upon the FEC code in\nuse, but in general, it contains any necessary details on the code in\nuse (e.g., FEC Instance ID, etc.).  As an example, the format of the\nEXT_FTI for small block systematic codes (\"fec_id\" = 129) is given\nhere:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |    het = 64   |    hel = 4    |       object_size (msb)       |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                       object_size (lsb)                       |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |       fec_instance_id         |          segment_size         |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |       fec_max_block_len       |         fec_num_parity        |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 7: Example: EXT_FTI Header Extension Format for 'fec_id' = 129",
      "ja": "図7：例： 'fec_id' = 129のためEXT_FTIヘッダ拡張フォーマット"
    },
    {
      "indent": 3,
      "text": "In this example (for \"fec_id\" = 129), the \"hel\" field value is 4. The size of the EXT_FTI header extension will possibly be different for other FEC schemes.",
      "ja": "この例では（= 129「fec_id」の場合）、「HEL」フィールドの値がEXT_FTIヘッダ拡張のサイズは、おそらく他のFECスキームの異なるであろう4です。"
    },
    {
      "indent": 3,
      "text": "The 48-bit \"object_size\" serves the purpose described previously.",
      "ja": "48ビットの「オブジェクト_」は、前述の目的を果たします。"
    },
    {
      "indent": 3,
      "text": "The \"fec_instance_id\" corresponds to the \"FEC Instance ID\" described in the FEC Building Block [RFC5052] document. In this case, the \"fec_instance_id\" is a value corresponding to the particular type of Small Block Systematic Code being used (e.g., Reed-Solomon GF(2^8), Reed-Solomon GF(2^16), etc). The standardized assignment of FEC Instance ID values is described in RFC 5052.",
      "ja": "「fec_instance_id」はFECビルディングブロック[RFC5052]の文書に記載された「FECインスタンスID」に対応します。この場合、「fec_instance_id」は（例えば、リード・ソロモンGF（2 ^ 8）、リード・ソロモンGF（2 ^ 16）、等）を使用して小ブロック組織符号の特定のタイプに対応する値です。 FECインスタンスID値の標準化された割り当ては、RFC 5052に記載されています。"
    },
    {
      "indent": 3,
      "text": "The \"segment_size\" field indicates the sender's current setting for maximum message payload content (in bytes). This allows receivers to allocate appropriate buffering resources and to determine other information in order to properly process received data messaging. Typically, FEC parity symbol segments will be of this size.",
      "ja": "「のsegment_size」フィールドは、バイト単位での最大メッセージ・ペイロードコンテンツの送信者の現在の設定を示しています。これは、受信機が適切なバッファリング資源を割り当てるために、適切に受信されたデータ・メッセージを処理するために他の情報を決定することを可能にします。典型的には、FECパリティシンボルセグメントは、このサイズのものであろう。"
    },
    {
      "indent": 3,
      "text": "The \"fec_max_block_len\" indicates the current maximum number of user data segments per FEC coding block to be used by the sender during the session. This allows receivers to allocate appropriate buffer space for buffering blocks transmitted by the sender.",
      "ja": "「fec_max_block_len」はFEC符号化ブロックごとのユーザデータセグメントの現在の最大数は、セッション中に送信者によって使用されることを示しています。これは、受信機が、送信者が送信したブロックをバッファリングするための適切なバッファ領域を割り当てることができます。"
    },
    {
      "indent": 3,
      "text": "The \"fec_num_parity\" corresponds to the \"maximum number of encoding symbols that can be generated for any source block\" as described in FEC Object Transmission Information for Small Block Systematic Codes as described in the FEC Building Block [RFC5052] document. For example, Reed-Solomon codes can be arbitrarily shortened to create different code variations for a given block length. In the case of Reed-Solomon (GF(2^8) and GF(2^16)) codes, this value indicates the maximum number of parity segments available from the sender for the coding blocks. This field MAY be interpreted differently for other systematic codes as they are defined.",
      "ja": "FECビルディングブロック[RFC5052]の文書に記載されているように小ブロック系統的コードについてFECオブジェクト伝送情報に記載されているように「fec_num_parity」は、「任意のソースブロックに対して生成することができる符号化シンボルの最大数」に相当します。例えば、リードソロモン符号は、任意所与のブロック長に対して異なるコードのバリエーションを作成するために短くすることができます。リード・ソロモン（GF（2 ^ 8）及びGF（2 ^ 16））符号の場合には、この値は、符号化ブロックの送信者からのパリティ・セグメントの最大数は、利用可能示します。それらが定義されている通り、このフィールドは、他の組織符号のために異なって解釈されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The payload portion of NORM_DATA messages includes source data or FEC-encoded application content. The content of this payload depends upon the FEC scheme being employed, and support for streaming using the NORM_OBJECT_STREAM type, when applicable, necessitates some additional content in the payload.",
      "ja": "NORM_DATAメッセージのペイロード部分は、ソースデータまたはFEC符号化されたアプリケーションの内容を含みます。適用可能な場合、このペイロードの内容は、採用されるFECスキームに依存し、NORM_OBJECT_STREAMタイプを使用して、ストリーミングのサポート、ペイロード内のいくつかの追加のコンテンツを必要とします。"
    },
    {
      "indent": 3,
      "text": "The \"payload_len\", \"payload_msg_start\", and \"payload_offset\" fields are present only for transport objects of type NORM_OBJECT_STREAM. These REQUIRED fields allow senders to arbitrarily vary the size of NORM_DATA payload segments for streams. This allows applications to flush transmitted streams as needed to meet unique streaming requirements. For objects of types NORM_OBJECT_FILE and NORM_OBJECT_DATA, these fields are unnecessary since the receiver can calculate the payload length and offset information from the \"fec_payload_id\" using the REQUIRED block partitioning algorithm described in the FEC Building Block [RFC5052] document. When systematic FEC codes (e.g., \"fec_id\" = 129) are used, the \"payload_len\", \"payload_msg_start\", and \"payload_offset\" fields contain actual payload_data length, message start index (or stream control code), and byte offset values for the associated application stream data segment (the remainder of the \"payload_data\" field content) for those NORM_DATA messages containing source data symbols. In NORM_DATA messages that contain FEC parity content, these fields do not contain values that can be directly interpreted, but instead are values computed from FEC encoding the \"payload_len\", \"payload_msg_start\", and \"payload_offset\" fields for the source data segments of the corresponding coding block. The actual \"payload_msg_start\", \"payload_len\" and, \"payload_offset\" values of missing data content can be determined upon decoding a FEC coding block. Note that these fields do NOT contribute to the value of the NORM_DATA \"hdr_len\" field. These fields are present only when the \"flags\" portion of the NORM_DATA message indicate the transport object is of type NORM_OBJECT_STREAM.",
      "ja": "「payload_len」、「payload_msg_start」、および「payload_offset」フィールドは唯一のタイプのNORM_OBJECT_STREAMのトランスポート・オブジェクトのために存在しています。これらの必須フィールドは、送信者が任意のストリームに対してNORM_DATAペイロードセグメントのサイズを変更することを可能にします。これは、独自のストリーミング要件を満たすために、必要に応じて、アプリケーションが送信されたストリームをフラッシュすることができます。受信機は、ペイロードの長さを計算し、FECビルディングブロック[RFC5052]の文書に記載さREQUIREDブロック分割アルゴリズムを使用して「fec_payload_id」からの情報をオフセットすることができるので種類NORM_OBJECT_FILEとNORM_OBJECT_DATAの目的のために、これらのフィールドは不要です。場合システマティックFEC符号（例えば、「fec_id」= 129）、「payload_len」、「payload_msg_start」、および「payload_offset」フィールドは、実際のpayload_data長を含む使用され、メッセージの開始インデックス（又はストリーム制御コード）、およびバイトオフセット値ソースデータシンボルを含むものNORM_DATAメッセージに関連付けられたアプリケーションストリームデータセグメント（「payload_data」フィールドの内容の残り）。 FECパリティコンテンツを含むNORM_DATAメッセージに、これらのフィールドを直接解釈することができる値を含んでいないが、代わりのソース・データ・セグメントの「payload_len」、「payload_msg_start」をコードするFECから計算された値、および「payload_offset」フィールドはブロック符号化に対応します。実際の「payload_msg_start」、「payload_len」と欠落データコンテンツの、「payload_offset」値は、FEC符号化ブロックを復号する際に決定することができます。これらのフィールドはNORM_DATA「hdr_len」フィールドの値には寄与しないことに注意してください。 NORM_DATAメッセージの「フラグ」部分は、トランスポート・オブジェクトは、タイプNORM_OBJECT_STREAMであることを示す場合にのみ、これらのフィールドが存在します。"
    },
    {
      "indent": 3,
      "text": "The \"payload_len\" value, when non-zero, indicates the length (in bytes) of the source content contained in the associated \"payload_data\" field. However, when the \"payload_len\" value is equal to ZERO, this indicates that the \"payload_msg_start\" field be alternatively interpreted as a \"stream_control_code\". The only \"stream_control_code\" value defined is NORM_STREAM_END = 0. The NORM_STREAM_END code indicates that the sender is terminating the transmission of stream content at the corresponding position in the stream and the receiver MUST NOT expect content (or request repair for any content) following that position in the stream. Additional specifications MAY extend the functionality of the NORM stream transport mode by defining additional stream control codes. These control codes are delivered to the recipient application reliably, in-order with respect to the streamed application data content.",
      "ja": "非ゼロは、関連する「payload_data」フィールドに含まれるソースコンテンツの長さ（バイト）を示す「payload_len」値、。 「payload_len」の値がゼロに等しい場合しかし、これは「payload_msg_start」フィールドは、代わりに「stream_control_code」として解釈されることを示しています。定義された唯一の「stream_control_code」値はNORM_STREAM_ENDコードは、送信者がストリームに対応する位置に、ストリームコンテンツの送信を終了し、受信機は、（任意のコンテンツまたは要求修復）コンテンツを期待していなければならないの次のことを示しているNORM_STREAM_END = 0です。ストリーム内の位置。追加の仕様は、追加のストリームの制御コードを定義することにより、NORMストリームトランスポートモードの機能を拡張することができます。これらの制御コードは、インオーダーストリーミングアプリケーションデータコンテンツに対して、確実に受信側アプリケーションに配信されます。"
    },
    {
      "indent": 3,
      "text": "The \"payload_msg_start\" field serves one of two exclusive purposes. When the \"payload_len\" value is non-zero, the \"payload_msg_start\" field, when also set to a non-zero value, indicates that the associated \"payload_data\" content contains an application-defined message boundary (start-of-message). When such a message boundary is indicated, the first byte of an application-defined message, with respect to the \"payload_data\" field, will be found at an offset of \"payload_msg_start - 1\" bytes. Thus, if a NORM_DATA payload for a NORM_OBJECT_STREAM contains the start of an application message at the first byte of the \"payload_data\" field, the value of the \"payload_msg_start\" field will be '1'. NORM implementations SHOULD provide sender stream applications with a capability to mark message boundaries in this manner. Similarly, the NORM receiver implementation SHOULD enable the application to recover such message boundary information. This enables NORM receivers to \"synchronize\" reliable reception of transmitted message stream content in a meaningful way (i.e., meaningful to the application) at any time, whether joining a session already in progress, or departing the session and returning. Note that if the value of the \"payload_msg_start\" field is ZERO, no message boundary is present. The \"payload_msg_start\" value will always be less than or equal to the \"payload_len\" value except for the special case of \"payload_len = 0\", which indicates the \"payload_msg_start\" field be instead interpreted as a \"stream_control_code\"",
      "ja": "「payload_msg_start」フィールドには、2つの排他的な目的の一つを提供しています。 「payload_len」値が非ゼロである場合、非ゼロ値に設定された「payload_msg_start」フィールドは、関連する「payload_data」コンテンツは、アプリケーション定義のメッセージ境界（開始のメッセージ）を含むことを示しています。バイト - 、メッセージ境界が示される場合、「payload_data」フィールドに対してアプリケーション定義メッセージの最初のバイトは、「1 payload_msg_start」のオフセットで見出されるであろう。 NORM_OBJECT_STREAMためNORM_DATAペイロードが「payload_data」フィールドの最初のバイトのアプリケーション・メッセージの開始を含む場合したがって、「payload_msg_start」フィールドの値が「1」であろう。 NORMの実装は、このようにメッセージの境界をマークする機能を備えた送信側のストリーム・アプリケーションを提供する必要があります。同様に、NORM受信機の実装は、メッセージ境界情報を回復するためにアプリケーションを有効にする必要があります。これは、すでに進行中のセッションに参加、またはセッションを離れると戻すかどうか、任意の時点で（アプリケーションにすなわち、意味の）意味のある方法で送信されたメッセージ・ストリーム・コンテンツの信頼性の高い受信を「同期」するNORM受信を可能にします。 「payload_msg_start」フィールドの値がゼロである場合、メッセージの境界が存在しないことに留意されたいです。 「payload_msg_start」値が常に代わりに「stream_control_code」として解釈される「payload_msg_start」フィールドを示す「payload_len = 0」の特別な場合を除いて「payload_len」値以下となり"
    },
    {
      "indent": 3,
      "text": "The \"payload_offset\" field indicates the relative byte position (from the sender stream transmission start) of the source content contained in the \"payload_data\" field. Note that for long-lived streams, the \"payload_offset\" field will wrap.",
      "ja": "「payload_offset」フィールドは「payload_data」フィールドに含まれるソースコンテンツの（送信ストリームの送信開始からの）相対バイト位置を示します。長寿命のストリームのために、「payload_offset」フィールドがラップすることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The \"payload_data\" field contains the original application source or parity content for the symbol identified by the \"fec_payload_id\". The length of this field SHALL be limited to a maximum of the sender's NormSegmentSize bytes as given in the FTI for the object. Note the length of this field for messages containing parity content will always be of length NormSegmentSize. When encoding data segments of varying sizes, the FEC encoder SHALL assume ZERO value padding for data segments with a length less than the NormSegmentSize. It is RECOMMENDED that a sender's NormSegmentSize generally be constant for the duration of a given sender's term of participation in the session, but can possibly vary on a per-object basis. The NormSegmentSize SHOULD be configurable by the sender application prior to session participation as needed for network topology MTU considerations. For IPv6, MTU discovery MAY be possibly leveraged at session startup to perform this configuration. The \"payload_data\" content MAY be delivered directly to the application for source symbols (when systematic FEC encoding is used) or upon decoding of the FEC block. For NORM_OBJECT_FILE and NORM_OBJECT_STREAM objects, the data segment length and offset can be calculated using the block partitioning algorithm described in the FEC Building Block [RFC5052] document. For NORM_OBJECT_STREAM objects, the length and offset is obtained from the segment's corresponding embedded \"payload_len\" and \"payload_offset\" fields.",
      "ja": "「payload_data」フィールドには、元のアプリケーションのソースまたは「fec_payload_id」で識別されるシンボルのパリティコンテンツが含まれています。オブジェクトのFTIに示すように、このフィールドの長さは、送信者のNormSegmentSizeバイトの最大値に制限されるもの。パリティコンテンツを含むメッセージのため、このフィールドの長さは常に長NormSegmentSizeであることに注意してください。様々なサイズのデータ​​セグメントを符号化する際に、FECエンコーダはNormSegmentSize未満の長さのデータセグメントのゼロ値のパディングを負います。送信者のNormSegmentSizeは、一般セッションへの参加の特定の送信者の任期の間は一定であることが推奨されていますが、おそらくオブジェクトごとに異なります。ネットワークトポロジのMTUを考慮して、必要に応じてNormSegmentSizeは、セッション参加に先立って送信側アプリケーションによって設定可能であるべきです。 IPv6の場合、MTUの発見は、おそらくこの構成を実行するために、セッションの起動時に活用されるかもしれません。 「payload_data」コンテンツは（FEC符号化が使用される系統的）ソースシンボルのためのアプリケーションまたはFECブロックの復号時に直接送達されてもよいです。 NORM_OBJECT_FILEとNORM_OBJECT_STREAMオブジェクトに対して、データセグメント長とオフセットはFECビルディングブロック[RFC5052]の文書に記載されたブロック分割アルゴリズムを用いて計算することができます。 NORM_OBJECT_STREAMオブジェクトの場合、長さ及びオフセットは、セグメントの対応する埋め込み「payload_len」および「payload_offset」フィールドから取得されます。"
    },
    {
      "indent": 0,
      "text": "4.2.2. NORM_INFO Message",
      "section_title": true,
      "ja": "4.2.2。 NORM_INFOメッセージ"
    },
    {
      "indent": 3,
      "text": "The NORM_INFO message is used to convey OPTIONAL, application-defined, out-of-band context information for transmitted NormObjects. An example NORM_INFO use for bulk file transfer is to place MIME type information for the associated file, data, or stream object into the NORM_INFO payload. Receivers could then use the NORM_INFO content to make a decision as to whether to participate in reliable reception of the associated object. Each NormObject can have an independent unit of NORM_INFO with which it is associated. NORM_DATA messages contain a flag to indicate the availability of NORM_INFO for a given NormObject. NORM receivers will NACK for retransmission of NORM_INFO when they have not received it for a given NormObject. The size of the NORM_INFO content is limited to that of a single NormSegmentSize for the given sender. This atomic nature allows the NORM_INFO to be rapidly and efficiently repaired within the NORM reliable transmission process.",
      "ja": "NORM_INFOメッセージが送信さNormObjectsためOPTIONAL、アプリケーション定義、アウトオブバンドのコンテキスト情報を伝えるために使用されます。 NORM_INFOバルクファイル転送に使用する例はNORM_INFOペイロードに関連付けられたファイル、データ、またはストリームオブジェクトのMIMEタイプ情報を配置することです。レシーバは、関連するオブジェクトの信頼できる受信に参加するか否かの決定を行うためにNORM_INFOのコンテンツを使用することができます。各NormObjectは、それが関連付けられているNORM_INFOの独立した単位を有することができます。 NORM_DATAメッセージが与えられたNormObjectためNORM_INFOの利用可能性を示すフラグが含まれています。 NORM受信機はNACK NORM_INFOの再送信のために、彼らは与えられたNormObjectのためにそれを受け取っていないだろうとき。 NORM_INFOコンテンツの大きさは、所与の送信者の単一NormSegmentSizeのものに限定されるものです。この原子の性質はNORM_INFOが迅速かつ効率的NORM信頼性の高い伝送プロセス内で修復することを可能にします。"
    },
    {
      "indent": 3,
      "text": "When NORM_INFO content is available for a NormObject, the NORM_FLAG_INFO flag SHALL be set in NORM_DATA messages for the corresponding \"object_transport_id\" and the NORM_INFO message SHALL be transmitted as the first message for the NormObject.",
      "ja": "NORM_INFOコンテンツがNormObjectのために利用可能である場合、NORM_FLAG_INFOフラグは、対応する「object_transport_id」のNORM_DATAメッセージに設定されなければならないとNORM_INFOメッセージがNormObjectための最初のメッセージとして送信されなければなりません。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|version| type=1|    hdr_len    |          sequence             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           source_id                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          instance_id          |     grtt      |backoff| gsize |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     flags     |     fec_id    |     object_transport_id       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                header_extensions (if applicable)              |\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         payload_data                          |\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 8: NORM_INFO Message Format",
      "ja": "図8：NORM_INFOメッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "The \"version\", \"type\", \"hdr_len\", \"sequence\", and \"source_id\" fields form the NORM common message header as described in Section 4.1. The value of the \"hdr_len\" field when no header extensions are present is 4.",
      "ja": "「バージョン」、「タイプ」、「hdr_len」、「配列」、および「SOURCE_ID」フィールドセクション4.1に記載されるようにNORM共通のメッセージヘッダーを形成します。全くヘッダ拡張が存在しない「hdr_len」フィールドの値は4です。"
    },
    {
      "indent": 3,
      "text": "The \"instance_id\", \"grtt\", \"backoff\", \"gsize\", \"flags\", \"fec_id\", and \"object_transport_id\" fields carry the same information and serve the same purpose as NORM_DATA messages. These values allow the receiver to prepare appropriate buffering, etc., for further transmissions from the sender when NORM_INFO is the first message received.",
      "ja": "「INSTANCE_ID」、「GRTT」、「バックオフ」、「GSIZE」、「フラグ」、「fec_id」、および「object_transport_id」フィールドには、同じ情報を運ぶとNORM_DATAメッセージと同じ目的を果たします。これらの値は、NORM_INFOが最初のメッセージが受信された送信者からのさらなる送信のために、受信機は適切なバッファリング、等を製造することを可能にします。"
    },
    {
      "indent": 3,
      "text": "As with NORM_DATA messages, the NORM FTI Header Extension (EXT_FTI) MAY be optionally applied to NORM_INFO messages. To conserve protocol overhead, NORM implementations MAY apply the EXT_FTI when used to NORM_INFO messages only and not to NORM_DATA messages.",
      "ja": "NORM_DATAメッセージと同様に、NORM FTIヘッダ拡張（EXT_FTI）は、必要に応じてメッセージをNORM_INFOに適用することができます。だけではなくNORM_DATAメッセージにNORM_INFOメッセージに使用される場合、プロトコルオーバーヘッドを節約するために、NORM実装はEXT_FTIを適用することができます。"
    },
    {
      "indent": 3,
      "text": "The NORM_INFO \"payload_data\" field contains sender application-defined content that can be used by receiver applications for various purposes as described above.",
      "ja": "NORM_INFO「payload_data」フィールドは、上述のように様々な目的のために受信機アプリケーションで使用することができる送信側アプリケーション定義のコンテンツを含みます。"
    },
    {
      "indent": 0,
      "text": "4.2.3. NORM_CMD Messages",
      "section_title": true,
      "ja": "4.2.3。 NORM_CMDメッセージ"
    },
    {
      "indent": 3,
      "text": "NORM_CMD messages are transmitted by senders to perform a number of\ndifferent protocol functions.  This includes functions such as round-\ntrip timing collection, congestion control functions, synchronization\nof sender/receiver repair \"windows\", and notification of sender\nstatus.  A core set of NORM_CMD messages is enumerated.\nAdditionally, a range of command types remain available for potential application-specific use.  Some NORM_CMD types can have dynamic\ncontent attached.  Any attached content will be limited to the\nmaximum length of the sender NormSegmentSize to retain the atomic\nnature of the commands.  All NORM_CMD messages begin with a common\nset of fields, after the usual NORM message common header.  The\nstandard NORM_CMD fields are:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |version| type=3|    hdr_len    |          sequence             |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                           source_id                           |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |          instance_id          |     grtt      |backoff| gsize |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |    sub-type   |                                               |\n  +-+-+-+-+-+-+-+-+        NORM_CMD Content                       +\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 9: NORM_CMD Standard Fields",
      "ja": "図9：NORM_CMD標準フィールド"
    },
    {
      "indent": 3,
      "text": "The \"version\", \"type\", \"hdr_len\", \"sequence\", and \"source_id\" fields form the NORM common message header as described in Section 4.1. The value of the \"hdr_len\" field for NORM_CMD messages without header extensions present depends upon the \"sub-type\" field.",
      "ja": "「バージョン」、「タイプ」、「hdr_len」、「配列」、および「SOURCE_ID」フィールドセクション4.1に記載されるようにNORM共通のメッセージヘッダーを形成します。本ヘッダ拡張せずNORM_CMDメッセージの「hdr_len」フィールドの値は、「サブタイプ」フィールドに依存します。"
    },
    {
      "indent": 3,
      "text": "The \"instance_id\", \"grtt\", \"backoff\", and \"gsize\" fields provide the same information and serve the same purpose as NORM_DATA and NORM_INFO messages. The \"sub-type\" field indicates the type of command to follow. The remainder of the NORM_CMD message is dependent upon the command sub-type. NORM command sub-types include:",
      "ja": "「INSTANCE_ID」、「GRTT」、「バックオフ」、および「GSIZE」フィールドには、同じ情報を提供し、NORM_DATAとNORM_INFOメッセージと同じ目的を果たします。 「サブタイプ」フィールドには、フォローするコマンドの種類を示します。 NORM_CMDメッセージの残りの部分は、コマンドサブタイプに依存します。 NORMコマンドサブタイプは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "+-----------------------+----------+--------------------------------+\n| Command               | Sub-type | Purpose                        |\n+-----------------------+----------+--------------------------------+\n| NORM_CMD(FLUSH)       |     1    | Used to indicate sender        |\n|                       |          | temporary end-of-transmission. |\n|                       |          | (Assists in robustly           |\n|                       |          | initiating outstanding repair  |\n|                       |          | requests from receivers).  May |\n|                       |          | also be optionally used to     |\n|                       |          | collect positive               |\n|                       |          | acknowledgment of reliable     |\n|                       |          | reception from a subset of     |\n|                       |          | receivers.                     |\n| NORM_CMD(EOT)         |     2    | Used to indicate sender        |\n|                       |          | permanent end-of-transmission. |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| NORM_CMD(SQUELCH)     |     3    | Used to advertise sender's     |\n|                       |          | current repair window in       |\n|                       |          | response to out-of-range NACKs |\n|                       |          | from receivers.                |\n| NORM_CMD(CC)          |     4    | Used for GRTT measurement and  |\n|                       |          | collection of congestion       |\n|                       |          | control feedback.              |\n| NORM_CMD(REPAIR_ADV)  |     5    | Used to advertise sender's     |\n|                       |          | aggregated repair/feedback     |\n|                       |          | state for suppression of       |\n|                       |          | unicast feedback from          |\n|                       |          | receivers.                     |\n| NORM_CMD(ACK_REQ)     |     6    | Used to request                |\n|                       |          | application-defined positive   |\n|                       |          | acknowledgment from a list of  |\n|                       |          | receivers (OPTIONAL).          |\n| NORM_CMD(APPLICATION) |     7    | Used for application-defined   |\n|                       |          | purposes that need to          |\n|                       |          | temporarily preempt or         |\n|                       |          | supplement data transmission   |\n|                       |          | (OPTIONAL).                    |\n+-----------------------+----------+--------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.2.3.1. NORM_CMD(FLUSH) Message",
      "section_title": true,
      "ja": "4.2.3.1。 NORM_CMD（FLUSH）メッセージ"
    },
    {
      "indent": 3,
      "text": "The NORM_CMD(FLUSH) command is sent when the sender reaches the end of all data content and pending repairs it has queued for transmission. This can indicate either a temporary or permanent end-of-data transmission, but that the sender is still willing to respond to repair requests. This command is repeated once per 2*GRTT_sender to excite the receiver set for any outstanding repair requests up to and including the transmission point indicated within the NORM_CMD(FLUSH) message. The number of repeats is equal to NORM_ROBUST_FACTOR unless a list of receivers from which explicit positive acknowledgment is expected (\"acking_node_list\") is given. In that case, the \"acking_node_list\" is updated as acknowledgments are received and the NORM_CMD(FLUSH) is repeated according to the mechanism described in Section 5.5.3. The greater the NORM_ROBUST_FACTOR, the greater the probability that all applicable receivers will be excited for acknowledgment or repair requests (NACKs) AND that the corresponding NACKs are delivered to the sender. A default value of NORM_ROBUST_FACTOR equal to 20 is RECOMMENDED. If a NORM_NACK message interrupts the flush process, the sender SHALL re-initiate the flush process after any resulting repair transmissions are completed.",
      "ja": "送信者は、すべてのデータ内容とそれが送信のためにキューに入れられたペンディング修理の終わりに到達したときNORM_CMD（FLUSH）コマンドが送信されます。これは、どちらかの一時的または永続的なエンド・オブ・データ伝送を示すことができますが、送信者は、まだ修理要求に応答して喜んでであること。このコマンドは、およびNORM_CMD（FLUSH）メッセージ内に示された送信点を含むまで未処理の修復要求を設定受信機を励起する2 * GRTT_sender毎に一度繰り返されます。明示的な肯定応答が（「acking_node_list」）が期待された受信機のリストが与えられない限り、反復の数はNORM_ROBUST_FACTORに等しいです。セクション5.5.3で説明されたメカニズムに従って確認応答が受信され、NORM_CMD（FLUSH）が繰り返されるように、その場合には、「acking_node_list」が更新されます。適用されるすべての受信機が承認または修理要求（NACKの）ために励起される確率も大きく、NORM_ROBUST_FACTOR大きいとそれに対応するのNACKは、送信者に配信されていること。 20に等しいNORM_ROBUST_FACTORのデフォルト値が推奨されます。 NORM_NACKメッセージがフラッシュ処理を中断した場合、結果として生じるいかなる修理送信が完了した後、送信者は、フラッシュ処理を再度開始しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that receivers also employ a timeout mechanism to self-initiate NACKing (if there are outstanding repair needs) when no messages of any type are received from a sender. This inactivity timeout is related to the NORM_CMD(FLUSH) and NORM_ROBUST_FACTOR and is specified in Section 5.3. Receivers SHALL self-initiate the NACK repair process when the inactivity timeout has expired for a specific sender and the receiver has pending repairs needed from that sender. With a sufficiently large NORM_ROBUST_FACTOR value, data content is delivered with a high assurance of reliability. The penalty of a large NORM_ROBUST_FACTOR value is the potential transmission of excess NORM_CMD(FLUSH) messages and a longer inactivity timeout for receivers to self-initiate a terminal NACK process.",
      "ja": "任意のタイプのないメッセージが送信者から受信されない場合に受信機が自己開始NACKing（未処理の修復の必要がある場合）に、タイムアウト機構を使用することに留意されたいです。この無活動タイムアウトはNORM_CMD（FLUSH）とNORM_ROBUST_FACTORに関連し、5.3節で指定されています。レシーバは、無活動タイムアウトは、特定の送信者のための期限が切れていると受信機は、その送信者から必要な修理を保留しているNACK修復プロセスを自動開始しなければなりません。十分に大きなNORM_ROBUST_FACTOR値と、データコンテンツは信頼性の高い保証を用いて送達されます。大NORM_ROBUST_FACTOR値のペナルティは、自己開始端末NACKプロセスに過剰NORM_CMD（FLUSH）メッセージおよび受信機のためのより長い非活動タイムアウトの可能性送信です。"
    },
    {
      "indent": 3,
      "text": "For finite-sized transport objects such as NORM_OBJECT_DATA and NORM_OBJECT_FILE, the flush process (if there are no further pending objects) occurs at the end of these objects. Thus, FEC repair information is always available for repairs in response to repair requests elicited by the flush command. However, for NORM_OBJECT_STREAM, the flush can occur at any time, including in the middle of a FEC coding block if systematic FEC codes are employed. In this case, the sender will not yet be able to provide FEC parity content for the concurrent coding block and will be limited to explicitly repairing the stream with source data content for that block. Applications that anticipate frequent flushing of stream content SHOULD be judicious in the selection of the FEC coding block size (i.e., do not use a very large coding block size if frequent flushing occurs). For example, a reliable multicast application transmitting an ongoing series of intermittent, relatively small messages will need to trade-off using the NORM_OBJECT_DATA paradigm versus the NORM_OBJECT_STREAM paradigm with an appropriate FEC coding block size. This is analogous to application trade-offs for other transport protocols such as the selection of different TCP modes of operation such as \"no delay\", etc.",
      "ja": "例えばNORM_OBJECT_DATAとNORM_OBJECT_FILEとして、有限サイズのトランスポート・オブジェクトの場合、フラッシュ処理は、（保留中のオブジェクトがもはや存在しない場合）、これらのオブジェクトの終了時に発生します。このように、FECリペア情報は常にflushコマンドによって誘発された修理依頼に応じて、修理のために利用可能です。しかし、NORM_OBJECT_STREAMため、フラッシュがシステマティックFEC符号が使用される場合、FEC符号化ブロックの途中に含む、任意の時点で行うことができます。この場合、送信者はまだ同時符号化ブロックのためのFECパリティコンテンツを提供することができなくなり、明示的にそのブロックのソースデータコンテンツをストリームを修復するために制限されます。ストリームコンテンツの頻繁なフラッシングを予測アプリケーションは、（頻繁なフラッシングが発生した場合、すなわち、非常に大きな符号ブロックサイズを使用しない）FEC符号化ブロックサイズの選択に慎重であるべきです。例えば、間欠、比較的小さなメッセージの継続的なシリーズを送信する信頼性の高いマルチキャストアプリケーションは、適切なFEC符号化ブロックサイズでNORM_OBJECT_STREAMパラダイム対NORM_OBJECT_DATAパラダイムを使用してオフを交換する必要があります。これは、等「遅延なし」としての動作の異なるTCPモードの選択のような他のトランスポートプロトコルのアプリケーションのトレードオフに類似しています"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|version| type=3|    hdr_len    |          sequence             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           source_id                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          instance_id          |     grtt      |backoff| gsize |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  sub-type = 1 |    fec_id     |      object_transport_id      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         fec_payload_id                        |\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                acking_node_list (if applicable)               |\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 10: NORM_CMD(FLUSH) Message Format",
      "ja": "図10：NORM_CMD（FLUSH）メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "The \"version\", \"type\", \"hdr_len\", \"sequence\", and \"source_id\" fields form the NORM common message header as described in Section 4.1. In addition to the NORM common message header and standard NORM_CMD fields, the NORM_CMD(FLUSH) message contains fields to identify the current status and logical transmit position of the sender.",
      "ja": "「バージョン」、「タイプ」、「hdr_len」、「配列」、および「SOURCE_ID」フィールドセクション4.1に記載されるようにNORM共通のメッセージヘッダーを形成します。 NORM共通メッセージヘッダと標準NORM_CMDフィールドに加えて、NORM_CMD（FLUSH）メッセージは、送信者の現在の状態と論理送信位置を特定するフィールドを含んでいます。"
    },
    {
      "indent": 3,
      "text": "The \"fec_id\" field indicates the FEC type used for the flushing \"object_transport_id\" and implies the size and format of the \"fec_payload_id\" field. Note the \"hdr_len\" value for the NORM_CMD(FLUSH) message is 4 plus the size of the \"fec_payload_id\" field when no header extensions are present.",
      "ja": "「fec_id」フィールドはフラッシング「object_transport_id」ために使用されるFECタイプを示し、「fec_payload_id」フィールドのサイズと形式を意味しています。全くヘッダ拡張が存在しない場合NORM_CMD（FLUSH）メッセージの「hdr_len」値が「fec_payload_id」フィールドのサイズ+ 4であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The \"object_transport_id\" and \"fec_payload_id\" fields indicate the sender's current logical \"transmit position\". These fields are interpreted in the same manner as in the NORM_DATA message type. Upon receipt of the NORM_CMD(FLUSH), receivers are expected to check their completion state THROUGH (including) this transmission position. If receivers have outstanding repair needs in this range, they SHALL initiate the NORM NACK Repair Process as described in Section 5.3. If receivers have no outstanding repair needs, no response to the NORM_CMD(FLUSH) is generated.",
      "ja": "「object_transport_id」と「fec_payload_id」フィールドには、送信者の現在の論理「送信位置」を示しています。これらのフィールドはNORM_DATAメッセージタイプと同様に解釈されます。 NORM_CMD（FLUSH）を受信すると、受信機はこの送信位置（を含む）を介してその完了状態をチェックすることが期待されます。受信機はこの範囲で優れた修理の必要がある場合は、セクション5.3で説明したように、彼らはNORMのNACKの修復プロセスを開始しなければなりません。受信機は、未解決の修理のニーズを持っていない場合は、NORM_CMD（FLUSH）への応答は生成されません。"
    },
    {
      "indent": 3,
      "text": "For NORM_OBJECT_STREAM objects using systematic FEC codes, receivers MUST request \"explicit-only\" repair of the identified \"source_block_number\" if the given \"encoding_symbol_id\" is less than the \"source_block_len\". This condition indicates the sender has not yet completed encoding the corresponding FEC block and parity content is not yet available. An \"explicit-only\" repair request consists of",
      "ja": "所与「encoding_symbol_id」が「source_block_len」未満であれば系統的なFEC符号を用いNORM_OBJECT_STREAMオブジェクトの場合、受信機は、識別された「source_block_number」の「明示的な専用」修復を要求しなければなりません。この条件は、送信者がまだ対応するFECブロックを符号化完了していないことを示し、パリティの内容はまだ利用できません。 「明示的な専用の」修理依頼はで構成されてい"
    },
    {
      "indent": 3,
      "text": "NACK content for the applicable \"source_block_number\" that does not include any requests for parity-based repair. This allows NORM sender applications to \"flush\" an ongoing stream of transmission when needed, even if in the middle of a FEC block. Once the sender resumes stream transmission and passes the end of the pending coding block, subsequent NACKs from receivers SHALL request parity-based repair as usual. Note that the use of a systematic FEC code is assumed here. Note that a sender has the option of arbitrarily shortening a given code block when such an application \"flush\" occurs. In this case, the receiver will request explicit repair, but the sender MAY provide FEC-based repair (parity segments) in response. These parity segments MUST contain the corrected \"source_block_len\" for the shortened block and that \"source_block_len\" associated with segments containing parity content SHALL override the previously advertised \"source_block_len\". Similarly, the \"source_block_len\" associated with the highest ordinal \"encoding_symbol_id\" SHALL take precedence over prior symbols when a difference (e.g., due to code shortening at the sender) occurs. Normal receiver NACK initiation and construction is discussed in detail in Section 5.3.",
      "ja": "パリティベースの修理のためのすべての要求が含まれていません該当する「source_block_number」のNACK内容。これはさえFECブロックの途中であれば、必要なときにNORM送信者アプリケーションは、送信の継続的な流れを「フラッシュ」することができます。送信側は、ストリーム伝送を再開し、保留中のコードブロックの終わりを通過すると、受信機からの後続のNACKはいつものように、パリティベースの修復を求めなければなりません。体系的FECコードの使用を想定していることに注意してください。送信者がこのようなアプリケーション「フラッシュ」が発生した場合、任意所与のコードブロックを短くするオプションを有することに留意されたいです。この場合、受信機は、明示的な修復を要求するが、送信者が応答してFECベースリペア（パリティセグメント）を提供することができます。これらのパリティセグメントは短縮ブロックについて補正「source_block_len」を含有しなければならず、以前にアドバタイズ「source_block_len」を上書きSHALLパリティコンテンツを含むセグメントに関連付けられた「source_block_len」という。同様に、最も高い順序に関連する「source_block_lenは」差（例えば、原因コードを送信者に短縮）が発生したときに前のシンボルよりも優先を講じなければならない「encoding_symbol_id」。通常の受信機NACK開始と建設は5.3節で詳しく説明されています。"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL \"acking_node_list\" field contains a list of NormNodeIds for receivers from which the sender is requesting explicit positive acknowledgment of reception up through the transmission point identified by the \"object_transport_id\" and \"fec_payload_id\" fields. The length of the list can be inferred from the length of the received NORM_CMD(FLUSH) message. When the \"acking_node_list\" is present, the lightweight positive acknowledgment process described in Section 5.5.3 SHALL be observed.",
      "ja": "オプション「acking_node_list」フィールドには、送信者が「object_transport_id」と「fec_payload_id」フィールドで識別される伝送ポイントを介してアップフロントの明示的な肯定応答を要求された受信機のためのNormNodeIdsのリストが含まれています。リストの長さは、受信NORM_CMD（FLUSH）メッセージの長さから推測することができます。 「acking_node_list」が存在する場合、セクション5.5.3で説明した軽量肯定応答プロセスを観察するものとします。"
    },
    {
      "indent": 0,
      "text": "4.2.3.2. NORM_CMD(EOT) Message",
      "section_title": true,
      "ja": "4.2.3.2。 NORM_CMD（EOT）メッセージ"
    },
    {
      "indent": 3,
      "text": "The NORM_CMD(EOT) command is sent when the sender reaches permanent end-of-transmission with respect to the NormSession and will not respond to further repair requests. This allows receivers to gracefully reach closure of operation with this sender (without requiring any timeout) and free any resources that are no longer needed. The NORM_CMD(EOT) command SHOULD be sent with the same robust mechanism as used for NORM_CMD(FLUSH) commands to provide a high assurance of reception by the receiver set.",
      "ja": "NORM_CMD（EOT）コマンドは、送信者がNormSessionに対する永久エンドの伝送に到達し、さらに修復要求に応答しないときに送信されます。これは、受信機が正常（任意のタイムアウトを必要とせずに）、この送信者に操作の閉鎖に到達し、不要になったすべてのリソースを解放することができます。 NORM_CMD（FLUSH）のために使用される受信機のセットによって受信の高い保証を提供するためのコマンドとしてNORM_CMD（EOT）コマンドが同じ堅牢な機構を送ってください。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|version| type=3|    hdr_len    |          sequence             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           source_id                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          instance_id          |     grtt      |backoff| gsize |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  sub-type = 2 |                    reserved                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 11: NORM_CMD(EOT) Message Format",
      "ja": "図11：NORM_CMD（EOT）メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "The value of the \"hdr_len\" field for NORM_CMD(EOT) messages without header extensions present is 4. The \"reserved\" field is reserved for future use and MUST be set to an all ZERO value. Receivers MUST ignore the \"reserved\" field.",
      "ja": "本ヘッダ拡張せずNORM_CMD（EOT）メッセージのための「hdr_len」フィールドの値が「予約」フィールドは将来の使用のために予約され、すべてのゼロ値に設定しなければなりません4です。レシーバは、「予約」フィールドを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.2.3.3. NORM_CMD(SQUELCH) Message",
      "section_title": true,
      "ja": "4.2.3.3。 NORM_CMD（SQUELCH）メッセージ"
    },
    {
      "indent": 3,
      "text": "The NORM_CMD(SQUELCH) command is transmitted in response to outdated or invalid NORM_NACK content received by the sender. Invalid NORM_NACK content consists of repair requests for NormObjects for which the sender is unable or unwilling to provide repair. This includes repair requests for outdated objects, aborted objects, or those objects that the sender previously transmitted marked with the NORM_FLAG_UNRELIABLE flag. This command indicates to receivers what content is available for repair, thus serving as a description of the sender's current \"repair window\". Receivers SHALL NOT generate repair requests for content identified as invalid by a NORM_CMD(SQUELCH).",
      "ja": "NORM_CMD（SQUELCH）コマンドは、送信者によって受信された期限切れまたは無効NORM_NACKコンテンツに応答して送信されます。無効なNORM_NACKの内容は、送信者が修理を提供できないか、不本意であるためNormObjects修理依頼で構成されています。これは修理時代遅れのオブジェクトに対する要求、中止されたオブジェクト、または以前に送信送信者がNORM_FLAG_UNRELIABLEフラグでマークされたオブジェクトが含まれています。このコマンドは、このように、送信者の現在の「修理・ウィンドウ」の説明として、修理のために利用可能なもの、コンテンツ受信機に指示します。レシーバはNORM_CMD（SQUELCH）によって無効と識別されるコンテンツの修復要求を生成しないものとします。"
    },
    {
      "indent": 3,
      "text": "The NORM_CMD(SQUELCH) command is sent once per 2*GRTT_sender at the most. The NORM_CMD(SQUELCH) advertises the current \"repair window\" of the sender by identifying the earliest (lowest) transmission point for which it will provide repair, along with an encoded list of objects from that point forward that are no longer valid for repair. This mechanism allows the sender application to cancel or abort transmission and/or repair of specific previously enqueued objects. The list also contains the identifiers for any objects within the repair window that were sent with the NORM_FLAG_UNRELIABLE flag set. In normal conditions, the NORM_CMD(SQUELCH) will be needed infrequently, and generally only to provide a reference repair window for receivers who have fallen \"out-of-sync\" with the sender due to extremely poor network conditions.",
      "ja": "NORM_CMD（SQUELCH）コマンドは、最大で2 * GRTT_senderごとに一度送信されます。 NORM_CMD（SQUELCH）は、もはや修復のために有効でないその時点からオブジェクトの符号化されたリストと共に、修理を提供する対象の最古の（最低の）送信点を識別することによって、送信者の現在の「修復ウィンドウ」をアドバタイズ。このメカニズムは、特定の以前にキューに入れられたオブジェクトの送信および/または修復をキャンセルするか、中止する送信側アプリケーションを可能にします。リストには、NORM_FLAG_UNRELIABLEフラグを設定して送信された修理・ウィンドウ内の任意のオブジェクトの識別子が含まれています。通常の状態では、NORM_CMD（SQUELCH）が、まれに必要とされるであろう、と「同期外れ」送信者とによる極めて悪いネットワークの状態に陥っている受信機の基準リペアウィンドウを提供するために、一般的にのみ。"
    },
    {
      "indent": 3,
      "text": "The starting point of the invalid NormObject list begins with the lowest invalid NormTransportId greater than the current \"repair\nwindow\" start from the invalid NACK(s) that prompted the generation\nof the squelch.  The length of the list is limited by the sender's\nNormSegmentSize.  This allows the receivers to learn the status of\nthe sender's applicable object repair window with minimal\ntransmission of NORM_CMD(SQUELCH) commands.  The format of the\nNORM_CMD(SQUELCH) message is:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |version| type=3|    hdr_len    |          sequence             |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                           source_id                           |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |          instance_id          |     grtt      |backoff| gsize |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  | sub-type = 3  |     fec_id    |      object_transport_id      |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                         fec_payload_id                        |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                        invalid_object_list                    |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 12: NORM_CMD(SQUELCH) Message Format",
      "ja": "図12：NORM_CMD（SQUELCH）メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "In addition to the NORM common message header and standard NORM_CMD fields, the NORM_CMD(SQUELCH) message contains fields to identify the earliest logical transmit position of the sender's current repair window and an \"invalid_object_list\" beginning with the index of the logically earliest invalid repair request from the offending NACK message that initiated the NORM_CMD(SQUELCH) transmission. The value of the \"hdr_len\" field when no extensions are present is 4 plus the size of the \"fec_payload_id\" field that is dependent upon the FEC scheme identified by the \"fec_id\" field.",
      "ja": "NORM一般的なメッセージヘッダと標準NORM_CMDのフィールドに加えて、NORM_CMD（SQUELCH）メッセージが送信者の現在の修理窓の最も初期の論理送信位置と論理的に最も初期の不正な修理依頼のインデックスから始まる「invalid_object_list」を識別するためのフィールドが含まれていますNORM_CMD（SQUELCH）送信を開始し、問題のNACKメッセージから。何の拡張が存在しない「hdr_len」フィールドの値は4プラス「fec_id」フィールドによって識別されるFECスキームに依存して「fec_payload_id」フィールドのサイズです。"
    },
    {
      "indent": 3,
      "text": "The \"object_transport_id\" and \"fec_payload_id\" fields are concatenated to indicate the beginning of the sender's current repair window (i.e., the logically earliest point in its transmission history for which the sender can provide repair). The \"fec_id\" field implies the size and format of the \"fec_payload_id\" field. This serves as an advertisement of a \"synchronization\" point for receivers to request repair. Note, that while an \"encoding_symbol_id\" MAY be included in the \"fec_payload_id\" field, the sender's repair window SHOULD be aligned on FEC coding block boundaries and thus the \"encoding_symbol_id\" SHOULD be zero.",
      "ja": "「object_transport_id」と「fec_payload_id」フィールドは、送信者の現在の修理・ウィンドウ（送信者が修理を提供することができるために、その送信履歴で、すなわち、論理的に早い時点）の開始を示すために連結されています。 「fec_id」フィールドは、「fec_payload_id」フィールドのサイズと形式を意味します。これは、受信機が修理を要求するための「同期」点の広告として役立ちます。 「encoding_symbol_idは」「fec_payload_id」フィールドに含まれてもよいが、送信者の修理ウィンドウがFEC符号化ブロック境界に配置する必要があることに注意してくださいので、「encoding_symbol_id」ゼロであるべきです。"
    },
    {
      "indent": 3,
      "text": "The \"invalid_object_list\" is a list of 16-bit NormTransportIds that, although they are within the range of the sender's current repair window, are no longer available for repair from the sender. For example, a sender application MAY dequeue an out-of-date object even though it is still within the repair window. The total size of the \"invalid_object_list\" content can be determined from the packet's payload length and is limited to a maximum of the NormSegmentSize of the sender. Thus, for very large repair windows, it is possible that a single NORM_CMD(SQUELCH) message cannot include the entire set of invalid objects in the repair window. In this case, the sender SHALL ensure that the list begins with a NormTransportId that is greater than or equal to the lowest ordinal invalid NormTransportId from the NACK message(s) that prompted the NORM_CMD(SQUELCH) generation. The NormTransportId in the \"invalid_object_list\" MUST be ordinally greater than the \"object_transport_id\" marking the beginning of the sender's repair window. This ensures convergence of the squelch process, even if multiple invalid NACK/squelch iterations are required. This explicit description of invalid content within the sender's current window allows the sender application (most notably for discrete object transport) to arbitrarily invalidate (i.e., dequeue) portions of enqueued content (e.g., certain objects) for which it no longer wishes to provide reliable transport.",
      "ja": "「invalid_object_listは、」彼らは、送信者の現在の修理窓の範囲内にあるものの、もはや送信者からの修理のために利用可能な、16ビットNormTransportIdsのリストです。例えば、送信側アプリケーションは、それが修理・ウィンドウ内にあるにもかかわらず、期限切れのオブジェクトをデキューするかもしれません。 「invalid_object_list」コンテンツの合計サイズは、パケットのペイロードの長さから決定することができ、送信者のNormSegmentSizeの最大値に制限されています。このように、非常に大規模な修復窓のため、単一NORM_CMD（SQUELCH）メッセージが修復ウィンドウの無効なオブジェクトのセット全体を含むことができない可能性があります。この場合、送信者リストは以上NORM_CMD（SQUELCH）の生成を促しNACKメッセージ（単数または複数）から最低の順序無効NormTransportIdに等しいNormTransportId始まることを保証しなければなりません。 「invalid_object_list」のNormTransportIdは、送信者の修理窓の始まりをマークする「object_transport_id」よりordinally大きくなければなりません。これは、複数の無効NACK /スケルチ反復が必要とされる場合でも、スケルチプロセスの収束を保証します。送信者の現在のウィンドウ内の無効なコンテンツのこの明示的な記述は、（特に離散物体輸送のための）送信側アプリケーションが任意に無効にすることを可能にする（すなわち、デキュー）それはもはや信頼性の提供を希望するために待ち行列に入れられたコンテンツ（例えば、特定のオブジェクト）の部分輸送。"
    },
    {
      "indent": 0,
      "text": "4.2.3.4. NORM_CMD(CC) Message",
      "section_title": true,
      "ja": "4.2.3.4。 NORM_CMD（CC）メッセージ"
    },
    {
      "indent": 3,
      "text": "The NORM_CMD(CC) message contains fields to enable sender-to-group GRTT measurement and to excite the group for congestion control feedback. A baseline NORM congestion control scheme (NORM-CC), based on the TCP-Friendly Multicast Congestion Control (TFMCC) scheme of RFC 4654 is fully specified in Section 5.5.2 of this document. The NORM_CMD(CC) message is usually transmitted as part of NORM-CC operation. A NORM header extension is defined below to be used with the NORM_CMD(CC) message to support NORM-CC operation. Different header extensions MAY be defined for the NORM_CMD(CC) (and/or other NORM messages as needed) to support alternative congestion control schemes in the future. If NORM is operated in a network where resources are explicitly dedicated to the NORM session and therefore congestion control operation is disabled, the NORM_CMD(CC) message is then used solely for GRTT measurement and MAY be sent less frequently than with congestion control operation.",
      "ja": "NORM_CMD（CC）メッセージは、送信者対グループGRTTの測定を可能にするために、輻輳制御フィードバックのためのグループを励起するためのフィールドを含んでいます。 TCPフレンドリーマルチキャスト輻輳制御に基づいて、ベースラインNORMの輻輳制御方式（NORM-CC）は、RFC 4654の（TFMCC）方式は、完全にこのドキュメントのセクション5.5.2で指定されています。 NORM_CMD（CC）メッセージは、通常、NORM-CC動作の一部として送信されます。 NORMヘッダの拡張は、以下に定義されるNORM-CCの動作をサポートするNORM_CMD（CC）メッセージで使用します。異なるヘッダ拡張は、将来的には、代替の輻輳制御方式をサポートするためにNORM_CMD（CC）（および/または必要に応じて他のNORMメッセージ）のために定義されるかもしれません。 NORMは、リソースが明示的NORMセッションに専用であり、したがって、輻輳制御動作が無効になっているネットワークで動作している場合、NORM_CMD（CC）メッセージは、GRTT測定のためだけに使用され、あまり頻繁に輻輳制御動作と比べて送ってもよいです。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|version| type=3|    hdr_len    |            sequence           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           source_id                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          instance_id          |     grtt      |backoff| gsize |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  sub-type = 4 |    reserved   |          cc_sequence          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         send_time_sec                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        send_time_usec                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               header extensions (if applicable)               |\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  cc_node_list (if applicable)                 |\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 13: NORM_CMD(CC) Message Format",
      "ja": "図13：NORM_CMD（CC）メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "The NORM common message header and standard NORM_CMD fields serve their usual purposes. The value of the \"hdr_len\" field when no header extensions are present is 6.",
      "ja": "NORM一般的なメッセージヘッダと標準NORM_CMDフィールドは通常の目的を果たします。全くヘッダ拡張が存在しない「hdr_len」フィールドの値は6です。"
    },
    {
      "indent": 3,
      "text": "The \"reserved\" field is for potential future use and MUST be set to ZERO in this version of the NORM protocol and its baseline NORM-CC congestion control scheme. It is possible for alternative congestion control schemes to use the NORM_CMD(CC) message defined here and leverage the \"reserved\" field for scheme-specific purposes.",
      "ja": "「予約」フィールドは、潜在的な将来の使用のためであり、このNORMプロトコルのバージョンとベースラインNORM-CCの輻輳制御方式でゼロに設定する必要があります。代替輻輳制御方式は、ここで定義されたNORM_CMD（CC）メッセージを使用し、スキーム、特定の目的のために「予約」フィールドを活用することが可能です。"
    },
    {
      "indent": 3,
      "text": "The \"cc_sequence\" field is a sequence number applied by the sender. For NORM-CC operation, it is used to provide functionality equivalent to the \"feedback round number\" (fb_nr) described in RFC 4654. The most recently received \"cc_sequence\" value is recorded by receivers and can be fed back to the sender in congestion control feedback generated by the receivers for that sender. The \"cc_sequence\" number can also be used in NORM implementations to assess how recently a receiver has received NORM_CMD(CC) probes from the sender. This can be useful instrumentation for complex or experimental multicast routing environments.",
      "ja": "「cc_sequence」フィールドには、送信者によって適用されたシーケンス番号です。 NORM-CC動作のためには、最も最近に受信した「cc_sequence」値が受信機によって記録され、渋滞に送信者に供給することができるRFC 4654.に記載された「フィードバックラウンド数」（fb_nr）と同等の機能を提供するために使用されその送信者のための受信機によって生成された制御フィードバック。 「cc_sequence」数は、受信機が送信機からNORM_CMD（CC）プローブを受信したか、最近評価するNORM実装に使用することができます。これは、複雑なまたは実験マルチキャストルーティング環境に役立つ計測することができます。"
    },
    {
      "indent": 3,
      "text": "The \"send_time\" field is a timestamp indicating the time that the NORM_CMD(CC) message was transmitted. This consists of a 64-bit field containing 32-bits with the time in seconds (\"send_time_sec\") and 32-bits with the time in microseconds (\"send_time_usec\") since some reference time the source maintains (usually 00:00:00, 1 January 1970). The byte ordering of the fields is \"Big Endian\" network order. Receivers use this timestamp adjusted by the amount of delay from the time they received the NORM_CMD(CC) message to the time of their response as the \"grtt_response\" portion of NORM_ACK and NORM_NACK messages generated. This allows the sender to evaluate round-trip times to different receivers for congestion control and other (e.g., GRTT determination) purposes.",
      "ja": "「SEND_TIME」フィールドはNORM_CMD（CC）メッセージを送信した時間を示すタイムスタンプです。これは、ソースが保持いくつかの基準時間（通常00:00:00から秒単位の時間（「send_time_sec」）およびマイクロ秒の時間（「send_time_usec」）と32ビットと32ビットを含む64ビットのフィールドで構成されてい、1970年1月1日）。フィールドのバイト順序は、「ビッグエンディアン」ネットワーク順です。受信機は、それらがNORM_CMD（CC）メッセージを受信した時刻から生成NORM_ACKとNORM_NACKメッセージの「grtt_response」部分としてのそれらの応答の時間遅延の量によって調整このタイムスタンプを使用します。これは、送信者が輻輳制御と他の（例えば、GRTT決定）目的のために異なる受信機へのラウンドトリップ時間を評価することを可能にします。"
    },
    {
      "indent": 3,
      "text": "To facilitate the baseline NORM-CC scheme described in Section 5.5.2,\na NORM-CC Rate header extension (EXT_RATE) is defined to inform the\ngroup of the sender's current transmission rate.  This is used along\nwith the loss detection \"sequence\" field of all NORM sender messages\nand the NORM_CMD(CC) GRTT collection process to support NORM-CC\ncongestion control operation.  The format of this header extension is\nas follows:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |    het = 128  |    reserved   |           send_rate           |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"send_rate\" field indicates the sender's current transmission rate in bytes per second. The 16-bit \"send_rate\" field consists of 12 bits of mantissa in the most significant portion and 4 bits of base 10 integer exponent (E) information in the least significant portion. The 12-bit mantissa portion of the field is scaled such that a base 10 mantissa (M) floating point value of 0.0 corresponds to 0 and a value of 10.0 corresponds to 4096 in the upper 12 bits of the 16-bit \"send_rate\" field. Thus:",
      "ja": "「send_rate」フィールドには、秒あたりのバイト数で、送信者の現在の伝送速度を示しています。 16ビットの「send_rate」フィールドは、最も重要な部分で仮数の12ビットと最下位部分においてベース10の整数指数（E）情報の4ビットから成ります。フィールドの12ビットの仮数部は、その基部10の仮数（M）浮動小数点0から0.0相当の値と16ビットの上位12ビットに4096から10.0相当の値「send_rate」フィールドはスケーリングされます。副<文>この[前述の事実の]結果として、それ故に、従って、だから◆【同】consequently; therefore <文>このような方法で、このようにして、こんなふうに、上に述べたように◆【同】in this manner <文>そのような程度まで<文> AひいてはB◆【用法】A and thus B <文>例えば◆【同】for example; as an example："
    },
    {
      "indent": 10,
      "text": "send_rate = (((int)(M * 4096.0 / 10.0 + 0.5)) << 4) | E;",
      "ja": "send_rate =（（（INT）（M * 4096.0 / 10.0 + 0.5））<< 4）| E;"
    },
    {
      "indent": 3,
      "text": "For example, to represent a transmission rate of 256 kbit/s (3.2e+04 bytes per second), the lower 4 bits of the 16-bit field contain a value of 0x04 to represent the exponent (E) while the upper 12 bits contain a value of 0x51f (M) as determined from the equation given above: send_rate = (((int)((3.2 * 4096.0 / 10.0) + 0.5)) << 4) | 4; = (0x51f << 4) | 0x4 = 0x51f4",
      "ja": "例えば、256キロビット/秒（毎秒3.2E + 04バイト）の伝送速度を表すために、16ビットのフィールドの下位4ビットは、指数（E）を表すために0x04の値を含む上位12ビット一方上記の式から決定されるように0x51fの値（M）を含む：send_rate =（（（INT）（（3.2 * 4096.0 / 10.0）+ 0.5））<< 4）| 4; =（0x51f << 4）| 0x4の= 0x51f4"
    },
    {
      "indent": 3,
      "text": "To decode the \"send_rate\" field, the following equation can be used:",
      "ja": "「send_rate」フィールドをデコードするには、次の式を使用することができます。"
    },
    {
      "indent": 3,
      "text": "value = (send_rate >> 4) * (10/4096) * power(10, (send_rate & x000f))",
      "ja": "値=（send_rate >> 4）*（4096分の10）*電源（10、（send_rate＆x000f））"
    },
    {
      "indent": 3,
      "text": "Note the maximum transmission rate that can be represented by this scheme is approximately 9.99e+15 bytes per second.",
      "ja": "このスキームで表すことができる最大の伝送速度は、毎秒約9.99e + 15バイトであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "When this extension is present, a \"cc_node_list\" might be attached as the payload of the NORM_CMD(CC) message. The presence of this header extension also implies that NORM receivers MUST respond according to the procedures described in Section 5.5.2.",
      "ja": "この拡張が存在する場合、「cc_node_list」はNORM_CMD（CC）メッセージのペイロードとして添付されるかもしれません。このヘッダー拡張の存在はまた、NORM受信機は、セクション5.5.2に記載の手順に従って応答しなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "The \"cc_node_list\" consists of a list of NormNodeIds and their associated congestion control status. This includes the current limiting receiver (CLR) node, any potential limiting receiver (PLR) nodes that have been identified, and some number of receivers for which congestion control status is being provided, most notably including the receivers' current RTT measurement. The maximum length of the \"cc_node_list\" provides for at least the CLR and one other receiver, but can be increased for more timely feedback to the group. The list length can be inferred from the length of the NORM_CMD(CC) message.",
      "ja": "「cc_node_listは」NormNodeIdsとそれに関連する輻輳制御状態のリストで構成されます。これは、電流制限レシーバ（CLR）ノード、同定された潜在的な限定受信（PLR）ノード、および輻輳制御状態が最も顕著に受信者の現在のRTTの測定を含む、提供されている受信機のいくつかの数を含みます。 「cc_node_list」の最大長さは、少なくともCLRとつの他の受信機のために提供するが、グループへのよりタイムリーなフィードバックを増加させることができます。リストの長さはNORM_CMD（CC）メッセージの長さから推測することができます。"
    },
    {
      "indent": 3,
      "text": "Each item in the \"cc_node_list\" is in the following format:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                          cc_node_id                           |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |    cc_flags   |     cc_rtt    |            cc_rate            |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"cc_node_id\" is the NormNodeId of the receiver the item represents.",
      "ja": "「cc_node_id」はアイテムが表す受信機のNormNodeIdあります。"
    },
    {
      "indent": 3,
      "text": "The \"cc_flags\" field contains flags indicating the congestion control status of the indicated receiver. The following flags are defined:",
      "ja": "「cc_flags」フィールドは、指定受信機の輻輳制御状態を示すフラグを含みます。次のフラグが定義されています。"
    },
    {
      "indent": 3,
      "text": "+--------------------+-------+--------------------------------------+\n| Flag               | Value | Purpose                              |\n+--------------------+-------+--------------------------------------+\n| NORM_FLAG_CC_CLR   |  0x01 | Receiver is the current limiting     |\n|                    |       | receiver (CLR).                      |\n| NORM_FLAG_CC_PLR   |  0x02 | Receiver is a potential limiting     |\n|                    |       | receiver (PLR).                      |\n| NORM_FLAG_CC_RTT   |  0x04 | Receiver has measured RTT with       |\n|                    |       | respect to sender.                   |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| NORM_FLAG_CC_START |  0x08 | Sender/receiver is in \"slow start\"   |\n|                    |       | phase of congestion control          |\n|                    |       | operation (i.e., the receiver has    |\n|                    |       | not yet detected any packet loss and |\n|                    |       | the \"cc_rate\" field is the           |\n|                    |       | receiver's actual measured receive   |\n|                    |       | rate).                               |\n| NORM_FLAG_CC_LEAVE |  0x10 | Receiver is imminently leaving the   |\n|                    |       | session and its feedback SHOULD not  |\n|                    |       | be considered in congestion control  |\n|                    |       | operation.                           |\n+--------------------+-------+--------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"cc_rtt\" contains a quantized representation of the RTT as measured by the sender with respect to the indicated receiver. This field is valid only if the NORM_FLAG_CC_RTT flag is set in the \"cc_flags\" field. This one-byte field is a quantized representation of the RTT using the algorithm described in the Multicast NACK Building Block [RFC5401] document.",
      "ja": "「cc_rtt」が示され、受信機に対して送信者によって測定されたRTTの量子化された表現を含みます。このフィールドはNORM_FLAG_CC_RTTフラグが「cc_flags」フィールドに設定されている場合にのみ有効です。この1バイトのフィールドは、マルチキャストNACKビルディングブロック[RFC5401]の文書に記載されたアルゴリズムを使用して、RTTの量子化された表現です。"
    },
    {
      "indent": 3,
      "text": "The \"cc_rate\" field contains a representation of the receiver's current calculated (during steady-state congestion control operation) or twice its measured (during the slow start phase) congestion control rate. This field is encoded and decoded using the same technique as described for the NORM_CMD(CC) \"send_rate\" field.",
      "ja": "「cc_rate」フィールドは（定常状態の輻輳制御動作時）受信機の現在の計算の表現を含むか、2倍の輻輳制御率（スロースタートフェーズ中に）測定しました。このフィールドは、符号化及びNORM_CMD（CC）「send_rate」フィールドについて記載したのと同じ技術を使用して復号化されます。"
    },
    {
      "indent": 0,
      "text": "4.2.3.5. NORM_CMD(REPAIR_ADV) Message",
      "section_title": true,
      "ja": "4.2.3.5。 NORM_CMD（REPAIR_ADV）メッセージ"
    },
    {
      "indent": 3,
      "text": "The NORM_CMD(REPAIR_ADV) message is used by the sender to \"advertise\" its aggregated repair state from NORM_NACK messages accumulated during a repair cycle and/or congestion control feedback received. This message is sent only when the sender has received NORM_NACK and/or NORM_ACK(CC) (when congestion control is enabled) messages via unicast transmission instead of multicast. By relaying this information to the receiver set, suppression of feedback can be achieved even when receivers are unicasting that feedback instead of multicasting it among the group [NormFeedback].",
      "ja": "NORM_CMD（REPAIR_ADV）メッセージが受信された修理サイクル及び/又は輻輳制御フィードバック中に蓄積NORM_NACKメッセージからその凝集修復状態を「宣伝」するために、送信者によって使用されます。このメッセージは、送信者が（輻輳制御が有効になっている）NORM_NACK及び/又はNORM_ACK（CC）ユニキャスト伝送の代わりに、マルチキャストを介してメッセージを受信した場合にのみ送信されます。受信機セットにこの情報を中継することにより、フィードバックの抑制は、受信機は、そのフィードバックをユニキャストの代わりにグループ[NormFeedback]の間、それをマルチキャストする場合であっても達成することができます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|version| type=3|    hdr_len    |          sequence             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           source_id                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          instance_id          |     grtt      |backoff| gsize |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| sub-type = 5  |     flags     |            reserved           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               header extensions (if applicable)               |\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       repair_adv_payload                      |\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 14: NORM_CMD(REPAIR_ADV) Message Format",
      "ja": "図14：NORM_CMD（REPAIR_ADV）メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "The \"instance_id\", \"grtt\", \"backoff\", \"gsize\", and \"sub-type\" fields serve the same purpose as in other NORM_CMD messages. The value of the \"hdr_len\" field when no extensions are present is 4.",
      "ja": "「INSTANCE_ID」、「GRTT」、「バックオフ」、「GSIZE」、および「サブタイプ」フィールドは、他のNORM_CMDメッセージと同じ目的を果たします。何の拡張子が存在しない「hdr_len」フィールドの値は4です。"
    },
    {
      "indent": 3,
      "text": "The \"flags\" field provides information on the NORM_CMD(REPAIR_ADV) content. There is currently one NORM_CMD(REPAIR_ADV) flag defined:",
      "ja": "「フラグ」フィールドはNORM_CMD（REPAIR_ADV）コンテンツについての情報を提供します。定義された1 NORM_CMD（REPAIR_ADV）フラグは現在あり："
    },
    {
      "indent": 21,
      "text": "NORM_REPAIR_ADV_FLAG_LIMIT = 0x01",
      "ja": "NORM_REPAIR_ADV_FLAG_LIMIT = 0x01の"
    },
    {
      "indent": 3,
      "text": "This flag is set by the sender when it is unable to fit its full current repair state into a single NormSegmentSize. If this flag is set, receivers SHALL limit their NACK response to generating NACK content only up through the maximum ordinal transmission position (objectTransportId::fecPayloadId) included in the \"repair_adv_content\".",
      "ja": "単一のNormSegmentSizeにその最大電流修理の状態に合わせてすることができないときに、このフラグは送信者によって設定されます。このフラグが設定されている場合、受信機は、最大順序送信位置（objectTransportId :: fecPayloadId）を介してのみアップNACKコンテンツを生成に対するNACK応答を制限するものと「repair_adv_content」に含まれます。"
    },
    {
      "indent": 3,
      "text": "When congestion control operation is enabled, a header extension SHOULD be applied to the NORM_CMD(REPAIR_ADV) representing the most limiting (in terms of congestion control feedback suppression) congestion control response. This allows the NORM_CMD(REPAIR_ADV) message to suppress receiver congestion control responses as well as NACK feedback messages. The field is defined as a header extension so that alternative congestion control schemes can be used for NORM without revision to this document. A NORM-CC Feedback Header Extension (EXT_CC) is defined to encapsulate congestion control feedback within NORM_NACK, NORM_ACK, and NORM_CMD(REPAIR_ADV) messages. If another congestion control technique (e.g., Pragmatic General Multicast Congestion Control (PGMCC) [PgmccPaper]) is used",
      "ja": "輻輳制御動作がイネーブルされると、ヘッダ拡張は、輻輳制御応答（輻輳制御フィードバック抑制の点で）最も制限を表すNORM_CMD（REPAIR_ADV）に適用すべきです。これはNORM_CMD（REPAIR_ADV）メッセージが受信輻輳制御応答ならびにNACKフィードバックメッセージを抑制することを可能にします。代替的な輻輳制御方式は、この文書の改訂することなく、NORMのために使用することができるように、フィールドは、ヘッダ拡張として定義されます。 NORM-CCフィードバックヘッダ拡張（EXT_CC）はNORM_NACK、NORM_ACK、及びNORM_CMD（REPAIR_ADV）メッセージ内の輻輳制御フィードバックをカプセル化するために定義されています。別の輻輳制御技術（例えば、実用的な一般的なマルチキャスト輻輳制御（PGMCC）PgmccPaper]）が使用される場合"
    },
    {
      "indent": 3,
      "text": "within a NORM implementation, an additional header extension MAY need\nto be defined to encapsulate any required feedback content.  The\nNORM-CC Feedback Header Extension format is:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |     het = 3   |    hel = 3    |          cc_sequence          |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |    cc_flags   |     cc_rtt    |            cc_loss            |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |            cc_rate            |          cc_reserved          |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"cc_sequence\" field contains the current greatest \"cc_sequence\" value receivers have received in NORM_CMD(CC) messages from the sender. This information assists the sender in congestion control operation by providing an indicator of how current (\"fresh\") the receiver's round-trip measurement reference time is and whether the receiver has been successfully receiving recent congestion control probes. For example, if it is apparent the receiver has not been receiving recent congestion control probes (and thus possibly other messages from the sender), the sender SHOULD choose to take congestion avoidance measures. For NORM_CMD(REPAIR_ADV) messages, the sender SHALL set the \"cc_sequence\" field value to the value set in the last NORM_CMD(CC) message sent.",
      "ja": "「cc_sequence」フィールドには、現在の最大の「cc_sequence」値の受信機はNORM_CMD（CC）送信者からのメッセージで受信しているが含まれています。この情報は、受信側の往復の測定基準時間がどのように現在の（「フレッシュ」）の指標を提供することにより、及び受信機が正常に最近の輻輳制御プローブを受信したかどうかを輻輳制御動作中に、送信者を支援します。それが明らかである場合たとえば、受信機は（したがって、送信者からおそらく他のメッセージ）最近の輻輳制御プローブを受信して​​いない、送信者は輻輳回避策を取ることを選択する必要があります。 NORM_CMD（REPAIR_ADV）メッセージの場合、送信者は送信され、最後のNORM_CMD（CC）メッセージに設定された値に「cc_sequence」フィールドの値を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"cc_flags\" field contains bits representing the receiver's state with respect to congestion control operation. The possible values for the \"cc_flags\" field are those specified for the NORM_CMD(CC) message node list item flags. These fields are used by receivers in controlling (suppressing as necessary) their congestion control feedback. For NORM_CMD(REPAIR_ADV) messages, the NORM_FLAG_CC_RTT SHALL be set only when all feedback messages received by the sender have the flag set. Similarly, the NORM_FLAG_CC_CLR or NORM_FLAG_CC_PLR SHALL be set only when no feedback has been received from non-CLR or non-PLR receivers. And the NORM_FLAG_CC_LEAVE SHALL be set only when all feedback messages the sender has received have this flag set. These heuristics for setting the flags in NORM_CMD(REPAIR_ADV) ensure the most effective suppression of receivers providing unicast feedback messages.",
      "ja": "「cc_flags」フィールドは、輻輳制御動作に関して受信機の状態を表すビットを含みます。 「cc_flags」フィールドに指定可能な値はNORM_CMD（CC）メッセージノードリストアイテムフラグに指定されたものです。これらのフィールドを制御する際に受信機によって使用されるそれらの輻輳制御フィードバックを（必要に応じて抑制）。 NORM_CMD（REPAIR_ADV）メッセージのために、NORM_FLAG_CC_RTTは、送信者によって受信されたすべてのフィードバックメッセージはフラグが設定されているときにのみ設定されなければなりません。同様に、NORM_FLAG_CC_CLRまたはNORM_FLAG_CC_PLRにはフィードバックが非CLRまたは非PLR受信機から受信されていない場合にのみ設定されなければなりません。そしてNORM_FLAG_CC_LEAVEは、送信者が受信したすべてのフィードバックメッセージは、このフラグが設定されているときにのみ設定されなければなりません。 NORM_CMD（REPAIR_ADV）のフラグを設定するためのこれらの経験則は、ユニキャストフィードバックメッセージを提供する受信機の最も効果的な抑制を確保します。"
    },
    {
      "indent": 3,
      "text": "The \"cc_rtt\" field SHALL be set to a default maximum value, and the NORM_FLAG_CC_RTT flag SHALL be cleared when no receiver has yet received RTT measurement information. When a receiver has received RTT measurement information, it SHALL set the \"cc_rtt\" value accordingly and set the NORM_FLAG_CC_RTT flag in the \"cc_flags\" field. For NORM_CMD(REPAIR_ADV) messages, the sender SHALL set the \"cc_rtt\" field value to the largest non-CLR/non-PLR RTT it has measured from receivers for the current feedback round.",
      "ja": "「cc_rtt」フィールドは、デフォルトの最大値に設定するものとし、いかなる受信機はまだRTT測定情報を受信しなかった場合NORM_FLAG_CC_RTTフラグがクリアされSHALL。受信機は、RTT測定情報を受信したとき、それに応じて「cc_rtt」の値を設定し、「cc_flags」フィールドにNORM_FLAG_CC_RTTフラグを設定します。 NORM_CMD（REPAIR_ADV）メッセージの場合、送信者は、それが現在のフィードバックのラウンドのための受信機から測定した最大の非CLR /非PLR RTTに「cc_rtt」フィールドの値を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"cc_loss\" field represents the receiver's current packet loss fraction estimate for the indicated source. The loss fraction is a value from 0.0 to 1.0 corresponding to a range of zero to 100 percent packet loss. The 16-bit \"cc_loss\" value is calculated by the following formula:",
      "ja": "「cc_loss」フィールドは、示されたソースのための受信機の現在のパケット損失分率推定値を表します。損失分率はゼロから100％のパケット損失の範囲に対応する0.0から1.0までの値です。 16ビットの「cc_loss」値は、以下の式で計算されます。"
    },
    {
      "indent": 13,
      "text": "\"cc_loss\" = floor(decimal_loss_fraction * 65535.0)",
      "ja": "\"cc_loss\" =床（decimal_loss_fraction * 65535.0）"
    },
    {
      "indent": 3,
      "text": "For NORM_CMD(REPAIR_ADV) messages, the sender SHALL set the \"cc_loss\" field value to the largest non-CLR/non-PLR loss estimate it has received from receivers for the current feedback round.",
      "ja": "NORM_CMD（REPAIR_ADV）メッセージの場合、送信者は、それが現在のフィードバックのラウンドのための受信機から受信した最大の非CLR /非PLR損失推定値に「cc_loss」フィールドの値を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"cc_rate\" field represents the receiver's current local congestion control rate. During \"slow start\", when the receiver has detected no loss, this value is set to twice the actual rate it has measured from the corresponding sender and the NORM_FLAG_CC_START is set in the \"cc_flags\" field. Otherwise, the receiver calculates a congestion control rate based on its loss measurement and RTT measurement information (even if default) for the \"cc_rate\" field. For NORM_CMD(REPAIR_ADV) messages, the sender SHALL set the \"cc_loss\" field value to the lowest non-CLR/non-PLR \"cc_rate\" report it has received from receivers for the current feedback round.",
      "ja": "「cc_rate」フィールドには、受信機の現在のローカル輻輳制御率を表しています。受信機は損失が検出されなかった「スロースタート」、中、この値は、それが、対応する送信者から測定している二倍実際の速度に設定され、NORM_FLAG_CC_START「はcc_flags」フィールドに設定されています。そうでなければ、受信機は、「cc_rate」フィールドのためにその損失測定に基づいて、輻輳制御速度及びRTT測定情報（たとえデフォルト場合）を算出します。 NORM_CMD（REPAIR_ADV）メッセージの場合、送信者は、それが現在のフィードバックのラウンドのための受信機から受信した最低非CLR /非PLR「cc_rate」レポートに「cc_loss」フィールドの値を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"cc_reserved\" field is reserved for future NORM protocol use. Currently, senders SHALL set this field to ZERO, and receivers SHALL ignore the content of this field.",
      "ja": "「cc_reserved」フィールドは、将来NORMプロトコルの使用のために予約されています。現在、送信者がこの欄に0を設定するものとし、受信機は、このフィールドの内容を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"repair_adv_payload\" is in exactly the same form as the \"nack_content\" of NORM_NACK messages and can be processed by receivers for suppression purposes in the same manner, with the exception of the condition when the NORM_REPAIR_ADV_FLAG_LIMIT is set.",
      "ja": "「repair_adv_payload」はNORM_NACKメッセージの「nack_content」と全く同じ形であり、NORM_REPAIR_ADV_FLAG_LIMITが設定された条件を除いて、同じ方法で抑制のために受信機によって処理することができます。"
    },
    {
      "indent": 0,
      "text": "4.2.3.6. NORM_CMD(ACK_REQ) Message",
      "section_title": true,
      "ja": "4.2.3.6。 NORM_CMD（ACK_REQ）メッセージ"
    },
    {
      "indent": 3,
      "text": "The NORM_CMD(ACK_REQ) message is used by the sender to request\nacknowledgment from a specified list of receivers.  This message is\nused in providing a lightweight positive acknowledgment mechanism\nthat is OPTIONAL for use by the reliable multicast application.  A\nrange of acknowledgment request types is provided for use at the\napplication's discretion.  Provision for application-defined,\npositively acknowledged commands allows the application to\nautomatically take advantage of transmission and round-trip timing\ninformation available to the NORM protocol.  The details of the NORM\nPositive Acknowledgment Process including transmission of the\nNORM_CMD(ACK_REQ) messages and the receiver response (NORM_ACK) are described in Section 5.5.3.  The format of the NORM_CMD(ACK_REQ)\nmessage is:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |version| type=3|    hdr_len    |          sequence             |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                           source_id                           |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |          instance_id          |     grtt      |backoff| gsize |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  | sub-type = 6  |    reserved   |    ack_type   |    ack_id     |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                       acking_node_list                        |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 15: NORM_CMD(ACK_REQ) Message Format",
      "ja": "図15：NORM_CMD（ACK_REQ）メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "The NORM common message header and standard NORM_CMD fields serve their usual purposes. The value of the \"hdr_len\" field for NORM_CMD(ACK_REQ) messages with no header extension present is 4.",
      "ja": "NORM一般的なメッセージヘッダと標準NORM_CMDフィールドは通常の目的を果たします。無ヘッダ拡張存在とNORM_CMD（ACK_REQ）メッセージのための「hdr_len」フィールドの値は4です。"
    },
    {
      "indent": 3,
      "text": "The \"ack_type\" field indicates the type of acknowledgment being requested and thus implies rules for how the receiver will treat this request. The following \"ack_type\" values are defined and are also used in NORM_ACK messages described later:",
      "ja": "「ack_type」フィールドには、要求されている承認のタイプを示し、したがって、受信機は、この要求を処理する方法のための規則を意味します。以下「ack_type」の値が定義され、また、後述するNORM_ACKメッセージで使用されています。"
    },
    {
      "indent": 3,
      "text": "+-----------------------+------------+------------------------------+\n| ACK Type              | Value      | Purpose                      |\n+-----------------------+------------+------------------------------+\n| NORM_ACK(CC)          | 1          | Used to identify NORM_ACK    |\n|                       |            | messages sent in response to |\n|                       |            | NORM_CMD(CC) messages.       |\n| NORM_ACK(FLUSH)       | 2          | Used to identify NORM_ACK    |\n|                       |            | messages sent in response to |\n|                       |            | NORM_CMD(FLUSH) messages.    |\n| NORM_ACK(RESERVED)    | 3-15       | Reserved for possible future |\n|                       |            | NORM protocol use.           |\n| NORM_ACK(APPLICATION) | 16-255     | Used at application's        |\n|                       |            | discretion.                  |\n+-----------------------+------------+------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The NORM_ACK(CC) value is provided for use only in NORM_ACKs generated in response to the NORM_CMD(CC) messages used in congestion control operation. Similarly, the NORM_ACK(FLUSH) is provided for use only in NORM_ACKs generated in response to applicable NORM_CMD(FLUSH) messages. NORM_CMD(ACK_REQ) messages with \"ack_type\" of NORM_ACK(CC) or NORM_ACK(FLUSH) SHALL NOT be generated by the sender.",
      "ja": "NORM_ACK（CC）値のみ輻輳制御動作で使用NORM_CMD（CC）メッセージに応答して生成NORM_ACKsに使用するために設けられています。同様に、NORM_ACK（FLUSH）をのみ適用NORM_CMD（FLUSH）メッセージに応答して生成NORM_ACKsに使用するために設けられています。 NORM_CMD（ACK_REQ）NORM_ACK（CC）またはNORM_ACK（FLUSH）の \"ack_type\" とのメッセージが送信者によって生成されないものとします。"
    },
    {
      "indent": 3,
      "text": "The NORM_ACK(RESERVED) range of \"ack_type\" values is provided for possible future NORM protocol use.",
      "ja": "「ack_type」値のNORM_ACK（RESERVED）の範囲は、可能な将来のNORMプロトコルの使用のために提供されます。"
    },
    {
      "indent": 3,
      "text": "The NORM_ACK(APPLICATION) range of \"ack_type\" values is provided so that NORM applications can implement application-defined, positively acknowledged commands that are able to leverage internal transmission and round-trip timing information available to the NORM protocol implementation.",
      "ja": "そのNORMアプリケーションは内部伝送及びNORMプロトコルの実装に利用可能な往復のタイミング情報を活用することができるアプリケーション定義、肯定応答コマンドを実行することができるので、「ack_type」値のNORM_ACK（アプリケーション）の範囲が提供されます。"
    },
    {
      "indent": 3,
      "text": "The \"ack_id\" provides a sequenced identifier for the given NORM_CMD(ACK_REQ) message. This \"ack_id\" is returned in NORM_ACK messages generated by the receivers so that the sender can associate the response with its corresponding request.",
      "ja": "「ack_id」は、所与NORM_CMD（ACK_REQ）メッセージのための配列決定の識別子を提供します。この「ack_idは、」送信者がその対応する要求と応答を関連付けることができるように、受信機によって生成されたNORM_ACKメッセージで返されます。"
    },
    {
      "indent": 3,
      "text": "The \"reserved\" field is reserved for possible future protocol use and SHALL be set to ZERO by senders and ignored by receivers.",
      "ja": "「予約」フィールドは、将来のプロトコルの使用のために予約されており、送信者によってゼロに設定され、受信機によって無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"acking_node_list\" field contains the NormNodeIds of the current NORM receivers that are desired to provide positive acknowledgment (NORM_ACK) to this request. The packet payload length implies the length of the \"acking_node_list\", and its length is limited to the sender NormSegmentSize. The individual NormNodeId items are listed in network (Big Endian) byte order. If a receiver's NormNodeId is included in the \"acking_node_list\", it SHALL schedule transmission of a NORM_ACK message as described in Section 5.5.3.",
      "ja": "「acking_node_list」フィールドは、この要求に肯定応答（NORM_ACK）を提供することが望まれている現在のNORMレシーバのNormNodeIdsを含んでいます。パケットペイロード長は「acking_node_list」の長さを意味し、その長さは、送信者NormSegmentSizeに制限されています。個々NormNodeId項目は、ネットワーク（ビッグエンディアン）のバイト順にリストされています。受信機のNormNodeIdが「acking_node_list」に含まれている場合、セクション5.5.3に記載したように、それはNORM_ACKメッセージの送信をスケジュールSHALL。"
    },
    {
      "indent": 0,
      "text": "4.2.3.7. NORM_CMD(APPLICATION) Message",
      "section_title": true,
      "ja": "4.2.3.7。 NORM_CMD（APPLICATION）メッセージ"
    },
    {
      "indent": 3,
      "text": "This command allows the NORM application to robustly transmit application-defined commands. The command message preempts any ongoing data transmission and is repeated up to NORM_ROBUST_FACTOR times at a rate of once per 2*GRTT_sender. This rate of repetition allows the application to observe any response (if that is the application's purpose for the command) before it is repeated. Possible responses can include initiation of data transmission, other NORM_CMD(APPLICATION) messages, or even application-defined, positively acknowledged commands from other NormSession participants. The transmission of these commands will preempt data transmission when they are scheduled and can be multiplexed with ongoing data transmission. This type of robustly transmitted command allows NORM applications to define a complete set of session control mechanisms with less state than the transfer of FEC-encoded reliable content needs while taking advantage of NORM transmission and round-trip timing information.",
      "ja": "このコマンドはNORMアプリケーションが確実にアプリケーション定義コマンドを送信することができます。コマンドメッセージは、進行中のデータ送信を先取りし、一回あたり2 * GRTT_senderの割合でNORM_ROBUST_FACTOR回まで繰り返されます。繰り返しのこの割合は、（そのコマンドのために、アプリケーションの目的であるならば）、それが繰り返される前に、アプリケーションが応答を観察することができます。可能な応答は、データ伝送の開始、他のNORM_CMD（アプリケーション）メッセージ、あるいはアプリケーション定義を含むことができ、正に他NormSession参加者からのコマンドを受け付け。それらが予定されていると継続的なデータ伝送を多重化することができたときに、これらのコマンドの送信は、データ送信を先取りします。ロバストに送信されたコマンドのこのタイプは、NORM送信及び往復タイミング情報を利用しながらNORMアプリケーションはFEC符号化された信頼性の高いコンテンツのニーズの転送よりも少ない状態でセッション制御メカニズムの完全なセットを定義することを可能にします。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|version| type=3|    hdr_len    |          sequence             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           source_id                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          instance_id          |     grtt      |backoff| gsize |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| sub-type = 7  |                    reserved                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   Application-Defined Content                 |\n|                              ...                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 16: NORM_CMD(APPLICATION) Message Format",
      "ja": "図16：NORM_CMD（APPLICATION）メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "The NORM common message header and NORM_CMD fields are interpreted as previously described. The value of the NORM_CMD(APPLICATION) \"hdr_len\" field when no header extensions are present is 4.",
      "ja": "NORM共通メッセージヘッダとNORM_CMDフィールドは、前述のように解釈されます。全くヘッダ拡張が存在しないNORM_CMD（アプリケーション）「hdr_len」フィールドの値は4です。"
    },
    {
      "indent": 3,
      "text": "The \"Application-Defined Content\" area contains information in a format at the discretion of the application. The size of this payload SHALL be limited to a maximum of the sender's NormSegmentSize setting. Upon reception, the NORM protocol implementation SHALL deliver the content to the receiver application. Note that any detection of duplicate reception of a NORM_CMD(APPLICATION) message is the responsibility of the application.",
      "ja": "「アプリケーション定義の内容」エリアには、アプリケーションの裁量形式で情報が含まれています。このペイロードのサイズは、送信者のNormSegmentSize設定の最大値に限定されるものとします。受信すると、NORMプロトコルの実装は、受信機アプリケーションにコンテンツを引き渡さなければなりません。 NORM_CMD（アプリケーション）メッセージの重複受信の検出は、アプリケーションの責任であることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "4.3. Receiver Messages",
      "section_title": true,
      "ja": "4.3。レシーバメッセージ"
    },
    {
      "indent": 3,
      "text": "The NORM message types generated by participating receivers consist of the NORM_NACK and NORM_ACK message types. NORM_NACK messages are sent to request repair of missing data content from sender transmission, and NORM_ACK messages are generated in response to certain sender commands including NORM_CMD(CC) and NORM_CMD(ACK_REQ).",
      "ja": "参加する受信機によって生成されたNORMメッセージタイプはNORM_NACKとNORM_ACKメッセージタイプから成ります。 NORM_NACKメッセージは、送信元送信からデータコンテンツを欠落の修復を要求するために送信され、NORM_ACKメッセージはNORM_CMD（CC）及びNORM_CMD（ACK_REQ）を含む特定の送信者コマンドに応答して生成されます。"
    },
    {
      "indent": 0,
      "text": "4.3.1. NORM_NACK Message",
      "section_title": true,
      "ja": "4.3.1。 NORM_NACKメッセージ"
    },
    {
      "indent": 3,
      "text": "The principal purpose of NORM_NACK messages is for receivers to request repair of sender content via selective, negative acknowledgment upon detection of incomplete data. NORM_NACK messages will be transmitted according to the rules of NORM_NACK generation and suppression described in Section 5.3. NORM_NACK messages also contain additional fields to provide feedback to the sender(s) for purposes of round-trip timing collection and congestion control.",
      "ja": "受信機が、不完全なデータの検出時に選択的、否定応答を介して送信元コンテンツの修復を要求するためNORM_NACKメッセージの主な目的です。 NORM_NACKメッセージは、セクション5.3で説明NORM_NACK生成および抑制のルールに従って送信されます。 NORM_NACKメッセージも往復のタイミング収集と輻輳制御の目的のために、送信者（複数可）にフィードバックを提供するために追加のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "The payload of NORM_NACK messages contains one or more repair requests for different objects or portions of those objects.  The\nNORM_NACK message format is as follows:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |version| type=4|    hdr_len    |            sequence           |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                           source_id                           |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                           server_id                           |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |           instance_id         |            reserved           |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                       grtt_response_sec                       |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                       grtt_response_usec                      |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |               header extensions (if applicable)               |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                          nack_payload                         |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 17: NORM_NACK Message Format",
      "ja": "図17：NORM_NACKメッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "The NORM common message header fields serve their usual purposes. The value of the \"hdr_len\" field for NORM_NACK messages without header extensions present is 6.",
      "ja": "NORM一般的なメッセージヘッダーフィールドは通常の目的を果たします。本ヘッダ拡張せずNORM_NACKメッセージの「hdr_len」フィールドの値は6です。"
    },
    {
      "indent": 3,
      "text": "The \"server_id\" field identifies the NORM sender to which the NORM_NACK message is destined.",
      "ja": "「SERVER_ID」フィールドには、NORM_NACKメッセージが宛先であるNORMの送信者を特定します。"
    },
    {
      "indent": 3,
      "text": "The \"instance_id\" field contains the current session identifier given by the sender identified by the \"server_id\" field in its sender messages. The sender SHOULD ignore feedback messages containing an invalid \"instance_id\" value.",
      "ja": "「INSTANCE_ID」フィールドは、その送信者のメッセージに「SERVER_ID」フィールドで識別される送信者によって与えられた現在のセッション識別子が含まれています。送信者は無効「INSTANCE_ID」値を含むフィードバック・メッセージを無視すべきです。"
    },
    {
      "indent": 3,
      "text": "The \"grtt_response\" fields contain an adjusted version of the timestamp from the most recently received NORM_CMD(CC) message for the indicated NORM sender. The format of the \"grtt_response\" is the same as the \"send_time\" field of the NORM_CMD(CC). The \"grtt_response\" value is relative to the \"send_time\" the source provided with a corresponding NORM_CMD(CC) command. The receiver adjusts the source's NORM_CMD(CC) \"send_time\" timestamp by adding the time delta from when the receiver received the NORM_CMD(CC) to when the NORM_NACK is transmitted in response to calculate the value in the \"grtt_response\" field. This is the \"receive_to_response_delta\" value used in the following formula: grtt_response = NORM_CMD(CC) send_time + receive_to_response_delta",
      "ja": "「grtt_response」フィールドが指示されたNORM送信者のための最も最近受け取っNORM_CMD（CC）メッセージからタイムスタンプの調整バージョンが含まれています。 「grtt_response」のフォーマットはNORM_CMD（CC）の「SEND_TIME」フィールドと同じです。 「grtt_response」値は「SEND_TIME」対応NORM_CMD（CC）コマンドで提供されたソースに対するものです。受信機は、受信機がNORM_NACKが「grtt_response」フィールドの値を計算するために応じて送信されたときにNORM_CMD（CC）を受信したときからの時間デルタを加算することによりソースのNORM_CMD（CC）「SEND_TIME」のタイムスタンプを調整します。これは、次の式で使用される \"receive_to_response_delta\" 値である：grtt_response = NORM_CMD（CC）SEND_TIME + receive_to_response_delta"
    },
    {
      "indent": 3,
      "text": "The receiver SHALL set the \"grtt_response\" to a ZERO value, to indicate it has not yet received a NORM_CMD(CC) message from the indicated sender, and the sender MUST ignore the \"grtt_response\" in this message.",
      "ja": "受信機は、ゼロ値に「grtt_response」を定めなければならないことはまだ示さ送信者からNORM_CMD（CC）メッセージを受信しなかったことを示すために、送信者は、このメッセージで「grtt_response」を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For NORM-CC operation, the NORM-CC Feedback Header Extension, as described in the NORM_CMD(REPAIR_ADV} message description, is added to NORM_NACK messages to provide feedback on the receiver's current state with respect to congestion control operation. Alternative header extensions for congestion control feedback MAY be defined for alternative congestion control schemes for NORM use in the future.",
      "ja": "NORM-CC動作、NORM-CCフィードバックヘッダ拡張のため、NORM_CMD（REPAIR_ADV}メッセージの説明に記載されているように、輻輳制御動作に関して受信機の現在の状態に関するフィードバックを提供するために、メッセージをNORM_NACKするために添加される。輻輳のための代替ヘッダ拡張制御フィードバックは、将来的にはNORMの使用のための代替輻輳制御方式のために定義されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The \"reserved\" field is for potential future NORM use and SHALL be set to ZERO for this version of the protocol.",
      "ja": "「予約」フィールドには、潜在的な将来のNORMの使用のためのものであり、プロトコルのこのバージョンのためにゼロに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"nack_payload\" of the NORM_NACK message specifies the repair\nneeds of the receiver with respect to the NORM sender indicated by\nthe \"server_id\" field.  The receiver constructs repair requests based\non the NORM_DATA and/or NORM_INFO segments it needs from the sender\nto complete reliable reception up to the sender's transmission\nposition at the moment the receiver initiates the NACK procedure as\ndescribed in Section 5.3.  A single NORM Repair Request consists of a\nlist of items, ranges, and/or FEC coding block erasure counts for\nneeded NORM_DATA and/or NORM_INFO content.  Multiple repair requests\ncan be concatenated within the \"nack_payload\" field of a NORM_NACK\nmessage.  A single NORM Repair Request can possibly include multiple\n\"items\", \"ranges\", or \"erasure_counts\".  In turn, the \"nack_payload\"\nfield MAY contain multiple repair requests.  A single NORM Repair\nRequest has the following format:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |      form     |     flags     |             length            |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                      repair_request_items                     |\n  |                             ...                               |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 18: NORM Repair Request Format",
      "ja": "図18：NORMの修理依頼フォーマット"
    },
    {
      "indent": 3,
      "text": "The \"form\" field indicates the type of repair request items given in the \"repair_request_items\" list. Possible values for the \"form\" field include:",
      "ja": "「フォーム」フィールドは、「repair_request_items」リストで与えられた修理依頼アイテムの種類を示します。 「フォーム」フィールドに指定可能な値は次のとおりです。"
    },
    {
      "indent": 22,
      "text": "+--------------------+-------+\n| Form               | Value |\n+--------------------+-------+\n| NORM_NACK_ITEMS    |   1   |\n| NORM_NACK_RANGES   |   2   |\n| NORM_NACK_ERASURES |   3   |\n+--------------------+-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A \"form\" value of NORM_NACK_ITEMS indicates each repair request item in the \"repair_request_items\" list is to be treated as an individual request. A value of NORM_NACK_RANGES indicates the \"repair_request_items\" list consists of pairs of repair request items corresponding to the inclusive ranges of repair needs. The NORM_NACK_ERASURES \"form\" indicates the repair request items are to be treated individually and the \"encoding_symbol_id\" portion of the \"fec_payload_id\" field of the repair request item (see below) is to be interpreted as an erasure count for the FEC coding block identified by the repair request item's \"source_block_number\".",
      "ja": "NORM_NACK_ITEMSの「形」の値は「repair_request_items」リスト内の各修理依頼項目は個々の要求として処理されるべきであることを示します。 NORM_NACK_RANGESの値が「repair_request_items」リストには、修理の必要性を含めた範囲に対応した修理依頼項目のペアで構成さを示しています。 NORM_NACK_ERASURES「フォーム」が個別に扱われるべきであり、修理依頼項目の「fec_payload_id」フィールド（下記参照）の「encoding_symbol_id」部分が特定のFEC符号化ブロックの消去回数として解釈されるべきである修理依頼項目を示します修理依頼項目の「source_block_number」によります。"
    },
    {
      "indent": 3,
      "text": "The \"flags\" field is currently used to indicate the level of data content for which the repair request items apply (i.e., an individual segment, entire FEC coding block, or entire transport object). Possible flag values include:",
      "ja": "「フラグ」フィールドは、現在修理依頼項目が適用されるデータ内容のレベルを示すために使用される（すなわち、個々のセグメント、全体FEC符号化ブロック、または全体のトランスポート・オブジェクト）。可能なフラグ値は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "+-------------------+--------+--------------------------------------+\n| Flag              |  Value | Purpose                              |\n+-------------------+--------+--------------------------------------+\n| NORM_NACK_SEGMENT |  0x01  | Indicates the listed segment(s) or   |\n|                   |        | range of segments needed as repair.  |\n| NORM_NACK_BLOCK   |  0x02  | Indicates the listed block(s) or     |\n|                   |        | range of blocks in entirety that are |\n|                   |        | needed as repair.                    |\n| NORM_NACK_INFO    |  0x04  | Indicates NORM_INFO is needed as     |\n|                   |        | repair for the listed object(s).     |\n| NORM_NACK_OBJECT  |  0x08  | Indicates the listed object(s) or    |\n|                   |        | range of objects in entirety are     |\n|                   |        | needed as repair.                    |\n+-------------------+--------+--------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When the NORM_NACK_SEGMENT flag is set, the \"object_transport_id\" and \"fec_payload_id\" fields are used to determine which sets or ranges of individual NORM_DATA segments are needed to repair content at the receiver. When the NORM_NACK_BLOCK flag is set, this indicates the receiver is completely missing the indicated coding block(s), and that transmissions sufficient to repair the indicated block(s) in their entirety are needed. When the NORM_NACK_INFO flag is set, this indicates the receiver is missing the NORM_INFO segment for the indicated \"object_transport_id\". Note the NORM_NACK_INFO can be set in combination with the NORM_NACK_BLOCK or NORM_NACK_SEGMENT flags, or can be set alone. When the NORM_NACK_OBJECT flag is set, this indicates the receiver is missing the entire NormTransportObject referenced by the \"object_transport_id\". This also implicitly requests any available NORM_INFO for the NormObject, if applicable. The \"fec_payload_id\" field is ignored when the flag NORM_NACK_OBJECT is set.",
      "ja": "NORM_NACK_SEGMENTフラグが設定されている場合、「object_transport_id」および「fec_payload_id」フィールドが設定または個々NORM_DATAセグメントの範囲は、受信機においてコンテンツを修復するために必要とされるかを決定するために使用されます。 NORM_NACK_BLOCKフラグが設定されている場合、これは、受信機が完全に示された符号化ブロックを欠落し、その全体が示されているブロックを修復するのに十分な伝送が必要であることであることを示します。 NORM_NACK_INFOフラグが設定されている場合、これは、受信機が示されている「object_transport_id」のNORM_INFOセグメントが欠落していることを示します。 NORM_NACK_INFOがNORM_NACK_BLOCKまたはNORM_NACK_SEGMENTフラグと組み合わせて設定することができ、単独設定することができます。 NORM_NACK_OBJECTフラグが設定されている場合、これは、受信機が「object_transport_id」によって参照される全体NormTransportObjectが欠落していることを示します。該当する場合、これはまた、暗黙のうちに、NormObjectのために使用可能な任意のNORM_INFOを要求します。フラグNORM_NACK_OBJECTが設定されている場合、「fec_payload_id」フィールドは無視されます。"
    },
    {
      "indent": 3,
      "text": "The \"length\" field value is the length in bytes of the \"repair_request_items\" field.",
      "ja": "「長さ」フィールドの値が「repair_request_items」フィールドのバイト長です。"
    },
    {
      "indent": 3,
      "text": "The \"repair_request_items\" field consists of a list of individual or\nrange pairs of transport data unit identifiers in the following\nformat.\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |     fec_id    |   reserved    |      object_transport_id      |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                        fec_payload_id                         |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 19: NORM Repair Request Item Format",
      "ja": "図19：NORM修理依頼項目フォーマット"
    },
    {
      "indent": 3,
      "text": "The \"fec_id\" indicates the FEC type and can be used to determine the format of the \"fec_payload_id\" field. The \"reserved\" field is kept for possible future use and SHALL be set to a ZERO value and ignored by NORM nodes processing NACK content.",
      "ja": "「fec_id」はFECタイプを示し、「fec_payload_id」フィールドのフォーマットを決定するために用いることができます。 「予約」フィールドは、将来の使用のために保持され、ゼロ値に設定され、NORMノード処理NACK内容によって無視されます。"
    },
    {
      "indent": 3,
      "text": "The \"object_transport_id\" corresponds to the NormObject for which repair is being requested, and the \"fec_payload_id\" identifies the specific FEC coding block and/or segment being requested. When the NORM_NACK_OBJECT flag is set, the value of the \"fec_payload_id\" field is ignored. When the NORM_NACK_BLOCK flag is set, only the FEC code block identifier portion of the \"fec_payload_id\" is to be interpreted.",
      "ja": "「object_transport_id」は修復が要求されているNormObjectに対応し、「fec_payload_id」は、特定のFEC符号化ブロックを識別および/またはセグメントが要求されています。 NORM_NACK_OBJECTフラグが設定されている場合は、「fec_payload_id」フィールドの値は無視されます。 NORM_NACK_BLOCKフラグが設定されている場合、「fec_payload_id」のみFECコードブロック識別子部分は、解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "The format of the \"fec_payload_id\" field depends upon the \"fec_id\" field value.",
      "ja": "「fec_payload_id」フィールドの形式は、「fec_id」フィールドの値に依存します。"
    },
    {
      "indent": 3,
      "text": "When the receiver's repair needs dictate that different forms (mixed ranges and/or individual items) or types (mixed specific segments and/or blocks or objects in entirety) are needed to complete reliable transmission, multiple NORM Repair Requests with different \"form\" and or \"flags\" values can be concatenated within a single NORM_NACK message. Additionally, NORM receivers SHALL construct NORM_NACK messages with their repair requests in ordinal order with respect to",
      "ja": "受信機の修理の必要性は、異なる形態（混合範囲および/または個々のアイテム）またはタイプ（混合特定のセグメント及び/又は全体がブロックまたはオブジェクト）は信頼性の高い伝送を完了するために必要であることを指示する場合、異なる「形態」との複数NORM修理要求及び又は「フラグ」の値は、単一NORM_NACKメッセージ内で連結することができます。また、NORM受信機はに関して序ために、彼らの修理依頼でNORM_NACKメッセージを構築するものとし"
    },
    {
      "indent": 3,
      "text": "\"object_transport_id\" and \"fec_payload_id\" values. The \"nack_payload\" size SHALL NOT exceed the NormSegmentSize for the sender to which the NORM_NACK is destined.",
      "ja": "\"object_transport_id\" と \"fec_payload_id\" の値。 「nack_payload」サイズがNORM_NACKが運命づけられていると、送信者のためのNormSegmentSizeを超えてはなりません。"
    },
    {
      "indent": 3,
      "text": "NORM_NACK Content Examples:",
      "ja": "NORM_NACKコンテンツの例："
    },
    {
      "indent": 3,
      "text": "In these examples, a small block, systematic FEC code (\"fec_id\" = 129) is assumed with a user data block length of 32 segments. In Example 1, a list of individual NORM_NACK_ITEMS repair requests is given. In Example 2, a list of NORM_NACK_RANGES requests AND a single NORM_NACK_ITEMS request are concatenated to illustrate the possible content of a NORM_NACK message. Note that FEC coding block erasure counts could also be provided in each case. However, the erasure counts are not really necessary since the sender can easily determine the erasure count while processing the NACK content. However, the erasure count option can be useful for operation with other FEC codes or for intermediate system purposes.",
      "ja": "これらの例では、小ブロック、システマティックFEC符号（「fec_id」= 129）は32個のセグメントのユーザーデータブロックの長さと仮定されます。例1では、個々のNORM_NACK_ITEMS修理依頼のリストが与えられています。実施例2では、​​NORM_NACK_RANGES要求と単一NORM_NACK_ITEMS要求のリストはNORM_NACKメッセージの可能な内容を説明するために連結されます。 FEC符号化ブロックの消去回数は、各場合に提供することができることに注意してください。 NACKのコンテンツを処理している間に、送信者が簡単に消去回数を決定することができますので、消去カウントは本当に必要はありません。しかし、消去回数のオプションは、他のFEC符号付きまたは中間システムの目的のために操作するのに便利です。"
    },
    {
      "indent": 4,
      "text": "Example 1: NORM_NACK \"nack_payload\" for: Object 12, Coding Block 3,\n                       Segments 2, 5, and 8\n  0                   1                   2                   3\n  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |   form = 1    | flags = 0x01  |       length  = 36            |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |  fec_id = 129 |   reserved    |    object_transport_id = 12   |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                    source_block_number = 3                    |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |    source_block_length = 32   |    encoding_symbol_id = 2     |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |  fec_id = 129 |   reserved    |    object_transport_id = 12   |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                    source_block_number = 3                    |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |    source_block_length = 32   |    encoding_symbol_id = 5     |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |  fec_id = 129 |   reserved    |    object_transport_id = 12   |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                    source_block_number = 3                    |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |    source_block_length = 32   |    encoding_symbol_id = 8     |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": " Example 2: NORM_NACK \"nack_payload\" for: Object 18, Coding Block 6,\nSegments 5, 6, 7, 8, 9, 10; and Object 19 NORM_INFO and Coding Block\n                            1, Segment 3\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |   form = 2    | flags = 0x01  |       length  = 24            |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |  fec_id = 129 |   reserved    |    object_transport_id = 18   |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                    source_block_number = 6                    |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |    source_block_length = 32   |    encoding_symbol_id = 5     |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |  fec_id = 129 |   reserved    |    object_transport_id = 18   |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                    source_block_number = 6                    |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |    source_block_length = 32   |    encoding_symbol_id = 10    |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |   form = 1    | flags = 0x05  |       length  = 12            |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |  fec_id = 129 |   reserved    |    object_transport_id = 19   |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                    source_block_number = 1                    |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |    source_block_length = 32   |    encoding_symbol_id = 3     |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3.2. NORM_ACK Message",
      "section_title": true,
      "ja": "4.3.2。 NORM_ACKメッセージ"
    },
    {
      "indent": 3,
      "text": "The NORM_ACK message is intended to be used primarily as part of NORM\ncongestion control operation and round-trip timing measurement.  The\nacknowledgment type NORM_ACK(CC) is provided for this purpose as\ndescribed in the NORM_CMD(ACK_REQ) message description.  The\ngeneration of NORM_ACK(CC) messages for round-trip timing estimation\nand congestion control operation is described in Section 5.5.1 and\nSection 5.5.2, respectively.  However, some multicast applications\ncan benefit from some limited form of positive acknowledgment for\ncertain functions.  A simple, scalable positive acknowledgment scheme\nis defined in Section 5.5.3, which can be leveraged by protocol\nimplementations when appropriate.  The NORM_CMD(FLUSH) can also be\nused for OPTIONAL collection of positive acknowledgment of reliable\nreception to a certain \"watermark\" transmission point from specific\nreceivers using this mechanism.  The NORM_ACK type NORM_ACK(FLUSH) is\nprovided for this purpose and the format of the \"nack_payload\" for\nthis acknowledgment type is given below.  Beyond that, a range of\napplication-defined \"ack_type\" values is provided for use at the NORM application's discretion.  Implementations making use of application-\ndefined positive acknowledgments MAY also make use of the\n\"nack_payload\" as needed, observing the constraint that the\n\"nack_payload\" field size be limited to a maximum of the\nNormSegmentSize for the sender to which the NORM_ACK is destined.\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |version| type=5|    hdr_len    |          sequence             |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                           source_id                           |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                           server_id                           |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |           instance_id         |    ack_type  |     ack_id     |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                       grtt_response_sec                       |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                       grtt_response_usec                      |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |               header extensions (if applicable)               |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                   ack_payload (if applicable)                 |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 20: NORM_ACK Message Format",
      "ja": "図20：NORM_ACKメッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "The NORM common message header fields serve their usual purposes. The value of the \"hdr_len\" field when no header extensions are present is 6.",
      "ja": "NORM一般的なメッセージヘッダーフィールドは通常の目的を果たします。全くヘッダ拡張が存在しない「hdr_len」フィールドの値は6です。"
    },
    {
      "indent": 3,
      "text": "The \"server_id\", \"instance_id\", and \"grtt_response\" fields serve the same purpose as the corresponding fields in NORM_NACK messages. Header extensions can be applied to support congestion control feedback or other functions in the same manner.",
      "ja": "「SERVER_ID」、「INSTANCE_ID」、および「grtt_response」フィールドはNORM_NACKメッセージの対応するフィールドと同じ目的を果たします。ヘッダ拡張は同様に輻輳制御フィードバックまたは他の機能をサポートするために適用することができます。"
    },
    {
      "indent": 3,
      "text": "The \"ack_type\" field indicates the nature of the NORM_ACK message. This directly corresponds to the \"ack_type\" field of the NORM_CMD(ACK_REQ) message to which this acknowledgment applies.",
      "ja": "「ack_type」フィールドには、NORM_ACKメッセージの性質を示します。これは、直接確認が適用されるNORM_CMD（ACK_REQ）メッセージの「ack_type」フィールドに対応します。"
    },
    {
      "indent": 3,
      "text": "The \"ack_id\" field serves as a sequence number so the sender can verify a received NORM_ACK message actually applies to a current acknowledgment request. The \"ack_id\" field is not used in the case of the NORM_ACK(CC) and NORM_ACK(FLUSH) acknowledgment types.",
      "ja": "送信者が受信NORM_ACKメッセージが実際に現在の応答要求に適用確認できるように、「ack_id」フィールドは、シーケンス番号として機能します。 「ack_id」フィールドはNORM_ACK（CC）とNORM_ACK（FLUSH）承認タイプの場合に使用されていません。"
    },
    {
      "indent": 3,
      "text": "The \"ack_payload\" format is a function of the \"ack_type\". The",
      "ja": "「ack_payload」形式は「ack_type」の関数です。ザ・"
    },
    {
      "indent": 3,
      "text": "NORM_ACK(CC) message has no attached content.  Only the NORM_ACK\nheader applies.  In the case of NORM_ACK(FLUSH), a specific\n\"ack_payload\" format is defined:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |     fec_id    |   reserved    |      object_transport_id      |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |                        fec_payload_id                         |\n  |                              ...                              |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"object_transport_id\" and \"fec_payload_id\" are used by the receiver to acknowledge applicable NORM_CMD(FLUSH) messages transmitted by the sender identified by the \"server_id\" field.",
      "ja": "「object_transport_id」および「fec_payload_id」「SERVER_ID」フィールドによって識別される送信者によって送信された適用NORM_CMD（FLUSH）メッセージを確認するために受信機によって使用されます。"
    },
    {
      "indent": 3,
      "text": "The \"ack_payload\" of NORM_ACK messages for application-defined \"ack_type\" values is specific to the application but is limited in size to a maximum of the NormSegmentSize of the sender referenced by the \"server_id\".",
      "ja": "アプリケーション定義の「ack_type」値についてNORM_ACKメッセージの「ack_payload」は、アプリケーションに特有であるが、「SERVER_ID」によって参照される送信者のNormSegmentSizeの最大サイズに制限されています。"
    },
    {
      "indent": 0,
      "text": "4.4. General Purpose Messages",
      "section_title": true,
      "ja": "4.4。汎用メッセージ"
    },
    {
      "indent": 3,
      "text": "Some additional message formats are defined for general purpose in NORM multicast sessions whether the participant is acting as a sender and/or receiver within the group.",
      "ja": "いくつかの追加のメッセージフォーマットは、参加者がグループ内の送信者および/または受信機として機能しているか否かをNORMマルチキャストセッションで一般的な目的のために定義されています。"
    },
    {
      "indent": 0,
      "text": "4.4.1. NORM_REPORT Message",
      "section_title": true,
      "ja": "4.4.1。 NORM_REPORTメッセージ"
    },
    {
      "indent": 3,
      "text": "This is an OPTIONAL message generated by NORM participants. This message can be used for periodic performance reports from receivers in experimental NORM implementations. The format of this message is currently undefined. Experimental NORM implementations MAY define NORM_REPORT formats as needed for test purposes. These report messages SHOULD be disabled for interoperability testing between different compliant NORM implementations.",
      "ja": "これは、NORMの参加者によって生成されたオプションのメッセージです。このメッセージは、実験的なNORM実装で受信機からの定期的なパフォーマンス・レポートのために使用することができます。このメッセージのフォーマットは、現在定義されていません。テスト目的のために、必要に応じて実験NORM実装はNORM_REPORTフォーマットを定義することができます。これらのレポートメッセージは異なる対応NORM実装間の相互運用性テストのために無効にする必要があります。"
    },
    {
      "indent": 0,
      "text": "5. Detailed Protocol Operation",
      "section_title": true,
      "ja": "5.詳細なプロトコル動作"
    },
    {
      "indent": 3,
      "text": "This section describes the detailed interactions of senders and receivers participating in a NORM session. A simple synopsis of the protocol operation is given here:",
      "ja": "このセクションでは、NORMセッションに参加して送信者と受信者の詳細な相互作用を説明します。プロトコル操作の簡単な概要をここに与えられます。"
    },
    {
      "indent": 3,
      "text": "1. The sender periodically transmits NORM_CMD(CC) messages as needed to initialize and collect round-trip timing and congestion control feedback from the receiver set.",
      "ja": "初期化と受信機セットから往復タイミングおよび輻輳制御フィードバックを収集するために、必要に応じて1送信者は、定期的NORM_CMD（CC）メッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "2. The sender transmits an ordinal set of NormObjects segmented in the form of NORM_DATA messages labeled with NormTransportIds and logically identified with FEC encoding block numbers and symbol identifiers. When applicable, NORM_INFO messages MAY optionally precede the transmission of data content for NORM transport objects.",
      "ja": "2.送信側はFEC符号化ブロック番号及びシンボル識別子で識別NormTransportIdsと論理で標識NORM_DATAメッセージの形で分割NormObjectsの順序セットを送信します。適用可能な場合、NORM_INFOメッセージは、必要に応じてNORMトランスポートオブジェクトのデータコンテンツの送信に先行してもよいです。"
    },
    {
      "indent": 3,
      "text": "3. As receivers detect missing content from the sender, they initiate repair requests with NORM_NACK messages. The receivers track the sender's most recent objectTransportId::fecPayloadId transmit position and NACK only for content that is ordinally prior to that current transmit position. The receivers schedule random backoff timeouts before generating NORM_NACK messages and wait an appropriate amount of time before repeating the NORM_NACK if their repair request is not satisfied.",
      "ja": "3.受信者が送信者から欠落しているコンテンツを検出すると、それらはNORM_NACKメッセージで修理依頼を開始します。受信機は、送信者の最新objectTransportIdを追跡:: fecPayloadIdはそれだけで現在の送信位置にordinally前にあるコンテンツのために位置し、NACKを送信します。レシーバはNORM_NACKメッセージを生成する前にランダムバックオフタイムアウトのスケジュールを設定し、その修理依頼が満たされない場合NORM_NACKを繰り返す前に、適切な時間を待ちます。"
    },
    {
      "indent": 3,
      "text": "4. The sender aggregates repair requests from the receivers and logically \"rewinds\" its transmit position to send appropriate repair messages. The sender sends repairs for the earliest ordinal transmit position first and maintains this ordinal repair transmission sequence. FEC parity content not previously transmitted for the applicable FEC coding block is used for repair transmissions to the greatest extent possible. If the sender exhausts its available FEC parity content on multiple repair cycles for the same coding block, it resorts to an explicit repair strategy (possibly using parity content) to complete repairs. (The use of explicit repair is an exception in general protocol operation, but the possibility does exist for extreme conditions). The sender immediately assumes transmission of new content once it has sent pending repairs.",
      "ja": "4.送信者の集合体は、受信機からの要求を修復し、論理的に適切な修復メッセージを送信するために、その送信位置を「巻き戻し」。送信者は、最初の早い序の送信位置のための修理を送り、この序修理送信シーケンスを維持しています。以前に該当するFEC符号化ブロックのために送信していないFECパリティのコンテンツは、可能な限り修理伝送に使用されます。送信者が同一の符号化ブロックに対して複数の補修サイクル上の利用可能FECパリティコンテンツを排出する場合は、修理を完了するために、（おそらくパリティコンテンツを使用して）明示的な補修戦略に頼っ。 （明示的な修復の使用は、一般的なプロトコルの動作に例外であるが、可能性は、極端な条件のために存在します）。それは保留中の修理を送信した後、送信者は、すぐに新しいコンテンツの伝送を前提としています。"
    },
    {
      "indent": 3,
      "text": "5. The sender transmits NORM_CMD(FLUSH) messages when it reaches the end of enqueued transmit content and pending repairs. Receivers respond to the NORM_CMD(FLUSH) messages with NORM_NACK transmissions (following the same suppression backoff timeout strategy as for data) if they need further repair.",
      "ja": "前記送信側は、それがエンキュー送信コンテンツとペンディング修理の端部に到達NORM_CMD（FLUSH）メッセージを送信します。彼らはさらに、修理が必要な場合は、レシーバNORM_CMD（FLUSH）（データ用と同じ抑制バックオフタイムアウト戦略以下）NORM_NACK送信のメッセージに応答します。"
    },
    {
      "indent": 3,
      "text": "6. The sender transmissions are subject to rate control limits determined by congestion control mechanisms. In the baseline NORM-CC operation, each sender in a NormSession maintains its own independent congestion control state. Receivers provide congestion control feedback in NORM_NACK and NORM_ACK messages. NORM_ACK feedback for congestion control purposes is governed using a suppression mechanism similar to that for NORM_NACK messages.",
      "ja": "前記送信側の送信は、輻輳制御機構によって決定された制御限界を評価する対象となっています。ベースラインNORM-CC動作において、NormSession内の各送信者は、独自の独立した輻輳制御状態を維持します。レシーバはNORM_NACKとNORM_ACKメッセージに輻輳制御フィードバックを提供します。輻輳制御の目的のためにNORM_ACKフィードバックはNORM_NACKメッセージと同様の抑制機構を使用して管理されています。"
    },
    {
      "indent": 3,
      "text": "While this overall concept is relatively simple, there are details to each of these aspects that need to be addressed for successful, efficient, robust, and scalable NORM protocol operation.",
      "ja": "この全体的な概念は比較的簡単ですが、成功した効率的な、堅牢、かつスケーラブルなNORMプロトコル動作に対処する必要がこれらの側面のそれぞれに詳細があります。"
    },
    {
      "indent": 0,
      "text": "5.1. Sender Initialization and Transmission",
      "section_title": true,
      "ja": "5.1。送信者の初期化と伝送"
    },
    {
      "indent": 3,
      "text": "Upon startup, the NORM sender immediately begins sending NORM_CMD(CC) messages to collect round-trip timing and other information from the potential group. If NORM-CC congestion control operation is enabled, the NORM-CC Rate header extension MUST be included in these messages. Congestion control operation SHALL be observed at all times when not operating using dedicated resources, like in the general Internet. Even if congestion control operation is disabled at the sender, it can be desirable to use the NORM_CMD(CC) messaging to collect feedback from the group using the baseline NORM-CC feedback mechanisms. This proactive feedback collection can be used to establish a GRTT estimate prior to data transmission and potential NACK operation.",
      "ja": "起動時に、NORMの送信者はすぐに潜在的なグループからの往復のタイミングやその他の情報を収集するためにNORM_CMD（CC）メッセージの送信を開始します。 NORM-CC輻輳制御動作が有効になっている場合は、NORM-CC率ヘッダ拡張は、これらのメッセージに含まれなければなりません。輻輳制御動作は、一般的なインターネットのように、専用のリソースを使用して動作していないときに、すべての回で観察されるものとする（SHALL）。輻輳制御動作を送信側で無効にされている場合でも、ベースラインNORM-CCのフィードバック機構を使用してグループからのフィードバックを収集するNORM_CMD（CC）メッセージを使用することが望ましいです。この積極的なフィードバックの収集は、データ伝送および潜在的なNACKの動作に先立っGRTT推定値を確立するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "In some cases, applications might need the sender to also proceed with data transmission immediately. In other cases, the sender might wish to defer data transmission until it has received some feedback or request from the receiver set indicating receivers are indeed present. Note, in some applications (e.g., web push), this indication MAY come out-of-band with respect to the multicast session via other means. As noted, the periodic transmission of NORM_CMD(CC) messages MAY precede actual data transmission in order to have an initial GRTT estimate.",
      "ja": "いくつかのケースでは、アプリケーションは、すぐにデータの伝送を続行する送信者が必要になる場合があります。他の場合には、送信者は、受信機が実際に存在して示す受信機セットからいくつかのフィードバックや要求を受信するまでデータ送信を延期することを望むかもしれません。ノートは、いくつかのアプリケーション（例えば、ウェブプッシュ）に、この指示は、他の手段を介してマルチキャストセッションに対してアウトオブバンド来るかもしれません。述べたように、NORM_CMD（CC）メッセージの周期的な送信は、初期GRTT推定値を得るために実際のデータ伝送に先行してもよいです。"
    },
    {
      "indent": 3,
      "text": "With inclusion of the OPTIONAL NORM FEC Object Transmission Information Header Extension (EXT_FTI), the NORM protocol sender message headers can contain all information necessary to prepare receivers for subsequent reliable reception. This includes FEC coding parameters, the sender NormSegmentSize, and other information. If this header extension is not used, it is presumed receivers have received the FEC Object Transmission Information via other means. Additionally, applications MAY leverage the use of NORM_INFO messages associated with the session data objects in the session to provide application-specific context information for the session and data being transmitted. These mechanisms allow for operation with minimal pre-coordination among the senders and receivers.",
      "ja": "OPTIONAL NORM FECオブジェクト伝送情報ヘッダ拡張（EXT_FTI）を含めて、NORMプロトコル送信者メッセージヘッダは、後続の確実な受信のために受信機を準備するために必要なすべての情報を含むことができます。これは、FEC符号化パラメータ、送信者NormSegmentSize、およびその他の情報が含まれています。このヘッダー拡張を使用しない場合、それが推定される受信機は、他の手段を介してFECオブジェクト伝送情報を受け取っています。また、アプリケーションは、セッションのためのアプリケーション固有のコンテキスト情報を提供するために、セッション中のセッション・データ・オブジェクトに関連付けられたNORM_INFOメッセージの使用を活用するかもしれなくて、データが送信されます。これらの機構は、送信側と受信側の間で最小の事前配位での動作を可能にします。"
    },
    {
      "indent": 3,
      "text": "The NORM sender begins segmenting application-enqueued data into NORM_DATA segments and transmitting it to the group. For objects of type NORM_OBJECT_DATA and NORM_OBJECT_FILE, the segmentation algorithm described in FEC Building Block [RFC5052] is RECOMMENDED. For objects of type NORM_OBJECT_STREAM, segmentation will typically be into uniform FEC coding block sizes, with individual segment sizes controlled by the application. In most cases, the application and NORM implementation SHOULD strive to produce full-sized (NormSegmentSize) segments when possible. The rate of transmission is controlled via congestion control mechanisms or is a fixed rate if desired for closed network operations. The receivers participating in the multicast group provide feedback to the sender as needed. When the sender reaches the end of data it has enqueued for transmission or any pending repairs, it transmits a series of NORM_CMD(FLUSH) messages at a rate of one per 2*GRTT_sender. Similar to the end of each transmitted FEC coding block during transmission, receivers SHALL respond to these NORM_CMD(FLUSH) messages with additional repair requests as needed. A protocol parameter NORM_ROBUST_FACTOR determines the number of flush messages sent. If receivers request repair, the repair is provided, and flushing occurs again at the end of repair transmission. The sender MAY attach an OPTIONAL \"acking_node_list\" to NORM_CMD(FLUSH) containing the NormNodeIds for receivers from which it expects explicit positive acknowledgment of reception. The NORM_CMD(FLUSH) message MAY be also used for this OPTIONAL purpose any time prior to the end of data enqueued for transmission with the NORM_CMD(FLUSH) messages multiplexed with ongoing data transmissions. The OPTIONAL NORM positive acknowledgment procedure is described in Section 5.5.3.",
      "ja": "NORMの送信者はNORM_DATAセグメントにアプリケーション・エンキューデータをセグメント化してグループに送信を開始します。タイプNORM_OBJECT_DATAとNORM_OBJECT_FILE、FECビルディングブロック[RFC5052]に記載のセグメント化アルゴリズムの目的のために推奨されています。型NORM_OBJECT_STREAMの目的のために、セグメンテーションは、典型的には、アプリケーションによって制御される、個々のセグメントサイズで、均一なFEC符号化ブロックサイズになります。ほとんどの場合、アプリケーション及びNORM実装が可能な場合、フルサイズ（NormSegmentSize）セグメントを生成するために努力すべきです。伝送速度は、輻輳制御機構を介して制御されるか、閉じたネットワーク動作のため、所望であれば、固定レートです。必要に応じて、マルチキャストグループに参加する受信機は、送信者にフィードバックを提供します。送信者は、それが送信または保留中の修理のために待ち行列に入れたデータの終わりに到達すると、これは、1つ* GRTT_sender 2あたりの割合でNORM_CMD（FLUSH）一連のメッセージを送信します。必要に応じて、送信時の各送信FEC符号化ブロックの端部と同様に、受信機は追加の修理要求にこれらNORM_CMD（FLUSH）メッセージに応答しなければなりません。プロトコルパラメータNORM_ROBUST_FACTORは、送信されたフラッシュメッセージの数を決定します。受信機は、修理を依頼した場合、修理が設けられており、フラッシングは、修復送信の終了時に再び発生されます。送信者は、それが受信の明示的な肯定応答を期待しているから、受信機のためNormNodeIdsを含むNORM_CMD（FLUSH）するには、オプションの「acking_node_list」をつけてもよいです。 NORM_CMD（FLUSH）メッセージもこのオプションの目的のために、進行中のデータ伝送と多重NORM_CMD（FLUSH）メッセージの伝送のために待ち行列に入れたデータの終わりの前にいつでも使用され得ます。オプションNORM肯定応答手順は、セクション5.5.3に記載されています。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Object Segmentation Algorithm",
      "section_title": true,
      "ja": "5.1.1。セグメンテーションアルゴリズムオブジェクト"
    },
    {
      "indent": 3,
      "text": "NORM senders and receivers MUST use a common algorithm for logically segmenting transport data into FEC encoding blocks and symbols so appropriate NACKs can be constructed to request repair of missing data. NORM FEC coding blocks are comprised of multi-byte symbols (segments) transmitted in the payload of NORM_DATA messages. Each NORM_DATA message will contain one or more source or encoding symbols identified by the \"fec_payload_id\" field, and the NormSegmentSize sender parameter defines the maximum size (in bytes) of the \"payload_data\" field containing the content (a \"segment\"). The FEC encoding type and associated parameters govern the source block size (number of source symbols per coding block, etc.). NORM senders and receivers use these FEC parameters, along with the NormSegmentSize and transport object size to compute the source block structure for transport objects. These parameters are provided in the FEC Object Transmission Information for each object. The block partitioning algorithm described in the FEC Building Block [RFC5052] document is RECOMMENDED for use in computing a source block structure such that all source blocks are as close to being equal length as possible. This helps avoid the performance disadvantages of \"short\" FEC blocks. Note that this algorithm applies only to the statically sized NORM_OBJECT_DATA and NORM_OBJECT_FILE transport object types where the object size is fixed and predetermined. For NORM_OBJECT_STREAM objects, the object is segmented according to the maximum source block length given in the FEC Transmission Information, unless the FEC Payload ID indicates an alternative size for a given block.",
      "ja": "NORMの送信側と受信側は、論理的にそう適切なのNACKが欠落データの修復を依頼するように構築することができるFEC符号化ブロックとシンボルへの輸送データをセグメント化するための共通のアルゴリズムを使用する必要があります。 NORM FEC符号化ブロックがNORM_DATAメッセージのペイロードで送信マルチバイトシンボル（セグメント）から構成されています。各NORM_DATAメッセージは「fec_payload_id」フィールドによって識別される1つ以上のソースまたは符号化シンボルを含むであろう、とNormSegmentSize送信者パラメータは、コンテンツを含む「payload_data」フィールド（「セグメント」）の最大サイズ（バイト単位）を定義します。 FEC符号化タイプおよび関連するパラメータは、ソース・ブロック・サイズ（符号化ブロック当たりのソースシンボルの数、など）を支配します。 NORMの送信側と受信側は、トランスポートオブジェクトのソースブロック構造を計算するためにNormSegmentSize搬送オブジェクトのサイズと共に、これらのFECのパラメータを使用します。これらのパラメータは、各オブジェクトのFECオブジェクト伝送情報で提供されています。 FECビルディングブロック[RFC5052]の文書に記載されたブロック分割アルゴリズムは、すべてのソースブロックができるだけ等しい長さに近くなるように、ソースブロック構造を計算する際に使用するために推奨されます。これは、「短い」FECブロックのパフォーマンスの欠点を回避するのに役立ちます。このアルゴリズムは、静的オブジェクトのサイズが固定され、予め定められてNORM_OBJECT_DATAとNORM_OBJECT_FILEトランスポート・オブジェクト・タイプの大きさのみに適用されます。 FECペイロードIDは、所与のブロックのための代替的なサイズを示さない限りNORM_OBJECT_STREAMオブジェクトの場合、オブジェクトは、FEC送信情報で指定された最大ソースブロック長に応じて分割されます。"
    },
    {
      "indent": 0,
      "text": "5.2. Receiver Initialization and Reception",
      "section_title": true,
      "ja": "5.2。受信機の初期化とレセプション"
    },
    {
      "indent": 3,
      "text": "For typical operation, NORM receivers will join a specified multicast group and listen on a specific port number for sender transmissions. As the NORM receiver receives NORM_DATA messages, it will establish buffering state and provide content to its application as appropriate for the given data type. The NORM protocol allows receivers to join and leave the group at will, although some applications might need receivers to be members of the group prior to start of data transmission. Thus, different NORM applications MAY use different policies to constrain the impact of new receivers joining the group in the middle of a session. For example, a useful implementation policy is for new receivers joining the group to limit or avoid repair requests for transport objects already in progress. The NORM sender implementation MAY impose additional constraints to limit the ability of receivers to disrupt reliable multicast performance by joining, leaving, and rejoining the group often. Different receiver \"join policies\" might be appropriate for different applications and/or scenarios. For general purpose operation, a default policy where receivers are allowed to request repair only for coding blocks with a NormTransportId and FEC coding block number greater than or equal to the first non-repair NORM_DATA or NORM_INFO message received upon joining the group is RECOMMENDED. For objects of type NORM_OBJECT_STREAM, it is RECOMMENDED the join policy constrain receivers to begin reliable reception at the current FEC coding block for which non-repair content is received.",
      "ja": "典型的な動作のために、NORM受信機は、指定されたマルチキャストグループに参加すると、送信者の送信のための特定のポート番号に聞きます。 NORM受信機がNORM_DATAメッセージを受信すると、それはバッファリング状態を確立して、所与のデータ・タイプに応じて、そのアプリケーションにコンテンツを提供するであろう。一部のアプリケーションは、データ送信の開始に先立って、グループのメンバーであることを受信機が必要になる場合がありますが、NORMプロトコルは、受信機は自由にグループに参加して残すことができます。このように、異なるNORMアプリケーションがセッションの途中でグループに参加し、新たな受信機の影響を制限するために異なるポリシーを使用するかもしれません。例えば、有用な実施方針を制限したり、すでに進行中のトランスポート・オブジェクトのための修理依頼を回避するためにグループに参加する新しい受信機のためです。 NORMの送信側の実装では、参加残し、多くの場合、グループを再結合することにより、信頼性の高いマルチキャストパフォーマンスを破壊する受信機の能力を制限するために追加の制約を課すことができます。異なる受信機は、異なるアプリケーションおよび/またはシナリオに適切であるかもしれない「方針を参加します」。汎用操作、受信機のみNormTransportId有するブロックよりも大きいか又は最初の非修復NORM_DATAに等しい又はFEC符号化ブロックの数を符号化するために修理を依頼することが許可されているデフォルトのポリシーNORM_INFOメッセージがグループに加わる際に受信するための推奨されます。型NORM_OBJECT_STREAMの目的のために、非修復コンテンツが受信された現在のFEC符号化ブロックにおいて確実な受信を開始する参加ポリシー制約受信機を推奨しています。"
    },
    {
      "indent": 3,
      "text": "In some deployments, different multicast receivers might have differing quality of network connectivity. Some receivers may suffer significantly poorer performance with very limited goodput due to low connection rate or substantial packet loss. Similar to the \"join policies\" described above, a NORM sender implementation MAY choose to enforce different \"service policies\" to perhaps exclude exceptionally poorly performing (or otherwise badly behaving) receivers from the group. The sender implementation could choose to ignore NACKs from such receivers and/or force advancement of its logical \"repair window\" (i.e., enforcing a minimal level of service) and use the NORM_CMD(SQUELCH) message to advise those poor performers of its advance. Note in some cases, the application may need to support the \"weakest member\" regardless of the time needed to achieve reliable delivery. When implemented, the protocol instantiation SHOULD expose controls to the set of \"join\" and/or \"service\" policies available to support the needs of different applications.",
      "ja": "いくつかの展開では、異なるマルチキャストレシーバは、ネットワーク接続の品質が異なる可能性があります。いくつかの受信機は、低接続速度や大幅なパケット損失に起因する非常に限られたグッドプットと大幅に劣ったパフォーマンスを被る可能性があります。上記の「参加の方針」と同様に、NORMの送信側の実装はおそらく、グループからの受信機、非常にパフォーマンスの低い（あるいは悪い行動）を除外するために、異なる「サービスポリシー」を施行するために選ぶかもしれません。送信側の実装は、受信機からNACKを無視することを選択および/またはその論理的な「修復ウィンドウ」の前進を強制する（すなわち、サービスの最小レベルを強制）およびその事前のもの貧しいパフォーマーを助言するNORM_CMD（SQUELCH）メッセージを使用することができます。いくつかのケースでは注意してください、アプリケーションに関係なく、信頼性の高い配信を実現するために必要な時間の「最も弱いメンバー」をサポートする必要があるかもしれません。実装された場合、プロトコルのインスタンス化は、さまざまなアプリケーションのニーズをサポートするために利用できる「参加」および/または「サービス」ポリシーのセットにコントロールを公開する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Receiver NACK Procedure",
      "section_title": true,
      "ja": "5.3。レシーバNACK手順"
    },
    {
      "indent": 3,
      "text": "When the receiver detects it is missing data from a sender's NORM transmissions, it initiates its NACKing procedure. The NACKing procedure SHALL be initiated only at FEC coding block boundaries, NormObject boundaries, upon receipt of a NORM_CMD(FLUSH) message, or upon an \"inactivity\" timeout when NORM_DATA or NORM_INFO transmissions are no longer received from a previously active sender. The RECOMMENDED value of such an inactivity timeout is:",
      "ja": "受信機は、それが送信者のNORM送信からデータが欠落している検出すると、そのNACKing手順を開始します。 NACKing手順のみFEC符号化ブロック境界で開始されるべきであり、NormObject境界、NORM_CMD（FLUSH）メッセージを受信すると、又はNORM_DATAまたはNORM_INFO送信がもはや以前にアクティブ送信機から受信される「非アクティブ」タイムアウト時。そのような無活動タイムアウトの推奨値は次のとおりです。"
    },
    {
      "indent": 12,
      "text": "T_inactivity = NORM_ROBUST_FACTOR * 2 * GRTT_sender",
      "ja": "T_inactivity = NORM_ROBUST_FACTOR * 2 * GRTT_sender"
    },
    {
      "indent": 3,
      "text": "where the GRTT_sender value corresponds to the GRTT estimate advertised in the \"grtt\" field of NORM sender messages. A minimum T_inactivity value of 1 second is RECOMMENDED. The NORM receiver SHOULD reset this inactivity timer and repeat NACK initiation upon timeout for up to NORM_ROBUST_FACTOR times or more depending upon the application's need for persistence by its receivers. It is also important receivers rescale the T_inactivity timeout as the sender's advertised GRTT changes.",
      "ja": "GRTT_sender値はNORMの送信者のメッセージの「GRTT」フィールドで広告GRTT推定値に相当します。 1秒の最小T_inactivity値が推奨されます。 NORM受信機は、この非アクティブタイマーをリセットし、その受信機によって持続性のために、アプリケーションのニーズに応じて、NORM_ROBUST_FACTOR回まで以上のタイムアウト時にNACK開始を繰り返す必要があります。受信機は、送信者の広告を出してGRTTの変化としてT_inactivityタイムアウトを再スケールも重要です。"
    },
    {
      "indent": 3,
      "text": "The NACKing procedure begins with a random backoff timeout. The duration of the backoff timeout is chosen using the \"RandomBackoff\" algorithm described in the Multicast NACK Building Block [RFC5401] document using (K_sender*GRTT_sender) for the maxTime parameter and the sender advertised group size (GSIZE_sender) as the groupSize parameter. NORM senders provide values for GRTT_sender, K_sender and GSIZE_sender via the \"grtt\", \"backoff\", and \"gsize\" fields of transmitted messages. The GRTT_sender value is determined by the sender based on feedback it has received from the group while the K_sender and GSIZE_sender values can be determined by application requirements and expectations or ancillary information. The backoff factor K_sender MUST be greater than one to provide for effective feedback suppression. A value of K_sender = 4 is RECOMMENDED for the Any Source Multicast (ASM) model, while a value of K_sender = 6 is RECOMMENDED for Single Source Multicast (SSM) operation.",
      "ja": "NACKing手順は、ランダムバックオフタイムアウトで始まります。バックオフタイムアウトの持続時間はMAXTIMEパラメータとGROUPSIZEパラメータとして送信者アドバタイズグループサイズ（GSIZE_sender）のために使用してマルチキャストNACKビルディングブロック[RFC5401]文書（K_sender * GRTT_sender）に記載された「RandomBackoff」アルゴリズムを使用して選択されます。 NORMの送信者は、「GRTT」、「バックオフ」、および送信されたメッセージの「GSIZE」フィールドを経てGRTT_sender、K_senderとGSIZE_senderのための値を提供します。 GRTT_sender値はK_senderとGSIZE_sender値は、アプリケーションの要件と期待または補助情報によって決定することができるが、それはグループから受信したフィードバックに基づいて送信者によって決定されます。バックオフ因子K_senderは、効果的なフィードバック抑制のために提供するものよりも大きくなければなりません。 K_sender = 6の値はシングルソースマルチキャスト（SSM）動作のために推奨されている間K_sender = 4の値は、任意のソースマルチキャスト（ASM）モデルに推奨されます。"
    },
    {
      "indent": 3,
      "text": "Thus: T_backoff = RandomBackoff(K_sender*GRTT_sender, GSIZE_sender)",
      "ja": "したがって：T_backoff = RandomBackoff（K_sender * GRTT_sender、GSIZE_sender）"
    },
    {
      "indent": 3,
      "text": "To avoid the possibility of NACK implosion in the case of sender or network failure during SSM operation, the receiver SHALL automatically suppress its NACK and immediately enter the \"holdoff\" period described below when T_backoff is greater than (K_sender-1)*GRTT_sender. Otherwise, the backoff period is entered and the receiver MUST accumulate external pending repair state from NORM_NACK messages and NORM_CMD(REPAIR_ADV) messages received. At the end of the backoff time, the receiver SHALL generate a NORM_NACK message only if the following conditions are met:",
      "ja": "SSM動作中に送信者またはネットワークに障害が発生した場合にはNACK爆縮の可能性を回避するために、受信機は自動的にNACKを抑制し、直ちにT_backoffは（K_sender-1）よりも大きい場合に後述する「ホールドオフ」期間に入るものと* GRTT_sender。そうでなければ、バックオフ期間が入力され、受信機はNORM_NACKメッセージから外部ペンディング修復状態を蓄積しなければならないとNORM_CMD（REPAIR_ADV）メッセージを受信しました。バックオフ時間の終わりに、受信機は、以下の条件が満たされる場合にのみNORM_NACKメッセージを生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "1. The sender's current transmit position (in terms of objectTransportId::fecPayloadId) exceeds the earliest repair position of the receiver.",
      "ja": "1.（objectTransportId :: fecPayloadIdの点で）送信者の現在の送信位置は、受信機の初期修復位置を越えます。"
    },
    {
      "indent": 3,
      "text": "2. The repair state accumulated from NORM_NACK and NORM_CMD(REPAIR_ADV) messages does not equal or supersede the receiver's repair needs up to the sender transmission position at the time the NACK procedure (backoff timeout) was initiated.",
      "ja": "2. NORM_NACKとNORM_CMD（REPAIR_ADV）メッセージからの累積修復状態が等しくない、または受信機の修理がNACK手順（バックオフタイムアウト）が開始された時点で送信元送信位置まで必要代わります。"
    },
    {
      "indent": 3,
      "text": "If these conditions are met, the receiver immediately generates a NORM_NACK message when the backoff timeout expires. Otherwise, the receiver's NACK is considered to be \"suppressed\" and the message is not sent. At this time, the receiver begins a \"holdoff\" period during which it constrains itself to not re-initiate the NACKing process. The purpose of this timeout is to allow the sender worst-case time to respond to the repair needs before the receiver requests repair again. The value of this \"holdoff\" timeout (T_rcvrHoldoff) as described in [RFC5401] is: T_rcvrHoldoff =(K_sender+2)*GRTT_sender",
      "ja": "これらの条件が満たされている場合、バックオフタイムアウトが満了すると、受信機は直ちにNORM_NACKメッセージを生成します。それ以外の場合は、受信者のNACKは「抑制」されると考えられ、メッセージは送信されません。このとき、受信機は、それがNACKingプロセスを再開始しないように自身を制限その間「ホールドオフ」期間を開始します。このタイムアウトの目的は、受信側の要求は再び修復する前に、送信者、最悪の場合の時間は修理ニーズに対応できるようにすることです。 [RFC5401]に記載されているように、この \"ホールドオフ\" タイムアウト（T_rcvrHoldoff）の値である：T_rcvrHoldoff =（K_sender + 2）* GRTT_sender"
    },
    {
      "indent": 3,
      "text": "The NORM_NACK message contains repair request content beginning with the lowest ordinal repair position of the receiver up through the coding block prior to the most recently heard ordinal transmission position for the sender. If the size of the NORM_NACK content exceeds the sender's NormSegmentSize, the NACK content is truncated so the receiver only generates a single NORM_NACK message per NACK cycle for a given sender. In summary, a single NACK message is generated containing the receiver's lowest ordinal repair needs.",
      "ja": "NORM_NACKメッセージは送信者のための最も最近聞い序送信位置に先立って、コーディングブロックを通じて受信機までの最低の順序修理位置から始まる修理依頼の内容が含まれています。 NORM_NACKコンテンツのサイズが、送信者のNormSegmentSizeを超えた場合、受信機のみ与えられた送信者NACKサイクル当たり単一NORM_NACKメッセージを生成するように、NACK含量が切り捨てられます。要約すると、単一のNACKメッセージは、受信者の最小順序修理の必要性を含むが生成されます。"
    },
    {
      "indent": 3,
      "text": "For each partially received FEC coding block requiring repair, the receiver SHALL, on its FIRST repair attempt for the block, request the parity portion of the FEC coding block beginning with the lowest ordinal parity \"encoding_symbol_id\" (i.e., \"encoding_symbol_id\" = \"source_block_len\") and request the number of FEC symbols corresponding to its data segment erasure count for the block. On subsequent repair cycles for the same coding block, the receiver SHALL request only those repair symbols from the first set it has not yet received up to the remaining erasure count for that applicable coding block. Note the sender might have transmitted other different, additional parity segments for other receivers that could also be used to satisfy the local receiver's erasure-filling needs. In the case where the erasure count for a partially received FEC coding block exceeds the maximum number of parity symbols available from the sender for the block (as indicated by the NORM_DATA \"fec_num_parity\" field), the receiver SHALL request all available parity segments plus the ordinally highest missing data segments needed to satisfy its total erasure needs for the block. The goal of this strategy is for the overall receiver set to request a lowest common denominator set of repair symbols for a given FEC coding block. This allows the sender to construct the most efficient repair transmission segment set and enables effective NACK suppression among the receivers even with uncorrelated packet loss. This approach also does not demand synchronization among the receiver set in their repair requests for the sender.",
      "ja": "各部分的に受信されたFEC符号化ブロックが必要な修理のために、受信機は、ブロックの最初の修復の試みで、最も低い順序のパリティ「encoding_symbol_id」（すなわち、「encoding_symbol_id」=「source_block_len始まるFEC符号化ブロックのパリティ部分を求めるもの「）ブロックのためにそのデータセグメント消去回数に対応するFEC記号の数を要求します。同じ符号化ブロックに対する後続の修復サイクルで、受信機は、それがまだその該当コーディングブロックの残りの消去回数まで受信していない第一のセットからのみリペアシンボルを求めるもの。送信者は、ローカル受信者の消去充填ニーズを満たすために使用することができ、他の受信機のため、他の異なる、追加のパリティセグメントを送信している場合があります。部分的に受信されたFEC符号化ブロックの消去カウントが（NORM_DATA「fec_num_parity」フィールドによって示されるように）ブロックのため送信者から入手可能なパリティシンボルの最大数を超えた場合に、受信機は、利用可能なすべてのパリティ・セグメントを要求するものとプラスordinally最高のブロックのためにその総消去ニーズを満たすために必要なデータセグメントを欠落しています。この戦略の目標は、与えられたFEC符号化ブロックについてリペアシンボルの最小公分母のセットを要求するように設定され、全​​体の受信機のためのものです。これは、送信者が最も効率的な修復の送信セグメントセットを構築することができ、さらに無相関パケット損失と受信機の間で効果的なNACKを抑制することができます。このアプローチでは、送信者のための彼らの修理依頼に設定された受信機間の同期を要求しません。"
    },
    {
      "indent": 3,
      "text": "For FEC coding blocks or NormObjects missed in their entirety, the NORM receiver constructs repair requests with NORM_NACK_BLOCK or NORM_NACK_OBJECT flags set as appropriate. The request for retransmission of NORM_INFO is accomplished by setting the NORM_NACK_INFO flag in a corresponding repair request.",
      "ja": "その全体を逃したFEC符号化ブロックまたはNormObjectsため、NORM受信機は適宜設定NORM_NACK_BLOCK又はNORM_NACK_OBJECTフラグを修復要求を構築します。 NORM_INFOの再送要求は、対応する修理依頼にNORM_NACK_INFOフラグを設定することによって達成されます。"
    },
    {
      "indent": 0,
      "text": "5.4. Sender NACK Processing and Response",
      "section_title": true,
      "ja": "5.4。送信者NACK処理と応答"
    },
    {
      "indent": 3,
      "text": "The principal goal of the sender is to make forward progress in the transmission of data its application has enqueued. However, the sender will need to occasionally \"rewind\" its logical transmission point to satisfy the repair needs of receivers who have NACKed. Aggregation of multiple NACKs is used to determine an optimal repair strategy when a NACK event occurs. Since receivers initiate the NACK process on coding block or object boundaries, there is some loose degree of synchronization of the repair process even when receivers experience uncorrelated data loss.",
      "ja": "送信者の主な目標は、そのアプリケーションがキューに入れられたデータの伝送に前進を作ることです。ただし、送信者は時折、NACKされている受信機の修理のニーズを満たすために、その論理的な送信点を「巻き戻し」にする必要があります。複数NACKの凝集がNACKイベントが発生したときに、最適な修復戦略を決定するために使用されます。受信機は、ブロックまたはオブジェクトの境界をコーディングにNACKプロセスを開始するので、受信機は、無相関のデータの損失が発生するにも修復プロセスの同期のいくつかの緩い度があります。"
    },
    {
      "indent": 0,
      "text": "5.4.1. Sender Repair State Aggregation",
      "section_title": true,
      "ja": "5.4.1。送信者の修復状態集計"
    },
    {
      "indent": 3,
      "text": "When a sender is in its normal state of transmitting new data and receives a NACK, it begins a procedure to accumulate NACK repair state from NORM_NACK messages before beginning repair transmissions. Note that this period of aggregating repair state does NOT interfere with its ongoing transmission of new data.",
      "ja": "送信者が新しいデータを送信し、その正常な状態にあり、NACKを受信すると、修理の送信を開始する前にNORM_NACKメッセージからNACK修復状態を蓄積するための手順を開始します。修理状態を集約のこの期間は、新たなデータの継続的な伝達に干渉しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "As described in [RFC5401], the period of time during which the sender aggregates NORM_NACK messages is equal to:",
      "ja": "[RFC5401]に記載されているように、送信者凝集体がメッセージをNORM_NACKする期間は、に等しいです。"
    },
    {
      "indent": 15,
      "text": "T_sndrAggregate = (K_sender + 1) * GRTT_sender",
      "ja": "T_sndrAggregate =（K_sender + 1）* GRTT_sender"
    },
    {
      "indent": 3,
      "text": "where K_sender is the backoff scaling value advertised to the receivers, and GRTT_sender is the sender's current estimate of the group's greatest round-trip time. Note, for NORM unicast sessions, the T_sndrAggregate time can be set to ZERO since there is only one receiver. Similarly, the K_sender value SHOULD be set to ZERO for NORM unicast sessions to minimize repair latency.",
      "ja": "K_senderは、受信機にアドバタイズバックオフスケーリング値であり、そしてGRTT_senderは、グループの最大のラウンドトリップ時間の送信者の現在の推定値です。唯一つの受信機があるので注意が、NORMユニキャストセッションのために、T_sndrAggregate時間をゼロに設定することができます。同様に、K_sender値は、修復の待ち時間を最小限に抑えるためにNORMユニキャストセッションのためにゼロに設定されるべきです。"
    },
    {
      "indent": 3,
      "text": "When this period ends, the sender \"rewinds\" by incorporating the accumulated repair state into its pending transmission state and begins transmitting repair messages. After pending repair transmissions are completed, the sender continues with new transmissions of any enqueued data. Also, at this point in time, the sender begins a \"holdoff\" timeout during which time the sender constrains itself from initiating a new repair aggregation cycle, even if NORM_NACK messages arrive. As described in [RFC5401], the value of this sender \"holdoff\" period is:",
      "ja": "場合は、この期間が終了すると、送信者は、その保留中の送信状態に蓄積修理状態を組み込むことによって、「巻き戻し」と修理メッセージの送信を開始します。保留中の修理送信が完了した後、送信者は、任意のキューに入れられたデータの新しい送信を続行します。また、この時点で、送信者はNORM_NACKメッセージが到着しても、送信者が新しい修理集約サイクルを開始するから自分自身を拘束し、その間に「ホールドオフ」タイムアウトを開始します。 [RFC5401]に記載されているように、この送信者「ホールドオフ」期間の値です。"
    },
    {
      "indent": 21,
      "text": "T_sndrHoldoff = (1 * GRTT_sender)",
      "ja": "T_sndrHoldoff =（1 * GRTT_sender）"
    },
    {
      "indent": 3,
      "text": "If additional NORM_NACK messages are received during this sender \"holdoff\" period, the sender will immediately incorporate these late-arriving messages into its pending transmission state if, and only if, the NACK content is ordinally greater than the sender's current transmission position. This \"holdoff\" time allows worst-case time for the sender to propagate its current transmission sequence position to the group, thus avoiding redundant repair transmissions. After the holdoff timeout expires, a new NACK accumulation period can be started (upon arrival of a NACK) in concert with the pending repair and new data transmission. Recall receivers are not to initiate the NACK repair process until the sender's logical transmission position exceeds the lowest ordinal position of their repair needs. With the new NACK aggregation period, the sender repeats the same process of incorporating accumulated repair state into its transmission plan and subsequently \"rewinding\" to transmit the lowest ordinal repair data when the aggregation period expires. Again, this is conducted in concert with ongoing new data and/or pending repair transmissions.",
      "ja": "追加NORM_NACKメッセージは、この送信者「ホールドオフ」期間中に受信された場合、送信者はすぐにその保留中の送信状態の場合にこれらの後期到着したメッセージを組み込む予定、と場合にのみ、NACKの内容は、送信者の現在の送信位置よりもordinally大きいです。この「ホールドオフ」の時間は、このように冗長救済送信を避け、グループに現在の送信シーケンス位置を伝播する送信者のための最悪の場合の時間を確保できます。ホールドオフタイムアウトが満了した後、新しいNACK蓄積期間は、保留中の修理や新たなデータ伝送と協力して（NACKの到着時）に開始することができます。リコール受信機は、送信者の論理的な伝送位置は、その修理ニーズの最低順序位置を超えるまでNACK修復プロセスを開始することはありません。新しいNACKの集計期間で、送信者は、その透過計画に蓄積され、修復状態を組み込み、その後集計期間が満了したときに、最低順序リペアデータを送信するために、「巻き戻し」の同様の処理を繰り返します。繰り返しますが、これは現在進行中の新しいデータおよび/または保留中の修理トランスミッションと協調して実施されます。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Sender FEC Repair Transmission Strategy",
      "section_title": true,
      "ja": "5.4.2。送信者FECリペア伝送戦略"
    },
    {
      "indent": 3,
      "text": "The NORM sender SHOULD leverage transmission of FEC parity content for repair to the greatest extent possible. Recall that receivers use a strategy to request a lowest common denominator of explicit repair (including parity content) in the formation of their NORM_NACK messages. Before falling back to explicitly satisfying different receivers' repair needs, the sender can make use of the general erasure-filling capability of FEC-generated parity segments. The sender can determine the maximum erasure-filling needs for individual FEC coding blocks from the NORM_NACK messages received during the repair aggregation period. Then, if the sender has a sufficient number (less than or equal to the maximum erasure count) of previously unsent parity segments available for the applicable coding blocks, the sender can transmit these in lieu of the specific packets the receiver set has requested. The sender SHOULD NOT resort to explicit transmission of the receiver set's repair needs until after exhausting its supply of \"fresh\" (unsent) parity segments for a given coding block. In general, if a sufficiently powerful FEC code is used, the need for explicit repair will be an exception, and the fulfillment of reliable multicast can be accomplished quite efficiently. However, the ability to resort to explicit repair allows the protocol to be continue to operate under even very extreme circumstances.",
      "ja": "NORMの送信者は、可能な限り修復のためのFECパリティコンテンツの伝送を活用すべきです。受信機はそのNORM_NACKメッセージの形成（パリティコンテンツを含む）明示的な修理の最小公分母を要求するための戦略を使用することを思い出してください。明示的に別の受信者の修理のニーズを満たすにフォールバックする前に、送信者は、FEC-生成したパリティセグメントの一般的な消去充填機能を利用することができます。送信者は、修理集計期間中に受信NORM_NACKメッセージからの個々のFEC符号化ブロックの最大消去充填ニーズを決定することができます。送信者は、十分な数（以下、最大消去回数に等しい）該当コーディングブロックのために利用可能な以前に未送信パリティセグメントを有する場合、送信者は受信セットが要求した特定のパケットの代わりにこれらを送信することができます。送信者は、与えられたブロック符号化のための「新鮮な」（未）パリティセグメントのその供給を排出後まで受信機セットの修理ニーズの明示的な伝送に頼るべきではありません。十分に強力なFECコードが使用されている場合、一般的には、明示的な修理の必要性は例外となり、かつ信頼性の高いマルチキャストの実現は非常に効率的に達成することができます。しかし、明示的な修理に頼るする機能は、プロトコルにも非常に極端な状況下で動作し続けることを可能にします。"
    },
    {
      "indent": 3,
      "text": "NORM_DATA messages sent as repair transmissions SHALL be flagged with the NORM_FLAG_REPAIR flag. This allows receivers to obey any policies limiting new receivers from joining the reliable transmission when only repair transmissions have been received. Additionally, the sender SHOULD flag NORM_DATA transmissions sent as explicit repair with the NORM_FLAG_EXPLICIT flag.",
      "ja": "修理トランスミッションとして送らNORM_DATAメッセージがNORM_FLAG_REPAIRフラグとフラグが設定されるものとします。これは、受信機が唯一の修理送信が受信された信頼性の高い伝送に参加する新しい受信機を制限するすべてのポリシーを遵守することができます。また、送信者はフラグNORM_DATA送信はNORM_FLAG_EXPLICITフラグを明示的な補修として送信すべきです。"
    },
    {
      "indent": 3,
      "text": "Although NORM end system receivers do not make use of the NORM_FLAG_EXPLICIT flag, this message transmission status could be leveraged by intermediate systems wishing to \"assist\" NORM protocol performance. If such systems are properly positioned with respect to reciprocal reverse-path multicast routing, they need to sub-cast only a sufficient count of non-explicit parity repairs to satisfy a multicast routing sub-tree's erasure-filling needs for a given FEC coding block. When the sender has resorted to explicit repair, then the intermediate systems SHOULD sub-cast all of the explicit repair packets to those portions of the routing tree still requiring repair for a given coding block. Note the intermediate systems will need to conduct repair state accumulation for sub-routes in a manner similar to the sender's repair state accumulation in order to have sufficient information to perform the sub-casting. Additionally, the intermediate systems could perform NORM_NACK suppression/aggregation as it conducts this repair state accumulation for NORM repair cycles. The details of this type of operation are beyond the scope of this document, but this information is provided for possible future consideration.",
      "ja": "NORMエンドシステム受信機がNORM_FLAG_EXPLICITフラグを利用しないが、このメッセージの伝送状態は、NORMプロトコルのパフォーマンスを「支援」することを望む中間システムによって活用することができます。このようなシステムが適切に相互のリバースパスマルチキャストルーティングに対して位置決めされている場合、彼らはする必要があり、サブキャスト与えられたFECブロック符号化のためのマルチキャストルーティングサブツリーの消去充填ニーズを満たすために、非明示的なパリティ修理の十分なだけの数。送信者は、明示的な修復に頼った場合、その後の中間システムが依然として所定の符号化ブロックの修復を必要とするルーティングツリーの部分に明示的な修復パケットの全サブキャストすべきです。なお、中間システムは、サブキャストを実行するのに十分な情報を持っているために、送信者の修理状態の蓄積と同様に、サブルートの補修状態の蓄積を実施する必要があります。それはNORM修理サイクルのこの修理状態の蓄積を行うように加え、中間システムはNORM_NACK抑制/集約を実行することができます。このタイプの動作の詳細については、このドキュメントの範囲を超えていますが、この情報は将来の検討のために提供されます。"
    },
    {
      "indent": 0,
      "text": "5.4.3. Sender NORM_CMD(SQUELCH) Generation",
      "section_title": true,
      "ja": "5.4.3。送信者NORM_CMD（SQUELCH）の生成"
    },
    {
      "indent": 3,
      "text": "If the sender receives a NORM_NACK message for repair of data it is no longer supporting, the sender generates a NORM_CMD(SQUELCH) message to advertise its repair window and squelch any receivers from additional NACKing of invalid data. The transmission rate of NORM_CMD(SQUELCH) messages is limited to once per 2*GRTT_sender. The \"invalid_object_list\" (if applicable) of the NORM_CMD(SQUELCH) message SHALL begin with the lowest \"object_transport_id\" from the invalid NORM_NACK messages received since the last NORM_CMD(SQUELCH) transmission. The list includes as many lower ordinal invalid \"object_transport_ids\" that can fit for the NORM_CMD(SQUELCH) payload size to less than or equal to the sender's NormSegmentSize parameter.",
      "ja": "送信者は、それはもはやサポートされたデータの修復のためNORM_NACKメッセージを受信した場合、送信者は、その修理・ウィンドウを宣伝し、無効なデータの追加NACKingから任意の受信機をスケルチするNORM_CMD（SQUELCH）メッセージを生成します。 NORM_CMD（SQUELCH）メッセージの伝送速度がGRTT_sender *一度2あたりに制限されます。 NORM_CMD（SQUELCH）メッセージの「invalid_object_list」は（該当する場合）最後NORM_CMD（SQUELCH）送信から受信した無効NORM_NACKメッセージから最下位「object_transport_id」で始まるものとします。リストには、送信者のNormSegmentSizeパラメータ以下にNORM_CMD（SQUELCH）ペイロードサイズに合うことができるなど、多くの低序無効「object_transport_ids」が含まれます。"
    },
    {
      "indent": 0,
      "text": "5.4.4. Sender NORM_CMD(REPAIR_ADV) Generation",
      "section_title": true,
      "ja": "5.4.4。送信者NORM_CMD（REPAIR_ADV）の生成"
    },
    {
      "indent": 3,
      "text": "When a NORM sender receives NORM_NACK messages from receivers via unicast transmission, it uses NORM_CMD(REPAIR_ADV) messages to advertise its accumulated repair state to the receiver set since the receiver set is not directly sharing their repair needs via multicast communication. A NORM sender implementation MAY use a separate port number from the NormSession port number as the source port for its transmissions. Thus, NORM receivers can direct any unicast feedback messages to this separate sender port number, distinct from the NORM session (or destination) port number. Then, the NORM sender implementation can discriminate unicast feedback messages from multicast feedback messages when there is a mix of multicast and unicast feedback receivers. The NORM_CMD(REPAIR_ADV) message is multicast to the receiver set by the sender. The payload portion of this message has content in the same format as the NORM_NACK receiver message payload. Receivers are then able to perform feedback suppression in the same manner as with NORM_NACK messages directly received from other receivers. Note that the sender does not merely retransmit NACK content it receives, but instead transmits a representation of its aggregated repair state. The transmission of NORM_CMD(REPAIR_ADV) messages is subject to the sender transmit rate limit and NormSegmentSize limitation. When the NORM_CMD(REPAIR_ADV) message is of maximum size (as indicated by the flag NORM_REPAIR_ADV_FLAG_LIMIT), receivers SHALL consider the maximum ordinal transmission position value embedded in the message as the senders current transmission position and implicitly suppress requests for ordinally higher repair. For congestion control operation, the sender will also need to provide any information needed so dynamic congestion control feedback can be suppressed among receivers. This document specifies the NORM-CC Feedback Header Extension that is applied for baseline NORM-CC operation. If other congestion control mechanisms are used within a NORM implementation, other header extensions MAY be defined. Whatever content format is used for this purpose SHOULD ensure that maximum possible suppression state is conveyed to the receiver set.",
      "ja": "NORM送信者は、ユニキャスト送信を介して受信機からNORM_NACKメッセージを受信すると、受信機セットは直接マルチキャスト通信を介して、それらの修復ニーズを共有していないので、設定受信機にその蓄積修復状態をアドバタイズするNORM_CMD（REPAIR_ADV）メッセージを使用します。 NORMの送信側の実装は、その伝送のための送信元ポートとしてNormSessionポート番号とは別のポート番号を使用するかもしれません。したがって、NORM受信機はNORMセッション（または宛先）とは異なる、この別個送信元ポート番号、ポート番号に任意のユニキャストフィードバックメッセージを向けることができます。マルチキャストとユニキャストのフィードバック受信機の混在がある場合に続いて、NORMの送信側の実装では、マルチキャストフィードバックメッセージからのユニキャストフィードバックメッセージを識別することができます。 NORM_CMD（REPAIR_ADV）メッセージは、送信者によって設定された受信機にマルチキャストされます。このメッセージのペイロード部分はNORM_NACK受信メッセージペイロードと同じフォーマットでコンテンツを有しています。受信機は、直接他の受信機から受信NORM_NACKメッセージと同様に、フィードバック抑制を行うことが可能です。送信者は、単に、受信し、その代わりに、その凝集修復状態の表現を送信NACKコンテンツを再送信しないことに注意してください。 NORM_CMD（REPAIR_ADV）メッセージの送信は、送信元送信レート制限とNormSegmentSize制限を受けます。 （フラグNORM_REPAIR_ADV_FLAG_LIMITによって示されるように）NORM_CMD（REPAIR_ADV）メッセージが最大サイズである場合、受信機は、送信者の現在の送信位置としてメッセージに埋め込まれた最大順序送信位置値を考慮し、暗黙ordinally高い修理のための要求を抑制するものとします。輻輳制御動作のために、送信者はまた、必要に応じのでダイナミック輻輳制御フィードバックは、受信機の間で抑制することができる任意の情報を提供する必要があります。この文書では、ベースラインNORM-CC動作に適用されるNORM-CCフィードバックヘッダー拡張子を指定します。他の輻輳制御メカニズムがNORMの実装内で使用される場合、他のヘッダ拡張を定義することができます。どのようなコンテンツフォーマットは、受信機セットに搬送される可能な最大抑制状態を確認する必要があり、この目的のために使用されます。"
    },
    {
      "indent": 0,
      "text": "5.5. Additional Protocol Mechanisms",
      "section_title": true,
      "ja": "5.5。追加議定書のメカニズム"
    },
    {
      "indent": 3,
      "text": "In addition to the principal function of data content transmission and repair, there are some other protocol mechanisms to help NORM to adapt to network conditions and play fairly with other coexistent protocols.",
      "ja": "データコンテンツ伝送および修理の主要な機能に加えて、ネットワークの状態に適応し、他の共存プロトコルとかなりプレイするNORMを助けるために、いくつかの他のプロトコルメカニズムがあります。"
    },
    {
      "indent": 0,
      "text": "5.5.1. Group Round-Trip Time (GRTT) Collection",
      "section_title": true,
      "ja": "5.5.1。グループラウンドトリップ時間（GRTT）コレクション"
    },
    {
      "indent": 3,
      "text": "For NORM receivers to appropriately scale backoff timeouts and the senders to use proper corresponding timeouts, the participants need to use a common timeout basis. Each NORM sender monitors the round-trip time of active receivers and determines the greatest group round-trip time. The sender advertises this GRTT estimate in every message it transmits so receivers have this value available for scaling their timers. To measure the current GRTT, the sender periodically sends NORM_CMD(CC) messages containing a locally generated timestamp. Receivers are expected to record this timestamp along with the time the NORM_CMD(CC) message is received. Then, when the receivers generate feedback messages to the sender, an adjusted version of the sender timestamp is embedded in the feedback message (NORM_NACK or NORM_ACK). The adjustment adds the amount of time the receiver held the timestamp before generating its response. Upon receipt of this adjusted timestamp, the sender is able to calculate the round-trip time to that receiver.",
      "ja": "NORM受信機は適切にバックオフタイムアウトを拡張すると、送信者が適切に対応するタイムアウトを使用するには、参加者が共通のタイムアウト基盤を使用する必要があります。各NORMの送信者は、アクティブ受信機の往復時間を監視し、最大のグループのラウンドトリップ時間を決定します。送信者は受信者が自分のタイマーをスケーリングするための可能なこの値を持っているので、それが送信するすべてのメッセージで、このGRTT推定値をアドバタイズします。現在のGRTTを測定するために、送信者は、定期的にローカルで生成されたタイムスタンプを含むNORM_CMD（CC）メッセージを送信します。受信機はNORM_CMD（CC）メッセージを受信した時間とともに、このタイムスタンプを記録することが期待されます。受信機は送信者にフィードバックメッセージを生成するときに、送信者のタイムスタンプの調整されたバージョンは、フィードバックメッセージ（NORM_NACK又はNORM_ACK）に埋め込まれています。調整は、受信機がその応答を生成する前にタイムスタンプを保持する時間を加算します。この調整されたタイムスタンプを受信すると、送信者はその受信機へのラウンドトリップ時間を計算することができます。"
    },
    {
      "indent": 3,
      "text": "The round-trip time for each receiver is fed into an algorithm that assigns weights and smoothes the values for a conservative estimate of the GRTT. The algorithm and methodology are described in the Multicast NACK Building Block [RFC5401] document in the section entitled \"One-to-Many Sender GRTT Measurement\". A conservative estimate helps guarantee feedback suppression at a small cost in overall protocol repair delay. The sender's current estimate of GRTT is advertised in the \"grtt\" field found in all NORM sender messages. The advertised GRTT is also limited to a minimum of the nominal inter-packet transmission time given the sender's current transmission rate and system clock granularity. The reason for this additional limit is to keep the receiver somewhat event-driven by making sure the sender has had adequate time to generate any response to repair requests from receivers given transmit rate limitations due to congestion control or configuration.",
      "ja": "各受信機のためのラウンドトリップ時間は、重みを割り当て、GRTTの保守的な推定値を平滑化アルゴリズムに供給されます。アルゴリズムと方法論は、「一対多送信者GRTT測定」の項でマルチキャストNACKビルディングブロック[RFC5401]ドキュメントに記述されています。控えめな見積もりでは、全体的なプロトコル修復遅延の小さなコストでフィードバック抑制を保証するのに役立ちます。 GRTTの送信者の現在の推定値は、すべてのNORMの送信者のメッセージで見つかった「GRTT」フィールドにアドバタイズされます。宣伝GRTTも、送信者の現在の伝送速度とシステムクロックの細分与えられた名目上のパケット間の伝送時間の最小値に制限されています。この追加の制限の理由は、送信側が輻輳制御または構成による転送レートの限界与えられた受信機からの要求を修復するためにすべての応答を生成するための十分な時間があったことを確認することによって、多少イベント駆動型の受信機を維持することです。"
    },
    {
      "indent": 3,
      "text": "When the NORM-CC Rate header extension is present in NORM_CMD(CC) messages, the receivers respond to NORM_CMD(CC) messages as described in Section 5.5.2, \"NORM Congestion Control Operation\". The NORM_CMD(CC) messages are periodically generated by the sender as described for congestion control operation. This provides for proactive, but controlled, feedback from the group in the form of NORM_ACK messages. This provides for GRTT feedback even if no NORM_NACK messages are being sent. If operating without congestion control in a closed network, the NORM_CMD(CC) messages MAY be sent periodically without the NORM-CC Rate header extension. In this case, receivers will only provide GRTT measurement feedback when NORM_NACK messages are generated since no NORM_ACK messages are generated. In this case, the NORM_CMD(CC) messages MAY be sent less frequently, perhaps as little as once per minute, to conserve network capacity. Note the NORM-CC Rate header extension MAY also be used to proactively solicit RTT feedback from the receiver group per congestion control operation even when the sender is not conducting congestion control rate adjustment. NORM operation without congestion control SHOULD be considered only in closed networks.",
      "ja": "NORM-CCレートヘッダ拡張がNORM_CMD（CC）メッセージに存在する場合、セクション5.5.2、「NORM輻輳制御動作」で説明したように、受信機はNORM_CMD（CC）メッセージに応答します。輻輳制御動作について説明したようにNORM_CMD（CC）メッセージを定期的に送信者によって生成されます。これは、積極的なのために提供していますが、NORM_ACKメッセージの形式でグループから、フィードバックを制御しました。これは何のNORM_NACKメッセージが送信されていないされている場合でも、GRTTのフィードバックを提供します。閉じたネットワークの輻輳制御なしで動作する場合、NORM_CMD（CC）メッセージをNORM-CCレートヘッダ拡張なしに定期的に送信されるかもしれません。何NORM_ACKメッセージが生成されないのでNORM_NACKメッセージが生成されるとき、この場合、受信機は、GRTT測定フィードバックを提供します。この場合、NORM_CMD（CC）メッセージは、ネットワーク容量を節約するために、おそらくはわずか1分に1回、それほど頻繁に送信されるかもしれません。 NORM-CCレートヘッダ拡張も積極的に送信者が輻輳制御速度調整を行っていない場合でも、輻輳制御動作ごとに受信グループからRTTフィードバックを求めるために使用されるかもしれ留意されたいです。輻輳制御なしNORM操作は、閉じたネットワークで考慮されるべきです。"
    },
    {
      "indent": 0,
      "text": "5.5.2. NORM Congestion Control Operation",
      "section_title": true,
      "ja": "5.5.2。 NORM輻輳制御動作"
    },
    {
      "indent": 3,
      "text": "This section describes baseline congestion control operation for the NORM protocol (NORM-CC). The supporting NORM message formats and approach described here are an adaptation of the equation-based TCP-Friendly Multicast Congestion Control (TFMCC) approach [RFC4654]. This congestion control scheme is REQUIRED for operation within the general Internet unless the NORM implementation is adapted to use another IETF-sanctioned reliable multicast congestion control mechanism. With this TFMCC-based approach, the transmissions of NORM senders are controlled in a rate-based manner as opposed to window-based congestion control algorithms as in TCP. However, it is possible the NORM protocol message set MAY alternatively be used to support a window-based multicast congestion control scheme such as PGMCC. The details of such an alternative MAY be described separately or in a future revision of this document. In either case (rate-based TFMCC or window-based PGMCC), successful control of sender transmission depends upon collection of sender-to-receiver packet loss estimates and RTTs to identify the congestion control bottleneck path(s) within the multicast topology and adjust the sender rate accordingly. The receiver with loss and RTT estimates corresponding to the lowest resulting calculated transmission rate is identified as the \"current limiting receiver\" (CLR). In the case of a tie (where candidate CLRs are within 10% of the same calculated rate), the receiver with the largest RTT value SHOULD be designated as the CLR.",
      "ja": "このセクションでは、NORMプロトコル（NORM-CC）のベースライン輻輳制御動作を説明します。ここで説明する支持NORMメッセージフォーマットと手法は、方程式ベースのTCPフレンドリーマルチキャスト輻輳制御（TFMCC）アプローチ[RFC4654]の適応です。 NORM実装は別のIETF公認信頼性マルチキャスト輻輳制御機構を使用するように適合されていない限り、この輻輳制御方式は、一般的なインターネット内での動作のために必要とされます。 TCPのようなウィンドウベースの輻輳制御アルゴリズムとは対照的に、このTFMCCベースのアプローチを用いて、NORMの送信者の送信は、レートベースの方法で制御されます。しかし、NORMプロトコルメッセージセットは代替的PGMCCとしてウィンドウベースのマルチキャスト輻輳制御方式をサポートするために使用されることが可能です。このような代替の詳細は別々に、またはこの文書の将来の改訂で説明することができます。いずれの場合（レートベースTFMCCまたはウィンドウベースPGMCC）において、送信側の送信の成功した制御は、マルチキャストトポロジ内の輻輳制御ボトルネックパス（複数可）を識別し、調整するために、送信者 - 受信器パケット損失の推定値とのRTTの収集に依存しますそれに応じて、送信者の割合。損失と最小結果の算出した伝送速度に対応するRTT推定値を用いて受信機は、「電流制限受信」（CLR）として識別されます。 （候補のCLRは、同じ計算された速度の10％以内である）同点の場合には、最大RTT値を持つ受信機は、CLRとして指定されるべきです。"
    },
    {
      "indent": 3,
      "text": "As described in [TcpModel], a steady-state sender transmission rate,\nto be \"friendly\" with competing TCP flows, can be calculated as:\n                                 S\nRsender = ----------------------------------------------------------\n        T_rtt*(sqrt((2/3)*p) + 12*sqrt((3/8)*p) * p * (1 + 32*(p^2)))",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where",
      "ja": "どこ"
    },
    {
      "indent": 3,
      "text": "S = nominal transmitted packet size. (In NORM, the \"nominal\" packet size can be determined by the sender as an exponentially weighted moving average (EWMA) of transmitted packet sizes to account for variable message sizes).",
      "ja": "S =名目送信パケットサイズ。 （NORMにおいて、「公称」パケット・サイズは次のように送信者によって決定することができ、指数関数的に可変メッセージサイズを考慮して送信パケットサイズの平均（EWMA）を移動重み付け）。"
    },
    {
      "indent": 3,
      "text": "T_rtt = RTT estimate of the current \"current limiting receiver\" (CLR).",
      "ja": "現在の「電流制限受信」（CLR）のT_rtt = RTT推定。"
    },
    {
      "indent": 3,
      "text": "p = loss event fraction of the CLR.",
      "ja": "CLRのP =損失事象の割合。"
    },
    {
      "indent": 3,
      "text": "To support congestion control feedback collection and operation, the NORM sender periodically transmits NORM_CMD(CC) command messages. NORM_CMD(CC) messages are multiplexed with NORM data and repair transmissions and serve several purposes, they:",
      "ja": "輻輳制御フィードバックの収集と操作をサポートするために、NORMの送信者は、定期的にNORM_CMD（CC）コマンドメッセージを送信します。 NORM_CMD（CC）のメッセージは、彼らは、NORMデータおよび修理の送信と多重化し、いくつかの目的を果たすされています。"
    },
    {
      "indent": 3,
      "text": "1. Stimulate explicit feedback from the general receiver set to collect congestion control information.",
      "ja": "1輻輳制御情報を収集するように設定する一般的な受信機からの明示的フィードバックを刺激します。"
    },
    {
      "indent": 3,
      "text": "2. Communicate state to the receiver set on the sender's current congestion control status including details of the CLR.",
      "ja": "2. CLRの詳細を含め、送信者の現在の輻輳制御状態に設定された受信機に状況を伝えます。"
    },
    {
      "indent": 3,
      "text": "3. Initiate rapid (immediate) feedback from the CLR in order to closely track the dynamics of congestion control for the current worst path in the group multicast topology.",
      "ja": "3.密接グループマルチキャストトポロジの現在のワーストパスの輻輳制御のダイナミクスを追跡するために、CLRからの迅速な（即時の）フィードバックを開始します。"
    },
    {
      "indent": 3,
      "text": "The format of the NORM_CMD(CC) message is described in Section 4.2.3 of this document. The NORM_CMD(CC) message contains information to allow measurement of RTTs, to inform the group of the congestion control CLR, and to provide feedback of individual RTT measurements to the receivers in the group. The NORM_CMD(CC) also provides for exciting feedback from OPTIONAL \"potential limiting receiver\" (PLR) nodes that might be determined administratively or possibly algorithmically based upon congestion control feedback. PLR nodes are receivers that have been identified to have potential for (perhaps soon) becoming the CLR and thus immediate, up-to-date feedback is beneficial for congestion control performance. The PLR list MAY be populated with a small number of receivers the sender identifies as approaching the CLR loss and delay conditions based on feedback from the group.",
      "ja": "NORM_CMD（CC）メッセージのフォーマットは、このドキュメントのセクション4.2.3に記載されています。 NORM_CMD（CC）メッセージは、輻輳制御CLRのグループに知らせるために、グループ内の受信機に個々のRTT測定値のフィードバックを提供するために、のRTTの測定を可能にする情報を含みます。 NORM_CMD（CC）は、管理的決定又はおそらくアルゴリズム輻輳制御フィードバックに基づくかもしれないOPTIONAL「電位制限受信」（PLR）ノードからの励起フィードバックを提供します。 PLRノードがCLRので、即時になってきて（おそらくもうすぐ）の可能性を持つことが確認されている受信機は、最新のフィードバックは、輻輳制御性能のために有益です。 PLRリストは、送信者がグループからのフィードバックに基づいてCLR損失及び遅延条件に近づくように識別する受信機の小さな数で取り込まれるかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.5.2.1. NORM_CMD(CC) Transmission",
      "section_title": true,
      "ja": "5.5.2.1。 NORM_CMD（CC）の送信"
    },
    {
      "indent": 3,
      "text": "The NORM_CMD(CC) message is transmitted periodically by the sender along with its normal data transmission. Note the repeated transmission of NORM_CMD(CC) messages MAY be initiated some time before transmission of user data content at session startup. This can be done to collect some estimation of the current state of the multicast topology with respect to group and individual RTT and congestion control state.",
      "ja": "NORM_CMD（CC）メッセージは、その通常のデータ送信と共に送信者によって定期的に送信されます。メッセージは、セッションの起動時にユーザデータコンテンツの送信前にいくつかの時間を開始することができるNORM_CMD（CC）の繰り返し送信を注意してください。これは、マルチキャストグループに対して、個々のRTTとトポロジーと輻輳制御状態の現在の状態のいくつかの推定を収集するために行うことができます。"
    },
    {
      "indent": 3,
      "text": "A NORM_CMD(CC) message is immediately transmitted at sender startup. The interval of subsequent NORM_CMD(CC) message transmission is determined as follows:",
      "ja": "NORM_CMD（CC）メッセージはすぐに送信者の起動時に送信されます。次のように後続NORM_CMD（CC）メッセージ送信の間隔が決定されます。"
    },
    {
      "indent": 3,
      "text": "1. By default, the interval is set according to the current sender GRTT estimate. A startup initial value of GRTT_sender = 0.5 seconds is RECOMMENDED when no feedback has yet been received from the group.",
      "ja": "1.デフォルトでは、間隔は、現在の送信者GRTT推定値に応じて設定されています。いかなるフィードバックがまだグループから受信されていない場合GRTT_sender = 0.5秒の起動初期値が推奨されます。"
    },
    {
      "indent": 3,
      "text": "2. Until a CLR has been identified (based on previous receiver feedback) or when no data transmission is pending, the NORM_CMD(CC) interval is doubled up from its current interval to a maximum of once per 30 seconds. This results in a low duty cycle for NORM_CMD(CC) probing when no CLR is identified or there is no pending data to transmit.",
      "ja": "2. CLRは（以前受信機からのフィードバックに基づいて）同定されるまで、または全くデータ送信が保留されていない場合、NORM_CMD（CC）間隔が一度当たり30秒の最大値に現在の間隔からダブルアップされます。これにはCLRが識別されないか、送信すべき保留中のデータが存在しないときプロービングNORM_CMDための低デューティサイクル（CC）になります。"
    },
    {
      "indent": 3,
      "text": "3. When a CLR has been identified (based on receiver feedback) and data transmission is pending, the probing interval is set to the RTT between the sender and the CLR (RTT_clr).",
      "ja": "3. CLRは、（受信機のフィードバックに基づいて）識別されたデータ送信が保留中である場合、プローブ間隔は、送信者とCLR（RTT_clr）との間のRTTに設定されています。"
    },
    {
      "indent": 3,
      "text": "4. Additionally, when the data transmission rate is low with respect to the RTT_clr interval used for probing, the implementation SHOULD ensure no more than one NORM_CMD(CC) message is sent per NORM_DATA message when there is data pending transmission. This ensures the transmission of this control message is not done to the exclusion of user data transmission.",
      "ja": "4.また、データ伝送速度は、プロービングに使用RTT_clr間隔に対して低い場合、実装は、データの保留中の送信が存在する場合にない複数のNORM_CMD（CC）メッセージをあたりNORM_DATAメッセージ送信されていることを確認すべきです。これは、この制御メッセージの送信は、ユーザデータの送信を除外して行われていない保証します。"
    },
    {
      "indent": 3,
      "text": "The NORM_CMD(CC) \"cc_sequence\" field is incremented with each transmission of a NORM_CMD(CC) command. The greatest \"cc_sequence\" recently received by receivers is included in their feedback to the sender. This allows the sender to determine the age of feedback to assist in congestion avoidance.",
      "ja": "NORM_CMD（CC）「cc_sequence」フィールドはNORM_CMD（CC）コマンドのそれぞれの送信でインクリメントされます。最近、受信機で受信した最大の「cc_sequenceは、」送信者へのフィードバックに含まれています。これは、送信者が輻輳回避を支援するためにフィードバックの年齢を決定することができます。"
    },
    {
      "indent": 3,
      "text": "The NORM-CC Rate Header Extension is applied to the NORM_CMD(CC) message and the sender advertises its current transmission rate in the \"send_rate\" field. The rate information is used by receivers to initialize loss estimation during congestion control startup or restart.",
      "ja": "NORM-CCレートヘッダー拡張がNORM_CMD（CC）メッセージに適用され、送信者が「send_rate」フィールドに、現在の伝送速度をアドバタイズします。レート情報は、輻輳制御の起動または再起動時に損失推定を初期化するために受信機によって使用されます。"
    },
    {
      "indent": 3,
      "text": "The \"cc_node_list\" contains a list of entries identifying receivers and their current congestion control state (status \"flags\", \"rtt\", and \"loss\" estimates). The list will be empty if the sender has not yet received any feedback from the group. If the sender has received feedback, the list will minimally contain an entry identifying the CLR. A NORM_FLAG_CC_CLR flag value is provided for the \"cc_flags\" field to identify the CLR entry. It is RECOMMENDED the CLR entry be the first in the list for implementation efficiency. Additional entries in the list are used to provide sender-measured individual RTT estimates to receivers in the group. The number of additional entries in this list is dependent upon the percentage of control traffic the sender application is willing to send with respect to user data message transmissions. More entries in the list will allow the sender to be more responsive to congestion control dynamics. The length of the list can be dynamically determined according to the current transmission rate and scheduling of NORM_CMD(CC) messages. The maximum length of the list corresponds to the sender's NormSegmentSize parameter for the session. The inclusion of additional entries in the list based on receiver feedback is prioritized with the following rules:",
      "ja": "「cc_node_list」は受信機と、現在の輻輳制御状態（ステータス「フラグ」、「RTT」、および「損失」の推定値）を識別するエントリのリストを含みます。送信者がまだグループからのフィードバックを受け取っていない場合は、リストは空になります。送信者がフィードバックを受信した場合、リストは最小限にCLRを特定するエントリが含まれています。 NORM_FLAG_CC_CLRフラグ値がCLRエントリを識別するために「cc_flags」フィールドのために提供されます。 CLRエントリが実装効率のためのリストの最初のすることをお勧めします。リスト内の追加のエントリは、RTTは、グループ内の受信者に推定し、送信者、個々の測定を提供するために使用されています。このリストの追加エントリの数は、送信側アプリケーションは、ユーザデータのメッセージ送信に関して送って喜んで制御トラフィックの割合に依存しています。リストに複数のエントリは、送信側が輻輳制御のダイナミクスにより応答できるようになります。リストの長さを動的NORM_CMD（CC）メッセージの現在の伝送レートとスケジューリングに応じて決定することができます。リストの最大長はセッションのために、送信者のNormSegmentSizeパラメータに対応します。受信機のフィードバックに基づいてリストに追加エントリを含めることは、以下の規則で優先されます。"
    },
    {
      "indent": 3,
      "text": "1. Receivers that have not yet been provided an RTT measurement get first priority. Of these, those with the greatest loss fraction receive precedence for list inclusion.",
      "ja": "まだRTT測定を提供されていない1.受信機は、最初の優先順位を取得します。これらのうち、最大の損失割合のものが、リストの包含のための優先順位を受け取ります。"
    },
    {
      "indent": 3,
      "text": "2. Secondly, receivers that have previously been provided an RTT measurement are included with receivers yielding the lowest calculated congestion rate getting precedence.",
      "ja": "2.第二に、以前にRTT測定値を提供されている受信機は、受信機が優先され得る最低の計算された混雑率を生じるに含まれています。"
    },
    {
      "indent": 3,
      "text": "There are \"cc_flag\" values in addition to NORM_FLAG_CC_CLR used for other congestion control functions. The NORM_FLAG_CC_PLR flag value is used to mark additional receivers from which the sender would like to have immediate, non-suppressed feedback. These can be receivers the sender algorithmically identified as potential future CLRs or have been pre-configured as potential congestion control points in the network. The NORM_FLAG_CC_RTT indicates the validity of the \"cc_rtt\" field for the associated receiver node. Normally, this flag will be set since the receivers in the list will typically be receivers from which the sender has received feedback. However, in the case the NORM sender has been pre-configured with a set of PLR nodes, feedback from those receivers might not have yet been collected and thus the \"cc_rtt\" field does not contain a valid value when this flag is not set. Similarly, a value of ZERO for the \"cc_rate\" field here MUST be treated as an invalid value and be ignored for the purposes of feedback suppression, etc.",
      "ja": "他の輻輳制御機能に使用NORM_FLAG_CC_CLRに加えて、「cc_flag」の値があります。 NORM_FLAG_CC_PLRフラグ値は送信者が即時、非抑制フィードバックしたいと思うそこから追加の受信機をマークするために使用されます。これらは、送信者がアルゴリズム将来のCLRとして同定又はネットワーク内の潜在的な輻輳制御点として予め設定された受信機であってもよいです。 NORM_FLAG_CC_RTTは、関連する受信ノードのための「cc_rtt」フィールドの有効性を示しています。リスト内の受信機は、典型的には、送信者がフィードバックを受信し、そこから受信することになるので、通常、このフラグがセットされます。しかし、NORMの送信者はPLRノードのセットで事前に設定されている場合には、それらの受信機からのフィードバックはまだ収集されていない可能性があり、このフラグが設定されていない場合ので、「cc_rtt」フィールドには、有効な値が含まれていません。同様に、ここで「cc_rate」フィールドのゼロの値は無効値として処理されなければならないとフィードバック抑制などの目的のために無視され"
    },
    {
      "indent": 0,
      "text": "5.5.2.2. NORM_CMD(CC) Feedback Response",
      "section_title": true,
      "ja": "5.5.2.2。 NORM_CMD（CC）フィードバック応答"
    },
    {
      "indent": 3,
      "text": "Receivers explicitly respond to NORM_CMD(CC) messages in the form of a NORM_ACK(RTT) message. The goal of the congestion control feedback is to determine the receivers with the lowest congestion control rates. Receivers marked as CLR or PLR nodes in the NORM_CMD(CC) \"cc_node_list\" immediately provide feedback in the form of a NORM_ACK to this message. When a NORM_CMD(CC) is received, non-CLR or non-PLR nodes initiate random feedback backoff timeouts similar to those used when the receiver initiates a repair cycle (see Section 5.3) in response to detection of data loss. The backoff timeout for the congestion control response is generated as follows:",
      "ja": "レシーバは、明示的にNORM_ACK（RTT）メッセージの形でNORM_CMD（CC）メッセージに応答します。輻輳制御フィードバックの目標は、最低の輻輳制御率と受信機を決定することです。受信機は、すぐにこのメッセージにNORM_ACKの形でフィードバックを提供NORM_CMD（CC）「cc_node_list」にCLRまたはPLRノードとしてマークされました。 NORM_CMD（CC）を受信したとき、非CLRまたは非PLRノードがランダム開始フィードバックバックオフは、データ損失の検出に応答して（セクション5.3を参照）受信機は修復サイクルを開始するときに使用されるものと同様のタイムアウト。次のように輻輳制御応答のためのバックオフタイムアウトが発生します。"
    },
    {
      "indent": 6,
      "text": "T_backoff = RandomBackoff(K_backoff * GRTT_sender, GSIZE_sender)",
      "ja": "T_backoff = RandomBackoff（K_backoff * GRTT_sender、GSIZE_sender）"
    },
    {
      "indent": 3,
      "text": "The RandomBackoff() algorithm provides a truncated exponentially distributed random number and is described in the Multicast NACK Building Block [RFC5401] document. The same backoff factor, K_backoff = K_sender, as used with NORM_NACK suppression is generally RECOMMENDED. However, in cases where the application purposefully specifies a very small K_sender backoff factor to minimize the NACK repair process latency (trading off group size scalability), it is RECOMMENDED a larger backoff factor for congestion control feedback be maintained, since there can be a larger volume of congestion control feedback than NACKs in many cases and some congestion control feedback latency might be tolerable where reliable delivery latency is not. As previously noted, a backoff factor value of K_sender = 4 is generally RECOMMENDED for ASM operation and K_sender = 6 for SSM operation. A receiver SHALL cancel the backoff timeout and thus its pending transmission of a NORM_ACK(RTT) message under the following conditions:",
      "ja": "RandomBackoff（）アルゴリズムは、切り捨てられた指数分布乱数を提供し、マルチキャストNACKビルディングブロック[RFC5401]の文書に記載されています。 NORM_NACK抑制で用いたのと同じバックオフ因子、K_backoff = K_senderは、一般的に推奨されています。しかし、アプリケーションが意図NACK修復プロセス待ち時間（グループサイズのスケーラビリティをトレードオフ）を最小化するために非常に小さいK_senderバックオフファクタを指定する場合には、大きくあり得るので、輻輳制御フィードバックのためのより大きなバックオフ因子は、維持することが推奨されます信頼性の高い配信待ち時間がない場合、多くの場合、NACKのより輻輳制御フィードバックの量といくつかの輻輳制御フィードバック待ち時間は許容できるかもしれません。先に述べたように、K_sender = 4のバックオフファクタ値は、一般に、SSMの動作のためのASM動作とK_sender = 6に推奨されます。受信機は、以下の条件でバックオフタイムアウトとNORM_ACK（RTT）のため、その保留中の送信メッセージをキャンセルしなければなりません。"
    },
    {
      "indent": 3,
      "text": "1. The receiver generates another feedback message (NORM_NACK or other NORM_ACK) before the congestion control feedback timeout expires (these messages will convey the current congestion control feedback information).",
      "ja": "1.受信機は、輻輳制御フィードバックタイムアウトが満了する前に、別のフィードバックメッセージ（NORM_NACKまたは他のNORM_ACK）を（これらのメッセージは、現在の輻輳制御フィードバック情報を伝達する）を生成します。"
    },
    {
      "indent": 3,
      "text": "2. A NORM_CMD(CC) or other receiver feedback with an ordinally greater \"cc_sequence\" field value is received before the congestion control feedback timeout expires (this is similar to the TFMCC feedback round number).",
      "ja": "2. A NORM_CMD（CC）又はordinally大きい「cc_sequence」フィールド値を有する他の受信機からのフィードバックは、輻輳制御フィードバックタイムアウトが期限切れになる前に（これはTFMCCフィードバックラウンド番号に類似している）を受信します。"
    },
    {
      "indent": 3,
      "text": "3. When the T_backoff is greater than 1*GRTT_sender. This prevents NACK implosion in the event of sender or network failure.",
      "ja": "3. T_backoffは1 *のGRTT_senderよりも大きくなります。これは、送信者またはネットワークに障害が発生した場合にNACKの爆縮を防止します。"
    },
    {
      "indent": 3,
      "text": "4. \"Suppressing\" congestion control feedback is heard from another receiver (in a NORM_ACK or NORM_NACK) or via a NORM_CMD(REPAIR_ADV) message from the sender. The local receiver's feedback is \"suppressed\" if the rate of the competing feedback (Rfb) is sufficiently close to or less than the local receiver's calculated rate (Rcalc). The local receiver's feedback is canceled when Rcalc > (0.9 * Rfb). Also, note receivers that have not yet received an RTT measurement from the sender are suppressed only by other receivers that have not yet measured RTT. Additionally, receivers whose RTT estimate has aged considerably (i.e., they haven't been included in the NORM_CMD(CC) \"cc_node_list\" in a long time) might wish to compete as a receiver with no prior RTT measurement after some long-term expiration period.",
      "ja": "4.「抑制」輻輳制御フィードバックは、（NORM_ACK又はNORM_NACKで）別の受信機から、または送信者からNORM_CMD（REPAIR_ADV）メッセージを介して、聞こえます。競合フィードバック（Rfbを）の速度が十分に近い、またはローカル受信機の計算速度（Rcalc）未満である場合、ローカル受信機のフィードバックが「抑制」されています。ローカル受信者のフィードバックがキャンセルされたときにRcalc>（0.9×Rfbを）。また、まだ送信者からのRTT測定値を受け取っていないメモ受信機のみまだRTTを測定していない他の受信機によって抑制されます。さらに、そのRTT推定（すなわち、彼らは長い時間でNORM_CMD（CC）「cc_node_list」には含まれていない）かなり老化した受信機は、いくつかの長期満了後はノー前RTT測定と受信機と競争することを望むかもしれません期間。"
    },
    {
      "indent": 3,
      "text": "When the backoff timer expires, the receiver SHALL generate a NORM_ACK(RTT) message to provide feedback to the sender and group. This message MAY be multicast to the group for most effective suppression in ASM topologies or unicast to the sender depending upon how the NORM protocol is deployed and configured.",
      "ja": "バックオフタイマが満了すると、受信機は、送信者とグループにフィードバックを提供するNORM_ACK（RTT）メッセージを生成しなければなりません。このメッセージは、ASMトポロジ又はNORMプロトコルが展開され、構成されている方法に応じて、送信者へのユニキャストで最も効果的な抑制のためにグループにマルチキャストされるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Whenever any feedback is generated (including this NORM_ACK(RTT) message), receivers include an adjusted version of the sender timestamp from the most recently received NORM_CMD(CC) message and its \"cc_sequence\" value in the corresponding NORM_ACK or NORM_NACK message fields. For NORM-CC operation, any generated feedback message SHALL also contain the NORM-CC Feedback header extension. The receiver provides its current \"cc_rate\" estimate, \"cc_loss\" estimate, \"cc_rtt\" if known, and any applicable \"cc_flags\" via this header extension.",
      "ja": "任意のフィードバック（このNORM_ACK（RTT）メッセージを含む）が生成されるたびに、受信機は、最も最近受信NORM_CMD（CC）メッセージおよび対応NORM_ACK又はNORM_NACKメッセージフィールドにその「cc_sequence」値から、送信者のタイムスタンプの調整されたバージョンを含みます。 NORM-CC動作のために、任意の生成されたフィードバック・メッセージはまた、NORM-CCフィードバックヘッダ拡張を含まなければなりません。受信機は、このヘッダー拡張を介して現在の「cc_rate」推定既知の場合、「cc_loss」推定値「cc_rtt」、および該当する「cc_flags」を提供します。"
    },
    {
      "indent": 3,
      "text": "During slow start (when the receiver has not yet detected loss from the sender), the receiver uses a value equal to two times its measured rate from the sender in the \"cc_rate\" field. For steady-state congestion control operation, the receiver \"cc_rate\" value is from the equation-based value using its current loss event estimate and sender<->receiver RTT information. (The GRTT_sender is used when the receiver has not yet measured its individual RTT.)",
      "ja": "（受信機がまだ送信者からの損失を検出していない）スロースタート時、受信機は、「cc_rate」フィールドの送信者からの二度の測定速度に等しい値を使用します。 < - >受信RTT情報定常輻輳制御動作のために、受信機「cc_rate」値は、現在の損失事象推定値と送信者を使用して、方程式系の値です。 （受信機がまだその個々のRTTを測定していない場合GRTT_senderが使用されます。）"
    },
    {
      "indent": 3,
      "text": "The \"cc_loss\" field value reflects the receiver's current loss event estimate with respect to the sender in question.",
      "ja": "「cc_loss」フィールドの値は、問題の送信者に関する受信機の現在の損失事象の推定値を反映しています。"
    },
    {
      "indent": 3,
      "text": "When the receiver has a valid individual RTT measurement, it SHALL include this value in the \"cc_rtt\" field. The NORM_FLAG_CC_RTT MUST be set when the \"cc_rtt\" field is valid.",
      "ja": "受信機が有効な個々のRTTの測定を持っているとき、それは「cc_rtt」フィールドにこの値を含まなければなりません。 「cc_rtt」フィールドが有効であるときNORM_FLAG_CC_RTTを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "After a congestion control feedback message is generated or when the feedback is suppressed, a non-CLR receiver begins a \"holdoff\" timeout period during which it will restrain itself from providing congestion control feedback, even if NORM_CMD(CC) messages are received from the sender (unless the receive becomes marked as a CLR or PLR node). The value of this holdoff timeout (T_ccHoldoff) period is:",
      "ja": "輻輳制御フィードバックメッセージが生成されるか、またはフィードバックが抑制される場合、非CLR受信機はNORM_CMD（CC）メッセージをから受信された場合でも、それが輻輳制御フィードバックを提供することから自分自身を抑制しますその間「ホールドオフ」タイムアウト期間を開始した後送信者（CLRまたはPLRノードとしてマークされてしまう受ける場合を除きます）。このホールドオフタイムアウト（T_ccHoldoff）期間の値です。"
    },
    {
      "indent": 19,
      "text": "T_ccHoldoff = (K_sender * GRTT_sender)",
      "ja": "T_ccHoldoff =（K_sender * GRTT_sender）"
    },
    {
      "indent": 3,
      "text": "Thus, non-CLR receivers are constrained to providing explicit congestion control feedback once per K_sender*GRTT_sender intervals. However, as the session progresses, different receivers will be responding to different NORM_CMD(CC) messages and there will be relatively continuous feedback of congestion control information while the sender is active.",
      "ja": "このように、非CLR受信機がK_sender * GRTT_sender間隔ごとに一度明示的輻輳制御フィードバックを提供することに制約されています。しかし、セッションが進行するにつれて、異なる受信機が異なるNORM_CMD（CC）メッセージに応答すると、送信者がアクティブである間輻輳制御情報の比較的連続的なフィードバックが存在することになります。"
    },
    {
      "indent": 0,
      "text": "5.5.2.3. Congestion Control Rate Adjustment",
      "section_title": true,
      "ja": "5.5.2.3。輻輳制御レート調整"
    },
    {
      "indent": 3,
      "text": "During steady-state operation, the sender will directly adjust its transmission rate to the rate indicated by the feedback from its currently selected CLR. As noted in [TfmccPaper], the estimation of parameters (loss and RTT) for the CLR will generally constrain the rate changes possible within acceptable bounds. For rate increases, the sender SHALL observe a maximum rate of increase of one packet per RTT at all times during steady-state operation.",
      "ja": "定常状態の動作時、送信側は、直接その現在選択されているCLRからのフィードバックによって示されるレートに対する伝送レートを調整します。 【TfmccPaper]で述べたように、CLRのパラメータ（損失とRTT）の推定は、一般的に許容される範囲内で可能な速度変化を抑制します。速度が増加するために、送信者は、定常状態動作中にすべての回でRTTごとに1つのパケットの増加の最大速度を遵守しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sender processes congestion control feedback from the receivers and selects the CLR based on the lowest rate receiver. Receiver rates are determined either directly from the slow start \"cc_rate\" provided by the receiver in the NORM-CC Feedback header extension or by performing the equation-based calculation using individual RTT and loss estimates (\"cc_loss\") as feedback is received.",
      "ja": "送信者は、受信機からの輻輳制御フィードバックを処理し、最低レート受信機に基づいてCLRを選択します。受信レートは、直接NORM-CCフィードバックヘッダ拡張またはフィードバックが受信されるように、個々のRTTおよび損失推定値を用いて、式ベースの計算（「cc_loss」）を行うことにより、受信機によって提供されるスロースタート「cc_rate」から決定されます。"
    },
    {
      "indent": 3,
      "text": "The sender can calculate a current RTT for a receiver (RTT_rcvrNew) using the \"grtt_response\" timestamp included in feedback messages. When the \"cc_rtt\" value in a response is not valid, the sender simply uses this RTT_rcvrNew value as the receiver's current RTT (RTT_rcvr). For non-CLR and non-PLR receivers, the sender SHOULD use the \"cc_rtt\" provided in the NORM-CC Feedback header extension as the receiver's previous RTT measurement (RTT_rcvrPrev) averaged with the current measurement (\"RTT_rcvrNew\") as the receiver's RTT value:",
      "ja": "送信側はフィードバック・メッセージに含まれる「grtt_response」タイムスタンプを使用して、受信機（RTT_rcvrNew）の現在のRTTを算出することができます。応答で「cc_rtt」の値が有効でない場合は、送信者は、単に受信者の現在のRTT（RTT_rcvr）として、このRTT_rcvrNew値を使用しています。非CLRおよび非PLR受信機のために、送信者は受信者のRTTのように受信機の前のRTT測定値（RTT_rcvrPrev）は電流測定（「RTT_rcvrNew」）と平均としてNORM-CCフィードバックヘッダ拡張内に設けられた「cc_rtt」を使用すべきです値："
    },
    {
      "indent": 13,
      "text": "RTT_rcvr = 0.5 * RTT_rcvrPrev + 0.5 * RTT_rcvrNew",
      "ja": "RTT_rcvr = 0.5 * RTT_rcvrPrev + 0.5 * RTT_rcvrNew"
    },
    {
      "indent": 3,
      "text": "For CLR receivers where feedback is received more regularly, the sender SHOULD maintain a more smoothed RTT estimate upon new feedback from the CLR where:",
      "ja": "フィードバックがより定期的に受信されたCLR受信機の場合、送信者はどこCLRから新しいフィードバックの際に、より平滑化RTT推定値を維持する必要があります。"
    },
    {
      "indent": 17,
      "text": "RTT_clr = 0.9 * RTT_clr + 0.1 * RTT_clrNew",
      "ja": "RTT_clr = 0.9 * RTT_clr + 0.1 * RTT_clrNew"
    },
    {
      "indent": 3,
      "text": "RTT_clrNew is the new RTT calculated from the timestamp in the feedback message received from the CLR. The RTT_clr is initialized to RTT_clrNew on the first feedback message received. Note that the same procedure is observed by the sender for PLR receivers, and if a PLR is \"promoted\" to CLR status, the smoothed estimate can be continued.",
      "ja": "RTT_clrNew新しいRTTがCLRから受信したフィードバック・メッセージ中のタイムスタンプから計算されます。 RTT_clrは、受信した第1のフィードバックメッセージにRTT_clrNewに初期化されます。同じ手順がPLR受信機の送信者によって観察されることに注意してください、とPLRは、CLRのステータスに「昇格」されている場合、平滑化推定を継続することができます。"
    },
    {
      "indent": 3,
      "text": "There are some additional periods besides steady-state operation to be considered in NORM-CC operation. These periods are:",
      "ja": "NORM-CC操作で考慮されるべき定常動作以外にいくつかの追加の期間があります。これらの期間は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. during session startup,",
      "section_title": true,
      "ja": "セッションの起動時に1、"
    },
    {
      "indent": 3,
      "text": "2. when no feedback is received from the CLR, and",
      "section_title": true,
      "ja": "2.全くフィードバックがCLRから受信されない、そして"
    },
    {
      "indent": 3,
      "text": "3. when the sender has a break in data transmission.",
      "section_title": true,
      "ja": "送信側がデータ伝送の中断を持っている3。"
    },
    {
      "indent": 3,
      "text": "During session startup, the congestion control operation SHALL observe a \"slow-start\" procedure to quickly approach its fair bandwidth share. An initial sender startup rate is assumed where:",
      "ja": "セッションの起動時には、輻輳制御動作が素早くその公平な帯域幅のシェアに近づくために、「スロースタート」の手順を遵守しなければなりません。最初の送信者の起動率が場合を想定されています。"
    },
    {
      "indent": 4,
      "text": "Rinit = MIN(NormSegmentSize/GRTT_sender, NormSegmentSize) bytes/sec",
      "ja": "RINIT = MIN（NormSegmentSize / GRTT_sender、NormSegmentSize）バイト/秒"
    },
    {
      "indent": 3,
      "text": "The rate is increased only when feedback is received from the receiver set. The \"slow start\" phase proceeds until any receiver provides feedback indicating loss has occurred. Rate increase during slow start is applied as: Rnew = Rrecv_min",
      "ja": "速度は、フィードバックは、受信機セットから受信された場合にのみ増加されます。 「スロースタート」位相進み任意の受信機までの損失が発生したことを示すフィードバックを提供します。 Rnew = Rrecv_min：スロースタート時のレートの増加は、次のように適用されます"
    },
    {
      "indent": 3,
      "text": "where Rrecv_min is the minimum reported receiver rate in the \"cc_rate\" field of congestion control feedback messages received from the group. Note during slow start, receivers use two times their measured rate from the sender in the \"cc_rate\" field of their feedback. Rate increase adjustment is limited to once per GRTT during slow start.",
      "ja": "Rrecv_minグループから受け取った輻輳制御フィードバックメッセージの「cc_rate」フィールドの最小報告受信レートがあります。スロースタートの際に注意し、受信機は、彼らのフィードバックの「cc_rate」フィールドに、送信者からの2倍の測定レートを使用します。レート増加調整はスロースタート時に一度GRTTごとに制限されています。"
    },
    {
      "indent": 3,
      "text": "If the CLR or any receiver intends to leave the group, it will set the NORM_FLAG_CC_LEAVE in its congestion control feedback message as an indication the sender SHOULD NOT select it as the CLR. When the CLR changes to a lower rate receiver, the sender SHOULD immediately adjust to the new lower rate. The sender is limited to increasing its rate at one additional packet per RTT towards any new, higher CLR rate.",
      "ja": "CLRまたは任意の受信機がグループから脱退しようとする場合、それは、送信者がCLRとして、それを選択しないでください指標としてその輻輳制御フィードバックメッセージにNORM_FLAG_CC_LEAVEを設定します。 CLRは、より低いレートの受信機に変更した場合、送信者はすぐに新しい、より低いレートに調整する必要があります。送信者は、新しい、より高CLR率の方RTTごとに追加のパケットでその速度を上げるに制限されています。"
    },
    {
      "indent": 3,
      "text": "The sender SHOULD also track the age of the feedback it has received from the CLR by comparing its current \"cc_sequence\" value (Seq_sender) to the last \"cc_sequence\" value received from the CLR (Seq_clr). As the age of the CLR feedback increases with no new feedback, the sender SHALL begin reducing its rate once per RTT_clr as a congestion avoidance measure. The following algorithm is used to determine the decrease in sender rate (Rsender bytes/sec) as the CLR feedback, unexpectedly, excessively ages:",
      "ja": "送信者はまた、CLR（Seq_clr）から受信した最後の「cc_sequence」の値に、現在の「cc_sequence」値（Seq_sender）を比較することにより、CLRから受け取ったフィードバックの年齢を追跡する必要があります。 CLRのフィードバックの年齢は無い新しいフィードバックを増加すると、送信者は輻輳回避策として、一度RTT_clrあたりの速度を低下させる始めるものとします。以下のアルゴリズムは、CLRのフィードバック、予期せず、過度の年齢として送信者率の低下（Rsenderバイト/秒）を決定するために使用されます。"
    },
    {
      "indent": 19,
      "text": "Age = Seq_sender - Seq_clr;\nif (Age > 4) Rsender = Rsender * 0.5;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This rate reduction is limited to the lower bound on NORM transmission rates. After NORM_ROBUST_FACTOR consecutive NORM_CMD(CC) rounds without any feedback from the CLR, the sender SHOULD assume the CLR has left the group and pick the receiver with the next lowest rate as the new CLR. Note this assumes the sender does not have explicit knowledge the CLR intentionally left the group. If no receiver feedback is received, the sender MAY wish to withhold further transmissions of NORM_DATA segments and maintain NORM_CMD(CC) transmissions only until feedback is detected. After such a CLR timeout, the sender will be transmitting with a minimal rate and SHOULD return to slow start as described here for a break in data transmission.",
      "ja": "このレートの減少は、NORMの伝送速度の下限に制限されています。 NORM_ROBUST_FACTOR連続NORM_CMD（CC）は、CLRからのフィードバックなしラウンド後、送信者は、CLRがグループを離脱したと仮定して、新しいCLRなどの次に低いレートで受信機を選ぶべきです。これは送信者はCLRが意図的にグループを去った明示的な知識を持っていない前提としています。全く受信フィードバックが受信されない場合、送信者はNORM_DATAセグメントの更なる送信を保留し、フィードバックが検出されるまでの間だけNORM_CMD（CC）の送信を維持することを望むかもしれません。このようCLRタイムアウトの後、送信者は最小限のレートで送信され、データ伝送の中断のために、ここで説明するように、開始を遅らせるために返すべきです。"
    },
    {
      "indent": 3,
      "text": "When the sender has a break in its data transmission, it can continue to probe the group with NORM_CMD(CC) messages to maintain RTT collection from the group. This will enable the sender to quickly determine an appropriate CLR upon data transmission restart.",
      "ja": "送信者はそのデータ伝送の中断を持っている場合は、グループからRTTコレクションを維持するためにNORM_CMD（CC）メッセージを持つグループを探査し続けることができます。これはすぐにデータ送信再開時に適切なCLRを決定するために、送信者が有効になります。"
    },
    {
      "indent": 3,
      "text": "However, the sender SHOULD exponentially reduce its target rate to be used for transmission restart as time since the break elapses. The target rate SHOULD be recalculated once per RTT_clr as:",
      "ja": "しかし、指数関数的にその目標レートを減らす必要があり、送信者は、休憩の経過からの時間として送信再開に使用します。目標レートはRTT_clr一回として再計算する必要があります。"
    },
    {
      "indent": 26,
      "text": "Rsender = Rsender * 0.5;",
      "ja": "Rsender = Rsender * 0.5。"
    },
    {
      "indent": 3,
      "text": "If the minimum NORM rate is reached, the sender SHOULD set the NORM_FLAG_START flag in its NORM_CMD(CC) messages upon restart and the group SHOULD observe slow-start congestion control procedures until any receiver experiences a new loss event.",
      "ja": "最小NORM率に達した場合、送信者は、再起動時にそのNORM_CMD（CC）メッセージでNORM_FLAG_STARTフラグを設定する必要があり、任意の受信機は、新たな損失事象を経験するまで、グループはスロースタート輻輳制御手順を確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.3. NORM Positive Acknowledgment Procedure",
      "section_title": true,
      "ja": "5.5.3。 NORM肯定応答手順"
    },
    {
      "indent": 3,
      "text": "NORM provides options for the source application to request positive acknowledgment (ACK) of NORM_CMD(FLUSH) and NORM_CMD(ACK_REQ) messages from members of the group. There are some specific acknowledgment requests defined for the NORM protocol and a range of acknowledgment request types left to be defined by the application. One predefined acknowledgment type is the NORM_ACK(FLUSH) type. This acknowledgment is used to determine if receivers have achieved completion of reliable reception up through a specific logical transmission point with respect to the sender's sequence of transmission. The NORM_ACK(FLUSH) acknowledgment MAY be used to assist in application flow control when the sender has information on a portion of the receiver set. Another predefined acknowledgment type is NORM_ACK(CC) used to explicitly provide congestion control feedback in response to NORM_CMD(CC) messages transmitted by the sender for NORM-CC operation. Note the NORM_ACK(CC) response does NOT follow the positive acknowledgment procedure described here. The NORM_CMD(ACK_REQ) and NORM_ACK messages contain an \"ack_type\" field to identify the type of acknowledgment requested and provided. A range of \"ack_type\" values is provided for application-defined use. While the application is responsible for initiating the acknowledgment request and interprets application-defined \"ack_type\" values, the acknowledgment procedure SHOULD be conducted within the protocol implementation to take advantage of timing and transmission scheduling information available to the NORM transport.",
      "ja": "NORMは、グループのメンバーからNORM_CMD（FLUSH）とNORM_CMD（ACK_REQ）メッセージの肯定応答（ACK）を要求するソース・アプリケーションのためのオプションを提供します。 NORMプロトコルおよびアプリケーションによって定義されるように、左承認要求タイプの範囲に対して定義されたいくつかの特定の承認要求があります。一つの事前定義された肯定応答タイプはNORM_ACK（FLUSH）型です。この肯定応答は受信機がアップ送信の送信者の配列に対して特定の論理伝送ポイントを介して信頼性の高い受信が完了したことを達成しているかどうかを決定するために使用されます。 NORM_ACK（FLUSH）肯定応答は送信者が受信機のセットの部分に関する情報を有している場合、アプリケーションフロー制御を支援するために使用されるかもしれません。別の事前定義された肯定応答タイプはNORM_ACK（CC）は、明示的NORM-CC動作のために送信者によって送信さNORM_CMD（CC）メッセージに応答して、輻輳制御フィードバックを提供するために使用されます。 NORM_ACK（CC）レスポンスは、ここで説明した肯定応答手順に従っていません。 NORM_CMD（ACK_REQ）とNORM_ACKメッセージが確認応答要求と提供の種類を識別するために、「ack_type」フィールドが含まれています。 「ack_type」の値の範囲は、アプリケーション定義の使用のために提供されます。アプリケーションが応答要求を開始する責任があり、アプリケーション定義の「ack_type」値を解釈しながら、肯定応答手順は、NORM輸送に利用可能なタイミング及び送信スケジューリング情報を利用するために、プロトコルの実装内で行われるべきです。"
    },
    {
      "indent": 3,
      "text": "The NORM Positive Acknowledgment Procedure uses polling by the sender to query the receiver group for response. Note this polling procedure is not intended to scale to very large receiver groups, but could be used in a large group setting to query a critical subset of the group. Either the NORM_CMD(ACK_REQ), or when applicable, the NORM_CMD(FLUSH) message is used for polling and contains a list of NormNodeIds of the receivers expected to respond to the command. The list of receivers providing acknowledgment is determined by the source application with a priori knowledge of participating nodes or via some other application-level mechanism.",
      "ja": "NORM肯定応答手順の応答を受信グループを照会するために送信者によってポーリングを使用しています。このポーリング手順を注意してください非常に大規模な受信機のグループに拡大するものではありませんが、グループの重要なサブセットを照会するために大規模なグループ設定に使用することができます。どちらのNORM_CMD（ACK_REQ）、または該当する場合は、NORM_CMD（FLUSH）メッセージをポーリングするために使用してコマンドに応答することが期待受信機のNormNodeIdsのリストが含まれています。肯定応答を提供する受信機のリストは、参加ノードの先験的知識又は他の何らかのアプリケーションレベルのメカニズムを介してソースアプリケーションによって決定されます。"
    },
    {
      "indent": 3,
      "text": "The ACK process is initiated by the sender generating NORM_CMD(FLUSH) or NORM_CMD(ACK_REQ) messages in periodic rounds. For NORM_ACK(FLUSH) requests, the NORM_CMD(FLUSH) contains a \"object_transport_id\" and \"fec_payload_id\" denoting the watermark transmission point for which acknowledgment is requested. This watermark transmission point is echoed in the corresponding fields of the NORM_ACK(FLUSH) message sent by the receiver in response. NORM_CMD(ACK_REQ) messages contain an \"ack_id\" field that is similarly echoed in response so the sender can match the response to the appropriate request.",
      "ja": "ACK処理は、周期的ラウンドでNORM_CMD（FLUSH）またはNORM_CMD（ACK_REQ）メッセージを生成、送信者によって開始されます。 NORM_ACK（FLUSH）要求の場合、NORM_CMD（FLUSH）が含まれ、確認応答が要求されている電子透かしの送信点を示す「object_transport_id」と「fec_payload_id」。この透かし伝送ポイントが応答して、受信機によって送信されたNORM_ACK（FLUSH）メッセージの対応するフィールドにエコーされます。 NORM_CMD（ACK_REQ）メッセージは、送信者が適切な要求に対する応答を一致させることができるので、同様に応じてエコーさ「ack_id」フィールドを含みます。"
    },
    {
      "indent": 3,
      "text": "In response to the NORM_CMD(ACK_REQ), the listed receivers randomly, with a uniform distribution, transmit NORM_ACK messages over a time window of (1*GRTT_sender). These NORM_ACK messages are typically unicast to the sender. (Note NORM_ACK(CC) messages SHALL be multicast or unicast in the same manner as NORM_NACK messages.)",
      "ja": "NORM_CMD（ACK_REQ）に応答して、リストされている受信機は、ランダムに、均一に分布して、（1 * GRTT_sender）の時間窓にわたってNORM_ACKメッセージを送信します。これらのNORM_ACKのメッセージは通常、送信者にユニキャストされています。 （NORM_ACK（CC）メッセージはNORM_NACKメッセージと同様に、マルチキャストまたはユニキャストされなければならない注意してください。）"
    },
    {
      "indent": 3,
      "text": "The ACK process is self-limiting and avoids ACK implosion because:",
      "ja": "ACKプロセスは自己限定的であるとので、ACK内部破裂を回避します："
    },
    {
      "indent": 3,
      "text": "1. Only a single NORM_CMD(ACK_REQ) message is generated once per (2*GRTT_sender), and",
      "ja": "1つだけNORM_CMD（ACK_REQ）メッセージが一度（2 * GRTT_sender）当たり生成され、そして"
    },
    {
      "indent": 3,
      "text": "2. The size of the \"acking_node_list\" of NormNodeIds from which acknowledgment is requested is limited to a maximum of the sender NormSegmentSize setting per round of the positive acknowledgment process.",
      "ja": "2.確認が要求されたNormNodeIdsの「acking_node_list」のサイズは、肯定応答プロセスのラウンドあたりの送信元NormSegmentSize設定の最大値に制限されます。"
    },
    {
      "indent": 3,
      "text": "Because the size of the included list is limited to the sender's NormSegmentSize setting, multiple NORM_CMD(ACK_REQ) rounds will sometimes be necessary to achieve responses from all receivers specified. The content of the attached NormNodeId list will be dynamically updated as this process progresses and NORM_ACK responses are received from the specified receiver set. As the sender receives valid responses (i.e., matching watermark point or \"ack_id\") from receivers, it SHALL eliminate those receivers from the subsequent NORM_CMD(ACK_REQ) message \"acking_node_list\" and add in any pending receiver NormNodeIds while keeping within the NormSegmentSize limitation of the list size. Each receiver is queried a maximum number of times (NORM_ROBUST_FACTOR, by default). Receivers not responding within this number of repeated requests are removed from the payload list to make room for other potential receivers pending acknowledgment. The transmission of the NORM_CMD(ACK_REQ) is repeated until no further responses are needed or until the repeat threshold is exceeded for all pending receivers. The transmission of NORM_CMD(ACK_REQ) or NORM_CMD(FLUSH) messages to conduct the positive acknowledgment process is multiplexed with ongoing sender data transmissions. However, the NORM_CMD(FLUSH) positive acknowledgment process MAY be interrupted in response to negative acknowledgment repair requests (NACKs) received from receivers during the acknowledgment period. The NORM_CMD(FLUSH) positive acknowledgment process is restarted for receivers pending acknowledgment once any the repairs have been transmitted.",
      "ja": "付属リストのサイズは、送信者のNormSegmentSize設定に制限されているため、複数のNORM_CMD（ACK_REQ）ラウンドは時々、指定されたすべての受信機からの応答を達成するために必要となります。添付NormNodeIdリストの内容は、このプロセスが進むにつれて動的に更新され、NORM_ACK応答は、指定された受信機のセットから受信されています。送信者が受信機から有効な応答（すなわち、一致する透かしポイントまたは「ack_id」）を受信すると、それ以降のNORM_CMD（ACK_REQ）メッセージ「acking_node_list」からの受信機を排除SHALLとのNormSegmentSize制限内に保ちながら、保留中の受信機NormNodeIdsに追加しますリストのサイズ。各受信機は、（デフォルトでは、NORM_ROBUST_FACTOR）最大回数を照会されます。再三の要求のこの数の中に応答しない受信機は承認保留中の他の潜在的な受信機のための余地を作るために、ペイロードリストから削除されます。 NORM_CMD（ACK_REQ）の送信は、それ以上の応答が必要とされなくなるまでか、リピート閾値が保留中のすべての受信機のために超過するまで繰り返されます。肯定応答処理を行うNORM_CMD（ACK_REQ）またはNORM_CMD（FLUSH）メッセージの送信が進行中の送信側データ伝送と多重化されます。しかしながら、肯定応答プロセスが否定応答修復要求（NACK信号）に応答して中断されていてもよいNORM_CMD（FLUSH）は、確認応答期間中に受信機から受信しました。 NORM_CMD（FLUSH）肯定応答プロセスは、任意の修理が送信された後、承認を保留中の受信機のために再起動されます。"
    },
    {
      "indent": 3,
      "text": "In the case of NORM_CMD(FLUSH) commands with an attached \"acking_node_list\", receivers will not ACK until they have received complete transmission of all data up to and including the given watermark transmission point. All receivers SHALL interpret the watermark point provided in the request NACK for repairs if needed as for NORM_CMD(FLUSH) commands with no attached \"acking_node_list\".",
      "ja": "彼らはまでのすべてのデータの完全な送信を受信し、指定された透かしの送信点を含むまでNORM_CMD（FLUSH）の場合には受信機がACKず、添付の「acking_node_list」と指示します。すべてのレシーバはNORM_CMD（FLUSH）用として必要に応じて、修理のために要求NACKで提供透かしポイントなし添付の「acking_node_list」とコマンドを解釈するものとします。"
    },
    {
      "indent": 0,
      "text": "5.5.4. Group Size Estimate",
      "section_title": true,
      "ja": "5.5.4。グループサイズの見積もり"
    },
    {
      "indent": 3,
      "text": "NORM sender messages contain a \"gsize\" field that is a representation of the group size and that is used in scaling random backoff timer ranges. The use of the group size estimate within the NORM protocol does not demand a precise estimation and works reasonably well if the estimate is within an order of magnitude of the actual group size. By default, the NORM sender group size estimate MAY be administratively configured. Also, given the expected scalability of the NORM protocol for general use, a default value of 10,000 is RECOMMENDED for use as the group size estimate. It is also possible the group size MAY be algorithmically approximated from the volume of congestion control feedback messages based on the exponentially weighted random backoff. However, the specification of such an algorithm is currently beyond the scope of this document.",
      "ja": "NORMの送信者のメッセージには、グループサイズの表記である「GSIZE」フィールドを含んでおり、それがランダムバックオフタイマー範囲をスケーリングに使用されています。 NORMプロトコル内グループサイズ推定値の使用は、正確な見積もりを要求し、推定値が実際のグループサイズの大きさのオーダー以内であれば合理的にうまく機能しません。デフォルトでは、NORM送信者グループのサイズ推定値は、管理上構成されるかもしれません。また、一般的な使用のためのNORMプロトコルの予想スケーラビリティを与え、10,000デフォルト値はグループサイズ推定値として使用することをお勧めします。グループのサイズはアルゴリズム指数加重ランダムバックオフに基づく輻輳制御フィードバックメッセージのボリュームから近似することができることも可能です。しかし、このようなアルゴリズムの仕様は、現在、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "6. Configurable Elements",
      "section_title": true,
      "ja": "6.設定可能な要素"
    },
    {
      "indent": 3,
      "text": "The NORM protocol supports a modest number of configurable parameters that control operation. Most of these need only be set at NORM sender(s) and the configuration information is communicated to the receiver set in NORM header and/or header extension fields. A notable exception to this is the NORM_ROBUST_FACTOR that is presumed to be a common value preset among senders and receivers for a given NORM session. The following table summarizes these configurable elements:",
      "ja": "NORMプロトコルが動作を制御する設定可能なパラメータの控えめな数をサポートしています。これらのほとんどは、NORM送信者（複数可）に設定すると、設定情報をNORMヘッダ及び/又はヘッダ拡張フィールドに設定された受信機に伝達されるだけでよいです。これに対する注目すべき例外は、指定されたNORMセッションの送信側と受信側の間で予め設定された共通の値であると推定されるNORM_ROBUST_FACTORあります。次の表は、これらの設定可能な要素をまとめたものです。"
    },
    {
      "indent": 3,
      "text": "+--------------------+----------------------------------------------+\n| Configurable       | Purpose                                      |\n| Element            |                                              |\n+--------------------+----------------------------------------------+\n| Sender initial     | Sender's initial estimate of greatest group  |\n| GRTT Estimate      | round-trip time.  Affects timing of feedback |\n| (GRTT_sender)      | suppression and sender command transmissions |\n|                    | at sender startup.                           |\n| Backoff Factor     | Sender's scaling factor used for timer-based |\n| (K_sender)         | feedback suppression.                        |\n| Group Size         | Sender's rough estimate of receiver group    |\n| Estimate           | size used in generation of random feedback   |\n| (GSIZE_sender)     | backoff timeout.                             |\n| NORM_ROBUST_FACTOR | Integer factor determining how persistently  |\n|                    | (i.e., robust) senders transmit repeated     |\n|                    | control messages and receivers self-initiate |\n|                    | timeout-based NACKing in the absence of      |\n|                    | sender activity.                             |\n| FEC Type           | Sender FEC encoding type.                    |\n| (\"fec_id\")         |                                              |\n| Sender segment     | Maximum size (in bytes) of the payload       |\n| size               | portion of NORM_DATA and other messages.     |\n| (NormSegmentSize)  |                                              |\n| NormNodeId         | Unique identifiers pre-assigned to all NORM  |\n|                    | session participants.                        |\n+--------------------+----------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The sender-controlled GRTT estimate (referred to as GRTT_sender in this document) is used to set and scale various timers associated with NORM protocol operation. During steady-state operation, the sender probes the receiver set, adapts to the group round-trip timing state, and advertises its estimate to the receiver set in the \"grtt\" field of relevant NORM protocol messages. However, an initial value must be assumed at sender startup. A large initial estimate is conservative and safer with regard to preventing feedback implosion and starting up congestion control operation, but requires the sender and receivers to allocate more buffering resources for a given transmission rate (i.e., larger effective delay*bandwidth product) to maintain efficient operation. A default initial value of GRTT_sender = 0.5 seconds is RECOMMENDED.",
      "ja": "（本書でGRTT_senderと呼ばれる）送信者制御GRTT推定はNORMプロトコルの動作に関連する様々なタイマーを設定し、スケーリングするために使われます。定常状態の動作時、送信側は、受信側のセットをプローブ群往復タイミングの状態に適応し、かつ関連するNORMプロトコルメッセージの「GRTT」フィールドに設定され、受信機に、その推定値をアドバタイズ。ただし、初期値は、送信側の起動時に想定されている必要があります。大きな初期推定値は、フィードバック爆縮を防止し、輻輳制御動作を起動に関して保守的で安全であるが、効率的に維持するために与えられた伝送速度（すなわち、より大きな有効遅延*帯域幅積）のためのより多くのバッファリング資源を割り当てるために、送信者と受信機を必要とします操作。 = 0.5秒GRTT_senderのデフォルトの初期値が推奨されます。"
    },
    {
      "indent": 3,
      "text": "The sender-controlled Backoff Factor (referred to a K_sender in this document) is used to scale protocol timers and contributes to the generation of the random backoff timeout value that facilitates timer-based feedback suppression. The sender advertises its configured Backoff Factor to the receiver set in the \"backoff\" field of applicable NORM messages and thus no receiver configuration is necessary. For ASM operation, a default value of K_sender = 4 is",
      "ja": "（本書でK_sender呼ばれる）送信者制御のバックオフ因子は、プロトコルタイマーをスケーリングするために使用され、タイマーベースのフィードバック抑制を容易にランダムバックオフタイムアウト値の生成に寄与する。送信者は、該当NORMメッセージの「バックオフ」フィールドに設定され、受信機にその構成バックオフ因子をアドバタイズし、したがって全く受信機構成は必要ありません。 ASMの動作のために、K_sender = 4のデフォルト値は"
    },
    {
      "indent": 3,
      "text": "RECOMMENDED; for SSM operation, a default value of K_sender = 6 is RECOMMENDED.",
      "ja": "推奨。 SSMの動作のために、K_sender = 6のデフォルト値が推奨されます。"
    },
    {
      "indent": 3,
      "text": "The sender estimate of session Group Size (referred to as GSIZE_sender in this document) also plays a role in the random selection of feedback suppression timeout values. The sender advertises its configured Group Size estimate to the receiver set in the \"gsize\" field of applicable NORM messages; thus, no receiver configuration is necessary. Only a rough estimate (i.e., \"order-of-magnitude\") is needed for effective feedback suppression and a default value of GSIZE_sender = 10,000 is RECOMMENDED as a conservative estimate for most uses.",
      "ja": "（この文書でGSIZE_senderと呼ばれる）は、セッショングループサイズの送信者の推定値はまた、フィードバック抑制タイムアウト値をランダムに選択する役割を果たしています。送信者は、適用NORMメッセージの「GSIZE」フィールドに設定された受信機にその構成されたグループサイズの見積もりをアドバタイズ。従って、いかなる受信機構成は必要ありません。概算（即ち、「オーダーのマグニチュード」）は効果的なフィードバック抑制とGSIZE_sender = 10,000デフォルト値のために必要とされるだけほとんどの用途のための保守的な推定値として推奨されています。"
    },
    {
      "indent": 3,
      "text": "The NORM_ROBUST_FACTOR is an integer parameter that determines how persistently NORM senders transmit control messages (NORM_CMD messages) such as end-of-transmission flushing, OPTIONAL positive acknowledgment requests, etc. Additionally, the receivers use their knowledge of NORM_ROBUST_FACTOR to determine when to consider a NORM sender inactive and MAY use the factor in determining how persistently to self-initiate repeated NACK repair requests upon such timeouts. This parameter is NOT communicated in NORM protocol message headers and is presumed to be preset to a consistent value among sender and receivers for a given NORM session. A default value of NORM_ROBUST_FACTOR = 20 is RECOMMENDED.",
      "ja": "NORM_ROBUST_FACTORはNORMの送信者が検討したときに更に、受信機が決定するNORM_ROBUST_FACTORの知識を使用する等のようなエンドの伝送フラッシングとして（NORM_CMDメッセージ）、OPTIONAL肯定応答要求、制御メッセージを送信する方法を持続的に決定する整数パラメータでありますNORMの送信者、非アクティブとし、このようなタイムアウト時に繰り返しNACKの修理依頼を自己開始どのように持続的に決定する要因を使用するかもしれません。このパラメータは、NORMプロトコルメッセージのヘッダに通信されておらず、所与NORMセッションの送信者と受信機の間で一貫性のある値にプリセットされると推定されます。 NORM_ROBUST_FACTOR = 20のデフォルト値が推奨されます。"
    },
    {
      "indent": 3,
      "text": "Another NORM sender configuration element is the FEC type used to encode NORM_DATA message content. The FEC type is communicated from the sender to the receiver set in the \"fec_id\" field of relevant NORM message headers. The \"fec_id\" value corresponds to an IANA-assigned value identifying the FEC encoding type as described in the FEC Building Block [RFC5052] document. Typically, a sender SHOULD use a consistent FEC encoding for its participation in a session to simplify receiver state allocation and maintenance, but its implementations MAY vary the FEC encoding type on a per-object basis if necessary.",
      "ja": "別のNORM送信側構成要素はNORM_DATAメッセージコンテンツを符号化するために使用されるFECタイプです。 FECタイプは、関連するNORMメッセージヘッダの「fec_id」フィールドに設定送信側から受信側に伝達されます。 「fec_id」値は、FECビルディングブロック[RFC5052]の文書に記載されているようにFEC符号化タイプを識別するIANAによって割り当てられた値に対応します。典型的には、送信者が受信状態の割り当てとメンテナンスを簡素化するためにセッションへの参加のための一貫性のFEC符号化を使用すべきであるが、必要に応じて、その実装は、オブジェクトごとに、FEC符号化タイプを変えることができます。"
    },
    {
      "indent": 3,
      "text": "The sender NormSegmentSize setting determines the maximum size of the payload portion of NORM_DATA and other messages that the sender transmits. Additionally, the payload size of feedback messages from receivers to a given sender is limited to that sender's NormSegmentSize. The NormSegmentSize SHOULD be configured to be compatible with expected network MTU limitations, given the added overhead of NORM, UDP, and IP protocol message headers. Additionally, MTU Discovery MAY be employed by the sender to determine an appropriate NormSegmentSize. The NormSegmentSize for a given sender can be determined by receivers from the FEC Object Transmission Information (FTI) provided either in applied EXT_FTI header extensions or pre-configured session information.",
      "ja": "センダNormSegmentSize設定は、送信者が送信ペイロードNORM_DATAの部分と他のメッセージの最大サイズを決定します。また、受信機から与えられた送信者へのフィードバックメッセージのペイロードサイズは、その送信者のNormSegmentSizeに限定されています。 NormSegmentSizeは、予想されるネットワークのMTUの制限に適合するように構成されたNORM、UDP、およびIPプロトコル・メッセージヘッダーの追加オーバーヘッドを与えられるべきです。また、MTUディスカバリーは、適切なNormSegmentSizeを決定するために、送信者によって使用されてもよいです。所与の送信者のNormSegmentSizeは、FECオブジェクト伝送情報（FTI）から受信することによって決定することができる印加EXT_FTIヘッダ拡張または事前に設定セッション情報のいずれかで提供。"
    },
    {
      "indent": 3,
      "text": "Although it is not technically a configurable element, the receivers MUST have FEC Object Transmission Information for transmitted NormObjects to properly buffer, decode, and reassemble the original content. For loosely organized NORM protocol sessions, the sender MAY apply the EXT_FTI Header Extension to NORM_DATA and NORM_INFO (if applicable) messages so that receivers can get this information without prior coordination. An implementation MAY also apply the EXT_FTI only to NORM_INFO messages for reduced overhead. Finally, applications MAY also provide the FTI out-of-band prior to sender transmission.",
      "ja": "それは技術的構成要素ではないが、受信機は、適切にバッファリングする送信NormObjectsためFECオブジェクト伝送情報を有してデコードし、元のコンテンツを再構築しなければなりません。受信機は事前調整なしにこの情報を得ることができるように緩く組織化NORMプロトコルセッションでは、送信者はNORM_DATAとNORM_INFO（該当する場合）のメッセージにEXT_FTIヘッダー拡張を適用することができます。実装も減少したオーバーヘッドのためにのみNORM_INFOメッセージにEXT_FTIを適用することができます。最後に、アプリケーションは、アウトオブバンドの前に、送信者の送信にFTIを提供することができます。"
    },
    {
      "indent": 3,
      "text": "Each participant in a NORM protocol session MUST be configured with a unique NormNodeId value. The NormNodeId value is used by receivers to identify the sender to which their NACK or other feedback messages are addressed, and senders use the NormNodeId to differentiate receivers for purposes of congestion control and OPTIONAL positive acknowledgment collection. Assignment of unique NormNodeId values can be done via a priori coordination and/or use of a deconfliction mechanism external to the NORM protocol itself. The values of NORM_NODE_NONE = 0x00000000 and NORM_NODE_ANY = 0xffffffff are reserved and MUST NOT be assigned to NORM participants.",
      "ja": "NORMプロトコルセッションで各参加者はユニークなNormNodeId値を設定する必要があります。 NormNodeId値は、そのNACKまたはその他のフィードバックメッセージがアドレス指定されているために、送信者を識別するために受信機によって使用され、送信者は輻輳制御と任意の正の確認応答収集の目的のために受信機を区別するためにNormNodeIdを使用しています。一意NormNodeId値の割り当ては、先験的調整及び/又はNORMプロトコル自体の外部deconflictionメカニズムの使用を介して行うことができます。 NORM_NODE_NONE = 0x00000000のとNORM_NODE_ANY = 0xffffffffとの値が予約されており、NORMの参加者に割り当てることはできません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The same security considerations that apply to the Multicast NACK [RFC5401], TFMCC [RFC4654], and FEC [RFC5052] Building Blocks also apply to the NORM protocol. In addition to the vulnerabilities to which any IP and IP multicast protocol implementation is subject, malicious hosts might engage in excessive NACKing in an attempt to prevent the NORM sender(s) from making forward progress in reliable transmission. Receiver \"join\" and \"service\" policy enforcement as described in Section 5.2 can be applied if such activity is detected. The use of cryptographic peer authentication, integrity checks, and/or confidentiality mechanisms can be used to provide a more effective degree of protection from objectionable transmissions from unauthorized hosts. But in some cases, even with authentication and integrity checks, the NACK-based feedback of NORM can be exploited by replay attacks forcing the NORM sender to unnecessarily transmit repair information. This MAY be addressed in part with network-layer IP security implementations that guard against this potential security exploitation or alternatively with a security mechanism using the EXT_AUTH header extension for similar purposes. Such security mechanisms SHOULD be deployed and used when available. Use of security mechanisms will impose additional \"a priori\" configuration upon the NORM deployment depending upon the techniques used.",
      "ja": "同じマルチキャストNACK [RFC5401]に適用するセキュリティ問題、TFMCC [RFC4654]、およびFEC [RFC5052]ビルディングブロックはまた、NORMプロトコルに適用します。任意のIPおよびIPマルチキャストプロトコルの実装は、被写体された脆弱性に加えて、悪質なホストは、信頼性の高い伝送の前方に進展してからNORM送信者（複数可）を防止しようとして過度NACKingに従事する可能性があります。こうした活動が検出された場合、受信機の第5.2節で説明したように「参加」と「サービス」ポリシーの施行を適用することができます。暗号ピア認証、整合性チェック、および/または機密保持機構の使用は、不正なホストから好ましくない送信からの保護のより効果的な度合いを提供するために使用することができます。しかし、いくつかのケースであっても、認証および整合性チェックで、NORMのNACKベースのフィードバックは不必要に修理情報を送信するためにNORMの送信者を強制的にリプレイ攻撃で悪用される可能性があります。これは、この潜在的なセキュリティの悪用に対して、または代替的に同様の目的のためにEXT_AUTHヘッダ拡張を使用して、セキュリティ・メカニズムを守るネットワーク層のIPセキュリティの実装と部分的に対処することができます。このようなセキュリティメカニズムが配備され、使用可能な場合、使用されてください。セキュリティメカニズムの使用は、使用される技術に応じて、NORMの展開時に、追加の「アプリオリ」の設定を課します。"
    },
    {
      "indent": 3,
      "text": "The NORM protocol is compatible with the use of IP security (IPsec)",
      "ja": "NORMプロトコルは、IPセキュリティ（IPsec）の使用と互換性があります"
    },
    {
      "indent": 3,
      "text": "[RFC4301], and the IPsec Encapsulating Security Payload (ESP) protocol or Authentication Header (AH) extension can be used to secure IP packets transmitted by NORM participants. A baseline approach to secure NORM operation using IPsec is described below. Compliant implementations of this specification are REQUIRED to be compatible with IPsec usage as described in Section 7.1. IPsec can be used to provide peer authentication, integrity protection, and/or encryption of packets containing NORM messages.",
      "ja": "[RFC4301]、およびIPsecカプセル化セキュリティペイロード（ESP）プロトコルまたは認証ヘッダ（AH）拡張子はNORM参加者によって送信されたIPパケットを保護するために使用することができます。 IPsecを使用してNORM演算を確保するためのベースラインアプローチについて説明します。この仕様の準拠実装はセクション7.1に記載したようにIPsecの使用に適合するように要求されています。 IPsecは、ピア認証、完全性保護、および/またはNORMメッセージを含むパケットの暗号化を提供するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Additionally, the EXT_AUTH header extension (HET = 1) is reserved for use by security mechanisms to provide alternatives to IPsec for the security of NORM messages. The format of this header extension and its processing is outside the scope of this document and is to be communicated out-of-band as part of the session description. It is possible an EXT_AUTH implementation MAY also provide for encryption of NORM message payloads as well as peer authentication and integrity protection. The use of this approach as compared to IPsec can allow for header compression techniques to be applied jointly to IP and NORM protocol headers. In cases where security analysis deems encryption of NORM protocol header content to be beneficial or necessary, the aforementioned use of IPsec ESP might be more appropriate. Additionally, the EXT_AUTH header extension can be utilized when NORM is implemented in a network with Network Address Translation (NAT) systems that are incompatible with use of the IPsec AH extension. If EXT_AUTH is present, whatever packet authentication or integrity checks that can be performed immediately upon reception of the packet MUST be performed before accepting the packet and performing any congestion-control-related action on it. Some packet authentication schemes impose a delay of several seconds between when a packet is received and when the packet can be fully authenticated. Any appropriate congestion control related action MUST NOT be postponed by any such packet security mechanism (i.e., security mechanisms MUST NOT result in poor congestion control behavior).",
      "ja": "また、EXT_AUTHヘッダ拡張（HET = 1）NORMメッセージのセキュリティのためのIPsecの代替を提供するために、セキュリティメカニズムによる使用のために予約されます。このヘッダー拡張とその処理の形式は、この文書の範囲外であるとセッション記述の一部として、アウトオブバンド通信されます。 EXT_AUTHの実装もNORMメッセージペイロードの暗号化だけでなく、ピア認証と完全性保護を提供することができる可能です。 IPsecのと比較して、このアプローチの使用は、IPとNORMプロトコルヘッダに共同適用されるヘッダ圧縮技術を可能にすることができます。セキュリティ分析はNORMプロトコルヘッダの内容の暗号化が有益または必要であると認める場合には、IPsecのESPの前述の使用がより適切かもしれません。 NORMは、IPsecのAH拡張の使用と互換性のないネットワークアドレス変換（NAT）システムとネットワークに実装された場合、さらに、EXT_AUTHヘッダ拡張を利用することができます。 EXT_AUTHが存在する場合、パケットの受信時に即座に行うことができるどのようなパケット認証または整合性チェックはパケットを受け入れ、その上の任意の輻輳制御に関連するアクションを実行する前に実行しなければなりません。いくつかのパケットの認証方式は、パケットを受信したときに、パケットが完全に認証することができたときの間に、数秒の遅延を課します。任意の適切な輻輳制御に関連するアクションは、任意のそのようなパケットのセキュリティメカニズムによって延期されてはいけません（すなわち、セキュリティメカニズムは、貧弱な輻輳制御動作が発生してはいけません）。"
    },
    {
      "indent": 3,
      "text": "Consideration MUST also be given to the potential for replay-attacks that would transplant authenticated packets from one NORM session to another to disrupt service. To avoid this potential, unique keys SHOULD be assigned on a per-session basis or NORM sender nodes SHOULD be configured to use unique \"instance_id\" identifiers managed as part of the security association for the sessions.",
      "ja": "対価は、サービスを中断させるために別のNORMセッションから認証されたパケットを移植うリプレイ攻撃の可能性を与えなければなりません。この可能性を回避するために、独自のキーは、セッションごとまたはNORM送信ノードに割り当てる必要がありますが、セッションのためのセキュリティアソシエーションの一部として管理ユニークな「INSTANCE_ID」の識別子を使用するように設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note NORM implementations can use the \"sequence\" field from the NORM common message header to detect replay attacks. This can be accomplished if the NORM sender maintains state on actively NACKing receivers. A cache of such receiver state can be used to provide protection against NACK replay attacks. NORM receivers MUST also maintain similar state for protection against possible replay of other receiver messages in ASM operation as well. For example, a receiver could be suppressed from providing NACK or congestion control feedback by replay of certain receiver messages. For these reasons, authentication of NORM messages (e.g., via IPsec) SHOULD be applied for protection against similar attacks that use fabricated messages. Also, encryption of messages to provide confidentiality of application data and protect privacy of users MAY also be applied using IPsec or similar mechanisms.",
      "ja": "注NORM実装はリプレイ攻撃を検出するために、NORM共通メッセージヘッダから「配列」フィールドを使用することができます。 NORMの送信者が積極的に受信機をNACKingに状態を維持した場合にこれが実現することができます。このような受信機の状態のキャッシュは、NACKのリプレイ攻撃に対する保護を提供するために使用することができます。 NORM受信機はまた、同様にASM動作における他の受信メッセージの可能リプレイに対する保護のための同様の状態を維持しなければなりません。例えば、受信機は、特定の受信メッセージの再生により、NACK又は輻輳制御フィードバックを提供するのを抑制することができます。これらの理由から、（IPsecの経由など、）NORMメッセージの認証を作製したメッセージを使用して同様の攻撃に対する保護のために適用されるべきです。また、アプリケーションデータの機密性を提供し、ユーザーのプライバシーを保護するために、メッセージの暗号化はまた、IPsecのまたは類似のメカニズムを使用して適用することができます。"
    },
    {
      "indent": 3,
      "text": "When applicable security measures are used, automated key management mechanisms such as those described in the Group Domain of Interpretation (GDOI) [RFC3547], Multimedia Internet KEYing (MIKEY) [RFC3830], or Group Secure Association Key Management Protocol (GSAKMP) [RFC4535] specifications SHOULD be applied.",
      "ja": "そのような解釈のグループドメイン（GDOI）に記載されているものとして適用可能なセキュリティ対策が使用され、自動化された鍵管理メカニズム[RFC3547]、マルチメディアインターネットキーイング（MIKEY）[RFC3830]、またはグループセキュア協会鍵管理プロトコル（GSAKMP）[RFC4535 ]仕様が適用されるべきです。"
    },
    {
      "indent": 3,
      "text": "While NORM does leverage FEC-based repair for scalability, this alone does not guarantee integrity of received data. Application-level integrity-checking of received data content is highly RECOMMENDED. This recommendation also applies when the IPsec security approach described below is used for added assurance in data content integrity given the shared use of IPsec Security Association information among the group.",
      "ja": "NORMは、スケーラビリティのためのFECベースの修理を活用していますが、これだけでは、受信したデータの整合性を保証するものではありません。受信したデータの内容のアプリケーションレベルの整合性チェックが強く推奨されます。下記のIPsecセキュリティアプローチは、グループ間のIPsecセキュリティアソシエーション情報の共同利用与えられたデータ内容の整合性で追加保証のために使用されている場合は、この勧告にも適用されます。"
    },
    {
      "indent": 0,
      "text": "7.1. Baseline Secure NORM Operation",
      "section_title": true,
      "ja": "7.1。ベースラインセキュアNORM操作"
    },
    {
      "indent": 3,
      "text": "This section describes a baseline mode of secure NORM protocol operation based on application of the IPsec security protocol. This approach is documented here to provide a baseline interoperable secure mode of operation. This particular approach represents one possible trade-off in the level of assurance that can be achieved and the scalability of multicast group-size given current IPsec mechanisms and the state required to support them. For example, this baseline approach specifies the use of a Security Association that is shared among the receiver set for feedback messages to the sender. This model requires that the receiver membership receiving the session keys is trusted and only provides protection from attacks that are external to the NORM group membership. More stateful and complex IPsec approaches and key management schemes may be applied for higher levels of assurance, but those are beyond the scope of this transport protocol specification. Additional approaches to NORM security, including other forms of IPsec application, MAY be specified in the future. For example, the use of the EXT_AUTH header extension could enable NORM-specific authentication or security encapsulation headers similar to those of IPsec to be specified and inserted into the NORM protocol message headers. This would allow header compression techniques to be applied to IP and NORM protocol headers when needed in a similar fashion to RTP [RFC3550] and as preserved in the specification for Secure Real Time Protocol (SRTP) [RFC3711].",
      "ja": "このセクションでは、IPsecセキュリティプロトコルのアプリケーションに基づいて、セキュアNORMプロトコル操作のベースラインモードを記述する。このアプローチは、操作のベースラインの相互運用可能セキュアモードを提供するために、ここに記載されています。この特定のアプローチは、一つの可能​​な実現することができる保証のレベルのトレードオフとマルチキャストグループサイズ与えられた電流のIPsecメカニズムのスケーラビリティおよびそれらをサポートするために必要な状態を表します。例えば、このベースラインアプローチは、送信者へのフィードバックメッセージに設定された受信機間で共有されているセキュリティアソシエーションの使用を指定します。このモデルは、セッションキーを受信する受信機のメンバーシップは、信頼できるとだけNORMグループメンバーシップの外部にある攻撃からの保護を提供していることが必要です。よりステートフルおよび複合のIPsecアプローチ及び鍵管理スキームは、保証の高いレベルのために適用することができるが、それらは、このトランスポートプロトコル仕様の範囲を超えています。 IPsecのアプリケーションの他の形態を含むNORMのセキュリティへのさらなるアプローチは、将来的に指定することができます。例えば、EXT_AUTHヘッダ拡張を使用することは、指定されたとNORMプロトコルメッセージのヘッダに挿入するのIPsecと同様のNORM固有の認証またはセキュリティカプセル化ヘッダを可能にすることができます。これは、ヘッダ圧縮技術がRTP [RFC3550]と同様に、必要なときにIPとNORMプロトコルヘッダに適用することができるようになるセキュアリアルタイムプロトコル（SRTP）[RFC3711]の仕様に保存されます。"
    },
    {
      "indent": 3,
      "text": "The baseline approach described is applicable to NORM operation configured for SSM (or SSM-like) operation where there is a single sender and the receivers are providing unicast feedback. This form of NORM operation allows for IPsec to be used with a manageable number of security associations (SA).",
      "ja": "が単一の送信者であり、受信機がユニキャストフィードバックを提供している場合について説明したベースラインのアプローチは、SSM（またはSSMのような）動作のために構成されたNORM演算にも適用可能です。 IPsecはセキュリティアソシエーション（SA）の管理可能な数で使用するためNORM演算のこの形態は可能。"
    },
    {
      "indent": 0,
      "text": "7.1.1. IPsec Approach",
      "section_title": true,
      "ja": "7.1.1。 IPsecのアプローチ"
    },
    {
      "indent": 3,
      "text": "For NORM one-to-many SSM operation with unicast feedback from receivers, each node SHALL be configured with two transport mode IPsec security associations and corresponding Security Policy Database (SPD) entries. One entry will be used for sender-to-group multicast packet authentication and optionally encryption while the other entry will be used to provide security for the unicast feedback messaging from the receiver(s) to the sender. Note that this single SA for NORM receiver feedback messages is shared to protect traffic from possibly multiple receivers to the single sender.",
      "ja": "NORM一対多SSM動作受信機からのユニキャストフィードバックを有するため、各ノードは、二つのトランスポート・モードのIPsecセキュリティアソシエーションを使用して構成されるものとし、対応するセキュリティポリシーデータベース（SPD）エントリ。他のエントリが送信側に受信側（S）からメッセージングユニキャストフィードバックのためのセキュリティを提供するために使用され、一方のエントリは、送信者とグループのマルチキャストパケットの認証および必要に応じて暗号化に使用されます。 NORM受信機フィードバックメッセージのためにこの単一のSAは、単一の送信者に場合によっては複数の受信機からのトラフィックを保護するために共有されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "For each NormSession, the NORM sender SHALL use an IPsec SA configured for ESP protocol [RFC4303] operation with the option for data origin authentication enabled. It is also RECOMMENDED this IPsec ESP SA be also configured to provide confidentiality protection for IP packets containing NORM protocol messages. This is suggested to make the realization of complex replay attacks much more difficult. The encryption key for this SA SHALL be preplaced at the sender and receiver(s) prior to NORM protocol operation. Use of automated key management is RECOMMENDED as a rekey SHALL be REQUIRED prior to expiration of the sequence space for the SA. This is necessary so receivers can use the built-in IPsec replay attack protection possible for an IPsec SA with a single source (the NORM sender). Thus, the receivers SHALL enable replay attack protection for this SA used to secure NORM sender traffic. An IPsec SPD entry MUST be configured to process outbound packets to the session (destination) address and UDP port number of the applicable (NormSession).",
      "ja": "各NormSessionため、NORMの送信者は、有効データ発信元認証のためのオプションとESPプロトコル[RFC4303]動作するように構成さのIPsec SAを使用しなければなりません。また、このIPsecのESP SAもNORMプロトコルメッセージを含むIPパケットの機密性保護を提供するように構成することが推奨されます。これは、複雑なリプレイ攻撃の実現がはるかに困難にすることが示唆されています。このSAの暗号化キーは、送信者と受信者（複数可）NORMプロトコル動作の前に予め配置されるものとします。リキーがSAのためのシーケンス空間の満了前に要するものとして、自動化された鍵管理の使用が推奨されます。受信機は、単一のソース（NORMの送信者）とのIPsec SAのための可能なIPsecの組み込みのリプレイ攻撃からの保護を使用できるようにするために必要です。このSAはNORMの送信元トラフィックを保護するために使用するためにこのように、受信機は、リプレイ攻撃からの保護を有効にするものとします。 IPsecのSPDエントリはセッション（宛先）アドレスと該当のUDPポート番号（NormSession）に発信パケットを処理するように構成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The NORM receiver(s) MUST be configured with the SA and SPD entry to properly process the IPsec-secured packets from the sender. The NORM receiver(s) SHALL also use a common, second IPsec SA (common Security Parameter Index (SPI) and encryption key) configured for ESP operation with the option for data origination authentication enabled. Similar to the NORM sender, is RECOMMENDED this IPsec ESP SA be also configured to provide confidentiality protection for IP packets containing NORM protocol messages. The receivers MUST have an IPsec SPD entry configured to process outbound NORM/UDP packets directed to the NORM sender source address and port number using this second SA. To support NORM unicast feedback, the sender's transmission port number SHOULD be selected to be distinct from the multicast session port number to allow discrimination between unicast and multicast feedback messages when access to the IP destination address is not possible (e.g., a user-space NORM implementation). For processing of packets from receivers, the NORM sender SHALL be configured with this common, second SA (and the corresponding SPD entry needed) in order to properly process messages from the receiver.",
      "ja": "NORM受信機（単数または複数）は、適切に、送信者からのIPsec-固定パケットを処理するSAとSPDエントリを設定する必要があります。 NORMの受信機（複数可）も有効にデータの発信認証のためのオプションを使用してESP動作に設定共通、第二のIPsec SA（共通セキュリティパラメータインデックス（SPI）と暗号化キー）を使用しなければなりません。 NORMの送信者と同様に、このIPsecのESP SAもNORMプロトコルメッセージを含むIPパケットの機密性保護を提供するように構成することが推奨されます。受信機は、この第2のSAを使用してNORMの送信元の送信元アドレスとポート番号に向けられたアウトバウンドNORM / UDPパケットを処理するように構成されたIPsec SPDエントリを持たなければなりません。 IP宛先アドレスへのアクセスが（例えば、ユーザ空間のNORMができない場合NORMユニキャストフィードバックをサポートするために、送信者の送信ポート番号は、ユニキャストとマルチキャストのフィードバックメッセージの間の識別を可能にするマルチキャストセッションのポート番号とは異なるものに選択されるべきです実装）。受信機からのパケットの処理のために、NORMの送信者が正しく受信側からのメッセージを処理するためにこの共通の、第二のSA（および必要に応じて、対応するSPDエントリ）で構成するものとします。"
    },
    {
      "indent": 3,
      "text": "Multiple receivers using a common IPsec SA for traffic directed to the NORM sender (i.e., many-to-one) typically prevents the use of built-in IPsec replay attack protection by the NORM sender with current IPsec implementations. Thus the built-in IPsec replay attack protection for this second SA at the sender MUST be disabled unless the particular IPsec implementation manages its replay protection on a per-source basis (which is not typical of existing IPsec implementations). So, to support a fully secure mode of operation, the NORM sender implementation MUST provide replay attack protection based upon the \"sequence\" field of NORM protocol messages from receivers. This can be accomplished with a high assurance of security, even with the limited size (16-bits) of this field, because:",
      "ja": "NORM送信者に向けられたトラフィックのための共通のIPsec SAを使用して、複数の受信機（すなわち、多対一）は、典型的には、現在のIPsec実装とNORM送信者によって内蔵IPsecのリプレイ攻撃に対する保護の使用を妨げます。特定のIPsec実装は、（既存のIPsec実装の一般的ではありません）ごとのソースベースでの再生保護を管理しない限り、このように内蔵された送信側でこの第二のSA用のIPsecリプレイ攻撃からの保護を無効にする必要があります。だから、操作の完全セキュア・モードをサポートするために、NORMの送信側の実装では、受信機からNORMプロトコルメッセージの「配列」フィールドに基づいて、リプレイ攻撃に対する保護を提供しなければなりません。これは、もこの分野の限られたサイズ（16ビット）で、セキュリティの高い保証を用いて達成することができます。"
    },
    {
      "indent": 3,
      "text": "1. NORM receiver NACK and non-CLR ACK feedback messages are sparse.",
      "section_title": true,
      "ja": "1. NORMレシーバNACKと非CLR ACKフィードバックメッセージはまばらで。"
    },
    {
      "indent": 3,
      "text": "2. The more frequent NORM_ACK feedback from CLR or PLR nodes is only a small set of receivers for which the sender needs to keep more persistent replay attack state.",
      "ja": "2. CLRまたはPLRのノードからより頻繁NORM_ACKのフィードバックは、送信者が、より持続的なリプレイ攻撃状態を維持する必要があるため、受信機の唯一の小さなセットです。"
    },
    {
      "indent": 3,
      "text": "3. NORM_NACK feedback messages preceding the sender's current repair window do not significantly impact protocol operation (generation of NORM_CMD(SQUELCH) is limited) and could be in fact ignored. This means the sender can prune any replay attack state that precedes the current repair window.",
      "ja": "送信者の現在の修理窓の前に3 NORM_NACKフィードバックメッセージが大幅プロトコルの動作に影響を与えません（NORM_CMDの世代（SQUELCH）が限られている）、無視事実である可能性があります。これは、送信者が、現在の修理窓の前に任意のリプレイ攻撃状態を剪定できることを意味します。"
    },
    {
      "indent": 3,
      "text": "4. NORM_ACK messages correspond to either a specific sender \"ack_id\", the sender \"cc_sequence\" for ACKs sent in response to NORM_CMD(CC), or the sender's current repair window in the case of ACKs sent in response to NORM_CMD(FLUSH). Thus, the sender can prune any replay attack state for receivers that precede the current applicable sequence or repair window space.",
      "ja": "4. NORM_ACKメッセージは、特定の送信者「ack_id」、NORM_CMD（CC）に応答して送信されたACKの送信者「cc_sequence」、またはNORM_CMD（FLUSH）に応答して送信されたACKの場合には、送信者の現在の修復ウィンドウのいずれかに対応します。したがって、送信者は現在、適用順序や修理窓のスペースの前に受信機のための任意リプレイ攻撃状態を剪定することができます。"
    },
    {
      "indent": 3,
      "text": "The use of ESP confidentiality for secure NORM protocol operation makes it more difficult for adversaries to conduct any form of replay attacks. Additionally, a NORM sender implementation with access to the full ESP protocol header could also use the ESP sequence information to make replay attack protection even more robust by maintaining the per-source ESP sequence state that existing IPsec implementations typically do not provide. The design of this baseline security approach for NORM intentionally places any more complex processing state or processing (e.g., replay attack protection given multiple receivers) at the NORM sender since NORM receiver implementations might often need to be less complex.",
      "ja": "敵は、リプレイ攻撃のいずれかの形式を実施するための安全なNORMプロトコルの動作のためのESPの機密性の使用は、それがより困難にします。さらに、また、既存のIPsec実装が一般的に提供していないあたり、ソースESPのシーケンス状態を維持することにより、リプレイ攻撃からの保護をより強固にするためにESPの配列情報を使用することができ、完全なESPプロトコルヘッダへのアクセス権を持つNORM送信者の実装。 NORM受信機の実装は、多くの場合、より複雑であることが必要かもしれないのでNORMは、このベースラインセキュリティアプローチの設計は、意図的にNORM送信側で任意のより複雑な処理状態や処理（複数の受信機を与え、例えば、リプレイ攻撃からの保護）を配置します。"
    },
    {
      "indent": 3,
      "text": "This baseline approach can be used for NORM protocol sessions with multiple senders if the SA pairs described are established for each sender. For small-sized groups, it is even possible many-to-many (ASM) IPsec configuration could be achieved where each participant uses a unique SA (with a unique SPI). In this case, the sender(s) would maintain an SA for each other participant rather than a single, shared SA for receiver feedback messages. This does not scale to larger group sizes given the complex set of SA and SPD entries each participant would need to maintain.",
      "ja": "説明SA対が各センダのために確立されている場合は、このベースラインアプローチは、複数の送信者とNORMプロトコルセッションのために使用することができます。各参加者は、（固有のSPIとの）一意のSAを使用する場合、小型のグループのために、それは多対多であっても可能である（ASM）IPsec構成を達成することができました。この場合には、送信者（単数または複数）が互いに参加者ではなく、単一のためのSAを維持する、受信機フィードバックメッセージのためのSAを共有しました。これは、各参加者が維持する必要があるだろうSAとSPDエントリーの複雑な一連の与えられた大きなグループサイズに拡張できません。"
    },
    {
      "indent": 3,
      "text": "It is anticipated in early deployments of this baseline approach to NORM security that key management will be conducted out-of-band with respect to NORM protocol operation. In the case of one-to-many NORM operation, it is possible receivers will retrieve keying information from a central server as needed or otherwise conduct group key updates with a similar centralized approach. Alternatively, it is possible with some key management schemes for rekey messages to be transmitted to the group as a message or transport object within the NORM reliable transfer session. Similarly, for group-wise communication sessions, it is possible for potential group participants to request keying and/or rekeying as part of NORM communications. Additional specification is necessary to define an in-band key management scheme for NORM sessions perhaps using the mechanisms of the automated group key management specifications cited in this document. Additional specification outside of the scope of this document would be needed to provide an interoperable approach for key management in-band of a NORM reliable transport session.",
      "ja": "鍵管理がNORMプロトコルの動作に関して、アウト・オブ・バンドに行われることをNORMのセキュリティにこのベースラインアプローチの早い展開で予想されます。一対多NORM動作の場合には、受信機は、必要に応じて中央サーバから情報を取得するキーイングまたは他の同様の集中型アプローチとグループ鍵の更新を実施することが可能です。あるいは、NORM信頼転送セッション内のメッセージまたは輸送対象としてグループに送信するための再入力メッセージのためのいくつかのキー管理方式で可能です。同様に、グループごとの通信セッションのために、NORM通信の一部として、キーイングおよび/または再キーイングを要求する可能性のあるグループの参加者のために可能です。追加の仕様は、おそらくこの文書において引用自動グループ鍵管理仕様のメカニズムを使用してNORMセッションのインバンドの鍵管理方式を定義する必要があります。この文書の範囲外の追加の仕様は、帯域内NORM信頼性の高いトランスポートセッションの鍵管理のための相互運用可能なアプローチを提供するために必要とされるであろう。"
    },
    {
      "indent": 0,
      "text": "7.1.2. IPsec Requirements",
      "section_title": true,
      "ja": "7.1.2。 IPsecの要件"
    },
    {
      "indent": 3,
      "text": "In order to implement this secure mode of NORM protocol operation, the following IPsec capabilities are REQUIRED.",
      "ja": "NORMプロトコルの動作のこのセキュアモードを実装するために、次のIPsec機能が必要です。"
    },
    {
      "indent": 0,
      "text": "7.1.2.1. Selectors",
      "section_title": true,
      "ja": "7.1.2.1。セレクタ"
    },
    {
      "indent": 3,
      "text": "The implementation MUST be able to use the source address, destination address, protocol (UDP), and UDP port numbers as selectors in the SPD.",
      "ja": "実装は、SPDのセレクタとして、送信元アドレス、宛先アドレス、プロトコル（UDP）、およびUDPポート番号を使用することができなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.1.2.2. Mode",
      "section_title": true,
      "ja": "7.1.2.2。モード"
    },
    {
      "indent": 3,
      "text": "IPsec in transport mode MUST be supported. The use of IPsec [RFC4301] processing for secure NORM traffic MUST be configured such",
      "ja": "トランスポートモードのIPsecをサポートしなければなりません。セキュアNORMトラフィックのためにIPsec [RFC4301]の処理の使用は、構成されなければなりません"
    },
    {
      "indent": 3,
      "text": "that unauthenticated packets are not received by the NORM protocol implementation.",
      "ja": "認証されていないパケットはNORMプロトコル実装によって受信されません。"
    },
    {
      "indent": 0,
      "text": "7.1.2.3. Key Management",
      "section_title": true,
      "ja": "7.1.2.3。キー管理"
    },
    {
      "indent": 3,
      "text": "An automated key management scheme for group key distribution and rekeying such as GDOI [RFC3547], GSAKMP [RFC4535], or MIKEY [RFC3830] is RECOMMENDED for use. Note it is possible for key update messages (e.g., the GDOI GROUPKEY-PUSH message) to be included as part of the NORM application reliable data transmission if appropriate interfaces are available between the NORM application and the key management daemon. Relatively short-lived NORM sessions MAY be able to use Manual Keying with a single, preplaced key, particularly if Extended Sequence Numbering (ESN) [RFC4303] is available in the IPsec implementation used. When manual keys are used, it is important that cryptographic algorithms suitable for manual key use are selected.",
      "ja": "そのようなGDOI [RFC3547]、GSAKMP [RFC4535]、またはMIKEY [RFC3830]としてグループ鍵配布およびリキーための自動化された鍵管理スキームを使用することをお勧めします。適切なインターフェイスがNORMアプリケーションと鍵管理デーモンの間で利用可能である場合、キー更新メッセージ（例えば、GDOI GROUPKEY-PUSHメッセージ）NORMアプリケーション信頼性のあるデータ送信の一部として含めることがすることが可能であることに注意してください。比較的短命NORMセッションは拡張シーケンス番号（ESN）[RFC4303]を使用するIPsec実装で利用可能である場合は特に、単一の、予め配置キーと手動キーイングを使用することができる場合があり。手動キーが使用されている場合は、手動キーの使用に適した暗号アルゴリズムが選択されていることが重要です。"
    },
    {
      "indent": 0,
      "text": "7.1.2.4. Security Policy",
      "section_title": true,
      "ja": "7.1.2.4。セキュリティポリシー"
    },
    {
      "indent": 3,
      "text": "Receivers MUST accept protocol messages only from the designated, authorized sender(s). Appropriate key management will provide authentication, integrity and/or encryption keys only to receivers authorized to participate in a designated session. The approach outlined here allows receiver sets to be controlled on a per-sender basis.",
      "ja": "レシーバは、指定、認可送信者（複数可）からのプロトコルメッセージを受け入れなければなりません。適切な鍵管理は、指定セッションに参加することを許可受信者に認証、完全性および/または暗号化キーを提供します。ここで概説したアプローチは、受信機セットごとの送信者に基づいて制御されることを可能にします。"
    },
    {
      "indent": 0,
      "text": "7.1.2.5. Authentication and Encryption",
      "section_title": true,
      "ja": "7.1.2.5。認証と暗号化"
    },
    {
      "indent": 3,
      "text": "Large NORM group sizes will necessitate some form of key management that does rely upon shared secrets. The GDOI and GSAKMP protocols mentioned here allow for certificate-based authentication. It is RECOMMENDED these certificates use IP addresses for authentication.",
      "ja": "大NORMグループのサイズは、共有秘密に依存しないキー管理のいくつかのフォームを必要とします。ここで述べGDOIとGSAKMPプロトコルは、証明書ベースの認証を可能とします。これらの証明書は、認証のためのIPアドレスを使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "7.1.2.6. Availability",
      "section_title": true,
      "ja": "7.1.2.6。可用性"
    },
    {
      "indent": 3,
      "text": "The IPsec requirements profile outlined here is commonly available on many potential NORM hosts. Configuration and operation of IPsec typically requires privileged user authorization. Automated key management implementations are typically configured with the privileges necessary to affect system IPsec configuration.",
      "ja": "ここで説明するIPsecの要件プロファイルは、多くの潜在的NORMのホスト上で一般的に利用可能です。設定とIPsecの動作は、通常、特権ユーザの認証が必要です。自動鍵管理の実装は、通常、システムのIPsecの設定に影響を与えるために必要な権限が設定されています。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Values of NORM Header Extension Types, Stream Control Codes, and NORM_CMD message sub-types are subject to IANA registration. They are in the registry named \"Reliable Multicast Transport (RMT) NORM Protocol Parameters\" available from http://www.iana.org.",
      "ja": "NORMヘッダ拡張タイプ、ストリーム制御コード、及びNORM_CMDメッセージサブタイプの値は、IANA登録の対象となっています。彼らは、「信頼できるマルチキャストトランスポート（RMT）NORMプロトコル・パラメータ」http://www.iana.orgから入手可能という名前のレジストリです。"
    },
    {
      "indent": 3,
      "text": "Note the reliable multicast building block components used by this specification also have their respective IANA considerations, and those documents SHOULD be consulted accordingly. In particular, the FEC Building Block used by NORM does REQUIRE IANA registration of the FEC codecs used. The registration instructions for FEC codecs are provided in RFC 5052. It is possible additional extensions of the NORM protocol might be specified in the future (e.g., additional NORM message types) and additional registries be established at that time with appropriate IETF standards action.",
      "ja": "この仕様で使用される信頼性の高いマルチキャストビルディング・ブロック・コンポーネントも、それぞれのIANAの考慮事項がありますし、それらの文書はそれに応じて相談する必要があります。特に、NORMで使用されるFECビルディングブロックを使用FECコーデックのIANA登録が必要です。 FECコーデックの登録手順は、NORMプロトコルの追加の拡張機能は、将来（例えば、追加のNORMメッセージタイプ）で指定されるかもしれないと追加のレジストリが適切なIETF標準アクションで、その時点で確立することが可能であるRFC 5052で提供されています。"
    },
    {
      "indent": 0,
      "text": "8.1. Explicit IANA Assignment Guidelines",
      "section_title": true,
      "ja": "8.1。明示的なIANAの割り当てのガイドライン"
    },
    {
      "indent": 3,
      "text": "This document introduces three registries for the NORM Header Extension Types, Stream Control Codes, and NORM_CMD Message sub-types. This section describes explicit IANA assignment guidelines for each of these.",
      "ja": "この文書では、NORMヘッダ拡張タイプ、ストリーム制御コード、およびNORM_CMDメッセージサブタイプのための3つのレジストリを紹介しています。このセクションでは、これらのそれぞれについて、明示的なIANAの割り当てのガイドラインについて説明します。"
    },
    {
      "indent": 0,
      "text": "8.1.1. NORM Header Extension Types",
      "section_title": true,
      "ja": "8.1.1。 NORMヘッダ拡張タイプ"
    },
    {
      "indent": 3,
      "text": "This document defines a registry for NORM Header Extensions named \"NORM Header Extension Types\".",
      "ja": "この文書は、「NORMヘッダ拡張タイプ」という名前のNORMヘッダの拡張機能のレジストリを定義します。"
    },
    {
      "indent": 3,
      "text": "The NORM Header Extension Type field is an 8-bit value. The values of this field identify extended header content allowing the protocol functionality to be expanded to include additional features and operating modes. The values that can be assigned within the \"NORM Header Extensions\" registry are numeric indexes in the range {0, 255}, boundaries included. Values in the range {0,127} indicate variable-length extended header fields while values in the range {128,255} indicate extensions of a fixed 4-byte length. This specification registers the following NORM Header Extension Types:",
      "ja": "NORMヘッダ拡張タイプフィールドは、8ビットの値です。このフィールドの値は、プロトコル機能は、追加の特徴および動作モードを含むように拡張されることを可能にする拡張ヘッダーの内容を識別します。 「NORMヘッダの拡張」レジストリ内で割り当て可能な値が範囲{0、255}の数値のインデックスであり、境界が含まれます。範囲{128255}の値が固定された4バイト長の延長を示しながら、範囲{0127}の値は、可変長拡張ヘッダフィールドを示します。この仕様は、次のNORMヘッダの拡張タイプを登録します。"
    },
    {
      "indent": 17,
      "text": "+-------+----------+--------------------+\n| Value | Name     | Reference          |\n+-------+----------+--------------------+\n| 1     | EXT_AUTH | This specification |\n| 3     | EXT_CC   | This specification |\n| 64    | EXT_FTI  | This specification |\n| 128   | EXT_RATE | This specification |\n+-------+----------+--------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Requests for assignment of additional NORM Header Extension Type values are granted on a \"Specification Required\" basis as defined by IANA Guidelines [RFC5226]. Any such header extension specifications MUST include a description of protocol actions to be taken when the extension type is encountered by a protocol implementation not supporting that specific option. For example, it is often possible for protocol implementations to ignore unknown header extensions.",
      "ja": "IANAガイドライン[RFC5226]で定義されている追加のNORMヘッダ拡張タイプ値の割り当ての要求は、「仕様が必要」に基づき付与されます。任意のこのようなヘッダ拡張仕様は、拡張タイプがその特定のオプションをサポートしないプロトコル実装が遭遇されたときに取るべきプロトコルアクションの記述を含まなければなりません。プロトコル実装が未知のヘッダ拡張を無視するため、例えば、それはしばしば可能です。"
    },
    {
      "indent": 0,
      "text": "8.1.2. NORM Stream Control Codes",
      "section_title": true,
      "ja": "8.1.2。 NORMストリーム制御コード"
    },
    {
      "indent": 3,
      "text": "This document defines a registry for NORM Stream Control Codes named \"NORM Stream Control Codes\".",
      "ja": "この文書は、「NORMストリーム制御コード」という名前NORMストリーム制御コードのレジストリを定義します。"
    },
    {
      "indent": 3,
      "text": "NORM Stream Control Codes are 16-bit values that can be inserted within a NORM_OBJECT_STREAM delivery object to convey sequenced, out-of-band (with respect to the stream data) control signaling applicable to the referenced stream object. These control codes are to be delivered to the application or protocol implementation with reliable delivery, in-order with respect to the their inserted position within the stream. This specification registers the following NORM Stream Control Code:",
      "ja": "NORMストリーム制御コードは、参照ストリームオブジェクトに適用可能なシグナル配列決定、アウトオブバンド（ストリームデータに対する）制御を搬送するNORM_OBJECT_STREAM送達オブジェクト内に挿入することができる16ビットの値です。これらの制御コードは、インオーダーストリーム内のそれらの挿入位置に関して、信頼性の高い配信を持つアプリケーションまたはプロトコルの実装に配信されます。この仕様は、次のNORMストリーム制御コードを登録します。"
    },
    {
      "indent": 13,
      "text": "+-------+-----------------+--------------------+\n| Value | Name            | Reference          |\n+-------+-----------------+--------------------+\n| 0     | NORM_STREAM_END | This specification |\n+-------+-----------------+--------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Additional NORM Stream Control Code value assignment requests are granted on a \"Specification Required\" basis as defined by IANA Guidelines [RFC5226]. The full 16-bit space outside of the value assigned in this specification are available for future assignment. In addition to describing the control code's expected interpretation, such specifications MUST include a description of protocol actions to be taken when the control code is encountered by a protocol implementation not supporting that specific option.",
      "ja": "IANAガイドライン[RFC5226]で定義されている追加のNORMストリーム制御コード値の割り当て要求は、「仕様が必要」に基づき付与されます。本明細書に割り当てられた値の外部フル16ビットの空間は、将来の割り当てのために利用可能です。制御コードの予想解釈を記述することに加えて、そのような仕様は、制御コードがその特定のオプションをサポートしないプロトコル実装が遭遇されたときに取るべきプロトコルアクションの記述を含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.1.3. NORM_CMD Message Sub-Types",
      "section_title": true,
      "ja": "8.1.3。 NORM_CMDメッセージサブタイプ"
    },
    {
      "indent": 3,
      "text": "This document defines a registry for NORM_CMD message sub-types named \"NORM Command Message Sub-types\".",
      "ja": "この文書は、「NORMコマンドメッセージのサブタイプ」という名前のNORM_CMDメッセージサブタイプのレジストリを定義します。"
    },
    {
      "indent": 3,
      "text": "The NORM_CMD message \"sub-type\" field is an 8-bit value with valid values in the range of 1-255. Note the value 0 is reserved to indicate an invalid NORM_CMD message sub-type. The current specification defines a number of NORM_CMD message sub-types senders can use to signal the receivers in various aspects of NORM protocol operation. This specification registers the following NORM_CMD Message Sub-types:",
      "ja": "NORM_CMDメッセージ「サブタイプ」フィールドは、1〜255の範囲の有効値を有する8ビットの値です。値0は無効NORM_CMDメッセージのサブタイプを示すために予約されます。現在の仕様では、送信者がNORMプロトコルの動作の様々な態様で受信機に信号を送るために使用できるNORM_CMDメッセージサブタイプの数を定義します。この仕様は、次のNORM_CMDメッセージサブタイプを登録します。"
    },
    {
      "indent": 10,
      "text": "+-------+-----------------------+--------------------+\n| Value | Name                  | Reference          |\n+-------+-----------------------+--------------------+\n| 0     | reserved              | This specification |\n| 1     | NORM_CMD(FLUSH)       | This specification |\n| 2     | NORM_CMD(EOT)         | This specification |\n| 3     | NORM_CMD(SQUELCH)     | This specification |\n| 4     | NORM_CMD(CC)          | This specification |\n| 5     | NORM_CMD(REPAIR_ADV)  | This specification |\n| 6     | NORM_CMD(ACK_REQ)     | This specification |\n| 7     | NORM_CMD(APPLICATION) | This specification |\n+-------+-----------------------+--------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Future specifications extending NORM MAY define additional NORM_CMD messages to enhance protocol functionality. NORM_CMD message sub-type value assignment requests are granted on a \"Specification Required\" basis as defined by IANA Guidelines [RFC5226]. In addition to describing the command sub-type's expected interpretation, specifications MUST include a description of protocol actions to be taken when the command is encountered by a protocol implementation not supporting that specific option.",
      "ja": "NORMを拡張する将来の仕様は、プロトコル機能を強化するために、追加のNORM_CMDメッセージを定義することができます。 IANAガイドライン[RFC5226]で定義されるようにNORM_CMDメッセージサブタイプ値割当要求が「仕様が必要」に基づいて付与されます。コマンドサブタイプの予想解釈を記述することに加えて、仕様は、コマンドがその特定のオプションをサポートしないプロトコル実装が遭遇されたときに取るべきプロトコルアクションの記述を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "This specification already defines an \"application-defined\" NORM_CMD message sub-type for use at the discretion of individual applications using NORM for transport. These \"application-defined\" commands are suitable for many application-specific purposes and do not involve standards action. In any case, such additional messages SHALL be subject to the same congestion control constraints as the existing NORM sender message set.",
      "ja": "この仕様は、すでに輸送のためのノルムを使用して、個々のアプリケーションの裁量で使用する「アプリケーション定義」NORM_CMDメッセージのサブタイプを定義します。これらの「アプリケーション定義」コマンドは、多くのアプリケーション固有の目的に適しており、標準アクションを伴いません。いずれの場合においても、このような付加的なメッセージは、既存のNORM送信者のメッセージ・セットと同じ輻輳制御の制約を受けなければなりません。"
    },
    {
      "indent": 0,
      "text": "9. Suggested Use",
      "section_title": true,
      "ja": "9.ご使用の目安"
    },
    {
      "indent": 3,
      "text": "The present NORM protocol is seen as a useful tool for the reliable data transfer over generic IP multicast services. It is not the intention of the authors to suggest it is suitable for supporting all envisioned multicast reliability requirements. NORM provides a simple and flexible framework for multicast applications with a degree of concern for network traffic implosion and protocol overhead efficiency. NORM-like protocols have been successfully demonstrated within the MBone for bulk data dissemination applications, including weather satellite compressed imagery updates servicing a large group of receivers and a generic web content reliable \"push\" application.",
      "ja": "現在NORMプロトコルは、一般的なIPマルチキャストサービス経由信頼性の高いデータ転送のための便利なツールとして見られています。すべての想定マルチキャスト信頼性要件を支持するのに適している示唆して作者の意図ではありません。 NORMは、ネットワークトラフィック内破およびプロトコルオーバーヘッド効率のために関心の度合いにマルチキャストアプリケーションのための簡単で柔軟なフレームワークを提供します。 NORM-のようなプロトコルが正常に受信機の大規模なグループにサービスを提供する気象衛星圧縮画像の更新と、一般的なWebコンテンツの信頼性の高い「プッシュ」アプリケーションを含め、バルクデータ配布アプリケーションのためにあるMBone内実証されています。"
    },
    {
      "indent": 3,
      "text": "In addition, this framework approach has some design features making it attractive for bulk transfer in asymmetric and wireless internetwork applications. NORM is capable of successfully operating independent of network structure and in environments with high packet loss, delay, and out-of-order delivery. Hybrid proactive/reactive",
      "ja": "また、このフレームワークのアプローチは、非対称および無線インターネットアプリケーションにおけるバルク転送のために、それは魅力的ないくつかの設計上の機能を備えています。 NORMが正常にネットワーク構造に依存せず、高いパケット損失、遅延、およびアウトオブオーダーデリバリーを有する環境において動作することができます。反応性/積極的なハイブリッド"
    },
    {
      "indent": 3,
      "text": "FEC-based repairing improve protocol performance in some multicast scenarios. A sender-only repair approach often makes additional engineering sense in asymmetric networks. NORM's unicast feedback capability is suitable for use in asymmetric networks or in networks where only unidirectional multicast routing/delivery service exists. Asymmetric architectures supporting multicast delivery are likely to make up an important portion of the future Internet structure (e.g., direct broadcast satellite (DBS) or cable and public-switched telephone network (PSTN) hybrids, etc.) and efficient, reliable bulk data transfer will be an important capability for servicing large groups of subscribed receivers.",
      "ja": "FECベースのいくつかのマルチキャストのシナリオにおけるプロトコルのパフォーマンスを向上させる修復。送信者のみの修理アプローチは、多くの場合、非対称ネットワークに追加エンジニアリング理にかなっています。 NORMのユニキャストフィードバック機能は、非対称ネットワークでのみ一方向マルチキャストルーティング/配信サービスが存在するネットワークでの使用に適しています。マルチキャスト配信をサポートする非対称アーキテクチャは、将来のインターネットの構造の重要な部分を構成する可能性がある（例えば、放送衛星（DBS）、またはケーブルや公衆交換電話網（PSTN）ハイブリッドなど）で効率的な、信頼性の高い大量のデータ転送加入受信機の大きなグループにサービスを提供するための重要な機能となります。"
    },
    {
      "indent": 1,
      "text": "10. Changes from",
      "section_title": true,
      "ja": "10.変更から"
    },
    {
      "indent": 3,
      "text": "This section lists the changes between the Experimental version of this specification, RFC 3940, and this version:",
      "ja": "このセクションでは、この仕様書、RFC 3940、およびこのバージョンの実験バージョン間の変更を示しています。"
    },
    {
      "indent": 3,
      "text": "1. Removal of the NORM_FLAG_MSG_START for NORM_OBJECT_STREAM, replacing it with the \"payload_msg_start\" field in the FEC-encoded preamble of the NORM_OBJECT_STREAM NORM_DATA payload.",
      "ja": "NORM_OBJECT_STREAM NORM_DATAペイロードのFEC符号化されたプリアンブルに「payload_msg_start」フィールドと交換NORM_OBJECT_STREAMためNORM_FLAG_MSG_START 1.除去。"
    },
    {
      "indent": 3,
      "text": "2. Definition of IANA registry for header extension and other assignments.",
      "ja": "ヘッダ拡張や他の割り当てのためのIANAレジストリの2の定義。"
    },
    {
      "indent": 3,
      "text": "3. Removal of file blocking scheme description now specified in the FEC Building Block document [RFC5052].",
      "ja": "今FECビルディングブロックの文書[RFC5052]で指定されたスキームの説明を遮断するファイルの3.除去。"
    },
    {
      "indent": 3,
      "text": "4. Removal of restriction of NORM receiver feedback message rate to local NORM sender rate (this caused congestion control failures in high speed operation. The extremely low feedback rate of the NORM protocol as compared to TCP avoids any resultant impact to the network as shown in [Mdpcc].)",
      "ja": "ローカルNORM送信者率（これは、高速動作における輻輳制御の失敗を引き起こした。NORMプロトコルの非常に低いフィードバック・レートにNORM受信フィードバック・メッセージレートの制限の4取り外しに示すように、TCPに比べてネットワークに任意得影響を回避するように【Mdpcc]）。"
    },
    {
      "indent": 3,
      "text": "5. Correction of errors in some message format descriptions.",
      "section_title": true,
      "ja": "いくつかのメッセージの形式の説明に誤りの訂正5。"
    },
    {
      "indent": 3,
      "text": "6. Correction of inconsistency in specification of the inactivity timeout.",
      "ja": "無活動タイムアウトの指定に矛盾6.修正。"
    },
    {
      "indent": 3,
      "text": "7. Addition of IPsec secure mode description with IPsec requirements.",
      "ja": "IPsecの要件とのIPsecセキュアモードの説明の7追加。"
    },
    {
      "indent": 3,
      "text": "8. Addition of the EXT_AUTH header extension definition.",
      "section_title": true,
      "ja": "EXT_AUTHヘッダ拡張定義の8添加。"
    },
    {
      "indent": 3,
      "text": "9. Clarification of interpretation of \"Source Block Length\" when FEC codes are arbitrarily shortened by the sender.",
      "ja": "「ソースブロック長」の解釈の明確化9. FECコードが任意に送信者によって短縮されたとき。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgments",
      "section_title": true,
      "ja": "11.謝辞"
    },
    {
      "indent": 3,
      "text": "(and these are not Negative)",
      "ja": "（これらはマイナスではありません）"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Rick Jones, Vincent Roca, Rod Walsh, Toni Paila, Michael Luby, and Joerg Widmer for their valuable input and comments on this document. The authors would also like to thank the RMT working group chairs, Roger Kermode and Lorenzo Vicisano, for their support in development of this specification, and Sally Floyd for her early input into this document.",
      "ja": "作者はこのドキュメントの彼らの貴重な入力とコメントのためのリック・ジョーンズ、ヴィンセントロカ、ロッド・ウォルシュ、トニPaila、マイケル・ルビー、そしてイェルクウィドマーに感謝したいと思います。著者らはまた、この文書に彼女の初期の入力のためにRMTワーキンググループチェア、ロジャーKermodeとロレンツォVicisano、この仕様の開発で彼らのサポートのために、とサリーフロイドに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12.参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1112] Deering, S., \"Host extensions for IP multicasting\", STD 5, RFC 1112, August 1989.",
      "ja": "[RFC1112]デアリング、S.、STD 5、RFC 1112 \"IPマルチキャスティングのためのホスト拡大\"、1989年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[RFC4301]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "ja": "[RFC4303]ケント、S.、 \"IPカプセル化セキュリティペイロード（ESP）\"、RFC 4303、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4607] Holbrook, H. and B. Cain, \"Source-Specific Multicast for IP\", RFC 4607, August 2006.",
      "ja": "[RFC4607]ホルブルック、H.、およびB.カイン、 \"IPのためのソース固有のマルチキャスト\"、RFC 4607、2006年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4654] Widmer, J. and M. Handley, \"TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification\", RFC 4654, August 2006.",
      "ja": "[RFC4654]ウィドマー、J.とM.ハンドリー、 \"TCPフレンドリーマルチキャスト輻輳制御（TFMCC）：プロトコル仕様\"、RFC 4654、2006年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5052] Watson, M., Luby, M., and L. Vicisano, \"Forward Error Correction (FEC) Building Block\", RFC 5052, August 2007.",
      "ja": "[RFC5052]ワトソン、M.、ルビー、M.、およびL. Vicisano、 \"前方誤り訂正（FEC）ビルディングブロック\"、RFC 5052、2007年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5401] Adamson, B., Bormann, C., Handley, M., and J. Macker, \"Multicast Negative-Acknowledgment (NACK) Building Blocks\", RFC 5401, November 2008.",
      "ja": "[RFC5401]アダムソン、B.、ボルマン、C.、ハンドレー、M.、およびJ. Macker、 \"マルチキャスト否定応答（NACK）ビルディングブロック\"、RFC 5401、2008年11月。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[FecHybrid] Gossink, D. and J. Macker, \"Reliable Multicast and Integrated Parity Retransmission with Channel Estimation\", IEEE GLOBECOMM, 1998.",
      "ja": "[FecHybrid] Gossink、D.とJ. Macker、 \"チャネル推定を用いた高信頼マルチキャストおよび統合されたパリティ再送信\"、IEEE GLOBECOMM、1998。"
    },
    {
      "indent": 3,
      "text": "[McastFeedback] Nonnenmacher, J. and E. Biersack, \"Optimal Multicast Feedback\", IEEE INFOCOM, p. 964, March/April 1998.",
      "ja": "【McastFeedback] Nonnenmacher、J.及びE. Biersack、 \"最適マルチキャストフィードバック\"、IEEE INFOCOM、P。 964年3月/ 1998年4月。"
    },
    {
      "indent": 3,
      "text": "[MdpToolkit] Macker, J. and B. Adamson, \"The Multicast Dissemination Protocol (MDP) Toolkit\", Proc. IEEE MILCOM, October 1999.",
      "ja": "【MdpToolkit] Macker、J.及びB.アダムソン、 \"マルチキャスト普及プロトコル（MDP）ツールキット\"、PROC。 IEEE MILCOM、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[Mdpcc] Adamson, B. and J. Macker, \"A TCP-Friendly, Rate-based Mechanism for NACK-Oriented Reliable Multicast Congestion Control\", Proc. IEEE GLOBECOMM, November 2001.",
      "ja": "【Mdpcc]アダムソン、B.及びJ. Macker、「NACK指向高信頼マルチキャスト輻輳制御のためのTCPフレンドリー、レートベースのメカニズム」、PROC。 IEEE GLOBECOMM、2001年11月。"
    },
    {
      "indent": 3,
      "text": "[NormFeedback] Adamson, B. and J. Macker, \"Quantitative Prediction of NACK-Oriented Reliable Multicast (NORM) Feedback\", IEEE MILCOM, October 2002.",
      "ja": "【NormFeedback]アダムソン、B.及びJ. Macker、 \"NACK指向高信頼マルチキャスト（NORM）フィードバックの定量的予測\"、IEEE MILCOM 2002年10月。"
    },
    {
      "indent": 3,
      "text": "[PgmccPaper] Rizzo, L., \"pgmcc: A TCP-Friendly Single-Rate Multicast Congestion Control Scheme\", ACM SIGCOMM, August 2000.",
      "ja": "[PgmccPaper] Rizzo氏、L.、 \"pgmcc：TCPフレンドリーシングルレートマルチキャスト輻輳制御方式\"、ACM SIGCOMM、2000年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2357] Mankin, A., Romanov, A., Bradner, S., and V. Paxson, \"IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols\", RFC 2357, June 1998.",
      "ja": "[RFC2357]マンキン、A.、ロマノフ、A.、RFC 2357、1998年6月ブラドナーの、S.、およびV.パクソン、 \"信頼性の高いマルチキャストトランスポートとアプリケーションプロトコルを評価するためのIETF基準\"。"
    },
    {
      "indent": 3,
      "text": "[RFC2974] Handley, M., Perkins, C., and E. Whelan, \"Session Announcement Protocol\", RFC 2974, October 2000.",
      "ja": "[RFC2974]ハンドリー、M.、パーキンス、C.、およびE.ウィーラン、 \"セッションアナウンスメントプロトコル\"、RFC 2974、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC3048] Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, \"Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer\", RFC 3048, January 2001.",
      "ja": "[RFC3048] Whetten、B.、Vicisano、L.、Kermode、R.、ハンドレー、M.、フロイド、S.、およびM.ルビー、 \"信頼できるマルチキャストトランスポート・ビルディング・ブロック一対多バルクデータ転送のための\" 、RFC 3048、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3269] Kermode, R. and L. Vicisano, \"Author Guidelines for Reliable Multicast Transport (RMT) Building Blocks and Protocol Instantiation documents\", RFC 3269, April 2002.",
      "ja": "[RFC3269] Kermode、R.とL. Vicisano、RFC 3269、2002年4月 \"信頼できるマルチキャストトランスポート（RMT）ビルディングブロックとプロトコルのインスタンス文書の作者のガイドライン\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3453] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, \"The Use of Forward Error Correction (FEC) in Reliable Multicast\", RFC 3453, December 2002.",
      "ja": "[RFC3453]ルビー、M.、Vicisano、L.、Gemmell、J.、リゾー、L.、ハンドレー、M.、およびJ.クロウクロフト、 \"信頼できるマルチキャストの前方誤り訂正（FEC）の使用\"、RFC 3453 、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3547] Baugher, M., Weis, B., Hardjono, T., and H. Harney, \"The Group Domain of Interpretation\", RFC 3547, July 2003.",
      "ja": "[RFC3547] Baugher、M.、ヴァイス、B.、Hardjono、T.、およびH.ハーニー、 \"解釈のグループドメイン\"、RFC 3547、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, July 2003.",
      "ja": "[RFC3550] Schulzrinneと、H.、Casner、S.、フレデリック、R.、およびV.ヤコブソン、 \"RTP：リアルタイムアプリケーションのためのトランスポートプロトコル\"、STD 64、RFC 3550、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, March 2004.",
      "ja": "[RFC3711] Baugher、M.、マグリュー、D.、Naslund、M.、カララ、E.、およびK. Norrman、 \"セキュアリアルタイム転送プロトコル（SRTP）\"、RFC 3711、2004年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3830] Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and K. Norrman, \"MIKEY: Multimedia Internet KEYing\", RFC 3830, August 2004.",
      "ja": "[RFC3830] Arkko、J.、カララ、E.、リンドホルム、F.、Naslund、M.、およびK. Norrman、 \"MIKEY：マルチメディアインターネットキーイング\"、RFC 3830、2004年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3940] Adamson, B., Bormann, C., Handley, M., and J. Macker, \"Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol\", RFC 3940, November 2004.",
      "ja": "[RFC3940]アダムソン、B.、ボルマン、C.、ハンドレー、M.、およびJ. Macker、 \"否定応答（NACK）配向高信頼マルチキャスト（NORM）プロトコル\"、RFC 3940、2004年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4535] Harney, H., Meth, U., Colegrove, A., and G. Gross, \"GSAKMP: Group Secure Association Key Management Protocol\", RFC 4535, June 2006.",
      "ja": "[RFC4535]はハーニー、H.、メタ、U.、Colegrove、A.、およびG.グロスは、：RFC 4535、2006年6月、 \"GSAKMPグループは、協会の鍵管理プロトコルをセキュア\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4566] Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session Description Protocol\", RFC 4566, July 2006.",
      "ja": "[RFC4566]ハンドリー、M.、ヤコブソン、V.、およびC.パーキンス、 \"SDP：セッション記述プロトコル\"、RFC 4566、2006年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC5445] Watson, M., \"Basic Forward Error Correction (FEC) Schemes\", RFC 5445, March 2009.",
      "ja": "[RFC5445]ワトソン、M.、 \"基本的な前方誤り訂正（FEC）スキーム\"、RFC 5445、2009年3月。"
    },
    {
      "indent": 3,
      "text": "[RmComparison] Pingali, S., Towsley, D., and J. Kurose, \"A Comparison of Sender-Initiated and Receiver-Initiated Reliable Multicast Protocols\", Proc. INFOCOMM, San Francisco CA, October 1993.",
      "ja": "【RmComparison] Pingali、S.、Towsley、D.、およびJ.黒瀬、「送信者開始の比較及び受信器で開始高信頼マルチキャストプロトコル」、PROC。インフォコム、カ​​リフォルニア州サンフランシスコ、1993年10月。"
    },
    {
      "indent": 3,
      "text": "[TcpModel] Padhye, J., Firoiu, V., Towsley, D., and J. Kurose, \"Modeling TCP Throughput: A Simple Model and its Empirical Validation\", ACM SIGCOMM, 1998.",
      "ja": "【TcpModel] Padhye、J.、Firoiu、V.、Towsley、D.、およびJ.黒瀬、 \"モデルTCPスループット：簡単なモデルとその実証的検証\"、ACM SIGCOMM、1998。"
    },
    {
      "indent": 3,
      "text": "[TfmccPaper] Widmer, J. and M. Handley, \"Extending Equation-Based Congestion Control to Multicast Applications\", ACM SIGCOMM, August 2001.",
      "ja": "「マルチキャストアプリケーションに式ベースの輻輳制御を拡張」[TfmccPaper]ウィドマー、J.とM.ハンドレー、ACM SIGCOMM、2001年8月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Brian Adamson Naval Research Laboratory Washington, DC 20375 USA",
      "ja": "ブライアン・アダムソン海軍研究所ワシントンD.C. 20375 USA"
    },
    {
      "indent": 3,
      "text": "EMail: adamson@itd.nrl.navy.mil",
      "ja": "メールアドレス：adamson@itd.nrl.navy.mil"
    },
    {
      "indent": 3,
      "text": "Carsten Bormann Universitaet Bremen TZI Postfach 330440 D-28334 Bremen Germany",
      "ja": "カルステンボルマンUniversitaetブレーメンTZI POSTFACH 330440 D-28334ブレーメン、ドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: cabo@tzi.org",
      "ja": "メールアドレス：cabo@tzi.org"
    },
    {
      "indent": 3,
      "text": "Mark Handley University College London Gower Street London WC1E 6BT UK",
      "ja": "マーク・ハンドリーロンドン大学ガウアーストリートロンドンWC1E 6BT英国"
    },
    {
      "indent": 3,
      "text": "EMail: M.Handley@cs.ucl.ac.uk",
      "ja": "メールアドレス：M.Handley@cs.ucl.ac.uk"
    },
    {
      "indent": 3,
      "text": "Joe Macker Naval Research Laboratory Washington, DC 20375 USA",
      "ja": "ジョーMacker海軍研究所ワシントンD.C. 20375 USA"
    },
    {
      "indent": 3,
      "text": "EMail: macker@itd.nrl.navy.mil",
      "ja": "メールアドレス：macker@itd.nrl.navy.mil"
    }
  ]
}