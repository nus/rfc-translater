{
  "title": {
    "text": "RFC 5906 - Network Time Protocol Version 4: Autokey Specification",
    "ja": "RFC 5906 - ネットワークタイムプロトコルバージョン4：自動キー仕様"
  },
  "number": 5906,
  "created_at": "2019-10-30 13:28:12.318512+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                  B. Haberman, Ed.\nRequest for Comments: 5906                                       JHU/APL\nCategory: Informational                                         D. Mills\nISSN: 2070-1721                                              U. Delaware\n                                                               June 2010",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Network Time Protocol Version 4: Autokey Specification",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo describes the Autokey security model for authenticating servers to clients using the Network Time Protocol (NTP) and public key cryptography. Its design is based on the premise that IPsec schemes cannot be adopted intact, since that would preclude stateless servers and severely compromise timekeeping accuracy. In addition, Public Key Infrastructure (PKI) schemes presume authenticated time values are always available to enforce certificate lifetimes; however, cryptographically verified timestamps require interaction between the timekeeping and authentication functions.",
      "ja": "このメモは、ネットワークタイムプロトコル（NTP）と、公開鍵暗号方式を使用してクライアントにサーバを認証するためのAutokeyセキュリティモデルについて説明します。そのデザインは、それはステートレスなサーバと厳しく妥協計時精度を妨げるので、IPsecのスキームは、そのまま採用することができないことを前提としています。また、公開鍵基盤（PKI）のスキームは、認証された時間値は、常に証明書の有効期限を強制するために利用されていると推定します。しかし、暗号的に検証タイムスタンプが計時と認証機能との相互作用を必要とします。"
    },
    {
      "indent": 3,
      "text": "This memo includes the Autokey requirements analysis, design principles, and protocol specification. A detailed description of the protocol states, events, and transition functions is included. A prototype of the Autokey design based on this memo has been implemented, tested, and documented in the NTP version 4 (NTPv4) software distribution for the Unix, Windows, and Virtual Memory System (VMS) operating systems at http://www.ntp.org.",
      "ja": "このメモは自動キーの要件分析、設計原理、およびプロトコル仕様を含んでいます。プロトコル状態、イベント、および遷移関数の詳細な説明が含まれています。このメモをもとに自動キーのデザインの原型は、実装、テスト、およびUnix、Windows用のNTPバージョン4（NTPv4）ソフトウェア配布、およびHTTPでの仮想メモリシステム（VMS）のオペレーティングシステムで文書化されています：// WWW。 ntp.org。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5906.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc5906で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2010 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n2. NTP Security Model ..............................................4\n3. Approach ........................................................7\n4. Autokey Cryptography ............................................8\n5. Autokey Protocol Overview ......................................12\n6. NTP Secure Groups ..............................................14\n7. Identity Schemes ...............................................19\n8. Timestamps and Filestamps ......................................20\n9. Autokey Operations .............................................22\n10. Autokey Protocol Messages .....................................23\n   10.1. No-Operation .............................................26\n   10.2. Association Message (ASSOC) ..............................26\n   10.3. Certificate Message (CERT) ...............................26\n   10.4. Cookie Message (COOKIE) ..................................27\n   10.5. Autokey Message (AUTO) ...................................27\n   10.6. Leapseconds Values Message (LEAP) ........................27\n   10.7. Sign Message (SIGN) ......................................27\n   10.8. Identity Messages (IFF, GQ, MV) ..........................27\n11. Autokey State Machine .........................................28\n   11.1. Status Word ..............................................28\n   11.2. Host State Variables .....................................30\n   11.3. Client State Variables (all modes) .......................33\n   11.4. Protocol State Transitions ...............................34\n        11.4.1. Server Dance ......................................34\n        11.4.2. Broadcast Dance ...................................35\n        11.4.3. Symmetric Dance ...................................36\n   11.5. Error Recovery ...........................................37\n12. Security Considerations .......................................39\n   12.1. Protocol Vulnerability ...................................39\n   12.2. Clogging Vulnerability ...................................40\n13. IANA Considerations ...........................................42\n13. References ....................................................42\n   13.1. Normative References .....................................42\n   13.2. Informative References ...................................43\nAppendix A.  Timestamps, Filestamps, and Partial Ordering .........45\nAppendix B.  Identity Schemes .....................................46\nAppendix C.  Private Certificate (PC) Scheme ......................47\nAppendix D.  Trusted Certificate (TC) Scheme ......................47\nAppendix E.  Schnorr (IFF) Identity Scheme ........................48\nAppendix F.  Guillard-Quisquater (GQ) Identity Scheme .............49\nAppendix G.  Mu-Varadharajan (MV) Identity Scheme .................51\nAppendix H.  ASN.1 Encoding Rules .................................54\nAppendix I.  COOKIE Request, IFF Response, GQ Response, MV\n             Response .............................................54\nAppendix J.  Certificates .........................................55",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A distributed network service requires reliable, ubiquitous, and survivable provisions to prevent accidental or malicious attacks on the servers and clients in the network or the values they exchange. Reliability requires that clients can determine that received packets are authentic; that is, were actually sent by the intended server and not manufactured or modified by an intruder. Ubiquity requires that a client can verify the authenticity of a server using only public information. Survivability requires protection from faulty implementations, improper operation, and possibly malicious clogging and replay attacks.",
      "ja": "分散型ネットワークサービスは、サーバとクライアントのネットワークや、彼らが交換する値の偶発的または悪意のある攻撃を防ぐために、信頼性の高いユビキタス、および存続条項が必要です。信頼性は、クライアントが受信したパケットが本物であることを判断できることが必要です。つまり、実際に意図サーバによって送信され、侵入者によって製造され、または変更されませんでした。 Ubiquityのは、クライアントが公開情報のみを使用して、サーバーの信頼性を確認できることが必要です。耐障害は障害のある実装で、不適切な操作、そしておそらく悪意の目詰まりやリプレイ攻撃からの保護が必要です。"
    },
    {
      "indent": 3,
      "text": "This memo describes a cryptographically sound and efficient methodology for use in the Network Time Protocol (NTP) [RFC5905]. The various key agreement schemes [RFC4306][RFC2412][RFC2522] proposed require per-association state variables, which contradicts the principles of the remote procedure call (RPC) paradigm in which servers keep no state for a possibly large client population. An evaluation of the PKI model and algorithms, e.g., as implemented in the OpenSSL library, leads to the conclusion that any scheme requiring every NTP packet to carry a PKI digital signature would result in unacceptably poor timekeeping performance.",
      "ja": "このメモは、ネットワークタイムプロトコル（NTP）[RFC5905]で使用するため、暗号健全かつ効率的な方法を説明します。様々な鍵合意スキーム[RFC4306] [RFC2412] [RFC2522]は、リモートプロシージャコール（RPC）サーバーは、おそらく大規模なクライアント集団について何の状態を維持しないようなパラダイムの原則に反するごとの会合状態変数を、必要と提案しました。 OpenSSLライブラリに実装されPKIモデルおよびアルゴリズムの評価は、例えば、PKIデジタル署名を運ぶために、すべてのNTPパケットを必要とする任意の方式が許容できないほど貧弱計時性能をもたらすであろうという結論に導きます。"
    },
    {
      "indent": 3,
      "text": "The Autokey protocol is based on a combination of PKI and a pseudo-random sequence generated by repeated hashes of a cryptographic value involving both public and private components. This scheme has been implemented, tested, and deployed in the Internet of today. A detailed description of the security model, design principles, and implementation is presented in this memo.",
      "ja": "オートキープロトコルは、PKIとパブリックおよびプライベートの両方の成分を含む暗号値の反復ハッシュによって生成された擬似ランダムシーケンスの組み合わせに基づいています。この方式は、実装、テスト、および今日のインターネットで展開されてきました。セキュリティモデル、設計原理、および実装の詳細な説明は、このメモに提示されています。"
    },
    {
      "indent": 3,
      "text": "This informational document describes the NTP extensions for Autokey as implemented in an NTPv4 software distribution available from http://www.ntp.org. This description is provided to offer a basis for future work and a reference for the software release. This document also describes the motivation for the extensions within the protocol.",
      "ja": "この情報文書はhttp://www.ntp.orgから入手NTPv4ソフトウェアの配布で実装されている自動キーのためのNTPの拡張機能について説明します。この記述は、将来の仕事のための基礎とソフトウェアリリースのための参照を提供するために提供されます。このドキュメントは、プロトコル内の拡張のための動機を説明しています。"
    },
    {
      "indent": 0,
      "text": "2. NTP Security Model",
      "section_title": true,
      "ja": "2. NTPセキュリティモデル"
    },
    {
      "indent": 3,
      "text": "NTP security requirements are even more stringent than most other distributed services. First, the operation of the authentication mechanism and the time synchronization mechanism are inextricably intertwined. Reliable time synchronization requires cryptographic keys that are valid only over designated time intervals; but, time intervals can be enforced only when participating servers and clients are reliably synchronized to UTC. In addition, the NTP subnet is hierarchical by nature, so time and trust flow from the primary servers at the root through secondary servers to the clients at the leaves.",
      "ja": "NTPのセキュリティ要件は、さらに厳しい他のほとんどの分散サービスよりも。まず、認証機構との時刻同期機構の動作が密接に絡み合っています。信頼性の高い時刻同期は、指定された時間間隔で有効な暗号鍵​​が必要です。しかし、時間間隔は、参加サーバとクライアントが確実にUTCに同期しているときにのみ適用できます。また、NTPサブネットは、本質的に階層的であるため、葉のクライアントへのセカンダリサーバ経由ルートに、プライマリサーバからの時間と信頼流れ。"
    },
    {
      "indent": 3,
      "text": "A client can claim authentic to dependent applications only if all servers on the path to the primary servers are bona fide authentic. In order to emphasize this requirement, in this memo, the notion of \"authentic\" is replaced by \"proventic\", an adjective new to English and derived from \"provenance\", as in the provenance of a painting. Having abused the language this far, the suffixes fixable to the various derivatives of authentic will be adopted for proventic as well. In NTP, each server authenticates the next-lower stratum servers and proventicates (authenticates by induction) the lowest stratum (primary) servers. Serious computer linguists would correctly interpret the proventic relation as the transitive closure of the authentic relation.",
      "ja": "クライアントは、プライマリサーバへのパス上のすべてのサーバーが本物の善意善意である場合にのみ依存するアプリケーションに本格的な主張することができます。この要件を強調するためには、このメモでは、「本物」の概念は、英語に形容詞が新しい、「proventic」に置き換えられ、絵の出所のように、「産地」から派生します。ここまでの言語を乱用した、本物の種々の誘導体に固定可能接尾辞は、同様にproventicに採用されます。 NTPでは、各サーバは、次に低い階層サーバとproventicates（誘導により認証）最低ストラタム（プライマリ）サーバを認証します。深刻なコンピュータ言語学者は正しく本物の関係の推移閉包としてproventic関係を解釈します。"
    },
    {
      "indent": 3,
      "text": "It is important to note that the notion of proventic does not necessarily imply the time is correct. An NTP client mobilizes a number of concurrent associations with different servers and uses a crafted agreement algorithm to pluck truechimers from the population possibly including falsetickers. A particular association is proventic if the server certificate and identity have been verified by the means described in this memo. However, the statement \"the client is synchronized to proventic sources\" means that the system clock has been set using the time values of one or more proventic associations and according to the NTP mitigation algorithms.",
      "ja": "proventicの概念は、必ずしも時刻が正しい意味するものではないことに注意することが重要です。 NTPクライアントは異なるサーバで同時アソシエーション数を動員し、おそらくfalsetickersを含む集団からtruechimersを摘み取るために細工された合意アルゴリズムを使用しています。サーバ証明書及び身元はこのメモに記載の手段によって検証されている場合は特に関連はproventicです。しかし、文は、システム・クロックは、1つまたは複数のproventic協会の時間値を使用して設定し、NTP緩和アルゴリズムに従ってされたことを意味し、「クライアントがproventic源に同期されます」。"
    },
    {
      "indent": 3,
      "text": "Over the last several years, the IETF has defined and evolved the IPsec infrastructure for privacy protection and source authentication in the Internet. The infrastructure includes the Encapsulating Security Payload (ESP) [RFC4303] and Authentication Header (AH) [RFC4302] for IPv4 and IPv6. Cryptographic algorithms that use these headers for various purposes include those developed for the PKI, including various message digest, digital signature, and key agreement algorithms. This memo takes no position on which message digest or digital signature algorithm is used. This is established by a profile for each community of users.",
      "ja": "過去数年にわたり、IETFが定義されており、インターネットでのプライバシー保護およびソース認証用のIPsecインフラストラクチャを進化させました。インフラストラクチャは、IPv4とIPv6のカプセル化セキュリティペイロード（ESP）[RFC4303]及び認証ヘッダ（AH）[RFC4302]を含みます。様々な目的のために、これらのヘッダーを使用する暗号化アルゴリズムは、種々のメッセージダイジェスト、デジタル署名、および鍵合意アルゴリズムを含むPKIのために開発されたものが挙げられます。このメモは、メッセージダイジェスト又はデジタル署名アルゴリズムが使用されるいかなる位置を取りません。これは、ユーザーの各コミュニティのためのプロファイルによって確立されています。"
    },
    {
      "indent": 3,
      "text": "It will facilitate the discussion in this memo to refer to the reference implementation available at http://www.ntp.org. It includes Autokey as described in this memo and is available to the general public; however, it is not part of the specification itself. The cryptographic means used by the reference implementation and its user community are based on the OpenSSL cryptographic software library available at http://www.openssl.org, but other libraries with equivalent functionality could be used as well. It is important for distribution and export purposes that the way in which these algorithms are used precludes encryption of any data other than incidental to the construction of digital signatures.",
      "ja": "それはhttp://www.ntp.orgで入手可能なリファレンス実装を参照するためにこのメモで議論を容易にします。なお、このメモに記載されているようにオートキーを含み、一般公衆に利用可能です。しかし、それは仕様自体の一部ではありません。リファレンス実装とそのユーザーコミュニティによって使用される暗号化の手段は、http://www.openssl.orgで入手可能なOpenSSLの暗号化ソフトウェアライブラリに基づいていますが、同等の機能を持つ他のライブラリは、同様に使用することができます。これは、これらのアルゴリズムが使用される方法は、デジタル署名の建設に付随以外のデータの暗号化を排除分布し、輸出目的のために重要です。"
    },
    {
      "indent": 3,
      "text": "The fundamental assumption in NTP about the security model is that packets transmitted over the Internet can be intercepted by those other than the intended recipient, remanufactured in various ways, and replayed in whole or part. These packets can cause the client to believe or produce incorrect information, cause protocol operations to fail, interrupt network service, or consume precious network and processor resources.",
      "ja": "セキュリティモデルについてのNTPの基本的な前提は、インターネット上で送信されたパケットは、さまざまな方法で再製品意図した受信者以外の、によって傍受、および全体的または部分的に再生することができるということです。これらのパケットは、誤った情報を信じるか、生成するクライアントを引き起こす可能性があります原因プロトコル操作は失敗し、ネットワークサービスを中断、または貴重なネットワークおよびプロセッサリソースを消費します。"
    },
    {
      "indent": 3,
      "text": "In the case of NTP, the assumed goal of the intruder is to inject false time values, disrupt the protocol or clog the network, servers, or clients with spurious packets that exhaust resources and deny service to legitimate applications. The mission of the algorithms and protocols described in this memo is to detect and discard spurious packets sent by someone other than the intended sender or sent by the intended sender, but modified or replayed by an intruder.",
      "ja": "NTPの場合は、侵入者の仮定の目標は、虚偽の時間値を注入プロトコルを混乱させるか、排気リソーススプリアスパケットをネットワーク、サーバ、またはクライアントを詰まらせ、正当なアプリケーションにサービスを拒否することです。このメモで説明したアルゴリズムとプロトコルの使命は、意図した送信者または意図送信者によって送信されたが、侵入者によって変更または再生以外の誰かによって送信された偽のパケットを検出して廃棄することです。"
    },
    {
      "indent": 3,
      "text": "There are a number of defense mechanisms already built in the NTP architecture, protocol, and algorithms. The on-wire timestamp exchange scheme is inherently resistant to spoofing, packet-loss, and replay attacks. The engineered clock filter, selection, and clustering algorithms are designed to defend against evil cliques of Byzantine traitors. While not necessarily designed to defeat determined intruders, these algorithms and accompanying sanity checks have functioned well over the years to deflect improperly operating but presumably friendly scenarios. However, these mechanisms do not securely identify and authenticate servers to clients. Without specific further protection, an intruder can inject any or all of the following attacks.",
      "ja": "すでにNTPアーキテクチャ、プロトコル、およびアルゴリズムに組み込まれた防御機構の数があります。上の線のタイムスタンプ交換方式はスプーフィング、パケット損失、およびリプレイ攻撃に対して本質的に耐性があります。エンジニアリングクロックフィルタ、選択、およびクラスタリングアルゴリズムは、ビザンチン裏切り者の悪クリークを防御するために設計されています。必ずしも決定した侵入者を倒すために設計されていないが、これらのアルゴリズムおよび添付の健全性チェックが正しく動作しますが、おそらく友好的なシナリオを偏向させるために長年にわたってうまく機能しています。しかし、これらのメカニズムは、しっかりと、クライアントにサーバーを識別し、認証しません。特定のさらなる保護がなければ、侵入者は、次の攻撃のいずれかまたは全てを注入することができます。"
    },
    {
      "indent": 3,
      "text": "1. An intruder can intercept and archive packets forever, as well as all the public values ever generated and transmitted over the net.",
      "ja": "1.侵入者は、傍受したアーカイブパケット永遠に、だけでなく、すべての公共の値は、これまでに生成され、ネット上で送信することができます。"
    },
    {
      "indent": 3,
      "text": "2. An intruder can generate packets faster than the server, network, or client can process them, especially if they require expensive cryptographic computations.",
      "ja": "2.侵入者は、彼らは高価な暗号計算が必要な場合は特に、より速く、それらを処理することができ、サーバ、ネットワーク、またはクライアント以外のパケットを生成することができます。"
    },
    {
      "indent": 3,
      "text": "3. In a wiretap attack, the intruder can intercept, modify, and replay a packet. However, it cannot permanently prevent onward transmission of the original packet; that is, it cannot break the wire, only tell lies and congest it. Except in the unlikely cases considered in Section 12, the modified packet cannot arrive at the victim before the original packet, nor does it have the server private keys or identity parameters.",
      "ja": "盗聴攻撃で3、侵入者は、傍受、変更、およびパケットを再生することができます。しかし、それは永久以降、元のパケットの送信を防ぐことはできません。つまり、それはワイヤーを破ることができない、唯一の嘘を言うと、それを混雑。セクション12で考慮さそうな場合を除いて、変更されたパケットは、元のパケットの前に犠牲者に到着することができない、またそれは、サーバの秘密鍵またはIDパラメータを持っています。"
    },
    {
      "indent": 3,
      "text": "4. In a man-in-the-middle or masquerade attack, the intruder is positioned between the server and client, so it can intercept, modify, and replay a packet and prevent onward transmission of the original packet. Except in unlikely cases considered in Section 12, the middleman does not have the server private keys.",
      "ja": "4.のman-in-the-middleにまたは攻撃を装う、侵入者は、サーバとクライアントとの間に位置しているので、それは、傍受、変更、およびパケットを再生し、元のパケットの前方送信を防ぐことができます。セクション12で考慮さそうな場合を除いて、仲介サーバ秘密鍵を持っていません。"
    },
    {
      "indent": 3,
      "text": "The NTP security model assumes the following possible limitations.",
      "ja": "NTPのセキュリティモデルは、以下の可能性の限界を想定しています。"
    },
    {
      "indent": 3,
      "text": "1. The running times for public key algorithms are relatively long and highly variable. In general, the performance of the time synchronization function is badly degraded if these algorithms must be used for every NTP packet.",
      "ja": "1.公開鍵アルゴリズムの実行している時間が比較的長く、非常に可変です。これらのアルゴリズムは、すべてのNTPパケットのために使用されなければならない場合には、一般的には、時刻同期機能の性能がひどく劣化しています。"
    },
    {
      "indent": 3,
      "text": "2. In some modes of operation, it is not feasible for a server to retain state variables for every client. It is however feasible to regenerated them for a client upon arrival of a packet from that client.",
      "ja": "サーバはすべてのクライアントのために状態変数を保持するための動作のいくつかのモード2.、それは現実的ではありません。そのクライアントからのパケットの到着時にクライアントのためにそれらを再生成することが可能です。"
    },
    {
      "indent": 3,
      "text": "3. The lifetime of cryptographic values must be enforced, which requires a reliable system clock. However, the sources that synchronize the system clock must be cryptographically proventicated. This circular interdependence of the timekeeping and proventication functions requires special handling.",
      "ja": "3.暗号値の寿命は、信頼性の高いシステム・クロックを必要とする、実施されなければなりません。しかし、システムクロックを同期ソースは、暗号proventicatedする必要があります。計時とproventication機能のこの円形相互依存関係は、特別な処理が必要です。"
    },
    {
      "indent": 3,
      "text": "4. Client security functions must involve only public values transmitted over the net. Private values must never be disclosed beyond the machine on which they were created, except in the case of a special trusted agent (TA) assigned for this purpose.",
      "ja": "4.クライアントのセキュリティ機能は、ネットを介して送信のみ公開値を伴う必要があります。プライベートの値は、この目的のために割り当てられた特別な信頼できるエージェント（TA）の場合を除き、それらが作成されたマシンを超えて開示してはなりません。"
    },
    {
      "indent": 3,
      "text": "Unlike the Secure Shell (SSH) security model, where the client must be securely authenticated to the server, in NTP, the server must be securely authenticated to the client. In SSH, each different interface address can be bound to a different name, as returned by a reverse-DNS query. In this design, separate public/private key pairs may be required for each interface address with a distinct name. A perceived advantage of this design is that the security compartment can be different for each interface. This allows a firewall, for instance, to require some interfaces to authenticate the client and others not.",
      "ja": "クライアントがサーバーにしっかりと認証されなければならないのSecure Shell（SSH）セキュリティモデルとは異なり、NTPで、サーバが安全にクライアントに認証される必要があります。逆DNSクエリによって返されるSSHでは、それぞれ異なるインターフェイスアドレスは、別の名前にバインドすることができます。この設計では、独立した公開鍵/秘密鍵のペアは、異なる名前を持つ各インターフェイスアドレスが必要な場合があります。この設計の知覚される利点は、セキュリティ区画は各インターフェイスのために異なることができることです。これは、ファイアウォールが、例えば、クライアントではなく、他を認証するためにいくつかのインタフェースを必要とすることができます。"
    },
    {
      "indent": 0,
      "text": "3. Approach",
      "section_title": true,
      "ja": "3.アプローチ"
    },
    {
      "indent": 3,
      "text": "The Autokey protocol described in this memo is designed to meet the following objectives. In-depth discussions on these objectives is in the web briefings and will not be elaborated in this memo. Note that here, and elsewhere in this memo, mention of broadcast mode means multicast mode as well, with exceptions as noted in the NTP software documentation [RFC5905].",
      "ja": "このメモで説明するのAutokeyプロトコルは、以下の目的を満たすように設計されています。これらの目標に関する詳細な議論ウェブブリーフィングであり、このメモでは詳述しません。 NTPソフトウェアのドキュメント[RFC5905]で述べたように、ここで、他の場所このメモでは、ブロードキャストモードの言及は例外を除いて、同様にマルチキャストモードを意味することに注意してください。"
    },
    {
      "indent": 3,
      "text": "1. It must interoperate with the existing NTP architecture model and protocol design. In particular, it must support the symmetric key scheme described in [RFC1305]. As a practical matter, the reference implementation must use the same internal key management system, including the use of 32-bit key IDs and existing mechanisms to store, activate, and revoke keys.",
      "ja": "1.これは、既存のNTPアーキテクチャモデルとプロトコルの設計と相互運用しなければなりません。特に、それは、[RFC1305]に記載の対称鍵方式をサポートしなければなりません。実際問題として、リファレンス実装は、32ビットの鍵IDの使用を含む、及び格納するためのメカニズムを、既存の、同じ内部鍵管理システムを使用して活性化し、鍵を取り消す必要があります。"
    },
    {
      "indent": 3,
      "text": "2. It must provide for the independent collection of cryptographic values and time values. An NTP packet is accepted for processing only when the required cryptographic values have been obtained and verified and the packet has passed all header sanity checks.",
      "ja": "2.これは、暗号値と時間値の独立したコレクションを提供しなければなりません。 NTPパケットが必要な暗号値を取得し、検証し、パケットがすべてのヘッダサニティ・チェックを通過したされた場合にのみ、処理のために受け入れています。"
    },
    {
      "indent": 3,
      "text": "3. It must not significantly degrade the potential accuracy of the NTP synchronization algorithms. In particular, it must not make unreasonable demands on the network or host processor and memory resources.",
      "ja": "3.それはかなりNTP同期アルゴリズムの潜在的な精度を低下させてはなりません。特に、それは、ネットワークまたはホストプロセッサとメモリリソースに不当な要求をしてはなりません。"
    },
    {
      "indent": 3,
      "text": "4. It must be resistant to cryptographic attacks, specifically those identified in the security model above. In particular, it must be tolerant of operational or implementation variances, such as packet loss or disorder, or suboptimal configurations.",
      "ja": "4.これは、特に上記のセキュリティモデルで同定されたもの、暗号攻撃に耐性でなければなりません。特に、このようなパケット損失または障害、または準最適構成と動作または実装分散の寛容でなければなりません。"
    },
    {
      "indent": 3,
      "text": "5. It must build on a widely available suite of cryptographic algorithms, yet be independent of the particular choice. In particular, it must not require data encryption other than that which is incidental to signature and cookie encryption operations.",
      "ja": "5.これは、暗号アルゴリズムの広く利用可能なスイートを構築し、まだ特定の選択の独立していなければなりません。特に、署名とクッキーの暗号化操作に付随するよりも、他のデータの暗号化を要求することはできません。"
    },
    {
      "indent": 3,
      "text": "6. It must function in all the modes supported by NTP, including server, symmetric, and broadcast modes.",
      "ja": "6.これは、サーバー、対称、およびブロードキャストモードを含むNTPでサポートされているすべてのモードで機能しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4. Autokey Cryptography",
      "section_title": true,
      "ja": "4.自動キー暗号化"
    },
    {
      "indent": 3,
      "text": "Autokey cryptography is based on the PKI algorithms commonly used in the Secure Shell and Secure Sockets Layer (SSL) applications. As in these applications, Autokey uses message digests to detect packet modification, digital signatures to verify credentials, and public certificates to provide traceable authority. What makes Autokey cryptography unique is the way in which these algorithms are used to deflect intruder attacks while maintaining the integrity and accuracy of the time synchronization function.",
      "ja": "自動キー暗号は、一般的にセキュアシェルとのSecure Sockets Layer（SSL）アプリケーションで使用されるPKIアルゴリズムに基づいています。これらのアプリケーションのように、自動キーは、追跡可能な権限を提供するために、資格情報、および公開証明書を検証するために、パケットの変更、デジタル署名を検出するためのメッセージダイジェストを使用しています。何のAutokey暗号のユニークな点は、時刻同期機能の完全性と正確性を維持しながら、これらのアルゴリズムは、侵入者の攻撃をそらすために使用される方法です。"
    },
    {
      "indent": 3,
      "text": "Autokey, like many other remote procedure call (RPC) protocols, depends on message digests for basic authentication; however, it is important to understand that message digests are also used by NTP when Autokey is not available or not configured. Selection of the digest algorithm is a function of NTP configuration and is transparent to Autokey.",
      "ja": "自動キーは、他の多くのリモートプロシージャコール（RPC）プロトコルのように、基本的な認証のためのダイジェストメッセージに依存します。自動キーが利用可能かどうか設定されていない場合しかし、また、NTPによって使用されるメッセージダイジェストを理解することが重要です。ダイジェストアルゴリズムの選択は、NTP設定の関数であり、自動キーに対して透過的です。"
    },
    {
      "indent": 3,
      "text": "The protocol design and reference implementation support both 128-bit and 160-bit message digest algorithms, each with a 32-bit key ID. In order to retain backwards compatibility with NTPv3, the NTPv4 key ID space is partitioned in two subspaces at a pivot point of 65536. Symmetric key IDs have values less than the pivot and indefinite lifetime. Autokey key IDs have pseudo-random values equal to or greater than the pivot and are expunged immediately after use.",
      "ja": "プロトコル設計およびリファレンス実装サポートは、128ビットおよび160ビットのメッセージ両方のアルゴリズム、32ビットの鍵IDと各ダイジェスト。 NTPv3との下位互換性を保持するために、NTPv4鍵ID空間が少ないピボットと不定寿命より65536対称鍵IDのピボット点で2つの部分空間の値を有する区画されています。自動キーのキーIDはピボット以上の擬似ランダム値を有し、使用後直ちに消去されます。"
    },
    {
      "indent": 3,
      "text": "Both symmetric key and public key cryptography authenticate as shown in Figure 1. The server looks up the key associated with the key ID and calculates the message digest from the NTP header and extension fields together with the key value. The key ID and digest form the message authentication code (MAC) included with the message. The client does the same computation using its local copy of the key and compares the result with the digest in the MAC. If the values agree, the message is assumed authentic.",
      "ja": "図1に示すように、両方の対称鍵および公開鍵暗号認証サーバは、鍵IDに関連付けられたキーを検索し、メッセージは、キー値とともにNTPヘッダーと拡張フィールドからダイジェストを計算します。鍵IDとメッセージ認証コード（MAC）を形成するメッセージダイジェストに含ま。クライアントは、キーのローカルコピーを使用して同じ計算を行い、MACでのダイジェストと結果を比較します。値が一致した場合、メッセージは本物と想定されます。"
    },
    {
      "indent": 16,
      "text": "+------------------+\n| NTP Header and   |\n| Extension Fields |\n+------------------+   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |       |        |   Message Authentication Code |\n     \\|/     \\|/       +              (MAC)            +\n********************   | +-------------------------+   |\n*   Compute Hash   *<----| Key ID | Message Digest |   +\n********************   | +-------------------------+   |\n          |            +-+-+-+-+-+-+-|-+-+-+-+-+-+-+-+-+\n         \\|/                        \\|/\n+------------------+       +-------------+\n|  Message Digest  |------>|   Compare   |\n+------------------+       +-------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 1: Message Authentication",
      "ja": "図1：メッセージ認証"
    },
    {
      "indent": 3,
      "text": "Autokey uses specially contrived session keys, called autokeys, and a precomputed pseudo-random sequence of autokeys that are saved in the autokey list. The Autokey protocol operates separately for each association, so there may be several autokey sequences operating independently at the same time.",
      "ja": "自動キーは特別に不自然なセッションキーと呼ばれるオートキー、および自動キーリストに保存されているオートキーの予め計算された擬似ランダムシーケンスを使用しています。オートキープロトコルは、各アソシエーションのために別々に動作するので、同時に独立して動作するいくつかのオートキー配列があってもよいです。"
    },
    {
      "indent": 19,
      "text": "+-------------+-------------+--------+--------+\n| Src Address | Dst Address | Key ID | Cookie |\n+-------------+-------------+--------+--------+",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Figure 2: NTPv4 Autokey",
      "ja": "図2：NTPv4のAutokey"
    },
    {
      "indent": 3,
      "text": "An autokey is computed from four fields in network byte order as shown in Figure 2. The four values are hashed using the MD5 algorithm to produce the 128-bit autokey value, which in the reference implementation is stored along with the key ID in a cache used for symmetric keys as well as autokeys. Keys are retrieved from the cache by key ID using hash tables and a fast lookup algorithm.",
      "ja": "図2に示すように、自動キーは、4つの値がリファレンス実装にキャッシュに鍵IDとともに記憶されている128ビットの自動キー値を生成するためにMD5アルゴリズムを使用してハッシュされ、ネットワークバイト順における4つのフィールドから計算され対称鍵だけでなく、オートキーを使用。キーはハッシュテーブルと高速検索アルゴリズムを使用してキーIDによってキャッシュから取得されます。"
    },
    {
      "indent": 3,
      "text": "For use with IPv4, the Src Address and Dst Address fields contain 32 bits; for use with IPv6, these fields contain 128 bits. In either case, the Key ID and Cookie fields contain 32 bits. Thus, an IPv4 autokey has four 32-bit words, while an IPv6 autokey has ten 32-bit words. The source and destination addresses and key ID are public values visible in the packet, while the cookie can be a public value or shared private value, depending on the NTP mode.",
      "ja": "IPv4の、Srcのアドレスとdstで使用するためのアドレスフィールドは、32ビットを含みます。 IPv6で使用するため、これらのフィールドは、128ビットを含みます。いずれの場合においても、鍵IDとクッキーフィールドは32ビットを含みます。 IPv6自動キーが10の32ビットワードを有しつつ、のIPv4自動キーは、4つの32ビットワードを有しています。クッキーは、NTPモードに応じて、公開値または共有プライベート値ことができるが、送信元と宛先アドレスと鍵IDは、パケット内の可視公開値です。"
    },
    {
      "indent": 3,
      "text": "The NTP packet format has been augmented to include one or more extension fields piggybacked between the original NTP header and the MAC. For packets without extension fields, the cookie is a shared private value. For packets with extension fields, the cookie has a default public value of zero, since these packets are validated independently using digital signatures.",
      "ja": "NTPパケットフォーマットは、一つ以上の拡張フィールドは、元のNTPヘッダとMAC間ピギーバック含むように拡張されています。拡張フィールドのないパケットの場合、クッキーは共有非公開の値です。これらのパケットは、独立して、デジタル署名を用いて検証されるので、拡張フィールドを有するパケットの場合、クッキーは、ゼロのデフォルト公開値を有します。"
    },
    {
      "indent": 3,
      "text": "There are some scenarios where the use of endpoint IP addresses may be difficult or impossible. These include configurations where network address translation (NAT) devices are in use or when addresses are changed during an association lifetime due to mobility constraints. For Autokey, the only restriction is that the address fields that are visible in the transmitted packet must be the same as those used to construct the autokey list and that these fields be the same as those visible in the received packet. (The use of alternative means, such as Autokey host names (discussed later) or hashes of these names may be a topic for future study.)",
      "ja": "エンドポイントのIPアドレスの使用が困難または不可能であるかもしれないいくつかのシナリオがあります。これらは、ネットワークアドレス変換（NAT）デバイス構成を含むアドレスが原因モビリティの制約に関連の存続期間中は変更されたときに使用されていますか。オートキーのために、唯一の制限は、送信されたパケット内に表示されたアドレスフィールドがオートキーのリストを構築し、これらのフィールドは、受信したパケットに見えるものと同じであることに使用されるものと同じでなければならないということです。 （例えばオートキーホスト名（後述）、またはこれらの名前のハッシュなどの代替手段を使用することは、今後の研究の課題であってもよいです。）"
    },
    {
      "indent": 0,
      "text": "+-----------+-----------+------+------+   +---------+  +-----+------+\n|Src Address|Dst Address|Key ID|Cookie|-->|         |  |Final|Final |\n+-----------+-----------+------+------+   | Session |  |Index|Key ID|\n     |           |         |        |     | Key ID  |  +-----+------+\n    \\|/         \\|/       \\|/      \\|/    |  List   |     |       |\n   *************************************  +---------+    \\|/     \\|/\n   *          COMPUTE HASH             *             *******************\n   *************************************             *COMPUTE SIGNATURE*\n     |                    Index n                    *******************\n    \\|/                                                       |\n   +--------+                                                 |\n   |  Next  |                                                \\|/\n   | Key ID |                                           +-----------+\n   +--------+                                           | Signature |\n   Index n+1                                            +-----------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 3: Constructing the Key List",
      "ja": "図3：キー一覧を構築"
    },
    {
      "indent": 3,
      "text": "Figure 3 shows how the autokey list and autokey values are computed. The key IDs used in the autokey list consist of a sequence starting with a random 32-bit nonce (autokey seed) greater than or equal to the pivot as the first key ID. The first autokey is computed as above using the given cookie and autokey seed and assigned index 0. The first 32 bits of the result in network byte order become the next key ID. The MD5 hash of the autokey is the key value saved in the key cache along with the key ID. The first 32 bits of the key become the key ID for the next autokey assigned index 1.",
      "ja": "図3は、オートキーリストと自動キー値が計算される方法を示しています。オートキーリストで使用される鍵IDは、以上の最初のキーIDとしてピボットに等しいランダム32ビットのノンス（オートキー種子）から始まる配列からなります。最初の自動キーは、与えられたクッキーおよび自動キーシードを用いて上記のように計算され、次のキーIDとなるネットワークバイト順にインデックス0の結果の最初の32ビットが割り当てられています。自動キーのMD5ハッシュは、キーIDと一緒にキーキャッシュに保存されたキーの値です。キーの最初の32ビットがインデックス1を割り当てられ、次のオートキーのためのキーIDになります。"
    },
    {
      "indent": 3,
      "text": "Operations continue to generate the entire list. It may happen that a newly generated key ID is less than the pivot or collides with another one already generated (birthday event). When this happens, which occurs only rarely, the key list is terminated at that point. The lifetime of each key is set to expire one poll interval after its scheduled use. In the reference implementation, the list is terminated when the maximum key lifetime is about one hour, so for poll intervals above one hour, a new key list containing only a single entry is regenerated for every poll.",
      "ja": "操作は、全体のリストを生成し続けます。新しく生成されたキーIDは、ピボット未満であるか、既に生成された別の1（誕生日のイベント）と衝突することが起こり得ます。これはまれにしか発生しない、発生した場合、キーリストはその時点で終了します。各キーの有効期間は、その使用予定の後に1回のポーリング間隔を期限切れに設定されています。一時間以上のポーリング間隔のために、単一のエントリのみを含む新しいキーリストは、すべての投票のために再生されるように、最大​​のキー寿命が、約1時間であるとき、リファレンス実装では、リストが終了されます。"
    },
    {
      "indent": 19,
      "text": "+------------------+\n|  NTP Header and  |\n| Extension Fields |\n+------------------+\n     |       |\n    \\|/     \\|/                     +---------+\n  ****************    +--------+    | Session |\n  * COMPUTE HASH *<---| Key ID |<---| Key ID  |\n  ****************    +--------+    |  List   |\n          |                |        +---------+\n         \\|/              \\|/\n+-----------------------------------+\n| Message Authentication Code (MAC) |\n+-----------------------------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 4: Transmitting Messages",
      "ja": "図4：メッセージを送信"
    },
    {
      "indent": 3,
      "text": "The index of the last autokey in the list is saved along with the key ID for that entry, collectively called the autokey values. The autokey values are then signed for use later. The list is used in reverse order as shown in Figure 4, so that the first autokey used is the last one generated.",
      "ja": "リストの最後の自動キーのインデックスをまとめて自動キー値と呼ばれ、そのエントリのキーIDと一緒に保存されます。自動キーの値は、後で使用するために署名されています。図4に示すように、使用される最初のオートキーが生成された最後のものであるように、リストは、逆の順序で使用されています。"
    },
    {
      "indent": 3,
      "text": "The Autokey protocol includes a message to retrieve the autokey values and verify the signature, so that subsequent packets can be validated using one or more hashes that eventually match the last key ID (valid) or exceed the index (invalid). This is called the autokey test in the following and is done for every packet, including those with and without extension fields. In the reference implementation, the most recent key ID received is saved for comparison with the first 32 bits in network byte order of the next following key value. This minimizes the number of hash operations in case a single packet is lost.",
      "ja": "オートキープロトコルは、自動キー値を取得し、後続のパケットが最終的に最後のキーID（有効）と一致またはインデックス（無効）を超えて一つ以上のハッシュを使用して検証することができるように、署名を検証するためのメッセージを含みます。これは以下で自動キーのテストと呼ばれ、パケットごとに行われ、拡張フィールドとないものも含みます。リファレンス実装では、受信した最新の鍵IDは次の次のキー値のネットワークバイト順で最初の32ビットとの比較のために保存されます。これは、単一のパケットが失われた場合には、ハッシュ操作の数を最小限に抑えることができます。"
    },
    {
      "indent": 0,
      "text": "5. Autokey Protocol Overview",
      "section_title": true,
      "ja": "5.自動キープロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The Autokey protocol includes a number of request/response exchanges that must be completed in order. In each exchange, a client sends a request message with data and expects a server response message with data. Requests and responses are contained in extension fields, one request or response in each field, as described later. An NTP packet can contain one request message and one or more response messages. The following is a list of these messages.",
      "ja": "オートキープロトコルは、順番に完了しなければならない要求/応答交換の数を含みます。各エクスチェンジでは、クライアントがデータを要求メッセージを送信し、データをサーバからの応答メッセージを期待しています。後述するように要求及び応答は、拡張フィールド、各フィールド内の1つの要求または応答に含まれています。 NTPパケットは、1つのリクエストメッセージと1つまたは複数の応答メッセージを含むことができます。以下では、これらのメッセージのリストです。"
    },
    {
      "indent": 3,
      "text": "o Parameter exchange. The request includes the client host name and status word; the response includes the server host name and status word. The status word specifies the digest/signature scheme to use and the identity schemes supported.",
      "ja": "Oパラメータ交換。要求は、クライアントのホスト名とステータス・ワードを含んでいます。応答は、サーバのホスト名とステータスワードが含まれています。ステータスワードは、使用するダイジェスト/署名方式およびサポートされているアイデンティティスキームを指定します。"
    },
    {
      "indent": 3,
      "text": "o Certificate exchange. The request includes the subject name of a certificate; the response consists of a signed certificate with that subject name. If the issuer name is not the same as the subject name, it has been signed by a host one step closer to a trusted host, so certificate retrieval continues for the issuer name. If it is trusted and self-signed, the trail concludes at the trusted host. If nontrusted and self-signed, the host certificate has not yet been signed, so the trail temporarily loops. Completion of this exchange lights the VAL bit as described below.",
      "ja": "O証明書交換。要求は、証明書のサブジェクト名を含みます。応答は、そのサブジェクト名を持つ署名された証明書で構成されています。発行者名が主題名と同じでない場合、それは一歩近づくトラステッド・ホストにホストによって署名されているので、証明書の取得は、発行者名に続けています。それは、信頼と自己署名されている場合は、トレイルは、信頼できるホストで終了します。信頼できないと自己署名した場合、ホスト証明書はまだ署名されていないので、トレイルは、一時的にループします。以下に説明するように、この交換の完了は、VALビットを点灯させます。"
    },
    {
      "indent": 3,
      "text": "o Identity exchange. The certificate trail is generally not considered sufficient protection against man-in-the-middle attacks unless additional protection such as the proof-of-possession scheme described in [RFC2875] is available, but this is expensive and requires servers to retain state. Autokey can use one of the challenge/response identity schemes described in Appendix B. Completion of this exchange lights the IFF bit as described below.",
      "ja": "Oアイデンティティ交換。証明書のトレイルは、一般的に、[RFC2875]で説明した実証の所持スキームなどの追加の保護がない限りman-in-the-middle攻撃に対して十分な保護とはみなされません提供されていますが、これは高価であり、状態を保持するサーバーが必要です。自動キーは、この交換の付録B.完了で説明チャレンジ/レスポンスアイデンティティスキームのいずれかを使用することができ、以下に説明するようにIFFビットを点灯します。"
    },
    {
      "indent": 3,
      "text": "o Cookie exchange. The request includes the public key of the server. The response includes the server cookie encrypted with this key. The client uses this value when constructing the key list. Completion of this exchange lights the COOK bit as described below.",
      "ja": "Oクッキー交換。リクエストは、サーバの公開鍵を含んでいます。応答は、この鍵で暗号化されたサーバクッキーを含んでいます。キーリストを構築するとき、クライアントは、この値を使用しています。以下に説明するように、この交換の完了は、COOKビットを点灯させます。"
    },
    {
      "indent": 3,
      "text": "o Autokey exchange. The request includes either no data or the autokey values in symmetric modes. The response includes the autokey values of the server. These values are used to verify the autokey sequence. Completion of this exchange lights the AUT bit as described below.",
      "ja": "自動キー交換、O。要求はデータ又は対称モードで自動キー値のいずれかを含んでいません。応答は、サーバの自動キー値が含まれています。これらの値は、自動キーシーケンスを確認するために使用されています。以下に説明するように、この交換の完了は、AUTビットを点灯させます。"
    },
    {
      "indent": 3,
      "text": "o Sign exchange. This exchange is executed only when the client has synchronized to a proventic source. The request includes the self-signed client certificate. The server acting as certification authority (CA) interprets the certificate as a X.509v3 certificate request. It extracts the subject, issuer, and extension fields, builds a new certificate with these data along with its own serial number and expiration time, then signs it using its own private key and includes it in the response. The client uses the signed certificate in its own role as server for dependent clients. Completion of this exchange lights the SIGN bit as described below.",
      "ja": "O交換をサイン。この交換は、クライアントがproventicソースに同期しているときにのみ実行されます。リクエストは、自己署名クライアント証明書が含まれています。認証局（CA）として動作するサーバーは、X.509v3証明書の要求として証明書を解釈します。これは、件名、発行者、および拡張フィールドを抽出し、独自のシリアル番号と有効期限と一緒に、これらのデータを使用して新しい証明書を作成します、それは自身の秘密鍵を使用して署名し、それに応答して、それを含んでいます。クライアントは、依存型クライアント用のサーバーとして、自身の役割で署名された証明書を使用しています。以下に説明するように、この交換の完了は、符号ビットを点灯させます。"
    },
    {
      "indent": 3,
      "text": "o Leapseconds exchange. This exchange is executed only when the client has synchronized to a proventic source. This exchange occurs when the server has the leapseconds values, as indicated in the host status word. If so, the client requests the values and compares them with its own values, if available. If the server values are newer than the client values, the client replaces its own with the server values. The client, acting as server, can now provide the most recent values to its dependent clients. In symmetric mode, this results in both peers having the newest values. Completion of this exchange lights the LPT bit as described below.",
      "ja": "為替Leapseconds O。この交換は、クライアントがproventicソースに同期しているときにのみ実行されます。ホスト・ステータス・ワードに示すように、サーバは、leapseconds値を持っている場合は、この交換が発生します。その場合、クライアントは値を要求し、利用可能な場合は、独自の値と比較します。サーバーの値がクライアント値よりも新しい場合、クライアントはサーバーの値を使用して、独自に置き換えられます。クライアントは、サーバーとして動作し、今その依存型クライアントに最新の値を提供することができます。対称モードでは、これは最新の値を有する両方のピアになります。以下に説明するように、この交換の完了は、LPTビットを点灯させます。"
    },
    {
      "indent": 3,
      "text": "Once the certificates and identity have been validated, subsequent packets are validated by digital signatures and the autokey sequence. The association is now proventic with respect to the downstratum trusted host, but is not yet selectable to discipline the system clock. The associations accumulate time values, and the mitigation algorithms continue in the usual way. When these algorithms have culled the falsetickers and cluster outliers and at least three survivors remain, the system clock has been synchronized to a proventic source.",
      "ja": "証明書と身元が確認された後、後続のパケットは、デジタル署名と自動キーシーケンスによって検証されています。協会は現在、downstratum信頼できるホストに関してproventicであるが、まだシステムクロックを訓練するために選択することはできません。協会は、時間値を蓄積し、緩和アルゴリズムは、通常の方法で継続します。これらのアルゴリズムはfalsetickersとクラスタ外れ値を淘汰しており、少なくとも3人の生存者が残っている場合、システムクロックはproventic源に同期されています。"
    },
    {
      "indent": 3,
      "text": "The time values for truechimer sources form a proventic partial ordering relative to the applicable signature timestamps. This raises the interesting issue of how to differentiate between the timestamps of different associations. It might happen, for instance, that the timestamp of some Autokey message is ahead of the system clock by some presumably small amount. For this reason, timestamp comparisons between different associations and between associations and the system clock are avoided, except in the NTP intersection and clustering algorithms and when determining whether a certificate has expired.",
      "ja": "truechimerソースの時間値は、適用可能な署名タイムスタンプに対してproventic部分的順序付けを形成します。これは、異なる団体のタイムスタンプを区別する方法の興味深い問題を提起します。いくつかの自動キーメッセージのタイムスタンプは、いくつかの、おそらく少しだけ先にシステムクロックのあることを、例えば、起こるかもしれません。このため、異なる団体間や団体とシステムクロック間のタイムスタンプの比較は、証明書の有効期限が切れているかどうかを判断する際のNTP交差点とクラスタリングアルゴリズムではと以外、回避されます。"
    },
    {
      "indent": 0,
      "text": "6. NTP Secure Groups",
      "section_title": true,
      "ja": "6. NTPセキュアグループ"
    },
    {
      "indent": 3,
      "text": "NTP secure groups are used to define cryptographic compartments and security hierarchies. A secure group consists of a number of hosts dynamically assembled as a forest with roots the trusted hosts (THs) at the lowest stratum of the group. The THs do not have to be, but often are, primary (stratum 1) servers. A trusted authority (TA), not necessarily a group host, generates private identity keys for servers and public identity keys for clients at the leaves of the forest. The TA deploys the server keys to the THs and other designated servers using secure means and posts the client keys on a public web site.",
      "ja": "NTP安全なグループは、暗号コンパートメントとセキュリティ階層を定義するために使用されています。安全なグループは、動的グループの最下位階層における根信頼できるホスト（THsと）と森林として組み立てホストの数から成ります。 THsとは、あることを持っていますが、多くの場合、プライマリ（階層1）サーバですありません。信頼された機関（TA）、必ずしもグループのホスト、森の葉で、クライアント用のサーバーやパブリックアイデンティティキーのプライベートアイデンティティ鍵を生成します。 TAは、安全な手段と投稿公共のウェブサイト上のクライアントキーを使用してTHsをし、他の指定されたサーバーへのサーバーキーを展開します。"
    },
    {
      "indent": 3,
      "text": "For Autokey purposes, all hosts belonging to a secure group have the same group name but different host names, not necessarily related to the DNS names. The group name is used in the subject and issuer fields of the TH certificates; the host name is used in these fields for other hosts. Thus, all host certificates are self-signed. During the use of the Autokey protocol, a client requests that the server sign its certificate and caches the result. A certificate trail is constructed by each host, possibly via intermediate hosts and ending at a TH. Thus, each host along the trail retrieves the entire trail from its server(s) and provides this plus its own signed certificates to its clients.",
      "ja": "自動キーの目的のために、安全なグループに属するすべてのホストが同じグループ名が異なるホスト名、必ずしもDNS名とは関係ありませんがあります。グループ名は、TH証明書のサブジェクトと発行者の分野で使用されています。ホスト名は、他のホストのためにこれらの分野で使用されています。このように、すべてのホスト証明書は自己署名されています。自動キープロトコルの使用時には、クライアントは、サーバがその証明書に署名することを要求し、その結果をキャッシュします。証明書証跡は、おそらく、中間のホストを介して、及びTHで終わる、各ホストで構成されています。このように、歩道に沿って、各ホストは、そのサーバ（群）から全体証跡を取得し、そのクライアントにこのプラス独自の署名付き証明書を提供します。"
    },
    {
      "indent": 3,
      "text": "Secure groups can be configured as hierarchies where a TH of one group can be a client of one or more other groups operating at a lower stratum. In one scenario, THs for groups RED and GREEN can be cryptographically distinct, but both be clients of group BLUE operating at a lower stratum. In another scenario, THs for group CYAN can be clients of multiple groups YELLOW and MAGENTA, both operating at a lower stratum. There are many other scenarios, but all must be configured to include only acyclic certificate trails.",
      "ja": "セキュア基は、1つのグループのTHが低い地層で動作する1つのまたは複数の他のグループのクライアントとすることができる階層構造として構成することができます。あるシナリオでは、グループ赤と緑のためTHsとは、暗号別個であることができるが、両方は、より低い階層で動作するグループBLUEのクライアントです。別のシナリオでは、グループシアンTHsとは、より低い階層で動作する複数のグループイエローとマゼンタ、両方のクライアントとすることができます。そこに多くの他のシナリオがありますが、すべては唯一の非環式、証明書のトレイルを含むように構成する必要があります。"
    },
    {
      "indent": 3,
      "text": "In Figure 5, the Alice group consists of THs Alice, which is also the TA, and Carol. Dependent servers Brenda and Denise have configured Alice and Carol, respectively, as their time sources. Stratum 3 server Eileen has configured both Brenda and Denise as her time sources. Public certificates are identified by the subject and signed by the issuer. Note that the server group keys have been previously installed on Brenda and Denise and the client group keys installed on all machines.",
      "ja": "図5では、アリス基はTHsをもTAであるアリスとキャロルから成ります。従属サーバブレンダとデニスは自分のタイムソースとして、それぞれ、アリスとキャロルを設定しています。階層3のサーバアイリーンは彼女の時間源としてブレンダとデニスの両方を設定しました。公共の証明書は、対象によって識別され、発行元によって署名されています。サーバグループのキーが以前ブレンダとデニスとすべてのマシンにインストールされたクライアントグループキーにインストールされていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "                  +-------------+ +-------------+ +-------------+\n                  | Alice Group | |    Brenda   | |    Denise   |\n                  |    Alice    | |             | |             |\n                  | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |\nCertificate       | | Alice |   | | | Brenda|   | | | Denise|   |\n+-+-+-+-+-+       | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |\n| Subject |       | | Alice*| 1 | | | Alice | 4 | | | Carol | 4 |\n+-+-+-+-+-+       | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |\n| Issuer  | S     |             | |             | |             |\n+-+-+-+-+-+       | +=======+   | | +-+-+-+-+   | | +-+-+-+-+   |\n                  | ||Alice|| 3 | | | Alice |   | | | Carol |   |\n Group Key        | +=======+   | | +-+-+-+-+   | | +-+-+-+-+   |\n+=========+       +-------------+ | | Alice*| 2 | | | Carol*| 2 |\n|| Group || S     | Alice Group | | +-+-+-+-+   | | +-+-+-+-+   |\n+=========+       |     Carol   | |             | |             |\n                  | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |\n S = step         | | Carol |   | | | Brenda|   | | | Denise|   |\n * = trusted      | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |\n                  | | Carol*| 1 | | | Brenda| 1 | | | Denise| 1 |\n                  | +-+-+-+-+   | | +-+-+-+-+   | | +-+-+-+-+   |\n                  |             | |             | |             |\n                  | +=======+   | | +=======+   | | +=======+   |\n                  | ||Alice|| 3 | | ||Alice|| 3 | | ||Alice|| 3 |\n                  | +=======+   | | +=======+   | | +=======+   |\n                  +-------------+ +-------------+ +-------------+\n                     Stratum 1                Stratum 2",
      "raw": true
    },
    {
      "indent": 21,
      "text": "+---------------------------------------------+\n|                  Eileen                     |\n|                                             |\n|           +-+-+-+-+   +-+-+-+-+             |\n|           | Eileen|   | Eileen|             |\n|           +-+-+-+-+   +-+-+-+-+             |\n|           | Brenda| 4 | Carol | 4           |\n|           +-+-+-+-+   +-+-+-+-+             |\n|                                             |\n|           +-+-+-+-+   +-+-+-+-+             |\n|           | Alice |   | Carol |             |\n|           +-+-+-+-+   +-+-+-+-+             |\n|           | Alice*| 2 | Carol*| 2           |\n|           +-+-+-+-+   +-+-+-+-+             |\n|                                             |\n|           +-+-+-+-+   +-+-+-+-+             |\n|           | Brenda|   | Denise|             |\n|           +-+-+-+-+   +-+-+-+-+             |\n|           | Alice | 2 | Carol | 2           |\n|           +-+-+-+-+   +-+-+-+-+             |\n|                                             |\n|                 +-+-+-+-+                   |\n|                 | Eileen|                   |\n|                 +-+-+-+-+                   |\n|                 | Eileen| 1                 |\n|                 +-+-+-+-+                   |\n|                                             |\n|                 +=======+                   |\n|                 ||Alice|| 3                 |\n|                 +=======+                   |\n+---------------------------------------------+\n                  Stratum 3",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 5: NTP Secure Groups",
      "ja": "図5：NTPセキュアグループ"
    },
    {
      "indent": 3,
      "text": "The steps in hiking the certificate trails and verifying identity are as follows. Note the step number in the description matches the step number in the figure.",
      "ja": "次のように証明書のハイキングコースや身元を確認の手順があります。説明のステップ番号は、図中のステップ番号と一致して注意してください。"
    },
    {
      "indent": 3,
      "text": "1. The girls start by loading the host key, sign key, self-signed certificate, and group key. Each client and server acting as a client starts the Autokey protocol by retrieving the server host name and digest/signature. This is done using the ASSOC exchange described later.",
      "ja": "1.女の子は、ホストキー、記号キー、自己署名証明書、およびグループキーをロードすることによって開始します。クライアントがサーバーのホスト名とダイジェスト/署名を取得してのAutokeyプロトコルを起動すると、各クライアントとサーバが動作します。これは、後述ASSOC交換を使用して行われます。"
    },
    {
      "indent": 3,
      "text": "2. They continue to load certificates recursively until a self-signed trusted certificate is found. Brenda and Denise immediately find trusted certificates for Alice and Carol, respectively, but Eileen will loop because neither Brenda nor Denise have their own certificates signed by either Alice or Carol. This is done using the CERT exchange described later.",
      "ja": "2.彼らは、自己署名の信頼できる証明書が発見されるまで、再帰的に証明書をロードし続けます。ブレンダもデニスのいずれもがアリスやキャロルのいずれかによって署名された、独自の証明書を持っているので、ブレンダとデニスはすぐに、それぞれ、アリスとキャロルのための信頼できる証明書を見つけることが、アイリーンがループ。これは、後述CERT交換を使用して行われます。"
    },
    {
      "indent": 3,
      "text": "3. Brenda and Denise continue with the selected identity schemes to verify that Alice and Carol have the correct group key previously generated by Alice. This is done using one of the identity schemes IFF, GQ, or MV, described later. If this succeeds, each continues in step 4.",
      "ja": "3.ブレンダとデニスはアリスとキャロルは、以前にアリスによって生成された正しいグループ鍵を持っていることを確認するために選択されたアイデンティティスキームを続行します。これは、アイデンティティスキームIFF、GQ、または後述のMV、のいずれかを使用して行われます。これが成功した場合、各ステップ4で継続されます。"
    },
    {
      "indent": 3,
      "text": "4. Brenda and Denise present their certificates for signature using the SIGN exchange described later. If this succeeds, either one of or both Brenda and Denise can now provide these signed certificates to Eileen, which may be looping in step 2. Eileen can now verify the trail via either Brenda or Denise to the trusted certificates for Alice and Carol. Once this is done, Eileen can complete the protocol just as Brenda and Denise did.",
      "ja": "4.ブレンダとデニスは、後述SIGN交換を使用して署名するための証明書を提示します。これが成功した場合、のいずれか一方またはブレンダとデニス両方が今アイリーンは現在、アリスとキャロルのための信頼された証明書にブレンダまたはデニスのいずれかを介して証跡を確認することができ、ステップ2でループすることができる、アイリーンにこれらの署名付き証明書を提供することができます。これが完了すると、アイリーンはブレンダとデニスがやったようなプロトコルを完了することができます。"
    },
    {
      "indent": 3,
      "text": "For various reasons, it may be convenient for a server to have client keys for more than one group. For example, Figure 6 shows three secure groups Alice, Helen, and Carol arranged in a hierarchy. Hosts A, B, C, and D belong to Alice with A and B as her THs. Hosts R and S belong to Helen with R as her TH. Hosts X and Y belong to Carol with X as her TH. Note that the TH for a group is always the lowest stratum and that the hosts of the combined groups form an acyclic graph. Note also that the certificate trail for each group terminates on a TH for that group.",
      "ja": "サーバーが複数のグループのためのクライアントの鍵を持っているため、様々な理由から、それは便利かもしれません。例えば、図6は、アリス、ヘレン、およびキャロルは、階層に配置された3つの安全なグループを示しています。ホストA、B、C、及びDは彼女THsをとしてAとBとアリスに属します。ホストのRとSは彼女のTHとしてRとヘレンに属します。ホストXとYは、彼女のTHとしてXとキャロルに属します。グループのためのTHは常に最も低い地層であることに注意し、合わせたグループのホストが非循環グラフを形成します。各グループの証明書証跡は、そのグループのためにTHで終わることにも注意してください。"
    },
    {
      "indent": 11,
      "text": "              *****     *****     @@@@@\nStratum 1     * A *     * B *     @ R @\n              *****     *****     @@@@@\n                  \\     /         /\n                   \\   /         /\n                   *****     @@@@@                *********\n        2          * C *     @ S @                * Alice *\n                   *****     @@@@@                *********\n                   /   \\     /\n                  /     \\   /                     @@@@@@@@@\n              *****     #####                     @ Helen @\n        3     * D *     # X #                     @@@@@@@@@\n              *****     #####\n                        /   \\                     #########\n                       /     \\                    # Carol #\n                   #####     #####                #########\n        4          # Y #     # Z #\n                   #####     #####",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 6: Hierarchical Overlapping Groups",
      "ja": "図6：階層オーバーラップグループ"
    },
    {
      "indent": 3,
      "text": "The intent of the scenario is to provide security separation, so that servers cannot masquerade as clients in other groups and clients cannot masquerade as servers. Assume, for example, that Alice and Helen belong to national standards laboratories and their server keys are used to confirm identity between members of each group. Carol is a prominent corporation receiving standards products and requiring cryptographic authentication. Perhaps under contract, host X belonging to Carol has client keys for both Alice and Helen and server keys for Carol. The Autokey protocol operates for each group separately while preserving security separation. Host X can prove identity in Carol to clients Y and Z, but cannot prove to anybody that it belongs to either Alice or Helen.",
      "ja": "シナリオの意図は、サーバが他のグループとクライアントでクライアントがサーバになりすますことができないになりすますことができないように、セキュリティの分離を提供することです。アリスとヘレンは、国家標準研究所に所属し、そのサーバーの鍵は、各グループのメンバー間の同一性を確認するために使用されていることを、例えば、想定しています。キャロルは標準規格の製品を受信し、暗号化認証を必要とする著名な企業です。おそらく、契約の下で、キャロルに属するホストXは、アリスとヘレンとキャロルのサーバーキーの両方のクライアントキーがあります。セキュリティの分離を維持しながらのAutokeyプロトコルは、個別に、各グループのために動作します。ホストXは、クライアントYとZのキャロルに身元を証明することができますが、それはアリスやヘレンのいずれかに属していることを誰に証明することはできません。"
    },
    {
      "indent": 0,
      "text": "7. Identity Schemes",
      "section_title": true,
      "ja": "7.アイデンティティスキーム"
    },
    {
      "indent": 3,
      "text": "A digital signature scheme provides secure server authentication, but it does not provide protection against masquerade, unless the server identity is verified by other means. The PKI model requires a server to prove identity to the client by a certificate trail, but independent means such as a driver's license are required for a CA to sign the server certificate. While Autokey supports this model by default, in a hierarchical ad hoc network, especially with server discovery schemes like NTP manycast, proving identity at each rest stop on the trail must be an intrinsic capability of Autokey itself.",
      "ja": "デジタル署名方式は、安全なサーバー認証を提供しますが、サーバのIDが他の手段によって検証されない限り、それは、仮面舞踏会に対する保護を提供していません。 PKIモデルは、証明書証跡によってクライアントに身元を証明するためにサーバを必要とするが、そのような運転免許証などの独立した手段は、サーバ証明書を署名するCAのために必要とされます。自動キーは、デフォルトではこのモデルをサポートしていますが、特にNTPのメニーキャストなどのサーバー発見方式と階層的なアドホックネットワーク、で、歩道上の各休憩で身元を証明することは自動キー自体の固有の能力でなければなりません。"
    },
    {
      "indent": 3,
      "text": "While the identity scheme described in [RFC2875] is based on a ubiquitous Diffie-Hellman infrastructure, it is expensive to generate and use when compared to others described in Appendix B. In principle, an ordinary public key scheme could be devised for this purpose, but the most stringent Autokey design requires that every challenge, even if duplicated, results in a different acceptable response.",
      "ja": "[RFC2875]で説明アイデンティティスキームはユビキタスのDiffie-Hellmanインフラストラクチャに基づいていますが、原則的には、付録Bに記載他人と比較すると、通常の公開鍵方式では、この目的のために考案することができ生成して使用することが高価です最も厳しいのAutokeyデザインは、そのすべての挑戦を必要とするが、重複した場合でも、別の許容可能な応答をもたらします。"
    },
    {
      "indent": 3,
      "text": "1. The scheme must have a relatively long lifetime, certainly longer than a typical certificate, and have no specific lifetime or expiration date. At the time the scheme is used, the host has not yet synchronized to a proventic source, so the scheme cannot depend on time.",
      "ja": "1.スキームは確かに長い典型的な証明よりも、比較的長い寿命を持っており、具体的な寿命や有効期限を持っていない必要があります。スキームが使用されている時には、ホストがまだproventicソースに同期していないので、スキームは、時間に依存することはできません。"
    },
    {
      "indent": 3,
      "text": "2. As the scheme can be used many times where the data might be exposed to potential intruders, the data must be either nonces or encrypted nonces.",
      "ja": "2.スキームは、データが潜在的な侵入者にさらされるかもしれない何回も使用することができるように、データは暗号化されたナンスやナンスのいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. The scheme should allow designated servers to prove identity to designated clients, but not allow clients acting as servers to prove identity to dependent clients.",
      "ja": "3.スキームは、指定されたサーバは、クライアントが依存型クライアントに身元を証明するために、サーバとして動作できるように指定されたクライアントに身元を証明する、ではなく、できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "4. To the greatest extent possible, the scheme should represent a zero-knowledge proof; that is, the client should be able to verify that the server has the correct group key, but without knowing the key itself.",
      "ja": "可能な限り4、ゼロ知識証明を表すべきスキーム。それは、クライアントがサーバーが正しいグループのキーを持っていますが、キー自体を知らずにいることを確認することができるはずです。"
    },
    {
      "indent": 3,
      "text": "There are five schemes now implemented in the NTPv4 reference implementation to prove identity: (1) private certificate (PC), (2) trusted certificate (TC), (3) a modified Schnorr algorithm (IFF aka Identify Friendly or Foe), (4) a modified Guillou-Quisquater (GQ) algorithm, and (5) a modified Mu-Varadharajan (MV) algorithm. Not all of these provide the same level of protection and one, TC, provides no protection but is included for comparison. The following is a brief summary description of each; details are given in Appendix B.",
      "ja": "（1）プライベート証明書（PC）、（2）信頼できる証明書（TC）、（3）修正シュアルゴリズム（IFFは別名フレンドリーや敵を識別）、（：今、身元を証明するNTPv4リファレンス実装で実装5つのスキームがあります。 4）変性Guillou-Quisquaterの（GQ）アルゴリズム、及び（5）変性ミューVaradharajan（MV）アルゴリズム。ないこれらのすべては、保護および1、TCの同じレベルを提供するには、保護機能はありませんが、比較のために含まれています。以下は、それぞれの簡単な概要説明です。詳細は付録Bに記載されています"
    },
    {
      "indent": 3,
      "text": "The PC scheme involves a private certificate as group key. The certificate is distributed to all other group members by secure means and is never revealed outside the group. In effect, the private certificate is used as a symmetric key. This scheme is used primarily for testing and development and is not recommended for regular use and is not considered further in this memo.",
      "ja": "PC方式は、グループキーとしてプライベート証明書を必要とします。証明書は、安全な手段により、他のすべてのグループのメンバーに配布され、グループ外に明らかにされることはありません。実際には、プライベート証明書は、対称鍵として使用されています。この方式は、主にテストや開発のために使用され、定期的に使用することは推奨されておらず、このメモでさらに考慮されていません。"
    },
    {
      "indent": 3,
      "text": "All other schemes involve a conventional certificate trail as described in [RFC5280]. This is the default scheme when an identity scheme is not required. While the remaining identity schemes incorporate TC, it is not by itself considered further in this memo.",
      "ja": "[RFC5280]に記載されているように、他のすべての方式は、従来の証明書証跡を伴います。これは、アイデンティティ・スキームが必要とされていないデフォルトのスキームです。残りのアイデンティティスキームはTCを取り入れながら、それ自体で、このメモでさらに考慮されていません。"
    },
    {
      "indent": 3,
      "text": "The three remaining schemes IFF, GQ, and MV involve a cryptographically strong challenge-response exchange where an intruder cannot deduce the server key, even after repeated observations of multiple exchanges. In addition, the MV scheme is properly described as a zero-knowledge proof, because the client can verify the server has the correct group key without either the server or client knowing its value. These schemes start when the client sends a nonce to the server, which then rolls its own nonce, performs a mathematical operation and sends the results to the client. The client performs another mathematical operation and verifies the results are correct.",
      "ja": "残りの3つのスキームIFF、GQ、およびMVは、侵入者でも、複数の取引所の繰り返し観測した後、サーバ鍵を推測することはできません暗号的に強いチャレンジ・レスポンスの交換を伴います。クライアントは、サーバがサーバまたはクライアントのどちらかが、その値を知らなくても、正しいグループ鍵を持っている確認することができるのでまた、MVスキームは正しく、ゼロ知識証明として記載されています。これらのスキームは、クライアントは、それ自身のnonceをロールサーバーにnonceを送信数学演算を実行し、その結果をクライアントに送信するときに開始します。クライアントは別の数学演算を実行し、結果が正しい確認します。"
    },
    {
      "indent": 0,
      "text": "8. Timestamps and Filestamps",
      "section_title": true,
      "ja": "8.タイムスタンプとFilestamps"
    },
    {
      "indent": 3,
      "text": "While public key signatures provide strong protection against misrepresentation of source, computing them is expensive. This invites the opportunity for an intruder to clog the client or server by replaying old messages or originating bogus messages. A client receiving such messages might be forced to verify what turns out to be an invalid signature and consume significant processor resources. In order to foil such attacks, every Autokey message carries a timestamp in the form of the NTP seconds when it was created. If the system clock is synchronized to a proventic source, a signature is produced with a valid (nonzero) timestamp. Otherwise, there is no signature and the timestamp is invalid (zero). The protocol detects and discards extension fields with old or duplicate timestamps, before any values are used or signatures are verified.",
      "ja": "公開鍵署名は元の不実表示に対する強力な保護を提供するが、それらは高価であるコンピューティング。これは、古いメッセージを再生または偽のメッセージを発信することにより、クライアントまたはサーバーを詰まらせるために、侵入者のための機会を誘います。このようなメッセージを受け取ったクライアントは、無効署名も、重要なプロセッサリソースを消費することが判明したものを確認するために強制される可能性があります。このような攻撃をくじくために、すべての自動キーメッセージは、それが作成されたNTP秒の形式でタイムスタンプを運びます。システムクロックはproventicソースと同期されている場合、署名は有効な（ゼロでない）タイムスタンプを用いて製造されます。そうでなければ、そこには署名がなく、タイムスタンプが（ゼロ）は無効です。任意の値が使用されているか、署名が検証される前に、プロトコルは、古いまたは重複したタイムスタンプを持つ拡張フィールドを検出し、破棄します。"
    },
    {
      "indent": 3,
      "text": "Signatures are computed only when cryptographic values are created or modified, which is by design not very often. Extension fields carrying these signatures are copied to messages as needed, but the signatures are not recomputed. There are three signature types:",
      "ja": "署名は、暗号値がない非常に多くの場合、設計によってである、作成または変更された場合にのみ計算されます。必要に応じてこれらの署名を保持する拡張フィールドは、メッセージにコピーされますが、署名は再計算されていません。 3つの署名タイプがあります。"
    },
    {
      "indent": 3,
      "text": "1. Cookie signature/timestamp. The cookie is signed when created by the server and sent to the client.",
      "ja": "1.クッキー署名/タイムスタンプ。サーバーによって作成され、クライアントに送信されたときにクッキーが署名されています。"
    },
    {
      "indent": 3,
      "text": "2. Autokey signature/timestamp. The autokey values are signed when the key list is created.",
      "ja": "2.オートキー署名/タイムスタンプ。キーリストが作成されたときに自動キー値が署名されています。"
    },
    {
      "indent": 3,
      "text": "3. Public values signature/timestamp. The public key, certificate, and leapsecond values are signed at the time of generation, which occurs when the system clock is first synchronized to a proventic source, when the values have changed and about once per day after that, even if these values have not changed.",
      "ja": "3.公共値署名/タイムスタンプ。公開鍵、証明書、および閏秒の値は、システムクロックが最初にこれらの値がいない場合でも、値が変更され、1日当たり約1回、その後しているとき、proventicソースに同期されたときに発生する、生成時に署名されていますかわった。"
    },
    {
      "indent": 3,
      "text": "The most recent timestamp received of each type is saved for comparison. Once a signature with a valid timestamp has been received, messages with invalid timestamps or earlier valid timestamps of the same type are discarded before the signature is verified. This is most important in broadcast mode, which could be vulnerable to a clogging attack without this test.",
      "ja": "各タイプの受信した最新のタイムスタンプは、比較のために保存されます。有効なタイムスタンプと署名が受信されると、署名が検証される前に、無効なタイムスタンプまたは同じタイプの以前の有効なタイムスタンプ付きのメッセージが破棄されます。これは、このテストなしで目詰まり攻撃の影響を受ける可能性があり、ブロードキャストモード、の中で最も重要です。"
    },
    {
      "indent": 3,
      "text": "All cryptographic values used by the protocol are time sensitive and are regularly refreshed. In particular, files containing cryptographic values used by signature and encryption algorithms are regenerated from time to time. It is the intent that file regenerations occur without specific advance warning and without requiring prior distribution of the file contents. While cryptographic data files are not specifically signed, every file is associated with a filestamp showing the NTP seconds at the creation epoch.",
      "ja": "プロトコルによって使用されるすべての暗号値は、時間に敏感であり、定期的に更新されます。具体的には、署名と暗号化アルゴリズムによって使用される暗号化値を含むファイルは随時再生されます。これは、ファイル再生の特定の事前の警告なしに、ファイルの内容の事前分布を必要とせずに発生する意図です。暗号化データファイルが具体的に署名されていないが、すべてのファイルが作成エポックでのNTP秒を示すfilestampに関連しています。"
    },
    {
      "indent": 3,
      "text": "Filestamps and timestamps can be compared in any combination and use the same conventions. It is necessary to compare them from time to time to determine which are earlier or later. Since these quantities have a granularity only to the second, such comparisons are ambiguous if the values are in the same second.",
      "ja": "Filestampsとタイムスタンプは、任意の組み合わせで比較し、同じ規則を使用することができます。以前以降であるかを決定するために、随時、それらを比較する必要があります。これらの量は、唯一の第二の粒度を有しているため値が同じ第二にある場合、そのような比較は曖昧です。"
    },
    {
      "indent": 3,
      "text": "It is important that filestamps be proventic data; thus, they cannot be produced unless the producer has been synchronized to a proventic source. As such, the filestamps throughout the NTP subnet represent a partial ordering of all creation epochs and serve as means to expunge old data and ensure new data are consistent. As the data are forwarded from server to client, the filestamps are preserved, including those for certificate and leapseconds values. Packets with older filestamps are discarded before spending cycles to verify the signature.",
      "ja": "filestampsはproventicデータであることが重要です。プロデューサがproventicソースと同期されていない限り、このように、それらは製造することができません。そのため、NTPサブネット全体filestampsは、すべての創造のエポックの一部の順序付けを表し、古いデータを抹消し、新しいデータが一致していることを確認するための手段としての役割を果たす。データがサーバからクライアントに転送されると、filestampsは、証明書とleapseconds値を含め、保存されています。古いfilestamps持つパケットは、署名を検証するサイクルを費やす前に廃棄されています。"
    },
    {
      "indent": 0,
      "text": "9. Autokey Operations",
      "section_title": true,
      "ja": "9.自動キー操作"
    },
    {
      "indent": 3,
      "text": "The NTP protocol has three principal modes of operation: client/ server, symmetric, and broadcast and each has its own Autokey program, or dance. Autokey choreography is designed to be non-intrusive and to require no additional packets other than for regular NTP operations. The NTP and Autokey protocols operate simultaneously and independently. When the dance is complete, subsequent packets are validated by the autokey sequence and thus considered proventic as well. Autokey assumes NTP clients poll servers at a relatively low rate, such as once per minute or slower. In particular, it assumes that a request sent at one poll opportunity will normally result in a response before the next poll opportunity; however, the protocol is robust against a missed or duplicate response.",
      "ja": "NTPプロトコルは、操作の基本的な3種類のモードがあります：クライアント/サーバー、対称、およびブロードキャストを、それぞれが独自の自動キープログラム、またはダンスを持っています。自動キー振り付けは、非侵入すると、通常のNTP業務用以外の追加のパケットを必要としないように設計されています。 NTPとのAutokeyプロトコルは、同時にかつ独立して動作します。ダンスが完了すると、後続のパケットは、自動キー配列により検証され、これにもproventicと考えられています。自動キーは、NTPクライアントに、このような分に一回か遅いかのような比較的低いレートでポーリングサーバを、前提としています。特に、1つのポーリング機会に送信された要求は、通常、次のポーリング機会の前に応答をもたらすだろうことを想定しています。しかし、このプロトコルは逃したか、重複応答に対してロバストです。"
    },
    {
      "indent": 3,
      "text": "The server dance was suggested by Steve Kent over lunch some time ago, but considerably modified since that meal. The server keeps no state for each client, but uses a fast algorithm and a 32-bit random private value (server seed) to regenerate the cookie upon arrival of a client packet. The cookie is calculated as the first 32 bits of the autokey computed from the client and server addresses, key ID zero, and the server seed as cookie. The cookie is used for the actual autokey calculation by both the client and server and is thus specific to each client separately.",
      "ja": "サーバーのダンスは、いくつかの時間前に昼食をとりながらスティーブ・ケントによって提案されたが、かなりその食事以降に変更されました。サーバは、各クライアントのために何の状態を保持しませんが、クライアントパケットの到着時にクッキーを再生するために、高速アルゴリズムと32ビットのランダムプライベート値（サーバ・シード）を使用しています。クッキーは、クッキーなどのクライアントおよびサーバのアドレスから計算自動キーの最初の32ビット、鍵IDゼロ、及びサーバシードとして算出されます。クッキーは、クライアントとサーバの両方によって実際のオートキーの計算に使用され、別々に各クライアントにこのように特定されます。"
    },
    {
      "indent": 3,
      "text": "In the server dance, the client uses the cookie and each key ID on the key list in turn to retrieve the autokey and generate the MAC. The server uses the same values to generate the message digest and verifies it matches the MAC. It then generates the MAC for the response using the same values, but with the client and server addresses interchanged. The client generates the message digest and verifies it matches the MAC. In order to deflect old replays, the client verifies that the key ID matches the last one sent. In this dance, the sequential structure of the key list is not exploited, but doing it this way simplifies and regularizes the implementation while making it nearly impossible for an intruder to guess the next key ID.",
      "ja": "サーバーのダンスでは、クライアントは、クッキーと自動キーを取得し、MACを生成するために順番にキーリスト上の各キーIDを使用しています。サーバーは、メッセージダイジェストを生成するために同じ値を使用し、それがMACと一致して検証します。その後、同じ値を使用して応答するためにMACを生成しますが、クライアントとサーバのアドレスと交換します。クライアントは、メッセージダイジェストを生成し、それがMACと一致して検証します。古いリプレイを偏向させるためには、クライアントがキーIDが最後の送信済み一致することを確認します。この踊りでは、キーリストのシーケンシャル構造が活用されていませんが、次のキーIDを推測するために、侵入者のために、それはほとんど不可能ながら、このようにそれを行うと、実装を簡素化し、regularizes。"
    },
    {
      "indent": 3,
      "text": "In the broadcast dance, clients normally do not send packets to the server, except when first starting up. At that time, the client runs the server dance to verify the server credentials and calibrate the propagation delay. The dance requires the association ID of the particular server association, since there can be more than one operating in the same server. For this purpose, the server packet includes the association ID in every response message sent and, when sending the first packet after generating a new key list, it sends the autokey values as well. After obtaining and verifying the autokey values, no extension fields are necessary and the client verifies further server packets using the autokey sequence.",
      "ja": "ブロードキャスト・ダンスでは、クライアントは通常、最初の起動時を除いて、サーバーにパケットを送信しません。その時、クライアントはサーバーの資格情報を確認し、伝播遅延を校正するために、サーバーのダンスを実行します。同じサーバ内で動作が複数存在することができるのでダンスは、特定のサーバアソシエーションのアソシエーションIDが必要です。この目的のために、サーバーのパケットが送信されると、新しい鍵リストを生成した後、最初のパケットを送信するとき、それは同様自動キー値を送信し、すべての応答メッセージ内の関連IDを含んでいます。自動キー値を取得して確認した後、何の拡張フィールドは必要ありませんし、クライアントが自動キーシーケンスを使用して、さらにサーバーのパケットを検証します。"
    },
    {
      "indent": 3,
      "text": "The symmetric dance is similar to the server dance and requires only a small amount of state between the arrival of a request and departure of the response. The key list for each direction is generated separately by each peer and used independently, but each is generated with the same cookie. The cookie is conveyed in a way similar to the server dance, except that the cookie is a simple nonce. There exists a possible race condition where each peer sends a cookie request before receiving the cookie response from the other peer. In this case, each peer winds up with two values, one it generated and one the other peer generated. The ambiguity is resolved simply by computing the working cookie as the EXOR of the two values.",
      "ja": "対称のダンスは、サーバーのダンスに似ており、応答の要求の到着と出発の間の状態のわずかな量を必要とします。各方向キーのリストは、各ピアによって別々に生成され、独立して使用されるが、それぞれが同一のクッキーを用いて生成されます。クッキーは、クッキーが簡単なナンスであることを除いて、サーバーのダンスと同様に搬送されます。各ピアが他のピアからのクッキーの応答を受信する前にクッキーの要求を送信可能な競合状態が存在します。この場合、各ピアは、2つの値、それが生成され1つずつ生成された他のピアと巻き取ります。曖昧さは、2つの値のEXORとして作動クッキーを計算することによって単純に解決されます。"
    },
    {
      "indent": 3,
      "text": "Once the Autokey dance has completed, it is normally dormant. In all except the broadcast dance, packets are normally sent without extension fields, unless the packet is the first one sent after generating a new key list or unless the client has requested the cookie or autokey values. If for some reason the client clock is stepped, rather than slewed, all cryptographic and time values for all associations are purged and the dances in all associations restarted from scratch. This ensures that stale values never propagate beyond a clock step.",
      "ja": "自動キーダンスが完了したら、それは通常は休止状態です。パケットは、新しいキーのリストを生成した後、または送信された最初のものでない限り、ブロードキャストダンスを除くすべてでは、パケットは通常、拡張フィールドなしで送信されているクライアントは、クッキーや自動キーの値を要求した場合を除きます。何らかの理由でクライアントクロックが強化されている場合は、スルーイングのではなく、すべての関連付けのためのすべての暗号化と時間の値がパージされ、すべての関連付けで踊りが最初から再開されます。これは、古い値がクロックステップを超えて伝播しないことを保証します。"
    },
    {
      "indent": 0,
      "text": "10. Autokey Protocol Messages",
      "section_title": true,
      "ja": "10.自動キープロトコルメッセージ"
    },
    {
      "indent": 3,
      "text": "The Autokey protocol data unit is the extension field, one or more of which can be piggybacked in the NTP packet. An extension field contains either a request with optional data or a response with optional data. To avoid deadlocks, any number of responses can be included in a packet, but only one request can be. A response is generated for every request, even if the requestor is not synchronized to a proventic source, but most contain meaningful data only if the responder is synchronized to a proventic source. Some requests and most responses carry timestamped signatures. The signature covers the entire extension field, including the timestamp and filestamp, where applicable. Only if the packet has correct format, length, and message digest are cycles spent to verify the signature.",
      "ja": "オートキープロトコルデータユニットは、NTPパケットにピギーバックすることができる1つ以上の拡張フィールドです。拡張フィールドは、オプションのデータを要求またはオプションのデータと応答のいずれかが含まれています。デッドロックを回避するには、応答の任意の数は、パケットに含めることができますが、唯一つの要求とすることができます。応答は、要求がproventicソースに同期されていない場合でも、すべての要求のために生成されますが、ほとんどは、レスポンダがproventicソースに同期されている場合にのみ意味のあるデータが含まれています。いくつかの要求と最も応答がタイムスタンプ署名を運びます。署名は、タイムスタンプとfilestamp、適用を含む全体の拡張フィールドをカバーします。パケットが正しい形式、長さ、およびメッセージダイジェストを持っている場合にのみサイクルは、署名を検証するために費やされています。"
    },
    {
      "indent": 3,
      "text": "There are currently eight Autokey requests and eight corresponding responses. The NTP packet format is described in [RFC5905] and the extension field format used for these messages is illustrated in Figure 7.",
      "ja": "8つの自動キー要求と8つのに対応する応答は現在ありません。 NTPパケットのフォーマットは、[RFC5905]に記載されており、これらのメッセージのために使用される拡張フィールドのフォーマットは、図7に示されています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|R|E|   Code    |  Field Type   |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Association ID                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Timestamp                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Filestamp                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Value Length                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               /",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/                             Value                             \\\n\\                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Signature Length                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               /\n/                           Signature                           \\\n\\                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\\                                                               /\n/                      Padding (if needed)                      \\\n\\                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 7: NTPv4 Extension Field Format",
      "ja": "図7：NTPv4拡張フィールドのフォーマット"
    },
    {
      "indent": 3,
      "text": "While each extension field is zero-padded to a 4-octet (word) boundary, the entire extension is not word-aligned. The Length field covers the entire extension field, including the Length and Padding fields. While the minimum field length is 8 octets, a maximum field length remains to be established. The reference implementation discards any packet with a field length more than 1024 octets.",
      "ja": "各拡張フィールドは、4オクテット（ワード）境界までゼロパディングされながら、全体の拡張は、ワード境界で整列されません。 Lengthフィールドは、長さとパディングフィールドを含む全体の拡張フィールドをカバーしています。最小フィールド長は8つのオクテットであるが、最大フィールド長は、確立されていません。リファレンス実装は、1024オクテットより多くのフィールドの長さを持つパケットを廃棄します。"
    },
    {
      "indent": 3,
      "text": "One or more extension fields follow the NTP packet header and the last followed by the MAC. The extension field parser initializes a pointer to the first octet beyond the NTP packet header and calculates the number of octets remaining to the end of the packet. If the remaining length is 20 (128-bit digest plus 4-octet key ID) or 22 (160-bit digest plus 4-octet key ID), the remaining data are the MAC and parsing is complete. If the remaining length is greater than 22, an extension field is present. If the remaining length is less than 8 or not a multiple of 4, a format error has occurred and the packet is discarded; otherwise, the parser increments the pointer by the extension field length and then uses the same rules as above to determine whether a MAC is present or another extension field.",
      "ja": "一つ以上の拡張フィールドは、NTPパケットのヘッダおよびMACに続いて、最後に従ってください。拡張フィールドパーサーは、NTPパケットのヘッダーを越えて最初のオクテットのポインタを初期化し、パケットの最後に残っているオクテットの数を算出します。残りの長さは、（160ビットのダイジェストプラス4オクテット鍵ID）20（128ビットのダイジェストプラス4オクテット鍵ID）または22である場合、残りのデータはMACであり、解析が完了しました。残りの長さが22より大きい場合、拡張フィールドが存在します。残りの長さが8未満、または4の倍数ではない場合には、フォーマットエラーが発生し、パケットは破棄されます。そうでない場合、パーサーは拡張フィールド長によってポインタをインクリメントした後、MACが存在するか、または別の拡張フィールドであるかどうかを決定するために上記と同じ規則を使用します。"
    },
    {
      "indent": 3,
      "text": "In Autokey the 8-bit Field Type field is interpreted as the version number, currently 2. For future versions, values 1-7 have been reserved for Autokey; other values may be assigned for other applications. The 6-bit Code field specifies the request or response operation. There are two flag bits: bit 0 is the Response Flag (R) and bit 1 is the Error Flag (E); the Reserved field is unused and should be set to 0. The remaining fields will be described later.",
      "ja": "オートキーの8ビットのフィールドタイプフィールドは、バージョン番号として解釈され、現在2将来のバージョンについては、1-7オートキーのために予約された値。他の値は、他のアプリケーションのために割り当てられてもよいです。 6ビットコードフィールドは、要求または応答操作を指定します。 2つのフラグビットがある：ビット0は、応答フラグ（R）であり、ビット1は、エラーフラグ（E）です。 Reservedフィールドは使用され、残りのフィールドは、後述する0に設定されるべきです。"
    },
    {
      "indent": 3,
      "text": "In the most common protocol operations, a client sends a request to a server with an operation code specified in the Code field and both the R bit and E bit dim. The server returns a response with the same operation code in the Code field and lights the R bit. The server can also light the E bit in case of error. Note that it is not necessarily a protocol error to send an unsolicited response with no matching request. If the R bit is dim, the client sets the Association ID field to the client association ID, which the server returns for verification. If the two values do not match, the response is discarded as if never sent. If the R bit is lit, the Association ID field is set to the server association ID obtained in the initial protocol exchange. If the Association ID field does not match any mobilized association ID, the request is discarded as if never sent.",
      "ja": "最も一般的なプロトコル動作では、クライアントはコードフィールドに指定された操作コードとRビットおよびEビット薄暗いの両方を使用してサーバーに要求を送信します。サーバは、コードフィールドに同じオペレーションコードに応答を返し、Rビットを点灯させます。サーバは、エラーの場合にはEビットを点灯することができます。必ずしも一致する要求に迷惑応答を送信するためのプロトコル・エラーではないことに留意されたいです。 Rビットが暗い場合は、クライアントは、クライアントのアソシエーションID、検証のためにサーバーが返すに協会のIDフィールドを設定します。 2つの値が一致しない場合は送信されることはありませんかのように、応答が破棄されます。 Rビットが点灯している場合、アソシエーションIDフィールドは、最初のプロトコル交換で得られたサーバアソシエーションIDに設定されています。協会のIDフィールドは任意の動員アソシエーションIDと一致しない場合は、要求が送信されることはありませんかのように廃棄されます。"
    },
    {
      "indent": 3,
      "text": "In some cases, not all fields may be present. For requests, until a client has synchronized to a proventic source, signatures are not valid. In such cases, the Timestamp field and Signature Length field (which specifies the length of the Signature) are zero and the Signature field is absent. Some request and error response messages carry no value or signature fields, so in these messages only the first two words (8 octets) are present.",
      "ja": "いくつかのケースでは、いないすべてのフィールドが存在してもよいです。クライアントがproventicソースに同期するまでの要求については、署名が有効ではありません。このような場合、タイムスタンプフィールドと（署名の長さを指定する）署名長さフィールドはゼロであり、署名フィールドは存在しません。いくつかの要求およびエラー応答メッセージは値または署名フィールドを搬送しないので、これらのメッセージにのみ最初の2つのワード（8オクテット）が存在しています。"
    },
    {
      "indent": 3,
      "text": "The Timestamp and Filestamp words carry the seconds field of an NTP timestamp. The timestamp establishes the signature epoch of the data field in the message, while the filestamp establishes the generation epoch of the file that ultimately produced the data that is signed.",
      "ja": "タイムスタンプとFilestamp言葉はNTPタイムスタンプの秒フィールドを運びます。 filestampが最終的に署名されたデータを生成したファイルの生成エポックを確立しながら、タイムスタンプは、メッセージ内のデータフィールドの署名エポックを確立します。"
    },
    {
      "indent": 3,
      "text": "A signature and timestamp are valid only when the signing host is synchronized to a proventic source; otherwise, the timestamp is zero. A cryptographic data file can only be generated if a signature is possible; otherwise, the filestamp is zero, except in the ASSOC response message, where it contains the server status word.",
      "ja": "署名とタイムスタンプが署名ホストがproventicソースに同期されている場合にのみ有効です。それ以外の場合は、タイムスタンプがゼロです。署名が可能である場合、暗号データ​​ファイルのみを生成することができます。そうでない場合は、filestampは、サーバ・ステータス・ワードが含まれているASSOC応答メッセージ、を除いて、ゼロです。"
    },
    {
      "indent": 3,
      "text": "As in all other TCP/IP protocol designs, all data are sent in network byte order. Unless specified otherwise in the descriptions to follow, the data referred to are stored in the Value field. The Value Length field specifies the length of the data in the Value field.",
      "ja": "他のすべてのTCP / IPプロトコルの設計と同様に、すべてのデータはネットワークバイト順序で送信されます。フォローする説明に別段の定めがない限り、参照されるデータは、Valueフィールドに格納されています。値長さフィールドは、Valueフィールド内のデータの長さを指定します。"
    },
    {
      "indent": 0,
      "text": "10.1. No-Operation",
      "section_title": true,
      "ja": "10.1. 無操作ん"
    },
    {
      "indent": 3,
      "text": "A No-operation request (Code 0) does nothing except return an empty response, which can be used as a crypto-ping.",
      "ja": "無操作要求（コード0）は、暗号のpingとして使用することができる空の応答を返す以外何もしません。"
    },
    {
      "indent": 0,
      "text": "10.2. Association Message (ASSOC)",
      "section_title": true,
      "ja": "10.2. 協会メッセージ（ASSOC）"
    },
    {
      "indent": 3,
      "text": "An Association Message (Code 1) is used in the parameter exchange to obtain the host name and status word. The request contains the client status word in the Filestamp field and the Autokey host name in the Value field. The response contains the server status word in the Filestamp field and the Autokey host name in the Value field. The Autokey host name is not necessarily the DNS host name. A valid response lights the ENAB bit and possibly others in the association status word.",
      "ja": "協会のメッセージ（コード1）は、ホスト名とステータスワードを取得するためにパラメータ交換に使用されています。リクエストは、ValueフィールドにFilestampフィールドにクライアントのステータスワードとのAutokeyホスト名が含まれています。応答は、ValueフィールドにFilestampフィールドにサーバーのステータスワードとのAutokeyホスト名が含まれています。自動キーのホスト名は、必ずしもDNSホスト名ではありません。有効な応答は、関連ステータスワードでENABビットと、おそらく他の人に点灯します。"
    },
    {
      "indent": 3,
      "text": "When multiple identity schemes are supported, the host status word determines which ones are available. In server and symmetric modes, the response status word contains bits corresponding to the supported schemes. In all modes, the scheme is selected based on the client identity parameters that are loaded at startup.",
      "ja": "複数のIDスキームがサポートされている場合は、ホスト・ステータス・ワードは、使用可能なものを決定します。サーバと対称モードでは、レスポンス・ステータス・ワードは、サポートされている方式に対応するビットを含みます。すべてのモードでは、スキームは、起動時にロードされているクライアントIDのパラメータに基づいて選択されます。"
    },
    {
      "indent": 0,
      "text": "10.3. Certificate Message (CERT)",
      "section_title": true,
      "ja": "10.3.  Certificateメッセージ（CERT）"
    },
    {
      "indent": 3,
      "text": "A Certificate Message (Code 2) is used in the certificate exchange to obtain a certificate by subject name. The request contains the subject name; the response contains the certificate encoded in X.509 format with ASN.1 syntax as described in Appendix H.",
      "ja": "証明書メッセージ（コード2）は、サブジェクト名で証明書を取得する証明書交換に使用されます。リクエストは、サブジェクト名が含まれています。応答は、付録Hに記載のようにASN.1構文でX.509形式でエンコードされた証明書を含みます"
    },
    {
      "indent": 3,
      "text": "If the subject name in the response does not match the issuer name, the exchange continues with the issuer name replacing the subject name in the request. The exchange continues until a trusted, self-signed certificate is found and lights the CERT bit in the association status word.",
      "ja": "応答でのサブジェクト名は、発行者名と一致しない場合、交換は、要求にサブジェクト名を置き換え発行者名と続きます。信頼され、自己署名証明書が見つかり、アソシエーションステータスワードのCERTビットを点灯するまで交換が続きます。"
    },
    {
      "indent": 0,
      "text": "10.4. Cookie Message (COOKIE)",
      "section_title": true,
      "ja": "10.4. クッキーのメッセージ（COOKIE）"
    },
    {
      "indent": 3,
      "text": "The Cookie Message (Code 3) is used in server and symmetric modes to obtain the server cookie. The request contains the host public key encoded with ASN.1 syntax as described in Appendix H. The response contains the cookie encrypted by the public key in the request. A valid response lights the COOKIE bit in the association status word.",
      "ja": "クッキーメッセージ（コード3）は、サーバクッキーを取得するためにサーバと、対称モードで使用されています。要求は、応答が要求内の公開鍵で暗号化されたCookieが含まれている付録H.で説明したようにASN.1構文でエンコードされたホスト公開鍵が含まれています。有効な応答は、関連ステータスワードのCOOKIEビットを点灯します。"
    },
    {
      "indent": 0,
      "text": "10.5. Autokey Message (AUTO)",
      "section_title": true,
      "ja": "10.5. 自動キーメッセージ（AUTO）"
    },
    {
      "indent": 3,
      "text": "The Autokey Message (Code 4) is used to obtain the autokey values. The request contains no value for a client or the autokey values for a symmetric peer. The response contains two 32-bit words, the first is the final key ID, while the second is the index of the final key ID. A valid response lights the AUTO bit in the association status word.",
      "ja": "オートキーメッセージ（コード4）は自動キー値を得るために使用されます。要求は、クライアントまたは対称ピアの自動キー値のための値を含んでいません。応答は、第二は、最終鍵IDのインデックスでありながら最初は、最終鍵IDであり、2つの32ビットワードを含みます。有効な応答は、関連ステータスワードのAUTOビットを点灯します。"
    },
    {
      "indent": 0,
      "text": "10.6. Leapseconds Values Message (LEAP)",
      "section_title": true,
      "ja": "10.6.  Leapsecondsは、メッセージを値（LEAP）"
    },
    {
      "indent": 3,
      "text": "The Leapseconds Values Message (Code 5) is used to obtain the leapseconds values as parsed from the leapseconds table from the National Institute of Standards and Technology (NIST). The request contains no values. The response contains three 32-bit integers: first the NTP seconds of the latest leap event followed by the NTP seconds when the latest NIST table expires and then the TAI offset following the leap event. A valid response lights the LEAP bit in the association status word.",
      "ja": "Leapsecondsメッセージ（コード5）は米国国立標準技術研究所（NIST）からleapsecondsテーブルから解析されたとしてleapseconds値を取得するために使用される値。リクエストは、値が含まれていません。最新のNISTテーブルの有効期限が切れたときのNTP秒続いた最新うるうイベントの最初のNTP秒、その後、TAIは飛躍イベント次オフセット：応答は、3つの32ビット整数が含まれています。有効な応答は、関連ステータスワードのLEAPビットを点灯します。"
    },
    {
      "indent": 0,
      "text": "10.7. Sign Message (SIGN)",
      "section_title": true,
      "ja": "10.7. メッセージの署名（SIGN）"
    },
    {
      "indent": 3,
      "text": "The Sign Message (Code 6) requests that the server sign and return a certificate presented in the request. The request contains the client certificate encoded in X.509 format with ASN.1 syntax as described in Appendix H. The response contains the client certificate signed by the server private key. A valid response lights the SIGN bit in the association status word.",
      "ja": "ログインメッセージ（コード6）は、サーバ記号とは、要求の中で提示された証明書を返すことを要求します。要求が応答は、サーバの秘密鍵で署名したクライアント証明書が含まれている付録H.で説明したようにASN.1構文でX.509形式でエンコードされたクライアント証明書が含まれています。有効な応答は、関連ステータスワードの符号ビットを点灯します。"
    },
    {
      "indent": 0,
      "text": "10.8. Identity Messages (IFF, GQ, MV)",
      "section_title": true,
      "ja": "10.8. アイデンティティメッセージ（IFF、GQ、MV）"
    },
    {
      "indent": 3,
      "text": "The Identity Messages (Code 7 (IFF), 8 (GQ), or 9 (MV)) contains the client challenge, usually a 160- or 512-bit nonce. The response contains the result of the mathematical operation defined in Appendix B. The Response is encoded in ASN.1 syntax as described in Appendix H. A valid response lights the VRFY bit in the association status word.",
      "ja": "アイデンティティ・メッセージ（コード7（IFF）、8（GQ）、または9（MV））は、クライアントの課題、通常160-または512ビットのノンスが含まれています。応答が有効な応答は、アソシエーション・ステータス・ワード内のVRFYビットを点灯付録H.で説明したようにASN.1シンタックスで符号化された付録Bザ応答で定義された数学的演算の結果を含んでいます。"
    },
    {
      "indent": 0,
      "text": "11. Autokey State Machine",
      "section_title": true,
      "ja": "11.自動キーステートマシン"
    },
    {
      "indent": 3,
      "text": "This section describes the formal model of the Autokey state machine, its state variables and the state transition functions.",
      "ja": "このセクションでは、自動キー・ステート・マシンの正式なモデル、その状態変数と状態遷移関数について説明します。"
    },
    {
      "indent": 0,
      "text": "11.1. Status Word",
      "section_title": true,
      "ja": "11.1. ステータスワード"
    },
    {
      "indent": 3,
      "text": "The server implements a host status word, while each client implements an association status word. These words have the format and content shown in Figure 8. The low-order 16 bits of the status word define the state of the Autokey dance, while the high-order 16 bits specify the Numerical Identifier (NID) as generated by the OpenSSL library of the OID for one of the message digest/signature encryption schemes defined in [RFC3279]. The NID values for the digest/signature algorithms defined in RFC 3279 are as follows:",
      "ja": "各クライアントがアソシエーションステータスワードを実装している間、サーバーは、ホスト・ステータス・ワードを実装しています。上位16ビットは、OpenSSLライブラリーによって生成される数値識別子（NID）を指定しながら、これらの言葉は、図8ステータス・ワードの16ビットがオートキーダンスの状態を定義する下位に示したフォーマットとコンテンツを持っています[RFC3279]で定義されたメッセージダイジェスト/署名暗号化方式のいずれかのOIDの。次のようにRFC 3279で定義されたダイジェスト/署名アルゴリズムのためのNIDの値は次のとおりです。"
    },
    {
      "indent": 10,
      "text": "+------------------------+----------------------+-----+\n|        Algorithm       | OID                  | NID |\n+------------------------+----------------------+-----+\n|         pkcs-1         | 1.2.840.113549.1.1   |   2 |\n|           md2          | 1.2.840.113549.2.2   |   3 |\n|           md5          | 1.2.840.113549.2.5   |   4 |\n|      rsaEncryption     | 1.2.840.113549.1.1.1 |   6 |\n|  md2WithRSAEncryption  | 1.2.840.113549.1.1.2 |   7 |\n|  md5WithRSAEncryption  | 1.2.840.113549.1.1.4 |   8 |\n|         id-sha1        | 1.3.14.3.2.26        |  64 |\n| sha-1WithRSAEncryption | 1.2.840.113549.1.1.5 |  65 |\n|     id-dsa-wth-sha1    | 1.2.840.10040.4.3    | 113 |\n|         id-dsa         | 1.2.840.10040.4.1    | 116 |\n+------------------------+----------------------+-----+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Bits 24-31 are reserved for server use, while bits 16-23 are reserved for client use. In the host portion, bits 24-27 specify the available identity schemes, while bits 28-31 specify the server capabilities. There are two additional bits implemented separately.",
      "ja": "ビット16-23は、クライアントが使用するために予約されている間のビット24-31は、サーバの使用のために予約されています。ビット28-31は、サーバ機能を指定しながら、ホスト部に、ビット24-27は、利用可能な識別スキームを指定します。別々に実装二つの追加のビットがあります。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Digest / Signature NID     |    Client     | Ident |  Host |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 8: Status Word",
      "ja": "図8：ステータスワード"
    },
    {
      "indent": 3,
      "text": "The host status word is included in the ASSOC request and response messages. The client copies this word to the association status word and then lights additional bits as the dance proceeds. Once enabled, these bits ordinarily never become dark unless a general reset occurs and the protocol is restarted from the beginning.",
      "ja": "ホスト・ステータス・ワードはASSOC要求と応答メッセージに含まれています。その後、クライアントコピーアソシエーションステータス・ワードにこの言葉とは、ダンスが進むなどの追加ビットを点灯します。有効にすると、これらのビットは、通常、一般的なリセットが発生しない限り、暗くなっていないとプロトコルは最初から再開されません。"
    },
    {
      "indent": 3,
      "text": "The host status bits are defined as follows:",
      "ja": "次のようにホスト・ステータス・ビットが定義されています。"
    },
    {
      "indent": 3,
      "text": "o ENAB (31) is lit if the server implements the Autokey protocol.",
      "ja": "サーバは、オートキープロトコルを実装する場合、O ENAB（31）が点灯されます。"
    },
    {
      "indent": 3,
      "text": "o LVAL (30) is lit if the server has installed leapseconds values, either from the NIST leapseconds file or from another server.",
      "ja": "サーバはleapseconds値をインストールしている場合、O LVAL（30）は、NIST leapsecondsファイルから、または別のサーバのいずれかから、点灯しています。"
    },
    {
      "indent": 3,
      "text": "o Bits (28-29) are reserved - always dark.",
      "ja": "Oビット（28-29）は、予約されている - 常に暗いです。"
    },
    {
      "indent": 3,
      "text": "o Bits 24-27 select which server identity schemes are available. While specific coding for various schemes is yet to be determined, the schemes available in the reference implementation and described in Appendix B include the following:",
      "ja": "Oビット24-27は、スキームが用意されていたサーバーのIDを選択します。様々な方式のための特定のコードがまだ決定されている間に、リファレンス実装で利用可能であり、付録Bに記載のスキームは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* none - Trusted Certificate (TC) Scheme (default).",
      "ja": "*なし - 信頼された証明書（TC）スキーム（デフォルト）。"
    },
    {
      "indent": 6,
      "text": "* PC (27) Private Certificate Scheme.",
      "ja": "* PC（27）プライベート証明書スキーム。"
    },
    {
      "indent": 6,
      "text": "* IFF (26) Schnorr aka Identify-Friendly-or-Foe Scheme.",
      "ja": "* IFF（26）シュ別名スキーム敵フレンドリーを識別-か - 。"
    },
    {
      "indent": 6,
      "text": "* GQ (25) Guillard-Quisquater Scheme.",
      "ja": "* GQ（25）ギラード-Quisquaterのスキーム。"
    },
    {
      "indent": 6,
      "text": "* MV (24) Mu-Varadharajan Scheme.",
      "ja": "*移動（24）R-varadharajamスキーム。"
    },
    {
      "indent": 3,
      "text": "o The PC scheme is exclusive of any other scheme. Otherwise, the IFF, GQ, and MV bits can be enabled in any combination.",
      "ja": "O PC方式は、他の方式の排他的です。それ以外の場合は、IFF、GQ、およびMVビットは任意の組み合わせで有効にすることができます。"
    },
    {
      "indent": 3,
      "text": "The association status bits are defined as follows:",
      "ja": "次のように関連ステータスビットが定義されています。"
    },
    {
      "indent": 3,
      "text": "o CERT (23): Lit when the trusted host certificate and public key are validated.",
      "ja": "O CERT（23）：点灯、信頼できるホスト証明書と公開鍵が検証されたとき。"
    },
    {
      "indent": 3,
      "text": "o VRFY (22): Lit when the trusted host identity credentials are confirmed.",
      "ja": "O VRFY（22）：点灯信頼できるホストのアイデンティティ証明書が確認されました。"
    },
    {
      "indent": 3,
      "text": "o PROV (21): Lit when the server signature is verified using its public key and identity credentials. Also called the proventic bit elsewhere in this memo. When enabled, signed values in subsequent messages are presumed proventic.",
      "ja": "PROV（21）O：サーバ署名は、公開鍵とアイデンティティの資格情報を使用して検証されて点灯。また、他の場所でこのメモでproventicビットと呼ばれます。有効にすると、それ以降のメッセージに署名した値がproventicと推定されています。"
    },
    {
      "indent": 3,
      "text": "o COOK (20): Lit when the cookie is received and validated. When lit, key lists with nonzero cookies are generated; when dim, the cookie is zero.",
      "ja": "O COOK（20）：クッキーが受信され、検証される点灯。点灯している場合、ゼロ以外のクッキーを持つキーリストが生成されます。とき薄暗い、クッキーはゼロです。"
    },
    {
      "indent": 3,
      "text": "o AUTO (19): Lit when the autokey values are received and validated. When lit, clients can validate packets without extension fields according to the autokey sequence.",
      "ja": "O AUTO（19）：点灯オートキー値を受信し、検証されたとき。点灯している場合、クライアントは自動キーシーケンスに応じて拡張フィールドなしでパケットを検証することができます。"
    },
    {
      "indent": 3,
      "text": "o SIGN (18): Lit when the host certificate is signed by the server.",
      "ja": "入出力SIGN（18）：点灯ホスト証明書がサーバによって署名されています。"
    },
    {
      "indent": 3,
      "text": "o LEAP (17): Lit when the leapseconds values are received and validated.",
      "ja": "O LEAP（17）：leapseconds値が受信され検証され点灯。"
    },
    {
      "indent": 3,
      "text": "o Bit 16: Reserved - always dark.",
      "ja": "O 16ビット：予約済み - 常に暗いです。"
    },
    {
      "indent": 3,
      "text": "There are three additional bits: LIST, SYNC, and PEER not included in the association status word. LIST is lit when the key list is regenerated and dim when the autokey values have been transmitted. This is necessary to avoid livelock under some conditions. SYNC is lit when the client has synchronized to a proventic source and never dim after that. PEER is lit when the server has synchronized, as indicated in the NTP header, and never dim after that.",
      "ja": "LIST、SYNC、およびピアはアソシエーションステータス・ワードに含まれていない：3つの追加ビットがあります。キーリストが再生され、自動キーの値が送信されたときに暗くされたときにLISTが点灯します。これは、いくつかの条件の下でライブロックを回避する必要があります。クライアントがproventic源に同期され、その後暗くはありませんでしたとき、SYNCが点灯します。サーバーが同期したときにピアがNTPヘッダーに示され、その後暗く決してとして、点灯しています。"
    },
    {
      "indent": 0,
      "text": "11.2. Host State Variables",
      "section_title": true,
      "ja": "11.2. 状態変数をホスト"
    },
    {
      "indent": 3,
      "text": "The following is a list of host state variables.",
      "ja": "以下は、ホストの状態変数のリストです。"
    },
    {
      "indent": 3,
      "text": "Host Name: The name of the host, by default the string returned by the Unix gethostname() library function. In the reference implementation, this is a configurable value.",
      "ja": "ホスト名：デフォルトでは、ホストの名前、Unixののgethostname（）ライブラリ関数によって返される文字列。リファレンス実装では、これは設定可能な値です。"
    },
    {
      "indent": 3,
      "text": "Host Status Word: This word is initialized when the host first starts up. The format is described above.",
      "ja": "ホストのステータスワード：ホストは最初の起動時にこの言葉が初期化されます。フォーマットは、上述されています。"
    },
    {
      "indent": 3,
      "text": "Host Key: The RSA public/private key pair used to encrypt/ decrypt cookies. This is also the default sign key.",
      "ja": "キーホスト：クッキーを暗号化/復号化するために使用するRSA公開鍵/秘密鍵のペアを。また、これは、デフォルトの記号キーです。"
    },
    {
      "indent": 3,
      "text": "Sign Key: The RSA or Digital Signature Algorithm (DSA) public/private key pair used to encrypt/decrypt signatures when the host key is not used for this purpose.",
      "ja": "キー記号：RSAまたはデジタル署名アルゴリズム（DSA）ホスト鍵が、この目的のために使用されていない場合、署名を復号化/暗号化するために使用される公開鍵/秘密鍵のペア。"
    },
    {
      "indent": 3,
      "text": "Sign Digest: The message digest algorithm used to compute the message digest before encryption.",
      "ja": "ダイジェストに署名：ダイジェストアルゴリズムは、暗号化の前に、メッセージダイジェストを計算するために使用されるメッセージを。"
    },
    {
      "indent": 3,
      "text": "IFF Parameters: The parameters used in the optional IFF identity scheme described in Appendix B.",
      "ja": "IFFパラメータ：付録Bに記載の任意のIFF識別スキームで使用されるパラメータ"
    },
    {
      "indent": 3,
      "text": "GQ Parameters: The parameters used in the optional GQ identity scheme described in Appendix B.",
      "ja": "GQパラメータ：付録Bに記載の任意のGQ識別スキームで使用されるパラメータ"
    },
    {
      "indent": 3,
      "text": "MV Parameters: The parameters used in the optional MV identity scheme described in Appendix B.",
      "ja": "MVパラメータ：付録Bに記載の任意のMVのアイデンティティ方式で使用されるパラメータ"
    },
    {
      "indent": 3,
      "text": "Server Seed: The private value hashed with the IP addresses and key identifier to construct the cookie.",
      "ja": "サーバーの種子：クッキーを構築するために、IPアドレスとキー識別子を使用してハッシュ民間値。"
    },
    {
      "indent": 3,
      "text": "CIS: Certificate Information Structure. This structure includes certain information fields from an X.509v3 certificate, together with the certificate itself. The fields extracted include the subject and issuer names, subject public key and message digest algorithm (pointers), and the beginning and end of the valid period in NTP seconds.",
      "ja": "CIS：証明書情報構造。この構造は証明書自体と一緒に、X.509v3証明書から特定の情報フィールドを含みます。抽出されたフィールドは、NTP秒で有効期間の対象と発行者名、サブジェクト公開鍵とメッセージアルゴリズム（ポインタ）を消化し、始まりと終わりが含まれます。"
    },
    {
      "indent": 24,
      "text": "The certificate itself is stored as an extension\nfield in network byte order so it can be copied\nintact to the message.  The structure is signed\nusing the sign key and carries the public values\ntimestamp at signature time and the filestamp of\nthe original certificate file.  The structure is\nused by the CERT response message and SIGN\nrequest and response messages.",
      "raw": true
    },
    {
      "indent": 24,
      "text": "A flags field in the CIS determines the status of the certificate. The field is encoded as follows:",
      "ja": "CIS内のフラグフィールドには、証明書のステータスを決定します。フィールドは、次のようにコード化されています。"
    },
    {
      "indent": 24,
      "text": "* TRUST (0x01) - The certificate has been signed by a trusted issuer. If the certificate is self-signed and contains \"trustRoot\" in the Extended Key Usage field, this bit is lit when the CIS is constructed.",
      "ja": "* TRUST（0×01） - 証明書は、信頼できる発行元によって署名されています。証明書が自己署名され、拡張キー使用法フィールドに「trustRoot」が含まれている場合、CISが構築されると、このビットが点灯しています。"
    },
    {
      "indent": 24,
      "text": "* SIGN (0x02) - The certificate signature has been verified. If the certificate is self-signed and verified using the contained public key, this bit is lit when the CIS is constructed.",
      "ja": "* SIGN（0×02） - 証明書の署名が検証されました。証明書が自己署名され、含まれる公開鍵を用いて検証した場合、CISが構築されると、このビットが点灯しています。"
    },
    {
      "indent": 24,
      "text": "* VALID (0x04) - The certificate is valid and can be used to verify signatures. This bit is lit when a trusted certificate has been found on a valid certificate trail.",
      "ja": "* VALID（0×04） - 証明書が有効であり、署名を検証するために使用することができます。信頼された証明書が有効な証明書の道に発見されたときに、このビットが点灯します。"
    },
    {
      "indent": 24,
      "text": "* PRIV (0x08) - The certificate is private and not to be revealed. If the certificate is self-signed and contains \"Private\" in the Extended Key Usage field, this bit is lit when the CIS is constructed.",
      "ja": "* PRIV（0x08の） - 証明書がプライベートで明らかにされてはなりません。証明書が自己署名され、拡張キー使用法フィールドに「プライベート」が含まれている場合、CISが構築されると、このビットが点灯しています。"
    },
    {
      "indent": 24,
      "text": "* ERROR (0x80) - The certificate is defective and not to be used in any way.",
      "ja": "* ERROR（0x80を） - 証明書は、欠陥のある、任意の方法で使用されるものではありません。"
    },
    {
      "indent": 3,
      "text": "Certificate List: CIS structures are stored on the certificate list in order of arrival, with the most recently received CIS placed first on the list. The list is initialized with the CIS for the host certificate, which is read from the host certificate file. Additional CIS entries are added to the list as certificates are obtained from the servers during the certificate exchange. CIS entries are discarded if overtaken by newer ones.",
      "ja": "証明書のリスト：最も最近受け取ったCISは、リストの上に最初に配置してCIS構造は、到着順に証明書リストに保存されます。リストは、ホスト証明書ファイルから読み込まれるホスト証明書、用CISで初期化されます。証明書は、証明書の交換中にサーバから取得される追加のCISエントリがリストに追加されます。新しいものに取って代わら場合CISエントリが破棄されます。"
    },
    {
      "indent": 24,
      "text": "The following values are stored as an extension\nfield structure in network byte order so they\ncan be copied intact to the message.  They are\nused to send some Autokey requests and\nresponses.  All but the Host Name Values\nstructure are signed using the sign key and all\ncarry the public values timestamp at signature\ntime.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Host Name Values: This is used to send ASSOC request and response messages. It contains the host status word and host name.",
      "ja": "名の値をホスト：これはASSOC要求と応答メッセージを送信するために使用されます。これは、ホスト・ステータス・ワードとホスト名が含まれています。"
    },
    {
      "indent": 3,
      "text": "Public Key Values: This is used to send the COOKIE request message. It contains the public encryption key used for the COOKIE response message.",
      "ja": "公開鍵値：これはCOOKIE要求メッセージを送信するために使用されます。これはCOOKIE応答メッセージに使用される公開暗号化キーが含まれています。"
    },
    {
      "indent": 3,
      "text": "Leapseconds Values: This is used to send the LEAP response message. It contains the leapseconds values in the LEAP message description.",
      "ja": "Leapseconds値：これは、LEAP応答メッセージを送信するために使用されます。これは、LEAPメッセージの説明にleapseconds値が含まれています。"
    },
    {
      "indent": 0,
      "text": "11.3. Client State Variables (all modes)",
      "section_title": true,
      "ja": "11.3. クライアントの状態変数（全モード）"
    },
    {
      "indent": 3,
      "text": "The following is a list of state variables used by the various dances in all modes.",
      "ja": "以下は、すべてのモードで様々な踊りで使用される状態変数のリストです。"
    },
    {
      "indent": 3,
      "text": "Association ID: The association ID used in responses. It is assigned when the association is mobilized.",
      "ja": "協会ID：レスポンスに使用さアソシエーションID。関連付けが動員されたときに割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Association Status Word: The status word copied from the ASSOC response; subsequently modified by the state machine.",
      "ja": "協会のステータスワード：ASSOC応答からコピーされたステータス・ワード;その後、ステートマシンによって変更。"
    },
    {
      "indent": 3,
      "text": "Subject Name: The server host name copied from the ASSOC response.",
      "ja": "サブジェクト名：ASSOC応答からコピーされたサーバーのホスト名。"
    },
    {
      "indent": 3,
      "text": "Issuer Name: The host name signing the certificate. It is extracted from the current server certificate upon arrival and used to request the next host on the certificate trail.",
      "ja": "発行者名：証明書に署名するホスト名。これは、到着時に、現在のサーバ証明書から抽出された証明書の歩道上の次のホストを要求するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Server Public Key: The public key used to decrypt signatures. It is extracted from the server host certificate.",
      "ja": "サーバ公開鍵：署名を復号化するために使用される公開鍵。これは、サーバのホスト証明書から抽出されます。"
    },
    {
      "indent": 3,
      "text": "Server Message Digest: The digest/signature scheme determined in the parameter exchange.",
      "ja": "サーバーメッセージダイジェスト：パラメータ交換で決定ダイジェスト/署名方式。"
    },
    {
      "indent": 3,
      "text": "Group Key: A set of values used by the identity exchange. It identifies the cryptographic compartment shared by the server and client.",
      "ja": "グループキー：アイデンティティ交換で使用される値のセット。これは、サーバとクライアントが共有する暗号コンパートメントを識別します。"
    },
    {
      "indent": 3,
      "text": "Receive Cookie Values: The cookie returned in a COOKIE response, together with its timestamp and filestamp.",
      "ja": "クッキーの値を受け取る：クッキーとは、一緒にそのタイムスタンプとfilestampで、COOKIE応答で返さ。"
    },
    {
      "indent": 3,
      "text": "Receive Autokey Values: The autokey values returned in an AUTO response, together with its timestamp and filestamp.",
      "ja": "自動キーの値を受け取る：自動キー値は、一緒にそのタイムスタンプとfilestampで、自動応答で返されます。"
    },
    {
      "indent": 3,
      "text": "Send Autokey Values: The autokey values with signature and timestamps.",
      "ja": "署名とタイムスタンプを自動キー値：自動キー値を送信します。"
    },
    {
      "indent": 3,
      "text": "Key List: A sequence of key IDs starting with the autokey seed and each pointing to the next. It is computed, timestamped, and signed at the next poll opportunity when the key list becomes empty.",
      "ja": "キーリスト：自動キーシードと次の各ポインティングで始まるキーIDのシーケンス。これは、計算されたタイムスタンプ、およびキーリストが空になったときに、次のポーリング機会に署名されています。"
    },
    {
      "indent": 3,
      "text": "Current Key Number: The index of the entry on the Key List to be used at the next poll opportunity.",
      "ja": "現在のキー番号：次のポーリング機会に使用するキーリスト上のエントリのインデックス。"
    },
    {
      "indent": 0,
      "text": "11.4. Protocol State Transitions",
      "section_title": true,
      "ja": "11.4. プロトコルの状態遷移"
    },
    {
      "indent": 3,
      "text": "The protocol state machine is very simple but robust. The state is determined by the client status word bits defined above. The state transitions of the three dances are shown below. The capitalized truth values represent the client status bits. All bits are initialized as dark and are lit upon the arrival of a specific response message as detailed above.",
      "ja": "プロトコル状態マシンは非常にシンプルだが堅牢です。状態は、上記で定義されたクライアント・ステータス・ワードのビットによって決定されます。 3人のダンスの状態遷移を以下に示します。大文字の真理値は、クライアントのステータス・ビットを表します。全てのビットが暗初期化され、上記で詳述したように特定の応答メッセージの到着時に点灯されます。"
    },
    {
      "indent": 0,
      "text": "11.4.1. Server Dance",
      "section_title": true,
      "ja": "11.4.1. サーバーのダンス"
    },
    {
      "indent": 3,
      "text": "The server dance begins when the client sends an ASSOC request to the server. The clock is updated when PREV is lit and the dance ends when LEAP is lit. In this dance, the autokey values are not used, so an autokey exchange is not necessary. Note that the SIGN and LEAP requests are not issued until the client has synchronized to a proventic source. Subsequent packets without extension fields are validated by the autokey sequence. This example and others assumes the IFF identity scheme has been selected in the parameter exchange.",
      "ja": "クライアントがサーバーにASSOC要求を送信するときに、サーバーのダンスが始まります。クロックはPREVが点灯しているときに更新され、LEAPが点灯しているとき、ダンスを終了します自動キー交換は必要ありませんので、この踊りでは、自動キー値は、使用されません。クライアントがproventicソースに同期されるまでSIGNとLEAP要求が発行されていないことに注意してください。拡張フィールドのない後続のパケットは、自動キーシーケンスによって検証されています。この例などはIFF識別スキームはパラメータ交換で選択されている前提としています。"
    },
    {
      "indent": 0,
      "text": "1       while (1) {\n2               wait_for_next_poll;\n3               make_NTP_header;\n4               if (response_ready)\n5                       send_response;\n6               if (!ENB)             /* parameter exchange */\n7                       ASSOC_request;\n8               else if (!CERT)       /* certificate exchange */\n9                       CERT_request(Host_Name);\n10              else if (!IFF)        /* identity exchange */\n11                      IFF_challenge;\n12              else if (!COOK)       /* cookie exchange */\n13                      COOKIE_request;\n14              else if (!SYNC)       /* wait for synchronization */\n15                      continue;\n16              else if (!SIGN)       /* sign exchange */\n17                      SIGN_request(Host_Certificate);\n18              else if (!LEAP)       /* leapsecond values exchange */\n19                      LEAP_request;\n20              send packet;\n21      }",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 9: Server Dance",
      "ja": "図9：サーバーのダンス"
    },
    {
      "indent": 3,
      "text": "If the server refreshes the private seed, the cookie becomes invalid. The server responds to an invalid cookie with a crypto-NAK message, which causes the client to restart the protocol from the beginning.",
      "ja": "サーバーがプライベートシードを更新した場合は、クッキーが無効になります。サーバは、最初からプロトコルを再起動するために、クライアントの原因となる暗号NAKメッセージ、と無効なクッキーに応答します。"
    },
    {
      "indent": 0,
      "text": "11.4.2. Broadcast Dance",
      "section_title": true,
      "ja": "11.4.2. ブロードキャスト・ダンス"
    },
    {
      "indent": 3,
      "text": "The broadcast dance is similar to the server dance with the cookie exchange replaced by the autokey values exchange. The broadcast dance begins when the client receives a broadcast packet including an ASSOC response with the server association ID. This mobilizes a client association in order to proventicate the source and calibrate the propagation delay. The dance ends when the LEAP bit is lit, after which the client sends no further packets. Normally, the broadcast server includes an ASSOC response in each transmitted packet. However, when the server generates a new key list, it includes an AUTO response instead.",
      "ja": "放送ダンスは、オートキー値交換によって置き換えクッキー交換とサーバーのダンスに似ています。クライアントはサーバアソシエーションIDとASSOC応答を含むブロードキャストパケットを受信したときにブロードキャスト踊りが始まります。これは、ソースをproventicate伝搬遅延を較正するために、クライアント・アソシエーションを動員します。 LEAPビットはクライアントがそれ以上のパケットを送信しないされた後、点灯しているときのダンスは終了します。通常、ブロードキャスト・サーバーは、各送信されたパケットでASSOC応答を含みます。サーバーは、新しいキーのリストを生成するときしかし、それは代わりにAUTO応答を含んでいます。"
    },
    {
      "indent": 0,
      "text": "   In the broadcast dance, extension fields are used with every packet,\n   so the cookie is always zero and no cookie exchange is necessary.  As\n   in the server dance, the clock is updated when PREV is lit and the dance ends when LEAP is lit.  Note that the SIGN and LEAP requests\n   are not issued until the client has synchronized to a proventic\n   source.  Subsequent packets without extension fields are validated by\n   the autokey sequence.\n1       while (1) {\n2               wait_for_next_poll;\n3               make_NTP_header;\n4               if (response_ready)\n5                       send_response;\n6               if (!ENB)              /* parameters exchange */\n7                       ASSOC_request;\n8               else if (!CERT)        /* certificate exchange */\n9                       CERT_request(Host_Name);\n10              else if (!IFF)         /* identity exchange */\n11                      IFF_challenge;\n12              else if (!AUT)         /* autokey values exchange */\n13                      AUTO_request;\n14              else if (!SYNC)        /* wait for synchronization */\n15                      continue;\n16              else if (!SIGN)        /* sign exchange */\n17                      SIGN_request(Host_Certificate);\n18              else if (!LEAP)        /* leapsecond values exchange */\n19                      LEAP_request;\n20              send NTP_packet;\n21      }",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 10: Broadcast Dance",
      "ja": "図10：ブロードキャスト・ダンス"
    },
    {
      "indent": 3,
      "text": "If a packet is lost and the autokey sequence is broken, the client hashes the current autokey until either it matches the previous autokey or the number of hashes exceeds the count given in the autokey values. If the latter, the client sends an AUTO request to retrieve the autokey values. If the client receives a crypto-NAK during the dance, or if the association ID changes, the client restarts the protocol from the beginning.",
      "ja": "パケットが失われ、自動キーシーケンスが壊れている場合のいずれか、それは前の自動キーと一致するか、ハッシュの数は、自動キー値で与えられた数を超えるまで、クライアントは現在の自動キーをハッシュします。後者の場合、クライアントは自動キーの値を取得するにはAUTO要求を送信します。クライアントは、ダンス中に暗号NAKを受信した場合、またはアソシエーションIDが変化した場合、クライアントは最初からプロトコルを再起動します。"
    },
    {
      "indent": 0,
      "text": "11.4.3. Symmetric Dance",
      "section_title": true,
      "ja": "11.4.3. 対称ダンス"
    },
    {
      "indent": 3,
      "text": "The symmetric dance is intricately choreographed. It begins when the active peer sends an ASSOC request to the passive peer. The passive peer mobilizes an association and both peers step a three-way dance where each peer completes a parameter exchange with the other. Until one of the peers has synchronized to a proventic source (which could be the other peer) and can sign messages, the other peer loops waiting for a valid timestamp in the ensuing CERT response.",
      "ja": "対称ダンスが複雑に振り付けされます。アクティブピアがパッシブピアにASSOC要求を送信したときにそれが開始されます。パッシブピアはアソシエーションを動員し、両方のピアは、各ピアが他とパラメータ交換を完了三方ダンスステップ。ピアの1つが、（他のピアとすることができる）と、メッセージに署名することができproventicソースと同期するまで、後続CERT応答の有効なタイムスタンプを待っている他のピア・ループ。"
    },
    {
      "indent": 0,
      "text": "1       while (1) {\n2               wait_for_next_poll;\n3               make_NTP_header;\n4               if (!ENB)             /* parameters exchange */\n5                       ASSOC_request;\n6               else if (!CERT)       /* certificate exchange */\n7                       CERT_request(Host_Name);\n8               else if (!IFF)        /* identity exchange */\n9                       IFF_challenge;\n10              else if (!COOK && PEER) /* cookie exchange */\n11                      COOKIE_request);\n12              else if (!AUTO)       /* autokey values exchange */\n13                      AUTO_request;\n14              else if (LIST)        /* autokey values response */\n15                      AUTO_response;\n16              else if (!SYNC)       /* wait for synchronization */\n17                      continue;\n18              else if (!SIGN)       /* sign exchange */\n19                      SIGN_request;\n20              else if (!LEAP)       /* leapsecond values exchange */\n21                      LEAP_request;\n22              send NTP_packet;\n23      }",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 11: Symmetric Dance",
      "ja": "図11：対称ダンス"
    },
    {
      "indent": 3,
      "text": "Once a peer has synchronized to a proventic source, it includes timestamped signatures in its messages. The other peer, which has been stalled waiting for valid timestamps, now mates the dance. It retrieves the now nonzero cookie using a cookie exchange and then the updated autokey values using an autokey exchange.",
      "ja": "ピアがproventicソースと同期したら、そのメッセージにタイムスタンプ署名を含みます。有効なタイムスタンプを待って失速してきた他のピアは、今のダンスをかみ合います。これは、クッキー交換やオートキー交換を使用して、更新された自動キー値を使用して、今、非ゼロクッキーを取得します。"
    },
    {
      "indent": 3,
      "text": "As in the broadcast dance, if a packet is lost and the autokey sequence broken, the peer hashes the current autokey until either it matches the previous autokey or the number of hashes exceeds the count given in the autokey values. If the latter, the client sends an AUTO request to retrieve the autokey values. If the peer receives a crypto-NAK during the dance, or if the association ID changes, the peer restarts the protocol from the beginning.",
      "ja": "どちらかそれは前の自動キーと一致するか、ハッシュの数は、自動キー値で与えられた数を超えるまで放送ダンスのように、パケットが失われたと自動キーシーケンスが壊れた場合、ピアは、現在の自動キーをハッシュします。後者の場合、クライアントは自動キーの値を取得するにはAUTO要求を送信します。ピアがダンス中に暗号NAKを受信した場合、またはアソシエーションIDが変化した場合、ピアは最初からプロトコルを再起動します。"
    },
    {
      "indent": 0,
      "text": "11.5. Error Recovery",
      "section_title": true,
      "ja": "11.5. エラーからの回復"
    },
    {
      "indent": 3,
      "text": "The Autokey protocol state machine includes provisions for various kinds of error conditions that can arise due to missing files, corrupted data, protocol violations, and packet loss or misorder, not to mention hostile intrusion. This section describes how the protocol responds to reachability and timeout events that can occur due to such errors.",
      "ja": "Autokeyプロトコルステートマシンは、敵対的な侵入はもちろんのこと、により不足しているファイル、破損したデータ、プロトコル違反、およびパケット損失またはmisorderに発生する可能性があるエラー条件のさまざまな種類の条項が含まれています。このセクションでは、プロトコルは、このようなエラーが原因で発生する可能性が到達可能性とタイムアウトイベントに応答する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "A persistent NTP association is mobilized by an entry in the configuration file, while an ephemeral association is mobilized upon the arrival of a broadcast or symmetric active packet with no matching association. Subsequently, a general reset reinitializes all association variables to the initial state when first mobilized. In addition, if the association is ephemeral, the association is demobilized and all resources acquired are returned to the system.",
      "ja": "エフェメラルアソシエーションが一致する関連付けブロードキャストまたは対称活性パケットの到着時に動員されている間、永続NTPアソシエーションは、設定ファイル内のエントリによって動員されます。最初の動員ときその後、一般的なリセットが初期状態にすべての関連変数を再初期化します。アソシエーションが短命である場合に加えて、関連が復員して、取得したすべてのリソースはシステムに戻されます。"
    },
    {
      "indent": 3,
      "text": "Every NTP association has two variables that maintain the liveness state of the protocol, the 8-bit reach register and the unreach counter defined in [RFC5905]. At every poll interval, the reach register is shifted left, the low order bit is dimmed and the high order bit is lost. At the same time, the unreach counter is incremented by one. If an arriving packet passes all authentication and sanity checks, the rightmost bit of the reach register is lit and the unreach counter is set to zero. If any bit in the reach register is lit, the server is reachable; otherwise, it is unreachable.",
      "ja": "すべてのNTPアソシエーションは、プロトコルのライブネス状態を維持する2つの変数を有し、8ビットレジスタに達すると[RFC5905]で定義さUNREACHカウンタ。すべてのポーリング間隔で、リーチレジスタは、左にシフトされた下位ビットが淡色表示され、上位ビットが失われます。同時に、UNREACHカウンタを1増加させます。到着したパケットは、すべての認証および健全性チェックに合格した場合、リーチレジスタの右端のビットが点灯し、UNREACHカウンタがゼロに設定されています。リーチレジスタの任意のビットが点灯している場合は、サーバが到達可能です。そうでない場合は、それが到達不能です。"
    },
    {
      "indent": 3,
      "text": "When the first poll is sent from an association, the reach register and unreach counter are set to zero. If the unreach counter reaches 16, the poll interval is doubled. In addition, if association is persistent, it is demobilized. This reduces the network load for packets that are unlikely to elicit a response.",
      "ja": "最初のポーリングが会合から送信されると、リーチレジスタとUNREACHカウンタがゼロに設定されます。 UNREACHカウンタが16に達した場合、ポーリング間隔が2倍になります。関連付けが永続的である場合に加えて、それが復員されます。これは、応答を誘発する可能性は低いパケットのためのネットワーク負荷を軽減します。"
    },
    {
      "indent": 3,
      "text": "At each state in the protocol, the client expects a particular response from the server. A request is included in the NTP packet sent at each poll interval until a valid response is received or a general reset occurs, in which case the protocol restarts from the beginning. A general reset also occurs for an association when an unrecoverable protocol error occurs. A general reset occurs for all associations when the system clock is first synchronized or the clock is stepped or when the server seed is refreshed.",
      "ja": "プロトコルの各状態において、クライアントは、サーバからの特定の応答を期待します。要求が有効な応答が受信されるか、または一般的なリセットプロトコルは最初から再開した場合に、発生するまで各ポーリング間隔で送信されたNTPパケットに含まれています。回復不能プロトコルエラーが発生した場合の一般的なリセットはまた、関連付けのために生じます。システム・クロックを最初に同期されたときに一般的なリセットはすべての関連付けのために発生した場合、またはクロックが進められるか、サーバ種子が更新されたとき。"
    },
    {
      "indent": 3,
      "text": "There are special cases designed to quickly respond to broken associations, such as when a server restarts or refreshes keys. Since the client cookie is invalidated, the server rejects the next client request and returns a crypto-NAK packet. Since the crypto-NAK has no MAC, the problem for the client is to determine whether it is legitimate or the result of intruder mischief. In order to reduce the vulnerability in such cases, the crypto-NAK, as well as all responses, is believed only if the result of a previous packet sent by the client and not a replay, as confirmed by the NTP on-wire protocol. While this defense can be easily circumvented by a man-in-the-middle, it does deflect other kinds of intruder warfare.",
      "ja": "迅速なサーバが再起動するか、キーを更新する場合などの関連付けを、壊れたために応答するように設計された特別なケースがあります。クライアントのクッキーが無効化されるので、サーバーは次のクライアント要求を拒否し、暗号NAKパケットを返します。暗号NAKは何のMACを持っていないので、クライアントにとっての問題は、それが正当か、侵入者のいたずらの結果であるかどうかを判断することです。このような場合の脆弱性を軽減するために、暗号NAKだけでなく、すべての応答は、と考えられている場合にのみNTP上のワイヤプロトコルによって確認されたように、クライアントとないリプレイによって送信された前のパケットの結果。この防衛は簡単なman-in-the-middleによって回避することができますが、それは侵入者戦の他の種類を偏向ありません。"
    },
    {
      "indent": 3,
      "text": "There are a number of situations where some event happens that causes the remaining autokeys on the key list to become invalid. When one of these situations happens, the key list and associated autokeys in the key cache are purged. A new key list, signature, and timestamp are generated when the next NTP message is sent, assuming there is one. The following is a list of these situations:",
      "ja": "いくつかのイベントがキーリストの残りのオートキーが無効になる原因となることが起こる状況がいくつかあります。次のいずれかの状況が発生した場合、キーキャッシュ内の鍵リストと関連するオートキーが削除されます。次NTPメッセージが送信されるときに、新しい鍵リスト、署名、タイムスタンプは1つが存在すると仮定して、生成されます。以下は、これらの状況の一覧です。"
    },
    {
      "indent": 3,
      "text": "1. When the cookie value changes for any reason.",
      "section_title": true,
      "ja": "何らかの理由1.ときにクッキー値が変化します。"
    },
    {
      "indent": 3,
      "text": "2. When the poll interval is changed. In this case, the calculated expiration times for the keys become invalid.",
      "ja": "2.ポーリング間隔が変更された場合。この場合、キーの計算された有効期限は無効になります。"
    },
    {
      "indent": 3,
      "text": "3. If a problem is detected when an entry is fetched from the key list. This could happen if the key was marked non-trusted or timed out, either of which implies a software bug.",
      "ja": "エントリーは、キーリストからフェッチするときに問題が検出された場合3.。キーは非信頼できるマークやソフトウェアのバグを意味いずれかが、タイムアウトした場合に発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "12. Security Considerations",
      "section_title": true,
      "ja": "12.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section discusses the most obvious security vulnerabilities in the various Autokey dances. In the following discussion, the cryptographic algorithms and private values themselves are assumed secure; that is, a brute force cryptanalytic attack will not reveal the host private key, sign private key, cookie value, identity parameters, server seed or autokey seed. In addition, an intruder will not be able to predict random generator values.",
      "ja": "このセクションでは、さまざまな自動キー踊りの中で最も明白なセキュリティ脆弱性について説明します。以下の議論では、暗号化アルゴリズムと民間の値自体は安全な仮定されています。つまり、ブルートフォース暗号解読攻撃は、ホスト秘密鍵を明らかにした秘密鍵、クッキー値、アイデンティティパラメータは、サーバの種子やオートキーシードに署名しません。また、侵入者は、乱数発生器の値を予測することはできません。"
    },
    {
      "indent": 0,
      "text": "12.1. Protocol Vulnerability",
      "section_title": true,
      "ja": "12.1. プロトコルの脆弱性"
    },
    {
      "indent": 3,
      "text": "While the protocol has not been subjected to a formal analysis, a few preliminary assertions can be made. In the client/server and symmetric dances, the underlying NTP on-wire protocol is resistant to lost, duplicate, and bogus packets, even if the clock is not synchronized, so the protocol is not vulnerable to a wiretapper attack. The on-wire protocol is resistant to replays of both the client request packet and the server reply packet. A man-in-the-middle attack, even if it could simulate a valid cookie, could not prove identity.",
      "ja": "プロトコルは、正式な分析に供されていないが、いくつかの予備的なアサーションを行うことができます。クライアント/サーバーおよび対称踊りでは、基礎となるNTP上のワイヤプロトコルは、プロトコルが盗聴攻撃に対して脆弱ではありませんので、クロックは、同期していない場合であっても、複製、失われた、と偽のパケットに耐性があります。オンワイヤプロトコルは、クライアント要求パケットとサーバ応答パケットの両方のリプレイに対して耐性です。 man-in-the-middle攻撃は、それが有効なクッキーをシミュレートすることができた場合でも、身元を証明することができませんでした。"
    },
    {
      "indent": 3,
      "text": "In the broadcast dance, the client begins with a volley in client/ server mode to obtain the autokey values and signature, so has the same protection as in that mode. When continuing in receive-only mode, a wiretapper cannot produce a key list with valid signed autokey values. If it replays an old packet, the client will reject it by the timestamp check. The most it can do is manufacture a future packet causing clients to repeat the autokey hash operations until exceeding the maximum key number. If this happens the broadcast client temporarily reverts to client mode to refresh the autokey values.",
      "ja": "ブロードキャスト・ダンスでは、クライアントはので、モードと同じ保護を持っている、自動キー値と署名を取得するために、クライアント/サーバー・モードでのボレーで始まります。受信専用モードを継続する場合、盗聴者は、有効な署名自動キー値とキーのリストを生成することはできません。それは昔のパケットを再生した場合、クライアントは、タイムスタンプのチェックで、それを拒否します。それは行うことができますほとんどが最大のキー数を超えるまで、自動キーのハッシュ演算を繰り返すようにクライアントを引き起こし、将来のパケットを製造しています。これはブロードキャストクライアントを発生した場合、一時的に自動キー値を更新するには、クライアントモードに戻ります。"
    },
    {
      "indent": 3,
      "text": "By assumption, a man-in-the-middle attacker that intercepts a packet cannot break the wire or delay an intercepted packet. If this assumption is removed, the middleman could intercept a broadcast packet and replace the data and message digest without detection by the clients.",
      "ja": "仮定することにより、パケットを傍受してman-in-the-middle攻撃者は、ワイヤを破るまたは傍受パケットを遅らせることはできません。この仮定が削除された場合、仲介は、ブロードキャストパケットを傍受し、データを交換し、メッセージがクライアントによって検出されることなく消化できました。"
    },
    {
      "indent": 3,
      "text": "As mentioned previously in this memo, the TC identity scheme is vulnerable to a man-in-the-middle attack where an intruder could create a bogus certificate trail. To foil this kind of attack, either the PC, IFF, GQ, or MV identity schemes must be used.",
      "ja": "このメモで前述したように、TCのアイデンティティスキームは、侵入者が偽の証明書証跡を作成することができman-in-the-middle攻撃に対して脆弱です。この種の攻撃、どちらかのPCを箔に、IFF、GQ、またはMVのアイデンティティスキームを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "A client instantiates cryptographic variables only if the server is synchronized to a proventic source. A server does not sign values or generate cryptographic data files unless synchronized to a proventic source. This raises an interesting issue: how does a client generate proventic cryptographic files before it has ever been synchronized to a proventic source? (Who shaves the barber if the barber shaves everybody in town who does not shave himself?) In principle, this paradox is resolved by assuming the primary (stratum 1) servers are proventicated by external phenomenological means.",
      "ja": "クライアントは、サーバがproventicソースに同期されている場合にのみ、暗号化変数をインスタンス化します。 proventic源に同期していない限り、サーバーは値を署名または暗号化データファイルを生成しません。これは興味深い問題を提起：それは今までproventicソースに同期される前にどのようにクライアントがproventic暗号化ファイルを生成しますか？原則として（理髪師は彼自身を剃るていない町で皆を剃る場合は？床屋を剃る人）、このパラドックスは、プライマリ（階層1）サーバが外部の現象論的な手段によってproventicatedされていると仮定することによって解決されます。"
    },
    {
      "indent": 0,
      "text": "12.2. Clogging Vulnerability",
      "section_title": true,
      "ja": "12.2. 目詰まりの脆弱性"
    },
    {
      "indent": 3,
      "text": "A self-induced clogging incident cannot happen, since signatures are computed only when the data have changed and the data do not change very often. For instance, the autokey values are signed only when the key list is regenerated, which happens about once an hour, while the public values are signed only when one of them is updated during a dance or the server seed is refreshed, which happens about once per day.",
      "ja": "署名は、データが変更されているときにのみ計算され、データが頻繁に変更されませんので、自己誘導詰まり事件は、発生することはできません。例えば、自動キー値は、公開値が一回程度起こるおり、そのうちの一つは、ダンス中に更新されたか、サーバーの種子が更新されたときにのみ署名されている間、キーリストは、およそ1時間に1回たまたま、再生されたときにのみ署名されています一日あたり。"
    },
    {
      "indent": 3,
      "text": "There are two clogging vulnerabilities exposed in the protocol design: an encryption attack where the intruder hopes to clog the victim server with needless cryptographic calculations, and a decryption attack where the intruder attempts to clog the victim client with needless cryptographic calculations. Autokey uses public key cryptography and the algorithms that perform these functions consume significant resources.",
      "ja": "侵入者が不必要な暗号計算と被害者のサーバーを詰まらせたいと考えている暗号化攻撃、侵入者が不必要な暗号計算と被害者のクライアントを詰まらしようと解読攻撃：プロトコル設計に晒さ2件の詰まりの脆弱性があります。自動キーは、公開鍵暗号を使用し、これらの機能を実行するアルゴリズムはかなりのリソースを消費します。"
    },
    {
      "indent": 3,
      "text": "In client/server and peer dances, an encryption hazard exists when a wiretapper replays prior cookie request messages at speed. There is no obvious way to deflect such attacks, as the server retains no state between requests. Replays of cookie request or response messages are detected and discarded by the client on-wire protocol.",
      "ja": "盗聴者がスピードで前にクッキーの要求メッセージを再生するとき、クライアント/サーバーとピア・ダンスでは、暗号化の危険性が存在します。サーバーが要求間の状態を保持しないよう、このような攻撃をそらすために明白な方法はありません。クッキーの要求または応答メッセージのリプレイは、クライアント上のワイヤプロトコルによって検出され、廃棄されています。"
    },
    {
      "indent": 3,
      "text": "In broadcast mode, a decryption hazard exists when a wiretapper replays autokey response messages at speed. Once synchronized to a proventic source, a legitimate extension field with timestamp the same as or earlier than the most recently received of that type is immediately discarded. This foils a man-in-the-middle cut-and-paste attack using an earlier response, for example. A legitimate extension field with timestamp in the future is unlikely, as that would require predicting the autokey sequence. However, this causes the client to refresh and verify the autokey values and signature.",
      "ja": "盗聴者が高速で自動キーの応答メッセージを再生するとき、ブロードキャストモードでは、復号化の危険性が存在します。 proventicソース、同じか、最近、すぐに破棄され、そのタイプの受信より前のタイムスタンプを持つ正当な拡張フィールドに同期したら。これは、例えば、以前の応答を使用してman-in-the-middleカットアンドペースト攻撃を、箔。それは自動キーシーケンスを予測する必要になるとして、将来的にタイムスタンプを持つ正当な拡張フィールドは、ほとんどありません。しかし、これが更新され、自動キー値と署名を確認するために、クライアントの原因となります。"
    },
    {
      "indent": 3,
      "text": "A determined attacker can destabilize the on-wire protocol or an Autokey dance in various ways by replaying old messages before the client or peer has synchronized for the first time. For instance, replaying an old symmetric mode message before the peers have synchronize will prevent the peers from ever synchronizing. Replaying out of order Autokey messages in any mode during a dance could prevent the dance from ever completing. There is nothing new in these kinds of attack; a similar vulnerability even exists in TCP.",
      "ja": "決定した攻撃者は、クライアントまたはピアが最初に同期される前に、古いメッセージを再生することによって上のワイヤプロトコルまたは様々な方法でのAutokeyダンスを不安定にすることができます。たとえば、ピアが同期される前に、古い対称モードメッセージを再生することは、これまでの同期からピアを防ぐことができます。ダンスの中のいずれかのモードでの順序のAutokeyメッセージのうち、再生することは今までに完了することからダンスを防ぐことができます。攻撃のこれらの種類の新しいものは何もありません。同様の脆弱性も、TCPに存在します。"
    },
    {
      "indent": 0,
      "text": "13. IANA Consideration",
      "section_title": true,
      "ja": "13. IANAの検討"
    },
    {
      "indent": 3,
      "text": "The IANA has added the following entries to the NTP Extensions Field Types registry:",
      "ja": "IANAは、NTPの拡張フィールドタイプレジストリに次のエントリを追加しました："
    },
    {
      "indent": 6,
      "text": "+------------+------------------------------------------+\n| Field Type | Meaning                                  |\n+------------+------------------------------------------+\n|   0x0002   | No-Operation Request                     |\n|   0x8002   | No-Operation Response                    |\n|   0xC002   | No-Operation Error Response              |\n|   0x0102   | Association Message Request              |\n|   0x8102   | Association Message Response             |\n|   0xC102   | Association Message Error Response       |\n|   0x0202   | Certificate Message Request              |\n|   0x8202   | Certificate Message Response             |\n|   0xC202   | Certificate Message Error Response       |\n|   0x0302   | Cookie Message Request                   |\n|   0x8302   | Cookie Message Response                  |\n|   0xC302   | Cookie Message Error Response            |\n|   0x0402   | Autokey Message Request                  |\n|   0x8402   | Autokey Message Response                 |\n|   0xC402   | Autokey Message Error Response           |\n|   0x0502   | Leapseconds Value Message Request        |\n|   0x8502   | Leapseconds Value Message Response       |\n|   0xC502   | Leapseconds Value Message Error Response |\n|   0x0602   | Sign Message Request                     |\n|   0x8602   | Sign Message Response                    |\n|   0xC602   | Sign Message Error Response              |\n|   0x0702   | IFF Identity Message Request             |\n|   0x8702   | IFF Identity Message Response            |\n|   0xC702   | IFF Identity Message Error Response      |\n|   0x0802   | GQ Identity Message Request              |\n|   0x8802   | GQ Identity Message Response             |\n|   0xC802   | GQ Identity Message Error Response       |\n|   0x0902   | MV Identity Message Request              |\n|   0x8902   | MV Identity Message Response             |\n|   0xC902   | MV Identity Message Error Response       |\n+------------+------------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "14. References",
      "section_title": true,
      "ja": "14.参考文献"
    },
    {
      "indent": 0,
      "text": "14.1. Normative References",
      "section_title": true,
      "ja": "14.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC5905] Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, \"Network Time Protocol Version 4: Protocol and Algorithms Specification\", RFC 5905, June 2010.",
      "ja": "[RFC5905]ミルズ、D.、マーティン、J.、エド、バーバンク、J.、およびW. Kasch、 \"ネットワークタイムプロトコルバージョン4：プロトコルとアルゴリズムの仕様\"、RFC 5905、2010年6月。"
    },
    {
      "indent": 0,
      "text": "14.2. Informative References",
      "section_title": true,
      "ja": "14.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[DASBUCH] Mills, D., \"Computer Network Time Synchronization - the Network Time Protocol\", 2006.",
      "ja": "[DASBUCH]ミルズ、D.、 \"コンピュータネットワーク時刻同期 - ネットワークタイムプロトコル\"、2006年。"
    },
    {
      "indent": 3,
      "text": "[GUILLOU] Guillou, L. and J. Quisquatar, \"A \"paradoxical\" identity-based signature scheme resulting from zero-knowledge\", 1990.",
      "ja": "【GUILLOU] Guillou、L.及びJ. Quisquatar、1990年「『逆説』ゼロ知識から得られたアイデンティティに基づく署名方式」。"
    },
    {
      "indent": 3,
      "text": "[MV] Mu, Y. and V. Varadharajan, \"Robust and secure broadcasting\", 2001.",
      "ja": "[移動]の前に、それが理由です。そして、運動をたくさん。 Varadharajam、 \"堅牢かつ安全な放送\"、2001年。"
    },
    {
      "indent": 3,
      "text": "[RFC1305] Mills, D., \"Network Time Protocol (Version 3) Specification, Implementation\", RFC 1305, March 1992.",
      "ja": "[RFC1305]ミルズ、D.、 \"ネットワーク時間プロトコル（バージョン3）仕様、実装\"、RFC 1305、1992年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2412] Orman, H., \"The OAKLEY Key Determination Protocol\", RFC 2412, November 1998.",
      "ja": "[RFC2412]オーマン、H.、 \"OAKLEYキー決意プロトコル\"、RFC 2412、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2522] Karn, P. and W. Simpson, \"Photuris: Session-Key Management Protocol\", RFC 2522, March 1999.",
      "ja": "[RFC2522]カーン、P.とW.シンプソン、 \"Photuris：セッション鍵管理プロトコル\"、RFC 2522、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2875] Prafullchandra, H. and J. Schaad, \"Diffie-Hellman Proof-of-Possession Algorithms\", RFC 2875, July 2000.",
      "ja": "[RFC2875] Prafullchandra氏、H.及びJ. Schaad、 \"ディフィー - ヘルマンプルーフ・オブ・所有アルゴリズム\"、RFC 2875、2000年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3279] Bassham, L., Polk, W., and R. Housley, \"Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 3279, April 2002.",
      "ja": "[RFC3279] Bassham、L.、ポーク、W.、およびR. Housley氏、RFC 3279、2002年4月 \"インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）プロフィールのためのアルゴリズムと識別子\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4210] Adams, C., Farrell, S., Kause, T., and T. Mononen, \"Internet X.509 Public Key Infrastructure Certificate Management Protocol (CMP)\", RFC 4210, September 2005.",
      "ja": "[RFC4210]アダムス、C.、ファレル、S.、Kause、T.、およびT. Mononen、 \"インターネットX.509公開鍵基盤証明書管理プロトコル（CMP）\"、RFC 4210、2005年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4302] Kent, S., \"IP Authentication Header\", RFC 4302, December 2005.",
      "ja": "[RFC4302]ケント、S.、 \"IP認証ヘッダー\"、RFC 4302、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "ja": "[RFC4303]ケント、S.、 \"IPカプセル化セキュリティペイロード（ESP）\"、RFC 4303、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4306] Kaufman, C., \"Internet Key Exchange (IKEv2) Protocol\", RFC 4306, December 2005.",
      "ja": "[RFC4306]カウフマン、C.、 \"インターネットキーエクスチェンジ（IKEv2の）プロトコル\"、RFC 4306、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[SCHNORR] Schnorr, C., \"Efficient signature generation for smart cards\", 1991.",
      "ja": "【シュノール]シュノール、C.、「スマートカードのための効率的な署名生成」、1991。"
    },
    {
      "indent": 3,
      "text": "[STINSON] Stinson, D., \"Cryptography - Theory and Practice\", 1995.",
      "ja": "[スティンソン]スティンソン、D.、 \"暗号化 - 理論と実践\"、1995年。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Timestamps, Filestamps, and Partial Ordering",
      "ja": "付録A.タイムスタンプ、Filestamps、および半順序"
    },
    {
      "indent": 3,
      "text": "When the host starts, it reads the host key and host certificate files, which are required for continued operation. It also reads the sign key and leapseconds values, when available. When reading these files, the host checks the file formats and filestamps for validity; for instance, all filestamps must be later than the time the UTC timescale was established in 1972 and the certificate filestamp must not be earlier than its associated sign key filestamp. At the time the files are read, the host is not synchronized, so it cannot determine whether the filestamps are bogus other than by using these simple checks. It must not produce filestamps or timestamps until synchronized to a proventic source.",
      "ja": "ホストが起動すると、それは継続的な動作に必要なホストキーとホスト証明書ファイルを、読み込みます。利用可能な場合、それはまた、記号キーとleapseconds値を読み取ります。これらのファイルを読み込む場合、ホストは、有効性のためのファイル形式とfilestampsをチェックします。例えば、すべてのfilestampsは後でUTCタイムスケールは、1972年に設立され、証明書のfilestampは、それに関連する記号キーfilestampよりも前でなければなりません以下でなければなりません。それはfilestampsは、これらの簡単なチェックを使用して以外の偽であるかどうかを判断することはできませんので、ファイルが読み込まれる時には、ホストは、同期されません。 proventicソースに同期するまで、それはfilestampsやタイムスタンプを生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "In the following, the relation A --> B is Lamport's \"happens before\" relation, which is true if event A happens before event B. When timestamps are compared to timestamps, the relation is false if A <--> B; that is, false if the events are simultaneous. For timestamps compared to filestamps and filestamps compared to filestamps, the relation is true if A <--> B. Note that the current time plays no part in these assertions except in (6) below; however, the NTP protocol itself ensures a correct partial ordering for all current time values.",
      "ja": "以下では、関係A  - > Bはランポートのあるタイムスタンプは、タイムスタンプと比較される場合、イベントAは、イベントBの前に発生した場合も同様である関係、「前に発生」、関係が偽である場合、A < - > B。イベントが同時である場合には、falseです。 < - >場合filestampsに比べfilestampsとfilestampsに比べタイムスタンプのために、関係が真である現在の時刻（6）以下を除いて、これらの主張には役割を果たしていないことB.注;しかし、NTPプロトコル自体は、現在のすべての時間値の正しい部分的順序を保証します。"
    },
    {
      "indent": 3,
      "text": "The following assertions apply to all relevant responses:",
      "ja": "以下のアサーションは、関連するすべての応答に適用されます。"
    },
    {
      "indent": 3,
      "text": "1. The client saves the most recent timestamp T0 and filestamp F0 for the respective signature type. For every received message carrying timestamp T1 and filestamp F1, the message is discarded unless T0 --> T1 and F0 --> F1. The requirement that T0 --> T1 is the primary defense against replays of old messages.",
      "ja": "1.クライアントは、それぞれの署名タイプの最新のタイムスタンプT0とfilestamp F0が保存されます。タイムスタンプT1及びfilestamp F1を搬送するすべての受信されたメッセージの場合、メッセージは破棄されない限り、T0  - > T1及びF0  - > F1。要件T0  - > T1は、古いメッセージのリプレイに対する一次防衛です。"
    },
    {
      "indent": 3,
      "text": "2. For timestamp T and filestamp F, F --> T; that is, the filestamp must happen before the timestamp. If not, this could be due to a file generation error or a significant error in the system clock time.",
      "ja": "タイムスタンプTとfilestamp F、F 2.  - > T。つまり、filestampは、タイムスタンプの前に行われる必要があります。そうでない場合、これはシステム・クロックの時間にファイル生成エラーまたは重大なエラーが原因である可能性があります。"
    },
    {
      "indent": 3,
      "text": "3. For sign key filestamp S, certificate filestamp C, cookie timestamp D and autokey timestamp A, S --> C --> D --> A; that is, the autokey must be generated after the cookie, the cookie after the certificate, and the certificate after the sign key.",
      "ja": "> C  -   - > D  - 記号キーfilestamp S、証明書filestamp C、クッキータイムスタンプD及びオートキータイムスタンプA、S 3.> A。つまり、自動キーは、クッキーの後に証明書の後に、クッキー、および記号キーの後に証明書を生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "4. For sign key filestamp S and certificate filestamp C specifying begin time B and end time E, S --> C--> B --> E; that is, the valid period must not be retroactive.",
      "ja": "> C  -   - > B  - 記号キーfilestamp S及びE、S、時刻Bと終了時刻を開始する特定の証明書filestampのC 4.> E。つまり、有効期間は遡及してはなりません。"
    },
    {
      "indent": 3,
      "text": "5. A certificate for subject S signed by issuer I and with filestamp C1 obsoletes, but does not necessarily invalidate, another certificate with the same subject and issuer but with filestamp C0, where C0 --> C1.",
      "ja": "被験者5.証明書が発行者によって署名されたS Iとfilestamp C1は時代遅れ、必ずしも無効にしないと、同じ被写体と発行者とが、filestamp C0、C0と別の証明書 - > C1。"
    },
    {
      "indent": 3,
      "text": "6. A certificate with begin time B and end time E is invalid and cannot be used to verify signatures if t --> B or E --> t, where t is the current proventic time. Note that the public key previously extracted from the certificate continues to be valid for an indefinite time. This raises the interesting possibility where a truechimer server with expired certificate or a falseticker with valid certificate are not detected until the client has synchronized to a proventic source.",
      "ja": "6時間Bと終了時刻Eを開始すると証明書が無効であると署名を検証するために使用することができない場合、T  - > BまたはE  - > T、tは現在proventic時間です。以前に証明書から抽出された公開鍵が無期限に有効であり続けることに注意してください。これは、クライアントがproventicソースに同期するまで、期限切れの証明書または有効な証明書を持つfalsetickerとtruechimerサーバーが検出されていない興味深い可能性を提起します。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Identity Schemes",
      "ja": "付録B.アイデンティティスキーム"
    },
    {
      "indent": 3,
      "text": "There are five identity schemes in the NTPv4 reference implementation: (1) private certificate (PC), (2) trusted certificate (TC), (3) a modified Schnorr algorithm (IFF - Identify Friend or Foe), (4) a modified Guillou-Quisquater (GQ) algorithm, and (5) a modified Mu-Varadharajan (MV) algorithm.",
      "ja": "（4）変更、 - （1）プライベート証明書（PC）、（2）信頼できる証明書（TC）、（3）修正シュアルゴリズム（敵味方識別IFF）：NTPv4のリファレンス実装で5つのアイデンティティスキームがあります。 Guillou-Quisquaterの（GQ）アルゴリズム、及び（5）変性ミューVaradharajan（MV）アルゴリズム。"
    },
    {
      "indent": 3,
      "text": "The PC scheme is intended for testing and development and not recommended for general use. The TC scheme uses a certificate trail, but not an identity scheme. The IFF, GQ, and MV identity schemes use a cryptographically strong challenge-response exchange where an intruder cannot learn the group key, even after repeated observations of multiple exchanges. These schemes begin when the client sends a nonce to the server, which then rolls its own nonce, performs a mathematical operation and sends the results to the client. The client performs a second mathematical operation to prove the server has the same group key as the client.",
      "ja": "PC方式は、テストと開発のためのものと一般的な使用にはお勧めしません。 TC方式は、証明書の道ではなく、アイデンティティ・スキームを使用しています。 IFF、GQ、およびMVのアイデンティティスキームは、侵入者でも、複数の取引所の繰り返し観測した後、グループキーを学ぶことができない暗号的に強いチャレンジ・レスポンス交換を使用しています。これらのスキームは、クライアントは、それ自身のnonceをロールサーバーにnonceを送信数学演算を実行し、その結果をクライアントに送信するときに開始します。クライアントは、サーバがクライアントと同じグループ鍵を持っていることを証明するために第2の数学的な操作を行います。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Private Certificate (PC) Scheme",
      "ja": "付録C.プライベート証明書（PC）スキーム"
    },
    {
      "indent": 3,
      "text": "The PC scheme shown in Figure 12 uses a private certificate as the group key.",
      "ja": "図12に示すPC方式は、グループ鍵としてプライベート証明書を使用しています。"
    },
    {
      "indent": 3,
      "text": "                          Trusted\n                         Authority\n           Secure     +-------------+    Secure\n       +--------------| Certificate |-------------+\n       |              +-------------+             |\n       |                                          |\n      \\|/                                        \\|/\n+-------------+                            +-------------+\n| Certificate |                            | Certificate |\n+-------------+                            +-------------+\n    Server                                     Client",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 12: Private Certificate (PC) Identity Scheme",
      "ja": "図12：プライベート証明書（PC）アイデンティティスキーム"
    },
    {
      "indent": 3,
      "text": "A certificate is designated private when the X.509v3 Extended Key Usage extension field is present and contains \"Private\". The private certificate is distributed to all other group members by secret means, so in fact becomes a symmetric key. Private certificates are also trusted, so there is no need for a certificate trail or identity scheme.",
      "ja": "X.509v3拡張キー使用法拡張フィールドが存在していると「プライベート」が含まれる場合、証明書は、民間指定されています。プライベート証明書は、秘密の手段によって他のすべてのグループのメンバーに配布するので、実際には対称鍵となっています。プライベート証明書も信頼されているので、証明書証跡またはIDスキームの必要はありません。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Trusted Certificate (TC) Scheme",
      "ja": "付録D.証明書（TC）スキームを信頼しました"
    },
    {
      "indent": 3,
      "text": "All other schemes involve a conventional certificate trail as shown\nin Figure 13.\n                                                        Trusted\n                Host                 Host                 Host\n           +-----------+        +-----------+        +-----------+\n      +--->|  Subject  |   +--->|  Subject  |   +--->|  Subject  |\n      |    +-----------+   |    +-----------+   |    +-----------+\n...---+    |  Issuer   |---+    |  Issuer   |---+    |  Issuer   |\n           +-----------+        +-----------+        +-----------+\n           | Signature |        | Signature |        | Signature |\n           +-----------+        +-----------+        +-----------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 13: Trusted Certificate (TC) Identity Scheme",
      "ja": "図13：信頼できる証明書（TC）アイデンティティスキーム"
    },
    {
      "indent": 3,
      "text": "As described in RFC 4210 [RFC4210], each certificate is signed by an issuer one step closer to the trusted host, which has a self-signed trusted certificate. A certificate is designated trusted when an X.509v3 Extended Key Usage extension field is present and contains \"trustRoot\". If no identity scheme is specified in the parameter exchange, this is the default scheme.",
      "ja": "RFC 4210 [RFC4210]に記載されているように、各証明書が一歩近づく自己署名の信頼された証明書を有するトラステッド・ホストに発行者によって署名されています。 X.509v3拡張キー使用法拡張フィールドが存在し、「trustRoot」が含まれていたときに証明書が信頼された指定されています。何のアイデンティティスキームはパラメータ交換で指定されていない場合、これがデフォルトのスキームです。"
    },
    {
      "indent": 0,
      "text": "Appendix E. Schnorr (IFF) Identity Scheme",
      "ja": "付録E.シュ（IFF）アイデンティティスキーム"
    },
    {
      "indent": 3,
      "text": "The IFF scheme is useful when the group key is concealed, so that client keys need not be protected. The primary disadvantage is that when the server key is refreshed all hosts must update the client key. The scheme shown in Figure 14 involves a set of public parameters and a group key including both private and public components. The public component is the client key.",
      "ja": "グループ鍵が隠されているときにクライアントキーを保護する必要はないようにIFF方式は、便利です。主な欠点は、サーバキーが更新されたとき、すべてのホストがクライアントキーを更新しなければならないということです。図14に示されているスキームは、公開パラメータとの両方プライベートおよびパブリックコンポーネントを含むグループ鍵のセットを含みます。公共のコンポーネントは、クライアントの鍵です。"
    },
    {
      "indent": 14,
      "text": "                       Trusted\n                      Authority\n                    +------------+\n                    | Parameters |\n         Secure     +------------+   Insecure\n      +-------------| Group Key  |-----------+\n      |             +------------+           |\n     \\|/                                    \\|/\n+------------+         Challenge       +------------+\n| Parameters |<------------------------| Parameters |\n+------------+                         +------------+\n|  Group Key |------------------------>| Client Key |\n+------------+         Response        +------------+\n    Server                                 Client",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 14: Schnorr (IFF) Identity Scheme",
      "ja": "図14：シュ（IFF）アイデンティティスキーム"
    },
    {
      "indent": 3,
      "text": "By happy coincidence, the mathematical principles on which IFF is based are similar to DSA. The scheme is a modification an algorithm described in [SCHNORR] and [STINSON] (p. 285). The parameters are generated by routines in the OpenSSL library, but only the moduli p, q and generator g are used. The p is a 512-bit prime, g a generator of the multiplicative group Z_p* and q a 160-bit prime that divides (p-1) and is a qth root of 1 mod p; that is, g^q = 1 mod p. The TA rolls a private random group key b (0 < b < q), then computes public client key v = g^(q-b) mod p. The TA distributes (p, q, g, b) to all servers using secure means and (p, q, g, v) to all clients not necessarily using secure means.",
      "ja": "幸せな偶然の一致では、IFFの基礎となる数学的な原則は、DSAに類似しています。スキームは[シュノール]と[スティンソン]（p。285）に記載のアルゴリズムの変形です。パラメータは、OpenSSLライブラリ内のルーチンによって生成され、だけモジュラスP、Q及びジェネレータGが使用されています。 pは512ビットの素数、G乗法群Z_p *のジェネレータとQ（P-1）分割する160ビットの素数であり、1つのMOD Pのq番​​目のルートです。すなわち、G ^ Q = 1つのMOD Pです。 TAプライベートランダムグループ鍵B（0 <B <q）をロールは、パブリッククライアント鍵V = G ^（Q-B）MOD pが計算します。安全な手段と使用しているすべてのサーバへのTAが配信（P、Q、G、B）（P、Q、G、v）はすべてのクライアントに必ずしも安全な手段を使用していません。"
    },
    {
      "indent": 3,
      "text": "The TA hides IFF parameters and keys in an OpenSSL DSA cuckoo structure. The IFF parameters are identical to the DSA parameters, so the OpenSSL library can be used directly. The structure shown in Figure 15 is written to a file as a DSA private key encoded in PEM. Unused structure members are set to one.",
      "ja": "TAは、OpenSSL DSAカッコウ構造にIFFパラメータとキーを隠します。 OpenSSLライブラリを直接使用することができるので、IFFパラメータは、DSAパラメータと同じです。図15に示す構造は、PEMで符号化されたDSAプライベートキーとしてファイルに書き込まれます。未使用の構造体のメンバは1に設定されています。"
    },
    {
      "indent": 14,
      "text": "+----------------------------------+-------------+\n|   IFF   |   DSA    |   Item      |   Include   |\n+=========+==========+=============+=============+\n|    p    |    p     | modulus     |    all      |\n+---------+----------+-------------+-------------+\n|    q    |    q     | modulus     |    all      |\n+---------+----------+-------------+-------------+\n|    g    |    g     | generator   |    all      |\n+---------+----------+-------------+-------------+\n|    b    | priv_key | group key   |   server    |\n+---------+----------+-------------+-------------+\n|    v    | pub_key  | client key  |   client    |\n+---------+----------+-------------+-------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 15: IFF Identity Scheme Structure",
      "ja": "図15：IFFアイデンティティスキームの構造"
    },
    {
      "indent": 3,
      "text": "Alice challenges Bob to confirm identity using the following protocol exchange.",
      "ja": "アリスは、以下のプロトコル交換を使用して身元を確認するために、ボブに挑戦します。"
    },
    {
      "indent": 3,
      "text": "1. Alice rolls random r (0 < r < q) and sends to Bob.",
      "section_title": true,
      "ja": "1.アリスはランダムR（0 <R <Q）をロールとボブに送信します。"
    },
    {
      "indent": 3,
      "text": "2. Bob rolls random k (0 < k < q), computes y = k + br mod q and x = g^k mod p, then sends (y, hash(x)) to Alice.",
      "ja": "2.ボブはランダムK（0 <K <Q）をロール、Y = K + BRのmod q及びX = G ^ K MOD Pを計算し、次に送信する（Y、ハッシュ（x））をアリスへ。"
    },
    {
      "indent": 3,
      "text": "3. Alice computes z = g^y * v^r mod p and verifies hash(z) equals hash(x).",
      "ja": "3.アリスは、z = G ^のY *のV ^はMOD P rを計算し、ハッシュ（z）を検証ハッシュに等しい（X）。"
    },
    {
      "indent": 3,
      "text": "If the hashes match, Alice knows that Bob has the group key b. Besides making the response shorter, the hash makes it effectively impossible for an intruder to solve for b by observing a number of these messages. The signed response binds this knowledge to Bob's private key and the public key previously received in his certificate.",
      "ja": "ハッシュが一致した場合、アリスはボブがグループ鍵Bを持っていることを知っています。応答は短くするほか、ハッシュは、これらのメッセージの数を観察することによって、Bのために解決するために、侵入者のためにそれが効果的にできなくなります。署名した応答は、ボブの秘密鍵と以前に彼の証明書で受信した公開鍵にこの知識をバインドします。"
    },
    {
      "indent": 0,
      "text": "Appendix F. Guillard-Quisquater (GQ) Identity Scheme",
      "ja": "付録F.ギラード-Quisquaterの（GQ）アイデンティティスキーム"
    },
    {
      "indent": 3,
      "text": "The GQ scheme is useful when the server key must be refreshed from time to time without changing the group key. The NTP utility programs include the GQ client key in the X.509v3 Subject Key Identifier extension field. The primary disadvantage of the scheme is that the group key must be protected in both the server and client. A secondary disadvantage is that when a server key is refreshed, old extension fields no longer work. The scheme shown in Figure 16 involves a set of public parameters and a group key used to generate private server keys and client keys.",
      "ja": "サーバーキーがグループキーを変更することなく、随時リフレッシュしなければならないときGQスキームが便利です。 NTPのユーティリティプログラムは、X.509v3にサブジェクトキー識別子拡張フィールドでGQクライアントキーが含まれます。スキームの主な欠点は、グループ鍵はサーバーとクライアントの両方で保護されなければならないということです。セカンダリ欠点は、サーバキーが更新されたとき、古い拡張フィールドが動作しなくなるということです。図16に示すスキームは、公開パラメータとプライベートサーバ鍵とクライアントの鍵を生成するために使用されるグループキーのセットを必要とします。"
    },
    {
      "indent": 14,
      "text": "                       Trusted\n                      Authority\n                    +------------+\n                    | Parameters |\n         Secure     +------------+   Secure\n      +-------------| Group Key  |-----------+\n      |             +------------+           |\n     \\|/                                    \\|/\n+------------+         Challenge       +------------+\n| Parameters |<------------------------| Parameters |\n+------------+                         +------------+\n|  Group Key |                         |  Group Key |\n+------------+         Response        +------------+\n| Server Key |------------------------>| Client Key |\n+------------+                         +------------+\n    Server                                 Client",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 16: Schnorr (IFF) Identity Scheme",
      "ja": "図16：シュ（IFF）アイデンティティスキーム"
    },
    {
      "indent": 3,
      "text": "By happy coincidence, the mathematical principles on which GQ is based are similar to RSA. The scheme is a modification of an algorithm described in [GUILLOU] and [STINSON] (p. 300) (with errors). The parameters are generated by routines in the OpenSSL library, but only the moduli p and q are used. The 512-bit public modulus is n=pq, where p and q are secret large primes. The TA rolls random large prime b (0 < b < n) and distributes (n, b) to all group servers and clients using secure means, since an intruder in possession of these values could impersonate a legitimate server. The private server key and public client key are constructed later.",
      "ja": "幸せな偶然の一致では、GQの基礎となる数学的な原則は、RSAに似ています。スキームは[GUILLOU]と[スティンソン]（p。300）（エラーが発生した）に記載されたアルゴリズムの変形です。パラメータは、OpenSSLライブラリのルーチンによって生成されているが、唯一の弾性係数pとqが使用されています。 512ビットの公開率は、n、pおよびqは、秘密の大きな素数である= PQ、です。これらの値の所有に侵入者が正当なサーバになりすます可能性があるので、TAは、安全な手段を使用して、すべてのグループのサーバとクライアントにランダム大きな素数B（0 <B <n）とが配信（N、B）をロール。プライベートサーバ鍵と公開クライアントキーは後に構築されています。"
    },
    {
      "indent": 3,
      "text": "The TA hides GQ parameters and keys in an OpenSSL RSA cuckoo structure. The GQ parameters are identical to the RSA parameters, so the OpenSSL library can be used directly. When generating a certificate, the server rolls random server key u (0 < u < n) and client key its inverse obscured by the group key v = (u^-1)^b mod n. These values replace the private and public keys normally generated by the RSA scheme. The client key is conveyed in a X.509 certificate extension. The updated GQ structure shown in Figure 17 is written as an RSA private key encoded in PEM. Unused structure members are set to one.",
      "ja": "TAは、OpenSSL RSAカッコウ構造でGQパラメータおよびキーを隠し。 OpenSSLライブラリを直接使用することができるので、GQパラメータは、RSAのパラメータと同じです。証明書を生成するとき、サーバは、グループ鍵v =によって隠さランダムサーバ鍵U（0 <U <N）およびクライアントキーその反転ロール（U ^ -1）^ B mod nを。これらの値は、通常、RSAスキームによって生成された秘密鍵と公開鍵を交換してください。クライアントキーは、X.509証明書拡張に搬送されます。図17に示す更新GQ構造はPEMでエンコードRSA秘密鍵として書き込まれます。未使用の構造体のメンバは1に設定されています。"
    },
    {
      "indent": 14,
      "text": "+---------------------------------+-------------+\n|   GQ    |   RSA    |   Item     |   Include   |\n+=========+==========+============+=============+\n|    n    |    n     | modulus    |    all      |\n+---------+----------+------------+-------------+\n|    b    |    e     | group key  |    all      |\n+---------+----------+------------+-------------+\n|    u    |    p     | server key |   server    |\n+---------+----------+------------+-------------+\n|    v    |    q     | client key |   client    |\n+---------+----------+------------+-------------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 17: GQ Identity Scheme Structure",
      "ja": "図17：GQアイデンティティスキームの構造"
    },
    {
      "indent": 3,
      "text": "Alice challenges Bob to confirm identity using the following exchange.",
      "ja": "アリスは、次の交換を使用して身元を確認するために、ボブに挑戦します。"
    },
    {
      "indent": 3,
      "text": "1. Alice rolls random r (0 < r < n) and sends to Bob.",
      "section_title": true,
      "ja": "1.アリスはランダムR（0 <R <N）ロールとボブに送信します。"
    },
    {
      "indent": 3,
      "text": "2. Bob rolls random k (0 < k < n) and computes y = ku^r mod n and x = k^b mod n, then sends (y, hash(x)) to Alice.",
      "ja": "2.ボブはランダムK（0 <K <N）のロールとyが区^はMOD Nであり、X = K ^ B mod nを計算し、R =計算し、アリスに（Y、ハッシュ（X））を送信します。"
    },
    {
      "indent": 3,
      "text": "3. Alice computes z = (v^r)*(y^b) mod n and verifies hash(z) equals hash(x).",
      "ja": "3.アリスは、z =（V ^ R）*（Y ^ B）mod nをを計算し、ハッシュ（z）を検証ハッシュに等しい（X）。"
    },
    {
      "indent": 3,
      "text": "If the hashes match, Alice knows that Bob has the corresponding server key u. Besides making the response shorter, the hash makes it effectively impossible for an intruder to solve for u by observing a number of these messages. The signed response binds this knowledge to Bob's private key and the client key previously received in his certificate.",
      "ja": "ハッシュが一致した場合、アリスはボブが、対応するサーバキーのuを持っていることを知っています。応答は短くするほか、ハッシュは、これらのメッセージの数を観察することによってuのために解決するために、侵入者のためにそれが効果的にできなくなります。署名した応答は、ボブの秘密鍵と以前に彼の証明書で受信したクライアントキーにこの知識をバインドします。"
    },
    {
      "indent": 0,
      "text": "Appendix G. Mu-Varadharajan (MV) Identity Scheme",
      "ja": "付録G.ミューVaradharajan（MV）アイデンティティスキーム"
    },
    {
      "indent": 3,
      "text": "The MV scheme is perhaps the most interesting and flexible of the three challenge/response schemes, but is devilishly complicated. It is most useful when a small number of servers provide synchronization to a large client population where there might be considerable risk of compromise between and among the servers and clients. The client population can be partitioned into a modest number of subgroups, each associated with an individual client key.",
      "ja": "MVスキームは、おそらく最も興味深いと3つのチャレンジ/レスポンススキームの柔軟性ですが、悪魔に複雑です。サーバの数が少ないサーバーとクライアント間との間の妥協のかなりのリスクがあるかもしれない大規模なクライアントの集団に同期を提供する際には最も有用です。クライアントの人口は、サブグループの控えめな数、個々のクライアントのキーに関連付けられている各に分割することができます。"
    },
    {
      "indent": 3,
      "text": "The TA generates an intricate cryptosystem involving encryption and decryption keys, together with a number of activation keys and associated client keys. The TA can activate and revoke individual client keys without changing the client keys themselves. The TA provides to the servers an encryption key E, and partial decryption keys g-bar and g-hat which depend on the activated keys. The servers have no additional information and, in particular, cannot masquerade as a TA. In addition, the TA provides to each client j individual partial decryption keys x-bar_j and x-hat_j, which do not need to be changed if the TA activates or deactivates any client key. The clients have no further information and, in particular, cannot masquerade as a server or TA.",
      "ja": "TAは、一緒にアクティベーションキーと関連するクライアント・キーの数と、暗号化および復号化鍵を伴う複雑な暗号を生成します。 TAは、アクティブにし、クライアントの鍵そのものを変更することなく、個々のクライアントキーを取り消すことができます。 TAは、サーバに活性化キーに依存して暗号化キーE、および部分復号鍵G-バーとg-帽子を提供します。サーバーは、追加の情報と、具体的には、TAになりすますことはできませんがありません。また、TAはTAが活性化するかまたは任意のクライアントキーを無効にした場合は変更する必要はありません。各クライアントjの個々の部分復号鍵のX-bar_jとx hat_jに提供します。クライアントは、具体的には、サーバやTAになりすますことができない、それ以上の情報を持っていないと。"
    },
    {
      "indent": 3,
      "text": "The scheme uses an encryption algorithm similar to El Gamal cryptography and a polynomial formed from the expansion of product terms (x-x_1)(x-x_2)(x-x_3)...(x-x_n), as described in [MV]. The paper has significant errors and serious omissions. The cryptosystem is constructed so that, for every encryption key E its inverse is (g-bar^x-hat_j)(g-hat^x-bar_j) mod p for every j. This remains true if both quantities are raised to the power k mod p. The difficulty in finding E is equivalent to the discrete log problem.",
      "ja": "[MVに記載されているようにスキームは、（X-x_nに関する）...エルガマル暗号と積項（X-X_1）の拡張（X-X_2）から形成された多項式（X-X_3）と同様の暗号化アルゴリズムを使用します]。紙は重大なエラーと重大な記載漏れがあります。ように暗号が構築され、すべての暗号化キーEのためにその逆は、すべてのjに対して（G-バー^ X-hat_j）（グラムハット^ X-bar_j）のmod pとします。両方の量は、電力のkモッズPに上げている場合、これは真のまま。 Eを見つけることの難しさは、離散対数問題と等価です。"
    },
    {
      "indent": 3,
      "text": "The scheme is shown in Figure 18. The TA generates the parameters, group key, server keys, and client keys, one for each client, all of which must be protected to prevent theft of service. Note that only the TA has the group key, which is not known to either the servers or clients. In this sense, the MV scheme is a zero-knowledge proof.",
      "ja": "図18. TAに示されているスキームは、パラメータ、サービスの盗難を防ぐために保護されなければならないすべては、グループキー、サーバキー、およびクライアントキー、各クライアントに対して1つを生成します。唯一のTAは、サーバーまたはクライアントのいずれかに知られていないグループキーを、持っていることに注意してください。この意味で、MV方式は、ゼロ知識証明です。"
    },
    {
      "indent": 14,
      "text": "                       Trusted\n                      Authority\n                    +------------+\n                    | Parameters |\n                    +------------+\n                    | Group Key  |\n                    +------------+\n                    | Server Key |\n         Secure     +------------+   Secure\n      +-------------| Client Key |-----------+\n      |             +------------+           |\n     \\|/                                    \\|/\n+------------+         Challenge       +------------+\n| Parameters |<------------------------| Parameters |\n+------------+                         +------------+\n| Server Key |------------------------>| Client Key |\n+------------+         Response        +------------+\n    Server                                 Client",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 18: Mu-Varadharajan (MV) Identity Scheme",
      "ja": "図18：R-varadharajam（MOVE）アイデンティティスキーム"
    },
    {
      "indent": 3,
      "text": "The TA hides MV parameters and keys in OpenSSL DSA cuckoo structures. The MV parameters are identical to the DSA parameters, so the OpenSSL library can be used directly. The structure shown in the figures below are written to files as a the fkey encoded in PEM. Unused structure members are set to one. The Figure 19 shows the data structure used by the servers, while Figure 20 shows the client data structure associated with each activation key.",
      "ja": "TAは、OpenSSL DSAカッコウ構造におけるMVパラメータとキーを隠します。 OpenSSLライブラリを直接使用することができるので、MVパラメータは、DSAパラメータと同じです。以下の図に示す構造は、PEMでエンコードFKEYとしてファイルに書き込まれます。未使用の構造体のメンバは1に設定されています。図20は、各アクティベーションキーに関連付けられたクライアント・データ構造を示している図19は、サーバによって使用されるデータ構造を示しています。"
    },
    {
      "indent": 14,
      "text": "+---------------------------------+-------------+\n|   MV    |   DSA    |   Item     |   Include   |\n+=========+==========+============+=============+\n|    p    |    p     | modulus    |    all      |\n+---------+----------+------------+-------------+\n|    q    |    q     | modulus    |   server    |\n+---------+----------+------------+-------------+\n|    E    |    g     | private    |   server    |\n|         |          | encrypt    |             |\n+---------+----------+------------+-------------+\n|  g-bar  | priv_key | public     |   server    |\n|         |          | decrypt    |             |\n+---------+----------+------------+-------------+\n|  g-hat  | pub_key  | public     |   server    |\n|         |          | decrypt    |             |\n+---------+----------+------------+-------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 19: MV Scheme Server Structure",
      "ja": "図19：MVスキームサーバーの構造"
    },
    {
      "indent": 14,
      "text": "+---------------------------------+-------------+\n|   MV    |   DSA    |   Item     |   Include   |\n+=========+==========+============+=============+\n|    p    |    p     | modulus    |    all      |\n+---------+----------+------------+-------------+\n| x-bar_j | priv_key | public     |   client    |\n|         |          | decrypt    |             |\n+---------+----------+------------+-------------+\n| x-hat_j | pub_key  | public     |   client    |\n|         |          | decrypt    |             |\n+---------+----------+------------+-------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 20: MV Scheme Client Structure",
      "ja": "図20：MVスキームクライアントの構造"
    },
    {
      "indent": 3,
      "text": "The devil is in the details, which are beyond the scope of this memo. The steps in generating the cryptosystem activating the keys and generating the partial decryption keys are in [DASBUCH] (page 170 ff).",
      "ja": "悪魔はこのメモの範囲を超えての詳細、です。キーを活性化する暗号を生成し、部分復号鍵を生成する際の手順は、[DASBUCH]（ページ170個のFF）です。"
    },
    {
      "indent": 3,
      "text": "Alice challenges Bob to confirm identity using the following exchange.",
      "ja": "アリスは、次の交換を使用して身元を確認するために、ボブに挑戦します。"
    },
    {
      "indent": 3,
      "text": "1. Alice rolls random r (0 < r < q) and sends to Bob.",
      "section_title": true,
      "ja": "1.アリスはランダムR（0 <R <Q）をロールとボブに送信します。"
    },
    {
      "indent": 3,
      "text": "2. Bob rolls random k (0 < k < q) and computes the session encryption key E-prime = E^k mod p and partial decryption keys g-bar-prime = g-bar^k mod p and g-hat-prime = g-hat^k mod p. He encrypts x = E-prime * r mod p and sends (x, g-bar-prime, g-hat-prime) to Alice.",
      "ja": "2.ボブはランダムK（0 <K <Q）をロールし、セッション暗号鍵Eプライム= E ^ K MOD pおよび部分復号鍵Gバープライム= Gバー^ K MOD pおよびG-HAT-を計算しますプライム=グラムハット^ kのモッズのp。彼は、x = E-プライム* Rモッズpを暗号化し、（X、G-バープライム、G-ハットプライム）アリスに送信します。"
    },
    {
      "indent": 3,
      "text": "3. Alice computes the session decryption key E^-1 = (g-bar-prime)^x-hat_j (g-hat-prime)^x-bar_j mod p and verifies that r = E^-1 x.",
      "ja": "3.アリスは、セッション復号鍵E ^ -1 =（G-バープライム）^ X-hat_j（G-ハットプライム）^ X-bar_j MOD Pを計算し、R = E ^ -1 Xことを検証します。"
    },
    {
      "indent": 0,
      "text": "Appendix H. ASN.1 Encoding Rules",
      "ja": "付録H. ASN.1符号化規則"
    },
    {
      "indent": 3,
      "text": "Certain value fields in request and response messages contain data encoded in ASN.1 distinguished encoding rules (DER). The BNF grammar for each encoding rule is given below along with the OpenSSL routine used for the encoding in the reference implementation. The object identifiers for the encryption algorithms and message digest/ signature encryption schemes are specified in [RFC3279]. The particular algorithms required for conformance are not specified in this memo.",
      "ja": "要求メッセージと応答メッセージ内の特定の値フィールドは、ASN.1識別符号化規則（DER）でエンコードされたデータを含みます。各符号化ルールのためのBNF文法は、リファレンス実装に符号化するために使用OpenSSLのルーチンとともに以下に与えられます。暗号化アルゴリズムとメッセージに対するオブジェクト識別子ダイジェスト/署名暗号化方式は、[RFC3279]で指定されています。適合のために必要な特定のアルゴリズムは、このメモで指定されていません。"
    },
    {
      "indent": 0,
      "text": "Appendix I. COOKIE Request, IFF Response, GQ Response, MV Response",
      "ja": "付録I.のCOOKIEリクエスト、IFF応答、GQレスポンス、MVレスポンス"
    },
    {
      "indent": 3,
      "text": "The value field of the COOKIE request message contains a sequence of two integers (n, e) encoded by the i2d_RSAPublicKey() routine in the OpenSSL distribution. In the request, n is the RSA modulus in bits and e is the public exponent.",
      "ja": "COOKIE要求メッセージの値フィールドは、OpenSSL分布i2d_RSAPublicKey（）ルーチンによってコードされる2つの整数（N、E）の配列を含みます。要求で、Nはビット単位RSAモジュラスであり、Eは、公開指数です。"
    },
    {
      "indent": 3,
      "text": "RSAPublicKey ::= SEQUENCE {\n        n ::= INTEGER,\n        e ::= INTEGER\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The IFF and GQ responses contain a sequence of two integers (r, s) encoded by the i2d_DSA_SIG() routine in the OpenSSL distribution. In the responses, r is the challenge response and s is the hash of the private value.",
      "ja": "IFFとGQ応答は、OpenSSL分布i2d_DSA_SIG（）ルーチンによってコードされる2つの整数（R、S）の配列を含みます。応答では、Rは、チャレンジ・レスポンスで、sは民間値のハッシュです。"
    },
    {
      "indent": 3,
      "text": "DSAPublicKey ::= SEQUENCE {\n        r ::= INTEGER,\n        s ::= INTEGER\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The MV response contains a sequence of three integers (p, q, g) encoded by the i2d_DSAparams() routine in the OpenSSL library. In the response, p is the hash of the encrypted challenge value and (q, g) is the client portion of the decryption key.",
      "ja": "MV応答は、OpenSSLライブラリのi2d_DSAparams（）ルーチンによってコードされる三つの整数（P、Q、G）の配列を含みます。応答では、pは暗号化されたチャレンジ値と、（Q、G）のハッシュを復号鍵のクライアント部分です。"
    },
    {
      "indent": 3,
      "text": "DSAparameters ::= SEQUENCE {\n        p ::= INTEGER,\n        q ::= INTEGER,\n        g ::= INTEGER\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix J. Certificates",
      "ja": "付録J.証明書"
    },
    {
      "indent": 3,
      "text": "Certificate extension fields are used to convey information used by the identity schemes. While the semantics of these fields generally conform with conventional usage, there are subtle variations. The fields used by Autokey version 2 include:",
      "ja": "証明書の拡張フィールドは、アイデンティティスキームによって使用される情報を伝えるために使用されています。これらのフィールドのセマンティクスは、一般に、従来の使用法に準拠しつつ、微妙な変化があります。 Autokeyバージョン2で使用するフィールドが含まれます："
    },
    {
      "indent": 3,
      "text": "o Basic Constraints. This field defines the basic functions of the certificate. It contains the string \"critical,CA:TRUE\", which means the field must be interpreted and the associated private key can be used to sign other certificates. While included for compatibility, Autokey makes no use of this field.",
      "ja": "基本制約O。このフィールドには、証明書の基本的な機能を定義します。フィールドが解釈されなければならないと関連付けられた秘密鍵は、他の証明書に署名するために使用できることを意味し、：それは、文字列「TRUE重要な、CA」が含まれています。互換性のために含まれますが、自動キーは、このフィールドを使用しません。"
    },
    {
      "indent": 3,
      "text": "o Key Usage. This field defines the intended use of the public key contained in the certificate. It contains the string \"digitalSignature,keyCertSign\", which means the contained public key can be used to verify signatures on data and other certificates. While included for compatibility, Autokey makes no use of this field.",
      "ja": "Oキー使用法。このフィールドには、証明書に含まれる公開鍵の使用目的を定義します。これは、含まれる公開鍵は、データと他の証明書に署名を検証するために使用できることを意味し、文字列「デジタル署名、KeyCertSignが」が、含まれています。互換性のために含まれますが、自動キーは、このフィールドを使用しません。"
    },
    {
      "indent": 3,
      "text": "o Extended Key Usage. This field further refines the intended use of the public key contained in the certificate and is present only in self-signed certificates. It contains the string \"Private\" if the certificate is designated private or the string \"trustRoot\" if it is designated trusted. A private certificate is always trusted.",
      "ja": "Oキー使用法を拡張。このフィールドには、さらに、証明書に含まれる公開鍵の使用目的を洗練して唯一の自己署名証明書の中に存在しています。それが信頼に指定されている場合、証明書は、プライベートまたは文字列「trustRoot」が指定された場合は、「プライベート」の文字列が含まれています。プライベート証明書は常に信頼されています。"
    },
    {
      "indent": 3,
      "text": "o Subject Key Identifier. This field contains the client identity key used in the GQ identity scheme. It is present only if the GQ scheme is in use.",
      "ja": "O件名キー識別子。このフィールドは、GQ識別スキームで使用されるクライアントIDのキーが含まれています。 GQスキームが使用されている場合にのみ存在しています。"
    },
    {
      "indent": 3,
      "text": "The value field contains an X.509v3 certificate encoded by the i2d_X509() routine in the OpenSSL distribution. The encoding follows the rules stated in [RFC5280], including the use of X.509v3 extension fields.",
      "ja": "値フィールドは、OpenSSL分布i2d_X509（）ルーチンによってコードX.509v3証明書を含んでいます。符号化は、のX.509v3拡張フィールドの使用を含む[RFC5280]に記載されているルールに従います。"
    },
    {
      "indent": 3,
      "text": "Certificate ::= SEQUENCE {\n        tbsCertificate                  TBSCertificate,\n        signatureAlgorithm              AlgorithmIdentifier,\n        signatureValue                  BIT STRING\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The signatureAlgorithm is the object identifier of the message digest/signature encryption scheme used to sign the certificate. The signatureValue is computed by the certificate issuer using this algorithm and the issuer private key.",
      "ja": "signatureAlgorithmは証明書に署名するために使用されるメッセージダイジェスト/署名暗号化スキームのオブジェクト識別子です。 signatureValueは、このアルゴリズムと発行者の秘密鍵を使用して、証明書発行者によって計算されます。"
    },
    {
      "indent": 3,
      "text": "TBSCertificate ::= SEQUENCE {\n        version                         EXPLICIT v3(2),\n        serialNumber                    CertificateSerialNumber,\n        signature                       AlgorithmIdentifier,\n        issuer                          Name,\n        validity                        Validity,\n        subject                         Name,\n        subjectPublicKeyInfo            SubjectPublicKeyInfo,\n        extensions                      EXPLICIT Extensions OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The serialNumber is an integer guaranteed to be unique for the generating host. The reference implementation uses the NTP seconds when the certificate was generated. The signature is the object identifier of the message digest/signature encryption scheme used to sign the certificate. It must be identical to the signatureAlgorithm.",
      "ja": "serialNumberを生成はホストに対して一意であることが保証整数です。証明書が生成されたときに、参照実装では、NTP秒を使用しています。署名は、証明書に署名するために使用されるメッセージダイジェスト/署名暗号化スキームのオブジェクト識別子です。それはのsignatureAlgorithmと同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "CertificateSerialNumber\nSET { ::= INTEGER\n        Validity ::= SEQUENCE {\n                notBefore              UTCTime,\n                notAfter               UTCTime\n        }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The notBefore and notAfter define the period of validity as defined in Appendix B.",
      "ja": "付録Bで定義されるようnotBeforeのとnotAfterのは、有効期限を定義します"
    },
    {
      "indent": 3,
      "text": "SubjectPublicKeyInfo ::= SEQUENCE {\n        algorithm                       AlgorithmIdentifier,\n        subjectPublicKey                BIT STRING\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The AlgorithmIdentifier specifies the encryption algorithm for the subject public key. The subjectPublicKey is the public key of the subject.",
      "ja": "AlgorithmIdentifierは、サブジェクト公開鍵の暗号化アルゴリズムを指定します。 subjectPublicKeyは、サブジェクトの公開鍵です。"
    },
    {
      "indent": 3,
      "text": "Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension\nExtension ::= SEQUENCE {\n        extnID                          OBJECT IDENTIFIER,\n        critical                        BOOLEAN DEFAULT FALSE,\n        extnValue                       OCTET STRING\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SET {\n        Name ::= SEQUENCE {\n                OBJECT IDENTIFIER       commonName\n                PrintableString         HostName\n        }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For trusted host certificates, the subject and issuer HostName is the NTP name of the group, while for all other host certificates the subject and issuer HostName is the NTP name of the host. In the reference implementation, if these names are not explicitly specified, they default to the string returned by the Unix gethostname() routine (trailing NUL removed). For other than self-signed certificates, the issuer HostName is the unique DNS name of the host signing the certificate.",
      "ja": "他のすべてのホスト証明書のサブジェクトと発行者のホスト名がホストのNTP名である一方で、信頼できるホストの証明書の場合は、対象と発行者ホスト名は、グループのNTP名です。これらの名前が明示的に指定されていない場合はリファレンス実装では、彼らは、Unixのgethostname（）ルーチン（削除末尾のNUL）によって返される文字列にデフォルト設定します。自己署名証明書以外の場合は、発行者のホスト名は、証明書に署名するホストのユニークなDNS名です。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the Autokey protocol itself has no provisions to revoke certificates. The reference implementation is purposely restarted about once a week, leading to the regeneration of the certificate and a restart of the Autokey protocol. This restart is not enforced for the Autokey protocol but rather for NTP functionality reasons.",
      "ja": "自動キープロトコル自体が証明書を失効させる一切の規定を持っていないことに留意すべきです。リファレンス実装では意図的に証明書の再生とのAutokeyプロトコルの再起動につながる、週に一回程度再起動されます。この再起動は自動キープロトコルのためではなく、NTPの機能上の理由から強制されません。"
    },
    {
      "indent": 3,
      "text": "Each group host operates with only one certificate at a time and constructs a trail by induction. Since the group configuration must form an acyclic graph, with roots at the trusted hosts, it does not matter which, of possibly several, signed certificates is used. The reference implementation chooses a single certificate and operates with only that certificate until the protocol is restarted.",
      "ja": "各グループのホストは、一度に1つの証明書のみで動作し、誘導により証跡を構築します。グループの構成は、信頼できるホストにルーツを持つ非循環グラフを形成しなければならないので、おそらく、いくつかの、署名証明書の使用され、重要ではありません。リファレンス実装では、単一の証明書を選択し、プロトコルを再起動するまでのみ、その証明書を使用して動作します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Brian Haberman (editor) The Johns Hopkins University Applied Physics Laboratory 11100 Johns Hopkins Road Laurel, MD 20723-6099 US",
      "ja": "ブライアンハーバーマン（エディタ）ジョンズ・ホプキンス大学応用物理研究所11100ジョンズホプキンスロードローレル、MD 20723から6099米"
    },
    {
      "indent": 3,
      "text": "Phone: +1 443 778 1319 EMail: brian@innovationslab.net",
      "ja": "電話：+1 443 778 1319 Eメール：brian@innovationslab.net"
    },
    {
      "indent": 3,
      "text": "Dr. David L. Mills University of Delaware Newark, DE 19716 US",
      "ja": "デラウェア州ニューアーク、DE 19716米国のデビッドL.ミルズ大学"
    },
    {
      "indent": 3,
      "text": "Phone: +1 302 831 8247 EMail: mills@udel.edu",
      "ja": "電話：+1 302 831 8247 Eメール：mills@udel.edu"
    }
  ]
}