{
  "title": {
    "text": "RFC 5389 - Session Traversal Utilities for NAT (STUN)",
    "ja": "RFC 5389 - NATのためのセッショントラバーサルユーティリティ（STUN）"
  },
  "number": 5389,
  "created_at": "2019-10-27 06:42:27.424639+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       J. Rosenberg\nRequest for Comments: 5389                                         Cisco\nObsoletes: 3489                                                  R. Mahy\nCategory: Standards Track                                    P. Matthews\n                                                            Unaffiliated\n                                                                 D. Wing\n                                                                   Cisco\n                                                            October 2008",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Session Traversal Utilities for NAT (STUN)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Session Traversal Utilities for NAT (STUN) is a protocol that serves as a tool for other protocols in dealing with Network Address Translator (NAT) traversal. It can be used by an endpoint to determine the IP address and port allocated to it by a NAT. It can also be used to check connectivity between two endpoints, and as a keep-alive protocol to maintain NAT bindings. STUN works with many existing NATs, and does not require any special behavior from them.",
      "ja": "NATのためのセッショントラバーサルユーティリティ（STUN）は、ネットワークアドレス変換（NAT）トラバーサルに対処する他のプロトコルのためのツールとして役立つプロトコルです。 NATによってそれに割り当てられたIPアドレスとポートを決定するためにエンドポイントで使用することができます。また、2つのエンドポイント間の接続性を確認するために使用することができ、およびキープアライブプロトコルとしてNATバインディングを維持します。 STUNは多くの既存のNATで動作し、それらからの特別な動作を必要としません。"
    },
    {
      "indent": 3,
      "text": "STUN is not a NAT traversal solution by itself. Rather, it is a tool to be used in the context of a NAT traversal solution. This is an important change from the previous version of this specification (RFC 3489), which presented STUN as a complete solution.",
      "ja": "STUNは、それ自体でNATトラバーサルソリューションではありません。むしろ、NATトラバーサルソリューションのコンテキストで使用されるツールです。これは完全なソリューションとしてSTUNを提示し、この仕様（RFC 3489）、以前のバージョンからの重要な変更です。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 3489.",
      "ja": "この文書はRFC 3489を廃止します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 0,
      "text": "1. Introduction ....................................................4\n2. Evolution from RFC 3489 .........................................4\n3. Overview of Operation ...........................................5\n4. Terminology .....................................................8\n5. Definitions .....................................................8\n6. STUN Message Structure .........................................10\n7. Base Protocol Procedures .......................................12\n   7.1. Forming a Request or an Indication ........................12\n   7.2. Sending the Request or Indication .........................13",
      "raw": true
    },
    {
      "indent": 0,
      "text": "        7.2.1. Sending over UDP ...................................13\n        7.2.2. Sending over TCP or TLS-over-TCP ...................14\n   7.3. Receiving a STUN Message ..................................16\n        7.3.1. Processing a Request ...............................17\n               7.3.1.1. Forming a Success or Error Response .......18\n               7.3.1.2. Sending the Success or Error Response .....19\n        7.3.2. Processing an Indication ...........................19\n        7.3.3. Processing a Success Response ......................19\n        7.3.4. Processing an Error Response .......................20\n8. FINGERPRINT Mechanism ..........................................20\n9. DNS Discovery of a Server ......................................21\n10. Authentication and Message-Integrity Mechanisms ...............22\n   10.1. Short-Term Credential Mechanism ..........................22\n        10.1.1. Forming a Request or Indication ...................23\n        10.1.2. Receiving a Request or Indication .................23\n        10.1.3. Receiving a Response ..............................24\n   10.2. Long-Term Credential Mechanism ...........................24\n        10.2.1. Forming a Request .................................25\n               10.2.1.1. First Request ............................25\n               10.2.1.2. Subsequent Requests ......................26\n        10.2.2. Receiving a Request ...............................26\n        10.2.3. Receiving a Response ..............................27\n11. ALTERNATE-SERVER Mechanism ....................................28\n12. Backwards Compatibility with RFC 3489 .........................28\n   12.1. Changes to Client Processing .............................29\n   12.2. Changes to Server Processing .............................29\n13. Basic Server Behavior .........................................30\n14. STUN Usages ...................................................30\n15. STUN Attributes ...............................................31\n   15.1. MAPPED-ADDRESS ...........................................32\n   15.2. XOR-MAPPED-ADDRESS .......................................33\n   15.3. USERNAME .................................................34\n   15.4. MESSAGE-INTEGRITY ........................................34\n   15.5. FINGERPRINT ..............................................36\n   15.6. ERROR-CODE ...............................................36\n   15.7. REALM ....................................................38\n   15.8. NONCE ....................................................38\n   15.9. UNKNOWN-ATTRIBUTES .......................................38\n   15.10. SOFTWARE ................................................39\n   15.11. ALTERNATE-SERVER ........................................39\n16. Security Considerations .......................................39\n   16.1. Attacks against the Protocol .............................39\n        16.1.1. Outside Attacks ...................................39\n        16.1.2. Inside Attacks ....................................40\n   16.2. Attacks Affecting the Usage ..............................40\n        16.2.1. Attack I: Distributed DoS (DDoS) against a\n                Target ............................................41\n        16.2.2. Attack II: Silencing a Client .....................41",
      "raw": true
    },
    {
      "indent": 0,
      "text": "        16.2.3. Attack III: Assuming the Identity of a Client .....42\n        16.2.4. Attack IV: Eavesdropping ..........................42\n   16.3. Hash Agility Plan ........................................42\n17. IAB Considerations ............................................42\n18. IANA Considerations ...........................................43\n   18.1. STUN Methods Registry ....................................43\n   18.2. STUN Attribute Registry ..................................43\n   18.3. STUN Error Code Registry .................................44\n   18.4. STUN UDP and TCP Port Numbers ............................45\n19. Changes since RFC 3489 ........................................45\n20. Contributors ..................................................47\n21. Acknowledgements ..............................................47\n22. References ....................................................47\n   22.1. Normative References .....................................47\n   22.2. Informative References ...................................48\nAppendix A. C Snippet to Determine STUN Message Types .............50",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The protocol defined in this specification, Session Traversal Utilities for NAT, provides a tool for dealing with NATs. It provides a means for an endpoint to determine the IP address and port allocated by a NAT that corresponds to its private IP address and port. It also provides a way for an endpoint to keep a NAT binding alive. With some extensions, the protocol can be used to do connectivity checks between two endpoints [MMUSIC-ICE], or to relay packets between two endpoints [BEHAVE-TURN].",
      "ja": "この仕様で定義されたプロトコル、NATのセッショントラバーサルユーティリティは、NATを扱うためのツールを提供します。それは、そのプライベートIPアドレスとポートに対応するNATによって割り当てられたIPアドレスとポートを決定するために、エンドポイントのための手段を提供します。また、エンドポイントが生き結合NATを維持するための方法を提供します。いくつかの拡張と、プロトコルは2つのエンドポイント[MMUSIC-ICE]との間の接続性チェックを実行するために使用することができ、あるいは2つのエンドポイント[BEHAVE-TURN]間のパケットを中継します。"
    },
    {
      "indent": 3,
      "text": "In keeping with its tool nature, this specification defines an extensible packet format, defines operation over several transport protocols, and provides for two forms of authentication.",
      "ja": "そのツールの性質に合わせて、本明細書は、拡張可能なパケットフォーマットを定義するいくつかのトランスポートプロトコルでの動作を定義し、認証の二つの形態を提供します。"
    },
    {
      "indent": 3,
      "text": "STUN is intended to be used in context of one or more NAT traversal solutions. These solutions are known as STUN usages. Each usage describes how STUN is utilized to achieve the NAT traversal solution. Typically, a usage indicates when STUN messages get sent, which optional attributes to include, what server is used, and what authentication mechanism is to be used. Interactive Connectivity Establishment (ICE) [MMUSIC-ICE] is one usage of STUN. SIP Outbound [SIP-OUTBOUND] is another usage of STUN. In some cases, a usage will require extensions to STUN. A STUN extension can be in the form of new methods, attributes, or error response codes. More information on STUN usages can be found in Section 14.",
      "ja": "STUNは、一つ以上のNATトラバーサルソリューションのコンテキストで使用されることを意図しています。これらのソリューションは、STUN用法として知られています。それぞれの用法はSTUNがNATトラバーサルソリューションを達成するために利用される方法を説明します。一般的に、使用量はSTUNメッセージが送信されます場合は、オプションの属性が使用されているものを、サーバー、含めるためにどの示し、そしてどのような認証メカニズムを使用することです。インタラクティブ接続確立（ICE）[MMUSIC-ICE] STUNの使用です。 SIP発信[SIP-OUTBOUND]はSTUNの別の使用方法です。いくつかのケースでは、使用量はSTUNへの拡張が必要になります。 STUNの拡張は、新しいメソッド、属性、またはエラー応答コードの形態であってもよいです。 STUN用法の詳細については、第14条に記載されています。"
    },
    {
      "indent": 1,
      "text": "2. Evolution from",
      "section_title": true,
      "ja": "2.進化"
    },
    {
      "indent": 3,
      "text": "STUN was originally defined in RFC 3489 [RFC3489]. That specification, sometimes referred to as \"classic STUN\", represented itself as a complete solution to the NAT traversal problem. In that solution, a client would discover whether it was behind a NAT, determine its NAT type, discover its IP address and port on the public side of the outermost NAT, and then utilize that IP address and port within the body of protocols, such as the Session Initiation Protocol (SIP) [RFC3261]. However, experience since the publication of RFC 3489 has found that classic STUN simply does not work sufficiently well to be a deployable solution. The address and port learned through classic STUN are sometimes usable for communications with a peer, and sometimes not. Classic STUN provided no way to discover whether it would, in fact, work or not, and it provided no remedy in cases where it did not. Furthermore, classic STUN's algorithm for classification of NAT types was found to be faulty, as many NATs did not fit cleanly into the types defined there.",
      "ja": "STUNはもともとRFC 3489 [RFC3489]で定義されました。その仕様は、時々、「古典的なSTUN」と呼ばれるNAT越え問題に対する完全なソリューションとしての地位を表します。その解決策では、クライアントは、それがNATの背後にあったかどうか発見するのNATタイプを決定し、最も外側のNATのパブリック側のIPアドレスとポートを発見し、そのような、プロトコルの本体内にそのIPアドレスとポートを利用することになりますセッション開始プロトコル（SIP）[RFC3261]として。しかし、RFC 3489の公表以来、経験は、古典的なSTUNは単純に展開ソリューションであることが十分に動作しないことを発見しました。アドレスおよびポートは、古典的なSTUNによって学習時々ない時々ピアとの通信のために使用可能である、と。クラシックSTUNは、それがあるかどうか、実際には、仕事やない発見する方法を提供していない、そしてそれがなかった場合には何の救済策を提供しません。さらに、NATタイプの分類のための古典的なSTUNのアルゴリズムは、多くのNATが定義された型にきれいにフィットしていなかったとして、障害のあることが判明しました。"
    },
    {
      "indent": 3,
      "text": "Classic STUN also had a security vulnerability -- attackers could provide the client with incorrect mapped addresses under certain topologies and constraints, and this was fundamentally not solvable through any cryptographic means. Though this problem remains with this specification, those attacks are now mitigated through the use of more complete solutions that make use of STUN.",
      "ja": "攻撃者は、特定のトポロジや制約の下で間違ってマップされたアドレスをクライアントに提供することができ、これは基本的に任意の暗号化手段を通じて解決可能ではなかった - クラシックSTUNは、セキュリティ上の脆弱性を持っていました。この問題は、この仕様に残るものの、これらの攻撃は今、STUNを利用して、より完全なソリューションを使用することによって軽減されます。"
    },
    {
      "indent": 3,
      "text": "For these reasons, this specification obsoletes RFC 3489, and instead describes STUN as a tool that is utilized as part of a complete NAT traversal solution. ICE [MMUSIC-ICE] is a complete NAT traversal solution for protocols based on the offer/answer [RFC3264] methodology, such as SIP. SIP Outbound [SIP-OUTBOUND] is a complete solution for traversal of SIP signaling, and it uses STUN in a very different way. Though it is possible that a protocol may be able to use STUN by itself (classic STUN) as a traversal solution, such usage is not described here and is strongly discouraged for the reasons described above.",
      "ja": "これらの理由から、この仕様はRFC 3489を廃止し、代わりに完全なNATトラバーサルソリューションの一部として利用されるツールとしてSTUNを説明しています。 ICE [MMUSIC-ICE]は、SIPなどのオファー/アンサー[RFC3264]方法論に基づいたプロトコルのための完全なNATトラバーサルソリューションです。 SIP発信[SIP-OUTBOUND]はSIPシグナリングのトラバーサルのための完全なソリューションであり、それは非常に異なる方法でSTUNを使用します。それはプロトコルはトラバーサルソリューションとしての地位（クラシックSTUN）によってSTUNを使用できる可能性があるが、そのような使用は、ここに記載されていないと強く上述の理由のために推奨されます。"
    },
    {
      "indent": 3,
      "text": "The on-the-wire protocol described here is changed only slightly from classic STUN. The protocol now runs over TCP in addition to UDP. Extensibility was added to the protocol in a more structured way. A magic cookie mechanism for demultiplexing STUN with application protocols was added by stealing 32 bits from the 128-bit transaction ID defined in RFC 3489, allowing the change to be backwards compatible. Mapped addresses are encoded using a new exclusive-or format. There are other, more minor changes. See Section 19 for a more complete listing.",
      "ja": "ここで説明するオン・ワイヤプロトコルは、古典的なSTUNからわずかしか変更されます。プロトコルは現在、UDPに加えてTCP上で実行されます。拡張性は、より構造化された方法でプロトコルに追加されました。アプリケーションプロトコルとSTUNを逆多重化するためのマジッククッキー機構は、RFC 3489で定義された128ビットのトランザクションIDから32ビットを盗む変更が後方互換性があるようにすることによって添加しました。マップされたアドレスは、新たな排他的論理和の形式を使用してエンコードされています。他の、より多くのマイナーな変更があります。より完全なリストについては、セクション19を参照してください。"
    },
    {
      "indent": 3,
      "text": "Due to the change in scope, STUN has also been renamed from \"Simple Traversal of UDP through NAT\" to \"Session Traversal Utilities for NAT\". The acronym remains STUN, which is all anyone ever remembers anyway.",
      "ja": "範囲の変更に、STUNは、「NATのセッショントラバーサルユーティリティ」を「NATによるUDPのシンプルトラバーサル」から改名されました。頭字語は、誰もが今までとにかく覚えているすべてであるSTUN、残ります。"
    },
    {
      "indent": 0,
      "text": "3. Overview of Operation",
      "section_title": true,
      "ja": "操作の概要3。"
    },
    {
      "indent": 3,
      "text": "This section is descriptive only.",
      "ja": "このセクションでは、唯一の記述です。"
    },
    {
      "indent": 28,
      "text": "   /-----\\\n // STUN  \\\\\n|   Server  |\n \\\\       //\n   \\-----/",
      "raw": true
    },
    {
      "indent": 10,
      "text": "                +--------------+             Public Internet\n................|     NAT 2    |.......................\n                +--------------+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "                +--------------+             Private NET 2\n................|     NAT 1    |.......................\n                +--------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "   /-----\\\n //  STUN \\\\\n|    Client |\n \\\\       //               Private NET 1\n   \\-----/",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 1: One Possible STUN Configuration",
      "ja": "図1：一つの可能​​なSTUNの設定"
    },
    {
      "indent": 3,
      "text": "One possible STUN configuration is shown in Figure 1. In this configuration, there are two entities (called STUN agents) that implement the STUN protocol. The lower agent in the figure is the client, and is connected to private network 1. This network connects to private network 2 through NAT 1. Private network 2 connects to the public Internet through NAT 2. The upper agent in the figure is the server, and resides on the public Internet.",
      "ja": "一つの可能​​なSTUNの構成はこの構成では、図1に示され、STUNプロトコルを実装する2つのエンティティ（と呼ばれるSTUN剤）があります。図の下エージェントがクライアントであり、このネットワークはNAT 1.プライベートネットワーク2を介してプライベートネットワーク2に接続するプライベートネットワーク1に接続されている図の上側のエージェントは、サーバーでNAT 2を介して公衆インターネットに接続します、および公共のインターネット上に存在します。"
    },
    {
      "indent": 3,
      "text": "STUN is a client-server protocol. It supports two types of transactions. One is a request/response transaction in which a client sends a request to a server, and the server returns a response. The second is an indication transaction in which either agent -- client or server -- sends an indication that generates no response. Both types of transactions include a transaction ID, which is a randomly selected 96-bit number. For request/response transactions, this transaction ID allows the client to associate the response with the request that generated it; for indications, the transaction ID serves as a debugging aid.",
      "ja": "STUNはクライアント・サーバ・プロトコルです。これは、2つのタイプのトランザクションをサポートしています。一つは、クライアントがサーバに要求を送信する要求/応答トランザクションであり、サーバは応答を返します。クライアントまたはサーバ -   - 第二は、トランザクション内のエージェントのどちらかの指標である応答を生成しない指示を送信します。トランザクションの両方のタイプは、ランダムに選択された96ビットの数であるトランザクションIDを含みます。要求/応答トランザクションの場合、このトランザクションIDは、クライアントがそれを生成した要求と応答を関連付けることができます。適応症のために、トランザクションIDは、デバッグ支援として機能します。"
    },
    {
      "indent": 3,
      "text": "All STUN messages start with a fixed header that includes a method, a class, and the transaction ID. The method indicates which of the various requests or indications this is; this specification defines just one method, Binding, but other methods are expected to be defined in other documents. The class indicates whether this is a request, a success response, an error response, or an indication. Following the fixed header comes zero or more attributes, which are Type-Length-Value extensions that convey additional information for the specific message.",
      "ja": "すべてのSTUNメッセージは、メソッド、クラス、およびトランザクションIDを含む固定ヘッダで始まります。この方法は、これは、種々の要求又は指示のかを示します。本明細書では結合、ただ一つの方法を定義して、他の方法は、他の文書で定義されることが期待されます。クラスは、この要求成功応答、エラー応答、または指示であるか否かを示します。固定ヘッダに続いて、特定のメッセージのための追加的な情報を伝えるなType-Length-値の拡張であり、ゼロ以上の属性を、来ます。"
    },
    {
      "indent": 3,
      "text": "This document defines a single method called Binding. The Binding method can be used either in request/response transactions or in indication transactions. When used in request/response transactions, the Binding method can be used to determine the particular \"binding\" a NAT has allocated to a STUN client. When used in either request/ response or in indication transactions, the Binding method can also be used to keep these \"bindings\" alive.",
      "ja": "この文書では、バインディングと呼ばれる単一のメソッドを定義しています。結合方法は、要求/応答トランザクションまたは指示トランザクションのいずれかで使用することができます。要求/応答トランザクションで使用される場合、結合方法は、NATがSTUNクライアントに割り当てられた「結合」とは、特定のかを決定するために使用することができます。要求/応答または指示トランザクションでのいずれかで使用される場合、結合方法はまた、生きているこれらの「バインディング」を維持するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "In the Binding request/response transaction, a Binding request is sent from a STUN client to a STUN server. When the Binding request arrives at the STUN server, it may have passed through one or more NATs between the STUN client and the STUN server (in Figure 1, there were two such NATs). As the Binding request message passes through a NAT, the NAT will modify the source transport address (that is, the source IP address and the source port) of the packet. As a result, the source transport address of the request received by the server will be the public IP address and port created by the NAT closest to the server. This is called a reflexive transport address. The STUN server copies that source transport address into an XOR-MAPPED-ADDRESS attribute in the STUN Binding response and sends the Binding response back to the STUN client. As this packet passes back through a NAT, the NAT will modify the destination transport address in the IP header, but the transport address in the XOR-MAPPED-ADDRESS attribute within the body of the STUN response will remain untouched. In this way, the client can learn its reflexive transport address allocated by the outermost NAT with respect to the STUN server.",
      "ja": "バインディング要求/応答トランザクションでは、バインド要求がSTUNサーバにSTUNクライアントから送信されます。バインディング要求がSTUNサーバに到着すると、それはSTUNクライアントとSTUNサーバとの間の1つまたは複数のNATを通過している可能性があり（図1において、二つのそのようなNATのがありました）。バインディング要求メッセージがNATを通過すると、NATは、ソース・トランスポート・アドレスを変更します（つまり、送信元IPアドレスと送信元ポート）パケット。その結果、サーバーが受信したリクエストの送信元トランスポートアドレスはサーバーに最も近いNATによって作成されたパブリックIPアドレスとポートになります。これは、再帰の輸送アドレスと呼ばれています。 STUNサーバーSTUNバインディング応答でXOR-MAPPED-ADDRESS属性にコピー元トランスポートアドレスとは、バックSTUNクライアントへの結合応答を送信します。このパケットがNATを通って戻るように、NATは、IPヘッダ内の宛先トランスポートアドレスを変更しますが、STUN応答の本体内XORマッピングされたアドレス属性にトランスポートアドレスはそのまま残ります。このように、クライアントは、STUNサーバーに関して、最も外側のNATによって割り当てられたその再帰の輸送アドレスを学ぶことができます。"
    },
    {
      "indent": 3,
      "text": "In some usages, STUN must be multiplexed with other protocols (e.g., [MMUSIC-ICE], [SIP-OUTBOUND]). In these usages, there must be a way to inspect a packet and determine if it is a STUN packet or not. STUN provides three fields in the STUN header with fixed values that can be used for this purpose. If this is not sufficient, then STUN packets can also contain a FINGERPRINT value, which can further be used to distinguish the packets.",
      "ja": "いくつかの用途では、STUNは、他のプロトコル（例えば、[MMUSIC-ICE]、[SIP-OUTBOUND]）と多重化されなければなりません。これらの用途では、パケットを検査し、それがSTUNパケットであるかどうかを決定するための方法がなければなりません。 STUNは、この目的のために使用することができる固定値でSTUNヘッダーの3つのフィールドが提供されます。これが十分でない場合には、STUNパケットはまた、パケットを区別するために使用することができるFINGERPRINT値を含むことができます。"
    },
    {
      "indent": 3,
      "text": "STUN defines a set of optional procedures that a usage can decide to use, called mechanisms. These mechanisms include DNS discovery, a redirection technique to an alternate server, a fingerprint attribute for demultiplexing, and two authentication and message-integrity exchanges. The authentication mechanisms revolve around the use of a username, password, and message-integrity value. Two authentication mechanisms, the long-term credential mechanism and the short-term credential mechanism, are defined in this specification. Each usage specifies the mechanisms allowed with that usage.",
      "ja": "STUNは、使用率が使用することを決定することができる任意の手順と呼ばれるメカニズムのセットを定義します。これらの機構は、DNSディスカバリ、代替サーバへリダイレクト技術、分離のための指紋属性と、2つの認証とメッセージ整合性の交換を含みます。認証メカニズムは、ユーザー名、パスワード、およびメッセージの完全性値の使用を中心に展開します。 2つの認証メカニズム、長期資格機構および短期信用証明機構は、本明細書で定義されています。各用法はその用法で許可メカニズムを指定します。"
    },
    {
      "indent": 3,
      "text": "In the long-term credential mechanism, the client and server share a pre-provisioned username and password and perform a digest challenge/ response exchange inspired by (but differing in details) to the one defined for HTTP [RFC2617]. In the short-term credential mechanism, the client and the server exchange a username and password through some out-of-band method prior to the STUN exchange. For example, in the ICE usage [MMUSIC-ICE] the two endpoints use out-of-band signaling to exchange a username and password. These are used to integrity protect and authenticate the request and response. There is no challenge or nonce used.",
      "ja": "長期資格情報メカニズムでは、クライアントとサーバのシェアは、事前にプロビジョニングされたユーザー名とパスワードとは、HTTP [RFC2617]のために定義されたものに（しかし、詳細が異なる）に触発されたダイジェストチャレンジ/レスポンス交換を行います。前STUN交換にはいくつかのアウトオブバンド方式による短期資格機構では、クライアントとサーバーの交換のユーザ名とパスワードを入力します。例えば、ICE用法[MMUSIC-ICE]に2つのエンドポイントは、ユーザ名とパスワードを交換するシグナリング帯域外使用します。これらは、要求および応答を保護し、認証の整合性に使用されています。使用なしの課題やナンスはありません。"
    },
    {
      "indent": 0,
      "text": "4. Terminology",
      "section_title": true,
      "ja": "4.用語"
    },
    {
      "indent": 3,
      "text": "In this document, the key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in BCP 14, RFC 2119 [RFC2119] and indicate requirement levels for compliant STUN implementations.",
      "ja": "この文書では、キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"NOT SHALL\"、 \"推奨\"、 \"すべきではない\" \"べきである\" \"ないものと\"、 \"MAY\"、および \"オプション\" BCP 14、RFC 2119 [RFC2119]に記載されており、対応STUNの実装に対する要求レベルを示すものとして解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "5. Definitions",
      "section_title": true,
      "ja": "5.定義"
    },
    {
      "indent": 3,
      "text": "STUN Agent: A STUN agent is an entity that implements the STUN protocol. The entity can be either a STUN client or a STUN server.",
      "ja": "STUNエージェント：STUNエージェントはSTUNプロトコルを実装するエンティティです。実体は、STUNクライアントかSTUNサーバーのいずれかになります。"
    },
    {
      "indent": 3,
      "text": "STUN Client: A STUN client is an entity that sends STUN requests and receives STUN responses. A STUN client can also send indications. In this specification, the terms STUN client and client are synonymous.",
      "ja": "STUNクライアント：STUNクライアントは、STUN要求を送信し、STUN応答を受信するエンティティです。 STUNクライアントにも表示を送信することができます。本明細書では、用語STUNクライアントとクライアントは同義です。"
    },
    {
      "indent": 3,
      "text": "STUN Server: A STUN server is an entity that receives STUN requests and sends STUN responses. A STUN server can also send indications. In this specification, the terms STUN server and server are synonymous.",
      "ja": "STUNサーバ：STUNサーバーがSTUN要求を受信し、STUN応答を送信するエンティティです。 STUNサーバも指摘を送ることができます。本明細書では、用語STUNサーバーとサーバーは同義です。"
    },
    {
      "indent": 3,
      "text": "Transport Address: The combination of an IP address and port number (such as a UDP or TCP port number).",
      "ja": "トランスポートアドレス：（UDPやTCPポート番号など）IPアドレスとポート番号の組み合わせ。"
    },
    {
      "indent": 3,
      "text": "Reflexive Transport Address: A transport address learned by a client that identifies that client as seen by another host on an IP network, typically a STUN server. When there is an intervening NAT between the client and the other host, the reflexive transport address represents the mapped address allocated to the client on the public side of the NAT. Reflexive transport addresses are learned from the mapped address attribute (MAPPED-ADDRESS or XOR-MAPPED-ADDRESS) in STUN responses.",
      "ja": "再帰トランスポートアドレス：IPネットワーク上の別のホスト、通常、STUNサーバによって見られるように、そのクライアントを識別し、クライアントによって学習されたトランスポートアドレス。クライアントと他のホストとの間に介在するNATが存在する場合、再帰トランスポートアドレスはNATのパブリック側のクライアントに割り当てられたマッピングされたアドレスを表します。再帰の輸送アドレスは、STUN応答のマッピングされたアドレスの属性（MAPPED-ADDRESSまたはXOR-MAPPED-ADDRESS）から学習されます。"
    },
    {
      "indent": 3,
      "text": "Mapped Address: Same meaning as reflexive address. This term is retained only for historic reasons and due to the naming of the MAPPED-ADDRESS and XOR-MAPPED-ADDRESS attributes.",
      "ja": "マップされた住所：再帰アドレスと同じ意味。この用語は、唯一の歴史的な理由のために起因しMAPPED-ADDRESSとXOR-MAPPED-ADDRESS属性の命名に保持されています。"
    },
    {
      "indent": 3,
      "text": "Long-Term Credential: A username and associated password that represent a shared secret between client and server. Long-term credentials are generally granted to the client when a subscriber enrolls in a service and persist until the subscriber leaves the service or explicitly changes the credential.",
      "ja": "長期資格：クライアントとサーバ間の共有秘密を表し、ユーザー名と関連付けられているパスワード。長期資格情報は、一般的に、加入者がサービスに登録する際に、クライアントに付与し、加入者がサービスを離れるか、明示的に資格情報を変更するまで持続しています。"
    },
    {
      "indent": 3,
      "text": "Long-Term Password: The password from a long-term credential.",
      "ja": "長期パスワード：長期資格情報からパスワード。"
    },
    {
      "indent": 3,
      "text": "Short-Term Credential: A temporary username and associated password that represent a shared secret between client and server. Short-term credentials are obtained through some kind of protocol mechanism between the client and server, preceding the STUN exchange. A short-term credential has an explicit temporal scope, which may be based on a specific amount of time (such as 5 minutes) or on an event (such as termination of a SIP dialog). The specific scope of a short-term credential is defined by the application usage.",
      "ja": "短期資格：クライアントとサーバ間の共有秘密を表し、一時的ユーザ名と関連付けられているパスワード。短期資格情報は、STUN交換に先行し、クライアントとサーバ間のプロトコルメカニズムのいくつかの種類を介して取得されています。短期資格情報は、明示的な時間の時間（例えば5分）の特定の量に基づくことができる範囲、またはイベントに（例えば、SIPダイアログの終端として）を有しています。短期信用証明書の具体的な範囲は、アプリケーションの使用によって定義されます。"
    },
    {
      "indent": 3,
      "text": "Short-Term Password: The password component of a short-term credential.",
      "ja": "短期パスワード：短期資格情報のパスワードコンポーネント。"
    },
    {
      "indent": 3,
      "text": "STUN Indication: A STUN message that does not receive a response.",
      "ja": "STUN表示：応答を受信しないSTUNメッセージ。"
    },
    {
      "indent": 3,
      "text": "Attribute: The STUN term for a Type-Length-Value (TLV) object that can be added to a STUN message. Attributes are divided into two types: comprehension-required and comprehension-optional. STUN agents can safely ignore comprehension-optional attributes they don't understand, but cannot successfully process a message if it contains comprehension-required attributes that are not understood.",
      "ja": "属性：STUNメッセージに追加することが可能なType-Length-Value（TLV）オブジェクトのSTUN用語。理解-必要と理解-オプション：属性は二つのタイプに分けられます。 STUNエージェントは、安全に、彼らは理解していない理解-オプションの属性を無視することができますが、それが理解されていない理解-必要な属性が含まれている場合は、メッセージを正常に処理することはできません。"
    },
    {
      "indent": 3,
      "text": "RTO: Retransmission TimeOut, which defines the initial period of time between transmission of a request and the first retransmit of that request.",
      "ja": "RTO：要求とその要求の最初の再送の送信の間の時間の初期期間を規定再送タイムアウト。"
    },
    {
      "indent": 0,
      "text": "6. STUN Message Structure",
      "section_title": true,
      "ja": "6. STUNメッセージの構造"
    },
    {
      "indent": 3,
      "text": "STUN messages are encoded in binary using network-oriented format (most significant byte or octet first, also commonly known as big-endian). The transmission order is described in detail in Appendix B of RFC 791 [RFC0791]. Unless otherwise noted, numeric constants are in decimal (base 10).",
      "ja": "STUNメッセージは（また、一般的にビッグエンディアンとして知られ、最初の最上位バイトまたはオクテット）ネットワーク指向の形式を使用してバイナリでエンコードされています。送信順序は、RFC 791 [RFC0791]の付録Bに詳細に記載されています。特に断りのない限り、数値定数は、小数点（基数10）です。"
    },
    {
      "indent": 3,
      "text": "All STUN messages MUST start with a 20-byte header followed by zero or more Attributes. The STUN header contains a STUN message type, magic cookie, transaction ID, and message length.",
      "ja": "すべてのSTUNメッセージは、ゼロ以上の属性に続く20バイトのヘッダで始まる必要があります。 STUNヘッダーはSTUNメッセージタイプ、マジッククッキー、トランザクションID、およびメッセージの長さを含んでいます。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0|     STUN Message Type     |         Message Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Magic Cookie                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                     Transaction ID (96 bits)                  |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 2: Format of STUN Message Header",
      "ja": "図2：STUNメッセージヘッダのフォーマット"
    },
    {
      "indent": 3,
      "text": "The most significant 2 bits of every STUN message MUST be zeroes. This can be used to differentiate STUN packets from other protocols when STUN is multiplexed with other protocols on the same port.",
      "ja": "すべてのSTUNメッセージの上位2ビットがゼロでなければなりません。これは、STUNを同じポート上の他のプロトコルと多重化されたときに他のプロトコルからSTUNパケットを区別するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "The message type defines the message class (request, success response, failure response, or indication) and the message method (the primary function) of the STUN message. Although there are four message classes, there are only two types of transactions in STUN: request/response transactions (which consist of a request message and a response message) and indication transactions (which consist of a single indication message). Response classes are split into error and success responses to aid in quickly processing the STUN message.",
      "ja": "メッセージタイプは、メッセージクラス（要求成功応答、失敗応答、または表示）とSTUNメッセージのメッセージ法（一次関数）を定義します。 （要求メッセージと応答メッセージから成る）要求/応答トランザクションと表示トランザクション（単一指示メッセージから成る）：4つのメッセージクラスがあるが、STUNのトランザクションの唯一の2種類があります。レスポンスクラスはすぐにSTUNメッセージの処理を支援するために、エラーと成功のレスポンスに分割されています。"
    },
    {
      "indent": 3,
      "text": "The message type field is decomposed further into the following structure:",
      "ja": "メッセージタイプフィールドは、次のような構造にさらに分解されます。"
    },
    {
      "indent": 24,
      "text": "0                 1\n2  3  4 5 6 7 8 9 0 1 2 3 4 5",
      "raw": true
    },
    {
      "indent": 23,
      "text": "+--+--+-+-+-+-+-+-+-+-+-+-+-+-+\n|M |M |M|M|M|C|M|M|M|C|M|M|M|M|\n|11|10|9|8|7|1|6|5|4|0|3|2|1|0|\n+--+--+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 3: Format of STUN Message Type Field",
      "ja": "図3：STUNメッセージタイプフィールドのフォーマット"
    },
    {
      "indent": 3,
      "text": "Here the bits in the message type field are shown as most significant (M11) through least significant (M0). M11 through M0 represent a 12- bit encoding of the method. C1 and C0 represent a 2-bit encoding of the class. A class of 0b00 is a request, a class of 0b01 is an indication, a class of 0b10 is a success response, and a class of 0b11 is an error response. This specification defines a single method, Binding. The method and class are orthogonal, so that for each method, a request, success response, error response, and indication are possible for that method. Extensions defining new methods MUST indicate which classes are permitted for that method.",
      "ja": "ここで、メッセージタイプフィールドのビットは、最下位（M0）を介して最上位（M11）として示されています。 M0を介してM11は、方法の12ビット符号化を表します。 C1とC0は、クラスの2ビット符号化を表します。 0b00とのクラスが要求され、0B01のクラスが表示され、0b10とのクラスは、成功応答であり、及び0b11にクラスは、エラー応答です。この仕様は、結合、単一のメソッドを定義します。各方法、要求成功応答、エラー応答、および表示のためにその方法を可能となるようにする方法とクラスは、直交しています。新しいメソッドを定義する拡張機能は、そのメソッドのために許可されているクラス指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, a Binding request has class=0b00 (request) and method=0b000000000001 (Binding) and is encoded into the first 16 bits as 0x0001. A Binding response has class=0b10 (success response) and method=0b000000000001, and is encoded into the first 16 bits as 0x0101.",
      "ja": "例えば、結合要求は、クラス= 0b00との（リクエスト）およびメソッド= 0b000000000001（結合）を有し、0x0001のような最初の16ビットに符号化されます。結合応答は、クラス= 0b10との（成功応答）とメソッド= 0b000000000001であり、0x0101のように最初の16ビットに符号化されます。"
    },
    {
      "indent": 6,
      "text": "Note: This unfortunate encoding is due to assignment of values in [RFC3489] that did not consider encoding Indications, Success, and Errors using bit fields.",
      "ja": "注：この不幸なエンコーディングが原因適応症、成功、およびビットフィールドを使用してエラーをコード考慮していなかった[RFC3489]の値の割り当てにあります。"
    },
    {
      "indent": 3,
      "text": "The magic cookie field MUST contain the fixed value 0x2112A442 in network byte order. In RFC 3489 [RFC3489], this field was part of the transaction ID; placing the magic cookie in this location allows a server to detect if the client will understand certain attributes that were added in this revised specification. In addition, it aids in distinguishing STUN packets from packets of other protocols when STUN is multiplexed with those other protocols on the same port.",
      "ja": "マジッククッキーフィールドは、ネットワークバイトオーダーで固定値0x2112A442を含まなければなりません。 RFC 3489 [RFC3489]では、このフィールドは、トランザクションIDの一部でした。この場所にマジッククッキーを配置すると、クライアントは、この改訂仕様に追加された特定の属性を理解する場合は、サーバーが検出することができます。また、STUNは、同じポート上のそれらの他のプロトコルと多重化された場合、他のプロトコルのパケットとSTUNパケットを区別するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "The transaction ID is a 96-bit identifier, used to uniquely identify STUN transactions. For request/response transactions, the transaction ID is chosen by the STUN client for the request and echoed by the server in the response. For indications, it is chosen by the agent sending the indication. It primarily serves to correlate requests with responses, though it also plays a small role in helping to prevent certain types of attacks. The server also uses the transaction ID as a key to identify each transaction uniquely across all clients. As such, the transaction ID MUST be uniformly and randomly chosen from the interval 0 .. 2**96-1, and SHOULD be cryptographically random. Resends of the same request reuse the same transaction ID, but the client MUST choose a new transaction ID for new transactions unless the new request is bit-wise identical to the previous request and sent from the same transport address to the same IP address. Success and error responses MUST carry the same transaction ID as their corresponding request. When an agent is acting as a STUN server and STUN client on the same port, the transaction IDs in requests sent by the agent have no relationship to the transaction IDs in requests received by the agent.",
      "ja": "トランザクションIDは、一意STUNトランザクションを識別するために使用される96ビットの識別子です。要求/応答トランザクションの場合、トランザクションIDは、要求のためのSTUNクライアントによって選択され、応答でサーバによってエコー。適応症のためには、表示を送信するエージェントによって選択されています。これは主に、それはまた、あるタイプの攻撃を防ぐことができますに小さな役割を果たしているものの、レスポンスとリクエストを関連付けるのに役立ちます。また、サーバはすべてのクライアント間で一意に各トランザクションを識別するためのキーとしてトランザクションIDを使用しています。このように、トランザクションIDは、均一かつランダムに間隔0から選択されなければならない.. 2 ** 96-1、及び暗号的にランダムであるべきです。同じ要求の再送信は、同じトランザクションIDを再利用しますが、新しい要求が前の要求と同じビット単位で、同じIPアドレスに同じトランスポートアドレスから送信されない限り、クライアントは、新しいトランザクションのための新しいトランザクションIDを選択する必要があります。成功とエラー応答がそれに対応する要求と同じトランザクションIDを運ばなければなりません。エージェントが同じポート上のSTUNサーバとSTUNクライアントとして動作している場合は、エージェントによって送信された要求におけるトランザクションIDは、エージェントが受信した要求におけるトランザクションIDとは関係がありません。"
    },
    {
      "indent": 3,
      "text": "The message length MUST contain the size, in bytes, of the message not including the 20-byte STUN header. Since all STUN attributes are padded to a multiple of 4 bytes, the last 2 bits of this field are always zero. This provides another way to distinguish STUN packets from packets of other protocols.",
      "ja": "メッセージの長さは20バイトのSTUNヘッダーを含まないメッセージのサイズをバイト単位で、含まなければなりません。すべてのSTUN属性が4バイトの倍数に埋め込まれているため、このフィールドの最後の2ビットは常にゼロです。これは、他のプロトコルのパケットとSTUNパケットを区別するための別の方法を提供します。"
    },
    {
      "indent": 3,
      "text": "Following the STUN fixed portion of the header are zero or more attributes. Each attribute is TLV (Type-Length-Value) encoded. The details of the encoding, and of the attributes themselves are given in Section 15.",
      "ja": "ヘッダのSTUN固定部以下、ゼロ以上の属性です。各属性は、TLV（タイプ - 長さ - 値）エンコードです。符号化の詳細、および自体はセクション15に記載されている属性の。"
    },
    {
      "indent": 0,
      "text": "7. Base Protocol Procedures",
      "section_title": true,
      "ja": "7.基本プロトコル手順"
    },
    {
      "indent": 3,
      "text": "This section defines the base procedures of the STUN protocol. It describes how messages are formed, how they are sent, and how they are processed when they are received. It also defines the detailed processing of the Binding method. Other sections in this document describe optional procedures that a usage may elect to use in certain situations. Other documents may define other extensions to STUN, by adding new methods, new attributes, or new error response codes.",
      "ja": "このセクションでは、STUNプロトコルのベース手順を定義します。それは彼らが送信されるか、メッセージが形成されている方法について説明し、それらがどのように受信されたとき、それらが処理されます。それはまた、結合方法の詳細な処理を定義します。この文書の他のセクションでは、使用が特定の状況で使用することを選択することができる任意の手順を記載しています。他の文書は、新しい方法、新しい属性、または新しいエラー応答コードを追加することによって、STUNに他の拡張機能を定義することができます。"
    },
    {
      "indent": 0,
      "text": "7.1. Forming a Request or an Indication",
      "section_title": true,
      "ja": "7.1。要求や指示を形成します"
    },
    {
      "indent": 3,
      "text": "When formulating a request or indication message, the agent MUST follow the rules in Section 6 when creating the header. In addition, the message class MUST be either \"Request\" or \"Indication\" (as appropriate), and the method must be either Binding or some method defined in another document.",
      "ja": "要求又は指示メッセージを定式化する際にヘッダを作成する場合、エージェントはセクション6の規則に従わなければなりません。また、メッセージクラスは、「要求」または（必要に応じて）「表示」のいずれかでなければなりません、そしてこの方法は、結合または他の文書で定義されたいくつかの方法のいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The agent then adds any attributes specified by the method or the usage. For example, some usages may specify that the agent use an authentication method (Section 10) or the FINGERPRINT attribute (Section 8).",
      "ja": "エージェントは、メソッドや使用方法によって指定された任意の属性を追加します。例えば、いくつかの用途は、エージェントが認証方法（セクション10）または指紋属性（セクション8）を使用することを指定してもよいです。"
    },
    {
      "indent": 3,
      "text": "If the agent is sending a request, it SHOULD add a SOFTWARE attribute to the request. Agents MAY include a SOFTWARE attribute in indications, depending on the method. Extensions to STUN should discuss whether SOFTWARE is useful in new indications.",
      "ja": "エージェントは、要求を送信している場合は、その要求にSOFTWARE属性を追加する必要があります。エージェントは、この方法によっては、適応症におけるSOFTWARE属性を含むかもしれません。 STUNへの拡張は、ソフトウェアが新しい適応症に有用であるかどうかを議論する必要があります。"
    },
    {
      "indent": 3,
      "text": "For the Binding method with no authentication, no attributes are required unless the usage specifies otherwise.",
      "ja": "使い方が別途定める場合を除き、認証なしとの結合方法については、何の属性は必要ありません。"
    },
    {
      "indent": 3,
      "text": "All STUN messages sent over UDP SHOULD be less than the path MTU, if known. If the path MTU is unknown, messages SHOULD be the smaller of 576 bytes and the first-hop MTU for IPv4 [RFC1122] and 1280 bytes for IPv6 [RFC2460]. This value corresponds to the overall size of the IP packet. Consequently, for IPv4, the actual STUN message would need to be less than 548 bytes (576 minus 20-byte IP header, minus 8-byte UDP header, assuming no IP options are used). STUN provides no ability to handle the case where the request is under the MTU but the response would be larger than the MTU. It is not envisioned that this limitation will be an issue for STUN. The MTU limitation is a SHOULD, and not a MUST, to account for cases where STUN itself is being used to probe for MTU characteristics [BEHAVE-NAT]. Outside of this or similar applications, the MTU constraint MUST be followed.",
      "ja": "UDP経由で送信されるすべてのSTUNメッセージが既知の場合、パスMTU未満でなければなりません。パスMTUが未知である場合、メッセージは、576バイトとIPv6 [RFC2460]のIPv4 [RFC1122] 1280バイトの最初のホップMTUを小さくなければなりません。この値は、IPパケットの全体のサイズに対応しています。これにより、IPv4で、実際のSTUNメッセージは（ないIPオプションを使用しないと仮定すると、576マイナス20バイトのIPヘッダー、マイナス8バイトのUDPヘッダ）未満548バイトである必要があろう。 STUN要求がMTUの下にあるが、応答がMTUよりも大きくなる場合に対処する能力を提供しません。この制限はSTUNのために問題になることが想定されていません。 MTUの制限はSTUN自身がMTU特性[BEHAVE-NAT]を探索するために使用されている場合を考慮して必要があり、しないなければなりません。このまたは同様のアプリケーションの外では、MTUの制約に従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.2. Sending the Request or Indication",
      "section_title": true,
      "ja": "7.2。要求や指示を送信します"
    },
    {
      "indent": 3,
      "text": "The agent then sends the request or indication. This document specifies how to send STUN messages over UDP, TCP, or TLS-over-TCP; other transport protocols may be added in the future. The STUN usage must specify which transport protocol is used, and how the agent determines the IP address and port of the recipient. Section 9 describes a DNS-based method of determining the IP address and port of a server that a usage may elect to use. STUN may be used with anycast addresses, but only with UDP and in usages where authentication is not used.",
      "ja": "エージェントは、要求や指示を送信します。この文書では、UDP、TCP、またはTLS-over-TCPの上でSTUNメッセージを送信する方法を指定します。他のトランスポートプロトコルは、将来的に追加することができます。 STUN用法が使用されているトランスポートプロトコルを指定する必要があり、エージェントは、受信者のIPアドレスとポートを決定する方法。セクション9は、使用率が使用することを選択することができるサーバーのIPアドレスとポートを決定するDNSベースの方法を記載しています。 STUNは、エニーキャストアドレスを持つが、唯一のUDPとし、認証が使用されていない用途に使用することができます。"
    },
    {
      "indent": 3,
      "text": "At any time, a client MAY have multiple outstanding STUN requests with the same STUN server (that is, multiple transactions in progress, with different transaction IDs). Absent other limits to the rate of new transactions (such as those specified by ICE for connectivity checks or when STUN is run over TCP), a client SHOULD space new transactions to a server by RTO and SHOULD limit itself to ten outstanding transactions to the same server.",
      "ja": "任意の時点で、クライアントは同じSTUNサーバー（つまり、異なるトランザクションIDで、進行中の複数のトランザクションである）を持つ複数の未STUN要求を持っているかもしれません。 （そのような接続性チェックやSTUNがTCP上で実行されたときのためのICEで指定されたものなど）、新たな取引のレートに不在その他の制限、クライアントはRTOによって、サーバへのスペースの新しいトランザクションが同じに10の未処理のトランザクションに自分自身を制限する必要がありますすべきですサーバ。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Sending over UDP",
      "section_title": true,
      "ja": "7.2.1。 UDP上で送信"
    },
    {
      "indent": 3,
      "text": "When running STUN over UDP, it is possible that the STUN message might be dropped by the network. Reliability of STUN request/ response transactions is accomplished through retransmissions of the request message by the client application itself. STUN indications are not retransmitted; thus, indication transactions over UDP are not reliable.",
      "ja": "UDP上でSTUNを実行している場合、STUNメッセージがネットワークによって廃棄される可能性があります可能性があります。 STUN要求/応答トランザクションの信頼性は、クライアント・アプリケーション自体によって要求メッセージの再送信を介して達成されます。 STUN兆候が再送されていません。このように、UDP上の表示トランザクションは、信頼性がありません。"
    },
    {
      "indent": 3,
      "text": "A client SHOULD retransmit a STUN request message starting with an interval of RTO (\"Retransmission TimeOut\"), doubling after each retransmission. The RTO is an estimate of the round-trip time (RTT), and is computed as described in RFC 2988 [RFC2988], with two exceptions. First, the initial value for RTO SHOULD be configurable (rather than the 3 s recommended in RFC 2988) and SHOULD be greater than 500 ms. The exception cases for this \"SHOULD\" are when other mechanisms are used to derive congestion thresholds (such as the ones defined in ICE for fixed rate streams), or when STUN is used in non-Internet environments with known network capacities. In fixed-line access links, a value of 500 ms is RECOMMENDED. Second, the value of RTO SHOULD NOT be rounded up to the nearest second. Rather, a 1 ms accuracy SHOULD be maintained. As with TCP, the usage of Karn's algorithm is RECOMMENDED [KARN87]. When applied to STUN, it means that RTT estimates SHOULD NOT be computed from STUN transactions that result in the retransmission of a request.",
      "ja": "クライアントは、各再送信後に倍増、RTOの間隔（「再送タイムアウト」）で始まるSTUN要求メッセージを再送信すべきです。 RTOは、ラウンドトリップ時間（RTT）の推定値であり、RFC 2988 [RFC2988]に記載のように、2つの例外を除いて、計算されます。まず、RTOの初期値は、（むしろRFC 2988で推奨3秒以上）設定されるべきであり、500ミリ秒より大きくなければなりません。他の機構は（例えば、固定レートのストリームのためのICEで定義されたものなど）、輻輳しきい値を導出するために使用される場合、またはSTUNが既知のネットワーク容量を有する非インターネット環境で使用される場合、このための例外ケースは、「SHOULD」。固定回線アクセスリンクでは、500ミリ秒の値が推奨されます。第二に、RTOの値は、最も近い秒に切り上げされるべきではありません。むしろ、1ミリ秒の精度が維持されるべきです。 TCPと同じように、カーンのアルゴリズムの使用は、[KARN87]推奨されます。 STUNに適用された場合、それはRTT推定値は、要求の再送信につながるSTUN取引から計算されるべきでないことを意味します。"
    },
    {
      "indent": 3,
      "text": "The value for RTO SHOULD be cached by a client after the completion of the transaction, and used as the starting value for RTO for the next transaction to the same server (based on equality of IP address). The value SHOULD be considered stale and discarded after 10 minutes.",
      "ja": "RTOの値は、トランザクションの完了後にクライアントによってキャッシュされ、および（IPアドレスの平等に基づいて）同じサーバーに次のトランザクションのためのRTOの開始値として使用する必要があります。値が古いと考えられ、10分後に廃棄されるべきである（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "Retransmissions continue until a response is received, or until a total of Rc requests have been sent. Rc SHOULD be configurable and SHOULD have a default of 7. If, after the last request, a duration equal to Rm times the RTO has passed without a response (providing ample time to get a response if only this final request actually succeeds), the client SHOULD consider the transaction to have failed. Rm SHOULD be configurable and SHOULD have a default of 16. A STUN transaction over UDP is also considered failed if there has been a hard ICMP error [RFC1122]. For example, assuming an RTO of 500 ms, requests would be sent at times 0 ms, 500 ms, 1500 ms, 3500 ms, 7500 ms, 15500 ms, and 31500 ms. If the client has not received a response after 39500 ms, the client will consider the transaction to have timed out.",
      "ja": "再送は、応答が受信されるまで継続する、またはRcは要求の合計まで送られてきました。 Rcは、設定する必要があり、最後の要求後、RTOは応答せずに通過したのRM倍に等しい持続時間は（これだけ最後の要求が実際に成功した場合の応答を取得するために十分な時間を提供する）、場合7のデフォルトを持っているべきです、クライアントは、トランザクションが失敗したと考えるべきです。 Rmが設定可能でなければならず、ハードICMPエラー[RFC1122]があった場合にも失敗したとみなされるUDPオーバー16 A STUNトランザクションのデフォルトを持つべきである（SHOULD）。例えば、500ミリ秒のRTOを仮定すると、要求は時間0ミリ秒、500ミリ秒、1500ミリ秒、3500ミリ秒、7500ミリ秒、15500ミリ秒、および31500ミリ秒で送信されることになります。クライアントは39500ミリ秒後に応答を受信しなかった場合、クライアントは、トランザクションがタイムアウトしていると考えます。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Sending over TCP or TLS-over-TCP",
      "section_title": true,
      "ja": "7.2.2。 TCPまたはTLS-over-TCPの上で送信"
    },
    {
      "indent": 3,
      "text": "For TCP and TLS-over-TCP, the client opens a TCP connection to the server.",
      "ja": "TCPとTLS-over-TCPのために、クライアントがサーバへのTCP接続をオープンします。"
    },
    {
      "indent": 3,
      "text": "In some usages of STUN, STUN is sent as the only protocol over the TCP connection. In this case, it can be sent without the aid of any additional framing or demultiplexing. In other usages, or with other extensions, it may be multiplexed with other data over a TCP connection. In that case, STUN MUST be run on top of some kind of framing protocol, specified by the usage or extension, which allows for the agent to extract complete STUN messages and complete application layer messages. The STUN service running on the well-known port or ports discovered through the DNS procedures in Section 9 is for STUN alone, and not for STUN multiplexed with other data. Consequently, no framing protocols are used in connections to those servers. When additional framing is utilized, the usage will specify how the client knows to apply it and what port to connect to. For example, in the case of ICE connectivity checks, this information is learned through out-of-band negotiation between client and server.",
      "ja": "STUNのいくつかの用法では、STUNはTCP接続上の唯一のプロトコルとして送信されます。この場合、それは追加のフレーミングや分離の助けを借りずに送信することができます。他の用途では、または他の拡張子を持つ、それはTCP接続を介して他のデータと多重化することができます。その場合には、STUNエージェントは、完全なSTUNメッセージと完全なアプリケーション層メッセージを抽出することを可能にする使用または拡張によって指定、フレーミングプロトコルのいくつかの種類の上で実行されなければなりません。第9章でDNSの手続きを経て発見された既知のポートまたはポート上で実行されているSTUNサービスはSTUNのためだけではなく、他のデータと多重STUNのためです。その結果、何のフレーミングプロトコルは、これらのサーバーへの接続に使用されていません。追加のフレーミングを利用する場合、利用状況は、クライアントがそれを適用するために知っているとどのようなポートに接続する方法を指定します。例えば、ICEの接続性チェックの場合には、この情報は、クライアントとサーバの間の帯域外交渉を通じて学習されます。"
    },
    {
      "indent": 3,
      "text": "When STUN is run by itself over TLS-over-TCP, the TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite MUST be implemented at a minimum. Implementations MAY also support any other ciphersuite. When it receives the TLS Certificate message, the client SHOULD verify the certificate and inspect the site identified by the certificate. If the certificate is invalid or revoked, or if it does not identify the appropriate party, the client MUST NOT send the STUN message or otherwise proceed with the STUN transaction. The client MUST verify the identity of the server. To do that, it follows the identification procedures defined in Section 3.1 of RFC 2818 [RFC2818]. Those procedures assume the client is dereferencing a URI. For purposes of usage with this specification, the client treats the domain name or IP address used in Section 8.1 as the host portion of the URI that has been dereferenced. Alternatively, a client MAY be configured with a set of domains or IP addresses that are trusted; if a certificate is received that identifies one of those domains or IP addresses, the client considers the identity of the server to be verified.",
      "ja": "STUNがTLS-over-TCPの上で単独で実行されると、TLS_RSA_WITH_AES_128_CBC_SHA暗号スイートは、最低でも実装しなければなりません。また、実装は、他の暗号スイートをサポートするかもしれません。それがTLS証明書メッセージを受信した場合、クライアントは証明書を検証し、証明書によって識別されるサイトを検査する必要があります。証明書が無効である場合または取り消し、あるいはそれが適切なパーティーを特定しない場合、クライアントはSTUNメッセージを送信したり、そうでない場合はSTUNトランザクションを進めてはなりません。クライアントはサーバーの身元を確かめなければなりません。これを行うためには、RFC 2818のセクション3.1 [RFC2818]で定義された識別手順に従います。これらの手順は、クライアントがURIを逆参照されているとします。この仕様と使用法の目的のために、クライアントは、逆参照されたURIのホスト部分としてセクション8.1で使用されるドメイン名やIPアドレスを扱います。また、クライアントは、ドメインまたは信頼されているIPアドレスのセットを用いて構成することができます。証明書は、それらのドメインやIPアドレスの1つを識別するその受信された場合、クライアントはサーバーの身元が確認されていると見なします。"
    },
    {
      "indent": 3,
      "text": "When STUN is run multiplexed with other protocols over a TLS-over-TCP connection, the mandatory ciphersuites and TLS handling procedures operate as defined by those protocols.",
      "ja": "STUNがTLS-over-TCPの接続を介して他のプロトコルと多重化を実行すると、これらのプロトコルによって定義されるように、必須暗号スイートとTLSの取り扱い手順が動作します。"
    },
    {
      "indent": 3,
      "text": "Reliability of STUN over TCP and TLS-over-TCP is handled by TCP itself, and there are no retransmissions at the STUN protocol level. However, for a request/response transaction, if the client has not received a response by Ti seconds after it sent the SYN to establish the connection, it considers the transaction to have timed out. Ti SHOULD be configurable and SHOULD have a default of 39.5s. This value has been chosen to equalize the TCP and UDP timeouts for the default initial RTO.",
      "ja": "TCPとTLS-オーバー-TCP上STUNの信頼性は、TCP自体によって処理され、そしてSTUNプロトコルレベルでの再送信は存在しません。それは、接続を確立するためのSYNを送った後、クライアントは、Ti秒で応答を受信して​​いない場合は、要求/応答トランザクションのために、それは、トランザクションがタイムアウトしたとみなします。 Tiは、設定されるべきであり、39.5sのデフォルトを持つべきである（SHOULD）。この値は、デフォルトの初期RTOのためのTCPおよびUDPタイムアウトを均等化するために選択されています。"
    },
    {
      "indent": 3,
      "text": "In addition, if the client is unable to establish the TCP connection, or the TCP connection is reset or fails before a response is received, any request/response transaction in progress is considered to have failed.",
      "ja": "クライアントは、TCP接続を確立することができない、またはTCP接続がリセットされたり、応答が受信される前に失敗した場合に加えて、進行中のすべての要求/応答トランザクションは失敗したと考えられています。"
    },
    {
      "indent": 3,
      "text": "The client MAY send multiple transactions over a single TCP (or TLS-over-TCP) connection, and it MAY send another request before receiving a response to the previous. The client SHOULD keep the connection open until it:",
      "ja": "クライアントは、単一のTCP（またはTLSオーバー-TCP）接続を介して複数のトランザクションを送信することができ、そしてそれは、以前に応答を受信する前に、別の要求を送信することができます。クライアントは、それまで開いている接続を維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "o has no further STUN requests or indications to send over that connection, and",
      "ja": "oはその接続を介して送信するためにそれ以上のSTUN要求または兆候を持っていない、と"
    },
    {
      "indent": 3,
      "text": "o has no plans to use any resources (such as a mapped address (MAPPED-ADDRESS or XOR-MAPPED-ADDRESS) or relayed address [BEHAVE-TURN]) that were learned though STUN requests sent over that connection, and",
      "ja": "oはSTUN要求がその接続を介して送信されても​​学習された（例えばマッピングされたアドレス（MAPPED-ADDRESSまたはXORマッピングされ-ADDRESS）又は中継アドレス[BEHAVE-TURN]など）の任意のリソースを使用する計画はない、と"
    },
    {
      "indent": 3,
      "text": "o if multiplexing other application protocols over that port, has finished using that other application, and",
      "ja": "Oそのポート経由多重他のアプリケーションプロトコルあれば、他のアプリケーションの使用が終了し、"
    },
    {
      "indent": 3,
      "text": "o if using that learned port with a remote peer, has established communications with that remote peer, as is required by some TCP NAT traversal techniques (e.g., [MMUSIC-ICE-TCP]).",
      "ja": "それはリモートピアのポートを学習し使用している場合、いくつかのTCP NATトラバーサル技法（例えば、[MMUSIC-ICE-TCP]）によって必要とされるO、、そのリモートピアとの通信を確立しました。"
    },
    {
      "indent": 3,
      "text": "At the server end, the server SHOULD keep the connection open, and let the client close it, unless the server has determined that the connection has timed out (for example, due to the client disconnecting from the network). Bindings learned by the client will remain valid in intervening NATs only while the connection remains open. Only the client knows how long it needs the binding. The server SHOULD NOT close a connection if a request was received over that connection for which a response was not sent. A server MUST NOT ever open a connection back towards the client in order to send a response. Servers SHOULD follow best practices regarding connection management in cases of overload.",
      "ja": "サーバー側では、サーバが接続を開いたまま、およびサーバは、接続がタイムアウトしたと判断した場合を除き、クライアントが（原因ネットワークから切断クライアントに、例えば）、それをクローズさせてください。クライアントによって学習されたバインディングは、接続が開いたまま間だけ介在NATの中で有効なままになります。唯一のクライアントは、それが結合を必要とするどのくらい知っています。要求は応答が送信されなかったために、その接続を介して受信された場合、サーバーは接続を閉じすべきではありません。サーバーは、今までに応答を送信するために戻って、クライアントへの接続を開いてはなりません。サーバーは、過負荷の場合の接続管理に関するベストプラクティスに従ってください。"
    },
    {
      "indent": 0,
      "text": "7.3. Receiving a STUN Message",
      "section_title": true,
      "ja": "7.3。 STUNメッセージを受信しました"
    },
    {
      "indent": 3,
      "text": "This section specifies the processing of a STUN message. The processing specified here is for STUN messages as defined in this specification; additional rules for backwards compatibility are defined in Section 12. Those additional procedures are optional, and usages can elect to utilize them. First, a set of processing operations is applied that is independent of the class. This is followed by class-specific processing, described in the subsections that follow.",
      "ja": "このセクションでは、STUNメッセージの処理を指定します。この仕様で定義され、ここで指定された処理は、STUNメッセージのためです。後方互換性のための追加の規則は、これらの追加の手順はオプションであり、用途にそれらを利用することを選択することができ、セクション12で定義されています。まず、処理動作のセットは、クラスとは無関係であることに適用されます。これは、以下のサブセクションで説明した、クラス固有の処理が続きます。"
    },
    {
      "indent": 3,
      "text": "When a STUN agent receives a STUN message, it first checks that the message obeys the rules of Section 6. It checks that the first two bits are 0, that the magic cookie field has the correct value, that the message length is sensible, and that the method value is a supported method. It checks that the message class is allowed for the particular method. If the message class is \"Success Response\" or \"Error Response\", the agent checks that the transaction ID matches a transaction that is still in progress. If the FINGERPRINT extension is being used, the agent checks that the FINGERPRINT attribute is present and contains the correct value. If any errors are detected, the message is silently discarded. In the case when STUN is being multiplexed with another protocol, an error may indicate that this is not really a STUN message; in this case, the agent should try to parse the message as a different protocol.",
      "ja": "STUNエージェントがメッセージは、セクション6のルールに従うSTUNメッセージ、これは、最初に確認を受信したときにマジッククッキーフィールドは、メッセージの長さが賢明であると、正しい値を有することが、最初の2ビットが0であることを確認し、そしてメソッドの値は、サポートされている方法であること。これは、メッセージクラスは、特定の方法のために許可されていることをチェックします。メッセージクラスは「成功応答」または「エラーレスポンス」である場合、エージェントはトランザクションIDがまだ進行中であるトランザクションと一致することを確認します。 FINGERPRINT拡張が使用されている場合、エージェントは、指紋属性が存在することをチェックし、正しい値を含みます。何らかのエラーが検出された場合、メッセージは静かに捨てられます。 STUNは、別のプロトコルと多重化されている場合には、エラーは、これが本当にSTUNメッセージでないことを示すことができます。この場合、エージェントは異なるプロトコルとしてメッセージを解析してみてください。"
    },
    {
      "indent": 3,
      "text": "The STUN agent then does any checks that are required by a authentication mechanism that the usage has specified (see Section 10).",
      "ja": "STUNエージェントは、使用量は（セクション10を参照）は、指定した認証メカニズムによって必要とされる任意のチェックを行います。"
    },
    {
      "indent": 3,
      "text": "Once the authentication checks are done, the STUN agent checks for unknown attributes and known-but-unexpected attributes in the message. Unknown comprehension-optional attributes MUST be ignored by the agent. Known-but-unexpected attributes SHOULD be ignored by the agent. Unknown comprehension-required attributes cause processing that depends on the message class and is described below.",
      "ja": "認証チェックが完了したら、STUNエージェントがメッセージ内の未知の属性と知られている - しかし、予想外の属性をチェックします。未知の理解 - 任意の属性は、エージェントによって無視されなければなりません。既知の-しかし、予想外の属性はエージェントによって無視されるべきです。未知の理解 - 必要な属性は、メッセージクラスに依存し、以下に説明する処理を引き起こします。"
    },
    {
      "indent": 3,
      "text": "At this point, further processing depends on the message class of the request.",
      "ja": "この時点で、さらなる処理要求のメッセージクラスに依存します。"
    },
    {
      "indent": 0,
      "text": "7.3.1. Processing a Request",
      "section_title": true,
      "ja": "7.3.1。要求の処理"
    },
    {
      "indent": 3,
      "text": "If the request contains one or more unknown comprehension-required attributes, the server replies with an error response with an error code of 420 (Unknown Attribute), and includes an UNKNOWN-ATTRIBUTES attribute in the response that lists the unknown comprehension-required attributes.",
      "ja": "リクエストは、1つまたは複数の未知の理解 - 必要な属性が含まれている場合、サーバは420（未知のアトリビュート）のエラーコードでエラーレスポンスを返信し、UNKNOWN-ATTRIBUTESが未知の理解 - 必要な属性を示し応じて属性を含んでいます。"
    },
    {
      "indent": 3,
      "text": "The server then does any additional checking that the method or the specific usage requires. If all the checks succeed, the server formulates a success response as described below.",
      "ja": "そして、サーバはメソッドや特定の用法が必要とする追加のチェックを行います。すべてのチェックが成功した場合、サーバーは、後述のように成功応答を定式化します。"
    },
    {
      "indent": 3,
      "text": "When run over UDP, a request received by the server could be the first request of a transaction, or a retransmission. The server MUST respond to retransmissions such that the following property is preserved: if the client receives the response to the retransmission and not the response that was sent to the original request, the overall state on the client and server is identical to the case where only the response to the original retransmission is received, or where both responses are received (in which case the client will use the first). The easiest way to meet this requirement is for the server to remember all transaction IDs received over UDP and their corresponding responses in the last 40 seconds. However, this requires the server to hold state, and will be inappropriate for any requests which are not authenticated. Another way is to reprocess the request and recompute the response. The latter technique MUST only be applied to requests that are idempotent (a request is considered idempotent when the same request can be safely repeated without impacting the overall state of the system) and result in the same success response for the same request. The Binding method is considered to be idempotent. Note that there are certain rare network events that could cause the reflexive transport address value to change, resulting in a different mapped address in different success responses. Extensions to STUN MUST discuss the implications of request retransmissions on servers that do not store transaction state.",
      "ja": "UDP上で実行すると、サーバーが受信したリクエストは、トランザクションの最初の要求、または再送信することができます。クライアントが再送信していない元の要求に送信された応答に対する応答を受信した場合、クライアントとサーバー上の全体的な状態は唯一のケースと同じです：サーバーは、次のプロパティが保存されるように、再送信に反応しなければなりません（クライアントが最初に使用されます。その場合に）元の再送に対する応答が受信され、又は両方の応答が受信されます。この要件を満たすための最も簡単な方法は、IDは、最後の40秒でUDPとそれに対応する応答を介して受信したすべてのトランザクションを覚えて、サーバー用です。しかし、これは状態を保持するために、サーバーを必要とし、認証されていないすべての要求には不適切となります。もう一つの方法は、要求を再処理し、応答を再計算することです。後者の技術は、冪等された要求に適用される（要求が同じ要求を安全システムの全体的な状態に影響を与えずに繰り返すことができるべき等と考えられる）と同じ要求に対して同じ成功応答を生じなければなりません。結合方法は、冪等されると考えられます。別の成功応答で異なるマッピングされたアドレスで、その結果、変更するには、再帰の輸送アドレス値を引き起こす可能性があり、特定のまれなネットワークイベントがあることに注意してください。 STUNへの拡張は、トランザクションの状態を保存していないサーバー上の要求の再送信の影響を議論しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1. Forming a Success or Error Response",
      "section_title": true,
      "ja": "7.3.1.1。成功またはエラー応答を構成します"
    },
    {
      "indent": 3,
      "text": "When forming the response (success or error), the server follows the rules of Section 6. The method of the response is the same as that of the request, and the message class is either \"Success Response\" or \"Error Response\".",
      "ja": "応答（成功またはエラー）を形成する場合、サーバは、応答の方法は、要求のものと同じである第6節の規則に従うと、メッセージクラスは「成功応答」または「エラーレスポンス」のいずれかです。"
    },
    {
      "indent": 3,
      "text": "For an error response, the server MUST add an ERROR-CODE attribute containing the error code specified in the processing above. The reason phrase is not fixed, but SHOULD be something suitable for the error code. For certain errors, additional attributes are added to the message. These attributes are spelled out in the description where the error code is specified. For example, for an error code of 420 (Unknown Attribute), the server MUST include an UNKNOWN-ATTRIBUTES attribute. Certain authentication errors also cause attributes to be added (see Section 10). Extensions may define other errors and/or additional attributes to add in error cases.",
      "ja": "エラー応答のために、サーバは、上記の処理で指定されたエラーコードを含むエラーコード属性を追加しなければなりません。理由句は固定ではなく、エラーコードに適したものでなければなりません。特定のエラーの場合は、追加の属性がメッセージに追加されます。これらの属性は、エラーコードが指定されている説明に綴られています。例えば、420のエラーコード（未知の属性）のために、サーバはUNKNOWN-ATTRIBUTES属性含まなければなりません。特定の認証エラーも（セクション10を参照）の属性を追加することが原因。拡張機能は、エラーケースに追加するその他のエラーおよび/または追加の属性を定義することができます。"
    },
    {
      "indent": 3,
      "text": "If the server authenticated the request using an authentication mechanism, then the server SHOULD add the appropriate authentication attributes to the response (see Section 10).",
      "ja": "サーバが認証メカニズムを使用して要求を認証した場合、サーバは適切な認証応答（セクション10を参照）に属性を追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "The server also adds any attributes required by the specific method or usage. In addition, the server SHOULD add a SOFTWARE attribute to the message.",
      "ja": "また、サーバは、特定の方法や使用方法により、必要なすべての属性を追加します。また、サーバーは、メッセージにSOFTWARE属性を追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "For the Binding method, no additional checking is required unless the usage specifies otherwise. When forming the success response, the server adds a XOR-MAPPED-ADDRESS attribute to the response, where the contents of the attribute are the source transport address of the request message. For UDP, this is the source IP address and source UDP port of the request message. For TCP and TLS-over-TCP, this is the source IP address and source TCP port of the TCP connection as seen by the server.",
      "ja": "利用状況に特別な指示がない限りバインド方法については、追加のチェックは必要ありません。成功応答を形成する場合、サーバーは、属性の内容は、要求メッセージの送信元トランスポートアドレスですレスポンスにXOR-MAPPED-ADDRESS属性を追加します。 UDPの場合、これは、要求メッセージの送信元IPアドレスと送信元UDPポートです。 TCPとTLS-over-TCPのために、これは、サーバから見たTCP接続の送信元IPアドレスと送信元TCPポートです。"
    },
    {
      "indent": 0,
      "text": "7.3.1.2. Sending the Success or Error Response",
      "section_title": true,
      "ja": "7.3.1.2。成功またはエラーレスポンスを送信"
    },
    {
      "indent": 3,
      "text": "The response (success or error) is sent over the same transport as the request was received on. If the request was received over UDP, the destination IP address and port of the response are the source IP address and port of the received request message, and the source IP address and port of the response are equal to the destination IP address and port of the received request message. If the request was received over TCP or TLS-over-TCP, the response is sent back on the same TCP connection as the request was received on.",
      "ja": "応答（成功またはエラー）は、要求が受信されたのと同じトランスポートを介して送信されます。要求はUDPを介して受信された場合、宛先IPアドレスと応答のポートは、受信したリクエストメッセージの送信元IPアドレスとポートであり、応答の送信元IPアドレスおよびポート、宛先IPアドレスおよびポートに等しいです受信した要求メッセージ。リクエストがTCPまたはTLS-over-TCPの上で受信された場合は、要求が受信されたとして、応答が同じTCP接続に送り返されます。"
    },
    {
      "indent": 0,
      "text": "7.3.2. Processing an Indication",
      "section_title": true,
      "ja": "7.3.2。表示の処理"
    },
    {
      "indent": 3,
      "text": "If the indication contains unknown comprehension-required attributes, the indication is discarded and processing ceases.",
      "ja": "表示は未知の理解 - 必要な属性が含まれている場合は、表示が破棄され、処理が停止しています。"
    },
    {
      "indent": 3,
      "text": "The agent then does any additional checking that the method or the specific usage requires. If all the checks succeed, the agent then processes the indication. No response is generated for an indication.",
      "ja": "エージェントは、メソッドや特定の用法が必要とする追加のチェックを行います。すべてのチェックが成功した場合、エージェントは通知を処理します。応答が表示のために生成されません。"
    },
    {
      "indent": 3,
      "text": "For the Binding method, no additional checking or processing is required, unless the usage specifies otherwise. The mere receipt of the message by the agent has refreshed the \"bindings\" in the intervening NATs.",
      "ja": "用法が別段指定しない限り、結合方法のために、追加のチェックまたは処理が必要とされません。エージェントによるメッセージの単なる受信は、介在するNATの中で「バインディング」をリフレッシュしています。"
    },
    {
      "indent": 3,
      "text": "Since indications are not re-transmitted over UDP (unlike requests), there is no need to handle re-transmissions of indications at the sending agent.",
      "ja": "適応症は、（要求とは異なり）UDP上で再送信されていないので、送信エージェントでの適応症の再送信を処理する必要はありません。"
    },
    {
      "indent": 0,
      "text": "7.3.3. Processing a Success Response",
      "section_title": true,
      "ja": "7.3.3。成功レスポンスの処理"
    },
    {
      "indent": 3,
      "text": "If the success response contains unknown comprehension-required attributes, the response is discarded and the transaction is considered to have failed.",
      "ja": "成功応答が未知の理解 - 必要な属性が含まれている場合は、応答が破棄され、トランザクションが失敗したと考えられています。"
    },
    {
      "indent": 3,
      "text": "The client then does any additional checking that the method or the specific usage requires. If all the checks succeed, the client then processes the success response.",
      "ja": "次に、クライアントはメソッドや特定の用法が必要とする追加のチェックを行います。すべてのチェックが成功した場合、クライアントは、成功応答を処理します。"
    },
    {
      "indent": 3,
      "text": "For the Binding method, the client checks that the XOR-MAPPED-ADDRESS attribute is present in the response. The client checks the address family specified. If it is an unsupported address family, the attribute SHOULD be ignored. If it is an unexpected but supported address family (for example, the Binding transaction was sent over IPv4, but the address family specified is IPv6), then the client MAY accept and use the value.",
      "ja": "結合方法のために、クライアントは、XORマッピングされたアドレス属性が応答中に存在することをチェックします。クライアントは、指定されたアドレスファミリをチェックします。それがサポートされていないアドレスファミリーである場合、属性は無視されるべきです。それは予期しないが、サポートされるアドレスファミリである場合（例えば、結合トランザクションはIPv4の上で送信されますが、指定されたアドレスファミリーがIPv6でいた）、その後、クライアントは値を受け入れ、使用するかもしれません。"
    },
    {
      "indent": 0,
      "text": "7.3.4. Processing an Error Response",
      "section_title": true,
      "ja": "7.3.4。エラー応答を処理"
    },
    {
      "indent": 3,
      "text": "If the error response contains unknown comprehension-required attributes, or if the error response does not contain an ERROR-CODE attribute, then the transaction is simply considered to have failed.",
      "ja": "エラーレスポンスがERROR-CODE属性が含まれていない場合は、エラーレスポンスが未知の理解 - 必要な属性が含まれている場合、または、そのトランザクションは、単純に失敗したと考えられています。"
    },
    {
      "indent": 3,
      "text": "The client then does any processing specified by the authentication mechanism (see Section 10). This may result in a new transaction attempt.",
      "ja": "次に、クライアントは認証機構（セクション10を参照）で指定した任意の処理を行います。これは、新しいトランザクションの試みになることがあります。"
    },
    {
      "indent": 3,
      "text": "The processing at this point depends on the error code, the method, and the usage; the following are the default rules:",
      "ja": "この時点での処理は、エラーコード、方法、および使用方法に依存します。以下は、デフォルトのルールです："
    },
    {
      "indent": 3,
      "text": "o If the error code is 300 through 399, the client SHOULD consider the transaction as failed unless the ALTERNATE-SERVER extension is being used. See Section 11.",
      "ja": "エラーコードが399を通じて300の場合は失敗したとALTERNATE-SERVER拡張子が使用されていない限り、O、クライアントがトランザクションを検討すべきです。セクション11を参照してください。"
    },
    {
      "indent": 3,
      "text": "o If the error code is 400 through 499, the client declares the transaction failed; in the case of 420 (Unknown Attribute), the response should contain a UNKNOWN-ATTRIBUTES attribute that gives additional information.",
      "ja": "エラーコードが499を通じて400の場合は、O、クライアントは、失敗したトランザクションを宣言します。 420（未知のアトリビュート）の場合には、応答はUNKNOWN-ATTRIBUTESは、それが付加的な情報を与える属性含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the error code is 500 through 599, the client MAY resend the request; clients that do so MUST limit the number of times they do this.",
      "ja": "エラーコードが599を通じて500の場合は、O、クライアントが要求を再送信してもよい（MAY）。そうするクライアントは、彼らがこれを行う回数を制限しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Any other error code causes the client to consider the transaction failed.",
      "ja": "その他のエラーコードは、トランザクションを検討するために、クライアントが失敗した原因となります。"
    },
    {
      "indent": 0,
      "text": "8. FINGERPRINT Mechanism",
      "section_title": true,
      "ja": "8. FINGERPRINTメカニズム"
    },
    {
      "indent": 3,
      "text": "This section describes an optional mechanism for STUN that aids in distinguishing STUN messages from packets of other protocols when the two are multiplexed on the same transport address. This mechanism is optional, and a STUN usage must describe if and when it is used. The FINGERPRINT mechanism is not backwards compatible with RFC 3489, and cannot be used in environments where such compatibility is required.",
      "ja": "このセクションでは、2つが同じトランスポートアドレスに多重化される場合、他のプロトコルのパケットから区別STUNメッセージを助けるSTUNのための任意のメカニズムを説明しています。このメカニズムはオプションであり、そしてそれを使用する場合STUNの使用率があれば記述しなければなりません。 FINGERPRINTメカニズムは、RFC 3489との下位互換性がありません、そのような互換性が要求される環境で使用することができません。"
    },
    {
      "indent": 3,
      "text": "In some usages, STUN messages are multiplexed on the same transport address as other protocols, such as the Real Time Transport Protocol (RTP). In order to apply the processing described in Section 7, STUN messages must first be separated from the application packets.",
      "ja": "いくつかの用途では、STUNメッセージは、リアルタイムトランスポートプロトコル（RTP）など、他のプロトコルと同じトランスポートアドレスに多重化されています。セクション7で説明した処理を適用するために、STUNメッセージは、最初のアプリケーションパケットから分離されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Section 6 describes three fixed fields in the STUN header that can be used for this purpose. However, in some cases, these three fixed fields may not be sufficient.",
      "ja": "セクション6は、この目的のために使用することができるSTUNヘッダーの3つの固定フィールドを記述する。しかし、いくつかのケースでは、これら3つの固定フィールドは十分ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "When the FINGERPRINT extension is used, an agent includes the FINGERPRINT attribute in messages it sends to another agent. Section 15.5 describes the placement and value of this attribute. When the agent receives what it believes is a STUN message, then, in addition to other basic checks, the agent also checks that the message contains a FINGERPRINT attribute and that the attribute contains the correct value. Section 7.3 describes when in the overall processing of a STUN message the FINGERPRINT check is performed. This additional check helps the agent detect messages of other protocols that might otherwise seem to be STUN messages.",
      "ja": "FINGERPRINT拡張が使用されている場合は、エージェントは、別のエージェントに送信するメッセージでFINGERPRINT属性を含んでいます。 15.5節では、この属性の配置と値について説明します。エージェントは、STUNメッセージが何であるか、それは信じて受信すると、他の基本的なチェックに加えて、エージェントは、メッセージがFINGERPRINT属性が含まれていることと、属性が正しい値が含まれていることを確認します。 STUNメッセージの全体的な処理でFINGERPRINTチェックが実行されたときセクション7.3で説明しています。この追加のチェックは、エージェントがそうでないSTUNメッセージであるように見えるかもしれない他のプロトコルのメッセージを検出するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "9. DNS Discovery of a Server",
      "section_title": true,
      "ja": "サーバーのDNS 9.発見"
    },
    {
      "indent": 3,
      "text": "This section describes an optional procedure for STUN that allows a client to use DNS to determine the IP address and port of a server. A STUN usage must describe if and when this extension is used. To use this procedure, the client must know a server's domain name and a service name; the usage must also describe how the client obtains these. Hard-coding the domain name of the server into software is NOT RECOMMENDED in case the domain name is lost or needs to change for legal or other reasons.",
      "ja": "このセクションでは、クライアントがサーバーのIPアドレスとポートを決定するためにDNSを使用することができますSTUNのためのオプションの手順を説明します。この拡張機能を使用する場合STUNの使用率があれば記述しなければなりません。この手順を使用するには、クライアントは、サーバのドメイン名とサービス名を知っている必要があります。使用方法は、クライアントがこれらを取得する方法を記述しなければなりません。ドメイン名が失われたり、法的またはその他の理由で変更する必要がある場合にはソフトウェアにサーバーのドメイン名をハードコーディングすることはお勧めしません。"
    },
    {
      "indent": 3,
      "text": "When a client wishes to locate a STUN server in the public Internet that accepts Binding request/response transactions, the SRV service name is \"stun\". When it wishes to locate a STUN server that accepts Binding request/response transactions over a TLS session, the SRV service name is \"stuns\". STUN usages MAY define additional DNS SRV service names.",
      "ja": "クライアントがバインディングリクエスト/レスポンストランザクションを受け入れ、公共のインターネットでSTUNサーバーを見つけるしたい場合は、SRVサービス名は、「スタン」です​​。それはTLSセッション上での要求/応答トランザクションをバインド受け入れるSTUNサーバーを見つけるしたい場合は、SRVサービス名は、「スタン」です​​。 STUN用法は、追加のDNS SRVサービス名を定義することができます。"
    },
    {
      "indent": 3,
      "text": "The domain name is resolved to a transport address using the SRV procedures specified in [RFC2782]. The DNS SRV service name is the service name provided as input to this procedure. The protocol in the SRV lookup is the transport protocol the client will run STUN over: \"udp\" for UDP and \"tcp\" for TCP. Note that only \"tcp\" is defined with \"stuns\" at this time.",
      "ja": "ドメイン名は、[RFC2782]で指定されたSRV手順を使用してトランスポート・アドレスに解決されます。 DNSのSRVサービス名は、この手順への入力として提供されるサービス名です。 UDPとTCPのための「TCP」を「UDP」：SRVルックアップでのプロトコルは、クライアントが上でSTUNを実行するトランスポートプロトコルです。唯一の「TCP」は、この時点で「スタン」と定義されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The procedures of RFC 2782 are followed to determine the server to contact. RFC 2782 spells out the details of how a set of SRV records is sorted and then tried. However, RFC 2782 only states that the client should \"try to connect to the (protocol, address, service)\" without giving any details on what happens in the event of failure. When following these procedures, if the STUN transaction times out without receipt of a response, the client SHOULD retry the request to the next server in the ordered defined by RFC 2782. Such a retry is only possible for request/response transmissions, since indication transactions generate no response or timeout.",
      "ja": "RFC 2782の手順は連絡するサーバーを決定するために続いています。 RFC 2782は、SRVレコードのセットをソートし、次に試される方法の詳細を綴ります。ただし、RFC 2782には、クライアントだけが障害が発生した場合に何が起こるか上の任意の詳細を与えることなく「（プロトコル、アドレス、サービス）に接続しよう」すべきであると述べています。これらの手順を以下の場合は、アウトSTUNのトランザクション時間応答の受信がなければ、クライアントは内の次のサーバに要求を再試行すべきである2782.このような再試行が表示取引いるので、リクエスト/レスポンスの送信のためにのみ可能であるRFCで定義された注文無応答またはタイムアウトを生成しません。"
    },
    {
      "indent": 3,
      "text": "The default port for STUN requests is 3478, for both TCP and UDP.",
      "ja": "STUN要求のデフォルトポートはTCPとUDPの両方のために、3478です。"
    },
    {
      "indent": 3,
      "text": "Administrators of STUN servers SHOULD use this port in their SRV records for UDP and TCP. In all cases, the port in DNS MUST reflect the one on which the server is listening. The default port for STUN over TLS is 5349. Servers can run STUN over TLS on the same port as STUN over TCP if the server software supports determining whether the initial message is a TLS or STUN message.",
      "ja": "STUNサーバの管理者は、UDPとTCPのための彼らのSRVレコードでこのポートを使用すべきです。すべての場合において、DNSのポートは、サーバーがリッスンしているものを反映しなければなりません。 TLS経由STUNのデフォルトポートは、サーバー・ソフトウェアが最初のメッセージがTLSまたはSTUNメッセージであるかどうかを判断するサポートしている場合は5349.サーバーはTCP上でSTUNと同じポートでTLS上でSTUNを実行することができます。"
    },
    {
      "indent": 3,
      "text": "If no SRV records were found, the client performs an A or AAAA record lookup of the domain name. The result will be a list of IP addresses, each of which can be contacted at the default port using UDP or TCP, independent of the STUN usage. For usages that require TLS, the client connects to one of the IP addresses using the default STUN over TLS port.",
      "ja": "何のSRVレコードが見つからなかった場合、クライアントは、ドメイン名のAまたはAAAAレコードのルックアップを実行します。結果は、STUN用法の独立したUDPまたはTCPを使用して、デフォルトのポートで接触させることができるそれぞれのIPアドレスのリストになります。 TLSを必要とする用途には、クライアントはTLSポート経由のデフォルトSTUNを使用してIPアドレスの1つに接続します。"
    },
    {
      "indent": 0,
      "text": "10. Authentication and Message-Integrity Mechanisms",
      "section_title": true,
      "ja": "10.認証とメッセージ整合性メカニズム"
    },
    {
      "indent": 3,
      "text": "This section defines two mechanisms for STUN that a client and server can use to provide authentication and message integrity; these two mechanisms are known as the short-term credential mechanism and the long-term credential mechanism. These two mechanisms are optional, and each usage must specify if and when these mechanisms are used. Consequently, both clients and servers will know which mechanism (if any) to follow based on knowledge of which usage applies. For example, a STUN server on the public Internet supporting ICE would have no authentication, whereas the STUN server functionality in an agent supporting connectivity checks would utilize short-term credentials. An overview of these two mechanisms is given in Section 3.",
      "ja": "このセクションでは、クライアントとサーバが認証とメッセージ整合性を提供するために使用できるSTUNのための2つのメカニズムを定義します。これらの二つの機構が短期資格機構と長期資格機構として知られています。これら2つのメカニズムがオプションであり、これらのメカニズムが使用される場合ならば、それぞれの使用量が指定しなければなりません。そのため、クライアントとサーバの両方が使用法が適用されるの知識に基づいて従うためにどのメカニズム（もしあれば）を知っているだろう。接続性チェックをサポートするエージェントでSTUNサーバ機能は、短期的な資格証明書を利用することになるのに対し、例えば、ICEをサポートしている公共のインターネット上のSTUNサーバーは、何の認証を持っていないだろう。これら二つのメカニズムの概要は、第3節で与えられています。"
    },
    {
      "indent": 3,
      "text": "Each mechanism specifies the additional processing required to use that mechanism, extending the processing specified in Section 7. The additional processing occurs in three different places: when forming a message, when receiving a message immediately after the basic checks have been performed, and when doing the detailed processing of error responses.",
      "ja": "実行時にメッセージを形成するときに、メッセージを受信した場合、基本的なチェックが行われた直後、及び各機構は、3つの異なる場所で追加の処理が発生し、セクション7で指定された処理を拡張、その機構を使用するために必要な追加の処理を指定しますエラー応答の詳細な処理。"
    },
    {
      "indent": 0,
      "text": "10.1. Short-Term Credential Mechanism",
      "section_title": true,
      "ja": "10.1。短期資格メカニズム"
    },
    {
      "indent": 3,
      "text": "The short-term credential mechanism assumes that, prior to the STUN transaction, the client and server have used some other protocol to exchange a credential in the form of a username and password. This credential is time-limited. The time limit is defined by the usage.",
      "ja": "短期資格情報メカニズムは、STUNトランザクション、クライアントとサーバの前には、ユーザー名とパスワードの形式で資格情報を交換するために、いくつかの他のプロトコルを使用している、ということを前提としています。この資格は、時間が限られています。制限時間は、使用することによって定義されます。"
    },
    {
      "indent": 3,
      "text": "As an example, in the ICE usage [MMUSIC-ICE], the two endpoints use out-of-band signaling to agree on a username and password, and this username and password are applicable for the duration of the media session.",
      "ja": "例として、ICE用法[MMUSIC-ICE]で、2つのエンドポイントは、ユーザー名とパスワードに同意するシグナリングをアウト・オブ・バンドを使用し、このユーザ名とパスワードは、メディアセッションの間に適用されます。"
    },
    {
      "indent": 3,
      "text": "This credential is used to form a message-integrity check in each request and in many responses. There is no challenge and response as in the long-term mechanism; consequently, replay is prevented by virtue of the time-limited nature of the credential.",
      "ja": "この資格は、各要求で、多くの応答のメッセージ完全性チェックを形成するために使用されます。何の挑戦と長期的なメカニズムのような応答がありません。従って、リプレイは資格の時限性質によって防止されます。"
    },
    {
      "indent": 0,
      "text": "10.1.1. Forming a Request or Indication",
      "section_title": true,
      "ja": "10.1.1。要求や指示を形成します"
    },
    {
      "indent": 3,
      "text": "For a request or indication message, the agent MUST include the USERNAME and MESSAGE-INTEGRITY attributes in the message. The HMAC for the MESSAGE-INTEGRITY attribute is computed as described in Section 15.4. Note that the password is never included in the request or indication.",
      "ja": "要求又は指示メッセージのために、薬剤は、USERNAMEとMESSAGE-INTEGRITYはメッセージの属性を含まなければなりません。 15.4節で説明したようにMESSAGE-INTEGRITY属性のHMACが計算されます。パスワードが要求または表示に含まれないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "10.1.2. Receiving a Request or Indication",
      "section_title": true,
      "ja": "10.1.2。要求や指示を受け取ります"
    },
    {
      "indent": 3,
      "text": "After the agent has done the basic processing of a message, the agent performs the checks listed below in order specified:",
      "ja": "エージェントは、メッセージの基本的な処理を行った後、エージェントは指定された順序で下記のチェックを実行します。"
    },
    {
      "indent": 3,
      "text": "o If the message does not contain both a MESSAGE-INTEGRITY and a USERNAME attribute:",
      "ja": "OメッセージはMESSAGE-INTEGRITYとUSERNAME属性の両方が含まれていない場合："
    },
    {
      "indent": 6,
      "text": "* If the message is a request, the server MUST reject the request with an error response. This response MUST use an error code of 400 (Bad Request).",
      "ja": "*メッセージがリクエストである場合、サーバはエラー応答で要求を拒絶しなければなりません。この応答は400（不正なリクエスト）のエラーコードを使用しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the message is an indication, the agent MUST silently discard the indication.",
      "ja": "*メッセージが表示された場合、エージェントは静かに表示を捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the USERNAME does not contain a username value currently valid within the server:",
      "ja": "O USERNAMEは、サーバー内で現在有効なユーザ名の値が含まれていない場合："
    },
    {
      "indent": 6,
      "text": "* If the message is a request, the server MUST reject the request with an error response. This response MUST use an error code of 401 (Unauthorized).",
      "ja": "*メッセージがリクエストである場合、サーバはエラー応答で要求を拒絶しなければなりません。この応答は401（不正）のエラーコードを使用しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the message is an indication, the agent MUST silently discard the indication.",
      "ja": "*メッセージが表示された場合、エージェントは静かに表示を捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Using the password associated with the username, compute the value for the message integrity as described in Section 15.4. If the resulting value does not match the contents of the MESSAGE-INTEGRITY attribute:",
      "ja": "15.4節で説明したように、ユーザ名に関連付けられたパスワードを使用してO、メッセージの整合性の値を計算します。結果の値はMESSAGE-INTEGRITYアトリビュートの内容と一致しない場合："
    },
    {
      "indent": 6,
      "text": "* If the message is a request, the server MUST reject the request with an error response. This response MUST use an error code of 401 (Unauthorized).",
      "ja": "*メッセージがリクエストである場合、サーバはエラー応答で要求を拒絶しなければなりません。この応答は401（不正）のエラーコードを使用しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the message is an indication, the agent MUST silently discard the indication.",
      "ja": "*メッセージが表示された場合、エージェントは静かに表示を捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "If these checks pass, the agent continues to process the request or indication. Any response generated by a server MUST include the MESSAGE-INTEGRITY attribute, computed using the password utilized to authenticate the request. The response MUST NOT contain the USERNAME attribute.",
      "ja": "これらのチェックに合格した場合、エージェントは、要求又は指示を処理し続けます。サーバによって生成された応答がMESSAGE-INTEGRITYアトリビュートを含まなければならない、要求を認証するために利用するパスワードを使用して計算。レスポンスはUSERNAME属性を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "If any of the checks fail, a server MUST NOT include a MESSAGE-INTEGRITY or USERNAME attribute in the error response. This is because, in these failure cases, the server cannot determine the shared secret necessary to compute MESSAGE-INTEGRITY.",
      "ja": "いずれかのチェックが失敗した場合、サーバはエラーレスポンスにMESSAGE-INTEGRITYもしくはUSERNAME属性を含んではいけません。これらの障害の場合には、サーバがMESSAGE-INTEGRITYを計算するために必要な共有秘密を判断できないためです。"
    },
    {
      "indent": 0,
      "text": "10.1.3. Receiving a Response",
      "section_title": true,
      "ja": "10.1.3。応答を受信します"
    },
    {
      "indent": 3,
      "text": "The client looks for the MESSAGE-INTEGRITY attribute in the response. If present, the client computes the message integrity over the response as defined in Section 15.4, using the same password it utilized for the request. If the resulting value matches the contents of the MESSAGE-INTEGRITY attribute, the response is considered authenticated. If the value does not match, or if MESSAGE-INTEGRITY was absent, the response MUST be discarded, as if it was never received. This means that retransmits, if applicable, will continue.",
      "ja": "クライアントが応答したMESSAGE-INTEGRITYアトリビュートを探します。それが要求するために利用さと同じパスワードを使用して、15.4節に定義されるように存在する場合、クライアントは応答を介したメッセージの整合性を計算します。結果の値がMESSAGE-INTEGRITYアトリビュートの内容と一致する場合、応答は認証と考えられています。値が一致しない場合、またはMESSAGE-INTEGRITYが不在だった場合、それが受信されなかったかのように、応答は、捨てなければなりません。これは、該当する場合再送は、継続することを意味します。"
    },
    {
      "indent": 0,
      "text": "10.2. Long-Term Credential Mechanism",
      "section_title": true,
      "ja": "10.2。長期資格メカニズム"
    },
    {
      "indent": 3,
      "text": "The long-term credential mechanism relies on a long-term credential, in the form of a username and password that are shared between client and server. The credential is considered long-term since it is assumed that it is provisioned for a user, and remains in effect until the user is no longer a subscriber of the system, or is changed. This is basically a traditional \"log-in\" username and password given to users.",
      "ja": "長期資格情報メカニズムは、クライアントとサーバの間で共有されているユーザ名とパスワードの形で、長期的な資格情報に依存しています。信任状は、ユーザーにプロビジョニングされていることを想定しているため、長期的に考えられ、そしてユーザは、もはやシステムの加入者であるか、または変更されるまで有効のままされていません。これは、基本的には、ユーザーに与えられた伝統的な「ログイン中」のユーザー名とパスワードです。"
    },
    {
      "indent": 3,
      "text": "Because these usernames and passwords are expected to be valid for extended periods of time, replay prevention is provided in the form of a digest challenge. In this mechanism, the client initially sends a request, without offering any credentials or any integrity checks. The server rejects this request, providing the user a realm (used to guide the user or agent in selection of a username and password) and a nonce. The nonce provides the replay protection. It is a cookie, selected by the server, and encoded in such a way as to indicate a duration of validity or client identity from which it is valid. The client retries the request, this time including its username and the realm, and echoing the nonce provided by the server. The client also includes a message-integrity, which provides an HMAC over the entire request, including the nonce. The server validates the nonce and checks the message integrity. If they match, the request is authenticated. If the nonce is no longer valid, it is considered \"stale\", and the server rejects the request, providing a new nonce.",
      "ja": "これらのユーザ名とパスワードは、長時間有効であると期待されているので、リプレイ防止がダイジェスト挑戦の形で提供されます。このメカニズムでは、クライアントは、最初に任意の資格情報または任意の整合性チェックを提供せずに、要求を送信します。サーバは、ユーザ（ユーザ名とパスワードを選択する際に、ユーザまたはエージェントを導くために使用される）領域とナンスを提供し、この要求を拒否します。ナンスはリプレイ保護を提供します。これは、サーバーによって選択された、クッキーであり、それが有効であるから、有効性やクライアントのアイデンティティの期間を示すような方法でエンコードされました。クライアントは、要求、そのユーザ名とレルム、およびサーバによって提供さナンスをエコーを含め、この時間を再試行します。クライアントはまたノンスを含む、要求全体にわたってHMACを提供するメッセージの完全性を、含みます。サーバは、nonceを検証し、メッセージの整合性をチェックします。それらが一致する場合は、要求が認証されます。ナンスがもはや有効でない場合は、「古くなった」とみなされ、サーバが新しいナンスを提供し、要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "In subsequent requests to the same server, the client reuses the nonce, username, realm, and password it used previously. In this way, subsequent requests are not rejected until the nonce becomes invalid by the server, in which case the rejection provides a new nonce to the client.",
      "ja": "同じサーバーに後続の要求では、クライアントは、それが以前に使用したnonce、ユーザ名、レルムおよびパスワードを再利用します。ナンスは、拒絶は、クライアントに新しいnonceを提供し、その場合には、サーバ、によって無効になるまで、このように、後続の要求は拒否されていません。"
    },
    {
      "indent": 3,
      "text": "Note that the long-term credential mechanism cannot be used to protect indications, since indications cannot be challenged. Usages utilizing indications must either use a short-term credential or omit authentication and message integrity for them.",
      "ja": "兆候が挑戦することができないため、長期的な資格情報メカニズムは、表示を保護するために使用することはできないことに注意してください。適応症を利用用途は、短期的な資格情報を使用するか、またはそれらのための認証とメッセージの整合性を省く必要があります。"
    },
    {
      "indent": 3,
      "text": "Since the long-term credential mechanism is susceptible to offline dictionary attacks, deployments SHOULD utilize passwords that are difficult to guess. In cases where the credentials are not entered by the user, but are rather placed on a client device during device provisioning, the password SHOULD have at least 128 bits of randomness. In cases where the credentials are entered by the user, they should follow best current practices around password structure.",
      "ja": "長期資格情報メカニズムは、オフライン辞書攻撃を受けやすいので、展開は推測しにくいパスワードを利用すべきです。認証情報がユーザによって入力されず、むしろデバイスのプロビジョニングの間、クライアントデバイス上に配置されている場合には、パスワードは、ランダム性の少なくとも128ビットを有するべきです。資格情報がユーザーによって入力された場合には、彼らはパスワード構造周りの最高の現在のプラクティスに従ってください。"
    },
    {
      "indent": 0,
      "text": "10.2.1. Forming a Request",
      "section_title": true,
      "ja": "10.2.1。リクエストを形成します"
    },
    {
      "indent": 3,
      "text": "There are two cases when forming a request. In the first case, this is the first request from the client to the server (as identified by its IP address and port). In the second case, the client is submitting a subsequent request once a previous request/response transaction has completed successfully. Forming a request as a consequence of a 401 or 438 error response is covered in Section 10.2.3 and is not considered a \"subsequent request\" and thus does not utilize the rules described in Section 10.2.1.2.",
      "ja": "リクエストを形成する際に2つのケースがあります。最初のケースでは、これは、クライアントからサーバへの最初の要求（そのIPアドレスとポートで識別される）です。後者の場合、クライアントは、一度前の要求/応答トランザクションが正常に完了した後続の要求を提出しています。 401または438エラー応答の結果として要求を形成することは、セクション10.2.3に覆われており、「後続リクエスト」とは見なされないので、セクション10.2.1.2に記載されたルールを利用しません。"
    },
    {
      "indent": 0,
      "text": "10.2.1.1. First Request",
      "section_title": true,
      "ja": "10.2.1.1。最初のリクエスト"
    },
    {
      "indent": 3,
      "text": "If the client has not completed a successful request/response transaction with the server (as identified by hostname, if the DNS procedures of Section 9 are used, else IP address if not), it SHOULD omit the USERNAME, MESSAGE-INTEGRITY, REALM, and NONCE attributes. In other words, the very first request is sent as if there were no authentication or message integrity applied.",
      "ja": "クライアントがサーバーと成功の要求/応答トランザクションを完了していない場合（ホスト名によって識別される、第9章のDNS手順は、他のIPアドレスではない場合に使用されている場合）、それは、USERNAME、MESSAGE-INTEGRITY、REALMを省略すべきですそしてNONCE属性。適用されていない認証やメッセージ整合性がなかったかのように換言すれば、非常に最初のリクエストが送信されます。"
    },
    {
      "indent": 0,
      "text": "10.2.1.2. Subsequent Requests",
      "section_title": true,
      "ja": "10.2.1.2。後続の要求"
    },
    {
      "indent": 3,
      "text": "Once a request/response transaction has completed successfully, the client will have been presented a realm and nonce by the server, and selected a username and password with which it authenticated. The client SHOULD cache the username, password, realm, and nonce for subsequent communications with the server. When the client sends a subsequent request, it SHOULD include the USERNAME, REALM, and NONCE attributes with these cached values. It SHOULD include a MESSAGE-INTEGRITY attribute, computed as described in Section 15.4 using the cached password.",
      "ja": "要求/応答トランザクションが正常に完了すると、クライアントは、サーバによって、レルムとナンスを提示し、それが認証されるユーザ名とパスワードを選択されています。クライアントは、サーバーとのその後の通信のためのユーザ名、パスワード、領域、およびnonceをキャッシュします。クライアントは、後続の要求を送信すると、それはUSERNAME、REALMを含むべきである、とNONCEは、これらのキャッシュされた値を持つ属性。これは、キャッシュされたパスワードを使用して、15.4節で説明したように計算されたMESSAGE-INTEGRITYアトリビュートを、含むべきです。"
    },
    {
      "indent": 0,
      "text": "10.2.2. Receiving a Request",
      "section_title": true,
      "ja": "10.2.2。要求を受信しました"
    },
    {
      "indent": 3,
      "text": "After the server has done the basic processing of a request, it performs the checks listed below in the order specified:",
      "ja": "サーバは、要求の基本的な処理を行った後、指定された順序で下記のチェックを実行します。"
    },
    {
      "indent": 3,
      "text": "o If the message does not contain a MESSAGE-INTEGRITY attribute, the server MUST generate an error response with an error code of 401 (Unauthorized). This response MUST include a REALM value. It is RECOMMENDED that the REALM value be the domain name of the provider of the STUN server. The response MUST include a NONCE, selected by the server. The response SHOULD NOT contain a USERNAME or MESSAGE-INTEGRITY attribute.",
      "ja": "メッセージはMESSAGE-INTEGRITYアトリビュートが含まれていない場合は、O、サーバは401（無許可）のエラーコードでエラーレスポンスを生成しなければなりません。この応答はREALM値を含まなければなりません。 REALM値がSTUNサーバのプロバイダーのドメイン名であることが推奨されます。応答は、サーバによって選択されたNONCEを含まなければなりません。レスポンスはUSERNAMEまたはMESSAGE-INTEGRITY属性を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "o If the message contains a MESSAGE-INTEGRITY attribute, but is missing the USERNAME, REALM, or NONCE attribute, the server MUST generate an error response with an error code of 400 (Bad Request). This response SHOULD NOT include a USERNAME, NONCE, REALM, or MESSAGE-INTEGRITY attribute.",
      "ja": "メッセージはMESSAGE-INTEGRITYアトリビュートが含まれていますが、USERNAME、REALM、またはNONCE属性が欠落している場合は、O、サーバは400（不正なリクエスト）のエラーコードでエラーレスポンスを生成しなければなりません。この応答はUSERNAME、NONCE、REALM、またはMESSAGE-INTEGRITYアトリビュートを含めるべきではありません。"
    },
    {
      "indent": 3,
      "text": "o If the NONCE is no longer valid, the server MUST generate an error response with an error code of 438 (Stale Nonce). This response MUST include NONCE and REALM attributes and SHOULD NOT include the USERNAME or MESSAGE-INTEGRITY attribute. Servers can invalidate nonces in order to provide additional security. See Section 4.3 of [RFC2617] for guidelines.",
      "ja": "NONCEがもはや有効であればO、サーバは438（古いナンス）のエラーコードでエラーレスポンスを生成してはなりません。この応答は、NONCEとREALM属性を含まなければならないとUSERNAMEまたはMESSAGE-INTEGRITYアトリビュートを含めるべきではありません。サーバーは、追加のセキュリティを提供するためにナンスを無効にすることができます。ガイドラインについては、[RFC2617]のセクション4.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "o If the username in the USERNAME attribute is not valid, the server MUST generate an error response with an error code of 401 (Unauthorized). This response MUST include a REALM value. It is RECOMMENDED that the REALM value be the domain name of the provider of the STUN server. The response MUST include a NONCE, selected by the server. The response SHOULD NOT contain a USERNAME or MESSAGE-INTEGRITY attribute.",
      "ja": "USERNAME属性にユーザ名が有効でない場合は、O、サーバは401（無許可）のエラーコードでエラーレスポンスを生成しなければなりません。この応答はREALM値を含まなければなりません。 REALM値がSTUNサーバのプロバイダーのドメイン名であることが推奨されます。応答は、サーバによって選択されたNONCEを含まなければなりません。レスポンスはUSERNAMEまたはMESSAGE-INTEGRITY属性を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "o Using the password associated with the username in the USERNAME attribute, compute the value for the message integrity as described in Section 15.4. If the resulting value does not match the contents of the MESSAGE-INTEGRITY attribute, the server MUST reject the request with an error response. This response MUST use an error code of 401 (Unauthorized). It MUST include REALM and NONCE attributes and SHOULD NOT include the USERNAME or MESSAGE-INTEGRITY attribute.",
      "ja": "15.4節で説明したようにUSERNAME属性にユーザ名に関連付けられたパスワードを使用してO、メッセージの整合性の値を計算します。結果の値がMESSAGE-INTEGRITYアトリビュートの内容と一致しない場合、サーバはエラー応答で要求を拒絶しなければなりません。この応答は401（不正）のエラーコードを使用しなければなりません。それはREALMとNONCE属性を含まなければならないとUSERNAMEまたはMESSAGE-INTEGRITY属性を含んではなりません。"
    },
    {
      "indent": 3,
      "text": "If these checks pass, the server continues to process the request. Any response generated by the server (excepting the cases described above) MUST include the MESSAGE-INTEGRITY attribute, computed using the username and password utilized to authenticate the request. The REALM, NONCE, and USERNAME attributes SHOULD NOT be included.",
      "ja": "これらのチェックに合格した場合、サーバーは要求を処理し続けます。 （上記の場合以外）サーバによって生成された応答は、要求を認証するために利用されるユーザ名とパスワードを使用して計算されたMESSAGE-INTEGRITY属性を含まなければなりません。 REALM、NONCE、およびUSERNAME属性が含まれるべきではありません。"
    },
    {
      "indent": 0,
      "text": "10.2.3. Receiving a Response",
      "section_title": true,
      "ja": "10.2.3。応答を受信します"
    },
    {
      "indent": 3,
      "text": "If the response is an error response with an error code of 401 (Unauthorized), the client SHOULD retry the request with a new transaction. This request MUST contain a USERNAME, determined by the client as the appropriate username for the REALM from the error response. The request MUST contain the REALM, copied from the error response. The request MUST contain the NONCE, copied from the error response. The request MUST contain the MESSAGE-INTEGRITY attribute, computed using the password associated with the username in the USERNAME attribute. The client MUST NOT perform this retry if it is not changing the USERNAME or REALM or its associated password, from the previous attempt.",
      "ja": "応答が401（無許可）のエラーコードでエラーレスポンスである場合、クライアントは新しいトランザクションでリクエストを再試行する必要があります。このリクエストはエラーレスポンスからREALMのための適切なユーザ名としてクライアントによって決定USERNAMEを含まなければなりません。リクエストはエラーレスポンスからコピーREALMを含まなければなりません。リクエストはエラーレスポンスからコピーされたNONCEを含まなければなりません。リクエストがMESSAGE-INTEGRITYアトリビュートを含まなければならない、USERNAME属性にユーザ名に関連付けられたパスワードを使用して計算。それは前の試行から、USERNAMEまたはREALMまたはそれに関連付けられたパスワードを変更されていない場合、クライアントはこの再試行を実行してはなりません。"
    },
    {
      "indent": 3,
      "text": "If the response is an error response with an error code of 438 (Stale Nonce), the client MUST retry the request, using the new NONCE supplied in the 438 (Stale Nonce) response. This retry MUST also include the USERNAME, REALM, and MESSAGE-INTEGRITY.",
      "ja": "応答が438（古いナンス）のエラーコードでエラー応答である場合、クライアント438（古いナンス）応答して供給される新たなnonceを使用して、要求を再試行しなければなりません。この再試行はまた、USERNAME、REALM、およびMESSAGE-INTEGRITYを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client looks for the MESSAGE-INTEGRITY attribute in the response (either success or failure). If present, the client computes the message integrity over the response as defined in Section 15.4, using the same password it utilized for the request. If the resulting value matches the contents of the MESSAGE-INTEGRITY attribute, the response is considered authenticated. If the value does not match, or if MESSAGE-INTEGRITY was absent, the response MUST be discarded, as if it was never received. This means that retransmits, if applicable, will continue.",
      "ja": "クライアントは、応答（成功または失敗のいずれか）でのMESSAGE-INTEGRITYアトリビュートを探します。それが要求するために利用さと同じパスワードを使用して、15.4節に定義されるように存在する場合、クライアントは応答を介したメッセージの整合性を計算します。結果の値がMESSAGE-INTEGRITYアトリビュートの内容と一致する場合、応答は認証と考えられています。値が一致しない場合、またはMESSAGE-INTEGRITYが不在だった場合、それが受信されなかったかのように、応答は、捨てなければなりません。これは、該当する場合再送は、継続することを意味します。"
    },
    {
      "indent": 0,
      "text": "11. ALTERNATE-SERVER Mechanism",
      "section_title": true,
      "ja": "11. ALTERNATE-SERVERメカニズム"
    },
    {
      "indent": 3,
      "text": "This section describes a mechanism in STUN that allows a server to redirect a client to another server. This extension is optional, and a usage must define if and when this extension is used.",
      "ja": "このセクションでは、サーバーが別のサーバーにクライアントをリダイレクトすることができますSTUNメカニズムを説明しています。この拡張はオプションで、この拡張機能を使用する場合は、いつ使用率が定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "A server using this extension redirects a client to another server by replying to a request message with an error response message with an error code of 300 (Try Alternate). The server MUST include an ALTERNATE-SERVER attribute in the error response. The error response message MAY be authenticated; however, there are uses cases for ALTERNATE-SERVER where authentication of the response is not possible or practical.",
      "ja": "この拡張機能を使用して、サーバ300のエラーコード（代替を試してください）と、エラー応答メッセージで要求メッセージに応答して別のサーバにクライアントをリダイレクトします。サーバはエラーレスポンスでALTERNATE-SERVER属性を含まなければなりません。エラー応答メッセージが認証されてもよいです。しかし、レスポンスの認証が可能か実用的ではないALTERNATE-SERVERの用途の場合があります。"
    },
    {
      "indent": 3,
      "text": "A client using this extension handles a 300 (Try Alternate) error code as follows. The client looks for an ALTERNATE-SERVER attribute in the error response. If one is found, then the client considers the current transaction as failed, and reattempts the request with the server specified in the attribute, using the same transport protocol used for the previous request. That request, if authenticated, MUST utilize the same credentials that the client would have used in the request to the server that performed the redirection. If the client has been redirected to a server on which it has already tried this request within the last five minutes, it MUST ignore the redirection and consider the transaction to have failed. This prevents infinite ping-ponging between servers in case of redirection loops.",
      "ja": "次のようにこの拡張を使用してクライアント300（代替を試す）、エラーコードを処理します。クライアントは、エラー応答でのALTERNATE-SERVER属性を探します。 1が見つかった場合、クライアントは失敗したように、現在のトランザクションを考慮し、前の要求のために使用したのと同じトランスポートプロトコルを使用して、属性に指定されたサーバで要求を再試行し。その要求は、認証された場合、クライアントはリダイレクトを実行したサーバーへの要求に使用していたのと同じ資格情報を使用しなければなりません。クライアントは、それがすでに最後の5分以内にこの要求を試した上でサーバーにリダイレクトされている場合、それはリダイレクトを無視して、失敗したトランザクションを考慮する必要があります。これは、リダイレクションループの場合、サーバー間で無限ピンポンを防止します。"
    },
    {
      "indent": 1,
      "text": "12. Backwards Compatibility with",
      "section_title": true,
      "ja": "12.後方互換性を持ちます"
    },
    {
      "indent": 3,
      "text": "This section defines procedures that allow a degree of backwards compatibility with the original protocol defined in RFC 3489 [RFC3489]. This mechanism is optional, meant to be utilized only in cases where a new client can connect to an old server, or vice versa. A usage must define if and when this procedure is used.",
      "ja": "このセクションでは、RFC 3489 [RFC3489]で定義された元のプロトコルとの下位互換性の程度を可能にする手順を定義します。このメカニズムは、新しいクライアントが古いサーバー、またはその逆に接続することができる場合に利用されることを意味し、任意です。この手順を使用する場合は、いつ使用率が定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 19 lists all the changes between this specification and RFC 3489 [RFC3489]. However, not all of these differences are important, because \"classic STUN\" was only used in a few specific ways. For the purposes of this extension, the important changes are the following. In RFC 3489:",
      "ja": "第19リストこの仕様とRFC 3489 [RFC3489]の間でのすべての変更。 「クラシックSTUN」が唯一のいくつかの特定の方法で使用されたためしかし、すべてではないこれらの違いのは、重要です。この拡張の目的のために、重要な変更は以下の通りです。 RFC 3489で："
    },
    {
      "indent": 3,
      "text": "o UDP was the only supported transport.",
      "ja": "O UDPのみがサポート輸送でした。"
    },
    {
      "indent": 3,
      "text": "o The field that is now the magic cookie field was a part of the transaction ID field, and transaction IDs were 128 bits long.",
      "ja": "O今あるフィールドはマジッククッキーフィールドは、トランザクションIDフィールドの一部であった、とトランザクションIDは128ビット長でした。"
    },
    {
      "indent": 3,
      "text": "o The XOR-MAPPED-ADDRESS attribute did not exist, and the Binding method used the MAPPED-ADDRESS attribute instead.",
      "ja": "O XORマッピングされたアドレス属性が存在しなかった、および結合方法は、マップされ、アドレスが代わりに属性を使用します。"
    },
    {
      "indent": 3,
      "text": "o There were three comprehension-required attributes, RESPONSE-ADDRESS, CHANGE-REQUEST, and CHANGED-ADDRESS, that have been removed from this specification.",
      "ja": "Oこの仕様書から削除された3理解-必要な属性、RESPONSE-ADDRESS、CHANGE-REQUEST、およびCHANGED-ADDRESSは、ありました。"
    },
    {
      "indent": 6,
      "text": "* CHANGE-REQUEST and CHANGED-ADDRESS are now part of the NAT Behavior Discovery usage [BEHAVE-NAT], and the other is deprecated.",
      "ja": "* CHANGE-REQUESTとCHANGED-ADDRESSは現在NAT振る舞いディスカバリ使用[BEHAVE-NAT]の一部であり、他方が推奨されていません。"
    },
    {
      "indent": 0,
      "text": "12.1. Changes to Client Processing",
      "section_title": true,
      "ja": "12.1。クライアント処理の変更"
    },
    {
      "indent": 3,
      "text": "A client that wants to interoperate with an [RFC3489] server SHOULD send a request message that uses the Binding method, contains no attributes, and uses UDP as the transport protocol to the server. If successful, the success response received from the server will contain a MAPPED-ADDRESS attribute rather than an XOR-MAPPED-ADDRESS attribute. A client seeking to interoperate with an older server MUST be prepared to receive either. Furthermore, the client MUST ignore any Reserved comprehension-required attributes that might appear in the response. Of the Reserved attributes in Section 18.2, 0x0002, 0x0004, 0x0005, and 0x000B may appear in Binding responses from a server compliant to RFC 3489. Other than this change, the processing of the response is identical to the procedures described above.",
      "ja": "Bindingメソッドを使用して要求メッセージを送るべきである[RFC3489]サーバーと相互運用したいクライアントは、属性が格納されていない、およびサーバーへのトランスポートプロトコルとしてUDPを使用しています。成功した場合は、サーバから受信成功応答は、むしろXOR-MAPPED-ADDRESS属性よりもMAPPED-ADDRESS属性が含まれています。古いサーバーと相互運用しようとしているクライアントは、いずれかの受信に準備しなければなりません。さらに、クライアントが応答に表示される可能性のある予約済みの理解、必要な属性を無視しなければなりません。予約は、セクション18.2、0×0002、0x0004は、0x0005の属性、及び0x000Bこの変更以外RFC 3489.に準拠サーバからバインディング応答に表示されることから、応答の処理は、上述した手順と同じです。"
    },
    {
      "indent": 0,
      "text": "12.2. Changes to Server Processing",
      "section_title": true,
      "ja": "12.2。サーバー処理の変更"
    },
    {
      "indent": 3,
      "text": "A STUN server can detect when a given Binding request message was sent from an RFC 3489 [RFC3489] client by the absence of the correct value in the magic cookie field. When the server detects an RFC 3489 client, it SHOULD copy the value seen in the magic cookie field in the Binding request to the magic cookie field in the Binding response message, and insert a MAPPED-ADDRESS attribute instead of an XOR-MAPPED-ADDRESS attribute.",
      "ja": "所与のバインディング要求メッセージがマジッククッキーフィールドの正しい値が存在しないことによって、RFC 3489 [RFC3489]クライアントから送信されたときSTUNサーバが検出することができます。サーバーは、RFC 3489のクライアントを検出すると、バインディング応答メッセージでマジッククッキーフィールドにバインド要求にマジッククッキーフィールドで見られる値をコピーし、XOR-MAPPED-ADDRESSの代わりにMAPPED-ADDRESS属性を挿入する必要があり属性。"
    },
    {
      "indent": 3,
      "text": "The client might, in rare situations, include either the RESPONSE-ADDRESS or CHANGE-REQUEST attributes. In these situations, the server will view these as unknown comprehension-required attributes and reply with an error response. Since the mechanisms utilizing those attributes are no longer supported, this behavior is acceptable.",
      "ja": "クライアントは、まれな状況では、応答-ADDRESSやCHANGE-REQUEST属性のいずれかが含まれる場合があります。このような状況では、サーバーは、これらのような未知の理解 - 必要な属性を表示し、エラー応答を返信。これらの属性を使用するメカニズムはサポートされなくなりましたので、この動作は許容可能です。"
    },
    {
      "indent": 3,
      "text": "The RFC 3489 version of STUN lacks both the magic cookie and the FINGERPRINT attribute that allows for a very high probability of correctly identifying STUN messages when multiplexed with other protocols. Therefore, STUN implementations that are backwards compatible with RFC 3489 SHOULD NOT be used in cases where STUN will be multiplexed with another protocol. However, that should not be an issue as such multiplexing was not available in RFC 3489.",
      "ja": "STUNのRFC 3489バージョンはマジッククッキーや他のプロトコルと多重化するときに正しくSTUNメッセージを特定するのは非常に高い確率を可能FINGERPRINT属性の両方を欠いています。したがって、RFC 3489との後方互換性があるSTUNの実装では、STUNが別のプロトコルと多重化される場合には使用すべきではありません。そのような多重化は、RFC 3489で利用できませんでしたしかし、それは問題ではありません。"
    },
    {
      "indent": 0,
      "text": "13. Basic Server Behavior",
      "section_title": true,
      "ja": "13.基本サーバーの動作"
    },
    {
      "indent": 3,
      "text": "This section defines the behavior of a basic, stand-alone STUN server. A basic STUN server provides clients with server reflexive transport addresses by receiving and replying to STUN Binding requests.",
      "ja": "このセクションでは、基本的な、スタンドアローンSTUNサーバーの動作を定義します。基本的なSTUNサーバは、受信してバインディングリクエストをSTUNする返信することで、サーバ再帰トランスポートアドレスをクライアントに提供します。"
    },
    {
      "indent": 3,
      "text": "The STUN server MUST support the Binding method. It SHOULD NOT utilize the short-term or long-term credential mechanism. This is because the work involved in authenticating the request is more than the work in simply processing it. It SHOULD NOT utilize the ALTERNATE-SERVER mechanism for the same reason. It MUST support UDP and TCP. It MAY support STUN over TCP/TLS; however, TLS provides minimal security benefits in this basic mode of operation. It MAY utilize the FINGERPRINT mechanism but MUST NOT require it. Since the stand-alone server only runs STUN, FINGERPRINT provides no benefit. Requiring it would break compatibility with RFC 3489, and such compatibility is desirable in a stand-alone server. Stand-alone STUN servers SHOULD support backwards compatibility with [RFC3489] clients, as described in Section 12.",
      "ja": "STUNサーバは、Bindingメソッドをサポートしなければなりません。これは、短期または長期資格情報メカニズムを利用すべきではありません。リクエストを認証に関わる仕事がそれを処理するだけで仕事を超えているためです。これは、同じ理由ALTERNATE-SERVERメカニズムを利用すべきではありません。これは、UDPとTCPをサポートしなければなりません。これは、TCP / TLS経由STUNをサポートするかもしれ。しかし、TLSは、この動作の基本モードでは、最小限のセキュリティ上の利点を提供します。これは、指紋メカニズムを利用することができるが、それを要求してはなりません。スタンドアロンサーバーのみSTUNを実行しているので、指紋が何のメリットを提供していません。それはRFC 3489、および、そのような互換性との互換性を壊す要求することは、スタンドアロンサーバーに望ましいです。スタンドアローン第12節で説明したようにSTUNサーバは、[RFC3489]クライアントとの後方互換性をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that administrators of STUN servers provide DNS entries for those servers as described in Section 9.",
      "ja": "第9章で説明したようにSTUNサーバの管理者は、それらのサーバーのDNSエントリを提供することを推奨しています。"
    },
    {
      "indent": 3,
      "text": "A basic STUN server is not a solution for NAT traversal by itself. However, it can be utilized as part of a solution through STUN usages. This is discussed further in Section 14.",
      "ja": "基本的なSTUNサーバーは、それ自体でNATトラバーサルのためのソリューションではありません。しかし、STUN用法を通る溶液の一部として利用することができます。これは、第14章で詳しく説明されています。"
    },
    {
      "indent": 0,
      "text": "14. STUN Usages",
      "section_title": true,
      "ja": "14. STUNの用途"
    },
    {
      "indent": 3,
      "text": "STUN by itself is not a solution to the NAT traversal problem. Rather, STUN defines a tool that can be used inside a larger solution. The term \"STUN usage\" is used for any solution that uses STUN as a component.",
      "ja": "それ自体でSTUNは、NAT越え問題の解決策ではありません。むしろ、STUNは、より大きな液内で使用することができるツールを規定します。用語「STUN用法は、」コンポーネントとしてSTUNを使用する任意の溶液のために使用されます。"
    },
    {
      "indent": 3,
      "text": "At the time of writing, three STUN usages are defined: Interactive Connectivity Establishment (ICE) [MMUSIC-ICE], Client-initiated connections for SIP [SIP-OUTBOUND], and NAT Behavior Discovery [BEHAVE-NAT]. Other STUN usages may be defined in the future.",
      "ja": "インタラクティブ接続確立（ICE）[MMUSIC-ICE]、SIPのためのクライアント開始された接続[SIP-OUTBOUND]、およびNATの挙動発見[BEHAVE-NAT]：これを書いている時点で、3つのSTUN用法が定義されています。他のSTUN用法は、将来的に定義されてもよいです。"
    },
    {
      "indent": 3,
      "text": "A STUN usage defines how STUN is actually utilized -- when to send requests, what to do with the responses, and which optional procedures defined here (or in an extension to STUN) are to be used. A usage would also define: o Which STUN methods are used.",
      "ja": "STUN用法は、STUNが実際に利用される方法を定義 - 何応答を行うには、かつここで（又はSTUNへの拡張で）定義された任意の手順、要求を送信する際に使用されます。使用方法も定義します：STUN方法が使用されているoを。"
    },
    {
      "indent": 3,
      "text": "o What authentication and message-integrity mechanisms are used.",
      "ja": "Oどのような認証とメッセージ整合性のメカニズムが使用されています。"
    },
    {
      "indent": 3,
      "text": "o The considerations around manual vs. automatic key derivation for the integrity mechanism, as discussed in [RFC4107].",
      "ja": "[RFC4107]で議論するように、完全性機構の手動対​​自動鍵導出周りに考察、O。"
    },
    {
      "indent": 3,
      "text": "o What mechanisms are used to distinguish STUN messages from other messages. When STUN is run over TCP, a framing mechanism may be required.",
      "ja": "Oどのようなメカニズム他のメッセージからSTUNメッセージを区別するために使用されています。 STUNがTCP上で実行されると、フレーミングメカニズムが必要になることがあります。"
    },
    {
      "indent": 3,
      "text": "o How a STUN client determines the IP address and port of the STUN server.",
      "ja": "OどのようにSTUNクライアントは、STUNサーバーのIPアドレスとポートを決定します。"
    },
    {
      "indent": 3,
      "text": "o Whether backwards compatibility to RFC 3489 is required.",
      "ja": "RFC 3489への後方互換性が必要とされているかどうか、O。"
    },
    {
      "indent": 3,
      "text": "o What optional attributes defined here (such as FINGERPRINT and ALTERNATE-SERVER) or in other extensions are required.",
      "ja": "Oオプションの何（ここで、指紋やALTERNATE-SERVERなど）、または他の拡張で定義された属性が必要とされています。"
    },
    {
      "indent": 3,
      "text": "In addition, any STUN usage must consider the security implications of using STUN in that usage. A number of attacks against STUN are known (see the Security Considerations section in this document), and any usage must consider how these attacks can be thwarted or mitigated.",
      "ja": "また、任意のSTUN用法はその用法でSTUNを使用してのセキュリティへの影響を考慮する必要があります。 STUNに対する攻撃の数は（この文書のセキュリティの考慮事項のセクションを参照）が知られており、いずれの用法はこれらの攻撃を阻止または緩和することができる方法を検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, a usage must consider whether its usage of STUN is an example of the Unilateral Self-Address Fixing approach to NAT traversal, and if so, address the questions raised in RFC 3424 [RFC3424].",
      "ja": "最後に、使用量はSTUNの用法がNATトラバーサルへのアプローチを固定片側自己アドレスの例であるかどうかを検討しなければならない、そうであれば、RFC 3424 [RFC3424]で提起された問題に対処します。"
    },
    {
      "indent": 0,
      "text": "15. STUN Attributes",
      "section_title": true,
      "ja": "15. STUN属性"
    },
    {
      "indent": 3,
      "text": "After the STUN header are zero or more attributes. Each attribute MUST be TLV encoded, with a 16-bit type, 16-bit length, and value. Each STUN attribute MUST end on a 32-bit boundary. As mentioned above, all fields in an attribute are transmitted most significant bit first.",
      "ja": "STUNヘッダーの後にゼロ以上の属性です。各属性は、TLVは、16ビットのタイプ、16ビットの長さ、および値と、符号化されなければなりません。それぞれのSTUN属性は、32ビット境界で終了する必要があります。前述したように、属性のすべてのフィールドは、最初の最上位ビットを送信しています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Type                  |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Value (variable)                ....\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 4: Format of STUN Attributes",
      "ja": "図4：STUN属性のフォーマット"
    },
    {
      "indent": 3,
      "text": "The value in the length field MUST contain the length of the Value part of the attribute, prior to padding, measured in bytes. Since STUN aligns attributes on 32-bit boundaries, attributes whose content is not a multiple of 4 bytes are padded with 1, 2, or 3 bytes of padding so that its value contains a multiple of 4 bytes. The padding bits are ignored, and may be any value.",
      "ja": "長さフィールドの値は、バイト単位で測定された、前パディングに、属性の値部分の長さを含まなければなりません。 STUNは、32ビット境界の属性を整列させるため、その含有量は4バイトの倍数ではない、その値は4バイトの倍数を含むようにパディングの1、2、または3バイトでパディングされる属性。パディングビットは無視され、任意の値であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Any attribute type MAY appear more than once in a STUN message. Unless specified otherwise, the order of appearance is significant: only the first occurrence needs to be processed by a receiver, and any duplicates MAY be ignored by a receiver.",
      "ja": "任意の属性タイプは、STUNメッセージに複数回表示されることがあります。特に断りのない限り、出現の順序は重要である：最初の発生は、受信機によって処理される必要があり、任意の重複は、受信機によって無視されてもよいです。"
    },
    {
      "indent": 3,
      "text": "To allow future revisions of this specification to add new attributes if needed, the attribute space is divided into two ranges. Attributes with type values between 0x0000 and 0x7FFF are comprehension-required attributes, which means that the STUN agent cannot successfully process the message unless it understands the attribute. Attributes with type values between 0x8000 and 0xFFFF are comprehension-optional attributes, which means that those attributes can be ignored by the STUN agent if it does not understand them.",
      "ja": "必要であれば、この仕様の将来の改訂は、新しい属性を追加できるようにするには、属性空間は、2つの範囲に分割されます。 0000と0x7FFFの間の型の値を持つ属性は、属性を理解しない限り、STUNエージェントがメッセージを正常に処理できないことを意味し、理解、必要な属性です。 0×8000と0xFFFFの間の型の値を持つ属性は、それが彼らを理解していない場合はそれらの属性は、STUNエージェントによって無視できることを意味し、理解・オプションの属性です。"
    },
    {
      "indent": 3,
      "text": "The set of STUN attribute types is maintained by IANA. The initial set defined by this specification is found in Section 18.2.",
      "ja": "STUN属性タイプのセットは、IANAによって維持されています。この仕様で定義された最初のセットは、18.2節で発見されました。"
    },
    {
      "indent": 3,
      "text": "The rest of this section describes the format of the various attributes defined in this specification.",
      "ja": "このセクションの残りの部分は、本明細書で定義された様々な属性のフォーマットを記述する。"
    },
    {
      "indent": 0,
      "text": "15.1. MAPPED-ADDRESS",
      "section_title": true,
      "ja": "15.1。 MAPPED-ADDRESS"
    },
    {
      "indent": 3,
      "text": "The MAPPED-ADDRESS attribute indicates a reflexive transport address of the client. It consists of an 8-bit address family and a 16-bit port, followed by a fixed-length value representing the IP address. If the address family is IPv4, the address MUST be 32 bits. If the address family is IPv6, the address MUST be 128 bits. All fields must be in network byte order.",
      "ja": "MAPPED-ADDRESS属性は、クライアントの再帰の輸送アドレスを示します。これは、IPアドレスを表す固定長の値に続く8ビットのアドレスファミリーと16ビットのポートからなります。アドレスファミリーがIPv4である場合、アドレスは32ビットでなければなりません。アドレスファミリーがIPv6である場合、アドレスは128ビットでなければなりません。すべてのフィールドはネットワークバイトオーダーでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The format of the MAPPED-ADDRESS attribute is:",
      "ja": "MAPPED-ADDRESS属性の形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0|    Family     |           Port                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                 Address (32 bits or 128 bits)                 |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 5: Format of MAPPED-ADDRESS Attribute",
      "ja": "図5：MAPPED-ADDRESS属性のフォーマット"
    },
    {
      "indent": 3,
      "text": "The address family can take on the following values:",
      "ja": "アドレスファミリは、以下の値を取ることができます。"
    },
    {
      "indent": 3,
      "text": "0x01:IPv4 0x02:IPv6",
      "ja": "0×01：IPv4の0x02の：IPv6の"
    },
    {
      "indent": 3,
      "text": "The first 8 bits of the MAPPED-ADDRESS MUST be set to 0 and MUST be ignored by receivers. These bits are present for aligning parameters on natural 32-bit boundaries.",
      "ja": "MAPPED-ADDRESSの最初の8ビットは0に設定しなければならなくて、受信機で無視しなければなりません。これらのビットは、天然の32ビット境界上のパラメータを整列させるために存在します。"
    },
    {
      "indent": 3,
      "text": "This attribute is used only by servers for achieving backwards compatibility with RFC 3489 [RFC3489] clients.",
      "ja": "この属性は、RFC 3489 [RFC3489]クライアントとの下位互換性を実現するためのサーバでのみ使用されます。"
    },
    {
      "indent": 0,
      "text": "15.2. XOR-MAPPED-ADDRESS",
      "section_title": true,
      "ja": "15.2。 XOR-MAPPED-ADDRESS"
    },
    {
      "indent": 3,
      "text": "The XOR-MAPPED-ADDRESS attribute is identical to the MAPPED-ADDRESS attribute, except that the reflexive transport address is obfuscated through the XOR function.",
      "ja": "XOR-MAPPED-ADDRESS属性は、再帰の輸送アドレスはXOR関数を使用して難読化されていることを除いて、MAPPED-ADDRESS属性と同じです。"
    },
    {
      "indent": 3,
      "text": "The format of the XOR-MAPPED-ADDRESS is:",
      "ja": "XOR-MAPPED-ADDRESSの形式は次のとおりです。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|x x x x x x x x|    Family     |         X-Port                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                X-Address (Variable)\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 6: Format of XOR-MAPPED-ADDRESS Attribute",
      "ja": "図6：XOR-MAPPED-ADDRESS属性のフォーマット"
    },
    {
      "indent": 3,
      "text": "The Family represents the IP address family, and is encoded identically to the Family in MAPPED-ADDRESS.",
      "ja": "家族は、IPアドレス・ファミリーを表し、MAPPED-ADDRESSに家族と同一に符号化されています。"
    },
    {
      "indent": 3,
      "text": "X-Port is computed by taking the mapped port in host byte order, XOR'ing it with the most significant 16 bits of the magic cookie, and then the converting the result to network byte order. If the IP address family is IPv4, X-Address is computed by taking the mapped IP address in host byte order, XOR'ing it with the magic cookie, and converting the result to network byte order. If the IP address family is IPv6, X-Address is computed by taking the mapped IP address in host byte order, XOR'ing it with the concatenation of the magic cookie and the 96-bit transaction ID, and converting the result to network byte order.",
      "ja": "Xポートは、ホストバイト順にマッピングされたポートを取るマジッククッキーの最上位16ビットとをXORし、次いでバイトオーダーをネットワークに結果を変換することによって計算されます。 IPアドレス・ファミリは、IPv4の場合は、X-アドレスは、ホストバイトオーダーでマッピングされたIPアドレスを取っマジッククッキーでそれをXORし、バイトオーダーをネットワークに結果を変換することによって計算されます。 IPアドレスファミリーがIPv6であるならば、X-アドレスは、ホストバイト順にマッピングされたIPアドレスを取っマジッククッキーの連結と96ビットのトランザクションIDとそれをXORして、バイトをネットワークに結果を変換することによって計算されます注文。"
    },
    {
      "indent": 3,
      "text": "The rules for encoding and processing the first 8 bits of the attribute's value, the rules for handling multiple occurrences of the attribute, and the rules for processing address families are the same as for MAPPED-ADDRESS.",
      "ja": "符号化および属性の値の最初の8ビットを処理するためのルールは、属性の複数の発生を処理するためのルール、およびアドレスファミリを処理するためのルールは、マッピングされ-ADDRESSと同じです。"
    },
    {
      "indent": 3,
      "text": "Note: XOR-MAPPED-ADDRESS and MAPPED-ADDRESS differ only in their encoding of the transport address. The former encodes the transport address by exclusive-or'ing it with the magic cookie. The latter encodes it directly in binary. RFC 3489 originally specified only MAPPED-ADDRESS. However, deployment experience found that some NATs rewrite the 32-bit binary payloads containing the NAT's public IP address, such as STUN's MAPPED-ADDRESS attribute, in the well-meaning but misguided attempt at providing a generic ALG function. Such behavior interferes with the operation of STUN and also causes failure of STUN's message-integrity checking.",
      "ja": "注意：XOR-MAPPED-ADDRESSとMAPPED-ADDRESSはトランスポートアドレスの彼らのエンコーディングのみが異なります。前者はマジッククッキーとそれを排他的論理和によりトランスポートアドレスを符号化します。後者は、バイナリに直接それをコードします。 RFC 3489は、もともとだけMAPPED-ADDRESSを指定しました。しかし、展開の経験は、いくつかのNATは、一般的なALG機能を提供することを、よく意味が、見当違いの試みでは、このようなSTUNのMAPPED-ADDRESS属性として、NATのパブリックIPアドレスを含む32ビットのバイナリペイロードを、書き換えることがわかりました。このような行動は、STUNの動作を妨害し、また、STUNのメッセージ整合性チェックの失敗の原因となります。"
    },
    {
      "indent": 0,
      "text": "15.3. USERNAME",
      "section_title": true,
      "ja": "15.3。 USERNAME"
    },
    {
      "indent": 3,
      "text": "The USERNAME attribute is used for message integrity. It identifies the username and password combination used in the message-integrity check.",
      "ja": "USERNAME属性は、メッセージの完全性のために使用されています。これは、メッセージ完全性チェックに使用するユーザー名とパスワードの組み合わせを特定します。"
    },
    {
      "indent": 3,
      "text": "The value of USERNAME is a variable-length value. It MUST contain a UTF-8 [RFC3629] encoded sequence of less than 513 bytes, and MUST have been processed using SASLprep [RFC4013].",
      "ja": "USERNAMEの値は、可変長値です。これは、UTF-8 [RFC3629]未満513バイトの符号化された配列を含まなければなりません、そしてSASLprep [RFC4013]を使用して処理されていなければなりません。"
    },
    {
      "indent": 0,
      "text": "15.4. MESSAGE-INTEGRITY",
      "section_title": true,
      "ja": "15.4。 MESSAGE-INTEGRITY"
    },
    {
      "indent": 3,
      "text": "The MESSAGE-INTEGRITY attribute contains an HMAC-SHA1 [RFC2104] of the STUN message. The MESSAGE-INTEGRITY attribute can be present in any STUN message type. Since it uses the SHA1 hash, the HMAC will be 20 bytes. The text used as input to HMAC is the STUN message, including the header, up to and including the attribute preceding the MESSAGE-INTEGRITY attribute. With the exception of the FINGERPRINT attribute, which appears after MESSAGE-INTEGRITY, agents MUST ignore all other attributes that follow MESSAGE-INTEGRITY.",
      "ja": "MESSAGE-INTEGRITYアトリビュートはSTUNメッセージのHMAC-SHA1 [RFC2104]を含んでいます。 MESSAGE-INTEGRITY属性は、任意のSTUNメッセージタイプに存在することができます。それはSHA1ハッシュを使用しているので、HMACは20バイトになります。 HMACへの入力として使用されるテキストはまで、ヘッダを含み、MESSAGE-INTEGRITYアトリビュートを先行属性を含む、STUNメッセージです。 MESSAGE-INTEGRITYの後に現れるFINGERPRINT属性を除いて、エージェントはMESSAGE-INTEGRITYに続く他のすべての属性を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The key for the HMAC depends on whether long-term or short-term credentials are in use. For long-term credentials, the key is 16 bytes:",
      "ja": "HMACのための鍵は、長期または短期資格情報が使用されているかどうかに依存します。長期資格情報については、キーは16バイトです。"
    },
    {
      "indent": 12,
      "text": "key = MD5(username \":\" realm \":\" SASLprep(password))",
      "ja": "キー= MD5（ユーザ名 \"：\" 王国 \"：\" SASLprep（パスワード））"
    },
    {
      "indent": 3,
      "text": "That is, the 16-byte key is formed by taking the MD5 hash of the result of concatenating the following five fields: (1) the username, with any quotes and trailing nulls removed, as taken from the USERNAME attribute (in which case SASLprep has already been applied); (2) a single colon; (3) the realm, with any quotes and trailing nulls removed; (4) a single colon; and (5) the password, with any trailing nulls removed and after processing using SASLprep. For example, if the username was 'user', the realm was 'realm', and the password was 'pass', then the 16-byte HMAC key would be the result of performing an MD5 hash on the string 'user:realm:pass', the resulting hash being 0x8493fbc53ba582fb4c044c456bdc40eb.",
      "ja": "その場合、userName属性（SASLprepから採取されたように、除去任意の引用符と後続ヌルで、（1）ユーザ名：すなわち、16バイトのキーは、以下の5つのフィールドを連結した結果のMD5ハッシュをとることによって形成されていますすでに）適用されています。 （2）単一のコロン。 （3）領域を除去する任意の引用符と末尾ヌルを有します。 （4）単一のコロン。 （5）パスワード、除去後続のヌルを有するとSASLprepを用いて処理した後。たとえば、ユーザ名が「ユーザー」だった場合、レルムは「王国」だった、とパスワードは「合格」だった場合、16バイトのHMACキーは、文字列「ユーザーにMD5ハッシュを行った結果になります：レルム： 、0x8493fbc53ba582fb4c044c456bdc40ebされ、得られたハッシュを渡します。"
    },
    {
      "indent": 3,
      "text": "For short-term credentials:",
      "ja": "短期的な資格証明書の場合："
    },
    {
      "indent": 26,
      "text": "key = SASLprep(password)",
      "ja": "キー= SASLprep（パスワード）"
    },
    {
      "indent": 3,
      "text": "where MD5 is defined in RFC 1321 [RFC1321] and SASLprep() is defined in RFC 4013 [RFC4013].",
      "ja": "MD5は、RFC 1321 [RFC1321]及びSASLprep（）で定義されるRFC 4013 [RFC4013]で定義されています。"
    },
    {
      "indent": 3,
      "text": "The structure of the key when used with long-term credentials facilitates deployment in systems that also utilize SIP. Typically, SIP systems utilizing SIP's digest authentication mechanism do not actually store the password in the database. Rather, they store a value called H(A1), which is equal to the key defined above.",
      "ja": "長期資格情報で使用されるキーの構造も、SIPを利用するシステムでの展開を容易にします。一般的に、SIPのダイジェスト認証機構を利用したSIPシステムは、実際にデータベースにパスワードを保存しないでください。むしろ、それらは、上記で定義されたキーに等しいH（A1）と呼ばれる値を格納します。"
    },
    {
      "indent": 3,
      "text": "Based on the rules above, the hash used to construct MESSAGE-INTEGRITY includes the length field from the STUN message header. Prior to performing the hash, the MESSAGE-INTEGRITY attribute MUST be inserted into the message (with dummy content). The length MUST then be set to point to the length of the message up to, and including, the MESSAGE-INTEGRITY attribute itself, but excluding any attributes after it. Once the computation is performed, the value of the MESSAGE-INTEGRITY attribute can be filled in, and the value of the length in the STUN header can be set to its correct value -- the length of the entire message. Similarly, when validating the MESSAGE-INTEGRITY, the length field should be adjusted to point to the end of the MESSAGE-INTEGRITY attribute prior to calculating the HMAC. Such adjustment is necessary when attributes, such as FINGERPRINT, appear after MESSAGE-INTEGRITY.",
      "ja": "上記の規則に基づいて、メッセージの完全性を構築するために使用されるハッシュは、STUNメッセージヘッダーの長さフィールドを含みます。ハッシュを実行する前に、MESSAGE-INTEGRITY属性は、（ダミーコンテンツに）メッセージに挿入しなければなりません。長さは、その後にメッセージの長さまでを指すように設定し、かつ含む、MESSAGE-INTEGRITYアトリビュート自体が、それの後に任意の属性を除外しなければなりません。計算が実行されると、MESSAGE-INTEGRITY属性の値はに充填することができ、そしてSTUNヘッダーの長さの値が正しい値に設定することができる - メッセージ全体の長さ。 MESSAGE-INTEGRITYを検証するとき同様に、長さフィールドは、MESSAGE-INTEGRITYの端を指すようにHMACを計算する前に属性が調整されるべきです。指紋などの属性は、MESSAGE-INTEGRITYの後に現れるとき、そのような調整が必要です。"
    },
    {
      "indent": 0,
      "text": "15.5. FINGERPRINT",
      "section_title": true,
      "ja": "15.5。指紋"
    },
    {
      "indent": 3,
      "text": "The FINGERPRINT attribute MAY be present in all STUN messages. The value of the attribute is computed as the CRC-32 of the STUN message up to (but excluding) the FINGERPRINT attribute itself, XOR'ed with the 32-bit value 0x5354554e (the XOR helps in cases where an application packet is also using CRC-32 in it). The 32-bit CRC is the one defined in ITU V.42 [ITU.V42.2002], which has a generator polynomial of x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1. When present, the FINGERPRINT attribute MUST be the last attribute in the message, and thus will appear after MESSAGE-INTEGRITY.",
      "ja": "FINGERPRINT属性は、すべてのSTUNメッセージ中に存在してもよいです。属性の値はCRC-32 STUNメッセージとしてアップ計算（ただし、を除く）FINGERPRINT属性自体、32ビット値0x5354554eとXORされる（XORは、アプリケーションパケットも使用している場合に役立ちCRC-32それに）。 32ビットCRCは、X32 + X26 + X23 + X22 + X16 + X12 + X11 + X10 + X8 + X7 + X5 +の生成多項式を有し、ITU V.42 [ITU.V42.2002]で定義されたものですX4 + X2 + X + 1。存在する場合、FINGERPRINT属性はメッセージの最後の属性であるに違いありませんので、MESSAGE-INTEGRITYの後に表示されます。"
    },
    {
      "indent": 3,
      "text": "The FINGERPRINT attribute can aid in distinguishing STUN packets from packets of other protocols. See Section 8.",
      "ja": "FINGERPRINT属性は、他のプロトコルのパケットとSTUNパケットを区別するのに役立つことができます。セクション8を参照してください。"
    },
    {
      "indent": 3,
      "text": "As with MESSAGE-INTEGRITY, the CRC used in the FINGERPRINT attribute covers the length field from the STUN message header. Therefore, this value must be correct and include the CRC attribute as part of the message length, prior to computation of the CRC. When using the FINGERPRINT attribute in a message, the attribute is first placed into the message with a dummy value, then the CRC is computed, and then the value of the attribute is updated. If the MESSAGE-INTEGRITY attribute is also present, then it must be present with the correct message-integrity value before the CRC is computed, since the CRC is done over the value of the MESSAGE-INTEGRITY attribute as well.",
      "ja": "MESSAGE-INTEGRITYと同様に、指紋属性で使用されるCRCはSTUNメッセージヘッダの長さフィールドをカバーします。したがって、この値は正確でなければならず、前CRCの計算に、メッセージ長の一部としてCRC属性を含みます。メッセージにFINGERPRINT属性を使用する場合、属性は、第1のダミー値を持つメッセージに置かれ、その後、CRCが計算され、その後、属性の値が更新されます。 MESSAGE-INTEGRITY属性も存在している場合、CRCがMESSAGE-INTEGRITYの値を介して行われているためだけでなく、属性、計算されたCRCの前に正しいメッセージ・インテグリティ値を持つ存在している必要があります。"
    },
    {
      "indent": 0,
      "text": "15.6. ERROR-CODE",
      "section_title": true,
      "ja": "15.6。エラーコード"
    },
    {
      "indent": 3,
      "text": "The ERROR-CODE attribute is used in error response messages. It contains a numeric error code value in the range of 300 to 699 plus a textual reason phrase encoded in UTF-8 [RFC3629], and is consistent in its code assignments and semantics with SIP [RFC3261] and HTTP [RFC2616]. The reason phrase is meant for user consumption, and can be anything appropriate for the error code. Recommended reason phrases for the defined error codes are included in the IANA registry for error codes. The reason phrase MUST be a UTF-8 [RFC3629] encoded sequence of less than 128 characters (which can be as long as 763 bytes).",
      "ja": "ERROR-CODE属性は、エラー応答メッセージに使用されています。これは、699から300の範囲の数値のエラーコード値を加えたUTF-8 [RFC3629]で符号化テキスト理由フレーズを含み、SIP [RFC3261]とHTTP [RFC2616]とのコード割り当ておよびセマンティクスに一致しています。理由フレーズは、ユーザーの消費のために意図され、エラーコードのための適切な何もすることができます。定義されたエラーコードの推奨理由フレーズは、エラーコードのIANAレジストリに含まれています。理由句は、（あれば763のようなバイトであり得る）未満128文字のUTF-8 [RFC3629]エンコードされたシーケンスでなければなりません。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Reserved, should be 0         |Class|     Number    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Reason Phrase (variable)                                ..\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 7: ERROR-CODE Attribute",
      "ja": "図7：ERROR-CODEアトリビュート"
    },
    {
      "indent": 3,
      "text": "To facilitate processing, the class of the error code (the hundreds digit) is encoded separately from the rest of the code, as shown in Figure 7.",
      "ja": "図7に示すような処理を容易にするために、エラーコード（数百の桁）のクラスは、コードの残りの部分とは別個に符号化されます。"
    },
    {
      "indent": 3,
      "text": "The Reserved bits SHOULD be 0, and are for alignment on 32-bit boundaries. Receivers MUST ignore these bits. The Class represents the hundreds digit of the error code. The value MUST be between 3 and 6. The Number represents the error code modulo 100, and its value MUST be between 0 and 99.",
      "ja": "予約ビットは0であり、32ビット境界に位置合わせするためのものであるべきです。レシーバは、これらのビットを無視しなければなりません。クラスは、エラーコードの数百の位を表します。値は、3と6の間でなければなりません数エラーコードモジュロ100を示し、その値は0と99の間でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following error codes, along with their recommended reason phrases, are defined:",
      "ja": "以下のエラーコードは、その推奨理由フレーズと一緒に、定義されています。"
    },
    {
      "indent": 3,
      "text": "300 Try Alternate: The client should contact an alternate server for this request. This error response MUST only be sent if the request included a USERNAME attribute and a valid MESSAGE-INTEGRITY attribute; otherwise, it MUST NOT be sent and error code 400 (Bad Request) is suggested. This error response MUST be protected with the MESSAGE-INTEGRITY attribute, and receivers MUST validate the MESSAGE-INTEGRITY of this response before redirecting themselves to an alternate server.",
      "ja": "300は、代替試してみてください。クライアントは、この要求の代替サーバに問い合わせてください。リクエストはUSERNAME属性と有効なMESSAGE-INTEGRITYアトリビュートが含まれている場合、このエラー応答は送らなければなりません。それ以外の場合は、送ってはいけません、エラーコード400（不正なリクエスト）が提案されています。このエラー応答がMESSAGE-INTEGRITYアトリビュートで保護されなければならない、とレシーバは、代替サーバに自分自身をリダイレクトする前にこのレスポンスのMESSAGE-INTEGRITYを検証する必要があります。"
    },
    {
      "indent": 13,
      "text": "Note: Failure to generate and validate message integrity\nfor a 300 response allows an on-path attacker to falsify a\n300 response thus causing subsequent STUN messages to be\nsent to a victim.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "400 Bad Request: The request was malformed. The client SHOULD NOT retry the request without modification from the previous attempt. The server may not be able to generate a valid MESSAGE-INTEGRITY for this error, so the client MUST NOT expect a valid MESSAGE-INTEGRITY attribute on this response.",
      "ja": "400不正な要求：要求が不正でした。クライアントは、以前の試みから変更なしで要求を再試行すべきではありません。クライアントは、この応答に有効なMESSAGE-INTEGRITYアトリビュートを予想してはいけませんので、サーバーは、このエラーの有効なMESSAGE-INTEGRITYを生成することができないかもしれません。"
    },
    {
      "indent": 3,
      "text": "401 Unauthorized: The request did not contain the correct credentials to proceed. The client should retry the request with proper credentials.",
      "ja": "無断401：要求が続行するための正しい資格情報が含まれていませんでした。クライアントは、適切な資格情報を使用して、要求を再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "420 Unknown Attribute: The server received a STUN packet containing a comprehension-required attribute that it did not understand. The server MUST put this unknown attribute in the UNKNOWN-ATTRIBUTE attribute of its error response.",
      "ja": "420不明な属性：サーバーは、それが理解していなかったことを理解-必要な属性を含むSTUNパケットを受信しました。サーバーは、そのエラーレスポンスのUNKNOWN-ATTRIBUTEアトリビュートにこの未知の属性を置く必要があります。"
    },
    {
      "indent": 3,
      "text": "438 Stale Nonce: The NONCE used by the client was no longer valid. The client should retry, using the NONCE provided in the response.",
      "ja": "438古いナンス：クライアントが使用するNONCEがもはや有効でした。クライアントは応答して提供NONCEを使用して、再試行する必要があります。"
    },
    {
      "indent": 3,
      "text": "500 Server Error: The server has suffered a temporary error. The client should try again.",
      "ja": "500サーバーエラー：サーバーが一時的なエラーを受けました。クライアントは、もう一度試してみてください。"
    },
    {
      "indent": 0,
      "text": "15.7. REALM",
      "section_title": true,
      "ja": "15.7。 REALM"
    },
    {
      "indent": 3,
      "text": "The REALM attribute may be present in requests and responses. It contains text that meets the grammar for \"realm-value\" as described in RFC 3261 [RFC3261] but without the double quotes and their surrounding whitespace. That is, it is an unquoted realm-value (and is therefore a sequence of qdtext or quoted-pair). It MUST be a UTF-8 [RFC3629] encoded sequence of less than 128 characters (which can be as long as 763 bytes), and MUST have been processed using SASLprep [RFC4013].",
      "ja": "REALM属性は、要求と応答中に存在することができます。これは、RFC 3261 [RFC3261]ではなく、二重引用符とその前後の空白なしで説明するように、「レルム値」のための文法を満たしているテキストが含まれています。つまり、引用符で囲まれていないレルム値である（したがってqdtextまたは引用対の配列です）。これは、（763のバイトと同じくらい長くすることができる）未満128文字のUTF-8 [RFC3629]エンコードされた配列でなければなりません、そしてSASLprep [RFC4013]を使用して処理されていなければなりません。"
    },
    {
      "indent": 3,
      "text": "Presence of the REALM attribute in a request indicates that long-term credentials are being used for authentication. Presence in certain error responses indicates that the server wishes the client to use a long-term credential for authentication.",
      "ja": "リクエストでREALM属性の存在は、長期の資格情報が認証に使用されていることを示しています。特定のエラー応答の存在は、サーバが認証のための長期的な資格情報を使用するようにクライアントを望んでいることを示しています。"
    },
    {
      "indent": 0,
      "text": "15.8. NONCE",
      "section_title": true,
      "ja": "15.8。使節"
    },
    {
      "indent": 3,
      "text": "The NONCE attribute may be present in requests and responses. It contains a sequence of qdtext or quoted-pair, which are defined in RFC 3261 [RFC3261]. Note that this means that the NONCE attribute will not contain actual quote characters. See RFC 2617 [RFC2617], Section 4.3, for guidance on selection of nonce values in a server.",
      "ja": "NONCE属性は、要求と応答中に存在することができます。これは、RFC 3261 [RFC3261]で定義されqdtextまたは引用対の配列を含みます。これはNONCE属性は、実際の引用符を含まないことを意味することに注意してください。サーバ内のnonce値の選択に関するガイダンスのために、4.3節、RFC 2617 [RFC2617]を参照してください。"
    },
    {
      "indent": 3,
      "text": "It MUST be less than 128 characters (which can be as long as 763 bytes).",
      "ja": "これは、（763のバイトと同じくらい長くすることができる）128文字未満でなければなりません。"
    },
    {
      "indent": 0,
      "text": "15.9. UNKNOWN-ATTRIBUTES",
      "section_title": true,
      "ja": "15.9。 UNKNOWN-ATTRIBUTES"
    },
    {
      "indent": 3,
      "text": "The UNKNOWN-ATTRIBUTES attribute is present only in an error response when the response code in the ERROR-CODE attribute is 420.",
      "ja": "UNKNOWN-ATTRIBUTES属性ERROR-CODE属性で応答コードが420である場合にのみ、エラー応答で存在します。"
    },
    {
      "indent": 3,
      "text": "The attribute contains a list of 16-bit values, each of which represents an attribute type that was not understood by the server.",
      "ja": "属性は、サーバによって理解されなかった属性タイプを表し各々が16ビット値のリストを含みます。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Attribute 1 Type           |     Attribute 2 Type        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Attribute 3 Type           |     Attribute 4 Type    ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 8: Format of UNKNOWN-ATTRIBUTES Attribute",
      "ja": "図8：UNKNOWN-ATTRIBUTESのフォーマットは、属性"
    },
    {
      "indent": 6,
      "text": "Note: In [RFC3489], this field was padded to 32 by duplicating the last attribute. In this version of the specification, the normal padding rules for attributes are used instead.",
      "ja": "注意：[RFC3489]では、このフィールドは最後の属性を複製することによって32に埋められました。仕様のこのバージョンでは、属性の通常のパディング規則が代わりに使用されます。"
    },
    {
      "indent": 0,
      "text": "15.10. SOFTWARE",
      "section_title": true,
      "ja": "15.10。ソフトウェア"
    },
    {
      "indent": 3,
      "text": "The SOFTWARE attribute contains a textual description of the software being used by the agent sending the message. It is used by clients and servers. Its value SHOULD include manufacturer and version number. The attribute has no impact on operation of the protocol, and serves only as a tool for diagnostic and debugging purposes. The value of SOFTWARE is variable length. It MUST be a UTF-8 [RFC3629] encoded sequence of less than 128 characters (which can be as long as 763 bytes).",
      "ja": "SOFTWARE属性は、メッセージを送信するエージェントによって使用されているソフトウェアのテキスト記述が含まれています。これは、クライアントとサーバによって使用されます。その値は、製造業者とバージョン番号を含むべきです。属性は、プロトコルの動作に影響を与えない、とのみ診断およびデバッグの目的のためのツールとして役立ちます。 SOFTWAREの値は可変長です。これは、（763のバイトと同じくらい長くすることができる）未満128文字のUTF-8 [RFC3629]エンコードされたシーケンスでなければなりません。"
    },
    {
      "indent": 0,
      "text": "15.11. ALTERNATE-SERVER",
      "section_title": true,
      "ja": "15.11。 ALTERNATE-SERVER"
    },
    {
      "indent": 3,
      "text": "The alternate server represents an alternate transport address identifying a different STUN server that the STUN client should try.",
      "ja": "代替サーバは、STUNクライアントが試みるべき異なるSTUNサーバーを特定する代替トランスポートアドレスを表します。"
    },
    {
      "indent": 3,
      "text": "It is encoded in the same way as MAPPED-ADDRESS, and thus refers to a single server by IP address. The IP address family MUST be identical to that of the source IP address of the request.",
      "ja": "これは、マップされ、アドレスと同じ方法で符号化され、従って、IPアドレスで単一のサーバーを指します。 IPアドレスファミリは、要求の送信元IPアドレスのものと同じでなければなりません。"
    },
    {
      "indent": 0,
      "text": "16. Security Considerations",
      "section_title": true,
      "ja": "16.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "16.1. Attacks against the Protocol",
      "section_title": true,
      "ja": "16.1。プロトコルに対する攻撃"
    },
    {
      "indent": 0,
      "text": "16.1.1. Outside Attacks",
      "section_title": true,
      "ja": "16.1.1。外部からの攻撃"
    },
    {
      "indent": 3,
      "text": "An attacker can try to modify STUN messages in transit, in order to cause a failure in STUN operation. These attacks are detected for both requests and responses through the message-integrity mechanism, using either a short-term or long-term credential. Of course, once detected, the manipulated packets will be dropped, causing the STUN transaction to effectively fail. This attack is possible only by an on-path attacker.",
      "ja": "攻撃者は、STUN操作での障害を引き起こすために、輸送中のSTUNメッセージを変更しようとすることができます。これらの攻撃は、短期または長期の資格のいずれかを使用して、メッセージの完全性機構を介して要求と応答の両方で検出されています。もちろん、一度検出され、操作パケットは、STUNトランザクションが効果的に失敗する原因、削除されます。この攻撃は、唯一のパス攻撃者によって可能です。"
    },
    {
      "indent": 3,
      "text": "An attacker that can observe, but not modify, STUN messages in-transit (for example, an attacker present on a shared access medium, such as Wi-Fi), can see a STUN request, and then immediately send a STUN response, typically an error response, in order to disrupt STUN processing. This attack is also prevented for messages that utilize MESSAGE-INTEGRITY. However, some error responses, those related to authentication in particular, cannot be protected by MESSAGE-INTEGRITY. When STUN itself is run over a secure transport protocol (e.g., TLS), these attacks are completely mitigated.",
      "ja": "確認したが、変更することはできません攻撃者は、STUNメッセージで-トランジット（例えば、Wi-Fiなどの共用アクセス媒体上に存在する攻撃者）は、STUNリクエストを見ることができ、その後、すぐに一般的に、STUN応答を送信しますエラー応答、STUN処理を破壊するためです。この攻撃は、MESSAGE-INTEGRITYを利用メッセージのために阻止されます。しかし、いくつかのエラーレスポンス、特に認証に関連するものは、MESSAGE-INTEGRITYで保護することはできません。 STUN自体（例えば、TLS）、セキュアトランスポートプロトコル上で実行されると、これらの攻撃は完全に緩和されます。"
    },
    {
      "indent": 3,
      "text": "Depending on the STUN usage, these attacks may be of minimal consequence and thus do not require message integrity to mitigate. For example, when STUN is used to a basic STUN server to discover a server reflexive candidate for usage with ICE, authentication and message integrity are not required since these attacks are detected during the connectivity check phase. The connectivity checks themselves, however, require protection for proper operation of ICE overall. As described in Section 14, STUN usages describe when authentication and message integrity are needed.",
      "ja": "STUNの使用状況に応じて、これらの攻撃は、最小限の結果であってもよいので、軽減するために、メッセージの整合性を必要としません。 STUNはICEで使用するためのサーバ再帰候補者を発見するための基本的なSTUNサーバーに使用されている場合、これらの攻撃は、接続性チェックフェーズ中に検出されているので、例えば、認証やメッセージの整合性が必要とされていません。接続自体は、しかし、全体的なICEの適切な動作のために保護を必要とチェックします。第14章で説明したように、認証とメッセージの整合性が必要な場合、STUN用法は、説明します。"
    },
    {
      "indent": 3,
      "text": "Since STUN uses the HMAC of a shared secret for authentication and integrity protection, it is subject to offline dictionary attacks. When authentication is utilized, it SHOULD be with a strong password that is not readily subject to offline dictionary attacks. Protection of the channel itself, using TLS, mitigates these attacks. However, STUN is most often run over UDP and in those cases, strong passwords are the only way to protect against these attacks.",
      "ja": "STUNが認証と完全性保護のための共有秘密のHMACを使用しているので、オフライン辞書攻撃される可能性があります。認証を利用する場合、それはオフライン辞書攻撃に容易に受けない強力なパスワードであるべきです。チャネル自体の保護は、TLSを使用して、これらの攻撃を軽減します。しかし、STUNはほとんどが、多くの場合、UDP上で実行され、それらの例には、強力なパスワードは、これらの攻撃から守るための唯一の方法ですです。"
    },
    {
      "indent": 0,
      "text": "16.1.2. Inside Attacks",
      "section_title": true,
      "ja": "16.1.2。インサイド攻撃"
    },
    {
      "indent": 3,
      "text": "A rogue client may try to launch a DoS attack against a server by sending it a large number of STUN requests. Fortunately, STUN requests can be processed statelessly by a server, making such attacks hard to launch.",
      "ja": "不正なクライアントはそれをSTUN要求を大量に送信することにより、サーバに対するDoS攻撃を起動しようとするかもしれません。幸いなことに、STUN要求が起動するような攻撃は、難く、サーバでステートレスに処理することができます。"
    },
    {
      "indent": 3,
      "text": "A rogue client may use a STUN server as a reflector, sending it requests with a falsified source IP address and port. In such a case, the response would be delivered to that source IP and port. There is no amplification of the number of packets with this attack (the STUN server sends one packet for each packet sent by the client), though there is a small increase in the amount of data, since STUN responses are typically larger than requests. This attack is mitigated by ingress source address filtering.",
      "ja": "不正なクライアントは、それが偽造送信元IPアドレスとポートを要求した送信、リフレクターとしてSTUNサーバを使用することができます。このような場合には、応答は、その送信元IPとポートに送達されるであろう。データ量のわずかな増加があったもののSTUN応答が一般的に要求よりも大きいので、この攻撃のパケット数の増幅が、（STUNサーバーは、クライアントから送信された各パケットに対して1つのパケットを送信します）がありません。この攻撃は、侵入ソースアドレスフィルタリングによって軽減されます。"
    },
    {
      "indent": 3,
      "text": "Revealing the specific software version of the agent through the SOFTWARE attribute might allow them to become more vulnerable to attacks against software that is known to contain security holes. Implementers SHOULD make usage of the SOFTWARE attribute a configurable option.",
      "ja": "SOFTWARE属性を使用して、エージェントの特定のソフトウェアバージョンを明らかにすることは、それらがセキュリティホールを含むことが知られているソフトウェアに対する攻撃に対してより脆弱になることを許可することがあります。実装者は、本ソフトウェアの使用量が設定可能なオプション属性行う必要があります。"
    },
    {
      "indent": 0,
      "text": "16.2. Attacks Affecting the Usage",
      "section_title": true,
      "ja": "16.2。使用方法に影響を与える攻撃"
    },
    {
      "indent": 3,
      "text": "This section lists attacks that might be launched against a usage of STUN. Each STUN usage must consider whether these attacks are applicable to it, and if so, discuss counter-measures.",
      "ja": "このセクションでは、STUNの用法に対して実行される可能性があります攻撃を示しています。それぞれのSTUN用法はこれらの攻撃は、それに適用されるかどうかを検討し、そうであれば、対策を議論する必要があります。"
    },
    {
      "indent": 3,
      "text": "Most of the attacks in this section revolve around an attacker modifying the reflexive address learned by a STUN client through a",
      "ja": "このセクションの攻撃のほとんどはを通じてSTUNクライアントによって学習された再帰アドレスを変更する攻撃者を中心に展開します"
    },
    {
      "indent": 3,
      "text": "Binding request/response transaction. Since the usage of the reflexive address is a function of the usage, the applicability and remediation of these attacks are usage-specific. In common situations, modification of the reflexive address by an on-path attacker is easy to do. Consider, for example, the common situation where STUN is run directly over UDP. In this case, an on-path attacker can modify the source IP address of the Binding request before it arrives at the STUN server. The STUN server will then return this IP address in the XOR-MAPPED-ADDRESS attribute to the client, and send the response back to that (falsified) IP address and port. If the attacker can also intercept this response, it can direct it back towards the client. Protecting against this attack by using a message-integrity check is impossible, since a message-integrity value cannot cover the source IP address, since the intervening NAT must be able to modify this value. Instead, one solution to preventing the attacks listed below is for the client to verify the reflexive address learned, as is done in ICE [MMUSIC-ICE]. Other usages may use other means to prevent these attacks.",
      "ja": "要求/応答トランザクションを結合。再帰アドレスの使用量は、使用の関数であるので、これらの攻撃の適用可能性と修復は、使用固有です。一般的な状況では、上のパス攻撃者による再帰アドレスの変更を行うのは簡単です。例えば、STUNはUDP上で直接実行される一般的な状況を考えてみましょう。それがSTUNサーバに到着する前に、この場合は、上のパス攻撃者は、バインディング要求の送信元のIPアドレスを変更することができます。 STUNサーバは、クライアントへのXOR-MAPPED-ADDRESS属性で、このIPアドレスを返し、その（改竄）IPアドレスとポートに応答を送信します。攻撃者はまた、この応答を傍受することができれば、それはクライアントに向かって戻って指示することができます。介在NATは、この値を変更することができなければならないので、メッセージ・インテグリティ値は、送信元IPアドレスをカバーすることはできませんので、メッセージ整合性チェックを使用して、この攻撃から保護することは、不可能です。 ICE [MMUSIC-ICE]で行われるようにする代わりに、学習、下記の攻撃を防止する一つの解決策は、再帰アドレスを確認するには、クライアントのためです。その他の用法はこれらの攻撃を防ぐために、他の手段を使用することができます。"
    },
    {
      "indent": 0,
      "text": "16.2.1. Attack I: Distributed DoS (DDoS) against a Target",
      "section_title": true,
      "ja": "16.2.1。攻撃は、I：標的に対する分散型DoS攻撃（DDoS攻撃）"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker provides one or more clients with the same faked reflexive address that points to the intended target. This will trick the STUN clients into thinking that their reflexive addresses are equal to that of the target. If the clients hand out that reflexive address in order to receive traffic on it (for example, in SIP messages), the traffic will instead be sent to the target. This attack can provide substantial amplification, especially when used with clients that are using STUN to enable multimedia applications. However, it can only be launched against targets for which packets from the STUN server to the target pass through the attacker, limiting the cases in which it is possible.",
      "ja": "この攻撃では、攻撃者が意図したターゲットを指す同じ偽造再帰アドレスを持つ1つ以上のクライアントを提供します。これは彼らの再帰アドレスがターゲットと同等であることを考えることにSTUNクライアントをだまします。クライアントはそれにトラフィックを受信するために、その再帰アドレスを配る場合（例えば、SIPメッセージに）、トラフィックではなく、ターゲットに送信されます。この攻撃は、マルチメディア・アプリケーションを可能にするために、STUNを使用しているクライアントで使用し、特にかなりの増幅を、提供することができます。しかし、それだけで、それが可能な例を制限する、ターゲットにSTUNサーバからのパケットが攻撃を通過するためのターゲットに対して起動することができます。"
    },
    {
      "indent": 0,
      "text": "16.2.2. Attack II: Silencing a Client",
      "section_title": true,
      "ja": "16.2.2。攻撃II：クライアントを消します"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker provides a STUN client with a faked reflexive address. The reflexive address it provides is a transport address that routes to nowhere. As a result, the client won't receive any of the packets it expects to receive when it hands out the reflexive address. This exploitation is not very interesting for the attacker. It impacts a single client, which is frequently not the desired target. Moreover, any attacker that can mount the attack could also deny service to the client by other means, such as preventing the client from receiving any response from the STUN server, or even a DHCP server. As with the attack in Section 16.2.1, this attack is only possible when the attacker is on path for packets sent from the STUN server towards this unused IP address.",
      "ja": "この攻撃では、攻撃者が偽造再帰アドレスでSTUNクライアントを提供します。それが提供する再帰アドレスがルートがどこにトランスポートアドレスです。その結果、クライアントは、それが再帰アドレスを渡したときに受信することを期待するパケットのいずれかを受け取ることができません。この開発は、攻撃者にとって非常に興味深いものではありません。それに影響を与える頻繁に所望のターゲットではない単一のクライアント、。また、攻撃を仕掛けることができます任意の攻撃者は、このようなSTUNサーバー、あるいはDHCPサーバからの応答を受信からクライアントを防ぐなど、他の手段によって、クライアントへのサービスを拒否することができます。攻撃者は、この未使用のIPアドレスに向けてSTUNサーバから送信されるパケットのパス上にあるとき、16.2.1項での攻撃と同様に、この攻撃にのみ可能です。"
    },
    {
      "indent": 0,
      "text": "16.2.3. Attack III: Assuming the Identity of a Client",
      "section_title": true,
      "ja": "16.2.3。アタックIII：クライアントのアイデンティティを仮定すると、"
    },
    {
      "indent": 3,
      "text": "This attack is similar to attack II. However, the faked reflexive address points to the attacker itself. This allows the attacker to receive traffic that was destined for the client.",
      "ja": "この攻撃は、攻撃IIに似ています。しかし、攻撃者自身に再帰アドレスポイントを偽造します。これにより、攻撃者は、クライアント宛てたトラフィックを受信することができます。"
    },
    {
      "indent": 0,
      "text": "16.2.4. Attack IV: Eavesdropping",
      "section_title": true,
      "ja": "16.2.4。攻撃IV：盗み聞き"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker forces the client to use a reflexive address that routes to itself. It then forwards any packets it receives to the client. This attack would allow the attacker to observe all packets sent to the client. However, in order to launch the attack, the attacker must have already been able to observe packets from the client to the STUN server. In most cases (such as when the attack is launched from an access network), this means that the attacker could already observe packets sent to the client. This attack is, as a result, only useful for observing traffic by attackers on the path from the client to the STUN server, but not generally on the path of packets being routed towards the client.",
      "ja": "この攻撃では、攻撃者は、自分自身へのルート再帰のアドレスを使用するようにクライアントを強制します。それは、それがクライアントに受け取るすべてのパケットを転送します。この攻撃では、攻撃者がクライアントに送信されたすべてのパケットを観察することができるようになります。しかし、攻撃を開始するためには、攻撃者は、すでにSTUNサーバーへのクライアントからのパケットを観察することができたに違いありません。 （このような攻撃は、アクセスネットワークから起動された場合など）、ほとんどの場合、これは、攻撃者は、すでにクライアントに送信されたパケットを観察することができたことを意味します。この攻撃ではなく、一般的にクライアントに向けてルーティングされたパケットのパス上に、クライアントからSTUNサーバーへのパス上の攻撃者がトラフィックを観察するだけで便利、結果として、あります。"
    },
    {
      "indent": 0,
      "text": "16.3. Hash Agility Plan",
      "section_title": true,
      "ja": "16.3。アジリティプランをハッシュ"
    },
    {
      "indent": 3,
      "text": "This specification uses HMAC-SHA-1 for computation of the message integrity. If, at a later time, HMAC-SHA-1 is found to be compromised, the following is the remedy that will be applied.",
      "ja": "この仕様は、メッセージ整合性の計算のためにHMAC-SHA-1を使用します。後の時点で、HMAC-SHA-1が損なわれることが見出されている、場合、以下が適用される治療薬です。"
    },
    {
      "indent": 3,
      "text": "We will define a STUN extension that introduces a new message-integrity attribute, computed using a new hash. Clients would be required to include both the new and old message-integrity attributes in their requests or indications. A new server will utilize the new message-integrity attribute, and an old one, the old. After a transition period where mixed implementations are in deployment, the old message-integrity attribute will be deprecated by another specification, and clients will cease including it in requests.",
      "ja": "私たちは、新しいハッシュを使用して計算、新しいメッセージの完全性属性を紹介するSTUN拡張を定義します。クライアントが含まれるように必要とされるであろう新旧両方のメッセージの完全性は、彼らの要求や適応症の属性。新しいサーバーは、古いものを新しいメッセージの完全性属性、および古い1つを利用します。混合実装が展開している移行期間後、古いメッセージの完全性属性は、別の仕様で廃止され、クライアントが要求でそれを含めなくなります。"
    },
    {
      "indent": 3,
      "text": "It is also important to note that the HMAC is done using a key that is itself computed using an MD5 of the user's password. The choice of the MD5 hash was made because of the existence of legacy databases that store passwords in that form. If future work finds that an HMAC of an MD5 input is not secure, and a different hash is needed, it can also be changed using this plan. However, this would require administrators to repopulate their databases.",
      "ja": "HMACは、それ自体がユーザーのパスワードのMD5を使用して計算されたキーを使用して行われることに注意することも重要です。 MD5ハッシュの選択は、そのせいで、フォームにパスワードを保存レガシー・データベースの存在で作られました。今後の作業は、MD5入力のHMACが安全ではないことを発見し、そして異なるハッシュが必要な場合、それはまた、この計画を使用して変更することができます。しかし、これは彼らのデータベースを再作成するために、管理者が必要となります。"
    },
    {
      "indent": 0,
      "text": "17. IAB Considerations",
      "section_title": true,
      "ja": "17. IABの考慮事項"
    },
    {
      "indent": 3,
      "text": "The IAB has studied the problem of Unilateral Self-Address Fixing (UNSAF), which is the general process by which a client attempts to determine its address in another realm on the other side of a NAT through a collaborative protocol reflection mechanism (RFC3424 [RFC3424]). STUN can be used to perform this function using a Binding request/response transaction if one agent is behind a NAT and the other is on the public side of the NAT.",
      "ja": "IABは、クライアントが協調プロトコル反射機構（RFC3424 [RFC3424を介してNATの反対側に別の領域にそのアドレスを決定しようとすることによって、一般的なプロセスである片側自アドレス固定（UNSAF）の問題を研究しています]）。一つの薬剤がNATの背後にあり、他方がNATのパブリック側にある場合STUNバインディング要求/応答トランザクションを使用してこの機能を実行するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "The IAB has mandated that protocols developed for this purpose document a specific set of considerations. Because some STUN usages provide UNSAF functions (such as ICE [MMUSIC-ICE] ), and others do not (such as SIP Outbound [SIP-OUTBOUND]), answers to these considerations need to be addressed by the usages themselves.",
      "ja": "IABは、プロトコルは、この目的の文書の検討事項の特定のセットを開発することを義務付けています。いくつかのSTUN用法が（例えばICE [MMUSIC-ICE]など）UNSAF機能を提供し、他の人が（例えばSIP発信[SIP-OUTBOUND]など）していないため、これらの考慮事項への回答は用法自身で対処する必要があります。"
    },
    {
      "indent": 0,
      "text": "18. IANA Considerations",
      "section_title": true,
      "ja": "18. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has created three new registries: a \"STUN Methods Registry\", a \"STUN Attributes Registry\", and a \"STUN Error Codes Registry\". IANA has also changed the name of the assigned IANA port for STUN from \"nat-stun-port\" to \"stun\".",
      "ja": "「STUNは、レジストリの属性」、「STUNメソッドレジストリ」、および「STUNエラーコードレジストリ」：IANA 3つの新しいレジストリを作成しました。 IANAはまた、「スタン」を「NAT-STUN-ポート」からSTUNのために割り当てられたIANAポートの名前を変更しました。"
    },
    {
      "indent": 0,
      "text": "18.1. STUN Methods Registry",
      "section_title": true,
      "ja": "18.1。 STUNメソッドレジストリ"
    },
    {
      "indent": 3,
      "text": "A STUN method is a hex number in the range 0x000 - 0xFFF. The encoding of STUN method into a STUN message is described in Section 6.",
      "ja": "0xFFF  -  STUNメソッドは、範囲$ 000で進数です。 STUNメッセージにSTUN方式の符号化は、セクション6で説明されています。"
    },
    {
      "indent": 3,
      "text": "The initial STUN methods are:",
      "ja": "初期STUN方法は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "0x000: (Reserved) 0x001: Binding 0x002: (Reserved; was SharedSecret)",
      "ja": "$ 000：（予約）0x001：0x002バインディング：（予約;しsharedsecretました）"
    },
    {
      "indent": 3,
      "text": "STUN methods in the range 0x000 - 0x7FF are assigned by IETF Review [RFC5226]. STUN methods in the range 0x800 - 0xFFF are assigned by Designated Expert [RFC5226]. The responsibility of the expert is to verify that the selected codepoint(s) are not in use and that the request is not for an abnormally large number of codepoints. Technical review of the extension itself is outside the scope of the designated expert responsibility.",
      "ja": "範囲$ 000でSTUN方法 -  0x7FFはIETFレビュー[RFC5226]によって割り当てられます。範囲は0x800でSTUN方法 -  0xFFFが指定された専門家[RFC5226]によって割り当てられます。専門家の責任は選択されたコードポイント（複数可）が使用され、要求は、コードポイントの異常に大きな数のためではないことはないことを確認することです。拡張自体の技術的な見直しは、指定された専門家の責任の範囲外です。"
    },
    {
      "indent": 0,
      "text": "18.2. STUN Attribute Registry",
      "section_title": true,
      "ja": "18.2。 STUN属性レジストリ"
    },
    {
      "indent": 3,
      "text": "A STUN Attribute type is a hex number in the range 0x0000 - 0xFFFF. STUN attribute types in the range 0x0000 - 0x7FFF are considered comprehension-required; STUN attribute types in the range 0x8000 - 0xFFFF are considered comprehension-optional. A STUN agent handles unknown comprehension-required and comprehension-optional attributes differently.",
      "ja": "0xFFFFの -  STUN属性タイプは、範囲0000内の進数です。範囲は0x0000でSTUN属性タイプ -  0x7FFFのは理解-必要と考えられています。範囲は0x8000でSTUN属性タイプ -  0xFFFFのは理解-オプションと考えられています。 STUNエージェントは、異なる未知の理解 - 必要と理解-オプションの属性を処理します。"
    },
    {
      "indent": 3,
      "text": "The initial STUN Attributes types are:",
      "ja": "初期STUNは種類がある属性："
    },
    {
      "indent": 3,
      "text": "Comprehension-required range (0x0000-0x7FFF): 0x0000: (Reserved) 0x0001: MAPPED-ADDRESS 0x0002: (Reserved; was RESPONSE-ADDRESS) 0x0003: (Reserved; was CHANGE-ADDRESS) 0x0004: (Reserved; was SOURCE-ADDRESS) 0x0005: (Reserved; was CHANGED-ADDRESS) 0x0006: USERNAME 0x0007: (Reserved; was PASSWORD) 0x0008: MESSAGE-INTEGRITY 0x0009: ERROR-CODE 0x000A: UNKNOWN-ATTRIBUTES 0x000B: (Reserved; was REFLECTED-FROM) 0x0014: REALM 0x0015: NONCE 0x0020: XOR-MAPPED-ADDRESS",
      "ja": "理解-必要な範囲（0x0000-0x7FFF）：0000：（予約）は0x0001：マッピングされたアドレス0×0002：（予約;たRESPONSE-ADDRESS）0x0003：（予約;たCHANGE-ADDRESS）0x0004は：（予約;た元アドレス） 0x0005：（予約; CHANGED-ADDRESSた）0x0006：USERNAME 0x0007：（予約; PASSWORDた）0x0008で：MESSAGE-INTEGRITY 0x0009：エラーコード0x000A：0x000B UNKNOWN-ATTRIBUTES：（予約は、反射からのものであった）0x0014：レルム0x0015 ：NONCE 0x0020に：XOR-MAPPED-ADDRESS"
    },
    {
      "indent": 3,
      "text": "Comprehension-optional range (0x8000-0xFFFF) 0x8022: SOFTWARE 0x8023: ALTERNATE-SERVER 0x8028: FINGERPRINT",
      "ja": "理解-任意の範囲（0x8000-0xFFFF）0x8022：SOFTWARE 0x8023：ALTERNATE-SERVER 0x8028：FINGERPRINT"
    },
    {
      "indent": 3,
      "text": "STUN Attribute types in the first half of the comprehension-required range (0x0000 - 0x3FFF) and in the first half of the comprehension-optional range (0x8000 - 0xBFFF) are assigned by IETF Review [RFC5226]. STUN Attribute types in the second half of the comprehension-required range (0x4000 - 0x7FFF) and in the second half of the comprehension-optional range (0xC000 - 0xFFFF) are assigned by Designated Expert [RFC5226]. The responsibility of the expert is to verify that the selected codepoint(s) are not in use, and that the request is not for an abnormally large number of codepoints. Technical review of the extension itself is outside the scope of the designated expert responsibility.",
      "ja": "理解-任意の範囲（0x8000の -  0xBFFF）の前半に - 理解-必要範囲（0x3FFFの0000）の前半におけるSTUN属性タイプは、IETFレビュー[RFC5226]によって割り当てられます。理解-任意の範囲（0xC000  -  0xFFFFの）の後半 - 理解-必要範囲（は0x7FFF 0x4000の）後半のSTUN属性タイプは、指定された専門家[RFC5226]によって割り当てられます。専門家の責任は選択されたコードポイント（複数可）が使用されていないことを確認することであり、それは要求がコードポイントの異常に大きな数のためではありません。拡張自体の技術的な見直しは、指定された専門家の責任の範囲外です。"
    },
    {
      "indent": 0,
      "text": "18.3. STUN Error Code Registry",
      "section_title": true,
      "ja": "18.3。 STUNエラーコードレジストリ"
    },
    {
      "indent": 3,
      "text": "A STUN error code is a number in the range 0 - 699. STUN error codes are accompanied by a textual reason phrase in UTF-8 [RFC3629] that is intended only for human consumption and can be anything appropriate; this document proposes only suggested values.",
      "ja": "STUNエラーコードは0の範囲内の数である -  699 STUNエラーコードのみ人間の消費のために意図され、適切なものとすることができるUTF-8 [RFC3629]でテキスト理由句を伴います。この文書では、唯一の推奨値を提案しています。"
    },
    {
      "indent": 3,
      "text": "STUN error codes are consistent in codepoint assignments and semantics with SIP [RFC3261] and HTTP [RFC2616].",
      "ja": "STUNエラーコードはSIP [RFC3261]とHTTP [RFC2616]とコードポイントの割り当てと意味で一貫しています。"
    },
    {
      "indent": 3,
      "text": "The initial values in this registry are given in Section 15.6.",
      "ja": "このレジストリ内の初期値は、15.6節に記載されています。"
    },
    {
      "indent": 3,
      "text": "New STUN error codes are assigned based on IETF Review [RFC5226]. The specification must carefully consider how clients that do not understand this error code will process it before granting the request. See the rules in Section 7.3.4.",
      "ja": "新しいSTUNエラーコードはIETFレビュー[RFC5226]に基づいて割り当てられます。仕様は、慎重にこのエラーコードを理解していないクライアントが要求を許可する前に、それを処理する方法を検討しなければなりません。 7.3.4項でルールを参照してください。"
    },
    {
      "indent": 0,
      "text": "18.4. STUN UDP and TCP Port Numbers",
      "section_title": true,
      "ja": "18.4。 UDPとTCPポート番号をSTUN"
    },
    {
      "indent": 3,
      "text": "IANA has previously assigned port 3478 for STUN. This port appears in the IANA registry under the moniker \"nat-stun-port\". In order to align the DNS SRV procedures with the registered protocol service, IANA is requested to change the name of protocol assigned to port 3478 from \"nat-stun-port\" to \"stun\", and the textual name from \"Simple Traversal of UDP Through NAT (STUN)\" to \"Session Traversal Utilities for NAT\", so that the IANA port registry would read:",
      "ja": "IANAは以前STUNのためにポート3478を割り当てています。このポートはあだ名「NAT-スタン・ポート」の下でIANAレジストリに表示されます。登録されたプロトコルサービスとDNSのSRV手順を合わせるために、IANAは、「NAT-スタン・ポート」に「スタン」からポート3478に割り当てられたプロトコルの名前を変更するように要求され、およびUDPのシンプルトラバーサル」からテキスト名NAT（STUN）」を 『セッショントラバーサルユーティリティNATについて』、IANAポートレジストリを読んでいましたように、通過："
    },
    {
      "indent": 3,
      "text": "stun 3478/tcp Session Traversal Utilities for NAT (STUN) port stun 3478/udp Session Traversal Utilities for NAT (STUN) port",
      "ja": "NAT（STUN）ポートスタン3478 / NATのUDPセッショントラバーサルユーティリティ（STUN）ポートの3478 / tcpのセッショントラバーサルユーティリティスタン"
    },
    {
      "indent": 3,
      "text": "In addition, IANA has assigned port number 5349 for the \"stuns\" service, defined over TCP and UDP. The UDP port is not currently defined; however, it is reserved for future use.",
      "ja": "また、IANAはTCPとUDPの上に定義された「スタン」サービス用のポート番号5349が割り当てられています。 UDPポートは現在定義されていません。しかし、それは将来の使用のために予約されています。"
    },
    {
      "indent": 1,
      "text": "19. Changes since",
      "section_title": true,
      "ja": "19.からの変更点"
    },
    {
      "indent": 3,
      "text": "This specification obsoletes RFC 3489 [RFC3489]. This specification differs from RFC 3489 in the following ways:",
      "ja": "この仕様はRFC 3489 [RFC3489]を廃止します。この仕様は、次の方法でRFC 3489と異なります。"
    },
    {
      "indent": 3,
      "text": "o Removed the notion that STUN is a complete NAT traversal solution. STUN is now a tool that can be used to produce a NAT traversal solution. As a consequence, changed the name of the protocol to Session Traversal Utilities for NAT.",
      "ja": "O STUNが完全なNATトラバーサルソリューションであるという概念を削除しました。 STUNは現在、NATトラバーサルソリューションを生成するために使用することができるツールです。結果として、NATのセッショントラバーサルユーティリティへのプロトコルの名前を変更しました。"
    },
    {
      "indent": 3,
      "text": "o Introduced the concept of STUN usages, and described what a usage of STUN must document.",
      "ja": "O STUN用法の概念を導入し、そしてSTUNの用法は文書化しなければならないものを説明しました。"
    },
    {
      "indent": 3,
      "text": "o Removed the usage of STUN for NAT type detection and binding lifetime discovery. These techniques have proven overly brittle due to wider variations in the types of NAT devices than described in this document. Removed the RESPONSE-ADDRESS, CHANGED-ADDRESS, CHANGE-REQUEST, SOURCE-ADDRESS, and REFLECTED-FROM attributes.",
      "ja": "O NATタイプ検出と結合寿命の発見のためのSTUNの使用を削除しました。これらの技術は、これによる文書で説明よりも、NATデバイスのタイプで、より広い変動に過度に脆性であることが判明しました。 RESPONSE-ADDRESS、CHANGED-ADDRESS、CHANGE-REQUEST、SOURCE-ADDRESSを削除し、その反射-からの属性。"
    },
    {
      "indent": 3,
      "text": "o Added a fixed 32-bit magic cookie and reduced length of transaction ID by 32 bits. The magic cookie begins at the same offset as the original transaction ID.",
      "ja": "Oは、固定32ビットのマジッククッキーを添加し、32ビットのトランザクションIDの長さを減少させました。マジッククッキーは、元のトランザクションIDと同じオフセットで始まります。"
    },
    {
      "indent": 3,
      "text": "o Added the XOR-MAPPED-ADDRESS attribute, which is included in Binding responses if the magic cookie is present in the request. Otherwise, the RFC 3489 behavior is retained (that is, Binding response includes MAPPED-ADDRESS). See discussion in XOR-MAPPED-ADDRESS regarding this change.",
      "ja": "Oマジッククッキーがリクエストに存在する場合にバインディングレスポンスに含まれているXOR-MAPPED-ADDRESS属性を追加しました。そうでない場合は、RFC 3489の挙動（つまり、バインディング応答がマッピング・アドレスを含む）が保持されています。この変更に関するXOR-MAPPED-ADDRESSでの議論を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Introduced formal structure into the message type header field, with an explicit pair of bits for indication of request, response, error response, or indication. Consequently, the message type field is split into the class (one of the previous four) and method.",
      "ja": "O要求、応答、エラー応答、または表示の指示のためのビットの明示的な対と、メッセージタイプヘッダフィールドに形式的な構造を導入しました。したがって、メッセージ・タイプ・フィールドは、クラス（前の4つのうちの1つ）とメソッドに分割されます。"
    },
    {
      "indent": 3,
      "text": "o Explicitly point out that the most significant 2 bits of STUN are 0b00, allowing easy differentiation with RTP packets when used with ICE.",
      "ja": "O明示的STUNの最上位2ビットが氷で使用される場合、RTPパケットで簡単に区別を可能に0b00とされていることを指摘します。"
    },
    {
      "indent": 3,
      "text": "o Added the FINGERPRINT attribute to provide a method of definitely detecting the difference between STUN and another protocol when the two protocols are multiplexed together.",
      "ja": "O FINGERPRINTは間違いなくSTUNと2つのプロトコルが一緒に多重化された別のプロトコルとの間の差を検出する方法を提供する属性を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Added support for IPv6. Made it clear that an IPv4 client could get a v6 mapped address, and vice versa.",
      "ja": "O IPv6のサポートを追加しました。それはV6を得ることができたIPv4クライアントがアドレスをマッピングされた明確なことをなされ、その逆も同様です。"
    },
    {
      "indent": 3,
      "text": "o Added long-term-credential-based authentication.",
      "ja": "O長期-資格情報ベースの認証を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Added the SOFTWARE, REALM, NONCE, and ALTERNATE-SERVER attributes.",
      "ja": "O SOFTWARE、REALM、NONCE、とALTERNATE-SERVER属性を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Removed the SharedSecret method, and thus the PASSWORD attribute. This method was almost never implemented and is not needed with current usages.",
      "ja": "Oしsharedsecret方法、ひいてはPASSWORD属性を削除しました。この方法は、ほとんど実装されていませんでしたし、現在の用途で必要とされていません。"
    },
    {
      "indent": 3,
      "text": "o Removed recommendation to continue listening for STUN responses for 10 seconds in an attempt to recognize an attack.",
      "ja": "O攻撃を認識しようとする試みで10秒間STUN応答を待機し続けるための勧告を削除しました。"
    },
    {
      "indent": 3,
      "text": "o Changed transaction timers to be more TCP friendly.",
      "ja": "OよりTCPフレンドリーであることをトランザクションタイマーを変更しました。"
    },
    {
      "indent": 3,
      "text": "o Removed the STUN example that centered around the separation of the control and media planes. Instead, provided more information on using STUN with protocols.",
      "ja": "O制御およびメディア・プレーンの分離を中心STUN例を削除。代わりに、プロトコルでSTUNの使用に関する詳細な情報を提供します。"
    },
    {
      "indent": 3,
      "text": "o Defined a generic padding mechanism that changes the interpretation of the length attribute. This would, in theory, break backwards compatibility. However, the mechanism in RFC 3489 never worked for the few attributes that weren't aligned naturally on 32-bit boundaries.",
      "ja": "O長さ属性の解釈を変更する一般的なパディングメカニズムを定義しました。これは、理論的には、下位互換性を破ります。しかし、RFC 3489でのメカニズムは、32ビット境界に自然にアラインされていないいくつかの属性のために働いたことはありません。"
    },
    {
      "indent": 3,
      "text": "o REALM, SERVER, reason phrases, and NONCE limited to 127 characters. USERNAME to 513 bytes.",
      "ja": "O REALM、サーバ、理由句、および127文字に制限さNONCE。 513バイトにUSERNAME。"
    },
    {
      "indent": 3,
      "text": "o Changed the DNS SRV procedures for TCP and TLS. UDP remains the same as before.",
      "ja": "O TCPおよびTLSのDNS SRV手順を変更しました。 UDPは以前と同じまま。"
    },
    {
      "indent": 0,
      "text": "20. Contributors",
      "section_title": true,
      "ja": "20.協力者"
    },
    {
      "indent": 3,
      "text": "Christian Huitema and Joel Weinberger were original co-authors of RFC 3489.",
      "ja": "クリスチャンのHuitemaとジョエル・ワインバーガーは、RFC 3489の元の共著者でした。"
    },
    {
      "indent": 0,
      "text": "21. Acknowledgements",
      "section_title": true,
      "ja": "21.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Cedric Aoun, Pete Cordell, Cullen Jennings, Bob Penfield, Xavier Marjou, Magnus Westerlund, Miguel Garcia, Bruce Lowekamp, and Chris Sullivan for their comments, and Baruch Sterman and Alan Hawrylyshen for initial implementations. Thanks for Leslie Daigle, Allison Mankin, Eric Rescorla, and Henning Schulzrinne for IESG and IAB input on this work.",
      "ja": "著者は、初期の実装のためのセドリックアウン、ピートコーデル、カレン・ジェニングス、ボブペンフィールド、ザビエルMarjou、マグヌスウェスター、ミゲル・ガルシア、ブルースLowekamp、そしてクリス・サリバン彼らのコメントのために、とバルークStermanとアランHawrylyshenに感謝したいと思います。レスリーDaigle氏、アリソンマンキン、エリックレスコラ、およびIESGのためのヘニングSchulzrinneとし、この作品のIAB入力いただきありがとうございます。"
    },
    {
      "indent": 0,
      "text": "22. References",
      "section_title": true,
      "ja": "22.参考文献"
    },
    {
      "indent": 0,
      "text": "22.1. Normative References",
      "section_title": true,
      "ja": "22.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[ITU.V42.2002] International Telecommunications Union, \"Error-correcting Procedures for DCEs Using Asynchronous-to-Synchronous Conversion\", ITU-T Recommendation V.42, March 2002.",
      "ja": "、ITU-T勧告V.42、2002年3月[ITU.V42.2002]国際電気通信連合、「非同期ツー同期変換を使用してのDCEのエラー訂正手順」。"
    },
    {
      "indent": 3,
      "text": "[RFC0791] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "ja": "[RFC0791]ポステル、J.、 \"インターネットプロトコル\"、STD 5、RFC 791、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122]ブレーデン、R.、 \"インターネットホストのための要件 - 通信層\"、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1321] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[RFC1321]のRivest、R.、 \"MD5メッセージダイジェストアルゴリズム\"、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC2460]デアリング、S.とR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の仕様\"、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2617] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, \"HTTP Authentication: Basic and Digest Access Authentication\", RFC 2617, June 1999.",
      "ja": "[RFC2617]フランクス、J.、ハラム・ベイカー、P.、Hostetler、J.、ローレンス、S.、リーチ、P.、Luotonen、A.、およびL.スチュワート、 \"HTTP認証：基本とダイジェストアクセス認証\" 、RFC 2617、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, February 2000.",
      "ja": "[RFC2782] Gulbrandsenの、A.、いるVixie、P.、およびL. Esibov、 \"サービスの場所を特定するためのDNS RR（DNSのSRV）\"、RFC 2782、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.",
      "ja": "[RFC2818]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2988] Paxson, V. and M. Allman, \"Computing TCP's Retransmission Timer\", RFC 2988, November 2000.",
      "ja": "[RFC2988]パクソン、V.とM.オールマン、 \"コンピューティングTCPの再送信タイマー\"、RFC 2988、2000年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4013] Zeilenga, K., \"SASLprep: Stringprep Profile for User Names and Passwords\", RFC 4013, February 2005.",
      "ja": "[RFC4013] Zeilenga、K.、 \"SASLprep：ユーザ名とパスワードのためのstringprepプロフィール\"、RFC 4013、2005年2月。"
    },
    {
      "indent": 0,
      "text": "22.2. Informative References",
      "section_title": true,
      "ja": "22.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[BEHAVE-NAT] MacDonald, D. and B. Lowekamp, \"NAT Behavior Discovery Using STUN\", Work in Progress, July 2008.",
      "ja": "[BEHAVE-NAT]マクドナルド、D.とB. Lowekamp、 \"NAT挙動検出STUNを使用する\"、進歩、2008年7月に作業。"
    },
    {
      "indent": 3,
      "text": "[BEHAVE-TURN] Rosenberg, J., Mahy, R., and P. Matthews, \"Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)\", Work in Progress, July 2008.",
      "ja": "[BEHAVE-TURN]ローゼンバーグ、J.、マーイ、R.、およびP.マシューズ、 \"トラバーサルNAT（TURN）の周りにリレーを使用する：NAT（STUN）のセッショントラバーサルユーティリティにリレー拡張機能\"、進歩、2008年7月に仕事を。"
    },
    {
      "indent": 3,
      "text": "[KARN87] Karn, P. and C. Partridge, \"Improving Round-Trip Time Estimates in Reliable Transport Protocols\", SIGCOMM 1987, August 1987.",
      "ja": "[KARN87]カーン、P.とC.ヤマウズラ、「信頼性の高いトランスポートプロトコルにラウンドトリップ時間の見積りの改善」、SIGCOMM 1987、1987年8月。"
    },
    {
      "indent": 3,
      "text": "[MMUSIC-ICE] Rosenberg, J., \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols\", Work in Progress, October 2007.",
      "ja": "[MUSIC-ICE]ローゼンバーグ、J.、 \"インタラクティブ接続確立（ICE）：オファー/回答プロトコルのためのネットワークアドレス変換（NAT）トラバーサルのための議定書\"、進歩、2007年10月の作業。"
    },
    {
      "indent": 3,
      "text": "[MMUSIC-ICE-TCP] Rosenberg, J., \"TCP Candidates with Interactive Connectivity Establishment (ICE)\", Work in Progress, July 2008.",
      "ja": "[MUSIC-ICE-TCP]ローゼンバーグ、J.、進歩、2008年7月に仕事 \"インタラクティブ接続確立（ICE）とのTCP候補\"。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[RFC3261]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 \"SIP：セッション開始プロトコル\" 、RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3264] Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model with Session Description Protocol (SDP)\", RFC 3264, June 2002.",
      "ja": "[RFC3264]ローゼンバーグ、J.とH. Schulzrinneと、RFC 3264、2002年6月 \"セッション記述プロトコル（SDP）とのオファー/アンサーモデル\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3424] Daigle, L. and IAB, \"IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation\", RFC 3424, November 2002.",
      "ja": "、RFC 3424、2002年11月、 \"ネットワークアドレス変換アクロス一方的な自己アドレス固定するためのIABの考慮事項（UNSAF）\" [RFC3424] Daigle氏、L.とIAB、。"
    },
    {
      "indent": 3,
      "text": "[RFC3489] Rosenberg, J., Weinberger, J., Huitema, C., and R. Mahy, \"STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)\", RFC 3489, March 2003.",
      "ja": "[RFC3489]ローゼンバーグ、J.、ワインバーガー、J.、のHuitema、C.、およびR.マーイ、 -  2003年3月、RFC 3489 \"STUNネットワークを介して、ユーザーデータグラムプロトコル（UDP）の簡単なトラバーサルは、翻訳者（NATのを）アドレス\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4107] Bellovin, S. and R. Housley, \"Guidelines for Cryptographic Key Management\", BCP 107, RFC 4107, June 2005.",
      "ja": "[RFC4107] Bellovin氏、S.とR. Housley氏、 \"暗号鍵管理のためのガイドライン\"、BCP 107、RFC 4107、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[SIP-OUTBOUND] Jennings, C. and R. Mahy, \"Managing Client Initiated Connections in the Session Initiation Protocol (SIP)\", Work in Progress, June 2008.",
      "ja": "[SIP-OUTBOUND]ジェニングス、C.とR.マーイ、進歩、2008年6月の作業「セッション開始プロトコル（SIP）でのクライアント開始された接続の管理」を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix A. C Snippet to Determine STUN Message Types",
      "ja": "STUNメッセージタイプを決定するために付録A. Cスニペット"
    },
    {
      "indent": 3,
      "text": "Given a 16-bit STUN message type value in host byte order in msg_type parameter, below are C macros to determine the STUN message types:",
      "ja": "MSG_TYPEパラメータでホストバイト順の16ビットSTUNメッセージタイプ値を与えられた、以下STUNメッセージタイプを決定するために、Cマクロは、以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "#define IS_REQUEST(msg_type) (((msg_type) & 0x0110) == 0x0000) #define IS_INDICATION(msg_type) (((msg_type) & 0x0110) == 0x0010) #define IS_SUCCESS_RESP(msg_type) (((msg_type) & 0x0110) == 0x0100) #define IS_ERR_RESP(msg_type) (((msg_type) & 0x0110) == 0x0110)",
      "ja": "#define IS_REQUEST（MSG_TYPE）（（（MSG_TYPE）＆0x0110）== 0×0000）の#define IS_INDICATION（MSG_TYPE）（（（MSG_TYPE）＆0x0110）== 0x0010）の#define IS_SUCCESS_RESP（MSG_TYPE）（（（MSG_TYPE）＆0x0110） ==は0x0100）の#define IS_ERR_RESP（MSG_TYPE）（（（MSG_TYPE）＆0x0110）== 0x0110）"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Jonathan Rosenberg Cisco Edison, NJ US",
      "ja": "ジョナサン・ローゼンバーグシスコエジソン、NJ US"
    },
    {
      "indent": 3,
      "text": "EMail: jdrosen@cisco.com URI: http://www.jdrosen.net",
      "ja": "電子メール：jdrosen@cisco.com URI：http://www.jdrosen.net"
    },
    {
      "indent": 3,
      "text": "Rohan Mahy Unaffiliated",
      "ja": "ロハンマーイ無所属"
    },
    {
      "indent": 3,
      "text": "EMail: rohan@ekabal.com",
      "ja": "メールアドレス：rohan@ekabal.com"
    },
    {
      "indent": 3,
      "text": "Philip Matthews Unaffiliated",
      "ja": "フィリップ・マシューズ無所属"
    },
    {
      "indent": 3,
      "text": "EMail: philip_matthews@magma.ca",
      "ja": "メールアドレス：philip_matthews@magma.ca"
    },
    {
      "indent": 3,
      "text": "Dan Wing Cisco 771 Alder Drive San Jose, CA 95035 US",
      "ja": "ダン・ウィングのCisco 771アルダードライブサンノゼ、CA 95035米国"
    },
    {
      "indent": 3,
      "text": "EMail: dwing@cisco.com",
      "ja": "メールアドレス：dwing@cisco.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2008).",
      "ja": "著作権（C）IETFトラスト（2008）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットSOCIETY、（もしあれば）を後援し、IETF TRUST ANDインターネットエンジニアリングタスクフォース放棄ALLに設けられています。保証は、明示または黙示、この情報の利用および特定目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証がこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    }
  ]
}