{
  "title": {
    "text": "RFC 5201 - Host Identity Protocol",
    "ja": "RFC 5201 - アイデンティティプロトコルホスト"
  },
  "number": 5201,
  "created_at": "2019-10-24 14:14:29.563426+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       R. Moskowitz\nRequest for Comments: 5201                                      ICSAlabs\nCategory: Experimental                                       P. Nikander\n                                                          P. Jokela, Ed.\n                                            Ericsson Research NomadicLab\n                                                            T. Henderson\n                                                      The Boeing Company\n                                                              April 2008",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Host Identity Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのためにExperimentalプロトコルを定義します。それはどんな種類のインターネット標準を指定しません。改善のための議論や提案が要求されています。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "IESG Note",
      "ja": "IESG注意"
    },
    {
      "indent": 3,
      "text": "The following issues describe IESG concerns about this document. The IESG expects that these issues will be addressed when future versions of HIP are designed.",
      "ja": "次の問題は、この文書についてIESGの懸念を説明します。 IESGはHIPの将来のバージョンが設計されている場合、これらの問題に対処されることを期待しています。"
    },
    {
      "indent": 3,
      "text": "This document doesn't currently define support for parameterized (randomized) hashing in signatures, support for negotiation of a key derivation function, or support for combined encryption modes.",
      "ja": "この文書では、現在、パラメータ化（無作為化）のためのサポートを定義する署名にハッシング、鍵導出関数の交渉のためのサポート、または組み合わせて暗号化モードをサポートしていません。"
    },
    {
      "indent": 3,
      "text": "HIP defines the usage of RSA in signing and encrypting data. Current recommendations propose usage of, for example, RSA OAEP/PSS for these operations in new protocols. Changing the algorithms to more current best practice should be considered.",
      "ja": "HIPは、署名し、データの暗号化にRSAの使用を定義します。現在の推奨事項は、新しいプロトコルでこれらの操作のために例えば、RSA OAEP / PSSの使用を提案しています。より多くの現在のベストプラクティスにアルゴリズムを変更することは考慮されるべきです。"
    },
    {
      "indent": 3,
      "text": "The current specification is currently using HMAC for message authentication. This is considered to be acceptable for an experimental RFC, but future versions must define a more generic method for message authentication, including the ability for other MAC algorithms to be used.",
      "ja": "現在の仕様では、現在、メッセージ認証のためのHMACを使用しています。これは実験的RFCのために許容できると考えられているが、将来のバージョンが使用される他のMACアルゴリズムの能力を含む、メッセージ認証のためのより一般的な方法を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "SHA-1 is no longer a preferred hashing algorithm. This is noted also by the authors, and it is understood that future, non-experimental versions must consider more secure hashing algorithms.",
      "ja": "SHA-1はもはや好適ハッシュアルゴリズムではありません。これは著者によっても指摘され、将来、非実験バージョンは、より安全なハッシュアルゴリズムを考慮しなければならないことが理解されます。"
    },
    {
      "indent": 3,
      "text": "HIP requires that an incoming packet's IP address be ignored. In simple cases this can be done, but when there are security policies based on incoming interface or IP address rules, the situation changes. The handling of data needs to be enhanced to cover different types of network and security configurations, as well as to meet local security policies.",
      "ja": "HIPは、着信パケットのIPアドレスが無視されている必要があります。簡単な例では、これを行うことができますが、着信インターフェイスまたはIPアドレスルールに基づいてセキュリティポリシーがある場合には、状況が変化します。データの取り扱いは、ネットワークおよびセキュリティ設定の異なる種類をカバーするだけでなく、ローカルセキュリティポリシーを満たすために強化する必要があります。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo specifies the details of the Host Identity Protocol (HIP). HIP allows consenting hosts to securely establish and maintain shared IP-layer state, allowing separation of the identifier and locator roles of IP addresses, thereby enabling continuity of communications across IP address changes. HIP is based on a Sigma-compliant Diffie-Hellman key exchange, using public key identifiers from a new Host Identity namespace for mutual peer authentication. The protocol is designed to be resistant to denial-of-service (DoS) and man-in-the-middle (MitM) attacks. When used together with another suitable security protocol, such as the Encapsulated Security Payload (ESP), it provides integrity protection and optional encryption for upper-layer protocols, such as TCP and UDP.",
      "ja": "このメモは、ホストアイデンティティプロトコル（HIP）の詳細を指定します。 HIPは、確実に、共有IPレイヤの状態を確立し、維持するためにホストを同意IPアドレスの識別子及びロケータの役割の分離を可能にすることにより、IPアドレスの変更を横切って通信の継続を可能にすることができます。 HIPは、相互ピア認証用の新しいホストアイデンティティ名前空間から公開鍵識別子を使用して、シグマ準拠のDiffie-Hellman鍵交換に基づいています。プロトコルは、サービス拒否（DOS）とMITM（中間者）攻撃に対して耐性があるように設計されています。そのようなカプセル化セキュリティペイロード（ESP）などの別の適切なセキュリティプロトコル、と一緒に使用する場合、そのようなTCPやUDPなどの上位層プロトコルのための完全性保護およびオプションの暗号化を提供します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   5\n  1.1.  A New Namespace and Identifiers . . . . . . . . . . . . .   5\n  1.2.  The HIP Base Exchange . . . . . . . . . . . . . . . . . .   6\n  1.3.  Memo Structure  . . . . . . . . . . . . . . . . . . . . .   7\n2.  Terms and Definitions . . . . . . . . . . . . . . . . . . . .   7\n  2.1.  Requirements Terminology  . . . . . . . . . . . . . . . .   7\n  2.2.  Notation  . . . . . . . . . . . . . . . . . . . . . . . .   7\n  2.3.  Definitions . . . . . . . . . . . . . . . . . . . . . . .   7\n3.  Host Identifier (HI) and Its Representations  . . . . . . . .   8\n  3.1.  Host Identity Tag (HIT) . . . . . . . . . . . . . . . . .   9\n  3.2.  Generating a HIT from an HI . . . . . . . . . . . . . . .   9\n4.  Protocol Overview . . . . . . . . . . . . . . . . . . . . . .  10\n  4.1.  Creating a HIP Association  . . . . . . . . . . . . . . .  10\n    4.1.1.  HIP Puzzle Mechanism  . . . . . . . . . . . . . . . .  12\n    4.1.2.  Puzzle Exchange . . . . . . . . . . . . . . . . . . .  13\n    4.1.3.  Authenticated Diffie-Hellman Protocol . . . . . . . .  14\n    4.1.4.  HIP Replay Protection . . . . . . . . . . . . . . . .  14\n    4.1.5.  Refusing a HIP Exchange . . . . . . . . . . . . . . .  15\n    4.1.6.  HIP Opportunistic Mode  . . . . . . . . . . . . . . .  16\n  4.2.  Updating a HIP Association  . . . . . . . . . . . . . . .  18\n  4.3.  Error Processing  . . . . . . . . . . . . . . . . . . . .  18\n  4.4.  HIP State Machine . . . . . . . . . . . . . . . . . . . .  19\n    4.4.1.  HIP States  . . . . . . . . . . . . . . . . . . . . .  20\n    4.4.2.  HIP State Processes . . . . . . . . . . . . . . . . .  21\n    4.4.3.  Simplified HIP State Diagram  . . . . . . . . . . . .  28\n  4.5.  User Data Considerations  . . . . . . . . . . . . . . . .  30\n    4.5.1.  TCP and UDP Pseudo-Header Computation for User Data .  30",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    4.5.2.  Sending Data on HIP Packets . . . . . . . . . . . . .  30\n    4.5.3.  Transport Formats . . . . . . . . . . . . . . . . . .  30\n    4.5.4.  Reboot and SA Timeout Restart of HIP  . . . . . . . .  30\n  4.6.  Certificate Distribution  . . . . . . . . . . . . . . . .  31\n5.  Packet Formats  . . . . . . . . . . . . . . . . . . . . . . .  31\n  5.1.  Payload Format  . . . . . . . . . . . . . . . . . . . . .  31\n    5.1.1.  Checksum  . . . . . . . . . . . . . . . . . . . . . .  33\n    5.1.2.  HIP Controls  . . . . . . . . . . . . . . . . . . . .  33\n    5.1.3.  HIP Fragmentation Support . . . . . . . . . . . . . .  33\n  5.2.  HIP Parameters  . . . . . . . . . . . . . . . . . . . . .  34\n    5.2.1.  TLV Format  . . . . . . . . . . . . . . . . . . . . .  37\n    5.2.2.  Defining New Parameters . . . . . . . . . . . . . . .  38\n    5.2.3.  R1_COUNTER  . . . . . . . . . . . . . . . . . . . . .  39\n    5.2.4.  PUZZLE  . . . . . . . . . . . . . . . . . . . . . . .  40\n    5.2.5.  SOLUTION  . . . . . . . . . . . . . . . . . . . . . .  41\n    5.2.6.  DIFFIE_HELLMAN  . . . . . . . . . . . . . . . . . . .  42\n    5.2.7.  HIP_TRANSFORM . . . . . . . . . . . . . . . . . . . .  43\n    5.2.8.  HOST_ID . . . . . . . . . . . . . . . . . . . . . . .  44\n    5.2.9.  HMAC  . . . . . . . . . . . . . . . . . . . . . . . .  45\n    5.2.10. HMAC_2  . . . . . . . . . . . . . . . . . . . . . . .  46\n    5.2.11. HIP_SIGNATURE . . . . . . . . . . . . . . . . . . . .  46\n    5.2.12. HIP_SIGNATURE_2 . . . . . . . . . . . . . . . . . . .  47\n    5.2.13. SEQ . . . . . . . . . . . . . . . . . . . . . . . . .  48\n    5.2.14. ACK . . . . . . . . . . . . . . . . . . . . . . . . .  48\n    5.2.15. ENCRYPTED . . . . . . . . . . . . . . . . . . . . . .  49\n    5.2.16. NOTIFICATION  . . . . . . . . . . . . . . . . . . . .  50\n    5.2.17. ECHO_REQUEST_SIGNED . . . . . . . . . . . . . . . . .  54\n    5.2.18. ECHO_REQUEST_UNSIGNED . . . . . . . . . . . . . . . .  54\n    5.2.19. ECHO_RESPONSE_SIGNED  . . . . . . . . . . . . . . . .  55\n    5.2.20. ECHO_RESPONSE_UNSIGNED  . . . . . . . . . . . . . . .  56\n  5.3.  HIP Packets . . . . . . . . . . . . . . . . . . . . . . .  56\n    5.3.1.  I1 - the HIP Initiator Packet . . . . . . . . . . . .  58\n    5.3.2.  R1 - the HIP Responder Packet . . . . . . . . . . . .  58\n    5.3.3.  I2 - the Second HIP Initiator Packet  . . . . . . . .  61\n    5.3.4.  R2 - the Second HIP Responder Packet  . . . . . . . .  62\n    5.3.5.  UPDATE - the HIP Update Packet  . . . . . . . . . . .  62\n    5.3.6.  NOTIFY - the HIP Notify Packet  . . . . . . . . . . .  63\n    5.3.7.  CLOSE - the HIP Association Closing Packet  . . . . .  64\n    5.3.8.  CLOSE_ACK - the HIP Closing Acknowledgment Packet . .  64\n  5.4.  ICMP Messages . . . . . . . . . . . . . . . . . . . . . .  65\n    5.4.1.  Invalid Version . . . . . . . . . . . . . . . . . . .  65\n    5.4.2.  Other Problems with the HIP Header and Packet\n            Structure . . . . . . . . . . . . . . . . . . . . . .  65\n    5.4.3.  Invalid Puzzle Solution . . . . . . . . . . . . . . .  65\n    5.4.4.  Non-Existing HIP Association  . . . . . . . . . . . .  66\n6.  Packet Processing . . . . . . . . . . . . . . . . . . . . . .  66\n  6.1.  Processing Outgoing Application Data  . . . . . . . . . .  66\n  6.2.  Processing Incoming Application Data  . . . . . . . . . .  67",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  6.3.  Solving the Puzzle  . . . . . . . . . . . . . . . . . . .  68\n  6.4.  HMAC and SIGNATURE Calculation and Verification . . . . .  70\n    6.4.1.  HMAC Calculation  . . . . . . . . . . . . . . . . . .  70\n    6.4.2.  Signature Calculation . . . . . . . . . . . . . . . .  72\n  6.5.  HIP KEYMAT Generation . . . . . . . . . . . . . . . . . .  74\n  6.6.  Initiation of a HIP Exchange  . . . . . . . . . . . . . .  75\n    6.6.1.  Sending Multiple I1s in Parallel  . . . . . . . . . .  76\n    6.6.2.  Processing Incoming ICMP Protocol Unreachable\n            Messages  . . . . . . . . . . . . . . . . . . . . . .  77\n  6.7.  Processing Incoming I1 Packets  . . . . . . . . . . . . .  77\n    6.7.1.  R1 Management . . . . . . . . . . . . . . . . . . . .  78\n    6.7.2.  Handling Malformed Messages . . . . . . . . . . . . .  79\n  6.8.  Processing Incoming R1 Packets  . . . . . . . . . . . . .  79\n    6.8.1.  Handling Malformed Messages . . . . . . . . . . . . .  81\n  6.9.  Processing Incoming I2 Packets  . . . . . . . . . . . . .  81\n    6.9.1.  Handling Malformed Messages . . . . . . . . . . . . .  84\n  6.10. Processing Incoming R2 Packets  . . . . . . . . . . . . .  84\n  6.11. Sending UPDATE Packets  . . . . . . . . . . . . . . . . .  84\n  6.12. Receiving UPDATE Packets  . . . . . . . . . . . . . . . .  85\n    6.12.1. Handling a SEQ Parameter in a Received UPDATE\n            Message . . . . . . . . . . . . . . . . . . . . . . .  86\n    6.12.2. Handling an ACK Parameter in a Received UPDATE\n            Packet  . . . . . . . . . . . . . . . . . . . . . . .  87\n  6.13. Processing NOTIFY Packets . . . . . . . . . . . . . . . .  87\n  6.14. Processing CLOSE Packets  . . . . . . . . . . . . . . . .  88\n  6.15. Processing CLOSE_ACK Packets  . . . . . . . . . . . . . .  88\n  6.16. Handling State Loss . . . . . . . . . . . . . . . . . . .  88\n7.  HIP Policies  . . . . . . . . . . . . . . . . . . . . . . . .  89\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  89\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  92\n10. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  93\n11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  95\n  11.1. Normative References  . . . . . . . . . . . . . . . . . .  95\n  11.2. Informative References  . . . . . . . . . . . . . . . . .  96\nAppendix A.  Using Responder Puzzles  . . . . . . . . . . . . . .  98\nAppendix B.  Generating a Public Key Encoding from an HI  . . . .  99\nAppendix C.  Example Checksums for HIP Packets  . . . . . . . . . 100\n  C.1.  IPv6 HIP Example (I1) . . . . . . . . . . . . . . . . . . 100\n  C.2.  IPv4 HIP Packet (I1)  . . . . . . . . . . . . . . . . . . 100\n  C.3.  TCP Segment . . . . . . . . . . . . . . . . . . . . . . . 101\nAppendix D.  384-Bit Group  . . . . . . . . . . . . . . . . . . . 101\nAppendix E.  OAKLEY Well-Known Group 1  . . . . . . . . . . . . . 102",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This memo specifies the details of the Host Identity Protocol (HIP). A high-level description of the protocol and the underlying architectural thinking is available in the separate HIP architecture description [RFC4423]. Briefly, the HIP architecture proposes an alternative to the dual use of IP addresses as \"locators\" (routing labels) and \"identifiers\" (endpoint, or host, identifiers). In HIP, public cryptographic keys, of a public/private key pair, are used as Host Identifiers, to which higher layer protocols are bound instead of an IP address. By using public keys (and their representations) as host identifiers, dynamic changes to IP address sets can be directly authenticated between hosts, and if desired, strong authentication between hosts at the TCP/IP stack level can be obtained.",
      "ja": "このメモは、ホストアイデンティティプロトコル（HIP）の詳細を指定します。プロトコルと根底にある建築思考の高レベルの記述は、別個のHIPアーキテクチャ記述[RFC4423]で入手可能です。簡単に言えば、HIPアーキテクチャは、「ロケータ」（ルーティングラベル）と「識別子」（エンドポイント、またはホスト、識別子）などのIPアドレスの二重使用に代わるものを提案しています。 HIPでは、公開暗号鍵は、公開鍵/秘密鍵のペアを、その上位層プロトコルは、IPアドレスの代わりにバインドされているために、ホスト識別子として使用されています。ホスト識別子としての公開鍵（およびその表現）を使用して、IPアドレス設定の動的な変更は、直接ホストとの間で認証することができ、必要に応じて、TCP / IPスタックレベルでホストとの間の強力な認証を得ることができます。"
    },
    {
      "indent": 3,
      "text": "This memo specifies the base HIP protocol (\"base exchange\") used between hosts to establish an IP-layer communications context, called HIP association, prior to communications. It also defines a packet format and procedures for updating an active HIP association. Other elements of the HIP architecture are specified in other documents, such as.",
      "ja": "このメモは、従来通信にHIPアソシエーションと呼ばれるIPレイヤの通信コンテキストを確立するためにホストの間で使用される基地HIPプロトコル（「塩基交換」）を、指定します。それはまた、活性HIPアソシエーションを更新するためのパケットフォーマットおよび手順を定義します。 HIPアーキテクチャの他の要素は、次のような他の文書で指定されています。"
    },
    {
      "indent": 3,
      "text": "o \"Using the Encapsulating Security Payload (ESP) Transport Format with the Host Identity Protocol (HIP)\" [RFC5202]: how to use the Encapsulating Security Payload (ESP) for integrity protection and optional encryption",
      "ja": "O [RFC5202]「ホストアイデンティティプロトコル（HIP）とカプセル化セキュリティペイロード（ESP）トランスポートフォーマットの使用」：整合性の保護とオプションの暗号化のためのカプセル化セキュリティペイロード（ESP）の使用方法"
    },
    {
      "indent": 3,
      "text": "o \"End-Host Mobility and Multihoming with the Host Identity Protocol\" [RFC5206]: how to support mobility and multihoming in HIP",
      "ja": "「ホストアイデンティティプロトコルとエンドホストモビリティとマルチホーミングの」o [RFC5206]：どのようにHIPに移動性とマルチホーミングをサポートするために、"
    },
    {
      "indent": 3,
      "text": "o \"Host Identity Protocol (HIP) Domain Name System (DNS) Extensions\" [RFC5205]: how to extend DNS to contain Host Identity information",
      "ja": "O「ホストアイデンティティプロトコル（HIP）ドメインネームシステム（DNS）の拡張」[RFC5205]：ホストの識別情報を含むようにDNSを拡張する方法"
    },
    {
      "indent": 3,
      "text": "o \"Host Identity Protocol (HIP) Rendezvous Extension\" [RFC5204]: using a rendezvous mechanism to contact mobile HIP hosts",
      "ja": "O「ホストアイデンティティプロトコル（HIP）ランデブー拡張子」[RFC5204]：モバイルHIPホストに連絡するためにランデブーメカニズムを使用して"
    },
    {
      "indent": 0,
      "text": "1.1. A New Namespace and Identifiers",
      "section_title": true,
      "ja": "1.1。新しい名前空間と識別子"
    },
    {
      "indent": 3,
      "text": "The Host Identity Protocol introduces a new namespace, the Host Identity namespace. Some ramifications of this new namespace are explained in the HIP architecture description [RFC4423].",
      "ja": "ホスト識別プロトコルは、新しい名前空間、ホストアイデンティティの名前空間を紹介します。この新しい名前空間の一部波及効果は、HIPアーキテクチャ記述[RFC4423]で説明されています。"
    },
    {
      "indent": 3,
      "text": "There are two main representations of the Host Identity, the full Host Identifier (HI) and the Host Identity Tag (HIT). The HI is a public key and directly represents the Identity. Since there are different public key algorithms that can be used with different key lengths, the HI is not good for use as a packet identifier, or as an index into the various operational tables needed to support HIP. Consequently, a hash of the HI, the Host Identity Tag (HIT), becomes the operational representation. It is 128 bits long and is used in the HIP payloads and to index the corresponding state in the end hosts. The HIT has an important security property in that it is self-certifying (see Section 3).",
      "ja": "ホストアイデンティティの二つの主要な表現がありますが、完全なホスト識別子（HI）とホストアイデンティティタグ（HIT）。 HIは、公開鍵であり、直接そのアイデンティティを表します。異なる鍵の長さで使用することができ、異なる公開鍵アルゴリズムがあるので、HIは、パケット識別子として、またはHIPをサポートするために必要な様々な動作テーブルへのインデックスとして使用するのに良好ではありません。その結果、HIのハッシュは、ホストアイデンティティタグ（HIT）は、運用表現になります。これは、128ビット長であり、エンドホストに対応する状態HIPペイロードおよびインデックスに使用されます。 HITは、それが自己証明（セクション3を参照）であることを重要なセキュリティ性を有しています。"
    },
    {
      "indent": 0,
      "text": "1.2. The HIP Base Exchange",
      "section_title": true,
      "ja": "1.2。 HIP基本交換"
    },
    {
      "indent": 3,
      "text": "The HIP base exchange is a two-party cryptographic protocol used to establish communications context between hosts. The base exchange is a Sigma-compliant [KRA03] four-packet exchange. The first party is called the Initiator and the second party the Responder. The four-packet design helps to make HIP DoS resilient. The protocol exchanges Diffie-Hellman keys in the 2nd and 3rd packets, and authenticates the parties in the 3rd and 4th packets. Additionally, the Responder starts a puzzle exchange in the 2nd packet, with the Initiator completing it in the 3rd packet before the Responder stores any state from the exchange.",
      "ja": "HIP基本交換は、ホスト間の通信コンテキストを確立するために使用される二つのパーティの暗号プロトコルです。塩基交換は、Sigma-準拠[KRA03]四パケット交換機です。最初のパーティは、イニシエータと第二党レスポンダと呼ばれています。 4パケットのデザインは、HIP DoS攻撃は、弾性作るのに役立ちます。プロトコルの第2、第3のパケットで交換のDiffie-Hellman鍵、および第3および第4のパケットでパーティーを認証します。さらに、レスポンダは、イニシエータが交流からレスポンダ店どのような状態の前に第三のパケットでそれを完了すると、第二のパケットにパズルの交換を開始します。"
    },
    {
      "indent": 3,
      "text": "The exchange can use the Diffie-Hellman output to encrypt the Host Identity of the Initiator in the 3rd packet (although Aura, et al., [AUR03] notes that such operation may interfere with packet-inspecting middleboxes), or the Host Identity may instead be sent unencrypted. The Responder's Host Identity is not protected. It should be noted, however, that both the Initiator's and the Responder's HITs are transported as such (in cleartext) in the packets, allowing an eavesdropper with a priori knowledge about the parties to verify their identities.",
      "ja": "交換は、（ただし、オーラ、ら、このような動作は、パケット検査中間装置を妨害し得ること[AUR03]ノート）3パケットのイニシエータのホストアイデンティティを暗号化するためのDiffie-Hellman出力を使用することができ、またはホストアイデンティティ月代わりに、暗号化されずに送信すること。レスポンダのホストアイデンティティが保護されていません。両方のイニシエータのとレスポンダのヒットは自分の身元を確認するために、当事者についての先験的な知識を持つ盗聴が可能、（クリアテキストで）そのようなパケットのように輸送されることに留意すべきです。"
    },
    {
      "indent": 3,
      "text": "Data packets start to flow after the 4th packet. The 3rd and 4th HIP packets may carry a data payload in the future. However, the details of this are to be defined later as more implementation experience is gained.",
      "ja": "データパケットは、第四パケットの後に流れ始めます。 3番目と4番目のHIPパケットは、将来的にはデータペイロードを運ぶことができます。しかし、これについての詳細は、より多くの実装経験が得られるよう、後に定義されることになっています。"
    },
    {
      "indent": 3,
      "text": "An existing HIP association can be updated using the update mechanism defined in this document, and when the association is no longer needed, it can be closed using the defined closing mechanism.",
      "ja": "既存のHIP協会は、この文書で定義された更新メカニズムを使用して更新することができ、関連付けが不要になったとき、それは定義された開閉機構を使用して閉じていないことができます。"
    },
    {
      "indent": 3,
      "text": "Finally, HIP is designed as an end-to-end authentication and key establishment protocol, to be used with Encapsulated Security Payload (ESP) [RFC5202] and other end-to-end security protocols. The base protocol does not cover all the fine-grained policy control found in Internet Key Exchange (IKE) [RFC4306] that allows IKE to support complex gateway policies. Thus, HIP is not a replacement for IKE.",
      "ja": "最後に、HIPは、カプセル化セキュリティペイロード（ESP）[RFC5202]と他のエンドツーエンドのセキュリティプロトコルと共に使用されるように、エンド・ツー・エンドの認証及び鍵確立プロトコルとして設計されています。基本プロトコルは、IKEは、複合ゲートウェイポリシーをサポートすることを可能にするインターネット鍵交換（IKE）[RFC4306]で見つかったすべてのきめ細かなポリシー制御をカバーしていません。このように、HIPは、IKEに代わるものではありません。"
    },
    {
      "indent": 0,
      "text": "1.3. Memo Structure",
      "section_title": true,
      "ja": "1.3。メモの構造"
    },
    {
      "indent": 3,
      "text": "The rest of this memo is structured as follows. Section 2 defines the central keywords, notation, and terms used throughout the rest of the document. Section 3 defines the structure of the Host Identity and its various representations. Section 4 gives an overview of the HIP base exchange protocol. Sections 5 and 6 define the detail packet formats and rules for packet processing. Finally, Sections 7, 8, and 9 discuss policy, security, and IANA considerations, respectively.",
      "ja": "次のようにこのメモの残りの部分が構成されています。第2節では、ドキュメントの残りの部分全体で使用中央キーワード、記号、および用語を定義します。セクション3は、ホストID及びその種々の表現の構造を定義します。セクション4は、HIP基本交換プロトコルの概要を示します。セクション5及び6は、パケット処理の詳細パケットフォーマットとルールを定義します。最後に、セクション7、8、および9は、それぞれ、ポリシー、セキュリティ、およびIANAの考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "2. Terms and Definitions",
      "section_title": true,
      "ja": "2.用語と定義"
    },
    {
      "indent": 0,
      "text": "2.1. Requirements Terminology",
      "section_title": true,
      "ja": "2.1。要件の用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Notation",
      "section_title": true,
      "ja": "2.2。表記法"
    },
    {
      "indent": 3,
      "text": "[x] indicates that x is optional.",
      "ja": "[x]は、xは任意であることを示しています。"
    },
    {
      "indent": 3,
      "text": "{x} indicates that x is encrypted.",
      "ja": "{x}はxが暗号化されていることを示しています。"
    },
    {
      "indent": 3,
      "text": "X(y) indicates that y is a parameter of X.",
      "ja": "X（Y）は、YはXのパラメータであることを示しています"
    },
    {
      "indent": 3,
      "text": "<x>i indicates that x exists i times.",
      "ja": "<x>は、私は、xが私回存在することを示しています。"
    },
    {
      "indent": 3,
      "text": "--> signifies \"Initiator to Responder\" communication (requests).",
      "ja": " - >通信（要求）「をイニシエータがレスポンダに」を意味します。"
    },
    {
      "indent": 3,
      "text": "<-- signifies \"Responder to Initiator\" communication (replies).",
      "ja": "< - が意味「イニシエータにレスポンダ」通信（返信）。"
    },
    {
      "indent": 3,
      "text": "| signifies concatenation of information-- e.g., X | Y is the concatenation of X with Y.",
      "ja": "| information--例えば、Xの連結を意味| Yは、YとXの連結であります"
    },
    {
      "indent": 3,
      "text": "Ltrunc (SHA-1(), K) denotes the lowest order K bits of the SHA-1 result.",
      "ja": "Ltrunc（SHA-1（）、K）は、SHA-1の結果の最下位kビットを表します。"
    },
    {
      "indent": 0,
      "text": "2.3. Definitions",
      "section_title": true,
      "ja": "2.3。定義"
    },
    {
      "indent": 3,
      "text": "Unused Association Lifetime (UAL): Implementation-specific time for which, if no packet is sent or received for this time interval, a host MAY begin to tear down an active association.",
      "ja": "未結合のライフタイム（UAL）：全くパケットがこの時間間隔のために送信されないまたは受信された場合、ホストがアクティブ・アソシエーションを切断し始める可能性があるため、実装固有時間。"
    },
    {
      "indent": 3,
      "text": "Maximum Segment Lifetime (MSL): Maximum time that a TCP segment is expected to spend in the network.",
      "ja": "最大セグメント寿命（MSL）：TCPセグメントがネットワークに過ごすことが予想されていることを最大時間。"
    },
    {
      "indent": 3,
      "text": "Exchange Complete (EC): Time that the host spends at the R2-SENT before it moves to ESTABLISHED state. The time is n * I2 retransmission timeout, where n is about I2_RETRIES_MAX.",
      "ja": "取引完了（EC）：ホストがESTABLISHED状態に移行する前にR2-SENTで過ごす時間。時間は、nはI2_RETRIES_MAXについてです* I2の再送タイムアウト、です。"
    },
    {
      "indent": 3,
      "text": "HIT Hash Algorithm: Hash algorithm used to generate a Host Identity Tag (HIT) from the Host Identity public key. Currently SHA-1 [FIPS95] is used.",
      "ja": "ハッシュアルゴリズムを打つ：ホストアイデンティティの公開鍵からホストアイデンティティタグ（HIT）を生成するために使用されるハッシュアルゴリズム。現在、SHA-1 [FIPS95]が使用されます。"
    },
    {
      "indent": 3,
      "text": "Responder's HIT Hash Algorithm (RHASH): Hash algorithm used for various hash calculations in this document. The algorithm is the same as is used to generate the Responder's HIT. RHASH is defined by the Orchid Context ID. For HIP, the present RHASH algorithm is defined in Section 3.2. A future version of HIP may define a new RHASH algorithm by defining a new Context ID.",
      "ja": "レスポンダのHITハッシュアルゴリズム（RHASH）：この文書に記載されている様々なハッシュ計算に使用されるハッシュアルゴリズム。このアルゴリズムは、レスポンダのHITを生成するために使用されるのと同じです。 RHASHは蘭コンテキストIDによって定義されます。 HIPのために、本RHASHアルゴリズムは、セクション3.2で定義されています。 HIPの将来のバージョンは、新しいコンテキストIDを定義することにより、新たなRHASHアルゴリズムを定義することができます。"
    },
    {
      "indent": 3,
      "text": "Opportunistic mode: HIP base exchange where the Responder's HIT is not known a priori to the Initiator.",
      "ja": "日和見モード：レスポンダのHITがイニシエータに先験的に知られていないHIP基本交換。"
    },
    {
      "indent": 0,
      "text": "3. Host Identifier (HI) and Its Representations",
      "section_title": true,
      "ja": "3.ホスト識別子（HI）とその表現"
    },
    {
      "indent": 3,
      "text": "In this section, the properties of the Host Identifier and Host Identifier Tag are discussed, and the exact format for them is defined. In HIP, the public key of an asymmetric key pair is used as the Host Identifier (HI). Correspondingly, the host itself is defined as the entity that holds the private key from the key pair. See the HIP architecture specification [RFC4423] for more details about the difference between an identity and the corresponding identifier.",
      "ja": "このセクションでは、ホスト識別子とホスト識別子タグの特性が議論され、そしてそれらの正確なフォーマットが定義されます。 HIPにおいて、非対称鍵ペアの公開鍵は、ホスト識別子（HI）として使用されます。これに対応し、ホスト自体が鍵のペアから秘密鍵を保持するエンティティとして定義されます。アイデンティティと対応する識別子との間の差についての詳細は、HIPアーキテクチャ仕様[RFC4423]を参照。"
    },
    {
      "indent": 3,
      "text": "HIP implementations MUST support the Rivest Shamir Adelman (RSA/SHA1) [RFC3110] public key algorithm, and SHOULD support the Digital Signature Algorithm (DSA) [RFC2536] algorithm; other algorithms MAY be supported.",
      "ja": "HIP実装は、リベストシャミールエーデルマン（RSA / SHA1）[RFC3110]公開鍵アルゴリズムをサポートしなければならない、とデジタル署名アルゴリズム（DSA）[RFC2536]アルゴリズムを支持します。他のアルゴリズムをサポートすることができます。"
    },
    {
      "indent": 3,
      "text": "A hashed encoding of the HI, the Host Identity Tag (HIT), is used in protocols to represent the Host Identity. The HIT is 128 bits long and has the following three key properties: i) it is the same length as an IPv6 address and can be used in address-sized fields in APIs and protocols, ii) it is self-certifying (i.e., given a HIT, it is computationally hard to find a Host Identity key that matches the HIT), and iii) the probability of HIT collision between two hosts is very low.",
      "ja": "HI、ホストアイデンティティタグ（HIT）のハッシュ化された符号化は、ホストアイデンティティを表現するためにプロトコルで使用されています。 HITは、128ビット長であり、以下の3つの重要な性質を有する：I）は、IPv6アドレスと同じ長さであり、APIおよびプロトコルのアドレスサイズフィールドに使用することができるが、II）は、自己証明（すなわち、与えられHITは、HITと一致するホストIDキー）を見つけることは計算が困難であると、iii）2つのホスト間HIT衝突の確率は非常に低いです。"
    },
    {
      "indent": 3,
      "text": "Carrying HIs and HITs in the header of user data packets would increase the overhead of packets. Thus, it is not expected that they are carried in every packet, but other methods are used to map the data packets to the corresponding HIs. In some cases, this makes it possible to use HIP without any additional headers in the user data packets. For example, if ESP is used to protect data traffic, the Security Parameter Index (SPI) carried in the ESP header can be used to map the encrypted data packet to the correct HIP association.",
      "ja": "ユーザ・データ・パケットのヘッダで彼とヒットを搬送するパケットのオーバーヘッドを増加させるであろう。したがって、それらはすべてのパケットで運ばれることが期待されていないが、他の方法は、彼の対応にデータパケットをマッピングするために使用されています。いくつかのケースでは、これは、ユーザデータパケットに追加のヘッダーなしでHIPを使用することが可能となります。 ESPは、データトラフィックを保護するために使用される場合、例えば、ESPヘッダで運ばれるセキュリティパラメータインデックス（SPI）が正しいHIPアソシエーションに暗号化されたデータパケットをマッピングするために使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.1. Host Identity Tag (HIT)",
      "section_title": true,
      "ja": "3.1。ホストアイデンティティタグ（HIT）"
    },
    {
      "indent": 3,
      "text": "The Host Identity Tag is a 128-bit value -- a hashed encoding of the Host Identifier. There are two advantages of using a hashed encoding over the actual Host Identity public key in protocols. Firstly, its fixed length makes for easier protocol coding and also better manages the packet size cost of this technology. Secondly, it presents a consistent format to the protocol whatever underlying identity technology is used.",
      "ja": "ホスト識別子のハッシュ化された符号化 - ホストIDタグは、128ビットの値です。プロトコルの実際のホストアイデンティティの公開鍵の上にハッシュされたエンコーディングを使用しての2つの利点があります。まず、その固定された長さは、より簡単なプロトコル符号化になり、また、より良い、この技術のパケットサイズ、コストを管理します。第二に、それは、基礎となるアイデンティティ技術が使用されているものは何でもプロトコルへの一貫したフォーマットを提示します。"
    },
    {
      "indent": 3,
      "text": "RFC 4843 [RFC4843] specifies 128-bit hash-based identifiers, called Overlay Routable Cryptographic Hash Identifiers (ORCHIDs). Their prefix, allocated from the IPv6 address block, is defined in [RFC4843]. The Host Identity Tag is a type of ORCHID, based on a SHA-1 hash of the Host Identity, as defined in Section 2 of [RFC4843].",
      "ja": "RFC 4843 [RFC4843]はオーバーレイルーティング可能な暗号ハッシュ識別子（ラン）と呼ばれる128ビットのハッシュベースの識別子を指定します。 IPv6アドレスブロックから割り当てられ、それらの接頭辞は、[RFC4843]で定義されています。 [RFC4843]のセクション2で定義されているホストIDタグは、ホストアイデンティティのSHA-1ハッシュに基づいて、ランの一種です。"
    },
    {
      "indent": 0,
      "text": "3.2. Generating a HIT from an HI",
      "section_title": true,
      "ja": "3.2。 HIからHITの生成"
    },
    {
      "indent": 3,
      "text": "The HIT MUST be generated according to the ORCHID generation method described in [RFC4843] using a context ID value of 0xF0EF F02F BFF4 3D0F E793 0C3C 6E61 74EA (this tag value has been generated randomly by the editor of this specification), and an input that encodes the Host Identity field (see Section 5.2.8) present in a HIP payload packet. The hash algorithm SHA-1 has to be used when generating HITs with this context ID. If a new ORCHID hash algorithm is needed in the future for HIT generation, a new version of HIP has to be specified with a new ORCHID context ID associated with the new hash algorithm.",
      "ja": "HITは0xF0EF F02F BFF4 3D0F E793 0C3C 6E61 74EA（このタグの値は、本明細書の編集者によってランダムに生成された）、及び入力のコンテキストID値を使用して、[RFC4843]に記載のラン生成方法に従って生成されなければなりませんHIPペイロードパケットに存在する（5.2.8項を参照）ホストIDフィールドを符号化します。ハッシュアルゴリズムSHA-1は、このコンテキストIDを持つヒットを生成する際に使用されなければなりません。新しいORCHIDハッシュアルゴリズムがHITを生成するため、将来的に必要とされている場合は、HIPの新バージョンでは、新たなハッシュアルゴリズムに関連した新しいORCHIDコンテキストIDを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "For Identities that are either RSA or Digital Signature Algorithm (DSA) public keys, this input consists of the public key encoding as specified in the corresponding DNSSEC document, taking the algorithm-specific portion of the RDATA part of the KEY RR. There are currently only two defined public key algorithms: RSA/SHA1 and DSA. Hence, either of the following applies:",
      "ja": "RSA又はデジタル署名アルゴリズム（DSA）のいずれかの公開鍵であるアイデンティティのために、この入力は、KEY RRのRDATA部のアルゴリズム特異的部分を取って、対応するDNSSEC文書で指定された公開鍵エンコーディングから成ります。 RSA / SHA1およびDSA：2つしか定義された公開鍵アルゴリズムは現在ありません。したがって、次のいずれかが適用されます。"
    },
    {
      "indent": 6,
      "text": "The RSA public key is encoded as defined in [RFC3110] Section 2, taking the exponent length (e_len), exponent (e), and modulus (n) fields concatenated. The length (n_len) of the modulus (n) can be determined from the total HI Length and the preceding HI fields including the exponent (e). Thus, the data to be hashed has the same length as the HI. The fields MUST be encoded in network byte order, as defined in [RFC3110].",
      "ja": "指数長（e_len）、指数（e）を取って、[RFC3110]セクション2で定義されるようにRSA公開鍵は、符号化され、そして弾性率（n）は、連結フィールド。モジュラスの長さ（n_len）（n）は、総HI長さ及び指数（E）を含む先行HIフィールドから決定することができます。このように、ハッシュされるデータはHIと同じ長さを有しています。 [RFC3110]で定義されたフィールドは、ネットワークバイト順に符号化されなければなりません。"
    },
    {
      "indent": 6,
      "text": "The DSA public key is encoded as defined in [RFC2536] Section 2, taking the fields T, Q, P, G, and Y, concatenated. Thus, the data to be hashed is 1 + 20 + 3 * 64 + 3 * 8 * T octets long, where T is the size parameter as defined in [RFC2536]. The size parameter T, affecting the field lengths, MUST be selected as the minimum value that is long enough to accommodate P, G, and Y. The fields MUST be encoded in network byte order, as defined in [RFC2536].",
      "ja": "[RFC2536]セクション2で定義されるようにDSA公開鍵はフィールドT、Q、P、G、及びY、連結を取って、符号化されます。このように、ハッシュされるデータは、1 + 20 + 3 * 64 + 3 * 8 * Tは、[RFC2536]で定義されるサイズパラメータであり、Tは、長いオクテット。フィールド長に影響を及ぼすサイズパラメータTは、[RFC2536]で定義されるフィールドは、ネットワークバイト順に符号化されなければならないP、G、及びYを収容するのに十分な長さの最小値として選択されなければなりません。"
    },
    {
      "indent": 3,
      "text": "In Appendix B, the public key encoding process is illustrated using pseudo-code.",
      "ja": "付録Bにおいて、公開鍵の符号化プロセスは、擬似コードを用いて示されています。"
    },
    {
      "indent": 0,
      "text": "4. Protocol Overview",
      "section_title": true,
      "ja": "4.プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The following material is an overview of the HIP protocol operation, and does not contain all details of the packet formats or the packet processing steps. Sections 5 and 6 describe in more detail the packet formats and packet processing steps, respectively, and are normative in case of any conflicts with this section.",
      "ja": "以下の材料は、HIPプロトコル動作の概要であり、パケットフォーマット、またはパケット処理手順の詳細をすべて含んでいません。セクション5及び6は、それぞれ、より詳細にはパケットフォーマット及びパケット処理手順を説明し、このセクションとの競合の場合に規定されています。"
    },
    {
      "indent": 3,
      "text": "The protocol number 139 has been assigned by IANA to the Host Identity Protocol.",
      "ja": "プロトコル番号139は、ホストアイデンティティプロトコルにIANAによって割り当てられています。"
    },
    {
      "indent": 3,
      "text": "The HIP payload (Section 5.1) header could be carried in every IP datagram. However, since HIP headers are relatively large (40 bytes), it is desirable to 'compress' the HIP header so that the HIP header only occurs in control packets used to establish or change HIP association state. The actual method for header 'compression' and for matching data packets with existing HIP associations (if any) is defined in separate documents, describing transport formats and methods. All HIP implementations MUST implement, at minimum, the ESP transport format for HIP [RFC5202].",
      "ja": "HIPペイロード（セクション5.1）ヘッダは、すべてのIPデータグラムに実行することができました。 HIPヘッダが（40バイト）が比較的大きいので、HIPヘッダのみHIPアソシエーション状態を確立または変更するために使用される制御パケットに発生するようしかし、それはHIPヘッダ「圧縮」することが望ましいです。ヘッダ「圧縮」および（もしあれば）既存のHIPアソシエーションとデータ・パケットを一致させるための実際の方法は、トランスポートフォーマット及び方法を記載する、別の文書で定義されています。すべてのHIP実装は、最低でも、HIP [RFC5202]のためにESPのトランスポートフォーマットを実装しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.1. Creating a HIP Association",
      "section_title": true,
      "ja": "4.1。 HIP協会を作成します"
    },
    {
      "indent": 3,
      "text": "By definition, the system initiating a HIP exchange is the Initiator, and the peer is the Responder. This distinction is forgotten once the base exchange completes, and either party can become the Initiator in future communications.",
      "ja": "定義により、HIP交換を開始するシステムがイニシエータであり、ピアがレスポンダです。この区別は、塩基交換が完了すると忘れ去られ、いずれかの当事者は、将来の通信にイニシエータになることができます。"
    },
    {
      "indent": 3,
      "text": "The HIP base exchange serves to manage the establishment of state between an Initiator and a Responder. The first packet, I1, initiates the exchange, and the last three packets, R1, I2, and R2, constitute an authenticated Diffie-Hellman [DIF76] key exchange for session key generation. During the Diffie-Hellman key exchange, a piece of keying material is generated. The HIP association keys are drawn from this keying material. If other cryptographic keys are needed, e.g., to be used with ESP, they are expected to be drawn from the same keying material.",
      "ja": "HIP基本交換は、イニシエータとレスポンダとの間の状態の確立を管理するのに役立ちます。最初のパケット、I1は、交換を開始し、最後の3つのパケット、R1、I2、及びR2は、認証されたディフィー・ヘルマンセッション鍵生成用【DIF76]キー交換を構成します。 Diffie-Hellman鍵交換中、材料をキーイングのピースが生成されます。 HIP関連キーは、この鍵素材から引き出されています。他の暗号鍵が必要な場合は、例えば、ESPで使用する、それらは同じ鍵素材から引き出されることが期待されます。"
    },
    {
      "indent": 3,
      "text": "The Initiator first sends a trigger packet, I1, to the Responder. The packet contains only the HIT of the Initiator and possibly the HIT of the Responder, if it is known. Note that in some cases it may be possible to replace this trigger packet by some other form of a trigger, in which case the protocol starts with the Responder sending the R1 packet.",
      "ja": "イニシエータは、ファーストレスポンダに、トリガーパケット、I1を送信します。それがわかっている場合、パケットは、唯一のイニシエータのHITとおそらくレスポンダのHITが含まれています。いくつかのケースでは、プロトコルはR1パケットを送信レスポンダで開始する場合には、トリガのいくつかの他の形態によりこのトリガーパケットを交換することが可能であることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The second packet, R1, starts the actual exchange. It contains a puzzle -- a cryptographic challenge that the Initiator must solve before continuing the exchange. The level of difficulty of the puzzle can be adjusted based on level of trust with the Initiator, current load, or other factors. In addition, the R1 contains the initial Diffie-Hellman parameters and a signature, covering part of the message. Some fields are left outside the signature to support pre-created R1s.",
      "ja": "第2のパケット、R1は、実際の交換を開始します。イニシエータは、交換を続行する前に解決しなければならない暗号挑戦 - それはパズルが含まれています。パズルの難易度は、開始剤と信頼のレベル、現在の負荷、または他の要因に基づいて調整することができます。また、R1は、メッセージの一部を覆って、初期のDiffie-Hellmanパラメータ及び署名を含みます。いくつかのフィールドは、事前に作成したのR1をサポートするために、署名の外に残っています。"
    },
    {
      "indent": 3,
      "text": "In the I2 packet, the Initiator must display the solution to the received puzzle. Without a correct solution, the I2 message is discarded. The I2 also contains a Diffie-Hellman parameter that carries needed information for the Responder. The packet is signed by the sender.",
      "ja": "I2パケットでは、イニシエータは、受信パズルの解決策を表示しなければなりません。正しい解決策がなければ、I2メッセージは破棄されます。 I2はまた、レスポンダに必要な情報を運ぶのDiffie-Hellmanパラメータを含んでいます。パケットが送信者によって署名されています。"
    },
    {
      "indent": 3,
      "text": "The R2 packet finalizes the base exchange. The packet is signed.",
      "ja": "R2のパケットは、塩基交換を確定します。パケットが署名されています。"
    },
    {
      "indent": 3,
      "text": "The base exchange is illustrated below. The term \"key\" refers to the Host Identity public key, and \"sig\" represents a signature using such a key. The packets contain other parameters not shown in this figure.",
      "ja": "塩基交換を以下に示します。用語「キー」は、ホストアイデンティティの公開鍵を意味し、「SIG」は、そのような鍵を用いて署名を表します。パケットは、この図に示されていない他のパラメータが含まれています。"
    },
    {
      "indent": 7,
      "text": "Initiator Responder",
      "ja": "イニシエータレスポンダ"
    },
    {
      "indent": 4,
      "text": "                I1: trigger exchange\n              -------------------------->\n                                          select precomputed R1\n                R1: puzzle, D-H, key, sig\n              <-------------------------\ncheck sig                                 remain stateless\nsolve puzzle\n              I2: solution, D-H, {key}, sig\n              -------------------------->\ncompute D-H                               check puzzle\n                                          check sig\n                        R2: sig\n              <--------------------------\ncheck sig                                 compute D-H",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.1.1. HIP Puzzle Mechanism",
      "section_title": true,
      "ja": "4.1.1。 HIPパズルメカニズム"
    },
    {
      "indent": 3,
      "text": "The purpose of the HIP puzzle mechanism is to protect the Responder from a number of denial-of-service threats. It allows the Responder to delay state creation until receiving I2. Furthermore, the puzzle allows the Responder to use a fairly cheap calculation to check that the Initiator is \"sincere\" in the sense that it has churned CPU cycles in solving the puzzle.",
      "ja": "HIPパズル機構の目的は、サービス拒否の脅威の数からレスポンダを保護することです。これは、ResponderがI2を受信するまでの状態の作成を遅らせることができます。さらに、パズルは、Responderがイニシエータは、それがパズルを解く際にCPUサイクルを解約したという意味で、「誠実」であることを確認するために、かなり安価な計算を使用することができます。"
    },
    {
      "indent": 3,
      "text": "The puzzle mechanism has been explicitly designed to give space for various implementation options. It allows a Responder implementation to completely delay session-specific state creation until a valid I2 is received. In such a case, a correctly formatted I2 can be rejected only once the Responder has checked its validity by computing one hash function. On the other hand, the design also allows a Responder implementation to keep state about received I1s, and match the received I2s against the state, thereby allowing the implementation to avoid the computational cost of the hash function. The drawback of this latter approach is the requirement of creating state. Finally, it also allows an implementation to use other combinations of the space-saving and computation-saving mechanisms.",
      "ja": "パズルのメカニズムは、明示的に、様々な実装オプションのためのスペースを与えるように設計されています。これは、有効なI2が受信されるまでレスポンダの実装は完全にセッション固有の状態の作成を遅らせることができます。 Responderが1つのハッシュ関数を計算することによって、その有効性を確認した後、このような場合には、正しくフォーマットI2のみを拒否することができます。一方、デザインも、それによって実装はハッシュ関数の計算コストを回避することを可能にする、受信I1sについての状態を維持し、状態に対して受信I2Sと一致するようにレスポンダの実装を可能にします。この後者のアプローチの欠点は、状態を作成する要件です。最後に、それはまた、実装は、省スペース及び計算を節約する機構の他の組み合わせを使用することを可能にします。"
    },
    {
      "indent": 3,
      "text": "The Responder can remain stateless and drop most spoofed I2s because puzzle calculation is based on the Initiator's Host Identity Tag. The idea is that the Responder has a (perhaps varying) number of pre-calculated R1 packets, and it selects one of these based on the information carried in I1. When the Responder then later receives I2, it can verify that the puzzle has been solved using the Initiator's HIT. This makes it impractical for the attacker to first exchange one I1/R1, and then generate a large number of spoofed I2s that seemingly come from different HITs. The method does not protect from an attacker that uses fixed HITs, though. Against such an attacker a viable approach may be to create a piece of local state, and remember that the puzzle check has previously failed. See Appendix A for one possible implementation. Implementations SHOULD include sufficient randomness to the algorithm so that algorithmic complexity attacks become impossible [CRO03].",
      "ja": "Responderはステートレスままとパズルの計算は、イニシエータのホストアイデンティティタグに基づいているため、ほとんどの偽装されたI2Sをドロップすることができます。アイデアは、レスポンダは予め計算R1パケットの（おそらく変化する）番号を有することであり、I1で運ばれた情報に基づいて、これらのいずれかを選択します。 Responderがその後I2を受信すると、パズルがイニシエータのHITを使用して解決されていることを確認することができます。これは、第1交換I1 / R1に攻撃者にとっては非現実的になり、その後、一見異なるヒットから来る偽装I2Sの多数を生成します。この方法は、しかし、固定されたヒットを使用して、攻撃者から保護することはできません。そのような攻撃に対して実行可能なアプローチは、ローカル状態の作品を作成して、パズルのチェックが以前に失敗したことを覚えておくことかもしれません。一つの可能​​な実装については、付録Aを参照してください。アルゴリズムの複雑攻撃は[CRO03]不可能となるような実装は、アルゴリズムに十分なランダム性を含むべきです。"
    },
    {
      "indent": 3,
      "text": "The Responder can set the puzzle difficulty for Initiator, based on its level of trust of the Initiator. Because the puzzle is not included in the signature calculation, the Responder can use pre-calculated R1 packets and include the puzzle just before sending the R1 to the Initiator. The Responder SHOULD use heuristics to determine when it is under a denial-of-service attack, and set the puzzle difficulty value K appropriately; see below.",
      "ja": "レスポンダは、イニシエータの信頼のそのレベルに基づいて、イニシエータのためのパズルの難易度を設定することができます。パズルは、署名計算に含まれないため、レスポンダは、予め計算R1パケットを使用して、単にイニシエータにR1を送信する前にパズルを含むことができます。レスポンダは、サービス拒否攻撃を受けているときに決定し、適切パズルの難易度値Kを設定するためにヒューリスティックを使用する必要があります。下記参照。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Puzzle Exchange",
      "section_title": true,
      "ja": "4.1.2。パズル交換"
    },
    {
      "indent": 3,
      "text": "The Responder starts the puzzle exchange when it receives an I1. The Responder supplies a random number I, and requires the Initiator to find a number J. To select a proper J, the Initiator must create the concatenation of I, the HITs of the parties, and J, and take a hash over this concatenation using the RHASH algorithm. The lowest order K bits of the result MUST be zeros. The value K sets the difficulty of the puzzle.",
      "ja": "それはI1を受信したときResponderはパズルの交換を開始します。 Responderは乱数Iを供給し、J.が適切Jを選択するには番号を見つけるために、イニシエータを必要とし、イニシエータはI、当事者のヒット、そしてJの連結を作成し、使用して、この連結上のハッシュを取る必要がありますRHASHアルゴリズム。結果の最下位kビットはゼロでなければなりません。値Kは、パズルの難易度を設定します。"
    },
    {
      "indent": 3,
      "text": "To generate a proper number J, the Initiator will have to generate a number of Js until one produces the hash target of zeros. The Initiator SHOULD give up after exceeding the puzzle lifetime in the PUZZLE parameter (Section 5.2.4). The Responder needs to re-create the concatenation of I, the HITs, and the provided J, and compute the hash once to prove that the Initiator did its assigned task.",
      "ja": "適切な数Jを生成するには、イニシエータは1つがゼロのハッシュターゲットを作るまでのJsの番号を生成する必要があります。イニシエータはPUZZLEパラメータ（5.2.4）でパズルの寿命を超えた後にあきらめるべきです。 ResponderはI、ヒット、および提供Jの連結を再作成し、イニシエータはその割り当てられたタスクをしたことを証明するために、一度ハッシュを計算する必要があります。"
    },
    {
      "indent": 3,
      "text": "To prevent precomputation attacks, the Responder MUST select the number I in such a way that the Initiator cannot guess it. Furthermore, the construction MUST allow the Responder to verify that the value was indeed selected by it and not by the Initiator. See Appendix A for an example on how to implement this.",
      "ja": "事前計算攻撃を防ぐために、レスポンダはイニシエータがそれを推測できないように番号Iを選択する必要があります。さらに、工事はResponderが値が実際にそれではなくイニシエータによって選択されたことを確認するために許容しなければなりません。これを実装する方法の例については、付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "Using the Opaque data field in an ECHO_REQUEST_SIGNED (Section 5.2.17) or in an ECHO_REQUEST_UNSIGNED parameter (Section 5.2.18), the Responder can include some data in R1 that the Initiator must copy unmodified in the corresponding I2 packet. The Responder can generate the Opaque data in various ways; e.g., using some secret, the sent I, and possibly other related data. Using the same secret, the received I (from the I2), and the other related data (if any), the Receiver can verify that it has itself sent the I to the Initiator. The Responder MUST periodically change such a used secret.",
      "ja": "ECHO_REQUEST_SIGNED（セクション5.2.17）またはECHO_REQUEST_UNSIGNEDパラメータ（セクション5.2.18）に不透明なデータフィールドを使用して、レスポンダは、イニシエータが対応I2パケットに修飾されていないコピーしなければならないことR1内の一部のデータを含むことができます。 Responderはさまざまな方法で不透明なデータを生成することができます。例えば、いくつかの秘密、送られたI、およびおそらく他の関連データを使用して。同じ秘密を使用して、I（I2から）、および他の関連データ（もしあれば）を受信し、受信機は、それ自体があることを確認することができる開始剤Iを送りました。 Responderは定期的に使用される秘密を変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the Responder generates a new puzzle and a new R1 once every few minutes. Furthermore, it is RECOMMENDED that the Responder remembers an old puzzle at least 2*Lifetime seconds after the puzzle has been deprecated. These time values allow a slower Initiator to solve the puzzle while limiting the usability that an old, solved puzzle has to an attacker.",
      "ja": "Responderが数分おきに一度新しいパズルと新しいR1を生成することを推奨されます。さらに、Responderは、パズルが廃止されました生涯秒後に古いパズル少なくとも2 *を覚えていることが推奨されます。これらの時間値は、古い、解決パズルが攻撃者にあり利便性を制限しながら、より遅いイニシエータは、パズルを解くことができます。"
    },
    {
      "indent": 3,
      "text": "NOTE: The protocol developers explicitly considered whether R1 should include a timestamp in order to protect the Initiator from replay attacks. The decision was to NOT include a timestamp.",
      "ja": "注：プロトコルの開発者が明示的にR1は、リプレイ攻撃からイニシエータを保護するためにタイムスタンプを含めるべきかどうかを検討しました。決定は、タイムスタンプを含めないようにしました。"
    },
    {
      "indent": 3,
      "text": "NOTE: The protocol developers explicitly considered whether a memory bound function should be used for the puzzle instead of a CPU-bound function. The decision was not to use memory-bound functions. At the time of the decision, the idea of memory-bound functions was relatively new and their IPR status were unknown. Once there is more experience about memory-bound functions and once their IPR status is better known, it may be reasonable to reconsider this decision.",
      "ja": "注：プロトコルの開発者が明示的にメモリバインド機能ではなく、CPUバウンド機能のパズルのために使用すべきかどうかを検討しました。決定は、メモリが結合した機能を使用することができませんでした。決断の時には、メモリが結合した機能のアイデアは比較的新しかったと彼らの知的財産権の状況は不明でした。メモリ結合機能について、その知的財産権の状態が良く知られている一回より多くの経験があると、この決定を再考するのが妥当かもしれません。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Authenticated Diffie-Hellman Protocol",
      "section_title": true,
      "ja": "4.1.3。認証済みのDiffie-Hellmanプロトコル"
    },
    {
      "indent": 3,
      "text": "The packets R1, I2, and R2 implement a standard authenticated Diffie-Hellman exchange. The Responder sends one or two public Diffie-Hellman keys and its public authentication key, i.e., its Host Identity, in R1. The signature in R1 allows the Initiator to verify that the R1 has been once generated by the Responder. However, since it is precomputed and therefore does not cover all of the packet, it does not protect from replay attacks.",
      "ja": "パケットR1、I2、及びR2は、標準的な認証のDiffie-Hellman交換を実現します。 ResponderはR1に1つまたは2つの公共のDiffie-Hellman鍵とその公開認証キー、すなわち、そのホストのアイデンティティを送信します。 R1内の署名は、イニシエータがR1が一度レスポンダによって生成されたことを確認することを可能にします。それは、パケットのすべてをカバーしていないため、事前に計算され、しかし、それはリプレイ攻撃から保護することはできません。"
    },
    {
      "indent": 3,
      "text": "When the Initiator receives an R1, it gets one or two public Diffie-Hellman values from the Responder. If there are two values, it selects the value corresponding to the strongest supported Group ID and computes the Diffie-Hellman session key (Kij). It creates a HIP association using keying material from the session key (see Section 6.5), and may use the association to encrypt its public authentication key, i.e., Host Identity. The resulting I2 contains the Initiator's Diffie-Hellman key and its (optionally encrypted) public authentication key. The signature in I2 covers all of the packet.",
      "ja": "イニシエータは、R1を受信すると、レスポンダから1または2つのパブリックのDiffie-Hellman値を取得します。二つの値が存在する場合、それが最強のサポートグループIDに対応する値を選択してのDiffie-Hellmanセッション鍵（Kijを）を計算します。これは、セッション鍵（セクション6.5を参照）から、キーイング材料を使用して、HIPの関連付けを作成し、その公開認証鍵、すなわち、ホストIDを暗号化するためにアソシエーションを使用してもよいです。その結果I2は、イニシエータののDiffie-Hellmanキーと（必要に応じて暗号化された）パブリック認証キーが含まれています。 I2での署名は、パケットのすべてをカバーしています。"
    },
    {
      "indent": 3,
      "text": "The Responder extracts the Initiator Diffie-Hellman public key from the I2, computes the Diffie-Hellman session key, creates a corresponding HIP association, and decrypts the Initiator's public authentication key. It can then verify the signature using the authentication key.",
      "ja": "レスポンダは、I2からイニシエータのDiffie-Hellman公開鍵を抽出するのDiffie-Hellmanセッション鍵を計算し、対応するHIPアソシエーションを作成し、イニシエータの公開認証鍵を復号化します。その後、認証キーを使用して署名を検証することができます。"
    },
    {
      "indent": 3,
      "text": "The final message, R2, is needed to protect the Initiator from replay attacks.",
      "ja": "最後のメッセージ、R2は、リプレイ攻撃からイニシエータを保護するために必要とされます。"
    },
    {
      "indent": 0,
      "text": "4.1.4. HIP Replay Protection",
      "section_title": true,
      "ja": "4.1.4。 HIPリプレイ保護"
    },
    {
      "indent": 3,
      "text": "The HIP protocol includes the following mechanisms to protect against malicious replays. Responders are protected against replays of I1 packets by virtue of the stateless response to I1s with presigned R1 messages. Initiators are protected against R1 replays by a monotonically increasing \"R1 generation counter\" included in the R1. Responders are protected against replays or false I2s by the puzzle mechanism (Section 4.1.1 above), and optional use of opaque data. Hosts are protected against replays to R2s and UPDATEs by use of a less expensive HMAC verification preceding HIP signature verification.",
      "ja": "HIPプロトコルは、悪意のあるリプレイから保護するために、以下のメカニズムが含まれています。レスポンダはpresigned R1メッセージでI1sにステートレス応答によってI1パケットのリプレイから保護されます。開始剤は、R1に含まれて単調に増加する「R1世代カウンタ」によってR1リプレイから保護されています。応答者は、パズル機構（上記セクション4.1.1）、および不透明データの任意の使用によってリプレイ又は偽I2Sから保護されます。ホストはHIP署名検証を先行安価HMAC認証を使用することによってのR 2及びアップデートにリプレイから保護されます。"
    },
    {
      "indent": 3,
      "text": "The R1 generation counter is a monotonically increasing 64-bit counter that may be initialized to any value. The scope of the counter MAY be system-wide but SHOULD be per Host Identity, if there is more than one local host identity. The value of this counter SHOULD be kept across system reboots and invocations of the HIP base exchange. This counter indicates the current generation of puzzles. Implementations MUST accept puzzles from the current generation and MAY accept puzzles from earlier generations. A system's local counter MUST be incremented at least as often as every time old R1s cease to be valid, and SHOULD never be decremented, lest the host expose its peers to the replay of previously generated, higher numbered R1s. The R1 counter SHOULD NOT roll over.",
      "ja": "R1生成カウンタは、任意の値に初期化され得る、単調に増加する64ビット・カウンタです。カウンタの範囲は、システム全体のかもしれないが、複数のローカルホストの同一性が存在する場合は、ホストIDごとにあるべきです。このカウンタの値は、システムが再起動し、HIP基本交換の呼び出しを横切って維持されるべきです。このカウンタは、パズルの現在の発生を示します。実装は、現在の世代からパズルを受け入れなければならないし、それ以前の世代からパズルを受け入れることができます。システムのローカルカウンタを有効にするたびに、古いのR1の停戦と少なくとも同じ頻繁に増加しなければなりません、そしてホストが以前に生成され、大きい番号のR1の再生に同業他社を公開しないように、減算すべきではありません。 R1カウンタはロールオーバーしない（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "A host may receive more than one R1, either due to sending multiple I1s (Section 6.6.1) or due to a replay of an old R1. When sending multiple I1s, an Initiator SHOULD wait for a small amount of time (a reasonable time may be 2 * expected RTT) after the first R1 reception to allow possibly multiple R1s to arrive, and it SHOULD respond to an R1 among the set with the largest R1 generation counter. If an Initiator is processing an R1 or has already sent an I2 (still waiting for R2) and it receives another R1 with a larger R1 generation counter, it MAY elect to restart R1 processing with the fresher R1, as if it were the first R1 to arrive.",
      "ja": "ホストが原因旧R1の再生にさらに1 R1よりも、どちらかによる複数のI1s（6.6.1項）またはを送るに受け取ることができます。複数I1sを送信するとき、イニシエータは、おそらく複数のR1が到着できるように、それが有するセットのうちR1に応答すべき第一のR1受信後（妥当な時間は2 * RTTを期待することができる）時間の少量のを待つべき最大のR1生成カウンタ。イニシエータは、R1を処理しているか、既にI2を送信した（依然としてR2を待っている）、それは、より大きなR1生成カウンタと別のR1を受信し、それが最初にR1であるかのように、新鮮R1とR1の処理を再開することを選択することができる場合到着する。"
    },
    {
      "indent": 3,
      "text": "Upon conclusion of an active HIP association with another host, the R1 generation counter associated with the peer host SHOULD be flushed. A local policy MAY override the default flushing of R1 counters on a per-HIT basis. The reason for recommending the flushing of this counter is that there may be hosts where the R1 generation counter (occasionally) decreases; e.g., due to hardware failure.",
      "ja": "別のホストとのアクティブなHIP協会の締結時に、ピア・ホストに関連付けられたR1世代カウンタがフラッシュされるべきです。ローカルポリシーごとのHIT基づいてR1カウンタのデフォルトのフラッシュを無効にすることができます。このカウンタのフラッシングを推奨する理由は、R1世代カウンタ（時々）が低下するホストが存在し得るということです。例えば、ハードウェア障害に起因します。"
    },
    {
      "indent": 0,
      "text": "4.1.5. Refusing a HIP Exchange",
      "section_title": true,
      "ja": "4.1.5。 HIP交換を拒否"
    },
    {
      "indent": 3,
      "text": "A HIP-aware host may choose not to accept a HIP exchange. If the host's policy is to only be an Initiator, it should begin its own HIP exchange. A host MAY choose to have such a policy since only the Initiator's HI is protected in the exchange. There is a risk of a race condition if each host's policy is to only be an Initiator, at which point the HIP exchange will fail.",
      "ja": "HIP-意識したホストは、HIP交換を受け入れるしないこともできます。ホストのポリシーが唯一のイニシエータにする場合、それは自身のHIP交換を開始する必要があります。ホストは、イニシエータのHIは交換で保護されているため、このようなポリシーを持っているのを選ぶかもしれ。各ホストのポリシーはHIP交換が失敗した時点でのみ可能イニシエータにある場合に競合状態の危険性があります。"
    },
    {
      "indent": 3,
      "text": "If the host's policy does not permit it to enter into a HIP exchange with the Initiator, it should send an ICMP 'Destination Unreachable, Administratively Prohibited' message. A more complex HIP packet is not used here as it actually opens up more potential DoS attacks than a simple ICMP message.",
      "ja": "ホストのポリシーは、イニシエータとHIP交換に入ることを許可しない場合は、ICMP「宛先到達不能、管理上禁止」というメッセージを送信する必要があります。より複雑なHIPパケットは、それが実際に簡単なICMPメッセージよりも多くの潜在的なDoS攻撃を開くと、ここで使用されていません。"
    },
    {
      "indent": 0,
      "text": "4.1.6. HIP Opportunistic Mode",
      "section_title": true,
      "ja": "4.1.6。 HIP日和見モード"
    },
    {
      "indent": 3,
      "text": "It is possible to initiate a HIP negotiation even if the Responder's HI (and HIT) is unknown. In this case, the connection initializing I1 packet contains NULL (all zeros) as the destination HIT. This kind of connection setup is called opportunistic mode.",
      "ja": "レスポンダのHI（およびHIT）が不明であっても、HIP交渉を開始することが可能です。この場合、I1パケットを初期接続は、宛先HITとしてNULL（すべてゼロ）を含みます。接続設定のこの種は、日和見モードと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "There are both security and API issues involved with the opportunistic mode.",
      "ja": "日和見モードに関わるセキュリティとAPIの問題の両方があります。"
    },
    {
      "indent": 3,
      "text": "Given that the Responder's HI is not known by the Initiator, there must be suitable API calls that allow the Initiator to request, directly or indirectly, that the underlying kernel initiate the HIP base exchange solely based on locators. The Responder's HI will be tentatively available in the R1 packet, and in an authenticated form once the R2 packet has been received and verified. Hence, it could be communicated to the application via new API mechanisms. However, with a backwards-compatible API the application sees only the locators used for the initial contact. Depending on the desired semantics of the API, this can raise the following issues:",
      "ja": "レスポンダのHIは、イニシエータによって知られていないことを考えると、基礎となるカーネルは、単にロケータに基づいてHIP基本交換を開始することを、直接的または間接的に、イニシエータが要求できるよう、適切なAPI呼び出しがなければなりません。 R2パケットを受信し、検証された後、レスポンダのHIは、R1パケットであり、認証された形で暫定的に利用できるようになります。したがって、それは新しいAPI機構を介してアプリケーションに通信することができます。しかし、後方互換APIとアプリケーションが最初に接触するために使用される唯一のロケータを見ています。 APIの所望のセマンティクスに応じて、これは次の問題を提起することができます："
    },
    {
      "indent": 3,
      "text": "o The actual locators may later change if an UPDATE message is used, even if from the API perspective the session still appears to be between specific locators. The locator update is still secure, however, and the session is still between the same nodes.",
      "ja": "UPDATEメッセージが使用される場合、O実際のロケータは、後にAPIの観点からセッションが特定のロケータとの間であるように見える場合であっても、変化してもよいです。ロケータの更新は、しかし、依然として安全で、セッションは、同じノード間のままです。"
    },
    {
      "indent": 3,
      "text": "o Different sessions between the same locators may result in connections to different nodes, if the implementation no longer remembers which identifier the peer had in another session. This is possible when the peer's locator has changed for legitimate reasons or when an attacker pretends to be a node that has the peer's locator. Therefore, when using opportunistic mode, HIP MUST NOT place any expectation that the peer's HI returned in the R1 message matches any HI previously seen from that address.",
      "ja": "実装がもはやピアが別のセッションであったがidentifierた覚えている場合、O同じロケータとの間の異なるセッションは、異なるノードへの接続を生じないかもしれません。ピアのロケータは、正当な理由のために変更されたとき、または、攻撃者はピアのロケータを有するノードになりすました場合にこれが可能です。日和見モードを使用するときため、HIPは、ピアのHIは、R1メッセージで返されたHIが以前にそのアドレスから見て一致する任意の期待を配置してはならず。"
    },
    {
      "indent": 6,
      "text": "If the HIP implementation and application do not have the same understanding of what constitutes a session, this may even happen within the same session. For instance, an implementation may not know when HIP state can be purged for UDP-based applications.",
      "ja": "HIP実装し、アプリケーションがセッションを構成するものの同じ理解を持っていない場合は、これでも同じセッション内で発生することがあります。 HIP状態はUDPベースのアプリケーションのためにパージすることができたときにたとえば、実装は知らないかもしれません。"
    },
    {
      "indent": 3,
      "text": "o As with all HIP exchanges, the handling of locator-based or interface-based policy is unclear for opportunistic mode HIP. An application may make a connection to a specific locator because the application has knowledge of the security properties along the network to that locator. If one of the nodes moves and the locators are updated, these security properties may not be maintained. Depending on the security policy of the application, this may be a problem. This is an area of ongoing study. As an example, there is work to create an API that applications can use to specify their security requirements in a similar context [IPsec-APIs].",
      "ja": "OすべてのHIP交換と同様に、ロケータ系またはインターフェイスベースのポリシーの取り扱いは、日和見モードHIPのため不明です。アプリケーションは、そのロケータにネットワークに沿っセキュリティプロパティの知識を持っているため、アプリケーションは特定のロケータへの接続を行うことができます。ノードが移動し、ロケータのいずれかが更新された場合は、これらのセキュリティの特性が維持されないことがあります。アプリケーションのセキュリティポリシーに応じて、これが問題になることがあります。これは現在進行中の研究の領域です。例として、アプリケーションが同様の状況[IPsecでのAPI]で自分のセキュリティ要件を指定するために使用できるAPIを作成するための作業があります。"
    },
    {
      "indent": 3,
      "text": "In addition, the following security considerations apply. The generation counter mechanism will be less efficient in protecting against replays of the R1 packet, given that the Responder can choose a replay that uses any HI, not just the one given in the I1 packet.",
      "ja": "また、次のセキュリティの考慮事項が適用されます。生成カウンタ機構は、レスポンダは、任意HI、I1パケットに与えられるだけでなく、1つを使用するリプレイを選択することができることを考えると、R1パケットのリプレイに対する保護であまり効率的であろう。"
    },
    {
      "indent": 3,
      "text": "More importantly, the opportunistic exchange is vulnerable to man-in-the-middle attacks, because the Initiator does not have any public key information about the peer. To assess the impacts of this vulnerability, we compare it to vulnerabilities in current, non-HIP-capable communications.",
      "ja": "イニシエータがピアについての公開鍵情報を持っていないので、もっと重要なのは、日和見交換は、man-in-the-middle攻撃に対して脆弱です。この脆弱性の影響を評価するために、我々は現在、非HIP可能な通信の脆弱性と比較します。"
    },
    {
      "indent": 3,
      "text": "An attacker on the path between the two peers can insert itself as a man-in-the-middle by providing its own identifier to the Initiator and then initiating another HIP session towards the Responder. For this to be possible, the Initiator must employ opportunistic mode, and the Responder must be configured to accept a connection from any HIP-enabled node.",
      "ja": "2つのピア間の経路上の攻撃者は、イニシエータに独自の識別子を提供し、次いでレスポンダに向かって別のHIPセッションを開始することによってのman-in-the-middleとして自身を挿入することができます。これを可能にするために、イニシエータは、日和見モードを使用しなければならない、とResponderは任意HIP対応ノードからの接続を受け入れるように構成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "An attacker outside the path will be unable to do so, given that it cannot respond to the messages in the base exchange.",
      "ja": "パス外の攻撃者は、それがベース交換でメッセージに応答することができないことを考えると、そうすることができません。"
    },
    {
      "indent": 3,
      "text": "These properties are characteristic also of communications in the current Internet. A client contacting a server without employing end-to-end security may find itself talking to the server via a man-in-the-middle, assuming again that the server is willing to talk to anyone.",
      "ja": "これらのプロパティは、現在のインターネットにおける通信の特徴でもあります。エンドツーエンドのセキュリティを用いることなく、サーバーに接続クライアントは、自身がサーバが誰にも話をして喜んでであることを再び仮定し、のman-in-the-middleを介してサーバに話を見つけることがあります。"
    },
    {
      "indent": 3,
      "text": "If end-to-end security is in place, then the worst that can happen in both the opportunistic HIP and normal IP cases is denial-of-service; an entity on the path can disrupt communications, but will be unable to insert itself as a man-in-the-middle.",
      "ja": "エンドツーエンドのセキュリティが所定の位置にある場合には、日和見HIPと通常のIPの両方の場合に起こることができる最悪の事態は、サービス拒否です。パス上のエンティティは、通信を中断させることができますが、のman-in-the-middleとしての地位を挿入することができません。"
    },
    {
      "indent": 3,
      "text": "However, once the opportunistic exchange has successfully completed, HIP provides integrity protection and confidentiality for the communications, and can securely change the locators of the endpoints.",
      "ja": "日和見交換が正常に完了した後しかし、HIPは、通信のための完全性保護と機密性を提供し、しっかりとエンドポイントのロケータを変更することができます。"
    },
    {
      "indent": 3,
      "text": "As a result, it is believed that the HIP opportunistic mode is at least as secure as current IP.",
      "ja": "その結果、HIP日和見モードは、少なくとも現在のIPと同様に安全であると考えられています。"
    },
    {
      "indent": 0,
      "text": "4.2. Updating a HIP Association",
      "section_title": true,
      "ja": "4.2。 HIP協会の更新"
    },
    {
      "indent": 3,
      "text": "A HIP association between two hosts may need to be updated over time. Examples include the need to rekey expiring user data security associations, add new security associations, or change IP addresses associated with hosts. The UPDATE packet is used for those and other similar purposes. This document only specifies the UPDATE packet format and basic processing rules, with mandatory parameters. The actual usage is defined in separate specifications.",
      "ja": "2つのホスト間のHIP協会は、時間をかけて更新する必要があります。例としては、期限切れのユーザデータのセキュリティアソシエーションをリキー新しいセキュリティアソシエーションを追加、またはホストに関連付けられたIPアドレスを変更する必要があります。 UPDATEパケットは、これらおよび他の同様の目的のために使用されています。この文書では、唯一の必須パラメータで、UPDATEパケットフォーマットと基本的な処理規則を指定します。実際の使用は、別の仕様で定義されています。"
    },
    {
      "indent": 3,
      "text": "HIP provides a general purpose UPDATE packet, which can carry multiple HIP parameters, for updating the HIP state between two peers. The UPDATE mechanism has the following properties:",
      "ja": "HIPは、2つのピア間HIP状態を更新するため、複数のHIPパラメータを運ぶことができる汎用UPDATEパケットを、提供します。 UPDATEメカニズムは、次のプロパティがあります。"
    },
    {
      "indent": 6,
      "text": "UPDATE messages carry a monotonically increasing sequence number and are explicitly acknowledged by the peer. Lost UPDATEs or acknowledgments may be recovered via retransmission. Multiple UPDATE messages may be outstanding under certain circumstances.",
      "ja": "UPDATEメッセージが単調に増加するシーケンス番号を運ぶと、明示的にピアによって確認されています。失われた更新や確認応答が再送信を介して回収することができます。複数のUPDATEメッセージは、特定の状況下で優れたかもしれません。"
    },
    {
      "indent": 6,
      "text": "UPDATE is protected by both HMAC and HIP_SIGNATURE parameters, since processing UPDATE signatures alone is a potential DoS attack against intermediate systems.",
      "ja": "単独でUPDATEシグネチャを処理する中間システムに対する潜在的なDoS攻撃であるため、更新は、HMACとHIP_SIGNATUREパラメータの両方によって保護されています。"
    },
    {
      "indent": 6,
      "text": "UPDATE packets are explicitly acknowledged by the use of an acknowledgment parameter that echoes an individual sequence number received from the peer. A single UPDATE packet may contain both a sequence number and one or more acknowledgment numbers (i.e., piggybacked acknowledgment(s) for the peer's UPDATE).",
      "ja": "アップデートパケットを明示的ピアから受信した個々のシーケンス番号を確認応答エコーパラメータの使用によって認められています。単一UPDATEパケットがシーケンス番号および1つまたは複数の確認応答番号の両方を含んでいてもよい（即ち、ピアのUPDATEに対する肯定応答（複数可）をピギーバック）。"
    },
    {
      "indent": 3,
      "text": "The UPDATE packet is defined in Section 5.3.5.",
      "ja": "UPDATEパケットは、セクション5.3.5で定義されています。"
    },
    {
      "indent": 0,
      "text": "4.3. Error Processing",
      "section_title": true,
      "ja": "4.3。エラー処理"
    },
    {
      "indent": 3,
      "text": "HIP error processing behavior depends on whether or not there exists an active HIP association. In general, if a HIP association exists between the sender and receiver of a packet causing an error condition, the receiver SHOULD respond with a NOTIFY packet. On the other hand, if there are no existing HIP associations between the sender and receiver, or the receiver cannot reasonably determine the identity of the sender, the receiver MAY respond with a suitable ICMP message; see Section 5.4 for more details.",
      "ja": "HIPエラー処理動作は、アクティブHIPアソシエーションが存在するか否かに依存します。 HIPアソシエーションがエラー条件を引き起こしたパケットの送信者と受信者との間に存在する場合、一般的に、受信機は、NOTIFYパケットで応答する必要があります。一方、送信者と受信者、または合理的に送信者の同一性を決定することができない受信機との間の既存のHIPアソシエーションが存在しない場合、適切なICMPメッセージで応答することができる受信機。詳細は、5.4節を参照してください。"
    },
    {
      "indent": 3,
      "text": "The HIP protocol and state machine is designed to recover from one of the parties crashing and losing its state. The following scenarios describe the main use cases covered by the design.",
      "ja": "HIPプロトコルとステートマシンがクラッシュし、その状態を失う当事者の一方から回復するように設計されています。次のシナリオは、設計でカバー主な使用例を説明します。"
    },
    {
      "indent": 6,
      "text": "No prior state between the two systems.",
      "ja": "2つのシステム間の事前の状態はありません。"
    },
    {
      "indent": 9,
      "text": "The system with data to send is the Initiator. The process follows the standard four-packet base exchange, establishing the HIP association.",
      "ja": "送信するデータを持つシステムがイニシエータです。プロセスは、HIPアソシエーションを確立し、標準的な4パケットベースの交換に従います。"
    },
    {
      "indent": 6,
      "text": "The system with data to send has no state with the receiver, but the receiver has a residual HIP association.",
      "ja": "送信するデータを有するシステムは、受信機とは状態を有していないが、受信機は、残留HIPの関連性を有しています。"
    },
    {
      "indent": 9,
      "text": "The system with data to send is the Initiator. The Initiator acts as in no prior state, sending I1 and getting R1. When the Responder receives a valid I2, the old association is 'discovered' and deleted, and the new association is established.",
      "ja": "送信するデータを持つシステムがイニシエータです。イニシエータは、I1を送信し、R1を取得し、事前の状態にあるとして動作します。 Responderが有効I2を受信した場合、古い協会を「発見」し、削除され、新しいアソシエーションが確立されています。"
    },
    {
      "indent": 6,
      "text": "The system with data to send has a HIP association, but the receiver does not.",
      "ja": "送信するデータを有するシステムは、HIPの関連性を有しているが、受信機がありません。"
    },
    {
      "indent": 9,
      "text": "The system sends data on the outbound user data security association. The receiver 'detects' the situation when it receives a user data packet that it cannot match to any HIP association. The receiving host MUST discard this packet.",
      "ja": "システムは、アウトバウンド、ユーザデータのセキュリティアソシエーション上でデータを送信します。受信機は、それがどんなHIP協会に一致させることができないユーザデータパケットを受信状況「を検出します」。受信ホストはこのパケットを捨てなければなりません。"
    },
    {
      "indent": 9,
      "text": "Optionally, the receiving host MAY send an ICMP packet, with the type Parameter Problem, to inform the sender that the HIP association does not exist (see Section 5.4), and it MAY initiate a new HIP negotiation. However, responding with these optional mechanisms is implementation or policy dependent.",
      "ja": "必要に応じて、受信ホストは、（5.4節を参照）HIPアソシエーションが存在しないことを送信者に通知するために、タイプパラメータ問題で、ICMPパケットを送信することができ、それが新しいHIP交渉を開始することができます。しかし、これらのオプションのメカニズムで応答することは、実装またはポリシーに依存しています。"
    },
    {
      "indent": 0,
      "text": "4.4. HIP State Machine",
      "section_title": true,
      "ja": "4.4。 HIPステートマシン"
    },
    {
      "indent": 3,
      "text": "The HIP protocol itself has little state. In the HIP base exchange, there is an Initiator and a Responder. Once the security associations (SAs) are established, this distinction is lost. If the HIP state needs to be re-established, the controlling parameters are which peer still has state and which has a datagram to send to its peer. The following state machine attempts to capture these processes.",
      "ja": "HIPプロトコル自体は少し状態があります。 HIP基本交換では、イニシエータとレスポンダがあります。セキュリティアソシエーション（SA）が確立されると、この区別は失われます。 HIPの状態を再確立する必要がある場合は、制御パラメータは、まだピアの状態を持っており、どのピアに送信するデータグラムを持っているです。以下のステートマシンは、これらのプロセスを捕獲しようとします。"
    },
    {
      "indent": 3,
      "text": "The state machine is presented in a single system view, representing either an Initiator or a Responder. There is not a complete overlap of processing logic here and in the packet definitions. Both are needed to completely implement HIP.",
      "ja": "状態機械は、イニシエータまたはレスポンダのいずれかを表し、単一のシステムビューで提示されます。処理ロジックの完全なオーバーラップは、ここに、パケットの定義ではありません。どちらも、完全にHIPを実装するために必要な。"
    },
    {
      "indent": 3,
      "text": "Implementors must understand that the state machine, as described here, is informational. Specific implementations are free to implement the actual functions differently. Section 6 describes the packet processing rules in more detail. This state machine focuses on the HIP I1, R1, I2, and R2 packets only. Other states may be introduced by mechanisms in other specifications (such as mobility and multihoming).",
      "ja": "実装者は、ステートマシンは、ここで説明するように、情報提供であることを理解しなければなりません。具体的な実装は異なり、実際の機能を実装するのは自由です。第6節では、より詳細にパケット処理のルールを説明します。このステートマシンは唯一のHIP I1、R1、I2、およびR2パケットに焦点を当てています。他の状態は、（例えば、移動度及びマルチホーミングのような）他の仕様のメカニズムによって導入することができます。"
    },
    {
      "indent": 0,
      "text": "4.4.1. HIP States",
      "section_title": true,
      "ja": "4.4.1。 HIP州"
    },
    {
      "indent": 3,
      "text": "+---------------------+---------------------------------------------+\n| State               | Explanation                                 |\n+---------------------+---------------------------------------------+\n| UNASSOCIATED        | State machine start                         |\n|                     |                                             |\n| I1-SENT             | Initiating base exchange                    |\n|                     |                                             |\n| I2-SENT             | Waiting to complete base exchange           |\n|                     |                                             |\n| R2-SENT             | Waiting to complete base exchange           |\n|                     |                                             |\n| ESTABLISHED         | HIP association established                 |\n|                     |                                             |\n| CLOSING             | HIP association closing, no data can be     |\n|                     | sent                                        |\n|                     |                                             |\n| CLOSED              | HIP association closed, no data can be sent |\n|                     |                                             |\n| E-FAILED            | HIP exchange failed                         |\n+---------------------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 28,
      "text": "Table 1: HIP States",
      "ja": "表1：HIP州"
    },
    {
      "indent": 0,
      "text": "4.4.2. HIP State Processes",
      "section_title": true,
      "ja": "4.4.2。 HIP状態のプロセス"
    },
    {
      "indent": 3,
      "text": "System behavior in state UNASSOCIATED, Table 2.",
      "ja": "状態関連付けられていない、表2のシステムの挙動。"
    },
    {
      "indent": 3,
      "text": "+---------------------+---------------------------------------------+\n| Trigger             | Action                                      |\n+---------------------+---------------------------------------------+\n| User data to send,  | Send I1 and go to I1-SENT                   |\n| requiring a new HIP |                                             |\n| association         |                                             |\n|                     |                                             |\n| Receive I1          | Send R1 and stay at UNASSOCIATED            |\n|                     |                                             |\n| Receive I2, process | If successful, send R2 and go to R2-SENT    |\n|                     |                                             |\n|                     | If fail, stay at UNASSOCIATED               |\n|                     |                                             |\n| Receive user data   | Optionally send ICMP as defined in          |\n| for unknown HIP     | Section 5.4 and stay at UNASSOCIATED        |\n| association         |                                             |\n|                     |                                             |\n| Receive CLOSE       | Optionally send ICMP Parameter Problem and  |\n|                     | stay at UNASSOCIATED                        |\n|                     |                                             |\n| Receive ANYOTHER    | Drop and stay at UNASSOCIATED               |\n+---------------------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Table 2: UNASSOCIATED - Start state",
      "ja": "表2：関連付けられていない - の状態を開始します"
    },
    {
      "indent": 3,
      "text": "System behavior in state I1-SENT, Table 3.",
      "ja": "状態I1-SENT、表3のシステムの動作。"
    },
    {
      "indent": 3,
      "text": "+---------------------+---------------------------------------------+\n| Trigger             | Action                                      |\n+---------------------+---------------------------------------------+\n| Receive I1          | If the local HIT is smaller than the peer   |\n|                     | HIT, drop I1 and stay at I1-SENT            |\n|                     |                                             |\n|                     | If the local HIT is greater than the peer   |\n|                     | HIT, send R1 and stay at I1_SENT            |\n|                     |                                             |\n| Receive I2, process | If successful, send R2 and go to R2-SENT    |\n|                     |                                             |\n|                     | If fail, stay at I1-SENT                    |\n|                     |                                             |\n| Receive R1, process | If successful, send I2 and go to I2-SENT    |\n|                     |                                             |\n|                     | If fail, stay at I1-SENT                    |\n|                     |                                             |\n| Receive ANYOTHER    | Drop and stay at I1-SENT                    |\n|                     |                                             |\n| Timeout, increment  | If counter is less than I1_RETRIES_MAX,     |\n| timeout counter     | send I1 and stay at I1-SENT                 |\n|                     |                                             |\n|                     | If counter is greater than I1_RETRIES_MAX,  |\n|                     | go to E-FAILED                              |\n+---------------------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Table 3: I1-SENT - Initiating HIP",
      "ja": "表3：I1-SENT  -  HIPを開始"
    },
    {
      "indent": 3,
      "text": "System behavior in state I2-SENT, Table 4.",
      "ja": "状態I2-SENT、表4のシステムの挙動。"
    },
    {
      "indent": 3,
      "text": "+---------------------+---------------------------------------------+\n| Trigger             | Action                                      |\n+---------------------+---------------------------------------------+\n| Receive I1          | Send R1 and stay at I2-SENT                 |\n|                     |                                             |\n| Receive R1, process | If successful, send I2 and cycle at I2-SENT |\n|                     |                                             |\n|                     | If fail, stay at I2-SENT                    |\n|                     |                                             |\n| Receive I2, process | If successful and local HIT is smaller than |\n|                     | the peer HIT, drop I2 and stay at I2-SENT   |\n|                     |                                             |\n|                     | If successful and local HIT is greater than |\n|                     | the peer HIT, send R2 and go to R2-SENT     |\n|                     |                                             |\n|                     | If fail, stay at I2-SENT                    |\n|                     |                                             |\n| Receive R2, process | If successful, go to ESTABLISHED            |\n|                     |                                             |\n|                     | If fail, stay at I2-SENT                    |\n|                     |                                             |\n| Receive ANYOTHER    | Drop and stay at I2-SENT                    |\n|                     |                                             |\n| Timeout, increment  | If counter is less than I2_RETRIES_MAX,     |\n| timeout counter     | send I2 and stay at I2-SENT                 |\n|                     |                                             |\n|                     | If counter is greater than I2_RETRIES_MAX,  |\n|                     | go to E-FAILED                              |\n+---------------------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Table 4: I2-SENT - Waiting to finish HIP",
      "ja": "表4：I2-SENT  -  HIPを完了するために待っています"
    },
    {
      "indent": 3,
      "text": "System behavior in state R2-SENT, Table 5.",
      "ja": "状態R2-SENT、表5のシステムの挙動。"
    },
    {
      "indent": 3,
      "text": "+---------------------+---------------------------------------------+\n| Trigger             | Action                                      |\n+---------------------+---------------------------------------------+\n| Receive I1          | Send R1 and stay at R2-SENT                 |\n|                     |                                             |\n| Receive I2, process | If successful, send R2 and cycle at R2-SENT |\n|                     |                                             |\n|                     | If fail, stay at R2-SENT                    |\n|                     |                                             |\n| Receive R1          | Drop and stay at R2-SENT                    |\n|                     |                                             |\n| Receive R2          | Drop and stay at R2-SENT                    |\n|                     |                                             |\n| Receive data or     | Move to ESTABLISHED                         |\n| UPDATE              |                                             |\n|                     |                                             |\n| Exchange Complete   | Move to ESTABLISHED                         |\n| Timeout             |                                             |\n+---------------------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Table 5: R2-SENT - Waiting to finish HIP",
      "ja": "表5：R2-SENT  -  HIPを完了するために待っています"
    },
    {
      "indent": 3,
      "text": "System behavior in state ESTABLISHED, Table 6.",
      "ja": "状態でのシステムの動作は、表6を設立しました。"
    },
    {
      "indent": 3,
      "text": "+---------------------+---------------------------------------------+\n| Trigger             | Action                                      |\n+---------------------+---------------------------------------------+\n| Receive I1          | Send R1 and stay at ESTABLISHED             |\n|                     |                                             |\n| Receive I2, process | If successful, send R2, drop old HIP        |\n| with puzzle and     | association, establish a new HIP            |\n| possible Opaque     | association, go to R2-SENT                  |\n| data verification   |                                             |\n|                     |                                             |\n|                     | If fail, stay at ESTABLISHED                |\n|                     |                                             |\n| Receive R1          | Drop and stay at ESTABLISHED                |\n|                     |                                             |\n| Receive R2          | Drop and stay at ESTABLISHED                |\n|                     |                                             |\n| Receive user data   | Process and stay at ESTABLISHED             |\n| for HIP association |                                             |\n|                     |                                             |\n| No packet           | Send CLOSE and go to CLOSING                |\n| sent/received       |                                             |\n| during UAL minutes  |                                             |\n|                     |                                             |\n| Receive CLOSE,      | If successful, send CLOSE_ACK and go to     |\n| process             | CLOSED                                      |\n|                     |                                             |\n|                     | If fail, stay at ESTABLISHED                |\n+---------------------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Table 6: ESTABLISHED - HIP association established",
      "ja": "表6：ESTABLISHED  -  HIPアソシエーションが確立"
    },
    {
      "indent": 3,
      "text": "System behavior in state CLOSING, Table 7.",
      "ja": "状態CLOSING、表7のシステムの挙動。"
    },
    {
      "indent": 3,
      "text": "+---------------------+---------------------------------------------+\n| Trigger             | Action                                      |\n+---------------------+---------------------------------------------+\n| User data to send,  | Send I1 and stay at CLOSING                 |\n| requires the        |                                             |\n| creation of another |                                             |\n| incarnation of the  |                                             |\n| HIP association     |                                             |\n|                     |                                             |\n| Receive I1          | Send R1 and stay at CLOSING                 |\n|                     |                                             |\n| Receive I2, process | If successful, send R2 and go to R2-SENT    |\n|                     |                                             |\n|                     | If fail, stay at CLOSING                    |\n|                     |                                             |\n| Receive R1, process | If successful, send I2 and go to I2-SENT    |\n|                     |                                             |\n|                     | If fail, stay at CLOSING                    |\n|                     |                                             |\n| Receive CLOSE,      | If successful, send CLOSE_ACK, discard      |\n| process             | state and go to CLOSED                      |\n|                     |                                             |\n|                     | If fail, stay at CLOSING                    |\n|                     |                                             |\n| Receive CLOSE_ACK,  | If successful, discard state and go to      |\n| process             | UNASSOCIATED                                |\n|                     |                                             |\n|                     | If fail, stay at CLOSING                    |\n|                     |                                             |\n| Receive ANYOTHER    | Drop and stay at CLOSING                    |\n|                     |                                             |\n| Timeout, increment  | If timeout sum is less than UAL+MSL         |\n| timeout sum, reset  | minutes, retransmit CLOSE and stay at       |\n| timer               | CLOSING                                     |\n|                     |                                             |\n|                     | If timeout sum is greater than UAL+MSL      |\n|                     | minutes, go to UNASSOCIATED                 |\n+---------------------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Table 7: CLOSING - HIP association has not been used for UAL minutes",
      "ja": "表7：CLOSING  -  HIP協会は、UALの分間使用されませんでした"
    },
    {
      "indent": 3,
      "text": "System behavior in state CLOSED, Table 8.",
      "ja": "状態でのシステムの動作は、表8を閉じました。"
    },
    {
      "indent": 3,
      "text": "+---------------------+---------------------------------------------+\n| Trigger             | Action                                      |\n+---------------------+---------------------------------------------+\n| Datagram to send,   | Send I1, and stay at CLOSED                 |\n| requires the        |                                             |\n| creation of another |                                             |\n| incarnation of the  |                                             |\n| HIP association     |                                             |\n|                     |                                             |\n| Receive I1          | Send R1 and stay at CLOSED                  |\n|                     |                                             |\n| Receive I2, process | If successful, send R2 and go to R2-SENT    |\n|                     |                                             |\n|                     | If fail, stay at CLOSED                     |\n|                     |                                             |\n| Receive R1, process | If successful, send I2 and go to I2-SENT    |\n|                     |                                             |\n|                     | If fail, stay at CLOSED                     |\n|                     |                                             |\n| Receive CLOSE,      | If successful, send CLOSE_ACK, stay at      |\n| process             | CLOSED                                      |\n|                     |                                             |\n|                     | If fail, stay at CLOSED                     |\n|                     |                                             |\n| Receive CLOSE_ACK,  | If successful, discard state and go to      |\n| process             | UNASSOCIATED                                |\n|                     |                                             |\n|                     | If fail, stay at CLOSED                     |\n|                     |                                             |\n| Receive ANYOTHER    | Drop and stay at CLOSED                     |\n|                     |                                             |\n| Timeout (UAL+2MSL)  | Discard state, and go to UNASSOCIATED       |\n+---------------------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Table 8: CLOSED - CLOSE_ACK sent, resending CLOSE_ACK if necessary",
      "ja": "表8：CLOSED  -  CLOSE_ACK送られ、必要に応じてCLOSE_ACKを再送"
    },
    {
      "indent": 3,
      "text": "System behavior in state E-FAILED, Table 9.",
      "ja": "状態でのシステムの動作は、表9のE-FAILED。"
    },
    {
      "indent": 3,
      "text": "+-------------------------+-----------------------------------------+\n| Trigger                 | Action                                  |\n+-------------------------+-----------------------------------------+\n| Wait for                | Go to UNASSOCIATED.  Re-negotiation is  |\n| implementation-specific | possible after moving to UNASSOCIATED   |\n| time                    | state.                                  |\n+-------------------------+-----------------------------------------+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Table 9: E-FAILED - HIP failed to establish association with peer",
      "ja": "表9：E-FAILED  -  HIPは、ピアとのアソシエーションを確立することができませんでした"
    },
    {
      "indent": 0,
      "text": "4.4.3. Simplified HIP State Diagram",
      "section_title": true,
      "ja": "4.4.3。簡素化されたHIP状態図"
    },
    {
      "indent": 3,
      "text": "The following diagram shows the major state transitions. Transitions based on received packets implicitly assume that the packets are successfully authenticated or processed.",
      "ja": "次の図は、主要な状態遷移を示しています。受信したパケットに基づいて、トランジションは、暗黙のうちにパケットが正常に認証または処理されていることを前提としています。"
    },
    {
      "indent": 3,
      "text": "                             +-+        +---------------------------+\n        I1 received, send R1 | |        |                           |\n                             | v        v                           |\n         Datagram to send  +--------------+  I2 received, send R2   |\n           +---------------| UNASSOCIATED |---------------+         |\n   Send I1 |               +--------------+               |         |\n           v                                              |         |\n      +---------+  I2 received, send R2                   |         |\n+---->| I1-SENT |---------------------------------------+ |         |\n|     +---------+                                       | |         |\n|          |                 +------------------------+ | |         |\n|          | R1 received,    | I2 received, send R2   | | |         |\n|          v send I2         |                        v v v         |\n|     +---------+            |                   +---------+        |\n|  +->| I2-SENT |------------+                   | R2-SENT |<----+  |\n|  |  +---------+                                +---------+     |  |\n|  |          |                                     |            |  |\n|  |          |                                 data|            |  |\n|  |receive   |                                   or|            |  |\n|  |R1, send  |                           EC timeout| receive I2,|  |\n|  |I2        |R2 received +--------------+         |     send R2|  |\n|  |          +----------->| ESTABLISHED  |<-------+|            |  |\n|  |                       +--------------+                      |  |\n|  |                         |    |     |  receive I2, send R2   |  |\n|  |        recv+------------+    |     +------------------------+  |\n|  |      CLOSE,|                 |                              |  |\n|  |        send|   No packet sent|                              |  |\n|  |   CLOSE_ACK|   /received for |                   timeout    |  |\n|  |            |   UAL min, send |    +---------+<-+ (UAL+MSL)  |  |\n|  |            |           CLOSE +--->| CLOSING |--+ retransmit |  |\n|  |            |                      +---------+    CLOSE      |  |\n+--|------------|----------------------+ | |  | |                |  |\n   +------------|------------------------+ |  | +----------------+  |\n   |            |              +-----------+  +------------------|--+\n   |            +------------+ | receive CLOSE,   CLOSE_ACK      |  |\n   |                         | | send CLOSE_ACK   received or    |  |\n   |                         | |                  timeout        |  |\n   |                         | |                  (UAL+MSL)      |  |\n   |                         v v                                 |  |\n   |                        +--------+  receive I2, send R2      |  |\n   +------------------------| CLOSED |---------------------------+  |\n                            +--------+       /----------------------+\n                              ^ |   \\-------/  timeout (UAL+2MSL),\n                              +-+              move to UNASSOCIATED\n               CLOSE received, send CLOSE_ACK",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5. User Data Considerations",
      "section_title": true,
      "ja": "4.5。ユーザーデータの考慮事項"
    },
    {
      "indent": 0,
      "text": "4.5.1. TCP and UDP Pseudo-Header Computation for User Data",
      "section_title": true,
      "ja": "4.5.1。ユーザーデータのためのTCPおよびUDP擬似ヘッダの計算"
    },
    {
      "indent": 3,
      "text": "When computing TCP and UDP checksums on user data packets that flow through sockets bound to HITs, the IPv6 pseudo-header format [RFC2460] MUST be used, even if the actual addresses on the packet are IPv4 addresses. Additionally, the HITs MUST be used in the place of the IPv6 addresses in the IPv6 pseudo-header. Note that the pseudo-header for actual HIP payloads is computed differently; see Section 5.1.1.",
      "ja": "ヒットに結合したソケットを流れるユーザデータパケットにTCPおよびUDPチェックサムを計算するとき、IPv6の疑似ヘッダのフォーマット[RFC2460]は、パケットの実際のアドレスは、IPv4アドレスであっても、使用しなければなりません。また、HITSは、IPv6疑似ヘッダにおけるIPv6アドレスの代わりに使用されなければなりません。実際のHIPペイロードのための疑似ヘッダが異なって計算されることに留意されたいです。 5.1.1項を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Sending Data on HIP Packets",
      "section_title": true,
      "ja": "4.5.2。 HIPのパケットへのデータの送信"
    },
    {
      "indent": 3,
      "text": "A future version of this document may define how to include user data on various HIP packets. However, currently the HIP header is a terminal header, and not followed by any other headers.",
      "ja": "このドキュメントの将来のバージョンでは、さまざまなHIPパケットのユーザデータを含める方法を定義することができます。しかし、現在HIPヘッダが端子ヘッダであり、そして任意の他のヘッダが続きません。"
    },
    {
      "indent": 0,
      "text": "4.5.3. Transport Formats",
      "section_title": true,
      "ja": "4.5.3。トランスポートフォーマット"
    },
    {
      "indent": 3,
      "text": "The actual data transmission format, used for user data after the HIP base exchange, is not defined in this document. Such transport formats and methods are described in separate specifications. All HIP implementations MUST implement, at minimum, the ESP transport format for HIP [RFC5202].",
      "ja": "HIP基本交換後のユーザデータのために使用される実際のデータ伝送フォーマットは、本文書で定義されていません。そのようなトランスポートフォーマット及び方法は別仕様書に記載されています。すべてのHIP実装は、最低でも、HIP [RFC5202]のためにESPのトランスポートフォーマットを実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When new transport formats are defined, they get the type value from the HIP Transform type value space 2048-4095. The order in which the transport formats are presented in the R1 packet, is the preferred order. The last of the transport formats MUST be ESP transport format, represented by the ESP_TRANSFORM parameter.",
      "ja": "新しいトランスポートフォーマットが定義されている場合、彼らはタイプの値空間2048から4095に変換HIPから型の値を取得します。トランスポートフォーマットは、R1パケットに提示される順序は、好ましい順序です。トランスポートフォーマットの最後はESP_TRANSFORMパラメータによって表されるESPのトランスポート・フォーマットでなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.5.4. Reboot and SA Timeout Restart of HIP",
      "section_title": true,
      "ja": "4.5.4。再起動して、HIPのSAのタイムアウトを再起動します"
    },
    {
      "indent": 3,
      "text": "Simulating a loss of state is a potential DoS attack. The following process has been crafted to manage state recovery without presenting a DoS opportunity.",
      "ja": "状態の損失をシミュレートする潜在的なDoS攻撃です。次のプロセスは、DoS攻撃の機会を提示することなく、状態の回復を管理するために細工されています。"
    },
    {
      "indent": 3,
      "text": "If a host reboots or the HIP association times out, it has lost its HIP state. If the host that lost state has a datagram to send to the peer, it simply restarts the HIP base exchange. After the base exchange has completed, the Initiator can create a new SA and start sending data. The peer does not reset its state until it receives a valid I2 HIP packet.",
      "ja": "ホストの再起動やHIP協会がタイムアウトした場合、それはそのHIP状態を失いました。状態を失ったホストがピアに送信するデータグラムを持っている場合、それは単にHIP基本交換を再起動します。塩基交換が完了した後は、イニシエータは新しいSAを作成し、データの送信を開始することができます。それが有効なI2のHIPパケットを受信するまで、ピアはその状態をリセットしません。"
    },
    {
      "indent": 3,
      "text": "If a system receives a user data packet that cannot be matched to any existing HIP association, it is possible that it has lost the state and its peer has not. It MAY send an ICMP packet with the Parameter",
      "ja": "システムは、既存のHIPアソシエーションに一致させることができないユーザ・データ・パケットを受信した場合、状態を失っており、そのピアがいない可能性があります。これは、パラメータにICMPパケットを送信することができ"
    },
    {
      "indent": 3,
      "text": "Problem type, and with the pointer pointing to the referred HIP-related association information. Reacting to such traffic depends on the implementation and the environment where the implementation is used.",
      "ja": "問題のタイプ、およびいうHIP関連関連情報を示すポインタです。そのようなトラフィックに反応させて実装し、実装が使用される環境に依存します。"
    },
    {
      "indent": 3,
      "text": "If the host, that apparently has lost its state, decides to restart the HIP base exchange, it sends an I1 packet to the peer. After the base exchange has been completed successfully, the Initiator can create a new HIP association and the peer drops its old SA and creates a new one.",
      "ja": "どうやらその状態を失ったホストは、HIP基本交換を再起動することを決定した場合、それはピアにI1パケットを送信します。塩基交換が正常に完了した後は、イニシエータは新しいHIPの関連付けを作成することができますし、ピアはその古いSAを削除し、新しいものを作成します。"
    },
    {
      "indent": 0,
      "text": "4.6. Certificate Distribution",
      "section_title": true,
      "ja": "4.6。証明書配布"
    },
    {
      "indent": 3,
      "text": "This document does not define how to use certificates or how to transfer them between hosts. These functions are expected to be defined in a future specification. A parameter type value, meant to be used for carrying certificates, is reserved, though: CERT, Type 768; see Section 5.2.",
      "ja": "このドキュメントでは、証明書を使用する方法やホスト間でそれらを転送する方法を定義していません。これらの機能は、将来の仕様で定義されることが期待されます。証明書を運ぶために使用されることを意図パラメータタイプ値が、予約されているけれども：CERT、タイプ768。 5.2節を参照してください。"
    },
    {
      "indent": 0,
      "text": "5. Packet Formats",
      "section_title": true,
      "ja": "5.パケットフォーマット"
    },
    {
      "indent": 0,
      "text": "5.1. Payload Format",
      "section_title": true,
      "ja": "5.1。ペイロードフォーマット"
    },
    {
      "indent": 3,
      "text": "All HIP packets start with a fixed header.",
      "ja": "すべてのHIPパケットは、固定ヘッダで始まります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Next Header   | Header Length |0| Packet Type |  VER. | RES.|1|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Checksum             |           Controls            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Sender's Host Identity Tag (HIT)               |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Receiver's Host Identity Tag (HIT)              |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n/                        HIP Parameters                         /\n/                                                               /\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The HIP header is logically an IPv6 extension header. However, this document does not describe processing for Next Header values other than decimal 59, IPPROTO_NONE, the IPv6 'no next header' value. Future documents MAY do so. However, current implementations MUST ignore trailing data if an unimplemented Next Header value is received.",
      "ja": "HIPヘッダは、論理的にIPv6拡張ヘッダです。しかしながら、この文献は、59進以外の次ヘッダ値についてIPPROTO_NONE、IPv6の「いいえ次ヘッダーの値を処理を記載していません。将来の文書はそうかもしれません。実装されていない次のヘッダー値が受信された場合は、現在の実装では、後続のデータを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Header Length field contains the length of the HIP Header and HIP parameters in 8-byte units, excluding the first 8 bytes. Since all HIP headers MUST contain the sender's and receiver's HIT fields, the minimum value for this field is 4, and conversely, the maximum length of the HIP Parameters field is (255*8)-32 = 2008 bytes. Note: this sets an additional limit for sizes of parameters included in the Parameters field, independent of the individual parameter maximum lengths.",
      "ja": "ヘッダ長フィールドは、最初の8つのバイトを除く、8バイト単位でHIPヘッダおよびHIPパラメータの長さを含みます。すべてのHIPヘッダは送信者と受信者のHITフィールドを含まなければならないため、このフィールドの最小値は4であり、そして逆に、HIPパラメータフィールドの最大長は（255 * 8）-32 = 2008バイトです。注：これは、個々のパラメータの最大長さの独立したパラメータフィールドに含まれるパラメータの大きさのために追加の制限を設定します。"
    },
    {
      "indent": 3,
      "text": "The Packet Type indicates the HIP packet type. The individual packet types are defined in the relevant sections. If a HIP host receives a HIP packet that contains an unknown packet type, it MUST drop the packet.",
      "ja": "パケットタイプは、HIPパケットの種類を示します。個々のパケットタイプは、関連セクションで定義されています。 HIPホストが不明なパケットタイプが含まれているHIPパケットを受信した場合、それはパケットをドロップしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The HIP Version is four bits. The current version is 1. The version number is expected to be incremented only if there are incompatible changes to the protocol. Most extensions can be handled by defining new packet types, new parameter types, or new controls.",
      "ja": "HIPバージョンは4ビットです。現在のバージョンは、バージョン番号がプロトコルに互換性のない変更がある場合にのみインクリメントされると予想される1です。ほとんどの拡張機能は、新たなパケットタイプ、新しいパラメータタイプ、または新しいコントロールを定義することによって処理することができます。"
    },
    {
      "indent": 3,
      "text": "The following three bits are reserved for future use. They MUST be zero when sent, and they SHOULD be ignored when handling a received packet.",
      "ja": "以下の3つのビットは将来の使用のために予約されています。送信されたとき、彼らはゼロでなければならない、と、受信したパケットを処理するときに、それらは無視されるべきです。"
    },
    {
      "indent": 3,
      "text": "The two fixed bits in the header are reserved for potential SHIM6 compatibility [SHIM6-PROTO]. For implementations adhering (only) to this specification, they MUST be set as shown when sending and MUST be ignored when receiving. This is to ensure optimal forward compatibility. Note that for implementations that implement other compatible specifications in addition to this specification, the corresponding rules may well be different. For example, in the case that the forthcoming SHIM6 protocol happens to be compatible with this specification, an implementation that implements both this specification and the SHIM6 protocol may need to check these bits in order to determine how to handle the packet.",
      "ja": "ヘッダ内の2つの固定ビットが電位SHIM6互換[SHIM6-PROTO]のために予約されています。示されるように送受信時に無視されなければならない場合、本明細書に（のみ）付着実装のために、それらは設定しなければなりません。これは、最適な上位互換性を確保することです。この明細書に加えて他の互換性の仕様を実現する実装のために、対応するルールが十分に異なっていてもよいことに留意されたいです。例えば、今後SHIM6プロトコルはこの仕様に適合するようにたまたまいる場合には、本明細書及びSHIM6プロトコルの両方を実装する実装では、パケットの処理方法を決定するためにこれらのビットをチェックする必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The HIT fields are always 128 bits (16 bytes) long.",
      "ja": "HITフィールドは常に長い128ビット（16バイト）です。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Checksum",
      "section_title": true,
      "ja": "5.1.1。チェックサム"
    },
    {
      "indent": 3,
      "text": "Since the checksum covers the source and destination addresses in the IP header, it must be recomputed on HIP-aware NAT devices.",
      "ja": "チェックサムは、IPヘッダ内の送信元アドレスと宛先アドレスをカバーするので、HIP対応NATデバイスに再計算されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If IPv6 is used to carry the HIP packet, the pseudo-header [RFC2460] contains the source and destination IPv6 addresses, HIP packet length in the pseudo-header length field, a zero field, and the HIP protocol number (see Section 4) in the Next Header field. The length field is in bytes and can be calculated from the HIP header length field: (HIP Header Length + 1) * 8.",
      "ja": "IPv6はHIPパケットを搬送するために使用される場合、疑似ヘッダ[RFC2460]は疑似ヘッダ長フィールドのソースと宛先IPv6アドレス、HIPパケット長、ゼロフィールド、及びHIPプロトコル番号を含む（セクション4を参照）次ヘッダフィールドに入力します。長さフィールドは、バイト単位であり、HIPヘッダ長フィールドから計算することができる：（HIPヘッダ長+ 1）* 8。"
    },
    {
      "indent": 3,
      "text": "In case of using IPv4, the IPv4 UDP pseudo-header format [RFC0768] is used. In the pseudo-header, the source and destination addresses are those used in the IP header, the zero field is obviously zero, the protocol is the HIP protocol number (see Section 4), and the length is calculated as in the IPv6 case.",
      "ja": "IPv4を使用する場合には、IPv4のUDP疑似ヘッダのフォーマット[RFC0768]は使用されています。疑似ヘッダにおいて、送信元および宛先アドレスはIPヘッダで使用されるものであり、ゼロフィールドが明らかにゼロであり、プロトコルは、HIPプロトコル番号（セクション4を参照）であり、長さは、IPv6の場合のように計算されます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. HIP Controls",
      "section_title": true,
      "ja": "5.1.2。 HIPコントロール"
    },
    {
      "indent": 3,
      "text": "The HIP Controls section conveys information about the structure of the packet and capabilities of the host.",
      "ja": "HIPコントロールセクションでは、ホストのパケットや能力の構造についての情報を伝えます。"
    },
    {
      "indent": 3,
      "text": "The following fields have been defined:",
      "ja": "次のフィールドが定義されています。"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| | | | | | | | | | | | | | | |A|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A - Anonymous: If this is set, the sender's HI in this packet is anonymous, i.e., one not listed in a directory. Anonymous HIs SHOULD NOT be stored. This control is set in packets R1 and/or I2. The peer receiving an anonymous HI may choose to refuse it.",
      "ja": " - 匿名：これが設定されている場合は、このパケット内の送信者のHIは、すなわち、1がディレクトリに記載されていない、匿名です。匿名彼は保存しないでください。この制御は、パケットR1および/またはI2に設定されています。匿名HIを受けたピアは、それを拒否することもできます。"
    },
    {
      "indent": 3,
      "text": "The rest of the fields are reserved for future use and MUST be set to zero on sent packets and ignored on received packets.",
      "ja": "残りのフィールドは、将来の使用のために予約されており、送信されたパケットにゼロに設定し、受信したパケットに無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.3. HIP Fragmentation Support",
      "section_title": true,
      "ja": "5.1.3。 HIPの断片化のサポート"
    },
    {
      "indent": 3,
      "text": "A HIP implementation must support IP fragmentation/reassembly. Fragment reassembly MUST be implemented in both IPv4 and IPv6, but fragment generation is REQUIRED to be implemented in IPv4 (IPv4 stacks and networks will usually do this by default) and RECOMMENDED to be implemented in IPv6. In IPv6 networks, the minimum MTU is larger, 1280 bytes, than in IPv4 networks. The larger MTU size is usually sufficient for most HIP packets, and therefore fragment generation may not be needed. If a host expects to send HIP packets that are larger than the minimum IPv6 MTU, it MUST implement fragment generation even for IPv6.",
      "ja": "HIPの実装では、IPフラグメンテーション/再構築をサポートしている必要があります。フラグメント再構成は、IPv4とIPv6の両方に実装されなければならないが、断片の生成はIPv4のに実装する必要がある（のIPv4スタック及びネットワークは通常、デフォルトでこれを行います）とIPv6に実装することを推奨します。 IPv6ネットワークでは、最小のMTUは、IPv4ネットワークに比べて、1280バイト大きくなります。より大きなMTUサイズが最もHIPパケットの通常十分であり、したがって、フラグメント生成が必要とされなくてもよいです。ホストは、最小のIPv6 MTUよりも大きいHIPパケットを送信することを期待する場合は、それも、IPv6のフラグメント生成を実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In IPv4 networks, HIP packets may encounter low MTUs along their routed path. Since HIP does not provide a mechanism to use multiple IP datagrams for a single HIP packet, support for path MTU discovery does not bring any value to HIP in IPv4 networks. HIP-aware NAT devices MUST perform any IPv4 reassembly/fragmentation.",
      "ja": "IPv4ネットワークでは、HIPパケットは、そのルーティングパスに沿って低いのMTUが発生することがあります。 HIPは、単一のHIPパケットに対して複数のIPデータグラムを使用するためのメカニズムを提供していないので、パスMTU発見のためのサポートは、IPv4ネットワークでのHIPに任意の値をもたらすものではありません。 HIP対応のNATデバイスは、任意のIPv4再構築/断片化を実行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "All HIP implementations have to be careful while employing a reassembly algorithm so that the algorithm is sufficiently resistant to DoS attacks.",
      "ja": "すべてのHIP実装は、アルゴリズムがDoS攻撃に対して十分な耐性になるように再構築アルゴリズムを採用しながら注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "Because certificate chains can cause the packet to be fragmented and fragmentation can open implementation to denial-of-service attacks [KAU03], it is strongly recommended that the separate document specifying the certificate usage in the HIP Base Exchange defines the usage of \"Hash and URL\" formats rather than including certificates in exchanges. With this, most problems related to DoS attacks with fragmentation can be avoided.",
      "ja": "証明書チェーンは、パケットが断片化されたことを引き起こす可能性がありますし、断片化は、サービス拒否攻撃[KAU03]への実装を開くことができるので、それは強くHIPベースExchange内の証明書の使用方法を指定する別の文書は、ハッシュ」の使用方法を定義することが推奨されており、取引所での証明書を含むURL」の形式ではなく。これにより、断片化してDoS攻撃に関連するほとんどの問題を回避することができます。"
    },
    {
      "indent": 0,
      "text": "5.2. HIP Parameters",
      "section_title": true,
      "ja": "5.2。 HIPパラメータ"
    },
    {
      "indent": 3,
      "text": "The HIP Parameters are used to carry the public key associated with the sender's HIT, together with related security and other information. They consist of ordered parameters, encoded in TLV format.",
      "ja": "HIPパラメータは、一緒に関連するセキュリティや他の情報と、送信者のHITに関連する公開鍵を運ぶために使用されています。彼らは、TLV形式でエンコードされた注文のパラメータで構成されています。"
    },
    {
      "indent": 3,
      "text": "The following parameter types are currently defined.",
      "ja": "次のパラメータの種類は、現在定義されています。"
    },
    {
      "indent": 3,
      "text": "+------------------------+-------+----------+-----------------------+\n| TLV                    | Type  | Length   | Data                  |\n+------------------------+-------+----------+-----------------------+\n| R1_COUNTER             | 128   | 12       | System Boot Counter   |\n|                        |       |          |                       |\n| PUZZLE                 | 257   | 12       | K and Random #I       |\n|                        |       |          |                       |\n| SOLUTION               | 321   | 20       | K, Random #I and      |\n|                        |       |          | puzzle solution J     |\n|                        |       |          |                       |\n| SEQ                    | 385   | 4        | Update packet ID      |\n|                        |       |          | number                |\n|                        |       |          |                       |\n| ACK                    | 449   | variable | Update packet ID      |\n|                        |       |          | number                |\n|                        |       |          |                       |\n| DIFFIE_HELLMAN         | 513   | variable | public key            |\n|                        |       |          |                       |\n| HIP_TRANSFORM          | 577   | variable | HIP Encryption and    |\n|                        |       |          | Integrity Transform   |\n|                        |       |          |                       |\n| ENCRYPTED              | 641   | variable | Encrypted part of I2  |\n|                        |       |          | packet                |\n|                        |       |          |                       |\n| HOST_ID                | 705   | variable | Host Identity with    |\n|                        |       |          | Fully-Qualified       |\n|                        |       |          | Domain FQDN (Name) or |\n|                        |       |          | Network Access        |\n|                        |       |          | Identifier (NAI)      |\n|                        |       |          |                       |\n| CERT                   | 768   | variable | HI Certificate; used  |\n|                        |       |          | to transfer           |\n|                        |       |          | certificates.  Usage  |\n|                        |       |          | is not currently      |\n|                        |       |          | defined, but it will  |\n|                        |       |          | be specified in a     |\n|                        |       |          | separate document     |\n|                        |       |          | once needed.          |\n|                        |       |          |                       |\n| NOTIFICATION           | 832   | variable | Informational data    |\n|                        |       |          |                       |\n| ECHO_REQUEST_SIGNED    | 897   | variable | Opaque data to be     |\n|                        |       |          | echoed back; under    |\n|                        |       |          | signature             |\n|                        |       |          |                       |\n| ECHO_RESPONSE_SIGNED   | 961   | variable | Opaque data echoed    |\n|                        |       |          | back; under signature |\n|                        |       |          |                       |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| HMAC                   | 61505 | variable | HMAC-based message    |\n|                        |       |          | authentication code,  |\n|                        |       |          | with key material     |\n|                        |       |          | from HIP_TRANSFORM    |\n|                        |       |          |                       |\n| HMAC_2                 | 61569 | variable | HMAC based message    |\n|                        |       |          | authentication code,  |\n|                        |       |          | with key material     |\n|                        |       |          | from HIP_TRANSFORM.   |\n|                        |       |          | Compared to HMAC, the |\n|                        |       |          | HOST_ID parameter is  |\n|                        |       |          | included in HMAC_2    |\n|                        |       |          | calculation.          |\n|                        |       |          |                       |\n| HIP_SIGNATURE_2        | 61633 | variable | Signature of the R1   |\n|                        |       |          | packet                |\n|                        |       |          |                       |\n| HIP_SIGNATURE          | 61697 | variable | Signature of the      |\n|                        |       |          | packet                |\n|                        |       |          |                       |\n| ECHO_REQUEST_UNSIGNED  | 63661 | variable | Opaque data to be     |\n|                        |       |          | echoed back; after    |\n|                        |       |          | signature             |\n|                        |       |          |                       |\n| ECHO_RESPONSE_UNSIGNED | 63425 | variable | Opaque data echoed    |\n|                        |       |          | back; after signature |\n+------------------------+-------+----------+-----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Because the ordering (from lowest to highest) of HIP parameters is strictly enforced (see Section 5.2.1), the parameter type values for existing parameters have been spaced to allow for future protocol extensions. Parameters numbered between 0-1023 are used in HIP handshake and update procedures and are covered by signatures. Parameters numbered between 1024-2047 are reserved. Parameters numbered between 2048-4095 are used for parameters related to HIP transform types. Parameters numbered between 4096 and (2^16 - 2^12) 61439 are reserved. Parameters numbered between 61440-62463 are used for signatures and signed MACs. Parameters numbered between 62464- 63487 are used for parameters that fall outside of the signed area of the packet. Parameters numbered between 63488-64511 are used for rendezvous and other relaying services. Parameters numbered between 64512-65535 are reserved.",
      "ja": "HIPパラメータの（最低から最高まで）の順序を厳密に（5.2.1項を参照）が施行されているので、既存のパラメータのためのパラメータの型の値は、将来のプロトコル拡張を可能にするために間隔を置いて配置されています。 0-1023間番号パラメータは、HIPハンドシェークおよび更新手順で使用され、署名によって覆われています。 1024-2047の間の番号パラメータが予約されています。 2048-4095の間の番号のパラメータは、HIP種類の変換に関連するパラメータに使用されています。 61439は予約されている - （2 ^ 12 2 ^ 16）4096との間番号パラメータ。 61440から62463の間の番号のパラメータは署名と署名されたMACのために使用されます。 62464- 63487の間番号パラメータは、パケットの署名された領域の外にあるパラメータのために使用されます。 63488から64511の間の番号のパラメータは、ランデブーや他の中継サービスのために使用されています。 64512から65535の間の番号パラメータが予約されています。"
    },
    {
      "indent": 0,
      "text": "5.2.1. TLV Format",
      "section_title": true,
      "ja": "5.2.1。 TLVのフォーマット"
    },
    {
      "indent": 3,
      "text": "The TLV-encoded parameters are described in the following subsections. The type-field value also describes the order of these fields in the packet, except for type values from 2048 to 4095 which are reserved for new transport forms. The parameters MUST be included in the packet such that their types form an increasing order. If the parameter can exist multiple times in the packet, the type value may be the same in consecutive parameters. If the order does not follow this rule, the packet is considered to be malformed and it MUST be discarded.",
      "ja": "TLV符号化されたパラメータは、以下のサブセクションに記載されています。タイプフィールドの値は、新しいトランスポート・フォームのために予約されている2048年から4095にタイプ値を除いて、パケット内のこれらのフィールドの順序を記述する。パラメータは、そのタイプは、昇順を形成するように、パケットに含まれなければなりません。パラメータがパケット内で複数回存在することができる場合は、タイプ値は、連続パラメータの同じであってもよいです。順番はこのルールに従わない場合、パケットは不正な形式されたとみなされ、それを捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "Parameters using type values from 2048 up to 4095 are transport formats. Currently, one transport format is defined: the ESP transport format [RFC5202]. The order of these parameters does not follow the order of their type value, but they are put in the packet in order of preference. The first of the transport formats it the most preferred, and so on.",
      "ja": "4095まで2048年からの型の値を使用したパラメータは、トランスポートフォーマットです。現在、1つのトランスポートフォーマットが定義されている：ESPのトランスポートフォーマット[RFC5202]。これらのパラメータの順序は、そのタイプの値の順序に従っていませんが、それらは優先順にパケットに入れています。トランスポートフォーマットの最初のそれはほとんどのように好適な、と。"
    },
    {
      "indent": 3,
      "text": "All of the TLV parameters have a length (including Type and Length fields), which is a multiple of 8 bytes. When needed, padding MUST be added to the end of the parameter so that the total length becomes a multiple of 8 bytes. This rule ensures proper alignment of data. Any added padding bytes MUST be zeroed by the sender, and their values SHOULD NOT be checked by the receiver.",
      "ja": "TLVパラメータの全ては、8バイトの倍数である、（タイプと長さフィールドを含む）の長さを有します。必要なときに全長が8バイトの倍数になるように、パディングは、パラメータの末尾に追加する必要があります。このルールは、データの適切なアライメントを保証します。任意の追加パディングバイトは、送信者によってゼロにしなければならない、とそれらの値は、受信機によって確認されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Consequently, the Length field indicates the length of the Contents field (in bytes). The total length of the TLV parameter (including Type, Length, Contents, and Padding) is related to the Length field according to the following formula:",
      "ja": "結果として、長さフィールドは、（バイト）内容フィールドの長さを示します。 （タイプ、長さ、内容、およびパディングを含む）TLVパラメータの全長は、以下の式に従ってLengthフィールドに関連しています。"
    },
    {
      "indent": 3,
      "text": "Total Length = 11 + Length - (Length + 3) % 8;",
      "ja": "全長= 11 +長さ - （長さ+ 3）％8。"
    },
    {
      "indent": 3,
      "text": "where % is the modulo operator",
      "ja": "ここで、％はモジュロ演算子であります"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type            |C|             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n/                          Contents                             /\n/                                               +-+-+-+-+-+-+-+-+\n|                                               |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type Type code for the parameter. 16 bits long, C-bit being part of the Type code. C Critical. One if this parameter is critical, and MUST be recognized by the recipient, zero otherwise. The C bit is considered to be a part of the Type field. Consequently, critical parameters are always odd and non-critical ones have an even value. Length Length of the Contents, in bytes. Contents Parameter specific, defined by Type Padding Padding, 0-7 bytes, added if needed",
      "ja": "パラメータのタイプのコードを入力します。 16ビット長、Cビットは、タイプ・コードの一部です。 Cクリティカル。このパラメータが重要であり、そして受信者によって認識されなければならない場合は、1つは、そうでない場合はゼロ。 Cビットは、タイプフィールドの一部であると考えられます。そのため、重要なパラメータは常に奇数であり、非重要なものは、偶数値を持っています。バイト単位のコンテンツの長さの長さ、。必要に応じて内容がタイプパディングパディングによって定義され、特定のパラメータ、0-7バイトが、追加しました"
    },
    {
      "indent": 3,
      "text": "Critical parameters MUST be recognized by the recipient. If a recipient encounters a critical parameter that it does not recognize, it MUST NOT process the packet any further. It MAY send an ICMP or NOTIFY, as defined in Section 4.3.",
      "ja": "重要なパラメータは、受信者によって認識されなければなりません。受信者は、それが認識しない重要なパラメータに遭遇した場合、それはそれ以上のパケットを処理してはいけません。 4.3節で定義されたように、それは、ICMPを送信したり、通知することができます。"
    },
    {
      "indent": 3,
      "text": "Non-critical parameters MAY be safely ignored. If a recipient encounters a non-critical parameter that it does not recognize, it SHOULD proceed as if the parameter was not present in the received packet.",
      "ja": "非クリティカルなパラメータは無視してかまいません。受信者は、それが認識しない非クリティカルなパラメータに遭遇した場合、そのパラメータは、受信したパケットには存在しなかったかのように進めるべき。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Defining New Parameters",
      "section_title": true,
      "ja": "5.2.2。新しいパラメータの定義"
    },
    {
      "indent": 3,
      "text": "Future specifications may define new parameters as needed. When defining new parameters, care must be taken to ensure that the parameter type values are appropriate and leave suitable space for other future extensions. One must remember that the parameters MUST always be arranged in increasing order by Type code, thereby limiting the order of parameters (see Section 5.2.1).",
      "ja": "必要に応じて今後の仕様は、新たなパラメータを定義することができます。新しいパラメータを定義する場合、注意がパラメータの型の値が適切であることを確認し、他の将来の拡張のために、適切なスペースを残すように注意しなければなりません。一つは、パラメータは常に、それによってパラメータ（5.2.1項を参照）の順番を制限し、タイプコードで昇順に配置しなければならないことを覚えておく必要があります。"
    },
    {
      "indent": 3,
      "text": "The following rules must be followed when defining new parameters.",
      "ja": "新しいパラメータを定義するときに、次の規則に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "1. The low-order bit C of the Type code is used to distinguish between critical and non-critical parameters.",
      "ja": "1.コードの下位ビットCは、クリティカル及び非クリティカルパラメータとを区別するために使用されます。"
    },
    {
      "indent": 3,
      "text": "2. A new parameter may be critical only if an old recipient ignoring it would cause security problems. In general, new parameters SHOULD be defined as non-critical, and expect a reply from the recipient.",
      "ja": "2.新しいパラメータは、それを無視し、古い受信者がセキュリティ上の問題を引き起こす場合にのみ重要になることがあります。一般的には、新しいパラメータは非クリティカルとして定義され、受信者からの応答を期待するべきです。"
    },
    {
      "indent": 3,
      "text": "3. If a system implements a new critical parameter, it MUST provide the ability to set the associated feature off, such that the critical parameter is not sent at all. The configuration option must be well documented. Implementations operating in a mode adhering to this specification MUST disable the sending of new critical parameters. In other words, the management interface MUST allow vanilla standards-only mode as a default configuration setting, and MAY allow new critical payloads to be configured on (and off).",
      "ja": "3.システムが新しい重要なパラメータを実装している場合、それは重要なパラメータが全く送られないように、関連する機能をオフに設定する機能を提供しなければなりません。設定オプションは、十分に文書化されなければなりません。この仕様に準拠モードで動作する実装は、新しい重要なパラメータの送信を無効にする必要があります。言い換えれば、管理インターフェイスは、デフォルトの構成設定としてバニラ規格専用モードを許容しなければなりませんし、新しい重要なペイロードは（オフ）に設定されることを可能にします。"
    },
    {
      "indent": 3,
      "text": "4. See Section 9 for allocation rules regarding Type codes.",
      "section_title": true,
      "ja": "4.コードについての割り当て規則については、セクション9を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.3. R1_COUNTER",
      "section_title": true,
      "ja": "5.2.3。 R1_COUNTER"
    },
    {
      "indent": 6,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Reserved, 4 bytes                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                R1 generation counter, 8 bytes                 |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 128 Length 12 R1 generation counter The current generation of valid puzzles",
      "ja": "タイプ128の長さ12 R1生成カウンタ有効なパズルの現在の世代"
    },
    {
      "indent": 3,
      "text": "The R1_COUNTER parameter contains a 64-bit unsigned integer in network-byte order, indicating the current generation of valid puzzles. The sender is supposed to increment this counter periodically. It is RECOMMENDED that the counter value is incremented at least as often as old PUZZLE values are deprecated so that SOLUTIONs to them are no longer accepted.",
      "ja": "R1_COUNTERパラメーターは、有効なパズルの現在の世代を示し、ネットワークバイト順で64ビットの符号なし整数を含んでいます。送信者は、定期的にこのカウンタをインクリメントすることになっています。それらの解決策は、もはや受け入れられているように、古いPUZZLE値は推奨されていないとして、カウンタ値が、少なくともできるだけ頻繁にインクリメントすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The R1_COUNTER parameter is optional. It SHOULD be included in the R1 (in which case, it is covered by the signature), and if present in the R1, it MAY be echoed (including the Reserved field verbatim) by the Initiator in the I2.",
      "ja": "R1_COUNTERパラメータはオプションです。これはR1（その場合、それは署名で覆われている）に含まれるべきであり、R1中に存在する場合、それはI2にイニシエータによって（逐語的Reservedフィールドを含む）をエコーされるかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.2.4. PUZZLE",
      "section_title": true,
      "ja": "5.2.4。パズル"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  K, 1 byte    |    Lifetime   |        Opaque, 2 bytes        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Random #I, 8 bytes                       |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 257 Length 12 K K is the number of verified bits Lifetime puzzle lifetime 2^(value-32) seconds Opaque data set by the Responder, indexing the puzzle Random #I random number",
      "ja": "12 K Kは、生涯パズル寿命2 ^（値-32）秒不透明なデータがレスポンダによって設定された検証ビット数パズルランダム#I乱数をインデックス257の長さを入力"
    },
    {
      "indent": 3,
      "text": "Random #I is represented as a 64-bit integer, K and Lifetime as 8-bit integers, all in network byte order.",
      "ja": "ランダム#Iは、すべてのネットワークバイト順に、8ビット整数として64ビット整数、Kおよび寿命のように表されます。"
    },
    {
      "indent": 3,
      "text": "The PUZZLE parameter contains the puzzle difficulty K and a 64-bit puzzle random integer #I. The Puzzle Lifetime indicates the time during which the puzzle solution is valid, and sets a time limit that should not be exceeded by the Initiator while it attempts to solve the puzzle. The lifetime is indicated as a power of 2 using the formula 2^(Lifetime-32) seconds. A puzzle MAY be augmented with an ECHO_REQUEST_SIGNED or an ECHO_REQUEST_UNSIGNED parameter included in the R1; the contents of the echo request are then echoed back in the ECHO_RESPONSE_SIGNED or in the ECHO_RESPONSE_UNSIGNED, allowing the Responder to use the included information as a part of its puzzle processing.",
      "ja": "パズルパラメータは、パズルの難易度Kと64ビットのパズルランダム整数#Iを含有します。パズル寿命はパズルの解決策が有効である時間を示し、それはパズルを解決しようとしながら、イニシエータが超えてはならない制限時間を設定します。寿命は式2 ^（寿命-32）秒を使用して、2のべき乗として示されています。パズルはECHO_REQUEST_SIGNED又はR1に含まECHO_REQUEST_UNSIGNEDパラメータで増強されるかもしれません。エコー要求の内容物は、次いでレスポンダは、そのパズルの処理の一部として含まれる情報を使用することができ、ECHO_RESPONSE_SIGNEDまたはECHO_RESPONSE_UNSIGNEDにエコーバックされます。"
    },
    {
      "indent": 3,
      "text": "The Opaque and Random #I field are not covered by the HIP_SIGNATURE_2 parameter.",
      "ja": "不透明とランダム#IフィールドがHIP_SIGNATURE_2パラメータによってカバーされていません。"
    },
    {
      "indent": 0,
      "text": "5.2.5. SOLUTION",
      "section_title": true,
      "ja": "5.2.5。解決"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| K, 1 byte     |   Reserved    |        Opaque, 2 bytes        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Random #I, 8 bytes                       |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Puzzle solution #J, 8 bytes                   |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 321 Length 20 K K is the number of verified bits Reserved zero when sent, ignored when received Opaque copied unmodified from the received PUZZLE parameter Random #I random number Puzzle solution #J random number",
      "ja": "20 K Kはゼロ送信不透明が受信パズルパラメータランダム#I乱数パズル溶液から修飾されていないコピー受信時に無視#J乱数を予約確認ビットの数である321の長さを入力"
    },
    {
      "indent": 3,
      "text": "Random #I and Random #J are represented as 64-bit integers, K as an 8-bit integer, all in network byte order.",
      "ja": "ランダム#Iとランダム#JがKは、すべてのネットワークバイト順に、8ビットの整数として、64ビット整数として表されます。"
    },
    {
      "indent": 3,
      "text": "The SOLUTION parameter contains a solution to a puzzle. It also echoes back the random difficulty K, the Opaque field, and the puzzle integer #I.",
      "ja": "SOLUTIONパラメータは、パズルの解が含まれています。また、ランダム困難K、不透明なフィールド、およびパズル整数#Iをエコーバック。"
    },
    {
      "indent": 0,
      "text": "5.2.6. DIFFIE_HELLMAN",
      "section_title": true,
      "ja": "5.2.6。 DIFFIE_HELLMAN"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Group ID    |      Public Value Length      | Public Value  /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Group ID    |      Public Value Length      | Public Value  /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                               |            padding            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 513 Length length in octets, excluding Type, Length, and padding Group ID defines values for p and g Public Value length of the following Public Value in octets Length Public Value the sender's public Diffie-Hellman key",
      "ja": "タイプ、長さを除いた、オクテット513の長さの長さを入力し、パディンググループIDは、pの値を定義し、送信者の公開のDiffie-Hellmanキーオクテット長公開値で、以下の公開値gの公開値の長さ"
    },
    {
      "indent": 3,
      "text": "The following Group IDs have been defined:",
      "ja": "以下のグループIDが定義されています。"
    },
    {
      "indent": 6,
      "text": "Group Value Reserved 0 384-bit group 1 OAKLEY well-known group 1 2 1536-bit MODP group 3 3072-bit MODP group 4 6144-bit MODP group 5 8192-bit MODP group 6",
      "ja": "グループ値予約0 384ビットグループ1 OAKLEY周知群1 2 1536ビットMODPグループ3 3072ビットMODPグループ4 6144ビットMODPグループ5 8192ビットMODPグループ6"
    },
    {
      "indent": 3,
      "text": "The MODP Diffie-Hellman groups are defined in [RFC3526]. The OAKLEY well-known group 1 is defined in Appendix E.",
      "ja": "MODPのDiffie-Hellmanグループは、[RFC3526]で定義されています。 OAKLEY周知グループ1は、付録Eに定義されています"
    },
    {
      "indent": 3,
      "text": "The sender can include at most two different Diffie-Hellman public values in the DIFFIE_HELLMAN parameter. This gives the possibility, e.g., for a server to provide a weaker encryption possibility for a PDA host that is not powerful enough. It is RECOMMENDED that the Initiator, receiving more than one public value, selects the stronger one, if it supports it.",
      "ja": "送信者はDIFFIE_HELLMANパラメータの最大2つの異なるのDiffie-Hellman公開値を含めることができます。これは十分に強力ではないPDAホストの弱い暗号化する可能性を提供するために、サーバーのために、例えば、可能性を提供します。それはそれをサポートしているかどうかは、イニシエータが、複数のパブリック値を受け、強い一つを選択することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "A HIP implementation MUST implement Group IDs 1 and 3. The 384-bit group can be used when lower security is enough (e.g., web surfing) and when the equipment is not powerful enough (e.g., some PDAs). It is REQUIRED that the default configuration allows Group ID 1 usage, but it is RECOMMENDED that applications that need stronger security turn Group ID 1 support off. Equipment powerful enough SHOULD implement also Group ID 5. The 384-bit group is defined in Appendix D.",
      "ja": "HIPの実装は、より低いセキュリティが十分に（例えば、ウェブサーフィン）である場合に384ビットのグループを使用することができるグループID 1と3を実装し、装置が十分に強力ではない（例えば、一部のPDA）しなければなりません。デフォルトの設定は、グループID 1回の使用を許可しますが、強力なセキュリティを必要とするアプリケーションは、グループIDに1のサポートをオフにすることをお勧めされている必要があります。また、384ビットのグループは、付録Dで定義されている5グループIDを実装する必要があり、十分に強力な装備"
    },
    {
      "indent": 3,
      "text": "To avoid unnecessary failures during the base exchange, the rest of the groups SHOULD be implemented in hosts where resources are adequate.",
      "ja": "塩基交換の際に、不必要な障害を避けるために、グループの残りの部分は、リソースが十分であるホストに実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.7. HIP_TRANSFORM",
      "section_title": true,
      "ja": "5.2.7。 HIP_TRANSFORM"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Suite ID #1        |          Suite ID #2          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Suite ID #n        |             Padding           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 577 Length length in octets, excluding Type, Length, and padding Suite ID defines the HIP Suite to be used",
      "ja": "タイプ、長さを除いた、オクテット577の長さの長さを入力し、パディングスイートIDを使用することがHIPスイートを定義します"
    },
    {
      "indent": 3,
      "text": "The following Suite IDs are defined ([RFC4307],[RFC2451]):",
      "ja": "以下スイートIDは（[RFC4307]、[RFC2451]）に定義されます："
    },
    {
      "indent": 9,
      "text": "Suite ID Value",
      "ja": "スイートID値"
    },
    {
      "indent": 9,
      "text": "RESERVED 0 AES-CBC with HMAC-SHA1 1 3DES-CBC with HMAC-SHA1 2 3DES-CBC with HMAC-MD5 3 BLOWFISH-CBC with HMAC-SHA1 4 NULL-ENCRYPT with HMAC-SHA1 5 NULL-ENCRYPT with HMAC-MD5 6",
      "ja": "HMAC-SHA1、HMAC-MD5 6にHMAC-SHA1 5 NULL暗号化とHMAC-SHA1 4 NULL暗号化とHMAC-MD5 3 BLOWFISH-CBCとHMAC-SHA1 2つの3DES-CBCと1つの3DES-CBCと0 AES-CBC予約"
    },
    {
      "indent": 3,
      "text": "The sender of a HIP_TRANSFORM parameter MUST make sure that there are no more than six (6) HIP Suite IDs in one HIP_TRANSFORM parameter. Conversely, a recipient MUST be prepared to handle received transport parameters that contain more than six Suite IDs by accepting the first six Suite IDs and dropping the rest. The limited number of transforms sets the maximum size of HIP_TRANSFORM parameter. As the default configuration, the HIP_TRANSFORM parameter MUST contain at least one of the mandatory Suite IDs. There MAY be a configuration option that allows the administrator to override this default.",
      "ja": "HIP_TRANSFORMパラメータの送信者は1つのHIP_TRANSFORMパラメータには半年以上（6）HIPスイートIDが存在しないことを確認する必要があります。逆に、受信者は最初の6つのスイートIDを受け付け、残りを滴下し半年以上スイートIDを含む受信したトランスポートパラメータを処理するために準備されなければなりません。変換の限られた数HIP_TRANSFORMパラメータの最大サイズを設定します。デフォルトの設定として、HIP_TRANSFORMパラメータは必須スイートIDの少なくとも一つを含まなければなりません。管理者は、このデフォルトを上書きすることを可能にする設定オプションがあるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The Responder lists supported and desired Suite IDs in order of preference in the R1, up to the maximum of six Suite IDs. The Initiator MUST choose only one of the corresponding Suite IDs. That Suite ID will be used for generating the I2.",
      "ja": "レスポンダリストは、6つのスイートIDの最大値まで、R1における優先順にスイートIDをサポートし、望ましいです。イニシエータは、対応するスイートIDの一つだけ選択する必要があります。そのスイートのIDは、I2を生成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Mandatory implementations: AES-CBC with HMAC-SHA1 and NULL-ENCRYPTION with HMAC-SHA1.",
      "ja": "必須の実装：HMAC-SHA1とHMAC-SHA1とNULL暗号化とAES-CBC。"
    },
    {
      "indent": 0,
      "text": "5.2.8. HOST_ID",
      "section_title": true,
      "ja": "5.2.8。 HOST_ID"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          HI Length            |DI-type|      DI Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Host Identity                         /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                               |         Domain Identifier     /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                               |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 705 Length length in octets, excluding Type, Length, and Padding HI Length length of the Host Identity in octets DI-type type of the following Domain Identifier field DI Length length of the FQDN or NAI in octets Host Identity actual Host Identity Domain Identifier the identifier of the sender",
      "ja": "アイデンティティ実際のホストアイデンティティドメイン識別子をホストオクテットでFQDNまたはNAIの次のドメイン識別子フィールドDI長長のオクテットDI型タイプでは705タイプ、長さを除いたオクテットの長さ長さ、およびホストIDのパディングHI長の長さを入力送信者の識別子"
    },
    {
      "indent": 3,
      "text": "The Host Identity is represented in RFC 4034 [RFC4034] format. The algorithms used in RDATA format are the following:",
      "ja": "ホストIDは、RFC 4034 [RFC4034]の形式で表されています。 RDATA形式で使用されるアルゴリズムは以下の通りです。"
    },
    {
      "indent": 9,
      "text": "Algorithms Values",
      "ja": "アルゴリズム値"
    },
    {
      "indent": 9,
      "text": "RESERVED 0 DSA 3 [RFC2536] (RECOMMENDED) RSA/SHA1 5 [RFC3110] (REQUIRED)",
      "ja": "RESERVED 0 DSA 3 [RFC2536]（推奨）RSA / SHA1 5 [RFC3110]（必須）"
    },
    {
      "indent": 3,
      "text": "The following DI-types have been defined:",
      "ja": "次DI-タイプが定義されています。"
    },
    {
      "indent": 10,
      "text": "Type                    Value\nnone included           0\nFQDN                    1\nNAI                     2",
      "raw": true
    },
    {
      "indent": 10,
      "text": "FQDN Fully Qualified Domain Name, in binary format. NAI Network Access Identifier",
      "ja": "バイナリ形式でのFQDN完全修飾ドメイン名、。 NAIネットワークアクセス識別子"
    },
    {
      "indent": 3,
      "text": "The format for the FQDN is defined in RFC 1035 [RFC1035] Section 3.1. The format for NAI is defined in [RFC4282]",
      "ja": "FQDNの形式は、RFC 1035 [RFC1035]セクション3.1で定義されています。 NAIのフォーマットは、[RFC4282]で定義されています"
    },
    {
      "indent": 3,
      "text": "If there is no Domain Identifier, i.e., the DI-type field is zero, the DI Length field is set to zero as well.",
      "ja": "いかなるドメイン識別子がない場合、すなわち、DI-typeフィールドがゼロである、DI長フィールドも同様にゼロに設定されます。"
    },
    {
      "indent": 0,
      "text": "5.2.9. HMAC",
      "section_title": true,
      "ja": "5.2.9。 HMAC"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                             HMAC                              |\n/                                                               /\n/                               +-------------------------------+\n|                               |            Padding            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 61505 Length length in octets, excluding Type, Length, and Padding HMAC HMAC computed over the HIP packet, excluding the HMAC parameter and any following parameters, such as HIP_SIGNATURE, HIP_SIGNATURE_2, ECHO_REQUEST_UNSIGNED, or ECHO_RESPONSE_UNSIGNED. The checksum field MUST be set to zero and the HIP header length in the HIP common header MUST be calculated not to cover any excluded parameters when the HMAC is calculated. The size of the HMAC is the natural size of the hash computation output depending on the used hash function.",
      "ja": "HMACパラメータなどHIP_SIGNATURE、HIP_SIGNATURE_2、ECHO_REQUEST_UNSIGNED、又はECHO_RESPONSE_UNSIGNEDなどの任意の以下のパラメータを除く、HIPパケットにわたって計算タイプ、長さ、及びパディングHMAC HMAC除く、オクテット61505長の長さを入力します。チェックサムフィールドはゼロに設定しなければならなくて、HIP共通ヘッダにおけるHIPヘッダ長は、HMACを計算する際、任意の除外パラメータをカバーしないように計算しなければなりません。 HMACの大きさは、使用されるハッシュ関数に応じてハッシュ演算出力の自然なサイズです。"
    },
    {
      "indent": 3,
      "text": "The HMAC calculation and verification process is presented in Section 6.4.1.",
      "ja": "HMACの計算と検証プロセスは、セクション6.4.1に示されています。"
    },
    {
      "indent": 0,
      "text": "5.2.10. HMAC_2",
      "section_title": true,
      "ja": "5.2.10。 HMAC_2"
    },
    {
      "indent": 3,
      "text": "The parameter structure is the same as in Section 5.2.9. The fields are:",
      "ja": "パラメータ構造は、5.2.9項と同じです。フィールドは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Type 61569 Length length in octets, excluding Type, Length, and Padding HMAC HMAC computed over the HIP packet, excluding the HMAC parameter and any following parameters such as HIP_SIGNATURE, HIP_SIGNATURE_2, ECHO_REQUEST_UNSIGNED, or ECHO_RESPONSE_UNSIGNED, and including an additional sender's HOST_ID parameter during the HMAC calculation. The checksum field MUST be set to zero and the HIP header length in the HIP common header MUST be calculated not to cover any excluded parameters when the HMAC is calculated. The size of the HMAC is the natural size of the hash computation output depending on the used hash function.",
      "ja": "HMACのパラメータや、HIP_SIGNATURE、HIP_SIGNATURE_2、ECHO_REQUEST_UNSIGNED、またはECHO_RESPONSE_UNSIGNEDなど任意の次のパラメータを除く、HIPパケットにわたって計算タイプ、長さ、およびパディングHMAC HMACを除く、オクテット単位で61569の長さの長さを入力し、中に追加の送信者のHOST_IDパラメータを含みますHMAC計算。チェックサムフィールドはゼロに設定しなければならなくて、HIP共通ヘッダにおけるHIPヘッダ長は、HMACを計算する際、任意の除外パラメータをカバーしないように計算しなければなりません。 HMACの大きさは、使用されるハッシュ関数に応じてハッシュ演算出力の自然なサイズです。"
    },
    {
      "indent": 3,
      "text": "The HMAC calculation and verification process is presented in Section 6.4.1.",
      "ja": "HMACの計算と検証プロセスは、セクション6.4.1に示されています。"
    },
    {
      "indent": 0,
      "text": "5.2.11. HIP_SIGNATURE",
      "section_title": true,
      "ja": "5.2.11。 HIP_SIGNATURE"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    SIG alg    |                  Signature                    /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                               |             Padding           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 61697 Length length in octets, excluding Type, Length, and Padding SIG alg signature algorithm Signature the signature is calculated over the HIP packet, excluding the HIP_SIGNATURE parameter and any parameters that follow the HIP_SIGNATURE parameter. The checksum field MUST be set to zero, and the HIP header length in the HIP common header MUST be calculated only to the beginning of the HIP_SIGNATURE parameter when the signature is calculated.",
      "ja": "タイプ、長さを除く、オクテット単位で61697の長さの長さを入力し、パディングSIG ALG署名アルゴリズム署名署名はHIP_SIGNATUREパラメータとHIP_SIGNATUREパラメータに従う任意のパラメータを除く、HIPパケットにわたって計算されます。チェックサムフィールドはゼロに設定しなければなりません、そして署名を算出する際HIP共通ヘッダにおけるHIPヘッダ長だけHIP_SIGNATUREパラメータの最初に計算しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The signature algorithms are defined in Section 5.2.8. The signature in the Signature field is encoded using the proper method depending on the signature algorithm (e.g., according to [RFC3110] in case of RSA/SHA1, or according to [RFC2536] in case of DSA).",
      "ja": "署名アルゴリズムはセクション5.2.8で定義されています。署名フィールドの署名が署名アルゴリズム（例えば、に従ってRSA / SHA1の場合には[RFC3110]、またはDSAの場合には[RFC2536]に記載）に応じて適切な方法を使用して符号化されます。"
    },
    {
      "indent": 3,
      "text": "The HIP_SIGNATURE calculation and verification process is presented in Section 6.4.2.",
      "ja": "HIP_SIGNATURE計算と検証プロセスは6.4.2項に示されています。"
    },
    {
      "indent": 0,
      "text": "5.2.12. HIP_SIGNATURE_2",
      "section_title": true,
      "ja": "5.2.12。 HIP_SIGNATURE_2"
    },
    {
      "indent": 3,
      "text": "The parameter structure is the same as in Section 5.2.11. The fields are:",
      "ja": "パラメータ構造は、セクション5.2.11と同じです。フィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Type 61633 Length length in octets, excluding Type, Length, and Padding SIG alg signature algorithm Signature Within the R1 packet that contains the HIP_SIGNATURE_2 parameter, the Initiator's HIT, the checksum field, and the Opaque and Random #I fields in the PUZZLE parameter MUST be set to zero while computing the HIP_SIGNATURE_2 signature. Further, the HIP packet length in the HIP header MUST be adjusted as if the HIP_SIGNATURE_2 was not in the packet during the signature calculation, i.e., the HIP packet length points to the beginning of the HIP_SIGNATURE_2 parameter during signing and verification.",
      "ja": "タイプ、長さを除いた、オクテット61633長の長さを入力し、HIP_SIGNATURE_2パラメータ、イニシエータのHIT、チェックサムフィールド、およびPUZZLEパラメータMUSTで不透明とランダム#Iフィールドを含むR1パケット内のパディングSIG ALG署名アルゴリズム署名HIP_SIGNATURE_2署名を計算しながら、ゼロに設定されます。 HIP_SIGNATURE_2署名計算時パケットでなかったかのように、さらに、HIPヘッダーのHIPパケット長を調整しなければならない、即ち、HIPパケット長点署名と検証中HIP_SIGNATURE_2パラメータの先頭に。"
    },
    {
      "indent": 3,
      "text": "Zeroing the Initiator's HIT makes it possible to create R1 packets beforehand, to minimize the effects of possible DoS attacks. Zeroing the Random #I and Opaque fields within the PUZZLE parameter allows these fields to be populated dynamically on precomputed R1s.",
      "ja": "イニシエータのHITをゼロにすることは可能DoS攻撃の影響を最小限に抑えるために、事前にR1パケットを作成することが可能となります。 PUZZLEパラメータ内のランダム#Iと不透明なフィールドをゼロにすることは、これらのフィールドは、事前に計算のR1に動的に移入することができます。"
    },
    {
      "indent": 3,
      "text": "Signature calculation and verification follows the process in Section 6.4.2.",
      "ja": "署名の計算及び検証は、セクション6.4.2の処理に従います。"
    },
    {
      "indent": 0,
      "text": "5.2.13. SEQ",
      "section_title": true,
      "ja": "5.2.13。 SEQ"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                            Update ID                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 385 Length 4 Update ID 32-bit sequence number",
      "ja": "385長さ4の更新ID 32ビットのシーケンス番号を入力"
    },
    {
      "indent": 3,
      "text": "The Update ID is an unsigned quantity, initialized by a host to zero upon moving to ESTABLISHED state. The Update ID has scope within a single HIP association, and not across multiple associations or multiple hosts. The Update ID is incremented by one before each new UPDATE that is sent by the host; the first UPDATE packet originated by a host has an Update ID of 0.",
      "ja": "更新IDは、確立された状態に移動する際にゼロにホストによって初期化符号なしの数量です。更新IDは、単一のHIPアソシエーション内ではなく、複数のアソシエーションまたは複数のホスト間で範囲を有しています。更新IDは、ホストによって送信されたそれぞれの新しいUPDATEの前に1ずつインクリメントされます。ホストによって発信最初のUPDATEパケットは0の更新IDを持っています。"
    },
    {
      "indent": 0,
      "text": "5.2.14. ACK",
      "section_title": true,
      "ja": "5.2.14。 ACK"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       peer Update ID                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 449 Length variable (multiple of 4) peer Update ID 32-bit sequence number corresponding to the Update ID being ACKed.",
      "ja": "449長さ変数（4の倍数）ACKされている情報を更新するIDに対応するピア更新ID 32ビットのシーケンス番号を入力します。"
    },
    {
      "indent": 3,
      "text": "The ACK parameter includes one or more Update IDs that have been received from the peer. The Length field identifies the number of peer Update IDs that are present in the parameter.",
      "ja": "ACKパラメータがピアから受信された1つまたは複数の更新IDを含みます。 Lengthフィールドは、パラメータに存在するピア更新IDの数を識別する。"
    },
    {
      "indent": 0,
      "text": "5.2.15. ENCRYPTED",
      "section_title": true,
      "ja": "5.2.15。 ENCRYPTED"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Reserved                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              IV                               /\n/                                                               /\n/                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               /\n/                        Encrypted data                         /\n/                                                               /\n/                               +-------------------------------+\n/                               |            Padding            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 641 Length length in octets, excluding Type, Length, and Padding Reserved zero when sent, ignored when received IV Initialization vector, if needed, otherwise nonexistent. The length of the IV is inferred from the HIP transform. Encrypted The data is encrypted using an encryption algorithm data as defined in HIP transform.",
      "ja": "そうでない場合は、存在しない、タイプ、長さ、およびパディング予約IV初期化ベクトルを受け取ったときに、必要に応じて、無視され、送信されたゼロを除く、オクテット単位で641の長さの長さを入力します。 IVの長さは、変換HIPから推測されます。 HIPで定義されたデータは変換暗号化アルゴリズムのデータを使用して暗号化された暗号化されました。"
    },
    {
      "indent": 3,
      "text": "The ENCRYPTED parameter encapsulates another parameter, the encrypted data, which holds one or more HIP parameters in block encrypted form.",
      "ja": "ENCRYPTEDパラメータが他のパラメータは、ブロック暗号化された形態における1つ以上のHIPパラメータを保持している暗号化されたデータを、カプセル化します。"
    },
    {
      "indent": 3,
      "text": "Consequently, the first fields in the encapsulated parameter(s) are Type and Length of the first such parameter, allowing the contents to be easily parsed after decryption.",
      "ja": "従って、カプセル化されたパラメータ（単数または複数）の最初のフィールドは、内容が容易に復号化した後に解析することを可能にする、最初のそのようなパラメータのタイプと長さです。"
    },
    {
      "indent": 3,
      "text": "The field labelled \"Encrypted data\" consists of the output of one or more HIP parameters concatenated together that have been passed through an encryption algorithm. Each of these inner parameters is padded according to the rules of Section 5.2.1 for padding individual parameters. As a result, the concatenated parameters will be a block of data that is 8-byte aligned.",
      "ja": "「暗号化データ」と表示されたフィールドは、暗号化アルゴリズムを通過してきた一緒に連結された1つ以上のHIPパラメータの出力で構成されています。これらの内の各パラメータは、個々のパラメータをパディングするための5.2.1の規則に従ってパディングされます。その結果、連結パラメータは、8バイト境界で整列されているデータのブロックです。"
    },
    {
      "indent": 3,
      "text": "Some encryption algorithms require that the data to be encrypted must be a multiple of the cipher algorithm block size. In this case, the above block of data MUST include additional padding, as specified by the encryption algorithm. The size of the extra padding is selected so that the length of the unencrypted data block is a multiple of the cipher block size. The encryption algorithm may specify padding bytes other than zero; for example, AES [FIPS01] uses the PKCS5 padding scheme (see section 6.1.1 of [RFC2898]) where the remaining n bytes to fill the block each have the value n. This yields an \"unencrypted data\" block that is transformed to an \"encrypted data\" block by the cipher suite. This extra padding added to the set of parameters to satisfy the cipher block alignment rules is not counted in HIP TLV length fields, and this extra padding should be removed by the cipher suite upon decryption.",
      "ja": "いくつかの暗号化アルゴリズムは、暗号化すべきデータが暗号アルゴリズムのブロックサイズの倍数でなければならないことが必要です。暗号化アルゴリズムで指定され、この場合、データの上記ブロックは、追加のパディングを含まなければなりません。暗号化されていないデータブロックの長さが暗号ブロックサイズの倍数になるように、余分なパディングのサイズが選択されます。暗号化アルゴリズムは、ゼロ以外のパディングバイトを指定してもよいです。例えば、AESは[FIPS01残りのNはそれぞれ値nを有するブロックを埋めるバイトPKCS5パディング方式を（[RFC2898]のセクション6.1.1を参照）を使用します。これは、暗号スイートによって、「暗号化されたデータ」ブロックに変換され、「暗号化されていないデータ」ブロックを生成します。暗号ブロックアライメントルールを満たすためにパラメータのセットに加え、このパディングは、HIP TLVの長さフィールドにカウントされず、この余分なパディングは、復号時に暗号スイートによって除去されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the length of the cipher suite output may be smaller or larger than the length of the set of parameters to be encrypted, since the encryption process may compress the data or add additional padding to the data.",
      "ja": "暗号化処理は、データを圧縮またはデータに追加のパディングを追加することができるので、暗号スイート出力の長さは、暗号化されるパラメータのセットの長さよりも小さくても大きくてもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Once this encryption process is completed, the Encrypted data field is ready for inclusion in the Parameter. If necessary, additional Padding for 8-byte alignment is then added according to the rules of Section 5.2.1.",
      "ja": "この暗号化プロセスが完了すると、暗号化されたデータフィールドは、パラメータに含めるための準備ができています。必要に応じて、8バイトアラインメントのための追加のパディングは、その後、セクション5.2.1の規則に従って追加されます。"
    },
    {
      "indent": 0,
      "text": "5.2.16. NOTIFICATION",
      "section_title": true,
      "ja": "5.2.16。通知"
    },
    {
      "indent": 3,
      "text": "The NOTIFICATION parameter is used to transmit informational data, such as error conditions and state transitions, to a HIP peer. A NOTIFICATION parameter may appear in the NOTIFY packet type. The use of the NOTIFICATION parameter in other packet types is for further study.",
      "ja": "通知パラメータは、HIPピアに、そのようなエラー状態と状態遷移などの情報データを送信するために使用されます。通知パラメータは、NOTIFYパケットタイプに表示される場合があります。他のパケットタイプで通知パラメータを使用することは、今後の検討課題です。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Reserved             |      Notify Message Type      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               /\n/                   Notification Data                           /\n/                                               +---------------+\n/                                               |     Padding   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 832 Length length in octets, excluding Type, Length, and Padding Reserved zero when sent, ignored when received Notify Message specifies the type of notification Type Notification informational or error data transmitted in addition Data to the Notify Message Type. Values for this field are type specific (see below). Padding any Padding, if necessary, to make the parameter a multiple of 8 bytes.",
      "ja": "通知メッセージタイプに加算データで送信された通知タイプ通知情報又はエラーデータの種類を指定するNOTIFYメッセージを受信したときに無視タイプ、長さ、及びパディング予約送信ゼロを除く、オクテット単位で832の長さの長さを入力します。このフィールドの値は、型の特定（下記参照）です。必要に応じてパラメータを8バイトの倍数を作るために、任意のパディングをパディング。"
    },
    {
      "indent": 3,
      "text": "Notification information can be error messages specifying why an SA could not be established. It can also be status data that a process managing an SA database wishes to communicate with a peer process. The table below lists the Notification messages and their corresponding values.",
      "ja": "通知情報は、SAを確立することができなかった理由を指定したエラーメッセージすることができます。それはまた、SAデータベースを管理プロセスは、ピア・プロセスと通信することを望む状況データとすることができます。以下の表は、通知メッセージとそれに対応する値を示しています。"
    },
    {
      "indent": 3,
      "text": "To avoid certain types of attacks, a Responder SHOULD avoid sending a NOTIFICATION to any host with which it has not successfully verified a puzzle solution.",
      "ja": "あるタイプの攻撃を回避するために、レスポンダは、それが正常にパズルの解決策を確認しなかったとの任意のホストに通知を送信することは避けてください。"
    },
    {
      "indent": 3,
      "text": "Types in the range 0-16383 are intended for reporting errors and in the range 16384-65535 for other status information. An implementation that receives a NOTIFY packet with a NOTIFICATION error parameter in response to a request packet (e.g., I1, I2, UPDATE) SHOULD assume that the corresponding request has failed entirely. Unrecognized error types MUST be ignored except that they SHOULD be logged.",
      "ja": "範囲0から16383でタイプは、報告エラーやその他のステータス情報の範囲は16384から65535に意図されています。インプリメンテーションは、要求パケットに応答してNOTIFICATION誤差パラメータでパケットをNOTIFY受信する（例えば、I1、I2、UPDATE）は、対応する要求が完全に失敗したと仮定すべきです。認識されないエラーの種類は、彼らがログに記録されるべきであることを除いて無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Notify payloads with status types MUST be ignored if not recognized.",
      "ja": "認識されない場合は、ステータスの種類と通知ペイロードを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "NOTIFICATION PARAMETER - ERROR TYPES     Value\n------------------------------------     -----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "UNSUPPORTED_CRITICAL_PARAMETER_TYPE 1",
      "ja": "UNSUPPORTED_CRITICAL_PARAMETER_TYPE 1"
    },
    {
      "indent": 6,
      "text": "Sent if the parameter type has the \"critical\" bit set and the parameter type is not recognized. Notification Data contains the two-octet parameter type.",
      "ja": "パラメータタイプは「重要な」ビットがセットされていると、パラメータの種類が認識されない場合に送信されます。通知データは、2オクテットのパラメータの型が含まれています。"
    },
    {
      "indent": 3,
      "text": "INVALID_SYNTAX 7",
      "ja": "INVALID_SYNTAX 7"
    },
    {
      "indent": 6,
      "text": "Indicates that the HIP message received was invalid because some type, length, or value was out of range or because the request was rejected for policy reasons. To avoid a denial-of-service attack using forged messages, this status may only be returned for packets whose HMAC (if present) and SIGNATURE have been verified. This status MUST be sent in response to any error not covered by one of the other status types, and should not contain details to avoid leaking information to someone probing a node. To aid debugging, more detailed error information SHOULD be written to a console or log.",
      "ja": "いくつかのタイプ、長さ、または値が範囲外か、要求がポリシー上の理由で拒否されたためであったため、メッセージが受信HIPが無効であったことを示しています。偽造メッセージを使用してサービス拒否攻撃を回避するために、このステータスは、そのHMAC（存在する場合）と署名検証されたパケットのために返されることがあります。このステータスは、他のステータス・タイプのいずれかでカバーされていない任意のエラーに対応して送らなければなりませんし、ノードをプロービング誰かに情報漏洩を避けるために詳細を含めることはできません。デバッグを支援するために、より詳細なエラー情報は、コンソールまたはログに書き込む必要があります。"
    },
    {
      "indent": 3,
      "text": "NO_DH_PROPOSAL_CHOSEN 14",
      "ja": "NO_DH_PROPOSAL_CHOSEN 14"
    },
    {
      "indent": 6,
      "text": "None of the proposed group IDs was acceptable.",
      "ja": "提案されたグループIDのいずれも許容ませんでした。"
    },
    {
      "indent": 3,
      "text": "INVALID_DH_CHOSEN 15",
      "ja": "INVALID_DH_CHOSEN 15"
    },
    {
      "indent": 6,
      "text": "The D-H Group ID field does not correspond to one offered by the Responder.",
      "ja": "D-HグループIDフィールドは、レスポンダによって提供されるものに対応しません。"
    },
    {
      "indent": 3,
      "text": "NO_HIP_PROPOSAL_CHOSEN 16",
      "ja": "NO_HIP_PROPOSAL_CHOSEN 16"
    },
    {
      "indent": 6,
      "text": "None of the proposed HIP Transform crypto suites was acceptable.",
      "ja": "暗号スイートを変換提案HIPのいずれも許容ませんでした。"
    },
    {
      "indent": 3,
      "text": "INVALID_HIP_TRANSFORM_CHOSEN 17",
      "ja": "INVALID_HIP_TRANSFORM_CHOSEN 17"
    },
    {
      "indent": 6,
      "text": "The HIP Transform crypto suite does not correspond to one offered by the Responder.",
      "ja": "HIP変換暗号スイートは、レスポンダによって提供されるものに対応していません。"
    },
    {
      "indent": 3,
      "text": "AUTHENTICATION_FAILED 24",
      "ja": "AUTHENTICATION_FAILED 24"
    },
    {
      "indent": 6,
      "text": "Sent in response to a HIP signature failure, except when the signature verification fails in a NOTIFY message.",
      "ja": "署名検証は、NOTIFYメッセージに失敗した場合を除き、HIP署名失敗に応答して送信されます。"
    },
    {
      "indent": 3,
      "text": "CHECKSUM_FAILED 26",
      "ja": "CHECKSUM_FAILED 26"
    },
    {
      "indent": 6,
      "text": "Sent in response to a HIP checksum failure.",
      "ja": "HIPのチェックサム障害に応じて送信されます。"
    },
    {
      "indent": 3,
      "text": "HMAC_FAILED 28",
      "ja": "HMAC_FAILED 28"
    },
    {
      "indent": 6,
      "text": "Sent in response to a HIP HMAC failure.",
      "ja": "HIP HMACの障害に応じて送信されます。"
    },
    {
      "indent": 3,
      "text": "ENCRYPTION_FAILED 32",
      "ja": "ENCRYPTION_FAILED 32"
    },
    {
      "indent": 6,
      "text": "The Responder could not successfully decrypt the ENCRYPTED parameter.",
      "ja": "レスポンダが正常にENCRYPTEDパラメータを復号化することができませんでした。"
    },
    {
      "indent": 3,
      "text": "INVALID_HIT 40",
      "ja": "INVALID_HIT 40"
    },
    {
      "indent": 6,
      "text": "Sent in response to a failure to validate the peer's HIT from the corresponding HI.",
      "ja": "対応HIからピアのHITを検証する失敗に応答して送信されます。"
    },
    {
      "indent": 3,
      "text": "BLOCKED_BY_POLICY 42",
      "ja": "BLOCKED_BY_POLICY 42"
    },
    {
      "indent": 6,
      "text": "The Responder is unwilling to set up an association for some policy reason (e.g., received HIT is NULL and policy does not allow opportunistic mode).",
      "ja": "レスポンダは、いくつかのポリシーの理由で関連付けを設定するために不本意である（例えば、受信されたHITはNULLであり、ポリシーが日和見モードを許可しません）。"
    },
    {
      "indent": 3,
      "text": "SERVER_BUSY_PLEASE_RETRY 44",
      "ja": "SERVER_BUSY_PLEASE_RETRY 44"
    },
    {
      "indent": 6,
      "text": "The Responder is unwilling to set up an association as it is suffering under some kind of overload and has chosen to shed load by rejecting the Initiator's request. The Initiator may retry; however, the Initiator MUST find another (different) puzzle solution for any such retries. Note that the Initiator may need to obtain a new puzzle with a new I1/R1 exchange.",
      "ja": "Responderは、それが過負荷のいくつかの種類の下で苦しんでいるとイニシエータの要求を拒否することで、負荷を当てることを選択したとして、関連付けを設定したくないです。イニシエータが再試行すること。しかし、開始剤は、任意のそのような再試行のために別の（異なる）パズルの解決策を見つけなければなりません。イニシエータは新しいI1 / R1交換で新しいパズルを取得する必要があるかもしれないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "NOTIFY MESSAGES - STATUS TYPES           Value\n------------------------------           -----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "I2_ACKNOWLEDGEMENT 16384",
      "ja": "I2_ACKNOWLEDGEMENT 16384"
    },
    {
      "indent": 6,
      "text": "The Responder has an I2 from the Initiator but had to queue the I2 for processing. The puzzle was correctly solved and the Responder is willing to set up an association but currently has a number of I2s in the processing queue. R2 will be sent after the I2 has been processed.",
      "ja": "レスポンダは、イニシエータからI2を持っているが、処理のためにI2をキューイングしなければなりませんでした。パズルが正しく解決し、Responderは関連を設定していく所存ですが、現在処理キュー内I2Sの数を持っていました。 I2が処理された後にR2が送信されます。"
    },
    {
      "indent": 0,
      "text": "5.2.17. ECHO_REQUEST_SIGNED",
      "section_title": true,
      "ja": "5.2.17。 ECHO_REQUEST_SIGNED"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Opaque data (variable length)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 897 Length variable Opaque data opaque data, supposed to be meaningful only to the node that sends ECHO_REQUEST_SIGNED and receives a corresponding ECHO_RESPONSE_SIGNED or ECHO_RESPONSE_UNSIGNED.",
      "ja": "のみECHO_REQUEST_SIGNEDを送信し、対応するECHO_RESPONSE_SIGNED又はECHO_RESPONSE_UNSIGNEDを受信ノードに有意義であると考え897の長さ可変不透明なデータ不透明なデータを入力。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_SIGNED parameter contains an opaque blob of data that the sender wants to get echoed back in the corresponding reply packet.",
      "ja": "ECHO_REQUEST_SIGNEDパラメータは、送信者が対応する応答パケットにエコーバックを取得したいデータの不透明ブロブが含まれています。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_SIGNED and corresponding echo response parameters MAY be used for any purpose where a node wants to carry some state in a request packet and get it back in a response packet. The ECHO_REQUEST_SIGNED is covered by the HMAC and SIGNATURE. A HIP packet can contain only one ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED parameter. The ECHO_REQUEST_SIGNED parameter MUST be responded to with a corresponding echo response. ECHO_RESPONSE_SIGNED SHOULD be used, but if it is not possible, e.g., due to a middlebox-provided response, it MAY be responded to with an ECHO_RESPONSE_UNSIGNED.",
      "ja": "ECHO_REQUEST_SIGNEDと対応するエコー応答パラメータは、ノードが要求パケットにいくつかの状態を運ぶと応答パケットにそれを取り戻すしたい任意の目的に使用することができます。 ECHO_REQUEST_SIGNEDは、HMACとSIGNATUREで覆われています。 HIPパケットが一つだけECHO_REQUEST_SIGNEDまたはECHO_REQUEST_UNSIGNEDパラメータを含めることができます。 ECHO_REQUEST_SIGNEDパラメータは、対応するエコー応答で応答しなければなりません。 ECHO_RESPONSE_SIGNEDが使用されるべきであり、それが可能でない場合、例えば、起因ミドル提供応答には、ECHO_RESPONSE_UNSIGNEDによって応答されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.2.18. ECHO_REQUEST_UNSIGNED",
      "section_title": true,
      "ja": "5.2.18。 ECHO_REQUEST_UNSIGNED"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Opaque data (variable length)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 63661 Length variable Opaque data opaque data, supposed to be meaningful only to the node that sends ECHO_REQUEST_UNSIGNED and receives a corresponding ECHO_RESPONSE_UNSIGNED.",
      "ja": "のみECHO_REQUEST_UNSIGNEDを送信し、対応するECHO_RESPONSE_UNSIGNEDを受信ノードに有意義であると考え63661長可変不透明なデータ不透明なデータを入力。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_UNSIGNED parameter contains an opaque blob of data that the sender wants to get echoed back in the corresponding reply packet.",
      "ja": "ECHO_REQUEST_UNSIGNEDパラメータは、送信者が対応する応答パケットにエコーバックを取得したいデータの不透明ブロブが含まれています。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_UNSIGNED and corresponding echo response parameters MAY be used for any purpose where a node wants to carry some state in a request packet and get it back in a response packet. The ECHO_REQUEST_UNSIGNED is not covered by the HMAC and SIGNATURE. A HIP packet can contain one or more ECHO_REQUEST_UNSIGNED parameters. It is possible that middleboxes add ECHO_REQUEST_UNSIGNED parameters in HIP packets passing by. The sender has to create the Opaque field so that it can later identify and remove the corresponding ECHO_RESPONSE_UNSIGNED parameter.",
      "ja": "ECHO_REQUEST_UNSIGNEDと対応するエコー応答パラメータは、ノードが要求パケットにいくつかの状態を運ぶと応答パケットにそれを取り戻すしたい任意の目的に使用することができます。 ECHO_REQUEST_UNSIGNEDは、HMACとSIGNATUREによってカバーされていません。 HIPパケットは、一つ以上のECHO_REQUEST_UNSIGNEDパラメータを含めることができます。ミドルボックスが通り過ぎるHIPパケットでECHO_REQUEST_UNSIGNEDパラメータを追加することも可能です。送信者は、それが後に、対応するECHO_RESPONSE_UNSIGNEDパラメータを識別して削除できるように不透明なフィールドを作成する必要があります。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_UNSIGNED parameter MUST be responded to with an ECHO_RESPONSE_UNSIGNED parameter.",
      "ja": "ECHO_REQUEST_UNSIGNEDパラメータはECHO_RESPONSE_UNSIGNEDパラメータで応答しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.19. ECHO_RESPONSE_SIGNED",
      "section_title": true,
      "ja": "5.2.19。 ECHO_RESPONSE_SIGNED"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Opaque data (variable length)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 961 Length variable Opaque data opaque data, copied unmodified from the ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED parameter that triggered this response.",
      "ja": "961長可変不透明なデータを不透明なデータを入力し、この応答をトリガーECHO_REQUEST_SIGNEDまたはECHO_REQUEST_UNSIGNEDパラメータから修飾されていないコピー。"
    },
    {
      "indent": 3,
      "text": "The ECHO_RESPONSE_SIGNED parameter contains an opaque blob of data that the sender of the ECHO_REQUEST_SIGNED wants to get echoed back. The opaque data is copied unmodified from the ECHO_REQUEST_SIGNED parameter.",
      "ja": "ECHO_RESPONSE_SIGNEDパラメータはECHO_REQUEST_SIGNEDの送信者がエコーバック取得したいデータの不透明ブロブが含まれています。不透明なデータはECHO_REQUEST_SIGNEDパラメータから修飾されていないコピーされます。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_SIGNED and ECHO_RESPONSE_SIGNED parameters MAY be used for any purpose where a node wants to carry some state in a request packet and get it back in a response packet. The ECHO_RESPONSE_SIGNED is covered by the HMAC and SIGNATURE.",
      "ja": "ECHO_REQUEST_SIGNEDとECHO_RESPONSE_SIGNEDパラメータは、ノードが要求パケットにいくつかの状態を運ぶと応答パケットにそれを取り戻すしたい任意の目的に使用することができます。 ECHO_RESPONSE_SIGNEDは、HMACとSIGNATUREで覆われています。"
    },
    {
      "indent": 0,
      "text": "5.2.20. ECHO_RESPONSE_UNSIGNED",
      "section_title": true,
      "ja": "5.2.20。 ECHO_RESPONSE_UNSIGNED"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Opaque data (variable length)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Type 63425 Length variable Opaque data opaque data, copied unmodified from the ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED parameter that triggered this response.",
      "ja": "63425長可変不透明なデータを不透明なデータを入力し、この応答をトリガーECHO_REQUEST_SIGNEDまたはECHO_REQUEST_UNSIGNEDパラメータから修飾されていないコピー。"
    },
    {
      "indent": 3,
      "text": "The ECHO_RESPONSE_UNSIGNED parameter contains an opaque blob of data that the sender of the ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED wants to get echoed back. The opaque data is copied unmodified from the corresponding echo request parameter.",
      "ja": "ECHO_RESPONSE_UNSIGNEDパラメータはECHO_REQUEST_SIGNEDまたはECHO_REQUEST_UNSIGNEDの送信者がエコーバック取得したいデータの不透明ブロブが含まれています。不透明なデータは、対応するエコー要求パラメータから修飾されていないコピーされます。"
    },
    {
      "indent": 3,
      "text": "The echo request and ECHO_RESPONSE_UNSIGNED parameters MAY be used for any purpose where a node wants to carry some state in a request packet and get it back in a response packet. The ECHO_RESPONSE_UNSIGNED is not covered by the HMAC and SIGNATURE.",
      "ja": "エコー要求とECHO_RESPONSE_UNSIGNEDパラメータは、ノードが要求パケットにいくつかの状態を運ぶと応答パケットにそれを取り戻すしたい任意の目的に使用することができます。 ECHO_RESPONSE_UNSIGNEDは、HMACとSIGNATUREによってカバーされていません。"
    },
    {
      "indent": 0,
      "text": "5.3. HIP Packets",
      "section_title": true,
      "ja": "5.3。 HIPのパケット"
    },
    {
      "indent": 3,
      "text": "There are eight basic HIP packets (see Table 10). Four are for the HIP base exchange, one is for updating, one is for sending notifications, and two are for closing a HIP association.",
      "ja": "8つの基本的なHIPパケットは、（表10参照）があります。四つは、HIP基本交換のためである1つは、1つの通知を送信するためのものであり、更新のためであり、2つのHIPアソシエーションを閉鎖するためのものです。"
    },
    {
      "indent": 3,
      "text": "+------------------+------------------------------------------------+\n|    Packet type   | Packet name                                    |\n+------------------+------------------------------------------------+\n|         1        | I1 - the HIP Initiator Packet                  |\n|                  |                                                |\n|         2        | R1 - the HIP Responder Packet                  |\n|                  |                                                |\n|         3        | I2 - the Second HIP Initiator Packet           |\n|                  |                                                |\n|         4        | R2 - the Second HIP Responder Packet           |\n|                  |                                                |\n|        16        | UPDATE - the HIP Update Packet                 |\n|                  |                                                |\n|        17        | NOTIFY - the HIP Notify Packet                 |\n|                  |                                                |\n|        18        | CLOSE - the HIP Association Closing Packet     |\n|                  |                                                |\n|        19        | CLOSE_ACK - the HIP Closing Acknowledgment     |\n|                  | Packet                                         |\n+------------------+------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Table 10: HIP packets and packet type numbers",
      "ja": "表10：HIPパケットとパケットタイプ番号"
    },
    {
      "indent": 3,
      "text": "Packets consist of the fixed header as described in Section 5.1, followed by the parameters. The parameter part, in turn, consists of zero or more TLV-coded parameters.",
      "ja": "パラメータが続くセクション5.1に記載のパケットは、固定ヘッダから成ります。パラメータの一部は、今度は、ゼロまたはそれ以上のTLV符号化されたパラメータで構成されています。"
    },
    {
      "indent": 3,
      "text": "In addition to the base packets, other packet types will be defined later in separate specifications. For example, support for mobility and multi-homing is not included in this specification.",
      "ja": "ベース・パケットに加えて、他のパケットタイプは、後で別の仕様で定義されます。例えば、モビリティ及びマルチホーミングのための支持体は、本明細書に含まれていません。"
    },
    {
      "indent": 3,
      "text": "See Notation (Section 2.2) for used operations.",
      "ja": "使用する操作のための記法（2.2節）を参照してください。"
    },
    {
      "indent": 3,
      "text": "In the future, an OPTIONAL upper-layer payload MAY follow the HIP header. The Next Header field in the header indicates if there is additional data following the HIP header. The HIP packet, however, MUST NOT be fragmented. This limits the size of the possible additional data in the packet.",
      "ja": "将来的には、OPTIONAL上層ペイロードはHIPヘッダに従うことができます。 HIPヘッダ以下の追加データがある場合、ヘッダーのNext Headerフィールドを示します。 HIPパケットは、しかし、断片化してはいけません。これは、パケット内の可能な追加データのサイズを制限します。"
    },
    {
      "indent": 0,
      "text": "5.3.1. I1 - the HIP Initiator Packet",
      "section_title": true,
      "ja": "5.3.1。 I1  -  HIPイニシエータパケット"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the I1 packet:",
      "ja": "I1パケットのHIPヘッダー値："
    },
    {
      "indent": 6,
      "text": "Header: Packet Type = 1 SRC HIT = Initiator's HIT DST HIT = Responder's HIT, or NULL",
      "ja": "ヘッダー：パケットタイプ= 1つのSRCのHIT =イニシエータのHIT DSTのHIT =レスポンダのHIT、またはNULL"
    },
    {
      "indent": 6,
      "text": "IP ( HIP () )",
      "ja": "IP（HIP（））"
    },
    {
      "indent": 3,
      "text": "The I1 packet contains only the fixed HIP header.",
      "ja": "I1パケットは、固定されたHIPヘッダを含んでいます。"
    },
    {
      "indent": 3,
      "text": "Valid control bits: none",
      "ja": "有効な制御ビット：なし"
    },
    {
      "indent": 3,
      "text": "The Initiator gets the Responder's HIT either from a DNS lookup of the Responder's FQDN, from some other repository, or from a local table. If the Initiator does not know the Responder's HIT, it may attempt to use opportunistic mode by using NULL (all zeros) as the Responder's HIT. See also \"HIP Opportunistic Mode\" (Section 4.1.6).",
      "ja": "イニシエータは、レスポンダのFQDNのDNSルックアップから、いくつかの他のリポジトリから、またはローカルテーブルのいずれかからレスポンダのHITを取得します。イニシエータは、レスポンダのHITがわからない場合は、レスポンダのHITとしてNULL（すべてゼロ）を使用して日和見モードを使用することを試みることができます。また、「HIP日和見モード」（セクション4.1.6）を参照してください。"
    },
    {
      "indent": 3,
      "text": "Since this packet is so easy to spoof even if it were signed, no attempt is made to add to its generation or processing cost.",
      "ja": "このパケットは、それが署名された場合でも、偽装するのは簡単ですので、何の試みは、その生成や処理コストに追加する行われません。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST be able to handle a storm of received I1 packets, discarding those with common content that arrive within a small time delta.",
      "ja": "実装は、短い時間内に到着デルタ共通のコンテンツを有するものを廃棄、受信I1パケットの嵐を扱うことができなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.2. R1 - the HIP Responder Packet",
      "section_title": true,
      "ja": "5.3.2。 R1  - パケットレスポンダHIP"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the R1 packet:",
      "ja": "R1パケットのHIPヘッダー値："
    },
    {
      "indent": 6,
      "text": "Header: Packet Type = 2 SRC HIT = Responder's HIT DST HIT = Initiator's HIT",
      "ja": "ヘッダー：パケットタイプ= 2 SRCのHIT =レスポンダのHIT DSTのHIT =イニシエータのHIT"
    },
    {
      "indent": 6,
      "text": "IP ( HIP ( [ R1_COUNTER, ] PUZZLE, DIFFIE_HELLMAN, HIP_TRANSFORM, HOST_ID, [ ECHO_REQUEST_SIGNED, ] HIP_SIGNATURE_2 ) <, ECHO_REQUEST_UNSIGNED >i)",
      "ja": "IP（HIP（[R1_COUNTER、】パズルDIFFIE_HELLMAN、HIP_TRANSFORM、HOST_ID、[ECHO_REQUEST_SIGNED、】HIP_SIGNATURE_2）<、ECHO_REQUEST_UNSIGNED> I）"
    },
    {
      "indent": 3,
      "text": "Valid control bits: A",
      "ja": "有効な制御ビット：A"
    },
    {
      "indent": 3,
      "text": "If the Responder's HI is an anonymous one, the A control MUST be set.",
      "ja": "レスポンダのHIは匿名のものであれば、Aの制御を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Initiator's HIT MUST match the one received in I1. If the Responder has multiple HIs, the Responder's HIT used MUST match Initiator's request. If the Initiator used opportunistic mode, the Responder may select freely among its HIs. See also \"HIP Opportunistic Mode\" (Section 4.1.6).",
      "ja": "イニシエータのHITはI1で受信したものと一致しなければなりません。 Responderが彼を複数持っている場合は、使用レスポンダのHITは、イニシエータの要求に合致しなければなりません。イニシエータは日和見モードを使用した場合、Responderはその彼の間で自由に選択することができます。また、「HIP日和見モード」（セクション4.1.6）を参照してください。"
    },
    {
      "indent": 3,
      "text": "The R1 generation counter is used to determine the currently valid generation of puzzles. The value is increased periodically, and it is RECOMMENDED that it is increased at least as often as solutions to old puzzles are no longer accepted.",
      "ja": "R1生成カウンタは、パズルの現在有効な世代を決定するために使用されます。値が定期的に増加し、少なくともとして頻繁に古いパズルの解決は、もはや受け入れられているように増加することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "The Puzzle contains a Random #I and the difficulty K. The difficulty K indicates the number of lower-order bits, in the puzzle hash result, that must be zeros; see Section 4.1.2. The Random #I is not covered by the signature and must be zeroed during the signature calculation, allowing the sender to select and set the #I into a precomputed R1 just prior sending it to the peer.",
      "ja": "パズルはランダム#Iと困難K.困難Kがゼロでなければならないパズルハッシュ結果に、下位ビットの数を示すが含ま。 4.1.2項を参照してください。ランダム#Iは、署名によって覆われておらず、送信者が直前のピアに送信する事前計算R1に#Iを選択して設定することができ、署名計算中にゼロしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Diffie-Hellman value is ephemeral, and one value SHOULD be used only for one connection. Once the Responder has received a valid response to an R1 packet, that Diffie-Hellman value SHOULD be deprecated. Because it is possible that the Responder has sent the same Diffie-Hellman value to different hosts simultaneously in corresponding R1 packets, those responses should also be accepted. However, as a defense against I1 storms, an implementation MAY propose, and re-use if not avoidable, the same Diffie-Hellman value for a period of time, for example, 15 minutes. By using a small number of different puzzles for a given Diffie-Hellman value, the R1 packets can be precomputed and delivered as quickly as I1 packets arrive. A scavenger process should clean up unused Diffie-Hellman values and puzzles.",
      "ja": "Diffie-Hellman値は短命であり、1つの値は、一つだけの接続のために使用されるべきです。レスポンダ一度のDiffie-Hellman値は推奨されるべきであること、R1パケットに有効な応答を受信しました。それはレスポンダがR1パケットを対応同時に異なるホストに同一のDiffie-Hellman値を送信している可能性があるため、これらの応答も受け入れなければなりません。しかし、I1ストームに対する防御として、実装が提案することができる、例えば再利用避けられない場合、一定期間のための同じのDiffie-Hellman値、15分。所与のDiffie-Hellman値に対して異なるパズルの小さな数を使用することにより、R1パケットが早くI1パケットが到着するように事前計算して配信することができます。スカベンジャープロセスは、未使用のDiffie-Hellman値とパズルをクリーンアップする必要があります。"
    },
    {
      "indent": 3,
      "text": "Re-using Diffie-Hellman public keys opens up the potential security risk of more than one Initiator ending up with the same keying material (due to faulty random number generators). Also, more than one Initiator using the same Responder public key half may lead to potentially easier cryptographic attacks and to imperfect forward security.",
      "ja": "再使用のDiffie-Hellman公開鍵を（不良による乱数ジェネレータに）同じ鍵素材で終わる複数のイニシエータの潜在的なセキュリティリスクを開きます。また、同じレスポンダの公開鍵の半分を使用して複数のイニシエータは、潜在的に簡単に暗号攻撃につながる可能性と前方セキュリティを不完全なために。"
    },
    {
      "indent": 3,
      "text": "However, these risks involved in re-using the same key are statistical; that is, the authors are not aware of any mechanism that would allow manipulation of the protocol so that the risk of the re-use of any given Responder Diffie-Hellman public key would differ from the base probability. Consequently, it is RECOMMENDED that implementations avoid re-using the same D-H key with multiple Initiators, but because the risk is considered statistical and not known to be manipulable, the implementations MAY re-use a key in order to ease resource-constrained implementations and to increase the probability of successful communication with legitimate clients even under an I1 storm. In particular, when it is too expensive to generate enough precomputed R1 packets to supply each potential Initiator with a different D-H key, the Responder MAY send the same D-H key to several Initiators, thereby creating the possibility of multiple legitimate Initiators ending up using the same Responder-side public key. However, as soon as the Responder knows that it will use a particular D-H key, it SHOULD stop offering it. This design is aimed to allow resource-constrained Responders to offer services under I1 storms and to simultaneously make the probability of D-H key re-use both statistical and as low as possible.",
      "ja": "しかし、同じキーを再利用に関与し、これらのリスクは統計的です。つまり、著者は、任意のレスポンダのDiffie-Hellman公開鍵の再利用のリスクは基本確率異なるなるようにプロトコルの操作を可能にする任意のメカニズムを認識していません。リスクが統計的とみなされ、操作可能であることが知られていないため、結果として、リソースに制約の実装を容易にするために、実装は再使用するかもしれキー、実装は複数のイニシエータと再利用同じDHキーを避けることが推奨されるが、そしてでも、I1の嵐の下で、正当なクライアントとの通信の成功の確率を高めるために。それは異なるDHキーでそれぞれの潜在的開始剤を供給するのに十分な予め計算R1パケットを生成するために非常に高価である場合、特に、レスポンダは、それによってそれを用い終わる複数の正当な開始剤の可能性を作成し、いくつかのイニシエータに同じDH鍵を送信することができますレスポンダ側の公開鍵。しかし、できるだけ早くResponderが、それは特定のD-Hキーを使用することを知っているように、それはそれを提供して停止する必要があります。この設計は、リソースに制約のあるレスポンダがI1の嵐の下でサービスを提供すると同時に、統計と可能な限り低く、両方のD-Hキー再利用の可能性を作ることができるように目指しています。"
    },
    {
      "indent": 3,
      "text": "If a future version of this protocol is considered, we strongly recommend that these issues be studied again. Especially, the current design allows hosts to become potentially more vulnerable to a statistical, low-probability problem during I1 storm attacks than what they are if no attack is taking place; whether this is acceptable or not should be reconsidered in the light of any new experience gained.",
      "ja": "このプロトコルの将来のバージョンが考慮されている場合は、私たちは強く、これらの問題を再度検討することをお勧めします。特に、現在の設計は、ホストが全く攻撃が行われていない場合、彼らが何であるかよりも、I1の嵐の攻撃中に統計的、低確率の問題に対して潜在的に脆弱になることができます。すべての新しい経験に照らして再検討する必要があり、これは許容可能であるかどうかをあげました。"
    },
    {
      "indent": 3,
      "text": "The HIP_TRANSFORM contains the encryption and integrity algorithms supported by the Responder to protect the HI exchange, in the order of preference. All implementations MUST support the AES [RFC3602] with HMAC-SHA-1-96 [RFC2404].",
      "ja": "HIP_TRANSFORMは、好みの順にHI交換を保護するためにレスポンダによってサポートされている暗号化と整合性アルゴリズムが含まれています。すべての実装は、AES HMAC-SHA-1-96 [RFC2404]と[RFC3602]をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_SIGNED and ECHO_REQUEST_UNSIGNED contains data that the sender wants to receive unmodified in the corresponding response packet in the ECHO_RESPONSE_SIGNED or ECHO_RESPONSE_UNSIGNED parameter.",
      "ja": "ECHO_REQUEST_SIGNEDとECHO_REQUEST_UNSIGNEDは、送信者がECHO_RESPONSE_SIGNEDまたはECHO_RESPONSE_UNSIGNEDパラメータに対応する応答パケットにそのまま受信したいデータが含まれています。"
    },
    {
      "indent": 3,
      "text": "The signature is calculated over the whole HIP envelope, after setting the Initiator's HIT, header checksum, as well as the Opaque field and the Random #I in the PUZZLE parameter temporarily to zero, and excluding any parameters that follow the signature, as described in Section 5.2.12. This allows the Responder to use precomputed R1s. The Initiator SHOULD validate this signature. It SHOULD check that the Responder's HI received matches with the one expected, if any.",
      "ja": "に記載のように署名は、署名に従うパラメータをゼロに一時パズルパラメータでランダム#IイニシエータのHIT、ヘッダチェックサム、並びに不透明フィールドとを設定し、除外した後、全体HIPエンベロープにわたって計算されますセクション5.2.12。これは、Responderが事前に計算のR1を使用することができます。イニシエータは、この署名を検証する必要があります。これは、レスポンダのHIがあれば、期待されるものと一致するものを受け取ったことを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.3. I2 - the Second HIP Initiator Packet",
      "section_title": true,
      "ja": "5.3.3。 I2  - セカンドHIPイニシエータパケット"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the I2 packet:",
      "ja": "I2パケットのHIPヘッダー値："
    },
    {
      "indent": 6,
      "text": "Header: Type = 3 SRC HIT = Initiator's HIT DST HIT = Responder's HIT",
      "ja": "ヘッダー：タイプ= 3 SRCのHIT =イニシエータのHIT DSTのHIT =レスポンダのHIT"
    },
    {
      "indent": 6,
      "text": "IP ( HIP ( [R1_COUNTER,] SOLUTION, DIFFIE_HELLMAN, HIP_TRANSFORM, ENCRYPTED { HOST_ID } or HOST_ID, [ ECHO_RESPONSE_SIGNED ,] HMAC, HIP_SIGNATURE <, ECHO_RESPONSE_UNSIGNED>i ) )",
      "ja": "IP（HIP（[R1_COUNTER、】溶液DIFFIE_HELLMAN、HIP_TRANSFORM、ENCRYPTED {HOST_ID}又はHOST_ID、[ECHO_RESPONSE_SIGNED、】HMAC、HIP_SIGNATURE <、ECHO_RESPONSE_UNSIGNED> i））を"
    },
    {
      "indent": 3,
      "text": "Valid control bits: A",
      "ja": "有効な制御ビット：A"
    },
    {
      "indent": 3,
      "text": "The HITs used MUST match the ones used previously.",
      "ja": "使用ヒットは、以前に使用したものと一致しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the Initiator's HI is an anonymous one, the A control MUST be set.",
      "ja": "イニシエータのHIは匿名のものであれば、Aの制御を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Initiator MAY include an unmodified copy of the R1_COUNTER parameter received in the corresponding R1 packet into the I2 packet.",
      "ja": "イニシエータは、I2パケットに対応するR1パケットで受信R1_COUNTERパラメータの非修飾コピーを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "The Solution contains the Random #I from R1 and the computed #J. The low-order K bits of the RHASH(I | ... | J) MUST be zero.",
      "ja": "ソリューションは、R1からランダム#Iと計算#Jが含まれています。 RHASH（| ... | I J）の下位Kビットはゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Diffie-Hellman value is ephemeral. If precomputed, a scavenger process should clean up unused Diffie-Hellman values. The Responder may re-use Diffie-Hellman values under some conditions as specified in Section 5.3.2.",
      "ja": "Diffie-Hellman値は短命です。事前に計算した場合、スカベンジャープロセスは、未使用のDiffie-Hellman値をクリーンアップする必要があります。セクション5.3.2で指定されるようにレスポンダは、いくつかの条件の下でのDiffie-Hellman値を再使用することができます。"
    },
    {
      "indent": 3,
      "text": "The HIP_TRANSFORM contains the single encryption and integrity transform selected by the Initiator, that will be used to protect the HI exchange. The chosen transform MUST correspond to one offered by the Responder in the R1. All implementations MUST support the AES transform [RFC3602].",
      "ja": "HIP_TRANSFORMはHI交換を保護するために使用されるイニシエータによって選択された1つの暗号化と整合性の変換が含まれています。変換選択したR1におけるレスポンダによって提供されるものに対応している必要があります。すべての実装は、AESは、[RFC3602]を変換サポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Initiator's HI MAY be encrypted using the HIP_TRANSFORM encryption algorithm. The keying material is derived from the Diffie-Hellman exchanged as defined in Section 6.5.",
      "ja": "イニシエータのHIはHIP_TRANSFORM暗号化アルゴリズムを用いて暗号化することができます。鍵材料は、ディフィー・ヘルマンに由来するセクション6.5で定義されるように交換しました。"
    },
    {
      "indent": 3,
      "text": "The ECHO_RESPONSE_SIGNED and ECHO_RESPONSE_UNSIGNED contain the unmodified Opaque data copied from the corresponding echo request parameter.",
      "ja": "ECHO_RESPONSE_SIGNEDとECHO_RESPONSE_UNSIGNEDは、対応するエコー要求パラメータからコピーされた修飾されていない不透明なデータを含みます。"
    },
    {
      "indent": 3,
      "text": "The HMAC is calculated over the whole HIP envelope, excluding any parameters after the HMAC, as described in Section 6.4.1. The Responder MUST validate the HMAC.",
      "ja": "6.4.1項で説明したようにHMACは、HMACの後に任意のパラメータを除く、全HIPエンベロープ上で計算されます。 ResponderはHMACを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "The signature is calculated over the whole HIP envelope, excluding any parameters after the HIP_SIGNATURE, as described in Section 5.2.11. The Responder MUST validate this signature. It MAY use either the HI in the packet or the HI acquired by some other means.",
      "ja": "セクション5.2.11に記載されているように署名は、HIP_SIGNATURE後の任意のパラメータを除く、全HIPエンベロープにわたって計算されます。 Responderは、この署名を検証する必要があります。これは、パケット内のHIまたはいくつかの他の手段によって取得HIいずれかを使用することができます。"
    },
    {
      "indent": 0,
      "text": "5.3.4. R2 - the Second HIP Responder Packet",
      "section_title": true,
      "ja": "5.3.4。 R2  - パケットレスポンダセカンドHIP"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the R2 packet:",
      "ja": "R2パケットのHIPヘッダー値："
    },
    {
      "indent": 6,
      "text": "Header: Packet Type = 4 SRC HIT = Responder's HIT DST HIT = Initiator's HIT",
      "ja": "ヘッダー：パケットタイプ= 4 SRCのHIT =レスポンダのHIT DSTのHIT =イニシエータのHIT"
    },
    {
      "indent": 6,
      "text": "IP ( HIP ( HMAC_2, HIP_SIGNATURE ) )",
      "ja": "IP（HIP（HMAC_2、HIP_SIGNATURE））"
    },
    {
      "indent": 3,
      "text": "Valid control bits: none",
      "ja": "有効な制御ビット：なし"
    },
    {
      "indent": 3,
      "text": "The HMAC_2 is calculated over the whole HIP envelope, with Responder's HOST_ID parameter concatenated with the HIP envelope. The HOST_ID parameter is removed after the HMAC calculation. The procedure is described in Section 6.4.1.",
      "ja": "HMAC_2はHIPエンベロープと連結レスポンダのHOST_IDパラメータで、全体のHIPエンベロープ上で計算されます。 HOST_IDパラメータは、HMAC計算後に除去されます。手順は、6.4.1項で説明されています。"
    },
    {
      "indent": 3,
      "text": "The signature is calculated over the whole HIP envelope.",
      "ja": "署名は全体HIPエンベロープ上で計算されます。"
    },
    {
      "indent": 3,
      "text": "The Initiator MUST validate both the HMAC and the signature.",
      "ja": "イニシエータは、HMACと署名の両方を検証しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.5. UPDATE - the HIP Update Packet",
      "section_title": true,
      "ja": "5.3.5。 UPDATE  -  HIPアップデートパケット"
    },
    {
      "indent": 3,
      "text": "Support for the UPDATE packet is MANDATORY.",
      "ja": "UPDATEパケットのサポートが必須です。"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the UPDATE packet:",
      "ja": "UPDATEパケットのHIPヘッダー値："
    },
    {
      "indent": 6,
      "text": "Header: Packet Type = 16 SRC HIT = Sender's HIT DST HIT = Recipient's HIT",
      "ja": "ヘッダー：パケットタイプ= 16 SRCのHIT =送信者のHIT DSTのHIT =受信者のHIT"
    },
    {
      "indent": 6,
      "text": "IP ( HIP ( [SEQ, ACK, ] HMAC, HIP_SIGNATURE ) )",
      "ja": "IP（HIP（[配列、ACK、】HMAC、HIP_SIGNATURE））"
    },
    {
      "indent": 3,
      "text": "Valid control bits: None",
      "ja": "有効な制御ビット：なし"
    },
    {
      "indent": 3,
      "text": "The UPDATE packet contains mandatory HMAC and HIP_SIGNATURE parameters, and other optional parameters.",
      "ja": "UPDATEパケットは必須HMACとHIP_SIGNATUREパラメータ、および他の任意のパラメータが含まれています。"
    },
    {
      "indent": 3,
      "text": "The UPDATE packet contains zero or one SEQ parameter. The presence of a SEQ parameter indicates that the receiver MUST ACK the UPDATE. An UPDATE that does not contain a SEQ parameter is simply an ACK of a previous UPDATE and itself MUST NOT be ACKed.",
      "ja": "UPDATEパケットは、ゼロまたは1 SEQパラメータが含まれています。 SEQパラメータの存在は、受信機が更新をACKしなければならないことを示しています。 SEQパラメータが含まれていないUPDATEは前のUPDATEと自身のACKがACKされてはならないだけです。"
    },
    {
      "indent": 3,
      "text": "An UPDATE packet contains zero or one ACK parameters. The ACK parameter echoes the SEQ sequence number of the UPDATE packet being ACKed. A host MAY choose to ACK more than one UPDATE packet at a time; e.g., the ACK may contain the last two SEQ values received, for robustness to ACK loss. ACK values are not cumulative; each received unique SEQ value requires at least one corresponding ACK value in reply. Received ACKs that are redundant are ignored.",
      "ja": "UPDATEパケットは、ゼロまたは1つのACKパラメータが含まれています。 ACKパラメータは、ACKされているUPDATEパケットのSEQシーケンス番号をエコーし​​ます。ホストは、一度に複数のUPDATEパケットをACKに選ぶかもしれ。例えば、ACKはACKの損失に対するロバスト性のために、受信された最後の二つのSEQ値を含んでいてもよいです。 ACK値は累積的ではありません。それぞれは、応答に少なくとも一つの対応するACK値を必要とする一意のSEQ値を受け取りました。冗長化されている受信ACKが無視されます。"
    },
    {
      "indent": 3,
      "text": "The UPDATE packet may contain both a SEQ and an ACK parameter. In this case, the ACK is being piggybacked on an outgoing UPDATE. In general, UPDATEs carrying SEQ SHOULD be ACKed upon completion of the processing of the UPDATE. A host MAY choose to hold the UPDATE carrying ACK for a short period of time to allow for the possibility of piggybacking the ACK parameter, in a manner similar to TCP delayed acknowledgments.",
      "ja": "UPDATEパケットは、配列とACKパラメータの両方を含んでいてもよいです。この場合、ACKは送信UPDATEにピギーバックされています。一般に、配列を担持する更新はUPDATEの処理の完了時にACKされるべきです。 TCPと同様に、ACKパラメータをピギーバックの可能性を可能にするために、短時間のACKを運ぶUPDATEを保持することを選択するかもしれないホストが確認応答を遅らせます。"
    },
    {
      "indent": 3,
      "text": "A sender MAY choose to forgo reliable transmission of a particular UPDATE (e.g., it becomes overcome by events). The semantics are such that the receiver MUST acknowledge the UPDATE, but the sender MAY choose to not care about receiving the ACK.",
      "ja": "送信者は、（例えば、それはイベントによって克服になります）、特定のUPDATEの信頼性の高い伝送を見送ることを選択するかもしれません。セマンティクスは、受信機がUPDATEを確認しなければならないようなものであるが、送信側はACKを受信気にしないことを選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "UPDATEs MAY be retransmitted without incrementing SEQ. If the same subset of parameters is included in multiple UPDATEs with different SEQs, the host MUST ensure that the receiver's processing of the parameters multiple times will not result in a protocol error.",
      "ja": "アップデートは、SEQをインクリメントせずに再送信されても​​よいです。パラメータの同じサブセットは異なるSEQsと複数の更新に含まれている場合、ホストは、受信機のパラメータの処理を複数回にプロトコルエラーが発生しないことを保証しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.6. NOTIFY - the HIP Notify Packet",
      "section_title": true,
      "ja": "5.3.6。 NOTIFY  -  HIPはパケットを通知します"
    },
    {
      "indent": 3,
      "text": "The NOTIFY packet is OPTIONAL. The NOTIFY packet MAY be used to provide information to a peer. Typically, NOTIFY is used to indicate some type of protocol error or negotiation failure. NOTIFY packets are unacknowledged. The receiver can handle the packet only as informational, and SHOULD NOT change its HIP state (Section 4.4.1) based purely on a received NOTIFY packet.",
      "ja": "NOTIFYパケットはオプションです。 NOTIFYパケットをピアに情報を提供するために使用され得ます。典型的には、プロトコルエラーまたはネゴシエーション失敗のいくつかのタイプを示すために使用されるNOTIFY。 NOTIFYパケットは未確認です。受信機は、情報提供のみを、パケットを処理することができ、およびNOTIFY受信したパケットに純粋に基づいて、そのHIP状態（4.4.1）を変更しないでください。"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the NOTIFY packet:",
      "ja": "NOTIFYパケットのHIPヘッダー値："
    },
    {
      "indent": 6,
      "text": "Header: Packet Type = 17 SRC HIT = Sender's HIT DST HIT = Recipient's HIT, or zero if unknown",
      "ja": "ヘッダー：パケットタイプ= 17 SRCのHIT =送信者のHIT DSTのHIT =受信者のHIT、またはゼロ不明な場合"
    },
    {
      "indent": 6,
      "text": "IP ( HIP (<NOTIFICATION>i, [HOST_ID, ] HIP_SIGNATURE) )",
      "ja": "IP（HIP（<NOTIFICATION> I、[HOST_ID、】HIP_SIGNATURE））"
    },
    {
      "indent": 3,
      "text": "Valid control bits: None",
      "ja": "有効な制御ビット：なし"
    },
    {
      "indent": 3,
      "text": "The NOTIFY packet is used to carry one or more NOTIFICATION parameters.",
      "ja": "NOTIFYパケットは、1つまたは複数の通知パラメータを運ぶために使用されます。"
    },
    {
      "indent": 0,
      "text": "5.3.7. CLOSE - the HIP Association Closing Packet",
      "section_title": true,
      "ja": "5.3.7。 CLOSE  -  HIP協会クロージングパケット"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the CLOSE packet:",
      "ja": "CLOSEパケットのHIPヘッダー値："
    },
    {
      "indent": 6,
      "text": "Header: Packet Type = 18 SRC HIT = Sender's HIT DST HIT = Recipient's HIT",
      "ja": "ヘッダー：パケットタイプ= 18 SRCのHIT =送信者のHIT DSTのHIT =受信者のHIT"
    },
    {
      "indent": 6,
      "text": "IP ( HIP ( ECHO_REQUEST_SIGNED, HMAC, HIP_SIGNATURE ) )",
      "ja": "IP（HIP（ECHO_REQUEST_SIGNED、HMAC、HIP_SIGNATURE））"
    },
    {
      "indent": 3,
      "text": "Valid control bits: none",
      "ja": "有効な制御ビット：なし"
    },
    {
      "indent": 3,
      "text": "The sender MUST include an ECHO_REQUEST_SIGNED used to validate CLOSE_ACK received in response, and both an HMAC and a signature (calculated over the whole HIP envelope).",
      "ja": "送信者はCLOSE_ACKに応答して受信確認するために使用し、HMACと（全体HIPエンベロープにわたって計算）署名の両方ECHO_REQUEST_SIGNEDを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The receiver peer MUST validate both the HMAC and the signature if it has a HIP association state, and MUST reply with a CLOSE_ACK containing an ECHO_RESPONSE_SIGNED corresponding to the received ECHO_REQUEST_SIGNED.",
      "ja": "受信ピアは、HIPの会合状態を有する場合、HMACと署名の両方を検証しなければならない、受信したECHO_REQUEST_SIGNEDに対応ECHO_RESPONSE_SIGNEDを含むCLOSE_ACKで応答しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.8. CLOSE_ACK - the HIP Closing Acknowledgment Packet",
      "section_title": true,
      "ja": "5.3.8。 CLOSE_ACK  -  HIPは、肯定応答パケットを閉じます"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the CLOSE_ACK packet:",
      "ja": "CLOSE_ACKパケットのHIPヘッダー値："
    },
    {
      "indent": 6,
      "text": "Header: Packet Type = 19 SRC HIT = Sender's HIT DST HIT = Recipient's HIT",
      "ja": "ヘッダー：パケットタイプ= 19 SRCのHIT =送信者のHIT DSTのHIT =受信者のHIT"
    },
    {
      "indent": 6,
      "text": "IP ( HIP ( ECHO_RESPONSE_SIGNED, HMAC, HIP_SIGNATURE ) )",
      "ja": "IP（HIP（ECHO_RESPONSE_SIGNED、HMAC、HIP_SIGNATURE））"
    },
    {
      "indent": 3,
      "text": "Valid control bits: none",
      "ja": "有効な制御ビット：なし"
    },
    {
      "indent": 3,
      "text": "The sender MUST include both an HMAC and signature (calculated over the whole HIP envelope).",
      "ja": "送信者は、（全体HIPエンベロープにわたって計算）HMACと署名の両方を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The receiver peer MUST validate both the HMAC and the signature.",
      "ja": "受信ピアはHMACと署名の両方を検証しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.4. ICMP Messages",
      "section_title": true,
      "ja": "5.4。 ICMPメッセージ"
    },
    {
      "indent": 3,
      "text": "When a HIP implementation detects a problem with an incoming packet, and it either cannot determine the identity of the sender of the packet or does not have any existing HIP association with the sender of the packet, it MAY respond with an ICMP packet. Any such replies MUST be rate-limited as described in [RFC2463]. In most cases, the ICMP packet will have the Parameter Problem type (12 for ICMPv4, 4 for ICMPv6), with the Pointer field pointing to the field that caused the ICMP message to be generated.",
      "ja": "HIP実装が着信パケットの問題を検出し、それはどちらか、パケットの送信者の身元を判別できないか、パケットの送信元を持つ既存のHIPの関連性を持っていない場合は、ICMPパケットで応答することができます。 [RFC2463]に記載されているように、任意のそのような応答は、レート制限されなければなりません。ほとんどの場合、ICMPパケットは、ICMPメッセージが生成される原因となったフィールドを指すポインタフィールドとパラメータ問題のタイプ（ICMPv6のためICMPv4の、4 12）を有することになります。"
    },
    {
      "indent": 0,
      "text": "5.4.1. Invalid Version",
      "section_title": true,
      "ja": "5.4.1。無効なバージョン"
    },
    {
      "indent": 3,
      "text": "If a HIP implementation receives a HIP packet that has an unrecognized HIP version number, it SHOULD respond, rate-limited, with an ICMP packet with type Parameter Problem, the Pointer pointing to the VER./RES. byte in the HIP header.",
      "ja": "HIP実装が認識できないHIPバージョン番号を持っているHIPパケットを受信した場合、それはタイプパラメータ問題、VER./RESを指すポインタを持つICMPパケットで、レート制限応答する必要があります。 HIPヘッダーのバイト。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Other Problems with the HIP Header and Packet Structure",
      "section_title": true,
      "ja": "5.4.2。 HIPヘッダおよびパケットの構造を持つその他の問題"
    },
    {
      "indent": 3,
      "text": "If a HIP implementation receives a HIP packet that has other unrecoverable problems in the header or packet format, it MAY respond, rate-limited, with an ICMP packet with type Parameter Problem, the Pointer pointing to the field that failed to pass the format checks. However, an implementation MUST NOT send an ICMP message if the checksum fails; instead, it MUST silently drop the packet.",
      "ja": "HIP実装がヘッダまたはパケットの形式で他の回復不可能な問題点があったHIPパケットを受信した場合、それはタイプパラメータ問題、フォーマットのチェックを通過することができなかったフィールドを指すポインタでICMPパケットで、速度制限応答MAY 。チェックサムが失敗した場合ただし、実装はICMPメッセージを送ってはいけません。その代わり、それは静かにパケットを廃棄しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.4.3. Invalid Puzzle Solution",
      "section_title": true,
      "ja": "5.4.3。無効なパズルソリューション"
    },
    {
      "indent": 3,
      "text": "If a HIP implementation receives an I2 packet that has an invalid puzzle solution, the behavior depends on the underlying version of IP. If IPv6 is used, the implementation SHOULD respond with an ICMP packet with type Parameter Problem, the Pointer pointing to the beginning of the Puzzle solution #J field in the SOLUTION payload in the HIP message.",
      "ja": "HIP実装が無効なパズルのソリューションを持っているI2パケットを受信した場合、動作は、IPの基本的なバージョンに依存します。 IPv6が使用されている場合、実装は、型パラメータ問題、HIPメッセージでSOLUTIONペイロード内のパズルソリューション#Jフィールドの先頭を指すポインタを持つICMPパケットで応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "If IPv4 is used, the implementation MAY respond with an ICMP packet with the type Parameter Problem, copying enough of bytes from the I2 message so that the SOLUTION parameter fits into the ICMP message, the Pointer pointing to the beginning of the Puzzle solution #J field, as in the IPv6 case. Note, however, that the resulting ICMPv4 message exceeds the typical ICMPv4 message size as defined in [RFC0792].",
      "ja": "IPv4のが使用されている場合、実装はSOLUTIONパラメータは、ICMPメッセージ、パズルソリューションの先頭を指すポインタに収まるようにI2メッセージからバイトを十分にコピーし、タイプパラメータ問題でICMPパケットで応答することができる#J IPv6のケースのようにフィールド、。 [RFC0792]で定義されるように、得られたICMPv4のメッセージは、典型的なICMPv4のメッセージサイズを超えていること、しかし、注意してください。"
    },
    {
      "indent": 0,
      "text": "5.4.4. Non-Existing HIP Association",
      "section_title": true,
      "ja": "5.4.4。非既存のHIP協会"
    },
    {
      "indent": 3,
      "text": "If a HIP implementation receives a CLOSE or UPDATE packet, or any other packet whose handling requires an existing association, that has either a Receiver or Sender HIT that does not match with any existing HIP association, the implementation MAY respond, rate-limited, with an ICMP packet with the type Parameter Problem, and with the Pointer pointing to the beginning of the first HIT that does not match.",
      "ja": "HIP実装がReceiverまたは既存のHIP協会と一致しない送信者HITのいずれかを持っているCLOSEまたはUPDATEパケット、またはその取扱い、既存の関連付けを必要とする他のパケットを受信した場合、実装はして、レート制限、対応MAY ICMPタイプパラメータ問題のパケット、および一致していない最初のHITの先頭を指すポインタを持ちます。"
    },
    {
      "indent": 3,
      "text": "A host MUST NOT reply with such an ICMP if it receives any of the following messages: I1, R2, I2, R2, and NOTIFY. When introducing new packet types, a specification SHOULD define the appropriate rules for sending or not sending this kind of ICMP reply.",
      "ja": "I1、R2、I2、R2、およびNOTIFY：それは、次のいずれかのメッセージを受信した場合、ホストは、ICMPで返答してはなりません。新しいパケットタイプを導入する場合、仕様が送信またはICMP応答のこの種を送信しないための適切なルールを定義する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Packet Processing",
      "section_title": true,
      "ja": "6.パケット処理"
    },
    {
      "indent": 3,
      "text": "Each host is assumed to have a single HIP protocol implementation that manages the host's HIP associations and handles requests for new ones. Each HIP association is governed by a conceptual state machine, with states defined above in Section 4.4. The HIP implementation can simultaneously maintain HIP associations with more than one host. Furthermore, the HIP implementation may have more than one active HIP association with another host; in this case, HIP associations are distinguished by their respective HITs. It is not possible to have more than one HIP association between any given pair of HITs. Consequently, the only way for two hosts to have more than one parallel association is to use different HITs, at least at one end.",
      "ja": "各ホストは、ホストのHIPの関連付けを管理し、新しいものに対する要求を処理する単一のHIPプロトコルの実装を持っていると想定されます。各HIPアソシエーションはセクション4.4で上記で定義された状態で、概念的な状態マシンによって支配されます。 HIPの実装では、同時に複数のホストでHIPの関連付けを維持することができます。また、HIPの実装では、別のホストと複数のアクティブHIPアソシエーションを有していてもよいです。この場合には、HIPの関連付けは、それぞれのヒットによって区別されます。ヒットの任意の対の間に複数のHIPアソシエーションを持つことは不可能です。その結果、2つのホストが複数の平行の関連付けを有するようにするための唯一の方法は、少なくとも一方の端部に、異なるヒットを使用することです。"
    },
    {
      "indent": 3,
      "text": "The processing of packets depends on the state of the HIP association(s) with respect to the authenticated or apparent originator of the packet. A HIP implementation determines whether it has an active association with the originator of the packet based on the HITs. In the case of user data carried in a specific transport format, the transport format document specifies how the incoming packets are matched with the active associations.",
      "ja": "パケットの処理は、パケットの認証され又は明らか発信に対するHIPアソシエーション（複数可）の状態に依存します。 HIP実装は、それがヒットに基づいて、パケットの発信元とのアクティブ・アソシエーションを有しているか否かを判定する。特定のトランスポートフォーマットで運ばユーザデータの場合には、トランスポート・フォーマットの文書は、着信パケットがアクティブアソシエーションと一致している方法を指定します。"
    },
    {
      "indent": 0,
      "text": "6.1. Processing Outgoing Application Data",
      "section_title": true,
      "ja": "6.1。送信アプリケーションデータを処理"
    },
    {
      "indent": 3,
      "text": "In a HIP host, an application can send application-level data using an identifier specified via the underlying API. The API can be a backwards-compatible API (see [HIP-APP]), using identifiers that look similar to IP addresses, or a completely new API, providing enhanced services related to Host Identities. Depending on the HIP implementation, the identifier provided to the application may be different; for example, it can be a HIT or an IP address.",
      "ja": "HIPホストにおいて、アプリケーションは、基礎となるAPIを介して指定された識別子を使用して、アプリケーションレベルのデータを送信することができます。 APIは、アイデンティティをホストに関連する高度なサービスを提供し、IPアドレス、または完全に新しいAPIと似た識別子を使用して、後方互換API（[HIP-APP]を参照）することができます。 HIPの実装に依存して、アプリケーションに提供識別子が異なっていてもよいです。例えば、それはHITまたはIPアドレスを指定できます。"
    },
    {
      "indent": 3,
      "text": "The exact format and method for transferring the data from the source HIP host to the destination HIP host is defined in the corresponding transport format document. The actual data is transferred in the network using the appropriate source and destination IP addresses.",
      "ja": "先HIPホストにソースHIPホストからデータを転送するための正確な形式および方法は、対応するトランスポートフォーマットの文書で定義されています。実際のデータは、適切なソースおよび宛先IPアドレスを使用してネットワークに転送されます。"
    },
    {
      "indent": 3,
      "text": "In this document, conceptual processing rules are defined only for the base case where both hosts have only single usable IP addresses; the multi-address multi-homing case will be specified separately.",
      "ja": "この文書では、概念的な処理ルールのみ両方のホストが単一の使用可能なIPアドレスを持つ基本ケースのために定義されています。マルチアドレスマルチホーミングケースは別々に指定されます。"
    },
    {
      "indent": 3,
      "text": "The following conceptual algorithm describes the steps that are required for handling outgoing datagrams destined to a HIT.",
      "ja": "次の概念的なアルゴリズムは、HIT宛の送信データグラムを処理するために必要な手順について説明します。"
    },
    {
      "indent": 3,
      "text": "1. If the datagram has a specified source address, it MUST be a HIT. If it is not, the implementation MAY replace the source address with a HIT. Otherwise, it MUST drop the packet.",
      "ja": "1.データグラムが指定した送信元アドレスを持っている場合、それはHITでなければなりません。そうでない場合は、実装は、HITと送信元アドレスを交換することができます。それ以外の場合は、パケットを廃棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If the datagram has an unspecified source address, the implementation must choose a suitable source HIT for the datagram.",
      "ja": "2.データグラムが指定されていない送信元アドレスを持っている場合、実装はデータグラムに適したソースHITを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "3. If there is no active HIP association with the given <source, destination> HIT pair, one must be created by running the base exchange. While waiting for the base exchange to complete, the implementation SHOULD queue at least one packet per HIP association to be formed, and it MAY queue more than one.",
      "ja": "所与の<ソース、宛先> HIT対でアクティブなHIPアソシエーションが存在しない場合3は、一つは塩基交換を実行することによって作成されなければなりません。塩基交換が完了するのを待っている間、実装はHIP協会あたり少なくとも1つのパケットが形成されるようにキューべきであり、それ以上のものを待機させることができます。"
    },
    {
      "indent": 3,
      "text": "4. Once there is an active HIP association for the given <source, destination> HIT pair, the outgoing datagram is passed to transport handling. The possible transport formats are defined in separate documents, of which the ESP transport format for HIP is mandatory for all HIP implementations.",
      "ja": "4.所与<ソース、宛先> HITペアのアクティブHIPアソシエーションが存在すると、発信データグラムは、取り扱いを輸送するために渡されます。可能なトランスポートフォーマットは、HIPのためのESPトランスポートフォーマットは、すべてのHIPの実装のために必須となっている、別の文書で定義されています。"
    },
    {
      "indent": 3,
      "text": "5. Before sending the packet, the HITs in the datagram are replaced with suitable IP addresses. For IPv6, the rules defined in [RFC3484] SHOULD be followed. Note that this HIT-to-IP-address conversion step MAY also be performed at some other point in the stack, e.g., before wrapping the packet into the output format.",
      "ja": "5.パケットを送信する前に、データグラム内のヒットは、適切なIPアドレスに置き換えられます。 IPv6の場合、[RFC3484]で定義されたルールに従わされるべきです。このHITとIPアドレス変換ステップは、出力フォーマットにパケットを巻き付ける前に、例えば、スタック内の他のいくつかの時点で実行されてもよいことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "6.2. Processing Incoming Application Data",
      "section_title": true,
      "ja": "6.2。着信アプリケーションデータを処理"
    },
    {
      "indent": 3,
      "text": "The following conceptual algorithm describes the incoming datagram handling when HITs are used at the receiving host as application-level identifiers. More detailed steps for processing packets are defined in corresponding transport format documents.",
      "ja": "以下の概念アルゴリズムは、ヒットがアプリケーションレベルの識別子として受信ホストで使用される入力データグラムの取り扱いについて記載しています。パケットを処理する詳細な手順は、対応するトランスポートフォーマットの文書で定義されています。"
    },
    {
      "indent": 3,
      "text": "1. The incoming datagram is mapped to an existing HIP association, typically using some information from the packet. For example, such mapping may be based on the ESP Security Parameter Index (SPI).",
      "ja": "1.着信データグラムは、典型的には、パケットからの情報を使用して、既存のHIPアソシエーションにマッピングされます。例えば、このようなマッピングは、ESPセキュリティパラメータインデックス（SPI）に基づくことができます。"
    },
    {
      "indent": 3,
      "text": "2. The specific transport format is unwrapped, in a way depending on the transport format, yielding a packet that looks like a standard (unencrypted) IP packet. If possible, this step SHOULD also verify that the packet was indeed (once) sent by the remote HIP host, as identified by the HIP association.",
      "ja": "2.特定のトランスポート・フォーマットは、標準的な（暗号化されていない）IPパケットのように見えるパケットを得、トランスポート・フォーマットに応じた方法で、開封されています。可能な場合、このステップは、また、HIPアソシエーションによって識別されるパケットが実際に（1回）、リモートHIPホストによって送信されたことを確認してください。"
    },
    {
      "indent": 7,
      "text": "Depending on the used transport mode, the verification method can\nvary.  While the HI (as well as HIT) is used as the higher-layer\nidentifier, the verification method has to verify that the data\npacket was sent by a node identity and that the actual identity\nmaps to this particular HIT.  When using ESP transport format\n[RFC5202], the verification is done using the SPI value in the\ndata packet to find the corresponding SA with associated HIT and\nkey, and decrypting the packet with that associated key.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. The IP addresses in the datagram are replaced with the HITs associated with the HIP association. Note that this IP-address-to-HIT conversion step MAY also be performed at some other point in the stack.",
      "ja": "前記データグラムのIPアドレスはHIPアソシエーションに関連付けられたヒットで置換されています。このIPアドレス対HIT変換ステップは、スタック内の他のいくつかの時点で実行されてもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "4. The datagram is delivered to the upper layer. When demultiplexing the datagram, the right upper-layer socket is based on the HITs.",
      "ja": "4.データグラムを上位層に配信されます。データグラムを逆多重化するとき、右上層ソケットがヒットに基づいています。"
    },
    {
      "indent": 0,
      "text": "6.3. Solving the Puzzle",
      "section_title": true,
      "ja": "6.3。パズルを解きます"
    },
    {
      "indent": 3,
      "text": "This subsection describes the puzzle-solving details.",
      "ja": "ここでは、パズルを解くの詳細を説明します。"
    },
    {
      "indent": 3,
      "text": "In R1, the values I and K are sent in network byte order. Similarly, in I2, the values I and J are sent in network byte order. The hash is created by concatenating, in network byte order, the following data, in the following order and using the RHASH algorithm:",
      "ja": "R1では、IとKの値はネットワークバイト順序で送信されます。同様に、I2に、I及びJの値は、ネットワークバイト順で送信されます。ハッシュは、次の順序で、ネットワークバイト順で、以下のデータを連結し、RHASHアルゴリズムを使用して作成されます。"
    },
    {
      "indent": 6,
      "text": "64-bit random value I, in network byte order, as appearing in R1 and I2.",
      "ja": "R1及びI2に現れるような、ネットワークバイト順で64ビットのランダム値I、、。"
    },
    {
      "indent": 6,
      "text": "128-bit Initiator's HIT, in network byte order, as appearing in the HIP Payload in R1 and I2.",
      "ja": "ネットワークバイト順に128ビットのイニシエータのHIT、R1及びI2でHIPペイロードに現れるとして。"
    },
    {
      "indent": 6,
      "text": "128-bit Responder's HIT, in network byte order, as appearing in the HIP Payload in R1 and I2.",
      "ja": "ネットワークバイト順に128ビットのレスポンダのHIT、R1及びI2でHIPペイロードに現れるとして。"
    },
    {
      "indent": 6,
      "text": "64-bit random value J, in network byte order, as appearing in I2.",
      "ja": "64ビットのランダム値J、ネットワークバイト順で、I2に現れるとして。"
    },
    {
      "indent": 3,
      "text": "In order to be a valid response puzzle, the K low-order bits of the resulting RHASH digest must be zero.",
      "ja": "有効な応答パズルであるために、結果として得られるRHASHダイジェストのK下位ビットはゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 6,
      "text": "i) The length of the data to be hashed is 48 bytes.",
      "ja": "I）ハッシュすべきデータの長さは48バイトです。"
    },
    {
      "indent": 6,
      "text": "ii) All the data in the hash input MUST be in network byte order.",
      "ja": "ⅱ）ハッシュ入力内のすべてのデータはネットワークバイト順でなければなりません。"
    },
    {
      "indent": 6,
      "text": "iii) The order of the Initiator's and Responder's HITs are different in the R1 and I2 packets; see Section 5.1. Care must be taken to copy the values in the right order to the hash input.",
      "ja": "III）イニシエータのとレスポンダのヒットの順序は、R1及びI2パケットが異なります。セクション5.1を参照してください。ケアは、ハッシュ入力に正しい順序で値をコピーするために取られなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following procedure describes the processing steps involved, assuming that the Responder chooses to precompute the R1 packets:",
      "ja": "次の手順では、レスポンダは、R1パケットを事前計算することを選択したと仮定すると、関係する処理ステップを説明します。"
    },
    {
      "indent": 3,
      "text": "Precomputation by the Responder: Sets up the puzzle difficulty K. Creates a signed R1 and caches it.",
      "ja": "レスポンダによって事前計算は：K.署名R1を作成し、それをキャッシュパズルの難易度を設定します。"
    },
    {
      "indent": 3,
      "text": "Responder: Selects a suitable cached R1. Generates a random number I. Sends I and K in an R1. Saves I and K for a Delta time.",
      "ja": "Responderは：、適切なキャッシュされたR1を選択します。乱数I.はR1でIとKを送信生成します。デルタ時間のためにIとKを保存します。"
    },
    {
      "indent": 3,
      "text": "Initiator: Generates repeated attempts to solve the puzzle until a matching J is found: Ltrunc( RHASH( I | HIT-I | HIT-R | J ), K ) == 0 Sends I and J in an I2.",
      "ja": "イニシエータ：Jが見つかるまで、マッチングパズルを解くために反復試行を生成し：Ltrunc（RHASH（I | HIT-I | HIT-R | J）、K）== 0はI2にI及びJを送信します。"
    },
    {
      "indent": 3,
      "text": "Responder: Verifies that the received I is a saved one. Finds the right K based on I. Computes V := Ltrunc( RHASH( I | HIT-I | HIT-R | J ), K ) Rejects if V != 0 Accept if V == 0",
      "ja": "レスポンダ：受け取った私は、保存された一つであることを確認します。検索しI.に基づく権利KはVを計算します：！= Ltrunc（RHASH（I | HIT-I | HIT-R | J）、K）は、V == 0ならばV = 0が受け入れた場合に拒否"
    },
    {
      "indent": 0,
      "text": "6.4. HMAC and SIGNATURE Calculation and Verification",
      "section_title": true,
      "ja": "6.4。 HMACと署名計算と検証"
    },
    {
      "indent": 3,
      "text": "The following subsections define the actions for processing HMAC, HIP_SIGNATURE and HIP_SIGNATURE_2 parameters.",
      "ja": "以下のサブセクションでは、HMAC、HIP_SIGNATUREとHIP_SIGNATURE_2パラメータを処理するためのアクションを定義します。"
    },
    {
      "indent": 0,
      "text": "6.4.1. HMAC Calculation",
      "section_title": true,
      "ja": "6.4.1。 HMACの計算"
    },
    {
      "indent": 3,
      "text": "The following process applies both to the HMAC and HMAC_2 parameters. When processing HMAC_2, the difference is that the HMAC calculation includes a pseudo HOST_ID field containing the Responder's information as sent in the R1 packet earlier.",
      "ja": "次のプロセスは、HMACとHMAC_2パラメータの両方に適用されます。 HMAC_2を処理するときに、違いは、以前のR1パケットで送信されるようHMAC計算はレスポンダの情報を含む擬似HOST_IDフィールドを含むことです。"
    },
    {
      "indent": 3,
      "text": "Both the Initiator and the Responder should take some care when verifying or calculating the HMAC_2. Specifically, the Responder should preserve other parameters than the HOST_ID when sending the R2. Also, the Initiator has to preserve the HOST_ID exactly as it was received in the R1 packet.",
      "ja": "検証やHMAC_2を計算するときに、イニシエータとレスポンダの両方が、いくつかの世話をする必要があります。 R2を送信するとき、具体的に、レスポンダはHOST_ID以外のパラメータを保存すべきです。また、イニシエータは、それがR1パケットで受信したものと同じHOST_IDを維持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The scope of the calculation for HMAC and HMAC_2 is:",
      "ja": "HMACとHMAC_2のための計算の範囲は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "HMAC: { HIP header | [ Parameters ] }",
      "ja": "HMAC：{HIPヘッダ| [ パラメーター ] }"
    },
    {
      "indent": 3,
      "text": "where Parameters include all HIP parameters of the packet that is being calculated with Type values from 1 to (HMAC's Type value - 1) and exclude parameters with Type values greater or equal to HMAC's Type value.",
      "ja": "（HMACのタイプの値を -  1）パラメータは、1からタイプ値を用いて算出されているパケットのすべてのHIPパラメータを含む場合と除外するパラメータを入力するには、HMACのタイプ値以上の値を持ちます。"
    },
    {
      "indent": 3,
      "text": "During HMAC calculation, the following applies:",
      "ja": "HMAC計算の際、以下が適用されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Checksum field is set to zero.",
      "ja": "HIPヘッダ中のO、チェックサムフィールドはゼロに設定されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Header Length field value is calculated to the beginning of the HMAC parameter.",
      "ja": "O HIPヘッダは、ヘッダ長フィールドの値は、HMACパラメータの最初に計算されます。"
    },
    {
      "indent": 3,
      "text": "Parameter order is described in Section 5.2.1.",
      "ja": "パラメータの順序は、セクション5.2.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "HMAC_2: { HIP header | [ Parameters ] | HOST_ID }",
      "ja": "HMAC_2：{HIPヘッダ| [パラメータ] | HOST_ID}"
    },
    {
      "indent": 3,
      "text": "where Parameters include all HIP parameters for the packet that is being calculated with Type values from 1 to (HMAC_2's Type value - 1) and exclude parameters with Type values greater or equal to HMAC_2's Type value.",
      "ja": "（HMAC_2のタイプ値 -  1）パラメータは、1からタイプ値を用いて計算されているパケットのためのすべてのHIPパラメータ含める場合と除外するパラメータをタイプHMAC_2のタイプ値以上の値を持ちます。"
    },
    {
      "indent": 3,
      "text": "During HMAC_2 calculation, the following applies:",
      "ja": "HMAC_2計算中、以下が適用されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Checksum field is set to zero.",
      "ja": "HIPヘッダ中のO、チェックサムフィールドはゼロに設定されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Header Length field value is calculated to the beginning of the HMAC_2 parameter and added to the length of the concatenated HOST_ID parameter length.",
      "ja": "O HIPヘッダでは、ヘッダ長フィールドの値がHMAC_2パラメータの最初に計算され、連結HOST_IDパラメータ長の長さに加えます。"
    },
    {
      "indent": 3,
      "text": "o HOST_ID parameter is exactly in the form it was received in the R1 packet from the Responder.",
      "ja": "O HOST_IDパラメータは、正確には、レスポンダからR1パケットで受信された形態です。"
    },
    {
      "indent": 3,
      "text": "Parameter order is described in Section 5.2.1, except that the HOST_ID parameter in this calculation is added to the end.",
      "ja": "パラメータの順序は、この計算でHOST_IDパラメータが最後に追加されることを除いて、セクション5.2.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "The HMAC parameter is defined in Section 5.2.9 and the HMAC_2 parameter in Section 5.2.10. The HMAC calculation and verification process (the process applies both to HMAC and HMAC_2 except where HMAC_2 is mentioned separately) is as follows:",
      "ja": "HMACのパラメータは、セクション5.2.9と5.2.10でHMAC_2パラメータで定義されています。 HMAC計算および検証プロセス（プロセスがHMAC_2が別々に記載されている場合を除き、HMACとHMAC_2の両方に適用される）以下の通りであります："
    },
    {
      "indent": 3,
      "text": "Packet sender:",
      "ja": "パケット送信："
    },
    {
      "indent": 3,
      "text": "1. Create the HIP packet, without the HMAC, HIP_SIGNATURE, HIP_SIGNATURE_2, or any other parameter with greater Type value than the HMAC parameter has.",
      "ja": "1. HMAC、HIP_SIGNATURE、HIP_SIGNATURE_2、またはHMACパラメータよりも大きいタイプの値を持つ他のパラメータがあるなしで、HIPパケットを作成します。"
    },
    {
      "indent": 3,
      "text": "2. In case of HMAC_2 calculation, add a HOST_ID (Responder) parameter to the end of the packet.",
      "ja": "2. HMAC_2計算の場合には、パケットの最後にHOST_ID（レスポンダ）パラメータを追加します。"
    },
    {
      "indent": 3,
      "text": "3. Calculate the Header Length field in the HIP header including the added HOST_ID parameter in case of HMAC_2.",
      "ja": "3. HMAC_2の場合に添加HOST_IDパラメータを含むHIPヘッダのヘッダ長フィールドを計算します。"
    },
    {
      "indent": 3,
      "text": "4. Compute the HMAC using either HIP-gl or HIP-lg integrity key retrieved from KEYMAT as defined in Section 6.5.",
      "ja": "4. HIP-GLまたはHIP-LGのいずれかのセクション6.5で定義されるようKEYMATから取得インテグリティキーを使用してHMACを計算します。"
    },
    {
      "indent": 3,
      "text": "5. In case of HMAC_2, remove the HOST_ID parameter from the packet.",
      "section_title": true,
      "ja": "5. HMAC_2の場合には、パケットからHOST_IDパラメータを削除します。"
    },
    {
      "indent": 3,
      "text": "6. Add the HMAC parameter to the packet and any parameter with greater Type value than the HMAC's (HMAC_2's) that may follow, including possible HIP_SIGNATURE or HIP_SIGNATURE_2 parameters",
      "ja": "6.可能HIP_SIGNATURE又はHIP_SIGNATURE_2パラメータを含む従うことパケット及びHMACの（HMAC_2の）より大きいType値を持つパラメータにHMACパラメータを追加"
    },
    {
      "indent": 3,
      "text": "7. Recalculate the Length field in the HIP header.",
      "section_title": true,
      "ja": "7. HIPヘッダの長さフィールドを再計算。"
    },
    {
      "indent": 3,
      "text": "Packet receiver:",
      "ja": "パケット受信機："
    },
    {
      "indent": 3,
      "text": "1. Verify the HIP header Length field.",
      "section_title": true,
      "ja": "1. HIPヘッダ長フィールドを確認します。"
    },
    {
      "indent": 3,
      "text": "2. Remove the HMAC or HMAC_2 parameter, as well as all other parameters that follow it with greater Type value including possible HIP_SIGNATURE or HIP_SIGNATURE_2 fields, saving the contents if they will be needed later.",
      "ja": "2.それらは後で必要になる場合は内容を保存し、HMACまたはHMAC_2パラメータだけでなく、可能HIP_SIGNATUREまたはHIP_SIGNATURE_2フィールドを含むより大きなタイプの値と、それに続く他のすべてのパラメータを削除します。"
    },
    {
      "indent": 3,
      "text": "3. In case of HMAC_2, build and add a HOST_ID parameter (with Responder information) to the packet. The HOST_ID parameter should be identical to the one previously received from the Responder.",
      "ja": "3. HMAC_2の場合には、構築したパケットに（レスポンダ情報付き）HOST_IDパラメータを追加します。 HOST_IDパラメータは、以前にレスポンダから受信したものと同一でなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. Recalculate the HIP packet length in the HIP header and clear the Checksum field (set it to all zeros). In case of HMAC_2, the length is calculated with the added HOST_ID parameter.",
      "ja": "4. HIPヘッダーのHIPパケット長を再計算し（全てゼロに設定）チェックサムフィールドをクリアします。 HMAC_2の場合には、長さが追加HOST_IDパラメータで計算されます。"
    },
    {
      "indent": 3,
      "text": "5. Compute the HMAC using either HIP-gl or HIP-lg integrity key as defined in Section 6.5 and verify it against the received HMAC.",
      "ja": "5.計算HMACセクション6.5で定義されるようにHIP-GLまたはHIP-LGインテグリティキーのいずれかを使用して、受信したHMACに対してそれを検証します。"
    },
    {
      "indent": 3,
      "text": "6. Set Checksum and Header Length field in the HIP header to original values.",
      "ja": "元の値にHIPヘッダーの6セットのチェックサムとヘッダ長フィールド。"
    },
    {
      "indent": 3,
      "text": "7. In case of HMAC_2, remove the HOST_ID parameter from the packet before further processing.",
      "ja": "7. HMAC_2の場合には、さらなる処理の前にパケットからHOST_IDパラメータを削除します。"
    },
    {
      "indent": 0,
      "text": "6.4.2. Signature Calculation",
      "section_title": true,
      "ja": "6.4.2。署名計算"
    },
    {
      "indent": 3,
      "text": "The following process applies both to the HIP_SIGNATURE and HIP_SIGNATURE_2 parameters. When processing HIP_SIGNATURE_2, the only difference is that instead of HIP_SIGNATURE parameter, the HIP_SIGNATURE_2 parameter is used, and the Initiator's HIT and PUZZLE Opaque and Random #I fields are cleared (set to all zeros) before computing the signature. The HIP_SIGNATURE parameter is defined in Section 5.2.11 and the HIP_SIGNATURE_2 parameter in Section 5.2.12.",
      "ja": "次のプロセスはHIP_SIGNATUREとHIP_SIGNATURE_2パラメータの両方に適用されます。 HIP_SIGNATURE_2を処理する場合、唯一の違いは、代わりHIP_SIGNATUREパラメータの、HIP_SIGNATURE_2パラメータが使用されることで、イニシエータのHITパズル不透明とランダム#Iフィールドは、署名を計算する前に（全てゼロに設定）がクリアされています。 HIP_SIGNATUREパラメータは、セクション5.2.11および5.2.12節でHIP_SIGNATURE_2パラメータで定義されています。"
    },
    {
      "indent": 3,
      "text": "The scope of the calculation for HIP_SIGNATURE and HIP_SIGNATURE_2 is:",
      "ja": "HIP_SIGNATUREとHIP_SIGNATURE_2のための計算の範囲は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "HIP_SIGNATURE: { HIP header | [ Parameters ] }",
      "ja": "HIP_SIGNATURE：{HIPヘッダ| [ パラメーター ] }"
    },
    {
      "indent": 3,
      "text": "where Parameters include all HIP parameters for the packet that is being calculated with Type values from 1 to (HIP_SIGNATURE's Type value - 1).",
      "ja": "パラメータは、1から（ -  1 HIP_SIGNATUREのタイプ値）にタイプ値を用いて計算されているパケットのためのすべてのHIPパラメータを含む場合。"
    },
    {
      "indent": 3,
      "text": "During signature calculation, the following apply:",
      "ja": "署名計算の間に、次が適用されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Checksum field is set to zero.",
      "ja": "HIPヘッダ中のO、チェックサムフィールドはゼロに設定されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Header Length field value is calculated to the beginning of the HIP_SIGNATURE parameter.",
      "ja": "O HIPヘッダは、ヘッダ長フィールドの値がHIP_SIGNATUREパラメータの最初に計算されます。"
    },
    {
      "indent": 3,
      "text": "Parameter order is described in Section 5.2.1.",
      "ja": "パラメータの順序は、セクション5.2.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "HIP_SIGNATURE_2: { HIP header | [ Parameters ] }",
      "ja": "HIP_SIGNATURE_2：{HIPヘッダ| [ パラメーター ] }"
    },
    {
      "indent": 3,
      "text": "where Parameters include all HIP parameters for the packet that is being calculated with Type values from 1 to (HIP_SIGNATURE_2's Type value - 1).",
      "ja": "パラメータは、1から（ -  1 HIP_SIGNATURE_2のタイプ値）にタイプ値を用いて計算されているパケットのためのすべてのHIPパラメータを含む場合。"
    },
    {
      "indent": 3,
      "text": "During signature calculation, the following apply:",
      "ja": "署名計算の間に、次が適用されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Initiator's HIT field and Checksum fields are set to zero.",
      "ja": "HIPヘッダ中のO、イニシエータのHITフィールドおよびチェックサムフィールドはゼロに設定されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Header Length field value is calculated to the beginning of the HIP_SIGNATURE_2 parameter.",
      "ja": "O HIPヘッダは、ヘッダ長フィールドの値がHIP_SIGNATURE_2パラメータの最初に計算されます。"
    },
    {
      "indent": 3,
      "text": "o PUZZLE parameter's Opaque and Random #I fields are set to zero.",
      "ja": "O PUZZLEパラメータの不透明とランダム#Iフィールドはゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "Parameter order is described in Section 5.2.1.",
      "ja": "パラメータの順序は、セクション5.2.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "Signature calculation and verification process (the process applies both to HIP_SIGNATURE and HIP_SIGNATURE_2 except in the case where HIP_SIGNATURE_2 is separately mentioned):",
      "ja": "署名の計算及び検証プロセス（プロセスがHIP_SIGNATURE_2が別々に記載されている場合を除いて、両方のHIP_SIGNATUREとHIP_SIGNATURE_2に適用されます）。"
    },
    {
      "indent": 3,
      "text": "Packet sender:",
      "ja": "パケット送信："
    },
    {
      "indent": 3,
      "text": "1. Create the HIP packet without the HIP_SIGNATURE parameter or any parameters that follow the HIP_SIGNATURE parameter.",
      "ja": "1. HIP_SIGNATUREパラメータまたはHIP_SIGNATUREパラメータに続くパラメータなしでHIPパケットを作成します。"
    },
    {
      "indent": 3,
      "text": "2. Calculate the Length field and zero the Checksum field in the HIP header. In case of HIP_SIGNATURE_2, set Initiator's HIT field in the HIP header as well as PUZZLE parameter's Opaque and Random #I fields to zero.",
      "ja": "2. Lengthフィールドを計算し、HIPヘッダ内のチェックサムフィールドをゼロ。 HIP_SIGNATURE_2の場合には、ゼロにHIPヘッダ内のイニシエータのHITフィールドならびにパズルパラメータの不透明とランダム#Iフィールドを設定します。"
    },
    {
      "indent": 3,
      "text": "3. Compute the signature using the private key corresponding to the Host Identifier (public key).",
      "ja": "3.計算ホスト識別子（公開鍵）に対応する秘密鍵を用いて署名。"
    },
    {
      "indent": 3,
      "text": "4. Add the HIP_SIGNATURE parameter to the packet.",
      "section_title": true,
      "ja": "4.パケットにHIP_SIGNATUREパラメータを追加します。"
    },
    {
      "indent": 3,
      "text": "5. Add any parameters that follow the HIP_SIGNATURE parameter.",
      "section_title": true,
      "ja": "5. HIP_SIGNATUREパラメータに続く任意のパラメータを追加します。"
    },
    {
      "indent": 3,
      "text": "6. Recalculate the Length field in the HIP header, and calculate the Checksum field.",
      "ja": "6. HIPヘッダの長さフィールドを再計算し、チェックサムフィールドを計算します。"
    },
    {
      "indent": 3,
      "text": "Packet receiver:",
      "ja": "パケット受信機："
    },
    {
      "indent": 3,
      "text": "1. Verify the HIP header Length field.",
      "section_title": true,
      "ja": "1. HIPヘッダ長フィールドを確認します。"
    },
    {
      "indent": 3,
      "text": "2. Save the contents of the HIP_SIGNATURE parameter and any parameters following the HIP_SIGNATURE parameter and remove them from the packet.",
      "ja": "2. HIP_SIGNATUREパラメータの内容とHIP_SIGNATUREパラメータ以下のいずれかのパラメータを保存して、パケットから削除します。"
    },
    {
      "indent": 3,
      "text": "3. Recalculate the HIP packet Length in the HIP header and clear the Checksum field (set it to all zeros). In case of HIP_SIGNATURE_2, set Initiator's HIT field in HIP header as well as PUZZLE parameter's Opaque and Random #I fields to zero.",
      "ja": "3. HIPヘッダーのHIPパケット長を再計算し（全てゼロに設定）チェックサムフィールドをクリアします。 HIP_SIGNATURE_2の場合には、ゼロにHIPヘッダ内のイニシエータのHITフィールドならびにパズルパラメータの不透明とランダム#Iフィールドを設定します。"
    },
    {
      "indent": 3,
      "text": "4. Compute the signature and verify it against the received signature using the packet sender's Host Identifier (public key).",
      "ja": "4.署名を計算し、パケットの送信元のホスト識別子（公開鍵）を使用して、受信した署名に対してそれを検証します。"
    },
    {
      "indent": 3,
      "text": "5. Restore the original packet by adding removed parameters (in step 2) and resetting the values that were set to zero (in step 3).",
      "ja": "5.（ステップ2）を除去パラメータを追加し、（ステップ3）がゼロに設定された値をリセットして元のパケットを復元します。"
    },
    {
      "indent": 3,
      "text": "The verification can use either the HI received from a HIP packet, the HI from a DNS query, if the FQDN has been received in the HOST_ID packet, or one received by some other means.",
      "ja": "検証は、FQDNがHOST_IDパケット、またはいくつかの他の手段によって受信した1つで受信された場合HIは、DNSクエリからHIPパケット、HIから受信のいずれかを使用することができます。"
    },
    {
      "indent": 0,
      "text": "6.5. HIP KEYMAT Generation",
      "section_title": true,
      "ja": "6.5。 HIPのKEYMATの生成"
    },
    {
      "indent": 3,
      "text": "HIP keying material is derived from the Diffie-Hellman session key, Kij, produced during the HIP base exchange (Section 4.1.3). The Initiator has Kij during the creation of the I2 packet, and the Responder has Kij once it receives the I2 packet. This is why I2 can already contain encrypted information.",
      "ja": "HIPキーイング材料をHIP基本交換（セクション4.1.3）の間に生成さのDiffie-Hellmanセッション鍵、Kijを、由来します。イニシエータは、I2パケットの作成中にKijをを持っており、それがI2パケットを受信するとResponderはKijをしています。 I2はすでに暗号化された情報を含めることができる理由です。"
    },
    {
      "indent": 3,
      "text": "The KEYMAT is derived by feeding Kij and the HITs into the following operation; the | operation denotes concatenation.",
      "ja": "KEYMATはKijを、次の操作にヒットを供給することによって導出されます。 |操作は連結を示しています。"
    },
    {
      "indent": 4,
      "text": "KEYMAT = K1 | K2 | K3 | ... where",
      "ja": "KEYMAT = K1 | K2 | K3 | ... どこ"
    },
    {
      "indent": 4,
      "text": "K1 = RHASH( Kij | sort(HIT-I | HIT-R) | I | J | 0x01 ) K2 = RHASH( Kij | K1 | 0x02 ) K3 = RHASH( Kij | K2 | 0x03 ) ... K255 = RHASH( Kij | K254 | 0xff ) K256 = RHASH( Kij | K255 | 0x00 ) etc.",
      "ja": "K1 = RHASH（Kijを|ソート（HIT-I | HIT-R）| I | J |は0x01）K2 = RHASH（Kijを| K1 | 0x02の）K3 = RHASH（Kijを| K2 | 0x03の）... K255 = RHASH（ KIJ | K254 | 0xffの）K256 = RHASH（KIJ | K255 | $ 00）など"
    },
    {
      "indent": 3,
      "text": "Sort(HIT-I | HIT-R) is defined as the network byte order concatenation of the two HITs, with the smaller HIT preceding the larger HIT, resulting from the numeric comparison of the two HITs interpreted as positive (unsigned) 128-bit integers in network byte order.",
      "ja": "ソート（HIT-Iは、| HIT-R）が正（符号なし）128ビットとして解釈2安打の数値比較から生じる、より大きなHIT先行小さいHITと、2安打のネットワークバイト順の連結として定義されますネットワークバイト順序の整数。"
    },
    {
      "indent": 3,
      "text": "I and J values are from the puzzle and its solution that were exchanged in R1 and I2 messages when this HIP association was set up. Both hosts have to store I and J values for the HIP association for future use.",
      "ja": "IとJの値は、このHIPアソシエーションが設定されたとき、R1とI2のメッセージで交換されたパズルとその溶液からです。両方のホストは、将来の使用のためのHIPアソシエーションのためにIおよびJの値を格納しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The initial keys are drawn sequentially in the order that is determined by the numeric comparison of the two HITs, with comparison method described in the previous paragraph. HOST_g denotes the host with the greater HIT value, and HOST_l the host with the lower HIT value.",
      "ja": "最初のキーは、前の段落で説明した比較方法を用いて、2安打の数値比較によって決定される順序で順次描画されます。 HOST_gが大きくHIT値でホストを示し、下部HIT値でHOST_lホスト。"
    },
    {
      "indent": 3,
      "text": "The drawing order for initial keys:",
      "ja": "最初のキーの描画順序："
    },
    {
      "indent": 6,
      "text": "HIP-gl encryption key for HOST_g's outgoing HIP packets",
      "ja": "HOST_gの送信HIPパケットのHIP-GL暗号化キー"
    },
    {
      "indent": 6,
      "text": "HIP-gl integrity (HMAC) key for HOST_g's outgoing HIP packets",
      "ja": "HIP-GLの整合性（HMAC）HOST_gの送信HIPパケットのキー"
    },
    {
      "indent": 6,
      "text": "HIP-lg encryption key (currently unused) for HOST_l's outgoing HIP packets",
      "ja": "HOST_lの送信HIPパケットのHIP-LG暗号化キー（現在未使用）"
    },
    {
      "indent": 6,
      "text": "HIP-lg integrity (HMAC) key for HOST_l's outgoing HIP packets",
      "ja": "HIP-LGインテグリティ（HMAC）HOST_lの送信HIPパケットのキー"
    },
    {
      "indent": 3,
      "text": "The number of bits drawn for a given algorithm is the \"natural\" size of the keys. For the mandatory algorithms, the following sizes apply:",
      "ja": "所定のアルゴリズムに描かれたビットの数は、キーの「自然な」サイズです。必須のアルゴリズムについては、以下のサイズが適用されます。"
    },
    {
      "indent": 3,
      "text": "AES 128 bits",
      "ja": "AES 128ビット"
    },
    {
      "indent": 3,
      "text": "SHA-1 160 bits",
      "ja": "SHA-1 160ビット"
    },
    {
      "indent": 3,
      "text": "NULL 0 bits",
      "ja": "NULL 0ビット"
    },
    {
      "indent": 3,
      "text": "If other key sizes are used, they must be treated as different encryption algorithms and defined separately.",
      "ja": "他のキーサイズが使用されている場合、それらは異なる暗号化アルゴリズムとして扱われ、個別に定義する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6. Initiation of a HIP Exchange",
      "section_title": true,
      "ja": "6.6。 HIP交換の開始"
    },
    {
      "indent": 3,
      "text": "An implementation may originate a HIP exchange to another host based on a local policy decision, usually triggered by an application datagram, in much the same way that an IPsec IKE key exchange can dynamically create a Security Association. Alternatively, a system may initiate a HIP exchange if it has rebooted or timed out, or otherwise lost its HIP state, as described in Section 4.5.4.",
      "ja": "実装は、かなりのIPsec IKE鍵交換が動的にセキュリティアソシエーションを作成することができるのと同じように、通常はアプリケーションのデータグラムによってトリガローカルポリシーの決定に基づいて、別のホストへのHIP交換を生じてもよいです。あるいは、それは再起動またはタイムアウトした場合、システムは、HIP交換を開始することができる、またはそうでなければ、セクション4.5.4に記載したように、そのHIP状態を失いました。"
    },
    {
      "indent": 3,
      "text": "The implementation prepares an I1 packet and sends it to the IP address that corresponds to the peer host. The IP address of the peer host may be obtained via conventional mechanisms, such as DNS lookup. The I1 contents are specified in Section 5.3.1. The selection of which Host Identity to use, if a host has more than one to choose from, is typically a policy decision.",
      "ja": "実装は、I1パケットを作成し、ピア・ホストに対応するIPアドレスに送信します。ピア・ホストのIPアドレスは、DNSルックアップのような従来の機構を介して得ることができます。 I1の内容は、セクション5.3.1で指定されています。ホストから選択する以上のものを持っている場合は、使用するホストのアイデンティティの選択は、一般的に政策決定です。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for initiating a HIP exchange:",
      "ja": "次の手順は、HIP交換を開始するための概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. The Initiator gets the Responder's HIT and one or more addresses either from a DNS lookup of the Responder's FQDN, from some other repository, or from a local table. If the Initiator does not know the Responder's HIT, it may attempt opportunistic mode by using NULL (all zeros) as the Responder's HIT. See also \"HIP Opportunistic Mode\" (Section 4.1.6).",
      "ja": "1.イニシエータがレスポンダのHITとレスポンダのFQDNのDNSルックアップから、いくつかの他のリポジトリから、またはローカルテーブルからいずれか1つ以上のアドレスを取得します。イニシエータは、レスポンダのHITがわからない場合は、レスポンダのHITとしてNULL（すべてゼロ）を使用して日和見モードを試みることができます。また、「HIP日和見モード」（セクション4.1.6）を参照してください。"
    },
    {
      "indent": 3,
      "text": "2. The Initiator sends an I1 to one of the Responder's addresses. The selection of which address to use is a local policy decision.",
      "ja": "2.イニシエータは、レスポンダのアドレスの1つにI1を送信します。使用するアドレスの選択は、ローカルの政策決定です。"
    },
    {
      "indent": 3,
      "text": "3. Upon sending an I1, the sender shall transition to state I1-SENT, start a timer whose timeout value should be larger than the worst-case anticipated RTT, and shall increment a timeout counter associated with the I1.",
      "ja": "3. I1を送信すると、送信者は、SENT-I1状態に移行そのタイムアウト値は、最悪の場合よりも大きくなければならないRTTを予想タイマーを起動し、I1に関連付けられたタイムアウトカウンタをインクリメントしなければならないものとします。"
    },
    {
      "indent": 3,
      "text": "4. Upon timeout, the sender SHOULD retransmit the I1 and restart the timer, up to a maximum of I1_RETRIES_MAX tries.",
      "ja": "4.タイムアウトすると、送信者はアップI1_RETRIES_MAXを試みるの最大に、タイマーをI1を再送信し、再起動する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6.1. Sending Multiple I1s in Parallel",
      "section_title": true,
      "ja": "6.6.1。並行して複数のI1sを送信"
    },
    {
      "indent": 3,
      "text": "For the sake of minimizing the session establishment latency, an implementation MAY send the same I1 to more than one of the Responder's addresses. However, it MUST NOT send to more than three (3) addresses in parallel. Furthermore, upon timeout, the implementation MUST refrain from sending the same I1 packet to multiple addresses. That is, if it retries to initialize the connection after timeout, it MUST NOT send the I1 packet to more than one destination address. These limitations are placed in order to avoid congestion of the network, and potential DoS attacks that might happen, e.g., because someone's claim to have hundreds or thousands of addresses could generate a huge number of I1 messages from the Initiator.",
      "ja": "セッション確立の待ち時間を最小化するために、実装はレスポンダの複数のアドレスに同じI1を送信することができます。しかし、それは並列で複数の3（3）のアドレスに送ってはいけません。また、タイムアウト時に、実装は複数のアドレスに同じI1パケットを送信控えなければなりません。つまり、タイムアウト後に接続を初期化するために再試行する場合、それは複数の宛先アドレスにI1パケットを送ってはいけません、です。アドレスの数百または数千を持っている誰かの主張は、イニシエータからI1メッセージの膨大な数を生成する可能性があるため、これらの制限は、例えば、ネットワークの混雑を避けるために置かれ、そして起こるかもしれない潜在的なDoS攻撃されています。"
    },
    {
      "indent": 3,
      "text": "As the Responder is not guaranteed to distinguish the duplicate I1s it receives at several of its addresses (because it avoids storing states when it answers back an R1), the Initiator may receive several duplicate R1s.",
      "ja": "レスポンダは、重複を区別するために保証されていないとして、それはそのアドレスのいくつかで受信I1s（それはR1をバックに答えるとき、それは保存状態を避けるため）、イニシエータは、いくつかの重複のR1を受けることができます。"
    },
    {
      "indent": 3,
      "text": "The Initiator SHOULD then select the initial preferred destination address using the source address of the selected received R1, and use the preferred address as a source address for the I2. Processing rules for received R1s are discussed in Section 6.8.",
      "ja": "イニシエータは、次に、選択された受信R1の送信元アドレスを使用して初期好適宛先アドレスを選択し、I2のソースアドレスとして好ましいアドレスを使用すべきです。受信のR1のための処理規則は6.8節で議論されています。"
    },
    {
      "indent": 0,
      "text": "6.6.2. Processing Incoming ICMP Protocol Unreachable Messages",
      "section_title": true,
      "ja": "6.6.2。着信ICMPプロトコル到達不能メッセージの処理"
    },
    {
      "indent": 3,
      "text": "A host may receive an ICMP 'Destination Protocol Unreachable' message as a response to sending a HIP I1 packet. Such a packet may be an indication that the peer does not support HIP, or it may be an attempt to launch an attack by making the Initiator believe that the Responder does not support HIP.",
      "ja": "ホストはHIPのI1パケットを送信に対する応答としてICMP「宛先プロトコル到達不能」というメッセージを受け取ることができます。このようなパケットは、ピアがHIPをサポートしていないことを示している可能性が、またはイニシエータがレスポンダは、HIPをサポートしていないと信じていることによって、攻撃を開始しようとする試みかもしれません。"
    },
    {
      "indent": 3,
      "text": "When a system receives an ICMP 'Destination Protocol Unreachable' message while it is waiting for an R1, it MUST NOT terminate the wait. It MAY continue as if it had not received the ICMP message, and send a few more I1s. Alternatively, it MAY take the ICMP message as a hint that the peer most probably does not support HIP, and return to state UNASSOCIATED earlier than otherwise. However, at minimum, it MUST continue waiting for an R1 for a reasonable time before returning to UNASSOCIATED.",
      "ja": "それはR1を待っている間に、システムがICMP「宛先プロトコル到達不能」メッセージを受信すると、それは待機を終了してはなりません。それはICMPメッセージを受け取っていないかのように継続し、さらにいくつかのI1sを送信することができます。また、それは、ピアがおそらくHIPをサポートしていないことをヒントとしてICMPメッセージをとることができ、および関連付けられていない以前のそれ以外よりも状態に戻ります。しかし、最低でも、それが関連付けられていないに戻る前に、合理的な時間のためにR1を待って継続する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.7. Processing Incoming I1 Packets",
      "section_title": true,
      "ja": "6.7。着信I1パケットを処理"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD reply to an I1 with an R1 packet, unless the implementation is unable or unwilling to set up a HIP association. If the implementation is unable to set up a HIP association, the host SHOULD send an ICMP Destination Protocol Unreachable, Administratively Prohibited, message to the I1 source address. If the implementation is unwilling to set up a HIP association, the host MAY ignore the I1. This latter case may occur during a DoS attack such as an I1 flood.",
      "ja": "実装はHIPの関連付けを設定することができない、または不本意でなければ実装は、R1パケットでI1に応答すべきです。実装はHIPの関連付けを設定することができない場合、ホストは、I1の送信元アドレスにICMP宛先到達不能プロトコル、管理上禁止、メッセージを送信する必要があります。実装はHIPの関連付けを設定することが不本意である場合、ホストは、I1を無視するかもしれません。この後者の場合は、I1の洪水などのDoS攻撃の間に起こり得ます。"
    },
    {
      "indent": 3,
      "text": "The implementation MUST be able to handle a storm of received I1 packets, discarding those with common content that arrive within a small time delta.",
      "ja": "実装は、短い時間内に到着デルタ共通のコンテンツを有するものを廃棄、受信I1パケットの嵐を扱うことができなければなりません。"
    },
    {
      "indent": 3,
      "text": "A spoofed I1 can result in an R1 attack on a system. An R1 sender MUST have a mechanism to rate-limit R1s to an address.",
      "ja": "偽装されたI1は、システム上のR1攻撃につながることができます。 R1の送信者がアドレスにレート制限のR1へのメカニズムを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the HIP state machine does not transition upon sending an R1.",
      "ja": "HIPステートマシンは、R1を送信するときに移行しないことが推奨されます。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for responding to an I1 packet:",
      "ja": "次の手順は、I1パケットに応答するための概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. The Responder MUST check that the Responder's HIT in the received I1 is either one of its own HITs or NULL.",
      "ja": "1. Responderは受け取っI1におけるレスポンダのHITは、自身のヒットまたはNULLのいずれか一つであることをチェックしなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If the Responder is in ESTABLISHED state, the Responder MAY respond to this with an R1 packet, prepare to drop existing SAs, and stay at ESTABLISHED state.",
      "ja": "2. ResponderがESTABLISHED状態にある場合、Responderは、R1パケットでこれに応え、既存のSAをドロップするための準備、および確立された状態で利用可能です。"
    },
    {
      "indent": 3,
      "text": "3. If the Responder is in I1-SENT state, it must make a comparison between the sender's HIT and its own (i.e., the receiver's) HIT. If the sender's HIT is greater than its own HIT, it should drop the I1 and stay at I1-SENT. If the sender's HIT is smaller than its own HIT, it should send R1 and stay at I1-SENT. The HIT comparison goes similarly as in Section 6.5.",
      "ja": "前記レスポンダは、I1-SENT状態にある場合は、送信者のHIT、自身（即ち、受信機の）HITとの比較を行わなければなりません。送信者のHITは独自のHITよりも大きい場合、それはI1をドロップし、I1-SENTに滞在する必要があります。送信者のHITは独自のHITよりも小さい場合、それはR1を送信し、I1-SENTに滞在する必要があります。 HITの比較は6.5節と同様になります。"
    },
    {
      "indent": 3,
      "text": "4. If the implementation chooses to respond to the I1 with an R1 packet, it creates a new R1 or selects a precomputed R1 according to the format described in Section 5.3.2.",
      "ja": "4.実装はR1パケットでI1に応答することを選択した場合、それは新しいR1を作成するか、セクション5.3.2で説明したフォーマットに従って予め計算R1を選択します。"
    },
    {
      "indent": 3,
      "text": "5. The R1 MUST contain the received Responder's HIT, unless the received HIT is NULL, in which case the Responder SHOULD select a HIT that is constructed with the MUST algorithm in Section 3, which is currently RSA. Other than that, selecting the HIT is a local policy matter.",
      "ja": "受信されたHITがNULLでない限り5. R1はレスポンダが現在RSAである第3のMUSTアルゴリズム、で構成されているHITを選択する必要があり、その場合には、受信したレスポンダのHITを含まなければなりません。それ以外は、HITを選択すると、ローカルポリシーの問題です。"
    },
    {
      "indent": 3,
      "text": "6. The Responder sends the R1 to the source IP address of the I1 packet.",
      "ja": "6. ResponderはI1パケットの送信元IPアドレスにR1を送信します。"
    },
    {
      "indent": 0,
      "text": "6.7.1. R1 Management",
      "section_title": true,
      "ja": "6.7.1。 R1管理"
    },
    {
      "indent": 3,
      "text": "All compliant implementations MUST produce R1 packets. An R1 packet MAY be precomputed. An R1 packet MAY be reused for time Delta T, which is implementation dependent, and SHOULD be deprecated and not used once a valid response I2 packet has been received from an Initiator. During an I1 message storm, an R1 packet may be re-used beyond this limit. R1 information MUST NOT be discarded until Delta S after T. Time S is the delay needed for the last I2 to arrive back to the Responder.",
      "ja": "すべての準拠した実装はR1パケットを生成しなければなりません。 R1パケットが事前に計算されるかもしれません。 R1パケットは実装に依存した時間デルタT、のために再利用することができる、と廃止されるべきで、イニシエータから一度有効な応答I2パケットを受信した使用されません。 I1メッセージ嵐の中、R1パケットがこの限界を超えて再使用することができます。 T.時間Sは、レスポンダに戻って到着する最後I2のために必要な遅延された後、R1情報は、デルタSまで捨ててはなりません。"
    },
    {
      "indent": 3,
      "text": "An implementation MAY keep state about received I1s and match the received I2s against the state, as discussed in Section 4.1.1.",
      "ja": "実装は受信I1sについての状態を維持し、4.1.1項で述べたように、状態に対して、受信したI2Sを一致させることができます。"
    },
    {
      "indent": 0,
      "text": "6.7.2. Handling Malformed Messages",
      "section_title": true,
      "ja": "6.7.2。不正な形式のメッセージの処理"
    },
    {
      "indent": 3,
      "text": "If an implementation receives a malformed I1 message, it SHOULD NOT respond with a NOTIFY message, as such practice could open up a potential denial-of-service danger. Instead, it MAY respond with an ICMP packet, as defined in Section 5.4.",
      "ja": "実装が不正な形式のI1メッセージを受信した場合、このような慣行は、潜在的なサービス拒否危険性を開く可能性があるので、それは、NOTIFYメッセージで応答すべきでありません。セクション5.4で定義されている代わりに、それは、ICMPパケットで応答することができます。"
    },
    {
      "indent": 0,
      "text": "6.8. Processing Incoming R1 Packets",
      "section_title": true,
      "ja": "6.8。着信R1パケットを処理"
    },
    {
      "indent": 3,
      "text": "A system receiving an R1 MUST first check to see if it has sent an I1 to the originator of the R1 (i.e., it is in state I1-SENT). If so, it SHOULD process the R1 as described below, send an I2, and go to state I2-SENT, setting a timer to protect the I2. If the system is in state I2-SENT, it MAY respond to an R1 if the R1 has a larger R1 generation counter; if so, it should drop its state due to processing the previous R1 and start over from state I1-SENT. If the system is in any other state with respect to that host, it SHOULD silently drop the R1.",
      "ja": "R1を受信するシステムは、最初に、R1（すなわち、それは状態I1-SENTである）の発信者にI1を送信したかどうかを確認しなければなりません。もしそうなら、それは、以下に説明するように、R1を処理I2を送信し、I2を保護するためにタイマーを設定し、状態I2-SENTに行く必要があります。システムが状態I2-SENTである場合、R1は大きくR1生成カウンタを有する場合、それはR1に応答することができます。もしそうなら、それが原因前R1の処理にその状態をド​​ロップし、状態I1-SENTからやり直すべきです。システムは、そのホストに対して任意の他の状態にある場合、それは静かにR1を削除すべきです。"
    },
    {
      "indent": 3,
      "text": "When sending multiple I1s, an Initiator SHOULD wait for a small amount of time after the first R1 reception to allow possibly multiple R1s to arrive, and it SHOULD respond to an R1 among the set with the largest R1 generation counter.",
      "ja": "複数I1sを送信するとき、イニシエータは、おそらく複数のR1が到達できるように最初のR1受信後の時間の少量のを待つ必要があり、それが最大R1生成カウンタとセット間R1に応答するべきです。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for responding to an R1 packet:",
      "ja": "次の手順は、R1パケットに応答するための概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. A system receiving an R1 MUST first check to see if it has sent an I1 to the originator of the R1 (i.e., it has a HIP association that is in state I1-SENT and that is associated with the HITs in the R1). Unless the I1 was sent in opportunistic mode (see Section 4.1.6), the IP addresses in the received R1 packet SHOULD be ignored and, when looking up the right HIP association, the received R1 SHOULD be matched against the associations using only the HITs. If a match exists, the system should process the R1 as described below.",
      "ja": "1. R1を受信するシステムは、最初に、R1の発信者にI1を送信したかどうかをチェックしなければならない（すなわち、それは状態I1-送られ、その中でHIPアソシエーションがR1でヒットに関連している持っています） 。 I1は、（セクション4.1.6を参照）日和見モードで送信された場合を除き、受信R1パケット内のIPアドレスは無視されるべきであると、右のHIPの関連付けを検索する場合、受信R1はヒットのみを使用して団体と照合されるべきである（SHOULD） 。一致が存在する場合、以下に記載されるように、システムは、R1を処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. Otherwise, if the system is in any other state than I1-SENT or I2-SENT with respect to the HITs included in the R1, it SHOULD silently drop the R1 and remain in the current state.",
      "ja": "システムは以外の状態にある場合2.そうでない場合には、I1-送信またはI2-SENTヒットに対しては、R1に含まれるが、それは静かにR1を削除し、現在の状態のままであるべきです。"
    },
    {
      "indent": 3,
      "text": "3. If the HIP association state is I1-SENT or I2-SENT, the received Initiator's HIT MUST correspond to the HIT used in the original, and the I1 and the Responder's HIT MUST correspond to the one used, unless the I1 contained a NULL HIT.",
      "ja": "3. HIP関連状態は、受信されたイニシエータのHITがオリジナルで使用HITに対応する必要があり、I1-送信またはI2-送られ、I1はNULLを含まない限り、I1とレスポンダのHITは、使用される1つに対応する必要がある場合ヒット。"
    },
    {
      "indent": 3,
      "text": "4. The system SHOULD validate the R1 signature before applying further packet processing, according to Section 5.2.12.",
      "ja": "前記システムは、セクション5.2.12によると、さらにパケット処理を適用する前に、R1の署名を検証すべきです。"
    },
    {
      "indent": 3,
      "text": "5. If the HIP association state is I1-SENT, and multiple valid R1s are present, the system SHOULD select from among the R1s with the largest R1 generation counter.",
      "ja": "5. HIP関連状態はI1-送信される場合、および複数の有効なのR1は、システムが最大R1世代カウンターでのR1の中から選択する必要があり、存在しています。"
    },
    {
      "indent": 3,
      "text": "6. If the HIP association state is I2-SENT, the system MAY reenter state I1-SENT and process the received R1 if it has a larger R1 generation counter than the R1 responded to previously.",
      "ja": "HIP関連状態はI2-送信される場合6は、それがR1より大きいR1生成カウンタを有する場合、受信しR1の状態I1-SENT再入力及び処理することができるシステムが以前に応答しました。"
    },
    {
      "indent": 3,
      "text": "7. The R1 packet may have the A bit set -- in this case, the system MAY choose to refuse it by dropping the R1 and returning to state UNASSOCIATED. The system SHOULD consider dropping the R1 only if it used a NULL HIT in I1. If the A bit is set, the Responder's HIT is anonymous and should not be stored.",
      "ja": "この場合には、システムはR1をドロップして関連付けられていない状態に戻ることによってそれを拒否することを選択するかもしれない -  7. R1パケットは、Aが設定ビットがあります。システムは、それがI1でNULLのHITを使用した場合にのみR1を落とすことを検討してください。 Aビットがセットされている場合は、レスポンダのHITは匿名で、保存すべきではありません。"
    },
    {
      "indent": 3,
      "text": "8. The system SHOULD attempt to validate the HIT against the received Host Identity by using the received Host Identity to construct a HIT and verify that it matches the Sender's HIT.",
      "ja": "8.システムは、HITを構築し、それが送信者のHITと一致することを確認するために、受信したホストのアイデンティティを使用して、受信したホストIDに対してHITを検証しようとすべきです。"
    },
    {
      "indent": 3,
      "text": "9. The system MUST store the received R1 generation counter for future reference.",
      "ja": "9.システムは、将来の参照のために受信されたR1世代カウンタを格納しなければなりません。"
    },
    {
      "indent": 3,
      "text": "10. The system attempts to solve the puzzle in R1. The system MUST terminate the search after exceeding the remaining lifetime of the puzzle. If the puzzle is not successfully solved, the implementation may either resend I1 within the retry bounds or abandon the HIP exchange.",
      "ja": "10.システムがR1でパズルを解くことを試みます。システムは、パズルの残りの寿命を超えた後、検索を終えなければなりません。パズルが正常に解決されない場合、実装は、リトライ範囲内I1を再送信するか、HIP交換を放棄することができるいずれか。"
    },
    {
      "indent": 3,
      "text": "11. The system computes standard Diffie-Hellman keying material according to the public value and Group ID provided in the DIFFIE_HELLMAN parameter. The Diffie-Hellman keying material Kij is used for key extraction as specified in Section 6.5. If the received Diffie-Hellman Group ID is not supported, the implementation may either resend I1 within the retry bounds or abandon the HIP exchange.",
      "ja": "11.システムがDIFFIE_HELLMANパラメータに設けられた公開値とグループIDに係る標準的なディフィー・ヘルマン鍵材料を算出します。セクション6.5で指定されたDiffie-Hellmanの鍵材料Kijを鍵抽出のために使用されます。受信されたディフィー・ヘルマングループIDがサポートされていない場合、実装は、リトライ範囲内I1を再送信するか、HIP交換を放棄することができるいずれか。"
    },
    {
      "indent": 3,
      "text": "12. The system selects the HIP transform from the choices presented in the R1 packet and uses the selected values subsequently when generating and using encryption keys, and when sending the I2. If the proposed alternatives are not acceptable to the system, it may either resend I1 within the retry bounds or abandon the HIP exchange.",
      "ja": "12.システムは、HIPはR1パケットに提示選択肢からの変換を選択し、暗号鍵を生成し、使用する場合、その後選択された値を使用し、I2を送信するとき。提案された代替システムに受け入れられない場合は、リトライ範囲内I1を再送信するか、HIP交換を放棄することができるいずれか。"
    },
    {
      "indent": 3,
      "text": "13. The system initializes the remaining variables in the associated state, including Update ID counters.",
      "ja": "13.システムは、更新IDカウンタを含む関連状態における残りの変数を初期化します。"
    },
    {
      "indent": 3,
      "text": "14. The system prepares and sends an I2, as described in Section 5.3.3.",
      "ja": "14.システムを準備し、セクション5.3.3に記載したように、I2を送信します。"
    },
    {
      "indent": 3,
      "text": "15. The system SHOULD start a timer whose timeout value should be larger than the worst-case anticipated RTT, and MUST increment a timeout counter associated with the I2. The sender SHOULD retransmit the I2 upon a timeout and restart the timer, up to a maximum of I2_RETRIES_MAX tries.",
      "ja": "15.システムは、そのタイムアウト値は、最悪の場合よりも大きくなければならないRTTを予想タイマーを起動する必要があり、及びI2に関連付けられたタイムアウトカウンタをインクリメントしなければなりません。送信者は、タイムアウト時にI2を再送し、タイマーを再起動し、I2_RETRIES_MAX試みるの最大までべきです。"
    },
    {
      "indent": 3,
      "text": "16. If the system is in state I1-SENT, it shall transition to state I2-SENT. If the system is in any other state, it remains in the current state.",
      "ja": "16.システムが状態I1-SENTである場合、それは状態I2-SENTに遷移しなければなりません。システムが他の状態にある場合、それは現在の状態のままになります。"
    },
    {
      "indent": 0,
      "text": "6.8.1. Handling Malformed Messages",
      "section_title": true,
      "ja": "6.8.1。不正な形式のメッセージの処理"
    },
    {
      "indent": 3,
      "text": "If an implementation receives a malformed R1 message, it MUST silently drop the packet. Sending a NOTIFY or ICMP would not help, as the sender of the R1 typically doesn't have any state. An implementation SHOULD wait for some more time for a possibly good R1, after which it MAY try again by sending a new I1 packet.",
      "ja": "実装が不正な形式のR1メッセージを受信した場合、それは静かにパケットを廃棄しなければなりません。 NOTIFYまたはICMPを送信すると、R1の送信者は、典型的には、任意の状態を持っていないと、役に立ちません。実装は、それが新しいI1パケットを送信することにより、再試行してください可能性がある後、おそらく良いR1のためのいくつかのより多くの時間を待つべき。"
    },
    {
      "indent": 0,
      "text": "6.9. Processing Incoming I2 Packets",
      "section_title": true,
      "ja": "6.9。着信I2パケットを処理"
    },
    {
      "indent": 3,
      "text": "Upon receipt of an I2, the system MAY perform initial checks to determine whether the I2 corresponds to a recent R1 that has been sent out, if the Responder keeps such state. For example, the sender could check whether the I2 is from an address or HIT that has recently received an R1 from it. The R1 may have had Opaque data included that was echoed back in the I2. If the I2 is considered to be suspect, it MAY be silently discarded by the system.",
      "ja": "I2を受信すると、システムは、I2は、レスポンダは、このような状態を維持する場合、送出された最近のR1に対応するかどうかを決定するために、初期チェックを実行してもよいです。例えば、送信者は、I2が、最近それからR1を受信したアドレスまたはHITからであるかどうかを確認できます。 R1は不透明なデータが戻っI2で反響したものが含ま持っていたかもしれません。 I2が疑わしいと見なされた場合、それは静かに、システムによって破棄されることがあります。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the HIP implementation SHOULD process the I2. This includes validation of the puzzle solution, generating the Diffie-Hellman key, decrypting the Initiator's Host Identity, verifying the signature, creating state, and finally sending an R2.",
      "ja": "それ以外の場合は、HIPの実装では、I2を処理しなければなりません。これは、のDiffie-Hellman鍵を生成イニシエータのホストIDを復号化、署名を検証し、状態を作成し、最終的にはR2を送信し、パズルソリューションの検証を含んでいます。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for responding to an I2 packet:",
      "ja": "次のステップは、I2パケットに応答するための概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. The system MAY perform checks to verify that the I2 corresponds to a recently sent R1. Such checks are implementation dependent. See Appendix A for a description of an example implementation.",
      "ja": "1.システムは、I2が最近送信されたR1に対応することを確認するためにチェックを行うことができます。このようなチェックは実装に依存しています。実装例については、付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "2. The system MUST check that the Responder's HIT corresponds to one of its own HITs.",
      "ja": "2.システムは、レスポンダのHITは、自身のヒットの一つに対応していることをチェックしなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. If the system's state machine is in the R2-SENT state, the system MAY check if the newly received I2 is similar to the one that triggered moving to R2-SENT. If so, it MAY retransmit a previously sent R2, reset the R2-SENT timer, and the state machine stays in R2-SENT.",
      "ja": "3.システムのステートマシンは、R2-SENT状態にある場合は、新たに受信したI2はR2-SENTに移動トリガされた1つに類似している場合、システムがチェックします。もしそうなら、それは、以前に送られたR2を再送R2-SENTタイマーをリセットし、ステートマシンは、R2-SENTにとどまるかもしれません。"
    },
    {
      "indent": 3,
      "text": "4. If the system's state machine is in the I2-SENT state, the system makes a comparison between its local and sender's HITs (similarly as in Section 6.5). If the local HIT is smaller than the sender's HIT, it should drop the I2 packet, use the peer Diffie-Hellman key and nonce I from the R1 packet received earlier, and get the local Diffie-Hellman key and nonce J from the I2 packet sent to the peer earlier. Otherwise, the system should process the received I2 packet and drop any previously derived Diffie-Hellman keying material Kij it might have formed upon sending the I2 previously. The peer Diffie-Hellman key and the nonce J are taken from the just arrived I2 packet. The local Diffie-Hellman key and the nonce I are the ones that were earlier sent in the R1 packet.",
      "ja": "4.システムの状態マシンはI2-SENT状態にある場合、システムは、ローカルと（同様に6.5節のように）送信者のヒットとを比較します。ローカルHITは、送信者のHITよりも小さい場合、それは先に受信R1パケットからピアのDiffie-HellmanキーとナンスIを使用し、I2パケットをドロップし、I2パケットからローカルのDiffie-HellmanキーとナンスJを取得する必要があります以前のピアに送信されました。そうしないと、システムは、受信I2パケットを処理し、Kijを、それが以前にI2を送信する際に形成されている可能性のある以前に得られたのDiffie-Hellmanの鍵材料をドロップする必要があります。ピアのDiffie-HellmanキーとナンスJはちょうど到着I2パケットから取得されます。地元のDiffie-Hellmanキーとナンスは、私は、以前のR1パケットで送信されたものです。"
    },
    {
      "indent": 3,
      "text": "5. If the system's state machine is in the I1-SENT state, and the HITs in the I2 match those used in the previously sent I1, the system uses this received I2 as the basis for the HIP association it was trying to form, and stops retransmitting I1 (provided that the I2 passes the below additional checks).",
      "ja": "システムの状態マシンはI1-SENT状態にあり、I2におけるヒットは、以前I1を送信に使用されるものと一致する場合5.システムは、これは、それが形成しようとしていたHIPアソシエーションのベースとしてI2を受け使用し、及びI1（I2は、以下の追加チェックを通過することを提供する）、再送を停止します。"
    },
    {
      "indent": 3,
      "text": "6. If the system's state machine is in any other state than R2- SENT, the system SHOULD check that the echoed R1 generation counter in I2 is within the acceptable range. Implementations MUST accept puzzles from the current generation and MAY accept puzzles from earlier generations. If the newly received I2 is outside the accepted range, the I2 is stale (perhaps replayed) and SHOULD be dropped.",
      "ja": "6.システムの状態マシンはR2-のSENT以外の状態にある場合、システムは、I2におけるエコーR1生成カウンタが許容範囲内であることを確認する必要があります。実装は、現在の世代からパズルを受け入れなければならないし、それ以前の世代からパズルを受け入れることができます。新たに受信したI2が許容範囲外である場合、I2は、（おそらく再生）陳腐であり、ドロップされるべきです。"
    },
    {
      "indent": 3,
      "text": "7. The system MUST validate the solution to the puzzle by computing the hash described in Section 5.3.3 using the same RHASH algorithm.",
      "ja": "7.システムは、同じRHASHアルゴリズムを使用して、セクション5.3.3に記載のハッシュを計算することによって、パズルの解決策を検証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "8. The I2 MUST have a single value in the HIP_TRANSFORM parameter, which MUST match one of the values offered to the Initiator in the R1 packet.",
      "ja": "8. I2は、R1パケット内のイニシエータに提供される値のいずれかと一致する必要がありHIP_TRANSFORMパラメータの単一の値を有していなければなりません。"
    },
    {
      "indent": 3,
      "text": "9. The system must derive Diffie-Hellman keying material Kij based on the public value and Group ID in the DIFFIE_HELLMAN parameter. This key is used to derive the HIP association keys, as described in Section 6.5. If the Diffie-Hellman Group ID is unsupported, the I2 packet is silently dropped.",
      "ja": "9.システムはDIFFIE_HELLMANパラメータの公開値とグループIDに基づいてのDiffie-Hellmanの鍵材料Kijをを導き出す必要があります。セクション6.5で説明したように、このキーは、HIP関連鍵を導出するために使用されます。 Diffie-HellmanのグループIDがサポートされていない場合、I2パケットは黙って落とされます。"
    },
    {
      "indent": 3,
      "text": "10. The encrypted HOST_ID is decrypted by the Initiator encryption key defined in Section 6.5. If the decrypted data is not a HOST_ID parameter, the I2 packet is silently dropped.",
      "ja": "10.暗号化HOST_IDは、6.5節で定義されたイニシエータの暗号化鍵で復号化されます。復号化されたデータは、HOST_IDパラメータでない場合は、I2パケットは黙って落とされます。"
    },
    {
      "indent": 3,
      "text": "11. The implementation SHOULD also verify that the Initiator's HIT in the I2 corresponds to the Host Identity sent in the I2. (Note: some middleboxes may not able to make this verification.)",
      "ja": "11.実装は、I2でイニシエータのHITはI2に送られたホストIDに対応していることを確認する必要があります。 （注：一部のミドルボックスは、この検証を行うこともできません。）"
    },
    {
      "indent": 3,
      "text": "12. The system MUST verify the HMAC according to the procedures in Section 5.2.9.",
      "ja": "12.システムは、セクション5.2.9の手順に従ってHMACを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "13. The system MUST verify the HIP_SIGNATURE according to Section 5.2.11 and Section 5.3.3.",
      "ja": "13.システムは、セクション5.2.11、セクション5.3.3に従ってHIP_SIGNATUREを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "14. If the checks above are valid, then the system proceeds with further I2 processing; otherwise, it discards the I2 and its state machine remains in the same state.",
      "ja": "14.上記のチェックが有効である場合、システムは、さらに、I2処理に進みます。それ以外の場合は、I2を破棄し、そのステートマシンは、同じ状態のままになります。"
    },
    {
      "indent": 3,
      "text": "15. The I2 packet may have the A bit set -- in this case, the system MAY choose to refuse it by dropping the I2 and the state machine returns to state UNASSOCIATED. If the A bit is set, the Initiator's HIT is anonymous and should not be stored.",
      "ja": "15. I2パケットは、Aビットが設定有していてもよい - この場合には、システムは、I2と状態マシンが関連付けられていない状態に戻るドロップすることによって、それを拒否することを選ぶかもしれ。 Aビットがセットされている場合、イニシエータのHITは匿名で、保存すべきではありません。"
    },
    {
      "indent": 3,
      "text": "16. The system initializes the remaining variables in the associated state, including Update ID counters.",
      "ja": "16.システムは、更新IDカウンタを含む関連状態における残りの変数を初期化します。"
    },
    {
      "indent": 3,
      "text": "17. Upon successful processing of an I2 when the system's state machine is in state UNASSOCIATED, I1-SENT, I2-SENT, or R2-SENT, an R2 is sent and the system's state machine transitions to state R2-SENT.",
      "ja": "システムの状態マシンが関連付けられていない状態であるI2の成功処理すると17が、I1-SENT、I2-SENT、またはR2が-SENT、R2が送信され、状態R2-SENTに、システムのステートマシン遷移されます。"
    },
    {
      "indent": 3,
      "text": "18. Upon successful processing of an I2 when the system's state machine is in state ESTABLISHED, the old HIP association is dropped and a new one is installed, an R2 is sent, and the system's state machine transitions to R2-SENT.",
      "ja": "システムの状態マシンが状態で確立されるとI2の成功処理すると18が、古いHIPの関連付けが削除され、新しいものがインストールされ、R2は、R2-SENTに送られ、システムのステートマシン遷移されます。"
    },
    {
      "indent": 3,
      "text": "19. Upon the system's state machine transitioning to R2-SENT, the system starts a timer. The state machine transitions to ESTABLISHED if some data has been received on the incoming HIP association, or an UPDATE packet has been received (or some other packet that indicates that the peer system's state machine has moved to ESTABLISHED). If the timer expires (allowing for maximal retransmissions of I2s), the state machine transitions to ESTABLISHED.",
      "ja": "R2-SENTに、システムのステート・マシンの移行時19は、システムはタイマーを開始します。一部のデータが入ってくるHIPアソシエーション上で受信された場合に設立され、又はUPDATEパケットを受信したステートマシン遷移（またはピアシステムの状態機械がESTABLISHEDに移動したことを示すいくつかの他のパケット）。タイマーが期限切れになった場合、ESTABLISHEDにステートマシンの遷移（I2Sの最大再送信を可能にします）。"
    },
    {
      "indent": 0,
      "text": "6.9.1. Handling Malformed Messages",
      "section_title": true,
      "ja": "6.9.1。不正な形式のメッセージの処理"
    },
    {
      "indent": 3,
      "text": "If an implementation receives a malformed I2 message, the behavior SHOULD depend on how many checks the message has already passed. If the puzzle solution in the message has already been checked, the implementation SHOULD report the error by responding with a NOTIFY packet. Otherwise, the implementation MAY respond with an ICMP message as defined in Section 5.4.",
      "ja": "実装が不正な形式のI2メッセージを受信した場合、動作はメッセージが既に経過しているどのように多くのチェックに依存する必要があります。メッセージ中のパズルのソリューションは、すでに確認されている場合、実装はNOTIFYパケットで応答することで、エラーを報告する必要があります。セクション5.4で定義されているそれ以外の場合、実装はICMPメッセージで応答することができます。"
    },
    {
      "indent": 0,
      "text": "6.10. Processing Incoming R2 Packets",
      "section_title": true,
      "ja": "6.10。着信R2パケットを処理"
    },
    {
      "indent": 3,
      "text": "An R2 received in states UNASSOCIATED, I1-SENT, or ESTABLISHED results in the R2 being dropped and the state machine staying in the same state. If an R2 is received in state I2-SENT, it SHOULD be processed.",
      "ja": "R2は、I1-SENT、会合していない状態で受信され、又はR2で確立結果が廃棄され、同じ状態に滞在状態機械。 R2が状態I2-SENTに受信された場合、それが処理されるべきです。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for an incoming R2 packet:",
      "ja": "次のステップは、着信R2パケットの概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. The system MUST verify that the HITs in use correspond to the HITs that were received in the R1.",
      "ja": "1.システムは、使用中のヒットがR1で受信されたヒットに対応することを確かめなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. The system MUST verify the HMAC_2 according to the procedures in Section 5.2.10.",
      "ja": "2.システムはセクション5.2.10の手順に従ってHMAC_2を確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. The system MUST verify the HIP signature according to the procedures in Section 5.2.11.",
      "ja": "3.システムはセクション5.2.11の手順に従ってHIP署名を検証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. If any of the checks above fail, there is a high probability of an ongoing man-in-the-middle or other security attack. The system SHOULD act accordingly, based on its local policy.",
      "ja": "4.上記のチェックのいずれか失敗した場合、現在進行中のman-in-the-middleまたは他のセキュリティ攻撃の可能性が高いです。システムは、ローカルポリシーに基づいて、それに従って行動しなければなりません。"
    },
    {
      "indent": 3,
      "text": "5. If the system is in any other state than I2-SENT, the R2 is silently dropped.",
      "ja": "5.システムは、I2-SENT以外の状態にある場合、R2は静かに滴下します。"
    },
    {
      "indent": 3,
      "text": "6. Upon successful processing of the R2, the state machine moves to state ESTABLISHED.",
      "ja": "R2の成功処理すると6は、ステートマシンは、確立された状態に移行します。"
    },
    {
      "indent": 0,
      "text": "6.11. Sending UPDATE Packets",
      "section_title": true,
      "ja": "6.11。 UPDATEパケットを送信します"
    },
    {
      "indent": 3,
      "text": "A host sends an UPDATE packet when it wants to update some information related to a HIP association. There are a number of likely situations, e.g., mobility management and rekeying of an existing ESP Security Association. The following paragraphs define the conceptual rules for sending an UPDATE packet to the peer. Additional steps can be defined in other documents where the UPDATE packet is used.",
      "ja": "ホストはHIP協会に関連するいくつかの情報を更新したいUPDATEパケットを送信します。例えばそうな状況の数、移動性管理および既存のESPセキュリティアソシエーションの再入力があります。以下の段落では、ピアに更新パケットを送信するための概念ルールを定義します。追加のステップは、UPDATEパケットが使用されている他のドキュメントで定義することができます。"
    },
    {
      "indent": 3,
      "text": "The system first determines whether there are any outstanding UPDATE messages that may conflict with the new UPDATE message under consideration. When multiple UPDATEs are outstanding (not yet acknowledged), the sender must assume that such UPDATEs may be processed in an arbitrary order. Therefore, any new UPDATEs that depend on a previous outstanding UPDATE being successfully received and acknowledged MUST be postponed until reception of the necessary ACK(s) occurs. One way to prevent any conflicts is to only allow one outstanding UPDATE at a time. However, allowing multiple UPDATEs may improve the performance of mobility and multihoming protocols.",
      "ja": "システムは、最初に、検討中の新しいUPDATEメッセージと競合する可能性のある優れたUPDATEメッセージがあるかどうかを決定します。複数の更新が（まだ認めていない）未処理である場合、送信者はそのような更新は、任意の順序で処理されてもよいことを想定しなければなりません。したがって、以前の未処理UPDATEに依存するすべての新しい更新が正常に受信され、必要に応じてACK（S）の受信が行われるまで延期されなければならない認めています。競合を防止するための一つの方法は、一度に1つの優れたUPDATEできるようにすることです。しかし、複数の更新を許可することは、モビリティとマルチホーミングプロトコルの性能を改善することができます。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for sending UPDATE packets.",
      "ja": "次の手順は、更新パケットを送信するための概念的な処理規則を定義します。"
    },
    {
      "indent": 3,
      "text": "1. The first UPDATE packet is sent with Update ID of zero. Otherwise, the system increments its own Update ID value by one before continuing the below steps.",
      "ja": "1.最初の更新パケットは、ゼロの更新IDと送信されます。そうしないと、システムは、以下の手順を続行する前に1によって、自身のアップデートID値をインクリメントします。"
    },
    {
      "indent": 3,
      "text": "2. The system creates an UPDATE packet that contains a SEQ parameter with the current value of Update ID. The UPDATE packet may also include an ACK of the peer's Update ID found in a received UPDATE SEQ parameter, if any.",
      "ja": "2.システムは、更新IDの電流値でSEQパラメータが含まれている更新パケットを作成します。アップデートパケットはまた、ピアの更新IDのACKを含むことがあれば、受信したUPDATE SEQパラメータに見出されます。"
    },
    {
      "indent": 3,
      "text": "3. The system sends the created UPDATE packet and starts an UPDATE timer. The default value for the timer is 2 * RTT estimate. If multiple UPDATEs are outstanding, multiple timers are in effect.",
      "ja": "3.システムが作成したUPDATEパケットを送信し、UPDATEタイマーを開始します。タイマーのデフォルト値は2 * RTTの推定値です。複数の更新が傑出している場合は、複数のタイマが有効になります。"
    },
    {
      "indent": 3,
      "text": "4. If the UPDATE timer expires, the UPDATE is resent. The UPDATE can be resent UPDATE_RETRY_MAX times. The UPDATE timer SHOULD be exponentially backed off for subsequent retransmissions. If no acknowledgment is received from the peer after UPDATE_RETRY_MAX times, the HIP association is considered to be broken and the state machine should move from state ESTABLISHED to state CLOSING as depicted in Section 4.4.3. The UPDATE timer is cancelled upon receiving an ACK from the peer that acknowledges receipt of the UPDATE.",
      "ja": "4. UPDATEタイマーが期限切れになった場合、UPDATEが再送信されます。 UPDATEはUPDATE_RETRY_MAX時間を再送することができます。 UPDATEタイマーは指数関数的に、その後の再送信のためにオフにバックアップする必要があります。肯定応答がUPDATE_RETRY_MAX時間後のピアから受信されない場合、HIPの関連付けが破損していると考えられる、セクション4.4.3に示すように、状態マシンは状態閉鎖するために設立された状態から移動しなければなりません。更新タイマは、UPDATEの受信を肯定応答するピアからのACKを受信すると解除されます。"
    },
    {
      "indent": 0,
      "text": "6.12. Receiving UPDATE Packets",
      "section_title": true,
      "ja": "6.12。 UPDATEパケットを受信"
    },
    {
      "indent": 3,
      "text": "When a system receives an UPDATE packet, its processing depends on the state of the HIP association and the presence and values of the SEQ and ACK parameters. Typically, an UPDATE message also carries optional parameters whose handling is defined in separate documents.",
      "ja": "システムは、更新パケットを受信した場合、その処理は、HIPアソシエーションとSEQとACKパラメータの存在及び値の状態に依存します。典型的には、UPDATEメッセージはまた、その取り扱い別の文書で定義されているオプションのパラメータを運びます。"
    },
    {
      "indent": 3,
      "text": "For each association, the peer's next expected in-sequence Update ID (\"peer Update ID\") is stored. Initially, this value is zero. Update ID comparisons of \"less than\" and \"greater than\" are performed with respect to a circular sequence number space.",
      "ja": "各アソシエーションのために、ピアの次の予想されるでシーケンス更新ID（「ピア更新ID」）が格納されています。最初は、この値はゼロです。円形のシーケンス番号空間に対して実行され、「より大きい」、「未満」のIDの比較を更新します。"
    },
    {
      "indent": 3,
      "text": "The sender may send multiple outstanding UPDATE messages. These messages are processed in the order in which they are received at the receiver (i.e., no resequencing is performed). When processing UPDATEs out-of-order, the receiver MUST keep track of which UPDATEs were previously processed, so that duplicates or retransmissions are ACKed and not reprocessed. A receiver MAY choose to define a receive window of Update IDs that it is willing to process at any given time, and discard received UPDATEs falling outside of that window.",
      "ja": "送信者は、複数の未処理のUPDATEメッセージを送信することができます。これらのメッセージは、それらが受信機で受信された順序で処理される（すなわち、全く再配列決定は行われません）。更新を処理するときにアウトオブオーダー、受信機は、更新が以前に複製または再送信がACKされるように、処理され、再処理されなかったを追跡しなければなりません。受信機は、任意の時点で処理する意思があることを更新IDの受信ウィンドウを定義するために選択し、そのウィンドウの外の受信した更新を捨てるかもしれ。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for receiving UPDATE packets.",
      "ja": "次の手順は、更新パケットを受信するための概念的な処理規則を定義します。"
    },
    {
      "indent": 3,
      "text": "1. If there is no corresponding HIP association, the implementation MAY reply with an ICMP Parameter Problem, as specified in Section 5.4.4.",
      "ja": "1.該当するHIPアソシエーションが存在しない場合、実装はセクション5.4.4で指定されるように、ICMPパラメータ問題に応答することができます。"
    },
    {
      "indent": 3,
      "text": "2. If the association is in the ESTABLISHED state and the SEQ (but not ACK) parameter is present, the UPDATE is processed and replied to as described in Section 6.12.1.",
      "ja": "アソシエーションがESTABLISHED状態とSEQ（ただしACK）パラメータが存在している場合2. UPDATEが処理され、セクション6.12.1に記載されているように返信されます。"
    },
    {
      "indent": 3,
      "text": "3. If the association is in the ESTABLISHED state and the ACK (but not SEQ) parameter is present, the UPDATE is processed as described in Section 6.12.2.",
      "ja": "3.アソシエーションが確立状態とACK（ただしSEQ）パラメータである場合、セクション6.12.2に記載されているようにUPDATEが処理され、存在しています。"
    },
    {
      "indent": 3,
      "text": "4. If the association is in the ESTABLISHED state and there is both an ACK and SEQ in the UPDATE, the ACK is first processed as described in Section 6.12.2, and then the rest of the UPDATE is processed as described in Section 6.12.1.",
      "ja": "前記アソシエーションがESTABLISHED状態にあり、ACKおよび配列の両方がアップデートである場合、セクション6.12.2に記載されているように、ACKが最初に処理され、そして、セクション6.12に記載されているように、更新の残りの部分が処理されます。 1。"
    },
    {
      "indent": 0,
      "text": "6.12.1. Handling a SEQ Parameter in a Received UPDATE Message",
      "section_title": true,
      "ja": "6.12.1。受信したUPDATEメッセージでSEQパラメータの処理"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for handling a SEQ parameter in a received UPDATE packet.",
      "ja": "次のステップは、受信された更新パケット内SEQパラメータを処理するための概念的な処理規則を定義します。"
    },
    {
      "indent": 3,
      "text": "1. If the Update ID in the received SEQ is not the next in the sequence of Update IDs and is greater than the receiver's window for new UPDATEs, the packet MUST be dropped.",
      "ja": "1.受け取った配列で更新IDは、更新IDの順序で次のものではなく、新しいアップデートを受信側のウィンドウよりも大きい場合、パケットは廃棄されなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If the Update ID in the received SEQ corresponds to an UPDATE that has recently been processed, the packet is treated as a retransmission. The HMAC verification (next step) MUST NOT be skipped. (A byte-by-byte comparison of the received and a stored packet would be OK, though.) It is recommended that a host cache UPDATE packets sent with ACKs to avoid the cost of generating a new ACK packet to respond to a replayed UPDATE. The system MUST acknowledge, again, such (apparent) UPDATE message retransmissions but SHOULD also consider rate-limiting such retransmission responses to guard against replay attacks.",
      "ja": "2.受信SEQで更新IDは最近のパケットを再送として処理され、処理された更新に対応する場合。 HMACの検証（次のステップ）をスキップしてはなりません。 （受信して格納されたパケットのバイト単位の比較とはいえ、OKになります。）これは、再生UPDATEに対応するため、新たなACKパケットを生成するコストを回避するためのACKを送信したホストキャッシュUPDATEパケットことをお勧めします。このシステムは、再び、そのような（見かけの）UPDATEメッセージの再送を確認する必要がありますが、また、リプレイ攻撃を防ぐための律速な再送応答を検討すべきです。"
    },
    {
      "indent": 3,
      "text": "3. The system MUST verify the HMAC in the UPDATE packet. If the verification fails, the packet MUST be dropped.",
      "ja": "3.システムがUPDATEパケットにHMACを確かめなければなりません。検証が失敗した場合、パケットは廃棄されなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. The system MAY verify the SIGNATURE in the UPDATE packet. If the verification fails, the packet SHOULD be dropped and an error message logged.",
      "ja": "4.システムはUPDATEパケット内の署名を検証することができます。検証が失敗した場合、パケットは廃棄されるべきであるとのエラーメッセージが記録されます。"
    },
    {
      "indent": 3,
      "text": "5. If a new SEQ parameter is being processed, the parameters in the UPDATE are then processed. The system MUST record the Update ID in the received SEQ parameter, for replay protection.",
      "ja": "5.新しいSEQパラメータが処理されている場合は、UPDATE内のパラメータが、その後に処理されます。システムは、再生保護のために、受け取ったSEQパラメータの更新IDを記録しなければなりません。"
    },
    {
      "indent": 3,
      "text": "6. An UPDATE acknowledgment packet with ACK parameter is prepared and sent to the peer. This ACK parameter may be included in a separate UPDATE or piggybacked in an UPDATE with SEQ parameter, as described in Section 5.3.5. The ACK parameter MAY acknowledge more than one of the peer's Update IDs.",
      "ja": "ACKパラメータ6. UPDATE確認パケットを調製し、ピアに送信されます。セクション5.3.5に記載したように、このACKパラメータは、別の更新プログラムに含まれる、またはSEQパラメータでUPDATEにピギーバックすることができます。 ACKパラメータは、ピアのアップデートIDの複数のを確認してもよいです。"
    },
    {
      "indent": 0,
      "text": "6.12.2. Handling an ACK Parameter in a Received UPDATE Packet",
      "section_title": true,
      "ja": "6.12.2。受信した更新パケット内のACKパラメータの処理"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for handling an ACK parameter in a received UPDATE packet.",
      "ja": "次のステップは、受信された更新パケット内のACKパラメータを処理するための概念的な処理規則を定義します。"
    },
    {
      "indent": 3,
      "text": "1. The sequence number reported in the ACK must match with an earlier sent UPDATE packet that has not already been acknowledged. If no match is found or if the ACK does not acknowledge a new UPDATE, the packet MUST either be dropped if no SEQ parameter is present, or the processing steps in Section 6.12.1 are followed.",
      "ja": "1. ACKで報告されたシーケンス番号がすでに確認されていない以前て送信さUPDATEパケットに一致している必要があります。一致が見つからない場合、またはACKが新しいUPDATEを認めていない場合、パケットはどちらか廃棄されなければならない場合は、配列のパラメータが存在しない、またはセクション6.12.1での処理工程が続いている場合。"
    },
    {
      "indent": 3,
      "text": "2. The system MUST verify the HMAC in the UPDATE packet. If the verification fails, the packet MUST be dropped.",
      "ja": "2.システムがUPDATEパケットにHMACを確かめなければなりません。検証が失敗した場合、パケットは廃棄されなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. The system MAY verify the SIGNATURE in the UPDATE packet. If the verification fails, the packet SHOULD be dropped and an error message logged.",
      "ja": "3.システムがUPDATEパケット内の署名を検証することができます。検証が失敗した場合、パケットは廃棄されるべきであるとのエラーメッセージが記録されます。"
    },
    {
      "indent": 3,
      "text": "4. The corresponding UPDATE timer is stopped (see Section 6.11) so that the now acknowledged UPDATE is no longer retransmitted. If multiple UPDATEs are newly acknowledged, multiple timers are stopped.",
      "ja": "今認めUPDATEはもはや再送さになるように4対応UPDATEタイマーは（6.11節を参照）が停止されていません。複数の更新が新たに確認される場合は、複数のタイマが停止されています。"
    },
    {
      "indent": 0,
      "text": "6.13. Processing NOTIFY Packets",
      "section_title": true,
      "ja": "6.13。 NOTIFYパケットの処理"
    },
    {
      "indent": 3,
      "text": "Processing NOTIFY packets is OPTIONAL. If processed, any errors in a received NOTIFICATION parameter SHOULD be logged. Received errors MUST be considered only as informational, and the receiver SHOULD NOT change its HIP state (Section 4.4.1) purely based on the received NOTIFY message.",
      "ja": "パケットをNOTIFY処理はオプションです。処理された場合は、受信した通知パラメータにエラーが記録されるべきです。受信エラーは情報提供のみと考えなければなりませんし、受信機は、純粋にNOTIFYメッセージを受信に基づいてHIP状態（4.4.1）を変更しないでください。"
    },
    {
      "indent": 0,
      "text": "6.14. Processing CLOSE Packets",
      "section_title": true,
      "ja": "6.14。 CLOSEパケットを処理"
    },
    {
      "indent": 3,
      "text": "When the host receives a CLOSE message, it responds with a CLOSE_ACK message and moves to CLOSED state. (The authenticity of the CLOSE message is verified using both HMAC and SIGNATURE). This processing applies whether or not the HIP association state is CLOSING in order to handle CLOSE messages from both ends that cross in flight.",
      "ja": "ホストは、CLOSEメッセージを受信すると、CLOSE_ACKメッセージで応答し、CLOSED状態に移行します。 （CLOSEメッセージの信憑性は、HMACと署名の両方を使用して検証されます）。この処理は、HIP関連状態が飛行中交差両端からCLOSEメッセージを処理するために閉じているか否かを適用します。"
    },
    {
      "indent": 3,
      "text": "The HIP association is not discarded before the host moves from the UNASSOCIATED state.",
      "ja": "HIPの関連付けが関連付けられていない状態からホストに移動する前に廃棄されていません。"
    },
    {
      "indent": 3,
      "text": "Once the closing process has started, any need to send data packets will trigger creating and establishing of a new HIP association, starting with sending an I1.",
      "ja": "クローズ処理が開始されると、データパケットを送信する必要が作成し、新しいHIP協会の設立、I1を送信することから始まるトリガされます。"
    },
    {
      "indent": 3,
      "text": "If there is no corresponding HIP association, the CLOSE packet is dropped.",
      "ja": "該当するHIPの関連付けがない場合は、CLOSEパケットはドロップされます。"
    },
    {
      "indent": 0,
      "text": "6.15. Processing CLOSE_ACK Packets",
      "section_title": true,
      "ja": "6.15。 CLOSE_ACKパケットを処理"
    },
    {
      "indent": 3,
      "text": "When a host receives a CLOSE_ACK message, it verifies that it is in CLOSING or CLOSED state and that the CLOSE_ACK was in response to the CLOSE (using the included ECHO_RESPONSE_SIGNED in response to the sent ECHO_REQUEST_SIGNED).",
      "ja": "ホストはCLOSE_ACKメッセージを受信すると、それは閉じたり閉じた状態にし、CLOSE_ACKは（送信ECHO_REQUEST_SIGNEDに対する応答に含まECHO_RESPONSE_SIGNEDを使用して）CLOSEに応答したことであることを検証します。"
    },
    {
      "indent": 3,
      "text": "The CLOSE_ACK uses HMAC and SIGNATURE for verification. The state is discarded when the state changes to UNASSOCIATED and, after that, the host MAY respond with an ICMP Parameter Problem to an incoming CLOSE message (see Section 5.4.4).",
      "ja": "CLOSE_ACKは、検証のためのHMACと署名を使用しています。状態が関連付けられていないにするときの状態変化を破棄され、その後、ホストは（5.4.4項を参照）、着信CLOSEメッセージにICMPパラメータ問題で応答することができます。"
    },
    {
      "indent": 0,
      "text": "6.16. Handling State Loss",
      "section_title": true,
      "ja": "6.16。国家の損失の取り扱い"
    },
    {
      "indent": 3,
      "text": "In the case of system crash and unanticipated state loss, the system SHOULD delete the corresponding HIP state, including the keying material. That is, the state SHOULD NOT be stored on stable storage. If the implementation does drop the state (as RECOMMENDED), it MUST also drop the peer's R1 generation counter value, unless a local policy explicitly defines that the value of that particular host is stored. An implementation MUST NOT store R1 generation counters by default, but storing R1 generation counter values, if done, MUST be configured by explicit HITs.",
      "ja": "システムクラッシュや予期しない状態の損失の場合には、システムは、キーイング材料を含む、対応するHIP状態を削除する必要があります。つまり、状態が安定したストレージに格納することはできません。実装は（推奨されるように）状態をドロップした場合、ローカルポリシーが明示的にその特定のホストの値が格納されていることを定義していない限り、それはまた、ピアのR1世代カウンタ値を削除する必要があります。実装は、デフォルトではR1生成カウンタを格納してはいけませんが、R1生成カウンタ値を格納し、行われた場合、明示的なヒットで構成しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. HIP Policies",
      "section_title": true,
      "ja": "7. HIPポリシー"
    },
    {
      "indent": 3,
      "text": "There are a number of variables that will influence the HIP exchanges that each host must support. All HIP implementations MUST support more than one simultaneous HI, at least one of which SHOULD be reserved for anonymous usage. Although anonymous HIs will be rarely used as Responders' HIs, they will be common for Initiators. Support for more than two HIs is RECOMMENDED.",
      "ja": "各ホストがサポートしなければならないHIP交換に影響を与える変数の数があります。すべてのHIP実装は、複数の同時HI、匿名の使用のために確保すべきで少なくとも一つをサポートしなければなりません。匿名ものの、彼はめったにレスポンダとして使用されることはありません彼の、彼らは、イニシエータの共通となります。二つ以上の彼のサポートが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Many Initiators would want to use a different HI for different Responders. The implementations SHOULD provide for an ACL of Initiator's HIT to Responder's HIT. This ACL SHOULD also include preferred transform and local lifetimes.",
      "ja": "多くのイニシエータは異なるレスポンダに異なるHIを使用したいと思います。実装はレスポンダのHITにイニシエータのHITのACLを提供すべきです。このACLはまた、寿命を変換し、地元の好適含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The value of K used in the HIP R1 packet can also vary by policy. K should never be greater than 20, but for trusted partners it could be as low as 0.",
      "ja": "HIP R1パケットに使用されるKの値は、ポリシーによって変化することができます。 Kは20より大きくなることはありませんが、信頼できるパートナーのためには、0と同じくらい低いかもしれません。"
    },
    {
      "indent": 3,
      "text": "Responders would need a similar ACL, representing which hosts they accept HIP exchanges, and the preferred transform and local lifetimes. Wildcarding SHOULD be supported for this ACL also.",
      "ja": "レスポンダは、彼らがHIP交換、及び好ましい変換し、地元の寿命を受け入れるホストを表す、同様のACLが必要になります。ワイルドカードはまた、このACLのためにサポートされる必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "HIP is designed to provide secure authentication of hosts. HIP also attempts to limit the exposure of the host to various denial-of-service and man-in-the-middle (MitM) attacks. In so doing, HIP itself is subject to its own DoS and MitM attacks that potentially could be more damaging to a host's ability to conduct business as usual.",
      "ja": "HIPは、ホストの安全な認証を提供するように設計されています。 HIPは、様々なサービス拒否とMITM（中間者）攻撃に対する宿主の曝露を制限しようとします。そうすることで、HIP自体が潜在的に通常通り業務を遂行するために、ホストの能力によりダメージを与える可能性があり、独自のDoSとのMitM攻撃の対象となります。"
    },
    {
      "indent": 3,
      "text": "The 384-bit Diffie-Hellman Group is targeted to be used in hosts that either do not require or are not powerful enough for handling strong cryptography. Although there is a risk that with suitable equipment the encryption can be broken in real time, the 384-bit group can provide some protection for end-hosts that are not able to handle any stronger cryptography. When the security provided by the 384-bit group is not enough for applications on a host, the support for this group should be turned off in the configuration.",
      "ja": "384ビットのDiffie-Hellmanのグループでは、どちらかが必要ではないか、強力な暗号化を処理するために十分に強力ではありませんないホストで使用されることを目標としています。適当な装置で暗号化をリアルタイムに分けることができないリスクがありますが、384ビットのグループは、任意のより強力な暗号化を処理することができませんエンドホストのためのいくつかの保護を提供することができます。 384ビットのグループによって提供されるセキュリティは、ホスト上のアプリケーションのために十分でない場合は、このグループのサポートは設定でオフにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Denial-of-service attacks often take advantage of the cost of start of state for a protocol on the Responder compared to the 'cheapness' on the Initiator. HIP makes no attempt to increase the cost of the start of state on the Initiator, but makes an effort to reduce the cost to the Responder. This is done by having the Responder start the 3-way exchange instead of the Initiator, making the HIP protocol 4 packets long. In doing this, packet 2 becomes a 'stock' packet that the Responder MAY use many times, until some Initiator has provided a valid response to such an R1 packet. During an I1 storm, the host may reuse the same D-H value also even if some Initiator has provided a valid response using that particular D-H value. However, such behavior is discouraged and should be avoided. Using the same Diffie-Hellman values and random puzzle #I value has some risks. This risk needs to be balanced against a potential storm of HIP I1 packets.",
      "ja": "DoS攻撃は、多くの場合、イニシエータの「安っぽさ」に比べレスポンダ上のプロトコルの状態の開始のコストを活用します。 HIPは、イニシエータ上の状態の開始のコストを増加させる試みませんが、レスポンダへのコストを削減する努力をします。これは、レスポンダはなく、開始剤の3ウェイ交換を開始有する4つのパケット長HIPプロトコルを作成することによって行われます。これを行うには、パケット2は、いくつかのイニシエータは、R1パケットに有効な応答を提供するまでResponderが、何回も使用するかもしれ「株式」のパケットになります。 I1の嵐の間、ホストは、いくつかのイニシエータがその特定のD-Hの値を使用して、有効な応答を提供した場合でも、同じD-Hの値を再利用してもよいです。しかし、そのような行動は推奨されており、避けるべきです。同じのDiffie-Hellman値とランダムパズル#I値を使用すると、いくつかのリスクがあります。このリスクはHIPのI1パケットの潜在的な嵐とのバランスする必要があります。"
    },
    {
      "indent": 3,
      "text": "This shifting of the start of state cost to the Initiator in creating the I2 HIP packet, presents another DoS attack. The attacker spoofs the I1 HIP packet and the Responder sends out the R1 HIP packet. This could conceivably tie up the 'Initiator' with evaluating the R1 HIP packet, and creating the I2 HIP packet. The defense against this attack is to simply ignore any R1 packet where a corresponding I1 was not sent.",
      "ja": "I2のHIPパケットを作成するためのイニシエータへの状態コストの開始のこのシフトは、別のDoS攻撃を提示します。攻撃者は、I1のHIPパケットを偽装し、ResponderはR1のHIPパケットを送信します。これはおそらく、R1のHIPパケットを評価し、そしてI2のHIPパケットを作成して「イニシエータ」をタイアップができます。この攻撃に対する防御は、単に対応するI1が送信されなかった任意のR1パケットを無視することです。"
    },
    {
      "indent": 3,
      "text": "A second form of DoS attack arrives in the I2 HIP packet. Once the attacking Initiator has solved the puzzle, it can send packets with spoofed IP source addresses with either an invalid encrypted HIP payload component or a bad HIP signature. This would take resources in the Responder's part to reach the point to discover that the I2 packet cannot be completely processed. The defense against this attack is after N bad I2 packets, the Responder would discard any I2s that contain the given Initiator HIT. This will shut down the attack. The attacker would have to request another R1 and use that to launch a new attack. The Responder could up the value of K while under attack. On the downside, valid I2s might get dropped too.",
      "ja": "DoS攻撃の2番目の形式はI2のHIPパケットに到着します。攻撃イニシエータは、パズルを解いていたら、それは無効な暗号化されたHIPペイロードコンポーネントまたは悪いHIP署名のいずれかと偽装されたIP送信元アドレスを持つパケットを送信することができます。これは、I2パケットが完全に処理できないことを発見するためのポイントに到達するためにレスポンダの一部のリソースを取るだろう。この攻撃に対する防御は、Responderが与えられたイニシエータHITを含むすべてのI2Sを捨てるだろう、N悪いI2パケットの後です。これは、攻撃をシャットダウンします。攻撃者は、別のR1を要求し、新しい攻撃を開始するためにそれを使用する必要があります。 Responderは攻撃を受けながら、Kの値をアップできました。下がり気味で、有効なI2Sはあまりにも廃棄されることがあります。"
    },
    {
      "indent": 3,
      "text": "A third form of DoS attack is emulating the restart of state after a reboot of one of the partners. A restarting host would send an I1 to a peer, which would respond with an R1 even if it were in the ESTABLISHED state. If the I1 were spoofed, the resulting R1 would be received unexpectedly by the spoofed host and would be dropped, as in the first case above.",
      "ja": "DoS攻撃の三番目の形式は、パートナーの1の再起動後に状態の再起動をエミュレートしています。再起動するホストは、それがESTABLISHED状態にあった場合でも、R1で応答するピアにI1を送信します。 I1を偽装した場合、得られたR1は、スプーフィングされたホストが予期せずに受信されると、上記第一の場合のように、ドロップされることになります。"
    },
    {
      "indent": 3,
      "text": "A fourth form of DoS attack is emulating the end of state. HIP relies on timers plus a CLOSE/CLOSE_ACK handshake to explicitly signal the end of a HIP association. Because both CLOSE and CLOSE_ACK messages contain an HMAC, an outsider cannot close a connection. The presence of an additional SIGNATURE allows middleboxes to inspect these messages and discard the associated state (for e.g., firewalling, SPI-based NATing, etc.). However, the optional behavior of replying to CLOSE with an ICMP Parameter Problem packet (as described in Section 5.4.4) might allow an IP spoofer sending CLOSE messages to launch reflection attacks.",
      "ja": "DoS攻撃の第四の形態は、状態の終了をエミュレートしています。 HIPは、明示的にHIP協会の終わりを知らせるためにタイマープラスCLOSE / CLOSE_ACKハンドシェイクに依存しています。 CLOSEとCLOSE_ACKメッセージの両方がHMACを含んでいるので、部外者には、接続を閉じることができません。追加SIGNATUREの存在は、中間装置は、これらのメッセージを検査し、関連する状態（例えば、ファイアウォールのために、SPIベースのNAT変換、等）を破棄することを可能にします。しかし、（セクション5.4.4で説明したように）ICMPパラメータ問題パケットと密接に返信のオプションの動作は、反射攻撃を開始するためにCLOSEメッセージを送信したIPスプーフィングを許可するかもしれません。"
    },
    {
      "indent": 3,
      "text": "A fifth form of DoS attack is replaying R1s to cause the Initiator to solve stale puzzles and become out of synchronization with the Responder. The R1 generation counter is a monotonically increasing counter designed to protect against this attack, as described in Section 4.1.4.",
      "ja": "DoS攻撃の第五の形式は、古いパズルを解くとレスポンダとの同期外れになるためのイニシエータを引き起こすのR1を再生されます。 R1生成カウンタは、第4.1.4項で説明したように、この攻撃から保護するために設計された単調に増加するカウンタです。"
    },
    {
      "indent": 3,
      "text": "Man-in-the-middle attacks are difficult to defend against, without third-party authentication. A skillful MitM could easily handle all parts of HIP, but HIP indirectly provides the following protection from a MitM attack. If the Responder's HI is retrieved from a signed DNS zone, a certificate, or through some other secure means, the Initiator can use this to validate the R1 HIP packet.",
      "ja": "man-in-the-middle攻撃は、サードパーティの認証なし、防御することは困難です。熟練のMitMは簡単HIPのすべての部分を扱うことができますが、HIPは、間接的にのMITM攻撃から、次の保護を提供します。レスポンダのHIが署名DNSゾーン、証明書から取得された場合、またはいくつかの他の安全な手段を通じて、イニシエータは、R1のHIPパケットを検証するためにこれを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Likewise, if the Initiator's HI is in a secure DNS zone, a trusted certificate, or otherwise securely available, the Responder can retrieve the HI (after having got the I2 HIP packet) and verify that the HI indeed can be trusted. However, since an Initiator may choose to use an anonymous HI, it knowingly risks a MitM attack. The Responder may choose not to accept a HIP exchange with an anonymous Initiator.",
      "ja": "イニシエータのHIは、セキュアなDNSゾーン、信頼できる証明書、またはその他の安全利用可能である場合には同様に、Responderは（I2のHIPパケットを得た後）HIを取得し、HIが実際に信頼することができることを確認することができます。しかし、イニシエータは、匿名のHIを使用することを選択するかもしれないので、それは故意のMITM攻撃をリスク。 Responderは匿名のイニシエータとのHIP交換を受け入れるしないこともできます。"
    },
    {
      "indent": 3,
      "text": "The HIP Opportunistic Mode concept has been introduced in this document, but this document does not specify what the semantics of such a connection setup are for applications. There are certain concerns with opportunistic mode, as discussed in Section 4.1.6.",
      "ja": "HIP日和見モードの概念が、本書で紹介されていますが、この文書では、このような接続設定のセマンティクスはアプリケーションのためのものであるかを指定しません。セクション4.1.6で説明したように日和見モードで特定の懸念があります。"
    },
    {
      "indent": 3,
      "text": "NOTIFY messages are used only for informational purposes and they are unacknowledged. A HIP implementation cannot rely solely on the information received in a NOTIFY message because the packet may have been replayed. It SHOULD NOT change any state information based purely on a received NOTIFY message.",
      "ja": "NOTIFYメッセージは情報提供のみを目的として使用されていると、彼らは未確認です。パケットが再生されている可能性があるため、HIPの実装では、NOTIFYメッセージで受信した情報のみに依存することはできません。これは、NOTIFYメッセージを受け取っに純粋に基づいて、すべての状態情報を変更するべきではありません。"
    },
    {
      "indent": 3,
      "text": "Since not all hosts will ever support HIP, ICMP 'Destination Protocol Unreachable' messages are to be expected and present a DoS attack. Against an Initiator, the attack would look like the Responder does not support HIP, but shortly after receiving the ICMP message, the Initiator would receive a valid R1 HIP packet. Thus, to protect from this attack, an Initiator should not react to an ICMP message until a reasonable delta time to get the real Responder's R1 HIP packet. A similar attack against the Responder is more involved. Normally, if an I1 message received by a Responder was a bogus one sent by an attacker, the Responder may receive an ICMP message from the IP address the R1 message was sent to. However, a sophisticated attacker can try to take advantage of such a behavior and try to break up the HIP exchange by sending such an ICMP message to the Responder before the Initiator has a chance to send a valid I2 message. Hence, the Responder SHOULD NOT act on such an ICMP message. Especially, it SHOULD NOT remove any minimal state created when it sent the R1 HIP packet (if it did create one), but wait for either a valid I2 HIP packet or the natural timeout (that is, if R1 packets are tracked at all). Likewise, the Initiator should ignore any ICMP message while waiting for an R2 HIP packet, and should delete any pending state only after a natural timeout.",
      "ja": "いないすべてのホストがこれまでにHIPをサポートしていますので、ICMP「宛先プロトコル到達不能」メッセージが期待されるとDoS攻撃を提示すべきです。イニシエータに対して、攻撃はHIPをサポートしていないレスポンダのように見えるだろうが、すぐにICMPメッセージを受信した後、イニシエータは、有効なR1のHIPパケットを受け取ることになります。したがって、この攻撃から保護するために、イニシエータは、実際のレスポンダのR1のHIPパケットを取得するには、合理的なデルタ時間まで、ICMPメッセージに反応してはなりません。レスポンダに対する同様の攻撃はより複雑です。レスポンダによって受信I1メッセージが攻撃者によって送信された偽のものであった場合、通常、レスポンダは、R1のメッセージが送られたIPアドレスからのICMPメッセージを受信することができます。しかし、洗練された攻撃者は、このような行動を利用しようとすると、イニシエータが有効なI2メッセージを送信する機会を得る前にレスポンダに、このようなICMPメッセージを送信することにより、HIP交換を分割しようとすることができます。したがって、Responderは、このようなICMPメッセージに基づいて行動すべきではありません。特に、それは（それが1を作成しなかった場合）、それはR1のHIPパケットを送信したときに作成された最小限の状態を削除しますが、有効なI2のHIPパケットまたは自然のタイムアウトのいずれかを待つべきではありません（R1パケットがすべてで追跡している場合には、あります） 。同様に、イニシエータは、R2のHIPパケットを待っている間に任意のICMPメッセージを無視すべきである、とだけ自然のタイムアウトの後、保留中の状態を削除する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has reserved protocol number 139 for the Host Identity Protocol.",
      "ja": "IANAは、ホスト識別プロトコルのためのプロトコル番号139を予約しました。"
    },
    {
      "indent": 3,
      "text": "This document defines a new 128-bit value under the CGA Message Type namespace [RFC3972], 0xF0EF F02F BFF4 3D0F E793 0C3C 6E61 74EA, to be used for HIT generation as specified in ORCHID [RFC4843].",
      "ja": "ORCHID [RFC4843]で指定されるように、このドキュメントは、0xF0EF F02F BFF4 3D0F E793 0C3C 6E61 74EAは、HITの生成に使用されるCGAメッセージタイプネームスペース[RFC3972]の下に新たな128ビットの値を定義します。"
    },
    {
      "indent": 3,
      "text": "This document also creates a set of new namespaces. These are described below.",
      "ja": "この文書は、新しい名前空間のセットを作成します。これらは、以下に記載されています。"
    },
    {
      "indent": 3,
      "text": "Packet Type",
      "ja": "パケットタイプ"
    },
    {
      "indent": 6,
      "text": "The 7-bit Packet Type field in a HIP protocol packet describes the type of a HIP protocol message. It is defined in Section 5.1. The current values are defined in Sections 5.3.1 through 5.3.8.",
      "ja": "7ビットのパケットタイプフィールドHIPプロトコルパケットでHIPプロトコルメッセージのタイプを記述する。これは、セクション5.1で定義されています。電流値は、5.3.8を介してセクション5.3.1で定義されています。"
    },
    {
      "indent": 6,
      "text": "New values are assigned through IETF Consensus [RFC2434].",
      "ja": "新しい値は、IETFコンセンサス[RFC2434]によって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "HIP Version",
      "ja": "HIPバージョン"
    },
    {
      "indent": 6,
      "text": "The four-bit Version field in a HIP protocol packet describes the version of the HIP protocol. It is defined in Section 5.1. The only currently defined value is 1. New values are assigned through IETF Consensus.",
      "ja": "HIPプロトコルパケットの4ビットのバージョンフィールドは、HIPプロトコルのバージョンを記述する。これは、セクション5.1で定義されています。唯一の現在定義された値は1.新規の値はIETFの合意によって割り当てられています。"
    },
    {
      "indent": 3,
      "text": "Parameter Type",
      "ja": "パラメータタイプ"
    },
    {
      "indent": 6,
      "text": "The 16-bit Type field in a HIP parameter describes the type of the parameter. It is defined in Section 5.2.1. The current values are defined in Sections 5.2.3 through 5.2.20.",
      "ja": "HIPパラメータの16ビットのタイプフィールドは、パラメータのタイプを記述する。これは、5.2.1項で定義されています。電流値は、5.2.20を介してセクション5.2.3で定義されています。"
    },
    {
      "indent": 6,
      "text": "With the exception of the assigned Type codes, the Type codes 0 through 1023 and 61440 through 65535 are reserved for future base protocol extensions, and are assigned through IETF Consensus.",
      "ja": "割り当てられたタイプコードを除いて、〜65535 1023 61440スルータイプコード0は、将来のベースプロトコル拡張のために予約されており、IETFコンセンサスを通して割り当てられています。"
    },
    {
      "indent": 6,
      "text": "The Type codes 32768 through 49141 are reserved for experimentation. Types SHOULD be selected in a random fashion from this range, thereby reducing the probability of collisions. A method employing genuine randomness (such as flipping a coin) SHOULD be used.",
      "ja": "32768 49141スルー型コードは、実験のために予約されています。タイプは、それによって衝突の確率を減少させる、この範囲からランダムに選択されるべきです。 （そのようなコインを反転など）真正乱数を用いた方法が使用されるべきです。"
    },
    {
      "indent": 6,
      "text": "All other Type codes are assigned through First Come First Served, with Specification Required [RFC2434].",
      "ja": "他のすべてのタイプのコードはまず仕様が必要である[RFC2434]で、添え是非まずを通じて割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Group ID",
      "ja": "グループID"
    },
    {
      "indent": 6,
      "text": "The eight-bit Group ID values appear in the DIFFIE_HELLMAN parameter and are defined in Section 5.2.6. New values either from the reserved or unassigned space are assigned through IETF Consensus.",
      "ja": "8ビットのグループID値はDIFFIE_HELLMANパラメータに表示され、セクション5.2.6で定義されています。予約済みまたは未割り当て領域からいずれかの新しい値は、IETFの合意によって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Suite ID",
      "ja": "スイートID"
    },
    {
      "indent": 6,
      "text": "The 16-bit Suite ID values in a HIP_TRANSFORM parameter are defined in Section 5.2.7. New values either from the reserved or unassigned space are assigned through IETF Consensus.",
      "ja": "HIP_TRANSFORMパラメータの16ビットスイートID値はセクション5.2.7で定義されています。予約済みまたは未割り当て領域からいずれかの新しい値は、IETFの合意によって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "DI-Type",
      "ja": "OF-タイプ"
    },
    {
      "indent": 6,
      "text": "The four-bit DI-Type values in a HOST_ID parameter are defined in Section 5.2.8. New values are assigned through IETF Consensus.",
      "ja": "HOST_IDパラメータの4ビットDI-Type値はセクション5.2.8で定義されています。新しい値は、IETFの合意によって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Notify Message Type",
      "ja": "メッセージタイプを通知します"
    },
    {
      "indent": 6,
      "text": "The 16-bit Notify Message Type values in a NOTIFICATION parameter are defined in Section 5.2.16.",
      "ja": "通知パラメータの16ビットNOTIFYメッセージ・タイプ値は、セクション5.2.16で定義されています。"
    },
    {
      "indent": 6,
      "text": "Notify Message Type values 1-10 are used for informing about errors in packet structures, values 11-20 for informing about problems in parameters containing cryptographic related material, values 21-30 for informing about problems in authentication or packet integrity verification. Parameter numbers above 30 can be used for informing about other types of errors or events. Values 51-8191 are error types reserved to be allocated by IANA. Values 8192-16383 are error types for experimentation. Values 16385- 40959 are status types to be allocated by IANA, and values 40960- 65535 are status types for experimentation. New values in ranges 51-8191 and 16385-40959 are assigned through First Come First Served, with Specification Required.",
      "ja": "通知メッセージタイプは、1〜10がパケット構造のエラーを知らせるために使用される値の暗号化関連物質を含むパラメータの問題について知らせるための11-20値、認証やパケットの完全性の検証で問題を知らせるために21-30値。 30以上のパラメータ番号はエラーまたは他のタイプのイベントについて通知するために使用することができます。値51から8191には、IANAによって割り当てられるために予約エラータイプです。値は8192から16383は、実験のためのエラータイプです。値16385- 40959は、IANAによって割り当てられるステータスタイプであり、40960- 65535値は、実験のためのステータスタイプです。範囲51から8191と16385から40959の新しい値は、まずを通じて割り当てられている第仕様が必要で、添え来ます。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgments",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "The drive to create HIP came to being after attending the MALLOC meeting at the 43rd IETF meeting. Baiju Patel and Hilarie Orman really gave the original author, Bob Moskowitz, the assist to get HIP beyond 5 paragraphs of ideas. It has matured considerably since the early versions thanks to extensive input from IETFers. Most importantly, its design goals are articulated and are different from other efforts in this direction. Particular mention goes to the members of the NameSpace Research Group of the IRTF. Noel Chiappa provided valuable input at early stages of discussions about identifier handling and Keith Moore the impetus to provide resolvability. Steve Deering provided encouragement to keep working, as a solid proposal can act as a proof of ideas for a research group.",
      "ja": "HIPを作成するには、ドライブが第43回IETF会合でMALLOC会議に出席した後であることになりました。 Baijuパテルとヒラリーオーマンは本当に原作者、ボブ・モスコウィッツ、アイデアの5つの段落を超えてHIPを取得するために支援を与えました。これは、初期バージョン以来かなりIETFersから広範囲の入力のおかげで成熟しています。最も重要なのは、その設計目標は、多関節と、この方向で他の努力とは異なりますされています。特に言及はIRTFのネームスペース研究グループのメンバーになります。クリスマスChiappaは、識別子の取り扱いとキース・ムーア解像性を提供するために、弾み議論の早い段階での貴重な入力を提供します。スティーブデアリングは、固体の提案は研究グループのためのアイデアの証明として機能することができて、作業を続けるために励ましを提供します。"
    },
    {
      "indent": 3,
      "text": "Many others contributed; extensive security tips were provided by Steve Bellovin. Rob Austein kept the DNS parts on track. Paul Kocher taught Bob Moskowitz how to make the puzzle exchange expensive for the Initiator to respond, but easy for the Responder to validate. Bill Sommerfeld supplied the Birthday concept, which later evolved into the R1 generation counter, to simplify reboot management. Erik Nordmark supplied the CLOSE-mechanism for closing connections. Rodney Thayer and Hugh Daniels provided extensive feedback. In the early times of this document, John Gilmore kept Bob Moskowitz challenged to provide something of value.",
      "ja": "多くの他の人が貢献しました。広範なセキュリティのヒントは、スティーブBellovin氏によって提供されました。ロブAusteinとは、トラック上のDNS部品を保ちました。ポール・コッフェルはパズルの交換がイニシエータが応答するために高価な、しかし検証するResponderのための簡単な作り方をボブ・モスコウィッツを教えました。ビル・ゾンマーフェルトは、後で再起動管理を簡素化するために、R1世代カウンタに進化誕生日概念を、供給されました。エリックNordmarkとは、接続を閉じるためのCLOSE-メカニズムを提供しました。ロドニーセイヤーとヒュー・ダニエルズは、広範なフィードバックを提供しました。このドキュメントの初期の時代には、ジョン・ギルモアは、ボブ・モスコウィッツは、価値のあるものを提供するために挑戦し続けました。"
    },
    {
      "indent": 3,
      "text": "During the later stages of this document, when the editing baton was transferred to Pekka Nikander, the input from the early implementors was invaluable. Without having actual implementations, this document would not be on the level it is now.",
      "ja": "編集バトンがペッカNikanderに移したときに、このドキュメントの後の段階で、早期の実装者からの入力は非常に貴重でした。実際の実装を持たずに、この文書は、それが今のレベルにはならないでしょう。"
    },
    {
      "indent": 3,
      "text": "In the usual IETF fashion, a large number of people have contributed to the actual text or ideas. The list of these people include Jeff Ahrenholz, Francis Dupont, Derek Fawcus, George Gross, Andrew McGregor, Julien Laganier, Miika Komu, Mika Kousa, Jan Melen, Henrik Petander, Michael Richardson, Tim Shepard, Jorma Wall, and Jukka Ylitalo. Our apologies to anyone whose name is missing.",
      "ja": "通常のIETFのファッションでは、多数の人々は、実際のテキストやアイデアに貢献してきました。これらの人々のリストはジェフAhrenholz、フランシスデュポン、デレクFawcus、ジョージ・グロス、アンドリュー・マクレガー、ジュリアンLaganier、Miikaこむ、ミカKousa、ジャンメレン、ヘンリクPetander、マイケル・リチャードソン、ティム・シェパード、ヨルマ・ウォール、およびユッカYlitaloが含まれます。名前欠けている誰にも私たちの謝罪。"
    },
    {
      "indent": 3,
      "text": "Once the HIP Working Group was founded in early 2004, a number of changes were introduced through the working group process. Most notably, the original document was split in two, one containing the base exchange and the other one defining how to use ESP. Some modifications to the protocol proposed by Aura, et al., [AUR03] were added at a later stage.",
      "ja": "HIPワーキンググループは、2004年初めに設立された後は、変更の数は、ワーキンググループのプロセスを経て導入されました。最も顕著なのは、元の文書は、二つの、塩基交換とESPを使用する方法を定義する他のものを含む1に分割されました。オーラによって提案されたプロトコルにいくつかの変更は、ら、[AUR03]後の段階で添加しました。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[FIPS95] NIST, \"FIPS PUB 180-1: Secure Hash Standard\", April 1995.",
      "ja": "[FIPS95] NIST、 \"FIPS PUB 180-1の：ハッシュ標準のSecure\"、1995年4月を。"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "ja": "[RFC0768]ポステル、J.、 \"ユーザ・データグラム・プロトコル\"、STD 6、RFC 768、1980年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, November 1987.",
      "ja": "[RFC1035] Mockapetris、P.、 \"ドメイン名 - 実装及び仕様\"、STD 13、RFC 1035、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2404] Madson, C. and R. Glenn, \"The Use of HMAC-SHA-1-96 within ESP and AH\", RFC 2404, November 1998.",
      "ja": "[RFC2404] Madson、C.とR.グレン、 \"ESPおよびAH内のHMAC-SHA-1-96の使用\"、RFC 2404、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2451] Pereira, R. and R. Adams, \"The ESP CBC-Mode Cipher Algorithms\", RFC 2451, November 1998.",
      "ja": "[RFC2451]ペレイラ、R.とR.アダムス、 \"ESP CBCモード暗号アルゴリズム\"、RFC 2451、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC2460]デアリング、S.とR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の仕様\"、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2463] Conta, A. and S. Deering, \"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification\", RFC 2463, December 1998.",
      "ja": "[RFC2463]コンタ、A.、およびS.デアリング、 \"インターネットプロトコルバージョン6（IPv6）仕様のためのインターネット制御メッセージプロトコル（ICMPv6の）\"、RFC 2463（1998年12月）。"
    },
    {
      "indent": 3,
      "text": "[RFC2536] Eastlake, D., \"DSA KEYs and SIGs in the Domain Name System (DNS)\", RFC 2536, March 1999.",
      "ja": "[RFC2536]イーストレイク、D.、 \"DSA鍵とドメインネームシステム（DNS）でのSIG\"、RFC 2536、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2898] Kaliski, B., \"PKCS #5: Password-Based Cryptography Specification Version 2.0\", RFC 2898, September 2000.",
      "ja": "[RFC2898] Kaliski、B.、 \"PKCS＃5：パスワードベースの暗号化仕様バージョン2.0\"、RFC 2898、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3110] Eastlake, D., \"RSA/SHA-1 SIGs and RSA KEYs in the Domain Name System (DNS)\", RFC 3110, May 2001.",
      "ja": "[RFC3110]イーストレーク、D.、 \"ドメインネームシステムにおけるRSA / SHA-1のSIGとRSA鍵（DNS）\"、RFC 3110、2001年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3484] Draves, R., \"Default Address Selection for Internet Protocol version 6 (IPv6)\", RFC 3484, February 2003.",
      "ja": "[RFC3484] Draves、R.、RFC 3484 \"インターネットプロトコルバージョン6（IPv6）のデフォルトのアドレス選択\"、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3526] Kivinen, T. and M. Kojo, \"More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)\", RFC 3526, May 2003.",
      "ja": "[RFC3526] Kivinen、T.およびM.古城、 \"インターネット鍵交換のためのより多くのモジュラー指数（MODP）のDiffie-Hellmanグループ（IKE）\"、RFC 3526、2003年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3602] Frankel, S., Glenn, R., and S. Kelly, \"The AES-CBC Cipher Algorithm and Its Use with IPsec\", RFC 3602, September 2003.",
      "ja": "[RFC3602]フランケル、S.、グレン、R.、およびS.ケリー、 \"AES-CBC暗号アルゴリズムおよびIPSecでの使用\"、RFC 3602、2003年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3972] Aura, T., \"Cryptographically Generated Addresses (CGA)\", RFC 3972, March 2005.",
      "ja": "[RFC3972]オーラ、T.、 \"暗号的に生成されたアドレス（CGA）\"、RFC 3972、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4034] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"Resource Records for the DNS Security Extensions\", RFC 4034, March 2005.",
      "ja": "[RFC4034]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 \"DNSセキュリティ拡張機能のためのリソースレコード\"、RFC 4034、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4282] Aboba, B., Beadles, M., Arkko, J., and P. Eronen, \"The Network Access Identifier\", RFC 4282, December 2005.",
      "ja": "[RFC4282] Aboba、B.、Beadles、M.、Arkko、J.、およびP. Eronen、 \"ネットワークアクセス識別子\"、RFC 4282、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4307] Schiller, J., \"Cryptographic Algorithms for Use in the Internet Key Exchange Version 2 (IKEv2)\", RFC 4307, December 2005.",
      "ja": "[RFC4307]シラー、J.、 \"インターネット鍵交換バージョン2（IKEv2の）での使用のための暗号アルゴリズム\"、RFC 4307、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4843] Nikander, P., Laganier, J., and F. Dupont, \"An IPv6 Prefix for Overlay Routable Cryptographic Hash Identifiers (ORCHID)\", RFC 4843, April 2007.",
      "ja": "[RFC4843] Nikander、P.、Laganier、J.、およびF.デュポン、RFC 4843、2007年4月 \"オーバーレイルーティング可能な暗号ハッシュ識別子（ORCHID）のIPv6プレフィックス\"。"
    },
    {
      "indent": 3,
      "text": "[RFC5202] Jokela, P., Moskowitz, R., and P. Nikander, \"Using the Encapsulating Security Payload (ESP) Transport Format with the Host Identity Protocol (HIP)\", RFC 5202, April 2008.",
      "ja": "[RFC5202] Jokela、P.、モスコウィッツ、R.、およびP. Nikander、RFC 5202、2008年4月 \"ホスト識別プロトコル（HIP）とカプセル化セキュリティペイロード（ESP）トランスポートフォーマットを使用します\"。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[AUR03] Aura, T., Nagarajan, A., and A. Gurtov, \"Analysis of the HIP Base Exchange Protocol\", in Proceedings of 10th Australasian Conference on Information Security and Privacy, July 2003.",
      "ja": "[AUR03]情報セキュリティとプライバシー、2003年7月10日にオーストラリアの会議の議事録でオーラ、T.、Nagarajan、A.、およびA. Gurtov、「HIP基本交換プロトコルの分析」、。"
    },
    {
      "indent": 3,
      "text": "[CRO03] Crosby, SA. and DS. Wallach, \"Denial of Service via Algorithmic Complexity Attacks\", in Proceedings of Usenix Security Symposium 2003, Washington, DC., August 2003.",
      "ja": "【CRO03]クロスビー、SA。そしてDS。ウォラック、のUsenixセキュリティシンポジウム2003、ワシントンD.C.の議事録では、「アルゴリズムの複雑攻撃を経由してサービス拒否」。、2003年8月。"
    },
    {
      "indent": 3,
      "text": "[DIF76] Diffie, W. and M. Hellman, \"New Directions in Cryptography\", IEEE Transactions on Information Theory vol. IT-22, number 6, pages 644-654, Nov 1976.",
      "ja": "[DIF76]ディフィー、W.とM.ヘルマン、「暗号に関する新」、情報理論の巻上のIEEEトランザクション。 IT-22、数6、ページ644から654、1976年11月。"
    },
    {
      "indent": 3,
      "text": "[FIPS01] NIST, \"FIPS PUB 197: Advanced Encryption Standard\", Nov 2001.",
      "ja": "[FIPS01] NIST、 \"FIPS PUBの197：高度暗号化規格\"、2001年11月。"
    },
    {
      "indent": 3,
      "text": "[HIP-APP] Henderson, T., Nikander, P., and M. Komu, \"Using the Host Identity Protocol with Legacy Applications\", Work in Progress, November 2007.",
      "ja": "[HIP-APP]ヘンダーソン、T.、Nikander、P.、およびM.こむ、進歩、2007年11月の作業 \"レガシーアプリケーションをホストアイデンティティプロトコルを使用します\"。"
    },
    {
      "indent": 3,
      "text": "[IPsec-APIs] Richardson, M., Williams, N., Komu, M., and S. Tarkoma, \"IPsec Application Programming Interfaces\", Work in Progress, February 2008.",
      "ja": "[IPsecでのAPI]リチャードソン、M.、ウィリアムズ、N.、こむ、M.、およびS. Tarkoma、 \"IPsecのアプリケーション・プログラミング・インターフェース\"、進歩、2008年2月に働いています。"
    },
    {
      "indent": 3,
      "text": "[KAU03] Kaufman, C., Perlman, R., and B. Sommerfeld, \"DoS protection for UDP-based protocols\", ACM Conference on Computer and Communications Security , Oct 2003.",
      "ja": "[KAU03]カウフマン、C.、パールマン、R.、およびB.ゾンマーフェルト、 \"UDPベースのプロトコルのためのDoS防御\"、コンピュータおよび通信セキュリティ、2003年10月にACM会議。"
    },
    {
      "indent": 3,
      "text": "[KRA03] Krawczyk, H., \"SIGMA: The 'SIGn-and-MAc' Approach to Authenticated Diffie-Hellman and Its Use in the IKE-Protocols\", in Proceedings of CRYPTO 2003, pages 400- 425, August 2003.",
      "ja": "[KRA03] Krawczyk、H.、 \"SIGMA：認証済みのDiffie-HellmanのとIKE-プロトコルでの使用に '記号-と-MAC' アプローチ\"、CRYPTO 2003の議事録では、ページ400〜425、2003年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0792] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, September 1981.",
      "ja": "[RFC0792]ポステル、J.、 \"インターネット制御メッセージプロトコル\"、STD 5、RFC 792、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2412] Orman, H., \"The OAKLEY Key Determination Protocol\", RFC 2412, November 1998.",
      "ja": "[RFC2412]オーマン、H.、 \"OAKLEYキー決意プロトコル\"、RFC 2412、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC4306] Kaufman, C., \"Internet Key Exchange (IKEv2) Protocol\", RFC 4306, December 2005.",
      "ja": "[RFC4306]カウフマン、C.、 \"インターネットキーエクスチェンジ（IKEv2の）プロトコル\"、RFC 4306、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4423] Moskowitz, R. and P. Nikander, \"Host Identity Protocol (HIP) Architecture\", RFC 4423, May 2006.",
      "ja": "[RFC4423]モスコウィッツ、R.とP. Nikander、 \"ホストアイデンティティプロトコル（HIP）アーキテクチャ\"、RFC 4423、2006年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5204] Laganier, J. and L. Eggert, \"Host Identity Protocol (HIP) Rendezvous Extension\", RFC 5204, April 2008.",
      "ja": "[RFC5204] Laganier、J.とL.エッゲルト、 \"ホストアイデンティティプロトコル（HIP）ランデブー拡張\"、RFC 5204、2008年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5205] Nikander, P. and J. Laganier, \"Host Identity Protocol (HIP) Domain Name System (DNS) Extensions\", RFC 5205, April 2008.",
      "ja": "[RFC5205] Nikander、P.およびJ. Laganier、 \"ホストアイデンティティプロトコル（HIP）ドメインネームシステム（DNS）の拡張\"、RFC 5205、2008年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5206] Henderson, T., Ed., \"End-Host Mobility and Multihoming with the Host Identity Protocol\", RFC 5206, April 2008.",
      "ja": "[RFC5206]ヘンダーソン、T.、エド。、「エンドホストモビリティとマルチホーミングをホストアイデンティティプロトコルで」、RFC 5206、2008年4月。"
    },
    {
      "indent": 3,
      "text": "[SHIM6-PROTO] Nordmark, E. and M. Bagnulo, \"Shim6: Level 3 Multihoming Shim Protocol for IPv6\", Work in Progress, February 2008.",
      "ja": "[SHIM6-PROTO] Nordmarkと、E.およびM. Bagnulo、 \"SHIM6：レベル3 IPv6のマルチホーミングシム・プロトコル\"、進歩、2008年2月に作業。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Using Responder Puzzles",
      "ja": "レスポンダパズルを使用した付録A."
    },
    {
      "indent": 3,
      "text": "As mentioned in Section 4.1.1, the Responder may delay state creation and still reject most spoofed I2s by using a number of pre-calculated R1s and a local selection function. This appendix defines one possible implementation in detail. The purpose of this appendix is to give the implementors an idea on how to implement the mechanism. If the implementation is based on this appendix, it MAY contain some local modification that makes an attacker's task harder.",
      "ja": "セクション4.1.1で述べたように、レスポンダは、状態の作成を遅らせ、まだ事前計算のR1の数とローカル選択機能を使用することによって最もスプーフィングされたI2Sを拒否することができます。この付録では、具体的に一つの可能​​な実装を定義します。この付録の目的は、実装者にメカニズムを実装する方法についてのアイデアを与えることです。実装は、この付録に基づいている場合、それは難しく、攻撃者の作業を行い、いくつかのローカルの変更を含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "The Responder creates a secret value S, that it regenerates periodically. The Responder needs to remember the two latest values of S. Each time the S is regenerated, the R1 generation counter value is incremented by one.",
      "ja": "Responderは、それが定期的に再生成すること、秘密値Sを作成します。 ResponderはSが再生成されるたびに、R1世代カウンタ値を1ずつインクリメントされるS.の最新の2つの値を覚えておく必要があります。"
    },
    {
      "indent": 3,
      "text": "The Responder generates a pre-signed R1 packet. The signature for pre-generated R1s must be recalculated when the Diffie-Hellman key is recomputed or when the R1_COUNTER value changes due to S value regeneration.",
      "ja": "レスポンダは、事前に署名されたR1パケットを生成します。事前生成のR1の署名は、ディフィー・ヘルマン鍵が再計算されたときに再計算またはなければならない場合、S値再生によるR1_COUNTER値が変化します。"
    },
    {
      "indent": 3,
      "text": "When the Initiator sends the I1 packet for initializing a connection, the Responder gets the HIT and IP address from the packet, and generates an I value for the puzzle. The I value is set to the pre-signed R1 packet.",
      "ja": "イニシエータが接続を初期化するためのI1パケットを送信すると、レスポンダは、パケットからのHITとIPアドレスを取得し、パズルのためのI値を生成します。 I値は、事前に署名したR1のパケットに設定されています。"
    },
    {
      "indent": 8,
      "text": "I value calculation:\nI = Ltrunc( RHASH ( S | HIT-I | HIT-R | IP-I | IP-R ), 64)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The RHASH algorithm is the same that is used to generate the Responder's HIT value.",
      "ja": "RHASHアルゴリズムは、レスポンダのHIT値を生成するために使用されるものと同じです。"
    },
    {
      "indent": 3,
      "text": "From an incoming I2 packet, the Responder gets the required information to validate the puzzle: HITs, IP addresses, and the information of the used S value from the R1_COUNTER. Using these values, the Responder can regenerate the I, and verify it against the I received in the I2 packet. If the I values match, it can verify the solution using I, J, and difficulty K. If the I values do not match, the I2 is dropped.",
      "ja": "HITS、IPアドレス、およびR1_COUNTERから使用S値の情報：入ってくるI2パケットから、Responderは、パズルを検証するために必要な情報を取得します。これらの値を用いて、ResponderはIを再生成し、私はI2パケットで受信に対してそれを確認することができます。 I値が一致した場合、それは私の値が一致しない場合は、I2がドロップされたI、J、および難易度Kを使用して解決策を確認することができます。"
    },
    {
      "indent": 8,
      "text": "puzzle_check:\nV := Ltrunc( RHASH( I2.I | I2.hit_i | I2.hit_r | I2.J ), K )\nif V != 0, drop the packet",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the puzzle solution is correct, the I and J values are stored for later use. They are used as input material when keying material is generated.",
      "ja": "パズルのソリューションが正しい場合、IとJの値は、後で使用するために保存されます。キーイング材料が生成されるときには、入力材料として使用されます。"
    },
    {
      "indent": 3,
      "text": "Keeping state about failed puzzle solutions depends on the implementation. Although it is possible for the Responder not to keep any state information, it still may do so to protect itself against certain attacks (see Section 4.1.1).",
      "ja": "失敗したパズルのソリューションについての状態を保つことは、実装に依存します。 Responderがどのような状態情報を保持しないためにそれは可能ですが、それはまだ特定の攻撃（4.1.1項を参照）に対して自身を守るためにそうすることができます。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Generating a Public Key Encoding from an HI",
      "ja": "HIから公開鍵暗号の生成付録B."
    },
    {
      "indent": 3,
      "text": "The following pseudo-code illustrates the process to generate a public key encoding from an HI for both RSA and DSA.",
      "ja": "次の擬似コードは、RSAやDSAの両方のためのHIから公開鍵暗号を生成するプロセスを示します。"
    },
    {
      "indent": 3,
      "text": "The symbol := denotes assignment; the symbol += denotes appending. The pseudo-function encode_in_network_byte_order takes two parameters, an integer (bignum) and a length in bytes, and returns the integer encoded into a byte string of the given length.",
      "ja": "記号：=は代入を表します。記号は+ =添付を示しています。擬似関数encode_in_network_byte_orderは、2つのパラメータ、整数（BIGNUM）およびバイト単位の長さをとり、所定の長さのバイト列にエンコードされた整数値を返します。"
    },
    {
      "indent": 3,
      "text": "switch ( HI.algorithm ) {",
      "ja": "スイッチ（HI.algorithm）{"
    },
    {
      "indent": 3,
      "text": "case RSA: buffer := encode_in_network_byte_order ( HI.RSA.e_len, ( HI.RSA.e_len > 255 ) ? 3 : 1 ) buffer += encode_in_network_byte_order ( HI.RSA.e, HI.RSA.e_len ) buffer += encode_in_network_byte_order ( HI.RSA.n, HI.RSA.n_len ) break;",
      "ja": "ケースRSA：バッファー：= encode_in_network_byte_order（HI.RSA.e_len、（> 255 HI.RSA.e_len）3：1）バッファー+ = encode_in_network_byte_order（HI.RSA.e、HI.RSA.e_len）バッファー+ = encode_in_network_byte_order（ HI.RSA.n、HI.RSA.n_len）ブレーク。"
    },
    {
      "indent": 3,
      "text": "case DSA: buffer := encode_in_network_byte_order ( HI.DSA.T , 1 ) buffer += encode_in_network_byte_order ( HI.DSA.Q , 20 ) buffer += encode_in_network_byte_order ( HI.DSA.P , 64 + 8 * HI.DSA.T ) buffer += encode_in_network_byte_order ( HI.DSA.G , 64 + 8 * HI.DSA.T ) buffer += encode_in_network_byte_order ( HI.DSA.Y , 64 + 8 * HI.DSA.T ) break;",
      "ja": "ケースDSA：バッファー：= encode_in_network_byte_order（HI.DSA.T、1）バッファ+ = encode_in_network_byte_order（HI.DSA.Q、20）緩衝剤+ = encode_in_network_byte_order（HI.DSA.P、64 + 8 * HI.DSA.T）バッファ+ = encode_in_network_byte_order（HI.DSA.G、64 + 8 * HI.DSA.T）+ = encode_in_network_byte_orderバッファ（HI.DSA.Y、64 + 8 * HI.DSA.T）破ります。"
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 0,
      "text": "Appendix C. Example Checksums for HIP Packets",
      "ja": "付録C.例サムHIPパケットのために"
    },
    {
      "indent": 3,
      "text": "The HIP checksum for HIP packets is specified in Section 5.1.1. Checksums for TCP and UDP packets running over HIP-enabled security associations are specified in Section 3.5. The examples below use IP addresses of 192.168.0.1 and 192.168.0.2 (and their respective IPv4- compatible IPv6 formats), and HITs with the prefix of 2001:10 followed by zeros, followed by a decimal 1 or 2, respectively.",
      "ja": "HIPパケットのHIPチェックサムは、セクション5.1.1で指定されています。 HIP-有効なセキュリティアソシエーション上で実行されているTCPおよびUDPパケットのためのチェックサムは、3.5節で指定されています。 2001接頭辞192.168.0.1と192.168.0.2（およびそれぞれIPv4-互換IPv6形式）の使用IPアドレスを以下の実施例、およびヒット数：10ゼロが続く、それぞれ小数1又は2、続きます。"
    },
    {
      "indent": 3,
      "text": "The following example is defined only for testing a checksum calculation. The address format for the IPv4-compatible IPv6 address is not a valid one, but using these IPv6 addresses when testing an IPv6 implementation gives the same checksum output as an IPv4 implementation with the corresponding IPv4 addresses.",
      "ja": "以下の実施例のみチェックサム計算をテストするために定義されています。 IPv4互換IPv6アドレスのアドレス形式が有効なものではなく、IPv6の実装をテストする場合、これらのIPv6アドレスを使用して対応のIPv4アドレスとIPv4の実装と同じチェックサム出力を与えます。"
    },
    {
      "indent": 0,
      "text": "C.1. IPv6 HIP Example (I1)",
      "ja": "C.1。 IPv6のHIP例（I1）"
    },
    {
      "indent": 6,
      "text": "Source Address:                 ::192.168.0.1\nDestination Address:            ::192.168.0.2\nUpper-Layer Packet Length:      40              0x28\nNext Header:                    139             0x8b\nPayload Protocol:               59              0x3b\nHeader Length:                  4               0x4\nPacket Type:                    1               0x1\nVersion:                        1               0x1\nReserved:                       1               0x1\nControl:                        0               0x0\nChecksum:                       446             0x1be\nSender's HIT  :                 2001:10::1\nReceiver's HIT:                 2001:10::2",
      "raw": true
    },
    {
      "indent": 0,
      "text": "C.2. IPv4 HIP Packet (I1)",
      "ja": "C.2。 IPv4のHIPパケット（I1）"
    },
    {
      "indent": 3,
      "text": "The IPv4 checksum value for the same example I1 packet is the same as the IPv6 checksum (since the checksums due to the IPv4 and IPv6 pseudo-header components are the same).",
      "ja": "（これはIPv4とIPv6の疑似ヘッダコンポーネントにチェックサムが同じであるため）同じ例I1パケットのIPv4チェックサム値は、IPv6チェックサムと同じです。"
    },
    {
      "indent": 0,
      "text": "C.3. TCP Segment",
      "ja": "C.3。 TCPセグメント"
    },
    {
      "indent": 3,
      "text": "Regardless of whether IPv6 or IPv4 is used, the TCP and UDP sockets use the IPv6 pseudo-header format [RFC2460], with the HITs used in place of the IPv6 addresses.",
      "ja": "かかわらずのIPv6またはIPv4を使用するかどうかの、TCPとUDPソケットは、IPv6アドレスの代わりに使用するヒットと、IPv6の疑似ヘッダのフォーマット[RFC2460]を使用します。"
    },
    {
      "indent": 6,
      "text": "Sender's HIT: 2001:10::1 Receiver's HIT: 2001:10::2 Upper-Layer Packet Length: 20 0x14 Next Header: 6 0x06 Source port: 65500 0xffdc Destination port: 22 0x0016 Sequence number: 1 0x00000001 Acknowledgment number: 0 0x00000000 Header length: 20 0x14 Flags: SYN 0x02 Window size: 65535 0xffff Checksum: 28618 0x6fca Urgent pointer: 0 0x0000",
      "ja": "送信者のHIT：2001：10 :: 1 ReceiverのHIT：2001：10 :: 2上位層パケットの長さ：20 0x14に次のヘッダ：6 0x06の送信元ポート：65500 0xffdc宛先ポート：22 0x0016シーケンス番号：1 0x00000001の確認番号：0 0x00000000のヘッダ長：20の0x14にフラグ：SYN 0x02のウィンドウサイズ：チェックサム0xFFFFの65535：28618 0x6fca緊急ポインタ：0 0000"
    },
    {
      "indent": 8,
      "text": "0x0000: 6000 0000 0014 0640 2001 0010 0000 0000 0x0010: 0000 0000 0000 0001 2001 0010 0000 0000 0x0020: 0000 0000 0000 0002 ffdc 0016 0000 0001 0x0030: 0000 0000 5002 ffff 6fca 0000",
      "ja": "0000：0014 0000 0640 2001 0010 6000 0000 0000 0x0010：0000 0000 0001 2001 0010 0000 0000 0000 0000 0000 0000 0x0020に0001 0000 0016 FFDC 0x0030 0002 0000 0000 0000 5002 FFFF 6fca"
    },
    {
      "indent": 0,
      "text": "Appendix D. 384-Bit Group",
      "ja": "付録D. 384ビットのグループ"
    },
    {
      "indent": 3,
      "text": "This 384-bit group is defined only to be used with HIP. NOTE: The security level of this group is very low! The encryption may be broken in a very short time, even real-time. It should be used only when the host is not powerful enough (e.g., some PDAs) and when security requirements are low (e.g., during normal web surfing).",
      "ja": "この384ビットのグループのみHIPで使用するように定義されます。注：このグループのセキュリティレベルが非常に低いです！暗号化は、非常に短い時間でさえリアルタイムに壊れていてもよいです。これは、ホストが十分に強力でない場合にのみ使用すべきである（例えば、いくつかのPDA）とセキュリティ要件は、（通常のウェブサーフィン中に、例えば、）低い場合。"
    },
    {
      "indent": 3,
      "text": "This prime is: 2^384 - 2^320 - 1 + 2^64 * { [ 2^254 pi] + 5857 }",
      "ja": "この素数は2 ^ 384から2 ^ 320から1 + 2 ^ 64 * {[2 ^ 254 PI] + 5857}"
    },
    {
      "indent": 3,
      "text": "Its hexadecimal value is:",
      "ja": "16進値は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1\n29024E08 8A67CC74 020BBEA6 3B13B202 FFFFFFFF FFFFFFFF",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The generator is: 2.",
      "ja": "発電機は、次のとおりです。2。"
    },
    {
      "indent": 0,
      "text": "Appendix E. OAKLEY Well-Known Group 1",
      "ja": "付録E. OAKLEYよく知られているグループ1"
    },
    {
      "indent": 3,
      "text": "See also [RFC2412] for definition of OAKLEY well-known group 1.",
      "ja": "OAKLEYよく知られているグループ1の定義についても、[RFC2412]を参照してください。"
    },
    {
      "indent": 3,
      "text": "OAKLEY Well-Known Group 1: A 768-bit prime",
      "ja": "OAKLEYよく知られているグループ1：768ビットの素数"
    },
    {
      "indent": 3,
      "text": "The prime is 2^768 - 2^704 - 1 + 2^64 * { [2^638 pi] + 149686 }.",
      "ja": "2 ^ 704  -   -  1 + 2 ^ 64 * {[2 ^ 638 PI] + 149686}素数は2 ^ 768です。"
    },
    {
      "indent": 3,
      "text": "The hexadecimal value is:",
      "ja": "16進数値です。"
    },
    {
      "indent": 7,
      "text": "FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1\n29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD\nEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245\nE485B576 625E7EC6 F44C42E9 A63A3620 FFFFFFFF FFFFFFFF",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This has been rigorously verified as a prime.",
      "ja": "これは厳密に総理として確認されています。"
    },
    {
      "indent": 3,
      "text": "The generator is: 22 (decimal)",
      "ja": "ジェネレータは22（10進数）"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Robert Moskowitz ICSAlabs, An Independent Division of Verizon Business Systems 1000 Bent Creek Blvd, Suite 200 Mechanicsburg, PA USA",
      "ja": "ロバート・モスコウィッツICSAlabs、1000年ベントクリークブルバード、スイート200メカニクス、PA USAベライゾンビジネスシステムの独立した部門"
    },
    {
      "indent": 3,
      "text": "EMail: rgm@icsalabs.com",
      "ja": "メールアドレス：rgm@icsalabs.com"
    },
    {
      "indent": 3,
      "text": "Pekka Nikander Ericsson Research NomadicLab JORVAS FIN-02420 FINLAND",
      "ja": "ペッカNikanderエリクソン研究NomadicLab JORVAS FIN-02420フィンランド"
    },
    {
      "indent": 3,
      "text": "Phone: +358 9 299 1 EMail: pekka.nikander@nomadiclab.com",
      "ja": "電話：+358 9 299 1 Eメール：pekka.nikander@nomadiclab.com"
    },
    {
      "indent": 3,
      "text": "Petri Jokela (editor) Ericsson Research NomadicLab JORVAS FIN-02420 FINLAND",
      "ja": "ペトリJokela（エディタ）エリクソン研究NomadicLab JORVAS FIN-02420フィンランド"
    },
    {
      "indent": 3,
      "text": "Phone: +358 9 299 1 EMail: petri.jokela@nomadiclab.com",
      "ja": "電話：+358 9 299 1 Eメール：petri.jokela@nomadiclab.com"
    },
    {
      "indent": 3,
      "text": "Thomas R. Henderson The Boeing Company P.O. Box 3707 Seattle, WA USA",
      "ja": "トーマス・R.ヘンダーソンザ・ボーイング社の私書箱ボックス3707シアトル、WA USA"
    },
    {
      "indent": 3,
      "text": "EMail: thomas.r.henderson@boeing.com",
      "ja": "メールアドレス：thomas.r.henderson@boeing.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2008).",
      "ja": "著作権（C）IETFトラスト（2008）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットSOCIETY、（もしあれば）を後援し、IETF TRUST ANDインターネットエンジニアリングタスクフォース放棄ALLに設けられています。保証は、明示または黙示、この情報の利用および特定目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証がこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    }
  ]
}