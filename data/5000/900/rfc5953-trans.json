{
  "title": {
    "text": "RFC 5953 - Transport Layer Security (TLS) Transport Model for the Simple Network Management Protocol (SNMP)",
    "ja": "RFC 5953 - トランスポート層セキュリティ（TLS）簡易ネットワーク管理プロトコルのための輸送モデル（SNMP）"
  },
  "number": 5953,
  "created_at": "2019-10-31 06:26:17.429005+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       W. Hardaker\nRequest for Comments: 5953                                  SPARTA, Inc.\nCategory: Standards Track                                    August 2010\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 11,
      "text": "  Transport Layer Security (TLS) Transport Model\nfor the Simple Network Management Protocol (SNMP)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes a Transport Model for the Simple Network Management Protocol (SNMP), that uses either the Transport Layer Security protocol or the Datagram Transport Layer Security (DTLS) protocol. The TLS and DTLS protocols provide authentication and privacy services for SNMP applications. This document describes how the TLS Transport Model (TLSTM) implements the needed features of a SNMP Transport Subsystem to make this protection possible in an interoperable way.",
      "ja": "この文書では、トランスポート層セキュリティプロトコルやデータグラムトランスポート層セキュリティ（DTLS）プロトコルのいずれかを使用して簡易ネットワーク管理プロトコル（SNMP）のための輸送モデルを説明しています。 TLSとDTLSプロトコルは、SNMPアプリケーションのための認証およびプライバシーサービスを提供します。この文書では、TLS輸送モデル（TLSTM）は、相互運用可能な方法でこの保護を可能にするためにSNMP交通サブシステムの必要な機能を実装する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "This Transport Model is designed to meet the security and operational needs of network administrators. It supports the sending of SNMP messages over TLS/TCP and DTLS/UDP. The TLS mode can make use of TCP's improved support for larger packet sizes and the DTLS mode provides potentially superior operation in environments where a connectionless (e.g., UDP) transport is preferred. Both TLS and DTLS integrate well into existing public keying infrastructures.",
      "ja": "この輸送モデルは、ネットワーク管理者のセキュリティと運用上のニーズを満たすように設計されています。これは、TLS / TCPおよびDTLS / UDP上でSNMPメッセージの送信をサポートしています。 TLSモードは、より大きなパケットサイズのためにTCPの改良されたサポートを利用することができ及びDTLSモードはコネクション（例えば、UDP）トランスポートが好ましい環境で潜在的に優れた動作を提供します。 TLSとDTLSはどちらも既存の公共キーインフラストラクチャにうまく統合します。"
    },
    {
      "indent": 3,
      "text": "This document also defines a portion of the Management Information Base (MIB) for use with network management protocols. In particular, it defines objects for managing the TLS Transport Model for SNMP.",
      "ja": "この文書は、ネットワーク管理プロトコルと共に使用するための管理情報ベース（MIB）の一部を画定します。特に、それはSNMPのためにTLS輸送モデルを管理するためのオブジェクトを定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5953.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc5953で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2010 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Conventions ................................................7\n2. The Transport Layer Security Protocol ...........................8\n3. How the TLSTM Fits into the Transport Subsystem .................8\n   3.1. Security Capabilities of this Model .......................10\n        3.1.1. Threats ............................................10\n        3.1.2. Message Protection .................................11\n        3.1.3. (D)TLS Connections .................................12\n   3.2. Security Parameter Passing ................................13\n   3.3. Notifications and Proxy ...................................13\n4. Elements of the Model ..........................................14\n   4.1. X.509 Certificates ........................................14\n        4.1.1. Provisioning for the Certificate ...................14\n   4.2. (D)TLS Usage ..............................................16\n   4.3. SNMP Services .............................................17\n        4.3.1. SNMP Services for an Outgoing Message ..............17\n        4.3.2. SNMP Services for an Incoming Message ..............18\n   4.4. Cached Information and References .........................19\n        4.4.1. TLS Transport Model Cached Information .............19",
      "raw": true
    },
    {
      "indent": 3,
      "text": "               4.4.1.1. tmSecurityName ............................19\n               4.4.1.2. tmSessionID ...............................20\n               4.4.1.3. Session State .............................20\n5. Elements of Procedure ..........................................20\n   5.1. Procedures for an Incoming Message ........................20\n        5.1.1. DTLS over UDP Processing for Incoming Messages .....21\n        5.1.2. Transport Processing for Incoming SNMP Messages ....22\n   5.2. Procedures for an Outgoing SNMP Message ...................24\n   5.3. Establishing or Accepting a Session .......................25\n        5.3.1. Establishing a Session as a Client .................25\n        5.3.2. Accepting a Session as a Server ....................27\n   5.4. Closing a Session .........................................28\n6. MIB Module Overview ............................................29\n   6.1. Structure of the MIB Module ...............................29\n   6.2. Textual Conventions .......................................29\n   6.3. Statistical Counters ......................................29\n   6.4. Configuration Tables ......................................29\n        6.4.1. Notifications ......................................30\n   6.5. Relationship to Other MIB Modules .........................30\n        6.5.1. MIB Modules Required for IMPORTS ...................30\n7. MIB Module Definition ..........................................30\n8. Operational Considerations .....................................53\n   8.1. Sessions ..................................................53\n   8.2. Notification Receiver Credential Selection ................54\n   8.3. contextEngineID Discovery .................................54\n   8.4. Transport Considerations ..................................55\n9. Security Considerations ........................................55\n   9.1. Certificates, Authentication, and Authorization ...........55\n   9.2. (D)TLS Security Considerations ............................56\n        9.2.1. TLS Version Requirements ...........................56\n        9.2.2. Perfect Forward Secrecy ............................56\n   9.3. Use with SNMPv1/SNMPv2c Messages ..........................56\n   9.4. MIB Module Security .......................................57\n10. IANA Considerations ...........................................58\n11. Acknowledgements ..............................................59\n12. References ....................................................60\n   12.1. Normative References .....................................60\n   12.2. Informative References ...................................61\nAppendix A.  Target and Notification Configuration Example ........63\n  A.1.  Configuring a Notification Originator .....................63\n  A.2.  Configuring TLSTM to Utilize a Simple Derivation of\n        tmSecurityName ............................................64\n  A.3.  Configuring TLSTM to Utilize Table-Driven Certificate\n        Mapping ...................................................64",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "It is important to understand the modular SNMPv3 architecture as defined by [RFC3411] and enhanced by the Transport Subsystem [RFC5590]. It is also important to understand the terminology of the SNMPv3 architecture in order to understand where the Transport Model described in this document fits into the architecture and how it interacts with the other architecture subsystems. For a detailed overview of the documents that describe the current Internet-Standard Management Framework, please refer to Section 7 of [RFC3410].",
      "ja": "[RFC3411]で定義されているモジュラーSNMPv3アーキテクチャを理解することが重要であるとトランスポートサブシステム[RFC5590]によって強化します。他のアーキテクチャのサブシステムと対話する方法この文書で説明輸送モデルは、アーキテクチャに適合し、どこに理解するために、SNMPv3アーキテクチャの用語を理解することも重要です。現在のインターネット標準の管理フレームワークを記述したドキュメントの詳細な概要については、[RFC3410]のセクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "This document describes a Transport Model that makes use of the Transport Layer Security (TLS) [RFC5246] and the Datagram Transport Layer Security (DTLS) Protocol [RFC4347], within a Transport Subsystem [RFC5590]. DTLS is the datagram variant of the Transport Layer Security (TLS) protocol [RFC5246]. The Transport Model in this document is referred to as the Transport Layer Security Transport Model (TLSTM). TLS and DTLS take advantage of the X.509 public keying infrastructure [RFC5280]. While (D)TLS supports multiple authentication mechanisms, this document only discusses X.509 certificate-based authentication. Although other forms of authentication are possible, they are outside the scope of this specification. This transport model is designed to meet the security and operational needs of network administrators, operating in both environments where a connectionless (e.g., UDP) transport is preferred and in environments where large quantities of data need to be sent (e.g., over a TCP-based stream). Both TLS and DTLS integrate well into existing public keying infrastructures. This document supports sending of SNMP messages over TLS/TCP and DTLS/UDP.",
      "ja": "この文書では、輸送サブシステム[RFC5590]の中に、トランスポート層セキュリティ（TLS）[RFC5246]とデータグラムトランスポート層セキュリティ（DTLS）プロトコル[RFC4347]を利用した輸送モデルを説明しています。 DTLSは、トランスポート層セキュリティ（TLS）プロトコル[RFC5246]のデータグラム変異体です。この文書の輸送モデルは、トランスポート層セキュリティ輸送モデル（TLSTM）と呼ばれています。 TLSとDTLSは、X.509公開鍵インフラストラクチャ[RFC5280]を利用します。 （D）TLSは、複数の認証メカニズムをサポートしながら、この文書は、X.509証明書ベースの認証について説明します。認証の他の形態が可能であるが、それらは本明細書の範囲外です。この輸送モデルは、コネクションレス（例えば、UDP）トランスポートが好ましい両方の環境でかつ大量のデータをTCP-の上に、例えば（送信する必要が環境で動作し、ネットワーク管理者のセキュリティと運用上のニーズを満たすように設計されてベースストリーム）。 TLSとDTLSはどちらも既存の公共キーインフラストラクチャにうまく統合します。このドキュメントは、TLS / TCPおよびDTLS / UDP上でSNMPメッセージの送信をサポートしています。"
    },
    {
      "indent": 3,
      "text": "This document also defines a portion of the Management Information Base (MIB) for use with network management protocols. In particular, it defines objects for managing the TLS Transport Model for SNMP.",
      "ja": "この文書は、ネットワーク管理プロトコルと共に使用するための管理情報ベース（MIB）の一部を画定します。特に、それはSNMPのためにTLS輸送モデルを管理するためのオブジェクトを定義します。"
    },
    {
      "indent": 3,
      "text": "Managed objects are accessed via a virtual information store, termed the Management Information Base or MIB. MIB objects are generally accessed through the Simple Network Management Protocol (SNMP). Objects in the MIB are defined using the mechanisms defined in the Structure of Management Information (SMI). This memo specifies a MIB module that is compliant to the SMIv2, which is described in STD 58: [RFC2578], [RFC2579], and [RFC2580].",
      "ja": "管理対象オブジェクトが仮想情報店を介してアクセスされ、管理情報ベースまたはMIBと呼ばれます。 MIBオブジェクトは、一般的に簡易ネットワーク管理プロトコル（SNMP）を介してアクセスされます。 MIBのオブジェクトは、管理情報（SMI）の構造で定義されたメカニズムを使用して定義されています。 [RFC2578]、[RFC2579]及び[RFC2580]：このメモは、STD 58に記載されているSMIv2のに準拠しているMIBモジュールを指定します。"
    },
    {
      "indent": 3,
      "text": "The diagram shown below gives a conceptual overview of two SNMP entities communicating using the TLS Transport Model (shown as \"TLSTM\"). One entity contains a command responder and notification originator application, and the other a command generator and notification receiver application. It should be understood that this particular mix of application types is an example only and other combinations are equally valid.",
      "ja": "以下に示す図は、TLS輸送モデル（「TLSTM」として示される）を使用して通信する2つのSNMPエンティティの概念の概要を示します。一方のエンティティは、コマンド応答および通知発信アプリケーションを含み、他のコマンドジェネレータと通知受信機アプリケーション。アプリケーションタイプのこの特定の組み合わせは一例であり、他の組み合わせも同様に有効であることを理解すべきです。"
    },
    {
      "indent": 3,
      "text": "Note: this diagram shows the Transport Security Model (TSM) being used as the security model that is defined in [RFC5591].",
      "ja": "注：この図は、トランスポート・セキュリティ・モデル（TSM）は[RFC5591]で定義されたセキュリティモデルとして使用されて示しています。"
    },
    {
      "indent": 1,
      "text": "+---------------------------------------------------------------------+\n|                              Network                                |\n+---------------------------------------------------------------------+\n    ^                     |            ^               |\n    |Notifications        |Commands    |Commands       |Notifications\n+---|---------------------|-------+ +--|---------------|--------------+\n|   |                     V       | |  |               V              |\n| +------------+  +------------+  | | +-----------+   +----------+    |\n| |  (D)TLS    |  |  (D)TLS    |  | | | (D)TLS    |   | (D)TLS   |    |\n| |  (Client)  |  |  (Server)  |  | | | (Client)  |   | (Server) |    |\n| +------------+  +------------+  | | +-----------+   +----------+    |\n|       ^             ^           | |       ^              ^          |\n|       |             |           | |       |              |          |\n|       +-------------+           | |       +--------------+          |\n| +-----|------------+            | | +-----|------------+            |\n| |     V            |            | | |     V            |            |\n| | +--------+       |   +-----+  | | | +--------+       |   +-----+  |\n| | | TLS TM |<--------->|Cache|  | | | | TLS TM |<--------->|Cache|  |\n| | +--------+       |   +-----+  | | | +--------+       |   +-----+  |\n| |Transport Subsys. |      ^     | | |Transport Subsys. |      ^     |\n| +------------------+      |     | | +------------------+      |     |\n|    ^                      |     | |    ^                      |     |\n|    |                      +--+  | |    |                      +--+  |\n|    v                         |  | |    V                         |  |\n| +-----+ +--------+ +-------+ |  | | +-----+ +--------+ +-------+ |  |\n| |     | |Message | |Securi.| |  | | |     | |Message | |Securi.| |  |\n| |Disp.| |Proc.   | |Subsys.| |  | | |Disp.| |Proc.   | |Subsys.| |  |\n| |     | |Subsys. | |       | |  | | |     | |Subsys. | |       | |  |\n| |     | |        | |       | |  | | |     | |        | |       | |  |\n| |     | | +----+ | | +---+ | |  | | |     | | +----+ | | +---+ | |  |\n| |    <--->|v3MP|<--> |TSM|<--+  | | |    <--->|v3MP|<--->|TSM|<--+  |\n| |     | | +----+ | | +---+ |    | | |     | | +----+ | | +---+ |    |\n| |     | |        | |       |    | | |     | |        | |       |    |\n| +-----+ +--------+ +-------+    | | +-----+ +--------+ +-------+    |\n|    ^                            | |    ^                            |\n|    |                            | |    |                            |\n|    +-+------------+             | |    +-+----------+               |\n|      |            |             | |      |          |               |\n|      v            v             | |      v          V               |\n| +-------------+ +-------------+ | | +-------------+ +-------------+ |\n| |   COMMAND   | | NOTIFICAT.  | | | |  COMMAND    | | NOTIFICAT.  | |\n| |  RESPONDER  | | ORIGINATOR  | | | | GENERATOR   | | RECEIVER    | |\n| | application | | application | | | | application | | application | |\n| +-------------+ +-------------+ | | +-------------+ +-------------+ |\n|                     SNMP entity | |                     SNMP entity |\n+---------------------------------+ +---------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1.1. Conventions",
      "section_title": true,
      "ja": "1.1。表記"
    },
    {
      "indent": 3,
      "text": "For consistency with SNMP-related specifications, this document favors terminology as defined in STD 62, rather than favoring terminology that is consistent with non-SNMP specifications. This is consistent with the IESG decision to not require the SNMPv3 terminology be modified to match the usage of other non-SNMP specifications when SNMPv3 was advanced to a Full Standard.",
      "ja": "むしろ非SNMPの仕様と一致している用語を好むよりも、STD 62で定義されているSNMP関連の仕様との整合性については、このドキュメントには、専門用語を好みます。これは、SNMPv3のは、全規格に進められたときに、他の非SNMP仕様の使用を一致するように変更されたSNMPv3用語を必要としないためにIESGの決定と一致しています。"
    },
    {
      "indent": 3,
      "text": "\"Authentication\" in this document typically refers to the English meaning of \"serving to prove the authenticity of\" the message, not data source authentication or peer identity authentication.",
      "ja": "このドキュメントの「認証」は、典型的にはメッセージではなく、データソース認証またはピアのアイデンティティ認証「の信憑性を証明するのに役立つ」の英語の意味を指します。"
    },
    {
      "indent": 3,
      "text": "The terms \"manager\" and \"agent\" are not used in this document because, in the [RFC3411] architecture, all SNMP entities have the capability of acting as manager, agent, or both depending on the SNMP application types supported in the implementation. Where distinction is required, the application names of command generator, command responder, notification originator, notification receiver, and proxy forwarder are used. See \"SNMP Applications\" [RFC3413] for further information.",
      "ja": "[RFC3411]アーキテクチャでは、すべてのSNMPエンティティが実装でサポートされているSNMPアプリケーションの種類に応じて、マネージャ、エージェント、またはその両方として作用する能力を有している、ので、用語「マネージャ」と「エージェント」は、本文書で使用されていません。区別が必要な場合、コマンド生成、コマンド応答、通知発信、通知受信、およびプロキシフォワーダのアプリケーション名が使用されています。詳細については、「SNMPアプリケーション」[RFC3413]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Large portions of this document simultaneously refer to both TLS and DTLS when discussing TLSTM components that function equally with either protocol. \"(D)TLS\" is used in these places to indicate that the statement applies to either or both protocols as appropriate. When a distinction between the protocols is needed, they are referred to independently through the use of \"TLS\" or \"DTLS\". The Transport Model, however, is named \"TLS Transport Model\" and refers not to the TLS or DTLS protocol but to the specification in this document, which includes support for both TLS and DTLS.",
      "ja": "どちらのプロトコルでも同様に機能するTLSTM成分を論じるときに、この文書の大部分は同時にTLSとDTLSの両方を指します。 「（D）TLSは、」文を適宜いずれか、または両方のプロトコルに適用されることを示すために、これらの場所で使用されています。プロトコル間の区別が必要な場合、それらは独立して、「TLS」または「DTLS」を使用して呼ばれています。輸送モデルは、しかし、「TLS輸送モデル」という名前ではなく、TLSまたはDTLSプロトコルではなくTLSとDTLSの両方をサポートしていますこの文書に記載されている仕様、を意味しています。"
    },
    {
      "indent": 3,
      "text": "Throughout this document, the terms \"client\" and \"server\" are used to refer to the two ends of the (D)TLS transport connection. The client actively opens the (D)TLS connection, and the server passively listens for the incoming (D)TLS connection. An SNMP entity may act as a (D)TLS client or server or both, depending on the SNMP applications supported.",
      "ja": "本明細書を通して、用語「クライアント」および「サーバ」は、（D）TLSトランスポート接続の両端を参照するために使用されます。クライアントは、積極的に（D）TLS接続を開き、サーバは受動的に入ってくる（D）TLS接続をリッスンします。 SNMPエンティティはサポートされているSNMPの用途に応じて、（D）TLSクライアントまたはサーバあるいはその両方として働くことができます。"
    },
    {
      "indent": 3,
      "text": "The User-Based Security Model (USM) [RFC3414] is a mandatory-to-implement Security Model in STD 62. While (D)TLS and USM frequently refer to a user, the terminology preferred in RFC 3411 and in this memo is \"principal\". A principal is the \"who\" on whose behalf services are provided or processing takes place. A principal can be, among other things, an individual acting in a particular role; a set of individuals, with each acting in a particular role; an application or a set of applications, or a combination of these within an administrative domain.",
      "ja": "ユーザベースのセキュリティモデル（USM）[RFC3414]（D）TLSとUSMながらSTD 62に強制的に実装セキュリティモデルで頻繁にユーザーを参照して、RFC 3411にこのメモで好ましい用語が \"主要な\"。校長は、「誰が」その代理としてサービスを提供しているか、処理には行われています。校長は、とりわけ、特定の役割には個人演技することができます。それぞれ特定の役割で行動すると個体の集合;アプリケーションまたはアプリケーションのセット、または管理ドメイン内のこれらの組み合わせ。"
    },
    {
      "indent": 3,
      "text": "Throughout this document, the term \"session\" is used to refer to a secure association between two TLS Transport Models that permits the transmission of one or more SNMP messages within the lifetime of the session. The (D)TLS protocols also have an internal notion of a session and although these two concepts of a session are related, when the term \"session\" is used this document is referring to the TLSTM's specific session and not directly to the (D)TLS protocol's session.",
      "ja": "このドキュメントでは、用語「セッションは」セッションの有効期間内の1つまたは複数のSNMPメッセージの送信を許可する2つのTLS輸送モデルの間のセキュアな関連性を参照するために使用されます。 （D）TLSプロトコルは、セッションの内部概念を有しており、セッションのこれら二つの概念が関連しているが、用語「セッション」が使用される場合、この文書は、（D）に直接ではなくTLSTMの特定のセッションを参照していますTLSプロトコルのセッション。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. The Transport Layer Security Protocol",
      "section_title": true,
      "ja": "2.トランスポート層セキュリティプロトコル"
    },
    {
      "indent": 3,
      "text": "(D)TLS provides authentication, data message integrity, and privacy at the transport layer (see [RFC4347]).",
      "ja": "（D）は、TLS（[RFC4347]を参照）、トランスポート層で認証、データメッセージの完全性及びプライバシーを提供します。"
    },
    {
      "indent": 3,
      "text": "The primary goals of the TLS Transport Model are to provide privacy, peer identity authentication and data integrity between two communicating SNMP entities. The TLS and DTLS protocols provide a secure transport upon which the TLSTM is based. Please refer to [RFC5246] and [RFC4347] for complete descriptions of the protocols.",
      "ja": "TLS輸送モデルの主な目標は、2つの通信SNMPエンティティ間のプライバシー、ピアのID認証およびデータの整合性を提供することです。 TLSとDTLSプロトコルはTLSTMの基礎となる安全な輸送を提供しています。プロトコルの完全な説明については、[RFC5246]と[RFC4347]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. How the TLSTM Fits into the Transport Subsystem",
      "section_title": true,
      "ja": "TLSTMトランスポートサブシステムにどのように適合するか3。"
    },
    {
      "indent": 3,
      "text": "A transport model is a component of the Transport Subsystem. The TLS Transport Model thus fits between the underlying (D)TLS transport layer and the Message Dispatcher [RFC3411] component of the SNMP engine.",
      "ja": "輸送モデルは、トランスポートサブシステムの構成要素です。 TLSトランスポートモデルは、このように、基礎となる（D）TLSトランスポート層とSNMPエンジンのメッセージディスパッチャ[RFC3411]成分との間に収まります。"
    },
    {
      "indent": 3,
      "text": "The TLS Transport Model will establish a session between itself and the TLS Transport Model of another SNMP engine. The sending transport model passes unencrypted and unauthenticated messages from the Dispatcher to (D)TLS to be encrypted and authenticated, and the receiving transport model accepts decrypted and authenticated/ integrity-checked incoming messages from (D)TLS and passes them to the Dispatcher.",
      "ja": "TLS輸送モデルは、それ自体、別のSNMPエンジンのTLS輸送モデルの間でセッションを確立します。送信トランスポート・モデルは、（D）、TLS暗号化され、認証されると、受信輸送モデルにディスパッチャから暗号化されていないと認証されていないメッセージを渡す（D）TLSから復号化および認証/完全性チェック着信メッセージを受け取り、ディスパッチャに渡します。"
    },
    {
      "indent": 3,
      "text": "After a TLS Transport Model session is established, SNMP messages can conceptually be sent through the session from one SNMP message Dispatcher to another SNMP Message Dispatcher. If multiple SNMP messages are needed to be passed between two SNMP applications they MAY be passed through the same session. A TLSTM implementation engine MAY choose to close the session to conserve resources.",
      "ja": "TLS輸送モデルセッションが確立された後、SNMPメッセージは、概念的には、別のSNMPメッセージDispatcherに1 SNMPメッセージディスパッチャからセッションを介して送信することができます。複数のSNMPメッセージは2つのSNMPアプリケーション間で渡されるために必要とされている場合、それらは同じセッションを通過させることができます。 TLSTM実装エンジンは、リソースを節約するために、セッションを閉じるために選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "The TLS Transport Model of an SNMP engine will perform the translation between (D)TLS-specific security parameters and SNMP-specific, model-independent parameters.",
      "ja": "SNMPエンジンのTLS輸送モデルは、（D）TLS固有のセキュリティパラメータおよびSNMP固有の、モデ​​ルに依存しないパラメータ間の変換を行います。"
    },
    {
      "indent": 3,
      "text": "The diagram below depicts where the TLS Transport Model (shown as \"(D)TLS TM\") fits into the architecture described in RFC 3411 and the Transport Subsystem:",
      "ja": "（「（D）TLS TM」として示される）TLS輸送モデルは、RFC 3411とトランスポート・サブシステムに記載のアーキテクチャに適合する場合以下の図は示しています。"
    },
    {
      "indent": 3,
      "text": "+------------------------------+\n|    Network                   |\n+------------------------------+\n   ^       ^              ^\n   |       |              |\n   v       v              v\n+-------------------------------------------------------------------+\n| +--------------------------------------------------+              |\n| |  Transport Subsystem                             |  +--------+  |\n| | +-----+ +-----+ +-------+             +-------+  |  |        |  |\n| | | UDP | | SSH | |(D)TLS |    . . .    | other |<--->| Cache  |  |\n| | |     | | TM  | | TM    |             |       |  |  |        |  |\n| | +-----+ +-----+ +-------+             +-------+  |  +--------+  |\n| +--------------------------------------------------+         ^    |\n|              ^                                               |    |\n|              |                                               |    |\n| Dispatcher   v                                               |    |\n| +--------------+ +---------------------+  +----------------+ |    |\n| | Transport    | | Message Processing  |  | Security       | |    |\n| | Dispatch     | | Subsystem           |  | Subsystem      | |    |\n| |              | |     +------------+  |  | +------------+ | |    |\n| |              | |  +->| v1MP       |<--->| | USM        | | |    |\n| |              | |  |  +------------+  |  | +------------+ | |    |\n| |              | |  |  +------------+  |  | +------------+ | |    |\n| |              | |  +->| v2cMP      |<--->| | Transport  | | |    |\n| | Message      | |  |  +------------+  |  | | Security   |<--+    |\n| | Dispatch    <---->|  +------------+  |  | | Model      | |      |\n| |              | |  +->| v3MP       |<--->| +------------+ |      |\n| |              | |  |  +------------+  |  | +------------+ |      |\n| | PDU Dispatch | |  |  +------------+  |  | | Other      | |      |\n| +--------------+ |  +->| otherMP    |<--->| | Model(s)   | |      |\n|              ^   |     +------------+  |  | +------------+ |      |\n|              |   +---------------------+  +----------------+      |\n|              v                                                    |\n|      +-------+-------------------------+---------------+          |\n|      ^                                 ^               ^          |\n|      |                                 |               |          |\n|      v                                 v               v          |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| +-------------+   +---------+   +--------------+  +-------------+ |\n| |   COMMAND   |   | ACCESS  |   | NOTIFICATION |  |    PROXY    | |\n| |  RESPONDER  |<->| CONTROL |<->|  ORIGINATOR  |  |  FORWARDER  | |\n| | application |   |         |   | applications |  | application | |\n| +-------------+   +---------+   +--------------+  +-------------+ |\n|      ^                                 ^                          |\n|      |                                 |                          |\n|      v                                 v                          |\n| +----------------------------------------------+                  |\n| |             MIB instrumentation              |      SNMP entity |\n+-------------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1. Security Capabilities of this Model",
      "section_title": true,
      "ja": "3.1。このモデルのセキュリティ機能"
    },
    {
      "indent": 0,
      "text": "3.1.1. Threats",
      "section_title": true,
      "ja": "3.1.1。脅威"
    },
    {
      "indent": 3,
      "text": "The TLS Transport Model provides protection against the threats identified by the RFC 3411 architecture [RFC3411]:",
      "ja": "TLS輸送モデルは、RFC 3411のアーキテクチャ[RFC3411]によって識別された脅威に対する保護を提供します。"
    },
    {
      "indent": 3,
      "text": "1. Modification of Information - The modification threat is the danger that an unauthorized entity may alter in-transit SNMP messages generated on behalf of an authorized principal in such a way as to effect unauthorized management operations, including falsifying the value of an object.",
      "ja": "情報の1変形例 - 変形の脅威は、オブジェクトの値を改ざんなどの不正管理操作を行うためのように、不正なエンティティがイントランジットように許可さ主に代わって生成されたSNMPメッセージを変更することができることは危険です。"
    },
    {
      "indent": 7,
      "text": "(D)TLS provides verification that the content of each received\nmessage has not been modified during its transmission through the\nnetwork, data has not been altered or destroyed in an\nunauthorized manner, and data sequences have not been altered to\nan extent greater than can occur non-maliciously.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. Masquerade - The masquerade threat is the danger that management operations unauthorized for a given principal may be attempted by assuming the identity of another principal that has the appropriate authorizations.",
      "ja": "2.マスカレード - なりすましの脅威は、所与のプリンシパルの不正管理操作が適切な権限を持つ別のプリンシパルのアイデンティティを仮定することによって試みられてもよいことは危険です。"
    },
    {
      "indent": 7,
      "text": "The TLSTM verifies the identity of the (D)TLS server through the\nuse of the (D)TLS protocol and X.509 certificates.  A TLS\nTransport Model implementation MUST support the authentication of\nboth the server and the client.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. Message stream modification - The re-ordering, delay, or replay of messages can and does occur through the natural operation of many connectionless transport services. The message stream modification threat is the danger that messages may be maliciously re-ordered, delayed or replayed to an extent that is greater than can occur through the natural operation of connectionless transport services, in order to effect unauthorized management operations.",
      "ja": "3.メッセージ・ストリームの修正 - 再順序付け、遅延、またはメッセージの再生ができ、多くのコネクションレスな輸送サービスの自然な操作で起こるん。メッセージ・ストリーム修正脅威は、メッセージが悪意を持って、再順序付け遅延や不正管理操作を行うために、コネクションレス型トランスポート・サービスの自然な操作によって発生する可能性がより大きい程度まで再生されてもよいことは危険です。"
    },
    {
      "indent": 7,
      "text": "(D)TLS provides replay protection with a Message Authentication\nCode (MAC) that includes a sequence number.  Since UDP provides\nno sequencing ability, DTLS uses a sliding window protocol with\nthe sequence number used for replay protection (see [RFC4347]).",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4. Disclosure - The disclosure threat is the danger of eavesdropping on the exchanges between SNMP engines.",
      "ja": "4.開示 - 開示の脅威は、SNMPエンジン間の交流に盗聴の危険性です。"
    },
    {
      "indent": 7,
      "text": "(D)TLS provides protection against the disclosure of information\nto unauthorized recipients or eavesdroppers by allowing for\nencryption of all traffic between SNMP engines.  A TLS Transport\nModel implementation MUST support message encryption to protect\nsensitive data from eavesdropping attacks.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5. Denial of Service - the RFC 3411 architecture [RFC3411] states that denial-of-service (DoS) attacks need not be addressed by an SNMP security protocol. However, connectionless transports (like DTLS over UDP) are susceptible to a variety of DoS attacks because they are more vulnerable to spoofed IP addresses. See Section 4.2 for details on how the cookie mechanism is used. Note, however, that this mechanism does not provide any defense against DoS attacks mounted from valid IP addresses.",
      "ja": "サービスの5.拒否 -  RFC 3411アーキテクチャ[RFC3411]はサービス拒否（DoS）攻撃は、SNMPセキュリティプロトコルによって対処する必要はないと述べています。彼らは偽装されたIPアドレスに対してより脆弱であるため、しかし、（UDP上DTLSのような）コネクションレスのトランスポートは、DoS攻撃の様々な影響を受けやすいです。クッキーのメカニズムが使用されている方法の詳細については、セクション4.2を参照してください。ただし、このメカニズムが有効なIPアドレスから搭載されたDoS攻撃に対する任意の防衛を提供しないこと。"
    },
    {
      "indent": 3,
      "text": "See Section 9 for more detail on the security considerations associated with the TLSTM and these security threats.",
      "ja": "TLSTM及びこれらのセキュリティの脅威に関連するセキュリティ上の考慮事項の詳細については、セクション9を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Message Protection",
      "section_title": true,
      "ja": "3.1.2。メッセージ保護"
    },
    {
      "indent": 3,
      "text": "The RFC 3411 architecture recognizes three levels of security:",
      "ja": "RFC 3411アーキテクチャは、3つのセキュリティレベルを認識します。"
    },
    {
      "indent": 3,
      "text": "o without authentication and without privacy (noAuthNoPriv)",
      "ja": "認証なしとプライバシーなしO（noAuthNoPrivという）"
    },
    {
      "indent": 3,
      "text": "o with authentication but without privacy (authNoPriv)",
      "ja": "認証ではなく、プライバシーのないO（authNoPriv）"
    },
    {
      "indent": 3,
      "text": "o with authentication and with privacy (authPriv)",
      "ja": "認証付きとプライバシー（authPrivの）とO"
    },
    {
      "indent": 3,
      "text": "The TLS Transport Model determines from (D)TLS the identity of the authenticated principal, the transport type and the transport address associated with an incoming message. The TLS Transport Model provides the identity and destination type and address to (D)TLS for outgoing messages.",
      "ja": "TLSトランスポートモデル（D）から判断する認証されたプリンシパル、トランスポート・タイプ、着信メッセージに関連付けられたトランスポート・アドレスのアイデンティティをTLS。 TLSトランスポートモデルは発信メッセージのための（D）TLSのアイデンティティおよび宛先タイプおよびアドレスを提供します。"
    },
    {
      "indent": 3,
      "text": "When an application requests a session for a message, it also requests a security level for that session. The TLS Transport Model MUST ensure that the (D)TLS connection provides security at least as high as the requested level of security. How the security level is translated into the algorithms used to provide data integrity and privacy is implementation dependent. However, the NULL integrity and encryption algorithms MUST NOT be used to fulfill security level requests for authentication or privacy. Implementations MAY choose to force (D)TLS to only allow cipher_suites that provide both authentication and privacy to guarantee this assertion.",
      "ja": "アプリケーションがメッセージのセッションを要求すると、それはまた、そのセッションのセキュリティレベルを要求します。 TLSトランスポートモデル（D）TLS接続がセキュリティの要求されたレベルと少なくとも同じ高セキュリティを提供することを確実にしなければなりません。セキュリティレベルは、データの整合性とプライバシーを提供するために使用されるアルゴリズムに翻訳されてどのように実装依存です。しかし、NULL整合性および暗号化アルゴリズムは、認証やプライバシーのセキュリティレベルの要求を満たすために使用してはいけません。実装はこの主張を保証する認証とプライバシーの両方を提供cipher_suitesを許可する（D）TLSを強制するために選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "If a suitable interface between the TLS Transport Model and the (D)TLS Handshake Protocol is implemented to allow the selection of security-level-dependent algorithms (for example, a security level to cipher_suites mapping table), then different security levels may be utilized by the application.",
      "ja": "TLSトランスポート・モデルとの間の適切なインタフェースと、（D）TLSハンドシェイクプロトコルは、セキュリティレベルに依存するアルゴリズム（cipher_suitesマッピングテーブルに、例えば、セキュリティレベル）の選択を可能にするために実装されている場合、異なるセキュリティレベルを利用することができますアプリケーションによって。"
    },
    {
      "indent": 3,
      "text": "The authentication, integrity, and privacy algorithms used by the (D)TLS Protocols may vary over time as the science of cryptography continues to evolve and the development of (D)TLS continues over time. Implementers are encouraged to plan for changes in operator trust of particular algorithms. Implementations SHOULD offer configuration settings for mapping algorithms to SNMPv3 security levels.",
      "ja": "暗号化の科学が進化し続け、（D）TLSの開発は時間をかけて継続するように（D）で使用される認証、完全性、およびプライバシーアルゴリズムTLSプロトコルは、時間の経過と共に変化してもよいです。実装者は、特定のアルゴリズムのオペレータ信託の変更を計画することをお勧めします。実装は、SNMPv3セキュリティレベルにマッピングアルゴリズムの構成設定を提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.3. (D)TLS Connections",
      "section_title": true,
      "ja": "3.1.3。 （D）TLS接続"
    },
    {
      "indent": 3,
      "text": "(D)TLS connections are opened by the TLS Transport Model during the elements of procedure for an outgoing SNMP message. Since the sender of a message initiates the creation of a (D)TLS connection if needed, the (D)TLS connection will already exist for an incoming message.",
      "ja": "（D）TLS接続が発信SNMPメッセージ手順の要素の間にTLS輸送モデルによって開かれます。メッセージの送信者が必要に応じて（D）TLS接続の作成を開始するため、（D）TLS接続が既に入ってくるメッセージのために存在します。"
    },
    {
      "indent": 3,
      "text": "Implementations MAY choose to instantiate (D)TLS connections in anticipation of outgoing messages. This approach might be useful to ensure that a (D)TLS connection to a given target can be established before it becomes important to send a message over the (D)TLS connection. Of course, there is no guarantee that a pre-established session will still be valid when needed.",
      "ja": "実装は、送信メッセージを見越して（D）TLS接続をインスタンス化することを選択するかもしれません。このアプローチは、（D）TLS接続を介してメッセージを送信することが重要になる前に与えられたターゲットへの（D）TLS接続を確立できることを保証するために役に立つかもしれません。もちろん、必要なときに事前に確立されたセッションがまだ有効であるという保証はありません。"
    },
    {
      "indent": 3,
      "text": "DTLS connections, when used over UDP, are uniquely identified within the TLS Transport Model by the combination of transportDomain, transportAddress, tmSecurityName, and requestedSecurityLevel associated with each session. Each unique combination of these parameters MUST have a locally chosen unique tlstmSessionID for each active session. For further information, see Section 5. TLS over TCP sessions, on the other hand, do not require a unique pairing of address and port attributes since their lower-layer protocols (TCP) already provide adequate session framing. But they must still provide a unique tlstmSessionID for referencing the session.",
      "ja": "DTLS接続は、UDP上で使用される場合、一意のセッションに関連付けられたtransportDomain、transportAddress、tmSecurityName、及びrequestedSecurityLevelの組み合わせによってTLS輸送モデル内で識別されています。これらのパラメータはそれぞれユニークな組み合わせは、各アクティブ・セッションのローカルに選ばれたユニークなtlstmSessionIDを持たなければなりません。詳細については、TCPセッションに対して、第5節TLSを参照してください、一方で、その下位層プロトコル（TCP）は、すでに十分なセッションフレーミングを提供するので、アドレスとポートのユニークなペアリング属性を必要としません。しかし、彼らはまだセッションを参照するためのユニークなtlstmSessionIDを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "The tlstmSessionID MUST NOT change during the entire duration of the session from the TLSTM's perspective, and MUST uniquely identify a single session. As an implementation hint: note that the (D)TLS internal SessionID does not meet these requirements, since it can change over the life of the connection as seen by the TLSTM (for example, during renegotiation), and does not necessarily uniquely identify a TLSTM session (there can be multiple TLSTM sessions sharing the same D(TLS) internal SessionID).",
      "ja": "tlstmSessionIDはTLSTMの視点からのセッションの全期間の間に変化してはならない、と一意に単一のセッションを特定しなければなりません。実装のヒントとして：（D）TLS内部セッションIDは、（例えば、再ネゴシエーション中）TLSTMによって見られるように、接続の寿命にわたって変化することができるので、これらの要件を満たしていない、必ずしも一意に識別しないことに注意してくださいTLSTMセッションが（同じD（TLS）内部セッションIDを共有する複数TLSTMセッションが存在し得ます）。"
    },
    {
      "indent": 0,
      "text": "3.2. Security Parameter Passing",
      "section_title": true,
      "ja": "3.2。セキュリティパラメータの受渡し"
    },
    {
      "indent": 3,
      "text": "For the (D)TLS server-side, (D)TLS-specific security parameters (i.e., cipher_suites, X.509 certificate fields, IP addresses, and ports) are translated by the TLS Transport Model into security parameters for the TLS Transport Model and security model (e.g., tmSecurityLevel, tmSecurityName, transportDomain, transportAddress). The transport-related and (D)TLS-security-related information, including the authenticated identity, are stored in a cache referenced by tmStateReference.",
      "ja": "（D）TLSサーバ側の場合は、（D）TLS固有のセキュリティパラメータ（すなわち、cipher_suites、X.509証明書フィールド、IPアドレス、およびポート）は、TLS輸送モデルのためのセキュリティパラメータにTLS輸送モデルによって翻訳されていますそして、セキュリティモデル（例えば、tmSecurityLevel、tmSecurityName、transportDomain、transportAddress）。輸送関連し、認証されたIDを含む（D）TLSセキュリティ関連情報は、tmStateReferenceによって参照キャッシュに格納されています。"
    },
    {
      "indent": 3,
      "text": "For the (D)TLS client side, the TLS Transport Model takes input provided by the Dispatcher in the sendMessage() Abstract Service Interface (ASI) and input from the tmStateReference cache. The (D)TLS Transport Model converts that information into suitable security parameters for (D)TLS and establishes sessions as needed.",
      "ja": "（D）TLSクライアント側では、TLSトランスポートモデルのsendMessageにディスパッチャ（）アブストラクトサービスインターフェイス（ASI）とtmStateReferenceキャッシュからの入力によって提供される入力を要します。 （D）TLS輸送モデルは、（D）TLSに適したセキュリティパラメータにその情報を変換し、必要に応じてセッションを確立します。"
    },
    {
      "indent": 3,
      "text": "The elements of procedure in Section 5 discuss these concepts in much greater detail.",
      "ja": "第5節の手順の要素は非常に詳細にこれらの概念を議論します。"
    },
    {
      "indent": 0,
      "text": "3.3. Notifications and Proxy",
      "section_title": true,
      "ja": "3.3。通知とプロキシ"
    },
    {
      "indent": 3,
      "text": "(D)TLS connections may be initiated by (D)TLS clients on behalf of SNMP applications that initiate communications, such as command generators, notification originators, proxy forwarders. Command generators are frequently operated by a human, but notification originators and proxy forwarders are usually unmanned automated processes. The targets to whom notifications and proxied requests should be sent is typically determined and configured by a network administrator.",
      "ja": "（D）TLS接続が（D）によって開始することができるが、そのようなコマンドジェネレータ、通知発信、プロキシフォワーダなどの通信を開始するSNMPアプリケーションに代わってクライアントをTLS。コマンド・ジェネレータは、しばしば人間によって運営されているが、通知の発信元とプロキシフォワーダは、通常は無人自動化プロセスです。通知およびプロキシ要求を誰にターゲットが送信されるべき一般的に、ネットワーク管理者によって決定され、構成されています。"
    },
    {
      "indent": 3,
      "text": "The SNMP-TARGET-MIB module [RFC3413] contains objects for defining management targets, including transportDomain, transportAddress, securityName, securityModel, and securityLevel parameters, for notification originator, proxy forwarder, and SNMP-controllable command generator applications. Transport domains and transport addresses are configured in the snmpTargetAddrTable, and the securityModel, securityName, and securityLevel parameters are configured in the snmpTargetParamsTable. This document defines a MIB module that extends the SNMP-TARGET-MIB's snmpTargetParamsTable to specify a (D)TLS client-side certificate to use for the connection.",
      "ja": "SNMP-TARGET-MIBモジュール[RFC3413]は、通知発信プロキシフォワーダ、およびSNMP-制御コマンド発生用途に、transportDomain、transportAddress、のsecurityName、securityModel、そしてたsecurityLevelパラメータを含む、管理目標を定義するためのオブジェクトが含まれています。輸送ドメインおよびトランスポートアドレスはsnmpTargetAddrTableの構成され、securityModel、のsecurityName、そしてたsecurityLevelパラメータがたsnmpTargetParamsTableに構成されています。この文書では、接続に使用する（D）TLSクライアント側の証明書を指定するためにSNMP-TARGET-MIBのたsnmpTargetParamsTableを拡張MIBモジュールを定義します。"
    },
    {
      "indent": 3,
      "text": "When configuring a (D)TLS target, the snmpTargetAddrTDomain and snmpTargetAddrTAddress parameters in snmpTargetAddrTable SHOULD be set to the snmpTLSTCPDomain or snmpDTLSUDPDomain object and an appropriate snmpTLSAddress value. When used with the SNMPv3 message processing model, the snmpTargetParamsMPModel column of the snmpTargetParamsTable SHOULD be set to a value of 3. The snmpTargetParamsSecurityName SHOULD be set to an appropriate securityName value and the snmpTlstmParamsClientFingerprint parameter of the snmpTlstmParamsTable SHOULD be set a value that refers to a locally held certificate (and the corresponding private key) to be used. Other parameters, for example, cryptographic configuration such as which cipher_suites to use, must come from configuration mechanisms not defined in this document.",
      "ja": "（D）TLSターゲットを構成する場合、snmpTargetAddrTableのsnmpTargetAddrTDomainとsnmpTargetAddrTAddressパラメータはsnmpTLSTCPDomain又はsnmpDTLSUDPDomain物体と適切なsnmpTLSAddress値に設定する必要があります。 SNMPv3のメッセージ処理モデルと共に使用した場合、たsnmpTargetParamsTableのsnmpTargetParamsMPModel列は適切なのsecurityName値に設定されるべきであり、snmpTlstmParamsTableのsnmpTlstmParamsClientFingerprintパラメータが参照値に設定されるべきである3. snmpTargetParamsSecurityNameの値に設定する必要がありますローカルで使用する証明書（および対応する秘密鍵）を開催しました。例えば、他のパラメータは、使用するcipher_suites例えばどのように暗号化構成は、この文書で定義されていないコンフィギュレーションメカニズムから来なければなりません。"
    },
    {
      "indent": 3,
      "text": "The securityName defined in the snmpTargetParamsSecurityName column will be used by the access control model to authorize any notifications that need to be sent.",
      "ja": "snmpTargetParamsSecurityName列で定義されたセキュリティ名を送信する必要のあるすべての通知を許可するアクセス制御モデルで使用されます。"
    },
    {
      "indent": 0,
      "text": "4. Elements of the Model",
      "section_title": true,
      "ja": "モデルの4要素"
    },
    {
      "indent": 3,
      "text": "This section contains definitions required to realize the (D)TLS Transport Model defined by this document.",
      "ja": "このセクションでは、この文書で定義された（D）TLS輸送モデルを実現するために必要な定義が含まれています。"
    },
    {
      "indent": 0,
      "text": "4.1. X.509 Certificates",
      "section_title": true,
      "ja": "4.1。 X.509証明書"
    },
    {
      "indent": 3,
      "text": "(D)TLS can make use of X.509 certificates for authentication of both sides of the transport. This section discusses the use of X.509 certificates in the TLSTM.",
      "ja": "（D）は、TLSトランスポートの両側の認証のためのX.509証明書を利用することができます。このセクションでは、TLSTMでX.509証明書の使用について説明します。"
    },
    {
      "indent": 3,
      "text": "While (D)TLS supports multiple authentication mechanisms, this document only discusses X.509-certificate-based authentication; other forms of authentication are outside the scope of this specification. TLSTM implementations are REQUIRED to support X.509 certificates.",
      "ja": "（D）TLSは、複数の認証メカニズムをサポートしながら、この文書は、X.509証明書ベースの認証について説明し、認証の他の形態は、本明細書の範囲外です。 TLSTMの実装は、X.509証明書をサポートするために必要とされています。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Provisioning for the Certificate",
      "section_title": true,
      "ja": "4.1.1。証明書のプロビジョニング"
    },
    {
      "indent": 3,
      "text": "Authentication using (D)TLS will require that SNMP entities have certificates, either signed by trusted Certification Authorities (CAs), or self signed. Furthermore, SNMP entities will most commonly need to be provisioned with root certificates that represent the list of trusted CAs that an SNMP entity can use for certificate verification. SNMP entities SHOULD also be provisioned with a X.509 certificate revocation mechanism which can be used to verify that a certificate has not been revoked. Trusted public keys from either CA certificates and/or self-signed certificates MUST be installed into the server through a trusted out-of-band mechanism and their authenticity MUST be verified before access is granted.",
      "ja": "（D）TLSは、SNMPエンティティは、信頼できる証明機関（CA）によって署名された証明書のいずれか、または自己署名を持っている必要がありますを使用して認証。さらに、SNMPエンティティは、最も一般的にSNMPエンティティは、証明書の検証に使用することができます信頼できるCAのリストを表すルート証明書をプロビジョニングする必要があります。 SNMPエンティティは、証明書が失効していないことを確認するために使用することができますX.509証明書の取り消し機構が提供される必要があります。 CA証明書および/または自己署名証明書のいずれかから信頼された公開鍵は、信頼できるアウトオブバンドメカニズムを介してサーバーにインストールする必要があり、アクセスが許可される前に、その信憑性を確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Having received a certificate from a connecting TLSTM client, the authenticated tmSecurityName of the principal is derived using the snmpTlstmCertToTSNTable. This table allows mapping of incoming connections to tmSecurityNames through defined transformations. The transformations defined in the SNMP-TLS-TM-MIB include:",
      "ja": "接続TLSTMクライアントから証明書を受信すると、プリンシパルの認証tmSecurityNameはsnmpTlstmCertToTSNTableを用いて導出されます。このテーブルは、定義された変換を介してtmSecurityNamesへの着信接続のマッピングを可能にします。 SNMP-TLS-TM-MIBで定義された変換は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Mapping a certificate's subjectAltName or CommonName components to a tmSecurityName, or",
      "ja": "tmSecurityNameに証明書ののsubjectAltNameかのCommonNameコンポーネントのマッピング、またはO"
    },
    {
      "indent": 3,
      "text": "o Mapping a certificate's fingerprint value to a directly specified tmSecurityName",
      "ja": "O直接指定tmSecurityNameに証明書のフィンガープリント値のマッピング"
    },
    {
      "indent": 3,
      "text": "As an implementation hint: implementations may choose to discard any connections for which no potential snmpTlstmCertToTSNTable mapping exists before performing certificate verification to avoid expending computational resources associated with certificate verification.",
      "ja": "実装のヒントとして：実装は、潜在的なsnmpTlstmCertToTSNTableマッピングが証明書の検証に関連した計算資源を消費回避するために証明書の検証を実行する前に存在しないため、任意の接続を破棄することを選択することができます。"
    },
    {
      "indent": 3,
      "text": "Deployments SHOULD map the \"subjectAltName\" component of X.509 certificates to the TLSTM specific tmSecurityNames. The authenticated identity can be obtained by the TLS Transport Model by extracting the subjectAltName(s) from the peer's certificate. The receiving application will then have an appropriate tmSecurityName for use by other SNMPv3 components like an access control model.",
      "ja": "展開はTLSTM特定tmSecurityNamesにX.509証明書の「のsubjectAltName」コンポーネントをマップする必要があります。認証されたIDは、ピアの証明書からのsubjectAltName（複数可）を抽出することによって、TLS輸送モデルによって得ることができます。受信側アプリケーションは、アクセス制御モデルのような他のSNMPv3のコンポーネントによる使用のために適切なtmSecurityNameを有するであろう。"
    },
    {
      "indent": 3,
      "text": "An example of this type of mapping setup can be found in Appendix A.",
      "ja": "マッピング設定のこのタイプの例は、付録Aに記載されています"
    },
    {
      "indent": 3,
      "text": "This tmSecurityName may be later translated from a TLSTM specific tmSecurityName to a SNMP engine securityName by the security model. A security model, like the TSM security model [RFC5591], may perform an identity mapping or a more complex mapping to derive the securityName from the tmSecurityName offered by the TLS Transport Model.",
      "ja": "このtmSecurityNameは、後にセキュリティモデルによって、SNMPエンジンのsecurityNameにTLSTM特定tmSecurityNameから翻訳することができます。セキュリティモデルは、TSMのセキュリティモデル[RFC5591]のように、アイデンティティマッピングまたはTLS輸送モデルが提供するtmSecurityNameからセキュリティ名を導出するために、より複雑なマッピングを行うことができます。"
    },
    {
      "indent": 3,
      "text": "The standard View-Based Access Control Model (VACM) access control model constrains securityNames to be 32 octets or less in length. A TLSTM generated tmSecurityName, possibly in combination with a messaging or security model that increases the length of the securityName, might cause the securityName length to exceed 32 octets. For example, a 32-octet tmSecurityName derived from an IPv6 address, paired with a TSM prefix, will generate a 36-octet securityName. Such a securityName will not be able to be used with standard VACM or TARGET MIB modules. Operators should be careful to select algorithms and subjectAltNames to avoid this situation.",
      "ja": "標準のビューベースアクセス制御モデル（VACM）アクセス制御モデルは、長さが32オクテット以下であることがsecurityNamesを制約します。 TLSTMはおそらくのsecurityNameの長さを増加させるメッセージまたはセキュリティモデルとの組み合わせで、tmSecurityNameを生成し、セキュリティ名の長さは32個のオクテットを超えて発生する可能性があります。例えば、TSMプレフィックスと対になってIPv6アドレスに由来する32オクテットのtmSecurityNameは、36オクテットのsecurityNameを生成します。そのようなセキュリティ名は、標準VACM又はTARGET MIBモジュールと共に使用することができなくなります。オペレータは、このような状況を回避するためのアルゴリズムとsubjectAltNamesをを選択するように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "A pictorial view of the complete transformation process (using the TSM security model for the example) is shown below:",
      "ja": "完全な変換処理（例えばTSMセキュリティモデルを使用して）の絵画図を以下に示します。"
    },
    {
      "indent": 4,
      "text": "+-------------+     +-------+                   +-----+\n| Certificate |     |       |                   |     |\n|    Path     |     | TLSTM |  tmSecurityName   | TSM |\n| Validation  | --> |       | ----------------->|     |\n+-------------+     +-------+                   +-----+\n                                                    |\n                                                    | securityName\n                                                    V\n                                                +-------------+\n                                                | application |\n                                                +-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.2. (D)TLS Usage",
      "section_title": true,
      "ja": "4.2。 （D）TLSの使用"
    },
    {
      "indent": 3,
      "text": "(D)TLS MUST negotiate a cipher_suite that uses X.509 certificates for authentication, and MUST authenticate both the client and the server. The mandatory-to-implement cipher_suite is specified in the TLS specification [RFC5246].",
      "ja": "（D）TLS認証用のX.509証明書を使用して暗号_スイートを交渉しなければならない、そしてクライアントとサーバーの両方を認証する必要があります。強制的に実装暗号_スイートは、TLS仕様[RFC5246]で指定されています。"
    },
    {
      "indent": 3,
      "text": "TLSTM verifies the certificates when the connection is opened (see Section 5.3). For this reason, TLS renegotiation with different certificates MUST NOT be done. That is, implementations MUST either disable renegotiation completely (RECOMMENDED), or they MUST present the same certificate during renegotiation (and MUST verify that the other end presented the same certificate).",
      "ja": "TLSTMは（5.3節を参照）、接続が開かれたときに、証明書を検証します。このため、異なる証明書とTLSの再交渉が行われてはなりません。すなわち、実装が完全に（推奨）のいずれか無効再ネゴシエーションなければならない、またはそれらは再ネゴシエーションの間、同一の証明書を提示しなければならない（及び他端が同一の証明書を提示していることを確認しなければなりません）。"
    },
    {
      "indent": 3,
      "text": "For DTLS over UDP, each SNMP message MUST be placed in a single UDP datagram; it MAY be split to multiple DTLS records. In other words, if a single datagram contains multiple DTLS application_data records, they are concatenated when received. The TLSTM implementation SHOULD return an error if the SNMP message does not fit in the UDP datagram, and thus cannot be sent.",
      "ja": "UDP上DTLSため、各SNMPメッセージは、単一のUDPデータグラムに置かなければなりません。それは、複数のDTLSレコードに分割することができます。単一のデータグラムが複数のDTLS application_dataのレコードが含まれている場合、受信時に言い換えれば、それらは連結されます。 SNMPメッセージは、UDPデータグラムに収まらないため、送信できない場合TLSTMの実装では、エラーを返すべきです。"
    },
    {
      "indent": 3,
      "text": "For DTLS over UDP, the DTLS server implementation MUST support DTLS cookies ([RFC4347] already requires that clients support DTLS cookies). Implementations are not required to perform the cookie exchange for every DTLS handshake; however, enabling it by default is RECOMMENDED.",
      "ja": "UDP上のDTLSの場合は、DTLSサーバの実装は、（[RFC4347]はすでにクライアントがDTLS Cookieをサポートすることを要求する）DTLSクッキーをサポートしなければなりません。実装はすべてのDTLSハンドシェイクのためのクッキー交換を実行する必要はありません。ただし、デフォルトでそれを有効にすると、推奨されます。"
    },
    {
      "indent": 3,
      "text": "For DTLS, replay protection MUST be used.",
      "ja": "DTLSの場合は、再生保護を使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.3. SNMP Services",
      "section_title": true,
      "ja": "4.3。 SNMPサービス"
    },
    {
      "indent": 3,
      "text": "This section describes the services provided by the TLS Transport Model with their inputs and outputs. The services are between the Transport Model and the Dispatcher.",
      "ja": "このセクションでは、入力と出力とのTLS輸送モデルが提供するサービスについて説明します。サービスは、輸送モデルとディスパッチャの間です。"
    },
    {
      "indent": 3,
      "text": "The services are described as primitives of an abstract service interface (ASI) and the inputs and outputs are described as abstract data elements as they are passed in these abstract service primitives.",
      "ja": "サービスは、抽象サービス・インターフェース（ASI）のプリミティブとして記載されており、それらは、これらの抽象サービスプリミティブに渡されるように入力と出力は、抽象データ要素として記載されています。"
    },
    {
      "indent": 0,
      "text": "4.3.1. SNMP Services for an Outgoing Message",
      "section_title": true,
      "ja": "4.3.1。送信メッセージのためのSNMPサービス"
    },
    {
      "indent": 3,
      "text": "The Dispatcher passes the information to the TLS Transport Model using the ASI defined in the Transport Subsystem:",
      "ja": "Dispatcherは輸送サブシステムで定義されたASIを使用してTLS輸送モデルに情報を渡します。"
    },
    {
      "indent": 6,
      "text": "statusInformation = sendMessage( IN destTransportDomain -- transport domain to be used IN destTransportAddress -- transport address to be used IN outgoingMessage -- the message to send IN outgoingMessageLength -- its length IN tmStateReference -- reference to transport state )",
      "ja": "statusInformationを=のsendMessage（destTransportDomain IN  - 輸送ドメインがdestTransportAddressで使用する - のoutgoingMessageで使用するトランスポート・アドレス -  outgoingMessageLengthで送信するメッセージ -  tmStateReferenceその長さ - 状態を輸送する参照）"
    },
    {
      "indent": 3,
      "text": "The abstract data elements returned from or passed as parameters into the abstract service primitives are as follows:",
      "ja": "次のように返されるか、抽象サービスプリミティブにパラメータとして渡された抽象データ要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation: An indication of whether the sending of the message was successful. If not, it is an indication of the problem.",
      "ja": "statusInformationを：メッセージの送信が成功したかどうかの表示。そうでない場合、それは問題の指標です。"
    },
    {
      "indent": 3,
      "text": "destTransportDomain: The transport domain for the associated destTransportAddress. The Transport Model uses this parameter to determine the transport type of the associated destTransportAddress. This document specifies the snmpTLSTCPDomain and the snmpDTLSUDPDomain transport domains.",
      "ja": "destTransportDomain：関連するdestTransportAddressのための輸送ドメイン。輸送モデルは、関連するdestTransportAddressのトランスポート・タイプを決定するために、このパラメータを使用しています。この文書では、snmpTLSTCPDomainとsnmpDTLSUDPDomain輸送ドメインを指定します。"
    },
    {
      "indent": 3,
      "text": "destTransportAddress: The transport address of the destination TLS Transport Model in a format specified by the SnmpTLSAddress TEXTUAL-CONVENTION.",
      "ja": "destTransportAddress：SnmpTLSAddress TEXTUAL-CONVENTIONで指定された形式で宛先TLS輸送モデルのトランスポートアドレス。"
    },
    {
      "indent": 3,
      "text": "outgoingMessage: The outgoing message to send to (D)TLS for encapsulation and transmission.",
      "ja": "outgoingMessage：発信メッセージは、カプセル化及び送信のために（D）TLSに送信します。"
    },
    {
      "indent": 3,
      "text": "outgoingMessageLength: The length of the outgoingMessage.",
      "ja": "outgoingMessage長さ：のoutgoingMessageの長さ。"
    },
    {
      "indent": 3,
      "text": "tmStateReference: A reference used to pass model-specific and mechanism-specific parameters between the Transport Subsystem and transport-aware Security Models.",
      "ja": "tmStateReference：トランスポートサブシステムと輸送対応セキュリティモデルとの間のモデル固有の機構固有のパラメータを渡すために使用される参照。"
    },
    {
      "indent": 0,
      "text": "4.3.2. SNMP Services for an Incoming Message",
      "section_title": true,
      "ja": "4.3.2。着信メッセージのためのSNMPサービス"
    },
    {
      "indent": 3,
      "text": "The TLS Transport Model processes the received message from the network using the (D)TLS service and then passes it to the Dispatcher using the following ASI:",
      "ja": "TLSトランスポートモデル（D）TLSサービスを用いてネットワークから受信したメッセージを処理し、次のASIを使用して、ディスパッチャに渡します。"
    },
    {
      "indent": 6,
      "text": "statusInformation = receiveMessage( IN transportDomain -- origin transport domain IN transportAddress -- origin transport address IN incomingMessage -- the message received IN incomingMessageLength -- its length IN tmStateReference -- reference to transport state )",
      "ja": "statusInformationを= receiveMessage（transportDomain IN  -  transportAddress原点輸送ドメイン -  incomingMessage原点輸送アドレス -  incomingMessageLengthで受信したメッセージ -  tmStateReferenceその長さ - 状態を輸送する参照）"
    },
    {
      "indent": 3,
      "text": "The abstract data elements returned from or passed as parameters into the abstract service primitives are as follows:",
      "ja": "次のように返されるか、抽象サービスプリミティブにパラメータとして渡された抽象データ要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "statusInformation: An indication of whether the passing of the message was successful. If not, it is an indication of the problem.",
      "ja": "statusInformationを：メッセージの受け渡しが成功したかどうかの表示。そうでない場合、それは問題の指標です。"
    },
    {
      "indent": 3,
      "text": "transportDomain: The transport domain for the associated transportAddress. This document specifies the snmpTLSTCPDomain and the snmpDTLSUDPDomain transport domains.",
      "ja": "transportDomain：関連するtransportAddressのための輸送ドメイン。この文書では、snmpTLSTCPDomainとsnmpDTLSUDPDomain輸送ドメインを指定します。"
    },
    {
      "indent": 3,
      "text": "transportAddress: The transport address of the source of the received message in a format specified by the SnmpTLSAddress TEXTUAL-CONVENTION.",
      "ja": "transportAddress：SnmpTLSAddressテキストの表記で指定された形式で受信されたメッセージの送信元のトランスポート・アドレス。"
    },
    {
      "indent": 3,
      "text": "incomingMessage: The whole SNMP message after being processed by (D)TLS.",
      "ja": "incomingMessage：（D）TLSによって処理された後の全体SNMPメッセージ。"
    },
    {
      "indent": 3,
      "text": "incomingMessageLength: The length of the incomingMessage.",
      "ja": "incomingMessageLength：incomingMessageの長さ。"
    },
    {
      "indent": 3,
      "text": "tmStateReference: A reference used to pass model-specific and mechanism-specific parameters between the Transport Subsystem and transport-aware Security Models.",
      "ja": "tmStateReference：トランスポートサブシステムと輸送対応セキュリティモデルとの間のモデル固有の機構固有のパラメータを渡すために使用される参照。"
    },
    {
      "indent": 0,
      "text": "4.4. Cached Information and References",
      "section_title": true,
      "ja": "4.4。キャッシュされた情報と参考文献"
    },
    {
      "indent": 3,
      "text": "When performing SNMP processing, there are two levels of state information that may need to be retained: the immediate state linking a request-response pair, and potentially longer-term state relating to transport and security. \"Transport Subsystem for the Simple Network Management Protocol (SNMP)\" [RFC5590] defines general requirements for caches and references.",
      "ja": "即時要求 - 応答ペアをリンク状態、およびトランスポートおよびセキュリティに関連する潜在的な長期的状態：SNMP処理を行う際に、保持される必要があり得る状態情報の2つのレベルがあります。 [RFC5590]「簡易ネットワーク管理プロトコル（SNMP）のためのトランスポートサブシステムは、」キャッシュおよび参照のための一般的な要件を定義します。"
    },
    {
      "indent": 0,
      "text": "4.4.1. TLS Transport Model Cached Information",
      "section_title": true,
      "ja": "4.4.1。 TLS輸送モデルキャッシュされた情報"
    },
    {
      "indent": 3,
      "text": "The TLS Transport Model has specific responsibilities regarding the cached information. See the Elements of Procedure in Section 5 for detailed processing instructions on the use of the tmStateReference fields by the TLS Transport Model.",
      "ja": "TLS輸送モデルは、キャッシュされた情報についての具体的な責任を持っています。 TLS輸送モデルによるtmStateReferenceフィールドの使用に関する詳細な処理手順については、第5章の手順の要素を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.4.1.1. tmSecurityName",
      "section_title": true,
      "ja": "4.4.1.1。 tmSecurityName"
    },
    {
      "indent": 3,
      "text": "The tmSecurityName MUST be a human-readable name (in snmpAdminString format) representing the identity that has been set according to the procedures in Section 5. The tmSecurityName MUST be constant for all traffic passing through a single TLSTM session. Messages MUST NOT be sent through an existing (D)TLS connection that was established using a different tmSecurityName.",
      "ja": "tmSecurityNameはtmSecurityNameが単一TLSTMセッションを通過するすべてのトラフィックに対して一定でなければならない第5の手順に従って設定されたIDを表す（れるSnmpAdminString形式）人間可読な名前でなければなりません。メッセージは異なるtmSecurityNameを使用して確立された既存の（D）TLS接続を介して送信されてはいけません。"
    },
    {
      "indent": 3,
      "text": "On the (D)TLS server side of a connection, the tmSecurityName is derived using the procedures described in Section 5.3.2 and the SNMP-TLS-TM-MIB's snmpTlstmCertToTSNTable DESCRIPTION clause.",
      "ja": "接続の（D）TLSサーバ側で、tmSecurityNameは、第5.3.2節に記載の手順とSNMP-TLS-TM-MIBのsnmpTlstmCertToTSNTable説明句を使用して導出されます。"
    },
    {
      "indent": 3,
      "text": "On the (D)TLS client side of a connection, the tmSecurityName is presented to the TLS Transport Model by the security model through the tmStateReference. This tmSecurityName is typically a copy of or is derived from the securityName that was passed by application (possibly because of configuration specified in the SNMP-TARGET-MIB). The Security Model likely derived the tmSecurityName from the securityName presented to the Security Model by the application (possibly because of configuration specified in the SNMP-TARGET-MIB).",
      "ja": "接続の（D）TLSクライアント側では、tmSecurityNameはtmStateReferenceを通じてセキュリティモデルによってTLS輸送モデルに提示されます。このtmSecurityNameは、典型的には、のコピーであるか（おそらくSNMP-TARGET-MIBで指定された構成の）アプリケーションによって渡されたセキュリティ名に由来します。セキュリティモデルは、おそらく（おそらくSNMP-TARGET-MIBで指定された構成の）アプリケーションによってセキュリティモデルに提示セキュリティ名からtmSecurityNameを導出しました。"
    },
    {
      "indent": 3,
      "text": "Transport-Model-aware security models derive tmSecurityName from a securityName, possibly configured in MIB modules for notifications and access controls. Transport Models SHOULD use predictable tmSecurityNames so operators will know what to use when configuring MIB modules that use securityNames derived from tmSecurityNames. The TLSTM generates predictable tmSecurityNames based on the configuration found in the SNMP-TLS-TM-MIB's snmpTlstmCertToTSNTable and relies on the network operators to have configured this table appropriately.",
      "ja": "トランスポートモデル対応のセキュリティモデルは、おそらく通知およびアクセス制御のためのMIBモジュールで構成され、セキュリティ名からtmSecurityNameを導き出します。事業者はtmSecurityNames由来securityNamesを使用するMIBモジュールを設定するときに使用するものを知っているだろうので、輸送モデルは、予測可能なtmSecurityNamesを使用すべきです。 TLSTMは、SNMP-TLSTM-MIBのsnmpTlstmCertToTSNTableで見つかった構成に基づいて予測可能なtmSecurityNamesを生成し、適切にこのテーブルを設定しているためにネットワークオペレータに依存しています。"
    },
    {
      "indent": 0,
      "text": "4.4.1.2. tmSessionID",
      "section_title": true,
      "ja": "4.4.1.2。 tmSessionID"
    },
    {
      "indent": 3,
      "text": "The tmSessionID MUST be recorded per message at the time of receipt. When tmSameSecurity is set, the recorded tmSessionID can be used to determine whether the (D)TLS connection available for sending a corresponding outgoing message is the same (D)TLS connection as was used when receiving the incoming message (e.g., a response to a request).",
      "ja": "tmSessionIDは、領収書の時点でメッセージごとに記録されなければなりません。 tmSameSecurityが設定されている場合、記録tmSessionIDは、対応する送信メッセージを送信するために利用可能な（D）TLS接続は、着信メッセージ（例えば、への応答を受信したときに使用したのと同じ（D）TLS接続であるかどうかを決定するために使用することができます要求）。"
    },
    {
      "indent": 0,
      "text": "4.4.1.3. Session State",
      "section_title": true,
      "ja": "4.4.1.3。セッション状態"
    },
    {
      "indent": 3,
      "text": "The per-session state that is referenced by tmStateReference may be saved across multiple messages in a Local Configuration Datastore. Additional session/connection state information might also be stored in a Local Configuration Datastore.",
      "ja": "tmStateReferenceによって参照されるセッションごとの状態は、ローカル設定データストアに複数のメッセージ間で保存することができます。追加のセッション/接続状態情報は、ローカルコンフィギュレーションデータストアに格納される可能性があります。"
    },
    {
      "indent": 0,
      "text": "5. Elements of Procedure",
      "section_title": true,
      "ja": "手順5.要素"
    },
    {
      "indent": 3,
      "text": "Abstract service interfaces have been defined by [RFC3411] and further augmented by [RFC5590] to describe the conceptual data flows between the various subsystems within an SNMP entity. The TLSTM uses some of these conceptual data flows when communicating between subsystems.",
      "ja": "抽象サービス・インターフェースは、[RFC3411]で定義され、さらにSNMPエンティティ内の様々なサブシステム間を流れる概念的なデータを記述するために[RFC5590]によって拡張されてきました。 TLSTMは、サブシステム間の通信時に、これらの概念のデータの一部が流入する使用します。"
    },
    {
      "indent": 3,
      "text": "To simplify the elements of procedure, the release of state information is not always explicitly specified. As a general rule, if state information is available when a message gets discarded, the message-state information should also be released. If state information is available when a session is closed, the session state information should also be released. Sensitive information, like cryptographic keys, should be overwritten appropriately prior to being released.",
      "ja": "手順の要素を簡単にするために、状態情報のリリースは常に明示的に指定されていません。メッセージは破棄されますときの状態情報が利用可能な場合は一般的なルールとして、メッセージの状態情報も解放されなければなりません。セッションが閉じられたときの状態情報が利用可能な場合、セッション状態情報も解放されなければなりません。機密情報は、暗号化キーのように、放出される前に適切に上書きされなければなりません。"
    },
    {
      "indent": 3,
      "text": "An error indication in statusInformation will typically include the Object Identifier (OID) and value for an incremented error counter. This may be accompanied by the requested securityLevel and the tmStateReference. Per-message context information is not accessible to Transport Models, so for the returned counter OID and value, contextEngine would be set to the local value of snmpEngineID and contextName to the default context for error counters.",
      "ja": "statusInformationを中にエラー表示は、典型的には、オブジェクト識別子（OID）と増分エラーカウンタの値を含むであろう。これは、要求されたsecurityLevelとtmStateReferenceを伴うことがあります。返されたカウンタOIDと値のため、contextEngineはエラーカウンタのデフォルトのコンテキストへのsnmpEngineIDとのcontextNameのローカル値に設定されますので、メッセージごとのコンテキスト情報は、モデルを輸送するためにアクセスできません。"
    },
    {
      "indent": 0,
      "text": "5.1. Procedures for an Incoming Message",
      "section_title": true,
      "ja": "5.1。着信メッセージのための手順"
    },
    {
      "indent": 3,
      "text": "This section describes the procedures followed by the (D)TLS Transport Model when it receives a (D)TLS protected packet. The required functionality is broken into two different sections.",
      "ja": "このセクションでは、（D）TLS保護パケットを受信した場合（D）TLS輸送モデルに続く手順を記載しています。必要な機能は、2つの異なるセクションに分割されます。"
    },
    {
      "indent": 3,
      "text": "Section 5.1.1 describes the processing required for de-multiplexing multiple DTLS connections, which is specifically needed for DTLS over UDP sessions. It is assumed that TLS protocol implementations already provide appropriate message demultiplexing.",
      "ja": "5.1.1項では、具体的UDPセッションでDTLSのために必要とされる逆多重化、複数のDTLS接続に必要な処理を記述しています。 TLSプロトコル実装が既に適切なメッセージ分離を提供することが想定されます。"
    },
    {
      "indent": 3,
      "text": "Section 5.1.2 describes the transport processing required once the (D)TLS processing has been completed. This will be needed for all (D)TLS-based connections.",
      "ja": "セクション5.1.2（D）TLS処理が完了した後に必要なトランスポート処理について説明します。これは、すべての（D）TLSベースの接続のために必要とされるであろう。"
    },
    {
      "indent": 0,
      "text": "5.1.1. DTLS over UDP Processing for Incoming Messages",
      "section_title": true,
      "ja": "5.1.1。受信メッセージのためのUDP処理よりDTLS"
    },
    {
      "indent": 3,
      "text": "Demultiplexing of incoming packets into separate DTLS sessions MUST be implemented. For connection-oriented transport protocols, such as TCP, the transport protocol takes care of demultiplexing incoming packets to the right connection. For DTLS over UDP, this demultiplexing will either need to be done within the DTLS implementation, if supported, or by the TLSTM implementation.",
      "ja": "別DTLSセッションに入ってくるパケットの多重分離を実施しなければなりません。 TCPのような接続指向のトランスポートプロトコルについては、トランスポート・プロトコルは、右の接続に着信パケットを分波の世話をします。 UDP上のDTLSの場合、この分離はサポートされている場合、またはTLSTMの実装により、DTLS実装内で実行する必要がありますどちらか。"
    },
    {
      "indent": 3,
      "text": "Like TCP, DTLS over UDP uses the four-tuple <source IP, destination IP, source port, destination port> for identifying the connection (and relevant DTLS connection state). This means that when establishing a new session, implementations MUST use a different UDP source port number for each active connection to a remote destination IP-address/port-number combination to ensure the remote entity can disambiguate between multiple connections.",
      "ja": "TCPのように、UDP上DTLS接続（及び関連DTLS接続状態）を識別するための4つのタプル<送信元IP、宛先IP、送信元ポート、宛先ポート>を使用します。これは、新しいセッションを確立するとき、実装が複数の接続の間に明確にすることができる遠隔エンティティを確実にするために、リモートの宛先IPアドレス/ポート番号の組み合わせに対する各アクティブな接続のために異なるUDPソースポート番号を使用しなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "If demultiplexing received UDP datagrams to DTLS connection state is done by the TLSTM implementation (instead of the DTLS implementation), the steps below describe one possible method to accomplish this.",
      "ja": "分離はDTLS接続状態にUDPデータグラムを受信した場合（代わりDTLS実装の）TLSTM実装によって行われ、以下の手順は、これを達成する一つの可能​​な方法を説明します。"
    },
    {
      "indent": 3,
      "text": "The important output results from the steps in this process are the remote transport address, incomingMessage, incomingMessageLength, and the tlstmSessionID.",
      "ja": "このプロセスのステップからの重要な出力結果は、incomingMessage、incomingMessageLength、およびtlstmSessionIDリモートトランスポートアドレスです。"
    },
    {
      "indent": 3,
      "text": "1) The TLS Transport Model examines the raw UDP message, in an implementation-dependent manner.",
      "ja": "1）TLS輸送モデルは実装依存的に、生のUDPメッセージを検査します。"
    },
    {
      "indent": 3,
      "text": "2) The TLS Transport Model queries the Local Configuration Datastore (LCD) (see [RFC3411] Section 3.4.2) using the transport parameters (source and destination IP addresses and ports) to determine if a session already exists.",
      "ja": "2）TLSトランスポートモデルは、セッションが既に存在するかどうかを決定するために、トランスポートパラメータ（送信元および宛先IPアドレスおよびポート）を使用して）ローカル設定データストア（LCD）（参照[RFC3411]セクション3.4.2に問い合わせます。"
    },
    {
      "indent": 7,
      "text": "2a)  If a matching entry in the LCD does not exist, then the UDP\n     packet is passed to the DTLS implementation for processing.\n     If the DTLS implementation decides to continue with the\n     connection and allocate state for it, it returns a new DTLS\n     connection handle (an implementation dependent detail).  In this case, TLSTM selects a new tlstmSessionId, and caches\n     this and the DTLS connection handle as a new entry in the\n     LCD (indexed by the transport parameters).  If the DTLS\n     implementation returns an error or does not allocate\n     connection state (which can happen with the stateless cookie\n     exchange), processing stops.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "2b) If a session does exist in the LCD, then its DTLS connection handle (an implementation dependent detail) and its tlstmSessionId is extracted from the LCD. The UDP packet and the connection handle is passed to the DTLS implementation. If the DTLS implementation returns success but does not return an incomingMessage and an incomingMessageLength then processing stops (this is the case when the UDP datagram contained DTLS handshake messages, for example). If the DTLS implementation returns an error then processing stops.",
      "ja": "2b）のセッションは、DTLS接続ハンドル（実装依存の詳細）次に、LCDに存在し、そのtlstmSessionIdはLCDから抽出された場合。 UDPパケットおよび接続ハンドルは、DTLS実装に渡されます。 DTLSの実装は成功を返しますがincomingMessage、その後、停止を処理incomingMessageLengthを（これはUDPデータグラムがDTLSが、例えば、メッセージをハンドシェイク含まれている場合です）戻らない場合。 DTLS実装がエラーを返した場合、処理は停止します。"
    },
    {
      "indent": 3,
      "text": "3) Retrieve the incomingMessage and an incomingMessageLength from DTLS. These results and the tlstmSessionID are used below in Section 5.1.2 to complete the processing of the incoming message.",
      "ja": "3）incomingMessage及びDTLSからincomingMessageLengthを取得します。これらの結果とtlstmSessionIDは、着信メッセージの処理を完了するために、セクション5.1.2に以下で使用されます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Transport Processing for Incoming SNMP Messages",
      "section_title": true,
      "ja": "5.1.2。着信SNMPメッセージの転送処理"
    },
    {
      "indent": 3,
      "text": "The procedures in this section describe how the TLS Transport Model should process messages that have already been properly extracted from the (D)TLS stream. Note that care must be taken when processing messages originating from either TLS or DTLS to ensure they're complete and single. For example, multiple SNMP messages can be passed through a single DTLS message and partial SNMP messages may be received from a TLS stream. These steps describe the processing of a singular SNMP message after it has been delivered from the (D)TLS stream.",
      "ja": "このセクションの手順では、TLS輸送モデルは、すでに適切に（D）TLSストリームから抽出されたメッセージを処理する方法を説明します。彼らは完全な単一かどうかを確認するために、TLSまたはDTLSのいずれかから送信されたメッセージを処理するときには注意する必要があります。例えば、複数のSNMPメッセージは、単一のDTLSメッセージを通過することができ、部分的なSNMPメッセージは、TLSストリームから受信することができます。それは（D）TLSストリームから配信された後、これらのステップは、特異SNMPメッセージの処理を記載しています。"
    },
    {
      "indent": 3,
      "text": "1) Determine the tlstmSessionID for the incoming message. The tlstmSessionID MUST be a unique session identifier for this (D)TLS connection. The contents and format of this identifier are implementation dependent as long as it is unique to the session. A session identifier MUST NOT be reused until all references to it are no longer in use. The tmSessionID is equal to the tlstmSessionID discussed in Section 5.1.1. tmSessionID refers to the session identifier when stored in the tmStateReference and tlstmSessionID refers to the session identifier when stored in the LCD. They MUST always be equal when processing a given session's traffic.",
      "ja": "1）着信メッセージのtlstmSessionIDを決定します。 tlstmSessionIDこの（D）TLS接続の一意のセッション識別子でなければなりません。それがセッションに固有のものであるとして、この識別子の内容と形式は限り実装に依存しています。それへのすべての参照が使用されなくなっているまで、セッション識別子を再利用しないてはなりません。 tmSessionIDは、セクション5.1.1で説明しtlstmSessionIDに等しいです。 tmStateReferenceとtlstmSessionIDに格納されている場合tmSessionIDはLCDに格納されているときにセッション識別子を指すセッション識別子を指します。与えられたセッションのトラフィックを処理するときに彼らはいつも同じでなければなりません。"
    },
    {
      "indent": 7,
      "text": "If this is the first message received through this session, and\nthe session does not have an assigned tlstmSessionID yet, then\nthe snmpTlstmSessionAccepts counter is incremented and a\ntlstmSessionID for the session is created.  This will only happen\non the server side of a connection because a client would have\nalready assigned a tlstmSessionID during the openSession()\ninvocation.  Implementations may have performed the procedures\ndescribed in Section 5.3.2 prior to this point or they may\nperform them now, but the procedures described in Section 5.3.2\nMUST be performed before continuing beyond this point.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2) Create a tmStateReference cache for the subsequent reference and assign the following values within it:",
      "ja": "2）その後の参照のためtmStateReferenceキャッシュを作成し、その中に次の値を割り当てます。"
    },
    {
      "indent": 7,
      "text": "tmTransportDomain  = snmpTLSTCPDomain or snmpDTLSUDPDomain as\n   appropriate.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "tmTransportAddress = The address from which the message originated.",
      "ja": "tmTransportAddressは、メッセージが発信されたアドレスを=。"
    },
    {
      "indent": 7,
      "text": "tmSecurityLevel = The derived tmSecurityLevel for the session, as discussed in Sections 3.1.2 and 5.3.",
      "ja": "セクション3.1.2および5.3で説明したようにtmSecurityLevelは、セッションの由来tmSecurityLevelを=。"
    },
    {
      "indent": 7,
      "text": "tmSecurityName = The derived tmSecurityName for the session as discussed in Section 5.3. This value MUST be constant during the lifetime of the session.",
      "ja": "tmSecurityNameは、セクション5.3で議論するようにセッションの由来tmSecurityNameを=。この値は、セッションの存続期間中に一定でなければなりません。"
    },
    {
      "indent": 7,
      "text": "tmSessionID = The tlstmSessionID described in step 1 above.",
      "ja": "tmSessionIDは= tlstmSessionIDは、上記のステップ1で説明しました。"
    },
    {
      "indent": 3,
      "text": "3) The incomingMessage and incomingMessageLength are assigned values from the (D)TLS processing.",
      "ja": "3）incomingMessageとincomingMessageLengthは、（D）TLS処理から値が割り当てられます。"
    },
    {
      "indent": 3,
      "text": "4) The TLS Transport Model passes the transportDomain, transportAddress, incomingMessage, and incomingMessageLength to the Dispatcher using the receiveMessage ASI:",
      "ja": "4）TLSトランスポートモデルreceiveMessage ASIを使用してディスパッチャにtransportDomain、transportAddress、incomingMessage、及びincomingMessageLengthを渡します。"
    },
    {
      "indent": 6,
      "text": "statusInformation = receiveMessage( IN transportDomain -- snmpTLSTCPDomain or snmpDTLSUDPDomain, IN transportAddress -- address for the received message IN incomingMessage -- the whole SNMP message from (D)TLS IN incomingMessageLength -- the length of the SNMP message IN tmStateReference -- transport info )",
      "ja": "statusInformationを= receiveMessage（transportDomain IN  -  transportAddress IN snmpTLSTCPDomain又はsnmpDTLSUDPDomain、 -  incomingMessageで受信したメッセージのアドレス -  tmStateReference IN SNMPメッセージの長さ -   - トランスポート情報（D）incomingMessageLength IN TLSから全体SNMPメッセージ）"
    },
    {
      "indent": 0,
      "text": "5.2. Procedures for an Outgoing SNMP Message",
      "section_title": true,
      "ja": "5.2。送信SNMPメッセージのための手順"
    },
    {
      "indent": 3,
      "text": "The Dispatcher sends a message to the TLS Transport Model using the following ASI:",
      "ja": "Dispatcherは、以下のASIを使用して、TLS輸送モデルにメッセージを送信します。"
    },
    {
      "indent": 6,
      "text": "statusInformation = sendMessage( IN destTransportDomain -- transport domain to be used IN destTransportAddress -- transport address to be used IN outgoingMessage -- the message to send IN outgoingMessageLength -- its length IN tmStateReference -- transport info )",
      "ja": "statusInformationを=のsendMessage（destTransportDomain IN  - 輸送ドメインがdestTransportAddressで使用する - のoutgoingMessageに使用するトランスポート・アドレス -  outgoingMessageLengthで送信するメッセージ -  tmStateReferenceでの長さ - 交通情報）"
    },
    {
      "indent": 3,
      "text": "This section describes the procedure followed by the TLS Transport Model whenever it is requested through this ASI to send a message.",
      "ja": "このセクションでは、メッセージを送信するには、このASIによって要求されるたびにTLS輸送モデルに続いて手順を説明します。"
    },
    {
      "indent": 3,
      "text": "1) If tmStateReference does not refer to a cache containing values for tmTransportDomain, tmTransportAddress, tmSecurityName, tmRequestedSecurityLevel, and tmSameSecurity, then increment the snmpTlstmSessionInvalidCaches counter, discard the message, and return the error indication in the statusInformation. Processing of this message stops.",
      "ja": "tmStateReferenceはtmTransportDomain、tmTransportAddress、tmSecurityName、tmRequestedSecurityLevel、及びtmSameSecurityの値を含むキャッシュを参照していない場合1）、次いで、snmpTlstmSessionInvalidCachesカウンタをインクリメントメッセージを破棄し、そしてstatusInformationを中にエラー表示を返します。このメッセージの処理が停止します。"
    },
    {
      "indent": 3,
      "text": "2) Extract the tmSessionID, tmTransportDomain, tmTransportAddress, tmSecurityName, tmRequestedSecurityLevel, and tmSameSecurity values from the tmStateReference. Note: the tmSessionID value may be undefined if no session exists yet over which the message can be sent.",
      "ja": "2）tmStateReferenceからtmSessionID、tmTransportDomain、tmTransportAddress、tmSecurityName、tmRequestedSecurityLevel、及びtmSameSecurity値を抽出します。注：セッションがメッセージを送信することができる上にまだ存在しない場合tmSessionID値は不定であってもよいです。"
    },
    {
      "indent": 3,
      "text": "3) If tmSameSecurity is true and tmSessionID is either undefined or refers to a session that is no longer open, then increment the snmpTlstmSessionNoSessions counter, discard the message, and return the error indication in the statusInformation. Processing of this message stops.",
      "ja": "tmSameSecurityが真であるとtmSessionIDが未定義であるか、またはもはや開いているセッションを参照している場合3）、次いで、snmpTlstmSessionNoSessionsカウンタをインクリメントメッセージを破棄し、そしてstatusInformationを中にエラー表示を返します。このメッセージの処理が停止します。"
    },
    {
      "indent": 3,
      "text": "4) If tmSameSecurity is false and tmSessionID refers to a session that is no longer available, then an implementation SHOULD open a new session, using the openSession() ASI (described in greater detail in step 5b). Instead of opening a new session an implementation MAY return a snmpTlstmSessionNoSessions error to the calling module and stop the processing of the message.",
      "ja": "tmSameSecurityが偽であるとtmSessionIDが使用できなくなったセッションを参照している場合4）、次いで、実装はのOpenSessionを使用して、新しいセッションを開くべきである（）ASI（ステップ5B）でより詳細に説明。代わりに、新しいセッションを開くの実装では、呼び出し元のモジュールにsnmpTlstmSessionNoSessionsエラーを返すと、メッセージの処理を停止することがあります。"
    },
    {
      "indent": 3,
      "text": "5) If tmSessionID is undefined, then use tmTransportDomain, tmTransportAddress, tmSecurityName, and tmRequestedSecurityLevel to see if there is a corresponding entry in the LCD suitable to send the message over.",
      "ja": "tmSessionIDが未定義の場合は5）、メッセージを介して送信するのに適したLCD内の対応するエントリがあるかどうかを確認するためにtmTransportDomain、tmTransportAddress、tmSecurityName、及びtmRequestedSecurityLevelを使用します。"
    },
    {
      "indent": 7,
      "text": "5a)  If there is a corresponding LCD entry, then this session\n     will be used to send the message.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "5b) If there is no corresponding LCD entry, then open a session using the openSession() ASI (discussed further in Section 5.3.1). Implementations MAY wish to offer message buffering to prevent redundant openSession() calls for the same cache entry. If an error is returned from openSession(), then discard the message, discard the tmStateReference, increment the snmpTlstmSessionOpenErrors, return an error indication to the calling module, and stop the processing of the message.",
      "ja": "該当するLCDのエントリが存在しない場合は図5（b））、その後のOpenSession（）ASI（5.3.1節で詳しく説明する）を使用してセッションを開きます。実装は、（冗長のOpenSessionを防ぐために、メッセージバッファリングを提供することを望むかもしれない）同じキャッシュエントリのために呼び出します。エラーが（）のOpenSessionから返された場合、メッセージを破棄する、snmpTlstmSessionOpenErrorsをインクリメントし、tmStateReferenceを破棄呼ぶモジュールにエラー表示を返し、メッセージの処理を停止します。"
    },
    {
      "indent": 3,
      "text": "6) Using either the session indicated by the tmSessionID (if there was one) or the session resulting from a previous step (4 or 5), pass the outgoingMessage to (D)TLS for encapsulation and transmission.",
      "ja": "ものがあった場合6）（tmSessionIDで示されるセッションのいずれかを使用して）、または前のステップ（4または起因するセッション5）、カプセル化および送信のための（D）TLSへのoutgoingMessageを渡します。"
    },
    {
      "indent": 0,
      "text": "5.3. Establishing or Accepting a Session",
      "section_title": true,
      "ja": "5.3。セッションの確立または受け入れ"
    },
    {
      "indent": 3,
      "text": "Establishing a (D)TLS connection as either a client or a server requires slightly different processing. The following two sections describe the necessary processing steps.",
      "ja": "クライアントまたはサーバのいずれかと（D）TLS接続を確立すると、わずかに異なる処理を必要とします。次の2つのセクションでは、必要な処理の手順を記述しています。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Establishing a Session as a Client",
      "section_title": true,
      "ja": "5.3.1。クライアントとしてセッションの確立"
    },
    {
      "indent": 3,
      "text": "The TLS Transport Model provides the following primitive for use by a client to establish a new (D)TLS connection:",
      "ja": "TLS輸送モデルは、新しい（D）TLS接続を確立するためにクライアントが使用するために、次のプリミティブを提供します。"
    },
    {
      "indent": 3,
      "text": "statusInformation = -- errorIndication or success openSession( IN tmStateReference -- transport information to be used OUT tmStateReference -- transport information to be used IN maxMessageSize -- of the sending SNMP entity )",
      "ja": "statusInformationを=  - （tmStateReference、IN  -  tmStateReferenceをOUTに使用するトランスポート情報 -  maxMessageSizeに使用するトランスポート情報 - 送信するSNMPエンティティの）errorIndicationや成功のOpenSession"
    },
    {
      "indent": 3,
      "text": "The following describes the procedure to follow when establishing an SNMP over a (D)TLS connection between SNMP engines for exchanging SNMP messages. This process is followed by any SNMP client's engine when establishing a session for subsequent use.",
      "ja": "以下は、SNMPメッセージを交換するためのSNMPエンジンとの間の（D）TLS接続を介してSNMPを確立する際に従うべき手順を記載しています。その後の使用のためのセッションを確立するときに、このプロセスは、任意のSNMPクライアントのエンジンが続いています。"
    },
    {
      "indent": 3,
      "text": "This procedure MAY be done automatically for an SNMP application that initiates a transaction, such as a command generator, a notification originator, or a proxy forwarder.",
      "ja": "この手順では、このようなコマンドジェネレータ、通知創始者、またはプロキシフォワーダとして、トランザクションを開始するSNMPアプリケーションのために自動的に行うことができます。"
    },
    {
      "indent": 3,
      "text": "1) The snmpTlstmSessionOpens counter is incremented.",
      "ja": "1）snmpTlstmSessionOpensカウンタがインクリメントされます。"
    },
    {
      "indent": 3,
      "text": "2) The client selects the appropriate certificate and cipher_suites for the key agreement based on the tmSecurityName and the tmRequestedSecurityLevel for the session. For sessions being established as a result of an SNMP-TARGET-MIB based operation, the certificate will potentially have been identified via the snmpTlstmParamsTable mapping and the cipher_suites will have to be taken from a system-wide or implementation-specific configuration. If no row in the snmpTlstmParamsTable exists, then implementations MAY choose to establish the connection using a default client certificate available to the application. Otherwise, the certificate and appropriate cipher_suites will need to be passed to the openSession() ASI as supplemental information or configured through an implementation-dependent mechanism. It is also implementation-dependent and possibly policy-dependent how tmRequestedSecurityLevel will be used to influence the security capabilities provided by the (D)TLS connection. However this is done, the security capabilities provided by (D)TLS MUST be at least as high as the level of security indicated by the tmRequestedSecurityLevel parameter. The actual security level of the session is reported in the tmStateReference cache as tmSecurityLevel. For (D)TLS to provide strong authentication, each principal acting as a command generator SHOULD have its own certificate.",
      "ja": "2）クライアントは、セッションのためにtmSecurityNameとtmRequestedSecurityLevelに基づいて鍵合意のための適切な証明書とcipher_suitesを選択します。 SNMP-TARGET-MIB基づく操作の結果として確立されるセッションの場合、証明書は、潜在的にsnmpTlstmParamsTableマッピングを介して識別されているであろうとcipher_suitesは、システム全体または実装固有の設定から取らなければならないであろう。 snmpTlstmParamsTableには行が存在しない場合、実装はアプリケーションで使用可能なデフォルトのクライアント証明書を使用して接続を確立することを選ぶかもしれません。そうでない場合、証明書と適切なcipher_suitesは実装依存機構を介して補足情報としてのOpenSession（）ASIに渡さまたは設定する必要があります。また、実装依存とおそらく政策に依存tmRequestedSecurityLevelは、（D）TLS接続によって提供されるセキュリティ機能に影響を与えるために使用される方法です。しかし、これが行われ、（D）TLSによって提供されるセキュリティ機能はtmRequestedSecurityLevelパラメータによって示されるセキュリティのレベルと少なくとも同程度に高くなければなりません。セッションの実際のセキュリティレベルがtmSecurityLevelとしてtmStateReferenceキャッシュで報告されます。強力な認証を提供するために、（D）TLSのために、コマンド発生器として作用する各プリンシパルが独自の証明書を持っているべきです。"
    },
    {
      "indent": 3,
      "text": "3) Using the destTransportDomain and destTransportAddress values, the client will initiate the (D)TLS handshake protocol to establish session keys for message integrity and encryption.",
      "ja": "3）destTransportDomainとdestTransportAddress値を使用して、クライアントは、メッセージの保全と暗号化のためのセッションキーを確立するために（D）TLSハンドシェーク・プロトコルを開始します。"
    },
    {
      "indent": 7,
      "text": "If the attempt to establish a session is unsuccessful, then\nsnmpTlstmSessionOpenErrors is incremented, an error indication is\nreturned, and processing stops.  If the session failed to open\nbecause the presented server certificate was unknown or invalid,\nthen the snmpTlstmSessionUnknownServerCertificate or\nsnmpTlstmSessionInvalidServerCertificates MUST be incremented and\nan snmpTlstmServerCertificateUnknown or\nsnmpTlstmServerInvalidCertificate notification SHOULD be sent as\nappropriate.  Reasons for server certificate invalidation\nincludes, but is not limited to, cryptographic validation\nfailures and an unexpected presented certificate identity.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4) The (D)TLS client MUST then verify that the (D)TLS server's presented certificate is the expected certificate. The (D)TLS client MUST NOT transmit SNMP messages until the server certificate has been authenticated, the client certificate has been transmitted and the TLS connection has been fully established.",
      "ja": "4）（D）TLSクライアントは、（D）TLSサーバの提示された証明書は、予想の証明書であることを確かめなければなりません。サーバー証明書が認証されるまで、（D）TLSクライアントは、SNMPメッセージを送信してはならない、クライアント証明書が送られてきたとTLS接続が完全に確立されています。"
    },
    {
      "indent": 7,
      "text": "If the connection is being established from a configuration based\non SNMP-TARGET-MIB configuration, then the snmpTlstmAddrTable\nDESCRIPTION clause describes how the verification is done (using\neither a certificate fingerprint, or an identity authenticated\nvia certification path validation).",
      "raw": true
    },
    {
      "indent": 7,
      "text": "If the connection is being established for reasons other than configuration found in the SNMP-TARGET-MIB, then configuration and procedures outside the scope of this document should be followed. Configuration mechanisms SHOULD be similar in nature to those defined in the snmpTlstmAddrTable to ensure consistency across management configuration systems. For example, a command-line tool for generating SNMP GETs might support specifying either the server's certificate fingerprint or the expected host name as a command-line argument.",
      "ja": "接続は、SNMP-TARGET-MIBに見出される構成以外の理由のために確立されている場合、この文書の範囲外の構成と手順に従わなければなりません。構成メカニズムは、管理構成システム全体の一貫性を確保するためsnmpTlstmAddrTableで定義されたものと本質的に類似していなければなりません。たとえば、SNMPを生成するためのコマンドラインツールは、サーバーの証明書のフィンガープリントまたはコマンドライン引数として期待されるホスト名のいずれかを指定してサポートする場合があります取得します。"
    },
    {
      "indent": 3,
      "text": "5) (D)TLS provides assurance that the authenticated identity has been signed by a trusted configured Certification Authority. If verification of the server's certificate fails in any way (for example, because of failures in cryptographic verification or the presented identity did not match the expected named entity) then the session establishment MUST fail, the snmpTlstmSessionInvalidServerCertificates object is incremented. If the session cannot be opened for any reason at all, including cryptographic verification failures and snmpTlstmCertToTSNTable lookup failures, then the snmpTlstmSessionOpenErrors counter is incremented and processing stops.",
      "ja": "5）（D）TLSは、認証されたアイデンティティが信頼構成証明機関によって署名されていることの保証を提供します。サーバの証明書の検証は、（例えば、あるため、暗号化検証または提示アイデンティティの障害に期待されるという名前のエンティティと一致しませんでした）どのような方法で失敗した場合、セッションの確立は失敗しなければなりません、snmpTlstmSessionInvalidServerCertificatesオブジェクトがインクリメントされます。セッションは、暗号化検証の失敗とsnmpTlstmCertToTSNTableルックアップの失敗を含め、すべて、何らかの理由で開くことができない場合は、snmpTlstmSessionOpenErrorsカウンタがインクリメントされ、処理が停止しています。"
    },
    {
      "indent": 3,
      "text": "6) The TLSTM-specific session identifier (tlstmSessionID) is set in the tmSessionID of the tmStateReference passed to the TLS Transport Model to indicate that the session has been established successfully and to point to a specific (D)TLS connection for future use. The tlstmSessionID is also stored in the LCD for later lookup during processing of incoming messages (Section 5.1.2).",
      "ja": "6）tmStateReferenceのtmSessionIDに設定されているTLSTM固有のセッション識別子（tlstmSessionID）は、セッションが正常に確立されていることを示すために、将来の使用のための特定の（D）TLS接続を指すように、TLS輸送モデルに渡されます。 tlstmSessionIDはまた、着信メッセージ（セクション5.1.2）の処理中に後で参照するためのLCDに格納されています。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Accepting a Session as a Server",
      "section_title": true,
      "ja": "5.3.2。サーバーとのセッションを受け入れます"
    },
    {
      "indent": 3,
      "text": "A (D)TLS server should accept new session connections from any client for which it is able to verify the client's credentials. This is done by authenticating the client's presented certificate through a certificate path validation process (e.g., [RFC5280]) or through certificate fingerprint verification using fingerprints configured in the snmpTlstmCertToTSNTable. Afterward, the server will determine the identity of the remote entity using the following procedures.",
      "ja": "（D）TLSサーバは、クライアントの資格情報を確認することができたため、任意のクライアントからの新しいセッションの接続を受け入れる必要があります。これは、証明書パス検証処理（例えば、[RFC5280]）を介して、またはsnmpTlstmCertToTSNTableに構成された指紋を使用して、証明書の指紋照合を通じてクライアントの提示された証明書を認証することによって行われます。その後、サーバーは、次の手順を使用してリモートエンティティのアイデンティティを決定します。"
    },
    {
      "indent": 3,
      "text": "The (D)TLS server identifies the authenticated identity from the (D)TLS client's principal certificate using configuration information from the snmpTlstmCertToTSNTable mapping table. The (D)TLS server MUST request and expect a certificate from the client and MUST NOT accept SNMP messages over the (D)TLS connection until the client has sent a certificate and it has been authenticated. The resulting derived tmSecurityName is recorded in the tmStateReference cache as tmSecurityName. The details of the lookup process are fully described in the DESCRIPTION clause of the snmpTlstmCertToTSNTable MIB object. If any verification fails in any way (for example, because of failures in cryptographic verification or because of the lack of an appropriate row in the snmpTlstmCertToTSNTable), then the session establishment MUST fail, and the snmpTlstmSessionInvalidClientCertificates object is incremented. If the session cannot be opened for any reason at all, including cryptographic verification failures, then the snmpTlstmSessionOpenErrors counter is incremented and processing stops.",
      "ja": "（D）TLSサーバはsnmpTlstmCertToTSNTableマッピングテーブルから設定情報を用いて、（D）TLSクライアントのプリンシパルの証明書から認証IDを識別する。 （D）TLSサーバは要求し、クライアントからの証明書を期待して、クライアントが証明書を送信しており、それが認証されるまで（D）TLS接続上でSNMPメッセージを受け入れてはいけませんしなければなりません。得られた派生tmSecurityNameはtmSecurityNameとしてtmStateReferenceキャッシュに記録されています。ルックアップ・プロセスの詳細は、完全snmpTlstmCertToTSNTable MIBオブジェクトの記述節に記載されています。いずれかの検証（たとえば、なぜなら暗号検証の失敗のため、またはsnmpTlstmCertToTSNTableにおける適切な行の欠如）は、任意の方法で失敗した場合、セッション確立が失敗しなければならない、とsnmpTlstmSessionInvalidClientCertificatesオブジェクトがインクリメントされます。セッションは、暗号化検証の失敗を含め、すべて、何らかの理由で開くことができない場合は、snmpTlstmSessionOpenErrorsカウンタがインクリメントされ、処理が停止しています。"
    },
    {
      "indent": 3,
      "text": "Servers that wish to support multiple principals at a particular port SHOULD make use of a (D)TLS extension that allows server-side principal selection like the Server Name Indication extension defined in Section 3.1 of [RFC4366]. Supporting this will allow, for example, sending notifications to a specific principal at a given TCP or UDP port.",
      "ja": "特定のポートで複数のプリンシパルをサポートしたいサーバーは、[RFC4366]のセクション3.1で定義されたサーバ名表示拡張のようなサーバー側主選択を可能にする（D）TLS拡張子を利用するべきです。これを支援することは、例えば、特定のTCPまたはUDPポートで特定のプリンシパルに通知を送信できるようになります。"
    },
    {
      "indent": 0,
      "text": "5.4. Closing a Session",
      "section_title": true,
      "ja": "5.4。セッションを閉じます"
    },
    {
      "indent": 3,
      "text": "The TLS Transport Model provides the following primitive to close a session:",
      "ja": "TLS輸送モデルは、セッションを閉じるには、次のプリミティブを提供します。"
    },
    {
      "indent": 3,
      "text": "statusInformation = closeSession( IN tmSessionID -- session ID of the session to be closed )",
      "ja": "statusInformationを= closeSession（tmSessionID、IN  - クローズするセッションのセッションID）"
    },
    {
      "indent": 3,
      "text": "The following describes the procedure to follow to close a session between a client and server. This process is followed by any SNMP engine closing the corresponding SNMP session.",
      "ja": "以下は、クライアントとサーバー間のセッションを閉じるには従うべき手順を説明します。このプロセスは、対応するSNMPセッションを閉じる任意のSNMPエンジンが続いています。"
    },
    {
      "indent": 3,
      "text": "1) Increment either the snmpTlstmSessionClientCloses or the snmpTlstmSessionServerCloses counter as appropriate.",
      "ja": "1）必要に応じてカウンタsnmpTlstmSessionClientCloses又はsnmpTlstmSessionServerClosesのいずれかをインクリメント。"
    },
    {
      "indent": 3,
      "text": "2) Look up the session using the tmSessionID.",
      "ja": "2）tmSessionIDを使用してセッションを検索します。"
    },
    {
      "indent": 3,
      "text": "3) If there is no open session associated with the tmSessionID, then closeSession processing is completed.",
      "ja": "tmSessionIDに関連付けられているオープンセッションがない場合3）、次いでcloseSession処理を終了します。"
    },
    {
      "indent": 3,
      "text": "4) Have (D)TLS close the specified connection. This MUST include sending a close_notify TLS Alert to inform the other side that session cleanup may be performed.",
      "ja": "4）は（D）TLSは、指定された接続を閉じます。これは、そのセッションのクリーンアップを実行することができる他の側に通知するためには、close_notify TLSアラートを送信含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "6. MIB Module Overview",
      "section_title": true,
      "ja": "6. MIBモジュールの概要"
    },
    {
      "indent": 3,
      "text": "This MIB module provides management of the TLS Transport Model. It defines needed textual conventions, statistical counters, notifications, and configuration infrastructure necessary for session establishment. Example usage of the configuration tables can be found in Appendix A.",
      "ja": "このMIBモジュールは、TLS輸送モデルの管理を提供します。これは、必要に応じてテキストの表記法、統計カウンタ、通知、およびセッション確立のために必要なコンフィギュレーション・インフラストラクチャを定義します。コンフィギュレーション・テーブルの使用例は、付録Aに記載されています"
    },
    {
      "indent": 0,
      "text": "6.1. Structure of the MIB Module",
      "section_title": true,
      "ja": "6.1。 MIBモジュールの構造"
    },
    {
      "indent": 3,
      "text": "Objects in this MIB module are arranged into subtrees. Each subtree is organized as a set of related objects. The overall structure and assignment of objects to their subtrees, and the intended purpose of each subtree, is shown below.",
      "ja": "このMIBモジュール内のオブジェクトは、サブツリーに配置されています。各サブツリーは、関連するオブジェクトの集合として構成されています。全体的な構造およびそのサブツリーへのオブジェクトの割り当て、及び各サブツリーの意図された目的は、以下に示されています。"
    },
    {
      "indent": 0,
      "text": "6.2. Textual Conventions",
      "section_title": true,
      "ja": "6.2。テキストの表記法"
    },
    {
      "indent": 3,
      "text": "Generic and Common Textual Conventions used in this module can be found summarized at http://www.ops.ietf.org/mib-common-tcs.html.",
      "ja": "このモジュールで使用される汎用的で一般的なテキストの表記法はhttp://www.ops.ietf.org/mib-common-tcs.htmlでまとめています。"
    },
    {
      "indent": 3,
      "text": "This module defines the following new Textual Conventions:",
      "ja": "このモジュールは、次の新しいテキストの表記法を定義します。"
    },
    {
      "indent": 3,
      "text": "o A new TransportAddress format for describing (D)TLS connection addressing requirements.",
      "ja": "O（D）TLS接続アドレッシング要件を記述するための新しいTransportAddressフォーマット。"
    },
    {
      "indent": 3,
      "text": "o A certificate fingerprint allowing MIB module objects to generically refer to a stored X.509 certificate using a cryptographic hash as a reference pointer.",
      "ja": "一般的に、参照ポインタとして暗号ハッシュを使用して格納されたX.509証明書を参照するためにMIBモジュールオブジェクトを許可証明書のフィンガープリントO。"
    },
    {
      "indent": 0,
      "text": "6.3. Statistical Counters",
      "section_title": true,
      "ja": "6.3。統計カウンタ"
    },
    {
      "indent": 3,
      "text": "The SNMP-TLS-TM-MIB defines counters that provide network management stations with information about session usage and potential errors that a device may be experiencing.",
      "ja": "SNMP-TLS-TM-MIBは、セッション使用し、デバイスが発生している可能性があり、潜在的なエラーに関する情報をネットワーク管理ステーションを提供カウンターを定義します。"
    },
    {
      "indent": 0,
      "text": "6.4. Configuration Tables",
      "section_title": true,
      "ja": "6.4。コンフィギュレーション・テーブル"
    },
    {
      "indent": 3,
      "text": "The SNMP-TLS-TM-MIB defines configuration tables that an administrator can use for configuring a device for sending and receiving SNMP messages over (D)TLS. In particular, there are MIB tables that extend the SNMP-TARGET-MIB for configuring (D)TLS certificate usage and a MIB table for mapping incoming (D)TLS client certificates to SNMPv3 tmSecurityNames.",
      "ja": "SNMP-TLS-TM-MIBは、管理者が（D）TLS上SNMPメッセージを送受信するための装置を構成するために使用できる構成テーブルを定義します。具体的には、（D）TLS証明書の使用およびSNMPv3 tmSecurityNamesに入ってくる（D）TLSクライアント証明書をマッピングするためのMIBテーブルを構成するためのSNMP-TARGET-MIBを拡張MIBテーブルがあります。"
    },
    {
      "indent": 0,
      "text": "6.4.1. Notifications",
      "section_title": true,
      "ja": "6.4.1。通知"
    },
    {
      "indent": 3,
      "text": "The SNMP-TLS-TM-MIB defines notifications to alert management stations when a (D)TLS connection fails because a server's presented certificate did not meet an expected value (snmpTlstmServerCertificateUnknown) or because cryptographic validation failed (snmpTlstmServerInvalidCertificate).",
      "ja": "SNMP-TLS-TM-MIBは、（D）TLS接続が失敗したときに、サーバーの提示された証明書は、暗号化検証が失敗した期待値（snmpTlstmServerCertificateUnknown）またはので（snmpTlstmServerInvalidCertificate）を満たしていなかったので、管理ステーションに警告する通知を定義します。"
    },
    {
      "indent": 0,
      "text": "6.5. Relationship to Other MIB Modules",
      "section_title": true,
      "ja": "6.5。他のMIBモジュールとの関係"
    },
    {
      "indent": 3,
      "text": "Some management objects defined in other MIB modules are applicable to an entity implementing the TLS Transport Model. In particular, it is assumed that an entity implementing the SNMP-TLS-TM-MIB will implement the SNMPv2-MIB [RFC3418], the SNMP-FRAMEWORK-MIB [RFC3411], the SNMP-TARGET-MIB [RFC3413], the SNMP-NOTIFICATION-MIB [RFC3413], and the SNMP-VIEW-BASED-ACM-MIB [RFC3415].",
      "ja": "他のMIBモジュールで定義された一部の管理オブジェクトは、TLS輸送モデルを実装するエンティティに適用されます。特に、想定されるのSNMPv2-MIB [RFC3418]、SNMP-FRAMEWORK-MIB [RFC3411]、SNMP-TARGET-MIB [RFC3413]、SNMPを実装するSNMP-TLS-TM-MIBを実装するエンティティ-NOTIFICATION-MIB [RFC3413]、およびSNMP-VIEW-BASED-ACM-MIB [RFC3415]。"
    },
    {
      "indent": 3,
      "text": "The SNMP-TLS-TM-MIB module contained in this document is for managing TLS Transport Model information.",
      "ja": "本文書に含まれているSNMP-TLS-TM-MIBモジュールは、TLS輸送モデルの情報を管理するためのものです。"
    },
    {
      "indent": 0,
      "text": "6.5.1. MIB Modules Required for IMPORTS",
      "section_title": true,
      "ja": "6.5.1。 MIBモジュールは、輸入に必要な"
    },
    {
      "indent": 3,
      "text": "The SNMP-TLS-TM-MIB module imports items from SNMPv2-SMI [RFC2578], SNMPv2-TC [RFC2579], SNMP-FRAMEWORK-MIB [RFC3411], SNMP-TARGET-MIB [RFC3413], and SNMPv2-CONF [RFC2580].",
      "ja": "SNMP-TLS-TM-MIBモジュール輸入のSNMPv2-SMI [RFC2578]から項目のSNMPv2-TC [RFC2579]、SNMP-FRAMEWORK-MIB [RFC3411]、SNMP-TARGET-MIB [RFC3413]、およびSNMPv2-CONF [RFC2580 ]。"
    },
    {
      "indent": 0,
      "text": "7. MIB Module Definition",
      "section_title": true,
      "ja": "7. MIBモジュール定義"
    },
    {
      "indent": 0,
      "text": "SNMP-TLS-TM-MIB DEFINITIONS ::= BEGIN",
      "raw": true
    },
    {
      "indent": 0,
      "text": "IMPORTS MODULE-IDENTITY, OBJECT-TYPE, OBJECT-IDENTITY, mib-2, snmpDomains, Counter32, Unsigned32, Gauge32, NOTIFICATION-TYPE FROM SNMPv2-SMI -- RFC 2578 or any update thereof TEXTUAL-CONVENTION, TimeStamp, RowStatus, StorageType, AutonomousType FROM SNMPv2-TC -- RFC 2579 or any update thereof MODULE-COMPLIANCE, OBJECT-GROUP, NOTIFICATION-GROUP FROM SNMPv2-CONF -- RFC 2580 or any update thereof SnmpAdminString FROM SNMP-FRAMEWORK-MIB -- RFC 3411 or any update thereof snmpTargetParamsName, snmpTargetAddrName FROM SNMP-TARGET-MIB -- RFC 3413 or any update thereof ;",
      "ja": "輸入MODULE-IDENTITY、OBJECT-TYPE、OBJECT-IDENTITY、MIB-2、snmpDomains、Counter32の、Unsigned32の、Gauge32、SNMPv2の-SMIからの通知-TYPE  -  RFC 2578またはテキストの表記、タイムスタンプ、RowStatusの、StorageTypeそれらの任意の更新、 AutonomousTypeのSNMPv2の-TC FROM  -  RFC 2579またはMODULE-COMPLIANCE、オブジェクト・グループ、のSNMPv2-CONF FROM NOTIFICATION-GROUPそれらの任意のアップデート -  RFC 2580またはSNMP-FRAMEWORK-MIBかられるSnmpAdminStringそれらの任意のアップデート -  RFC 3411、または任意の更新そのsnmpTargetParamsName、SNMP-TARGET-MIBからsnmpTargetAddrName  -  RFC 3413、またはそれらの任意のアップデート。"
    },
    {
      "indent": 0,
      "text": "snmpTlstmMIB MODULE-IDENTITY LAST-UPDATED \"201005070000Z\" ORGANIZATION \"ISMS Working Group\" CONTACT-INFO \"WG-EMail: isms@lists.ietf.org Subscribe: isms-request@lists.ietf.org",
      "ja": "snmpTlstmMIB MODULE-IDENTITY LAST-UPDATED \"201005070000Z\" ORGANIZATION \"ISMSワーキンググループ\" CONTACT-INFO「WG-Eメール：isms@lists.ietf.org購読：isms-request@lists.ietf.org"
    },
    {
      "indent": 18,
      "text": "Chairs:\n   Juergen Schoenwaelder\n   Jacobs University Bremen\n   Campus Ring 1\n   28725 Bremen\n   Germany\n   +49 421 200-3587\n   j.schoenwaelder@jacobs-university.de",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Russ Mundy SPARTA, Inc. 7110 Samuel Morse Drive Columbia, MD 21046 USA",
      "ja": "ラス・マンディSPARTA、Inc.の7110サミュエル・モールスドライブコロンビア、MD 21046 USA"
    },
    {
      "indent": 18,
      "text": "Editor: Wes Hardaker SPARTA, Inc. P.O. Box 382 Davis, CA 95617 USA ietf@hardakers.net \"",
      "ja": "編集者：ウェス・ハードフィールドSPARTA、Inc.の私書箱ボックス382デイビス、CA 95617 USA ietf@hardakers.net」"
    },
    {
      "indent": 4,
      "text": "DESCRIPTION \" The TLS Transport Model MIB",
      "ja": "DESCRIPTION \"TLS輸送モデルMIB"
    },
    {
      "indent": 8,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as\nthe document authors.  All rights reserved.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info).\"",
      "ja": "、に基づき許可されており、中に含まれるライセンス条項に従う、簡体BSDライセンスは、IETFドキュメントに関連IETFトラストの法律規定（のセクション4.Cに記載されている変更の有無にかかわらず、ソースおよびバイナリ形式での再配布および使用http://trustee.ietf.org/license-info）。」"
    },
    {
      "indent": 7,
      "text": "REVISION \"201005070000Z\" DESCRIPTION \"This version of this MIB module is part of RFC 5953; see the RFC itself for full legal notices.\"",
      "ja": "REVISION「201005070000Z」DESCRIPTION「このMIBモジュールのこのバージョンはRFC 5953の一部です;完全な適法な通知についてはRFC自体を参照してください。」"
    },
    {
      "indent": 4,
      "text": "::= { mib-2 198 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- ************************************************ -- subtrees of the SNMP-TLS-TM-MIB -- ************************************************",
      "ja": " -  ************************************************ -  SNMP-TLS-TM-MIBのサブツリー -  ************************************ ************"
    },
    {
      "indent": 0,
      "text": "snmpTlstmNotifications OBJECT IDENTIFIER ::= { snmpTlstmMIB 0 }\nsnmpTlstmIdentities    OBJECT IDENTIFIER ::= { snmpTlstmMIB 1 }\nsnmpTlstmObjects       OBJECT IDENTIFIER ::= { snmpTlstmMIB 2 }\nsnmpTlstmConformance   OBJECT IDENTIFIER ::= { snmpTlstmMIB 3 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- ************************************************ -- snmpTlstmObjects - Objects -- ************************************************",
      "ja": " -  ************************************************ -  snmpTlstmObjects  - オブジェクト -  ******************************************* *****"
    },
    {
      "indent": 0,
      "text": "snmpTLSTCPDomain OBJECT-IDENTITY STATUS current DESCRIPTION \"The SNMP over TLS via TCP transport domain. The corresponding transport address is of type SnmpTLSAddress.",
      "ja": "TCPトランスポートドメインを介してTLSオーバーOBJECT-IDENTITYステータス現在の説明」SNMPをsnmpTLSTCPDomain。対応するトランスポートアドレスはタイプSnmpTLSAddressです。"
    },
    {
      "indent": 4,
      "text": "    The securityName prefix to be associated with the\n    snmpTLSTCPDomain is 'tls'.  This prefix may be used by\n    security models or other components to identify which secure\n    transport infrastructure authenticated a securityName.\"\nREFERENCE\n  \"RFC 2579: Textual Conventions for SMIv2\"",
      "raw": true
    },
    {
      "indent": 4,
      "text": "::= { snmpDomains 8 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpDTLSUDPDomain OBJECT-IDENTITY STATUS current DESCRIPTION \"The SNMP over DTLS via UDP transport domain. The corresponding transport address is of type SnmpTLSAddress.",
      "ja": "UDP輸送ドメインを介してDTLS上OBJECT-IDENTITYステータス現在の説明」SNMPをsnmpDTLSUDPDomain。対応するトランスポートアドレスはタイプSnmpTLSAddressです。"
    },
    {
      "indent": 4,
      "text": "    The securityName prefix to be associated with the\n    snmpDTLSUDPDomain is 'dtls'.  This prefix may be used by\n    security models or other components to identify which secure\n    transport infrastructure authenticated a securityName.\"\nREFERENCE\n  \"RFC 2579: Textual Conventions for SMIv2\"",
      "raw": true
    },
    {
      "indent": 4,
      "text": "::= { snmpDomains 9 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "SnmpTLSAddress ::= TEXTUAL-CONVENTION\n    DISPLAY-HINT \"1a\"\n    STATUS       current\n    DESCRIPTION\n        \"Represents an IPv4 address, an IPv6 address, or a\n         US-ASCII-encoded hostname and port number.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "An IPv4 address must be in dotted decimal format followed by a\ncolon ':' (US-ASCII character 0x3A) and a decimal port number\nin US-ASCII.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "An IPv6 address must be a colon-separated format (as described in RFC 5952), surrounded by square brackets ('[', US-ASCII character 0x5B, and ']', US-ASCII character 0x5D), followed by a colon ':' (US-ASCII character 0x3A) and a decimal port number in US-ASCII.",
      "ja": "コロン '続く、角括弧（ '['、US-ASCII文字0x5B、および ']'、US-ASCII文字0x5D）によって囲まれ、（RFC 5952に記載されているように）IPv6アドレスは、コロンで区切られた形式でなければなりません：」（US-ASCII文字0x3A）とUS-ASCIIで10進数のポート番号。"
    },
    {
      "indent": 8,
      "text": "A hostname is always in US-ASCII (as per [RFC1033]); internationalized hostnames are encoded in US-ASCII as domain names after transformation via the ToASCII operation specified in [RFC3490]. The ToASCII operation MUST be performed with the UseSTD3ASCIIRules flag set. The hostname is followed by a colon ':' (US-ASCII character 0x3A) and a decimal port number in US-ASCII. The name SHOULD be fully qualified whenever possible.",
      "ja": "ホスト名は、（[RFC1033]あたりなど）US-ASCIIに常にあります。国際化ホスト名は、[RFC3490]で指定もしToASCII操作を経由して変換後のドメイン名としてUS-ASCIIでエンコードされています。もしToASCII操作はUseSTD3ASCIIRulesフラグを設定して行われなければなりません。 「：」（US-ASCII文字0x3A）とUS-ASCIIで10進数のポート番号ホスト名は、コロンが続いています。名前は、可能な限り完全指定する必要があります。"
    },
    {
      "indent": 8,
      "text": "Values of this textual convention may not be directly usable as transport-layer addressing information, and may require run-time resolution. As such, applications that write them must be prepared for handling errors if such values are not supported, or cannot be resolved (if resolution occurs at the time of the management operation).",
      "ja": "このテキストの表記法の値は、トランスポート層のアドレス指定情報として直接使用できない場合があり、および実行時の解像度が必要な場合があります。このように、それらを書き込むアプリケーションは、そのような値がサポートされていない、または（解像度が管理操作時に発生した場合）解決できない場合にエラーを処理のために準備されなければなりません。"
    },
    {
      "indent": 8,
      "text": "The DESCRIPTION clause of TransportAddress objects that may have SnmpTLSAddress values must fully describe how (and when) such names are to be resolved to IP addresses and vice versa.",
      "ja": "SnmpTLSAddress値を有していてもよいTransportAddressオブジェクトの記述節は完全にそのような名前は、その逆のIPアドレスに解決されるべき方法（および場合）について説明しなければなりません。"
    },
    {
      "indent": 8,
      "text": "This textual convention SHOULD NOT be used directly in object definitions since it restricts addresses to a specific format. However, if it is used, it MAY be used either on its own or in conjunction with TransportAddressType or TransportDomain as a pair.",
      "ja": "それは特定のフォーマットにアドレスを制限するため、このテキストの表記法はオブジェクト定義で直接使用してはなりません。ただし、使用されれば、それは自分自身でまたはペアとしてTransportAddressTypeまたはTransportDomainと組み合わせて使用​​することができます。"
    },
    {
      "indent": 8,
      "text": "When this textual convention is used as a syntax of an index object, there may be issues with the limit of 128 sub-identifiers specified in SMIv2 (STD 58). It is RECOMMENDED that all MIB documents using this textual convention make explicit any limitations on index component lengths that management software must observe. This may be done either by including SIZE constraints on the index components or by specifying applicable constraints in the conceptual row DESCRIPTION clause or in the surrounding documentation.\"",
      "ja": "このテキストの表記法は、インデックスオブジェクトの構文として使用する場合、SMIv2の指定された128のサブ識別子（STD 58）の限界の問題があってもよいです。このテキストの表記法を使用して、すべてのMIBの文書がインデックスコンポーネントの明示的な制限事項は、管理ソフトウェアが守らなければならないことを長することをお勧めします。これは、インデックスコンポーネントのサイズの制約を含めることによって、または概念的な行の記述節内または周囲のドキュメントに適用可能な制約を指定することによってのいずれかで行うことができます。」"
    },
    {
      "indent": 4,
      "text": "REFERENCE \"RFC 1033: DOMAIN ADMINISTRATORS OPERATIONS GUIDE RFC 3490: Internationalizing Domain Names in Applications RFC 5952: A Recommendation for IPv6 Address Text Representation \" SYNTAX OCTET STRING (SIZE (1..255))",
      "ja": "REFERENCE「RFC 1033：ドメイン管理者操作ガイドのRFC 3490：アプリケーションにおけるドメイン名の国際化RFC 5952：IPv6のアドレステキスト表現のための勧告」構文オクテットSTRING（SIZE（1 255））"
    },
    {
      "indent": 0,
      "text": "SnmpTLSFingerprint ::= TEXTUAL-CONVENTION\n    DISPLAY-HINT \"1x:1x\"\n    STATUS       current\n    DESCRIPTION\n       \"A fingerprint value that can be used to uniquely reference\n       other data of potentially arbitrary length.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "An SnmpTLSFingerprint value is composed of a 1-octet hashing\nalgorithm identifier followed by the fingerprint value.  The\noctet value encoded is taken from the IANA TLS HashAlgorithm\nRegistry (RFC 5246).  The remaining octets are filled using the\nresults of the hashing algorithm.",
      "raw": true
    },
    {
      "indent": 4,
      "text": " This TEXTUAL-CONVENTION allows for a zero-length (blank) SnmpTLSFingerprint value for use in tables where the fingerprint value may be optional. MIB definitions or implementations may refuse to accept a zero-length value as appropriate.\" REFERENCE \"RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 http://www.iana.org/assignments/tls-parameters/ \" SYNTAX OCTET STRING (SIZE (0..255))",
      "ja": "このテキストの表記法は、指紋値は任意であるテーブルで使用するためのゼロ長（ブランク）SnmpTLSFingerprint値を可能にします。 MIB定義や実装は、適切な長さゼロの値を受け入れることを拒否することができ、「REFERENCE 『RFC 5246：トランスポート層セキュリティ（TLS）プロトコルバージョン1.2 http://www.iana.org/assignments/tls-parameters/』 SYNTAXオクテットSTRING（SIZE（0 255））"
    },
    {
      "indent": 0,
      "text": "-- Identities for use in the snmpTlstmCertToTSNTable",
      "ja": " -  snmpTlstmCertToTSNTableで使用するためのアイデンティティ"
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertToTSNMIdentities OBJECT IDENTIFIER\n    ::= { snmpTlstmIdentities 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertSpecified OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION  \"Directly specifies the tmSecurityName to be used for\n                  this certificate.  The value of the tmSecurityName\n                  to use is specified in the snmpTlstmCertToTSNData\n                  column.  The snmpTlstmCertToTSNData column must contain a non-zero length SnmpAdminString compliant\n                  value or the mapping described in this row must be\n                  considered a failure.\"\n    ::= { snmpTlstmCertToTSNMIdentities 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertSANRFC822Name OBJECT-IDENTITY STATUS current DESCRIPTION \"Maps a subjectAltName's rfc822Name to a tmSecurityName. The local part of the rfc822Name is passed unaltered but the host-part of the name must be passed in lowercase. This mapping results in a 1:1 correspondence between equivalent subjectAltName rfc822Name values and tmSecurityName values except that the host-part of the name MUST be passed in lowercase.",
      "ja": "snmpTlstmCertSANRFC822Name OBJECT-IDENTITYステータス現在の説明は「tmSecurityNameへのsubjectAltNameのrfc822Nameでのマッピングrfc822Nameでのローカル部分は変更なしで渡されるが、名前のホスト部分は小文字で渡されなければならない1におけるこのマッピングの結果：。。同等の間の1の対応名前のホスト部分は小文字で渡さなければならないことを除いてのsubjectAltName rfc822Nameで値とtmSecurityName値。"
    },
    {
      "indent": 4,
      "text": "              Example rfc822Name Field:  FooBar@Example.COM\n              is mapped to tmSecurityName: FooBar@example.com.\"\n::= { snmpTlstmCertToTSNMIdentities 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertSANDNSName OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION  \"Maps a subjectAltName's dNSName to a\n                  tmSecurityName after first converting it to all\n                  lowercase (RFC 5280 does not specify converting to\n                  lowercase so this involves an extra step).  This\n                  mapping results in a 1:1 correspondence between\n                  subjectAltName dNSName values and the tmSecurityName\n                  values.\"\n    REFERENCE \"RFC 5280 - Internet X.509 Public Key Infrastructure\n                         Certificate and Certificate Revocation\n                         List (CRL) Profile.\"\n    ::= { snmpTlstmCertToTSNMIdentities 3 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertSANIpAddress OBJECT-IDENTITY STATUS current DESCRIPTION \"Maps a subjectAltName's iPAddress to a tmSecurityName by transforming the binary encoded address as follows:",
      "ja": "snmpTlstmCertSANIpAddress OBJECT-IDENTITYステータス現在の説明は「次のようにバイナリエンコードされたアドレスを変換することによりtmSecurityNameへのsubjectAltNameのIPアドレスをマッピングします。"
    },
    {
      "indent": 18,
      "text": "1) for IPv4, the value is converted into a\n   decimal-dotted quad address (e.g., '192.0.2.1').",
      "raw": true
    },
    {
      "indent": 18,
      "text": "2) for IPv6 addresses, the value is converted into a 32-character all lowercase hexadecimal string without any colon separators.",
      "ja": "2）IPv6アドレスのために、値は任意のコロン区切りなしで32文字のすべて小文字の16進数文字列に変換されます。"
    },
    {
      "indent": 18,
      "text": "This mapping results in a 1:1 correspondence between subjectAltName iPAddress values and the tmSecurityName values.",
      "ja": "IPアドレスのsubjectAltName値とtmSecurityName値と1対応：1でのこのマッピングの結果。"
    },
    {
      "indent": 4,
      "text": "              The resulting length of an encoded IPv6 address is\n              the maximum length supported by the View-Based\n              Access Control Model (VACM).  Using both the\n              Transport Security Model's support for transport\n              prefixes (see the SNMP-TSM-MIB's\n              snmpTsmConfigurationUsePrefix object for details)\n              will result in securityName lengths that exceed what\n              VACM can handle.\"\n::= { snmpTlstmCertToTSNMIdentities 4 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertSANAny OBJECT-IDENTITY STATUS current DESCRIPTION \"Maps any of the following fields using the corresponding mapping algorithms:",
      "ja": "snmpTlstmCertSANAny OBJECT-IDENTITYステータス現在の説明は「対応するマッピングアルゴリズムを使用して、次のいずれかのフィールドをマッピングします。"
    },
    {
      "indent": 18,
      "text": "|------------+----------------------------|\n| Type       | Algorithm                  |\n|------------+----------------------------|\n| rfc822Name | snmpTlstmCertSANRFC822Name |\n| dNSName    | snmpTlstmCertSANDNSName    |\n| iPAddress  | snmpTlstmCertSANIpAddress  |\n|------------+----------------------------|",
      "raw": true
    },
    {
      "indent": 18,
      "text": "The first matching subjectAltName value found in the certificate of the above types MUST be used when deriving the tmSecurityName. The mapping algorithm specified in the 'Algorithm' column MUST be used to derive the tmSecurityName.",
      "ja": "tmSecurityNameを導出する際に、上記のタイプの証明書で最初に検出されたマッチングのsubjectAltName値を使用しなければなりません。 「アルゴリズム」列で指定されたマッピングアルゴリズムはtmSecurityNameを導出するために使用されなければなりません。"
    },
    {
      "indent": 4,
      "text": "              This mapping results in a 1:1 correspondence between\n              subjectAltName values and tmSecurityName values.  The\n              three sub-mapping algorithms produced by this\n              combined algorithm cannot produce conflicting\n              results between themselves.\"\n::= { snmpTlstmCertToTSNMIdentities 5 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertCommonName OBJECT-IDENTITY STATUS current",
      "ja": "snmpTlstmCertCommonName OBJECT-IDENTITYステータス現在"
    },
    {
      "indent": 4,
      "text": "DESCRIPTION  \"Maps a certificate's CommonName to a tmSecurityName\n              after converting it to a UTF-8 encoding.  The usage\n              of CommonNames is deprecated and users are\n              encouraged to use subjectAltName mapping methods instead.  This mapping results in a 1:1\n              correspondence between certificate CommonName values\n              and tmSecurityName values.\"\n::= { snmpTlstmCertToTSNMIdentities 6 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- The snmpTlstmSession Group",
      "ja": " -  snmpTlstmSessionグループ"
    },
    {
      "indent": 0,
      "text": "snmpTlstmSession           OBJECT IDENTIFIER ::= { snmpTlstmObjects 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmSessionOpens  OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION\n       \"The number of times an openSession() request has been executed\n       as a (D)TLS client, regardless of whether it succeeded or\n       failed.\"\n    ::= { snmpTlstmSession 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmSessionClientCloses  OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION\n        \"The number of times a closeSession() request has been\n        executed as an (D)TLS client, regardless of whether it\n        succeeded or failed.\"\n    ::= { snmpTlstmSession 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmSessionOpenErrors  OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION\n        \"The number of times an openSession() request failed to open a\n        session as a (D)TLS client, for any reason.\"\n    ::= { snmpTlstmSession 3 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmSessionAccepts  OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION\n       \"The number of times a (D)TLS server has accepted a new\n       connection from a client and has received at least one SNMP\n       message through it.\"\n    ::= { snmpTlstmSession 4 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmSessionServerCloses  OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION\n        \"The number of times a closeSession() request has been\n        executed as an (D)TLS server, regardless of whether it\n        succeeded or failed.\"\n    ::= { snmpTlstmSession 5 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmSessionNoSessions  OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION\n        \"The number of times an outgoing message was dropped because\n        the session associated with the passed tmStateReference was no\n        longer (or was never) available.\"\n    ::= { snmpTlstmSession 6 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmSessionInvalidClientCertificates OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION\n        \"The number of times an incoming session was not established\n        on an (D)TLS server because the presented client certificate\n        was invalid.  Reasons for invalidation include, but are not\n        limited to, cryptographic validation failures or lack of a\n        suitable mapping row in the snmpTlstmCertToTSNTable.\"\n    ::= { snmpTlstmSession 7 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmSessionUnknownServerCertificate OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION\n        \"The number of times an outgoing session was not established\n         on an (D)TLS client because the server certificate presented\n         by an SNMP over (D)TLS server was invalid because no\n         configured fingerprint or Certification Authority (CA) was\n         acceptable to validate it.\n         This may result because there was no entry in the\n         snmpTlstmAddrTable or because no path could be found to a\n         known CA.\"\n    ::= { snmpTlstmSession 8 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmSessionInvalidServerCertificates OBJECT-TYPE SYNTAX Counter32 MAX-ACCESS read-only STATUS current DESCRIPTION \"The number of times an outgoing session was not established on an (D)TLS client because the server certificate presented by an SNMP over (D)TLS server could not be validated even if the fingerprint or expected validation path was known. That is, a cryptographic validation error occurred during certificate validation processing.",
      "ja": "snmpTlstmSessionInvalidServerCertificatesのOBJECT-TYPE SYNTAXカウンタACCESS read-onlyステータス現在の説明「送信セッション（D）に設立されていなかった回数TLSクライアント上でSNMPによって提示されたサーバー証明書は、（D）TLSサーバがあることができなかったので、指紋または予想される検証パスが知られていた場合でも、検証。つまり、暗号検証エラーは、証明書の検証処理中に発生しました。"
    },
    {
      "indent": 4,
      "text": "    Reasons for invalidation include, but are not\n    limited to, cryptographic validation failures.\"\n::= { snmpTlstmSession 9 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmSessionInvalidCaches OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION\n        \"The number of outgoing messages dropped because the\n        tmStateReference referred to an invalid cache.\"\n    ::= { snmpTlstmSession 10 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- Configuration Objects",
      "ja": " - 構成オブジェクト"
    },
    {
      "indent": 0,
      "text": "snmpTlstmConfig             OBJECT IDENTIFIER ::= { snmpTlstmObjects 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- Certificate mapping",
      "ja": " - 証明書のマッピング"
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertificateMapping OBJECT IDENTIFIER ::= { snmpTlstmConfig 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertToTSNCount OBJECT-TYPE\n    SYNTAX      Gauge32\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n        \"A count of the number of entries in the\n        snmpTlstmCertToTSNTable.\"\n    ::= { snmpTlstmCertificateMapping 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertToTSNTableLastChanged OBJECT-TYPE\n    SYNTAX      TimeStamp\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n        \"The value of sysUpTime.0 when the snmpTlstmCertToTSNTable was\n        last modified through any means, or 0 if it has not been\n        modified since the command responder was started.\"\n    ::= { snmpTlstmCertificateMapping 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertToTSNTable OBJECT-TYPE SYNTAX SEQUENCE OF SnmpTlstmCertToTSNEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"This table is used by a (D)TLS server to map the (D)TLS client's presented X.509 certificate to a tmSecurityName.",
      "ja": "SnmpTlstmCertToTSNEntry MAX-ACCESSステータス現在の説明のsnmpTlstmCertToTSNTable OBJECT-TYPE構文配列は「この表はtmSecurityNameに（D）TLSクライアントの提示X.509証明書をマッピングするために（D）TLSサーバで使用されています。"
    },
    {
      "indent": 8,
      "text": "On an incoming (D)TLS/SNMP connection, the client's presented\ncertificate must either be validated based on an established\ntrust anchor, or it must directly match a fingerprint in this\ntable.  This table does not provide any mechanisms for\nconfiguring the trust anchors; the transfer of any needed\ntrusted certificates for path validation is expected to occur\nthrough an out-of-band transfer.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Once the certificate has been found acceptable (either by path validation or directly matching a fingerprint in this table), this table is consulted to determine the appropriate tmSecurityName to identify with the remote connection. This is done by considering each active row from this table in prioritized order according to its snmpTlstmCertToTSNID value. Each row's snmpTlstmCertToTSNFingerprint value determines whether the row is a match for the incoming connection:",
      "ja": "証明書は、（パス検証によって、または直接この表の指紋と一致するいずれか）に許容される発見された後、このテーブルは、リモート接続に識別するために適切なtmSecurityNameを決定するために調べられます。これは、そのsnmpTlstmCertToTSNID値に応じて優先順位順に、このテーブルから各アクティブ行を考慮することによって行われます。各行のsnmpTlstmCertToTSNFingerprint値は、行が着信接続のための一致であるか否かを判断します。"
    },
    {
      "indent": 12,
      "text": "1) If the row's snmpTlstmCertToTSNFingerprint value\n   identifies the presented certificate, then consider the\n   row as a successful match.",
      "raw": true
    },
    {
      "indent": 12,
      "text": "2) If the row's snmpTlstmCertToTSNFingerprint value identifies a locally held copy of a trusted CA certificate and that CA certificate was used to validate the path to the presented certificate, then consider the row as a successful match.",
      "ja": "行のsnmpTlstmCertToTSNFingerprint値が信頼できるCA証明書のローカルに保持されたコピーを識別し、そのCA証明書が提示された証明書へのパスを検証するために使用された場合2）、次いで、成功一致として行を考えます。"
    },
    {
      "indent": 8,
      "text": "Once a matching row has been found, the snmpTlstmCertToTSNMapType value can be used to determine how the tmSecurityName to associate with the session should be determined. See the snmpTlstmCertToTSNMapType column's DESCRIPTION for details on determining the tmSecurityName value. If it is impossible to determine a tmSecurityName from the row's data combined with the data presented in the certificate, then additional rows MUST be searched looking for another potential match. If a resulting tmSecurityName mapped from a given row is not compatible with the needed requirements of a tmSecurityName (e.g., VACM imposes a 32-octet-maximum length and the certificate derived securityName could be longer), then it must be considered an invalid match and additional rows MUST be searched looking for another potential match.",
      "ja": "一致する行が見つかった後、snmpTlstmCertToTSNMapType値は、セッションに関連付けるtmSecurityNameを決定する方法を決定するために使用することができます。 tmSecurityName値を決定する方法の詳細についてsnmpTlstmCertToTSNMapType列の説明を参照してください。それは証明書に提示されたデータと組み合わせる行のデータからtmSecurityNameを決定することは不可能である場合、追加の行は、他の潜在的な一致を探して探索しなければなりません。得tmSecurityNameは、所与の行からマッピングされた場合tmSecurityNameの必要要件と互換性がありません（例えば、VACMは、32オクテットの最大長さを課し、証明書のsecurityNameが長くなる可能性が誘導される）、それは無効と一致考慮しなければならないと追加の行は、他の潜在的なマッチを探して検索しなければなりません。"
    },
    {
      "indent": 8,
      "text": "If no matching and valid row can be found, the connection MUST be closed and SNMP messages MUST NOT be accepted over it.",
      "ja": "一致すると有効な行が見つからない場合、接続は閉じなければならないとSNMPメッセージは、その上に受け入れてはなりません。"
    },
    {
      "indent": 8,
      "text": "Missing values of snmpTlstmCertToTSNID are acceptable and implementations should continue to the next highest numbered row. It is recommended that administrators skip index values to leave room for the insertion of future rows (for example, use values of 10 and 20 when creating initial rows).",
      "ja": "snmpTlstmCertToTSNIDの欠落値が許容され、実装は、次の最も大きい番号の行に続けなければなりません。 （最初の行を作成する際に、例えば、10と20の値を使用する）、管理者が将来の行を挿入するための余地を残すためにインデックス値をスキップすることをお勧めします。"
    },
    {
      "indent": 4,
      "text": "    Users are encouraged to make use of certificates with\n    subjectAltName fields that can be used as tmSecurityNames so\n    that a single root CA certificate can allow all child\n    certificate's subjectAltName to map directly to a\n    tmSecurityName via a 1:1 transformation.  However, this table\n    is flexible to allow for situations where existing deployed\n    certificate infrastructures do not provide adequate\n    subjectAltName values for use as tmSecurityNames.\n    Certificates may also be mapped to tmSecurityNames using the\n    CommonName portion of the Subject field.  However, the usage\n    of the CommonName field is deprecated and thus this usage is\n    NOT RECOMMENDED.  Direct mapping from each individual\n    certificate fingerprint to a tmSecurityName is also possible\n    but requires one entry in the table per tmSecurityName and\n    requires more management operations to completely configure a\n    device.\"\n::= { snmpTlstmCertificateMapping 3 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertToTSNEntry OBJECT-TYPE SYNTAX SnmpTlstmCertToTSNEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"A row in the snmpTlstmCertToTSNTable that specifies a mapping for an incoming (D)TLS certificate to a tmSecurityName to use for a connection.\"",
      "ja": "snmpTlstmCertToTSNEntry OBJECT-TYPE構文SnmpTlstmCertToTSNEntry MAX-ACCESSステータス現在の説明は「接続に使用するtmSecurityNameに入ってくる（D）TLS証明書のマッピングを指定snmpTlstmCertToTSNTableの行。」"
    },
    {
      "indent": 4,
      "text": "INDEX   { snmpTlstmCertToTSNID }\n::= { snmpTlstmCertToTSNTable 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "SnmpTlstmCertToTSNEntry ::= SEQUENCE {\n    snmpTlstmCertToTSNID           Unsigned32,\n    snmpTlstmCertToTSNFingerprint  SnmpTLSFingerprint,\n    snmpTlstmCertToTSNMapType      AutonomousType,\n    snmpTlstmCertToTSNData         OCTET STRING,\n    snmpTlstmCertToTSNStorageType  StorageType,\n    snmpTlstmCertToTSNRowStatus    RowStatus\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertToTSNID OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"A unique, prioritized index for the given entry.  Lower\n        numbers indicate a higher priority.\"\n    ::= { snmpTlstmCertToTSNEntry 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertToTSNFingerprint OBJECT-TYPE\n    SYNTAX      SnmpTLSFingerprint (SIZE(1..255))\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"A cryptographic hash of a X.509 certificate.  The results of\n        a successful matching fingerprint to either the trusted CA in\n        the certificate validation path or to the certificate itself\n        is dictated by the snmpTlstmCertToTSNMapType column.\"\n    ::= { snmpTlstmCertToTSNEntry 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertToTSNMapType OBJECT-TYPE SYNTAX AutonomousType MAX-ACCESS read-create STATUS current DESCRIPTION \"Specifies the mapping type for deriving a tmSecurityName from a certificate. Details for mapping of a particular type SHALL be specified in the DESCRIPTION clause of the OBJECT-IDENTITY that describes the mapping. If a mapping succeeds it will return a tmSecurityName for use by the TLSTM model and processing stops.",
      "ja": "snmpTlstmCertToTSNMapTypeのOBJECT-TYPE SYNTAX AutonomousTypeのMAX-ACCESSはリード作成しますステータス現在の説明は「証明書からtmSecurityNameを導出するためのマッピングタイプを指定します。特定のタイプのマッピングの詳細については説明しOBJECT-IDENTITYの説明節に規定しますマッピング。マッピングは、それがTLSTMモデルおよび処理で使用するためtmSecurityNameを返します。成功した場合は停止します。"
    },
    {
      "indent": 8,
      "text": "If the resulting mapped value is not compatible with the\nneeded requirements of a tmSecurityName (e.g., VACM imposes a\n32-octet-maximum length and the certificate derived securityName could be longer), then future rows MUST be\nsearched for additional snmpTlstmCertToTSNFingerprint matches\nto look for a mapping that succeeds.",
      "raw": true
    },
    {
      "indent": 4,
      "text": "    Suitable values for assigning to this object that are defined\n    within the SNMP-TLS-TM-MIB can be found in the\n    snmpTlstmCertToTSNMIdentities portion of the MIB tree.\"\nDEFVAL { snmpTlstmCertSpecified }\n::= { snmpTlstmCertToTSNEntry 3 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertToTSNData OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE(0..1024))\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"Auxiliary data used as optional configuration information for\n        a given mapping specified by the snmpTlstmCertToTSNMapType\n        column.  Only some mapping systems will make use of this\n        column.  The value in this column MUST be ignored for any\n        mapping type that does not require data present in this\n        column.\"\n    DEFVAL { \"\" }\n    ::= { snmpTlstmCertToTSNEntry 4 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertToTSNStorageType OBJECT-TYPE\n    SYNTAX       StorageType\n    MAX-ACCESS   read-create\n    STATUS       current\n    DESCRIPTION\n        \"The storage type for this conceptual row.  Conceptual rows\n        having the value 'permanent' need not allow write-access to\n        any columnar objects in the row.\"\n    DEFVAL      { nonVolatile }\n    ::= { snmpTlstmCertToTSNEntry 5 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmCertToTSNRowStatus OBJECT-TYPE SYNTAX RowStatus MAX-ACCESS read-create STATUS current DESCRIPTION \"The status of this conceptual row. This object may be used to create or remove rows from this table.",
      "ja": "snmpTlstmCertToTSNRowStatusのOBJECT-TYPE構文RowStatus MAX-ACCESSはリード作成ステータス現在の説明「この概念的な列のステータス。このオブジェクトはこのテーブルから行を作成または除去するために使用されてもよいです。"
    },
    {
      "indent": 8,
      "text": "To create a row in this table, an administrator must set this\nobject to either createAndGo(4) or createAndWait(5).",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Until instances of all corresponding columns are appropriately configured, the value of the corresponding instance of the snmpTlstmParamsRowStatus column is notReady(3).",
      "ja": "すべての対応する列のインスタンスが適切に設定されるまで、snmpTlstmParamsRowStatus列の対応するインスタンスの値が準備中である（3）。"
    },
    {
      "indent": 8,
      "text": "In particular, a newly created row cannot be made active until the corresponding snmpTlstmCertToTSNFingerprint, snmpTlstmCertToTSNMapType, and snmpTlstmCertToTSNData columns have been set.",
      "ja": "対応snmpTlstmCertToTSNFingerprint、snmpTlstmCertToTSNMapType、及びsnmpTlstmCertToTSNData列が設定されるまで、特に、新しく作成された行をアクティブにすることができません。"
    },
    {
      "indent": 4,
      "text": "    The following objects may not be modified while the\n    value of this object is active(1):\n        - snmpTlstmCertToTSNFingerprint\n        - snmpTlstmCertToTSNMapType\n        - snmpTlstmCertToTSNData\n    An attempt to set these objects while the value of\n    snmpTlstmParamsRowStatus is active(1) will result in\n    an inconsistentValue error.\"\n::= { snmpTlstmCertToTSNEntry 6 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- Maps tmSecurityNames to certificates for use by the SNMP-TARGET-MIB",
      "ja": " -  SNMP-TARGET-MIBで使用するための証明書にマップtmSecurityNames"
    },
    {
      "indent": 0,
      "text": "snmpTlstmParamsCount OBJECT-TYPE\n    SYNTAX      Gauge32\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n        \"A count of the number of entries in the snmpTlstmParamsTable.\"\n    ::= { snmpTlstmCertificateMapping 4 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmParamsTableLastChanged OBJECT-TYPE\n    SYNTAX      TimeStamp\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n        \"The value of sysUpTime.0 when the snmpTlstmParamsTable\n        was last modified through any means, or 0 if it has not been\n        modified since the command responder was started.\"\n    ::= { snmpTlstmCertificateMapping 5 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmParamsTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF SnmpTlstmParamsEntry\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"This table is used by a (D)TLS client when a (D)TLS\n        connection is being set up using an entry in the\n        SNMP-TARGET-MIB.  It extends the SNMP-TARGET-MIB's\n        snmpTargetParamsTable with a fingerprint of a certificate to\n        use when establishing such a (D)TLS connection.\"\n    ::= { snmpTlstmCertificateMapping 6 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmParamsEntry OBJECT-TYPE\n    SYNTAX      SnmpTlstmParamsEntry\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"A conceptual row containing a fingerprint hash of a locally\n        held certificate for a given snmpTargetParamsEntry.  The\n        values in this row should be ignored if the connection that\n        needs to be established, as indicated by the SNMP-TARGET-MIB\n        infrastructure, is not a certificate and (D)TLS based\n        connection.  The connection SHOULD NOT be established if the\n        certificate fingerprint stored in this entry does not point to\n        a valid locally held certificate or if it points to an\n        unusable certificate (such as might happen when the\n        certificate's expiration date has been reached).\"\n    INDEX    { IMPLIED snmpTargetParamsName }\n    ::= { snmpTlstmParamsTable 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "SnmpTlstmParamsEntry ::= SEQUENCE {\n    snmpTlstmParamsClientFingerprint SnmpTLSFingerprint,\n    snmpTlstmParamsStorageType       StorageType,\n    snmpTlstmParamsRowStatus         RowStatus\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmParamsClientFingerprint OBJECT-TYPE\n    SYNTAX      SnmpTLSFingerprint\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"This object stores the hash of the public portion of a\n        locally held X.509 certificate.  The X.509 certificate, its\n        public key, and the corresponding private key will be used\n        when initiating a (D)TLS connection as a (D)TLS client.\"\n    ::= { snmpTlstmParamsEntry 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmParamsStorageType OBJECT-TYPE\n    SYNTAX       StorageType\n    MAX-ACCESS   read-create\n    STATUS       current\n    DESCRIPTION\n        \"The storage type for this conceptual row.  Conceptual rows\n        having the value 'permanent' need not allow write-access to\n        any columnar objects in the row.\"\n    DEFVAL      { nonVolatile }\n    ::= { snmpTlstmParamsEntry 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmParamsRowStatus OBJECT-TYPE SYNTAX RowStatus MAX-ACCESS read-create STATUS current DESCRIPTION \"The status of this conceptual row. This object may be used to create or remove rows from this table.",
      "ja": "snmpTlstmParamsRowStatusのOBJECT-TYPE構文RowStatus MAX-ACCESSはリード作成ステータス現在の説明「この概念的な列のステータス。このオブジェクトはこのテーブルから行を作成または除去するために使用されてもよいです。"
    },
    {
      "indent": 8,
      "text": "To create a row in this table, an administrator must set this\nobject to either createAndGo(4) or createAndWait(5).",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Until instances of all corresponding columns are appropriately configured, the value of the corresponding instance of the snmpTlstmParamsRowStatus column is notReady(3).",
      "ja": "すべての対応する列のインスタンスが適切に設定されるまで、snmpTlstmParamsRowStatus列の対応するインスタンスの値が準備中である（3）。"
    },
    {
      "indent": 8,
      "text": "In particular, a newly created row cannot be made active until the corresponding snmpTlstmParamsClientFingerprint column has been set.",
      "ja": "対応snmpTlstmParamsClientFingerprint列が設定されるまで、特に、新しく作成された行をアクティブにすることができません。"
    },
    {
      "indent": 8,
      "text": "The snmpTlstmParamsClientFingerprint object may not be modified while the value of this object is active(1).",
      "ja": "このオブジェクトの値がアクティブである間snmpTlstmParamsClientFingerprintオブジェクトは修正されないかもしれません（1）。"
    },
    {
      "indent": 4,
      "text": "    An attempt to set these objects while the value of\n    snmpTlstmParamsRowStatus is active(1) will result in\n    an inconsistentValue error.\"\n::= { snmpTlstmParamsEntry 3 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmAddrCount OBJECT-TYPE\n    SYNTAX      Gauge32\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n        \"A count of the number of entries in the snmpTlstmAddrTable.\"\n    ::= { snmpTlstmCertificateMapping 7 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmAddrTableLastChanged OBJECT-TYPE\n    SYNTAX      TimeStamp\n    MAX-ACCESS  read-only\n    STATUS      current\n    DESCRIPTION\n        \"The value of sysUpTime.0 when the snmpTlstmAddrTable\n        was last modified through any means, or 0 if it has not been\n        modified since the command responder was started.\"\n    ::= { snmpTlstmCertificateMapping 8 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmAddrTable OBJECT-TYPE SYNTAX SEQUENCE OF SnmpTlstmAddrEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"This table is used by a (D)TLS client when a (D)TLS connection is being set up using an entry in the SNMP-TARGET-MIB. It extends the SNMP-TARGET-MIB's snmpTargetAddrTable so that the client can verify that the correct server has been reached. This verification can use either a certificate fingerprint, or an identity authenticated via certification path validation.",
      "ja": "SnmpTlstmAddrEntry MAX-ACCESSステータス現在の説明のsnmpTlstmAddrTable OBJECT-TYPE構文配列は「この表は、（D）TLS接続はSNMP-TARGET-MIBのエントリを使用して設定されている（D）TLSクライアントによって使用されクライアントが正しいサーバーに到達したことを確認できるようにします。これは、SNMP-TARGET-MIBのsnmpTargetAddrTableのを拡張します。この検証は、証明書のフィンガープリント、または証明書パスの検証を経て認証されたIDのいずれかを使用することができます。"
    },
    {
      "indent": 8,
      "text": "If there is an active row in this table corresponding to the\nentry in the SNMP-TARGET-MIB that was used to establish the\nconnection, and the row's snmpTlstmAddrServerFingerprint\ncolumn has non-empty value, then the server's presented\ncertificate is compared with the\nsnmpTlstmAddrServerFingerprint value (and the\nsnmpTlstmAddrServerIdentity column is ignored).  If the\nfingerprint matches, the verification has succeeded.  If the\nfingerprint does not match, then the connection MUST be\nclosed.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "If the server's presented certificate has passed certification path validation [RFC5280] to a configured trust anchor, and an active row exists with a zero-length snmpTlstmAddrServerFingerprint value, then the snmpTlstmAddrServerIdentity column contains the expected host name. This expected host name is then compared against the server's certificate as follows:",
      "ja": "サーバの提示された証明書が設定されている信頼アンカーに認証パスの検証[RFC5280]を経過し、かつアクティブな行はゼロ長snmpTlstmAddrServerFingerprint値で存在する場合、snmpTlstmAddrServerIdentity列は予想ホスト名を含みます。これは、次のようにホスト名は、サーバの証明書と比較されると予想しました。"
    },
    {
      "indent": 10,
      "text": "- Implementations MUST support matching the expected host name against a dNSName in the subjectAltName extension field and MAY support checking the name against the CommonName portion of the subject distinguished name.",
      "ja": " - 実装はsubjectAltName拡張フィールド内のdNSNameに対して予期されているホスト名と一致するサポートしなければならないと被写体識別名のCommonName部に対して名前をチェックサポートするかもしれません。"
    },
    {
      "indent": 10,
      "text": "- The '*' (ASCII 0x2a) wildcard character is allowed in the dNSName of the subjectAltName extension (and in common name, if used to store the host name), but only as the left-most (least significant) DNS label in that value. This wildcard matches any left-most DNS label in the server name. That is, the subject *.example.com matches the server names a.example.com and b.example.com, but does not match example.com or a.b.example.com. Implementations MUST support wildcards in certificates as specified above, but MAY provide a configuration option to disable them.",
      "ja": " - 「*」（アスキー0x2a）ワイルドカード文字は、その中にsubjectAltName拡張（および一般名で、ホスト名を格納するために使用される場合）が、唯一のように、一番左の（最下位）DNSラベルののdNSNameで許可されています値。このワイルドカードは、サーバー名に任意の一番左のDNSラベルと一致します。つまり、対象* .example.comとは、サーバー名a.example.comとb.example.comと一致しますが、example.comまたはa.b.example.comと一致していないです。実装は、上記の指定された証明書でワイルドカードをサポートしなければならないが、それらを無効にする設定オプションを提供してもよいです。"
    },
    {
      "indent": 10,
      "text": "- If the locally configured name is an internationalized domain name, conforming implementations MUST convert it to the ASCII Compatible Encoding (ACE) format for performing comparisons, as specified in Section 7 of [RFC5280].",
      "ja": " - ローカルに設定名が国際化ドメイン名である場合は、[RFC5280]のセクション7で指定されるように、適合実装は、実行比較のためにASCIIコンパチブルエンコーディング（ACE）形式に変換しなければなりません。"
    },
    {
      "indent": 8,
      "text": "If the expected host name fails these conditions then the connection MUST be closed.",
      "ja": "予想されるホスト名は、これらの条件を失敗した場合、接続は閉じられなければなりません。"
    },
    {
      "indent": 8,
      "text": "If there is no row in this table corresponding to the entry in the SNMP-TARGET-MIB and the server can be authorized by another, implementation-dependent means, then the connection MAY still proceed.\"",
      "ja": "SNMP-TARGET-MIB及びサーバ内のエントリに対応するこの表には行が他によって許可することができない場合は、実装依存の手段は、接続がまだ進行してもよいです。」"
    },
    {
      "indent": 4,
      "text": "::= { snmpTlstmCertificateMapping 9 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmAddrEntry OBJECT-TYPE\n    SYNTAX      SnmpTlstmAddrEntry\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"A conceptual row containing a copy of a certificate's\n        fingerprint for a given snmpTargetAddrEntry.  The values in\n        this row should be ignored if the connection that needs to be\n        established, as indicated by the SNMP-TARGET-MIB\n        infrastructure, is not a (D)TLS based connection.  If an\n        snmpTlstmAddrEntry exists for a given snmpTargetAddrEntry, then\n        the presented server certificate MUST match or the connection\n        MUST NOT be established.  If a row in this table does not\n        exist to match an snmpTargetAddrEntry row, then the connection\n        SHOULD still proceed if some other certificate validation path\n        algorithm (e.g., RFC 5280) can be used.\"\n    INDEX    { IMPLIED snmpTargetAddrName }\n    ::= { snmpTlstmAddrTable 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "SnmpTlstmAddrEntry ::= SEQUENCE {\n    snmpTlstmAddrServerFingerprint    SnmpTLSFingerprint,\n    snmpTlstmAddrServerIdentity       SnmpAdminString,\n    snmpTlstmAddrStorageType          StorageType,\n    snmpTlstmAddrRowStatus            RowStatus\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmAddrServerFingerprint OBJECT-TYPE\n    SYNTAX      SnmpTLSFingerprint\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"A cryptographic hash of a public X.509 certificate.  This\n        object should store the hash of the public X.509 certificate\n        that the remote server should present during the (D)TLS\n        connection setup.  The fingerprint of the presented\n        certificate and this hash value MUST match exactly or the\n        connection MUST NOT be established.\"\n    DEFVAL { \"\" }\n    ::= { snmpTlstmAddrEntry 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmAddrServerIdentity OBJECT-TYPE\n    SYNTAX      SnmpAdminString\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"The reference identity to check against the identity\n        presented by the remote system.\"\n    DEFVAL { \"\" }\n    ::= { snmpTlstmAddrEntry 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmAddrStorageType OBJECT-TYPE\n    SYNTAX       StorageType\n    MAX-ACCESS   read-create\n    STATUS       current\n    DESCRIPTION\n        \"The storage type for this conceptual row.  Conceptual rows\n        having the value 'permanent' need not allow write-access to\n        any columnar objects in the row.\"\n    DEFVAL      { nonVolatile }\n    ::= { snmpTlstmAddrEntry 3 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmAddrRowStatus OBJECT-TYPE SYNTAX RowStatus MAX-ACCESS read-create STATUS current",
      "ja": "snmpTlstmAddrRowStatusのOBJECT-TYPE構文RowStatus MAX-ACCESSはリード作成しますステータス現在"
    },
    {
      "indent": 4,
      "text": "DESCRIPTION\n    \"The status of this conceptual row.  This object may be used\n    to create or remove rows from this table.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "To create a row in this table, an administrator must set this\nobject to either createAndGo(4) or createAndWait(5).",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Until instances of all corresponding columns are appropriately configured, the value of the corresponding instance of the snmpTlstmAddrRowStatus column is notReady(3).",
      "ja": "すべての対応する列のインスタンスが適切に設定されるまで、snmpTlstmAddrRowStatus列の対応するインスタンスの値が準備中である（3）。"
    },
    {
      "indent": 8,
      "text": "In particular, a newly created row cannot be made active until the corresponding snmpTlstmAddrServerFingerprint column has been set.",
      "ja": "対応snmpTlstmAddrServerFingerprint列が設定されるまで、特に、新しく作成された行をアクティブにすることができません。"
    },
    {
      "indent": 8,
      "text": "Rows MUST NOT be active if the snmpTlstmAddrServerFingerprint column is blank and the snmpTlstmAddrServerIdentity is set to '*' since this would insecurely accept any presented certificate.",
      "ja": "snmpTlstmAddrServerFingerprint欄が空白であり、これは安全でない任意の提示された証明書を受け入れるであろうからsnmpTlstmAddrServerIdentityが「*」に設定されている場合、行はアクティブにしてはなりません。"
    },
    {
      "indent": 8,
      "text": "The snmpTlstmAddrServerFingerprint object may not be modified while the value of this object is active(1).",
      "ja": "このオブジェクトの値がアクティブである間snmpTlstmAddrServerFingerprintオブジェクトは修正されないかもしれません（1）。"
    },
    {
      "indent": 4,
      "text": "    An attempt to set these objects while the value of\n    snmpTlstmAddrRowStatus is active(1) will result in\n    an inconsistentValue error.\"\n::= { snmpTlstmAddrEntry 4 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- ************************************************ -- snmpTlstmNotifications - Notifications Information -- ************************************************",
      "ja": " -  ************************************************ -  snmpTlstmNotifications  - 通知情報 -  ****************************************** ******"
    },
    {
      "indent": 0,
      "text": "snmpTlstmServerCertificateUnknown NOTIFICATION-TYPE OBJECTS { snmpTlstmSessionUnknownServerCertificate } STATUS current DESCRIPTION \"Notification that the server certificate presented by an SNMP over (D)TLS server was invalid because no configured fingerprint or CA was acceptable to validate it. This may be because there was no entry in the snmpTlstmAddrTable or because no path could be found to known Certification Authority.",
      "ja": "いかなる構成指紋またはCAがにエントリが存在しないため、これがあってもよい。それを検証するために許容されるなかったので、SNMPによって提示されたサーバー証明書上（D）TLSサーバが無効であったことをsnmpTlstmServerCertificateUnknown NOTIFICATION-TYPEオブジェクト{snmpTlstmSessionUnknownServerCertificate}ステータス現在の説明「通知snmpTlstmAddrTableまたは全くパスが知られている認証局に見つかりませんでしたので。"
    },
    {
      "indent": 4,
      "text": "     To avoid notification loops, this notification MUST NOT be\n     sent to servers that themselves have triggered the\n     notification.\"\n::= { snmpTlstmNotifications 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmServerInvalidCertificate NOTIFICATION-TYPE OBJECTS { snmpTlstmAddrServerFingerprint, snmpTlstmSessionInvalidServerCertificates} STATUS current DESCRIPTION \"Notification that the server certificate presented by an SNMP over (D)TLS server could not be validated even if the fingerprint or expected validation path was known. That is, a cryptographic validation error occurred during certificate validation processing.",
      "ja": "snmpTlstmServerInvalidCertificate NOTIFICATION-TYPEオブジェクト{snmpTlstmAddrServerFingerprint、snmpTlstmSessionInvalidServerCertificates}ステータス現在の説明「通知SNMP上（D）TLSサーバによって提示サーバ証明書は、指紋又は予想検証パスが知られていた場合であっても検証できなかったこと。それは、暗号化検証されエラーは、証明書の検証処理中に発生しました。"
    },
    {
      "indent": 4,
      "text": "     To avoid notification loops, this notification MUST NOT be\n     sent to servers that themselves have triggered the\n     notification.\"\n::= { snmpTlstmNotifications 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- ************************************************ -- snmpTlstmCompliances - Conformance Information -- ************************************************",
      "ja": " -  ************************************************ -  snmpTlstmCompliances  - 適合情報 -  ****************************************** ******"
    },
    {
      "indent": 0,
      "text": "snmpTlstmCompliances OBJECT IDENTIFIER ::= { snmpTlstmConformance 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmGroups OBJECT IDENTIFIER ::= { snmpTlstmConformance 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- ************************************************ -- Compliance statements -- ************************************************",
      "ja": " -  ************************************************ - コンプライアンスステートメント -  ******************************************** ****"
    },
    {
      "indent": 0,
      "text": "snmpTlstmCompliance MODULE-COMPLIANCE\n    STATUS      current\n    DESCRIPTION\n        \"The compliance statement for SNMP engines that support the\n        SNMP-TLS-TM-MIB\"\n    MODULE\n        MANDATORY-GROUPS { snmpTlstmStatsGroup,\n                           snmpTlstmIncomingGroup,\n                           snmpTlstmOutgoingGroup,\n                           snmpTlstmNotificationGroup }\n    ::= { snmpTlstmCompliances 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "-- ************************************************\n-- Units of conformance\n-- ************************************************\nsnmpTlstmStatsGroup OBJECT-GROUP\n    OBJECTS {\n        snmpTlstmSessionOpens,\n        snmpTlstmSessionClientCloses,\n        snmpTlstmSessionOpenErrors,\n        snmpTlstmSessionAccepts,\n        snmpTlstmSessionServerCloses,\n        snmpTlstmSessionNoSessions,\n        snmpTlstmSessionInvalidClientCertificates,\n        snmpTlstmSessionUnknownServerCertificate,\n        snmpTlstmSessionInvalidServerCertificates,\n        snmpTlstmSessionInvalidCaches\n    }\n    STATUS      current\n    DESCRIPTION\n        \"A collection of objects for maintaining\n        statistical information of an SNMP engine that\n        implements the SNMP TLS Transport Model.\"\n    ::= { snmpTlstmGroups 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmIncomingGroup OBJECT-GROUP\n    OBJECTS {\n        snmpTlstmCertToTSNCount,\n        snmpTlstmCertToTSNTableLastChanged,\n        snmpTlstmCertToTSNFingerprint,\n        snmpTlstmCertToTSNMapType,\n        snmpTlstmCertToTSNData,\n        snmpTlstmCertToTSNStorageType,\n        snmpTlstmCertToTSNRowStatus\n    }\n    STATUS      current\n    DESCRIPTION\n        \"A collection of objects for maintaining\n        incoming connection certificate mappings to\n        tmSecurityNames of an SNMP engine that implements the\n        SNMP TLS Transport Model.\"\n    ::= { snmpTlstmGroups 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmOutgoingGroup OBJECT-GROUP\n    OBJECTS {\n        snmpTlstmParamsCount,\n        snmpTlstmParamsTableLastChanged,\n        snmpTlstmParamsClientFingerprint,\n        snmpTlstmParamsStorageType,\n        snmpTlstmParamsRowStatus, snmpTlstmAddrCount,\n        snmpTlstmAddrTableLastChanged,\n        snmpTlstmAddrServerFingerprint,\n        snmpTlstmAddrServerIdentity,\n        snmpTlstmAddrStorageType,\n        snmpTlstmAddrRowStatus\n    }\n    STATUS      current\n    DESCRIPTION\n        \"A collection of objects for maintaining\n        outgoing connection certificates to use when opening\n        connections as a result of SNMP-TARGET-MIB settings.\"\n    ::= { snmpTlstmGroups 3 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "snmpTlstmNotificationGroup NOTIFICATION-GROUP\n    NOTIFICATIONS {\n        snmpTlstmServerCertificateUnknown,\n        snmpTlstmServerInvalidCertificate\n    }\n    STATUS current\n    DESCRIPTION\n        \"Notifications\"\n    ::= { snmpTlstmGroups 4 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "END",
      "ja": "終わり"
    },
    {
      "indent": 0,
      "text": "8. Operational Considerations",
      "section_title": true,
      "ja": "8.運用に関する注意事項"
    },
    {
      "indent": 3,
      "text": "This section discusses various operational aspects of deploying TLSTM.",
      "ja": "このセクションでは、TLSTMを展開するさまざまな運用面について説明します。"
    },
    {
      "indent": 0,
      "text": "8.1. Sessions",
      "section_title": true,
      "ja": "8.1。セッション"
    },
    {
      "indent": 3,
      "text": "A session is discussed throughout this document as meaning a security association between two TLSTM instances. State information for the sessions are maintained in each TLSTM implementation and this information is created and destroyed as sessions are opened and closed. A \"broken\" session (one side up and one side down) can result if one side of a session is brought down abruptly (i.e., reboot, power outage, etc.). Whenever possible, implementations SHOULD provide graceful session termination through the use of TLS disconnect messages. Implementations SHOULD also have a system in place for detecting \"broken\" sessions through the use of heartbeats [HEARTBEAT] or other detection mechanisms.",
      "ja": "セッションは2つのTLSTMインスタンス間のセキュリティ関係を意味するものとして、この文書を通して議論されています。セッションの状態情報は、各TLSTMの実装で維持され、セッションが開閉されるように、この情報は、作成および破棄されます。セッションの片側が急激に（すなわち、リブート、停電など）ダウンしている場合、「壊れた」セッションが（片側上下片側）をもたらすことができます。可能な限り、実装はTLS切断メッセージを使用して優雅なセッション終了を提供する必要があります。実装はまた、ハートビート[HEARTBEAT]または他の検出機構の使用を介して、「壊れた」セッションを検出する代わりに、システムを持っているべきです。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD limit the lifetime of established sessions depending on the algorithms used for generation of the master session secret, the privacy and integrity algorithms used to protect messages, the environment of the session, the amount of data transferred, and the sensitivity of the data.",
      "ja": "実装は、メッセージ、セッションの環境、転送されるデータの量、およびデータの機密性を保護するために使用、プライバシーと整合性アルゴリズムをマスターセッション秘密の生成に使用されるアルゴリズムに応じて、確立されたセッションの寿命を制限する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2. Notification Receiver Credential Selection",
      "section_title": true,
      "ja": "8.2。通知受信資格の選択"
    },
    {
      "indent": 3,
      "text": "When an SNMP engine needs to establish an outgoing session for notifications, the snmpTargetParamsTable includes an entry for the snmpTargetParamsSecurityName of the target. Servers that wish to support multiple principals at a particular port SHOULD make use of the Server Name Indication extension defined in Section 3.1 of [RFC4366]. Without the Server Name Indication the receiving SNMP engine (server) will not know which (D)TLS certificate to offer to the client so that the tmSecurityName identity-authentication will be successful.",
      "ja": "SNMPエンジンは、通知の発信セッションを確立する必要がある場合、たsnmpTargetParamsTableは、ターゲットのsnmpTargetParamsSecurityNameのためのエントリが含まれています。特定のポートで複数のプリンシパルをサポートしたいサーバーは、[RFC4366]のセクション3.1で定義されたサーバ名表示の拡張機能を利用するべきです。 tmSecurityNameのID認証が成功するように、サーバ名の表示のない受信SNMPエンジン（サーバー）は、クライアントに提供するためにどの（D）TLS証明書を知ることができません。"
    },
    {
      "indent": 3,
      "text": "Another solution is to maintain a one-to-one mapping between certificates and incoming ports for notification receivers. This can be handled at the notification originator by configuring the snmpTargetAddrTable (snmpTargetAddrTDomain and snmpTargetAddrTAddress) and requiring the receiving SNMP engine to monitor multiple incoming static ports based on which principals are capable of receiving notifications.",
      "ja": "別の解決策は、証明書と、通知受信のための受信ポートとの間に1対1のマッピングを維持することです。これは、のsnmpTargetAddrTable（snmpTargetAddrTDomainとsnmpTargetAddrTAddress）を構成し、プリンシパルが通知を受信することが可能であるかに基づいて複数の着信静的ポートを監視するために、受信したSNMPエンジンに要求することによって、通知元で処理することができます。"
    },
    {
      "indent": 3,
      "text": "Implementations MAY also choose to designate a single Notification Receiver Principal to receive all incoming notifications or select an implementation specific method of selecting a server certificate to present to clients.",
      "ja": "また、実装はすべての着信通知を受け取るか、クライアントに提示するサーバー証明書を選択する実装固有の方法を選択するために、単一の通知受信プリンシパルを指定することを選ぶかもしれ。"
    },
    {
      "indent": 0,
      "text": "8.3. contextEngineID Discovery",
      "section_title": true,
      "ja": "8.3。 contextEngineIDディスカバリー"
    },
    {
      "indent": 3,
      "text": "SNMPv3 requires that an application know the identifier (snmpEngineID) of the remote SNMP protocol engine in order to retrieve or manipulate objects maintained on the remote SNMP entity.",
      "ja": "SNMPv3は、アプリケーションがリモートSNMPエンティティで維持オブジェクトを取得または操作するために遠隔SNMPプロトコルエンジンの識別子（のsnmpEngineID）を知ることが必要です。"
    },
    {
      "indent": 3,
      "text": "[RFC5343] introduces a well-known localEngineID and a discovery mechanism that can be used to learn the snmpEngineID of a remote SNMP protocol engine. Implementations are RECOMMENDED to support and use the contextEngineID discovery mechanism defined in [RFC5343].",
      "ja": "[RFC5343]は周知localEngineIDとリモートSNMPプロトコルエンジンのsnmpEngineIDを学ぶために使用することができる検出メカニズムを導入します。実装は、[RFC5343]で定義されたcontextEngineID発見メカニズムをサポートし、使用することが推奨されます。"
    },
    {
      "indent": 0,
      "text": "8.4. Transport Considerations",
      "section_title": true,
      "ja": "8.4。交通に関する注意事項"
    },
    {
      "indent": 3,
      "text": "This document defines how SNMP messages can be transmitted over the TLS- and DTLS-based protocols. Each of these protocols are additionally based on other transports (TCP and UDP). These two base protocols also have operational considerations that must be taken into consideration when selecting a (D)TLS-based protocol to use such as its performance in degraded or limited networks. It is beyond the scope of this document to summarize the characteristics of these transport mechanisms. Please refer to the base protocol documents for details on messaging considerations with respect to MTU size, fragmentation, performance in lossy networks, etc.",
      "ja": "この文書では、SNMPメッセージがTLS-とDTLSベースのプロトコルを介して送信する方法を定義します。これらのプロトコルのそれぞれは、さらに、他のトランスポート（TCPおよびUDP）に基づいています。これら二つのベースプロトコルはまた、分解または制限されたネットワークにおいて、その性能として使用する（D）TLSベースのプロトコルを選択する際に考慮しなければならない操作上の考慮事項を有します。これは、これらのトランスポートメカニズムの特性を要約するために、このドキュメントの範囲を超えています。等のMTUサイズ、断片化、損失の多いネットワークのパフォーマンス、に対して、メッセージングの考慮事項の詳細については、基本プロトコル文書を参照してください"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document describes a transport model that permits SNMP to utilize (D)TLS security services. The security threats and how the (D)TLS transport model mitigates these threats are covered in detail throughout this document. Security considerations for DTLS are covered in [RFC4347] and security considerations for TLS are described in Section 11 and Appendices D, E, and F of TLS 1.2 [RFC5246]. When run over a connectionless transport such as UDP, DTLS is more vulnerable to denial-of-service attacks from spoofed IP addresses; see Section 4.2 for details how the cookie exchange is used to address this issue.",
      "ja": "この文書は、（D）TLSのセキュリティサービスを利用するためにSNMPを許可する輸送モデルを説明しています。セキュリティの脅威と（D）TLS輸送モデルは、これらの脅威は、本書で詳しく説明されている軽減する方法。セキュリティDTLSの考慮事項[RFC4347]でカバーされており、TLSのためのセキュリティ問題はセクション11及び付録Dに記載されており、E、およびTLS 1.2のF [RFC5246]。 UDPなどのコネクションレストランスポート上で実行すると、DTLSは、偽装されたIPアドレスからのサービス拒否攻撃に対して脆弱です。クッキー交換がこの問題に対処するために使用される方法の詳細については、セクション4.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.1. Certificates, Authentication, and Authorization",
      "section_title": true,
      "ja": "9.1。証明書、認証、および承認"
    },
    {
      "indent": 3,
      "text": "Implementations are responsible for providing a security certificate installation and configuration mechanism. Implementations SHOULD support certificate revocation lists.",
      "ja": "実装は、セキュリティ証明書のインストールおよび構成メカニズムを提供する責任があります。実装は、証明書失効リストをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "(D)TLS provides for authentication of the identity of both the (D)TLS server and the (D)TLS client. Access to MIB objects for the authenticated principal MUST be enforced by an access control subsystem (e.g., the VACM).",
      "ja": "（D）TLSは、（D）TLSサーバ及​​び（D）TLSクライアントの両方のIDの認証を提供します。認証されたプリンシパルのMIBオブジェクトへのアクセスは、アクセス制御サブシステムによって実施されなければならない（例えば、VACM）。"
    },
    {
      "indent": 3,
      "text": "Authentication of the command generator principal's identity is important for use with the SNMP access control subsystem to ensure that only authorized principals have access to potentially sensitive data. The authenticated identity of the command generator principal's certificate is mapped to an SNMP model-independent securityName for use with SNMP access control.",
      "ja": "コマンド発生校長のアイデンティティの認証にのみ許可校長が潜在的に機密データへのアクセス権を持っていることを確認するために、SNMPアクセス制御サブシステムで使用するために重要です。コマンド発生校長の証明書の認証されたIDは、SNMPアクセス制御で使用するためのSNMPモデルに依存しないセキュリティ名にマッピングされています。"
    },
    {
      "indent": 3,
      "text": "The (D)TLS handshake only provides assurance that the certificate of the authenticated identity has been signed by a configured accepted Certification Authority. (D)TLS has no way to further authorize or reject access based on the authenticated identity. An Access Control",
      "ja": "（D）TLSハンドシェイクは、認証されたアイデンティティの証明書を構成受け入れ証明機関によって署名されていることの保証を提供します。 （D）TLSは、さらに、認証されたIDに基づいてアクセスを許可または拒否する方法がありません。アクセス制御"
    },
    {
      "indent": 3,
      "text": "Model (such as the VACM) provides access control and authorization of a command generator's requests to a command responder and a notification receiver's authorization to receive Notifications from a notification originator. However, to avoid man-in-the-middle attacks, both ends of the (D)TLS-based connection MUST check the certificate presented by the other side against what was expected. For example, command generators must check that the command responder presented and authenticated itself with a X.509 certificate that was expected. Not doing so would allow an impostor, at a minimum, to present false data, receive sensitive information and/or provide a false belief that configuration was actually received and acted upon. Authenticating and verifying the identity of the (D)TLS server and the (D)TLS client for all operations ensures the authenticity of the SNMP engine that provides MIB data.",
      "ja": "（例えばVACMなどの）モデルは、コマンド応答通知元から通知を受信する通知受信者の許可にコマンドジェネレータの要求のアクセス制御および認証を提供します。しかしながら、man-in-the-middle攻撃を回避するために、（D）TLSベースの接続の両端が予想されたものに対して反対側が提示した証明書をチェックしなければなりません。たとえば、コマンド・ジェネレータは、コマンド応答者が提示され、期待されたX.509証明書を使用して自身を認証していることを確認しなければなりません。そうしないと、機密情報を受け取り、詐欺師は、最低でも、虚偽のデータを提示することができ、および/または構成は、実際に受信して作用して誤った信念を提供します。すべての操作（D）TLSサーバ及​​び（D）TLSクライアントのアイデンティティを認証し、検証するMIBデータを提供するSNMPエンジンの信頼性を保証します。"
    },
    {
      "indent": 3,
      "text": "The instructions found in the DESCRIPTION clause of the snmpTlstmCertToTSNTable object must be followed exactly. It is also important that the rows of the table be searched in prioritized order starting with the row containing the lowest numbered snmpTlstmCertToTSNID value.",
      "ja": "snmpTlstmCertToTSNTableオブジェクトの説明句で見つかった命令が正確に従わなければなりません。テーブルの行が最も小さい番号snmpTlstmCertToTSNID値を含む行から始まる優先順位の順序で検索されることも重要です。"
    },
    {
      "indent": 0,
      "text": "9.2. (D)TLS Security Considerations",
      "section_title": true,
      "ja": "9.2。 （D）TLSセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section discusses security considerations specific to the usage of (D)TLS.",
      "ja": "このセクションでは、（D）TLSの使用に固有のセキュリティ上の考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "9.2.1. TLS Version Requirements",
      "section_title": true,
      "ja": "9.2.1。 TLSバージョン要件"
    },
    {
      "indent": 3,
      "text": "Implementations of TLS typically support multiple versions of the Transport Layer Security protocol as well as the older Secure Sockets Layer (SSL) protocol. Because of known security vulnerabilities, TLSTM clients and servers MUST NOT request, offer, or use SSL 2.0. See Appendix E.2 of [RFC5246] for further details.",
      "ja": "TLSの実装は通常、複数のトランスポート層セキュリティプロトコルのバージョンと同様に古いのSecure Sockets Layer（SSL）プロトコルをサポートしています。そのため、既知のセキュリティの脆弱性のため、TLSTMクライアントとサーバは、提供を要求し、またはSSL 2.0を使用してはなりません。詳細は[RFC5246]の付録E.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.2.2. Perfect Forward Secrecy",
      "section_title": true,
      "ja": "9.2.2。完全転送秘密"
    },
    {
      "indent": 3,
      "text": "The use of Perfect Forward Secrecy is RECOMMENDED and can be provided by (D)TLS with appropriately selected cipher_suites, as discussed in Appendix F of [RFC5246].",
      "ja": "完全転送秘密の使用が推奨され、[RFC5246]の付録Fで説明したように、適切に選択cipher_suitesと（D）TLSによって提供することができます。"
    },
    {
      "indent": 0,
      "text": "9.3. Use with SNMPv1/SNMPv2c Messages",
      "section_title": true,
      "ja": "9.3。 SNMPv1 / SNMPv2cのメッセージを使用します"
    },
    {
      "indent": 3,
      "text": "The SNMPv1 and SNMPv2c message processing described in [RFC3584] (BCP 74) always selects the SNMPv1 or SNMPv2c Security Models, respectively. Both of these and the User-based Security Model typically used with SNMPv3 derive the securityName and securityLevel from the SNMP message received, even when the message was received over a secure transport. Access control decisions are therefore made based on the contents of the SNMP message, rather than using the authenticated identity and securityLevel provided by the TLS Transport Model. It is RECOMMENDED that only SNMPv3 messages using the Transport Security Model (TSM) or another secure-transport aware security model be sent over the TLSTM transport.",
      "ja": "[RFC3584]（BCP 74）に記載のSNMPv1およびSNMPv2cのメッセージ処理は常に、それぞれ、SNMPv1またはSNMPv2cのセキュリティモデルを選択します。通常のSNMPv3で使用されるこれらおよびユーザベースセキュリティモデルの両方は、メッセージが安全なトランスポートを介して受信された場合でも、受信したSNMPメッセージからセキュリティ名とたsecurityLevelを導き出します。アクセス制御の決定は、そのためではなく、TLS輸送モデルにより提供される認証されたIDとたsecurityLevelを使用するよりも、SNMPメッセージの内容に基づいて作られています。交通セキュリティモデル（TSM）または別のセキュア輸送意識したセキュリティモデルを使用してのみSNMPv3メッセージがTLSTMトランスポートを介して送られることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Using a non-transport-aware Security Model with a secure Transport Model is NOT RECOMMENDED. See [RFC5590] Section 7.1 for additional details on the coexistence of security-aware transports and non-transport-aware security models.",
      "ja": "安全な輸送モデルと非輸送対応のセキュリティモデルを使用することは推奨されません。 [RFC5590]セキュリティ対応のトランスポートおよび非トランスポート対応のセキュリティモデルの共存に関する追加の詳細については、7.1節を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.4. MIB Module Security",
      "section_title": true,
      "ja": "9.4。 MIBモジュールのセキュリティ"
    },
    {
      "indent": 3,
      "text": "There are a number of management objects defined in this MIB module with a MAX-ACCESS clause of read-write and/or read-create. Such objects may be considered sensitive or vulnerable in some network environments. The support for SET operations in a non-secure environment without proper protection can have a negative effect on network operations. These are the tables and objects and their sensitivity/vulnerability:",
      "ja": "読み書きおよび/またはリード作成のMAX-ACCESS句でこのMIBモジュールで定義された管理オブジェクトの数があります。そのようなオブジェクトは、いくつかのネットワーク環境に敏感又は脆弱と考えることができます。適切な保護のない非安全な環境におけるSET操作のサポートはネットワーク操作のときにマイナスの影響を与える可能性があります。これらは、テーブルと、オブジェクトとそれらの感度/脆弱性です："
    },
    {
      "indent": 3,
      "text": "o The snmpTlstmParamsTable can be used to change the outgoing X.509 certificate used to establish a (D)TLS connection. Modification to objects in this table need to be adequately authenticated since modification to values in this table will have profound impacts to the security of outbound connections from the device. Since knowledge of authorization rules and certificate usage mechanisms may be considered sensitive, protection from disclosure of the SNMP traffic via encryption is also highly recommended.",
      "ja": "O snmpTlstmParamsTableは、（D）TLS接続を確立するために使用される発信X.509証明書を変更するために使用することができます。この表のオブジェクトへの変更は、この表の値への変更は、デバイスからのアウトバウンド接続のセキュリティに深刻な影響を持つことになりますので、適切に認証される必要があります。承認規則と証明書の利用の仕組みの知識が敏感と考えることができるので、暗号化を介したSNMPトラフィックの開示からの保護も強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "o The snmpTlstmAddrTable can be used to change the expectations of the certificates presented by a remote (D)TLS server. Modification to objects in this table need to be adequately authenticated since modification to values in this table will have profound impacts to the security of outbound connections from the device. Since knowledge of authorization rules and certificate usage mechanisms may be considered sensitive, protection from disclosure of the SNMP traffic via encryption is also highly recommended.",
      "ja": "O snmpTlstmAddrTableは、リモート（D）TLSサーバによって提示された証明書の予想を変更するために使用することができます。この表のオブジェクトへの変更は、この表の値への変更は、デバイスからのアウトバウンド接続のセキュリティに深刻な影響を持つことになりますので、適切に認証される必要があります。承認規則と証明書の利用の仕組みの知識が敏感と考えることができるので、暗号化を介したSNMPトラフィックの開示からの保護も強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "o The snmpTlstmCertToTSNTable is used to specify the mapping of incoming X.509 certificates to tmSecurityNames, which eventually get mapped to a SNMPv3 securityName. Modification to objects in this table need to be adequately authenticated since modification to values in this table will have profound impacts to the security of incoming connections to the device. Since knowledge of authorization rules and certificate usage mechanisms may be considered sensitive, protection from disclosure of the SNMP traffic via encryption is also highly recommended. When this table contains a significant number of rows it may affect the system performance when accepting new (D)TLS connections.",
      "ja": "O snmpTlstmCertToTSNTableは、最終的にSNMPv3のセキュリティ名にマップされ得るtmSecurityNamesへの着信X.509証明書のマッピングを指定するために使用されます。この表のオブジェクトへの変更は、この表の値への変更は、デバイスへの着信接続のセキュリティに深刻な影響を持つことになりますので、適切に認証される必要があります。承認規則と証明書の利用の仕組みの知識が敏感と考えることができるので、暗号化を介したSNMPトラフィックの開示からの保護も強くお勧めします。このテーブルには、相当数の行が含まれている場合には、新たな（D）TLS接続を受け付けた場合には、システムのパフォーマンスに影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "Some of the readable objects in this MIB module (i.e., objects with a MAX-ACCESS other than not-accessible) may be considered sensitive or vulnerable in some network environments. It is thus important to control even GET and/or NOTIFY access to these objects and possibly to even encrypt the values of these objects when sending them over the network via SNMP. These are the tables and objects and their sensitivity/vulnerability:",
      "ja": "このMIBモジュールで読み取り可能なオブジェクトの一部（すなわち、アクセス可能ではない以外MAX-ACCESS持つオブジェクト）は、いくつかのネットワーク環境に敏感又は脆弱と考えることができます。 GETおよび/またはこれらのオブジェクトへのアクセスを通知し、おそらくSNMPを通してネットワークの上にそれらを送信する場合でも、これらのオブジェクトの値を暗号化するためにも、制御することが重要です。これらは、テーブルと、オブジェクトとそれらの感度/脆弱性です："
    },
    {
      "indent": 3,
      "text": "o This MIB contains a collection of counters that monitor the (D)TLS connections being established with a device. Since knowledge of connection and certificate usage mechanisms may be considered sensitive, protection from disclosure of the SNMP traffic via encryption is highly recommended.",
      "ja": "OこのMIBはデバイスとの間で確立される（D）TLS接続を監視カウンタのコレクションを含みます。接続と証明書の利用メカニズムの知識が敏感と考えることができるので、暗号化を介したSNMPトラフィックの開示からの保護を強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "SNMP versions prior to SNMPv3 did not include adequate security. Even if the network itself is secure (for example, by using IPsec), even then, there is no control as to who on the secure network is allowed to access and GET/SET (read/change/create/delete) the objects in this MIB module.",
      "ja": "SNMPv3の前のSNMPバージョンは十分なセキュリティを含んでいませんでした。ネットワーク自体が（例えば、IPsecを使用して）安全であっても、その後も、安全なネットワーク上で/ SETにアクセスし、GETだれに許容されているかのように何の制御（読み取り/変更/作成/削除）内のオブジェクトが存在しませんこのMIBモジュール。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that implementers consider the security features as provided by the SNMPv3 framework (see [RFC3410], Section 8), including full support for the SNMPv3 cryptographic mechanisms (for authentication and privacy).",
      "ja": "実装者がSNMPv3フレームワークで提供するようにセキュリティ機能を考えることが推奨される（認証とプライバシーのため）SNMPv3の暗号のメカニズムのためのフルサポートを含む、（、[RFC3410]のセクション8を参照）。"
    },
    {
      "indent": 3,
      "text": "Further, deployment of SNMP versions prior to SNMPv3 is NOT RECOMMENDED. Instead, it is RECOMMENDED to deploy SNMPv3 and to enable cryptographic security. It is then a customer/operator responsibility to ensure that the SNMP entity giving access to an instance of this MIB module is properly configured to give access to the objects only to those principals (users) that have legitimate rights to indeed GET or SET (change/create/delete) them.",
      "ja": "さらに、SNMPv3の前のSNMPバージョンの展開はお勧めしません。代わりに、SNMPv3を展開すると、暗号化セキュリティを有効にすることをお勧めします。このMIBモジュールのインスタンスへのアクセスを与えるSNMP実体が適切にのみプリンシパル（ユーザ）にオブジェクトへのアクセスを提供するように設定されていることを確認するために、顧客/オペレータ責任実際にGETまたはSET（変化への正当な権利を有することです/）/削除、それらを作成します。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has assigned:",
      "ja": "IANAが割り当てられています："
    },
    {
      "indent": 3,
      "text": "1. Two TCP/UDP port numbers from the \"Registered Ports\" range of the Port Numbers registry, with the following keywords:",
      "ja": "次のキーワードとポート番号のレジストリの「登録ポート」の範囲から1つのTCP / UDPポート番号、："
    },
    {
      "indent": 5,
      "text": "Keyword         Decimal      Description       References\n-------         -------      -----------       ----------\nsnmptls         10161/tcp    SNMP-TLS          [RFC5953]\nsnmpdtls        10161/udp    SNMP-DTLS         [RFC5953]\nsnmptls-trap    10162/tcp    SNMP-Trap-TLS     [RFC5953]\nsnmpdtls-trap   10162/udp    SNMP-Trap-DTLS    [RFC5953]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "These are the default ports for receipt of SNMP command messages (snmptls and snmpdtls) and SNMP notification messages (snmptls- trap and snmpdtls-trap) over a TLS Transport Model as defined in this document.",
      "ja": "この文書で定義されるように、これらは、SNMPのコマンドメッセージ（snmptlsとsnmpdtls）とTLS輸送モデルを超えるSNMP通知メッセージ（snmptls-トラップとsnmpdtlsトラップ）を受け取るためのデフォルトポートです。"
    },
    {
      "indent": 3,
      "text": "2. An SMI number (8) under snmpDomains for the snmpTLSTCPDomain object identifier",
      "ja": "snmpTLSTCPDomainオブジェクト識別子のsnmpDomains下2.アンSMI番号（8）"
    },
    {
      "indent": 3,
      "text": "3. An SMI number (9) under snmpDomains for the snmpDTLSUDPDomain object identifier",
      "ja": "snmpDTLSUDPDomainオブジェクト識別子のsnmpDomains 3.アンSMI番号（9）"
    },
    {
      "indent": 3,
      "text": "4. An SMI number (198) under mib-2, for the MIB module in this document",
      "ja": "この文書に記載されているMIBモジュールのMIB-2 4.アンSMI番号（198）、"
    },
    {
      "indent": 3,
      "text": "5. \"tls\" as the corresponding prefix for the snmpTLSTCPDomain in the SNMP Transport Domains registry",
      "ja": "SNMP交通ドメインレジストリでsnmpTLSTCPDomainに対応する接頭辞として5.「TLS」"
    },
    {
      "indent": 3,
      "text": "6. \"dtls\" as the corresponding prefix for the snmpDTLSUDPDomain in the SNMP Transport Domains registry",
      "ja": "SNMP交通ドメインレジストリでsnmpDTLSUDPDomainに対応する接頭辞として6.「DTLS」"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgements",
      "section_title": true,
      "ja": "11.謝辞"
    },
    {
      "indent": 3,
      "text": "This document closely follows and copies the Secure Shell Transport Model for SNMP documented by David Harrington and Joseph Salowey in [RFC5592].",
      "ja": "この文書では、密接に追随し、コピー[RFC5592]でデビッド・ハリントンとジョセフSaloweyによって文書SNMPのためのセキュアシェル輸送モデル。"
    },
    {
      "indent": 3,
      "text": "This document was reviewed by the following people who helped provide useful comments (in alphabetical order): Andy Donati, Pasi Eronen, David Harrington, Jeffrey Hutzelman, Alan Luchuk, Michael Peck, Tom Petch, Randy Presuhn, Ray Purvis, Peter Saint-Andre, Joseph Salowey, Juergen Schoenwaelder, Dave Shield, and Robert Story.",
      "ja": "アンディ・ドナーティ、パシEronen、デヴィッド・ハリントン、ジェフリーHutzelman、アランLuchuk、マイケル・ペック、トム・ペッチ、ランディPresuhn、レイ・パーヴィス、ピーターサンアンドレ：この文書は（アルファベット順）有益なコメントを提供助け以下の人々によって検討されました、ジョセフSalowey、ユルゲンSchoenwaelder、デイブ盾、そしてロバート・ストーリー。"
    },
    {
      "indent": 3,
      "text": "This work was supported in part by the United States Department of Defense. Large portions of this document are based on work by General Dynamics C4 Systems and the following individuals: Brian Baril, Kim Bryant, Dana Deluca, Dan Hanson, Tim Huemiller, John Holzhauer, Colin Hoogeboom, Dave Kornbau, Chris Knaian, Dan Knaul, Charles Limoges, Steve Moccaldi, Gerardo Orlando, and Brandon Yip.",
      "ja": "この作品は、米国国防総省によって部分的にサポートされていました。このドキュメントの大部分は、ゼネラルダイナミクスC4システムと以下の個人での作業に基づいています：ブライアン・バリル、キム・ブライアント、ダナ・デルーカ、ダン・ハンソン、ティムHuemiller、ジョンHolzhauer、コリン・Hoogeboom、デイブKornbau、クリスKnaian、ダンKnaul、チャールズリモージュ、スティーブMoccaldi、ヘラルド・オーランド、ブランドン・イップ。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12.参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1033] Lottor, M., \"Domain administrators operations guide\", RFC 1033, November 1987.",
      "ja": "[RFC1033] Lottor、M.、 \"ドメイン管理者操作ガイド\"、RFC 1033、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2578] McCloghrie, K., Ed., Perkins, D., Ed., and J. Schoenwaelder, Ed., \"Structure of Management Information Version 2 (SMIv2)\", STD 58, RFC 2578, April 1999.",
      "ja": "[RFC2578] McCloghrie、K.、エド。、パーキンス、D.、編、及びJ. Schoenwaelder、編、STD 58、RFC 2578、 \"経営情報バージョン2（SMIv2）の構造\"、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2579] McCloghrie, K., Ed., Perkins, D., Ed., and J. Schoenwaelder, Ed., \"Textual Conventions for SMIv2\", STD 58, RFC 2579, April 1999.",
      "ja": "[RFC2579] McCloghrie、K.、エド。、パーキンス、D.、編、及びJ. Schoenwaelder、エド。、 \"SMIv2のためのテキストの表記法\"、STD 58、RFC 2579、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2580] McCloghrie, K., Perkins, D., and J. Schoenwaelder, \"Conformance Statements for SMIv2\", STD 58, RFC 2580, April 1999.",
      "ja": "[RFC2580] McCloghrie、K.、パーキンス、D.、およびJ. Schoenwaelder、 \"SMIv2のための適合性宣言\"、STD 58、RFC 2580、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3411] Harrington, D., Presuhn, R., and B. Wijnen, \"An Architecture for Describing Simple Network Management Protocol (SNMP) Management Frameworks\", STD 62, RFC 3411, December 2002.",
      "ja": "[RFC3411]ハリントン、D.、Presuhn、R.、およびB. Wijnenの、 \"簡易ネットワーク管理プロトコル（SNMP）管理フレームワークを記述するためのアーキテクチャ\"、STD 62、RFC 3411、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3413] Levi, D., Meyer, P., and B. Stewart, \"Simple Network Management Protocol (SNMP) Applications\", STD 62, RFC 3413, December 2002.",
      "ja": "[RFC3413]レビ、D.、マイヤー、P.、およびB.スチュワート、 \"簡易ネットワーク管理プロトコル（SNMP）アプリケーション\"、STD 62、RFC 3413、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3414] Blumenthal, U. and B. Wijnen, \"User-based Security Model (USM) for version 3 of the Simple Network Management Protocol (SNMPv3)\", STD 62, RFC 3414, December 2002.",
      "ja": "、STD 62、RFC 3414、2002年12月 \"簡易ネットワーク管理プロトコル（SNMPv3の）のバージョン3のためのユーザベースセキュリティモデル（USM）\" [RFC3414]ブルーメンソール、U.とB. Wijnenの、。"
    },
    {
      "indent": 3,
      "text": "[RFC3415] Wijnen, B., Presuhn, R., and K. McCloghrie, \"View-based Access Control Model (VACM) for the Simple Network Management Protocol (SNMP)\", STD 62, RFC 3415, December 2002.",
      "ja": "[RFC3415] Wijnenの、B.、Presuhn、R.、およびK. McCloghrie、 \"簡易ネットワーク管理プロトコルのためのビューベースアクセス制御モデル（VACM）（SNMP）\"、STD 62、RFC 3415、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3418] Presuhn, R., \"Management Information Base (MIB) for the Simple Network Management Protocol (SNMP)\", STD 62, RFC 3418, December 2002.",
      "ja": "、STD 62、RFC 3418、2002年12月 \"簡易ネットワーク管理プロトコル（SNMP）管理情報ベース（MIB）\" [RFC3418] Presuhn、R.、。"
    },
    {
      "indent": 3,
      "text": "[RFC3490] Faltstrom, P., Hoffman, P., and A. Costello, \"Internationalizing Domain Names in Applications (IDNA)\", RFC 3490, March 2003.",
      "ja": "[RFC3490] Faltstrom、P.、ホフマン、P.、およびA.コステロ、 \"アプリケーションにおける国際化ドメイン名（IDNA）\"、RFC 3490、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3584] Frye, R., Levi, D., Routhier, S., and B. Wijnen, \"Coexistence between Version 1, Version 2, and Version 3 of the Internet-standard Network Management Framework\", BCP 74, RFC 3584, August 2003.",
      "ja": "[RFC3584]フライ、R.、レヴィ、D.、Routhier、S.、およびB. Wijnenの、 \"バージョン1、バージョン2、及びインターネット標準ネットワーク管理フレームワークのバージョン3の間の共存\"、BCP 74、RFC 3584 、2003年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security\", RFC 4347, April 2006.",
      "ja": "[RFC4347]レスコラ、E.およびN. Modadugu、 \"データグラムトランスポート層セキュリティ\"、RFC 4347、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4366] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, \"Transport Layer Security (TLS) Extensions\", RFC 4366, April 2006.",
      "ja": "[RFC4366]ブレイク・ウィルソン、S.、Nystrom、M.、ホップウッド、D.、ミケルセン、J.、およびT.ライト、 \"トランスポート層セキュリティ（TLS）拡張機能\"、RFC 4366、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5590] Harrington, D. and J. Schoenwaelder, \"Transport Subsystem for the Simple Network Management Protocol (SNMP)\", RFC 5590, June 2009.",
      "ja": "[RFC5590]ハリントン、D.とJ. Schoenwaelder、RFC 5590、2009年6月 \"簡易ネットワーク管理プロトコル（SNMP）のための輸送サブシステム\"。"
    },
    {
      "indent": 3,
      "text": "[RFC5591] Harrington, D. and W. Hardaker, \"Transport Security Model for the Simple Network Management Protocol (SNMP)\", RFC 5591, June 2009.",
      "ja": "[RFC5591]ハリントン、D.およびW. Hardaker、RFC 5591、2009年6月 \"簡易ネットワーク管理プロトコル（SNMP）のためのトランスポート・セキュリティモデル\"。"
    },
    {
      "indent": 3,
      "text": "[RFC5952] Kawamura, S. and M. Kawashima, \"A Recommendation for IPv6 Address Text Representation\", RFC 5952, August 2010.",
      "ja": "[RFC5952]川村、S.とM.川島、RFC 5952、2010年8月、 \"IPv6アドレスのテキスト表現のための勧告\"。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC3410] Case, J., Mundy, R., Partain, D., and B. Stewart, \"Introduction and Applicability Statements for Internet-Standard Management Framework\", RFC 3410, December 2002.",
      "ja": "[RFC3410]ケース、J.、マンディ、R.、パーテイン、D.、およびB.スチュワート、 \"インターネット標準の管理フレームワークのための序論と適用性声明\"、RFC 3410、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5343] Schoenwaelder, J., \"Simple Network Management Protocol (SNMP) Context EngineID Discovery\", RFC 5343, September 2008.",
      "ja": "[RFC5343] Schoenwaelder、J.、 \"簡易ネットワーク管理プロトコル（SNMP）コンテキストENGINEIDディスカバリー\"、RFC 5343、2008年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5592] Harrington, D., Salowey, J., and W. Hardaker, \"Secure Shell Transport Model for the Simple Network Management Protocol (SNMP)\", RFC 5592, June 2009.",
      "ja": "[RFC5592]ハリントン、D.、Salowey、J.、およびW. Hardakerは、RFC 5592、2009年6月 \"シェル輸送モデルは、簡易ネットワーク管理プロトコル（SNMP）のための安全な\"。"
    },
    {
      "indent": 3,
      "text": "[HEARTBEAT] Seggelmann, R., Tuexen, M., and M. Williams, \"Transport Layer Security and Datagram Transport Layer Security Heartbeat Extension\", Work in Progress, February 2010.",
      "ja": "[HEARTBEAT] Seggelmann、R.、Tuexen、M.、およびM.ウィリアムズ、 \"トランスポートレイヤセキュリティとデータグラムトランスポートレイヤセキュリティハートビート拡張\"、進歩、2010年2月での作業。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Target and Notification Configuration Example",
      "ja": "付録A.ターゲットと通知の設定例"
    },
    {
      "indent": 3,
      "text": "The following sections describe example configuration for the SNMP-TLS-TM-MIB, the SNMP-TARGET-MIB, the NOTIFICATION-MIB, and the SNMP-VIEW-BASED-ACM-MIB.",
      "ja": "以下の節では、SNMP-TLS-TM-MIB、SNMP-TARGET-MIB、NOTIFICATION-MIB、およびSNMP-VIEW-BASED-ACM-MIBのための構成例を記載しています。"
    },
    {
      "indent": 0,
      "text": "A.1. Configuring a Notification Originator",
      "ja": "A.1。通知の発信元を設定"
    },
    {
      "indent": 3,
      "text": "The following row adds the \"Joe Cool\" user to the \"administrators\" group:",
      "ja": "次の行は、「管理者」グループに「ジョー・クール」のユーザーを追加します。"
    },
    {
      "indent": 7,
      "text": "vacmSecurityModel              = 4 (TSM)\nvacmSecurityName               = \"Joe Cool\"\nvacmGroupName                  = \"administrators\"\nvacmSecurityToGroupStorageType = 3 (nonVolatile)\nvacmSecurityToGroupStatus      = 4 (createAndGo)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following row configures the snmpTlstmAddrTable to use certificate path validation and to require the remote notification receiver to present a certificate for the \"server.example.org\" identity.",
      "ja": "次の行は、証明書パスの検証を使用すると「server.example.org」同一の証明書を提示する遠隔通知受信を要求するsnmpTlstmAddrTableを構成します。"
    },
    {
      "indent": 7,
      "text": "snmpTargetAddrName             =  \"toNRAddr\"\nsnmpTlstmAddrServerFingerprint =  \"\"\nsnmpTlstmAddrServerIdentity    =  \"server.example.org\"\nsnmpTlstmAddrStorageType       =  3         (nonVolatile)\nsnmpTlstmAddrRowStatus         =  4         (createAndGo)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following row configures the snmpTargetAddrTable to send notifications using TLS/TCP to the snmptls-trap port at 192.0.2.1:",
      "ja": "次の行は、192.0.2.1でsnmptlsトラップポートにTLS / TCPを使用して通知を送信するためのsnmpTargetAddrTableを設定します。"
    },
    {
      "indent": 7,
      "text": "snmpTargetAddrName              = \"toNRAddr\"\nsnmpTargetAddrTDomain           = snmpTLSTCPDomain\nsnmpTargetAddrTAddress          = \"192.0.2.1:10162\"\nsnmpTargetAddrTimeout           = 1500\nsnmpTargetAddrRetryCount        = 3\nsnmpTargetAddrTagList           = \"toNRTag\"\nsnmpTargetAddrParams            = \"toNR\"     (MUST match below)\nsnmpTargetAddrStorageType       = 3          (nonVolatile)\nsnmpTargetAddrColumnStatus      = 4          (createAndGo)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following row configures the snmpTargetParamsTable to send the notifications to \"Joe Cool\", using authPriv SNMPv3 notifications through the TransportSecurityModel [RFC5591]:",
      "ja": "次の行はTransportSecurityModel [RFC5591]を介しauthPrivのSNMPv3の通知を使用して、「ジョー・クール」に通知を送信するたsnmpTargetParamsTableを設定します。"
    },
    {
      "indent": 7,
      "text": "snmpTargetParamsName            = \"toNR\"     (must match above)\nsnmpTargetParamsMPModel         = 3 (SNMPv3)\nsnmpTargetParamsSecurityModel   = 4 (TransportSecurityModel)\nsnmpTargetParamsSecurityName    = \"Joe Cool\"\nsnmpTargetParamsSecurityLevel   = 3          (authPriv)\nsnmpTargetParamsStorageType     = 3          (nonVolatile)\nsnmpTargetParamsRowStatus       = 4          (createAndGo0",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.2. Configuring TLSTM to Utilize a Simple Derivation of tmSecurityName",
      "ja": "A.2。 tmSecurityNameの簡単な導出を利用するTLSTMの設定"
    },
    {
      "indent": 3,
      "text": "The following row configures the snmpTlstmCertToTSNTable to map a validated client certificate, referenced by the client's public X.509 hash fingerprint, to a tmSecurityName using the subjectAltName component of the certificate.",
      "ja": "次の行は、証明書ののsubjectAltNameコンポーネントを使用tmSecurityNameに、クライアントの公開X.509ハッシュ指紋によって参照さ検証クライアント証明書をマッピングするsnmpTlstmCertToTSNTableを構成します。"
    },
    {
      "indent": 7,
      "text": "snmpTlstmCertToTSNID          = 1\n                                (chosen by ordering preference)\nsnmpTlstmCertToTSNFingerprint = HASH (appropriate fingerprint)\nsnmpTlstmCertToTSNMapType     = snmpTlstmCertSANAny\nsnmpTlstmCertToTSNData        = \"\"  (not used)\nsnmpTlstmCertToTSNStorageType = 3   (nonVolatile)\nsnmpTlstmCertToTSNRowStatus   = 4   (createAndGo)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This type of configuration should only be used when the naming conventions of the (possibly multiple) Certification Authorities are well understood, so two different principals cannot inadvertently be identified by the same derived tmSecurityName.",
      "ja": "このタイプの構成は、（場合によっては複数）証明機関はよく理解されているので、2つの異なるプリンシパルが誤って同じ由来tmSecurityNameによって同定することができない。のときに命名規則を使用しなければなりません"
    },
    {
      "indent": 0,
      "text": "A.3. Configuring TLSTM to Utilize Table-Driven Certificate Mapping",
      "ja": "A.3。テーブル駆動証明書マッピングを利用するTLSTMの設定"
    },
    {
      "indent": 3,
      "text": "The following row configures the snmpTlstmCertToTSNTable to map a validated client certificate, referenced by the client's public X.509 hash fingerprint, to the directly specified tmSecurityName of \"Joe Cool\".",
      "ja": "次の行は、「クールジョー」の直接指定tmSecurityNameに、クライアントの公開X.509のハッシュ指紋が参照する検証されたクライアント証明書を、マップするためにsnmpTlstmCertToTSNTableを設定します。"
    },
    {
      "indent": 7,
      "text": "snmpTlstmCertToTSNID           = 2\n                                 (chosen by ordering preference)\nsnmpTlstmCertToTSNFingerprint  = HASH (appropriate fingerprint)\nsnmpTlstmCertToTSNMapType      = snmpTlstmCertSpecified\nsnmpTlstmCertToTSNSecurityName = \"Joe Cool\"\nsnmpTlstmCertToTSNStorageType  = 3  (nonVolatile)\nsnmpTlstmCertToTSNRowStatus    = 4  (createAndGo)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Wes Hardaker SPARTA, Inc. P.O. Box 382 Davis, CA 95617 USA",
      "ja": "ウェスHardaker SPARTA、株式会社私書箱382デイビス、CA 95617 USA箱"
    },
    {
      "indent": 3,
      "text": "Phone: +1 530 792 1913 EMail: ietf@hardakers.net",
      "ja": "電話：+1 530 792 1913 Eメール：ietf@hardakers.net"
    }
  ]
}