{
  "title": {
    "text": "RFC 5842 - Binding Extensions to Web Distributed Authoring and Versioning (WebDAV)",
    "ja": "RFC 5842 - Web分散オーサリングとバージョン管理（WebDAV）への結合の拡張"
  },
  "number": 5842,
  "created_at": "2019-10-29 16:19:34.287953+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          G. Clemm\nRequest for Comments: 5842                                           IBM\nCategory: Experimental                                       J. Crawford\nISSN: 2070-1721                                             IBM Research\n                                                         J. Reschke, Ed.\n                                                              greenbytes\n                                                            J. Whitehead\n                                                         U.C. Santa Cruz\n                                                              April 2010",
      "raw": true
    },
    {
      "indent": 11,
      "text": "              Binding Extensions to\nWeb Distributed Authoring and Versioning (WebDAV)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This specification defines bindings, and the BIND method for creating multiple bindings to the same resource. Creating a new binding to a resource causes at least one new URI to be mapped to that resource. Servers are required to ensure the integrity of any bindings that they allow to be created.",
      "ja": "この仕様は、バインディングを定義し、同じリソースに複数のバインディングを作成するためのBINDの方法。リソースへの新しいバインディングを作成すると、少なくとも1つの新しいURIはそのリソースにマッピングされるようにします。サーバは、彼らが作成できるようにする任意のバインディングの整合性を確保するために必要とされています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5842.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc5842で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2010 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Terminology ................................................5\n   1.2. Method Preconditions and Postconditions ....................6\n2. Overview of Bindings ............................................7\n   2.1. Bindings to Collections ....................................7\n        2.1.1. Bind Loops ..........................................8\n   2.2. URI Mappings Created by a New Binding ......................8\n   2.3. COPY and Bindings ..........................................9\n        2.3.1. Example: COPY with \"Depth: infinity\" in\n               Presence of Bind Loops .............................11\n        2.3.2. Example: COPY Updating Multiple Bindings ...........13\n        2.3.3. Example: COPY with \"Depth: infinity\" with\n               Multiple Bindings to a Leaf Resource ...............14\n   2.4. DELETE and Bindings .......................................15\n   2.5. MOVE and Bindings .........................................15\n        2.5.1. Example: Simple MOVE ...............................16\n        2.5.2. Example: MOVE Request Causing a Bind Loop ..........16\n   2.6. PROPFIND and Bindings .....................................18",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   2.7. Determining Whether Two Bindings Are to the Same\n        Resource ..................................................18\n   2.8. Discovering the Bindings to a Resource ....................19\n3. Properties .....................................................19\n   3.1. DAV:resource-id Property ..................................20\n   3.2. DAV:parent-set Property ...................................20\n        3.2.1. Example for DAV:parent-set Property ................20\n4. BIND Method ....................................................21\n   4.1. Example: BIND .............................................24\n5. UNBIND Method ..................................................24\n   5.1. Example: UNBIND ...........................................26\n6. REBIND Method ..................................................26\n   6.1. Example: REBIND ...........................................28\n   6.2. Example: REBIND in Presence of Locks and Bind Loops .......29\n7. Additional Status Codes ........................................31\n   7.1. 208 Already Reported ......................................31\n        7.1.1. Example: PROPFIND by Bind-Aware Client .............32\n        7.1.2. Example: PROPFIND by Non-Bind-Aware Client .........34\n   7.2. 508 Loop Detected .........................................34\n8. Capability Discovery ...........................................34\n   8.1. OPTIONS Method ............................................34\n   8.2. 'DAV' Request Header ......................................34\n9. Relationship to Locking in WebDAV ..............................35\n   9.1. Example: Locking and Multiple Bindings ....................36\n10. Relationship to WebDAV Access Control Protocol ................37\n11. Relationship to Versioning Extensions to WebDAV ...............37\n12. Security Considerations .......................................40\n   12.1. Privacy Concerns .........................................40\n   12.2. Bind Loops ...............................................40\n   12.3. Bindings and Denial of Service ...........................40\n   12.4. Private Locations May Be Revealed ........................40\n   12.5. DAV:parent-set and Denial of Service .....................41\n13. Internationalization Considerations ...........................41\n14. IANA Considerations ...........................................41\n15. Acknowledgements ..............................................41\n16. References ....................................................41\n   16.1. Normative References .....................................41\n   16.2. Informative References ...................................42\nIndex .............................................................42",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This specification extends the WebDAV Distributed Authoring Protocol ([RFC4918]) to enable clients to create new access paths to existing resources. This capability is useful for several reasons:",
      "ja": "この仕様は既存のリソースへの新しいアクセス・パスを作成するには、クライアントを有効にするには、オーサリングプロトコル（[RFC4918]）分散WebDAVを拡張します。この機能は、いくつかの理由のために有用です："
    },
    {
      "indent": 3,
      "text": "URIs of WebDAV-compliant resources are hierarchical and correspond to a hierarchy of collections in resource space. The WebDAV Distributed Authoring Protocol makes it possible to organize these resources into hierarchies, placing them into groupings, known as collections, which are more easily browsed and manipulated than a single flat collection. However, hierarchies require categorization decisions that locate resources at a single location in the hierarchy, a drawback when a resource has multiple valid categories. For example, in a hierarchy of vehicle descriptions containing collections for cars and boats, a description of a combination car/boat vehicle could belong in either collection. Ideally, the description should be accessible from both. Allowing clients to create new URIs that access the existing resource lets them put that resource into multiple collections.",
      "ja": "WebDAVの準拠リソースのURIは階層構造になっているとリソース空間内のコレクションの階層に対応しています。オーサリングプロトコル分散WebDAVは、より簡単に、単一のフラットコレクションより閲覧、操作されているコレクションとして知られているグループ、にそれらを配置し、階層にこれらのリソースを整理することが可能となります。しかし、階層は、リソースが複数の有効なカテゴリを持っている場合、階層内の単一の場所で欠点がリソースを見つけ分類の決定を必要とします。例えば、車やボートのためのコレクションを含む車両記述の階層に、組み合わせの車/ボート車両の説明は、コレクションのいずれかに属している可能性があります。理想的には、説明は両方からアクセスできる必要があります。クライアントは、既存のリソースにアクセスする新しいURIを作成できるようにすると、それらが複数のコレクションにそのリソースを置くことができます。"
    },
    {
      "indent": 3,
      "text": "Hierarchies also make resource sharing more difficult, since resources that have utility across many collections are still forced into a single collection. For example, the mathematics department at one university might create a collection of information on fractals that contains bindings to some local resources but also provides access to some resources at other universities. For many reasons, it may be undesirable to make physical copies of the shared resources on the local server, for example, to conserve disk space, to respect copyright constraints, or to make any changes in the shared resources visible automatically. Being able to create new access paths to existing resources in other collections or even on other servers is useful for this sort of case.",
      "ja": "多くのコレクション全体の有用性を持っているリソースがまだシングルコレクションに強制されるので、階層はまた、リソース共有をより困難にします。例えば、ある大学で数学部門では、いくつかのローカルリソースへのバインディングが含まれているだけでなく、他の大学でいくつかのリソースへのアクセスを提供フラクタル上の情報の収集を作成することがあります。多くの理由から、ディスクスペースを節約するために著作権の制約を尊重する、または自動的に表示、共有リソースの変更を行うために、例えば、ローカルサーバー上の共有リソースの物理的なコピーを作成するために望ましくないかもしれません。他のコレクションで、あるいは他のサーバー上の既存のリソースへの新しいアクセス・パスを作成できることは、例、この種のために有用です。"
    },
    {
      "indent": 3,
      "text": "The BIND method, defined here, provides a mechanism for allowing clients to create alternative access paths to existing WebDAV resources. HTTP [RFC2616] and WebDAV [RFC4918] methods are able to work because there are mappings between URIs and resources. A method is addressed to a URI, and the server follows the mapping from that URI to a resource, applying the method to that resource. Multiple URIs may be mapped to the same resource, but until now, there has been no way for clients to create additional URIs mapped to existing resources.",
      "ja": "ここで定義されたBINDの方法は、クライアントは既存のWebDAVリソースへの代替アクセス・パスを作成することを可能にするためのメカニズムを提供します。 HTTP [RFC2616]とWebDAV [RFC4918]の方法はURIとリソースの間のマッピングがあるので仕事することができます。この方法は、URIに宛てて、サーバはそのリソースへの方法を適用する、リソースにそのURIからのマッピングに従います。複数のURIが同じリソースにマッピングすることができるが、今までは、クライアントは既存のリソースにマッピングされた追加のURIを作成するための手立てがなかったです。"
    },
    {
      "indent": 3,
      "text": "BIND lets clients associate a new URI with an existing WebDAV resource, and this URI can then be used to submit requests to the resource. Since URIs of WebDAV resources are hierarchical, and correspond to a hierarchy of collections in resource space, the BIND method also has the effect of adding the resource to a collection. As new URIs are associated with the resource, it appears in additional collections.",
      "ja": "BINDは、クライアントが既存のWebDAVリソースに新しいURIを関連付けることができますし、このURIはそのリソースへの要求を提出するために使用することができます。 WebDAVのリソースのURIは階層的であり、リソース空間におけるコレクションの階層に対応するので、BINDの方法はまた、コレクションにリソースを追加する効果を有します。新しいURIは、リソースに関連付けられているとして、それは追加のコレクションに表示されます。"
    },
    {
      "indent": 3,
      "text": "A BIND request does not create a new resource, but simply makes a new URI for submitting requests to an existing resource available. The new URI is indistinguishable from any other URI when submitting a request to a resource. Only one round trip is needed to submit a request to the intended target. Servers are required to enforce the integrity of the relationships between the new URIs and the resources associated with them. Consequently, it may be very costly for servers to support BIND requests that cross server boundaries.",
      "ja": "BIND要求は、新しいリソースを作成するのではなく、単純に利用できる既存のリソースに要求を提出するための新しいURIを作成しません。リソースへの要求を提出するときに、新しいURIは、他のURIと区別がつきません。一つだけのラウンドトリップが目的のターゲットに要求を提出することが必要とされています。サーバは新しいURIとそれらに関連付けられているリソース間の関係の整合性を適用する必要があります。サーバーは、サーバーの境界を越えBIND要求をサポートするために結果的に、それは非常にコストがかかる可能性があります。"
    },
    {
      "indent": 3,
      "text": "This specification is organized as follows. Section 1.1 defines terminology used in the rest of the specification, while Section 2 overviews bindings. Section 3 defines the new properties needed to support multiple bindings to the same resource. Section 4 specifies the BIND method, used to create multiple bindings to the same resource. Section 5 specifies the UNBIND method, used to remove a binding to a resource. Section 6 specifies the REBIND method, used to move a binding to another collection.",
      "ja": "次のようにこの仕様は構成されています。セクション1.1は、セクション2概要バインディングながら、本明細書の残りの部分で使用される用語を定義します。第3節では、同じリソースに複数のバインディングをサポートするために必要な新しいプロパティを定義します。セクション4は、同じリソースに複数のバインディングを作成するために使用されるBIND方式を指定します。第5節では、リソースへの結合を除去するために使用されるUNBIND方法を指定します。第6節は、別のコレクションへの結合を移動するために使用さREBIND方法を指定します。"
    },
    {
      "indent": 0,
      "text": "1.1. Terminology",
      "section_title": true,
      "ja": "1.1。用語"
    },
    {
      "indent": 3,
      "text": "The terminology used here follows and extends that in the WebDAV Distributed Authoring Protocol specification [RFC4918].",
      "ja": "ここで使用される用語は、以下とWebDAVでオーサリングプロトコル仕様[RFC4918]を分散することを延びています。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document uses XML DTD fragments ([XML]) as a notational convention, using the rules defined in Section 17 of [RFC4918].",
      "ja": "このドキュメントは[RFC4918]のセクション17で定義されたルールを使用して、表記規則としてXML DTD断片（[XML]）を使用します。"
    },
    {
      "indent": 3,
      "text": "URI Mapping",
      "ja": "URIマッピング"
    },
    {
      "indent": 6,
      "text": "A relation between an absolute URI and a resource. For an absolute URI U and the resource it identifies R, the URI mapping can be thought of as (U => R). Since a resource can represent items that are not network retrievable as well as those that are, it is possible for a resource to have zero, one, or many URI mappings. Mapping a resource to an \"http\"-scheme URI makes it possible to submit HTTP requests to the resource using the URI.",
      "ja": "絶対URIとリソースの間の関係。絶対URI UとそれがRを識別するリソースは、URIマッピングはとして（U => R）と考えることができます。リソースが同様であるものとして回収ネットワークされていないアイテムを表すことができるので、リソースは0個、1個、または多数のURIマッピングを持っているため、それが可能です。 「http」をリソースマッピング-scheme URIは、それが可能なURIを使用してリソースへのHTTPリクエストを提出することができます。"
    },
    {
      "indent": 3,
      "text": "Path Segment",
      "ja": "パスセグメント"
    },
    {
      "indent": 6,
      "text": "Informally, the characters found between slashes (\"/\") in a URI. Formally, as defined in Section 3.3 of [RFC3986].",
      "ja": "非公式に、文字はURIにスラッシュ（「/」）との間に見られます。正式には、[RFC3986]のセクション3.3で定義された通りです。"
    },
    {
      "indent": 3,
      "text": "Binding",
      "ja": "バインディング"
    },
    {
      "indent": 6,
      "text": "A relation between a single path segment (in a collection) and a resource. A binding is part of the state of a collection. If two different collections contain a binding between the same path segment and the same resource, these are two distinct bindings. So for a collection C, a path segment S, and a resource R, the binding can be thought of as C:(S -> R). Bindings create URI mappings, and hence allow requests to be sent to a single resource from multiple locations in a URI namespace. For example, given a collection C (accessible through the URI http://www.example.com/CollX), a path segment S (equal to \"foo.html\"), and a resource R, then creating the binding C: (S -> R) makes it possible to use the URI http://www.example.com/CollX/foo.html to access R.",
      "ja": "（コレクション内の）単一パスセグメントとリソースの間の関係。バインディングは、コレクションの状態の一部です。二つの異なるコレクションが同一の経路セグメントと同一のリソースとの間の結合を含む場合、これらは、2つの別個の結合です。 （ - > R S）：そう収集Cのために、経路セグメントS、およびリソースR、結合はCと考えることができます。バインディングは、URIのマッピングを作成し、ひいては要求はURI名前空間の複数の場所から単一のリソースに送信することを可能にします。例えば、その後、結合Cを作成収集C（URI http://www.example.com/CollXを介してアクセス可能）、パスセグメントS（「foo.htmlという」に等しい）、及びリソースRを、与えられました： （S  - > R）がRをアクセスするためのURI http://www.example.com/CollX/foo.htmlを使用することができます"
    },
    {
      "indent": 3,
      "text": "Collection",
      "ja": "コレクション"
    },
    {
      "indent": 6,
      "text": "A resource that contains, as part of its state, a set of bindings that identify internal member resources.",
      "ja": "その状態の一部として含むリソース、内部部材のリソースを識別するバインディングのセット。"
    },
    {
      "indent": 3,
      "text": "Internal Member URI",
      "ja": "内部メンバーURI"
    },
    {
      "indent": 6,
      "text": "The URI that identifies an internal member of a collection and that consists of the URI for the collection, followed by a slash character ('/'), followed by the path segment of the binding for that internal member.",
      "ja": "コレクションの内部メンバを識別し、それはその内部メンバーの結合のパスセグメントに続くスラッシュ（「/」）、続いて収集のためURIから成るURI。"
    },
    {
      "indent": 3,
      "text": "Binding Integrity",
      "ja": "バインディングの整合性"
    },
    {
      "indent": 6,
      "text": "The property of a binding that says that:",
      "ja": "言う結合のプロパティ："
    },
    {
      "indent": 6,
      "text": "* the binding continues to exist, and",
      "ja": "*存在し続け、および結合"
    },
    {
      "indent": 6,
      "text": "* the identity of the resource identified by that binding does not change,",
      "ja": "*その結合することによって識別されるリソースのアイデンティティは変更されません、"
    },
    {
      "indent": 6,
      "text": "unless an explicit request is executed that is defined to delete that binding (examples of requests that delete a binding are DELETE, MOVE, and -- defined later on -- UNBIND and REBIND).",
      "ja": "（ - 後で定義 - アンバインドし、REBINDれる結合DELETE、MOVEを削除し、要求の一例）を明示的な要求が実行されない限り、それが結合することを削除するように定義されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Method Preconditions and Postconditions",
      "section_title": true,
      "ja": "1.2。メソッドの事前条件と事後条件"
    },
    {
      "indent": 3,
      "text": "See Section 16 of [RFC4918] for the definitions of \"precondition\" and \"postcondition\".",
      "ja": "「前提条件」と「事後条件」の定義については、[RFC4918]のセクション16を参照してください。"
    },
    {
      "indent": 0,
      "text": "2. Overview of Bindings",
      "section_title": true,
      "ja": "バインディングの概要2。"
    },
    {
      "indent": 3,
      "text": "Bindings are part of the state of a collection. They define the internal members of the collection and the names of those internal members.",
      "ja": "バインディングは、コレクションの状態の一部です。彼らは、コレクションの内部メンバーとそれらの内部のメンバーの名前を定義します。"
    },
    {
      "indent": 3,
      "text": "Bindings are added and removed by a variety of existing HTTP methods. A method that creates a new resource, such as PUT, COPY, and MKCOL, adds a binding. A method that deletes a resource, such as DELETE, removes a binding. A method that moves a resource (e.g., MOVE) both adds a binding (in the destination collection) and removes a binding (in the source collection). The BIND method introduced here provides a mechanism for adding a second binding to an existing resource. There is no difference between an initial binding added by PUT, COPY, or MKCOL and additional bindings added with BIND.",
      "ja": "バインディングを加え、既存のHTTPの様々な方法によって除去されます。このようPUT、COPY、およびMKCOLとして、新しいリソースを作成する方法は、バインディングを追加します。 DELETEなど、リソースを削除する方法は、結合を除去します。リソース（例えば、MOVE）の両方の移動方法は、（先のコレクションに）結合および結合（ソースコレクション）を除去する追加します。ここで導入されたBINDの方法は、第2の既存のリソースへの結合を追加するためのメカニズムを提供します。 PUT、COPY、またはMKCOLおよびBINDに追加された追加のバインディングによって追加バインディング初期の間に違いはありません。"
    },
    {
      "indent": 3,
      "text": "It would be very undesirable if one binding could be destroyed as a side effect of operating on the resource through a different binding. In particular, the removal of one binding to a resource (e.g., with a DELETE or a MOVE) MUST NOT disrupt another binding to that resource, e.g., by turning that binding into a dangling path segment. The server MUST NOT reclaim system resources after removing one binding, while other bindings to the resource remain. In other words, the server MUST maintain the integrity of a binding. It is permissible, however, for future method definitions (e.g., a DESTROY method) to have semantics that explicitly remove all bindings and/or immediately reclaim system resources.",
      "ja": "1の結合が異なる結合を通じてリソース上で動作の副作用として破壊することができれば、それは非常に望ましくないであろう。具体的には、（DELETEまたはMOVEと例えば、）リソースに結合する一方の除去は別のダングリング経路セグメントに結合することを回すことにより、例えば、そのリソースへの結合を破壊してはいけません。リソースへの他のバインディングが残っている間、サーバーは、結合1つを取り外した後、システムリソースを再利用してはなりません。つまり、サーバーは、結合の完全性を維持しなければなりません。これは、明示的にすべてのバインディングを削除し、および/または直後にシステムリソースを再利用意味を持つように、将来のメソッドの定義（例えば、destroyメソッド）のために、しかし、許容されます。"
    },
    {
      "indent": 6,
      "text": "Note: the collection model described herein is not compatible with systems in which resources inherit properties based solely on the access path, as the ability to create additional bindings will cause a single resource to appear as member of several different collections at the same time.",
      "ja": "注意：ここに記載さコレクション・モデルは、リソースは単一のリソースは、同時に複数の異なるコレクションのメンバーとして表示される場合があります追加のバインディングを作成する機能として、アクセスパスのみに基づいてプロパティを継承するシステムと互換性がありません。"
    },
    {
      "indent": 0,
      "text": "2.1. Bindings to Collections",
      "section_title": true,
      "ja": "2.1。コレクションへのバインディング"
    },
    {
      "indent": 3,
      "text": "Creating a new binding to a collection makes each resource associated with a binding in that collection accessible via a new URI, and thus creates new URI mappings to those resources but no new bindings.",
      "ja": "コレクションに新しいバインディングを作成すると、新しいURIを経由して、そのコレクションに結合アクセスに関連した各リソースになりますので、それらのリソースへの新しいURIのマッピングが、新しいバインディングを作成します。"
    },
    {
      "indent": 3,
      "text": "For example, suppose a new binding CollY is created for collection C1 in the figure below. It immediately becomes possible to access resource R1 using the URI /CollY/x.gif and to access resource R2 using the URI /CollY/y.jpg, but no new bindings for these child resources were created. This is because bindings are part of the state of a collection, and they associate a URI that is relative to that collection with its target resource. No change to the bindings in Collection C1 is needed to make its children accessible using /CollY/x.gif and /CollY/y.jpg.",
      "ja": "たとえば、新しい結合CollYは下図のコレクションC1のために作成されているとします。それはすぐにURI /CollY/x.gifを使用してリソースR1にアクセスし、URI /CollY/y.jpgを使用してリソースR2にアクセスすることが可能となるが、これらの子リソースのための新たなバインディングが作成されませんでした。バインディングは、コレクションの状態の一部であるので、これはある、と彼らはそのターゲット・リソースとそのコレクションに対する相対URIを関連付けます。コレクションC1でのバインディングへの変更は/CollY/x.gifと/CollY/y.jpgを使用して、その子供たちがアクセスできるようにする必要はありません。"
    },
    {
      "indent": 21,
      "text": "+-------------------------+\n| Root Collection         |\n|  bindings:              |\n|  CollX          CollY   |\n+-------------------------+\n    |            /\n    |           /\n    |          /\n+------------------+\n| Collection C1    |\n| bindings:        |\n| x.gif     y.jpg  |\n+------------------+\n    |          \\\n    |           \\\n    |            \\\n+-------------+   +-------------+\n| Resource R1 |   | Resource R2 |\n+-------------+   +-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.1.1. Bind Loops",
      "section_title": true,
      "ja": "2.1.1。バインドループ"
    },
    {
      "indent": 3,
      "text": "Bindings to collections can result in loops (\"cycles\"), which servers MUST detect when processing \"Depth: infinity\" requests. It is sometimes possible to complete an operation in spite of the presence of a loop. For instance, a PROPFIND can still succeed if the server uses the new status code 208 (Already Reported) defined in Section 7.1.",
      "ja": "リクエスト：コレクションへのバインディングは、「無限の深さ」を処理するときにサーバーが検出しなければならないループ（「サイクル」）をもたらすことができます。ループの存在にもかかわらず、操作を完了できる場合があります。サーバはセクション7.1で定義された新しいステータスコード208（すでに報告されている）を使用している場合たとえば、PROPFINDはまだ成功することができます。"
    },
    {
      "indent": 3,
      "text": "However, the 508 (Loop Detected) status code is defined in Section 7.2 for use in contexts where an operation is terminated because a loop was encountered.",
      "ja": "しかし、508（ループ検出）のステータスコードは、ループが発生したため、操作が終了した状況での使用については、セクション7.2で定義されています。"
    },
    {
      "indent": 3,
      "text": "Support for loops is OPTIONAL: servers MAY reject requests that would lead to the creation of a bind loop (see DAV:cycle-allowed precondition defined in Section 4).",
      "ja": "ループのサポートはオプションです：バインドループの創出につながる要求を拒否するかもしれサーバは（：セクション4で定義されたサイクル-許可の前提条件DAVを参照してください）。"
    },
    {
      "indent": 0,
      "text": "2.2. URI Mappings Created by a New Binding",
      "section_title": true,
      "ja": "2.2。新しいバインディングによって作成されたURIのマッピング"
    },
    {
      "indent": 3,
      "text": "Suppose a binding from \"Binding-Name\" to resource R is to be added to a collection, C. Then if C-MAP is the set of URIs that were mapped to C before the BIND request, then for each URI \"C-URI\" in C-MAP, the URI \"C-URI/Binding-Name\" is mapped to resource R following the BIND request.",
      "ja": "C-MAPは、BIND要求の前にCにマッピングされたURIの設定された場合C.は、各URI「C-URIために、そして、R資源に「バインディング名」から結合がコレクションに追加されると仮定します「C-MAPで、URI \"C-URI /結合名は\" BIND要求次のRリソースにマッピングされます。"
    },
    {
      "indent": 3,
      "text": "For example, if a binding from \"foo.html\" to R is added to a collection C, and if the following URIs are mapped to C:",
      "ja": "例えば、Rに「foo.htmlという」からバインディング収集Cに追加された場合、および以下のURIをCにマッピングされている場合："
    },
    {
      "indent": 3,
      "text": "http://www.example.com/A/1/ http://example.com/A/one/",
      "ja": "ｈっｔｐ：／／ｗっｗ。えぁｍｐぇ。こｍ／あ／１／ ｈっｔｐ：／／えぁｍｐぇ。こｍ／あ／おね／"
    },
    {
      "indent": 3,
      "text": "then the following new mappings to R are introduced:",
      "ja": "その後、Rへ次の新しいマッピングが導入されています。"
    },
    {
      "indent": 3,
      "text": "http://www.example.com/A/1/foo.html http://example.com/A/one/foo.html",
      "ja": "ｈっｔｐ：／／ｗっｗ。えぁｍｐぇ。こｍ／あ／１／ふぉお。ｈｔｍｌ ｈっｔｐ：／／えぁｍｐぇ。こｍ／あ／おね／ふぉお。ｈｔｍｌ"
    },
    {
      "indent": 3,
      "text": "Note that if R is a collection, additional URI mappings are created to the descendents of R. Also, note that if a binding is made in collection C to C itself (or to a parent of C), an infinite number of mappings are introduced.",
      "ja": "Rがコレクションである場合、追加のURIマッピングもR.の子孫に作成されることに注意し、結合がC自身に収集Cで行われた場合（またはCの親に）、マッピングの無限数が導入されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "For example, if a binding from \"myself\" to C is then added to C, the following infinite number of additional mappings to C are introduced:",
      "ja": "Cに「自分」の結合は、その後Cに追加された場合、例えば、Cに追加のマッピングの次の無限数が導入されます。"
    },
    {
      "indent": 3,
      "text": "http://www.example.com/A/1/myself http://www.example.com/A/1/myself/myself ...",
      "ja": "ｈっｔｐ：／／ｗっｗ。えぁｍｐぇ。こｍ／あ／１／ｍｙせｌｆ ｈっｔｐ：／／ｗっｗ。えぁｍｐぇ。こｍ／あ／１／ｍｙせｌｆ／ｍｙせｌｆ 。。。"
    },
    {
      "indent": 3,
      "text": "and the following infinite number of additional mappings to R are introduced:",
      "ja": "そしてRへの追加のマッピングの次無限数が導入されています。"
    },
    {
      "indent": 3,
      "text": "http://www.example.com/A/1/myself/foo.html http://www.example.com/A/1/myself/myself/foo.html ...",
      "ja": "ｈっｔｐ：／／ｗっｗ。えぁｍｐぇ。こｍ／あ／１／ｍｙせｌｆ／ふぉお。ｈｔｍｌ ｈっｔｐ：／／ｗっｗ。えぁｍｐぇ。こｍ／あ／１／ｍｙせｌｆ／ｍｙせｌｆ／ふぉお。ｈｔｍｌ 。。。"
    },
    {
      "indent": 0,
      "text": "2.3. COPY and Bindings",
      "section_title": true,
      "ja": "2.3。 COPYとバインド"
    },
    {
      "indent": 3,
      "text": "As defined in Section 9.8 of [RFC4918], COPY causes the resource identified by the Request-URI to be duplicated and makes the new resource accessible using the URI specified in the Destination header. Upon successful completion of a COPY, a new binding is created between the last path segment of the Destination header and the destination resource. The new binding is added to its parent collection, identified by the Destination header minus its final segment.",
      "ja": "[RFC4918]のセクション9.8で定義されているように、COPYは、Request-URIによって識別されたリソースが重複させると宛先ヘッダで指定されたURIを使用して、新しいリソースにアクセスできるようになります。コピーが正常に完了すると、新しいバインディングは、宛先ヘッダの最後のパスセグメントと宛先リソース間で作成されます。新しいバインディングは、宛先ヘッダマイナス最終的なセグメントによって識別親コレクションに追加されます。"
    },
    {
      "indent": 3,
      "text": "The following figure shows an example: suppose that a COPY is issued to URI-3 for resource R (which is also mapped to URI-1 and URI-2), with the Destination header set to URI-X. After successful completion of the COPY operation, resource R is duplicated to create resource R', and a new binding has been created that creates at least the URI mapping between URI-X and the new resource (although other URI mappings may also have been created).",
      "ja": "次の図は一例を示している：コピーがURI-Xに設定された宛先ヘッダと、URI-3リソースRのために（また、URI-1及びURI-2にマッピングされている）に発行されていると仮定する。 COPY動作が正常に完了した後に、リソースRは、リソースR」を作成するために複製され、新たな結合は、他のURIマッピングも作成されているかもしれないが（少なくともURI-Xと新しいリソースとの間のURIマッピングを作成し、その作成されています）。"
    },
    {
      "indent": 5,
      "text": "URI-1   URI-2    URI-3                           URI-X\n   |       |        |                              |\n   |       |        |   <---- URI Mappings ---->   |\n   |       |        |                              |\n+---------------------+                 +------------------------+\n|     Resource R      |                 |     Resource R'        |\n+---------------------+                 +------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "It might be thought that a COPY request with \"Depth: 0\" on a collection would duplicate its bindings, since bindings are part of the collection's state. This is not the case, however. The definition of Depth in [RFC4918] makes it clear that a \"Depth: 0\" request does not apply to a collection's members. Consequently, a COPY with \"Depth: 0\" does not duplicate the bindings contained by the collection.",
      "ja": "バインディングは、コレクションの状態の一部なので、コレクションに、そのバインディングを複製します：「0深さ」とのコピー要求をすることを考えている可能性があります。しかし、これはそうではありません。 「：0深さ」要求コレクションのメンバーには適用されません[RFC4918]で深さの定義は、それが明確であることになります。その結果、「深さ：0」とのCOPYは、コレクションに含まれるバインディングを複製しません。"
    },
    {
      "indent": 3,
      "text": "If a COPY request causes an existing resource to be updated, the bindings to that resource MUST be unaffected by the COPY request. Using the preceding example, suppose that a COPY request is issued to URI-X for resource R', with the Destination header set to URI-2. The content and dead properties of resource R would be updated to be a copy of those of resource R', but the mappings from URI-1, URI-2, and URI-3 to resource R remain unaffected. If, because of multiple bindings to a resource, more than one source resource updates a single destination resource, the order of the updates is server defined (see Section 2.3.2 for an example).",
      "ja": "COPY要求を更新する既存のリソースが発生した場合は、そのリソースへのバインディングがCOPY要求による影響を受けなければなりません。前述の例を使用して、COPY要求がURI-2に設定された宛先ヘッダと、リソースR」のURI-Xに発行されたとします。リソースRの内容とデッドプロパティは、リソースR」のそれらのコピーに更新されますが、リソースRへのURI-1、URI-2、およびURI-3からのマッピングは影響を受けません。 、なぜなら、リソースへの複数のバインディングの、複数のソースリソースが単一の宛先リソースを更新する場合、更新の順序が定義されたサーバ（例えば、セクション2.3.2を参照します）。"
    },
    {
      "indent": 3,
      "text": "If a COPY request would cause a new resource to be created as a copy of an existing resource, and that COPY request has already created a copy of that existing resource, the COPY request instead creates another binding to the previous copy, instead of creating a new resource (see Section 2.3.3 for an example).",
      "ja": "COPY要求は既存のリソースのコピーとして作成される新しいリソースを引き起こす、そのCOPY要求が既に既存のリソースのコピーを作成している場合、COPY要求ではなく、代わりに作成するのではなく、以前のコピーに別の結合を作成します新しいリソース（例えば2.3.3項を参照してください）。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Example: COPY with \"Depth: infinity\" in Presence of Bind Loops",
      "section_title": true,
      "ja": "2.3.1。バインドループの存在下での例：「無限の深さ」とCOPY"
    },
    {
      "indent": 3,
      "text": "As an example of how COPY with \"Depth: infinity\" would work in the presence of bindings, consider the following collection:",
      "ja": "COPY方法の例として、「深さ：無限大は」バインディングの存在下で働くだろう、次のコレクションを考慮してください。"
    },
    {
      "indent": 17,
      "text": "+------------------+\n| Root Collection  |\n|  bindings:       |\n|  CollX           |\n+------------------+\n    |\n    |\n+-------------------------------+\n| Collection C1                 |<-------+\n| bindings:                     |        |\n| x.gif      CollY              |        |\n+-------------------------------+        |\n    |            \\        (creates loop) |\n    |             \\                      |\n+-------------+   +------------------+   |\n| Resource R1 |   | Collection C2    |   |\n+-------------+   | bindings:        |   |\n                  | y.gif     CollZ  |   |\n                  +------------------+   |\n                      |         |        |\n                      |         +--------+\n                      |\n                  +-------------+\n                  | Resource R2 |\n                  +-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If a COPY request with \"Depth: infinity\" is submitted to /CollX, with a destination of /CollA, the outcome of the copy operation is that a copy of the tree is replicated to the target /CollA:",
      "ja": "「深さ：無限大」とCOPY要求をした場合/ CollXに提出され、コラ/の先に、コピー操作の結果は、ツリーのコピーがターゲット/コラに複製されていることです。"
    },
    {
      "indent": 16,
      "text": "+------------------+\n| Root Collection  |\n|  bindings:       |\n|  CollX     CollA |\n+------------------+\n   |           |\n   |           +---------------------------+\n   |                                       |\n+-------------------+                      |\n| Collection C1     |<------------------+  |\n| bindings:         |                   |  |\n| x.gif      CollY  |                   |  |\n+-------------------+                   |  |\n   |            \\        (creates loop) |  |\n   |             \\                      |  |\n+-------------+   +-----------------+   |  |\n| Resource R1 |   | Collection C2   |   |  |\n+-------------+   | bindings:       |   |  |\n                  | y.gif     CollZ |   |  |\n                  +-----------------+   |  |\n                      |         |       |  |\n                      |         +-------+  |\n                      |                    |\n                  +-------------+          |\n                  | Resource R2 |          |\n                  +-------------+          |\n                                           |\n           +-------------------------------+\n           |\n+-------------------+\n| Collection C3     |<------------------+\n| bindings:         |                   |\n| x.gif      CollY  |                   |\n+-------------------+                   |\n   |            \\        (creates loop) |\n   |             \\                      |\n+-------------+   +-----------------+   |\n| Resource R3 |   | Collection C4   |   |\n+-------------+   | bindings:       |   |\n                  | y.gif     CollZ |   |\n                  +-----------------+   |\n                      |         |       |\n                      |         +-------+\n                      |\n                  +-------------+\n                  | Resource R4 |\n                  +-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that the same would apply for more complex loops.",
      "ja": "同じことが、より複雑なループに適用されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Example: COPY Updating Multiple Bindings",
      "section_title": true,
      "ja": "2.3.2。例：COPYは、複数のバインディングを更新します"
    },
    {
      "indent": 3,
      "text": "Given the following collection hierarchy:",
      "ja": "次のコレクションの階層を考えます："
    },
    {
      "indent": 12,
      "text": "                    +------------------+\n                    | Root Collection  |\n                    |  bindings:       |\n                    |  CollX     CollY |\n                    +------------------+\n                       /              \\\n                      /                \\\n                     /                  \\\n  +--------------------------+   +-----------------+\n  |      Collection C1       |   | Collection C2   |\n  |      bindings:           |   | bindings:       |\n  |     x.gif     y.gif      |   | x.gif     y.gif |\n  +--------------------------+   +-----------------+\n          |         |                |         |\n          |         |                |         |\n+-------------+  +-------------+   +-------------+\n| Resource R1 |  | Resource R2 |   | Resource R3 |\n+-------------+  +-------------+   +-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A COPY of /CollX with \"Depth: infinity\" to /CollY will not result in a changed hierarchy, and Resource R3 will be updated with the content of either Resource R1 or Resource R2.",
      "ja": "/ CollXのCOPY：/ CollYに「深さ無限大は」変更された階層にはなりませんし、リソースR3は、リソースR1またはリソースR2のいずれかの内容で更新されます。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Example: COPY with \"Depth: infinity\" with Multiple Bindings to a Leaf Resource",
      "ja": "2.3.3。葉のリソースへの複数のバインディングを持つ例：「無限の深さ」とCOPY"
    },
    {
      "indent": 3,
      "text": "Given the following collection hierarchy:",
      "ja": "次のコレクションの階層を考えます："
    },
    {
      "indent": 28,
      "text": "+------------------+\n| Root Collection  |\n|  bindings:       |\n|  CollX           |\n+------------------+\n   |\n   |\n   |\n+----------------+\n| Collection C1  |\n| bindings:      |\n| x.gif    y.gif |\n+----------------+\n   |         |\n   |         |\n +-------------+\n | Resource R1 |\n +-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A COPY of /CollX with \"Depth: infinity\" to /CollY results in the following collection hierarchy:",
      "ja": "以下のコレクション階層内/ CollY結果へ：「無限の深さ」と/ CollXのCOPY："
    },
    {
      "indent": 18,
      "text": "+------------------+\n| Root Collection  |\n|  bindings:       |\n|  CollX     CollY |\n+------------------+\n   |              \\\n   |               \\\n   |                \\\n+----------------+  +-----------------+\n| Collection C1  |  | Collection C2   |\n| bindings:      |  | bindings:       |\n| x.gif    y.gif |  | x.gif     y.gif |\n+----------------+  +-----------------+\n   |         |          |         |\n   |         |          |         |\n +-------------+      +-------------+\n | Resource R1 |      | Resource R2 |\n +-------------+      +-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.4. DELETE and Bindings",
      "section_title": true,
      "ja": "2.4。 DELETEとバインド"
    },
    {
      "indent": 3,
      "text": "When there are multiple bindings to a resource, a DELETE applied to that resource MUST NOT remove any bindings to that resource other than the one identified by the Request-URI. For example, suppose the collection identified by the URI \"/a\" has a binding named \"x\" to a resource R, and another collection identified by \"/b\" has a binding named \"y\" to the same resource R. Then, a DELETE applied to \"/a/x\" removes the binding named \"x\" from \"/a\" but MUST NOT remove the binding named \"y\" from \"/b\" (i.e., after the DELETE, \"/y/b\" continues to identify the resource R).",
      "ja": "リソースに複数のバインディングが存在する場合、そのリソースに適用されるDELETEは、Request-URIによって識別されるもの以外のそのリソースに任意のバインディングを削除してはいけません。例えば、そして、URIによって識別されるコレクションは、「/」リソースRへの結合という名前の「X」を有し、「/ B」で識別別のコレクションが同じリソースRに結合するという名前の「Y」を有すると仮定\"/ A / X\" ではなく \"/ B\" からの結合という名前の \"Y\"（つまり、DELETEの後に、 \"/ Y / B\" を削除してはならない \"/\" からの結合という名前の \"x\" を削除するために適用されるDELETEリソースR）を識別し続けます。"
    },
    {
      "indent": 3,
      "text": "When DELETE is applied to a collection, it MUST NOT modify the membership of any other collection that is not itself a member of the collection being deleted. For example, if both \"/a/.../x\" and \"/b/.../y\" identify the same collection, C, then applying DELETE to \"/a\" must not delete an internal member from C or from any other collection that is a member of C, because that would modify the membership of \"/b\".",
      "ja": "DELETEは、コレクションに適用されると、それは削除されるコレクションのメンバーそのものではない、他のコレクションのメンバシップを変更してはいけません。例えば、「/a/.../x」および「/b/.../y」同じコレクションを特定両方場合、適用Cは、「/」Cから内部メンバーを削除してはならないためにDELETEまたはそれは、「/ B」のメンバーシップを変更になるので、Cのメンバーである他のコレクションから。"
    },
    {
      "indent": 3,
      "text": "If a collection supports the UNBIND method (see Section 5), a DELETE of an internal member of a collection MAY be implemented as an UNBIND request. In this case, applying DELETE to a Request-URI has the effect of removing the binding identified by the final segment of the Request-URI from the collection identified by the Request-URI minus its final segment. Although [RFC4918] allows a DELETE to be a non-atomic operation, when the DELETE operation is implemented as an UNBIND, the operation is atomic. In particular, a DELETE on a hierarchy of resources is simply the removal of a binding to the collection identified by the Request-URI.",
      "ja": "コレクションはUNBINDメソッドをサポートしている場合（第5節を参照）、コレクションの内部メンバーのDELETEはUNBIND要求として実装することができます。この場合、DELETEに適用するのRequest-URIがRequest-URIマイナス最終的なセグメントによって識別コレクションからのRequest-URIの最後のセグメントによって同定された結合を除去する効果を有します。 [RFC4918]はDELETEは削除操作がUNBINDとして実装されている非アトミック動作にすることができるが、操作がアトミックです。具体的には、リソースの階層上のDELETEは単に、Request-URIによって識別されるコレクションへの結合を除去することです。"
    },
    {
      "indent": 0,
      "text": "2.5. MOVE and Bindings",
      "section_title": true,
      "ja": "2.5。 MOVEとバインド"
    },
    {
      "indent": 3,
      "text": "When MOVE is applied to a resource, the other bindings to that resource MUST be unaffected; and if the resource being moved is a collection, the bindings to any members of that collection MUST be unaffected. Also, if MOVE is used with Overwrite:T to delete an existing resource, the constraints specified for DELETE apply.",
      "ja": "MOVEがリソースに適用されるとき、そのリソースへの他の結合は影響を受けなければなりません。移動中のリソースがコレクションである場合と、そのコレクションのすべてのメンバーへのバインディングは影響を受けなければなりません。 MOVEを上書きして使用されている場合も、：Tは既存のリソースを削除するには、DELETEのために指定された制約が適用されます。"
    },
    {
      "indent": 3,
      "text": "If the destination collection of a MOVE request supports the REBIND method (see Section 6), a MOVE of a resource into that collection MAY be implemented as a REBIND request. Although [RFC4918] allows a MOVE to be a non-atomic operation, when the MOVE operation is implemented as a REBIND, the operation is atomic. In particular, applying a MOVE to a Request-URI and a Destination URI has the effect of removing a binding to a resource (at the Request-URI) and creating a new binding to that resource (at the Destination URI). Even when the Request-URI identifies a collection, the MOVE operation involves only removing one binding to that collection and adding another.",
      "ja": "MOVE要求の宛先コレクション（セクション6を参照）REBIND方法をサポートしている場合は、そのコレクション内のリソースのMOVEはREBIND要求として実現されてもよいです。 [RFC4918]はMOVE非アトミック操作することを可能にするがMOVE動作がREBINDとして実装されている場合、操作はアトミックです。具体的には、リクエストURIと宛先への移行を適用するURIは、（要求URIで）リソースに結合し、（先URIで）そのリソースに対する新しいバインディングの作成を除去する効果を有します。リクエストURIは、コレクションを識別した場合であっても、MOVE動作は、そのコレクションに結合するものを除去し、別のものを追加することを含みます。"
    },
    {
      "indent": 0,
      "text": "2.5.1. Example: Simple MOVE",
      "section_title": true,
      "ja": "2.5.1。例：単純なMOVE"
    },
    {
      "indent": 3,
      "text": "As an example, suppose that a MOVE is issued to URI-3 for resource R below (which is also mapped to URI-1 and URI-2), with the Destination header set to URI-X. After successful completion of the MOVE operation, a new binding has been created that creates the URI mapping between URI-X and resource R. The binding corresponding to the final segment of URI-3 has been removed, which also causes the URI mapping between URI-3 and R to be removed. If resource R were a collection, old URI-3-based mappings to members of R would have been removed, and new URI-X-based mappings to members of R would have been created.",
      "ja": "一例として、MOVEは、URI-Xに設定された宛先ヘッダと、（また、URI-1及びURI-2にマッピングされている）以下リソースRのURI-3に対して発行されると仮定する。 MOVE動作が正常に完了した後に、新しいバインディングはURI-3の最終セグメントに対応することもURIとの間のURIマッピングを引き起こす、除去されたバインディングURI-XおよびリソースR.ザ間のURIマッピングを作成し、その作成されています-3およびRは除去されます。リソースRは、収集した場合には、Rのメンバーに古いURI-3ベースのマッピングが削除されていたであろう、とRのメンバーに新しいURI-Xベースのマッピングが作成されていたであろう。"
    },
    {
      "indent": 3,
      "text": ">> Before Request:",
      "ja": ">>要求の前に："
    },
    {
      "indent": 15,
      "text": " URI-1   URI-2    URI-3\n   |       |        |\n   |       |        |      <---- URI Mappings\n   |       |        |\n+---------------------+\n|     Resource R      |\n+---------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": ">> After Request:",
      "ja": ">>リクエストの後に："
    },
    {
      "indent": 15,
      "text": " URI-1   URI-2    URI-X\n   |       |        |\n   |       |        |      <---- URI Mappings\n   |       |        |\n+---------------------+\n|     Resource R      |\n+---------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.5.2. Example: MOVE Request Causing a Bind Loop",
      "section_title": true,
      "ja": "2.5.2。例：バインドループを引き起こして移動要求"
    },
    {
      "indent": 3,
      "text": "Note that in the presence of collection bindings, a MOVE request can cause the creation of a bind loop.",
      "ja": "コレクションバインディングの存在下で、MOVE要求がバインドループの作成を引き起こす可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Consider the top-level collections C1 and C2 with URIs \"/CollW/\" and \"/CollX/\". C1 also contains an additional binding named \"CollY\" to C2:",
      "ja": "「/ CollW /」および「/ CollX /」URIを持つトップレベルのコレクションC1及びC2を考えます。 C1もC2に「CollY」という名前の追加の結合が含まれています。"
    },
    {
      "indent": 28,
      "text": "         +------------------+\n         | Root Collection  |\n         |  bindings:       |\n         |  CollW    CollX  |\n         +------------------+\n             |          |\n             |          |\n+------------------+    |\n| Collection C1    |    |\n|  bindings:       |    |\n|           CollY  |    |\n+------------------+    |\n             |          |\n             |          |\n         +------------------+\n         | Collection C2    |\n         |                  |\n         |                  |\n         +------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In this case, the MOVE request below would cause a bind loop:",
      "ja": "この場合、以下のMOVE要求がバインドループが発生します："
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "MOVE /CollW HTTP/1.1 Host: example.com Destination: /CollX/CollZ",
      "ja": "MOVE / CollW HTTP / 1.1ホスト：example.com先：/ CollX / CollZ"
    },
    {
      "indent": 3,
      "text": "If the request succeeded, the resulting state would be:",
      "ja": "リクエストが成功した場合、結果の状態は次のようになります。"
    },
    {
      "indent": 21,
      "text": "                +------------------+\n                | Root Collection  |\n                |  bindings:       |\n                |           CollX  |\n                +------------------+\n                               |\n                               |\n       +------------------+    |\n       | Collection C1    |    |\n+----> |  bindings:       |    |\n|      |           CollY  |    |\n|      +------------------+    |\n|                   |          |\n|                   |          |\n|               +------------------+\n|               | Collection C2    |\n|               |  bindings:       |\n|               | CollZ            |\n|               +------------------+\n|                   |\n|                   |\n+-------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.6. PROPFIND and Bindings",
      "section_title": true,
      "ja": "2.6。 PROPFINDとバインド"
    },
    {
      "indent": 3,
      "text": "Consistent with [RFC4918], the value of a dead property MUST be independent of the number of bindings to its host resource or of the path submitted to PROPFIND. On the other hand, the behavior for each live property depends on its individual definition (for example, see [RFC3744], Section 5, Paragraph 2 for a case where the value is independent of its path and bindings, and [RFC4918], Section 8.8 for a discussion about the live properties DAV:getetag and DAV: getlastmodified, which may behave differently).",
      "ja": "[RFC4918]と一致して、死者のプロパティの値は、そのホストのリソースまたはPROPFINDに提出パスのバインディングの数の独立していなければなりません。一方、各ライブプロパティの動作は、（例えば、[RFC3744]、セクション5、値はそのパスとバインディングから独立している場合のパラグラフ2、及び[RFC4918]、セクションを参照その個々の定義に依存しますライブプロパティについての議論のための8.8は、DAV：getetagとDAV：getlastmodifiedを、異なる挙動を示す可能性があります）。"
    },
    {
      "indent": 0,
      "text": "2.7. Determining Whether Two Bindings Are to the Same Resource",
      "section_title": true,
      "ja": "2.7。 2つのバインディングが同じリソースにしているかどうかを決定"
    },
    {
      "indent": 3,
      "text": "It is useful to have some way of determining whether two bindings are to the same resource. Two resources might have identical contents and properties, but not be the same resource (e.g., an update to one resource does not affect the other resource).",
      "ja": "2つのバインディングが同じリソースにあるかどうかを決定するいくつかの方法があると便利です。 2つのリソースは、同一の内容や性質を持っていますが、（例えば、一つのリソースへの更新が他のリソースに影響を与えません）同じリソースではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "The REQUIRED DAV:resource-id property defined in Section 3.1 is a resource identifier, which MUST be unique across all resources for all time. If the values of DAV:resource-id returned by PROPFIND requests through two bindings are identical character by character, the client can be assured that the two bindings are to the same resource.",
      "ja": "REQUIRED DAV：3.1節で定義されたリソース-idプロパティは、すべての時間のためにすべてのリソース間で一意でなければならないリソース識別子、です。 DAVの値場合：2つのバインディングを通じてPROPFINDリクエストによって返されたリソース-idは文字によって同一の文字が、クライアントは2つのバインディングが同じリソースにあることを保証することができます。"
    },
    {
      "indent": 3,
      "text": "The DAV:resource-id property is created, and its value assigned, when the resource is created. The value of DAV:resource-id MUST NOT be changed. Even after the resource is no longer accessible through any URI, that value MUST NOT be reassigned to another resource's DAV: resource-id property.",
      "ja": "DAV：リソースが作成されたときに、リソース-idプロパティは、作成され、その値が割り当てられます。 DAVの値：リソース-IDを変更してはいけません。リソースは任意のURIを通じてアクセスできなくなった後も、その値は、別のリソースのDAVに再割り当てないしてはならない：リソース-idプロパティ。"
    },
    {
      "indent": 3,
      "text": "Any method that creates a new resource MUST assign a new, unique value to its DAV:resource-id property. For example, a PUT applied to a null resource, COPY (when not overwriting an existing target) and CHECKIN (see [RFC3253], Section 4.4) must assign a new, unique value to the DAV:resource-id property of the new resource they create.",
      "ja": "リソース-idプロパティ：新しいリソースを作成し、任意の方法は、そのDAVに新しい、ユニークな値を割り当てる必要があります。例えば、ヌルリソース、COPY（既存のターゲットを上書きしない場合）とCHECKINに適用PUTは、DAVに新しい、一意の値を割り当てる必要があります（[RFC3253]、セクション4.4を参照）：新しいリソースのリソースIDプロパティを彼らが作成します。"
    },
    {
      "indent": 3,
      "text": "On the other hand, any method that affects an existing resource must not change the value of its DAV:resource-id property. Specifically, a PUT or a COPY that updates an existing resource must not change the value of its DAV:resource-id property. A REBIND, since it does not create a new resource, but only changes the location of an existing resource, must not change the value of the DAV:resource-id property.",
      "ja": "リソース-idプロパティ：一方、既存のリソースに影響を与える方法は、そのDAVの値を変更しないでください。リソース-idプロパティ：具体的には、既存のリソースを更新PUTまたはCOPYは、そのDAVの値を変更しないでください。リソース-idプロパティ：それは新しいリソースを作成しますが、唯一の既存のリソースの場所を変更していないので、REBINDは、DAVの値を変更しないでください。"
    },
    {
      "indent": 0,
      "text": "2.8. Discovering the Bindings to a Resource",
      "section_title": true,
      "ja": "2.8。リソースへのバインディングを発見"
    },
    {
      "indent": 3,
      "text": "An OPTIONAL DAV:parent-set property on a resource provides a list of the bindings that associate a collection and a URI segment with that resource. If the DAV:parent-set property exists on a given resource, it MUST contain a complete list of all bindings to that resource that the client is authorized to see. When deciding whether to support the DAV:parent-set property, server implementers / administrators should balance the benefits it provides against the cost of maintaining the property and the security risks enumerated in Sections 12.4 and 12.5.",
      "ja": "オプションDAV：親設定プロパティリソースには、そのリソースを収集し、URIセグメントを関連付けるバインディングのリストを提供します。 DAV場合：親設定プロパティは、与えられたリソース上に存在する、それはクライアントが参照を許可されているリソースへのすべてのバインディングの完全なリストを含まなければなりません。 DAVをサポートするかどうかを決定するときは：親設定プロパティを、サーバーの実装者/管理者は、それが財産を維持するためのコストとセクション12.4と12.5で列挙セキュリティリスクに対して提供ベネフィットのバランスをとる必要があります。"
    },
    {
      "indent": 0,
      "text": "3. Properties",
      "section_title": true,
      "ja": "3. [プロパティ"
    },
    {
      "indent": 3,
      "text": "The bind feature introduces the properties defined below.",
      "ja": "バインド機能は、次に定義する特性を紹介します。"
    },
    {
      "indent": 3,
      "text": "A DAV:allprop PROPFIND request SHOULD NOT return any of the properties defined by this document. This allows a binding server to perform efficiently when a naive client, which does not understand the cost of asking a server to compute all possible live properties, issues a DAV:allprop PROPFIND request.",
      "ja": "DAV：allprop PROPFIND要求は、この文書で定義されたプロパティのいずれかを返すべきではありません。 allprop PROPFIND要求：これは、すべての可能なライブのプロパティを計算するために、サーバーを尋ねるのコストを理解していない素朴なクライアントは、DAVを発行したときに結合サーバーが効率的に実行することができます。"
    },
    {
      "indent": 0,
      "text": "3.1. DAV:resource-id Property",
      "section_title": true,
      "ja": "3.1。 DAV：リソース-idプロパティ"
    },
    {
      "indent": 3,
      "text": "The DAV:resource-id property is a REQUIRED property that enables clients to determine whether two bindings are to the same resource. The value of DAV:resource-id is a URI, and may use any registered URI scheme that guarantees the uniqueness of the value across all resources for all time (e.g., the urn:uuid: URN namespace defined in [RFC4122] or the opaquelocktoken: URI scheme defined in [RFC4918]).",
      "ja": "DAV：リソースIDプロパティは、2つのバインディングが同じリソースにあるかどうかを決定するためにクライアントを有効に必要なプロパティです。 DAVの値：リソースIDはURIであり、すべての時間（例えば、骨壷のためにすべてのリソースを横切る値の一意性を保証する任意の登録URIスキームを使用することができる：UUID：URN名前空間は[RFC4122]またはopaquelocktokenで定義されて[RFC4918]で定義されたURIスキーム）。"
    },
    {
      "indent": 3,
      "text": "<!ELEMENT resource-id (href)>",
      "ja": "<！ELEMENTリソース-ID（HREF）>"
    },
    {
      "indent": 0,
      "text": "3.2. DAV:parent-set Property",
      "section_title": true,
      "ja": "3.2。 DAV：親設定プロパティ"
    },
    {
      "indent": 3,
      "text": "The DAV:parent-set property is an OPTIONAL property that enables clients to discover what collections contain a binding to this resource (i.e., what collections have that resource as an internal member). It contains an href/segment pair for each collection that has a binding to the resource. The href identifies the collection, and the segment identifies the binding name of that resource in that collection.",
      "ja": "DAV：親設定プロパティは、このリソースへの結合のコレクションが含まれているものを発見するためにクライアントを可能オプションのプロパティです（すなわち、内部のメンバーとして、そのリソース持っているもののコレクション）。これは、リソースへの結合を有し、各コレクションのHREF /セグメント対を含んでいます。 HREFは、コレクションを識別し、セグメントがそのコレクション内のそのリソースのバインディング名を識別する。"
    },
    {
      "indent": 3,
      "text": "A given collection MUST appear only once in the DAV:parent-set for any given binding, even if there are multiple URI mappings to that collection.",
      "ja": "指定されたコレクションは、DAVに一度だけ現れなければならない：そのコレクションに複数のURIのマッピングがある場合でも、バインディング与えられたいずれかの親がセット。"
    },
    {
      "indent": 3,
      "text": "<!ELEMENT parent-set (parent)*> <!ELEMENT parent (href, segment)> <!ELEMENT segment (#PCDATA)> <!-- PCDATA value: segment, as defined in Section 3.3 of [RFC3986] -->",
      "ja": "<！ELEMENT親セット（親）*> <ELEMENT親（HREF、セグメント）> <！ELEMENTセグメント（#PCDATA）> <！ -  PCDATA値：セグメント、セクション3.3で定義されるように[RFC3986]  - >"
    },
    {
      "indent": 0,
      "text": "3.2.1. Example for DAV:parent-set Property",
      "section_title": true,
      "ja": "3.2.1。 DAVの例：親設定プロパティ"
    },
    {
      "indent": 3,
      "text": "For example, if collection C1 is mapped to both /CollX and /CollY, and C1 contains a binding named \"x.gif\" to a resource R1, then either [/CollX, x.gif] or [/CollY, x.gif] can appear in the DAV:parent-set of R1, but not both. But if C1 also had a binding named \"y.gif\" to R1, then there would be two entries for C1 in the DAV:parent-set of R1 (i.e., both [/CollX, x.gif] and [/CollX, y.gif] or, alternatively, both [/CollY, x.gif] and [/CollY, y.gif]).",
      "ja": "例えば、収集C1は/ CollX及び/ CollY両方にマッピングされ、C1は、リソースR1、その後のいずれか[/ CollX、x.gif]または[/ CollY、x.gifに結合名前 \"x.gif\" が含まれる場合両方のR1の親セットではなく：] DAVに表示することができます。 R1（すなわち、両方の[/ CollX、x.gif]と[/ CollX、親のセット：C1はまた、R1との結合という名前の「y.gif」を持っていた場合でも、その後、DAVでC1の2つのエントリが存在することになりますy.gif]、あるいは、両方の[/ CollY、x.gif]および[/ CollY、y.gif]）。"
    },
    {
      "indent": 24,
      "text": "+-------------------------+\n| Root Collection         |\n|  bindings:              |\n|  CollX          CollY   |\n+-------------------------+\n    |            /\n    |           /\n    |          /\n+-----------------+\n| Collection C1   |\n| bindings:       |\n| x.gif    y.gif  |\n+-----------------+\n     |      |\n     |      |\n     |      |\n +-------------+\n | Resource R1 |\n +-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In this case, one possible value for the DAV:parent-set property on \"/CollX/x.gif\" would be:",
      "ja": "この場合は、DAVのための1つの可能な値：「/CollX/x.gif」の親設定プロパティは、次のようになります。"
    },
    {
      "indent": 5,
      "text": "<parent-set xmlns=\"DAV:\"> <parent> <href>/CollX</href> <segment>x.gif</segment> </parent> <parent> <href>/CollX</href> <segment>y.gif</segment> </parent> </parent-set>",
      "ja": "<親セットのxmlns = \"DAV：\"> <親> <HREF> / CollX </ HREF> <セグメント> x.gif </セグメント> </親> <親> <HREF> / CollX </ HREF> <セグメント> y.gif </セグメント> </親> </親セット>"
    },
    {
      "indent": 0,
      "text": "4. BIND Method",
      "section_title": true,
      "ja": "4. BIND方法"
    },
    {
      "indent": 3,
      "text": "The BIND method modifies the collection identified by the Request-URI, by adding a new binding from the segment specified in the BIND body to the resource identified in the BIND body.",
      "ja": "BIND法は、BIND本体に識別されたリソースに結合体で指定されたセグメントから新しいバインディングを追加することによって、リクエストURIによって識別されるコレクションを修正します。"
    },
    {
      "indent": 3,
      "text": "If a server cannot guarantee the integrity of the binding, the BIND request MUST fail. Note that it is especially difficult to maintain the integrity of cross-server bindings. Unless the server where the resource resides knows about all bindings on all servers to that resource, it may unwittingly destroy the resource or make it inaccessible without notifying another server that manages a binding to the resource. For example, if server A permits the creation of a binding to a resource on server B, server A must notify server B about its binding and must have an agreement with B that B will not destroy the resource while A's binding exists. Otherwise, server B may receive a DELETE request that it thinks removes the last binding to the resource and destroy the resource while A's binding still exists. The precondition DAV:cross-server-binding is defined below for cases where servers fail cross-server BIND requests because they cannot guarantee the integrity of cross-server bindings.",
      "ja": "サーバーは、結合の完全性を保証することはできません場合は、BIND要求が失敗しなければなりません。クロスサーババインディングの整合性を維持することが特に困難であることに注意してください。リソースが存在するサーバーがそのリソースへのすべてのサーバー上に関するすべてのバインディングを知っている場合を除き、それは無意識のうちに資源を破壊したり、リソースへの結合を管理し、別のサーバーに通知することなく、それはアクセスできないことがあります。サーバーAがサーバーB上のリソースへの結合の作成を許可する場合、例えば、サーバAは、その結合およびAの結合が存在している間Bがリソースを破壊しないであろうBとの契約を持っている必要がありますについては、サーバBに通知しなければなりません。そうでない場合は、サーバBは、それがリソースへの最後のバインディングを削除し、Aの結合がまだ存在している間、リソースを破壊すると考えDELETE要求を受信することができます。前提条件のDAV：クロスサーバ結合は、それらがクロスサーババインディングの整合性を保証できませんので、サーバがクロスサーバBIND要求を失敗する例については、以下に定義されます。"
    },
    {
      "indent": 3,
      "text": "By default, if there already is a binding for the specified segment in the collection, the new binding replaces the existing binding. This default binding replacement behavior can be overridden using the Overwrite header defined in Section 10.6 of [RFC4918].",
      "ja": "すでに存在している場合、デフォルトでは、コレクション内の指定されたセグメントのバインディング、新しいバインディングは、既存の結合に置き換えられます。このデフォルトバインディング交換挙動は[RFC4918]のセクション10.6で定義された上書きヘッダを使用してオーバーライドすることができます。"
    },
    {
      "indent": 3,
      "text": "If a BIND request fails, the server state preceding the request MUST be restored. This method is unsafe and idempotent (see [RFC2616], Section 9.1).",
      "ja": "BIND要求が失敗した場合は、リクエストの前にサーバの状態を復元する必要があります。この方法は、（[RFC2616]、セクション9.1を参照）危険と冪等です。"
    },
    {
      "indent": 3,
      "text": "Marshalling:",
      "ja": "マーシャリング："
    },
    {
      "indent": 6,
      "text": "The request MAY include an Overwrite header.",
      "ja": "要求が上書きヘッダーを含むかもしれません。"
    },
    {
      "indent": 6,
      "text": "The request body MUST be a DAV:bind XML element.",
      "ja": "バインドXML要素：リクエストボディは、DAVでなければなりません。"
    },
    {
      "indent": 6,
      "text": "<!ELEMENT bind (segment, href)>",
      "ja": "<！ELEMENTバインド（セグメント、HREF）>"
    },
    {
      "indent": 6,
      "text": "If the request succeeds, the server MUST return 201 (Created) when a new binding was created and 200 (OK) or 204 (No Content) when an existing binding was replaced.",
      "ja": "リクエストが成功すると、サーバーは、既存のバインディングが交換された新しいバインディングが作成された（作成者）201および200（OK）または204（コンテンツなし）を返さなければなりません。"
    },
    {
      "indent": 6,
      "text": "If a response body for a successful request is included, it MUST be a DAV:bind-response XML element. Note that this document does not define any elements for the BIND response body, but the DAV: bind-response element is defined to ensure interoperability between future extensions that do define elements for the BIND response body.",
      "ja": "成功した要求に対するレスポンスボディが含まれている場合は、DAVでなければならない：バインド応答XML要素。この文書はBINDのレスポンスボディのための任意の要素を定義していないことに注意してください、しかし、DAV：バインド応答エレメントは、BINDのレスポンスボディのための要素を定義行い、将来の拡張の間の相互運用性を確保するために定義されています。"
    },
    {
      "indent": 6,
      "text": "<!ELEMENT bind-response ANY>",
      "ja": "<！ELEMENTバインド応答ANY>"
    },
    {
      "indent": 3,
      "text": "Preconditions:",
      "ja": "前提条件："
    },
    {
      "indent": 6,
      "text": "(DAV:bind-into-collection): The Request-URI MUST identify a collection.",
      "ja": "（DAV：バインドに-コレクション）：Request-URIがコレクションを特定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:bind-source-exists): The DAV:href element MUST identify a resource.",
      "ja": "（DAV：バインドソースが-存在）：DAV：hrefの要素は、リソースを識別しなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:binding-allowed): The resource identified by the DAV:href supports multiple bindings to it.",
      "ja": "（DAV：-許可バインディング）：DAVで識別されるリソース：HREFがそれに複数のバインディングをサポートしています。"
    },
    {
      "indent": 6,
      "text": "(DAV:cross-server-binding): If the resource identified by the DAV: href element in the request body is on another server from the collection identified by the Request-URI, the server MUST support cross-server bindings (servers that do not support cross-server bindings can use this condition code to signal the client exactly why the request failed).",
      "ja": "（DAV：クロスサーバ結合）：DAVで識別されるリソース場合：リクエストボディのhref要素が要求URIで識別されるコレクションから別のサーバー上にある、サーバはクロスサーバのバインディング（実行するサーバをサポートしなければなりませんないサポートクロスサーバのバインディングは、要求が失敗した理由）正確にクライアントを知らせるために、この条件コードを使用することができます。"
    },
    {
      "indent": 6,
      "text": "(DAV:name-allowed): The name specified by the DAV:segment is available for use as a new binding name.",
      "ja": "（DAV：名可）：DAVによって指定された名前：セグメントは新しいバインディング名として使用可能です。"
    },
    {
      "indent": 6,
      "text": "(DAV:can-overwrite): If the collection already contains a binding with the specified path segment, and if an Overwrite header is included, the value of the Overwrite header MUST be \"T\".",
      "ja": "（DAV：CAN-上書き）：コレクションは、すでに指定されたパスのセグメントとの結合を含み、上書きヘッダが含まれている場合、上書きヘッダの値が「T」でなければならない場合。"
    },
    {
      "indent": 6,
      "text": "(DAV:cycle-allowed): If the DAV:href element identifies a collection, and if the Request-URI identifies a collection that is a member of that collection, the server MUST support cycles in the URI namespace (servers that do not support cycles can use this condition code to signal the client exactly why the request failed).",
      "ja": "（DAV：サイクル-許可）：hrefの要素のコレクションを識別し、要求URIは、そのコレクションのメンバーであるコレクションを識別した場合、サーバがサポートしていないURI名前空間（サーバ内のサイクルをサポートしなければならない：DAVの場合サイクル）は、要求が失敗した理由を正確にクライアントを知らせるために、この条件コードを使用することができます。"
    },
    {
      "indent": 6,
      "text": "(DAV:locked-update-allowed): If the collection identified by the Request-URI is write-locked, then the appropriate token MUST be specified in an If request header.",
      "ja": "（DAV：ロック更新可）：のRequest-URIによって識別されるコレクションは書き込みロックされている場合、適切なトークンがあれば要求ヘッダーで指定されなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:locked-overwrite-allowed): If the collection already contains a binding with the specified path segment, and if that binding is protected by a write lock, then the appropriate token MUST be specified in an If request header.",
      "ja": "（DAV：ロック上書き可）：コレクションは、すでに指定されたパスのセグメントとの結合を含む場合、その結合は、書き込みロックによって保護されている場合、次いで適切なトークンがあれば要求ヘッダーで指定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Postconditions:",
      "ja": "事後条件："
    },
    {
      "indent": 6,
      "text": "(DAV:new-binding): The collection MUST have a binding that maps the segment specified in the DAV:segment element in the request body to the resource identified by the DAV:href element in the request body.",
      "ja": "（DAV：新しい結合）：DAVで識別されるリソースにリクエストボディ内のセグメントの要素：リクエストボディのhref要素コレクションが結合すなわちDAVで指定されたセグメントをマッピングしなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.1. Example: BIND",
      "section_title": true,
      "ja": "4.1。例：BIND"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "BIND /CollY HTTP/1.1 Host: www.example.com Content-Type: application/xml; charset=\"utf-8\" Content-Length: 172",
      "ja": "BIND / CollY HTTP / 1.1ホスト：www.example.comのContent-Type：アプリケーション/ xmlの; charset = \"UTF-8\" をコンテンツの長さ：172"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?> <D:bind xmlns:D=\"DAV:\"> <D:segment>bar.html</D:segment> <D:href>http://www.example.com/CollX/foo.html</D:href> </D:bind>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <D：バインドのxmlns：D = \"DAV：\"> <D：セグメント>内容でbar.html </ D：セグメント> <D：HREF> HTTP ：//www.example.com/CollX/foo.html </ D：HREF> </ D：バインド>"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>回答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 201 Created Location: http://www.example.com/CollY/bar.html",
      "ja": "HTTP / 1.1 201作成された場所：http://www.example.com/CollY/bar.html"
    },
    {
      "indent": 3,
      "text": "The server added a new binding to the collection, \"http://www.example.com/CollY\", associating \"bar.html\" with the resource identified by the URI \"http://www.example.com/CollX/foo.html\". Clients can now use the URI \"http://www.example.com/CollY/bar.html\" to submit requests to that resource.",
      "ja": "サーバは「http://www.example.com/CollY」、コレクションに新しいバインディングを追加し、URIで識別されるリソースで「内容でbar.htmlを」関連付ける「http://www.example.com/CollX/ foo.htmlという」。クライアントは、今、そのリソースに要求を提出するURI「http://www.example.com/CollY/bar.html」を使用することができます。"
    },
    {
      "indent": 0,
      "text": "5. UNBIND Method",
      "section_title": true,
      "ja": "5. UNBIND方法"
    },
    {
      "indent": 3,
      "text": "The UNBIND method modifies the collection identified by the Request-URI by removing the binding identified by the segment specified in the UNBIND body.",
      "ja": "UNBIND方法は、結合UNBIND体で指定されたセグメントによって識別さを除去することにより、リクエストURIによって識別されるコレクションを修正します。"
    },
    {
      "indent": 3,
      "text": "Once a resource is unreachable by any URI mapping, the server MAY reclaim system resources associated with that resource. If UNBIND removes a binding to a resource, but there remain URI mappings to that resource, the server MUST NOT reclaim system resources associated with the resource.",
      "ja": "リソースは任意のURIマッピングによって到達不能になると、サーバーはそのリソースに関連付けられたシステムリソースを再利用するかもしれません。 UNBINDがリソースへのバインディングを削除しますが、URIのマッピングは、そのリソースに残っている場合、サーバーはリソースに関連付けられたシステムリソースを再利用してはなりません。"
    },
    {
      "indent": 3,
      "text": "If an UNBIND request fails, the server state preceding the request MUST be restored. This method is unsafe and idempotent (see [RFC2616], Section 9.1).",
      "ja": "UNBIND要求が失敗した場合は、リクエストの前にサーバの状態を復元する必要があります。この方法は、（[RFC2616]、セクション9.1を参照）危険と冪等です。"
    },
    {
      "indent": 3,
      "text": "Marshalling:",
      "ja": "マーシャリング："
    },
    {
      "indent": 6,
      "text": "The request body MUST be a DAV:unbind XML element.",
      "ja": "アンバインドXML要素：リクエストボディは、DAVでなければなりません。"
    },
    {
      "indent": 6,
      "text": "<!ELEMENT unbind (segment)>",
      "ja": "<！ELEMENTのアンバインド（セグメント）>"
    },
    {
      "indent": 6,
      "text": "If the request succeeds, the server MUST return 200 (OK) or 204 (No Content) when the binding was successfully deleted.",
      "ja": "リクエストが成功すると、サーバーは、バインドが正常に削除された200（OK）または204（コンテンツなし）を返さなければなりません。"
    },
    {
      "indent": 6,
      "text": "If a response body for a successful request is included, it MUST be a DAV:unbind-response XML element. Note that this document does not define any elements for the UNBIND response body, but the DAV:unbind-response element is defined to ensure interoperability between future extensions that do define elements for the UNBIND response body.",
      "ja": "成功した要求に対するレスポンスボディが含まれている場合は、DAVでなければならない：アンバインド応答XML要素。この文書はUNBINDレスポンスボディのための任意の要素を定義していないことに注意してください、しかし、DAV：アンバインド応答要素がUNBINDレスポンスボディのための要素を定義行い、将来の拡張の間の相互運用性を確保するために定義されています。"
    },
    {
      "indent": 6,
      "text": "<!ELEMENT unbind-response ANY>",
      "ja": "<！ELEMENTアンバインド応答ANY>"
    },
    {
      "indent": 3,
      "text": "Preconditions:",
      "ja": "前提条件："
    },
    {
      "indent": 6,
      "text": "(DAV:unbind-from-collection): The Request-URI MUST identify a collection.",
      "ja": "（DAV：アンバインド-から収集）：のRequest-URIは、コレクションを識別しなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:unbind-source-exists): The DAV:segment element MUST identify a binding in the collection identified by the Request-URI.",
      "ja": "（DAV：アンバインドソースが-存在）：DAV：セグメント要素がRequest-URIによって識別されるコレクション内のバインディングを識別しなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:locked-update-allowed): If the collection identified by the Request-URI is write-locked, then the appropriate token MUST be specified in the request.",
      "ja": "（DAV：ロック更新可）：のRequest-URIによって識別されるコレクションは書き込みロックされている場合、適切なトークンは、要求で指定されなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:protected-url-deletion-allowed): If the binding identified by the segment is protected by a write lock, then the appropriate token MUST be specified in the request.",
      "ja": "（DAV：保護されたURL欠失許容）：セグメントによって同定された結合は、書き込みロックで保護されている場合、次いで適切なトークンは、要求で指定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Postconditions:",
      "ja": "事後条件："
    },
    {
      "indent": 6,
      "text": "(DAV:binding-deleted): The collection MUST NOT have a binding for the segment specified in the DAV:segment element in the request body.",
      "ja": "（DAV：欠失バインディング）：リクエストボディ内のセグメントの要素：コレクションは、DAVで指定されたセグメントに結合してはなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:lock-deleted): If the internal member URI of the binding specified by the Request-URI and the DAV:segment element in the request body was protected by a write lock at the time of the request, that write lock must have been deleted by the request.",
      "ja": "Request-URIおよびDAVで指定結合の内部メンバーURI場合：（DAV：ロック削除）リクエストボディ内のセグメント要素は要求時の書込ロックで保護された、その書き込みロックを持っている必要があります要求によって削除されて。"
    },
    {
      "indent": 0,
      "text": "5.1. Example: UNBIND",
      "section_title": true,
      "ja": "5.1。例：UNBIND"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "UNBIND /CollX HTTP/1.1 Host: www.example.com Content-Type: application/xml; charset=\"utf-8\" Content-Length: 117",
      "ja": "UNBIND / CollX HTTP / 1.1ホスト：www.example.comのContent-Type：アプリケーション/ xmlの; charset = \"UTF-8\" をコンテンツの長さ：117"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?> <D:unbind xmlns:D=\"DAV:\"> <D:segment>foo.html</D:segment> </D:unbind>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <D：アンバインドのxmlns：D = \"DAV：\"> <D：セグメント> foo.htmlという</ D：セグメント> </ D：アンバインド>"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>回答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK",
      "ja": "HTTP / 1.1 200 OK"
    },
    {
      "indent": 3,
      "text": "The server removed the binding named \"foo.html\" from the collection, \"http://www.example.com/CollX\". A request to the resource named \"http://www.example.com/CollX/foo.html\" will return a 404 (Not Found) response.",
      "ja": "サーバーは、コレクションからの結合という名前の「foo.htmlという」、「http://www.example.com/CollX」を削除しました。名前のリソースへの要求は「http://www.example.com/CollX/foo.html」404（Not Found）応答を返します。"
    },
    {
      "indent": 0,
      "text": "6. REBIND Method",
      "section_title": true,
      "ja": "6. REBIND方法"
    },
    {
      "indent": 3,
      "text": "The REBIND method removes a binding to a resource from a collection, and adds a binding to that resource into the collection identified by the Request-URI. The request body specifies the binding to be added (segment) and the old binding to be removed (href). It is effectively an atomic form of a MOVE request, and MUST be treated the same way as MOVE for the purpose of determining access permissions.",
      "ja": "REBINDメソッドは、コレクションからリソースへの結合を除去し、そして、Request-URIによって識別されるコレクションにそのリソースへの結合が追加されます。リクエストボディは、（セグメント）を添加する結合、古いバインディングを除去する（HREF）を指定します。これは、効果的に移動要求の原子の形であり、アクセス権を決定する目的のためにMOVEと同じように扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a REBIND request fails, the server state preceding the request MUST be restored. This method is unsafe and idempotent (see [RFC2616], Section 9.1).",
      "ja": "REBIND要求に失敗した場合は、リクエストの前にサーバの状態を復元する必要があります。この方法は、（[RFC2616]、セクション9.1を参照）危険と冪等です。"
    },
    {
      "indent": 3,
      "text": "Marshalling:",
      "ja": "マーシャリング："
    },
    {
      "indent": 6,
      "text": "The request MAY include an Overwrite header.",
      "ja": "要求が上書きヘッダーを含むかもしれません。"
    },
    {
      "indent": 6,
      "text": "The request body MUST be a DAV:rebind XML element.",
      "ja": "リクエストボディは、DAVでなければならない：XML要素を再バインドします。"
    },
    {
      "indent": 6,
      "text": "<!ELEMENT rebind (segment, href)>",
      "ja": "<！ELEMENT再バインド（セグメント、HREF）>"
    },
    {
      "indent": 6,
      "text": "If the request succeeds, the server MUST return 201 (Created) when a new binding was created and 200 (OK) or 204 (No Content) when an existing binding was replaced.",
      "ja": "リクエストが成功すると、サーバーは、既存のバインディングが交換された新しいバインディングが作成された（作成者）201および200（OK）または204（コンテンツなし）を返さなければなりません。"
    },
    {
      "indent": 6,
      "text": "If a response body for a successful request is included, it MUST be a DAV:rebind-response XML element. Note that this document does not define any elements for the REBIND response body, but the DAV:rebind-response element is defined to ensure interoperability between future extensions that do define elements for the REBIND response body.",
      "ja": "再バインド応答XML要素：成功したリクエストのレスポンスボディが含まれている場合は、DAVでなければなりません。この文書はREBINDのレスポンスボディのための任意の要素を定義していないことに注意してください、しかし、DAV：再バインド応答要素は、REBINDのレスポンスボディのための要素を定義行い、将来の拡張の間の相互運用性を確保するために定義されています。"
    },
    {
      "indent": 6,
      "text": "<!ELEMENT rebind-response ANY>",
      "ja": "<！ELEMENT再バインド応答ANY>"
    },
    {
      "indent": 3,
      "text": "Preconditions:",
      "ja": "前提条件："
    },
    {
      "indent": 6,
      "text": "(DAV:rebind-into-collection): The Request-URI MUST identify a collection.",
      "ja": "（DAV：再バインド-にコレクション）：のRequest-URIは、コレクションを識別しなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:rebind-source-exists): The DAV:href element MUST identify a resource.",
      "ja": "（DAV：再バインド・ソースは、存在）：DAV：hrefの要素は、リソースを識別しなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:cross-server-binding): If the resource identified by the DAV: href element in the request body is on another server from the collection identified by the Request-URI, the server MUST support cross-server bindings (servers that do not support cross-server bindings can use this condition code to signal the client exactly why the request failed).",
      "ja": "（DAV：クロスサーバ結合）：DAVで識別されるリソース場合：リクエストボディのhref要素が要求URIで識別されるコレクションから別のサーバー上にある、サーバはクロスサーバのバインディング（実行するサーバをサポートしなければなりませんないサポートクロスサーバのバインディングは、要求が失敗した理由）正確にクライアントを知らせるために、この条件コードを使用することができます。"
    },
    {
      "indent": 6,
      "text": "(DAV:name-allowed): The name specified by the DAV:segment is available for use as a new binding name.",
      "ja": "（DAV：名可）：DAVによって指定された名前：セグメントは新しいバインディング名として使用可能です。"
    },
    {
      "indent": 6,
      "text": "(DAV:can-overwrite): If the collection already contains a binding with the specified path segment, and if an Overwrite header is included, the value of the Overwrite header MUST be \"T\".",
      "ja": "（DAV：CAN-上書き）：コレクションは、すでに指定されたパスのセグメントとの結合を含み、上書きヘッダが含まれている場合、上書きヘッダの値が「T」でなければならない場合。"
    },
    {
      "indent": 6,
      "text": "(DAV:cycle-allowed): If the DAV:href element identifies a collection, and if the Request-URI identifies a collection that is a member of that collection, the server MUST support cycles in the URI namespace (servers that do not support cycles can use this condition code to signal the client exactly why the request failed).",
      "ja": "（DAV：サイクル-許可）：hrefの要素のコレクションを識別し、要求URIは、そのコレクションのメンバーであるコレクションを識別した場合、サーバがサポートしていないURI名前空間（サーバ内のサイクルをサポートしなければならない：DAVの場合サイクル）は、要求が失敗した理由を正確にクライアントを知らせるために、この条件コードを使用することができます。"
    },
    {
      "indent": 6,
      "text": "(DAV:locked-update-allowed): If the collection identified by the Request-URI is write-locked, then the appropriate token MUST be specified in the request.",
      "ja": "（DAV：ロック更新可）：のRequest-URIによって識別されるコレクションは書き込みロックされている場合、適切なトークンは、要求で指定されなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:protected-url-modification-allowed): If the collection identified by the Request-URI already contains a binding with the specified path segment, and if that binding is protected by a write lock, then the appropriate token MUST be specified in the request.",
      "ja": "（DAV：保護されたURL修飾許容）のRequest-URIによって識別されるコレクションは、すでに指定されたパスのセグメントとの結合を含み、その結合は、書き込みロックによって保護されている場合、次いで適切なトークンは、で指定する必要がある場合リクエスト。"
    },
    {
      "indent": 6,
      "text": "(DAV:locked-source-collection-update-allowed): If the collection identified by the parent collection prefix of the DAV:href URI is write-locked, then the appropriate token MUST be specified in the request.",
      "ja": "（DAV：ロック・ソース・コレクション・更新許可）：コレクションは、DAVの親コレクションプレフィックスによって識別される場合：hrefのURIが書き込みロックされ、次いで適切なトークンは、要求で指定されなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:protected-source-url-deletion-allowed): If the DAV:href URI is protected by a write lock, then the appropriate token MUST be specified in the request.",
      "ja": "DAV場合：（DAV：保護されたソースURL欠失許容）HREF URIが書き込みロックによって保護され、次いで適切なトークンは、要求で指定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Postconditions:",
      "ja": "事後条件："
    },
    {
      "indent": 6,
      "text": "(DAV:new-binding): The collection MUST have a binding that maps the segment specified in the DAV:segment element in the request body, to the resource that was identified by the DAV:href element in the request body.",
      "ja": "（DAV：新しい結合）：リクエストボディ内のセグメント要素、DAVにより同定されたリソースへ：リクエストボディのhref要素のコレクションは、DAVで指定されたセグメントをマッピングすること結合を持たなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:binding-deleted): The URL specified in the DAV:href element in the request body MUST NOT be mapped to a resource.",
      "ja": "（DAV：欠失結合）：DAVで指定されたURL：リクエストボディのhref要素がリソースにマッピングされてはいけません。"
    },
    {
      "indent": 6,
      "text": "(DAV:lock-deleted): If the URL specified in the DAV:href element in the request body was protected by a write lock at the time of the request, that write lock must have been deleted by the request.",
      "ja": "（DAV：ロックは-削除）：DAVに指定されたURL場合：リクエストボディのhref要素は、要求時に書き込みロックによって保護されていた、その書き込みロックが要求によって削除されている必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1. Example: REBIND",
      "section_title": true,
      "ja": "6.1。例：REBIND"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "REBIND /CollX HTTP/1.1 Host: www.example.com Content-Type: application/xml; charset=\"utf-8\" Content-Length: 176",
      "ja": "REBIND / CollX HTTP / 1.1ホスト：www.example.comのContent-Type：アプリケーション/ xmlの; charset = \"UTF-8\" をコンテンツの長さ：176"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?> <D:rebind xmlns:D=\"DAV:\"> <D:segment>foo.html</D:segment> <D:href>http://www.example.com/CollY/bar.html</D:href> </D:rebind>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <D：のxmlnsを再バインド：D = \"DAV：\"> <D：セグメント> foo.htmlという</ D：セグメント> <D：HREF> HTTP ：//www.example.com/CollY/bar.html </ D：HREF> </ D：再バインド>"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>回答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK",
      "ja": "HTTP / 1.1 200 OK"
    },
    {
      "indent": 3,
      "text": "The server added a new binding to the collection, \"http://www.example.com/CollX\", associating \"foo.html\" with the resource identified by the URI \"http://www.example.com/CollY/bar.html\" and removes the binding named \"bar.html\" from the collection identified by the URI",
      "ja": "サーバは「http://www.example.com/CollX」、コレクションに新しいバインディングを追加し、URIで識別されるリソースで「foo.htmlという」を関連付ける「http://www.example.com/CollY/内容でbar.html」と結合という名前の削除 『URIで識別されるコレクションから内容でbar.htmlを』"
    },
    {
      "indent": 3,
      "text": "\"http://www.example.com/CollY\". Clients can now use the URI \"http://www.example.com/CollX/foo.html\" to submit requests to that resource, and requests on the URI \"http://www.example.com/CollY/bar.html\" will fail with a 404 (Not Found) response.",
      "ja": "\"http://www.example.com/CollY\"。クライアントは、今URI「http://www.example.com/CollY/barにそのリソースへの要求、および要求を提出するURI「http://www.example.com/CollX/foo.html」を使用することができます。 htmlの」404（見つかりません）応答で失敗します。"
    },
    {
      "indent": 0,
      "text": "6.2. Example: REBIND in Presence of Locks and Bind Loops",
      "section_title": true,
      "ja": "6.2。例：ロックの有無とバインドループにREBIND"
    },
    {
      "indent": 3,
      "text": "To illustrate the effects of locks and bind loops on a REBIND operation, consider the following collection:",
      "ja": "ロックの影響を説明し、再バインド操作上のループをバインドするには、次のコレクションを考慮してください。"
    },
    {
      "indent": 14,
      "text": "+------------------+\n| Root Collection  |\n|  bindings:       |\n|  CollW           |\n+------------------+\n     |\n     |\n     |\n+-------------------------------+\n| Collection C1                 |<--------+\n| LOCKED infinity               |         |\n| (lock token L1)               |         |\n| bindings:                     |         |\n| CollX               CollY     |         |\n+-------------------------------+         |\n     |                  |                 |\n     |                  |  (creates loop) |\n     |                  |                 |\n+-----------------+  +------------------+ |\n| Collection C2   |  | Collection C3    | |\n| (inherit lock)  |  | (inherit lock)   | |\n| (lock token L1) |  | (lock token L1)  | |\n| bindings:       |  | bindings:        | |\n|  {none}         |  | y.gif     CollZ  | |\n+-----------------+  +------------------+ |\n                       |            |     |\n                       |            +-----+\n                       |\n                   +---------------------------+\n                   | Resource R2               |\n                   | (lock inherited from C1)  |\n                   | (lock token L1)           |\n                   +---------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(where L1 is \"urn:uuid:f92d4fae-7012-11ab-a765-00c0ca1f6bf9\").",
      "ja": "（ここで、L1は、 \"：UUID：f92d4fae-7012-11ab-a765-00c0ca1f6bf9 URN\" です）。"
    },
    {
      "indent": 3,
      "text": "Note that the binding between CollZ and C1 creates a loop in the containment hierarchy. Servers are not required to support such loops, though the server in this example does.",
      "ja": "CollZとC1の間の結合が包含階層のループを作成することに留意されたいです。この例では、サーバーがないのにサーバーは、このようなループをサポートする必要はありません。"
    },
    {
      "indent": 3,
      "text": "The REBIND request below will remove the segment \"CollZ\" from C3 and add a new binding from \"CollA\" to the collection C2.",
      "ja": "REBIND要求は、以下のC3からセグメント「CollZ」を削除し、収集C2に「コラ」から新しいバインディングを追加します。"
    },
    {
      "indent": 3,
      "text": "REBIND /CollW/CollX HTTP/1.1 Host: www.example.com If: (<urn:uuid:f92d4fae-7012-11ab-a765-00c0ca1f6bf9>) Content-Type: application/xml; charset=\"utf-8\" Content-Length: 152",
      "ja": "REBIND / CollW / CollX HTTP / 1.1ホスト：www.example.comの場合：（<URN：UUID：f92d4fae-7012-11ab-a765-00c0ca1f6bf9>）のContent-Type：アプリケーション/ xmlの; charset = \"UTF-8\" をコンテンツの長さ：152"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?> <D:rebind xmlns:D=\"DAV:\"> <D:segment>CollA</D:segment> <D:href>/CollW/CollY/CollZ</D:href> </D:rebind>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <D：のxmlnsを再バインド：D = \"DAV：\"> <D：セグメント>コラが</ D：セグメント> <D：HREF> / CollW / CollY / CollZ </ D：HREF> </ D：再バインド>"
    },
    {
      "indent": 3,
      "text": "The outcome of the REBIND operation is:",
      "ja": "REBIND操作の結果は次のとおりです。"
    },
    {
      "indent": 14,
      "text": "+------------------+\n| Root Collection  |\n|  bindings:       |\n|  CollW           |\n+------------------+\n     |\n     |\n     |\n+-------------------------------+\n| Collection C1                 |\n| LOCKED infinity               |\n| (lock token L1)               |\n| bindings:                     |\n| CollX                  CollY  |\n+-------------------------------+\n     |              ^      |\n     |              |      |\n+-----------------+ | +------------------+\n| Collection C2   | | | Collection C3    |\n|(inherited lock) | | | (inherited lock) |\n|(lock token L1)  | | | (lock token L1)  |\n| bindings:       | | | bindings:        |\n| CollA           | | | y.gif            |\n+-----------------+ | +------------------+\n    |               |    |\n    +---------------+    |\n     (creates loop)      |\n                   +---------------------------+\n                   | Resource R2               |\n                   | (inherited lock from C1)  |\n                   | (lock token L1)           |\n                   +---------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7. Additional Status Codes",
      "section_title": true,
      "ja": "7.追加のステータスコード"
    },
    {
      "indent": 0,
      "text": "7.1. 208 Already Reported",
      "section_title": true,
      "ja": "7.1。すでに報告されている208"
    },
    {
      "indent": 3,
      "text": "The 208 (Already Reported) status code can be used inside a DAV: propstat response element to avoid enumerating the internal members of multiple bindings to the same collection repeatedly. For each binding to a collection inside the request's scope, only one will be reported with a 200 status, while subsequent DAV:response elements for all other bindings will use the 208 status, and no DAV:response elements for their descendants are included.",
      "ja": "繰り返し同じコレクションに複数のバインディングの内部メンバーを列挙避けるためpropstat応答エレメント：208（既に報告）ステータスコードがDAV内で使用することができます。他のすべてのバインディングの応答エレメント208個の状態が使用され、およびNO DAV：その子孫の応答要素が含まれていない後続のDAVはながら、各リクエストのスコープ内コレクションに結合するために、一つだけは、200のステータスで報告されます。"
    },
    {
      "indent": 3,
      "text": "Note that the 208 status will only occur for \"Depth: infinity\" requests, and that it is of particular importance when the multiple collection bindings cause a bind loop as discussed in Section 2.2.",
      "ja": "208のステータスが唯一の「深さ：無限」のために発生することに注意してくださいリクエスト、および2.2節で述べたように、複数のコレクションバインディングがバインドループが発生するとき、それは特に重要であること。"
    },
    {
      "indent": 3,
      "text": "A client can request the DAV:resource-id property in a PROPFIND request to guarantee that they can accurately reconstruct the binding structure of a collection with multiple bindings to a single resource.",
      "ja": "クライアントは、DAVを要求することができます：リソース-idプロパティをPROPFIND要求に、彼らは正確に単一のリソースに複数のバインディングのコレクションの結合構造を再構築できることを保証します。"
    },
    {
      "indent": 3,
      "text": "For backward compatibility with clients not aware of the 208 status code appearing in multistatus response bodies, it SHOULD NOT be used unless the client has signaled support for this specification using the \"DAV\" request header (see Section 8.2). Instead, a 508 status should be returned when a binding loop is discovered. This allows the server to return the 508 as the top-level return status, if it discovers it before it started the response, or in the middle of a multistatus, if it discovers it in the middle of streaming out a multistatus response.",
      "ja": "クライアントが「DAV」リクエストヘッダを使用して、この仕様のサポートを合図していない限り、multistatusレスポンスボディに登場する208のステータスコードを認識していないクライアントとの後方互換性のために、それを使用すべきでない（8.2節を参照してください）。結合ループが発見されたときに代わりに、508のステータスが返されるべきです。それが応答を開始する前に、それはmultistatus応答を行うストリーミングの途中でそれを発見した場合、それは、それを発見し、またはmultistatusの途中で場合、これは、サーバはトップレベルのリターン・ステータスとして508を返すことができます。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Example: PROPFIND by Bind-Aware Client",
      "section_title": true,
      "ja": "7.1.1。例：バインド対応クライアントによってPROPFIND"
    },
    {
      "indent": 3,
      "text": "For example, consider a PROPFIND request on /Coll (bound to collection C), where the members of /Coll are /Coll/Foo (bound to resource R) and /Coll/Bar (bound to collection C).",
      "ja": "例えば、/コルのメンバーは/コル/ Fooの（R資源にバインド）と（回収Cに結合している）/コル/バーです（収集Cに結合している）/コル、上のPROPFIND要求を検討してください。"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "PROPFIND /Coll/ HTTP/1.1 Host: www.example.com Depth: infinity DAV: bind Content-Type: application/xml; charset=\"utf-8\" Content-Length: 152",
      "ja": "PROPFIND /コル/ HTTP / 1.1ホスト：www.example.com深さ：無限DAV：バインドのContent-Type：アプリケーション/ xmlの; charset = \"UTF-8\" をコンテンツの長さ：152"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?> <D:propfind xmlns:D=\"DAV:\"> <D:prop> <D:displayname/> <D:resource-id/> </D:prop> </D:propfind>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <D：PROPFINDのxmlns：D = \"DAV：\"> <D：プロペラ> <D：のdisplayName /> <D：リソース-ID /> < / D：プロップ> </ D：PROPFIND>"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>回答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 207 Multi-Status Content-Type: application/xml; charset=\"utf-8\" Content-Length: 1241",
      "ja": "HTTP / 1.1 207マルチステータスのContent-Type：アプリケーション/ xmlの; charset = \"UTF-8\" をコンテンツの長さ：1241"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?> <D:multistatus xmlns:D=\"DAV:\"> <D:response> <D:href>http://www.example.com/Coll/</D:href> <D:propstat> <D:prop> <D:displayname>Loop Demo</D:displayname> <D:resource-id> <D:href >urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf8</D:href> </D:resource-id> </D:prop> <D:status>HTTP/1.1 200 OK</D:status> </D:propstat> </D:response> <D:response> <D:href>http://www.example.com/Coll/Foo</D:href> <D:propstat> <D:prop> <D:displayname>Bird Inventory</D:displayname> <D:resource-id> <D:href >urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf9</D:href> </D:resource-id> </D:prop> <D:status>HTTP/1.1 200 OK</D:status> </D:propstat> </D:response> <D:response> <D:href>http://www.example.com/Coll/Bar</D:href> <D:propstat> <D:prop> <D:displayname>Loop Demo</D:displayname> <D:resource-id> <D:href >urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf8</D:href> </D:resource-id> </D:prop> <D:status>HTTP/1.1 208 Already Reported</D:status> </D:propstat> </D:response> </D:multistatus>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <D：multistatusのxmlns：D = \"DAV：\"> <D：レスポンス> <D：HREF> http://www.example.com/コル/ </ D：HREF> <D：propstat> <D：プロペラ> <D：のDisplayName>ループデモ</ D：表示名> <D：リソースID> <D：HREF> URN：UUID：f81d4fae-7dec -11d0-a765-00a0c91e6bf8 </ D：HREF> </ D：リソースID> </ D：プロペラ> <D：ステータス> HTTP / 1.1 200 OK </ D：状態> </ D：propstat> </ D：レスポンス> <D：レスポンス> <D：HREF> http://www.example.com/Coll/Foo </ D：HREF> <D：propstat> <D：プロペラ> <D：のDisplayName>鳥インベントリ</ D：表示名> <D：リソースID> <D：HREF> URN：UUID：f81d4fae-7dec-11D0-a765-00a0c91e6bf9 </ D：HREF> </ D：リソースID> </ D：小道具> <D：ステータス> HTTP / 1.1 200 OK </ D：状態> </ D：propstat> </ D：レスポンス> <D：レスポンス> <D：HREF> http://www.example.com/Coll /バー</ D：HREF> <D：propstat> <D：プロペラ> <D：のDisplayName>ループデモ</ D：表示名> <D：リソースID> <D：HREF> URN：UUID：f81d4fae-7dec -11d0-a765-00a0c91e6bf8 </ D：HREF> </ D：リソースID> </ D：プロペラ> <D：ステータス> HTTP / 1.1 208すでに報告</ D：状態> </ D：propstat> < / D：レスポンス> </ D：multistatus>"
    },
    {
      "indent": 0,
      "text": "7.1.2. Example: PROPFIND by Non-Bind-Aware Client",
      "section_title": true,
      "ja": "7.1.2。例：非バインド対応クライアントによってPROPFIND"
    },
    {
      "indent": 3,
      "text": "In this example, the client isn't aware of the 208 status code introduced by this specification. As the \"Depth: infinity\" PROPFIND request would cause a loop condition, the whole request is rejected with a 508 status.",
      "ja": "この例では、クライアントは、本明細書によって導入208のステータスコードを認識しません。 「深さ：無限大」とPROPFIND要求がループ状態を引き起こす、全体の要求は508のステータスで拒否されます。"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "PROPFIND /Coll/ HTTP/1.1 Host: www.example.com Depth: infinity Content-Type: application/xml; charset=\"utf-8\" Content-Length: 125",
      "ja": "PROPFIND /コル/ HTTP / 1.1ホスト：www.example.com深さ：無限のContent-Type：アプリケーション/ xmlの; charset = \"UTF-8\" をコンテンツの長さ：125"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?> <D:propfind xmlns:D=\"DAV:\"> <D:prop> <D:displayname/> </D:prop> </D:propfind>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <D：PROPFINDのxmlns：D = \"DAV：\"> <D：プロペラ> <D：のdisplayName /> </ D：プロップ> </ D ：PROPFIND>"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>回答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 508 Loop Detected",
      "ja": "HTTP / 1.1 508ループ検出"
    },
    {
      "indent": 0,
      "text": "7.2. 508 Loop Detected",
      "section_title": true,
      "ja": "7.2。 508ループ検出"
    },
    {
      "indent": 3,
      "text": "The 508 (Loop Detected) status code indicates that the server terminated an operation because it encountered an infinite loop while processing a request with \"Depth: infinity\". This status indicates that the entire operation failed.",
      "ja": "508（ループ検出）のステータスコードが「：無限深さ」の要求を処理しつつ、無限ループが発生したため、サーバが動作を終了したことを示しています。このステータスは、全体の操作が失敗したことを示しています。"
    },
    {
      "indent": 0,
      "text": "8. Capability Discovery",
      "section_title": true,
      "ja": "8.能力ディスカバリー"
    },
    {
      "indent": 0,
      "text": "8.1. OPTIONS Method",
      "section_title": true,
      "ja": "8.1。 OPTIONSメソッド"
    },
    {
      "indent": 3,
      "text": "If the server supports bindings, it MUST return the compliance class name \"bind\" as a field in the \"DAV\" response header (see [RFC4918], Section 10.1) from an OPTIONS request on any resource implemented by that server. A value of \"bind\" in the \"DAV\" header MUST indicate that the server supports all MUST-level requirements and REQUIRED features specified in this document.",
      "ja": "サーバーがバインディングをサポートしている場合、それは、そのサーバによって実装任意のリソース上のOPTIONS要求から（[RFC4918]、10.1節を参照してください）「DAV」レスポンスヘッダ内のフィールドとして「バインド」準拠のクラス名を返さなければなりません。 「DAV」ヘッダ内の「バインド」の値は、サーバがすべてのMUSTレベルの要件をサポートし、REQUIREDは、この文書で指定されていますことを示す必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2. 'DAV' Request Header",
      "section_title": true,
      "ja": "8.2。 「DAV」リクエスト・ヘッダー"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD signal support for all MUST-level requirements and REQUIRED features by submitting a \"DAV\" request header containing the compliance class name \"bind\". In particular, the client MUST understand the 208 status code defined in Section 7.1.",
      "ja": "クライアントは、コンプライアンス・クラス名「バインド」を含む「DAV」リクエストヘッダを提出することにより、すべてのMUSTレベルの要件と必要な機能のサポートを通知すべきです。具体的には、クライアントはセクション7.1で定義された208のステータスコードを理解する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Relationship to Locking in WebDAV",
      "section_title": true,
      "ja": "WebDAVの中でロック9.関係"
    },
    {
      "indent": 3,
      "text": "Locking is an optional feature of WebDAV ([RFC4918]). The base WebDAV specification and this protocol extension have been designed in parallel, making sure that all features of WebDAV can be implemented on a server that implements this protocol as well.",
      "ja": "ロックは、WebDAV（[RFC4918]）のオプション機能です。基本WebDAV仕様と、このプロトコル拡張は、WebDAVのすべての機能は、同様に、このプロトコルを実装して、サーバー上で実施することができることを確認しながら、並行して設計されています。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, WebDAV uses the term \"lock-root\" inconsistently. It is introduced in Section 6.1 of [RFC4918], point 2, as:",
      "ja": "残念ながら、WebDAVは「ロック・ルートを」矛盾用語を使用しています。それは次のように、[RFC4918]の6.1節、ポイント2で導入されています。"
    },
    {
      "indent": 6,
      "text": "2. A resource becomes directly locked when a LOCK request to a URL of that resource creates a new lock. The \"lock-root\" of the new lock is that URL. If at the time of the request, the URL is not mapped to a resource, a new empty resource is created and directly locked.",
      "ja": "そのリソースのURLにLOCK要求が新しいロックを作成するとき2.リソースを直接ロックされます。新しいロックの「ロック・ルート」は、URLです。要求時に、URLがリソースにマッピングされていない場合は、新しい空のリソースが作成され、直接ロックされています。"
    },
    {
      "indent": 3,
      "text": "On the other hand, [RFC4918], Section 9.10.1 states:",
      "ja": "一方、[RFC4918]、セクション9.10.1の状態："
    },
    {
      "indent": 6,
      "text": "A LOCK request to an existing resource will create a lock on the resource identified by the Request-URI, provided the resource is not already locked with a conflicting lock. The resource identified in the Request-URI becomes the root of the lock.",
      "ja": "既存のリソースへのLOCK要求は、すでに競合ロックでロックされていないリソースを提供Request-URIによって識別されるリソースのロックを、作成します。リクエスト-URIで識別されるリソースは、ロックのルートになります。"
    },
    {
      "indent": 3,
      "text": "Servers that implement both WebDAV locking and support for multiple bindings MUST use the first interpretation: the lock-root is the URI through which the lock was created, not a resource. This URI, and potential aliases of this URI ([RFC4918], Section 5), are said to be \"protected\" by the lock.",
      "ja": "複数のバインディングのためのWebDAVロックとサポートの両方を実装するサーバは最初の解釈を使用しなければならない：ロックルートはロックが作成された通過URI、ない資源です。このURI、このURI（[RFC4918]、セクション5）の潜在的なエイリアスは、ロックによって「保護」されると言われます。"
    },
    {
      "indent": 3,
      "text": "As defined in the introduction to Section 7 of [RFC4918], write operations that modify the state of a locked resource require that the lock token is submitted with the request. Consistent with WebDAV, the state of the resource consists of the content (\"any variant\"), dead properties, lockable live properties (item 1), plus, for a collection, all its bindings (item 2). Note that this, by definition, does not depend on the Request-URI to which the write operation is applied (the locked state is a property of the resource, not its URI).",
      "ja": "[RFC4918]のセクション7の導入部で定義されているように、ロックされたリソースの状態を変更する操作は、ロック・トークンを要求して提出されることを必要と書きます。 WebDAVのと一致して、リソースの状態は、コンテンツ（「任意の変異体」）、死者の特性、ロック可能なライブプロパティ（項目1）、プラス、コレクションのために、そのすべてのバインディング（項目2）から構成されています。これは、定義により、書き込み動作が適用されるのRequest-URI（ロック状態がリソースではなく、そのURIの特性である）に依存しないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "However, the lock-root is the URI through which the lock was requested. Thus, the protection defined in item 3 of the list does not apply to additional URIs that may be mapped to the same resource due to the existence of multiple bindings.",
      "ja": "しかし、ロック・ルートは、ロックが要求されたURIています。したがって、リストの項目3で定義された保護は、複数のバインディングの存在に起因する同じリソースにマッピングすることができる追加のURIに適用されません。"
    },
    {
      "indent": 0,
      "text": "9.1. Example: Locking and Multiple Bindings",
      "section_title": true,
      "ja": "9.1。例：ロックと複数のバインディング"
    },
    {
      "indent": 3,
      "text": "Consider a root collection \"/\", containing the two collections C1 and C2, named \"/CollX\" and \"/CollY\", and a child resource R, bound to C1 as \"/CollX/test\" and bound to C2 as \"/CollY/test\":",
      "ja": "/」としてルート「/ CollX」という名前の2つのコレクションC1とC2を含むコレクション「/」、および「/ CollY」、および「/ CollX /テスト」として、C1に結合している子リソースR、及びC2に結合を考えてみましょうCollY /テスト \"："
    },
    {
      "indent": 20,
      "text": "     +-------------------------+\n     | Root Collection         |\n     |  bindings:              |\n     |  CollX          CollY   |\n     +-------------------------+\n         |                |\n         |                |\n         |                |\n+---------------+  +---------------+\n| Collection C1 |  | Collection C2 |\n| bindings:     |  | bindings:     |\n|     test      |  |     test      |\n+---------------+  +---------------+\n         |               |\n         |               |\n         |               |\n        +------------------+\n        |    Resource R    |\n        +------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Given a host name of \"www.example.com\", applying a depth-zero write lock to \"/CollX/test\" will lock the resource R, and the lock-root of this lock will be \"http://www.example.com/CollX/test\".",
      "ja": "「/ CollX /テスト」に深さゼロの書き込みロックを適用し、「www.example.com」のホスト名を与えられたリソースRをロックし、このロックのロック・ルートは、「HTTPになります：// WWW。 example.com/CollX/test」。"
    },
    {
      "indent": 3,
      "text": "Thus, the following operations will require that the associated lock token is submitted with the \"If\" request header ([RFC4918], Section 10.4):",
      "ja": "従って、以下の動作は、関連するロックトークンが「IF」要求ヘッダ（[RFC4918]、セクション10.4）で提出されることを必要とするであろう。"
    },
    {
      "indent": 3,
      "text": "o a PUT or PROPPATCH request modifying the content or lockable properties of resource R (as R is locked) -- no matter which URI is used as request target, and",
      "ja": "O（Rがロックされているように）リソースRのコンテンツまたはロック可能なプロパティを変更しないPUTまたはPROPPATCH要求 -  URIは、要求の対象として使用されるに関係なく、および"
    },
    {
      "indent": 3,
      "text": "o a MOVE, REBIND, UNBIND, or DELETE request causing \"/CollX/test\" not to be mapped to resource R anymore (be it addressed to \"/CollX\" or \"/CollX/test\").",
      "ja": "O MOVEは、UNBINDを再バインド、または要求原因の削除「/ CollX /試験」はもうRリソースにマッピングされるべきではない（それが対処する「/ CollX」または「/ CollX /試験」）。"
    },
    {
      "indent": 3,
      "text": "The following operations will not require submission of the lock token:",
      "ja": "以下の操作は、ロック・トークンの提出を必要としません。"
    },
    {
      "indent": 3,
      "text": "o a DELETE request addressed to \"/CollY\" or \"/CollY/test\", as it does not affect the resource R, nor the lock-root,",
      "ja": "O DELETE要求は、それが資源Rには影響を与えないように「/ CollY」または「/ CollY /テスト」を取り上げ、またロック・ルート、"
    },
    {
      "indent": 3,
      "text": "o for the same reason, an UNBIND request removing the binding \"test\" from collection C2, or the binding \"CollY\" from the root collection, and",
      "ja": "同じ理由で、コレクションC2から結合「試験」、またはルートコレクションから結合「CollY」を除去UNBIND要求のO、及び"
    },
    {
      "indent": 3,
      "text": "o similarly, a MOVE or REBIND request causing \"/CollY/test\" not being mapped to resource R anymore.",
      "ja": "O同様に、MOVEまたは原因要求を再バインドを「/ CollY /試験」もうRリソースにマッピングされていません。"
    },
    {
      "indent": 3,
      "text": "Note that despite the lock-root being \"http://www.example.com/CollX/test\", an UNLOCK request can be addressed through any URI mapped to resource R, as UNLOCK operates on the resource identified by the Request-URI, not that URI (see [RFC4918], Section 9.11).",
      "ja": "任意のURIがUNLOCKがRequest-URIで識別されるリソースで動作するように、Rリソースにマッピングを通じてロックルートがあるにもかかわらず「http://www.example.com/CollX/test」、アンロック要求に対処することができることに注意してください、URIは（セクション9.11を[RFC4918]を参照）ではないこと。"
    },
    {
      "indent": 0,
      "text": "10. Relationship to WebDAV Access Control Protocol",
      "section_title": true,
      "ja": "WebDAVのアクセス制御プロトコルへの10の関係"
    },
    {
      "indent": 3,
      "text": "Note that the WebDAV Access Control Protocol has been designed for compatibility with systems that allow multiple URIs to map to the same resource (see [RFC3744], Section 5):",
      "ja": "WebDAVのアクセス制御プロトコルは、複数のURIが同じリソース（[RFC3744]、セクション5を参照）にマッピングすることを可能にするシステムとの互換性のために設計されていることに注意してください。"
    },
    {
      "indent": 6,
      "text": "Access control properties (especially DAV:acl and DAV:inherited-acl-set) are defined on the resource identified by the Request-URI of a PROPFIND request. A direct consequence is that if the resource is accessible via multiple URI, the value of access control properties is the same across these URI.",
      "ja": "アクセス制御特性（特にDAV：ACLおよびDAV：継承-ACL-セット）PROPFIND要求のRequest-URIによって識別されるリソース上で定義されています。直接の結果は、リソースが複数のURIを介してアクセスされた場合、アクセス制御プロパティの値は、これらのURI全体で同じであるということです。"
    },
    {
      "indent": 3,
      "text": "Furthermore, note that BIND and REBIND behave the same as MOVE with respect to the DAV:acl property (see [RFC3744], Section 7.3).",
      "ja": "さらに、そのBINDに注意し、DAVに対して移動と同じように振る舞うREBIND：ACLプロパティ（[RFC3744]セクション7.3を参照）。"
    },
    {
      "indent": 0,
      "text": "11. Relationship to Versioning Extensions to WebDAV",
      "section_title": true,
      "ja": "WebDAVのにバージョン管理の拡張に11の関係"
    },
    {
      "indent": 3,
      "text": "Servers that implement Workspaces ([RFC3253], Section 6) and Version-Controlled Collections ([RFC3253], Section 14) already need to implement BIND-like behavior in order to handle UPDATE and UNCHECKOUT semantics.",
      "ja": "ワークスペース（[RFC3253]、セクション6）とバージョン管理されたコレクション（[RFC3253]、セクション14）を実装するサーバは、既にUPDATEとUNCHECKOUTセマンティクスを処理するために、BINDのような動作を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Consider a workspace \"/ws1/\", containing the version-controlled, checked-out collections C1 and C2, named \"/ws1/CollX\" and \"/ws1/ CollY\", and a version-controlled resource R, bound to C1 as \"/ws1/ CollX/test\":",
      "ja": "バージョン管理を含む、「/ / WS1」ワークスペースを考慮し、チェックアウトのコレクションC1とC2、「/ WS1 / CollX」という名前で、「/ WS1 / CollY」、およびとしてC1に結合されたバージョン管理されたリソースのR、 \"/ WS1 / CollX /テスト\"："
    },
    {
      "indent": 20,
      "text": "     +-------------------------+\n     | Workspace               |\n     |  bindings:              |\n     |  CollX          CollY   |\n     +-------------------------+\n         |                |\n         |                |\n         |                |\n+---------------+  +---------------+\n| Collection C1 |  | Collection C2 |\n| bindings:     |  |               |\n|     test      |  |               |\n+---------------+  +---------------+\n         |\n         |\n         |\n        +------------------+\n        |    Resource R    |\n        +------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Moving \"/ws1/CollX/test\" into \"/ws1/CollY\", checking in C2, but undoing the checkout on C1 will undo part of the MOVE request, thus restoring the binding from C1 to R, but keeping the new binding from C2 to R:",
      "ja": "こうしてC1からRへの結合を復元するが、より新しいバインディングを維持、「/ WS1 / CollY」に「/ WS1 / CollX /テストを」移動C2にチェックが、移動要求の一部を取り消しますC1にチェックアウトを元に戻しますRへのC2："
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "MOVE /ws1/CollX/test HTTP/1.1 Host: www.example.com Destination: /ws1/CollY/test",
      "ja": "MOVE / WS1 / CollX /テストHTTP / 1.1ホスト：www.example.com先：/ WS1 / CollY /テスト"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>回答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 204 No Content",
      "ja": "HTTP / 1.1 204コンテンツなし"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "CHECKIN /ws1/CollY/ HTTP/1.1 Host: www.example.com",
      "ja": "CHECKIN / WS1 / CollY / HTTP / 1.1ホスト：www.example.com"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>回答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 201 Created Cache-Control: no-cache Location: http://repo.example.com/his/17/ver/42",
      "ja": "HTTP / 1.1 201作成されたのCache-Control：キャッシュなし所在地：http://repo.example.com/his/17/ver/42"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "UNCHECKOUT /ws1/CollX/ HTTP/1.1 Host: www.example.com",
      "ja": "UNCHECKOUT / WS1 / CollX / HTTP / 1.1ホスト：www.example.com"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>回答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK Cache-Control: no-cache",
      "ja": "HTTP / 1.1 200 OKのCache-Control：キャッシュなし"
    },
    {
      "indent": 3,
      "text": "As a result, both C1 and C2 would have a binding to R:",
      "ja": "結果として、C1とC2の両方がRへの結合を有するであろう。"
    },
    {
      "indent": 20,
      "text": "     +-------------------------+\n     | Workspace               |\n     |  bindings:              |\n     |  CollX          CollY   |\n     +-------------------------+\n         |                |\n         |                |\n         |                |\n+---------------+  +---------------+\n| Collection C1 |  | Collection C2 |\n| bindings:     |  | bindings:     |\n|     test      |  |     test      |\n+---------------+  +---------------+\n         |                |\n         |                |\n         |                |\n        +------------------+\n        |    Resource R    |\n        +------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The MOVE semantics defined in Section 3.15 of [RFC3253] already require that \"/ws1/CollX/test\" and \"/ws1/CollY/test\" will have the same version history (as exposed in the DAV:version-history property). Furthermore, the UNCHECKOUT semantics (which in this case is similar to UPDATE, see Section 14.11 of [RFC3253]) require:",
      "ja": "[RFC3253]のセクション3.15で定義されたMOVEセマンティクスが既に（：バージョン履歴性DAVに露出されるように）「/ WS1 / CollX /試験」および「/ WS1 / CollY /テスト」は、同じバージョン履歴を有することを必要とします。また、UNCHECKOUTセマンティクス（この場合における更新と同様である、[RFC3253]のセクション14.11を参照）が必要です。"
    },
    {
      "indent": 6,
      "text": "If a new version-controlled member is in a workspace that already has a version-controlled resource for that version history, then the new version-controlled member MUST be just a binding (i.e., another name for) that existing version-controlled resource.",
      "ja": "新しいバージョンの制御部材は、既にそのバージョン履歴のバージョン管理されたリソースを持っている作業領域にある場合は、新しいバージョンの制御部材は、既存のバージョン管理されたリソースことだけ結合（即ちため、別の名前）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Thus, \"/ws1/CollX/test\" and \"/ws1/CollY/test\" will be bindings to the same resource R, and have identical DAV:resource-id properties.",
      "ja": "したがって、「/ WS1 / CollX /試験」および「/ WS1 / CollY /試験」は、同じリソースRに結合すること、および同じDAVを有するであろう：リソースIDプロパティ。"
    },
    {
      "indent": 0,
      "text": "12. Security Considerations",
      "section_title": true,
      "ja": "12.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section is provided to make WebDAV implementers aware of the security implications of this protocol.",
      "ja": "このセクションでは、このプロトコルのセキュリティへの影響のWebDAVの実装者に認識させるために提供されます。"
    },
    {
      "indent": 3,
      "text": "All of the security considerations of HTTP/1.1 ([RFC2616], Section 15) and the WebDAV Distributed Authoring Protocol specification ([RFC4918], Section 20) also apply to this protocol specification. In addition, bindings introduce several new security concerns and increase the risk of some existing threats. These issues are detailed below.",
      "ja": "HTTP / 1.1のセキュリティ上の考慮事項のすべて（[RFC2616]、セクション15）とWebDAVの分散オーサリングプロトコル仕様（[RFC4918]、セクション20）も、このプロトコル仕様に適用されます。また、バインディングは、いくつかの新しいセキュリティ上の問題を紹介し、いくつかの既存の脅威のリスクを高めます。これらの問題は以下に詳述されています。"
    },
    {
      "indent": 0,
      "text": "12.1. Privacy Concerns",
      "section_title": true,
      "ja": "12.1。プライバシーの問題"
    },
    {
      "indent": 3,
      "text": "In a context where cross-server bindings are supported, creating bindings on a trusted server may make it possible for a hostile agent to induce users to send private information to a target on a different server.",
      "ja": "クロスサーババインディングは敵対的なエージェントが別のサーバー上のターゲットに個人情報を送信するためにユーザーを誘導することが可能になることがあり、信頼できるサーバー上のバインディングを作成し、サポートされている文脈で。"
    },
    {
      "indent": 0,
      "text": "12.2. Bind Loops",
      "section_title": true,
      "ja": "12.2。バインドループ"
    },
    {
      "indent": 3,
      "text": "Although bind loops were already possible in HTTP 1.1, the introduction of the BIND method creates a new avenue for clients to create loops accidentally or maliciously. If the binding and its target are on the same server, the server may be able to detect BIND requests that would create loops. Servers are required to detect loops that are caused by bindings to collections during the processing of any requests with \"Depth: infinity\".",
      "ja": "バインドループはHTTP 1.1で既に可能でしたが、BIND方式の導入は、クライアントが誤って、または悪意を持ってループを作成するための新しい道を作成します。結合し、そのターゲットが同じサーバー上にある場合、サーバーは、ループを作成しBIND要求を検出することができます。サーバは「：無限の深さ」を持つすべてのリクエストの処理中にコレクションにバインディングによって引き起こされるループを検出するために必要とされています。"
    },
    {
      "indent": 0,
      "text": "12.3. Bindings and Denial of Service",
      "section_title": true,
      "ja": "12.3。バインディングおよびサービス拒否"
    },
    {
      "indent": 3,
      "text": "Denial-of-service attacks were already possible by posting URIs that were intended for limited use at heavily used Web sites. The introduction of BIND creates a new avenue for similar denial-of-service attacks. If cross-server bindings are supported, clients can now create bindings at heavily used sites to target locations that were not designed for heavy usage.",
      "ja": "DoS攻撃は、使用頻度の高いWebサイトで限定された使用のために意図されたURIを掲載することにより、既に可能でした。 BINDの導入は、類似したサービス拒否攻撃のための新しい道を作成します。クロスサーバのバインディングがサポートされている場合、クライアントは現在、大量使用のために設計されていない場所をターゲットに使用頻度の高いサイトでバインディングを作成することができます。"
    },
    {
      "indent": 0,
      "text": "12.4. Private Locations May Be Revealed",
      "section_title": true,
      "ja": "12.4。プライベートな場所は明らかにすることができます"
    },
    {
      "indent": 3,
      "text": "If the DAV:parent-set property is maintained on a resource, the owners of the bindings risk revealing private locations. The directory structures where bindings are located are available to anyone who has access to the DAV:parent-set property on the resource. Moving a binding may reveal its new location to anyone with access to DAV:parent-set on its resource.",
      "ja": "DAV場合：親プロパティセットがリソース上で維持され、バインディングの所有者は、プライベートの場所を明らかに危険性があります。リソースの親設定プロパティ：バインディングが配置されているディレクトリ構造は、DAVへのアクセス権を持つすべてのユーザーが利用できます。バインディングを移動すると、DAVへのアクセス権を持つ人には、新しい場所を明らかにすることがあります。そのリソース上の親セット。"
    },
    {
      "indent": 0,
      "text": "12.5. DAV:parent-set and Denial of Service",
      "section_title": true,
      "ja": "12.5。 DAV：親セットおよびサービス拒否"
    },
    {
      "indent": 3,
      "text": "If the server maintains the DAV:parent-set property in response to bindings created in other administrative domains, it is exposed to hostile attempts to make it devote resources to adding bindings to the list.",
      "ja": "サーバはDAVを維持した場合：親設定プロパティを、他の管理ドメインで作成されたバインディングに応じて、それがリストにバインディングを追加することにリソースを割く作るために敵対的な試みにさらされています。"
    },
    {
      "indent": 0,
      "text": "13. Internationalization Considerations",
      "section_title": true,
      "ja": "13.国際化に関する注意事項"
    },
    {
      "indent": 3,
      "text": "All internationalization considerations mentioned in Section 19 of [RFC4918] also apply to this document.",
      "ja": "[RFC4918]のセクション19で述べたすべての国際化の考慮も、この文書に適用されます。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Section 7 defines the HTTP status codes 208 (Already Reported) and 508 (Loop Detected), which have been added to the HTTP Status Code Registry.",
      "ja": "セクション7は、HTTPステータスコードレジストリに追加されたHTTPステータスコード208（既に報告）と508（ループ検出）定義します。"
    },
    {
      "indent": 0,
      "text": "15. Acknowledgements",
      "section_title": true,
      "ja": "15.謝辞"
    },
    {
      "indent": 3,
      "text": "This document is the collaborative product of the authors and Tyson Chihaya, Jim Davis, Chuck Fay and Judith Slein. It has benefited from thoughtful discussion by Jim Amsden, Peter Carlson, Steve Carter, Ken Coar, Ellis Cohen, Dan Connolly, Bruce Cragun, Cyrus Daboo, Spencer Dawkins, Mark Day, Werner Donne, Rajiv Dulepet, David Durand, Lisa Dusseault, Stefan Eissing, Roy Fielding, Yaron Goland, Joe Hildebrand, Fred Hitt, Alex Hopmann, James Hunt, Marcus Jager, Chris Kaler, Manoj Kasichainula, Rohit Khare, Brian Korver, Daniel LaLiberte, Steve Martin, Larry Masinter, Jeff McAffer, Alexey Melnikov, Surendra Koduru Reddy, Max Rible, Sam Ruby, Bradley Sergeant, Nick Shelness, John Stracke, John Tigue, John Turner, Kevin Wiggen, and other members of the concluded WebDAV working group.",
      "ja": "この文書では、著者とタイソン千早、ジム・デイビス、チャック・フェイとジュディスSleinのコラボレーティブな製品です。それはジム・Amsden、ピーター・カールソン、スティーブ・カーター、ケン・コアー、エリス・コーエン、ダン・コノリー、ブルースCragun、サイラスDaboo、スペンサードーキンス、マーク・デイ、ヴェルナー・ダン、ラジブDulepet、デビッド・デュラン、リサDusseault、ステファンで思慮深い議論から恩恵を受けていますEissing、ロイ・フィールディング、ヤロンGoland、ジョー・ヒルデブラント、フレッドHITT、アレックスHopmann、ジェームス・ハント、マーカス・イェーガー、クリスKaler、ManojさんKasichainula、ロフィット・クヘア、ブライアン・コーバー、ダニエル・リベルテ、スティーブ・マーティン、ラリーMasinter、ジェフMcAffer氏、アレクセイ・メルニコフ、スレンドラKoduruレディ、マックスRible、サムルビー、ブラッドリー軍曹、ニックShelness、ジョンStracke、ジョンTigue、ジョン・ターナー、ケビン・Wiggen、と結論付けたのWebDAVワーキンググループの他のメンバー。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16.参考文献"
    },
    {
      "indent": 0,
      "text": "16.1. Normative References",
      "section_title": true,
      "ja": "16.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4918] Dusseault, L., Ed., \"HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)\", RFC 4918, June 2007.",
      "ja": "[RFC4918] Dusseault、L.、エド。、RFC 4918、2007年6月 \"Web分散オーサリングとバージョン管理（WebDAV）のためのHTTP拡張機能\"。"
    },
    {
      "indent": 3,
      "text": "[XML] Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., and F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", W3C REC-xml-20081126, November 2008, <http://www.w3.org/TR/2008/REC-xml-20081126/>.",
      "ja": "[XML]ブレイ、T.、パオリ、J.、Sperberg-マックィーン、C.、MALER、E.、およびF. Yergeau、 \"拡張マークアップ言語（XML）1.0（第5版）\"、W3C REC-XML-20081126 2008年11月、<http://www.w3.org/TR/2008/REC-xml-20081126/>。"
    },
    {
      "indent": 0,
      "text": "16.2. Informative References",
      "section_title": true,
      "ja": "16.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC3253] Clemm, G., Amsden, J., Ellison, T., Kaler, C., and J. Whitehead, \"Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)\", RFC 3253, March 2002.",
      "ja": "[RFC3253] Clemm、G.、Amsden、J.、エリソン、T.、Kaler、C.、およびJ.ホワイトヘッド \"のWebDAV（Web分散オーサリングとバージョン）のバージョンの拡張\"、RFC 3253、2002年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3744] Clemm, G., Reschke, J., Sedlar, E., and J. Whitehead, \"Web Distributed Authoring and Versioning (WebDAV) Access Control Protocol\", RFC 3744, May 2004.",
      "ja": "[RFC3744] Clemm、G.、Reschke、J.、Sedlar、E.、およびJ.ホワイトヘッド、 \"Web分散オーサリングとバージョン管理（WebDAV）アクセス制御プロトコル\"、RFC 3744、2004年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4122] Leach, P., Mealling, M., and R. Salz, \"A Universally Unique IDentifier (UUID) URN Namespace\", RFC 4122, July 2005.",
      "ja": "[RFC4122]リーチ、P.、Mealling、M.、およびR. Salzの、 \"汎用一意識別子（UUID）URN名前空間\"、RFC 4122、2005年7月。"
    },
    {
      "indent": 0,
      "text": "Index",
      "ja": "指数"
    },
    {
      "indent": 3,
      "text": "2 208 Already Reported (status code) 31, 41",
      "ja": "2 208すでに報告（状態コード）31、41"
    },
    {
      "indent": 3,
      "text": "5 508 Loop Detected (status code) 34, 41",
      "ja": "5 508ループ検出（ステータスコード）34、41"
    },
    {
      "indent": 3,
      "text": "B BIND method 21 Marshalling 22 Postconditions 23 Preconditions 22 Binding 6 Binding Integrity 6-7, 21",
      "ja": "6結合整合6-7、21バインディングBのBIND法21のマーシャリング22事後条件23の前提条件22"
    },
    {
      "indent": 3,
      "text": "C Collection 6 Condition Names DAV:bind-into-collection (pre) 22 DAV:bind-source-exists (pre) 22 DAV:binding-allowed (pre) 23 DAV:binding-deleted (post) 25, 28 DAV:can-overwrite (pre) 23, 27 DAV:cross-server-binding (pre) 23, 27",
      "ja": "Cコレクション6条件名DAV：バインドに-コレクション（前）22 DAV：バインド・ソースが存在する（前）22 DAV：結合-許可（前）23 DAV：-削除バインディング（ポスト）25、28 DAV：CAN -overwrite（予備）23、27 DAV：クロスサーバ結合（予備）23、27"
    },
    {
      "indent": 9,
      "text": "DAV:cycle-allowed (pre)  23, 27\nDAV:lock-deleted (post)  25, 28\nDAV:locked-overwrite-allowed (pre)  23\nDAV:locked-source-collection-update-allowed (pre)  28\nDAV:locked-update-allowed (pre)  23, 25, 27\nDAV:name-allowed (pre)  23, 27\nDAV:new-binding (post)  23, 28\nDAV:protected-source-url-deletion-allowed (pre)  28\nDAV:protected-url-deletion-allowed (pre)  25\nDAV:protected-url-modification-allowed (pre)  27\nDAV:rebind-into-collection (pre)  27\nDAV:rebind-source-exists (pre)  27\nDAV:unbind-from-collection (pre)  25\nDAV:unbind-source-exists (pre)  25",
      "raw": true
    },
    {
      "indent": 3,
      "text": "D DAV header compliance class 'bind' 34 DAV:bind-into-collection precondition 22 DAV:bind-source-exists precondition 22 DAV:binding-allowed precondition 23 DAV:binding-deleted postcondition 25, 28 DAV:can-overwrite precondition 23, 27 DAV:cross-server-binding precondition 23, 27 DAV:cycle-allowed precondition 23, 27 DAV:lock-deleted postcondition 25, 28 DAV:locked-overwrite-allowed precondition 23 DAV:locked-source-collection-update-allowed precondition 28 DAV:locked-update-allowed precondition 23, 25, 27 DAV:name-allowed precondition 23, 27 DAV:new-binding postcondition 23, 28 DAV:parent-set property 20 DAV:protected-source-url-deletion-allowed precondition 28 DAV:protected-url-deletion-allowed precondition 25 DAV:protected-url-modification-allowed precondition 27 DAV:rebind-into-collection precondition 27 DAV:rebind-source-exists precondition 27 DAV:resource-id property 19 DAV:unbind-from-collection precondition 25 DAV:unbind-source-exists precondition 25",
      "ja": "D DAVヘッダコンプライアンスクラス 'バインド' 34 DAV：バインドに収集前提条件22 DAV：結合せ前提条件23 DAV：結合削除事後25、28 DAV：CAN-上書き前提条件23前提条件22 DAVをバインドソースは、存在します、27 DAV：クロスサーバ結合前提23、27 DAV：サイクル許容前提23、27 DAV：ロック削除事後25、28 DAV：ロック上書き許容前提23 DAV：ロック・ソース・コレクションupdate-許可の前提条件28 DAV：ロック・更新許可の前提条件23、25、27 DAV：名前、許可の前提条件23、27 DAV：新結合事後条件23、28 DAV：親設定プロパティ20 DAV：保護された-source-urlに、削除-allowed前提条件28 DAV：保護されたURL-削除-許可の前提条件25 DAV：保護されたURL  - 修正 - 許可の前提条件27 DAV：再バインド-に収集前提条件27 DAV：リソース-idプロパティ：前提条件27 DAVを再バインド・ソースは、存在します19 DAV：アンバインド-から収集前提25 DAV：前提条件25をアンバインド・ソースは、存在"
    },
    {
      "indent": 3,
      "text": "I Internal Member URI 6",
      "ja": "I内部メンバーURI 6"
    },
    {
      "indent": 3,
      "text": "L Locking 35",
      "ja": "L 35のロック"
    },
    {
      "indent": 3,
      "text": "M Methods BIND 21 REBIND 26 UNBIND 24",
      "ja": "M方法BIND 21 REBIND 26 UNBIND 24"
    },
    {
      "indent": 3,
      "text": "P Path Segment 5 Properties DAV:parent-set 20 DAV:resource-id 19",
      "ja": "Pパスセグメント5プロパティDAV：親セット20 DAV：リソース-ID 19"
    },
    {
      "indent": 3,
      "text": "R REBIND method 26 Marshalling 26 Postconditions 28 Preconditions 27",
      "ja": "R再バインド方法26マーシャリング26の事後条件28前提条件27"
    },
    {
      "indent": 3,
      "text": "S Status Codes 208 Already Reported 31, 41 508 Loop Detected 34, 41",
      "ja": "208はすでに31、41 508ループ34、41を検出し報告Sステータスコード"
    },
    {
      "indent": 3,
      "text": "U UNBIND method 24 Marshalling 24 Postconditions 25 Preconditions 25 URI Mapping 5",
      "ja": "U UNBIND方法24マーシャリング24の事後条件25の前提25 URIマッピング5"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Geoffrey Clemm IBM 550 King Street Littleton, MA 01460",
      "ja": "ジェフリー・Clemm IBM 550キングストリートリトルトン、MA 01460"
    },
    {
      "indent": 3,
      "text": "EMail: geoffrey.clemm@us.ibm.com",
      "ja": "メールアドレス：geoffrey.clemm@us.ibm.com"
    },
    {
      "indent": 3,
      "text": "Jason Crawford IBM Research P.O. Box 704 Yorktown Heights, NY 10598",
      "ja": "ジェイソン・クロフォードIBMリサーチ私書箱ボックス704ヨークタウンハイツ、NY 10598"
    },
    {
      "indent": 3,
      "text": "EMail: ccjason@us.ibm.com",
      "ja": "メールアドレス：ccjason@us.ibm.com"
    },
    {
      "indent": 3,
      "text": "Julian F. Reschke (editor) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 Germany",
      "ja": "ジュリアンF. Reschke（エディタ）greenbytes社Hafenweg 16ミュンスター、NW 48155ドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: julian.reschke@greenbytes.de",
      "ja": "メールアドレス：julian.reschke@greenbytes.de"
    },
    {
      "indent": 3,
      "text": "Jim Whitehead UC Santa Cruz, Dept. of Computer Science 1156 High Street Santa Cruz, CA 95064",
      "ja": "ジム・ホワイトヘッドUCサンタクルス、コンピュータサイエンス学科1156ハイストリートサンタクルス、CA 95064"
    },
    {
      "indent": 3,
      "text": "EMail: ejw@cse.ucsc.edu",
      "ja": "メールアドレス：ejw@cse.ucsc.edu"
    }
  ]
}