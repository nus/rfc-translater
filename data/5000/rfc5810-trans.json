{
  "title": {
    "text": "RFC 5810 - Forwarding and Control Element Separation (ForCES) Protocol Specification",
    "ja": "RFC 5810 - 転送と制御素子分離（のForCES）プロトコル仕様"
  },
  "number": 5810,
  "created_at": "2019-10-29 06:13:15.488631+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     A. Doria, Ed.\nRequest for Comments: 5810                Lulea University of Technology\nCategory: Standards Track                             J. Hadi Salim, Ed.\nISSN: 2070-1721                                                     Znyx\n                                                            R. Haas, Ed.\n                                                                     IBM\n                                                        H. Khosravi, Ed.\n                                                                   Intel\n                                                            W. Wang, Ed.\n                                                                 L. Dong\n                                           Zhejiang Gongshang University\n                                                                R. Gopal\n                                                                   Nokia\n                                                              J. Halpern\n                                                              March 2010",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Forwarding and Control Element Separation (ForCES)\n              Protocol Specification",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies the Forwarding and Control Element Separation (ForCES) protocol. The ForCES protocol is used for communications between Control Elements(CEs) and Forwarding Elements (FEs) in a ForCES Network Element (ForCES NE). This specification is intended to meet the ForCES protocol requirements defined in RFC 3654. Besides the ForCES protocol, this specification also defines the requirements for the Transport Mapping Layer (TML).",
      "ja": "この文書では、転送と制御素子分離（のForCES）プロトコルを指定します。 ForCESプロトコルは、のForCESネットワーク要素（NEのForCES）における制御要素（CES）および転送要素（FE）との間の通信のために使用されます。この仕様は、のForCESプロトコルに加えRFC 3654.に定義されているのForCESプロトコル要件を満たすように意図され、本明細書はまた、トランスポート・マッピング・レイヤー（TML）のための要件を定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5810.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc5810で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2010 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n2. Terminology and Conventions .....................................6\n   2.1. Requirements Language ......................................6\n   2.2. Other Notation .............................................6\n   2.3. Integers ...................................................6\n3. Definitions .....................................................6\n4. Overview .......................................................10\n   4.1. Protocol Framework ........................................11\n        4.1.1. The PL .............................................13\n        4.1.2. The TML ............................................14\n        4.1.3. The FEM/CEM Interface ..............................14\n   4.2. ForCES Protocol Phases ....................................15\n        4.2.1. Pre-association ....................................16\n        4.2.2. Post-association ...................................18\n   4.3. Protocol Mechanisms .......................................19\n        4.3.1. Transactions, Atomicity, Execution, and Responses ..19\n        4.3.2. Scalability ........................................25\n        4.3.3. Heartbeat Mechanism ................................26\n        4.3.4. FE Object and FE Protocol LFBs .....................27\n   4.4. Protocol Scenarios ........................................27\n        4.4.1. Association Setup State ............................27\n        4.4.2. Association Established State or Steady State ......29\n5. TML Requirements ...............................................31\n   5.1. TML Parameterization ......................................34\n6. Message Encapsulation ..........................................35\n   6.1. Common Header .............................................35\n   6.2. Type Length Value (TLV) Structuring .......................40\n        6.2.1. Nested TLVs ........................................41\n        6.2.2. Scope of the T in TLV ..............................41\n   6.3. ILV .......................................................41\n   6.4. Important Protocol Encapsulations .........................42\n        6.4.1. Paths ..............................................42\n        6.4.2. Keys ...............................................42\n        6.4.3. DATA TLVs ..........................................43\n        6.4.4. Addressing LFB Entities ............................43\n7. Protocol Construction ..........................................44\n   7.1. Discussion on Encoding ....................................48\n        7.1.1. Data Packing Rules .................................48\n        7.1.2. Path Flags .........................................49\n        7.1.3. Relation of Operational Flags with Global\n               Message Flags ......................................49\n        7.1.4. Content Path Selection .............................49\n        7.1.5. LFBselect-TLV ......................................49\n        7.1.6. OPER-TLV ...........................................50\n        7.1.7. RESULT TLV .........................................52\n        7.1.8. DATA TLV ...........................................55",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        7.1.9. SET and GET Relationship ...........................56\n   7.2. Protocol Encoding Visualization ...........................56\n   7.3. Core ForCES LFBs ..........................................59\n        7.3.1. FE Protocol LFB ....................................60\n        7.3.2. FE Object LFB ......................................63\n   7.4. Semantics of Message Direction ............................63\n   7.5. Association Messages ......................................64\n        7.5.1. Association Setup Message ..........................64\n        7.5.2. Association Setup Response Message .................66\n        7.5.3. Association Teardown Message .......................68\n   7.6. Configuration Messages ....................................69\n        7.6.1. Config Message .....................................69\n        7.6.2. Config Response Message ............................71\n   7.7. Query Messages ............................................73\n        7.7.1. Query Message ......................................73\n        7.7.2. Query Response Message .............................75\n   7.8. Event Notification Message ................................77\n   7.9. Packet Redirect Message ...................................79\n   7.10. Heartbeat Message ........................................82\n8. High Availability Support ......................................83\n   8.1. Relation with the FE Protocol .............................83\n   8.2. Responsibilities for HA ...................................86\n9. Security Considerations ........................................87\n   9.1. No Security ...............................................87\n        9.1.1. Endpoint Authentication ............................88\n        9.1.2. Message Authentication .............................88\n   9.2. ForCES PL and TML Security Service ........................88\n        9.2.1. Endpoint Authentication Service ....................88\n        9.2.2. Message Authentication Service .....................89\n        9.2.3. Confidentiality Service ............................89\n10. Acknowledgments ...............................................89\n11. References ....................................................89\n   11.1. Normative References .....................................89\n   11.2. Informative References ...................................90\nAppendix A.  IANA Considerations ..................................91\n  A.1.  Message Type Namespace ....................................91\n  A.2.  Operation Selection .......................................92\n  A.3.  Header Flags ..............................................93\n  A.4.  TLV Type Namespace ........................................93\n  A.5.  RESULT-TLV Result Values ..................................94\n  A.6.  Association Setup Response ................................94\n  A.7.  Association Teardown Message ..............................95\nAppendix B.  ForCES Protocol LFB Schema ...........................96\n  B.1.  Capabilities .............................................102\n  B.2.  Components ...............................................102\nAppendix C.  Data Encoding Examples ..............................103\nAppendix D.  Use Cases ...........................................107",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Forwarding and Control Element Separation (ForCES) defines an architectural framework and associated protocols to standardize information exchange between the control plane and the forwarding plane in a ForCES Network Element (ForCES NE). RFC 3654 has defined the ForCES requirements, and RFC 3746 has defined the ForCES framework. While there may be multiple protocols used within the overall ForCES architecture, the terms \"ForCES protocol\" and \"protocol\" as used in this document refer to the protocol used to standardize the information exchange between Control Elements (CEs) and Forwarding Elements (FEs) only.",
      "ja": "転送と制御素子分離（力が）アーキテクチャフレームワークを定義し、関連プロトコルするのForCESネットワーク要素（NEのForCES）における制御プレーンと転送プレーン間の情報交換を標準化します。 RFC 3654は、のForCESの要件を定義しており、およびRFC 3746のForCESフレームワークを定義しています。全体のForCESアーキテクチャ内で使用される複数のプロトコルが存在してもよいが、本文書で使用される用語「のForCESプロトコル」および「プロトコル」は、制御要素（CES）および転送要素（FE）との間の情報交換を標準化するために使用されるプロトコルを参照しますのみ。"
    },
    {
      "indent": 3,
      "text": "The ForCES FE model [RFC5812] presents a formal way to define FE Logical Function Blocks (LFBs) using XML. LFB configuration components, capabilities, and associated events are defined when the LFB is formally created. The LFBs within the FE are accordingly controlled in a standardized way by the ForCES protocol.",
      "ja": "ForCES FEモデル[RFC5812]はXMLを使用してFEの論理機能ブロック（LFBs）を定義するための正式な方法を提示しています。 LFBが正式に作成されたときLFB構成コンポーネント、機能、および関連するイベントが定義されています。 FE内LFBsそれに応じのForCESプロトコルによって標準化された方法で制御されます。"
    },
    {
      "indent": 3,
      "text": "This document defines the ForCES protocol specifications. The ForCES protocol works in a master-slave mode in which FEs are slaves and CEs are masters. The protocol includes commands for transport of LFB configuration information, association setup, status, event notifications, etc.",
      "ja": "この文書はのForCESプロトコルの仕様を定義します。 FEは、スレーブおよびCEされたマスタ・スレーブモードの力プロトコル作品がマスターです。プロトコルは、LFB構成情報、関連設定、状態、イベント通知、等の輸送のためのコマンドを含みます"
    },
    {
      "indent": 3,
      "text": "Section 3 provides a glossary of terminology used in the specification.",
      "ja": "セクション3は、本明細書で使用される用語の用語集を提供します。"
    },
    {
      "indent": 3,
      "text": "Section 4 provides an overview of the protocol, including a discussion on the protocol framework and descriptions of the Protocol Layer (PL), a Transport Mapping Layer (TML), and the ForCES protocol mechanisms. Section 4.4 describes several protocol scenarios and includes message exchange descriptions.",
      "ja": "セクション4は、プロトコル・フレームワークとプロトコルレイヤ（PL）、トランスポート・マッピング・レイヤー（TML）、強制的プロトコルメカニズムの記述に関する議論を含むプロトコルの概要を提供します。セクション4.4は、いくつかのプロトコル・シナリオについて説明し、メッセージ交換の説明を含みます。"
    },
    {
      "indent": 3,
      "text": "While this document does not define the TML, Section 5 details the services that a TML MUST provide (TML requirements).",
      "ja": "この文書はTMLを定義していませんが、第5節では、TMLは（TML要件）を提供しなければならないサービスを詳述します。"
    },
    {
      "indent": 3,
      "text": "The ForCES protocol defines a common header for all protocol messages. The header is defined in Section 6.1, while the protocol messages are defined in Section 7.",
      "ja": "ForCESプロトコルは、すべてのプロトコルメッセージの共通ヘッダを定義します。プロトコルメッセージは、セクション7で定義されている間ヘッダは、セクション6.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "Section 8 describes the protocol support for high-availability mechanisms including redundancy and fail over.",
      "ja": "セクション8は、冗長性およびフェイルオーバーなどの高可用性機構のプロトコルのサポートが記載されています。"
    },
    {
      "indent": 3,
      "text": "Section 9 defines the security mechanisms provided by the PL and TML.",
      "ja": "セクション9は、PLとTMLによって提供されるセキュリティメカニズムを定義します。"
    },
    {
      "indent": 0,
      "text": "2. Terminology and Conventions",
      "section_title": true,
      "ja": "2.用語と表記"
    },
    {
      "indent": 0,
      "text": "2.1. Requirements Language",
      "section_title": true,
      "ja": "2.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Other Notation",
      "section_title": true,
      "ja": "2.2. その他の記法"
    },
    {
      "indent": 3,
      "text": "In Table 1 and Table 2, the following notation is used to indicate multiplicity:",
      "ja": "表1及び表2に、以下の表記が多数を示すために使用されます。"
    },
    {
      "indent": 6,
      "text": "(value)+ .... means \"1 or more instances of value\"",
      "ja": "（値）+ ....「値の1つの以上のインスタンス」を意味します"
    },
    {
      "indent": 6,
      "text": "(value)* .... means \"0 or more instances of value\"",
      "ja": "（値）* ...「の値の0以上のインスタンス」を意味します"
    },
    {
      "indent": 0,
      "text": "2.3. Integers",
      "section_title": true,
      "ja": "2.3. 整数"
    },
    {
      "indent": 3,
      "text": "All integers are to be coded as unsigned binary integers of appropriate length.",
      "ja": "すべての整数は、適切な長さの符号なし2進整数として符号化されるべきです。"
    },
    {
      "indent": 0,
      "text": "3. Definitions",
      "section_title": true,
      "ja": "3.定義"
    },
    {
      "indent": 3,
      "text": "This document follows the terminology defined by the ForCES requirements in [RFC3654] and by the ForCES framework in [RFC3746]. The definitions be are repeated below for clarity.",
      "ja": "このドキュメントは[RFC3654]の力の要件によって、および[RFC3746]の力フレームワークによって定義された用語を以下。定義は明確にするため、以下の反復されること。"
    },
    {
      "indent": 3,
      "text": "Addressable Entity (AE):",
      "ja": "アドレス指定可能なエンティティ（AE）："
    },
    {
      "indent": 3,
      "text": "A physical device that is directly addressable given some interconnect technology. For example, on IP networks, it is a device that can be reached using an IP address; and on a switch fabric, it is a device that can be reached using a switch fabric port number.",
      "ja": "いくつかの相互接続技術与えられた直接アドレスである物理デバイス。例えば、IPネットワーク上では、IPアドレスを使用して到達することができる装置です。スイッチファブリックには、スイッチファブリックのポート番号を使用して到達することができる装置です。"
    },
    {
      "indent": 3,
      "text": "Control Element (CE):",
      "ja": "制御要素（CE）"
    },
    {
      "indent": 3,
      "text": "A logical entity that implements the ForCES protocol and uses it to instruct one or more FEs on how to process packets. CEs handle functionality such as the execution of control and signaling protocols.",
      "ja": "ForCESのプロトコルを実装しパケットを処理する方法の一の以上のFEを指示するためにそれを使用する論理エンティティ。 CEは、このような制御およびシグナリングプロトコルの実行などの機能を扱います。"
    },
    {
      "indent": 3,
      "text": "CE Manager (CEM):",
      "ja": "ECマネージャ（CEM）"
    },
    {
      "indent": 3,
      "text": "A logical entity responsible for generic CE management tasks. It is particularly used during the pre-association phase to determine with which FE(s) a CE should communicate. This process is called FE discovery and may involve the CE manager learning the capabilities of available FEs.",
      "ja": "一般的なCEの管理タスクを担当する論理エンティティ。特にれるFE（S）CEは、通信すべきかを決定するために予め関連付け段階中に使用されます。このプロセスは、FEの発見と呼ばれ、利用できるのFEの機能を学習CEマネージャを含むことができます。"
    },
    {
      "indent": 3,
      "text": "Data Path:",
      "ja": "データ経路："
    },
    {
      "indent": 3,
      "text": "A conceptual path taken by packets within the forwarding plane inside an FE.",
      "ja": "FE内部転送プレーン内のパケットによって取ら概念パス。"
    },
    {
      "indent": 3,
      "text": "Forwarding Element (FE):",
      "ja": "転送要素（FE）："
    },
    {
      "indent": 3,
      "text": "A logical entity that implements the ForCES protocol. FEs use the underlying hardware to provide per-packet processing and handling as directed/controlled by one or more CEs via the ForCES protocol.",
      "ja": "ForCESプロトコルを実装する論理エンティティ。 FEは、のForCESプロトコルを介して1つのまたは複数のCEによって制御/指示されるように、パケット単位の処理および取り扱いを提供するために、基礎となるハードウェアを使用します。"
    },
    {
      "indent": 3,
      "text": "FE Model:",
      "ja": "モデルでは："
    },
    {
      "indent": 3,
      "text": "A model that describes the logical processing functions of an FE. The FE model is defined using Logical Function Blocks (LFBs).",
      "ja": "FEの論理的な処理機能を記述するモデル。 FEモデルは、論理機能ブロック（LFBs）を使用して定義されます。"
    },
    {
      "indent": 3,
      "text": "FE Manager (FEM):",
      "ja": "FEマネージャー（FEM）："
    },
    {
      "indent": 3,
      "text": "A logical entity responsible for generic FE management tasks. It is used during the pre-association phase to determine with which CE(s) an FE should communicate. This process is called CE discovery and may involve the FE manager learning the capabilities of available CEs. An FE manager may use anything from a static configuration to a pre-association phase protocol (see below) to determine which CE(s) to use. Being a logical entity, an FE manager might be physically combined with any of the other logical entities such as FEs.",
      "ja": "一般的なFE管理タスクを担当する論理エンティティ。 CE（S）FEが通信すべきであると決定するために、事前関連付け段階中に使用されます。このプロセスは、CEの発見と呼ばれ、利用可能なCEの機能を学習FEマネージャを含むことができます。 FEマネージャが使用するCE（S）を決定するために（下記参照）プレ会合相プロトコル静的構成のものを用いることができます。論理エンティティである、FEマネージャは、物理的に複数のFEのような他の論理エンティティのいずれかと組み合わせることがあります。"
    },
    {
      "indent": 3,
      "text": "ForCES Network Element (NE):",
      "ja": "ForCESネットワーク要素（NE）："
    },
    {
      "indent": 3,
      "text": "An entity composed of one or more CEs and one or more FEs. To entities outside an NE, the NE represents a single point of management. Similarly, an NE usually hides its internal organization from external entities.",
      "ja": "エンティティは、1つまたは複数のCEと一の以上のFEで構成される。 NE外のエンティティに、NEは、単一の管理ポイントを表します。同様に、NEは、通常、外部エンティティからその内部組織を隠します。"
    },
    {
      "indent": 3,
      "text": "High Touch Capability:",
      "ja": "ハイタッチ機能："
    },
    {
      "indent": 3,
      "text": "This term will be used to apply to the capabilities found in some forwarders to take action on the contents or headers of a packet based on content other than what is found in the IP header. Examples of these capabilities include quality of service (QoS) policies, virtual private networks, firewall, and L7 content recognition.",
      "ja": "この用語は、IPヘッダーで見つかっているもの以外のコンテンツに基づいて、パケットの内容やヘッダに対してアクションを取るために、いくつかのフォワーダーで見つかった機能に適用するために使用されます。これらの機能の例としては、サービス品質（QoS）ポリシー、仮想プライベートネットワーク、ファイアウォール、およびL7コンテンツの認識が含まれます。"
    },
    {
      "indent": 3,
      "text": "Inter-FE Topology:",
      "ja": "インター-FEトポロジ："
    },
    {
      "indent": 3,
      "text": "See FE Topology.",
      "ja": "FEトポロジを参照してください。"
    },
    {
      "indent": 3,
      "text": "Intra-FE Topology:",
      "ja": "イントラFEトポロジ："
    },
    {
      "indent": 3,
      "text": "See LFB Topology.",
      "ja": "LFBトポロジを参照してください。"
    },
    {
      "indent": 3,
      "text": "LFB (Logical Function Block):",
      "ja": "LFB（論理機能ブロック）："
    },
    {
      "indent": 3,
      "text": "The basic building block that is operated on by the ForCES protocol. The LFB is a well-defined, logically separable functional block that resides in an FE and is controlled by the CE via the ForCES protocol. The LFB may reside at the FE's data path and process packets or may be purely an FE control or configuration entity that is operated on by the CE. Note that the LFB is a functionally accurate abstraction of the FE's processing capabilities, but not a hardware-accurate representation of the FE implementation.",
      "ja": "ForCESプロトコルによって操作された基本的なビルディングブロック。 LFBはFEに存在する、強制的プロトコルを介してCEによって制御され、明確に定義され、論理的に分離可能な機能ブロックです。 LFBはFEのデータパスおよびプロセスパケットに存在し得るか、または純粋にCEによって操作されたFE制御または構成エンティティであってもよいです。 LFBは、機能的に正確なFEの処理能力の抽象化ではなく、FE実装のハードウェア、正確な表現であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "FE Topology:",
      "ja": "トポロジカルには："
    },
    {
      "indent": 3,
      "text": "A representation of how the multiple FEs within a single NE are interconnected. Sometimes this is called inter-FE topology, to be distinguished from intra-FE topology (i.e., LFB topology).",
      "ja": "単一NE内の複数のFEが相互接続されているかの表現。時にはこれは、イントラFEトポロジ（すなわち、LFBトポロジー）と区別するために、インターFEトポロジと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "LFB Class and LFB Instance:",
      "ja": "LFBクラスとLFBインスタンス："
    },
    {
      "indent": 3,
      "text": "LFBs are categorized by LFB classes. An LFB instance represents an LFB class (or type) existence. There may be multiple instances of the same LFB class (or type) in an FE. An LFB class is represented by an LFB class ID, and an LFB instance is represented by an LFB instance ID. As a result, an LFB class ID associated with an LFB instance ID uniquely specifies an LFB existence.",
      "ja": "LFBsはLFBクラスによって分類されています。 LFBインスタンスは、LFBのクラス（またはタイプ）が存在することを表します。 FEに同じLFBクラス（またはタイプ）の複数のインスタンスが存在してもよいです。 LFBクラスはLFBクラスIDによって表され、LFBインスタンスはLFBインスタンスIDによって表されます。結果として、LFBインスタンスIDに関連付けられたLFBクラスIDは一意にLFBの存在を特定します。"
    },
    {
      "indent": 3,
      "text": "LFB Meta Data:",
      "ja": "LFBメタデータ："
    },
    {
      "indent": 3,
      "text": "Meta data is used to communicate per-packet state from one LFB to another, but is not sent across the network. The FE model defines how such meta data is identified, produced, and consumed by the LFBs. It defines the functionality but not how meta data is encoded within an implementation.",
      "ja": "メタデータは、別のLFBからパケット単位の状態を通信するために使用されるが、ネットワークを介して送信されていません。 FEモデルは、メタデータは、識別された生成、及びLFBsによって消費される方法を定義します。これは、機能を定義ではなく、どのようにメタデータは、実装内でエンコードされます。"
    },
    {
      "indent": 3,
      "text": "LFB Component:",
      "ja": "LFBコンポーネント："
    },
    {
      "indent": 3,
      "text": "Operational parameters of the LFBs that must be visible to the CEs are conceptualized in the FE model as the LFB components. The LFB components include, for example, flags, single parameter arguments, complex arguments, and tables that the CE can read and/or write via the ForCES protocol (see below).",
      "ja": "CEに見えなければならないLFBsの動作パラメータは、LFB成分としてFEモデルで概念化されます。 LFB成分（下記参照）、例えば、フラグ、単一のパラメータ、引数、複雑な引数、及びCEは、読み取り及び/又はのForCESプロトコルを介して書き込むことができるテーブルを含みます。"
    },
    {
      "indent": 3,
      "text": "LFB Topology:",
      "ja": "LFBトポロジ："
    },
    {
      "indent": 3,
      "text": "Representation of how the LFB instances are logically interconnected and placed along the data path within one FE. Sometimes it is also called intra-FE topology, to be distinguished from inter-FE topology.",
      "ja": "LFBインスタンスが論理的に相互接続し、1 FE内のデータ・パスに沿って配置されているかの表現。時にはまた、インター-FEトポロジと区別するために、内-FEトポロジと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Pre-association Phase:",
      "ja": "事前会合フェーズ："
    },
    {
      "indent": 3,
      "text": "The period of time during which an FE manager and a CE manager are determining which FE(s) and CE(s) should be part of the same network element.",
      "ja": "FEマネージャとCEマネージャがFE（S）およびCE（S）が同じネットワーク要素の一部であるべきかを決定される期間。"
    },
    {
      "indent": 3,
      "text": "Post-association Phase:",
      "ja": "ポスト関連フェーズ："
    },
    {
      "indent": 3,
      "text": "The period of time during which an FE knows which CE is to control it and vice versa. This includes the time during which the CE and FE are establishing communication with one another.",
      "ja": "FEは、CEは、それおよびその逆を制御することである知っている期間。これは、CEとFEが互いに通信を確立する時間を含みます。"
    },
    {
      "indent": 3,
      "text": "ForCES Protocol:",
      "ja": "ForCESプロトコル："
    },
    {
      "indent": 3,
      "text": "While there may be multiple protocols used within the overall ForCES architecture, the terms \"ForCES protocol\" and \"protocol\" refer to the Fp reference points in the ForCES framework in [RFC3746]. This protocol does not apply to CE-to-CE communication, FE-to-FE communication, or communication between FE and CE managers. Basically, the ForCES protocol works in a master-slave mode in which FEs are slaves and CEs are masters. This document defines the specifications for this ForCES protocol.",
      "ja": "全体のForCESアーキテクチャ内で使用される複数のプロトコルが存在してもよいが、用語「のForCESプロトコル」および「プロトコル」は、[RFC3746]の力の枠組みの中のFP基準点を指します。このプロトコルは、CE-に-CE通信、FE-に-FE通信、またはFEとCEマネージャ間の通信には適用されません。基本的に、複数のFEは、スレーブおよびCEされたマスタ・スレーブモードの力プロトコル作品はマスターです。この文書では、こののForCESプロトコルの仕様を定義します。"
    },
    {
      "indent": 3,
      "text": "ForCES Protocol Layer (ForCES PL):",
      "ja": "ForCESプロトコルレイヤ（のForCES PL）："
    },
    {
      "indent": 3,
      "text": "A layer in the ForCES protocol architecture that defines the ForCES protocol messages, the protocol state transfer scheme, and the ForCES protocol architecture itself (including requirements of ForCES TML as shown below). Specifications of ForCES PL are defined by this document.",
      "ja": "ForCESプロトコルメッセージ、プロトコル状態転送方式、及び（以下に示すようのForCES TMLの要件を含む）のForCESプロトコルアーキテクチャ自体を定義するのForCESプロトコルアーキテクチャのレイヤ。 ForCES PLの仕様は、この文書で定義されています。"
    },
    {
      "indent": 3,
      "text": "ForCES Protocol Transport Mapping Layer (ForCES TML):",
      "ja": "ForCESプロトコルトランスポートマッピング・レイヤー（のForCES TML）："
    },
    {
      "indent": 3,
      "text": "A layer in ForCES protocol architecture that uses the capabilities of existing transport protocols to specifically address protocol message transportation issues, such as how the protocol messages are mapped to different transport media (like TCP, IP, ATM, Ethernet, etc.), and how to achieve and implement reliability, multicast, ordering, etc. The ForCES TML specifications are detailed in separate ForCES documents, one for each TML.",
      "ja": "具体的には（等TCP、IP、ATM、イーサネット（登録商標）、など）そのようなプロトコル・メッセージは、異なる輸送媒体にマッピングされる方法のようなプロトコル・メッセージの輸送の問題に対処するために、既存のトランスポートプロトコルの機能を使用するのForCESプロトコルアーキテクチャのレイヤ、及び方法など、実現性と信頼性を実現する、マルチキャスト、発注に力TMLの仕様は、別のForCES文書、各TMLのための1で詳述されています。"
    },
    {
      "indent": 0,
      "text": "4. Overview",
      "section_title": true,
      "ja": "4.概要"
    },
    {
      "indent": 3,
      "text": "The reader is referred to the framework document [RFC3746], and in particular, Sections 3 and 4, for an architectural overview and an explanation of how the ForCES protocol fits in. There may be some content overlap between the framework document and this section in order to provide clarity. This document is authoritative on the protocol, whereas [RFC3746] is authoritative on the architecture.",
      "ja": "読者は、フレームワーク文書[RFC3746]と呼ばれ、特に、アーキテクチャの概要、強制的プロトコルに適合させる方法を説明するためのセクション3と4は、フレームワーク文書とこのセクションの間の一部のコンテンツの重複があるかもしれません明瞭さを提供するため。 [RFC3746]はアーキテクチャ上の権威であるのに対し、この文書は、プロトコルに権威あります。"
    },
    {
      "indent": 0,
      "text": "4.1. Protocol Framework",
      "section_title": true,
      "ja": "4.1. プロトコルフレームワーク"
    },
    {
      "indent": 3,
      "text": "Figure 1 below is reproduced from the framework document for clarity. It shows an NE with two CEs and two FEs.",
      "ja": "以下の図1は、明確化のためのフレームワーク文書から再生されます。これは、2つのCEおよび2つのFEとNEを示しています。"
    },
    {
      "indent": 5,
      "text": "                       ---------------------------------------\n                       | ForCES Network Element              |\n--------------   Fc    | --------------      --------------  |\n| CE Manager |---------+-|     CE 1   |------|    CE 2    |  |\n--------------         | |            |  Fr  |            |  |\n      |                | --------------      --------------  |\n      | Fl             |         |  |    Fp       /          |\n      |                |       Fp|  |----------| /           |\n      |                |         |             |/            |\n      |                |         |             |             |\n      |                |         |     Fp     /|----|        |\n      |                |         |  /--------/      |        |\n--------------     Ff  | --------------      --------------  |\n| FE Manager |---------+-|     FE 1   |  Fi  |     FE 2   |  |\n--------------         | |            |------|            |  |\n                       | --------------      --------------  |\n                       |   |  |  |  |          |  |  |  |    |\n                       ----+--+--+--+----------+--+--+--+-----\n                           |  |  |  |          |  |  |  |\n                           |  |  |  |          |  |  |  |\n                             Fi/f                   Fi/f",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Fp: CE-FE interface\nFi: FE-FE interface\nFr: CE-CE interface\nFc: Interface between the CE manager and a CE\nFf: Interface between the FE manager and an FE\nFl: Interface between the CE manager and the FE manager\nFi/f: FE external interface",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 1: ForCES Architectural Diagram",
      "ja": "図1：のForCESアーキテクチャダイアグラム"
    },
    {
      "indent": 3,
      "text": "The ForCES protocol domain is found in the Fp reference points. The Protocol Element configuration reference points, Fc and Ff, also play a role in the booting up of the ForCES protocol. The protocol element configuration (indicated by reference points Fc, Ff, and Fl in [RFC3746]) is out of scope of the ForCES protocol but is touched on in this document in discussion of FEM and CEM since it is an integral part of the protocol pre-association phase.",
      "ja": "ForCESプロトコルドメインはFpの基準点に見出されます。プロトコル要素の構成基準点は、FcとFFは、またのForCESプロトコルのブートアップ中に役割を果たしています。 （[RFC3746]での基準点のFc、Ffと、とflで示す）プロトコル要素の構成は、のForCESプロトコルの範囲外であるが、それはプロトコルの不可欠な部分であるので、FEM及びCEMの議論は、この文書に触れています事前会合相。"
    },
    {
      "indent": 3,
      "text": "Figure 2 below shows further breakdown of the Fp interfaces by means of the example of an MPLS QoS-enabled Network Element.",
      "ja": "図2は、以下のMPLS QoS対応ネットワーク要素の一例によるFpのインタフェースのさらに内訳を示します。"
    },
    {
      "indent": 9,
      "text": "-------------------------------------------------\n|       |       |       |       |       |       |\n|OSPF   |RIP    |BGP    |RSVP   |LDP    |. . .  |\n|       |       |       |       |       |       |\n-------------------------------------------------    CE\n|               ForCES Interface                |\n-------------------------------------------------\n                        ^   ^\n                        |   |\n                ForCES  |   |data\n                control |   |packets\n                messages|   |(e.g., routing packets)\n                        |   |\n                        v   v\n-------------------------------------------------\n|               ForCES Interface                |\n-------------------------------------------------    FE\n|       |       |       |       |       |       |\n|LPM Fwd|Meter  |Shaper |MPLS   |Classi-|. . .  |\n|       |       |       |       |fier   |       |\n-------------------------------------------------",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 2: Examples of CE and FE Functions",
      "ja": "図2：CEとFE機能の例"
    },
    {
      "indent": 3,
      "text": "The ForCES interface shown in Figure 2 constitutes two pieces: the PL and the TML.",
      "ja": "PLおよびTML：図2に示されているのForCESインタフェースは、二つの部分を構成しています。"
    },
    {
      "indent": 3,
      "text": "This is depicted in Figure 3 below.",
      "ja": "これは以下の図3に示されています。"
    },
    {
      "indent": 9,
      "text": "+------------------------------------------------\n|               CE PL                           |\n+------------------------------------------------\n|              CE TML                           |\n+------------------------------------------------\n                          ^\n                          |\n             ForCES       |   (i.e.,  ForCES data + control\n             PL           |    packets )\n             messages     |\n             over         |\n             specific     |\n             TML          |\n             encaps       |\n             and          |\n             transport    |\n                          |\n                          v\n+------------------------------------------------\n|              FE TML                           |\n+------------------------------------------------\n|               FE PL                           |\n+------------------------------------------------",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 3: ForCES Interface",
      "ja": "図3：のForCESインタフェース"
    },
    {
      "indent": 3,
      "text": "The PL is in fact the ForCES protocol. Its semantics and message layout are defined in this document. The TML layer is necessary to connect two ForCES PLs as shown in Figure 3 above. The TML is out of scope for this document but is within scope of ForCES. This document defines requirements the PL needs the TML to meet.",
      "ja": "PLは、実際の力のプロトコルです。その意味とメッセージのレイアウトは、この文書で定義されています。 TML層は、上記の図3に示すように、二つの力PLSのを接続する必要があります。 TMLはこの文書の範囲外ですが、力の範囲内です。この文書では、PLを満たすためにTMLを必要とする要件を定義します。"
    },
    {
      "indent": 3,
      "text": "Both the PL and the TML are standardized by the IETF. While only one PL is defined, different TMLs are expected to be standardized. To interoperate, the TML at the CE and FE are expected to conform to the same definition.",
      "ja": "PLとTMLの両方がIETFによって標準化されています。一つだけPLが定義されている間、別のTMLsは標準化されることが期待されます。相互運用するには、CEでTMLとFEは、同じ定義に準拠することが期待されます。"
    },
    {
      "indent": 3,
      "text": "On transmit, the PL delivers its messages to the TML. The local TML delivers the message to the destination TML. On receive, the TML delivers the message to its destination PL.",
      "ja": "送信では、PLはTMLにそのメッセージを配信します。地元TMLは先TMLにメッセージを配信します。受信では、TMLは、その宛先PLにメッセージを配信します。"
    },
    {
      "indent": 0,
      "text": "4.1.1. The PL",
      "section_title": true,
      "ja": "4.1.1.  PL"
    },
    {
      "indent": 3,
      "text": "The PL is common to all implementations of ForCES and is standardized by the IETF as defined in this document. The PL is responsible for associating an FE or CE to an NE. It is also responsible for tearing down such associations. An FE uses the PL to transmit various subscribed-to events to the CE PL as well as to respond to various status requests issued from the CE PL. The CE configures both the FE and associated LFBs' operational parameters using the PL. In addition, the CE may send various requests to the FE to activate or deactivate it, reconfigure its HA parameterization, subscribe to specific events, etc. More details can be found in Section 7.",
      "ja": "PLは、力のすべての実装に共通であり、この文書で定義されるようにIETFによって標準化されています。 PLは、NEにFEまたはCEを関連付けるための責任があります。また、このような団体を解体する責任があります。 FEは、CE PLに様々なサブスクライブ-にイベントを送信するだけでなく、CE PLから発行された各種ステータス要求に応答するためにPLを使用しています。 CEは、FEとPLを使用して、関連するLFBs'動作パラメータの両方を設定します。また、CEは、詳細は7章で見つけることができるなど、有効または無効にし、それを、そのHAのパラメータを再設定し、特定のイベントをサブスクライブするFEにさまざまなリクエストを送信することができます。"
    },
    {
      "indent": 0,
      "text": "4.1.2. The TML",
      "section_title": true,
      "ja": "4.1.2.  TML"
    },
    {
      "indent": 3,
      "text": "The TML transports the PL messages. The TML is where the issues of how to achieve transport-level reliability, congestion control, multicast, ordering, etc. are handled. It is expected that more than one TML will be standardized. The various possible TMLs could vary their implementations based on the capabilities of underlying media and transport. However, since each TML is standardized, interoperability is guaranteed as long as both endpoints support the same TML. All ForCES protocol layer implementations MUST be portable across all TMLs, because all TMLs MUST have the top-edge semantics defined in this document.",
      "ja": "TMLはPLメッセージを転送します。などのトランスポート・レベルの信頼性、輻輳制御、マルチキャスト、順序を、どのように達成するかの問題が扱われるところTMLです。複数のTMLは標準化されることが期待されます。様々な可能性のあるTMLsは、基礎となるメディアや輸送の能力に基づいて、その実装を変化させることができます。各TMLが標準化されているので、相互運用性は、両方のエンドポイントが同じTMLをサポートしている限り保証されています。全てTMLsこの文書で定義されたトップエッジセマンティクスを持たなければならないので、すべての力のプロトコル層の実装は、すべてのTMLs間で移植していなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.1.3. The FEM/CEM Interface",
      "section_title": true,
      "ja": "4.1.3.  FEM / CEMインターフェイス"
    },
    {
      "indent": 3,
      "text": "The FEM and CEM components, although valuable in the setup and configurations of both the PL and TML, are out of scope of the ForCES protocol. The best way to think of them is as configurations/ parameterizations for the PL and TML before they become active (or even at runtime based on implementation). In the simplest case, the FE or CE reads a static configuration file. RFC 3746 has a more detailed description on how the FEM and CEM could be used. The pre-association phase, where the CEM and FEM can be used, are described briefly in Section 4.2.1.",
      "ja": "FEMとCEMコンポーネント、PLおよびTMLの両方のセットアップおよび構成に価値が、のForCESプロトコルの範囲外です。構成は/ PLとTMLのためのパラメータ化は、彼らがアクティブ（あるいは実装に基づいて、実行時）になる前に、と考えるための最良の方法です。最も単純なケースでは、FEまたはCEは、静的な設定ファイルを読み込みます。 RFC 3746は、FEMとCEMを使用することができる方法についてのより詳細な記述があります。 CEM及びFEMを使用することができる事前会合相は、4.2.1節で簡単に説明されています。"
    },
    {
      "indent": 3,
      "text": "An example of typical things the FEM/CEM could configure would be TML-specific parameterizations such as:",
      "ja": "FEM / CEMを設定することができ、典型的なものの例としては、以下のようなTML固有のパラメータ化のようになります。"
    },
    {
      "indent": 3,
      "text": "a. How the TML connection should happen (for example, what IP addresses to use, transport modes, etc.)",
      "ja": "A。 TML接続が起こるはずどのように（例えば、IPアドレスがどのような、輸送モード、などを使用します）"
    },
    {
      "indent": 3,
      "text": "b. The ID for the FE (FEID) or CE (CEID) (which would also be issued during the pre-association phase)",
      "ja": "B。 （また、事前関連付け段階中に発行される）FE（FEID）またはCE（CEID）のID"
    },
    {
      "indent": 3,
      "text": "c. Security parameterization such as keys, etc.",
      "ja": "C。などのキー、などのセキュリティパラメータ"
    },
    {
      "indent": 3,
      "text": "d. Connection association parameters",
      "ja": "D。接続関連パラメータ"
    },
    {
      "indent": 3,
      "text": "An example of connection association parameters might be:",
      "ja": "接続関連パラメータの例は次のようになります。"
    },
    {
      "indent": 3,
      "text": "o simple parameters: send up to 3 association messages every 1 second",
      "ja": "簡単なパラメータ○：3つの関連メッセージごとに1秒まで送ります"
    },
    {
      "indent": 3,
      "text": "o complex parameters: send up to 4 association messages with increasing exponential timeout",
      "ja": "複雑なパラメータO：増加指数タイムアウトで4つのアソシエーションまでのメッセージを送ります"
    },
    {
      "indent": 0,
      "text": "4.2. ForCES Protocol Phases",
      "section_title": true,
      "ja": "4.2.  ForCESプロトコルフェーズ"
    },
    {
      "indent": 3,
      "text": "ForCES, in relation to NEs, involves two phases: the pre-association phase where configuration/initialization/bootup of the TML and PL layer happens, and the post-association phase where the ForCES protocol operates to manipulate the parameters of the FEs.",
      "ja": "TMLとPL層の構成/初期化/起動が起こる前会合相、強制的プロトコルのFEのパラメータを操作するように動作後会合相：力は、NEに関連して、二つの相を含みます。"
    },
    {
      "indent": 7,
      "text": "                CE sends Association Setup\n    +---->--->------------>---->---->---->------->----+\n    |                                                 Y\n    ^                                                 |\n    |                                                 Y\n+---+-------+                                     +-------------+\n|FE pre-    |                                     | FE post-    |\n|association|    CE sends Association Teardown    | association |\n|phase      |<------- <------<-----<------<-------+ phase       |\n|           |                                     |             |\n+-----------+                                     +-------------+\n      ^                                               Y\n      |                                               |\n      +-<---<------<-----<------<----<---------<------+\n                    FE loses association",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 4: The FE Protocol Phases",
      "ja": "図4：FEプロトコルフェーズ"
    },
    {
      "indent": 3,
      "text": "In the mandated case, once associated, the FE may forward packets depending on the configuration of its specific LFBs. An FE that is associated to a CE will continue sending packets until it receives an Association Teardown Message or until it loses association. An unassociated FE MAY continue sending packets when it has a high availability capability. The extra details are explained in Section 8 and not discussed here to allow for a clear explanation of the basics.",
      "ja": "義務付けられた場合に、関連付けられた後、FEは、その特定LFBsの構成に応じてパケットを転送することができます。 CEに関連付けられているFEは、それが協会のティアダウンメッセージを受信するまで、またはそれがアソシエーションを失うまでパケットを送信し続けます。それは、高可用性機能を備えていたときに関連付けられていないFEは、パケットの送信を継続することができます。余分な詳細は、第8章で説明した基礎の明確な説明を可能にするために、ここで議論されていません。"
    },
    {
      "indent": 3,
      "text": "The FE state transitions are controlled by means of the FE Object LFB FEState component, which is defined in [RFC5812], Section 5.1, and also explained in Section 7.3.2.",
      "ja": "FE状態遷移が[RFC5812]で定義されているFEオブジェクトLFB FEState成分、セクション5.1によって制御され、また、セクション7.3.2で説明されています。"
    },
    {
      "indent": 3,
      "text": "The FE initializes in the FEState OperDisable. When the FE is ready to process packets in the data path, it transitions itself to the OperEnable state.",
      "ja": "FEはFEState OperDisableで初期化します。 FEは、データパス内のパケットを処理する準備ができている場合、それはOperEnable状態に自分自身を移行します。"
    },
    {
      "indent": 3,
      "text": "The CE may decide to pause the FE after it already came up as OperEnable. It does this by setting the FEState to AdminDisable. The FE stays in the AdminDisable state until it is explicitly configured by the CE to transition to the OperEnable state.",
      "ja": "それはすでにOperEnableとして思い付いた後、CEは、FEを一時停止するように決定することができます。それはAdminDisableにFEStateを設定することでこれを行います。それが明示的にCEで構成されているまで、FEはOperEnable状態に遷移するAdminDisable状態のままです。"
    },
    {
      "indent": 3,
      "text": "When the FE loses its association with the CE, it may go into the pre-association phase depending on the programmed policy. For the FE to properly complete the transition to the AdminDisable state, it MUST stop packet forwarding and this may impact multiple LFBS. How this is achieved is outside the scope of this specification.",
      "ja": "FEは、CEとの関連付けを失うと、それはプログラムポリシーに応じて事前関連付け段階に入ることがあります。 FEが適切AdminDisable状態への移行を完了するためには、パケットの転送を停止する必要があり、これは複数LFBSに影響を与える可能性があります。どのようにこれが達成され、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Pre-association",
      "section_title": true,
      "ja": "４。２。１。 Ｐれーあっそしあちおん"
    },
    {
      "indent": 3,
      "text": "The ForCES interface is configured during the pre-association phase. In a simple setup, the configuration is static and is typically read from a saved configuration file. All the parameters for the association phase are well known after the pre-association phase is complete. A protocol such as DHCP may be used to retrieve the configuration parameters instead of reading them from a static configuration file. Note, this will still be considered static pre-association. Dynamic configuration may also happen using the Fc, Ff, and Fl reference points (refer to [RFC3746]). Vendors may use their own proprietary service discovery protocol to pass the parameters. Essentially, only guidelines are provided here and the details are left to the implementation.",
      "ja": "ForCESインタフェースは事前関連付け段階中に構成されています。簡単なセットアップでは、構成が静的であり、一般的に保存した設定ファイルから読み込まれます。事前会合フェーズが完了した後に会合相のためのすべてのパラメータは、よく知られています。 DHCPなどのプロトコルではなく、静的なコンフィギュレーションファイルからそれらを読み出す構成パラメータを取得するために使用されてもよいです。注、これはまだ、静的な事前会合とみなされます。動的構成もFC、Ffは、とfl基準点を使用して発生する可能性があり（[RFC3746]参照）。ベンダーは、パラメータを渡すために、自分の独自のサービス発見プロトコルを使用することができます。基本的に、唯一のガイドラインでは、ここで提供されており、詳細は実装に任されています。"
    },
    {
      "indent": 3,
      "text": "The following are scenarios reproduced from the framework document to show a pre-association example.",
      "ja": "フレームワーク文書から再生される次のシナリオは、事前会合例を示します。"
    },
    {
      "indent": 4,
      "text": "  <----Ff ref pt--->              <--Fc ref pt------->\n  FE Manager      FE                CE Manager    CE\n   |              |                 |             |\n   |              |                 |             |\n(security exchange)               (security exchange)\n  1|<------------>| authentication 1|<----------->|authentication\n   |              |                 |             |\n (FE ID, components)              (CE ID, components)\n  2|<-------------| request        2|<------------|request\n   |              |                 |             |\n  3|------------->| response       3|------------>|response\n  (corresponding CE ID)          (corresponding FE ID)\n   |              |                 |             |\n   |              |                 |             |",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 5: Examples of a Message Exchange over the Ff and Fc\n                     Reference Points",
      "raw": true
    },
    {
      "indent": 6,
      "text": "<-----------Fl ref pt-------------->            |",
      "raw": true
    },
    {
      "indent": 6,
      "text": "FE Manager      FE               CE Manager     CE\n |              |                 |             |\n |              |                 |             |\n(security exchange)               |             |\n1|<------------------------------>|             |\n |              |                 |             |\n(a list of CEs and their components)            |\n2|<-------------------------------|             |\n |              |                 |             |\n(a list of FEs and their components)            |\n3|------------------------------->|             |\n |              |                 |             |\n |              |                 |             |",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 6: Example of a Message Exchange over the Fl Reference Point",
      "ja": "図6：フロリダ基準点以上のメッセージ交換の例"
    },
    {
      "indent": 3,
      "text": "Before the transition to the association phase, the FEM will have established contact with a CEM component. Initialization of the ForCES interface will have completed, and authentication as well as capability discovery may be complete. Both the FE and CE would have the necessary information for connecting to each other for configuration, accounting, identification, and authentication purposes. To summarize, at the completion of this stage both sides have all the necessary protocol parameters such as timers, etc. The Fl reference point may continue to operate during the association phase and may be used to force a disassociation of an FE or CE. The specific interactions of the CEM and the FEM that are part of the pre-association phase are out of scope; for this reason, these details are not discussed any further in this specification. The reader is referred to the framework document [RFC3746] for a slightly more detailed discussion.",
      "ja": "会合相への移行前に、FEMは、CEM成分との接触を確立しているであろう。 ForCESインターフェースの初期化が完了しているだろう、と認証だけでなく、機能の発見は完全なものがあります。 FEおよびCEの両方が設定、アカウンティング、識別、および認証のために相互に接続するために必要な情報を有することになります。要約すると、この段階の完了時に両側が等タイマー、などのすべての必要なプロトコル・パラメータは、FL基準点は、関連付け段階中に動作し続けることができるおり、FEまたはCEの解離を強制するために使用することができます。事前会合相の一部であるCEM及びFEMの特異的相互作用は、範囲外です。この理由のために、これらの詳細は、本明細書で任意の更なる議論されていません。読者はわずかにより詳細な議論のためのフレームワークドキュメント[RFC3746]と呼ばれます。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Post-association",
      "section_title": true,
      "ja": "4.2.2. ポスト協会"
    },
    {
      "indent": 3,
      "text": "In this phase, the FE and CE components communicate with each other using the ForCES protocol (PL over TML) as defined in this document. There are three sub-phases:",
      "ja": "この文書で定義されるように、この段階では、FEおよびCE成分がのForCESプロトコル（TML上PL）を使用して互いに通信します。三つのサブフェーズがあります。"
    },
    {
      "indent": 3,
      "text": "o Association Setup Stage",
      "ja": "O協会のセットアップステージ"
    },
    {
      "indent": 3,
      "text": "o Established Stage",
      "ja": "O設立ステージ"
    },
    {
      "indent": 3,
      "text": "o Association Lost Stage",
      "ja": "O協会ロストステージ"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. Association Setup Stage",
      "section_title": true,
      "ja": "4.2.2.1。協会のセットアップステージ"
    },
    {
      "indent": 3,
      "text": "The FE attempts to join the NE. The FE may be rejected or accepted. Once granted access into the NE, capabilities exchange happens with the CE querying the FE. Once the CE has the FE capability information, the CE can offer an initial configuration (possibly to restore state) and can query certain components within either an LFB or the FE itself.",
      "ja": "FEはNEに参加しようとします。 FEは拒否または受け入れられます。 NEへのアクセスを許可されると、機能交換は、FEを照会CEで発生します。 CEは、FE能力情報を取得すると、CEは、（おそらく状態を復元する）初期設定を提供することができ、LFBまたはFE自体のいずれかの中にいくつかの構成要素を照会することができます。"
    },
    {
      "indent": 3,
      "text": "More details are provided in Section 4.4.",
      "ja": "詳細はセクション4.4で提供されています。"
    },
    {
      "indent": 3,
      "text": "On successful completion of this stage, the FE joins the NE and is moved to the Established Stage.",
      "ja": "この段階が正常に完了すると、FEはNEに参加し、設立ステージに移動されます。"
    },
    {
      "indent": 0,
      "text": "4.2.2.2. Established Stage",
      "section_title": true,
      "ja": "4.2.2.2。設立ステージ"
    },
    {
      "indent": 3,
      "text": "In this stage, the FE is continuously updated or queried. The FE may also send asynchronous event notifications to the CE or synchronous heartbeat notifications if programmed to do so. This stage continues until a termination occurs, either due to loss of connectivity or due to a termination initiated by either the CE or the FE.",
      "ja": "この段階では、FEは継続的に更新または照会されます。そうするためにプログラムされた場合、FEはまた、CEまたは同期のハートビート通知に非同期イベント通知を送信することができます。終了が発生するまで、この段階のいずれかによる接続性の喪失、または起因CEまたはFEのいずれかによって開始終了まで、継続します。"
    },
    {
      "indent": 3,
      "text": "Refer to the section on protocol scenarios, Section 4.4, for more details.",
      "ja": "詳細については、プロトコルのシナリオ、セクション4.4の項を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2.2.3. Association Lost Stage",
      "section_title": true,
      "ja": "4.2.2.3。協会ロストステージ"
    },
    {
      "indent": 3,
      "text": "In this stage, both or either the CE or FE declare the other side is no longer associated. The disconnection could be initiated by either party for administrative purposes but may also be driven by operational reasons such as loss of connectivity.",
      "ja": "この段階で、両方又はいずれかCEまたはFEは反対側がもはや関連付けられて宣言しません。断線が管理上の目的のためにいずれかの当事者によって開始することができただけでなく、接続性の喪失などの運用上の理由により駆動することができます。"
    },
    {
      "indent": 3,
      "text": "A core LFB known as the FE Protocol Object (FEPO) is defined (refer to Appendix B and Section 7.3.1). FEPO defines various timers that can be used in conjunction with a traffic-sensitive heartbeat mechanism (Section 4.3.3) to detect loss of connectivity.",
      "ja": "FEプロトコルオブジェクト（のFePO）として知られているコアLFBは（付録B、セクション7.3.1を参照）が定義されています。 FePOは、接続の喪失を検出するために、トラフィック感受性ハートビートメカニズム（4.3.3）と組み合わせて使用​​することができる様々なタイマーを定義します。"
    },
    {
      "indent": 3,
      "text": "The loss of connectivity between TMLs does not indicate a loss of association between respective PL layers. If the TML cannot repair the transport loss before the programmed FEPO timer thresholds associated with the FE is exceeded, then the association between the respective PL layers will be lost.",
      "ja": "TMLs間の接続の損失は、それぞれPL層との間の関連の損失を示していません。 FEに関連付けられたプログラムのFePOタイマーのしきい値を超過する前に、TMLは、輸送損失を修復できない場合は、それぞれのPL層の間の関連付けが失われます。"
    },
    {
      "indent": 3,
      "text": "FEPO defines several policies that can be programmed to define behavior upon a detected loss of association. The FEPO's programmed CE failover policy (refer to Sections 8, 7.3.1, 4.3.3, and B) defines what takes place upon loss of association.",
      "ja": "FePOは、関連の検出損失時の動作を定義するようにプログラムすることができる複数のポリシーを定義します。 FePOのプログラムCEのフェールオーバーポリシーは、（セクション8、7.3.1、4.3.3、およびBを参照してください）関連の損失時に行われるものを定義しています。"
    },
    {
      "indent": 3,
      "text": "For this version of the protocol (as defined in this document), the FE, upon re-association, MUST discard any state it has as invalid and retrieve new state. This approach is motivated by a desire for simplicity (as opposed to efficiency).",
      "ja": "プロトコルのこのバージョン（本文書で定義されるように）のために、FEは、再アソシエーション時に、それは新しい状態を取得無効とを有する任意の状態を破棄しなければなりません。このアプローチは、（効率とは対照的に）簡単のため欲求によって動機付けされます。"
    },
    {
      "indent": 0,
      "text": "4.3. Protocol Mechanisms",
      "section_title": true,
      "ja": "4.3. プロトコルメカニズム"
    },
    {
      "indent": 3,
      "text": "Various semantics are exposed to the protocol users via the PL header including transaction capabilities, atomicity of transactions, two-phase commits, batching/parallelization, high availability, and failover as well as command pipelines.",
      "ja": "種々のセマンティクスはトランザクション機能、トランザクションのアトミック性、二相コミット、バッチ/並列化、高可用性、およびフェイルオーバーならびにコマンドパイプラインを含むPLヘッダを介してプロトコルユーザに露出されています。"
    },
    {
      "indent": 3,
      "text": "The EM (Execution Mode) flag, AT (Atomic Transaction) flag, and TP (Transaction Phase) flag as defined in the common header (Section 6.1) are relevant to these mechanisms.",
      "ja": "EM（実行モード）フラグ、AT（アトミックトランザクション）フラグ、TP（トランザクション相）フラグ共通ヘッダ（セクション6.1）で定義されるように、これらの機構に関連しています。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Transactions, Atomicity, Execution, and Responses",
      "section_title": true,
      "ja": "4.3.1. 取引、原子性、実行、および応答"
    },
    {
      "indent": 3,
      "text": "In the master-slave relationship, the CE instructs one or more FEs on how to execute operations and how to report the results.",
      "ja": "主従関係において、CEは、操作を実行してどのように結果を報告するために方法の一の以上のFEを指示します。"
    },
    {
      "indent": 3,
      "text": "This section details the different modes of execution that a CE can order the FE(s) to perform, as defined in Section 4.3.1.1. It also describes the different modes a CE can ask the FE(s) to use for formatting the responses after processing the operations as requested. These modes relate to the transactional two-phase commit operations.",
      "ja": "このセクションでは、CEは、セクション4.3.1.1で定義されるように、実行するためにFE（単数または複数）を注文することができ、実行の異なるモードを詳述します。また、CEが要求などの操作を処理した後の応答をフォーマットするために使用するFE（複数可）を求めることができ、異なるモードを説明しています。これらのモードは、トランザクション2フェーズに関連する操作をコミットします。"
    },
    {
      "indent": 0,
      "text": "4.3.1.1. Execution",
      "section_title": true,
      "ja": "4.3.1.1。実行"
    },
    {
      "indent": 3,
      "text": "There are 3 execution modes that can be requested for a batch of operations spanning one or more LFB selectors (refer to Section 7.1.5) in one protocol message. The EM flag defined in the common header (Section 6.1) selects the execution mode for a protocol message, as below:",
      "ja": "一つ以上のLFBセレクタにまたがる操作のバッチを要求することができる3つの実行モードがあり、プロトコルメッセージに（セクション7.1.5参照）。共通ヘッダ（セクション6.1）で定義されたEMフラグは以下のように、プロトコルメッセージのための実行モードを選択します。"
    },
    {
      "indent": 3,
      "text": "a. execute-all-or-none",
      "ja": "A。実行-全か無か"
    },
    {
      "indent": 3,
      "text": "b. continue-execute-on-failure",
      "ja": "B。引き続き実行・オン・失敗"
    },
    {
      "indent": 3,
      "text": "c. execute-until-failure",
      "ja": "C。実行-まで障害"
    },
    {
      "indent": 0,
      "text": "4.3.1.1.1. execute-all-or-none",
      "section_title": true,
      "ja": "4.3.1.1.1。実行-全か無か"
    },
    {
      "indent": 3,
      "text": "When set to this mode of execution, independent operations in a message MAY be targeted at one or more LFB selectors within an FE. All these operations are executed serially, and the FE MUST have no execution failure for any of the operations. If any operation fails to execute, then all the previous ones that have been executed prior to the failure will need to be undone. That is, there is rollback for this mode of operation.",
      "ja": "実行のこのモードに設定すると、メッセージ中の独立した操作は、FE内の1つ以上のLFBセレクタで標的とすることができます。これらの操作はすべて、逐次実行され、FEは、操作のいずれかのための実行の失敗があってはなりません。任意の操作が実行に失敗した場合は、障害の前に実行されたすべての以前のものは元に戻すことが必要になります。つまり、この動作モードのロールバックがあります。"
    },
    {
      "indent": 3,
      "text": "Refer to Section 4.3.1.2.2 for how this mode is used in cases of transactions. In such a case, no operation is executed unless a commit is issued by the CE.",
      "ja": "このモードは、トランザクションの例でどのように使用されるかについては、セクション4.3.1.2.2を参照してください。コミットCEによって発行されていない限り、このような場合には、何も操作が実行されません。"
    },
    {
      "indent": 3,
      "text": "Care should be taken on how this mode is used because a mis-configuration could result in traffic losses. To add certainty to the success of an operation, one should use this mode in a transactional operation as described in Section 4.3.1.2.2",
      "ja": "ケアは、設定ミスがトラフィックの損失が生じる可能性があるため、このモードの使用方法に注意が必要です。セクション4.3.1.2.2で説明したように、操作の成功に確信を追加するためには、トランザクションの操作で、このモードを使用する必要があります"
    },
    {
      "indent": 0,
      "text": "4.3.1.1.2. continue-execute-on-failure",
      "section_title": true,
      "ja": "4.3.1.1.2。引き続き実行・オン・失敗"
    },
    {
      "indent": 3,
      "text": "If several independent operations are targeted at one or more LFB selectors, execution continues for all operations at the FE even if one or more operations fail.",
      "ja": "いくつかの独立した操作は、1つのまたは複数のLFBセレクタをターゲットにしている場合は、実行が1つ以上の操作が失敗してもFEですべての操作のために続けています。"
    },
    {
      "indent": 0,
      "text": "4.3.1.1.3. execute-until-failure",
      "section_title": true,
      "ja": "4.3.1.1.3。実行-まで障害"
    },
    {
      "indent": 3,
      "text": "In this mode, all operations are executed on the FE sequentially until the first failure. The rest of the operations are not executed but operations already completed are not undone. That is, there is no rollback in this mode of operation.",
      "ja": "このモードでは、すべての操作が最初の故障までFE順次に実行されます。操作の残りの部分は実行されませんが、すでに完了した操作が取り消されていません。つまり、この動作モードにはロールバックはありません。"
    },
    {
      "indent": 0,
      "text": "4.3.1.2. Transaction and Atomicity",
      "section_title": true,
      "ja": "4.3.1.2。トランザクションとアトミック"
    },
    {
      "indent": 0,
      "text": "4.3.1.2.1. Transaction Definition",
      "section_title": true,
      "ja": "4.3.1.2.1。トランザクション定義"
    },
    {
      "indent": 3,
      "text": "A transaction is defined as a collection of one or more ForCES operations within one or more PL messages that MUST meet the ACIDity properties [ACID], defined as:",
      "ja": "トランザクションは、次のように定義酸性特性を満たさなければならない一つ以上のPLメッセージ内の1つ以上の力操作のコレクション[酸]、次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "Atomicity: In a transaction involving two or more discrete pieces of information, either all of the pieces are committed or none are.",
      "ja": "原子性：情報の2つの以上の個別の部分を含むトランザクションでは、どちらかの作品のすべてがコミットまたはnoneですがあります。"
    },
    {
      "indent": 3,
      "text": "Consistency: A transaction either creates a new and valid state of data or, if any failure occurs, returns all data to the state it was in before the transaction was started.",
      "ja": "一貫性：どちらかのトランザクションがデータの新しいと有効な状態を作成するか、いずれかの障害が発生した場合、トランザクションが開始された前の状態にすべてのデータを返します。"
    },
    {
      "indent": 3,
      "text": "Isolation: A transaction in process and not yet committed MUST remain isolated from any other transaction.",
      "ja": "アイソレーション：プロセスにおけるトランザクション、まだコミットされていないが、他のトランザクションから分離されたままにしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Durability: Committed data is saved by the system such that, even in the event of a failure and a system restart, the data is available in its correct state.",
      "ja": "耐久性：コミットされたデータであっても故障とシステムの再起動の際に、データが正しい状態に利用可能である、ことをそのようなシステムによって保存されています。"
    },
    {
      "indent": 3,
      "text": "There are cases where the CE knows exact memory and implementation details of the FE such as in the case of an FE-CE pair from the same vendor where the FE-CE pair is tightly coupled. In such a case, the transactional operations may be simplified further by extra computation at the CE. This view is not discussed further other than to mention that it is not disallowed.",
      "ja": "CEは、FE-CEペアが緊密に結合されているのと同じベンダーからFE-CEペアの場合と同様にFEの正確なメモリおよび実装の詳細を知っている場合があります。このような場合には、トランザクションの動作がCEに余分な計算によってさらに簡略化することができます。このビューは、それが禁止されていないことを言及するよりも、さらに他の議論されていません。"
    },
    {
      "indent": 3,
      "text": "As defined above, a transaction is always atomic and MAY be",
      "ja": "上記に定義したように、トランザクションは常にアトミックであってもよいです"
    },
    {
      "indent": 3,
      "text": "a. Within an FE alone Example: updating multiple tables that are dependent on each other. If updating one fails, then any that were already updated MUST be undone.",
      "ja": "A。 FEだけでは例の中で：相互に依存する複数のテーブルを更新します。更新1が失敗した場合、すでに更新されたそのいずれかが取り消されなければなりません。"
    },
    {
      "indent": 3,
      "text": "b. Distributed across the NE Example: updating table(s) that are inter-dependent across several FEs (such as L3 forwarding-related tables).",
      "ja": "B。 NE例に分散（例えばL3転送関連のテーブルのような）いくつかのFEを横切る相互依存している更新テーブル（単数または複数）。"
    },
    {
      "indent": 0,
      "text": "4.3.1.2.2. Transaction Protocol",
      "section_title": true,
      "ja": "4.3.1.2.2。トランザクションプロトコル"
    },
    {
      "indent": 3,
      "text": "By use of the execution mode, as defined in Section 4.3.1.1, the protocol has provided a mechanism for transactional operations within one stand-alone message. The 'execute-all-or-none' mode can meet the ACID requirements.",
      "ja": "実行モードを使用することによって、セクション4.3.1.1で定義されるように、プロトコルは、一スタンドアロンメッセージ内にトランザクション操作するための機構を提供しています。 「すべての実行か無か」モードは、ACID要件を満たすことができます。"
    },
    {
      "indent": 3,
      "text": "For transactional operations of multiple messages within one FE or across FEs, a classical transactional protocol known as two-phase commit (2PC) [2PCREF] is supported by the protocol to achieve the transactional operations utilizing Config messages (Section 7.6.1).",
      "ja": "1 FE内又はフェス2フェーズ・コミットとして知られている古典的なトランザクションプロトコルを横切る複数のメッセージのトランザクション操作のために（2PC）2PCREF]コンフィグメッセージ（セクション7.6.1）を利用トランザクション操作を達成するために、プロトコルによってサポートされています。"
    },
    {
      "indent": 3,
      "text": "The COMMIT and TRCOMP operations in conjunction with the AT and the TP flags in the common header (Section 6.1) are provided for 2PC-based transactional operations spanning multiple messages.",
      "ja": "共通ヘッダ（セクション6.1）でATとTPフラグと一緒にCOMMITとTRCOMP操作は、複数のメッセージにまたがる2PCベースのトランザクション操作のために提供されます。"
    },
    {
      "indent": 3,
      "text": "The AT flag, when set, indicates that this message belongs to an Atomic Transaction. All messages for a transaction operation MUST have the AT flag set. If not set, it means that the message is a stand-alone message and does not participate in any transaction operation that spans multiple messages.",
      "ja": "セットATフラグは、このメッセージがアトミックトランザクションに属していることを示しています。トランザクション操作のためのすべてのメッセージは、ATフラグを設定する必要があります。設定されていない場合、メッセージは、スタンドアロンのメッセージであり、複数のメッセージにまたがるすべてのトランザクション操作に参加しないことを意味します。"
    },
    {
      "indent": 3,
      "text": "The TP flag indicates the Transaction Phase to which this message belongs. There are 4 possible phases for a transactional operation known as:",
      "ja": "TPフラグは、このメッセージが属するトランザクション位相を示します。知られているトランザクションの操作のための4つの可能なフェーズがあります。"
    },
    {
      "indent": 6,
      "text": "SOT (Start of Transaction)",
      "ja": "SOT（トランザクションの開始）"
    },
    {
      "indent": 6,
      "text": "MOT (Middle of Transaction)",
      "ja": "MOT（トランザクションの途中）"
    },
    {
      "indent": 6,
      "text": "EOT (End of Transaction)",
      "ja": "EOT（トランザクションの終了）"
    },
    {
      "indent": 6,
      "text": "ABT (Abort)",
      "ja": "ABT（中止）"
    },
    {
      "indent": 3,
      "text": "The COMMIT operation is used by the CE to signal to the FE(s) to commit a transaction. When used with an ABT TP flag, the COMMIT operation signals the FE(s) to roll back (i.e., un-COMMIT) a previously committed transaction.",
      "ja": "COMMIT操作がトランザクションをコミットするFE（複数可）に知らせるためにCEによって使用されます。 ABT TPフラグと一緒に使用すると、COMMIT操作（すなわち、未コミット）以前にコミットされたトランザクションをロールバックするFE（複数可）信号。"
    },
    {
      "indent": 3,
      "text": "The TRCOMP operation is a small addition to the classical 2PC approach. TRCOMP is sent by the CE to signal to the FE(s) that the transaction they have COMMITed is now over. This allows the FE(s) an opportunity to clear state they may have kept around to perform a roll back (if it became necessary).",
      "ja": "TRCOMP操作は、古典的な2PCアプローチに少量の添加です。 TRCOMPは、それらがコミットされているトランザクションが終わっ今であることをFE（複数可）に知らせるためにCEによって送信されます。これは、（それが必要となった場合）FE（S）それらはロールバックを実行するために周りに保たれている可能性の状態をクリアする機会ができます。"
    },
    {
      "indent": 3,
      "text": "A transaction operation is started with a message in which the TP flag is set to Start of Transaction (SOT). Multi-part messages, after the first one, are indicated by the Middle of Transaction (MOT) flag. All messages from the CE MUST set the AlwaysACK flag (Section 6) to solicit responses from the FE(s).",
      "ja": "トランザクション操作は、TPフラグがトランザクション（SOT）の開始に設定されているメッセージで開始されます。マルチパートメッセージは、最初の後、トランザクションの途中（MOT）フラグによって示されています。 CEからのすべてのメッセージは、FE（S）からの応答を勧誘するAlwaysACKフラグ（第6節）を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Before the CE issues a commit (described further below), the FE MUST only validate that the operation can be executed but not execute it.",
      "ja": "CEは、（さらに後述する）コミットを発行する前に、FEのみ動作を実行できることを検証し、それを実行しないでください。"
    },
    {
      "indent": 6,
      "text": "Any failure notified by an FE causes the CE to abort the transaction on all FEs involved in the transaction. This is achieved by sending a Config message with an ABT flag and a COMMIT operation.",
      "ja": "FEで通知任意の失敗は、トランザクションに関与するすべてのFE上の取引を中止するCEの原因となります。これは、ABTフラグとCOMMIT操作でConfigメッセージを送信することによって達成されます。"
    },
    {
      "indent": 6,
      "text": "If there are no failures by any participating FE, the transaction commitment phase is signaled from the CE to the FE by an End of Transaction (EOT) configuration message with a COMMIT operation.",
      "ja": "任意の参加FEによって失敗がなければ、トランザクションのコミット・フェーズは、COMMIT操作でトランザクションの終了（EOT）の設定メッセージによってCEからFEに通知されます。"
    },
    {
      "indent": 3,
      "text": "The FE MUST respond to the CE's EOT message. There are two possible failure scenarios in which the CE MUST abort the transaction (as described above):",
      "ja": "FEは、CEのEOTメッセージに反応しなければなりません。 （上記のように）CEがトランザクションをアボートしなければならない二つの可能な障害シナリオがあります。"
    },
    {
      "indent": 3,
      "text": "a. If any participating FE responds with a failure message in relation to the transaction.",
      "ja": "A。任意の参加FEは、取引に関連して失敗メッセージで応答した場合。"
    },
    {
      "indent": 3,
      "text": "b. If no response is received from a participating FE within a specified timeout.",
      "ja": "B。応答が指定されたタイムアウト時間内に参加FEから受信されない場合。"
    },
    {
      "indent": 3,
      "text": "If all participating FEs respond with a success indicator within the expected time, then the CE MUST issue a TRCOMP operation to all participating FEs. An FE MUST NOT respond to a TRCOMP.",
      "ja": "すべての参加のFEは、想定された時間内に成功インジケーターで応答した場合は、CEは、すべての参加のFEにTRCOMP操作を発行しなければなりません。 FEはTRCOMPに応じてはいけません。"
    },
    {
      "indent": 3,
      "text": "Note that a transactional operation is generically atomic; therefore, it requires that the execution modes of all messages in a transaction operation should always be kept the same and be set to 'execute-all-or-none'. If the EM flag is set to other execution modes, it will result in a transaction failure.",
      "ja": "トランザクショナルオペレーションは一般的にアトミックであることに注意してください。したがって、それは、トランザクション操作のすべてのメッセージの実行モードが常に同じに維持されなければならないと「 - 全か無かを実行しない」に設定されている必要があります。 EMフラグは、他の実行モードに設定されている場合、それはトランザクション障害になります。"
    },
    {
      "indent": 3,
      "text": "As noted above, a transaction may span multiple messages. It is up to the CE to keep track of the different outstanding messages making up a transaction. As an example, the correlator field could be used to mark transactions and a sequence field to label the different messages within the same atomic transaction, but this is out of scope and up to implementations.",
      "ja": "上述したように、トランザクションが複数のメッセージにまたがることがあります。これは、トランザクションを構成するさまざまな優れたメッセージを追跡するためにCEまでです。一例として、相関フィールドが同じアトミックトランザクション内の異なるメッセージを標識するためにトランザクションおよびシーケンスのフィールドをマークするために使用することができるが、これは範囲外と実装次第です。"
    },
    {
      "indent": 0,
      "text": "4.3.1.2.3. Recovery",
      "section_title": true,
      "ja": "4.3.1.2.3。回復"
    },
    {
      "indent": 3,
      "text": "Any of the participating FEs or the CE or the associations between them may fail after the EOT Response message has been sent by the FE but before the CE has received all the responses, e.g., if the EOT response never reaches the CE.",
      "ja": "参加のFEまたはCEまたはそれらの間の関係のいずれかがEOT応答メッセージは、FEにより送信された後失敗することがありますがEOT応答がCEに到達したことがない場合はCE前に、例えば、すべての応答を受信しました。"
    },
    {
      "indent": 3,
      "text": "In this protocol revision, as indicated in Section 4.2.2.3, an FE losing an association would be required to get entirely new state from the newly associated CE upon a re-association. Although this approach is simplistic and provides likeliness of losing data path traffic, it is a design choice to avoid the additional complexity of managing graceful restarts. The HA mechanisms (Section 8) are provided to allow for a continuous operation in case of FE failures.",
      "ja": "このプロトコル改訂において、セクション4.2.2.3に示されているように、関連性を失うFEは、再アソシエーション時に新たに関連付けられたCEから完全に新しい状態を取得するために必要とされるであろう。このアプローチは単純化され、データパスのトラフィックを失うのしやすを提供しますが、優雅な再起動を管理するための追加的な複雑さを避けるために、設計上の選択です。 HA機構（セクション8）はFEの障害の場合に連続運転を可能にするために設けられています。"
    },
    {
      "indent": 3,
      "text": "Flexibility is provided on how to react when an FE loses association. This is dictated by the CE failover policy (refer to Section 8 and Section 7.3).",
      "ja": "柔軟性は、FEが関連を失ったときにどのように対処するかに設けられています。これは、CEのフェイルオーバー・ポリシーによって決定される（8節と7.3節を参照してください）。"
    },
    {
      "indent": 0,
      "text": "4.3.1.2.4. Transaction Messaging Example",
      "section_title": true,
      "ja": "4.3.1.2.4。トランザクションメッセージの例"
    },
    {
      "indent": 3,
      "text": "This section illustrates an example of how a successful two-phase commit between a CE and an FE would look in the simple case.",
      "ja": "このセクションでは、2つの相がCEとFEとの間でコミット成功したが、単純な場合にどのように見えるかの例を示しています。"
    },
    {
      "indent": 9,
      "text": "FE PL CE PL",
      "ja": "FE PL CE PL"
    },
    {
      "indent": 11,
      "text": "|                                                      |\n| (1) Config, SOT,AT, EM=All-or-None, OP= SET/DEL,etc  |\n|<-----------------------------------------------------|\n|                                                      |\n| (2) ACKnowledge                                      |\n|----------------------------------------------------->|\n|                                                      |\n| (3) Config, MOT,AT, EM=All-or-None, OP= SET/DEL,etc  |\n|<-----------------------------------------------------|\n|                                                      |\n| (4) ACKnowledge                                      |\n|----------------------------------------------------->|\n|                                                      |\n| (5) Config, MOT,AT, EM=All-or-None, OP= SET/DEL,etc  |\n|<-----------------------------------------------------|\n|                                                      |\n| (6) ACKnowledge                                      |\n|----------------------------------------------------->|\n.                                                      .\n.                                                      .\n.                                                      .\n.                                                      .\n|                                                      |\n| (N) Config, EOT,AT, EM=All-or-None, OP= COMMIT       |\n|<-----------------------------------------------------|\n|                                                      |\n| (N+1)Config-response, ACKnowledge, OP=COMMIT-RESPONSE|\n|----------------------------------------------------->|\n|                                                      |\n| (N+2) Config, OP=TRCOMP                              |\n|<-----------------------------------------------------|",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 7: Example of a Two-Phase Commit",
      "ja": "図7：二相の例は、コミット"
    },
    {
      "indent": 3,
      "text": "For the scenario illustrated above:",
      "ja": "上記例示のシナリオのために："
    },
    {
      "indent": 3,
      "text": "o In step 1, the CE issues a Config message with an operation of choice like a DEL or SET. The transaction flags are set to indicate a Start of Transaction (SOT), Atomic Transaction (AT), and execute-all-or-none.",
      "ja": "Oステップ1において、CEは、DELまたはSETのような選択の操作とConfigメッセージを発行します。トランザクションフラグがトランザクションの開始（SOT）、アトミック・トランザクション（AT）を示し、実行していない - 全か無かのように設定されています。"
    },
    {
      "indent": 3,
      "text": "o The FE validates that it can execute the request successfully and then issues an acknowledgment back to the CE in step 2.",
      "ja": "O FEは、それが正常に要求を実行できることを検証した後、ステップ2に戻ってCEに肯定応答を発行します。"
    },
    {
      "indent": 3,
      "text": "o In step 3, the same sort of construct as in step 1 is repeated by the CE with the transaction flag changed to Middle of Transaction (MOT).",
      "ja": "Oステップ3では、ステップ1と同様の構築物と同じ種類のトランザクション（MOT）の途中に変更し、トランザクションフラグとCEによって繰り返されます。"
    },
    {
      "indent": 3,
      "text": "o The FE validates that it can execute the request successfully and then issues an acknowledgment back to the CE in step 4.",
      "ja": "O FEは、それが正常に要求を実行できることを検証した後、ステップ4に戻ってCEに肯定応答を発行します。"
    },
    {
      "indent": 3,
      "text": "o The CE-FE exchange continues in the same manner until all the operations and their parameters are transferred to the FE. This happens in step (N-1).",
      "ja": "O CE-FE交換は、すべての操作まで同様に続け、それらのパラメータは、FEに転送されます。これは、ステップ（N-1）で起こります。"
    },
    {
      "indent": 3,
      "text": "o In step N, the CE issues a commit. A commit is a Config message with an operation of type COMMIT. The transaction flag is set to End of Transaction (EOT). Essentially, this is an \"empty\" message asking the FE to execute all the operations it has gathered since the beginning of the transaction (message #1).",
      "ja": "OステップNでは、CEは、コミットを発行します。コミットコミットタイプの動作とConfigメッセージです。トランザクションフラグは、トランザクションの終了（EOT）に設定されています。基本的に、これはトランザクション（メッセージ＃1）の初めから集まったすべての操作を実行するためにFEを求めて「空」のメッセージです。"
    },
    {
      "indent": 3,
      "text": "o The FE at this point executes the full transaction. It then issues an acknowledgment back to the CE in step (N+1) that contains a COMMIT-RESPONSE.",
      "ja": "この時点でFE Oが完全なトランザクションを実行します。その後、バックCOMMIT-RESPONSEを含有するステップ（N + 1）内のCEに肯定応答を発行します。"
    },
    {
      "indent": 3,
      "text": "o The CE in this case has the simple task of issuing a TRCOMP operation to the FE in step (N+2).",
      "ja": "Oこの場合、CEは、ステップFEにTRCOMP動作（N + 2）を発行する簡単なタスクを有します。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Scalability",
      "section_title": true,
      "ja": "4.3.2. スケーラビリティ"
    },
    {
      "indent": 3,
      "text": "It is desirable that the PL not become the bottleneck when larger bandwidth pipes become available. To pick a hypothetical example in today's terms, if a 100-Gbps pipe is available and there is sufficient work, then the PL should be able to take advantage of this and use all of the 100-Gbps pipe. Two mechanisms have been provided to achieve this. The first one is batching and the second one is a command pipeline.",
      "ja": "より大きな帯域幅のパイプが利用可能になったときにPLがボトルネックになっていないことが望ましいです。 100 Gbpsのパイプが利用可能であり、十分な仕事があるかどうか、今日の面で仮想的な例を選ぶために、そしてPLはこれを利用し、100 Gbpsのパイプの全てを使用することができるはずです。 2つのメカニズムがこれを達成するために提供されています。最初のものは、バッチ処理であり、もう一つはコマンドパイプラインです。"
    },
    {
      "indent": 3,
      "text": "Batching is the ability to send multiple commands (such as Config) in one Protocol Data Unit (PDU). The size of the batch will be affected by, among other things, the path MTU. The commands may be part of the same transaction or may be part of unrelated transactions that are independent of each other.",
      "ja": "バッチ処理は、一つのプロトコルデータユニット（PDU）で（例えば構成のような）複数のコマンドを送信する機能です。バッチのサイズは、パスMTU、とりわけ、によって影響を受けることになります。コマンドは、同じトランザクションの一部であってもよいし、互いに独立した無関係のトランザクションの一部であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Command pipelining allows for pipelining of independent transactions that do not affect each other. Each independent transaction could consist of one or more batches.",
      "ja": "コマンドのパイプラインは、お互いに影響を与えていない独立したトランザクションのパイプライン化することができます。それぞれの独立したトランザクションは、1つのまたは複数のバッチで構成することができます。"
    },
    {
      "indent": 0,
      "text": "4.3.2.1. Batching",
      "section_title": true,
      "ja": "4.3.2.1。バッチ処理"
    },
    {
      "indent": 3,
      "text": "There are several batching levels at different protocol hierarchies.",
      "ja": "異なるプロトコル階層でのいくつかのバッチ処理のレベルがあります。"
    },
    {
      "indent": 3,
      "text": "o Multiple PL PDUs can be aggregated under one TML message.",
      "ja": "O複数PLのPDUは、一つTMLメッセージの下に集約することができます。"
    },
    {
      "indent": 3,
      "text": "o Multiple LFB classes and instances (as indicated in the LFB selector) can be addressed within one PL PDU.",
      "ja": "O複数LFBクラス及びインスタンスは（LFBセレクタに示されるように）1 PL PDU内に対処することができます。"
    },
    {
      "indent": 3,
      "text": "o Multiple operations can be addressed to a single LFB class and instance.",
      "ja": "O複数の操作は、単一のLFBクラスおよびインスタンスに対処することができます。"
    },
    {
      "indent": 0,
      "text": "4.3.2.2. Command Pipelining",
      "section_title": true,
      "ja": "4.3.2.2。コマンドパイプライン"
    },
    {
      "indent": 3,
      "text": "The protocol allows any number of messages to be issued by the CE before the corresponding acknowledgments (if requested) have been returned by the FE. Hence, pipelining is inherently supported by the protocol. Matching responses with requests messages can be done using the correlator field in the message header.",
      "ja": "プロトコルは、メッセージの任意の数はFEで返された対応する確認応答（要求された場合）の前にCEによって発行することができます。したがって、パイプラインは、本質的プロトコルによってサポートされています。要求メッセージとマッチング応答は、メッセージヘッダーに相関フィールドを使用して行うことができます。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Heartbeat Mechanism",
      "section_title": true,
      "ja": "4.3.3. ハートビートメカニズム"
    },
    {
      "indent": 3,
      "text": "Heartbeats (HBs) between FEs and CEs are traffic sensitive. An HB is sent only if no PL traffic is sent between the CE and FE within a configured interval. This has the effect of reducing the amount of HB traffic in the case of busy PL periods.",
      "ja": "FEとCE間のハートビート（HBS）は、トラフィック敏感です。 HBは何のPLトラフィックが設定された間隔内のCEとFEとの間で送信されていない場合にのみ送信されます。これは、忙しいPL期間の場合にはHBトラフィックの量を低減する効果があります。"
    },
    {
      "indent": 3,
      "text": "An HB can be sourced by either the CE or FE. When sourced by the CE, a response can be requested (similar to the ICMP ping protocol). The FE can only generate HBs in the case of being configured to do so by the CE. Refer to Section 7.3.1 and Section 7.10 for details.",
      "ja": "HBは、CEやFEのいずれかによって供給することができます。 CEによって供給するとき、応答が（ICMPピングプロトコルと同様に）要求することができます。 FEは、CEによってそうするように構成された場合でのHBsを生成することができます。 7.3.1項および詳細については、7.10節を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.3.4. FE Object and FE Protocol LFBs",
      "section_title": true,
      "ja": "4.3.4.  FEオブジェクトとFEプロトコルLFBs"
    },
    {
      "indent": 3,
      "text": "All PL messages operate on LFB constructs, as this provides more flexibility for future enhancements. This means that maintenance and configurability of FEs, NE, and the ForCES protocol itself MUST be expressed in terms of this LFB architecture. For this reason, special LFBs are created to accommodate this need.",
      "ja": "これは、将来の拡張のためのより多くの柔軟性を提供して、すべてのPLメッセージは、LFBの構文で動作します。これは、メンテナンスとのFEのコンフィギュラ、NE、、強制的プロトコル自体がこのLFBアーキテクチャで表さなければならないことを意味します。このため、特別なLFBsは、このニーズに対応するために作成されます。"
    },
    {
      "indent": 3,
      "text": "In addition, this shows how the ForCES protocol itself can be controlled by the very same type of structures (LFBs) it uses to control functions such as IP forwarding, filtering, etc.",
      "ja": "加えて、これはそのような等IP転送、フィルタリングなどの機能を制御するために使用するのForCESプロトコル自体は、構造（LFBs）の非常に同じ種類によって制御することができる方法を示して"
    },
    {
      "indent": 3,
      "text": "To achieve this, the following specialized LFBs are introduced:",
      "ja": "これを実現するために、以下の特殊なLFBsが導入されています。"
    },
    {
      "indent": 3,
      "text": "o FE Protocol LFB, which is used to control the ForCES protocol.",
      "ja": "ForCESプロトコルを制御するために使用されるFEプロトコルLFB、O。"
    },
    {
      "indent": 3,
      "text": "o FE Object LFB, which is used to control components relative to the FE itself. Such components include FEState [RFC5812], vendor, etc.",
      "ja": "O FEはFE自体に対して構成要素を制御するために使用されるLFBを、オブジェクト。このような成分は、等FEState [RFC5812]、ベンダーを含みます"
    },
    {
      "indent": 3,
      "text": "These LFBs are detailed in Section 7.3.",
      "ja": "これらのLFBsは、7.3節で詳述されています。"
    },
    {
      "indent": 0,
      "text": "4.4. Protocol Scenarios",
      "section_title": true,
      "ja": "4.4. プロトコルシナリオ"
    },
    {
      "indent": 3,
      "text": "This section provides a very high level description of sample message sequences between a CE and an FE. For protocol message encoding refer to Section 6.1, and for the semantics of the protocol refer to Section 4.3.",
      "ja": "このセクションでは、CEとFEとの間のサンプルのメッセージシーケンスの非常に高いレベルの記述を提供します。プロトコルメッセージのエンコードについては、セクション6.1を参照してください、とプロトコルの意味論については、セクション4.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Association Setup State",
      "section_title": true,
      "ja": "4.4.1. 協会のセットアップ状態"
    },
    {
      "indent": 3,
      "text": "The associations among CEs and FEs are initiated via the Association Setup message from the FE. If a Setup Request is granted by the CE, a successful Setup Response message is sent to the FE. If CEs and FEs are operating in an insecure environment, then the security associations have to be established between them before any association messages can be exchanged. The TML MUST take care of establishing any security associations.",
      "ja": "CEとFE間の関連付けはFEから協会セットアップメッセージを介して開始されています。セットアップ要求は、CEによって付与されている場合は、成功したセットアップ応答メッセージは、FEに送信されます。 CEとFEが安全でない環境で動作している場合は、セキュリティアソシエーションは、任意の関連メッセージを交換することができる前に、それらの間に確立する必要があります。 TMLは、すべてのセキュリティアソシエーションを確立するの世話をしなければなりません。"
    },
    {
      "indent": 3,
      "text": "This is typically followed by capability query, topology query, etc. When the FE is ready to start processing the data path, it sets the FEO FEState component to OperEnable (refer to [RFC5812] for details) and reports it to the CE as such when it is first queried. Typically, the FE is expected to be ready to process the data path before it associates, but there may be rare cases where it needs time do some pre-processing -- in such a case, the FE will start in the OperDisable state and when it is ready will transition to the OperEnable state. An example of an FE starting in OperDisable then transitioning to OperEnable is illustrated in Figure 8. The CE could at any time also disable the FE's data path operations by setting the FEState to AdminDisable. The FE MUST NOT process packets during this state unless the CE sets the state back to OperEnable. These sequences of messages are illustrated in Figure 8 below.",
      "ja": "これは、典型的には、FEは、データパスの処理を開始する準備ができている場合、それは等FEO FEStateのOperEnableに対する成分（詳細は[RFC5812]参照）とCEにレポートを設定する等の機能クエリ、トポロジ・クエリ、続いてそれが最初に照会されたとき。典型的には、FEは、それが関連付け前にデータパスを処理する準備ができると予想されるが、それは時間がいくつかの前処理を行う必要があるまれな場合がある - そのような場合には、FEがOperDisable状態で開始するときOperEnable状態に移行します準備ができています。 FEは、次にOperEnableに移行OperDisableに出発の例は、CEは、任意の時点でもAdminDisableにFEStateを設定することにより、FEのデータパスの動作を無効に可能性が図8に示されています。 CEが戻っOperEnableに状態を設定しない限り、FEは、この状態の間、パケットを処理してはいけません。メッセージのこれらの配列は、以下の図8に示されています。"
    },
    {
      "indent": 11,
      "text": "FE PL CE PL",
      "ja": "FE PL CE PL"
    },
    {
      "indent": 13,
      "text": "|                       |\n|   Asso Setup Req      |\n|---------------------->|\n|                       |\n|   Asso Setup Resp     |\n|<----------------------|\n|                       |\n| LFBx Query capability |\n|<----------------------|\n|                       |\n| LFBx Query Resp       |\n|---------------------->|\n|                       |\n| FEO Query (Topology)  |\n|<----------------------|\n|                       |\n| FEO Query Resp        |\n|---------------------->|\n|                       |\n| FEO OperEnable Event  |\n|---------------------->|\n|                       |\n|  Config FEO Adminup   |\n|<----------------------|\n|                       |\n| FEO Config-Resp       |\n|---------------------->|\n|                       |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 8: Message Exchange between CE and FE to Establish an NE Association",
      "ja": "図8：CEとFE間のメッセージ交換NEアソシエーションを確立します"
    },
    {
      "indent": 3,
      "text": "On successful completion of this state, the FE joins the NE.",
      "ja": "この状態が正常に完了すると、FEはNEに参加します。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Association Established State or Steady State",
      "section_title": true,
      "ja": "4.4.2. 協会設立の状態または定常状態"
    },
    {
      "indent": 3,
      "text": "In this state, the FE is continuously updated or queried. The FE may also send asynchronous event notifications to the CE, synchronous Heartbeat messages, or Packet Redirect message to the CE. This continues until a termination (or deactivation) is initiated by either the CE or FE. Figure 9 below, helps illustrate this state.",
      "ja": "この状態では、FEは継続的に更新または照会されます。 FEはまた、CEをCEへの非同期イベント通知、同期ハートビートメッセージ、またはパケットリダイレクトメッセージを送信することができます。終了（又は不活性化）がCEまたはFEのいずれかによって開始されるまで続きます。 9下の図は、この状態を説明するのに役立ちます。"
    },
    {
      "indent": 11,
      "text": "FE PL CE PL",
      "ja": "FE PL CE PL"
    },
    {
      "indent": 13,
      "text": "|                              |\n|    Heartbeat                 |\n|<---------------------------->|\n|                              |\n|   Heartbeat                  |\n|----------------------------->|\n|                              |\n| Config-set LFBy (Event sub.) |\n|<-----------------------------|\n|                              |\n|     Config Resp LFBy         |\n|----------------------------->|\n|                              |\n|  Config-set LFBx Component   |\n|<-----------------------------|\n|                              |\n|     Config Resp  LFBx        |\n|----------------------------->|\n|                              |\n|Config-Query LFBz (Stats)     |\n|<--------------------------- -|\n|                              |\n|    Query Resp LFBz           |\n|----------------------------->|\n|                              |\n|    FE Event Report           |\n|----------------------------->|\n|                              |\n|  Config-Del LFBx Component   |\n|<-----------------------------|\n|                              |\n|     Config Resp LFBx         |\n|----------------------------->|\n|                              |\n|    Packet Redirect LFBx      |\n|----------------------------->|\n|                              |\n|    Heartbeat                 |\n|<-----------------------------|\n.                              .\n.                              .\n|                              |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 9: Message Exchange between CE and FE during Steady-State Communication",
      "ja": "図9：定常通信時にCEとFE間のメッセージ交換"
    },
    {
      "indent": 3,
      "text": "Note that the sequence of messages shown in the figure serve only as examples and the message exchange sequences could be different from what is shown in the figure. Also, note that the protocol scenarios described in this section do not include all the different message exchanges that would take place during failover. That is described in the HA section (Section 8).",
      "ja": "同図に示すメッセージのシーケンスは例としてのみ機能し、メッセージ交換シーケンスが図示されているものとは異なることができることに留意されたいです。また、このセクションで説明したプロトコルシナリオは、フェールオーバー中に行われるすべての異なるメッセージ交換が含まれていないことに注意してください。それはHAのセクション（セクション8）に記載されています。"
    },
    {
      "indent": 0,
      "text": "5. TML Requirements",
      "section_title": true,
      "ja": "5つのTMLの要件"
    },
    {
      "indent": 3,
      "text": "The requirements below are expected to be met by the TML. This text does not define how such mechanisms are delivered. As an example, the mechanisms to meet the requirements could be defined to be delivered via hardware or between 2 or more TML software processes on different CEs or FEs in protocol-level schemes.",
      "ja": "以下の要件は、TMLによって満たされることが期待されます。このテキストは、配信されているどのようなメカニズムを定義しません。一例として、要件を満たすためのメカニズムは、ハードウェアを介して、またはプロトコルレベル方式で異なる複数のCE又は複数のFEに2つの以上TMLソフトウェアプロセス間で配信されるように定義することができます。"
    },
    {
      "indent": 3,
      "text": "Each TML MUST describe how it contributes to achieving the listed ForCES requirements. If for any reason a TML does not provide a service listed below, a justification needs to be provided.",
      "ja": "各TMLは、それが記載されているのForCES要件の達成にどのように寄与するかを説明しなければなりません。何らかの理由でTMLは、下記のサービスを提供していない場合は、正当な理由が提供される必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementations that support the ForCES protocol specification MUST implement [RFC5811]. Note that additional TMLs might be specified in the future, and if a new TML defined in the future that meets the requirements listed here proves to be better, then the \"MUST implement TML\" may be redefined.",
      "ja": "ForCESプロトコル仕様をサポートする実装は、[RFC5811]を実装しなければなりません。追加TMLsが、将来的に指定されるかもしれないことに注意してください、とここに記載されている要件を満たし、将来的に定義された新しいTMLが優れていることが判明した場合、その後、再定義することができる「TML実装しなければなりません」。"
    },
    {
      "indent": 3,
      "text": "1. Reliability",
      "section_title": true,
      "ja": "1.信頼性"
    },
    {
      "indent": 7,
      "text": "Various ForCES messages will require varying degrees of reliable\ndelivery via the TML.  It is the TML's responsibility to provide\nthese shades of reliability and describe how the different ForCES\nmessages map to reliability.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "The most common level of reliability is what we refer to as strict or robust reliability in which we mean no losses, corruption, or re-ordering of information being transported while ensuring message delivery in a timely fashion.",
      "ja": "信頼性の最も一般的なレベルでは、我々は何の損失、破損、または適時にメッセージ配信を確保しながら搬送されている情報の並べ替えを意味しないするなど厳しいや堅牢な信頼性を参照するものです。"
    },
    {
      "indent": 7,
      "text": "Payloads such as configuration from a CE and its response from an FE are mission critical and must be delivered in a robust reliable fashion. Thus, for information of this sort, the TML MUST either provide built-in protocol mechanisms or use a reliable transport protocol for achieving robust/strict reliability.",
      "ja": "このようCEからの設定およびFEからその応答として、ペイロードは、ミッションクリティカルであり、堅牢で信頼性の高い方法で送達されなければなりません。したがって、この種の情報は、TMLは内蔵プロトコルメカニズムを提供しなければなりませんのいずれか又は堅牢な/厳格な信頼性を達成するための信頼性の高いトランスポートプロトコルを使用します。"
    },
    {
      "indent": 7,
      "text": "Some information or payloads, such as redirected packets or packet sampling, may not require robust reliability (can tolerate some degree of losses). For information of this sort, the TML could define to use a mechanism that is not strictly reliable (while conforming to other TML requirements such as congestion control).",
      "ja": "そのようなリダイレクトされたパケットまたはパケットサンプリングなどの一部の情報またはペイロードは、（損失をある程度許容することができる）強固な信頼性を必要としない場合があります。この種の情報については、TMLは、（例えば、輻輳制御のような他のTML要件に準拠しながら）厳密に信頼できないメカニズムを使用するように定義することができます。"
    },
    {
      "indent": 7,
      "text": "Some information or payloads, such as heartbeat packets, may prefer timeliness over reliable delivery. For information of this sort, the TML could define to use a mechanism that is not strictly reliable (while conforming to other TML requirements such as congestion control).",
      "ja": "そのようなハートビートパケットのようないくつかの情報又はペイロードは、信頼性の高い配信の上に適時性を好むかもしれません。この種の情報については、TMLは、（例えば、輻輳制御のような他のTML要件に準拠しながら）厳密に信頼できないメカニズムを使用するように定義することができます。"
    },
    {
      "indent": 3,
      "text": "2. Security",
      "section_title": true,
      "ja": "2.セキュリティ"
    },
    {
      "indent": 7,
      "text": "TML provides security services to the ForCES PL.  Because a\nForCES PL is used to operate an NE, attacks designed to confuse,\ndisable, or take information from a ForCES-based NE may be seen\nas a prime objective during a network attack.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "An attacker in a position to inject false messages into a PL stream can affect either the FE's treatment of the data path (for example, by falsifying control data reported as coming from the CE) or the CE itself (by modifying events or responses reported as coming from the FE). For this reason, CE and FE node authentication and TML message authentication are important.",
      "ja": "PLストリームに偽のメッセージを注入する位置に、攻撃者は、として報告されたイベント、または応答を変更することによって（またはCE自体（例えば、制御CEから来るように報告されたデータを改竄することによって）データパスのFEの治療のいずれかに影響を与えることができ）FEから来ます。このため、CEとFEノード認証とTMLメッセージ認証は重要です。"
    },
    {
      "indent": 7,
      "text": "The PL messages may also contain information of value to an attacker, including information about the configuration of the network, encryption keys, and other sensitive control data, so care must be taken to confine their visibility to authorized users.",
      "ja": "ケアは、許可されたユーザへの可視性を制限するために取られなければならないので、PLメッセージも、ネットワークの構成に関する情報、暗号化キー、およびその他の重要な制御データを含む、攻撃者にとって価値の情報が含まれていてもよいです。"
    },
    {
      "indent": 7,
      "text": "* The TML MUST provide a mechanism to authenticate ForCES CEs and FEs, in order to prevent the participation of unauthorized CEs and unauthorized FEs in the control and data path processing of a ForCES NE.",
      "ja": "* TMLは、不正のCE、強制的にNEの制御及びデータパス処理における不正のFEの参加を防ぐために、のForCESのCEとFEを認証するためのメカニズムを提供しなければなりません。"
    },
    {
      "indent": 7,
      "text": "* The TML SHOULD provide a mechanism to ensure message authentication of PL data transferred from the CE to FE (and vice versa), in order to prevent the injection of incorrect data into PL messages.",
      "ja": "* TMLはPLメッセージに不正なデータの注入を防止するために、FE（およびその逆）にCEから転送されたPLデータのメッセージ認証を確保するためのメカニズムを提供しなければなりません。"
    },
    {
      "indent": 7,
      "text": "* The TML SHOULD provide a mechanism to ensure the confidentiality of data transferred from the ForCES PL, in order to prevent disclosure of PL-level information transported via the TML.",
      "ja": "* TMLはTMLを介して輸送PL-レベル情報の開示を防止するために強制しPLから転送されたデータの機密性を確保するためのメカニズムを提供しなければなりません。"
    },
    {
      "indent": 7,
      "text": "The TML SHOULD provide these services by employing TLS or IPsec.",
      "ja": "TMLは、TLSやIPsecを使用することにより、これらのサービスを提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. Congestion control",
      "section_title": true,
      "ja": "3.輻輳制御"
    },
    {
      "indent": 7,
      "text": "The transport congestion control scheme used by the TML needs to\nbe defined.  The congestion control mechanism defined by the TML\nMUST prevent transport congestive collapse [RFC2914] on either\nthe FE or CE side.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4. Uni/multi/broadcast addressing/delivery, if any",
      "section_title": true,
      "ja": "4.ユニ/マルチ/ブロードキャストのアドレス指定/配達、もしあれば"
    },
    {
      "indent": 7,
      "text": "If there is any mapping between PL- and TML-level uni/multi/\nbroadcast addressing, it needs to be defined.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5. HA decisions",
      "section_title": true,
      "ja": "5. HAの決定"
    },
    {
      "indent": 7,
      "text": "It is expected that availability of transport links is the TML's\nresponsibility.  However, based upon its configuration, the PL\nmay wish to participate in link failover schemes and therefore\nthe TML MUST support this capability.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Please refer to Section 8 for details.",
      "ja": "詳細については、セクション8を参照してください。"
    },
    {
      "indent": 3,
      "text": "6. Encapsulations used",
      "section_title": true,
      "ja": "使用6.カプセル化"
    },
    {
      "indent": 7,
      "text": "Different types of TMLs will encapsulate the PL messages on\ndifferent types of headers.  The TML needs to specify the\nencapsulation used.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7. Prioritization",
      "section_title": true,
      "ja": "7.優先順位付け"
    },
    {
      "indent": 7,
      "text": "It is expected that the TML will be able to handle up to 8\npriority levels needed by the PL and will provide preferential\ntreatment.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "While the TML needs to define how this is achieved, it should be noted that the requirement for supporting up to 8 priority levels does not mean that the underlying TML MUST be capable of providing up to 8 actual priority levels. In the event that the underlying TML layer does not have support for 8 priority levels, the supported priority levels should be divided between the available TML priority levels. For example, if the TML only supports 2 priority levels, 0-3 could go in one TML priority level, while 4-7 could go in the other.",
      "ja": "TMLは、これが達成される方法を定義する必要があるが、8つの優先順位レベルまでサポートするための要件は、基礎となるTML 8つの実際の優先レベルまで提供することができなければならないことを意味するものではないことに留意すべきです。基礎となるTML層8つの優先順位レベルをサポートしていない場合には、サポートされている優先順位は、利用可能なTML優先度レベルとの間で分割されなければなりません。 TMLはわずか2つの優先度レベルをサポートしている場合4-7は、他に行くことができる一方で、例えば、0-3は、1つのTML優先レベルに行くことができます。"
    },
    {
      "indent": 7,
      "text": "The TML MUST NOT re-order config packets with the same priority.",
      "ja": "TMLは、同じ優先度の設定パケットの順序を変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "8. Node Overload Prevention",
      "section_title": true,
      "ja": "8.ノードの過負荷防止"
    },
    {
      "indent": 7,
      "text": "The TML MUST define mechanisms it uses to help prevent node\noverload.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Overload results in starvation of node compute cycles and/or bandwidth resources, which reduces the operational capacity of a ForCES NE. NE node overload could be deliberately instigated by a hostile node to attack a ForCES NE and create a denial of service (DoS). It could also be created by a variety of other reasons such as large control protocol updates (e.g., BGP flaps), which consequently cause a high frequency of CE to FE table updates, HA failovers, or component failures, which migrate an FE or CE load overwhelming the new CE or FE, etc. Although the environments under which SIP and ForCES operate are different, [RFC5390] provides a good guide to generic node requirements one needs to guard for.",
      "ja": "ForCESのNEの運転容量を減少ノード計算サイクルおよび/または帯域幅リソースの飢餓に過負荷をもたらします。 NEノードの過負荷は、故意のForCES NEを攻撃し、サービス拒否（DoS）を作成するために、敵対的なノードによって扇動することができます。それはまた、結果的にFEまたはCEを移行FEテーブルの更新、HAのフェイルオーバー、またはコンポーネントの障害に対するCEの高周波を引き起こす大きな制御プロトコルの更新（例えば、BGPフラップ）のような他のさまざまな理由により作成することができますSIPと力が動作する環境下では異なるが、新しいCEまたはFE等を圧倒負荷、[RFC5390]は一つのために保護する必要がある一般的なノードの要件に良いガイドを提供します。"
    },
    {
      "indent": 7,
      "text": "A ForCES node CPU may be overwhelmed because the incoming packet rate is higher than it can keep up with -- in such a case, a node's transport queues grow and transport congestion subsequently follows. A ForCES node CPU may also be adversely overloaded with very few packets, i.e., no transport congestion at all (e.g., a in a DoS attack against a table hashing algorithm that overflows the table and/or keeps the CPU busy so it does not process other tasks). The TML node overload solution specified MUST address both types of node overload scenarios.",
      "ja": "このような場合には、ノードのトランスポートキューが成長し、交通渋滞が、その後、次の - のForCESノードCPUは、着信パケットレートが、それはついていくことができるよりも高くなっているので、圧倒かもしれません。 ForCESノードのCPUにも悪影響を非常に少数のパケット、すなわち、全く交通渋滞（例えば、テーブルをオーバーフローおよび/またはCPU忙しくテーブルのハッシュアルゴリズムに対するDoS攻撃では、それがないように、プロセスで過負荷にすることができます他のタスク）。指定されたTMLノード過負荷溶液は、ノードの過負荷シナリオの両方のタイプに対処しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1. TML Parameterization",
      "section_title": true,
      "ja": "5.1.  TMLのパラメータ"
    },
    {
      "indent": 3,
      "text": "It is expected that it should be possible to use a configuration reference point, such as the FEM or the CEM, to configure the TML.",
      "ja": "TMLを設定するために、FEMまたはCEMとして、設定基準点を使用することが可能であることが予想されます。"
    },
    {
      "indent": 3,
      "text": "Some of the configured parameters may include:",
      "ja": "設定されたパラメータの一部が含まれます。"
    },
    {
      "indent": 3,
      "text": "o PL ID",
      "ja": "PL ID O"
    },
    {
      "indent": 3,
      "text": "o Connection Type and associated data. For example, if a TML uses IP/TCP/UDP, then parameters such as TCP and UDP port and IP addresses need to be configured.",
      "ja": "O接続タイプと関連付けられたデータ。 TMLは、IP / TCP / UDPを使用した場合、そのようなTCPおよびUDPポートとIPアドレスなどのパラメータを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Number of transport connections",
      "ja": "交通機関の接続のO数"
    },
    {
      "indent": 3,
      "text": "o Connection capability, such as bandwidth, etc.",
      "ja": "O接続機能、帯域幅などなど"
    },
    {
      "indent": 3,
      "text": "o Allowed/supported connection QoS policy (or congestion control policy)",
      "ja": "O可/サポートされている接続のQoSポリシー（または輻輳制御ポリシー）"
    },
    {
      "indent": 0,
      "text": "6. Message Encapsulation",
      "section_title": true,
      "ja": "6.メッセージのカプセル化"
    },
    {
      "indent": 3,
      "text": "All PL PDUs start with a common header Section 6.1 followed by one or more TLVs Section 6.2, which may nest other TLVs Section 6.2.1. All fields are in network byte order.",
      "ja": "全てPL PDUがよい巣他のTLVセクション6.2.1一つ以上のTLV 6.2、続いて共通ヘッダセクション6.1で始まります。すべてのフィールドは、ネットワークバイト順です。"
    },
    {
      "indent": 0,
      "text": "6.1. Common Header",
      "section_title": true,
      "ja": "6.1. 共通ヘッダ"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|version| rsvd  | Message Type  |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Source ID                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Destination ID                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Correlator[63:32]                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Correlator[31:0]                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Flags                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 10: Common Header",
      "ja": "図10：共通ヘッダ"
    },
    {
      "indent": 3,
      "text": "The message is 32-bit aligned.",
      "ja": "メッセージは、32ビット整合されます。"
    },
    {
      "indent": 3,
      "text": "Version (4 bits): Version number. Current version is 1.",
      "ja": "バージョン（4ビット）：バージョン番号。現在のバージョンは1です。"
    },
    {
      "indent": 3,
      "text": "rsvd (4 bits): Unused at this point. A receiver should not interpret this field. Senders MUST set it to zero and receivers MUST ignore this field.",
      "ja": "RSVD（4ビット）：この時点で未使用。受信機は、このフィールドを解釈するべきではありません。送信者はゼロにそれを設定しなければなりませんし、受信機は、このフィールドを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Message Type (8 bits): Commands are defined in Section 7.",
      "ja": "メッセージタイプ（8ビット）：コマンドはセクション7で定義されています。"
    },
    {
      "indent": 3,
      "text": "Length (16 bits): length of header + the rest of the message in DWORDS (4-byte increments).",
      "ja": "長さ（16ビット）：ヘッダの長さ+ DWORDSにおけるメッセージの残りの部分（4バイト単位）。"
    },
    {
      "indent": 3,
      "text": "Source ID (32 bits):",
      "ja": "送信元ID（32ビット）："
    },
    {
      "indent": 3,
      "text": "Dest ID (32 bits):",
      "ja": "ID（32ビット）："
    },
    {
      "indent": 6,
      "text": "* Each of the source and destination IDs are 32-bit IDs that are unique NE-wide and that identify the termination points of a ForCES PL message.",
      "ja": "*ソースおよび宛先IDのそれぞれは、固有のNE-ワイドであり、それはのForCES PLメッセージの終端点を識別する32ビットのIDです。"
    },
    {
      "indent": 6,
      "text": "* IDs allow multi/broad/unicast addressing with the following approach:",
      "ja": "* IDは、次の方法で対処するマルチ/広範な/ユニキャストを許可します："
    },
    {
      "indent": 10,
      "text": "a.  A split address space is used to distinguish FEs from CEs.\n    Even though in a large NE there are typically two or more\n    orders of magnitude of more FEs than CEs, the address\n    space is split uniformly for simplicity.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "b. The address space allows up to 2^30 (over a billion) CEs and the same amount of FEs.",
      "ja": "B。アドレス空間は、2 ^ 30（億以上）CEとFEの同じ量を最大ことができます。"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|TS |                           sub-ID                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 11: ForCES ID Format",
      "ja": "図11：のForCES IDのフォーマット"
    },
    {
      "indent": 11,
      "text": "c. The 2 most significant bits called Type Switch (TS) are used to split the ID space as follows:",
      "ja": "C。次のように2つの最上位ビットと呼ばれるタイプのスイッチ（TS）は、ID空間を分割するために使用されています。"
    },
    {
      "indent": 3,
      "text": "TS        Corresponding ID range       Assignment\n--        ----------------------       ----------\n0b00      0x00000000 to 0x3FFFFFFF     FE IDs (2^30)\n0b01      0x40000000 to 0x7FFFFFFF     CE IDs (2^30)\n0b10      0x80000000 to 0xBFFFFFFF     reserved\n0b11      0xC0000000 to 0xFFFFFFEF     multicast IDs (2^30 - 16)\n0b11      0xFFFFFFF0 to 0xFFFFFFFC     reserved\n0b11      0xFFFFFFFD                   all CEs broadcast\n0b11      0xFFFFFFFE                   all FEs broadcast\n0b11      0xFFFFFFFF                   all FEs and CEs (NE) broadcast",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 12: Type Switch ID Space",
      "ja": "図12：タイプスイッチIDスペース"
    },
    {
      "indent": 6,
      "text": "* Multicast or broadcast IDs are used to group endpoints (such as CEs and FEs). As an example, one could group FEs in some functional group, by assigning a multicast ID. Likewise, subgroups of CEs that act, for instance, in a back-up mode may be assigned a multicast ID to hide them from the FE.",
      "ja": "*マルチキャストまたはブロードキャストIDは、（例えば、CEとFEなど）グループエンドポイントに使用されます。一例として、一つは、マルチキャストIDを割り当てることにより、いくつかの官能基のグループのFE、できました。同様に、バックアップモードでは、例えば、行動CEのサブグループはFEからそれらを隠すために、マルチキャストIDを割り当ててもよいです。"
    },
    {
      "indent": 10,
      "text": "+   Multicast IDs can be used for both source or destination\n    IDs.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "+ Broadcast IDs can be used only for destination IDs.",
      "ja": "+ブロードキャストIDは、先のIDにのみ使用することができます。"
    },
    {
      "indent": 6,
      "text": "* This document does not discuss how a particular multicast ID is associated to a given group though it could be done via configuration process. The list of IDs an FE owns or is part of are listed on the FE Object LFB.",
      "ja": "*このドキュメントは、コンフィギュレーションプロセスを介して行うことができるものの、特定のマルチキャストIDが与えられたグループに関連付けられている方法については説明しません。 IDのリストFEは、所有しているか、FEオブジェクトLFBに上場されているの一部です。"
    },
    {
      "indent": 3,
      "text": "Correlator (64 bits):",
      "ja": "相関器（64ビット）："
    },
    {
      "indent": 6,
      "text": "This field is set by the CE to correlate ForCES Request messages with the corresponding Response messages from the FE. Essentially, it is a cookie. The correlator is handled transparently by the FE, i.e., for a particular Request message the FE MUST assign the same correlator value in the corresponding Response message. In the case where the message from the CE does not elicit a response, this field may not be useful.",
      "ja": "このフィールドは、FEからの対応する応答メッセージと力要求メッセージを相関させるためにCEによって設定されています。基本的に、それはクッキーです。相関器は、FEは、対応する応答メッセージに同じ相関値を割り当てる必要があり、特定の要求メッセージのために、すなわち、FEによって透過的に処理されます。 CEからのメッセージが応答を誘発しない場合、このフィールドは有用ではないかもしれません。"
    },
    {
      "indent": 6,
      "text": "The correlator field could be used in many implementations in specific ways by the CE. For example, the CE could split the correlator into a 32-bit transactional identifier and 32-bit message sequence identifier. Another example is a 64-bit pointer to a context block. All such implementation-specific uses of the correlator are outside the scope of this specification.",
      "ja": "相関フィールドには、CEによって特定の方法で多くの実装で使用することができます。例えば、CEは、32ビットのトランザクション識別子と32ビットのメッセージシーケンス識別子に相関器を分割することができました。別の例では、コンテキスト・ブロックに64ビット・ポインタです。相関器のすべてのそのような実装固有の用途は、本明細書の範囲外です。"
    },
    {
      "indent": 6,
      "text": "It should be noted that the correlator is transmitted on the network as if it were a 64-bit unsigned integer with the leftmost or most significant octet (bits 63-56) transmitted first.",
      "ja": "左端または最上位オクテット（ビット63から56）最初に送信した64ビット符号なし整数であるかのように、相関器は、ネットワーク上で送信されることに留意すべきです。"
    },
    {
      "indent": 6,
      "text": "Whenever the correlator field is not relevant, because no message is expected, the correlator field is set to 0.",
      "ja": "何のメッセージが予想されていないので、相関フィールドは、関連していないときはいつでも、相関フィールドが0に設定されています。"
    },
    {
      "indent": 3,
      "text": "Flags (32 bits): Identified so far:",
      "ja": "フラグ（32ビット）：これまでに同定されました："
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   |     |     |   | |   |                                     |\n|ACK| Pri |Rsr  |EM |A|TP |     Reserved                        |\n|   |     | vd. |   |T|   |                                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 13: Header Flags",
      "ja": "図13：ヘッダーフラグ"
    },
    {
      "indent": 3,
      "text": "- ACK: ACK indicator (2 bits)",
      "ja": " -  ACK：ACKインジケータ（2ビット）"
    },
    {
      "indent": 3,
      "text": "The ACK indicator flag is only used by the CE when sending a Config message (Section 7.6.1) or an HB message (Section 7.10) to indicate to the message receiver whether or not a response is required by the sender. Note that for all other messages than the Config message or the HB message this flag MUST be ignored.",
      "ja": "応答が送信者によって必要とされているか否かをメッセージ受信機に指示するためにConfigメッセージ（セクション7.6.1）又はHBメッセージ（7.10）を送信する場合、ACKインジケータフラグはCEによって使用されます。 ConfigメッセージやHBメッセージよりも他のすべてのメッセージのために、このフラグは無視されなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The flag values are defined as follows:",
      "ja": "次のようにフラグの値が定義されています。"
    },
    {
      "indent": 6,
      "text": "'NoACK' (0b00) - to indicate that the message receiver MUST NOT send any Response message back to this message sender.",
      "ja": "「NOACKは」（0b00と） - メッセージの受信機は、このメッセージの送信者に戻って任意の応答メッセージを送ってはいけませんことを示します。"
    },
    {
      "indent": 6,
      "text": "'SuccessACK'(0b01) - to indicate that the message receiver MUST send a Response message back only when the message has been successfully processed by the receiver.",
      "ja": "「SuccessACK」（0B01） - メッセージが正常に受信機によって処理された場合にのみ、メッセージの受信者が戻って応答メッセージを送らなければなりませんことを示します。"
    },
    {
      "indent": 6,
      "text": "'FailureACK'(0b10) - to indicate that the message receiver MUST send a Response message back only when there is failure by the receiver in processing (executing) the message. In other words, if the message can be processed successfully, the sender will not expect any response from the receiver.",
      "ja": "「FailureACK」（0b10と） - 処理における受信機による故障（実行）メッセージがある場合にのみ、メッセージ受信機はバック応答メッセージを送信しなければならないことを示します。メッセージが正常に処理することができます言い換えれば、送信側は受信側からの応答を期待しないであろう。"
    },
    {
      "indent": 6,
      "text": "'AlwaysACK' (0b11) - to indicate that the message receiver MUST send a Response message.",
      "ja": "「AlwaysACK」（0b11に） - メッセージ受信応答メッセージを送信しなければならないことを示します。"
    },
    {
      "indent": 3,
      "text": "Note that in above definitions, the term success implies a complete execution without any failure of the message. Anything else than a complete successful execution is defined as a failure for the message processing. As a result, for the execution modes (defined in Section 4.3.1.1) like execute-all-or-none, execute-until-failure, and continue-execute-on-failure, if any single operation among several operations in the same message fails, it will be treated as a failure and result in a response if the ACK indicator has been set to 'FailureACK' or 'AlwaysACK'.",
      "ja": "上記の定義では、長期的な成功は、メッセージのいずれかの障害が発生することなく、完全な実行を意味することに注意してください。完全に正常に実行されるよりもそれ以外のものは、メッセージ処理のための障害として定義されます。結果として、実行-すべてか無か様（セクション4.3.1.1で定義された）実行モードのためにまで障害実行、および継続実行オン故障、同じでいくつかの動作のうち、任意の単一の動作場合メッセージが失敗し、それが失敗として扱われ、ACKインジケータが「FailureACK」または「AlwaysACK」に設定されている場合は応答をもたらします。"
    },
    {
      "indent": 3,
      "text": "Also note that, other than in Config and HB messages, requirements for responses of messages are all given in a default way rather than by ACK flags. The default requirements of these messages and the expected responses are summarized below. Detailed descriptions can be found in the individual message definitions:",
      "ja": "また、コンフィグとHBメッセージ以外の、メッセージの応答のための要件はすべてデフォルトで仕方なく、ACKフラグによって与えられている、ということに注意してください。これらのメッセージと予想される応答のデフォルトの要件は以下のとおりです。詳細な説明は、個々のメッセージ定義に見つけることができます："
    },
    {
      "indent": 11,
      "text": "+ Association Setup message always expects a response.",
      "ja": "+協会セットアップメッセージは、常に応答を期待しています。"
    },
    {
      "indent": 11,
      "text": "+ Association Teardown Message, and Packet Redirect message, never expect responses.",
      "ja": "+協会ティアダウンメッセージ、およびパケットリダイレクトメッセージは、応答を期待することはありません。"
    },
    {
      "indent": 11,
      "text": "+ Query message always expects a response.",
      "ja": "+クエリメッセージは常に応答を期待しています。"
    },
    {
      "indent": 11,
      "text": "+ Response message never expects further responses.",
      "ja": "+応答メッセージには、さらに応答を期待することはありません。"
    },
    {
      "indent": 3,
      "text": "- Pri: Priority (3 bits)",
      "ja": " - ぷり：優先度（3ビット）"
    },
    {
      "indent": 3,
      "text": "ForCES protocol defines 8 different levels of priority (0-7). The priority level can be used to distinguish between different protocol message types as well as between the same message type. The higher the priority value, the more important the PDU is. For example, the REDIRECT packet message could have different priorities to distinguish between routing protocol packets and ARP packets being redirected from FE to CE. The normal priority level is 1. The different priorities imply messages could be re-ordered; however, re-ordering is undesirable when it comes to a set of messages within a transaction and caution should be exercised to avoid this.",
      "ja": "ForCESプロトコルは、優先順位（0-7）の8つの異なるレベルを定義します。優先レベルは、異なるプロトコルメッセージタイプ間ならびに同じメッセージタイプを区別するために使用することができます。優先度の値が高いほど、より重要なPDUです。例えば、REDIRECTパケットメッセージはFEからCEにリダイレクトされるルーティングプロトコルパケットとARPパケットを区別するために異なる優先度を有することができます。異なる優先順位がメッセージを再順序付けすることができる暗示1.通常の優先度です。しかし、それはトランザクションと注意内のメッセージのセットになると再配列が望ましくないこの問題を回避するために行使されなければなりません。"
    },
    {
      "indent": 3,
      "text": "- EM: Execution Mode (2 bits)",
      "ja": " -  EM：実行モード（2ビット）"
    },
    {
      "indent": 3,
      "text": "There are 3 execution modes; refer to Section 4.3.1.1 for details.",
      "ja": "3つの実行モードがあります。詳細については、4.3.1.1項を参照してください。"
    },
    {
      "indent": 6,
      "text": "Reserved..................... (0b00)",
      "raw": true
    },
    {
      "indent": 6,
      "text": "`execute-all-or-none` ....... (0b01)",
      "ja": "`実行-NONE`全かを.......（0B01）"
    },
    {
      "indent": 6,
      "text": "`execute-until-failure` ..... (0b10)",
      "ja": "`実行-まで-failure` .....（0b10と）"
    },
    {
      "indent": 6,
      "text": "`continue-execute-on-failure` (0b11)",
      "ja": "`継続実行オンfailure`（0b11に）"
    },
    {
      "indent": 3,
      "text": "- AT: Atomic Transaction (1 bit)",
      "ja": " -  AT：アトミック・トランザクション（1ビット）"
    },
    {
      "indent": 3,
      "text": "This flag indicates if the message is a stand-alone message or one of multiple messages that belong to 2PC transaction operations. See Section 4.3.1.2.2 for details.",
      "ja": "メッセージは、スタンドアロンのメッセージまたは2PCトランザクション・オペレーションに属している複数のメッセージのうちの1つである場合、このフラグを示します。詳細については、セクション4.3.1.2.2を参照してください。"
    },
    {
      "indent": 6,
      "text": "Stand-alone message ......... (0b0)",
      "raw": true
    },
    {
      "indent": 6,
      "text": "2PC transaction message ..... (0b1)",
      "ja": "2PCトランザクションメッセージ.....（0B1）"
    },
    {
      "indent": 3,
      "text": "- TP: Transaction Phase (2 bits)",
      "ja": " -  TP：トランザクション相（2ビット）"
    },
    {
      "indent": 3,
      "text": "A message from the CE to the FE within a transaction could be indicative of the different phases the transaction is in. Refer to Section 4.3.1.2.2 for details.",
      "ja": "トランザクション内のFEへのCEからのメッセージは、トランザクションが中にある異なる相の指標である可能性があります。詳細については、セクション4.3.1.2.2を参照してください。"
    },
    {
      "indent": 6,
      "text": "SOT (start of transaction) ..... (0b00)",
      "ja": "SOT（トランザクションの開始）.....（0b00と）"
    },
    {
      "indent": 6,
      "text": "MOT (middle of transaction) .... (0b01)",
      "ja": "MOT（トランザクションの途中）....（0B01）"
    },
    {
      "indent": 6,
      "text": "EOT (end of transaction) ........(0b10)",
      "ja": "EOT（トランザクションの終了）........（0b10と）"
    },
    {
      "indent": 6,
      "text": "ABT (abort) .....................(0b11)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6.2. Type Length Value (TLV) Structuring",
      "section_title": true,
      "ja": "6.2. タイプ長さ値（TLV）構造化"
    },
    {
      "indent": 3,
      "text": "TLVs are extensively used by the ForCES protocol. TLVs have some very nice properties that make them a good candidate for encoding the XML definitions of the LFB class model. These are:",
      "ja": "TLVが広範囲のForCESプロトコルによって使用されています。 TLVがそれらLFBクラスモデルのXML定義をエンコードするための良い候補にするいくつかの非常に素晴らしい特性を有しています。これらは："
    },
    {
      "indent": 3,
      "text": "o Providing for binary type-value encoding that is close to the XML string tag-value scheme.",
      "ja": "XML文字列タグ値のスキームに近いバイナリタイプ値の符号化を提供するO。"
    },
    {
      "indent": 3,
      "text": "o Allowing for fast generalized binary-parsing functions.",
      "ja": "高速の一般バイナリ解析関数を可能にO。"
    },
    {
      "indent": 3,
      "text": "o Allowing for forward and backward tag compatibility. This is equivalent to the XML approach, i.e., old applications can ignore new TLVs and newer applications can ignore older TLVs.",
      "ja": "前方と後方のタグ互換性のために許可O。これはつまり、古いアプリケーションが新しいTLVを無視することができますし、新しいアプリケーションは、古いTLVを無視することができ、XMLのアプローチに相当します。"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| TLV Type                    | TLV Length                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Value (Essentially the TLV Data)                   |\n~                                                               ~\n~                                                               ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 14: TLV Representation",
      "ja": "図14：TLV表現"
    },
    {
      "indent": 3,
      "text": "TLV Type (16):",
      "ja": "TLVタイプ（16）："
    },
    {
      "indent": 3,
      "text": "The TLV type field is 2 octets, and semantically indicates the type of data encapsulated within the TLV.",
      "ja": "TLVタイプフィールドは、2つのオクテットであり、意味的TLV内にカプセル化されたデータの種類を示します。"
    },
    {
      "indent": 3,
      "text": "TLV Length (16):",
      "ja": "TLVの長さ（16）："
    },
    {
      "indent": 3,
      "text": "The TLV length field is 2 octets, and includes the length of the TLV type (2 octets), TLV Length (2 octets), and the length of the TLV data found in the value field, in octets. Note that this length is the actual length of the value, before any padding for alignment is added.",
      "ja": "TLVの長さフィールドは、2つのオクテットで、オクテットでTLVタイプの長さ（2つのオクテット）、TLVの長さ（2つのオクテット）、および値のフィールドに見つかったTLVデータの長さを含みます。位置合わせのための任意のパディングが追加される前に、この長さは、値の実際の長さであることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "TLV Value (variable):",
      "ja": "TLV値（変数）："
    },
    {
      "indent": 3,
      "text": "The TLV value field carries the data. For extensibility, the TLV value may in fact be a TLV. Padding is required when the length is not a multiple of 32 bits, and is the minimum number of octets required to bring the TLV to a multiple of 32 bits. The length of the value before padding is indicated by the TLV Length field.",
      "ja": "TLV値フィールドは、データを運びます。拡張性のために、TLV値は、実際にはTLVかもしれません。長さが32ビットの倍数ではなく、32ビットの倍数にTLVをもたらすために必要なオクテット数の最小値である場合のパディングが必要です。パディング前の値の長さは、TLVの長さフィールドによって示されます。"
    },
    {
      "indent": 3,
      "text": "Note: The value field could be empty, which implies the minimal length a TLV could be is 4 (length of \"T\" field and length of \"L\" field).",
      "ja": "注：値フィールドはTLVがあり得る最小の長さを意味しており、空である可能性は、図4（「T」フィールドと「L」フィールドの長さの長さ）です。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Nested TLVs",
      "section_title": true,
      "ja": "6.2.1. ネストされたTLV"
    },
    {
      "indent": 3,
      "text": "TLV values can be other TLVs. This provides the benefits of protocol flexibility (being able to add new extensions by introducing new TLVs when needed). The nesting feature also allows for a conceptual optimization with the XML LFB definitions to binary PL representation (represented by nested TLVs).",
      "ja": "TLV値は、他のTLVすることができます。これは、（必要なときに新しいTLVを導入することにより、新しい拡張機能を追加することがある）プロトコルの柔軟性の利点を提供します。ネスティング機能は、（ネストのTLVで表される）は、バイナリPL表現にXMLのLFB定義と概念の最適化を可能にします。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Scope of the T in TLV",
      "section_title": true,
      "ja": "6.2.2.  TLVでのTの範囲"
    },
    {
      "indent": 3,
      "text": "There are two global name scopes for the \"Type\" in the TLV. The first name scope is for OPER-TLVs and is defined in A.4 whereas the second name scope is outside OPER-TLVs and is defined in section A.2.",
      "ja": "TLVでの「タイプ」には2つのグローバル名のスコープがあります。最初の名前スコープはOPER-TLVのためのものであり、2番目の名前スコープ外OPER-のTLVであり、セクションA.2に定義されているのに対し、A.4で定義されています。"
    },
    {
      "indent": 0,
      "text": "6.3. ILV",
      "section_title": true,
      "ja": "6.3.  ILV"
    },
    {
      "indent": 3,
      "text": "The ILV is a slight variation of the TLV. This sets the type (\"T\") to be a 32-bit local index that refers to a ForCES component ID (refer to Section 6.4.1).",
      "ja": "ILVは、TLVのわずかな変化です。これは、（セクション6.4.1を参照）のForCESコンポーネントIDを指す32ビットのローカル索引であるとタイプ（「T」）を設定します。"
    },
    {
      "indent": 3,
      "text": "The ILV length field is a 4-octet integer, and includes the length of the ILV type (4 octets), ILV Length (4 octets), and the length of the ILV data found in the value field, in octets. Note that, as in the case of the TLV, this length is the actual length of the value, before any padding for alignment is added.",
      "ja": "ILV長フィールドは、4オクテットの整数であり、ILV型（4つのオクテット）、ILV長（4つのオクテット）、およびオクテットで、値フィールドに見出さILVデータの長さの長さを含みます。位置合わせのための任意のパディングが追加される前に、TLVの場合のように、この長さは、値の実際の長さであることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Identifier                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Length                                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Value                                  |\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 15: ILV Representation",
      "ja": "図15：ILV表現"
    },
    {
      "indent": 3,
      "text": "It should be noted that the \"I\" values are of local scope and are defined by the data declarations from the LFB definition. Refer to Section 7.1.8 for discussions on usage of ILVs.",
      "ja": "「I」の値がローカルスコープのものであり、LFB定義からデータ宣言によって定義されることに留意されたいです。 ILVsの使用に関する議論については、セクション7.1.8を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.4. Important Protocol Encapsulations",
      "section_title": true,
      "ja": "6.4. 重要なプロトコルカプセル化"
    },
    {
      "indent": 3,
      "text": "In this section, we review a few encapsulation concepts that are used by the ForCES protocol for its operations.",
      "ja": "このセクションでは、我々はその操作のためのForCESプロトコルによって使用されているいくつかのカプセル化の概念を確認します。"
    },
    {
      "indent": 3,
      "text": "We briefly re-introduce two concepts, paths, and keys, from the ForCES model [RFC5812] in order to provide context. The reader is referred to [RFC5812] for a lot of the finer details.",
      "ja": "我々は、簡単にコンテキストを提供するための力モデルからの二つの概念、パス、およびキー、[RFC5812]を再導入。読者はより細かい細部の多くのために[RFC5812]と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "For readability reasons, we introduce the encapsulation schemes that are used to carry content in a protocol message, namely, FULLDATA-TLV, SPARSEDATA-TLV, and RESULT-TLV.",
      "ja": "読みやすさの理由から、私たちはプロトコルメッセージのコンテンツを運ぶために使用されているカプセル化スキームを導入、すなわち、FULLDATA-TLV、SPARSEDATA-TLV、その結果-TLV。"
    },
    {
      "indent": 0,
      "text": "6.4.1. Paths",
      "section_title": true,
      "ja": "6.4.1. パス"
    },
    {
      "indent": 3,
      "text": "The ForCES model [RFC5812] defines an XML-based language that allows for a formal definition of LFBs. This is similar to the relationship between ASN.1 and SNMP MIB definition (MIB being analogous to the LFB and ASN.1 being analogous to the XML model language). Any entity that the CE configures on an FE MUST be formally defined in an LFB. These entities could be scalars (e.g., a 32-bit IPv4 address) or vectors (such as a nexthop table). Each entity within the LFB is given a numeric 32-bit identifier known as a \"component id\". This scheme allows the component to be \"addressed\" in a protocol construct.",
      "ja": "ForCESモデル[RFC5812]はLFBsの正式な定義を可能にするXMLベースの言語を定義します。これは、ASN.1やSNMP MIB定義（MIBはLFBに類似しているとASN.1は、XMLモデル言語に類似している）との間の関係に似ています。 CEは、FEに設定する任意のエンティティが正式にLFBで定義する必要があります。これらのエンティティは、スカラー（例えば、32ビットのIPv4アドレス）または（例えばネクストホップテーブルのような）ベクターであってもよいです。 LFB内の各エンティティは、「コンポーネントID」として知られている数値の32ビットの識別子が与えられます。この方式では、コンポーネントは、プロトコル構築物の「アドレス指定」することを可能にします。"
    },
    {
      "indent": 3,
      "text": "These addressable entities could be hierarchical (e.g., a table column or a cell within a table row). In order to address hierarchical data, the concept of a path is introduced by the model [RFC5812]. A path is a series of 32-bit component IDs that are typically presented in a dot-notation (e.g., 1.2.3.4). Section 7 formally defines how paths are used to reference data that is being encapsulated within a protocol message.",
      "ja": "これらのアドレス指定可能なエンティティは、階層的であり得る（例えば、テーブル列またはテーブル列内のセル）。階層データに対処するために、パスの概念は、モデル[RFC5812]によって導入されます。経路は、典型的には、ドット表記（例えば、1.2.3.4）に提示されている32ビットコンポーネントIDの系列です。セクション7は、正式経路がプロトコルメッセージ内にカプセル化されているデータを参照するために使用される方法を定義します。"
    },
    {
      "indent": 0,
      "text": "6.4.2. Keys",
      "section_title": true,
      "ja": "6.4.2. キー"
    },
    {
      "indent": 3,
      "text": "The ForCES model [RFC5812] defines two ways to address table rows. The standard/common mechanism is to allow table rows to be referenced by a 32-bit index. The secondary mechanism is via keys that allow for content addressing. An example key is a multi-field content key that uses the IP address and prefix length to uniquely reference an IPv4 routing table row. In essence, while the common scheme to address a table row is via its table index, a table row's path could be derived from a key. The KEYINFO-TLV (Section 7) is used to carry the data that is used to do the lookup.",
      "ja": "ForCESモデル[RFC5812]は表の行をアドレス指定する2つの方法を定義します。標準/一般的なメカニズムは、テーブルの行は、32ビットのインデックスにより参照することができるようにすることです。第二のメカニズムは、コンテンツのアドレス指定を可能とするキーです。例えば、キーが一意のIPv4ルーティングテーブルの行を参照するIPアドレスとプレフィックス長を使用してマルチフィールドのコンテンツ鍵です。表の行をアドレス指定するための一般的なスキームは、そのテーブルインデックスを介してであるが本質的に、テーブルの行のパスは、鍵から導出することができます。 KeyInfoに-TLV（第7節）は、ルックアップを行うために使用されるデータを運ぶために使用されます。"
    },
    {
      "indent": 0,
      "text": "6.4.3. DATA TLVs",
      "section_title": true,
      "ja": "6.4.3. データのTLV"
    },
    {
      "indent": 3,
      "text": "Data from or to the FE is carried in two types of TLVs: FULLDATA-TLV and SPARSEDATA-TLV. Responses to operations executed by the FE are carried in RESULT-TLVs.",
      "ja": "FULLDATA-TLVとSPARSEDATA-TLV：FEからかへのデータは、のTLVの2種類で運ばれます。 FEが実行する操作に応答がRESULT-のTLVで搬送されます。"
    },
    {
      "indent": 3,
      "text": "In FULLDATA-TLV, the data is encoded in such a way that a receiver of such data, by virtue of being armed with knowledge of the path and the LFB definition, can infer or correlate the TLV \"Value\" contents. This is essentially an optimization that helps reduce the amount of description required for the transported data in the protocol grammar. Refer to Appendix C for an example of FULLDATA-TLVs.",
      "ja": "FULLDATA-TLVでは、データは、データの受信機は、経路の知識とLFB定義で武装されることによって、推測またはTLV「値」の内容を相関させることができるような方法で符号化されます。これは本質的に、プロトコルの文法で転送されるデータのために必要な記述の量を減らすことができます最適化です。 FULLDATA-のTLVの例については、付録Cを参照。"
    },
    {
      "indent": 3,
      "text": "A number of operations in ForCES will need to reference optional data within larger structures. The SPARSEDATA-TLV encoding is provided to make it easier to encapsulate optionally appearing data components. Refer to Appendix C for an example of SPARSEDATA-TLV.",
      "ja": "力の操作の数は、より大きな構造内の任意のデータを参照する必要があります。 SPARSEDATA-TLVエンコーディングは、それが簡単に任意に現れるデータ・コンポーネントをカプセル化するために設けられています。 SPARSEDATA-TLVの例については、付録Cを参照。"
    },
    {
      "indent": 3,
      "text": "RESULT-TLVs carry responses back from the FE based on a config issued by the CE. Refer to Appendix C for examples of RESULT-TLVs and Section 7.1.7 for layout.",
      "ja": "RESULT-TLVがCEによって発行された設定に基づいてバックFEからの応答を運びます。 RESULT-のTLVとレイアウトについては、セクション7.1.7の例については、付録Cを参照してください。"
    },
    {
      "indent": 0,
      "text": "6.4.4. Addressing LFB Entities",
      "section_title": true,
      "ja": "6.4.4.  LFBエンティティへの対処"
    },
    {
      "indent": 3,
      "text": "Section 6.4.1 and Section 6.4.2 discuss how to target an entity within an LFB. However, the addressing mechanism used requires that an LFB type and instance are selected first. The LFB selector is used to select an LFB type and instance being targeted. Section 7 goes into more details; for our purpose, we illustrate this concept using Figure 16 below. More examples of layouts can be found reading further into the text (example: Figure 22).",
      "ja": "6.4.1項および6.4.2項は、LFB内のエンティティをターゲットにする方法について説明します。しかし、使用されるアドレッシング機構は、LFBタイプとインスタンスが最初に選択されることを必要とします。 LFBセレクタは、標的とされるLFBタイプおよびインスタンスを選択するために使用されます。第7節は、より多くの細部に入ります。私たちの目的のために、我々は、下の図16を使用して、この概念を説明します。レイアウトの他の例は、テキスト（：図22の例）にさらに読み出し見出すことができます。"
    },
    {
      "indent": 6,
      "text": "main hdr (Message type: example \"config\")\n |\n |\n |\n +- T = LFBselect\n        |\n        +-- LFBCLASSID (unique per LFB defined)\n        |\n        |\n        +-- LFBInstance  (runtime configuration)\n        |\n        +-- T = An operation TLV describes what we do to an entity\n            |   //Refer to the OPER-TLV values enumerated below\n            |   //the TLVs that can be used for operations\n            |\n            |\n            +--+-- one or more path encodings to target an entity\n               | // Refer to the discussion on keys and paths\n               |\n               |\n               +-- The associated data, if any, for the entity\n                  // Refer to discussion on FULL/SPARSE DATA TLVs",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 16: Entity Addressing",
      "ja": "図16：エンティティのアドレッシング"
    },
    {
      "indent": 0,
      "text": "7. Protocol Construction",
      "section_title": true,
      "ja": "7.プロトコル建設"
    },
    {
      "indent": 3,
      "text": "A protocol layer PDU consists of a common header (defined in Section 6.1 ) and a message body. The common header is followed by a message-type-specific message body. Each message body is formed from one or more top-level TLVs. A top-level TLV may contain one or more sub-TLVs; these sub-TLVs are described in this document as OPER-TLVs, because they describe an operation to be done.",
      "ja": "プロトコル層のPDU（セクション6.1で定義された）共通ヘッダとメッセージ本体で構成されています。共通ヘッダは、メッセージ・タイプ固有のメッセージ本体が続きます。各メッセージの本体は、一つ以上の最上位のTLVから形成されます。最上位のTLVは、1つ以上のサブTLVを含んでいてもよいです。これらは操作が行われるように説明しているため、これらのサブのTLVは、OPER-のTLVとしてこの文書に記載されています。"
    },
    {
      "indent": 3,
      "text": "+-------------+---------------+---------------------+---------------+\n|   Message   | Top-Level TLV |     OPER-TLV(s)     |   Reference   |\n|     Name    |               |                     |               |\n+-------------+---------------+---------------------+---------------+\n| Association |  (LFBselect)* |        REPORT       | Section 7.5.1 |\n|    Setup    |               |                     |               |\n| Association | ASRresult-TLV |         none        | Section 7.5.2 |\n|    Setup    |               |                     |               |\n|   Response  |               |                     |               |\n| Association | ASTreason-TLV |         none        | Section 7.5.3 |\n|   Teardown  |               |                     |               |\n|    Config   |  (LFBselect)+ |  (SET | SET-PROP |  | Section 7.6.1 |\n|             |               |    DEL | COMMIT |   |               |\n|             |               |       TRCOMP)+      |               |\n|    Config   |  (LFBselect)+ |   (SET-RESPONSE |   | Section 7.6.2 |\n|   Response  |               | SET-PROP-RESPONSE | |               |\n|             |               |    DEL-RESPONSE |   |               |\n|             |               |  COMMIT-RESPONSE)+  |               |\n|    Query    |  (LFBselect)+ |  (GET | GET-PROP)+  | Section 7.7.1 |\n|    Query    |  (LFBselect)+ |   (GET-RESPONSE |   | Section 7.7.2 |\n|   Response  |               | GET-PROP-RESPONSE)+ |               |\n|    Event    |   LFBselect   |        REPORT       |  Section 7.8  |\n|   Notifi-   |               |                     |               |\n|    cation   |               |                     |               |\n|    Packet   |  REDIRECT-TLV |         none        |  Section 7.9  |\n|   Redirect  |               |                     |               |\n|  Heartbeat  |      none     |         none        |  Section 7.10 |\n+-------------+---------------+---------------------+---------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 1",
      "ja": "表1"
    },
    {
      "indent": 3,
      "text": "The different messages are illustrated in Table 1. The different message type numerical values are defined in Appendix A.1. All the TLV values are defined in Appendix A.2.",
      "ja": "異なるメッセージは、表1の数値は、付録A.1に定義されている異なるメッセージタイプに示されています。すべてのTLV値は、付録A.2で定義されています。"
    },
    {
      "indent": 3,
      "text": "An LFBselect TLV (refer to Section 7.1.5) contains the LFB Classid and LFB instance being referenced as well as the OPER-TLV(s) being applied to that reference.",
      "ja": "LFBselect TLV（セクション7.1.5参照）LFB CLASSIDとLFBインスタンスが参照されているだけでなく、OPER-TLV（s）は、その参照に適用されて含まれています。"
    },
    {
      "indent": 3,
      "text": "Each type of OPER-TLV is constrained as to how it describes the paths and selectors of interest. The following BNF describes the basic structure of an OPER-TLV and Table 2 gives the details for each type.",
      "ja": "OPER-TLVの各タイプは、それが関心のパスセレクタを記述する方法として拘束されています。以下のBNFはOPER-TLVの基本構造を説明し、表2は、各タイプの詳細を与えます。"
    },
    {
      "indent": 7,
      "text": "OPER-TLV := 1*PATH-DATA-TLV\nPATH-DATA-TLV := PATH  [DATA]\nPATH := flags IDcount IDs [SELECTOR]\nSELECTOR :=  KEYINFO-TLV\nDATA := FULLDATA-TLV / SPARSEDATA-TLV / RESULT-TLV /\n        1*PATH-DATA-TLV\nKEYINFO-TLV := KeyID FULLDATA-TLV\nFULLDATA-TLV := encoded data component which may nest\n               further FULLDATA-TLVs\nSPARSEDATA-TLV := encoded data that may have optionally\n                 appearing components\nRESULT-TLV := Holds result code and optional FULLDATA-TLV",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 17: BNF of OPER-TLV",
      "ja": "図17：OPER-TLVのBNF"
    },
    {
      "indent": 3,
      "text": "o PATH-DATA-TLV identifies the exact component targeted and may have zero or more paths associated with it. The last PATH-DATA-TLV in the case of nesting of paths via the DATA construct in the case of SET, SET-PROP requests, and GET-RESPONSE/GET-PROP-RESPONSE is terminated by encoded data or response in the form of either FULLDATA-TLV or SPARSEDATA-TLV or RESULT-TLV.",
      "ja": "O PATH-DATA-TLVは、標的の正確なコンポーネントを識別し、それに関連付けられたゼロ個以上の経路を有することができます。データを介してパスの入れ子の場合には最後のパス-DATA-TLVは、SETの場合に構築要求-PROPセット、GET-RESPONSE / GET-PROP-RESPONSEはの形で符号化されたデータ又は応答によって終了されますFULLDATA-TLVまたはSPARSEDATA-TLVまたは結果-TLVのどちらか。"
    },
    {
      "indent": 3,
      "text": "o PATH provides the path to the data being referenced.",
      "ja": "Oパスは、参照されているデータへのパスを提供します。"
    },
    {
      "indent": 6,
      "text": "* flags (16 bits) are used to further refine the operation to be applied on the path. More on these later.",
      "ja": "*フラグ（16ビット）は、さらにパスに適用するための動作を改善するために使用されます。これらの後に詳しいです。"
    },
    {
      "indent": 6,
      "text": "* IDcount (16 bits): count of 32-bit IDs",
      "ja": "* IDCOUNT（16ビット）：32ビットIDの数"
    },
    {
      "indent": 6,
      "text": "* IDs: zero or more 32-bit IDs (whose count is given by IDcount) defining the main path. Depending on the flags, IDs could be field IDs only or a mix of field and dynamic IDs. Zero is used for the special case of using the entirety of the containing context as the result of the path.",
      "ja": "* IDは：（そのカウントIDCOUNTによって与えられる）は、ゼロ又はそれ以上の32ビットIDの主経路を画定します。フラグによって、IDは、フィールドIDのみまたはフィールドおよびダイナミックIDの組み合わせである可能性があります。ゼロは、パスの結果として含有するコ​​ンテキストの全体を使用しての特別な場合に使用されます。"
    },
    {
      "indent": 3,
      "text": "o SELECTOR is an optional construct that further defines the PATH. Currently, the only defined selector is the KEYINFO-TLV, used for selecting an array entry by the value of a key field. The presence of a SELECTOR is correct only when the flags also indicate its presence.",
      "ja": "Oセレクタはさらに、パスを定義するオプションの構築物です。現在、唯一の定義されたセレクタは、キー・フィールドの値によって配列エントリを選択するために使用するKeyInfo-TLVです。フラグはまた、その存在を示すときにのみSELECTORの存在が正しいです。"
    },
    {
      "indent": 3,
      "text": "o A KEYINFO-TLV contains information used in content keying.",
      "ja": "OのKeyInfo-TLVは、コンテンツキーで使用される情報を含みます。"
    },
    {
      "indent": 6,
      "text": "* A 32-bit KeyID is used in a KEYINFO-TLV. It indicates which key for the current array is being used as the content key for array entry selection.",
      "ja": "* 32ビットKeyIDををするKeyInfo-TLVに使用されます。これは、アレイエントリを選択するためのコンテンツ鍵として使用されている現在のアレイのどのキーを示しています。"
    },
    {
      "indent": 6,
      "text": "* The key's data is the data to look for in the array, in the fields identified by the key field. The information is encoded according to the rules for the contents of a FULLDATA-TLV, and represents the field or fields that make up the key identified by the KeyID.",
      "ja": "*キーのデータがキーフィールドで識別されるフィールドに、配列内を探すためのデータです。情報はFULLDATA-TLVの内容の規則に従って符号化され、およびKeyIDをによって識別キーを構成するフィールドまたはフィールドを表しています。"
    },
    {
      "indent": 3,
      "text": "o DATA may contain a FULLDATA-TLV, SPARSEDATA-TLV, a RESULT-TLV, or 1 or more further PATH-DATA selections. FULLDATA-TLV and SPARSEDATA-TLV are only allowed on SET or SET-PROP requests, or on responses that return content information (GET-RESPONSE, for example). PATH-DATA may be included to extend the path on any request.",
      "ja": "OデータはFULLDATA-TLV、SPARSEDATA-TLV、RESULT-TLV、または1以上のさらなるPATH-DATAの選択を含んでいてもよいです。 FULLDATA-TLVとSPARSEDATA-TLVはSETまたはSET-PROPのリクエストで許可されている、または（例えば、GET-RESPONSE）コンテンツ情報を返す応答にされています。 PATH-DATAは、任意の要求に応じて経路を拡張するために含まれてもよいです。"
    },
    {
      "indent": 6,
      "text": "* Note: Nested PATH-DATA-TLVs are supported as an efficiency measure to permit common subexpression extraction.",
      "ja": "*注：ネストされたPATH-DATA-のTLVは、共通部分式の抽出を可能にするために、効率の指標としてサポートされています。"
    },
    {
      "indent": 6,
      "text": "* FULLDATA-TLV and SPARSEDATA-TLV contain \"the data\" whose path has been selected by the PATH. Refer to Section 7.1 for details.",
      "ja": "* FULLDATA-TLVとSPARSEDATA-TLVは、そのパスPATHによって選択された「データ」を含んでいます。詳細については、7.1節を参照してください。"
    },
    {
      "indent": 6,
      "text": "* The following table summarizes the applicability and restrictions of the FULL/SPARSEDATA-TLVs and the RESULT-TLV to the OPER-TLVs.",
      "ja": "*以下の表は、OPER-のTLVへの適用およびFULL / SPARSEDATA-のTLVとRESULT-TLVの制限をまとめています。"
    },
    {
      "indent": 3,
      "text": "+-------------------+-------------------------------+---------------+\n|      OPER-TLV     |            DATA TLV           |   RESULT-TLV  |\n+-------------------+-------------------------------+---------------+\n|        SET        |                               |      none     |\n|      SET-PROP     |        (FULLDATA-TLV |        |      none     |\n|                   |        SPARSEDATA-TLV)+       |               |\n|    SET-RESPONSE   |              none             | (RESULT-TLV)+ |\n| SET-PROP-RESPONSE |              none             | (RESULT-TLV)+ |\n|        DEL        |                               |      none     |\n|    DEL-RESPONSE   |              none             | (RESULT-TLV)+ |\n|        GET        |              none             |      none     |\n|      GET-PROP     |              none             |      none     |\n|    GET-RESPONSE   |        (FULLDATA-TLV)+        | (RESULT-TLV)* |\n| GET-PROP-RESPONSE |        (FULLDATA-TLV)+        | (RESULT-TLV)* |\n|       REPORT      |        (FULLDATA-TLV)+        |      none     |\n|       COMMIT      |              none             |      none     |\n|  COMMIT-RESPONSE  |              none             | (RESULT-TLV)+ |\n|       TRCOMP      |              none             |      none     |\n+-------------------+-------------------------------+---------------+",
      "raw": true
    },
    {
      "indent": 37,
      "text": "Table 2",
      "ja": "表2"
    },
    {
      "indent": 3,
      "text": "o RESULT-TLV contains the indication of whether the individual SET or SET-PROP succeeded. RESULT-TLV is included on the assumption that individual parts of a SET request can succeed or fail separately.",
      "ja": "O RESULT-TLVは、個々のSETまたはSET-PROPが成功したかどうかの表示を含みます。 RESULT-TLVは、SET要求の個々の部分が成功するか、別々に失敗する可能性があることを前提に含まれています。"
    },
    {
      "indent": 3,
      "text": "In summary, this approach has the following characteristics:",
      "ja": "要約すると、このアプローチは、以下の特徴があります。"
    },
    {
      "indent": 3,
      "text": "o There can be one or more LFB class ID and instance ID combinations targeted in a message (batch).",
      "ja": "Oメッセージ（バッチ）において標的一つ以上のLFBクラスIDおよびインスタンスIDの組み合わせがあり得ます。"
    },
    {
      "indent": 3,
      "text": "o There can one or more operations on an addressed LFB class ID/ instance ID combination (batch).",
      "ja": "Oアドレス指定LFBクラスID /インスタンスIDの組み合わせ（バッチ）上の1つのまたは複数のオペレーションが存在することができます。"
    },
    {
      "indent": 3,
      "text": "o There can be one or more path targets per operation (batch).",
      "ja": "O操作（バッチ）ごとに1つのまたは複数のパスのターゲットが存在する場合があります。"
    },
    {
      "indent": 3,
      "text": "o Paths may have zero or more data values associated (flexibility and operation specific).",
      "ja": "Oパスは、関連付けられたゼロ個以上のデータ値（柔軟性及び動作特定）を有していてもよいです。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the above is optimized for the case of a single LFB class ID and instance ID targeting. To target multiple instances within the same class, multiple LFBselects are needed.",
      "ja": "なお、上記のターゲティング単一LFBクラスIDおよびインスタンスIDの場合のために最適化されていることに留意すべきです。同じクラス内の複数のインスタンスをターゲットにするには、複数のLFBselectsが必要とされています。"
    },
    {
      "indent": 0,
      "text": "7.1. Discussion on Encoding",
      "section_title": true,
      "ja": "7.1. エンコードに関する議論"
    },
    {
      "indent": 3,
      "text": "Section 6.4.3 discusses the two types of DATA encodings (FULLDATA-TLV and SPARSEDATA-TLV) and the justifications for their existence. In this section, we explain how they are encoded.",
      "ja": "6.4.3項では、DATAエンコーディング（FULLDATA-TLVとSPARSEDATA-TLV）とその存在のための正当化の二つのタイプについて説明します。このセクションでは、我々は、彼らがどのようにエンコードされるかを説明します。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Data Packing Rules",
      "section_title": true,
      "ja": "7.1.1. データパッキングルール"
    },
    {
      "indent": 3,
      "text": "The scheme for encoding data used in this document adheres to the following rules:",
      "ja": "このドキュメントで使用される符号化データのためのスキームは、次の規則に準拠します："
    },
    {
      "indent": 3,
      "text": "o The Value (\"V\" of TLV) of FULLDATA-TLV will contain the data being transported. This data will be as was described in the LFB definition.",
      "ja": "FULLDATA-TLVの値（TLVの「V」）が搬送されるデータを含むであろうO。 LFBの定義で説明したように、このデータになります。"
    },
    {
      "indent": 3,
      "text": "o Variable-sized data within a FULLDATA-TLV will be encapsulated inside another FULLDATA-TLV inside the V of the outer TLV. For an example of such a setup, refer to Appendices C and D.",
      "ja": "O FULLDATA-TLV内で可変サイズのデータ​​は、外部TLVのV内側別FULLDATA-TLV内部に封入されます。そのような設定の例については、付録CおよびDを参照"
    },
    {
      "indent": 3,
      "text": "o In the case of FULLDATA-TLVs:",
      "ja": "FULLDATA-のTLVの場合○："
    },
    {
      "indent": 6,
      "text": "* When a table is referred to in the PATH (IDs) of a PATH-DATA-TLV, then the FULLDATA-TLV's \"V\" will contain that table's row content prefixed by its 32-bit index/subscript. On the other hand, the PATH may contain an index pointing to a row in table; in such a case, the FULLDATA-TLV's \"V\" will only contain the content with the index in order to avoid ambiguity.",
      "ja": "テーブルはPATH-DATA-TLVのPATH（IDS）で言及された場合*、次いでFULLDATA-TLVの「V」は、32ビットのインデックス/添字で始まるそのテーブルの行の内容を含むことになります。一方、PATHは、テーブル内の行を指すインデックスを含むことができます。このような場合には、FULLDATA-TLVの「V」は唯一のあいまいさを避けるために、インデックスを持つコンテンツが含まれます。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Path Flags",
      "section_title": true,
      "ja": "7.1.2. パスの国旗"
    },
    {
      "indent": 3,
      "text": "Only bit 0, the SELECTOR Bit, is currently used in the path flags as illustrated in Figure 18.",
      "ja": "図18に示すようにのみビット0は、セレクタビットは、現在の経路フラグに使用されます。"
    },
    {
      "indent": 6,
      "text": "0                   1\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| |                           |\n|S|   Reserved                |\n| |                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 18: Path Flags",
      "ja": "図18：パスの旗"
    },
    {
      "indent": 6,
      "text": "The semantics of the flag are defined as follows:",
      "ja": "次のようにフラグのセマンティクスが定義されています。"
    },
    {
      "indent": 3,
      "text": "o SELECTOR Bit: F_SELKEY(set to 1) indicates that a KEY Selector is present following this path information, and should be considered in evaluating the path content.",
      "ja": "O SELECTORビット：F_SELKEY（1セット）キーセレクターこの経路情報本以下であり、かつパスコンテンツを評価する際に考慮されるべきであることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.1.3. Relation of Operational Flags with Global Message Flags",
      "section_title": true,
      "ja": "7.1.3. グローバルメッセージフラグと運用国旗の関係"
    },
    {
      "indent": 3,
      "text": "Global flags, such as the execution mode and the atomicity indicators defined in the header, apply to all operations in a message. Global flags provide semantics that are orthogonal to those provided by the operational flags, such as the flags defined in path-data. The scope of operational flags is restricted to the operation.",
      "ja": "そのような実行モードとヘッダで定義された原子数指標としてグローバルフラグは、メッセージ内のすべての操作に適用されます。グローバルフラグは、パスデータに定義されたフラグなどのフラグ演算により提供される、直交するセマンティクスを提供します。操作フラグの範囲は、操作に制限されています。"
    },
    {
      "indent": 0,
      "text": "7.1.4. Content Path Selection",
      "section_title": true,
      "ja": "7.1.4. コンテンツパスの選択"
    },
    {
      "indent": 3,
      "text": "The KEYINFO-TLV describes the KEY as well as associated KEY data. KEYs, used for content searches, are restricted and described in the LFB definition.",
      "ja": "KeyInfoに-TLVは、KEYだけでなく、関連する鍵データを記述する。コンテンツの検索に使用するキーは、LFBの定義に制限され、説明されています。"
    },
    {
      "indent": 0,
      "text": "7.1.5. LFBselect-TLV",
      "section_title": true,
      "ja": "7.1.5.  LFBselect-TLV"
    },
    {
      "indent": 3,
      "text": "The LFBselect TLV is an instance of a TLV as defined in Section 6.2. The definition is as follows:",
      "ja": "セクション6.2で定義されるようLFBselect TLVは、TLVのインスタンスです。次のように定義は次のとおりです。"
    },
    {
      "indent": 4,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Type = LFBselect       |               Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          LFB Class ID                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        LFB Instance ID                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        OPER-TLV                               |\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                           ...                                 ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        OPER-TLV                               |\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 19: PL PDU Layout",
      "ja": "図19：PL PDUレイアウト"
    },
    {
      "indent": 3,
      "text": "Type:",
      "ja": "タイプ："
    },
    {
      "indent": 3,
      "text": "The type of the TLV is \"LFBselect\"",
      "ja": "TLVのタイプは「LFBselect」であります"
    },
    {
      "indent": 3,
      "text": "Length:",
      "ja": "長さ："
    },
    {
      "indent": 3,
      "text": "Length of the TLV including the T and L fields, in octets.",
      "ja": "オクテット内TとLフィールドを含むTLVの長さ。"
    },
    {
      "indent": 3,
      "text": "LFB Class ID:",
      "ja": "LFBクラスID："
    },
    {
      "indent": 3,
      "text": "This field uniquely recognizes the LFB class/type.",
      "ja": "このフィールドは、一意LFBクラス/タイプを認識します。"
    },
    {
      "indent": 3,
      "text": "LFB Instance ID:",
      "ja": "LFBインスタンスID："
    },
    {
      "indent": 3,
      "text": "This field uniquely identifies the LFB instance.",
      "ja": "このフィールドは、一意LFBインスタンスを識別する。"
    },
    {
      "indent": 3,
      "text": "OPER-TLV:",
      "ja": "OPERA-TLV："
    },
    {
      "indent": 3,
      "text": "It describes an operation nested in the LFBselect TLV. Note that usually there SHOULD be at least one OPER-TLV present for an LFB select TLV.",
      "ja": "それはLFBselect TLVにネスト操作について説明しています。通常TLVを選択LFBための少なくとも一つのOPER-TLVが存在すべきであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "7.1.6. OPER-TLV",
      "section_title": true,
      "ja": "7.1.6.  OPERA-TLV"
    },
    {
      "indent": 3,
      "text": "The OPER-TLV is a place holder in the grammar for TLVs that define operations. The different types are defined in Table 3, below.",
      "ja": "OPER-TLVは、操作を定義するためのTLV文法におけるプレースホルダです。異なるタイプを以下の表3に定義されています。"
    },
    {
      "indent": 3,
      "text": "+-------------------+--------+--------------------------------------+\n|      OPER-TLV     |   TLV  |               Comments               |\n|                   | \"Type\" |                                      |\n+-------------------+--------+--------------------------------------+\n|        SET        | 0x0001 |   From CE to FE.  Used to create or  |\n|                   |        |       add or update components       |\n|      SET-PROP     | 0x0002 |   From CE to FE.  Used to create or  |\n|                   |        |  add or update component properties  |\n|    SET-RESPONSE   | 0x0003 |     From FE to CE.  Used to carry    |\n|                   |        |           response of a SET          |\n| SET-PROP-RESPONSE | 0x0004 |     From FE to CE.  Used to carry    |\n|                   |        |        response of a SET-PROP        |\n|        DEL        | 0x0005 |   From CE to FE.  Used to delete or  |\n|                   |        |          remove an component         |\n|    DEL-RESPONSE   | 0x0006 |     From FE to CE.  Used to carry    |\n|                   |        |           response of a DEL          |\n|        GET        | 0x0007 |  From CE to FE.  Used to retrieve an |\n|                   |        |               component              |\n|      GET-PROP     | 0x0008 |  From CE to FE.  Used to retrieve an |\n|                   |        |          component property          |\n|    GET-RESPONSE   | 0x0009 |     From FE to CE.  Used to carry    |\n|                   |        |           response of a GET          |\n| GET-PROP-RESPONSE | 0x000A |     From FE to CE.  Used to carry    |\n|                   |        |        response of a GET-PROP        |\n|       REPORT      | 0x000B |   From FE to CE.  Used to carry an   |\n|                   |        |          asynchronous event          |\n|       COMMIT      | 0x000C |    From CE to FE.  Used to issue a   |\n|                   |        |      commit in a 2PC transaction     |\n|  COMMIT-RESPONSE  | 0x000D |   From FE to CE.  Used to confirm a  |\n|                   |        |      commit in a 2PC transaction     |\n|       TRCOMP      | 0x000E |   From CE to FE.  Used to indicate   |\n|                   |        |  NE-wide success of 2PC transaction  |\n+-------------------+--------+--------------------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 3",
      "ja": "表3"
    },
    {
      "indent": 3,
      "text": "Different messages use OPER-TLV and define how they are used (refer to Table 1 and Table 2).",
      "ja": "異なるメッセージはOPER-TLVを使用して、それらが（表1および表2を参照）を使用する方法を定義します。"
    },
    {
      "indent": 3,
      "text": "SET, SET-PROP, and GET/GET-PROP requests are issued by the CE and do not carry RESULT-TLVs. On the other hand, SET-RESPONSE, SET-PROP-RESPONSE, and GET-RESPONSE/GET-PROP-RESPONSE carry RESULT-TLVs.",
      "ja": "SET、SET-PROPは、およびGET / GET-PROP要求はCEによって発行され、結果-TLVを運びません。一方、SET-RESPONSE、SET-PROP-RESPONSE、およびGET-RESPONSE / GET-PROP-RESPONSEキャリーRESULT-TLVを。"
    },
    {
      "indent": 3,
      "text": "A GET-RESPONSE in response to a successful GET will have FULLDATA-TLVs added to the leaf paths to carry the requested data. For GET operations that fail, instead of the FULLDATA-TLV there will be a RESULT-TLV.",
      "ja": "成功したGETに応じて、GET-RESPONSEはFULLDATA-のTLVが要求されたデータを運ぶために葉のパスに追加されます。失敗GET操作の場合、代わりにFULLDATA-TLVの結果-TLVがあるでしょう。"
    },
    {
      "indent": 3,
      "text": "For a SET-RESPONSE/SET-PROP-RESPONSE, each FULLDATA-TLV or SPARSEDATA-TLV in the original request will be replaced with a RESULT-TLV in the response. If the request set the FailureACK flag, then only those items that failed will appear in the response. If the request was for AlwaysACK, then all components of the request will appear in the response with RESULT-TLVs.",
      "ja": "SET-RESPONSE / SET-PROP-RESPONSEのために、オリジナルの要求における各FULLDATA-TLVまたはSPARSEDATA-TLVはRESULT-TLV応答に置き換えられます。リクエストがFailureACKフラグを設定すると、失敗した項目のみが応答に表示されます。リクエストがAlwaysACKのためだった場合、その要求のすべてのコンポーネントがRESULT-のTLVで応答に表示されます。"
    },
    {
      "indent": 3,
      "text": "Note that if a SET/SET-PROP request with a structure in a FULLDATA-TLV is issued, and some field in the structure is invalid, the FE will not attempt to indicate which field was invalid, but rather will indicate that the operation failed. Note further that if there are multiple errors in a single leaf PATH-DATA/FULLDATA-TLB, the FE can select which error it chooses to return. So if a FULLDATA-TLV for a SET/SET-PROP of a structure attempts to write one field that is read only, and attempts to set another field to an invalid value, the FE can return indication of either error.",
      "ja": "FULLDATA-TLVで構成されたSET / SET-PROP要求が発行され、構造体のいくつかのフィールドが無効である場合は、FEが無効だったフィールドを示すしようとしませんが、むしろ操作が失敗したことを示すことに注意してください。単一の葉PATH-DATA / FULLDATA-TLB内に複数のエラーがある場合、FEは、それが戻ることを選択したエラーを選択できることにさらに注意してください。構造のSET / SET-PROPためFULLDATA-TLVが読み取り専用である一つのフィールドを書き込もうとし、無効な値に別のフィールドを設定しようとするので、FEは、いずれかのエラーの指示を返すことができます。"
    },
    {
      "indent": 3,
      "text": "A SET/SET-PROP operation on a variable-length component with a length of 0 for the item is not the same as deleting it. If the CE wishes to delete, then the DEL operation should be used whether the path refers to an array component or an optional structure component.",
      "ja": "アイテムの0の長さの可変長成分にSET / SET-PROP操作は、それを削除すると同じではありません。 CEは削除したい場合には、DEL操作は、パスは、アレイ成分又は任意構成成分を意味するかどうかを使用すべきです。"
    },
    {
      "indent": 0,
      "text": "7.1.7. RESULT TLV",
      "section_title": true,
      "ja": "7.1.7.  RESULT TLV"
    },
    {
      "indent": 3,
      "text": "The RESULT-TLV is an instance of TLV defined in Section 6.2. The definition is as follows:",
      "ja": "RESULT-TLVは、セクション6.2で定義されたTLVのインスタンスです。次のように定義は次のとおりです。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = RESULT-TLV          |               Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Result Value  |                  Reserved                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 20: RESULT-TLV",
      "ja": "図20：RESULT-TLV"
    },
    {
      "indent": 27,
      "text": "Defined Result Values",
      "ja": "定義された結果の値"
    },
    {
      "indent": 3,
      "text": "+-----------------------------+-----------+-------------------------+\n|         Result Value        |   Value   |        Definition       |\n+-----------------------------+-----------+-------------------------+\n|          E_SUCCESS          |    0x00   |         Success         |\n|       E_INVALID_HEADER      |    0x01   |  Unspecified error with |\n|                             |           |         header.         |\n|      E_LENGTH_MISMATCH      |    0x02   |   Header length field   |\n|                             |           |  does not match actual  |\n|                             |           |      packet length.     |\n|      E_VERSION_MISMATCH     |    0x03   |  Unresolvable mismatch  |\n|                             |           |       in versions.      |\n|  E_INVALID_DESTINATION_PID  |    0x04   |    Destination PID is   |\n|                             |           | invalid for the message |\n|                             |           |        receiver.        |\n|        E_LFB_UNKNOWN        |    0x05   |   LFB Class ID is not   |\n|                             |           |    known by receiver.   |\n|       E_LFB_NOT_FOUND       |    0x06   |  LFB Class ID is known  |\n|                             |           |   by receiver but not   |\n|                             |           |    currently in use.    |\n| E_LFB_INSTANCE_ID_NOT_FOUND |    0x07   |  LFB Class ID is known  |\n|                             |           |    but the specified    |\n|                             |           |  instance of that class |\n|                             |           |     does not exist.     |\n|        E_INVALID_PATH       |    0x08   |  The specified path is  |\n|                             |           |       impossible.       |\n|  E_COMPONENT_DOES_NOT_EXIST |    0x09   |  The specified path is  |\n|                             |           |     possible but the    |\n|                             |           |    component does not   |\n|                             |           | exist (e.g., attempt to |\n|                             |           | modify a table row that |\n|                             |           |  has not been created). |\n|           E_EXISTS          |    0x0A   |   The specified object  |\n|                             |           |   exists but it cannot  |\n|                             |           | exist for the operation |\n|                             |           |    to succeed (e.g.,    |\n|                             |           |    attempt to add an    |\n|                             |           |  existing LFB instance  |\n|                             |           |   or array subscript).  |\n|         E_NOT_FOUND         |    0x0B   |   The specified object  |\n|                             |           |  does not exist but it  |\n|                             |           |    MUST exist for the   |\n|                             |           |   operation to succeed  |\n|                             |           |    (e.g., attempt to    |\n|                             |           |  delete a non-existing  |\n|                             |           |  LFB instance or array  |\n|                             |           |       subscript).       |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "|         E_READ_ONLY         |    0x0C   |   Attempt to modify a   |\n|                             |           |     read-only value.    |\n|   E_INVALID_ARRAY_CREATION  |    0x0D   |   Attempt to create an  |\n|                             |           | array with an unallowed |\n|                             |           |        subscript.       |\n|     E_VALUE_OUT_OF_RANGE    |    0x0E   |     Attempt to set a    |\n|                             |           |   parameter to a value  |\n|                             |           |      outside of its     |\n|                             |           |     allowable range.    |\n|     E_CONTENTS_TOO_LONG     |    0x0D   |     Attempt to write    |\n|                             |           |   contents larger than  |\n|                             |           | the target object space |\n|                             |           |    (i.e., exceeding a   |\n|                             |           |         buffer).        |\n|     E_INVALID_PARAMETERS    |    0x10   |   Any other error with  |\n|                             |           |     data parameters.    |\n|    E_INVALID_MESSAGE_TYPE   |    0x11   |   Message type is not   |\n|                             |           |       acceptable.       |\n|       E_INVALID_FLAGS       |    0x12   |  Message flags are not  |\n|                             |           |    acceptable for the   |\n|                             |           |   given message type.   |\n|        E_INVALID_TLV        |    0x13   | A TLV is not acceptable |\n|                             |           |  for the given message  |\n|                             |           |          type.          |\n|        E_EVENT_ERROR        |    0x14   | Unspecified error while |\n|                             |           |    handling an event.   |\n|       E_NOT_SUPPORTED       |    0x15   |   Attempt to perform a  |\n|                             |           |  valid ForCES operation |\n|                             |           |  that is unsupported by |\n|                             |           |  the message receiver.  |\n|        E_MEMORY_ERROR       |    0x16   | A memory error occurred |\n|                             |           |    while processing a   |\n|                             |           |    message (no error    |\n|                             |           | detected in the message |\n|                             |           |         itself).        |\n|       E_INTERNAL_ERROR      |    0x17   |   An unspecified error  |\n|                             |           |      occurred while     |\n|                             |           |   processing a message  |\n|                             |           |  (no error detected in  |\n|                             |           |   the message itself).  |\n|              -              | 0x18-0xFE |         Reserved        |\n|     E_UNSPECIFIED_ERROR     |    0xFF   |  Unspecified error (for |\n|                             |           |    when the FE cannot   |\n|                             |           |     decide what went    |\n|                             |           |         wrong).         |\n+-----------------------------+-----------+-------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 4",
      "ja": "表4"
    },
    {
      "indent": 0,
      "text": "7.1.8. DATA TLV",
      "section_title": true,
      "ja": "7.1.8. データTLV"
    },
    {
      "indent": 3,
      "text": "A FULLDATA-TLV has \"T\"= FULLDATA-TLV and a 16-bit length followed by the data value/contents. Likewise, a SPARSEDATA-TLV has \"T\" = SPARSEDATA-TLV, a 16-bit length, followed by the data value/contents. In the case of the SPARSEDATA-TLV, each component in the Value part of the TLV will be further encapsulated in an ILV.",
      "ja": "FULLDATA-TLVは、「T」= FULLDATA-TLVデータ値/内容に続く16ビットの長さを有します。同様に、SPARSEDATA-TLVデータ値/内容、続いて \"T\" = SPARSEDATA-TLV、16ビットの長さを有します。 SPARSEDATA-TLVの場合には、TLVの値の部分の各コンポーネントは、さらに、ILV内にカプセル化されるであろう。"
    },
    {
      "indent": 3,
      "text": "Below are the encoding rules for the FULLDATA-TLV and SPARSEDATA-TLVs. Appendix C is very useful in illustrating these rules:",
      "ja": "以下はFULLDATA-TLVとSPARSEDATA-TLVのための符号化規則があります。付録Cには、これらのルールを説明するのに非常に便利です。"
    },
    {
      "indent": 3,
      "text": "1. Both ILVs and TLVs MUST be 32-bit aligned. Any padding bits used for the alignment MUST be zero on transmission and MUST be ignored upon reception.",
      "ja": "1.両方ILVsとのTLVは、32ビット整列されなければなりません。位置合わせのために使用される任意のパディングビットが送信にゼロでなければならないし、受信時に無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. FULLDATA-TLVs may be used at a particular path only if every component at that path level is present. In example 1(c) of Appendix C, this concept is illustrated by the presence of all components of the structure S in the FULLDATA-TLV encoding. This requirement holds regardless of whether the fields are fixed or variable length, mandatory or optional.",
      "ja": "2. FULLDATA-のTLVは、そのパスのレベルですべてのコンポーネントが存在する場合にのみ、特定の経路で使用することができます。付録Cの実施例1（c）に、この概念はFULLDATA-TLV符号化における構造体Sのすべてのコンポーネントが存在することによって示されています。この要件は必須またはオプションに関係なく、フィールドは固定されているか否かに可変長を保持しています。"
    },
    {
      "indent": 7,
      "text": "*   If a FULLDATA-TLV is used, the encoder MUST lay out data for\n    each component in the same order in which the data was\n    defined in the LFB specification.  This ensures the decoder\n    is able to retrieve the data.  To use the example 1 again in\n    Appendix C, this implies the encoder/decoder is assumed to\n    have knowledge of how structure S is laid out in the\n    definition.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* In the case of a SPARSEDATA-TLV, it does not need to be ordered since the \"I\" in the ILV uniquely identifies the component. Examples 1(a) and 1(b) in Appendix C illustrate the power of SPARSEDATA-TLV encoding.",
      "ja": "「私は」ILVで一意にコンポーネントを識別するので* SPARSEDATA-TLVの場合は、注文する必要はありません。付録Cに、実施例1（a）及び図1（b）はSPARSEDATA-TLVエンコーディングのパワーを示しています。"
    },
    {
      "indent": 3,
      "text": "3. Inside a FULLDATA-TLV",
      "section_title": true,
      "ja": "FULLDATA-TLVインサイド3"
    },
    {
      "indent": 7,
      "text": "*   The values for atomic, fixed-length fields are given without\n    any TLV encapsulation.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* The values for atomic, variable-length fields are given inside FULLDATA-TLVs.",
      "ja": "*原子、可変長フィールドの値はFULLDATA-TLVの内部与えられます。"
    },
    {
      "indent": 7,
      "text": "* The values for arrays are in the form of index/subscript, followed by value as stated in \"Data Packing Rules\" (Section 7.1.1) and demonstrated by the examples in the appendices.",
      "ja": "*配列の値は「データパッキング規則」（セクション7.1.1）に記載されていると付録の例によって示されるように値が続くインデックス/添字の形態です。"
    },
    {
      "indent": 3,
      "text": "4. Inside a SPARSEDATA-TLV",
      "section_title": true,
      "ja": "SPARSEDATA-TLVインサイド4"
    },
    {
      "indent": 7,
      "text": "*   The values of all fields MUST be given with ILVs (32-bit\n    index, 32-bit length).",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5. FULLDATA-TLVs cannot contain an ILV.",
      "section_title": true,
      "ja": "5. FULLDATA-TLVがILVを含めることはできません。"
    },
    {
      "indent": 3,
      "text": "6. A FULLDATA-TLV can also contain a FULLDATA-TLV for variable-sized components. The decoding disambiguation is assumed from rule #3 above.",
      "ja": "6. A FULLDATA-TLVはまた、可変サイズのコンポーネントのFULLDATA-TLVを含むことができます。復号一義化は、上記のルール＃3から想定されます。"
    },
    {
      "indent": 0,
      "text": "7.1.9. SET and GET Relationship",
      "section_title": true,
      "ja": "7.1.9. リレーションシップを設定および取得"
    },
    {
      "indent": 3,
      "text": "It is expected that a GET-RESPONSE would satisfy the following:",
      "ja": "GET-RESPONSEは、以下を満たすことが期待されます。"
    },
    {
      "indent": 3,
      "text": "o It would have exactly the same path definitions as those sent in the GET. The only difference is that a GET-RESPONSE will contain FULLDATA-TLVs.",
      "ja": "OそれはGETで送られたものとまったく同じパスの定義を持っているでしょう。唯一の違いは、GET-RESPONSEがFULLDATA-TLVを含むことです。"
    },
    {
      "indent": 3,
      "text": "o It should be possible to take the same GET-RESPONSE and convert it to a SET successfully by merely changing the T in the operational TLV.",
      "ja": "O同じGET-RESPONSEを取り、単に運用TLVにTを変更することにより、正常に設定に変換することが可能です。"
    },
    {
      "indent": 3,
      "text": "o There are exceptions to this rule:",
      "ja": "Oこのルールには例外があります。"
    },
    {
      "indent": 7,
      "text": "1.  When a KEY selector is used with a path in a GET operation,\n    that selector is not returned in the GET-RESPONSE; instead,\n    the cooked result is returned.  Refer to the examples using\n    KEYS to see this.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "2. When dumping a whole table in a GET, the GET-RESPONSE that merely edits the T to be SET will end up overwriting the table.",
      "ja": "GETでテーブル全体をダンプする場合2.は、単に設定するTを編集GET-RESPONSEは、テーブルを上書きしてしまいます。"
    },
    {
      "indent": 0,
      "text": "7.2. Protocol Encoding Visualization",
      "section_title": true,
      "ja": "7.2. プロトコルエンコーディングの可視化"
    },
    {
      "indent": 3,
      "text": "The figure below shows a general layout of the PL PDU. A main header is followed by one or more LFB selections each of which may contain one or more operations.",
      "ja": "以下の図は、PL PDUの一般的なレイアウトを示しています。メインヘッダは、1つまたは複数の操作を含むことができるそれぞれが一つ以上のLFBの選択が続きます。"
    },
    {
      "indent": 3,
      "text": "main hdr (Config in this case)\n     |\n     |\n     +--- T = LFBselect\n     |        |\n     |        +-- LFBCLASSID\n     |        |\n     |        |\n     |        +-- LFBInstance\n     |        |\n     |        +-- T = SET\n     |        |   |\n     |        |   +--  // one or more path targets\n     |        |        // with their data here to be added\n     |        |\n     |        +-- T  = DEL\n     |        .   |\n     |        .   +--  // one or more path targets to be deleted\n     |\n     |\n     +--- T = LFBselect\n     |        |\n     |        +-- LFBCLASSID\n     |        |\n     |        |\n     |        +-- LFBInstance\n     |        |\n     |        + -- T= SET\n     |        |    .\n     |        |    .\n     |        + -- T= DEL\n     |        |    .\n     |        |    .\n     |        |\n     |        + -- T= SET\n     |        |    .\n     |        |    .\n     |\n     |\n     +--- T = LFBselect\n             |\n             +-- LFBCLASSID\n             |\n             +-- LFBInstance\n             .\n             .\n             .\n                  Figure 21: PL PDU Logical Layout",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The figure below shows a more detailed example of the general layout of the operation within a targeted LFB selection. The idea is to show the different nesting levels a path could take to get to the target path.",
      "ja": "以下の図は、標的LFB選択内の動作の一般的なレイアウトの詳細な例を示しています。アイデアは、パスをターゲットパスに到達するために取ることができるさまざまな入れ子のレベルを示すことです。"
    },
    {
      "indent": 8,
      "text": "T = SET\n|  |\n|  +- T = Path-data\n|       |\n|       + -- flags\n|       + -- IDCount\n|       + -- IDs\n|       |\n|       +- T = Path-data\n|          |\n|          + -- flags\n|          + -- IDCount\n|          + -- IDs\n|          |\n|          +- T = Path-data\n|             |\n|             + -- flags\n|             + -- IDCount\n|             + -- IDs\n|             + -- T = KEYINFO-TLV\n|             |    + -- KEY_ID\n|             |    + -- KEY_DATA\n|             |\n|             + -- T = FULLDATA-TLV\n|                  + -- data\n|\n|\nT = SET\n|  |\n|  +- T = Path-data\n|  |  |\n|  |  + -- flags\n|  |  + -- IDCount\n|  |  + -- IDs\n|  |  |\n|  |  + -- T = FULLDATA-TLV\n|  |          + -- data\n|  +- T = Path-data\n|     |",
      "raw": true
    },
    {
      "indent": 8,
      "text": "| + -- flags | + -- IDCount | + -- IDs | | | + -- T = FULLDATA-TLV | + -- data T = DEL | +- T = Path-data | + -- flags + -- IDCount + -- IDs | +- T = Path-data | + -- flags + -- IDCount + -- IDs | +- T = Path-data | + -- flags + -- IDCount + -- IDs + -- T = KEYINFO-TLV | + -- KEY_ID | + -- KEY_DATA +- T = Path-data | + -- flags + -- IDCount + -- IDs",
      "ja": "| +  - 旗| +  -  IDCOUNT | +  -  IDS | | | +  -  T = FULLDATA-TLV | +  - データT = DEL | +  -  T =パスデータ| +  -  +旗 -  IDCOUNT +  -  IDS | +  -  T =パスデータ| +  -  +旗 -  IDCOUNT +  -  IDS | +  -  T =パスデータ| +  -  +旗 -  IDCOUNT +  - のID +  -  T =のKeyInfo-TLV | +  -  KEY_ID | +  -  + KEY_DATA  -  T =パスデータ| +  -  +旗 -  IDCOUNT +  - のID"
    },
    {
      "indent": 20,
      "text": "Figure 22: Sample Operation Layout",
      "ja": "図22：サンプル操作レイアウト"
    },
    {
      "indent": 3,
      "text": "Appendix D shows a more concise set of use cases on how the data encoding is done.",
      "ja": "付録Dは、データ符号化が行われている方法の使用事例のより簡潔なセットを示します。"
    },
    {
      "indent": 0,
      "text": "7.3. Core ForCES LFBs",
      "section_title": true,
      "ja": "7.3. コアのForCES LFBs"
    },
    {
      "indent": 3,
      "text": "There are two LFBs that are used to control the operation of the ForCES protocol and to interact with FEs and CEs:",
      "ja": "ForCESプロトコルの動作を制御するとのFEとCEとのやり取りに使用される2つのLFBsがあります。"
    },
    {
      "indent": 3,
      "text": "o FE Protocol LFB o FE Object LFB",
      "ja": "FEオブジェクトLFB〇〇FEプロトコルLFB"
    },
    {
      "indent": 3,
      "text": "Although these LFBs have the same form and interface as other LFBs, they are special in many respects. They have fixed well-known LFB Class and Instance IDs. They are statically defined (no dynamic instantiation allowed), and their status cannot be changed by the protocol: any operation to change the state of such LFBs (for instance, in order to disable the LFB) MUST result in an error. Moreover, these LFBs MUST exist before the first ForCES message can be sent or received. All components in these LFBs MUST have pre-defined default values. Finally, these LFBs do not have input or output ports and do not integrate into the intra-FE LFB topology.",
      "ja": "これらLFBsが他のLFBsと同じ形式とのインタフェースを持っているが、それらは多くの点で特別なものです。彼らは、よく知られたLFBクラスとインスタンスIDを修正しました。これらは、静的（動的なインスタンス化が許可されていない）が定義され、そしてそれらの状態は、プロトコルによって変更することはできません。（LFBを無効にするために、例えば）そのようなLFBsの状態を変更する任意の動作エラーが発生しなければなりません。また、これらLFBsは最初のForCESメッセージが送信または受信することができる前に存在しなければなりません。これらLFBsのすべてのコンポーネントは、事前定義されたデフォルト値を持たなければなりません。最後に、これらのLFBsは、入力または出力ポートを持っていないとイントラ-FE LFBトポロジに統合されません。"
    },
    {
      "indent": 0,
      "text": "7.3.1. FE Protocol LFB",
      "section_title": true,
      "ja": "H.a 0.1。 PHPでの議定書"
    },
    {
      "indent": 3,
      "text": "The FE Protocol LFB is a logical entity in each FE that is used to control the ForCES protocol. The FE Protocol LFB Class ID is assigned the value 0x2. The FE Protocol LFB Instance ID is assigned the value 0x1. There MUST be one and only one instance of the FE Protocol LFB in an FE. The values of the components in the FE Protocol LFB have pre-defined default values that are specified here. Unless explicit changes are made to these values using Config messages from the CE, these default values MUST be used for correct operation of the protocol.",
      "ja": "FEプロトコルLFBはのForCESプロトコルを制御するために使用される各FE内の論理エンティティです。 FEプロトコルLFBクラスIDは、値を0x2に割り当てられています。 FEプロトコルLFBインスタンスIDは、値は0x1が割り当てられます。 1とFEでFE議定LFBのインスタンスは1つだけでなければなりません。 FEプロトコルLFBのコンポーネントの値がここで指定されている事前定義されたデフォルト値を持っています。明示的な変更はCEからコンフィグメッセージを使用して、これらの値に対して行われていない限り、これらのデフォルト値は、プロトコルの正しい操作のために使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The formal definition of the FE Protocol Object LFB can be found in Appendix B.",
      "ja": "FEプロトコルオブジェクトLFBの正式な定義は付録Bに記載されています"
    },
    {
      "indent": 0,
      "text": "7.3.1.1. FE Protocol Capabilities",
      "section_title": true,
      "ja": "7.3.1.1。 FEプロトコルの機能"
    },
    {
      "indent": 3,
      "text": "FE Protocol capabilities are read-only.",
      "ja": "FEプロトコル機能は読み取り専用です。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.1. SupportableVersions",
      "section_title": true,
      "ja": "7.3.1.1.1。 SupportableVersions"
    },
    {
      "indent": 3,
      "text": "ForCES protocol version(s) supported by the FE.",
      "ja": "FEでサポートされているのForCESプロトコルバージョン（S）。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2. FE Protocol Components",
      "section_title": true,
      "ja": "7.3.1.1.2。 FEプロトコルコンポーネント"
    },
    {
      "indent": 3,
      "text": "FE Protocol components (can be read and set).",
      "ja": "FEプロトコルコンポーネント（読み取りおよび設定することができます）。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.1. CurrentRunningVersion",
      "section_title": true,
      "ja": "7.3.1.1.2.1。 CurrentRunningVersion"
    },
    {
      "indent": 3,
      "text": "Current running version of the ForCES protocol.",
      "ja": "ForCESプロトコルの現在の実行バージョン。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.2. FEID",
      "section_title": true,
      "ja": "7.3.1.1.2.2。確執"
    },
    {
      "indent": 3,
      "text": "FE unicast ID.",
      "ja": "FEユニキャストID。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.3. MulticastFEIDs",
      "section_title": true,
      "ja": "7.3.1.1.2.3。 MulticastFEIDs"
    },
    {
      "indent": 3,
      "text": "FE multicast ID(s) list - This is a list of multicast IDs to which the FE belongs. These IDs are configured by the CE.",
      "ja": "FEマルチキャストID（S）リスト - これは、FEが属するマルチキャストIDのリストです。これらのIDは、CEによって構成されます。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.4. CEHBPolicy",
      "section_title": true,
      "ja": "7.3.1.1.2.4。 CEHBPolicy"
    },
    {
      "indent": 3,
      "text": "CE heartbeat policy - This policy, along with the parameter 'CE Heartbeat Dead Interval (CE HDI)' as described below, defines the operating parameters for the FE to check the CE liveness. The policy values with meanings are listed as follows:",
      "ja": "CEハートビートポリシー -  FEは、CEの生存性を確認するために、このポリシーは、後述するようにパラメータ「CEハートビートデッドインターバル（CE HDI）」と一緒に、動作パラメータを定義します。次のような意味を持つポリシーの値が記載されています："
    },
    {
      "indent": 3,
      "text": "o 0 (default) - This policy specifies that the CE will send a Heartbeat message to the FE(s) whenever the CE reaches a time interval within which no other PL messages were sent from the CE to the FE(s); refer to Section 4.3.3 and Section 7.10 for details. The CE HDI component as described below is tied to this policy.",
      "ja": "0（デフォルト） - このポリシーは、CEは、他のPLメッセージがFE（複数可）にCEから送信されなかったその中の時間間隔に達するたびにCEは、FE（S）にハートビートメッセージを送信することを指定します。 4.3.3および詳細については、7.10節を参照してください。後述のようにCEのHDI成分は、このポリシーに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "o 1 - The CE will not generate any HB messages. This actually means that the CE does not want the FE to check the CE liveness.",
      "ja": "1 O  -  CEは、任意のHBメッセージを生成しません。これは実際にCEがFEは、CEの生存性を確認する必要はありませんことを意味します。"
    },
    {
      "indent": 3,
      "text": "o Others - Reserved.",
      "ja": "その他のO  - 予約。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.5. CEHDI",
      "section_title": true,
      "ja": "H.a.1.1.o.kh. Shuhdi"
    },
    {
      "indent": 3,
      "text": "CE Heartbeat Dead Interval (CE HDI) - The time interval the FE uses to check the CE liveness. If FE has not received any messages from CE within this time interval, FE deduces lost connectivity, which implies that the CE is dead or the association to the CE is lost. Default value is 30 s.",
      "ja": "CEハートビートデッドインターバル（CE HDI） -  FEは、CEの生存性をチェックするために使用する時間間隔。 FEは、この時間間隔内CEからのメッセージを受信しない場合、FEはCEが死んでいるか、CEへの関連付けが失われることを意味失われた接続を、推論します。デフォルト値は30秒​​です。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.6. FEHBPolicy",
      "section_title": true,
      "ja": "7.3.1.1.2.6。 FEHBPolicy"
    },
    {
      "indent": 3,
      "text": "FE heartbeat policy - This policy, along with the parameter 'FE Heartbeat Interval (FE HI)', defines the operating parameters for how the FE should behave so that the CE can deduce its liveness. The policy values and the meanings are:",
      "ja": "FEハートビートポリシー - このポリシーは、パラメータと一緒に「FEハートビート間隔（FE HI）」は、FEはCEがその生存性を推測することができるように振る舞うべきかの動作パラメータを定義します。ポリシーの値と意味は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o 0 (default) - The FE should not generate any Heartbeat messages. In this scenario, the CE is responsible for checking FE liveness by setting the PL header ACK flag of the message it sends to AlwaysACK. The FE responds to the CE whenever the CE sends such Heartbeat Request messages. Refer to Section 7.10 and Section 4.3.3 for details.",
      "ja": "0（デフォルト） -  FEは、任意のハートビートメッセージを生成してはなりません。このシナリオでは、CEは、AlwaysACKに送信するメッセージのPLヘッダのACKフラグを設定することにより、FEの生存性を確認する責任があります。 FEは、CEは、このようなハートビート要求メッセージを送信するたびにCEに応答します。詳細については、7.10項及び4.3.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "o 1 - This policy specifies that the FE MUST actively send a Heartbeat message if it reaches the time interval assigned by the FE HI as long as no other messages were sent from the FE to the CE during that interval as described in Section 4.3.3.",
      "ja": "1 O  - このポリシーは、その間隔の間であれば他のメッセージをCEにFEから送信されなかったとしてFE HIによって割り当てられた時間間隔に到達した場合、セクション4.3.3に記載したようにFEが積極的にハートビートメッセージを送信しなければならないことを指定します。"
    },
    {
      "indent": 3,
      "text": "o Others - Reserved.",
      "ja": "その他のO  - 予約。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.7. FEHI",
      "section_title": true,
      "ja": "7.3.1.1.2.7。ボトムライン"
    },
    {
      "indent": 3,
      "text": "FE Heartbeat Interval (FE HI) - The time interval the FE should use to send HB as long as no other messages were sent from the FE to the CE during that interval as described in Section 4.3.3. The default value for an FE HI is 500 ms.",
      "ja": "FEハートビート間隔（FE HI） -  FEは、セクション4.3.3に記載したように他のメッセージがそのインターバル中にCEにFEから送信されなかった限り、HBを送信するために使用すべき時間間隔。 FE HIのデフォルト値は500ミリ秒です。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.8. CEID",
      "section_title": true,
      "ja": "7.3.1.1.2.8。 CON"
    },
    {
      "indent": 3,
      "text": "Primary CEID - The CEID with which the FE is associated.",
      "ja": "プライマリCEID  -  FEが関連付けられているCEID。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.9. LastCEID",
      "section_title": true,
      "ja": "7.3.1.1.2.9。 LastCEID"
    },
    {
      "indent": 3,
      "text": "Last Primary CEID - The CEID of the last CE with which the FE associated. This CE ID is reported to the new Primary CEID.",
      "ja": "最後のプライマリCEID  -  FEが関連付けられていると、最後のCEのCEID。このCE IDは、新しいプライマリCEIDに報告されます。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.10. BackupCEs",
      "section_title": true,
      "ja": "7.3.1.1.2.10。 BackupCEs"
    },
    {
      "indent": 3,
      "text": "The list of backup CEs an FE can use as backups. Refer to Section 8 for details.",
      "ja": "バックアップCEのリストFEは、バックアップとして使用することができます。詳細については、第8章を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.11. CEFailoverPolicy",
      "section_title": true,
      "ja": "7.3.1.1.2.11。 CEFailoverPolicy"
    },
    {
      "indent": 3,
      "text": "CE failover policy - This specifies the behavior of the FE when the association with the CE is lost. There is a very tight relation between CE failover policy and Section 7.3.1.1.2.8, Section 7.3.1.1.2.10, Section 7.3.1.1.2.12, and Section 8. When an association is lost, depending on configuration, one of the policies listed below is activated.",
      "ja": "CEのフェールオーバーポリシー - これは、CEとの関連付けが失われたFEの動作を指定します。 CEのフェイルオーバー・ポリシーおよびセクション7.3.1.1.2.8節7.3.1.1.2.10、節7.3.1.1.2.12、および関連付けが構成に応じて、失われた第8節、政策の一つとの間に非常に緊密な関係があります下記に記載されているがアクティブになります。"
    },
    {
      "indent": 3,
      "text": "o 0 (default) - The FE should stop functioning immediately and transition to FE OperDisable.",
      "ja": "0（デフォルト）O  -  FEは、FE OperDisableに直ちに移行機能を停止すべきです。"
    },
    {
      "indent": 3,
      "text": "o 1 - The FE should continue running and do what it can even without an associated CE. This basically requires that the FE support CE Graceful restart (and defines such support in its capabilities). If the CEFTI expires before the FE re-associates with either the primary CEID (Section 7.3.1.1.2.8) or one of possibly several backup CEs (Section 7.3.1.1.2.10), the FE will go operationally down.",
      "ja": "O 1  -  FEは実行を継続しても、関連するCEなしで何ができる行う必要があります。これは基本的にFEがCEグレースフルリスタートをサポートしている必要が（とその能力のようなサポートを定義します）。 CEFTIは、プライマリCEID（セクション7.3.1.1.2.8）または多分、いくつかのバックアップCEの1（節7.3.1.1.2.10）とFEの再関連付けする前に期限切れになった場合、FEは動作上のダウンになります。"
    },
    {
      "indent": 3,
      "text": "o Others - Reserved.",
      "ja": "その他のO  - 予約。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.12. CEFTI",
      "section_title": true,
      "ja": "7.3.1.1.2.12。 CEFTA"
    },
    {
      "indent": 3,
      "text": "CE Failover Timeout Interval (CEFTI) - The time interval associated with the CE failover policy case '0' and '1'. The default value is set to 300 seconds. Note that it is advisable to set the CEFTI value much higher than the CE Heartbeat Dead Interval (CE HDI) since the effect of expiring this parameter is devastating to the operation of the FE.",
      "ja": "CEフェイルオーバータイムアウト間隔（CEFTI） -  CEフェイルオーバー・ポリシー・ケース「0」と「1」に関連する時間間隔。デフォルト値は300秒に設定されています。このパラメータを期限切れの効果は、FEの動作に破壊的であるので、CEハートビートデッドインターバル（CE HDI）よりもはるかに高いCEFTI値を設定することが望ましいことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "7.3.1.1.2.13. FERestartPolicy",
      "section_title": true,
      "ja": "7.3.1.1.2.13。 FERestartPolicy"
    },
    {
      "indent": 3,
      "text": "FE restart policy - This specifies the behavior of the FE during an FE restart. The restart may be from an FE failure or other reasons that have made the FE down and then need to restart. The values are defined as follows:",
      "ja": "FEは、ポリシーを再起動する - これは、FEの再起動時にFEの動作を指定します。再起動がダウンFEを作り、その後、再起動する必要がありますしているFE障害やその他の理由からのものであってもよいです。値は次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "o 0(default)- Restart the FE from scratch. In this case, the FE should start from the pre-association phase.",
      "ja": "0（デフォルト） - ゼロからFEを再起動します。この場合、FEは、予め関連付け段階から開始すべきです。"
    },
    {
      "indent": 3,
      "text": "o Others - Reserved for future use.",
      "ja": "Oその他 - 今後の使用のために予約されています。"
    },
    {
      "indent": 0,
      "text": "7.3.2. FE Object LFB",
      "section_title": true,
      "ja": "H.a.o.彼の軍隊をPHPで"
    },
    {
      "indent": 3,
      "text": "The FE Object LFB is a logical entity in each FE and contains components relative to the FE itself, and not to the operation of the ForCES protocol.",
      "ja": "FEオブジェクトLFBは、各FE内の論理エンティティであり、強制的プロトコルの動作にFE自体に対してではなく、構成要素を含んでいます。"
    },
    {
      "indent": 3,
      "text": "The formal definition of the FE Object LFB can be found in [RFC5812]. The model captures the high-level properties of the FE that the CE needs to know to begin working with the FE. The class ID for this LFB class is also assigned in [RFC5812]. The singular instance of this class will always exist, and will always have instance ID 0x1 within its class. It is common, although not mandatory, for a CE to fetch much of the component and capability information from this LFB instance when the CE begins controlling the operation of the FE.",
      "ja": "FEオブジェクトLFBの正式な定義は[RFC5812]で見つけることができます。モデルは、CEがFEで作業を開始するために知っておく必要があるとFEのハイレベルのプロパティをキャプチャします。このLFBクラスのクラスIDは、[RFC5812]に割り当てられています。このクラスの単数インスタンスが常に存在し、常にそのクラス内のインスタンスIDの0x1のを持っています。 CEは、FEの動作を制御開始時CEこのLFBインスタンスから成分および能力情報の多くを取得することは、必須ではないものの、一般的です。"
    },
    {
      "indent": 0,
      "text": "7.4. Semantics of Message Direction",
      "section_title": true,
      "ja": "7.4. メッセージの方向のセマンティクス"
    },
    {
      "indent": 3,
      "text": "Recall: The PL provides a master(CE)-slave(FE) relationship. The LFBs reside at the FE and are controlled by CE.",
      "ja": "リコール：PLマスター（CE）-slave（FE）の関係を提供します。 LFBsはFEに常駐し、CEによって制御されます。"
    },
    {
      "indent": 3,
      "text": "When messages go from the CE, the LFB selector (class and instance) refers to the destination LFB selection that resides in the FE.",
      "ja": "メッセージは、CEから行く場合、LFBセレクタ（クラスおよびインスタンス）はFEに常駐先LFB選択を指します。"
    },
    {
      "indent": 3,
      "text": "When messages go from the FE to the CE, the LFB selector (class and instance) refers to the source LFB selection that resides in the FE.",
      "ja": "メッセージは、CEにFEから行く場合、LFBセレクタ（クラスおよびインスタンス）はFEに存在するソースLFB選択を指します。"
    },
    {
      "indent": 0,
      "text": "7.5. Association Messages",
      "section_title": true,
      "ja": "7.5. 投稿協会"
    },
    {
      "indent": 3,
      "text": "The ForCES Association messages are used to establish and tear down associations between FEs and CEs.",
      "ja": "ForCES協会メッセージがのFEとCE間の関連付けを確立し、解体するために使用されています。"
    },
    {
      "indent": 0,
      "text": "7.5.1. Association Setup Message",
      "section_title": true,
      "ja": "7.5.1. 協会セットアップメッセージ"
    },
    {
      "indent": 3,
      "text": "This message is sent by the FE to the CE to set up a ForCES association between them.",
      "ja": "このメッセージは、それらの間の力の関連付けを設定するためにCEにFEにより送信されます。"
    },
    {
      "indent": 3,
      "text": "Message transfer direction: FE to CE",
      "ja": "メッセージ転送方向：CEとFE"
    },
    {
      "indent": 3,
      "text": "Message header: The Message Type in the header is set to MessageType= 'AssociationSetup'. The ACK flag in the header MUST be ignored, and the Association Setup message always expects to get a response from the message receiver (CE), whether or not the setup is successful. The correlator field in the header is set, so that FE can correlate the response coming back from the CE correctly. The FE may set the source ID to 0 in the header to request that the CE should assign an FE ID for the FE in the Setup Response message.",
      "ja": "メッセージヘッダ：メッセージタイプヘッダには、のMessageType =「AssociationSetup」に設定されています。ヘッダ内のACKフラグは無視しなければなりません、そして協会セットアップメッセージは常にセットアップが成功したか否か、メッセージ受信（CE）からの応答を得ることを期待します。 FEが正しくCEから戻ってくる応答を相関させることができるように、ヘッダ内の相関フィールドは、設定されています。 FEは、CEは、セットアップ応答メッセージにFE FE用IDを割り当てる必要があることを要求するために、ヘッダに0にソースIDを設定してもよいです。"
    },
    {
      "indent": 3,
      "text": "Message body: The Association Setup message body optionally consists of zero, one, or two LFBselect TLVs, as described in Section 7.1.5. The Association Setup message only operates on the FE Object and FE Protocol LFBs; therefore, the LFB class ID in the LFBselect TLV only points to these two kinds of LFBs.",
      "ja": "メッセージ本文：セクション7.1.5で説明したように協会セットアップメッセージ本体が必要に応じて、ゼロ、1または2つのLFBselectのTLVから成ります。協会のセットアップメッセージは、FEオブジェクトとFEプロトコルLFBs上で動作します。従って、LFBselect TLVにLFBクラスIDのみLFBsのこの2種類を指します。"
    },
    {
      "indent": 6,
      "text": "The OPER-TLV in the LFBselect TLV is defined as a 'REPORT' operation. More than one component may be announced in this message using the REPORT operation to let the FE declare its configuration parameters in an unsolicited manner. These may contain components suggesting values such as the FE HB Interval or the FEID. The OPER-TLV used is defined below.",
      "ja": "OPER-TLV LFBselect TLVでは、「REPORT」操作として定義されます。複数のコンポーネントは、FEが求められていないようにして、その設定パラメータを宣言できるようにREPORT操作を使用して、このメッセージに発表されてもよいです。これらは、FE HB間隔またはFEIDなどの値を示唆している成分を含んでいてもよいです。使用OPER-TLVは以下に定義されます。"
    },
    {
      "indent": 3,
      "text": "OPER-TLV for Association Setup:",
      "ja": "協会のセットアップのためのOPER-TLV："
    },
    {
      "indent": 4,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = REPORT              |               Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    PATH-DATA-TLV for REPORT                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 29,
      "text": "Figure 23: OPER-TLV",
      "ja": "図23：OPER-TLV"
    },
    {
      "indent": 3,
      "text": "Type: Only one operation type is defined for the Association Setup message:",
      "ja": "タイプ：1つの操作のみのタイプは協会セットアップメッセージ用に定義されています。"
    },
    {
      "indent": 6,
      "text": "Type = \"REPORT\" - This type of operation is for the FE to report something to the CE.",
      "ja": "タイプ=「REPORT」 -  FEがCEに何かを報告するための操作のこのタイプです。"
    },
    {
      "indent": 3,
      "text": "PATH-DATA-TLV for REPORT: This is generically a PATH-DATA-TLV format that has been defined in Section 7 in the PATH-DATA BNF definition. The PATH-DATA-TLV for the REPORT operation MAY contain FULLDATA-TLV(s) but SHALL NOT contain any RESULT-TLV in the data format. The RESULT-TLV is defined in Section 7.1.7 and the FULLDATA-TLV is defined in Section 7.1.8.",
      "ja": "レポートのPATH-DATA-TLV：これは一般的にPATH-DATA BNF定義のセクション7で定義されているPATH-DATA-TLV形式です。 REPORT操作のためのPATH-DATA-TLVはFULLDATA-TLV（複数可）を含有してもよいが、データ形式のいずれかのRESULT-TLVを含んではなりません。 RESULT-TLVは、7.1.7項で定義され、FULLDATA-TLVは、セクション7.1.8で定義されています。"
    },
    {
      "indent": 3,
      "text": "To better illustrate the above PDU format, a tree structure for the format is shown below:",
      "ja": "良好上記PDUのフォーマットを説明するために、形式のツリー構造を以下に示します。"
    },
    {
      "indent": 3,
      "text": "main hdr (type =  Association Setup)\n     |\n     |\n     +--- T = LFBselect\n     |        |\n     |        +-- LFBCLASSID = FE object\n     |        |\n     |        |\n     |        +-- LFBInstance = 0x1\n     |\n     +--- T = LFBselect\n              |\n              +-- LFBCLASSID = FE Protocol object\n              |\n              |\n              +-- LFBInstance = 0x1\n                    |\n                    +---OPER-TLV = REPORT\n                        |\n                        +-- Path-data to one or more components",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 24: PDU Format for Association Setup Message",
      "ja": "図24：協会セットアップメッセージのためのPDUのフォーマット"
    },
    {
      "indent": 0,
      "text": "7.5.2. Association Setup Response Message",
      "section_title": true,
      "ja": "7.5.2. 協会セットアップ応答メッセージ"
    },
    {
      "indent": 3,
      "text": "This message is sent by the CE to the FE in response to the Setup message. It indicates to the FE whether or not the setup is successful, i.e., whether an association is established.",
      "ja": "このメッセージは、セットアップメッセージに応答してFEにCEによって送信されます。これは、関連付けが成立しているか否か、すなわち、セットアップが成功したか否かをFEに示します。"
    },
    {
      "indent": 3,
      "text": "Message transfer direction:",
      "ja": "メッセージ転送方向："
    },
    {
      "indent": 3,
      "text": "CE to FE",
      "ja": "FEへのCE"
    },
    {
      "indent": 3,
      "text": "Message header:",
      "ja": "メッセージヘッダ："
    },
    {
      "indent": 3,
      "text": "The Message Type in the header is set to MessageType= 'AssociationSetupResponse'. The ACK flag in the header MUST be ignored, and the Setup Response message never expects to get any more responses from the message receiver (FE). The destination ID in the header will be set to the source ID in the corresponding Association Setup message, unless that source ID was 0. If the corresponding source ID was 0, then the CE will assign an FE ID value and use that value for the destination ID.",
      "ja": "ヘッダ内のメッセージタイプは、のMessageType =「AssociationSetupResponse」に設定されています。ヘッダ内のACKフラグは無視されなければならない、とセットアップ応答メッセージは、メッセージ受信者（FE）から任意のより多くの回答を得ることを期待することはありません。ヘッダ内の宛先IDは、対応するソースIDは、次に、CEは、FE ID値を割り当て、ためにその値が使用され、0であった場合、その送信元IDが0でない限り、対応するアソシエーションのセットアップメッセージのソースIDに設定されます先のID。"
    },
    {
      "indent": 4,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Type = ASRresult       |               Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  Association Setup Result                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 25: ASResult OPER-TLV",
      "ja": "図25：OPERのasResult-TLV"
    },
    {
      "indent": 3,
      "text": "Type (16 bits):",
      "ja": "タイプ（16ビット）："
    },
    {
      "indent": 3,
      "text": "The type of the TLV is \"ASResult\".",
      "ja": "TLVのタイプは、「のasResult」です。"
    },
    {
      "indent": 3,
      "text": "Length (16 bits):",
      "ja": "長さ（16ビット）："
    },
    {
      "indent": 3,
      "text": "Length of the TLV including the T and L fields, in octets.",
      "ja": "オクテット内TとLフィールドを含むTLVの長さ。"
    },
    {
      "indent": 3,
      "text": "Association Setup result (32 bits):",
      "ja": "関連設定結果（32ビット）："
    },
    {
      "indent": 3,
      "text": "This indicates whether the Setup message was successful or whether the FE request was rejected by the CE. The defined values are:",
      "ja": "これは、セットアップメッセージが成功したか、FE要求はCEによって拒否されたかどうかかどうかを示します。定義された値は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "0 = success",
      "ja": "0 =成功"
    },
    {
      "indent": 7,
      "text": "1 = FE ID invalid",
      "ja": "1 = FE ID無効"
    },
    {
      "indent": 7,
      "text": "2 = permission denied",
      "ja": "2 =許可拒否"
    },
    {
      "indent": 3,
      "text": "To better illustrate the above PDU format, a tree structure for the format is shown below:",
      "ja": "良好上記PDUのフォーマットを説明するために、形式のツリー構造を以下に示します。"
    },
    {
      "indent": 3,
      "text": "main hdr (type =  Association Setup Response)\n |\n |\n +--- T = ASResult-TLV",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 26: PDU Format for Association Setup Response Message",
      "ja": "図26：アソシエーション設定応答メッセージのためのPDUのフォーマット"
    },
    {
      "indent": 0,
      "text": "7.5.3. Association Teardown Message",
      "section_title": true,
      "ja": "7.5.3. 協会ティアダウンメッセージ"
    },
    {
      "indent": 3,
      "text": "This message can be sent by the FE or CE to any ForCES element to end its ForCES association with that element.",
      "ja": "このメッセージは、その要素と軍事力の関連付けを終了する任意のForCES要素にFEまたはCEによって送信することができます。"
    },
    {
      "indent": 3,
      "text": "Message transfer direction:",
      "ja": "メッセージ転送方向："
    },
    {
      "indent": 3,
      "text": "CE to FE, or FE to CE (or CE to CE)",
      "ja": "（CEまたはCE）CEのFE、またはFEへのCE"
    },
    {
      "indent": 3,
      "text": "Message Header:",
      "ja": "メッセージヘッダ："
    },
    {
      "indent": 3,
      "text": "The Message Type in the header is set to MessageType= \"AssociationTeardown\". The ACK flag MUST be ignored. The correlator field in the header MUST be set to zero and MUST be ignored by the receiver.",
      "ja": "ヘッダ内のメッセージタイプは=「AssociationTeardownを」のMessageTypeに設定されています。 ACKフラグは無視しなければなりません。ヘッダ内の相関フィールドがゼロに設定しなければならなくて、受信機で無視しなければなりません。"
    },
    {
      "indent": 4,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Type = ASTreason       |               Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Teardown Reason                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 27: ASTreason-TLV",
      "ja": "図27：ASTreason-TLV"
    },
    {
      "indent": 3,
      "text": "Type (16 bits):",
      "ja": "タイプ（16ビット）："
    },
    {
      "indent": 3,
      "text": "The type of the TLV is \"ASTreason\".",
      "ja": "TLVのタイプは「ASTreason」です。"
    },
    {
      "indent": 3,
      "text": "Length (16 bits):",
      "ja": "長さ（16ビット）："
    },
    {
      "indent": 3,
      "text": "Length of the TLV including the T and L fields, in octets.",
      "ja": "オクテット内TとLフィールドを含むTLVの長さ。"
    },
    {
      "indent": 3,
      "text": "Teardown reason (32 bits):",
      "ja": "解体理由（32ビット）："
    },
    {
      "indent": 3,
      "text": "This indicates the reason why the association is being terminated. Several reason codes are defined as follows.",
      "ja": "これは、関連付けが終了している理由を示しています。次のようにいくつかの理由コードが定義されています。"
    },
    {
      "indent": 7,
      "text": "0 - normal teardown by administrator",
      "ja": "0  - 管理者によって通常のティアダウン"
    },
    {
      "indent": 7,
      "text": "1 - error - loss of heartbeats",
      "ja": "1  - エラー - ハートビートの損失"
    },
    {
      "indent": 7,
      "text": "2 - error - out of bandwidth",
      "ja": "2  - エラー - 帯域幅のうち"
    },
    {
      "indent": 7,
      "text": "3 - error - out of memory",
      "ja": "3  - エラー - メモリ不足"
    },
    {
      "indent": 7,
      "text": "4 - error - application crash",
      "ja": "4  - エラー - アプリケーションのクラッシュ"
    },
    {
      "indent": 7,
      "text": "255 - error - other or unspecified",
      "ja": "255  - エラー - その他または未指定"
    },
    {
      "indent": 3,
      "text": "To better illustrate the above PDU format, a tree structure for the format is shown below:",
      "ja": "良好上記PDUのフォーマットを説明するために、形式のツリー構造を以下に示します。"
    },
    {
      "indent": 3,
      "text": "main hdr (type =  Association Teardown)\n |\n |\n +--- T = ASTreason-TLV",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 28: PDU Format for Association Teardown Message",
      "ja": "図28：協会ティアダウンメッセージのPDUのフォーマット"
    },
    {
      "indent": 0,
      "text": "7.6. Configuration Messages",
      "section_title": true,
      "ja": "7.6. 構成メッセージ"
    },
    {
      "indent": 3,
      "text": "The ForCES Configuration messages are used by CE to configure the FEs in a ForCES NE and report the results back to the CE.",
      "ja": "ForCES設定メッセージはのForCES NE内のFEを設定し、バックCEに結果を報告するためにCEによって使用されています。"
    },
    {
      "indent": 0,
      "text": "7.6.1. Config Message",
      "section_title": true,
      "ja": "7.6.1.  Configメッセージ"
    },
    {
      "indent": 3,
      "text": "This message is sent by the CE to the FE to configure LFB components in the FE. This message is also used by the CE to subscribe/ unsubscribe to LFB events.",
      "ja": "このメッセージは、FEにLFBコンポーネントを構成するためにFEにCEによって送信されます。このメッセージは、/サブスクライブLFBイベントに解除するCEによって使用されます。"
    },
    {
      "indent": 3,
      "text": "As usual, a Config message is composed of a common header followed by a message body that consists of one or more TLV data formats. Detailed description of the message is as follows:",
      "ja": "いつものように、構成メッセージは、一つ以上のTLVデータ形式で構成され、メッセージ本体に続く共通ヘッダで構成されています。次のようにメッセージの詳細な説明は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Message transfer direction:",
      "ja": "メッセージ転送方向："
    },
    {
      "indent": 3,
      "text": "CE to FE",
      "ja": "FEへのCE"
    },
    {
      "indent": 3,
      "text": "Message header:",
      "ja": "メッセージヘッダ："
    },
    {
      "indent": 3,
      "text": "The Message Type in the header is set to MessageType= 'Config'. The ACK flag in the header can be set to any value defined in Section 6.1, to indicate whether or not a response from the FE is expected by the message.",
      "ja": "ヘッダ内のメッセージタイプが「コンフィグ」=のMessageTypeするように設定されています。ヘッダ内のACKフラグがFEからの応答がメッセージが期待されているか否かを示すために、セクション6.1で定義された任意の値に設定することができます。"
    },
    {
      "indent": 3,
      "text": "OPER-TLV for Config:",
      "ja": "コンフィグためのOPER-TLV："
    },
    {
      "indent": 4,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type                 |               Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        PATH-DATA-TLV                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 29: OPER-TLV for Config",
      "ja": "図29：コンフィグためのOPER-TLV"
    },
    {
      "indent": 3,
      "text": "Type:",
      "ja": "タイプ："
    },
    {
      "indent": 3,
      "text": "The operation type for Config message. Two types of operations for the Config message are defined:",
      "ja": "Configメッセージのための操作タイプ。 Configメッセージのための操作の二つのタイプが定義されています。"
    },
    {
      "indent": 7,
      "text": "Type = \"SET\" - This operation is to set LFB components",
      "ja": "タイプ=「SET」 - この操作は、LFBのコンポーネントを設定することです"
    },
    {
      "indent": 7,
      "text": "Type = \"SET-PROP\" - This operation is to set LFB component properties.",
      "ja": "タイプ= \"SET-PROPを\"  - この操作は、LFBのコンポーネントのプロパティを設定することです。"
    },
    {
      "indent": 7,
      "text": "Type = \"DEL\" - This operation is to delete some LFB components.",
      "ja": "タイプ=「DEL」 - この操作は、いくつかのLFBコンポーネントを削除することです。"
    },
    {
      "indent": 7,
      "text": "Type = \"COMMIT\" - This operation is sent to the FE to commit in a 2pc transaction. A COMMIT TLV is an empty TLV, i.e., it has no \"V\"alue. In other words, there is a length of 4 (which is for the header only).",
      "ja": "TYPE =「COMMIT」 - この操作は、2PCトランザクションにコミットするFEに送信されます。それには、「V」ALUEを有していない、すなわち、TLVが空TLVコミット。換言すれば、（ヘッダのみのためのものである）4の長さがあります。"
    },
    {
      "indent": 7,
      "text": "Type = \"TRCOMP\" - This operation is sent to the FE to mark the success from an NE perspective of a 2pc transaction. A TRCOMP TLV is an empty TLV, i.e., it has no \"V\"alue. In other words, there is a length of 4 (which is for the header only).",
      "ja": "=「TRCOMP」type  - この操作は、2PCトランザクションのNEの観点から成功をマークするFEに送信されます。 TRCOMP TLV、すなわち、それは「V」ALUEを有していない、空のTLVです。換言すれば、（ヘッダのみのためのものである）4の長さがあります。"
    },
    {
      "indent": 3,
      "text": "PATH-DATA-TLV:",
      "ja": "PATH-DATA-TLV："
    },
    {
      "indent": 3,
      "text": "This is generically a PATH-DATA-TLV format that has been defined in Section 7 in the PATH-DATA-TLV BNF definition. The restriction on the use of PATH-DATA-TLV for SET/SET-PROP operation is that it MUST contain either FULLDATA-TLV or SPARSEDATA-TLV(s), but MUST NOT contain any RESULT-TLV. The restriction on the use of PATH-DATA-TLV for DEL operation is it MAY contain FULLDATA-TLV or SPARSEDATA-TLV(s), but MUST NOT contain any RESULT-TLV. The RESULT-TLV is defined in Section 7.1.7 and FULLDATA-TLVs and SPARSEDATA-TLVs are defined in Section 7.1.8.",
      "ja": "これは、一般的にPATH-DATA-TLV BNFの定義では7節で定義されているPATH-DATA-TLV形式です。 SET / SET-PROP動作のためPATH-DATA-TLVの使用に関する制限は、それがFULLDATA-TLVまたはSPARSEDATA-TLV（S）のいずれかを含まなければならないが、任意のRESULT-TLVが含まれていなければならないということです。 DEL操作のためのPATH-DATA-TLVの使用上の制限は、それがFULLDATA-TLVまたはSPARSEDATA-TLV（複数可）を含んでいてもよいが、任意のRESULT-TLVを含んでいてはならないです。 RESULT-TLVは、7.1.7項で定義され、FULLDATA-のTLVとSPARSEDATA-のTLVは、セクション7.1.8で定義されています。"
    },
    {
      "indent": 7,
      "text": "Note:  For Event subscription, the events will be defined by the\n       individual LFBs.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "To better illustrate the above PDU format, a tree structure for the format is shown below:",
      "ja": "良好上記PDUのフォーマットを説明するために、形式のツリー構造を以下に示します。"
    },
    {
      "indent": 3,
      "text": "main hdr (type = Config)\n |\n |\n +--- T = LFBselect\n .        |\n .        +-- LFBCLASSID = target LFB class\n .        |\n          |\n          +-- LFBInstance = target LFB instance\n          |\n          |\n          +-- T = operation { SET }\n          |   |\n          |   +--  // one or more path targets\n          |      // associated with FULLDATA-TLV or SPARSEDATA-TLV(s)\n          |\n          +-- T = operation { DEL }\n          |   |\n          |   +--  // one or more path targets\n          |\n          +-- T = operation { COMMIT } //A COMMIT TLV is an empty TLV\n                   .\n                   .",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 30: PDU Format for Configuration Message",
      "ja": "図30：設定メッセージのPDUのフォーマット"
    },
    {
      "indent": 0,
      "text": "7.6.2. Config Response Message",
      "section_title": true,
      "ja": "7.6.2. コンフィグ応答メッセージ"
    },
    {
      "indent": 3,
      "text": "This message is sent by the FE to the CE in response to the Config message. It indicates whether or not the Config was successful on the FE and also gives a detailed response regarding the configuration result of each component.",
      "ja": "このメッセージは、Configメッセージに応答してCEにFEによって送信されます。これは、構成がFEに成功したか否かを示し、また、各成分の構成結果に関する詳細な応答を与えます。"
    },
    {
      "indent": 3,
      "text": "Message transfer direction:",
      "ja": "メッセージ転送方向："
    },
    {
      "indent": 3,
      "text": "FE to CE",
      "ja": "CEのFE"
    },
    {
      "indent": 3,
      "text": "Message header:",
      "ja": "メッセージヘッダ："
    },
    {
      "indent": 3,
      "text": "The Message Type in the header is set to MessageType= 'Config Response'. The ACK flag in the header is always ignored, and the Config Response message never expects to get any further response from the message receiver (CE).",
      "ja": "ヘッダ内のメッセージタイプは、のMessageType =「コンフィグ応答」に設定されています。ヘッダ内のACKフラグは常に無視され、構成応答メッセージは、メッセージレシーバ（CE）からの任意のさらなる応答を得ることを期待されることはありません。"
    },
    {
      "indent": 3,
      "text": "OPER-TLV for Config Response:",
      "ja": "コンフィグ応答のためのOPER-TLV："
    },
    {
      "indent": 4,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Type                 |               Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        PATH-DATA-TLV                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 31: OPER-TLV for Config Response",
      "ja": "図31：コンフィグ応答のためのOPER-TLV"
    },
    {
      "indent": 3,
      "text": "Type: The operation type for Config Response message. Two types of operations for the Config Response message are defined:",
      "ja": "タイプ：コンフィグ応答メッセージの操作タイプ。コンフィグ応答メッセージのための操作の二つのタイプが定義されています。"
    },
    {
      "indent": 7,
      "text": "Type = \"SET-RESPONSE\" - This operation is for the response of the\n       SET operation of LFB components.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Type = \"SET-PROP-RESPONSE\" - This operation is for the response of the SET-PROP operation of LFB component properties.",
      "ja": "タイプ= \"SET-PROP-RESPONSE\"  - この操作はLFBコンポーネントのプロパティのSET-PROP操作の応答のためのものです。"
    },
    {
      "indent": 7,
      "text": "Type = \"DEL-RESPONSE\" - This operation is for the response of the DELETE operation of LFB components.",
      "ja": "タイプ=「DEL-RESPONSE」 - この操作はLFB成分のDELETE操作の応答のためのものです。"
    },
    {
      "indent": 7,
      "text": "Type = \"COMMIT-RESPONSE\" - This operation is sent to the CE to confirm a commit success in a 2pc transaction. A COMMIT-RESPONSE TLV MUST contain a RESULT-TLV indicating success or failure.",
      "ja": "TYPE =「COMMIT-RESPONSEを」 - この操作は、2PCトランザクションでコミットの成功を確認するためにCEに送信されます。 COMMIT-RESPONSE TLVは、成功または失敗を示す結果-TLVを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "PATH-DATA-TLV:",
      "ja": "PATH-DATA-TLV："
    },
    {
      "indent": 3,
      "text": "This is generically a PATH-DATA-TLV format that has been defined in Section 7 in the PATH-DATA-TLV BNF definition. The restriction on the use of PATH-DATA-TLV for SET-RESPONSE operation is that it MUST contain RESULT-TLV(s). The restriction on the use of PATH-DATA-TLV for DEL-RESPONSE operation is it also MUST contain RESULT-TLV(s). The RESULT-TLV is defined in Section 7.1.7.",
      "ja": "これは、一般的にPATH-DATA-TLV BNFの定義では7節で定義されているPATH-DATA-TLV形式です。 SET-RESPONSE動作のためPATH-DATA-TLVの使用に関する制限は、それがRESULT-TLV（単数または複数）を含んでいなければならないことです。 DEL-RESPONSE動作のためPATH-DATA-TLVの使用に関する制限は、それがまたRESULT-TLV（単数または複数）を含まなければなりませんです。 RESULT-TLVは、7.1.7項で定義されています。"
    },
    {
      "indent": 3,
      "text": "To better illustrate the above PDU format, a tree structure for the format is shown below:",
      "ja": "良好上記PDUのフォーマットを説明するために、形式のツリー構造を以下に示します。"
    },
    {
      "indent": 4,
      "text": "main hdr (type = ConfigResponse)\n |\n |\n +--- T = LFBselect\n .        |\n .        +-- LFBCLASSID = target LFB class\n .        |\n          |\n          +-- LFBInstance = target LFB instance\n          |\n          |\n          +-- T = operation { SET-RESPONSE }\n          |   |\n          |   +--  // one or more path targets\n          |        // associated with FULL or SPARSEDATA-TLV(s)\n          |\n          +-- T = operation { DEL-RESPONSE }\n          |   |\n          |   +--  // one or more path targets\n          |\n          +-- T = operation { COMMIT-RESPONSE }\n          |           |\n          |           +--  RESULT-TLV",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 32: PDU Format for Config Response Message",
      "ja": "図32：コンフィグ応答メッセージのためのPDUのフォーマット"
    },
    {
      "indent": 0,
      "text": "7.7. Query Messages",
      "section_title": true,
      "ja": "7.7. クエリメッセージ"
    },
    {
      "indent": 3,
      "text": "The ForCES Query messages are used by the CE to query LFBs in the FE for information like LFB components, capabilities, statistics, etc. Query messages include the Query message and the Query Response message.",
      "ja": "ForCESクエリメッセージは、LFBのコンポーネント、機能、統計などの情報については、FEでLFBsを照会するためにCEによって使用されているなどのクエリメッセージは、クエリメッセージとクエリ応答メッセージが含まれます。"
    },
    {
      "indent": 0,
      "text": "7.7.1. Query Message",
      "section_title": true,
      "ja": "7.7.1. クエリメッセージ"
    },
    {
      "indent": 3,
      "text": "A Query message is composed of a common header and a message body that consists of one or more TLV data formats. Detailed description of the message is as follows:",
      "ja": "Queryメッセージは、共通ヘッダおよび1つまたは複数のTLVデータ形式で構成され、メッセージ本体で構成されています。次のようにメッセージの詳細な説明は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Message transfer direction:",
      "ja": "メッセージ転送方向："
    },
    {
      "indent": 3,
      "text": "from CE to FE",
      "ja": "CEからFEへ"
    },
    {
      "indent": 3,
      "text": "Message header:",
      "ja": "メッセージヘッダ："
    },
    {
      "indent": 3,
      "text": "The Message Type in the header is set to MessageType= 'Query'. The ACK flag in the header is always ignored, and a full response for a Query message is always expected. The Correlator field in the header is set, so that the CE can locate the response back from FE correctly.",
      "ja": "ヘッダ内のメッセージタイプは、のMessageType =「クエリ」に設定されています。ヘッダ内のACKフラグは常に無視され、クエリメッセージの完全な応答が常に期待されています。 CEが正しく戻ってFEからの応答を見つけることができるように、ヘッダ内の相関フィールドは、設定されています。"
    },
    {
      "indent": 3,
      "text": "OPER-TLV for Query:",
      "ja": "クエリのためのOPER-TLV："
    },
    {
      "indent": 4,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = GET/GET-PROP        |               Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    PATH-DATA-TLV for GET/GET-PROP             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 33: TLV for Query",
      "ja": "図33：クエリのためのTLV"
    },
    {
      "indent": 3,
      "text": "Type:",
      "ja": "タイプ："
    },
    {
      "indent": 3,
      "text": "The operation type for query. Two operation types are defined:",
      "ja": "クエリの操作タイプ。 2つの動作タイプが定義されています。"
    },
    {
      "indent": 7,
      "text": "Type = \"GET\" - This operation is to request to get LFB\n       components.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Type = \"GET-PROP\" - This operation is to request to get LFB component properties.",
      "ja": "TYPE = \"-PROPをGET\"  - この操作は、LFBコンポーネントのプロパティを取得するために要求することです。"
    },
    {
      "indent": 3,
      "text": "PATH-DATA-TLV for GET/GET-PROP:",
      "ja": "GET / GET-PROPのためのPATH-DATA-TLV："
    },
    {
      "indent": 3,
      "text": "This is generically a PATH-DATA-TLV format that has been defined in Section 7 in the PATH-DATA-TLV BNF definition. The restriction on the use of PATH-DATA-TLV for GET/GET-PROP operation is it MUST NOT contain any SPARSEDATA-TLV or FULLDATA- TLV and RESULT-TLV in the data format.",
      "ja": "これは、一般的にPATH-DATA-TLV BNFの定義では7節で定義されているPATH-DATA-TLV形式です。 GET / GET-PROPの操作のためのPATH-DATA-TLVの使用上の制限は、それがデータフォーマットでSPARSEDATA-TLVまたはFULLDATA- TLV、結果-TLVいずれかを含んではならないです。"
    },
    {
      "indent": 3,
      "text": "To better illustrate the above PDU format, a tree structure for the format is shown below:",
      "ja": "良好上記PDUのフォーマットを説明するために、形式のツリー構造を以下に示します。"
    },
    {
      "indent": 3,
      "text": "main hdr (type = Query)\n |\n |\n +--- T = LFBselect\n .        |\n .        +-- LFBCLASSID = target LFB class\n .        |\n          |\n          +-- LFBInstance = target LFB instance\n          |\n          |\n          +-- T = operation { GET }\n          |   |\n          |   +--  // one or more path targets\n          |\n          +-- T = operation { GET }\n          .   |\n          .   +--  // one or more path targets\n          .",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 34: PDU Format for Query Message",
      "ja": "図34：クエリメッセージのPDUのフォーマット"
    },
    {
      "indent": 0,
      "text": "7.7.2. Query Response Message",
      "section_title": true,
      "ja": "7.7.2. クエリ応答メッセージ"
    },
    {
      "indent": 3,
      "text": "When receiving a Query message, the receiver should process the message and come up with a query result. The receiver sends the query result back to the message sender by use of the Query Response message. The query result can be the information being queried if the query operation is successful, or can also be error codes if the query operation fails, indicating the reasons for the failure.",
      "ja": "Queryメッセージを受信すると、受信者はメッセージを処理し、クエリ結果を考え出す必要があります。受信機は、クエリ応答メッセージを使用してバックメッセージの送信者への問い合わせ結果を送信します。クエリ結果は、クエリ操作が成功した場合に照会される情報であってもよく、またはクエリ操作が失敗した場合、エラー・コードとすることができ、失敗の理由を示します。"
    },
    {
      "indent": 3,
      "text": "A Query Response message is also composed of a common header and a message body consisting of one or more TLVs describing the query result. Detailed description of the message is as follows:",
      "ja": "クエリ応答メッセージは、共通ヘッダとクエリ結果を記述する1つのまたは複数のTLVからなるメッセージ本体で構成されています。次のようにメッセージの詳細な説明は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Message transfer direction:",
      "ja": "メッセージ転送方向："
    },
    {
      "indent": 3,
      "text": "from FE to CE",
      "ja": "FEからCEへ"
    },
    {
      "indent": 3,
      "text": "Message header:",
      "ja": "メッセージヘッダ："
    },
    {
      "indent": 3,
      "text": "The Message Type in the header is set to MessageType= 'QueryResponse'. The ACK flag in the header is ignored. As a response itself, the message does not expect a further response.",
      "ja": "ヘッダ内のメッセージタイプは、のMessageType =「QueryResponse」に設定されています。ヘッダ内のACKフラグは無視されます。応答自体として、メッセージはさらに、応答を期待していません。"
    },
    {
      "indent": 3,
      "text": "OPER-TLV for Query Response:",
      "ja": "クエリ応答のためのOPER-TLV："
    },
    {
      "indent": 4,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Type = GET-RESPONSE/GET-PROP-RESPONSE|    Length               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        PATH-DATA-TLV for GET-RESPONSE/GET-PROP-RESPONSE       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 35: TLV for Query Response",
      "ja": "図35：クエリ応答のためのTLV"
    },
    {
      "indent": 3,
      "text": "Type:",
      "ja": "タイプ："
    },
    {
      "indent": 3,
      "text": "The operation type for query response. One operation type is defined:",
      "ja": "クエリ応答のための操作タイプ。一つの操作タイプが定義されます。"
    },
    {
      "indent": 7,
      "text": "Type = \"GET-RESPONSE\" - This operation is for the response of the\n       GET operation of LFB components.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Type = \"GET-PROP-RESPONSE\" - This operation is for the response of the GET-PROP operation of LFB components.",
      "ja": "タイプは、= \"GET-PROP-RESPONSE\"  - この操作は、LFBコンポーネントのGET-PROPの操作の応答のためです。"
    },
    {
      "indent": 3,
      "text": "PATH-DATA-TLV for GET-RESPONSE/GET-PROP-RESPONSE:",
      "ja": "PATH-DATA-TLV GET-RESPONSE / GET-PROP-RESPONSEのために："
    },
    {
      "indent": 3,
      "text": "This is generically a PATH-DATA-TLV format that has been defined in Section 7 in the PATH-DATA-TLV BNF definition. The PATH-DATA- TLV for the GET-RESPONSE operation MAY contain SPARSEDATA-TLV, FULLDATA-TLV, and/or RESULT-TLV(s) in the data encoding. The RESULT-TLV is defined in Section 7.1.7 and the SPARSEDATA-TLVs and FULLDATA-TLVs are defined in Section 7.1.8.",
      "ja": "これは、一般的にPATH-DATA-TLV BNFの定義では7節で定義されているPATH-DATA-TLV形式です。 PATH-DATA- TLV GET応答動作のためには、データ符号化にSPARSEDATA-TLV、FULLDATA-TLV、および/または結果-TLV（S）を含んでいてもよいです。 RESULT-TLVは、7.1.7項で定義され、SPARSEDATA-のTLVとFULLDATA-のTLVは、セクション7.1.8で定義されています。"
    },
    {
      "indent": 3,
      "text": "To better illustrate the above PDU format, a tree structure for the format is shown below:",
      "ja": "良好上記PDUのフォーマットを説明するために、形式のツリー構造を以下に示します。"
    },
    {
      "indent": 3,
      "text": "main hdr (type = QueryResponse)\n  |\n  |\n  +--- T = LFBselect\n  .        |\n  .        +-- LFBCLASSID = target LFB class\n  .        |\n           |\n           +-- LFBInstance = target LFB instance\n           |\n           |\n           +-- T = operation { GET-RESPONSE }\n           |   |\n           |   +--  // one or more path targets\n           |\n           +-- T = operation { GET-PROP-RESPONSE }\n           .   |\n           .   +--  // one or more path targets\n           .",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 36: PDU Format for Query Response Message",
      "ja": "図36：クエリ応答メッセージのためのPDUのフォーマット"
    },
    {
      "indent": 0,
      "text": "7.8. Event Notification Message",
      "section_title": true,
      "ja": "7.8. イベント通知メッセージ"
    },
    {
      "indent": 3,
      "text": "Event Notification message is used by the FE to asynchronously notify the CE of events that happen in the FE.",
      "ja": "イベント通知メッセージは、非同期FEに発生するイベントのCEに通知するためにFEによって使用されます。"
    },
    {
      "indent": 3,
      "text": "All events that can be generated in an FE are subscribable by the CE. The CE can subscribe to an event via a Config message with the SET-PROP operation, where the included path specifies the event, as defined by the LFB Library and described by the FE Model.",
      "ja": "FEで生成することができるすべてのイベントは、CEによってサブスクライブされています。 CEは、LFBライブラリによって定義され、FEモデルによって記載されるように含まれるパスは、イベントを指定SET-PROP動作とConfigメッセージを介してイベントをサブスクライブすることができます。"
    },
    {
      "indent": 3,
      "text": "As usual, an Event Notification message is composed of a common header and a message body that consists of one or more TLV data formats. Detailed description of the message is as follows:",
      "ja": "いつものように、イベント通知メッセージは、共通ヘッダおよび1つまたは複数のTLVデータ形式で構成され、メッセージ本体で構成されています。次のようにメッセージの詳細な説明は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Message transfer direction:",
      "ja": "メッセージ転送方向："
    },
    {
      "indent": 3,
      "text": "FE to CE",
      "ja": "CEのFE"
    },
    {
      "indent": 3,
      "text": "Message header:",
      "ja": "メッセージヘッダ："
    },
    {
      "indent": 3,
      "text": "The Message Type in the message header is set to MessageType = 'EventNotification'. The ACK flag in the header MUST be ignored by the CE, and the Event Notification message does not expect any response from the receiver.",
      "ja": "メッセージヘッダ内のメッセージタイプは、のMessageType =「EventNotification」に設定されています。ヘッダ内のACKフラグはCEによって無視されなければならない、およびイベント通知メッセージは、受信機からの応答を期待しません。"
    },
    {
      "indent": 3,
      "text": "OPER-TLV for Event Notification:",
      "ja": "イベント通知のためのOPER-TLV："
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = REPORT              |               Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    PATH-DATA-TLV for REPORT                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 37: TLV for Event Notification",
      "ja": "図37：イベント通知のためのTLV"
    },
    {
      "indent": 3,
      "text": "Type:",
      "ja": "タイプ："
    },
    {
      "indent": 3,
      "text": "Only one operation type is defined for the Event Notification message:",
      "ja": "唯一の操作タイプは、イベント通知メッセージ用に定義されています。"
    },
    {
      "indent": 6,
      "text": "Type = \"REPORT\" - This type of operation is for the FE to report something to the CE.",
      "ja": "タイプ=「REPORT」 -  FEがCEに何かを報告するための操作のこのタイプです。"
    },
    {
      "indent": 3,
      "text": "PATH-DATA-TLV for REPORT:",
      "ja": "レポートのPATH-DATA-TLV："
    },
    {
      "indent": 3,
      "text": "This is generically a PATH-DATA-TLV format that has been defined in Section 7 in the PATH-DATA-TLV BNF definition. The PATH-DATA- TLV for the REPORT operation MAY contain FULLDATA-TLV or SPARSEDATA-TLV(s) but MUST NOT contain any RESULT-TLV in the data format.",
      "ja": "これは、一般的にPATH-DATA-TLV BNFの定義では7節で定義されているPATH-DATA-TLV形式です。 REPORT操作のためのPATH-DATA- TLVはFULLDATA-TLVまたはSPARSEDATA-TLV（複数可）を含有してもよいが、データ形式のいずれかのRESULT-TLVを含めることはできません。"
    },
    {
      "indent": 3,
      "text": "To better illustrate the above PDU format, a tree structure for the format is shown below:",
      "ja": "良好上記PDUのフォーマットを説明するために、形式のツリー構造を以下に示します。"
    },
    {
      "indent": 3,
      "text": "main hdr (type = Event Notification)\n  |\n  |\n  +--- T = LFBselect\n             |\n             +-- LFBCLASSID = target LFB class\n             |\n             |\n             +-- LFBInstance = target LFB instance\n             |\n             |\n             +-- T = operation { REPORT }\n             |   |\n             |   +--  // one or more path targets\n             |        // associated with FULL/SPARSE DATA TLV(s)\n             +-- T = operation { REPORT }\n             .   |\n             .   +--  // one or more path targets\n             .        // associated with FULL/SPARSE DATA TLV(s)",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 38: PDU Format for Event Notification Message",
      "ja": "図38：イベント通知メッセージのためのPDUのフォーマット"
    },
    {
      "indent": 0,
      "text": "7.9. Packet Redirect Message",
      "section_title": true,
      "ja": "7.9. パケットリダイレクトメッセージ"
    },
    {
      "indent": 3,
      "text": "A Packet Redirect message is used to transfer data packets between the CE and FE. Usually, these data packets are control packets, but they may be just data path packets that need further (exception or high-touch) processing. It is also feasible that this message carries no data packets and rather just meta data.",
      "ja": "パケットリダイレクトメッセージは、CEとFEとの間でデータパケットを転送するために使用されます。通常、これらのデータパケットは、制御パケットですが、彼らは、さらに（例外またはハイタッチ）処理を必要とするだけで、データパスパケットかもしれません。このメッセージがデータパケットというだけでメタデータを搬送しないことも可能です。"
    },
    {
      "indent": 3,
      "text": "The Packet Redirect message data format is formatted as follows:",
      "ja": "次のようにパケットリダイレクトメッセージのデータフォーマットがフォーマットされています。"
    },
    {
      "indent": 3,
      "text": "Message transfer direction:",
      "ja": "メッセージ転送方向："
    },
    {
      "indent": 3,
      "text": "CE to FE or FE to CE",
      "ja": "CEのFEやFEへのCE"
    },
    {
      "indent": 3,
      "text": "Message header:",
      "ja": "メッセージヘッダ："
    },
    {
      "indent": 3,
      "text": "The Message Type in the header is set to MessageType= 'PacketRedirect'.",
      "ja": "ヘッダ内のメッセージタイプは、のMessageType =「PacketRedirect」に設定されています。"
    },
    {
      "indent": 3,
      "text": "Message body:",
      "ja": "メッセージ本文："
    },
    {
      "indent": 3,
      "text": "This consists of one or more TLVs that contain or describe the packet being redirected. The TLV is specifically a Redirect TLV (with the TLV Type=\"Redirect\"). Detailed data format of a Redirect TLV for a Packet Redirect message is as follows:",
      "ja": "これは、含まれているか、リダイレクトされたパケットを記述する1つのまたは複数のTLVで構成されています。 TLVは、具体的には（TLVタイプ=「リダイレクトする」で）リダイレクトTLVです。次のようにパケットリダイレクトメッセージのリダイレクトTLVの詳細なデータフォーマットです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Type = Redirect        |               Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Meta Data TLV                          |\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Redirect Data TLV                      |\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 39: Redirect_Data TLV",
      "ja": "図39：Redirect_Data TLV"
    },
    {
      "indent": 3,
      "text": "Meta Data TLV:",
      "ja": "メタデータTLV："
    },
    {
      "indent": 3,
      "text": "This is a TLV that specifies meta data associated with followed redirected data. The TLV is as follows:",
      "ja": "これは、その後リダイレクトされたデータに関連付けられたメタデータを指定するTLVです。次のようにTLVは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = METADATA-TLV        |               Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Meta Data ILV                          |\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                           ...                                 ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Meta Data ILV                          |\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 40: METADATA-TLV",
      "ja": "図40：METADATA-TLV"
    },
    {
      "indent": 3,
      "text": "Meta Data ILV:",
      "ja": "メタデータILV："
    },
    {
      "indent": 3,
      "text": "This is an Identifier-Length-Value format that is used to describe one meta data. The ILV has the format as:",
      "ja": "これは、1つのメタデータを記述するために使用される識別子レングス値の形式です。 ILVは通りの形式になっています。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Meta Data ID                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Length                                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Meta Data Value                        |\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 41: Meta Data ILV",
      "ja": "図41：メタデータILV"
    },
    {
      "indent": 3,
      "text": "where Meta Data ID is an identifier for the meta data, which is statically assigned by the LFB definition.",
      "ja": "メタデータIDは静的LFB定義によって割り当てられたメタデータの識別子です。"
    },
    {
      "indent": 3,
      "text": "Redirect Data TLV:",
      "ja": "データTLVをリダイレクトします。"
    },
    {
      "indent": 3,
      "text": "This is a TLV describing one packet of data to be directed via the redirect operation. The TLV format is as follows:",
      "ja": "これは、リダイレクト動作を介して導かれるデータの一つのパケットを記述するTLVです。次のようにTLVの形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = REDIRECTDATA-TLV    |               Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Redirected Data                        |\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 42: Redirect Data TLV",
      "ja": "図42：データTLVリダイレクト"
    },
    {
      "indent": 3,
      "text": "Redirected Data:",
      "ja": "リダイレクトされたデータ："
    },
    {
      "indent": 3,
      "text": "This field contains the packet that is to be redirected in network byte order. The packet should be 32 bits aligned as is the data for all TLVs. The meta data infers what kind of packet is carried in value field and therefore allows for easy decoding of data encapsulated.",
      "ja": "このフィールドは、ネットワークバイト順にリダイレクトされるパケットが含まれています。パケットは、すべてのTLVのためのデータであるように整列さ32ビットであるべきです。メタデータは、値フィールドで運ばれ、したがって、カプセル化されたデータを簡単にデコードすることができますされたパケットの種類を推定します。"
    },
    {
      "indent": 3,
      "text": "To better illustrate the above PDU format, a tree structure for the format is shown below:",
      "ja": "良好上記PDUのフォーマットを説明するために、形式のツリー構造を以下に示します。"
    },
    {
      "indent": 3,
      "text": "main hdr (type = PacketRedirect)\n        |\n        |\n        +--- T = Redirect\n        .        |\n        .        +-- T = METADATA-TLV\n                 |          |\n                 |          +--  Meta Data ILV\n                 |          |\n                 |          +--  Meta Data ILV\n                 |          .\n                 |          .\n                 |\n                 +-- T = REDIRECTDATA-TLV\n                     |\n                     +--  // Redirected Data",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 43: PDU Format for Packet Redirect Message",
      "ja": "図43：パケットリダイレクトメッセージのPDUフォーマット"
    },
    {
      "indent": 0,
      "text": "7.10. Heartbeat Message",
      "section_title": true,
      "ja": "7.10. ハートビートメッセージ"
    },
    {
      "indent": 3,
      "text": "The Heartbeat (HB) message is used for one ForCES element (FE or CE) to asynchronously notify one or more other ForCES elements in the same ForCES NE on its liveness. Section 4.3.3 describes the traffic-sensitive approach used.",
      "ja": "ハートビート（HB）メッセージは非同期そのライブネスに同一のForCESのNE内の1つまたは複数の他の力の要素を通知するために、1つのForCES要素（FEまたはCE）のために使用されます。 4.3.3は、使用されるトラフィックに敏感なアプローチを説明しています。"
    },
    {
      "indent": 3,
      "text": "A Heartbeat message is sent by a ForCES element periodically. The parameterization and policy definition for heartbeats for an FE are managed as components of the FE Protocol Object LFB, and can be set by CE via a Config message. The Heartbeat message is a little different from other protocol messages in that it is only composed of a common header, with the message body left empty. A detailed description of the message is as follows:",
      "ja": "ハートビートメッセージは、定期的のForCES要素によって送信されます。 FEのためのハートビートのためのパラメータとポリシー定義は、FEプロトコルオブジェクトLFBのコンポーネントとして管理され、Configメッセージを介してCEによって設定することができます。ハートビートメッセージは、メッセージ本体が空のままで、それが唯一、共通ヘッダで構成されているという点で他のプロトコルメッセージとは少し異なっています。次のようにメッセージの詳細な説明は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Message transfer direction:",
      "ja": "メッセージ転送方向："
    },
    {
      "indent": 3,
      "text": "FE to CE or CE to FE",
      "ja": "FEへのCEまたはCEのFE"
    },
    {
      "indent": 3,
      "text": "Message header:",
      "ja": "メッセージヘッダ："
    },
    {
      "indent": 3,
      "text": "The Message Type in the message header is set to MessageType = 'Heartbeat'. Section 4.3.3 describes the HB mechanisms used. The ACK flag in the header MUST be set to either 'NoACK' or 'AlwaysACK' when the HB is sent.",
      "ja": "メッセージヘッダ内のメッセージタイプは、のMessageType =「ハートビート」に設定されています。 4.3.3を使用HBのメカニズムについて説明します。 HBが送信されたとき、ヘッダ内のACKフラグが「ノアック」または「AlwaysACK」のいずれかに設定しなければなりません。"
    },
    {
      "indent": 7,
      "text": "* When set to 'NoACK', the HB is not soliciting for a response.",
      "ja": "「ノアック」に設定した場合*、HBは、応答のために勧誘されていません。"
    },
    {
      "indent": 7,
      "text": "* When set to 'AlwaysACK', the HB Message sender is always expecting a response from its receiver. According to the HB policies defined in Section 7.3.1, only the CE can send such an HB message to query FE liveness. For simplicity and because of the minimal nature of the HB message, the response to an HB message is another HB message, i.e., no specific HB Response message is defined. Whenever an FE receives an HB message marked with 'AlwaysACK' from the CE, the FE MUST send an HB message back immediately. The HB message sent by the FE in response to the 'AlwaysACK' MUST modify the source and destination IDs so that the ID of the FE is the source ID and the CE ID of the sender is the destination ID, and MUST change the ACK information to 'NoACK'. A CE MUST NOT respond to an HB message with 'AlwaysACK' set.",
      "ja": "「AlwaysACK」に設定した場合*、HBメッセージの送信者は、常に、その受信機からの応答を期待しています。 7.3.1項で定義されたHBの方針によると、唯一のCEは、FEの生存性を照会するために、このようなHBメッセージを送ることができます。簡略化のため及びためHBメッセージの最小の性質のため、HBメッセージに対する応答は、別のHBメッセージ、すなわち、特別なHB応答メッセージが定義されていませんです。 FEは、CEから「AlwaysACK」が付くHBメッセージを受信するたびに、FEはすぐに戻ってHBメッセージを送らなければなりません。 「AlwaysACK」に応答して、FEによって送信されたHBメッセージはFEのIDがソースIDであり、送信側のCEのIDが宛先IDとなるように、ソースと宛先のIDを変更する必要があり、及びACK情報を変更する必要があります「ノアック」へ。 CEは、「AlwaysACK」を設定してHBメッセージに応じてはいけません。"
    },
    {
      "indent": 7,
      "text": "* When set to anything else other than 'NoACK' or 'AlwaysACK', the HB message is treated as if it was a 'NoACK'.",
      "ja": "「ノアック」または「AlwaysACK」以外の何かに設定されている場合、それは「ノアック」だったかのように*、HBメッセージが処理されます。"
    },
    {
      "indent": 3,
      "text": "The correlator field in the HB message header SHOULD be set accordingly when a response is expected so that a receiver can correlate the response correctly. The correlator field MAY be ignored if no response is expected.",
      "ja": "受信機が正しく応答を相関させることができるように、応答が予想される場合HBメッセージヘッダーの相関フィールドは、それに応じて設定されるべきです。応答が期待されていない場合は相関フィールドは無視してもよいです。"
    },
    {
      "indent": 3,
      "text": "Message body:",
      "ja": "メッセージ本文："
    },
    {
      "indent": 3,
      "text": "The message body is empty for the Heartbeat message.",
      "ja": "メッセージ本文には、ハートビートメッセージのため空です。"
    },
    {
      "indent": 0,
      "text": "8. High Availability Support",
      "section_title": true,
      "ja": "8.高可用性サポート"
    },
    {
      "indent": 3,
      "text": "The ForCES protocol provides mechanisms for CE redundancy and failover, in order to support High Availability as defined in [RFC3654]. FE redundancy and FE to FE interaction is currently out of scope of this document. There can be multiple redundant CEs and FEs in a ForCES NE. However, at any one time only one primary CE can control the FEs though there can be multiple secondary CEs. The FE and the CE PL are aware of the primary and secondary CEs. This information (primary, secondary CEs) is configured in the FE and in the CE PLs during pre-association by the FEM and the CEM respectively. Only the primary CE sends control messages to the FEs.",
      "ja": "ForCESプロトコルは、[RFC3654]で定義されるように高可用性をサポートするために、CEの冗長性およびフェイルオーバーのためのメカニズムを提供します。 FEの冗長性とFE FEへの相互作用は、この文書の範囲の外に現在あります。 ForCES NEで複数の冗長CEとFEが存在する場合があります。複数の二次のCEが存在し得るもののしかし、一度に1つのプライマリCEは複数のFEを制御することができます。 FEおよびCE PLは、プライマリとセカンダリのCEを認識しています。この情報（一次、二次のCE）はそれぞれFEMおよびCEMによって予め関連付け中FEおよびCE用のPLに構成されています。唯一の主要CEフェズに制御メッセージを送信します。"
    },
    {
      "indent": 0,
      "text": "8.1. Relation with the FE Protocol",
      "section_title": true,
      "ja": "8.1.  FE議定書との関係"
    },
    {
      "indent": 3,
      "text": "High Availability parameterization in an FE is driven by configuring the FE Protocol Object LFB (refer to Appendix B and Section 7.3.1). The FE Heartbeat Interval, CE Heartbeat Dead Interval, and CE",
      "ja": "FEでの高可用性のパラメータはFEプロトコルオブジェクトLFBを（付録Bおよび7.3.1項を参照）の設定によって駆動されます。 FEハートビート間隔、CEハートビートデッドインターバル、およびCE"
    },
    {
      "indent": 3,
      "text": "Heartbeat policy help in detecting connectivity problems between an FE and CE. The CE failover policy defines the reaction on a detected failure.",
      "ja": "FEとCE間の接続の問題を検出する心拍ポリシーヘルプ。 CE・フェイルオーバー・ポリシーは、検出された障害に反応を定義します。"
    },
    {
      "indent": 3,
      "text": "Figure 44 extends the state machine illustrated in Figure 4 to allow for new states that facilitate connection recovery.",
      "ja": "図44は、図4に示す状態マシンが接続の回復を促進する新たな状態を可能にするように延びています。"
    },
    {
      "indent": 7,
      "text": "(CE issues Teardown ||    +-----------------+\n   Lost association) &&   | Pre-association |\n  CE failover policy = 0  | (Association    |\n      +------------>-->-->|   in            +<----+\n      |                   | progress)       |     |\n      |     CE issues     +--------+--------+     |\n      |     Association        |                  | CFTI\n      |       Setup            V                  | timer\n      |     ___________________+                  | expires\n      |     |                                     |\n      |     V                                     ^\n    +-+-----------+                          +-------+-----+\n    |             |                          |  Not        |\n    |             |  (CE issues Teardown ||  |  Associated |\n    |             |    Lost association) &&  |             |\n    | Associated  |  CE failover policy = 1  | (May        |\n    |             |                          | Continue    |\n    |             |---------->------->------>|  Forwarding)|\n    |             |                          |             |\n    +-------------+                          +-------------+\n         ^                                         V\n         |                                         |\n         |            CE issues                    |\n         |            Association                  |\n         |            Setup                        |\n         +_________________________________________+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 44: FE State Machine Considering HA",
      "ja": "図44：FEステートマシンは、HAを考えます"
    },
    {
      "indent": 3,
      "text": "Section 4.2 describes transitions between the pre-association, associated, and not associated states.",
      "ja": "セクション4.2は、関連する事前会合ではなく関連する状態間の遷移を記述する。"
    },
    {
      "indent": 3,
      "text": "When communication fails between the FE and CE (which can be caused by either the CE or link failure but not FE related), either the TML on the FE will trigger the FE PL regarding this failure or it will be detected using the HB messages between FEs and CEs. The communication failure, regardless of how it is detected, MUST be considered as a loss of association between the CE and corresponding FE.",
      "ja": "通信は、FEにFEおよびCE（CEまたはリンクの障害ではなく、FEは、関連のいずれかによって引き起こされ得る）、のいずれかTMLの間に失敗した場合、この失敗に関するFE PLをトリガするか、間HBメッセージを使用して検出されますFEおよびCEの。通信障害は関係なく、それが検出される方法の、CEと対応FEとの間の関連性の損失とみなされなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the FE's FEPO CE failover policy is configured to mode 0 (the default), it will immediately transition to the pre-association phase. This means that if association is again established, all FE state will need to be re-established.",
      "ja": "FEののFePO CEのフェイルオーバー・ポリシーはモード0（デフォルト）に設定されている場合、それはすぐに事前会合フェーズに移行します。これは、関連付けが再び確立された場合、すべてのFE状態を再確立する必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "If the FE's FEPO CE failover policy is configured to mode 1, it indicates that the FE is capable of HA restart recovery. In such a case, the FE transitions to the not associated state and the CEFTI timer is started. The FE MAY continue to forward packets during this state. It MAY also recycle through any configured secondary CEs in a round-robin fashion. It first adds its primary CE to the tail of backup CEs and sets its primary CE to be the first secondary. It then attempts to associate with the CE designated as the new primary CE. If it fails to re-associate with any CE and the CEFTI expires, the FE then transitions to the pre-association state.",
      "ja": "FEののFePO CEのフェイルオーバー・ポリシーはモード1に設定されている場合、それは、FEは、HAの再起動の回復が可能であることを示しています。そのような場合には、FEは関連していない状態に遷移し、CEFTIタイマーが開始されます。 FEは、この状態の間にパケットを転送し続けることができます。また、ラウンドロビン方式で任意の設定されたセカンダリのCEを通じてリサイクルしてもよい（MAY）。これは、最初のバックアップCEの末尾にその主CEを追加し、その主なCEは、第一の二次であることを設定します。その後、新しいプライマリCEとして指定されたCEとの関連付けを試みます。それはどんなCEとの会合を再に失敗し、CEFTIの有効期限が切れた場合、FEは、事前会合状態に移行します。"
    },
    {
      "indent": 3,
      "text": "If the FE, while in the not associated state, manages to reconnect to a new primary CE before CEFTI expires, it transitions to the associated state. Once re-associated, the FE tries to recover any state that may have been lost during the not associated state. How the FE achieves this is out of scope for this document.",
      "ja": "FEは、関連付けられていない状態で、CEFTIの有効期限が切れる前に、新しいプライマリCEへの再接続を管理しながら場合は、関連する状態に移行します。再関連付けられた後、FEは関連していない状態の間に失われた可能性のある状態を回復しようとします。 FEがどのように達成するか、これはこの文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Figure 45 below illustrates the ForCES message sequences that the FE uses to recover the connection.",
      "ja": "図45は、以下FEが接続を回復するために使用するのForCESメッセージシーケンスを示す図です。"
    },
    {
      "indent": 7,
      "text": "  FE                   CE Primary        CE Secondary\n  |                       |                    |\n  |  Asso Estb,Caps exchg |                    |\n1 |<--------------------->|                    |\n  |                       |                    |\n  |       All msgs        |                    |\n2 |<--------------------->|                    |\n  |                       |                    |\n  |                       |                    |\n  |                   FAILURE                  |\n  |                                            |\n  |         Asso Estb,Caps exchange            |\n3 |<------------------------------------------>|\n  |                                            |\n  |              Event Report (pri CE down)    |\n4 |------------------------------------------->|\n  |                                            |\n  |                   All Msgs                 |\n5 |<------------------------------------------>|",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 45: CE Failover for Report Primary Mode",
      "ja": "図45：レポートのプライマリモードのCEフェイルオーバー"
    },
    {
      "indent": 3,
      "text": "A CE-to-CE synchronization protocol would be needed to support fast failover as well as to address some of the corner cases; however, this will not be defined by the ForCES protocol as it is out of scope for this specification.",
      "ja": "CE-へ-CE同期プロトコルは、高速フェイルオーバーをサポートするだけでなく、コーナーケースの一部に対処するために必要とされるであろう。それは本明細書の範囲外であり、しかし、これはのForCESプロトコルによって定義されることはありません。"
    },
    {
      "indent": 3,
      "text": "An explicit message (a Config message setting primary CE component in the FE Protocol Object) from the primary CE can also be used to change the primary CE for an FE during normal protocol operation.",
      "ja": "一次CEからの明示的なメッセージ（ConfigメッセージFEプロトコルオブジェクトのプライマリCEコンポーネントを設定）は、通常のプロトコル動作中FEのプライマリCEを変更するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Also note that the FEs in a ForCES NE could also use a multicast CE ID, i.e., they could be associated with a group of CEs (this assumes the use of a CE-CE synchronization protocol, which is out of scope for this specification). In this case, the loss of association would mean that communication with the entire multicast group of CEs has been lost. The mechanisms described above will apply for this case as well during the loss of association. If, however, the secondary CE was also using the multicast CE ID that was lost, then the FE will need to form a new association using a different CE ID. If the capability exists, the FE MAY first attempt to form a new association with the original primary CE using a different non-multicast CE ID.",
      "ja": "また、（これは本明細書の範囲外であるCE-CE同期プロトコルの使用を想定している）のForCESのNEでのFEはまた、マルチキャストCEのIDを使用することができ、すなわち、それらはCEのグループに関連付けることができることに注意してください。この場合には、関連の損失は、CEの全マルチキャストグループとの通信が失われたことを意味します。上記機構は、関連の損失時にも、この場合に適用されます。しかし、二次CEはまた、失われたマルチキャストCEのIDを使用していた場合、FEは異なるCEのIDを使用して、新しいアソシエーションを形成する必要があります。能力が存在する場合、FEは、第異なる非マルチキャストCEのIDを使用して、元の一次CEとの新たな関連付けを形成することを試みることができます。"
    },
    {
      "indent": 0,
      "text": "8.2. Responsibilities for HA",
      "section_title": true,
      "ja": "8.2.  HAのための責任"
    },
    {
      "indent": 3,
      "text": "TML level:",
      "ja": "TMLレベル："
    },
    {
      "indent": 3,
      "text": "1. The TML controls logical connection availability and failover.",
      "section_title": true,
      "ja": "1. TMLは、論理接続の可用性およびフェイルオーバーを制御します。"
    },
    {
      "indent": 3,
      "text": "2. The TML also controls peer HA management.",
      "section_title": true,
      "ja": "2. TMLはまた、ピアHA管理を制御します。"
    },
    {
      "indent": 3,
      "text": "At this level, control of all lower layers, for example, transport level (such as IP addresses, MAC addresses, etc.) and associated links going down are the role of the TML.",
      "ja": "このレベルで、すべての下位層の制御は、例えば、ダウン及び関連するリンク（例えば、IPアドレス、MACアドレスなど）トランスポートレベルはTMLの役割です。"
    },
    {
      "indent": 3,
      "text": "PL level:",
      "ja": "PLレベル："
    },
    {
      "indent": 3,
      "text": "All other functionality, including configuring the HA behavior during setup, the CE IDs used to identify primary and secondary CEs, protocol messages used to report CE failure (Event Report), Heartbeat messages used to detect association failure, messages to change the primary CE (Config), and other HA-related operations described before, are the PL responsibility.",
      "ja": "セットアップ中にHAの動作を設定するなど、他のすべての機能、プライマリとセカンダリのCE、CEの失敗（イベントレポート）を報告するために使用されるプロトコルメッセージ、関連の障害を検出するために使用されるハートビートメッセージを識別するために使用されるCEのIDは、主CEを変更するには、メッセージ（構成）、および前述の他のHA関連の操作は、PLの責任です。"
    },
    {
      "indent": 3,
      "text": "To put the two together, if a path to a primary CE is down, the TML would take care of failing over to a backup path, if one is available. If the CE is totally unreachable, then the PL would be informed and it would take the appropriate actions described earlier.",
      "ja": "主CEへのパスがダウンしている場合は、1つが利用可能な場合一緒に2を入れて、TMLは、バックアップパスへのフェイルオーバーの世話をするでしょう。 CEは完全に到達不能である場合には、PLが通知されるだろうし、それは、前述の適切な行動を取るだろう。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The ForCES framework document [RFC3746], Section 8, goes into extensive detail on a variety of security threats, the possible effects of those threats on the protocol, and responses to those threats. This document does not repeat that discussion; the reader is referred to the ForCES framework document [RFC3746] for those details and how the ForCES architecture addresses them.",
      "ja": "ForCESフレームワークドキュメント[RFC3746]、セクション8には、セキュリティ上の脅威、プロトコル上でこれらの脅威の可能性のある影響、およびそれらの脅威に対する応答の様々な大規模なディテールに入ります。この文書では、その議論を繰り返しません。読者はこれらの詳細についてのForCESフレームワークドキュメント[RFC3746]と呼ぶ、強制的アーキテクチャは、それらに対処する方法をされています。"
    },
    {
      "indent": 3,
      "text": "ForCES PL uses security services provided by the ForCES TML. The TML provides security services such as endpoint authentication service, message authentication service, and confidentiality service. Endpoint authentication service is invoked at the time of the pre-association connection establishment phase and message authentication is performed whenever the FE or CE receives a packet from its peer.",
      "ja": "ForCES PLはのForCES TMLが提供するセキュリティ・サービスを使用しています。 TMLは、エンドポイントの認証サービス、メッセージ認証サービス、および機密性サービスなどのセキュリティサービスを提供します。エンドポイント認証サービスは、FEまたはCEがピアからパケットを受信するたびに実行されるプリ関連コネクション確立フェーズとメッセージ認証時に呼び出されます。"
    },
    {
      "indent": 3,
      "text": "The following are the general security mechanisms that need to be in place for ForCES PL.",
      "ja": "次のForCES PLのための場所にする必要があり、一般的なセキュリティメカニズムがあります。"
    },
    {
      "indent": 3,
      "text": "o Security mechanisms are session controlled -- that is, once the security is turned on depending upon the chosen security level (No Security, Authentication, Confidentiality), it will be in effect for the entire duration of the session.",
      "ja": "Oセキュリティメカニズムは、セッションが制御される - つまり、セキュリティが選択されたセキュリティレベル（無セキュリティ、認証、機密性）に応じてオンされると、それは、セッションの全期間のために有効であろう。"
    },
    {
      "indent": 3,
      "text": "o An operator should configure the same security policies for both primary and backup FEs and CEs (if available). This will ensure uniform operations and avoid unnecessary complexity in policy configuration.",
      "ja": "（利用可能な場合）Oオペレータは、プライマリおよびバックアップのFEおよびCEの両方に同じセキュリティポリシーを設定する必要があります。これは、均一な運用を確保し、ポリシー設定に不必要な複雑さを避けることができます。"
    },
    {
      "indent": 0,
      "text": "9.1. No Security",
      "section_title": true,
      "ja": "9.1. セキュリティなし"
    },
    {
      "indent": 3,
      "text": "When \"No Security\" is chosen for ForCES protocol communication, both endpoint authentication and message authentication service needs to be performed by ForCES PL. Both these mechanism are weak and do not involve cryptographic operation. An operator can choose \"No Security\" level when the ForCES protocol endpoints are within a single box, for example.",
      "ja": "「セキュリティなし」とのForCESプロトコル通信のために選択される場合、両方のエンドポイント認証とメッセージ認証サービスのForCES PLによって実行される必要があります。これらの両方のメカニズムが弱く、暗号操作を伴いません。 ForCESプロトコルエンドポイントは、例えば、単一のボックス内にあるとき、オペレータは、「セキュリティなし」レベルを選択することができます。"
    },
    {
      "indent": 3,
      "text": "In order to have interoperable and uniform implementation across various security levels, each CE and FE endpoint MUST implement this level.",
      "ja": "さまざまなセキュリティレベルにわたって相互運用可能かつ均一な実装を有するために、各CEとFEエンドポイントは、このレベルを実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "What is described below (in Section 9.1.1 and Section 9.1.2) are error checks and not security procedures. The reader is referred to Section 9.2 for security procedures.",
      "ja": "（9.1.1項および9.1.2項に）、以下に説明されるどのようなエラーチェックではなく、セキュリティの手順があります。読者は、セキュリティ手順については、セクション9.2と呼ばれます。"
    },
    {
      "indent": 0,
      "text": "9.1.1. Endpoint Authentication",
      "section_title": true,
      "ja": "9.1.1. エンドポイント認証"
    },
    {
      "indent": 3,
      "text": "Each CE and FE PL maintains a list of associations as part of its configuration. This is done via the CEM and FEM interfaces. An FE MUST connect to only those CEs that are configured via the FEM; similarly, a CE should accept the connection and establish associations for the FEs which are configured via the CEM. The CE should validate the FE identifier before accepting the connections during the pre-association phase.",
      "ja": "各CEとFE PLは、その構成の一部として、団体のリストを保持します。これは、CEMおよびFEMインターフェースを介して行われます。 FEは、FEMを介して構成されているだけのCEに接続する必要があります。同様に、CEは接続を受け入れ、CEMを介して構成されているのFEのためのアソシエーションを確立すべきです。 CEは、予めアソシエーションフェーズの間の接続を受け入れる前にFE識別子を検証しなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.1.2. Message Authentication",
      "section_title": true,
      "ja": "9.1.2. メッセージ認証"
    },
    {
      "indent": 3,
      "text": "When a CE or FE initiates a message, the receiving endpoint MUST validate the initiator of the message by checking the common header CE or FE identifiers. This will ensure proper protocol functioning. This extra processing step is recommended even when the underlying TML layer security services exist.",
      "ja": "CEまたはFEがメッセージを開始すると、受信エンドポイントは、共通ヘッダのCEまたはFE識別子をチェックすることにより、メッセージのイニシエータを検証する必要があります。これは、適切なプロトコル機能を保証します。基本となるTML層のセキュリティサービスが存在する場合でも、この余分な処理ステップが推奨されます。"
    },
    {
      "indent": 0,
      "text": "9.2. ForCES PL and TML Security Service",
      "section_title": true,
      "ja": "9.2.  ForCES PLとTMLセキュリティサービス"
    },
    {
      "indent": 3,
      "text": "This section is applicable if an operator wishes to use the TML security services. A ForCES TML MUST support one or more security services such as endpoint authentication service, message authentication service, and confidentiality service, as part of TML security layer functions. It is the responsibility of the operator to select an appropriate security service and configure security policies accordingly. The details of such configuration are outside the scope of the ForCES PL and are dependent on the type of transport protocol and the nature of the connection.",
      "ja": "オペレータがTMLのセキュリティ・サービスを使用したい場合は、このセクションでは、適用されます。 ForCES TMLはTMLセキュリティレイヤ機能の一部として、そのようなエンドポイントの認証サービス、メッセージ認証サービス、および機密性サービスなどの1つまたは複数のセキュリティ・サービスをサポートしなければなりません。適切なセキュリティサービスを選択し、それに応じてセキュリティポリシーを設定するには、オペレータの責任です。このような構成の詳細のForCES PLの範囲外であり、トランスポートプロトコルの種類、接続の性質に依存しています。"
    },
    {
      "indent": 3,
      "text": "All these configurations should be done prior to starting the CE and FE.",
      "ja": "これらのすべての構成は、CEとFEを開始する前に行うべきです。"
    },
    {
      "indent": 3,
      "text": "When certificates-based authentication is being used at the TML, the certificate can use a ForCES-specific naming structure as certificate names and, accordingly, the security policies can be configured at the CE and FE.",
      "ja": "証明書ベースの認証がTMLで使用されている場合、証明書は、証明書の名前としてのForCES固有の命名構造を使用することができ、従って、セキュリティポリシーは、CEとFEで構成することができます。"
    },
    {
      "indent": 3,
      "text": "The reader is asked to refer to specific TML documents for details on the security requirements specific to that TML.",
      "ja": "読者はそのTMLに特有のセキュリティ要件の詳細については、特定のTML文書を参照するように求められます。"
    },
    {
      "indent": 0,
      "text": "9.2.1. Endpoint Authentication Service",
      "section_title": true,
      "ja": "9.2.1. エンドポイント認証サービス"
    },
    {
      "indent": 3,
      "text": "When TML security services are enabled, the ForCES TML performs endpoint authentication. Security association is established between CE and FE and is transparent to the ForCES PL.",
      "ja": "TMLのセキュリティサービスが有効になっている場合は強制しTMLは、エンドポイントの認証を実行します。セキュリティアソシエーションは、CEとFEとの間で確立に強制PLに対して透過的です。"
    },
    {
      "indent": 0,
      "text": "9.2.2. Message Authentication Service",
      "section_title": true,
      "ja": "9.2.2. メッセージ認証サービス"
    },
    {
      "indent": 3,
      "text": "This is a TML-specific operation and is transparent to the ForCES PL. For details, refer to Section 5.",
      "ja": "これは、TML-特定の操作で、強制的にPLに対して透過的です。詳細については、第5章を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.2.3. Confidentiality Service",
      "section_title": true,
      "ja": "9.2.3. 機密性サービス"
    },
    {
      "indent": 3,
      "text": "This is a TML-specific operation and is transparent to the ForCES PL. For details, refer to Section 5.",
      "ja": "これは、TML-特定の操作で、強制的にPLに対して透過的です。詳細については、第5章を参照してください。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgments",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors of this document would like to acknowledge and thank the ForCES Working Group and especially the following: Furquan Ansari, Alex Audu, Steven Blake, Shuchi Chawla, Alan DeKok, Ellen M. Deleganes, Xiaoyi Guo, Yunfei Guo, Evangelos Haleplidis, Zsolt Haraszti, Fenggen Jia, John C. Lin, Alistair Munro, Jeff Pickering, T. Sridhlar, Guangming Wang, Chaoping Wu, and Lily L. Yang, for their contributions. We would also like to thank David Putzolu and Patrick Droz for their comments and suggestions on the protocol and for their infinite patience. We would also like to thank Sue Hares and Alia Atlas for extensive reviews of the document.",
      "ja": "このドキュメントの作者は感謝し、強制的にワーキンググループ、特に以下の感謝ます：Furquanアンサリ、アレックスAudu、スティーブ・ブレイク、Shuchiチャウラ、アランDeKok、エレンM. Deleganes、Xiaoyi郭、Yunfei郭、Evangelos Haleplidis、ジョルトを彼らの貢献のためHaraszti、Fenggen嘉、ジョンC.林、アリステア・マンロー、ジェフ・ピカリング、T. Sridhlar、光明王、Chaoping呉、とリリーL.ヤン、。また、プロトコル上の彼らのコメントや提案をし、彼らの無限の忍耐のためのデビッドPutzoluとパトリックドローに感謝したいと思います。また、文書の大規模なレビューのためにスーノウサギとアリアアトラスに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "Alia Atlas did a wonderful job of shaping the document to make it more readable by providing the IESG feedback.",
      "ja": "アリアアトラスは、IESGのフィードバックを提供することによって、それを読みやすくするために文書を整形する素晴らしい仕事をしました。"
    },
    {
      "indent": 3,
      "text": "Ross Callon was instrumental in getting us over major humps to getting this document published.",
      "ja": "ロスCallonは公表され、この文書を取得する主要なこぶの上に私たちを得ることに尽力しました。"
    },
    {
      "indent": 3,
      "text": "The editors have used the xml2rfc [RFC2629] tools in creating this document and are very grateful for the existence and quality of these tools. The editor is also grateful to Elwyn Davies for his help in correcting the XML source of this document.",
      "ja": "編集者は、この文書の作成にxml2rfc [RFC2629]ツールを使用して、これらのツールの存在と品質のために非常に感謝しているしています。エディタは、このドキュメントのXMLソースの補正に彼の助けのためのエルウィン・デイヴィスに感謝です。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2914] Floyd, S., \"Congestion Control Principles\", BCP 41, RFC 2914, September 2000.",
      "ja": "[RFC2914]フロイド、S.、 \"輻輳制御の原理\"、BCP 41、RFC 2914、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5390] Rosenberg, J., \"Requirements for Management of Overload in the Session Initiation Protocol\", RFC 5390, December 2008.",
      "ja": "[RFC5390]ローゼンバーグ、J.、「セッション開始プロトコルにおける過負荷の管理のための要件」、RFC 5390、2008年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5811] Hadi Salim, J. and K. Ogawa, \"SCTP-Based Transport Mapping Layer (TML) for the Forwarding and Control Element Separation (ForCES) Protocol\", RFC 5811, March 2010.",
      "ja": "[RFC5811]ハディサリム、J.及びK.小川、 \"転送および制御素子分離用SCTPベースのトランスポート・マッピング・レイヤ（TML）（のForCES）プロトコル\"、RFC 5811、2010年月。"
    },
    {
      "indent": 3,
      "text": "[RFC5812] Halpern, J. and J. Hadi Salim, \"Forwarding and Control Element Separation (ForCES) Forwarding Element Model\", RFC 5812, March 2010.",
      "ja": "[RFC5812]アルペルン、J.およびJ.ハディサリム、 \"転送および制御素子分離（のForCES）転送要素モデル\"、RFC 5812、2010年3月。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[2PCREF] Gray, J., \"Notes on database operating systems\", in \"Operating Systems: An Advanced Course\" Lecture Notes in Computer Science, Vol. 60, pp. 394-481, Springer-Verlag, 1978.",
      "ja": "コンピュータサイエンス、巻で講義ノート：[2PCREF]グレー、J.は、「上級コースオペレーティングシステム」で、「データベース・オペレーティング・システム上での注意事項」。 60頁394から481、シュプリンガー・フェアラーク、1978。"
    },
    {
      "indent": 3,
      "text": "[ACID] Haerder, T. and A. Reuter, \"Principles of Transaction-Orientated Database Recovery\", 1983.",
      "ja": "[ACID]ハーダー、T.とA.ロイター、「トランザクション指向データベースの回復の原則」、1983年。"
    },
    {
      "indent": 3,
      "text": "[RFC2629] Rose, M., \"Writing I-Ds and RFCs using XML\", RFC 2629, June 1999.",
      "ja": "[RFC2629]ローズ、M.、 \"ライティングI-DSおよびXMLを使用しているRFC\"、RFC 2629、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3654] Khosravi, H. and T. Anderson, \"Requirements for Separation of IP Control and Forwarding\", RFC 3654, November 2003.",
      "ja": "[RFC3654] Khosravi、H.、およびT.アンダーソン、 \"IP制御とフォワーディングの分離のための要件\"、RFC 3654、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3746] Yang, L., Dantu, R., Anderson, T., and R. Gopal, \"Forwarding and Control Element Separation (ForCES) Framework\", RFC 3746, April 2004.",
      "ja": "[RFC3746]ヤン、L.、Dantu、R.、アンダーソン、T.、およびR.ゴパル、 \"転送および制御素子分離（のForCES）フレームワーク\"、RFC 3746、2004年4月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. IANA Considerations",
      "ja": "付録A. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Following the policies outlined in \"Guidelines for Writing an IANA Considerations Section in RFCs\" (RFC 5226 [RFC5226]), the following namespaces are defined in ForCES.",
      "ja": "「RFCでIANA問題部に書くためのガイドライン」（RFC 5226 [RFC5226]）で概説された方針に続いて、次の名前空間は、力の定義されています。"
    },
    {
      "indent": 3,
      "text": "o Message Type Namespace, Section 7",
      "ja": "メッセージタイプのネームスペース、セクション7 O"
    },
    {
      "indent": 3,
      "text": "o Operation Type Namespace, Section 7.1.6",
      "ja": "O操作タイプの名前空間、セクション7.1.6"
    },
    {
      "indent": 3,
      "text": "o Header Flags, Section 6.1",
      "ja": "Oヘッダフラグ、6.1節"
    },
    {
      "indent": 3,
      "text": "o TLV Type, Section 7",
      "ja": "TLVタイプ、セクション7 O"
    },
    {
      "indent": 3,
      "text": "o TLV Result Values, Section 7.1.7",
      "ja": "O TLV結果値、セクション7.1.7"
    },
    {
      "indent": 3,
      "text": "o LFB Class ID, Section 7.1.5 (resolved by model document, [RFC5812].",
      "ja": "LFBクラスID、セクション7.1.5（モデルドキュメントによって解決、[RFC5812] O。"
    },
    {
      "indent": 3,
      "text": "o Result: Association Setup Response, Section 7.5.2",
      "ja": "O結果：協会のセットアップ応答、7.5.2項"
    },
    {
      "indent": 3,
      "text": "o Reason: Association Teardown Message, Section 7.5.3",
      "ja": "O理由：協会ティアダウンメッセージ、7.5.3"
    },
    {
      "indent": 0,
      "text": "A.1. Message Type Namespace",
      "ja": "A.1。メッセージタイプのネームスペース"
    },
    {
      "indent": 3,
      "text": "The Message Type is an 8-bit value. The following is the guideline for defining the Message Type namespace:",
      "ja": "メッセージタイプは8ビット値です。以下は、メッセージタイプの名前空間を定義するためのガイドラインです。"
    },
    {
      "indent": 3,
      "text": "Message Types 0x00 - 0x1F Message Types in this range are part of the base ForCES protocol. Message Types in this range are allocated through an IETF consensus action [RFC5226].",
      "ja": "メッセージタイプは0x00  - この範囲の0x1Fのメッセージタイプは、基本力プロトコルの一部です。この範囲のメッセージタイプは、IETFコンセンサスアクション[RFC5226]を介して割り当てられています。"
    },
    {
      "indent": 6,
      "text": "Values assigned by this specification:",
      "ja": "この仕様によって割り当てられた値："
    },
    {
      "indent": 7,
      "text": "0x00 Reserved 0x01 AssociationSetup 0x02 AssociationTeardown 0x03 Config 0x04 Query 0x05 EventNotification 0x06 PacketRedirect 0x07 - 0x0E Reserved 0x0F Hearbeat 0x11 AssociationSetupResponse 0x12 Reserved 0x13 ConfigResponse 0x14 QueryResponse",
      "ja": "0x00の予約が0x01 0x02のAssociationSetup AssociationTeardown 0x03のコンフィグ0x04のクエリ0x05のEventNotification 0x06のPacketRedirect 0x07の -  0x0Eの予約0x0FのHearbeat 0x11をAssociationSetupResponseの0x12予約0x13を0x14にConfigResponse QueryResponse"
    },
    {
      "indent": 3,
      "text": "Message Types 0x20 - 0x7F Message Types in this range are Specification Required [RFC5226]. Message Types using this range MUST be documented in an RFC or other permanent and readily available reference.",
      "ja": "メッセージタイプの0x20  - この範囲の0x7Fのメッセージタイプは、仕様が必要である[RFC5226]です。この範囲を使用して、メッセージタイプはRFCまたは他の永久的かつ容易に入手可能な文献に文書化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Message Types 0x80 - 0xFF Message Types in this range are reserved for vendor private extensions and are the responsibility of individual vendors. IANA management of this range of the Message Type namespace is unnecessary.",
      "ja": "メッセージタイプは0x80  - この範囲では0xFFメッセージタイプは、ベンダプライベート拡張のために予約し、個々のベンダーの責任とされています。メッセージタイプのネームスペースのこの範囲のIANA管理は不要です。"
    },
    {
      "indent": 0,
      "text": "A.2. Operation Selection",
      "ja": "A.2。動作選択"
    },
    {
      "indent": 3,
      "text": "The Operation Selection (OPER-TLV) namespace is 16 bits long. The following is the guideline for managing the OPER-TLV namespace.",
      "ja": "操作の選択（OPER-TLV）名前空間は16ビット長です。次はOPER-TLVの名前空間を管理するためのガイドラインです。"
    },
    {
      "indent": 3,
      "text": "OPER-TLV Type 0x0000-0x0FF OPER-TLV Types in this range are allocated through an IETF consensus process [RFC5226].",
      "ja": "この範囲内のOPER-TLVタイプ0x0000-0x0FF OPER-TLVタイプはIETFコンセンサスプロセス[RFC5226]を介して割り当てられています。"
    },
    {
      "indent": 6,
      "text": "Values assigned by this specification:",
      "ja": "この仕様によって割り当てられた値："
    },
    {
      "indent": 17,
      "text": "0x0000           Reserved\n0x0001           SET\n0x0002           SET-PROP\n0x0003           SET-RESPONSE\n0x0004           SET-PROP-RESPONSE\n0x0005           DEL\n0x0006           DEL-RESPONSE\n0x0007           GET\n0x0008           GET-PROP\n0x0009           GET-RESPONSE\n0x000A           GET-PROP-RESPONSE\n0x000B           REPORT\n0x000C           COMMIT\n0x000D           COMMIT-RESPONSE\n0x000E           TRCOMP",
      "raw": true
    },
    {
      "indent": 3,
      "text": "OPER-TLV Type 0x0100-0x7FFF OPER-TLV Types using this range MUST be documented in an RFC or other permanent and readily available reference [RFC5226].",
      "ja": "この範囲を使用してOPER-TLVタイプ0x0100-0x7FFF OPER-TLVのタイプは、RFCまたは他の永久的かつ容易に入手可能な参考文献[RFC5226]で文書化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "OPER-TLV Type 0x8000-0xFFFF OPER-TLV Types in this range are reserved for vendor private extensions and are the responsibility of individual vendors. IANA management of this range of the OPER-TLV Type namespace is unnecessary.",
      "ja": "この範囲内のOPER-TLVタイプ0x8000-0xFFFF OPER-TLVタイプは、ベンダプライベート拡張のために予約し、個々のベンダーの責任とされています。 OPER-TLVタイプの名前空間のこの範囲のIANA管理は不要です。"
    },
    {
      "indent": 0,
      "text": "A.3. Header Flags",
      "ja": "A.3。ヘッダーフラグ"
    },
    {
      "indent": 6,
      "text": "The Header flag field is 32 bits long.  Header flags are part of\nthe ForCES base protocol.  Header flags are allocated through an\nIETF consensus action [RFC5226].",
      "raw": true
    },
    {
      "indent": 0,
      "text": "A.4. TLV Type Namespace",
      "ja": "A.4。 TLVタイプネームスペース"
    },
    {
      "indent": 3,
      "text": "The TLV Type namespace is 16 bits long. The following is the guideline for managing the TLV Type namespace.",
      "ja": "TLVタイプの名前空間は16ビット長です。以下は、TLVタイプの名前空間を管理するためのガイドラインです。"
    },
    {
      "indent": 3,
      "text": "TLV Type 0x0000-0x01FF TLV Types in this range are allocated through an IETF consensus process [RFC5226].",
      "ja": "この範囲のTLVタイプ0x0000-0x01FF TLVタイプはIETFコンセンサスプロセス[RFC5226]を介して割り当てられています。"
    },
    {
      "indent": 6,
      "text": "Values assigned by this specification:",
      "ja": "この仕様によって割り当てられた値："
    },
    {
      "indent": 17,
      "text": "0x0000           Reserved\n0x0001           REDIRECT-TLV\n0x0010           ASResult-TLV\n0x0011           ASTreason-TLV\n0x1000           LFBselect-TLV\n0x0110           PATH-DATA-TLV\n0x0111           KEYINFO-TLV\n0x0112           FULLDATA-TLV\n0x0113           SPARSEDATA-TLV\n0x0114           RESULT-TLV\n0x0115           METADATA-TLV\n0x0116           REDIRECTDATA-TLV",
      "raw": true
    },
    {
      "indent": 3,
      "text": "TLV Type 0x0200-0x7FFF TLV Types using this range MUST be documented in an RFC or other permanent and readily available reference [RFC5226].",
      "ja": "この範囲を使用して、TLVタイプ0x0200-0x7FFF TLVのタイプは、RFCまたは他の永久的かつ容易に入手可能な参考文献[RFC5226]で文書化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "TLV Type 0x8000-0xFFFF TLV Types in this range are reserved for vendor private extensions and are the responsibility of individual vendors. IANA management of this range of the TLV Type namespace is unnecessary.",
      "ja": "この範囲のTLVタイプ0x8000-0xFFFF TLVタイプは、ベンダープライベート拡張のために予約し、個々のベンダーの責任とされています。 TLVタイプの名前空間のこの範囲のIANA管理は不要です。"
    },
    {
      "indent": 0,
      "text": "A.5. RESULT-TLV Result Values",
      "ja": "A.5。 RESULT-TLVの結果値"
    },
    {
      "indent": 3,
      "text": "The RESULT-TLV RTesult Value is an 8-bit value.",
      "ja": "RESULT-TLV RTesult値は8ビット値です。"
    },
    {
      "indent": 16,
      "text": "0x00        E_SUCCESS\n0x01        E_INVALID_HEADER\n0x02        E_LENGTH_MISMATCH\n0x03        E_VERSION_MISMATCH\n0x04        E_INVALID_DESTINATION_PID\n0x05        E_LFB_UNKNOWN\n0x06        E_LFB_NOT_FOUND\n0x07        E_LFB_INSTANCE_ID_NOT_FOUND\n0x08        E_INVALID_PATH\n0x09        E_COMPONENT_DOES_NOT_EXIST\n0x0A        E_EXISTS\n0x0B        E_NOT_FOUND\n0x0C        E_READ_ONLY\n0x0D        E_INVALID_ARRAY_CREATION\n0x0E        E_VALUE_OUT_OF_RANGE\n0x0F        E_CONTENTS_TOO_LONG\n0x10        E_INVALID_PARAMETERS\n0x11        E_INVALID_MESSAGE_TYPE\n0x12        E_E_INVALID_FLAGS\n0x13        E_INVALID_TLV\n0x14        E_EVENT_ERROR\n0x15        E_NOT_SUPPORTED\n0x16        E_MEMORY_ERROR\n0x17        E_INTERNAL_ERROR\n0x18-0xFE   Reserved\n0xFF        E_UNSPECIFIED_ERROR",
      "raw": true
    },
    {
      "indent": 3,
      "text": "All values not assigned in this specification are designated as Assignment by Expert Review.",
      "ja": "この仕様で割り当てられていないすべての値は、専門家レビューにより割り当てに指定されています。"
    },
    {
      "indent": 0,
      "text": "A.6. Association Setup Response",
      "ja": "A.6。協会のセットアップ応答"
    },
    {
      "indent": 3,
      "text": "The Association Setup Response namespace is 32 bits long. The following is the guideline for managing the Association Setup Response namespace.",
      "ja": "協会のセットアップ応答の名前空間は32ビット長です。以下は、協会のセットアップ応答の名前空間を管理するためのガイドラインです。"
    },
    {
      "indent": 3,
      "text": "Association Setup Response 0x0000-0x00FF Association Setup Responses in this range are allocated through an IETF consensus process [RFC5226].",
      "ja": "この範囲のアソシエーションのセットアップ応答0x0000-0x00FF関連セットアップ応答はIETFコンセンサスプロセス[RFC5226]を介して割り当てられています。"
    },
    {
      "indent": 6,
      "text": "Values assigned by this specification:",
      "ja": "この仕様によって割り当てられた値："
    },
    {
      "indent": 10,
      "text": "0x0000   Success\n0x0001   FE ID Invalid\n0x0002   Permission Denied",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Association Setup Response 0x0100-0x0FFF Association Setup Responses in this range are Specification Required [RFC5226]. Values using this range MUST be documented in an RFC or other permanent and readily available reference [RFC5226].",
      "ja": "この範囲内の協会のセットアップ応答0x0100-0x0FFF協会セットアップ応答は、仕様が必要である[RFC5226]です。この範囲を使用して値は、RFCまたは他の永久的かつ容易に入手可能な参考文献[RFC5226]で文書化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Association Setup Response 0x1000-0xFFFF Association Setup Responses in this range are reserved for vendor private extensions and are the responsibility of individual vendors. IANA management of this range of the Association Setup Response namespace is unnecessary.",
      "ja": "この範囲内の協会のセットアップ応答0x1000-0xFFFF協会セットアップ応答は、ベンダプライベート拡張のために予約し、個々のベンダーの責任とされています。協会セットアップ応答名前空間のこの範囲のIANA管理は不要です。"
    },
    {
      "indent": 0,
      "text": "A.7. Association Teardown Message",
      "ja": "A.7。協会ティアダウンメッセージ"
    },
    {
      "indent": 3,
      "text": "The Association Teardown Message namespace is 32 bits long. The following is the guideline for managing the Association Teardown Message namespace.",
      "ja": "協会ティアダウンメッセージの名前空間は32ビット長です。以下は、協会のティアダウンメッセージの名前空間を管理するためのガイドラインです。"
    },
    {
      "indent": 3,
      "text": "Association Teardown Message 0x00000000-0x0000FFFF Association Teardown Messages in this range are allocated through an IETF consensus process [RFC5226].",
      "ja": "この範囲内の関連ティアダウンメッセージ0x00000000-0x0000FFFF関連ティアダウンメッセージは、IETFコンセンサスプロセス[RFC5226]を介して割り当てられています。"
    },
    {
      "indent": 6,
      "text": "Values assigned by this specification:",
      "ja": "この仕様によって割り当てられた値："
    },
    {
      "indent": 11,
      "text": "0x00000000        Normal - teardown by administrator\n0x00000001        Error  - loss of heartbeats\n0x00000002        Error  - loss of bandwidth\n0x00000003        Error  - out of Memory\n0x00000004        Error  - application crash\n0x000000FF        Error  - unspecified",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Association Teardown Message 0x00010000-0x7FFFFFFF Association Teardown Messages in this range are Specification Required [RFC5226]. Association Teardown Messages using this range MUST be documented in an RFC or other permanent and readily available references. [RFC5226].",
      "ja": "この範囲内の協会ティアダウンメッセージ0x00010000-0x7FFFFFFF協会ティアダウンメッセージは、仕様が必要である[RFC5226]です。この範囲を使用して、関連ティアダウンメッセージは、RFCまたは他の永久的かつ容易に入手可能な参考文献に文書化されなければなりません。 [RFC5226]。"
    },
    {
      "indent": 3,
      "text": "Association Teardown Message 0x80000000-0xFFFFFFFFF Association Teardown Messages in this range are reserved for vendor private extensions and are the responsibility of individual vendors. IANA management of this range of the Association Teardown Message namespace is unnecessary.",
      "ja": "この範囲内の協会ティアダウンメッセージ0x80000000-0xFFFFFFFFF協会ティアダウンメッセージは、ベンダプライベート拡張のために予約し、個々のベンダーの責任とされています。協会ティアダウンメッセージの名前空間のこの範囲のIANA管理は不要です。"
    },
    {
      "indent": 0,
      "text": "Appendix B. ForCES Protocol LFB Schema",
      "ja": "付録B.のForCESプロトコルLFBスキーマ"
    },
    {
      "indent": 3,
      "text": "The schema described below conforms to the LFB schema described in the ForCES model [RFC5812].",
      "ja": "以下に記載するスキーマは、のForCESモデル[RFC5812]に記載LFBスキーマに準拠します。"
    },
    {
      "indent": 3,
      "text": "Section 7.3.1 describes the details of the different components defined in this definition.",
      "ja": "7.3.1項では、この定義で定義されているさまざまなコンポーネントの詳細について説明します。"
    },
    {
      "indent": 3,
      "text": "<LFBLibrary xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" provides=\"FEPO\"> <!-- XXX --> <dataTypeDefs> <dataTypeDef> <name>CEHBPolicyValues</name> <synopsis> The possible values of CE heartbeat policy </synopsis> <atomic> <baseType>uchar</baseType> <specialValues> <specialValue value=\"0\"> <name>CEHBPolicy0</name> <synopsis> The CE heartbeat policy 0 </synopsis> </specialValue> <specialValue value=\"1\"> <name>CEHBPolicy1</name> <synopsis> The CE heartbeat policy 1 </synopsis> </specialValue> </specialValues> </atomic> </dataTypeDef>",
      "ja": "<LFBLibraryのxmlns = \"壷：IETF：のparams：XML：NS：力：lfbmodel：1.0\" のxmlns：XSI = \"http://www.w3.org/2001/XMLSchema-instance\" = \"のFePO\" 提供> <！ -  XXX  - > <dataTypeDefs> <dataTypeDef> <名前> CEHBPolicyValues </名前> <概要> CEハートビートポリシーの可能な値</シノプシス> <原子> <baseType> UCHAR </ baseType> <specialValues> <specialValue値= \"0\"> <名前> CEHBPolicy0 </名前> <概要> CEハートビートポリシー0 </概要> </ specialValue> <specialValue値= \"1\"> <名前> CEHBPolicy1 </名前> <概要> CEハートビートポリシー1 </概要> </ specialValue> </ specialValues> </原子> </ dataTypeDef>"
    },
    {
      "indent": 9,
      "text": "<dataTypeDef>\n   <name>FEHBPolicyValues</name>\n        <synopsis>\n            The possible values of FE heartbeat policy\n       </synopsis>\n     <atomic>\n     <baseType>uchar</baseType>\n     <specialValues>",
      "raw": true
    },
    {
      "indent": 9,
      "text": " <specialValue value=\"0\"> <name>FEHBPolicy0</name> <synopsis> The FE heartbeat policy 0 </synopsis> </specialValue> <specialValue value=\"1\"> <name>FEHBPolicy1</name> <synopsis> The FE heartbeat policy 1 </synopsis> </specialValue> </specialValues> </atomic> </dataTypeDef>",
      "ja": "<specialValue値= \"0\"> <名前> FEHBPolicy0 </名前> <概要> FEハートビートポリシー0 </概要> </ specialValue> <specialValue値= \"1\"> <名前> FEHBPolicy1 </名前> <概要> FEハートビートポリシー1 </概要> </ specialValue> </ specialValues> </原子> </ dataTypeDef>"
    },
    {
      "indent": 9,
      "text": "<dataTypeDef> <name>FERestartPolicyValues</name> <synopsis> The possible values of FE restart policy </synopsis> <atomic> <baseType>uchar</baseType> <specialValues> <specialValue value=\"0\"> <name>FERestartPolicy0</name> <synopsis> The FE restart policy 0 </synopsis> </specialValue> </specialValues> </atomic> </dataTypeDef>",
      "ja": "<dataTypeDef> <名前> FERestartPolicyValues </名前> <概要> FE再起動ポリシーの可能な値</シノプシス> <原子> <baseType> UCHAR </ baseType> <specialValues> <specialValue値= \"0\"> <名前> FERestartPolicy0 </名前> <概要> FE再起動ポリシー0 </概要> </ specialValue> </ specialValues> </アトミック> </ dataTypeDef>"
    },
    {
      "indent": 9,
      "text": "<dataTypeDef> <name>CEFailoverPolicyValues</name> <synopsis> The possible values of CE failover policy </synopsis> <atomic> <baseType>uchar</baseType> <specialValues> <specialValue value=\"0\"> <name>CEFailoverPolicy0</name> <synopsis> The CE failover policy 0 </synopsis> </specialValue>",
      "ja": "<dataTypeDef> <名前> CEFailoverPolicyValues </名前> <概要> CE・フェイルオーバー・ポリシーの可能な値</シノプシス> <原子> <baseType> UCHAR </ baseType> <specialValues> <specialValue値= \"0\"> <名前> CEFailoverPolicy0 </名前> <概要> CEのフェイルオーバー・ポリシー0 </概要> </ specialValue>"
    },
    {
      "indent": 9,
      "text": " <specialValue value=\"1\"> <name>CEFailoverPolicy1</name> <synopsis> The CE failover policy 1 </synopsis> </specialValue> </specialValues> </atomic> </dataTypeDef>",
      "ja": "<specialValue値= \"1\"> <名前> CEFailoverPolicy1 </名前> <概要> CE・フェイルオーバー・ポリシー1 </概要> </ specialValue> </ specialValues> </原子> </ dataTypeDef>"
    },
    {
      "indent": 5,
      "text": " <dataTypeDef> <name>FEHACapab</name> <synopsis> The supported HA features </synopsis> <atomic> <baseType>uchar</baseType> <specialValues> <specialValue value=\"0\"> <name>GracefullRestart</name> <synopsis> The FE supports Graceful Restart </synopsis> </specialValue> <specialValue value=\"1\"> <name>HA</name> <synopsis> The FE supports HA </synopsis> </specialValue> </specialValues> </atomic> </dataTypeDef> </dataTypeDefs>",
      "ja": "<dataTypeDef> <名前> FEHACapab </名前> <概要>サポートされているHA機能</シノプシス> <原子> <baseType> UCHAR </ baseType> <specialValues> <specialValue値= \"0\"> <名前> GracefullRestart </ > <概要> FEは、グレースフルリスタート</概要> </ specialValue> <specialValue値= \"1\" をサポートしている名前> <名前> HA </名前> <概要> FEは、HA </概要> </ specialValue> <をサポートしています/ specialValues> </アトミック> </ dataTypeDef> </ dataTypeDefs>"
    },
    {
      "indent": 5,
      "text": "<LFBClassDefs> <LFBClassDef LFBClassID=\"2\"> <name>FEPO</name> <synopsis> The FE Protocol Object </synopsis> <version>1.0</version>",
      "ja": "<LFBClassDefs> <LFBClassDef LFBClassID = \"2\"> <名前>のFePO </名前> <概要> FEプロトコルオブジェクト</シノプシス>の<version> 1.0 </バージョン>"
    },
    {
      "indent": 5,
      "text": "<components> <component componentID=\"1\" access=\"read-only\"> <name>CurrentRunningVersion</name> <synopsis>Currently running ForCES version</synopsis> <typeRef>uchar</typeRef>",
      "ja": "<成分> <コンポーネントのComponentID = \"1\" アクセス= \"読み取り専用\"> <名前> CurrentRunningVersion </名前> <概要>現在実行中のForCESバージョン</シノプシス> <typeRef> UCHAR </ typeRef>"
    },
    {
      "indent": 11,
      "text": "  </component>\n<component componentID=\"2\" access=\"read-only\">\n  <name>FEID</name>\n  <synopsis>Unicast FEID</synopsis>\n  <typeRef>uint32</typeRef>\n</component>\n<component componentID=\"3\" access=\"read-write\">\n   <name>MulticastFEIDs</name>\n   <synopsis>\n      the table of all multicast IDs\n   </synopsis>\n   <array type=\"variable-size\">\n    <typeRef>uint32</typeRef>\n   </array>\n</component>\n<component componentID=\"4\" access=\"read-write\">\n  <name>CEHBPolicy</name>\n  <synopsis>\n   The CE Heartbeat Policy\n  </synopsis>\n  <typeRef>CEHBPolicyValues</typeRef>\n</component>\n<component componentID=\"5\" access=\"read-write\">\n  <name>CEHDI</name>\n  <synopsis>\n    The CE Heartbeat Dead Interval in millisecs\n  </synopsis>\n  <typeRef>uint32</typeRef>\n</component>\n<component componentID=\"6\" access=\"read-write\">\n  <name>FEHBPolicy</name>\n  <synopsis>\n    The FE Heartbeat Policy\n  </synopsis>\n  <typeRef>FEHBPolicyValues</typeRef>\n</component>\n<component componentID=\"7\" access=\"read-write\">\n  <name>FEHI</name>\n  <synopsis>\n    The FE Heartbeat Interval in millisecs\n  </synopsis>\n  <typeRef>uint32</typeRef>\n</component>\n<component componentID=\"8\" access=\"read-write\">\n  <name>CEID</name>\n  <synopsis>\n     The Primary CE this FE is associated with\n  </synopsis>",
      "raw": true
    },
    {
      "indent": 11,
      "text": " <typeRef>uint32</typeRef> </component>",
      "ja": "<TypeRef> UINT32 </ typeRef> </成分>"
    },
    {
      "indent": 11,
      "text": "<component componentID=\"9\" access=\"read-write\"> <name>BackupCEs</name> <synopsis> The table of all backup CEs other than the primary </synopsis> <array type=\"variable-size\"> <typeRef>uint32</typeRef> </array> </component> <component componentID=\"10\" access=\"read-write\"> <name>CEFailoverPolicy</name> <synopsis> The CE Failover Policy </synopsis> <typeRef>CEFailoverPolicyValues</typeRef> </component>",
      "ja": "<成分COMPONENTID =「9」アクセス=「読み書き」> <名前> BackupCEs </名前> <概要>プライマリ</シノプシス> <配列型=「可変サイズ」>以外のすべてのバックアップCEのテーブル<typeRef> UINT32 </ typeRef> </アレイ> </コンポーネント> <コンポーネントのComponentID = \"10\" アクセス= \"読み書き\"> <名前> CEFailoverPolicy </名前> <概要> CEフェイルオーバー・ポリシー</概要> <typeRef> CEFailoverPolicyValues </ typeRef> </成分>"
    },
    {
      "indent": 9,
      "text": " <component componentID=\"11\" access=\"read-write\"> <name>CEFTI</name> <synopsis> The CE Failover Timeout Interval in millisecs </synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"12\" access=\"read-write\"> <name>FERestartPolicy</name> <synopsis> The FE Restart Policy </synopsis> <typeRef>FERestartPolicyValues</typeRef> </component> <component componentID=\"13\" access=\"read-write\"> <name>LastCEID</name> <synopsis> The Primary CE this FE was last associated with </synopsis> <typeRef>uint32</typeRef> </component> </components>",
      "ja": "<成分COMPONENTID = \"11\" アクセス= \"読み書き\"> <名前> CEFTI </名前> <概要> millisecsにおけるCEフェイルオーバタイムアウト間隔</シノプシス> <typeRef> UINT32 </ typeRef> </成分> <コンポーネントCOMPONENTID = \"12\" アクセス= \"読み書き\"> <名前> FERestartPolicy </名前> <概要> FE再起動ポリシー</概要> <typeRef> FERestartPolicyValues </ typeRef> </部品> <コンポーネントCOMPONENTID =」 13\" アクセス= \"読み書き\"> <名前> LastCEID </名前> <概要>このFEは</シノプシス> <typeRef> UINT32 </ typeRef> </成分> </部品>と最後に関連付けられたプライマリCE"
    },
    {
      "indent": 8,
      "text": "<capabilities> <capability componentID=\"30\"> <name>SupportableVersions</name> <synopsis> the table of ForCES versions that FE supports",
      "ja": "<機能> <機能COMPONENTID = \"30\"> <名前> SupportableVersions </名前> <あらすじ>のForCESバージョンFEサポートのテーブル"
    },
    {
      "indent": 9,
      "text": " </synopsis> <array type=\"variable-size\"> <typeRef>uchar</typeRef> </array> </capability> <capability componentID=\"31\"> <name>HACapabilities</name> <synopsis> the table of HA capabilities the FE supports </synopsis> <array type=\"variable-size\"> <typeRef>FEHACapab</typeRef> </array> </capability> </capabilities>",
      "ja": "</シノプシス> <配列型= \"可変サイズ\"> <typeRef> UCHAR </ typeRef> </アレイ> </機能> <能力COMPONENTID = \"31\"> <名前> HACapabilities </名前> <概要> HA機能のテーブルは、FEがサポート</シノプシス> <配列型= \"可変サイズ\"> <typeRef> FEHACapab </ typeRef> </アレイ> </機能> </機能>"
    },
    {
      "indent": 9,
      "text": "<events baseID=\"61\"> <event eventID=\"1\"> <name>PrimaryCEDown</name> <synopsis> The pimary CE has changed </synopsis> <eventTarget> <eventField>LastCEID</eventField> </eventTarget> <eventChanged/> <eventReports> <eventReport> <eventField>LastCEID</eventField> </eventReport> </eventReports> </event> </events>",
      "ja": "<イベントbaseID = \"61\"> <イベントのeventID = \"1\"> <名前> PrimaryCEDown </名前> <概要> pimary CEが変更された</シノプシス> <のEventTarget> <eventField> LastCEID </ eventField> </のEventTarget > <eventChanged /> <eventReports> <eventReport> <eventField> LastCEID </ eventField> </ eventReport> </ eventReports> </イベント> </イベント>"
    },
    {
      "indent": 3,
      "text": " </LFBClassDef> </LFBClassDefs> </LFBLibrary>",
      "ja": "</ LFBClassDef> </ LFBClassDefs> </ LFBLibrary>"
    },
    {
      "indent": 0,
      "text": "B.1. Capabilities",
      "ja": "B.1。機能"
    },
    {
      "indent": 3,
      "text": "Supportable Versions enumerates all ForCES versions that an FE supports.",
      "ja": "サポート可能なバージョンは、FEがサポートするすべての力のバージョンを列挙します。"
    },
    {
      "indent": 3,
      "text": "FEHACapab enumerates the HA capabilities of the FE. If the FE is not capable of graceful restarts or HA, then it will not be able to participate in HA as described in Section 8.1.",
      "ja": "FEHACapabは、FEのHA機能を列挙します。 FEは、正常な再起動またはHAできない場合、セクション8.1で説明したようにHAに参加することはできません。"
    },
    {
      "indent": 0,
      "text": "B.2. Components",
      "ja": "B.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "All components are explained in Section 7.3.1.",
      "ja": "すべてのコンポーネントは、7.3.1項で説明されています。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Data Encoding Examples",
      "ja": "付録C.データ符号化の例"
    },
    {
      "indent": 3,
      "text": "In this section a few examples of data encoding are discussed. These example, however, do not show any padding.",
      "ja": "このセクションでは、データ符号化のいくつかの例が議論されています。これらの例では、しかし、任意のパディングを示していません。"
    },
    {
      "indent": 3,
      "text": "==========\nExample 1:\n==========",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Structure with three fixed-lengthof, mandatory fields.",
      "ja": "3つの固定-lengthof、必須フィールドを持つ構造体。"
    },
    {
      "indent": 11,
      "text": "struct S {\nuint16 a\nuint16 b\nuint16 c\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(a) Describing all fields using SPARSEDATA-TLV",
      "ja": "（A）SPARSEDATA-TLVを使用して、すべてのフィールドの記述"
    },
    {
      "indent": 11,
      "text": "PATH-DATA-TLV\n  Path to an instance of S ...\n  SPARSEDATA-TLV\n    ComponentIDof(a), lengthof(a), valueof(a)\n    ComponentIDof(b), lengthof(b), valueof(b)\n    ComponentIDof(c), lengthof(c), valueof(c)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(b) Describing a subset of fields",
      "ja": "（b）は、フィールドのサブセットを記述"
    },
    {
      "indent": 11,
      "text": "PATH-DATA-TLV\n  Path to an instance of S ...\n  SPARSEDATA-TLV\n    ComponentIDof(a), lengthof(a), valueof(a)\n    ComponentIDof(c), lengthof(c), valueof(c)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: Even though there are non-optional components in structure S, since one can uniquely identify components, one can selectively send components of structure S (e.g., in the case of an update from CE to FE).",
      "ja": "注：一つは一意のコンポーネントを識別することができるので、構造体Sにおける非任意の成分がある場合でも、一つは選択的S（例えば、CEからFEへの更新の場合）構造体の構成要素を送信することができます。"
    },
    {
      "indent": 3,
      "text": "(c) Describing all fields using a FULLDATA-TLV",
      "ja": "（C）FULLDATA-TLVを使用して、すべてのフィールドの記述"
    },
    {
      "indent": 11,
      "text": "PATH-DATA-TLV\n  Path to an instance of S ...\n  FULLDATA-TLV\n    valueof(a)\n    valueof(b)\n    valueof(c)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "==========\nExample 2:\n==========",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Structure with three fixed-lengthof fields, one mandatory, two optional.",
      "ja": "3固定lengthofフィールド、必須1、2つのオプションを持つ構造体。"
    },
    {
      "indent": 11,
      "text": "struct T {\nuint16 a\nuint16 b (optional)\nuint16 c (optional)\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This example is identical to example 1, as illustrated below.",
      "ja": "以下に示すように、この例では、実施例1と同一です。"
    },
    {
      "indent": 3,
      "text": "(a) Describing all fields using SPARSEDATA-TLV",
      "ja": "（A）SPARSEDATA-TLVを使用して、すべてのフィールドの記述"
    },
    {
      "indent": 11,
      "text": "PATH-DATA-TLV\n  Path to an instance of S ...\n  SPARSEDATA-TLV\n    ComponentIDof(a), lengthof(a), valueof(a)\n    ComponentIDof(b), lengthof(b), valueof(b)\n    ComponentIDof(c), lengthof(c), valueof(c)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(b) Describing a subset of fields using SPARSEDATA-TLV",
      "ja": "（B）SPARSEDATA-TLVを使用して、フィールドのサブセットを記述"
    },
    {
      "indent": 11,
      "text": "PATH-DATA-TLV\n  Path to an instance of S ...\n  SPARSEDATA-TLV\n    ComponentIDof(a), lengthof(a), valueof(a)\n    ComponentIDof(c), lengthof(c), valueof(c)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(c) Describing all fields using a FULLDATA-TLV",
      "ja": "（C）FULLDATA-TLVを使用して、すべてのフィールドの記述"
    },
    {
      "indent": 11,
      "text": "PATH-DATA-TLV\n  Path to an instance of S ...\n  FULLDATA-TLV\n    valueof(a)\n    valueof(b)\n    valueof(c)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: FULLDATA-TLV _cannot_ be used unless all fields are being described.",
      "ja": "注意：すべてのフィールドが記述されている場合を除きFULLDATA-TLVを使用すること_cannot_。"
    },
    {
      "indent": 3,
      "text": "==========\nExample 3:\n==========",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Structure with a mix of fixed-lengthof and variable-lengthof fields, some mandatory, some optional. Note in this case, b is variable sized.",
      "ja": "固定lengthofと可変lengthofフィールド、いくつかの必須、いくつかのオプションが混在する構造。この場合には注意、Bはサイズ可変です。"
    },
    {
      "indent": 11,
      "text": "struct U {\nuint16 a\nstring b (optional)\nuint16 c (optional)\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(a) Describing all fields using SPARSEDATA-TLV",
      "ja": "（A）SPARSEDATA-TLVを使用して、すべてのフィールドの記述"
    },
    {
      "indent": 11,
      "text": "Path to an instance of U ...\nSPARSEDATA-TLV\n  ComponentIDof(a), lengthof(a), valueof(a)\n  ComponentIDof(b), lengthof(b), valueof(b)\n  ComponentIDof(c), lengthof(c), valueof(c)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(b) Describing a subset of fields using SPARSEDATA-TLV",
      "ja": "（B）SPARSEDATA-TLVを使用して、フィールドのサブセットを記述"
    },
    {
      "indent": 11,
      "text": "Path to an instance of U ...\nSPARSEDATA-TLV\n  ComponentIDof(a), lengthof(a), valueof(a)\n  ComponentIDof(c), lengthof(c), valueof(c)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(c) Describing all fields using FULLDATA-TLV",
      "ja": "（C）FULLDATA-TLVを使用して、すべてのフィールドの記述"
    },
    {
      "indent": 11,
      "text": "Path to an instance of U ...\n  FULLDATA-TLV\n    valueof(a)\n    FULLDATA-TLV\n      valueof(b)\n    valueof(c)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: The variable-length field requires the addition of a FULLDATA-TLV within the outer FULLDATA-TLV as in the case of component b above.",
      "ja": "注：可変長フィールドは、上記成分Bの場合と同様に、外側FULLDATA-TLV内FULLDATA-TLVの添加を必要とします。"
    },
    {
      "indent": 3,
      "text": "==========\nExample 4:\n==========",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Structure containing an array of another structure type.",
      "ja": "別の構造型の配列を含む構造体。"
    },
    {
      "indent": 11,
      "text": "struct V {\nuint32 x\nuint32 y\nstruct U z[]\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(a) Encoding using SPARSEDATA-TLV, with two instances of z[], also described with SPARSEDATA-TLV, assuming only the 10th and 15th subscripts of z[] are encoded.",
      "ja": "（A）[]エンコードされているだけ10およびZ 15の添え字を想定し、またSPARSEDATA-TLVて説明Z []の2つのインスタンスと、SPARSEDATA-TLVを用いた符号化。"
    },
    {
      "indent": 8,
      "text": "path to instance of V ...\nSPARSEDATA-TLV\n ComponentIDof(x), lengthof(x), valueof(x)\n ComponentIDof(y), lengthof(y), valueof(y)\n ComponentIDof(z), lengthof(all below)\n   ComponentID = 10 (i.e index 10 from z[]), lengthof(all below)\n       ComponentIDof(a), lengthof(a), valueof(a)\n       ComponentIDof(b), lengthof(b), valueof(b)\n   ComponentID = 15 (index 15 from z[]), lengthof(all below)\n       ComponentIDof(a), lengthof(a), valueof(a)\n       ComponentIDof(c), lengthof(c), valueof(c)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note the holes in the components of z (10 followed by 15). Also note the gap in index 15 with only components a and c appearing but not b.",
      "ja": "（15続く10）Zのコンポーネントの穴に注意してください。また、唯一の成分Aおよび出現Cが、Bではないとインデックス15の隙間に注意してください。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Use Cases",
      "ja": "付録D.ユースケース"
    },
    {
      "indent": 3,
      "text": "Assume LFB with the following components for the following use cases.",
      "ja": "以下の使用例については、以下のコンポーネントでLFBを前提としています。"
    },
    {
      "indent": 3,
      "text": "foo1, type u32, ID = 1",
      "ja": "foo1は、型U32、ID = 1"
    },
    {
      "indent": 3,
      "text": "foo2, type u32, ID = 2",
      "ja": "foo2は、型U32、ID = 2"
    },
    {
      "indent": 3,
      "text": "table1: type array, ID = 3 components are: t1, type u32, ID = 1 t2, type u32, ID = 2 // index into table2 KEY: nhkey, ID = 1, V = t2",
      "ja": "TABLE1：型アレイ、ID = 3つの成分である：T1、型U32、ID = 1、T2、型U32、ID = 2 //インデックステーブル2のKEYへ：nhkey、ID = 1、V = T2"
    },
    {
      "indent": 3,
      "text": "table2: type array, ID = 4 components are: j1, type u32, ID = 1 j2, type u32, ID = 2 KEY: akey, ID = 1, V = { j1,j2 }",
      "ja": "表2：型アレイ、ID = 4つの成分である：J1、型U32、ID = 1 J2、型U32、ID = 2 KEY：AKEY、ID = 1、V = {J1、J2}"
    },
    {
      "indent": 3,
      "text": "table3: type array, ID = 5 components are: someid, type u32, ID = 1 name, type string variable sized, ID = 2",
      "ja": "表3：タイプアレイ、ID = 5の構成要素は、次のとおりsomeid、型U32、ID = 1名、文字列型変数サイズ、ID = 2"
    },
    {
      "indent": 3,
      "text": "table4: type array, ID = 6 components are: j1, type u32, ID = 1 j2, type u32, ID = 2 j3, type u32, ID = 3 j4, type u32, ID = 4 KEY: mykey, ID = 1, V = { j1}",
      "ja": "表4：型アレイ、ID = 6の構成要素は、次のとおりJ1、型U32、ID = 1 J2、型U32、ID = 2 J3、型U32、ID = 3 J4、型U32、ID = 4 KEY：mykeyを、ID = 1 、Vは= {} J1"
    },
    {
      "indent": 3,
      "text": "table5: type array, ID = 7 components are: p1, type u32, ID = 1 p2, type array, ID = 2, array components of type-X",
      "ja": "表5：型アレイ、ID = 7つの成分である：P1、タイプU32、ID = 1、P2、型アレイ、ID = 2、タイプXの配列要素"
    },
    {
      "indent": 3,
      "text": "Type-X: x1, ID 1, type u32 x2, ID2 , type u32 KEY: tkey, ID = 1, V = { x1}",
      "ja": "タイプX：X 1、ID 1、タイプU32×2、ID2、型U32のKEY：処理鍵、ID = 1、V = {X 1}"
    },
    {
      "indent": 3,
      "text": "All examples will use valueof(x) to indicate the value of the referenced component x. In the case where F_SEL** are missing (bits equal to 00) then the flags will not show any selection.",
      "ja": "全ての例は、参照成分xの値を示すためのvalueOf（X）を使用します。 F_SEL **が欠落している場合（00に等しいビット）で、次いでフラグは、任意の選択は表示されません。"
    },
    {
      "indent": 3,
      "text": "All the examples only show use of FULLDATA-TLV for data encoding; although SPARSEDATA-TLV would make more sense in certain occasions, the emphasis is on showing the message layout. Refer to Appendix C for examples that show usage of both FULLDATA-TLV and SPARSEDATA-TLV.",
      "ja": "すべての例は、単なるデータの符号化のためのFULLDATA-TLVの使用を示しています。 SPARSEDATA-TLVは、特定の場面で、より理にかなっているが、重点は、メッセージのレイアウトを示すです。 FULLDATA-TLVとSPARSEDATA-TLVの両方の使用を示す例については、付録Cを参照。"
    },
    {
      "indent": 3,
      "text": "1. To get foo1",
      "section_title": true,
      "ja": "1. foo1のを取得するには"
    },
    {
      "indent": 3,
      "text": "OPER = GET-TLV PATH-DATA-TLV: IDCount = 1, IDs = 1 Result: OPER = GET-RESPONSE-TLV PATH-DATA-TLV: flags=0, IDCount = 1, IDs = 1 FULLDATA-TLV L = 4+4, V = valueof(foo1)",
      "ja": "OPER = GET-TLV PATH-DATA-TLV：IDCOUNT = 1、のID = 1の検索結果：OPER = GET-RESPONSE-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 1、IDが= 1 FULLDATA-TLVのL = 4 +4、V =のvalueOf（foo1の）"
    },
    {
      "indent": 3,
      "text": "2. To set foo2 to 10",
      "section_title": true,
      "ja": "2. 10にfoo2はを設定するには"
    },
    {
      "indent": 3,
      "text": "OPER = SET-TLV PATH-DATA-TLV: flags = 0, IDCount = 1, IDs = 2 FULLDATA-TLV: L = 4+4, V=10",
      "ja": "OPER = SET-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 1、IDが= 2 FULLDATA-TLV：L = 4 + 4、V = 10"
    },
    {
      "indent": 3,
      "text": "Result: OPER = SET-RESPONSE-TLV PATH-DATA-TLV: flags = 0, IDCount = 1, IDs = 2 RESULT-TLV",
      "ja": "結果：OPER = SET-RESPONSE-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 1、IDが= 2 RESULT-TLV"
    },
    {
      "indent": 3,
      "text": "3. To dump table2",
      "section_title": true,
      "ja": "3.表2をダンプします"
    },
    {
      "indent": 6,
      "text": "OPER = GET-TLV PATH-DATA-TLV: IDCount = 1, IDs = 4 Result: OPER = GET-RESPONSE-TLV PATH-DATA-TLV: flags = 0, IDCount = 1, IDs = 4 FULLDATA-TLV: L = XXX, V= a series of: index, valueof(j1), valueof(j2) representing the entire table",
      "ja": "OPER = GET-TLV PATH-DATA-TLV：IDCOUNT = 1、のID = 4の検索結果：OPER = GET-RESPONSE-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 1、IDが= 4 FULLDATA-TLV：L = XXX、Vは一連=：表全体を表す指標を、のvalueOf（J1）のvalueOf（J2）"
    },
    {
      "indent": 8,
      "text": "Note: One should be able to take a GET-RESPONSE-TLV and convert it to a SET-TLV. If the result in the above example is sent back in a SET-TLV (instead of a GET-RESPONSE_TLV), then the entire contents of the table will be replaced at that point.",
      "ja": "注意：一つは、GET-RESPONSE-TLVを取ると、SET-TLVに変換することができるはずです。上記の例の結果は、SET-TLV（代わりにGET-RESPONSE_TLVの）に返送された場合、テーブルの全内容は、その時点で交換されます。"
    },
    {
      "indent": 3,
      "text": "4. Multiple operations example. To create entry 0-5 of table2 (Error conditions are ignored)",
      "ja": "前記複数の動作例。表2のエントリ0-5を作成するには（エラー条件は無視されます）"
    },
    {
      "indent": 3,
      "text": "OPER = SET-TLV PATH-DATA-TLV: flags = 0 , IDCount = 1, IDs = 4 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 0 FULLDATA-TLV valueof(j1), valueof(j2) of entry 0 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 1 FULLDATA-TLV valueof(j1), valueof(j2) of entry 1 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 2 FULLDATA-TLV valueof(j1), valueof(j2) of entry 2 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 3 FULLDATA-TLV valueof(j1), valueof(j2) of entry 3 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 4 FULLDATA-TLV valueof(j1), valueof(j2) of entry 4 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 5 FULLDATA-TLV valueof(j1), valueof(j2) of entry 5",
      "ja": "OPER = SET-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 1、IDは= 4 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 0 FULLDATA-TLV用のvalueOf（J1）のvalueOf（J2）エントリ1 PATH-DATA-TLVフラグのエントリ0 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 1 FULLDATA-TLV用のvalueOf（J1）のvalueOf（J2）の= 0、IDCOUNT = 1、IDが= 2 FULLDATA-TLVのvalueOf（J1）のvalueOfエントリー2 PATH-DATA-TLVフラグの（J2）= 0、IDCOUNT = 1、のID = 3 FULLDATA-TLV用のvalueOf（J1）のvalueOf（J2）エントリの3 PATH-DATA- TLVフラグ= 0、IDCOUNT = 1、IDが= 4 FULLDATA-TLV用のvalueOf（J1）のvalueOfエントリの（J2）4 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 5 FULLDATA-TLV用のvalueOf（J1）エントリー5、のvalueOf（J2）"
    },
    {
      "indent": 3,
      "text": "Result: OPER = SET-RESPONSE-TLV PATH-DATA-TLV: flags = 0 , IDCount = 1, IDs = 4 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 0 RESULT-TLV PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 1 RESULT-TLV PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 2 RESULT-TLV PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 3 RESULT-TLV PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 4 RESULT-TLV PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 5 RESULT-TLV",
      "ja": "結果：OPER = SET-RESPONSE-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 1、IDが= 4 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 0 RESULT-TLV PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 1 RESULT-TLV経路-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 2 RESULT-TLV経路-DATA-TLVフラグ= 0、IDCOUNT = 1、のID = 3 RESULT -TLV PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 4 RESULT-TLV PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 5 RESULT-TLV"
    },
    {
      "indent": 3,
      "text": "5. Block operations (with holes) example. Replace entry 0,2 of table2.",
      "ja": "5.ブロック操作（穴を有する）の例。表2のエントリ0,2を交換してください。"
    },
    {
      "indent": 3,
      "text": "OPER = SET-TLV PATH-DATA-TLV: flags = 0 , IDCount = 1, IDs = 4 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 0 FULLDATA-TLV containing valueof(j1), valueof(j2) of 0 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 2 FULLDATA-TLV containing valueof(j1), valueof(j2) of 2",
      "ja": "OPER = SET-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 1、IDは= 4 PATH-DATA-TLVフラグ= 0、のvalueOf（J1）を含有IDCOUNT = 1、IDが= 0 FULLDATA-TLV、のvalueOf（J2 2のvalueOf（J1）のvalueOf（J2）を含む）0 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 2 FULLDATA-TLV"
    },
    {
      "indent": 3,
      "text": "Result: OPER = SET-TLV PATH-DATA-TLV: flags = 0 , IDCount = 1, IDs = 4 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 0 RESULT-TLV PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 2 RESULT-TLV",
      "ja": "結果：OPER = SET-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 1、IDが= 4 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 0 RESULT-TLV PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 2 RESULT-TLV"
    },
    {
      "indent": 3,
      "text": "6. Getting rows example. Get first entry of table2.",
      "section_title": true,
      "ja": "6.行の例を取得します。表2の最初のエントリを取得します。"
    },
    {
      "indent": 3,
      "text": "OPER = GET-TLV PATH-DATA-TLV: IDCount = 2, IDs = 4.0",
      "ja": "OPER = GET-TLV PATH-DATA-TLV：IDCOUNT = 2、IDを= 4.0"
    },
    {
      "indent": 3,
      "text": "Result: OPER = GET-RESPONSE-TLV PATH-DATA-TLV: IDCount = 2, IDs = 4.0 FULLDATA-TLV containing valueof(j1), valueof(j2)",
      "ja": "結果：OPER = GET-RESPONSE-TLV経路-DATA-TLV：IDCOUNT = 2、IDが= 4.0のvalueOf（J1）を含有FULLDATA-TLV、のvalueOf（J2）"
    },
    {
      "indent": 3,
      "text": "7. Get entry 0-5 of table2.",
      "section_title": true,
      "ja": "7.表2のエントリ0-5を取得します。"
    },
    {
      "indent": 3,
      "text": "OPER = GET-TLV PATH-DATA-TLV: flags = 0, IDCount = 1, IDs = 4 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 0 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 1 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 2 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 3 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 4 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 5",
      "ja": "OPER = GET-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 1、IDが= 4 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 0 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1 、のID = 1 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 2 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、のID = 3 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 4 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 5"
    },
    {
      "indent": 3,
      "text": "Result: OPER = GET-RESPONSE-TLV PATH-DATA-TLV: flags = 0, IDCount = 1, IDs = 4 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 0 FULLDATA-TLV containing valueof(j1), valueof(j2) PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 1 FULLDATA-TLV containing valueof(j1), valueof(j2) PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 2 FULLDATA-TLV containing valueof(j1), valueof(j2) PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 3 FULLDATA-TLV containing valueof(j1), valueof(j2) PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 4 FULLDATA-TLV containing valueof(j1), valueof(j2) PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 5 FULLDATA-TLV containing valueof(j1), valueof(j2)",
      "ja": "結果：OPER = GET-RESPONSE-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 1、IDが= 4 PATH-DATA-TLVフラグ= 0、のvalueOfを含むIDCOUNT = 1、IDが= 0 FULLDATA-TLV（J1） 、のvalueOf（J2）PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 1 FULLDATA-TLVのvalueOf（J1）を含有する、のvalueOf（J2）PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 2 valueOf（J1）を含むのvalueOf（J1）を含有FULLDATA-TLV、のvalueOf（J2）PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、のID = 3 FULLDATA-TLV、のvalueOf（J2）PATH-DATA-TLVフラグ= 0 valueOf（J1）のvalueOf（J2）を含む、IDCOUNT = 1、IDが= 4 FULLDATA-TLVのvalueOf（J1）を含有する、のvalueOf（J2）PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 5 FULLDATA-TLV"
    },
    {
      "indent": 3,
      "text": "8. Create a row in table2, index 5.",
      "section_title": true,
      "ja": "8.表2の行を作成し、インデックス5。"
    },
    {
      "indent": 3,
      "text": "OPER = SET-TLV PATH-DATA-TLV: flags = 0, IDCount = 2, IDs = 4.5 FULLDATA-TLV containing valueof(j1), valueof(j2)",
      "ja": "OPER = SET-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 2、IDが= 4.5 FULLDATA-TLV含有のvalueOf（J1）のvalueOf（J2）"
    },
    {
      "indent": 3,
      "text": "Result: OPER = SET-RESPONSE-TLV PATH-DATA-TLV: flags = 0, IDCount = 1, IDs = 4.5 RESULT-TLV",
      "ja": "結果：OPER = SET-RESPONSE-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 1、IDを= 4.5 RESULT-TLV"
    },
    {
      "indent": 3,
      "text": "9. Dump contents of table1.",
      "section_title": true,
      "ja": "TABLE1の9.ダンプ内容。"
    },
    {
      "indent": 3,
      "text": "OPER = GET-TLV PATH-DATA-TLV: flags = 0, IDCount = 1, IDs = 3",
      "ja": "OPER = GET-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 1、IDを= 3"
    },
    {
      "indent": 3,
      "text": "Result: OPER = GET-RESPONSE-TLV PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 3 FULLDATA-TLV, Length = XXXX (depending on size of table1) index, valueof(t1),valueof(t2) index, valueof(t1),valueof(t2) . . .",
      "ja": "結果：OPER = GET-RESPONSE-TLV PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、のID = 3 FULLDATA-TLV、長さ= XXXX（TABLE1のサイズに応じて）インデックス、のvalueOf（T1）のvalueOf（T2）インデックスのvalueOf（T1）のvalueOf（T2）。 。 。"
    },
    {
      "indent": 3,
      "text": "10. Using keys. Get row entry from table4 where j1=100. Recall, j1 is a defined key for this table and its KeyID is 1.",
      "ja": "10.キーを使用。 J1 = 100テーブルからの行のエントリを取得します。リコールは、J1は、このテーブルの定義されたキーであり、そのキーIDは1です。"
    },
    {
      "indent": 3,
      "text": "OPER = GET-TLV PATH-DATA-TLV: flags = F_SELKEY IDCount = 1, IDs = 6 KEYINFO-TLV = KeyID=1, KEY_DATA=100",
      "ja": "OPER = GET-TLV PATH-DATA-TLV：フラグ= F_SELKEY IDCOUNT = 1、IDは= 6のKeyInfo-TLV = KeyIDを= 1、KEY_DATA = 100"
    },
    {
      "indent": 3,
      "text": "Result: If j1=100 was at index 10 OPER = GET-RESPONSE-TLV PATH-DATA-TLV: flags = 0, IDCount = 1, IDs = 6.10 FULLDATA-TLV containing valueof(j1), valueof(j2),valueof(j3),valueof(j4)",
      "ja": "結果：J1 = 100、インデックス10 OPER = GET-RESPONSE-TLV経路-DATA-TLVであった場合は、次のフラグ= 0、IDCOUNT = 1、IDを= 6.10 FULLDATA-TLV含有のvalueOf（J1）のvalueOf（J2）のvalueOf（ J3）、のvalueOf（J4）"
    },
    {
      "indent": 3,
      "text": "11. Delete row with KEY match (j1=100, j2=200) in table2. Note that the j1,j2 pair is a defined key for the table2.",
      "ja": "11.表2に（J1 = 100、J 2 = 200）KEY一致して行を削除します。 J1、J2のペアは、表2のために定義されたキーであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "OPER = DEL-TLV PATH-DATA-TLV: flags = F_SELKEY IDCount = 1, IDs = 4 KEYINFO-TLV: {KeyID =1 KEY_DATA=100,200}",
      "ja": "OPER = DEL-TLV経路-DATA-TLV：フラグ= F_SELKEY IDCOUNT = 1、のID = 4のKeyInfo-TLV：{KeyIDを= 1 KEY_DATA = 100,200}"
    },
    {
      "indent": 3,
      "text": "Result: If (j1=100, j2=200) was at entry 15: OPER = DELETE-RESPONSE-TLV PATH-DATA-TLV: flags = 0 IDCount = 2, IDs = 4.15 RESULT-TLV",
      "ja": "結果：OPER = DELETE-RESPONSE-TLV PATH-DATA-TLV：（J1 = 100、J 2 = 200）場合、エントリで15であったフラグ= 0 IDCOUNT = 2のID = 4.15 RESULT-TLV"
    },
    {
      "indent": 3,
      "text": "12. Dump contents of table3. It should be noted that this table has a column with a component name that is variable sized. The purpose of this use case is to show how such a component is to be encoded.",
      "ja": "表3の12ダンプの内容。なお、このテーブルは、サイズ可変である部品名を持つ列を有していることに留意すべきです。この使用例の目的は、そのような成分が符号化される方法を示すことです。"
    },
    {
      "indent": 3,
      "text": "OPER = GET-TLV PATH-DATA-TLV: flags = 0 IDCount = 1, IDs = 5",
      "ja": "OPER = GET-TLV PATH-DATA-TLV：フラグ= 0 IDCOUNT = 1、IDを= 5"
    },
    {
      "indent": 3,
      "text": "Result: OPER = GET-RESPONSE-TLV PATH-DATA-TLV: flags = 0 IDCount = 1, IDs = 5 FULLDATA-TLV, Length = XXXX index, someidv, TLV: T=FULLDATA-TLV, L = 4+strlen(namev), V = valueof(v) index, someidv, TLV: T=FULLDATA-TLV, L = 4+strlen(namev), V = valueof(v) index, someidv, TLV: T=FULLDATA-TLV, L = 4+strlen(namev), V = valueof(v) index, someidv, TLV: T=FULLDATA-TLV, L = 4+strlen(namev), V = valueof(v) . . .",
      "ja": "結果：OPER = GET-RESPONSE-TLV PATH-DATA-TLV：フラグ= 0 IDCOUNT = 1、IDが= 5 FULLDATA-TLV、長さ= XXXXインデックス、someidv、TLV：T = FULLDATA-TLV、L = 4 + STRLEN（ namev）、Vは=のvalueOf（V）インデックス、someidv、TLV：T = FULLDATA-TLV、L = 4 + STRLEN（namev）、Vは=のvalueOf（V）インデックス、someidv、TLV：T = FULLDATA-TLV、L = 4 + STRLEN（namev）、V =のvalueOf（V）インデックス、someidv、TLV：T = FULLDATA-TLV、L = 4 + STRLEN（namev）、Vは=のvalueOf（V）。 。 。"
    },
    {
      "indent": 3,
      "text": "13. Multiple atomic operations.",
      "section_title": true,
      "ja": "13.複数のアトミック操作。"
    },
    {
      "indent": 8,
      "text": "Note 1:   This emulates adding a new nexthop entry and then\n   atomically updating the L3 entries pointing to an old NH to\n   point to a new one.  The assumption is that both tables are\n   in the same LFB.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Note: Observe the two operations on the LFB instance; both are SET operations.",
      "ja": "注：LFBインスタンス上の2つの動作を守っ。両方が操作を設定されています。"
    },
    {
      "indent": 3,
      "text": "//Operation 1: Add a new entry to table2 index #20. OPER = SET-TLV Path-TLV: flags = 0, IDCount = 2, IDs = 4.20 FULLDATA-TLV, V= valueof(j1),valueof(j2)",
      "ja": "//オペレーション1：表2インデックス＃20に新しいエントリを追加します。 OPER = SET-TLVパスTLV：フラグ= 0、IDCOUNT = 2のID = 4.20 FULLDATA-TLV、V =のvalueOf（J1）のvalueOf（J2）"
    },
    {
      "indent": 3,
      "text": "// Operation 2: Update table1 entry which // was pointing with t2 = 10 to now point to 20 OPER = SET-TLV PATH-DATA-TLV: flags = F_SELKEY, IDCount = 1, IDs = 3 KEYINFO-TLV = KeyID=1 KEY_DATA=10 PATH-DATA-TLV flags = 0 IDCount = 1, IDs = 2 FULLDATA-TLV, V= 20",
      "ja": "//操作2：//がT2で指した更新TABLE1エントリ= 10が今20 OPER = SET-TLV PATH-DATA-TLVを指すように：フラグ= F_SELKEY、IDCOUNT = 1、のID = 3のKeyInfo-TLV = KeyIDを= 1 KEY_DATA = 10 PATH-DATA-TLVフラグ= 0 IDCOUNT = 1、IDが= 2 FULLDATA-TLV、V = 20"
    },
    {
      "indent": 3,
      "text": "Result: //first operation, SET OPER = SET-RESPONSE-TLV PATH-DATA-TLV flags = 0 IDCount = 3, IDs = 4.20 RESULT-TLV code = success FULLDATA-TLV, V = valueof(j1),valueof(j2) // second operation SET - assuming entry 16 was updated OPER = SET-RESPONSE-TLV PATH-DATA-TLV flags = 0 IDCount = 2, IDs = 3.16 PATH-DATA-TLV flags = 0 IDCount = 1, IDs = 2 RESULT-TLV code = success FULLDATA-TLV, Length = XXXX v=20",
      "ja": "結果：//最初の操作、SET OPER = SET-RESPONSE-TLV PATH-DATA-TLVフラグ= 0 IDCOUNT = 3、IDを= 4.20 RESULT-TLVコード=成功FULLDATA-TLV、V =のvalueOf（J1）のvalueOf（J2 ）//第2の動作セット - 想定エントリ16が更新されたOPER = SET-RESPONSE-TLV PATH-DATA-TLVフラグ= 0 IDCOUNT = 2のID = 3.16 PATH-DATA-TLVフラグ= 0 IDCOUNT = 1、IDが= 2 RESULT -TLVコード=成功FULLDATA-TLV、長さ= XXXXのV = 20"
    },
    {
      "indent": 3,
      "text": "14. Selective setting. On table4 -- for indices 1, 3, 5, 7, and 9. Replace j1 to 100, j2 to 200, j3 to 300. Leave j4 as is.",
      "ja": "14.選択設定。表4に - と同様にインデックス1、3、5、7、および9 300脱退J4 200へJ2 100 J1、J3を交換します。"
    },
    {
      "indent": 3,
      "text": "PER = SET-TLV PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 6 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 1 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 1 FULLDATA-TLV, Length = XXXX, V = {100} PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 2 FULLDATA-TLV, Length = XXXX, V = {200} PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 3 FULLDATA-TLV, Length = XXXX, V = {300} PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 3 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 1 FULLDATA-TLV, Length = XXXX, V = {100} PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 2 FULLDATA-TLV, Length = XXXX, V = {200} PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 3 FULLDATA-TLV, Length = XXXX, V = {300}",
      "ja": "PER = SET-TLV PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 6 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 1 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、 ID = 1 FULLDATA-TLV、長さ= XXXX、V = {100} PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 2 FULLDATA-TLV、長さ= XXXX、V = {200} PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、のID = 3 FULLDATA-TLV、長さ= XXXX、V = {300} PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、のID = 3 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 1 FULLDATA-TLV、長さ= XXXX、V = {100} PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 2 FULLDATA-TLV、長さ= XXXX、V = {200} PATH- DATA-TLVフラグ= 0、IDCOUNT = 1、のID = 3 FULLDATA-TLV、長さ= XXXX、V = {300}"
    },
    {
      "indent": 11,
      "text": "PATH-DATA-TLV\n    flags = 0, IDCount = 1, IDs = 5\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 1\n        FULLDATA-TLV, Length = XXXX, V = {100}\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 2\n        FULLDATA-TLV, Length = XXXX, V = {200}\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 3\n        FULLDATA-TLV, Length = XXXX, V = {300}\nPATH-DATA-TLV\n    flags = 0, IDCount = 1, IDs = 7\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 1\n        FULLDATA-TLV, Length = XXXX, V = {100}\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 2\n        FULLDATA-TLV, Length = XXXX, V = {200}\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 3\n        FULLDATA-TLV, Length = XXXX, V = {300}\nPATH-DATA-TLV\n    flags = 0, IDCount = 1, IDs = 9\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 1\n        FULLDATA-TLV, Length = XXXX, V = {100}\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 2\n        FULLDATA-TLV, Length = XXXX, V = {200}\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 3\n        FULLDATA-TLV, Length = XXXX, V = {300}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "response:",
      "ja": "応答："
    },
    {
      "indent": 3,
      "text": "OPER = SET-RESPONSE-TLV PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 6 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 1 PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 1 RESULT-TLV PATH-DATA-TLV flags = 0, IDCount = 1, IDs = 2 RESULT-TLV",
      "ja": "OPER = SET-RESPONSE-TLV PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 6 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 1 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 1 RESULT-TLV PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 2 RESULT-TLV"
    },
    {
      "indent": 11,
      "text": "    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 3\n        RESULT-TLV\nPATH-DATA-TLV\n    flags = 0, IDCount = 1, IDs = 3\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 1\n        RESULT-TLV\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 2\n        RESULT-TLV\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 3\n        RESULT-TLV\nPATH-DATA-TLV\n    flags = 0, IDCount = 1, IDs = 5\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 1\n        RESULT-TLV\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 2\n        RESULT-TLV\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 3\n        RESULT-TLV\nPATH-DATA-TLV\n    flags = 0, IDCount = 1, IDs = 7\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 1\n        RESULT-TLV\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 2\n        RESULT-TLV\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 3\n        RESULT-TLV\nPATH-DATA-TLV\n    flags = 0, IDCount = 1, IDs = 9\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 1\n        RESULT-TLV\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 2\n        RESULT-TLV\n    PATH-DATA-TLV\n        flags = 0, IDCount = 1, IDs = 3\n        RESULT-TLV",
      "raw": true
    },
    {
      "indent": 3,
      "text": "15. Manipulation of table of table examples. Get x1 from table10 row with index 4, inside table5 entry 10.",
      "ja": "テーブルの例の表の15操作。表5のエントリー10の内部に、指標4と表10行からX1を得ます。"
    },
    {
      "indent": 3,
      "text": "operation = GET-TLV PATH-DATA-TLV flags = 0 IDCount = 5, IDs=7.10.2.4.1",
      "ja": "操作= GET-TLV PATH-DATA-TLVフラグ= 0 IDCOUNT = 5、IDを= 7.10.2.4.1"
    },
    {
      "indent": 3,
      "text": "Results: operation = GET-RESPONSE-TLV PATH-DATA-TLV flags = 0 IDCount = 5, IDs=7.10.2.4.1 FULLDATA-TLV: L=XXXX, V = valueof(x1)",
      "ja": "結果：操作= GET-RESPONSE-TLV PATH-DATA-TLVフラグ= 0 IDCOUNT = 5、IDが= 7.10.2.4.1 FULLDATA-TLV：L = XXXX、V =のvalueOf（X1）"
    },
    {
      "indent": 3,
      "text": "16. From table5's row 10 table10, get X2s based on the value of x1 equaling 10 (recall x1 is KeyID 1).",
      "ja": "表5の行10表10から16、（リコールx1がKeyIDを1である）10に等しいX1の値に基づいて、X2Sを得ます。"
    },
    {
      "indent": 3,
      "text": "operation = GET-TLV PATH-DATA-TLV flag = F_SELKEY, IDCount=3, IDS = 7.10.2 KEYINFO-TLV, KeyID = 1, KEYDATA = 10 PATH-DATA-TLV IDCount = 1, IDS = 2 //select x2",
      "ja": "オペレーション= GET-TLV PATH-DATA-TLVフラグ= F_SELKEY、IDCOUNT = 3、IDS = 7.10.2のKeyInfo-TLV、KeyIDを= 1、KEYDATA = 10 PATH-DATA-TLV IDCOUNT = 1、IDS = 2×2を選択//"
    },
    {
      "indent": 3,
      "text": "Results: If x1=10 was at entry 11: operation = GET-RESPONSE-TLV PATH-DATA-TLV flag = 0, IDCount=5, IDS = 7.10.2.11 PATH-DATA-TLV flags = 0 IDCount = 1, IDS = 2 FULLDATA-TLV: L=XXXX, V = valueof(x2)",
      "ja": "結果：X1 = 10エントリで11であった場合は、次の操作= GET-RESPONSE-TLV PATH-DATA-TLVフラグ= 0、IDCOUNT = 5、IDS = 7.10.2.11 PATH-DATA-TLVフラグ= 0 IDCOUNT = 1、IDS = 2 FULLDATA-TLV：L = XXXX、V =のvalueOf（X2）"
    },
    {
      "indent": 3,
      "text": "17. Further example of manipulating a table of tables",
      "section_title": true,
      "ja": "テーブルのテーブルを操作する17さらなる例"
    },
    {
      "indent": 3,
      "text": "Consider table6, which is defined as: table6: type array, ID = 8 components are: p1, type u32, ID = 1 p2, type array, ID = 2, array components of type type-A",
      "ja": "表6：タイプアレイ、ID = 8つの部品である：P1、タイプU32、ID = 1、P2、型アレイ、ID = 2、タイプtype-Aの配列要素として定義されている考える表6、"
    },
    {
      "indent": 3,
      "text": "type-A: a1, type u32, ID 1, a2, type array ID2 ,array components of type type-B",
      "ja": "タイプA：A1、型U32、ID 1、A2、型配列ID2、タイプtype-Bの配列要素"
    },
    {
      "indent": 3,
      "text": "type-B: b1, type u32, ID 1 b2, type u32, ID 2",
      "ja": "タイプB：B1、型U32、ID 1 B2、型U32、ID 2"
    },
    {
      "indent": 3,
      "text": "If for example one wanted to set by replacing: table6.10.p1 to 111 table6.10.p2.20.a1 to 222 table6.10.p2.20.a2.30.b1 to 333",
      "ja": "333に222 table6.10.p2.20.a2.30.b1に111 table6.10.p2.20.a1にtable6.10.p1：一例のために交換することによって設定したい場合"
    },
    {
      "indent": 3,
      "text": "in one message and one operation.",
      "ja": "一つのメッセージと、一回の操作インチ"
    },
    {
      "indent": 3,
      "text": "There are two ways to do this: a) using nesting b) using a flat path data",
      "ja": "これを行うには二つの方法があります：a）は、ネストBを使用して）フラットパスデータを使用して"
    },
    {
      "indent": 3,
      "text": "A. Method using nesting in one message with a single operation",
      "ja": "単一の操作で一つのメッセージにネスティングを使用する方法A."
    },
    {
      "indent": 3,
      "text": "operation = SET-TLV PATH-DATA-TLV flags = 0 IDCount = 2, IDs=6.10 PATH-DATA-TLV flags = 0, IDCount = 1, IDs=1 FULLDATA-TLV: L=XXXX, V = {111} PATH-DATA-TLV flags = 0 IDCount = 2, IDs=2.20 PATH-DATA-TLV flags = 0, IDCount = 1, IDs=1 FULLDATA-TLV: L=XXXX, V = {222} PATH-DATA-TLV : flags = 0, IDCount = 3, IDs=2.30.1 FULLDATA-TLV: L=XXXX, V = {333}",
      "ja": "オペレーション= SET-TLV経路-DATA-TLVフラグ= 0 IDCOUNT = 2のID = 6.10 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 1 FULLDATA-TLV：L = XXXX、V = {111} PATH -DATA-TLVフラグ= 0 IDCOUNT = 2のID = 2.20 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 1 FULLDATA-TLV：L = XXXX、V = {222} PATH-DATA-TLV：フラグ= 0、IDCOUNT = 3、IDが= 2.30.1 FULLDATA-TLV：L = XXXX、V = {333}"
    },
    {
      "indent": 3,
      "text": "Result: operation = SET-RESPONSE-TLV PATH-DATA-TLV flags = 0 IDCount = 2, IDs=6.10 PATH-DATA-TLV flags = 0, IDCount = 1, IDs=1 RESULT-TLV PATH-DATA-TLV flags = 0 IDCount = 2, IDs=2.20 PATH-DATA-TLV flags = 0, IDCount = 1, IDs=1 RESULT-TLV PATH-DATA-TLV : flags = 0, IDCount = 3, IDs=2.30.1 RESULT-TLV",
      "ja": "結果：操作= SET-RESPONSE-TLV PATH-DATA-TLVフラグ= 0 IDCOUNT = 2のID = 6.10 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 1 RESULT-TLV PATH-DATA-TLVフラグ= 0 IDCOUNT = 2のID = 2.20 PATH-DATA-TLVフラグ= 0、IDCOUNT = 1、IDが= 1 RESULT-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 3、IDが= 2.30.1 RESULT-TLV"
    },
    {
      "indent": 3,
      "text": "B. Method using a flat path data in one message with a single operation",
      "ja": "単一の操作で一つのメッセージにおけるフラットパスデータを使用してB.方法"
    },
    {
      "indent": 3,
      "text": "operation = SET-TLV PATH-DATA-TLV : flags = 0, IDCount = 3, IDs=6.10.1 FULLDATA-TLV: L=XXXX, V = {111} PATH-DATA-TLV : flags = 0, IDCount = 5, IDs=6.10.1.20.1 FULLDATA-TLV: L=XXXX, V = {222} PATH-DATA-TLV : flags = 0, IDCount = 7, IDs=6.10.1.20.1.30.1 FULLDATA-TLV: L=XXXX, V = {333} Result: operation = SET-TLV PATH-DATA-TLV : flags = 0, IDCount = 3, IDs=6.10.1 RESULT-TLV PATH-DATA-TLV : flags = 0, IDCount = 5, IDs=6.10.1.20.1 RESULT-TLV PATH-DATA-TLV : flags = 0, IDCount = 7, IDs=6.10.1.20.1.30.1 RESULT-TLV",
      "ja": "オペレーション= SET-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 3、IDが= 6.10.1 FULLDATA-TLV：L = XXXX、V = {111} PATH-DATA-TLV：フラグ= 0、IDCOUNT = 5 、のID = 6.10.1.20.1 FULLDATA-TLV：L = XXXX、V = {222} PATH-DATA-TLV：フラグ= 0、IDCOUNT = 7、のID = 6.10.1.20.1.30.1 FULLDATA-TLV：L = XXXX、V = {333}結果：動作= SET-TLV経路-DATA-TLV：= 0フラグ、IDCOUNT = 3、IDが= 6.10.1 RESULT-TLV経路-DATA-TLV：フラグ= 0、IDCOUNT = 5、 IDが= 6.10.1.20.1 RESULT-TLV PATH-DATA-TLV：フラグ= 0、IDCOUNT = 7、のID = 6.10.1.20.1.30.1 RESULT-TLV"
    },
    {
      "indent": 3,
      "text": "18. Get a whole LFB (all its components, etc.).",
      "section_title": true,
      "ja": "18.全体のLFB（そのすべてのコンポーネントなど）を取得します。"
    },
    {
      "indent": 8,
      "text": "For example:   At startup a CE might well want the entire FE\n   Object LFB.  So, in a request targeted at class 1, instance\n   1, one might find:",
      "raw": true
    },
    {
      "indent": 3,
      "text": "operation = GET-TLV PATH-DATA-TLV flags = 0 IDCount = 0",
      "ja": "操作= GET-TLV PATH-DATA-TLVフラグ= 0 IDCOUNT = 0"
    },
    {
      "indent": 3,
      "text": "result: operation = GET-RESPONSE-TLV PATH-DATA-TLV flags = 0 IDCount = 0 FULLDATA-TLV encoding of the FE Object LFB",
      "ja": "結果：FEの動作= GET-RESPONSE-TLV PATH-DATA-TLVフラグ= 0 IDCOUNT = 0 FULLDATA-TLVエンコーディングLFBオブジェクト"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Avri Doria (editor) Lulea University of Technology Rainbow Way Lulea SE-971 87 Sweden",
      "ja": "Avriドリア（エディタ）ルレオ工科大学の虹の道ルーレオSE-971 87スウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone: +46 73 277 1788 EMail: avri@ltu.se",
      "ja": "電話：+46 73 277 1788 Eメール：avri@ltu.se"
    },
    {
      "indent": 3,
      "text": "Jamal Hadi Salim (editor) Znyx Ottawa, Ontario Canada",
      "ja": "ジャマル・ハディサリム（エディタ）ZNYXオタワ、オンタリオ州カナダ"
    },
    {
      "indent": 3,
      "text": "Phone: EMail: hadi@mojatatu.com",
      "ja": "電話番号：Eメール：hadi@mojatatu.com"
    },
    {
      "indent": 3,
      "text": "Robert Haas (editor) IBM Saumerstrasse 4 8803 Ruschlikon Switzerland",
      "ja": "ロバート・ハース（編集者）IBM Saumerstrasse 4 8803リュシュリコンスイス"
    },
    {
      "indent": 3,
      "text": "Phone: EMail: rha@zurich.ibm.com",
      "ja": "電話番号：Eメール：rha@zurich.ibm.com"
    },
    {
      "indent": 3,
      "text": "Hormuzd M Khosravi (editor) Intel 2111 NE 25th Avenue Hillsboro, OR 97124 USA",
      "ja": "Hormuzd M Khosravi（エディタ）インテル2111 NE 25日アベニューヒルズボロ、OR 97124 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 503 264 0334 EMail: hormuzd.m.khosravi@intel.com",
      "ja": "電話：+1 503 264 0334 Eメール：hormuzd.m.khosravi@intel.com"
    },
    {
      "indent": 3,
      "text": "Weiming Wang (editor) Zhejiang Gongshang University 18, Xuezheng Str., Xiasha University Town Hangzhou 310018 P.R. China",
      "ja": "魏名王（エディタ）Z Hejiang行くアグリビジネス大学18、X UE正STR。、Ξアシャ大学町杭州310018中華人民共和国"
    },
    {
      "indent": 3,
      "text": "Phone: +86-571-28877721 EMail: wmwang@zjgsu.edu.cn",
      "ja": "電話：+ 86-571-28877721電子メール：wmwang@zjgsu.edu.cn"
    },
    {
      "indent": 3,
      "text": "Ligang Dong Zhejiang Gongshang University 18, Xuezheng Str., Xiasha University Town Hangzhou 310018 P.R. China",
      "ja": "L Iは、シリンダ洞Zは、AIB大学18、X UE正STR。、ξアシャ大学町杭州310018中華人民共和国をhejiang行きます"
    },
    {
      "indent": 3,
      "text": "Phone: +86-571-28877751 EMail: donglg@zjgsu.edu.cn",
      "ja": "電話：+ 86-571-28877751電子メール：donglg@zjgsu.edu.cn"
    },
    {
      "indent": 3,
      "text": "Ram Gopal Nokia 5, Wayside Road Burlington, MA 310035 USA",
      "ja": "ラムゴパルノキア5、道端の道路バーリントン、マサチューセッツ310035 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-781-993-3685 EMail: ram.gopal@nsn.com",
      "ja": "電話：+ 1-781-993-3685 Eメール：ram.gopal@nsn.com"
    },
    {
      "indent": 3,
      "text": "Joel Halpern P.O. Box 6049 Leesburg, VA 20178 USA",
      "ja": "ジョエルハルパーンの私書箱ボックス6049リーズバーグ、VA 20178 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-703-371-3043 EMail: jmh@joelhalpern.com",
      "ja": "電話：+ 1-703-371-3043 Eメール：jmh@joelhalpern.com"
    }
  ]
}