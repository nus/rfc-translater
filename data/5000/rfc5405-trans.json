{
  "title": {
    "text": "RFC 5405 - Unicast UDP Usage Guidelines for Application Designers",
    "ja": "RFC 5405 - アプリケーションデザイナーのためのユニキャストUDPの使用上の注意事項"
  },
  "number": 5405,
  "created_at": "2019-10-27 10:41:43.224979+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          L. Eggert\nRequest for Comments: 5405                                         Nokia\nBCP: 145                                                    G. Fairhurst\nCategory: Best Current Practice                   University of Aberdeen\n                                                           November 2008",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Unicast UDP Usage Guidelines for Application Designers",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements. Distribution of this memo is unlimited.",
      "ja": "このドキュメントはインターネットコミュニティのためのインターネットBest Current Practicesを指定し、改善のための議論と提案を要求します。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2008 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2008 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/ license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/ライセンス情報）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The User Datagram Protocol (UDP) provides a minimal message-passing transport that has no inherent congestion control mechanisms. Because congestion control is critical to the stable operation of the Internet, applications and upper-layer protocols that choose to use UDP as an Internet transport must employ mechanisms to prevent congestion collapse and to establish some degree of fairness with concurrent traffic. This document provides guidelines on the use of UDP for the designers of unicast applications and upper-layer protocols. Congestion control guidelines are a primary focus, but the document also provides guidance on other topics, including message sizes, reliability, checksums, and middlebox traversal.",
      "ja": "ユーザーデータグラムプロトコル（UDP）がない固有の輻輳制御機構を有していない最小のメッセージパッシングの輸送を提供します。輻輳制御は、インターネットの安定動作に重要であるため、アプリケーションやインターネット・トランスポートとしてUDPを使用することを選択した上位層プロトコルは、輻輳崩壊を防ぐために同時トラフィックとの公平性をある程度確立するためのメカニズムを使用しなければなりません。この文書では、ユニキャストアプリケーションと上位層プロトコルの設計者のためのUDPの使用に関するガイドラインを提供します。輻輳制御のガイドラインが主な焦点ですが、ドキュメントは、メッセージのサイズ、信頼性、チェックサム、およびミドルトラバーサルを含め、他のトピックに関するガイダンスを提供します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  5\n3.  UDP Usage Guidelines . . . . . . . . . . . . . . . . . . . . .  5\n  3.1.  Congestion Control Guidelines  . . . . . . . . . . . . . .  6\n  3.2.  Message Size Guidelines  . . . . . . . . . . . . . . . . . 11\n  3.3.  Reliability Guidelines . . . . . . . . . . . . . . . . . . 12\n  3.4.  Checksum Guidelines  . . . . . . . . . . . . . . . . . . . 13\n  3.5.  Middlebox Traversal Guidelines . . . . . . . . . . . . . . 15\n  3.6.  Programming Guidelines . . . . . . . . . . . . . . . . . . 17\n  3.7.  ICMP Guidelines  . . . . . . . . . . . . . . . . . . . . . 18\n4.  Security Considerations  . . . . . . . . . . . . . . . . . . . 19\n5.  Summary  . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n6.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 22\n7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n  7.1.  Normative References . . . . . . . . . . . . . . . . . . . 22\n  7.2.  Informative References . . . . . . . . . . . . . . . . . . 23",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The User Datagram Protocol (UDP) [RFC0768] provides a minimal, unreliable, best-effort, message-passing transport to applications and upper-layer protocols (both simply called \"applications\" in the remainder of this document). Compared to other transport protocols, UDP and its UDP-Lite variant [RFC3828] are unique in that they do not establish end-to-end connections between communicating end systems. UDP communication consequently does not incur connection establishment and teardown overheads, and there is minimal associated end system state. Because of these characteristics, UDP can offer a very efficient communication transport to some applications.",
      "ja": "ユーザデータグラムプロトコル（UDP）[RFC0768]は、アプリケーションおよび上位層プロトコル（この文書の残りの部分の両方において単に「アプリケーション」）の最小、信頼できない、ベストエフォート、メッセージパッシング輸送を提供します。他のトランスポートプロトコルと比較すると、UDPおよびそのUDP-Liteの変種[RFC3828]は、彼らがエンドシステムを通信間のエンドツーエンド接続を確立していないという点でユニークです。 UDP通信は、結果として、接続確立およびティアダウンオーバーヘッドが発生せず、最小限の関連するエンドシステムの状態があります。これらの特徴により、UDPは、いくつかのアプリケーションに非常に効率的な通信の輸送を提供することができます。"
    },
    {
      "indent": 3,
      "text": "A second unique characteristic of UDP is that it provides no inherent congestion control mechanisms. On many platforms, applications can send UDP datagrams at the line rate of the link interface, which is often much greater than the available path capacity, and doing so contributes to congestion along the path. [RFC2914] describes the best current practice for congestion control in the Internet. It identifies two major reasons why congestion control mechanisms are critical for the stable operation of the Internet:",
      "ja": "UDPの第2の特有の特徴は、それが固有の輻輳制御メカニズムを提供しないことです。多くのプラットフォームでは、アプリケーションでは、多くの場合、使用可能なパス容量よりもはるかに大きい、そしてそうすることがパスに沿って混雑に貢献するリンクインターフェイスのラインレートでUDPデータグラムを送信することができます。 [RFC2914]はインターネットにおける輻輳制御のための最良の現在のプラクティスについて説明します。これは、輻輳制御メカニズムは、インターネットの安定動作のために重要である理由を二つの主要な理由を識別します。"
    },
    {
      "indent": 3,
      "text": "1. The prevention of congestion collapse, i.e., a state where an increase in network load results in a decrease in useful work done by the network.",
      "ja": "1.輻輳崩壊、すなわち、有用な仕事の減少ネットワーク負荷結果の増加がネットワークによって行わ状態の予防に。"
    },
    {
      "indent": 3,
      "text": "2. The establishment of a degree of fairness, i.e., allowing multiple flows to share the capacity of a path reasonably equitably.",
      "ja": "2.複数のフローが合理的公平パスの容量を共有することを可能にする公平性の程度、すなわち、確立。"
    },
    {
      "indent": 3,
      "text": "Because UDP itself provides no congestion control mechanisms, it is up to the applications that use UDP for Internet communication to employ suitable mechanisms to prevent congestion collapse and establish a degree of fairness. [RFC2309] discusses the dangers of congestion-unresponsive flows and states that \"all UDP-based streaming applications should incorporate effective congestion avoidance mechanisms\". This is an important requirement, even for applications that do not use UDP for streaming. In addition, congestion-controlled transmission is of benefit to an application itself, because it can reduce self-induced packet loss, minimize retransmissions, and hence reduce delays. Congestion control is essential even at relatively slow transmission rates. For example, an application that generates five 1500-byte UDP datagrams in one second can already exceed the capacity of a 56 Kb/s path. For applications that can operate at higher, potentially unbounded data rates, congestion control becomes vital to prevent congestion collapse and establish some degree of fairness. Section 3 describes a number of simple guidelines for the designers of such applications.",
      "ja": "UDP自体は輻輳制御メカニズムを提供しないので、輻輳崩壊を防ぐと公平性の度合いを確立するための適切な機構を採用するインターネット通信にUDPを使用するアプリケーション次第です。 [RFC2309]は輻輳無応答フローの危険性を説明し、「すべてのUDPベースのストリーミングアプリケーションが有効な輻輳回避メカニズムを組み込むべきである」と述べています。これはさえストリーミングにUDPを使用しないアプリケーションのために、重要な要件です。それは、自己誘導パケット損失を減らす再送を最小化し、したがって遅延を減らすことができるので、また、輻輳制御送信は、アプリケーション自体に有益です。輻輳制御が比較的遅い伝送速度で不可欠です。例えば、1秒間に5 1500バイトUDPデータグラムを生成するアプリケーションは既に56 KB / Sパスの容量を超えることができます。高い、潜在的に無制限のデータレートで動作するアプリケーションの場合は、輻輳制御、輻輳崩壊を防ぐと公平性をある程度確立することが重要になります。第3節では、このようなアプリケーションの設計者のための簡単なガイドラインの数を示します。"
    },
    {
      "indent": 3,
      "text": "A UDP datagram is carried in a single IP packet and is hence limited to a maximum payload of 65,507 bytes for IPv4 and 65,527 bytes for IPv6. The transmission of large IP packets usually requires IP fragmentation. Fragmentation decreases communication reliability and efficiency and should be avoided. IPv6 allows the option of transmitting large packets (\"jumbograms\") without fragmentation when all link layers along the path support this [RFC2675]. Some of the guidelines in Section 3 describe how applications should determine appropriate message sizes. Other sections of this document provide guidance on reliability, checksums, and middlebox traversal.",
      "ja": "UDPデータグラムは、単一のIPパケットで運ばれ、したがって、IPv4の65507バイト、IPv6の65527バイトの最大ペイロードに限定されます。大規模なIPパケットの送信は、通常、IPフラグメンテーションが必要です。断片化は、通信の信頼性と効率を低下させ、避けるべきです。 IPv6は、パスに沿ってすべてのリンク層は、この[RFC2675]をサポートしている場合、断片化することなく、大きなパケット（「ジャンボグラム」）を送信するオプションを可能にします。第3節のガイドラインのいくつかは、アプリケーションが適切なメッセージサイズを決定する方法を説明します。このドキュメントの他のセクションでは、信頼性、チェックサム、およびミドルトラバーサル上のガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "This document provides guidelines and recommendations. Although most unicast UDP applications are expected to follow these guidelines, there do exist valid reasons why a specific application may decide not to follow a given guideline. In such cases, it is RECOMMENDED that the application designers document the rationale for their design choice in the technical specification of their application or protocol.",
      "ja": "この文書では、ガイドラインと推奨事項を提供します。ほとんどのユニキャストUDPアプリケーションがこれらのガイドラインに従うことが期待されていますが、特定のアプリケーションが特定のガイドラインに従うことを決めるかもしれない理由を正当な理由が存在します。このような場合には、アプリケーション設計者が自分のアプリケーションやプロトコルの技術仕様での設計上の選択の根拠を文書化することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "This document provides guidelines to designers of applications that use UDP for unicast transmission, which is the most common case. Specialized classes of applications use UDP for IP multicast [RFC1112], broadcast [RFC0919], or anycast [RFC1546] transmissions. The design of such specialized applications requires expertise that goes beyond the simple, unicast-specific guidelines given in this document. Multicast and broadcast senders may transmit to multiple receivers across potentially very heterogeneous paths at the same time, which significantly complicates congestion control, flow control, and reliability mechanisms. The IETF has defined a reliable multicast framework [RFC3048] and several building blocks to aid the designers of multicast applications, such as [RFC3738] or [RFC4654]. Anycast senders must be aware that successive messages sent to the same anycast IP address may be delivered to different anycast nodes, i.e., arrive at different locations in the topology. It is not intended that the guidelines in this document apply to multicast, broadcast, or anycast applications that use UDP.",
      "ja": "この文書では、最も一般的なケースであるユニキャスト送信、UDPを使用するアプリケーションの設計者にガイドラインを提供します。専門[RFC0919]ブロードキャストアプリケーションのクラスのIPマルチキャスト[RFC1112]のためにUDPを使用し、またはエニーキャスト[RFC1546]トランスミッション。そのような特殊なアプリケーションの設計は、本文書に与えられたシンプルな、ユニ​​キャスト固有のガイドラインを超えて専門知識を必要とします。マルチキャスト及びブロードキャスト送信者が著しく輻輳制御、フロー制御、および信頼性の機構が複雑と同時に、潜在的に非常に不均質経路上の複数の受信機に送信することができます。 IETFは、[RFC3738]または[RFC4654]などのマルチキャストアプリケーションの設計者を支援するために信頼性の高いマルチキャストフレームワーク[RFC3048]及びいくつかのビルディングブロックを定義しています。エニーキャスト送信者が同一のエニーキャストIPアドレスに送信された連続したメッセージが異なるエニーキャストノードに配信されても​​よいことに注意しなければならない、すなわち、トポロジ内の異なる位置に到着します。この文書のガイドラインは、マルチキャスト、ブロードキャスト、またはUDPを使用するエニーキャストアプリケーションに適用することを意図していません。"
    },
    {
      "indent": 3,
      "text": "Finally, although this document specifically refers to unicast applications that use UDP, the spirit of some of its guidelines also applies to other message-passing applications and protocols (specifically on the topics of congestion control, message sizes, and reliability). Examples include signaling or control applications that choose to run directly over IP by registering their own IP protocol number with IANA. This document may provide useful background reading to the designers of such applications and protocols.",
      "ja": "この文書は、具体的にUDPを使用するユニキャストアプリケーションに言及しているが、最終的に、そのガイドラインの一部の精神は、他のメッセージパッシングアプリケーションとプロトコル（具体的には輻輳制御のトピックに関する、メッセージサイズ、および信頼性）に適用されます。例としては、IANAで、独自のIPプロトコル番号を登録することにより、IP上で直接実行することを選択したシグナリングまたは制御アプリケーションが含まれます。この文書では、このようなアプリケーションとプロトコルの設計者に読んで有益な背景を提供することができます。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますBCP 14、RFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. UDP Usage Guidelines",
      "section_title": true,
      "ja": "3. UDP使用上のガイドライン"
    },
    {
      "indent": 3,
      "text": "Internet paths can have widely varying characteristics, including transmission delays, available bandwidths, congestion levels, reordering probabilities, supported message sizes, or loss rates. Furthermore, the same Internet path can have very different conditions over time. Consequently, applications that may be used on the Internet MUST NOT make assumptions about specific path characteristics. They MUST instead use mechanisms that let them operate safely under very different path conditions. Typically, this requires conservatively probing the current conditions of the Internet path they communicate over to establish a transmission behavior that it can sustain and that is reasonably fair to other traffic sharing the path.",
      "ja": "インターネットパスは伝送遅延、利用可能な帯域幅、渋滞度、並び替え確率、サポートされているメッセージのサイズ、又は損失率を含む多種多様な特性を有することができます。さらに、同じインターネットパスは、時間をかけて非常に異なる条件を持つことができます。そのため、インターネット上で使用できるアプリケーションは、特定のパスの特性についての仮定をしてはなりません。彼らは代わりに、彼らは非常に異なるパス条件の下で安全に動作させメカニズムを使用しなければなりません。通常、これは控えめに、彼らはそれを維持することができ、送信動作を確立する上で通信インターネットパスの現在の状況を探査する必要があり、それはパスを共有する他のトラフィックに合理的に公平です。"
    },
    {
      "indent": 3,
      "text": "These mechanisms are difficult to implement correctly. For most applications, the use of one of the existing IETF transport protocols is the simplest method of acquiring the required mechanisms. Consequently, the RECOMMENDED alternative to the UDP usage described in the remainder of this section is the use of an IETF transport protocol such as TCP [RFC0793], Stream Control Transmission Protocol (SCTP) [RFC4960], and SCTP Partial Reliability Extension (SCTP-PR) [RFC3758], or Datagram Congestion Control Protocol (DCCP) [RFC4340] with its different congestion control types [RFC4341][RFC4342][CCID4].",
      "ja": "これらのメカニズムは正確に実施することが困難です。ほとんどのアプリケーションでは、既存のIETFのトランスポートプロトコルの1つの使用は、必要なメカニズムを取得する最も簡単な方法です。したがって、このセクションの残りで説明したUDPの使用することを推奨代替TCPなどIETFトランスポートプロトコル[RFC0793]を使用することで、ストリーム制御伝送プロトコル（SCTP）[RFC4960]、およびSCTP部分信頼性拡張（SCTP- PR）[RFC3758]、またはデータグラム輻輳制御プロトコル（DCCP）は異なる輻輳制御型と[RFC4340]、[RFC4341]、[RFC4342] [CCID4]。"
    },
    {
      "indent": 3,
      "text": "If used correctly, these more fully-featured transport protocols are not as \"heavyweight\" as often claimed. For example, the TCP algorithms have been continuously improved over decades, and have reached a level of efficiency and correctness that custom application-layer mechanisms will struggle to easily duplicate. In addition, many TCP implementations allow connections to be tuned by an application to its purposes. For example, TCP's \"Nagle\" algorithm [RFC0896] can be disabled, improving communication latency at the expense of more frequent -- but still congestion-controlled -- packet transmissions. Another example is the TCP SYN cookie mechanism [RFC4987], which is available on many platforms. TCP with SYN cookies does not require a server to maintain per-connection state until the connection is established. TCP also requires the end that closes a connection to maintain the TIME-WAIT state that prevents delayed segments from one connection instance from interfering with a later one. Applications that are aware of and designed for this behavior can shift maintenance of the TIME-WAIT state to conserve resources by controlling which end closes a TCP connection [FABER]. Finally, TCP's built-in capacity-probing and awareness of the maximum transmission unit supported by the path (PMTU) results in efficient data transmission that quickly compensates for the initial connection setup delay, in the case of transfers that exchange more than a few segments.",
      "ja": "正しく使用した場合、これらのより完全な機能を備えたトランスポートプロトコルは、多くの場合、記載の「ヘビー級」としてではありません。例えば、TCPアルゴリズムは、連続的に数十年にわたって改善された、カスタムアプリケーション層のメカニズムを簡単複製に苦労します効率と正確さのレベルに達しています。また、多くのTCP実装は、接続がその目的に適用することによって調整することを可能にします。例えば、TCPの「ネーグル」アルゴリズム[RFC0896]はより頻繁に犠牲に通信遅延を改善し、無効にすることができます - しかし、まだ輻輳制御 - パケット送信。別の例は、多くのプラットフォームで利用可能であるTCP SYNクッキーメカニズム[RFC4987]、です。 SYNクッキーとのTCP接続が確立されるまで、接続ごとの状態を維持するためにサーバを必要としません。 TCPはまた、後で一つと干渉つの接続インスタンスからの遅延セグメントを防止TIME-WAIT状態を維持するために、接続を閉じ端を必要とします。意識して、この動作のために設計されたアプリケーションは、TCPコネクション[FABER]を閉じる終了制御することにより、リソースを節約するためにTIME-WAIT状態の維持をシフトすることができます。最後に、TCPの内蔵容量プロービングかつ迅速に少数のセグメントよりも交換転送の場合には、最初の接続セットアップ遅延を補償する効率的なデータ伝送における経路（PMTU）の結果によってサポートされる最大伝送ユニットの意識。"
    },
    {
      "indent": 0,
      "text": "3.1. Congestion Control Guidelines",
      "section_title": true,
      "ja": "3.1. 輻輳制御のガイドライン"
    },
    {
      "indent": 3,
      "text": "If an application or upper-layer protocol chooses not to use a congestion-controlled transport protocol, it SHOULD control the rate at which it sends UDP datagrams to a destination host, in order to fulfill the requirements of [RFC2914]. It is important to stress that an application SHOULD perform congestion control over all UDP traffic it sends to a destination, independently from how it generates this traffic. For example, an application that forks multiple worker processes or otherwise uses multiple sockets to generate UDP datagrams SHOULD perform congestion control over the aggregate traffic.",
      "ja": "アプリケーションまたは上位層プロトコルは、輻輳制御トランスポートプロトコルを使用しないことを選択した場合、それは[RFC2914]の要件を満たすために、宛先ホストにUDPデータグラムを送信する速度を制御すべきです。アプリケーションが、それがこのトラフィックを生成する方法とは独立して、宛先に送信するすべてのUDPトラフィック上で輻輳制御を実行すべきであることを強調することが重要です。例えば、複数のワーカープロセスをフォークまたはその他のUDPデータグラムを生成するために複数のソケットを使用するアプリケーションは、集約トラフィック上輻輳制御を実行すべきです。"
    },
    {
      "indent": 3,
      "text": "Several approaches to perform congestion control are discussed in the remainder of this section. Not all approaches discussed below are appropriate for all UDP-transmitting applications. Section 3.1.1 discusses congestion control options for applications that perform bulk transfers over UDP. Such applications can employ schemes that sample the path over several subsequent RTTs during which data is exchanged, in order to determine a sending rate that the path at its current load can support. Other applications only exchange a few UDP datagrams with a destination. Section 3.1.2 discusses congestion control options for such \"low data-volume\" applications. Because they typically do not transmit enough data to iteratively sample the path to determine a safe sending rate, they need to employ different kinds of congestion control mechanisms. Section 3.1.3 discusses congestion control considerations when UDP is used as a tunneling protocol.",
      "ja": "輻輳制御を実行するためのいくつかのアプローチは、このセクションの残りの部分に記載されています。以下で説明されていないすべてのアプローチは、すべてのUDP-送信するアプリケーションに適しています。 3.1.1項は、UDP上でバルク転送を実行するアプリケーションのための輻輳制御オプションについて説明します。そのようなアプリケーションは、現在の負荷に経路がサポート可能送信レートを決定するために、データが交換される間に、いくつかの後続のRTT上に経路をサンプリング方式を採用することができます。他のアプリケーションは唯一の目的地で少数のUDPデータグラムを交換します。第3.1.2項は、そのような「低データ・ボリューム」のアプリケーションのための輻輳制御オプションについて説明します。彼らは通常、反復的に安全な送信レートを決定するために、パスをサンプリングするのに十分なデータを送信することはありませんので、彼らは輻輳制御メカニズムの異なる種類を採用する必要があります。 UDPは、トンネリングプロトコルとして使用されている場合、セクション3.1.3には、輻輳制御の考慮事項について説明します。"
    },
    {
      "indent": 3,
      "text": "It is important to note that congestion control should not be viewed as an add-on to a finished application. Many of the mechanisms discussed in the guidelines below require application support to operate correctly. Application designers need to consider congestion control throughout the design of their application, similar to how they consider security aspects throughout the design process.",
      "ja": "輻輳制御がアドオン完成したアプリケーションへと見るべきではないことに注意することが重要です。以下のガイドラインで議論メカニズムの多くは、正常に動作するアプリケーションのサポートを必要とします。アプリケーション設計者は、彼らが設計プロセス全体でセキュリティ面を考慮してどのように類似し、そのアプリケーションの設計、全体の輻輳制御を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "In the past, the IETF has also investigated integrated congestion control mechanisms that act on the traffic aggregate between two hosts, i.e., a framework such as the Congestion Manager [RFC3124],",
      "ja": "過去には、IETFはまた、2つのホストは、このような輻輳マネージャとして、すなわち、フレームワーク[RFC3124]の間のトラフィック集合に作用する統合された輻輳制御メカニズムを調査しました、"
    },
    {
      "indent": 3,
      "text": "where active sessions may share current congestion information in a way that is independent of the transport protocol. Such mechanisms have currently failed to see deployment, but would otherwise simplify the design of congestion control mechanisms for UDP sessions, so that they fulfill the requirements in [RFC2914].",
      "ja": "ここで、アクティブなセッションは、トランスポートプロトコルとは無関係であるように、現在の渋滞情報を共有することができます。このようなメカニズムは、現在展開を見ることができなかったが、彼らは[RFC2914]で要件を満たすように、それ以外の場合は、UDPセッションのための輻輳制御機構の設計を簡素化します。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Bulk Transfer Applications",
      "section_title": true,
      "ja": "3.1.1. バルク転送アプリケーション"
    },
    {
      "indent": 3,
      "text": "Applications that perform bulk transmission of data to a peer over UDP, i.e., applications that exchange more than a small number of UDP datagrams per RTT, SHOULD implement TCP-Friendly Rate Control (TFRC) [RFC5348], window-based, TCP-like congestion control, or otherwise ensure that the application complies with the congestion control principles.",
      "ja": "UDP上のピアへのデータの一括送信を行うアプリケーションは、すなわち、RTTあたりのUDPデータグラムの小さな数よりも多くを交換するアプリケーションは、TCPフレンドリーレート制御（TFRC）[RFC5348]、ウィンドウベースを実装する必要があり、TCPのような輻輳制御、またはその他のアプリケーションは、輻輳制御の原則に準拠していることを確認してください。"
    },
    {
      "indent": 3,
      "text": "TFRC has been designed to provide both congestion control and fairness in a way that is compatible with the IETF's other transport protocols. If an application implements TFRC, it need not follow the remaining guidelines in Section 3.1.1, because TFRC already addresses them, but SHOULD still follow the remaining guidelines in the subsequent subsections of Section 3.",
      "ja": "TFRCは、IETFの他のトランスポートプロトコルと互換性のある方法で輻輳制御と公平性の両方を提供するように設計されています。アプリケーションは、TFRCを実装している場合、それはTFRCは、すでにそれらを解決するため、3.1.1項の残りのガイドラインに従う必要はないが、それでも第3節の以降のサブセクションの残りのガイドラインに従ってください。"
    },
    {
      "indent": 3,
      "text": "Bulk transfer applications that choose not to implement TFRC or TCP-like windowing SHOULD implement a congestion control scheme that results in bandwidth use that competes fairly with TCP within an order of magnitude. Section 2 of [RFC3551] suggests that applications SHOULD monitor the packet loss rate to ensure that it is within acceptable parameters. Packet loss is considered acceptable if a TCP flow across the same network path under the same network conditions would achieve an average throughput, measured on a reasonable timescale, that is not less than that of the UDP flow. The comparison to TCP cannot be specified exactly, but is intended as an \"order-of-magnitude\" comparison in timescale and throughput.",
      "ja": "TFRCまたはTCPのようなウィンドウを実装しないことを選択したバルク転送アプリケーションは、桁以内かなりTCPと競合する帯域幅を使用することになる輻輳制御方式を実装する必要があります。 [RFC3551]のセクション2は、アプリケーションが、それが許容パラメータの範囲内にあることを保証するためにパケット損失率を監視すべきであることを示唆しています。同じネットワーク条件下で同じネットワーク・パスを横切るTCPフローは、UDPフローのそれ以上である合理的なタイムスケールで測定した平均スループットを達成ならばパケットロスが許容されると考えられます。 TCPとの比較を正確に特定することはできないが、タイムスケールとスループットの「桁違い」の比較として意図されています。"
    },
    {
      "indent": 3,
      "text": "Finally, some bulk transfer applications may choose not to implement any congestion control mechanism and instead rely on transmitting across reserved path capacity. This might be an acceptable choice for a subset of restricted networking environments, but is by no means a safe practice for operation in the Internet. When the UDP traffic of such applications leaks out on unprovisioned Internet paths, it can significantly degrade the performance of other traffic sharing the path and even result in congestion collapse. Applications that support an uncontrolled or unadaptive transmission behavior SHOULD NOT do so by default and SHOULD instead require users to explicitly enable this mode of operation.",
      "ja": "最後に、いくつかのバルク転送アプリケーションは、任意の輻輳制御機構を実装し、代わりに、予約パス能力を横切って伝達に依存しないように選択することができます。これは、制限されたネットワーク環境のサブセットのために許容可能な選択肢となりますが、インターネットでの動作のための安全な練習を意味していないことであるかもしれません。このようなアプリケーションのUDPトラフィックがプロビジョニングされていないインターネットの経路上で漏れ出した場合、それが大幅にパスを共有する他のトラフィックのパフォーマンスが低下しても、輻輳崩壊につながることができます。制御不能またはunadaptive伝送の動作をサポートするアプリケーションは、デフォルトでは、そうすべきではなく、代わりに、明示的にこの動作モードを有効にするには、ユーザーに要求すべきです。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Low Data-Volume Applications",
      "section_title": true,
      "ja": "3.1.2. 低いデータ容量アプリケーション"
    },
    {
      "indent": 3,
      "text": "When applications that at any time exchange only a small number of UDP datagrams with a destination implement TFRC or one of the other congestion control schemes in Section 3.1.1, the network sees little benefit, because those mechanisms perform congestion control in a way that is only effective for longer transmissions.",
      "ja": "これらのメカニズムがあるようにして輻輳制御を行うので、いつでも交換で宛先とUDPデータグラムのほんの数はTFRCを実装または3.1.1の他の輻輳制御方式の一アプリケーションは、ネットワークは、少しの利益を見たとき長い伝送のためにのみ有効。"
    },
    {
      "indent": 3,
      "text": "Applications that at any time exchange only a small number of UDP datagrams with a destination SHOULD still control their transmission behavior by not sending on average more than one UDP datagram per round-trip time (RTT) to a destination. Similar to the recommendation in [RFC1536], an application SHOULD maintain an estimate of the RTT for any destination with which it communicates. Applications SHOULD implement the algorithm specified in [RFC2988] to compute a smoothed RTT (SRTT) estimate. They SHOULD also detect packet loss and exponentially back-off their retransmission timer when a loss event occurs. When implementing this scheme, applications need to choose a sensible initial value for the RTT. This value SHOULD generally be as conservative as possible for the given application. TCP uses an initial value of 3 seconds [RFC2988], which is also RECOMMENDED as an initial value for UDP applications. SIP [RFC3261] and GIST [GIST] use an initial value of 500 ms, and initial timeouts that are shorter than this are likely problematic in many cases. It is also important to note that the initial timeout is not the maximum possible timeout -- the RECOMMENDED algorithm in [RFC2988] yields timeout values after a series of losses that are much longer than the initial value.",
      "ja": "いつでも交換で先とのUDPデータグラムのほんの数はまだ先に平均でラウンドトリップ時間（RTT）ごとに複数のUDPデータグラムを送信しないことにより、それらの送信動作を制御する必要がありますアプリケーション。 [RFC1536]で推薦と同様に、アプリケーションは、それが通信する任意の宛先のRTTの推定値を維持しなければなりません。アプリケーションは、平滑化RTT（SRTT）推定値を計算するために[RFC2988]で指定されたアルゴリズムを実装する必要があります。彼らはまた、パケット損失を検出し、指数関数的バックオフその再送タイマを損失事象が発生したときにすべきです。この方式を実装する場合、アプリケーションは、RTTのための賢明な初期値を選択する必要があります。この値は、一般に、所与の用途のために可能な限り保存的であるべきです。 TCPもUDPアプリケーションのための初期値として推奨されて3秒[RFC2988]の初期値を、使用しています。 SIP [RFC3261]及びGISTは[GIST] 500ミリ秒の初期値、これは多くの場合、問題可能性があるよりも短い初期タイムアウトを使用します。最初のタイムアウトが可能な最大タイムアウトではないことに注意することも重要である -  [RFC2988]で推奨アルゴリズムは、はるかに長い初期値よりも損失の一連の後にタイムアウト値が得られます。"
    },
    {
      "indent": 3,
      "text": "Some applications cannot maintain a reliable RTT estimate for a destination. The first case is that of applications that exchange too few UDP datagrams with a peer to establish a statistically accurate RTT estimate. Such applications MAY use a predetermined transmission interval that is exponentially backed-off when packets are lost. TCP uses an initial value of 3 seconds [RFC2988], which is also RECOMMENDED as an initial value for UDP applications. SIP [RFC3261] and GIST [GIST] use an interval of 500 ms, and shorter values are likely problematic in many cases. As in the previous case, note that the initial timeout is not the maximum possible timeout.",
      "ja": "一部のアプリケーションでは、目的地のための信頼性の高いRTT推定値を維持することはできません。最初のケースでは、統計学的に正確なRTT推定値を確立するためにピアと少なすぎるUDPデータグラムを交換するアプリケーションのことです。そのようなアプリケーションは、指数関数的バックオフされたパケットが失われた場合に所定の送信間隔を使用するかもしれません。 TCPもUDPアプリケーションのための初期値として推奨されて3秒[RFC2988]の初期値を、使用しています。 SIP [RFC3261]及びGISTは[GIST] 500ミリ秒の間隔を使用し、より短い値は、多くの場合、可能性が問題となります。前の場合のように、最初のタイムアウトが可能な最大タイムアウトではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "A second class of applications cannot maintain an RTT estimate for a destination, because the destination does not send return traffic. Such applications SHOULD NOT send more than one UDP datagram every 3 seconds, and SHOULD use an even less aggressive rate when possible. The 3-second interval was chosen based on TCP's retransmission timeout when the RTT is unknown [RFC2988], and shorter values are likely problematic in many cases. Note that the sending rate in this case must be more conservative than in the two previous cases, because the lack of return traffic prevents the detection of packet loss, i.e., congestion events, and the application therefore cannot perform exponential back-off to reduce load.",
      "ja": "宛先はリターントラフィックを送信しないので、アプリケーションの第二のクラスは、宛先に対するRTT推定値を維持することはできません。このようなアプリケーションは、複数のUDPデータグラムごとに3秒を送るべきではありませんし、可能な場合でも、あまり積極的でレートを使用すべきです。 RTTは不明[RFC2988]があるときに3秒の間隔は、TCPの再送タイムアウトに基づいて選ばれた、短い値は、多くの場合、可能性が問題となっています。リターントラフィックの欠如は、パケットロスの検出を防止するので、この場合の送信レートは、前の2つのケースに比べて、より保守的でなければならないことに注意してください、すなわち、輻輳イベント、およびアプリケーションは、そのための負荷を軽減するために、指数バックオフを実行することはできません。"
    },
    {
      "indent": 3,
      "text": "Applications that communicate bidirectionally SHOULD employ congestion control for both directions of the communication. For example, for a client-server, request-response-style application, clients SHOULD congestion-control their request transmission to a server, and the server SHOULD congestion-control its responses to the clients. Congestion in the forward and reverse direction is uncorrelated, and an application SHOULD either independently detect and respond to congestion along both directions, or limit new and retransmitted requests based on acknowledged responses across the entire round-trip path.",
      "ja": "双方向通信アプリケーションは、通信の両方向のための輻輳制御を採用するべきです。例えば、クライアント・サーバー、リクエスト・レスポンス・スタイルのアプリケーションのために、クライアントはサーバーへのリクエスト送信を混雑制御する必要があり、サーバはクライアントへの応答を輻輳制御する必要があります。前方および逆方向の渋滞は無相関であり、アプリケーションは単独検出し、両方の方向に沿って混雑への対応、または全体の往復路を挟んで認め応答に基づいて、新たな再送要求を制限する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.3. UDP Tunnels",
      "section_title": true,
      "ja": "3.1.3.  UDPトンネル"
    },
    {
      "indent": 3,
      "text": "One increasingly popular use of UDP is as a tunneling protocol, where a tunnel endpoint encapsulates the packets of another protocol inside UDP datagrams and transmits them to another tunnel endpoint, which decapsulates the UDP datagrams and forwards the original packets contained in the payload. Tunnels establish virtual links that appear to directly connect locations that are distant in the physical Internet topology and can be used to create virtual (private) networks. Using UDP as a tunneling protocol is attractive when the payload protocol is not supported by middleboxes that may exist along the path, because many middleboxes support transmission using UDP.",
      "ja": "UDPの一のますます普及使用は、トンネルエンドポイントは、UDPデータグラム内の別のプロトコルのパケットをカプセル化し、UDPデータグラムのカプセル化を解除し、ペイロードに含まれる元のパケットを転送する別のトンネルエンドポイントに送信するトンネリングプロトコルの通りです。トンネルは、直接物理的なインターネット・トポロジーで離れていると仮想（プライベート）ネットワークを作成するために使用することができる場所を接続するために表示される仮想リンクを確立します。ペイロードプロトコルは経路に沿って存在し得る中間装置によってサポートされていない場合、多くの中間装置は、UDPを用いて送信をサポートするため、トンネリングプロトコルとしてUDPを使用することは、魅力的です。"
    },
    {
      "indent": 3,
      "text": "Well-implemented tunnels are generally invisible to the endpoints that happen to transmit over a path that includes tunneled links. On the other hand, to the routers along the path of a UDP tunnel, i.e., the routers between the two tunnel endpoints, the traffic that a UDP tunnel generates is a regular UDP flow, and the encapsulator and decapsulator appear as regular UDP-sending and -receiving applications. Because other flows can share the path with one or more UDP tunnels, congestion control needs to be considered.",
      "ja": "まあ、実装のトンネルは、トンネルのリンクを含むパスを経由送信するために起こるのエンドポイントに、一般的には見えません。一方、UDPトンネルの経路に沿ったルータに、すなわち、2つのトンネルエンドポイント間のルータは、UDPトンネルが生成するトラフィックは、通常のUDPフローであり、カプセル化およびカプセル開放装置は、通常のUDP-送信として表示しますそして、アプリケーションを受入れ。他のフローは、1つまたは複数のUDPトンネルでパスを共有することができるので、輻輳制御を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Two factors determine whether a UDP tunnel needs to employ specific congestion control mechanisms -- first, whether the payload traffic is IP-based; second, whether the tunneling scheme generates UDP traffic at a volume that corresponds to the volume of payload traffic carried within the tunnel.",
      "ja": "二つの要因がUDPトンネルが特定の輻輳制御機構を採用する必要があるかどうかを決定する - 第一、ペイロードトラフィックはIPベースであるかどうか。第二、トンネリング方式は、トンネル内で搬送されるペイロードトラフィックの量に相当する量でUDPトラフィックを生成するかどうか。"
    },
    {
      "indent": 3,
      "text": "IP-based traffic is generally assumed to be congestion-controlled, i.e., it is assumed that the transport protocols generating IP-based traffic at the sender already employ mechanisms that are sufficient to address congestion on the path. Consequently, a tunnel carrying",
      "ja": "IPベースのトラフィックは、一般に輻輳制御であると仮定され、すなわち、送信者にIPベースのトラフィックを生成するトランスポート・プロトコルが既に経路上の混雑に対処するのに十分なメカニズムを採用しているものとします。その結果、トンネルは、搬送します"
    },
    {
      "indent": 3,
      "text": "IP-based traffic should already interact appropriately with other traffic sharing the path, and specific congestion control mechanisms for the tunnel are not necessary.",
      "ja": "IPベースのトラフィックは既にパスを共有する他のトラフィックと適切に相互作用する必要があり、トンネルのための特定の輻輳制御機構は不要です。"
    },
    {
      "indent": 3,
      "text": "However, if the IP traffic in the tunnel is known to not be congestion-controlled, additional measures are RECOMMENDED in order to limit the impact of the tunneled traffic on other traffic sharing the path.",
      "ja": "トンネル内のIPトラフィックが輻輳制御できないことが知られている場合には、追加的な措置がパスを共有する他のトラフィックにトンネルトラフィックの影響を制限するために推奨されます。"
    },
    {
      "indent": 3,
      "text": "The following guidelines define these possible cases in more detail:",
      "ja": "次のガイドラインは、より詳細にこれらの可能なケースを定義します。"
    },
    {
      "indent": 3,
      "text": "1. A tunnel generates UDP traffic at a volume that corresponds to the volume of payload traffic, and the payload traffic is IP-based and congestion-controlled.",
      "ja": "1.トンネルは、ペイロードトラフィックの量に相当する量でUDPトラフィックを生成し、ペイロードトラフィックは、IPベースの輻輳制御です。"
    },
    {
      "indent": 7,
      "text": "This is arguably the most common case for Internet tunnels.  In\nthis case, the UDP tunnel SHOULD NOT employ its own congestion\ncontrol mechanism, because congestion losses of tunneled traffic\nwill already trigger an appropriate congestion response at the\noriginal senders of the tunneled traffic.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Note that this guideline is built on the assumption that most IP-based communication is congestion-controlled. If a UDP tunnel is used for IP-based traffic that is known to not be congestion-controlled, the next set of guidelines applies.",
      "ja": "このガイドラインは、ほとんどのIPベースの通信が輻輳制御されていることを前提に構築されていることに注意してください。 UDPトンネルが輻輳制御されていないことが知られているIPベースのトラフィックに使用されている場合は、ガイドラインの次のセットが適用されます。"
    },
    {
      "indent": 3,
      "text": "2. A tunnel generates UDP traffic at a volume that corresponds to the volume of payload traffic, and the payload traffic is not known to be IP-based, or is known to be IP-based but not congestion-controlled.",
      "ja": "2.トンネルがペイロードトラフィックの量に相当する量でUDPトラフィックを生成し、ペイロードトラフィックはIPベースであることが知られていない、または輻輳制御IPベースであることが知られていないが。"
    },
    {
      "indent": 7,
      "text": "This can be the case, for example, when some link-layer protocols\nare encapsulated within UDP (but not all link-layer protocols;\nsome are congestion-controlled).  Because it is not known that\ncongestion losses of tunneled non-IP traffic will trigger an\nappropriate congestion response at the senders, the UDP tunnel\nSHOULD employ an appropriate congestion control mechanism.\nBecause tunnels are usually bulk-transfer applications as far as\nthe intermediate routers are concerned, the guidelines in\nSection 3.1.1 apply.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. A tunnel generates UDP traffic at a volume that does not correspond to the volume of payload traffic, independent of whether the payload traffic is IP-based or congestion-controlled.",
      "ja": "3.トンネルがペイロードトラフィックはIPベースであるかどうかとは無関係に又は輻輳制御、ペイロードトラフィックの量に対応していないボリュームでUDPトラフィックを生成します。"
    },
    {
      "indent": 7,
      "text": "Examples of this class include UDP tunnels that send at a\nconstant rate, increase their transmission rates under loss, for\nexample, due to increasing redundancy when Forward Error",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Correction is used, or are otherwise constrained in their transmission behavior. These specialized uses of UDP for tunneling go beyond the scope of the general guidelines given in this document. The implementer of such specialized tunnels SHOULD carefully consider congestion control in the design of their tunneling mechanism.",
      "ja": "補正が使用されている、あるいはそれらの送信動作に制約されています。トンネリングのためのUDPのこれらの特殊な使用法は、本文書に与えられた一般的なガイドラインの範囲を超えて行きます。そのような専門的なトンネルの実装は慎重にトンネリングメカニズムの設計における輻輳制御を考慮すべきです。"
    },
    {
      "indent": 3,
      "text": "Designing a tunneling mechanism requires significantly more expertise than needed for many other UDP applications, because tunnels virtualize lower-layer components of the Internet, and the virtualized components need to correctly interact with the infrastructure at that layer. This document only touches upon the congestion control considerations for implementing UDP tunnels; a discussion of other required tunneling behavior is out of scope.",
      "ja": "トンネルは、インターネットの下層コンポーネントを仮想化し、仮想化されたコンポーネントが正しくその層でのインフラストラクチャと対話する必要があるため、トンネリングメカニズムを設計することは、他の多くのUDPアプリケーションに必要なよりもかなり多くの専門知識が必要。この文書では、唯一のUDPトンネルを実装するための輻輳制御考慮に触れます。他の必要なトンネルの挙動の議論は範囲外です。"
    },
    {
      "indent": 0,
      "text": "3.2. Message Size Guidelines",
      "section_title": true,
      "ja": "3.2. メッセージサイズのガイドライン"
    },
    {
      "indent": 3,
      "text": "IP fragmentation lowers the efficiency and reliability of Internet communication. The loss of a single fragment results in the loss of an entire fragmented packet, because even if all other fragments are received correctly, the original packet cannot be reassembled and delivered. This fundamental issue with fragmentation exists for both IPv4 and IPv6. In addition, some network address translators (NATs) and firewalls drop IP fragments. The network address translation performed by a NAT only operates on complete IP packets, and some firewall policies also require inspection of complete IP packets. Even with these being the case, some NATs and firewalls simply do not implement the necessary reassembly functionality, and instead choose to drop all fragments. Finally, [RFC4963] documents other issues specific to IPv4 fragmentation.",
      "ja": "IPフラグメンテーションは、インターネット通信の効率と信頼性を低下させます。全フラグメントパケットの損失に単一フラグメント結果の損失、他のすべてのフラグメントが正しく受信された場合でも、元のパケットを再組み立てして配信することができないからです。フラグメンテーションとこの根本的な問題は、IPv4とIPv6の両方のために存在します。また、一部のネットワークアドレス変換（NAT）とファイアウォールは、IPフラグメントをドロップします。 NATが実行するネットワークアドレス変換は、唯一の完全なIPパケットで動作し、一部のファイアウォールポリシーは、完全なIPパケットの検査を必要とします。でも、これらはケースであることに、いくつかのNATやファイアウォールは、単純に、必要な再構築機能を実装し、代わりにすべてのフラグメントをドロップすることを選択しないでください。最後に、[RFC4963]はIPv4のフラグメンテーションに固有の他の問題に関して説明しています。"
    },
    {
      "indent": 3,
      "text": "Due to these issues, an application SHOULD NOT send UDP datagrams that result in IP packets that exceed the MTU of the path to the destination. Consequently, an application SHOULD either use the path MTU information provided by the IP layer or implement path MTU discovery itself [RFC1191][RFC1981][RFC4821] to determine whether the path to a destination will support its desired message size without fragmentation.",
      "ja": "これらの問題に起因して、アプリケーションが宛先へのパスのMTUを超えるIPパケットにつながるUDPデータグラムを送るべきではありません。したがって、アプリケーションは、IP層によって提供される経路MTU情報を使用するか、または宛先へのパスが断片化することなく、その所望のメッセージサイズをサポートするかどうかを決定するために、パスMTUディスカバリ自体[RFC1191]、[RFC1981]、[RFC4821]を実装すべきであるいずれか。"
    },
    {
      "indent": 3,
      "text": "Applications that do not follow this recommendation to do PMTU discovery SHOULD still avoid sending UDP datagrams that would result in IP packets that exceed the path MTU. Because the actual path MTU is unknown, such applications SHOULD fall back to sending messages that are shorter than the default effective MTU for sending (EMTU_S in [RFC1122]). For IPv4, EMTU_S is the smaller of 576 bytes and the first-hop MTU [RFC1122]. For IPv6, EMTU_S is 1280 bytes [RFC2460]. The effective PMTU for a directly connected destination (with no routers on the path) is the configured interface MTU, which could be less than the maximum link payload size. Transmission of minimum-sized UDP datagrams is inefficient over paths that support a larger PMTU, which is a second reason to implement PMTU discovery.",
      "ja": "PMTU検出を行うには、この勧告に従わないアプリケーションは、まだパスMTUを超えるIPパケットにつながるUDPデータグラムを送信することは避けてください。実際のパスMTUが不明であるため、このようなアプリケーションは、（[RFC1122]でEMTU_S）を送信するためのデフォルトの有効MTUよりも短いメッセージの送信にフォールバックすべきです。 IPv4の場合、EMTU_Sは576バイトと最初のホップMTU [RFC1122]の小さい方です。 IPv6の場合、EMTU_S 1280バイト[RFC2460]です。 （パスにはルータで）直接接続された宛先の有効なPMTUは、最大リンクペイロードサイズよりも小さい可能性が設定されたインターフェイスMTUです。最小サイズのUDPデータグラムの送信は、PMTUディスカバリを実装するための第2の理由は、より大きなPMTUをサポートする経路上に非効率的です。"
    },
    {
      "indent": 3,
      "text": "To determine an appropriate UDP payload size, applications MUST subtract the size of the IP header (which includes any IPv4 optional headers or IPv6 extension headers) as well as the length of the UDP header (8 bytes) from the PMTU size. This size, known as the MMS_S, can be obtained from the TCP/IP stack [RFC1122].",
      "ja": "適切なUDPペイロードサイズを決定するために、アプリケーションは、（任意のIPv4オプションヘッダまたはIPv6拡張ヘッダを含む）IPヘッダのサイズならびにPMTUサイズからUDPヘッダ（8バイト）の長さを減算しなければなりません。 MMS_Sとして知られるこのサイズは、TCP / IPスタック[RFC1122]から得ることができます。"
    },
    {
      "indent": 3,
      "text": "Applications that do not send messages that exceed the effective PMTU of IPv4 or IPv6 need not implement any of the above mechanisms. Note that the presence of tunnels can cause an additional reduction of the effective PMTU, so implementing PMTU discovery may be beneficial.",
      "ja": "IPv4またはIPv6の有効PMTUを超えるメッセージを送信しないアプリケーションでは、上記のメカニズムのいずれかを実装する必要はありません。トンネルの存在が効果的なPMTUの追加削減を引き起こす可能性があることに注意してくださいので、PMTU検出を実装することは有益であるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Applications that fragment an application-layer message into multiple UDP datagrams SHOULD perform this fragmentation so that each datagram can be received independently, and be independently retransmitted in the case where an application implements its own reliability mechanisms.",
      "ja": "複数のUDPデータグラムにアプリケーション層メッセージを断片化アプリケーションは、各データグラムは、独立して受信することができるように、この断片化を実行する必要があり、かつ独立して、アプリケーションが独自の信頼性メカニズムを実装する場合に再送されます。"
    },
    {
      "indent": 0,
      "text": "3.3. Reliability Guidelines",
      "section_title": true,
      "ja": "3.3. 信頼性のガイドライン"
    },
    {
      "indent": 3,
      "text": "Application designers are generally aware that UDP does not provide any reliability, e.g., it does not retransmit any lost packets. Often, this is a main reason to consider UDP as a transport. Applications that do require reliable message delivery MUST implement an appropriate mechanism themselves.",
      "ja": "アプリケーション設計者は、一般的にUDPは、任意の信頼性を提供しないことを知っている、例えば、それが失われたパケットを再送しません。多くの場合、これはトランスポートとしてUDPを検討する主な理由です。信頼性の高いメッセージ配信を必要としないアプリケーションでは、適切なメカニズム自体を実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "UDP also does not protect against datagram duplication, i.e., an application may receive multiple copies of the same UDP datagram. Application designers SHOULD verify that their application handles datagram duplication gracefully, and may consequently need to implement mechanisms to detect duplicates. Even if UDP datagram reception triggers idempotent operations, applications may want to suppress duplicate datagrams to reduce load.",
      "ja": "UDPはまたすなわち、アプリケーションは、同じUDPデータグラムの複数のコピーを受信することができる、データグラム複製から保護しません。アプリケーション設計者は、アプリケーションが正常にデータグラムの複製を扱うことを確認する必要があり、その結果、重複を検出するためのメカニズムを実装する必要があるかもしれません。 UDPデータグラムの受信が冪等の操作をトリガとしても、アプリケーションの負荷を軽減するために、重複データグラムを抑制することができます。"
    },
    {
      "indent": 3,
      "text": "In addition, the Internet can significantly delay some packets with respect to others, e.g., due to routing transients, intermittent connectivity, or mobility. This can cause reordering, where UDP datagrams arrive at the receiver in an order different from the transmission order. Applications that require ordered delivery MUST reestablish datagram ordering themselves.",
      "ja": "また、インターネットは、有意により過渡、断続的な接続、又は移動性をルーティングのために、例えば、他の人に対していくつかのパケットを遅延させることができます。これは、UDPデータグラムが送信順序と異なる順序で受信機に到達並べ替えを引き起こすことができます。注文の配信を必要とするアプリケーションは、自分自身を注文データグラムを再確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, it is important to note that delay spikes can be very large. This can cause reordered packets to arrive many seconds after they were sent. [RFC0793] defines the maximum delay a TCP segment should experience -- the Maximum Segment Lifetime (MSL) -- as 2 minutes. No other RFC defines an MSL for other transport protocols or IP itself. This document clarifies that the MSL value to be used for UDP SHOULD be the same 2 minutes as for TCP. Applications SHOULD be robust to the reception of delayed or duplicate packets that are received within this 2-minute interval.",
      "ja": "最後に、遅延スパイクが非常に大きくなる可能性があることに注意することが重要です。これは、それらが送信された後に並べ替えパケットが何秒に到着することがあります。 2分として - 最大セグメント寿命（MSL） -  [RFC0793]はTCPセグメントが経験する最大遅延を定義します。他のRFCは、他のトランスポートプロトコルやIP自身のためにMSLを定義していません。この文書では、UDPで使用するMSL値はTCPと同じ2分されるべきであることを明確にしています。アプリケーションは、この2分間隔内に受信されている遅延や重複パケットの受信に堅牢であるべきです。"
    },
    {
      "indent": 3,
      "text": "An application that requires reliable and ordered message delivery SHOULD choose an IETF standard transport protocol that provides these features. If this is not possible, it will need to implement a set of appropriate mechanisms itself.",
      "ja": "信頼性と注文したメッセージ配信を必要とするアプリケーションは、これらの機能を提供してIETF標準のトランスポートプロトコルを選択する必要があります。これが不可能な場合、それは適切なメカニズム自体のセットを実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4. Checksum Guidelines",
      "section_title": true,
      "ja": "3.4. チェックサムのガイドライン"
    },
    {
      "indent": 3,
      "text": "The UDP header includes an optional, 16-bit one's complement checksum that provides an integrity check. This results in a relatively weak protection in terms of coding theory [RFC3819], and application developers SHOULD implement additional checks where data integrity is important, e.g., through a Cyclic Redundancy Check (CRC) included with the data to verify the integrity of an entire object/file sent over the UDP service.",
      "ja": "UDPヘッダは、整合性チェックを提供するオプション、16ビットの1の補数チェックサムを含んでいます。これは理論[RFC3819]をコード化の面で比較的弱い保護になり、アプリケーション開発者は、データの整合性が重要である追加のチェック、などを実装する必要があり、巡回冗長検査（CRC）を介して全体の整合性を検証するために、データに含まれていますオブジェクト/ファイルには、UDPサービスを介して送信されます。"
    },
    {
      "indent": 3,
      "text": "The UDP checksum provides a statistical guarantee that the payload was not corrupted in transit. It also allows the receiver to verify that it was the intended destination of the packet, because it covers the IP addresses, port numbers, and protocol number, and it verifies that the packet is not truncated or padded, because it covers the size field. It therefore protects an application against receiving corrupted payload data in place of, or in addition to, the data that was sent. This check is not strong from a coding or cryptographic perspective, and is not designed to detect physical-layer errors or malicious modification of the datagram [RFC3819].",
      "ja": "UDPチェックサムはペイロードが輸送中に破損していない統計的な保証を提供します。それはIPアドレス、ポート番号、およびプロトコル番号をカバーしているので、それはまた、受信機は、パケットの意図された宛先であったことを確認することができ、そしてそれは、サイズフィールドをカバーするため、パケットは、切り捨てまたはパディングされていないことを検証します。したがって、の代わりに、破損したペイロードデータを受信、または送信されたデータに加えて、反対のアプリケーションを保護します。このチェックは、符号化または暗号化の観点から強くはないが、物理層エラーやデータグラム[RFC3819]の悪意のある変更を検出するように設計されていません。"
    },
    {
      "indent": 3,
      "text": "Applications SHOULD enable UDP checksums, although [RFC0768] permits the option to disable their use. Applications that choose to disable UDP checksums when transmitting over IPv4 therefore MUST NOT make assumptions regarding the correctness of received data and MUST behave correctly when a UDP datagram is received that was originally sent to a different destination or is otherwise corrupted. The use of the UDP checksum is REQUIRED when applications transmit UDP over IPv6 [RFC2460].",
      "ja": "[RFC0768]は、その使用を無効にするオプションを許可するものの、アプリケーションは、UDPチェックサムを有効にする必要があります。 IPv4の上で送信するときにUDPチェックサムを無効にすることを選択したアプリケーションは、したがって、受信したデータの正しさに関する仮定してはならないとUDPデータグラムは、それはもともと別の宛先に送信されたか、そうでない場合は破損している受信されたときに正しく動作しなければなりません。アプリケーションがIPv6 [RFC2460]の上にUDPを送信するときにUDPチェックサムを使用することが必要です。"
    },
    {
      "indent": 0,
      "text": "3.4.1. UDP-Lite",
      "section_title": true,
      "ja": "3.4.1.  UDP-Liteの"
    },
    {
      "indent": 3,
      "text": "A special class of applications can derive benefit from having partially-damaged payloads delivered, rather than discarded, when using paths that include error-prone links. Such applications can tolerate payload corruption and MAY choose to use the Lightweight User Datagram Protocol (UDP-Lite) [RFC3828] variant of UDP instead of",
      "ja": "アプリケーションの特別なクラスは、エラープローンリンクを含むパスを使用する場合、廃棄するのではなく、送達部分的に破損したペイロードを有することから利益を得ることができます。このようなアプリケーションは、ペイロードの破損に耐えることができますし、代わりにUDPの軽量ユーザーデータグラムプロトコル（UDP-Liteは）[RFC3828]バリアントを使用することもできます"
    },
    {
      "indent": 3,
      "text": "basic UDP. Applications that choose to use UDP-Lite instead of UDP should still follow the congestion control and other guidelines described for use with UDP in Section 3.",
      "ja": "基本的なUDP。代わりにUDPのUDP-Liteの使用を選択したアプリケーションは、まだ第3節ではUDPで使用するために説明した輻輳制御およびその他のガイドラインに従ってください。"
    },
    {
      "indent": 3,
      "text": "UDP-Lite changes the semantics of the UDP \"payload length\" field to that of a \"checksum coverage length\" field. Otherwise, UDP-Lite is semantically identical to UDP. The interface of UDP-Lite differs from that of UDP by the addition of a single (socket) option that communicates a checksum coverage length value: at the sender, this specifies the intended checksum coverage, with the remaining unprotected part of the payload called the \"error-insensitive part\". By default, the UDP-Lite checksum coverage extends across the entire datagram. If required, an application may dynamically modify this length value, e.g., to offer greater protection to some messages. UDP-Lite always verifies that a packet was delivered to the intended destination, i.e., always verifies the header fields. Errors in the insensitive part will not cause a UDP datagram to be discarded by the destination. Applications using UDP-Lite therefore MUST NOT make assumptions regarding the correctness of the data received in the insensitive part of the UDP-Lite payload.",
      "ja": "UDP-Liteは、「チェックサム・カバレッジ・長さ」フィールドのそれとUDP「ペイロード長」フィールドのセマンティクスを変更します。それ以外の場合は、UDP-LiteはUDPと意味的に同じです。 UDP-Liteとのインターフェースは、チェックサム・カバレッジ・長さ値を伝達する単一（ソケット）オプションの添加によりUDPとは異なる：送信者に、これはと呼ばれるペイロードの残りの保護されていない部分と、意図されたチェックサム適用範囲を指定します「エラーと小文字を区別しない部分」。デフォルトでは、UDP-Liteのチェックサム適用範囲は、データグラム全体を横切って延びます。必要な場合は、アプリケーションが動的にいくつかのメッセージに大きな保護を提供するために、例えば、この長さの値を変更することがあります。 UDP-Liteは、常にパケットを、即ち、常にヘッダフィールドを検証し、意図された宛先に配信されたことを検証します。小文字を区別しない部分のエラーは、UDPデータグラムが宛先によって破棄されることはありません。 UDP-Liteのペイロードの影響を受けない部分で受信したデータの正しさに関する仮定してはならないため、UDP-Liteの使用するアプリケーション。"
    },
    {
      "indent": 3,
      "text": "The sending application SHOULD select the minimum checksum coverage to include all sensitive protocol headers. For example, applications that use the Real-Time Protocol (RTP) [RFC3550] will likely want to protect the RTP header against corruption. Applications, where appropriate, MUST also introduce their own appropriate validity checks for protocol information carried in the insensitive part of the UDP-Lite payload (e.g., internal CRCs).",
      "ja": "送信側アプリケーションは、すべての敏感なプロトコルヘッダを含むように最小チェックサム適用範囲を選択すべきです。例えば、リアルタイムプロトコル（RTP）[RFC3550]を使用するアプリケーションは、おそらく腐敗RTPヘッダを保護することになるでしょう。アプリケーションは、適切な場合、また、UDP-Liteのペイロード（例えば、内部のCRC）の非感受性部分で運ばれるプロトコル情報のための独自の適切な妥当性チェックを導入しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The receiver must set a minimum coverage threshold for incoming packets that is not smaller than the smallest coverage used by the sender [RFC3828]. The receiver SHOULD select a threshold that is sufficiently large to block packets with an inappropriately short coverage field. This may be a fixed value, or may be negotiated by an application. UDP-Lite does not provide mechanisms to negotiate the checksum coverage between the sender and receiver.",
      "ja": "受信機は、送信者[RFC3828]で使用される最小のカバレッジよりも小さくない着信パケットの最小カバレッジしきい値を設定しなければなりません。受信機は、不適切に短いカバレッジ・フィールドを有するパケットをブロックするのに十分な大きさの閾値を選択すべきです。これは、固定値であってもよいし、またはアプリケーションによってネゴシエートされてもよいです。 UDP-Liteは、送信者と受信者の間のチェックサムカバレッジを交渉する仕組みを提供していません。"
    },
    {
      "indent": 3,
      "text": "Applications may still experience packet loss, rather than corruption, when using UDP-Lite. The enhancements offered by UDP-Lite rely upon a link being able to intercept the UDP-Lite header to correctly identify the partial coverage required. When tunnels and/or encryption are used, this can result in UDP-Lite datagrams being treated the same as UDP datagrams, i.e., result in packet loss. Use of IP fragmentation can also prevent special treatment for UDP-Lite datagrams, and this is another reason why applications SHOULD avoid IP fragmentation (Section 3.2).",
      "ja": "UDP-Liteの使用時にアプリケーションは、まだ、かなり腐敗よりも、パケットロスが発生することがあります。 UDP-Liteのが提供する拡張機能が正しく必要な部分カバレッジを識別するために、UDP-Liteのヘッダを傍受することができるというリンクに依存しています。トンネルおよび/または暗号化が使用される場合、これはすなわち、パケット損失につながる、UDPデータグラムと同じように扱われているUDP-Liteのデータグラムをもたらすことができます。 IPフラグメンテーションの使用は、UDP-Liteのデータグラムのための特別な処理を防ぐことができ、そしてこれは、アプリケーションがIPフラグメンテーション（3.2節）を避けなければならないもう一つの理由です。"
    },
    {
      "indent": 0,
      "text": "3.5. Middlebox Traversal Guidelines",
      "section_title": true,
      "ja": "3.5. ミドルトラバーサルのガイドライン"
    },
    {
      "indent": 3,
      "text": "Network address translators (NATs) and firewalls are examples of intermediary devices (\"middleboxes\") that can exist along an end-to-end path. A middlebox typically performs a function that requires it to maintain per-flow state. For connection-oriented protocols, such as TCP, middleboxes snoop and parse the connection-management traffic and create and destroy per-flow state accordingly. For a connectionless protocol such as UDP, this approach is not possible. Consequently, middleboxes may create per-flow state when they see a packet that indicates a new flow, and destroy the state after some period of time during which no packets belonging to the same flow have arrived.",
      "ja": "ネットワークアドレス変換（NAT）とファイアウォールは、エンドツーエンドの経路に沿って存在することができる中間デバイス（「中間装置」）の一例です。ミドルボックスは、典型的には、フローごとの状態を維持することを必要とする機能を果たします。 TCPのようなコネクション指向のプロトコルについては、ミドルボックスは、スヌープと接続管理トラフィックを解析して作成し、それに応じて、フローごとの状態を破壊します。 UDPのようなコネクションレスプロトコルの場合、このアプローチは不可能です。その結果、ミドルボックスは、彼らが新しい流れを示しているパケットを見ると、フローごとの状態を作成し、同じフローに属するパケットが到着していない間の時間のいくつかの期間後の状態を破壊することがあります。"
    },
    {
      "indent": 3,
      "text": "Depending on the specific function that the middlebox performs, this behavior can introduce a time-dependency that restricts the kinds of UDP traffic exchanges that will be successful across the middlebox. For example, NATs and firewalls typically define the partial path on one side of them to be interior to the domain they serve, whereas the partial path on their other side is defined to be exterior to that domain. Per-flow state is typically created when the first packet crosses from the interior to the exterior, and while the state is present, NATs and firewalls will forward return traffic. Return traffic that arrives after the per-flow state has timed out is dropped, as is other traffic that arrives from the exterior.",
      "ja": "ミドルが実行する特定の機能に応じて、この動作は、ミドル全体で成功するUDPトラフィック交換の種類を制限時間依存性を導入することができます。例えば、のNAT及びファイアウォールは、典型的には、その反対側の部分経路がそのドメインの外側になるように定義され、一方、それらの一方の側の部分経路は、彼らが提供ドメインに対して内部であると定義します。最初のパケットが内部から外部に交差し、状態が存在している間、NATのファイアウォールは、リターントラフィックを転送する際に、フローごとの状態は、一般的に作成されます。外部から到着した他のトラフィックがあるとして、フローごとの状態がタイムアウトした後に到着したリターントラフィックは、廃棄されます。"
    },
    {
      "indent": 3,
      "text": "Many applications that use UDP for communication operate across middleboxes without needing to employ additional mechanisms. One example is the Domain Name System (DNS), which has a strict request-response communication pattern that typically completes within seconds.",
      "ja": "通信のためにUDPを使用する多くのアプリケーションは、追加の機構を使用することなく、ミドルボックス間で動作します。一例では、典型的には、数秒以内に完了した厳密な要求 - 応答通信パターンを有するドメインネームシステム（DNS）、です。"
    },
    {
      "indent": 3,
      "text": "Other applications may experience communication failures when middleboxes destroy the per-flow state associated with an application session during periods when the application does not exchange any UDP traffic. Applications SHOULD be able to gracefully handle such communication failures and implement mechanisms to re-establish application-layer sessions and state.",
      "ja": "ミドルボックスは、期間中のアプリケーションセッションに関連付けられたフローごとの状態を破壊するときにアプリケーションが任意のUDPトラフィックを交換しない場合に他のアプリケーションは、通信障害が発生することがあります。アプリケーションが正常にこのような通信障害を処理し、アプリケーション層のセッション状態を再確立するためのメカニズムを実装することができるべきです。"
    },
    {
      "indent": 3,
      "text": "For some applications, such as media transmissions, this re-synchronization is highly undesirable, because it can cause user-perceivable playback artifacts. Such specialized applications MAY send periodic keep-alive messages to attempt to refresh middlebox state. It is important to note that keep-alive messages are NOT RECOMMENDED for general use -- they are unnecessary for many applications and can consume significant amounts of system and network resources.",
      "ja": "それは、ユーザが知覚再生アーティファクトを引き起こす可能性があるので、このようなメディアの送信などの一部のアプリケーションでは、この再同期は、非常に望ましくありません。このような特殊なアプリケーションには、ミドル状態をリフレッシュしようとするために定期的にキープアライブメッセージを送信することができます。そのキープアライブメッセージは、一般的な使用のために推奨されていません注意することが重要である - 彼らは多くのアプリケーションのために不必要であり、システムやネットワークのリソースを大量に消費することができます。"
    },
    {
      "indent": 3,
      "text": "An application that needs to employ keep-alives to deliver useful service over UDP in the presence of middleboxes SHOULD NOT transmit them more frequently than once every 15 seconds and SHOULD use longer intervals when possible. No common timeout has been specified for per-flow UDP state for arbitrary middleboxes. NATs require a state timeout of 2 minutes or longer [RFC4787]. However, empirical evidence suggests that a significant fraction of currently deployed middleboxes unfortunately use shorter timeouts. The timeout of 15 seconds originates with the Interactive Connectivity Establishment (ICE) protocol [ICE]. When applications are deployed in more controlled network environments, the deployers SHOULD investigate whether the target environment allows applications to use longer intervals, or whether it offers mechanisms to explicitly control middlebox state timeout durations, for example, using Middlebox Communications (MIDCOM) [RFC3303], Next Steps in Signaling (NSIS) [NSLP], or Universal Plug and Play (UPnP) [UPnP]. It is RECOMMENDED that applications apply slight random variations (\"jitter\") to the timing of keep-alive transmissions, to reduce the potential for persistent synchronization between keep-alive transmissions from different hosts.",
      "ja": "ミドルボックスの存在下でUDP上で便利なサービスを提供するためにキープアライブを採用する必要があるアプリケーションは、一回15秒よりも頻繁にそれらを送信するべきではなく、可能な場合はより長い間隔を使用すべきです。共通のタイムアウトは、任意のミドルボックスのためのフローごとのUDPの状態のために指定されていません。 NATは2分以上[RFC4787]の状態のタイムアウトを要求します。しかし、経験的証拠は、現在展開ミドルボックスのかなりの割合が、残念ながら短いタイムアウトを使用することを示唆しています。 15秒のタイムアウトは、インタラクティブ接続確立（ICE）プロトコル[ICE]で発信します。アプリケーションは、より制御されたネットワーク環境で展開されている場合、デプロイヤは、ターゲット環境がより長い間隔を使用するアプリケーションを許可するかどうかを調査する必要があり、かどうかそれはミドル・コミュニケーションズ（MIDCOM）[RFC3303]を使用して、例えば、明示的ミドル状態のタイムアウト期間を制御するためのメカニズムを提供しますシグナリングにおける次のステップ（NSIS）[NSLP]、またはユニバーサルプラグアンドプレイ（UPnP）のUPnP]。異なるホストからのキープアライブ送信の間の永続的な同期の可能性を減らすために、アプリケーションがキープアライブ送信のタイミングに多少のランダムな変動（「ジッター」）を適用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Sending keep-alives is not a substitute for implementing robust connection handling. Like all UDP datagrams, keep-alives can be delayed or dropped, causing middlebox state to time out. In addition, the congestion control guidelines in Section 3.1 cover all UDP transmissions by an application, including the transmission of middlebox keep-alives. Congestion control may thus lead to delays or temporary suspension of keep-alive transmission.",
      "ja": "キープアライブを送信すると、強固な接続処理を実装するための代替ではありません。すべてのUDPデータグラムのように、キープアライブは、時間にミドル状態を引き起こし、遅れたりドロップすることができます。また、3.1節カバーにおける輻輳制御に関するガイドラインは、ミドルの送信など、アプリケーションによってすべてのUDP送信は、キープアライブを。輻輳制御は、このような遅延またはキープアライブの送信の一時的な停止につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Keep-alive messages are NOT RECOMMENDED for general use. They are unnecessary for many applications and may consume significant resources. For example, on battery-powered devices, if an application needs to maintain connectivity for long periods with little traffic, the frequency at which keep-alives are sent can become the determining factor that governs power consumption, depending on the underlying network technology. Because many middleboxes are designed to require keep-alives for TCP connections at a frequency that is much lower than that needed for UDP, this difference alone can often be sufficient to prefer TCP over UDP for these deployments. On the other hand, there is anecdotal evidence that suggests that direct communication through middleboxes, e.g., by using ICE [ICE], does succeed less often with TCP than with UDP. The tradeoffs between different transport protocols -- especially when it comes to middlebox traversal -- deserve careful analysis.",
      "ja": "キープアライブメッセージは、一般的な使用のために推奨されていません。彼らは多くの用途のために不必要であり、かなりのリソースを消費することがあります。アプリケーションは、交通量の少ない長時間接続を維持する必要がある場合たとえば、バッテリ駆動機器に、送信されたキープアライブをする頻度は、基盤となるネットワーク技術に依存し、消費電力を左右する決定要因になることができます。多くのミドルボックスは、UDPのために必要なものよりもはるかに低い周波数でTCP接続のキープアライブを必要とするように設計されているので、一人でこの違いは、多くの場合、これらの展開のためにUDP上でTCPを好むのに十分であり得ます。一方、ミドルボックスによる直接通信は、例えば、ICE [ICE]を用いて、あまり頻繁にTCPとUDPよりも成功しないことを示唆している事例証拠があります。異なるトランスポートプロトコルの間のトレードオフ - 特にそれがトラバーサルをミドルになる - 慎重な分析に値します。"
    },
    {
      "indent": 0,
      "text": "3.6. Programming Guidelines",
      "section_title": true,
      "ja": "3.6. プログラミングのガイドライン"
    },
    {
      "indent": 3,
      "text": "The de facto standard application programming interface (API) for TCP/IP applications is the \"sockets\" interface [POSIX]. Some platforms also offer applications the ability to directly assemble and transmit IP packets through \"raw sockets\" or similar facilities. This is a second, more cumbersome method of using UDP. The guidelines in this document cover all such methods through which an application may use UDP. Because the sockets API is by far the most common method, the remainder of this section discusses it in more detail.",
      "ja": "TCP / IPアプリケーションのための事実上の標準アプリケーション・プログラミング・インターフェース（API）は、「ソケット」インターフェース[POSIX]です。一部のプラットフォームでは、アプリケーションに直接集合し、「生のソケット」または同様の施設を介してIPパケットを送信する機能を提供します。これは、UDPを使用しての第二、より面倒な方法です。この文書のガイドラインは、アプリケーションがUDPを使用することができ、それを通してすべてのそのような方法をカバーしています。ソケットAPIは、これまでで最も一般的な方法であるため、このセクションの残りの部分は、より詳細にそれを説明します。"
    },
    {
      "indent": 3,
      "text": "Although the sockets API was developed for UNIX in the early 1980s, a wide variety of non-UNIX operating systems also implement this. The sockets API supports both IPv4 and IPv6 [RFC3493]. The UDP sockets API differs from that for TCP in several key ways. Because application programmers are typically more familiar with the TCP sockets API, the remainder of this section discusses these differences. [STEVENS] provides usage examples of the UDP sockets API.",
      "ja": "ソケットAPIは、1980年代初頭にUNIX用に開発されましたが、非UNIXオペレーティング・システムの多種多様なもこれを実装します。ソケットAPIは、IPv4とIPv6 [RFC3493]の両方をサポートしています。 UDPソケットAPIは、いくつかの重要な方法でTCPのためのものとは異なります。アプリケーションプログラマは、通常のTCPソケットAPIに精通しているので、このセクションの残りの部分は、これらの違いについて説明します。 【STEVENS]はUDPソケットAPIの使用例を提供します。"
    },
    {
      "indent": 3,
      "text": "UDP datagrams may be directly sent and received, without any connection setup. Using the sockets API, applications can receive packets from more than one IP source address on a single UDP socket. Some servers use this to exchange data with more than one remote host through a single UDP socket at the same time. Many applications need to ensure that they receive packets from a particular source address; these applications MUST implement corresponding checks at the application layer or explicitly request that the operating system filter the received packets.",
      "ja": "UDPデータグラムは直接送信され、任意の接続設定せずに、受信することができます。ソケットAPIを使用して、アプリケーションは、単一のUDPソケットに複数のIP送信元アドレスからのパケットを受信することができます。一部のサーバーでは、これは同時に、単一のUDPソケットを介して、複数のリモートホストとデータを交換するために使用します。多くのアプリケーションは、彼らが特定の送信元アドレスからのパケットを受信することを確認する必要があります。これらのアプリケーションは、アプリケーション層に対応するチェックを実施するか、明示的に、オペレーティング・システムは、受信したパケットをフィルタリングすることを要求しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a client/server application executes on a host with more than one IP interface, the application SHOULD send any UDP responses with an IP source address that matches the IP destination address of the UDP datagram that carried the request (see [RFC1122], Section 4.1.3.5). Many middleboxes expect this transmission behavior and drop replies that are sent from a different IP address, as explained in Section 3.5.",
      "ja": "クライアント/サーバ・アプリケーションが複数のIPインタフェースを持つホスト上で実行した場合、アプリケーションが要求を実行UDPデータグラムのIP宛先アドレスと一致するIP送信元アドレスと任意のUDP応答を送信すべきである（[RFC1122]、セクションを参照してください4.1.3.5）。多くのミドルボックスは、この送信動作を期待し、3.5節で説明したように、異なるIPアドレスから送信された応答をドロップします。"
    },
    {
      "indent": 3,
      "text": "A UDP receiver can receive a valid UDP datagram with a zero-length payload. Note that this is different from a return value of zero from a read() socket call, which for TCP indicates the end of the connection.",
      "ja": "UDP受信機は、長さゼロのペイロードを持つ有効なUDPデータグラムを受信することができます。これはTCP接続のための終了を示すリード（）ソケット呼び出し、ゼロからの戻り値と異なることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Many operating systems also allow a UDP socket to be connected, i.e., to bind a UDP socket to a specific pair of addresses and ports. This is similar to the corresponding TCP sockets API functionality. However, for UDP, this is only a local operation that serves to simplify the local send/receive functions and to filter the traffic for the specified addresses and ports. Binding a UDP socket does not establish a connection -- UDP does not notify the remote end when a local UDP socket is bound. Binding a socket also allows configuring options that affect the UDP or IP layers, for example, use of the UDP checksum or the IP Timestamp option. On some stacks, a bound socket also allows an application to be notified when ICMP error messages are received for its transmissions [RFC1122].",
      "ja": "多くのオペレーティングシステムは、また、アドレスとポートの特定のペアにUDPソケットを結合すること、すなわち、UDPソケットが接続されることを可能にします。これは、対応するTCPソケットAPIの機能に似ています。しかし、UDPのために、これは、ローカル送信/受信機能と、指定したアドレスとポートのトラフィックをフィルタリングすることを簡素化するのに役立つだけローカル操作です。 UDPソケットをバインドすると、接続を確立していない - ローカルUDPソケットがバインドされたときにUDPがリモートエンドに通知しません。ソケットをバインドするにも、例えば、UDPチェックサムまたはIPタイムスタンプオプションの使用をUDPまたはIP層に影響を与えるオプションを設定することができます。いくつかのスタックでは、バインドされたソケットは、ICMPエラーメッセージがその送信[RFC1122]のために受信されたときにアプリケーションに通知することができます。"
    },
    {
      "indent": 3,
      "text": "UDP provides no flow-control. This is another reason why UDP-based applications need to be robust in the presence of packet loss. This loss can also occur within the sending host, when an application sends data faster than the line rate of the outbound network interface. It can also occur on the destination, where receive calls fail to return all the data that was sent when the application issues them too infrequently (i.e., such that the receive buffer overflows). Robust flow control mechanisms are difficult to implement, which is why applications that need this functionality SHOULD consider using a full-featured transport protocol.",
      "ja": "UDPにはフロー制御を提供していません。これは、UDPベースのアプリケーションは、パケット損失の存在下で堅牢である必要はもう一つの理由です。この損失は、アプリケーションをより速く送信ネットワークインターフェイスのラインレートよりもデータを送信する際、送信ホスト内で発生することができます。また、受信コールが、それらはあまりにまれに（バッファオーバーフローを受信すること、すなわち、このような）アプリケーションの問題送信されたすべてのデータを返すことができない宛先、上で起こり得ます。堅牢なフロー制御メカニズムは、この機能を必要とするアプリケーションは、フル機能のトランスポートプロトコルを使用して検討すべき理由である、実施することが困難です。"
    },
    {
      "indent": 3,
      "text": "When an application closes a TCP, SCTP or DCCP socket, the transport protocol on the receiving host is required to maintain TIME-WAIT state. This prevents delayed packets from the closed connection instance from being mistakenly associated with a later connection instance that happens to reuse the same IP address and port pairs. The UDP protocol does not implement such a mechanism. Therefore, UDP-based applications need to be robust in this case. One application may close a socket or terminate, followed in time by another application receiving on the same port. This later application may then receive packets intended for the first application that were delayed in the network.",
      "ja": "アプリケーションは、TCP、SCTPやDCCPソケットを閉じると、受信側ホスト上のトランスポートプロトコルは、TIME-WAIT状態を維持するために必要とされます。これは、誤って同じIPアドレスとポートのペアを再利用するために起こる後、接続インスタンスに関連付けられているから、閉じた接続インスタンスからの遅延パケットを防ぎます。 UDPプロトコルは、このような仕組みを実装していません。したがって、UDPベースのアプリケーションは、この場合には堅牢にする必要があります。 1つの用途は、同じポートで受信する他のアプリケーションによって時間的に続いて、ソケットを閉じるか、終了することができます。この後、アプリケーションは、ネットワーク内で遅延された最初のアプリケーションのために意図されたパケットを受信することができます。"
    },
    {
      "indent": 3,
      "text": "The Internet can provide service differentiation to applications based on IP-layer packet markings [RFC2475]. This facility can be used for UDP traffic. Different operating systems provide different interfaces for marking packets to applications. Differentiated services require support from the network, and application deployers need to discuss the provisioning of this functionality with their network operator.",
      "ja": "インターネットは、IP層パケットマーキング[RFC2475]に基づいてアプリケーションへのサービスの差別化を提供することができます。この機能は、UDPトラフィックに使用することができます。異なるオペレーティングシステムは、アプリケーションにパケットをマーキングするために異なるインタフェースを提供します。差別化されたサービスは、ネットワークからの支援を必要とし、アプリケーションデプロイヤは、そのネットワークオペレータと、この機能のプロビジョニングを議論する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.7. ICMP Guidelines",
      "section_title": true,
      "ja": "3.7.  ICMPのガイドライン"
    },
    {
      "indent": 3,
      "text": "Applications can utilize information about ICMP error messages that the UDP layer passes up for a variety of purposes [RFC1122]. Applications SHOULD validate that the information in the ICMP message payload, e.g., a reported error condition, corresponds to a UDP datagram that the application actually sent. Note that not all APIs have the necessary functions to support this validation, and some APIs already perform this validation internally before passing ICMP information to the application.",
      "ja": "アプリケーションは、UDP層は、様々な目的のためにアップ渡しICMPエラーメッセージ[RFC1122]についての情報を利用することができます。アプリケーションは、ICMPメッセージペイロード内の情報は、例えば、報告されたエラー状態は、アプリケーションが実際に送信されたUDPデータグラムに対応することを検証する必要があります。いないすべてのAPIは、この検証をサポートするために必要な機能を持っており、いくつかのAPIは、既にアプリケーションにICMP情報を渡す前に、内部でこの検証を行うことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Any application response to ICMP error messages SHOULD be robust to temporary routing failures, i.e., transient ICMP \"unreachable\" messages should not normally cause a communication abort. Applications SHOULD appropriately process ICMP messages generated in response to transmitted traffic. A correct response often requires context, such as local state about communication instances to each destination, that although readily available in connection-oriented transport protocols is not always maintained by UDP-based applications.",
      "ja": "ICMPエラーメッセージへの任意のアプリケーションの応答は、すなわち、過渡ICMP「到達不能」メッセージが正常に通信中断が発生することはありません一時的なルーティング障害に対して堅牢であるべきです。アプリケーションは、適切に送信されたトラフィックに応じて生成されたICMPメッセージを処理する必要があります。正しい応答は、多くの場合、接続指向のトランスポートプロトコルで容易に入手可能であるが、常にUDPベースのアプリケーションによって維持されていないと、そのような各宛先への通信インスタンスに関するローカル状態として、コンテキストを必要とします。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "UDP does not provide communications security. Applications that need to protect their communications against eavesdropping, tampering, or message forgery SHOULD employ end-to-end security services provided by other IETF protocols. Applications that respond to short requests with potentially large responses are vulnerable to amplification attacks, and SHOULD authenticate the sender before responding. The source IP address of a request is not a useful authenticator, because it can be spoofed.",
      "ja": "UDPは、通信のセキュリティを提供しません。他のIETFプロトコルによって提供エンドツーエンドのセキュリティサービスを採用すべき盗聴、改ざん、またはメッセージ偽造に対する彼らの通信を保護する必要があるアプリケーション。潜在的に大きな応答と短い要求に応答するアプリケーションは、増幅攻撃に対して脆弱であり、応答する前に、送信者を認証する必要があります。それは詐称できるため、要求の送信元IPアドレスは、便利なオーセンティケータではありません。"
    },
    {
      "indent": 3,
      "text": "One option of securing UDP communications is with IPsec [RFC4301], which can provide authentication for flows of IP packets through the Authentication Header (AH) [RFC4302] and encryption and/or authentication through the Encapsulating Security Payload (ESP) [RFC4303]. Applications use the Internet Key Exchange (IKE) [RFC4306] to configure IPsec for their sessions. Depending on how IPsec is configured for a flow, it can authenticate or encrypt the UDP headers as well as UDP payloads. If an application only requires authentication, ESP with no encryption but with authentication is often a better option than AH, because ESP can operate across middleboxes. An application that uses IPsec requires the support of an operating system that implements the IPsec protocol suite.",
      "ja": "UDP通信を確保する1つのオプションは、認証ヘッダ（AH）[RFC4302]およびカプセル化セキュリティペイロード（ESP）を介して、暗号化および/または認証[RFC4303]を介してIPパケットのフローのための認証を提供することができるのIPsec [RFC4301]です。アプリケーションは、そのセッションのためにIPsecを設定するには、インターネット鍵交換（IKE）[RFC4306]を使用します。 IPsecは、フロー用に設定されている方法に応じて、それはUDPヘッダと同様にUDPペイロードを認証または暗号化することができます。アプリケーションが認証のみを必要とする場合はESPがミドルボックスにわたって動作することができるため、暗号化なしが、認証とESPは、多くの場合、AHより良いオプションです。 IPsecを使用するアプリケーションは、IPsecプロトコルスイートを実装するオペレーティング・システムのサポートを必要とします。"
    },
    {
      "indent": 3,
      "text": "Although it is possible to use IPsec to secure UDP communications, not all operating systems support IPsec or allow applications to easily configure it for their flows. A second option of securing UDP communications is through Datagram Transport Layer Security (DTLS) [RFC4347]. DTLS provides communication privacy by encrypting UDP payloads. It does not protect the UDP headers. Applications can implement DTLS without relying on support from the operating system.",
      "ja": "それはUDP通信を保護するためにIPsecを使用することも可能であるが、すべてのオペレーティングシステムにはIPsecをサポートしたり、アプリケーションが簡単に彼らのフローのためにそれを設定することはできませ。 UDP通信を確保する2番目のオプションは、データグラムトランスポート層セキュリティ（DTLS）[RFC4347]を使用することです。 DTLSはUDPペイロードを暗号化することにより、通信のプライバシーを提供します。これは、UDPヘッダを保護することはできません。アプリケーションは、オペレーティングシステムからの支援に頼らずDTLSを実装することができます。"
    },
    {
      "indent": 3,
      "text": "Many other options for authenticating or encrypting UDP payloads exist. For example, the GSS-API security framework [RFC2743] or Cryptographic Message Syntax (CMS) [RFC3852] could be used to protect UDP payloads. The IETF standard for securing RTP [RFC3550] communication sessions over UDP is the Secure Real-time Transport Protocol (SRTP) [RFC3711]. In some applications, a better solution is to protect larger stand-alone objects, such as files or messages, instead of individual UDP payloads. In these situations, CMS [RFC3852], S/MIME [RFC3851] or OpenPGP [RFC4880] could be used. In addition, there are many non-IETF protocols in this area.",
      "ja": "UDPペイロードを認証または暗号化するための他の多くの選択肢が存在します。たとえば、GSS-APIのセキュリティフレームワーク[RFC2743]や暗号メッセージ構文（CMS）[RFC3852]はUDPペイロードを保護するために使用することができます。 UDP上でRTP [RFC3550]の通信セッションを確保するためのIETF標準は、セキュアリアルタイム転送プロトコル（SRTP）[RFC3711]です。一部のアプリケーションでは、よりよい解決策は、そのようなファイルやメッセージの代わりに、個々のUDPペイロードのような大きなスタンドアロンのオブジェクトを、保護することです。これらの状況では、CMS [RFC3852]において、S / MIME [RFC3851]かのOpenPGP [RFC4880]は使用することができます。また、この地域の多くの非IETFプロトコルがあります。"
    },
    {
      "indent": 3,
      "text": "Like congestion control mechanisms, security mechanisms are difficult to design and implement correctly. It is hence RECOMMENDED that applications employ well-known standard security mechanisms such as DTLS or IPsec, rather than inventing their own.",
      "ja": "輻輳制御メカニズムと同様に、セキュリティメカニズムが設計し、正しく実装することは困難です。それ故にアプリケーションではなく、独自の発明よりも、このようなDTLSやIPsecなどの周知の標準的なセキュリティ機構を用いることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "The Generalized TTL Security Mechanism (GTSM) [RFC5082] may be used with UDP applications (especially when the intended endpoint is on the same link as the sender). This is a lightweight mechanism that allows a receiver to filter unwanted packets.",
      "ja": "一般TTLセキュリティメカニズム（GTSM）[RFC5082]はUDPアプリケーション（意図されたエンドポイントは、送信者と同じリンク上にある場合は特に）と共に使用することができます。これは、受信機は、不要なパケットをフィルタリングすることを可能にする軽量なメカニズムです。"
    },
    {
      "indent": 3,
      "text": "In terms of congestion control, [RFC2309] and [RFC2914] discuss the dangers of congestion-unresponsive flows to the Internet. This document provides guidelines to designers of UDP-based applications to congestion-control their transmissions, and does not raise any additional security concerns.",
      "ja": "輻輳制御の観点から、[RFC2309]及び[RFC2914]は、インターネットに輻輳応答しないフローの危険性を議論します。この文書では、輻輳制御への送信をUDPベースのアプリケーションの設計者に指針を提供し、任意の追加のセキュリティ上の問題を提起しません。"
    },
    {
      "indent": 0,
      "text": "5. Summary",
      "section_title": true,
      "ja": "5.まとめ"
    },
    {
      "indent": 3,
      "text": "This section summarizes the guidelines made in Sections 3 and 4 in a tabular format (Table 1) for easy referencing.",
      "ja": "このセクションでは、簡単に参照するために表形式（表1）のセクション3と4で行われたガイドラインをまとめたものです。"
    },
    {
      "indent": 3,
      "text": "+---------------------------------------------------------+---------+\n| Recommendation                                          | Section |\n+---------------------------------------------------------+---------+\n| MUST tolerate a wide range of Internet path conditions  | 3       |\n| SHOULD use a full-featured transport (TCP, SCTP, DCCP)  |         |\n|                                                         |         |\n| SHOULD control rate of transmission                     | 3.1     |\n| SHOULD perform congestion control over all traffic      |         |\n|                                                         |         |\n| for bulk transfers,                                     | 3.1.1   |\n| SHOULD consider implementing TFRC                       |         |\n| else, SHOULD in other ways use bandwidth similar to TCP |         |\n|                                                         |         |\n| for non-bulk transfers,                                 | 3.1.2   |\n| SHOULD measure RTT and transmit max. 1 datagram/RTT     |         |\n| else, SHOULD send at most 1 datagram every 3 seconds    |         |\n| SHOULD back-off retransmission timers following loss    |         |\n|                                                         |         |\n| for tunnels carrying IP Traffic,                        | 3.1.3   |\n| SHOULD NOT perform congestion control                   |         |\n|                                                         |         |\n| for non-IP tunnels or rate not determined by traffic,   | 3.1.3   |\n| SHOULD perform congestion control                       |         |\n|                                                         |         |\n| SHOULD NOT send datagrams that exceed the PMTU, i.e.,   | 3.2     |\n| SHOULD discover PMTU or send datagrams < minimum PMTU   |         |\n|                                                         |         |\n| SHOULD handle datagram loss, duplication, reordering    | 3.3     |\n| SHOULD be robust to delivery delays up to 2 minutes     |         |\n|                                                         |         |\n| SHOULD enable IPv4 UDP checksum                         | 3.4     |\n| MUST enable IPv6 UDP checksum                           |         |\n| else, MAY use UDP-Lite with suitable checksum coverage  | 3.4.1   |\n|                                                         |         |\n| SHOULD NOT always send middlebox keep-alives            | 3.5     |\n| MAY use keep-alives when needed (min. interval 15 sec)  |         |\n|                                                         |         |\n| MUST check IP source address                            | 3.6     |\n| and, for client/server applications                     |         |\n| SHOULD send responses from src address matching request |         |\n|                                                         |         |\n| SHOULD use standard IETF security protocols when needed | 4       |\n+---------------------------------------------------------+---------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Table 1: Summary of recommendations",
      "ja": "表1：勧告の概要"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgments",
      "section_title": true,
      "ja": "6.謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Paul Aitken, Mark Allman, Francois Audet, Iljitsch van Beijnum, Stewart Bryant, Remi Denis-Courmont, Lisa Dusseault, Wesley Eddy, Pasi Eronen, Sally Floyd, Robert Hancock, Jeffrey Hutzelman, Cullen Jennings, Tero Kivinen, Peter Koch, Jukka Manner, Philip Matthews, Joerg Ott, Colin Perkins, Tom Petch, Carlos Pignataro, Pasi Sarolahti, Pascal Thubert, Joe Touch, Dave Ward, and Magnus Westerlund for their comments on this document.",
      "ja": "ポール・エイトケン、マーク・オールマン、フランソワAudet、IljitschバンBeijnum、スチュワートブライアント、レミデニス・Courmont、リサDusseault、ウェズリーエディ、パシEronen、サリー・フロイド、ロバート・ハンコック、ジェフリーHutzelman、カレン・ジェニングス、TERO Kivinen、ピーター・コッホのおかげで、このドキュメントの彼らのコメントのためのユッカ・マナー、フィリップ・マシューズ、イェルク・オット、コリンパーキンス、トム・ペッチ、カルロスPignataro、パシSarolahti、パスカルThubert、ジョー・タッチ、デイブ・ワード、およびマグヌスウェスター。"
    },
    {
      "indent": 3,
      "text": "The middlebox traversal guidelines in Section 3.5 incorporate ideas from Section 5 of [BEHAVE-APP] by Bryan Ford, Pyda Srisuresh, and Dan Kegel.",
      "ja": "3.5節でミドルトラバーサルガイドラインはブライアン・フォード、Pyda Srisuresh、そしてダンケーゲルで[BEHAVE-APP]のセクション5からのアイデアを取り入れています。"
    },
    {
      "indent": 3,
      "text": "Lars Eggert is partly funded by [TRILOGY], a research project supported by the European Commission under its Seventh Framework Program. Gorry Fairhurst was partly funded by the EC SatNEx project.",
      "ja": "ラースEggertのは、部分的に[TRILOGY]、その第七次フレームワーク計画の下で、欧州委員会でサポートされている研究プロジェクトによって資金を供給されます。 Gorry Fairhurstは、部分的にEC SatNExプロジェクトによって資金を供給されました。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "ja": "[RFC0768]ポステル、J.、 \"ユーザ・データグラム・プロトコル\"、STD 6、RFC 768、1980年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC0793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122]ブレーデン、R.、 \"インターネットホストのための要件 - 通信層\"、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, November 1990.",
      "ja": "[RFC1191]ムガール人、J.とS.デアリング、 \"パスMTUディスカバリ\"、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1981] McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, August 1996.",
      "ja": "[RFC1981]マッキャン、J.、デアリング、S.、およびJ.ムガール人、RFC 1981、1996年8月 \"IPバージョン6のパスMTUディスカバリー\"。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC2460]デアリング、S.とR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の仕様\"、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2914] Floyd, S., \"Congestion Control Principles\", BCP 41, RFC 2914, September 2000.",
      "ja": "[RFC2914]フロイド、S.、 \"輻輳制御の原理\"、BCP 41、RFC 2914、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2988] Paxson, V. and M. Allman, \"Computing TCP's Retransmission Timer\", RFC 2988, November 2000.",
      "ja": "[RFC2988]パクソン、V.とM.オールマン、 \"コンピューティングTCPの再送信タイマー\"、RFC 2988、2000年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3828] Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., and G. Fairhurst, \"The Lightweight User Datagram Protocol (UDP-Lite)\", RFC 3828, July 2004.",
      "ja": "[RFC3828] Larzon、L-A。、Degermark、M.、ピンク、S.、ヨンソン、L-E。、およびG. Fairhurst、 \"軽量ユーザーデータグラムプロトコル（UDP-Liteの）\"、RFC 3828、2004年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4787] Audet, F. and C. Jennings, \"Network Address Translation (NAT) Behavioral Requirements for Unicast UDP\", BCP 127, RFC 4787, January 2007.",
      "ja": "[RFC4787] Audet、F.とC.ジェニングス、 \"ネットワークアドレス変換（NAT）ユニキャストUDPのための行動の要件\"、BCP 127、RFC 4787、2007年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, March 2007.",
      "ja": "[RFC4821]マシス、M.とJ. Heffner、 \"パケット化レイヤのパスMTUディスカバリ\"、RFC 4821、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5348] Floyd, S., Handley, M., Padhye, J., and J. Widmer, \"TCP Friendly Rate Control (TFRC): Protocol Specification\", RFC 5348, September 2008.",
      "ja": "[RFC5348]フロイド、S.、ハンドリー、M.、Padhye、J.、およびJ.ウィトマー、 \"TCPフレンドリーレート制御（TFRC）：プロトコル仕様\"、RFC 5348、2008年9月。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[BEHAVE-APP] Ford, B., \"Application Design Guidelines for Traversal through Network Address Translators\", Work in Progress, March 2007.",
      "ja": "[BEHAVE-APP]フォード、B.は、進歩、2007年3月に、仕事を「ネットワークを介してトラバーサルのためのアプリケーション設計のガイドラインは、翻訳者アドレス」。"
    },
    {
      "indent": 3,
      "text": "[CCID4] Floyd, S. and E. Kohler, \"Profile for Datagram Congestion Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate Control for Small Packets (TFRC-SP)\", Work in Progress, February 2008.",
      "ja": "[CCID4]フロイド、S.、およびE.コーラー、 \"データグラム輻輳制御プロトコル（DCCP）輻輳ID 4のためのプロフィール：小パケット用のTCPフレンドリーレート制御（TFRC-SP）\"、進歩、2008年2月に作業。"
    },
    {
      "indent": 3,
      "text": "[FABER] Faber, T., Touch, J., and W. Yue, \"The TIME-WAIT State in TCP and Its Effect on Busy Servers\", Proc. IEEE Infocom, March 1999.",
      "ja": "\"ビジーサーバー上のTCPとその効果でTIME-WAIT状態\" [FABER]フェーバー、T.、タッチ、J.、およびW.越、PROC。 IEEEインフォコム、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[GIST] Schulzrinne, H. and R. Hancock, \"GIST: General Internet Signalling Transport\", Work in Progress, July 2008.",
      "ja": "[GIST] Schulzrinneと、H.とR.ハンコック、 \"GIST：一般的なインターネットシグナリング交通\"、進歩、2008年7月に作業。"
    },
    {
      "indent": 3,
      "text": "[ICE] Rosenberg, J., \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols\", Work in Progress, October 2007.",
      "ja": "[ICE]ローゼンバーグ、J.、「インタラクティブ接続確立（ICE）：オファー/回答プロトコルのためのネットワークアドレス変換（NAT）トラバーサルのための議定書」、進歩、2007年10月の作業。"
    },
    {
      "indent": 3,
      "text": "[NSLP] Stiemerling, M., Tschofenig, H., Aoun, C., and E. Davies, \"NAT/Firewall NSIS Signaling Layer Protocol (NSLP)\", Work in Progress, September 2008.",
      "ja": "[NSLP] Stiemerling、M.、Tschofenig、H.、アウン、C.、およびE.デイヴィス、 \"NAT /ファイアウォールNSISシグナリング層プロトコル（NSLP）\"、進歩、2008年9月の作業。"
    },
    {
      "indent": 3,
      "text": "[POSIX] IEEE Std. 1003.1-2001, \"Standard for Information Technology - Portable Operating System Interface (POSIX)\", Open Group Technical Standard: Base Specifications Issue 6, ISO/IEC 9945:2002, December 2001.",
      "ja": "[POSIX] IEEE STD。 1003.1-2001、 \"情報技術のための標準 - ポータブルオペレーティングシステムインタフェース（POSIX）\"、Open Groupの技術標準：基本仕様6号、ISO / IEC 9945：2002、2001年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC0896] Nagle, J., \"Congestion control in IP/TCP internetworks\", RFC 896, January 1984.",
      "ja": "[RFC0896]ネーグル、J.、 \"IP / TCPインターネットワークにおける輻輳制御\"、RFC 896、1984年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC0919] Mogul, J., \"Broadcasting Internet Datagrams\", STD 5, RFC 919, October 1984.",
      "ja": "[RFC0919]モーグル、J.、 \"放送インターネットデータグラム\"、STD 5、RFC 919、1984年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1112] Deering, S., \"Host extensions for IP multicasting\", STD 5, RFC 1112, August 1989.",
      "ja": "[RFC1112]デアリング、S.、STD 5、RFC 1112 \"IPマルチキャスティングのためのホスト拡大\"、1989年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1536] Kumar, A., Postel, J., Neuman, C., Danzig, P., and S. Miller, \"Common DNS Implementation Errors and Suggested Fixes\", RFC 1536, October 1993.",
      "ja": "[RFC1536]クマー、A.、ポステル、J.、ニューマン、C.、ダンツィヒ、P.、およびS. Millerの \"一般的なDNS実装エラーおよび推奨修正\"、RFC 1536、1993年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1546] Partridge, C., Mendez, T., and W. Milliken, \"Host Anycasting Service\", RFC 1546, November 1993.",
      "ja": "[RFC1546]ウズラ、C.、メンデス、T.、およびW.ミリケン、 \"ホストエニーキャストサービス\"、RFC 1546、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2309] Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering, S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G., Partridge, C., Peterson, L., Ramakrishnan, K., Shenker, S., Wroclawski, J., and L. Zhang, \"Recommendations on Queue Management and Congestion Avoidance in the Internet\", RFC 2309, April 1998.",
      "ja": "[RFC2309]ブレーデン、B.、クラーク、D.、クロウクロフト、J.、デイビー、B.、デアリング、S.、Estrin、D.、フロイド、S.、ヤコブソン、V.、Minshall、G.、ヤマウズラ、 C.、ピーターソン、L.、ラマクリシュナン、K.、Shenker、S.、Wroclawski、J.、およびL.チャン、 \"インターネットの待ち行列管理と輻輳回避の推薦\"、RFC 2309、1998年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2475] Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z., and W. Weiss, \"An Architecture for Differentiated Services\", RFC 2475, December 1998.",
      "ja": "[RFC2475]ブレイク、S.、ブラ​​ック、D.、カールソン、M.、デイヴィス、E.、王、Z.、およびW.ワイス、 \"差別化サービスのためのアーキテクチャ\"、RFC 2475、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2675] Borman, D., Deering, S., and R. Hinden, \"IPv6 Jumbograms\", RFC 2675, August 1999.",
      "ja": "[RFC2675]ボーマン、D.、デアリング、S.、およびR. Hindenと \"IPv6のジャンボグラム\"、RFC 2675、1999年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2743] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, January 2000.",
      "ja": "[RFC2743]リン、J.、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェースバージョン2、アップデート1\"、RFC 2743、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3048] Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, \"Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer\", RFC 3048, January 2001.",
      "ja": "[RFC3048] Whetten、B.、Vicisano、L.、Kermode、R.、ハンドレー、M.、フロイド、S.、およびM.ルビー、 \"信頼できるマルチキャストトランスポート・ビルディング・ブロック一対多バルクデータ転送のための\" 、RFC 3048、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3124] Balakrishnan, H. and S. Seshan, \"The Congestion Manager\", RFC 3124, June 2001.",
      "ja": "[RFC3124]バラクリシュナン、H.とS. Seshan、 \"輻輳管理\"、RFC 3124、2001年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[RFC3261]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 \"SIP：セッション開始プロトコル\" 、RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3303] Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A., and A. Rayhan, \"Middlebox communication architecture and framework\", RFC 3303, August 2002.",
      "ja": "[RFC3303] Srisuresh、P.、Kuthan、J.、ローゼンバーグ、J.、モリター、A.、およびA. Rayhan、 \"ミドル通信アーキテクチャおよびフレームワーク\"、RFC 3303、2002年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 3493, February 2003.",
      "ja": "[RFC3493]ギリガン、R.、トムソン、S.、バウンド、J.、マッキャン、J.、およびW.スティーブンス、 \"IPv6の基本的なソケットインタフェース拡張\"、RFC 3493、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, July 2003.",
      "ja": "[RFC3550] Schulzrinneと、H.、Casner、S.、フレデリック、R.、およびV.ヤコブソン、 \"RTP：リアルタイムアプリケーションのためのトランスポートプロトコル\"、STD 64、RFC 3550、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3551] Schulzrinne, H. and S. Casner, \"RTP Profile for Audio and Video Conferences with Minimal Control\", STD 65, RFC 3551, July 2003.",
      "ja": "[RFC3551] Schulzrinneと、H.とS. Casner、 \"最小量のコントロールがあるオーディオとビデオ会議システムのためのRTPプロフィール\"、STD 65、RFC 3551、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, March 2004.",
      "ja": "[RFC3711] Baugher、M.、マグリュー、D.、Naslund、M.、カララ、E.、およびK. Norrman、 \"セキュアリアルタイム転送プロトコル（SRTP）\"、RFC 3711、2004年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3738] Luby, M. and V. Goyal, \"Wave and Equation Based Rate Control (WEBRC) Building Block\", RFC 3738, April 2004.",
      "ja": "[RFC3738]ルビー、M.およびV. Goyal氏、 \"波動と式ベースのレート制御（WEBRC）ビルディングブロック\"、RFC 3738、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3758] Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P. Conrad, \"Stream Control Transmission Protocol (SCTP) Partial Reliability Extension\", RFC 3758, May 2004.",
      "ja": "[RFC3758]スチュワート、R.、Ramalho、M.、謝、Q.、Tuexen、M.、およびP.コンラッド、 \"ストリーム制御伝送プロトコル（SCTP）部分的な信頼性拡張\"、RFC 3758、2004年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3819] Karn, P., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, \"Advice for Internet Subnetwork Designers\", BCP 89, RFC 3819, July 2004.",
      "ja": "[RFC3819]カーン、P.、ボルマン、C.、Fairhurst、G.、グロスマン、D.、ルートヴィヒ、R.、Mahdavi、J.、モンテネグロ、G.、タッチ、J.、およびL.ウッド、「アドバイスインターネットサブネットワークデザイナー」、BCP 89、RFC 3819、2004年7月のため。"
    },
    {
      "indent": 3,
      "text": "[RFC3851] Ramsdell, B., \"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.1 Message Specification\", RFC 3851, July 2004.",
      "ja": "[RFC3851] Ramsdell、B.、 \"/セキュア多目的インターネットメール拡張（S / MIME）バージョン3.1メッセージ仕様\"、RFC 3851、2004年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3852] Housley, R., \"Cryptographic Message Syntax (CMS)\", RFC 3852, July 2004.",
      "ja": "[RFC3852] Housley氏、R.、 \"暗号メッセージ構文（CMS）\"、RFC 3852、2004年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[RFC4301]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4302] Kent, S., \"IP Authentication Header\", RFC 4302, December 2005.",
      "ja": "[RFC4302]ケント、S.、 \"IP認証ヘッダー\"、RFC 4302、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "ja": "[RFC4303]ケント、S.、 \"IPカプセル化セキュリティペイロード（ESP）\"、RFC 4303、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4306] Kaufman, C., \"Internet Key Exchange (IKEv2) Protocol\", RFC 4306, December 2005.",
      "ja": "[RFC4306]カウフマン、C.、 \"インターネットキーエクスチェンジ（IKEv2の）プロトコル\"、RFC 4306、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4340] Kohler, E., Handley, M., and S. Floyd, \"Datagram Congestion Control Protocol (DCCP)\", RFC 4340, March 2006.",
      "ja": "[RFC4340]コーラー、E.、ハンドリー、M.、およびS.フロイド、 \"データグラム輻輳制御プロトコル（DCCP）\"、RFC 4340、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4341] Floyd, S. and E. Kohler, \"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 2: TCP-like Congestion Control\", RFC 4341, March 2006.",
      "ja": "[RFC4341]フロイド、S.、およびE.コーラー、 \"データグラム輻輳制御プロトコル（DCCP）輻輳制御ID 2用のプロフィール：TCPのような輻輳制御\"、RFC 4341、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4342] Floyd, S., Kohler, E., and J. Padhye, \"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 3: TCP-Friendly Rate Control (TFRC)\", RFC 4342, March 2006.",
      "ja": "[RFC4342]フロイド、S.、コーラー、E.、およびJ. Padhye、 \"データグラム混雑制御プロトコル（DCCP）輻輳制御ID 3のプロフィール：TCPフレンドリーレート制御（TFRC）\"、RFC 4342、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security\", RFC 4347, April 2006.",
      "ja": "[RFC4347]レスコラ、E.およびN. Modadugu、 \"データグラムトランスポート層セキュリティ\"、RFC 4347、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4654] Widmer, J. and M. Handley, \"TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification\", RFC 4654, August 2006.",
      "ja": "[RFC4654]ウィドマー、J.とM.ハンドリー、 \"TCPフレンドリーマルチキャスト輻輳制御（TFMCC）：プロトコル仕様\"、RFC 4654、2006年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4880] Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, \"OpenPGP Message Format\", RFC 4880, November 2007.",
      "ja": "[RFC4880]カラス、J.、Donnerhacke、L.、フィニー、H.、ショー、D.、およびR.セイヤー、 \"OpenPGPのメッセージフォーマット\"、RFC 4880、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., \"Stream Control Transmission Protocol\", RFC 4960, September 2007.",
      "ja": "[RFC4960]スチュワート、R.、 \"ストリーム制御伝送プロトコル\"、RFC 4960、2007年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4963] Heffner, J., Mathis, M., and B. Chandler, \"IPv4 Reassembly Errors at High Data Rates\", RFC 4963, July 2007.",
      "ja": "[RFC4963] Heffner、J.、マティス、M.、およびB.チャンドラー、 \"高速データレートでのIPv4の再構築エラー\"、RFC 4963、2007年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4987] Eddy, W., \"TCP SYN Flooding Attacks and Common Mitigations\", RFC 4987, August 2007.",
      "ja": "[RFC4987]エディ、W.、 \"TCPのSYNフラッド攻撃と共通の軽減策\"、RFC 4987、2007年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5082] Gill, V., Heasley, J., Meyer, D., Savola, P., and C. Pignataro, \"The Generalized TTL Security Mechanism (GTSM)\", RFC 5082, October 2007.",
      "ja": "[RFC5082]ギル、V.、Heasley、J.、マイヤー、D.、Savola、P.、およびC. Pignataro、 \"一般TTLセキュリティメカニズム（GTSM）\"、RFC 5082、2007年10月。"
    },
    {
      "indent": 3,
      "text": "[STEVENS] Stevens, W., Fenner, B., and A. Rudoff, \"UNIX Network Programming, The sockets Networking API\", Addison-Wesley, 2004.",
      "ja": "[STEVENS]スティーブンス、W.、フェナー、B.、およびA. Rudoff、 \"UNIXネットワークプログラミング、APIをネットワークソケット\"、アディソン・ウェズリー、2004。"
    },
    {
      "indent": 3,
      "text": "[TRILOGY] \"Trilogy Project\", <http://www.trilogy-project.org>.",
      "ja": "[TRILOGY] \"トリロジープロジェクト\"、<http://www.trilogy-project.org>。"
    },
    {
      "indent": 3,
      "text": "[UPnP] UPnP Forum, \"Internet Gateway Device (IGD) Standardized Device Control Protocol V 1.0\", November 2001.",
      "ja": "[UPnPの] UPnPフォーラム、 \"インターネットゲートウェイデバイス（IGD）標準化されたデバイス制御プロトコルV 1.0\"、2001年11月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Lars Eggert Nokia Research Center P.O. Box 407 Nokia Group 00045 Finland",
      "ja": "ラースEggertのノキア・リサーチセンター私書箱ボックス407ノキアグループ00045フィンランド"
    },
    {
      "indent": 3,
      "text": "Phone: +358 50 48 24461 EMail: lars.eggert@nokia.com URI: http://people.nokia.net/~lars/",
      "ja": "電話番号：+358 50 48 24461電子メール：lars.eggert@nokia.com URI：http://people.nokia.net/~lars/"
    },
    {
      "indent": 3,
      "text": "Godred Fairhurst University of Aberdeen Department of Engineering Fraser Noble Building Aberdeen AB24 3UE Scotland",
      "ja": "エンジニアリング・フレイザーノーブルビルアバディーンAB24 3UEスコットランドのアバディーン部門のGodred Fairhurst大学"
    },
    {
      "indent": 3,
      "text": "EMail: gorry@erg.abdn.ac.uk URI: http://www.erg.abdn.ac.uk/",
      "ja": "電子メール：gorry@erg.abdn.ac.uk URI：http://www.erg.abdn.ac.uk/"
    }
  ]
}