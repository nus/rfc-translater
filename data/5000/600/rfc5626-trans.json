{
  "title": {
    "text": "RFC 5626 - Managing Client-Initiated Connections in the Session Initiation Protocol (SIP)",
    "ja": "RFC 5626 - セッション開始プロトコル（SIP）におけるクライアント開始された接続を管理します"
  },
  "number": 5626,
  "created_at": "2019-10-24 00:21:09.197552+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                   C. Jennings, Ed.\nRequest for Comments: 5626                                 Cisco Systems\nUpdates: 3261, 3327                                         R. Mahy, Ed.\nCategory: Standards Track                                   Unaffiliated\n                                                           F. Audet, Ed.\n                                                              Skype Labs\n                                                            October 2009",
      "raw": true
    },
    {
      "indent": 16,
      "text": " Managing Client-Initiated Connections\nin the Session Initiation Protocol (SIP)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Session Initiation Protocol (SIP) allows proxy servers to initiate TCP connections or to send asynchronous UDP datagrams to User Agents in order to deliver requests. However, in a large number of real deployments, many practical considerations, such as the existence of firewalls and Network Address Translators (NATs) or the use of TLS with server-provided certificates, prevent servers from connecting to User Agents in this way. This specification defines behaviors for User Agents, registrars, and proxy servers that allow requests to be delivered on existing connections established by the User Agent. It also defines keep-alive behaviors needed to keep NAT bindings open and specifies the usage of multiple connections from the User Agent to its registrar.",
      "ja": "セッション開始プロトコル（SIP）は、プロキシサーバは、TCP接続を開始するか、要求を実現するために、ユーザエージェントに非同期UDPデータグラムを送信することができます。しかし、ファイアウォールやネットワークアドレス変換（NAT）またはサーバが提供する証明書とTLSの使用の有無など、実際の展開、多くの実用的な考慮事項、多数の中で、このようにユーザーエージェントへの接続からサーバーを防ぎます。この仕様は、要求がユーザーエージェントによって確立された既存の接続上で配信することを可能にするユーザエージェント、レジストラとプロキシサーバーのための動作を定義します。また、オープンなNATバインディングを維持するために必要なキープアライブ動作を定義し、そのレジストラへのユーザーエージェントからの複数の接続の使用を指定します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2009 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2009 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。のセクション4.eで説明したように、コードのコンポーネントは、簡素化されたBSDライセンスのテキストを含める必要があり、この文書から抽出されました"
    },
    {
      "indent": 3,
      "text": "the Trust Legal Provisions and are provided without warranty as described in the BSD License.",
      "ja": "トラスト法規定とBSDライセンスで説明したように、保証なしで提供されています。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n2.  Conventions and Terminology  . . . . . . . . . . . . . . . . .  5\n  2.1.  Definitions  . . . . . . . . . . . . . . . . . . . . . . .  5\n3.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .  6\n  3.1.  Summary of Mechanism . . . . . . . . . . . . . . . . . . .  6\n  3.2.  Single Registrar and UA  . . . . . . . . . . . . . . . . .  7\n  3.3.  Multiple Connections from a User Agent . . . . . . . . . .  8\n  3.4.  Edge Proxies . . . . . . . . . . . . . . . . . . . . . . . 10\n  3.5.  Keep-Alive Technique . . . . . . . . . . . . . . . . . . . 11\n    3.5.1.  CRLF Keep-Alive Technique  . . . . . . . . . . . . . . 12\n    3.5.2.  STUN Keep-Alive Technique  . . . . . . . . . . . . . . 12\n4.  User Agent Procedures  . . . . . . . . . . . . . . . . . . . . 13\n  4.1.  Instance ID Creation . . . . . . . . . . . . . . . . . . . 13\n  4.2.  Registrations  . . . . . . . . . . . . . . . . . . . . . . 14\n    4.2.1.  Initial Registrations  . . . . . . . . . . . . . . . . 14\n    4.2.2.  Subsequent REGISTER Requests . . . . . . . . . . . . . 16\n    4.2.3.  Third-Party Registrations  . . . . . . . . . . . . . . 17\n  4.3.  Sending Non-REGISTER Requests  . . . . . . . . . . . . . . 17\n  4.4.  Keep-Alives and Detecting Flow Failure . . . . . . . . . . 18\n    4.4.1.  Keep-Alive with CRLF . . . . . . . . . . . . . . . . . 19\n    4.4.2.  Keep-Alive with STUN . . . . . . . . . . . . . . . . . 21\n  4.5.  Flow Recovery  . . . . . . . . . . . . . . . . . . . . . . 21\n5.  Edge Proxy Procedures  . . . . . . . . . . . . . . . . . . . . 22\n  5.1.  Processing Register Requests . . . . . . . . . . . . . . . 22\n  5.2.  Generating Flow Tokens . . . . . . . . . . . . . . . . . . 23\n  5.3.  Forwarding Non-REGISTER Requests . . . . . . . . . . . . . 23\n    5.3.1.  Processing Incoming Requests . . . . . . . . . . . . . 24\n    5.3.2.  Processing Outgoing Requests . . . . . . . . . . . . . 24\n  5.4.  Edge Proxy Keep-Alive Handling . . . . . . . . . . . . . . 25\n6.  Registrar Procedures . . . . . . . . . . . . . . . . . . . . . 25\n7.  Authoritative Proxy Procedures: Forwarding Requests  . . . . . 27",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8.  STUN Keep-Alive Processing . . . . . . . . . . . . . . . . . . 28\n  8.1.  Use with SigComp . . . . . . . . . . . . . . . . . . . . . 29\n9.  Example Message Flow . . . . . . . . . . . . . . . . . . . . . 30\n  9.1.  Subscription to Configuration Package  . . . . . . . . . . 30\n  9.2.  Registration . . . . . . . . . . . . . . . . . . . . . . . 32\n  9.3.  Incoming Call and Proxy Crash  . . . . . . . . . . . . . . 34\n  9.4.  Re-Registration  . . . . . . . . . . . . . . . . . . . . . 37\n  9.5.  Outgoing Call  . . . . . . . . . . . . . . . . . . . . . . 38\n10. Grammar  . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n11. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 40\n  11.1. Flow-Timer Header Field  . . . . . . . . . . . . . . . . . 40\n  11.2. \"reg-id\" Contact Header Field Parameter  . . . . . . . . . 40\n  11.3. SIP/SIPS URI Parameters  . . . . . . . . . . . . . . . . . 41\n  11.4. SIP Option Tag . . . . . . . . . . . . . . . . . . . . . . 41\n  11.5. 430 (Flow Failed) Response Code  . . . . . . . . . . . . . 41\n  11.6. 439 (First Hop Lacks Outbound Support) Response Code . . . 42\n  11.7. Media Feature Tag  . . . . . . . . . . . . . . . . . . . . 42\n12. Security Considerations  . . . . . . . . . . . . . . . . . . . 43\n13. Operational Notes on Transports  . . . . . . . . . . . . . . . 44\n14. Requirements . . . . . . . . . . . . . . . . . . . . . . . . . 44\n15. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 45\n16. References . . . . . . . . . . . . . . . . . . . . . . . . . . 45\n  16.1. Normative References . . . . . . . . . . . . . . . . . . . 45\n  16.2. Informative References . . . . . . . . . . . . . . . . . . 47\nAppendix A.  Default Flow Registration Backoff Times . . . . . . . 49\nAppendix B.  ABNF  . . . . . . . . . . . . . . . . . . . . . . . . 49",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "There are many environments for SIP [RFC3261] deployments in which the User Agent (UA) can form a connection to a registrar or proxy but in which connections in the reverse direction to the UA are not possible. This can happen for several reasons, but the most likely is a NAT or a firewall in between the SIP UA and the proxy. Many such devices will only allow outgoing connections. This specification allows a SIP User Agent behind such a firewall or NAT to receive inbound traffic associated with registrations or dialogs that it initiates.",
      "ja": "ユーザエージェント（UA）はレジストラまたはプロキシへの接続を形成することができるが、ここでUAとは逆方向の接続が不可能である、SIP [RFC3261]の展開のための多くの環境があります。これにはいくつかの理由で発生することができますが、最も可能性の高いNATまたはSIP UAとプロキシの間でファイアウォールです。多くのこのようなデバイスは外部への接続を許可します。この仕様は、それが開始の登録やダイアログに関連したインバウンドトラフィックを受信するようにファイアウォールやNATの背後にあるSIPユーザエージェントを可能にします。"
    },
    {
      "indent": 3,
      "text": "Most IP phones and personal computers get their network configurations dynamically via a protocol such as the Dynamic Host Configuration Protocol (DHCP) [RFC2131]. These systems typically do not have a useful name in the Domain Name System (DNS) [RFC1035], and they almost never have a long-term, stable DNS name that is appropriate for use in the subjectAltName of a certificate, as required by [RFC3261]. However, these systems can still act as a Transport Layer Security (TLS) [RFC5246] client and form outbound connections to a proxy or registrar that authenticates with a server certificate. The server can authenticate the UA using a shared secret in a digest challenge (as defined in Section 22 of RFC 3261) over that TLS connection. This specification allows a SIP User Agent who has to initiate the TLS connection to receive inbound traffic associated with registrations or dialogs that it initiates.",
      "ja": "ほとんどのIP電話やパソコンには、動的ホスト構成プロトコル（DHCP）[RFC2131]などのプロトコルを介して動的にネットワーク構成を取得します。これらのシステムは、通常、ドメインネームシステム（DNS）[RFC1035]に便利な名前を持っていない、との要求に応じて、彼らは、[証明書ののsubjectAltNameでの使用に適している長期的、安定的なDNS名を持っていることはほとんどありませんRFC3261]。しかし、これらのシステムはまだトランスポート層セキュリティ（TLS）[RFC5246]クライアントとして動作し、サーバ証明書で認証プロキシまたはレジストラへのアウトバウンド接続を形成することができます。そのTLS接続を介して（RFC 3261のセクション22で定義されている）サーバがダイジェスト挑戦で共有秘密を使用してUAを認証することができます。この仕様は、それが開始の登録やダイアログに関連付けられている着信トラフィックを受信するTLS接続を開始しなければならないSIPユーザーエージェントを可能にします。"
    },
    {
      "indent": 3,
      "text": "The key idea of this specification is that when a UA sends a REGISTER request or a dialog-forming request, the proxy can later use this same network \"flow\" -- whether this is a bidirectional stream of UDP datagrams, a TCP connection, or an analogous concept in another transport protocol -- to forward any incoming requests that need to go to this UA in the context of the registration or dialog.",
      "ja": "これは、UDPデータグラム、TCP接続、または双方向の流れがあるかどうか - この仕様のキーアイデアは、UAはREGISTERリクエストまたはダイアログ形成要求を送信するときに、プロキシは、この後、同じネットワーク「流れ」を使うことができることです別のトランスポートプロトコルにおける類似の概念 - 登録またはダイアログのコンテキストでこのUAに行くために必要なすべての着信要求を転送します。"
    },
    {
      "indent": 3,
      "text": "For a UA to receive incoming requests, the UA has to connect to a server. Since the server can't connect to the UA, the UA has to make sure that a flow is always active. This requires the UA to detect when a flow fails. Since such detection takes time and leaves a window of opportunity for missed incoming requests, this mechanism allows the UA to register over multiple flows at the same time. This specification also defines two keep-alive schemes. The keep-alive mechanism is used to keep NAT bindings fresh, and to allow the UA to detect when a flow has failed.",
      "ja": "UAが着信要求を受信するために、UAは、サーバーに接続する必要があります。サーバはUAに接続できないので、UAは、流れが常にアクティブであることを確認する必要があります。これは、流れが失敗したときを検出するためにUAが必要です。そのような検出に時間がかかり、逃した着信要求のための機会の窓を残しているので、このメカニズムは、UAが同時に複数のフローを超える登録することができます。また、この仕様は2キープアライブスキームを定義します。キープアライブメカニズムは、新鮮なNATバインディングを維持するために、そしてフローが失敗した場合、UAが検出できるようにするために使用されます。"
    },
    {
      "indent": 0,
      "text": "2. Conventions and Terminology",
      "section_title": true,
      "ja": "2.表記と用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2.1. Definitions",
      "section_title": true,
      "ja": "2.1。定義"
    },
    {
      "indent": 3,
      "text": "Authoritative Proxy: A proxy that handles non-REGISTER requests for a specific Address-of-Record (AOR), performs the logical Location Server lookup described in [RFC3261], and forwards those requests to specific Contact URIs. (In [RFC3261], the role that is authoritative for REGISTER requests for a specific AOR is a Registration Server.)",
      "ja": "権威プロキシ：特定のアドレス・オブ・レコード（AOR）のための非REGISTER要求を処理するプロキシは、[RFC3261]に記載の論理ロケーションサーバルックアップを実行し、特定の連絡先のURIにそれらの要求を転送します。 （[RFC3261]では、特定のAORのためのREGISTERリクエストに対して権限のある役割は、登録サーバーです。）"
    },
    {
      "indent": 3,
      "text": "Edge Proxy: An edge proxy is any proxy that is located topologically between the registering User Agent and the Authoritative Proxy. The \"first\" edge proxy refers to the first edge proxy encountered when a UA sends a request.",
      "ja": "エッジ・プロキシ：エッジプロキシは、登録ユーザーエージェントと権威プロキシ間位相幾何学的に配置されているすべてのプロキシです。 「最初の」エッジプロキシは、UAがリクエストを送信するときに遭遇する最初のエッジプロキシを指します。"
    },
    {
      "indent": 3,
      "text": "Flow: A Flow is a transport-layer association between two hosts that is represented by the network address and port number of both ends and by the transport protocol. For TCP, a flow is equivalent to a TCP connection. For UDP a flow is a bidirectional stream of datagrams between a single pair of IP addresses and ports of both peers. With TCP, a flow often has a one-to-one correspondence with a single file descriptor in the operating system.",
      "ja": "フロー：フローは、両端のネットワークアドレスとポート番号によって、およびトランスポートプロトコルによって表される2つのホスト間のトランスポート層の関連付けです。 TCPの場合、フローは、TCP接続に相当します。 UDPのフローは、IPアドレスと、両方のピアのポートの単一の対の間のデータグラムの双方向の流れです。 TCPでは、流れは、多くの場合、オペレーティング・システム内の単一ファイルディスクリプタと1対1で対応しています。"
    },
    {
      "indent": 3,
      "text": "Flow Token: An identifier that uniquely identifies a flow which can be included in a SIP URI (Uniform Resource Identifier [RFC3986]).",
      "ja": "フロートークン：一意のSIP URI（ユニフォームリソース識別子[RFC3986]）に含めることができるフローを識別する識別子。"
    },
    {
      "indent": 3,
      "text": "reg-id: This refers to the value of a new header field parameter value for the Contact header field. When a UA registers multiple times, each for a different flow, each concurrent registration gets a unique reg-id value.",
      "ja": "REG-ID：これはContactヘッダーフィールドのための新しいヘッダフィールドパラメータ値の値を指します。 UAが複数回登録する場合、それぞれ異なるフローに対して、各同時登録はユニークREG-ID値を取得します。"
    },
    {
      "indent": 3,
      "text": "instance-id: This specification uses the word instance-id to refer to the value of the \"sip.instance\" media feature tag which appears as a \"+sip.instance\" Contact header field parameter. This is a Uniform Resource Name (URN) that uniquely identifies this specific UA instance.",
      "ja": "インスタンスID：この仕様は、「+ sip.instance」Contactヘッダーフィールドパラメータとして表示され、「sip.instance」メディア特徴タグの値を参照する単語インスタンスIDを使用します。これは、一意に特定UAインスタンスを識別するURN（Uniform Resource Name）です。"
    },
    {
      "indent": 3,
      "text": "\"ob\" Parameter: The \"ob\" parameter is a SIP URI parameter that has a different meaning depending on context. In a Path header field value, it is used by the first edge proxy to indicate that a flow token was added to the URI. In a Contact or Route header field value, it indicates that the UA would like other requests in the same dialog to be routed over the same flow.",
      "ja": "「OB」パラメータ：「OB」パラメータは、コンテキストに応じて異なる意味を持つSIP URIパラメータです。 Pathヘッダフィールド値には、フロートークンがURIに追加されたことを示すために、第1エッジプロキシによって使用されています。連絡先またはRouteヘッダーフィールド値では、UAは、同じフローを介してルーティングされる同じダイアログ内の他の要求をしたいと思いことを示しています。"
    },
    {
      "indent": 3,
      "text": "outbound-proxy-set: A set of SIP URIs (Uniform Resource Identifiers) that represents each of the outbound proxies (often edge proxies) with which the UA will attempt to maintain a direct flow. The first URI in the set is often referred to as the primary outbound proxy and the second as the secondary outbound proxy. There is no difference between any of the URIs in this set, nor does the primary/secondary terminology imply that one is preferred over the other.",
      "ja": "アウトバウンドプロキシ設定：UAが直接流れを維持しようとしているとアウトバウンドプロキシ（しばしばプロキシエッジ）のそれぞれを表すSIP URI（Uniform Resource Identifiers）のセット。セット内の最初のURIは、多くの場合、一次アウトバウンドプロキシと二次アウトバウンドプロキシとしての第2と呼ばれます。そここのセットのURIのいずれかの間に違いはありません、またプライマリ/セカンダリ用語は、一方が他方よりも優先されることを意味するものではありません。"
    },
    {
      "indent": 0,
      "text": "3. Overview",
      "section_title": true,
      "ja": "3.概要"
    },
    {
      "indent": 3,
      "text": "The mechanisms defined in this document are useful in several scenarios discussed below, including the simple co-located registrar and proxy, a User Agent desiring multiple connections to a resource (for redundancy, for example), and a system that uses edge proxies.",
      "ja": "この文書で定義されたメカニズムは、単純な共同設置レジストラとプロキシ、（例えば、冗長性のために）リソースへの複数の接続を希望するユーザエージェント、およびエッジプロキシを使用するシステムなど、以下に説明するいくつかのシナリオにおいて有用です。"
    },
    {
      "indent": 3,
      "text": "This entire section is non-normative.",
      "ja": "このセクション全体では非規範的です。"
    },
    {
      "indent": 0,
      "text": "3.1. Summary of Mechanism",
      "section_title": true,
      "ja": "3.1。メカニズムの概要"
    },
    {
      "indent": 3,
      "text": "Each UA has a unique instance-id that stays the same for this UA even if the UA reboots or is power cycled. Each UA can register multiple times over different flows for the same SIP Address of Record (AOR) to achieve high reliability. Each registration includes the instance-id for the UA and a reg-id label that is different for each flow. The registrar can use the instance-id to recognize that two different registrations both correspond to the same UA. The registrar can use the reg-id label to recognize whether a UA is creating a new flow or refreshing or replacing an old one, possibly after a reboot or a network failure.",
      "ja": "各UAは、UAが再起動または電源再投入であったとしても、このUAのために同じまま一意のインスタンスIDを持っています。各UAは、高い信頼性を達成するために、レコード（AOR）の同じSIPアドレスの異なるフローにわたって複数回登録することができます。各登録は、UAおよびフローごとに異なるREG-IDラベルのインスタンスIDを含みます。レジストラは、二つの異なる登録の両方が同一のUAに対応することを認識し、インスタンスIDを使用することができます。レジストラは、UAは、おそらく再起動やネットワークに障害が発生した後、古いものを新しいフローを作成または更新または交換されているかどうかを認識するために、REG-IDラベルを使用することができます。"
    },
    {
      "indent": 3,
      "text": "When a proxy goes to route a message to a UA for which it has a binding, it can use any one of the flows on which a successful registration has been completed. A failure to deliver a request on a particular flow can be tried again on an alternate flow. Proxies can determine which flows go to the same UA by comparing the instance-id. Proxies can tell that a flow replaces a previously abandoned flow by looking at the reg-id.",
      "ja": "プロキシがルーティングするために、それは結合を持っているUAにメッセージを行くと、それは成功し、登録が完了されたフローのいずれかを使用することができます。特定のフローに関する要求を提供する失敗は、代替フローに再試行することができます。プロキシは、インスタンスIDを比較して同一のUAに進み流れるかを決定することができます。プロキシは、流れがREG-IDを見て、以前に捨てられた流れを置き換えることを伝えることができます。"
    },
    {
      "indent": 3,
      "text": "When sending a dialog-forming request, a UA can also ask its first edge proxy to route subsequent requests in that dialog over the same flow. This is necessary whether the UA has registered or not.",
      "ja": "ダイアログ形成要求を送信する場合、UAは、同じフロー上そのダイアログ内の経路の後続の要求に対する第1のエッジプロキシに依頼することができます。これは、UAが登録されているか否かが必要です。"
    },
    {
      "indent": 3,
      "text": "UAs use a simple periodic message as a keep-alive mechanism to keep their flow to the proxy or registrar alive. For connection-oriented transports such as TCP this is based on carriage-return and line-feed sequences (CRLF), while for transports that are not connection oriented, this is accomplished by using a SIP-specific usage profile of STUN (Session Traversal Utilities for NAT) [RFC5389].",
      "ja": "UAはプロキシにその流れを維持するか、生きているレジストラするキープアライブメカニズムとして単純な周期メッセージを使用しています。接続指向されていないトランスポートのために、これは、STUN（セッショントラバーサルユーティリティのSIP固有の使用プロファイルを使用することによって達成されている間、TCPなどのコネクション型トランスポートのために、これは、キャリッジ・リターンおよび改行シーケンス（CRLF）に基づいていますNAT用）[RFC5389]。"
    },
    {
      "indent": 0,
      "text": "3.2. Single Registrar and UA",
      "section_title": true,
      "ja": "3.2。シングルRegistrarおよびUA"
    },
    {
      "indent": 3,
      "text": "In the topology shown below, a single server is acting as both a registrar and proxy.",
      "ja": "以下に示すトポロジーでは、単一のサーバは、レジストラとプロキシの両方として機能しています。"
    },
    {
      "indent": 6,
      "text": "+-----------+\n| Registrar |\n| Proxy     |\n+-----+-----+\n      |\n      |\n +----+--+\n | User  |\n | Agent |\n +-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "User Agents that form only a single flow continue to register normally but include the instance-id as described in Section 4.1. The UA also includes a \"reg-id\" Contact header field parameter that is used to allow the registrar to detect and avoid keeping invalid contacts when a UA reboots or reconnects after its old connection has failed for some reason.",
      "ja": "単一の流れを形成するユーザエージェントは、通常、登録し続けるが、セクション4.1で説明したようにインスタンスIDが含まれます。 UAはまた、レジストラが検出し、UAが再起動するか、その古い接続が何らかの理由で失敗した後に再接続したときに、無効な接触を保つ避けるためにできるようにするために使用される「REG-ID」Contactヘッダーフィールドパラメータを含んでいます。"
    },
    {
      "indent": 3,
      "text": "For clarity, here is an example. Bob's UA creates a new TCP flow to the registrar and sends the following REGISTER request.",
      "ja": "明確にするために、ここでの例です。ボブのUAは、レジストラに新しいTCPフローを作成し、以下のREGISTERリクエストを送信します。"
    },
    {
      "indent": 3,
      "text": "REGISTER sip:example.com SIP/2.0 Via: SIP/2.0/TCP 192.0.2.2;branch=z9hG4bK-bad0ce-11-1036 Max-Forwards: 70 From: Bob <sip:bob@example.com>;tag=d879h76 To: Bob <sip:bob@example.com> Call-ID: 8921348ju72je840.204 CSeq: 1 REGISTER Supported: path, outbound Contact: <sip:line1@192.0.2.2;transport=tcp>; reg-id=1; ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-000A95A0E128>\" Content-Length: 0",
      "ja": "70：ボブ・ブランチ= z9hG4bK-bad0ce-11から1036マックス・転送し、SIP / 2.0 / TCPの192.0.2.2：example.com SIP / 2.0経由：一口を登録<一口：bob@example.com>;タグ= d879h76 To：ボブ<SIP：bob@example.com>はコールIDを：8921348ju72je840.204のCSeq：1つのREGISTERサポート：パス、アウトバウンド連絡先：<SIP：line1@192.0.2.2;運輸= TCP>; REG-ID = 1。 ; + sip.instance = \"<壷：UUID：00000000-0000-1000-8000-000A95A0E128>\" のContent-Length：0"
    },
    {
      "indent": 3,
      "text": "The registrar challenges this registration to authenticate Bob. When the registrar adds an entry for this contact under the AOR for Bob, the registrar also keeps track of the connection over which it received this registration.",
      "ja": "レジストラは、ボブを認証するには、この登録に挑戦します。レジストラは、ボブのためのAORの下で、この連絡先のエントリを追加すると、レジストラはまた、この登録を受けた上で接続を追跡します。"
    },
    {
      "indent": 3,
      "text": "The registrar saves the instance-id (\"urn:uuid:00000000-0000-1000-8000-000A95A0E128\") and reg-id (\"1\") along with the rest of the Contact header field. If the instance-id and reg-id are the same as a previous registration for the same AOR, the registrar replaces the old Contact URI and flow information. This allows a UA that has rebooted to replace its previous registration for each flow with minimal impact on overall system load.",
      "ja": "Contactヘッダフィールドの残りの部分と一緒に（ \"00000000-0000-1000-8000-000A95A0E128：UUID URN\"）及びREG-ID（ \"1\"）レジストラは、インスタンスIDを保存します。インスタンスIDとREG-idは同じAORのために以前の登録と同じである場合、レジストラは、古い連絡先URIを置き換え、情報を流し。これは、システム全体の負荷への影響を最小限に抑えながら、各フローのために以前の登録を置き換えるために再起動したUAができます。"
    },
    {
      "indent": 3,
      "text": "When Alice sends a request to Bob, his authoritative proxy selects the target set. The proxy forwards the request to elements in the target set based on the proxy's policy. The proxy looks at the target set and uses the instance-id to understand if two targets both end up routing to the same UA. When the proxy goes to forward a request to a given target, it looks and finds the flows over which it received the registration. The proxy then forwards the request over an existing flow, instead of resolving the Contact URI using the procedures in [RFC3263] and trying to form a new flow to that contact.",
      "ja": "アリスがボブにリクエストを送信すると、彼の権威プロキシが設定された目標を選択します。プロキシは、プロキシのポリシーに基づいてターゲット・セット内の要素に要求を転送します。プロキシは、ターゲットセットを見て、二つの標的が同一のUAにルーティング終わる両方の場合は理解してインスタンスIDを使用しています。プロキシが指定されたターゲットに要求を転送するために行くとき、それは登録を受けた上で流れを見て、見つけました。プロキシは、代わりに、[RFC3263]の手順を使用して連絡先URIを解決し、その連絡先に新しい流れを形成しようとする、既存の流れの上に要求を転送します。"
    },
    {
      "indent": 3,
      "text": "As described in the next section, if the proxy has multiple flows that all go to this UA, the proxy can choose any one of the registration bindings for this AOR that has the same instance-id as the selected UA.",
      "ja": "次のセクションで説明したように、プロキシは、すべてのこのUAに進み、複数のフローを有する場合、プロキシは、選択されたUAと同じインスタンスIDを有し、このAORの登録バインディングのいずれかを選択することができます。"
    },
    {
      "indent": 0,
      "text": "3.3. Multiple Connections from a User Agent",
      "section_title": true,
      "ja": "3.3。ユーザーエージェントからの複数の接続"
    },
    {
      "indent": 3,
      "text": "There are various ways to deploy SIP to build a reliable and scalable system. This section discusses one such design that is possible with the mechanisms in this specification. Other designs are also possible.",
      "ja": "信頼性が高くスケーラブルなシステムを構築するためにSIPを配備するためのさまざまな方法があります。このセクションでは、本明細書では機構で可能であるような一の設計を論じています。他の設計も可能です。"
    },
    {
      "indent": 3,
      "text": "In the example system below, the logical outbound proxy/registrar for the domain is running on two hosts that share the appropriate state and can both provide registrar and outbound proxy functionality for the domain. The UA will form connections to two of the physical hosts that can perform the authoritative proxy/registrar function for the domain. Reliability is achieved by having the UA form two TCP connections to the domain.",
      "ja": "以下の例のシステムでは、ドメインの論理アウトバウンドプロキシ/レジストラは適切な状態を共有する2つのホスト上で実行され、両方のドメインのレジストラとアウトバウンドプロキシ機能を提供することができます。 UAは、ドメインの権限のプロキシ/レジストラの機能を実行することができる物理ホストの2つに接続を形成します。信頼性は、ドメインへのUAフォーム2つのTCP接続を有することによって達成されます。"
    },
    {
      "indent": 7,
      "text": "+-------------------+\n| Domain            |\n| Logical Proxy/Reg |\n|                   |\n|+-----+     +-----+|\n||Host1|     |Host2||\n|+-----+     +-----+|\n+---\\------------/--+\n     \\          /\n      \\        /\n       \\      /\n        \\    /\n       +------+\n       | User |\n       | Agent|\n       +------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The UA is configured with multiple outbound proxy registration URIs. These URIs are configured into the UA through whatever the normal mechanism is to configure the proxy address and AOR in the UA. If the AOR is alice@example.com, the outbound-proxy-set might look something like \"sip:primary.example.com\" and \"sip: secondary.example.com\". Note that each URI in the outbound-proxy-set could resolve to several different physical hosts. The administrative domain that created these URIs should ensure that the two URIs resolve to separate hosts. These URIs are handled according to normal SIP processing rules, so mechanisms like DNS SRV [RFC2782] can be used to do load-balancing across a proxy farm. The approach in this document does not prevent future extensions, such as the SIP UA configuration framework [CONFIG-FMWK], from adding other ways for a User Agent to discover its outbound-proxy-set.",
      "ja": "UAは、複数のアウトバウンドプロキシ登録のURIで構成されています。これらのURIは、通常のメカニズムは、UAでプロキシアドレスとAORを設定することですどんなを通じてUAに設定されています。そして「SIP：secondary.example.com」：AORがalice@example.comある場合は、アウトバウンドプロキシ・セットは、「primary.example.com一口」のように見えるかもしれません。アウトバウンドプロキシ・セット内の各URIは、いくつかの異なる物理ホストに解決できることに注意してください。これらのURIを作成した管理ドメインは、2つのURIは、別々のホストに解決することを確認する必要があります。 DNS SRV [RFC2782]のようなメカニズムがプロキシファーム間で負荷分散を行うために使用することができるので、これらのURIは、通常のSIP処理ルールに従って処理されます。この文書に記載されているアプローチは、そのアウトバウンドプロキシセットを発見するユーザエージェントのための他の方法を追加することから、そのようなSIP UA構成フレームワーク[CONFIG-FMWK]などの将来の拡張を妨げません。"
    },
    {
      "indent": 3,
      "text": "The domain also needs to ensure that a request for the UA sent to Host1 or Host2 is then sent across the appropriate flow to the UA. The domain might choose to use the Path header approach (as described in the next section) to store this internal routing information on Host1 or Host2.",
      "ja": "ドメインはまた、ホスト1又はホスト2に送信されたUAの要求が次にUAに適切なフローを介して送信されることを保証する必要があります。ドメインは、（次のセクションで説明したように）ホスト1又はホスト2に、この内部ルーティング情報を格納するためにパスヘッダアプローチを使用することを選択するかもしれません。"
    },
    {
      "indent": 3,
      "text": "When a single server fails, all the UAs that have a flow through it will detect a flow failure and try to reconnect. This can cause large loads on the server. When large numbers of hosts reconnect nearly simultaneously, this is referred to as the avalanche restart problem, and is further discussed in Section 4.5. The multiple flows to many servers help reduce the load caused by the avalanche restart. If a UA has multiple flows, and one of the servers fails, the UA delays a recommended amount of time before trying to form a new connection to replace the flow to the server that failed. By spreading out the time used for all the UAs to reconnect to a server, the load on the server farm is reduced.",
      "ja": "単一のサーバに障害が発生した場合、それを通る流れを持っているすべてのUAは流れの障害を検出し、再接続しようとします。これは、サーバーに大きな負荷を引き起こす可能性があります。ホストの多数がほぼ同時に再接続するときに、これがアバランシェ再起動の問題と呼ばれ、そしてさらに4.5節で議論されています。多くのサーバーに複数のフローは、雪崩の再起動による負荷を減らすのに役立ちます。 UAは、複数のフローがあり、いずれかのサーバに障害が発生した場合、UAは、障害が発生したサーバへの流れを置き換えるために新しい接続を形成しようとする前に、時間の推奨量を遅らせます。サーバーに再接続するために、すべてのUAに使用する時間を分散することで、サーバーファームの負荷が軽減されます。"
    },
    {
      "indent": 3,
      "text": "Scalability is achieved by using DNS SRV [RFC2782] to load-balance the primary connection across a set of machines that can service the primary connection, and also using DNS SRV to load-balance across a separate set of machines that can service the secondary connection. The deployment here requires that DNS is configured with one entry that resolves to all the primary hosts and another entry that resolves to all the secondary hosts. While this introduces additional DNS configuration, the approach works and requires no additional SIP extensions to [RFC3263].",
      "ja": "スケーラビリティはプライマリ接続にサービスを提供することができるマシンのセットにわたって負荷バランスプライマリ接続するために、DNS SRV [RFC2782]を使用して、また二次接続にサービスを提供することができる機械の別個のセットにわたってバランスをロードするためのDNS SRVを使用することによって達成されます。ここでの展開は、DNSがすべてのプライマリホストとすべてのセカンダリホストに解決別のエントリに解決されるつのエントリで構成されている必要があります。これは、追加のDNS設定を紹介しながら、アプローチが動作し、[RFC3263]に追加のSIP拡張を必要としません。"
    },
    {
      "indent": 3,
      "text": "Another motivation for maintaining multiple flows between the UA and its registrar is related to multihomed UAs. Such UAs can benefit from multiple connections from different interfaces to protect against the failure of an individual access link.",
      "ja": "UAとレジストラとの間の複数のフローを維持するための別の動機は、マルチホームのUAに関連しています。そのようなUAは、個々のアクセスリンクの障害から保護するために、異なるインターフェイスからの複数の接続から利益を得ることができます。"
    },
    {
      "indent": 0,
      "text": "3.4. Edge Proxies",
      "section_title": true,
      "ja": "3.4。エッジプロキシ"
    },
    {
      "indent": 3,
      "text": "Some SIP deployments use edge proxies such that the UA sends the REGISTER to an edge proxy that then forwards the REGISTER to the registrar. There could be a NAT or firewall between the UA and the edge proxy.",
      "ja": "いくつかのSIP展開は、UAは、その後、レジストラにREGISTERを転送するエッジプロキシにREGISTERを送信するように、エッジプロキシを使用しています。 UAとエッジプロキシ間のNATまたはファイアウォールがあるかもしれません。"
    },
    {
      "indent": 8,
      "text": "        +---------+\n        |Registrar|\n        |Proxy    |\n        +---------+\n         /      \\\n        /        \\\n       /          \\\n    +-----+     +-----+\n    |Edge1|     |Edge2|\n    +-----+     +-----+\n       \\           /\n        \\         /\n----------------------------NAT/FW\n          \\     /\n           \\   /\n          +------+\n          |User  |\n          |Agent |\n          +------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The edge proxy includes a Path header [RFC3327] so that when the proxy/registrar later forwards a request to this UA, the request is routed through the edge proxy.",
      "ja": "後で転送するプロキシ/レジストラこのUAに要求は、要求がエッジプロキシを介してルーティングされたときにエッジプロキシは、そのようPathヘッダ[RFC3327]を含みます。"
    },
    {
      "indent": 3,
      "text": "These systems can use effectively the same mechanism as described in the previous sections but need to use the Path header. When the edge proxy receives a registration, it needs to create an identifier value that is unique to this flow (and not a subsequent flow with the same addresses) and put this identifier in the Path header URI. This identifier has two purposes. First, it allows the edge proxy to map future requests back to the correct flow. Second, because the identifier will only be returned if the user authenticates with the registrar successfully, it allows the edge proxy to indirectly check the user's authentication information via the registrar. The identifier is placed in the user portion of a loose route in the Path header. If the registration succeeds, the edge proxy needs to map future requests (that are routed to the identifier value from the Path header) to the associated flow.",
      "ja": "これらのシステムは、効果的に前のセクションで説明したのと同じメカニズムを使用するが、Pathヘッダを使用する必要ができます。エッジプロキシ登録を受信すると、このフロー（およびなく、同じアドレスを持つ後続のフロー）に固有の識別子の値を作成し、PathヘッダURIに識別子を配置する必要があります。この識別子は、2つの目的があります。まず、エッジプロキシが戻って正しい流れに今後の要求をマッピングすることができます。ユーザが正常に登録して認証する場合、識別子のみが返されますので、第二に、それはエッジプロキシが間接的にレジストラを介してユーザの認証情報を確認することができます。識別子は、パスヘッダーの緩いルートのユーザ部分に配置されます。登録が成功した場合、エッジプロキシは、関連するフローに（Pathヘッダから識別子値にルーティングされる）将来の要求をマップする必要があります。"
    },
    {
      "indent": 3,
      "text": "The term edge proxy is often used to refer to deployments where the edge proxy is in the same administrative domain as the registrar. However, in this specification we use the term to refer to any proxy between the UA and the registrar. For example, the edge proxy may be inside an enterprise that requires its use, and the registrar could be from a service provider with no relationship to the enterprise. Regardless of whether they are in the same administrative domain, this specification requires that registrars and edge proxies support the Path header mechanism in [RFC3327].",
      "ja": "用語のエッジプロキシは、多くの場合、エッジプロキシは、レジストラと同じ管理ドメイン内での展開を参照するために使用されます。しかし、この仕様では、我々はUAとレジストラの間の任意のプロキシを参照するために用語を使用しています。例えば、エッジプロキシは、その使用を必要とする企業の内部であってもよく、レジストラは、企業に関係しないサービスプロバイダからとすることができます。かかわらず、それらが同じ管理ドメイン内にあるかどうかの、本明細書は、レジストラおよびエッジプロキシは[RFC3327]のパスヘッダメカニズムをサポートすることを必要とします。"
    },
    {
      "indent": 0,
      "text": "3.5. Keep-Alive Technique",
      "section_title": true,
      "ja": "3.5。キープアライブテクニック"
    },
    {
      "indent": 3,
      "text": "This document describes two keep-alive mechanisms: a CRLF keep-alive and a STUN keep-alive. Each of these mechanisms uses a client-to-server \"ping\" keep-alive and a corresponding server-to-client \"pong\" message. This ping-pong sequence allows the client, and optionally the server, to tell if its flow is still active and useful for SIP traffic. The server responds to pings by sending pongs. If the client does not receive a pong in response to its ping (allowing for retransmission for STUN as described in Section 4.4.2), it declares the flow dead and opens a new flow in its place.",
      "ja": "この文書では、2キープアライブメカニズムについて説明します。CRLFは、キープアライブとSTUNのキープアライブ。これらの各メカニズムは、クライアントからサーバーへの「pingを」キープアライブと対応するサーバからクライアントへの「ピンポン」のメッセージを使用しています。このピンポンシーケンスは、クライアントを可能にし、その流れがまだアクティブおよびSIPトラフィックのために有用である場合に伝えるために、サーバーをオプションで。サーバーはpongsを送信することにより、pingに応答します。クライアントは、（4.4.2項で説明したようにSTUNのための再送信を可能にする）そのピングに応答して、ピンポンを受信しない場合、それは死んだ流れを宣言し、その場所に新しい流れを開きます。"
    },
    {
      "indent": 3,
      "text": "This document also suggests timer values for these client keep-alive mechanisms. These timer values were chosen to keep most NAT and firewall bindings open, to detect unresponsive servers within 2 minutes, and to mitigate against the avalanche restart problem. However, the client may choose different timer values to suit its needs, for example to optimize battery life. In some environments, the server can also keep track of the time since a ping was received over a flow to guess the likelihood that the flow is still useful for delivering SIP messages.",
      "ja": "この文書はまた、これらのクライアントは、キープアライブメカニズムのためのタイマー値を示唆しています。これらのタイマー値は2分以内に応答しないサーバを検出し、雪崩の再起動の問題を軽減するために、オープンで最もNATやファイアウォールのバインディングを維持するために選ばれました。ただし、クライアントは、バッテリ寿命を最適化するために、例えば、そのニーズに合わせてさまざまなタイマー値を選択することができます。 pingが流れ、まだSIPメッセージを送達するのに有用である可能性を推測するために流れを介して受信されて以来、いくつかの環境では、サーバは、時間の経過を追うことができます。"
    },
    {
      "indent": 3,
      "text": "When the UA detects that a flow has failed or that the flow definition has changed, the UA needs to re-register and will use the back-off mechanism described in Section 4.5 to provide congestion relief when a large number of agents simultaneously reboot.",
      "ja": "UAは、フローが失敗したこと、またはフロー定義が変更されたことを検出した場合、UAは再登録する必要があり、多数のエージェントを同時に再起動したときに渋滞緩和を提供するために、4.5節に記載のバックオフ機構を使用します。"
    },
    {
      "indent": 3,
      "text": "A keep-alive mechanism needs to keep NAT bindings refreshed; for connections, it also needs to detect failure of a connection; and for connectionless transports, it needs to detect flow failures including changes to the NAT public mapping. For connection-oriented transports such as TCP [RFC0793] and SCTP [RFC4960], this specification describes a keep-alive approach based on sending CRLFs. For connectionless transport, such as UDP [RFC0768], this specification describes using STUN [RFC5389] over the same flow as the SIP traffic to perform the keep-alive.",
      "ja": "キープアライブメカニズムがリフレッシュNATバインディングを維持する必要があります。接続のために、それはまた、接続の障害を検出する必要があります。そしてコネクションレスのトランスポートのために、それはNATパブリックマッピングへの変更など、流れの障害を検出する必要があります。このようTCP [RFC0793]とSCTP [RFC4960]などの接続型トランスポートのために、この仕様はのCRLFを送信するに基づいてキープアライブのアプローチを説明します。そのようなUDP [RFC0768]などのコネクションレスのトランスポートのために、この仕様はキープアライブを実行するためにSIPトラフィックと同じフロー上STUN [RFC5389]を使用して記載されています。"
    },
    {
      "indent": 3,
      "text": "UAs and Proxies are also free to use native transport keep-alives; however, the application may not be able to set these timers on a per-connection basis, and the server certainly cannot make any assumption about what values are used. Use of native transport keep-alives is outside the scope of this document.",
      "ja": "UAとプロキシはまた、ネイティブの輸送キープアライブを使用するのは自由です。ただし、アプリケーションは、接続ごとにこれらのタイマーを設定することができないかもしれない、と、サーバは確かに値が使用されているものについての仮定をすることはできません。ネイティブトランスポートキープアライブの使用は、この文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "3.5.1. CRLF Keep-Alive Technique",
      "section_title": true,
      "ja": "3.5.1。 CRLFは、キープアライブテクニック"
    },
    {
      "indent": 3,
      "text": "This approach can only be used with connection-oriented transports such as TCP or SCTP. The client periodically sends a double-CRLF (the \"ping\") then waits to receive a single CRLF (the \"pong\"). If the client does not receive a \"pong\" within an appropriate amount of time, it considers the flow failed.",
      "ja": "このアプローチは、例えばTCP又はSCTPなどの接続指向トランスポートとともに使用することができます。クライアントは、定期的に、単一CRLF（「ピンポン」）を受信するのを待つダブルCRLF（「ピング」）を送信します。クライアントが適切な時間内「ピンポン」を受信しない場合、それが失敗した流れを考慮します。"
    },
    {
      "indent": 6,
      "text": "Note: Sending a CRLF over a connection-oriented transport is backwards compatible (because of requirements in Section 7.5 of [RFC3261]), but only implementations which support this specification will respond to a \"ping\" with a \"pong\".",
      "ja": "（なぜなら、[RFC3261]のセクション7.5の規定の）コネクション型トランスポートを介してCRLFを送信する下位互換性があるが、この仕様をサポートする唯一の実装は、「ポン」と「ピング」に応答します。注意してください。"
    },
    {
      "indent": 0,
      "text": "3.5.2. STUN Keep-Alive Technique",
      "section_title": true,
      "ja": "3.5.2。 STUNキープアライブテクニック"
    },
    {
      "indent": 3,
      "text": "This approach can only be used for connection-less transports, such as UDP.",
      "ja": "このアプローチは、UDPなどのコネクションレスのトランスポートのために使用することができます。"
    },
    {
      "indent": 3,
      "text": "For connection-less transports, a flow definition could change because a NAT device in the network path reboots and the resulting public IP address or port mapping for the UA changes. To detect this, STUN requests are sent over the same flow that is being used for the SIP traffic. The proxy or registrar acts as a limited Session Traversal Utilities for NAT (STUN) [RFC5389] server on the SIP signaling port.",
      "ja": "ネットワーク経路内のNATデバイスが再起動し、UAの変化のために、得られたパブリックIPアドレスまたはポートマッピングので、コネクションレスのトランスポートのために、フロー定義を変えることができます。これを検出するために、STUN要求がSIPトラフィックに使用されているのと同じ流れを介して送信されます。プロキシやSIPシグナリングポート上の限られたNATのためのセッショントラバーサルユーティリティ（STUN）[RFC5389]サーバとしてレジストラ働きます。"
    },
    {
      "indent": 6,
      "text": "Note: The STUN mechanism is very robust and allows the detection of a changed IP address and port. Many other options were considered, but the SIP Working Group selected the STUN-based approach. Approaches using SIP requests were abandoned because many believed that good performance and full backwards compatibility using this method were mutually exclusive.",
      "ja": "注意：STUNメカニズムは非常に堅牢で、変更したIPアドレスとポートの検出を可能にします。他の多くのオプションが考えられるが、SIPワーキンググループでは、STUNベースのアプローチを選択しました。多くは、このメソッドを使用して優れた性能と完全な後方互換性は相互に排他的であったと考えられているため、SIPリクエストを使用してのアプローチは放棄されました。"
    },
    {
      "indent": 0,
      "text": "4. User Agent Procedures",
      "section_title": true,
      "ja": "4.ユーザーエージェント手順"
    },
    {
      "indent": 0,
      "text": "4.1. Instance ID Creation",
      "section_title": true,
      "ja": "4.1。インスタンスIDの作成"
    },
    {
      "indent": 3,
      "text": "Each UA MUST have an Instance Identifier Uniform Resource Name (URN) [RFC2141] that uniquely identifies the device. Usage of a URN provides a persistent and unique name for the UA instance. It also provides an easy way to guarantee uniqueness within the AOR. This URN MUST be persistent across power cycles of the device. The instance ID MUST NOT change as the device moves from one network to another.",
      "ja": "各UAは、デバイスを一意に識別するインスタンス識別子ユニフォームリソース名（URN）[RFC2141]を持たなければなりません。 URNの使用法は、UAインスタンスの永続的な、ユニークな名前を提供します。また、AOR内の一意性を保証するための簡単な方法を提供します。このURNは、デバイスのパワーサイクル全体で持続的でなければなりません。デバイスは、あるネットワークから別のネットワークへ移動するときに、インスタンスIDは変更されてはいけません。"
    },
    {
      "indent": 3,
      "text": "A UA SHOULD create a Universally Unique Identifier (UUID) URN [RFC4122] as its instance-id. The UUID URN allows for non-centralized computation of a URN based on time, unique names (such as a MAC address), or a random number generator.",
      "ja": "UAは、そのインスタンスIDとして汎用一意識別子（UUID）URN [RFC4122]を作成する必要があります。 UUID URNは、時間に基づいて、URNの非集中型計算を可能にする、（例えば、MACアドレスなど）固有の名前、又は乱数発生器。"
    },
    {
      "indent": 6,
      "text": "Note: A device like a \"soft phone\", when first installed, can generate a UUID [RFC4122] and then save this in persistent storage for all future use. For a device such as a \"hard phone\", which will only ever have a single SIP UA present, the UUID can include the MAC address and be generated at any time because it is guaranteed that no other UUID is being generated at the same time on that physical device. This means the value of the time component of the UUID can be arbitrarily selected to be any time less than the time when the device was manufactured. A time of 0 (as shown in the example in Section 3.2) is perfectly legal as long as the device knows no other UUIDs were generated at this time on this device.",
      "ja": "注：「ソフトフォン」などのデバイス、最初にインストールしたとき、UUID [RFC4122]を生成し、すべての将来の使用のために永続的なストレージにこれを保存することができます。こうしたしか、単一のSIP UAの存在を持っているだろう「ハードフォン」、などのデバイスの場合、UUIDは、MACアドレスを含むことができ、他のUUIDが同時に生成されていないことが保証されているので、いつでも生成することその物理デバイス上。これは、UUIDの時間成分の値は、任意のデバイスが製造された時間よりも短い任意の時間となるように選択することができることを意味します。 （セクション3.2の例に示されるように）0の時間があれば、デバイスは、他のUUIDは、このデバイスのこの時点では発生しなかった知っているように完全に合法です。"
    },
    {
      "indent": 3,
      "text": "If a URN scheme other than UUID is used, the UA MUST only use URNs for which an RFC (from the IETF stream) defines how the specific URN needs to be constructed and used in the \"+sip.instance\" Contact header field parameter for outbound behavior.",
      "ja": "UUID以外URN方式を使用する場合、UAは、（IETFストリームから）RFCは、特定のURNはのための「+ sip.instance」Contactヘッダーフィールドパラメータで構成され、使用される必要がある方法を定義するためのURNを使用しなければなりませんアウトバウンド行動。"
    },
    {
      "indent": 3,
      "text": "To convey its instance-id in both requests and responses, the UA includes a \"sip.instance\" media feature tag as a UA characteristic [RFC3840]. This media feature tag is encoded in the Contact header field as the \"+sip.instance\" Contact header field parameter. One case where a UA could prefer to omit the \"sip.instance\" media feature tag is when it is making an anonymous request or some other privacy concern requires that the UA not reveal its identity.",
      "ja": "要求と応答の両方において、そのインスタンスIDを伝えるために、UAは、UA特性[RFC3840]として「sip.instance」メディア特徴タグを含みます。このメディア特徴タグは「+ sip.instance」ContactヘッダーフィールドパラメータとしてContactヘッダーフィールドに符号化されます。それは匿名の要求を行っているか、他のいくつかのプライバシーの懸念はUAがその身元を明らかにしないことを要求したときに、UAが「sip.instance」メディア特徴タグを省略することを好む可能性があるケースがあります。"
    },
    {
      "indent": 6,
      "text": "Note: [RFC3840] defines equality rules for callee capabilities parameters, and according to that specification, the \"sip.instance\" media feature tag will be compared by case-sensitive string comparison. This means that the URN will be encapsulated by angle brackets (\"<\" and \">\") when it is placed within the quoted string value of the \"+sip.instance\" Contact header field parameter. The case-sensitive matching rules apply only to the generic usages defined in the callee capabilities [RFC3840] and the caller preferences [RFC3841] specifications. When the instance ID is used in this specification, it is \"extracted\" from the value in the \"sip.instance\" media feature tag. Thus, equality comparisons are performed using the rules for URN equality that are specific to the scheme in the URN. If the element performing the comparisons does not understand the URN scheme, it performs the comparisons using the lexical equality rules defined in [RFC2141]. Lexical equality could result in two URNs being considered unequal when they are actually equal. In this specific usage of URNs, the only element that provides the URN is the SIP UA instance identified by that URN. As a result, the UA instance has to provide lexically equivalent URNs in each registration it generates. This is likely to be normal behavior in any case; clients are not likely to modify the value of the instance ID so that it remains functionally equivalent to (yet lexicographically different from) previous registrations.",
      "ja": "注：[RFC3840]は着信機能パラメータの等価規則を定義し、その仕様に応じて、「sip.instance」メディア特徴タグは大文字と小文字を区別する文字列比較によって比較します。これは、それが「+ sip.instance」Contactヘッダフィールドパラメータの引用符で囲まれた文字列値内に配置されたときにURNは（「<」と「>」）、角括弧によってカプセル化されることを意味します。大文字と小文字を区別マッチングルールは、着信機能[RFC3840]と発呼者の嗜好[RFC3841]の仕様で定義された一般的な用途にも適用されます。インスタンスIDは、本明細書で使用される場合、それは「sip.instance」メディア特徴タグの値から「抽出」されています。従って、等価比較はURNでスキームに固有のURN平等のルールを使用して実行されます。比較を実行する要素はURN方式を理解していない場合、それは[RFC2141]で定義された語彙等価規則を使用して比較を行います。字句平等は、彼らが実際に等しい場合に等しくないと見なされている2つのURNにつながる可能性があります。 URNのこの特定の使用では、URNを提供する唯一の要素は、そのURNによって識別されるSIP UAインスタンスです。結果として、UAインスタンスは、それが生成する各登録に字句等価のURNを提供しなければなりません。これは、どのような場合でも正常な行動である可能性が高いです。クライアントは、それが機能的に同等（まだから辞書的に異なる）以前の登録のままであるように、インスタンスIDの値を変更する可能性はありません。"
    },
    {
      "indent": 0,
      "text": "4.2. Registrations",
      "section_title": true,
      "ja": "4.2。登録"
    },
    {
      "indent": 0,
      "text": "4.2.1. Initial Registrations",
      "section_title": true,
      "ja": "4.2.1。初期登録"
    },
    {
      "indent": 3,
      "text": "At configuration time, UAs obtain one or more SIP URIs representing the default outbound-proxy-set. This specification assumes the set is determined via any of a number of configuration mechanisms, and future specifications can define additional mechanisms such as using DNS to discover this set. How the UA is configured is outside the scope of this specification. However, a UA MUST support sets with at least two outbound proxy URIs and SHOULD support sets with up to four URIs.",
      "ja": "構成時に、UAは、デフォルトのアウトバウンドプロキシセットを表す1つのまたは複数のSIP URIを取得します。この仕様は、セットを構成機構の数のいずれかを介して決定されていると仮定し、そして将来の仕様は、このセットを発見するためにDNSを使用するなど、追加の機構を定義することができます。 UAが設定されているどのようにこの仕様の範囲外です。しかし、UAは、少なくとも二つのアウトバウンドプロキシのURIとのセットをサポートしなければならないし、最大4つのURIを持つセットをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "For each outbound proxy URI in the set, the User Agent Client (UAC) SHOULD send a REGISTER request using this URI as the default outbound proxy. (Alternatively, the UA could limit the number of flows formed to conserve battery power, for example). If the set has more than one URI, the UAC MUST send a REGISTER request to at least two of the default outbound proxies from the set. UAs that support this specification MUST include the outbound option tag in a Supported header field in a REGISTER request. Each of these REGISTER requests will use a unique Call-ID. Forming the route set for the request is outside the scope of this document, but typically results in sending the REGISTER such that the topmost Route header field contains a loose route to the outbound proxy URI.",
      "ja": "セット内の各アウトバウンドプロキシURIのために、ユーザエージェントクライアント（UAC）は、デフォルトのアウトバウンドプロキシとしてこのURIを使用してREGISTERリクエストを送るべきです。 （代替的に、UAは、例えば、バッテリ電力を節約するために形成されたフローの数を制限することができます）。セットが複数のURIを持っている場合は、UACがセットからデフォルトのアウトバウンドプロキシの少なくとも二つにREGISTERリクエストを送らなければなりません。この仕様をサポートするUAは、REGISTERリクエストでサポートされているヘッダフィールドのアウトバウンドオプションタグを含まなければなりません。これらのREGISTER要求のそれぞれは、固有のコール-IDを使用します。要求に設定された経路を形成することは、この文書の範囲外であるが、典型的には、最上位のルートヘッダフィールドは、アウトバウンドプロキシURIに緩い経路を含むようにREGISTERを送ることになります。"
    },
    {
      "indent": 3,
      "text": "REGISTER requests, other than those described in Section 4.2.3, MUST include an instance-id media feature tag as specified in Section 4.1.",
      "ja": "セクション4.1で指定されるようにインスタンスIDメディア特徴タグを含まなければなりません、セクション4.2.3に記載したもの以外の要求を、登録します。"
    },
    {
      "indent": 3,
      "text": "A UAC conforming to this specification MUST include in the Contact header field, a \"reg-id\" parameter that is distinct from other \"reg-id\" parameters used in other registrations that use the same \"+sip.instance\" Contact header field parameter and AOR. Each one of these registrations will form a new flow from the UA to the proxy. The sequence of reg-id values does not have to be sequential but MUST be exactly the same sequence of reg-id values each time the UA instance power cycles or reboots, so that the reg-id values will collide with the previously used reg-id values. This is so the registrar can replace the older registrations.",
      "ja": "この仕様に準拠するUACは、Contactヘッダフィールド、同じ「+ sip.instance」Contactヘッダーフィールドパラメータを使用する他の登録に使用される他の「REG-ID」パラメータから区別される、「REG-ID」のパラメータに含める必要そしてAOR。これらの登録のそれぞれは、プロキシへのUAからの新しい流れを形成することになります。 REG-ID値の配列は、連続である必要はないが、REG-ID値は、以前に使用REG-と衝突するように、REG-ID値たびUAインスタンス電源サイクルまたはリブートのとまったく同じ順序でなければなりませんID値。レジストラは、古い登録を置き換えることができるようにするためです。"
    },
    {
      "indent": 6,
      "text": "Note: The UAC can situationally decide whether to request outbound behavior by including or omitting the \"reg-id\" Contact header field parameter. For example, imagine the outbound-proxy-set contains two proxies in different domains, EP1 and EP2. If an outbound-style registration succeeded for a flow through EP1, the UA might decide to include 'outbound' in its Require header field when registering with EP2, in order to ensure consistency. Similarly, if the registration through EP1 did not support outbound, the UA might not register with EP2 at all.",
      "ja": "注意：UACは、状況的に含む、または「REG-ID」Contactヘッダーフィールドパラメータを省略することにより、発信動作を要求するかどうかを決定することができます。例えば、アウトバウンドプロキシセットが異なるドメインの2つのプロキシ、EP1およびEP2を含有する想像。アウトバウンド・スタイルの登録はEP1を通過する流れのために成功した場合、UAは、一貫性を確保するために、EP2の登録時にそのRequireヘッダーフィールドに「アウトバウンド」を含むことを決定するかもしれません。 EP1を通して登録が発信をサポートしていませんでした場合は同様に、UAは全くEP2に登録しない場合があります。"
    },
    {
      "indent": 3,
      "text": "The UAC MUST support the Path header [RFC3327] mechanism, and indicate its support by including the 'path' option-tag in a Supported header field value in its REGISTER requests. Other than optionally examining the Path vector in the response, this is all that is required of the UAC to support Path.",
      "ja": "UACは、Pathヘッダ[RFC3327]メカニズムをサポートし、そのREGISTER要求でサポートされているヘッダフィールド値に「パス」オプションタグを含めることにより、そのサポートを示さなければなりません。必要に応じて対応してパスベクトルを調べる以外に、これはパスをサポートするために、UACに要求されるすべてです。"
    },
    {
      "indent": 3,
      "text": "The UAC examines successful registration responses for the presence of an outbound option-tag in a Require header field value. Presence of this option-tag indicates that the registrar is compliant with this specification, and that any edge proxies which needed to participate are also compliant. If the registrar did not support outbound, the UA has potentially registered an un-routable contact. It is the responsibility of the UA to remove any inappropriate Contacts.",
      "ja": "UACは、Requireヘッダーフィールド値のアウトバウンドオプションタグの存在のために成功した登録応答を調べます。このオプション・タグの存在は、レジストラは、この仕様に準拠していることを示しており、参加するために必要な任意のエッジプロキシも準拠していること。レジストラは、発信をサポートしていない場合は、UAは、潜在的に非ルーティング可能な連絡先を登録しています。任意の不適切な連絡先を削除するUAの責任です。"
    },
    {
      "indent": 3,
      "text": "If outbound registration succeeded, as indicated by the presence of the outbound option-tag in the Require header field of a successful registration response, the UA begins sending keep-alives as described in Section 4.4.",
      "ja": "アウトバウンド登録が成功した場合は成功した登録応答のRequireヘッダーフィールドのアウトバウンドオプションタグの存在によって示されるように、UAは、キープアライブを4.4節で説明したように送信を開始します。"
    },
    {
      "indent": 6,
      "text": "Note: The UA needs to honor 503 (Service Unavailable) responses to registrations as described in [RFC3261] and [RFC3263]. In particular, implementors should note that when receiving a 503 (Service Unavailable) response with a Retry-After header field, the UA is expected to wait the indicated amount of time and retry the registration. A Retry-After header field value of 0 is valid and indicates the UA is expected to retry the REGISTER request immediately. Implementations need to ensure that when retrying the REGISTER request, they revisit the DNS resolution results such that the UA can select an alternate host from the one chosen the previous time the URI was resolved.",
      "ja": "注意：UAは、[RFC3261]と[RFC3263]で説明したように登録する503（サービス利用不可）応答を尊重する必要があります。具体的には、実装は、再試行の後ヘッダフィールドを持つ503（サービス利用不可）応答を受信した場合、UAは、時間の指示された量を待って、登録を再試行することが期待されていることに注意すべきです。 0のリトライ後、ヘッダーフィールドの値が有効であり、UAは直ちにREGISTERリクエストを再試行することが期待されていることを示します。実装は、再試行REGISTER要求は、それらがDNS解決の結果を再検討するとき、UAはURIが解決された前回選択されたものから交互のホストを選択することができるようにようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the registering UA receives a 439 (First Hop Lacks Outbound Support) response to a REGISTER request, it MAY re-attempt registration without using the outbound mechanism (subject to local policy at the client). If the client has one or more alternate outbound proxies available, it MAY re-attempt registration through such outbound proxies. See Section 11.6 for more information on the 439 response code.",
      "ja": "登録UAはREGISTER要求への439（最初のホップが発信がサポートされない）応答を受信した場合、それはアウトバウンドメカニズム（クライアントのローカルポリシーに従う）を使用せずに登録を再試行するかもしれません。クライアントが利用できる1つ以上の代替アウトバウンドプロキシを持っている場合は、そのようなアウトバウンドプロキシ経由の登録を再試行するかもしれません。 439応答コードの詳細については、セクション11.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Subsequent REGISTER Requests",
      "section_title": true,
      "ja": "4.2.2。後続のREGISTER要求"
    },
    {
      "indent": 3,
      "text": "Registrations for refreshing a binding and for removing a binding use the same instance-id and reg-id values as the corresponding initial registration where the binding was added. Registrations that merely refresh an existing binding are sent over the same flow as the original registration where the binding was added.",
      "ja": "バインディングをリフレッシュすると結合を添加した対応する初期登録と同じインスタンスID及びREG-ID値を使用して結合を除去するための登録。単に既存のバインディングをリフレッシュ登録は、添加した結合元の登録と同じフローを介して送信されます。"
    },
    {
      "indent": 3,
      "text": "If a re-registration is rejected with a recoverable error response, for example by a 503 (Service Unavailable) containing a Retry-After header, the UAC SHOULD NOT tear down the corresponding flow if the flow uses a connection-oriented transport such as TCP. As long as \"pongs\" are received in response to \"pings\", the flow SHOULD be kept active until a non-recoverable error response is received. This prevents unnecessary closing and opening of connections.",
      "ja": "再登録を再試行した後、ヘッダを含む503（サービス利用不可）で、例えば、回復可能なエラー応答で拒否された場合、フローは、TCPのようなコネクション型トランスポートを使用する場合、UACは、対応するフローを切断すべきではありません。回復不能エラー応答を受信するまで限り「pongs」を「ピング」に応答して受信されるように、フローがアクティブに維持されるべきです。これは、接続の不要な開閉を防止します。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Third-Party Registrations",
      "section_title": true,
      "ja": "4.2.3。サードパーティの登録"
    },
    {
      "indent": 3,
      "text": "In an initial registration or re-registration, a UA MUST NOT include a \"reg-id\" header field parameter in the Contact header field if the registering UA is not the same instance as the UA referred to by the target Contact header field. (This practice is occasionally used to install forwarding policy into registrars.)",
      "ja": "UAが目標Contactヘッダーフィールドにより参照として登録するUAは、同じインスタンスではない場合、最初の登録または再登録では、UAは、コンタクトヘッダフィールドに「REG-ID」ヘッダフィールドパラメータを含めることはできません。 （これは実際には時折、レジストラに転送ポリシーをインストールするために使用されます。）"
    },
    {
      "indent": 3,
      "text": "A UAC also MUST NOT include an instance-id feature tag or \"reg-id\" Contact header field parameter in a request to un-register all Contacts (a single Contact header field value with the value of \"*\").",
      "ja": "UACはまた、登録解除すべての連絡先（「*」の値を持つ単一のContactヘッダーフィールド値）への要求でインスタンスID機能タグまたは「REG-ID」Contactヘッダフィールドパラメータを含めることはできません。"
    },
    {
      "indent": 0,
      "text": "4.3. Sending Non-REGISTER Requests",
      "section_title": true,
      "ja": "4.3。非REGISTERリクエストを送信します"
    },
    {
      "indent": 3,
      "text": "When a UAC is about to send a request, it first performs normal processing to select the next hop URI. The UA can use a variety of techniques to compute the route set and accordingly the next hop URI. Discussion of these techniques is outside the scope of this document. UAs that support this specification SHOULD include the outbound option tag in a Supported header field in a request that is not a REGISTER request.",
      "ja": "UACは、リクエストを送信しようとするとき、それは第一次のホップURIを選択するために、通常の処理を行います。 UAは、ルートセットし、それに応じて次のホップURIを計算するために様々な技術を使用することができます。これらの技術の議論は、この文書の範囲外です。この仕様をサポートするUAはREGISTERリクエストでないリクエストにSupportedヘッダーフィールドでアウトバウンドオプションタグを含むべきです。"
    },
    {
      "indent": 3,
      "text": "The UAC performs normal DNS resolution on the next hop URI (as described in [RFC3263]) to find a protocol, IP address, and port. For protocols that don't use TLS, if the UAC has an existing flow to this IP address, and port with the correct protocol, then the UAC MUST use the existing connection. For TLS protocols, there MUST also be a match between the host production in the next hop and one of the URIs contained in the subjectAltName in the peer certificate. If the UAC cannot use one of the existing flows, then it SHOULD form a new flow by sending a datagram or opening a new connection to the next hop, as appropriate for the transport protocol.",
      "ja": "UACは、プロトコル、IPアドレス、およびポートを見つけるために次のホップURI（[RFC3263]に記載されているように）上に通常のDNS解決を行います。 UACは、このIPアドレスへの既存のフローがある場合、TLSを使用して、正しいプロトコルとポートしないプロトコルについては、その後、UACは、既存の接続を使用する必要があります。 TLSプロトコルのために、また、宿主ネクストホップの生産とピア証明書内のsubjectAltNameに含まれるURIの一方との間の一致がなければなりません。 UACが既存のフローのものを使用できない場合、それはトランスポート・プロトコルに応じて、データグラムを送信するか、次のホップへの新しい接続を開くことによって、新たな流れを形成すべきです。"
    },
    {
      "indent": 3,
      "text": "Typically, a UAC using the procedures of this document and sending a dialog-forming request will want all subsequent requests in the dialog to arrive over the same flow. If the UAC is using a Globally Routable UA URI (GRUU) [RFC5627] that was instantiated using a Contact header field value that included an \"ob\" parameter, the UAC sends the request over the flow used for registration, and subsequent requests will arrive over that same flow. If the UAC is not using such a GRUU, then the UAC adds an \"ob\" parameter to its Contact header field value. This will cause all subsequent requests in the dialog to arrive over the flow instantiated by the dialog-forming request. This case is typical when the request is sent prior to registration, such as in the initial subscription dialog for the configuration framework [CONFIG-FMWK].",
      "ja": "一般的に、UACこのドキュメントの手順を使用して、ダイアログを形成するリクエストを送信するには、ダイアログ内の後続のすべての要求が同じ流れの上に到着することになるでしょう。 UACが「OB」パラメータが含まContactヘッダーフィールド値を使用してインスタンス化されたグローバルにルーティング可能なUA URI（GRUU）[RFC5627]を使用している場合、UACは、登録のために使用されるフローオーバー要求を送信し、後続の要求が到着します同じ流れを超えます。 UACは、このようなGRUUを使用していない場合、UACは、そのContactヘッダーフィールド値に「OB」パラメータを追加します。これは、ダイアログ内のすべての後続の要求は、ダイアログ形成要求によってインスタンス化の流れの上に到着するようになります。この場合は、要求は、このような構成の枠組み[CONFIG-FMWK]の初期サブスクリプション・ダイアログのように、登録前に送信されたときに典型的です。"
    },
    {
      "indent": 6,
      "text": "Note: If the UAC wants a UDP flow to work through NATs or firewalls, it still needs to put the 'rport' parameter [RFC3581] in its Via header field value, and send from the port it is prepared to receive on. More general information about NAT traversal in SIP is described in [NAT-SCEN].",
      "ja": "注意：UACは、NATのか、ファイアウォール経由で動作するようにUDPフローを望んでいるならば、それはまだそのViaヘッダーフィールド値に「RPORT」パラメータ[RFC3581]を入れて、受信する準備ができているポートから送信する必要があります。 SIPにおけるNATトラバーサルに関する一般的な情報は、[NAT-SCEN]に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.4. Keep-Alives and Detecting Flow Failure",
      "section_title": true,
      "ja": "4.4。キープアライブと流量検出失敗"
    },
    {
      "indent": 3,
      "text": "Keep-alives are used for refreshing NAT/firewall bindings and detecting flow failure. Flows can fail for many reasons including the rebooting of NATs and the crashing of edge proxies.",
      "ja": "キープアライブは、NAT /ファイアウォールのバインディングをリフレッシュし、流れの障害を検出するために使用されています。フローはNATのの再起動およびエッジプロキシのクラッシュなど、さまざまな理由で失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "As described in Section 4.2, a UA that registers will begin sending keep-alives after an appropriate registration response. A UA that does not register (for example, a PSTN gateway behind a firewall) can also send keep-alives under certain circumstances.",
      "ja": "セクション4.2で説明したように、登録UAは、適切な登録応答後にキープアライブを送信し始めます。登録しないUAは、（例えば、ファイアウォールの背後にあるPSTNゲートウェイ）は、特定の状況下でキープアライブを送信することができます。"
    },
    {
      "indent": 3,
      "text": "Under specific circumstances, a UAC might be allowed to send STUN keep-alives even if the procedures in Section 4.2 were not completed, provided that there is an explicit indication that the target first-hop SIP node supports STUN keep-alives. For example, this applies to a non-registering UA or to a case where the UA registration succeeded, but the response did not include the outbound option-tag in the Require header field.",
      "ja": "特定の状況下では、UACは、セクション4.2の手順が完了しなかった場合でも、STUNのキープアライブを送信することを許可ターゲット最初のホップSIPノードはSTUNがキープアライブをサポートしていることを明示的な指示が存在することを提供されるかもしれません。例えば、これは、非登録UAまたはUAの登録が成功しましたが、応答はRequireヘッダーフィールドに、アウトバウンドオプションタグが含まれていなかった場合に適用されます。"
    },
    {
      "indent": 6,
      "text": "Note: A UA can \"always\" send a double CRLF (a \"ping\") over connection-oriented transports as this is already allowed by Section 7.5 of [RFC3261]. However a UA that did not register using outbound registration cannot expect a CRLF in response (a \"pong\") unless the UA has an explicit indication that CRLF keep-alives are supported as described in this section. Likewise, a UA that did not successfully register with outbound procedures needs explicit indication that the target first-hop SIP node supports STUN keep-alives before it can send any STUN messages.",
      "ja": "注：これは、すでに[RFC3261]のセクション7.5により許容されるUA「は常に」接続指向のトランスポート上に二重CRLF（「ピング」）を送信することができます。 UAは、このセクションで説明するようCRLFキープアライブがサポートされていることを明示していない限り、しかし、アウトバウンド登録を使って登録しなかったUAレスポンスでCRLF（「ピンポン」）を期待することはできません。同様に、成功したアウトバウンド手続きに登録しませんでしたUAは、それがどんなSTUNメッセージを送ることができる前に、ターゲット最初のホップのSIPノードはSTUNキープアライブをサポートしていることを明示する必要があります。"
    },
    {
      "indent": 3,
      "text": "A configuration option indicating keep-alive support for a specific target is considered an explicit indication. If these conditions are satisfied, the UA sends its keep-alives according to the same guidelines as those used when UAs register; these guidelines are described below.",
      "ja": "特定のターゲットのためのキープアライブのサポートを示す設定オプションを明示考えられています。これらの条件が満たされた場合、UAは、UAが登録する際に使用されるものと同じガイドラインに従ってそのキープアライブを送信します。これらのガイドラインは、以下に記載されています。"
    },
    {
      "indent": 3,
      "text": "The UA needs to detect when a specific flow fails. The UA actively tries to detect failure by periodically sending keep-alive messages using one of the techniques described in Sections 4.4.1 or 4.4.2. If a flow with a registration has failed, the UA follows the procedures in Section 4.2 to form a new flow to replace the failed one.",
      "ja": "UAは、特定のフローが失敗したときに検出する必要があります。 UAは、積極的に定期的にセクション4.4.1または4.4.2に記載されている技術のいずれかを使用してキープアライブメッセージを送信することにより、障害を検出しようとします。登録にフローが失敗した場合、UAは失敗したものを置き換えるために新しい流れを形成するために、4.2節の手順に従います。"
    },
    {
      "indent": 3,
      "text": "When a successful registration response contains the Flow-Timer header field, the value of this header field is the number of seconds the server is prepared to wait without seeing keep-alives before it could consider the corresponding flow dead. Note that the server would wait for an amount of time larger than the Flow-Timer in order to have a grace period to account for transport delay. The UA MUST send keep-alives at least as often as this number of seconds. If the UA uses the server-recommended keep-alive frequency it SHOULD send its keep-alives so that the interval between each keep-alive is randomly distributed between 80% and 100% of the server-provided time. For example, if the server suggests 120 seconds, the UA would send each keep-alive with a different frequency between 95 and 120 seconds.",
      "ja": "成功した登録応答がフロータイマーヘッダフィールドが含まれている場合は、このヘッダフィールドの値は、サーバが対応するフローが死んで考えることができる前にキープアライブを見ずに待つために準備された秒数です。サーバーは、輸送遅れを考慮するための猶予期間を持っているために、フロータイマーよりも大きな時間の量を待つことに注意してください。 UAは、この秒数と少なくとも同じ頻繁にキープアライブを送らなければなりません。 UAは、サーバー推奨キープアライブ周波数を使用する場合、各キープアライブ間隔がランダムに80％とサーバが提供する時間の100％の間に分布されるように、それは、そのキープアライブを送信するべきです。サーバが120秒を示唆している場合、例えば、UAは、各キープアライブ95と120秒の間で異なる周波数で送信することになります。"
    },
    {
      "indent": 3,
      "text": "If no Flow-Timer header field was present in a register response for this flow, the UA can send keep-alives at its discretion. The sections below provide RECOMMENDED default values for these keep-alives.",
      "ja": "何のフロータイマーのヘッダフィールドは、この流れのためのレジスタ応答に存在しない場合は、UAは、その裁量でキープアライブを送信することができます。以下のセクションでは、これらのキープアライブのために推奨されるデフォルト値を提供します。"
    },
    {
      "indent": 3,
      "text": "The client needs to perform normal [RFC3263] SIP DNS resolution on the URI from the outbound-proxy-set to pick a transport. Once a transport is selected, the UA selects the keep-alive approach that is recommended for that transport.",
      "ja": "クライアントからURIに通常[RFC3263] SIPのDNS解決を実行する必要がアウトバウンドプロキシ・トランスポート・セットを選択します。トランスポートが選択されると、UAはその輸送のために推奨されるキープアライブのアプローチを選択します。"
    },
    {
      "indent": 3,
      "text": "Section 4.4.1 describes a keep-alive mechanism for connection-oriented transports such as TCP or SCTP. Section 4.4.2 describes a keep-alive mechanism for connection-less transports such as UDP. Support for other transports such as DCCP [RFC4340] is for further study.",
      "ja": "4.4.1は、TCPやSCTPなどの接続型トランスポートのためのキープアライブメカニズムについて説明します。 4.4.2は、UDPなどのコネクションレストランスポートのキープアライブメカニズムについて説明します。このようDCCP [RFC4340]などの他のトランスポートのサポートは今後の検討課題です。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Keep-Alive with CRLF",
      "section_title": true,
      "ja": "4.4.1。キープアライブCRLFで"
    },
    {
      "indent": 3,
      "text": "This approach MUST only be used with connection oriented transports such as TCP or SCTP; it MUST NOT be used with connection-less transports such as UDP.",
      "ja": "このアプローチは、そのようなTCPやSCTPなどの接続指向のトランスポートで使用する必要があります。それは、UDPなどのコネクションレストランスポートを使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "A User Agent that forms flows checks if the configured URI to which the UA is connecting resolves to a connection-oriented transport (e.g., TCP and TLS over TCP).",
      "ja": "形成するユーザエージェントUAは、接続指向トランスポートに解決を接続した構成URIかどうかを確認する（TCPオーバー例えば、TCPおよびTLS）を流れます。"
    },
    {
      "indent": 3,
      "text": "For this mechanism, the client \"ping\" is a double-CRLF sequence, and the server \"pong\" is a single CRLF, as defined in the ABNF below:",
      "ja": "このメカニズムでは、クライアントが「pingが」ダブルCRLFシーケンスであり、以下ABNFで定義された「ピンポン」サーバーは、単一CRLFです。"
    },
    {
      "indent": 3,
      "text": "CRLF = CR LF double-CRLF = CR LF CR LF CR = %x0D LF = %x0A",
      "ja": "CRLF = CR LF二CRLF = CR LF CR LF CR =％x0D LF =％X0A"
    },
    {
      "indent": 3,
      "text": "The \"ping\" and \"pong\" need to be sent between SIP messages and cannot be sent in the middle of a SIP message. If sending over TLS, the CRLFs are sent inside the TLS protected channel. If sending over a SigComp [RFC3320] compressed data stream, the CRLF keep-alives are sent inside the compressed stream. The double CRLF is considered a single SigComp message. The specific mechanism for representing these characters is an implementation-specific matter to be handled by the SigComp compressor at the sending end.",
      "ja": "「ピング」と「ピンポンは、」SIPメッセージとの間で送信する必要があり、SIPメッセージの途中で送信することはできません。 TLS上で送信する場合は、のCRLFはTLSで保護チャネルの内側に送信されます。 SigCompの[RFC3320]の圧縮データストリーム上で送信した場合、CRLFは、キープアライブを圧縮ストリームの内部に送られます。ダブルCRLFは、単一のSigCompメッセージと考えられています。これらの文字を表すための特定のメカニズムは、送信端でのSigComp圧縮機によって処理される実装特有の問題です。"
    },
    {
      "indent": 3,
      "text": "If a pong is not received within 10 seconds after sending a ping (or immediately after processing any incoming message being received when that 10 seconds expires), then the client MUST treat the flow as failed. Clients MUST support this CRLF keep-alive.",
      "ja": "ピンポンがpingを送信した後10秒以内に受信されない（又は直ちに着信メッセージを処理した後、10秒が満了したときに受信される）場合は失敗したように、クライアントは、フローを処理しなければなりません。クライアントは、キープアライブこのCRLFをサポートしなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: This value of 10-second timeout was selected to be long enough that it allows plenty of time for a server to send a response even if the server is temporarily busy with an administrative activity. At the same time, it was selected to be small enough that a UA registered to two redundant servers with unremarkable hardware uptime could still easily provide very high levels of overall reliability. Although some Internet protocols are designed for round-trip times over 10 seconds, SIP for real-time communications is not really usable in these type of environments as users often abandon calls before waiting much more than a few seconds.",
      "ja": "注意：10秒のタイムアウトのこの値は、サーバが管理活動と一時的にビジー状態であっても、応答を送信するサーバー用にたくさんの時間を可能にすることを十分に長くなるように選択されました。同時に、それが目立たないハードウェアの稼働時間を持つ2台の冗長サーバに登録されたUAはまだ簡単に全体的な信頼性の非常に高いレベルを提供できることを十分に小さくなるように選択されました。一部のインターネットプロトコルが10秒以上往復時間のために設計されていますが、ユーザーは、多くの場合、数秒よりもはるかに多くを待っている前に、呼び出しを放棄するよう、リアルタイム通信のためのSIPは、実際に使用可能な環境でのこれらのタイプではありません。"
    },
    {
      "indent": 3,
      "text": "When a Flow-Timer header field is not provided in the most recent success registration response, the proper selection of keep-alive frequency is primarily a trade-off between battery usage and availability. The UA MUST select a random number between a fixed or configurable upper bound and a lower bound, where the lower bound is 20% less then the upper bound. The fixed upper bound or the default configurable upper bound SHOULD be 120 seconds (95 seconds for the lower bound) where battery power is not a concern and 840 seconds (672 seconds for the lower bound) where battery power is a concern. The random number will be different for each keep-alive \"ping\".",
      "ja": "フロータイマーのヘッダフィールドは、最新の成功登録応答で提供されていない場合は、キープアライブ周波数の適切な選択は、主にバッテリの使用量と可用性の間のトレードオフです。 UAは、下限が上限を20％少ない場合、固定または設定可能な上限と下限の間の乱数を選択しなければなりません。固定された上限またはデフォルト設定上限はバッテリ電力がバッテリ電源が懸念される懸念と840秒（下限用の672秒）ではありません120秒（下限95秒）であるべきです。乱数は、各キープアライブ「のping」ごとに異なります。"
    },
    {
      "indent": 6,
      "text": "Note on selection of time values: the 120-second upper bound was chosen based on the idea that for a good user experience, failures normally will be detected in this amount of time and a new connection will be set up. The 14-minute upper bound for battery-powered devices was selected based on NATs with TCP timeouts as low as 15 minutes. Operators that wish to change the relationship between load on servers and the expected time that a user might not receive inbound communications will probably adjust this time. The 95-second lower bound was chosen so that the jitter introduced will result in a relatively even load on the servers after 30 minutes.",
      "ja": "時間値の選択に注意：上限120秒、良好なユーザ体験のために、失敗は通常この時間内に検出され、新しい接続がセットアップされるであろうという考えに基づいて選択しました。上部のバッテリ駆動機器行きの14分は、TCPとNATをに基づいて選択された15分ほどの低いタイムアウト。ユーザーは、インバウンド通信を受信しない場合がありますことをサーバーの負荷との間の関係と予想される時間を変更したい事業者は、おそらく、この時間を調整します。導入されたジッタが比較的さえ30分後にサーバーの負荷になりますように、下限95秒を選択しました。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Keep-Alive with STUN",
      "section_title": true,
      "ja": "4.4.2。キープアライブSTUNと"
    },
    {
      "indent": 3,
      "text": "This approach MUST only be used with connection-less transports, such as UDP; it MUST NOT be used for connection-oriented transports such as TCP and SCTP.",
      "ja": "このアプローチは、例えばUDPなどのコネクションレス型トランスポート、と共に使用されなければなりません。それは、TCPやSCTPなどの接続型トランスポートのために使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "A User Agent that forms flows checks if the configured URI to which the UA is connecting resolves to use the UDP transport. The UA can periodically perform keep-alive checks by sending STUN [RFC5389] Binding Requests over the flow as described in Section 8. Clients MUST support STUN-based keep-alives.",
      "ja": "形成するユーザエージェントUAはUDPトランスポートを使用に解決を接続した構成URI場合チェックを流れます。 UAは、定期的にクライアントは、STUNベースキープアライブをサポートしなければならないセクション8に記載されているようにSTUN [RFC5389]をフロー上バインディング要求を送信することによって、キープアライブチェックを実行することができます。"
    },
    {
      "indent": 3,
      "text": "When a Flow-Timer header field is not included in a successful registration response, the time between each keep-alive request SHOULD be a random number between 24 and 29 seconds.",
      "ja": "フロータイマヘッダフィールドが成功した登録応答に含まれていない場合、各キープアライブ要求の間の時間は、24と29秒の間の乱数であるべきです。"
    },
    {
      "indent": 6,
      "text": "Note on selection of time values: the upper bound of 29 seconds was selected, as many NATs have UDP timeouts as low as 30 seconds. The 24-second lower bound was selected so that after 10 minutes the jitter introduced by different timers will make the keep-alive requests unsynchronized to evenly spread the load on the servers. Note that the short NAT timeouts with UDP have a negative impact on battery life.",
      "ja": "時間値の選択に注意してください：29秒の上限を選択した、多くのNATは、UDPは30秒ほどの低いタイムアウト持っているとして。 10分後に別のタイマーによって導入されたジッタが均等にサーバーの負荷を分散するためにキープアライブ要求が非同期になりますように、下限を24秒を選択しました。バッテリ寿命にマイナスの影響を与える短いNATは、UDPでタイムアウトことに注意してください。"
    },
    {
      "indent": 3,
      "text": "If a STUN Binding Error Response is received, or if no Binding Response is received after 7 retransmissions (16 times the STUN \"RTO\" timer -- where RTO is an estimate of round-trip time), the UA considers the flow failed. If the XOR-MAPPED-ADDRESS in the STUN Binding Response changes, the UA MUST treat this event as a failure on the flow.",
      "ja": "STUNバインディングエラー応答が受信された場合、またはバインディングレスポンスが7つの再送（16回STUN「RTO」タイマー -  RTOは往復時間の推定値である）の後に受信されない場合、UAは、フローは失敗したと見なします。 STUNでXOR-MAPPED-ADDRESSは、レスポンスの変更をバインドした場合、UAは、流れの障害としてこのイベントを扱わなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.5. Flow Recovery",
      "section_title": true,
      "ja": "4.5。流れの回復"
    },
    {
      "indent": 3,
      "text": "When a flow used for registration (through a particular URI in the outbound-proxy-set) fails, the UA needs to form a new flow to replace the old flow and replace any registrations that were previously sent over this flow. Each new registration MUST have the same reg-id value as the registration it replaces. This is done in much the same way as forming a brand new flow as described in Section 4.2; however, if there is a failure in forming this flow, the UA needs to wait a certain amount of time before retrying to form a flow to this particular next hop.",
      "ja": "（アウトバウンドプロキシ・セット内の特定のURIを介して）登録のために使用されるフローが失敗した場合、UAは、古いフローを交換し、以前にこのフローを介して送信されたすべての登録を置き換えるために新しい流れを形成する必要があります。それぞれの新規登録は、それが置き換わる登録と同じREG-id値を持たなければなりません。これは、4.2節で説明したように、ブランドの新しい流れを形成することとほとんど同じ方法で行われます。このフローを形成する際に障害が発生した場合は、UAは、この特定の次のホップへの流れを形成するために再試行する前に一定の時間を待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "The amount of time to wait depends if the previous attempt at establishing a flow was successful. For the purposes of this section, a flow is considered successful if outbound registration succeeded, and if keep-alives are in use on this flow, at least one subsequent keep-alive response was received.",
      "ja": "流れを確立で前の試行が成功した場合に待機する時間の量が左右される。本項の目的のために、アウトバウンドの登録が成功した場合、フローは成功したとみなされ、およびキープアライブはこのフローで使用されている場合は、少なくとも一つの後続のキープアライブ応答が受信されました。"
    },
    {
      "indent": 3,
      "text": "The number of seconds to wait is computed in the following way. If all of the flows to every URI in the outbound proxy set have failed, the base-time is set to a lower value (with a default of 30 seconds); otherwise, in the case where at least one of the flows has not failed, the base-time is set to a higher value (with a default of 90 seconds). The upper-bound wait time (W) is computed by taking two raised to the power of the number of consecutive registration failures for that URI, and multiplying this by the base-time, up to a configurable maximum time (with a default of 1800 seconds).",
      "ja": "待つ秒数は、次のように計算されます。アウトバウンドプロキシ・セット内のすべてのURIへの流れのすべてが失敗した場合、ベース時間（30秒の既定値）より低い値に設定されています。そうでない場合は、フローの少なくとも一方が故障していない場合には、ベース時間（90秒の既定値）より高い値に設定されています。上限待ち時間（W）は1800の既定値（設定最大時間まで、そのURIの連続登録失敗回数の乗二つ取り、ベース時間によって、これを乗算することによって計算されます秒）。"
    },
    {
      "indent": 3,
      "text": "W = min (max-time, (base-time * (2 ^ consecutive-failures)))",
      "ja": "W =分（MAX-時間、（ベース時間*（2 ^連続-障害）））"
    },
    {
      "indent": 3,
      "text": "These times MAY be configurable in the UA. The three times are:",
      "ja": "これらの時間は、UAに設定可能です。三回は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o max-time with a default of 1800 seconds",
      "ja": "1800秒のデフォルトとO MAX-時間"
    },
    {
      "indent": 3,
      "text": "o base-time (if all failed) with a default of 30 seconds",
      "ja": "30秒のデフォルトとOベース・タイム（すべてが失敗した場合）"
    },
    {
      "indent": 3,
      "text": "o base-time (if all have not failed) with a default of 90 seconds",
      "ja": "90秒のデフォルトとOベース・タイム（すべてが失敗していない場合）"
    },
    {
      "indent": 3,
      "text": "For example, if the base-time is 30 seconds, and there were three failures, then the upper-bound wait time is min(1800, 30*(2^3)) or 240 seconds. The actual amount of time the UA waits before retrying registration (the retry delay time) is computed by selecting a uniform random time between 50 and 100% of the upper-bound wait time. The UA MUST wait for at least the value of the retry delay time before trying another registration to form a new flow for that URI (a 503 response to an earlier failed registration attempt with a Retry-After header field value may cause the UA to wait longer).",
      "ja": "ベース時間は30秒で、3つの失敗があった場合、例えば、その上限待ち時間分（^ 3 1800、30 *（2））、または240秒です。 UAは、リトライ登録（再試行遅延時間）前に待機時間の実際の量は、上限待ち時間の50と100％の間の一様ランダムな時間を選択することによって計算されます。 UAは待つようにUAを引き起こす可能性があり、再試行-Afterヘッダフィールド値を持つ、以前失敗した登録の試みにそのURI（503応答のための新たな流れを形成するために、別の登録をしようとする前に、再試行の遅​​延時間の少なくとも価値を待つ必要がありますより長いです）。"
    },
    {
      "indent": 3,
      "text": "To be explicitly clear on the boundary conditions: when the UA boots, it immediately tries to register. If this fails and no registration on other flows succeed, the first retry happens somewhere between 30 and 60 seconds after the failure of the first registration request. If the number of consecutive-failures is large enough that the maximum of 1800 seconds is reached, the UA will keep trying indefinitely with a random time of 15 to 30 minutes between each attempt.",
      "ja": "境界条件に明示的にクリアにするために：UAブーツ、それがすぐ登録しようとします。これが失敗し、他のフローには登録が成功しない場合は、最初の再試行は、最初の登録要求の失敗後30〜60秒の間のどこかに起こります。連続して、失敗の数は1800秒の最大値に達していることを十分に大きい場合、UAは各試行の間に15〜30分のランダムな時間を無期限に挑戦し続けます。"
    },
    {
      "indent": 0,
      "text": "5. Edge Proxy Procedures",
      "section_title": true,
      "ja": "5.エッジ・プロキシ手続き"
    },
    {
      "indent": 0,
      "text": "5.1. Processing Register Requests",
      "section_title": true,
      "ja": "5.1。登録要求を処理"
    },
    {
      "indent": 3,
      "text": "When an edge proxy receives a registration request with a \"reg-id\" header field parameter in the Contact header field, it needs to determine if it (the edge proxy) will have to be visited for any subsequent requests sent to the User Agent identified in the Contact header field, or not. If the edge proxy is the first hop, as indicated by the Via header field, it MUST insert its URI in a Path header field value as described in [RFC3327]. If it is not the first hop, it might still decide to add itself to the Path header based on local policy. In addition, if the edge proxy is the first SIP node after the UAC, the edge proxy either MUST store a \"flow token\" (containing information about the flow from the previous hop) in its Path URI or reject the request. The flow token MUST be an identifier that is unique to this network flow. The flow token MAY be placed in the userpart of the URI. In addition, the first node MUST include an \"ob\" URI parameter in its Path header field value. If the edge proxy is not the first SIP node after the UAC it MUST NOT place an \"ob\" URI parameter in a Path header field value. The edge proxy can determine if it is the first hop by examining the Via header field.",
      "ja": "エッジプロキシは、コンタクトヘッダフィールドに「REG-ID」ヘッダフィールドパラメータの登録要求を受信すると、それは（エッジプロキシ）が識別されたユーザエージェントに送信された後続の要求のために訪問しなければならないかどうかを決定する必要がありますContactヘッダーフィールドでは、そうでありませんか。エッジプロキシが最初のホップである場合は、[RFC3327]に記載されているように、Viaヘッダフィールドによって示されるように、それは、Pathヘッダフィールド値にそのURIを挿入する必要があります。それは最初のホップではない場合、それはまだローカルポリシーに基づいて、Pathヘッダに自分自身を追加することを決定するかもしれません。エッジプロキシがUAC後の最初のSIPノードである場合に加えて、エッジプロキシは、その経路URIに（前のホップからのフローに関する情報を含む）「フロートークン」を記憶または要求を拒否しなければならないのいずれか。フロートークンは、このネットワークのフローに固有の識別子でなければなりません。フロー・トークンは、URIのuserpartに配置することができます。加えて、最初のノードは、そのパスヘッダフィールド値の「OB」URIパラメータを含まなければなりません。エッジプロキシがUAC後の最初のSIPノードでない場合には、パスヘッダフィールド値に「OB」URIパラメータを置いてはいけません。エッジプロキシは、Viaヘッダフィールドを調べ、最初のホップであるかどうかを決定することができます。"
    },
    {
      "indent": 0,
      "text": "5.2. Generating Flow Tokens",
      "section_title": true,
      "ja": "5.2。生成フロートークン"
    },
    {
      "indent": 3,
      "text": "A trivial but impractical way to satisfy the flow token requirement in Section 5.1 involves storing a mapping between an incrementing counter and the connection information; however, this would require the edge proxy to keep an infeasible amount of state. It is unclear when this state could be removed, and the approach would have problems if the proxy crashed and lost the value of the counter. A stateless example is provided below. A proxy can use any algorithm it wants as long as the flow token is unique to a flow, the flow can be recovered from the token, and the token cannot be modified by attackers.",
      "ja": "セクション5.1で流れトークン要求を満たすために些細なしかし非現実的な方法は、インクリメントカウンタと接続情報との間のマッピングを格納することを含みます。しかし、これは国家の実現不可能な量を維持するためにエッジプロキシを必要とします。この状態を除去することができ、およびプロキシがクラッシュし、カウンタの値を失った場合のアプローチは問題を抱えているだろうというとき、それは不明です。ステートレス例が以下に提供されます。プロキシが、それはフロートークンが流れに固有である限り望んでいる任意のアルゴリズムを使用することができ、流れは、トークンから回収することができ、トークンは、攻撃者が変更することはできません。"
    },
    {
      "indent": 6,
      "text": "Example Algorithm: When the proxy boots, it selects a 20-octet crypto random key called K that only the edge proxy knows. A byte array, called S, is formed that contains the following information about the flow the request was received on: an enumeration indicating the protocol, the local IP address and port, the remote IP address and port. The HMAC of S is computed using the key K and the HMAC-SHA1-80 algorithm, as defined in [RFC2104]. The concatenation of the HMAC and S are base64 encoded, as defined in [RFC4648], and used as the flow identifier. When using IPv4 addresses, this will result in a 32-octet identifier.",
      "ja": "例アルゴリズム：プロキシブーツは、それが唯一のエッジプロキシが知っているKと呼ばれる20オクテットの暗号ランダムキーを選択します。プロトコル、ローカルIPアドレスとポート、リモートIPアドレスとポートを示す列挙型：Sと呼ばれるバイト配列は、要求が受信されたフローに関する以下の情報が含まれて形成されています。 [RFC2104]で定義されるようにSのHMACは、鍵KとHMAC-SHA1-80アルゴリズムを用いて計算されます。 HMACとSの連結は、[RFC4648]で定義されるように、base64エンコードされ、そしてフロー識別子として使用されます。 IPv4のアドレスを使用する場合、これは32オクテットの識別子をもたらすであろう。"
    },
    {
      "indent": 0,
      "text": "5.3. Forwarding Non-REGISTER Requests",
      "section_title": true,
      "ja": "5.3。非REGISTER要求を転送"
    },
    {
      "indent": 3,
      "text": "When an edge proxy receives a request, it applies normal routing procedures with the following additions. If the edge proxy receives a request where the edge proxy is the host in the topmost Route header field value, and the Route header field value contains a flow token, the proxy follows the procedures of this section. Otherwise the edge proxy skips the procedures in this section, removes itself from the Route header field, and continues processing the request.",
      "ja": "エッジプロキシは、要求を受信すると、以下の追加の通常のルーティング手順を適用します。エッジプロキシは、エッジプロキシは、最上位のルートヘッダフィールド値のホストで要求を受信し、Routeヘッダーフィールド値は、フロートークンが含まれている場合、プロキシは、このセクションの手順に従います。そうでなければ、エッジプロキシは、このセクションの手順をスキップRouteヘッダーフィールドから自身を削除し、要求を処理し続けます。"
    },
    {
      "indent": 3,
      "text": "The proxy decodes the flow token and compares the flow in the flow token with the source of the request to determine if this is an \"incoming\" or \"outgoing\" request.",
      "ja": "プロキシはトークン流をデコードし、これは、「受信」または「送信」要求であるかどうかを決定するために、要求のソースと流体トークンのフローを比較します。"
    },
    {
      "indent": 3,
      "text": "If the flow in the flow token identified by the topmost Route header field value matches the source IP address and port of the request, the request is an \"outgoing\" request; otherwise, it is an \"incoming\" request.",
      "ja": "最上位のルートヘッダフィールド値によって識別されたフロー・トークン内の流れは、ソースIPアドレスと要求のポートと一致する場合、要求は「発信」の要求です。それ以外の場合は、「入」の要求です。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Processing Incoming Requests",
      "section_title": true,
      "ja": "5.3.1。着信要求を処理"
    },
    {
      "indent": 3,
      "text": "If the Route header value contains an \"ob\" URI parameter, the Route header was probably copied from the Path header in a registration. If the Route header value contains an \"ob\" URI parameter, and the request is a new dialog-forming request, the proxy needs to adjust the route set to ensure that subsequent requests in the dialog can be delivered over a valid flow to the UA instance identified by the flow token.",
      "ja": "ルートヘッダの値が「OB」URIパラメータが含まれている場合は、Routeヘッダは、おそらく登録でPathヘッダからコピーされました。ルートヘッダの値が「OB」URIパラメータ、及び要求が新しいダイアログ形成要求であるが含まれている場合、プロキシは、ダイアログ内の後続リクエストがUAへの有効な流れを介して配信することができるように設定された経路を調整する必要がありますフロー・トークンによって識別されたインスタンス。"
    },
    {
      "indent": 6,
      "text": "Note: A simple approach to satisfy this requirement is for the proxy to add a Record-Route header field value that contains the flow-token, by copying the URI in the Route header minus the \"ob\" parameter.",
      "ja": "注：プロキシはRouteヘッダーマイナス「OB」パラメータでURIをコピーすることによって、フロートークンを含むレコードルートヘッダフィールド値を追加するため、この要件が満足する簡単な方法を。"
    },
    {
      "indent": 3,
      "text": "Next, whether the Route header field contained an \"ob\" URI parameter or not, the proxy removes the Route header field value and forwards the request over the 'logical flow' identified by the flow token, that is known to deliver data to the specific target UA instance. If the flow token has been tampered with, the proxy SHOULD send a 403 (Forbidden) response. If the flow no longer exists, the proxy SHOULD send a 430 (Flow Failed) response to the request.",
      "ja": "次に、Routeヘッダフィールドが「OB」URIパラメータが含まれているか否か、プロキシはRouteヘッダーフィールド値を除去し、フロートークンによって識別される「論理フロー」オーバー要求を転送し、それを特定するデータを配信することが知られていますUAインスタンスをターゲットにしています。フロー・トークンが改ざんされている場合、プロキシは403（禁止）応答を送信すべきです。流れがもう存在しない場合、プロキシはリクエストに430（フローが失敗した）応答を送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "Proxies that used the example algorithm described in Section 5.2 to form a flow token follow the procedures below to determine the correct flow. To decode the flow token, take the flow identifier in the user portion of the URI and base64 decode it, then verify the HMAC is correct by recomputing the HMAC and checking that it matches. If the HMAC is not correct, the request has been tampered with.",
      "ja": "トークン正しい流れを決定するために、以下の手順に従っ流を形成するために、セクション5.2で説明した例のアルゴリズムを使用するプロキシ。フロートークンを復号するために、URIのユーザ部分にフロー識別子を取得し、BASE64、それを復号し、HMACは、HMACを再計算し、それが一致することをチェックすることにより、正しいことを確認します。 HMACが正しくない場合は、要求が改ざんされています。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Processing Outgoing Requests",
      "section_title": true,
      "ja": "5.3.2。発信要求を処理"
    },
    {
      "indent": 3,
      "text": "For mid-dialog requests to work with outbound UAs, the requests need to be forwarded over some valid flow to the appropriate UA instance. If the edge proxy receives an outgoing dialog-forming request, the edge proxy can use the presence of the \"ob\" URI parameter in the UAC's Contact URI (or topmost Route header field) to determine if the edge proxy needs to assist in mid-dialog request routing.",
      "ja": "アウトバウンドのUAで動作するように、ダイアログ中のリクエストの場合、リクエストは適切なUAインスタンスにいくつかの有効な流れを介して転送する必要があります。エッジプロキシは、発信ダイアログ形成要求を受信した場合、エッジプロキシは、エッジプロキシが半ばを補助する必要があるかどうかを決定するためにUACの連絡先URI（または最上位のルートヘッダフィールド）に「OB」URIパラメータの存在を使用することができダイアログ要求ルーティング。"
    },
    {
      "indent": 6,
      "text": "Implementation note: Specific procedures at the edge proxy to ensure that mid-dialog requests are routed over an existing flow are not part of this specification. However, an approach such as having the edge proxy add a Record-Route header with a flow token is one way to ensure that mid-dialog requests are routed over the correct flow.",
      "ja": "実装上の注意：ミッドダイアログ要求が既存の流れの上に配線されていることを確実にするためにエッジプロキシでの具体的な手順は、本明細書の一部ではありません。しかしながら、このようなエッジプロキシは、フロートークンとRecord-Routeヘッダを追加有するようなアプローチは、中間ダイアログ要求が正しい流れを介してルーティングされることを保証する一つの方法です。"
    },
    {
      "indent": 0,
      "text": "5.4. Edge Proxy Keep-Alive Handling",
      "section_title": true,
      "ja": "5.4。エッジ・プロキシはキープアライブ処理"
    },
    {
      "indent": 3,
      "text": "All edge proxies compliant with this specification MUST implement support for STUN NAT keep-alives on their SIP UDP ports as described in Section 8.",
      "ja": "第8章で説明したように、この仕様に準拠するすべてのエッジプロキシはそのSIP UDPポートでSTUN NATキープアライブのサポートを実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a server receives a double CRLF sequence between SIP messages on a connection-oriented transport such as TCP or SCTP, it MUST immediately respond with a single CRLF over the same connection.",
      "ja": "サーバーは、TCPやSCTPなどの接続指向のトランスポート上でSIPメッセージの間の二重CRLFシーケンスを受信すると、それはすぐに同じ接続を介して、単一のCRLFで応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The last proxy to forward a successful registration response to a UA MAY include a Flow-Timer header field if the response contains the outbound option-tag in a Require header field value in the response. The reason a proxy would send a Flow-Timer is if it wishes to detect flow failures proactively and take appropriate action (e.g., log alarms, provide alternative treatment if incoming requests for the UA are received, etc.). The server MUST wait for an amount of time larger than the Flow-Timer in order to have a grace period to account for transport delay.",
      "ja": "応答は、応答におけるRequireヘッダーフィールド値のアウトバウンドオプションタグが含まれている場合、最後のプロキシは、フロータイマーヘッダーフィールドを含んでいてもよいUAに成功した登録応答を転送します。それは積極的に流れの障害を検出し（例えば、アラームを記録、UAのための着信要求が受信された場合など、代替治療を提供する）適切な行動をとることを希望する場合、プロキシは、フロータイマーを送ってしまう理由があります。サーバーは、輸送遅れを考慮するための猶予期間を持っているために、フロータイマーよりも大きな時間の間、待たなければなりません。"
    },
    {
      "indent": 0,
      "text": "6. Registrar Procedures",
      "section_title": true,
      "ja": "6.登録手続き"
    },
    {
      "indent": 3,
      "text": "This specification updates the definition of a binding in [RFC3261], Section 10 and [RFC3327], Section 5.3.",
      "ja": "この仕様は、[RFC3261]に結合部10と[RFC3327]、セクション5.3の定義を更新します。"
    },
    {
      "indent": 3,
      "text": "Registrars that implement this specification MUST support the Path header mechanism [RFC3327].",
      "ja": "この仕様を実装するレジストラは、Pathヘッダ機構[RFC3327]をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "When receiving a REGISTER request, the registrar MUST check from its Via header field if the registrar is the first hop or not. If the registrar is not the first hop, it MUST examine the Path header of the request. If the Path header field is missing or it exists but the first URI does not have an \"ob\" URI parameter, then outbound processing MUST NOT be applied to the registration. In this case, the following processing applies: if the REGISTER request contains the reg-id and the outbound option tag in a Supported header field, then the registrar MUST respond to the REGISTER request with a 439 (First Hop Lacks Outbound Support) response; otherwise, the registrar MUST ignore the \"reg-id\" parameter of the Contact header. See Section 11.6 for more information on the 439 response code.",
      "ja": "REGISTER要求を受信すると、レジストラは、最初のホップであるかない場合、レジストラは、そのViaヘッダーフィールドからチェックしなければなりません。レジストラは、最初のホップでない場合、それはリクエストのパスヘッダを検査しなければなりません。 Pathヘッダーフィールドが欠落しているか、それが存在しますが、最初のURIは「OB」URIパラメータを持っていない場合は、アウトバウンド処理は、登録に適用してはなりません。この場合、以下の処理が適用される：REGISTER要求がREG-IDとSupportedヘッダーフィールドにアウトバウンドオプションタグを含む場合、次いで、レジストラは、439（最初のホップで送信サポートを欠いている）応答でREGISTER要求に応答しなければなりません。そうでない場合、レジストラは、Contactヘッダの「REG-ID」パラメータを無視しなければなりません。 439応答コードの詳細については、セクション11.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "A Contact header field value with an instance-id media feature tag but no \"reg-id\" header field parameter is valid (this combination will result in the creation of a GRUU, as described in the GRUU specification [RFC5627]), but one with a reg-id but no instance-id is not valid. If the registrar processes a Contact header field value with a reg-id but no instance-id, it simply ignores the reg-id parameter.",
      "ja": "インスタンスIDメディア特徴タグが、NO「REG-ID」ヘッダフィールドパラメータが有効であるとContactヘッダーフィールド値は（この組み合わせは、GRUU仕様[RFC5627]に記載されているように、GRUUの作成をもたらす）が、1つREG-IDが、無インスタンスIDで有効ではありません。レジストラは、REG-IDが、無インスタンスIDを持つContactヘッダーフィールド値を処理する場合、それは単にREG-idパラメータを無視します。"
    },
    {
      "indent": 3,
      "text": "A registration containing a \"reg-id\" header field parameter and a non-zero expiration is used to register a single UA instance over a single flow, and can also de-register any Contact header fields with zero expiration. Therefore, if the Contact header field contains more than one header field value with a non-zero expiration and any of these header field values contain a \"reg-id\" Contact header field parameter, the entire registration SHOULD be rejected with a 400 (Bad Request) response. The justification for recommending rejection versus making it mandatory is that the receiver is allowed by [RFC3261] to squelch (not respond to) excessively malformed or malicious messages.",
      "ja": "「REG-ID」ヘッダフィールドパラメータと非ゼロの有効期限を含む登録が単一のフローにわたって単一UAインスタンスを登録するために使用され、またすることができ、ゼロの有効期限を持つ任意のContactヘッダフィールドを登録解除。したがって、Contactヘッダフィールドが非ゼロの有効期限と、複数のヘッダーフィールド値を含み、これらのヘッダフィールド値のいずれかが「REG-ID」Contactヘッダフィールドパラメータを含む、全体の登録が400（不良で拒否されるべきか要求）応答。それは必須の製造対拒絶を推奨するための正当化は、受信機が（に応答しない）が過度に不正なまたは悪意のあるメッセージをスケルチするために[RFC3261]で許可されることです。"
    },
    {
      "indent": 3,
      "text": "If the Contact header did not contain a \"reg-id\" Contact header field parameter or if that parameter was ignored (as described above), the registrar MUST NOT include the outbound option-tag in the Require header field of its response.",
      "ja": "Contactヘッダは、「REG-ID」Contactヘッダーフィールドパラメータまたは（上述のように）、そのパラメータが無視された場合、レジストラはそのレスポンスのRequireヘッダーフィールドにおけるアウトバウンドオプションタグを含めることはできませんが含まれていなかった場合。"
    },
    {
      "indent": 3,
      "text": "The registrar MUST be prepared to receive, simultaneously for the same AOR, some registrations that use instance-id and reg-id and some registrations that do not. The registrar MAY be configured with local policy to reject any registrations that do not include the instance-id and reg-id, or with Path header field values that do not contain the \"ob\" URI parameter. If the Contact header field does not contain a \"+sip.instance\" Contact header field parameter, the registrar processes the request using the Contact binding rules in [RFC3261].",
      "ja": "レジストラは、同時に同じAORのために、インスタンスIDとREG-IDとそうでないいくつかの登録を使用して、いくつかの登録を受けるために準備しなければなりません。レジストラは、インスタンスID及びREG-ID、または「OB」URIパラメータを含まないパスヘッダフィールド値とが含まれていない任意の登録を拒絶するために、ローカルポリシーで構成されてもよいです。 Contactヘッダーフィールドは、「+ sip.instance」Contactヘッダーフィールドのパラメータが含まれていない場合、レジストラは、[RFC3261]のルールを結合接触を使用して要求を処理します。"
    },
    {
      "indent": 3,
      "text": "When a \"+sip.instance\" Contact header field parameter and a \"reg-id\" Contact header field parameter are present in a Contact header field of a REGISTER request (after the Contact header validation as described above), the corresponding binding is between an AOR and the combination of the instance-id (from the \"+sip.instance\" Contact header parameter) and the value of \"reg-id\" Contact header field parameter parameter. The registrar MUST store in the binding the Contact URI, all the Contact header field parameters, and any Path header field values. (Even though the Contact URI is not used for binding comparisons, it is still needed by the authoritative proxy to form the target set.) Provided that the UAC had included an outbound option-tag (defined in Section 11.4) in a Supported header field",
      "ja": "「+ sip.instance」Contactヘッダーフィールドパラメータと「REG-ID」ContactヘッダフィールドパラメータがREGISTER要求のContactヘッダフィールドに存在する場合（上記のように、Contactヘッダの検証後に）、対応する結合が間にありますAORと（「+ sip.instance」Contactヘッダパラメータから）インスタンスIDの組み合わせと「REG-ID」Contactヘッダフィールドパラメータパラメータの値。レジストラは、結合接触URI内のすべての連絡先ヘッダフィールドパラメータ、および任意のパスヘッダフィールド値を格納する必要があります。 （連絡先URIが比較を結合するために使用されていないとしても、まだターゲット・セットを形成するために権限のプロキシによって必要とされる。）UACは、Supportedヘッダフィールドに（セクション11.4で定義された）送信オプションタグを含めたことを提供します"
    },
    {
      "indent": 3,
      "text": "value in the REGISTER request, the registrar MUST include the outbound option-tag in a Require header field value in its response to that REGISTER request.",
      "ja": "REGISTER要求の値は、レジストラは、REGISTERリクエストに対する応答に必要とヘッダーフィールド値のアウトバウンドオプションタグを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the UAC has a direct flow with the registrar, the registrar MUST store enough information to uniquely identify the network flow over which the request arrived. For common operating systems with TCP, this would typically be just the handle to the file descriptor where the handle would become invalid if the TCP session was closed. For common operating systems with UDP this would typically be the file descriptor for the local socket that received the request, the local interface, and the IP address and port number of the remote side that sent the request. The registrar MAY store this information by adding itself to the Path header field with an appropriate flow token.",
      "ja": "UACは、レジストラとの直接フローを有する場合、レジストラは一意に要求が到着れるネットワーク・フローを識別するために十分な情報を格納しなければなりません。 TCPと共通のオペレーティング・システムでは、これは通常、TCPセッションが閉じられた場合にはハンドルが無効になるファイルディスクリプタへのハンドルだけだろう。 UDPでの一般的なオペレーティングシステムでは、これは一般的に要求、ローカルインタフェース、およびリクエストを送信したリモート側のIPアドレスとポート番号を受信したローカルソケットのファイルディスクリプタになります。レジストラは適切なフロートークンとパスヘッダフィールドに自分自身を追加することによって、この情報を格納してもよいです。"
    },
    {
      "indent": 3,
      "text": "If the registrar receives a re-registration for a specific combination of AOR, and instance-id and reg-id values, the registrar MUST update any information that uniquely identifies the network flow over which the request arrived if that information has changed, and SHOULD update the time the binding was last updated.",
      "ja": "レジストラは、AORの特定の組み合わせのために再登録、およびインスタンスID及びREG-ID値を受信した場合、レジストラは一意にその情報が変更された場合、要求が到着れるネットワーク・フローを識別する任意の情報を更新し、SHOULD MUSTバインディングが最後に更新された時刻を更新。"
    },
    {
      "indent": 3,
      "text": "To be compliant with this specification, registrars that can receive SIP requests directly from a UAC without intervening edge proxies MUST implement the same keep-alive mechanisms as edge proxies (Section 5.4). Registrars with a direct flow with a UA MAY include a Flow-Timer header in a 2xx class registration response that includes the outbound option-tag in the Require header.",
      "ja": "この仕様に準拠するために、エッジプロキシを介さずUACから直接SIPリクエストを受信することができるレジストラは、エッジプロキシ（5.4）と同じキープアライブメカニズムを実装しなければなりません。 UAに直接流とレジストラは、要求ヘッダ内のアウトバウンドオプションタグを含むの2xxクラス登録応答フロータイマヘッダを含むかもしれません。"
    },
    {
      "indent": 0,
      "text": "7. Authoritative Proxy Procedures: Forwarding Requests",
      "section_title": true,
      "ja": "7.権威プロキシ手順：転送要求"
    },
    {
      "indent": 3,
      "text": "When a proxy uses the location service to look up a registration binding and then proxies a request to a particular contact, it selects a contact to use normally, with a few additional rules:",
      "ja": "プロキシバインディング登録をルックアップするために位置情報サービスを使用し、その後、特定の連絡先にリクエストをプロキシする際には、いくつかの追加ルールで、通常使用する連絡先を選択します。"
    },
    {
      "indent": 3,
      "text": "o The proxy MUST NOT populate the target set with more than one contact with the same AOR and instance-id at a time.",
      "ja": "Oプロキシは、一度に同じAORとインスタンスIDを持つ複数の連絡先と設定された目標を移入してはいけません。"
    },
    {
      "indent": 3,
      "text": "o If a request for a particular AOR and instance-id fails with a 430 (Flow Failed) response, the proxy SHOULD replace the failed branch with another target (if one is available) with the same AOR and instance-id, but a different reg-id.",
      "ja": "特定のAORとインスタンスIDの要求は430（フローが失敗しました）応答に失敗した場合（使用可能な場合）、O、プロキシは同じAORとインスタンスIDで別のターゲットで失敗した枝を交換する必要がありますが、異なりますREG-ID。"
    },
    {
      "indent": 3,
      "text": "o If the proxy receives a final response from a branch other than a 408 (Request Timeout) or a 430 (Flow Failed) response, the proxy MUST NOT forward the same request to another target representing the same AOR and instance-id. The targeted instance has already provided its response.",
      "ja": "プロキシ408（要求タイムアウト）以外のブランチからの最終応答または430（フローが失敗した）応答を受信した場合、O、プロキシは、同一のAORとインスタンスIDを表す別のターゲットに同じ要求を転送してはいけません。対象のインスタンスがすでにその応答を提供してきました。"
    },
    {
      "indent": 3,
      "text": "The proxy uses the next-hop target of the message and the value of any stored Path header field vector in the registration binding to decide how to forward and populate the Route header in the request. If the proxy is co-located with the registrar and stored information about the flow to the UA that created the binding, then the proxy MUST send the request over the same 'logical flow' saved with the binding, since that flow is known to deliver data to the specific target UA instance's network flow that was saved with the binding.",
      "ja": "プロキシは、メッセージの次ホップ対象と転送し、要求にRouteヘッダを移入する方法を決定するバインディング登録の任意の保存されたパスヘッダフィールドベクトルの値を使用します。プロキシはレジストラと同じ場所に配置し、その流れを供給することが知られていることから、結合して保存された同じ「論理的な流れ」の上に結合し、プロキシが送らなければなりません要求を作成したUAへの流れについての情報が格納されている場合バインディングで保存された特定のターゲットUAインスタンスのネットワークフローへのデータ。"
    },
    {
      "indent": 6,
      "text": "Implementation note: Typically this means that for TCP, the request is sent on the same TCP socket that received the REGISTER request. For UDP, the request is sent from the same local IP address and port over which the registration was received, to the same IP address and port from which the REGISTER was received.",
      "ja": "実装上の注意：一般的に、これはTCPのために、要求がREGISTERリクエストを受け取った同じTCPソケットで送信されることを意味します。 UDPの場合は、要求がREGISTERを受信したのと同じIPアドレスとポートに、登録を受信した上で、同じローカルIPアドレスとポートから送信されます。"
    },
    {
      "indent": 3,
      "text": "If a proxy or registrar receives information from the network that indicates that no future messages will be delivered on a specific flow, then the proxy MUST invalidate all the bindings in the target set that use that flow (regardless of AOR). Examples of this are a TCP socket closing or receiving a destination unreachable ICMP error on a UDP flow. Similarly, if a proxy closes a file descriptor, it MUST invalidate all the bindings in the target set with flows that use that file descriptor.",
      "ja": "プロキシまたはレジストラがない将来のメッセージが特定のフローに配信されないことを示し、ネットワークから情報を受信した場合、プロキシは（かかわらず、AORの）そのフローを使用して、ターゲット・セット内のすべてのバインディングを無効化しなければなりません。この例は、TCPソケット閉鎖またはUDPフロー上の宛先到達不能ICMPエラーを受信して​​います。プロキシがファイルディスクリプタをクローズする場合は同様に、そのファイルディスクリプタを使用フローに設定された目標にすべてのバインディングを無効にしなければなりません。"
    },
    {
      "indent": 0,
      "text": "8. STUN Keep-Alive Processing",
      "section_title": true,
      "ja": "8. STUNキープアライブ処理"
    },
    {
      "indent": 3,
      "text": "This section describes changes to the SIP transport layer that allow SIP and STUN [RFC5389] Binding Requests to be mixed over the same flow. This constitutes a new STUN usage. The STUN messages are used to verify that connectivity is still available over a UDP flow, and to provide periodic keep-alives. These STUN keep-alives are always sent to the next SIP hop. STUN messages are not delivered end-to-end.",
      "ja": "このセクションでは、SIPとSTUN [RFC5389]バインディング要求が同じフロー上に混合されることを可能にするSIP輸送層への変更を記載しています。これは、新しいSTUNの使用を構成しています。 STUNメッセージは、その接続性を検証するために使用されるUDPフロー上でまだ利用可能で、かつ定期的にキープアライブを提供しています。これらのSTUNのキープアライブは、常に次のSIPのホップに送信されます。 STUNメッセージは、エンドツーエンドを提供されていません。"
    },
    {
      "indent": 3,
      "text": "The only STUN messages required by this usage are Binding Requests, Binding Responses, and Binding Error Responses. The UAC sends Binding Requests over the same UDP flow that is used for sending SIP messages. These Binding Requests do not require any STUN attributes. The corresponding Binding Responses do not require any STUN attributes except the XOR-MAPPED-ADDRESS. The UAS, proxy, or registrar responds to a valid Binding Request with a Binding Response that MUST include the XOR-MAPPED-ADDRESS attribute.",
      "ja": "この使用によって必要なだけSTUNメッセージは、要求をバインディングバインディング応答、およびエラーレスポンスをバインドされています。 UACは、SIPメッセージを送信するために使用されているのと同じUDPフローを超えるバインド要求を送信します。これらの結合要求は、任意のSTUN属性を必要としません。対応する結合応答はXOR-MAPPED-ADDRESSを除くすべてのSTUN属性を必要としません。 UAS、プロキシ、またはレジストラはXOR-MAPPED-ADDRESS属性を含まなければならないのBindingレスポンスとの有効なバインディング要求に応答します。"
    },
    {
      "indent": 3,
      "text": "If a server compliant to this section receives SIP requests on a given interface and UDP port, it MUST also provide a limited version of a STUN server on the same interface and UDP port.",
      "ja": "このセクションに準拠したサーバは、指定されたインタフェースとUDPポート上のSIPリクエストを受信した場合、それはまた、同じインタフェースとUDPポート上のSTUNサーバーの限定バージョンを提供しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: It is easy to distinguish STUN and SIP packets sent over UDP, because the first octet of a STUN Binding method has a value of 0 or 1, while the first octet of a SIP message is never a 0 or 1.",
      "ja": "注：SIPメッセージの最初のオクテットは、0又は1になることはありませんしながら、STUNバインディング方法の最初のオクテットは、0又は1の値を有するので、UDPを介して送信されるSTUNとSIPパケットを区別することは容易です。"
    },
    {
      "indent": 3,
      "text": "Because sending and receiving binary STUN data on the same ports used for SIP is a significant and non-backwards compatible change to RFC 3261, this section requires a number of checks before sending STUN messages to a SIP node. If a SIP node sends STUN requests (for example, due to incorrect configuration) despite these warnings, the node could be blacklisted for UDP traffic.",
      "ja": "SIPのために使用したのと同じポートでバイナリSTUNデータを送受信するRFC 3261に重要および非下位互換性の変化であるため、ここでは、SIPノードにSTUNメッセージを送信する前にチェックの数を必要とします。 SIPノードは、これらの警告にもかかわらず（誤った構成に、例えば）STUN要求を送信した場合、ノードは、UDPトラフィックのためにブラックリストにすることができます。"
    },
    {
      "indent": 3,
      "text": "A SIP node MUST NOT send STUN requests over a flow unless it has an explicit indication that the target next-hop SIP server claims to support this specification. UACs MUST NOT use an ambiguous configuration option such as \"Work through NATs?\" or \"Do keep-alives?\" to imply next-hop STUN support. A UAC MAY use the presence of an \"ob\" URI parameter in the Path header in a registration response as an indication that its first edge proxy supports the keep-alives defined in this document.",
      "ja": "それはターゲットネクストホップSIPサーバはこの仕様をサポートするために主張することが明示的に指示がない限り、SIPノードは、フロー上STUN要求を送信してはいけません。求めるUACは、次のような曖昧な設定オプションを使用してはならない「NATを通過動作しますか？」または「キープアライブのか？」ネクストホップSTUNのサポートを意味します。 UACは、その第1のエッジプロキシは、この文書で定義されたキープアライブをサポートしていることを指標として登録応答でPathヘッダの「OB」URIパラメータの存在を使用するかもしれません。"
    },
    {
      "indent": 6,
      "text": "Note: Typically, a SIP node first sends a SIP request and waits to receive a 2xx class response over a flow to a new target destination, before sending any STUN messages. When scheduled for the next NAT refresh, the SIP node sends a STUN request to the target.",
      "ja": "注：典型的には、SIPノードは、最初のSIPリクエストを送信し、任意のSTUNメッセージを送信する前に、新たな目標目的地への流れ上の2xxクラスの応答の受信を待ちます。次のNATのリフレッシュのために予定した場合、SIPノードは、ターゲットにSTUN要求を送信します。"
    },
    {
      "indent": 3,
      "text": "Once a flow is established, failure of a STUN request (including its retransmissions) is considered a failure of the underlying flow. For SIP over UDP flows, if the XOR-MAPPED-ADDRESS returned over the flow changes, this indicates that the underlying connectivity has changed, and is considered a flow failure.",
      "ja": "流れが確立されると、（その再送信を含む）STUN要求の失敗は、基礎となる流れの失敗とみなされます。 XOR・マップド・アドレスがフローの変更の上に戻された場合、UDPフロー上SIPについては、これは根本的な接続が変更されたことを示し、フロー障害考えられます。"
    },
    {
      "indent": 3,
      "text": "The SIP keep-alive STUN usage requires no backwards compatibility with [RFC3489].",
      "ja": "SIPのキープアライブSTUN用法は[RFC3489]とは下位互換性を必要としません。"
    },
    {
      "indent": 0,
      "text": "8.1. Use with SigComp",
      "section_title": true,
      "ja": "8.1。 SigCompを使用します"
    },
    {
      "indent": 3,
      "text": "When STUN is used together with SigComp [RFC3320] compressed SIP messages over the same flow, the STUN messages are simply sent uncompressed, \"outside\" of SigComp. This is supported by multiplexing STUN messages with SigComp messages by checking the two topmost bits of the message. These bits are always one for SigComp, or zero for STUN.",
      "ja": "STUNは、同じフロー上にSIPメッセージを圧縮にSigComp [RFC3320]と一緒に使用する場合、STUNメッセージは、単にのSigCompの「外側」、圧縮されていない送信されます。これは、メッセージの2つの最上位ビットをチェックすることによってのSigCompメッセージで多重STUNメッセージに支持されています。これらのビットは常にSigCompのための1、またはSTUNでゼロになっています。"
    },
    {
      "indent": 6,
      "text": "Note: All SigComp messages contain a prefix (the five most significant bits of the first byte are set to one) that does not occur in UTF-8 [RFC3629] encoded text messages, so for",
      "ja": "注：すべてのSigCompメッセージはとてもためにUTF-8 [RFC3629]エンコードされたテキストメッセージでは発生しません接頭辞（最初のバイトの最上位5ビットが1に設定されている）、含まれています"
    },
    {
      "indent": 6,
      "text": "applications that use this encoding (or ASCII encoding) it is possible to multiplex uncompressed application messages and SigComp messages on the same UDP port. The most significant two bits of every STUN Binding method are both zeroes. This, combined with the magic cookie, aids in differentiating STUN packets from other protocols when STUN is multiplexed with other protocols on the same port.",
      "ja": "このエンコーディング（またはASCIIエンコーディング）を使用するアプリケーションは、同じUDPポートに圧縮されていないアプリケーションメッセージとのSigCompメッセージを多重化することが可能です。すべてのSTUNバインディング方法の上位2ビットが両方ともゼロです。これは、マジッククッキーと組み合わせて、STUNは、同じポート上の他のプロトコルと多重化されたときに、他のプロトコルからSTUNパケットを区別するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "9. Example Message Flow",
      "section_title": true,
      "ja": "9.例メッセージフロー"
    },
    {
      "indent": 3,
      "text": "Below is an example message flow illustrating most of the concepts discussed in this specification. In many cases, Via, Content-Length, and Max-Forwards headers are omitted for brevity and readability.",
      "ja": "以下本明細書で説明する概念のほとんどを示す例示メッセージフローです。多くの場合、経由、コンテンツの長さ、およびマックス・フォワードヘッダが簡潔さと読みやすさのために省略されています。"
    },
    {
      "indent": 3,
      "text": "In these examples, \"EP1\" and \"EP2\" are outbound proxies, and \"Proxy\" is the authoritativeProxy.",
      "ja": "これらの例では、「EP1」と「EP2は、」アウトバウンドプロキシで、「プロキシ」authoritativeProxyです。"
    },
    {
      "indent": 3,
      "text": "The section is subdivided into independent calls flows; however, they are structured in sequential order of a hypothetical sequence of call flows.",
      "ja": "セクションは、独立したコールの流れに分割されています。しかし、彼らは、コールフローの仮想的なシーケンスの順序で構成されています。"
    },
    {
      "indent": 0,
      "text": "9.1. Subscription to Configuration Package",
      "section_title": true,
      "ja": "9.1。構成パッケージへのサブスクリプション"
    },
    {
      "indent": 3,
      "text": "If the outbound proxy set is already configured on Bob's UA, then this subsection can be skipped. Otherwise, if the outbound proxy set is learned through the configuration package, Bob's UA sends a SUBSCRIBE request for the UA profile configuration package [CONFIG-FMWK]. This request is a poll (Expires is zero). After receiving the NOTIFY request, Bob's UA fetches the external configuration using HTTPS (not shown) and obtains a configuration file that contains the outbound-proxy-set \"sip:ep1.example.com;lr\" and \"sip:ep2.example.com;lr\".",
      "ja": "アウトバウンドプロキシセットがすでにボブのUAに設定されている場合、このサブセクションをスキップすることができます。アウトバウンドプロキシ設定が構成パッケージを介して学習されている場合それ以外の場合は、ボブのUAは、UAプロファイルコンフィギュレーションパッケージ[CONFIG-FMWK]のためのSUBSCRIBEリクエストを送信します。この要求は世論調査（有効期限がゼロである）です。 「SIPと;：「LRをep1.example.com SIP」：ep2.exampleをNOTIFY要求を受信した後、ボブのUAは、HTTPSを使用して、外部構成（図示せず）をフェッチし、アウトバウンドプロキシ設定を含む設定ファイルを取得します。 COM; LR」。"
    },
    {
      "indent": 4,
      "text": " [----example.com domain-------------------------]\n Bob         EP1   EP2     Proxy             Config\n  |           |     |        |                  |\n1)|SUBSCRIBE->|     |        |                  |\n2)|           |---SUBSCRIBE Event: ua-profile ->|\n3)|           |<--200 OK -----------------------|\n4)|<--200 OK--|     |        |                  |\n5)|           |<--NOTIFY------------------------|\n6)|<--NOTIFY--|     |        |                  |\n7)|---200 OK->|     |        |                  |\n8)|           |---200 OK ---------------------->|\n  |           |     |        |                  |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In this example, the DNS server happens to be configured so that sip: example.com resolves to EP1 and EP2.",
      "ja": "example.com EP1およびEP2に解決：SIPはそのように、この例では、DNSサーバが設定することを起こります。"
    },
    {
      "indent": 3,
      "text": "Example Message #1:",
      "ja": "メッセージの例＃1："
    },
    {
      "indent": 3,
      "text": "SUBSCRIBE sip:00000000-0000-1000-8000-AABBCCDDEEFF@example.com SIP/2.0 Via: SIP/2.0/TCP 192.0.2.2;branch=z9hG4bKnlsdkdj2 Max-Forwards: 70 From: <anonymous@example.com>;tag=23324 To: <sip:00000000-0000-1000-8000-AABBCCDDEEFF@example.com> Call-ID: nSz1TWN54x7My0GvpEBj CSeq: 1 SUBSCRIBE Event: ua-profile ;profile-type=device ;vendor=\"example.com\";model=\"uPhone\";version=\"1.1\" Expires: 0 Supported: path, outbound Accept: message/external-body, application/x-uPhone-config Contact: <sip:192.0.2.2;transport=tcp;ob> ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\" Content-Length: 0",
      "ja": "00000000-0000-1000-8000-AABBCCDDEEFF@example.com SIP / 2.0経由：SIP SUBSCRIBE SIP / 2.0 / TCPの192.0.2.2を、ブランチ= z9hG4bKnlsdkdj2マックス・フォワード：から70：<anonymous@example.com>;タグ= 23324に<SIP：00000000-0000-1000-8000-AABBCCDDEEFF@example.com>コール番号：nSz1TWN54x7My0GvpEBjのCSeq：1イベントSUBSCRIBE：UAプロファイル、プロファイル・タイプ=デバイス;ベンダー= \"example.com\";モデル= \"uPhone\"、バージョン= \"1.1\" 有効期限：0サポート：パスを、アウトバウンド受け入れ：メッセージ/外部ボディ、アプリケーション/ X-uPhone-設定との接触：<SIP：192.0.2.2;輸送= TCP; OB>; + sip.instance = \"<壷：UUID：00000000-0000-1000-8000-AABBCCDDEEFF>\" のContent-Length：0"
    },
    {
      "indent": 3,
      "text": "In message #2, EP1 adds the following Record-Route header:",
      "ja": "メッセージ＃2において、EP1は、以下のRecord-Routeヘッダを追加します。"
    },
    {
      "indent": 3,
      "text": "Record-Route: <sip:GopIKSsn0oGLPXRdV9BAXpT3coNuiGKV@ep1.example.com;lr>",
      "ja": "レコードルート：<SIP：GopIKSsn0oGLPXRdV9BAXpT3coNuiGKV@ep1.example.com; LR>"
    },
    {
      "indent": 3,
      "text": "In message #5, the configuration server sends a NOTIFY with an external URL for Bob to fetch his configuration. The NOTIFY has a Subscription-State header that ends the subscription.",
      "ja": "メッセージ＃5では、コンフィギュレーションサーバは、ボブが彼のコンフィギュレーションを取得するために外部のURLでNOTIFY送信します。 NOTIFYサブスクリプションを終了スクリプション・ステート・ヘッダーを持っています。"
    },
    {
      "indent": 3,
      "text": "Message #5",
      "ja": "メッセージ＃5"
    },
    {
      "indent": 3,
      "text": "NOTIFY sip:192.0.2.2;transport=tcp;ob SIP/2.0 Via: SIP/2.0/TCP 192.0.2.5;branch=z9hG4bKn81dd2 Max-Forwards: 70 To: <anonymous@example.com>;tag=23324 From: <sip:00000000-0000-1000-8000-AABBCCDDEEFF@example.com>;tag=0983 Call-ID: nSz1TWN54x7My0GvpEBj CSeq: 1 NOTIFY Route: <sip:GopIKSsn0oGLPXRdV9BAXpT3coNuiGKV@ep1.example.com;lr> Subscription-State: terminated;reason=timeout Event: ua-profile Content-Type: message/external-body; access-type=\"URL\" ;expiration=\"Thu, 01 Jan 2009 09:00:00 UTC\" ;URL=\"http://example.com/uPhone.cfg\" ;size=9999;hash=10AB568E91245681AC1B Content-Length: 0",
      "ja": "一口にNOTIFY：192.0.2.2;運輸= TCP; OB SIP / 2.0経由：SIP / 2.0 / TCPの192.0.2.5;ブランチ= z9hG4bKn81dd2マックス・フォワード：70：<anonymous@example.com>;タグ= 23324から：< SIP：00000000-0000-1000-8000-AABBCCDDEEFF@example.com>;タグ= 0983のCall-ID：nSz1TWN54x7My0GvpEBjのCSeq：1ルートをNOTIFY：<SIP：GopIKSsn0oGLPXRdV9BAXpT3coNuiGKV@ep1.example.com; LR>サブスクリ - 状態：終了。理由=タイムアウトイベント：UA-プロファイルのContent-Type：メッセージ/外部ボディ;アクセスタイプ= \"URL\";満了= \"木、2009年1月1日午前9時00分00秒UTC\"; URL = \"http://example.com/uPhone.cfg\";サイズ= 9999;ハッシュ= 10AB568E91245681AC1BのContent-Length ：0"
    },
    {
      "indent": 3,
      "text": "EP1 receives this NOTIFY request, strips off the Route header, extracts the flow-token, calculates the correct flow, and forwards the request (message #6) over that flow to Bob.",
      "ja": "EP1は、このNOTIFYリクエストを受信するRouteヘッダを取り除き、フロートークン抽出し、正しい流量を計算し、ボブへの流れを介して要求（メッセージ＃6）を転送します。"
    },
    {
      "indent": 3,
      "text": "Bob's UA fetches the configuration file and learns the outbound proxy set.",
      "ja": "ボブのUAは、設定ファイルを取得し、アウトバウンドプロキシ設定を学習します。"
    },
    {
      "indent": 0,
      "text": "9.2. Registration",
      "section_title": true,
      "ja": "9.2。登録"
    },
    {
      "indent": 3,
      "text": "Now that Bob's UA is configured with the outbound-proxy-set whether through configuration or using the configuration framework procedures of the previous section, Bob's UA sends REGISTER requests through each edge proxy in the set. Once the registrations succeed, Bob's UA begins sending CRLF keep-alives about every 2 minutes.",
      "ja": "今構成を通して、または、前のセクションの構成フレームワークの手順を使用しているかどうかボブのUAは、アウトバウンドプロキシ設定で構成されていることを、ボブのUAは、セット内の各エッジプロキシを介してREGISTERリクエストを送信します。登録が成功したら、ボブのUAは、2分ごとに約CRLFのキープアライブの送信を開始します。"
    },
    {
      "indent": 3,
      "text": "  Bob         EP1   EP2     Proxy     Alice\n   |           |     |        |         |\n 9)|-REGISTER->|     |        |         |\n10)|           |---REGISTER-->|         |\n11)|           |<----200 OK---|         |\n12)|<-200 OK---|     |        |         |\n13)|----REGISTER---->|        |         |\n14)|           |     |--REG-->|         |\n15)|           |     |<-200---|         |\n16)|<----200 OK------|        |         |\n   |           |     |        |         |\n   |  about 120 seconds later...        |\n   |           |     |        |         |\n17)|--2CRLF--->|     |        |         |\n18)|<--CRLF----|     |        |         |\n19)|------2CRLF----->|        |         |\n20)|<------CRLF------|        |         |\n   |           |     |        |         |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In message #9, Bob's UA sends its first registration through the first edge proxy in the outbound-proxy-set by including a loose route. The UA includes an instance-id and reg-id in its Contact header field value. Note the option-tags in the Supported header.",
      "ja": "メッセージ＃9において、ボブのUAは、緩い経路を含めることによって、アウトバウンドプロキシ・セット内の最初のエッジプロキシを通じて最初の登録を送信します。 UAはContactヘッダーフィールド値のインスタンスID及びREG-IDを含んでいます。サポートされているヘッダーにオプションタグに注意してください。"
    },
    {
      "indent": 3,
      "text": "Message #9",
      "ja": "メッセージ＃9"
    },
    {
      "indent": 3,
      "text": "REGISTER sip:example.com SIP/2.0 Via: SIP/2.0/TCP 192.0.2.2;branch=z9hG4bKnashds7 Max-Forwards: 70 From: Bob <sip:bob@example.com>;tag=7F94778B653B To: Bob <sip:bob@example.com> Call-ID: 16CB75F21C70 CSeq: 1 REGISTER Supported: path, outbound Route: <sip:ep1.example.com;lr> Contact: <sip:bob@192.0.2.2;transport=tcp>;reg-id=1 ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\" Content-Length: 0",
      "ja": "70：ボブ・ブランチ= z9hG4bKnashds7マックス・転送し、SIP / 2.0 / TCPの192.0.2.2：example.com SIP / 2.0経由：一口を登録<一口：bob@example.com>;タグ= 7F94778B653Bへ：ボブ<SIP： bob@example.com>コールID：16CB75F21C70のCSeq：1つのレジスタはサポートされている：パス、アウトバウンドルート：<SIP：ep1.example.com; LR>連絡先：<SIP：bob@192.0.2.2;運輸= TCP>; REG -id = 1; + sip.instance = \"<URN：UUID：00000000-0000-1000-8000-AABBCCDDEEFF>\" のContent-Length：0"
    },
    {
      "indent": 3,
      "text": "Message #10 is similar. EP1 removes the Route header field value, decrements Max-Forwards, and adds its Via header field value. Since EP1 is the first edge proxy, it adds a Path header with a flow token and includes the \"ob\" parameter.",
      "ja": "メッセージ＃10も同様です。 EP1はRouteヘッダーフィールド値を削除し、最大前方にデクリメントし、そのViaヘッダーフィールド値を加算します。 EP1は、第1のエッジプロキシであるので、フロートークンとPathヘッダを追加し、「OB」パラメータを含みます。"
    },
    {
      "indent": 3,
      "text": "Path: <sip:VskztcQ/S8p4WPbOnHbuyh5iJvJIW3ib@ep1.example.com;lr;ob>",
      "ja": "パス：<SIP：VskztcQ/S8p4WPbOnHbuyh5iJvJIW3ib@ep1.example.com; LR; OB>"
    },
    {
      "indent": 3,
      "text": "Since the response to the REGISTER (message #11) contains the outbound option-tag in the Require header field, Bob's UA will know that the registrar used outbound binding rules. The response also contains the currently active Contacts, and the Path for the current registration.",
      "ja": "REGISTER（メッセージ＃11）に対応必要なヘッダフィールドの送信オプションタグを含んでいるので、ボブのUAは、レジストラがアウトバウンド結合ルールを使用したことを知っているであろう。応答には、現在アクティブなコンタクト、および現在の登録のためのパスが含まれています。"
    },
    {
      "indent": 3,
      "text": "Message #11",
      "ja": "メッセージ＃11"
    },
    {
      "indent": 3,
      "text": "SIP/2.0 200 OK Via: SIP/2.0/TCP 192.0.2.15;branch=z9hG4bKnuiqisi Via: SIP/2.0/TCP 192.0.2.2;branch=z9hG4bKnashds7 From: Bob <sip:bob@example.com>;tag=7F94778B653B To: Bob <sip:bob@example.com>;tag=6AF99445E44A Call-ID: 16CB75F21C70 CSeq: 1 REGISTER Supported: path, outbound Require: outbound Contact: <sip:bob@192.0.2.2;transport=tcp>;reg-id=1;expires=3600 ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\" Path: <sip:VskztcQ/S8p4WPbOnHbuyh5iJvJIW3ib@ep1.example.com;lr;ob> Content-Length: 0",
      "ja": "SIP / 2.0 200 OK経由：SIP / 2.0 / TCP 192.0.2.15;ブランチ= z9hG4bKnuiqisi経由：SIP / 2.0 / TCPの192.0.2.2;ブランチ= z9hG4bKnashds7から：ボブ<SIP：bob@example.com>;タグ= 7F94778B653Bへ：ボブ<SIP：bob@example.com>;タグ= 6AF99445E44Aコール-ID：16CB75F21C70のCSeq：1つのREGISTERサポート：パス、アウトバウンドが必要：アウトバウンドコンタクト：<SIP：bob@192.0.2.2;運輸= TCP>; REG-をID = 1; + sip.instance =; = 3600満了する \"<URN：UUID：00000000-0000-1000-8000-AABBCCDDEEFF>\" パス：<SIP：VskztcQ/S8p4WPbOnHbuyh5iJvJIW3ib@ep1.example.com; LR; OB>コンテンツ-length：0"
    },
    {
      "indent": 3,
      "text": "The second registration through EP2 (message #13) is similar except that the Call-ID has changed, the reg-id is 2, and the Route header goes through EP2.",
      "ja": "EP2（メッセージ＃13）を介して第2の登録は、Call-IDは、REG-IDが2であり、変化した、とRouteヘッダは、EP2を通過することを除いて同様です。"
    },
    {
      "indent": 3,
      "text": "Message #13",
      "ja": "メッセージ＃13"
    },
    {
      "indent": 3,
      "text": "REGISTER sip:example.com SIP/2.0 Via: SIP/2.0/TCP 192.0.2.2;branch=z9hG4bKnqr9bym Max-Forwards: 70 From: Bob <sip:bob@example.com>;tag=755285EABDE2 To: Bob <sip:bob@example.com> Call-ID: E05133BD26DD CSeq: 1 REGISTER Supported: path, outbound Route: <sip:ep2.example.com;lr> Contact: <sip:bob@192.0.2.2;transport=tcp>;reg-id=2 ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\" Content-Length: 0",
      "ja": "70：ボブ・ブランチ= z9hG4bKnqr9bymマックス・転送し、SIP / 2.0 / TCPの192.0.2.2：example.com SIP / 2.0経由：一口を登録<一口：bob@example.com>;タグ= 755285EABDE2へ：ボブ<SIP： bob@example.com>コール-IDを：E05133BD26DDのCSeq：1つのREGISTERサポート：パス、アウトバウンドルート：<SIP：ep2.example.com; LR>連絡先：<SIP：bob@192.0.2.2;運輸= TCP>; REG -id = 2; + sip.instance = \"<URN：UUID：00000000-0000-1000-8000-AABBCCDDEEFF>\" のContent-Length：0"
    },
    {
      "indent": 3,
      "text": "Likewise in message #14, EP2 adds a Path header with flow token and \"ob\" parameter.",
      "ja": "同様に、メッセージ＃14において、EP2は、フロートークンと「OB」パラメータとPathヘッダを付加します。"
    },
    {
      "indent": 3,
      "text": "Path: <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr;ob>",
      "ja": "パス：<SIP：wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com; LR; OB>"
    },
    {
      "indent": 3,
      "text": "Message #16 tells Bob's UA that outbound registration was successful, and shows both Contacts. Note that only the Path corresponding to the current registration is returned.",
      "ja": "メッセージ＃16は、アウトバウンド登録が成功した、との両方の連絡先が表示されていることをボブのUAに指示します。現在の登録に対応する唯一のパスが返されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Message #16",
      "ja": "メッセージ＃16"
    },
    {
      "indent": 3,
      "text": "SIP/2.0 200 OK Via: SIP/2.0/TCP 192.0.2.2;branch=z9hG4bKnqr9bym From: Bob <sip:bob@example.com>;tag=755285EABDE2 To: Bob <sip:bob@example.com>;tag=49A9AD0B3F6A Call-ID: E05133BD26DD Supported: path, outbound Require: outbound CSeq: 1 REGISTER Contact: <sip:bob@192.0.2.2;transport=tcp>;reg-id=1;expires=3600 ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\" Contact: <sip:bob@192.0.2.2;transport=tcp>;reg-id=2;expires=3600 ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\" Path: <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr;ob> Content-Length: 0",
      "ja": "SIP / 2.0 200 OK経由：SIP / 2.0 / TCPの192.0.2.2;ブランチ= z9hG4bKnqr9bymから：ボブ<SIP：bob@example.com>;タグ= 755285EABDE2へ：ボブ<SIP：bob@example.com>;タグ= 49A9AD0B3F6Aコール-ID：E05133BD26DDがサポートされている：パス、アウトバウンドが必要：アウトバウンドのCSeq：1つのREGISTER連絡先：<SIP：bob@192.0.2.2;運輸= TCP>; REG-ID = 1; = 3600を満了し; + sip.instance =を」 <URN：UUID：00000000-0000-1000-8000-AABBCCDDEEFF> \"連絡先：<SIP：bob@192.0.2.2;輸送= TCP>; REG-ID = 2; = 3600を満了し; + sip.instance =\" <URN ：UUID：00000000-0000-1000-8000-AABBCCDDEEFF>」パス：<SIP：wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com; LR; OB>のContent-Length：0"
    },
    {
      "indent": 0,
      "text": "9.3. Incoming Call and Proxy Crash",
      "section_title": true,
      "ja": "9.3。着信およびプロキシのクラッシュ"
    },
    {
      "indent": 3,
      "text": "In this example, after registration, EP1 crashes and reboots. Before Bob's UA notices that its flow to EP1 is no longer responding, Alice calls Bob. Bob's authoritative proxy first tries the flow to EP1, but EP1 no longer has a flow to Bob, so it responds with a 430 (Flow Failed) response. The proxy removes the stale registration and tries the next binding for the same instance.",
      "ja": "この例では、登録後、EP1がクラッシュして再起動します。ボブのUAはEP1にその流れはもはや応答していることに気づきません前に、アリスはボブを呼び出します。ボブの認証プロキシが最初EP1への流れをしようとしますが、EP1は、もはやボブへの流れを持っていないので、それは430で応答レスポンスを（フローは失敗しました）。プロキシが無効登録を削除し、同じインスタンスのための次の結合を試みます。"
    },
    {
      "indent": 3,
      "text": "  Bob         EP1   EP2     Proxy     Alice\n   |           |     |        |         |\n   |    CRASH  X     |        |         |\n   |        Reboot   |        |         |\n   |           |     |        |         |\n21)|           |     |        |<-INVITE-|\n22)|           |<---INVITE----|         |\n23)|           |----430------>|         |\n24)|           |     |<-INVITE|         |\n25)|<---INVITE-------|        |         |\n26)|----200 OK------>|        |         |\n27)|           |     |200 OK->|         |\n28)|           |     |        |-200 OK->|\n29)|           |     |<----------ACK----|\n30)|<---ACK----------|        |         |\n   |           |     |        |         |\n31)|           |     |<----------BYE----|\n32)|<---BYE----------|        |         |\n33)|----200 OK------>|        |         |\n34)|           |     |--------200 OK--->|\n   |           |     |        |         |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Message #21",
      "ja": "メッセージ＃21"
    },
    {
      "indent": 3,
      "text": "INVITE sip:bob@example.com SIP/2.0 To: Bob <sip:bob@example.com> From: Alice <sip:alice@a.example>;tag=02935 Call-ID: klmvCxVWGp6MxJp2T2mb CSeq: 1 INVITE",
      "ja": "bob@example.com SIP / 2.0：から<bob@example.com SIP>：アリス<SIP：alice@a.example>ボブSIPのINVITE;タグは= 02935のCall-ID：klmvCxVWGp6MxJp2T2mbのCSeq：INVITE 1"
    },
    {
      "indent": 3,
      "text": "Bob's proxy rewrites the Request-URI to the Contact URI used in Bob's registration, and places the path for one of the registrations towards Bob's UA instance into a Route header field. This Route goes through EP1.",
      "ja": "ボブのプロキシは、ボブの登録に使用されるコンタクトURIへのRequest-URIを書き換え、RouteヘッダフィールドにボブのUAインスタンス向かっ登録のための経路を置きます。このルートは、EP1を通過します。"
    },
    {
      "indent": 3,
      "text": "Message #22",
      "ja": "メッセージ＃22"
    },
    {
      "indent": 3,
      "text": "INVITE sip:bob@192.0.2.2;transport=tcp SIP/2.0 To: Bob <sip:bob@example.com> From: Alice <sip:alice@a.example>;tag=02935 Call-ID: klmvCxVWGp6MxJp2T2mb CSeq: 1 INVITE Route: <sip:VskztcQ/S8p4WPbOnHbuyh5iJvJIW3ib@ep1.example.com;lr;ob>",
      "ja": "bob@192.0.2.2;輸送= TCP SIP / 2.0：SIPのINVITEから：ボブ<bob@example.com SIP>：アリス<SIP：alice@a.example>;タグ= 02935のCall-ID：klmvCxVWGp6MxJp2T2mbのCSeq： <SIP：; LR; OB VskztcQ/S8p4WPbOnHbuyh5iJvJIW3ib@ep1.example.com> 1ルートのINVITE"
    },
    {
      "indent": 3,
      "text": "Since EP1 just rebooted, it does not have the flow described in the flow token. It returns a 430 (Flow Failed) response.",
      "ja": "EP1だけで再起動するので、それが流れトークンで説明したフローを持っていません。これは、430（フローが失敗した）応答を返します。"
    },
    {
      "indent": 3,
      "text": "Message #23",
      "ja": "メッセージ＃23"
    },
    {
      "indent": 3,
      "text": "SIP/2.0 430 Flow Failed To: Bob <sip:bob@example.com> From: Alice <sip:alice@a.example>;tag=02935 Call-ID: klmvCxVWGp6MxJp2T2mb CSeq: 1 INVITE",
      "ja": "<bob@example.com SIP>：アリス<SIP：alice@a.example>ボブ：SIP / 2.0 430フローに失敗し、タグは= 02935のCall-ID：klmvCxVWGp6MxJp2T2mbのCSeq：INVITE 1"
    },
    {
      "indent": 3,
      "text": "The proxy deletes the binding for this path and tries to forward the INVITE again, this time with the path through EP2.",
      "ja": "プロキシは、EP2を通る経路と、この時間を、このパスのバインドを削除し、再度INVITEを転送しようとします。"
    },
    {
      "indent": 3,
      "text": "Message #24",
      "ja": "メッセージ＃24"
    },
    {
      "indent": 3,
      "text": "INVITE sip:bob@192.0.2.2;transport=tcp SIP/2.0 To: Bob <sip:bob@example.com> From: Alice <sip:alice@a.example>;tag=02935 Call-ID: klmvCxVWGp6MxJp2T2mb CSeq: 1 INVITE Route: <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr;ob>",
      "ja": "bob@192.0.2.2;輸送= TCP SIP / 2.0：SIPのINVITEから：ボブ<bob@example.com SIP>：アリス<SIP：alice@a.example>;タグ= 02935のCall-ID：klmvCxVWGp6MxJp2T2mbのCSeq： <SIP：; LR; OB wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com> 1ルートのINVITE"
    },
    {
      "indent": 3,
      "text": "In message #25, EP2 needs to add a Record-Route header field value, so that any subsequent in-dialog messages from Alice's UA arrive at Bob's UA. EP2 can determine it needs to Record-Route since the request is a dialog-forming request and the Route header contained a flow token and an \"ob\" parameter. This Record-Route information is passed back to Alice's UA in the responses (messages #26, 27, and 28).",
      "ja": "メッセージ＃25においては、EP2は、アリスのUAからの後続のインダイアログメッセージがボブのUAに到達するように、レコードルートヘッダフィールド値を追加する必要があります。 EP2は、レコードルートを要求するダイアログ形成要求およびルートヘッダは、フロートークンと「OB」パラメータが含まれているので、必要に決定することができます。これは、レコード・ルート情報が応答に戻って、アリスのUAに渡されます（メッセージ＃26、27、および28）。"
    },
    {
      "indent": 3,
      "text": "Message #25",
      "ja": "メッセージ＃25"
    },
    {
      "indent": 3,
      "text": "INVITE sip:bob@192.0.2.2;transport=tcp SIP/2.0 To: Bob <sip:bob@example.com> From: Alice <sip:alice@a.example>;tag=02935 Call-ID: klmvCxVWGp6MxJp2T2mb CSeq: 1 INVITE Record-Route: <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr>",
      "ja": "bob@192.0.2.2;輸送= TCP SIP / 2.0：SIPのINVITEから：ボブ<bob@example.com SIP>：アリス<SIP：alice@a.example>;タグ= 02935のCall-ID：klmvCxVWGp6MxJp2T2mbのCSeq： 1レコードルートをINVITE <SIP：wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com; LR>"
    },
    {
      "indent": 3,
      "text": "Message #26",
      "ja": "メッセージ＃26"
    },
    {
      "indent": 3,
      "text": "SIP/2.0 200 OK To: Bob <sip:bob@example.com>;tag=skduk2 From: Alice <sip:alice@a.example>;tag=02935 Call-ID: klmvCxVWGp6MxJp2T2mb CSeq: 1 INVITE Record-Route: <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr>",
      "ja": "SIP / 2.0 200 OK：ボブ<SIP：bob@example.com>;からタグ= skduk2：アリス<SIP：alice@a.example>;タグは= 02935コールID：klmvCxVWGp6MxJp2T2mbのCSeq：レコードルートをINVITE：1 <一口：wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com; LR>"
    },
    {
      "indent": 3,
      "text": "At this point, both UAs have the correct route-set for the dialog. Any subsequent requests in this dialog will route correctly. For example, the ACK request in message #29 is sent from Alice's UA directly to EP2. The BYE request in message #31 uses the same route-set.",
      "ja": "この時点で、両方のUAは、ダイアログの正しいルートが設定されています。正しくこのダイアログ意志ルート内の任意の後続の要求。例えば、メッセージ＃29でACK要求は、EP2に直接アリスのUAから送信されます。メッセージ＃31にBYE要求が同じルートのセットを使用します。"
    },
    {
      "indent": 3,
      "text": "Message #29",
      "ja": "メッセージ＃29"
    },
    {
      "indent": 3,
      "text": "ACK sip:bob@192.0.2.2;transport=tcp SIP/2.0 To: Bob <sip:bob@example.com>;tag=skduk2 From: Alice <sip:alice@a.example>;tag=02935 Call-ID: klmvCxVWGp6MxJp2T2mb CSeq: 1 ACK Route: <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr>",
      "ja": "ACKをSIP：bob@192.0.2.2;への輸送= TCPのSIP / 2.0：ボブ<SIP：bob@example.com>;からタグ= skduk2：アリス<SIP：alice@a.example>;タグ= 02935コールID ：klmvCxVWGp6MxJp2T2mbのCSeq：1 ACK経路：<SIP：wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com; LR>"
    },
    {
      "indent": 3,
      "text": "Message #31",
      "ja": "メッセージ＃31"
    },
    {
      "indent": 3,
      "text": "BYE sip:bob@192.0.2.2;transport=tcp SIP/2.0 To: Bob <sip:bob@example.com>;tag=skduk2 From: Alice <sip:alice@a.example>;tag=02935 Call-ID: klmvCxVWGp6MxJp2T2mb CSeq: 2 BYE Route: <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr>",
      "ja": "BYEをSIP：bob@192.0.2.2;輸送= TCP SIP / 2.0：ボブ<SIP：bob@example.com>;からタグ= skduk2：アリス<SIP：alice@a.example>;タグ= 02935コールID ：klmvCxVWGp6MxJp2T2mbのCSeq：2 BYEルート<SIP：wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com; LR>"
    },
    {
      "indent": 0,
      "text": "9.4. Re-Registration",
      "section_title": true,
      "ja": "9.4。再登録"
    },
    {
      "indent": 3,
      "text": "Somewhat later, Bob's UA sends keep-alives to both its edge proxies, but it discovers that the flow with EP1 failed. Bob's UA re-registers through EP1 using the same reg-id and Call-ID it previously used.",
      "ja": "やや後で、ボブのUAは、その両方のエッジプロキシにキープアライブを送信し、それはEP1との流れが失敗したことを検出します。ボブのUAの同じREG-IDを使用してEP1て再登録およびCall-IDには、以前に使用します。"
    },
    {
      "indent": 3,
      "text": "  Bob         EP1   EP2     Proxy     Alice\n   |           |     |        |         |\n35)|------2CRLF----->|        |         |\n36)|<------CRLF------|        |         |\n37)|--2CRLF->X |     |        |         |\n   |           |     |        |         |\n38)|-REGISTER->|     |        |         |\n39)|           |---REGISTER-->|         |\n40)|           |<----200 OK---|         |\n41)|<-200 OK---|     |        |         |\n   |           |     |        |         |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Message #38",
      "ja": "メッセージ＃38"
    },
    {
      "indent": 3,
      "text": "REGISTER sip:example.com SIP/2.0 From: Bob <sip:bob@example.com>;tag=7F94778B653B To: Bob <sip:bob@example.com> Call-ID: 16CB75F21C70 CSeq: 2 REGISTER Supported: path, outbound Route: <sip:ep1.example.com;lr> Contact: <sip:bob@192.0.2.2;transport=tcp>;reg-id=1 ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\"",
      "ja": "ボブ<SIP：bob@example.com>コール番号：16CB75F21C70のCSeq：2 REGISTERサポート：パス、;からexample.com SIP / 2.0：：：ボブ<SIP bob@example.com>タグ= 7F94778B653Bには、SIPレジスタ往路：<SIP：ep1.example.com; LR>連絡先：<SIP：bob@192.0.2.2;輸送= TCP>; REG-ID = 1; + sip.instance = \"<URN：UUID：00000000から0000 -1000-8000-AABBCCDDEEFF>」"
    },
    {
      "indent": 3,
      "text": "In message #39, EP1 inserts a Path header with a new flow token:",
      "ja": "メッセージ＃39において、EP1は、新しいフロートークンとPathヘッダを挿入します。"
    },
    {
      "indent": 3,
      "text": "Path: <sip:3yJEbr1GYZK9cPYk5Snocez6DzO7w+AX@ep1.example.com;lr;ob>",
      "ja": "パス：<SIP：3yJEbr1GYZK9cPYk5Snocez6DzO7w+AX@ep1.example.com; LR; OB>"
    },
    {
      "indent": 0,
      "text": "9.5. Outgoing Call",
      "section_title": true,
      "ja": "9.5。発信コール"
    },
    {
      "indent": 3,
      "text": "Finally, Bob makes an outgoing call to Alice. Bob's UA includes an \"ob\" parameter in its Contact URI in message #42. EP1 adds a Record-Route with a flow-token in message #43. The route-set is returned to Bob in the response (messages #45, 46, and 47), and either Bob or Alice can send in-dialog requests.",
      "ja": "最後に、ボブはアリスに発信呼び出しを行います。ボブのUAは、メッセージ＃42にその連絡先URIに「OB」パラメータを含んでいます。 EP1は、メッセージ＃43のフロー・トークンで録音・ルートを追加します。ルートセットは、（メッセージ＃45、46、および47）応答でボブに戻され、ボブまたはアリスのいずれかで、ダイアログのリクエストを送信することができます。"
    },
    {
      "indent": 3,
      "text": "  Bob         EP1   EP2     Proxy     Alice\n   |           |     |        |         |\n42)|--INVITE-->|     |        |         |\n43)|           |---INVITE---->|         |\n44)|           |     |        |-INVITE->|\n45)|           |     |        |<--200---|\n46)|           |<----200 OK---|         |\n47)|<-200 OK---|     |        |         |\n48)|--ACK----->|     |        |         |\n49)|           |-----ACK--------------->|\n   |           |     |        |         |\n50)|-- BYE---->|     |        |         |\n51)|           |-----------BYE--------->|\n52)|           |<----------200 OK-------|\n53)|<--200 OK--|     |        |         |\n   |           |     |        |         |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Message #42",
      "ja": "メッセージ＃42"
    },
    {
      "indent": 3,
      "text": "INVITE sip:alice@a.example SIP/2.0 From: Bob <sip:bob@example.com>;tag=ldw22z To: Alice <sip:alice@a.example> Call-ID: 95KGsk2V/Eis9LcpBYy3 CSeq: 1 INVITE Route: <sip:ep1.example.com;lr> Contact: <sip:bob@192.0.2.2;transport=tcp;ob>",
      "ja": "SIPのINVITE：SIP / 2.0 alice@a.exampleから：ボブ<SIP：bob@example.com>;タグ= ldw22zに：アリス<SIP：alice@a.example>コール番号：95KGsk2V / Eis9LcpBYy3のCSeq：INVITE 1ルート：<SIP：ep1.example.com; LR>連絡先：<SIP：bob@192.0.2.2;運輸= TCP; OB>"
    },
    {
      "indent": 3,
      "text": "In message #43, EP1 adds the following Record-Route header.",
      "ja": "メッセージ＃43において、EP1は、以下のRecord-Routeヘッダを追加します。"
    },
    {
      "indent": 3,
      "text": "Record-Route: <sip:3yJEbr1GYZK9cPYk5Snocez6DzO7w+AX@ep1.example.com;lr>",
      "ja": "レコードルート：<SIP：3yJEbr1GYZK9cPYk5Snocez6DzO7w+AX@ep1.example.com; LR>"
    },
    {
      "indent": 3,
      "text": "When EP1 receives the BYE (message #50) from Bob's UA, it can tell that the request is an \"outgoing\" request (since the source of the request matches the flow in the flow token) and simply deletes its Route header field value and forwards the request on to Alice's UA.",
      "ja": "EP1は、ボブのUAからBYE（メッセージ＃50）を受信すると、それは（要求元がフロートークンにフローと一致するので）要求が「発信」の要求であることを伝えることができ、単にそのルートヘッダフィールド値を削除しアリスのUAへの要求を転送します。"
    },
    {
      "indent": 3,
      "text": "Message #50",
      "ja": "メッセージ＃50"
    },
    {
      "indent": 3,
      "text": "BYE sip:alice@a.example SIP/2.0 From: Bob <sip:bob@example.com>;tag=ldw22z To: Alice <sip:alice@a.example>;tag=plqus8 Call-ID: 95KGsk2V/Eis9LcpBYy3 CSeq: 2 BYE Route: <sip:3yJEbr1GYZK9cPYk5Snocez6DzO7w+AX@ep1.example.com;lr> Contact: <sip:bob@192.0.2.2;transport=tcp;ob>",
      "ja": "BYEをSIP：ボブ：SIP / 2.0 alice@a.example：;：アリス<SIP：alice@a.example> <SIP bob@example.com>からタグ= ldw22z;タグ=コールIDをplqus8：95KGsk2V / Eis9LcpBYy3 CSeq：2 BYEルート：<SIP：3yJEbr1GYZK9cPYk5Snocez6DzO7w+AX@ep1.example.com; LR>連絡先：<SIP：bob@192.0.2.2;運輸= TCP; OB>"
    },
    {
      "indent": 0,
      "text": "10. Grammar",
      "section_title": true,
      "ja": "10.文法"
    },
    {
      "indent": 3,
      "text": "This specification defines a new header field \"Flow-Timer\", and new Contact header field parameters, \"reg-id\" and \"+sip.instance\". The grammar includes the definitions from [RFC3261]. Flow-Timer is an extension-header from the message-header in the [RFC3261] ABNF.",
      "ja": "この仕様は、新しいヘッダフィールド「フロータイマ」、および新しい連絡先ヘッダフィールドパラメータ、「REG-ID」及び「+ sip.instance」を定義します。文法は[RFC3261]の定義を含みます。フロータイマは[RFC3261] ABNFにメッセージヘッダから拡張ヘッダです。"
    },
    {
      "indent": 3,
      "text": "The ABNF [RFC5234] is:",
      "ja": "ABNF [RFC5234]は次のとおりです。"
    },
    {
      "indent": 4,
      "text": "Flow-Timer = \"Flow-Timer\" HCOLON 1*DIGIT",
      "ja": "フロー・タイマー=「フロー・タイマ」HCOLON 1 * DIGIT"
    },
    {
      "indent": 4,
      "text": "contact-params =/ c-p-reg / c-p-instance",
      "ja": "コンタクト-paramsは= / C-P-REG / C-P-インスタンス"
    },
    {
      "indent": 4,
      "text": "c-p-reg = \"reg-id\" EQUAL 1*DIGIT ; 1 to (2^31 - 1)",
      "ja": "C-P-REG = \"REG-ID\" EQUAL 1 * DIGIT。 1（1  -  2 ^ 31）に"
    },
    {
      "indent": 4,
      "text": "c-p-instance = \"+sip.instance\" EQUAL DQUOTE \"<\" instance-val \">\" DQUOTE",
      "ja": "C-P-インスタンス= \"+ sip.instance\" EQUAL DQUOTE \"<\" インスタンス-VAL \">\" DQUOTE"
    },
    {
      "indent": 4,
      "text": "instance-val = 1*uric ; defined in RFC 3261",
      "ja": "インスタンス-VAL = 1 *尿。 RFC 3261で定義されています"
    },
    {
      "indent": 3,
      "text": "The value of the reg-id MUST NOT be 0 and MUST be less than 2^31.",
      "ja": "REG-IDの値は0てはならず、2 ^ 31未満でなければなりません。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "11.1. Flow-Timer Header Field",
      "section_title": true,
      "ja": "11.1。フロータイマーヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "This specification defines a new SIP header field \"Flow-Timer\" whose syntax is defined in Section 10.",
      "ja": "この仕様は新しいSIPヘッダ・フィールド構文がセクション10で定義される「フロータイマ」を定義します。"
    },
    {
      "indent": 5,
      "text": "Header Name        compact    Reference\n-----------------  -------    ---------\nFlow-Timer                    [RFC5626]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.2. \"reg-id\" Contact Header Field Parameter",
      "section_title": true,
      "ja": "11.2。 「REG-ID」連絡先ヘッダーフィールドパラメータ"
    },
    {
      "indent": 3,
      "text": "This specification defines a new Contact header field parameter called reg-id in the \"Header Field Parameters and Parameter Values\" sub-registry as per the registry created by [RFC3968]. The syntax is defined in Section 10. The required information is:",
      "ja": "この仕様は、[RFC3968]によって作成されたレジストリ通り「ヘッダフィールドパラメータとパラメータ値」サブレジストリにREG-IDと呼ばれる新しい連絡先ヘッダフィールドパラメータを定義します。構文は、必要な情報があるセクション10で定義されています。"
    },
    {
      "indent": 3,
      "text": "                                               Predefined\nHeader Field            Parameter Name         Values      Reference\n----------------------  ---------------------  ----------  ---------\nContact                 reg-id                 No          [RFC5626]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.3. SIP/SIPS URI Parameters",
      "section_title": true,
      "ja": "11.3。 SIP / URIパラメータをSIPS"
    },
    {
      "indent": 3,
      "text": "This specification augments the \"SIP/SIPS URI Parameters\" sub-registry as per the registry created by [RFC3969]. The required information is:",
      "ja": "この仕様は、[RFC3969]によって作成されたレジストリ通り「SIPは/ SIPS URIパラメータ」サブレジストリを増強します。必要な情報は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Parameter Name     Predefined Values     Reference\n--------------     -----------------     ---------\nob                 No                    [RFC5626]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.4. SIP Option Tag",
      "section_title": true,
      "ja": "11.4。 SIPオプションタグ"
    },
    {
      "indent": 3,
      "text": "This specification registers a new SIP option tag, as per the guidelines in Section 27.1 of [RFC3261].",
      "ja": "この仕様は、[RFC3261]のセクション27.1のガイドラインに従って、新しいSIPオプションタグを登録します。"
    },
    {
      "indent": 3,
      "text": "Name: outbound",
      "ja": "名前：アウトバウンド"
    },
    {
      "indent": 3,
      "text": "Description: This option-tag is used to identify UAs and registrars that support extensions for Client-Initiated Connections. A UA places this option in a Supported header to communicate its support for this extension. A registrar places this option-tag in a Require header to indicate to the registering User Agent that the registrar used registrations using the binding rules defined in this extension.",
      "ja": "説明：このオプションタグは、クライアント開始された接続用の拡張機能をサポートするUAとレジストラを識別するために使用されます。 UAは、この拡張のサポートを伝えるためにサポートされているヘッダには、このオプションを配置します。レジストラ場所はRequireヘッダーでこのオプションタグは、レジストラは、この拡張で定義された結合規則を使用して登録を使用することを登録ユーザエージェントに指示します。"
    },
    {
      "indent": 0,
      "text": "11.5. 430 (Flow Failed) Response Code",
      "section_title": true,
      "ja": "11.5。 430（フローが失敗しました）応答コード"
    },
    {
      "indent": 3,
      "text": "This document registers a new SIP response code (430 Flow Failed), as per the guidelines in Section 27.4 of [RFC3261]. This response code is used by an edge proxy to indicate to the Authoritative Proxy that a specific flow to a UA instance has failed. Other flows to the same instance could still succeed. The Authoritative Proxy SHOULD attempt to forward to another target (flow) with the same instance-id and AOR. Endpoints should never receive a 430 response. If an endpoint receives a 430 response, it should treat it as a 400 (Bad Request) per normal procedures, as in Section 8.1.3.2 of [RFC3261]. This response code is defined by the following information, which has been added to the method and response-code sub-registry under the SIP Parameters registry.",
      "ja": "この文書では、[RFC3261]のセクション27.4のガイドラインに従って、新しいSIP応答コード（430フローが失敗した）を登録します。この応答コードは、UAインスタンスに特定のフローが失敗したことを権威プロキシに示すためにエッジプロキシによって使用されます。同じインスタンスに他のフローは、まだ成功することができます。権威プロキシは、同じインスタンスIDとAORと別の標的（フロー）に転送しようとすべきです。エンドポイントは430応答を受け取ることはありません。エンドポイントは430応答を受信した場合、それは[RFC3261]のセクション8.1.3.2のように、通常の手順に従って400（悪いRequest）として扱うべきです。この応答コードは、SIPパラメータレジストリ下方法と応答コードのサブレジストリに追加された次の情報によって定義されます。"
    },
    {
      "indent": 5,
      "text": "Response Code                               Reference\n------------------------------------------  ---------\nRequest Failure 4xx\n  430 Flow Failed                           [RFC5626]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.6. 439 (First Hop Lacks Outbound Support) Response Code",
      "section_title": true,
      "ja": "11.6。 439応答コード（ファーストホップアウトバウンドサポートされません）"
    },
    {
      "indent": 3,
      "text": "This document registers a new SIP response code (439 First Hop Lacks Outbound Support), as per the guidelines in Section 27.4 of [RFC3261]. This response code is used by a registrar to indicate that it supports the 'outbound' feature described in this specification, but that the first outbound proxy that the user is attempting to register through does not. Note that this response code is only appropriate in the case that the registering User Agent advertises support for outbound processing by including the outbound option tag in a Supported header field. Proxies MUST NOT send a 439 response to any requests that do not contain a \"reg-id\" parameter and an outbound option tag in a Supported header field. This response code is defined by the following information, which has been added to the method and response-code sub-registry under the SIP Parameters registry.",
      "ja": "このドキュメントは[RFC3261]のセクション27.4のガイドラインに従って、（439最初のホップの送信サポートを欠いている）新しいSIP応答コードを登録します。この応答コードは、それが本明細書に記載された「アウトバウンド」機能をサポートしていることが、ユーザが通過登録しようとしている最初のアウトバウンドプロキシがないことを示すためにレジストラによって使用されます。この応答コードが登録ユーザエージェントがサポートされているヘッダフィールドのアウトバウンドオプションタグを含めることによって、送信処理のためのサポートをアドバタイズする場合にのみ適切であることに留意されたいです。プロキシはサポートされているヘッダフィールドに「REG-ID」パラメータやアウトバウンドオプションタグが含まれていないすべての要求に439応答を送ってはいけません。この応答コードは、SIPパラメータレジストリ下方法と応答コードのサブレジストリに追加された次の情報によって定義されます。"
    },
    {
      "indent": 5,
      "text": "Response Code                               Reference\n------------------------------------------  ---------\nRequest Failure 4xx\n  439 First Hop Lacks Outbound Support      [RFC&rfc.number;]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.7. Media Feature Tag",
      "section_title": true,
      "ja": "11.7。メディア特徴デー"
    },
    {
      "indent": 3,
      "text": "This section registers a new media feature tag, per the procedures defined in [RFC2506]. The tag is placed into the sip tree, which is defined in [RFC3840].",
      "ja": "このセクションでは、[RFC2506]で定義された手順に従って、新しいメディア特徴タグを登録します。タグは[RFC3840]で定義されているSIPツリーに配置されます。"
    },
    {
      "indent": 3,
      "text": "Media feature tag name: sip.instance",
      "ja": "メディアフィーチャータグ名：sip.instance"
    },
    {
      "indent": 3,
      "text": "ASN.1 Identifier: 23",
      "ja": "ASN.1識別子：23"
    },
    {
      "indent": 3,
      "text": "Summary of the media feature indicated by this tag: This feature tag contains a string containing a URN that indicates a unique identifier associated with the UA instance registering the Contact.",
      "ja": "このタグで示されるメディアフィーチャーの概要：このフィーチャータグは、連絡先を登録するUAのインスタンスに関連付けられた一意の識別子を示すURNを含む文字列が含まれています。"
    },
    {
      "indent": 3,
      "text": "Values appropriate for use with this feature tag: String (equality relationship).",
      "ja": "文字列（平等の関係）：この機能タグで使用するための適切な値。"
    },
    {
      "indent": 3,
      "text": "The feature tag is intended primarily for use in the following applications, protocols, services, or negotiation mechanisms: This feature tag is most useful in a communications application, for describing the capabilities of a device, such as a phone or PDA.",
      "ja": "フィーチャータグは、主に以下のアプリケーション、プロトコル、サービス、または交渉メカニズムにおける使用のために意図されています。この機能タグは、このような携帯電話やPDAなどのデバイスの機能を記述するために、通信アプリケーションに最も有用です。"
    },
    {
      "indent": 3,
      "text": "Examples of typical use: Routing a call to a specific device.",
      "ja": "典型的な使用例：特定のデバイスへのコールをルーティング。"
    },
    {
      "indent": 3,
      "text": "Related standards or documents: RFC 5626",
      "ja": "関連する規格または文書：RFC 5626"
    },
    {
      "indent": 3,
      "text": "Security Considerations: This media feature tag can be used in ways which affect application behaviors. For example, the SIP caller preferences extension [RFC3841] allows for call routing decisions to be based on the values of these parameters. Therefore, if an attacker can modify the values of this tag, they might be able to affect the behavior of applications. As a result, applications that utilize this media feature tag SHOULD provide a means for ensuring its integrity. Similarly, this feature tag should only be trusted as valid when it comes from the user or User Agent described by the tag. As a result, protocols for conveying this feature tag SHOULD provide a mechanism for guaranteeing authenticity.",
      "ja": "セキュリティの考慮：このメディアフィーチャータグは、アプリケーションの動作に影響を与える方法で使用することができます。例えば、SIP発信者プリファレンス拡張[RFC3841]は、これらのパラメータの値に基づいするコールルーティングの決定を可能にします。攻撃者がこのタグの値を変更することができればそれゆえ、彼らは、アプリケーションの動作に影響を与えることができるかもしれません。その結果、このメディアフィーチャータグを使用するアプリケーションは、完全性を保証するための手段を提供する必要があります。それはタグで記述されたユーザーまたはユーザーエージェントから来ている場合も同様に、この機能タグのみが有効として信頼されなければなりません。結果として、この機能タグを搬送するためのプロトコルは、信頼性を保証するためのメカニズムを提供しなければなりません。"
    },
    {
      "indent": 0,
      "text": "12. Security Considerations",
      "section_title": true,
      "ja": "12.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "One of the key security concerns in this work is making sure that an attacker cannot hijack the sessions of a valid user and cause all calls destined to that user to be sent to the attacker. Note that the intent is not to prevent existing active attacks on SIP UDP and TCP traffic, but to ensure that no new attacks are added by introducing the outbound mechanism.",
      "ja": "この作品の重要なセキュリティ上の懸念の一つは、攻撃者が有効なユーザーのセッションをハイジャックし、そのユーザー宛てのすべてのコールが攻撃者に送信させることができないことを確認しています。意図は、SIP UDPやTCPトラフィックに既存のアクティブな攻撃を防ぐために、ない新しい攻撃が発信メカニズムを導入することで追加されていないことを保証するものではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The simple case is when there are no edge proxies. In this case, the only time an entry can be added to the routing for a given AOR is when the registration succeeds. SIP already protects against attackers being able to successfully register, and this scheme relies on that security. Some implementers have considered the idea of just saving the instance-id without relating it to the AOR with which it registered. This idea will not work because an attacker's UA can impersonate a valid user's instance-id and hijack that user's calls.",
      "ja": "いかなるエッジプロキシが存在しない場合、単純なケースです。登録が成功した場合この場合は、エントリが与えられたAORのルーティングに添加することができる唯一の時間です。 SIPは、すでに正常に登録することができるという攻撃から保護し、そしてこの方式は、セキュリティに依存しています。いくつかの実装は、ちょうどそれが登録されてAORにそれを関連せずにインスタンスIDを保存するという考えと考えられてきました。攻撃者のUAが有効なユーザーのインスタンスIDを偽装し、そのユーザの通話をハイジャックすることができますので、このアイデアは動作しません。"
    },
    {
      "indent": 3,
      "text": "The more complex case involves one or more edge proxies. When a UA sends a REGISTER request through an edge proxy on to the registrar, the edge proxy inserts a Path header field value. If the registration is successfully authenticated, the registrar stores the value of the Path header field. Later, when the registrar forwards a request destined for the UA, it copies the stored value of the Path header field into the Route header field of the request and forwards the request to the edge proxy.",
      "ja": "より複雑な場合は、一つ以上のエッジプロキシを含みます。 UAはレジストラ上にエッジプロキシを介して登録要求を送信した場合、エッジプロキシはパスヘッダフィールド値を挿入します。登録が正常に認証された場合、レジストラは、Pathヘッダフィールドの値を格納します。後、レジストラは、その要求のRouteヘッダフィールドにコピーパスヘッダフィールドの格納された値を、UA宛の要求を転送し、エッジプロキシに要求を転送します。"
    },
    {
      "indent": 3,
      "text": "The only time an edge proxy will route over a particular flow is when it has received a Route header that has the flow identifier information that it has created. An incoming request would have gotten this information from the registrar. The registrar will only save this information for a given AOR if the registration for the AOR has been successful; and the registration will only be successful if the UA can correctly authenticate. Even if an attacker has spoofed some bad information in the Path header sent to the registrar, the attacker will not be able to get the registrar to accept this information for an AOR that does not belong to the attacker. The registrar will not hand out this bad information to others, and others will not be misled into contacting the attacker.",
      "ja": "それが作成したフロー識別子情報を有するRouteヘッダを受信したときにエッジプロキシだけ時間が特定のフロー上の経路があるであろう。着信要求は、レジストラからこの情報を得ているでしょう。 AORの登録が成功した場合、レジストラにのみ与えられたAORのためにこの情報を保存します。 UAが正しく認証できた場合、登録にのみ成功します。攻撃者はレジストラに送信されたPathヘッダにいくつかの悪い情報を詐称している場合でも、攻撃者は、攻撃者に属していないAORのために、この情報を受け入れるようにレジストラを取得することができなくなります。レジストラは、他の人にこの悪い情報を配るないだろう、と他の人が攻撃者に連絡に惑わされないであろう。"
    },
    {
      "indent": 3,
      "text": "The Security Considerations discussed in [RFC3261] and [RFC3327] are also relevant to this document. For the security considerations of generating flow tokens, please also see Section 5.2. A discussion of preventing the avalanche restart problem is in Section 4.5.",
      "ja": "[RFC3261]と[RFC3327]で議論セキュリティの考慮事項も、このドキュメントに関連しています。フロー・トークンを生成するセキュリティ上の考慮事項については、また、5.2節を参照してください。雪崩の再起動の問題を防止する議論は、セクション4.5です。"
    },
    {
      "indent": 3,
      "text": "This document does not change the mandatory-to-implement security mechanisms in SIP. User Agents are already required to implement Digest authentication while support of TLS is recommended; proxy servers are already required to implement Digest and TLS.",
      "ja": "この文書では、SIPでの実装に必須のセキュリティメカニズムは変更されません。 TLSのサポートが推奨されている間、ユーザーエージェントは、すでにダイジェスト認証を実装するために必要とされています。プロキシサーバは、すでにダイジェストとTLSを実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "13. Operational Notes on Transports",
      "section_title": true,
      "ja": "トランスポート13.使用上の注意"
    },
    {
      "indent": 3,
      "text": "This entire section is non-normative.",
      "ja": "このセクション全体では非規範的です。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] requires proxies, registrars, and User Agents to implement both TCP and UDP but deployments can chose which transport protocols they want to use. Deployments need to be careful in choosing what transports to use. Many SIP features and extensions, such as large presence notification bodies, result in SIP requests that can be too large to be reasonably transported over UDP. [RFC3261] states that when a request is too large for UDP, the device sending the request attempts to switch over to TCP. It is important to note that when using outbound, this will only work if the UA has formed both UDP and TCP outbound flows. This specification allows the UA to do so, but in most cases it will probably make more sense for the UA to form a TCP outbound connection only, rather than forming both UDP and TCP flows. One of the key reasons that many deployments choose not to use TCP has to do with the difficulty of building proxies that can maintain a very large number of active TCP connections. Many deployments today use SIP in such a way that the messages are small enough that they work over UDP but they can not take advantage of all the functionality SIP offers. Deployments that use only UDP outbound connections are going to fail with sufficiently large SIP messages.",
      "ja": "[RFC3261]はTCPとUDPの両方を実装するために、プロキシ、レジストラ、およびユーザエージェントが必要ですが、展開は、彼らが使用したいのトランスポートプロトコルを選択できます。配備は、使用するトランスポート何選ぶ際に注意する必要があります。このような大規模なプレゼンス通知体として多くのSIP機能と拡張は、合理的にUDP上で転送するには大きすぎることができSIPリクエストにつながります。 [RFC3261]は、要求がUDPに対して大きすぎる場合、要求を送信するデバイスがTCPに切り替えるしようと述べています。アウトバウンドを使用した場合、UAは両方のUDPおよびTCPアウトバウンドの流れを形成している場合、これはのみ動作することに注意することが重要です。この仕様は、UAがそうすることができますが、UAは、むしろUDPとTCPフローの両方を形成するよりも、唯一のTCPアウトバウンド接続を形成するために、ほとんどの場合、それはおそらくより多くの意味を行います。多くの配備は、TCPを使用しないことを選択することを主な理由の一つは、アクティブなTCP接続の非常に大きな数を維持することができるプロキシを構築することの難しさに関係しています。メッセージは、彼らはUDP上で動作しますが、彼らはすべての機能のSIPの申し出を利用することができないことを十分に小さいような方法で、多くの配備今日の使用SIP。唯一のUDPアウトバウンド接続を使用する展開は十分に大きいSIPメッセージで失敗しようとしています。"
    },
    {
      "indent": 0,
      "text": "14. Requirements",
      "section_title": true,
      "ja": "14.要件"
    },
    {
      "indent": 3,
      "text": "This specification was developed to meet the following requirements:",
      "ja": "この仕様は、次の要件を満たすために開発されました："
    },
    {
      "indent": 3,
      "text": "1. Must be able to detect that a UA supports these mechanisms.",
      "section_title": true,
      "ja": "1. UAはこれらのメカニズムをサポートしていることを検出することができる必要があります。"
    },
    {
      "indent": 3,
      "text": "2. Support UAs behind NATs.",
      "section_title": true,
      "ja": "NATの背後2.サポートのUA。"
    },
    {
      "indent": 3,
      "text": "3. Support TLS to a UA without a stable DNS name or IP address.",
      "section_title": true,
      "ja": "安定したDNS名またはIPアドレスを持たないUA 3.サポートTLS。"
    },
    {
      "indent": 3,
      "text": "4. Detect failure of a connection and be able to correct for this.",
      "section_title": true,
      "ja": "4.接続の障害を検出し、これを修正することができます。"
    },
    {
      "indent": 3,
      "text": "5. Support many UAs simultaneously rebooting.",
      "section_title": true,
      "ja": "5.サポート多くのUAが同時に再起動します。"
    },
    {
      "indent": 3,
      "text": "6. Support a NAT rebooting or resetting.",
      "section_title": true,
      "ja": "6. NATリブートまたはリセットをサポートしています。"
    },
    {
      "indent": 3,
      "text": "7. Minimize initial startup load on a proxy.",
      "section_title": true,
      "ja": "7.プロキシの初期起動時の負荷を最小限に抑えます。"
    },
    {
      "indent": 3,
      "text": "8. Support architectures with edge proxies.",
      "section_title": true,
      "ja": "エッジプロキシ8.サポートアーキテクチャ。"
    },
    {
      "indent": 0,
      "text": "15. Acknowledgments",
      "section_title": true,
      "ja": "15.謝辞"
    },
    {
      "indent": 3,
      "text": "Francois Audet acted as document shepherd for this document, tracking hundreds of comments and incorporating many grammatical fixes as well as prodding the editors to \"get on with it\". Jonathan Rosenberg, Erkki Koivusalo, and Byron Campen provided many comments and useful text. Dave Oran came up with the idea of using the most recent registration first in the proxy. Alan Hawrylyshen co-authored the document that formed the initial text of this specification. Additionally, many of the concepts here originated at a connection reuse meeting at IETF 60 that included the authors, Jon Peterson, Jonathan Rosenberg, Alan Hawrylyshen, and Paul Kyzivat. The TCP design team consisting of Chris Boulton, Scott Lawrence, Rajnish Jain, Vijay K. Gurbani, and Ganesh Jayadevan provided input and text. Nils Ohlmeier provided many fixes and initial implementation experience. In addition, thanks to the following folks for useful comments: Francois Audet, Flemming Andreasen, Mike Hammer, Dan Wing, Srivatsa Srinivasan, Dale Worely, Juha Heinanen, Eric Rescorla, Lyndsay Campbell, Christer Holmberg, Kevin Johns, Jeroen van Bemmel, Derek MacDonald, Dean Willis, and Robert Sparks.",
      "ja": "フランソワAudetは、コメントの数百人を追跡し、多くの文法の修正を組み込むだけでなく、「それに乗る」ためのエディタをつつい、この文書の文書羊飼いを務めました。ジョナサン・ローゼンバーグ、エルッキKoivusalo、バイロンCampenは多くのコメントと便利なテキストを提供しました。デイブ・オランは、プロキシで最初に最新の登録を使用してのアイデアを思い付きました。アランHawrylyshenは、本明細書の最初の文字を形成し、ドキュメントを共同執筆しました。また、ここでは概念の多くは作家、ジョン・ピーターソン、ジョナサン・ローゼンバーグ、アランHawrylyshen、そしてポール・Kyzivatを含まIETF 60での接続の再利用の会議で始まりました。クリスボールトン、スコット・ローレンス、Rajnishジャイナ教、ビジェイK. Gurbani、およびガネーシュJayadevanからなるTCPの設計チームは、入力とテキストを提供しました。ニルスOhlmeierは多くの修正と初期の実装経験を提供します。また、有益なコメントについて以下の人々に感謝：フランソワAudet、フレミングAndreasenの、マイク・ハマー、ダン・ウィング、Srivatsaスリニバサン、デイルWorely、ユハHeinanen、エリックレスコラ、リンゼー・キャンベル、クリステルHolmbergの、ケビン・ジョーンズ、イェルーンバンBemmel、デレクマクドナルド、ディーンウィリス、そしてロバート・スパークス。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16.参考文献"
    },
    {
      "indent": 0,
      "text": "16.1. Normative References",
      "section_title": true,
      "ja": "16.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2141] Moats, R., \"URN Syntax\", RFC 2141, May 1997.",
      "ja": "[RFC2141]堀、R.、 \"URN構文\"、RFC 2141、1997年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2506] Holtman, K., Mutz, A., and T. Hardie, \"Media Feature Tag Registration Procedure\", BCP 31, RFC 2506, March 1999.",
      "ja": "[RFC2506] Holtman、K.、MUTZ、A.、およびT.ハーディ、 \"メディア特徴タグの登録手順\"、BCP 31、RFC 2506、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[RFC3261]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 \"SIP：セッション開始プロトコル\" 、RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3263] Rosenberg, J. and H. Schulzrinne, \"Session Initiation Protocol (SIP): Locating SIP Servers\", RFC 3263, June 2002.",
      "ja": "[RFC3263]ローゼンバーグ、J.とH. Schulzrinneと、 \"セッション開始プロトコル（SIP）：SIPサーバの検索\"、RFC 3263、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3327] Willis, D. and B. Hoeneisen, \"Session Initiation Protocol (SIP) Extension Header Field for Registering Non-Adjacent Contacts\", RFC 3327, December 2002.",
      "ja": "[RFC3327]ウィリス、D.とB. Hoeneisen、 \"セッション開始プロトコル非隣接コンタクトを登録するための（SIP）拡張ヘッダーフィールド\"、RFC 3327、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3581] Rosenberg, J. and H. Schulzrinne, \"An Extension to the Session Initiation Protocol (SIP) for Symmetric Response Routing\", RFC 3581, August 2003.",
      "ja": "[RFC3581]ローゼンバーグ、J.、およびH. Schulzrinneと、 \"対称応答ルーティングのためのセッション開始プロトコル（SIP）への拡張\"、RFC 3581、2003年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3840] Rosenberg, J., Schulzrinne, H., and P. Kyzivat, \"Indicating User Agent Capabilities in the Session Initiation Protocol (SIP)\", RFC 3840, August 2004.",
      "ja": "[RFC3840]ローゼンバーグ、J.、Schulzrinneと、H.、およびP. Kyzivat、RFC 3840、2004年8月 \"セッション開始プロトコル（SIP）におけるユーザエージェントの能力を示します\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3841] Rosenberg, J., Schulzrinne, H., and P. Kyzivat, \"Caller Preferences for the Session Initiation Protocol (SIP)\", RFC 3841, August 2004.",
      "ja": "[RFC3841]ローゼンバーグ、J.、Schulzrinneと、H.、およびP. Kyzivat、 \"セッション開始プロトコル（SIP）のための発信者が設定\"、RFC 3841、2004年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3968] Camarillo, G., \"The Internet Assigned Number Authority (IANA) Header Field Parameter Registry for the Session Initiation Protocol (SIP)\", BCP 98, RFC 3968, December 2004.",
      "ja": "[RFC3968]キャマリロ、G.、BCP 98、RFC 3968、2004年12月 \"インターネットは、セッション開始プロトコル（SIP）のための番号機関（IANA）ヘッダーフィールドパラメータレジストリを割り当てられました\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3969] Camarillo, G., \"The Internet Assigned Number Authority (IANA) Uniform Resource Identifier (URI) Parameter Registry for the Session Initiation Protocol (SIP)\", BCP 99, RFC 3969, December 2004.",
      "ja": "[RFC3969]キャマリロ、G.、BCP 99、RFC 3969、2004年12月 \"セッション開始プロトコル（SIP）のための番号機関（IANA）のURI（Uniform Resource Identifier）パラメータレジストリの割り当てインターネット\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4122] Leach, P., Mealling, M., and R. Salz, \"A Universally Unique IDentifier (UUID) URN Namespace\", RFC 4122, July 2005.",
      "ja": "[RFC4122]リーチ、P.、Mealling、M.、およびR. Salzの、 \"汎用一意識別子（UUID）URN名前空間\"、RFC 4122、2005年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, \"Session Traversal Utilities for NAT (STUN)\", RFC 5389, October 2008.",
      "ja": "[RFC5389]ローゼンバーグ、J.、マーイ、R.、マシューズ、P.、およびD.翼、 \"NAT（STUN）のセッショントラバーサルユーティリティ\"、RFC 5389、2008年10月。"
    },
    {
      "indent": 0,
      "text": "16.2. Informative References",
      "section_title": true,
      "ja": "16.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[CONFIG-FMWK] Petrie, D. and S. Channabasappa, Ed., \"A Framework for Session Initiation Protocol User Agent Profile Delivery\", Work in Progress, February 2008.",
      "ja": "[CONFIG-FMWK]ペトリー、D.とS. Channabasappa、エド。、「セッション開始プロトコルユーザエージェントプロファイル配信のためのフレームワーク」は、進歩、2008年2月に作業。"
    },
    {
      "indent": 3,
      "text": "[NAT-SCEN] Boulton, C., Rosenberg, J., Camarillo, G., and F. Audet, \"Best Current Practices for NAT Traversal for Client-Server SIP\", Work in Progress, September 2008.",
      "ja": "[NAT-SCEN]ボールトン、C.、ローゼンバーグ、J.、カマリロ、G.、およびF. Audet、 \"クライアント・サーバのSIP用NATトラバーサルのためのベストプラクティスの現在\"、進歩、2008年9月の作業。"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "ja": "[RFC0768]ポステル、J.、 \"ユーザ・データグラム・プロトコル\"、STD 6、RFC 768、1980年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC0793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, November 1987.",
      "ja": "[RFC1035] Mockapetris、P.、 \"ドメイン名 - 実装及び仕様\"、STD 13、RFC 1035、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2131] Droms, R., \"Dynamic Host Configuration Protocol\", RFC 2131, March 1997.",
      "ja": "[RFC2131] Droms、R.、 \"動的ホスト構成プロトコル\"、RFC 2131、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, February 2000.",
      "ja": "[RFC2782] Gulbrandsenの、A.、いるVixie、P.、およびL. Esibov、 \"サービスの場所を特定するためのDNS RR（DNSのSRV）\"、RFC 2782、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3320] Price, R., Bormann, C., Christoffersson, J., Hannu, H., Liu, Z., and J. Rosenberg, \"Signaling Compression (SigComp)\", RFC 3320, January 2003.",
      "ja": "[RFC3320]価格、R.、ボルマン、C.、Christoffersson、J.、ハンヌ、H.、劉、Z.、およびJ.ローゼンバーグ、 \"シグナリング圧縮（SigCompの）\"、RFC 3320、2003年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3489] Rosenberg, J., Weinberger, J., Huitema, C., and R. Mahy, \"STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)\", RFC 3489, March 2003.",
      "ja": "[RFC3489]ローゼンバーグ、J.、ワインバーガー、J.、のHuitema、C.、およびR.マーイ、 -  2003年3月、RFC 3489 \"STUNネットワークを介して、ユーザーデータグラムプロトコル（UDP）の簡単なトラバーサルは、翻訳者（NATのを）アドレス\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4340] Kohler, E., Handley, M., and S. Floyd, \"Datagram Congestion Control Protocol (DCCP)\", RFC 4340, March 2006.",
      "ja": "[RFC4340]コーラー、E.、ハンドリー、M.、およびS.フロイド、 \"データグラム輻輳制御プロトコル（DCCP）\"、RFC 4340、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、2006年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., \"Stream Control Transmission Protocol\", RFC 4960, September 2007.",
      "ja": "[RFC4960]スチュワート、R.、 \"ストリーム制御伝送プロトコル\"、RFC 4960、2007年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5627] Rosenberg, J., \"Obtaining and Using Globally Routable User Agent URIs (GRUUs) in the Session Initiation Protocol (SIP)\", RFC 5627, October 2009.",
      "ja": "[RFC5627]ローゼンバーグ、J.、RFC 5627、2009年10月 \"セッション開始プロトコル（SIP）でグローバルにルーティング可能なユーザエージェントのURI（GRUUs）の取得と使用\" を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Default Flow Registration Backoff Times",
      "ja": "付録A.デフォルトのフロー登録バックオフタイムズ"
    },
    {
      "indent": 3,
      "text": "The base-time used for the flow re-registration backoff times described in Section 4.5 are configurable. If the base-time-all-fail value is set to the default of 30 seconds and the base-time-not-failed value is set to the default of 90 seconds, the following table shows the resulting amount of time the UA will wait to retry registration.",
      "ja": "セクション4.5で説明したフローの再登録バックオフ時間のために用いられる塩基時間が設定されています。ベース時間は、すべて失敗値は30秒​​のデフォルトとベース時間-失敗しない値に設定されている場合は、90秒のデフォルトに設定され、次の表では、UAが待機する時間の結果の量を示しています登録を再試行します。"
    },
    {
      "indent": 5,
      "text": "+-------------------+--------------------+---------------------+\n| # of reg failures | all flows unusable | > 1 non-failed flow |\n+-------------------+--------------------+---------------------+\n| 0                 | 0 s                | 0 s                 |\n| 1                 | 30-60 s            | 90-180 s            |\n| 2                 | 1-2 min            | 3-6 min             |\n| 3                 | 2-4 min            | 6-12 min            |\n| 4                 | 4-8 min            | 12-24 min           |\n| 5                 | 8-16 min           | 15-30 min           |\n| 6 or more         | 15-30 min          | 15-30 min           |\n+-------------------+--------------------+---------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix B. ABNF",
      "ja": "付録B. ABNF"
    },
    {
      "indent": 3,
      "text": "This appendix contains the ABNF defined earlier in this document.",
      "ja": "この付録では、以前この文書の定義されたABNFが含まれています。"
    },
    {
      "indent": 6,
      "text": "CRLF = CR LF double-CRLF = CR LF CR LF CR = %x0D LF = %x0A",
      "ja": "CRLF = CR LF二CRLF = CR LF CR LF CR =％x0D LF =％X0A"
    },
    {
      "indent": 6,
      "text": "Flow-Timer = \"Flow-Timer\" HCOLON 1*DIGIT",
      "ja": "フロー・タイマー=「フロー・タイマ」HCOLON 1 * DIGIT"
    },
    {
      "indent": 6,
      "text": "contact-params =/ c-p-reg / c-p-instance",
      "ja": "コンタクト-paramsは= / C-P-REG / C-P-インスタンス"
    },
    {
      "indent": 6,
      "text": "c-p-reg = \"reg-id\" EQUAL 1*DIGIT ; 1 to (2^31 - 1)",
      "ja": "C-P-REG = \"REG-ID\" EQUAL 1 * DIGIT。 1（1  -  2 ^ 31）に"
    },
    {
      "indent": 6,
      "text": "c-p-instance = \"+sip.instance\" EQUAL DQUOTE \"<\" instance-val \">\" DQUOTE",
      "ja": "C-P-インスタンス= \"+ sip.instance\" EQUAL DQUOTE \"<\" インスタンス-VAL \">\" DQUOTE"
    },
    {
      "indent": 6,
      "text": "instance-val = 1*uric ; defined in RFC 3261",
      "ja": "インスタンス-VAL = 1 *尿。 RFC 3261で定義されています"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Cullen Jennings (editor) Cisco Systems 170 West Tasman Drive Mailstop SJC-21/2 San Jose, CA 95134 USA",
      "ja": "カレンジェニングス（編集者）、シスコシステムズ170西タスマンドライブメールストップSJC-2分の21サンノゼ、CA 95134 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 902-3341 EMail: fluffy@cisco.com",
      "ja": "電話：+1 408 902-3341 Eメール：fluffy@cisco.com"
    },
    {
      "indent": 3,
      "text": "Rohan Mahy (editor) Unaffiliated",
      "ja": "ローハンマーイ（編集者）無所属"
    },
    {
      "indent": 3,
      "text": "EMail: rohan@ekabal.com",
      "ja": "メールアドレス：rohan@ekabal.com"
    },
    {
      "indent": 3,
      "text": "Francois Audet (editor) Skype Labs",
      "ja": "フランソワAudet（エディタ）スカイプ研究所"
    },
    {
      "indent": 3,
      "text": "EMail: francois.audet@skypelabs.com",
      "ja": "メールアドレス：francois.audet@skypelabs.com"
    }
  ]
}