{
  "title": {
    "text": "RFC 5681 - TCP Congestion Control",
    "ja": "RFC 5681 - TCPの輻輳制御"
  },
  "number": 5681,
  "created_at": "2019-10-27 11:26:21.426020+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          M. Allman\nRequest for Comments: 5681                                     V. Paxson\nObsoletes: 2581                                                     ICSI\nCategory: Standards Track                                     E. Blanton\n                                                       Purdue University\n                                                          September 2009",
      "raw": true
    },
    {
      "indent": 25,
      "text": "TCP Congestion Control",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document defines TCP's four intertwined congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery. In addition, the document specifies how TCP should begin transmission after a relatively long idle period, as well as discussing various acknowledgment generation methods. This document obsoletes RFC 2581.",
      "ja": "スロースタート、輻輳回避、高速再送、高速回復：このドキュメントでは、TCPの4つの絡み合った輻輳制御アルゴリズムを定義します。また、ドキュメントは、TCPが比較的長いアイドル期間の後に送信を開始、並びに種々の確認生成方法を議論する方法を指定します。この文書はRFC 2581を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2009 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2009 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents in effect on the date of publication of this document (http://trustee.ietf.org/license-info). Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書（http://trustee.ietf.org/license-info）の発行日に有効なIETFドキュメントに関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table Of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n2. Definitions .....................................................3\n3. Congestion Control Algorithms ...................................4\n   3.1. Slow Start and Congestion Avoidance ........................4\n   3.2. Fast Retransmit/Fast Recovery ..............................8\n4. Additional Considerations ......................................10\n   4.1. Restarting Idle Connections ...............................10\n   4.2. Generating Acknowledgments ................................11\n   4.3. Loss Recovery Mechanisms ..................................12\n5. Security Considerations ........................................13\n6. Changes between RFC 2001 and RFC 2581 ..........................13\n7. Changes Relative to RFC 2581 ...................................14\n8. Acknowledgments ................................................15\n9. References .....................................................15\n   9.1. Normative References ......................................15\n   9.2. Informative References ....................................16",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies four TCP [RFC793] congestion control algorithms: slow start, congestion avoidance, fast retransmit and fast recovery. These algorithms were devised in [Jac88] and [Jac90]. Their use with TCP is standardized in [RFC1122]. Additional early work in additive-increase, multiplicative-decrease congestion control is given in [CJ89].",
      "ja": "スロースタート、輻輳回避、高速再送と高速リカバリ：この文書では、4 TCP [RFC793]輻輳制御アルゴリズムを指定します。これらのアルゴリズムは、[Jac90] [Jac88]および考案されました。 TCPでのこれらの使用は[RFC1122]で標準化されています。添加剤の増加で追加の初期の作品は、乗法-減少輻輳制御は[CJ89]で与えられています。"
    },
    {
      "indent": 3,
      "text": "Note that [Ste94] provides examples of these algorithms in action and [WS95] provides an explanation of the source code for the BSD implementation of these algorithms.",
      "ja": "[Ste94]アクションおよび[WS95]でこれらのアルゴリズムの例を提供することに注意することは、これらのアルゴリズムのBSD実装のソースコードの説明を提供します。"
    },
    {
      "indent": 3,
      "text": "In addition to specifying these congestion control algorithms, this document specifies what TCP connections should do after a relatively long idle period, as well as specifying and clarifying some of the issues pertaining to TCP ACK generation.",
      "ja": "これらの輻輳制御アルゴリズムを指定するだけでなく、この文書には、TCP接続が指定し、TCP ACK生成に関連する問題のいくつかを明確にするだけでなく、比較的長いアイドル期間の後に何をすべきかを指定します。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes [RFC2581], which in turn obsoleted [RFC2001].",
      "ja": "この文書では、順番に廃止[RFC2581]、[RFC2001]を廃止します。"
    },
    {
      "indent": 3,
      "text": "This document is organized as follows. Section 2 provides various definitions that will be used throughout the document. Section 3 provides a specification of the congestion control algorithms. Section 4 outlines concerns related to the congestion control algorithms and finally, section 5 outlines security considerations.",
      "ja": "次のようにこの文書は、組織化されています。第2節では、文書全体で使用される様々な定義を提供します。セクション3は、輻輳制御アルゴリズムの仕様を提供します。第4節では、輻輳制御アルゴリズムに関連した懸念を概説し、最終的に、セクション5は、セキュリティ上の考慮事項の概要を説明します。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2.定義"
    },
    {
      "indent": 3,
      "text": "This section provides the definition of several terms that will be used throughout the remainder of this document.",
      "ja": "このセクションでは、この文書の残りの部分の全体にわたって使用されるいくつかの用語の定義を提供します。"
    },
    {
      "indent": 3,
      "text": "SEGMENT: A segment is ANY TCP/IP data or acknowledgment packet (or both).",
      "ja": "SEGMENT：セグメントは、任意のTCP / IPデータ又は確認応答パケット（またはその両方）です。"
    },
    {
      "indent": 3,
      "text": "SENDER MAXIMUM SEGMENT SIZE (SMSS): The SMSS is the size of the largest segment that the sender can transmit. This value can be based on the maximum transmission unit of the network, the path MTU discovery [RFC1191, RFC4821] algorithm, RMSS (see next item), or other factors. The size does not include the TCP/IP headers and options.",
      "ja": "SENDER最大セグメントサイズ（SMSS）：SMSSは、送信者が送信できる最大セグメントサイズです。この値は、ネットワークの最大転送単位、パスMTU探索[RFC1191、RFC4821]アルゴリズム、RMSS（次の項目を参照）、または他の要因に基づくことができます。サイズは、TCP / IPヘッダおよびオプションが含まれていません。"
    },
    {
      "indent": 3,
      "text": "RECEIVER MAXIMUM SEGMENT SIZE (RMSS): The RMSS is the size of the largest segment the receiver is willing to accept. This is the value specified in the MSS option sent by the receiver during connection startup. Or, if the MSS option is not used, it is 536 bytes [RFC1122]. The size does not include the TCP/IP headers and options.",
      "ja": "受信最大セグメントサイズ（RMSS）：RMSSは、受信機が受け入れる意志がある最大セグメントサイズです。これは、接続の起動時に受信機によって送信されたMSSオプションで指定した値です。 MSSオプションが使用されていない場合や、それが536バイト[RFC1122]です。サイズは、TCP / IPヘッダおよびオプションが含まれていません。"
    },
    {
      "indent": 3,
      "text": "FULL-SIZED SEGMENT: A segment that contains the maximum number of data bytes permitted (i.e., a segment containing SMSS bytes of data).",
      "ja": "フルサイズのセグメント：許可されたデータバイトの最大数を含むセグメント（すなわち、データのSMSSバイトを含むセグメント）。"
    },
    {
      "indent": 3,
      "text": "RECEIVER WINDOW (rwnd): The most recently advertised receiver window.",
      "ja": "RECEIVER WINDOW（RWND）：最近宣伝受信ウィンドウ。"
    },
    {
      "indent": 3,
      "text": "CONGESTION WINDOW (cwnd): A TCP state variable that limits the amount of data a TCP can send. At any given time, a TCP MUST NOT send data with a sequence number higher than the sum of the highest acknowledged sequence number and the minimum of cwnd and rwnd.",
      "ja": "輻輳ウィンドウ（CWND）：TCPが送信できるデータの量を制限するTCPステート変数。任意の時点で、TCPは最高認めシーケンス番号とのcwndとRWNDの最小値の合計よりも高いシーケンス番号のデータを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "INITIAL WINDOW (IW): The initial window is the size of the sender's congestion window after the three-way handshake is completed.",
      "ja": "INITIAL WINDOW（IW）：3ウェイハンドシェイクが完了した後、最初のウィンドウは、送信者の輻輳ウィンドウのサイズです。"
    },
    {
      "indent": 3,
      "text": "LOSS WINDOW (LW): The loss window is the size of the congestion window after a TCP sender detects loss using its retransmission timer.",
      "ja": "損失WINDOW（LW）：TCPの送信側がその再送タイマを使用して損失を検出した後、ロス・ウィンドウは、輻輳ウィンドウのサイズです。"
    },
    {
      "indent": 3,
      "text": "RESTART WINDOW (RW): The restart window is the size of the congestion window after a TCP restarts transmission after an idle period (if the slow start algorithm is used; see section 4.1 for more discussion).",
      "ja": "RESTARTのウィンドウ（RW）：リスタートウィンドウは、TCPがアイドル期間の後に送信を再開した後に、輻輳ウィンドウのサイズである（スロースタートアルゴリズムが使用される場合、より多くの議論のためのセクション4.1を参照します）。"
    },
    {
      "indent": 3,
      "text": "FLIGHT SIZE: The amount of data that has been sent but not yet cumulatively acknowledged.",
      "ja": "FLIGHTサイズ：送信されたがまだ累積認識されているデータの量。"
    },
    {
      "indent": 3,
      "text": "DUPLICATE ACKNOWLEDGMENT: An acknowledgment is considered a \"duplicate\" in the following algorithms when (a) the receiver of the ACK has outstanding data, (b) the incoming acknowledgment carries no data, (c) the SYN and FIN bits are both off, (d) the acknowledgment number is equal to the greatest acknowledgment received on the given connection (TCP.UNA from [RFC793]) and (e) the advertised window in the incoming acknowledgment equals the advertised window in the last incoming acknowledgment.",
      "ja": "謝辞を複製：肯定応答は、（a）は、ACKの受信機は、未処理のデータがある場合（C）、（B）受信確認応答がデータを搬送しない、以下のアルゴリズムにおいて「重複」SYNとFINビットは、両方ともオフであると考えられています（D）確認応答番号が最大承認が与えられた接続（[RFC793]からTCP.UNA）及び（e）に等しい受信された受信確認応答に広告ウィンドウは、最後の受信確認応答で広告ウィンドウに等しいです。"
    },
    {
      "indent": 6,
      "text": "Alternatively, a TCP that utilizes selective acknowledgments (SACKs) [RFC2018, RFC2883] can leverage the SACK information to determine when an incoming ACK is a \"duplicate\" (e.g., if the ACK contains previously unknown SACK information).",
      "ja": "あるいは、選択的肯定応答を利用するTCP（サック）[RFC2018、RFC2883]は着信ACKが「複製」（例えば、ACKが以前に未知のSACK情報が含まれている場合）であるときを決定するためにSACK情報を活用することができます。"
    },
    {
      "indent": 0,
      "text": "3. Congestion Control Algorithms",
      "section_title": true,
      "ja": "3.輻輳制御アルゴリズム"
    },
    {
      "indent": 3,
      "text": "This section defines the four congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery, developed in [Jac88] and [Jac90]. In some situations, it may be beneficial for a TCP sender to be more conservative than the algorithms allow; however, a TCP MUST NOT be more aggressive than the following algorithms allow (that is, MUST NOT send data when the value of cwnd computed by the following algorithms would not allow the data to be sent).",
      "ja": "スロースタート、輻輳回避、高速再送、高速回復、で開発された[Jac88]と[Jac90]：このセクションでは、4つの輻輳制御アルゴリズムを定義します。いくつかの状況では、アルゴリズムが許すよりも保守的にTCP送信者のために有益であり得ます。しかし、TCPは、次のアルゴリズムは、（次のアルゴリズムによって計算のcwndの値は、データが送信されることを許可しないだろうというときつまり、データを送ってはいけません）を許可よりもより積極的にすることはできません。"
    },
    {
      "indent": 3,
      "text": "Also, note that the algorithms specified in this document work in terms of using loss as the signal of congestion. Explicit Congestion Notification (ECN) could also be used as specified in [RFC3168].",
      "ja": "また、アルゴリズムは混雑の信号として損失を使用しての面で、この文書の作業で指定されたことに注意してください。 [RFC3168]で指定されるように明示的輻輳通知（ECN）を使用することもできます。"
    },
    {
      "indent": 0,
      "text": "3.1. Slow Start and Congestion Avoidance",
      "section_title": true,
      "ja": "3.1。スロースタートと輻輳回避"
    },
    {
      "indent": 3,
      "text": "The slow start and congestion avoidance algorithms MUST be used by a TCP sender to control the amount of outstanding data being injected into the network. To implement these algorithms, two variables are added to the TCP per-connection state. The congestion window (cwnd) is a sender-side limit on the amount of data the sender can transmit into the network before receiving an acknowledgment (ACK), while the receiver's advertised window (rwnd) is a receiver-side limit on the amount of outstanding data. The minimum of cwnd and rwnd governs data transmission.",
      "ja": "スロースタートと輻輳回避アルゴリズムは、ネットワークに注入される未処理データの量を制御するために、TCP送信者によって使用されなければなりません。これらのアルゴリズムを実装するには、二つの変数は、TCPコネクションごとの状態に追加されます。受信機の広告ウィンドウ（RWNDが）の量に受信側の限界である輻輳ウィンドウ（CWND）は、送信側が確認応答（ACK）を受信する前にネットワークに送信できるデータの量に、送信者側の限界であります優れたデータ。 CWNDおよびRWNDの最小値は、データ送信を司ります。"
    },
    {
      "indent": 3,
      "text": "Another state variable, the slow start threshold (ssthresh), is used to determine whether the slow start or congestion avoidance algorithm is used to control data transmission, as discussed below.",
      "ja": "後述するように別の状態変数、スロースタート閾値（SSTHRESH）は、スロースタートや輻輳回避アルゴリズムは、データ伝送を制御するために使用されているかどうかを決定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Beginning transmission into a network with unknown conditions requires TCP to slowly probe the network to determine the available capacity, in order to avoid congesting the network with an inappropriately large burst of data. The slow start algorithm is used for this purpose at the beginning of a transfer, or after repairing loss detected by the retransmission timer. Slow start additionally serves to start the \"ACK clock\" used by the TCP sender to release data into the network in the slow start, congestion avoidance, and loss recovery algorithms.",
      "ja": "未知の条件でネットワークへの送信を開始すると、データの不適切な大規模なバーストでネットワークを輻輳を避けるために、ゆっくりと利用可能な容量を決定するためにネットワークをプローブするTCPが必要です。スロースタートアルゴリズムは、転送の開始時、または再送タイマによって検出された損失を修復した後、この目的のために使用されます。スロースタートは、さらにスロースタートでネットワークにデータを解放するために、TCP送信者によって使用される「ACKクロック」、輻輳回避、および損失回復アルゴリズムを開始するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "IW, the initial value of cwnd, MUST be set using the following guidelines as an upper bound.",
      "ja": "IW、cwndの初期値は、上限として、次のガイドラインを使用して設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If SMSS > 2190 bytes: IW = 2 * SMSS bytes and MUST NOT be more than 2 segments If (SMSS > 1095 bytes) and (SMSS <= 2190 bytes): IW = 3 * SMSS bytes and MUST NOT be more than 3 segments if SMSS <= 1095 bytes: IW = 4 * SMSS bytes and MUST NOT be more than 4 segments",
      "ja": "SMSS> 2190バイトの場合：IWは、2つの* SMSSバイトを=と（SMSS> 1095バイト）及び（SMSS <= 2190バイト）の場合は2つの以上のセグメントであってはいけません：IW 3つの*のSMSSバイトを=と3つの以上のセグメントであってはいけませんSMSS <= 1095バイトの場合：IWは、4つの*のSMSSバイトを=と4つの以上のセグメントであってはいけません"
    },
    {
      "indent": 3,
      "text": "As specified in [RFC3390], the SYN/ACK and the acknowledgment of the SYN/ACK MUST NOT increase the size of the congestion window. Further, if the SYN or SYN/ACK is lost, the initial window used by a sender after a correctly transmitted SYN MUST be one segment consisting of at most SMSS bytes.",
      "ja": "[RFC3390]で指定されるように、SYN / ACKおよびSYN / ACKの肯定応答は、輻輳ウィンドウのサイズを大きくしてはいけません。 SYNまたはSYN / ACKが失われた場合、さらに、正しく送信されたSYN後に送信者によって使用される初期画面が最もSMSSバイトで成る一つのセグメントでなければなりません。"
    },
    {
      "indent": 3,
      "text": "A detailed rationale and discussion of the IW setting is provided in [RFC3390].",
      "ja": "IW設定の詳細な理論的根拠と議論は[RFC3390]に提供されます。"
    },
    {
      "indent": 3,
      "text": "When initial congestion windows of more than one segment are implemented along with Path MTU Discovery [RFC1191], and the MSS being used is found to be too large, the congestion window cwnd SHOULD be reduced to prevent large bursts of smaller segments. Specifically, cwnd SHOULD be reduced by the ratio of the old segment size to the new segment size.",
      "ja": "複数のセグメントの最初の輻輳ウィンドウがパスMTU探索[RFC1191]、およびMSSを使用して一緒に実装されたときには大きすぎることが見出され、輻輳ウィンドウCWNDは、小さなセグメントの大バーストを防ぐために、低減されるべきです。具体的には、CWNDは、新しいセグメントサイズに古いセグメントサイズの比によって低減されるべきです。"
    },
    {
      "indent": 3,
      "text": "The initial value of ssthresh SHOULD be set arbitrarily high (e.g., to the size of the largest possible advertised window), but ssthresh MUST be reduced in response to congestion. Setting ssthresh as high as possible allows the network conditions, rather than some arbitrary host limit, to dictate the sending rate. In cases where the end systems have a solid understanding of the network path, more carefully setting the initial ssthresh value may have merit (e.g., such that the end host does not create congestion along the path).",
      "ja": "SSTHRESHの初期値は、（可能な最大広告ウィンドウのサイズに、例えば）任意に高く設定する必要がありますが、SSTHRESH輻輳に応答して減少させなければなりません。できるだけ高くSSTHRESHを設定すると、送信レートを決定するために、むしろ、いくつかの任意のホストの制限よりも、ネットワークの状態を可能にします。エンドシステムは、ネットワーク経路の固体理解している場合には、より慎重に初期SSTHRESHの値を設定するメリットを有していてもよい（例えば、エンドホストは、経路に沿って混雑を作成しないこと）。"
    },
    {
      "indent": 3,
      "text": "The slow start algorithm is used when cwnd < ssthresh, while the congestion avoidance algorithm is used when cwnd > ssthresh. When cwnd and ssthresh are equal, the sender may use either slow start or congestion avoidance.",
      "ja": "SSTHRESH <輻輳回避アルゴリズムは場合CWND使用されている間SSTHRESH、>場合CWNDスロースタートアルゴリズムが使用されます。 CWNDおよびSSTHRESHが等しい場合、送信側はスロースタートや輻輳回避のいずれかを使用することができます。"
    },
    {
      "indent": 3,
      "text": "During slow start, a TCP increments cwnd by at most SMSS bytes for each ACK received that cumulatively acknowledges new data. Slow start ends when cwnd exceeds ssthresh (or, optionally, when it reaches it, as noted above) or when congestion is observed. While traditionally TCP implementations have increased cwnd by precisely SMSS bytes upon receipt of an ACK covering new data, we RECOMMEND that TCP implementations increase cwnd, per:",
      "ja": "スロースタート時には、各ACKのための最もSMSSバイトででcwndをTCP増分が累積的に新しいデータを認めることを受けました。スロースタートは、（上述のように、それは、それに到達したときに、必要に応じて、または、）CWNDがSSTHRESHを超えたときに終了するか、輻輳が観察された場合。伝統的なTCPの実装は、新しいデータをカバーするACKを受信すると、正確にSMSSバイトのcwndを増加しているが、我々は、TCP実装があたり、cwndのを増やすことをお勧めします。"
    },
    {
      "indent": 6,
      "text": "cwnd += min (N, SMSS) (2)",
      "ja": "CWND + =分（N、SMSS）（2）"
    },
    {
      "indent": 3,
      "text": "where N is the number of previously unacknowledged bytes acknowledged in the incoming ACK. This adjustment is part of Appropriate Byte Counting [RFC3465] and provides robustness against misbehaving receivers that may attempt to induce a sender to artificially inflate cwnd using a mechanism known as \"ACK Division\" [SCWA99]. ACK Division consists of a receiver sending multiple ACKs for a single TCP data segment, each acknowledging only a portion of its data. A TCP that increments cwnd by SMSS for each such ACK will inappropriately inflate the amount of data injected into the network.",
      "ja": "Nは、受信ACKに認め以前に未確認のバイト数です。この調整は、適切なバイトカウント[RFC3465]の一部であり、人為的に「ACK部門」[SCWA99]として知られているメカニズムを使用してCWND膨張させるために、送信者を誘導しようと試みることができる不正動作する受信機に対するロバスト性を提供します。 ACK部門は、それぞれが、そのデータの一部のみを認め、単一のTCPデータセグメントのための複数のACKを送信する受信機で構成されています。このような各ACKのためにSMSSによってCWNDを増分TCPは不適切ネットワークに注入されたデータの量を膨らませるであろう。"
    },
    {
      "indent": 3,
      "text": "During congestion avoidance, cwnd is incremented by roughly 1 full-sized segment per round-trip time (RTT). Congestion avoidance continues until congestion is detected. The basic guidelines for incrementing cwnd during congestion avoidance are:",
      "ja": "輻輳回避中、CWNDは、ラウンドトリップ時間（RTT）当たりおおよそ1フルサイズのセグメントだけインクリメントされます。輻輳が検出されるまで輻輳回避は継続します。輻輳回避中にcwndをインクリメントするための基本的なガイドラインは以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "* MAY increment cwnd by SMSS bytes",
      "ja": "* SMSSバイトでのcwndを増加してもよい（MAY）"
    },
    {
      "indent": 6,
      "text": "* SHOULD increment cwnd per equation (2) once per RTT",
      "ja": "* RTTごとに一度式（2）あたりのcwndをインクリメントすべきです"
    },
    {
      "indent": 6,
      "text": "* MUST NOT increment cwnd by more than SMSS bytes",
      "ja": "* SMSSバイト以上でのcwndを増加してはなりません"
    },
    {
      "indent": 3,
      "text": "We note that [RFC3465] allows for cwnd increases of more than SMSS bytes for incoming acknowledgments during slow start on an experimental basis; however, such behavior is not allowed as part of the standard.",
      "ja": "我々は、[RFC3465]は、実験に基づいて、スロースタート時の受信確認応答のためのよりSMSSバイトのCWNDが増加を可能にすることに注意してください。しかし、そのような行動は、規格の一部として許可されていません。"
    },
    {
      "indent": 3,
      "text": "The RECOMMENDED way to increase cwnd during congestion avoidance is to count the number of bytes that have been acknowledged by ACKs for new data. (A drawback of this implementation is that it requires maintaining an additional state variable.) When the number of bytes acknowledged reaches cwnd, then cwnd can be incremented by up to SMSS bytes. Note that during congestion avoidance, cwnd MUST NOT be increased by more than SMSS bytes per RTT. This method both allows TCPs to increase cwnd by one segment per RTT in the face of delayed ACKs and provides robustness against ACK Division attacks.",
      "ja": "輻輳回避中にcwndをを高めるために推奨される方法は、新しいデータに対するACKによって承認されたバイト数を数えることです。 （この実施の欠点は、追加の状態変数を維持する必要があることである。）を認めたバイトの数がCWNDに達すると、その後CWNDがSMSSバイトまでインクリメントすることができます。輻輳回避中に、cwndをSMSSはバイトあたりのRTTよりも増加してはならないことに注意してください。この方法は、遅延ACKの面にRTTごとにセグメントによりCWNDを高めるためのTCPを可能にし、ACK分割攻撃に対する耐性を提供し、両方。"
    },
    {
      "indent": 3,
      "text": "Another common formula that a TCP MAY use to update cwnd during congestion avoidance is given in equation (3):",
      "ja": "TCPは輻輳回避中にcwndを更新するために使用できる別の一般的な式は、式（3）で与えられます。"
    },
    {
      "indent": 6,
      "text": "cwnd += SMSS*SMSS/cwnd (3)",
      "ja": "CWND + = SMSSの*のSMSS / CWND（3）"
    },
    {
      "indent": 3,
      "text": "This adjustment is executed on every incoming ACK that acknowledges new data. Equation (3) provides an acceptable approximation to the underlying principle of increasing cwnd by 1 full-sized segment per RTT. (Note that for a connection in which the receiver is acknowledging every-other packet, (3) is less aggressive than allowed -- roughly increasing cwnd every second RTT.)",
      "ja": "この調整は、新しいデータを認識し、すべての着信ACK上で実行されます。式（3）はRTTごとに1フルサイズセグメントによってCWND増加の根底にある原理に許容される近似を提供します。 （受信機は、すべて、他のパケットを承認された接続用なお、（3）許容未満アグレッシブである - 概ね毎秒RTTをCWNDが増加します。）"
    },
    {
      "indent": 3,
      "text": "Implementation Note: Since integer arithmetic is usually used in TCP implementations, the formula given in equation (3) can fail to increase cwnd when the congestion window is larger than SMSS*SMSS. If the above formula yields 0, the result SHOULD be rounded up to 1 byte.",
      "ja": "実装注：整数演算は、通常、TCPの実装に使用されるので、式で与えられた式（3）は、輻輳ウィンドウはSMSS * SMSSより大きい場合にcwndを増加させるために失敗する可能性があります。上記式収量0の場合、結果は1バイトに切り上げされるべきです。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: Older implementations have an additional additive constant on the right-hand side of equation (3). This is incorrect and can actually lead to diminished performance [RFC2525].",
      "ja": "実装注：古い実装は、式（3）の右辺に追加の添加剤定数を有します。これは間違っていると、実際にパフォーマンスの低下[RFC2525]につながることができます。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: Some implementations maintain cwnd in units of bytes, while others in units of full-sized segments. The latter will find equation (3) difficult to use, and may prefer to use the counting approach discussed in the previous paragraph.",
      "ja": "実装注：いくつかの実装では、フルサイズのセグメントの単位で他ながら、バイト単位でCWNDを維持します。後者は、式（3）困難使用するでしょう、そして前の段落で説明した計数アプローチを使用することを好むかもしれません。"
    },
    {
      "indent": 3,
      "text": "When a TCP sender detects segment loss using the retransmission timer and the given segment has not yet been resent by way of the retransmission timer, the value of ssthresh MUST be set to no more than the value given in equation (4):",
      "ja": "TCP送信者がまだ再送タイマにより再送されていない再送タイマ及び所与のセグメントを使用してセグメントの損失を検出したとき、SSTHRESHの値は、式（4）で与えられた値以下に設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "ssthresh = max (FlightSize / 2, 2*SMSS) (4)",
      "ja": "SSTHRESH = MAX（FlightSize / 2、2 * SMSS）（4）"
    },
    {
      "indent": 3,
      "text": "where, as discussed above, FlightSize is the amount of outstanding data in the network.",
      "ja": "ここで、上述したように、FlightSizeは、ネットワーク内の未処理データの量です。"
    },
    {
      "indent": 3,
      "text": "On the other hand, when a TCP sender detects segment loss using the retransmission timer and the given segment has already been retransmitted by way of the retransmission timer at least once, the value of ssthresh is held constant.",
      "ja": "再送タイマ及び所与のセグメントを使用してTCP送信者検出セグメント損失は既に少なくとも一回の再送信タイマーによって再送信されてきた一方、SSTHRESHの値が一定に保持されます。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: An easy mistake to make is to simply use cwnd, rather than FlightSize, which in some implementations may incidentally increase well beyond rwnd.",
      "ja": "実装上の注意：簡単な間違い作るためには、単にいくつかの実装では偶然にもRWNDを超えて増加可能性がある、というよりもFlightSize、cwndのを使用することです。"
    },
    {
      "indent": 3,
      "text": "Furthermore, upon a timeout (as specified in [RFC2988]) cwnd MUST be set to no more than the loss window, LW, which equals 1 full-sized segment (regardless of the value of IW). Therefore, after retransmitting the dropped segment the TCP sender uses the slow start algorithm to increase the window from 1 full-sized segment to the new value of ssthresh, at which point congestion avoidance again takes over.",
      "ja": "また、CWND（[RFC2988]で指定されるように）、タイムアウト時（かかわらず、IWの値）1フルサイズのセグメントに等しい損失ウィンドウ、LW、超えないように設定しなければなりません。従って、ドロップされたセグメントを再送した後にTCP送信者は、ポイント輻輳回避が再び引き継ぐれるSSTHRESHの新しい値に1フルサイズセグメントからウィンドウを増加させるためにスロースタートアルゴリズムを使用します。"
    },
    {
      "indent": 3,
      "text": "As shown in [FF96] and [RFC3782], slow-start-based loss recovery after a timeout can cause spurious retransmissions that trigger duplicate acknowledgments. The reaction to the arrival of these duplicate ACKs in TCP implementations varies widely. This document does not specify how to treat such acknowledgments, but does note this as an area that may benefit from additional attention, experimentation and specification.",
      "ja": "[FF96]と[RFC3782]に示すように、タイムアウト後のスロースタート・ベースの損失回復は、重複確認応答を誘発するスプリアス再送を引き起こす可能性があります。 TCPの実装におけるこれらの重複ACKの到着に反応が大きく異なります。この文書では、このような確認応答を処理する方法を指定しませんが、追加の注意、実験や仕様から利益を得ることができる領域としてこれを注意しません。"
    },
    {
      "indent": 0,
      "text": "3.2. Fast Retransmit/Fast Recovery",
      "section_title": true,
      "ja": "3.2。高速再送/高速リカバリ"
    },
    {
      "indent": 3,
      "text": "A TCP receiver SHOULD send an immediate duplicate ACK when an out-of-order segment arrives. The purpose of this ACK is to inform the sender that a segment was received out-of-order and which sequence number is expected. From the sender's perspective, duplicate ACKs can be caused by a number of network problems. First, they can be caused by dropped segments. In this case, all segments after the dropped segment will trigger duplicate ACKs until the loss is repaired. Second, duplicate ACKs can be caused by the re-ordering of data segments by the network (not a rare event along some network paths [Pax97]). Finally, duplicate ACKs can be caused by replication of ACK or data segments by the network. In addition, a TCP receiver SHOULD send an immediate ACK when the incoming segment fills in all or part of a gap in the sequence space. This will generate more timely information for a sender recovering from a loss through a retransmission timeout, a fast retransmit, or an advanced loss recovery algorithm, as outlined in section 4.3.",
      "ja": "アウトオブオーダーセグメントが到着したときにTCP受信機は即座に重複ACKを送るべきです。このACKの目的は、セグメントは、アウト・オブ・オーダー受信及びシーケンス番号が期待された送信者に通知することです。送信者の視点から、重複ACKは、ネットワークの問題の数によって引き起こされる場合があります。まず、彼らはドロップセグメントによって引き起こされる場合があります。損失が修復されるまでこの場合、ドロップされたセグメントの後のすべてのセグメントは重複ACKをトリガします。第二に、重複ACKは、ネットワーク（一部のネットワークパス[Pax97]に沿っていない稀な事象）によるデータセグメントの再配列によって引き起こされ得ます。最後に、重複ACKは、ネットワークによってACK又はデータセグメントの複製によって引き起こされ得ます。着信セグメントは、配列空間中のギャップの全て又は一部を埋める場合に加えて、TCP受信機は、即時ACKを送信すべきです。これは、4.3節で概説したように、再送タイムアウト、高速再送、または高度な損失回復アルゴリズムによる損失から回復送信者のために、よりタイムリーな情報を生成します。"
    },
    {
      "indent": 3,
      "text": "The TCP sender SHOULD use the \"fast retransmit\" algorithm to detect and repair loss, based on incoming duplicate ACKs. The fast retransmit algorithm uses the arrival of 3 duplicate ACKs (as defined in section 2, without any intervening ACKs which move SND.UNA) as an indication that a segment has been lost. After receiving 3 duplicate ACKs, TCP performs a retransmission of what appears to be the missing segment, without waiting for the retransmission timer to expire.",
      "ja": "TCPの送信者は、着信重複ACKをもとに、「高速再送」を検出するアルゴリズムと修理損失を、使用すべきです。セグメントが失われたことを示すものとして（SND.UNAを移動介在のACKなしに、セクション2で定義されるように）高速再送アルゴリズムは3個の重複ACKの到着を使用します。 3つの重複ACKを受信した後、TCPが満了するの再送タイマーを待たずに、失われたセグメントと思われるものの再送信を行います。"
    },
    {
      "indent": 3,
      "text": "After the fast retransmit algorithm sends what appears to be the missing segment, the \"fast recovery\" algorithm governs the transmission of new data until a non-duplicate ACK arrives. The reason for not performing slow start is that the receipt of the duplicate ACKs not only indicates that a segment has been lost, but also that segments are most likely leaving the network (although a massive segment duplication by the network can invalidate this conclusion). In other words, since the receiver can only generate a duplicate ACK when a segment has arrived, that segment has left the network and is in the receiver's buffer, so we know it is no longer consuming network resources. Furthermore, since the ACK \"clock\" [Jac88] is preserved, the TCP sender can continue to transmit new segments (although transmission must continue using a reduced cwnd, since loss is an indication of congestion).",
      "ja": "高速再送アルゴリズムは失われたセグメントと思われるものを送信した後、非重複ACKが到着するまで、「高速回復」アルゴリズムは、新たなデータの伝送を管理します。スロースタートを行わない理由は、重複ACKの受信がセグメントが失われたことを示していないだけでなく、（ネットワークによる大規模なセグメントの重複がこの結論を無効にすることができるが）セグメントが最も可能性の高いネットワークを残していることです。セグメントが到着したとき、受信機が唯一の重複ACKを生成することができますので、言い換えれば、そのセグメントはネットワークを残しているし、受信側のバッファにあるので、我々は、それはもはやネットワークリソースを消費している知っていません。 ACK「クロック」[Jac88]保存されるので、TCP送信者は（損失が輻輳の指標であるので、送信が、低減CWNDを使用し続けなければならないが）新しいセグメントを送信し続けることができます。"
    },
    {
      "indent": 3,
      "text": "The fast retransmit and fast recovery algorithms are implemented together as follows.",
      "ja": "次のように高速再送と高速回復アルゴリズムが一緒に実装されています。"
    },
    {
      "indent": 3,
      "text": "1. On the first and second duplicate ACKs received at a sender, a TCP SHOULD send a segment of previously unsent data per [RFC3042] provided that the receiver's advertised window allows, the total FlightSize would remain less than or equal to cwnd plus 2*SMSS, and that new data is available for transmission. Further, the TCP sender MUST NOT change cwnd to reflect these two segments [RFC3042]. Note that a sender using SACK [RFC2018] MUST NOT send new data unless the incoming duplicate acknowledgment contains new SACK information.",
      "ja": "第一および第二の重複ACK 1.送信者で受信、TCPは[RFC3042]あたりの以前に未送信データのセグメントを送信すべきである受信機の広告ウィンドウができ、総FlightSizeはcwndをするために以下のままプラス2になることを条件とします* SMSS、その新しいデータが伝送のために利用可能です。さらに、TCPの送信者は、これらの二つのセグメント[RFC3042]を反映するためにcwndを変更してはなりません。入ってくる重複確認応答が新しいSACK情報が含まれていない限り、SACK [RFC2018]を使用して送信者が新しいデータを送ってはいけないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "2. When the third duplicate ACK is received, a TCP MUST set ssthresh to no more than the value given in equation (4). When [RFC3042] is in use, additional data sent in limited transmit MUST NOT be included in this calculation.",
      "ja": "第三の重複ACKが受信されると2は、TCPは、式（4）で与えられた値以下にSSTHRESHを設定しなければなりません。 [RFC3042]が使用されている場合、制限された送信で送信され、追加のデータは、この計算に含めてはいけません。"
    },
    {
      "indent": 3,
      "text": "3. The lost segment starting at SND.UNA MUST be retransmitted and cwnd set to ssthresh plus 3*SMSS. This artificially \"inflates\" the congestion window by the number of segments (three) that have left the network and which the receiver has buffered.",
      "ja": "3. SND.UNAから始まる失われたセグメントが再送信されなければならないとSSTHRESHプラス3 *のSMSSに設定CWND。これは、人工的に、受信機がバッファリングしているネットワークとを残しているセグメント（3）の数で輻輳ウィンドウを「膨張します」。"
    },
    {
      "indent": 3,
      "text": "4. For each additional duplicate ACK received (after the third), cwnd MUST be incremented by SMSS. This artificially inflates the congestion window in order to reflect the additional segment that has left the network.",
      "ja": "ACKは、（第3の後に）受信した各追加重複4.は、CWNDはSMSSだけ増分されなければなりません。これは人為的にネットワークから離脱した追加のセグメントを反映するために、輻輳ウィンドウを膨張させます。"
    },
    {
      "indent": 7,
      "text": "Note: [SCWA99] discusses a receiver-based attack whereby many\nbogus duplicate ACKs are sent to the data sender in order to\nartificially inflate cwnd and cause a higher than appropriate sending rate to be used.  A TCP MAY therefore limit the number of\ntimes cwnd is artificially inflated during loss recovery to the\nnumber of outstanding segments (or, an approximation thereof).",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Note: When an advanced loss recovery mechanism (such as outlined in section 4.3) is not in use, this increase in FlightSize can cause equation (4) to slightly inflate cwnd and ssthresh, as some of the segments between SND.UNA and SND.NXT are assumed to have left the network but are still reflected in FlightSize.",
      "ja": "注：高度損失回復機構（セクション4.3に概説のような）使用されていない場合、FlightSizeのこの増加は、式（4）若干SND.UNAとSNDとの間のセグメントの一部として、CWNDおよびSSTHRESHを膨張させることができます。 NXTは、ネットワークを残していると想定されているが、まだFlightSizeに反映されています。"
    },
    {
      "indent": 3,
      "text": "5. When previously unsent data is available and the new value of cwnd and the receiver's advertised window allow, a TCP SHOULD send 1*SMSS bytes of previously unsent data.",
      "ja": "以前に未送信のデータが利用可能であるとのcwndの新しい価値と受信機の広告ウィンドウが許可した場合5. TCPは、以前に未送信データの1つの*のSMSSバイトを送るべきです。"
    },
    {
      "indent": 3,
      "text": "6. When the next ACK arrives that acknowledges previously unacknowledged data, a TCP MUST set cwnd to ssthresh (the value set in step 2). This is termed \"deflating\" the window.",
      "ja": "次のACKがそれが以前に不承認のデータを承認到着する6、TCPは（ステップ2で設定した値）をSSTHRESHするCWNDを設定しなければなりません。これは、ウィンドウを「収縮」と呼ばれています。"
    },
    {
      "indent": 7,
      "text": "This ACK should be the acknowledgment elicited by the\nretransmission from step 3, one RTT after the retransmission\n(though it may arrive sooner in the presence of significant out-\nof-order delivery of data segments at the receiver).\nAdditionally, this ACK should acknowledge all the intermediate\nsegments sent between the lost segment and the receipt of the\nthird duplicate ACK, if none of these were lost.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: This algorithm is known to generally not recover efficiently from multiple losses in a single flight of packets [FF96]. Section 4.3 below addresses such cases.",
      "ja": "注：このアルゴリズムは、一般的に、パケット[FF96]の単一飛行中に複数の損失から効率的に回復しないことが知られています。アドレスこのような場合、以下のセクション4.3。"
    },
    {
      "indent": 0,
      "text": "4. Additional Considerations",
      "section_title": true,
      "ja": "4.その他の考慮事項"
    },
    {
      "indent": 0,
      "text": "4.1. Restarting Idle Connections",
      "section_title": true,
      "ja": "4.1。アイドル接続を再起動します"
    },
    {
      "indent": 3,
      "text": "A known problem with the TCP congestion control algorithms described above is that they allow a potentially inappropriate burst of traffic to be transmitted after TCP has been idle for a relatively long period of time. After an idle period, TCP cannot use the ACK clock to strobe new segments into the network, as all the ACKs have drained from the network. Therefore, as specified above, TCP can potentially send a cwnd-size line-rate burst into the network after an idle period. In addition, changing network conditions may have rendered TCP's notion of the available end-to-end network capacity between two endpoints, as estimated by cwnd, inaccurate during the course of a long idle period.",
      "ja": "上述したTCPの輻輳制御アルゴリズムの既知の問題は、それらがTCPが比較的長時間にわたってアイドルであった後にトラフィックの潜在的に不適切なバーストが送信されることを可能にすることです。アイドル期間の後、TCPは、すべてのACKがネットワークから流出したように、ネットワークに新しいセグメントをストローブするためにACKクロックを使用することはできません。したがって、上記指定されているように、TCPは、潜在的にCWNDサイズのラインレートがアイドル期間の後にネットワークにバーストを送信することができます。長いアイドル期間の経過中に不正確なのcwnd、によって推定として加えて、変化するネットワーク条件は、2つのエンドポイント間で利用可能なエンドツーエンドのネットワーク容量のTCPの概念をレンダリングしている可能性があります。"
    },
    {
      "indent": 3,
      "text": "[Jac88] recommends that a TCP use slow start to restart transmission after a relatively long idle period. Slow start serves to restart the ACK clock, just as it does at the beginning of a transfer. This mechanism has been widely deployed in the following manner. When TCP has not received a segment for more than one retransmission timeout, cwnd is reduced to the value of the restart window (RW) before transmission begins.",
      "ja": "[Jac88] TCPが比較的長いアイドル期間の後に送信を再開するためにスロースタートを使用することをお勧めします。スロースタートは、それが転送の開始時に同じよう、ACKクロックを再開するのに役立ちます。このメカニズムは広く、次のように展開されています。 TCPは複数の再送信タイムアウトのためのセグメントを受信して​​いない場合、CWNDは、送信が開始される前にリスタートウィンドウ（RW）の値まで低減されます。"
    },
    {
      "indent": 3,
      "text": "For the purposes of this standard, we define RW = min(IW,cwnd).",
      "ja": "この規格の目的のために、私たちはRW =分（IW、CWND）を定義します。"
    },
    {
      "indent": 3,
      "text": "Using the last time a segment was received to determine whether or not to decrease cwnd can fail to deflate cwnd in the common case of persistent HTTP connections [HTH98]. In this case, a Web server receives a request before transmitting data to the Web client. The reception of the request makes the test for an idle connection fail, and allows the TCP to begin transmission with a possibly inappropriately large cwnd.",
      "ja": "CWNDを減少させるか否かを判定するセグメントが受信された最後の時間を使用することにより、持続的なHTTP接続[HTH98]の一般的な場合にCWNDを収縮するために失敗する可能性があります。この場合、Webサーバーは、Webクライアントにデータを送信する前に要求を受信します。要求の受信が失敗アイドル接続のためのテストを行い、TCPはおそらく不適切に大きいCWNDで送信を開始することを可能にします。"
    },
    {
      "indent": 3,
      "text": "Therefore, a TCP SHOULD set cwnd to no more than RW before beginning transmission if the TCP has not sent data in an interval exceeding the retransmission timeout.",
      "ja": "したがって、TCPはTCPの再送タイムアウトを超える間隔でデータを送信していない場合は、送信を開始する前に、RWを超えないようにcwndを設定すべきです。"
    },
    {
      "indent": 0,
      "text": "4.2. Generating Acknowledgments",
      "section_title": true,
      "ja": "4.2。謝辞の生成"
    },
    {
      "indent": 3,
      "text": "The delayed ACK algorithm specified in [RFC1122] SHOULD be used by a TCP receiver. When using delayed ACKs, a TCP receiver MUST NOT excessively delay acknowledgments. Specifically, an ACK SHOULD be generated for at least every second full-sized segment, and MUST be generated within 500 ms of the arrival of the first unacknowledged packet.",
      "ja": "[RFC1122]で指定された遅延ACKアルゴリズムはTCP受信機によって使用されるべきです。遅延ACKを使用する場合は、TCP受信機は過度に確認応答を遅らせるてはなりません。具体的には、ACKは、少なくとも毎秒フルサイズのセグメントに対して生成されるべきであり、最初の未確認パケットの到着の500ミリ秒以内に生成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The requirement that an ACK \"SHOULD\" be generated for at least every second full-sized segment is listed in [RFC1122] in one place as a SHOULD and another as a MUST. Here we unambiguously state it is a SHOULD. We also emphasize that this is a SHOULD, meaning that an implementor should indeed only deviate from this requirement after careful consideration of the implications. See the discussion of \"Stretch ACK violation\" in [RFC2525] and the references therein for a discussion of the possible performance problems with generating ACKs less frequently than every second full-sized segment.",
      "ja": "ACK要求少なくとも毎秒フルサイズのセグメントがべきでなければならないので、別のように、1つの場所で、[RFC1122]に記載されているために発生すること「は、SHOULD」。ここでは明確にそれを明記してくださいです。また、実装者が実際に唯一の影響を慎重に検討した後、この要件から逸脱しなければならないことを意味し、これはSHOULDであることを強調します。 [RFC2525]の「ストレッチACK違反」の議論とそれほど頻繁毎秒フルサイズのセグメントよりACKを生成するとにより、パフォーマンスの問題の議論のために、その中の参考文献を参照。"
    },
    {
      "indent": 3,
      "text": "In some cases, the sender and receiver may not agree on what constitutes a full-sized segment. An implementation is deemed to comply with this requirement if it sends at least one acknowledgment every time it receives 2*RMSS bytes of new data from the sender, where RMSS is the Maximum Segment Size specified by the receiver to the sender (or the default value of 536 bytes, per [RFC1122], if the receiver does not specify an MSS option during connection establishment). The sender may be forced to use a segment size less than RMSS due to the maximum transmission unit (MTU), the path MTU discovery algorithm or other factors. For instance, consider the case when the receiver announces an RMSS of X bytes but the sender ends up using a segment size of Y bytes (Y < X) due to path MTU discovery (or the sender's MTU size). The receiver will generate stretch ACKs if it waits for 2*X bytes to arrive before an ACK is sent. Clearly this will take more than 2 segments of size Y bytes. Therefore, while a specific algorithm is not defined, it is desirable for receivers to attempt to prevent this situation, for example, by acknowledging at least every second segment, regardless of size. Finally, we repeat that an ACK MUST NOT be delayed for more than 500 ms waiting on a second full-sized segment to arrive.",
      "ja": "いくつかのケースでは、送信者と受信者は、フルサイズのセグメントを構成するものに一致しないことがあります。それはRMSSは、送信側に受信機によって指定された最大セグメントサイズ（またはデフォルト値である送信者からの新しいデータの2つの* RMSSバイトを受信するたびに少なくとも一つの肯定応答を送信する場合、実装は、この要件を満たすと認められます受信機は、接続確立時MSSオプションが指定されていない場合は[RFC1122]あたり536バイト）の。送信者による最大伝送単位（MTU）、パスMTU発見アルゴリズムまたは他の要因に以下RMSSよりセグメントサイズを使用するように強制されてもよいです。受信機はRMSS Xのバイトを発表が、送信者が起因パスMTUディスカバリ（又は送信者のMTUサイズ）にYバイト（Y <X）のセグメントサイズを使用してしまう場合、例えば、ケースを考えます。それは2を待つ場合、受信機は、ACKが送信される前に到達するXバイト*ストレッチACKを生成します。これは明らかにサイズYバイトの2つの以上のセグメントを取るであろう。特定のアルゴリズムが定義されていないながら、受信機はサイズに関係なく、少なくとも毎秒セグメントを認めることによって、例えば、このような状況を防止しようとするため、それが望ましいです。最後に、私たちは、ACKが到着する2番目の、フルサイズのセグメントで待機している500以上のミリ秒遅らせてはならないことを繰り返します。"
    },
    {
      "indent": 3,
      "text": "Out-of-order data segments SHOULD be acknowledged immediately, in order to accelerate loss recovery. To trigger the fast retransmit algorithm, the receiver SHOULD send an immediate duplicate ACK when it receives a data segment above a gap in the sequence space. To provide feedback to senders recovering from losses, the receiver SHOULD send an immediate ACK when it receives a data segment that fills in all or part of a gap in the sequence space.",
      "ja": "アウトオブオーダデータセグメントが損失回復を促進するために、すぐに承認されるべきです。それは、配列空間中のギャップ上のデータセグメントを受信したときに高速再送アルゴリズムをトリガするために、受信機は、即時重複ACKを送信すべきです。それは、配列空間中のギャップの全て又は一部を埋めるデータセグメントを受信したときの損失から回復送信者にフィードバックを提供するために、受信機は、即時ACKを送信すべきです。"
    },
    {
      "indent": 3,
      "text": "A TCP receiver MUST NOT generate more than one ACK for every incoming segment, other than to update the offered window as the receiving application consumes new data (see [RFC813] and page 42 of [RFC793]).",
      "ja": "受信側アプリケーションが新しいデータを消費するように提供されるウィンドウを更新するよりも、TCP受信機は、他のすべての受信セグメントに複数のACKを生成してはいけません（[RFC813]参照[RFC793]の42ページ）。"
    },
    {
      "indent": 0,
      "text": "4.3. Loss Recovery Mechanisms",
      "section_title": true,
      "ja": "4.3。損失回復のメカニズム"
    },
    {
      "indent": 3,
      "text": "A number of loss recovery algorithms that augment fast retransmit and fast recovery have been suggested by TCP researchers and specified in the RFC series. While some of these algorithms are based on the TCP selective acknowledgment (SACK) option [RFC2018], such as [FF96], [MM96a], [MM96b], and [RFC3517], others do not require SACKs, such as [Hoe96], [FF96], and [RFC3782]. The non-SACK algorithms use \"partial acknowledgments\" (ACKs that cover previously unacknowledged data, but not all the data outstanding when loss was detected) to trigger retransmissions. While this document does not standardize any of the specific algorithms that may improve fast retransmit/fast recovery, these enhanced algorithms are implicitly allowed, as long as they follow the general principles of the basic four algorithms outlined above.",
      "ja": "高速再送と高速リカバリを強化損失回復アルゴリズムの数は、TCPの研究者によって提案とRFCシリーズで指定されています。これらのアルゴリズムのいくつかは、このような[FF96]、[MM96a]、[MM96b]、および[RFC3517]のようにTCP選択的確認応答（SACK）オプション[RFC2018]に基づいているが、他の人は、このような[Hoe96]として袋を、必要としません[FF96]、および[RFC3782]。非SACKアルゴリズムは、再送信をトリガするために「部分的確認応答」（以前に認められていないデータをカバーするのACKはなく、損失が検出されたときに未処理のすべてのデータ）を使用します。この文書は高速再送/高速回復を改善することがあり、特定のアルゴリズムのいずれかを標準化していませんが、これらの強化されたアルゴリズムは、暗黙のうちに、彼らは上記で概説した基本的な4つのアルゴリズムの一般的な原則に従っている限り、許可されています。"
    },
    {
      "indent": 3,
      "text": "That is, when the first loss in a window of data is detected, ssthresh MUST be set to no more than the value given by equation (4). Second, until all lost segments in the window of data in question are repaired, the number of segments transmitted in each RTT MUST be no more than half the number of outstanding segments when the loss was detected. Finally, after all loss in the given window of segments has been successfully retransmitted, cwnd MUST be set to no more than ssthresh and congestion avoidance MUST be used to further increase cwnd. Loss in two successive windows of data, or the loss of a retransmission, should be taken as two indications of congestion and, therefore, cwnd (and ssthresh) MUST be lowered twice in this case.",
      "ja": "データのウィンドウ内の最初の損失が検出された場合には、SSTHRESHは、式（4）で与えられる値を超えないように設定する必要があります。第二に、問題のデータのウィンドウ内のすべての失われたセグメントが修復されるまで、各RTTで送信セグメントの数は、損失が検出された優れたセグメントの半分以下の数でなければなりません。セグメントの所定のウィンドウ内のすべての損失が正常に再送信された後、最後に、CWNDはさらにCWNDを増加させるために使用されなければならないSSTHRESHと輻輳回避を超えないように設定しなければなりません。二つの連続するデータのウィンドウ、または再送の損失の損失は、従って、CWND（およびSSTHRESH）は、この場合には二回低下するなければならない2つの輻輳の指標と、のように解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "We RECOMMEND that TCP implementors employ some form of advanced loss recovery that can cope with multiple losses in a window of data. The algorithms detailed in [RFC3782] and [RFC3517] conform to the general principles outlined above. We note that while these are not the only two algorithms that conform to the above general principles these two algorithms have been vetted by the community and are currently on the Standards Track.",
      "ja": "私たちは、TCPの実装は、データのウィンドウに複数の損失に対応できる高度な損失回復のいくつかのフォームを採用することをお勧めします。 [RFC3782]及び[RFC3517]に詳述されたアルゴリズムは、上記で概説した一般原則に従います。我々は、これらは、これら2つのアルゴリズムは、コミュニティによって吟味し、標準化過程の上に現在されている上記の一般原則に準拠して唯一の2つのアルゴリズムではありませんしながら、ということに注意してください。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This document requires a TCP to diminish its sending rate in the presence of retransmission timeouts and the arrival of duplicate acknowledgments. An attacker can therefore impair the performance of a TCP connection by either causing data packets or their acknowledgments to be lost, or by forging excessive duplicate acknowledgments.",
      "ja": "この文書では、再送タイムアウトの存在と重複確認応答の到着にその送信レートを減少させるためにTCPが必要です。攻撃者はこのため失われた、または過度の重複確認応答を鍛造するためにどちらかの原因となったデータ・パケットまたはその確認応答により、TCPコネクションの性能を損なうことができます。"
    },
    {
      "indent": 3,
      "text": "In response to the ACK division attack outlined in [SCWA99], this document RECOMMENDS increasing the congestion window based on the number of bytes newly acknowledged in each arriving ACK rather than by a particular constant on each arriving ACK (as outlined in section 3.1).",
      "ja": "【SCWA99]に概説ACK分割攻撃に応答して、この文書は、新たにそれぞれ到着ACK（セクション3.1に概説されるように）上の特定の定数によって各到着ACKに認めなくバイト数に基づいて輻輳ウィンドウを増加させることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The Internet, to a considerable degree, relies on the correct implementation of these algorithms in order to preserve network stability and avoid congestion collapse. An attacker could cause TCP endpoints to respond more aggressively in the face of congestion by forging excessive duplicate acknowledgments or excessive acknowledgments for new data. Conceivably, such an attack could drive a portion of the network into congestion collapse.",
      "ja": "インターネットは、かなりの程度まで、ネットワークの安定性を維持し、輻輳崩壊を避けるために、これらのアルゴリズムの正しい実装に依存しています。攻撃者は、TCPエンドポイントは、新しいデータのための過度の重複確認応答や過度の承認を鍛造することで輻輳の顔に、より積極的に対応する可能性があります。おそらく、このような攻撃は、輻輳崩壊にネットワークの一部を運転できます。"
    },
    {
      "indent": 1,
      "text": "6. Changes between and",
      "section_title": true,
      "ja": "間6.変更"
    },
    {
      "indent": 3,
      "text": "[RFC2001] was extensively rewritten editorially and it is not feasible to itemize the list of changes between [RFC2001] and [RFC2581]. The intention of [RFC2581] was to not change any of the recommendations given in [RFC2001], but to further clarify cases that were not discussed in detail in [RFC2001]. Specifically, [RFC2581] suggested what TCP connections should do after a relatively long idle period, as well as specified and clarified some of the issues pertaining to TCP ACK generation. Finally, the allowable upper bound for the initial congestion window was raised from one to two segments.",
      "ja": "[RFC2001]は広範囲に編集者書き直され、[RFC2001]と[RFC2581]の間で変更のリストを箇条書きにすることは不可能です。 [RFC2581]の意図は、[RFC2001]で与えられた勧告を変更しないことであったが、さらに、[RFC2001]で詳細に説明されなかったケースを明確にします。具体的には、[RFC2581]は指定された接続が同様に、比較的長いアイドル期間の後に何をすべきかを提案しTCPとTCP ACK生成に関連する問題のいくつかを明らかにしました。最後に、初期の輻輳ウィンドウの許容上限は二つのセグメントに1から上げました。"
    },
    {
      "indent": 1,
      "text": "7. Changes Relative to",
      "section_title": true,
      "ja": "への相対7.変更"
    },
    {
      "indent": 3,
      "text": "A specific definition for \"duplicate acknowledgment\" has been added, based on the definition used by BSD TCP.",
      "ja": "「重複確認応答」のための具体的な定義は、BSD TCPで使用される定義に基づいて、追加されました。"
    },
    {
      "indent": 3,
      "text": "The document now notes that what to do with duplicate ACKs after the retransmission timer has fired is future work and explicitly unspecified in this document.",
      "ja": "文書は今何再送タイマが発射した後に重複ACKを行うには、将来の仕事や、この文書で明示的に指定されていないことを指摘しています。"
    },
    {
      "indent": 3,
      "text": "The initial window requirements were changed to allow Larger Initial Windows as standardized in [RFC3390]. Additionally, the steps to take when an initial window is discovered to be too large due to Path MTU Discovery [RFC1191] are detailed.",
      "ja": "初期ウィンドウの要件は[RFC3390]で標準化などのより大きな初期のWindowsを許可するように変更されました。また、初期ウィンドウが原因パスMTUディスカバリには大きすぎることが発見されたときに実行する手順[RFC1191]は詳述されています。"
    },
    {
      "indent": 3,
      "text": "The recommended initial value for ssthresh has been changed to say that it SHOULD be arbitrarily high, where it was previously MAY. This is to provide additional guidance to implementors on the matter.",
      "ja": "SSTHRESHのための推奨される初期値は、それが以前にMAYたところ、任意に高くなければならないと言うように変更されました。これは、問題の実装者に追加的なガイダンスを提供することです。"
    },
    {
      "indent": 3,
      "text": "During slow start, the usage of Appropriate Byte Counting [RFC3465] with L=1*SMSS is explicitly recommended. The method of increasing cwnd given in [RFC2581] is still explicitly allowed. Byte counting during congestion avoidance is also recommended, while the method from [RFC2581] and other safe methods are still allowed.",
      "ja": "スロースタート時には、L = 1 * SMSSを持つ適切なバイトカウント[RFC3465]の使用を明示的に推奨されます。 [RFC2581]で与えられたのcwndを増加させる方法は、まだ明示的に許可されています。 [RFC2581]の方法および他の安全な方法が依然として許容しながら、輻輳回避中バイトカウントもまた、推奨されます。"
    },
    {
      "indent": 3,
      "text": "The treatment of ssthresh on retransmission timeout was clarified. In particular, ssthresh must be set to half the FlightSize on the first retransmission of a given segment and then is held constant on subsequent retransmissions of the same segment.",
      "ja": "再送タイムアウトのSSTHRESHの治療を明らかにしました。特に、SSTHRESHは、所与のセグメントの最初の再送でFlightSize半分に設定されなければならないし、同じセグメントの後続の再送信に一定に保持されます。"
    },
    {
      "indent": 3,
      "text": "The description of fast retransmit and fast recovery has been clarified, and the use of Limited Transmit [RFC3042] is now recommended.",
      "ja": "高速再送と高速リカバリの説明は明らかにされており、限定送信[RFC3042]の使用が今お勧めします。"
    },
    {
      "indent": 3,
      "text": "TCPs now MAY limit the number of duplicate ACKs that artificially inflate cwnd during loss recovery to the number of segments outstanding to avoid the duplicate ACK spoofing attack described in [SCWA99].",
      "ja": "TCPは今、人為的に[SCWA99]で説明の重複ACKスプーフィング攻撃を避けるために優れたセグメントの数に対する損失回復の間にcwndを膨らませるの重複ACKの数を制限することがあります。"
    },
    {
      "indent": 3,
      "text": "The restart window has been changed to min(IW,cwnd) from IW. This behavior was described as \"experimental\" in [RFC2581].",
      "ja": "再起動ウィンドウがIWから（IW、CWND）をminに変更されました。この動作は、[RFC2581]に「実験的」と説明しました。"
    },
    {
      "indent": 3,
      "text": "It is now recommended that TCP implementors implement an advanced loss recovery algorithm conforming to the principles outlined in this document.",
      "ja": "現在では、TCPの実装者は、本文書に概説原則に準拠した先進的な損失回復アルゴリズムを実装することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The security considerations have been updated to discuss ACK division and recommend byte counting as a counter to this attack.",
      "ja": "セキュリティの考慮事項は、ACK部門を議論し、この攻撃へのカウンターとしてバイトカウントを推奨するように更新されました。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgments",
      "section_title": true,
      "ja": "8.謝辞"
    },
    {
      "indent": 3,
      "text": "The core algorithms we describe were developed by Van Jacobson [Jac88, Jac90]. In addition, Limited Transmit [RFC3042] was developed in conjunction with Hari Balakrishnan and Sally Floyd. The initial congestion window size specified in this document is a result of work with Sally Floyd and Craig Partridge [RFC2414, RFC3390].",
      "ja": "我々は説明コアアルゴリズムはヴァンヤコブソン[Jac88、Jac90]によって開発されました。加えて、限定送信[RFC3042]はハリ・バラクリシュナンとサリーフロイドに関連して開発されました。この文書で指定された初期輻輳ウィンドウサイズは、サリーフロイドとクレイグ・パートリッジ[RFC2414、RFC3390]との作業の結果です。"
    },
    {
      "indent": 3,
      "text": "W. Richard (\"Rich\") Stevens wrote the first version of this document [RFC2001] and co-authored the second version [RFC2581]. This present version much benefits from his clarity and thoughtfulness of description, and we are grateful for Rich's contributions in elucidating TCP congestion control, as well as in more broadly helping us understand numerous issues relating to networking.",
      "ja": "W.リチャード（「リッチ」）は、スティーブンスは、このドキュメント[RFC2001]と共著第二版[RFC2581]の最初のバージョンを書きました。この現在のバージョンの説明の彼の明快さと心遣いから多くの恩恵を、私たちはTCPの輻輳制御を解明中だけでなく、より広く、私たちは、ネットワークに関連する数多くの問題を理解するうえでリッチの貢献に感謝しています。"
    },
    {
      "indent": 3,
      "text": "We wish to emphasize that the shortcomings and mistakes of this document are solely the responsibility of the current authors.",
      "ja": "私たちは、この文書の欠点や過ちは、単に現在の著者の責任であることを強調したいです。"
    },
    {
      "indent": 3,
      "text": "Some of the text from this document is taken from \"TCP/IP Illustrated, Volume 1: The Protocols\" by W. Richard Stevens (Addison-Wesley, 1994) and \"TCP/IP Illustrated, Volume 2: The Implementation\" by Gary R. Wright and W. Richard Stevens (Addison-Wesley, 1995). This material is used with the permission of Addison-Wesley.",
      "ja": "W.リチャードスティーヴンス（アジソン・ウェズリー、1994）によると：ゲイリーRによる「TCP / IPイラスト、2巻実装」：このドキュメントからテキストの一部は、「プロトコルTCP / IPイラスト、第1巻」から取られます。ライトとW.リチャードスティーヴンス（アジソン・ウェズリー、1995）。この材料は、アディソン・ウェスリーの許可を得て使用されます。"
    },
    {
      "indent": 3,
      "text": "Anil Agarwal, Steve Arden, Neal Cardwell, Noritoshi Demizu, Gorry Fairhurst, Kevin Fall, John Heffner, Alfred Hoenes, Sally Floyd, Reiner Ludwig, Matt Mathis, Craig Partridge, and Joe Touch contributed a number of helpful suggestions.",
      "ja": "アニルAgarwal氏、スティーブ・アーデン、ニールカードウェル、典俊Demizu、Gorry Fairhurst、ケビン秋、ジョンHeffner、アルフレッドHoenes、サリー・フロイド、ライナールートヴィヒ、マット・マシス、クレイグ・パートリッジ、そしてジョー・タッチは、役立つ情報の数を貢献しました。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122]ブレーデン、R.、エド、 \"インターネットホストのための要件 - 通信層\"。、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, November 1990.",
      "ja": "[RFC1191]ムガール人、J.とS.デアリング、 \"パスMTUディスカバリ\"、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[CJ89] Chiu, D. and R. Jain, \"Analysis of the Increase/Decrease Algorithms for Congestion Avoidance in Computer Networks\", Journal of Computer Networks and ISDN Systems, vol. 17, no. 1, pp. 1-14, June 1989.",
      "ja": "[CJ89]チウ、D.とR.ジャイナ教、「コンピュータネットワークにおける輻輳回避のための増加/減少アルゴリズムの分析」、コンピュータネットワークやISDNシステムズ誌vol。 17、ありません。 1頁1-14、1989年6月。"
    },
    {
      "indent": 3,
      "text": "[FF96] Fall, K. and S. Floyd, \"Simulation-based Comparisons of Tahoe, Reno and SACK TCP\", Computer Communication Review, July 1996, ftp://ftp.ee.lbl.gov/papers/sacks.ps.Z.",
      "ja": "[FF96]秋、K.およびS.フロイド、コンピュータコミュニケーションレビュー、1996年7月、ftp://ftp.ee.lbl.gov/papers/sacks.ps「タホ、リノとSACK TCPのシミュレーションベースの比較」 .Z。"
    },
    {
      "indent": 3,
      "text": "[Hoe96] Hoe, J., \"Improving the Start-up Behavior of a Congestion Control Scheme for TCP\", In ACM SIGCOMM, August 1996.",
      "ja": "[Hoe96]鍬、J.、ACM SIGCOMM、1996年8月には、「TCP輻輳制御方式のスタート・アップ挙動を改善」。"
    },
    {
      "indent": 3,
      "text": "[HTH98] Hughes, A., Touch, J., and J. Heidemann, \"Issues in TCP Slow-Start Restart After Idle\", Work in Progress, March 1998.",
      "ja": "[HTH98]ヒューズ、A.、タッチ、J.、およびJ. Heidemann、 \"アイドルの後にTCPスロースタートの再起動での問題\"、進歩、1998年3月での作業。"
    },
    {
      "indent": 3,
      "text": "[Jac88] Jacobson, V., \"Congestion Avoidance and Control\", Computer Communication Review, vol. 18, no. 4, pp. 314-329, Aug. 1988. ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z.",
      "ja": "[Jac88]ジェーコブソン、V.、「輻輳回避とコントロール」、コンピュータコミュニケーションレビュー、巻。 18、ありません。 4、頁314から329 8月1988 ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z。"
    },
    {
      "indent": 3,
      "text": "[Jac90] Jacobson, V., \"Modified TCP Congestion Avoidance Algorithm\", end2end-interest mailing list, April 30, 1990. ftp://ftp.isi.edu/end2end/end2end-interest-1990.mail.",
      "ja": "[Jac90]ジェーコブソン、V.、 \"修飾TCPの輻輳回避アルゴリズム\"、end2end金利メーリングリスト、4月30日、1990年ftp://ftp.isi.edu/end2end/end2end-interest-1990.mail。"
    },
    {
      "indent": 3,
      "text": "[MM96a] Mathis, M. and J. Mahdavi, \"Forward Acknowledgment: Refining TCP Congestion Control\", Proceedings of SIGCOMM'96, August, 1996, Stanford, CA. Available from http://www.psc.edu/networking/papers/papers.html",
      "ja": "[MM96a]マシス、M.とJ. Mahdavi、 \"フォワード謝辞：精錬TCP輻輳制御\"、SIGCOMM'96、8月、1996年、スタンフォード大学、カリフォルニアの議事録http://www.psc.edu/networking/papers/papers.htmlから入手可能"
    },
    {
      "indent": 3,
      "text": "[MM96b] Mathis, M. and J. Mahdavi, \"TCP Rate-Halving with Bounding Parameters\", Technical report. Available from http://www.psc.edu/networking/papers/FACKnotes/current.",
      "ja": "[MM96b]マシス、M.とJ. Mahdavi、 \"バウンディングパラメータを指定したTCPレート-半減\"、技術報告書。 http://www.psc.edu/networking/papers/FACKnotes/currentから入手できます。"
    },
    {
      "indent": 3,
      "text": "[Pax97] Paxson, V., \"End-to-End Internet Packet Dynamics\", Proceedings of SIGCOMM '97, Cannes, France, Sep. 1997.",
      "ja": "[Pax97]パクソン、V.、「エンドツーエンドのインターネットパケットダイナミクス」、SIGCOMM '97の議事録、カンヌ、フランス、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC813] Clark, D., \"Window and Acknowledgement Strategy in TCP\", RFC 813, July 1982.",
      "ja": "[RFC813]クラーク、D.、 \"TCPでウィンドウと謝辞戦略\"、RFC 813、1982年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC2001] Stevens, W., \"TCP Slow Start, Congestion Avoidance, Fast Retransmit, and Fast Recovery Algorithms\", RFC 2001, January 1997.",
      "ja": "[RFC2001]スティーブンス、W.、 \"TCPスロースタート、輻輳回避、高速再送、および高速リカバリアルゴリズム\"、RFC 2001、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, October 1996.",
      "ja": "[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 \"TCPの選択確認応答オプション\"、RFC 2018、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2414] Allman, M., Floyd, S., and C. Partridge, \"Increasing TCP's Initial Window\", RFC 2414, September 1998.",
      "ja": "[RFC2414]オールマン、M.、フロイド、S.、およびC.ヤマウズラ、 \"増加するTCPの初期ウィンドウ\"、RFC 2414、1998年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2525] Paxson, V., Allman, M., Dawson, S., Fenner, W., Griner, J., Heavens, I., Lahey, K., Semke, J., and B. Volz, \"Known TCP Implementation Problems\", RFC 2525, March 1999.",
      "ja": "[RFC2525]パクソン、V.、オールマン、M.、ドーソン、S.、フェナー、W.、Griner、J.、天、I.、レイヒー、K.、Semke、J.、およびB.フォルツ、「既知TCPの実装の問題」、RFC 2525、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2581] Allman, M., Paxson, V., and W. Stevens, \"TCP Congestion Control\", RFC 2581, April 1999.",
      "ja": "[RFC2581]オールマン、M.、パクソン、V.、およびW.スティーブンス、 \"TCP輻輳制御\"、RFC 2581、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, \"An Extension to the Selective Acknowledgement (SACK) Option for TCP\", RFC 2883, July 2000.",
      "ja": "[RFC2883]フロイド、S.、Mahdavi、J.、マティス、M.、およびM.ポドルスキー、RFC 2883、2000年7月 \"TCPのための選択的確認応答（SACK）オプションの拡張\"。"
    },
    {
      "indent": 3,
      "text": "[RFC2988] Paxson, V. and M. Allman, \"Computing TCP's Retransmission Timer\", RFC 2988, November 2000.",
      "ja": "[RFC2988]パクソン、V.とM.オールマン、 \"コンピューティングTCPの再送信タイマー\"、RFC 2988、2000年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3042] Allman, M., Balakrishnan, H., and S. Floyd, \"Enhancing TCP's Loss Recovery Using Limited Transmit\", RFC 3042, January 2001.",
      "ja": "[RFC3042]オールマン、M.、バラクリシュナン、H.、およびS.フロイド、 \"株式会社トランスミットを使用したTCPの損失回復の強化\"、RFC 3042、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, September 2001.",
      "ja": "\"IPに明示的輻輳通知の添加（ECN）\" [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3390] Allman, M., Floyd, S., and C. Partridge, \"Increasing TCP's Initial Window\", RFC 3390, October 2002.",
      "ja": "[RFC3390]オールマン、M.、フロイド、S.、およびC.ヤマウズラ、 \"増加するTCPの初期ウィンドウ\"、RFC 3390、2002年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC3465] Allman, M., \"TCP Congestion Control with Appropriate Byte Counting (ABC)\", RFC 3465, February 2003.",
      "ja": "[RFC3465]オールマン、M.、RFC 3465、2003年2月 \"適切なバイトカウント（ABC）とTCP輻輳制御\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3517] Blanton, E., Allman, M., Fall, K., and L. Wang, \"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP\", RFC 3517, April 2003.",
      "ja": "[RFC3517]ブラントン、E.、オールマン、M.、秋、K.、およびL.王は、 \"保守的な選択的確認応答（SACK）はTCPのために損失回復アルゴリズムをベース\"、RFC 3517、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3782] Floyd, S., Henderson, T., and A. Gurtov, \"The NewReno Modification to TCP's Fast Recovery Algorithm\", RFC 3782, April 2004.",
      "ja": "[RFC3782]フロイド、S.、ヘンダーソン、T.、およびA. Gurtov、RFC 3782、2004年4月 \"TCPの高速回復アルゴリズムにNewRenoの変更\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, March 2007.",
      "ja": "[RFC4821]マシス、M.とJ. Heffner、 \"パケット化レイヤのパスMTUディスカバリ\"、RFC 4821、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[SCWA99] Savage, S., Cardwell, N., Wetherall, D., and T. Anderson, \"TCP Congestion Control With a Misbehaving Receiver\", ACM Computer Communication Review, 29(5), October 1999.",
      "ja": "[SCWA99]サベージ、S.、カードウェル、N.、Wetherall、D.、およびT.アンダーソン、 \"ふらちな受信機をTCPの輻輳制御\"、ACMコンピュータコミュニケーションレビュー、29（5）、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[Ste94] Stevens, W., \"TCP/IP Illustrated, Volume 1: The Protocols\", Addison-Wesley, 1994.",
      "ja": "[Ste94]スティーブンス、W.、 \"TCP / IPイラスト、第1巻：プロトコル\"、アディソン・ウェズリー、1994。"
    },
    {
      "indent": 3,
      "text": "[WS95] Wright, G. and W. Stevens, \"TCP/IP Illustrated, Volume 2: The Implementation\", Addison-Wesley, 1995.",
      "ja": "[WS95]ライト、G.とW.スティーブンス、 \"TCP / IPイラスト、2巻：インプリメンテーション\"、アディソン・ウェズリー、1995。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Mark Allman International Computer Science Institute (ICSI) 1947 Center Street Suite 600 Berkeley, CA 94704-1198 Phone: +1 440 235 1792 EMail: mallman@icir.org http://www.icir.org/mallman/",
      "ja": "マーク・オールマン国際コンピュータサイエンス研究所（ICSI）1947年センターストリートスイート600バークレー、CA 94704から1198電話：+1 440 235 1792 Eメール：mallman@icir.org http://www.icir.org/mallman/"
    },
    {
      "indent": 3,
      "text": "Vern Paxson International Computer Science Institute (ICSI) 1947 Center Street Suite 600 Berkeley, CA 94704-1198 Phone: +1 510/642-4274 x302 EMail: vern@icir.org http://www.icir.org/vern/",
      "ja": "バーン・パクソン国際コンピュータサイエンス研究所（ICSI）1947センターストリートスイート600バークレー、CA 94704から1198電話：+1 510/642から4274 X302メール：vern@icir.org http://www.icir.org/vern/"
    },
    {
      "indent": 3,
      "text": "Ethan Blanton Purdue University Computer Sciences 305 North University Street West Lafayette, IN 47907 EMail: eblanton@cs.purdue.edu http://www.cs.purdue.edu/homes/eblanton/",
      "ja": "イーサンブラントンパデュー大学コンピュータサイエンス305ノースユニバーシティストリートウェストラファイエット、47907メールに：eblanton@cs.purdue.edu http://www.cs.purdue.edu/homes/eblanton/"
    }
  ]
}