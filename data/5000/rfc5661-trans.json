{
  "title": {
    "text": "RFC 5661 - Network File System (NFS) Version 4 Minor Version 1 Protocol",
    "ja": "RFC 5661 - ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1つのプロトコル"
  },
  "number": 5661,
  "created_at": "2019-10-26 21:30:50.563219+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                   S. Shepler, Ed.\nRequest for Comments: 5661                               Storspeed, Inc.\nCategory: Standards Track                                 M. Eisler, Ed.\nISSN: 2070-1721                                           D. Noveck, Ed.\n                                                                  NetApp\n                                                            January 2010",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Network File System (NFS) Version 4 Minor Version 1 Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes the Network File System (NFS) version 4 minor version 1, including features retained from the base protocol (NFS version 4 minor version 0, which is specified in RFC 3530) and protocol extensions made subsequently. Major extensions introduced in NFS version 4 minor version 1 include Sessions, Directory Delegations, and parallel NFS (pNFS). NFS version 4 minor version 1 has no dependencies on NFS version 4 minor version 0, and it is considered a separate protocol. Thus, this document neither updates nor obsoletes RFC 3530. NFS minor version 1 is deemed superior to NFS minor version 0 with no loss of functionality, and its use is preferred over version 0. Both NFS minor versions 0 and 1 can be used simultaneously on the same network, between the same client and server.",
      "ja": "この文書は、その後行われ、プロトコルの拡張（RFC 3530で指定されているNFSバージョン4マイナーバージョン0）ネットワークファイルシステム（NFS）バージョン4ベースのプロトコルから保持機能を含むマイナーバージョン1を、記載されています。 NFSバージョン4マイナーバージョン1で導入された主要な拡張は、セッション、ディレクトリ委任、及びパラレルNFS（pNFSの）が挙げられます。 NFSバージョン4のマイナーバージョン1は、NFSバージョン4マイナーバージョン0との依存関係はありません、それは別のプロトコルであると考えられます。したがって、この文書の更新もRFC 3530 NFSマイナーバージョン1を時代遅れどちらが機能を失うことなくNFSマイナーバージョン0に対して優れたものとみなされ、その使用は両方ともNFSマイナーバージョン0と1が同時に使用することができるバージョン0よりも好ましいです同じクライアントとサーバの間で同一のネットワーク、。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5661.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc5661で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2010 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................9\n   1.1. The NFS Version 4 Minor Version 1 Protocol .................9\n   1.2. Requirements Language ......................................9\n   1.3. Scope of This Document .....................................9\n   1.4. NFSv4 Goals ...............................................10\n   1.5. NFSv4.1 Goals .............................................10\n   1.6. General Definitions .......................................11\n   1.7. Overview of NFSv4.1 Features ..............................13\n   1.8. Differences from NFSv4.0 ..................................17\n2. Core Infrastructure ............................................18\n   2.1. Introduction ..............................................18\n   2.2. RPC and XDR ...............................................19\n   2.3. COMPOUND and CB_COMPOUND ..................................22\n   2.4. Client Identifiers and Client Owners ......................23\n   2.5. Server Owners .............................................28\n   2.6. Security Service Negotiation ..............................29\n   2.7. Minor Versioning ..........................................34\n   2.8. Non-RPC-Based Security Services ...........................37\n   2.9. Transport Layers ..........................................37\n   2.10. Session ..................................................40\n3. Protocol Constants and Data Types ..............................86\n   3.1. Basic Constants ...........................................86\n   3.2. Basic Data Types ..........................................87\n   3.3. Structured Data Types .....................................89\n4. Filehandles ....................................................97\n   4.1. Obtaining the First Filehandle ............................98\n   4.2. Filehandle Types ..........................................99\n   4.3. One Method of Constructing a Volatile Filehandle .........101\n   4.4. Client Recovery from Filehandle Expiration ...............102\n5. File Attributes ...............................................103\n   5.1. REQUIRED Attributes ......................................104\n   5.2. RECOMMENDED Attributes ...................................104\n   5.3. Named Attributes .........................................105\n   5.4. Classification of Attributes .............................106\n   5.5. Set-Only and Get-Only Attributes .........................107\n   5.6. REQUIRED Attributes - List and Definition References .....107\n   5.7. RECOMMENDED Attributes - List and Definition References ..108\n   5.8. Attribute Definitions ....................................110\n   5.9. Interpreting owner and owner_group .......................119\n   5.10. Character Case Attributes ...............................121\n   5.11. Directory Notification Attributes .......................121\n   5.12. pNFS Attribute Definitions ..............................122\n   5.13. Retention Attributes ....................................123\n6. Access Control Attributes .....................................126\n   6.1. Goals ....................................................126\n   6.2. File Attributes Discussion ...............................128",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   6.3. Common Methods ...........................................144\n   6.4. Requirements .............................................147\n7. Single-Server Namespace .......................................153\n   7.1. Server Exports ...........................................153\n   7.2. Browsing Exports .........................................153\n   7.3. Server Pseudo File System ................................154\n   7.4. Multiple Roots ...........................................155\n   7.5. Filehandle Volatility ....................................155\n   7.6. Exported Root ............................................155\n   7.7. Mount Point Crossing .....................................156\n   7.8. Security Policy and Namespace Presentation ...............156\n8. State Management ..............................................157\n   8.1. Client and Session ID ....................................158\n   8.2. Stateid Definition .......................................158\n   8.3. Lease Renewal ............................................167\n   8.4. Crash Recovery ...........................................170\n   8.5. Server Revocation of Locks ...............................181\n   8.6. Short and Long Leases ....................................182\n   8.7. Clocks, Propagation Delay, and Calculating Lease\n        Expiration ...............................................182\n   8.8. Obsolete Locking Infrastructure from NFSv4.0 .............183\n9. File Locking and Share Reservations ...........................184\n   9.1. Opens and Byte-Range Locks ...............................184\n   9.2. Lock Ranges ..............................................188\n   9.3. Upgrading and Downgrading Locks ..........................188\n   9.4. Stateid Seqid Values and Byte-Range Locks ................189\n   9.5. Issues with Multiple Open-Owners .........................189\n   9.6. Blocking Locks ...........................................190\n   9.7. Share Reservations .......................................191\n   9.8. OPEN/CLOSE Operations ....................................192\n   9.9. Open Upgrade and Downgrade ...............................192\n   9.10. Parallel OPENs ..........................................193\n   9.11. Reclaim of Open and Byte-Range Locks ....................194\n10. Client-Side Caching ..........................................194\n   10.1. Performance Challenges for Client-Side Caching ..........195\n   10.2. Delegation and Callbacks ................................196\n   10.3. Data Caching ............................................200\n   10.4. Open Delegation .........................................205\n   10.5. Data Caching and Revocation .............................216\n   10.6. Attribute Caching .......................................218\n   10.7. Data and Metadata Caching and Memory Mapped Files .......220\n   10.8. Name and Directory Caching without Directory\n         Delegations .............................................222\n   10.9. Directory Delegations ...................................225\n11. Multi-Server Namespace .......................................228\n   11.1. Location Attributes .....................................228\n   11.2. File System Presence or Absence .........................229\n   11.3. Getting Attributes for an Absent File System ............230",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   11.4. Uses of Location Information ............................232\n   11.5. Location Entries and Server Identity ....................236\n   11.6. Additional Client-Side Considerations ...................237\n   11.7. Effecting File System Transitions .......................238\n   11.8. Effecting File System Referrals .........................251\n   11.9. The Attribute fs_locations ..............................258\n   11.10. The Attribute fs_locations_info ........................261\n   11.11. The Attribute fs_status ................................273\n12. Parallel NFS (pNFS) ..........................................277\n   12.1. Introduction ............................................277\n   12.2. pNFS Definitions ........................................278\n   12.3. pNFS Operations .........................................284\n   12.4. pNFS Attributes .........................................285\n   12.5. Layout Semantics ........................................285\n   12.6. pNFS Mechanics ..........................................300\n   12.7. Recovery ................................................302\n   12.8. Metadata and Storage Device Roles .......................307\n   12.9. Security Considerations for pNFS ........................307\n13. NFSv4.1 as a Storage Protocol in pNFS: the File Layout Type ..309\n   13.1. Client ID and Session Considerations ....................309\n   13.2. File Layout Definitions .................................312\n   13.3. File Layout Data Types ..................................312\n   13.4. Interpreting the File Layout ............................317\n   13.5. Data Server Multipathing ................................324\n   13.6. Operations Sent to NFSv4.1 Data Servers .................325\n   13.7. COMMIT through Metadata Server ..........................327\n   13.8. The Layout Iomode .......................................328\n   13.9. Metadata and Data Server State Coordination .............329\n   13.10. Data Server Component File Size ........................332\n   13.11. Layout Revocation and Fencing ..........................333\n   13.12. Security Considerations for the File Layout Type .......334\n14. Internationalization .........................................334\n  14.1.  Stringprep profile for the utf8str_cs type ..............336\n  14.2.  Stringprep profile for the utf8str_cis type .............337\n  14.3.  Stringprep profile for the utf8str_mixed type ...........338\n  14.4.  UTF-8 Capabilities ......................................340\n  14.5.  UTF-8 Related Errors ....................................340\n15. Error Values .................................................341\n   15.1. Error Definitions .......................................341\n   15.2. Operations and Their Valid Errors .......................361\n   15.3. Callback Operations and Their Valid Errors ..............376\n   15.4. Errors and the Operations That Use Them .................379\n16. NFSv4.1 Procedures ...........................................391\n   16.1. Procedure 0: NULL - No Operation ........................392\n   16.2. Procedure 1: COMPOUND - Compound Operations .............392\n17. Operations: REQUIRED, RECOMMENDED, or OPTIONAL ...............403\n18. NFSv4.1 Operations ...........................................407\n   18.1. Operation 3: ACCESS - Check Access Rights ...............407",
      "raw": true
    },
    {
      "indent": 6,
      "text": "18.2. Operation 4: CLOSE - Close File .........................413\n18.3. Operation 5: COMMIT - Commit Cached Data ................414\n18.4. Operation 6: CREATE - Create a Non-Regular File Object ..417\n18.5. Operation 7: DELEGPURGE - Purge Delegations\n      Awaiting Recovery .......................................419\n18.6. Operation 8: DELEGRETURN - Return Delegation ............420\n18.7. Operation 9: GETATTR - Get Attributes ...................421\n18.8. Operation 10: GETFH - Get Current Filehandle ............423\n18.9. Operation 11: LINK - Create Link to a File ..............424\n18.10. Operation 12: LOCK - Create Lock .......................426\n18.11. Operation 13: LOCKT - Test for Lock ....................430\n18.12. Operation 14: LOCKU - Unlock File ......................432\n18.13. Operation 15: LOOKUP - Lookup Filename .................433\n18.14. Operation 16: LOOKUPP - Lookup Parent Directory ........435\n18.15. Operation 17: NVERIFY - Verify Difference in\n       Attributes .............................................436\n18.16. Operation 18: OPEN - Open a Regular File ...............437\n18.17. Operation 19: OPENATTR - Open Named Attribute\n       Directory ..............................................458\n18.18. Operation 21: OPEN_DOWNGRADE - Reduce Open File\n       Access .................................................459\n18.19. Operation 22: PUTFH - Set Current Filehandle ...........461\n18.20. Operation 23: PUTPUBFH - Set Public Filehandle .........461\n18.21. Operation 24: PUTROOTFH - Set Root Filehandle ..........463\n18.22. Operation 25: READ - Read from File ....................464\n18.23. Operation 26: READDIR - Read Directory .................466\n18.24. Operation 27: READLINK - Read Symbolic Link ............469\n18.25. Operation 28: REMOVE - Remove File System Object .......470\n18.26. Operation 29: RENAME - Rename Directory Entry ..........473\n18.27. Operation 31: RESTOREFH - Restore Saved Filehandle .....477\n18.28. Operation 32: SAVEFH - Save Current Filehandle .........478\n18.29. Operation 33: SECINFO - Obtain Available Security ......479\n18.30. Operation 34: SETATTR - Set Attributes .................482\n18.31. Operation 37: VERIFY - Verify Same Attributes ..........485\n18.32. Operation 38: WRITE - Write to File ....................486\n18.33. Operation 40: BACKCHANNEL_CTL - Backchannel Control ....491\n18.34. Operation 41: BIND_CONN_TO_SESSION - Associate\n       Connection with Session ................................492\n18.35. Operation 42: EXCHANGE_ID - Instantiate Client ID ......495\n18.36. Operation 43: CREATE_SESSION - Create New\n       Session and Confirm Client ID ..........................513\n18.37. Operation 44: DESTROY_SESSION - Destroy a Session ......523\n18.38. Operation 45: FREE_STATEID - Free Stateid with\n       No Locks ...............................................525\n18.39. Operation 46: GET_DIR_DELEGATION - Get a\n       Directory Delegation ...................................526\n18.40. Operation 47: GETDEVICEINFO - Get Device Information ...530\n18.41. Operation 48: GETDEVICELIST - Get All Device",
      "raw": true
    },
    {
      "indent": 3,
      "text": "          Mappings for a File System .............................533\n   18.42. Operation 49: LAYOUTCOMMIT - Commit Writes Made\n          Using a Layout .........................................534\n   18.43. Operation 50: LAYOUTGET - Get Layout Information .......538\n   18.44. Operation 51: LAYOUTRETURN - Release Layout\n          Information ............................................547\n   18.45. Operation 52: SECINFO_NO_NAME - Get Security on\n          Unnamed Object .........................................552\n   18.46. Operation 53: SEQUENCE - Supply Per-Procedure\n          Sequencing and Control .................................553\n   18.47. Operation 54: SET_SSV - Update SSV for a Client ID .....559\n   18.48. Operation 55: TEST_STATEID - Test Stateids for\n          Validity ...............................................561\n   18.49. Operation 56: WANT_DELEGATION - Request Delegation .....563\n   18.50. Operation 57: DESTROY_CLIENTID - Destroy a Client ID ...566\n   18.51. Operation 58: RECLAIM_COMPLETE - Indicates\n          Reclaims Finished ......................................567\n   18.52. Operation 10044: ILLEGAL - Illegal Operation ...........569\n19. NFSv4.1 Callback Procedures ..................................570\n   19.1. Procedure 0: CB_NULL - No Operation .....................570\n   19.2. Procedure 1: CB_COMPOUND - Compound Operations ..........571\n20. NFSv4.1 Callback Operations ..................................574\n   20.1. Operation 3: CB_GETATTR - Get Attributes ................574\n   20.2. Operation 4: CB_RECALL - Recall a Delegation ............575\n   20.3. Operation 5: CB_LAYOUTRECALL - Recall Layout\n         from Client .............................................576\n   20.4. Operation 6: CB_NOTIFY - Notify Client of\n         Directory Changes .......................................580\n   20.5. Operation 7: CB_PUSH_DELEG - Offer Previously\n         Requested Delegation to Client ..........................583\n   20.6. Operation 8: CB_RECALL_ANY - Keep Any N\n         Recallable Objects ......................................584\n   20.7. Operation 9: CB_RECALLABLE_OBJ_AVAIL - Signal\n         Resources for Recallable Objects ........................588\n   20.8. Operation 10: CB_RECALL_SLOT - Change Flow\n         Control Limits ..........................................588\n   20.9. Operation 11: CB_SEQUENCE - Supply Backchannel\n         Sequencing and Control ..................................589\n   20.10. Operation 12: CB_WANTS_CANCELLED - Cancel\n          Pending Delegation Wants ...............................592\n   20.11. Operation 13: CB_NOTIFY_LOCK - Notify Client of\n          Possible Lock Availability .............................593\n   20.12. Operation 14: CB_NOTIFY_DEVICEID - Notify\n          Client of Device ID Changes ............................594\n   20.13. Operation 10044: CB_ILLEGAL - Illegal Callback\n          Operation ..............................................596\n21. Security Considerations ......................................597\n22. IANA Considerations ..........................................598",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   22.1. Named Attribute Definitions .............................598\n   22.2. Device ID Notifications .................................600\n   22.3. Object Recall Types .....................................601\n   22.4. Layout Types ............................................603\n   22.5. Path Variable Definitions ...............................606\n23. References ...................................................609\n   23.1. Normative References ....................................609\n   23.2. Informative References ..................................612\nAppendix A.  Acknowledgments  ....................................615",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. The NFS Version 4 Minor Version 1 Protocol",
      "section_title": true,
      "ja": "1.1.  NFSバージョン4のマイナーバージョン1プロトコル"
    },
    {
      "indent": 3,
      "text": "The NFS version 4 minor version 1 (NFSv4.1) protocol is the second minor version of the NFS version 4 (NFSv4) protocol. The first minor version, NFSv4.0, is described in [30]. It generally follows the guidelines for minor versioning that are listed in Section 10 of RFC 3530. However, it diverges from guidelines 11 (\"a client and server that support minor version X must support minor versions 0 through X-1\") and 12 (\"no new features may be introduced as mandatory in a minor version\"). These divergences are due to the introduction of the sessions model for managing non-idempotent operations and the RECLAIM_COMPLETE operation. These two new features are infrastructural in nature and simplify implementation of existing and other new features. Making them anything but REQUIRED would add undue complexity to protocol definition and implementation. NFSv4.1 accordingly updates the minor versioning guidelines (Section 2.7).",
      "ja": "NFSバージョン4マイナーバージョン1（NFSv4.1）プロトコルは、NFSバージョン4（NFSv4の）プロトコルの第二のマイナーバージョンです。最初のマイナーバージョン、NFSv4.0は、[30]に記載されています。これは、一般的にはガイドライン11（「X-1を通じてマイナーバージョン0をサポートしている必要がありますマイナーバージョンXをサポートするクライアントとサーバ」）及び12（から発散する、しかしRFC 3530のセクション10に記載されていマイナーバージョンのためのガイドラインに従っ）「何の新機能はマイナーバージョンで必須として導入することはできません」。これらの相違は、非冪等の操作を管理するためのセッションモデルの導入とRECLAIM_COMPLETE操作によるものです。これらの2つの新機能は、本質的にインフラであり、既存およびその他の新機能の実装を簡素化します。必要ですが、彼らに何かを作ることは、プロトコルの定義と実装への過度の複雑さを追加します。 NFSv4.1はそれに応じてマイナーバージョンのガイドライン（2.7節）を更新します。"
    },
    {
      "indent": 3,
      "text": "As a minor version, NFSv4.1 is consistent with the overall goals for NFSv4, but extends the protocol so as to better meet those goals, based on experiences with NFSv4.0. In addition, NFSv4.1 has adopted some additional goals, which motivate some of the major extensions in NFSv4.1.",
      "ja": "マイナーバージョンとして、NFSv4.1は、NFSv4のための全体的な目標と一致しているが、より良いNFSv4.0と経験に基づいてこれらの目標を満たすようにプロトコルを拡張します。また、NFSv4.1はNFSv4.1の主要な拡張の一部をやる気いくつかの追加の目標を、採用しています。"
    },
    {
      "indent": 0,
      "text": "1.2. Requirements Language",
      "section_title": true,
      "ja": "1.2. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [1].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119に記載されるように解釈される[1]。"
    },
    {
      "indent": 0,
      "text": "1.3. Scope of This Document",
      "section_title": true,
      "ja": "1.3. この文書の範囲"
    },
    {
      "indent": 3,
      "text": "This document describes the NFSv4.1 protocol. With respect to NFSv4.0, this document does not:",
      "ja": "この文書では、NFSv4.1プロトコルを記述します。 NFSv4.0に関しては、この文書はしていません。"
    },
    {
      "indent": 3,
      "text": "o describe the NFSv4.0 protocol, except where needed to contrast with NFSv4.1.",
      "ja": "O NFSv4.1と対比するために必要な場合を除き、NFSv4.0プロトコルを記述する。"
    },
    {
      "indent": 3,
      "text": "o modify the specification of the NFSv4.0 protocol.",
      "ja": "O NFSv4.0プロトコルの仕様を変更します。"
    },
    {
      "indent": 3,
      "text": "o clarify the NFSv4.0 protocol.",
      "ja": "O NFSv4.0プロトコルを明らかにする。"
    },
    {
      "indent": 0,
      "text": "1.4. NFSv4 Goals",
      "section_title": true,
      "ja": "1.4.  NFSv4の目標"
    },
    {
      "indent": 3,
      "text": "The NFSv4 protocol is a further revision of the NFS protocol defined already by NFSv3 [31]. It retains the essential characteristics of previous versions: easy recovery; independence of transport protocols, operating systems, and file systems; simplicity; and good performance. NFSv4 has the following goals:",
      "ja": "NFSv4プロトコルはNFSv3の[31]で既に定義されたNFSプロトコルのさらなるリビジョンです。これは、以前のバージョンの本質的な特徴を保持：簡単に回復します。トランスポートプロトコル、オペレーティング・システム、およびファイルシステムの独立性。シンプルさ。そして、優れたパフォーマンス。 NFSv4のは、次の目標を持っています："
    },
    {
      "indent": 3,
      "text": "o Improved access and good performance on the Internet",
      "ja": "O、インターネット上でアクセスし、良好なパフォーマンスを改善しました"
    },
    {
      "indent": 6,
      "text": "The protocol is designed to transit firewalls easily, perform well where latency is high and bandwidth is low, and scale to very large numbers of clients per server.",
      "ja": "プロトコルは、レイテンシが高く、帯域幅が低い場合も実行し、簡単にトランジットのファイアウォールに設計されており、サーバーあたりのクライアントの規模に非常に大きな数字です。"
    },
    {
      "indent": 3,
      "text": "o Strong security with negotiation built into the protocol",
      "ja": "O交渉を持つ強力なセキュリティプロトコルに組み込まれて"
    },
    {
      "indent": 6,
      "text": "The protocol builds on the work of the ONCRPC working group in supporting the RPCSEC_GSS protocol. Additionally, the NFSv4.1 protocol provides a mechanism to allow clients and servers the ability to negotiate security and require clients and servers to support a minimal set of security schemes.",
      "ja": "プロトコルは、RPCSEC_GSSプロトコルをサポートするONCRPCワーキンググループの作業に基づいています。また、NFSv4.1プロトコルは、クライアントとサーバにセキュリティをネゴシエートし、セキュリティ方式の最小セットをサポートするために、クライアントとサーバーを必要とする機能を許可するためのメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "o Good cross-platform interoperability",
      "ja": "Oグッドクロスプラットフォームの相互運用性"
    },
    {
      "indent": 6,
      "text": "The protocol features a file system model that provides a useful, common set of features that does not unduly favor one file system or operating system over another.",
      "ja": "プロトコルは不当に別の上に1つのファイル・システムまたはオペレーティング・システムを支持していない機能の便利な、共通セットを提供し、ファイルシステムのモデルを提供しています。"
    },
    {
      "indent": 3,
      "text": "o Designed for protocol extensions",
      "ja": "Oプロトコル拡張のために設計"
    },
    {
      "indent": 6,
      "text": "The protocol is designed to accept standard extensions within a framework that enables and encourages backward compatibility.",
      "ja": "プロトコルが可能と下位互換性を奨励枠内標準の拡張を受け入れるように設計されています。"
    },
    {
      "indent": 0,
      "text": "1.5. NFSv4.1 Goals",
      "section_title": true,
      "ja": "1.5.  NFSv4.1目標"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 has the following goals, within the framework established by the overall NFSv4 goals.",
      "ja": "NFSv4.1は、全体のNFSv4のゴールによって確立された枠組みの中で、次の目標を持っています。"
    },
    {
      "indent": 3,
      "text": "o To correct significant structural weaknesses and oversights discovered in the base protocol.",
      "ja": "oは基本プロトコルで発見された重要な構造の弱点や見落としを修正します。"
    },
    {
      "indent": 3,
      "text": "o To add clarity and specificity to areas left unaddressed or not addressed in sufficient detail in the base protocol. However, as stated in Section 1.3, it is not a goal to clarify the NFSv4.0 protocol in the NFSv4.1 specification.",
      "ja": "oは非アドレス指定領域左またはベースプロトコルに十分に詳細に扱われていないと明確さと特異性を追加します。第1.3節で述べたようにしかし、NFSv4.1仕様のNFSv4.0プロトコルを明確にする目的ではありません。"
    },
    {
      "indent": 3,
      "text": "o To add specific features based on experience with the existing protocol and recent industry developments.",
      "ja": "oは既存のプロトコルと最近の業界動向と経験に基づいて特定の機能を追加します。"
    },
    {
      "indent": 3,
      "text": "o To provide protocol support to take advantage of clustered server deployments including the ability to provide scalable parallel access to files distributed among multiple servers.",
      "ja": "oは、複数のサーバに分散ファイルにスケーラブルな並列アクセスを提供する能力を含むクラスタ化されたサーバー展開を利用するために、プロトコルのサポートを提供します。"
    },
    {
      "indent": 0,
      "text": "1.6. General Definitions",
      "section_title": true,
      "ja": "1.6. 一般的な定義"
    },
    {
      "indent": 3,
      "text": "The following definitions provide an appropriate context for the reader.",
      "ja": "以下の定義は、読者のために適切なコンテキストを提供します。"
    },
    {
      "indent": 3,
      "text": "Byte: In this document, a byte is an octet, i.e., a datum exactly 8 bits in length.",
      "ja": "バイト：この文書では、バイトはオクテット、即ち、基準長さが正確に8ビットです。"
    },
    {
      "indent": 3,
      "text": "Client: The client is the entity that accesses the NFS server's resources. The client may be an application that contains the logic to access the NFS server directly. The client may also be the traditional operating system client that provides remote file system services for a set of applications.",
      "ja": "クライアント：クライアントがNFSサーバーのリソースにアクセスするエンティティです。クライアントは直接NFSサーバーにアクセスするためのロジックが含まれているアプリケーションであってもよいです。また、クライアントはアプリケーションのセットのためにリモートファイルシステムのサービスを提供し、伝統的なオペレーティングシステムのクライアントであってもよいです。"
    },
    {
      "indent": 6,
      "text": "A client is uniquely identified by a client owner.",
      "ja": "クライアントが独自にクライアント所有者によって識別されます。"
    },
    {
      "indent": 6,
      "text": "With reference to byte-range locking, the client is also the entity that maintains a set of locks on behalf of one or more applications. This client is responsible for crash or failure recovery for those locks it manages.",
      "ja": "バイト範囲ロックを参照すると、クライアントは、1つ以上のアプリケーションのためにロックのセットを保持するエンティティです。このクライアントは、それが管理し、それらのロックのクラッシュや障害復旧のために責任があります。"
    },
    {
      "indent": 6,
      "text": "Note that multiple clients may share the same transport and connection and multiple clients may exist on the same network node.",
      "ja": "複数のクライアントが同じトランスポートおよび接続を共有してもよいし、複数のクライアントが同一のネットワーク・ノードに存在してもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Client ID: The client ID is a 64-bit quantity used as a unique, short-hand reference to a client-supplied verifier and client owner. The server is responsible for supplying the client ID.",
      "ja": "クライアントIDは、クライアントIDは、クライアントが提供する検証者とクライアント所有者に固有の、ショートハンド基準として使用される64ビット量です。サーバーは、クライアントのIDを供給するための責任があります。"
    },
    {
      "indent": 3,
      "text": "Client Owner: The client owner is a unique string, opaque to the server, that identifies a client. Multiple network connections and source network addresses originating from those connections may share a client owner. The server is expected to treat requests from connections with the same client owner as coming from the same client.",
      "ja": "クライアント所有者：クライアントの所有者は、クライアントを特定のサーバへの不透明なユニークな文字列です。これらの接続に起因する複数のネットワーク接続とソースネットワークアドレスは、クライアント所有者を共有することがあります。サーバーは、同じクライアントから来ると同じクライアント所有者との接続からの要求を処理することが期待されます。"
    },
    {
      "indent": 3,
      "text": "File System: The file system is the collection of objects on a server (as identified by the major identifier of a server owner, which is defined later in this section) that share the same fsid attribute (see Section 5.8.1.9).",
      "ja": "ファイルシステム：ファイルシステムに同じFSID属性を共有し、サーバ上のオブジェクトのコレクション（この項の後半で定義されているサーバーの所有者の主要な識別子によって識別される）（セクション5.8.1.9を参照）です。"
    },
    {
      "indent": 3,
      "text": "Lease: A lease is an interval of time defined by the server for which the client is irrevocably granted locks. At the end of a lease period, locks may be revoked if the lease has not been extended. A lock must be revoked if a conflicting lock has been granted after the lease interval.",
      "ja": "リース：リースは、クライアントが取り返しのつかないロックを付与されているサーバーで定義された時間間隔です。リースが拡張されていない場合、リース期間の終了時に、ロックが取り消されてもよいです。競合ロックがリース期間の後に付与されている場合はロックが取り消されなければなりません。"
    },
    {
      "indent": 6,
      "text": "A server grants a client a single lease for all state.",
      "ja": "サーバーはクライアントにすべての状態のための単一のリースを付与します。"
    },
    {
      "indent": 3,
      "text": "Lock: The term \"lock\" is used to refer to byte-range (in UNIX environments, also known as record) locks, share reservations, delegations, or layouts unless specifically stated otherwise.",
      "ja": "ロック：特に明記しない限り、用語「ロック」はロック、共有の予約、委任、またはレイアウト（また、レコードとして知られているUNIX環境で、）バイト範囲を指すために使用されます。"
    },
    {
      "indent": 3,
      "text": "Secret State Verifier (SSV): The SSV is a unique secret key shared between a client and server. The SSV serves as the secret key for an internal (that is, internal to NFSv4.1) Generic Security Services (GSS) mechanism (the SSV GSS mechanism; see Section 2.10.9). The SSV GSS mechanism uses the SSV to compute message integrity code (MIC) and Wrap tokens. See Section 2.10.8.3 for more details on how NFSv4.1 uses the SSV and the SSV GSS mechanism.",
      "ja": "シークレット状態検証（SSV）：SSVは、クライアントとサーバの間で共有独特の秘密鍵です。 SSVは内部（つまり、NFSv4.1の内部にある）一般的なセキュリティサービス（GSS）メカニズム（;セクション2.10.9を参照してくださいSSV GSSメカニズム）のための秘密鍵として機能します。 SSV GSS機構は、メッセージ完全性コード（MIC）とラップトークンを計算するSSVを使用します。 NFSv4.1はSSV SSVとGSSメカニズムを使用する方法の詳細については、セクション2.10.8.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Server: The Server is the entity responsible for coordinating client access to a set of file systems and is identified by a server owner. A server can span multiple network addresses.",
      "ja": "サーバー：サーバーは、ファイル・システムのセットへのクライアントアクセスの調整を担当するエンティティであり、サーバーの所有者によって識別されます。サーバーは、複数のネットワークアドレスにまたがることができます。"
    },
    {
      "indent": 3,
      "text": "Server Owner: The server owner identifies the server to the client. The server owner consists of a major identifier and a minor identifier. When the client has two connections each to a peer with the same major identifier, the client assumes that both peers are the same server (the server namespace is the same via each connection) and that lock state is sharable across both connections. When each peer has both the same major and minor identifiers, the client assumes that each connection might be associable with the same session.",
      "ja": "サーバーの所有者：サーバーの所有者がクライアントにサーバーを識別します。サーバーの所有者は、主要な識別子とマイナー識別子で構成されています。クライアントが同じ主要な識別子を持つピアに2つの接続それぞれを有している場合、クライアントは、両方のピアが同じサーバであると仮定している（サーバの名前空間は、各接続を介して同一である）、そのロック状態では両方の接続を横切って共有可能です。各ピアは、同じメジャーとマイナーの識別子の両方を持っている場合、クライアントはそれぞれの接続は、同じセッションで会合可能であるかもしれないことを前提としています。"
    },
    {
      "indent": 3,
      "text": "Stable Storage: Stable storage is storage from which data stored by an NFSv4.1 server can be recovered without data loss from multiple power failures (including cascading power failures, that is, several power failures in quick succession), operating system failures, and/or hardware failure of components other than the storage medium itself (such as disk, nonvolatile RAM, flash memory, etc.).",
      "ja": "貯蔵安定性：安定したストレージ/ NFSv4.1サーバによって記憶されたデータは、オペレーティングシステムの障害（即ち、立て続けにいくつかの停電を停電のカスケードを含む）複数の電力障害からデータを損失することなく回収することが可能なストレージであり、そして記憶媒体自体（等ディスク、不揮発性RAM、フラッシュメモリなど）以外の成分またはハードウェア障害。"
    },
    {
      "indent": 6,
      "text": "Some examples of stable storage that are allowable for an NFS server include:",
      "ja": "NFSサーバ用に許容される安定したストレージのいくつかの例は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "1. Media commit of data; that is, the modified data has been successfully written to the disk media, for example, the disk platter.",
      "ja": "1.メディアは、データのコミット。つまり、変更されたデータが正常にディスクプラッタ、例えば、ディスクメディアに書き込まれています。"
    },
    {
      "indent": 6,
      "text": "2. An immediate reply disk drive with battery-backed, on-drive intermediate storage or uninterruptible power system (UPS).",
      "ja": "2.バッテリバックアップ、オン駆動中間貯蔵または無停電電源装置（UPS）との即時応答ディスクドライブ。"
    },
    {
      "indent": 6,
      "text": "3. Server commit of data with battery-backed intermediate storage and recovery software.",
      "ja": "3.サーバーは、バッテリバックアップ中間貯蔵及び回復ソフトウェアとデータのコミット。"
    },
    {
      "indent": 6,
      "text": "4. Cache commit with uninterruptible power system (UPS) and recovery software.",
      "ja": "4.キャッシュは、無停電電源装置（UPS）と回復ソフトウェアをコミットします。"
    },
    {
      "indent": 3,
      "text": "Stateid: A stateid is a 128-bit quantity returned by a server that uniquely defines the open and locking states provided by the server for a specific open-owner or lock-owner/open-owner pair for a specific file and type of lock.",
      "ja": "stateidは：のstateid一意特定のファイルとロックの種類に特異的なオープン所有者またはロック所有者/オープン所有者ペアのサーバーによって提供されるオープンとロック状態を定義し、サーバによって返された128ビットの量です。"
    },
    {
      "indent": 3,
      "text": "Verifier: A verifier is a 64-bit quantity generated by the client that the server can use to determine if the client has restarted and lost all previous lock state.",
      "ja": "検証：検証者は、サーバは、クライアントが再起動し、すべての以前のロック状態を喪失したかどうかを判定するために使用できるクライアントによって生成された64ビット量です。"
    },
    {
      "indent": 0,
      "text": "1.7. Overview of NFSv4.1 Features",
      "section_title": true,
      "ja": "1.7.  NFSv4.1機能の概要"
    },
    {
      "indent": 3,
      "text": "The major features of the NFSv4.1 protocol will be reviewed in brief. This will be done to provide an appropriate context for both the reader who is familiar with the previous versions of the NFS protocol and the reader who is new to the NFS protocols. For the reader new to the NFS protocols, there is still a set of fundamental knowledge that is expected. The reader should be familiar with the External Data Representation (XDR) and Remote Procedure Call (RPC) protocols as described in [2] and [3]. A basic knowledge of file systems and distributed file systems is expected as well.",
      "ja": "NFSv4.1プロトコルの主な機能は、簡単に審査されます。これは、NFSプロトコルとNFSプロトコルに新しく追加され、リーダの以前のバージョンに精通している読者の両方のために適切なコンテキストを提供するために行われます。 NFSプロトコルへの新しい読者のために、期待されている基本的な知識のセットがまだあります。記載のようにリーダーは、外部データ表現（XDR）とリモートプロシージャコール（RPC）プロトコルに精通している必要があり[2]、[3]。ファイルシステムと分散ファイルシステムの基本的な知識も同様に期待されています。"
    },
    {
      "indent": 3,
      "text": "In general, this specification of NFSv4.1 will not distinguish those features added in minor version 1 from those present in the base protocol but will treat NFSv4.1 as a unified whole. See Section 1.8 for a summary of the differences between NFSv4.0 and NFSv4.1.",
      "ja": "一般的に、NFSv4.1のこの仕様は、ベースプロトコル中に存在するものからマイナーバージョン1で追加され、それらの機能を区別しないであろうが、統一された全体としてNFSv4.1を治療するであろう。 NFSv4.0とNFSv4.1間の違いの概要については、1.8項を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.7.1. RPC and Security",
      "section_title": true,
      "ja": "1.7.1.  RPCとセキュリティ"
    },
    {
      "indent": 3,
      "text": "As with previous versions of NFS, the External Data Representation (XDR) and Remote Procedure Call (RPC) mechanisms used for the NFSv4.1 protocol are those defined in [2] and [3]. To meet end-to-end security requirements, the RPCSEC_GSS framework [4] is used to extend the basic RPC security. With the use of RPCSEC_GSS, various mechanisms can be provided to offer authentication, integrity, and privacy to the NFSv4 protocol. Kerberos V5 is used as described in [5] to provide one security framework. With the use of RPCSEC_GSS, other mechanisms may also be specified and used for NFSv4.1 security.",
      "ja": "NFSの以前のバージョンと同様に、NFSv4.1プロトコルに使用される外部データ表現（XDR）とリモートプロシージャコール（RPC）メカニズムは、で定義されたものである[2]、[3]。エンドツーエンドのセキュリティ要件を満たすために、RPCSEC_GSSフレームワーク[4]は、基本的なRPCセキュリティを拡張するために使用されます。 RPCSEC_GSSを使用すると、様々なメカニズムがNFSv4のプロトコルに認証、整合性、およびプライバシーを提供するために提供することができます。 [5]つのセキュリティ・フレームワークを提供するために記載されているようにケルベロスV5が使用されます。 RPCSEC_GSSを使用して、他の機構も指定されてもよく、NFSv4.1セキュリティのために使用されます。"
    },
    {
      "indent": 3,
      "text": "To enable in-band security negotiation, the NFSv4.1 protocol has operations that provide the client a method of querying the server about its policies regarding which security mechanisms must be used for access to the server's file system resources. With this, the client can securely match the security mechanism that meets the policies specified at both the client and server.",
      "ja": "インバンドセキュリティネゴシエーションを有効にするには、NFSv4.1プロトコルはクライアントにセキュリティメカニズムは、サーバーのファイル・システム・リソースへのアクセスに使用する必要がありますについての方針についてのサーバーを照会する方法を提供する事業を展開しています。これにより、クライアントが安全に、クライアントとサーバの両方で指定したポリシーを満たしているセキュリティ・メカニズムを一致させることができます。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 introduces parallel access (see Section 1.7.2.2), which is called pNFS. The security framework described in this section is significantly modified by the introduction of pNFS (see Section 12.9), because data access is sometimes not over RPC. The level of significance varies with the storage protocol (see Section 12.2.5) and can be as low as zero impact (see Section 13.12).",
      "ja": "NFSv4.1はpNFSのと呼ばれる並列アクセスを（セクション1.7.2.2を参照）を、紹介します。データアクセスがRPC上時々ないため、このセクションで説明するセキュリティフレームワークを大幅に、pNFSの（セクション12.9を参照）の導入により修飾されています。有意水準（セクション13.12を参照）ストレージプロトコル（セクション12.2.5を参照）に応じて変化し、ゼロ影響限り低くすることができます。"
    },
    {
      "indent": 0,
      "text": "1.7.2. Protocol Structure",
      "section_title": true,
      "ja": "1.7.2. プロトコル構造"
    },
    {
      "indent": 0,
      "text": "1.7.2.1. Core Protocol",
      "section_title": true,
      "ja": "1.7.2.1。コアプロトコル"
    },
    {
      "indent": 3,
      "text": "Unlike NFSv3, which used a series of ancillary protocols (e.g., NLM, NSM (Network Status Monitor), MOUNT), within all minor versions of NFSv4 a single RPC protocol is used to make requests to the server. Facilities that had been separate protocols, such as locking, are now integrated within a single unified protocol.",
      "ja": "補助的な一連のプロトコルを使用したNFSv3とは異なり（例えば、NLM、NSM（ネットワークステータスモニタ）、MOUNT）は、NFSv4のすべてのマイナーバージョン内の単一のRPCプロトコルは、サーバーへのリクエストを行うために使用されます。このようなロックのような別個のプロトコル、されていた施設は、今や単一の統一プロトコル内に統合されています。"
    },
    {
      "indent": 0,
      "text": "1.7.2.2. Parallel Access",
      "section_title": true,
      "ja": "1.7.2.2。パラレル・アクセス"
    },
    {
      "indent": 3,
      "text": "Minor version 1 supports high-performance data access to a clustered server implementation by enabling a separation of metadata access and data access, with the latter done to multiple servers in parallel.",
      "ja": "マイナーバージョン1は、並行して複数のサーバーに行わ後者で、メタデータアクセス及びデータアクセスの分離を可能にすることによって、クラスタ化サーバの実装に高性能データアクセスをサポートします。"
    },
    {
      "indent": 3,
      "text": "Such parallel data access is controlled by recallable objects known as \"layouts\", which are integrated into the protocol locking model. Clients direct requests for data access to a set of data servers specified by the layout via a data storage protocol which may be NFSv4.1 or may be another protocol.",
      "ja": "そのような並列データアクセスは、プロトコルロックモデルに組み込まれている「レイアウト」として知られているリコールオブジェクトによって制御されます。クライアントNFSv4.1であってもよいし、他のプロトコルであってもよいデータ・ストレージ・プロトコルを介してレイアウトで指定されたデータ・サーバのセットへのデータアクセスのために直接要求します。"
    },
    {
      "indent": 3,
      "text": "Because the protocols used for parallel data access are not necessarily RPC-based, the RPC-based security model (Section 1.7.1) is obviously impacted (see Section 12.9). The degree of impact varies with the storage protocol (see Section 12.2.5) used for data access, and can be as low as zero (see Section 13.12).",
      "ja": "パラレルデータアクセスに使用されるプロトコルは、必ずしもRPCベースではないため、RPCベースのセキュリティモデル（1.7.1項）は明らかに影響される（セクション12.9を参照）。影響の程度は、データアクセスのために使用されるストレージ・プロトコル（セクション12.2.5を参照）と異なり、ゼロ（セクション13.12を参照）のように低くすることができます。"
    },
    {
      "indent": 0,
      "text": "1.7.3. File System Model",
      "section_title": true,
      "ja": "1.7.3. ファイルシステムモデル"
    },
    {
      "indent": 3,
      "text": "The general file system model used for the NFSv4.1 protocol is the same as previous versions. The server file system is hierarchical with the regular files contained within being treated as opaque byte streams. In a slight departure, file and directory names are encoded with UTF-8 to deal with the basics of internationalization.",
      "ja": "NFSv4.1プロトコルに使用される一般的なファイルシステム・モデルは、以前のバージョンと同じです。サーバーのファイルシステムは、不透明なバイトストリームとして処理されている内に含まれ、通常のファイルと階層的です。若干の出発では、ファイル名やディレクトリ名は、国際化の基礎に対処するためにUTF-8でエンコードされています。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol does not require a separate protocol to provide for the initial mapping between path name and filehandle. All file systems exported by a server are presented as a tree so that all file systems are reachable from a special per-server global root filehandle. This allows LOOKUP operations to be used to perform functions previously provided by the MOUNT protocol. The server provides any necessary pseudo file systems to bridge any gaps that arise due to unexported gaps between exported file systems.",
      "ja": "NFSv4.1プロトコルは、パス名とファイルハンドルとの間の最初のマッピングを提供するために、別のプロトコルを必要としません。すべてのファイルシステムは特殊なサーバーごとのグローバルルートファイルハンドルから到達可能であるように、サーバーによってエクスポートされたすべてのファイルシステムは、ツリーとして提示されています。これは、ルックアップ動作は、以前MOUNTプロトコルによって提供される機能を実行するために使用されることを可能にします。サーバーは、エクスポートされたファイルシステムとの間のアンエクスポートの隙間に起因生じる隙間を埋めるために必要な疑似ファイルシステムを提供します。"
    },
    {
      "indent": 0,
      "text": "1.7.3.1. Filehandles",
      "section_title": true,
      "ja": "1.7.3.1。ファイルハンドル"
    },
    {
      "indent": 3,
      "text": "As in previous versions of the NFS protocol, opaque filehandles are used to identify individual files and directories. Lookup-type and create operations translate file and directory names to filehandles, which are then used to identify objects in subsequent operations.",
      "ja": "NFSプロトコルの以前のバージョンと同様に、不透明なファイルハンドルは、個々のファイルやディレクトリを識別するために使用されています。検索型と、その後の操作でオブジェクトを識別するために使用されているファイルハンドルにファイル名やディレクトリ名を翻訳オペレーションを作成します。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol provides support for persistent filehandles, guaranteed to be valid for the lifetime of the file system object designated. In addition, it provides support to servers to provide filehandles with more limited validity guarantees, called volatile filehandles.",
      "ja": "NFSv4.1プロトコルが指定されたファイル・システム・オブジェクトの寿命のために有効であることが保証永続的なファイルハンドルをサポートします。また、揮発性ファイルハンドルと呼ばれる、より限定された有効性の保証、でファイルハンドルを提供するために、サーバーへのサポートを提供します。"
    },
    {
      "indent": 0,
      "text": "1.7.3.2. File Attributes",
      "section_title": true,
      "ja": "1.7.3.2。ファイル属性"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol has a rich and extensible file object attribute structure, which is divided into REQUIRED, RECOMMENDED, and named attributes (see Section 5).",
      "ja": "NFSv4.1プロトコルは、必須推奨、と命名された属性（セクション5を参照）に分割して、リッチで拡張可能なファイルオブジェクトの属性構造を持っています。"
    },
    {
      "indent": 3,
      "text": "Several (but not all) of the REQUIRED attributes are derived from the attributes of NFSv3 (see the definition of the fattr3 data type in [31]). An example of a REQUIRED attribute is the file object's type (Section 5.8.1.2) so that regular files can be distinguished from directories (also known as folders in some operating environments) and other types of objects. REQUIRED attributes are discussed in Section 5.1.",
      "ja": "必須属性のいくつか（全てではないが）NFSv3のの属性から導出される（[31]でfattr3データ型の定義を参照のこと）。通常のファイルは、ディレクトリ（また、一部のオペレーティング環境でのフォルダとして知られる）および他のタイプのオブジェクトと区別できるように、必要な属性の例は、ファイルオブジェクトのタイプ（セクション5.8.1.2）です。必要な属性は、セクション5.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "An example of three RECOMMENDED attributes are acl, sacl, and dacl. These attributes define an Access Control List (ACL) on a file object (Section 6). An ACL provides directory and file access control beyond the model used in NFSv3. The ACL definition allows for specification of specific sets of permissions for individual users and groups. In addition, ACL inheritance allows propagation of access permissions and restrictions down a directory tree as file system objects are created. RECOMMENDED attributes are discussed in Section 5.2.",
      "ja": "3つの推奨属性の例は、ACL、SACL、およびDACLです。これらの属性はファイルオブジェクト（第6節）のアクセス制御リスト（ACL）を定義します。 ACLはNFSv3のに使用されるモデルを超えて、ディレクトリとファイルのアクセス制御を提供します。 ACL定義は、個々のユーザーおよびグループの権限の特定のセットの仕様を可能にします。ファイル・システム・オブジェクトが作成されるほか、ACLの継承は、ディレクトリツリー下のアクセス許可と制限の伝搬を可能にします。推奨属性は、5.2節で議論されています。"
    },
    {
      "indent": 3,
      "text": "A named attribute is an opaque byte stream that is associated with a directory or file and referred to by a string name. Named attributes are meant to be used by client applications as a method to associate application-specific data with a regular file or directory. NFSv4.1 modifies named attributes relative to NFSv4.0 by tightening the allowed operations in order to prevent the development of non-interoperable implementations. Named attributes are discussed in Section 5.3.",
      "ja": "名前の属性は、ディレクトリやファイルに関連付けられており、文字列名で呼ばれる不透明なバイトストリームです。名前付き属性は、通常のファイルまたはディレクトリとアプリケーション固有のデータを関連付けるための方法として、クライアントアプリケーションによって使用されることを意味しています。 NFSv4.1は、非相互運用可能な実装の開発を防ぐために許可される操作を締めて、NFSv4.0に対するという名前の属性を変更します。名前付き属性は、5.3節で議論されています。"
    },
    {
      "indent": 0,
      "text": "1.7.3.3. Multi-Server Namespace",
      "section_title": true,
      "ja": "1.7.3.3。マルチサーバーの名前空間"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 contains a number of features to allow implementation of namespaces that cross server boundaries and that allow and facilitate a non-disruptive transfer of support for individual file systems between servers. They are all based upon attributes that allow one file system to specify alternate or new locations for that file system.",
      "ja": "NFSv4.1は、サーバーの境界を越え、それが可能になり、サーバ間の個々のファイルシステムのサポートの無停止移行を促進する名前空間の実装を可能にするために、多数の機能が含まれています。これらはすべて一つのファイルシステムは、そのファイルシステムの代替または新しい場所を指定することができ、属性に基づいています。"
    },
    {
      "indent": 3,
      "text": "These attributes may be used together with the concept of absent file systems, which provide specifications for additional locations but no actual file system content. This allows a number of important facilities:",
      "ja": "これらの属性は、追加の場所のための仕様が、実際のファイル・システム・コンテンツを提供不在でのファイルシステムの概念と一緒に使用することもできます。これは重要な施設の数を可能にします："
    },
    {
      "indent": 3,
      "text": "o Location attributes may be used with absent file systems to implement referrals whereby one server may direct the client to a file system provided by another server. This allows extensive multi-server namespaces to be constructed.",
      "ja": "O場所属性は、一つのサーバが別のサーバによって提供されるファイルシステムにクライアントに指示することができることにより、照会を実装するために存在しないファイルシステムで使用されてもよいです。これは、大規模なマルチサーバーの名前空間を構築することを可能にします。"
    },
    {
      "indent": 3,
      "text": "o Location attributes may be provided for present file systems to provide the locations of alternate file system instances or replicas to be used in the event that the current file system instance becomes unavailable.",
      "ja": "Oロケーション属性は、現在のファイル・システム・インスタンスが使用できなくなった場合に使用する代替ファイル・システム・インスタンスまたはレプリカの場所を提供することが、本ファイルシステムのために提供されてもよいです。"
    },
    {
      "indent": 3,
      "text": "o Location attributes may be provided when a previously present file system becomes absent. This allows non-disruptive migration of file systems to alternate servers.",
      "ja": "以前に、本ファイルシステムが不在になったときにO場所属性が提供されてもよいです。これは、代替サーバーへのファイル・システムの無停止移行できます。"
    },
    {
      "indent": 0,
      "text": "1.7.4. Locking Facilities",
      "section_title": true,
      "ja": "1.7.4. ロック施設"
    },
    {
      "indent": 3,
      "text": "As mentioned previously, NFSv4.1 is a single protocol that includes locking facilities. These locking facilities include support for many types of locks including a number of sorts of recallable locks.",
      "ja": "先に述べたように、NFSv4.1は、ロック機能を含む単一のプロトコルです。これらのロック機能は、リコールロックの種類の数など、ロックの多くの種類をサポートしています。"
    },
    {
      "indent": 3,
      "text": "Recallable locks such as delegations allow the client to be assured that certain events will not occur so long as that lock is held. When circumstances change, the lock is recalled via a callback request. The assurances provided by delegations allow more extensive caching to be done safely when circumstances allow it.",
      "ja": "などの代表団としてリコールロックは、クライアントが特定のイベントは、そのロックが保持される限り発生しないことを保証することを可能にします。状況が変化した場合、ロックはコールバック要求を経由してリコールされます。代表団が提供する保証は、事情が許すときに、より広範なキャッシングが安全に行われることを可能にします。"
    },
    {
      "indent": 3,
      "text": "The types of locks are:",
      "ja": "ロックの種類は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Share reservations as established by OPEN operations.",
      "ja": "OPEN操作によって確立されたOシェア予約。"
    },
    {
      "indent": 3,
      "text": "o Byte-range locks.",
      "ja": "Oバイト範囲ロック。"
    },
    {
      "indent": 3,
      "text": "o File delegations, which are recallable locks that assure the holder that inconsistent opens and file changes cannot occur so long as the delegation is held.",
      "ja": "矛盾が開き、ファイルの変更があれば、委任が保持されているように発生することができないというホルダーを保証リコールロックされているOファイルの代表団、。"
    },
    {
      "indent": 3,
      "text": "o Directory delegations, which are recallable locks that assure the holder that inconsistent directory modifications cannot occur so long as the delegation is held.",
      "ja": "矛盾ディレクトリの変更があれば委任が保持されるように発生することができないホルダーを保証リコールロックされているOディレクトリ委任。"
    },
    {
      "indent": 3,
      "text": "o Layouts, which are recallable objects that assure the holder that direct access to the file data may be performed directly by the client and that no change to the data's location that is inconsistent with that access may be made so long as the layout is held.",
      "ja": "ファイルのデータへの直接アクセスがクライアントによって、そのアクセスと矛盾しているデータの位置に変化があれば、レイアウトが保持されるようになされなくてもよいことは直接実行されてもよいことホルダーを保証リコール対象であるOレイアウト、。"
    },
    {
      "indent": 3,
      "text": "All locks for a given client are tied together under a single client-wide lease. All requests made on sessions associated with the client renew that lease. When the client's lease is not promptly renewed, the client's locks are subject to revocation. In the event of server restart, clients have the opportunity to safely reclaim their locks within a special grace period.",
      "ja": "特定のクライアントのためのすべてのロックは、単一のクライアント全体のリースの下で一緒に接続されています。クライアントに関連付けられているセッションで行われたすべての要求は、そのリースを更新します。クライアントのリースが速やかに更新されていない場合は、クライアントのロックは取り消しの対象となります。サーバーの再起動が発生した場合、クライアントは安全に特別猶予期間内にロックを再要求する機会を持っています。"
    },
    {
      "indent": 0,
      "text": "1.8. Differences from NFSv4.0",
      "section_title": true,
      "ja": "1.8.  NFSv4.0との違い"
    },
    {
      "indent": 3,
      "text": "The following summarizes the major differences between minor version 1 and the base protocol:",
      "ja": "以下は、マイナーバージョン1と基本プロトコルの主な違いを要約します。"
    },
    {
      "indent": 3,
      "text": "o Implementation of the sessions model (Section 2.10).",
      "ja": "セッションモデル（2.10）のOの実装。"
    },
    {
      "indent": 3,
      "text": "o Parallel access to data (Section 12).",
      "ja": "データへの並列アクセスをO（第12節）。"
    },
    {
      "indent": 3,
      "text": "o Addition of the RECLAIM_COMPLETE operation to better structure the lock reclamation process (Section 18.51).",
      "ja": "O RECLAIM_COMPLETE動作の添加は、より良好なロックリクラメーション処理（セクション18.51）の構造に関する。"
    },
    {
      "indent": 3,
      "text": "o Enhanced delegation support as follows.",
      "ja": "次のようにO委任のサポートを強化。"
    },
    {
      "indent": 6,
      "text": "* Delegations on directories and other file types in addition to regular files (Section 18.39, Section 18.49).",
      "ja": "*通常のファイル（項18.39、項18.49）に加えて、ディレクトリと他のファイルタイプの代表団。"
    },
    {
      "indent": 6,
      "text": "* Operations to optimize acquisition of recalled or denied delegations (Section 18.49, Section 20.5, Section 20.7).",
      "ja": "*リコールまたは拒否された代表団（項18.49、セクション20.5、セクション20.7）の取得を最適化するための操作。"
    },
    {
      "indent": 6,
      "text": "* Notifications of changes to files and directories (Section 18.39, Section 20.4).",
      "ja": "*ファイルやディレクトリへの変更の通知（セクション18.39、20.4項）。"
    },
    {
      "indent": 6,
      "text": "* A method to allow a server to indicate that it is recalling one or more delegations for resource management reasons, and thus a method to allow the client to pick which delegations to return (Section 20.6).",
      "ja": "それは資源管理上の理由から、一つ以上の委任を想起し、クライアントが（セクション20.6）を返すためにどの代表団選択できるようにするための方法であることを示すために、サーバーを許可する*方法。"
    },
    {
      "indent": 3,
      "text": "o Attributes can be set atomically during exclusive file create via the OPEN operation (see the new EXCLUSIVE4_1 creation method in Section 18.16).",
      "ja": "O属性は（セクション18.16で新しいEXCLUSIVE4_1作成方法を参照してください）OPEN操作を経て作成排他的なファイル中に原子レベルで設定することができます。"
    },
    {
      "indent": 3,
      "text": "o Open files can be preserved if removed and the hard link count (\"hard link\" is defined in an Open Group [Section 3.191 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\"\">6] standard) goes to zero, thus obviating the need for clients to rename deleted files to partially hidden names -- colloquially called \"silly rename\" (see the new OPEN4_RESULT_PRESERVE_UNLINKED reply flag in Section 18.16).",
      "ja": "Oオープンファイルを削除した場合、保存することができ、ハードリンク数（「ハードリンクは、」Open Groupの基本仕様の問題の基本定義6 IEEE STD 1003.1、2004年版、HTMLバージョンの第3章のオープングループ[セクション3.191に定義されています愚かな名前の変更「（新OPEN4_RESULT_PRESERVE_UNLINKED返信フラグを参照してください - （www.opengroup.org）、ISBN 1931624232「」口語と呼ばれる> 6]標準では）ので、クライアントが部分的に隠された名前がために削除されたファイルの名前を変更するための必要性をなくす、ゼロになります」 ）第18.16インチ"
    },
    {
      "indent": 3,
      "text": "o Improved compatibility with Microsoft Windows for Access Control Lists (Section 6.2.3, Section 6.2.2, Section 6.4.3.2).",
      "ja": "Oアクセス制御リストのためのMicrosoft Windows（6.2.3項、6.2.2項、セクション6.4.3.2）との互換性の向上。"
    },
    {
      "indent": 3,
      "text": "o Data retention (Section 5.13).",
      "ja": "Oデータ保持（セクション5.13）。"
    },
    {
      "indent": 3,
      "text": "o Identification of the implementation of the NFS client and server (Section 18.35).",
      "ja": "O NFSクライアントとサーバの実装の同定（セクション18.35）。"
    },
    {
      "indent": 3,
      "text": "o Support for notification of the availability of byte-range locks (see the new OPEN4_RESULT_MAY_NOTIFY_LOCK reply flag in Section 18.16 and see Section 20.11).",
      "ja": "Oバイト範囲ロックの可用性の通知のサポート（セクション18.16で新しいOPEN4_RESULT_MAY_NOTIFY_LOCK応答フラグを参照し、セクション20.11を参照してください）。"
    },
    {
      "indent": 3,
      "text": "o In NFSv4.1, LIPKEY and SPKM-3 are not required security mechanisms [32].",
      "ja": "O NFSv4.1、LIPKEYおよびSPKM-3において必要とされないセキュリティメカニズム[32]。"
    },
    {
      "indent": 0,
      "text": "2. Core Infrastructure",
      "section_title": true,
      "ja": "2.コアインフラストラクチャ"
    },
    {
      "indent": 0,
      "text": "2.1. Introduction",
      "section_title": true,
      "ja": "2.1. 前書き"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 relies on core infrastructure common to nearly every operation. This core infrastructure is described in the remainder of this section.",
      "ja": "NFSv4.1は、ほぼすべての操作に共通のコアインフラストラクチャに依存しています。このコアインフラストラクチャは、このセクションの残りの部分に記載されています。"
    },
    {
      "indent": 0,
      "text": "2.2. RPC and XDR",
      "section_title": true,
      "ja": "2.2.  RPCとXDR"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol is a Remote Procedure Call (RPC) application that uses RPC version 2 and the corresponding eXternal Data Representation (XDR) as defined in [3] and [2].",
      "ja": "NFSv4.1プロトコルはRPCバージョン2を使用してリモートプロシージャコール（RPC）アプリケーションとで定義されるように、対応する外部データ表現（XDR）である[3]及び[2]。"
    },
    {
      "indent": 0,
      "text": "2.2.1. RPC-Based Security",
      "section_title": true,
      "ja": "2.2.1.  RPCベースのセキュリティ"
    },
    {
      "indent": 3,
      "text": "Previous NFS versions have been thought of as having a host-based authentication model, where the NFS server authenticates the NFS client, and trusts the client to authenticate all users. Actually, NFS has always depended on RPC for authentication. One of the first forms of RPC authentication, AUTH_SYS, had no strong authentication and required a host-based authentication approach. NFSv4.1 also depends on RPC for basic security services and mandates RPC support for a user-based authentication model. The user-based authentication model has user principals authenticated by a server, and in turn the server authenticated by user principals. RPC provides some basic security services that are used by NFSv4.1.",
      "ja": "前NFSバージョンはNFSサーバは、NFSクライアントを認証し、すべてのユーザーを認証するためにクライアントを信頼し、ホストベースの認証モデルを有するものとして考えられてきました。実際には、NFSは常に認証のためのRPCに依存してきました。 RPC認証、AUTH_SYSの最初の形態の1つは、何の強力な認証がなかったし、ホストベースの認証アプローチを必要としました。 NFSv4.1また、基本的なセキュリティサービスのためのRPCに依存し、ユーザベースの認証モデルのためのRPCのサポートを義務付け。ユーザベースの認証モデルは、サーバーによって認証されたユーザ・プリンシパルがあり、順番にサーバは、ユーザ・プリンシパルによって認証されました。 RPCは、NFSv4.1で使用されるいくつかの基本的なセキュリティサービスを提供しています。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1. RPC Security Flavors",
      "section_title": true,
      "ja": "2.2.1.1。 RPCセキュリティフレーバ"
    },
    {
      "indent": 3,
      "text": "As described in Section 7.2 (\"Authentication\") of [3], RPC security is encapsulated in the RPC header, via a security or authentication flavor, and information specific to the specified security flavor. Every RPC header conveys information used to identify and authenticate a client and server. As discussed in Section 2.2.1.1.1, some security flavors provide additional security services.",
      "ja": "セクション7.2（「認証」）に記載されているように[3]、RPCのセキュリティは、セキュリティまたは認証フレーバーを介して、RPCヘッダでカプセル化し、指定されたセキュリティ風味の情報が特定されます。すべてのRPCヘッダは、クライアントとサーバーを識別し、認証するために使用される情報を伝えます。セクション2.2.1.1.1で説明したように、いくつかのセキュリティフレーバーは、追加のセキュリティサービスを提供しています。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 clients and servers MUST implement RPCSEC_GSS. (This requirement to implement is not a requirement to use.) Other flavors, such as AUTH_NONE and AUTH_SYS, MAY be implemented as well.",
      "ja": "NFSv4.1クライアントとサーバは、RPCSEC_GSSを実装しなければなりません。例えばAUTH_NONEおよびAUTH_SYSとして（この要件を実現するために使用する必要はない。）他のフレーバーは、同様に実施することができます。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1.1. RPCSEC_GSS and Security Services",
      "section_title": true,
      "ja": "2.2.1.1.1。 RPCSEC_GSSとセキュリティサービス"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS [4] uses the functionality of GSS-API [7]. This allows for the use of various security mechanisms by the RPC layer without the additional implementation overhead of adding RPC security flavors.",
      "ja": "RPCSEC_GSS [4] [7] GSS-APIの機能を使用します。これは、RPCセキュリティ風味を加える追加の実施オーバーヘッドなしRPC層によって様々なセキュリティメカニズムの使用を可能にします。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1.1.1. Identification, Authentication, Integrity, Privacy",
      "section_title": true,
      "ja": "2.2.1.1.1.1。識別、認証、完全性、プライバシー"
    },
    {
      "indent": 3,
      "text": "Via the GSS-API, RPCSEC_GSS can be used to identify and authenticate users on clients to servers, and servers to users. It can also perform integrity checking on the entire RPC message, including the RPC header, and on the arguments or results. Finally, privacy, usually via encryption, is a service available with RPCSEC_GSS. Privacy is performed on the arguments and results. Note that if privacy is selected, integrity, authentication, and identification are enabled. If privacy is not selected, but integrity is selected, authentication and identification are enabled. If integrity and privacy are not selected, but authentication is enabled, identification is enabled. RPCSEC_GSS does not provide identification as a separate service.",
      "ja": "GSS-APIを経由して、RPCSEC_GSSは、ユーザーにサーバーへのクライアント、サーバー上のユーザーを識別し、認証するために使用することができます。それはまた、RPCヘッダを含む全体のRPCメッセージ、上及び引数または結果に整合性チェックを行うことができます。最後に、プライバシーは、通常の暗号化を経て、RPCSEC_GSSで利用できるサービスです。プライバシーは、引数と結果で行われます。プライバシーが選択されている場合、整合性、認証、および識別が有効になっていることに注意してください。プライバシーが選択されていませんが、完全性を選択した場合は、認証および識別が有効になっています。整合性とプライバシーが選択されていませんが、認証が有効になっている場合、識別が有効になっています。 RPCSEC_GSSは、別のサービスとして識別情報を提供していません。"
    },
    {
      "indent": 3,
      "text": "Although GSS-API has an authentication service distinct from its privacy and integrity services, GSS-API's authentication service is not used for RPCSEC_GSS's authentication service. Instead, each RPC request and response header is integrity protected with the GSS-API integrity service, and this allows RPCSEC_GSS to offer per-RPC authentication and identity. See [4] for more information.",
      "ja": "GSS-APIは、そのプライバシーと整合性サービスとは別個の認証サービスがありますが、GSS-APIの認証サービスはRPCSEC_GSSの認証サービスに使用されていません。代わりに、各RPCリクエストとレスポンスヘッダは、GSS-APIの整合性サービスで保護整合性であり、これはRPCSEC_GSSがあたり-RPC認証とアイデンティティを提供することができます。詳細については、[4]を参照してください。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 client and servers MUST support RPCSEC_GSS's integrity and authentication service. NFSv4.1 servers MUST support RPCSEC_GSS's privacy service. NFSv4.1 clients SHOULD support RPCSEC_GSS's privacy service.",
      "ja": "NFSv4.1のクライアントとサーバは、RPCSEC_GSSの整合性と認証サービスをサポートしなければなりません。 NFSv4.1サーバーでは、RPCSEC_GSSのプライバシーサービスをサポートしなければなりません。 NFSv4.1のクライアントはRPCSEC_GSSのプライバシーサービスをサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1.1.2. Security Mechanisms for NFSv4.1",
      "section_title": true,
      "ja": "2.2.1.1.1.2。 NFSv4.1のためのセキュリティメカニズム"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS, via GSS-API, normalizes access to mechanisms that provide security services. Therefore, NFSv4.1 clients and servers MUST support the Kerberos V5 security mechanism.",
      "ja": "RPCSEC_GSSは、GSS-APIを経由して、セキュリティサービスを提供するメカニズムへのアクセスを正規化します。したがって、NFSv4.1のクライアントとサーバは、Kerberos V5セキュリティメカニズムをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The use of RPCSEC_GSS requires selection of mechanism, quality of protection (QOP), and service (authentication, integrity, privacy). For the mandated security mechanisms, NFSv4.1 specifies that a QOP of zero is used, leaving it up to the mechanism or the mechanism's configuration to map QOP zero to an appropriate level of protection. Each mandated mechanism specifies a minimum set of cryptographic algorithms for implementing integrity and privacy. NFSv4.1 clients and servers MUST be implemented on operating environments that comply with the REQUIRED cryptographic algorithms of each REQUIRED mechanism.",
      "ja": "RPCSEC_GSSの使用は、メカニズムの選択、保護の品質（QOP）、およびサービス（認証、完全性、プライバシー）が必要です。義務付けられたセキュリティメカニズムについて、NFSv4.1は、機構や保護の適切なレベルにQOPゼロをマッピングするためのメカニズムの設定にそれを残して、ゼロのQOPが使用されていることを指定します。各義務付けメカニズムは、整合性とプライバシーを実装するための暗号化アルゴリズムの最小セットを指定します。 NFSv4.1のクライアントとサーバは、必要な各機構のREQUIRED暗号化アルゴリズムに準拠動作環境に実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1.1.2.1. Kerberos V5",
      "section_title": true,
      "ja": "2.2.1.1.1.2.1。ケルベロスV5"
    },
    {
      "indent": 3,
      "text": "The Kerberos V5 GSS-API mechanism as described in [5] MUST be implemented with the RPCSEC_GSS services as specified in the following table:",
      "ja": "ケルベロスV5 GSS-APIメカニズムで説明したように、次の表に指定されるように[5] RPCSEC_GSSサービスを実装しなければなりません。"
    },
    {
      "indent": 6,
      "text": "column descriptions: 1 == number of pseudo flavor 2 == name of pseudo flavor 3 == mechanism's OID 4 == RPCSEC_GSS service 5 == NFSv4.1 clients MUST support 6 == NFSv4.1 servers MUST support",
      "ja": "列の説明：擬似風味の疑似風味の1つの==数2 ==名3 ==メカニズムのOID 4 == RPCSEC_GSSサービス5つの== NFSv4.1のクライアントが6台の== NFSv4.1サーバをサポートしなければならないがサポートしなければなりません"
    },
    {
      "indent": 6,
      "text": "1      2        3                    4                     5   6\n------------------------------------------------------------------\n390003 krb5     1.2.840.113554.1.2.2 rpc_gss_svc_none      yes yes\n390004 krb5i    1.2.840.113554.1.2.2 rpc_gss_svc_integrity yes yes\n390005 krb5p    1.2.840.113554.1.2.2 rpc_gss_svc_privacy    no yes",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that the number and name of the pseudo flavor are presented here as a mapping aid to the implementor. Because the NFSv4.1 protocol includes a method to negotiate security and it understands the GSS-API mechanism, the pseudo flavor is not needed. The pseudo flavor is needed for the NFSv3 since the security negotiation is done via the MOUNT protocol as described in [33].",
      "ja": "疑似風味の番号と名前が実装へのマッピングの補助として、ここで提示されていることに注意してください。 NFSv4.1プロトコルはセキュリティを交渉する方法を含み、それはGSS-APIメカニズムを理解しているので、疑似風味は必要ありません。 [33]に記載されているようにセキュリティネゴシエーションは、MOUNTプロトコルを介して行われるので、疑似風味はNFSv3のために必要とされます。"
    },
    {
      "indent": 3,
      "text": "At the time NFSv4.1 was specified, the Advanced Encryption Standard (AES) with HMAC-SHA1 was a REQUIRED algorithm set for Kerberos V5. In contrast, when NFSv4.0 was specified, weaker algorithm sets were REQUIRED for Kerberos V5, and were REQUIRED in the NFSv4.0 specification, because the Kerberos V5 specification at the time did not specify stronger algorithms. The NFSv4.1 specification does not specify REQUIRED algorithms for Kerberos V5, and instead, the implementor is expected to track the evolution of the Kerberos V5 standard if and when stronger algorithms are specified.",
      "ja": "NFSv4.1は、指定された時点では、HMAC-SHA1でのAdvanced Encryption Standard（AES）はケルベロスV5に設定されたREQUIREDアルゴリズムがしました。時ケルベロスV5仕様は強力なアルゴリズムを指定しなかったので、NFSv4.0を指定した場合は対照的に、より弱いアルゴリズムセットはケルベロスV5のために必要であった、そしてNFSv4.0仕様で必要でした。 NFSv4.1仕様は、Kerberos V5に必要なアルゴリズムを指定していない、その代わり、実装者は、強力なアルゴリズムが指定されている場合場合とKerberos V5の標準の進化を追跡することが期待されます。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1.1.2.1.1. Security Considerations for Cryptographic Algorithms in Kerberos V5",
      "ja": "2.2.1.1.1.2.1.1。ケルベロスV5での暗号化アルゴリズムのためのセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "When deploying NFSv4.1, the strength of the security achieved depends on the existing Kerberos V5 infrastructure. The algorithms of Kerberos V5 are not directly exposed to or selectable by the client or server, so there is some due diligence required by the user of NFSv4.1 to ensure that security is acceptable where needed.",
      "ja": "NFSv4.1を展開する場合、達成セキュリティの強さは、既存のKerberos V5インフラストラクチャに依存します。ケルベロスV5のアルゴリズムは、直接にさらされたり、クライアントまたはサーバによって選択されないので、必要な場合、セキュリティが受け入れ可能であることを確認するためにNFSv4.1のユーザが必要とするいくつかのデューデリジェンスがあります。"
    },
    {
      "indent": 0,
      "text": "2.2.1.1.1.3. GSS Server Principal",
      "section_title": true,
      "ja": "2.2.1.1.1.3。 GSSサーバーのプリンシパル"
    },
    {
      "indent": 3,
      "text": "Regardless of what security mechanism under RPCSEC_GSS is being used, the NFS server MUST identify itself in GSS-API via a GSS_C_NT_HOSTBASED_SERVICE name type. GSS_C_NT_HOSTBASED_SERVICE names are of the form:",
      "ja": "かかわらずRPCSEC_GSSの下のセキュリティメカニズムが使用されているものの、NFSサーバはGSS_C_NT_HOSTBASED_SERVICE名のタイプを経由してGSS-API自体を特定しなければなりません。 GSS_C_NT_HOSTBASED_SERVICE名の形式は次のとおりです。"
    },
    {
      "indent": 8,
      "text": "service@hostname",
      "ja": "サービス@ホスト名"
    },
    {
      "indent": 3,
      "text": "For NFS, the \"service\" element is",
      "ja": "NFSの場合は、「サービス」の要素があります"
    },
    {
      "indent": 8,
      "text": "nfs",
      "ja": "同じ"
    },
    {
      "indent": 3,
      "text": "Implementations of security mechanisms will convert nfs@hostname to various different forms. For Kerberos V5, the following form is RECOMMENDED:",
      "ja": "セキュリティ・メカニズムの実装は、種々の異なる形態にホスト名@ NFSを変換します。ケルベロスV5の場合は、以下のフォームをお勧めします。"
    },
    {
      "indent": 8,
      "text": "nfs/hostname",
      "ja": "NFS /ホスト名"
    },
    {
      "indent": 0,
      "text": "2.3. COMPOUND and CB_COMPOUND",
      "section_title": true,
      "ja": "2.3.  COMPOUNDとCB_COMPOUND"
    },
    {
      "indent": 3,
      "text": "A significant departure from the versions of the NFS protocol before NFSv4 is the introduction of the COMPOUND procedure. For the NFSv4 protocol, in all minor versions, there are exactly two RPC procedures, NULL and COMPOUND. The COMPOUND procedure is defined as a series of individual operations and these operations perform the sorts of functions performed by traditional NFS procedures.",
      "ja": "NFSv4の前にNFSプロトコルのバージョンから大幅に逸脱はCOMPOUND手順の紹介です。 NFSv4のプロトコルでは、すべてのマイナーバージョンでは、2つのRPCの手続き、NULLとCOMPOUNDはまさにそこにあります。 COMPOUND手順は、個々の一連の動作として定義され、これらの動作は、従来のNFS手順によって実行される機能のソートを行います。"
    },
    {
      "indent": 3,
      "text": "The operations combined within a COMPOUND request are evaluated in order by the server, without any atomicity guarantees. A limited set of facilities exist to pass results from one operation to another. Once an operation returns a failing result, the evaluation ends and the results of all evaluated operations are returned to the client.",
      "ja": "複合要求内で組み合わせる操作は、任意の原子性を保証することなく、サーバの順に評価されます。施設の限られたセットは、別の操作からの結果を渡すために存在します。操作が失敗し、結果を返した後、評価が終了し、全ての評価の操作の結果がクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "With the use of the COMPOUND procedure, the client is able to build simple or complex requests. These COMPOUND requests allow for a reduction in the number of RPCs needed for logical file system operations. For example, multi-component look up requests can be constructed by combining multiple LOOKUP operations. Those can be further combined with operations such as GETATTR, READDIR, or OPEN plus READ to do more complicated sets of operation without incurring additional latency.",
      "ja": "COMPOUND手順を使用すると、クライアントは、単純または複雑な要求を構築することができます。これらの化合物の要求は、論理ファイルシステム操作のために必要なRPCの数の減少を可能とします。例えば、マルチコンポーネントルックアップ要求は、複数のルックアップ動作を組み合わせることによって構築することができます。これらは、さらに追加の遅延を招くことなく動作のより複雑なセットを行うには、このようなGETATTR、READDIR、またはOPENプラスREADなどの操作と組み合わせることができます。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 also contains a considerable set of callback operations in which the server makes an RPC directed at the client. Callback RPCs have a similar structure to that of the normal server requests. In all minor versions of the NFSv4 protocol, there are two callback RPC procedures: CB_NULL and CB_COMPOUND. The CB_COMPOUND procedure is defined in an analogous fashion to that of COMPOUND with its own set of callback operations.",
      "ja": "NFSv4.1は、サーバーがクライアントに向けRPCを行っているコールバック操作のかなりのセットが含まれています。コールバックRPCは、通常のサーバー要求と同様の構造を有しています。 CB_NULLとCB_COMPOUND：NFSv4のプロトコルのすべてのマイナーバージョンでは、2つのコールバックRPCの手順があります。 CB_COMPOUND手順は、コールバックオペレーションの独自のセットを有する化合物のものと類似の方法で定義されています。"
    },
    {
      "indent": 3,
      "text": "The addition of new server and callback operations within the COMPOUND and CB_COMPOUND request framework provides a means of extending the protocol in subsequent minor versions.",
      "ja": "COMPOUNDとCB_COMPOUND要求フレームワーク内で、新しいサーバー、コールバックオペレーションの添加は、後続のマイナーバージョンのプロトコルを拡張する手段を提供します。"
    },
    {
      "indent": 3,
      "text": "Except for a small number of operations needed for session creation, server requests and callback requests are performed within the context of a session. Sessions provide a client context for every request and support robust reply protection for non-idempotent requests.",
      "ja": "セッションの作成に必要な操作の数が少ない場合を除き、サーバー要求とコールバック要求は、セッションのコンテキスト内で実行されています。セッションは、すべての要求のためのクライアントコンテキストを提供し、非べき等の要求のための堅牢な返信保護をサポートしています。"
    },
    {
      "indent": 0,
      "text": "2.4. Client Identifiers and Client Owners",
      "section_title": true,
      "ja": "2.4. クライアント識別子およびクライアントの所有者"
    },
    {
      "indent": 3,
      "text": "For each operation that obtains or depends on locking state, the specific client needs to be identifiable by the server.",
      "ja": "取得または状態をロックに依存する操作ごとに、特定のクライアントは、サーバによって識別可能である必要があります。"
    },
    {
      "indent": 3,
      "text": "Each distinct client instance is represented by a client ID. A client ID is a 64-bit identifier representing a specific client at a given time. The client ID is changed whenever the client re-initializes, and may change when the server re-initializes. Client IDs are used to support lock identification and crash recovery.",
      "ja": "各別個のクライアント・インスタンスは、クライアントIDによって表されます。クライアントIDは、所定の時間に特定のクライアントを表す64ビットの識別子です。クライアントIDは、いつでもクライアントの再初期化を変更し、ときに、サーバーの再初期化変更されることがあります。クライアントIDは、ロック識別し、クラッシュリカバリをサポートするために使用されています。"
    },
    {
      "indent": 3,
      "text": "During steady state operation, the client ID associated with each operation is derived from the session (see Section 2.10) on which the operation is sent. A session is associated with a client ID when the session is created.",
      "ja": "定常状態動作中に、各操作に関連付けられたクライアントIDは、操作が送信されたセッション（セクション2.10を参照）から誘導されます。セッションが作成されたときに、セッションは、クライアントIDに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Unlike NFSv4.0, the only NFSv4.1 operations possible before a client ID is established are those needed to establish the client ID.",
      "ja": "NFSv4.0とは異なり、クライアントIDが確​​立される前に可能なだけNFSv4.1操作は、クライアントのIDを確立するのに必要とされるものです。"
    },
    {
      "indent": 3,
      "text": "A sequence of an EXCHANGE_ID operation followed by a CREATE_SESSION operation using that client ID (eir_clientid as returned from EXCHANGE_ID) is required to establish and confirm the client ID on the server. Establishment of identification by a new incarnation of the client also has the effect of immediately releasing any locking state that a previous incarnation of that same client might have had on the server. Such released state would include all byte-range lock, share reservation, layout state, and -- where the server supports neither the CLAIM_DELEGATE_PREV nor CLAIM_DELEG_CUR_FH claim types -- all delegation state associated with the same client with the same identity. For discussion of delegation state recovery, see Section 10.2.1. For discussion of layout state recovery, see Section 12.7.1.",
      "ja": "（EXCHANGE_IDから返されるeir_clientid）そのクライアントIDを使用してCREATE_SESSION操作続いEXCHANGE_ID動作のシーケンスは、サーバ上のクライアントIDを確立し確認する必要があります。クライアントの新しいインカネーションによる識別の確立も、すぐにその同じクライアントの以前の化身がサーバー上で持っていたかもしれない任意のロック状態を解除する効果があります。サーバがCLAIM_DELEGATE_PREVもCLAIM_DELEG_CUR_FHの主張でもないタイプをサポートしています -   - 同じIDを持つ同じクライアントに関連するすべての委任状態このような解放状態では、すべてのバイト範囲ロック、共有予約、レイアウトの状態などがあります。委任状態の回復の議論については、10.2.1項を参照してください。レイアウトの状態の回復の議論については、12.7.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Releasing such state requires that the server be able to determine that one client instance is the successor of another. Where this cannot be done, for any of a number of reasons, the locking state will remain for a time subject to lease expiration (see Section 8.3) and the new client will need to wait for such state to be removed, if it makes conflicting lock requests.",
      "ja": "そのような状態を解放すると、サーバが一つのクライアント・インスタンスが他の後継者であることを決定することができることを必要とします。これは多くの理由のいずれかのために、行うことができない場合は、ロック状態は、有効期限のリースを受ける時間のために残ります（8.3節を参照）、それが競合になる場合は、新しいクライアントが、削除されるような状態を待つ必要があります。ロック要求。"
    },
    {
      "indent": 3,
      "text": "Client identification is encapsulated in the following client owner\ndata type: struct client_owner4 {\n        verifier4       co_verifier;\n        opaque          co_ownerid<NFS4_OPAQUE_LIMIT>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first field, co_verifier, is a client incarnation verifier. The server will start the process of canceling the client's leased state if co_verifier is different than what the server has previously recorded for the identified client (as specified in the co_ownerid field).",
      "ja": "最初のフィールドは、co_verifier、クライアントの化身の検証です。 co_verifierは（co_owneridフィールドに指定されている）サーバが以前に同定されたクライアントのために記録したものと異なる場合、サーバーはクライアントのリース状態を解除する処理を開始します。"
    },
    {
      "indent": 3,
      "text": "The second field, co_ownerid, is a variable length string that uniquely defines the client so that subsequent instances of the same client bear the same co_ownerid with a different verifier.",
      "ja": "第2のフィールド、co_owneridは、同じクライアントの後続のインスタンスが異なるベリファイアと同じco_owneridを負担するようにクライアントを一意に定義する可変長の文字列です。"
    },
    {
      "indent": 3,
      "text": "There are several considerations for how the client generates the co_ownerid string:",
      "ja": "クライアントがco_ownerid文字列を生成する方法にはいくつかの考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "o The string should be unique so that multiple clients do not present the same string. The consequences of two clients presenting the same string range from one client getting an error to one client having its leased state abruptly and unexpectedly cancelled.",
      "ja": "複数のクライアントが同じ文字列を提示しないように、文字列が一意である必要がありますoを。 1つのクライアントにエラーを取得して1つのクライアントから同じ文字列の範囲を提示する2つのクライアントの結果は、そのリース状態が突然と予期せずにキャンセルされました。"
    },
    {
      "indent": 3,
      "text": "o The string should be selected so that subsequent incarnations (e.g., restarts) of the same client cause the client to present the same string. The implementor is cautioned from an approach that requires the string to be recorded in a local file because this precludes the use of the implementation in an environment where there is no local disk and all file access is from an NFSv4.1 server.",
      "ja": "O文字列は、同じクライアントの後続の化身（例えば、再起動）は、クライアントが同じ文字列を提示させるように選択されるべきです。実装者は、これはローカルディスクがない環境での実装の使用を排除し、すべてのファイルアクセスは、NFSv4.1サーバーからあるので、ローカルファイルに記録される文字列を必要としたアプローチから警告されます。"
    },
    {
      "indent": 3,
      "text": "o The string should be the same for each server network address that the client accesses. This way, if a server has multiple interfaces, the client can trunk traffic over multiple network paths as described in Section 2.10.5. (Note: the precise opposite was advised in the NFSv4.0 specification [30].)",
      "ja": "Oの文字列は、クライアントがアクセスする各サーバーのネットワーク・アドレスで同じである必要があります。サーバが複数のインタフェースを持っている場合は、セクション2.10.5で説明したように、この方法では、クライアントが複数のネットワーク・パス上のトラフィックをトランクすることができます。 （注：正確な反対がNFSv4.0仕様に助言された[30]。）"
    },
    {
      "indent": 3,
      "text": "o The algorithm for generating the string should not assume that the client's network address will not change, unless the client implementation knows it is using statically assigned network addresses. This includes changes between client incarnations and even changes while the client is still running in its current incarnation. Thus, with dynamic address assignment, if the client includes just the client's network address in the co_ownerid string, there is a real risk that after the client gives up the network address, another client, using a similar algorithm for generating the co_ownerid string, would generate a conflicting co_ownerid string.",
      "ja": "クライアントの実装は、それが静的に割り当てられたネットワークアドレスを使用している知っている場合を除きoを、文字列を生成するためのアルゴリズムは、クライアントのネットワークアドレスが変更されないことを仮定するべきではありません。クライアントが現在の化身で実行されている間、これは、クライアントの化身とでも変化と変更が含まれています。したがって、クライアントがco_ownerid文字列の中だけで、クライアントのネットワークアドレスが含まれている場合、動的なアドレス割り当てと、クライアントはネットワークアドレスを放棄した後という現実的なリスクがあり、別のクライアント、co_ownerid文字列を生成するための同様のアルゴリズムを考え使用して競合co_ownerid文字列を生成します。"
    },
    {
      "indent": 3,
      "text": "Given the above considerations, an example of a well-generated co_ownerid string is one that includes:",
      "ja": "上記の考察を考慮すると、よく発生co_ownerid文字列の例は、1つです。"
    },
    {
      "indent": 3,
      "text": "o If applicable, the client's statically assigned network address.",
      "ja": "O該当する場合は、クライアントの静的に割り当てられたネットワークアドレス。"
    },
    {
      "indent": 3,
      "text": "o Additional information that tends to be unique, such as one or more of:",
      "ja": "このようの一つ以上のように、ユニークになりがちO追加情報："
    },
    {
      "indent": 6,
      "text": "* The client machine's serial number (for privacy reasons, it is best to perform some one-way function on the serial number).",
      "ja": "*クライアント・マシンのシリアル番号（プライバシー上の理由から、それはシリアル番号にいくつかの一方向関数を実行するのが最善です）。"
    },
    {
      "indent": 6,
      "text": "* A Media Access Control (MAC) address (again, a one-way function should be performed).",
      "ja": "*メディアアクセス制御（MAC）アドレス（再び、一方向関数を実行する必要があります）。"
    },
    {
      "indent": 6,
      "text": "* The timestamp of when the NFSv4.1 software was first installed on the client (though this is subject to the previously mentioned caution about using information that is stored in a file, because the file might only be accessible over NFSv4.1).",
      "ja": "*（ファイルのみNFSv4.1経由でアクセス可能であるかもしれないので、これはファイルに格納された情報を、使用について前述の注意の対象となるが）NFSv4.1ソフトウェアが最初のクライアントにインストールしたときのタイムスタンプ。"
    },
    {
      "indent": 6,
      "text": "* A true random number. However, since this number ought to be the same between client incarnations, this shares the same problem as that of using the timestamp of the software installation.",
      "ja": "*真の乱数。しかし、この数は、クライアント・インカネーションの間で同じであるべきことから、これは、ソフトウェアのインストールのタイムスタンプを使用してのものと同じ問題を共有しています。"
    },
    {
      "indent": 3,
      "text": "o For a user-level NFSv4.1 client, it should contain additional information to distinguish the client from other user-level clients running on the same host, such as a process identifier or other unique sequence.",
      "ja": "OユーザーレベルNFSv4.1のクライアントのために、そのようなプロセス識別子または他のユニーク配列と同じホスト上で動作している他のユーザーレベルのクライアントからクライアントを区別するために付加的な情報を含むべきです。"
    },
    {
      "indent": 3,
      "text": "The client ID is assigned by the server (the eir_clientid result from EXCHANGE_ID) and should be chosen so that it will not conflict with a client ID previously assigned by the server. This applies across server restarts.",
      "ja": "クライアントIDは、サーバ（EXCHANGE_IDからeir_clientid結果）によって割り当てられ、それが以前にサーバによって割り当てられたクライアントIDと競合しないように選択されるべきです。これは、サーバーを再起動して適用されます。"
    },
    {
      "indent": 3,
      "text": "In the event of a server restart, a client may find out that its current client ID is no longer valid when it receives an NFS4ERR_STALE_CLIENTID error. The precise circumstances depend on the characteristics of the sessions involved, specifically whether the session is persistent (see Section 2.10.6.5), but in each case the client will receive this error when it attempts to establish a new session with the existing client ID and receives the error NFS4ERR_STALE_CLIENTID, indicating that a new client ID needs to be obtained via EXCHANGE_ID and the new session established with that client ID.",
      "ja": "サーバーの再起動が発生した場合、クライアントは、それがNFS4ERR_STALE_CLIENTIDエラーを受信したときにその現在のクライアントIDは、もはや有効ではないことを見つけることがあります。正確な状況は、（セクション2.10.6.5を参照）セッションが永続的で、具体的かどうか、関係するセッションの特性に依存するが、それは、既存のクライアントIDを使用して新しいセッションを確立しようとしたとき、それぞれの場合に、クライアントはこのエラーを受け取ることになりますし、新しいクライアントIDがEXCHANGE_IDとそのクライアントのIDを確立し、新しいセッションを介して取得する必要があることを示す、エラーNFS4ERR_STALE_CLIENTIDを受けます。"
    },
    {
      "indent": 3,
      "text": "When a session is not persistent, the client will find out that it needs to create a new session as a result of getting an NFS4ERR_BADSESSION, since the session in question was lost as part of a server restart. When the existing client ID is presented to a server as part of creating a session and that client ID is not recognized, as would happen after a server restart, the server will reject the request with the error NFS4ERR_STALE_CLIENTID.",
      "ja": "セッションが永続的でない場合は、クライアントは、それが問題のセッションがサーバの再起動の一環として失われたため、NFS4ERR_BADSESSIONを得ることの結果として、新しいセッションを作成する必要があることがわかります。既存のクライアントIDは、セッション作成の一部としてサーバーに提示され、そのクライアントのIDは、サーバの再起動後に起こるように、認識されない場合は、サーバがエラーNFS4ERR_STALE_CLIENTIDで要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "In the case of the session being persistent, the client will re-establish communication using the existing session after the restart. This session will be associated with the existing client ID but may only be used to retransmit operations that the client previously transmitted and did not see replies to. Replies to operations that the server previously performed will come from the reply cache; otherwise, NFS4ERR_DEADSESSION will be returned. Hence, such a session is referred to as \"dead\". In this situation, in order to perform new operations, the client needs to establish a new session. If an attempt is made to establish this new session with the existing client ID, the server will reject the request with NFS4ERR_STALE_CLIENTID.",
      "ja": "永続中のセッションの場合、クライアントは、再起動後に既存のセッションを使用して通信を再確立します。このセッションでは、既存のクライアントIDに関連付けされますが、唯一のクライアントが以前に送信され、への返信を見ていないという操作を再送信するために使用することができます。以前に実行したサーバーが応答キャッシュから来るという操作に返信。そうでない場合は、NFS4ERR_DEADSESSIONが返されます。したがって、そのようなセッションは「死んだ」とも呼ばれます。このような状況では、新しい操作を実行するために、クライアントは新しいセッションを確立する必要があります。試みが既存のクライアントIDを持つこの新しいセッションを確立するためになされた場合、サーバはNFS4ERR_STALE_CLIENTIDで要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "When NFS4ERR_STALE_CLIENTID is received in either of these situations, the client needs to obtain a new client ID by use of the EXCHANGE_ID operation, then use that client ID as the basis of a new session, and then proceed to any other necessary recovery for the server restart case (see Section 8.4.2).",
      "ja": "NFS4ERR_STALE_CLIENTIDは、これらの状況のいずれかで受信されると、クライアントはEXCHANGE_ID操作を使用して新しいクライアントIDを取得する必要があり、その後、新しいセッションの基本として、そのクライアントのIDを使用して、サーバーの任意の他の必要な回復に進みます再起動の場合（セクション8.4.2を参照してください）。"
    },
    {
      "indent": 3,
      "text": "See the descriptions of EXCHANGE_ID (Section 18.35) and CREATE_SESSION (Section 18.36) for a complete specification of these operations.",
      "ja": "これらの操作の完全な仕様のためEXCHANGE_ID（セクション18.35）とCREATE_SESSION（セクション18.36）の説明を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.4.1. Upgrade from NFSv4.0 to NFSv4.1",
      "section_title": true,
      "ja": "2.4.1.  NFSv4.0からNFSv4.1にアップグレード"
    },
    {
      "indent": 3,
      "text": "To facilitate upgrade from NFSv4.0 to NFSv4.1, a server may compare a value of data type client_owner4 in an EXCHANGE_ID with a value of data type nfs_client_id4 that was established using the SETCLIENTID operation of NFSv4.0. A server that does so will allow an upgraded client to avoid waiting until the lease (i.e., the lease established by the NFSv4.0 instance client) expires. This requires that the value of data type client_owner4 be constructed the same way as the value of data type nfs_client_id4. If the latter's contents included the server's network address (per the recommendations of the NFSv4.0 specification [30]), and the NFSv4.1 client does not wish to use a client ID that prevents trunking, it should send two EXCHANGE_ID operations. The first EXCHANGE_ID will have a client_owner4 equal to the nfs_client_id4. This will clear the state created by the NFSv4.0 client. The second EXCHANGE_ID will not have the server's network address. The state created for the second EXCHANGE_ID will not have to wait for lease expiration, because there will be no state to expire.",
      "ja": "NFSv4.1へNFSv4.0からのアップグレードを容易にするために、サーバは、NFSv4.0のSETCLIENTID操作を使用して確立されたデータ型nfs_client_id4の値とEXCHANGE_IDにデータ型client_owner4の値を比較することができます。そうするサーバーは、アップグレードされたクライアントがリース（NFSv4.0インスタンスクライアントによって確立された、すなわち、リース）が期限切れになるまで待って避けることができます。これは、データ型client_owner4の値はデータ型nfs_client_id4の値と同じように構成されることを必要とします。後者の内容は、サーバのネットワークアドレスが含まれている場合（[30] NFSv4.0仕様の勧告あたり）、およびNFSv4.1のクライアントがトランキングを防止し、クライアントのIDを使用したくない、それは2つのEXCHANGE_ID操作を送信する必要があります。最初EXCHANGE_IDはnfs_client_id4に等しいclient_owner4を持つことになります。これは、NFSv4.0クライアントによって作成された状態がクリアされます。二EXCHANGE_IDは、サーバのネットワークアドレスを持っていません。期限切れに何の状態が生じないため、2番目のEXCHANGE_ID用に作成された状態では、リース満了を待つ必要はありません。"
    },
    {
      "indent": 0,
      "text": "2.4.2. Server Release of Client ID",
      "section_title": true,
      "ja": "2.4.2. クライアントIDのサーバ・リリース"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 introduces a new operation called DESTROY_CLIENTID (Section 18.50), which the client SHOULD use to destroy a client ID it no longer needs. This permits graceful, bilateral release of a client ID. The operation cannot be used if there are sessions associated with the client ID, or state with an unexpired lease.",
      "ja": "NFSv4.1は、クライアントが、それはもはや必要とするクライアントのIDを破壊するために使用すべきであるDESTROY_CLIENTID（セクション18.50）と呼ばれる新しい操作を、紹介します。これは、クライアントIDの優雅な、二国間の放出を可能にします。期限が切れていないリースを持つクライアントID、または状態に関連したセッションがある場合、操作は使用できません。"
    },
    {
      "indent": 3,
      "text": "If the server determines that the client holds no associated state for its client ID (associated state includes unrevoked sessions, opens, locks, delegations, layouts, and wants), the server MAY choose to unilaterally release the client ID in order to conserve resources. If the client contacts the server after this release, the server MUST ensure that the client receives the appropriate error so that it will use the EXCHANGE_ID/CREATE_SESSION sequence to establish a new client ID. The server ought to be very hesitant to release a client ID since the resulting work on the client to recover from such an event will be the same burden as if the server had failed and restarted. Typically, a server would not release a client ID unless there had been no activity from that client for many minutes. As long as there are sessions, opens, locks, delegations, layouts, or wants, the server MUST NOT release the client ID. See Section 2.10.13.1.4 for discussion on releasing inactive sessions.",
      "ja": "サーバが（関連する状態は、UNREVOKEDセッションが含ま開き、ロック、代表団、レイアウト、および望んでいる）クライアントは、そのクライアントIDのために何の関連する状態を保持していないと判断した場合、サーバが一方的にリソースを節約するために、クライアントのIDを解放するために選ぶかもしれません。クライアントは、このリリースの後にサーバー場合、サーバは新しいクライアントIDを確立するEXCHANGE_ID / CREATE_SESSIONシーケンスを使用するようにクライアントに適切なエラーを受け取ることを保証しなければなりません。サーバは、サーバに障害が発生して再起動したかのようなイベントから回復するには、クライアント上の結果の作業は同じ負担になりますので、クライアントのIDを解放するために非常に躊躇であるべき。多く分間そのクライアントからの活動がなかった場合を除き一般的に、サーバはクライアントのIDを解放しないでしょう。限りのセッションがあるので、開く、ロック、代表団、レイアウト、または望んでいる、サーバーは、クライアントのIDを解放してはなりません。非アクティブなセッションを解放に関する議論については、セクション2.10.13.1.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.4.3. Resolving Client Owner Conflicts",
      "section_title": true,
      "ja": "2.4.3. クライアント所有の競合の解決"
    },
    {
      "indent": 3,
      "text": "When the server gets an EXCHANGE_ID for a client owner that currently has no state, or that has state but the lease has expired, the server MUST allow the EXCHANGE_ID and confirm the new client ID if followed by the appropriate CREATE_SESSION.",
      "ja": "サーバーには現在の状態を持っていないクライアント所有者のためのEXCHANGE_IDを取得、またはその状態を持っていますが、リースが期限切れになった場合は、サーバーはEXCHANGE_IDを許容しなければなりませんし、適切なCREATE_SESSIONが続く場合は、新しいクライアントIDを確認します。"
    },
    {
      "indent": 3,
      "text": "When the server gets an EXCHANGE_ID for a new incarnation of a client owner that currently has an old incarnation with state and an unexpired lease, the server is allowed to dispose of the state of the previous incarnation of the client owner if one of the following is true:",
      "ja": "サーバーが現在の状態と古い化身と期限が切れていないリースを持つクライアントの所有者の新しい化身のためEXCHANGE_IDを取得すると、次のいずれかがある場合、サーバはクライアントの所有者の前の化身の状態を処分することが許可されています真："
    },
    {
      "indent": 3,
      "text": "o The principal that created the client ID for the client owner is the same as the principal that is sending the EXCHANGE_ID operation. Note that if the client ID was created with SP4_MACH_CRED state protection (Section 18.35), the principal MUST be based on RPCSEC_GSS authentication, the RPCSEC_GSS service used",
      "ja": "Oクライアント所有者のクライアントIDを作成した主体はEXCHANGE_ID動作を送信している主と同じです。クライアントIDがSP4_MACH_CRED状態の保護（セクション18.35）で作成された場合、校長はRPCSEC_GSS認証に基づいていなければならないことに注意してください、RPCSEC_GSSサービスが使用します"
    },
    {
      "indent": 6,
      "text": "MUST be integrity or privacy, and the same GSS mechanism and principal MUST be used as that used when the client ID was created.",
      "ja": "クライアントIDが作成されたときにそれが使用されるような整合性やプライバシー、同じGSSメカニズムと元本を使用しなければなりませんしなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The client ID was established with SP4_SSV protection (Section 18.35, Section 2.10.8.3) and the client sends the EXCHANGE_ID with the security flavor set to RPCSEC_GSS using the GSS SSV mechanism (Section 2.10.9).",
      "ja": "クライアントID oをSP4_SSV保護（第18.35節2.10.8.3）で設立され、クライアントはGSS SSVメカニズム（セクション2.10.9）を使用してRPCSEC_GSSするために設定されたセキュリティ風味とEXCHANGE_IDを送信します。"
    },
    {
      "indent": 3,
      "text": "o The client ID was established with SP4_SSV protection, and under the conditions described herein, the EXCHANGE_ID was sent with SP4_MACH_CRED state protection. Because the SSV might not persist across client and server restart, and because the first time a client sends EXCHANGE_ID to a server it does not have an SSV, the client MAY send the subsequent EXCHANGE_ID without an SSV RPCSEC_GSS handle. Instead, as with SP4_MACH_CRED protection, the principal MUST be based on RPCSEC_GSS authentication, the RPCSEC_GSS service used MUST be integrity or privacy, and the same GSS mechanism and principal MUST be used as that used when the client ID was created.",
      "ja": "OクライアントIDはSP4_SSV保護で設立された、本明細書に記載の条件の下で、EXCHANGE_IDはSP4_MACH_CREDステート保護を送られました。 SSVは、クライアントとサーバの再起動間で保持されない場合があります、初めてので、クライアントはそれがSSVを持っていないサーバにEXCHANGE_IDを送信するので、クライアントは、SSV RPCSEC_GSSハンドルずに次のEXCHANGE_IDを送信することができます。 SP4_MACH_CRED保護と同様に、プリンシパルはRPCSEC_GSS認証に基づいていなければならない代わりに、使用RPCSEC_GSSサービスは、整合性やプライバシー、同じGSSメカニズムと元本でなければならないクライアントIDが作成されたときにそれが使用されるように使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If none of the above situations apply, the server MUST return NFS4ERR_CLID_INUSE.",
      "ja": "上記の状況のいずれにも該当しない場合は、サーバーはNFS4ERR_CLID_INUSEを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the server accepts the principal and co_ownerid as matching that which created the client ID, and the co_verifier in the EXCHANGE_ID differs from the co_verifier used when the client ID was created, then after the server receives a CREATE_SESSION that confirms the client ID, the server deletes state. If the co_verifier values are the same (e.g., the client either is updating properties of the client ID (Section 18.35) or is attempting trunking (Section 2.10.5), the server MUST NOT delete state.",
      "ja": "サーバは、クライアントIDを作成したことと一致するとして主とco_owneridを受け入れる場合、およびEXCHANGE_IDでco_verifierは、クライアントIDが作成されたときに使用co_verifier異なって、サーバはクライアントのIDを確認CREATE_SESSIONを受信した後、サーバー状態を削除します。 co_verifier値が同じである場合（例えば、クライアントはどちらか（セクション18.35）クライアントIDのプロパティを更新しているか、トランキング（セクション2.10.5）は、サーバが状態を削除しないようにしてくださいしようとしています。"
    },
    {
      "indent": 0,
      "text": "2.5. Server Owners",
      "section_title": true,
      "ja": "2.5. サーバーの所有者"
    },
    {
      "indent": 3,
      "text": "The server owner is similar to a client owner (Section 2.4), but unlike the client owner, there is no shorthand server ID. The server owner is defined in the following data type:",
      "ja": "サーバーの所有者は、クライアント所有者（2.4節）と似ていますが、クライアント所有者とは異なり、速記サーバIDはありません。サーバーの所有者は、次のデータ型で定義されます。"
    },
    {
      "indent": 3,
      "text": "struct server_owner4 {\n uint64_t       so_minor_id;\n opaque         so_major_id<NFS4_OPAQUE_LIMIT>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The server owner is returned from EXCHANGE_ID. When the so_major_id fields are the same in two EXCHANGE_ID results, the connections that each EXCHANGE_ID were sent over can be assumed to address the same server (as defined in Section 1.6). If the so_minor_id fields are also the same, then not only do both connections connect to the same server, but the session can be shared across both connections. The reader is cautioned that multiple servers may deliberately or accidentally claim to have the same so_major_id or so_major_id/ so_minor_id; the reader should examine Sections 2.10.5 and 18.35 in order to avoid acting on falsely matching server owner values.",
      "ja": "サーバーの所有者はEXCHANGE_IDから返されます。 so_major_idフィールドは、2つのEXCHANGE_ID結果が同じである場合、各EXCHANGE_IDを介して送信された接続（セクション1.6で定義されるように）同じサーバーに対処すると仮定することができます。 so_minor_idフィールドも同じである場合は、両方の接続は、同じサーバーに接続するのですが、セッションは両方の接続間で共有することができないだけ。リーダは複数のサーバーが故意または偶然同じso_major_id又はso_major_id / so_minor_idを持っていると主張することが警告されます。読者は、誤ってサーバーの所有者値を一致に作用を避けるために、セクション2.10.5および18.35を調べる必要があります。"
    },
    {
      "indent": 3,
      "text": "The considerations for generating a so_major_id are similar to that for generating a co_ownerid string (see Section 2.4). The consequences of two servers generating conflicting so_major_id values are less dire than they are for co_ownerid conflicts because the client can use RPCSEC_GSS to compare the authenticity of each server (see Section 2.10.5).",
      "ja": "so_major_idを生成するための考慮事項は、（セクション2.4を参照）co_ownerid文字列を生成するためのものと同様です。競合so_major_id値を生成する二つのサーバの結果は、クライアントが各サーバーの信憑性を比較するために、RPCSEC_GSSを使用することができますので、彼らはco_ownerid競合のためのものよりも悲惨です（2.10.5項を参照してください）。"
    },
    {
      "indent": 0,
      "text": "2.6. Security Service Negotiation",
      "section_title": true,
      "ja": "2.6. セキュリティサービスの交渉"
    },
    {
      "indent": 3,
      "text": "With the NFSv4.1 server potentially offering multiple security mechanisms, the client needs a method to determine or negotiate which mechanism is to be used for its communication with the server. The NFS server may have multiple points within its file system namespace that are available for use by NFS clients. These points can be considered security policy boundaries, and, in some NFS implementations, are tied to NFS export points. In turn, the NFS server may be configured such that each of these security policy boundaries may have different or multiple security mechanisms in use.",
      "ja": "NFSv4.1サーバは、潜在的に複数のセキュリティメカニズムを提供して、クライアントは、サーバとの通信に使用すべきメカニズム決定または交渉する方法を必要とします。 NFSサーバは、NFSクライアントで使用するために用意されていて、ファイルシステムの名前空間内の複数のポイントを有することができます。これらの点は、いくつかのNFSの実装では、NFSエクスポート・ポイントに関連付けられている、セキュリティポリシーの境界と考えられ、およびすることができます。次に、NFSサーバは、これらのセキュリティポリシーの境界のそれぞれは、使用中の異なるまたは複数のセキュリティメカニズムを有することができるように構成されてもよいです。"
    },
    {
      "indent": 3,
      "text": "The security negotiation between client and server SHOULD be done with a secure channel to eliminate the possibility of a third party intercepting the negotiation sequence and forcing the client and server to choose a lower level of security than required or desired. See Section 21 for further discussion.",
      "ja": "クライアントとサーバ間のセキュリティネゴシエーションは、交渉のシーケンスを傍受し、必要または所望されるよりもセキュリティの低いレベルを選択し、クライアントとサーバーを強制的に第三者の可能性を排除するために安全なチャネルで行われるべきです。さらなる議論については、セクション21を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.6.1. NFSv4.1 Security Tuples",
      "section_title": true,
      "ja": "2.6.1.  NFSv4.1セキュリティタプル"
    },
    {
      "indent": 3,
      "text": "An NFS server can assign one or more \"security tuples\" to each security policy boundary in its namespace. Each security tuple consists of a security flavor (see Section 2.2.1.1) and, if the flavor is RPCSEC_GSS, a GSS-API mechanism Object Identifier (OID), a GSS-API quality of protection, and an RPCSEC_GSS service.",
      "ja": "NFSサーバは、その名前空間内の各セキュリティポリシーの境界に1つ以上の「セキュリティタプル」を割り当てることができます。味はRPCSEC_GSS、GSS-APIメカニズムのオブジェクト識別子（OID）、保護のGSS-APIの品質、およびRPCSEC_GSSサービスである場合は各セキュリティタプルは、セキュリティ風味で構成されています（セクション2.2.1.1を参照します）。"
    },
    {
      "indent": 0,
      "text": "2.6.2. SECINFO and SECINFO_NO_NAME",
      "section_title": true,
      "ja": "2.6.2.  SECINFOとSECINFO_NO_NAME"
    },
    {
      "indent": 3,
      "text": "The SECINFO and SECINFO_NO_NAME operations allow the client to determine, on a per-filehandle basis, what security tuple is to be used for server access. In general, the client will not have to use either operation except during initial communication with the server or when the client crosses security policy boundaries at the server.",
      "ja": "SECINFOとSECINFO_NO_NAME操作は、セキュリティのタプルは、サーバーへのアクセスに使用するものを、あたりのファイルハンドルに基づき、クライアントが決定することができます。一般的には、クライアントは、サーバー場合、またはクライアントがサーバにセキュリティポリシーの境界を横切るとの初期通信中以外のいずれかの操作を使用する必要はありません。"
    },
    {
      "indent": 3,
      "text": "However, the server's policies may also change at any time and force the client to negotiate a new security tuple.",
      "ja": "しかし、サーバのポリシーはいつでも変更し、新しいセキュリティタプルを交渉するクライアントを強制することがあります。"
    },
    {
      "indent": 3,
      "text": "Where the use of different security tuples would affect the type of access that would be allowed if a request was sent over the same connection used for the SECINFO or SECINFO_NO_NAME operation (e.g., read-only vs. read-write) access, security tuples that allow greater access should be presented first. Where the general level of access is the same and different security flavors limit the range of principals whose privileges are recognized (e.g., allowing or disallowing root access), flavors supporting the greatest range of principals should be listed first.",
      "ja": "異なるセキュリティタプルの使用は、要求がSECINFOまたはSECINFO_NO_NAME操作のために使用されるのと同じ接続を介して送信された場合に許されるアクセスの種類に影響を与える場合は（例えば、読み取り専用、読み書き対）アクセス、セキュリティタプルことより大きなアクセスが最初に提示されなければならないことができます。アクセスの一般的なレベルは同じと異なるセキュリティ風味が特権認識されている（例えば、ルートアクセスを許可または禁止）、プリンシパルの最大範囲を支持風味が最初にリストされるべきであるプリンシパルの範囲を限定するものです。"
    },
    {
      "indent": 0,
      "text": "2.6.3. Security Error",
      "section_title": true,
      "ja": "2.6.3. セキュリティエラー"
    },
    {
      "indent": 3,
      "text": "Based on the assumption that each NFSv4.1 client and server MUST support a minimum set of security (i.e., Kerberos V5 under RPCSEC_GSS), the NFS client will initiate file access to the server with one of the minimal security tuples. During communication with the server, the client may receive an NFS error of NFS4ERR_WRONGSEC. This error allows the server to notify the client that the security tuple currently being used contravenes the server's security policy. The client is then responsible for determining (see Section 2.6.3.1) what security tuples are available at the server and choosing one that is appropriate for the client.",
      "ja": "各NFSv4.1クライアントとサーバが、セキュリティの最小セットをサポートしなければならないという仮定に基づいて（すなわち、RPCSEC_GSS下ケルベロスV5）は、NFSクライアントは、最小限のセキュリティタプルの1つとサーバへのファイルアクセスを開始します。サーバーとの通信中に、クライアントはNFS4ERR_WRONGSECのNFSエラーが発生することがあります。このエラーは、サーバーが現在使用しているセキュリティタプルは、サーバーのセキュリティポリシーに反することをクライアントに通知することができます。クライアントは、サーバで使用可能なセキュリティタプル（セクション2.6.3.1を参照）を決定し、クライアントに適切なものを選択するために、その後責任があります。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1. Using NFS4ERR_WRONGSEC, SECINFO, and SECINFO_NO_NAME",
      "section_title": true,
      "ja": "2.6.3.1。 NFS4ERR_WRONGSEC、SECINFO、およびSECINFO_NO_NAMEを使用して"
    },
    {
      "indent": 3,
      "text": "This section explains the mechanics of NFSv4.1 security negotiation.",
      "ja": "このセクションでは、NFSv4.1のセキュリティネゴシエーションの仕組みを説明しています。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1. Put Filehandle Operations",
      "section_title": true,
      "ja": "2.6.3.1.1。ファイルハンドル操作を入れて"
    },
    {
      "indent": 3,
      "text": "The term \"put filehandle operation\" refers to PUTROOTFH, PUTPUBFH, PUTFH, and RESTOREFH. Each of the subsections herein describes how the server handles a subseries of operations that starts with a put filehandle operation.",
      "ja": "用語は、「ファイルハンドル操作を置く」PUTROOTFH、PUTPUBFH、PUTFH、およびRESTOREFHを指します。サブセクションのそれぞれは、ここで、サーバが置かファイルハンドル操作で始まる操作のサブシリーズをどのように処理するかについて説明します。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.1. Put Filehandle Operation + SAVEFH",
      "section_title": true,
      "ja": "2.6.3.1.1.1。ファイルハンドル操作+ SAVEFHを置きます"
    },
    {
      "indent": 3,
      "text": "The client is saving a filehandle for a future RESTOREFH, LINK, or RENAME. SAVEFH MUST NOT return NFS4ERR_WRONGSEC. To determine whether or not the put filehandle operation returns NFS4ERR_WRONGSEC, the server implementation pretends SAVEFH is not in the series of operations and examines which of the situations described in the other subsections of Section 2.6.3.1.1 apply.",
      "ja": "クライアントは、将来RESTOREFH、LINK、またはRENAMEのためのファイルハンドルを保存しています。 SAVEFHはNFS4ERR_WRONGSECを返してはなりません。プットファイルハンドル操作がNFS4ERR_WRONGSECを返すかどうかを決定するために、サーバ実装はSAVEFHが一連の動作ではなく、適用セクション2.6.3.1.1の他のサブセクションで説明状況のどの検査ふり。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.2. Two or More Put Filehandle Operations",
      "section_title": true,
      "ja": "2.6.3.1.1.2。二つ以上のファイルハンドル操作を入れて"
    },
    {
      "indent": 3,
      "text": "For a series of N put filehandle operations, the server MUST NOT return NFS4ERR_WRONGSEC to the first N-1 put filehandle operations. The Nth put filehandle operation is handled as if it is the first in a subseries of operations. For example, if the server received a COMPOUND request with this series of operations -- PUTFH, PUTROOTFH, LOOKUP -- then the PUTFH operation is ignored for NFS4ERR_WRONGSEC purposes, and the PUTROOTFH, LOOKUP subseries is processed as according to Section 2.6.3.1.1.3.",
      "ja": "ファイルハンドル操作を置くNのシリーズでは、サーバは、最初のN-1にNFS4ERR_WRONGSECを返してはならないファイルハンドル操作を置きます。 N番目のは、それが操作のサブシリーズの最初であるかのようにファイルハンドル操作が処理されます置きます。サーバは、この一連の動作を有する化合物の要求を受信した場合、例えば、 -  PUTFH、PUTROOTFH、LOOKUP  - 次にPUTFH操作はNFS4ERR_WRONGSEC目的のために無視され、PUTROOTFHは、LOOKUPのサブシリーズは、セクション2.6.3.1に記載のように処理されます。 1.3。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.3. Put Filehandle Operation + LOOKUP (or OPEN of an Existing Name)",
      "ja": "2.6.3.1.1.3。ファイルハンドル操作+ LOOKUP（または既存の名前のOPEN）を入れて"
    },
    {
      "indent": 3,
      "text": "This situation also applies to a put filehandle operation followed by a LOOKUP or an OPEN operation that specifies an existing component name.",
      "ja": "この状況はまた、LOOKUPまたは既存のコンポーネント名を指定し、OPEN操作に続いて入れたファイルハンドルの操作に適用されます。"
    },
    {
      "indent": 3,
      "text": "In this situation, the client is potentially crossing a security policy boundary, and the set of security tuples the parent directory supports may differ from those of the child. The server implementation may decide whether to impose any restrictions on security policy administration. There are at least three approaches (sec_policy_child is the tuple set of the child export, sec_policy_parent is that of the parent).",
      "ja": "このような状況では、クライアントは、潜在的なセキュリティポリシーの境界を横断して、セキュリティタプルの集合親ディレクトリ支持体は子供のものとは異なる場合があります。サーバの実装は、セキュリティポリシーの管理上の任意の制限を課すかどうかを決めることができます。 （sec_policy_child子輸出のタプルセットで、sec_policy_parentは親のことである）は、少なくとも3つのアプローチがあります。"
    },
    {
      "indent": 3,
      "text": "(a) sec_policy_child <= sec_policy_parent (<= for subset). This means that the set of security tuples specified on the security policy of a child directory is always a subset of its parent directory.",
      "ja": "（A）sec_policy_child <= sec_policy_parent（<=サブセットについて）。これは、子ディレクトリのセキュリティポリシーに指定されたセキュリティタプルのセットは、常にその親ディレクトリのサブセットであることを意味します。"
    },
    {
      "indent": 3,
      "text": "(b) sec_policy_child ^ sec_policy_parent != {} (^ for intersection, {} for the empty set). This means that the set of security tuples specified on the security policy of a child directory always has a non-empty intersection with that of the parent.",
      "ja": "（B）sec_policy_child ^ sec_policy_parent！= {}（^交差点のために、{}が空集合の場合）。これは、子ディレクトリのセキュリティポリシーに指定されたセキュリティタプルのセットは、常に親のものと非空の交差点を有することを意味します。"
    },
    {
      "indent": 3,
      "text": "(c) sec_policy_child ^ sec_policy_parent == {}. This means that the set of security tuples specified on the security policy of a child directory may not intersect with that of the parent. In other words, there are no restrictions on how the system administrator may set up these tuples.",
      "ja": "（C）sec_policy_child ^ sec_policy_parent == {}。これは、子ディレクトリのセキュリティポリシーに指定されたセキュリティタプルのセットは親のものと交差しない可能性があることを意味します。言い換えれば、システム管理者がこれらのタプルを設定できるかに制限はありません。"
    },
    {
      "indent": 3,
      "text": "In order for a server to support approaches (b) (for the case when a client chooses a flavor that is not a member of sec_policy_parent) and (c), the put filehandle operation cannot return NFS4ERR_WRONGSEC when there is a security tuple mismatch. Instead, it should be returned from the LOOKUP (or OPEN by existing component name) that follows.",
      "ja": "セキュリティタプルの不一致がある場合のアプローチをサポートするサーバーのために、（b）と（c）（クライアントはsec_policy_parentのメンバーではない風味を選択した場合の）、プットファイルハンドル操作がNFS4ERR_WRONGSECを返すことができません。代わりに、次のようLOOKUPから返された（または既存のコンポーネント名でOPEN）されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Since the above guideline does not contradict approach (a), it should be followed in general. Even if approach (a) is implemented, it is possible for the security tuple used to be acceptable for the target of LOOKUP but not for the filehandles used in the put filehandle operation. The put filehandle operation could be a PUTROOTFH or PUTPUBFH, where the client cannot know the security tuples for the root or public filehandle. Or the security policy for the filehandle used by the put filehandle operation could have changed since the time the filehandle was obtained.",
      "ja": "上記のガイドラインは、アプローチ（A）に矛盾しないので、一般的に従うべきです。 （A）アプローチが実装されても、それが入れファイルハンドル操作に使用されるファイルハンドルのルックアップの目標のために許容なくなるように使用されるセキュリティタプルことが可能です。置くファイルハンドル操作は、クライアントがルートまたは公共ファイルハンドルのセキュリティタプルを知ることができないPUTROOTFHまたはPUTPUBFH、である可能性があります。またはプットファイルハンドル操作によって使用されるファイルハンドルのセキュリティポリシーは、ファイルハンドルが得られた時点以降に変更された可能性があります。"
    },
    {
      "indent": 3,
      "text": "Therefore, an NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC in response to the put filehandle operation if the operation is immediately followed by a LOOKUP or an OPEN by component name.",
      "ja": "操作はすぐにLOOKUPまたはコンポーネント名でOPENが続いている場合ので、NFSv4.1サーバーが置かファイルハンドル操作に応じてNFS4ERR_WRONGSECを返してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.4. Put Filehandle Operation + LOOKUPP",
      "section_title": true,
      "ja": "2.6.3.1.1.4。ファイルハンドル操作+ LOOKUPを置きます"
    },
    {
      "indent": 3,
      "text": "Since SECINFO only works its way down, there is no way LOOKUPP can return NFS4ERR_WRONGSEC without SECINFO_NO_NAME. SECINFO_NO_NAME solves this issue via style SECINFO_STYLE4_PARENT, which works in the opposite direction as SECINFO. As with Section 2.6.3.1.1.3, a put filehandle operation that is followed by a LOOKUPP MUST NOT return NFS4ERR_WRONGSEC. If the server does not support SECINFO_NO_NAME, the client's only recourse is to send the put filehandle operation, LOOKUPP, GETFH sequence of operations with every security tuple it supports.",
      "ja": "SECINFOだけダウンそのように動作するので、LOOKUPPはSECINFO_NO_NAMEなしNFS4ERR_WRONGSECを返すことができる方法はありません。 SECINFO_NO_NAMEはSECINFOと反対方向に働くスタイルSECINFO_STYLE4_PARENTを介してこの問題を解決します。セクション2.6.3.1.1.3と同じように、LOOKUPPが続いている置くファイルハンドル操作がNFS4ERR_WRONGSECを返してはなりません。サーバがSECINFO_NO_NAMEをサポートしていない場合は、クライアントの唯一の手段は、それがサポートするすべてのセキュリティタプルと操作の置くファイルハンドル操作、LOOKUPP、GETFHシーケンスを送信することです。"
    },
    {
      "indent": 3,
      "text": "Regardless of whether SECINFO_NO_NAME is supported, an NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC in response to a put filehandle operation if the operation is immediately followed by a LOOKUPP.",
      "ja": "操作はすぐにLOOKUPPが続いている場合にかかわらずSECINFO_NO_NAMEがサポートされているかどうかの、NFSv4.1サーバーが置かファイルハンドル操作に応じてNFS4ERR_WRONGSECを返してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.5. Put Filehandle Operation + SECINFO/SECINFO_NO_NAME",
      "section_title": true,
      "ja": "2.6.3.1.1.5。ファイルハンドル操作+ SECINFO / SECINFO_NO_NAMEを入れて"
    },
    {
      "indent": 3,
      "text": "A security-sensitive client is allowed to choose a strong security tuple when querying a server to determine a file object's permitted security tuples. The security tuple chosen by the client does not have to be included in the tuple list of the security policy of either the parent directory indicated in the put filehandle operation or the child file object indicated in SECINFO (or any parent directory indicated in SECINFO_NO_NAME). Of course, the server has to be configured for whatever security tuple the client selects; otherwise, the request will fail at the RPC layer with an appropriate authentication error.",
      "ja": "セキュリティに敏感なクライアントは、ファイルオブジェクトの許可セキュリティタプルを決定するためにサーバーを照会するとき、強力なセキュリティタプルを選択することが許可されています。クライアントが選択したセキュリティタプルを置くファイルハンドル操作に示されている親ディレクトリやSECINFOに示されている子のファイルオブジェクト（またはSECINFO_NO_NAMEに示されている任意の親ディレクトリ）のいずれかのセキュリティポリシーのタプルのリストに含まれている必要はありません。もちろん、サーバは、クライアントが選択したものは何でもセキュリティのタプルのために設定する必要があります。そうでない場合は、要求が適切な認証エラーでRPC層で失敗します。"
    },
    {
      "indent": 3,
      "text": "In theory, there is no connection between the security flavor used by SECINFO or SECINFO_NO_NAME and those supported by the security policy. But in practice, the client may start looking for strong flavors from those supported by the security policy, followed by those in the REQUIRED set.",
      "ja": "理論的には、SECINFOまたはSECINFO_NO_NAMEとセキュリティポリシーによってサポートされているものが使用するセキュリティ風味との接続がありません。しかし実際には、クライアントは、必要な一連のものに続いて、セキュリティポリシーでサポートされているもの、からの強い味を探し始めることがあります。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC to a put filehandle operation that is immediately followed by SECINFO or SECINFO_NO_NAME. The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC from SECINFO or SECINFO_NO_NAME.",
      "ja": "NFSv4.1サーバーはすぐにSECINFOまたはSECINFO_NO_NAMEが続いている置くファイルハンドル操作にNFS4ERR_WRONGSECを返してはなりません。 NFSv4.1サーバーがSECINFOまたはSECINFO_NO_NAMEからNFS4ERR_WRONGSECを返してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.6. Put Filehandle Operation + Nothing",
      "section_title": true,
      "ja": "2.6.3.1.1.6。ファイルハンドル操作+の何も入れていません"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC.",
      "ja": "NFSv4.1サーバーがNFS4ERR_WRONGSECを返してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.7. Put Filehandle Operation + Anything Else",
      "section_title": true,
      "ja": "2.6.3.1.1.7。そうでないファイルハンドル操作+なんでも入れ"
    },
    {
      "indent": 3,
      "text": "\"Anything Else\" includes OPEN by filehandle.",
      "ja": "「何か他のものは、」ファイルハンドルによるOPEN含まれています。"
    },
    {
      "indent": 3,
      "text": "The security policy enforcement applies to the filehandle specified in the put filehandle operation. Therefore, the put filehandle operation MUST return NFS4ERR_WRONGSEC when there is a security tuple mismatch. This avoids the complexity of adding NFS4ERR_WRONGSEC as an allowable error to every other operation.",
      "ja": "セキュリティポリシーの施行は入れファイルハンドル操作で指定されたファイルハンドルに適用されます。セキュリティタプルの不一致があるときので、置くファイルハンドル操作がNFS4ERR_WRONGSECを返さなければなりません。これは、他のすべての操作を許容誤差としてNFS4ERR_WRONGSECを追加することの複雑さを避けることができます。"
    },
    {
      "indent": 3,
      "text": "A COMPOUND containing the series put filehandle operation + SECINFO_NO_NAME (style SECINFO_STYLE4_CURRENT_FH) is an efficient way for the client to recover from NFS4ERR_WRONGSEC.",
      "ja": "シリーズを含む化合物は、ファイルハンドル操作を置く+ SECINFO_NO_NAME（スタイルSECINFO_STYLE4_CURRENT_FH）は、クライアントがNFS4ERR_WRONGSECから回復するための効率的な方法です。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 server MUST NOT return NFS4ERR_WRONGSEC to any operation other than a put filehandle operation, LOOKUP, LOOKUPP, and OPEN (by component name).",
      "ja": "NFSv4.1サーバーが置かファイルハンドル操作、LOOKUP、LOOKUPP、およびOPEN（コンポーネント名別）以外の任意の操作にNFS4ERR_WRONGSECを返してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.1.8. Operations after SECINFO and SECINFO_NO_NAME",
      "section_title": true,
      "ja": "2.6.3.1.1.8。 SECINFOとSECINFO_NO_NAME後の操作"
    },
    {
      "indent": 3,
      "text": "Suppose a client sends a COMPOUND procedure containing the series SEQUENCE, PUTFH, SECINFO_NONAME, READ, and suppose the security tuple used does not match that required for the target file. By rule (see Section 2.6.3.1.1.5), neither PUTFH nor SECINFO_NO_NAME can return NFS4ERR_WRONGSEC. By rule (see Section 2.6.3.1.1.7), READ cannot return NFS4ERR_WRONGSEC. The issue is resolved by the fact that SECINFO and SECINFO_NO_NAME consume the current filehandle (note that this is a change from NFSv4.0). This leaves no current filehandle for READ to use, and READ returns NFS4ERR_NOFILEHANDLE.",
      "ja": "クライアントは、一連のシーケンスを含む化合物の手続きを送るPUTFH、SECINFO_NONAME、READ、および使用するセキュリティタプルが対象のファイルに必要なことを一致していないと仮定したとします。ルール（セクション2.6.3.1.1.5を参照）することにより、PUTFHもSECINFO_NO_NAMEどちらもNFS4ERR_WRONGSECを返すことができます。ルール（セクション2.6.3.1.1.7を参照）することで、READはNFS4ERR_WRONGSECを返すことができません。問題はSECINFOとSECINFO_NO_NAMEは、現在のファイルハンドルを消費しているという事実によって解決される（これはNFSv4.0からの変更であることに注意してください）。これは、READが使用するための現在のファイルハンドルを残さない、と読むNFS4ERR_NOFILEHANDLEを返します。"
    },
    {
      "indent": 0,
      "text": "2.6.3.1.2. LINK and RENAME",
      "section_title": true,
      "ja": "2.6.3.1.2。 LINKとRENAME"
    },
    {
      "indent": 3,
      "text": "The LINK and RENAME operations use both the current and saved filehandles. Technically, the server MAY return NFS4ERR_WRONGSEC from LINK or RENAME if the security policy of the saved filehandle rejects the security flavor used in the COMPOUND request's credentials. If the server does so, then if there is no intersection between the security policies of saved and current filehandles, this means that it will be impossible for the client to perform the intended LINK or RENAME operation.",
      "ja": "LINKと操作は現在、保存されたファイルハンドルの両方を使用して名前を変更します。技術的には、サーバは、LINKからNFS4ERR_WRONGSECを返すか、保存されたファイルハンドルのセキュリティポリシーがCOMPOUND要求の資格情報で使用されているセキュリティ風味を拒否した場合RENAMEかもしれません。サーバーがそうする場合は保存され、現在のファイルハンドルのセキュリティポリシーとの間には共通部分が存在しない場合、そして、これは、クライアントが意図したLINKを実行したり、操作の名前を変更することが不可能になることを意味します。"
    },
    {
      "indent": 3,
      "text": "For example, suppose the client sends this COMPOUND request: SEQUENCE, PUTFH bFH, SAVEFH, PUTFH aFH, RENAME \"c\" \"d\", where filehandles bFH and aFH refer to different directories. Suppose no common security tuple exists between the security policies of aFH and bFH. If the client sends the request using credentials acceptable to bFH's security policy but not aFH's policy, then the PUTFH aFH operation will fail with NFS4ERR_WRONGSEC. After a SECINFO_NO_NAME request, the client sends SEQUENCE, PUTFH bFH, SAVEFH, PUTFH aFH, RENAME \"c\" \"d\", using credentials acceptable to aFH's security policy but not bFH's policy. The server returns NFS4ERR_WRONGSEC on the RENAME operation.",
      "ja": "例えば、クライアントは、この化合物の要求を送信したとします。SEQUENCEは、PUTFH BFH、SAVEFH、PUTFH AFHは、BFHとAFHは別のディレクトリを参照してくださいファイルハンドル「C」「D」を、名前を変更します。共通のセキュリティタプルは、AFHとBFHのセキュリティポリシーの間に存在しないと仮定します。クライアントがBFHのセキュリティポリシーではなく、AFHの政策に許容可能な資格情報を使用して要求を送信した場合、PUTFH AFH操作がNFS4ERR_WRONGSECで失敗します。 SECINFO_NO_NAME要求した後、クライアントはSEQUENCE、PUTFH BFH、SAVEFH、PUTFH AFHを送り、AFHのセキュリティポリシーではなく、BFHの政策に許容可能な資格情報を使用して、「C」「D」を変更します。サーバは、RENAME操作にNFS4ERR_WRONGSECを返します。"
    },
    {
      "indent": 3,
      "text": "To prevent a client from an endless sequence of a request containing LINK or RENAME, followed by a request containing SECINFO_NO_NAME or SECINFO, the server MUST detect when the security policies of the current and saved filehandles have no mutually acceptable security tuple, and MUST NOT return NFS4ERR_WRONGSEC from LINK or RENAME in that situation. Instead the server MUST do one of two things:",
      "ja": "現在とファイルハンドルを保存するセキュリティポリシーがまったく相互に受け入れ可能なセキュリティタプルを持っていない、と返してはならないときに、リンクを含むリクエストの無限のシーケンスからクライアントを防止またはRENAME、SECINFO_NO_NAMEまたはSECINFOを含む要求が続くために、サーバーを検出しなければなりませんそのような状況でのLINKまたはRENAMEからNFS4ERR_WRONGSEC。代わりに、サーバーは2つのいずれかを行う必要があります"
    },
    {
      "indent": 3,
      "text": "o The server can return NFS4ERR_XDEV.",
      "ja": "OサーバはNFS4ERR_XDEVを返すことができます。"
    },
    {
      "indent": 3,
      "text": "o The server can allow the security policy of the current filehandle to override that of the saved filehandle, and so return NFS4_OK.",
      "ja": "Oサーバは、現在のファイルハンドルのセキュリティポリシーが保存されたファイルハンドルのそれを上書きすることができ、そのためNFS4_OKを返すことができます。"
    },
    {
      "indent": 0,
      "text": "2.7. Minor Versioning",
      "section_title": true,
      "ja": "2.7. マイナーバージョン管理"
    },
    {
      "indent": 3,
      "text": "To address the requirement of an NFS protocol that can evolve as the need arises, the NFSv4.1 protocol contains the rules and framework to allow for future minor changes or versioning.",
      "ja": "必要に応じて進化させることができ、NFSプロトコルの要件に対処するために、NFSv4.1プロトコルは、将来のマイナーな変更やバージョン管理を可能にするためのルールやフレームワークが含まれています。"
    },
    {
      "indent": 3,
      "text": "The base assumption with respect to minor versioning is that any future accepted minor version will be documented in one or more Standards Track RFCs. Minor version 0 of the NFSv4 protocol is represented by [30], and minor version 1 is represented by this RFC. The COMPOUND and CB_COMPOUND procedures support the encoding of the minor version being requested by the client.",
      "ja": "マイナーバージョンに関する基本仮定は、将来のマイナーバージョンを受け入れたことである一つ以上の標準化過程RFCで文書化されます。 NFSv4プロトコルのマイナーバージョン0は、[30]で表され、マイナーバージョン1は、このRFCによって表されます。 COMPOUNDとCB_COMPOUND手順は、クライアントによって要求されているマイナーバージョンのエンコーディングをサポートしています。"
    },
    {
      "indent": 3,
      "text": "The following items represent the basic rules for the development of minor versions. Note that a future minor version may modify or add to the following rules as part of the minor version definition.",
      "ja": "以下の項目は、マイナーバージョンの開発のための基本的なルールを表しています。将来のマイナーバージョンが変更またはマイナーバージョン定義の一部として、以下のルールに追加することがあります。"
    },
    {
      "indent": 3,
      "text": "1. Procedures are not added or deleted.",
      "section_title": true,
      "ja": "1.手順が追加または削除されません。"
    },
    {
      "indent": 8,
      "text": "To maintain the general RPC model, NFSv4 minor versions will not\nadd to or delete procedures from the NFS program.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. Minor versions may add operations to the COMPOUND and CB_COMPOUND procedures.",
      "ja": "2.マイナーバージョンは、化合物およびCB_COMPOUND手順に操作を追加することができます。"
    },
    {
      "indent": 8,
      "text": "The addition of operations to the COMPOUND and CB_COMPOUND\nprocedures does not affect the RPC model.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "* Minor versions may append attributes to the bitmap4 that represents sets of attributes and to the fattr4 that represents sets of attribute values.",
      "ja": "*マイナーバージョンは、属性のセットを表しbitmap4および属性値の組を表すfattr4に属性を追加することができます。"
    },
    {
      "indent": 11,
      "text": "This allows for the expansion of the attribute model to allow for future growth or adaptation.",
      "ja": "これは、将来の成長や適応を可能にする属性モデルを拡張することができます。"
    },
    {
      "indent": 8,
      "text": "* Minor version X must append any new attributes after the last documented attribute.",
      "ja": "*マイナーバージョンXは、最後の文書属性の後に任意の新しい属性を追加する必要があります。"
    },
    {
      "indent": 11,
      "text": "Since attribute results are specified as an opaque array of per-attribute, XDR-encoded results, the complexity of adding new attributes in the midst of the current definitions would be too burdensome.",
      "ja": "属性の結果が当たりの属性、XDRエンコード結果の不透明な配列として指定されているので、現在の定義の中に新しい属性を追加することの複雑さはあまりに厄介であろう。"
    },
    {
      "indent": 3,
      "text": "3. Minor versions must not modify the structure of an existing operation's arguments or results.",
      "ja": "3.マイナーバージョンでは、既存のオペレーションの引数や結果の構造を変更してはなりません。"
    },
    {
      "indent": 8,
      "text": "Again, the complexity of handling multiple structure definitions\nfor a single operation is too burdensome.  New operations should\nbe added instead of modifying existing structures for a minor\nversion.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "This rule does not preclude the following adaptations in a minor version:",
      "ja": "この規則は、マイナーバージョンでは、以下の適応を妨げるものではありません。"
    },
    {
      "indent": 8,
      "text": "* adding bits to flag fields, such as new attributes to GETATTR's bitmap4 data type, and providing corresponding variants of opaque arrays, such as a notify4 used together with such bitmaps",
      "ja": "* GETATTRのbitmap4データ型に新たな属性としてフラグフィールドにビットを追加すること、およびそのようなそのようなビットマップと一緒に使用notify4として不透明アレイの対応する変異体を、提供"
    },
    {
      "indent": 8,
      "text": "* adding bits to existing attributes like ACLs that have flag words",
      "ja": "*フラグの言葉を持っていたACLのような既存の属性にビットを追加します"
    },
    {
      "indent": 8,
      "text": "* extending enumerated types (including NFS4ERR_*) with new values",
      "ja": "*新しい値で（NFS4ERR_ *を含む）列挙型を拡張"
    },
    {
      "indent": 8,
      "text": "* adding cases to a switched union",
      "ja": "*切り替え組合に例を追加"
    },
    {
      "indent": 3,
      "text": "4. Minor versions must not modify the structure of existing attributes.",
      "ja": "4.マイナーバージョンには、既存の属性の構造を変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "5. Minor versions must not delete operations.",
      "section_title": true,
      "ja": "5.マイナーバージョンでは、操作を削除してはなりません。"
    },
    {
      "indent": 8,
      "text": "This prevents the potential reuse of a particular operation\n\"slot\" in a future minor version.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6. Minor versions must not delete attributes.",
      "section_title": true,
      "ja": "6.マイナーバージョンでは、属性を削除してはいけません。"
    },
    {
      "indent": 3,
      "text": "7. Minor versions must not delete flag bits or enumeration values.",
      "section_title": true,
      "ja": "7.マイナーバージョンは、フラグビットまたは列挙値を削除してはなりません。"
    },
    {
      "indent": 3,
      "text": "8. Minor versions may declare an operation MUST NOT be implemented.",
      "section_title": true,
      "ja": "8.マイナーバージョンが実装されてはいけません操作を宣言することができます。"
    },
    {
      "indent": 8,
      "text": "Specifying that an operation MUST NOT be implemented is\nequivalent to obsoleting an operation.  For the client, it means\nthat the operation MUST NOT be sent to the server.  For the\nserver, an NFS error can be returned as opposed to \"dropping\"\nthe request as an XDR decode error.  This approach allows for\nthe obsolescence of an operation while maintaining its structure\nso that a future minor version can reintroduce the operation.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "1. Minor versions may declare that an attribute MUST NOT be implemented.",
      "ja": "1.マイナーバージョンでは、属性が実装されてはならないことを宣言することができます。"
    },
    {
      "indent": 8,
      "text": "2. Minor versions may declare that a flag bit or enumeration value MUST NOT be implemented.",
      "ja": "2.マイナーバージョンは、フラグビットまたは列挙値が実装されてはならないことを宣言することができます。"
    },
    {
      "indent": 3,
      "text": "9. Minor versions may downgrade features from REQUIRED to RECOMMENDED, or RECOMMENDED to OPTIONAL.",
      "ja": "9.マイナーバージョンを推奨、またはオプションすることをお勧めするために必要なの機能をダウングレードすることがあります。"
    },
    {
      "indent": 3,
      "text": "10. Minor versions may upgrade features from OPTIONAL to RECOMMENDED, or RECOMMENDED to REQUIRED.",
      "ja": "10.マイナーバージョンを推奨、またはREQUIREDすることをお勧めするには、オプションの機能をアップグレードすることができます。"
    },
    {
      "indent": 3,
      "text": "11. A client and server that support minor version X SHOULD support minor versions zero through X-1 as well.",
      "ja": "マイナーバージョンXをサポート11.クライアントとサーバは、マイナーバージョンをサポートすべきであるだけでなくX-1を介してゼロ。"
    },
    {
      "indent": 3,
      "text": "12. Except for infrastructural changes, a minor version must not introduce REQUIRED new features.",
      "ja": "インフラの変更を除き12、マイナーバージョンは、必要な新機能を導入してはなりません。"
    },
    {
      "indent": 8,
      "text": "This rule allows for the introduction of new functionality and\nforces the use of implementation experience before designating a\nfeature as REQUIRED.  On the other hand, some classes of\nfeatures are infrastructural and have broad effects.  Allowing\ninfrastructural features to be RECOMMENDED or OPTIONAL\ncomplicates implementation of the minor version.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "13. A client MUST NOT attempt to use a stateid, filehandle, or similar returned object from the COMPOUND procedure with minor version X for another COMPOUND procedure with minor version Y, where X != Y.",
      "ja": "13.クライアントは、X！= Y.マイナーバージョンY、と別のCOMPOUND手順のためにマイナーバージョンXでCOMPOUND手順からのstateid、ファイルハンドル、または同様返されたオブジェクトを使用することを試みてはいけません"
    },
    {
      "indent": 0,
      "text": "2.8. Non-RPC-Based Security Services",
      "section_title": true,
      "ja": "2.8. 非RPCベースのセキュリティ・サービス"
    },
    {
      "indent": 3,
      "text": "As described in Section 2.2.1.1.1.1, NFSv4.1 relies on RPC for identification, authentication, integrity, and privacy. NFSv4.1 itself provides or enables additional security services as described in the next several subsections.",
      "ja": "セクション2.2.1.1.1.1で説明したように、NFSv4.1は、識別、認証、整合性、およびプライバシーのためのRPCに依存しています。次のいくつかのサブセクションで説明するようにNFSv4.1自体は、追加のセキュリティサービスを提供したりできます。"
    },
    {
      "indent": 0,
      "text": "2.8.1. Authorization",
      "section_title": true,
      "ja": "2.8.1. 認定"
    },
    {
      "indent": 3,
      "text": "Authorization to access a file object via an NFSv4.1 operation is ultimately determined by the NFSv4.1 server. A client can predetermine its access to a file object via the OPEN (Section 18.16) and the ACCESS (Section 18.1) operations.",
      "ja": "NFSv4.1操作を介してファイルオブジェクトにアクセスする権限は、最終的にNFSv4.1サーバーによって決定されます。クライアントがOPEN（セクション18.16）とアクセス（18.1節）操作でファイルオブジェクトへのアクセスを事前に決定することができます。"
    },
    {
      "indent": 3,
      "text": "Principals with appropriate access rights can modify the authorization on a file object via the SETATTR (Section 18.30) operation. Attributes that affect access rights include mode, owner, owner_group, acl, dacl, and sacl. See Section 5.",
      "ja": "適切なアクセス権を持つプリンシパルはSETATTR（セクション18.30）の操作を経由してファイルオブジェクト上の権限を変更することができます。アクセス権に影響を与える属性は、モード、所有者、owner_group、ACL、DACL、およびSACLが含まれます。第5節を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.8.2. Auditing",
      "section_title": true,
      "ja": "2.8.2. 会計監査"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 provides auditing on a per-file object basis, via the acl and sacl attributes as described in Section 6. It is outside the scope of this specification to specify audit log formats or management policies.",
      "ja": "NFSv4.1は、ACLを介して、ファイルごとのオブジェクトに基づいて監査を提供し、SACLはセクション6で説明したように、監査ログフォーマットまたは管理ポリシーを指定するには、この明細書の範囲外である属性。"
    },
    {
      "indent": 0,
      "text": "2.8.3. Intrusion Detection",
      "section_title": true,
      "ja": "2.8.3. 侵入検知"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 provides alarm control on a per-file object basis, via the acl and sacl attributes as described in Section 6. Alarms may serve as the basis for intrusion detection. It is outside the scope of this specification to specify heuristics for detecting intrusion via alarms.",
      "ja": "NFSv4.1は、ACLを介して、ファイルごとのオブジェクトに基づいて、警報制御を提供し、SACLはセクションで説明したように6アラームが侵入検知のための基礎として機能することができる属性。これは、アラームを介して侵入を検出するためのヒューリスティックを指定するには、この明細書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "2.9. Transport Layers",
      "section_title": true,
      "ja": "2.9. トランスポートレイヤー"
    },
    {
      "indent": 0,
      "text": "2.9.1. REQUIRED and RECOMMENDED Properties of Transports",
      "section_title": true,
      "ja": "2.9.1. トランスポートの必須および推奨のプロパティ"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 works over Remote Direct Memory Access (RDMA) and non-RDMA-based transports with the following attributes: o The transport supports reliable delivery of data, which NFSv4.1 requires but neither NFSv4.1 nor RPC has facilities for ensuring [34].",
      "ja": "NFSv4.1は、次の属性を持つリモートダイレクトメモリアクセス（RDMA）と非RDMAベースのトランスポート上で動作します：トランスポートは、データの信頼性の高い配信をサポートNFSv4.1を必要とするが、どちらもNFSv4.1もRPCを確保するための設備を[持ってoを34]。"
    },
    {
      "indent": 3,
      "text": "o The transport delivers data in the order it was sent. Ordered delivery simplifies detection of transmit errors, and simplifies the sending of arbitrary sized requests and responses via the record marking protocol [3].",
      "ja": "Oの輸送は、それが送信された順にデータを提供します。順序付けられた配信は、送信エラーの検出を簡素化し、およびプロトコルをマーキングレコードを介して任意のサイズの要求と応答の送信を簡素化する[3]。"
    },
    {
      "indent": 3,
      "text": "Where an NFSv4.1 implementation supports operation over the IP network protocol, any transport used between NFS and IP MUST be among the IETF-approved congestion control transport protocols. At the time this document was written, the only two transports that had the above attributes were TCP and the Stream Control Transmission Protocol (SCTP). To enhance the possibilities for interoperability, an NFSv4.1 implementation MUST support operation over the TCP transport protocol.",
      "ja": "NFSv4.1実装はIPネットワークプロトコルを介して動作をサポートする場合、NFSとIPとの間に使用される任意のトランスポートは、IETF承認輻輳制御トランスポートプロトコルの中でなければなりません。この文書が書かれた時点で、上記の属性を持っていた唯一の2つのトランスポートは、TCPおよびストリーム制御伝送プロトコル（SCTP）でした。相互運用性のための可能性を高めるために、NFSv4.1実装は、TCPトランスポートプロトコル上での動作をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Even if NFSv4.1 is used over a non-IP network protocol, it is RECOMMENDED that the transport support congestion control.",
      "ja": "NFSv4.1は、非IPネットワークプロトコルで使用されている場合でも、それは輸送支援輻輳制御することを推奨しています。"
    },
    {
      "indent": 3,
      "text": "It is permissible for a connectionless transport to be used under NFSv4.1; however, reliable and in-order delivery of data combined with congestion control by the connectionless transport is REQUIRED. As a consequence, UDP by itself MUST NOT be used as an NFSv4.1 transport. NFSv4.1 assumes that a client transport address and server transport address used to send data over a transport together constitute a connection, even if the underlying transport eschews the concept of a connection.",
      "ja": "コネクションレストランスポートがNFSv4.1下で使用されることが許されています。しかし、コネクションレス輸送による輻輳制御と組み合わせたデータの信頼性の順序配信を要求されています。結果として、それ自体でUDPはNFSv4.1トランスポートとして使用してはいけません。 NFSv4.1は、クライアントのトランスポートアドレスおよびトランスポートを介してデータを送信するために使用されるサーバーのトランスポートアドレスは一緒に基礎となるトランスポートは接続の概念を避けていても、接続を構成することを前提としています。"
    },
    {
      "indent": 0,
      "text": "2.9.2. Client and Server Transport Behavior",
      "section_title": true,
      "ja": "2.9.2. クライアントとサーバーの交通行動"
    },
    {
      "indent": 3,
      "text": "If a connection-oriented transport (e.g., TCP) is used, the client and server SHOULD use long-lived connections for at least three reasons:",
      "ja": "接続指向の輸送が（例えば、TCP）を使用する場合は、クライアントとサーバは、少なくとも3つの理由で長寿命の接続を使用する必要がある場合："
    },
    {
      "indent": 3,
      "text": "1. This will prevent the weakening of the transport's congestion control mechanisms via short-lived connections.",
      "ja": "1.これは短命接続を介してトランスポートの輻輳制御機構の弱体化を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "2. This will improve performance for the WAN environment by eliminating the need for connection setup handshakes.",
      "ja": "2.これは、接続設定ハンドシェイクの必要性を排除することにより、WAN環境のパフォーマンスが向上します。"
    },
    {
      "indent": 3,
      "text": "3. The NFSv4.1 callback model differs from NFSv4.0, and requires the client and server to maintain a client-created backchannel (see Section 2.10.3.1) for the server to use.",
      "ja": "3. NFSv4.1コールバックモデルはNFSv4.0と異なり、クライアントが作成したバックチャネルを維持するために、クライアントとサーバーを必要とするサーバーが使用する（セクション2.10.3.1を参照してください）。"
    },
    {
      "indent": 3,
      "text": "In order to reduce congestion, if a connection-oriented transport is used, and the request is not the NULL procedure: o A requester MUST NOT retry a request unless the connection the request was sent over was lost before the reply was received.",
      "ja": "応答が受信される前に、要求が終わっ送信された接続が失われた場合を除き、要求者は、要求を再試行してはならない○：接続指向のトランスポートが使用され、要求がNULL手続きでない場合は、輻輳を低減するために。"
    },
    {
      "indent": 3,
      "text": "o A replier MUST NOT silently drop a request, even if the request is a retry. (The silent drop behavior of RPCSEC_GSS [4] does not apply because this behavior happens at the RPCSEC_GSS layer, a lower layer in the request processing.) Instead, the replier SHOULD return an appropriate error (see Section 2.10.6.1), or it MAY disconnect the connection.",
      "ja": "Oリプライヤは黙って要求が再試行された場合でも、要求をドロップしてはなりません。 （この現象は、RPCSEC_GSS層、要求処理における下層に起こるので、RPCSEC_GSSのサイレントドロップ動作[4]は適用されない。）その代わりに、回答者は、適切なエラーを返すべきである（セクション2.10.6.1を参照）、または接続が切断されることがあります。"
    },
    {
      "indent": 3,
      "text": "When sending a reply, the replier MUST send the reply to the same full network address (e.g., if using an IP-based transport, the source port of the requester is part of the full network address) from which the requester sent the request. If using a connection-oriented transport, replies MUST be sent on the same connection from which the request was received.",
      "ja": "応答を送信する際、回答者は、リクエスタが要求を送ったのと同じ完全なネットワークアドレス（例えば、IPベースのトランスポートを使用している場合、要求の送信元ポートが完全なネットワークアドレスの一部である）に応答を送信しなければなりません。コネクション型トランスポートを使用する場合、応答は要求を受信したのと同じ接続上で送信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a connection is dropped after the replier receives the request but before the replier sends the reply, the replier might have a pending reply. If a connection is established with the same source and destination full network address as the dropped connection, then the replier MUST NOT send the reply until the requester retries the request. The reason for this prohibition is that the requester MAY retry a request over a different connection (provided that connection is associated with the original request's session).",
      "ja": "接続がリプライヤ後に削除されている場合は、要求を受信するが、リプライヤが応答を送信する前に、リプライヤは保留中の回答を持っているかもしれません。接続がドロップされた接続と同じ送信元と宛先の完全なネットワークアドレスで確立されている場合は、リクエスタが要求を再試行するまで、その後、リプライヤは応答を送ってはいけません。この禁止の理由は、要求側が（接続は元の要求のセッションに関連付けられていることを提供する）別の接続を介して要求を再試行することです。"
    },
    {
      "indent": 3,
      "text": "When using RDMA transports, there are other reasons for not tolerating retries over the same connection:",
      "ja": "RDMAトランスポートを使用する場合は、同じ接続での再試行を許容ないための他の理由があります。"
    },
    {
      "indent": 3,
      "text": "o RDMA transports use \"credits\" to enforce flow control, where a credit is a right to a peer to transmit a message. If one peer were to retransmit a request (or reply), it would consume an additional credit. If the replier retransmitted a reply, it would certainly result in an RDMA connection loss, since the requester would typically only post a single receive buffer for each request. If the requester retransmitted a request, the additional credit consumed on the server might lead to RDMA connection failure unless the client accounted for it and decreased its available credit, leading to wasted resources.",
      "ja": "O RDMAクレジットがメッセージを送信するためのピアへの権利であるフロー制御を強制する「クレジット」を使用して搬送します。一方のピアが要求を再送信する（または返信）した場合、それは追加のクレジットを消費することになります。リプライヤが応答を再送信した場合、それは確かにリクエスターは、通常、単一の要求ごとに受信バッファを投稿するであろうから、RDMAの接続損失につながります。依頼者が要求を再送信した場合、クライアントはそれを占め、無駄な資源につながる、その利用可能なクレジットを減少させた場合を除き、サーバー上で消費追加のクレジットがRDMA接続障害につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "o RDMA credits present a new issue to the reply cache in NFSv4.1. The reply cache may be used when a connection within a session is lost, such as after the client reconnects. Credit information is a dynamic property of the RDMA connection, and stale values must not be replayed from the cache. This implies that the reply cache contents must not be blindly used when replies are sent from it, and credit information appropriate to the channel must be refreshed by the RPC layer.",
      "ja": "O RDMAクレジットはNFSv4.1で返信キャッシュに新しい問題を提示します。セッション内の接続は、クライアントが再接続した後のように、失われたときの応答キャッシュを使用することができます。信用情報は、RDMA接続の動的な特性であり、そして古い値がキャッシュから再生してはいけません。これは、応答がそこから送信され、チャネルへの適切な信用情報は、RPC層によってリフレッシュされなければならないとき、応答キャッシュの内容を盲目的に使用してはならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "In addition, as described in Section 2.10.6.2, while a session is active, the NFSv4.1 requester MUST NOT stop waiting for a reply.",
      "ja": "セッションがアクティブな間加えて、セクション2.10.6.2で説明したように、NFSv4.1依頼者は応答を待って停止してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.9.3. Ports",
      "section_title": true,
      "ja": "2.9.3. ポート"
    },
    {
      "indent": 3,
      "text": "Historically, NFSv3 servers have listened over TCP port 2049. The registered port 2049 [35] for the NFS protocol should be the default configuration. NFSv4.1 clients SHOULD NOT use the RPC binding protocols as described in [36].",
      "ja": "歴史的に、NFSv3のサーバは、デフォルトの設定でなければなりませんNFSプロトコルのTCPポート2049登録ポート[35] 2049年の上に耳を傾けてきました。 [36]に記載されているようにNFSv4.1クライアントは、プロトコルバインディングRPCを使用しません。"
    },
    {
      "indent": 0,
      "text": "2.10. Session",
      "section_title": true,
      "ja": "2.10. セッション"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 clients and servers MUST support and MUST use the session feature as described in this section.",
      "ja": "NFSv4.1のクライアントとサーバーがサポートしなければならないと、このセクションで説明するようにセッション機能を使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.10.1. Motivation and Overview",
      "section_title": true,
      "ja": "2.10.1. 動機と概要"
    },
    {
      "indent": 3,
      "text": "Previous versions and minor versions of NFS have suffered from the following:",
      "ja": "以前のバージョンとNFSのマイナーバージョンは以下の苦しんでいます："
    },
    {
      "indent": 3,
      "text": "o Lack of support for Exactly Once Semantics (EOS). This includes lack of support for EOS through server failure and recovery.",
      "ja": "O必ず1回セマンティクスのサポートの欠如（EOS）。これは、サーバーの障害と回復を通じてEOSのためのサポートの欠如が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Limited callback support, including no support for sending callbacks through firewalls, and races between replies to normal requests and callbacks.",
      "ja": "通常のリクエストとコールバックへの応答の間にはファイアウォール経由でコールバックを送信するためのサポート、そしてレースを含めない限り、コールバックをサポートし、O。"
    },
    {
      "indent": 3,
      "text": "o Limited trunking over multiple network paths.",
      "ja": "O限定は、複数のネットワークパス上でトランキング。"
    },
    {
      "indent": 3,
      "text": "o Requiring machine credentials for fully secure operation.",
      "ja": "完全に安全な操作のためのマシンクレデンシャルを要求O。"
    },
    {
      "indent": 3,
      "text": "Through the introduction of a session, NFSv4.1 addresses the above shortfalls with practical solutions:",
      "ja": "セッションの導入により、NFSv4.1は、実用的なソリューションで上記の不足に対処します。"
    },
    {
      "indent": 3,
      "text": "o EOS is enabled by a reply cache with a bounded size, making it feasible to keep the cache in persistent storage and enable EOS through server failure and recovery. One reason that previous revisions of NFS did not support EOS was because some EOS approaches often limited parallelism. As will be explained in Section 2.10.6, NFSv4.1 supports both EOS and unlimited parallelism.",
      "ja": "O EOSは、それが実現可能な永続ストレージにキャッシュを保持し、サーバ障害と回復を通じてEOSを有効にすること、有界サイズの返信キャッシュで有効になっています。いくつかのEOSのアプローチは、多くの場合、並列処理を制限されているためNFSの以前のリビジョンは、EOSをサポートしていないことを理由の一つでした。セクション2.10.6に説明するように、NFSv4.1はEOSと無制限の並列処理の両方をサポートしています。"
    },
    {
      "indent": 3,
      "text": "o The NFSv4.1 client (defined in Section 1.6, Paragraph 2) creates transport connections and provides them to the server to use for sending callback requests, thus solving the firewall issue (Section 18.34). Races between responses from client requests and",
      "ja": "NFSv4.1のクライアントO（1.6項、第2項で定義されている）交通機関の接続を作成しますので、ファイアウォールの問題（セクション18.34）を解く、コールバック要求を送信するために使用するサーバーにそれらを提供します。クライアント要求からの応答間のレースと"
    },
    {
      "indent": 6,
      "text": "callbacks caused by the requests are detected via the session's sequencing properties that are a consequence of EOS (Section 2.10.6.3).",
      "ja": "リクエストによって引き起こされるコールバックは、EOS（セクション2.10.6.3）の結果であるセッションのシーケンシングのプロパティを介して検出されています。"
    },
    {
      "indent": 3,
      "text": "o The NFSv4.1 client can associate an arbitrary number of connections with the session, and thus provide trunking (Section 2.10.5).",
      "ja": "O NFSv4.1クライアントは、トランキング（セクション2.10.5）を提供し、したがってセッションとの接続の任意の数を関連付け、そしてすることができます。"
    },
    {
      "indent": 3,
      "text": "o The NFSv4.1 client and server produces a session key independent of client and server machine credentials which can be used to compute a digest for protecting critical session management operations (Section 2.10.8.3).",
      "ja": "NFSv4.1のクライアントとサーバーは、重要なセッション管理操作（セクション2.10.8.3）を保護するため、ダイジェストを計算するために使用することができ、クライアントとサーバマシンのクレデンシャルのセッションキーの独立を作成するoを。"
    },
    {
      "indent": 3,
      "text": "o The NFSv4.1 client can also create secure RPCSEC_GSS contexts for use by the session's backchannel that do not require the server to authenticate to a client machine principal (Section 2.10.8.2).",
      "ja": "O NFSv4.1のクライアントは、クライアント・マシンのプリンシパル（セクション2.10.8.2）を認証するためにサーバーを必要としないセッションのバックチャネルで使用するための安全なRPCSEC_GSSコンテキストを作成することができます。"
    },
    {
      "indent": 3,
      "text": "A session is a dynamically created, long-lived server object created by a client and used over time from one or more transport connections. Its function is to maintain the server's state relative to the connection(s) belonging to a client instance. This state is entirely independent of the connection itself, and indeed the state exists whether or not the connection exists. A client may have one or more sessions associated with it so that client-associated state may be accessed using any of the sessions associated with that client's client ID, when connections are associated with those sessions. When no connections are associated with any of a client ID's sessions for an extended time, such objects as locks, opens, delegations, layouts, etc. are subject to expiration. The session serves as an object representing a means of access by a client to the associated client state on the server, independent of the physical means of access to that state.",
      "ja": "セッションは、クライアントによって作成され、一の以上のトランスポート接続から時間をかけて使用し、動的に作成された、長寿命のサーバーオブジェクトです。その機能は、クライアントインスタンスに属する接続（複数可）に、サーバの状態の相対性を維持することです。この状態は、接続自体の完全に独立しており、実際の状態は、接続が存在するか否かが存在します。クライアントに関連する状態は、接続がそれらのセッションに関連付けられているクライアントのクライアントIDに関連付けられたセッションのいずれかを使用してアクセスできるように、クライアントは、それに関連付けられた1つ以上のセッションを有していてもよいです。いかなる接続は、長時間のクライアントIDのセッション、ロックなどのオブジェクトのいずれかと関連していない開いている場合、委任、レイアウト等が期限切れの対象となっています。セッションは、その状態へのアクセスの物理的手段の独立したサーバ上の関連するクライアントの状態へのクライアントによるアクセスの手段を表すオブジェクトとして機能します。"
    },
    {
      "indent": 3,
      "text": "A single client may create multiple sessions. A single session MUST NOT serve multiple clients.",
      "ja": "単一のクライアントが複数のセッションを作成することができます。単一のセッションは、複数のクライアントにサービスを提供してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.10.2. NFSv4 Integration",
      "section_title": true,
      "ja": "2.10.2.  NFSv4の統合"
    },
    {
      "indent": 3,
      "text": "Sessions are part of NFSv4.1 and not NFSv4.0. Normally, a major infrastructure change such as sessions would require a new major version number to an Open Network Computing (ONC) RPC program like NFS. However, because NFSv4 encapsulates its functionality in a single procedure, COMPOUND, and because COMPOUND can support an arbitrary number of operations, sessions have been added to NFSv4.1 with little difficulty. COMPOUND includes a minor version number field, and for NFSv4.1 this minor version is set to 1. When the NFSv4 server processes a COMPOUND with the minor version set to 1, it expects a different set of operations than it does for NFSv4.0.",
      "ja": "セッションはNFSv4.1はなくNFSv4.0の一部です。通常、このようなセッションなどの主要なインフラストラクチャの変更は、NFSのようなオープンネットワークコンピューティング（ONC）RPCプログラムに新しいメジャーバージョン番号が必要になります。 NFSv4のは、単一の手順、化合物中にその機能をカプセル化しているため、および化合物は操作の任意の数をサポートすることができるのでしかし、セッションはほとんど困難でNFSv4.1に追加されました。化合物はマイナーバージョン番号フィールドを含み、NFSv4サーバが1に設定されたマイナーバージョンを有する化合物を処理するときNFSv4.1このマイナーバージョンは1に設定され、それはNFSv4.0ためよりも動作の異なるセットを期待します。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 defines the SEQUENCE operation, which is required for every COMPOUND that operates over an established session, with the exception of some session administration operations, such as DESTROY_SESSION (Section 18.37).",
      "ja": "NFSv4.1は、DESTROY_SESSION（セクション18.37）のように、いくつかのセッション管理操作を除いて、確立されたセッションで動作し、すべての化合物について必要とされるシーケンス動作を定義します。"
    },
    {
      "indent": 0,
      "text": "2.10.2.1. SEQUENCE and CB_SEQUENCE",
      "section_title": true,
      "ja": "2.10.2.1。 SEQUENCEとCB_SEQUENCE"
    },
    {
      "indent": 3,
      "text": "In NFSv4.1, when the SEQUENCE operation is present, it MUST be the first operation in the COMPOUND procedure. The primary purpose of SEQUENCE is to carry the session identifier. The session identifier associates all other operations in the COMPOUND procedure with a particular session. SEQUENCE also contains required information for maintaining EOS (see Section 2.10.6). Session-enabled NFSv4.1 COMPOUND requests thus have the form:",
      "ja": "シーケンス動作が存在する場合NFSv4.1において、化合物手順における最初の操作でなければなりません。 SEQUENCEの主な目的は、セッション識別子を運ぶことです。セッション識別子は、特定のセッションを有する化合物の手順で他のすべての操作を関連付けます。 SEQUENCEはまた、EOS（セクション2.10.6を参照）を維持するために必要な情報が含まれています。セッション対応のNFSv4.1化合物の要求は、このような形式になります。"
    },
    {
      "indent": 7,
      "text": "+-----+--------------+-----------+------------+-----------+----\n| tag | minorversion | numops    |SEQUENCE op | op + args | ...\n|     |   (== 1)     | (limited) |  + args    |           |\n+-----+--------------+-----------+------------+-----------+----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "and the replies have the form:",
      "ja": "そして、応答の形式は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "+------------+-----+--------+-------------------------------+--//\n|last status | tag | numres |status + SEQUENCE op + results |  //\n+------------+-----+--------+-------------------------------+--//\n        //-----------------------+----\n        // status + op + results | ...\n        //-----------------------+----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A CB_COMPOUND procedure request and reply has a similar form to COMPOUND, but instead of a SEQUENCE operation, there is a CB_SEQUENCE operation. CB_COMPOUND also has an additional field called \"callback_ident\", which is superfluous in NFSv4.1 and MUST be ignored by the client. CB_SEQUENCE has the same information as SEQUENCE, and also includes other information needed to resolve callback races (Section 2.10.6.3).",
      "ja": "CB_COMPOUND手順要求および応答が化合物に類似した形状を有しているが、代わりにシーケンス動作を、CB_SEQUENCE動作があります。 CB_COMPOUNDもNFSv4.1で余分であり、クライアントによって無視されなければならない「callback_ident」と呼ばれる追加のフィールドがあります。 CB_SEQUENCEはSEQUENCEと同じ情報を持っており、また、コールバックレース（セクション2.10.6.3）を解決するために必要なその他の情報が含まれています。"
    },
    {
      "indent": 0,
      "text": "2.10.2.2. Client ID and Session Association",
      "section_title": true,
      "ja": "2.10.2.2。クライアントIDとセッション協会"
    },
    {
      "indent": 3,
      "text": "Each client ID (Section 2.4) can have zero or more active sessions. A client ID and associated session are required to perform file access in NFSv4.1. Each time a session is used (whether by a client sending a request to the server or the client replying to a callback request from the server), the state leased to its associated client ID is automatically renewed.",
      "ja": "各クライアントID（2.4節）は、ゼロ個以上のアクティブなセッションを持つことができます。クライアントIDと関連付けられたセッションがNFSv4.1でファイルアクセスを実行するために必要とされます。セッションが使用されるたびに（クライアントがサーバにリクエストを送信したり、クライアントがサーバからのコールバック要求に応答するかどうか）、その関連付けられたクライアントIDにリース状態が自動的に更新されます。"
    },
    {
      "indent": 3,
      "text": "State (which can consist of share reservations, locks, delegations, and layouts (Section 1.7.4)) is tied to the client ID. Client state is not tied to any individual session. Successive state changing operations from a given state owner MAY go over different sessions, provided the session is associated with the same client ID. A callback MAY arrive over a different session than that of the request that originally acquired the state pertaining to the callback. For example, if session A is used to acquire a delegation, a request to recall the delegation MAY arrive over session B if both sessions are associated with the same client ID. Sections 2.10.8.1 and 2.10.8.2 discuss the security considerations around callbacks.",
      "ja": "（株予約、ロック、代表団、およびレイアウト（セクション1.7.4）で構成することができます）状態は、クライアントIDに関連付けられています。クライアントの状態は、個々のセッションに関連付けられていません。与えられた状態の所有者からの操作を変更する連続した状態が異なるセッションを介して行くことが、セッションは同じクライアントIDに関連付けられて。コールバックは、もともとコールバックに関連する状態を取得し、要求とは異なるセッションを超える到着するかもしれません。セッションAが委任を取得するために使用される場合、両方のセッションが同じクライアントIDに関連付けられている場合、例えば、委任をリコールする要求は、セッションB上に到達することができます。セクション2.10.8.1と2.10.8.2は、コールバックを中心に、セキュリティ上の考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "2.10.3. Channels",
      "section_title": true,
      "ja": "2.10.3. チャンネル"
    },
    {
      "indent": 3,
      "text": "A channel is not a connection. A channel represents the direction ONC RPC requests are sent.",
      "ja": "チャンネルは接続できません。チャネルは、ONC RPC要求が送信される方向を表します。"
    },
    {
      "indent": 3,
      "text": "Each session has one or two channels: the fore channel and the backchannel. Because there are at most two channels per session, and because each channel has a distinct purpose, channels are not assigned identifiers.",
      "ja": "前部チャネルおよびバックチャネル：各セッションは、1つのまたは2つのチャンネルを持っています。そこセッションあたり最大2つのチャンネルであり、各チャネルは明確な目的を持っているので、チャンネルは、識別子を割り当てられませんので。"
    },
    {
      "indent": 3,
      "text": "The fore channel is used for ordinary requests from the client to the server, and carries COMPOUND requests and responses. A session always has a fore channel.",
      "ja": "前部チャネルは、クライアントからサーバーへの通常の要求のために使用され、COMPOUND要求と応答を運ぶれます。セッションは常に前部チャネルを持っています。"
    },
    {
      "indent": 3,
      "text": "The backchannel is used for callback requests from server to client, and carries CB_COMPOUND requests and responses. Whether or not there is a backchannel is a decision made by the client; however, many features of NFSv4.1 require a backchannel. NFSv4.1 servers MUST support backchannels.",
      "ja": "バックチャネルは、サーバからクライアントへのコールバック要求に使用し、CB_COMPOUNDの要求と応答を運ぶれます。バックチャネルがあるかどうかは、クライアントによって行われた決定です。しかし、NFSv4.1の多くの機能は、バックチャネルが必要です。 NFSv4.1サーバーでは、backchannelsをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each session has resources for each channel, including separate reply caches (see Section 2.10.6.1). Note that even the backchannel requires a reply cache (or, at least, a slot table in order to detect retries) because some callback operations are nonidempotent.",
      "ja": "各セッションは、個別の応答キャッシュ（項2.10.6.1を参照）を含めた各チャネルのためのリソースを有しています。いくつかのコールバックオペレーションが非アイデンポテントであるためにもバックチャネルが応答キャッシュ（再試行を検出するために、または、少なくとも、スロットテーブル）を必要とすることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "2.10.3.1. Association of Connections, Channels, and Sessions",
      "section_title": true,
      "ja": "2.10.3.1。接続、チャンネル、およびセッションの協会"
    },
    {
      "indent": 3,
      "text": "Each channel is associated with zero or more transport connections (whether of the same transport protocol or different transport protocols). A connection can be associated with one channel or both channels of a session; the client and server negotiate whether a connection will carry traffic for one channel or both channels via the CREATE_SESSION (Section 18.36) and the BIND_CONN_TO_SESSION (Section 18.34) operations. When a session is created via CREATE_SESSION, the connection that transported the CREATE_SESSION request is automatically associated with the fore channel, and optionally the backchannel. If the client specifies no state protection (Section 18.35) when the session is created, then when SEQUENCE is transmitted on a different connection, the connection is automatically associated with the fore channel of the session specified in the SEQUENCE operation.",
      "ja": "各チャネルは、ゼロまたはそれ以上のトランスポート接続（同じトランスポートプロトコルまたは異なるトランスポートプロトコルのかどうか）と関連しています。接続は、一つのチャネルまたはセッションの両方のチャネルに関連付けることができます。クライアントとサーバは、接続がCREATE_SESSION（セクション18.36）とBIND_CONN_TO_SESSION（セクション18.34）の操作を介してチャネルまたは両方のチャネルのトラフィックを伝送するかどうかを交渉します。セッションがCREATE_SESSIONを介して作成されたとき、CREATE_SESSION要求を搬送接続が自動的に前方チャネルに関連付けられ、バックチャネルを任意れます。セッションが作成されると、クライアントは何のステート保護（セクション18.35）を指定しない場合はSEQUENCEは別の接続で送信された場合、その後、接続が自動的にSEQUENCE操作で指定されたセッションの前部チャネルに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "A connection's association with a session is not exclusive. A connection associated with the channel(s) of one session may be simultaneously associated with the channel(s) of other sessions including sessions associated with other client IDs.",
      "ja": "セッションとの接続の関連付けは、排他的ではありません。一つのセッションのチャネル（単数または複数）に関連付けられた接続が同時に他のクライアントIDに関連付けられたセッションを含む他のセッションのチャネル（複数可）に関連付けることができます。"
    },
    {
      "indent": 3,
      "text": "It is permissible for connections of multiple transport types to be associated with the same channel. For example, both TCP and RDMA connections can be associated with the fore channel. In the event an RDMA and non-RDMA connection are associated with the same channel, the maximum number of slots SHOULD be at least one more than the total number of RDMA credits (Section 2.10.6.1). This way, if all RDMA credits are used, the non-RDMA connection can have at least one outstanding request. If a server supports multiple transport types, it MUST allow a client to associate connections from each transport to a channel.",
      "ja": "複数のトランスポート・タイプの接続が同じチャネルに関連付けられることが許容されます。例えば、TCP及びRDMA接続の両方が前方チャネルに関連付けることができます。 RDMA非RDMA接続が同じチャネルに関連付けられている場合には、スロットの最大数は、RDMAクレジット（第2.10.6.1）の総数よりも少なくとも1以上であるべきです。すべてのRDMAのクレジットが使用されている場合は、この方法では、非RDMA接続が少なくとも一つの未処理の要求を持つことができます。サーバーが複数のトランスポートタイプをサポートしている場合、それは、クライアントがチャネルに各トランスポートからの接続を関連付けることができなければなりません。"
    },
    {
      "indent": 3,
      "text": "It is permissible for a connection of one type of transport to be associated with the fore channel, and a connection of a different type to be associated with the backchannel.",
      "ja": "輸送の一つのタイプの接続が前方チャネルに関連すること、および異なる種類の接続をバッ​​クチャネルに関連付けられることが許容されます。"
    },
    {
      "indent": 0,
      "text": "2.10.4. Server Scope",
      "section_title": true,
      "ja": "2.10.4. サーバースコープ"
    },
    {
      "indent": 3,
      "text": "Servers each specify a server scope value in the form of an opaque string eir_server_scope returned as part of the results of an EXCHANGE_ID operation. The purpose of the server scope is to allow a group of servers to indicate to clients that a set of servers sharing the same server scope value has arranged to use compatible values of otherwise opaque identifiers. Thus, the identifiers generated by one server of that set may be presented to another of that same scope.",
      "ja": "サーバは、各EXCHANGE_ID動作の結果の一部として返さ不透明ストリングeir_server_scopeの形でサーバスコープ値を指定します。サーバスコープの目的は、サーバのグループが同じサーバスコープ値を共有サーバのセットは、そうでなければ不透明な識別子の互換性のある値を使用するように構成されたことをクライアントに知らせるようにすることです。したがって、そのセットの1台のサーバによって生成された識別子が同じスコープの他に提示することができます。"
    },
    {
      "indent": 3,
      "text": "The use of such compatible values does not imply that a value generated by one server will always be accepted by another. In most cases, it will not. However, a server will not accept a value generated by another inadvertently. When it does accept it, it will be because it is recognized as valid and carrying the same meaning as on another server of the same scope.",
      "ja": "このような互換性のある値の使用は、一つのサーバによって生成された値は、常に別に受け入れられるであろうことを意味するものではありません。ほとんどの場合、それはしません。ただし、サーバは別の不注意によって生成された値を受け入れません。それはそれを受け入れない場合、それは有効なものとして、同じスコープの別のサーバー上と同じ意味を運んで認識されているので、それは次のようになります。"
    },
    {
      "indent": 3,
      "text": "When servers are of the same server scope, this compatibility of values applies to the follow identifiers: o Filehandle values. A filehandle value accepted by two servers of the same server scope denotes the same object. A WRITE operation sent to one server is reflected immediately in a READ sent to the other, and locks obtained on one server conflict with those requested on the other.",
      "ja": "ファイルハンドル値O：サーバーは、同じサーバーの範囲である場合には、この値の互換性は以下の識別子に適用されます。同じサーバスコープの二つのサーバによって受け入れファイルハンドル値が同じオブジェクトを表しています。一つのサーバに送信された書き込み動作は、他に送信READに直ちに反映され、ロックが他に要求されたものと1つのサーバーの競合で得られました。"
    },
    {
      "indent": 3,
      "text": "o Session ID values. A session ID value accepted by two servers of the same server scope denotes the same session.",
      "ja": "セッションID値O。同じサーバー・スコープの二つのサーバによって受け入れられたセッションIDの値が同じセッションを示しています。"
    },
    {
      "indent": 3,
      "text": "o Client ID values. A client ID value accepted as valid by two servers of the same server scope is associated with two clients with the same client owner and verifier.",
      "ja": "クライアントID値O。同じサーバー・スコープの二つのサーバで有効なものとして受け入れられたクライアントIDの値が同じクライアント所有者と検証との2つのクライアントに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "o State ID values. A state ID value is recognized as valid when the corresponding client ID is recognized as valid. If the same stateid value is accepted as valid on two servers of the same scope and the client IDs on the two servers represent the same client owner and verifier, then the two stateid values designate the same set of locks and are for the same file.",
      "ja": "州ID値O。対応するクライアントIDが有効であると認識されたときの状態のID値は、有効なものとして認識されています。同じのstateid値は同じスコープの二つのサーバ上で有効なものとして受け入れられ、二つのサーバ上のクライアントIDが同じクライアント所有者と検証を表している場合、2つのstateid値はロックの同じセットを指定し、同じファイルのためのものです。"
    },
    {
      "indent": 3,
      "text": "o Server owner values. When the server scope values are the same, server owner value may be validly compared. In cases where the server scope values are different, server owner values are treated as different even if they contain all identical bytes.",
      "ja": "Oサーバの所有者値。サーバスコープの値が同じである場合、サーバの所有者の値が有効に比較することができます。サーバスコープの値が異なる場合には、サーバの所有者の値は、それらがすべて同じバイトを含む場合であっても異なるように扱われます。"
    },
    {
      "indent": 3,
      "text": "The coordination among servers required to provide such compatibility can be quite minimal, and limited to a simple partition of the ID space. The recognition of common values requires additional implementation, but this can be tailored to the specific situations in which that recognition is desired.",
      "ja": "そのような互換性を提供するために必要なサーバー間の調整は非常に最小限の、およびIDスペースの簡単なパーティションに制限することができます。一般的な値の認識は、追加の実装を必要とするが、これは、その認識が望まれる特定の状況に合わせて調整することができます。"
    },
    {
      "indent": 3,
      "text": "Clients will have occasion to compare the server scope values of multiple servers under a number of circumstances, each of which will be discussed under the appropriate functional section:",
      "ja": "クライアントは、適切な機能部の下に議論されるそれぞれが多くの状況下で複数のサーバーのサーバースコープ値を比較する機会を有することになります。"
    },
    {
      "indent": 3,
      "text": "o When server owner values received in response to EXCHANGE_ID operations sent to multiple network addresses are compared for the purpose of determining the validity of various forms of trunking, as described in Section 2.10.5.",
      "ja": "セクション2.10.5に記載されているようにO、複数のネットワークアドレスに送信EXCHANGE_ID操作に応答して受信したサーバの所有者の値は、トランキングの様々な形態の有効性を決定するために比較した場合。"
    },
    {
      "indent": 3,
      "text": "o When network or server reconfiguration causes the same network address to possibly be directed to different servers, with the necessity for the client to determine when lock reclaim should be attempted, as described in Section 8.4.2.1.",
      "ja": "ネットワークやサーバーの再構成が同一のネットワークアドレスを起こした場合、O、おそらくセクション8.4.2.1で説明したように、ロックの再利用は、試みるべきかを決定するために、クライアントのために必要で、別のサーバーに送られます。"
    },
    {
      "indent": 3,
      "text": "o When file system migration causes the transfer of responsibility for a file system between servers and the client needs to determine whether state has been transferred with the file system (as described in Section 11.7.7) or whether the client needs to reclaim state on a similar basis as in the case of server restart, as described in Section 8.4.2.",
      "ja": "Oファイルシステムの移行は、サーバ間のファイルシステムの責任の転送を引き起こし、クライアント状態はファイルシステムで転送されたかどうか（セクション11.7.7に記載されているように）、またはクライアントは、A上の状態を再利用する必要があるかどうかを決定する必要がある場合8.4.2項で説明したように、サーバの再起動の場合と同様の基礎、。"
    },
    {
      "indent": 3,
      "text": "When two replies from EXCHANGE_ID, each from two different server network addresses, have the same server scope, there are a number of ways a client can validate that the common server scope is due to two servers cooperating in a group.",
      "ja": "EXCHANGE_IDから2件の回答、2つの異なるサーバー・ネットワークアドレスからそれぞれが、同じサーバーのスコープを持っている場合は、クライアントは一般的なサーバーのスコープがグループで協力二つのサーバによるものであることを検証することができますいくつかの方法があります。"
    },
    {
      "indent": 3,
      "text": "o If both EXCHANGE_ID requests were sent with RPCSEC_GSS authentication and the server principal is the same for both targets, the equality of server scope is validated. It is RECOMMENDED that two servers intending to share the same server scope also share the same principal name.",
      "ja": "両方EXCHANGE_ID要求がRPCSEC_GSS認証で送信され、サーバープリンシパルは、両方のターゲットでも同じですしていた場合、O、サーバースコープの平等が検証されます。同じサーバーのスコープを共有しようとする2台のサーバーが、同じプリンシパル名を共有することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "o The client may accept the appearance of the second server in the fs_locations or fs_locations_info attribute for a relevant file system. For example, if there is a migration event for a particular file system or there are locks to be reclaimed on a particular file system, the attributes for that particular file system may be used. The client sends the GETATTR request to the first server for the fs_locations or fs_locations_info attribute with RPCSEC_GSS authentication. It may need to do this in advance of the need to verify the common server scope. If the client successfully authenticates the reply to GETATTR, and the GETATTR request and reply containing the fs_locations or fs_locations_info attribute refers to the second server, then the equality of server scope is supported. A client may choose to limit the use of this form of support to information relevant to the specific file system involved (e.g. a file system being migrated).",
      "ja": "Oクライアントは、関連するファイルシステムのfs_位置における第二のサーバの外観やfs_locations_info属性を受け入れることができます。移行イベントは、特定のファイルシステムに存在するか、または特定のファイルシステム上に再生されるべきロックがある場合、例えば、その特定のファイル・システムの属性を使用してもよいです。クライアントは、RPCSEC_GSS認証でfs_位置やfs_locations_info属性の最初のサーバにGETATTR要求を送信します。これは、一般的なサーバーのスコープを検証する必要の前にこれを実行する必要があるかもしれません。クライアントが正常にfs_位置を含むGETATTRへの応答、およびGETATTR要求と応答を認証または属性fs_locations_info第二のサーバを参照する場合は、サーバースコープの平等がサポートされています。クライアントは、（移行される例えば、ファイルシステム）関与する特定のファイルシステムに関連する情報への支援は、このフォームの使用を制限することを選択することができます。"
    },
    {
      "indent": 0,
      "text": "2.10.5. Trunking",
      "section_title": true,
      "ja": "2.10.5. トランキング"
    },
    {
      "indent": 3,
      "text": "Trunking is the use of multiple connections between a client and server in order to increase the speed of data transfer. NFSv4.1 supports two types of trunking: session trunking and client ID trunking.",
      "ja": "トランキングは、データ転送速度を向上させるために、クライアントとサーバ間の複数の接続を使用することです。セッションのトランキングおよびクライアントIDのトランキング：NFSv4.1は、トランキングの2種類をサポートしています。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 servers MUST support both forms of trunking within the context of a single server network address and MUST support both forms within the context of the set of network addresses used to access a single server. NFSv4.1 servers in a clustered configuration MAY allow network addresses for different servers to use client ID trunking.",
      "ja": "NFSv4.1サーバは、単一のサーバのネットワークアドレスのコンテキスト内でのトランキングの両方の形式をサポートしなければならないし、単一のサーバーにアクセスするために使用されるネットワークアドレスのセットのコンテキスト内で両方の形式をサポートしなければなりません。クラスタ構成でのNFSv4.1サーバーが異なるサーバーのためのネットワークアドレスは、クライアントIDのトランキングを使用することを可能にします。"
    },
    {
      "indent": 3,
      "text": "Clients may use either form of trunking as long as they do not, when trunking between different server network addresses, violate the servers' mandates as to the kinds of trunking to be allowed (see below). With regard to callback channels, the client MUST allow the server to choose among all callback channels valid for a given client ID and MUST support trunking when the connections supporting the backchannel allow session or client ID trunking to be used for callbacks.",
      "ja": "クライアントは別のサーバーネットワークアドレスの間でトランキングする場合、限り、そうではないとして、トランキングのいずれかの形式を使用します（下記参照）を許可するトランキングの種類に関して、サーバの義務に違反する可能性があります。コールバック・チャネルに関しては、クライアントは、サーバが特定のクライアントIDの有効なすべてのコールバックチャンネルの中から選択することを可能にしなければならなくて、バックチャネルをサポートしている接続は、セッションまたはクライアントIDトランキングは、コールバックのために使用することができるようにするとき、トランキングをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Session trunking is essentially the association of multiple connections, each with potentially different target and/or source network addresses, to the same session. When the target network addresses (server addresses) of the two connections are the same, the server MUST support such session trunking. When the target network addresses are different, the server MAY indicate such support using the data returned by the EXCHANGE_ID operation (see below).",
      "ja": "セッションのトランキングは、本質的に同じセッションに潜在的に異なる標的および/またはソース・ネットワーク・アドレスを持つ複数の接続の関連付け、それぞれ、です。 2つの接続のターゲット・ネットワーク・アドレス（サーバアドレス）が同一である場合、サーバは、セッションのトランキングをサポートしなければなりません。ターゲットネットワークアドレスが異なる場合、サーバは（下記参照）EXCHANGE_ID操作で返されたデータを使用して、このようなサポートを示すことがあります。"
    },
    {
      "indent": 3,
      "text": "Client ID trunking is the association of multiple sessions to the same client ID. Servers MUST support client ID trunking for two target network addresses whenever they allow session trunking for those same two network addresses. In addition, a server MAY, by presenting the same major server owner ID (Section 2.5) and server scope (Section 2.10.4), allow an additional case of client ID trunking. When two servers return the same major server owner and server scope, it means that the two servers are cooperating on locking state management, which is a prerequisite for client ID trunking.",
      "ja": "クライアントIDトランキングは、同じクライアントIDに複数のセッションの団体です。サーバーは、彼らがそれらの同じ2つのネットワークアドレスのセッショントランキングを許可したときに2つのターゲットネットワークアドレス用のクライアントIDトランキングをサポートしなければなりません。また、サーバは、同一の主要なサーバ所有者ID（セクション2.5）とサーバースコープ（セクション2.10.4）を提示することによって、クライアントIDトランキングの追加のケースを可能にすることができます。 2つのサーバーが同じ主要なサーバーの所有者とサーバースコープを返すとき、それは2台のサーバーがクライアントIDトランキングのための前提条件であるロック状態の管理、上で協力していることを意味します。"
    },
    {
      "indent": 3,
      "text": "Distinguishing when the client is allowed to use session and client ID trunking requires understanding how the results of the EXCHANGE_ID (Section 18.35) operation identify a server. Suppose a client sends EXCHANGE_IDs over two different connections, each with a possibly different target network address, but each EXCHANGE_ID operation has the same value in the eia_clientowner field. If the same NFSv4.1 server is listening over each connection, then each EXCHANGE_ID result MUST return the same values of eir_clientid, eir_server_owner.so_major_id, and eir_server_scope. The client can then treat each connection as referring to the same server (subject to verification; see Section 2.10.5.1 later in this section), and it can use each connection to trunk requests and replies. The client's choice is whether session trunking or client ID trunking applies.",
      "ja": "クライアントがセッションおよびクライアントIDのトランキングを使用することを許可されたときに区別することはEXCHANGE_ID（セクション18.35）演算の結果は、サーバを識別する方法を理解することが必要です。クライアントは、おそらく別のターゲット・ネットワーク・アドレスを持つ2つの異なる接続、各オーバーEXCHANGE_IDsを送信しますが、各EXCHANGE_ID操作がeia_clientownerフィールドに同じ値を持っていると仮定します。同じNFSv4.1サーバーが各接続を介して待機している場合、各EXCHANGE_ID結果はeir_clientid、eir_server_owner.so_major_id、およびeir_server_scopeの同じ値を返さなければなりません。クライアントは、同じサーバー（検証の対象;このセクションで後述のセクション2.10.5.1を参照）を参照すると、各接続を扱うことができ、それはトランク要求および応答への各接続を使用することができます。クライアントの選択はセッションのトランキングやクライアントIDトランキングが適用されるかどうかです。"
    },
    {
      "indent": 3,
      "text": "Session Trunking. If the eia_clientowner argument is the same in two different EXCHANGE_ID requests, and the eir_clientid, eir_server_owner.so_major_id, eir_server_owner.so_minor_id, and eir_server_scope results match in both EXCHANGE_ID results, then the client is permitted to perform session trunking. If the client has no session mapping to the tuple of eir_clientid, eir_server_owner.so_major_id, eir_server_scope, and eir_server_owner.so_minor_id, then it creates the session via a CREATE_SESSION operation over one of the connections, which associates the connection to the session. If there is a session for the tuple, the client can send BIND_CONN_TO_SESSION to associate the connection to the session.",
      "ja": "セッションのトランキング。 eia_clientowner引数は、二つの異なるEXCHANGE_IDリクエストで同じであり、両方EXCHANGE_ID結果でeir_clientid、eir_server_owner.so_major_id、eir_server_owner.so_minor_id、およびeir_server_scopeの結果が一致するが、その後、クライアントは、セッションのトランキングを実行するために許可されている場合。クライアントはeir_clientid、eir_server_owner.so_major_id、eir_server_scope、およびeir_server_owner.so_minor_idのタプルへのセッションのマッピングを持っていない場合、それは、セッションへの接続を関連付け接続の一つ、上CREATE_SESSION操作を経てセッションを作成します。タプルのセッションがある場合、クライアントは、セッションへの接続を関連付けるBIND_CONN_TO_SESSIONを送ることができます。"
    },
    {
      "indent": 6,
      "text": "Of course, if the client does not desire to use session trunking, it is not required to do so. It can invoke CREATE_SESSION on the connection. This will result in client ID trunking as described below. It can also decide to drop the connection if it does not choose to use trunking.",
      "ja": "クライアントがセッションのトランキングを使用することを希望しない場合はもちろん、そうする必要はありません。これは、接続上CREATE_SESSIONを呼び出すことができます。後述のようにこれは、クライアントIDのトランクになります。また、それがトランキングを使用することを選択しない場合、接続をドロップすることを決定することができます。"
    },
    {
      "indent": 3,
      "text": "Client ID Trunking. If the eia_clientowner argument is the same in two different EXCHANGE_ID requests, and the eir_clientid, eir_server_owner.so_major_id, and eir_server_scope results match in both EXCHANGE_ID results, then the client is permitted to perform client ID trunking (regardless of whether the eir_server_owner.so_minor_id results match). The client can associate each connection with different sessions, where each session is associated with the same server.",
      "ja": "クライアントIDトランキング。 eia_clientowner引数は、2つの異なるEXCHANGE_IDリクエストに同じ、両方EXCHANGE_ID結果にeir_clientid、eir_server_owner.so_major_id、及びeir_server_scope結果が一致である場合、クライアントは、（関係なく、クライアントIDトランキングを実行することが許可されeir_server_owner.so_minor_id結果が一致するかどうか）。クライアントは、各セッションは、同じサーバーに関連付けられている別のセッションとの各接続を関連付けることができます。"
    },
    {
      "indent": 6,
      "text": "The client completes the act of client ID trunking by invoking CREATE_SESSION on each connection, using the same client ID that was returned in eir_clientid. These invocations create two sessions and also associate each connection with its respective session. The client is free to decline to use client ID trunking by simply dropping the connection at this point.",
      "ja": "クライアントはeir_clientidで返されたのと同じクライアントIDを使用して、接続ごとにCREATE_SESSIONを呼び出すことによって、クライアントのIDトランキングの行為を完了します。これらの呼び出しは、二つのセッションを作成しても、それぞれのセッションとの各接続を関連付けます。クライアントは、単にこの時点で、接続をドロップすることによって、クライアントのIDトランキングを使用することを拒否して自由です。"
    },
    {
      "indent": 6,
      "text": "When doing client ID trunking, locking state is shared across sessions associated with that same client ID. This requires the server to coordinate state across sessions.",
      "ja": "クライアントIDトランキングを行う場合、ロック状態は、同じクライアントIDに関連付けられているセッション間で共有されています。これは、セッション間で状態を調整するためにサーバを必要とします。"
    },
    {
      "indent": 3,
      "text": "The client should be prepared for the possibility that eir_server_owner values may be different on subsequent EXCHANGE_ID requests made to the same network address, as a result of various sorts of reconfiguration events. When this happens and the changes result in the invalidation of previously valid forms of trunking, the client should cease to use those forms, either by dropping connections or by adding sessions. For a discussion of lock reclaim as it relates to such reconfiguration events, see Section 8.4.2.1.",
      "ja": "クライアントは、再構成イベントの各種の結果として、値が同じネットワークアドレスに加えられた後続EXCHANGE_ID要求に異なっていてもよいeir_server_owner可能性のために準備されるべきです。これが起こると変更はトランキングの前に有効な形式の無効化につながる場合には、クライアントが接続を切断するか、追加のセッションのいずれかによって、これらのフォームを使用するのをやめるべきです。それは、このような再構成イベントに関連するロックの議論のために再利用、セクション8.4.2.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.10.5.1. Verifying Claims of Matching Server Identity",
      "section_title": true,
      "ja": "2.10.5.1。マッチングサーバのアイデンティティの主張を検証"
    },
    {
      "indent": 3,
      "text": "When two servers over two connections claim matching or partially matching eir_server_owner, eir_server_scope, and eir_clientid values, the client does not have to trust the servers' claims. The client may verify these claims before trunking traffic in the following ways: o For session trunking, clients SHOULD reliably verify if connections between different network paths are in fact associated with the same NFSv4.1 server and usable on the same session, and servers MUST allow clients to perform reliable verification. When a client ID is created, the client SHOULD specify that BIND_CONN_TO_SESSION is to be verified according to the SP4_SSV or SP4_MACH_CRED (Section 18.35) state protection options. For SP4_SSV, reliable verification depends on a shared secret (the SSV) that is established via the SET_SSV (Section 18.47) operation.",
      "ja": "2つの接続を介して2台のサーバーが一致または部分一致eir_server_owner、eir_server_scope、およびeir_clientid値を主張する場合、クライアントはサーバの主張を信用する必要はありません。異なるネットワークパス間の接続は、実際に同じセッションで同じNFSv4.1サーバーおよび使用可能に関連付けられている場合、セッショントランキングのためにoは、クライアントが確実に確認する必要があり、サーバーは、必要があります。クライアントは、次の方法でトラフィックをトランキングする前に、これらの主張を確認することができますクライアントは、信頼性の高い検証を行うことを可能にします。クライアントIDが作成されると、クライアントはBIND_CONN_TO_SESSIONがSP4_SSVまたはSP4_MACH_CRED（セクション18.35）状態の保護オプションに従って検証されるべきであることを指定する必要があります。 SP4_SSVのために、信頼性の検証がSET_SSV（セクション18.47）の操作を介して確立された共有秘密（SSV）に依存します。"
    },
    {
      "indent": 6,
      "text": "When a new connection is associated with the session (via the BIND_CONN_TO_SESSION operation, see Section 18.34), if the client specified SP4_SSV state protection for the BIND_CONN_TO_SESSION operation, the client MUST send the BIND_CONN_TO_SESSION with RPCSEC_GSS protection, using integrity or privacy, and an RPCSEC_GSS handle created with the GSS SSV mechanism (Section 2.10.9).",
      "ja": "新しい接続が（項18.34を参照してください、BIND_CONN_TO_SESSION操作によって）セッションに関連付けられている場合、クライアントはBIND_CONN_TO_SESSION動作にSP4_SSV状態の保護を指定した場合、クライアントはRPCSEC_GSS保護、整合性やプライバシーを使用して、およびRPCSEC_GSSでBIND_CONN_TO_SESSIONを送らなければなりませんGSS SSVメカニズム（セクション2.10.9）で作成したハンドル。"
    },
    {
      "indent": 6,
      "text": "If the client mistakenly tries to associate a connection to a session of a wrong server, the server will either reject the attempt because it is not aware of the session identifier of the BIND_CONN_TO_SESSION arguments, or it will reject the attempt because the RPCSEC_GSS authentication fails. Even if the server mistakenly or maliciously accepts the connection association attempt, the RPCSEC_GSS verifier it computes in the response will not be verified by the client, so the client will know it cannot use the connection for trunking the specified session.",
      "ja": "クライアントが誤って間違ったサーバーのセッションへの接続を関連付けしようとすると、それはBIND_CONN_TO_SESSION引数のセッション識別子を認識していないため、サーバが試みを拒否するか、またはRPCSEC_GSS認証が失敗したので、それは試みを拒否します。サーバーが誤ってまたは故意の接続関連の試みを受け入れたとしても、それが応答で計算しRPCSEC_GSS検証は、クライアントによって検証されることはありませんので、クライアントは、それが指定されたセッションをトランキング用の接続を使用することはできません知っているだろう。"
    },
    {
      "indent": 6,
      "text": "If the client specified SP4_MACH_CRED state protection, the BIND_CONN_TO_SESSION operation will use RPCSEC_GSS integrity or privacy, using the same credential that was used when the client ID was created. Mutual authentication via RPCSEC_GSS assures the client that the connection is associated with the correct session of the correct server.",
      "ja": "クライアントはSP4_MACH_CRED状態の保護を指定した場合、BIND_CONN_TO_SESSION操作はクライアントIDが作成されたときに使用したのと同じ資格情報を使用して、RPCSEC_GSSの整合性やプライバシーを使用します。 RPCSEC_GSSを介した相互認証は、接続が正しいサーバーの正しいセッションに関連付けられているクライアントを保証します。"
    },
    {
      "indent": 3,
      "text": "o For client ID trunking, the client has at least two options for verifying that the same client ID obtained from two different EXCHANGE_ID operations came from the same server. The first option is to use RPCSEC_GSS authentication when sending each EXCHANGE_ID operation. Each time an EXCHANGE_ID is sent with RPCSEC_GSS authentication, the client notes the principal name of the GSS target. If the EXCHANGE_ID results indicate that client ID trunking is possible, and the GSS targets' principal names are the same, the servers are the same and client ID trunking is allowed.",
      "ja": "OクライアントIDトランキングの場合、クライアントは、二つの異なるEXCHANGE_ID操作から得た同じクライアントIDが同じサーバから来たことを検証するための少なくとも2つのオプションがあります。最初のオプションは、各EXCHANGE_ID操作を送信するときにRPCSEC_GSS認証を使用することです。 EXCHANGE_IDはRPCSEC_GSS認証で送信されるたびに、クライアントはGSSの対象のプリンシパル名を指摘しています。 EXCHANGE_ID結果がクライアントIDトランキングが可能であることを示している、とGSSのターゲットのプリンシパル名が同じである場合、サーバは同じとクライアントIDトランキングが許可されています。"
    },
    {
      "indent": 6,
      "text": "The second option for verification is to use SP4_SSV protection. When the client sends EXCHANGE_ID, it specifies SP4_SSV protection. The first EXCHANGE_ID the client sends always has to be confirmed by a CREATE_SESSION call. The client then sends SET_SSV. Later, the client sends EXCHANGE_ID to a second destination network address different from the one the first EXCHANGE_ID was sent to. The client checks that each EXCHANGE_ID reply has the same eir_clientid, eir_server_owner.so_major_id, and eir_server_scope. If so, the client verifies the claim by sending a CREATE_SESSION operation to the second destination address, protected with RPCSEC_GSS integrity using an RPCSEC_GSS handle returned by the second EXCHANGE_ID. If the server accepts the CREATE_SESSION request, and if the client verifies the RPCSEC_GSS verifier and integrity codes, then the client has proof the second server knows the SSV, and thus the two servers are cooperating for the purposes of specifying server scope and client ID trunking.",
      "ja": "確認のため2番目のオプションは、SP4_SSV保護を使用することです。クライアントがEXCHANGE_IDを送信するとき、それはSP4_SSV保護を指定します。クライアントは常に送信最初EXCHANGE_IDはCREATE_SESSIONコールによって確認する必要があります。その後、クライアントはSET_SSVを送信します。その後、クライアントは最初EXCHANGE_IDが送られたものとは異なる第二の宛先ネットワークアドレスにEXCHANGE_IDを送信します。各EXCHANGE_ID応答が同じeir_clientid、eir_server_owner.so_major_id、およびeir_server_scopeを持つクライアントをチェックします。その場合、クライアントは、第二EXCHANGE_IDによって返さRPCSEC_GSSハンドルを使用してRPCSEC_GSSの整合性を保護し、第二宛先アドレスにCREATE_SESSION操作を送信することにより、請求を検証します。サーバーはCREATE_SESSION要求を受け付け、そしてクライアントはRPCSEC_GSS検証と整合性のコードを確認した場合、クライアントは証明を持っている2番目のサーバーは、SSVを知っているので、2台のサーバーが、サーバーのスコープを指定する目的のために協力し、クライアントIDトランキングされている場合。"
    },
    {
      "indent": 0,
      "text": "2.10.6. Exactly Once Semantics",
      "section_title": true,
      "ja": "2.10.6. 正確に一度セマンティクス"
    },
    {
      "indent": 3,
      "text": "Via the session, NFSv4.1 offers exactly once semantics (EOS) for requests sent over a channel. EOS is supported on both the fore channel and backchannel.",
      "ja": "セッションを介して、NFSv4.1は、チャネルを介して送信された要求のために正確に一度のセマンティクス（EOS）を提供しています。 EOSは、前部チャネルおよびバックチャネルの両方でサポートされています。"
    },
    {
      "indent": 3,
      "text": "Each COMPOUND or CB_COMPOUND request that is sent with a leading SEQUENCE or CB_SEQUENCE operation MUST be executed by the receiver exactly once. This requirement holds regardless of whether the request is sent with reply caching specified (see Section 2.10.6.1.3). The requirement holds even if the requester is sending the request over a session created between a pNFS data client and pNFS data server. To understand the rationale for this requirement, divide the requests into three classifications:",
      "ja": "先導配列またはCB_SEQUENCE操作で送信される各化合物またはCB_COMPOUND要求が一度だけ受信機によって実行されなければなりません。この要件にかかわらず、要求が指定された応答をキャッシュに送信されたかどうかの保持（セクション2.10.6.1.3を参照してください）。要件は、要求者がpNFSのデータクライアントとのpNFSデータサーバの間に作成されたセッションを介して要求を送信した場合でも保持しています。この要件の根拠を理解するために、3つの分類にリクエストを分割："
    },
    {
      "indent": 3,
      "text": "o Non-idempotent requests.",
      "ja": "O非べき等要求。"
    },
    {
      "indent": 3,
      "text": "o Idempotent modifying requests.",
      "ja": "Oべき等は要求を修正します。"
    },
    {
      "indent": 3,
      "text": "o Idempotent non-modifying requests.",
      "ja": "Oべき等非修正を要求。"
    },
    {
      "indent": 3,
      "text": "An example of a non-idempotent request is RENAME. Obviously, if a replier executes the same RENAME request twice, and the first execution succeeds, the re-execution will fail. If the replier returns the result from the re-execution, this result is incorrect. Therefore, EOS is required for non-idempotent requests.",
      "ja": "非べき等要求の例は、RENAMEです。リプライヤは二度同じRENAME要求を実行し、最初の実行が成功した場合明らかに、再実行が失敗します。リプライヤが再実行から結果を返す場合、この結果は正しくありません。そのため、EOSは、非冪等の要求のために必要とされます。"
    },
    {
      "indent": 3,
      "text": "An example of an idempotent modifying request is a COMPOUND request containing a WRITE operation. Repeated execution of the same WRITE has the same effect as execution of that WRITE a single time. Nevertheless, enforcing EOS for WRITEs and other idempotent modifying requests is necessary to avoid data corruption.",
      "ja": "要求を変更する冪等の例は、書き込み動作を含む化合物の要求です。同じ書き込みの繰り返し実行はそれが単一の時間を書く実行と同じ効果を有します。それにも関わらず、書き込み、他の冪等の変更要求のためのEOSを施行すると、データの破損を回避する必要があります。"
    },
    {
      "indent": 3,
      "text": "Suppose a client sends WRITE A to a noncompliant server that does not enforce EOS, and receives no response, perhaps due to a network partition. The client reconnects to the server and re-sends WRITE A. Now, the server has outstanding two instances of A. The server can be in a situation in which it executes and replies to the retry of A, while the first A is still waiting in the server's internal I/O system for some resource. Upon receiving the reply to the second attempt of WRITE A, the client believes its WRITE is done so it is free to send WRITE B, which overlaps the byte-range of A. When the original A is dispatched from the server's I/O system and executed (thus the second time A will have been written), then what has been written by B can be overwritten and thus corrupted.",
      "ja": "クライアントは、EOSを強制することはありません非準拠のサーバーへの書き込みAを送信し、おそらくネットワークパーティションに、応答を受信しないと仮定します。最初のAはまだ待っている間に、クライアントがサーバーに再接続し、サーバはサーバが実行され、Aの再試行に応答する状況にあることができるA.の優れた2件のインスタンスがあり、今WRITE Aを再送信しますいくつかのリソースのために、サーバの内部I / OシステムインチWRITEのAの第二の試みに対する応答を受信すると、クライアントは、元Aは、サーバのI / Oシステムから派遣された場合A.のバイト範囲と重なるWRITE Bを、送信して自由であるように、その書き込みが行われていると考えています及び（従って第二の時間Aが書き込まれているであろう）を実行し、Bによって書かれた内容が上書きされ、したがって、破損させることができます。"
    },
    {
      "indent": 3,
      "text": "An example of an idempotent non-modifying request is a COMPOUND containing SEQUENCE, PUTFH, READLINK, and nothing else. The re-execution of such a request will not cause data corruption or produce an incorrect result. Nonetheless, to keep the implementation simple, the replier MUST enforce EOS for all requests, whether or not idempotent and non-modifying.",
      "ja": "冪等非変更要求の例は、SEQUENCE、PUTFH、READLINK、そして他には何を含む化合物です。そのような要求の再実行は、データの破損が発生したり、不正確な結果を生成しません。それにもかかわらず、実装をシンプルに保つために、リプライヤは冪等と非改かどうかにかかわらず、すべての要求のためのEOSを施行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that true and complete EOS is not possible unless the server persists the reply cache in stable storage, and unless the server is somehow implemented to never require a restart (indeed, if such a server exists, the distinction between a reply cache kept in stable storage versus one that is not is one without meaning). See Section 2.10.6.5 for a discussion of persistence in the reply cache. Regardless, even if the server does not persist the reply cache, EOS improves robustness and correctness over previous versions of NFS because the legacy duplicate request/reply caches were based on the ONC RPC transaction identifier (XID). Section 2.10.6.1 explains the shortcomings of the XID as a basis for a reply cache and describes how NFSv4.1 sessions improve upon the XID.",
      "ja": "サーバが安定したストレージに返信キャッシュを持続しない限り、その真実かつ完全なEOSが不可能であることに注意してください、そしてサーバが何らかの形で応答キャッシュの区別が安定に保たれ、そのようなサーバが存在する場合は、実際に（再起動する必要がないように実装されていない限り、ない1対ストレージは意味のないもの）です。回答キャッシュにおける持続性の議論については、セクション2.10.6.5を参照してください。レガシー/リクエストが重複キャッシュはONC RPCのトランザクションID（XID）に基づいた返信ためにかかわらず、サーバーが応答キャッシュを保持していない場合でも、EOSは、NFSの以前のバージョンに比べて堅牢性と正確性を向上させます。セクション2.10.6.1は、返信キャッシュのための基礎としてXIDの欠点を説明し、NFSv4.1セッションはXIDを改善する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "2.10.6.1. Slot Identifiers and Reply Cache",
      "section_title": true,
      "ja": "2.10.6.1。スロット識別子と返信キャッシュ"
    },
    {
      "indent": 3,
      "text": "The RPC layer provides a transaction ID (XID), which, while required to be unique, is not convenient for tracking requests for two reasons. First, the XID is only meaningful to the requester; it cannot be interpreted by the replier except to test for equality with previously sent requests. When consulting an RPC-based duplicate request cache, the opaqueness of the XID requires a computationally expensive look up (often via a hash that includes XID and source address). NFSv4.1 requests use a non-opaque slot ID, which is an index into a slot table, which is far more efficient. Second, because RPC requests can be executed by the replier in any order, there is no bound on the number of requests that may be outstanding at any time. To achieve perfect EOS, using ONC RPC would require storing all replies in the reply cache. XIDs are 32 bits; storing over four billion (2^32) replies in the reply cache is not practical. In practice, previous versions of NFS have chosen to store a fixed number of replies in the cache, and to use a least recently used (LRU) approach to replacing cache entries with new entries when the cache is full. In NFSv4.1, the number of outstanding requests is bounded by the size of the slot table, and a sequence ID per slot is used to tell the replier when it is safe to delete a cached reply.",
      "ja": "RPC層は、一意である必要ながら、二つの理由で要求を追跡するのに便利ではない、トランザクションID（XID）を提供します。まず、XIDは、依頼者にのみ意味があります。それは、以前に送信された要求と平等のためのテストを除いてリプライヤによって解釈することはできません。 RPCベースの重複要求キャッシュに相談すると、XIDの不透明性は、（多くの場合、XIDと送信元アドレスが含まれてハッシュを経由して）計算コストルックアップが必要です。 NFSv4.1要求がはるかに効率的であるスロットテーブルへのインデックス、非不透明スロットIDを、使用します。 RPC要求は、任意の順序でリプライヤで実行することができますので、第二に、任意の時点で未解決かもしれリクエストの数には限界がありません。完璧なEOSを達成するために、ONC RPCを使用すると、応答キャッシュ内のすべての返信を保存する必要になります。 XIDは32ビットです。 40億（2 ^ 32）上に格納するキャッシュは実用的でない応答で応答します。実際には、NFSの以前のバージョンは、キャッシュ内の応答の固定数を記憶するために、キャッシュがいっぱいになると、新しいエントリがキャッシュ・エントリを置換する最低使用頻度（LRU）アプローチを使用することを選択しました。 NFSv4.1では、未処理の要求の数は、スロットテーブルのサイズによって制限され、スロットあたりのシーケンスIDは、キャッシュされた回答を削除しても安全であるときリプライヤを伝えるために使用されています。"
    },
    {
      "indent": 3,
      "text": "In the NFSv4.1 reply cache, when the requester sends a new request, it selects a slot ID in the range 0..N, where N is the replier's current maximum slot ID granted to the requester on the session over which the request is to be sent. The value of N starts out as equal to ca_maxrequests - 1 (Section 18.36), but can be adjusted by the response to SEQUENCE or CB_SEQUENCE as described later in this section. The slot ID must be unused by any of the requests that the requester has already active on the session. \"Unused\" here means the requester has no outstanding request for that slot ID.",
      "ja": "リクエスタが新しい要求を送信NFSv4.1応答キャッシュでは、Nは、回答者の現在の最大スロットID要求がある上にセッションで要求者に付与される範囲0..N、スロットIDを選択します送信されます。 1（セクション18.36）が、このセクションで後述するように配列またはCB_SEQUENCEに応答することによって調整することができる -  Nの値はca_maxrequestsに等しいとして出発する。スロットIDは、要求者がセッションに既に活性を有する要求のいずれかにより未使用でなければなりません。ここでは「未使用」とは、要求者がそのスロットIDの未解決の要求を持っていないことを意味します。"
    },
    {
      "indent": 3,
      "text": "A slot contains a sequence ID and the cached reply corresponding to the request sent with that sequence ID. The sequence ID is a 32-bit unsigned value, and is therefore in the range 0..0xFFFFFFFF (2^32 - 1). The first time a slot is used, the requester MUST specify a sequence ID of one (Section 18.36). Each time a slot is reused, the request MUST specify a sequence ID that is one greater than that of the previous request on the slot. If the previous sequence ID was 0xFFFFFFFF, then the next request for the slot MUST have the sequence ID set to zero (i.e., (2^32 - 1) + 1 mod 2^32).",
      "ja": "スロットは、配列IDとそのシーケンスIDに送信される要求に対応するキャッシュされた応答を含んでいます。シーケンスIDは、32ビットの符号なしの値であり、範囲0..0xFFFFFFFF（2 ^ 32から1）でことです。スロットが使用されて初めて、要求者は、一つ（セクション18.36）のシーケンスIDを指定しなければなりません。スロットが再使用されるたびに、要求は、スロットに前の要求よりも1大きいシーケンス番号を指定しなければなりません。 （ -  1）+ 1 MOD 2 ^ 32、すなわち、（2 ^ 32）前回のシーケンスIDが0xFFFFFFFFのあった場合には、スロットの次の要求がゼロにシーケンスIDが設定されていなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sequence ID accompanies the slot ID in each request. It is for the critical check at the replier: it used to efficiently determine whether a request using a certain slot ID is a retransmit or a new, never-before-seen request. It is not feasible for the requester to assert that it is retransmitting to implement this, because for any given request the requester cannot know whether the replier has seen it unless the replier actually replies. Of course, if the requester has seen the reply, the requester would not retransmit.",
      "ja": "シーケンスIDは、各リクエストのスロットIDを伴います。それはリプライヤで重要なチェックのためにある：それは効率的に特定のスロットIDを使用して要求を再送信するか、新しい、見たことのない要求であるかどうかを決定するために使用します。依頼者は、任意の要求に対して、要求側がリプライヤが実際に返信しない限り、リプライヤがそれを見ているかどうかを知ることができないので、これを実装するために再送信されていることを主張することは現実的ではありません。もちろん、要求者が返信を見ている場合、要求者は、再送信しません。"
    },
    {
      "indent": 3,
      "text": "The replier compares each received request's sequence ID with the last one previously received for that slot ID, to see if the new request is: o A new request, in which the sequence ID is one greater than that previously seen in the slot (accounting for sequence wraparound). The replier proceeds to execute the new request, and the replier MUST increase the slot's sequence ID by one.",
      "ja": "新しい要求があれば回答者は、以前にそのスロットIDの受信最後の、各受信された要求のシーケンスIDは、参照と比較する：シーケンスIDは、以前のスロットで見られるものより1大きいである新しい要求、O（占めシーケンスラップアラウンド）。リプライヤは、新しい要求を実行するために進み、リプライヤは1でスロットのシーケンス番号を増やす必要があります。"
    },
    {
      "indent": 3,
      "text": "o A retransmitted request, in which the sequence ID is equal to that currently recorded in the slot. If the original request has executed to completion, the replier returns the cached reply. See Section 2.10.6.2 for direction on how the replier deals with retries of requests that are still in progress.",
      "ja": "シーケンスIDは、現在のスロットに記録されたものと同じである再送要求、O。元の要求が完了するまで実行している場合は、リプライヤは、キャッシュされた応答を返します。まだ進行中です要求の再試行でどのようにリプライヤお得な情報で方向については、セクション2.10.6.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "o A misordered retry, in which the sequence ID is less than (accounting for sequence wraparound) that previously seen in the slot. The replier MUST return NFS4ERR_SEQ_MISORDERED (as the result from SEQUENCE or CB_SEQUENCE).",
      "ja": "シーケンスIDは、以前のスロットで見られたもの（配列回り込みを占める）未満であるmisorderedリトライ、O。回答は、（配列またはCB_SEQUENCEから結果として）NFS4ERR_SEQ_MISORDEREDを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A misordered new request, in which the sequence ID is two or more than (accounting for sequence wraparound) that previously seen in the slot. Note that because the sequence ID MUST wrap around to zero once it reaches 0xFFFFFFFF, a misordered new request and a misordered retry cannot be distinguished. Thus, the replier MUST return NFS4ERR_SEQ_MISORDERED (as the result from SEQUENCE or CB_SEQUENCE).",
      "ja": "シーケンスIDは、以前スロットに見られる二つまたは（配列回り込みを占める）以上であるmisordered新しい要求、O。それは0xFFFFFFFFの、misordered新しい要求とmisordered再試行が区別できないに達すると、シーケンスIDがゼロにラップアラウンドしなければならないので注意してください。したがって、回答はNFS4ERR_SEQ_MISORDERED（配列またはCB_SEQUENCEから結果として）を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Unlike the XID, the slot ID is always within a specific range; this has two implications. The first implication is that for a given session, the replier need only cache the results of a limited number of COMPOUND requests. The second implication derives from the first, which is that unlike XID-indexed reply caches (also known as duplicate request caches - DRCs), the slot ID-based reply cache cannot be overflowed. Through use of the sequence ID to identify retransmitted requests, the replier does not need to actually cache the request itself, reducing the storage requirements of the reply cache further. These facilities make it practical to maintain all the required entries for an effective reply cache.",
      "ja": "XIDは異なり、スロットIDは、特定の範囲内に常にあります。これは2つの意味があります。最初の含意は与えられたセッションのために、リプライヤのみCOMPOUND要求の限られた数の結果をキャッシュする必要があることです。 、スロットIDベースの応答キャッシュがオーバーフローすることができない - 第含意は（DRCをも重複要求キャッシュとして知られている）応答キャッシュをXIDインデックスとは異なりことであり、最初に由来します。再送されたリクエストを識別するためのシーケンスIDを使用することにより、リプライヤは実際にはさらに、応答キャッシュのストレージ要件を削減する、要求自体をキャッシュする必要はありません。これらの施設は、それが実用的な効果的な応答キャッシュに必要なすべてのエントリを維持するために作ります。"
    },
    {
      "indent": 3,
      "text": "The slot ID, sequence ID, and session ID therefore take over the traditional role of the XID and source network address in the replier's reply cache implementation. This approach is considerably more portable and completely robust -- it is not subject to the reassignment of ports as clients reconnect over IP networks. In addition, the RPC XID is not used in the reply cache, enhancing robustness of the cache in the face of any rapid reuse of XIDs by the requester. While the replier does not care about the XID for the purposes of reply cache management (but the replier MUST return the same XID that was in the request), nonetheless there are considerations for the XID in NFSv4.1 that are the same as all other previous versions of NFS. The RPC XID remains in each message and needs to be formulated in NFSv4.1 requests as in any other ONC RPC request. The reasons include:",
      "ja": "スロットID、シーケンスID、およびセッションIDは、したがって、XIDの伝統的な役割を引き継ぐとリプライヤの応答キャッシュ実装のソースネットワークアドレス。このアプローチは、かなり多くのポータブルと完全に堅牢です - クライアントはIPネットワーク上で再接続するように、ポートの再割当の対象ではありません。また、RPC XIDは、依頼者によるのXIDのいずれかの急速な再利用の顔にキャッシュの堅牢性を高め、応答キャッシュで使用されていません。リプライヤが応答キャッシュ管理の目的のためにXIDを気にしませんが（しかしリプライヤが要求していた同じXIDを返さなければならない）、それにもかかわらず、すべて同じであるNFSv4.1でXIDのための考慮事項がありますNFSの以前のバージョン。 RPC XIDは、各メッセージに残り、他のONC RPCリクエストのようNFSv4.1要求中に処方される必要があります。理由は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The RPC layer retains its existing semantics and implementation.",
      "ja": "O RPC層は、既存のセマンティクスと実装を保持します。"
    },
    {
      "indent": 3,
      "text": "o The requester and replier must be able to interoperate at the RPC layer, prior to the NFSv4.1 decoding of the SEQUENCE or CB_SEQUENCE operation.",
      "ja": "O要求者と回答者は、先行配列またはCB_SEQUENCE操作のNFSv4.1復号に、RPC層で相互運用することができなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If an operation is being used that does not start with SEQUENCE or CB_SEQUENCE (e.g., BIND_CONN_TO_SESSION), then the RPC XID is needed for correct operation to match the reply to the request.",
      "ja": "動作が使用されている場合、O SEQUENCEまたはCB_SEQUENCE（例えば、BIND_CONN_TO_SESSION）で始まっていないこと、その後、RPC XIDは、要求に対する応答に一致するように、正しい動作のために必要とされます。"
    },
    {
      "indent": 3,
      "text": "o The SEQUENCE or CB_SEQUENCE operation may generate an error. If so, the embedded slot ID, sequence ID, and session ID (if present) in the request will not be in the reply, and the requester has only the XID to match the reply to the request.",
      "ja": "O SEQUENCEまたはCB_SEQUENCE操作がエラーを生成することができます。もしそうであれば、要求に埋め込まれたスロットID、シーケンスID、およびセッションID（存在する場合）応答にされず、リクエスタは、要求に対する応答を一致させるだけXIDを有しています。"
    },
    {
      "indent": 3,
      "text": "Given that well-formulated XIDs continue to be required, this begs the question: why do SEQUENCE and CB_SEQUENCE replies have a session ID, slot ID, and sequence ID? Having the session ID in the reply means that the requester does not have to use the XID to look up the session ID, which would be necessary if the connection were associated with multiple sessions. Having the slot ID and sequence ID in the reply means that the requester does not have to use the XID to look up the slot ID and sequence ID. Furthermore, since the XID is only 32 bits, it is too small to guarantee the re-association of a reply with its request [37]; having session ID, slot ID, and sequence ID in the reply allows the client to validate that the reply in fact belongs to the matched request.",
      "ja": "よく策定のXIDが必要とされ続けていることを考えると、これは質問を頼む：なぜSEQUENCEとCB_SEQUENCE回答は、セッションID、スロットID、およびシーケンスIDを持っていますか？返信のセッションIDを持つことは、要求者が、接続が複数のセッションに関連付けられていた場合には必要となるセッションIDを、ルックアップするためにXIDを使用する必要がないことを意味します。返信のスロットのIDとシーケンスIDを持つことは、要求者がスロットIDとシーケンスIDをルックアップするためにXIDを使用する必要がないことを意味します。 XIDは、32ビットであるので、その要求と応答の再会合を保証するためには小さすぎる[37]。セッションID、スロットID、および応答のシーケンスIDを持つことは、クライアントが実際に応答が一致した要求に属していることを検証することができます。"
    },
    {
      "indent": 3,
      "text": "The SEQUENCE (and CB_SEQUENCE) operation also carries a \"highest_slotid\" value, which carries additional requester slot usage information. The requester MUST always indicate the slot ID representing the outstanding request with the highest-numbered slot value. The requester should in all cases provide the most conservative value possible, although it can be increased somewhat above the actual instantaneous usage to maintain some minimum or optimal level. This provides a way for the requester to yield unused request slots back to the replier, which in turn can use the information to reallocate resources.",
      "ja": "配列（およびCB_SEQUENCE）動作は、追加のリクエスタスロットの使用状況情報を運ぶ「highest_slotid」値を、運びます。リクエスタは常に最高の番号のスロット値を有する未処理の要求を表すスロットIDを指定する必要があります。いくつかの最小値または最適なレベルを維持するために、多少実際の瞬間的な使用を超えて増加することができるが、リクエスタは全ての場合において、可能な限り最も保守的な値を提供しなければなりません。これは、リクエスタがバック順番にリソースを再割り当てするために情報を使用することができる回答に未使用のリクエストスロットを生成するための方法を提供します。"
    },
    {
      "indent": 3,
      "text": "The replier responds with both a new target highest_slotid and an enforced highest_slotid, described as follows: o The target highest_slotid is an indication to the requester of the highest_slotid the replier wishes the requester to be using. This permits the replier to withdraw (or add) resources from a requester that has been found to not be using them, in order to more fairly share resources among a varying level of demand from other requesters. The requester must always comply with the replier's value updates, since they indicate newly established hard limits on the requester's access to session resources. However, because of request pipelining, the requester may have active requests in flight reflecting prior values; therefore, the replier must not immediately require the requester to comply.",
      "ja": "回答は次のように説明し、新たな目標highest_slotidと強制highest_slotid両方で応答：ターゲットhighest_slotid oを回答を使用するリクエスタを望むhighest_slotidのリクエスタへの指示です。これは、他のリクエスタからの需要の変化レベル間でより公平に共有リソースをするためには、それらを使用していないことが判明している依頼者からの資源の撤退（または追加）するリプライヤを許可します。彼らは、セッションリソースへの要求者のアクセスに新設されたハードの限界を示しているため、依頼者は常に、リプライヤの値の更新を遵守しなければなりません。しかし、要求パイプラインの、要求者は前の値を反映して飛行中のアクティブな要求を有していてもよいです。そのため、リプライヤはすぐに遵守するために要求者を要求してはなりません。"
    },
    {
      "indent": 3,
      "text": "o The enforced highest_slotid indicates the highest slot ID the requester is permitted to use on a subsequent SEQUENCE or CB_SEQUENCE operation. The replier's enforced highest_slotid SHOULD be no less than the highest_slotid the requester indicated in the SEQUENCE or CB_SEQUENCE arguments.",
      "ja": "O強制highest_slotidは、要求者が後続の配列またはCB_SEQUENCE操作に使用することが許可されている最高のスロットIDを示しています。リプライヤの施行highest_slotidは、依頼者がSEQUENCEまたはCB_SEQUENCE引数で示さhighest_slotid劣らないはずです。"
    },
    {
      "indent": 6,
      "text": "A requester can be intransigent with respect to lowering its highest_slotid argument to a Sequence operation, i.e. the requester continues to ignore the target highest_slotid in the response to a Sequence operation, and continues to set its highest_slotid argument to be higher than the target highest_slotid. This can be considered particularly egregious behavior when the replier knows there are no outstanding requests with slot IDs higher than its target highest_slotid. When faced with such intransigence, the replier is free to take more forceful action, and MAY reply with a new enforced highest_slotid that is less than its previous enforced highest_slotid. Thereafter, if the requester continues to send requests with a highest_slotid that is greater than the replier's new enforced highest_slotid, the server MAY return NFS4ERR_BAD_HIGH_SLOT, unless the slot ID in the request is greater than the new enforced highest_slotid and the request is a retry.",
      "ja": "リクエスタがシーケンス動作へのhighest_slotid引数を低下に関して妥協することができ、すなわち、リクエスタは、配列操作に応じて目標highest_slotidを無視し続け、目標highest_slotidよりも高く、そのhighest_slotid引数を設定し続けます。リプライヤがその目標highest_slotidよりも高いスロットIDとは、未処理の要求が存在しない知っているとき、これが特にひどい行動とみなすことができます。そのような妥協に直面したとき、リプライヤはより強力な行動を取るために自由であり、その前の施行highest_slotid未満の新しい施行highest_slotidに応答することができます。リクエスタがリプライヤの新しい施行highest_slotidより大きいhighest_slotidとのリクエストを送信し続けた場合、要求内のスロットIDが新しい強制highest_slotidよりも大きく、要求が再試行されない限り、その後、サーバーは、NFS4ERR_BAD_HIGH_SLOTを返すことがあります。"
    },
    {
      "indent": 6,
      "text": "The replier SHOULD retain the slots it wants to retire until the requester sends a request with a highest_slotid less than or equal to the replier's new enforced highest_slotid.",
      "ja": "リプライヤは、要求者がリプライヤの新しい施行highest_slotid以下highest_slotidで要求を送信するまで引退したいスロットを保持しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The requester can also be intransigent with respect to sending non-retry requests that have a slot ID that exceeds the replier's highest_slotid. Once the replier has forcibly lowered the enforced highest_slotid, the requester is only allowed to send retries on slots that exceed the replier's highest_slotid. If a request is received with a slot ID that is higher than the new enforced highest_slotid, and the sequence ID is one higher than what is in the slot's reply cache, then the server can both retire the slot and return NFS4ERR_BADSLOT (however, the server MUST NOT do one and not the other). The reason it is safe to retire the slot is because by using the next sequence ID, the requester is indicating it has received the previous reply for the slot.",
      "ja": "リクエスタはまた、回答者のhighest_slotidを超えたスロットIDを有する非リトライ要求を送信に対して妥協することができます。リプライヤは強制的に施行highest_slotidを下げた後、依頼者にのみリプライヤのhighest_slotidを超えスロットに再試行を送信することが許可されています。要求は、新たな強制highest_slotidより高いスロットIDを受信し、シーケンスIDは、スロットの応答キャッシュにあるものより1高くなっている場合、サーバーは、両方のスロットを引退し、NFS4ERR_BADSLOT（ただし、サーバーを返すことができます。 1とされていない他のを）やるなりません。次のシーケンスIDを使用して、リクエスタはそれがスロットの前の応答を受信した指示されているので、スロットを引退しても安全である理由です。"
    },
    {
      "indent": 3,
      "text": "o The requester SHOULD use the lowest available slot when sending a new request. This way, the replier may be able to retire slot entries faster. However, where the replier is actively adjusting its granted highest_slotid, it will not be able to use only the receipt of the slot ID and highest_slotid in the request. Neither the slot ID nor the highest_slotid used in a request may reflect the replier's current idea of the requester's session limit, because the request may have been sent from the requester before the update was received. Therefore, in the downward adjustment case, the replier may have to retain a number of reply cache entries at least as large as the old value of maximum requests outstanding, until it can infer that the requester has seen a reply containing the new granted highest_slotid. The replier can infer that the requester has seen such a reply when it receives a new request with the same slot ID as the request replied to and the next higher sequence ID.",
      "ja": "新しいリクエストを送信するとき、O要求者は、使用可能な最小のスロットを使用すべきです。このように、リプライヤは速くスロットエントリを引退することができるかもしれません。リプライヤは積極的に付与されたhighest_slotidを調整している場合しかし、リクエストでのみスロットIDの受信とhighest_slotidを使用することはできません。更新が受信される前に、要求が依頼者から送信された可能性があるため、スロットIDや要求で使用highest_slotidどちらも、要求者のセッション制限のリプライヤの現在の考え方を反映することができます。したがって、下方調整場合、回答者は、要求者が新しい付与highest_slotidを含む応答を見ていると推測できるまで、未処理の最大要求の古い値と少なくとも同じ大き応答キャッシュエントリの数を保持する必要があります。回答者は、リクエスタが要求に回答し、次に高いシーケンスIDとして、同じスロットIDと新しい要求を受信し、そのような応答を見ていると推測することができます。"
    },
    {
      "indent": 0,
      "text": "2.10.6.1.1. Caching of SEQUENCE and CB_SEQUENCE Replies",
      "section_title": true,
      "ja": "2.10.6.1.1。 SEQUENCEとCB_SEQUENCE回答のキャッシング"
    },
    {
      "indent": 3,
      "text": "When a SEQUENCE or CB_SEQUENCE operation is successfully executed, its reply MUST always be cached. Specifically, session ID, sequence ID, and slot ID MUST be cached in the reply cache. The reply from SEQUENCE also includes the highest slot ID, target highest slot ID, and status flags. Instead of caching these values, the server MAY re-compute the values from the current state of the fore channel, session, and/or client ID as appropriate. Similarly, the reply from CB_SEQUENCE includes a highest slot ID and target highest slot ID. The client MAY re-compute the values from the current state of the session as appropriate.",
      "ja": "SEQUENCEまたはCB_SEQUENCE操作が正常に実行された場合、その応答は常にキャッシュされなければなりません。具体的には、セッションID、シーケンス番号、およびスロットIDは、応答キャッシュ内にキャッシュされなければなりません。配列からの応答はまた、最高のスロットID、及びステータスフラグを標的とする、最高のスロットのIDを含みます。代わりにこれらの値をキャッシュする、サーバは、必要に応じて前方チャネル、セッション、及び/またはクライアントIDの現在の状態から値を再計算することができます。同様に、CB_SEQUENCEからの応答は、最高スロットIDとターゲット最高スロットのIDを含みます。クライアントは、必要に応じて、セッションの現在の状態から値を再計算することができます。"
    },
    {
      "indent": 3,
      "text": "Regardless of whether or not a replier is re-computing highest slot ID, target slot ID, and status on replies to retries, the requester MUST NOT assume that the values are being re-computed whenever it receives a reply after a retry is sent, since it has no way of knowing whether the reply it has received was sent by the replier in response to the retry or is a delayed response to the original request. Therefore, it may be the case that highest slot ID, target slot ID, or status bits may reflect the state of affairs when the request was first executed. Although acting based on such delayed information is valid, it may cause the receiver of the reply to do unneeded work. Requesters MAY choose to send additional requests to get the current state of affairs or use the state of affairs reported by subsequent requests, in preference to acting immediately on data that might be out of date.",
      "ja": "それは再試行後に応答が送信され受信する度にかかわらず回答者が再試行に応答に再計算最高スロットID、目標スロットID、及びステータスであるか否かの、要求者は、値が再計算されていると仮定してはいけません、それが受信した応答が再試行に応答して回答者によって送信されるか、または元の要求に応答遅れているれたかどうかを知る方法がないからです。したがって、要求が最初に実行されたときに最高のスロットID、目標スロットID、またはステータスビットは、業務の状態を反映することができる場合であってもよいです。こうした遅れた情報に基づいて行動することは有効ですが、それは回答の受信機が不要な仕事をする恐れがあります。リクエスタは、事務の現在の状態を取得したり、古くなっかもしれないデータにすぐに行動に優先して、後続の要求によって報告された事務の状態を、使用するための追加の要求を送信するために選ぶかもしれません。"
    },
    {
      "indent": 0,
      "text": "2.10.6.1.2. Errors from SEQUENCE and CB_SEQUENCE",
      "section_title": true,
      "ja": "2.10.6.1.2。 SEQUENCEとCB_SEQUENCEからのエラー"
    },
    {
      "indent": 3,
      "text": "Any time SEQUENCE or CB_SEQUENCE returns an error, the sequence ID of the slot MUST NOT change. The replier MUST NOT modify the reply cache entry for the slot whenever an error is returned from SEQUENCE or CB_SEQUENCE.",
      "ja": "任意の時間配列またはCB_SEQUENCEはエラーを返し、スロットのシーケンスIDは変更してはいけません。エラーがSEQUENCEまたはCB_SEQUENCEから返されるたびリプライヤは、スロットに対する応答キャッシュエントリを変更してはいけません。"
    },
    {
      "indent": 0,
      "text": "2.10.6.1.3. Optional Reply Caching",
      "section_title": true,
      "ja": "2.10.6.1.3。オプションの返信キャッシング"
    },
    {
      "indent": 3,
      "text": "On a per-request basis, the requester can choose to direct the replier to cache the reply to all operations after the first operation (SEQUENCE or CB_SEQUENCE) via the sa_cachethis or csa_cachethis fields of the arguments to SEQUENCE or CB_SEQUENCE. The reason it would not direct the replier to cache the entire reply is that the request is composed of all idempotent operations [34]. Caching the reply may offer little benefit. If the reply is too large (see Section 2.10.6.4), it may not be cacheable anyway. Even if the reply to idempotent request is small enough to cache, unnecessarily caching the reply slows down the server and increases RPC latency.",
      "ja": "リクエストごとに、依頼者は、SEQUENCEまたはCB_SEQUENCEへの引数のsa_cachethisまたはcsa_cachethisフィールドを介して第一の動作（SEQUENCEまたはCB_SEQUENCE）した後、すべての操作への応答をキャッシュするリプライヤを指示するために選択することができます。それは全体の応答をキャッシュする回答を指示しないであろう理由は、要求が全て冪等の操作[34]で構成されていることです。返信をキャッシュすると、ほとんど利益を提供することがあります。応答が（セクション2.10.6.4を参照してください）大きすぎる場合、それはとにかくキャッシュ可能ではないかもしれません。リクエストをべき等への応答がキャッシュに十分に小さい場合であっても、不必要に回答をキャッシュすると、サーバーの速度が低下し、RPCの待ち時間が増加します。"
    },
    {
      "indent": 3,
      "text": "Whether or not the requester requests the reply to be cached has no effect on the slot processing. If the results of SEQUENCE or CB_SEQUENCE are NFS4_OK, then the slot's sequence ID MUST be incremented by one. If a requester does not direct the replier to cache the reply, the replier MUST do one of following:",
      "ja": "要求者がキャッシュされるの返信を要求したかどうかは、スロットの処理には影響を与えません。配列またはCB_SEQUENCEの結果がNFS4_OKである場合、スロットのシーケンスIDをインクリメントしなければなりません。依頼者が応答をキャッシュするリプライヤを指示していない場合は、リプライヤは、次のいずれかを行う必要があります"
    },
    {
      "indent": 3,
      "text": "o The replier can cache the entire original reply. Even though sa_cachethis or csa_cachethis is FALSE, the replier is always free to cache. It may choose this approach in order to simplify implementation.",
      "ja": "Oリプライヤは、原稿全体の応答をキャッシュすることができます。 sa_cachethisまたはcsa_cachethisがFALSEであるにもかかわらず、リプライヤは常にキャッシュに無料です。それは、実装を簡素化するために、このアプローチを選択することができます。"
    },
    {
      "indent": 3,
      "text": "o The replier enters into its reply cache a reply consisting of the original results to the SEQUENCE or CB_SEQUENCE operation, and with the next operation in COMPOUND or CB_COMPOUND having the error NFS4ERR_RETRY_UNCACHED_REP. Thus, if the requester later retries the request, it will get NFS4ERR_RETRY_UNCACHED_REP. If a replier receives a retried Sequence operation where the reply to the COMPOUND or CB_COMPOUND was not cached, then the replier,",
      "ja": "O回答者は、その応答キャッシュにSEQUENCEまたはCB_SEQUENCE動作原結果からなる応答を入力し、エラーNFS4ERR_RETRY_UNCACHED_REPを有する化合物またはCB_COMPOUNDにおける次の動作です。依頼者が後で要求を再試行する場合はこのように、それはNFS4ERR_RETRY_UNCACHED_REPを取得します。リプライヤは、化合物またはCB_COMPOUNDへの応答がキャッシュされていませんでした再試行シーケンス動作受けた場合には、リプライヤ、"
    },
    {
      "indent": 6,
      "text": "* MAY return NFS4ERR_RETRY_UNCACHED_REP in reply to a Sequence operation if the Sequence operation is not the first operation (granted, a requester that does so is in violation of the NFSv4.1 protocol).",
      "ja": "シーケンス動作は、最初の操作（許可され、そうリクエスタがNFSv4.1プロトコルに違反している）でない場合*シーケンス動作に対する応答でNFS4ERR_RETRY_UNCACHED_REPを返すことができます。"
    },
    {
      "indent": 6,
      "text": "* MUST NOT return NFS4ERR_RETRY_UNCACHED_REP in reply to a Sequence operation if the Sequence operation is the first operation.",
      "ja": "シーケンス動作は、第1の操作であれば*シーケンス動作に応答してNFS4ERR_RETRY_UNCACHED_REPを返してはなりません。"
    },
    {
      "indent": 3,
      "text": "o If the second operation is an illegal operation, or an operation that was legal in a previous minor version of NFSv4 and MUST NOT be supported in the current minor version (e.g., SETCLIENTID), the replier MUST NOT ever return NFS4ERR_RETRY_UNCACHED_REP. Instead the replier MUST return NFS4ERR_OP_ILLEGAL or NFS4ERR_BADXDR or NFS4ERR_NOTSUPP as appropriate.",
      "ja": "第2の操作は不正な処理、またはNFSv4の以前のマイナーバージョンで法的だったし、現在のマイナーバージョン（例えば、SETCLIENTID）でサポートされてはならない操作である場合には、O、リプライヤはこれまでNFS4ERR_RETRY_UNCACHED_REPを返してはなりません。代わりにリプライヤは、必要に応じてNFS4ERR_OP_ILLEGALまたはNFS4ERR_BADXDRまたはNFS4ERR_NOTSUPPを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the second operation can result in another error status, the replier MAY return a status other than NFS4ERR_RETRY_UNCACHED_REP, provided the operation is not executed in such a way that the state of the replier is changed. Examples of such an error status include: NFS4ERR_NOTSUPP returned for an operation that is legal but not REQUIRED in the current minor versions, and thus not supported by the replier; NFS4ERR_SEQUENCE_POS; and NFS4ERR_REQ_TOO_BIG.",
      "ja": "第2の動作は、他のエラー状態をもたらすことができる場合は、O、回答者は、操作が回答者の状態が変化するように実行されない設け、NFS4ERR_RETRY_UNCACHED_REP以外のステータスを返すことができます。このようなエラー状態の例としては、NFS4ERR_NOTSUPP法的が、現在のマイナーバージョンでは必要とされないので、回答者によってサポートされていない操作のために返されます。 NFS4ERR_SEQUENCE_POS;そしてNFS4ERR_REQ_TOO_BIG。"
    },
    {
      "indent": 3,
      "text": "The discussion above assumes that the retried request matches the original one. Section 2.10.6.1.3.1 discusses what the replier might do, and MUST do when original and retried requests do not match. Since the replier may only cache a small amount of the information that would be required to determine whether this is a case of a false retry, the replier may send to the client any of the following responses:",
      "ja": "上記の議論は再試行要求はオリジナルのものと一致していることを前提としています。第2.10.6.1.3.1はリプライヤが行うかもしれないものについて説明し、オリジナルと再試行要求が一致しない場合に行う必要があります。リプライヤはこれだけ偽の再試行の場合であるかどうかを判断するために必要とされるであろう少量の情報をキャッシュすることがありますので、リプライヤは、次の応答のいずれかのクライアントに送信可能性があります。"
    },
    {
      "indent": 3,
      "text": "o The cached reply to the original request (if the replier has cached it in its entirety and the users of the original request and retry match).",
      "ja": "元のリクエスト（回答者は、その全体が、元の要求のユーザーにそれをキャッシュされ、一致を再試行している場合）にキャッシュされた返信O。"
    },
    {
      "indent": 3,
      "text": "o A reply that consists only of the Sequence operation with the error NFS4ERR_FALSE_RETRY.",
      "ja": "唯一のエラーNFS4ERR_FALSE_RETRYとシーケンス動作から成る返信O。"
    },
    {
      "indent": 3,
      "text": "o A reply consisting of the response to Sequence with the status NFS4_OK, together with the second operation as it appeared in the retried request with an error of NFS4ERR_RETRY_UNCACHED_REP or other error as described above.",
      "ja": "上記のように、それはNFS4ERR_RETRY_UNCACHED_REPまたは他のエラーのエラーで再試行要求に現れとして一緒に第2の動作と、ステータスNFS4_OKとシーケンスに応答からなる返信O。"
    },
    {
      "indent": 3,
      "text": "o A reply that consists of the response to Sequence with the status NFS4_OK, together with the second operation as it appeared in the original request with an error of NFS4ERR_RETRY_UNCACHED_REP or other error as described above.",
      "ja": "上記のように、それはNFS4ERR_RETRY_UNCACHED_REPまたは他のエラーのエラーが発生した元の要求に現れとして一緒に第2の動作と、ステータスNFS4_OKとシーケンスに応答から成る返信O。"
    },
    {
      "indent": 0,
      "text": "2.10.6.1.3.1. False Retry",
      "section_title": true,
      "ja": "2.10.6.1.3.1。 Falseの再試行"
    },
    {
      "indent": 3,
      "text": "If a requester sent a Sequence operation with a slot ID and sequence ID that are in the reply cache but the replier detected that the retried request is not the same as the original request, including a retry that has different operations or different arguments in the operations from the original and a retry that uses a different principal in the RPC request's credential field that translates to a different user, then this is a false retry. When the replier detects a false retry, it is permitted (but not always obligated) to return NFS4ERR_FALSE_RETRY in response to the Sequence operation when it detects a false retry.",
      "ja": "リクエスタが応答キャッシュ内にあるスロットIDとシーケンスIDとシーケンス動作を送ったが、回答者が再試行要求が操作で異なる操作または異なる引数を有するリトライを含む、元の要求と同じでないことを検出した場合オリジナルと異なるユーザーに変換RPC要求の資格フィールドに別のプリンシパルを使用して、再試行から、これは偽の再試行です。リプライヤが偽の再試行を検出すると、偽の再試行を検出したときにシーケンス動作に応じてNFS4ERR_FALSE_RETRYを返すために（必ずしも義務ではなく）許可されています。"
    },
    {
      "indent": 3,
      "text": "Translations of particularly privileged user values to other users due to the lack of appropriately secure credentials, as configured on the replier, should be applied before determining whether the users are the same or different. If the replier determines the users are different between the original request and a retry, then the replier MUST return NFS4ERR_FALSE_RETRY.",
      "ja": "適切に安全な認証情報の欠如に他のユーザーに特に特権ユーザー値の翻訳は、回答者に設定され、ユーザが同じか異なるかを決定する前に適用されるべきです。回答は、ユーザーが元の要求と再試行の間で異なる判断した場合、その後、回答者はNFS4ERR_FALSE_RETRYを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an operation of the retry is an illegal operation, or an operation that was legal in a previous minor version of NFSv4 and MUST NOT be supported in the current minor version (e.g., SETCLIENTID), the replier MAY return NFS4ERR_FALSE_RETRY (and MUST do so if the users of the original request and retry differ). Otherwise, the replier MAY return NFS4ERR_OP_ILLEGAL or NFS4ERR_BADXDR or NFS4ERR_NOTSUPP as appropriate. Note that the handling is in contrast for how the replier deals with retries requests with no cached reply. The difference is due to NFS4ERR_FALSE_RETRY being a valid error for only Sequence operations, whereas NFS4ERR_RETRY_UNCACHED_REP is a valid error for all operations except illegal operations and operations that MUST NOT be supported in the current minor version of NFSv4.",
      "ja": "リトライの動作が不正な操作、またはNFSv4の以前のマイナーバージョンで法的だったし、現在のマイナーバージョン（例えば、SETCLIENTID）でサポートされてはならない操作であれば、リプライヤはNFS4ERR_FALSE_RETRYを返してもよい（そして、そうしなければなりません元の要求と再試行のユーザーが異なる場合）。それ以外の場合は、リプライヤは、必要に応じてNFS4ERR_OP_ILLEGALまたはNFS4ERR_BADXDRまたはNFS4ERR_NOTSUPPを返す場合があります。取り扱いがキャッシュされた応答で再試行要求にどのようにリプライヤお得な情報のためのと対照的であることに注意してください。 NFS4ERR_RETRY_UNCACHED_REPはNFSv4の現在のマイナーバージョンではサポートされてはならない違法な操作と操作以外のすべての操作のための有効なエラーであるのに対し、違いは、NFS4ERR_FALSE_RETRYのみシーケンス操作のための有効なエラーであることによるものです。"
    },
    {
      "indent": 0,
      "text": "2.10.6.2. Retry and Replay of Reply",
      "section_title": true,
      "ja": "2.10.6.2。再試行し、返信のリプレイ"
    },
    {
      "indent": 3,
      "text": "A requester MUST NOT retry a request, unless the connection it used to send the request disconnects. The requester can then reconnect and re-send the request, or it can re-send the request over a different connection that is associated with the same session.",
      "ja": "接続は、要求の切断を送信するために使用されない限り、要求者は、要求を再試行してはなりません。要求者は、次いで、再接続要求を再送信し、またはそれは、同じセッションに関連付けられている異なる接続を介して要求を再送信することができることができます。"
    },
    {
      "indent": 3,
      "text": "If the requester is a server wanting to re-send a callback operation over the backchannel of a session, the requester of course cannot reconnect because only the client can associate connections with the backchannel. The server can re-send the request over another connection that is bound to the same session's backchannel. If there is no such connection, the server MUST indicate that the session has no backchannel by setting the SEQ4_STATUS_CB_PATH_DOWN_SESSION flag bit in the response to the next SEQUENCE operation from the client. The client MUST then associate a connection with the session (or destroy the session).",
      "ja": "依頼者がセッションのバックチャネル上でコールバック操作を再送信したいサーバーがある場合のみ、クライアントはバックチャネルとの接続を関連付けることができますので、当然の要求者は、再接続することはできません。サーバーは、同じセッションのバックチャネルにバインドされている別の接続を介して要求を再送信することができます。そのような接続が存在しない場合、サーバは、セッションが、クライアントからの次のシーケンスの操作に応じてSEQ4_STATUS_CB_PATH_DOWN_SESSIONフラグビットを設定することにより何らバックチャネルを有していないことを示さなければなりません。次に、クライアントはセッションとの接続を関連付ける（またはセッションを破棄）しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that it is not fatal for a requester to retry without a disconnect between the request and retry. However, the retry does consume resources, especially with RDMA, where each request, retry or not, consumes a credit. Retries for no reason, especially retries sent shortly after the previous attempt, are a poor use of network bandwidth and defeat the purpose of a transport's inherent congestion control system.",
      "ja": "依頼者は、要求と再試行の間に切断せずに再試行することは致命的ではないことに注意してください。ただし、再試行は、特に各要求は、再試行するかどうか、クレジットを消費RDMA、と、リソースを消費しません。理由もなく再試行、前回の試行直後に送信され、特に再試行は、ネットワーク帯域幅の貧しい人々の使用であり、トランスポートの固有の輻輳制御システムの目的を倒します。"
    },
    {
      "indent": 3,
      "text": "A requester MUST wait for a reply to a request before using the slot for another request. If it does not wait for a reply, then the requester does not know what sequence ID to use for the slot on its next request. For example, suppose a requester sends a request with sequence ID 1, and does not wait for the response. The next time it uses the slot, it sends the new request with sequence ID 2. If the replier has not seen the request with sequence ID 1, then the replier is not expecting sequence ID 2, and rejects the requester's new request with NFS4ERR_SEQ_MISORDERED (as the result from SEQUENCE or CB_SEQUENCE).",
      "ja": "リクエスタは、別の要求のためのスロットを使用する前に、要求に対する応答を待たなければなりません。それが応答を待機していない場合、要求者は、その次のリクエストのスロットの場合に使用するシーケンスIDを知りません。たとえば、リクエスタがシーケンス番号1で要求を送信し、応答を待ちませんと仮定します。それはスロットを使用しています次回は、それはシーケンスID 2.で新しい要求を送信しリプライヤは、シーケンス番号1で要求を見ていない場合は、リプライヤは、（シーケンス番号2を期待し、NFS4ERR_SEQ_MISORDEREDと要求者の新しい要求を拒否されていません）配列またはCB_SEQUENCEから結果として。"
    },
    {
      "indent": 3,
      "text": "RDMA fabrics do not guarantee that the memory handles (Steering Tags) within each RPC/RDMA \"chunk\" [8] are valid on a scope outside that of a single connection. Therefore, handles used by the direct operations become invalid after connection loss. The server must ensure that any RDMA operations that must be replayed from the reply cache use the newly provided handle(s) from the most recent request.",
      "ja": "RDMAファブリックは各RPC / RDMA「チャンク」内のメモリハンドル（ステアリングタグ）[8]単一の接続の外範囲で有効であることを保証するものではありません。そのため、直接操作で使用されるハンドルは、接続損失の後に無効になります。サーバは、応答キャッシュから再生されなければならない任意のRDMA操作は、最新のリクエストから新たに設けられたハンドル（複数可）を使用していることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "A retry might be sent while the original request is still in progress on the replier. The replier SHOULD deal with the issue by returning NFS4ERR_DELAY as the reply to SEQUENCE or CB_SEQUENCE operation, but implementations MAY return NFS4ERR_MISORDERED. Since errors from SEQUENCE and CB_SEQUENCE are never recorded in the reply cache, this approach allows the results of the execution of the original request to be properly recorded in the reply cache (assuming that the requester specified the reply to be cached).",
      "ja": "元の要求がリプライヤの進行中にリトライが送信される可能性があります。リプライヤは、SEQUENCEまたはCB_SEQUENCE操作への応答としてNFS4ERR_DELAYを返すことで問題に対処する必要がありますが、実装はNFS4ERR_MISORDEREDを返す場合があります。 SEQUENCEとCB_SEQUENCEからエラーが返信キャッシュに記録されることはないので、このアプローチは、元の要求の実行結果が正常（リクエスタがキャッシュする応答を指定したと仮定して）返信キャッシュに記録されることを可能にします。"
    },
    {
      "indent": 0,
      "text": "2.10.6.3. Resolving Server Callback Races",
      "section_title": true,
      "ja": "2.10.6.3。解決サーバーのコールバックレース"
    },
    {
      "indent": 3,
      "text": "It is possible for server callbacks to arrive at the client before the reply from related fore channel operations. For example, a client may have been granted a delegation to a file it has opened, but the reply to the OPEN (informing the client of the granting of the delegation) may be delayed in the network. If a conflicting operation arrives at the server, it will recall the delegation using the backchannel, which may be on a different transport connection, perhaps even a different network, or even a different session associated with the same client ID.",
      "ja": "サーバーのコールバックは、関連する前部チャネル事業からの返信前にクライアントに到着することが可能です。例えば、クライアントは、それが開いたファイルへの委任を付与されているかもしれないが、OPEN（委任の付与のクライアントに通知）に対する応答は、ネットワーク内で遅延することができます。競合操作がサーバーに到着した場合、それは、同じクライアントIDに関連付けられた異なるトランスポート接続上にあってもよいバックチャネルを使用して、委任、おそらく別のネットワーク、あるいは別のセッションを思い出します。"
    },
    {
      "indent": 3,
      "text": "The presence of a session between the client and server alleviates this issue. When a session is in place, each client request is uniquely identified by its { session ID, slot ID, sequence ID } triple. By the rules under which slot entries (reply cache entries) are retired, the server has knowledge whether the client has \"seen\" each of the server's replies. The server can therefore provide sufficient information to the client to allow it to disambiguate between an erroneous or conflicting callback race condition.",
      "ja": "クライアントとサーバ間のセッションの存在は、この問題を軽減します。セッションが適所にあるときに、各クライアント要求は、一意三重その{セッションID、スロットID、シーケンスID}によって識別されます。ルールによってスロットエントリ（応答キャッシュエントリ）が引退されているの下で、サーバーは、クライアントがサーバの応答のそれぞれを「見て」いるかどうかの知識を持っています。サーバーは、したがって、それは誤ったまたは競合コールバックの競合状態の間で明確にできるように、クライアントに十分な情報を提供することができます。"
    },
    {
      "indent": 3,
      "text": "For each client operation that might result in some sort of server callback, the server SHOULD \"remember\" the { session ID, slot ID, sequence ID } triple of the client request until the slot ID retirement rules allow the server to determine that the client has, in fact, seen the server's reply. Until the time the { session ID, slot ID, sequence ID } request triple can be retired, any recalls of the associated object MUST carry an array of these referring identifiers (in the CB_SEQUENCE operation's arguments), for the benefit of the client. After this time, it is not necessary for the server to provide this information in related callbacks, since it is certain that a race condition can no longer occur.",
      "ja": "スロットID退職規則は、サーバがクライアントと判断することを可能にするまで、サーバーコールバックのいくつかの並べ替えをもたらす可能性がある各クライアント操作のために、サーバは、クライアント要求のトリプル{セッションID、スロットID、シーケンスID}を「覚えている」べきです、実際には、サーバの応答を見ています。 {セッションID、スロットID、シーケンスID}は、要求が三重リタイアすることができるまで、関連するオブジェクトのいずれかリコールは、クライアントの利益のために、これらの参照識別子（CB_SEQUENCE操作の引数で）の配列を運ばなければなりません。競合状態が発生しなくなりましたことを確実であるため、サーバは、関連するコールバックでこの情報を提供するために、この時間の後に、それは必要ありません。"
    },
    {
      "indent": 3,
      "text": "The CB_SEQUENCE operation that begins each server callback carries a list of \"referring\" { session ID, slot ID, sequence ID } triples. If the client finds the request corresponding to the referring session ID, slot ID, and sequence ID to be currently outstanding (i.e., the server's reply has not been seen by the client), it can determine that the callback has raced the reply, and act accordingly. If the client does not find the request corresponding to the referring triple to be outstanding (including the case of a session ID referring to a destroyed session), then there is no race with respect to this triple. The server SHOULD limit the referring triples to requests that refer to just those that apply to the objects referred to in the CB_COMPOUND procedure.",
      "ja": "各サーバーのコールバックを開始CB_SEQUENCE動作は「参照」{セッションID、スロットID、シーケンスID}はトリプルのリストを運びます。クライアントが（つまり、サーバの応答がクライアントによって見られていません）を参照セッションID、スロットID、およびシーケンスIDに対応する要求は、現在未解決であることを発見すると、コールバックが応答をレースしていることを決定することができ、かつそれに応じて行動します。クライアントが（破壊されたセッションを参照するセッションIDの場合を含む）非凡であることを言及するのトリプルに対応するリクエストが見つからない場合は、このトリプルに関しては何のレースはありません。サーバは単にオブジェクトに適用するものがCB_COMPOUND手順で参照される参照要求を参照するトリプルを制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client must not simply wait forever for the expected server reply to arrive before responding to the CB_COMPOUND that won the race, because it is possible that it will be delayed indefinitely. The client should assume the likely case that the reply will arrive within the average round-trip time for COMPOUND requests to the server, and wait that period of time. If that period of time expires, it can respond to the CB_COMPOUND with NFS4ERR_DELAY. There are other scenarios under which callbacks may race replies. Among them are pNFS layout recalls as described in Section 12.5.5.2.",
      "ja": "予想されるサーバの応答がレースに勝ったCB_COMPOUNDに応答する前に到着するために、無期限に延期される可能性があるため、クライアントは、単純に、いつまでも待ってはいけません。クライアントは、応答がサーバにCOMPOUND要求の平均往復時間内に到着する可能性が高い場合を想定し、その期間を待つ必要があります。その期間が満了した場合、それはNFS4ERR_DELAYとCB_COMPOUNDに対応することができます。コールバックが回答をレースもその下で他のシナリオがあります。その中のpNFSは、セクション12.5.5.2で説明したようにレイアウトは回想しています。"
    },
    {
      "indent": 0,
      "text": "2.10.6.4. COMPOUND and CB_COMPOUND Construction Issues",
      "section_title": true,
      "ja": "2.10.6.4。 COMPOUNDとCB_COMPOUND建設問題"
    },
    {
      "indent": 3,
      "text": "Very large requests and replies may pose both buffer management issues (especially with RDMA) and reply cache issues. When the session is created (Section 18.36), for each channel (fore and back), the client and server negotiate the maximum-sized request they will send or process (ca_maxrequestsize), the maximum-sized reply they will return or process (ca_maxresponsesize), and the maximum-sized reply they will store in the reply cache (ca_maxresponsesize_cached).",
      "ja": "非常に大規模な要求や応答は（特にRDMA付き）の両方のバッファ管理の問題を提起し、キャッシュの問題を応答することができます。セッションが作成されると（セクション18.36）、各チャネル（フォア、バック）のために、クライアントとサーバーは、最大サイズの彼らが返す返信またはプロセスの最大サイズ、彼らが送信されます要求またはプロセス（ca_maxrequestsizeを）交渉（ca_maxresponsesize ）、及びそれらが応答キャッシュ（ca_maxresponsesize_cached）に格納する最大サイズの返信。"
    },
    {
      "indent": 3,
      "text": "If a request exceeds ca_maxrequestsize, the reply will have the status NFS4ERR_REQ_TOO_BIG. A replier MAY return NFS4ERR_REQ_TOO_BIG as the status for the first operation (SEQUENCE or CB_SEQUENCE) in the request (which means that no operations in the request executed and that the state of the slot in the reply cache is unchanged), or it MAY opt to return it on a subsequent operation in the same COMPOUND or CB_COMPOUND request (which means that at least one operation did execute and that the state of the slot in the reply cache does change). The replier SHOULD set NFS4ERR_REQ_TOO_BIG on the operation that exceeds ca_maxrequestsize.",
      "ja": "リクエストがca_maxrequestsizeを超えた場合、応答は、ステータスNFS4ERR_REQ_TOO_BIGを持っています。回答は、（要求には操作が実行されないことを意味し、応答キャッシュ内のスロットの状態が変化しないように）要求内の最初の操作（SEQUENCEまたはCB_SEQUENCE）のステータスとしてNFS4ERR_REQ_TOO_BIGを返すもよく、またはそれはに選ぶことができ同じ化合物または（少なくとも1つの動作が実行さなかったこと、応答キャッシュ内のスロットの状態が変化しないことを意味する）CB_COMPOUND要求に後続の操作にそれを返します。リプライヤはca_maxrequestsizeを超えた操作にNFS4ERR_REQ_TOO_BIGを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a reply exceeds ca_maxresponsesize, the reply will have the status NFS4ERR_REP_TOO_BIG. A replier MAY return NFS4ERR_REP_TOO_BIG as the status for the first operation (SEQUENCE or CB_SEQUENCE) in the request, or it MAY opt to return it on a subsequent operation (in the same COMPOUND or CB_COMPOUND reply). A replier MAY return NFS4ERR_REP_TOO_BIG in the reply to SEQUENCE or CB_SEQUENCE, even if the response would still exceed ca_maxresponsesize.",
      "ja": "返信がca_maxresponsesizeを超えた場合、応答は、ステータスNFS4ERR_REP_TOO_BIGを持っています。回答は、要求内の最初の操作（SEQUENCEまたはCB_SEQUENCE）のステータスとしてNFS4ERR_REP_TOO_BIGを返すもよく、またはそれは（同じ化合物又はCB_COMPOUND応答に）後続の操作にそれを返すように選択してもよいです。応答がまだca_maxresponsesizeを超えてしまう場合でもリプライヤは、SEQUENCEまたはCB_SEQUENCEへの返信でNFS4ERR_REP_TOO_BIGを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "If sa_cachethis or csa_cachethis is TRUE, then the replier MUST cache a reply except if an error is returned by the SEQUENCE or CB_SEQUENCE operation (see Section 2.10.6.1.2). If the reply exceeds ca_maxresponsesize_cached (and sa_cachethis or csa_cachethis is TRUE), then the server MUST return NFS4ERR_REP_TOO_BIG_TO_CACHE. Even if NFS4ERR_REP_TOO_BIG_TO_CACHE (or any other error for that matter) is returned on an operation other than the first operation (SEQUENCE or CB_SEQUENCE), then the reply MUST be cached if sa_cachethis or csa_cachethis is TRUE. For example, if a COMPOUND has eleven operations, including SEQUENCE, the fifth operation is a RENAME, and the tenth operation is a READ for one million bytes, the server may return NFS4ERR_REP_TOO_BIG_TO_CACHE on the tenth operation. Since the server executed several operations, especially the non-idempotent RENAME, the client's request to cache the reply needs to be honored in order for the correct operation of exactly once semantics. If the client retries the request, the server will have cached a reply that contains results for ten of the eleven requested operations, with the tenth operation having a status of NFS4ERR_REP_TOO_BIG_TO_CACHE.",
      "ja": "sa_cachethisまたはcsa_cachethisがTRUEの場合、リプライヤはエラーがSEQUENCEまたはCB_SEQUENCE操作によって返された場合を除き、応答をキャッシュしなければならない（セクション2.10.6.1.2を参照してください）。応答がca_maxresponsesize_cached（及びsa_cachethis又はcsa_cachethis TRUEである）を超えている場合、サーバはNFS4ERR_REP_TOO_BIG_TO_CACHEを返さなければなりません。 NFS4ERR_REP_TOO_BIG_TO_CACHE（またはそのことについては、他のエラーが）最初の操作（配列またはCB_SEQUENCE）以外の動作に戻してもsa_cachethis又はcsa_cachethisがtrueの場合、応答がキャッシュされなければなりません。化合物は、配列を含む11回の動作を有する場合、例えば、第5の動作はRENAMEであり、第10動作は100万バイトのために読み取られ、サーバは、第10の動作についてNFS4ERR_REP_TOO_BIG_TO_CACHEを返すことができます。サーバはいくつかの操作、特に非冪等のRENAMEを実行しているので、回答をキャッシュするクライアントの要求を正確に意味論かつての正しい動作のために光栄する必要があります。クライアントが要求を再試行した場合、サーバーは、第10の動作がNFS4ERR_REP_TOO_BIG_TO_CACHEの地位を有する11の要求された操作の10の結果が含まれている応答を、キャッシュされています。"
    },
    {
      "indent": 3,
      "text": "A client needs to take care that when sending operations that change the current filehandle (except for PUTFH, PUTPUBFH, PUTROOTFH, and RESTOREFH), it not exceed the maximum reply buffer before the GETFH operation. Otherwise, the client will have to retry the operation that changed the current filehandle, in order to obtain the desired filehandle. For the OPEN operation (see Section 18.16), retry is not always available as an option. The following guidelines for the handling of filehandle-changing operations are advised: o Within the same COMPOUND procedure, a client SHOULD send GETFH immediately after a current filehandle-changing operation. A client MUST send GETFH after a current filehandle-changing operation that is also non-idempotent (e.g., the OPEN operation), unless the operation is RESTOREFH. RESTOREFH is an exception, because even though it is non-idempotent, the filehandle RESTOREFH produced originated from an operation that is either idempotent (e.g., PUTFH, LOOKUP), or non-idempotent (e.g., OPEN, CREATE). If the origin is non-idempotent, then because the client MUST send GETFH after the origin operation, the client can recover if RESTOREFH returns an error.",
      "ja": "クライアントは（PUTFH、PUTPUBFH、PUTROOTFH、およびRESTOREFHを除く）は、現在のファイルハンドルを変更する操作を送信するとき、それはGETFH操作の前に最大応答バッファを超えないようにすることを世話をする必要があります。そうしないと、クライアントは必要なファイルハンドルを得るために、現在のファイルハンドルを変更し、操作を再試行する必要があります。 OPEN操作のために、常にオプションとして使用できません再試行（項18.16を参照してください）。ファイルハンドルを変える操作の取り扱いについては、次のガイドラインが推奨されます。同じCOMPOUNDプロシージャ内O、クライアントは、現在のファイルハンドル、変更操作の直後にGETFHを送るべきです。動作はRESTOREFHでない限り、クライアントは、非冪等（例えば、OPEN操作）も現在のファイルハンドル、変更操作後GETFHを送らなければなりません。それは非冪等であってもためRESTOREFHは例外で、生成ファイルハンドルRESTOREFHは冪等（例えば、PUTFH、LOOKUP）、または非冪等（例えば、OPEN、CREATE）のいずれかで動作由来します。起源が非冪等である場合には、クライアントが原点操作後GETFHを送らなければなりませんのでRESTOREFHがエラーを返した場合、その後、クライアントは回復することができます。"
    },
    {
      "indent": 3,
      "text": "o A server MAY return NFS4ERR_REP_TOO_BIG or NFS4ERR_REP_TOO_BIG_TO_CACHE (if sa_cachethis is TRUE) on a filehandle-changing operation if the reply would be too large on the next operation.",
      "ja": "（sa_cachethisがTRUEの場合）応答が次の動作に大きすぎる場合にOサーバは、ファイルハンドルを変える操作にNFS4ERR_REP_TOO_BIG又はNFS4ERR_REP_TOO_BIG_TO_CACHEを返すことができます。"
    },
    {
      "indent": 3,
      "text": "o A server SHOULD return NFS4ERR_REP_TOO_BIG or NFS4ERR_REP_TOO_BIG_TO_CACHE (if sa_cachethis is TRUE) on a filehandle-changing, non-idempotent operation if the reply would be too large on the next operation, especially if the operation is OPEN.",
      "ja": "（sa_cachethisがTRUEである場合）、応答動作が開いている場合は特に、次の操作には大きすぎることになる場合、Oサーバは、ファイルハンドルを変える、非冪等操作にNFS4ERR_REP_TOO_BIG又はNFS4ERR_REP_TOO_BIG_TO_CACHEを返すべきです。"
    },
    {
      "indent": 3,
      "text": "o A server MAY return NFS4ERR_UNSAFE_COMPOUND to a non-idempotent current filehandle-changing operation, if it looks at the next operation (in the same COMPOUND procedure) and finds it is not GETFH. The server SHOULD do this if it is unable to determine in advance whether the total response size would exceed ca_maxresponsesize_cached or ca_maxresponsesize.",
      "ja": "それは（同じCOMPOUND手順で）次の操作を見て、それがGETFHない見つけた場合、Oサーバは、非冪等、現在のファイルハンドル-変更操作にNFS4ERR_UNSAFE_COMPOUNDを返してもよいです。合計応答サイズがca_maxresponsesize_cachedまたはca_maxresponsesizeを超えるかどうかを事前に決定することができない場合、サーバは、これを行うべきです。"
    },
    {
      "indent": 0,
      "text": "2.10.6.5. Persistence",
      "section_title": true,
      "ja": "2.10.6.5。固執"
    },
    {
      "indent": 3,
      "text": "Since the reply cache is bounded, it is practical for the reply cache to persist across server restarts. The replier MUST persist the following information if it agreed to persist the session (when the session was created; see Section 18.36):",
      "ja": "返信キャッシュが制限されているので、サーバーの再起動しても持続する応答キャッシュのための実用的です。それは、セッションを持続することに同意した場合リプライヤは、以下の情報を保持しなければならない（セッションが作成されたときに、セクション18.36を参照してください）："
    },
    {
      "indent": 3,
      "text": "o The session ID.",
      "ja": "セッションID、O。"
    },
    {
      "indent": 3,
      "text": "o The slot table including the sequence ID and cached reply for each slot.",
      "ja": "各スロットのシーケンス番号と、キャッシュされた応答を含むスロットテーブルO。"
    },
    {
      "indent": 3,
      "text": "The above are sufficient for a replier to provide EOS semantics for any requests that were sent and executed before the server restarted. If the replier is a client, then there is no need for it to persist any more information, unless the client will be persisting all other state across client restart, in which case, the server will never see any NFSv4.1-level protocol manifestation of a client restart. If the replier is a server, with just the slot table and session ID persisting, any requests the client retries after the server restart will return the results that are cached in the reply cache, and any new requests (i.e., the sequence ID is one greater than the slot's sequence ID) MUST be rejected with NFS4ERR_DEADSESSION (returned by SEQUENCE). Such a session is considered dead. A server MAY re-animate a session after a server restart so that the session will accept new requests as well as retries. To re-animate a session, the server needs to persist additional information through server restart:",
      "ja": "上記は、サーバーを再起動する前に送信され、実行されたすべての要求のためのEOSセマンティクスを提供するために、リプライヤには十分です。リプライヤがクライアントである場合、それは任意のより多くの情報を永続化するための必要はありません、クライアントは、クライアントの再起動を越え、他の全ての状態を永続化されていない限り、サーバーはNFSv4.1レベルのプロトコルの症状を見ることはありません、その場合、クライアントの再起動の。リプライヤはちょうどスロットテーブルとセッションID持続して、サーバーの場合は、サーバーの再起動後にすべての要求クライアントの再試行が応答キャッシュ内にキャッシュされた結果、および任意の新しい要求（すなわちを返し、シーケンスIDは1ですスロットのシーケンスID）よりも大きいがNFS4ERR_DEADSESSION（配列によって返される）で拒否されなければなりません。このようなセッションが死んだと考えられています。セッションは、新しい要求だけでなく、再試行を受け入れるように、サーバーは、サーバーの再起動後にセッションを再アニメーション化するかもしれません。セッションを再アニメーション化するには、サーバは、サーバの再起動によって、追加情報を永続化する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The client ID. This is a prerequisite to let the client create more sessions associated with the same client ID as the re-animated session.",
      "ja": "クライアントID、O。これは、クライアントが再アニメ化セッションと同じクライアントIDに関連付けられた複数のセッションを作成してみましょうするための前提条件です。"
    },
    {
      "indent": 3,
      "text": "o The client ID's sequence ID that is used for creating sessions (see Sections 18.35 and 18.36). This is a prerequisite to let the client create more sessions.",
      "ja": "セッションを作成するために使用されているクライアントIDのシーケンスID O（セクション18.35と18.36を参照してください）。これは、クライアントが複数のセッションを作成してみましょうするための前提条件です。"
    },
    {
      "indent": 3,
      "text": "o The principal that created the client ID. This allows the server to authenticate the client when it sends EXCHANGE_ID.",
      "ja": "クライアントIDを作成した校長O。これは、EXCHANGE_IDを送信するときに、サーバーがクライアントを認証することができます。"
    },
    {
      "indent": 3,
      "text": "o The SSV, if SP4_SSV state protection was specified when the client ID was created (see Section 18.35). This lets the client create new sessions, and associate connections with the new and existing sessions.",
      "ja": "クライアントIDが作成されたときSP4_SSV状態の保護が指定されている場合SSV O、（項18.35を参照してください）。これにより、クライアントは新しいセッションを作成することができ、新規および既存のセッションに関連付ける接続。"
    },
    {
      "indent": 3,
      "text": "o The properties of the client ID as defined in Section 18.35.",
      "ja": "クライアントIDのプロパティoをセクション18.35で定義されています。"
    },
    {
      "indent": 3,
      "text": "A persistent reply cache places certain demands on the server. The execution of the sequence of operations (starting with SEQUENCE) and placement of its results in the persistent cache MUST be atomic. If a client retries a sequence of operations that was previously executed on the server, the only acceptable outcomes are either the original cached reply or an indication that the client ID or session has been lost (indicating a catastrophic loss of the reply cache or a session that has been deleted because the client failed to use the session for an extended period of time).",
      "ja": "持続応答キャッシュは、サーバー上の特定の要求を課します。永続キャッシュの動作のシーケンスの実行（SEQUENCEで始まる）とその結果の配置は、アトミックでなければなりません。クライアントが以前にサーバー上で実行された一連の操作を再試行した場合、唯一の許容可能な結果は、元のキャッシュされた応答または応答キャッシュやセッションの壊滅的な損失を示すクライアントIDまたはセッションが失われたことを示す（どちらかでありますクライアントが長時間にわたってセッションを使用することができなかったので、それは）削除されています。"
    },
    {
      "indent": 3,
      "text": "A server could fail and restart in the middle of a COMPOUND procedure that contains one or more non-idempotent or idempotent-but-modifying operations. This creates an even higher challenge for atomic execution and placement of results in the reply cache. One way to view the problem is as a single transaction consisting of each operation in the COMPOUND followed by storing the result in persistent storage, then finally a transaction commit. If there is a failure before the transaction is committed, then the server rolls back the transaction. If the server itself fails, then when it restarts, its recovery logic could roll back the transaction before starting the NFSv4.1 server.",
      "ja": "サーバーは、1つ以上の非冪等または冪等-が、変更などの操作が含まれていますCOMPOUND手順の途中で失敗して再起動できます。これは、原子、実行し、応答キャッシュ内の結果を配置するためのさらに高い挑戦を作成します。問題を表示する一つの方法は、最後にトランザクションがコミット、永続ストレージに結果を格納することによって、続いて化合物中の各操作からなる単一のトランザクションとしてあります。トランザクションがコミットされる前に、障害が発生した場合、サーバは、トランザクションをロールバックします。サーバ自体に障害が発生した場合、それが再起動したときに、それから、その回復ロジックはNFSv4.1サーバーを起動する前に、トランザクションをロールバックすることができます。"
    },
    {
      "indent": 3,
      "text": "While the description of the implementation for atomic execution of the request and caching of the reply is beyond the scope of this document, an example implementation for NFSv2 [38] is described in [39].",
      "ja": "応答の要求とキャッシングのアトミック実行の実装の説明はこの文書の範囲外であるが、のNFSv2 [38]のための例示的な実施形態は、[39]に記載されています。"
    },
    {
      "indent": 0,
      "text": "2.10.7. RDMA Considerations",
      "section_title": true,
      "ja": "2.10.7.  RDMAの考慮事項"
    },
    {
      "indent": 3,
      "text": "A complete discussion of the operation of RPC-based protocols over RDMA transports is in [8]. A discussion of the operation of NFSv4, including NFSv4.1, over RDMA is in [9]. Where RDMA is considered, this specification assumes the use of such a layering; it addresses only the upper-layer issues relevant to making best use of RPC/RDMA.",
      "ja": "RDMAトランスポート経由でRPCベースのプロトコルの動作の完全な議論はである[8]。 RDMA上NFSv4.1などのNFSv4の動作の議論は、[9]です。 RDMAが考慮されている場合、この仕様は、このようなレイヤーの使用を前提とし、それは、RPC / RDMAを活かしに関連する唯一の上位層の問題に対処します。"
    },
    {
      "indent": 0,
      "text": "2.10.7.1. RDMA Connection Resources",
      "section_title": true,
      "ja": "2.10.7.1。 RDMA接続リソース"
    },
    {
      "indent": 3,
      "text": "RDMA requires its consumers to register memory and post buffers of a specific size and number for receive operations.",
      "ja": "RDMAは、受信操作のための具体的なサイズと数のメモリとポストバッファを登録するには、その消費者が必要です。"
    },
    {
      "indent": 3,
      "text": "Registration of memory can be a relatively high-overhead operation, since it requires pinning of buffers, assignment of attributes (e.g., readable/writable), and initialization of hardware translation. Preregistration is desirable to reduce overhead. These registrations are specific to hardware interfaces and even to RDMA connection endpoints; therefore, negotiation of their limits is desirable to manage resources effectively.",
      "ja": "それはハードウェア翻訳のバッファのピンニング、属性の割り当て（例えば、リード/ライト可能）、及び初期化を必要とするのでメモリの登録は、比較的高いオーバーヘッド操作することができます。事前登録は、オーバーヘッドを低減することが望ましいです。これらの登録は、ハードウェアインターフェースへ、さらにRDMA接続のエンドポイントに固有です。そのため、その限界の交渉は、効果的にリソースを管理することが望ましいです。"
    },
    {
      "indent": 3,
      "text": "Following basic registration, these buffers must be posted by the RPC layer to handle receives. These buffers remain in use by the RPC/ NFSv4.1 implementation; the size and number of them must be known to the remote peer in order to avoid RDMA errors that would cause a fatal error on the RDMA connection.",
      "ja": "基本登録に続いて、これらのバッファは、受信処理するために、RPC層によって投稿されなければなりません。これらのバッファは、RPC / NFSv4.1実装で使用されて残っています。それらの大きさや数は、RDMA接続に致命的なエラーを引き起こすRDMAエラーを回避するために、リモートピアに知らなければなりません。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 manages slots as resources on a per-session basis (see Section 2.10), while RDMA connections manage credits on a per-connection basis. This means that in order for a peer to send data over RDMA to a remote buffer, it has to have both an NFSv4.1 slot and an RDMA credit. If multiple RDMA connections are associated with a session, then if the total number of credits across all RDMA connections associated with the session is X, and the number of slots in the session is Y, then the maximum number of outstanding requests is the lesser of X and Y.",
      "ja": "RDMA接続は、接続ごとにクレジットを管理しながら、NFSv4.1は、セッションごとにリソースとしてスロットを管理し、（2.10節を参照してください）。これは、リモートバッファへRDMAを介してデータを送信するピアのために、それはNFSv4.1スロットとRDMAクレジットの両方を有していなければならないことを意味します。複数RDMA接続がセッションに関連付けられている場合、そのセッションに関連付けられているすべてのRDMA接続の両端のクレジットの総数はXであり、そしてセッションのスロット数がYである場合、未解決の要求の最大数の少ないですXおよびY."
    },
    {
      "indent": 0,
      "text": "2.10.7.2. Flow Control",
      "section_title": true,
      "ja": "2.10.7.2。フロー制御"
    },
    {
      "indent": 3,
      "text": "Previous versions of NFS do not provide flow control; instead, they rely on the windowing provided by transports like TCP to throttle requests. This does not work with RDMA, which provides no operation flow control and will terminate a connection in error when limits are exceeded. Limits such as maximum number of requests outstanding are therefore negotiated when a session is created (see the ca_maxrequests field in Section 18.36). These limits then provide the maxima within which each connection associated with the session's channel(s) must remain. RDMA connections are managed within these limits as described in Section 3.3 of [8]; if there are multiple RDMA connections, then the maximum number of requests for a channel will be divided among the RDMA connections. Put a different way, the onus is on the replier to ensure that the total number of RDMA credits across all connections associated with the replier's channel does exceed the channel's maximum number of outstanding requests.",
      "ja": "NFSの以前のバージョンでは、フロー制御を提供していません。代わりに、彼らはスロットル要求にTCPのようなトランスポートが提供するウィンドウに依存しています。これは、何も操作フロー制御を提供しないし、制限を超えたときにエラーに接続を終了するRDMA、動作しません。セッションが作成されたときに、このような未処理の要求の最大数などの制限は、そのために交渉されている（セクション18.36でca_maxrequestsフィールドを参照してください）。これらの制限は、セッションのチャネル（単数または複数）に関連付けられた各接続が残っている必要があり、その中の最大値を提供します。 [8]のセクション3.3に記載されているようにRDMA接続は、これらの制限内で管理されています。複数RDMA接続がある場合、チャネルの要求の最大数は、RDMA接続の間で分割されます。別の言い方をすれば、責任はリプライヤのチャネルに関連付けられているすべての接続間でRDMAクレジットの総数が未処理の要求のチャネルの最大数を超えないことを確実にするためにリプライヤです。"
    },
    {
      "indent": 3,
      "text": "The limits may also be modified dynamically at the replier's choosing by manipulating certain parameters present in each NFSv4.1 reply. In addition, the CB_RECALL_SLOT callback operation (see Section 20.8) can be sent by a server to a client to return RDMA credits to the server, thereby lowering the maximum number of requests a client can have outstanding to the server.",
      "ja": "制限は、各NFSv4.1応答中に存在する特定のパラメータを操作することによって、回答者の選んで動的に変更することができます。また、CB_RECALL_SLOTコールバック操作は（セクション20.8を参照）、これにより、クライアントがサーバーへの未持つことができる要求の最大数を下げ、サーバーへのRDMAクレジットを返すためにサーバからクライアントに送信することができます。"
    },
    {
      "indent": 0,
      "text": "2.10.7.3. Padding",
      "section_title": true,
      "ja": "2.10.7.3。パディング"
    },
    {
      "indent": 3,
      "text": "Header padding is requested by each peer at session initiation (see the ca_headerpadsize argument to CREATE_SESSION in Section 18.36), and subsequently used by the RPC RDMA layer, as described in [8]. Zero padding is permitted.",
      "ja": "記載されているように、ヘッダパディングは、[8]、（セクション18.36にCREATE_SESSIONにca_headerpadsize引数を参照）、セッション開始時に各ピアによって要求され、続いてRPC RDMA層によって使用されます。ゼロパディングは許可されています。"
    },
    {
      "indent": 3,
      "text": "Padding leverages the useful property that RDMA preserve alignment of data, even when they are placed into anonymous (untagged) buffers. If requested, client inline writes will insert appropriate pad bytes within the request header to align the data payload on the specified boundary. The client is encouraged to add sufficient padding (up to the negotiated size) so that the \"data\" field of the WRITE operation is aligned. Most servers can make good use of such padding, which allows them to chain receive buffers in such a way that any data carried by client requests will be placed into appropriate buffers at the server, ready for file system processing. The receiver's RPC layer encounters no overhead from skipping over pad bytes, and the RDMA layer's high performance makes the insertion and transmission of padding on the sender a significant optimization. In this way, the need for servers to perform RDMA Read to satisfy all but the largest client writes is obviated. An added benefit is the reduction of message round trips on the network -- a potentially good trade, where latency is present.",
      "ja": "パディングは、RDMAは、それらが匿名（タグなし）バッファに配置されている場合でも、データの位置合わせを維持する有用な特性を活用します。要求された場合、クライアントインライン書き込みが指定された境界上のデータペイロードを整列させるために要求ヘッダ内の適切なパッドバイトを挿入します。クライアントは、書き込み動作の「データ」フィールドが整列されるように（交渉さサイズまで）十分なパディングを追加することが推奨されます。ほとんどのサーバーは、クライアントの要求によって運ばれる任意のデータは、ファイルシステム処理の準備ができて、サーバで適切な緩衝液の中に置かれるように受信バッファをチェーンにそれらを可能なパディング、を十分に活用することができます。受信機のRPC層はパッドバイトをスキップからのオーバーヘッドに遭遇せず、RDMA層の高性能は、送信側でパディングの挿入及び送信著しい最適化を行います。このように、サーバはすべてが、最大のクライアントの書き込みを満たすために、RDMA読み取りを実行するために必要性が回避されます。潜在的に良好なトレード、待ち時間が存在する - 付加的な利点は、ネットワーク上のラウンドトリップメッセージの減少です。"
    },
    {
      "indent": 3,
      "text": "The value to choose for padding is subject to a number of criteria. A primary source of variable-length data in the RPC header is the authentication information, the form of which is client-determined, possibly in response to server specification. The contents of COMPOUNDs, sizes of strings such as those passed to RENAME, etc. all go into the determination of a maximal NFSv4.1 request size and therefore minimal buffer size. The client must select its offered value carefully, so as to avoid overburdening the server, and vice versa. The benefit of an appropriate padding value is higher performance.",
      "ja": "パディングのために選択する値は、多くの基準に従うものとします。 RPCヘッダーの可変長データのプライマリソースは、認証情報、おそらくサーバ仕様に応答して、クライアント決定されるの一形態です。等の化合物、そのような名前を変更するに渡されるものとして文字列のサイズの内容は全て、最大NFSv4.1要求サイズ、したがって最小のバッファサイズの決定に入ります。クライアントは、サーバーに過度な負担をかける避けるために、慎重に提供された値を選択し、その逆なければなりません。適切なパディング値の利点は、より高いパフォーマンスです。"
    },
    {
      "indent": 8,
      "text": "            Sender gather:\n|RPC Request|Pad  bytes|Length| -> |User data...|\n\\------+----------------------/      \\\n        \\                             \\\n         \\    Receiver scatter:        \\-----------+- ...\n    /-----+----------------\\            \\           \\\n    |RPC Request|Pad|Length|   ->  |FS buffer|->|FS buffer|->...",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the above case, the server may recycle unused buffers to the next posted receive if unused by the actual received request, or may pass the now-complete buffers by reference for normal write processing. For a server that can make use of it, this removes any need for data copies of incoming data, without resorting to complicated end-to-end buffer advertisement and management. This includes most kernel-based and integrated server designs, among many others. The client may perform similar optimizations, if desired.",
      "ja": "上記の場合、サーバは次の未使用のバッファをリサイクルできる未使用の場合、実際の受信要求によって受け取る、または通常のライト処理のために参照により今や完全バッファを通過することができる投稿。それを利用することができますサーバーの場合、これは複雑なエンドツーエンドのバッファ広告及び管理に頼ることなく、入ってくるデータのデータ・コピーの必要性を取り除きます。これは、他の多くの間で最もカーネルベースと統合サーバの設計が含まれています。必要であれば、クライアントは、同様の最適化を行うことができます。"
    },
    {
      "indent": 0,
      "text": "2.10.7.4. Dual RDMA and Non-RDMA Transports",
      "section_title": true,
      "ja": "2.10.7.4。デュアルRDMAおよび非RDMAトランスポート"
    },
    {
      "indent": 3,
      "text": "Some RDMA transports (e.g., RFC 5040 [10]) permit a \"streaming\" (non-RDMA) phase, where ordinary traffic might flow before \"stepping up\" to RDMA mode, commencing RDMA traffic. Some RDMA transports start connections always in RDMA mode. NFSv4.1 allows, but does not assume, a streaming phase before RDMA mode. When a connection is associated with a session, the client and server negotiate whether the connection is used in RDMA or non-RDMA mode (see Sections 18.36 and 18.34).",
      "ja": "いくつかのRDMAトランスポート（例えば、RFC 5040 [10]）は、通常のトラフィックがRDMAトラフィックを開始、RDMAモードに「ステップアップ」の前に流れるかもしれない「ストリーミング」（非RDMA）相を、許可します。いくつかのRDMAは、RDMAモードで常に接続を開始運びます。 NFSv4.1はできますが、RDMAモードの前に、ストリーミング相を負いません。接続は、セッションに関連付けられている場合、クライアントとサーバが接続をRDMAまたは非RDMAモードで使用されているか否かを交渉する（セクション18.36と18.34を参照のこと）。"
    },
    {
      "indent": 0,
      "text": "2.10.8. Session Security",
      "section_title": true,
      "ja": "2.10.8. セッションのセキュリティ"
    },
    {
      "indent": 0,
      "text": "2.10.8.1. Session Callback Security",
      "section_title": true,
      "ja": "2.10.8.1。セッションコールバックのセキュリティ"
    },
    {
      "indent": 3,
      "text": "Via session/connection association, NFSv4.1 improves security over that provided by NFSv4.0 for the backchannel. The connection is client-initiated (see Section 18.34) and subject to the same firewall and routing checks as the fore channel. At the client's option (see Section 18.35), connection association is fully authenticated before being activated (see Section 18.34). Traffic from the server over the backchannel is authenticated exactly as the client specifies (see Section 2.10.8.2).",
      "ja": "セッション/接続会合を介して、NFSv4.1は、バックチャネルのためNFSv4.0で提供されるものの上にセキュリティが向上します。接続は、クライアントが開始し（セクション18.34を参照）、前方チャネルと同じファイアウォールおよびルーティングチェックを受けます。クライアントのオプションでは、接続の関連付けが完全に（項18.34を参照）が起動される前に認証される（セクション18.35を参照）。バックチャネルを介してサーバからのトラフィックは、クライアントが指定する（セクション2.10.8.2を参照）として正確に認証されます。"
    },
    {
      "indent": 0,
      "text": "2.10.8.2. Backchannel RPC Security",
      "section_title": true,
      "ja": "2.10.8.2。バックチャネルRPCセキュリティ"
    },
    {
      "indent": 3,
      "text": "When the NFSv4.1 client establishes the backchannel, it informs the server of the security flavors and principals to use when sending requests. If the security flavor is RPCSEC_GSS, the client expresses the principal in the form of an established RPCSEC_GSS context. The server is free to use any of the flavor/principal combinations the client offers, but it MUST NOT use unoffered combinations. This way, the client need not provide a target GSS principal for the backchannel as it did with NFSv4.0, nor does the server have to implement an RPCSEC_GSS initiator as it did with NFSv4.0 [30].",
      "ja": "NFSv4.1のクライアントはバックチャネルを確立すると、それは要求を送信するときに使用するセキュリティの味とプリンシパルのサーバーに通知します。セキュリティ風味がRPCSEC_GSSの場合、クライアントは確立RPCSEC_GSSコンテキストの形でプリンシパルを表現しています。サーバーは、クライアントが提供しています味/元本の組み合わせのいずれかを使用して自由であるが、それはunofferedの組み合わせを使用してはなりません。それはNFSv4.0で行ったように、この方法では、クライアントはバックチャネル用のターゲットGSSプリンシパルを提供する必要はない、またサーバーは、それがNFSv4.0 [30]で行ったようにRPCSEC_GSSイニシエータを実装する必要がありません。"
    },
    {
      "indent": 3,
      "text": "The CREATE_SESSION (Section 18.36) and BACKCHANNEL_CTL (Section 18.33) operations allow the client to specify flavor/ principal combinations.",
      "ja": "CREATE_SESSION（セクション18.36）とBACKCHANNEL_CTL（セクション18.33）の操作は、クライアントが、風味/主組み合わせを指定することを可能にします。"
    },
    {
      "indent": 3,
      "text": "Also note that the SP4_SSV state protection mode (see Sections 18.35 and 2.10.8.3) has the side benefit of providing SSV-derived RPCSEC_GSS contexts (Section 2.10.9).",
      "ja": "またSP4_SSV状態保護モード（セクション18.35と2.10.8.3を参照）SSV由来RPCSEC_GSSコンテキスト（セクション2.10.9）を提供するという副次的な利点を持っていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.10.8.3. Protection from Unauthorized State Changes",
      "section_title": true,
      "ja": "2.10.8.3。無許可ステートの変更からの保護"
    },
    {
      "indent": 3,
      "text": "As described to this point in the specification, the state model of NFSv4.1 is vulnerable to an attacker that sends a SEQUENCE operation with a forged session ID and with a slot ID that it expects the legitimate client to use next. When the legitimate client uses the slot ID with the same sequence number, the server returns the attacker's result from the reply cache, which disrupts the legitimate client and thus denies service to it. Similarly, an attacker could send a CREATE_SESSION with a forged client ID to create a new session associated with the client ID. The attacker could send requests using the new session that change locking state, such as LOCKU operations to release locks the legitimate client has acquired. Setting a security policy on the file that requires RPCSEC_GSS credentials when manipulating the file's state is one potential work around, but has the disadvantage of preventing a legitimate client from releasing state when RPCSEC_GSS is required to do so, but a GSS context cannot be obtained (possibly because the user has logged off the client).",
      "ja": "明細書中のここまで説明したように、NFSv4.1の状態モデルは、鍛造、セッションIDと、それが正当なクライアントが次に使用する予定のスロットIDとシーケンス動作を送信する攻撃者に対して脆弱です。正当なクライアントが同じシーケンス番号とスロットIDを使用すると、サーバーは、正当なクライアントを破壊返信キャッシュから攻撃者の結果を返すので、それへのサービスを拒否します。同様に、攻撃者は、クライアントIDに関連付けられた新しいセッションを作成するために、偽造クライアントIDとCREATE_SESSIONを送信することができます。攻撃者は、正当なクライアントが取得したロックを解放するために、このようなLOCKU操作として、ロック状態を変更するには、新しいセッションを使用して要求を送信することができます。ファイルの状態を操作するときRPCSEC_GSS資格情報を必要とし、ファイルのセキュリティポリシーを設定すると（約1つの潜在的な仕事ですが、RPCSEC_GSSはそうする必要がある場合に状態を解除する正当なクライアントを防止するという欠点がありますが、GSSコンテキストを得ることができません多分）ユーザーがクライアントをログオフしたため。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 provides three options to a client for state protection, which are specified when a client creates a client ID via EXCHANGE_ID (Section 18.35).",
      "ja": "NFSv4.1は、クライアントがEXCHANGE_ID（セクション18.35）を介してクライアントIDを作成するときに指定されている状態の保護、のためにクライアントに3つのオプションを提供します。"
    },
    {
      "indent": 3,
      "text": "The first (SP4_NONE) is to simply waive state protection.",
      "ja": "最初（SP4_NONE）単に状態の保護を放棄することです。"
    },
    {
      "indent": 3,
      "text": "The other two options (SP4_MACH_CRED and SP4_SSV) share several traits:",
      "ja": "他の2つのオプション（SP4_MACH_CREDとSP4_SSV）は、いくつかの特徴を共有します："
    },
    {
      "indent": 3,
      "text": "o An RPCSEC_GSS-based credential is used to authenticate client ID and session maintenance operations, including creating and destroying a session, associating a connection with the session, and destroying the client ID.",
      "ja": "O RPCSEC_GSSベースの資格証明を作成し、セッションを破壊、セッションとの接続を関連付け、クライアントIDを破壊含むクライアントIDとセッション維持操作を認証するために使用されます。"
    },
    {
      "indent": 3,
      "text": "o Because RPCSEC_GSS is used to authenticate client ID and session maintenance, the attacker cannot associate a rogue connection with a legitimate session, or associate a rogue session with a legitimate client ID in order to maliciously alter the client ID's lock state via CLOSE, LOCKU, DELEGRETURN, LAYOUTRETURN, etc.",
      "ja": "RPCSEC_GSSは、クライアントIDとセッション維持を認証するために使用されるため、攻撃者は正当なセッションとの不正な接続を関連付ける、あるいは悪意を持っCLOSEを介してクライアントIDのロック状態を変更するために、正当なクライアントIDで不正なセッションを関連付けることはできませんO、LOCKU、 DELEGRETURN、LAYOUTRETURNなど"
    },
    {
      "indent": 3,
      "text": "o In cases where the server's security policies on a portion of its namespace require RPCSEC_GSS authentication, a client may have to use an RPCSEC_GSS credential to remove per-file state (e.g., LOCKU, CLOSE, etc.). The server may require that the principal that removes the state match certain criteria (e.g., the principal might have to be the same as the one that acquired the state). However, the client might not have an RPCSEC_GSS context for such a principal, and might not be able to create such a context (perhaps because the user has logged off). When the client establishes SP4_MACH_CRED or SP4_SSV protection, it can specify a list of operations that the server MUST allow using the machine credential (if SP4_MACH_CRED is used) or the SSV credential (if SP4_SSV is used).",
      "ja": "Oその名前空間の一部に、サーバーのセキュリティポリシーは、RPCSEC_GSS認証が必要なケースでは、クライアントごとのファイルの状態（例えば、LOCKU、CLOSE、など）を除去するRPCSEC_GSS資格を使用する必要があります。サーバは、状態一致特定の基準を削除プリンシパルが（例えば、主に状態を取得したものと同じでなければならないかもしれない）ことを要求することができます。ただし、クライアントは、プリンシパルのRPCSEC_GSSコンテキストを持っていない可能性があり、および（ユーザーがログオフしているかもしれないので）、このようなコンテキストを作成することができない場合があります。クライアントがSP4_MACH_CREDまたはSP4_SSV保護を確立すると、それは（SP4_SSVが使用されている場合）、サーバは（SP4_MACH_CREDが使用されている場合）、マシンの資格やSSVの資格を使用して許可しなければならないこと操作のリストを指定することができます。"
    },
    {
      "indent": 3,
      "text": "The SP4_MACH_CRED state protection option uses a machine credential where the principal that creates the client ID MUST also be the principal that performs client ID and session maintenance operations. The security of the machine credential state protection approach depends entirely on safe guarding the per-machine credential. Assuming a proper safeguard using the per-machine credential for operations like CREATE_SESSION, BIND_CONN_TO_SESSION,",
      "ja": "SP4_MACH_CREDステート保護オプションは、クライアントのIDを作成し、プリンシパルは、クライアントIDとセッション維持操作を実行元本でなければならないマシンクレデンシャルを使用しています。マシンクレデンシャルステート保護アプローチのセキュリティは、マシンごとの資格を守って安全に完全に依存します。 CREATE_SESSION、BIND_CONN_TO_SESSIONのような操作のためにマシンごとの資格情報を使用して、適切な安全装置を想定すると、"
    },
    {
      "indent": 3,
      "text": "DESTROY_SESSION, and DESTROY_CLIENTID will prevent an attacker from associating a rogue connection with a session, or associating a rogue session with a client ID.",
      "ja": "DESTROY_SESSION、およびDESTROY_CLIENTIDは、セッションとの不正な接続を関連付ける、またはクライアントIDに不正なセッションを関連付けることから、攻撃者を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "There are at least three scenarios for the SP4_MACH_CRED option:",
      "ja": "SP4_MACH_CREDオプションの少なくとも3つのシナリオがあります。"
    },
    {
      "indent": 3,
      "text": "1. The system administrator configures a unique, permanent per-machine credential for one of the mandated GSS mechanisms (e.g., if Kerberos V5 is used, a \"keytab\" containing a principal derived from a client host name could be used).",
      "ja": "1.システム管理者が義務付けGSS機構の一つのためのユニークな、永久的なマシンごとの資格を設定する（ケルベロスV5が使用される場合、例えば、クライアントのホスト名に由来するプリンシパルを含む「キータブ」が使用され得ます）。"
    },
    {
      "indent": 3,
      "text": "2. The client is used by a single user, and so the client ID and its sessions are used by just that user. If the user's credential expires, then session and client ID maintenance cannot occur, but since the client has a single user, only that user is inconvenienced.",
      "ja": "2.クライアントは、単一のユーザーによって使用され、そのクライアントIDとそのセッションはちょうどそのユーザーによって使用されています。ユーザーの資格情報の有効期限が切れた場合は、セッションおよびクライアントIDのメンテナンスが発生することはできませんが、クライアントは単一のユーザーを持っているため、そのユーザのみが不便されます。"
    },
    {
      "indent": 3,
      "text": "3. The physical client has multiple users, but the client implementation has a unique client ID for each user. This is effectively the same as the second scenario, but a disadvantage is that each user needs to be allocated at least one session each, so the approach suffers from lack of economy.",
      "ja": "3.物理的なクライアントは、複数のユーザーを持っていますが、クライアントの実装では、各ユーザーの一意のクライアントIDを持っています。これは効果的に第2のシナリオと同じであるが、欠点は、アプローチが、経済性の欠如に苦しんでいるように、各ユーザは、少なくとも一つのセッション毎に割り当てられる必要があることです。"
    },
    {
      "indent": 3,
      "text": "The SP4_SSV protection option uses the SSV (Section 1.6), via RPCSEC_GSS and the SSV GSS mechanism (Section 2.10.9), to protect state from attack. The SP4_SSV protection option is intended for the situation comprised of a client that has multiple active users and a system administrator who wants to avoid the burden of installing a permanent machine credential on each client. The SSV is established and updated on the server via SET_SSV (see Section 18.47). To prevent eavesdropping, a client SHOULD send SET_SSV via RPCSEC_GSS with the privacy service. Several aspects of the SSV make it intractable for an attacker to guess the SSV, and thus associate rogue connections with a session, and rogue sessions with a client ID:",
      "ja": "SP4_SSV保護オプションは、攻撃から国家を守るために、RPCSEC_GSSとSSV GSSメカニズム（セクション2.10.9）を介して、SSV（1.6節）を使用しています。 SP4_SSV保護オプションは、複数のアクティブユーザーと各クライアントに永続的なマシンの資格をインストールするの負担を避けたいシステム管理者を持つクライアントで構成状況を対象としています。 SSVが確立され、SET_SSVを経由してサーバー上で更新されます（セクション18.47を参照してください）。盗聴を防ぐために、クライアントは、プライバシーサービスをRPCSEC_GSS経由SET_SSVを送るべきです。 SSVのいくつかの態様は、クライアントのIDを持つセッションで不正な接続、および不正なセッションをSSVを推測し、したがって関連付けるため、攻撃者にとっては、難治ます"
    },
    {
      "indent": 3,
      "text": "o The arguments to and results of SET_SSV include digests of the old and new SSV, respectively.",
      "ja": "引数とSET_SSVの結果oをそれぞれ、古いものと新しいSSVのダイジェストが含まれています。"
    },
    {
      "indent": 3,
      "text": "o Because the initial value of the SSV is zero, therefore known, the client that opts for SP4_SSV protection and opts to apply SP4_SSV protection to BIND_CONN_TO_SESSION and CREATE_SESSION MUST send at least one SET_SSV operation before the first BIND_CONN_TO_SESSION operation or before the second CREATE_SESSION operation on a client ID. If it does not, the SSV mechanism will not generate tokens (Section 2.10.9). A client SHOULD send SET_SSV as soon as a session is created.",
      "ja": "SSVの初期値は、したがって、既知の、ゼロであるので、O、SP4_SSV保護のために付き合えとSP4_SSVのBIND_CONN_TO_SESSIONに保護及びCREATE_SESSIONを適用することを選択し、クライアントは、第BIND_CONN_TO_SESSION操作の前又は上に第二CREATE_SESSION操作の前に少なくとも一つのSET_SSV動作を送らなければなりませんクライアントID。そうでない場合は、SSVメカニズムは、トークン（セクション2.10.9）を生成しません。クライアントは、セッションが作成されると同時にSET_SSVを送るべきです。"
    },
    {
      "indent": 3,
      "text": "o A SET_SSV request does not replace the SSV with the argument to SET_SSV. Instead, the current SSV on the server is logically exclusive ORed (XORed) with the argument to SET_SSV. Each time a new principal uses a client ID for the first time, the client SHOULD send a SET_SSV with that principal's RPCSEC_GSS credentials, with RPCSEC_GSS service set to RPC_GSS_SVC_PRIVACY.",
      "ja": "O SET_SSV要求はSET_SSVへの引数とSSVに代わるものではありません。代わりに、サーバー上の現在のSSVはSET_SSVへの引数を持つ論理的に排他的論理和（XOR演算）です。新しいプリンシパルが初めてのクライアントIDを使用するたびに、クライアントがRPC_GSS_SVC_PRIVACYに設定RPCSEC_GSSサービスと、そのプリンシパルのRPCSEC_GSS資格を持つSET_SSVを送るべきです。"
    },
    {
      "indent": 3,
      "text": "Here are the types of attacks that can be attempted by an attacker named Eve on a victim named Bob, and how SP4_SSV protection foils each attack:",
      "ja": "ここではボブという名前の被害者にイブという名前の攻撃者によって試みることができる攻撃の種類があり、どのようにSP4_SSV保護は、それぞれの攻撃箔："
    },
    {
      "indent": 3,
      "text": "o Suppose Eve is the first user to log into a legitimate client. Eve's use of an NFSv4.1 file system will cause the legitimate client to create a client ID with SP4_SSV protection, specifying that the BIND_CONN_TO_SESSION operation MUST use the SSV credential. Eve's use of the file system also causes an SSV to be created. The SET_SSV operation that creates the SSV will be protected by the RPCSEC_GSS context created by the legitimate client, which uses Eve's GSS principal and credentials. Eve can eavesdrop on the network while her RPCSEC_GSS context is created and the SET_SSV using her context is sent. Even if the legitimate client sends the SET_SSV with RPC_GSS_SVC_PRIVACY, because Eve knows her own credentials, she can decrypt the SSV. Eve can compute an RPCSEC_GSS credential that BIND_CONN_TO_SESSION will accept, and so associate a new connection with the legitimate session. Eve can change the slot ID and sequence state of a legitimate session, and/or the SSV state, in such a way that when Bob accesses the server via the same legitimate client, the legitimate client will be unable to use the session.",
      "ja": "Oイブが正当なクライアントにログインする最初のユーザーであると仮定します。 NFSv4.1ファイルシステムのイブの使用はBIND_CONN_TO_SESSION操作はSSVの資格を使用しなければならないことを指定して、SP4_SSV保護機能を備えたクライアントIDを作成するために、正当なクライアントが発生します。ファイルシステムのイブの使用はまた、SSVが作成されます。 SSVを作成SET_SSV操作はイブのGSSプリンシパルと資格情報を使用して、正当なクライアントによって作成RPCSEC_GSSコンテキストによって保護されます。彼女のRPCSEC_GSSコンテキストが作成され、彼女のコンテキストを使用してSET_SSVが送られている間イブがネットワークを盗聴することができます。イブは彼女自身の資格情報を知っているので、正当なクライアントは、RPC_GSS_SVC_PRIVACYでSET_SSVを送信した場合でも、彼女はSSVを復号化することができます。イブはBIND_CONN_TO_SESSIONが受け入れるRPCSEC_GSS資格を計算し、その正当なセッションとの新しい接続を関連付けることができます。イブは、ボブが同じ正規クライアントを介してサーバにアクセスするとき、正規クライアントがセッションを使用することができないであろうように、スロットID及びシーケンス状態正規セッションの、及び/又はSSVの状態を変化させることができます。"
    },
    {
      "indent": 6,
      "text": "The client's only recourse is to create a new client ID for Bob to use, and establish a new SSV for the client ID. The client will be unable to delete the old client ID, and will let the lease on the old client ID expire.",
      "ja": "クライアントの唯一の頼みの綱は、ボブが使用する新しいクライアントIDを作成し、クライアントIDのための新しいSSVを確立することです。クライアントは、古いクライアントのIDを削除することができませんし、古いクライアントIDのリースの期限が切れるようになります。"
    },
    {
      "indent": 6,
      "text": "Once the legitimate client establishes an SSV over the new session using Bob's RPCSEC_GSS context, Eve can use the new session via the legitimate client, but she cannot disrupt Bob. Moreover, because the client SHOULD have modified the SSV due to Eve using the new session, Bob cannot get revenge on Eve by associating a rogue connection with the session.",
      "ja": "正当なクライアントは、ボブのRPCSEC_GSSコンテキストを使用して新しいセッションを介しSSVを確立すると、イブは、正当なクライアントを経由して、新しいセッションを使用することができますが、彼女はボブを妨害することはできません。クライアントは新しいセッションを使用して原因イブにSSVを変更したはずなのでまた、ボブは、セッションとの不正な接続を関連付けることによってイブに復讐を取得することはできません。"
    },
    {
      "indent": 6,
      "text": "The question is how did the legitimate client detect that Eve has hijacked the old session? When the client detects that a new principal, Bob, wants to use the session, it SHOULD have sent a SET_SSV, which leads to the following sub-scenarios:",
      "ja": "質問はどのように正当なクライアントはイブが古いセッションをハイジャックしていることを検出なかったのですか？クライアントが新しいプリンシパル、ボブは、セッションを使用したいことを検出すると、それは以下のサブシナリオにつながるSET_SSVを、送信されている必要があります。"
    },
    {
      "indent": 6,
      "text": "* Let us suppose that from the rogue connection, Eve sent a SET_SSV with the same slot ID and sequence ID that the legitimate client later uses. The server will assume the SET_SSV sent with Bob's credentials is a retry, and return to the legitimate client the reply it sent Eve. However, unless Eve can correctly guess the SSV the legitimate client will use, the digest verification checks in the SET_SSV response will fail. That is an indication to the client that the session has apparently been hijacked.",
      "ja": "*私たちは、不正な接続から、イブが正当なクライアントが、後に使用するのと同じスロットIDとシーケンスIDでSET_SSVを送ったと仮定しましょう。サーバーは、Bobの資格情報を使用して送信されSET_SSVが再試行であると仮定して、正当なクライアントには、イブに送られた応答を返します。しかし、イブが正しく正当なクライアントが使用するSSVを推測することができない限り、SET_SSV応答のダイジェスト検証チェックが失敗します。それは、セッションが明らかにハイジャックされたクライアントへの指示です。"
    },
    {
      "indent": 6,
      "text": "* Alternatively, Eve sent a SET_SSV with a different slot ID than the legitimate client uses for its SET_SSV. Then the digest verification of the SET_SSV sent with Bob's credentials fails on the server, and the error returned to the client makes it apparent that the session has been hijacked.",
      "ja": "*あるいは、イブは、正当なクライアントがSET_SSVに使用するよりも、異なるスロットIDとSET_SSVを送りました。そして、Bobの資格情報を使用して送信されSET_SSVのダイジェスト検証がサーバー上で失敗し、エラーがクライアントに返さすると、セッションがハイジャックされたこと、それが明らかになります。"
    },
    {
      "indent": 6,
      "text": "* Alternatively, Eve sent an operation other than SET_SSV, but with the same slot ID and sequence that the legitimate client uses for its SET_SSV. The server returns to the legitimate client the response it sent Eve. The client sees that the response is not at all what it expects. The client assumes either session hijacking or a server bug, and either way destroys the old session.",
      "ja": "*あるいは、イブはなく、正当なクライアントがSET_SSVに使用する同じスロットIDと配列と、SET_SSV以外の動作を送りました。サーバーは、正当なクライアントにはイブを送信し、応答を返します。クライアントは応答が全くそれが期待するものではないことを認識します。クライアントは、セッションハイジャックやサーバのバグのいずれかを想定しており、いずれかの方法は、古いセッションを破棄します。"
    },
    {
      "indent": 3,
      "text": "o Eve associates a rogue connection with the session as above, and then destroys the session. Again, Bob goes to use the server from the legitimate client, which sends a SET_SSV using Bob's credentials. The client receives an error that indicates that the session does not exist. When the client tries to create a new session, this will fail because the SSV it has does not match that which the server has, and now the client knows the session was hijacked. The legitimate client establishes a new client ID.",
      "ja": "Oイブは、上記のようにセッションに不正な接続を関連付け、そして、セッションを破棄します。ここでも、ボブは、ボブの資格情報を使用してSET_SSVを送信し、正当なクライアントからサーバーを使用するようになります。クライアントは、セッションが存在しないことを示すエラーを受け取ります。クライアントは新しいセッションを作成しようとすると、それが持っているSSVは、サーバが持っている、そして今、クライアントはセッションがハイジャックされた知っているものと一致しないため、これは失敗します。正当なクライアントは、新しいクライアントIDを確立します。"
    },
    {
      "indent": 3,
      "text": "o If Eve creates a connection before the legitimate client establishes an SSV, because the initial value of the SSV is zero and therefore known, Eve can send a SET_SSV that will pass the digest verification check. However, because the new connection has not been associated with the session, the SET_SSV is rejected for that reason.",
      "ja": "正当なクライアントがSSVを確立する前に、SSVの初期値はゼロであるため、知られているので、イブは、接続を作成する場合は、O、イブは、ダイジェスト検証チェックを通過しますSET_SSVを送ることができます。新しい接続がセッションに関連付けられていないので、しかし、SET_SSVはその理由で拒否されます。"
    },
    {
      "indent": 3,
      "text": "In summary, an attacker's disruption of state when SP4_SSV protection is in use is limited to the formative period of a client ID, its first session, and the establishment of the SSV. Once a non-malicious user uses the client ID, the client quickly detects any hijack and rectifies the situation. Once a non-malicious user successfully modifies the SSV, the attacker cannot use NFSv4.1 operations to disrupt the non-malicious user.",
      "ja": "要約すると、SP4_SSV保護が使用されている状態の攻撃者の破壊は、クライアントID、その最初のセッション、およびSSVの確立の形成期に制限されています。非悪意のあるユーザがクライアントIDを使用すると、クライアントはすぐに任意のハイジャックを検出し、状況を整流します。悪意のないユーザーが正常SSVを変更すると、攻撃者は、悪意のないユーザーを混乱させるためにNFSv4.1操作を使用することはできません。"
    },
    {
      "indent": 3,
      "text": "Note that neither the SP4_MACH_CRED nor SP4_SSV protection approaches prevent hijacking of a transport connection that has previously been associated with a session. If the goal of a counter-threat strategy is to prevent connection hijacking, the use of IPsec is RECOMMENDED.",
      "ja": "SP4_MACH_CREDもSP4_SSV保護アプローチでもないが、以前のセッションに関連付けられているトランスポート接続のハイジャックを防ぐことに注意してください。カウンターの脅威戦略の目標は、接続ハイジャックを防ぐためであれば、IPsecの使用を推奨します。"
    },
    {
      "indent": 3,
      "text": "If a connection hijack occurs, the hijacker could in theory change locking state and negatively impact the service to legitimate clients. However, if the server is configured to require the use of RPCSEC_GSS with integrity or privacy on the affected file objects, and if EXCHGID4_FLAG_BIND_PRINC_STATEID capability (Section 18.35) is in force, this will thwart unauthorized attempts to change locking state.",
      "ja": "接続ハイジャックが発生した場合、ハイジャック犯は、理論的には状態をロックに変更し、負正当なクライアントへのサービスに影響を与える可能性があります。ただし、場合、サーバーは、影響を受けるファイルオブジェクトの整合性やプライバシーをRPCSEC_GSSの使用を必要とするように構成されており、EXCHGID4_FLAG_BIND_PRINC_STATEID能力（セクション18.35）が力にある場合、これは状態をロック変更する権限のない試みを阻止します。"
    },
    {
      "indent": 0,
      "text": "2.10.9. The Secret State Verifier (SSV) GSS Mechanism",
      "section_title": true,
      "ja": "2.10.9. シークレット状態検証（SSV）GSSメカニズム"
    },
    {
      "indent": 3,
      "text": "The SSV provides the secret key for a GSS mechanism internal to NFSv4.1 that NFSv4.1 uses for state protection. Contexts for this mechanism are not established via the RPCSEC_GSS protocol. Instead, the contexts are automatically created when EXCHANGE_ID specifies SP4_SSV protection. The only tokens defined are the PerMsgToken (emitted by GSS_GetMIC) and the SealedMessage token (emitted by GSS_Wrap).",
      "ja": "SSVはNFSv4.1は、ステート保護のために使用していますNFSv4.1内部のGSSメカニズムのための秘密鍵を提供します。このメカニズムのためのコンテキストは、RPCSEC_GSSプロトコルを介して確立されていません。 EXCHANGE_IDがSP4_SSV保護を指定した場合に代わりに、コンテキストが自動的に作成されます。定義された唯一のトークンは（GSS_GetMICによって放出された）PerMsgToken及び（にGSS_Wrapによって放出された）SealedMessageトークンです。"
    },
    {
      "indent": 3,
      "text": "The mechanism OID for the SSV mechanism is iso.org.dod.internet.private.enterprise.Michael Eisler.nfs.ssv_mech (1.3.6.1.4.1.28882.1.1). While the SSV mechanism does not define any initial context tokens, the OID can be used to let servers indicate that the SSV mechanism is acceptable whenever the client sends a SECINFO or SECINFO_NO_NAME operation (see Section 2.6).",
      "ja": "SSVメカニズムの機構OIDはiso.org.dod.internet.private.enterprise.Michael Eisler.nfs.ssv_mech（1.3.6.1.4.1.28882.1.1）です。 SSVメカニズムは、任意の初期コンテキスト・トークンを定義していませんが、OIDサーバーは、クライアントがSECINFOまたはSECINFO_NO_NAME操作を（2.6節を参照）を送信するときSSVメカニズムが受け入れ可能であることを示すようにすることができます。"
    },
    {
      "indent": 3,
      "text": "The SSV mechanism defines four subkeys derived from the SSV value. Each time SET_SSV is invoked, the subkeys are recalculated by the client and server. The calculation of each of the four subkeys depends on each of the four respective ssv_subkey4 enumerated values. The calculation uses the HMAC [11] algorithm, using the current SSV as the key, the one-way hash algorithm as negotiated by EXCHANGE_ID, and the input text as represented by the XDR encoded enumeration value for that subkey of data type ssv_subkey4. If the length of the output of the HMAC algorithm exceeds the length of key of the encryption algorithm (which is also negotiated by EXCHANGE_ID), then the subkey MUST be truncated from the HMAC output, i.e., if the subkey is of N bytes long, then the first N bytes of the HMAC output MUST be used for the subkey. The specification of EXCHANGE_ID states that the length of the output of the HMAC algorithm MUST NOT be less than the length of subkey needed for the encryption algorithm (see Section 18.35).",
      "ja": "SSV機構は、SSV値に由来する4つのサブキーを定義します。 SET_SSVが呼び出されるたびに、サブキーは、クライアントとサーバによって再計算されます。 4つのサブキーのそれぞれの計算は、4つのそれぞれのssv_subkey4列挙された値のそれぞれに依存します。計算は、キー、EXCHANGE_IDによって交渉として一方向ハッシュアルゴリズム、及びデータ型ssv_subkey4のサブキーのXDR符号化された列挙値によって表されるように、入力テキストとして現在のSSVを使用して、HMAC [11]アルゴリズムを使用します。 HMACアルゴリズムの出力の長さは（もEXCHANGE_IDによってネゴシエートされる）暗号化アルゴリズムの鍵の長さを超える場合サブキーがNである場合、サブキー、すなわち、HMAC出力から切り捨てなければならないバイト長、次に、HMAC出力の最初のNバイトはサブキーに使用されなければなりません。 EXCHANGE_IDの仕様は、HMACアルゴリズムの出力の長さは暗号化アルゴリズムのために必要なサブキーの長さ未満であってはならないと述べている（セクション18.35を参照してください）。"
    },
    {
      "indent": 3,
      "text": "/* Input for computing subkeys */\nenum ssv_subkey4 {\n        SSV4_SUBKEY_MIC_I2T     = 1,\n        SSV4_SUBKEY_MIC_T2I     = 2,\n        SSV4_SUBKEY_SEAL_I2T    = 3,\n        SSV4_SUBKEY_SEAL_T2I    = 4\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The subkey derived from SSV4_SUBKEY_MIC_I2T is used for calculating message integrity codes (MICs) that originate from the NFSv4.1 client, whether as part of a request over the fore channel or a response over the backchannel. The subkey derived from SSV4_SUBKEY_MIC_T2I is used for MICs originating from the NFSv4.1 server. The subkey derived from SSV4_SUBKEY_SEAL_I2T is used for encryption text originating from the NFSv4.1 client, and the subkey derived from SSV4_SUBKEY_SEAL_T2I is used for encryption text originating from the NFSv4.1 server.",
      "ja": "SSV4_SUBKEY_MIC_I2T由来するサブキーは前方チャネルまたはバックチャネル上の応答を介して要求の一部としてかどうか、NFSv4.1クライアントから発信メッセージ完全性コード（MIC値）を計算するために使用されます。 SSV4_SUBKEY_MIC_T2I由来サブキーには、NFSv4.1サーバーから発信MICのために使用されています。 SSV4_SUBKEY_SEAL_I2T由来サブキーはNFSv4.1のクライアントから発信暗号化テキストに使用され、そしてSSV4_SUBKEY_SEAL_T2I由来サブキーはNFSv4.1サーバーから発信暗号化テキストに使用されます。"
    },
    {
      "indent": 3,
      "text": "The PerMsgToken description is based on an XDR definition:",
      "ja": "PerMsgTokenの説明は、XDR定義に基づいています。"
    },
    {
      "indent": 3,
      "text": "/* Input for computing smt_hmac */\nstruct ssv_mic_plain_tkn4 {\n  uint32_t        smpt_ssv_seq;\n  opaque          smpt_orig_plain<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* SSV GSS PerMsgToken token */\nstruct ssv_mic_tkn4 {\n  uint32_t        smt_ssv_seq;\n  opaque          smt_hmac<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The field smt_hmac is an HMAC calculated by using the subkey derived from SSV4_SUBKEY_MIC_I2T or SSV4_SUBKEY_MIC_T2I as the key, the one-way hash algorithm as negotiated by EXCHANGE_ID, and the input text as represented by data of type ssv_mic_plain_tkn4. The field smpt_ssv_seq is the same as smt_ssv_seq. The field smpt_orig_plain is the \"message\" input passed to GSS_GetMIC() (see Section 2.3.1 of [7]). The caller of GSS_GetMIC() provides a pointer to a buffer containing the plain text. The SSV mechanism's entry point for GSS_GetMIC() encodes this into an opaque array, and the encoding will include an initial four-byte length, plus any necessary padding. Prepended to this will be the XDR encoded value of smpt_ssv_seq, thus making up an XDR encoding of a value of data type ssv_mic_plain_tkn4, which in turn is the input into the HMAC.",
      "ja": "フィールドsmt_hmacはHMACがタイプssv_mic_plain_tkn4のデータによって表されるようなキー、EXCHANGE_IDによって交渉として一方向ハッシュアルゴリズム、および入力テキストとしてSSV4_SUBKEY_MIC_I2T又はSSV4_SUBKEY_MIC_T2I由来するサブキーを用いて算出されます。フィールドsmpt_ssv_seqはsmt_ssv_seqと同じです。フィールドsmpt_orig_plainはGSS_GetMICに渡される「メッセージ」入力（）（[7]のセクション2.3.1を参照します）。 GSS_GetMICの発信者は、（）プレーンテキストを含むバッファへのポインタを提供します。 GSS_GetMIC（）のためにSSV機構のエントリポイントは、不透明な配列にこれを符号化し、符号化は、最初の4バイト長、および任意の必要なパディングを含むであろう。このように順番にHMACに入力されるデータ型ssv_mic_plain_tkn4の値のXDRエンコーディングを構成する、smpt_ssv_seqのXDR符号化された値となり、これに付加。"
    },
    {
      "indent": 3,
      "text": "The token emitted by GSS_GetMIC() is XDR encoded and of XDR data type ssv_mic_tkn4. The field smt_ssv_seq comes from the SSV sequence number, which is equal to one after SET_SSV (Section 18.47) is called the first time on a client ID. Thereafter, the SSV sequence number is incremented on each SET_SSV. Thus, smt_ssv_seq represents the version of the SSV at the time GSS_GetMIC() was called. As noted in Section 18.35, the client and server can maintain multiple concurrent versions of the SSV. This allows the SSV to be changed without serializing all RPC calls that use the SSV mechanism with SET_SSV operations. Once the HMAC is calculated, it is XDR encoded into smt_hmac, which will include an initial four-byte length, and any necessary padding. Prepended to this will be the XDR encoded value of smt_ssv_seq.",
      "ja": "GSS_GetMIC（）によって放出されたトークンは、XDR符号化され、XDRデータ型ssv_mic_tkn4です。フィールドsmt_ssv_seqは、クライアントIDで初めて呼ばれSET_SSV（セクション18.47）後の1に等しいSSVシーケンス番号、から来ています。その後、SSVのシーケンス番号は各SET_SSVにインクリメントされます。したがって、smt_ssv_seqはGSS_GetMIC（）が呼び出された時点でSSVのバージョンを表します。セクション18.35で述べたように、クライアントとサーバは、SSVの複数の同時のバージョンを維持することができます。これは、SSVはSET_SSV操作でSSVメカニズムを使用するすべてのRPC呼び出しをシリアライズすることなく変更することができます。 HMACが計算されると、それは最初の4バイトの長さを含むことになるsmt_hmacにエンコードXDR、および任意の必要なパディングです。この前に付加することsmt_ssv_seqのXDRエンコードされた値になります。"
    },
    {
      "indent": 3,
      "text": "The SealedMessage description is based on an XDR definition:",
      "ja": "SealedMessageの説明は、XDR定義に基づいています。"
    },
    {
      "indent": 3,
      "text": "/* Input for computing ssct_encr_data and ssct_hmac */\nstruct ssv_seal_plain_tkn4 {\n  opaque          sspt_confounder<>;\n  uint32_t        sspt_ssv_seq;\n  opaque          sspt_orig_plain<>;\n  opaque          sspt_pad<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* SSV GSS SealedMessage token */\nstruct ssv_seal_cipher_tkn4 {\n  uint32_t      ssct_ssv_seq;\n  opaque        ssct_iv<>;\n  opaque        ssct_encr_data<>;\n  opaque        ssct_hmac<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The token emitted by GSS_Wrap() is XDR encoded and of XDR data type ssv_seal_cipher_tkn4.",
      "ja": "GSS_Wrap（）によって放出されたトークンは、XDR符号化され、XDRデータ型ssv_seal_cipher_tkn4です。"
    },
    {
      "indent": 3,
      "text": "The ssct_ssv_seq field has the same meaning as smt_ssv_seq.",
      "ja": "ssct_ssv_seqフィールドはsmt_ssv_seqと同じ意味を持っています。"
    },
    {
      "indent": 3,
      "text": "The ssct_encr_data field is the result of encrypting a value of the XDR encoded data type ssv_seal_plain_tkn4. The encryption key is the subkey derived from SSV4_SUBKEY_SEAL_I2T or SSV4_SUBKEY_SEAL_T2I, and the encryption algorithm is that negotiated by EXCHANGE_ID.",
      "ja": "ssct_encr_dataフィールドはXDR符号化データ型ssv_seal_plain_tkn4の値を暗号化した結果です。暗号化キーはSSV4_SUBKEY_SEAL_I2TまたはSSV4_SUBKEY_SEAL_T2I由来のサブキーで、暗号化アルゴリズムはEXCHANGE_IDによって交渉ということです。"
    },
    {
      "indent": 3,
      "text": "The ssct_iv field is the initialization vector (IV) for the encryption algorithm (if applicable) and is sent in clear text. The content and size of the IV MUST comply with the specification of the encryption algorithm. For example, the id-aes256-CBC algorithm MUST use a 16-byte initialization vector (IV), which MUST be unpredictable for each instance of a value of data type ssv_seal_plain_tkn4 that is encrypted with a particular SSV key.",
      "ja": "ssct_ivフィールドは、暗号化アルゴリズムのための初期化ベクトル（IV）である（該当する場合）と、クリアテキストで送信されます。 IVの内容及びサイズは、暗号化アルゴリズムの仕様に準拠しなければなりません。例えば、ID-AES256-CBCアルゴリズムは、特定のSSV鍵で暗号化されたデータ型ssv_seal_plain_tkn4の値の各インスタンスのために予測不可能でなければならない、16バイトの初期化ベクトル（IV）を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The ssct_hmac field is the result of computing an HMAC using the value of the XDR encoded data type ssv_seal_plain_tkn4 as the input text. The key is the subkey derived from SSV4_SUBKEY_MIC_I2T or SSV4_SUBKEY_MIC_T2I, and the one-way hash algorithm is that negotiated by EXCHANGE_ID.",
      "ja": "ssct_hmacフィールドは、入力されたテキストとしてXDR符号化データ型ssv_seal_plain_tkn4の値を使用してHMACを計算した結果です。キーはSSV4_SUBKEY_MIC_I2T又はSSV4_SUBKEY_MIC_T2I由来するサブキーであり、一方向ハッシュアルゴリズムはEXCHANGE_IDによって交渉することです。"
    },
    {
      "indent": 3,
      "text": "The sspt_confounder field is a random value.",
      "ja": "sspt_confounderフィールドには、ランダムな値です。"
    },
    {
      "indent": 3,
      "text": "The sspt_ssv_seq field is the same as ssvt_ssv_seq.",
      "ja": "sspt_ssv_seqフィールドはssvt_ssv_seqと同じです。"
    },
    {
      "indent": 3,
      "text": "The field sspt_orig_plain field is the original plaintext and is the \"input_message\" input passed to GSS_Wrap() (see Section 2.3.3 of [7]). As with the handling of the plaintext by the SSV mechanism's GSS_GetMIC() entry point, the entry point for GSS_Wrap() expects a pointer to the plaintext, and will XDR encode an opaque array into sspt_orig_plain representing the plain text, along with the other fields of an instance of data type ssv_seal_plain_tkn4.",
      "ja": "フィールドsspt_orig_plainフィールドは、元の平文とにGSS_Wrapに渡される「input_message」入力（）（[7]のセクション2.3.3を参照します）。 SSV機構のGSS_GetMIC（）エントリポイントによって平文の取り扱いと同様、にGSS_Wrap（）のエントリポイントは、平文へのポインタを期待し、そしてXDRは、他のフィールドと共に、sspt_orig_plainプレーンテキストを表すに不透明な配列をコードしますデータ型ssv_seal_plain_tkn4のインスタンスの。"
    },
    {
      "indent": 3,
      "text": "The sspt_pad field is present to support encryption algorithms that require inputs to be in fixed-sized blocks. The content of sspt_pad is zero filled except for the length. Beware that the XDR encoding of ssv_seal_plain_tkn4 contains three variable-length arrays, and so each array consumes four bytes for an array length, and each array that follows the length is always padded to a multiple of four bytes per the XDR standard.",
      "ja": "sspt_padフィールドは、固定サイズのブロックであることが入力を必要とする暗号化アルゴリズムをサポートするために存在しています。 sspt_padの含有量は、長さを除いて充填ゼロです。 ssv_seal_plain_tkn4のXDRエンコーディング三可変長配列を含み、その結果、各アレイは、配列の長さのために4つのバイトを消費し、長さを以下の各アレイは常にXDR標準当たり4バイトの倍数にパディングされることに注意してください。"
    },
    {
      "indent": 3,
      "text": "For example, suppose the encryption algorithm uses 16-byte blocks, and the sspt_confounder is three bytes long, and the sspt_orig_plain field is 15 bytes long. The XDR encoding of sspt_confounder uses eight bytes (4 + 3 + 1 byte pad), the XDR encoding of sspt_ssv_seq uses four bytes, the XDR encoding of sspt_orig_plain uses 20 bytes (4 + 15 + 1 byte pad), and the smallest XDR encoding of the sspt_pad field is four bytes. This totals 36 bytes. The next multiple of 16 is 48; thus, the length field of sspt_pad needs to be set to 12 bytes, or a total encoding of 16 bytes. The total number of XDR encoded bytes is thus 8 + 4 + 20 + 16 = 48.",
      "ja": "例えば、暗号化アルゴリズムは、16バイトのブロックを使用し、sspt_confounderは3バイトの長さで、sspt_orig_plainフィールドは15バイト長であると仮定します。 sspt_confounderのXDRエンコーディングは8バイト（4 + 3 + 1バイトパッド）を使用し、sspt_ssv_seqのXDR符号化は、4つのバイトを使用sspt_orig_plainのXDRエンコーディングは、20バイト（4 + 15 + 1バイトパッド）を使用し、及び最小のXDRエンコーディングsspt_padフィールドの4バイトです。これは、36のバイトを合計します。 16の倍数は48です。従って、sspt_padの長さフィールドは12バイト、又は16バイトの合計エンコーディングに設定する必要があります。 XDRエンコードされたバイトの総数は、このように8 + 4 + 20 + 16 = 48です。"
    },
    {
      "indent": 3,
      "text": "GSS_Wrap() emits a token that is an XDR encoding of a value of data type ssv_seal_cipher_tkn4. Note that regardless of whether or not the caller of GSS_Wrap() requests confidentiality, the token always has confidentiality. This is because the SSV mechanism is for RPCSEC_GSS, and RPCSEC_GSS never produces GSS_wrap() tokens without confidentiality.",
      "ja": "GSS_Wrap（）データ型ssv_seal_cipher_tkn4の値のXDRエンコードされたトークンを発します。かかわらずにGSS_Wrap（のかどうか、発信者のこと）機密性を要求し、トークンは常に機密性を持っていることに注意してください。 SSVメカニズムはRPCSEC_GSSのためであり、RPCSEC_GSSは、機密性なしにGSS_Wrap（）トークンを生成したことがないからです。"
    },
    {
      "indent": 3,
      "text": "There is one SSV per client ID. There is a single GSS context for a client ID / SSV pair. All SSV mechanism RPCSEC_GSS handles of a client ID / SSV pair share the same GSS context. SSV GSS contexts do not expire except when the SSV is destroyed (causes would include the client ID being destroyed or a server restart). Since one purpose of context expiration is to replace keys that have been in use for \"too long\", hence vulnerable to compromise by brute force or accident, the client can replace the SSV key by sending periodic SET_SSV operations, which is done by cycling through different users' RPCSEC_GSS credentials. This way, the SSV is replaced without destroying the SSV's GSS contexts.",
      "ja": "クライアントIDごとに1つのSSVがあります。クライアントID / SSVのペアのための単一のGSSコンテキストがあります。クライアントID / SSVのペアのすべてのSSV機構RPCSEC_GSSハンドルは、同じGSSコンテキストを共有します。 SSVが破壊されたときに（原因が破壊されているクライアントIDまたはサーバの再起動が含まれます）を除き、SSV GSSコンテキストは有効期限はありません。コンテキストの有効期限の1つの目的は、ブルートフォースや事故で妥協するので、傷つきやすい、「長すぎる」ために使用されている鍵を交換することですので、クライアントはを循環することによって行われ、定期的SET_SSV操作を送信することにより、SSVキーを置き換えることができます別のユーザーのRPCSEC_GSS資格。この方法では、SSVはSSVのGSSコンテキストを破壊することなく交換されます。"
    },
    {
      "indent": 3,
      "text": "SSV RPCSEC_GSS handles can be expired or deleted by the server at any time, and the EXCHANGE_ID operation can be used to create more SSV RPCSEC_GSS handles. Expiration of SSV RPCSEC_GSS handles does not imply that the SSV or its GSS context has expired.",
      "ja": "SSV RPCSEC_GSSハンドルは有効期限が切れたか、サーバーによって削除された任意の時点で、かつEXCHANGE_ID操作がよりSSVのRPCSEC_GSSハンドルを作成するために使用することができますすることができます。 SSVのRPCSEC_GSSハンドルの有効期限は、SSVまたはそのGSSコンテキストの有効期限が切れていることを意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "The client MUST establish an SSV via SET_SSV before the SSV GSS context can be used to emit tokens from GSS_Wrap() and GSS_GetMIC(). If SET_SSV has not been successfully called, attempts to emit tokens MUST fail.",
      "ja": "SSV GSSコンテキスト前SET_SSV介しSSVを確立しなければならないクライアントにGSS_Wrap（）とGSS_GetMICからトークンを放出するために使用することができます（）。 SET_SSVが正常に呼び出されていない場合は、トークンを放出しようとする試みは失敗しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The SSV mechanism does not support replay detection and sequencing in its tokens because RPCSEC_GSS does not use those features (See Section 5.2.2, \"Context Creation Requests\", in [4]). However, Section 2.10.10 discusses special considerations for the SSV mechanism when used with RPCSEC_GSS.",
      "ja": "RPCSEC_GSSは、これらの機能を使用しないためSSVメカニズムは、そのトークンでリプレイ検出や順序付けをサポートしていません（[4]には、5.2.2項、「コンテキスト作成要求」を参照してください）。 RPCSEC_GSSで使用する場合ただし、セクション2.10.10は、SSVのメカニズムのための特別な考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "2.10.10. Security Considerations for RPCSEC_GSS When Using the SSV Mechanism",
      "ja": "2.10.10.  RPCSEC_GSSのためのセキュリティの考慮事項SSVメカニズムを使用して"
    },
    {
      "indent": 3,
      "text": "When a client ID is created with SP4_SSV state protection (see Section 18.35), the client is permitted to associate multiple RPCSEC_GSS handles with the single SSV GSS context (see Section 2.10.9). Because of the way RPCSEC_GSS (both version 1 and version 2, see [4] and [12]) calculate the verifier of the reply, special care must be taken by the implementation of the NFSv4.1 client to prevent attacks by a man-in-the-middle. The verifier of an RPCSEC_GSS reply is the output of GSS_GetMIC() applied to the input value of the seq_num field of the RPCSEC_GSS credential (data type rpc_gss_cred_ver_1_t) (see Section 5.3.3.2 of [4]). If multiple RPCSEC_GSS handles share the same GSS context, then if one handle is used to send a request with the same seq_num value as another handle, an attacker could block the reply, and replace it with the verifier used for the other handle.",
      "ja": "クライアントIDがSP4_SSV状態の保護（項18.35を参照）で作成された場合、クライアントは、複数のRPCSEC_GSSは、単一のSSV GSSコンテキスト（セクション2.10.9を参照）でハンドルを関連付けることが許可されています。ウェイRPCSEC_GSSの応答の検証を計算し、特別な注意がマンによる攻撃を防ぐために、NFSv4.1クライアントの実装によって取らなければならない（両方のバージョン1とバージョン2は、[4]、[12]参照）ので途中で。 RPCSEC_GSS応答の検証はGSS_GetMIC（の出力）（[4]のセクション5.3.3.2を参照）RPCSEC_GSS資格（データ型rpc_gss_cred_ver_1_t）のSEQ_NUMフィールドの入力値に適用されます。複数RPCSEC_GSSハンドルは、同じGSSコンテキストを共有する場合は、1つのハンドルが別のハンドルと同じSEQ_NUM値と要求を送信するために使用される場合、その後、攻撃者が応答をブロックし、他のハンドルに使用される検証とそれを置き換えることができます。"
    },
    {
      "indent": 3,
      "text": "There are multiple ways to prevent the attack on the SSV RPCSEC_GSS verifier in the reply. The simplest is believed to be as follows.",
      "ja": "返信にSSV RPCSEC_GSS検証への攻撃を防ぐために、複数の方法があります。最も単純には以下のように考えています。"
    },
    {
      "indent": 3,
      "text": "o Each time one or more new SSV RPCSEC_GSS handles are created via EXCHANGE_ID, the client SHOULD send a SET_SSV operation to modify the SSV. By changing the SSV, the new handles will not result in the re-use of an SSV RPCSEC_GSS verifier in a reply.",
      "ja": "1つ以上の新しいSSVのRPCSEC_GSSハンドルがEXCHANGE_IDを介して作成されるたびに、O、クライアントはSSVを変更するSET_SSV操作を送るべきです。 SSVを変更することにより、新しいハンドルが返信にSSV RPCSEC_GSS検証の再利用にはなりません。"
    },
    {
      "indent": 3,
      "text": "o When a requester decides to use N SSV RPCSEC_GSS handles, it SHOULD assign a unique and non-overlapping range of seq_nums to each SSV RPCSEC_GSS handle. The size of each range SHOULD be equal to MAXSEQ / N (see Section 5 of [4] for the definition of MAXSEQ). When an SSV RPCSEC_GSS handle reaches its maximum, it SHOULD force the replier to destroy the handle by sending a NULL RPC request with seq_num set to MAXSEQ + 1 (see Section 5.3.3.3 of [4]).",
      "ja": "リクエスタがN SSV RPCSEC_GSSハンドルを使用することを決定する場合、O、それは各SSV RPCSEC_GSSハンドルへseq_numsのユニークかつ非重複範囲を割り当てる必要があります。各範囲の大きさは、（MAXSEQの定義については、[4]のセクション5を参照）MAXSEQ / Nに等しくなければなりません。 SSV RPCSEC_GSSハンドルがその最大値に到達すると、それはMAXSEQ + 1に設定SEQ_NUMとNULLのRPC要求を送信することによって、ハンドルを破壊するために回答者を強制的（[4]のセクション5.3.3.3を参照）。"
    },
    {
      "indent": 3,
      "text": "o When the requester wants to increase or decrease N, it SHOULD force the replier to destroy all N handles by sending a NULL RPC request on each handle with seq_num set to MAXSEQ + 1. If the requester is the client, it SHOULD send a SET_SSV operation before using new handles. If the requester is the server, then the client SHOULD send a SET_SSV operation when it detects that the server has forced it to destroy a backchannel's SSV RPCSEC_GSS handle. By sending a SET_SSV operation, the SSV will change, and so the attacker will be unavailable to successfully replay a previous verifier in a reply to the requester.",
      "ja": "依頼者は、Nを増減したいときは、O、それはすべてのNを破壊するリプライヤを強制すべきである要求者がクライアントである場合は、各MAXSEQ + 1に設定SEQ_NUMで扱う上でのNULL RPCリクエストを送信することにより処理し、それはSET_SSVを送るべきです新しいハンドルを使用する前に操作。依頼者がサーバである場合、それは、サーバーがバックチャネルのSSV RPCSEC_GSSハンドルを破壊することを余儀なくされたことを検出した場合、クライアントはSET_SSV操作を送るべきです。 SET_SSV操作を送信することにより、SSVは変化し、その攻撃者は依頼者への返信で、前の検証を再生するために使用できなくなります。"
    },
    {
      "indent": 3,
      "text": "Note that if the replier carefully creates the SSV RPCSEC_GSS handles, the related risk of a man-in-the-middle splicing a forged SSV RPCSEC_GSS credential with a verifier for another handle does not exist. This is because the verifier in an RPCSEC_GSS request is computed from input that includes both the RPCSEC_GSS handle and seq_num (see Section 5.3.1 of [4]). Provided the replier takes care to avoid re-using the value of an RPCSEC_GSS handle that it creates, such as by including a generation number in the handle, the man-in-the-middle will not be able to successfully replay a previous verifier in the request to a replier.",
      "ja": "リプライヤは慎重SSVのRPCSEC_GSSハンドルを作成した場合、別のハンドルのための検証とのman-in-the-middleスプライシング偽造SSV RPCSEC_GSS資格の関連リスクが存在しないことに注意してください。これはRPCSEC_GSS要求はRPCSEC_GSSハンドルとSEQ_NUM（[4]のセクション5.3.1を参照）の両方を含む入力から計算さであるため、検証者です。回答者は、RPCSEC_GSSの値は、それがそのようなハンドル内の世代番号を含むことなどによって、作成、のman-in-the-middleが正常に前検証を再生することはできないことを扱う再使用を避けるために世話を提供リプライヤに要求。"
    },
    {
      "indent": 0,
      "text": "2.10.11. Session Mechanics - Steady State",
      "section_title": true,
      "ja": "2.10.11. セッション力学 - 定常状態"
    },
    {
      "indent": 0,
      "text": "2.10.11.1. Obligations of the Server",
      "section_title": true,
      "ja": "2.10.11.1。サーバーの義務"
    },
    {
      "indent": 3,
      "text": "The server has the primary obligation to monitor the state of backchannel resources that the client has created for the server (RPCSEC_GSS contexts and backchannel connections). If these resources vanish, the server takes action as specified in Section 2.10.13.2.",
      "ja": "サーバーは、クライアントがサーバー（RPCSEC_GSSコンテキストとバックチャネル接続）のために作成したバックチャネルリソースの状態を監視するための主要な義務を負っています。これらのリソースが消えた場合は、セクション2.10.13.2に指定されているように、サーバは、アクションを実行します。"
    },
    {
      "indent": 0,
      "text": "2.10.11.2. Obligations of the Client",
      "section_title": true,
      "ja": "2.10.11.2。クライアントの義務"
    },
    {
      "indent": 3,
      "text": "The client SHOULD honor the following obligations in order to utilize the session:",
      "ja": "クライアントは、セッションを利用するために、次の義務を尊重すべきです："
    },
    {
      "indent": 3,
      "text": "o Keep a necessary session from going idle on the server. A client that requires a session but nonetheless is not sending operations risks having the session be destroyed by the server. This is because sessions consume resources, and resource limitations may force the server to cull an inactive session. A server MAY consider a session to be inactive if the client has not used the session before the session inactivity timer (Section 2.10.12) has expired.",
      "ja": "Oサーバー上のアイドル行くから必要なセッションをしてください。それにもかかわらず、セッションが必要ですが、クライアントはセッションがサーバーによって破壊されたオペレーションリスクを送信していません。セッションがリソースを消費し、リソースの制限が非アクティブなセッションを処分するためにサーバを強制する可能性があるからです。サーバーは、セッション非アクティブタイマー（セクション2.10.12）が満了する前に、クライアントがセッションを使用していない場合、セッションがアクティブであることを検討してください。"
    },
    {
      "indent": 3,
      "text": "o Destroy the session when not needed. If a client has multiple sessions, one of which has no requests waiting for replies, and has been idle for some period of time, it SHOULD destroy the session.",
      "ja": "必要のないときOセッションを破壊します。クライアントが複数のセッションを持っている場合は、の一つは、それがセッションを破棄する必要があり、回答を待って何の要求を持っていない、と、しばらくアイドル状態になっています。"
    },
    {
      "indent": 3,
      "text": "o Maintain GSS contexts and RPCSEC_GSS handles for the backchannel. If the client requires the server to use the RPCSEC_GSS security flavor for callbacks, then it needs to be sure the RPCSEC_GSS handles and/or their GSS contexts that are handed to the server via BACKCHANNEL_CTL or CREATE_SESSION are unexpired.",
      "ja": "Oバックチャネル用のGSSコンテキストとRPCSEC_GSSハンドルを維持します。クライアントは、コールバックのRPCSEC_GSSセキュリティ風味を使用するようにサーバーを必要とする場合、それはBACKCHANNEL_CTLまたはCREATE_SESSIONを介してサーバに渡されRPCSEC_GSSハンドルおよび/またはそのGSSコンテキスト期限が切れていないであることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Preserve a connection for a backchannel. The server requires a backchannel in order to gracefully recall recallable state or notify the client of certain events. Note that if the connection is not being used for the fore channel, there is no way for the client to tell if the connection is still alive (e.g., the server restarted without sending a disconnect). The onus is on the server, not the client, to determine if the backchannel's connection is alive, and to indicate in the response to a SEQUENCE operation when the last connection associated with a session's backchannel has disconnected.",
      "ja": "Oバックチャネルの接続を保持します。サーバーは正常リコール状態を呼び出すか、特定のイベントのクライアントに通知するために、バックチャネルが必要です。接続は前部チャネルのために使用されていない場合は、接続がまだ生きている場合、クライアントは言うする方法がないことに注意してください（例えば、切断を送信せずに再起動サーバー）。責任はバックチャネルの接続が生きているかどうかを判断するために、セッションのバックチャネルに関連付けられた最後の接続が切断したときにシーケンス動作に対応して示すために、サーバー、クライアントではなく上にあります。"
    },
    {
      "indent": 0,
      "text": "2.10.11.3. Steps the Client Takes to Establish a Session",
      "section_title": true,
      "ja": "2.10.11.3。クライアントがセッションを確立するのにかかる手順"
    },
    {
      "indent": 3,
      "text": "If the client does not have a client ID, the client sends EXCHANGE_ID to establish a client ID. If it opts for SP4_MACH_CRED or SP4_SSV protection, in the spo_must_enforce list of operations, it SHOULD at minimum specify CREATE_SESSION, DESTROY_SESSION, BIND_CONN_TO_SESSION, BACKCHANNEL_CTL, and DESTROY_CLIENTID. If it opts for SP4_SSV protection, the client needs to ask for SSV-based RPCSEC_GSS handles.",
      "ja": "クライアントは、クライアントのIDを持っていない場合、クライアントは、クライアントのIDを確立するためEXCHANGE_IDを送信します。それはSP4_MACH_CREDまたはSP4_SSV保護のために選択した場合、操作のspo_must_enforceリストには、最低でもCREATE_SESSION、DESTROY_SESSION、BIND_CONN_TO_SESSION、BACKCHANNEL_CTL、およびDESTROY_CLIENTIDを指定する必要があります。それはSP4_SSVの保護のために選択した場合、クライアントは、SSVベースRPCSEC_GSSハンドルを依頼する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client uses the client ID to send a CREATE_SESSION on a connection to the server. The results of CREATE_SESSION indicate whether or not the server will persist the session reply cache through a server that has restarted, and the client notes this for future reference.",
      "ja": "クライアントは、サーバーへの接続にCREATE_SESSIONを送信するために、クライアントのIDを使用しています。 CREATE_SESSIONの結果は、サーバーが再起動したサーバを介してセッション応答キャッシュを保持するかどうかを示し、クライアントは今後の参考のためにこれを指摘しています。"
    },
    {
      "indent": 3,
      "text": "If the client specified SP4_SSV state protection when the client ID was created, then it SHOULD send SET_SSV in the first COMPOUND after the session is created. Each time a new principal goes to use the client ID, it SHOULD send a SET_SSV again.",
      "ja": "クライアントIDが作成されたとき、クライアントはSP4_SSV状態の保護を指定した場合、セッションが作成された後、それが第一の化合物でSET_SSVを送るべきです。新しいプリンシパルは、クライアントIDを使用するために行くたびに、それが再びSET_SSVを送るべきです。"
    },
    {
      "indent": 3,
      "text": "If the client wants to use delegations, layouts, directory notifications, or any other state that requires a backchannel, then it needs to add a connection to the backchannel if CREATE_SESSION did not already do so. The client creates a connection, and calls BIND_CONN_TO_SESSION to associate the connection with the session and the session's backchannel. If CREATE_SESSION did not already do so, the client MUST tell the server what security is required in order for the client to accept callbacks. The client does this via BACKCHANNEL_CTL. If the client selected SP4_MACH_CRED or SP4_SSV protection when it called EXCHANGE_ID, then the client SHOULD specify that the backchannel use RPCSEC_GSS contexts for security.",
      "ja": "クライアントは、代表団、レイアウト、ディレクトリの通知、またはバックチャネルを必要とする他の状態を使用したい場合は、それはCREATE_SESSIONが既にそうしなかった場合、バックチャネルに接続を追加する必要があります。クライアントは接続を作成し、セッションとセッションのバックチャネルとの接続を関連付けるためにBIND_CONN_TO_SESSIONを呼び出します。 CREATE_SESSIONが既にそうしなかった場合、クライアントはコールバックを受け入れるようにクライアントのために必要なもの、セキュリティサーバーを伝える必要があります。クライアントはBACKCHANNEL_CTLを経由してこれを行います。それはEXCHANGE_IDを呼び出したときに、クライアントがSP4_MACH_CREDまたはSP4_SSV保護を選択した場合、クライアントは、セキュリティのためのバックチャネル使用RPCSEC_GSSコンテキストことを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client wants to use additional connections for the backchannel, then it needs to call BIND_CONN_TO_SESSION on each connection it wants to use with the session. If the client wants to use additional connections for the fore channel, then it needs to call BIND_CONN_TO_SESSION if it specified SP4_SSV or SP4_MACH_CRED state protection when the client ID was created.",
      "ja": "クライアントはバックチャネルのための追加の接続を使用したい場合は、それはそれは、セッションで使用したい各接続にBIND_CONN_TO_SESSIONを呼び出す必要があります。クライアントは、前部チャネルのための追加の接続を使用したい場合、それは、クライアントのIDが作成されたとき、それはSP4_SSVまたはSP4_MACH_CRED状態の保護を指定した場合BIND_CONN_TO_SESSIONを呼び出す必要があります。"
    },
    {
      "indent": 3,
      "text": "At this point, the session has reached steady state.",
      "ja": "この時点で、セッションが定常状態に達しています。"
    },
    {
      "indent": 0,
      "text": "2.10.12. Session Inactivity Timer",
      "section_title": true,
      "ja": "2.10.12. セッションの非アクティブタイマー"
    },
    {
      "indent": 3,
      "text": "The server MAY maintain a session inactivity timer for each session. If the session inactivity timer expires, then the server MAY destroy the session. To avoid losing a session due to inactivity, the client MUST renew the session inactivity timer. The length of session inactivity timer MUST NOT be less than the lease_time attribute (Section 5.8.1.11). As with lease renewal (Section 8.3), when the server receives a SEQUENCE operation, it resets the session inactivity timer, and MUST NOT allow the timer to expire while the rest of the operations in the COMPOUND procedure's request are still executing. Once the last operation has finished, the server MUST set the session inactivity timer to expire no sooner than the sum of the current time and the value of the lease_time attribute.",
      "ja": "サーバは、各セッションのセッション非アクティブタイマーを維持することができます。セッションの非アクティブタイマーが満了した場合、サーバーは、セッションを破壊する可能性があります。不活動によるセッションが失われないようにするには、クライアントは、セッションの非アクティブタイマーを更新しなければなりません。セッションの非アクティブタイマーの長さはlease_time属性（セクション5.8.1.11）以上でなければなりません。リースの更新（セクション8.3）と同様に、サーバはSEQUENCEの操作を受信したとき、それは、セッション非アクティブタイマーをリセットし、COMPOUND手順の要求での操作の残りはまだ実行されている間、タイマーが期限切れに許してはなりません。最後の操作が完了すると、サーバーには早く、現在の時間の合計とlease_time属性の値よりも期限切れにセッション非アクティブタイマーを設定してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.10.13. Session Mechanics - Recovery",
      "section_title": true,
      "ja": "2.10.13. セッション力学 - 回復"
    },
    {
      "indent": 0,
      "text": "2.10.13.1. Events Requiring Client Action",
      "section_title": true,
      "ja": "2.10.13.1。クライアントのアクションが必要なイベント"
    },
    {
      "indent": 3,
      "text": "The following events require client action to recover.",
      "ja": "次のイベントが回復し、クライアントのアクションを必要とします。"
    },
    {
      "indent": 0,
      "text": "2.10.13.1.1. RPCSEC_GSS Context Loss by Callback Path",
      "section_title": true,
      "ja": "2.10.13.1.1。コールバックパスでRPCSEC_GSSコンテキスト損失"
    },
    {
      "indent": 3,
      "text": "If all RPCSEC_GSS handles granted by the client to the server for callback use have expired, the client MUST establish a new handle via BACKCHANNEL_CTL. The sr_status_flags field of the SEQUENCE results indicates when callback handles are nearly expired, or fully expired (see Section 18.46.3).",
      "ja": "コールバックの使用のためにクライアントからサーバーに付与されたすべてのRPCSEC_GSSハンドルの有効期限が切れている場合、クライアントはBACKCHANNEL_CTLを経由して新しいハンドルを確立する必要があります。コールバックのハンドルが（セクション18.46.3を参照）はほぼ有効期限が切れ、または完全に有効期限が切れているときSEQUENCE結果のsr_status_flagsフィールドを示します。"
    },
    {
      "indent": 0,
      "text": "2.10.13.1.2. Connection Loss",
      "section_title": true,
      "ja": "2.10.13.1.2。接続損失"
    },
    {
      "indent": 3,
      "text": "If the client loses the last connection of the session and wants to retain the session, then it needs to create a new connection, and if, when the client ID was created, BIND_CONN_TO_SESSION was specified in the spo_must_enforce list, the client MUST use BIND_CONN_TO_SESSION to associate the connection with the session.",
      "ja": "クライアントがセッションの最後の接続を失い、セッションを保持したい場合、それは新しい接続を作成する必要があり、クライアントのIDを作成したときに、BIND_CONN_TO_SESSIONがspo_must_enforceリストに指定された場合など、クライアントがにBIND_CONN_TO_SESSIONを使用しなければなりませんセッションとの接続を関連付けます。"
    },
    {
      "indent": 3,
      "text": "If there was a request outstanding at the time of connection loss, then if the client wants to continue to use the session, it MUST retry the request, as described in Section 2.10.6.2. Note that it is not necessary to retry requests over a connection with the same source network address or the same destination network address as the lost connection. As long as the session ID, slot ID, and sequence ID in the retry match that of the original request, the server will recognize the request as a retry if it executed the request prior to disconnect.",
      "ja": "接続損失の時点で未処理の要求があった場合、クライアントはセッションを使用し続けたい場合は、セクション2.10.6.2に説明するように、そして、それは、要求を再試行しなければなりません。同じソースネットワークアドレスまたは失われた接続と同じ宛先ネットワークアドレスとの接続を介して要求を再試行する必要はないことに注意してください。それは切断する前に、要求を実行した場合に限り、再試行マッチのセッションID、スロットID、及び配列IDとして、元の要求と、サーバは、再試行としての要求を理解するであろう。"
    },
    {
      "indent": 3,
      "text": "If the connection that was lost was the last one associated with the backchannel, and the client wants to retain the backchannel and/or prevent revocation of recallable state, the client needs to reconnect, and if it does, it MUST associate the connection to the session and backchannel via BIND_CONN_TO_SESSION. The server SHOULD indicate when it has no callback connection via the sr_status_flags result from SEQUENCE.",
      "ja": "失われた接続がバックチャネルに関連付けられている最後の一人だった、とクライアントがバックチャネルを保持および/またはリコール状態の失効を防ぐために望んでいる場合は、クライアントが再接続する必要があり、それがない場合、それはへの接続を関連付ける必要がありますBIND_CONN_TO_SESSION経由のセッションおよびバックチャネル。それはSEQUENCEからsr_status_flags結果を経由してコールバック接続を持っていないときに、サーバーが示す必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10.13.1.3. Backchannel GSS Context Loss",
      "section_title": true,
      "ja": "2.10.13.1.3。バックチャネルGSSコンテキスト損失"
    },
    {
      "indent": 3,
      "text": "Via the sr_status_flags result of the SEQUENCE operation or other means, the client will learn if some or all of the RPCSEC_GSS contexts it assigned to the backchannel have been lost. If the client wants to retain the backchannel and/or not put recallable state subject to revocation, the client needs to use BACKCHANNEL_CTL to assign new contexts.",
      "ja": "それがバックチャネルに割り当てられたRPCSEC_GSSコンテキストの一部またはすべてが失われた場合のシーケンス動作または他の手段のsr_status_flags結果を経由して、クライアントが学びます。クライアントがバックチャネルを保持および/または失効にリコール状態の件名を入れていないしたい場合、クライアントは新しいコンテキストを割り当てるためにBACKCHANNEL_CTLを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10.13.1.4. Loss of Session",
      "section_title": true,
      "ja": "2.10.13.1.4。セッションの喪失"
    },
    {
      "indent": 3,
      "text": "The replier might lose a record of the session. Causes include:",
      "ja": "リプライヤは、セッションの記録が失われる可能性があります。原因は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Replier failure and restart.",
      "ja": "Oリプライヤ障害や再起動。"
    },
    {
      "indent": 3,
      "text": "o A catastrophe that causes the reply cache to be corrupted or lost on the media on which it was stored. This applies even if the replier indicated in the CREATE_SESSION results that it would persist the cache.",
      "ja": "O応答キャッシュの原因となる大惨事が破損しているか、それが保存されたメディアに失われます。これはCREATE_SESSIONに示さリプライヤは、それがキャッシュを保持することをもたらした場合でも適用されます。"
    },
    {
      "indent": 3,
      "text": "o The server purges the session of a client that has been inactive for a very extended period of time.",
      "ja": "Oサーバーは、時間の非常に長い期間のために非アクティブにされているクライアントのセッションを消去します。"
    },
    {
      "indent": 3,
      "text": "o As a result of configuration changes among a set of clustered servers, a network address previously connected to one server becomes connected to a different server that has no knowledge of the session in question. Such a configuration change will generally only happen when the original server ceases to function for a time.",
      "ja": "Oクラスタ化されたサーバのセットの中の設定変更の結果として、ネットワークアドレスは、以前に問題のセッションの知識を持たない別のサーバーに接続された1台のサーバーになりますに接続されています。元のサーバーが時間のために機能しなくなったときにこのような構成の変更は、一般的にのみ発生します。"
    },
    {
      "indent": 3,
      "text": "Loss of reply cache is equivalent to loss of session. The replier indicates loss of session to the requester by returning NFS4ERR_BADSESSION on the next operation that uses the session ID that refers to the lost session.",
      "ja": "回答キャッシュの損失は、セッションの損失に相当します。回答者は、失われたセッションを指すセッションIDを使用して次の動作にNFS4ERR_BADSESSIONを返すことによって、要求者にセッションの損失を示しています。"
    },
    {
      "indent": 3,
      "text": "After an event like a server restart, the client may have lost its connections. The client assumes for the moment that the session has not been lost. It reconnects, and if it specified connection association enforcement when the session was created, it invokes BIND_CONN_TO_SESSION using the session ID. Otherwise, it invokes SEQUENCE. If BIND_CONN_TO_SESSION or SEQUENCE returns NFS4ERR_BADSESSION, the client knows the session is not available to it when communicating with that network address. If the connection survives session loss, then the next SEQUENCE operation the client sends over the connection will get back NFS4ERR_BADSESSION. The client again knows the session was lost.",
      "ja": "サーバの再起動などのイベントの後、クライアントはその接続を失っている可能性があります。クライアントは、セッションが失われていない瞬間を前提としています。これは、再接続、およびセッションが作成されたとき、それは、接続関連の施行を指定した場合、それは、セッションIDを使用してBIND_CONN_TO_SESSIONを起動します。それ以外の場合は、SEQUENCEを呼び出します。 BIND_CONN_TO_SESSIONまたはSEQUENCEはNFS4ERR_BADSESSIONを返した場合、クライアントはそのネットワークアドレスと通信するときにセッションが使用できません知っています。接続はセッションの損失を存続した場合、クライアントは接続を介して送信し、次のシーケンス動作はNFS4ERR_BADSESSIONを取り戻すだろう。クライアントは、再びセッションが失われました知っています。"
    },
    {
      "indent": 3,
      "text": "Here is one suggested algorithm for the client when it gets NFS4ERR_BADSESSION. It is not obligatory in that, if a client does not want to take advantage of such features as trunking, it may omit parts of it. However, it is a useful example that draws attention to various possible recovery issues:",
      "ja": "ここでは、それはNFS4ERR_BADSESSIONを取得し、クライアントのための1つの提案のアルゴリズムです。これは、クライアントがトランキングなどの機能を利用したくない場合は、それはそれの一部を省略することがあり、その中に必須ではありません。しかし、それは様々な可能性の回復の問題に注意を引く有用な例であります："
    },
    {
      "indent": 3,
      "text": "1. If the client has other connections to other server network addresses associated with the same session, attempt a COMPOUND with a single operation, SEQUENCE, on each of the other connections.",
      "ja": "1.クライアントが同じセッションに関連付けられている他のサーバのネットワーク・アドレスへの他の接続を持っている場合は、単一の操作で化合物を試み、SEQUENCE、他の接続のそれぞれに。"
    },
    {
      "indent": 3,
      "text": "2. If the attempts succeed, the session is still alive, and this is a strong indicator that the server's network address has moved. The client might send an EXCHANGE_ID on the connection that returned NFS4ERR_BADSESSION to see if there are opportunities for client ID trunking (i.e., the same client ID and so_major are returned). The client might use DNS to see if the moved network address was replaced with another, so that the performance and availability benefits of session trunking can continue.",
      "ja": "2.試みが成功した場合、セッションはまだ生きている、これはサーバのネットワークアドレスが移動したことに強い指標です。クライアントは、クライアントのIDトランキングの機会がある（すなわち、同じクライアントIDとso_major返された）かどうかを確認するためにNFS4ERR_BADSESSIONを返された接続上EXCHANGE_IDを送信することがあります。クライアントは、セッションのトランキングのパフォーマンスと可用性のメリットを継続できるように、移動ネットワークアドレスが、別のと交換したかどうかを確認するためにDNSを使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "3. If the SEQUENCE requests fail with NFS4ERR_BADSESSION, then the session no longer exists on any of the server network addresses for which the client has connections associated with that session ID. It is possible the session is still alive and available on other network addresses. The client sends an EXCHANGE_ID on all the connections to see if the server owner is still listening on those network addresses. If the same server owner is returned but a new client ID is returned, this is a strong indicator of a server restart. If both the same server owner and same client ID are returned, then this is a strong indication that the server did delete the session, and the client will need to send a CREATE_SESSION if it has no other sessions for that client ID. If a different server owner is returned, the client can use DNS to find other network addresses. If it does not, or if DNS does not find any other addresses for the server, then the client will be unable to provide NFSv4.1 service, and fatal errors should be returned to processes that were using the server. If the client is using a \"mount\" paradigm, unmounting the server is advised.",
      "ja": "3. SEQUENCE要求がNFS4ERR_BADSESSIONで失敗した場合、セッションはもはやクライアントがそのセッションIDに関連付けられた接続を持っているサーバ・ネットワーク・アドレスのいずれかに存在します。セッションがまだ他のネットワークアドレスに生きていて利用可能であることも可能です。クライアントは、サーバーの所有者はまだ、これらのネットワーク・アドレスをリッスンしているかどうかを確認するために、すべての接続にEXCHANGE_IDを送信します。同じサーバーの所有者が返されますが、新しいクライアントIDが返された場合、これはサーバの再起動の強力な指標です。同じサーバーの所有者と同じクライアントIDの両方が返された場合、これは、サーバーがセッションを削除したことが強く示唆され、そしてそれはそのクライアントIDには他のセッションを持っていない場合、クライアントはCREATE_SESSIONを送信する必要があります。別のサーバーの所有者が返された場合、クライアントは、他のネットワークアドレスを見つけるために、DNSを使用することができます。そうでない場合は、DNSがサーバーの任意の他のアドレスを見つけることができなかった場合、または、クライアントはNFSv4.1サービスを提供することができません、と致命的なエラーがサーバーを使用していたプロセスに返されるべきです。クライアントが「マウント」パラダイムを使用している場合は、サーバーをアンマウントすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "4. If the client knows of no other connections associated with the session ID and server network addresses that are, or have been, associated with the session ID, then the client can use DNS to find other network addresses. If it does not, or if DNS does not find any other addresses for the server, then the client will be unable to provide NFSv4.1 service, and fatal errors should be returned to processes that were using the server. If the client is using a \"mount\" paradigm, unmounting the server is advised.",
      "ja": "クライアントがセッションIDに関連付けられている、またはされているセッションIDとサーバネットワークアドレスに関連付けられていない他の接続を知っている場合は4、クライアントは、他のネットワークアドレスを見つけるために、DNSを使用することができます。そうでない場合は、DNSがサーバーの任意の他のアドレスを見つけることができなかった場合、または、クライアントはNFSv4.1サービスを提供することができません、と致命的なエラーがサーバーを使用していたプロセスに返されるべきです。クライアントが「マウント」パラダイムを使用している場合は、サーバーをアンマウントすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "If there is a reconfiguration event that results in the same network address being assigned to servers where the eir_server_scope value is different, it cannot be guaranteed that a session ID generated by the first will be recognized as invalid by the first. Therefore, in managing server reconfigurations among servers with different server scope values, it is necessary to make sure that all clients have disconnected from the first server before effecting the reconfiguration. Nonetheless, clients should not assume that servers will always adhere to this requirement; clients MUST be prepared to deal with unexpected effects of server reconfigurations. Even where a session ID is inappropriately recognized as valid, it is likely either that the connection will not be recognized as valid or that a sequence value for a slot will not be correct. Therefore, when a client receives results indicating such unexpected errors, the use of EXCHANGE_ID to determine the current server configuration is RECOMMENDED.",
      "ja": "eir_server_scope値が異なるサーバに割り当てられている同じネットワークアドレスになり再構成イベントがある場合は、最初で生成されたセッションIDが最初で無効として認識されることを保証することはできません。そのため、異なるサーバースコープ値とサーバー間でのサーバーの再構成を管理するには、すべてのクライアントが再設定を行う前に、最初のサーバーから切断されていることを確認する必要があります。それにもかかわらず、クライアントは、サーバは常にこの要件を遵守することを前提とすべきではありません。クライアントは、サーバーの再構成の予期しない影響に対処するために準備しなければなりません。セッションIDが不適切に有効であると認識されている場合でも、接続が有効であると認識されないこと、またはスロットのシーケンスの値は正確でないことのいずれかの可能性があります。クライアントがそのような予期しないエラーを示す結果を受信した場合、したがって、現在のサーバの構成を決定するEXCHANGE_IDの使用が推奨されます。"
    },
    {
      "indent": 3,
      "text": "A variation on the above is that after a server's network address moves, there is no NFSv4.1 server listening, e.g., no listener on port 2049. In this example, one of the following occur: the NFSv4 server returns NFS4ERR_MINOR_VERS_MISMATCH, the NFS server returns a PROG_MISMATCH error, the RPC listener on 2049 returns PROG_UNVAIL, or attempts to reconnect to the network address timeout. These SHOULD be treated as equivalent to SEQUENCE returning NFS4ERR_BADSESSION for these purposes.",
      "ja": "上記の変化は例えば、この例では、ポート2049には、リスナー、次のいずれかが発生しない、サーバのネットワークアドレスが移動した後、何もNFSv4.1サーバーのリスニングがないことである：NFSv4サーバはNFS4ERR_MINOR_VERS_MISMATCH、NFSサーバを返します。 PROG_MISMATCHエラーを返し、2049にRPCリスナーはPROG_UNVAILを返し、又はネットワークアドレスのタイムアウトに再接続しようと試みます。これらは、これらの目的のためにNFS4ERR_BADSESSIONを返すSEQUENCEと同等に扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "When the client detects session loss, it needs to call CREATE_SESSION to recover. Any non-idempotent operations that were in progress might have been performed on the server at the time of session loss. The client has no general way to recover from this.",
      "ja": "クライアントがセッションの損失を検出すると、それが回復するCREATE_SESSIONを呼び出す必要があります。進行中であった非冪等の操作は、セッションロスの時に、サーバー上で実行されている場合があります。クライアントは、このから回復する一般的な方法を持っていません。"
    },
    {
      "indent": 3,
      "text": "Note that loss of session does not imply loss of byte-range lock, open, delegation, or layout state because locks, opens, delegations, and layouts are tied to the client ID and depend on the client ID, not the session. Nor does loss of byte-range lock, open, delegation, or layout state imply loss of session state, because the session depends on the client ID; loss of client ID however does imply loss of session, byte-range lock, open, delegation, and layout state. See Section 8.4.2. A session can survive a server restart, but lock recovery may still be needed.",
      "ja": "ロックは、開き代表団、およびレイアウトはクライアントIDに関連付けられているし、クライアントID、いないセッションに依存しているためバイト範囲ロック、オープン、委譲、またはレイアウトの状態の喪失を意味するものではありませんセッションの損失に注意してください。セッションは、クライアントのIDに依存しているため、NORバイト範囲ロックの喪失、オープン、委譲、またはレイアウトの状態は、セッション状態の損失を意味するものではありません。クライアントIDの損失は、しかし、セッションの損失、バイト範囲ロック、オープン、委任、およびレイアウトの状態を意味するものではありません。 8.4.2項を参照してください。セッションは、サーバーの再起動を生き残ることができますが、ロック回復がまだ必要かもしれません。"
    },
    {
      "indent": 3,
      "text": "It is possible that CREATE_SESSION will fail with NFS4ERR_STALE_CLIENTID (e.g., the server restarts and does not preserve client ID state). If so, the client needs to call EXCHANGE_ID, followed by CREATE_SESSION.",
      "ja": "CREATE_SESSIONがNFS4ERR_STALE_CLIENTIDで失敗します（例えば、サーバーが再起動し、クライアントIDの状態を保存しない）ことも可能です。その場合、クライアントはCREATE_SESSION続いEXCHANGE_IDを呼び出す必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10.13.2. Events Requiring Server Action",
      "section_title": true,
      "ja": "2.10.13.2。サーバーアクションが必要なイベント"
    },
    {
      "indent": 3,
      "text": "The following events require server action to recover.",
      "ja": "次のイベントが回復するサーバーのアクションを必要とします。"
    },
    {
      "indent": 0,
      "text": "2.10.13.2.1. Client Crash and Restart",
      "section_title": true,
      "ja": "2.10.13.2.1。クライアントのクラッシュと再起動"
    },
    {
      "indent": 3,
      "text": "As described in Section 18.35, a restarted client sends EXCHANGE_ID in such a way that it causes the server to delete any sessions it had.",
      "ja": "セクション18.35で述べたように、再起動クライアントは、それが持っていたすべてのセッションを削除するには、サーバーの原因となるような方法でEXCHANGE_IDを送信します。"
    },
    {
      "indent": 0,
      "text": "2.10.13.2.2. Client Crash with No Restart",
      "section_title": true,
      "ja": "2.10.13.2.2。ノー再起動してクライアントのクラッシュ"
    },
    {
      "indent": 3,
      "text": "If a client crashes and never comes back, it will never send EXCHANGE_ID with its old client owner. Thus, the server has session state that will never be used again. After an extended period of time, and if the server has resource constraints, it MAY destroy the old session as well as locking state.",
      "ja": "クライアントがクラッシュし、決して戻ってきた場合、それはその古いクライアント所有者でEXCHANGE_IDを送信することはありません。このように、サーバが再び使用されることはありませんセッション状態を持っています。長時間の後、およびサーバはリソースの制約がある場合、それは古いセッションを破棄するだけでなく、状態をロックするかもしれません。"
    },
    {
      "indent": 0,
      "text": "2.10.13.2.3. Extended Network Partition",
      "section_title": true,
      "ja": "2.10.13.2.3。拡張ネットワークパーティション"
    },
    {
      "indent": 3,
      "text": "To the server, the extended network partition may be no different from a client crash with no restart (see Section 2.10.13.2.2). Unless the server can discern that there is a network partition, it is free to treat the situation as if the client has crashed permanently.",
      "ja": "サーバーに、拡張ネットワークパーティションはありません再起動（セクション2.10.13.2.2を参照）を使用してクライアントのクラッシュと何ら変わりないかもしれません。サーバーは、ネットワークパーティションがあることを見分けることができない限り、クライアントが永続的にクラッシュしたかのような状況を扱うために自由です。"
    },
    {
      "indent": 0,
      "text": "2.10.13.2.4. Backchannel Connection Loss",
      "section_title": true,
      "ja": "2.10.13.2.4。バックチャネル接続の損失"
    },
    {
      "indent": 3,
      "text": "If there were callback requests outstanding at the time of a connection loss, then the server MUST retry the requests, as described in Section 2.10.6.2. Note that it is not necessary to retry requests over a connection with the same source network address or the same destination network address as the lost connection. As long as the session ID, slot ID, and sequence ID in the retry match that of the original request, the callback target will recognize the request as a retry even if it did see the request prior to disconnect.",
      "ja": "接続損失時の優れたコールバック要求があった場合は、セクション2.10.6.2で説明したように、サーバは、要求を再試行しなければなりません。同じソースネットワークアドレスまたは失われた接続と同じ宛先ネットワークアドレスとの接続を介して要求を再試行する必要はないことに注意してください。限りその元の要求の再試行の試合でセッションID、スロットID、およびシーケンスIDとして、コールバック対象は、それが切断する前にリクエストを見た場合でも、再試行として要求を認識します。"
    },
    {
      "indent": 3,
      "text": "If the connection lost is the last one associated with the backchannel, then the server MUST indicate that in the sr_status_flags field of every SEQUENCE reply until the backchannel is re-established. There are two situations, each of which uses different status flags: no connectivity for the session's backchannel and no connectivity for any session backchannel of the client. See Section 18.46 for a description of the appropriate flags in sr_status_flags.",
      "ja": "失われた接続がバックチャネルに関連付けられた最後のものである場合にはバックチャネルが再確立されるまで、サーバーはすべてのSEQUENCE応答のsr_status_flagsフィールドにそれを示す必要があります。セッションのバックチャネルのための無接続とクライアントのいずれかのセッションのバックチャネルのための接続なし：異なるステータスフラグを使用してそれぞれの2つの状況があります。 sr_status_flagsで適切なフラグの説明については、セクション18.46を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.10.13.2.5. GSS Context Loss",
      "section_title": true,
      "ja": "2.10.13.2.5。 GSSコンテキスト損失"
    },
    {
      "indent": 3,
      "text": "The server SHOULD monitor when the number of RPCSEC_GSS handles assigned to the backchannel reaches one, and when that one handle is near expiry (i.e., between one and two periods of lease time), and indicate so in the sr_status_flags field of all SEQUENCE replies. The server MUST indicate when all of the backchannel's assigned RPCSEC_GSS handles have expired via the sr_status_flags field of all SEQUENCE replies.",
      "ja": "サーバRPCSEC_GSSの数をバックチャネルに割り当てられたハンドルときに監視すべきは、一つに到達し、その1つのハンドルが（リース時間の1及び2期間の間、すなわち、）期限近くにある場合、及び全てのsr_status_flagsフィールドにそう示すSEQUENCE返信。バックチャネルの割り当てRPCSEC_GSSハンドルのすべてが、すべてのシーケンスの返信のsr_status_flagsフィールドを経由して期限切れになったときにサーバーが指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10.14. Parallel NFS and Sessions",
      "section_title": true,
      "ja": "2.10.14. パラレルNFSとセッション"
    },
    {
      "indent": 3,
      "text": "A client and server can potentially be a non-pNFS implementation, a metadata server implementation, a data server implementation, or two or three types of implementations. The EXCHGID4_FLAG_USE_NON_PNFS, EXCHGID4_FLAG_USE_PNFS_MDS, and EXCHGID4_FLAG_USE_PNFS_DS flags (not mutually exclusive) are passed in the EXCHANGE_ID arguments and results to allow the client to indicate how it wants to use sessions created under the client ID, and to allow the server to indicate how it will allow the sessions to be used. See Section 13.1 for pNFS sessions considerations.",
      "ja": "クライアントとサーバは、潜在的に非pNFSの実装、メタデータサーバの実装、データ・サーバの実装、または実装の2種類または3種類とすることができます。 EXCHGID4_FLAG_USE_NON_PNFS、EXCHGID4_FLAG_USE_PNFS_MDS、およびEXCHGID4_FLAG_USE_PNFS_DSフラグ（相互に排他的ではない）クライアントがクライアントIDの下に作成されたセッションを使用したい方法を指示できるようにするためにEXCHANGE_IDの引数と結果に渡され、サーバはそれができるようになりますどのように示すことができるようにセッションが使用します。 pNFSのセッションの考慮事項については、セクション13.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Protocol Constants and Data Types",
      "section_title": true,
      "ja": "3.プロトコル定数とデータ型"
    },
    {
      "indent": 3,
      "text": "The syntax and semantics to describe the data types of the NFSv4.1 protocol are defined in the XDR RFC 4506 [2] and RPC RFC 5531 [3] documents. The next sections build upon the XDR data types to define constants, types, and structures specific to this protocol. The full list of XDR data types is in [13].",
      "ja": "構文およびセマンティクスNFSv4.1プロトコルのデータ・タイプを記述するXDRのRFC 4506で定義されている[2]とRPC RFC 5531 [3]ドキュメント。次のセクションでは、このプロトコルに固有の定数、型、および構造を定義するにはXDRのデータ型に基づいて構築します。 XDRデータ型の完全なリストは、[13]です。"
    },
    {
      "indent": 0,
      "text": "3.1. Basic Constants",
      "section_title": true,
      "ja": "3.1. 基本定数"
    },
    {
      "indent": 3,
      "text": "const NFS4_FHSIZE               = 128;\nconst NFS4_VERIFIER_SIZE        = 8;\nconst NFS4_OPAQUE_LIMIT         = 1024;\nconst NFS4_SESSIONID_SIZE       = 16;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const NFS4_INT64_MAX            = 0x7fffffffffffffff;\nconst NFS4_UINT64_MAX           = 0xffffffffffffffff;\nconst NFS4_INT32_MAX            = 0x7fffffff;\nconst NFS4_UINT32_MAX           = 0xffffffff;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const NFS4_MAXFILELEN           = 0xffffffffffffffff;\nconst NFS4_MAXFILEOFF           = 0xfffffffffffffffe;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Except where noted, all these constants are defined in bytes.",
      "ja": "注記がある場合を除き、すべてのこれらの定数はバイト単位で定義されています。"
    },
    {
      "indent": 3,
      "text": "o NFS4_FHSIZE is the maximum size of a filehandle.",
      "ja": "O NFS4_FHSIZEは、ファイルハンドルの最大サイズです。"
    },
    {
      "indent": 3,
      "text": "o NFS4_VERIFIER_SIZE is the fixed size of a verifier.",
      "ja": "O NFS4_VERIFIER_SIZEは、検証の固定サイズです。"
    },
    {
      "indent": 3,
      "text": "o NFS4_OPAQUE_LIMIT is the maximum size of certain opaque information.",
      "ja": "O NFS4_OPAQUE_LIMITは、特定の不透明の情報の最大サイズです。"
    },
    {
      "indent": 3,
      "text": "o NFS4_SESSIONID_SIZE is the fixed size of a session identifier.",
      "ja": "O NFS4_SESSIONID_SIZEは、セッション識別子の固定サイズです。"
    },
    {
      "indent": 3,
      "text": "o NFS4_INT64_MAX is the maximum value of a signed 64-bit integer.",
      "ja": "O NFS4_INT64_MAXは、符号付き64ビット整数の最大値です。"
    },
    {
      "indent": 3,
      "text": "o NFS4_UINT64_MAX is the maximum value of an unsigned 64-bit integer.",
      "ja": "O NFS4_UINT64_MAXは、符号なし64ビット整数の最大値です。"
    },
    {
      "indent": 3,
      "text": "o NFS4_INT32_MAX is the maximum value of a signed 32-bit integer.",
      "ja": "O NFS4_INT32_MAXは、符号付き32ビット整数の最大値です。"
    },
    {
      "indent": 3,
      "text": "o NFS4_UINT32_MAX is the maximum value of an unsigned 32-bit integer.",
      "ja": "O NFS4_UINT32_MAXは、符号なし32ビット整数の最大値です。"
    },
    {
      "indent": 3,
      "text": "o NFS4_MAXFILELEN is the maximum length of a regular file.",
      "ja": "O NFS4_MAXFILELENは、通常のファイルの最大長です。"
    },
    {
      "indent": 3,
      "text": "o NFS4_MAXFILEOFF is the maximum offset into a regular file.",
      "ja": "O NFS4_MAXFILEOFFは、通常のファイルへのオフセット最大値です。"
    },
    {
      "indent": 0,
      "text": "3.2. Basic Data Types",
      "section_title": true,
      "ja": "3.2. 基本データ型"
    },
    {
      "indent": 3,
      "text": "These are the base NFSv4.1 data types.",
      "ja": "これらは、基本NFSv4.1データ型です。"
    },
    {
      "indent": 3,
      "text": "+---------------+---------------------------------------------------+\n| Data Type     | Definition                                        |\n+---------------+---------------------------------------------------+\n| int32_t       | typedef int int32_t;                              |\n| uint32_t      | typedef unsigned int uint32_t;                    |\n| int64_t       | typedef hyper int64_t;                            |\n| uint64_t      | typedef unsigned hyper uint64_t;                  |\n| attrlist4     | typedef opaque attrlist4<>;                       |\n|               | Used for file/directory attributes.               |\n| bitmap4       | typedef uint32_t bitmap4<>;                       |\n|               | Used in attribute array encoding.                 |\n| changeid4     | typedef uint64_t changeid4;                       |\n|               | Used in the definition of change_info4.           |\n| clientid4     | typedef uint64_t clientid4;                       |\n|               | Shorthand reference to client identification.     |\n| count4        | typedef uint32_t count4;                          |\n|               | Various count parameters (READ, WRITE, COMMIT).   |\n| length4       | typedef uint64_t length4;                         |\n|               | The length of a byte-range within a file.         |\n| mode4         | typedef uint32_t mode4;                           |\n|               | Mode attribute data type.                         |\n| nfs_cookie4   | typedef uint64_t nfs_cookie4;                     |\n|               | Opaque cookie value for READDIR.                  |\n| nfs_fh4       | typedef opaque nfs_fh4<NFS4_FHSIZE>;              |\n|               | Filehandle definition.                            |\n| nfs_ftype4    | enum nfs_ftype4;                                  |\n|               | Various defined file types.                       |\n| nfsstat4      | enum nfsstat4;                                    |\n|               | Return value for operations.                      |\n| offset4       | typedef uint64_t offset4;                         |\n|               | Various offset designations (READ, WRITE, LOCK,   |\n|               | COMMIT).                                          |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| qop4          | typedef uint32_t qop4;                            |\n|               | Quality of protection designation in SECINFO.     |\n| sec_oid4      | typedef opaque sec_oid4<>;                        |\n|               | Security Object Identifier.  The sec_oid4 data    |\n|               | type is not really opaque.  Instead, it contains  |\n|               | an ASN.1 OBJECT IDENTIFIER as used by GSS-API in  |\n|               | the mech_type argument to GSS_Init_sec_context.   |\n|               | See [7] for details.                              |\n| sequenceid4   | typedef uint32_t sequenceid4;                     |\n|               | Sequence number used for various session          |\n|               | operations (EXCHANGE_ID, CREATE_SESSION,          |\n|               | SEQUENCE, CB_SEQUENCE).                           |\n| seqid4        | typedef uint32_t seqid4;                          |\n|               | Sequence identifier used for locking.             |\n| sessionid4    | typedef opaque sessionid4[NFS4_SESSIONID_SIZE];   |\n|               | Session identifier.                               |\n| slotid4       | typedef uint32_t slotid4;                         |\n|               | Sequencing artifact for various session           |\n|               | operations (SEQUENCE, CB_SEQUENCE).               |\n| utf8string    | typedef opaque utf8string<>;                      |\n|               | UTF-8 encoding for strings.                       |\n| utf8str_cis   | typedef utf8string utf8str_cis;                   |\n|               | Case-insensitive UTF-8 string.                    |\n| utf8str_cs    | typedef utf8string utf8str_cs;                    |\n|               | Case-sensitive UTF-8 string.                      |\n| utf8str_mixed | typedef utf8string utf8str_mixed;                 |\n|               | UTF-8 strings with a case-sensitive prefix and a  |\n|               | case-insensitive suffix.                          |\n| component4    | typedef utf8str_cs component4;                    |\n|               | Represents pathname components.                   |\n| linktext4     | typedef utf8str_cs linktext4;                     |\n|               | Symbolic link contents (\"symbolic link\" is        |\n|               | defined in an Open Group [Section 3.372 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\"\">14] standard).          |\n| pathname4     | typedef component4 pathname4<>;                   |\n|               | Represents pathname for fs_locations.             |\n| verifier4     | typedef opaque verifier4[NFS4_VERIFIER_SIZE];     |\n|               | Verifier used for various operations (COMMIT,     |\n|               | CREATE, EXCHANGE_ID, OPEN, READDIR, WRITE)        |\n|               | NFS4_VERIFIER_SIZE is defined as 8.               |\n+---------------+---------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 26,
      "text": "End of Base Data Types",
      "ja": "基本データ型の終了"
    },
    {
      "indent": 34,
      "text": "Table 1",
      "ja": "表1"
    },
    {
      "indent": 0,
      "text": "3.3. Structured Data Types",
      "section_title": true,
      "ja": "3.3. 構造化データ型"
    },
    {
      "indent": 0,
      "text": "3.3.1. nfstime4",
      "section_title": true,
      "ja": "3.3.1.  nfstime4"
    },
    {
      "indent": 3,
      "text": "struct nfstime4 {\n        int64_t         seconds;\n        uint32_t        nseconds;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The nfstime4 data type gives the number of seconds and nanoseconds since midnight or zero hour January 1, 1970 Coordinated Universal Time (UTC). Values greater than zero for the seconds field denote dates after the zero hour January 1, 1970. Values less than zero for the seconds field denote dates before the zero hour January 1, 1970. In both cases, the nseconds field is to be added to the seconds field for the final time representation. For example, if the time to be represented is one-half second before zero hour January 1, 1970, the seconds field would have a value of negative one (-1) and the nseconds field would have a value of one-half second (500000000). Values greater than 999,999,999 for nseconds are invalid.",
      "ja": "nfstime4データ型は、深夜またはゼロ時間1970年1月1日協定世界時（UTC）からの秒とナノ秒数を示します。秒フィールドにゼロ以上の値がゼロ時間の1月1日以降の日付を表し、秒フィールドにはあまりゼロより1970年の値は、どちらの場合も、ゼロ時間1970年1月1日より前の日付を表し、nsecondsフィールドが追加されます最終時間表現のための秒フィールド。例えば、表現すべき時間がゼロ時間1970年1月1日前に、2番目の半分である場合、秒フィールドが負の1（-1）の値とnsecondsフィールドは、（第2の半分の値を有することになるだろう5億）。 nsecondsための999,999,999以上の値が無効です。"
    },
    {
      "indent": 3,
      "text": "This data type is used to pass time and date information. A server converts to and from its local representation of time when processing time values, preserving as much accuracy as possible. If the precision of timestamps stored for a file system object is less than defined, loss of precision can occur. An adjunct time maintenance protocol is RECOMMENDED to reduce client and server time skew.",
      "ja": "このデータ型は、日付と時刻の情報を渡すために使用されます。時間値を処理するとき、サーバはできるだけ正確さを維持し、時間のローカル表現へと変換します。ファイル・システム・オブジェクトのための記憶されたタイムスタンプの精度が規定未満であれば、精度の損失が発生する可能性があります。補助時間のメンテナンスプロトコルは、クライアントとサーバーの時間のずれを低減することを推奨します。"
    },
    {
      "indent": 0,
      "text": "3.3.2. time_how4",
      "section_title": true,
      "ja": "3.3.2.  time_how4"
    },
    {
      "indent": 3,
      "text": "enum time_how4 { SET_TO_SERVER_TIME4 = 0, SET_TO_CLIENT_TIME4 = 1 };",
      "ja": "列挙time_how4 {SET_TO_SERVER_TIME4 = 0、SET_TO_CLIENT_TIME4 = 1}。"
    },
    {
      "indent": 0,
      "text": "3.3.3. settime4",
      "section_title": true,
      "ja": "3.3.3.  settime4"
    },
    {
      "indent": 3,
      "text": "union settime4 switch (time_how4 set_it) {\n case SET_TO_CLIENT_TIME4:\n         nfstime4       time;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The time_how4 and settime4 data types are used for setting timestamps in file object attributes. If set_it is SET_TO_SERVER_TIME4, then the server uses its local representation of time for the time value.",
      "ja": "time_how4とsettime4データ型は、ファイルオブジェクトの属性にタイムスタンプを設定するために使用されています。 set_itがSET_TO_SERVER_TIME4ある場合、サーバーは、時間値のための時間のローカルな表現を使用しています。"
    },
    {
      "indent": 0,
      "text": "3.3.4. specdata4",
      "section_title": true,
      "ja": "3.3.4.  specdata4"
    },
    {
      "indent": 3,
      "text": "struct specdata4 {\n uint32_t specdata1; /* major device number */\n uint32_t specdata2; /* minor device number */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This data type represents the device numbers for the device file types NF4CHR and NF4BLK.",
      "ja": "このデータ型は、デバイスファイルの種類NF4CHRとNF4BLKのためのデバイス番号を表します。"
    },
    {
      "indent": 0,
      "text": "3.3.5. fsid4",
      "section_title": true,
      "ja": "3.3.5.  fsid4"
    },
    {
      "indent": 3,
      "text": "struct fsid4 {\n        uint64_t        major;\n        uint64_t        minor;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3.6. change_policy4",
      "section_title": true,
      "ja": "3.3.6.  change_policy4"
    },
    {
      "indent": 3,
      "text": "struct change_policy4 {\n        uint64_t        cp_major;\n        uint64_t        cp_minor;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The change_policy4 data type is used for the change_policy RECOMMENDED attribute. It provides change sequencing indication analogous to the change attribute. To enable the server to present a value valid across server re-initialization without requiring persistent storage, two 64-bit quantities are used, allowing one to be a server instance ID and the second to be incremented non-persistently, within a given server instance.",
      "ja": "change_policy4データ型はchange_policy推奨属性のために使用されています。これは、変化属性に類似変更のシーケンス表示を提供します。永続ストレージを必要とせずに、サーバの再初期横切って有効な値を提供するようにサーバーを可能にするために、2つの64ビット量は、特定のサーバーインスタンス内、一方はサーバーインスタンスIDと非永続的にインクリメントされる第2できるように、使用されています。"
    },
    {
      "indent": 0,
      "text": "3.3.7. fattr4",
      "section_title": true,
      "ja": "3.3.7.  fattr4"
    },
    {
      "indent": 3,
      "text": "struct fattr4 {\n        bitmap4         attrmask;\n        attrlist4       attr_vals;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fattr4 data type is used to represent file and directory attributes.",
      "ja": "fattr4データ型は、ファイルやディレクトリの属性を表すために使用されます。"
    },
    {
      "indent": 3,
      "text": "The bitmap is a counted array of 32-bit integers used to contain bit values. The position of the integer in the array that contains bit n can be computed from the expression (n / 32), and its bit within that integer is (n mod 32).",
      "ja": "ビットマップは、ビット値を含むように使用される32ビット整数のカウント配列です。ビットnを含む配列の整数の位置は、式（N / 32）から計算することができ、その整数内のそのビットは（N MOD 32）。"
    },
    {
      "indent": 3,
      "text": "0            1\n+-----------+-----------+-----------+--\n|  count    | 31  ..  0 | 63  .. 32 |\n+-----------+-----------+-----------+--",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3.8. change_info4",
      "section_title": true,
      "ja": "3.3.8. 変化_info4"
    },
    {
      "indent": 3,
      "text": "struct change_info4 {\n        bool            atomic;\n        changeid4       before;\n        changeid4       after;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This data type is used with the CREATE, LINK, OPEN, REMOVE, and RENAME operations to let the client know the value of the change attribute for the directory in which the target file system object resides.",
      "ja": "このデータ型は、クライアントがターゲット・ファイル・システム・オブジェクトが存在するディレクトリの変更属性の値を知っているように、CREATE、LINK、OPENは、REMOVE、名前の変更操作で使用されています。"
    },
    {
      "indent": 0,
      "text": "3.3.9. netaddr4",
      "section_title": true,
      "ja": "3.3.9.  netaddr4"
    },
    {
      "indent": 3,
      "text": "struct netaddr4 {\n        /* see struct rpcb in RFC 1833 */\n        string na_r_netid<>; /* network id */\n        string na_r_addr<>;  /* universal address */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The netaddr4 data type is used to identify network transport endpoints. The r_netid and r_addr fields respectively contain a netid and uaddr. The netid and uaddr concepts are defined in [15]. The netid and uaddr formats for TCP over IPv4 and TCP over IPv6 are defined in [15], specifically Tables 2 and 3 and Sections 5.2.3.3 and 5.2.3.4.",
      "ja": "netaddr4データ型はネットワークトランスポートエンドポイントを識別するために使用されます。 r_netidとR_ADDRフィールドは、それぞれNETIDとuaddrが含まれています。 NETIDとuaddr概念は[15]で定義されています。 NETIDとuaddrのIPv6上IPv4およびTCP上のTCPのためのフォーマットが定義されている[15]、具体的には表2及び表3及びセクション5.2.3.3および5.2.3.4。"
    },
    {
      "indent": 0,
      "text": "3.3.10. state_owner4",
      "section_title": true,
      "ja": "3.3.10.  state_owner4"
    },
    {
      "indent": 3,
      "text": "struct state_owner4 {\n        clientid4       clientid;\n        opaque          owner<NFS4_OPAQUE_LIMIT>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "typedef state_owner4 open_owner4;\ntypedef state_owner4 lock_owner4;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The state_owner4 data type is the base type for the open_owner4 (Section 3.3.10.1) and lock_owner4 (Section 3.3.10.2).",
      "ja": "state_owner4データ型はopen_owner4（セクション3.3.10.1）とlock_owner4（セクション3.3.10.2）の基本型です。"
    },
    {
      "indent": 0,
      "text": "3.3.10.1. open_owner4",
      "section_title": true,
      "ja": "3.3.10.1。 open_owner4"
    },
    {
      "indent": 3,
      "text": "This data type is used to identify the owner of OPEN state.",
      "ja": "このデータ型はOPEN状態の所有者を識別するために使用されます。"
    },
    {
      "indent": 0,
      "text": "3.3.10.2. lock_owner4",
      "section_title": true,
      "ja": "3.3.10.2。 lock_owner4"
    },
    {
      "indent": 3,
      "text": "This structure is used to identify the owner of byte-range locking state.",
      "ja": "この構造は、バイト範囲ロック状態の所有者を識別するために使用されます。"
    },
    {
      "indent": 0,
      "text": "3.3.11. open_to_lock_owner4",
      "section_title": true,
      "ja": "3.3.11.  open_to_lock_owner4"
    },
    {
      "indent": 3,
      "text": "struct open_to_lock_owner4 {\n        seqid4          open_seqid;\n        stateid4        open_stateid;\n        seqid4          lock_seqid;\n        lock_owner4     lock_owner;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This data type is used for the first LOCK operation done for an open_owner4. It provides both the open_stateid and lock_owner, such that the transition is made from a valid open_stateid sequence to that of the new lock_stateid sequence. Using this mechanism avoids the confirmation of the lock_owner/lock_seqid pair since it is tied to established state in the form of the open_stateid/open_seqid.",
      "ja": "このデータ型はopen_owner4に対して行う第1のロック操作のために使用されます。これは、遷移が新しいlock_stateid系列のそれに有効なopen_stateid配列から作られるように、open_stateidとlock_ownerの両方を提供します。それはopen_stateid / open_seqidの形で確立された状態に関連付けられているので、この機構を使用することlock_owner / lock_seqidペアの確認を回避します。"
    },
    {
      "indent": 0,
      "text": "3.3.12. stateid4",
      "section_title": true,
      "ja": "3.3.12.  stateid4"
    },
    {
      "indent": 3,
      "text": "struct stateid4 {\n        uint32_t        seqid;\n        opaque          other[12];\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This data type is used for the various state sharing mechanisms between the client and server. The client never modifies a value of data type stateid. The starting value of the \"seqid\" field is undefined. The server is required to increment the \"seqid\" field by one at each transition of the stateid. This is important since the client will inspect the seqid in OPEN stateids to determine the order of OPEN processing done by the server.",
      "ja": "このデータ型は、クライアントとサーバの間の種々の状態共有メカニズムのために使用されます。クライアントは、データ型のstateidの値を変更することはありません。 「SEQID」フィールドの開始値は未定義です。サーバはのstateidの各遷移における一方によって「SEQID」フィールドを増分する必要があります。クライアントがサーバによって行わOPEN処理の順序を決定するためにOPENのstateidsにSEQIDを検査しますので、これは重要です。"
    },
    {
      "indent": 0,
      "text": "3.3.13. layouttype4",
      "section_title": true,
      "ja": "3.3.13.  layouttype4"
    },
    {
      "indent": 3,
      "text": "enum layouttype4 { LAYOUT4_NFSV4_1_FILES = 0x1, LAYOUT4_OSD2_OBJECTS = 0x2, LAYOUT4_BLOCK_VOLUME = 0x3 };",
      "ja": "列挙layouttype4 {LAYOUT4_NFSV4_1_FILES = 0x1の、LAYOUT4_OSD2_OBJECTS = 0x2の、LAYOUT4_BLOCK_VOLUME =を0x3}。"
    },
    {
      "indent": 3,
      "text": "This data type indicates what type of layout is being used. The file server advertises the layout types it supports through the fs_layout_type file system attribute (Section 5.12.1). A client asks for layouts of a particular type in LAYOUTGET, and processes those layouts in its layout-type-specific logic.",
      "ja": "このデータ型は使用されているレイアウトの種類を示します。ファイルサーバは、それがfs_layout_typeファイルシステム属性（セクション5.12.1）を介してサポートしていレイアウトタイプをアドバタイズします。クライアントはLAYOUTGETにおける特定のタイプのレイアウトを要求し、そのレイアウト・タイプ固有のロジックでこれらのレイアウトを処理します。"
    },
    {
      "indent": 3,
      "text": "The layouttype4 data type is 32 bits in length. The range represented by the layout type is split into three parts. Type 0x0 is reserved. Types within the range 0x00000001-0x7FFFFFFF are globally unique and are assigned according to the description in Section 22.4; they are maintained by IANA. Types within the range 0x80000000-0xFFFFFFFF are site specific and for private use only.",
      "ja": "layouttype4データ型は、長さが32ビットです。レイアウトタイプで表される範囲は、3つの部分に分割されます。タイプ0x0が予約されています。範囲0x00000001-0x7FFFFFFF内のタイプがグローバルに一意であり、セクション22.4で説明に従って割り当てられます。彼らはIANAによって維持されています。範囲内の0x80000000-0xFFFFFFFFタイプは、サイトの特定とだけ私的使用のためにあります。"
    },
    {
      "indent": 3,
      "text": "The LAYOUT4_NFSV4_1_FILES enumeration specifies that the NFSv4.1 file layout type, as defined in Section 13, is to be used. The LAYOUT4_OSD2_OBJECTS enumeration specifies that the object layout, as defined in [40], is to be used. Similarly, the LAYOUT4_BLOCK_VOLUME enumeration specifies that the block/volume layout, as defined in [41], is to be used.",
      "ja": "LAYOUT4_NFSV4_1_FILES列挙はセクション13で定義されるようNFSv4.1ファイルレイアウトの種類は、使用することを指定します。 LAYOUT4_OSD2_OBJECTS列挙には[40]で定義されるように、オブジェクトのレイアウトが、使用することを指定します。同様に、[41]で定義されるようLAYOUT4_BLOCK_VOLUME列挙には、そのブロック/ボリュームレイアウトを指定し、使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "3.3.14. deviceid4",
      "section_title": true,
      "ja": "3.3.14.  deviceid4"
    },
    {
      "indent": 3,
      "text": "const NFS4_DEVICEID4_SIZE = 16;",
      "ja": "CONST NFS4_DEVICEID4_SIZE = 16。"
    },
    {
      "indent": 3,
      "text": "typedef opaque deviceid4[NFS4_DEVICEID4_SIZE];",
      "ja": "【NFS4_DEVICEID4_SIZE】不透明deviceid4のtypedef。"
    },
    {
      "indent": 3,
      "text": "Layout information includes device IDs that specify a storage device through a compact handle. Addressing and type information is obtained with the GETDEVICEINFO operation. Device IDs are not guaranteed to be valid across metadata server restarts. A device ID is unique per client ID and layout type. See Section 12.2.10 for more details.",
      "ja": "レイアウト情報は、コンパクトなハンドルを介してストレージ装置を指定したデバイスIDを含みます。アドレッシングおよびタイプ情報がGETDEVICEINFO操作で得られます。デバイスIDは、メタデータ・サーバを再起動して有効であることが保証されていません。デバイスIDは、クライアントIDとレイアウトタイプごとにユニークです。詳細については、セクション12.2.10を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.15. device_addr4",
      "section_title": true,
      "ja": "3.3.15.  device_addr4"
    },
    {
      "indent": 3,
      "text": "struct device_addr4 {\n        layouttype4             da_layout_type;\n        opaque                  da_addr_body<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The device address is used to set up a communication channel with the storage device. Different layout types will require different data types to define how they communicate with storage devices. The opaque da_addr_body field is interpreted based on the specified da_layout_type field.",
      "ja": "デバイスアドレスは、記憶装置との通信チャネルを設定するために使用されています。異なるレイアウトの種類は、彼らはストレージデバイスとの通信方法を定義するために、異なるデータタイプが必要になります。不透明da_addr_bodyフィールドが指定されたda_layout_typeフィールドに基づいて解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document defines the device address for the NFSv4.1 file layout (see Section 13.3), which identifies a storage device by network IP address and port number. This is sufficient for the clients to communicate with the NFSv4.1 storage devices, and may be sufficient for other layout types as well. Device types for object-based storage devices and block storage devices (e.g., Small Computer System Interface (SCSI) volume labels) are defined by their respective layout specifications.",
      "ja": "この文書は、ネットワークIPアドレスとポート番号で記憶装置を識別するNFSv4.1ファイルレイアウト（セクション13.3を参照）のデバイスアドレスを定義します。これにより、クライアントはNFSv4.1ストレージデバイスと通信するために十分であり、同様に他のレイアウトタイプのために十分であってもよいです。オブジェクトベースのストレージデバイスとブロックストレージデバイスのデバイスタイプ（例えば、小型コンピュータシステムインタフェース（SCSI）ボリュームラベル）は、それぞれのレイアウト仕様によって定義されます。"
    },
    {
      "indent": 0,
      "text": "3.3.16. layout_content4",
      "section_title": true,
      "ja": "3.3.16.  layout_content4"
    },
    {
      "indent": 3,
      "text": "struct layout_content4 {\n        layouttype4 loc_type;\n        opaque      loc_body<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The loc_body field is interpreted based on the layout type (loc_type). This document defines the loc_body for the NFSv4.1 file layout type; see Section 13.3 for its definition.",
      "ja": "loc_bodyフィールドがレイアウトタイプ（loc_type）に基づいて解釈されます。この文書では、NFSv4.1ファイルのレイアウトタイプ用loc_bodyを定義します。その定義については13.3節を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.17. layout4",
      "section_title": true,
      "ja": "3.3.17.  layout4"
    },
    {
      "indent": 3,
      "text": "struct layout4 {\n        offset4                 lo_offset;\n        length4                 lo_length;\n        layoutiomode4           lo_iomode;\n        layout_content4         lo_content;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The layout4 data type defines a layout for a file. The layout type specific data is opaque within lo_content. Since layouts are sub-dividable, the offset and length together with the file's filehandle, the client ID, iomode, and layout type identify the layout.",
      "ja": "layout4データ・タイプは、ファイルのレイアウトを定義します。レイアウトタイプ特定データがlo_content内で不透明です。レイアウトは、サブ分割可能、オフセットと長さは、ファイルのファイルハンドル、クライアントID、IOModeに、レイアウトタイプと一緒にされているので、レイアウトを識別します。"
    },
    {
      "indent": 0,
      "text": "3.3.18. layoutupdate4",
      "section_title": true,
      "ja": "3.3.18.  layoutupdate4"
    },
    {
      "indent": 3,
      "text": "struct layoutupdate4 {\n        layouttype4             lou_type;\n        opaque                  lou_body<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The layoutupdate4 data type is used by the client to return updated layout information to the metadata server via the LAYOUTCOMMIT (Section 18.42) operation. This data type provides a channel to pass layout type specific information (in field lou_body) back to the metadata server. For example, for the block/volume layout type, this could include the list of reserved blocks that were written. The contents of the opaque lou_body argument are determined by the layout type. The NFSv4.1 file-based layout does not use this data type; if lou_type is LAYOUT4_NFSV4_1_FILES, the lou_body field MUST have a zero length.",
      "ja": "layoutupdate4データ型はLAYOUTCOMMIT（項18.42）の操作を経て、メタデータ・サーバに更新したレイアウト情報を返すために、クライアントによって使用されます。このデータタイプは、バックメタデータサーバに（フィールドlou_bodyに）レイアウト・タイプ固有の情報を渡すためのチャネルを提供します。例えば、ブロック/ボリュームレイアウトタイプに対して、これは書き込まれた予約ブロックのリストを含むことができます。不透明lou_body引数の内容は、レイアウトの種類によって決定されます。 NFSv4.1ファイルベースのレイアウトは、このデータ型を使用していません。 lou_typeがLAYOUT4_NFSV4_1_FILESであれば、lou_bodyフィールドがゼロの長さを持たなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3.19. layouthint4",
      "section_title": true,
      "ja": "3.3.19.  layouthint4"
    },
    {
      "indent": 3,
      "text": "struct layouthint4 {\n        layouttype4             loh_type;\n        opaque                  loh_body<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The layouthint4 data type is used by the client to pass in a hint about the type of layout it would like created for a particular file. It is the data type specified by the layout_hint attribute described in Section 5.12.4. The metadata server may ignore the hint or may selectively ignore fields within the hint. This hint should be provided at create time as part of the initial attributes within OPEN. The loh_body field is specific to the type of layout (loh_type). The NFSv4.1 file-based layout uses the nfsv4_1_file_layouthint4 data type as defined in Section 13.3.",
      "ja": "layouthint4データ型は、それが特定のファイルのために作成された希望のレイアウトのタイプについてのヒントに渡すために、クライアントによって使用されます。これは、セクション5.12.4に記載しlayout_hint属性で指定されたデータ型です。メタデータサーバはヒントを無視したり、選択ヒント内のフィールドを無視することができます。このヒントは、OPEN内の最初の属性の一部として作成時に提供されるべきです。 loh_bodyフィールドは、レイアウト（loh_type）のタイプに特異的です。 13.3節で定義されるようNFSv4.1ファイルベースのレイアウトはnfsv4_1_file_layouthint4データ型を使用します。"
    },
    {
      "indent": 0,
      "text": "3.3.20. layoutiomode4",
      "section_title": true,
      "ja": "3.3.20.  layoutiomode4"
    },
    {
      "indent": 3,
      "text": "enum layoutiomode4 { LAYOUTIOMODE4_READ = 1, LAYOUTIOMODE4_RW = 2, LAYOUTIOMODE4_ANY = 3 };",
      "ja": "列挙layoutiomode4 {LAYOUTIOMODE4_READ = 1、LAYOUTIOMODE4_RW = 2、LAYOUTIOMODE4_ANY = 3}。"
    },
    {
      "indent": 3,
      "text": "The iomode specifies whether the client intends to just read or both read and write the data represented by the layout. While the LAYOUTIOMODE4_ANY iomode MUST NOT be used in the arguments to the LAYOUTGET operation, it MAY be used in the arguments to the LAYOUTRETURN and CB_LAYOUTRECALL operations. The LAYOUTIOMODE4_ANY iomode specifies that layouts pertaining to both LAYOUTIOMODE4_READ and LAYOUTIOMODE4_RW iomodes are being returned or recalled, respectively. The metadata server's use of the iomode may depend on the layout type being used. The storage devices MAY validate I/O accesses against the iomode and reject invalid accesses.",
      "ja": "IOModeには、クライアントがちょうど読み取りまたは両方のレイアウトによって表されるデータを読み書きするつもりかどうかを指定します。 LAYOUTIOMODE4_ANYのIOModeにはLAYOUTGET操作の引数に使用してはいけませんが、それはLAYOUTRETURNとCB_LAYOUTRECALL操作への引数に使用されるかもしれません。 LAYOUTIOMODE4_ANYのIOModeには、両方のLAYOUTIOMODE4_READとLAYOUTIOMODE4_RW iomodesに関連するレイアウトは、それぞれ、返品・リコールされていることを指定します。 IOModeにのメタデータ・サーバの使用は、使用されているレイアウトの種類に依存してもよいです。ストレージデバイスは、I / OがIOModeに反対アクセス検証し、不正なアクセスを拒否することがあります。"
    },
    {
      "indent": 0,
      "text": "3.3.21. nfs_impl_id4",
      "section_title": true,
      "ja": "3.3.21.  nfs_impl_id4"
    },
    {
      "indent": 3,
      "text": "struct nfs_impl_id4 {\n        utf8str_cis   nii_domain;\n        utf8str_cs    nii_name;\n        nfstime4      nii_date;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This data type is used to identify client and server implementation details. The nii_domain field is the DNS domain name with which the implementor is associated. The nii_name field is the product name of the implementation and is completely free form. It is RECOMMENDED that the nii_name be used to distinguish machine architecture, machine platforms, revisions, versions, and patch levels. The nii_date field is the timestamp of when the software instance was published or built.",
      "ja": "このデータ型は、クライアントとサーバーの実装の詳細を識別するために使用されます。 nii_domainフィールドは、実装者が関連付けられているDNSドメイン名です。 nii_nameフィールドは実装の製品名で、完全に自由な形式です。 nii_nameマシン・アーキテクチャ、コンピュータプラットフォーム、リビジョン、バージョン、およびパッチレベルを区別するために使用することを推奨されています。 nii_dateフィールドは、ソフトウェアのインスタンスは、公開または建設されたときのタイムスタンプです。"
    },
    {
      "indent": 0,
      "text": "3.3.22. threshold_item4",
      "section_title": true,
      "ja": "3.3.22.  threshold_item4"
    },
    {
      "indent": 3,
      "text": "struct threshold_item4 {\n        layouttype4     thi_layout_type;\n        bitmap4         thi_hintset;\n        opaque          thi_hintlist<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This data type contains a list of hints specific to a layout type for helping the client determine when it should send I/O directly through the metadata server versus the storage devices. The data type consists of the layout type (thi_layout_type), a bitmap (thi_hintset) describing the set of hints supported by the server (they may differ based on the layout type), and a list of hints (thi_hintlist) whose content is determined by the hintset bitmap. See the mdsthreshold attribute for more details.",
      "ja": "このデータ型は、それがストレージデバイスに対してメタデータサーバを介して直接I / Oを送信する必要がある場合、クライアントが決める手助けのためのレイアウトタイプに固有のヒントのリストが含まれています。データ型は、その内容によって決定されたサーバでサポートされているヒントのセット（これらはレイアウトタイプに基づいて異なっていてもよい）、およびヒントのリスト（thi_hintlist）を記述するレイアウトタイプ（thi_layout_type）、ビットマップ（thi_hintset）からなりますhintsetビットマップ。詳細はmdsthreshold属性を参照してください。"
    },
    {
      "indent": 3,
      "text": "The thi_hintset field is a bitmap of the following values:",
      "ja": "thi_hintsetフィールドには、次の値のビットマップです。"
    },
    {
      "indent": 3,
      "text": "+-------------------------+---+---------+---------------------------+\n| name                    | # | Data    | Description               |\n|                         |   | Type    |                           |\n+-------------------------+---+---------+---------------------------+\n| threshold4_read_size    | 0 | length4 | If a file's length is     |\n|                         |   |         | less than the value of    |\n|                         |   |         | threshold4_read_size,     |\n|                         |   |         | then it is RECOMMENDED    |\n|                         |   |         | that the client read from |\n|                         |   |         | the file via the MDS and  |\n|                         |   |         | not a storage device.     |\n| threshold4_write_size   | 1 | length4 | If a file's length is     |\n|                         |   |         | less than the value of    |\n|                         |   |         | threshold4_write_size,    |\n|                         |   |         | then it is RECOMMENDED    |\n|                         |   |         | that the client write to  |\n|                         |   |         | the file via the MDS and  |\n|                         |   |         | not a storage device.     |\n| threshold4_read_iosize  | 2 | length4 | For read I/O sizes below  |\n|                         |   |         | this threshold, it is     |\n|                         |   |         | RECOMMENDED to read data  |\n|                         |   |         | through the MDS.          |\n| threshold4_write_iosize | 3 | length4 | For write I/O sizes below |\n|                         |   |         | this threshold, it is     |\n|                         |   |         | RECOMMENDED to write data |\n|                         |   |         | through the MDS.          |\n+-------------------------+---+---------+---------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3.23. mdsthreshold4",
      "section_title": true,
      "ja": "3.3.23.  mdsthreshold4"
    },
    {
      "indent": 3,
      "text": "struct mdsthreshold4 {\n        threshold_item4 mth_hints<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This data type holds an array of elements of data type threshold_item4, each of which is valid for a particular layout type. An array is necessary because a server can support multiple layout types for a single file.",
      "ja": "このデータタイプは、特定のレイアウトタイプに対して有効であり、その各々はデータ型threshold_item4、の要素の配列を保持しています。サーバーは、単一のファイルに対して複数のレイアウトタイプをサポートすることができますので、配列が必要です。"
    },
    {
      "indent": 0,
      "text": "4. Filehandles",
      "section_title": true,
      "ja": "4.ファイルハンドル"
    },
    {
      "indent": 3,
      "text": "The filehandle in the NFS protocol is a per-server unique identifier for a file system object. The contents of the filehandle are opaque to the client. Therefore, the server is responsible for translating the filehandle to an internal representation of the file system object.",
      "ja": "NFSプロトコルにおけるファイルハンドルは、ファイル・システム・オブジェクトごとのサーバの一意の識別子です。ファイルハンドルの内容は、クライアントに不透明です。したがって、サーバは、ファイル・システム・オブジェクトの内部表現にファイルハンドルを変換する責任があります。"
    },
    {
      "indent": 0,
      "text": "4.1. Obtaining the First Filehandle",
      "section_title": true,
      "ja": "4.1. まず、ファイルハンドルの取得"
    },
    {
      "indent": 3,
      "text": "The operations of the NFS protocol are defined in terms of one or more filehandles. Therefore, the client needs a filehandle to initiate communication with the server. With the NFSv3 protocol (RFC 1813 [31]), there exists an ancillary protocol to obtain this first filehandle. The MOUNT protocol, RPC program number 100005, provides the mechanism of translating a string-based file system pathname to a filehandle, which can then be used by the NFS protocols.",
      "ja": "NFSプロトコルの動作は、一つ以上のファイルハンドルで定義されています。そのため、クライアントは、サーバとの通信を開始するためにファイルハンドルを必要とします。 NFSv3のプロトコル（RFC 1813 [31]）と、この第一のファイルハンドルを取得するために補助的なプロトコルが存在します。 MOUNTプロトコル、RPCプログラム番号100005は、次いで、NFSプロトコルによって使用することができるファイルハンドルに文字列ベースのファイルシステムのパス名を変換する機構を提供します。"
    },
    {
      "indent": 3,
      "text": "The MOUNT protocol has deficiencies in the area of security and use via firewalls. This is one reason that the use of the public filehandle was introduced in RFC 2054 [42] and RFC 2055 [43]. With the use of the public filehandle in combination with the LOOKUP operation in the NFSv3 protocol, it has been demonstrated that the MOUNT protocol is unnecessary for viable interaction between NFS client and server.",
      "ja": "MOUNTプロトコルがファイアウォールを経由して、セキュリティと使用領域の欠陥を持っています。これは、公共ファイルハンドルの使用は、RFC 2054 [42]およびRFC 2055 [43]で導入された理由の一つです。 NFSv3のプロトコルにおけるLOOKUP操作との組み合わせで、公共ファイルハンドルを使用すると、MOUNTプロトコルはNFSクライアントとサーバの間で実行可能な相互作用のために不必要であることが証明されています。"
    },
    {
      "indent": 3,
      "text": "Therefore, the NFSv4.1 protocol will not use an ancillary protocol for translation from string-based pathnames to a filehandle. Two special filehandles will be used as starting points for the NFS client.",
      "ja": "したがって、NFSv4.1プロトコルは、ファイルハンドルに文字列ベースのパス名からの翻訳のための補助的なプロトコルを使用しません。二つの特別なファイルハンドルはNFSクライアントのための出発点として使用されます。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Root Filehandle",
      "section_title": true,
      "ja": "4.1.1. ルートファイルハンドル"
    },
    {
      "indent": 3,
      "text": "The first of the special filehandles is the ROOT filehandle. The ROOT filehandle is the \"conceptual\" root of the file system namespace at the NFS server. The client uses or starts with the ROOT filehandle by employing the PUTROOTFH operation. The PUTROOTFH operation instructs the server to set the \"current\" filehandle to the ROOT of the server's file tree. Once this PUTROOTFH operation is used, the client can then traverse the entirety of the server's file tree with the LOOKUP operation. A complete discussion of the server namespace is in Section 7.",
      "ja": "特別なファイルハンドルの最初は、ROOTファイルハンドルです。 ROOTファイルハンドルは、NFSサーバーでのファイルシステムの名前空間の「概念」ルートです。クライアントが使用していますかPUTROOTFH操作を採用することにより、ROOTファイルハンドルから始まります。 PUTROOTFH操作は、サーバーのファイルツリーのルートに「現在の」ファイルハンドルを設定するために、サーバーに指示します。このPUTROOTFH操作が使用されると、次にクライアントはLOOKUP操作でサーバーのファイルツリーの全体を横切ることができます。サーバーの名前空間の完全な議論はセクション7です。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Public Filehandle",
      "section_title": true,
      "ja": "4.1.2. 公開ファイルハンドル"
    },
    {
      "indent": 3,
      "text": "The second special filehandle is the PUBLIC filehandle. Unlike the ROOT filehandle, the PUBLIC filehandle may be bound or represent an arbitrary file system object at the server. The server is responsible for this binding. It may be that the PUBLIC filehandle and the ROOT filehandle refer to the same file system object. However, it is up to the administrative software at the server and the policies of the server administrator to define the binding of the PUBLIC filehandle and server file system object. The client may not make any assumptions about this binding. The client uses the PUBLIC filehandle via the PUTPUBFH operation.",
      "ja": "第2の特殊ファイルハンドルは、PUBLICファイルハンドルです。 ROOTファイルハンドルとは異なり、PUBLICファイルハンドルを結合してもよいし、サーバに任意のファイル・システム・オブジェクトを表します。サーバーは、この結合の原因です。これは、PUBLICファイルハンドルとROOTファイルハンドルは同じファイル・システム・オブジェクトを参照している可能性があります。しかし、それはPUBLICファイルハンドルとサーバーのファイルシステムオブジェクトの結合を定義するために、サーバーの管理ソフトウェア、およびサーバ管理者の方針次第です。クライアントは、このバインディングについての仮定をしない場合があります。クライアントはPUTPUBFH操作によってPUBLICファイルハンドルを使用しています。"
    },
    {
      "indent": 0,
      "text": "4.2. Filehandle Types",
      "section_title": true,
      "ja": "4.2. ファイルハンドルタイプ"
    },
    {
      "indent": 3,
      "text": "In the NFSv3 protocol, there was one type of filehandle with a single set of semantics. This type of filehandle is termed \"persistent\" in NFSv4.1. The semantics of a persistent filehandle remain the same as before. A new type of filehandle introduced in NFSv4.1 is the \"volatile\" filehandle, which attempts to accommodate certain server environments.",
      "ja": "NFSv3のプロトコルでは、意味論の単一のセットを持つファイルハンドルの一つのタイプがありました。ファイルハンドルのこのタイプは、NFSv4.1で「持続的」と呼ばれています。永続的なファイルハンドルの意味は前と同じまま。 NFSv4.1に導入ファイルハンドルの新しいタイプは、特定のサーバ環境に適応しようとする「揮発性」ファイルハンドルです。"
    },
    {
      "indent": 3,
      "text": "The volatile filehandle type was introduced to address server functionality or implementation issues that make correct implementation of a persistent filehandle infeasible. Some server environments do not provide a file-system-level invariant that can be used to construct a persistent filehandle. The underlying server file system may not provide the invariant or the server's file system programming interfaces may not provide access to the needed invariant. Volatile filehandles may ease the implementation of server functionality such as hierarchical storage management or file system reorganization or migration. However, the volatile filehandle increases the implementation burden for the client.",
      "ja": "揮発性ファイルハンドルタイプは、実行不可能な永続的なファイルハンドルの正しい実装を行うサーバー機能や実装の問題に対処するために導入されました。一部のサーバー環境では、永続的なファイルハンドルを構築するために使用することができ、ファイル・システム・レベルの不変を提供していません。基盤となるサーバーのファイルシステムは、不変またはサーバのファイルシステム・プログラミング・インタフェースが必要な不変へのアクセスを提供することはできません提供することはできません。揮発性ファイルハンドルは、階層ストレージ管理やファイルシステムの再編成または移行などのサーバ機能の実装を容易にすることができます。ただし、揮発性ファイルハンドルは、クライアントの実装の負担が増加します。"
    },
    {
      "indent": 3,
      "text": "Since the client will need to handle persistent and volatile filehandles differently, a file attribute is defined that may be used by the client to determine the filehandle types being returned by the server.",
      "ja": "クライアントは異なり、永続的かつ揮発性ファイルハンドルを処理する必要がありますので、ファイルの属性は、サーバーによって返されるファイルハンドルのタイプを決定するために、クライアントによって使用されることが規定されています。"
    },
    {
      "indent": 0,
      "text": "4.2.1. General Properties of a Filehandle",
      "section_title": true,
      "ja": "4.2.1. ファイルハンドルの一般プロパティ"
    },
    {
      "indent": 3,
      "text": "The filehandle contains all the information the server needs to distinguish an individual file. To the client, the filehandle is opaque. The client stores filehandles for use in a later request and can compare two filehandles from the same server for equality by doing a byte-by-byte comparison. However, the client MUST NOT otherwise interpret the contents of filehandles. If two filehandles from the same server are equal, they MUST refer to the same file. Servers SHOULD try to maintain a one-to-one correspondence between filehandles and files, but this is not required. Clients MUST use filehandle comparisons only to improve performance, not for correct behavior. All clients need to be prepared for situations in which it cannot be determined whether two filehandles denote the same object and in such cases, avoid making invalid assumptions that might cause incorrect behavior. Further discussion of filehandle and attribute comparison in the context of data caching is presented in Section 10.3.4.",
      "ja": "ファイルハンドルは、サーバーは、個々のファイルを区別するために必要なすべての情報が含まれています。クライアントに、ファイルハンドルは不透明です。クライアント店後の要求で使用するためにファイルハンドルとバイト単位の比較を行うことによって平等に同じサーバーから二つのファイルハンドルを比較することができます。ただし、クライアントは、そうでない場合はファイルハンドルの内容を解釈してはいけません。同じサーバからの2つのファイルハンドルが等しい場合、それらは同じファイルを参照する必要があります。サーバーは、ファイルハンドルとファイルとの間の1対1の対応を維持しようとする必要があり、これは必須ではありません。クライアントは、だけでなく、正しい動作のために、パフォーマンスを向上させるためにファイルハンドルの比較を使用しなければなりません。すべてのクライアントは、2つのファイルハンドルが同じオブジェクトを表すかどうかを判断し、そのような場合には、不正な動作を引き起こす可能性がある無効な仮定を避けることができない状況のために準備する必要があります。データキャッシュのコンテキストでファイルハンドルと属性比較のさらなる議論は10.3.4項に示されています。"
    },
    {
      "indent": 3,
      "text": "As an example, in the case that two different pathnames when traversed at the server terminate at the same file system object, the server SHOULD return the same filehandle for each path. This can occur if a hard link (see [Section 3.191 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\"\">6]) is used to create two file names that refer to the same underlying file object and associated data. For example, if paths /a/b/c and /a/d/c refer to the same file, the server SHOULD return the same filehandle for both pathnames' traversals.",
      "ja": "一例として、サーバで横断つの異なるパス名が同じファイル・システム・オブジェクトで終端している場合に、サーバは、パス毎に同じファイルハンドルを返すべきです。これはハードリンク（参照[Open Groupの基本仕様の問題の基本定義6 IEEE STD 1003.1、2004 Editionの、HTMLバージョン（www.opengroup.org）、ISBN 1931624232 \"\"> 6の第3章のセクション3.191]場合に発生することができます）同じ基礎となるファイル・オブジェクトと関連付けられたデータを参照して2人のファイル名を作成するために使用されます。および/ A / D /同一のファイルを参照cはパス/ A / B / Cの場合、例えば、サーバは、両方のパス名トラバーサルのために同じファイルハンドルを返すべきです。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Persistent Filehandle",
      "section_title": true,
      "ja": "4.2.2. 永続的なファイルハンドル"
    },
    {
      "indent": 3,
      "text": "A persistent filehandle is defined as having a fixed value for the lifetime of the file system object to which it refers. Once the server creates the filehandle for a file system object, the server MUST accept the same filehandle for the object for the lifetime of the object. If the server restarts, the NFS server MUST honor the same filehandle value as it did in the server's previous instantiation. Similarly, if the file system is migrated, the new NFS server MUST honor the same filehandle as the old NFS server.",
      "ja": "永続ファイルハンドルは、それが参照するファイル・システム・オブジェクトの寿命のために固定値を有するものとして定義されます。サーバーは、ファイル・システム・オブジェクトのファイルハンドルを作成すると、サーバーは、オブジェクトの寿命のためのオブジェクトの同じファイルハンドルを受け入れなければなりません。サーバーが再起動する場合は、サーバーの以前のインスタンスで行ったように、NFSサーバは、同じファイルハンドル値を尊重しなければなりません。ファイルシステムが移行された場合も同様に、新しいNFSサーバは、古いNFSサーバと同じファイルハンドルを尊重しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The persistent filehandle will be become stale or invalid when the file system object is removed. When the server is presented with a persistent filehandle that refers to a deleted object, it MUST return an error of NFS4ERR_STALE. A filehandle may become stale when the file system containing the object is no longer available. The file system may become unavailable if it exists on removable media and the media is no longer available at the server or the file system in whole has been destroyed or the file system has simply been removed from the server's namespace (i.e., unmounted in a UNIX environment).",
      "ja": "ファイル・システム・オブジェクトが削除されたときに、永続ファイルハンドルは、古い、または無効になってされます。サーバーが削除されたオブジェクトを参照する永続的なファイルハンドルが提示されている場合、それはNFS4ERR_STALEのエラーを返さなければなりません。オブジェクトを含むファイルシステムが使用できなくなったとき、ファイルハンドルが古くなっていないことがあります。それは、リムーバブルメディア上に存在しないと、メディアがサーバで利用できなくなったか、全体のファイルシステムが破壊されているか、ファイルシステムは、単にUNIXでアンマウントサーバーの名前空間（すなわち、から削除されている場合は、ファイルシステムが使用できなくなることがあり環境）。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Volatile Filehandle",
      "section_title": true,
      "ja": "4.2.3. 揮発性ファイルハンドル"
    },
    {
      "indent": 3,
      "text": "A volatile filehandle does not share the same longevity characteristics of a persistent filehandle. The server may determine that a volatile filehandle is no longer valid at many different points in time. If the server can definitively determine that a volatile filehandle refers to an object that has been removed, the server should return NFS4ERR_STALE to the client (as is the case for persistent filehandles). In all other cases where the server determines that a volatile filehandle can no longer be used, it should return an error of NFS4ERR_FHEXPIRED.",
      "ja": "揮発性ファイルハンドルは、持続的なファイルハンドルの同じ寿命特性を共有しません。サーバーは、揮発性ファイルハンドルが時間内に多くの異なる時点でもはや有効であることを決定しないことがあります。サーバは決定的揮発性ファイルハンドルが削除されたオブジェクトを参照することを決定することができる場合（永続ファイルハンドルの場合のように）、サーバは、クライアントにNFS4ERR_STALEを返すべきです。サーバーが揮発性ファイルハンドルが使用できなくなると判断した他のすべてのケースでは、それはNFS4ERR_FHEXPIREDのエラーを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The REQUIRED attribute \"fh_expire_type\" is used by the client to determine what type of filehandle the server is providing for a particular file system. This attribute is a bitmask with the following values:",
      "ja": "必要な属性「fh_expire_typeは、」特定のファイルシステムのために提供しているファイルハンドルのサーバーの種類を決定するために、クライアントによって使用されます。この属性は、次の値を持つビットマスクです。"
    },
    {
      "indent": 3,
      "text": "FH4_PERSISTENT The value of FH4_PERSISTENT is used to indicate a persistent filehandle, which is valid until the object is removed from the file system. The server will not return NFS4ERR_FHEXPIRED for this filehandle. FH4_PERSISTENT is defined as a value in which none of the bits specified below are set.",
      "ja": "FH4_PERSISTENTはFH4_PERSISTENTの値は、オブジェクトがファイルシステムから削除されるまで有効で永続的なファイルハンドルを示すために使用されます。サーバーは、このファイルハンドルのためNFS4ERR_FHEXPIREDを返しません。 FH4_PERSISTENTは、以下の指定されたビットのどれも設定されていないれた値として定義されます。"
    },
    {
      "indent": 3,
      "text": "FH4_VOLATILE_ANY The filehandle may expire at any time, except as specifically excluded (i.e., FH4_NO_EXPIRE_WITH_OPEN).",
      "ja": "FH4_VOLATILE_ANYは、ファイルハンドルは、具体的に（即ち、FH4_NO_EXPIRE_WITH_OPEN）除外を除き、任意の時点で有効期限が切れることができます。"
    },
    {
      "indent": 3,
      "text": "FH4_NOEXPIRE_WITH_OPEN May only be set when FH4_VOLATILE_ANY is set. If this bit is set, then the meaning of FH4_VOLATILE_ANY is qualified to exclude any expiration of the filehandle when it is open.",
      "ja": "FH4_VOLATILE_ANYが設定されている場合FH4_NOEXPIRE_WITH_OPENにのみ設定することができます。このビットがセットされている場合は、FH4_VOLATILE_ANYの意味は、それが開いているときにファイルハンドルのいずれかの有効期限を除外する資格があります。"
    },
    {
      "indent": 3,
      "text": "FH4_VOL_MIGRATION The filehandle will expire as a result of a file system transition (migration or replication), in those cases in which the continuity of filehandle use is not specified by handle class information within the fs_locations_info attribute. When this bit is set, clients without access to fs_locations_info information should assume that filehandles will expire on file system transitions.",
      "ja": "FH4_VOL_MIGRATIONは、ファイルハンドルは、ファイルハンドルの使用の連続性がfs_locations_info属性内のハンドルクラス情報によって指定されていないような場合に、ファイルシステムの移行（マイグレーションまたは複製）の結果として、有効期限が切れます。このビットがセットされている場合、fs_locations_info情報へのアクセスのないクライアントは、ファイルハンドルは、ファイルシステムの移行に期限切れになることを前提とすべきです。"
    },
    {
      "indent": 3,
      "text": "FH4_VOL_RENAME The filehandle will expire during rename. This includes a rename by the requesting client or a rename by any other client. If FH4_VOL_ANY is set, FH4_VOL_RENAME is redundant.",
      "ja": "FH4_VOL_RENAMEは、ファイルハンドルは、名前の変更時に期限切れになります。これは、要求元のクライアントによる名前変更またはその他のクライアントによる名前の変更が含まれています。 FH4_VOL_ANYが設定されている場合、FH4_VOL_RENAMEは冗長です。"
    },
    {
      "indent": 3,
      "text": "Servers that provide volatile filehandles that can expire while open require special care as regards handling of RENAMEs and REMOVEs. This situation can arise if FH4_VOL_MIGRATION or FH4_VOL_RENAME is set, if FH4_VOLATILE_ANY is set and FH4_NOEXPIRE_WITH_OPEN is not set, or if a non-read-only file system has a transition target in a different handle class. In these cases, the server should deny a RENAME or REMOVE that would affect an OPEN file of any of the components leading to the OPEN file. In addition, the server should deny all RENAME or REMOVE requests during the grace period, in order to make sure that reclaims of files where filehandles may have expired do not do a reclaim for the wrong file.",
      "ja": "名前を変更し、削除しますの取り扱いに関してオープンには、特別なケアを必要としながら、期限切れにすることができ、揮発性ファイルハンドルを提供するサーバ。 FH4_VOLATILE_ANYが設定されているとFH4_NOEXPIRE_WITH_OPENが設定、または非読み取り専用ファイルシステムが異なるハンドルクラスで遷移先がある場合はされていない場合FH4_VOL_MIGRATIONまたはFH4_VOL_RENAMEが、設定されている場合、この状況が発生する可能性があります。これらのケースでは、サーバーは、OPENファイルにつながるのコンポーネントのいずれかのOPENのファイルに影響を与えるRENAMEまたは削除を拒否すべきです。また、サーバはすべてのRENAMEを否定すべきであるか、ファイルハンドルの有効期限が切れている可能性のあるファイルの再要求が間違ったファイルの再利用をしないことを確実にするためには、猶予期間中の要求を削除します。"
    },
    {
      "indent": 3,
      "text": "Volatile filehandles are especially suitable for implementation of the pseudo file systems used to bridge exports. See Section 7.5 for a discussion of this.",
      "ja": "揮発性ファイルハンドルは、輸出を埋めるために使用される疑似ファイルシステムの実装に特に適しています。この議論については7.5節を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.3. One Method of Constructing a Volatile Filehandle",
      "section_title": true,
      "ja": "4.3. 揮発性ファイルハンドルを構築する一つの方法"
    },
    {
      "indent": 3,
      "text": "A volatile filehandle, while opaque to the client, could contain:",
      "ja": "揮発性ファイルハンドルは、クライアントには不透明ながら、含めることができます："
    },
    {
      "indent": 3,
      "text": "[volatile bit = 1 | server boot time | slot | generation number] o slot is an index in the server volatile filehandle table",
      "ja": "[揮発性ビット= 1 |サーバーの起動時間|スロット|世代番号] Oスロットは、サーバ揮発性ファイルハンドルテーブルのインデックスであります"
    },
    {
      "indent": 3,
      "text": "o generation number is the generation number for the table entry/ slot",
      "ja": "O世代番号は、テーブルエントリ/スロットの世代番号であります"
    },
    {
      "indent": 3,
      "text": "When the client presents a volatile filehandle, the server makes the following checks, which assume that the check for the volatile bit has passed. If the server boot time is less than the current server boot time, return NFS4ERR_FHEXPIRED. If slot is out of range, return NFS4ERR_BADHANDLE. If the generation number does not match, return NFS4ERR_FHEXPIRED.",
      "ja": "クライアントは、揮発性ファイルハンドルを提示すると、サーバーは、揮発性ビットのチェックが合格したことを前提とし、以下のチェックを、作ります。サーバーの起動時間は、現在のサーバーの起動時間よりも小さい場合、NFS4ERR_FHEXPIREDを返します。スロットが範囲外の場合は、NFS4ERR_BADHANDLEを返します。世代番号が一致しない場合は、NFS4ERR_FHEXPIREDを返します。"
    },
    {
      "indent": 3,
      "text": "When the server restarts, the table is gone (it is volatile).",
      "ja": "サーバーを再起動すると、テーブルがなくなっている場合には（それは揮発性です）。"
    },
    {
      "indent": 3,
      "text": "If the volatile bit is 0, then it is a persistent filehandle with a different structure following it.",
      "ja": "揮発性のビットが0であれば、それはそれ以下の異なる構造を持つ永続的なファイルハンドルです。"
    },
    {
      "indent": 0,
      "text": "4.4. Client Recovery from Filehandle Expiration",
      "section_title": true,
      "ja": "4.4. ファイルハンドルの有効期限からクライアント回復"
    },
    {
      "indent": 3,
      "text": "If possible, the client SHOULD recover from the receipt of an NFS4ERR_FHEXPIRED error. The client must take on additional responsibility so that it may prepare itself to recover from the expiration of a volatile filehandle. If the server returns persistent filehandles, the client does not need these additional steps.",
      "ja": "可能な場合、クライアントはNFS4ERR_FHEXPIREDエラーの受領から回復する必要があります。それは揮発性ファイルハンドルの満了から回復するために自分自身を準備することができるように、クライアントは、追加の責任を取る必要があります。サーバーは、永続的なファイルハンドルを返した場合、クライアントは、これらの追加の手順は必要ありません。"
    },
    {
      "indent": 3,
      "text": "For volatile filehandles, most commonly the client will need to store the component names leading up to and including the file system object in question. With these names, the client should be able to recover by finding a filehandle in the namespace that is still available or by starting at the root of the server's file system namespace.",
      "ja": "揮発性ファイルハンドルのために、最も一般的なクライアントは、コンポーネント名に至るまで、問題のファイル・システム・オブジェクトを含むを保存する必要があります。これらの名前を使用すると、クライアントはまだ利用できたり、サーバーのファイルシステムの名前空間のルートに開始することである名前空間にファイルハンドルを見つけることによって回復することができるはずです。"
    },
    {
      "indent": 3,
      "text": "If the expired filehandle refers to an object that has been removed from the file system, obviously the client will not be able to recover from the expired filehandle.",
      "ja": "期限切れのファイルハンドルは、ファイルシステムから削除されたオブジェクトを参照する場合は、明らかにクライアントが期限切れのファイルハンドルから回復することはできません。"
    },
    {
      "indent": 3,
      "text": "It is also possible that the expired filehandle refers to a file that has been renamed. If the file was renamed by another client, again it is possible that the original client will not be able to recover. However, in the case that the client itself is renaming the file and the file is open, it is possible that the client may be able to recover. The client can determine the new pathname based on the processing of the rename request. The client can then regenerate the new filehandle based on the new pathname. The client could also use the COMPOUND procedure to construct a series of operations like:",
      "ja": "期限切れのファイルハンドルの名前が変更されたファイルを参照することも可能です。ファイルが別のクライアントによって名前が変更された場合は、再度、元のクライアントが回復することができない可能性があります。しかし、クライアント自身がファイルの名前を変更され、ファイルが開いている場合には、クライアントが回復することができる可能性があります。クライアントは、名前変更要求の処理に基づいて、新しいパス名を決定することができます。クライアントは、新しいパス名に基づいて新しいファイルハンドルを再生成することができます。また、クライアントは、のような一連の操作を構築するためにCOMPOUNDプロシージャを使用できます。"
    },
    {
      "indent": 13,
      "text": "RENAME A B\nLOOKUP B\nGETFH",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that the COMPOUND procedure does not provide atomicity. This example only reduces the overhead of recovering from an expired filehandle.",
      "ja": "COMPOUND手順は原子性を提供していないことに注意してください。この例では、唯一の有効期限が切れたファイルハンドルからの回復のオーバーヘッドを軽減します。"
    },
    {
      "indent": 0,
      "text": "5. File Attributes",
      "section_title": true,
      "ja": "5.ファイル属性"
    },
    {
      "indent": 3,
      "text": "To meet the requirements of extensibility and increased interoperability with non-UNIX platforms, attributes need to be handled in a flexible manner. The NFSv3 fattr3 structure contains a fixed list of attributes that not all clients and servers are able to support or care about. The fattr3 structure cannot be extended as new needs arise and it provides no way to indicate non-support. With the NFSv4.1 protocol, the client is able to query what attributes the server supports and construct requests with only those supported attributes (or a subset thereof).",
      "ja": "非UNIXプラットフォームと拡張性と相互運用性が向上の要件を満たすために、属性は、柔軟な方法で処理する必要があります。 NFSv3のfattr3構造は、すべてのクライアントとサーバーではないが、サポートしたり、気にすることができます属性の固定されたリストが含まれています。新たなニーズが発生し、それが非サポートを示す方法を提供していませんようfattr3構造を拡張することはできません。 NFSv4.1プロトコルを使用すると、クライアントは、サーバーがサポートするどの属性照会とのみサポートされる属性（またはそのサブセット）とのリクエストを構築することができます。"
    },
    {
      "indent": 3,
      "text": "To this end, attributes are divided into three groups: REQUIRED, RECOMMENDED, and named. Both REQUIRED and RECOMMENDED attributes are supported in the NFSv4.1 protocol by a specific and well-defined encoding and are identified by number. They are requested by setting a bit in the bit vector sent in the GETATTR request; the server response includes a bit vector to list what attributes were returned in the response. New REQUIRED or RECOMMENDED attributes may be added to the NFSv4 protocol as part of a new minor version by publishing a Standards Track RFC that allocates a new attribute number value and defines the encoding for the attribute. See Section 2.7 for further discussion.",
      "ja": "このため、属性は3つのグループに分けています必須、推奨、および命名します。必須および推奨属性の両方が特異的かつ明確に定義されたエンコーディングによってNFSv4.1プロトコルでサポートされており、番号で識別されます。それらはGETATTR要求で送信されたビット・ベクトル内のビットを設定することによって要求されています。サーバーの応答は、属性が応答で返されたものをリストするビットベクトルを含んでいます。新しい必須または推奨の属性は新しい属性数値を割り当て、属性のエンコーディングを定義する標準化過程のRFCを公開することによって、新たなマイナーバージョンの一部としてのNFSv4プロトコルに加えてもよいです。さらなる議論については、セクション2.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "Named attributes are accessed by the new OPENATTR operation, which accesses a hidden directory of attributes associated with a file system object. OPENATTR takes a filehandle for the object and returns the filehandle for the attribute hierarchy. The filehandle for the named attributes is a directory object accessible by LOOKUP or READDIR and contains files whose names represent the named attributes and whose data bytes are the value of the attribute. For example:",
      "ja": "名前付き属性は、ファイル・システム・オブジェクトに関連付けられた属性の隠しディレクトリにアクセスし、新たなOPENATTR操作によってアクセスされています。 OPENATTRは、オブジェクトのファイルハンドルを取り、属性階層のためのファイルハンドルを返します。名前の属性のファイルハンドルは、LOOKUPまたはREADDIRからアクセス可能なディレクトリオブジェクトで、名前が命名された属性とデータバイト属性の値ですが表すファイルが含まれています。例えば："
    },
    {
      "indent": 8,
      "text": "+----------+-----------+---------------------------------+\n| LOOKUP   | \"foo\"     | ; look up file                  |\n| GETATTR  | attrbits  |                                 |\n| OPENATTR |           | ; access foo's named attributes |\n| LOOKUP   | \"x11icon\" | ; look up specific attribute    |\n| READ     | 0,4096    | ; read stream of bytes          |\n+----------+-----------+---------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Named attributes are intended for data needed by applications rather than by an NFS client implementation. NFS implementors are strongly encouraged to define their new attributes as RECOMMENDED attributes by bringing them to the IETF Standards Track process.",
      "ja": "名前付き属性は、アプリケーションではなく、NFSクライアントの実装が必要とするデータのために意図されています。 NFSの実装が強くIETF標準化過程のプロセスにそれらをもたらすことが推奨する属性として彼らの新しい属性を定義することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The set of attributes that are classified as REQUIRED is deliberately small since servers need to do whatever it takes to support them. A server should support as many of the RECOMMENDED attributes as possible but, by their definition, the server is not required to support all of them. Attributes are deemed REQUIRED if the data is both needed by a large number of clients and is not otherwise reasonably computable by the client when support is not provided on the server.",
      "ja": "サーバはそれがそれらをサポートするために取るものは何でもする必要がありますので、必要に応じて分類されている属性のセットは、意図的に小さいです。サーバーは、可能な限り推奨属性の多くをサポートする必要がありますが、その定義により、サーバはそれらのすべてをサポートする必要はありません。属性は、データが両方のクライアントの数が多いことにより、必要とサポートがサーバー上で提供されていない場合、クライアントでそれ以外の場合は、合理的に計算可能ではありませんされている場合は必須と見なされます。"
    },
    {
      "indent": 3,
      "text": "Note that the hidden directory returned by OPENATTR is a convenience for protocol processing. The client should not make any assumptions about the server's implementation of named attributes and whether or not the underlying file system at the server has a named attribute directory. Therefore, operations such as SETATTR and GETATTR on the named attribute directory are undefined.",
      "ja": "OPENATTRによって返された隠しディレクトリは、プロトコル処理のための便利であることに注意してください。クライアントは、指定された属性のサーバの実装について、サーバーの基本的なファイルシステムは、名前付き属性のディレクトリを持っているかどうか任意の仮定を行うべきではありません。したがって、このような名前の属性ディレクトリにSETATTRやGETATTRなどの操作が定義されていません。"
    },
    {
      "indent": 0,
      "text": "5.1. REQUIRED Attributes",
      "section_title": true,
      "ja": "5.1. 必要な属性"
    },
    {
      "indent": 3,
      "text": "These MUST be supported by every NFSv4.1 client and server in order to ensure a minimum level of interoperability. The server MUST store and return these attributes, and the client MUST be able to function with an attribute set limited to these attributes. With just the REQUIRED attributes some client functionality may be impaired or limited in some ways. A client may ask for any of these attributes to be returned by setting a bit in the GETATTR request, and the server MUST return their value.",
      "ja": "これらは、相互運用性の最小レベルを確保するために、すべてのNFSv4.1のクライアントとサーバでサポートしなければなりません。サーバに格納され、これらの属性を返し、クライアントがこれらの属性に制限された属性セットで機能できなければならないしなければなりません。ただREQUIRED属性を持ついくつかのクライアント機能が損なわれたり、いくつかの方法で制限される場合があります。クライアントは、GETATTR要求にビットをセットすることによって返されるこれらの属性のいずれかを求めることができる、そしてサーバはその値を返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2. RECOMMENDED Attributes",
      "section_title": true,
      "ja": "5.2. 推奨属性"
    },
    {
      "indent": 3,
      "text": "These attributes are understood well enough to warrant support in the NFSv4.1 protocol. However, they may not be supported on all clients and servers. A client may ask for any of these attributes to be returned by setting a bit in the GETATTR request but must handle the case where the server does not return them. A client MAY ask for the set of attributes the server supports and SHOULD NOT request attributes the server does not support. A server should be tolerant of requests for unsupported attributes and simply not return them rather than considering the request an error. It is expected that servers will support all attributes they comfortably can and only fail to support attributes that are difficult to support in their operating environments. A server should provide attributes whenever they don't have to \"tell lies\" to the client. For example, a file modification time should be either an accurate time or should not be supported by the server. At times this will be difficult for clients, but a client is better positioned to decide whether and how to fabricate or construct an attribute or whether to do without the attribute.",
      "ja": "これらの属性は、NFSv4.1プロトコルでサポートを保証するために十分に理解されています。しかし、彼らはすべてのクライアントとサーバーではサポートされない場合があります。クライアントは、GETATTR要求にビットをセットすることによって返されるこれらの属性のいずれかを求めることができるが、サーバーがそれらを返さない場合を処理する必要があります。クライアントは、サーバーがサポートする属性のセットを求めることができるとSHOULD NOT要求がサポートされていないサーバーを属性。サーバがサポートされていない属性に対する要求の耐性があると単純にかなり要求エラーを考慮よりもそれらを返すべきではありません。サーバは、彼らが快適にできるすべての属性をサポートするだけで自分の操作環境でサポートすることが困難な属性をサポートするために失敗することが期待されます。彼らは、クライアントに「嘘をつく」する必要はありませんいつでもサーバーは、属性を提供する必要があります。例えば、ファイルの修正時刻が正確な時間のいずれかでなければなりませんまたはサーバーでサポートされていないはずです。時にはこれは、クライアントのために困難になりますが、クライアントは良く製造または属性を構築または属性なしで行うかどうかをするかどうか、およびその方法を決定するように配置されています。"
    },
    {
      "indent": 0,
      "text": "5.3. Named Attributes",
      "section_title": true,
      "ja": "5.3. 指定された属性"
    },
    {
      "indent": 3,
      "text": "These attributes are not supported by direct encoding in the NFSv4 protocol but are accessed by string names rather than numbers and correspond to an uninterpreted stream of bytes that are stored with the file system object. The namespace for these attributes may be accessed by using the OPENATTR operation. The OPENATTR operation returns a filehandle for a virtual \"named attribute directory\", and further perusal and modification of the namespace may be done using operations that work on more typical directories. In particular, READDIR may be used to get a list of such named attributes, and LOOKUP and OPEN may select a particular attribute. Creation of a new named attribute may be the result of an OPEN specifying file creation.",
      "ja": "これらの属性はNFSv4のプロトコルで直接符号化することによってサポートされていないが、文字列の名前ではなく番号でアクセスされ、ファイル・システム・オブジェクトに格納されたバイトの未解釈のストリームに対応します。これらの属性の名前空間はOPENATTR操作を使用してアクセスすることができます。 OPENATTR操作がより一般的なディレクトリに取り組む操作を用いて行うことができる名前空間の仮想「という名前の属性ディレクトリ」、さらに閲覧や変更のためのファイルハンドルを返します。特に、READDIRは、そのような名前の属性のリストを取得するために使用することができる、とLOOKUPとOPENは、特定の属性を選択することができます。新しい名前付き属性の作成は、OPEN指定ファイル作成の結果であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Once an OPEN is done, named attributes may be examined and changed by normal READ and WRITE operations using the filehandles and stateids returned by OPEN.",
      "ja": "OPENが完了すると、名前の属性が検査され、ファイルハンドルを使用して、通常の読み取りおよび書き込み操作によって変更し、OPENによって返さのstateidsすることができます。"
    },
    {
      "indent": 3,
      "text": "Named attributes and the named attribute directory may have their own (non-named) attributes. Each of these objects MUST have all of the REQUIRED attributes and may have additional RECOMMENDED attributes. However, the set of attributes for named attributes and the named attribute directory need not be, and typically will not be, as large as that for other objects in that file system.",
      "ja": "名前付き属性と名前の属性ディレクトリは、独自の（非命名）の属性を有することができます。これらの各オブジェクトは、必要なすべての属性を持たなければならないし、推奨される追加の属性を有することができます。しかし、指定された属性と名前の属性ディレクトリの属性のセットがある必要はない、と一般的に、そのファイルシステム内の他のオブジェクトの場合と同じ大きさではありません。"
    },
    {
      "indent": 3,
      "text": "Named attributes and the named attribute directory might be the target of delegations (in the case of the named attribute directory, these will be directory delegations). However, since granting delegations is at the server's discretion, a server need not support delegations on named attributes or the named attribute directory.",
      "ja": "名前付き属性と名前の属性ディレクトリには、代表団のターゲット（という名前の属性ディレクトリの場合には、これらのディレクトリの代表団となります）かもしれません。しかし、代表団は、サーバの裁量で付与するので、サーバーは指定された属性または名前付き属性ディレクトリに代表団をサポートする必要はありません。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that servers support arbitrary named attributes. A client should not depend on the ability to store any named attributes in the server's file system. If a server does support named attributes, a client that is also able to handle them should be able to copy a file's data and metadata with complete transparency from one location to another; this would imply that names allowed for regular directory entries are valid for named attribute names as well.",
      "ja": "サーバは、任意の名前の属性をサポートすることが推奨されます。クライアントは、サーバのファイルシステム内の任意の名前の属性を格納する能力に依存すべきではありません。サーバがサポートという名前の属性がない場合、またそれらを扱うことができるクライアントは、ある場所から別の場所への完全な透明性を持つファイルのデータおよびメタデータをコピーすることができるはずです。これは、通常のディレクトリエントリには使用でき名称は、同様の名前の属性名のために有効であることを含意するでしょう。"
    },
    {
      "indent": 3,
      "text": "In NFSv4.1, the structure of named attribute directories is restricted in a number of ways, in order to prevent the development of non-interoperable implementations in which some servers support a fully general hierarchical directory structure for named attributes while others support a limited but adequate structure for named attributes. In such an environment, clients or applications might come to depend on non-portable extensions. The restrictions are:",
      "ja": "NFSv4.1では、という名前の属性ディレクトリの構造は、他の人が制限されますがをサポートしながら、一部のサーバが指定された属性の完全一般的な階層ディレクトリ構造をサポートする非相互運用可能な実装の開発を防ぐために、いくつかの方法で制限されています指定された属性のための適切な構造。このような環境では、クライアントまたはアプリケーションは、非ポータブル拡張に依存するようになるかもしれません。制限事項は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o CREATE is not allowed in a named attribute directory. Thus, such objects as symbolic links and special files are not allowed to be named attributes. Further, directories may not be created in a named attribute directory, so no hierarchical structure of named attributes for a single object is allowed.",
      "ja": "Oという名前の属性ディレクトリに許可されていませんCREATE。したがって、シンボリックリンクや特殊なファイルのようなオブジェクトは、指定された属性であることを許可されていません。さらに、ディレクトリはという名前の属性ディレクトリに作成されない場合があり、その単一のオブジェクトの名前付き属性のない階層構造が許可されていません。"
    },
    {
      "indent": 3,
      "text": "o If OPENATTR is done on a named attribute directory or on a named attribute, the server MUST return NFS4ERR_WRONG_TYPE.",
      "ja": "OPENATTRという名前の属性ディレクトリ上または名前付き属性に行われている場合は、O、サーバはNFS4ERR_WRONG_TYPEを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Doing a RENAME of a named attribute to a different named attribute directory or to an ordinary (i.e., non-named-attribute) directory is not allowed.",
      "ja": "異なる名前の属性ディレクトリにまたは通常の（すなわち、非命名属性）ディレクトリが許可されていないに指定された属性のRENAMEを行うO。"
    },
    {
      "indent": 3,
      "text": "o Creating hard links between named attribute directories or between named attribute directories and ordinary directories is not allowed.",
      "ja": "名前付き属性のディレクトリ間または名前付き属性ディレクトリと通常のディレクトリ間のハードリンクを作成するoを許可されていません。"
    },
    {
      "indent": 3,
      "text": "Names of attributes will not be controlled by this document or other IETF Standards Track documents. See Section 22.1 for further discussion.",
      "ja": "属性の名前は、この文書または他のIETF標準化過程文書によって制御されることはありません。さらなる議論については項22.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.4. Classification of Attributes",
      "section_title": true,
      "ja": "5.4. 属性の分類"
    },
    {
      "indent": 3,
      "text": "Each of the REQUIRED and RECOMMENDED attributes can be classified in one of three categories: per server (i.e., the value of the attribute will be the same for all file objects that share the same server owner; see Section 2.5 for a definition of server owner), per file system (i.e., the value of the attribute will be the same for some or all file objects that share the same fsid attribute (Section 5.8.1.9) and server owner), or per file system object. Note that it is possible that some per file system attributes may vary within the file system, depending on the value of the \"homogeneous\" (Section 5.8.2.16) attribute. Note that the attributes time_access_set and time_modify_set are not listed in this section because they are write-only attributes corresponding to time_access and time_modify, and are used in a special instance of SETATTR.",
      "ja": "REQUIREDのそれぞれと推奨属性は、次の3つのカテゴリのいずれかに分類することができます。サーバーごとに（すなわち、属性の値が同じサーバーの所有者を共有するすべてのファイルオブジェクトに対して同じになります。サーバーの所有者の定義については、2.5節を参照してください）、ファイルシステムごとに、サーバーの所有者）、またはファイルごとにシステムオブジェクト（すなわち、属性の値が同じFSID属性（セクション5.8.1.9を共有一部またはすべてのファイルオブジェクトに対して同じになります）。いくつかのファイルあたりのシステム属性は「均質」（セクション5.8.2.16）属性の値に応じて、ファイルシステム内で変動する可能性があることに注意してください。属性time_access_setとtime_modify_setは、それらが書き込み専用のtime_accessとtime_modifyに対応する属性であるため、このセクションに記載されていない、とSETATTRの特殊なインスタンスで使用されることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "o The per-server attribute is:",
      "ja": "Oサーバごとの属性は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "lease_time",
      "ja": "リース時間"
    },
    {
      "indent": 3,
      "text": "o The per-file system attributes are:",
      "ja": "ファイルシステムごとoを属性は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "supported_attrs, suppattr_exclcreat, fh_expire_type,\nlink_support, symlink_support, unique_handles, aclsupport,\ncansettime, case_insensitive, case_preserving,\nchown_restricted, files_avail, files_free, files_total,\nfs_locations, homogeneous, maxfilesize, maxname, maxread,\nmaxwrite, no_trunc, space_avail, space_free, space_total,\ntime_delta, change_policy, fs_status, fs_layout_type,\nfs_locations_info, fs_charset_cap",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o The per-file system object attributes are:",
      "ja": "ファイルシステムごとにオブジェクトoの属性は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "type, change, size, named_attr, fsid, rdattr_error, filehandle,\nacl, archive, fileid, hidden, maxlink, mimetype, mode,\nnumlinks, owner, owner_group, rawdev, space_used, system,\ntime_access, time_backup, time_create, time_metadata,\ntime_modify, mounted_on_fileid, dir_notif_delay,\ndirent_notif_delay, dacl, sacl, layout_type, layout_hint,\nlayout_blksize, layout_alignment, mdsthreshold, retention_get,\nretention_set, retentevt_get, retentevt_set, retention_hold,\nmode_set_masked",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For quota_avail_hard, quota_avail_soft, and quota_used, see their definitions below for the appropriate classification.",
      "ja": "quota_avail_hard、quota_avail_soft、およびQUOTA_USEDために、適切な分類については、以下のそれらの定義を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.5. Set-Only and Get-Only Attributes",
      "section_title": true,
      "ja": "5.5. のみの設定とは、Get-属性のみ"
    },
    {
      "indent": 3,
      "text": "Some REQUIRED and RECOMMENDED attributes are set-only; i.e., they can be set via SETATTR but not retrieved via GETATTR. Similarly, some REQUIRED and RECOMMENDED attributes are get-only; i.e., they can be retrieved via GETATTR but not set via SETATTR. If a client attempts to set a get-only attribute or get a set-only attributes, the server MUST return NFS4ERR_INVAL.",
      "ja": "いくつかの必須および推奨属性は設定専用です。すなわち、それらはSETATTRを介して設定されたが、GETATTRを介して取得しないことができます。同様に、いくつかの必須および推奨の属性が取得専用です。すなわち、それらはGETATTRを介して取り出さなくSETATTRを介して設定されていないことができます。クライアントがGET専用属性を設定するか、または属性のみが設定を取得しようとすると、サーバーはNFS4ERR_INVALを返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.6. REQUIRED Attributes - List and Definition References",
      "section_title": true,
      "ja": "5.6. 必要な属性 - リストと定義参照"
    },
    {
      "indent": 3,
      "text": "The list of REQUIRED attributes appears in Table 2. The meaning of the columns of the table are:",
      "ja": "必要な属性のリストを表2、表の列の意味に表示されます。"
    },
    {
      "indent": 3,
      "text": "o Name: The name of the attribute.",
      "ja": "O名：属性の名前。"
    },
    {
      "indent": 3,
      "text": "o Id: The number assigned to the attribute. In the event of conflicts between the assigned number and [13], the latter is likely authoritative, but should be resolved with Errata to this document and/or [13]. See [44] for the Errata process.",
      "ja": "O番号：属性に割り当てられた番号。割り当てられた番号、[13]の間で競合が発生した場合、後者は、おそらく信頼できますが、この文書及び/又は[13]にエラッタで解決すべきです。エラッタ・プロセスのための[44]を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Data Type: The XDR data type of the attribute.",
      "ja": "Oデータタイプ：属性のXDRデータ型。"
    },
    {
      "indent": 3,
      "text": "o Acc: Access allowed to the attribute. R means read-only (GETATTR may retrieve, SETATTR may not set). W means write-only (SETATTR may set, GETATTR may not retrieve). R W means read/write (GETATTR may retrieve, SETATTR may set).",
      "ja": "Acc○：アクセス属性に許可されます。 Rは読み取り専用（GETATTRが検索してもよい、SETATTRが設定されていない場合があります）を意味します。 Wは、書き込み専用（SETATTRは、設定することがGETATTRが取得できない場合があります）を意味します。 R Wは、読み取り/書き込みを意味（GETATTRが検索してもよい、SETATTRは設定可能）。"
    },
    {
      "indent": 3,
      "text": "o Defined in: The section of this specification that describes the attribute.",
      "ja": "属性を記述し、この仕様のセクション：Oで定義されます。"
    },
    {
      "indent": 5,
      "text": "+--------------------+----+------------+-----+------------------+\n| Name               | Id | Data Type  | Acc | Defined in:      |\n+--------------------+----+------------+-----+------------------+\n| supported_attrs    | 0  | bitmap4    | R   | Section 5.8.1.1  |\n| type               | 1  | nfs_ftype4 | R   | Section 5.8.1.2  |\n| fh_expire_type     | 2  | uint32_t   | R   | Section 5.8.1.3  |\n| change             | 3  | uint64_t   | R   | Section 5.8.1.4  |\n| size               | 4  | uint64_t   | R W | Section 5.8.1.5  |\n| link_support       | 5  | bool       | R   | Section 5.8.1.6  |\n| symlink_support    | 6  | bool       | R   | Section 5.8.1.7  |\n| named_attr         | 7  | bool       | R   | Section 5.8.1.8  |\n| fsid               | 8  | fsid4      | R   | Section 5.8.1.9  |\n| unique_handles     | 9  | bool       | R   | Section 5.8.1.10 |\n| lease_time         | 10 | nfs_lease4 | R   | Section 5.8.1.11 |\n| rdattr_error       | 11 | enum       | R   | Section 5.8.1.12 |\n| filehandle         | 19 | nfs_fh4    | R   | Section 5.8.1.13 |\n| suppattr_exclcreat | 75 | bitmap4    | R   | Section 5.8.1.14 |\n+--------------------+----+------------+-----+------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 2",
      "ja": "表2"
    },
    {
      "indent": 0,
      "text": "5.7. RECOMMENDED Attributes - List and Definition References",
      "section_title": true,
      "ja": "5.7. 推奨属性 - リストと定義参照"
    },
    {
      "indent": 3,
      "text": "The RECOMMENDED attributes are defined in Table 3. The meanings of the column headers are the same as Table 2; see Section 5.6 for the meanings.",
      "ja": "推奨属性は、列ヘッダーの意味は表2と同じであり、表3に定義されています。意味については、セクション5.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "+--------------------+----+----------------+-----+------------------+\n| Name               | Id | Data Type      | Acc | Defined in:      |\n+--------------------+----+----------------+-----+------------------+\n| acl                | 12 | nfsace4<>      | R W | Section 6.2.1    |\n| aclsupport         | 13 | uint32_t       | R   | Section 6.2.1.2  |\n| archive            | 14 | bool           | R W | Section 5.8.2.1  |\n| cansettime         | 15 | bool           | R   | Section 5.8.2.2  |\n| case_insensitive   | 16 | bool           | R   | Section 5.8.2.3  |\n| case_preserving    | 17 | bool           | R   | Section 5.8.2.4  |\n| change_policy      | 60 | chg_policy4    | R   | Section 5.8.2.5  |\n| chown_restricted   | 18 | bool           | R   | Section 5.8.2.6  |\n| dacl               | 58 | nfsacl41       | R W | Section 6.2.2    |\n| dir_notif_delay    | 56 | nfstime4       | R   | Section 5.11.1   |\n| dirent_notif_delay | 57 | nfstime4       | R   | Section 5.11.2   |\n| fileid             | 20 | uint64_t       | R   | Section 5.8.2.7  |\n| files_avail        | 21 | uint64_t       | R   | Section 5.8.2.8  |\n| files_free         | 22 | uint64_t       | R   | Section 5.8.2.9  |\n| files_total        | 23 | uint64_t       | R   | Section 5.8.2.10 |\n| fs_charset_cap     | 76 | uint32_t       | R   | Section 5.8.2.11 |\n| fs_layout_type     | 62 | layouttype4<>  | R   | Section 5.12.1   |\n| fs_locations       | 24 | fs_locations   | R   | Section 5.8.2.12 |\n| fs_locations_info  | 67 | *              | R   | Section 5.8.2.13 |\n| fs_status          | 61 | fs4_status     | R   | Section 5.8.2.14 |\n| hidden             | 25 | bool           | R W | Section 5.8.2.15 |\n| homogeneous        | 26 | bool           | R   | Section 5.8.2.16 |\n| layout_alignment   | 66 | uint32_t       | R   | Section 5.12.2   |\n| layout_blksize     | 65 | uint32_t       | R   | Section 5.12.3   |\n| layout_hint        | 63 | layouthint4    |   W | Section 5.12.4   |\n| layout_type        | 64 | layouttype4<>  | R   | Section 5.12.5   |\n| maxfilesize        | 27 | uint64_t       | R   | Section 5.8.2.17 |\n| maxlink            | 28 | uint32_t       | R   | Section 5.8.2.18 |\n| maxname            | 29 | uint32_t       | R   | Section 5.8.2.19 |\n| maxread            | 30 | uint64_t       | R   | Section 5.8.2.20 |\n| maxwrite           | 31 | uint64_t       | R   | Section 5.8.2.21 |\n| mdsthreshold       | 68 | mdsthreshold4  | R   | Section 5.12.6   |\n| mimetype           | 32 | utf8str_cs     | R W | Section 5.8.2.22 |\n| mode               | 33 | mode4          | R W | Section 6.2.4    |\n| mode_set_masked    | 74 | mode_masked4   |   W | Section 6.2.5    |\n| mounted_on_fileid  | 55 | uint64_t       | R   | Section 5.8.2.23 |\n| no_trunc           | 34 | bool           | R   | Section 5.8.2.24 |\n| numlinks           | 35 | uint32_t       | R   | Section 5.8.2.25 |\n| owner              | 36 | utf8str_mixed  | R W | Section 5.8.2.26 |\n| owner_group        | 37 | utf8str_mixed  | R W | Section 5.8.2.27 |\n| quota_avail_hard   | 38 | uint64_t       | R   | Section 5.8.2.28 |\n| quota_avail_soft   | 39 | uint64_t       | R   | Section 5.8.2.29 |\n| quota_used         | 40 | uint64_t       | R   | Section 5.8.2.30 |\n| rawdev             | 41 | specdata4      | R   | Section 5.8.2.31 |\n| retentevt_get      | 71 | retention_get4 | R   | Section 5.13.3   |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| retentevt_set      | 72 | retention_set4 |   W | Section 5.13.4   |\n| retention_get      | 69 | retention_get4 | R   | Section 5.13.1   |\n| retention_hold     | 73 | uint64_t       | R W | Section 5.13.5   |\n| retention_set      | 70 | retention_set4 |   W | Section 5.13.2   |\n| sacl               | 59 | nfsacl41       | R W | Section 6.2.3    |\n| space_avail        | 42 | uint64_t       | R   | Section 5.8.2.32 |\n| space_free         | 43 | uint64_t       | R   | Section 5.8.2.33 |\n| space_total        | 44 | uint64_t       | R   | Section 5.8.2.34 |\n| space_used         | 45 | uint64_t       | R   | Section 5.8.2.35 |\n| system             | 46 | bool           | R W | Section 5.8.2.36 |\n| time_access        | 47 | nfstime4       | R   | Section 5.8.2.37 |\n| time_access_set    | 48 | settime4       |   W | Section 5.8.2.38 |\n| time_backup        | 49 | nfstime4       | R W | Section 5.8.2.39 |\n| time_create        | 50 | nfstime4       | R W | Section 5.8.2.40 |\n| time_delta         | 51 | nfstime4       | R   | Section 5.8.2.41 |\n| time_metadata      | 52 | nfstime4       | R   | Section 5.8.2.42 |\n| time_modify        | 53 | nfstime4       | R   | Section 5.8.2.43 |\n| time_modify_set    | 54 | settime4       |   W | Section 5.8.2.44 |\n+--------------------+----+----------------+-----+------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 3",
      "ja": "表3"
    },
    {
      "indent": 3,
      "text": "* fs_locations_info4",
      "ja": "* fs_locations_info4"
    },
    {
      "indent": 0,
      "text": "5.8. Attribute Definitions",
      "section_title": true,
      "ja": "5.8. 属性定義"
    },
    {
      "indent": 0,
      "text": "5.8.1. Definitions of REQUIRED Attributes",
      "section_title": true,
      "ja": "5.8.1. 必要な属性の定義"
    },
    {
      "indent": 0,
      "text": "5.8.1.1. Attribute 0: supported_attrs",
      "section_title": true,
      "ja": "5.8.1.1。属性0：supported_attrs"
    },
    {
      "indent": 3,
      "text": "The bit vector that would retrieve all REQUIRED and RECOMMENDED attributes that are supported for this object. The scope of this attribute applies to all objects with a matching fsid.",
      "ja": "このオブジェクトでサポートされているすべての必須および推奨の属性を取得しますビットベクトル。この属性の範囲は、一致するFSIDを持つすべてのオブジェクトに適用されます。"
    },
    {
      "indent": 0,
      "text": "5.8.1.2. Attribute 1: type",
      "section_title": true,
      "ja": "5.8.1.2。項目1：タイプ"
    },
    {
      "indent": 3,
      "text": "Designates the type of an object in terms of one of a number of special constants:",
      "ja": "特別な定数のうちの1つの点でオブジェクトの種類を指定します。"
    },
    {
      "indent": 3,
      "text": "o NF4REG designates a regular file.",
      "ja": "O NF4REGは、通常のファイルを指定します。"
    },
    {
      "indent": 3,
      "text": "o NF4DIR designates a directory.",
      "ja": "O NF4DIRは、ディレクトリを指定します。"
    },
    {
      "indent": 3,
      "text": "o NF4BLK designates a block device special file.",
      "ja": "O NF4BLKはブロックデバイス特殊ファイルを指定します。"
    },
    {
      "indent": 3,
      "text": "o NF4CHR designates a character device special file.",
      "ja": "O NF4CHRはキャラクタデバイス特殊ファイルを指定します。"
    },
    {
      "indent": 3,
      "text": "o NF4LNK designates a symbolic link.",
      "ja": "O NF4LNKは、シンボリックリンクを指定します。"
    },
    {
      "indent": 3,
      "text": "o NF4SOCK designates a named socket special file.",
      "ja": "O NF4SOCKは、名前付きソケット特殊ファイルを指定します。"
    },
    {
      "indent": 3,
      "text": "o NF4FIFO designates a fifo special file.",
      "ja": "O NF4FIFOは、FIFO特殊ファイルを指定します。"
    },
    {
      "indent": 3,
      "text": "o NF4ATTRDIR designates a named attribute directory.",
      "ja": "O NF4ATTRDIRは、名前の属性ディレクトリを指定します。"
    },
    {
      "indent": 3,
      "text": "o NF4NAMEDATTR designates a named attribute.",
      "ja": "O NF4NAMEDATTRは、名前の属性を指定します。"
    },
    {
      "indent": 3,
      "text": "Within the explanatory text and operation descriptions, the following phrases will be used with the meanings given below:",
      "ja": "説明文と動作説明の中に、以下の語句を以下に示す意味で使用されます。"
    },
    {
      "indent": 3,
      "text": "o The phrase \"is a directory\" means that the object's type attribute is NF4DIR or NF4ATTRDIR.",
      "ja": "O句は、オブジェクトのtype属性がNF4DIRまたはNF4ATTRDIRであることを意味し、「ディレクトリです」。"
    },
    {
      "indent": 3,
      "text": "o The phrase \"is a special file\" means that the object's type attribute is NF4BLK, NF4CHR, NF4SOCK, or NF4FIFO.",
      "ja": "フレーズは「特別なファイルである」Oオブジェクトのtype属性がNF4BLK、NF4CHR、NF4SOCK、またはNF4FIFOであることを意味します。"
    },
    {
      "indent": 3,
      "text": "o The phrases \"is an ordinary file\" and \"is a regular file\" mean that the object's type attribute is NF4REG or NF4NAMEDATTR.",
      "ja": "フレーズO「普通のファイルである」と、オブジェクトのtype属性がNF4REGまたはNF4NAMEDATTRであることを意味し、「通常のファイルです」。"
    },
    {
      "indent": 0,
      "text": "5.8.1.3. Attribute 2: fh_expire_type",
      "section_title": true,
      "ja": "5.8.1.3。項目2：fh_expire_type"
    },
    {
      "indent": 3,
      "text": "Server uses this to specify filehandle expiration behavior to the client. See Section 4 for additional description.",
      "ja": "サーバーは、クライアントにファイルハンドルの有効期限の動作を指定するために、これを使用しています。追加の説明については、セクション4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8.1.4. Attribute 3: change",
      "section_title": true,
      "ja": "5.8.1.4。属性3：変更"
    },
    {
      "indent": 3,
      "text": "A value created by the server that the client can use to determine if file data, directory contents, or attributes of the object have been modified. The server may return the object's time_metadata attribute for this attribute's value, but only if the file system object cannot be updated more frequently than the resolution of time_metadata.",
      "ja": "クライアントは、ファイルデータ、ディレクトリの内容、またはオブジェクトの属性が変更されているかどうかを判断するために使用することができ、サーバによって作成された値。サーバーはなく、ファイル・システム・オブジェクトがtime_metadataの解像度よりも頻繁に更新することができない場合にのみ、この属性の値のオブジェクトのtime_metadata属性を返すことがあります。"
    },
    {
      "indent": 0,
      "text": "5.8.1.5. Attribute 4: size",
      "section_title": true,
      "ja": "5.8.1.5。属性4：サイズ"
    },
    {
      "indent": 3,
      "text": "The size of the object in bytes.",
      "ja": "バイト内のオブジェクトのサイズ。"
    },
    {
      "indent": 0,
      "text": "5.8.1.6. Attribute 5: link_support",
      "section_title": true,
      "ja": "5.8.1.6。属性5：link_support"
    },
    {
      "indent": 3,
      "text": "TRUE, if the object's file system supports hard links.",
      "ja": "TRUE、オブジェクトのファイルシステムはハードリンクをサポートしている場合。"
    },
    {
      "indent": 0,
      "text": "5.8.1.7. Attribute 6: symlink_support",
      "section_title": true,
      "ja": "5.8.1.7。属性6：symlink_support"
    },
    {
      "indent": 3,
      "text": "TRUE, if the object's file system supports symbolic links.",
      "ja": "TRUE、オブジェクトのファイルシステムがシンボリックリンクをサポートしている場合。"
    },
    {
      "indent": 0,
      "text": "5.8.1.8. Attribute 7: named_attr",
      "section_title": true,
      "ja": "5.8.1.8。 7属性：named_attr"
    },
    {
      "indent": 3,
      "text": "TRUE, if this object has named attributes. In other words, object has a non-empty named attribute directory.",
      "ja": "TRUE、このオブジェクトが属性を指名した場合。つまり、オブジェクトが空でない名前の属性ディレクトリを持っています。"
    },
    {
      "indent": 0,
      "text": "5.8.1.9. Attribute 8: fsid",
      "section_title": true,
      "ja": "5.8.1.9。属性8：ブローチ"
    },
    {
      "indent": 3,
      "text": "Unique file system identifier for the file system holding this object. The fsid attribute has major and minor components, each of which are of data type uint64_t.",
      "ja": "このオブジェクトを保持しているファイルシステムのためのユニークなファイルシステム識別子。 FSID属性は、データ・タイプuint64_tをのあるそれぞれの、メジャーとマイナーのコンポーネントがあります。"
    },
    {
      "indent": 0,
      "text": "5.8.1.10. Attribute 9: unique_handles",
      "section_title": true,
      "ja": "5.8.1.10。属性9：unique_handles"
    },
    {
      "indent": 3,
      "text": "TRUE, if two distinct filehandles are guaranteed to refer to two different file system objects.",
      "ja": "TRUE、二つの異なるファイルハンドルが2つの異なるファイル・システム・オブジェクトを参照することが保証されています。"
    },
    {
      "indent": 0,
      "text": "5.8.1.11. Attribute 10: lease_time",
      "section_title": true,
      "ja": "5.8.1.11。属性10：lease_time"
    },
    {
      "indent": 3,
      "text": "Duration of the lease at server in seconds.",
      "ja": "秒で、サーバーのリース期間。"
    },
    {
      "indent": 0,
      "text": "5.8.1.12. Attribute 11: rdattr_error",
      "section_title": true,
      "ja": "5.8.1.12。属性11：rdattr_error"
    },
    {
      "indent": 3,
      "text": "Error returned from an attempt to retrieve attributes during a READDIR operation.",
      "ja": "エラーがREADDIR操作中に属性を取得しようとする試みから返されました。"
    },
    {
      "indent": 0,
      "text": "5.8.1.13. Attribute 19: filehandle",
      "section_title": true,
      "ja": "5.8.1.13。属性19：ファイルハンドル"
    },
    {
      "indent": 3,
      "text": "The filehandle of this object (primarily for READDIR requests).",
      "ja": "（主にREADDIR要求のための）このオブジェクトのファイルハンドル。"
    },
    {
      "indent": 0,
      "text": "5.8.1.14. Attribute 75: suppattr_exclcreat",
      "section_title": true,
      "ja": "5.8.1.14。属性75：suppattr_exclcreat"
    },
    {
      "indent": 3,
      "text": "The bit vector that would set all REQUIRED and RECOMMENDED attributes that are supported by the EXCLUSIVE4_1 method of file creation via the OPEN operation. The scope of this attribute applies to all objects with a matching fsid.",
      "ja": "OPEN操作を介したファイル作成のEXCLUSIVE4_1方法でサポートされているすべての必須および推奨の属性を設定しますビットベクトル。この属性の範囲は、一致するFSIDを持つすべてのオブジェクトに適用されます。"
    },
    {
      "indent": 0,
      "text": "5.8.2. Definitions of Uncategorized RECOMMENDED Attributes",
      "section_title": true,
      "ja": "5.8.2. 未分類の定義は属性を推奨しました"
    },
    {
      "indent": 3,
      "text": "The definitions of most of the RECOMMENDED attributes follow. Collections that share a common category are defined in other sections.",
      "ja": "推奨属性のほとんどの定義は以下の通り。一般的なカテゴリを共有するコレクションは、他のセクションで定義されています。"
    },
    {
      "indent": 0,
      "text": "5.8.2.1. Attribute 14: archive",
      "section_title": true,
      "ja": "5.8.2.1。属性14：アーカイブ"
    },
    {
      "indent": 3,
      "text": "TRUE, if this file has been archived since the time of last modification (deprecated in favor of time_backup).",
      "ja": "TRUE、このファイルは（time_backupの非推奨）最終更新時刻以降にアーカイブされている場合。"
    },
    {
      "indent": 0,
      "text": "5.8.2.2. Attribute 15: cansettime",
      "section_title": true,
      "ja": "5.8.2.2。属性15：cansettime"
    },
    {
      "indent": 3,
      "text": "TRUE, if the server is able to change the times for a file system object as specified in a SETATTR operation.",
      "ja": "TRUE、SETATTR操作に指定されているサーバーは、ファイル・システム・オブジェクトのための時間を変更することができる場合。"
    },
    {
      "indent": 0,
      "text": "5.8.2.3. Attribute 16: case_insensitive",
      "section_title": true,
      "ja": "5.8.2.3。属性16：CASE_INSENSITIVE"
    },
    {
      "indent": 3,
      "text": "TRUE, if file name comparisons on this file system are case insensitive.",
      "ja": "TRUE、このファイルシステム上のファイル名の比較は大文字と小文字が区別されます。"
    },
    {
      "indent": 0,
      "text": "5.8.2.4. Attribute 17: case_preserving",
      "section_title": true,
      "ja": "5.8.2.4。属性17：case_preserving"
    },
    {
      "indent": 3,
      "text": "TRUE, if file name case on this file system is preserved.",
      "ja": "このファイルシステム上のファイル名のケースが保存されている場合、TRUE。"
    },
    {
      "indent": 0,
      "text": "5.8.2.5. Attribute 60: change_policy",
      "section_title": true,
      "ja": "5.8.2.5。属性60：change_policy"
    },
    {
      "indent": 3,
      "text": "A value created by the server that the client can use to determine if some server policy related to the current file system has been subject to change. If the value remains the same, then the client can be sure that the values of the attributes related to fs location and the fss_type field of the fs_status attribute have not changed. On the other hand, a change in this value does necessarily imply a change in policy. It is up to the client to interrogate the server to determine if some policy relevant to it has changed. See Section 3.3.6 for details.",
      "ja": "クライアントは、現在のファイルシステムに関連するいくつかのサーバー・ポリシーが変更されることとなっているかどうかを判断するために使用することができ、サーバによって作成された値。値が同じままである場合、クライアントは、FSの場所とfs_status属性のfss_typeフィールドに関連する属性の値が変更されていないことを確認することができます。一方、この値の変化は、必ずしも政策の変更を意味するものではありません。それは、それに関連するいくつかのポリシーが変更されているかどうかを判断するために、サーバーを調べるために、クライアント次第です。詳細については、3.3.6項を参照してください。"
    },
    {
      "indent": 3,
      "text": "This attribute MUST change when the value returned by the fs_locations or fs_locations_info attribute changes, when a file system goes from read-only to writable or vice versa, or when the allowable set of security flavors for the file system or any part thereof is changed.",
      "ja": "fs_位置によって、または属性の変更fs_locations_info返された値は、ファイルシステムは読み取り専用からなるとき書き込み可能またはその逆、または時にファイルシステムまたはその変更された一部のセキュリティ風味の許容セットするときに、この属性は変更する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.8.2.6. Attribute 18: chown_restricted",
      "section_title": true,
      "ja": "5.8.2.6。属性18：chown_restricted"
    },
    {
      "indent": 3,
      "text": "If TRUE, the server will reject any request to change either the owner or the group associated with a file if the caller is not a privileged user (for example, \"root\" in UNIX operating environments or, in Windows 2000, the \"Take Ownership\" privilege).",
      "ja": "TRUEの場合、発信者は、例えば（特権ユーザでない場合、サーバはUNIXオペレーティング環境では、所有者またはファイルに関連付けられたグループのいずれかを変更するには、「ルート」のいずれかの要求を拒否しますか、Windows 2000では、「所有権の取得します「特権）。"
    },
    {
      "indent": 0,
      "text": "5.8.2.7. Attribute 20: fileid",
      "section_title": true,
      "ja": "5.8.2.7。属性20：FILEID"
    },
    {
      "indent": 3,
      "text": "A number uniquely identifying the file within the file system.",
      "ja": "一意のファイルシステム内のファイルを識別するための番号。"
    },
    {
      "indent": 0,
      "text": "5.8.2.8. Attribute 21: files_avail",
      "section_title": true,
      "ja": "5.8.2.8。属性21：files_avail"
    },
    {
      "indent": 3,
      "text": "File slots available to this user on the file system containing this object -- this should be the smallest relevant limit.",
      "ja": "このオブジェクトを含むファイルシステム上でこのユーザが利用可能なファイル・スロット - これは最も小さい関連限界であるべきです。"
    },
    {
      "indent": 0,
      "text": "5.8.2.9. Attribute 22: files_free",
      "section_title": true,
      "ja": "5.8.2.9。属性22：files_free"
    },
    {
      "indent": 3,
      "text": "Free file slots on the file system containing this object -- this should be the smallest relevant limit.",
      "ja": "このオブジェクトを含むファイルシステム上の無料のファイルスロットは - これは、最小の関連する制限する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.8.2.10. Attribute 23: files_total",
      "section_title": true,
      "ja": "5.8.2.10。属性23：files_total"
    },
    {
      "indent": 3,
      "text": "Total file slots on the file system containing this object.",
      "ja": "このオブジェクトを含むファイルシステム上のファイルの総スロット。"
    },
    {
      "indent": 0,
      "text": "5.8.2.11. Attribute 76: fs_charset_cap",
      "section_title": true,
      "ja": "5.8.2.11。属性76：fs_charset_cap"
    },
    {
      "indent": 3,
      "text": "Character set capabilities for this file system. See Section 14.4.",
      "ja": "文字は、このファイル・システムの機能を設定します。 14.4節を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8.2.12. Attribute 24: fs_locations",
      "section_title": true,
      "ja": "5.8.2.12。属性24：fs_位置"
    },
    {
      "indent": 3,
      "text": "Locations where this file system may be found. If the server returns NFS4ERR_MOVED as an error, this attribute MUST be supported. See Section 11.9 for more details.",
      "ja": "このファイルシステムが見つけることができる場所。サーバがエラーとしてNFS4ERR_MOVEDを返す場合、この属性をサポートしなければなりません。詳細については、セクション11.9を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8.2.13. Attribute 67: fs_locations_info",
      "section_title": true,
      "ja": "5.8.2.13。 67属性：fs_locations_info"
    },
    {
      "indent": 3,
      "text": "Full function file system location. See Section 11.10 for more details.",
      "ja": "フル機能のファイルシステムの場所。詳細は、11.10項を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8.2.14. Attribute 61: fs_status",
      "section_title": true,
      "ja": "5.8.2.14。属性61：fs_status"
    },
    {
      "indent": 3,
      "text": "Generic file system type information. See Section 11.11 for more details.",
      "ja": "一般的なファイルシステムの情報を入力します。詳細はセクション11.11を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8.2.15. Attribute 25: hidden",
      "section_title": true,
      "ja": "5.8.2.15。属性25：隠されました"
    },
    {
      "indent": 3,
      "text": "TRUE, if the file is considered hidden with respect to the Windows API.",
      "ja": "TRUE、ファイルがWindows APIに関して隠されたとみなされた場合。"
    },
    {
      "indent": 0,
      "text": "5.8.2.16. Attribute 26: homogeneous",
      "section_title": true,
      "ja": "5.8.2.16。属性26：均質"
    },
    {
      "indent": 3,
      "text": "TRUE, if this object's file system is homogeneous; i.e., all objects in the file system (all objects on the server with the same fsid) have common values for all per-file-system attributes.",
      "ja": "TRUE、このオブジェクトのファイルシステムが均一である場合。すなわち、ファイルシステム内のすべてのオブジェクト（同じFSIDを使用してサーバ上のすべてのオブジェクト）は、すべての単位のファイル・システムの属性について共通の値を有しています。"
    },
    {
      "indent": 0,
      "text": "5.8.2.17. Attribute 27: maxfilesize",
      "section_title": true,
      "ja": "5.8.2.17。属性27：MAXFILESIZE"
    },
    {
      "indent": 3,
      "text": "Maximum supported file size for the file system of this object.",
      "ja": "このオブジェクトのファイルシステムのサポートされる最大ファイルサイズ。"
    },
    {
      "indent": 0,
      "text": "5.8.2.18. Attribute 28: maxlink",
      "section_title": true,
      "ja": "5.8.2.18。属性28：maxlink"
    },
    {
      "indent": 3,
      "text": "Maximum number of links for this object.",
      "ja": "このオブジェクトのためのリンクの最大数。"
    },
    {
      "indent": 0,
      "text": "5.8.2.19. Attribute 29: maxname",
      "section_title": true,
      "ja": "5.8.2.19。属性29：MAXNAME"
    },
    {
      "indent": 3,
      "text": "Maximum file name size supported for this object.",
      "ja": "このオブジェクトに対してサポートされている最大ファイル名サイズ。"
    },
    {
      "indent": 0,
      "text": "5.8.2.20. Attribute 30: maxread",
      "section_title": true,
      "ja": "5.8.2.20。属性30：maxread"
    },
    {
      "indent": 3,
      "text": "Maximum amount of data the READ operation will return for this object.",
      "ja": "データの最大量は、READ操作は、このオブジェクトのために返されます。"
    },
    {
      "indent": 0,
      "text": "5.8.2.21. Attribute 31: maxwrite",
      "section_title": true,
      "ja": "5.8.2.21。属性31：maxwrite"
    },
    {
      "indent": 3,
      "text": "Maximum amount of data the WRITE operation will accept for this object. This attribute SHOULD be supported if the file is writable. Lack of this attribute can lead to the client either wasting bandwidth or not receiving the best performance.",
      "ja": "データの最大量は、WRITE操作は、このオブジェクトのために受け入れます。ファイルが書き込み可能である場合、この属性はサポートされる必要があります。この属性の欠如は、いずれかの帯域幅を浪費や最高のパフォーマンスを受けていないクライアントにつながることができます。"
    },
    {
      "indent": 0,
      "text": "5.8.2.22. Attribute 32: mimetype",
      "section_title": true,
      "ja": "5.8.2.22。属性32：MIMEタイプ"
    },
    {
      "indent": 3,
      "text": "MIME body type/subtype of this object.",
      "ja": "このオブジェクトのMIMEボディタイプ/サブタイプ。"
    },
    {
      "indent": 0,
      "text": "5.8.2.23. Attribute 55: mounted_on_fileid",
      "section_title": true,
      "ja": "5.8.2.23。属性55：mounted_on_fileid"
    },
    {
      "indent": 3,
      "text": "Like fileid, but if the target filehandle is the root of a file system, this attribute represents the fileid of the underlying directory.",
      "ja": "対象のファイルハンドルは、ファイルシステムのルートである場合FILEID似ていますが、この属性は、基礎となるディレクトリのFILEIDを表します。"
    },
    {
      "indent": 3,
      "text": "UNIX-based operating environments connect a file system into the namespace by connecting (mounting) the file system onto the existing file object (the mount point, usually a directory) of an existing file system. When the mount point's parent directory is read via an API like readdir(), the return results are directory entries, each with a component name and a fileid. The fileid of the mount point's directory entry will be different from the fileid that the stat() system call returns. The stat() system call is returning the fileid of the root of the mounted file system, whereas readdir() is returning the fileid that stat() would have returned before any file systems were mounted on the mount point.",
      "ja": "UNIXベースのオペレーティング環境は、既存のファイルシステムの既存のファイル・オブジェクト（マウントポイント、通常はディレクトリ）に（実装に）ファイル・システムを接続することによって、名前空間内のファイル・システムを接続します。マウントポイントの親ディレクトリがreaddirのように（）APIを介して読み出された場合、戻り結果がディレクトリエントリ、コンポーネント名とFILEIDとそれぞれ。マウントポイントのディレクトリエントリのFILEIDはFILEIDのstat（）システムコールが戻るとは異なります。 STAT（readdirのに対し、（）システムコール）が、マウントされたファイルシステムのルートのFILEIDを返すには、すべてのファイルシステムをマウントポイントにマウントされた前のstat（）が戻ってきたでしょうFILEIDを返しています。"
    },
    {
      "indent": 3,
      "text": "Unlike NFSv3, NFSv4.1 allows a client's LOOKUP request to cross other file systems. The client detects the file system crossing whenever the filehandle argument of LOOKUP has an fsid attribute different from that of the filehandle returned by LOOKUP. A UNIX-based client will consider this a \"mount point crossing\". UNIX has a legacy scheme for allowing a process to determine its current working directory. This relies on readdir() of a mount point's parent and stat() of the mount point returning fileids as previously described. The mounted_on_fileid attribute corresponds to the fileid that readdir() would have returned as described previously.",
      "ja": "NFSv3のとは異なり、NFSv4.1は、クライアントのLOOKUP要求は他のファイルシステムを横断することができます。 LOOKUPのファイルハンドル引数はFSIDを持っている時はいつでも、クライアントは、ファイル・システムの交差を検出しLOOKUPで返されるファイルハンドルとは異なる属性。 UNIXベースのクライアントは、この「マウントポイントの交差点」を検討します。 UNIXは、現在の作業ディレクトリを決定するためのプロセスを可能にするための従来の方式を採用しています。先に述べたように、これはfileidsを返すマウントポイントのマウントポイントの親とのstat（）ののreaddir（）に依存しています。 mounted_on_fileid属性は、前述のように（）を返すはずREADDIR FILEIDに相当します。"
    },
    {
      "indent": 3,
      "text": "While the NFSv4.1 client could simply fabricate a fileid corresponding to what mounted_on_fileid provides (and if the server does not support mounted_on_fileid, the client has no choice), there is a risk that the client will generate a fileid that conflicts with one that is already assigned to another object in the file system. Instead, if the server can provide the mounted_on_fileid, the potential for client operational problems in this area is eliminated.",
      "ja": "NFSv4.1のクライアントは、単に提供（およびサーバがmounted_on_fileidをサポートしていない場合、クライアントは選択の余地がありません）何mounted_on_fileidに対応FILEIDを作ることもできますが、クライアントである1と競合FILEIDを発生するおそれがありますすでにファイルシステム内の別のオブジェクトに割り当てられています。サーバがmounted_on_fileidを提供できるかどう代わりに、この分野でのクライアントの動作上の問題の可能性が排除されます。"
    },
    {
      "indent": 3,
      "text": "If the server detects that there is no mounted point at the target file object, then the value for mounted_on_fileid that it returns is the same as that of the fileid attribute.",
      "ja": "サーバは、対象ファイルオブジェクトで何のマウントポイントが存在しないことを検出した場合、それが返すことmounted_on_fileidの値がFILEID属性と同じです。"
    },
    {
      "indent": 3,
      "text": "The mounted_on_fileid attribute is RECOMMENDED, so the server SHOULD provide it if possible, and for a UNIX-based server, this is straightforward. Usually, mounted_on_fileid will be requested during a READDIR operation, in which case it is trivial (at least for UNIX-based servers) to return mounted_on_fileid since it is equal to the fileid of a directory entry returned by readdir(). If mounted_on_fileid is requested in a GETATTR operation, the server should obey an invariant that has it returning a value that is equal to the file object's entry in the object's parent directory, i.e., what readdir() would have returned. Some operating environments allow a series of two or more file systems to be mounted onto a single mount point. In this case, for the server to obey the aforementioned invariant, it will need to find the base mount point, and not the intermediate mount points.",
      "ja": "mounted_on_fileid属性が推奨されているので、可能な場合、サーバはそれを提供すべきである、とUNIXベースのサーバーのために、これは簡単です。それがREADDIR（で返されるディレクトリエントリのFILEIDに等しいので、通常、mounted_on_fileid）がmounted_on_fileidを返すために（少なくともUNIXベースのサーバーのために）それは簡単です、その場合には、READDIR操作中に要求されます。 mounted_on_fileidがGETATTR操作で要求された場合、サーバはそれがすなわち、何のreaddir（）戻っているだろう、オブジェクトの親ディレクトリ内のファイルオブジェクトのエントリに等しい値を返す持つ不変に従わなければなりません。いくつかの動作環境は、二つ以上のファイル・システムのシリーズは、単一のマウントポイントにマウントすることができます。この場合は、サーバーのための前述の不変に従うように、それがベースマウントポイントを見つける必要があるでしょうし、中間ではないマウントポイントを。"
    },
    {
      "indent": 0,
      "text": "5.8.2.24. Attribute 34: no_trunc",
      "section_title": true,
      "ja": "5.8.2.24。属性34：no_trunc"
    },
    {
      "indent": 3,
      "text": "If this attribute is TRUE, then if the client uses a file name longer than name_max, an error will be returned instead of the name being truncated.",
      "ja": "この属性がTRUEの場合、クライアントが長いNAME_MAXよりファイル名を使用している場合、エラーは名前が切り捨てられるのではなく、返されます。"
    },
    {
      "indent": 0,
      "text": "5.8.2.25. Attribute 35: numlinks",
      "section_title": true,
      "ja": "5.8.2.25。属性35：numlinks"
    },
    {
      "indent": 3,
      "text": "Number of hard links to this object.",
      "ja": "このオブジェクトへのハードリンクの数。"
    },
    {
      "indent": 0,
      "text": "5.8.2.26. Attribute 36: owner",
      "section_title": true,
      "ja": "5.8.2.26。属性36：オーナー"
    },
    {
      "indent": 3,
      "text": "The string name of the owner of this object.",
      "ja": "このオブジェクトの所有者の文字列名。"
    },
    {
      "indent": 0,
      "text": "5.8.2.27. Attribute 37: owner_group",
      "section_title": true,
      "ja": "5.8.2.27。 37属性：owner_group"
    },
    {
      "indent": 3,
      "text": "The string name of the group ownership of this object.",
      "ja": "このオブジェクトのグループ所有権の文字列名。"
    },
    {
      "indent": 0,
      "text": "5.8.2.28. Attribute 38: quota_avail_hard",
      "section_title": true,
      "ja": "5.8.2.28。属性38：quota_avail_hard"
    },
    {
      "indent": 3,
      "text": "The value in bytes that represents the amount of additional disk space beyond the current allocation that can be allocated to this file or directory before further allocations will be refused. It is understood that this space may be consumed by allocations to other files or directories.",
      "ja": "さらに配分する前に、このファイルまたはディレクトリに割り当てることができ、現在の割り当てを超える追加のディスク・スペースの量を表し、バイト単位の値が拒否されます。このスペースは、他のファイルまたはディレクトリへの割り当てによって消費されてもよいことが理解されます。"
    },
    {
      "indent": 0,
      "text": "5.8.2.29. Attribute 39: quota_avail_soft",
      "section_title": true,
      "ja": "5.8.2.29。属性39：quota_avail_soft"
    },
    {
      "indent": 3,
      "text": "The value in bytes that represents the amount of additional disk space that can be allocated to this file or directory before the user may reasonably be warned. It is understood that this space may be consumed by allocations to other files or directories though there is a rule as to which other files or directories.",
      "ja": "ユーザー前にこのファイルまたはディレクトリに割り当てることができ、追加のディスク・スペースの量を表しバイト単位の値が合理的に警告されることがあります。他のどのファイルやディレクトリのようルールがあるが、このスペースは、他のファイルやディレクトリへの割り当てによって消費されてもよいことが理解されます。"
    },
    {
      "indent": 0,
      "text": "5.8.2.30. Attribute 40: quota_used",
      "section_title": true,
      "ja": "5.8.2.30。属性40：QUOTA_USED"
    },
    {
      "indent": 3,
      "text": "The value in bytes that represents the amount of disk space used by this file or directory and possibly a number of other similar files or directories, where the set of \"similar\" meets at least the criterion that allocating space to any file or directory in the set will reduce the \"quota_avail_hard\" of every other file or directory in the set.",
      "ja": "「類似」のセットは、少なくとも基準を満たす可能性がこのファイルまたはディレクトリおよび他の類似のファイルまたはディレクトリの数によって使用されるディスク・スペースの量を表すバイトの値その中の任意のファイルやディレクトリにスペースを割り当てますセットは、セット内の他のすべてのファイルやディレクトリの「quota_avail_hard」を削減します。"
    },
    {
      "indent": 3,
      "text": "Note that there may be a number of distinct but overlapping sets of files or directories for which a quota_used value is maintained, e.g., \"all files with a given owner\", \"all files with a given group owner\", etc. The server is at liberty to choose any of those sets when providing the content of the quota_used attribute, but should do so in a repeatable way. The rule may be configured per file system or may be \"choose the set with the smallest quota\".",
      "ja": "サーバーは例えば、「特定の所有者を持つすべてのファイル」、「与えられたグループの所有者であるすべてのファイル」など、QUOTA_USED値が維持されているファイルやディレクトリの異なるが重なり合うセットの数があるかもしれないことに注意してくださいQUOTA_USED属性のコンテンツを提供する際に自由にそれらのセットのいずれかを選択することが、再現可能な方法で行う必要があります。ルールは、ファイルシステムごとに設定してもよいし、「最小のクォータでセットを選択」であってもよいです。"
    },
    {
      "indent": 0,
      "text": "5.8.2.31. Attribute 41: rawdev",
      "section_title": true,
      "ja": "5.8.2.31。 41属性：rawdev"
    },
    {
      "indent": 3,
      "text": "Raw device number of file of type NF4BLK or NF4CHR. The device number is split into major and minor numbers. If the file's type attribute is not NF4BLK or NF4CHR, the value returned SHOULD NOT be considered useful.",
      "ja": "タイプNF4BLKまたはNF4CHRのファイルの生のデバイス番号。デバイス番号は、メジャーとマイナー番号に分割されます。ファイルのtype属性がNF4BLKかNF4CHRされていない場合、戻り値は有用であるとみなされるべきではありません。"
    },
    {
      "indent": 0,
      "text": "5.8.2.32. Attribute 42: space_avail",
      "section_title": true,
      "ja": "5.8.2.32。属性42：space_avail"
    },
    {
      "indent": 3,
      "text": "Disk space in bytes available to this user on the file system containing this object -- this should be the smallest relevant limit.",
      "ja": "これは、最小の関連限界であるべき - このオブジェクトを含むファイルシステム上でこのユーザーに利用可能なバイト単位のディスク容量。"
    },
    {
      "indent": 0,
      "text": "5.8.2.33. Attribute 43: space_free",
      "section_title": true,
      "ja": "5.8.2.33。属性43：space_free"
    },
    {
      "indent": 3,
      "text": "Free disk space in bytes on the file system containing this object -- this should be the smallest relevant limit.",
      "ja": "これは、最小の関連限界であるべき - このオブジェクトを含むファイルシステム上のバイト単位でのディスク空き容量。"
    },
    {
      "indent": 0,
      "text": "5.8.2.34. Attribute 44: space_total",
      "section_title": true,
      "ja": "5.8.2.34。属性44：space_total"
    },
    {
      "indent": 3,
      "text": "Total disk space in bytes on the file system containing this object.",
      "ja": "このオブジェクトを含むファイルシステム上のバイト単位での総ディスク容量。"
    },
    {
      "indent": 0,
      "text": "5.8.2.35. Attribute 45: space_used",
      "section_title": true,
      "ja": "5.8.2.35。 45属性：space_used"
    },
    {
      "indent": 3,
      "text": "Number of file system bytes allocated to this object.",
      "ja": "このオブジェクトに割り当てられたファイルシステムのバイト数。"
    },
    {
      "indent": 0,
      "text": "5.8.2.36. Attribute 46: system",
      "section_title": true,
      "ja": "5.8.2.36。属性46：システム"
    },
    {
      "indent": 3,
      "text": "This attribute is TRUE if this file is a \"system\" file with respect to the Windows operating environment.",
      "ja": "このファイルは、Windowsの動作環境に関しては、「システム」ファイルである場合、この属性はTRUEです。"
    },
    {
      "indent": 0,
      "text": "5.8.2.37. Attribute 47: time_access",
      "section_title": true,
      "ja": "5.8.2.37。属性47：time_access"
    },
    {
      "indent": 3,
      "text": "The time_access attribute represents the time of last access to the object by a READ operation sent to the server. The notion of what is an \"access\" depends on the server's operating environment and/or the server's file system semantics. For example, for servers obeying Portable Operating System Interface (POSIX) semantics, time_access would be updated only by the READ and READDIR operations and not any of the operations that modify the content of the object [16], [17], [18]. Of course, setting the corresponding time_access_set attribute is another way to modify the time_access attribute.",
      "ja": "time_access属性がサーバーに送信されたREAD操作によってオブジェクトへの最後のアクセスの時間を表しています。 「アクセス」であるものの概念は、サーバの動作環境および/またはサーバのファイルシステムのセマンティクスに依存します。例えば、ポータブルオペレーティングシステムインタフェース（POSIX）のセマンティクスに従うサーバに対して、time_access読み取り専用とREADDIR操作によって更新されるとしないオブジェクトの内容を変更する操作のいずれか[16]、[17]、[18] 。もちろん、対応するtime_access_set属性を設定することtime_access属性を変更する別の方法です。"
    },
    {
      "indent": 3,
      "text": "Whenever the file object resides on a writable file system, the server should make its best efforts to record time_access into stable storage. However, to mitigate the performance effects of doing so, and most especially whenever the server is satisfying the read of the object's content from its cache, the server MAY cache access time updates and lazily write them to stable storage. It is also acceptable to give administrators of the server the option to disable time_access updates.",
      "ja": "ファイルオブジェクトが、書き込み可能なファイルシステム上に存在するたびに、サーバーは安定したストレージにtime_accessを記録するために最善の努力をする必要があります。しかし、そうすることのパフォーマンスへの影響を軽減するために、最も特に、サーバーがそのキャッシュからオブジェクトの内容の読み取りを満足されるたびに、サーバーは、アクセス時間の更新をキャッシュして、怠惰安定したストレージにそれらを書き込むことができます。サーバーの管理者はtime_access更新を無効にするオプションを与えることも可能です。"
    },
    {
      "indent": 0,
      "text": "5.8.2.38. Attribute 48: time_access_set",
      "section_title": true,
      "ja": "5.8.2.38。属性48：time_access_set"
    },
    {
      "indent": 3,
      "text": "Sets the time of last access to the object. SETATTR use only.",
      "ja": "オブジェクトへの最後のアクセスの時間を設定します。 SETATTRにのみ使用します。"
    },
    {
      "indent": 0,
      "text": "5.8.2.39. Attribute 49: time_backup",
      "section_title": true,
      "ja": "5.8.2.39。属性49：time_backup"
    },
    {
      "indent": 3,
      "text": "The time of last backup of the object.",
      "ja": "オブジェクトの最後のバックアップの時間。"
    },
    {
      "indent": 0,
      "text": "5.8.2.40. Attribute 50: time_create",
      "section_title": true,
      "ja": "5.8.2.40。属性50：time_create"
    },
    {
      "indent": 3,
      "text": "The time of creation of the object. This attribute does not have any relation to the traditional UNIX file attribute \"ctime\" or \"change time\".",
      "ja": "オブジェクトの作成の時間。この属性は、伝統的なUNIXファイル属性「CTIME」または「変更時間」とは関係ありません。"
    },
    {
      "indent": 0,
      "text": "5.8.2.41. Attribute 51: time_delta",
      "section_title": true,
      "ja": "5.8.2.41。属性51：TIME_DELTA"
    },
    {
      "indent": 3,
      "text": "Smallest useful server time granularity.",
      "ja": "最小の便利なサーバーの時間精度。"
    },
    {
      "indent": 0,
      "text": "5.8.2.42. Attribute 52: time_metadata",
      "section_title": true,
      "ja": "5.8.2.42。属性52：time_metadata"
    },
    {
      "indent": 3,
      "text": "The time of last metadata modification of the object.",
      "ja": "オブジェクトの最後のメタデータの変更の時間。"
    },
    {
      "indent": 0,
      "text": "5.8.2.43. Attribute 53: time_modify",
      "section_title": true,
      "ja": "5.8.2.43。属性53：time_modify"
    },
    {
      "indent": 3,
      "text": "The time of last modification to the object.",
      "ja": "オブジェクトへの最終更新時刻。"
    },
    {
      "indent": 0,
      "text": "5.8.2.44. Attribute 54: time_modify_set",
      "section_title": true,
      "ja": "5.8.2.44。属性54：time_modify_set"
    },
    {
      "indent": 3,
      "text": "Sets the time of last modification to the object. SETATTR use only.",
      "ja": "オブジェクトの最終更新時刻を設定します。 SETATTRにのみ使用します。"
    },
    {
      "indent": 0,
      "text": "5.9. Interpreting owner and owner_group",
      "section_title": true,
      "ja": "5.9. 解釈の所有者とowner_group"
    },
    {
      "indent": 3,
      "text": "The RECOMMENDED attributes \"owner\" and \"owner_group\" (and also users and groups within the \"acl\" attribute) are represented in terms of a UTF-8 string. To avoid a representation that is tied to a particular underlying implementation at the client or server, the use of the UTF-8 string has been chosen. Note that Section 6.1 of RFC 2624 [45] provides additional rationale. It is expected that the client and server will have their own local representation of owner and owner_group that is used for local storage or presentation to the end user. Therefore, it is expected that when these attributes are transferred between the client and server, the local representation is translated to a syntax of the form \"user@dns_domain\". This will allow for a client and server that do not use the same local representation the ability to translate to a common syntax that can be interpreted by both.",
      "ja": "推奨属性の「所有者」と「owner_group」（とも「ACL」属性内のユーザーとグループ）はUTF-8文字列で表現されています。クライアントまたはサーバーで特定の基本的な実装に結び付けられている表現を避けるために、UTF-8文字列の使用が選択されています。 RFC 2624のセクション6.1に注意してください[45]追加の理論的根拠を提供します。クライアントとサーバは、エンドユーザーにローカルストレージやプレゼンテーションのために使用されている所有者とowner_groupの独自のローカルな表現を持っていることが期待されます。したがって、これらの属性は、クライアントとサーバーの間で転送されたときに、地元の表現がフォーム「のuser @ dns_domain」の構文に翻訳されることが期待されます。これは、同じローカルな表現を両方によって解釈することができ、共通の構文に変換する機能を使用していないクライアントとサーバが可能になります。"
    },
    {
      "indent": 3,
      "text": "Similarly, security principals may be represented in different ways by different security mechanisms. Servers normally translate these representations into a common format, generally that used by local storage, to serve as a means of identifying the users corresponding to these security principals. When these local identifiers are translated to the form of the owner attribute, associated with files created by such principals, they identify, in a common format, the users associated with each corresponding set of security principals.",
      "ja": "同様に、セキュリティプリンシパルは、異なるセキュリティメカニズムにより異なる方法で表すことができます。サーバは、通常、これらのセキュリティプリンシパルに対応するユーザを識別する手段として機能するように、ローカル記憶装置によって使用される一般的こと、共通の形式にこれらの表現を翻訳します。これらのローカル識別子は、所有者属性の形式に変換されている場合は、そのようなプリンシパルで作成されたファイルに関連付けられている、彼らは、共通のフォーマットで、セキュリティプリンシパルの各対応するセットに関連付けられているユーザを識別します。"
    },
    {
      "indent": 3,
      "text": "The translation used to interpret owner and group strings is not specified as part of the protocol. This allows various solutions to be employed. For example, a local translation table may be consulted that maps a numeric identifier to the user@dns_domain syntax. A name service may also be used to accomplish the translation. A server may provide a more general service, not limited by any particular translation (which would only translate a limited set of possible strings) by storing the owner and owner_group attributes in local storage without any translation or it may augment a translation method by storing the entire string for attributes for which no translation is available while using the local representation for those cases in which a translation is available.",
      "ja": "所有者とグループの文字列を解釈するために使用される変換は、プロトコルの一部として指定されていません。これは、様々なソリューションを採用することができるようになります。たとえば、ローカルの変換テーブルはdns_domain構文@ユーザーに数値識別子をマップする参考にすることができます。ネームサービスは、翻訳を達成するために使用することができます。サーバは、所有者を格納することによって（唯一の可能な文字列の限られたセットを翻訳するであろう）は、任意の特定の翻訳によって限定されるものではなく、より一般的なサービスを提供することができるとowner_groupは、変換されずに、ローカルストレージの属性またはそれが格納することにより、翻訳方法を増強することができます翻訳が利用可能であるこれらの例のためのローカルな表現を使用しながら、何の翻訳が利用できないために属性の文字列全体。"
    },
    {
      "indent": 3,
      "text": "Servers that do not provide support for all possible values of the owner and owner_group attributes SHOULD return an error (NFS4ERR_BADOWNER) when a string is presented that has no translation, as the value to be set for a SETATTR of the owner, owner_group, or acl attributes. When a server does accept an owner or owner_group value as valid on a SETATTR (and similarly for the owner and group strings in an acl), it is promising to return that same string when a corresponding GETATTR is done. Configuration changes (including changes from the mapping of the string to the local representation) and ill-constructed name translations (those that contain aliasing) may make that promise impossible to honor. Servers should make appropriate efforts to avoid a situation in which these attributes have their values changed when no real change to ownership has occurred.",
      "ja": "所有者のすべての可能な値のためのサポートを提供し、文字列値は、所有者のSETATTRに設定すると、何の翻訳を持っていないが提示されている場合、エラー（NFS4ERR_BADOWNER）を返すべき属性をowner_groupないサーバー、owner_group、またはACL属性。サーバはSETATTRに有効な（および同様にACLの所有者とグループ文字列の）所有者またはowner_group値を受け入れない場合、対応するGETATTRが行われたときに同じ文字列を返すために有望です。悪い構築名翻訳（エイリアシングを含むもの）（ローカル表現への文字列のマッピングからの変更を含む）設定の変更は尊重するという約束を不可能にすることがあります。サーバは、これらの属性は、所有権への本当の変化が発生していないとき、その値が変更されていた状況を回避するための適切な努力をする必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"dns_domain\" portion of the owner string is meant to be a DNS domain name, for example, user@example.org. Servers should accept as valid a set of users for at least one domain. A server may treat other domains as having no valid translations. A more general service is provided when a server is capable of accepting users for multiple domains, or for all domains, subject to security constraints.",
      "ja": "所有者文字列の「dns_domain」の部分は、例えば、user@example.orgため、DNSドメイン名であることを意味しています。サーバーは、少なくとも1つのドメインに対するユーザーの有効なセットを受け入れる必要があります。サーバーは、有効な翻訳を持っていないとして、他のドメインを扱うことがあります。サーバが複数のドメインのために、またはセキュリティ制約の対象となるすべてのドメインのユーザを受け入れることができる場合に、より一般的なサービスが提供されます。"
    },
    {
      "indent": 3,
      "text": "In the case where there is no translation available to the client or server, the attribute value will be constructed without the \"@\". Therefore, the absence of the @ from the owner or owner_group attribute signifies that no translation was available at the sender and that the receiver of the attribute should not use that string as a basis for translation into its own internal format. Even though the attribute value cannot be translated, it may still be useful. In the case of a client, the attribute string may be used for local display of ownership.",
      "ja": "クライアントまたはサーバに利用可能な翻訳が存在しない場合には、属性値は「@」なしで構成されます。したがって、所有者またはowner_group属性から@の不在には翻訳が送信側で属性の受信機は、独自の内部形式に変換するための基礎として、その文字列を使用してはならないことを利用できなかったことを意味します。属性値が変換できないにもかかわらず、それはまだ有用である可能性があります。クライアントの場合、属性文字列は、所有権のローカル・ディスプレイのために使用することができます。"
    },
    {
      "indent": 3,
      "text": "To provide a greater degree of compatibility with NFSv3, which identified users and groups by 32-bit unsigned user identifiers and group identifiers, owner and group strings that consist of decimal numeric values with no leading zeros can be given a special interpretation by clients and servers that choose to provide such support. The receiver may treat such a user or group string as representing the same user as would be represented by an NFSv3 uid or gid having the corresponding numeric value. A server is not obligated to accept such a string, but may return an NFS4ERR_BADOWNER instead. To avoid this mechanism being used to subvert user and group translation, so that a client might pass all of the owners and groups in numeric form, a server SHOULD return an NFS4ERR_BADOWNER error when there is a valid translation for the user or owner designated in this way. In that case, the client must use the appropriate name@domain string and not the special form for compatibility.",
      "ja": "クライアントとサーバーによって特殊な解釈を与えることができる32ビットの符号なしのユーザ識別子とグループ識別子、所有者なし先行ゼロの10進数値から成るグループ列によってユーザおよびグループを同定NFSv3の、との互換性のより大きな程度を提供しますそれは、このようなサポートを提供することを選択しました。受信機は、NFSv3のUIDのまたは対応する数値を有するGIDによって表されるであろうと同じユーザを表すようなユーザまたはグループ列を扱うことができます。サーバーは、このような文字列を受け入れる義務はないが、代わりにNFS4ERR_BADOWNERを返すことがあります。この中で指定されたユーザーまたは所有者の有効な翻訳がある場合に、クライアントは数値形式で所有者とグループのすべてを渡すかもしれないように、ユーザーやグループの翻訳を破壊するために使用されているこのメカニズムを回避するために、サーバーはNFS4ERR_BADOWNERエラーを返すべきです仕方。その場合、クライアントは適切な名前@ドメイン文字列ではなく、互換性のための特別なフォームを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The owner string \"nobody\" may be used to designate an anonymous user, which will be associated with a file created by a security principal that cannot be mapped through normal means to the owner attribute. Users and implementations of NFSv4.1 SHOULD NOT use \"nobody\" to designate a real user whose access is not anonymous.",
      "ja": "所有者列「誰が」所有者属性に通常の手段を介してマッピングすることができないセキュリティプリンシパルによって作成されたファイルに関連付けられる匿名ユーザを指定するために使用することはできません。 NFSv4.1のユーザーと実装は、そのアクセス匿名でない実際のユーザーを指定するには、「誰」を使用しないべきではありません。"
    },
    {
      "indent": 0,
      "text": "5.10. Character Case Attributes",
      "section_title": true,
      "ja": "5.10. キャラクターケースの属性"
    },
    {
      "indent": 3,
      "text": "With respect to the case_insensitive and case_preserving attributes, each UCS-4 character (which UTF-8 encodes) can be mapped according to Appendix B.2 of RFC 3454 [19]. For general character handling and internationalization issues, see Section 14.",
      "ja": "CASE_INSENSITIVEとcase_preserving属性に対して、マッピングすることができる（UTF-8コードする）各UCS-4文字は、RFC 3454 [19]の付録B.2に記載の方法。一般的な文字の取り扱いと国際化の問題については、第14章を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.11. Directory Notification Attributes",
      "section_title": true,
      "ja": "5.11. ディレクトリ通知の属性"
    },
    {
      "indent": 3,
      "text": "As described in Section 18.39, the client can request a minimum delay for notifications of changes to attributes, but the server is free to ignore what the client requests. The client can determine in advance what notification delays the server will accept by sending a GETATTR operation for either or both of two directory notification attributes. When the client calls the GET_DIR_DELEGATION operation and asks for attribute change notifications, it should request notification delays that are no less than the values in the server-provided attributes.",
      "ja": "セクション18.39で説明したように、クライアントは属性への変更の通知のための最小遅延を要求することができますが、サーバーはどのクライアントの要求を無視して自由です。クライアントは、サーバーに2つのディレクトリ通知属性のいずれかまたは両方のためにGETATTR操作を送信することにより受け入れる遅らせる何の通知事前に決定することができます。クライアントがGET_DIR_DELEGATION操作を呼び出し、属性変更通知を要求するときは、サーバーが提供する属性の値よりも小さいません通知の遅延を要求しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.11.1. Attribute 56: dir_notif_delay",
      "section_title": true,
      "ja": "5.11.1. 属性56：dir_notif_delay"
    },
    {
      "indent": 3,
      "text": "The dir_notif_delay attribute is the minimum number of seconds the server will delay before notifying the client of a change to the directory's attributes.",
      "ja": "dir_notif_delay属性は、サーバーがディレクトリの属性に変更をクライアントに通知する前に遅延する秒数の最小値です。"
    },
    {
      "indent": 0,
      "text": "5.11.2. Attribute 57: dirent_notif_delay",
      "section_title": true,
      "ja": "5.11.2. 属性57：dirent_notif_delay"
    },
    {
      "indent": 3,
      "text": "The dirent_notif_delay attribute is the minimum number of seconds the server will delay before notifying the client of a change to a file object that has an entry in the directory.",
      "ja": "dirent_notif_delay属性は、サーバーがディレクトリ内にエントリを持つファイルオブジェクトへの変更をクライアントに通知する前に遅延する秒数の最小値です。"
    },
    {
      "indent": 0,
      "text": "5.12. pNFS Attribute Definitions",
      "section_title": true,
      "ja": "5.12.  pNFSのアトリビュート定義"
    },
    {
      "indent": 0,
      "text": "5.12.1. Attribute 62: fs_layout_type",
      "section_title": true,
      "ja": "5.12.1. 属性62：fs_layout_type"
    },
    {
      "indent": 3,
      "text": "The fs_layout_type attribute (see Section 3.3.13) applies to a file system and indicates what layout types are supported by the file system. When the client encounters a new fsid, the client SHOULD obtain the value for the fs_layout_type attribute associated with the new file system. This attribute is used by the client to determine if the layout types supported by the server match any of the client's supported layout types.",
      "ja": "fs_layout_type属性は、（セクション3.3.13を参照してください）ファイルシステムに適用され、レイアウトタイプがファイルシステムによってサポートされているかを示します。クライアントが新しいFSIDに遭遇すると、クライアントは新しいファイルシステムに関連するfs_layout_type属性の値を取得する必要があります。この属性は、サーバーでサポートされているレイアウトの種類は、クライアントのサポートレイアウトの種類のいずれかに一致するかどうかを判断するために、クライアントによって使用されます。"
    },
    {
      "indent": 0,
      "text": "5.12.2. Attribute 66: layout_alignment",
      "section_title": true,
      "ja": "5.12.2. 属性66：layout_alignment"
    },
    {
      "indent": 3,
      "text": "When a client holds layouts on files of a file system, the layout_alignment attribute indicates the preferred alignment for I/O to files on that file system. Where possible, the client should send READ and WRITE operations with offsets that are whole multiples of the layout_alignment attribute.",
      "ja": "クライアントは、ファイルシステムのファイルのレイアウトを保持している場合は、layout_alignment属性は、そのファイルシステム上のファイルへのI / Oの優先配置を示します。可能であれば、クライアントはlayout_alignment属性の全体の倍数オフセットで読み取りおよび書き込み操作を送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.12.3. Attribute 65: layout_blksize",
      "section_title": true,
      "ja": "5.12.3. 属性65：layout_blksize"
    },
    {
      "indent": 3,
      "text": "When a client holds layouts on files of a file system, the layout_blksize attribute indicates the preferred block size for I/O to files on that file system. Where possible, the client should send READ operations with a count argument that is a whole multiple of layout_blksize, and WRITE operations with a data argument of size that is a whole multiple of layout_blksize.",
      "ja": "クライアントは、ファイルシステムのファイルのレイアウトを保持している場合は、layout_blksize属性は、そのファイルシステム上のファイルへのI / Oのための好ましいブロックサイズを示しています。可能であれば、クライアントはlayout_blksizeの整数倍であるcount引数でREAD操作を送信し、layout_blksizeの整数倍であるサイズのデータ​​引数で操作を記述する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.12.4. Attribute 63: layout_hint",
      "section_title": true,
      "ja": "5.12.4. 属性63：layout_hint"
    },
    {
      "indent": 3,
      "text": "The layout_hint attribute (see Section 3.3.19) may be set on newly created files to influence the metadata server's choice for the file's layout. If possible, this attribute is one of those set in the initial attributes within the OPEN operation. The metadata server may choose to ignore this attribute. The layout_hint attribute is a subset of the layout structure returned by LAYOUTGET. For example, instead of specifying particular devices, this would be used to suggest the stripe width of a file. The server implementation determines which fields within the layout will be used.",
      "ja": "layout_hint属性（セクション3.3.19を参照）、ファイルのレイアウトのためのメタデータ・サーバの選択に影響を与えるために、新しく作成されたファイルに設定することができます。可能な場合、この属性はOPEN操作内の最初の属性に設定されたものの一つです。メタデータサーバはこの属性を無視することもできます。 layout_hint属性はLAYOUTGETによって返されたレイアウト構造のサブセットです。たとえば、代わりに特定のデバイスを指定するのは、これはファイルのストライプ幅を示唆するために使用されます。サーバの実装が使用されますレイアウト内のフィールドを決定します。"
    },
    {
      "indent": 0,
      "text": "5.12.5. Attribute 64: layout_type",
      "section_title": true,
      "ja": "5.12.5. 属性64：layout_type"
    },
    {
      "indent": 3,
      "text": "This attribute lists the layout type(s) available for a file. The value returned by the server is for informational purposes only. The client will use the LAYOUTGET operation to obtain the information needed in order to perform I/O, for example, the specific device information for the file and its layout.",
      "ja": "この属性は、ファイルのために利用可能なレイアウトのタイプ（複数可）を示しています。サーバから返された値は、情報提供のみを目的としています。クライアントは、例えば、I / Oを実行するために必要な情報を取得するために、ファイルとそのレイアウトのための特定のデバイス情報をLAYOUTGET操作を使用します。"
    },
    {
      "indent": 0,
      "text": "5.12.6. Attribute 68: mdsthreshold",
      "section_title": true,
      "ja": "5.12.6. 属性68：mdsthreshold"
    },
    {
      "indent": 3,
      "text": "This attribute is a server-provided hint used to communicate to the client when it is more efficient to send READ and WRITE operations to the metadata server or the data server. The two types of thresholds described are file size thresholds and I/O size thresholds. If a file's size is smaller than the file size threshold, data accesses SHOULD be sent to the metadata server. If an I/O request has a length that is below the I/O size threshold, the I/O SHOULD be sent to the metadata server. Each threshold type is specified separately for read and write.",
      "ja": "この属性は、メタデータ・サーバまたはデータ・サーバに読み取りおよび書き込み操作を送信する方が効率的であるときに、クライアントとの通信に使用されるサーバが提供するヒントです。説明しきい値の2種類が、ファイルサイズのしきい値とI / Oサイズの閾値です。ファイルのサイズは、ファイルサイズのしきい値よりも小さい場合は、データのアクセスは、メタデータサーバに送信する必要があります。 I / O要求は、I / Oサイズのしきい値を下回っている長さを持っている場合は、I / Oは、メタデータサーバに送信する必要があります。各しきい値タイプは、読み取りと書き込みのために個別に指定されています。"
    },
    {
      "indent": 3,
      "text": "The server MAY provide both types of thresholds for a file. If both file size and I/O size are provided, the client SHOULD reach or exceed both thresholds before sending its read or write requests to the data server. Alternatively, if only one of the specified thresholds is reached or exceeded, the I/O requests are sent to the metadata server.",
      "ja": "サーバーは、ファイルのしきい値の両方のタイプを提供することができます。ファイルサイズとI / Oサイズの両方が提供されている場合、クライアントは、データ・サーバへの読み込みまたは書き込み要求を送信する前に、両方のしきい値に達するか超えている必要があります。指定されたしきい値の一つだけに達するか超えた場合あるいは、I / O要求は、メタデータサーバに送信されます。"
    },
    {
      "indent": 3,
      "text": "For each threshold type, a value of zero indicates no READ or WRITE should be sent to the metadata server, while a value of all ones indicates that all READs or WRITEs should be sent to the metadata server.",
      "ja": "各閾値タイプについて、ゼロの値は、すべてのものの値がすべての読み取りまたは書き込みがメタデータサーバに送信されるべきであることを示している間はREADまたはWRITEは、メタデータサーバに送信されるべきではない示します。"
    },
    {
      "indent": 3,
      "text": "The attribute is available on a per-filehandle basis. If the current filehandle refers to a non-pNFS file or directory, the metadata server should return an attribute that is representative of the filehandle's file system. It is suggested that this attribute is queried as part of the OPEN operation. Due to dynamic system changes, the client should not assume that the attribute will remain constant for any specific time period; thus, it should be periodically refreshed.",
      "ja": "属性ごとのファイルハンドルベースで提供されています。現在のファイルハンドルが非pNFSのファイルまたはディレクトリを参照する場合は、メタデータサーバは、ファイルハンドルのファイルシステムの代表である属性を返す必要があります。この属性はOPEN操作の一部として照会されていることを示唆しています。動的なシステム変更のため、クライアントは、属性が任意の特定の時間のための一定のままであると仮定してはいけません。したがって、それは定期的に更新する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.13. Retention Attributes",
      "section_title": true,
      "ja": "5.13. 保持属性"
    },
    {
      "indent": 3,
      "text": "Retention is a concept whereby a file object can be placed in an immutable, undeletable, unrenamable state for a fixed or infinite duration of time. Once in this \"retained\" state, the file cannot be moved out of the state until the duration of retention has been reached.",
      "ja": "保持は、ファイルオブジェクトは、時間の固定または無限期間にわたって不変、削除不可、unrenamable状態にすることができる概念です。保持期間が達成されるまで、一度この「保持」状態で、ファイルは状態の外に移動することはできません。"
    },
    {
      "indent": 3,
      "text": "When retention is enabled, retention MUST extend to the data of the file, and the name of file. The server MAY extend retention to any other property of the file, including any subset of REQUIRED, RECOMMENDED, and named attributes, with the exceptions noted in this section.",
      "ja": "保持が有効になっている場合、保持は、ファイルのデータ、およびファイルの名前に拡張する必要があります。サーバーは、このセクションで述べた例外を除いて、すべてのREQUIREDのサブセット、推奨、およびという名前の属性を含む、ファイルの他のプロパティに保持を延長することができます。"
    },
    {
      "indent": 3,
      "text": "Servers MAY support or not support retention on any file object type.",
      "ja": "サーバーは、サポートしたり、任意のファイル・オブジェクト・タイプの保持をサポートしていないかもしれません。"
    },
    {
      "indent": 3,
      "text": "The five retention attributes are explained in the next subsections.",
      "ja": "5つの保持属性は、次のサブセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "5.13.1. Attribute 69: retention_get",
      "section_title": true,
      "ja": "5.13.1. 属性69：retention_get"
    },
    {
      "indent": 3,
      "text": "If retention is enabled for the associated file, this attribute's value represents the retention begin time of the file object. This attribute's value is only readable with the GETATTR operation and MUST NOT be modified by the SETATTR operation (Section 5.5). The value of the attribute consists of:",
      "ja": "保持が関連付けられているファイルに対して有効になっている場合は、この属性の値は保持がファイルオブジェクトの開始時刻を表します。この属性の値は、GETATTR操作でのみ読めるとSETATTR操作（5.5節）で変更してはいけません。属性の値は、で構成されています。"
    },
    {
      "indent": 3,
      "text": "const RET4_DURATION_INFINITE    = 0xffffffffffffffff;\nstruct retention_get4 {\n        uint64_t        rg_duration;\n        nfstime4        rg_begin_time<1>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The field rg_duration is the duration in seconds indicating how long the file will be retained once retention is enabled. The field rg_begin_time is an array of up to one absolute time value. If the array is zero length, no beginning retention time has been established, and retention is not enabled. If rg_duration is equal to RET4_DURATION_INFINITE, the file, once retention is enabled, will be retained for an infinite duration.",
      "ja": "フィールドrg_durationは、保持を有効にすると、ファイルが保存されますどのくらいの時間を示す秒単位の期間です。フィールドrg_begin_timeは、最大1時間の絶対値の配列です。配列の長さがゼロである場合、開始保持時間が確立されていない、と保持が有効になっていません。 rg_durationは、ファイルをRET4_DURATION_INFINITEに等しい場合は、保持を有効にすると、無限の期間のために保持されます。"
    },
    {
      "indent": 3,
      "text": "If (as soon as) rg_duration is zero, then rg_begin_time will be of zero length, and again, retention is not (no longer) enabled.",
      "ja": "rg_durationがゼロである（できるだけ早く）場合は、rg_begin_timeはゼロ長さでもないだろう、と再び、保持は（もはや）が有効ではありません。"
    },
    {
      "indent": 0,
      "text": "5.13.2. Attribute 70: retention_set",
      "section_title": true,
      "ja": "5.13.2. 属性70：retention_set"
    },
    {
      "indent": 3,
      "text": "This attribute is used to set the retention duration and optionally enable retention for the associated file object. This attribute is only modifiable via the SETATTR operation and MUST NOT be retrieved by the GETATTR operation (Section 5.5). This attribute corresponds to retention_get. The value of the attribute consists of:",
      "ja": "この属性は、保持期間を設定し、必要に応じて関連するファイルオブジェクトの保持を可能にするために使用されます。この属性は、SETATTR操作によってのみ変更可能であるとGETATTR操作（5.5節）によって取得してはなりません。この属性は、retention_getに対応しています。属性の値は、で構成されています。"
    },
    {
      "indent": 3,
      "text": "struct retention_set4 {\n        bool            rs_enable;\n        uint64_t        rs_duration<1>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the client sets rs_enable to TRUE, then it is enabling retention on the file object with the begin time of retention starting from the server's current time and date. The duration of the retention can also be provided if the rs_duration array is of length one. The duration is the time in seconds from the begin time of retention, and if set to RET4_DURATION_INFINITE, the file is to be retained forever. If retention is enabled, with no duration specified in either this SETATTR or a previous SETATTR, the duration defaults to zero seconds. The server MAY restrict the enabling of retention or the duration of retention on the basis of the ACE4_WRITE_RETENTION ACL permission.",
      "ja": "クライアントがTRUEにrs_enable設定した場合、それは、サーバーの現在の日付と時刻から始まる保持の開始時刻とファイルオブジェクトに保持を可能にしています。保持の持続時間もrs_durationアレイは長さが1である場合に提供することができます。期間は、保持の開始時からの秒単位の時間であり、RET4_DURATION_INFINITEに設定すると、ファイルは永久に保持されます。保持はこのSETATTRまたは前SETATTR、0秒に期間のデフォルトのいずれかに指定されていない期間で、有効になっている場合。サーバーはACE4_WRITE_RETENTION ACL許可に基づいて保持または保持の期間の有効化を制限することができます。"
    },
    {
      "indent": 3,
      "text": "The enabling of retention MUST NOT prevent the enabling of event-based retention or the modification of the retention_hold attribute.",
      "ja": "イベント・ベースの保存やretention_hold属性の変更の許可を妨げてはならない保持の有効化。"
    },
    {
      "indent": 3,
      "text": "The following rules apply to both the retention_set and retentevt_set attributes.",
      "ja": "次の規則がretention_setとretentevt_set属性の両方に適用されます。"
    },
    {
      "indent": 3,
      "text": "o As long as retention is not enabled, the client is permitted to decrease the duration.",
      "ja": "Oなどの長い保持が有効になっていないとして、クライアントは、継続時間を短くすることが許可されています。"
    },
    {
      "indent": 3,
      "text": "o The duration can always be set to an equal or higher value, even if retention is enabled. Note that once retention is enabled, the actual duration (as returned by the retention_get or retentevt_get attributes; see Section 5.13.1 or Section 5.13.3) is constantly counting down to zero (one unit per second), unless the duration was set to RET4_DURATION_INFINITE. Thus, it will not be possible for the client to precisely extend the duration on a file that has retention enabled.",
      "ja": "O期間は常に保持が有効になっていても、同等またはより高い値に設定することができます。 （retention_get又はretentevt_getによって返される属性、セクション5.13.1、または5.13.3節を参照）の保持を有効にすると、実際の期間は、その注意持続時間に設定した場合を除き、常にゼロ（毎秒単位）にカウントダウンされますRET4_DURATION_INFINITE。クライアントは正確に保持が有効になっているファイルに期間を延長するためにこのように、それはできません。"
    },
    {
      "indent": 3,
      "text": "o While retention is enabled, attempts to disable retention or decrease the retention's duration MUST fail with the error NFS4ERR_INVAL.",
      "ja": "保持が有効になっているまま、o、保持を無効にするか、エラーNFS4ERR_INVALで失敗しなければなりません保持の期間を減少しようとします。"
    },
    {
      "indent": 3,
      "text": "o If the principal attempting to change retention_set or retentevt_set does not have ACE4_WRITE_RETENTION permissions, the attempt MUST fail with NFS4ERR_ACCESS.",
      "ja": "retention_setまたはretentevt_setを変更しようと校長がACE4_WRITE_RETENTION権限を持っていない場合は、O、試みはNFS4ERR_ACCESSで失敗しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.13.3. Attribute 71: retentevt_get",
      "section_title": true,
      "ja": "5.13.3. 属性71：retentevt_get"
    },
    {
      "indent": 3,
      "text": "Gets the event-based retention duration, and if enabled, the event-based retention begin time of the file object. This attribute is like retention_get, but refers to event-based retention. The event that triggers event-based retention is not defined by the NFSv4.1 specification.",
      "ja": "イベント・ベースの保存期間を取得し、有効にした場合、イベントベースの保持は、ファイルオブジェクトの時間を開始します。この属性は、retention_getのようなものですが、イベントベースの保存を参照します。イベントベースの保持をトリガするイベントは、NFSv4.1仕様で定義されていません。"
    },
    {
      "indent": 0,
      "text": "5.13.4. Attribute 72: retentevt_set",
      "section_title": true,
      "ja": "5.13.4. 属性72：retentevt_set"
    },
    {
      "indent": 3,
      "text": "Sets the event-based retention duration, and optionally enables event-based retention on the file object. This attribute corresponds to retentevt_get and is like retention_set, but refers to event-based retention. When event-based retention is set, the file MUST be retained even if non-event-based retention has been set, and the duration of non-event-based retention has been reached. Conversely, when non-event-based retention has been set, the file MUST be retained even if event-based retention has been set, and the duration of event-based retention has been reached. The server MAY restrict the enabling of event-based retention or the duration of event-based retention on the basis of the ACE4_WRITE_RETENTION ACL permission. The enabling of event-based retention MUST NOT prevent the enabling of non-event-based retention or the modification of the retention_hold attribute.",
      "ja": "イベント・ベースの保存期間が設定し、必要に応じてファイルオブジェクトにイベント・ベースの保存を可能にします。この属性は、retentevt_getに対応し、retention_setのようなものですが、イベントベースの保存を参照します。イベントベースの保持が設定されている場合は、ファイルが非イベント・ベースの保存が設定されている場合でも保持されなければならない、と非イベントベースの保持の期間に達しています。非イベントベースの保持が設定されている場合は逆に、ファイルには、イベント・ベースの保存が設定されている、イベントベースの保存の期間に達した場合でも保持されなければなりません。サーバーは、イベント・ベースの保存やACE4_WRITE_RETENTION ACL許可に基づいてイベントベースの保持の期間の有効化を制限することができます。イベント・ベースの保存の有効化は、非イベント・ベースの保存やretention_hold属性の変更の可能を妨げてはなりません。"
    },
    {
      "indent": 0,
      "text": "5.13.5. Attribute 73: retention_hold",
      "section_title": true,
      "ja": "5.13.5. 属性73：retention_hold"
    },
    {
      "indent": 3,
      "text": "Gets or sets administrative retention holds, one hold per bit position.",
      "ja": "行政保持は、ビット位置につき1つのホールドを保持して取得または設定します。"
    },
    {
      "indent": 3,
      "text": "This attribute allows one to 64 administrative holds, one hold per bit on the attribute. If retention_hold is not zero, then the file MUST NOT be deleted, renamed, or modified, even if the duration on enabled event or non-event-based retention has been reached. The server MAY restrict the modification of retention_hold on the basis of the ACE4_WRITE_RETENTION_HOLD ACL permission. The enabling of administration retention holds does not prevent the enabling of event-based or non-event-based retention.",
      "ja": "この属性は、1〜64の管理者は、属性のビットあたり1つのホールドを保持していることができます。 retention_holdがゼロでない場合は、ファイルが有効になってイベントや非イベント・ベースの保存の期間に達した場合でも、削除、名前の変更、または変更してはいけません。サーバーはACE4_WRITE_RETENTION_HOLD ACL許可に基づいてretention_holdの変更を制限することができます。管理の有効化リテンションは、イベントベースまたは非イベントベースの保持を可能に防ぐことはできません保持しています。"
    },
    {
      "indent": 3,
      "text": "If the principal attempting to change retention_hold does not have ACE4_WRITE_RETENTION_HOLD permissions, the attempt MUST fail with NFS4ERR_ACCESS.",
      "ja": "retention_holdを変更しようと校長がACE4_WRITE_RETENTION_HOLD権限を持っていない場合、試みはNFS4ERR_ACCESSで失敗しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6. Access Control Attributes",
      "section_title": true,
      "ja": "6.アクセス制御属性"
    },
    {
      "indent": 3,
      "text": "Access Control Lists (ACLs) are file attributes that specify fine-grained access control. This section covers the \"acl\", \"dacl\", \"sacl\", \"aclsupport\", \"mode\", and \"mode_set_masked\" file attributes and their interactions. Note that file attributes may apply to any file system object.",
      "ja": "アクセス制御リスト（ACL）ファイルは、それがファイングレイン・アクセス・コントロールを指定する属性です。このセクションでは、「DACLを」「のacl」「SACL」、「aclsupport」、「モード」、および「mode_set_masked」ファイル属性とそれらの相互作用をカバーしています。ファイル属性は、任意のファイル・システム・オブジェクトに適用することがあります。"
    },
    {
      "indent": 0,
      "text": "6.1. Goals",
      "section_title": true,
      "ja": "6.1. 目標"
    },
    {
      "indent": 3,
      "text": "ACLs and modes represent two well-established models for specifying permissions. This section specifies requirements that attempt to meet the following goals: o If a server supports the mode attribute, it should provide reasonable semantics to clients that only set and retrieve the mode attribute.",
      "ja": "ACLとモードは、パーミッションを指定するための2つのよく確立したモデルを表しています。サーバーは、mode属性をサポートしている場合、それが唯一の設定とモード属性を取得し、クライアントへの合理的なセマンティクスを提供しなければならない○：このセクションでは、次の目標を達成しようとする要件を指定します。"
    },
    {
      "indent": 3,
      "text": "o If a server supports ACL attributes, it should provide reasonable semantics to clients that only set and retrieve those attributes.",
      "ja": "サーバはACL属性をサポートしている場合は、O、それだけで設定し、それらの属性を取得し、クライアントへの合理的なセマンティクスを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "o On servers that support the mode attribute, if ACL attributes have never been set on an object, via inheritance or explicitly, the behavior should be traditional UNIX-like behavior.",
      "ja": "ACL属性は継承を介して、または明示的に、オブジェクトに設定されていなかった場合は、Oモード属性をサポートするサーバーでは、挙動は、従来のUNIXのような振る舞いである必要があります。"
    },
    {
      "indent": 3,
      "text": "o On servers that support the mode attribute, if the ACL attributes have been previously set on an object, either explicitly or via inheritance:",
      "ja": "O ACL属性は以前に明示的または継承を経由して、オブジェクトに設定されている場合は、mode属性をサポートしているサーバーの場合："
    },
    {
      "indent": 6,
      "text": "* Setting only the mode attribute should effectively control the traditional UNIX-like permissions of read, write, and execute on owner, owner_group, and other.",
      "ja": "*専用モード属性は効果的に、読み取りの伝統的なUNIXライクなアクセス許可を制御し、書き込み、および所有者、owner_group、および他の上で実行する必要があり設定。"
    },
    {
      "indent": 6,
      "text": "* Setting only the mode attribute should provide reasonable security. For example, setting a mode of 000 should be enough to ensure that future OPEN operations for OPEN4_SHARE_ACCESS_READ or OPEN4_SHARE_ACCESS_WRITE by any principal fail, regardless of a previously existing or inherited ACL.",
      "ja": "*専用モード属性を設定すると、合理的なセキュリティを提供する必要があります。例えば、000のモードを設定しても、主によってOPEN4_SHARE_ACCESS_READ又はOPEN4_SHARE_ACCESS_WRITEためOPEN操作は関係なく、既存または継承されたACLの、フェイルその将来を保証するのに十分であるべきです。"
    },
    {
      "indent": 3,
      "text": "o NFSv4.1 may introduce different semantics relating to the mode and ACL attributes, but it does not render invalid any previously existing implementations. Additionally, this section provides clarifications based on previous implementations and discussions around them.",
      "ja": "O NFSv4.1は、モードに関する異なる意味を導入することができるし、ACL属性が、それは、無効な任意の既存の実装をレンダリングされません。また、このセクションでは、以前の実装とその周りの議論に基づいて明確化を提供します。"
    },
    {
      "indent": 3,
      "text": "o On servers that support both the mode and the acl or dacl attributes, the server must keep the two consistent with each other. The value of the mode attribute (with the exception of the three high-order bits described in Section 6.2.4) must be determined entirely by the value of the ACL, so that use of the mode is never required for anything other than setting the three high-order bits. See Section 6.4.1 for exact requirements.",
      "ja": "OモードおよびACLまたはDACL属性の両方をサポートするサーバーでは、サーバーはお互いに2一貫性を保つ必要があります。モードの使用は、設定以外のために必要とされることはないように（セクション6.2.4で説明した3つの上位ビットを除く）モード属性の値は、ACLの値によって完全に決定されなければなりません上位3ビット。正確な要件については、セクション6.4.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "o When a mode attribute is set on an object, the ACL attributes may need to be modified in order to not conflict with the new mode. In such cases, it is desirable that the ACL keep as much information as possible. This includes information about inheritance, AUDIT and ALARM ACEs, and permissions granted and denied that do not conflict with the new mode.",
      "ja": "モード属性がオブジェクトに設定されている場合、O、ACL属性が新しいモードと競合しないようにするために変更する必要があります。このような場合には、ACLは、できるだけ多くの情報を保持することが望ましいです。これは、新しいモードと競合しない相続、AUDITとALARM ACEは、パーミッション付与と拒否に関する情報が含まれています。"
    },
    {
      "indent": 0,
      "text": "6.2. File Attributes Discussion",
      "section_title": true,
      "ja": "6.2. ファイルには、ディスカッションを属性"
    },
    {
      "indent": 0,
      "text": "6.2.1. Attribute 12: acl",
      "section_title": true,
      "ja": "6.2.1. 属性12：ACL"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 ACL attribute contains an array of Access Control Entries (ACEs) that are associated with the file system object. Although the client can set and get the acl attribute, the server is responsible for using the ACL to perform access control. The client can use the OPEN or ACCESS operations to check access without modifying or reading data or metadata.",
      "ja": "NFSv4.1 ACL属性は、ファイル・システム・オブジェクトに関連付けられているアクセス制御エントリ（ACE）の配列を含んでいます。クライアントがACL属性を設定して取得することができますが、サーバーは、アクセス制御を実行するためにACLを使用する責任があります。クライアントは、データまたはメタデータを変更するか、読まずにアクセスをチェックするためにOPENまたはアクセス操作を使用することができます。"
    },
    {
      "indent": 3,
      "text": "The NFS ACE structure is defined as follows:",
      "ja": "次のようにNFS ACE構造が定義されています。"
    },
    {
      "indent": 3,
      "text": "typedef uint32_t acetype4;",
      "ja": "typedefでのuint32_t acetype4。"
    },
    {
      "indent": 3,
      "text": "typedef uint32_t aceflag4;",
      "ja": "typedefでのuint32_t aceflag4。"
    },
    {
      "indent": 3,
      "text": "typedef uint32_t acemask4;",
      "ja": "typedefでのuint32_t acemask4。"
    },
    {
      "indent": 3,
      "text": "struct nfsace4 {\n        acetype4        type;\n        aceflag4        flag;\n        acemask4        access_mask;\n        utf8str_mixed   who;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "To determine if a request succeeds, the server processes each nfsace4 entry in order. Only ACEs that have a \"who\" that matches the requester are considered. Each ACE is processed until all of the bits of the requester's access have been ALLOWED. Once a bit (see below) has been ALLOWED by an ACCESS_ALLOWED_ACE, it is no longer considered in the processing of later ACEs. If an ACCESS_DENIED_ACE is encountered where the requester's access still has unALLOWED bits in common with the \"access_mask\" of the ACE, the request is denied. When the ACL is fully processed, if there are bits in the requester's mask that have not been ALLOWED or DENIED, access is denied.",
      "ja": "リクエストが成功したかどうかを判断するには、サーバは順序で各nfsace4エントリを処理します。依頼者と一致した「」持っている唯一のACEが考慮されます。依頼者のアクセスのビットのすべてが許可されるまで、各ACEが処理されます。ビットが（下記参照）ACCESS_ALLOWED_ACEによって許可された後、それはもはや後のACEの処理において考慮されません。 ACCESS_DENIED_ACEが発生した場合は、要求者のアクセスはまだACEの「access_mask」と共通の許可されていないビットを有する場合、要求は拒否されます。 ACLが完全に処理されると許可または拒否されていない依頼者のマスクのビットがある場合は、アクセスが拒否されます。"
    },
    {
      "indent": 3,
      "text": "Unlike the ALLOW and DENY ACE types, the ALARM and AUDIT ACE types do not affect a requester's access, and instead are for triggering events as a result of a requester's access attempt. Therefore, AUDIT and ALARM ACEs are processed only after processing ALLOW and DENY ACEs.",
      "ja": "許可し、DENY ACEタイプとは異なり、ALARMおよびAUDIT ACEタイプは、要求者のアクセスには影響しませんし、代わりに、要求者のアクセス試行の結果としてイベントをトリガするためのものです。したがって、AUDITとALARMのACEのみACEを可能にし、DENY処理した後に処理されます。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 ACL model is quite rich. Some server platforms may provide access-control functionality that goes beyond the UNIX-style mode attribute, but that is not as rich as the NFS ACL model. So that users can take advantage of this more limited functionality, the server may support the acl attributes by mapping between its ACL model and the NFSv4.1 ACL model. Servers must ensure that the ACL they actually store or enforce is at least as strict as the NFSv4 ACL that was set. It is tempting to accomplish this by rejecting any ACL that falls outside the small set that can be represented accurately. However, such an approach can render ACLs unusable without special client-side knowledge of the server's mapping, which defeats the purpose of having a common NFSv4 ACL protocol. Therefore, servers should accept every ACL that they can without compromising security. To help accomplish this, servers may make a special exception, in the case of unsupported permission bits, to the rule that bits not ALLOWED or DENIED by an ACL must be denied. For example, a UNIX-style server might choose to silently allow read attribute permissions even though an ACL does not explicitly allow those permissions. (An ACL that explicitly denies permission to read attributes should still be rejected.)",
      "ja": "NFSv4.1 ACLモデルは非常に豊富です。一部のサーバー・プラットフォームは、UNIXスタイルのmode属性を超えたアクセス制御機能を提供することができるが、それはNFS ACLモデルほど豊富ではありません。ユーザーはこのより限定された機能を利用することができるように、サーバーは、そのACLモデルとNFSv4.1 ACLモデルとの間のマッピングにより、ACL属性をサポートすることができます。サーバーは、彼らが実際に格納したり、強制ACLが設定されたのNFSv4 ACLと少なくとも同程度に厳格であることを確認する必要があります。正確に表現することができる小さなセットから外れる任意のACLを拒否することによって、これを達成するために魅力的です。しかし、このようなアプローチは、共通のNFSv4 ACLプロトコルを持つことの目的に反し、サーバーのマッピング、の特別なクライアント側の知識がなくてもACLが使用不能になることができます。そのため、サーバは、セキュリティを損なうことなく、その彼らができるすべてのACLを受け入れる必要があります。これを実現しやすくするために、サーバが拒否しなければならないACLによって許可または拒否されていないビットルールに、サポートされていない許可ビットの場合には、特別な例外を行うことができます。たとえば、UNIX形式のサーバーは、ACLが明示的にこれらの権限を許可していないにもかかわらず、読み属性の権限を静かに許可することを選択するかもしれません。 （明示的に属性を読み取るためのアクセス許可を拒否するACLはまだ拒絶されなければなりません。）"
    },
    {
      "indent": 3,
      "text": "The situation is complicated by the fact that a server may have multiple modules that enforce ACLs. For example, the enforcement for NFSv4.1 access may be different from, but not weaker than, the enforcement for local access, and both may be different from the enforcement for access through other protocols such as SMB (Server Message Block). So it may be useful for a server to accept an ACL even if not all of its modules are able to support it.",
      "ja": "状況は、サーバーがACLを強制する複数のモジュールを持っているかもしれないという事実によって複雑になります。例えば、NFSv4.1アクセスのための施行は、ローカルアクセスのための施行、より弱いとは異なるが、なくてもよい、との両方は、SMB（サーバメッセージブロック）など、他のプロトコルを介してアクセスするための施行と異なっていてもよいです。そのモジュールのすべてではないが、それをサポートすることができている場合でも、サーバーがACLを受け入れるするので、有用である可能性があります。"
    },
    {
      "indent": 3,
      "text": "The guiding principle with regard to NFSv4 access is that the server must not accept ACLs that appear to make access to the file more restrictive than it really is.",
      "ja": "NFSv4のアクセスに関する指導原則は、サーバは、それが実際よりも、ファイルへのアクセスがより制限するために表示されるACLを受け入れてはならないということです。"
    },
    {
      "indent": 0,
      "text": "6.2.1.1. ACE Type",
      "section_title": true,
      "ja": "6.2.1.1。 ACEの種類"
    },
    {
      "indent": 3,
      "text": "The constants used for the type field (acetype4) are as follows:",
      "ja": "次のようにタイプフィールド（acetype4）に使用される定数です。"
    },
    {
      "indent": 3,
      "text": "const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;\nconst ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;\nconst ACE4_SYSTEM_AUDIT_ACE_TYPE        = 0x00000002;\nconst ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Only the ALLOWED and DENIED bits may be used in the dacl attribute, and only the AUDIT and ALARM bits may be used in the sacl attribute. All four are permitted in the acl attribute.",
      "ja": "のみ可能とDENIEDビットがDACL属性で使用することができる、とのみAUDITとALARMビットがSACL属性で使用されてもよいです。 4つのすべてのは、ACL属性で許可されています。"
    },
    {
      "indent": 3,
      "text": "+------------------------------+--------------+---------------------+\n| Value                        | Abbreviation | Description         |\n+------------------------------+--------------+---------------------+\n| ACE4_ACCESS_ALLOWED_ACE_TYPE | ALLOW        | Explicitly grants   |\n|                              |              | the access defined  |\n|                              |              | in acemask4 to the  |\n|                              |              | file or directory.  |\n| ACE4_ACCESS_DENIED_ACE_TYPE  | DENY         | Explicitly denies   |\n|                              |              | the access defined  |\n|                              |              | in acemask4 to the  |\n|                              |              | file or directory.  |\n| ACE4_SYSTEM_AUDIT_ACE_TYPE   | AUDIT        | Log (in a           |\n|                              |              | system-dependent    |\n|                              |              | way) any access     |\n|                              |              | attempt to a file   |\n|                              |              | or directory that   |\n|                              |              | uses any of the     |\n|                              |              | access methods      |\n|                              |              | specified in        |\n|                              |              | acemask4.           |\n| ACE4_SYSTEM_ALARM_ACE_TYPE   | ALARM        | Generate an alarm   |\n|                              |              | (in a               |\n|                              |              | system-dependent    |\n|                              |              | way) when any       |\n|                              |              | access attempt is   |\n|                              |              | made to a file or   |\n|                              |              | directory for the   |\n|                              |              | access methods      |\n|                              |              | specified in        |\n|                              |              | acemask4.           |\n+------------------------------+--------------+---------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"Abbreviation\" column denotes how the types will be referred to throughout the rest of this section.",
      "ja": "「省略形」列には、型が、このセクションの残りの部分と呼ぶことにする方法を示しています。"
    },
    {
      "indent": 0,
      "text": "6.2.1.2. Attribute 13: aclsupport",
      "section_title": true,
      "ja": "6.2.1.2。属性13：aclsupport"
    },
    {
      "indent": 3,
      "text": "A server need not support all of the above ACE types. This attribute indicates which ACE types are supported for the current file system. The bitmask constants used to represent the above definitions within the aclsupport attribute are as follows:",
      "ja": "サーバーは、上記のACEタイプのすべてをサポートしている必要はありません。この属性は、ACEタイプは、現在のファイルシステムでサポートされているかを示します。次のようにaclsupport属性内の上記の定義を表すために使用されるビットマスク定数です。"
    },
    {
      "indent": 3,
      "text": "const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;\nconst ACL4_SUPPORT_DENY_ACL     = 0x00000002;\nconst ACL4_SUPPORT_AUDIT_ACL    = 0x00000004;\nconst ACL4_SUPPORT_ALARM_ACL    = 0x00000008;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Servers that support either the ALLOW or DENY ACE type SHOULD support both ALLOW and DENY ACE types.",
      "ja": "ACEの種類が許可し、ACEの種類をDENYの両方をサポートすべき許可または拒否のいずれかサポートするサーバー。"
    },
    {
      "indent": 3,
      "text": "Clients should not attempt to set an ACE unless the server claims support for that ACE type. If the server receives a request to set an ACE that it cannot store, it MUST reject the request with NFS4ERR_ATTRNOTSUPP. If the server receives a request to set an ACE that it can store but cannot enforce, the server SHOULD reject the request with NFS4ERR_ATTRNOTSUPP.",
      "ja": "クライアントは、サーバーのクレームがそのACEの種類をサポートしない限り、ACEを設定しようとするべきではありません。サーバが格納できないというACEを設定するための要求を受信した場合、それはNFS4ERR_ATTRNOTSUPPで要求を拒絶しなければなりません。サーバーが保存することができますが、強制することはできませんACEを設定するための要求を受信した場合、サーバはNFS4ERR_ATTRNOTSUPPとのリクエストを拒否すべきです。"
    },
    {
      "indent": 3,
      "text": "Support for any of the ACL attributes is optional (albeit RECOMMENDED). However, a server that supports either of the new ACL attributes (dacl or sacl) MUST allow use of the new ACL attributes to access all of the ACE types that it supports. In other words, if such a server supports ALLOW or DENY ACEs, then it MUST support the dacl attribute, and if it supports AUDIT or ALARM ACEs, then it MUST support the sacl attribute.",
      "ja": "ACLの属性のいずれかのサポートは、（推奨はあるが）はオプションです。しかし、新しいACLの使用を許可する必要があり、新たなACL属性（DACLまたはSACL）のいずれかをサポートするサーバーは、サポートするACEタイプのすべてにアクセスするための属性。言い換えれば、このようなサーバはACEを許可または拒否サポートしていれば、それはDACL属性をサポートしなければならない、そしてそれはAUDITかALARM ACEをサポートしている場合、それはSACL属性をサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2.1.3. ACE Access Mask",
      "section_title": true,
      "ja": "6.2.1.3。 ACEアクセスマスク"
    },
    {
      "indent": 3,
      "text": "The bitmask constants used for the access mask field are as follows:",
      "ja": "次のようにアクセスマスクフィールドに使用されるビットマスク定数は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "const ACE4_READ_DATA            = 0x00000001;\nconst ACE4_LIST_DIRECTORY       = 0x00000001;\nconst ACE4_WRITE_DATA           = 0x00000002;\nconst ACE4_ADD_FILE             = 0x00000002;\nconst ACE4_APPEND_DATA          = 0x00000004;\nconst ACE4_ADD_SUBDIRECTORY     = 0x00000004;\nconst ACE4_READ_NAMED_ATTRS     = 0x00000008;\nconst ACE4_WRITE_NAMED_ATTRS    = 0x00000010;\nconst ACE4_EXECUTE              = 0x00000020;\nconst ACE4_DELETE_CHILD         = 0x00000040;\nconst ACE4_READ_ATTRIBUTES      = 0x00000080;\nconst ACE4_WRITE_ATTRIBUTES     = 0x00000100;\nconst ACE4_WRITE_RETENTION      = 0x00000200;\nconst ACE4_WRITE_RETENTION_HOLD = 0x00000400;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const ACE4_DELETE               = 0x00010000;\nconst ACE4_READ_ACL             = 0x00020000;\nconst ACE4_WRITE_ACL            = 0x00040000;\nconst ACE4_WRITE_OWNER          = 0x00080000;\nconst ACE4_SYNCHRONIZE          = 0x00100000;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that some masks have coincident values, for example, ACE4_READ_DATA and ACE4_LIST_DIRECTORY. The mask entries ACE4_LIST_DIRECTORY, ACE4_ADD_FILE, and ACE4_ADD_SUBDIRECTORY are intended to be used with directory objects, while ACE4_READ_DATA, ACE4_WRITE_DATA, and ACE4_APPEND_DATA are intended to be used with non-directory objects.",
      "ja": "なお、一部のマスクが一致する値を持っていること、例えば、ACE4_READ_DATAとACE4_LIST_DIRECTORY。 ACE4_READ_DATA、ACE4_WRITE_DATA、及びACE4_APPEND_DATA非ディレクトリオブジェクトで使用することが意図されている間、マスク・エントリACE4_LIST_DIRECTORY、ACE4_ADD_FILE、及びACE4_ADD_SUBDIRECTORYは、ディレクトリオブジェクトと一緒に使用されることが意図されます。"
    },
    {
      "indent": 0,
      "text": "6.2.1.3.1. Discussion of Mask Attributes",
      "section_title": true,
      "ja": "6.2.1.3.1。マスク属性のディスカッション"
    },
    {
      "indent": 3,
      "text": "ACE4_READ_DATA",
      "ja": "ACE4_READ_DATA"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "READ",
      "ja": "読む"
    },
    {
      "indent": 9,
      "text": "OPEN",
      "ja": "開いた"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to read the data of the file.",
      "ja": "ファイルのデータを読み取るためのアクセス許可。"
    },
    {
      "indent": 9,
      "text": "Servers SHOULD allow a user the ability to read the data of the file when only the ACE4_EXECUTE access mask bit is allowed.",
      "ja": "サーバーは、ユーザーにのみACE4_EXECUTEアクセスマスクビットが許可されたときに、ファイルのデータを読み取る能力を可能にしなければなりません。"
    },
    {
      "indent": 3,
      "text": "ACE4_LIST_DIRECTORY",
      "ja": "ACE4_LIST_DIRECTORY"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "READDIR",
      "ja": "READDIR"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to list the contents of a directory.",
      "ja": "ディレクトリの内容を一覧表示するためのアクセス許可。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_DATA",
      "ja": "ACE4_WRITE_DATA"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "WRITE",
      "ja": "書く"
    },
    {
      "indent": 9,
      "text": "OPEN",
      "ja": "開いた"
    },
    {
      "indent": 9,
      "text": "SETATTR of size",
      "ja": "サイズのSETATTR"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to modify a file's data.",
      "ja": "ファイルのデータを変更する権限。"
    },
    {
      "indent": 3,
      "text": "ACE4_ADD_FILE",
      "ja": "ACE4_ADD_FILE"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "CREATE",
      "ja": "CREATE"
    },
    {
      "indent": 9,
      "text": "LINK",
      "ja": "リンク"
    },
    {
      "indent": 9,
      "text": "OPEN",
      "ja": "開いた"
    },
    {
      "indent": 9,
      "text": "RENAME",
      "ja": "リネーム"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to add a new file in a directory. The CREATE operation is affected when nfs_ftype4 is NF4LNK, NF4BLK, NF4CHR, NF4SOCK, or NF4FIFO. (NF4DIR is not listed because it is covered by ACE4_ADD_SUBDIRECTORY.) OPEN is affected when used to create a regular file. LINK and RENAME are always affected.",
      "ja": "ディレクトリに新しいファイルを追加する権限。 nfs_ftype4はNF4LNK、NF4BLK、NF4CHR、NF4SOCK、又はNF4FIFOある場合、CREATE操作が影響を受けます。 （それはACE4_ADD_SUBDIRECTORYによって覆われているためNF4DIRが記載されていません。）通常のファイルを作成するために使用されるときOPENが影響を受けています。 LINKとRENAMEは常に影響を受けます。"
    },
    {
      "indent": 3,
      "text": "ACE4_APPEND_DATA",
      "ja": "ACE4_APPEND_DATA"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "WRITE",
      "ja": "書く"
    },
    {
      "indent": 9,
      "text": "OPEN",
      "ja": "開いた"
    },
    {
      "indent": 9,
      "text": "SETATTR of size",
      "ja": "サイズのSETATTR"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "The ability to modify a file's data, but only starting at EOF. This allows for the notion of append-only files, by allowing ACE4_APPEND_DATA and denying ACE4_WRITE_DATA to the same user or group. If a file has an ACL such as the one described above and a WRITE request is made for somewhere other than EOF, the server SHOULD return NFS4ERR_ACCESS.",
      "ja": "ファイルのデータを変更する機能は、だけEOFから始まります。これはACE4_APPEND_DATAを許可し、同じユーザーまたはグループにACE4_WRITE_DATAを拒否することによって、追加専用ファイルの概念が可能になります。ファイルは、上述したようなACLを持っており、書き込み要求がEOF以外のどこかのために作られた場合、サーバはNFS4ERR_ACCESSを返すべきです。"
    },
    {
      "indent": 3,
      "text": "ACE4_ADD_SUBDIRECTORY",
      "ja": "ACE4_ADD_SUBDIRECTORY"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "CREATE",
      "ja": "CREATE"
    },
    {
      "indent": 9,
      "text": "RENAME",
      "ja": "リネーム"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to create a subdirectory in a directory. The CREATE operation is affected when nfs_ftype4 is NF4DIR. The RENAME operation is always affected.",
      "ja": "ディレクトリ内にサブディレクトリを作成する権限。 NF4DIRがnfs_ftype4あるとき、CREATE操作が影響を受けています。 RENAME操作は常に影響を受けています。"
    },
    {
      "indent": 3,
      "text": "ACE4_READ_NAMED_ATTRS",
      "ja": "ACE4_READ_NAMED_ATTRS"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "OPENATTR",
      "ja": "OPENATTR"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to read the named attributes of a file or to look up the named attribute directory. OPENATTR is affected when it is not used to create a named attribute directory. This is when 1) createdir is TRUE, but a named attribute directory already exists, or 2) createdir is FALSE.",
      "ja": "ファイルの名前の属性を読み取るため、または名前付き属性のディレクトリを検索する許可。名前の属性ディレクトリを作成するために使用されていない場合OPENATTRが影響を受けています。これは、1）createdirはTRUEですが、名前の属性ディレクトリがすでに存在している、または2）createdirがFALSEであるときです。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_NAMED_ATTRS",
      "ja": "ACE4_WRITE_NAMED_ATTRS"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "OPENATTR",
      "ja": "OPENATTR"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to write the named attributes of a file or to create a named attribute directory. OPENATTR is affected when it is used to create a named attribute directory. This is when createdir is TRUE and no named attribute directory exists. The ability to check whether or not a named attribute directory exists depends on the ability to look it up; therefore, users also need the ACE4_READ_NAMED_ATTRS permission in order to create a named attribute directory.",
      "ja": "ファイルの名前の属性を記述するか、名前付き属性のディレクトリを作成する権限。名前の属性ディレクトリを作成するために使用されている場合OPENATTRが影響を受けています。 createdirがTRUEで、何という名前の属性ディレクトリが存在しない場合です。名前の属性ディレクトリが存在するかどうかをチェックする機能は、それを検索する能力に依存します。そのため、ユーザーはまた、名前の属性ディレクトリを作成するためにACE4_READ_NAMED_ATTRS権限が必要です。"
    },
    {
      "indent": 3,
      "text": "ACE4_EXECUTE",
      "ja": "ACE4_EXECUTE"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "READ",
      "ja": "読む"
    },
    {
      "indent": 9,
      "text": "OPEN",
      "ja": "開いた"
    },
    {
      "indent": 9,
      "text": "REMOVE",
      "ja": "削除する"
    },
    {
      "indent": 9,
      "text": "RENAME",
      "ja": "リネーム"
    },
    {
      "indent": 9,
      "text": "LINK",
      "ja": "リンク"
    },
    {
      "indent": 9,
      "text": "CREATE",
      "ja": "CREATE"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to execute a file.",
      "ja": "ファイルを実行する権限。"
    },
    {
      "indent": 9,
      "text": "Servers SHOULD allow a user the ability to read the data of the file when only the ACE4_EXECUTE access mask bit is allowed. This is because there is no way to execute a file without reading the contents. Though a server may treat ACE4_EXECUTE and ACE4_READ_DATA bits identically when deciding to permit a READ operation, it SHOULD still allow the two bits to be set independently in ACLs, and MUST distinguish between them when replying to ACCESS operations. In particular, servers SHOULD NOT silently turn on one of the two bits when the other is set, as that would make it impossible for the client to correctly enforce the distinction between read and execute permissions.",
      "ja": "サーバーは、ユーザーにのみACE4_EXECUTEアクセスマスクビットが許可されたときに、ファイルのデータを読み取る能力を可能にしなければなりません。内容を読まずにファイルを実行する方法がないためです。 READ操作を可能とすることを決定する際に、サーバーが同一のACE4_EXECUTEとACE4_READ_DATAビットを扱うかもしれないが、それはまだ2つのビットは、ACLの中で独立して設定できるようにする必要があり、アクセス操作に返信するときにそれらを区別しなければなりません。具体的には、サーバは黙ってそれはそれは不可能クライアントを正しく読み取りおよび実行権限の区別を強制するために作ると同じように、他が設定されている2つのビットの1をオンにすべきではありません。"
    },
    {
      "indent": 9,
      "text": "As an example, following a SETATTR of the following ACL:",
      "ja": "一例として、次のACLのSETATTR次"
    },
    {
      "indent": 9,
      "text": "nfsuser:ACE4_EXECUTE:ALLOW",
      "ja": "nfsuser：ACE4_EXECUTE：ALLOW"
    },
    {
      "indent": 9,
      "text": "A subsequent GETATTR of ACL for that file SHOULD return:",
      "ja": "そのファイルのACLのその後のGETATTRは返すべきです："
    },
    {
      "indent": 9,
      "text": "nfsuser:ACE4_EXECUTE:ALLOW",
      "ja": "nfsuser：ACE4_EXECUTE：ALLOW"
    },
    {
      "indent": 9,
      "text": "Rather than:",
      "ja": "のではなく："
    },
    {
      "indent": 9,
      "text": "nfsuser:ACE4_EXECUTE/ACE4_READ_DATA:ALLOW",
      "ja": "nfsuser：ACE4_EXECUTE / ACE4_READ_DATA：ALLOW"
    },
    {
      "indent": 3,
      "text": "ACE4_EXECUTE",
      "ja": "ACE4_EXECUTE"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "LOOKUP",
      "ja": "調べる"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to traverse/search a directory.",
      "ja": "ディレクトリを検索/トラバースする許可。"
    },
    {
      "indent": 3,
      "text": "ACE4_DELETE_CHILD",
      "ja": "ACE4_DELETE_CHILD"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "REMOVE",
      "ja": "削除する"
    },
    {
      "indent": 9,
      "text": "RENAME",
      "ja": "リネーム"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to delete a file or directory within a directory. See Section 6.2.1.3.2 for information on ACE4_DELETE and ACE4_DELETE_CHILD interact.",
      "ja": "ディレクトリ内のファイルやディレクトリを削除する権限。 ACE4_DELETEとACE4_DELETE_CHILDの相互作用の詳細については、セクション6.2.1.3.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "ACE4_READ_ATTRIBUTES",
      "ja": "ACE4_READ_ATTRIBUTES"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "GETATTR of file system object attributes",
      "ja": "ファイル・システム・オブジェクト属性のGETATTR"
    },
    {
      "indent": 9,
      "text": "VERIFY",
      "ja": "VERIFY"
    },
    {
      "indent": 9,
      "text": "NVERIFY",
      "ja": "NVERIFY"
    },
    {
      "indent": 9,
      "text": "READDIR",
      "ja": "READDIR"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "The ability to read basic attributes (non-ACLs) of a file. On a UNIX system, basic attributes can be thought of as the stat-level attributes. Allowing this access mask bit would mean that the entity can execute \"ls -l\" and stat. If a READDIR operation requests attributes, this mask must be allowed for the READDIR to succeed.",
      "ja": "ファイルの基本属性（ACL以外）を読み取る能力。 UNIXシステムでは、基本的な属性は、STAT-レベル属性と考えることができます。このアクセスマスクビットを許可すると、エンティティは「ls -lで」とのstatを実行できることを意味します。 READDIR操作が属性を要求する場合READDIRを成功させるために、このマスクは、許可する必要があります。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_ATTRIBUTES",
      "ja": "ACE4_WRITE_ATTRIBUTES"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "SETATTR of time_access_set, time_backup,",
      "ja": "time_access_setのSETATTR、time_backup、"
    },
    {
      "indent": 9,
      "text": "time_create, time_modify_set, mimetype, hidden, system",
      "ja": "time_create、time_modify_set、MIMEタイプ、隠し、システム"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to change the times associated with a file or directory to an arbitrary value. Also permission to change the mimetype, hidden, and system attributes. A user having ACE4_WRITE_DATA or ACE4_WRITE_ATTRIBUTES will be allowed to set the times associated with a file to the current server time.",
      "ja": "任意の値にファイルまたはディレクトリに関連付けられた時刻を変更する権限。また、MIMEタイプを変更する権限、隠し、およびシステム属性。 ACE4_WRITE_DATAまたはACE4_WRITE_ATTRIBUTESを持つユーザーは、現在のサーバー時刻にファイルに関連付けられている時間を設定することが許可されます。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_RETENTION",
      "ja": "ACE4_WRITE_RETENTION"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "SETATTR of retention_set, retentevt_set.",
      "ja": "retention_setのSETATTR、retentevt_set。"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to modify the durations of event and non-event-based retention. Also permission to enable event and non-event-based retention. A server MAY behave such that setting ACE4_WRITE_ATTRIBUTES allows ACE4_WRITE_RETENTION.",
      "ja": "イベントの期間と非イベントベースの保持を変更する権限。また、イベントや非イベントベースの保持を有効にする権限。サーバーはACE4_WRITE_ATTRIBUTESを設定するACE4_WRITE_RETENTIONを可能にするような動作をする場合があります。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_RETENTION_HOLD",
      "ja": "ACE4_WRITE_RETENTION_HOLD"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "SETATTR of retention_hold.",
      "ja": "retention_holdのSETATTR。"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to modify the administration retention holds. A server MAY map ACE4_WRITE_ATTRIBUTES to ACE_WRITE_RETENTION_HOLD.",
      "ja": "管理の保持を変更する権限を保持しています。サーバーはACE_WRITE_RETENTION_HOLDにACE4_WRITE_ATTRIBUTESをマッピングすることができます。"
    },
    {
      "indent": 3,
      "text": "ACE4_DELETE",
      "ja": "ACE4_DELETE"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "REMOVE",
      "ja": "削除する"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to delete the file or directory. See Section 6.2.1.3.2 for information on ACE4_DELETE and ACE4_DELETE_CHILD interact.",
      "ja": "ファイルまたはディレクトリを削除する権限。 ACE4_DELETEとACE4_DELETE_CHILDの相互作用の詳細については、セクション6.2.1.3.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "ACE4_READ_ACL",
      "ja": "ACE4_READ_ACL"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "GETATTR of acl, dacl, or sacl",
      "ja": "ACLのGETATTR、DACL、またはSACL"
    },
    {
      "indent": 9,
      "text": "NVERIFY",
      "ja": "NVERIFY"
    },
    {
      "indent": 9,
      "text": "VERIFY",
      "ja": "VERIFY"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to read the ACL.",
      "ja": "ACLの読み取り権限。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_ACL",
      "ja": "ACE4_WRITE_ACL"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "SETATTR of acl and mode",
      "ja": "ACLとモードのSETATTR"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to write the acl and mode attributes.",
      "ja": "ACLとモード属性を書き込む権限。"
    },
    {
      "indent": 3,
      "text": "ACE4_WRITE_OWNER",
      "ja": "ACE4_WRITE_OWNER"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "SETATTR of owner and owner_group",
      "ja": "所有者とowner_groupのSETATTR"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to write the owner and owner_group attributes. On UNIX systems, this is the ability to execute chown() and chgrp().",
      "ja": "所有者の書き込みと属性をowner_groupする許可。 UNIXシステムでは、これは（）はchown（）とchgrpコマンドを実行する能力です。"
    },
    {
      "indent": 3,
      "text": "ACE4_SYNCHRONIZE",
      "ja": "ACE4_SYNCHRONIZE"
    },
    {
      "indent": 6,
      "text": "Operation(s) affected:",
      "ja": "オペレーション（s）は影響を受けました："
    },
    {
      "indent": 9,
      "text": "NONE",
      "ja": "無し"
    },
    {
      "indent": 6,
      "text": "Discussion:",
      "ja": "討論："
    },
    {
      "indent": 9,
      "text": "Permission to use the file object as a synchronization primitive for interprocess communication. This permission is not enforced or interpreted by the NFSv4.1 server on behalf of the client.",
      "ja": "プロセス間通信のための同期プリミティブとしてファイルオブジェクトを使用する許可。この権限は、クライアントに代わって強制またはNFSv4.1サーバーによって解釈されていません。"
    },
    {
      "indent": 9,
      "text": "Typically, the ACE4_SYNCHRONIZE permission is only meaningful on local file systems, i.e., file systems not accessed via NFSv4.1. The reason that the permission bit exists is that some operating environments, such as Windows, use ACE4_SYNCHRONIZE.",
      "ja": "典型的には、ACE4_SYNCHRONIZE許可は、NFSv4.1を介してアクセスされない、すなわち、ファイル・システムのローカルファイルシステム上でのみ有効です。許可ビットが存在する理由は、Windowsのようないくつかの動作環境は、ACE4_SYNCHRONIZEを使用することです。"
    },
    {
      "indent": 9,
      "text": "For example, if a client copies a file that has ACE4_SYNCHRONIZE set from a local file system to an NFSv4.1 server, and then later copies the file from the NFSv4.1 server to a local file system, it is likely that if ACE4_SYNCHRONIZE was set in the original file, the client will want it set in the second copy. The first copy will not have the permission set unless the NFSv4.1 server has the means to set the ACE4_SYNCHRONIZE bit. The second copy will not have the permission set unless the NFSv4.1 server has the means to retrieve the ACE4_SYNCHRONIZE bit.",
      "ja": "たとえば、クライアントコピーACE4_SYNCHRONIZE後でコピーしたファイルをローカルファイルシステムへのNFSv4.1サーバーから、その後NFSv4.1サーバーへのローカルファイルシステムから設定して、しているファイルならば、ACE4_SYNCHRONIZEだったら可能性が高いです元のファイルに設定され、クライアントは、それが第二のコピーに設定したいと思うでしょう。 NFSv4.1サーバーがACE4_SYNCHRONIZEビットを設定するための手段を持っていない限り、最初のコピーは、アクセス許可セットを持っていません。 NFSv4.1サーバーがACE4_SYNCHRONIZEビットを取得するための手段を持っていない限り、第二のコピーは、アクセス許可セットを持っていません。"
    },
    {
      "indent": 3,
      "text": "Server implementations need not provide the granularity of control that is implied by this list of masks. For example, POSIX-based systems might not distinguish ACE4_APPEND_DATA (the ability to append to a file) from ACE4_WRITE_DATA (the ability to modify existing contents); both masks would be tied to a single \"write\" permission [20]. When such a server returns attributes to the client, it would show both ACE4_APPEND_DATA and ACE4_WRITE_DATA if and only if the write permission is enabled.",
      "ja": "サーバ実装は、マスクのこのリストによって暗示される制御の粒度を提供する必要はありません。例えば、POSIXベースのシステムは、ACE4_WRITE_DATA（既存の内容を変更する能力）からACE4_APPEND_DATA（ファイルに追加する能力）を区別しないかもしれません。両方のマスクは、単一の「書き込み」権限[20]に接続します。そのようなサーバがクライアントに属性を返すとき、それがあればACE4_APPEND_DATAとACE4_WRITE_DATAの両方を示すであろうし、書き込み許可が有効な場合のみ。"
    },
    {
      "indent": 3,
      "text": "If a server receives a SETATTR request that it cannot accurately implement, it should err in the direction of more restricted access, except in the previously discussed cases of execute and read. For example, suppose a server cannot distinguish overwriting data from appending new data, as described in the previous paragraph. If a client submits an ALLOW ACE where ACE4_APPEND_DATA is set but ACE4_WRITE_DATA is not (or vice versa), the server should either turn off ACE4_APPEND_DATA or reject the request with NFS4ERR_ATTRNOTSUPP.",
      "ja": "サーバはそれが正確に実装することはできませんSETATTR要求を受信した場合、それが実行し、読みの先に述べた場合を除いて、より多くのアクセス制限の方向に誤るべきです。例えば、前の段落で説明したように、サーバは、新しいデータを追加するからデータを上書き区別できないと仮定します。クライアントはACE4_APPEND_DATAが設定されているALLOW ACEを提出するが、ACE4_WRITE_DATAは（またはその逆）でない場合、サーバはどちらかACE4_APPEND_DATAをオフにしたり、NFS4ERR_ATTRNOTSUPPで要求を拒否しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2.1.3.2. ACE4_DELETE vs. ACE4_DELETE_CHILD",
      "section_title": true,
      "ja": "6.2.1.3.2。 ACE4_DELETE対ACE4_DELETE_CHILD"
    },
    {
      "indent": 3,
      "text": "Two access mask bits govern the ability to delete a directory entry: ACE4_DELETE on the object itself (the \"target\") and ACE4_DELETE_CHILD on the containing directory (the \"parent\").",
      "ja": "含むディレクトリ（「親」）上でオブジェクト自体（「標的」）にACE4_DELETEとACE4_DELETE_CHILD：2つのアクセス・マスク・ビットは、ディレクトリエントリを削除する能力を支配します。"
    },
    {
      "indent": 3,
      "text": "Many systems also take the \"sticky bit\" (MODE4_SVTX) on a directory to allow unlink only to a user that owns either the target or the parent; on some such systems the decision also depends on whether the target is writable.",
      "ja": "多くのシステムはまた、唯一のターゲットまたは親のいずれかを所有しているユーザーにリンク解除を許可するディレクトリに「スティッキービット」（MODE4_SVTX）を取ります。このようないくつかのシステム上の決定はまた、ターゲットが書き込み可能であるかどうかに依存します。"
    },
    {
      "indent": 3,
      "text": "Servers SHOULD allow unlink if either ACE4_DELETE is permitted on the target, or ACE4_DELETE_CHILD is permitted on the parent. (Note that this is true even if the parent or target explicitly denies one of these permissions.)",
      "ja": "サーバはどちらかACE4_DELETEがターゲットに許可されている、またはACE4_DELETE_CHILDが親に許可されている場合は解除許可する必要があります。 （これは親またはターゲットが明示的にこれらの権限のいずれかを拒否した場合も同様であることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "If the ACLs in question neither explicitly ALLOW nor DENY either of the above, and if MODE4_SVTX is not set on the parent, then the server SHOULD allow the removal if and only if ACE4_ADD_FILE is permitted. In the case where MODE4_SVTX is set, the server may also require the remover to own either the parent or the target, or may require the target to be writable.",
      "ja": "場合は、問題のACLは、どちらも明示的に許可もDENY上記のいずれかを、そしてMODE4_SVTXが親に設定されていない場合やACE4_ADD_FILEが許可されている場合にだけ、サーバは除去を可能にしなければなりません。 MODE4_SVTXが設定されている場合、サーバは、親またはターゲットを所有する除去を必要とするかもしれない、または書き込み可能にターゲットを必要とし得ます。"
    },
    {
      "indent": 3,
      "text": "This allows servers to support something close to traditional UNIX-like semantics, with ACE4_ADD_FILE taking the place of the write bit.",
      "ja": "これは、サーバがACE4_ADD_FILEは、書き込みビットの場所を取って、伝統的なUNIXに似た意味論に近いものをサポートすることができます。"
    },
    {
      "indent": 0,
      "text": "6.2.1.4. ACE flag",
      "section_title": true,
      "ja": "6.2.1.4。 ACEフラグ"
    },
    {
      "indent": 3,
      "text": "The bitmask constants used for the flag field are as follows:",
      "ja": "次のようにフラグフィールドに使用されるビットマスク定数です。"
    },
    {
      "indent": 3,
      "text": "const ACE4_FILE_INHERIT_ACE             = 0x00000001;\nconst ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;\nconst ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;\nconst ACE4_INHERIT_ONLY_ACE             = 0x00000008;\nconst ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;\nconst ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;\nconst ACE4_IDENTIFIER_GROUP             = 0x00000040;\nconst ACE4_INHERITED_ACE                = 0x00000080;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A server need not support any of these flags. If the server supports flags that are similar to, but not exactly the same as, these flags, the implementation may define a mapping between the protocol-defined flags and the implementation-defined flags.",
      "ja": "サーバーは、これらのフラグのいずれかをサポートする必要はありません。サーバは同様に、これらのフラグは、全く同じではないフラグをサポートしている場合、実装は、プロトコル定義のフラグおよび実装定義フラグとの間のマッピングを定義することができます。"
    },
    {
      "indent": 3,
      "text": "For example, suppose a client tries to set an ACE with ACE4_FILE_INHERIT_ACE set but not ACE4_DIRECTORY_INHERIT_ACE. If the server does not support any form of ACL inheritance, the server should reject the request with NFS4ERR_ATTRNOTSUPP. If the server supports a single \"inherit ACE\" flag that applies to both files and directories, the server may reject the request (i.e., requiring the client to set both the file and directory inheritance flags). The server may also accept the request and silently turn on the ACE4_DIRECTORY_INHERIT_ACE flag.",
      "ja": "例えば、クライアントはACE4_FILE_INHERIT_ACEセットではなくACE4_DIRECTORY_INHERIT_ACEでACEを設定しようとします。サーバーは、ACLの継承のいずれかの形式をサポートしていない場合、サーバはNFS4ERR_ATTRNOTSUPPで要求を拒否しなければなりません。サーバがファイルとディレクトリの両方に適用されるシングル「継承ACE」フラグをサポートしている場合、サーバーが要求を拒否することができる（すなわち、ファイルやディレクトリの継承の両方のフラグを設定するためのクライアントを必要とします）。また、サーバは要求を受け入れ、静かACE4_DIRECTORY_INHERIT_ACEフラグをオンにすることがあります。"
    },
    {
      "indent": 0,
      "text": "6.2.1.4.1. Discussion of Flag Bits",
      "section_title": true,
      "ja": "6.2.1.4.1。フラグビットのディスカッション"
    },
    {
      "indent": 3,
      "text": "ACE4_FILE_INHERIT_ACE Any non-directory file in any sub-directory will get this ACE inherited.",
      "ja": "任意のサブディレクトリ内の任意のディレクトリ以外のファイルは、このACEが継承されますACE4_FILE_INHERIT_ACE。"
    },
    {
      "indent": 3,
      "text": "ACE4_DIRECTORY_INHERIT_ACE Can be placed on a directory and indicates that this ACE should be added to each new directory created. If this flag is set in an ACE in an ACL attribute to be set on a non-directory file system object, the operation attempting to set the ACL SHOULD fail with NFS4ERR_ATTRNOTSUPP.",
      "ja": "ACE4_DIRECTORY_INHERIT_ACEは、ディレクトリ上に配置され、このACEが作成したそれぞれの新しいディレクトリに追加されなければならないことを示していることができます。このフラグがディレクトリ以外のファイルシステムオブジェクトに設定されるACL属性でACEに設定されている場合は、ACLを設定しようとする操作がNFS4ERR_ATTRNOTSUPPで失敗すべきです。"
    },
    {
      "indent": 3,
      "text": "ACE4_NO_PROPAGATE_INHERIT_ACE Can be placed on a directory. This flag tells the server that inheritance of this ACE should stop at newly created child directories.",
      "ja": "ACE4_NO_PROPAGATE_INHERIT_ACEはディレクトリに配置することができます。このフラグは、このACEの継承が新たに作成された子ディレクトリで停止する必要があり、サーバーに指示します。"
    },
    {
      "indent": 3,
      "text": "ACE4_INHERIT_ONLY_ACE Can be placed on a directory but does not apply to the directory; ALLOW and DENY ACEs with this bit set do not affect access to the directory, and AUDIT and ALARM ACEs with this bit set do not trigger log or alarm events. Such ACEs only take effect once they are applied (with this bit cleared) to newly created files and directories as specified by the ACE4_FILE_INHERIT_ACE and ACE4_DIRECTORY_INHERIT_ACE flags.",
      "ja": "ACE4_INHERIT_ONLY_ACEはディレクトリに配置することができますが、ディレクトリには適用されません。このビットが設定された許可し、DENY ACEは、ディレクトリへのアクセスには影響しませんし、このビットがセットされたAUDITとALARM ACEは、ログやアラームイベントをトリガしません。彼らは新しく作成されたファイルとACE4_FILE_INHERIT_ACEとACE4_DIRECTORY_INHERIT_ACEフラグで指定されたディレクトリに（クリアこのビットに）適用されると、このようなACEがのみ有効になります。"
    },
    {
      "indent": 6,
      "text": "If this flag is present on an ACE, but neither ACE4_DIRECTORY_INHERIT_ACE nor ACE4_FILE_INHERIT_ACE is present, then an operation attempting to set such an attribute SHOULD fail with NFS4ERR_ATTRNOTSUPP.",
      "ja": "このフラグは、ACE上に存在するが、どちらもACE4_DIRECTORY_INHERIT_ACEもACE4_FILE_INHERIT_ACEが存在する場合、そのような属性を設定しようとする操作がNFS4ERR_ATTRNOTSUPPで失敗すべきです。"
    },
    {
      "indent": 3,
      "text": "ACE4_SUCCESSFUL_ACCESS_ACE_FLAG",
      "ja": "ACE4_SUCCESSFUL_ACCESS_ACE_FLAG"
    },
    {
      "indent": 3,
      "text": "ACE4_FAILED_ACCESS_ACE_FLAG The ACE4_SUCCESSFUL_ACCESS_ACE_FLAG (SUCCESS) and ACE4_FAILED_ACCESS_ACE_FLAG (FAILED) flag bits may be set only on ACE4_SYSTEM_AUDIT_ACE_TYPE (AUDIT) and ACE4_SYSTEM_ALARM_ACE_TYPE (ALARM) ACE types. If during the processing of the file's ACL, the server encounters an AUDIT or ALARM ACE that matches the principal attempting the OPEN, the server notes that fact, and the presence, if any, of the SUCCESS and FAILED flags encountered in the AUDIT or ALARM ACE. Once the server completes the ACL processing, it then notes if the operation succeeded or failed. If the operation succeeded, and if the SUCCESS flag was set for a matching AUDIT or ALARM ACE, then the appropriate AUDIT or ALARM event occurs. If the operation failed, and if the FAILED flag was set for the matching AUDIT or ALARM ACE, then the appropriate AUDIT or ALARM event occurs. Either or both of the SUCCESS or FAILED can be set, but if neither is set, the AUDIT or ALARM ACE is not useful.",
      "ja": "ACE4_FAILED_ACCESS_ACE_FLAGザACE4_SUCCESSFUL_ACCESS_ACE_FLAG（成功）とACE4_FAILED_ACCESS_ACE_FLAG（FAILED）のフラグビットのみACE4_SYSTEM_AUDIT_ACE_TYPE（AUDIT）とACE4_SYSTEM_ALARM_ACE_TYPE（ALARM）ACEタイプに基づいて設定してもよいです。ファイルのACLの処理中に、サーバーがOPENをしようと元本と一致したAUDITかALARM ACEを検出した場合、サーバーはその事実を指摘し、AUDITまたはALARMに遭遇成功と失敗のフラグの存在、もしあれば、エース。サーバーは、ACLの処理を完了すると、それは、操作が成功したか失敗した場合は指摘しています。操作が成功し、成功フラグをマッチングAUDITまたはアラームACEに設定された場合には、適切な監査またはアラームイベントが発生した場合。操作が失敗した場合、失敗したフラグが一致するAUDITまたはアラームACEに設定された場合には、適切な監査またはアラームイベントが発生します。いずれかまたはSUCCESSの両方またはFAILEDを設定することができますが、どちらも設定されていない場合、AUDITまたはALARM ACEは有用ではありません。"
    },
    {
      "indent": 6,
      "text": "The previously described processing applies to ACCESS operations even when they return NFS4_OK. For the purposes of AUDIT and ALARM, we consider an ACCESS operation to be a \"failure\" if it fails to return a bit that was requested and supported.",
      "ja": "彼らはNFS4_OKを返す場合でも、前述の処理は、アクセス操作に適用されます。 AUDITとALARMの目的のために、我々はそれが要求され、サポートされたビットを返すことに失敗した場合、アクセス操作は「失敗」であると考えています。"
    },
    {
      "indent": 3,
      "text": "ACE4_IDENTIFIER_GROUP Indicates that the \"who\" refers to a GROUP as defined under UNIX or a GROUP ACCOUNT as defined under Windows. Clients and servers MUST ignore the ACE4_IDENTIFIER_GROUP flag on ACEs with a who value equal to one of the special identifiers outlined in Section 6.2.1.5.",
      "ja": "ACE4_IDENTIFIER_GROUPは、Windowsの下で定義されているUNIXまたはグループアカウントの下で定義される「誰が」基を意味することを示します。クライアントとサーバーは、セクション6.2.1.5に概説特別な識別子の1に等しい値、誰とACEでACE4_IDENTIFIER_GROUPフラグを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "ACE4_INHERITED_ACE Indicates that this ACE is inherited from a parent directory. A server that supports automatic inheritance will place this flag on any ACEs inherited from the parent directory when creating a new object. Client applications will use this to perform automatic inheritance. Clients and servers MUST clear this bit in the acl attribute; it may only be used in the dacl and sacl attributes.",
      "ja": "ACE4_INHERITED_ACEは、このACEは、親ディレクトリから継承されていることを示します。自動継承をサポートするサーバは、新しいオブジェクトを作成するときに、親ディレクトリから継承するACEに、このフラグを配置します。クライアントアプリケーションは、自動継承を実行するためにこれを使用します。クライアントとサーバーは、ACL属性で、このビットをクリアしなければなりません。それが唯一のDACLとSACLの属性で使用することができます。"
    },
    {
      "indent": 0,
      "text": "6.2.1.5. ACE Who",
      "section_title": true,
      "ja": "6.2.1.5。 ACEは誰"
    },
    {
      "indent": 3,
      "text": "The \"who\" field of an ACE is an identifier that specifies the principal or principals to whom the ACE applies. It may refer to a user or a group, with the flag bit ACE4_IDENTIFIER_GROUP specifying which.",
      "ja": "ACEの「人」フィールドには、ACEの適用対象に元本またはプリンシパルを特定する識別子です。それは、フラグビットACE4_IDENTIFIER_GROUPを指定して、ユーザまたはグループを指すことができます。"
    },
    {
      "indent": 3,
      "text": "There are several special identifiers that need to be understood universally, rather than in the context of a particular DNS domain. Some of these identifiers cannot be understood when an NFS client accesses the server, but have meaning when a local process accesses the file. The ability to display and modify these permissions is permitted over NFS, even if none of the access methods on the server understands the identifiers.",
      "ja": "むしろ、特定のDNSドメインの文脈におけるよりも、普遍的に理解する必要があるいくつかの特別な識別子があります。これらの識別子の一部は、NFSクライアントがサーバにアクセスするときに理解することはできませんが、ローカルプロセスがファイルにアクセスしたときに意味しています。表示し、これらの権限を変更する機能は、サーバ上のアクセス方法のどれもが識別子を理解していない場合でも、NFS上で許可されています。"
    },
    {
      "indent": 3,
      "text": "+---------------+--------------------------------------------------+\n| Who           | Description                                      |\n+---------------+--------------------------------------------------+\n| OWNER         | The owner of the file.                           |\n| GROUP         | The group associated with the file.              |\n| EVERYONE      | The world, including the owner and owning group. |\n| INTERACTIVE   | Accessed from an interactive terminal.           |\n| NETWORK       | Accessed via the network.                        |\n| DIALUP        | Accessed as a dialup user to the server.         |\n| BATCH         | Accessed from a batch job.                       |\n| ANONYMOUS     | Accessed without any authentication.             |\n| AUTHENTICATED | Any authenticated user (opposite of ANONYMOUS).  |\n| SERVICE       | Access from a system service.                    |\n+---------------+--------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 4",
      "ja": "表4"
    },
    {
      "indent": 3,
      "text": "To avoid conflict, these special identifiers are distinguished by an appended \"@\" and should appear in the form \"xxxx@\" (with no domain name after the \"@\"), for example, ANONYMOUS@.",
      "ja": "競合を避けるために、これらの特別な識別子は、ANONYMOUS @例えば、「@」追加され、（「@」の後にノードメイン名を持つ）フォーム「XXXXの@」に表示されるはずで区別されています。"
    },
    {
      "indent": 3,
      "text": "The ACE4_IDENTIFIER_GROUP flag MUST be ignored on entries with these special identifiers. When encoding entries with these special identifiers, the ACE4_IDENTIFIER_GROUP flag SHOULD be set to zero.",
      "ja": "ACE4_IDENTIFIER_GROUPフラグは、これらの特別な識別子を持つエントリで無視しなければなりません。これらの特別な識別子を持つエントリを符号化するとき、ACE4_IDENTIFIER_GROUPフラグがゼロに設定されるべきです。"
    },
    {
      "indent": 0,
      "text": "6.2.1.5.1. Discussion of EVERYONE@",
      "section_title": true,
      "ja": "6.2.1.5.1。 EVERYONEの議論@"
    },
    {
      "indent": 3,
      "text": "It is important to note that \"EVERYONE@\" is not equivalent to the UNIX \"other\" entity. This is because, by definition, UNIX \"other\" does not include the owner or owning group of a file. \"EVERYONE@\" means literally everyone, including the owner or owning group.",
      "ja": "「誰もが@」UNIX「その他」の実体と等価ではないことに注意することが重要です。定義により、UNIXは、ファイルの所有者または所有グループを「その他」は含まれないためです。 「EVERYONEは、@」所有者または所有グループを含む文字通り皆を意味します。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Attribute 58: dacl",
      "section_title": true,
      "ja": "6.2.2.  58属性：タックル"
    },
    {
      "indent": 3,
      "text": "The dacl attribute is like the acl attribute, but dacl allows just ALLOW and DENY ACEs. The dacl attribute supports automatic inheritance (see Section 6.4.3.2).",
      "ja": "DACL属性は、ACL属性に似ているが、DACLはただのACEを許可し、DENYことができます。 DACL属性が自動継承を（セクション6.4.3.2を参照）をサポートしています。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Attribute 59: sacl",
      "section_title": true,
      "ja": "6.2.3.  59属性：SACL"
    },
    {
      "indent": 3,
      "text": "The sacl attribute is like the acl attribute, but sacl allows just AUDIT and ALARM ACEs. The sacl attribute supports automatic inheritance (see Section 6.4.3.2).",
      "ja": "SACL属性はACL属性と似ていますが、SACLはちょうどAUDITとALARM ACEを可能にします。 SACL属性は、自動継承を（セクション6.4.3.2を参照）をサポートしています。"
    },
    {
      "indent": 0,
      "text": "6.2.4. Attribute 33: mode",
      "section_title": true,
      "ja": "6.2.4. 属性33：モード"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 mode attribute is based on the UNIX mode bits. The following bits are defined:",
      "ja": "NFSv4.1モード属性は、UNIXモード・ビットに基づいています。次のビットが定義されています。"
    },
    {
      "indent": 3,
      "text": "const MODE4_SUID = 0x800;  /* set user id on execution */\nconst MODE4_SGID = 0x400;  /* set group id on execution */\nconst MODE4_SVTX = 0x200;  /* save text even after use */\nconst MODE4_RUSR = 0x100;  /* read permission: owner */\nconst MODE4_WUSR = 0x080;  /* write permission: owner */\nconst MODE4_XUSR = 0x040;  /* execute permission: owner */\nconst MODE4_RGRP = 0x020;  /* read permission: group */\nconst MODE4_WGRP = 0x010;  /* write permission: group */\nconst MODE4_XGRP = 0x008;  /* execute permission: group */\nconst MODE4_ROTH = 0x004;  /* read permission: other */\nconst MODE4_WOTH = 0x002;  /* write permission: other */\nconst MODE4_XOTH = 0x001;  /* execute permission: other */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Bits MODE4_RUSR, MODE4_WUSR, and MODE4_XUSR apply to the principal identified in the owner attribute. Bits MODE4_RGRP, MODE4_WGRP, and MODE4_XGRP apply to principals identified in the owner_group attribute but who are not identified in the owner attribute. Bits MODE4_ROTH, MODE4_WOTH, and MODE4_XOTH apply to any principal that does not match that in the owner attribute and does not have a group matching that of the owner_group attribute.",
      "ja": "ビットMODE4_RUSR、MODE4_WUSR、及びMODE4_XUSRは、所有者の属性で識別されたプリンシパルに適用されます。ビットMODE4_RGRP、MODE4_WGRP、およびMODE4_XGRPは、所有者の属性で識別されていないowner_group属性で識別プリンシパルだけに適用されます。ビットMODE4_ROTH、MODE4_WOTH、及びMODE4_XOTHは、所有者属性に一致しないとowner_group属性と一致する基を有さない任意のプリンシパルに適用されます。"
    },
    {
      "indent": 3,
      "text": "Bits within a mode other than those specified above are not defined by this protocol. A server MUST NOT return bits other than those defined above in a GETATTR or READDIR operation, and it MUST return NFS4ERR_INVAL if bits other than those defined above are set in a SETATTR, CREATE, OPEN, VERIFY, or NVERIFY operation.",
      "ja": "上記以外のモード内のビットは、このプロトコルで定義されていません。サーバはGETATTR又はREADDIR操作で上記に定義されるもの以外のビットを返してはいけません、そして、それは上記で定義されたもの以外のビットはSETATTRに設定されている場合、NFS4ERR_INVALを返すCREATE、OPEN、VERIFY、又はNVERIFY動作しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2.5. Attribute 74: mode_set_masked",
      "section_title": true,
      "ja": "6.2.5. 属性74：mode_set_masked"
    },
    {
      "indent": 3,
      "text": "The mode_set_masked attribute is a write-only attribute that allows individual bits in the mode attribute to be set or reset, without changing others. It allows, for example, the bits MODE4_SUID, MODE4_SGID, and MODE4_SVTX to be modified while leaving unmodified any of the nine low-order mode bits devoted to permissions.",
      "ja": "mode_set_masked属性が他の人を変更することなく、モード属性の個々のビットがセットまたはリセットされることを可能にする書き込み専用属性です。権限に専念9低次モードビットの任意の非修飾を残して、それは、例えば、ビットMODE4_SUID、MODE4_SGID、及びMODE4_SVTXを変更することが、可能となります。"
    },
    {
      "indent": 3,
      "text": "In such instances that the nine low-order bits are left unmodified, then neither the acl nor the dacl attribute should be automatically modified as discussed in Section 6.4.1.",
      "ja": "セクション6.4.1で説明したように9下位ビットは、その後、未修飾残されるような場合に、ACLもDACL属性のいずれも自動的に変更されるべきです。"
    },
    {
      "indent": 3,
      "text": "The mode_set_masked attribute consists of two words, each in the form of a mode4. The first consists of the value to be applied to the current mode value and the second is a mask. Only bits set to one in the mask word are changed (set or reset) in the file's mode. All other bits in the mode remain unchanged. Bits in the first word that correspond to bits that are zero in the mask are ignored, except that undefined bits are checked for validity and can result in NFS4ERR_INVAL as described below.",
      "ja": "mode_set_masked属性は二つの単語、MODE4の形でそれぞれ構成されています。最初は、現在のモード値に適用される値で構成され、第二のマスクです。マスク・ワードにいずれかに設定のみのビットは、ファイルのモード（セットまたはリセット）に変更されています。モードの他のすべてのビットは変更されません。その未定義のビットは有効性がチェックされ、以下に説明するようにNFS4ERR_INVALをもたらすことができる以外はマスクでゼロであるビットに対応する最初のワードのビットは、無視されます。"
    },
    {
      "indent": 3,
      "text": "The mode_set_masked attribute is only valid in a SETATTR operation. If it is used in a CREATE or OPEN operation, the server MUST return NFS4ERR_INVAL.",
      "ja": "mode_set_masked属性は、SETATTR操作でのみ有効です。それは、CREATEやOPEN操作で使用されている場合、サーバーはNFS4ERR_INVALを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Bits not defined as valid in the mode attribute are not valid in either word of the mode_set_masked attribute. The server MUST return NFS4ERR_INVAL if any such bits are set to one in a SETATTR. If the mode and mode_set_masked attributes are both specified in the same SETATTR, the server MUST also return NFS4ERR_INVAL.",
      "ja": "mode属性に有効なものとして定義されていないビットはmode_set_masked属性のいずれかの単語には有効ではありません。このようなビットがSETATTRに1に設定されている場合、サーバはNFS4ERR_INVALを返さなければなりません。モードとmode_set_masked属性は両方とも同じSETATTRに指定されている場合は、サーバーもNFS4ERR_INVALを返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.3. Common Methods",
      "section_title": true,
      "ja": "6.3. 共通メソッド"
    },
    {
      "indent": 3,
      "text": "The requirements in this section will be referred to in future sections, especially Section 6.4.",
      "ja": "このセクションの要件は、特に6.4節、将来のセクションで呼ぶことにします。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Interpreting an ACL",
      "section_title": true,
      "ja": "6.3.1.  ACLの解釈"
    },
    {
      "indent": 0,
      "text": "6.3.1.1. Server Considerations",
      "section_title": true,
      "ja": "6.3.1.1。サーバーの考慮事項"
    },
    {
      "indent": 3,
      "text": "The server uses the algorithm described in Section 6.2.1 to determine whether an ACL allows access to an object. However, the ACL might not be the sole determiner of access. For example:",
      "ja": "サーバは、ACLがオブジェクトへのアクセスを許可するかどうかを決定するために、セクション6.2.1に記載したアルゴリズムを使用します。しかし、ACLは、アクセスの唯一の決定ではないかもしれません。例えば："
    },
    {
      "indent": 3,
      "text": "o In the case of a file system exported as read-only, the server may deny write access even though an object's ACL grants it.",
      "ja": "O読み取り専用としてエクスポートされたファイルシステムの場合、サーバーは、オブジェクトのACLはそれを許可していても書き込みアクセスを拒否することができます。"
    },
    {
      "indent": 3,
      "text": "o Server implementations MAY grant ACE4_WRITE_ACL and ACE4_READ_ACL permissions to prevent a situation from arising in which there is no valid way to ever modify the ACL.",
      "ja": "Oサーバーの実装は、これまでACLを変更するための有効な方法はありませんここで生じるの事態を防ぐためにACE4_WRITE_ACLとACE4_READ_ACL権限を付与することができます。"
    },
    {
      "indent": 3,
      "text": "o All servers will allow a user the ability to read the data of the file when only the execute permission is granted (i.e., if the ACL denies the user the ACE4_READ_DATA access and allows the user ACE4_EXECUTE, the server will allow the user to read the data of the file).",
      "ja": "唯一の実行権限が付与されたときに、OのすべてのサーバーはACLがユーザーにACE4_READ_DATAのアクセスを拒否し、ユーザーACE4_EXECUTEを許可する場合、すなわち、サーバは、ユーザが読めるようになります（ユーザーがファイルのデータを読み取る能力をできるようになりますファイルのデータ）。"
    },
    {
      "indent": 3,
      "text": "o Many servers have the notion of owner-override in which the owner of the object is allowed to override accesses that are denied by the ACL. This may be helpful, for example, to allow users continued access to open files on which the permissions have changed.",
      "ja": "Oサーバの多くは、オブジェクトの所有者は、ACLによって拒否されたアクセスを無効にすることが許されている所有者、オーバーライドの概念を持っています。これにより、ユーザーは権限が変更された上でファイルを開くためのアクセスを引き続き許可するように、例えば、役立つかもしれません。"
    },
    {
      "indent": 3,
      "text": "o Many servers have the notion of a \"superuser\" that has privileges beyond an ordinary user. The superuser may be able to read or write data or metadata in ways that would not be permitted by the ACL.",
      "ja": "Oサーバの多くは、通常のユーザーを超えた権限を持つ「スーパーユーザ」の概念を持っています。スーパーユーザは、ACLによって許可されない方法でデータやメタデータを読み書きすることができるかもしれません。"
    },
    {
      "indent": 3,
      "text": "o A retention attribute might also block access otherwise allowed by ACLs (see Section 5.13).",
      "ja": "O保持属性はまた、そうでない場合はACLで許可されたアクセスをブロックするかもしれない（5.13項を参照してください）。"
    },
    {
      "indent": 0,
      "text": "6.3.1.2. Client Considerations",
      "section_title": true,
      "ja": "6.3.1.2。クライアントの考慮事項"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD NOT do their own access checks based on their interpretation of the ACL, but rather use the OPEN and ACCESS operations to do access checks. This allows the client to act on the results of having the server determine whether or not access should be granted based on its interpretation of the ACL.",
      "ja": "クライアントは、ACLの彼らの解釈に基づいて、独自のアクセスチェックを行うのではなく、アクセスチェックを行うためにOPENし、アクセスする操作を使用しないでください。これにより、クライアントは、サーバがアクセスがACLの解釈に基づいて許可されるべきかどうかを判断した結果に基づいて行動することができます。"
    },
    {
      "indent": 3,
      "text": "Clients must be aware of situations in which an object's ACL will define a certain access even though the server will not enforce it. In general, but especially in these situations, the client needs to do its part in the enforcement of access as defined by the ACL. To do this, the client MAY send the appropriate ACCESS operation prior to servicing the request of the user or application in order to determine whether the user or application should be granted the access requested. For examples in which the ACL may define accesses that the server doesn't enforce, see Section 6.3.1.1.",
      "ja": "クライアントは、サーバがそれを強制しないであろうにもかかわらず、オブジェクトのACLは、特定のアクセスを定義しますする状況を認識する必要があります。一般的に、しかし、特にこのような状況では、クライアントは、ACLで定義されたアクセスの施行にその一部を行う必要があります。これを行うには、クライアントは、前のユーザーやアプリケーションが要求されたアクセス権を付与する必要があるかどうかを判断するために、ユーザーまたはアプリケーションの要求にサービスを提供し、適切なアクセス動作を送信することができます。 ACLを定義することができた例についてサーバは、セクション6.3.1.1を参照し、強制しないことにアクセスします。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Computing a Mode Attribute from an ACL",
      "section_title": true,
      "ja": "6.3.2.  ACLからのモード属性を計算"
    },
    {
      "indent": 3,
      "text": "The following method can be used to calculate the MODE4_R*, MODE4_W*, and MODE4_X* bits of a mode attribute, based upon an ACL.",
      "ja": "以下の方法は、ACLに基づいて、モード属性のMODE4_R *、MODE4_W *、及びMODE4_X *ビットを計算するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "First, for each of the special identifiers OWNER@, GROUP@, and EVERYONE@, evaluate the ACL in order, considering only ALLOW and DENY ACEs for the identifier EVERYONE@ and for the identifier under consideration. The result of the evaluation will be an NFSv4 ACL mask showing exactly which bits are permitted to that identifier.",
      "ja": "まず、特別な識別子の所有者@、group @、およびeveryoneする@ごとに、識別子EVERYONEの@のためにと検討中の識別子のためにのみ許可し、DENY ACEを考慮すると、順番にACLを評価します。評価の結果は、ビットがその識別子に許可されている正確に示すのNFSv4 ACLマスクであろう。"
    },
    {
      "indent": 3,
      "text": "Then translate the calculated mask for OWNER@, GROUP@, and EVERYONE@ into mode bits for, respectively, the user, group, and other, as follows:",
      "ja": "次のように、所有者@、グループ@、それぞれ、ユーザ、グループ、その他、のためのモードビットに@皆のための計算されたマスクを翻訳："
    },
    {
      "indent": 3,
      "text": "1. Set the read bit (MODE4_RUSR, MODE4_RGRP, or MODE4_ROTH) if and only if ACE4_READ_DATA is set in the corresponding mask.",
      "ja": "1.設定ACE4_READ_DATAは、対応するマスクに設定されている場合に限り、読み取りビット（MODE4_RUSR、MODE4_RGRP、又はMODE4_ROTH）。"
    },
    {
      "indent": 3,
      "text": "2. Set the write bit (MODE4_WUSR, MODE4_WGRP, or MODE4_WOTH) if and only if ACE4_WRITE_DATA and ACE4_APPEND_DATA are both set in the corresponding mask.",
      "ja": "2.書き込みビット（MODE4_WUSR、MODE4_WGRP、又はMODE4_WOTH）IFおよびACE4_WRITE_DATAとACE4_APPEND_DATAの両方対応するマスクに設定されている場合のみ。"
    },
    {
      "indent": 3,
      "text": "3. Set the execute bit (MODE4_XUSR, MODE4_XGRP, or MODE4_XOTH), if and only if ACE4_EXECUTE is set in the corresponding mask.",
      "ja": "3. ACE4_EXECUTEが対応するマスクに設定されている場合に限り、（MODE4_XUSR、MODE4_XGRP、又はMODE4_XOTH）実行ビットを設定します。"
    },
    {
      "indent": 0,
      "text": "6.3.2.1. Discussion",
      "section_title": true,
      "ja": "6.3.2.1。討論"
    },
    {
      "indent": 3,
      "text": "Some server implementations also add bits permitted to named users and groups to the group bits (MODE4_RGRP, MODE4_WGRP, and MODE4_XGRP).",
      "ja": "一部のサーバーの実装は、グループ・ビット（MODE4_RGRP、MODE4_WGRP、およびMODE4_XGRP）への指定ユーザーおよびグループに許可ビットを追加します。"
    },
    {
      "indent": 3,
      "text": "Implementations are discouraged from doing this, because it has been found to cause confusion for users who see members of a file's group denied access that the mode bits appear to allow. (The presence of DENY ACEs may also lead to such behavior, but DENY ACEs are expected to be more rarely used.)",
      "ja": "ファイルのグループのメンバーは、モードビットが許可するように見えるのアクセスを拒否された参照のユーザーのための混乱を引き起こすことが分かっているので、実装は、これをやってから、落胆しています。 （DENY ACEの存在はまた、そのような挙動につながるが、ACEのがよりめったに使用されないことが期待されて拒否することができます。）"
    },
    {
      "indent": 3,
      "text": "The same user confusion seen when fetching the mode also results if setting the mode does not effectively control permissions for the owner, group, and other users; this motivates some of the requirements that follow.",
      "ja": "モードを設定すると効果的に所有者、グループ、および他のユーザーの権限を制御しない場合のモードをフェッチするときに見られる同一のユーザの混乱も生じます。これは続く要件の一部を動機付けます。"
    },
    {
      "indent": 0,
      "text": "6.4. Requirements",
      "section_title": true,
      "ja": "6.4. 必要条件"
    },
    {
      "indent": 3,
      "text": "The server that supports both mode and ACL must take care to synchronize the MODE4_*USR, MODE4_*GRP, and MODE4_*OTH bits with the ACEs that have respective who fields of \"OWNER@\", \"GROUP@\", and \"EVERYONE@\". This way, the client can see if semantically equivalent access permissions exist whether the client asks for the owner, owner_group, and mode attributes or for just the ACL.",
      "ja": "モードとACLの両方をサポートするサーバーは、それぞれの人「OWNER @」、「グループ@」のフィールド、および「EVERYONEを持っているのACEとMODE4_ * USR、MODE4_ * GRP、およびMODE4_ * OTHビットを同期するために注意しなければなりません@ 」。意味的に同等のアクセス権限は、クライアントがowner_group、所有者を要求するかどうかが存在する場合は、この方法では、クライアントが見ることができ、かつモードがちょうどACL属性または。"
    },
    {
      "indent": 3,
      "text": "In this section, much is made of the methods in Section 6.3.2. Many requirements refer to this section. But note that the methods have behaviors specified with \"SHOULD\". This is intentional, to avoid invalidating existing implementations that compute the mode according to the withdrawn POSIX ACL draft (1003.1e draft 17), rather than by actual permissions on owner, group, and other.",
      "ja": "このセクションでは、多くの6.3.2項に方法で作られています。多くの要件は、このセクションを参照してください。しかし、方法は「SHOULD」で指定された振る舞いを持っていることに注意してください。これは、引き出さPOSIX ACLドラフト（1003.1eでドラフト17）にではなく、所有者、グループ、および他の実際の許可によってかかるモードを計算する既存の実装を無効に回避するために、意図的です。"
    },
    {
      "indent": 0,
      "text": "6.4.1. Setting the Mode and/or ACL Attributes",
      "section_title": true,
      "ja": "6.4.1. モードおよび/またはACL属性の設定"
    },
    {
      "indent": 3,
      "text": "In the case where a server supports the sacl or dacl attribute, in addition to the acl attribute, the server MUST fail a request to set the acl attribute simultaneously with a dacl or sacl attribute. The error to be given is NFS4ERR_ATTRNOTSUPP.",
      "ja": "サーバがSACLまたはDACL属性をサポートする場合には、ACL属性に加えて、サーバは、DACLまたはSACL属性と同時にACL属性を設定する要求に失敗しなければなりません。与えられるべきエラーがNFS4ERR_ATTRNOTSUPPです。"
    },
    {
      "indent": 0,
      "text": "6.4.1.1. Setting Mode and not ACL",
      "section_title": true,
      "ja": "6.4.1.1。設定モードではなくACL"
    },
    {
      "indent": 3,
      "text": "When any of the nine low-order mode bits are subject to change, either because the mode attribute was set or because the mode_set_masked attribute was set and the mask included one or more bits from the nine low-order mode bits, and no ACL attribute is explicitly set, the acl and dacl attributes must be modified in accordance with the updated value of those bits. This must happen even if the value of the low-order bits is the same after the mode is set as before.",
      "ja": "9低次モードビットのいずれかが変更される場合があり、いずれのモード属性が設定されていたためか、mode_set_masked属性が設定され、マスクは、9つの低次モードビット、およびno ACL属性から1つ以上のビットが含まれていたため、場合明示的に設定され、ACLおよびDACL属性は、これらのビットの更新された値に応じて変更しなければなりません。これは、モードは以前のように設定された後、下位ビットの値が同じであっても起こらなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that any AUDIT or ALARM ACEs (hence any ACEs in the sacl attribute) are unaffected by changes to the mode.",
      "ja": "任意AUDITまたはアラームのACE（SACL属性内したがって任意のACE）のモードへの変更によって影響を受けないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "In cases in which the permissions bits are subject to change, the acl and dacl attributes MUST be modified such that the mode computed via the method in Section 6.3.2 yields the low-order nine bits (MODE4_R*, MODE4_W*, MODE4_X*) of the mode attribute as modified by the attribute change. The ACL attributes SHOULD also be modified such that:",
      "ja": "パーミッションビットが変更される場合がありする場合には、ACLおよびDACL属性は、セクション6.3.2方法によって計算モードが下位9ビット（MODE4_R *、MODE4_W *、MODE4_X *）が得られるように修正されなければなりませんmode属性のように、属性の変更によって変更されました。 ACL属性はまた、そのようなことを変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. If MODE4_RGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_READ_DATA.",
      "ja": "MODE4_RGRPが設定されていない場合1.、明示的に所有者@とEVERYONEの@以外のACLに記載されているエンティティはACE4_READ_DATAを付与されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "2. If MODE4_WGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_WRITE_DATA or ACE4_APPEND_DATA.",
      "ja": "MODE4_WGRPが設定されていない場合は2、明示的に所有者@とEVERYONEの@以外のACLに記載されているエンティティはACE4_WRITE_DATAまたはACE4_APPEND_DATAを付与されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "3. If MODE4_XGRP is not set, entities explicitly listed in the ACL other than OWNER@ and EVERYONE@ SHOULD NOT be granted ACE4_EXECUTE.",
      "ja": "MODE4_XGRPが設定されていない場合3.、明示的に所有者@とEVERYONEの@以外のACLに記載されているエンティティはACE4_EXECUTEを付与されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Access mask bits other than those listed above, appearing in ALLOW ACEs, MAY also be disabled.",
      "ja": "ACEをALLOWに現れる上記以外のアクセス・マスク・ビットは、また、ディセーブルされます。"
    },
    {
      "indent": 3,
      "text": "Note that ACEs with the flag ACE4_INHERIT_ONLY_ACE set do not affect the permissions of the ACL itself, nor do ACEs of the type AUDIT and ALARM. As such, it is desirable to leave these ACEs unmodified when modifying the ACL attributes.",
      "ja": "フラグACE4_INHERIT_ONLY_ACEセットでACEは注意がACL自体の権限に影響を与え、NOR型AUDITとALARMのACEを行いません。このように、ACL属性を変更する際、未修飾これらのACEを残すことが望ましいです。"
    },
    {
      "indent": 3,
      "text": "Also note that the requirement may be met by discarding the acl and dacl, in favor of an ACL that represents the mode and only the mode. This is permitted, but it is preferable for a server to preserve as much of the ACL as possible without violating the above requirements. Discarding the ACL makes it effectively impossible for a file created with a mode attribute to inherit an ACL (see Section 6.4.3).",
      "ja": "また、要件はモードと専用モードを表しACLの賛成で、ACLとDACLを捨てることによって満たすことができることに注意してください。これは許可するが、サーバが上記の要件に違反することなく、可能なACLの多くを保持することが好適です。 ACLを破棄すること（6.4.3項を参照）ACLを継承するモード属性で作成されたファイルのためにそれが効果的にできなくなります。"
    },
    {
      "indent": 0,
      "text": "6.4.1.2. Setting ACL and Not Mode",
      "section_title": true,
      "ja": "6.4.1.2。設定ACLとNotモード"
    },
    {
      "indent": 3,
      "text": "When setting the acl or dacl and not setting the mode or mode_set_masked attributes, the permission bits of the mode need to be derived from the ACL. In this case, the ACL attribute SHOULD be set as given. The nine low-order bits of the mode attribute (MODE4_R*, MODE4_W*, MODE4_X*) MUST be modified to match the result of the method in Section 6.3.2. The three high-order bits of the mode (MODE4_SUID, MODE4_SGID, MODE4_SVTX) SHOULD remain unchanged.",
      "ja": "ACLまたはDACLを設定し、モードやmode_set_masked属性を設定しない場合、モードの許可ビットがACLから派生する必要があります。与えられたとして、この場合、ACL属性を設定する必要があります。モード属性（MODE4_R *、MODE4_W *、MODE4_X *）の9下位ビットは、セクション6.3.2における方法の結果と一致するように修正されなければなりません。モード（MODE4_SUID、MODE4_SGID、MODE4_SVTX）の上位3ビットは不変べきです。"
    },
    {
      "indent": 0,
      "text": "6.4.1.3. Setting Both ACL and Mode",
      "section_title": true,
      "ja": "6.4.1.3。 ACLとモードの両方を設定します"
    },
    {
      "indent": 3,
      "text": "When setting both the mode (includes use of either the mode attribute or the mode_set_masked attribute) and the acl or dacl attributes in the same operation, the attributes MUST be applied in this order: mode (or mode_set_masked), then ACL. The mode-related attribute is set as given, then the ACL attribute is set as given, possibly changing the final mode, as described above in Section 6.4.1.2.",
      "ja": "ACL次に、モード（又はmode_set_masked）モード（モード属性またはmode_set_masked属性のいずれかの使用を含む）と同じ操作でACLまたはDACL属性の両方を設定する際に、属性がこの順で適用されなければなりません。与えられたモードに関連する属性が設定されて与えられるように、セクション6.4.1.2に上述したように、その後、ACL属性は、おそらく最終的なモードを変更、設定されています。"
    },
    {
      "indent": 0,
      "text": "6.4.2. Retrieving the Mode and/or ACL Attributes",
      "section_title": true,
      "ja": "6.4.2. モードおよび/またはACL属性の取得"
    },
    {
      "indent": 3,
      "text": "This section applies only to servers that support both the mode and ACL attributes.",
      "ja": "このセクションでは、専用モードとACLの属性の両方をサポートするサーバーに適用されます。"
    },
    {
      "indent": 3,
      "text": "Some server implementations may have a concept of \"objects without ACLs\", meaning that all permissions are granted and denied according to the mode attribute and that no ACL attribute is stored for that object. If an ACL attribute is requested of such a server, the server SHOULD return an ACL that does not conflict with the mode; that is to say, the ACL returned SHOULD represent the nine low-order bits of the mode attribute (MODE4_R*, MODE4_W*, MODE4_X*) as described in Section 6.3.2.",
      "ja": "一部のサーバーの実装は、すべての権限が付与されたと拒否されたモードの属性に応じてと何のACL属性がそのオブジェクトのために格納されていないことをされていることを意味し、「ACLのなしのオブジェクト」の概念を持つことができます。 ACL属性は、このようなサーバーに要求されている場合は、サーバーモードと競合しないACLを返すべきです。すなわち、ACLは、セクション6.3.2に記載したようにモード属性（MODE4_R *、MODE4_W *、MODE4_X *）の9下位ビットを表現して下さい返さ。"
    },
    {
      "indent": 3,
      "text": "For other server implementations, the ACL attribute is always present for every object. Such servers SHOULD store at least the three high-order bits of the mode attribute (MODE4_SUID, MODE4_SGID, MODE4_SVTX). The server SHOULD return a mode attribute if one is requested, and the low-order nine bits of the mode (MODE4_R*, MODE4_W*, MODE4_X*) MUST match the result of applying the method in Section 6.3.2 to the ACL attribute.",
      "ja": "他のサーバーの実装では、ACL属性は常に、すべてのオブジェクトのために存在しています。そのようなサーバは、モード属性（MODE4_SUID、MODE4_SGID、MODE4_SVTX）少なくとも3つの上位ビットを格納する必要があります。一つは要求された場合、サーバは、モード属性を返す必要があり、モード（MODE4_R *、MODE4_W *、MODE4_X *）の下位9ビットは、ACL属性にセクション6.3.2方法を適用した結果と一致しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.4.3. Creating New Objects",
      "section_title": true,
      "ja": "6.4.3. 新しいオブジェクトの作成"
    },
    {
      "indent": 3,
      "text": "If a server supports any ACL attributes, it may use the ACL attributes on the parent directory to compute an initial ACL attribute for a newly created object. This will be referred to as the inherited ACL within this section. The act of adding one or more ACEs to the inherited ACL that are based upon ACEs in the parent directory's ACL will be referred to as inheriting an ACE within this section.",
      "ja": "サーバーは、任意のACL属性をサポートしている場合、それはACLが、新しく作成されたオブジェクトの初期ACL属性を計算するために、親ディレクトリの属性使用することができます。これは、このセクション内で継承されたACLと呼ぶことにします。親ディレクトリのACL内のACEに基づいています継承されたACLへの1つのまたは複数のACEを追加することの行為は、このセクション内のACEを継承と呼ぶことにします。"
    },
    {
      "indent": 3,
      "text": "Implementors should standardize what the behavior of CREATE and OPEN must be depending on the presence or absence of the mode and ACL attributes.",
      "ja": "実装者は、CREATEやOPENの動作モードとACL属性の有無によってしなければならないものを標準化する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. If just the mode is given in the call:",
      "section_title": true,
      "ja": "1.ちょうどモードは呼び出しで指定されている場合："
    },
    {
      "indent": 7,
      "text": "In this case, inheritance SHOULD take place, but the mode MUST be\napplied to the inherited ACL as described in Section 6.4.1.1,\nthereby modifying the ACL.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. If just the ACL is given in the call:",
      "section_title": true,
      "ja": "2.ちょうどACLは呼び出しで指定されている場合："
    },
    {
      "indent": 7,
      "text": "In this case, inheritance SHOULD NOT take place, and the ACL as\ndefined in the CREATE or OPEN will be set without modification,\nand the mode modified as in Section 6.4.1.2.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. If both mode and ACL are given in the call:",
      "section_title": true,
      "ja": "3.モードとACLの両方がコールに与えられている場合："
    },
    {
      "indent": 7,
      "text": "In this case, inheritance SHOULD NOT take place, and both\nattributes will be set as described in Section 6.4.1.3.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4. If neither mode nor ACL is given in the call:",
      "section_title": true,
      "ja": "4.どちらのモードでもACLは呼び出しで指定されている場合："
    },
    {
      "indent": 7,
      "text": "In the case where an object is being created without any initial\nattributes at all, e.g., an OPEN operation with an opentype4 of\nOPEN4_CREATE and a createmode4 of EXCLUSIVE4, inheritance SHOULD\nNOT take place (note that EXCLUSIVE4_1 is a better choice of\ncreatemode4, since it does permit initial attributes).  Instead,\nthe server SHOULD set permissions to deny all access to the newly\ncreated object.  It is expected that the appropriate client will\nset the desired attributes in a subsequent SETATTR operation, and\nthe server SHOULD allow that operation to succeed, regardless of\nwhat permissions the object is created with.  For example, an\nempty ACL denies all permissions, but the server should allow the\nowner's SETATTR to succeed even though WRITE_ACL is implicitly\ndenied.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "In other cases, inheritance SHOULD take place, and no modifications to the ACL will happen. The mode attribute, if supported, MUST be as computed in Section 6.3.2, with the MODE4_SUID, MODE4_SGID, and MODE4_SVTX bits clear. If no inheritable ACEs exist on the parent directory, the rules for creating acl, dacl, or sacl attributes are implementation defined. If either the dacl or sacl attribute is supported, then the ACL4_DEFAULTED flag SHOULD be set on the newly created attributes.",
      "ja": "他の例では、継承は行われるべきである、とACLへの変更は起こりません。セクション6.3.2で計算さモード属性は、サポートされている場合、MODE4_SUID、MODE4_SGID、及びMODE4_SVTXビットで、明確でなければなりません。何の継承可能なACEが親ディレクトリに存在しない場合は、ACL、DACL、またはSACLの属性を作成するための規則は、実装が定義されています。 DACLまたはSACL属性のいずれかがサポートされている場合は、ACL4_DEFAULTEDフラグは、新しく作成された属性に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.4.3.1. The Inherited ACL",
      "section_title": true,
      "ja": "6.4.3.1。継承ACL"
    },
    {
      "indent": 3,
      "text": "If the object being created is not a directory, the inherited ACL SHOULD NOT inherit ACEs from the parent directory ACL unless the ACE4_FILE_INHERIT_FLAG is set.",
      "ja": "作成中のオブジェクトがディレクトリでない場合ACE4_FILE_INHERIT_FLAGが設定されていない限り、継承されたACLは親ディレクトリのACLからACEを継承すべきではありません。"
    },
    {
      "indent": 3,
      "text": "If the object being created is a directory, the inherited ACL should inherit all inheritable ACEs from the parent directory, that is, those that have the ACE4_FILE_INHERIT_ACE or ACE4_DIRECTORY_INHERIT_ACE flag set. If the inheritable ACE has ACE4_FILE_INHERIT_ACE set but ACE4_DIRECTORY_INHERIT_ACE is clear, the inherited ACE on the newly created directory MUST have the ACE4_INHERIT_ONLY_ACE flag set to prevent the directory from being affected by ACEs meant for non-directories.",
      "ja": "作成中のオブジェクトがディレクトリである場合は、継承されたACLは親ディレクトリからすべての継承可能なACEを継承する必要があり、それは、ACE4_FILE_INHERIT_ACEまたはACE4_DIRECTORY_INHERIT_ACEフラグが設定されているものです。継承ACEはACE4_FILE_INHERIT_ACE設定されているが、ACE4_DIRECTORY_INHERIT_ACEがクリアされている場合は、新しく作成したディレクトリに継承されたACEは、ディレクトリ以外のために意味のACEに影響されることから、ディレクトリを防止するために設定ACE4_INHERIT_ONLY_ACEフラグを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a new directory is created, the server MAY split any inherited ACE that is both inheritable and effective (in other words, that has neither ACE4_INHERIT_ONLY_ACE nor ACE4_NO_PROPAGATE_INHERIT_ACE set), into two ACEs, one with no inheritance flags and one with ACE4_INHERIT_ONLY_ACE set. (In the case of a dacl or sacl attribute, both of those ACEs SHOULD also have the ACE4_INHERITED_ACE flag set.)",
      "ja": "新しいディレクトリが作成されると、サーバは2つのACE、無継承フラグと1とACE4_INHERIT_ONLY_ACEが設定された一つに（どちらもACE4_INHERIT_ONLY_ACEもACE4_NO_PROPAGATE_INHERIT_ACEセットを持って、他の言葉で、）継承可能かつ効果的である任意の継承されたACEを、分割することができます。 （DACLまたはSACL属性の場合には、それらのACEの両方はまたACE4_INHERITED_ACEフラグが設定されているべきです。）"
    },
    {
      "indent": 3,
      "text": "This makes it simpler to modify the effective permissions on the directory without modifying the ACE that is to be inherited to the new directory's children.",
      "ja": "これは、単純に新しいディレクトリの子に継承されるACEを変更せずに、ディレクトリの有効なアクセス許可を変更することができます。"
    },
    {
      "indent": 0,
      "text": "6.4.3.2. Automatic Inheritance",
      "section_title": true,
      "ja": "6.4.3.2。自動継承"
    },
    {
      "indent": 3,
      "text": "The acl attribute consists only of an array of ACEs, but the sacl (Section 6.2.3) and dacl (Section 6.2.2) attributes also include an additional flag field.",
      "ja": "ACL属性は、ACEの配列からなるが、SACL（セクション6.2.3）とDACL（セクション6.2.2）は、属性の追加フラグフィールドを含みます。"
    },
    {
      "indent": 3,
      "text": "struct nfsacl41 {\n        aclflag4        na41_flag;\n        nfsace4         na41_aces<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The flag field applies to the entire sacl or dacl; three flag values are defined:",
      "ja": "フラグフィールドは、全体のSACLまたはDACLに適用されます。 3つのフラグ値が定義されています。"
    },
    {
      "indent": 3,
      "text": "const ACL4_AUTO_INHERIT         = 0x00000001;\nconst ACL4_PROTECTED            = 0x00000002;\nconst ACL4_DEFAULTED            = 0x00000004;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "and all other bits must be cleared. The ACE4_INHERITED_ACE flag may be set in the ACEs of the sacl or dacl (whereas it must always be cleared in the acl).",
      "ja": "他のすべてのビットをクリアする必要があります。 （それは常にACLでクリアされなければならないのに対し）ACE4_INHERITED_ACEフラグがSACLまたはDACLのACEを設定してもよいです。"
    },
    {
      "indent": 3,
      "text": "Together these features allow a server to support automatic inheritance, which we now explain in more detail.",
      "ja": "一緒にこれらの機能は、サーバーは、我々は今、より詳細に説明した自動継承をサポートすることができます。"
    },
    {
      "indent": 3,
      "text": "Inheritable ACEs are normally inherited by child objects only at the time that the child objects are created; later modifications to inheritable ACEs do not result in modifications to inherited ACEs on descendants.",
      "ja": "継承可能なACEは通常、唯一の子オブジェクトが作成された時点で子オブジェクトに継承されます。継承可能なACEへの以降の変更は、子孫に継承されたACEへの変更にはなりません。"
    },
    {
      "indent": 3,
      "text": "However, the dacl and sacl provide an OPTIONAL mechanism that allows a client application to propagate changes to inheritable ACEs to an entire directory hierarchy.",
      "ja": "しかし、DACLとSACLは、クライアントアプリケーションがディレクトリ階層全体に継承可能なACEに変更を伝播することを可能にするオプションのメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "A server that supports this performs inheritance at object creation time in the normal way, and SHOULD set the ACE4_INHERITED_ACE flag on any inherited ACEs as they are added to the new object.",
      "ja": "これをサポートするサーバは、通常の方法でオブジェクトの作成時に継承を行い、そして、彼らは新しいオブジェクトに追加される任意の継承されたACEにACE4_INHERITED_ACEフラグを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "A client application such as an ACL editor may then propagate changes to inheritable ACEs on a directory by recursively traversing that directory's descendants and modifying each ACL encountered to remove any ACEs with the ACE4_INHERITED_ACE flag and to replace them by the new inheritable ACEs (also with the ACE4_INHERITED_ACE flag set). It uses the existing ACE inheritance flags in the obvious way to decide which ACEs to propagate. (Note that it may encounter further inheritable ACEs when descending the directory hierarchy and that those will also need to be taken into account when propagating inheritable ACEs to further descendants.)",
      "ja": "その後、再帰的にそのディレクトリの子孫を横断して各ACLを変更することによって、ディレクトリに継承可能なACEに変更を伝搬することができるACLエディタなどのクライアントアプリケーションなどはACE4_INHERITED_ACEフラグですべてのACEを削除するとしても（新しい継承可能なACEによってそれらを置き換えるために遭遇しましたACE4_INHERITED_ACEフラグセット）。これは、伝播するのACEかを決定するために明白な方法で既存のACEの継承フラグを使用しています。 （ディレクトリ階層を下降するとき、それはさらに継承可能なACEに遭遇することが、それらはまた子孫に継承ACEを伝搬する際に考慮される必要があることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "The reach of this propagation may be limited in two ways: first, automatic inheritance is not performed from any directory ACL that has the ACL4_AUTO_INHERIT flag cleared; and second, automatic inheritance stops wherever an ACL with the ACL4_PROTECTED flag is set, preventing modification of that ACL and also (if the ACL is set on a directory) of the ACL on any of the object's descendants.",
      "ja": "この伝播のリーチは、2つの方法で制限され得る：最初、自動継承をクリアACL4_AUTO_INHERITフラグを有する任意のディレクトリのACLから行われていません。第二に、自動継承オブジェクトの子孫のいずれかにACLの（ACLがディレクトリに設定されている場合）ACL4_PROTECTEDフラグとACLはまた、そのACLの変形を防止し、設定されどこ停止します。"
    },
    {
      "indent": 3,
      "text": "This propagation is performed independently for the sacl and the dacl attributes; thus, the ACL4_AUTO_INHERIT and ACL4_PROTECTED flags may be independently set for the sacl and the dacl, and propagation of one type of acl may continue down a hierarchy even where propagation of the other acl has stopped.",
      "ja": "この伝播は、SACLとDACL属性に対して独立して行われます。従って、ACL4_AUTO_INHERITとACL4_PROTECTEDフラグは、互いに独立して、ACLの伝播が停止した場合でも、階層を下り続けることができるSACLとDACL、およびACLの一種の伝播のために設定されてもよいです。"
    },
    {
      "indent": 3,
      "text": "New objects should be created with a dacl and a sacl that both have the ACL4_PROTECTED flag cleared and the ACL4_AUTO_INHERIT flag set to the same value as that on, respectively, the sacl or dacl of the parent object.",
      "ja": "新しいオブジェクトは、DACLとの両方が、それぞれ、ACL4_PROTECTEDフラグがクリアされ、ACL4_AUTO_INHERITフラグがオンと同じ値に設定SACL又は親オブジェクトのDACLを有するSacIで作成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Both the dacl and sacl attributes are RECOMMENDED, and a server may support one without supporting the other.",
      "ja": "DACLとSACLの属性の両方が推奨され、サーバは他のを支援することなく、1をサポートすることができます。"
    },
    {
      "indent": 3,
      "text": "A server that supports both the old acl attribute and one or both of the new dacl or sacl attributes must do so in such a way as to keep all three attributes consistent with each other. Thus, the ACEs reported in the acl attribute should be the union of the ACEs reported in the dacl and sacl attributes, except that the ACE4_INHERITED_ACE flag must be cleared from the ACEs in the acl. And of course a client that queries only the acl will be unable to determine the values of the sacl or dacl flag fields.",
      "ja": "互いに矛盾のすべての3つの属性を維持するよう、古いACL属性と新しいDACLまたはSACL属性のいずれかまたは両方の両方をサポートするサーバーは、このような方法で行う必要があります。このように、ACL属性で報告されたACEはACE4_INHERITED_ACEフラグがACL内のACEからクリアしなければならないことを除いて、DACLとSACL属性で報告されたACEの労働組合でなければなりません。そしてもちろん、唯一のACLを照会するクライアントは、SACLの値またはDACLフラグフィールドを決定することができません。"
    },
    {
      "indent": 3,
      "text": "When a client performs a SETATTR for the acl attribute, the server SHOULD set the ACL4_PROTECTED flag to true on both the sacl and the dacl. By using the acl attribute, as opposed to the dacl or sacl attributes, the client signals that it may not understand automatic inheritance, and thus cannot be trusted to set an ACL for which automatic inheritance would make sense.",
      "ja": "クライアントがACL属性のSETATTRを実行すると、サーバーは、SACLとDACLの両方にtrueにACL4_PROTECTEDフラグを設定する必要があります。 ACL属性を使用することにより、DACLまたはSACLの属性とは対照的に、それはこのように自動継承を理解し、ないかもしれないクライアント信号は自動継承が理にかなっているACLを設定するために信頼することはできません。"
    },
    {
      "indent": 3,
      "text": "When a client application queries an ACL, modifies it, and sets it again, it should leave any ACEs marked with ACE4_INHERITED_ACE unchanged, in their original order, at the end of the ACL. If the application is unable to do this, it should set the ACL4_PROTECTED flag. This behavior is not enforced by servers, but violations of this rule may lead to unexpected results when applications perform automatic inheritance.",
      "ja": "クライアントアプリケーションがACLを照会すると、それを修正し、再びそれを設定し、それがACLの最後に、元の順序で、ACE4_INHERITED_ACEそのままでマークされたすべてのACEを残す必要があります。アプリケーションがこれを行うことができない場合は、ACL4_PROTECTEDフラグを設定する必要があります。この動作は、サーバによって強制されていませんが、アプリケーションが自動的に継承を行うときに、このルールの違反は、予期しない結果につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "If a server also supports the mode attribute, it SHOULD set the mode in such a way that leaves inherited ACEs unchanged, in their original order, at the end of the ACL. If it is unable to do so, it SHOULD set the ACL4_PROTECTED flag on the file's dacl.",
      "ja": "サーバはまた、モード属性をサポートしている場合、それはACLの終わりに、元の順序で、そのまま継承されたACEを離れるようにモードを設定する必要があります。それはそうすることができない場合は、ファイルのDACLにACL4_PROTECTEDフラグを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, in the case where the request that creates a new file or directory does not also set permissions for that file or directory, and there are also no ACEs to inherit from the parent's directory, then the server's choice of ACL for the new object is implementation-dependent. In this case, the server SHOULD set the ACL4_DEFAULTED flag on the ACL it chooses for the new object. An application performing automatic inheritance takes the ACL4_DEFAULTED flag as a sign that the ACL should be completely replaced by one generated using the automatic inheritance rules.",
      "ja": "最後に、新しいファイルまたはディレクトリを作成し、要求も、そのファイルやディレクトリのアクセス権を設定していない、と親のディレクトリから継承する一切のACEも存在しない場合には、その後、新しいオブジェクトのACLのサーバの選択があります実装依存。この場合、サーバは、それが新しいオブジェクトの選択ACLにACL4_DEFAULTEDフラグを設定する必要があります。自動継承を行うアプリケーションは、ACLを完全に自動継承ルールを使用して生成ものと交換しなければならない符号としてACL4_DEFAULTEDフラグを取ります。"
    },
    {
      "indent": 0,
      "text": "7. Single-Server Namespace",
      "section_title": true,
      "ja": "7.単一サーバーの名前空間"
    },
    {
      "indent": 3,
      "text": "This section describes the NFSv4 single-server namespace. Single-server namespaces may be presented directly to clients, or they may be used as a basis to form larger multi-server namespaces (e.g., site-wide or organization-wide) to be presented to clients, as described in Section 11.",
      "ja": "このセクションでは、NFSv4の単一サーバーの名前空間について説明します。単一サーバのネームスペースは、クライアントに直接提供することができる、またはセクション11で説明したように、それらは、クライアントに提示する、より大きなマルチサーバーの名前空間（例えば、サイト全体または組織全体）を形成するための基礎として使用することができます。"
    },
    {
      "indent": 0,
      "text": "7.1. Server Exports",
      "section_title": true,
      "ja": "7.1. サーバーの輸出"
    },
    {
      "indent": 3,
      "text": "On a UNIX server, the namespace describes all the files reachable by pathnames under the root directory or \"/\". On a Windows server, the namespace constitutes all the files on disks named by mapped disk letters. NFS server administrators rarely make the entire server's file system namespace available to NFS clients. More often, portions of the namespace are made available via an \"export\" feature. In previous versions of the NFS protocol, the root filehandle for each export is obtained through the MOUNT protocol; the client sent a string that identified the export name within the namespace and the server returned the root filehandle for that export. The MOUNT protocol also provided an EXPORTS procedure that enumerated the server's exports.",
      "ja": "UNIXサーバーでは、名前空間は、ルートディレクトリの下にパス名で到達可能なすべてのファイルを記述したり、「/」。 Windowsサーバでは、名前空間がマッピングされたディスクの文字で指定されたディスク上のすべてのファイルを構成しています。 NFSサーバーの管理者は、めったにNFSクライアントに、サーバー全体のファイルシステムの名前空間を利用可能にしません。多くの場合、名前空間の部分は、「エクスポート」機能を経由して利用できるようになります。 NFSプロトコルの旧バージョンでは、各エクスポートのルートファイルハンドルは、MOUNTプロトコルを介して得られます。クライアントは、名前空間にエクスポート名を特定し、サーバーがその輸出のルートファイルハンドルを返された文字列を送りました。 MOUNTプロトコルは、サーバの輸出を列挙EXPORTS手順を提供します。"
    },
    {
      "indent": 0,
      "text": "7.2. Browsing Exports",
      "section_title": true,
      "ja": "7.2. ブラウズ輸出"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol provides a root filehandle that clients can use to obtain filehandles for the exports of a particular server, via a series of LOOKUP operations within a COMPOUND, to traverse a path. A common user experience is to use a graphical user interface (perhaps a file \"Open\" dialog window) to find a file via progressive browsing through a directory tree. The client must be able to move from one export to another export via single-component, progressive LOOKUP operations.",
      "ja": "NFSv4.1プロトコルは、クライアントが経路を横断するように、化合物内LOOKUPの一連の動作を介して、特定のサーバの輸出のためのファイルハンドルを取得するために使用することができ、ルートファイルハンドルを提供します。一般的なユーザーエクスペリエンスは、ディレクトリツリーをプログレッシブブラウジング経由でファイルを見つけるために、グラフィカル・ユーザー・インターフェース（おそらくファイル「開く」ダイアログ・ウィンドウ）を使用することです。クライアントは、単一成分、プログレッシブLOOKUP操作を介して別の輸出に1つのエクスポートから動くことができなければなりません。"
    },
    {
      "indent": 3,
      "text": "This style of browsing is not well supported by the NFSv3 protocol. In NFSv3, the client expects all LOOKUP operations to remain within a single server file system. For example, the device attribute will not change. This prevents a client from taking namespace paths that span exports.",
      "ja": "ブラウジングのこのスタイルはよくNFSv3のプロトコルによってサポートされていません。 NFSv3ではでは、クライアントはすべてのLOOKUP操作は、単一のサーバ・ファイル・システム内にとどまると予想しています。例えば、デバイスの属性が変更されません。これは、輸出にまたがる名前空間のパスを取ってからクライアントを防ぎます。"
    },
    {
      "indent": 3,
      "text": "In the case of NFSv3, an automounter on the client can obtain a snapshot of the server's namespace using the EXPORTS procedure of the MOUNT protocol. If it understands the server's pathname syntax, it can create an image of the server's namespace on the client. The parts of the namespace that are not exported by the server are filled in with directories that might be constructed similarly to an NFSv4.1 \"pseudo file system\" (see Section 7.3) that allows the user to browse from one mounted file system to another. There is a drawback to this representation of the server's namespace on the client: it is static. If the server administrator adds a new export, the client will be unaware of it.",
      "ja": "NFSv3の場合には、クライアント上でオートマウンタは、MOUNTプロトコルのEXPORTS手順を使用して、サーバーの名前空間のスナップショットを取得することができます。それは、サーバのパス名の構文を理解している場合、それは、クライアント上のサーバーの名前空間の画像を作成することができます。サーバーによってエクスポートされていない名前空間の部分がNFSv4.1「擬似ファイルシステム」と同様に構成されるかもしれないディレクトリで満たされている（7.3節を参照）は、ユーザーが別のマウントされたファイルシステムから参照することができます。クライアント上のサーバーの名前空間のこの表現への欠点があります：それは静的です。サーバ管理者が新たな輸出を追加した場合、クライアントはそれに気づいていないだろう。"
    },
    {
      "indent": 0,
      "text": "7.3. Server Pseudo File System",
      "section_title": true,
      "ja": "7.3. サーバー擬似ファイルシステム"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 servers avoid this namespace inconsistency by presenting all the exports for a given server within the framework of a single namespace for that server. An NFSv4.1 client uses LOOKUP and READDIR operations to browse seamlessly from one export to another.",
      "ja": "NFSv4.1サーバは、そのサーバのための単一の名前空間の枠組みの中で特定のサーバーのすべての輸出を提示することによって、この名前空間の矛盾を避けます。 NFSv4.1のクライアントは、別のエクスポートからシームレスに閲覧することLOOKUPとREADDIR操作を使用しています。"
    },
    {
      "indent": 3,
      "text": "Where there are portions of the server namespace that are not exported, clients require some way of traversing those portions to reach actual exported file systems. A technique that servers may use to provide for this is to bridge the unexported portion of the namespace via a \"pseudo file system\" that provides a view of exported directories only. A pseudo file system has a unique fsid and behaves like a normal, read-only file system.",
      "ja": "エクスポートされていないサーバーの名前空間の部分がある場合、クライアントは、実際のエクスポートされたファイルシステムに到達するためにそれらの部分を横断するいくつかの方法が必要です。サーバはこれを提供するために使用することができる技術は、エクスポートされたディレクトリのビューを提供する「擬似ファイルシステム」を介して、名前空間のアンエクスポート部分を埋めることです。擬似ファイルシステムは、ユニークなFSIDを持っており、通常、読み取り専用ファイルシステムのように動作します。"
    },
    {
      "indent": 3,
      "text": "Based on the construction of the server's namespace, it is possible that multiple pseudo file systems may exist. For example,",
      "ja": "サーバーの名前空間の建設に基づいて、複数の疑似ファイルシステムが存在する可能性があります。例えば、"
    },
    {
      "indent": 11,
      "text": "/a              pseudo file system\n/a/b            real file system\n/a/b/c          pseudo file system\n/a/b/c/d        real file system",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each of the pseudo file systems is considered a separate entity and therefore MUST have its own fsid, unique among all the fsids for that server.",
      "ja": "疑似ファイルシステムの各々は、独立した事業体とみなされ、したがって、そのサーバーのすべてのfsidsの中でユニークな独自のFSIDを持っている必要があります。"
    },
    {
      "indent": 0,
      "text": "7.4. Multiple Roots",
      "section_title": true,
      "ja": "7.4. 複数のルーツ"
    },
    {
      "indent": 3,
      "text": "Certain operating environments are sometimes described as having \"multiple roots\". In such environments, individual file systems are commonly represented by disk or volume names. NFSv4 servers for these platforms can construct a pseudo file system above these root names so that disk letters or volume names are simply directory names in the pseudo root.",
      "ja": "特定の動作環境は、時々、「複数のルート」を有すると記載されています。このような環境では、個々のファイルシステムは、一般的に、ディスクまたはボリューム名で表されます。ディスクの文字またはボリューム名は、単に疑似ルートにディレクトリ名になるように、これらのプラットフォーム用のNFSv4サーバは、これらのルート名の上の擬似ファイルシステムを構築することができます。"
    },
    {
      "indent": 0,
      "text": "7.5. Filehandle Volatility",
      "section_title": true,
      "ja": "7.5. ファイルハンドルボラティリティ"
    },
    {
      "indent": 3,
      "text": "The nature of the server's pseudo file system is that it is a logical representation of file system(s) available from the server. Therefore, the pseudo file system is most likely constructed dynamically when the server is first instantiated. It is expected that the pseudo file system may not have an on-disk counterpart from which persistent filehandles could be constructed. Even though it is preferable that the server provide persistent filehandles for the pseudo file system, the NFS client should expect that pseudo file system filehandles are volatile. This can be confirmed by checking the associated \"fh_expire_type\" attribute for those filehandles in question. If the filehandles are volatile, the NFS client must be prepared to recover a filehandle value (e.g., with a series of LOOKUP operations) when receiving an error of NFS4ERR_FHEXPIRED.",
      "ja": "サーバの疑似ファイルシステムの性質は、それがサーバから利用可能なファイルシステム（複数可）の論理的な表現であるということです。そのため、擬似ファイルシステムは、最も可能性の高いサーバが最初にインスタンス化されるときに動的に構築されています。擬似ファイルシステムは永続的なファイルハンドルを構築することができたから、ディスク上の対応するものがないことが予想されます。それは、サーバが擬似ファイルシステムのための永続的なファイルハンドルを提供することが好ましいですが、NFSクライアントは、擬似ファイルシステムのファイルハンドルが揮発性であることを期待してください。これが問題になっているこれらのファイルハンドルに関連付けられた「fh_expire_type」属性をチェックすることで確認することができます。ファイルハンドルが揮発性である場合NFS4ERR_FHEXPIREDのエラーを受信した場合、NFSクライアントは、（ルックアップ一連の動作で、例えば）ファイルハンドル値を回復するために用意されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Because it is quite likely that servers will implement pseudo file systems using volatile filehandles, clients need to be prepared for them, rather than assuming that all filehandles will be persistent.",
      "ja": "それはサーバーが揮発性ファイルハンドルを使用して疑似ファイルシステムを実装することは非常に可能性があるので、クライアントではなく、すべてのファイルハンドルが持続的になることを想定するよりも、彼らのために準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.6. Exported Root",
      "section_title": true,
      "ja": "7.6. エクスポートされたルート"
    },
    {
      "indent": 3,
      "text": "If the server's root file system is exported, one might conclude that a pseudo file system is unneeded. This is not necessarily so. Assume the following file systems on a server:",
      "ja": "サーバーのルートファイルシステムがエクスポートされる場合、一つは疑似ファイルシステムが不要であると結論することがあります。これは必ずしもそうではありません。サーバー上の次のファイルシステムを想定します。"
    },
    {
      "indent": 11,
      "text": "/       fs1  (exported)\n/a      fs2  (not exported)\n/a/b    fs3  (exported)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Because fs2 is not exported, fs3 cannot be reached with simple LOOKUPs. The server must bridge the gap with a pseudo file system.",
      "ja": "FS2がエクスポートされていないので、FS3は、簡単な検索で到達することはできません。サーバーは、擬似ファイルシステムとのギャップを埋める必要があります。"
    },
    {
      "indent": 0,
      "text": "7.7. Mount Point Crossing",
      "section_title": true,
      "ja": "7.7. マウントポイントクロッシング"
    },
    {
      "indent": 3,
      "text": "The server file system environment may be constructed in such a way that one file system contains a directory that is 'covered' or mounted upon by a second file system. For example:",
      "ja": "サーバーのファイルシステム環境は、一つのファイルシステムが「カバー」や第2のファイルシステムによって上にマウントされたディレクトリを含むように構成してもよいです。例えば："
    },
    {
      "indent": 11,
      "text": "/a/b            (file system 1)\n/a/b/c/d        (file system 2)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The pseudo file system for this server may be constructed to look like:",
      "ja": "このサーバーの疑似ファイルシステムが見えるように構築することができます。"
    },
    {
      "indent": 11,
      "text": "/               (place holder/not exported)\n/a/b            (file system 1)\n/a/b/c/d        (file system 2)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "It is the server's responsibility to present the pseudo file system that is complete to the client. If the client sends a LOOKUP request for the path /a/b/c/d, the server's response is the filehandle of the root of the file system /a/b/c/d. In previous versions of the NFS protocol, the server would respond with the filehandle of directory /a/b/c/d within the file system /a/b.",
      "ja": "クライアントへの完全な擬似ファイルシステムを提示するサーバーの責任です。クライアントは、パス/ A / B / C / DのためのLOOKUP要求を送信すると、サーバーの応答は、ファイルシステム/ A / B / C / Dの根のファイルハンドルです。 NFSプロトコルの旧バージョンでは、サーバーは、ファイル・システム/ A / B内のディレクトリ/ A / B / C / Dのファイルハンドルを用いて応答します。"
    },
    {
      "indent": 3,
      "text": "The NFS client will be able to determine if it crosses a server mount point by a change in the value of the \"fsid\" attribute.",
      "ja": "NFSクライアントは、サーバが「FSID」属性の値の変化により、マウントポイントを横断するかどうかを判断することができるようになります。"
    },
    {
      "indent": 0,
      "text": "7.8. Security Policy and Namespace Presentation",
      "section_title": true,
      "ja": "7.8. セキュリティポリシーと名前空間プレゼンテーション"
    },
    {
      "indent": 3,
      "text": "Because NFSv4 clients possess the ability to change the security mechanisms used, after determining what is allowed, by using SECINFO and SECINFO_NONAME, the server SHOULD NOT present a different view of the namespace based on the security mechanism being used by a client. Instead, it should present a consistent view and return NFS4ERR_WRONGSEC if an attempt is made to access data with an inappropriate security mechanism.",
      "ja": "NFSv4のクライアントが使用するセキュリティ・メカニズムを変更する機能を有しているため、許可されていることを決定した後、SECINFOとSECINFO_NONAMEを使用することにより、サーバは、クライアントによって使用されているセキュリティ・メカニズムに基づいて、名前空間の異なるビューを提示すべきではありません。代わりに、一貫性のあるビューを提示し、試行が不適切なセキュリティ・メカニズムを使用してデータにアクセスするために行われた場合NFS4ERR_WRONGSECを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If security considerations make it necessary to hide the existence of a particular file system, as opposed to all of the data within it, the server can apply the security policy of a shared resource in the server's namespace to components of the resource's ancestors. For example:",
      "ja": "セキュリティの考慮事項は、その中のすべてのデータとは対照的に、それは必要に応じて、特定のファイルシステムの存在を隠すために作る場合は、サーバーはリソースの祖先のコンポーネントに、サーバーの名前空間内の共有リソースのセキュリティポリシーを適用することができます。例えば："
    },
    {
      "indent": 11,
      "text": "/                           (place holder/not exported)\n/a/b                        (file system 1)\n/a/b/MySecretProject        (file system 2)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The /a/b/MySecretProject directory is a real file system and is the shared resource. Suppose the security policy for /a/b/ MySecretProject is Kerberos with integrity and it is desired to limit knowledge of the existence of this file system. In this case, the server should apply the same security policy to /a/b. This allows for knowledge of the existence of a file system to be secured when desirable.",
      "ja": "/ A / B / MySecretProjectディレクトリには、実際のファイルシステムであり、共有リソースです。 / A / B / MySecretProjectのセキュリティポリシーは、整合性とKerberosのであり、このファイルシステムの存在の知識を制限することが望まれていると仮定します。この場合、サーバは/ A / Bに同じセキュリティポリシーを適用する必要があります。これは望ましい確保するファイルシステムの存在の知識が可能になります。"
    },
    {
      "indent": 3,
      "text": "For the case of the use of multiple, disjoint security mechanisms in the server's resources, applying that sort of policy would result in the higher-level file system not being accessible using any security flavor. Therefore, that sort of configuration is not compatible with hiding the existence (as opposed to the contents) from clients using multiple disjoint sets of security flavors.",
      "ja": "複数の使用の場合には、ポリシーの並べ替えを適用し、サーバーのリソースでばらばらセキュリティメカニズムは、すべてのセキュリティ風味を使用してアクセスされていない上位レベルのファイルシステムにつながります。したがって、構成のソートは、セキュリティ風味の複数の互いに素な集合を使用して、クライアントから（コンテンツとは対照的に）の存在を隠すと互換性がありません。"
    },
    {
      "indent": 3,
      "text": "In other circumstances, a desirable policy is for the security of a particular object in the server's namespace to include the union of all security mechanisms of all direct descendants. A common and convenient practice, unless strong security requirements dictate otherwise, is to make the entire the pseudo file system accessible by all of the valid security mechanisms.",
      "ja": "他の状況では、望ましい政策は、すべての直接の子孫のすべてのセキュリティ・メカニズムの組合を含むように、サーバーの名前空間内の特定のオブジェクトのセキュリティのためです。一般的で便利な練習は、強力なセキュリティ要件がそう指示しない限り、有効なセキュリティメカニズムのすべてによって、全体の疑似ファイルシステムにアクセスできるようにすることです。"
    },
    {
      "indent": 3,
      "text": "Where there is concern about the security of data on the network, clients should use strong security mechanisms to access the pseudo file system in order to prevent man-in-the-middle attacks.",
      "ja": "ネットワーク上のデータのセキュリティについて懸念がある場合、クライアントは、man-in-the-middle攻撃を防ぐために、擬似ファイルシステムにアクセスするための強力なセキュリティ・メカニズムを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "8. State Management",
      "section_title": true,
      "ja": "8.状態管理"
    },
    {
      "indent": 3,
      "text": "Integrating locking into the NFS protocol necessarily causes it to be stateful. With the inclusion of such features as share reservations, file and directory delegations, recallable layouts, and support for mandatory byte-range locking, the protocol becomes substantially more dependent on proper management of state than the traditional combination of NFS and NLM (Network Lock Manager) [46]. These features include expanded locking facilities, which provide some measure of inter-client exclusion, but the state also offers features not readily providable using a stateless model. There are three components to making this state manageable:",
      "ja": "NFSプロトコルにロック統合必ずしもステートフルさせます。共有の予約、ファイルおよびディレクトリ団、リコールレイアウト、および必須のバイト範囲ロックのサポートなどの機能を含めて、プロトコルはNFSとNLM（ネットワークロックマネージャの従来の組み合わせより状態の適切な管理に実質的に依存するようになります）[46]。これらの機能は、クライアント間の除外のいくつかの手段を提供する、拡張ロック機能が含まれますが、状態もステートレスなモデルを用いて容易に提供可能な機能を提供していますありません。この状態は管理しやすい作りには3つのコンポーネントがあります。"
    },
    {
      "indent": 3,
      "text": "o clear division between client and server",
      "ja": "クライアントとサーバの間のO明確な区分"
    },
    {
      "indent": 3,
      "text": "o ability to reliably detect inconsistency in state between client and server",
      "ja": "O能力は確実にクライアントとサーバの間の状態に矛盾を検出します"
    },
    {
      "indent": 3,
      "text": "o simple and robust recovery mechanisms",
      "ja": "Oシンプルで堅牢な回復メカニズム"
    },
    {
      "indent": 3,
      "text": "In this model, the server owns the state information. The client requests changes in locks and the server responds with the changes made. Non-client-initiated changes in locking state are infrequent. The client receives prompt notification of such changes and can adjust its view of the locking state to reflect the server's changes.",
      "ja": "このモデルでは、サーバーは、状態情報を所有しています。クライアントは、ロックの変更を要求し、サーバが行った変更で応答します。ロック状態での非クライアント主導の変更はまれです。クライアントは、このような変化の迅速な通知を受信して​​、サーバーの変更を反映するために、ロック状態のその視野を調整することができます。"
    },
    {
      "indent": 3,
      "text": "Individual pieces of state created by the server and passed to the client at its request are represented by 128-bit stateids. These stateids may represent a particular open file, a set of byte-range locks held by a particular owner, or a recallable delegation of privileges to access a file in particular ways or at a particular location.",
      "ja": "その要求に応じてクライアントにサーバによって作成され、渡された状態の個々の部分は、128ビットのstateidsで表現されています。これらのstateidsは、特定の開いているファイル、特定の所有者によって保持されたバイト範囲ロックのセット、または特定の方法で、または特定の場所にあるファイルへのアクセス権限の委譲リコールを表すことができます。"
    },
    {
      "indent": 3,
      "text": "In all cases, there is a transition from the most general information that represents a client as a whole to the eventual lightweight stateid used for most client and server locking interactions. The details of this transition will vary with the type of object but it always starts with a client ID.",
      "ja": "全ての場合において、最もクライアントとサーバのロックの相互作用のために使用される最終的な軽量のstateidに全体としてクライアントを表す最も一般的な情報の遷移があります。この移行の詳細については、オブジェクトの種類によって異なりますが、それは常にクライアントのIDで始まります。"
    },
    {
      "indent": 0,
      "text": "8.1. Client and Session ID",
      "section_title": true,
      "ja": "8.1. クライアントとセッションID"
    },
    {
      "indent": 3,
      "text": "A client must establish a client ID (see Section 2.4) and then one or more sessionids (see Section 2.10) before performing any operations to open, byte-range lock, delegate, or obtain a layout for a file object. Each session ID is associated with a specific client ID, and thus serves as a shorthand reference to an NFSv4.1 client.",
      "ja": "クライアントは、クライアントのIDを確立する（2.4節を参照）、その後、一つ以上のsessionids、バイト範囲ロック、開くために任意の操作を実行する前に、デリゲートを（2.10節を参照）、またはファイルオブジェクトのレイアウトを取得する必要があります。各セッションIDは、特定のクライアントIDに関連付けられ、したがってNFSv4.1クライアントに速記参照として機能します。"
    },
    {
      "indent": 3,
      "text": "For some types of locking interactions, the client will represent some number of internal locking entities called \"owners\", which normally correspond to processes internal to the client. For other types of locking-related objects, such as delegations and layouts, no such intermediate entities are provided for, and the locking-related objects are considered to be transferred directly between the server and a unitary client.",
      "ja": "ロックの相互作用のいくつかのタイプのために、クライアントは通常、クライアントの内部プロセスに対応する「所有者」と呼ばれる内部ロックエンティティ、いくつかの数を表します。そのような委任やレイアウトなどのロック関連のオブジェクトの他のタイプについては、そのような中間エンティティはのために提供されていない、とロッキング関連オブジェクトは、サーバと単一のクライアント間で直接転送されると考えられます。"
    },
    {
      "indent": 0,
      "text": "8.2. Stateid Definition",
      "section_title": true,
      "ja": "8.2.  STATEID定義"
    },
    {
      "indent": 3,
      "text": "When the server grants a lock of any type (including opens, byte-range locks, delegations, and layouts), it responds with a unique stateid that represents a set of locks (often a single lock) for the same file, of the same type, and sharing the same ownership characteristics. Thus, opens of the same file by different open-owners each have an identifying stateid. Similarly, each set of byte-range locks on a file owned by a specific lock-owner has its own identifying stateid. Delegations and layouts also have associated stateids by which they may be referenced. The stateid is used as a shorthand reference to a lock or set of locks, and given a stateid, the server can determine the associated state-owner or state-owners (in the case of an open-owner/lock-owner pair) and the associated filehandle. When stateids are used, the current filehandle must be the one associated with that stateid.",
      "ja": "サーバは（開きバイト範囲ロック、代表団、およびレイアウトを含む）あらゆるタイプのロックを付与すると、それは同じで、同じファイルのロックのセット（多くの場合、単一のロック）を表す一意のstateidで応答しますタイプ、および同じ所有者の特性を共有します。このように、各々が特定のstateidを有する異なるオープンオーナーによって同じファイルの開き。同様に、特定のロック所有者が所有するファイル上のバイト範囲ロックの各セットは、それ自身の特定のstateidを有しています。代表団とレイアウトはまた、彼らが参照されるかもしれないのstateidsが関連付けられています。 stateidロックに速記参照として使用されるか、またはロックの設定、およびのstateidが与えられ、サーバは（オープン所有者/ロック所有者ペアの場合）関連状態、所有者または状態の所有者を決定することができると関連するファイルハンドル。 stateidsが使用される場合、現在のファイルハンドルは、そののstateidに関連付けられているものでなければなりません。"
    },
    {
      "indent": 3,
      "text": "All stateids associated with a given client ID are associated with a common lease that represents the claim of those stateids and the objects they represent to be maintained by the server. See Section 8.3 for a discussion of the lease.",
      "ja": "所与のクライアントIDに関連付けられたすべてのstateidsは、それらのstateids、それらがサーバによって維持される表すオブジェクトの項を表す一般的なリースに関連しています。リースの議論については、セクション8.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "The server may assign stateids independently for different clients. A stateid with the same bit pattern for one client may designate an entirely different set of locks for a different client. The stateid is always interpreted with respect to the client ID associated with the current session. Stateids apply to all sessions associated with the given client ID, and the client may use a stateid obtained from one session on another session associated with the same client ID.",
      "ja": "サーバーは、異なるクライアントごとに独立のstateidsを割り当てることができます。一つのクライアントに対して同じビットパターンとのstateidは異なるクライアントのロックの完全に異なるセットを指定することができます。 stateidは、常に現在のセッションに関連付けられたクライアントIDに対して解釈されます。 stateidsは、与えられたクライアントIDに関連付けられているすべてのセッションに適用され、そしてクライアントが同じクライアントIDに関連付けられた別のセッションでのセッションから得られたstateidを使用することができます。"
    },
    {
      "indent": 0,
      "text": "8.2.1. Stateid Types",
      "section_title": true,
      "ja": "8.2.1.  STATEIDタイプ"
    },
    {
      "indent": 3,
      "text": "With the exception of special stateids (see Section 8.2.3), each stateid represents locking objects of one of a set of types defined by the NFSv4.1 protocol. Note that in all these cases, where we speak of guarantee, it is understood there are situations such as a client restart, or lock revocation, that allow the guarantee to be voided.",
      "ja": "特別のstateids（セクション8.2.3を参照）を除いて、それぞれのstateidはNFSv4.1プロトコルによって定義されたタイプのセットのうちの1つのロックオブジェクトを表しています。我々は保証の話これらすべての場合において、なお、その保証は無効とすることができ、クライアントの再起動、またはロック失効などの状況が、そこにあるものと理解されます。"
    },
    {
      "indent": 3,
      "text": "o Stateids may represent opens of files.",
      "ja": "Oのstateidsはファイルの開きを表すことができます。"
    },
    {
      "indent": 6,
      "text": "Each stateid in this case represents the OPEN state for a given client ID/open-owner/filehandle triple. Such stateids are subject to change (with consequent incrementing of the stateid's seqid) in response to OPENs that result in upgrade and OPEN_DOWNGRADE operations.",
      "ja": "この場合の各のstateidは、所与のクライアントID /オープン所有者/ファイルハンドル三重ためOPEN状態を表しています。そのようなのstateidsアップグレードとOPEN_DOWNGRADE動作をもたらすのOPENsに応答して（のstateidのSEQIDの結果としての増分で）変更される場合があります。"
    },
    {
      "indent": 3,
      "text": "o Stateids may represent sets of byte-range locks.",
      "ja": "Oのstateidsは、バイト範囲ロックのセットを表してもよいです。"
    },
    {
      "indent": 6,
      "text": "All locks held on a particular file by a particular owner and gotten under the aegis of a particular open file are associated with a single stateid with the seqid being incremented whenever LOCK and LOCKU operations affect that set of locks.",
      "ja": "LOCKとLOCKU操作がロックのセットに影響を与えるたびにインクリメントされる特定のオープンファイルの庇護の下で特定の所有者が特定のファイルに保持され得、すべてのロックはSEQID有する単一のstateidに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "o Stateids may represent file delegations, which are recallable guarantees by the server to the client that other clients will not reference or modify a particular file, until the delegation is returned. In NFSv4.1, file delegations may be obtained on both regular and non-regular files.",
      "ja": "Oのstateidsは、委任が返されるまで、他のクライアントは、特定のファイルを参照したり変更しないことをクライアントにサーバによってリコール保証されているファイルの代表団を表すことができます。 NFSv4.1では、ファイルの代表団は、正規・非正規のファイルの両方に取得することができます。"
    },
    {
      "indent": 6,
      "text": "A stateid represents a single delegation held by a client for a particular filehandle.",
      "ja": "stateidは、特定のファイルハンドルのためにクライアントによって保持された単一の代表団を表します。"
    },
    {
      "indent": 3,
      "text": "o Stateids may represent directory delegations, which are recallable guarantees by the server to the client that other clients will not modify the directory, until the delegation is returned.",
      "ja": "代表団が返されるまで、Oのstateidsは、他のクライアントがディレクトリを変更しませんクライアントにサーバによってリコール保証されているディレクトリの代表団を表すことができます。"
    },
    {
      "indent": 6,
      "text": "A stateid represents a single delegation held by a client for a particular directory filehandle.",
      "ja": "stateidは、特定のディレクトリのファイルハンドルのために、クライアントによって保持された単一の代表団を表します。"
    },
    {
      "indent": 3,
      "text": "o Stateids may represent layouts, which are recallable guarantees by the server to the client that particular files may be accessed via an alternate data access protocol at specific locations. Such access is limited to particular sets of byte-ranges and may proceed until those byte-ranges are reduced or the layout is returned.",
      "ja": "Oのstateidsは、特定のファイルが特定の位置で代替データアクセスプロトコルを介してアクセスすることができるクライアントにサーバによってリコール保証されているレイアウトを表すことができます。そのようなアクセスは、バイト範囲の特定のセットに制限され、これらのバイト範囲が縮小されるか、またはレイアウトが返されるまで進行することができます。"
    },
    {
      "indent": 6,
      "text": "A stateid represents the set of all layouts held by a particular client for a particular filehandle with a given layout type. The seqid is updated as the layouts of that set of byte-ranges change, via layout stateid changing operations such as LAYOUTGET and LAYOUTRETURN.",
      "ja": "stateidは、所与のレイアウトタイプを用いて、特定のファイルハンドルのために特定のクライアントが保持しているすべてのレイアウトのセットを表します。 SEQIDは、LAYOUTGETとLAYOUTRETURNなどの操作を変更するレイアウトのstateidを介して、バイト範囲の変化のセットのレイアウトのように更新されます。"
    },
    {
      "indent": 0,
      "text": "8.2.2. Stateid Structure",
      "section_title": true,
      "ja": "8.2.2.  STATEID構造"
    },
    {
      "indent": 3,
      "text": "Stateids are divided into two fields, a 96-bit \"other\" field identifying the specific set of locks and a 32-bit \"seqid\" sequence value. Except in the case of special stateids (see Section 8.2.3), a particular value of the \"other\" field denotes a set of locks of the same type (for example, byte-range locks, opens, delegations, or layouts), for a specific file or directory, and sharing the same ownership characteristics. The seqid designates a specific instance of such a set of locks, and is incremented to indicate changes in such a set of locks, either by the addition or deletion of locks from the set, a change in the byte-range they apply to, or an upgrade or downgrade in the type of one or more locks.",
      "ja": "stateids 2つのフィールド、ロックの特定のセットと32ビットの「SEQID」シーケンス値を識別する96ビットの「その他」のフィールドに分割されます。特別のstateids（セクション8.2.3を参照）の場合を除き、「その他」フィールドの特定の値は、同じタイプ（例えば、バイト範囲ロックを開き、代表団、又はレイアウト）のロックの集合を表し、特定のファイルやディレクトリ、および同じ所有者の特性を共有するため。 SEQIDはロックのようなセットの特定のインスタンスを指定して、いずれかの組からのロックの追加又は削除することによって、それらが適用バイト範囲の変化をロックのようなセットの変更を示すために増分され、又は一の以上のロックのタイプでアップグレードまたはダウングレード。"
    },
    {
      "indent": 3,
      "text": "When such a set of locks is first created, the server returns a stateid with seqid value of one. On subsequent operations that modify the set of locks, the server is required to increment the \"seqid\" field by one whenever it returns a stateid for the same state-owner/file/type combination and there is some change in the set of locks actually designated. In this case, the server will return a stateid with an \"other\" field the same as previously used for that state-owner/file/type combination, with an incremented \"seqid\" field. This pattern continues until the seqid is incremented past NFS4_UINT32_MAX, and one (not zero) is the next seqid value.",
      "ja": "ロックのようなセットが最初に作成されたとき、サーバは、一つのSEQID値とのstateidを返します。ロックのセットを変更する後続の操作で、サーバは、それが同じ状態、所有者/ファイル/タイプの組み合わせのためのstateidを返し、ロックのセット内のいくつかの変化が実際に存在するときはいつでも一方によって「SEQID」フィールドを増分する必要があります専用。この場合、サーバは、インクリメント「SEQID」フィールドと、以前にその状態所有者/ファイル/タイプ組合せに用いたものと同じフィールドを「その他」とのstateidを返します。 SEQIDがNFS4_UINT32_MAX越えてインクリメントされるまで、このパターンが続き、一方が（ゼロでない）次SEQID値です。"
    },
    {
      "indent": 3,
      "text": "The purpose of the incrementing of the seqid is to allow the server to communicate to the client the order in which operations that modified locking state associated with a stateid have been processed and to make it possible for the client to send requests that are conditional on the set of locks not having changed since the stateid in question was returned.",
      "ja": "SEQIDの増分の目的は、サーバがクライアントへのstateidに関連付けられた状態をロックする改変操作が処理されて、それが可能なクライアントが、条件である要求を送信するために作るために順序を通信できるようにすることです問題ののstateidが返されたため、ロックのセットがありません変更されました。"
    },
    {
      "indent": 3,
      "text": "Except for layout stateids (Section 12.5.3), when a client sends a stateid to the server, it has two choices with regard to the seqid sent. It may set the seqid to zero to indicate to the server that it wishes the most up-to-date seqid for that stateid's \"other\" field to be used. This would be the common choice in the case of a stateid sent with a READ or WRITE operation. It also may set a non-zero value, in which case the server checks if that seqid is the correct one. In that case, the server is required to return NFS4ERR_OLD_STATEID if the seqid is lower than the most current value and NFS4ERR_BAD_STATEID if the seqid is greater than the most current value. This would be the common choice in the case of stateids sent with a CLOSE or OPEN_DOWNGRADE. Because OPENs may be sent in parallel for the same owner, a client might close a file without knowing that an OPEN upgrade had been done by the server, changing the lock in question. If CLOSE were sent with a zero seqid, the OPEN upgrade would be cancelled before the client even received an indication that an upgrade had happened.",
      "ja": "クライアントがサーバに送信したstateidをレイアウトのstateids（セクション12.5.3）、を除いて、それが送られたSEQIDに関して2つの選択肢があります。それは、使用することのstateidの「その他」分野の最新のSEQIDを希望するサーバに示すためにゼロにSEQIDを設定することができます。これは、READまたはWRITE動作で送信されるのstateidの場合の一般的な選択であろう。そのSEQIDが正しいものである場合には、非ゼロ値、ケース内のサーバチェックを設定してもよいです。その場合、サーバはSEQIDが最も現在の値よりも大きい場合SEQIDが最新値とNFS4ERR_BAD_STATEIDより低い場合NFS4ERR_OLD_STATEIDを返すために必要とされます。これは、CLOSEまたはOPEN_DOWNGRADEで送信されたのstateidsの場合の一般的な選択であろう。 OPENsが同じ所有者のために並行して送信することができるので、クライアントがOPENアップグレードが問題のロックを変更、サーバーによって行われていたことを知らずにファイルを閉じることがあります。 CLOSEがゼロSEQIDで送信された場合は、クライアントもアップグレードが起こったという指示を受信する前に、OPENアップグレードがキャンセルされるだろう。"
    },
    {
      "indent": 3,
      "text": "When a stateid is sent by the server to the client as part of a callback operation, it is not subject to checking for a current seqid and returning NFS4ERR_OLD_STATEID. This is because the client is not in a position to know the most up-to-date seqid and thus cannot verify it. Unless specially noted, the seqid value for a stateid sent by the server to the client as part of a callback is required to be zero with NFS4ERR_BAD_STATEID returned if it is not.",
      "ja": "stateidは、コールバック操作の一部として、サーバからクライアントに送信されると、それは現在のSEQIDをチェックしてNFS4ERR_OLD_STATEIDを返すの対象ではありません。クライアントが最新のSEQIDを知る立場にないので、それを確認できないためです。特別に記載のない限り、コールバックの一部として、サーバからクライアントに送信されたstateidのためSEQID値はNFS4ERR_BAD_STATEIDでゼロであることが要求されることがない場合に返さ。"
    },
    {
      "indent": 3,
      "text": "In making comparisons between seqids, both by the client in determining the order of operations and by the server in determining whether the NFS4ERR_OLD_STATEID is to be returned, the possibility of the seqid being swapped around past the NFS4_UINT32_MAX value needs to be taken into account. When two seqid values are being compared, the total count of slots for all sessions associated with the current client is used to do this. When one seqid value is less than this total slot count and another seqid value is greater than NFS4_UINT32_MAX minus the total slot count, the former is to be treated as lower than the latter, despite the fact that it is numerically greater.",
      "ja": "操作の順序を決定する際にクライアントによってそしてNFS4ERR_OLD_STATEIDが返されるかどうかを決定する際に、サーバの両方、seqids間の比較を行う際に、SEQIDの可能性がNFS4_UINT32_MAX値が考慮される必要があるの周りを越えて交換されています。 2つのSEQID値が比較されている場合は、現在のクライアントに関連付けられているすべてのセッションのスロットの合計数は、これを行うために使用されます。 1つのSEQID値がこの総スロット数より小さいと他SEQID値がNFS4_UINT32_MAXマイナス総スロット数よりも大きい場合、前者は、それが数値的に大きいという事実にもかかわらず、後者よりも低いものとして扱われるべきです。"
    },
    {
      "indent": 0,
      "text": "8.2.3. Special Stateids",
      "section_title": true,
      "ja": "8.2.3. 特別のstateids"
    },
    {
      "indent": 3,
      "text": "Stateid values whose \"other\" field is either all zeros or all ones are reserved. They may not be assigned by the server but have special meanings defined by the protocol. The particular meaning depends on whether the \"other\" field is all zeros or all ones and the specific value of the \"seqid\" field.",
      "ja": "その「その他」の欄のstateid値はすべてゼロ、またはすべてのもののいずれかを予約されています。彼らは、サーバーによって割り当てられたが、プロトコルによって定義された特別な意味を持つことはできません。特定の意味は、「その他」の欄はすべてゼロ、またはすべてのものと「SEQID」フィールドの特定の値であるかどうかに依存します。"
    },
    {
      "indent": 3,
      "text": "The following combinations of \"other\" and \"seqid\" are defined in NFSv4.1:",
      "ja": "「その他」と「SEQID」の以下の組み合わせは、NFSv4.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "o When \"other\" and \"seqid\" are both zero, the stateid is treated as a special anonymous stateid, which can be used in READ, WRITE, and SETATTR requests to indicate the absence of any OPEN state associated with the request. When an anonymous stateid value is used and an existing open denies the form of access requested, then access will be denied to the request. This stateid MUST NOT be used on operations to data servers (Section 13.6).",
      "ja": "「その他」及び「SEQID」は両方ともゼロである場合、O、のstateidはWRITE、READで使用することができる特別な匿名のstateid、として扱われ、その要求に関連する任意のオープン状態が存在しないことを示すためにSETATTR要求されます。匿名のstateid値を使用し、既存のオープンが要求されたアクセスのフォームを拒否された場合、アクセスは、要求に拒否されます。これのstateidは、データ・サーバ（13.6節）への操作に使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "o When \"other\" and \"seqid\" are both all ones, the stateid is a special READ bypass stateid. When this value is used in WRITE or SETATTR, it is treated like the anonymous value. When used in READ, the server MAY grant access, even if access would normally be denied to READ operations. This stateid MUST NOT be used on operations to data servers.",
      "ja": "「その他」と「SEQID」は両方とも、すべてのもののとき、O、のstateidは特別READバイパスのstateidです。この値は、WRITEまたはSETATTRに使用されている場合は、匿名の値のように扱われています。 READで使用する場合、サーバはアクセスが通常の操作を読み取るために拒否された場合でも、アクセスを許可することができます。これのstateidは、データ・サーバへの操作に使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "o When \"other\" is zero and \"seqid\" is one, the stateid represents the current stateid, which is whatever value is the last stateid returned by an operation within the COMPOUND. In the case of an OPEN, the stateid returned for the open file and not the delegation is used. The stateid passed to the operation in place of the special value has its \"seqid\" value set to zero, except when the current stateid is used by the operation CLOSE or OPEN_DOWNGRADE. If there is no operation in the COMPOUND that has returned a stateid value, the server MUST return the error NFS4ERR_BAD_STATEID. As illustrated in Figure 6, if the value of a current stateid is a special stateid and the stateid of an operation's arguments has \"other\" set to zero and \"seqid\" set to one, then the server MUST return the error NFS4ERR_BAD_STATEID.",
      "ja": "Oのstateidは、化合物内の操作によって返された最後のstateidがどのような値である現在のstateidを表し、ゼロと「SEQID」が一つである場合には「その他」です。 OPENの場合は、のstateidは、開いているファイルに対して返さ及び委任が使用されていません。特別な値の代わりに操作に渡さのstateidは、その「SEQID」値は、現在のstateidは、操作CLOSE又はOPEN_DOWNGRADEによって使用される場合を除き、ゼロに設定されています。たstateid値を返した化合物中に何も操作がない場合、サーバーはエラーNFS4ERR_BAD_STATEIDを返さなければなりません。図6に示すように、現在のstateidの値は、特別なstateidと操作の引数のstateidが「その他」をゼロに設定し、「SEQID」一に設定されているされている場合、サーバはエラーNFS4ERR_BAD_STATEIDを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o When \"other\" is zero and \"seqid\" is NFS4_UINT32_MAX, the stateid represents a reserved stateid value defined to be invalid. When this stateid is used, the server MUST return the error NFS4ERR_BAD_STATEID.",
      "ja": "「その他」はゼロであり、「SEQID」はNFS4_UINT32_MAXある場合、O、のstateidは無効であると定義され、予約のstateid値を表します。このたstateidを使用すると、サーバーはエラーNFS4ERR_BAD_STATEIDを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a stateid value is used that has all zeros or all ones in the \"other\" field but does not match one of the cases above, the server MUST return the error NFS4ERR_BAD_STATEID.",
      "ja": "stateid値がすべてゼロまたは「その他」の欄にあるすべてのものを持っていますが、上記の例1と一致していませんが使用されている場合は、サーバがエラーNFS4ERR_BAD_STATEIDを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Special stateids, unlike other stateids, are not associated with individual client IDs or filehandles and can be used with all valid client IDs and filehandles. In the case of a special stateid designating the current stateid, the current stateid value substituted for the special stateid is associated with a particular client ID and filehandle, and so, if it is used where the current filehandle does not match that associated with the current stateid, the operation to which the stateid is passed will return NFS4ERR_BAD_STATEID.",
      "ja": "特別のstateidsは、他のstateidsとは異なり、個々のクライアントIDまたはファイルハンドルに関連付けられていないと、すべての有効なクライアントIDとファイルハンドルを使用することができます。現在のstateidを指定する特別のstateidの場合には、特別のstateidの代わりに現在のstateid値は、特定のクライアントIDとファイルハンドルに関連付けされ、それが使用される場合ので、ここで現在のファイルハンドルは、現在関連付けられていることと一致しませんstateid、のstateidが通過されている操作はNFS4ERR_BAD_STATEIDを返します。"
    },
    {
      "indent": 0,
      "text": "8.2.4. Stateid Lifetime and Validation",
      "section_title": true,
      "ja": "8.2.4.  STATEID生涯と検証"
    },
    {
      "indent": 3,
      "text": "Stateids must remain valid until either a client restart or a server restart or until the client returns all of the locks associated with the stateid by means of an operation such as CLOSE or DELEGRETURN. If the locks are lost due to revocation, as long as the client ID is valid, the stateid remains a valid designation of that revoked state until the client frees it by using FREE_STATEID. Stateids associated with byte-range locks are an exception. They remain valid even if a LOCKU frees all remaining locks, so long as the open file with which they are associated remains open, unless the client frees the stateids via the FREE_STATEID operation.",
      "ja": "クライアントの再起動またはサーバーの再起動またはクライアントまでのいずれかは、CLOSEまたはDELEGRETURNなどの操作によってのstateidに関連付けられているロックのすべてを返すまでのstateidsは有効でなければなりません。ロックが失効によって失われている場合、クライアントはFREE_STATEIDを使用して、それを解放するまで、限り、クライアントIDが有効であるとして、のstateidは、その取り消された状態の有効な名称のまま。バイト範囲ロックに関連付けられているのstateidsは例外です。彼らはLOCKUは長い間、クライアントはFREE_STATEID操作を経由してのstateidsを解放しない限り、それらが関連付けられている、開いているファイルは、開いたままで、残りのすべてのロックを解放しても有効なまま。"
    },
    {
      "indent": 3,
      "text": "It should be noted that there are situations in which the client's locks become invalid, without the client requesting they be returned. These include lease expiration and a number of forms of lock revocation within the lease period. It is important to note that in these situations, the stateid remains valid and the client can use it to determine the disposition of the associated lost locks.",
      "ja": "クライアントのロックが無効になっている状況では、クライアントは、彼らが返されることを要求せずに、あることに留意すべきです。これらは、リース満了及びリース期間内にロック失効のフォームの数を含みます。このような状況で、のstateidが有効なままで、クライアントが関連付けられている失われたロックの配置を決定するためにそれを使用できることに注意することが重要です。"
    },
    {
      "indent": 3,
      "text": "An \"other\" value must never be reused for a different purpose (i.e., different filehandle, owner, or type of locks) within the context of a single client ID. A server may retain the \"other\" value for the same purpose beyond the point where it may otherwise be freed, but if it does so, it must maintain \"seqid\" continuity with previous values.",
      "ja": "「その他」の値は、単一のクライアントIDのコンテキスト内で（すなわち、異なるファイルハンドル、所有者、またはロックの種類）は、異なる目的のために再利用してはなりません。サーバは、それがそうでなければ解放されてもよいが、そうしなければ、それが以前の値と「SEQID」連続性を維持しなければならない点を越えて同じ目的のために、「その他」の値を保持することができます。"
    },
    {
      "indent": 3,
      "text": "One mechanism that may be used to satisfy the requirement that the server recognize invalid and out-of-date stateids is for the server to divide the \"other\" field of the stateid into two fields.",
      "ja": "サーバが無効とアウト日付のstateidsを認識要件を満たすために使用され得る1つの機構は、サーバーに2つのフィールドへのstateidの「その他」フィールドを分割するためのものです。"
    },
    {
      "indent": 3,
      "text": "o an index into a table of locking-state structures.",
      "ja": "Oロック状態構造のテーブルへのインデックス。"
    },
    {
      "indent": 3,
      "text": "o a generation number that is incremented on each allocation of a table entry for a particular use.",
      "ja": "特定の使用のためのテーブルエントリの各割当にインクリメントされる世代番号O。"
    },
    {
      "indent": 3,
      "text": "And then store in each table entry,",
      "ja": "そして、各テーブルエントリに格納"
    },
    {
      "indent": 3,
      "text": "o the client ID with which the stateid is associated.",
      "ja": "たstateidが関連付けられているクライアントID O。"
    },
    {
      "indent": 3,
      "text": "o the current generation number for the (at most one) valid stateid sharing this index value.",
      "ja": "このインデックス値を共有する（最大1つ）の有効なstateidの現在の世代番号O。"
    },
    {
      "indent": 3,
      "text": "o the filehandle of the file on which the locks are taken.",
      "ja": "ロックが取られているファイルのファイルハンドルO。"
    },
    {
      "indent": 3,
      "text": "o an indication of the type of stateid (open, byte-range lock, file delegation, directory delegation, layout).",
      "ja": "Oのstateidのタイプの指示（オープン、バイト範囲ロックは、委任、ディレクトリ委任、レイアウトファイル）。"
    },
    {
      "indent": 3,
      "text": "o the last \"seqid\" value returned corresponding to the current \"other\" value.",
      "ja": "O最後の「SEQID」値は、現在の「その他」の値に対応する戻りました。"
    },
    {
      "indent": 3,
      "text": "o an indication of the current status of the locks associated with this stateid, in particular, whether these have been revoked and if so, for what reason.",
      "ja": "これらが取り消されたか否か、具体的には、本のstateidに関連付けられているロックの現在のステータスの表示Oとそうであれば、どのような理由のために。"
    },
    {
      "indent": 3,
      "text": "With this information, an incoming stateid can be validated and the appropriate error returned when necessary. Special and non-special stateids are handled separately. (See Section 8.2.3 for a discussion of special stateids.)",
      "ja": "この情報を用いて、着信のstateidを検証することができ、必要なときに適切なエラーが返されます。特殊および非特殊なのstateidsは別々に処理されています。 （特別のstateidsの議論については、セクション8.2.3を参照してください。）"
    },
    {
      "indent": 3,
      "text": "Note that stateids are implicitly qualified by the current client ID, as derived from the client ID associated with the current session. Note, however, that the semantics of the session will prevent stateids associated with a previous client or server instance from being analyzed by this procedure.",
      "ja": "現在のセッションに関連付けられているクライアントIDから派生としてのstateidsが暗黙のうち、現在のクライアントIDで修飾されていることに注意してください。セッションのセマンティクスは、この手順によって分析されているから、以前のクライアントまたはサーバのインスタンスに関連付けられているのstateidsを予防すること、しかし、注意してください。"
    },
    {
      "indent": 3,
      "text": "If server restart has resulted in an invalid client ID or a session ID that is invalid, SEQUENCE will return an error and the operation that takes a stateid as an argument will never be processed.",
      "ja": "サーバの再起動が無効なクライアントID、または無効であるセッションIDをもたらした場合は、SEQUENCEはエラーと引数が処理されることはありませんようなstateidを取る操作を返します。"
    },
    {
      "indent": 3,
      "text": "If there has been a server restart where there is a persistent session and all leased state has been lost, then the session in question will, although valid, be marked as dead, and any operation not satisfied by means of the reply cache will receive the error NFS4ERR_DEADSESSION, and thus not be processed as indicated below.",
      "ja": "そこに永続的なセッションがあり、すべてのリース状態が失われたサーバーの再起動があった場合には、当該のセッションは、有効なものの、死者としてマークされ、応答キャッシュによって満たされていない任意の操作が届きますエラーNFS4ERR_DEADSESSION、及び以下に示すようにこのように処理されません。"
    },
    {
      "indent": 3,
      "text": "When a stateid is being tested and the \"other\" field is all zeros or all ones, a check that the \"other\" and \"seqid\" fields match a defined combination for a special stateid is done and the results determined as follows:",
      "ja": "stateidがテストされていると、「その他」の欄はすべてゼロまたはすべてのもので、「その他」と「SEQID」フィールドは特別なstateidのために定義された組み合わせと一致していることをチェックが行われ、以下のような結果が決定した場合："
    },
    {
      "indent": 3,
      "text": "o If the \"other\" and \"seqid\" fields do not match a defined combination associated with a special stateid, the error NFS4ERR_BAD_STATEID is returned.",
      "ja": "「その他」と「SEQID」フィールドは特別なstateidに関連付けられて定義された組み合わせと一致しない場合は、O、エラーNFS4ERR_BAD_STATEIDが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the special stateid is one designating the current stateid and there is a current stateid, then the current stateid is substituted for the special stateid and the checks appropriate to non-special stateids are performed.",
      "ja": "特別のstateidは現在のstateidを指定するものであると、現在のstateidが存在する場合、O、現在のstateidは、特別なstateidに置換され、非特別のstateidsに適切なチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "o If the combination is valid in general but is not appropriate to the context in which the stateid is used (e.g., an all-zero stateid is used when an OPEN stateid is required in a LOCK operation), the error NFS4ERR_BAD_STATEID is also returned.",
      "ja": "組み合わせは、一般的に有効であるが、（OPENのstateidがロック動作に必要とされる場合、例えば、全てゼロのstateidが使用されている）のstateidが使用される文脈に適切でない場合はO、エラーNFS4ERR_BAD_STATEIDも返されます。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the check is completed and the special stateid is accepted as valid.",
      "ja": "Oそれ以外の場合は、チェックが完了し、特別なstateidが有効なものとして受け入れられています。"
    },
    {
      "indent": 3,
      "text": "When a stateid is being tested, and the \"other\" field is neither all zeros nor all ones, the following procedure could be used to validate an incoming stateid and return an appropriate error, when necessary, assuming that the \"other\" field would be divided into a table index and an entry generation.",
      "ja": "stateidがテストされ、そして「その他」フィールドがすべてゼロでも全てのものでもない場合、次の手順は、着信のstateidを検証し、適切なエラーを返すために使用することができる、と仮定すると、必要な場合、「他の」フィールドは、あろうことテーブルインデックスエントリの世代に分け。"
    },
    {
      "indent": 3,
      "text": "o If the table index field is outside the range of the associated table, return NFS4ERR_BAD_STATEID.",
      "ja": "テーブルインデックスフィールドは、関連するテーブルの範囲外である場合、O、NFS4ERR_BAD_STATEIDを返します。"
    },
    {
      "indent": 3,
      "text": "o If the selected table entry is of a different generation than that specified in the incoming stateid, return NFS4ERR_BAD_STATEID.",
      "ja": "選択されたテーブル・エントリが入ってくるのstateidで指定されたものとは異なる世代である場合、O、NFS4ERR_BAD_STATEIDを返します。"
    },
    {
      "indent": 3,
      "text": "o If the selected table entry does not match the current filehandle, return NFS4ERR_BAD_STATEID.",
      "ja": "選択したテーブルのエントリは、現在のファイルハンドルと一致しない場合は、O、NFS4ERR_BAD_STATEIDを返します。"
    },
    {
      "indent": 3,
      "text": "o If the client ID in the table entry does not match the client ID associated with the current session, return NFS4ERR_BAD_STATEID.",
      "ja": "Oテーブルエントリ内のクライアントIDはNFS4ERR_BAD_STATEIDを返し、現在のセッションに関連付けられているクライアントIDと一致しない場合。"
    },
    {
      "indent": 3,
      "text": "o If the stateid represents revoked state, then return NFS4ERR_EXPIRED, NFS4ERR_ADMIN_REVOKED, or NFS4ERR_DELEG_REVOKED, as appropriate.",
      "ja": "stateidが失効状態を表す場合、O、次いで必要に応じて、NFS4ERR_EXPIRED、NFS4ERR_ADMIN_REVOKED、又はNFS4ERR_DELEG_REVOKEDを返します。"
    },
    {
      "indent": 3,
      "text": "o If the stateid type is not valid for the context in which the stateid appears, return NFS4ERR_BAD_STATEID. Note that a stateid may be valid in general, as would be reported by the TEST_STATEID operation, but be invalid for a particular operation, as, for example, when a stateid that doesn't represent byte-range locks is passed to the non-from_open case of LOCK or to LOCKU, or when a stateid that does not represent an open is passed to CLOSE or OPEN_DOWNGRADE. In such cases, the server MUST return NFS4ERR_BAD_STATEID.",
      "ja": "stateidタイプがのstateidが現れるコンテキストのために有効でない場合は、O、NFS4ERR_BAD_STATEIDを返します。バイト範囲ロックを表していないのstateidが非に渡されたときのstateidは、例えば、として、TEST_STATEID操作によって報告されるように、一般的には有効であるが、特定の動作のために無効であってもよいことに留意されたいですLOCKの又はLOCKUにfrom_open場合、またはオープンを表さないのstateidは閉じるかOPEN_DOWNGRADEに渡されたとき。このような場合には、サーバがNFS4ERR_BAD_STATEIDを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the \"seqid\" field is not zero and it is greater than the current sequence value corresponding to the current \"other\" field, return NFS4ERR_BAD_STATEID.",
      "ja": "「SEQID」フィールドがゼロでないと、それは現在の「その他」フィールドに対応する現在のシーケンス値よりも大きい場合には、O、NFS4ERR_BAD_STATEIDを返します。"
    },
    {
      "indent": 3,
      "text": "o If the \"seqid\" field is not zero and it is less than the current sequence value corresponding to the current \"other\" field, return NFS4ERR_OLD_STATEID.",
      "ja": "「SEQID」フィールドがゼロでないと、それは現在の「その他」フィールドに対応する現在のシーケンス値未満である場合、O、NFS4ERR_OLD_STATEIDを返します。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the stateid is valid and the table entry should contain any additional information about the type of stateid and information associated with that particular type of stateid, such as the associated set of locks, e.g., open-owner and lock-owner information, as well as information on the specific locks, e.g., open modes and byte-ranges.",
      "ja": "Oそうでない場合、のstateidは有効であり、テーブルエントリは、そのようなロックの関連したセットとして、例えば、オープン所有者とロック所有者情報のstateidの特定のタイプに関連付けられているのstateid情報のタイプに関する追加情報を含むべきですならびに特定のロック、例えば、オープンモードとバイト範囲に関する情報。"
    },
    {
      "indent": 0,
      "text": "8.2.5. Stateid Use for I/O Operations",
      "section_title": true,
      "ja": "8.2.5.  I / O操作のためのstateid使用"
    },
    {
      "indent": 3,
      "text": "Clients performing I/O operations need to select an appropriate stateid based on the locks (including opens and delegations) held by the client and the various types of state-owners sending the I/O requests. SETATTR operations that change the file size are treated like I/O operations in this regard.",
      "ja": "I / O操作を実行するクライアントは、クライアントが保持している（開いて代表団を含む）ロックおよびI / O要求を送信状態の所有者の様々なタイプに基づいて適切なstateidを選択する必要があります。ファイルサイズを変更するSETATTR操作は、この点でI / O操作のように扱われます。"
    },
    {
      "indent": 3,
      "text": "The following rules, applied in order of decreasing priority, govern the selection of the appropriate stateid. In following these rules, the client will only consider locks of which it has actually received notification by an appropriate operation response or callback. Note that the rules are slightly different in the case of I/O to data servers when file layouts are being used (see Section 13.9.1).",
      "ja": "優先度の高いものから順に適用される以下の規則は、適切なのstateidの選択を支配します。これらのルールを次のように、クライアントは、それが実際に適切な操作の応答またはコールバックにより通知を受けたのロックを検討します。ファイルのレイアウトは（項13.9.1を参照）を使用しているときのルールは、データ・サーバへのI / Oの場合は、わずかに異なっていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "o If the client holds a delegation for the file in question, the delegation stateid SHOULD be used.",
      "ja": "クライアントは、問題のファイルのための委任を保持している場合は、O、委任のstateidを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if the entity corresponding to the lock-owner (e.g., a process) sending the I/O has a byte-range lock stateid for the associated open file, then the byte-range lock stateid for that lock-owner and open file SHOULD be used.",
      "ja": "Oそれ以外の場合は、エンティティがロック所有者に対応する場合（例えば、プロセス）I / Oに関連したオープンファイルのバイト範囲ロックのstateid、そのロック所有者とオープン用次いでバイト範囲ロックのstateidを有する送信ファイルを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If there is no byte-range lock stateid, then the OPEN stateid for the open file in question SHOULD be used.",
      "ja": "何のバイト範囲ロックのstateidがない場合は、O、その後、問題の開いているファイルのOPENのstateidを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Finally, if none of the above apply, then a special stateid SHOULD be used.",
      "ja": "上記に該当しない場合はO最後に、その後、特別のstateidを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Ignoring these rules may result in situations in which the server does not have information necessary to properly process the request. For example, when mandatory byte-range locks are in effect, if the stateid does not indicate the proper lock-owner, via a lock stateid, a request might be avoidably rejected.",
      "ja": "これらのルールを無視すると、サーバがリクエストを適切に処理するために必要な情報を持っていないという状況になることがあります。必須バイト範囲ロックが有効になっているときのstateidは、適切なロック所有者を示すものではありません場合たとえば、ロックのstateidを経由して、要求がavoidably拒否されることがあります。"
    },
    {
      "indent": 3,
      "text": "The server however should not try to enforce these ordering rules and should use whatever information is available to properly process I/O requests. In particular, when a client has a delegation for a given file, it SHOULD take note of this fact in processing a request, even if it is sent with a special stateid.",
      "ja": "サーバーは、しかし、これらの発注ルールを適用しようとするべきではないと適切にI / O要求を処理するために利用可能であるどんな情報を使用する必要があります。クライアントが指定したファイルのための委任を持っているとき、特に、それが特別なstateidで送信された場合でも、要求を処理するには、この事実に注意を払うべきです。"
    },
    {
      "indent": 0,
      "text": "8.2.6. Stateid Use for SETATTR Operations",
      "section_title": true,
      "ja": "8.2.6.  SETATTR操作のためのstateid使用"
    },
    {
      "indent": 3,
      "text": "Because each operation is associated with a session ID and from that the clientid can be determined, operations do not need to include a stateid for the server to be able to determine whether they should cause a delegation to be recalled or are to be treated as done within the scope of the delegation.",
      "ja": "各操作はのClientIDを決定することができるセッションIDにしてから、関連付けられているため、操作は、彼らが代表団が行ったように扱われることを想起したりしていることが原因かどうかを決定できるようにするには、サーバー用のstateidを含める必要はありません委任の範囲内です。"
    },
    {
      "indent": 3,
      "text": "In the case of SETATTR operations, a stateid is present. In cases other than those that set the file size, the client may send either a special stateid or, when a delegation is held for the file in question, a delegation stateid. While the server SHOULD validate the stateid and may use the stateid to optimize the determination as to whether a delegation is held, it SHOULD note the presence of a delegation even when a special stateid is sent, and MUST accept a valid delegation stateid when sent.",
      "ja": "SETATTR操作の場合、のstateidが存在します。ファイルサイズを設定しているもの以外のケースでは、クライアントは、代表団が問題のファイル、委任のstateidのために保持されている特別なstateidか、のいずれかを送信することができます。サーバがたstateidを検証する必要がありますし、委任が保持されているかどうかについての決意を最適化するためのstateidを使用することができますが、それは特別なstateidが送られても代表団の存在に注意する必要があり、かつ送信されたときに有効な委任のstateidを受け入れなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.3. Lease Renewal",
      "section_title": true,
      "ja": "8.3. リースの更新"
    },
    {
      "indent": 3,
      "text": "Each client/server pair, as represented by a client ID, has a single lease. The purpose of the lease is to allow the client to indicate to the server, in a low-overhead way, that it is active, and thus that the server is to retain the client's locks. This arrangement allows the server to remove stale locking-related objects that are held by a client that has crashed or is otherwise unreachable, once the relevant lease expires. This in turn allows other clients to obtain conflicting locks without being delayed indefinitely by inactive or unreachable clients. It is not a mechanism for cache consistency and lease renewals may not be denied if the lease interval has not expired.",
      "ja": "各クライアント/サーバのペアは、クライアントのIDによって表されるように、単一リースを持っています。リースの目的は、クライアントが、それがアクティブであるため、サーバーがクライアントのロックを保持することであるということを、低オーバーヘッドの方法で、サーバーに指示することができるようにすることです。この構成では、サーバがクラッシュまたは関連するリースが期限切れになった後は、そうでなければ到達できたクライアントによって保持されている失効ロッキング関連オブジェクトを削除することを可能にします。これは、順番に他のクライアントが非アクティブまたは到達不能クライアントが無期限に延期されることなく、競合するロックを取得することができます。リース期間が満了していない場合は拒否されないことがキャッシュの一貫性とリース更新のためのメカニズムではありません。"
    },
    {
      "indent": 3,
      "text": "Since each session is associated with a specific client (identified by the client's client ID), any operation sent on that session is an indication that the associated client is reachable. When a request is sent for a given session, successful execution of a SEQUENCE operation (or successful retrieval of the result of SEQUENCE from the reply cache) on an unexpired lease will result in the lease being implicitly renewed, for the standard renewal period (equal to the lease_time attribute).",
      "ja": "各セッションは（クライアントのクライアントIDによって識別される）特定のクライアントに関連付けられているので、そのセッションで送信された操作は、関連するクライアントが到達可能であることを示しています。要求が特定のセッションのために送信された場合、期限が切れていないリースでシーケンス動作の実行が成功（または応答キャッシュからの配列の結果の成功した検索は）等しい（暗黙的に標準的な更新期間のために、更新されたリースをもたらすであろうlease_time属性に）。"
    },
    {
      "indent": 3,
      "text": "If the client ID's lease has not expired when the server receives a SEQUENCE operation, then the server MUST renew the lease. If the client ID's lease has expired when the server receives a SEQUENCE operation, the server MAY renew the lease; this depends on whether any state was revoked as a result of the client's failure to renew the lease before expiration.",
      "ja": "サーバがシーケンス動作を受信したときにクライアントIDのリースが期限切れになっていない場合、サーバーはリースを更新しなければなりません。サーバがシーケンス動作を受信したときにクライアントIDのリースの有効期限が切れている場合、サーバはリースを更新することができます。これはどのような状態が満了する前にリースを更新するには、クライアントの失敗の結果として取り消されたかどうかに依存します。"
    },
    {
      "indent": 3,
      "text": "Absent other activity that would renew the lease, a COMPOUND consisting of a single SEQUENCE operation will suffice. The client should also take communication-related delays into account and take steps to ensure that the renewal messages actually reach the server in good time. For example:",
      "ja": "リースの更新でしょう不在その他の活動は、単一のシーケンス動作からなる化合物が十分です。クライアントも考慮に通信関連の遅延を取り、更新メッセージは、実際に良い時間にサーバに到達することを確保するための措置をとる必要があります。例えば："
    },
    {
      "indent": 3,
      "text": "o When trunking is in effect, the client should consider sending multiple requests on different connections, in order to ensure that renewal occurs, even in the event of blockage in the path used for one of those connections.",
      "ja": "トランキングが有効な場合、O、クライアントでも、それらのいずれかの接続に使用するパス内の閉塞が発生した場合には、更新が発生することを確実にするために、異なった接続で複数の要求を送信することを検討すべきです。"
    },
    {
      "indent": 3,
      "text": "o Transport retransmission delays might become so large as to approach or exceed the length of the lease period. This may be particularly likely when the server is unresponsive due to a restart; see Section 8.4.2.1. If the client implementation is not careful, transport retransmission delays can result in the client failing to detect a server restart before the grace period ends. The scenario is that the client is using a transport with exponential backoff, such that the maximum retransmission timeout exceeds both the grace period and the lease_time attribute. A network partition causes the client's connection's retransmission interval to back off, and even after the partition heals, the next transport-level retransmission is sent after the server has restarted and its grace period ends.",
      "ja": "O交通再送遅延が接近又はリース期間の長さを超えるように大きくなる可能性があります。これは、再起動するようにサーバーが応答しない場合に特に可能性が高いです。セクション8.4.2.1を参照してください。クライアントの実装は慎重でない場合は、輸送再送遅延は、猶予期間が終了する前に、サーバーの再起動を検出できないクライアントになることができます。シナリオは、クライアントが最大再送タイムアウトが猶予期間とlease_time属性の両方を超えるように、指数バックオフでトランスポートを使用していることです。ネットワークパーティションはオフにバックアップするクライアントの接続の再送信間隔を引き起こし、さらにはパーティションが治癒した後、次のトランスポート・レベルの再送信は、サーバーが再起動した後に送られ、その猶予期間が終了しています。"
    },
    {
      "indent": 6,
      "text": "The client MUST either recover from the ensuing NFS4ERR_NO_GRACE errors or it MUST ensure that, despite transport-level retransmission intervals that exceed the lease_time, a SEQUENCE operation is sent that renews the lease before expiration. The client can achieve this by associating a new connection with the session, and sending a SEQUENCE operation on it. However, if the attempt to establish a new connection is delayed for some reason (e.g., exponential backoff of the connection establishment packets), the client will have to abort the connection establishment attempt before the lease expires, and attempt to reconnect.",
      "ja": "クライアントはその後NFS4ERR_NO_GRACEエラーから回復しなければならないのいずれか、またはそれがlease_timeを超えてトランスポートレベルの再送間隔にもかかわらず、シーケンス動作が満了する前にリースを更新すること送信される、ことを確認しなければなりません。クライアントは、セッションとの新しい接続を関連付け、その上にシーケンス動作を送信することによって、これを達成することができます。新しい接続を確立しようとする試みは、何らかの理由（接続確立パケットの、例えば、指数バックオフ）のために遅れている場合は、クライアントは、リースの期限が切れる前に、接続確立の試行を中止しなければならない、と再接続を試みます。"
    },
    {
      "indent": 3,
      "text": "If the server renews the lease upon receiving a SEQUENCE operation, the server MUST NOT allow the lease to expire while the rest of the operations in the COMPOUND procedure's request are still executing.",
      "ja": "サーバがシーケンス動作を受けてリースを更新した場合、サーバはCOMPOUND手順の要求での操作の残りはまだ実行されている間、リースが期限切れに許してはなりません。"
    },
    {
      "indent": 3,
      "text": "Once the last operation has finished, and the response to COMPOUND has been sent, the server MUST set the lease to expire no sooner than the sum of current time and the value of the lease_time attribute.",
      "ja": "最後の操作が完了すると、化合物への応答が送信されると、サーバはやいなや、現在の時間の合計とlease_time属性の値よりも期限切れにリースを設定してはなりません。"
    },
    {
      "indent": 3,
      "text": "A client ID's lease can expire when it has been at least the lease interval (lease_time) since the last lease-renewing SEQUENCE operation was sent on any of the client ID's sessions and there are no active COMPOUND operations on any such sessions.",
      "ja": "最後のリース更新シーケンス動作は、クライアントIDのセッションのいずれかに送信され、どのようなセッションには、活性化合物の操作があるなかったので、それは、少なくともリース期間（lease_time）となっているときに、クライアントIDのリースが期限切れになることができます。"
    },
    {
      "indent": 3,
      "text": "Because the SEQUENCE operation is the basic mechanism to renew a lease, and because it must be done at least once for each lease period, it is the natural mechanism whereby the server will inform the client of changes in the lease status that the client needs to be informed of. The client should inspect the status flags (sr_status_flags) returned by sequence and take the appropriate action (see Section 18.46.3 for details).",
      "ja": "シーケンス動作は、リースを更新するための基本的な機構であり、それはそれぞれのリース期間に少なくとも一度行わなければならないため、サーバーは、クライアントが必要であることを、リース状態の変化をクライアントに通知することによって、それが自然のメカニズムであるため、が通知さ。クライアントは、シーケンスによって返されるステータスフラグ（sr_status_flags）を検査します（詳細については、セクション18.46.3を参照）、適切な行動を取る必要があります。"
    },
    {
      "indent": 3,
      "text": "o The status bits SEQ4_STATUS_CB_PATH_DOWN and SEQ4_STATUS_CB_PATH_DOWN_SESSION indicate problems with the backchannel that the client may need to address in order to receive callback requests.",
      "ja": "ステータスビットのSEQ4_STATUS_CB_PATH_DOWNとSEQ4_STATUS_CB_PATH_DOWN_SESSION oをクライアントがコールバック要求を受信するために対処する必要があるかもしれないことにバックチャネルの問題を示しています。"
    },
    {
      "indent": 3,
      "text": "o The status bits SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING and SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED indicate problems with GSS contexts or RPCSEC_GSS handles for the backchannel that the client might have to address in order to allow callback requests to be sent.",
      "ja": "ステータスビットのSEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRINGとSEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED oをGSSコンテキストまたはRPCSEC_GSSでの問題は、クライアントがコールバック要求を送信することができるようにするために対処する必要がある場合がありますことを、バックチャネルのハンドルを示しています。"
    },
    {
      "indent": 3,
      "text": "o The status bits SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED, SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED, SEQ4_STATUS_ADMIN_STATE_REVOKED, and SEQ4_STATUS_RECALLABLE_STATE_REVOKED notify the client of lock revocation events. When these bits are set, the client should use TEST_STATEID to find what stateids have been revoked and use FREE_STATEID to acknowledge loss of the associated state.",
      "ja": "ステータスビットoをSEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED、SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED、SEQ4_STATUS_ADMIN_STATE_REVOKED、及びSEQ4_STATUS_RECALLABLE_STATE_REVOKEDロック失効イベントのクライアントに通知します。これらのビットが設定されている場合、クライアントはのstateidsが取り消されているものを見つけると関連付けられた状態の喪失を確認するためにFREE_STATEIDを使用するTEST_STATEIDを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The status bit SEQ4_STATUS_LEASE_MOVE indicates that responsibility for lease renewal has been transferred to one or more new servers.",
      "ja": "OステータスビットSEQ4_STATUS_LEASE_MOVEは、リース更新のための責任が1つ以上の新しいサーバに転送されたことを示します。"
    },
    {
      "indent": 3,
      "text": "o The status bit SEQ4_STATUS_RESTART_RECLAIM_NEEDED indicates that due to server restart the client must reclaim locking state.",
      "ja": "OステータスビットSEQ4_STATUS_RESTART_RECLAIM_NEEDEDは、サーバーに再起動するため、クライアントは状態をロック取り戻す必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "o The status bit SEQ4_STATUS_BACKCHANNEL_FAULT indicates that the server has encountered an unrecoverable fault with the backchannel (e.g., it has lost track of a sequence ID for a slot in the backchannel).",
      "ja": "OステータスビットSEQ4_STATUS_BACKCHANNEL_FAULTは、サーバが（例えば、それはバックチャネルのスロットのシーケンスIDの追跡を失った）バックチャネルと、回復不能な障害が発生したことを示しています。"
    },
    {
      "indent": 0,
      "text": "8.4. Crash Recovery",
      "section_title": true,
      "ja": "8.4. クラッシュ回復"
    },
    {
      "indent": 3,
      "text": "A critical requirement in crash recovery is that both the client and the server know when the other has failed. Additionally, it is required that a client sees a consistent view of data across server restarts. All READ and WRITE operations that may have been queued within the client or network buffers must wait until the client has successfully recovered the locks protecting the READ and WRITE operations. Any that reach the server before the server can safely determine that the client has recovered enough locking state to be sure that such operations can be safely processed must be rejected. This will happen because either:",
      "ja": "クラッシュリカバリの重要な要件は、他に障害が発生したときにクライアントとサーバーの両方が知っていることです。さらに、クライアントがサーバを再起動してデータの一貫性のあるビューを見ることが必要です。クライアントが正常に読み取りおよび書き込み操作を保護するロックを回復するまで、クライアントまたはネットワークバッファ内キューに登録されている可能性があり、すべての読み取りおよび書き込み操作が待機する必要があります。サーバーの前に、サーバーに到達するいずれかが安全にクライアントが安全に処理できるような操作を拒否しなければならないことを確認するために十分なロック状態を回復したと判断することができます。どちらかのために発生します："
    },
    {
      "indent": 3,
      "text": "o The state presented is no longer valid since it is associated with a now invalid client ID. In this case, the client will receive either an NFS4ERR_BADSESSION or NFS4ERR_DEADSESSION error, and any attempt to attach a new session to that invalid client ID will result in an NFS4ERR_STALE_CLIENTID error.",
      "ja": "それが今で無効なクライアントIDに関連付けられているので、O提示状態が有効ではありません。この場合、クライアントはNFS4ERR_BADSESSIONまたはNFS4ERR_DEADSESSIONエラーのいずれかを受け取ることになりますし、その無効なクライアントIDに新しいセッションを添付しようとすると、NFS4ERR_STALE_CLIENTIDエラーになります。"
    },
    {
      "indent": 3,
      "text": "o Subsequent recovery of locks may make execution of the operation inappropriate (NFS4ERR_GRACE).",
      "ja": "Oロックのその後の回復は、（NFS4ERR_GRACE）不適切な操作の実行を行うことができます。"
    },
    {
      "indent": 0,
      "text": "8.4.1. Client Failure and Recovery",
      "section_title": true,
      "ja": "8.4.1. クライアントの障害と復旧"
    },
    {
      "indent": 3,
      "text": "In the event that a client fails, the server may release the client's locks when the associated lease has expired. Conflicting locks from another client may only be granted after this lease expiration. As discussed in Section 8.3, when a client has not failed and re-establishes its lease before expiration occurs, requests for conflicting locks will not be granted.",
      "ja": "関連するリースが期限切れになったときに、クライアントに障害が発生した場合には、サーバはクライアントのロックを解除することができます。別のクライアントから競合するロックにのみ、このリース満了後に付与することができます。有効期限が発生する前に、クライアントがそのリースを失敗し、再確立していない、セクション8.3で説明したように、競合するロックの要求は認められません。"
    },
    {
      "indent": 3,
      "text": "To minimize client delay upon restart, lock requests are associated with an instance of the client by a client-supplied verifier. This verifier is part of the client_owner4 sent in the initial EXCHANGE_ID call made by the client. The server returns a client ID as a result of the EXCHANGE_ID operation. The client then confirms the use of the client ID by establishing a session associated with that client ID (see Section 18.36.3 for a description of how this is done). All locks, including opens, byte-range locks, delegations, and layouts obtained by sessions using that client ID, are associated with that client ID.",
      "ja": "再起動時にクライアントの遅延を最小限に抑えるために、ロック要求は、クライアントが提供する検証することで、クライアントのインスタンスに関連付けられています。この検証では、クライアントによって行われた最初のEXCHANGE_ID呼び出しで送信されclient_owner4の一部です。サーバーはEXCHANGE_ID操作の結果としてクライアントのIDを返します。クライアントは、そのクライアントIDに関連付けられたセッションを確立することにより、クライアントのIDを使用することを確認する（これがどのように行われるかの説明については、セクション18.36.3を参照してください）。すべてのロックは、を含むが開き、そのクライアントのIDを使用するセッションによって得られたバイト範囲ロック、代表団、およびレイアウトは、そのクライアントIDに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Since the verifier will be changed by the client upon each initialization, the server can compare a new verifier to the verifier associated with currently held locks and determine that they do not match. This signifies the client's new instantiation and subsequent loss (upon confirmation of the new client ID) of locking state. As a result, the server is free to release all locks held that are associated with the old client ID that was derived from the old verifier. At this point, conflicting locks from other clients, kept waiting while the lease had not yet expired, can be granted. In addition, all stateids associated with the old client ID can also be freed, as they are no longer reference-able.",
      "ja": "検証は、各初期化時にクライアントによって変更されますので、サーバーは現在保持しているロックに関連した検証者に新しい検証を比較し、一致していないと判断することができます。これは、状態をロックする（新しいクライアントIDの確認時に）クライアントの新しいインスタンス化とその後の損失を意味します。その結果、サーバは古い検証から得られた古いクライアントIDに関連付けられて保持されているすべてのロックを解放して自由です。この時点で、他のクライアントから競合するロックは、リースがまだ有効期限が切れていなかった一方で、付与することができ待たさ。彼らはもはや参照できますよう加えて、古いクライアントのIDに関連付けられているすべてのstateidsも、解放することはできません。"
    },
    {
      "indent": 3,
      "text": "Note that the verifier must have the same uniqueness properties as the verifier for the COMMIT operation.",
      "ja": "検証は、COMMIT操作のための検証と同じ独自性の性質を持っている必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "8.4.2. Server Failure and Recovery",
      "section_title": true,
      "ja": "8.4.2. サーバーの障害と復旧"
    },
    {
      "indent": 3,
      "text": "If the server loses locking state (usually as a result of a restart), it must allow clients time to discover this fact and re-establish the lost locking state. The client must be able to re-establish the locking state without having the server deny valid requests because the server has granted conflicting access to another client. Likewise, if there is a possibility that clients have not yet re-established their locking state for a file and that such locking state might make it invalid to perform READ or WRITE operations. For example, if mandatory locks are a possibility, the server must disallow READ and WRITE operations for that file.",
      "ja": "サーバーが（通常は再起動の結果としての）状態をロック失った場合、それはこの事実を発見し、失われたロック状態を再確立するために、クライアントの時間を許可する必要があります。クライアントは、サーバーが他のクライアントへのアクセスが競合付与しているため、サーバーは有効な要求を拒否せずにロック状態を再確立することができなければなりません。同様に、クライアントはまだファイルのために彼らのロック状態を再確立して、このようなロック状態は、READまたはWRITE操作を実行することを無効にするかもしれないしていない可能性がある場合。強制ロックが可能であれば例えば、サーバはREADを禁止しなければなりませんし、そのファイルに対する操作を記述します。"
    },
    {
      "indent": 3,
      "text": "A client can determine that loss of locking state has occurred via several methods.",
      "ja": "クライアントは状態をロックの損失はいくつかの方法を経由して発生したと判断することができます。"
    },
    {
      "indent": 3,
      "text": "1. When a SEQUENCE (most common) or other operation returns NFS4ERR_BADSESSION, this may mean that the session has been destroyed but the client ID is still valid. The client sends a CREATE_SESSION request with the client ID to re-establish the session. If CREATE_SESSION fails with NFS4ERR_STALE_CLIENTID, the client must establish a new client ID (see Section 8.1) and re-establish its lock state with the new client ID, after the CREATE_SESSION operation succeeds (see Section 8.4.2.1).",
      "ja": "SEQUENCE（最も一般的）、または他の操作がNFS4ERR_BADSESSIONを返すとき1.、これは、セッションが破棄されたが、クライアントのIDがまだ有効であることを意味します。クライアントは、セッションを再確立するためのクライアントIDとCREATE_SESSION要求を送信します。 CREATE_SESSION操作が成功した後、（セクション8.4.2.1を参照）CREATE_SESSIONはNFS4ERR_STALE_CLIENTIDで失敗した場合、クライアントは新しいクライアントIDを確立する必要があります（8.1節を参照）、新しいクライアントIDとそのロック状態を再確立。"
    },
    {
      "indent": 3,
      "text": "2. When a SEQUENCE (most common) or other operation on a persistent session returns NFS4ERR_DEADSESSION, this indicates that a session is no longer usable for new, i.e., not satisfied from the reply cache, operations. Once all pending operations are determined to be either performed before the retry or not performed, the client sends a CREATE_SESSION request with the client ID to re-establish the session. If CREATE_SESSION fails with NFS4ERR_STALE_CLIENTID, the client must establish a new client ID (see Section 8.1) and re-establish its lock state after the CREATE_SESSION, with the new client ID, succeeds (Section 8.4.2.1).",
      "ja": "永続セッション上の配列（最も一般的）、または他の操作がNFS4ERR_DEADSESSIONを返す場合2.このセッションは、もはや操作応答キャッシュから、すなわち、満たされていない新たに使用可能であることを示していません。一旦、全ての保留中の操作が再試行する前に行われたり行われていないのいずれかであると判断され、クライアントが再確立セッションへのクライアントIDとCREATE_SESSION要求を送信します。 CREATE_SESSIONはNFS4ERR_STALE_CLIENTIDで失敗した場合、クライアントは新しいクライアントIDを確立する必要があります（8.1節を参照）、新しいクライアントID、成功した（セクション8.4.2.1）で、CREATE_SESSION後にそのロック状態を再確立。"
    },
    {
      "indent": 3,
      "text": "3. When an operation, neither SEQUENCE nor preceded by SEQUENCE (for example, CREATE_SESSION, DESTROY_SESSION), returns NFS4ERR_STALE_CLIENTID, the client MUST establish a new client ID (Section 8.1) and re-establish its lock state (Section 8.4.2.1).",
      "ja": "3.動作は、配列（例えば、CREATE_SESSION、DESTROY_SESSION）が先行もSEQUENCEもは、クライアントが新しいクライアントID（セクション8.1）と再確立そのロック状態（セクション8.4.2.1）を確立する必要があり、NFS4ERR_STALE_CLIENTIDを返す場合。"
    },
    {
      "indent": 0,
      "text": "8.4.2.1. State Reclaim",
      "section_title": true,
      "ja": "8.4.2.1。国家取り戻します"
    },
    {
      "indent": 3,
      "text": "When state information and the associated locks are lost as a result of a server restart, the protocol must provide a way to cause that state to be re-established. The approach used is to define, for most types of locking state (layouts are an exception), a request whose function is to allow the client to re-establish on the server a lock first obtained from a previous instance. Generally, these requests are variants of the requests normally used to create locks of that type and are referred to as \"reclaim-type\" requests, and the process of re-establishing such locks is referred to as \"reclaiming\" them.",
      "ja": "状態情報と関連付けられているロックは、サーバーの再起動の結果として失われている場合、プロトコルは、その状態を再確立することが原因とする方法を提供する必要があります。使用されるアプローチは、ロック状態のほとんどの種類（レイアウトは例外である）ため、その機能は、クライアントがサーバ最初の前のインスタンスから取得されたロックに再確立できるようにすることである要求を定義することです。一般的に、これらの要求は、通常、そのタイプのロックを作成するために使用される要求の変種であり、「再利用型」の要求と呼ばれ、再確立、ロックのプロセスは、それらを「再利用」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Because each client must have an opportunity to reclaim all of the locks that it has without the possibility that some other client will be granted a conflicting lock, a \"grace period\" is devoted to the reclaim process. During this period, requests creating client IDs and sessions are handled normally, but locking requests are subject to special restrictions. Only reclaim-type locking requests are allowed, unless the server can reliably determine (through state persistently maintained across restart instances) that granting any such lock cannot possibly conflict with a subsequent reclaim. When a request is made to obtain a new lock (i.e., not a reclaim-type request) during the grace period and such a determination cannot be made, the server must return the error NFS4ERR_GRACE.",
      "ja": "各クライアントが他のクライアントが競合ロックが付与される可能性なしに、それが持っているロックのすべてを再利用する機会を持っていなければならないので、「猶予期間」を再利用プロセスに専念しています。この期間中に、クライアントIDを作成し、要求とセッションが正常に処理されますが、ロック要求は、特別な制限を受けます。のみ再利用型のロック要求が許可され、サーバがない限り確実にそのようなロックを許可することは、おそらくその後の再利用と競合することができない（状態を通じて持続再始動インスタンス間で維持される）を決定することができます。要求が猶予期間中に新しいロック（すなわち、再利用しないタイプの要求）を取得するために作られ、そのような決意をすることができない場合、サーバはエラーNFS4ERR_GRACEを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once a session is established using the new client ID, the client will use reclaim-type locking requests (e.g., LOCK operations with reclaim set to TRUE and OPEN operations with a claim type of CLAIM_PREVIOUS; see Section 9.11) to re-establish its locking state. Once this is done, or if there is no such locking state to reclaim, the client sends a global RECLAIM_COMPLETE operation, i.e., one with the rca_one_fs argument set to FALSE, to indicate that it has reclaimed all of the locking state that it will reclaim. Once a client sends such a RECLAIM_COMPLETE operation, it may attempt non-reclaim locking operations, although it might get an NFS4ERR_GRACE status result from each such operation until the period of special handling is over. See Section 11.7.7 for a discussion of the analogous handling lock reclamation in the case of file systems transitioning from server to server.",
      "ja": "セッションが新しいクライアントIDを使用して確立されると、クライアントは再利用型のロック要求を使用します（例えば、CLAIM_PREVIOUSの請求タイプでTRUEとOPEN操作に設定し再利用してLOCK操作を、セクション9.11を参照）を再確立そのロックに状態。これが行われ、または再利用するそのようなロック状態が存在しない場合、クライアントはグローバルRECLAIM_COMPLETE操作、すなわち、FALSEに設定しrca_one_fs引数と一つに送信されると、それはそれは再利用することをロック状態のすべてを再利用していることを示すために、 。クライアントは、このようなRECLAIM_COMPLETE操作を送信すると、特別な処理の期間が終わるまで、それは、そのような各操作からNFS4ERR_GRACEステータス結果を得るかもしれませんが、それは、非再利用ロック操作を試みることができます。サーバーからサーバーへの移行ファイル・システムの場合における類似の取扱ロック埋め立ての議論については、セクション11.7.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "During the grace period, the server must reject READ and WRITE operations and non-reclaim locking requests (i.e., other LOCK and OPEN operations) with an error of NFS4ERR_GRACE, unless it can guarantee that these may be done safely, as described below.",
      "ja": "それは以下に説明するように、これらは、安全に行うことができることを保証できない限り、猶予期間中に、サーバは、NFS4ERR_GRACEの誤差とREADおよびWRITE操作と非再利用ロック要求（すなわち、他のLOCKとOPEN操作）を拒否しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The grace period may last until all clients that are known to possibly have had locks have done a global RECLAIM_COMPLETE operation, indicating that they have finished reclaiming the locks they held before the server restart. This means that a client that has done a RECLAIM_COMPLETE must be prepared to receive an NFS4ERR_GRACE when attempting to acquire new locks. In order for the server to know that all clients with possible prior lock state have done a RECLAIM_COMPLETE, the server must maintain in stable storage a list clients that may have such locks. The server may also terminate the grace period before all clients have done a global RECLAIM_COMPLETE. The server SHOULD NOT terminate the grace period before a time equal to the lease period in order to give clients an opportunity to find out about the server restart, as a result of sending requests on associated sessions with a frequency governed by the lease time. Note that when a client does not send such requests (or they are sent by the client but not received by the server), it is possible for the grace period to expire before the client finds out that the server restart has occurred.",
      "ja": "猶予期間は、おそらくロックが、彼らは、サーバーの再起動の前に開催されたロックを再利用が終了したことを示す、グローバルRECLAIM_COMPLETE操作を行っている持っていたことが知られているすべてのクライアントまで続くことがあります。これはRECLAIM_COMPLETEを行っているクライアントが新しいロックを取得しようとするときNFS4ERR_GRACEを受けるために準備しなければならないことを意味しています。サーバが可能以前のロック状態を持つすべてのクライアントがRECLAIM_COMPLETEを行っていることを知るためには、サーバが安定したストレージに、このようなロックを持っていることがあり、リストのクライアントを維持しなければなりません。すべてのクライアントがグローバルRECLAIM_COMPLETEを行っている前に、サーバーには、猶予期間を終了させることができます。サーバーは、クライアントにリース期間に支配周波数に関連したセッションの要求を送信した結果として、サーバの再起動について知る機会を与えるために、リース期間に等しい時間前に猶予期間を終了すべきではありません。クライアントは、サーバの再起動が発生したことを知り前に猶予期間が期限切れになるようにするために、クライアントがそのような要求を送信していない場合（またはそれらがクライアントによって送信されますが、サーバによって受信されない）ことに注意してください、それが可能です。"
    },
    {
      "indent": 3,
      "text": "Some additional time in order to allow a client to establish a new client ID and session and to effect lock reclaims may be added to the lease time. Note that analogous rules apply to file system-specific grace periods discussed in Section 11.7.7.",
      "ja": "新しいクライアントIDとセッションを確立すると、ロックを再要求を行うために、クライアントがリース時間に添加することができるようにするためのいくつかの追加の時間。類似の規則は、セクション11.7.7で説明したシステム固有の猶予期間をファイルに適用することに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the server can reliably determine that granting a non-reclaim request will not conflict with reclamation of locks by other clients, the NFS4ERR_GRACE error does not have to be returned even within the grace period, although NFS4ERR_GRACE must always be returned to clients attempting a non-reclaim lock request before doing their own global RECLAIM_COMPLETE. For the server to be able to service READ and WRITE operations during the grace period, it must again be able to guarantee that no possible conflict could arise between a potential reclaim locking request and the READ or WRITE operation. If the server is unable to offer that guarantee, the NFS4ERR_GRACE error must be returned to the client.",
      "ja": "サーバーは確実に非再利用要求を許可すると、他のクライアントによるロックの再利用と競合しない、NFS4ERR_GRACEエラーがNFS4ERR_GRACEは常に非を試みるクライアントに返さなければなりませんが、でも、猶予期間内に返却する必要がないことを確認できた場合自分のグローバルRECLAIM_COMPLETEを行う前に、ロック要求を-reclaim。サーバが猶予期間中に読み取りおよび書き込み操作にサービスを提供できるようにするには、再び何の可能性競合が要求およびREADまたはWRITE操作をロックする可能性のある再利用との間で発生することができなかったことを保証することができなければなりません。サーバがその保証を提供することができない場合は、NFS4ERR_GRACEエラーがクライアントに返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "For a server to provide simple, valid handling during the grace period, the easiest method is to simply reject all non-reclaim locking requests and READ and WRITE operations by returning the NFS4ERR_GRACE error. However, a server may keep information about granted locks in stable storage. With this information, the server could determine if a locking, READ or WRITE operation can be safely processed.",
      "ja": "サーバが猶予期間中に、単純な、有効な処理を提供するために、最も簡単な方法は、単純にNFS4ERR_GRACEエラーを返すことによって、要求とREADとWRITE操作をロックするすべての非再利用を拒否することです。ただし、サーバーは安定したストレージに付与されたロックに関する情報を保持することができます。ロックは、READまたはWRITE操作を安全に処理できる場合は、この情報を使用して、サーバが決定することができます。"
    },
    {
      "indent": 3,
      "text": "For example, if the server maintained on stable storage summary information on whether mandatory locks exist, either mandatory byte-range locks, or share reservations specifying deny modes, many requests could be allowed during the grace period. If it is known that no such share reservations exist, OPEN request that do not specify deny modes may be safely granted. If, in addition, it is known that no mandatory byte-range locks exist, either through information stored on stable storage or simply because the server does not support such locks, READ and WRITE operations may be safely processed during the grace period. Another important case is where it is known that no mandatory byte-range locks exist, either because the server does not provide support for them or because their absence is known from persistently recorded data. In this case, READ and WRITE operations specifying stateids derived from reclaim-type operations may be validly processed during the grace period because of the fact that the valid reclaim ensures that no lock subsequently granted can prevent the I/O.",
      "ja": "サーバは、強制ロックが存在するかどうかに安定記憶要約情報、のいずれか必須のバイト範囲ロック、またはモードを拒否する指定共有の予約に維持場合など、多くの要求が猶予期間中に許可することができます。それはそのような株式の予約が存在しないことが知られている場合は、モードを否定指定しないOPEN要求は安全に付与することができます。場合は、加えて、ない必須バイト範囲ロックが安定したストレージに格納されているいずれかの情報を介して、存在しないか、サーバがそのようなロックをサポートしていないという理由だけで、READおよびWRITE動作が安全に猶予期間中に処理され得ることが知られています。何の義務バイト範囲ロックが存在しないことが知られているもう一つの重要なケースがあり、どちらかのサーバがそれらのためか、彼らの不在が永続的に記録されたデータから知られているので、サポートを提供していませんので。この場合、再利用型事業から派生のstateidsを指定する読み取りおよび書き込み操作は、正当ための有効な再利用がその後に付与された何のロックがI / Oを防ぐことはできないことを保証しているという事実の猶予期間中に処理することができます。"
    },
    {
      "indent": 3,
      "text": "To reiterate, for a server that allows non-reclaim lock and I/O requests to be processed during the grace period, it MUST determine that no lock subsequently reclaimed will be rejected and that no lock subsequently reclaimed would have prevented any I/O operation processed during the grace period.",
      "ja": "猶予期間中に処理するために、非再利用ロックおよびI / O要求を可能にするサーバに対して、繰り返しに、それはその後埋め立て何のロックが拒否されないことを決定する必要があり、その後、埋め立て何のロックは任意のI / O操作を妨げないだろうということ猶予期間中に処理。"
    },
    {
      "indent": 3,
      "text": "Clients should be prepared for the return of NFS4ERR_GRACE errors for non-reclaim lock and I/O requests. In this case, the client should employ a retry mechanism for the request. A delay (on the order of several seconds) between retries should be used to avoid overwhelming the server. Further discussion of the general issue is included in [47]. The client must account for the server that can perform I/O and non-reclaim locking requests within the grace period as well as those that cannot do so.",
      "ja": "クライアントは、非再利用のためのロックNFS4ERR_GRACEエラーのリターンのために準備し、I ​​/ O要求されなければなりません。この場合、クライアントは要求の再試行メカニズムを採用する必要があります。再試行の間（数秒程度）の遅延は、サーバーを圧倒回避するために使用する必要があります。一般的な問題のさらなる議論は、[47]に含まれています。クライアントがそうすることができないものだけでなく、猶予期間内にI / Oと非再利用ロック要求を行うことができますサーバーを考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A reclaim-type locking request outside the server's grace period can only succeed if the server can guarantee that no conflicting lock or I/O request has been granted since restart.",
      "ja": "サーバが競合するロックまたはI / O要求を再起動してから付与されていないことを保証することができた場合、サーバーの猶予期間外の再利用型のロック要求にのみ成功することができます。"
    },
    {
      "indent": 3,
      "text": "A server may, upon restart, establish a new value for the lease period. Therefore, clients should, once a new client ID is established, refetch the lease_time attribute and use it as the basis for lease renewal for the lease associated with that server. However, the server must establish, for this restart event, a grace period at least as long as the lease period for the previous server instantiation. This allows the client state obtained during the previous server instance to be reliably re-established.",
      "ja": "サーバーは、再起動時に、リース期間のための新しい値を確立することができます。新しいクライアントIDが確​​立されるため、クライアントは、lease_time属性を再フェッチし、そのサーバーに関連付けられているリースのリース更新のための基礎としてそれを使用する必要があります。ただし、サーバはこの再起動イベント、猶予期間、少なくとも限り、以前のサーバインスタンス化のためのリース期間のために、確立する必要があります。これは、以前のサーバインスタンスの間に取得したクライアントの状態が確実に再確立することができます。"
    },
    {
      "indent": 3,
      "text": "The possibility exists that, because of server configuration events, the client will be communicating with a server different than the one on which the locks were obtained, as shown by the combination of eir_server_scope and eir_server_owner. This leads to the issue of if and when the client should attempt to reclaim locks previously obtained on what is being reported as a different server. The rules to resolve this question are as follows:",
      "ja": "可能性が存在し、そのサーバーの構成イベントの、クライアントはeir_server_scopeとeir_server_ownerの組み合わせによって示されるようにロックが、得られたものとは別のサーバと通信するため。これは、クライアントが以前に別のサーバーとして報告されているものに得られロックを再利用しようとしなければならない場合とする場合の問題につながります。次のようにこの質問を解決するためのルールは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the server scope is different, the client should not attempt to reclaim locks. In this situation, no lock reclaim is possible. Any attempt to re-obtain the locks with non-reclaim operations is problematic since there is no guarantee that the existing filehandles will be recognized by the new server, or that if recognized, they denote the same objects. It is best to treat the locks as having been revoked by the reconfiguration event.",
      "ja": "サーバーのスコープが異なる場合は、O、クライアントがロックを再利用しないでください。このような状況では、全くロック再利用が可能ではありません。既存のファイルハンドルが認識された場合、彼らは同じオブジェクトを表すことを新しいサーバによって認識、またはされるという保証はありませんので、非再生操作でロックを再取得しようとするには問題があります。これは、再構成イベントによって取り消されたとしてロックを処理することが最善です。"
    },
    {
      "indent": 3,
      "text": "o If the server scope is the same, the client should attempt to reclaim locks, even if the eir_server_owner value is different. In this situation, it is the responsibility of the server to return NFS4ERR_NO_GRACE if it cannot provide correct support for lock reclaim operations, including the prevention of edge conditions.",
      "ja": "サーバーのスコープが同じであればO、クライアントはeir_server_owner値が異なる場合でも、ロックを再利用しようとしなければなりません。このような状況では、それはロックがエッジ状態の予防を含め、業務を、取り戻すためにそれが正しいのサポートを提供することができない場合は、サーバの責任はNFS4ERR_NO_GRACEを返すことです。"
    },
    {
      "indent": 3,
      "text": "The eir_server_owner field is not used in making this determination. Its function is to specify trunking possibilities for the client (see Section 2.10.5) and not to control lock reclaim.",
      "ja": "eir_server_ownerフィールドは、この決意を作製する際に使用されていません。その機能は、クライアントのトランキングの可能性を（2.10.5項を参照）を指定すると、ロック再利用を制御することができません。"
    },
    {
      "indent": 0,
      "text": "8.4.2.1.1. Security Considerations for State Reclaim",
      "section_title": true,
      "ja": "8.4.2.1.1。国家取り戻すためのセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "During the grace period, a client can reclaim state that it believes or asserts it had before the server restarted. Unless the server maintained a complete record of all the state the client had, the server has little choice but to trust the client. (Of course, if the server maintained a complete record, then it would not have to force the client to reclaim state after server restart.) While the server has to trust the client to tell the truth, such trust does not have any negative consequences for security. The fundamental rule for the server when processing reclaim requests is that it MUST NOT grant the reclaim if an equivalent non-reclaim request would not be granted during steady state due to access control or access conflict issues. For example, an OPEN request during a reclaim will be refused with NFS4ERR_ACCESS if the principal making the request does not have access to open the file according to the discretionary ACL (Section 6.2.2) on the file.",
      "ja": "猶予期間中、クライアントはそれを信じているか、サーバーを再起動する前に、それが持っていたアサート状態を取り戻すことができます。サーバは、クライアントが持っていたすべての状態の完全な記録を維持していない限り、サーバーはクライアントを信頼するしか選択の余地があります。 （サーバーは、完全な記録を維持している場合もちろん、それはサーバの再起動後の状態を取り戻すために、クライアントを強制する必要はない。）サーバーが真実を伝えるために、クライアントを信頼しているが、このような信頼関係は、任意の負の影響を持っていませんセキュリティのために。リクエストを取り戻す処理するサーバーの基本的なルールは、同等の非再利用要求が原因のアクセス制御やアクセス競合の問題のために、定常状態時に付与されないならば、それは再利用を許可してはならないということです。要求を行っプリンシパルは、ファイル上の随意ACL（6.2.2項）に従ってファイルを開くためのアクセス権を持っていない場合、例えば、再利用時のOPEN要求がNFS4ERR_ACCESSで拒否されます。"
    },
    {
      "indent": 3,
      "text": "Nonetheless, it is possible that a client operating in error or maliciously could, during reclaim, prevent another client from reclaiming access to state. For example, an attacker could send an",
      "ja": "それにもかかわらず、エラーまたは悪意を持って動作するクライアントは、再利用の際に、状態へのアクセスを取り戻すから別のクライアントを防ぐ可能性があります。例えば、攻撃者が送信することができます"
    },
    {
      "indent": 3,
      "text": "OPEN reclaim operation with a deny mode that prevents another client from reclaiming the OPEN state it had before the server restarted. The attacker could perform the same denial of service during steady state prior to server restart, as long as the attacker had permissions. Given that the attack vectors are equivalent, the grace period does not offer any additional opportunity for denial of service, and any concerns about this attack vector, whether during grace or steady state, are addressed the same way: use RPCSEC_GSS for authentication and limit access to the file only to principals that the owner of the file trusts.",
      "ja": "サーバーを再起動する前に、それが持っていたOPEN状態を取り戻すから別のクライアントを防ぐ拒否モードでOPEN再生操作。攻撃者がいる限り、攻撃者が権限を持っていたとして、前にサーバの再起動に定常状態の間に同じサービス拒否を行うことができます。猶予または定常状態の時に、同じように対処しているかどうか、攻撃ベクトルが等価であることを考えると、猶予期間は、サービス拒否のための追加の機会を提供していない、とこの攻撃ベクトルについての懸念：認証と制限のアクセスのためのRPCSEC_GSSを使用しますファイルへの唯一の校長にそのファイル信託の所有者。"
    },
    {
      "indent": 3,
      "text": "Note that if prior to restart the server had client IDs with the EXCHGID4_FLAG_BIND_PRINC_STATEID (Section 18.35) capability set, then the server SHOULD record in stable storage the client owner and the principal that established the client ID via EXCHANGE_ID. If the server does not, then there is a risk a client will be unable to reclaim state if it does not have a credential for a principal that was originally authorized to establish the state.",
      "ja": "サーバを再起動する前には、EXCHGID4_FLAG_BIND_PRINC_STATEID（セクション18.35）機能を設定したクライアントIDを持っていた場合、サーバーは安定したストレージにクライアント所有者とEXCHANGE_IDを介してクライアントIDを確立元本を記録すべきであることに注意してください。サーバがない場合、それは元々の状態を確立するために承認された主体の資格を持っていない場合、クライアントは状態を再利用することができません危険性があります。"
    },
    {
      "indent": 0,
      "text": "8.4.3. Network Partitions and Recovery",
      "section_title": true,
      "ja": "8.4.3. ネットワークパーティションと回復"
    },
    {
      "indent": 3,
      "text": "If the duration of a network partition is greater than the lease period provided by the server, the server will not have received a lease renewal from the client. If this occurs, the server may free all locks held for the client or it may allow the lock state to remain for a considerable period, subject to the constraint that if a request for a conflicting lock is made, locks associated with an expired lease do not prevent such a conflicting lock from being granted but MUST be revoked as necessary so as to avoid interfering with such conflicting requests.",
      "ja": "ネットワークパーティションの期間は、サーバーが提供するリース期間よりも大きい場合、サーバはクライアントからのリースの更新を受け取っていません。この問題が発生した場合、サーバはクライアントのために開催されたすべてのロックを解放するか、それがロック状態が競合ロックの要求がなされた場合、期限切れのリースに関連したロックを行うという制約を受けるかなりの期間、のために残ることを可能にします付与されているが、このような相反する要求との干渉を避けるために、必要に応じて取り消さなければならないから、このような競合ロックを防ぐことはできません。"
    },
    {
      "indent": 3,
      "text": "If the server chooses to delay freeing of lock state until there is a conflict, it may either free all of the client's locks once there is a conflict or it may only revoke the minimum set of locks necessary to allow conflicting requests. When it adopts the finer-grained approach, it must revoke all locks associated with a given stateid, even if the conflict is with only a subset of locks.",
      "ja": "競合があるまで、サーバーがロック状態の解放を遅らせることを選択した場合、それはどちらか、クライアントのロックのすべての自由度競合がある場合もあれば、唯一の競合要求を許可するために必要なロックの最小セットを取り消すことができます。それはよりきめの細かいアプローチを採用している場合は、競合がロックのサブセットのみである場合でも、一定のstateidに関連付けられたすべてのロックを取り消す必要があります。"
    },
    {
      "indent": 3,
      "text": "When the server chooses to free all of a client's lock state, either immediately upon lease expiration or as a result of the first attempt to obtain a conflicting a lock, the server may report the loss of lock state in a number of ways.",
      "ja": "サーバはどちらかすぐにリース満了時または競合するロックを取得する最初の試みの結果として、クライアントのロック状態のすべてを解放することを選択した場合、サーバーは、いくつかの方法でロック状態の損失を報告することがあります。"
    },
    {
      "indent": 3,
      "text": "The server may choose to invalidate the session and the associated client ID. In this case, once the client can communicate with the server, it will receive an NFS4ERR_BADSESSION error. Upon attempting to create a new session, it would get an NFS4ERR_STALE_CLIENTID. Upon creating the new client ID and new session, the client will attempt to reclaim locks. Normally, the server will not allow the client to reclaim locks, because the server will not be in its recovery grace period.",
      "ja": "サーバーは、セッションと関連付けられているクライアントIDを無効にすることもできます。この場合、サーバーと通信できるクライアントたら、それはNFS4ERR_BADSESSIONエラーが発生します。新しいセッションを作成しようとしたら、それはNFS4ERR_STALE_CLIENTIDになるだろう。新しいクライアントIDと新しいセッションを作成すると、クライアントはロックを再要求しようとします。サーバーは、その回復の猶予期間になりませんので、通常、サーバは、クライアントがロックを再利用することはできません。"
    },
    {
      "indent": 3,
      "text": "Another possibility is for the server to maintain the session and client ID but for all stateids held by the client to become invalid or stale. Once the client can reach the server after such a network partition, the status returned by the SEQUENCE operation will indicate a loss of locking state; i.e., the flag SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED will be set in sr_status_flags. In addition, all I/O submitted by the client with the now invalid stateids will fail with the server returning the error NFS4ERR_EXPIRED. Once the client learns of the loss of locking state, it will suitably notify the applications that held the invalidated locks. The client should then take action to free invalidated stateids, either by establishing a new client ID using a new verifier or by doing a FREE_STATEID operation to release each of the invalidated stateids.",
      "ja": "サーバーがセッションとクライアントのIDを維持するのではなく、クライアントが保持しているすべてのstateidsのために無効または陳腐化するための別の可能性があります。クライアントは、ネットワーク・パーティションの後にサーバーに到達することができたら、シーケンス動作によって返されるステータスは、状態をロックの損失を示します。即ち、フラグSEQ4_STATUS_EXPIRED_ALL_STATE_REVOKEDはsr_status_flagsに設定されます。また、すべてのI / OエラーNFS4ERR_EXPIREDを返すサーバーで失敗します今無効のstateidsでクライアントから提出されました。クライアントがロック状態の喪失を知った後は、それが適切に無効化されたロックを開催するアプリケーションを通知します。クライアントは、新しいベリファイアを使用して新しいクライアントIDを確立することによって、または無効化のstateidsのそれぞれを解放するためにFREE_STATEID操作を行うことのいずれかによって、無効化のstateidsを解放するために行動を取る必要があります。"
    },
    {
      "indent": 3,
      "text": "When the server adopts a finer-grained approach to revocation of locks when a client's lease has expired, only a subset of stateids will normally become invalid during a network partition. When the client can communicate with the server after such a network partition heals, the status returned by the SEQUENCE operation will indicate a partial loss of locking state (SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED). In addition, operations, including I/O submitted by the client, with the now invalid stateids will fail with the server returning the error NFS4ERR_EXPIRED. Once the client learns of the loss of locking state, it will use the TEST_STATEID operation on all of its stateids to determine which locks have been lost and then suitably notify the applications that held the invalidated locks. The client can then release the invalidated locking state and acknowledge the revocation of the associated locks by doing a FREE_STATEID operation on each of the invalidated stateids.",
      "ja": "サーバーがクライアントのリースが期限切れになったロックの失効にきめ細かいアプローチを採用した場合、のstateidsのサブセットのみが、通常はネットワークパーティション時に無効となります。クライアントは、ネットワークパーティションが治癒後にサーバと通信できる場合、シーケンス動作によって返されるステータスは、ロック状態（SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED）の部分的な損失を示すであろう。また、クライアントから提出されたI / Oなどの操作は、現在無効のstateidsはエラーNFS4ERR_EXPIREDを返すサーバーで失敗しますと。クライアントがロック状態の喪失を知った後は、ロックが失われたかを判断するためにそののstateidsのすべてのTEST_STATEID操作を使用して、適切に無効化されたロックを開催するアプリケーションを通知します。次に、クライアントは無効にロック状態を解除し、無効のstateidsのそれぞれにFREE_STATEID操作を行うことによって、関連するロックの失効を確認することができます。"
    },
    {
      "indent": 3,
      "text": "When a network partition is combined with a server restart, there are edge conditions that place requirements on the server in order to avoid silent data corruption following the server restart. Two of these edge conditions are known, and are discussed below.",
      "ja": "ネットワークパーティションがサーバの再起動と組み合わせると、サーバーの再起動、次のサイレントデータ破損を避けるために、場所、サーバー上の要件をエッジ条件があります。これらのエッジ条件の二つが知られており、以下に説明します。"
    },
    {
      "indent": 3,
      "text": "The first edge condition arises as a result of the scenarios such as the following:",
      "ja": "最初のエッジ条件は、次のようなシナリオの結果として生じます。"
    },
    {
      "indent": 3,
      "text": "1. Client A acquires a lock.",
      "section_title": true,
      "ja": "1.クライアントAは、ロックを取得します。"
    },
    {
      "indent": 3,
      "text": "2. Client A and server experience mutual network partition, such that client A is unable to renew its lease.",
      "ja": "2.クライアントAとサーバの経験の相互ネットワークパーティション、クライアントAは、そのリースを更新することができないようになっています。"
    },
    {
      "indent": 3,
      "text": "3. Client A's lease expires, and the server releases the lock.",
      "section_title": true,
      "ja": "3.クライアントAのリースが期限切れになると、サーバーは、ロックを解除します。"
    },
    {
      "indent": 3,
      "text": "4. Client B acquires a lock that would have conflicted with that of client A.",
      "ja": "4.クライアントBは、クライアントAのそれと衝突していたロックを取得します"
    },
    {
      "indent": 3,
      "text": "5. Client B releases its lock.",
      "section_title": true,
      "ja": "5.クライアントBは、そのロックを解除します。"
    },
    {
      "indent": 3,
      "text": "6. Server restarts.",
      "section_title": true,
      "ja": "6.サーバーが再起動します。"
    },
    {
      "indent": 3,
      "text": "7. Network partition between client A and server heals.",
      "section_title": true,
      "ja": "クライアントAとサーバ間の治癒7.ネットワークパーティション。"
    },
    {
      "indent": 3,
      "text": "8. Client A connects to a new server instance and finds out about server restart.",
      "ja": "8.クライアントAは、新しいサーバーインスタンスに接続し、サーバの再起動について見つけ出します。"
    },
    {
      "indent": 3,
      "text": "9. Client A reclaims its lock within the server's grace period.",
      "section_title": true,
      "ja": "9.クライアントAは、サーバーの猶予期間内にそのロックを再利用します。"
    },
    {
      "indent": 3,
      "text": "Thus, at the final step, the server has erroneously granted client A's lock reclaim. If client B modified the object the lock was protecting, client A will experience object corruption.",
      "ja": "このように、最後のステップでは、サーバが誤ってクライアントAのロック再利用を許可されています。クライアントBは、ロックが保護されたオブジェクトを変更した場合、クライアントAは、オブジェクトの破損が発生します。"
    },
    {
      "indent": 3,
      "text": "The second known edge condition arises in situations such as the following:",
      "ja": "第2の既知のエッジ条件は、次のような状況で発生します。"
    },
    {
      "indent": 3,
      "text": "1. Client A acquires one or more locks.",
      "section_title": true,
      "ja": "1.クライアントAは、一つ以上のロックを取得します。"
    },
    {
      "indent": 3,
      "text": "2. Server restarts.",
      "section_title": true,
      "ja": "2.サーバーが再起動します。"
    },
    {
      "indent": 3,
      "text": "3. Client A and server experience mutual network partition, such that client A is unable to reclaim all of its locks within the grace period.",
      "ja": "3.クライアントAとサーバの経験の相互ネットワークパーティション、クライアントAは、猶予期間内にそのロックのすべてを再利用することができないようになっています。"
    },
    {
      "indent": 3,
      "text": "4. Server's reclaim grace period ends. Client A has either no locks or an incomplete set of locks known to the server.",
      "ja": "4.サーバーの再利用の猶予期間が終了します。クライアントAにはロックまたはサーバに知られているロックの不完全なセットのいずれかを有していません。"
    },
    {
      "indent": 3,
      "text": "5. Client B acquires a lock that would have conflicted with a lock of client A that was not reclaimed.",
      "ja": "5.クライアントBは再利用されなかったクライアントAのロックと競合しているだろうロックを取得します。"
    },
    {
      "indent": 3,
      "text": "6. Client B releases the lock.",
      "section_title": true,
      "ja": "6.クライアントBは、ロックを解除します。"
    },
    {
      "indent": 3,
      "text": "7. Server restarts a second time.",
      "section_title": true,
      "ja": "7.サーバーを2回再起動します。"
    },
    {
      "indent": 3,
      "text": "8. Network partition between client A and server heals.",
      "section_title": true,
      "ja": "クライアントAとサーバ間の治癒8.ネットワークパーティション。"
    },
    {
      "indent": 3,
      "text": "9. Client A connects to new server instance and finds out about server restart.",
      "ja": "9.クライアントAは、新しいサーバーインスタンスに接続し、サーバの再起動について見つけ出します。"
    },
    {
      "indent": 3,
      "text": "10. Client A reclaims its lock within the server's grace period.",
      "section_title": true,
      "ja": "10.クライアントAは、サーバーの猶予期間内にそのロックを再利用します。"
    },
    {
      "indent": 3,
      "text": "As with the first edge condition, the final step of the scenario of the second edge condition has the server erroneously granting client A's lock reclaim.",
      "ja": "最初のエッジ条件と同様に、第2のエッジ条件のシナリオの最終ステップは、誤ってクライアントAのロックの再利用を許可するサーバを有しています。"
    },
    {
      "indent": 3,
      "text": "Solving the first and second edge conditions requires either that the server always assumes after it restarts that some edge condition occurs, and thus returns NFS4ERR_NO_GRACE for all reclaim attempts, or that the server record some information in stable storage. The amount of information the server records in stable storage is in inverse proportion to how harsh the server intends to be whenever edge conditions arise. The server that is completely tolerant of all edge conditions will record in stable storage every lock that is acquired, removing the lock record from stable storage only when the lock is released. For the two edge conditions discussed above, the harshest a server can be, and still support a grace period for reclaims, requires that the server record in stable storage some minimal information. For example, a server implementation could, for each client, save in stable storage a record containing:",
      "ja": "第一と第二のエッジ条件を解決することは、いくつかのエッジ状態が発生することを再開し、従って試み、またはサーバが安定したストレージにいくつかの情報を記録することを取り戻すすべてについてNFS4ERR_NO_GRACEを返した後に、サーバが常に想定していることのいずれかが必要です。安定したストレージの情報量サーバーレコードは、サーバーは、エッジ状態が発生するたびになろうとするどのように厳しいに反比例します。すべてのエッジ条件の完全耐性のあるサーバが安定したストレージにロックが解除されるだけ安定したストレージからロック・レコードを削除し、取得されたすべてのロックを記録します。上記説明した2つのエッジ条件のため、過酷なサーバがあること、さらに再要求するための猶予期間をサポートすることができ、いくつかの最小限の情報安定したストレージにそのサーバレコードを必要とします。例えば、サーバの実装は、各クライアントのために、安定したストレージに含むレコードを保存できます。"
    },
    {
      "indent": 3,
      "text": "o the co_ownerid field from the client_owner4 presented in the EXCHANGE_ID operation.",
      "ja": "EXCHANGE_ID操作で提示client_owner4からco_owneridフィールドO。"
    },
    {
      "indent": 3,
      "text": "o a boolean that indicates if the client's lease expired or if there was administrative intervention (see Section 8.5) to revoke a byte-range lock, share reservation, or delegation and there has been no acknowledgment, via FREE_STATEID, of such revocation.",
      "ja": "Oクライアントのリース期限が切れたり、管理者の介入があった場合（セクション8.5を参照）かどうかを示すブール値はバイト範囲ロック、共有予約、または委任を撤回することや、失効、FREE_STATEIDを経由して、確認応答がなかったです。"
    },
    {
      "indent": 3,
      "text": "o a boolean that indicates whether the client may have locks that it believes to be reclaimable in situations in which the grace period was terminated, making the server's view of lock reclaimability suspect. The server will set this for any client record in stable storage where the client has not done a suitable RECLAIM_COMPLETE (global or file system-specific depending on the target of the lock request) before it grants any new (i.e., not reclaimed) lock to any client.",
      "ja": "クライアントが猶予期間がロックreclaimability容疑者のサーバのビューを作る、終了された状況で再利用可能であると信じるロックを有することができるかどうかを示すboolean O。サーバは、それがどんな新しい（すなわち、再利用しない）ロックを許可する前に、クライアントは、適切なRECLAIM_COMPLETEをしていない安定したストレージ内の任意のクライアントレコード（グローバルまたはファイルシステム固有のロック要求のターゲットに依存する）のためにこれを設定します任意のクライアント。"
    },
    {
      "indent": 3,
      "text": "Assuming the above record keeping, for the first edge condition, after the server restarts, the record that client A's lease expired means that another client could have acquired a conflicting byte-range lock, share reservation, or delegation. Hence, the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE.",
      "ja": "サーバーの再起動後、最初のエッジ条件のために、上記の記録保持を仮定すると、クライアントAのリースが期限切れという記録は、別のクライアントが競合バイト範囲ロック、共有予約、または委任を取得していることを意味します。したがって、サーバーはエラーNFS4ERR_NO_GRACEとクライアントAからの再利用を拒否しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For the second edge condition, after the server restarts for a second time, the indication that the client had not completed its reclaims at the time at which the grace period ended means that the server must reject a reclaim from client A with the error NFS4ERR_NO_GRACE.",
      "ja": "第2のエッジ状態の場合、二度目のサーバーの再起動後、猶予期間が終了したクライアントは、現時点ではその再要求を完了していなかったことを示す指標は、サーバがエラーNFS4ERR_NO_GRACEとクライアントAからの再利用を拒否しなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "When either edge condition occurs, the client's attempt to reclaim locks will result in the error NFS4ERR_NO_GRACE. When this is received, or after the client restarts with no lock state, the client will send a global RECLAIM_COMPLETE. When the RECLAIM_COMPLETE is received, the server and client are again in agreement regarding reclaimable locks and both booleans in persistent storage can be reset, to be set again only when there is a subsequent event that causes lock reclaim operations to be questionable.",
      "ja": "どちらかのエッジ状態が発生した場合、ロックを再利用するクライアントの試みは、エラーNFS4ERR_NO_GRACEになります。これを受信した場合、クライアントはロックなしの状態で再起動した後、または、クライアントがグローバルRECLAIM_COMPLETEを送信します。 RECLAIM_COMPLETEが受信されると、サーバとクライアントは、再生可能なロックと永続ストレージの両方のブールロック再利用操作が疑わしいことになり、その後のイベントがある場合にのみ再設定しなければ、リセットすることができますについて合意に再びです。"
    },
    {
      "indent": 3,
      "text": "Regardless of the level and approach to record keeping, the server MUST implement one of the following strategies (which apply to reclaims of share reservations, byte-range locks, and delegations):",
      "ja": "かかわらず、記録保持のレベルやアプローチの、サーバは、（株予約、バイト範囲ロック、および代表団の再利用に適用されます）次のいずれかを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Reject all reclaims with NFS4ERR_NO_GRACE. This is extremely unforgiving, but necessary if the server does not record lock state in stable storage.",
      "ja": "1. NFS4ERR_NO_GRACEですべてを再要求を拒否します。サーバが安定したストレージにロック状態を記録していない場合、これは非常に厳しいが、必要です。"
    },
    {
      "indent": 3,
      "text": "2. Record sufficient state in stable storage such that all known edge conditions involving server restart, including the two noted in this section, are detected. It is acceptable to erroneously recognize an edge condition and not allow a reclaim, when, with sufficient knowledge, it would be allowed. The error the server would return in this case is NFS4ERR_NO_GRACE. Note that it is not known if there are other edge conditions.",
      "ja": "このセクションで述べた2を含むサーバの再起動を伴うすべての既知のエッジ条件が検出されるような安定したストレージに前記記録十分な状態。十分な知識と、それが許される場合には、誤ってエッジ状態を認識し、再利用を許可しないために許容可能です。サーバはこの場合には戻ってくるエラーはNFS4ERR_NO_GRACEです。他のエッジ条件がある場合は、それが知られていないことに注意してください。"
    },
    {
      "indent": 7,
      "text": "In the event that, after a server restart, the server determines\nthere is unrecoverable damage or corruption to the information in\nstable storage, then for all clients and/or locks that may be\naffected, the server MUST return NFS4ERR_NO_GRACE.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A mandate for the client's handling of the NFS4ERR_NO_GRACE error is outside the scope of this specification, since the strategies for such handling are very dependent on the client's operating environment. However, one potential approach is described below.",
      "ja": "そのような取扱いのための戦略は、クライアントの動作環境に非常に依存しているため、NFS4ERR_NO_GRACEエラーのクライアントの処理のための任務は、この仕様の範囲外です。しかしながら、潜在的なアプローチは、以下に説明します。"
    },
    {
      "indent": 3,
      "text": "When the client receives NFS4ERR_NO_GRACE, it could examine the change attribute of the objects for which the client is trying to reclaim state, and use that to determine whether to re-establish the state via normal OPEN or LOCK operations. This is acceptable provided that the client's operating environment allows it. In other words, the client implementor is advised to document for his users the behavior. The client could also inform the application that its byte-range lock or share reservations (whether or not they were delegated) have been lost, such as via a UNIX signal, a Graphical User Interface (GUI) pop-up window, etc. See Section 10.5 for a discussion of what the client should do for dealing with unreclaimed delegations on client state.",
      "ja": "クライアントがNFS4ERR_NO_GRACEを受信すると、クライアントは状態を再利用しようとしているオブジェクトの変化属性を調べ、通常のOPENまたはLOCK操作によって状態を再確立するかどうかを決定するためにそれを使用することができます。これは、クライアントの動作環境がそれを可能にすることを提供可能です。つまり、クライアントの実装者は、彼のユーザーのための行動を文書化することをお勧めします。また、クライアントは、そのバイト範囲ロックまたは共有の予約は（それらが委任されたかどうか）などのUNIX信号など、グラフィカル・ユーザー・インターフェース（GUI）ポップアップウィンドウ、参照を介したとして、失われたアプリケーションを通知することができクライアントは、クライアントの状態にunreclaimed代表団に対処するために何をすべきかの議論については、セクション10.5。"
    },
    {
      "indent": 3,
      "text": "For further discussion of revocation of locks, see Section 8.5.",
      "ja": "ロックの取消しのさらなる議論については、セクション8.5を参照してください。"
    },
    {
      "indent": 0,
      "text": "8.5. Server Revocation of Locks",
      "section_title": true,
      "ja": "8.5. ロックのサーバーの失効"
    },
    {
      "indent": 3,
      "text": "At any point, the server can revoke locks held by a client, and the client must be prepared for this event. When the client detects that its locks have been or may have been revoked, the client is responsible for validating the state information between itself and the server. Validating locking state for the client means that it must verify or reclaim state for each lock currently held.",
      "ja": "任意の時点で、サーバは、クライアントが保持しているロックを取り消すことができ、クライアントは、このイベントのために準備しなければなりません。クライアントは、そのロックがされているか、取り消されたことを検出すると、クライアントは、それ自体とサーバの間で状態情報を検証する責任があります。クライアントのロック状態を検証することは、現在開催され、各ロックの状態を確認したり、再利用しなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "The first occasion of lock revocation is upon server restart. Note that this includes situations in which sessions are persistent and locking state is lost. In this class of instances, the client will receive an error (NFS4ERR_STALE_CLIENTID) on an operation that takes client ID, usually as part of recovery in response to a problem with the current session), and the client will proceed with normal crash recovery as described in the Section 8.4.2.1.",
      "ja": "ロック取消しの最初の機会は、サーバーの再起動時です。これはセッションが永続的である状況が含まれており、ロック状態が失われることに注意してください。インスタンスのこのクラスでは、クライアントは通常、現在のセッションでの問題に応じて、回復の一環として、クライアントのIDを取る操作）でエラー（NFS4ERR_STALE_CLIENTID）を受け取ります、と説明するように、クライアントは通常のクラッシュリカバリを続行しますセクション8.4.2.1インチ"
    },
    {
      "indent": 3,
      "text": "The second occasion of lock revocation is the inability to renew the lease before expiration, as discussed in Section 8.4.3. While this is considered a rare or unusual event, the client must be prepared to recover. The server is responsible for determining the precise consequences of the lease expiration, informing the client of the scope of the lock revocation decided upon. The client then uses the status information provided by the server in the SEQUENCE results (field sr_status_flags, see Section 18.46.3) to synchronize its locking state with that of the server, in order to recover.",
      "ja": "8.4.3項で述べたように、ロック失効の第二の機会は、満了前にリースを更新することができないことです。これは稀なまたは異常なイベントと見なされますが、クライアントが回復する準備をしなければなりません。サーバは、リース満了の正確な結果を決定すると決めたロック取消しの範囲のクライアントに通知する責任があります。次に、クライアントは回復するために、サーバのそれとのロック状態を同期させるために（フィールドsr_status_flags、セクション18.46.3を参照）SEQUENCE結果にサーバによって提供されるステータス情報を使用します。"
    },
    {
      "indent": 3,
      "text": "The third occasion of lock revocation can occur as a result of revocation of locks within the lease period, either because of administrative intervention or because a recallable lock (a delegation or layout) was not returned within the lease period after having been recalled. While these are considered rare events, they are possible, and the client must be prepared to deal with them. When either of these events occurs, the client finds out about the situation through the status returned by the SEQUENCE operation. Any use of stateids associated with locks revoked during the lease period will receive the error NFS4ERR_ADMIN_REVOKED or NFS4ERR_DELEG_REVOKED, as appropriate.",
      "ja": "ロック失効の第三の時は、リース期間内に、いずれかのために管理者の介入またはリコールロック（委任又はレイアウト）がリコールされた後、リース期間内に戻されていなかったため、ロックの取消しの結果として起こり得ます。これらは稀な事象と考えられているが、それらは可能であり、クライアントはそれらに対処するために準備する必要があります。これらのイベントのいずれかが発生した場合、クライアントはSEQUENCEの操作によって返されるステータスによって状況について見つけ出します。リース期間中に失効ロックに関連付けられているのstateidsの使用は、必要に応じて、エラーNFS4ERR_ADMIN_REVOKED又はNFS4ERR_DELEG_REVOKEDを受けます。"
    },
    {
      "indent": 3,
      "text": "In all situations in which a subset of locking state may have been revoked, which include all cases in which locking state is revoked within the lease period, it is up to the client to determine which locks have been revoked and which have not. It does this by using the TEST_STATEID operation on the appropriate set of stateids. Once the set of revoked locks has been determined, the applications can be notified, and the invalidated stateids can be freed and lock revocation acknowledged by using FREE_STATEID.",
      "ja": "ロック状態は、リース期間内に失効しているすべてのケースを含むロック状態のサブセットが取り消された可能性のあるすべての状況において、それは、クライアントまでロックが取り消されなく有するされているかを決定することです。それはのstateidsの適切なセットにTEST_STATEID操作を使用してこれを行います。取り消されたロックのセットが決定されると、アプリケーションは、通知することができ、および無効化のstateidsは解放されたとFREE_STATEIDを使用して認め失効をロックすることができます。"
    },
    {
      "indent": 0,
      "text": "8.6. Short and Long Leases",
      "section_title": true,
      "ja": "8.6. ショートとロングリース"
    },
    {
      "indent": 3,
      "text": "When determining the time period for the server lease, the usual lease tradeoffs apply. A short lease is good for fast server recovery at a cost of increased operations to effect lease renewal (when there are no other operations during the period to effect lease renewal as a side effect). A long lease is certainly kinder and gentler to servers trying to handle very large numbers of clients. The number of extra requests to effect lock renewal drops in inverse proportion to the lease time. The disadvantages of a long lease include the possibility of slower recovery after certain failures. After server failure, a longer grace period may be required when some clients do not promptly reclaim their locks and do a global RECLAIM_COMPLETE. In the event of client failure, the longer period for a lease to expire will force conflicting requests to wait longer.",
      "ja": "サーバーのリース期間を決定する際に、通常の賃貸借トレードオフが適用されます。短期リースは、リースの更新を（副作用として、リースの更新を達成する期間中は他の操作がない場合）行うように増加した業務のコストで高速なサーバー回復のために良いです。長いリースは、クライアントの非常に大きな数字を扱うしようとしているサーバへの確かに親切かつ緩やかで。ロックリニューアルをもたらすために、余分な要求の数は、リース時間に反比例して低下します。長いリースの欠点は、特定の障害後に遅い回復の可能性があります。一部のクライアントが速やかにロックを再要求し、グローバルRECLAIM_COMPLETEをしない場合に、サーバーに障害が発生した後、長い猶予期間が必要になることがあります。クライアントに障害が発生した場合、有効期限が切れるようにリースのための長い期間が長く待つように相反する要求を強制します。"
    },
    {
      "indent": 3,
      "text": "A long lease is practical if the server can store lease state in stable storage. Upon recovery, the server can reconstruct the lease state from its stable storage and continue operation with its clients.",
      "ja": "サーバが安定したストレージにリース状態を保存することができれば、長いリースは実用的です。回復時に、サーバーは、その安定したストレージからリース状態を再構築することができ、そのクライアントとの動作を継続します。"
    },
    {
      "indent": 0,
      "text": "8.7. Clocks, Propagation Delay, and Calculating Lease Expiration",
      "section_title": true,
      "ja": "8.7. 時計、伝播遅延、および計算リースの有効期限"
    },
    {
      "indent": 3,
      "text": "To avoid the need for synchronized clocks, lease times are granted by the server as a time delta. However, there is a requirement that the client and server clocks do not drift excessively over the duration of the lease. There is also the issue of propagation delay across the network, which could easily be several hundred milliseconds, as well as the possibility that requests will be lost and need to be retransmitted.",
      "ja": "同期クロックの必要性を回避するには、リース時間は時間デルタとしてサーバによって付与されます。ただし、クライアントとサーバーのクロックは、リース期間にわたって過度にドリフトしていない要件があります。簡単に数百ミリ秒、などの要求が失われ、再送信する必要があります可能性があることができ、ネットワーク、全体の伝播遅延の問題もあります。"
    },
    {
      "indent": 3,
      "text": "To take propagation delay into account, the client should subtract it from lease times (e.g., if the client estimates the one-way propagation delay as 200 milliseconds, then it can assume that the lease is already 200 milliseconds old when it gets it). In addition, it will take another 200 milliseconds to get a response back to the server. So the client must send a lease renewal or write data back to the server at least 400 milliseconds before the lease would expire. If the propagation delay varies over the life of the lease (e.g., the client is on a mobile host), the client will need to continuously subtract the increase in propagation delay from the lease times.",
      "ja": "アカウントに伝播遅延を取るために、クライアントはリース時間からそれを引く必要があります（それはそれを取得する場合、クライアントは200ミリ秒として一方向の伝搬遅延を推定した場合、例えば、それはリースがすでに200ミリ秒古いであると仮定することができます）。また、それは戻って、サーバへの応答を取得するには、別の200ミリ秒かかります。リースが期限切れになるでしょう前に少なくとも400ミリ秒のように、クライアントは、リースの更新を送信する必要がありますか、サーバーに戻ってデータを書き込みます。伝搬遅延は、リース期間にわたって変化する場合（例えば、クライアントがモバイルホスト上にある）、クライアントは継続的にリース時間から伝搬遅延の増加を引く必要があります。"
    },
    {
      "indent": 3,
      "text": "The server's lease period configuration should take into account the network distance of the clients that will be accessing the server's resources. It is expected that the lease period will take into account the network propagation delays and other network delay factors for the client population. Since the protocol does not allow for an automatic method to determine an appropriate lease period, the server's administrator may have to tune the lease period.",
      "ja": "サーバのリース期間の設定は、アカウントに、サーバーのリソースにアクセスするクライアントのネットワーク距離を取る必要があります。リース期間は、アカウントにクライアント人口のネットワーク伝播遅延およびその他のネットワーク遅延の要因を取ることが期待されます。プロトコルは、適切なリース期間を決定するための自動方法を許可しないので、サーバーの管理者が同調するように、リース期間を有することができます。"
    },
    {
      "indent": 0,
      "text": "8.8. Obsolete Locking Infrastructure from NFSv4.0",
      "section_title": true,
      "ja": "8.8.  NFSv4.0から廃止されたロック・インフラ"
    },
    {
      "indent": 3,
      "text": "There are a number of operations and fields within existing operations that no longer have a function in NFSv4.1. In one way or another, these changes are all due to the implementation of sessions that provide client context and exactly once semantics as a base feature of the protocol, separate from locking itself.",
      "ja": "もはやNFSv4.1で機能を持っていない既存事業内の操作とフィールドの数があります。何らかの形で、これらの変化は、すべてのクライアントコンテキストを提供し、正確に自分自身をロックから別のプロトコルのベース機能としてセマンティクス一度セッションの実装によるものです。"
    },
    {
      "indent": 3,
      "text": "The following NFSv4.0 operations MUST NOT be implemented in NFSv4.1. The server MUST return NFS4ERR_NOTSUPP if these operations are found in an NFSv4.1 COMPOUND.",
      "ja": "次NFSv4.0操作はNFSv4.1で実装されてはなりません。これらの操作はNFSv4.1化合物で発見された場合、サーバーはNFS4ERR_NOTSUPPを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o SETCLIENTID since its function has been replaced by EXCHANGE_ID.",
      "ja": "Oその機能以来SETCLIENTIDはEXCHANGE_IDに置き換えられました。"
    },
    {
      "indent": 3,
      "text": "o SETCLIENTID_CONFIRM since client ID confirmation now happens by means of CREATE_SESSION.",
      "ja": "OクライアントIDの確認以来SETCLIENTID_CONFIRMは今CREATE_SESSIONによって起こります。"
    },
    {
      "indent": 3,
      "text": "o OPEN_CONFIRM because state-owner-based seqids have been replaced by the sequence ID in the SEQUENCE operation.",
      "ja": "オープン_CONFIRM Oので、状態所有者ベースseqidsシーケンス操作のシーケンスIDによって置き換えられています。"
    },
    {
      "indent": 3,
      "text": "o RELEASE_LOCKOWNER because lock-owners with no associated locks do not have any sequence-related state and so can be deleted by the server at will.",
      "ja": "なし関連するロックとロック所有者は、任意のシーケンス関連の状態を持っていないので、自由にサーバーによって削除することができますO RELEASE_LOCKOWNERので。"
    },
    {
      "indent": 3,
      "text": "o RENEW because every SEQUENCE operation for a session causes lease renewal, making a separate operation superfluous.",
      "ja": "セッションごとSEQUENCEの操作は別の操作は不要作り、リースの更新が発生するため、O RENEW。"
    },
    {
      "indent": 3,
      "text": "Also, there are a number of fields, present in existing operations, related to locking that have no use in minor version 1. They were used in minor version 0 to perform functions now provided in a different fashion.",
      "ja": "また、既存の動作中に存在するフィールドの数、彼らは今、異なる様式で提供される機能を実行するためにマイナーバージョン0で使用したマイナーバージョン1には使用を持たないロックに関連があります。"
    },
    {
      "indent": 3,
      "text": "o Sequence ids used to sequence requests for a given state-owner and to provide retry protection, now provided via sessions.",
      "ja": "OシーケンスIDが与えられた状態、所有者のためのシーケンス要求に使用され、現在のセッションを介して提供さリトライ保護を提供します。"
    },
    {
      "indent": 3,
      "text": "o Client IDs used to identify the client associated with a given request. Client identification is now available using the client ID associated with the current session, without needing an explicit client ID field.",
      "ja": "oクライアントIDが与えられた要求に関連付けられたクライアントを識別するために使用されます。クライアントの識別は、明示的なクライアントIDフィールドを必要とせずに、現在のセッションに関連付けられたクライアントIDを使用して利用できるようになりました。"
    },
    {
      "indent": 3,
      "text": "Such vestigial fields in existing operations have no function in NFSv4.1 and are ignored by the server. Note that client IDs in operations new to NFSv4.1 (such as CREATE_SESSION and DESTROY_CLIENTID) are not ignored.",
      "ja": "既存事業でのこのような痕跡フィールドはNFSv4.1で何の機能も持っていないと、サーバによって無視されます。 （このようCREATE_SESSIONとDESTROY_CLIENTIDなど）NFSv4.1への新規事業で、そのクライアントIDが無視されていません注意してください。"
    },
    {
      "indent": 0,
      "text": "9. File Locking and Share Reservations",
      "section_title": true,
      "ja": "9.ファイルロックと共有予約"
    },
    {
      "indent": 3,
      "text": "To support Win32 share reservations, it is necessary to provide operations that atomically open or create files. Having a separate share/unshare operation would not allow correct implementation of the Win32 OpenFile API. In order to correctly implement share semantics, the previous NFS protocol mechanisms used when a file is opened or created (LOOKUP, CREATE, ACCESS) need to be replaced. The NFSv4.1 protocol defines an OPEN operation that is capable of atomically looking up, creating, and locking a file on the server.",
      "ja": "Win32のシェアの予約をサポートするために、アトミックオープンオペレーションを提供したり、ファイルを作成する必要があります。別のシェア/共有解除操作を持つことのWin32のOpenFileのAPIの正しい実装を許可しないでしょう。正しく共有セマンティクスを実現するために、ファイルを開くまたは作成されたときに使用される従来のNFSプロトコルメカニズム（LOOKUPは、CREATE、ACCESS）に交換する必要があります。 NFSv4.1プロトコルはアトミックに、ルックアップ作成、およびサーバ上のファイルをロックすることが可能であるOPEN操作を定義します。"
    },
    {
      "indent": 0,
      "text": "9.1. Opens and Byte-Range Locks",
      "section_title": true,
      "ja": "9.1. オープンして、バイト範囲ロック"
    },
    {
      "indent": 3,
      "text": "It is assumed that manipulating a byte-range lock is rare when compared to READ and WRITE operations. It is also assumed that server restarts and network partitions are relatively rare. Therefore, it is important that the READ and WRITE operations have a lightweight mechanism to indicate if they possess a held lock. A LOCK operation contains the heavyweight information required to establish a byte-range lock and uniquely define the owner of the lock.",
      "ja": "読み出し動作と書き込み動作と比較した場合、バイト範囲ロックを操作することはまれであると仮定されます。また、サーバーが再起動し、ネットワークパーティションは比較的まれであると仮定する。したがって、READとWRITE操作は、彼らが保持されたロックを所有どうかを示すための軽量なメカニズムを持っていることが重要です。 LOCK操作は、バイト範囲ロックを確立し、一意のロックの所有者を定義するために必要なヘビーな情報を含んでいます。"
    },
    {
      "indent": 0,
      "text": "9.1.1. State-Owner Definition",
      "section_title": true,
      "ja": "9.1.1. 状態 - 所有者の定義"
    },
    {
      "indent": 3,
      "text": "When opening a file or requesting a byte-range lock, the client must specify an identifier that represents the owner of the requested lock. This identifier is in the form of a state-owner, represented in the protocol by a state_owner4, a variable-length opaque array that, when concatenated with the current client ID, uniquely defines the owner of a lock managed by the client. This may be a thread ID, process ID, or other unique value.",
      "ja": "ファイルを開いたり、バイト範囲ロックを要求する場合、クライアントは要求されたロックの所有者を表す識別子を指定する必要があります。この識別子はstate_owner4によってプロトコルで表される状態、所有者、の形態であり、現在のクライアントIDと連結、可変長の不透明な配列は、一意のクライアントが管理するロックの所有者を定義します。これは、スレッドID、プロセスID、または他のユニークな値であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Owners of opens and owners of byte-range locks are separate entities and remain separate even if the same opaque arrays are used to designate owners of each. The protocol distinguishes between open-owners (represented by open_owner4 structures) and lock-owners (represented by lock_owner4 structures).",
      "ja": "オープンおよびバイト範囲ロックの所有者の所有者が同じ不透明アレイはそれぞれの所有者を指定するために使用されていても、別個のエンティティであり、別個のままです。プロトコルは、オープン所有者（open_owner4構造によって表される）と（lock_owner4構造によって表される）ロック所有者を区別する。"
    },
    {
      "indent": 3,
      "text": "Each open is associated with a specific open-owner while each byte-range lock is associated with a lock-owner and an open-owner, the latter being the open-owner associated with the open file under which the LOCK operation was done. Delegations and layouts, on the other hand, are not associated with a specific owner but are associated with the client as a whole (identified by a client ID).",
      "ja": "各バイト範囲ロックがロック所有者とオープン所有者は、ロック操作が行われたときのオープンファイルに関連付けられている後者はオープン所有者に関連付けられている間に、各オープンは、特定のオープン所有者に関連付けられています。委任とレイアウトは、一方で、特定の所有者に関連付けられていないが、（クライアントIDによって識別される）全体としてクライアントに関連付けられています。"
    },
    {
      "indent": 0,
      "text": "9.1.2. Use of the Stateid and Locking",
      "section_title": true,
      "ja": "9.1.2.  STATEIDとロックの使用"
    },
    {
      "indent": 3,
      "text": "All READ, WRITE, and SETATTR operations contain a stateid. For the purposes of this section, SETATTR operations that change the size attribute of a file are treated as if they are writing the area between the old and new sizes (i.e., the byte-range truncated or added to the file by means of the SETATTR), even where SETATTR is not explicitly mentioned in the text. The stateid passed to one of these operations must be one that represents an open, a set of byte-range locks, or a delegation, or it may be a special stateid representing anonymous access or the special bypass stateid.",
      "ja": "すべてのREAD、WRITE、およびSETATTR操作はのstateidを含んでいます。彼らは切り捨てられるかSETATTRによってファイルに追加新旧のサイズ（すなわち、バイト範囲の間の領域を書いているかのように、このセクションの目的のために、ファイルのサイズ属性を変更するSETATTR操作が処理されます）、SETATTRが明示的にテキストで言及されていない場合でも。これらの操作のいずれかに渡されたstateidはオープンを表し1、バイト範囲ロックのセット、または委任でなければならない、またはそれが匿名アクセスや特殊バイパスのstateidを表す特別なstateidかもしれません。"
    },
    {
      "indent": 3,
      "text": "If the state-owner performs a READ or WRITE operation in a situation in which it has established a byte-range lock or share reservation on the server (any OPEN constitutes a share reservation), the stateid (previously returned by the server) must be used to indicate what locks, including both byte-range locks and share reservations, are held by the state-owner. If no state is established by the client, either a byte-range lock or a share reservation, a special stateid for anonymous state (zero as the value for \"other\" and \"seqid\") is used. (See Section 8.2.3 for a description of 'special' stateids in general.) Regardless of whether a stateid for anonymous state or a stateid returned by the server is used, if there is a conflicting share reservation or mandatory byte-range lock held on the file, the server MUST refuse to service the READ or WRITE operation.",
      "ja": "状態所有者は、それがサーバー上のバイト範囲ロックまたは共有の予約を確立している状況で読み取りまたは書き込み操作を行った場合、（以前にサーバによって返された）のstateidでなければならない（いかなるOPENは、共有の予約を構成します）バイト範囲ロックと共有の予約の両方を含むものロック、示すために使用される、状態、所有者によって保持されています。いかなる状態がクライアントによって確立されていない場合は、バイト範囲ロックまたは共有の予約（「その他」と「SEQID」の値としてゼロ）匿名状態のための特別のstateidのいずれかが使用されます。 （一般に「特別」のstateidsの説明については、セクション8.2.3を参照。）にかかわらず、匿名状態またはサーバによって返さのstateidのためのstateidが使用されているかどうかの、保持された競合共有予約や必須のバイト範囲ロックが存在する場合ファイルには、サーバーはREADまたはWRITE操作にサービスを提供することを拒否しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Share reservations are established by OPEN operations and by their nature are mandatory in that when the OPEN denies READ or WRITE operations, that denial results in such operations being rejected with error NFS4ERR_LOCKED. Byte-range locks may be implemented by the server as either mandatory or advisory, or the choice of mandatory or advisory behavior may be determined by the server on the basis of the file being accessed (for example, some UNIX-based servers support a \"mandatory lock bit\" on the mode attribute such that if set, byte-range locks are required on the file before I/O is possible). When byte-range locks are advisory, they only prevent the granting of conflicting lock requests and have no effect on READs or WRITEs. Mandatory byte-range locks, however, prevent conflicting I/O operations. When they are attempted, they are rejected with NFS4ERR_LOCKED. When the client gets NFS4ERR_LOCKED on a file for which it knows it has the proper share reservation, it will need to send a LOCK operation on the byte-range of the file that includes the byte-range the I/O was to be performed on, with an appropriate locktype field of the LOCK operation's arguments (i.e., READ*_LT for a READ operation, WRITE*_LT for a WRITE operation).",
      "ja": "OPENは、READまたはWRITE操作を拒否したとき、共有予約がOPEN操作によって、その性質上、確立されているという点で必須で、このような操作でその否定結果がエラーNFS4ERR_LOCKEDで拒否されています。バイト範囲ロックは必須または諮問のいずれかとしてサーバによって実現することができる、または必須または諮問行動の選択がアクセスされるファイルに基づいてサーバによって決定することができる（例えば、いくつかのUNIXベースのサーバは、「サポートモードで強制ロックビット」）が設定されている場合、I / Oが可能である前に、バイト範囲ロックがファイル上で必要とされるような属性。バイト範囲ロックが助言しているとき、彼らは唯一の競合ロック要求の付与を防止し、読み出しまたは書き込みには影響しません。必須バイト範囲ロックは、しかし、I / O操作の競合防ぎます。それらが試みられている場合、それらはNFS4ERR_LOCKEDで拒否されています。クライアントは、それが適切な共有の予約を持って知っているファイルにNFS4ERR_LOCKEDますと、それはI / Oの上に実行されることになっていたバイト範囲を含むファイルのバイト範囲のロック操作を送信する必要があります。 、LOCK操作の引数の適切な種類のLockType場で（すなわち、READ * _LTは、読み出し動作のために、* WRITE操作のための_LTをWRITE）。"
    },
    {
      "indent": 3,
      "text": "Note that for UNIX environments that support mandatory byte-range locking, the distinction between advisory and mandatory locking is subtle. In fact, advisory and mandatory byte-range locks are exactly the same as far as the APIs and requirements on implementation. If the mandatory lock attribute is set on the file, the server checks to see if the lock-owner has an appropriate shared (READ_LT) or exclusive (WRITE_LT) byte-range lock on the byte-range it wishes to READ from or WRITE to. If there is no appropriate lock, the server checks if there is a conflicting lock (which can be done by attempting to acquire the conflicting lock on behalf of the lock-owner, and if successful, release the lock after the READ or WRITE operation is done), and if there is, the server returns NFS4ERR_LOCKED.",
      "ja": "必須のバイト範囲ロッキングをサポートするUNIX環境のために、顧問及び強制ロックの間の区別は微妙であることに留意されたいです。実際には、顧問と必須バイト範囲ロックは限り実装のAPIと要件とまったく同じです。強制ロック属性がファイルに設定されている場合は、サーバーのかどうかを確認し、ロック所有者が共有適切な（READ_LT）またはバイト範囲に排他（WRITE_LT）バイト範囲ロックを持っている場合には、読み出しまたはWRITEしたいです。何の適切なロックが存在しない場合は、ロックの所有者に代わって、競合するロックを取得しようとすることによって行うことができ、競合するロック（サーバーチェックがある場合は、成功した場合、READまたはWRITE操作がされた後、ロックを解除）行われ、存在する場合、サーバはNFS4ERR_LOCKEDを返します。"
    },
    {
      "indent": 3,
      "text": "For Windows environments, byte-range locks are always mandatory, so the server always checks for byte-range locks during I/O requests.",
      "ja": "Windows環境の場合は、バイト範囲ロックは常に必須ですので、サーバは常にI / O要求時にバイト範囲ロックをチェックします。"
    },
    {
      "indent": 3,
      "text": "Thus, the LOCK operation does not need to distinguish between advisory and mandatory byte-range locks. It is the server's processing of the READ and WRITE operations that introduces the distinction.",
      "ja": "このように、LOCK操作が顧問と必須バイト範囲ロックを区別する必要はありません。それは区別を紹介読み取りおよび書き込み操作のサーバーの処理です。"
    },
    {
      "indent": 3,
      "text": "Every stateid that is validly passed to READ, WRITE, or SETATTR, with the exception of special stateid values, defines an access mode for the file (i.e., OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH).",
      "ja": "有効に、読み取り、書き込み、またはSETATTRに渡されるすべてのstateidは、特別のstateid値を除いて、ファイルのアクセスモード（すなわち、OPEN4_SHARE_ACCESS_READ、OPEN4_SHARE_ACCESS_WRITE、又はOPEN4_SHARE_ACCESS_BOTH）を定義します。"
    },
    {
      "indent": 3,
      "text": "o For stateids associated with opens, this is the mode defined by the original OPEN that caused the allocation of the OPEN stateid and as modified by subsequent OPENs and OPEN_DOWNGRADEs for the same open-owner/file pair.",
      "ja": "O開きと関連のstateidsの場合、これは、OPENのstateidの割り当てを引き起こし、原OPENによって定義されたモードで同じオープン所有者/ファイル・ペアのための後続開き、OPEN_DOWNGRADEsによって修正されます。"
    },
    {
      "indent": 3,
      "text": "o For stateids returned by byte-range LOCK operations, the appropriate mode is the access mode for the OPEN stateid associated with the lock set represented by the stateid.",
      "ja": "Oバイト範囲ロック操作によって返さのstateidsために、適切なモードは、のstateidで表されるロックセットに関連付けられたOPENのstateidのアクセスモードです。"
    },
    {
      "indent": 3,
      "text": "o For delegation stateids, the access mode is based on the type of delegation.",
      "ja": "委任のstateidsについてはO、アクセスモードは、委任の種類に基づいています。"
    },
    {
      "indent": 3,
      "text": "When a READ, WRITE, or SETATTR (that specifies the size attribute) operation is done, the operation is subject to checking against the access mode to verify that the operation is appropriate given the stateid with which the operation is associated.",
      "ja": "ときに読み取り、書き込み、またはSETATTR（すなわち、サイズ属性を指定する）操作が行われ、操作が操作は、操作が関連付けられているのstateid所与適切であることを確認するために、アクセスモードに対してチェックを受けます。"
    },
    {
      "indent": 3,
      "text": "In the case of WRITE-type operations (i.e., WRITEs and SETATTRs that set size), the server MUST verify that the access mode allows writing and MUST return an NFS4ERR_OPENMODE error if it does not. In the case of READ, the server may perform the corresponding check on the access mode, or it may choose to allow READ on OPENs for OPEN4_SHARE_ACCESS_WRITE, to accommodate clients whose WRITE implementation may unavoidably do reads (e.g., due to buffer cache constraints). However, even if READs are allowed in these circumstances, the server MUST still check for locks that conflict with the READ (e.g., another OPEN specified OPEN4_SHARE_DENY_READ or OPEN4_SHARE_DENY_BOTH). Note that a server that does enforce the access mode check on READs need not explicitly check for conflicting share reservations since the existence of OPEN for OPEN4_SHARE_ACCESS_READ guarantees that no conflicting share reservation can exist.",
      "ja": "書き込みタイプの操作（サイズを設定、すなわち、書き込み、SETATTRs）の場合には、サーバは、アクセスモードが書き込みを許可し、そうでない場合NFS4ERR_OPENMODEエラーを返す必要があることを確認しなければなりません。 READの場合は、サーバがアクセスモードに対応するチェックを行うことができる、またはそれはそのWRITE実装行う避けられないかもしれ読み込み、クライアントに対応するために、OPEN4_SHARE_ACCESS_WRITEためのOPENsにREADを許可することもできます（例えば、キャッシュ制約をバッファリングによる）。しかしながら、このような状況で許可されている読んでも、サーバーはREADと競合する（例えば、別のOPENはOPEN4_SHARE_DENY_READ又はOPEN4_SHARE_DENY_BOTH指定された）ロックをチェックしなければなりません。上のアクセスモードのチェックを強制しないサーバが明示的に競合する株式の予約が存在しないことをOPEN4_SHARE_ACCESS_READ保証のためのOPENの存在以来、シェアの予約の競合をチェックする必要はありません読み取るように注意してください。"
    },
    {
      "indent": 3,
      "text": "The READ bypass special stateid (all bits of \"other\" and \"seqid\" set to one) indicates a desire to bypass locking checks. The server MAY allow READ operations to bypass locking checks at the server, when this special stateid is used. However, WRITE operations with this special stateid value MUST NOT bypass locking checks and are treated exactly the same as if a special stateid for anonymous state were used.",
      "ja": "READバイパス特別のstateid（すべてのビットが「その他」といずれかに設定された「SEQID」）バイパスロックチェックしたい旨を示します。サーバは、この特別なstateidを使用する場合、READ操作は、サーバでのロックのチェックを回避することを可能にし得ます。しかしながら、この特別のstateid値と操作を書くバイパスチェックをロックしてはいけません、匿名状態のための特別のstateidを使用した場合と全く同様に扱われます。"
    },
    {
      "indent": 3,
      "text": "A lock may not be granted while a READ or WRITE operation using one of the special stateids is being performed and the scope of the lock to be granted would conflict with the READ or WRITE operation. This can occur when:",
      "ja": "特別のstateidsのいずれかを使用してREADまたはWRITE動作が実行されているロックの範囲は、READまたはWRITE動作と競合する付与するながら、ロックが付与されなくてもよいです。これは時に発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "o A mandatory byte-range lock is requested with a byte-range that conflicts with the byte-range of the READ or WRITE operation. For the purposes of this paragraph, a conflict occurs when a shared lock is requested and a WRITE operation is being performed, or an exclusive lock is requested and either a READ or a WRITE operation is being performed.",
      "ja": "O必須のバイト範囲ロックは、READまたはWRITE動作のバイト範囲と競合バイト範囲で要求されています。共有ロックが要求され、書き込み動作が行われている、または排他ロックが要求され、READまたはWRITE動作のいずれかが行われているとき、この項の目的のために、競合が発生します。"
    },
    {
      "indent": 3,
      "text": "o A share reservation is requested that denies reading and/or writing and the corresponding operation is being performed.",
      "ja": "共有予約oを読み取り及び/又は書き込みと対応する動作が行われている拒否することが要求されます。"
    },
    {
      "indent": 3,
      "text": "o A delegation is to be granted and the delegation type would prevent the I/O operation, i.e., READ and WRITE conflict with an OPEN_DELEGATE_WRITE delegation and WRITE conflicts with an OPEN_DELEGATE_READ delegation.",
      "ja": "委任oを付与されるべきであり、委譲タイプ、すなわち、READ及びOPEN_DELEGATE_WRITE委任との競合を書き込み、OPEN_DELEGATE_READ委任との競合をWRITE、I / O動作を妨げます。"
    },
    {
      "indent": 3,
      "text": "When a client holds a delegation, it needs to ensure that the stateid sent conveys the association of operation with the delegation, to avoid the delegation from being avoidably recalled. When the delegation stateid, a stateid open associated with that delegation, or a stateid representing byte-range locks derived from such an open is used, the server knows that the READ, WRITE, or SETATTR does not conflict with the delegation but is sent under the aegis of the delegation. Even though it is possible for the server to determine from the client ID (via the session ID) that the client does in fact have a delegation, the server is not obliged to check this, so using a special stateid can result in avoidable recall of the delegation.",
      "ja": "クライアントが委任を保持しているとき、それはavoidablyリコールされることから委任を避けるために、送信されたstateidは代表団と操作の関連を伝えることを確認する必要があります。委任のstateid、のstateidが使用される委任、またはそのようなオープン由来するバイト範囲ロックを表すのstateidに関連付けられた開いたときに、サーバは、読み取り、書き込みすることを知っている、またはSETATTRは委任と競合しないが、下に送られます。代表団の後援。サーバはクライアントが実際に委任していないサーバはこれをチェックする義務はない、ので、特別なstateidを使用しての回避リコールにつながることができること（セッションIDを経由して）クライアントIDから判断することが可能であるにもかかわらず、委任。"
    },
    {
      "indent": 0,
      "text": "9.2. Lock Ranges",
      "section_title": true,
      "ja": "9.2. ロック範囲"
    },
    {
      "indent": 3,
      "text": "The protocol allows a lock-owner to request a lock with a byte-range and then either upgrade, downgrade, or unlock a sub-range of the initial lock, or a byte-range that overlaps -- fully or partially -- either with that initial lock or a combination of a set of existing locks for the same lock-owner. It is expected that this will be an uncommon type of request. In any case, servers or server file systems may not be able to support sub-range lock semantics. In the event that a server receives a locking request that represents a sub-range of current locking state for the lock-owner, the server is allowed to return the error NFS4ERR_LOCK_RANGE to signify that it does not support sub-range lock operations. Therefore, the client should be prepared to receive this error and, if appropriate, report the error to the requesting application.",
      "ja": "完全にまたは部分的に -   - プロトコルが重なるバイト範囲のロックを要求した後、いずれかのアップグレード、ダウングレード、あるいは初期ロックのサブ範囲のロックを解除するロック所有者、またはバイト範囲を可能にするいずれかでその最初のロックまたは同じロック所有者のための既存のロックのセットの組み合わせ。要求の珍しいタイプであることが期待されます。いずれの場合も、サーバーまたはサーバーのファイル・システムは、サブ範囲ロックのセマンティクスをサポートすることができない場合があります。サーバは、ロック所有者の現在のロック状態のサブ範囲を表すロック要求を受信した場合に、サーバは、それがサブ範囲ロック操作をサポートしていないことを示すためにエラーNFS4ERR_LOCK_RANGEを返すことが許可されています。そのため、クライアントは、適切な場合には、要求元のアプリケーションにエラーを報告し、このエラーを受け取るために準備してする必要があります。"
    },
    {
      "indent": 3,
      "text": "The client is discouraged from combining multiple independent locking ranges that happen to be adjacent into a single request since the server may not support sub-range requests for reasons related to the recovery of byte-range locking state in the event of server failure. As discussed in Section 8.4.2, the server may employ certain optimizations during recovery that work effectively only when the client's behavior during lock recovery is similar to the client's locking behavior prior to server failure.",
      "ja": "クライアントは、サーバが、サーバに障害が発生した場合にバイト範囲ロック状態の回復に関連する理由のためのサブ範囲要求をサポートしないかもしれないので、単一の要求内に隣接するように起こる複数の独立したロック範囲を組み合わせることから推奨されます。 8.4.2項で述べたように、サーバはロックリカバリ時に、クライアントの動作は、サーバーの障害が発生する前に、クライアントのロック動作に似ている場合にのみ、効果的に機能回復中に特定の最適化を使用することができます。"
    },
    {
      "indent": 0,
      "text": "9.3. Upgrading and Downgrading Locks",
      "section_title": true,
      "ja": "9.3. ロックのアップグレードとダウングレード"
    },
    {
      "indent": 3,
      "text": "If a client has a WRITE_LT lock on a byte-range, it can request an atomic downgrade of the lock to a READ_LT lock via the LOCK operation, by setting the type to READ_LT. If the server supports atomic downgrade, the request will succeed. If not, it will return NFS4ERR_LOCK_NOTSUPP. The client should be prepared to receive this error and, if appropriate, report the error to the requesting application.",
      "ja": "クライアントは、バイト範囲のWRITE_LTロックを持っている場合、それはREAD_LTにタイプを設定することにより、LOCK操作によってREAD_LTロックにロックの原子格下げを要求することができます。サーバは、原子ダウングレードをサポートしている場合、要求は成功します。そうでない場合、それはNFS4ERR_LOCK_NOTSUPPを返します。クライアントは、適切な場合には、要求元のアプリケーションにエラーを報告し、このエラーを受け取るために準備してする必要があります。"
    },
    {
      "indent": 3,
      "text": "If a client has a READ_LT lock on a byte-range, it can request an atomic upgrade of the lock to a WRITE_LT lock via the LOCK operation by setting the type to WRITE_LT or WRITEW_LT. If the server does not support atomic upgrade, it will return NFS4ERR_LOCK_NOTSUPP. If the upgrade can be achieved without an existing conflict, the request will succeed. Otherwise, the server will return either NFS4ERR_DENIED or NFS4ERR_DEADLOCK. The error NFS4ERR_DEADLOCK is returned if the client sent the LOCK operation with the type set to WRITEW_LT and the server has detected a deadlock. The client should be prepared to receive such errors and, if appropriate, report the error to the requesting application.",
      "ja": "クライアントは、バイト範囲のREAD_LTロックを持っている場合、それはWRITE_LTするタイプやWRITEW_LTを設定することにより、LOCK操作によってWRITE_LTロックにロックの原子アップグレードを要求することができます。サーバは、原子のアップグレードをサポートしていない場合、それはNFS4ERR_LOCK_NOTSUPPを返します。アップグレードは、既存の競合することなく達成することができた場合、要求は成功します。そうしないと、サーバはNFS4ERR_DENIEDまたはNFS4ERR_DEADLOCKのいずれかを返します。クライアントがWRITEW_LTに設定タイプとサーバーとのLOCK操作がデッドロックを検出した送信された場合、エラーNFS4ERR_DEADLOCKが返されます。クライアントは、適切な場合には、要求元のアプリケーションにエラーを報告し、このようなエラーを受け取ることを準備するとすべきです。"
    },
    {
      "indent": 0,
      "text": "9.4. Stateid Seqid Values and Byte-Range Locks",
      "section_title": true,
      "ja": "9.4.  STATEID SEQID値とバイト範囲ロック"
    },
    {
      "indent": 3,
      "text": "When a LOCK or LOCKU operation is performed, the stateid returned has the same \"other\" value as the argument's stateid, and a \"seqid\" value that is incremented (relative to the argument's stateid) to reflect the occurrence of the LOCK or LOCKU operation. The server MUST increment the value of the \"seqid\" field whenever there is any change to the locking status of any byte offset as described by any of the locks covered by the stateid. A change in locking status includes a change from locked to unlocked or the reverse or a change from being locked for READ_LT to being locked for WRITE_LT or the reverse.",
      "ja": "LOCKまたはLOCKU操作が行われた場合、返されるのstateidはLOCKの発生又はLOCKU動作を反映するように引数ののstateid同じ「その他」の値、および（引数ののstateidに対して）インクリメントされ「SEQID」の値を有します。 stateidによって覆われたロックのいずれかで説明したようにオフセット任意のバイトのロック状態に変更があるたびにサーバが「SEQID」フィールドの値をインクリメントしなければなりません。ステータスロックの変化は、ロック解除または逆もしくはWRITE_LTまたはその逆のためにロックされるまでREAD_LTのためにロックされてからの変化にロックからの変更を含みます。"
    },
    {
      "indent": 3,
      "text": "When there is no such change, as, for example, when a range already locked for WRITE_LT is locked again for WRITE_LT, the server MAY increment the \"seqid\" value.",
      "ja": "例えば、範囲が既にWRITE_LTのためにロックするときWRITE_LT再度ロックされ、同様に、そのような変化がない場合、サーバは「SEQID」値をインクリメントしてもよい（MAY）。"
    },
    {
      "indent": 0,
      "text": "9.5. Issues with Multiple Open-Owners",
      "section_title": true,
      "ja": "9.5. 複数のオープン所有者に関する問題"
    },
    {
      "indent": 3,
      "text": "When the same file is opened by multiple open-owners, a client will have multiple OPEN stateids for that file, each associated with a different open-owner. In that case, there can be multiple LOCK and LOCKU requests for the same lock-owner sent using the different OPEN stateids, and so a situation may arise in which there are multiple stateids, each representing byte-range locks on the same file and held by the same lock-owner but each associated with a different open-owner.",
      "ja": "同じファイルが複数のオープン・オーナーが開かれると、クライアントは、それぞれが異なるオープン所有者に関連付けられ、そのファイルに対して複数のOPENのstateidsを持つことになります。その場合、異なるOPENのstateidsを使用して送信される同一のロック所有者のための複数のLOCKとLOCKU要求が存在することができ、そう状況は、複数のstateidsが存在している生じる同じファイルの各表すバイト範囲ロックして保持することができます同じロック所有者ではなく、それぞれ異なるオープン所有者に関連付けられています。"
    },
    {
      "indent": 3,
      "text": "In such a situation, the locking status of each byte (i.e., whether it is locked, the READ_LT or WRITE_LT type of the lock, and the lock-owner holding the lock) MUST reflect the last LOCK or LOCKU operation done for the lock-owner in question, independent of the stateid through which the request was sent.",
      "ja": "このような状況では、各バイトのロック状態（すなわち、それがロックされているかどうか、ロックのREAD_LT又はWRITE_LTタイプ、およびロックを保持ロック所有者）はロックインのために行わ最後LOCKまたはLOCKU動作を反映しなければなりませんリクエストが送信されたてのstateidの独立した問題の所有者、。"
    },
    {
      "indent": 3,
      "text": "When a byte is locked by the lock-owner in question, the open-owner to which that byte-range lock is assigned SHOULD be that of the open-owner associated with the stateid through which the last LOCK of that byte was done. When there is a change in the open-owner associated with locks for the stateid through which a LOCK or LOCKU was done, the \"seqid\" field of the stateid MUST be incremented, even if the locking, in terms of lock-owners has not changed. When there is a change to the set of locked bytes associated with a different stateid for the same lock-owner, i.e., associated with a different open-owner, the \"seqid\" value for that stateid MUST NOT be incremented.",
      "ja": "バイトが当該ロック所有者によってロックされている場合、そのバイト範囲ロックが割り当てられているオープン所有者は、そのバイトの最後のロックが行われたを通してのstateidに関連付けられたオープン所有者のものでなければなりません。 LOCKまたはLOCKUが行われたを通してのstateidのためのロックに関連付けられたオープン所有者に変更がある場合、のstateidの「SEQID」フィールドは、ロック所有者の観点でロックが、いなくても、増分されなければなりませんかわった。異なるオープン所有者に関連付けられている、すなわち、同じロック所有者のために異なるのstateid、関連付けられたロックされたバイトの集合に変化がある場合、そのためのstateid「SEQID」の値をインクリメントしてはいけません。"
    },
    {
      "indent": 0,
      "text": "9.6. Blocking Locks",
      "section_title": true,
      "ja": "9.6. ブロッキング・ロック"
    },
    {
      "indent": 3,
      "text": "Some clients require the support of blocking locks. While NFSv4.1 provides a callback when a previously unavailable lock becomes available, this is an OPTIONAL feature and clients cannot depend on its presence. Clients need to be prepared to continually poll for the lock. This presents a fairness problem. Two of the lock types, READW_LT and WRITEW_LT, are used to indicate to the server that the client is requesting a blocking lock. When the callback is not used, the server should maintain an ordered list of pending blocking locks. When the conflicting lock is released, the server may wait for the period of time equal to lease_time for the first waiting client to re-request the lock. After the lease period expires, the next waiting client request is allowed the lock. Clients are required to poll at an interval sufficiently small that it is likely to acquire the lock in a timely manner. The server is not required to maintain a list of pending blocked locks as it is used to increase fairness and not correct operation. Because of the unordered nature of crash recovery, storing of lock state to stable storage would be required to guarantee ordered granting of blocking locks.",
      "ja": "一部のクライアントには、ロックをブロックのサポートを必要とします。以前は利用できなかったロックが使用可能になったときにNFSv4.1コールバックを提供していますが、これはオプション機能とクライアントがその存在に依存することはできませんです。クライアントが継続的にロックをポーリングするために準備する必要があります。これは、公平性の問題を提示します。ロックタイプ、READW_LTとWRITEW_LTの二つは、クライアントがブロッキングロックを要求しているサーバーに示すために使用されています。コールバックを使用しない場合、サーバーは保留中のブロッキング・ロックの順序付きリストを維持する必要があります。矛盾するロックが解除されると、サーバーは再要求するロックへの最初の待機しているクライアントのためにlease_timeに等しい時間の期間を待つことができます。リース期間が満了した後、次の待機クライアントの要求は、ロックを許可されています。クライアントは、タイムリーにロックを取得する可能性があることを十分に小さい間隔でポーリングするように要求されています。サーバーは、正しい動作を公平性を高めるために使用されていないようブロックされたロックを保留中のリストを維持するために必要とされていません。そのためクラッシュ回復の順不同の性質上、安定したストレージにロック状態の記憶がロックをブロックする命じ付与を保証するために必要とされるであろう。"
    },
    {
      "indent": 3,
      "text": "Servers may also note the lock types and delay returning denial of the request to allow extra time for a conflicting lock to be released, allowing a successful return. In this way, clients can avoid the burden of needless frequent polling for blocking locks. The server should take care in the length of delay in the event the client retransmits the request.",
      "ja": "サーバはまた、ロックの種類に注意し、成功したリターンをできるように、リリースされる競合ロックのための余分な時間を与えるために、要求の拒否を返す遅れることがあります。このように、クライアントがロックを阻止するため、無駄に頻繁にポーリングの負担を回避することができます。サーバは、クライアントが要求を再送信する場合に、遅延の長さに世話をする必要があります。"
    },
    {
      "indent": 3,
      "text": "If a server receives a blocking LOCK operation, denies it, and then later receives a nonblocking request for the same lock, which is also denied, then it should remove the lock in question from its list of pending blocking locks. Clients should use such a nonblocking request to indicate to the server that this is the last time they intend to poll for the lock, as may happen when the process requesting the lock is interrupted. This is a courtesy to the server, to prevent it from unnecessarily waiting a lease period before granting other LOCK operations. However, clients are not required to perform this courtesy, and servers must not depend on them doing so. Also, clients must be prepared for the possibility that this final locking request will be accepted.",
      "ja": "サーバは、ブロックLOCK操作を受け付け、それを拒否し、その後も拒否されているのと同じロック、のためのノンブロッキング要求を受信した場合、それは保留中のブロッキング・ロックのリストから、問題のロックを解除する必要があります。クライアントは、これは、彼らがロックを要求しているプロセスが中断されたときに起こり得るような、ロックをポーリングする予定の最後の時間であるサーバーに示すために、このようなノンブロッキング要求を使用する必要があります。これは、不必要に他のLOCK操作を許可する前に、リース期間を待ってから、それを防ぐために、サーバへの礼儀です。ただし、クライアントはこの礼儀を実行するために必要とされていない、およびサーバはそうそれらに依存してはなりません。また、クライアントはこの最後のロック要求が受け入れられる可能性のために準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a server indicates, via the flag OPEN4_RESULT_MAY_NOTIFY_LOCK, that CB_NOTIFY_LOCK callbacks might be done for the current open file, the client should take notice of this, but, since this is a hint, cannot rely on a CB_NOTIFY_LOCK always being done. A client may reasonably reduce the frequency with which it polls for a denied lock, since the greater latency that might occur is likely to be eliminated given a prompt callback, but it still needs to poll. When it receives a CB_NOTIFY_LOCK, it should promptly try to obtain the lock, but it should be aware that other clients may be polling and that the server is under no obligation to reserve the lock for that particular client.",
      "ja": "サーバがCB_NOTIFY_LOCKコールバックは、現在開いているファイルに対して行われる可能性があることを、フラグOPEN4_RESULT_MAY_NOTIFY_LOCKを経由して、示している場合、クライアントは、この通知を取る必要がありますが、これはヒントがあるため、常に行われてCB_NOTIFY_LOCKに頼ることはできません。発生する可能性のある大きな遅延がプロンプトコールバック与え排除される可能性があるが、それはまだポーリングする必要があるため、クライアントは、合理的に、拒否されたロック用とそれがポーリング頻度を減らすことができます。それはCB_NOTIFY_LOCKを受けたときは、速やかロックを取得しようとする必要がありますが、他のクライアントがポーリングできず、サーバがその特定のクライアントのためにロックを予約する義務はないということを認識する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.7. Share Reservations",
      "section_title": true,
      "ja": "9.7. シェア予約"
    },
    {
      "indent": 3,
      "text": "A share reservation is a mechanism to control access to a file. It is a separate and independent mechanism from byte-range locking. When a client opens a file, it sends an OPEN operation to the server specifying the type of access required (READ, WRITE, or BOTH) and the type of access to deny others (OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH). If the OPEN fails, the client will fail the application's open request.",
      "ja": "シェア予約は、ファイルへのアクセスを制御するメカニズムです。これは、バイト範囲ロックは別個の独立した機構です。クライアントがファイルを開くと、それは他の人（OPE​​N4_SHARE_DENY_NONE、OPEN4_SHARE_DENY_READ、OPEN4_SHARE_DENY_WRITE、またはOPEN4_SHARE_DENY_BOTH）を否定する（READ、WRITE、またはBOTH）必要なアクセスの種類を指定してサーバにOPEN操作を送信し、アクセスの種類。 OPENが失敗した場合、クライアントは、アプリケーションのオープン要求を失敗します。"
    },
    {
      "indent": 3,
      "text": "Pseudo-code definition of the semantics:",
      "ja": "セマンティクスの擬似コードの定義："
    },
    {
      "indent": 11,
      "text": "if (request.access == 0) {\n  return (NFS4ERR_INVAL)\n} else {\n  if ((request.access & file_state.deny)) ||\n     (request.deny & file_state.access)) {\n    return (NFS4ERR_SHARE_DENIED)\n}\nreturn (NFS4ERR_OK);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When doing this checking of share reservations on OPEN, the current file_state used in the algorithm includes bits that reflect all current opens, including those for the open-owner making the new OPEN request.",
      "ja": "OPEN上の共有の予約のこのチェックを行う場合は、アルゴリズムで使用される現在のfile_stateは、オープン所有者が新しいOPEN要求を行うためのものを含めて、開く現在のすべてを反映するビットを含みます。"
    },
    {
      "indent": 3,
      "text": "The constants used for the OPEN and OPEN_DOWNGRADE operations for the access and deny fields are as follows:",
      "ja": "次のようにアクセスするためにOPENとOPEN_DOWNGRADE操作に使用してフィールドを否定する定数は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_ACCESS_READ   = 0x00000001;\nconst OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;\nconst OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_DENY_NONE     = 0x00000000;\nconst OPEN4_SHARE_DENY_READ     = 0x00000001;\nconst OPEN4_SHARE_DENY_WRITE    = 0x00000002;\nconst OPEN4_SHARE_DENY_BOTH     = 0x00000003;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.8. OPEN/CLOSE Operations",
      "section_title": true,
      "ja": "9.8.  OPEN / CLOSE操作"
    },
    {
      "indent": 3,
      "text": "To provide correct share semantics, a client MUST use the OPEN operation to obtain the initial filehandle and indicate the desired access and what access, if any, to deny. Even if the client intends to use a special stateid for anonymous state or READ bypass, it must still obtain the filehandle for the regular file with the OPEN operation so the appropriate share semantics can be applied. Clients that do not have a deny mode built into their programming interfaces for opening a file should request a deny mode of OPEN4_SHARE_DENY_NONE.",
      "ja": "正しい共有セマンティクスを提供するために、クライアントは、最初のファイルハンドルを取得するためにOPEN操作を使用しなければならないと拒否し、もしあれば、所望のアクセスと何のアクセスを示しています。クライアントが匿名状態またはREADバイパスのための特別なstateidを使用しようとする場合であっても、適切な共有のセマンティクスを適用することができますので、それはまだOPEN操作で通常のファイルのためのファイルハンドルを取得する必要があります。ファイルを開くための彼らのプログラミング・インターフェースに組み込まれて拒否モードを持っていないクライアントは、OPEN4_SHARE_DENY_NONEの拒否モードを要求すべきです。"
    },
    {
      "indent": 3,
      "text": "The OPEN operation with the CREATE flag also subsumes the CREATE operation for regular files as used in previous versions of the NFS protocol. This allows a create with a share to be done atomically.",
      "ja": "CREATEフラグをOPEN動作もNFSプロトコルの以前のバージョンで使用されるような、通常のファイルのCREATE操作を包含し。これはアトミックに行われるシェアで作成できます。"
    },
    {
      "indent": 3,
      "text": "The CLOSE operation removes all share reservations held by the open-owner on that file. If byte-range locks are held, the client SHOULD release all locks before sending a CLOSE operation. The server MAY free all outstanding locks on CLOSE, but some servers may not support the CLOSE of a file that still has byte-range locks held. The server MUST return failure, NFS4ERR_LOCKS_HELD, if any locks would exist after the CLOSE.",
      "ja": "CLOSE操作は、そのファイルのオープン、所有者が保有する全ての株式の予約を削除します。バイト範囲ロックが保持されている場合、クライアントはCLOSEオペレーションを送る前に、すべてのロックを解除しなければなりません。サーバーは、CLOSE上のすべての未解決のロックを解放するかもしれが、一部のサーバーがまだ開催されたバイト範囲ロックを持つファイルのCLOSEをサポートしていないかもしれません。すべてのロックは、CLOSEの後に存在するならば、サーバーは、障害が発生、NFS4ERR_LOCKS_HELDを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The LOOKUP operation will return a filehandle without establishing any lock state on the server. Without a valid stateid, the server will assume that the client has the least access. For example, if one client opened a file with OPEN4_SHARE_DENY_BOTH and another client accesses the file via a filehandle obtained through LOOKUP, the second client could only read the file using the special read bypass stateid. The second client could not WRITE the file at all because it would not have a valid stateid from OPEN and the special anonymous stateid would not be allowed access.",
      "ja": "LOOKUP操作は、サーバー上の任意のロック状態を確立することなくファイルハンドルを返します。有効なstateidがなければ、サーバーは、クライアントが少なくともアクセス権を持っていることを前提としています。 1つのクライアントがOPEN4_SHARE_DENY_BOTHでファイルを開いて、別のクライアントがLOOKUPを経て得られたファイルハンドル経由でファイルにアクセスする場合、例えば、2番目のクライアントは、特別な読み取りバイパスのstateidを使用してファイルを読み込むことができます。それがアクセスを許可されませんOPENと特別な匿名なstateidから有効なstateidを持っていないため、2番目のクライアントは、すべてのファイルを書き込むことができませんでした。"
    },
    {
      "indent": 0,
      "text": "9.9. Open Upgrade and Downgrade",
      "section_title": true,
      "ja": "9.9. オープンアップグレードおよびダウングレード"
    },
    {
      "indent": 3,
      "text": "When an OPEN is done for a file and the open-owner for which the OPEN is being done already has the file open, the result is to upgrade the open file status maintained on the server to include the access and deny bits specified by the new OPEN as well as those for the existing OPEN. The result is that there is one open file, as far as the protocol is concerned, and it includes the union of the access and deny bits for all of the OPEN requests completed. The OPEN is represented by a single stateid whose \"other\" value matches that of the original open, and whose \"seqid\" value is incremented to reflect the occurrence of the upgrade. The increment is required in cases in which the \"upgrade\" results in no change to the open mode (e.g., an OPEN is done for read when the existing open file is opened for",
      "ja": "OPENは、ファイルとOPENが既に行わファイルを開いているされているオープン所有者のために行われた場合、結果は新しいで指定されたビットへのアクセスを含めると拒否するようにサーバー上に保持開いているファイルのステータスをアップグレードすることです同様に、既存のOPENのものとしてOPEN。結果は限りプロトコルに関しては、1つの開いているファイルがあることであり、それはアクセスの組合を含んでおり、完成OPENすべての要求のためのビットを否定します。 OPENは、その「他の」値は、元のオープンのものと一致し、その「SEQID」値アップグレードの発生を反映するようにインクリメントされる単一のstateidで表されます。増分は、既存の開いているファイルがために開かれたとき、オープンモードへの変更なしで結果を「アップグレード」（例えば、OPENが読み取りのために行われた場合に必要とされます"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_BOTH). Only a single CLOSE will be done to reset the effects of both OPENs. The client may use the stateid returned by the OPEN effecting the upgrade or with a stateid sharing the same \"other\" field and a seqid of zero, although care needs to be taken as far as upgrades that happen while the CLOSE is pending. Note that the client, when sending the OPEN, may not know that the same file is in fact being opened. The above only applies if both OPENs result in the OPENed object being designated by the same filehandle.",
      "ja": "OPEN4_SHARE_ACCESS_BOTH）。つだけCLOSEが開き、両方の効果をリセットするために行われます。ケアは限りCLOSEが保留されている間に起こるアップグレードなどの注意が必要ものの、クライアントは、アップグレードまたは同じ「その他」フィールドとゼロのSEQIDを共有したstateidとを行うOPENによって返されたstateidを使用することができます。 OPENを送信するとき、クライアントは、同じファイルが実際に開かれていることを知らないかもしれないことに注意してください。両方が同じファイルハンドルによって指定されるオープンされたオブジェクトをもたらす開いた場合、上記にのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "When the server chooses to export multiple filehandles corresponding to the same file object and returns different filehandles on two different OPENs of the same file object, the server MUST NOT \"OR\" together the access and deny bits and coalesce the two open files. Instead, the server must maintain separate OPENs with separate stateids and will require separate CLOSEs to free them.",
      "ja": "サーバーは、同じファイルオブジェクトに対応する複数のファイルハンドルをエクスポートすることを選択したと同じファイルオブジェクトの二つの異なるのOPENs上の異なるファイルハンドルを返し、サーバーはMUST NOT「OR」一緒にアクセスをしてビットを否定し、2つの開いているファイルを結合する場合。代わりに、サーバは別ののstateidsで別々のOPENsを維持しなければならないし、それらを解放するために別の閉じが必要になります。"
    },
    {
      "indent": 3,
      "text": "When multiple open files on the client are merged into a single OPEN file object on the server, the close of one of the open files (on the client) may necessitate change of the access and deny status of the open file on the server. This is because the union of the access and deny bits for the remaining opens may be smaller (i.e., a proper subset) than previously. The OPEN_DOWNGRADE operation is used to make the necessary change and the client should use it to update the server so that share reservation requests by other clients are handled properly. The stateid returned has the same \"other\" field as that passed to the server. The \"seqid\" value in the returned stateid MUST be incremented, even in situations in which there is no change to the access and deny bits for the file.",
      "ja": "クライアント上の複数の開いているファイルを、サーバー上の単一のオープンファイルオブジェクトにマージされている場合、（クライアント上）開いているファイルの一つの近くには、アクセスの変更を必要とし、サーバー上の開いているファイルの状態を拒否することができます。アクセスの和集合と残りのためのビットを否定するが、以前よりも（すなわち、適切なサブセット）も小さくてもよい開くからです。 OPEN_DOWNGRADE操作が必要な変更を行うために使用され、他のクライアントがその共有の予約要求が適切に処理されているように、クライアントはサーバーを更新するためにそれを使用する必要があります。返されたstateidはサーバに渡さと同じ「その他」のフィールドがあります。返されたstateidで「SEQID」の値であってもそこにアクセスするためには変化がなく、ファイルのビットを拒否している状況では、増加しなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.10. Parallel OPENs",
      "section_title": true,
      "ja": "9.10. パラレルのOPENs"
    },
    {
      "indent": 3,
      "text": "Unlike the case of NFSv4.0, in which OPEN operations for the same open-owner are inherently serialized because of the owner-based seqid, multiple OPENs for the same open-owner may be done in parallel. When clients do this, they may encounter situations in which, because of the existence of hard links, two OPEN operations may turn out to open the same file, with a later OPEN performed being an upgrade of the first, with this fact only visible to the client once the operations complete.",
      "ja": "同じオープン所有者のOPEN操作は、本質的ため所有者ベースSEQIDの直列化されたNFSv4.0の場合とは異なり、同じオープン所有者のための複数のOPENsを並行して行うことができます。クライアントはこれを行うと、彼らはので、ハードリンクの存在、状況が発生することがあり、2つのOPEN操作は、後にOPENして、同じファイルを開くためになるかもしれ行っだけに見えるこの事実と、最初のアップグレードであること完全な操作一度クライアント。"
    },
    {
      "indent": 3,
      "text": "In this situation, clients may determine the order in which the OPENs were performed by examining the stateids returned by the OPENs. Stateids that share a common value of the \"other\" field can be recognized as having opened the same file, with the order of the operations determinable from the order of the \"seqid\" fields, mod any possible wraparound of the 32-bit field.",
      "ja": "このような状況では、クライアントが表示されますが開いによって返されたのstateidsを調べることによって実行された順序を決定することができます。 「その他」のフィールドの共通の値を共有するのstateidsは、32ビットのフィールドの任意の可能なラップアラウンドをMOD、「SEQID」フィールドの順序から決定オペレーションの順序で、同じファイルをオープンしたと認識することができます。"
    },
    {
      "indent": 3,
      "text": "When the possibility exists that the client will send multiple OPENs for the same open-owner in parallel, it may be the case that an open upgrade may happen without the client knowing beforehand that this could happen. Because of this possibility, CLOSEs and OPEN_DOWNGRADEs should generally be sent with a non-zero seqid in the stateid, to avoid the possibility that the status change associated with an open upgrade is not inadvertently lost.",
      "ja": "可能性はクライアントが並行して同じオープン所有者のために複数のOPENsを送信することが存在する場合、それはオープンアップグレードが、クライアントはこれが起こる可能性がありますので、予め知らなくても起こるかもしれません場合があります。このため可能性、閉じ、OPEN_DOWNGRADEsは一般的に、オープンアップグレードに関連した状態変化が不用意に失われていないという可能性を避けるために、のstateid内の非ゼロSEQIDで送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.11. Reclaim of Open and Byte-Range Locks",
      "section_title": true,
      "ja": "9.11. オープンとバイト範囲ロックの再利用"
    },
    {
      "indent": 3,
      "text": "Special forms of the LOCK and OPEN operations are provided when it is necessary to re-establish byte-range locks or opens after a server failure.",
      "ja": "それが再確立バイト範囲ロックする必要があるか、サーバーに障害が発生した後開いたときにLOCKとOPENオペレーションの特別なフォームが用意されています。"
    },
    {
      "indent": 3,
      "text": "o To reclaim existing opens, an OPEN operation is performed using a CLAIM_PREVIOUS. Because the client, in this type of situation, will have already opened the file and have the filehandle of the target file, this operation requires that the current filehandle be the target file, rather than a directory, and no file name is specified.",
      "ja": "既存の再利用するためにoがOPEN操作がCLAIM_PREVIOUSを使用して行われ、開きます。クライアントは、このような状況では、既にファイルを開いて、対象ファイルのファイルハンドルを持っていますので、この操作は、現在のファイルハンドルがターゲットファイルではなくディレクトリであることを必要とし、ファイル名が指定されていません。"
    },
    {
      "indent": 3,
      "text": "o To reclaim byte-range locks, a LOCK operation with the reclaim parameter set to true is used.",
      "ja": "Oは、バイト範囲ロックを解放するには、trueに設定再利用パラメータとLOCK動作が使用されます。"
    },
    {
      "indent": 3,
      "text": "Reclaims of opens associated with delegations are discussed in Section 10.2.1.",
      "ja": "代表団に関連した開きの再要求は、10.2.1項で説明されています。"
    },
    {
      "indent": 0,
      "text": "10. Client-Side Caching",
      "section_title": true,
      "ja": "10.クライアント側のキャッシュ"
    },
    {
      "indent": 3,
      "text": "Client-side caching of data, of file attributes, and of file names is essential to providing good performance with the NFS protocol. Providing distributed cache coherence is a difficult problem, and previous versions of the NFS protocol have not attempted it. Instead, several NFS client implementation techniques have been used to reduce the problems that a lack of coherence poses for users. These techniques have not been clearly defined by earlier protocol specifications, and it is often unclear what is valid or invalid client behavior.",
      "ja": "ファイル属性の、およびファイル名のデータのクライアント側のキャッシュは、NFSプロトコルとの良好なパフォーマンスを提供するために不可欠です。分散キャッシュの一貫性を提供することは困難な問題であり、およびNFSプロトコルの以前のバージョンではそれをしようとしていません。代わりに、いくつかのNFSクライアントの実装技術は、一貫性の欠如は、ユーザーのためのポーズの問題を軽減するために使用されています。これらの技術は明らかに以前のプロトコル仕様で定義されていない、有効か無効クライアントの動作が何であるかを、多くの場合不明です。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol uses many techniques similar to those that have been used in previous protocol versions. The NFSv4.1 protocol does not provide distributed cache coherence. However, it defines a more limited set of caching guarantees to allow locks and share reservations to be used without destructive interference from client-side caching.",
      "ja": "NFSv4.1プロトコルは、以前のプロトコルバージョンで使用されたものと同様の多くの技術を使用します。 NFSv4.1プロトコルは、分散キャッシュの一貫性を提供していません。しかし、ロックと共有の予約がクライアント側のキャッシュからの破壊的干渉なしに使用することができるようにキャッシング保証のより限定されたセットを定義します。"
    },
    {
      "indent": 3,
      "text": "In addition, the NFSv4.1 protocol introduces a delegation mechanism, which allows many decisions normally made by the server to be made locally by clients. This mechanism provides efficient support of the common cases where sharing is infrequent or where sharing is read-only.",
      "ja": "また、NFSv4.1プロトコルは、通常、サーバーによって行われた多くの決定は、クライアントによってローカルで行うことを可能にする委任メカニズムが導入されています。この機構は、共有がまれであるか、または共有が読み取り専用である場合に一般的なケースの効率的なサポートを提供します。"
    },
    {
      "indent": 0,
      "text": "10.1. Performance Challenges for Client-Side Caching",
      "section_title": true,
      "ja": "10.1. クライアント側のキャッシュのパフォーマンスの課題"
    },
    {
      "indent": 3,
      "text": "Caching techniques used in previous versions of the NFS protocol have been successful in providing good performance. However, several scalability challenges can arise when those techniques are used with very large numbers of clients. This is particularly true when clients are geographically distributed, which classically increases the latency for cache revalidation requests.",
      "ja": "NFSプロトコルの以前のバージョンで使用されるキャッシュ技術は、優れた性能を提供することに成功しています。これらの技術は、クライアントの非常に大きな数字で使用されている場合しかし、いくつかのスケーラビリティの問題が発生する可能性があります。クライアントが地理的に古典的にキャッシュ再検証要求のための待ち時間が増加する、分散している場合は特にそうです。"
    },
    {
      "indent": 3,
      "text": "The previous versions of the NFS protocol repeat their file data cache validation requests at the time the file is opened. This behavior can have serious performance drawbacks. A common case is one in which a file is only accessed by a single client. Therefore, sharing is infrequent.",
      "ja": "NFSプロトコルの以前のバージョンでは、ファイルが開かれた時にそのファイルのデータ・キャッシュの検証要求を繰り返します。この動作は、パフォーマンスに重大な欠点を持つことができます。一般的なケースでは、ファイルは、単一のクライアントがアクセスしたものです。そのため、共有はまれです。"
    },
    {
      "indent": 3,
      "text": "In this case, repeated references to the server to find that no conflicts exist are expensive. A better option with regards to performance is to allow a client that repeatedly opens a file to do so without reference to the server. This is done until potentially conflicting operations from another client actually occur.",
      "ja": "この場合、競合が存在しない高価であることを見つけるために、サーバーへの参照を繰り返しました。パフォーマンスに関してとのより良いオプションは、繰り返し、サーバーを参照することなくこれを行うには、ファイルを開くクライアントをできるようにすることです。別のクライアントからの潜在的な競合の操作が実際に発生するまで、これが行われます。"
    },
    {
      "indent": 3,
      "text": "A similar situation arises in connection with byte-range locking. Sending LOCK and LOCKU operations as well as the READ and WRITE operations necessary to make data caching consistent with the locking semantics (see Section 10.3.2) can severely limit performance. When locking is used to provide protection against infrequent conflicts, a large penalty is incurred. This penalty may discourage the use of byte-range locking by applications.",
      "ja": "同様の状況は、バイト範囲ロックに関連して生じます。 LOCKとLOCKU操作ならびにロッキングセマンティクスでデータキャッシュに一貫性を持たせるために必要な読み取りおよび書き込み操作を送信（10.3.2項を参照）パフォーマンスが大幅に制限することができます。ロックがまれ衝突に対する保護を提供するために使用される場合、大きなペナルティが発生しています。このペナルティは、アプリケーションによってバイト範囲ロックの使用を阻止することができます。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol provides more aggressive caching strategies with the following design goals:",
      "ja": "NFSv4.1プロトコルは、次の設計目標をより積極的なキャッシング戦略を提供します。"
    },
    {
      "indent": 3,
      "text": "o Compatibility with a large range of server semantics.",
      "ja": "サーバーのセマンティクスの大規模な範囲でのOの互換性。"
    },
    {
      "indent": 3,
      "text": "o Providing the same caching benefits as previous versions of the NFS protocol when unable to support the more aggressive model.",
      "ja": "より積極的なモデルをサポートすることができませんでしNFSプロトコルの以前のバージョンと同じキャッシングの利点を提供し、O。"
    },
    {
      "indent": 3,
      "text": "o Requirements for aggressive caching are organized so that a large portion of the benefit can be obtained even when not all of the requirements can be met.",
      "ja": "利益の大部分は、要件のすべてを満たすことができない場合でも得られるように、積極的なキャッシュ用のO要件が整理されています。"
    },
    {
      "indent": 3,
      "text": "The appropriate requirements for the server are discussed in later sections in which specific forms of caching are covered (see Section 10.4).",
      "ja": "サーバのための適切な要件は、キャッシュの特定の形態は、被覆された後のセクション（セクション10.4を参照）に記載されています。"
    },
    {
      "indent": 0,
      "text": "10.2. Delegation and Callbacks",
      "section_title": true,
      "ja": "10.2. 委任とコールバック"
    },
    {
      "indent": 3,
      "text": "Recallable delegation of server responsibilities for a file to a client improves performance by avoiding repeated requests to the server in the absence of inter-client conflict. With the use of a \"callback\" RPC from server to client, a server recalls delegated responsibilities when another client engages in sharing of a delegated file.",
      "ja": "クライアントへのファイルのサーバー責任のリコール代表団は、クライアント間の競合が存在しない場合に、サーバーへの再三の要求を回避することによって、パフォーマンスが向上します。別のクライアントが委任ファイルの共有に従事したときに、サーバーからクライアントへの「コールバック」RPCを使用すると、サーバーは、委任の責任を思い出します。"
    },
    {
      "indent": 3,
      "text": "A delegation is passed from the server to the client, specifying the object of the delegation and the type of delegation. There are different types of delegations, but each type contains a stateid to be used to represent the delegation when performing operations that depend on the delegation. This stateid is similar to those associated with locks and share reservations but differs in that the stateid for a delegation is associated with a client ID and may be used on behalf of all the open-owners for the given client. A delegation is made to the client as a whole and not to any specific process or thread of control within it.",
      "ja": "委任は、委任の対象と委任の種類を指定して、サーバからクライアントに渡されます。そこ代表団の異なるタイプがありますが、それぞれのタイプには、代表団に依存する操作を実行する場合、委任を表すために使用されるのstateidが含まれています。これのstateidはロックとシェアの予約に関連したものと同様であるが、代表団のためのstateidは、クライアントIDに関連付けられており、特定のクライアントのために開いているすべての所有者に代わって使用することができるという点で異なります。代表団は、全体としてではなく、特定のプロセスやその内のコントロールのスレッドに、クライアントに行われます。"
    },
    {
      "indent": 3,
      "text": "The backchannel is established by CREATE_SESSION and BIND_CONN_TO_SESSION, and the client is required to maintain it. Because the backchannel may be down, even temporarily, correct protocol operation does not depend on them. Preliminary testing of backchannel functionality by means of a CB_COMPOUND procedure with a single operation, CB_SEQUENCE, can be used to check the continuity of the backchannel. A server avoids delegating responsibilities until it has determined that the backchannel exists. Because the granting of a delegation is always conditional upon the absence of conflicting access, clients MUST NOT assume that a delegation will be granted and they MUST always be prepared for OPENs, WANT_DELEGATIONs, and GET_DIR_DELEGATIONs to be processed without any delegations being granted.",
      "ja": "バックチャネルはCREATE_SESSIONとBIND_CONN_TO_SESSIONによって確立され、クライアントはそれを維持するために必要とされます。バックチャネルがダウンしている可能性があるため、一時的であっても、正しいプロトコル動作は、それらに依存しません。単一操作でCB_COMPOUND手順によってバックチャネル機能の予備試験、CB_SEQUENCEは、バックチャネルの連続性を確認するために使用することができます。サーバーは、それがバックチャネルが存在すると判断するまで、責任を委譲避けることができます。代表団の付与は、競合アクセスの不在時に常に条件付きであるため、クライアントは、代表団が付与され、それらは常に代表団が許可されずに処理されることに開いて、WANT_DELEGATIONs、およびGET_DIR_DELEGATIONsのために準備しなければなりませんと仮定してはいけません。"
    },
    {
      "indent": 3,
      "text": "Unlike locks, an operation by a second client to a delegated file will cause the server to recall a delegation through a callback. For individual operations, we will describe, under IMPLEMENTATION, when such operations are required to effect a recall. A number of points should be noted, however.",
      "ja": "ロックとは異なり、委任ファイルへの2番目のクライアントによる操作は、サーバーがコールバックを通じて委任をリコールするようになります。個々の操作のために、私たちは、このような操作はリコールを行うために必要とされている場合、実装の下で、説明します。点の数は、しかし、留意すべきです。"
    },
    {
      "indent": 3,
      "text": "o The server is free to recall a delegation whenever it feels it is desirable and may do so even if no operations requiring recall are being done.",
      "ja": "Oサーバーは、それが望ましいとリコールが必要な何も操作が行われていないされている場合でも、そうすることができると感じる時はいつでも委任をリコールして自由です。"
    },
    {
      "indent": 3,
      "text": "o Operations done outside the NFSv4.1 protocol, due to, for example, access by other protocols, or by local access, also need to result in delegation recall when they make analogous changes to file system data. What is crucial is if the change would invalidate the guarantees provided by the delegation. When this is possible, the delegation needs to be recalled and MUST be returned or revoked before allowing the operation to proceed.",
      "ja": "O操作は、例えば、原因に、NFSv4.1プロトコル外で行わ他のプロトコルによるアクセス、またはローカルアクセスにより、また、彼らはシステムデータをファイルに類似した変更を加えたときに、委任のリコールにつながるする必要があります。変更は代表団が提供する保証が無効になる場合は何非常に重要なことはあります。これが可能である場合には、代表団は、リコールする必要があり、操作が続行を許可する前に戻ったり取り消さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The semantics of the file system are crucial in defining when delegation recall is required. If a particular change within a specific implementation causes change to a file attribute, then delegation recall is required, whether that operation has been specifically listed as requiring delegation recall. Again, what is critical is whether the guarantees provided by the delegation are being invalidated.",
      "ja": "ファイルシステムのセマンティクスoを委譲リコールが必要な場合に定義する際に重要です。特定の実装内の特定の変更は、ファイル属性に変更が生じた場合は、委任のリコールは、その操作は、具体的に委任のリコールを要求するものとして記載されているかどうか、必要とされます。ここでも、どのような重要なことは、代表団が提供する保証が無効にされているかどうかです。"
    },
    {
      "indent": 3,
      "text": "Despite those caveats, the implementation sections for a number of operations describe situations in which delegation recall would be required under some common circumstances:",
      "ja": "これらの警告にもかかわらず、操作の数の実装のセクションでは、委任のリコールは、いくつかの一般的な状況下で必要とされるであろう状況を説明します。"
    },
    {
      "indent": 3,
      "text": "o For GETATTR, see Section 18.7.4.",
      "ja": "O GETATTRは、項18.7.4を参照。"
    },
    {
      "indent": 3,
      "text": "o For OPEN, see Section 18.16.4.",
      "ja": "O OPENについては、項18.16.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o For READ, see Section 18.22.4.",
      "ja": "O READについては、項18.22.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o For REMOVE, see Section 18.25.4.",
      "ja": "O REMOVEについては、項18.25.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o For RENAME, see Section 18.26.4.",
      "ja": "O RENAMEについては、項18.26.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o For SETATTR, see Section 18.30.4.",
      "ja": "O SETATTRについては、項18.30.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o For WRITE, see Section 18.32.4.",
      "ja": "O WRITEについては、項18.32.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "On recall, the client holding the delegation needs to flush modified state (such as modified data) to the server and return the delegation. The conflicting request will not be acted on until the recall is complete. The recall is considered complete when the client returns the delegation or the server times its wait for the delegation to be returned and revokes the delegation as a result of the timeout. In the interim, the server will either delay responding to conflicting requests or respond to them with NFS4ERR_DELAY. Following the resolution of the recall, the server has the information necessary to grant or deny the second client's request.",
      "ja": "リコールでは、委任を保持しているクライアントは、サーバに（例えば修正されたデータなど）変更された状態をフラッシュし、委任を返す必要があります。リコールが完了するまでの相反する要求を実行しません。クライアントが委任またはサーバー回返され、タイムアウトの結果として委任を取り消しする委譲のための待機を返したときにリコールが完了したと見なされます。暫定では、サーバはどちらかの遅延、競合する要求に応答しますかNFS4ERR_DELAYでそれらに対応しています。リコールの解決に続いて、サーバーは、第二のクライアントの要求を許可または拒否するために必要な情報を持っています。"
    },
    {
      "indent": 3,
      "text": "At the time the client receives a delegation recall, it may have substantial state that needs to be flushed to the server. Therefore, the server should allow sufficient time for the delegation to be returned since it may involve numerous RPCs to the server. If the server is able to determine that the client is diligently flushing state to the server as a result of the recall, the server may extend the usual time allowed for a recall. However, the time allowed for recall completion should not be unbounded.",
      "ja": "クライアントが委譲リコールを受ける時には、それがサーバーにフラッシュする必要がかなりの状態を有することができます。そのため、サーバーは、サーバーに多数のRPCを含むことができるので、返される委譲のための十分な時間を許可する必要があります。サーバは、クライアントが熱心にリコールの結果としてサーバーに状態をフラッシュしていることを決定することができる場合は、サーバーはリコールのために許可される通常の時間を延長することができます。しかし、リコール完了に許される時間は無制限ではありません。"
    },
    {
      "indent": 3,
      "text": "An example of this is when responsibility to mediate opens on a given file is delegated to a client (see Section 10.4). The server will not know what opens are in effect on the client. Without this knowledge, the server will be unable to determine if the access and deny states for the file allow any particular open until the delegation for the file has been returned.",
      "ja": "仲介する責任が与えられたファイルに開いたときに、この例では（項10.4を参照）、クライアントに委譲されています。開いたのか分からなくなり、サーバーは、クライアントに適用されています。この知識がないと、サーバーは、次の場合にアクセスを決定し、ファイルの委譲が返されるまで、ファイルの状態は、特定のオープンを許可、拒否することができません。"
    },
    {
      "indent": 3,
      "text": "A client failure or a network partition can result in failure to respond to a recall callback. In this case, the server will revoke the delegation, which in turn will render useless any modified state still on the client.",
      "ja": "クライアント障害またはネットワークパーティションは、リコールコールバックに応答する障害が発生することができます。この場合、サーバは、順番に、クライアント上ではまだ役に立たない任意の変更された状態をレンダリングします委任を、取り消します。"
    },
    {
      "indent": 0,
      "text": "10.2.1. Delegation Recovery",
      "section_title": true,
      "ja": "10.2.1. 委任回復"
    },
    {
      "indent": 3,
      "text": "There are three situations that delegation recovery needs to deal with:",
      "ja": "代表団の回復が対処する必要があることの3つの状況があります。"
    },
    {
      "indent": 3,
      "text": "o client restart",
      "ja": "Oクライアントの再起動"
    },
    {
      "indent": 3,
      "text": "o server restart",
      "ja": "Oサーバの再起動"
    },
    {
      "indent": 3,
      "text": "o network partition (full or backchannel-only)",
      "ja": "Oネットワークパーティション（完全またはバックチャンネルのみ）"
    },
    {
      "indent": 3,
      "text": "In the event the client restarts, the failure to renew the lease will result in the revocation of byte-range locks and share reservations. Delegations, however, may be treated a bit differently.",
      "ja": "クライアントが再起動する場合には、リースの更新に失敗すると、バイト範囲ロックと共有の予約の取り消しになります。代表団は、しかし、異なるビットを処理することができます。"
    },
    {
      "indent": 3,
      "text": "There will be situations in which delegations will need to be re-established after a client restarts. The reason for this is that the client may have file data stored locally and this data was associated with the previously held delegations. The client will need to re-establish the appropriate file state on the server.",
      "ja": "代表団は、クライアントの再起動後に再確立する必要がある状況があります。この理由は、クライアントがファイルデータがローカルに保存されている可能性があり、このデータが以前に開催された代表団と関連していたということです。クライアントは、サーバ上の適切なファイルの状態を再確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "To allow for this type of client recovery, the server MAY extend the period for delegation recovery beyond the typical lease expiration period. This implies that requests from other clients that conflict with these delegations will need to wait. Because the normal recall process may require significant time for the client to flush changed state to the server, other clients need be prepared for delays that occur because of a conflicting delegation. This longer interval would increase the window for clients to restart and consult stable storage so that the delegations can be reclaimed. For OPEN delegations, such delegations are reclaimed using OPEN with a claim type of CLAIM_DELEGATE_PREV or CLAIM_DELEG_PREV_FH (see Sections 10.5 and 18.16 for discussion of OPEN delegation and the details of OPEN, respectively).",
      "ja": "クライアントの回復のこのタイプを可能にするため、サーバーは、一般的なリースの有効期限を越えた委任回復のための期間を延長することができます。これは、他のクライアントからの要求は、これらの代表団と競合を待つ必要があることを意味します。クライアントがサーバに変更された状態をフラッシュするために、通常のリコール処理はかなりの時間が必要な場合がありますので、他のクライアントがあるため、競合する代表団の発生の遅れのために準備される必要があります。この長い間隔は代表団を再利用できるように、安定した記憶装置を再起動して相談するクライアントのためのウィンドウを増加させることになります。 OPEN委任のため、そのような委任（それぞれ、セクションOPEN委任の議論とOPENの詳細については10.5および18.16を参照）CLAIM_DELEGATE_PREV又はCLAIM_DELEG_PREV_FHのクレームタイプでOPEN用いて再生されます。"
    },
    {
      "indent": 3,
      "text": "A server MAY support claim types of CLAIM_DELEGATE_PREV and CLAIM_DELEG_PREV_FH, and if it does, it MUST NOT remove delegations upon a CREATE_SESSION that confirm a client ID created by EXCHANGE_ID. Instead, the server MUST, for a period of time no less than that of the value of the lease_time attribute, maintain the client's delegations to allow time for the client to send CLAIM_DELEGATE_PREV and/or CLAIM_DELEG_PREV_FH requests. The server that supports CLAIM_DELEGATE_PREV and/or CLAIM_DELEG_PREV_FH MUST support the DELEGPURGE operation.",
      "ja": "サーバーはCLAIM_DELEGATE_PREVとCLAIM_DELEG_PREV_FHの請求タイプをサポートすることができ、それがない場合、それはEXCHANGE_IDによって作成されたクライアントIDを確認CREATE_SESSION時に代表団を削除してはなりません。代わりに、サーバは、lease_time属性の値よりも劣らず、一定期間、CLAIM_DELEGATE_PREVおよび/またはCLAIM_DELEG_PREV_FHリクエストを送信するために、クライアントのための時間を確保するために、クライアントの代表団を維持しなければなりません。 CLAIM_DELEGATE_PREVおよび/またはCLAIM_DELEG_PREV_FHをサポートするサーバーは、DELEGPURGE操作をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the server restarts, delegations are reclaimed (using the OPEN operation with CLAIM_PREVIOUS) in a similar fashion to byte-range locks and share reservations. However, there is a slight semantic difference. In the normal case, if the server decides that a delegation should not be granted, it performs the requested action (e.g., OPEN) without granting any delegation. For reclaim, the server grants the delegation but a special designation is applied so that the client treats the delegation as having been granted but recalled by the server. Because of this, the client has the duty to write all modified state to the server and then return the delegation. This process of handling delegation reclaim reconciles three principles of the NFSv4.1 protocol:",
      "ja": "サーバの再起動は、委任は、バイト範囲ロックと共有の予約と同様の方法で（CLAIM_PREVIOUSで開く操作を使用して）再生されたとき。しかし、わずかなセマンティック違いがあります。サーバは委任が許可されるべきではないと判断した場合、通常の場合、それは任意の委任を許可することなく、要求されたアクション（例えば、OPEN）を行います。再利用のために、サーバが委任を許可しますが、クライアントがサーバによって付与されたが、リコールされたものとして委任を扱うように、特別な指定が適用されます。このため、クライアントは、サーバーへのすべての変更された状態を書き込み、委任を返す義務があります。委任再利用を扱うこのプロセスは、NFSv4.1プロトコルの3つの原則を調和させます。"
    },
    {
      "indent": 3,
      "text": "o Upon reclaim, a client reporting resources assigned to it by an earlier server instance must be granted those resources.",
      "ja": "O再利用時には、以前のサーバインスタンスによってそれに割り当てられたリソースを報告するクライアントは、それらのリソースを付与する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The server has unquestionable authority to determine whether delegations are to be granted and, once granted, whether they are to be continued.",
      "ja": "Oサーバは、代表団は、かつて彼らが継続するかどうか、付与された、許可されたとされるようにしているかどうかを判断するために疑う余地のない権限を有しています。"
    },
    {
      "indent": 3,
      "text": "o The use of callbacks should not be depended upon until the client has proven its ability to receive them.",
      "ja": "クライアントがそれらを受信する能力を証明しているまで、Oコールバックの使用はに依存すべきではありません。"
    },
    {
      "indent": 3,
      "text": "When a client needs to reclaim a delegation and there is no associated open, the client may use the CLAIM_PREVIOUS variant of the WANT_DELEGATION operation. However, since the server is not required to support this operation, an alternative is to reclaim via a dummy OPEN together with the delegation using an OPEN of type CLAIM_PREVIOUS. The dummy open file can be released using a CLOSE to re-establish the original state to be reclaimed, a delegation without an associated open.",
      "ja": "クライアントが委任を再利用する必要があり、何の関連するオープンがない場合、クライアントはWANT_DELEGATION操作のCLAIM_PREVIOUSバリアントを使用することができます。サーバーがこの操作をサポートするために必要とされていないので、代替はタイプCLAIM_PREVIOUSのOPENを使用して代表団と一緒にダミーOPEN経由して再利用することです。ダミー開いているファイルは、関連するオープンせずに、委任を再利用するために再確立元の状態にCLOSEを使用して解放することができます。"
    },
    {
      "indent": 3,
      "text": "When a client has more than a single open associated with a delegation, state for those additional opens can be established using OPEN operations of type CLAIM_DELEGATE_CUR. When these are used to establish opens associated with reclaimed delegations, the server MUST allow them when made within the grace period.",
      "ja": "クライアントは、委任に関連した単一のオープンより多くを持っている場合は、追加のそれらのための状態は、型CLAIM_DELEGATE_CURのOPEN操作を使用して確立することができます開きます。これらは再利用の代表団に関連付け開き確立するために使用されている場合は、猶予期間内になされたときに、サーバーがそれらを許容しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a network partition occurs, delegations are subject to freeing by the server when the lease renewal period expires. This is similar to the behavior for locks and share reservations. For delegations, however, the server may extend the period in which conflicting requests are held off. Eventually, the occurrence of a conflicting request from another client will cause revocation of the delegation. A loss of the backchannel (e.g., by later network configuration change) will have the same effect. A recall request will fail and revocation of the delegation will result.",
      "ja": "ネットワークパーティションが発生した場合、代表団はリース更新期間が満了したときに、サーバによって解放の対象となっています。これは、ロックとシェアの予約のための動作に似ています。委譲のために、しかし、サーバは、競合する要求がオフに保持される期間を延長することができます。最終的には、別のクライアントから競合の要求の発生は委任の取消しの原因となります。 （後にネットワーク構成変更によって、例えば、）バックチャネルの損失は、同じ効果を有するであろう。リコール要求は失敗し、代表団の失効が発生します。"
    },
    {
      "indent": 3,
      "text": "A client normally finds out about revocation of a delegation when it uses a stateid associated with a delegation and receives one of the errors NFS4ERR_EXPIRED, NFS4ERR_ADMIN_REVOKED, or NFS4ERR_DELEG_REVOKED. It also may find out about delegation revocation after a client restart when it attempts to reclaim a delegation and receives that same error. Note that in the case of a revoked OPEN_DELEGATE_WRITE delegation, there are issues because data may have been modified by the client whose delegation is revoked and separately by other clients. See Section 10.5.1 for a discussion of such issues. Note also that when delegations are revoked, information about the revoked delegation will be written by the server to stable storage (as described in Section 8.4.3). This is done to deal with the case in which a server restarts after revoking a delegation but before the client holding the revoked delegation is notified about the revocation.",
      "ja": "それは代表団に関連付けられたstateidを使用すると、エラーNFS4ERR_EXPIRED、NFS4ERR_ADMIN_REVOKED、またはNFS4ERR_DELEG_REVOKEDのいずれかを受信したときに、クライアントは通常、委任の取消しについて見つけ出します。それは代表団を再利用しようとすると、同じエラーを受信した場合も、クライアントの再起動後に委任失効について調べることがあります。データはその代表団、他のクライアントによって個別に無効化され、クライアントによって変更された可能性があるため、失効OPEN_DELEGATE_WRITE委任の場合には、問題があることに注意してください。そのような問題の議論については、セクション10.5.1を参照してください。代表団が取り消されたときに（8.4.3項で説明したように）、取り消された代表団についての情報が安定したストレージにサーバーによって書き込まれることにも注意してください。これは、委任を取り消した後が、取り消された代表団を保持しているクライアントの前にサーバーの再起動が取消しについて通知された場合に対処するために行われます。"
    },
    {
      "indent": 0,
      "text": "10.3. Data Caching",
      "section_title": true,
      "ja": "10.3. データキャッシング"
    },
    {
      "indent": 3,
      "text": "When applications share access to a set of files, they need to be implemented so as to take account of the possibility of conflicting access by another application. This is true whether the applications in question execute on different clients or reside on the same client.",
      "ja": "ファイルのセットにアプリケーション共有アクセス、彼らは他のアプリケーションによるアクセスの競合の可能性を考慮するように実装する必要があります。これは、問題のアプリケーションは、異なるクライアント上で実行するか、同じクライアント上に存在するかどうか本当です。"
    },
    {
      "indent": 3,
      "text": "Share reservations and byte-range locks are the facilities the NFSv4.1 protocol provides to allow applications to coordinate access by using mutual exclusion facilities. The NFSv4.1 protocol's data caching must be implemented such that it does not invalidate the assumptions on which those using these facilities depend.",
      "ja": "共有の予約およびバイト範囲ロックはNFSv4.1プロトコルは、アプリケーションが相互排他設備を使用してアクセスを調整できるようにするために提供する機能です。 NFSv4.1プロトコルのデータのキャッシングは、これらの施設を利用したものが依存している仮定を無効にしないように実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.3.1. Data Caching and OPENs",
      "section_title": true,
      "ja": "10.3.1. データキャッシング、開きました"
    },
    {
      "indent": 3,
      "text": "In order to avoid invalidating the sharing assumptions on which applications rely, NFSv4.1 clients should not provide cached data to applications or modify it on behalf of an application when it would not be valid to obtain or modify that same data via a READ or WRITE operation.",
      "ja": "アプリケーションが依存している上で共有仮定を無効避けるために、NFSv4.1のクライアントは、アプリケーションにデータをキャッシュして提供してはならないか、入手またはREADを経由して、同じデータを変更したり、書き込むには有効ではないだろうというとき、アプリケーションに代わって、それを修正します操作。"
    },
    {
      "indent": 3,
      "text": "Furthermore, in the absence of an OPEN delegation (see Section 10.4), two additional rules apply. Note that these rules are obeyed in practice by many NFSv3 clients.",
      "ja": "さらに、OPEN代表団の不在（項10.4を参照）で、二つの追加の規則が適用されます。これらのルールは、多くのNFSv3のクライアントが実際に守られることに注意してください。"
    },
    {
      "indent": 3,
      "text": "o First, cached data present on a client must be revalidated after doing an OPEN. Revalidating means that the client fetches the change attribute from the server, compares it with the cached change attribute, and if different, declares the cached data (as well as the cached attributes) as invalid. This is to ensure that the data for the OPENed file is still correctly reflected in the client's cache. This validation must be done at least when the client's OPEN operation includes a deny of OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH, thus terminating a period in which other clients may have had the opportunity to open the file with OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH access. Clients may choose to do the revalidation more often (i.e., at OPENs specifying a deny mode of OPEN4_SHARE_DENY_NONE) to parallel the NFSv3 protocol's practice for the benefit of users assuming this degree of cache revalidation.",
      "ja": "Oまず、クライアント上に存在し、キャッシュされたデータは、OPENをやった後、再検証する必要があります。再検証は、クライアントが、サーバからの変化属性を取得し、キャッシュされた変化属性と比較し、異なる場合は、無効としてキャッシュされたデータ（同様にキャッシュされた属性）を宣言していることを意味します。これは、開いたファイルのデータがまだ正しくクライアントのキャッシュに反映されていることを確認することです。この検証は、クライアントのOPEN操作は、このように他のクライアントがOPEN4_SHARE_ACCESS_WRITE / OPEN4_SHARE_ACCESS_BOTHアクセスでファイルを開くための機会を持っていたかもしれ期間を終了し、OPEN4_SHARE_DENY_WRITEまたはOPEN4_SHARE_DENY_BOTHの拒否を含む少なくとも時に行われなければなりません。クライアントは、キャッシュ再検証のこの程度を想定し、ユーザーの利益のためにNFSv3のプロトコルの練習を並行して（すなわち、OPEN4_SHARE_DENY_NONEの拒否モードを指定のOPENs時）より頻繁に再検証を行うことを選択できます。"
    },
    {
      "indent": 6,
      "text": "Since the change attribute is updated for data and metadata modifications, some client implementors may be tempted to use the time_modify attribute and not the change attribute to validate cached data, so that metadata changes do not spuriously invalidate clean data. The implementor is cautioned in this approach. The change attribute is guaranteed to change for each update to the file, whereas time_modify is guaranteed to change only at the granularity of the time_delta attribute. Use by the client's data cache validation logic of time_modify and not change runs the risk of the client incorrectly marking stale data as valid. Thus, any cache validation approach by the client MUST include the use of the change attribute.",
      "ja": "変化属性は、データとメタデータの変更のために更新されているので、いくつかのクライアントの実装は、そのメタデータの変更が誤ってクリーンなデータが無効になることはありませんので、キャッシュされたデータを検証するためにtime_modify属性ではなく変化属性を使用するように誘惑することができます。実装者は、このアプローチに警告されています。 time_modifyがTIME_DELTA属性の粒度でのみ変更することが保証されているのに対し、変化属性は、ファイルへの更新ごとに変更することが保証されています。変更time_modifyのクライアントのデータ・キャッシュの検証ロジックで使用していないと、クライアントが誤って有効として古いデータをマーキングするリスクを実行します。このように、クライアントによる任意のキャッシュ・バリデーションアプローチは、変化属性を使用することを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Second, modified data must be flushed to the server before closing a file OPENed for OPEN4_SHARE_ACCESS_WRITE. This is complementary to the first rule. If the data is not flushed at CLOSE, the revalidation done after the client OPENs a file is unable to achieve its purpose. The other aspect to flushing the data before close is that the data must be committed to stable storage, at the server, before the CLOSE operation is requested by the client. In the case of a server restart and a CLOSEd file, it may not be possible to retransmit the data to be written to the file, hence, this requirement.",
      "ja": "O第二に、変更されたデータは、ファイルOPEN4_SHARE_ACCESS_WRITEのためにオープンを閉じる前に、サーバーにフラッシュする必要があります。これは最初のルールに相補的です。データはCLOSEでフラッシュされていない場合は、クライアントがファイルを開いた後に行う再検証は、その目的を達成することができません。クローズする前にデータをフラッシュする他の側面は、CLOSE操作がクライアントによって要求される前のデータは、サーバーで、安定したストレージにコミットしなければならないということです。サーバの再起動と閉じられたファイルの場合には、したがって、ファイルに書き込まれるデータを再送信するために、この要件可能ではないかもしれません。"
    },
    {
      "indent": 0,
      "text": "10.3.2. Data Caching and File Locking",
      "section_title": true,
      "ja": "10.3.2. データ・キャッシングとファイルロック"
    },
    {
      "indent": 3,
      "text": "For those applications that choose to use byte-range locking instead of share reservations to exclude inconsistent file access, there is an analogous set of constraints that apply to client-side data caching. These rules are effective only if the byte-range locking is used in a way that matches in an equivalent way the actual READ and WRITE operations executed. This is as opposed to byte-range locking that is based on pure convention. For example, it is possible to manipulate a two-megabyte file by dividing the file into two one-megabyte ranges and protecting access to the two byte-ranges by byte-range locks on bytes zero and one. A WRITE_LT lock on byte zero of the file would represent the right to perform READ and WRITE operations on the first byte-range. A WRITE_LT lock on byte one of the file would represent the right to perform READ and WRITE operations on the second byte-range. As long as all applications manipulating the file obey this convention, they will work on a local file system. However, they may not work with the NFSv4.1 protocol unless clients refrain from data caching.",
      "ja": "一貫性のないファイルへのアクセスを除外するために、代わりに株式の予約のバイト範囲ロックを使用することを選択し、それらのアプリケーションでは、クライアント側のデータキャッシュに適用される制約の類似したセットがあります。これらのルールは、バイト範囲ロックは、実際の読み出しおよび書き込み動作が実行される同等の方法で一致するように使用されている場合にのみ有効です。これは純粋な慣例に基づいてバイト範囲ロックのように対向しています。例えば、2つの1メガバイトの範囲にファイルを分割し、バイト0と1にバイト範囲ロックによって2バイト範囲へのアクセスを保護することにより、二メガバイトのファイルを操作することが可能です。ファイルのバイトゼロにWRITE_LTロックは最初のバイト範囲に読み取りおよび書き込み操作を実行する権利を表すことになります。ファイルのバイト一方WRITE_LTロックは、第二のバイト範囲に読み取りおよび書き込み操作を実行する権利を表すことになります。限り、ファイルを操作するすべてのアプリケーションがこの規則に従うように、彼らはローカルファイルシステム上で動作します。クライアントがデータ・キャッシングを控える場合を除きしかし、彼らはNFSv4.1プロトコルでは動作しない場合があります。"
    },
    {
      "indent": 3,
      "text": "The rules for data caching in the byte-range locking environment are:",
      "ja": "バイト範囲ロック環境でのデータのキャッシュのためのルールは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o First, when a client obtains a byte-range lock for a particular byte-range, the data cache corresponding to that byte-range (if any cache data exists) must be revalidated. If the change attribute indicates that the file may have been updated since the cached data was obtained, the client must flush or invalidate the cached data for the newly locked byte-range. A client might choose to invalidate all of the non-modified cached data that it has for the file, but the only requirement for correct operation is to invalidate all of the data in the newly locked byte-range.",
      "ja": "クライアントが特定のバイト範囲のバイト範囲ロックを取得した場合、Oまず、そのバイト範囲（任意のキャッシュデータが存在する場合）に対応するデータキャッシュが再検証されなければなりません。変化属性がキャッシュされたデータが得られたので、ファイルが更新された可能性があることを示している場合、クライアントは、新たにロックされたバイト範囲のキャッシュされたデータをフラッシュしたり無効化しなければなりません。クライアントは、ファイルのために持っている非改変キャッシュされたデータのすべてを無効にすることを選択するかもしれませんが、正しい操作のための唯一の要件は、新たにロックされたバイト範囲内のすべてのデータを無効にすることです。"
    },
    {
      "indent": 3,
      "text": "o Second, before releasing a WRITE_LT lock for a byte-range, all modified data for that byte-range must be flushed to the server. The modified data must also be written to stable storage.",
      "ja": "O第二に、バイト範囲のためのWRITE_LTのロックを解除する前に、そのバイト範囲のためのすべての変更されたデータをサーバーにフラッシュする必要があります。変更されたデータはまた、安定したストレージに書き込む必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that flushing data to the server and the invalidation of cached data must reflect the actual byte-ranges locked or unlocked. Rounding these up or down to reflect client cache block boundaries will cause problems if not carefully done. For example, writing a modified block when only half of that block is within an area being unlocked may cause invalid modification to the byte-range outside the unlocked area. This, in turn, may be part of a byte-range locked by another client. Clients can avoid this situation by synchronously performing portions of WRITE operations that overlap that portion (initial or final) that is not a full block. Similarly, invalidating a locked area that is not an integral number of full buffer blocks would require the client to read one or two partial blocks from the server if the revalidation procedure shows that the data that the client possesses may not be valid.",
      "ja": "サーバとキャッシュされたデータの無効化へデータをフラッシュすると、実際のバイト範囲ロックまたはロック解除を反映しなければならないことに注意してください。注意深く行われていない場合は、クライアントのキャッシュ・ブロックの境界を反映するためにダウンこれらを丸めたりすると、問題が発生します。例えば、修飾されたブロックを書き込むと、そのブロックの半分だけがロック解除された領域外バイト範囲に無効な変形を引き起こす可能性がアンロックされるエリア内にある場合。これは、順番に、別のクライアントによってロックバイト範囲の一部であってもよいです。クライアントは同期満杯ブロックでない部分（初期または最終）を重複WRITE動作の部分を実行することによってこの状況を回避することができます。再検証手順は、クライアントが保有するデータが有効ではないかもしれないことを示す場合同様、フルバッファブロックの整数倍ではないロックされた領域を無効にすると、サーバーから一つまたは二つの部分ブロックを読み取るためにクライアントが必要となります。"
    },
    {
      "indent": 3,
      "text": "The data that is written to the server as a prerequisite to the unlocking of a byte-range must be written, at the server, to stable storage. The client may accomplish this either with synchronous writes or by following asynchronous writes with a COMMIT operation. This is required because retransmission of the modified data after a server restart might conflict with a lock held by another client.",
      "ja": "バイト範囲のロック解除の前提条件としてサーバに書き込まれたデータは、安定したストレージに、サーバに書き込まれなければなりません。クライアントは同期書き込みまたはCOMMIT操作で非同期書き込みを、次のいずれかによって、これを達成することができます。サーバの再起動後に変更されたデータの再送信は、別のクライアントによって保持されたロックと競合する可能性がありますので、これが必要です。"
    },
    {
      "indent": 3,
      "text": "A client implementation may choose to accommodate applications that use byte-range locking in non-standard ways (e.g., using a byte-range lock as a global semaphore) by flushing to the server more data upon a LOCKU than is covered by the locked range. This may include modified data within files other than the one for which the unlocks are being done. In such cases, the client must not interfere with applications whose READs and WRITEs are being done only within the bounds of byte-range locks that the application holds. For example, an application locks a single byte of a file and proceeds to write that single byte. A client that chose to handle a LOCKU by flushing all modified data to the server could validly write that single byte in response to an unrelated LOCKU operation. However, it would not be valid to write the entire block in which that single written byte was located since it includes an area that is not locked and might be locked by another client. Client implementations can avoid this problem by dividing files with modified data into those for which all modifications are done to areas covered by an appropriate byte-range lock and those for which there are modifications not covered by a byte-range lock. Any writes done for the former class of files must not include areas not locked and thus not modified on the client.",
      "ja": "クライアントの実装では、非標準的な方法でバイト範囲ロックを使用するアプリケーションに対応することもできます（例えば、グローバルセマフォとしてバイト範囲ロックを使用して）ロックされた範囲で覆われているよりも、LOCKU時にサーバーにデータをフラッシュすることにより、 。これは、アンロックが行われているために1以外のファイル内で変更されたデータを含むことができます。このような場合には、クライアントは、その読み込みと書き込みのみアプリケーションが保持しているバイト範囲ロックの範囲内で行われているアプリケーションを妨害してはなりません。例えば、アプリケーションは、ファイルの単一のバイトをロックし、その単一バイトの書き込みに進みます。サーバーへのすべての変更されたデータをフラッシュしてLOCKUを処理するために選択したクライアントが有効に無関係LOCKUの操作に応じて、その1バイトを書くことができます。しかし、ロックされていないと別のクライアントによってロックされるかもしれない領域を含むので、その単一書かれたバイトが配置されたブロック全体を書き込むことが有効ではありません。クライアントの実装は、すべての変更が適切なバイト範囲ロックとバイト範囲ロックによって覆われていない変更があるれるものによってカバーされる領域に行われているため、それらに変更されたデータのファイルを分割することによってこの問題を回避することができます。ファイルの元のクラスに行って、任意の書き込みは、領域がロックされていないため、クライアント上で変更されていない含めることはできません。"
    },
    {
      "indent": 0,
      "text": "10.3.3. Data Caching and Mandatory File Locking",
      "section_title": true,
      "ja": "10.3.3. データ・キャッシングと強制ファイルロック"
    },
    {
      "indent": 3,
      "text": "Client-side data caching needs to respect mandatory byte-range locking when it is in effect. The presence of mandatory byte-range locking for a given file is indicated when the client gets back NFS4ERR_LOCKED from a READ or WRITE operation on a file for which it has an appropriate share reservation. When mandatory locking is in effect for a file, the client must check for an appropriate byte-range lock for data being read or written. If a byte-range lock exists for the range being read or written, the client may satisfy the request using the client's validated cache. If an appropriate byte-range lock is not held for the range of the read or write, the read or write request must not be satisfied by the client's cache and the request must be sent to the server for processing. When a read or write request partially overlaps a locked byte-range, the request should be subdivided into multiple pieces with each byte-range (locked or not) treated appropriately.",
      "ja": "クライアント側データ・キャッシングは、それが有効である場合は必須バイト範囲ロックを尊重する必要があります。クライアントは、それが適切な共有の予約を持っているファイルに対してREADまたはWRITE動作からNFS4ERR_LOCKEDバック取得したときに与えられたファイルのための必須のバイト範囲ロックの存在が示されています。強制ロックは、ファイルのために有効な場合、クライアントは、読み取りまたは書き込み中のデータのための適切なバイト範囲ロックをチェックする必要があります。バイト範囲ロックが読み取りまたは書き込まれている範囲に存在する場合、クライアントは、クライアントの検証キャッシュを使用して要求を満たすようにしてもよいです。適切なバイト範囲ロックは、読み取りの範囲で保有または書き込み、読み取りまたは書き込み要求されていない場合は、クライアントのキャッシュによって満たされなければならないと要求を処理するためにサーバーに送信する必要があります。読み取りまたは書き込み要求が部分的にロックされたバイト範囲と重なる場合、要求が適切に処理各バイト範囲（ロックまたはしない）を有する複数の部分に細分されるべきです。"
    },
    {
      "indent": 0,
      "text": "10.3.4. Data Caching and File Identity",
      "section_title": true,
      "ja": "10.3.4. データキャッシングとファイルアイデンティティ"
    },
    {
      "indent": 3,
      "text": "When clients cache data, the file data needs to be organized according to the file system object to which the data belongs. For NFSv3 clients, the typical practice has been to assume for the purpose of caching that distinct filehandles represent distinct file system objects. The client then has the choice to organize and maintain the data cache on this basis.",
      "ja": "クライアントがデータをキャッシュすると、ファイルデータは、データが属するファイルシステムオブジェクトに応じて整理する必要があります。 NFSv3のクライアントの場合、典型的な練習は、異なるファイルハンドルが別個のファイル・システム・オブジェクトを表すキャッシングの目的のために仮定することでした。その後、クライアントはこれに基づいてデータキャッシュを整理し、維持するための選択肢を持っています。"
    },
    {
      "indent": 3,
      "text": "In the NFSv4.1 protocol, there is now the possibility to have significant deviations from a \"one filehandle per object\" model because a filehandle may be constructed on the basis of the object's pathname. Therefore, clients need a reliable method to determine if two filehandles designate the same file system object. If clients were simply to assume that all distinct filehandles denote distinct objects and proceed to do data caching on this basis, caching inconsistencies would arise between the distinct client-side objects that mapped to the same server-side object.",
      "ja": "ファイルハンドルは、オブジェクトのパス名に基づいて構築することができるので、NFSv4.1プロトコルでは、「1つのファイルハンドルオブジェクトごとに」モデルから大幅に逸脱を持っている可能性が今そこにあります。したがって、クライアントは、二つのファイルハンドルが同じファイル・システム・オブジェクトを指定する場合に信頼性の高い方法を決定する必要があります。クライアントは単純にすべての個別のファイルハンドルが別個のオブジェクトを表すことを前提とし、これに基づいてデータのキャッシュを行うに進みした場合、キャッシュの不整合は、同じサーバー側オブジェクトにマッピングされた個別のクライアント側のオブジェクト間で生じるであろう。"
    },
    {
      "indent": 3,
      "text": "By providing a method to differentiate filehandles, the NFSv4.1 protocol alleviates a potential functional regression in comparison with the NFSv3 protocol. Without this method, caching inconsistencies within the same client could occur, and this has not been present in previous versions of the NFS protocol. Note that it is possible to have such inconsistencies with applications executing on multiple clients, but that is not the issue being addressed here.",
      "ja": "ファイルハンドルを区別するための方法を提供することによって、NFSv4.1プロトコルはNFSv3のプロトコルと比較して潜在的な機能的回帰を緩和します。この方法がなければ、同じクライアント内のキャッシュの不整合が発生する可能性があり、これは、NFSプロトコルの以前のバージョンに存在していませんでした。複数のクライアント上で実行するアプリケーションで、このような矛盾を持つことが可能であるが、それはここで扱われている問題ではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "For the purposes of data caching, the following steps allow an NFSv4.1 client to determine whether two distinct filehandles denote the same server-side object:",
      "ja": "データキャッシュの目的のために、次の手順は、NFSv4.1クライアントは、2つの別個のファイルハンドルが同じサーバ側のオブジェクトを表すかどうかを決定することを可能にします。"
    },
    {
      "indent": 3,
      "text": "o If GETATTR directed to two filehandles returns different values of the fsid attribute, then the filehandles represent distinct objects.",
      "ja": "GETATTRは、2つのファイルハンドルに向けFSID属性の異なる値を返す場合、O、次にファイルハンドルは、異なるオブジェクトを表します。"
    },
    {
      "indent": 3,
      "text": "o If GETATTR for any file with an fsid that matches the fsid of the two filehandles in question returns a unique_handles attribute with a value of TRUE, then the two objects are distinct.",
      "ja": "問題の2つのファイルハンドルのFSIDと一致するFSIDを持つ任意のファイルのGETATTRがunique_handlesがTRUEの値を持つ属性を返した場合、O、その後、2つのオブジェクトが異なっています。"
    },
    {
      "indent": 3,
      "text": "o If GETATTR directed to the two filehandles does not return the fileid attribute for both of the handles, then it cannot be determined whether the two objects are the same. Therefore, operations that depend on that knowledge (e.g., client-side data caching) cannot be done reliably. Note that if GETATTR does not return the fileid attribute for both filehandles, it will return it for neither of the filehandles, since the fsid for both filehandles is the same.",
      "ja": "GETATTRは、2つのファイルハンドルに向けられた場合、Oハンドルの両方のためFILEID属性を返さない、2つのオブジェクトが同一であるか否かを判断することはできません。したがって、その知識に依存する操作（例えば、クライアント側データ・キャッシング）を確実に行うことができません。 GETATTRは、両方のファイルハンドル用FILEID属性を返さない場合は、両方のファイルハンドルのためのfsidが同じであるため、それは、ファイルハンドルのどちらのためにそれを返すことに注意してください。"
    },
    {
      "indent": 3,
      "text": "o If GETATTR directed to the two filehandles returns different values for the fileid attribute, then they are distinct objects.",
      "ja": "GETATTRは、2つのファイルハンドルに向けFILEID属性の異なる値を返す場合、O、それらは別個のオブジェクトです。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, they are the same object.",
      "ja": "Oそれ以外の場合は、同じオブジェクトです。"
    },
    {
      "indent": 0,
      "text": "10.4. Open Delegation",
      "section_title": true,
      "ja": "10.4. オープン委任"
    },
    {
      "indent": 3,
      "text": "When a file is being OPENed, the server may delegate further handling of opens and closes for that file to the opening client. Any such delegation is recallable since the circumstances that allowed for the delegation are subject to change. In particular, if the server receives a conflicting OPEN from another client, the server must recall the delegation before deciding whether the OPEN from the other client may be granted. Making a delegation is up to the server, and clients should not assume that any particular OPEN either will or will not result in an OPEN delegation. The following is a typical set of conditions that servers might use in deciding whether an OPEN should be delegated:",
      "ja": "ファイルが開かれている場合は、サーバーがオープンのさらなる取り扱いを委任し、開口部クライアントにそのファイルを閉じて。委任に対して許可状況が変更される場合がありますので、任意のそのような委任はリコールです。サーバが別のクライアントから競合OPENを受信した場合、特に、サーバは、他のクライアントからのOPENを付与することができるかどうかを決定する前に委任を思い出す必要があります。委任を作ることは、サーバー次第です、とクライアントがどちらかのいずれかの特定のOPENがまたはOPEN委任にはなりませんだろうと想定してはいけません。以下は、サーバーがOPENを委任する必要があるかどうかを決定する際に使用する可能性のある条件の典型的なセットです。"
    },
    {
      "indent": 3,
      "text": "o The client must be able to respond to the server's callback requests. If a backchannel has been established, the server will send a CB_COMPOUND request, containing a single operation, CB_SEQUENCE, for a test of backchannel availability.",
      "ja": "Oクライアントは、サーバーのコールバック要求に応答できなければなりません。バックチャネルが確立されている場合、サーバーは、バックチャネル可用性のテストのために、単一の操作、CB_SEQUENCEを含む、CB_COMPOUND要求を送信します。"
    },
    {
      "indent": 3,
      "text": "o The client must have responded properly to previous recalls.",
      "ja": "Oクライアントは、以前のリコールに適切に対応している必要があります。"
    },
    {
      "indent": 3,
      "text": "o There must be no current OPEN conflicting with the requested delegation.",
      "ja": "O要求された代表団とは、現在のOPEN矛盾があってはいけません。"
    },
    {
      "indent": 3,
      "text": "o There should be no current delegation that conflicts with the delegation being requested.",
      "ja": "O委任が要求されていると競合するどんな現在の代表団があってはなりません。"
    },
    {
      "indent": 3,
      "text": "o The probability of future conflicting open requests should be low based on the recent history of the file.",
      "ja": "Oオープン要求が競合し、将来の確率が低いファイルの最近の履歴に基づくべきです。"
    },
    {
      "indent": 3,
      "text": "o The existence of any server-specific semantics of OPEN/CLOSE that would make the required handling incompatible with the prescribed handling that the delegated client would apply (see below).",
      "ja": "必要な規定の委任クライアントが適用されることを扱うと互換性の取り扱いになるだろうOPEN / CLOSEの任意のサーバ固有の意味の存在O（下記参照）。"
    },
    {
      "indent": 3,
      "text": "There are two types of OPEN delegations: OPEN_DELEGATE_READ and OPEN_DELEGATE_WRITE. An OPEN_DELEGATE_READ delegation allows a client to handle, on its own, requests to open a file for reading that do not deny OPEN4_SHARE_ACCESS_READ access to others. Multiple",
      "ja": "OPEN_DELEGATE_READとOPEN_DELEGATE_WRITE：OPEN代表団の2種類があります。 OPEN_DELEGATE_READ代表団は、他の人にOPEN4_SHARE_ACCESS_READのアクセスを拒否していない読書のためのファイルを開くには、独自の、要求に、クライアントが処理することができます。複数"
    },
    {
      "indent": 3,
      "text": "OPEN_DELEGATE_READ delegations may be outstanding simultaneously and do not conflict. An OPEN_DELEGATE_WRITE delegation allows the client to handle, on its own, all opens. Only OPEN_DELEGATE_WRITE delegation may exist for a given file at a given time, and it is inconsistent with any OPEN_DELEGATE_READ delegations.",
      "ja": "OPEN_DELEGATE_READの代表団は、同時に優れたことと競合しないことがあります。 OPEN_DELEGATE_WRITE代表団が独自に、クライアントが処理することができ、すべてが表示されます。唯一のOPEN_DELEGATE_WRITE代表団は、与えられた時間に指定したファイルの存在する可能性がある、そしてそれはどのOPEN_DELEGATE_READ代表団と矛盾しています。"
    },
    {
      "indent": 3,
      "text": "When a client has an OPEN_DELEGATE_READ delegation, it is assured that neither the contents, the attributes (with the exception of time_access), nor the names of any links to the file will change without its knowledge, so long as the delegation is held. When a client has an OPEN_DELEGATE_WRITE delegation, it may modify the file data locally since no other client will be accessing the file's data. The client holding an OPEN_DELEGATE_WRITE delegation may only locally affect file attributes that are intimately connected with the file data: size, change, time_access, time_metadata, and time_modify. All other attributes must be reflected on the server.",
      "ja": "クライアントがOPEN_DELEGATE_READ委任を持っている場合は、内容、（time_accessを除く）の属性、またファイルへのリンクの名前でもない限り、委任が保持されているように、その知識なしに変更になることが保証されます。クライアントがOPEN_DELEGATE_WRITE委任がある場合、他のクライアントがファイルのデータにアクセスできなくなりますので、ローカルファイルのデータを変更することができます。サイズ、変更、time_access、time_metadata、およびtime_modify：OPEN_DELEGATE_WRITE委任を保持しているクライアントは、ローカルでのみ密接ファイルデータに接続されているファイルの属性に影響を与える可能性があります。他のすべての属性は、サーバー上に反映されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a client has an OPEN delegation, it does not need to send OPENs or CLOSEs to the server. Instead, the client may update the appropriate status internally. For an OPEN_DELEGATE_READ delegation, opens that cannot be handled locally (opens that are for OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH or that deny OPEN4_SHARE_ACCESS_READ access) must be sent to the server.",
      "ja": "クライアントがOPEN委任を持っているときは、サーバーに開閉するを送信する必要はありません。代わりに、クライアントは内部で適切なステータスを更新することができます。 OPEN_DELEGATE_READ代表団のために、それはローカルで処理することができません開き、サーバに送信する必要があります（OPEN4_SHARE_ACCESS_WRITE / OPEN4_SHARE_ACCESS_BOTHのためのものであるか、それがOPEN4_SHARE_ACCESS_READアクセスを拒否しているが開きます）。"
    },
    {
      "indent": 3,
      "text": "When an OPEN delegation is made, the reply to the OPEN contains an OPEN delegation structure that specifies the following:",
      "ja": "OPEN委譲が行われると、OPENへの回答は次のように指定するOPEN委任構造が含まれています。"
    },
    {
      "indent": 3,
      "text": "o the type of delegation (OPEN_DELEGATE_READ or OPEN_DELEGATE_WRITE).",
      "ja": "O委任の種類（OPEN_DELEGATE_READまたはOPEN_DELEGATE_WRITE）。"
    },
    {
      "indent": 3,
      "text": "o space limitation information to control flushing of data on close (OPEN_DELEGATE_WRITE delegation only; see Section 10.4.1)",
      "ja": "O近い上のデータのフラッシングを制御する空間制限情報（のみOPEN_DELEGATE_WRITE委任を、第10.4.1項を参照）"
    },
    {
      "indent": 3,
      "text": "o an nfsace4 specifying read and write permissions",
      "ja": "読み取りおよび書き込み権限を指定nfsace4 O"
    },
    {
      "indent": 3,
      "text": "o a stateid to represent the delegation",
      "ja": "委任を表現するためのstateid O"
    },
    {
      "indent": 3,
      "text": "The delegation stateid is separate and distinct from the stateid for the OPEN proper. The standard stateid, unlike the delegation stateid, is associated with a particular lock-owner and will continue to be valid after the delegation is recalled and the file remains open.",
      "ja": "委任のstateidはOPEN適切ためのstateidから独立した別個です。標準のstateidは、委任のstateidとは異なり、特定のロック所有者に関連付けられているし、委任がリコールされた後に有効であり続けるであろうと、ファイルは開いたままになります。"
    },
    {
      "indent": 3,
      "text": "When a request internal to the client is made to open a file and an OPEN delegation is in effect, it will be accepted or rejected solely on the basis of the following conditions. Any requirement for other checks to be made by the delegate should result in the OPEN delegation being denied so that the checks can be made by the server itself.",
      "ja": "クライアントへの内部要求がファイルを開くために作られたとOPEN委任が有効になっているされている場合、それは単に、以下の条件に基づいて承認または拒否されます。チェックはサーバ自体によって行うことができるように、デリゲートによってなされる他のチェックのためにどのような要件が拒否さOPEN委任を生じるはずです。"
    },
    {
      "indent": 3,
      "text": "o The access and deny bits for the request and the file as described in Section 9.7.",
      "ja": "アクセスoおよび第9.7節に記載されるように要求し、ファイルのビットを否定します。"
    },
    {
      "indent": 3,
      "text": "o The read and write permissions as determined below.",
      "ja": "読み取りおよび書き込み権限O以下決定されます。"
    },
    {
      "indent": 3,
      "text": "The nfsace4 passed with delegation can be used to avoid frequent ACCESS calls. The permission check should be as follows:",
      "ja": "代表団に渡さnfsace4は、頻繁にアクセス呼び出しを回避するために使用することができます。次のようにパーミッションチェックは次のようになります。"
    },
    {
      "indent": 3,
      "text": "o If the nfsace4 indicates that the open may be done, then it should be granted without reference to the server.",
      "ja": "O nfsace4は、それがサーバーを参照することなく付与されなければならない、オープンを行うことができることを示している場合。"
    },
    {
      "indent": 3,
      "text": "o If the nfsace4 indicates that the open may not be done, then an ACCESS request must be sent to the server to obtain the definitive answer.",
      "ja": "nfsace4がオープンが行われない可能性があることを示した場合は、O、その後、アクセス要求は、決定的な答えを得るために、サーバーに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The server may return an nfsace4 that is more restrictive than the actual ACL of the file. This includes an nfsace4 that specifies denial of all access. Note that some common practices such as mapping the traditional user \"root\" to the user \"nobody\" (see Section 5.9) may make it incorrect to return the actual ACL of the file in the delegation response.",
      "ja": "サーバーは、ファイルの実際のACLよりも制限さnfsace4を返すことがあります。これは、すべてのアクセスの拒否を指定nfsace4が含まれています。こうしたユーザー「誰」に伝統的なユーザー「root」をマッピングするなど、いくつかの一般的な慣行が（5.9節を参照）、それは間違った委任応じて、ファイルの実際のACLを返すように作ることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The use of a delegation together with various other forms of caching creates the possibility that no server authentication and authorization will ever be performed for a given user since all of the user's requests might be satisfied locally. Where the client is depending on the server for authentication and authorization, the client should be sure authentication and authorization occurs for each user by use of the ACCESS operation. This should be the case even if an ACCESS operation would not be required otherwise. As mentioned before, the server may enforce frequent authentication by returning an nfsace4 denying all access with every OPEN delegation.",
      "ja": "キャッシングの様々な他の形態と一緒に委任の使用は、ユーザーのすべての要求をローカルに満足されることがありますので、何のサーバ認証と承認はこれまで、特定のユーザーのために実行されません可能性が作成されます。クライアントは、認証および承認のためのサーバに依存されている場合、クライアントは、認証と認可がアクセス動作を使用することによって、ユーザーごとに発生したことを確認する必要があります。これは、アクセス動作がそうでなければ必要とされない場合でも同様である必要があります。前に述べたように、サーバーはすべてのOPEN代表団とのすべてのアクセスを拒否nfsace4を返すことによって、頻繁に認証を強制することがあります。"
    },
    {
      "indent": 0,
      "text": "10.4.1. Open Delegation and Data Caching",
      "section_title": true,
      "ja": "10.4.1. オープン委任およびデータキャッシング"
    },
    {
      "indent": 3,
      "text": "An OPEN delegation allows much of the message overhead associated with the opening and closing files to be eliminated. An open when an OPEN delegation is in effect does not require that a validation message be sent to the server. The continued endurance of the \"OPEN_DELEGATE_READ delegation\" provides a guarantee that no OPEN for OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH, and thus no write, has occurred. Similarly, when closing a file opened for OPEN4_SHARE_ACCESS_WRITE/OPEN4_SHARE_ACCESS_BOTH and if an OPEN_DELEGATE_WRITE delegation is in effect, the data written does not have to be written to the server until the OPEN delegation is recalled. The continued endurance of the OPEN delegation provides a guarantee that no open, and thus no READ or WRITE, has been done by another client.",
      "ja": "OPEN代表団は、ファイルを開いたり閉じ関連付けられているメッセージオーバーヘッドの多くは解消することができます。 OPEN委任が有効になっているオープンは、検証メッセージをサーバーに送信する必要はありません。 「OPEN_DELEGATE_READ委任」の継続的な耐久性はOPEN4_SHARE_ACCESS_WRITE / OPEN4_SHARE_ACCESS_BOTHにはOPENので、ノー書き込みは、発生していないという保証を提供します。同様に、ファイルを閉じるときには、OPEN4_SHARE_ACCESS_WRITE / OPEN4_SHARE_ACCESS_BOTHのために開かれ、OPEN_DELEGATE_WRITE委任が有効である場合、書き込まれたデータは、OPEN委任がリコールされるまでサーバーに書き込まれている必要はありません。 OPEN委任の継続的な耐久性にはオープン、ひいてはなしREADまたはWRITEは、別のクライアントによって行われていないという保証を提供します。"
    },
    {
      "indent": 3,
      "text": "For the purposes of OPEN delegation, READs and WRITEs done without an OPEN are treated as the functional equivalents of a corresponding type of OPEN. Although a client SHOULD NOT use special stateids when an open exists, delegation handling on the server can use the client ID associated with the current session to determine if the operation has been done by the holder of the delegation (in which case, no recall is necessary) or by another client (in which case, the delegation must be recalled and I/O not proceed until the delegation is recalled or revoked).",
      "ja": "OPEN委任の目的のために、読み取り、OPENなく行わ書き込みがOPENの対応するタイプの機能的等価物として扱われます。クライアントは、オープンが存在する場合、サーバー上で処理する委譲操作が、その場合には（代表団の所有者によって行われているかどうかを判断するために、現在のセッションに関連付けられたクライアントIDを使用することができる特別なのstateidsを使用しませんが、何のリコールではありません必要に応じて）、または他のクライアント（その場合には、代表団がリコールされなければならないと委任がリコールまたは取り消されるまでのI / O進まない）によります。"
    },
    {
      "indent": 3,
      "text": "With delegations, a client is able to avoid writing data to the server when the CLOSE of a file is serviced. The file close system call is the usual point at which the client is notified of a lack of stable storage for the modified file data generated by the application. At the close, file data is written to the server and, through normal accounting, the server is able to determine if the available file system space for the data has been exceeded (i.e., the server returns NFS4ERR_NOSPC or NFS4ERR_DQUOT). This accounting includes quotas. The introduction of delegations requires that an alternative method be in place for the same type of communication to occur between client and server.",
      "ja": "代表団では、クライアントは、ファイルのCLOSEがサービスされているサーバへのデータの書き込みを避けることができます。ファイルクローズシステムコールは、クライアントがアプリケーションによって生成された変更されたファイルデータの保存安定性の不足が通知される通常のポイントです。 （すなわち、サーバはNFS4ERR_NOSPC又はNFS4ERR_DQUOTを返す）近くで、ファイルデータがサーバーに書き込まれると、データのために利用可能なファイル・システム・スペースを超えている場合、通常の課金を介して、サーバが決定することができます。この会計は、クォータが含まれています。代表団の導入は、別の方法は、クライアントとサーバーの間で発生する通信の同じタイプのための場所であることが必要です。"
    },
    {
      "indent": 3,
      "text": "In the delegation response, the server provides either the limit of the size of the file or the number of modified blocks and associated block size. The server must ensure that the client will be able to write modified data to the server of a size equal to that provided in the original delegation. The server must make this assurance for all outstanding delegations. Therefore, the server must be careful in its management of available space for new or modified data, taking into account available file system space and any applicable quotas. The server can recall delegations as a result of managing the available file system space. The client should abide by the server's state space limits for delegations. If the client exceeds the stated limits for the delegation, the server's behavior is undefined.",
      "ja": "委任応答して、サーバは、ファイルまたは変更されたブロックの数と関連したブロックサイズの大きさの制限のいずれかを提供します。サーバーは、クライアントが、元代表団に提供されるものに等しいサイズのサーバに変更されたデータを書き込むことができるようになることを確認する必要があります。サーバーはすべての未処理の代表団のために、この保証をしなければなりません。そのため、サーバは、アカウントに使用可能なファイルシステムスペースおよび適用クォータを取って、新規または変更されたデータのために利用可能なスペースの経営で注意しなければなりません。サーバーは、使用可能なファイルシステム領域の管理の結果として、代表団を思い出すことができます。クライアントは、代表団のために、サーバの状態空間の制限を遵守しなければなりません。クライアントは、委譲のために述べた制限を超えた場合は、サーバーの動作は未定義です。"
    },
    {
      "indent": 3,
      "text": "Based on server conditions, quotas, or available file system space, the server may grant OPEN_DELEGATE_WRITE delegations with very restrictive space limitations. The limitations may be defined in a way that will always force modified data to be flushed to the server on close.",
      "ja": "サーバーの状況、クォータ、または使用可能なファイル・システム・スペースに基づいて、サーバーは非常に制限的スペースの制約でOPEN_DELEGATE_WRITE代表団を付与することができます。制限は、常に近くにサーバーにフラッシュされるように変更されたデータを強制する方法で定義することができます。"
    },
    {
      "indent": 3,
      "text": "With respect to authentication, flushing modified data to the server after a CLOSE has occurred may be problematic. For example, the user of the application may have logged off the client, and unexpired authentication credentials may not be present. In this case, the client may need to take special care to ensure that local unexpired credentials will in fact be available. This may be accomplished by tracking the expiration time of credentials and flushing data well in advance of their expiration or by making private copies of credentials to assure their availability when needed.",
      "ja": "認証に関しては、CLOSEが発生した後、サーバーに変更されたデータをフラッシュすることは問題となり得ます。たとえば、アプリケーションのユーザは、クライアントがログオフしていること、および有効期限内の認証資格情報は存在しないかもしれません。この場合、クライアントは、ローカルの期限が切れていない証明書が実際に利用可能になることを保証するために特別な注意を払う必要があるかもしれません。これは、資格証明書の有効期限を追跡し、その有効期限の事前にデータをフラッシュするか、必要なときに自分の可用性を保証するために資格のプライベートコピーを作成することによって達成することができます。"
    },
    {
      "indent": 0,
      "text": "10.4.2. Open Delegation and File Locks",
      "section_title": true,
      "ja": "10.4.2. 開いている委譲とファイルロック"
    },
    {
      "indent": 3,
      "text": "When a client holds an OPEN_DELEGATE_WRITE delegation, lock operations are performed locally. This includes those required for mandatory byte-range locking. This can be done since the delegation implies that there can be no conflicting locks. Similarly, all of the revalidations that would normally be associated with obtaining locks and the flushing of data associated with the releasing of locks need not be done.",
      "ja": "クライアントがOPEN_DELEGATE_WRITE委任を保持している場合は、ロック操作がローカルで実行されています。これは必須のバイト範囲ロックのために必要なものを含みます。代表団は、競合するロックがないことを意味するので、これは行うことができます。同様に、通常は入手ロックとロックの解除に関連したデータのフラッシュに関連付けられる再確認のすべてが行われる必要がありません。"
    },
    {
      "indent": 3,
      "text": "When a client holds an OPEN_DELEGATE_READ delegation, lock operations are not performed locally. All lock operations, including those requesting non-exclusive locks, are sent to the server for resolution.",
      "ja": "クライアントがOPEN_DELEGATE_READ委任を保持している場合は、ロックの操作はローカルで実行されていません。非排他的ロックを要求するものも含め、すべてのロック操作は、解決のためにサーバに送信されます。"
    },
    {
      "indent": 0,
      "text": "10.4.3. Handling of CB_GETATTR",
      "section_title": true,
      "ja": "10.4.3.  CB_GETATTRの取り扱い"
    },
    {
      "indent": 3,
      "text": "The server needs to employ special handling for a GETATTR where the target is a file that has an OPEN_DELEGATE_WRITE delegation in effect. The reason for this is that the client holding the OPEN_DELEGATE_WRITE delegation may have modified the data, and the server needs to reflect this change to the second client that submitted the GETATTR. Therefore, the client holding the OPEN_DELEGATE_WRITE delegation needs to be interrogated. The server will use the CB_GETATTR operation. The only attributes that the server can reliably query via CB_GETATTR are size and change.",
      "ja": "サーバーは、ターゲットが有効でOPEN_DELEGATE_WRITE委任を持つファイルであるGETATTRのための特別な処理を採用する必要があります。この理由は、OPEN_DELEGATE_WRITEの委任を保持しているクライアントがデータを変更したこと、およびサーバーがGETATTRを提出した2番目のクライアントにこの変更を反映する必要があるということです。したがって、OPEN_DELEGATE_WRITE委任を保持しているクライアントは、尋問する必要があります。サーバーはCB_GETATTR操作を使用します。唯一のサーバが確実にサイズと変更されているCB_GETATTR経由で照会することができることを属性。"
    },
    {
      "indent": 3,
      "text": "Since CB_GETATTR is being used to satisfy another client's GETATTR request, the server only needs to know if the client holding the delegation has a modified version of the file. If the client's copy of the delegated file is not modified (data or size), the server can satisfy the second client's GETATTR request from the attributes stored locally at the server. If the file is modified, the server only needs to know about this modified state. If the server determines that the file is currently modified, it will respond to the second client's GETATTR as if the file had been modified locally at the server.",
      "ja": "CB_GETATTRは、別のクライアントのGETATTR要求を満たすために使用されているので、サーバは委任を保持しているクライアントは、ファイルの修正バージョンを持っているかどうかを知る必要があります。委任ファイルのクライアントのコピーが（データまたはサイズ）に変更されていない場合、サーバは、サーバにローカルに保存された属性から2番目のクライアントのGETATTR要求を満たすことができます。ファイルが変更されている場合は、サーバーにのみ、この修正された状態について知る必要があります。サーバーは、ファイルが現在変更されていると判断した場合は、ファイルをサーバーでローカルに変更されたかのように、それは2番目のクライアントのGETATTRに応答します。"
    },
    {
      "indent": 3,
      "text": "Since the form of the change attribute is determined by the server and is opaque to the client, the client and server need to agree on a method of communicating the modified state of the file. For the size attribute, the client will report its current view of the file size. For the change attribute, the handling is more involved.",
      "ja": "変化属性の形式は、サーバによって決定され、クライアントに不透明であるされているので、クライアントとサーバーは、ファイルの変更された状態を通信する方法に同意する必要があります。サイズ属性の場合、クライアントは、ファイルサイズの現在の見解を報告します。変化属性の場合、取り扱いはより複雑です。"
    },
    {
      "indent": 3,
      "text": "For the client, the following steps will be taken when receiving an OPEN_DELEGATE_WRITE delegation:",
      "ja": "OPEN_DELEGATE_WRITE委任を受けたときに、クライアントの場合は、以下のステップが行われます："
    },
    {
      "indent": 3,
      "text": "o The value of the change attribute will be obtained from the server and cached. Let this value be represented by c.",
      "ja": "O変化属性の値は、サーバーから取得し、キャッシュされます。この値はcで表すことがしてみましょう。"
    },
    {
      "indent": 3,
      "text": "o The client will create a value greater than c that will be used for communicating that modified data is held at the client. Let this value be represented by d.",
      "ja": "Oクライアントは、変更されたデータがクライアントで保持されていることを通信するために使用されるCよりも大きい値を作成します。この値をdで表すことがしてみましょう。"
    },
    {
      "indent": 3,
      "text": "o When the client is queried via CB_GETATTR for the change attribute, it checks to see if it holds modified data. If the file is modified, the value d is returned for the change attribute value. If this file is not currently modified, the client returns the value c for the change attribute.",
      "ja": "クライアントが変更属性のCB_GETATTR経由で照会すると、O、それが変更されたデータを保持しているかどうかを確認します。ファイルが変更されている場合は、値dが変化属性値に返されます。このファイルは、現在変更されていない場合、クライアントは、変更属性の値cを返します。"
    },
    {
      "indent": 3,
      "text": "For simplicity of implementation, the client MAY for each CB_GETATTR return the same value d. This is true even if, between successive CB_GETATTR operations, the client again modifies the file's data or metadata in its cache. The client can return the same value because the only requirement is that the client be able to indicate to the server that the client holds modified data. Therefore, the value of d may always be c + 1.",
      "ja": "実装を簡単にするために、各CB_GETATTRのクライアントMAYは同じ値dを返します。これは、連続したCB_GETATTR操作の間、クライアントは再びそのキャッシュ内のファイルのデータまたはメタデータを変更する場合も同様です。唯一の要件は、クライアントは、クライアントが変更されたデータを保持するサーバに指示することができるということであるため、クライアントが同じ値を返すことができます。したがって、Dの値は常にC + 1であってもよいです。"
    },
    {
      "indent": 3,
      "text": "While the change attribute is opaque to the client in the sense that it has no idea what units of time, if any, the server is counting change with, it is not opaque in that the client has to treat it as an unsigned integer, and the server has to be able to see the results of the client's changes to that integer. Therefore, the server MUST encode the change attribute in network order when sending it to the client. The client MUST decode it from network order to its native order when receiving it, and the client MUST encode it in network order when sending it to the server. For this reason, change is defined as an unsigned integer rather than an opaque array of bytes.",
      "ja": "変化属性は、それはサーバーの変更をカウントしている時間の何単位があれば、何のアイデアを持っていないという意味で、クライアントに不透明であるが、それは、クライアントが符号なし整数として扱う必要があることで不透明ではなく、サーバーは、その整数に対するクライアントの変更の結果を確認することができなければなりません。それをクライアントに送信するときにそのため、サーバがネットワーク順に変化属性を符号化しなければなりません。それを受信したとき、クライアントはその本来の順序にネットワークオーダーからそれをデコードしなければならない、そしてそれをサーバーに送信するときに、クライアントはネットワークのためにそれを符号化しなければなりません。この理由のため、変化が符号なし整数ではなくバイトの不透明な配列として定義されます。"
    },
    {
      "indent": 3,
      "text": "For the server, the following steps will be taken when providing an OPEN_DELEGATE_WRITE delegation:",
      "ja": "OPEN_DELEGATE_WRITE委任を提供する場合、サーバの場合は、以下のステップが行われます："
    },
    {
      "indent": 3,
      "text": "o Upon providing an OPEN_DELEGATE_WRITE delegation, the server will cache a copy of the change attribute in the data structure it uses to record the delegation. Let this value be represented by sc.",
      "ja": "O OPEN_DELEGATE_WRITE委任を提供する際に、サーバーは、それが委任を記録するために使用するデータ構造に変化属性のコピーをキャッシュします。この値は、SCで表すことがしてみましょう。"
    },
    {
      "indent": 3,
      "text": "o When a second client sends a GETATTR operation on the same file to the server, the server obtains the change attribute from the first client. Let this value be cc.",
      "ja": "2番目のクライアントがサーバに同じファイルにGETATTR操作を送信すると、O、サーバは、最初のクライアントからの変化属性を取得します。この値はccでみましょう。"
    },
    {
      "indent": 3,
      "text": "o If the value cc is equal to sc, the file is not modified and the server returns the current values for change, time_metadata, and time_modify (for example) to the second client.",
      "ja": "値CCは皮下に等しい場合、O、ファイルが変更され、サーバは、第2のクライアントへの変化、time_metadata、および（例えば）time_modifyの現在の値が返されていません。"
    },
    {
      "indent": 3,
      "text": "o If the value cc is NOT equal to sc, the file is currently modified at the first client and most likely will be modified at the server at a future time. The server then uses its current time to construct attribute values for time_metadata and time_modify. A new value of sc, which we will call nsc, is computed by the server, such that nsc >= sc + 1. The server then returns the constructed time_metadata, time_modify, and nsc values to the requester. The server replaces sc in the delegation record with nsc. To prevent the possibility of time_modify, time_metadata, and change from appearing to go backward (which would happen if the client holding the delegation fails to write its modified data to the server before the delegation is revoked or returned), the server SHOULD update the file's metadata record with the constructed attribute values. For reasons of reasonable performance, committing the constructed attribute values to stable storage is OPTIONAL.",
      "ja": "値CCがSCに等しいされていない場合は、O、ファイルは現在、最初のクライアントで変更され、最も可能性の高い将来の時点でサーバーに変更されます。次に、サーバーはtime_metadataとtime_modifyの属性値を構築するために、現在の時刻を使用しています。我々は、NSCを呼び出すSCの新しい値は、NSC> = SC + 1サーバは次いで、要求元に構築time_metadata、time_modify、およびNSC値を返すように、サーバによって計算されます。サーバーは、NSCとの委任レコードにSCを置き換えます。 time_modify、time_metadataの可能性を防止し、後方に行くように見えるから変更するには、サーバがファイルのを更新する必要があります（これは、委任を保持しているクライアントは、委任が取り消さまたは返される前に、サーバーにその変更されたデータの書き込みに失敗した場合に発生します）構成された属性値を持つメタデータレコード。妥当な性能の理由から、安定したストレージに構成された属性値をコミットすることは任意です。"
    },
    {
      "indent": 3,
      "text": "As discussed earlier in this section, the client MAY return the same cc value on subsequent CB_GETATTR calls, even if the file was modified in the client's cache yet again between successive CB_GETATTR calls. Therefore, the server must assume that the file has been modified yet again, and MUST take care to ensure that the new nsc it constructs and returns is greater than the previous nsc it returned. An example implementation's delegation record would satisfy this mandate by including a boolean field (let us call it \"modified\") that is set to FALSE when the delegation is granted, and an sc value set at the time of grant to the change attribute value. The modified field would be set to TRUE the first time cc != sc, and would stay TRUE until the delegation is returned or revoked. The processing for constructing nsc, time_modify, and time_metadata would use this pseudo code:",
      "ja": "このセクションですでに述べたように、クライアントは、ファイルが連続したCB_GETATTRの呼び出しの間に再びまだ、クライアントのキャッシュに変更された場合でも、その後のCB_GETATTRの呼び出しで同じCC値を返すことがあります。そのため、サーバーは、ファイルが再び変更されていることを前提としなければならない、そしてそれは構築し、返す新しいNSCはそれが返され、前のNSC以上であることを保証するために注意しなければなりません。実装例の委任レコードは、委任が許可されたときにFALSEに設定されたbooleanフィールド（私たちは、「修正」と呼んでみましょう）、および変更の属性値に付与時に設定SC値を含むことによって、この任務を満たすでしょう。変更されたフィールドがTRUEに初めてCC！= SCに設定されるだろう、と委任が返さまたは取り消されるまでTRUEとどまります。 NSCを構築するための処理、time_modify、およびtime_metadataは、この擬似コードを使用します。"
    },
    {
      "indent": 7,
      "text": "if (!modified) {\n    do CB_GETATTR for change and size;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    if (cc != sc)\n        modified = TRUE;\n} else {\n    do CB_GETATTR for size;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "if (modified) {\n    sc = sc + 1;\n    time_modify = time_metadata = current_time;\n    update sc, time_modify, time_metadata into file's metadata;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This would return to the client (that sent GETATTR) the attributes it requested, but make sure size comes from what CB_GETATTR returned. The server would not update the file's metadata with the client's modified size.",
      "ja": "これは、（GETATTRを送った）クライアント、それは要求された属性に戻りますが、サイズはCB_GETATTRが返さ何から来ていることを確認します。サーバーはクライアントの変更サイズのファイルのメタデータを更新しないでしょう。"
    },
    {
      "indent": 3,
      "text": "In the case that the file attribute size is different than the server's current value, the server treats this as a modification regardless of the value of the change attribute retrieved via CB_GETATTR and responds to the second client as in the last step.",
      "ja": "ファイル属性のサイズがサーバの現在の値と異なる場合は、関係なく、変化属性CB_GETATTR経由で取得し、最後のステップのように、第2のクライアントに応答の値の変更などのサーバー扱いこれ。"
    },
    {
      "indent": 3,
      "text": "This methodology resolves issues of clock differences between client and server and other scenarios where the use of CB_GETATTR break down.",
      "ja": "この方法は、クライアントとサーバとCB_GETATTRの使用が打破他のシナリオ間のクロック差の問題を解決します。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the server is under no obligation to use CB_GETATTR, and therefore the server MAY simply recall the delegation to avoid its use.",
      "ja": "サーバーがCB_GETATTRを使用する義務はないことに留意すべきであるので、サーバは単に、その使用を避けるために、委任を思い出すかもしれ。"
    },
    {
      "indent": 0,
      "text": "10.4.4. Recall of Open Delegation",
      "section_title": true,
      "ja": "10.4.4. オープン委任のリコール"
    },
    {
      "indent": 3,
      "text": "The following events necessitate recall of an OPEN delegation:",
      "ja": "次のイベントがOPEN委任のリコールを余儀なく："
    },
    {
      "indent": 3,
      "text": "o potentially conflicting OPEN request (or a READ or WRITE operation done with a special stateid)",
      "ja": "O潜在OPEN要求（または特別なstateidで行わREADまたはWRITE動作）競合"
    },
    {
      "indent": 3,
      "text": "o SETATTR sent by another client",
      "ja": "O SETATTR別のクライアントから送信されました"
    },
    {
      "indent": 3,
      "text": "o REMOVE request for the file",
      "ja": "ファイルに対する要求を削除するには"
    },
    {
      "indent": 3,
      "text": "o RENAME request for the file as either the source or target of the RENAME",
      "ja": "O RENAMEのソースまたはターゲットとしてファイルの要求の名前を変更"
    },
    {
      "indent": 3,
      "text": "Whether a RENAME of a directory in the path leading to the file results in recall of an OPEN delegation depends on the semantics of the server's file system. If that file system denies such RENAMEs when a file is open, the recall must be performed to determine whether the file in question is, in fact, open.",
      "ja": "OPEN委任のリコールで、ファイルの結果につながるパス内のディレクトリのRENAMEかどうかは、サーバーのファイルシステムのセマンティクスに依存します。ファイルが開いているときに、そのファイル・システムは、このような名前に変更を拒否した場合、リコールは、問題のファイルは、実際には、開いているかどうかを決定するために行われなければなりません。"
    },
    {
      "indent": 3,
      "text": "In addition to the situations above, the server may choose to recall OPEN delegations at any time if resource constraints make it advisable to do so. Clients should always be prepared for the possibility of recall.",
      "ja": "上記の状況に加えて、サーバは、リソースの制約がそうすることをお勧めします場合はいつでもOPEN委任をリコールすることもできます。クライアントは常にリコールの可能性のために準備されるべきです。"
    },
    {
      "indent": 3,
      "text": "When a client receives a recall for an OPEN delegation, it needs to update state on the server before returning the delegation. These same updates must be done whenever a client chooses to return a delegation voluntarily. The following items of state need to be dealt with:",
      "ja": "クライアントがOPEN委任のリコールを受信すると、それは代表団を返す前に、サーバー上での状態を更新する必要があります。これらの同じ更新は、クライアントが自発的に委任を返すことを選択したときに行われなければなりません。状態の以下の項目が扱われる必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the file associated with the delegation is no longer open and no previous CLOSE operation has been sent to the server, a CLOSE operation must be sent to the server.",
      "ja": "代表団に関連付けられたファイルは、もはや開いていて、以前のCLOSE操作がサーバーに送信されていない場合は、O、CLOSE操作がサーバーに送信されませんする必要があります。"
    },
    {
      "indent": 3,
      "text": "o If a file has other open references at the client, then OPEN operations must be sent to the server. The appropriate stateids will be provided by the server for subsequent use by the client since the delegation stateid will no longer be valid. These OPEN requests are done with the claim type of CLAIM_DELEGATE_CUR. This will allow the presentation of the delegation stateid so that the client can establish the appropriate rights to perform the OPEN. (see Section 18.16, which describes the OPEN operation, for details.)",
      "ja": "ファイルがクライアントで開いている他の参照を持っている場合は、O、その後、OPEN操作はサーバに送信する必要があります。委任のstateidは無効になりますので、適切なのstateidsは、クライアントによって、その後の使用のために、サーバによって提供されます。これらのOPEN要求はCLAIM_DELEGATE_CURの請求タイプで行われます。クライアントがOPENを実行するための適切な権限を確立できるように、これは、委任のstateidのプレゼンテーションが可能になります。 （詳細については、OPEN操作を説明するセクション18.16を参照してください。）"
    },
    {
      "indent": 3,
      "text": "o If there are granted byte-range locks, the corresponding LOCK operations need to be performed. This applies to the OPEN_DELEGATE_WRITE delegation case only.",
      "ja": "バイト範囲ロックが付与されている場合は、O、対応するロック操作が実行される必要があります。これはOPEN_DELEGATE_WRITE委任する場合にのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "o For an OPEN_DELEGATE_WRITE delegation, if at the time of recall the file is not open for OPEN4_SHARE_ACCESS_WRITE/ OPEN4_SHARE_ACCESS_BOTH, all modified data for the file must be flushed to the server. If the delegation had not existed, the client would have done this data flush before the CLOSE operation.",
      "ja": "リコール時にファイルがOPEN4_SHARE_ACCESS_WRITE / OPEN4_SHARE_ACCESS_BOTH用にオープンされていない場合はO OPEN_DELEGATE_WRITEの委任については、ファイルのすべての変更されたデータをサーバーにフラッシュする必要があります。代表団が存在していなかった場合、クライアントはCLOSE操作の前に、このデータフラッシュを行っているでしょう。"
    },
    {
      "indent": 3,
      "text": "o For an OPEN_DELEGATE_WRITE delegation when a file is still open at the time of recall, any modified data for the file needs to be flushed to the server.",
      "ja": "Oファイルはリコールの時にまだ開いているOPEN_DELEGATE_WRITE委譲については、ファイルの任意の変更されたデータをサーバーにフラッシュする必要があります。"
    },
    {
      "indent": 3,
      "text": "o With the OPEN_DELEGATE_WRITE delegation in place, it is possible that the file was truncated during the duration of the delegation. For example, the truncation could have occurred as a result of an",
      "ja": "代わりにOPEN_DELEGATE_WRITE委任してO、ファイルが委任の期間中に切り捨てられた可能性があります。たとえば、切り捨てが結果として発生した可能性が"
    },
    {
      "indent": 6,
      "text": "OPEN UNCHECKED with a size attribute value of zero. Therefore, if a truncation of the file has occurred and this operation has not been propagated to the server, the truncation must occur before any modified data is written to the server.",
      "ja": "ゼロのサイズの属性値でUNCHECKED開きます。ファイルの切り捨てが発生していると、この操作は、サーバーに伝播されていない場合、任意の変更されたデータがサーバーに書き込まれる前にそのため、切り捨てが行われなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the case of OPEN_DELEGATE_WRITE delegation, byte-range locking imposes some additional requirements. To precisely maintain the associated invariant, it is required to flush any modified data in any byte-range for which a WRITE_LT lock was released while the OPEN_DELEGATE_WRITE delegation was in effect. However, because the OPEN_DELEGATE_WRITE delegation implies no other locking by other clients, a simpler implementation is to flush all modified data for the file (as described just above) if any WRITE_LT lock has been released while the OPEN_DELEGATE_WRITE delegation was in effect.",
      "ja": "OPEN_DELEGATE_WRITE委任の場合は、バイト範囲ロックは、いくつかの追加の要件を課します。正確関連不変を維持するために、OPEN_DELEGATE_WRITE委任が有効であったWRITE_LTロックが解除されたため、任意のバイト範囲内の任意の変更されたデータをフラッシュする必要があります。 OPEN_DELEGATE_WRITE委任が他のクライアントによって他のロックを意味しないためしかし、より簡単な実装は、（ちょうど上記のように）OPEN_DELEGATE_WRITE委任が有効であった任意WRITE_LTロックが解除された場合、ファイルのすべての変更されたデータをフラッシュすることです。"
    },
    {
      "indent": 3,
      "text": "An implementation need not wait until delegation recall (or the decision to voluntarily return a delegation) to perform any of the above actions, if implementation considerations (e.g., resource availability constraints) make that desirable. Generally, however, the fact that the actual OPEN state of the file may continue to change makes it not worthwhile to send information about opens and closes to the server, except as part of delegation return. An exception is when the client has no more internal opens of the file. In this case, sending a CLOSE is useful because it reduces resource utilization on the client and server. Regardless of the client's choices on scheduling these actions, all must be performed before the delegation is returned, including (when applicable) the close that corresponds to the OPEN that resulted in the delegation. These actions can be performed either in previous requests or in previous operations in the same COMPOUND request.",
      "ja": "実装は、実装上の考慮事項は、（例えば、リソースの可用性の制約）ことが望ましくする場合は、上記のいずれかのアクションを実行するために、委任のリコール（または自主的に委任を返すように決定）するまで待つ必要はありません。しかしながら、一般的には、ファイルの実際のOPEN状態が変化し続けているという事実が開き、委任リターンの一部として以外に、サーバーに閉じについて、それは価値がない情報を送信することができます。クライアントはこれ以上内部ファイルの開きいる場合は例外ではありません。それは、クライアントとサーバー上のリソース使用率を低下させるので、この場合には、CLOSEを送信すると便利です。委任が返される前にかかわらず、これらのアクションをスケジュール上のクライアントの選択肢の、すべては（該当する場合）の代表団が生じOPENに対応近い含めて、実行する必要があります。これらのアクションは、以前の要求または同じCOMPOUND要求で以前の操作のいずれかで行うことができます。"
    },
    {
      "indent": 0,
      "text": "10.4.5. Clients That Fail to Honor Delegation Recalls",
      "section_title": true,
      "ja": "10.4.5. 委任リコールを称えるために失敗したクライアント"
    },
    {
      "indent": 3,
      "text": "A client may fail to respond to a recall for various reasons, such as a failure of the backchannel from server to the client. The client may be unaware of a failure in the backchannel. This lack of awareness could result in the client finding out long after the failure that its delegation has been revoked, and another client has modified the data for which the client had a delegation. This is especially a problem for the client that held an OPEN_DELEGATE_WRITE delegation.",
      "ja": "クライアントは、サーバからクライアントへのバックチャネルの故障など、さまざまな理由でリコールへの対応に失敗することがあります。クライアントは、バックチャネルの障害に気づかないかもしれません。意識の欠如は、クライアントがその代表団が取り消された障害が発生した後、長い見つけると、別のクライアントは、クライアントが委任を持っていたため、データを変更したにつながる可能性があります。これは特にOPEN_DELEGATE_WRITEの委任を開催クライアントの問題です。"
    },
    {
      "indent": 3,
      "text": "Status bits returned by SEQUENCE operations help to provide an alternate way of informing the client of issues regarding the status of the backchannel and of recalled delegations. When the backchannel is not available, the server returns the status bit SEQ4_STATUS_CB_PATH_DOWN on SEQUENCE operations. The client can react by attempting to re-establish the backchannel and by returning recallable objects if a backchannel cannot be successfully re-established.",
      "ja": "SEQUENCE操作によって返されたステータス・ビットは、バックチャネルのとリコール代表団の地位に関する問題のクライアントに通知する別の方法を提供するのに役立ちます。バックチャネルが利用できない場合、サーバはSEQUENCE運用上のステータスビットSEQ4_STATUS_CB_PATH_DOWNを返します。クライアントは、バックチャネルを再確立しようとすることにより、及びバックチャネルが正常に再確立することができない場合はリコールのオブジェクトを返すことによって反応することができます。"
    },
    {
      "indent": 3,
      "text": "Whether the backchannel is functioning or not, it may be that the recalled delegation is not returned. Note that the client's lease might still be renewed, even though the recalled delegation is not returned. In this situation, servers SHOULD revoke delegations that are not returned in a period of time equal to the lease period. This period of time should allow the client time to note the backchannel-down status and re-establish the backchannel.",
      "ja": "バックチャネルが機能しているかどうか、それはリコール代表団が返されていないことかもしれません。リコール代表団が返されていなくても、クライアントのリースがまだ更新されるかもしれないことに注意してください。このような状況では、サーバは、リース期間に等しい時間の期間内に返却されていない代表団を取り消すべきです。この期間は、バックチャネルダウンの状態に注意し、バックチャネルを再確立するためのクライアントの時間を許可する必要があります。"
    },
    {
      "indent": 3,
      "text": "When delegations are revoked, the server will return with the SEQ4_STATUS_RECALLABLE_STATE_REVOKED status bit set on subsequent SEQUENCE operations. The client should note this and then use TEST_STATEID to find which delegations have been revoked.",
      "ja": "代表団が取り消された場合、サーバーは、後続のSEQUENCEの操作で設定SEQ4_STATUS_RECALLABLE_STATE_REVOKEDステータスビットを返します。クライアントは、この点に注意してください、その後、代表団が無効化されているかを見つけるためにTEST_STATEIDを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.4.6. Delegation Revocation",
      "section_title": true,
      "ja": "10.4.6. 委任失効"
    },
    {
      "indent": 3,
      "text": "At the point a delegation is revoked, if there are associated opens on the client, these opens may or may not be revoked. If no byte-range lock or open is granted that is inconsistent with the existing open, the stateid for the open may remain valid and be disconnected from the revoked delegation, just as would be the case if the delegation were returned.",
      "ja": "そこに関連付けられている場合時点で、委任がクライアントに開き、取り消され、これらは、5月に開いたり、取り消されないことがあります。バイト範囲ロックまたはオープン何が既存のオープンと矛盾するよう許可されていない場合は、オープンのためのstateidは、代表団が返された場合ケースだろうと同じように、有効なままであり、取り消された代表団から切り離すこと。"
    },
    {
      "indent": 3,
      "text": "For example, if an OPEN for OPEN4_SHARE_ACCESS_BOTH with a deny of OPEN4_SHARE_DENY_NONE is associated with the delegation, granting of another such OPEN to a different client will revoke the delegation but need not revoke the OPEN, since the two OPENs are consistent with each other. On the other hand, if an OPEN denying write access is granted, then the existing OPEN must be revoked.",
      "ja": "例えばOPEN4_SHARE_DENY_NONEの拒否とOPEN4_SHARE_ACCESS_BOTHためのOPEN場合、委任を取り消します別のクライアントにそのような別のOPENの付与、代表団と関連しているが、2つのOPENsが互いに一致していることから、OPENを取り消す必要はありません。 OPEN拒否書き込みアクセスが許可された場合に、既存のOPENを取り消さなければなりません。"
    },
    {
      "indent": 3,
      "text": "When opens and/or locks are revoked, the applications holding these opens or locks need to be notified. This notification usually occurs by returning errors for READ/WRITE operations or when a close is attempted for the open file.",
      "ja": "開き、および/またはロックが取り消された場合、これらを保持しているアプリケーションが表示されますまたはロックが通知する必要があります。この通知は、通常、READ / WRITE操作にエラーを返すとき、またはクローズが開いたファイルのためにしようとしていることによって起こります。"
    },
    {
      "indent": 3,
      "text": "If no opens exist for the file at the point the delegation is revoked, then notification of the revocation is unnecessary. However, if there is modified data present at the client for the file, the user of the application should be notified. Unfortunately, it may not be possible to notify the user since active applications may not be present at the client. See Section 10.5.1 for additional details.",
      "ja": "委任が取り消された時点でファイルの存在開いたいかなる場合は、取り消しの通知は不要ではありません。ファイルのクライアントで変更されたデータが存在した場合ただし、アプリケーションの利用者に通知しなければなりません。残念ながら、アクティブなアプリケーションがクライアントに存在しないかもしれないので、ユーザに通知することはできないかもしれません。詳細については10.5.1項を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.4.7. Delegations via WANT_DELEGATION",
      "section_title": true,
      "ja": "10.4.7.  WANT_DELEGATION経由代表団"
    },
    {
      "indent": 3,
      "text": "In addition to providing delegations as part of the reply to OPEN operations, servers MAY provide delegations separate from open, via the OPTIONAL WANT_DELEGATION operation. This allows delegations to be obtained in advance of an OPEN that might benefit from them, for objects that are not a valid target of OPEN, or to deal with cases in which a delegation has been recalled and the client wants to make an attempt to re-establish it if the absence of use by other clients allows that.",
      "ja": "操作を開くために、応答の一部として委任を提供することに加えて、サーバは、委任がOPTIONAL WANT_DELEGATION操作を介して、オープンとは別に提供するかもしれません。これは、OPENの有効なターゲットではないオブジェクトのために、代表団はそれらの恩恵を受ける可能性がOPENの前に取得することを可能にする、または委任がリコールされた場合に対処するために、クライアントは再試行を作りたいです他のクライアントによって使用の有無がそれを可能にする場合は、それを-establish。"
    },
    {
      "indent": 3,
      "text": "The WANT_DELEGATION operation may be performed on any type of file object other than a directory.",
      "ja": "WANT_DELEGATION操作は、ディレクトリ以外のファイルのオブジェクトの任意のタイプで実行されてもよいです。"
    },
    {
      "indent": 3,
      "text": "When a delegation is obtained using WANT_DELEGATION, any open files for the same filehandle held by that client are to be treated as subordinate to the delegation, just as if they had been created using an OPEN of type CLAIM_DELEGATE_CUR. They are otherwise unchanged as to seqid, access and deny modes, and the relationship with byte-range locks. Similarly, because existing byte-range locks are subordinate to an open, those byte-range locks also become indirectly subordinate to that new delegation.",
      "ja": "代表団はWANT_DELEGATIONを使用して得られた場合、そのクライアントが保持している同じファイルハンドルのために開いているファイルは、彼らがタイプCLAIM_DELEGATE_CURのOPENを使用して作成されていたかのように、代表団に従属するものとして扱われるべきです。彼らは、SEQIDアクセスとモードを拒否し、バイト範囲ロックと関係するようにそれ以外の変更はありません。既存のバイト範囲ロックがオープンに従属しているので、同様に、これらのバイト範囲ロックは、その新しい代表団に間接的に下位になります。"
    },
    {
      "indent": 3,
      "text": "The WANT_DELEGATION operation provides for delivery of delegations via callbacks, when the delegations are not immediately available. When a requested delegation is available, it is delivered to the client via a CB_PUSH_DELEG operation. When this happens, open files for the same filehandle become subordinate to the new delegation at the point at which the delegation is delivered, just as if they had been created using an OPEN of type CLAIM_DELEGATE_CUR. Similarly, this occurs for existing byte-range locks subordinate to an open.",
      "ja": "WANT_DELEGATION操作は、代表団がすぐに利用できない場合、コールバックを経由して代表団の送達を提供します。要求された代表団が利用可能である場合、それはCB_PUSH_DELEG操作を介してクライアントに配信されます。このとき、同じファイルハンドルのための開いているファイルは、それらが型CLAIM_DELEGATE_CURのOPENを使用して作成されていたかのように、委任が配信された時点で新たな代表団に従属になります。同様に、これはオープンに従属する既存のバイト範囲ロックのために発生します。"
    },
    {
      "indent": 0,
      "text": "10.5. Data Caching and Revocation",
      "section_title": true,
      "ja": "10.5. データキャッシングと失効"
    },
    {
      "indent": 3,
      "text": "When locks and delegations are revoked, the assumptions upon which successful caching depends are no longer guaranteed. For any locks or share reservations that have been revoked, the corresponding state-owner needs to be notified. This notification includes applications with a file open that has a corresponding delegation that has been revoked. Cached data associated with the revocation must be removed from the client. In the case of modified data existing in the client's cache, that data must be removed from the client without being written to the server. As mentioned, the assumptions made by the client are no longer valid at the point when a lock or delegation has been revoked. For example, another client may have been granted a conflicting byte-range lock after the revocation of the byte-range lock at the first client. Therefore, the data within the lock range may have been modified by the other client. Obviously, the first client is unable to guarantee to the application what has occurred to the file in the case of revocation.",
      "ja": "ロックや代表団が取り消された場合は、成功したキャッシュが依存する仮定はもはや保証されません。取り消されたすべてのロックまたは共有の予約の場合は、対応する状態-所有者に通知する必要があります。この通知は取り消された対応する代表団を持っているファイルのオープンとアプリケーションが含まれています。失効に関連付けられたキャッシュされたデータは、クライアントから削除する必要があります。クライアントのキャッシュ内の既存の変更されたデータの場合には、そのデータがサーバーに書き込まれずに、クライアントから削除する必要があります。前述のように、クライアントによって行われた仮定は、ロックまたは委任が取り消された時点で、もはや有効ではありません。例えば、別のクライアントは、最初のクライアントでのバイト範囲ロックの失効後の競合バイト範囲ロックを付与されている可能性があります。したがって、ロック範囲内のデータは、他のクライアントによって修飾されていてもよいです。もちろん、最初のクライアントが失効した場合のファイルに発生したものをアプリケーションに保証することができません。"
    },
    {
      "indent": 3,
      "text": "Notification to a state-owner will in many cases consist of simply returning an error on the next and all subsequent READs/WRITEs to the open file or on the close. Where the methods available to a client make such notification impossible because errors for certain operations may not be returned, more drastic action such as signals or process termination may be appropriate. The justification here is that an invariant on which an application depends may be violated. Depending on how errors are typically treated for the client-operating environment, further levels of notification including logging, console messages, and GUI pop-ups may be appropriate.",
      "ja": "状態所有者への通知は、多くの場合、単に次にエラーを返すので構成され、すべての後続の/を開いているファイルに、または近くに読み書きします。特定の操作のためにエラーが返されない場合があるため、クライアントが利用可能な方法は、そのような通知が不可能ここで、このような信号またはプロセス終了、より思い切ったアクションが適切であり得ます。ここでの正当化は、アプリケーションが依存している不変に違反することができるということです。エラーは通常、クライアント・オペレーティング環境のために処理されている方法に応じて、ログ、コンソールメッセージ、およびGUIのポップアップを含む通知のさらなるレベルが適切かもしれません。"
    },
    {
      "indent": 0,
      "text": "10.5.1. Revocation Recovery for Write Open Delegation",
      "section_title": true,
      "ja": "10.5.1. 書き込みオープン委譲のための失効回復"
    },
    {
      "indent": 3,
      "text": "Revocation recovery for an OPEN_DELEGATE_WRITE delegation poses the special issue of modified data in the client cache while the file is not open. In this situation, any client that does not flush modified data to the server on each close must ensure that the user receives appropriate notification of the failure as a result of the revocation. Since such situations may require human action to correct problems, notification schemes in which the appropriate user or administrator is notified may be necessary. Logging and console messages are typical examples.",
      "ja": "ファイルが開いていないながらOPEN_DELEGATE_WRITE委任の失効回復は、クライアントキャッシュに変更されたデータの特別な問題を提起します。このような状況では、各近い上のサーバーに変更されたデータをフラッシュしない任意のクライアントは、ユーザーが失効した結果として故障の適切な通知を受けたことを確認する必要があります。このような状況は、問題を修正するために人間の行動を必要とするかもしれないので、適切なユーザまたは管理者に通知された通知方式が必要であってもよいです。ロギングとコンソールメッセージが典型的な例です。"
    },
    {
      "indent": 3,
      "text": "If there is modified data on the client, it must not be flushed normally to the server. A client may attempt to provide a copy of the file data as modified during the delegation under a different name in the file system namespace to ease recovery. Note that when the client can determine that the file has not been modified by any other client, or when the client has a complete cached copy of the file in question, such a saved copy of the client's view of the file may be of particular value for recovery. In another case, recovery using a copy of the file based partially on the client's cached data and partially on the server's copy as modified by other clients will be anything but straightforward, so clients may avoid saving file contents in these situations or specially mark the results to warn users of possible problems.",
      "ja": "クライアント上のデータが変更された場合は、サーバーに正常にフラッシュされてはなりません。クライアントは、リカバリを容易にするために、ファイルシステムの名前空間に別の名前で、委任時に変更されたファイルデータのコピーを提供しようとすることができます。クライアントは、ファイルが他のクライアントによって変更されていないと判断できる場合に、クライアントが問題のファイルの完全なキャッシュされたコピーを持っている場合、または、ファイルのクライアントのビューのように保存されたコピーが特定の値であってもよいことに注意してください回復のため。クライアントはこれらの状況では、ファイルの内容を保存しないようまたは特別な結果をマークすることができるので、別のケースでは、他のクライアントによって修正され、クライアントのキャッシュされたデータに、一部のサーバーのコピーに部分的に基づいて、ファイルのコピーを使用して回復は、簡単な何でもなります可能性のある問題のユーザーに警告します。"
    },
    {
      "indent": 3,
      "text": "Saving of such modified data in delegation revocation situations may be limited to files of a certain size or might be used only when sufficient disk space is available within the target file system. Such saving may also be restricted to situations when the client has sufficient buffering resources to keep the cached copy available until it is properly stored to the target file system.",
      "ja": "委任失効状況で、このような変更されたデータの保存は、特定のサイズのファイルに限定することができるか、十分なディスク領域が、ターゲット・ファイル・システム内で利用可能である場合にのみ使用される可能性があります。このような節約はまた、それが適切にターゲット・ファイル・システムに格納されるまで、クライアントが利用できるキャッシュされたコピーを保持するのに十分なバッファリング資源を持っているときの状況に制限することができます。"
    },
    {
      "indent": 0,
      "text": "10.6. Attribute Caching",
      "section_title": true,
      "ja": "10.6. 属性のキャッシュ"
    },
    {
      "indent": 3,
      "text": "This section pertains to the caching of a file's attributes on a client when that client does not hold a delegation on the file.",
      "ja": "このセクションでは、クライアントがファイルの委任を保持していないクライアント上のファイルの属性のキャッシングに関連します。"
    },
    {
      "indent": 3,
      "text": "The attributes discussed in this section do not include named attributes. Individual named attributes are analogous to files, and caching of the data for these needs to be handled just as data caching is for ordinary files. Similarly, LOOKUP results from an OPENATTR directory (as well as the directory's contents) are to be cached on the same basis as any other pathnames.",
      "ja": "このセクションで説明する属性が指定された属性が含まれていません。個々の名前の属性は、ファイルに類似しており、これらのニーズのためのデータのキャッシュは、データキャッシュが通常のファイルのためであると同じように扱うことが。同様に、OPENATTRディレクトリ（ならびにディレクトリの内容）から参照結果は、他のパス名と同じに基づいてキャッシュされるべきです。"
    },
    {
      "indent": 3,
      "text": "Clients may cache file attributes obtained from the server and use them to avoid subsequent GETATTR requests. Such caching is write through in that modification to file attributes is always done by means of requests to the server and should not be done locally and should not be cached. The exception to this are modifications to attributes that are intimately connected with data caching. Therefore, extending a file by writing data to the local data cache is reflected immediately in the size as seen on the client without this change being immediately reflected on the server. Normally, such changes are not propagated directly to the server, but when the modified data is flushed to the server, analogous attribute changes are made on the server. When OPEN delegation is in effect, the modified attributes may be returned to the server in reaction to a CB_RECALL call.",
      "ja": "クライアントは、サーバから取得したファイル属性をキャッシュし、その後のGETATTR要求を避けるためにそれらを使用することができます。このようなキャッシュは常に、サーバーへのリクエストによって行われた属性をファイルにその変更にライトスルーしてローカルに実行すべきではないとキャッシュされるべきではないです。この例外は密接にデータキャッシュに接続されている属性に変更されています。したがって、ローカル・データ・キャッシュにデータを書き込むことで、ファイルを拡張すると、この変更はすぐにサーバーに反映されずに、クライアント上で見られるような大きさにすぐに反映されています。通常、このような変更は、サーバーに直接伝播されるのではなく、変更されたデータをサーバーにフラッシュされたときに、類似した属性の変更は、サーバー上で行われています。 OPEN委任が有効になっている場合には、変更された属性はCB_RECALLコールに反応してサーバーに戻すことができます。"
    },
    {
      "indent": 3,
      "text": "The result of local caching of attributes is that the attribute caches maintained on individual clients will not be coherent. Changes made in one order on the server may be seen in a different order on one client and in a third order on another client.",
      "ja": "属性のローカルキャッシュの結果は、個々のクライアント上で維持さ属性キャッシュがコヒーレントではないということです。サーバー上の1つの順序で行われた変更は1つのクライアント上で、別のクライアント上の三ために、異なる順序で見ることができます。"
    },
    {
      "indent": 3,
      "text": "The typical file system application programming interfaces do not provide means to atomically modify or interrogate attributes for multiple files at the same time. The following rules provide an environment where the potential incoherencies mentioned above can be reasonably managed. These rules are derived from the practice of previous NFS protocols.",
      "ja": "一般的なファイルシステムのアプリケーション・プログラミング・インタフェースは、アトミック、同時に複数のファイルの属性を変更したり、尋問するための手段を提供しません。次の規則は、前述した可能性incoherenciesが合理的に管理することができる環境を提供します。これらの規則は、以前のNFSプロトコルの実施から導出されています。"
    },
    {
      "indent": 3,
      "text": "o All attributes for a given file (per-fsid attributes excepted) are cached as a unit at the client so that no non-serializability can arise within the context of a single file.",
      "ja": "何の非直列可能で、単一のファイルのコンテキスト内で発生しないことができるように、O、指定されたファイルのすべての属性は、（あたり-FSID属性は除く）クライアントでの単位としてキャッシュされます。"
    },
    {
      "indent": 3,
      "text": "o An upper time boundary is maintained on how long a client cache entry can be kept without being refreshed from the server.",
      "ja": "O上側の時間境界は、クライアントのキャッシュエントリは、サーバから更新されずに保持することができるどのくらいに維持されています。"
    },
    {
      "indent": 3,
      "text": "o When operations are performed that change attributes at the server, the updated attribute set is requested as part of the containing RPC. This includes directory operations that update attributes indirectly. This is accomplished by following the modifying operation with a GETATTR operation and then using the results of the GETATTR to update the client's cached attributes.",
      "ja": "操作は変更がサーバーに属性をすることを行っている場合には、O、更新された属性のセットが含まRPCの一部として要求されています。これは、その更新が間接的に属性ディレクトリ操作を含んでいます。これは、GETATTR操作で改質操作を次し、クライアントのキャッシュされた属性を更新するために、GETATTRの結果を使用することによって達成されます。"
    },
    {
      "indent": 3,
      "text": "Note that if the full set of attributes to be cached is requested by READDIR, the results can be cached by the client on the same basis as attributes obtained via GETATTR.",
      "ja": "キャッシュされる属性の完全なセットがREADDIRによって要求された場合、結果がGETATTRを介して取得した属性と同じ基準で、クライアントによってキャッシュされることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A client may validate its cached version of attributes for a file by fetching both the change and time_access attributes and assuming that if the change attribute has the same value as it did when the attributes were cached, then no attributes other than time_access have changed. The reason why time_access is also fetched is because many servers operate in environments where the operation that updates change does not update time_access. For example, POSIX file semantics do not update access time when a file is modified by the write system call [18]. Therefore, the client that wants a current time_access value should fetch it with change during the attribute cache validation processing and update its cached time_access.",
      "ja": "クライアントが変更とtime_access属性の両方を取得し、属性がキャッシュされた時にそれがなかったとして変化属性が同じ値を持っている場合は、time_access以外の属性が変更されていないことを仮定することにより、ファイルの属性のそのキャッシュされたバージョンを検証することができます。多くのサーバーが変更を更新操作がtime_accessを更新していない環境でも動作するのでtime_accessもフェッチされる理由はあります。例えば、POSIXファイルのセマンティクスは、ファイルが書き込みシステムコール[18]によって変更されたアクセス時間を更新しません。したがって、現在のtime_access値を望んでいるクライアントは、属性キャッシュの検証処理中に変更して、それをフェッチし、そのキャッシュされたtime_accessを更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client may maintain a cache of modified attributes for those attributes intimately connected with data of modified regular files (size, time_modify, and change). Other than those three attributes, the client MUST NOT maintain a cache of modified attributes. Instead, attribute changes are immediately sent to the server.",
      "ja": "クライアントは密接に変更され、通常のファイル（サイズ、time_modify、および変更）のデータに接続し、それらの属性のために変更された属性のキャッシュを維持することができます。これらの3つの属性以外にも、クライアントが変更された属性のキャッシュを維持してはなりません。代わりに、属性の変更は、すぐにサーバーに送信されます。"
    },
    {
      "indent": 3,
      "text": "In some operating environments, the equivalent to time_access is expected to be implicitly updated by each read of the content of the file object. If an NFS client is caching the content of a file object, whether it is a regular file, directory, or symbolic link, the client SHOULD NOT update the time_access attribute (via SETATTR or a small READ or READDIR request) on the server with each read that is satisfied from cache. The reason is that this can defeat the performance benefits of caching content, especially since an explicit SETATTR of time_access may alter the change attribute on the server. If the change attribute changes, clients that are caching the content will think the content has changed, and will re-read unmodified data from the server. Nor is the client encouraged to maintain a modified version of time_access in its cache, since the client either would eventually have to write the access time to the server with bad performance effects or never update the server's time_access, thereby resulting in a situation where an application that caches access time between a close and open of the same file observes the access time oscillating between the past and present. The time_access attribute always means the time of last access to a file by a read that was satisfied by the server. This way clients will tend to see only time_access changes that go forward in time.",
      "ja": "一部のオペレーティング環境では、time_accessと同等のは暗黙のうちにファイルオブジェクトのコンテンツの各読み取りによって更新されることが期待されます。 NFSクライアントは、それが通常のファイル、ディレクトリ、シンボリックリンクであるかどうか、ファイルオブジェクトのコンテンツをキャッシュしている場合、クライアントはそれぞれに、サーバー上の（SETATTRや小さなREADまたはREADDIR要求を経由して）time_access属性を更新すべきではありませんそれはキャッシュから満足しているお読みください。その理由は、これがtime_accessの明示的なSETATTRは、サーバー上の変化属性を変更することができる、特に以来、キャッシュコンテンツのパフォーマンス上の利点を倒すことができるということです。変更属性の変更をした場合、コンテンツをキャッシュしているクライアントは、コンテンツがサーバーから変更されていないデータを変更した、と再読み込みすると思います。いずれかのクライアントが最終的にどこ適用することにより状況が生じ、悪いパフォーマンスの影響で、サーバへのアクセス時間を書かないか、決してサーバーのtime_accessを更新しなければならないので、NORクライアントは、そのキャッシュにtime_accessの修正バージョンを維持することが奨励されますそれは、同じファイルのクローズとオープンとの間のアクセス時間は、過去と現在との間のアクセス時間の振動を観察キャッシュします。 time_access属性は常にサーバーによって満たされた読み取りがファイルへの最後のアクセスの時間を意味します。この方法では、クライアントが時間に前に進むのみtime_accessの変更を確認する傾向があります。"
    },
    {
      "indent": 0,
      "text": "10.7. Data and Metadata Caching and Memory Mapped Files",
      "section_title": true,
      "ja": "10.7. データおよびメタデータキャッシュとメモリマップファイル"
    },
    {
      "indent": 3,
      "text": "Some operating environments include the capability for an application to map a file's content into the application's address space. Each time the application accesses a memory location that corresponds to a block that has not been loaded into the address space, a page fault occurs and the file is read (or if the block does not exist in the file, the block is allocated and then instantiated in the application's address space).",
      "ja": "一部のオペレーティング環境では、アプリケーションのアドレス空間にファイルの内容をマップするアプリケーションのための機能が含まれています。アドレス空間にロードされていないブロックに対応するメモリ位置にアクセスするアプリケーションごとに、ページフォールトが発生し、ファイルが読み込まれる（またはブロックがファイル内に存在しない場合、ブロックが割り当てられると）アプリケーションのアドレス空間でインスタンス化。"
    },
    {
      "indent": 3,
      "text": "As long as each memory-mapped access to the file requires a page fault, the relevant attributes of the file that are used to detect access and modification (time_access, time_metadata, time_modify, and change) will be updated. However, in many operating environments, when page faults are not required, these attributes will not be updated on reads or updates to the file via memory access (regardless of whether the file is local or is accessed remotely). A client or server MAY fail to update attributes of a file that is being accessed via memory-mapped I/O. This has several implications:",
      "ja": "限り、ファイルへの各メモリ・マップ・アクセスは、ページフォールトを必要として、アクセスと変更（time_access、time_metadata、time_modify、および変更）を検出するために使用されているファイルの関連属性が更新されます。ページフォルトが必要とされていない場合しかし、多くのオペレーティング環境では、これらの属性は、上で更新されません（関係なく、ファイルがローカルまたはリモートでアクセスされたかどうかの）メモリアクセスを介してファイルへの読み取りまたは更新されます。クライアントまたはサーバは、メモリマップドI / Oを経由してアクセスされているファイルの属性を更新するために失敗することがあります。これにはいくつかの意味を持っています："
    },
    {
      "indent": 3,
      "text": "o If there is an application on the server that has memory mapped a file that a client is also accessing, the client may not be able to get a consistent value of the change attribute to determine whether or not its cache is stale. A server that knows that the file is memory-mapped could always pessimistically return updated values for change so as to force the application to always get the most up-to-date data and metadata for the file. However, due to the negative performance implications of this, such behavior is OPTIONAL.",
      "ja": "メモリは、クライアントにもアクセスしているファイルをマッピングしているサーバー上のアプリケーションがある場合は、O、クライアントは、そのキャッシュが古くなっているかどうかを判断するために変化属性の一貫性のある値を取得することができない場合があります。常に最新のデータやファイルのメタデータを取得するためにアプリケーションを強制するように、ファイルがメモリマップされていることを知っているサーバーは、常に悲観的に変更のための更新された値を返すことができます。しかし、この負のパフォーマンスへの影響のために、そのような行動はオプションです。"
    },
    {
      "indent": 3,
      "text": "o If the memory-mapped file is not being modified on the server, and instead is just being read by an application via the memory-mapped interface, the client will not see an updated time_access attribute. However, in many operating environments, neither will any process running on the server. Thus, NFS clients are at no disadvantage with respect to local processes.",
      "ja": "メモリマップドファイルがサーバー上で変更されていない、とだけではなく、メモリマップされたインタフェースを介してアプリケーションによって読み取られている場合は、O、クライアントが更新されtime_access属性は表示されません。しかし、多くのオペレーティング環境では、どちらも任意のプロセスは、サーバー上で実行されているんでしょう。したがって、NFSクライアントは、ローカルプロセスに対してない不利です。"
    },
    {
      "indent": 3,
      "text": "o If there is another client that is memory mapping the file, and if that client is holding an OPEN_DELEGATE_WRITE delegation, the same set of issues as discussed in the previous two bullet points apply. So, when a server does a CB_GETATTR to a file that the client has modified in its cache, the reply from CB_GETATTR will not necessarily be accurate. As discussed earlier, the client's obligation is to report that the file has been modified since the delegation was granted, not whether it has been modified again between successive CB_GETATTR calls, and the server MUST assume that any file the client has modified in cache has been modified again between successive CB_GETATTR calls. Depending on the nature of the client's memory management system, this weak obligation may not be possible. A client MAY return stale information in CB_GETATTR whenever the file is memory-mapped.",
      "ja": "Oメモリのファイルをマッピングしている別のクライアントがある場合は、前の2箇条書きで説明したように、そのクライアントは、問題の同じセットをOPEN_DELEGATE_WRITE委任を保持している場合は適用されます。サーバは、クライアントがそのキャッシュ内で変更したファイルにCB_GETATTRをするときに、CB_GETATTRからの応答は必ずしも正確ではありません。先に述べたように、クライアントの義務は、委任が許可されたので、それが連続CB_GETATTR呼び出しの間で再び変更されているかどうか、ファイルが変更されたことを報告することで、サーバは、クライアントがキャッシュ内で変更したすべてのファイルがされていると仮定しなければなりません連続CB_GETATTR呼び出しの間で再び修正。クライアントのメモリ管理システムの性質に応じて、この弱い義務はできないことがあります。ファイルがメモリマップされているときは常にクライアントがCB_GETATTRに古い情報が返されることがあります。"
    },
    {
      "indent": 3,
      "text": "o The mixture of memory mapping and byte-range locking on the same file is problematic. Consider the following scenario, where a page size on each client is 8192 bytes.",
      "ja": "O同じファイルのメモリマッピングおよびバイト範囲ロックの混合物が問題となります。各クライアント上のページサイズが8192バイトである場合、次のシナリオを検討してください。"
    },
    {
      "indent": 6,
      "text": "* Client A memory maps the first page (8192 bytes) of file X.",
      "ja": "*クライアントのメモリは、ファイルXの最初のページ（8192バイト）にマップ"
    },
    {
      "indent": 6,
      "text": "* Client B memory maps the first page (8192 bytes) of file X.",
      "ja": "*クライアントBのメモリは、ファイルXの最初のページ（8192バイト）にマップ"
    },
    {
      "indent": 6,
      "text": "* Client A WRITE_LT locks the first 4096 bytes.",
      "ja": "*クライアントA WRITE_LTは、最初の4096のバイトをロックします。"
    },
    {
      "indent": 6,
      "text": "* Client B WRITE_LT locks the second 4096 bytes.",
      "ja": "*クライアントB WRITE_LTは、第4096バイトをロックします。"
    },
    {
      "indent": 6,
      "text": "* Client A, via a STORE instruction, modifies part of its locked byte-range.",
      "ja": "*クライアントAは、STORE命令を介して、そのロックされたバイト範囲の一部を変更します。"
    },
    {
      "indent": 6,
      "text": "* Simultaneous to client A, client B executes a STORE on part of its locked byte-range.",
      "ja": "*クライアントAへの同時、クライアントBはそのロックバイト範囲の一部にSTOREを実行します。"
    },
    {
      "indent": 3,
      "text": "Here the challenge is for each client to resynchronize to get a correct view of the first page. In many operating environments, the virtual memory management systems on each client only know a page is modified, not that a subset of the page corresponding to the respective lock byte-ranges has been modified. So it is not possible for each client to do the right thing, which is to write to the server only that portion of the page that is locked. For example, if client A simply writes out the page, and then client B writes out the page, client A's data is lost.",
      "ja": "各クライアントは、最初のページの正しいビューを取得するために再同期化するためにここで課題となっています。多くのオペレーティング環境では、各クライアント上の仮想メモリ管理システムが唯一のページが変更されて知っている、それぞれのロックバイト範囲に対応したページのサブセットが変更されていないこと。だから、各クライアントがサーバーにロックされているページのその部分のみを記述することで正しいことを、行うことは可能ではありません。例えば、クライアントAは、単にページを書き出した場合、その後、クライアントBがページを書き出し、クライアントAのデータが失われます。"
    },
    {
      "indent": 3,
      "text": "Moreover, if mandatory locking is enabled on the file, then we have a different problem. When clients A and B execute the STORE instructions, the resulting page faults require a byte-range lock on the entire page. Each client then tries to extend their locked range to the entire page, which results in a deadlock. Communicating the NFS4ERR_DEADLOCK error to a STORE instruction is difficult at best.",
      "ja": "強制ロックがファイル上で有効になっている場合はまた、我々は別の問題を抱えています。クライアントA及びBは、ストア命令を実行すると、結果として生じるページ・フォールトはページ全体にバイト範囲ロックを必要とします。各クライアントは、その後、デッドロックになり、ページ全体に彼らのロックされた範囲を拡張しようとします。 STORE命令にNFS4ERR_DEADLOCKエラーを伝えることは最高に困難です。"
    },
    {
      "indent": 3,
      "text": "If a client is locking the entire memory-mapped file, there is no problem with advisory or mandatory byte-range locking, at least until the client unlocks a byte-range in the middle of the file.",
      "ja": "クライアントは、全体のメモリマップファイルをロックしている場合、クライアントはファイルの途中でバイト範囲ロックを解除少なくともまで、諮問または必須のバイト範囲ロッキング問題がありません。"
    },
    {
      "indent": 3,
      "text": "Given the above issues, the following are permitted:",
      "ja": "上記の問題を考えると、次は許可されています。"
    },
    {
      "indent": 3,
      "text": "o Clients and servers MAY deny memory mapping a file for which they know there are byte-range locks.",
      "ja": "Oクライアントとサーバーは、バイト範囲ロックが知っているファイルをマッピングするメモリを拒否することができます。"
    },
    {
      "indent": 3,
      "text": "o Clients and servers MAY deny a byte-range lock on a file they know is memory-mapped.",
      "ja": "Oクライアントとサーバーは、彼らが知っているファイルのバイト範囲ロックは、メモリマップされている拒否することができます。"
    },
    {
      "indent": 3,
      "text": "o A client MAY deny memory mapping a file that it knows requires mandatory locking for I/O. If mandatory locking is enabled after the file is opened and mapped, the client MAY deny the application further access to its mapped file.",
      "ja": "Oクライアントは、それがI / Oのための強制ロックを必要と知っているファイルをマッピングするメモリを拒否することができます。ファイルが開かれ、マップされた後に強制ロックが有効になっている場合、クライアントはそのマップされたファイルへのアプリケーションのさらなるアクセスを拒否することができます。"
    },
    {
      "indent": 0,
      "text": "10.8. Name and Directory Caching without Directory Delegations",
      "section_title": true,
      "ja": "10.8. ディレクトリ代表団のない名前とディレクトリのキャッシング"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 directory delegation facility (described in Section 10.9 below) is OPTIONAL for servers to implement. Even where it is implemented, it may not always be functional because of resource availability issues or other constraints. Thus, it is important to understand how name and directory caching are done in the absence of directory delegations. These topics are discussed in the next two subsections.",
      "ja": "サーバが実装するために（以下のセクション10.9で説明）NFSv4.1ディレクトリ委任機能はオプションです。それが実装されている場合であっても、それは常にあるため、リソースの可用性の問題やその他の制約の機能的ではないかもしれません。したがって、名前とディレクトリのキャッシュがディレクトリの代表団が存在しない状態で行われているかを理解することが重要です。これらのトピックは、次の2つのサブセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "10.8.1. Name Caching",
      "section_title": true,
      "ja": "10.8.1. 名前キャッシング"
    },
    {
      "indent": 3,
      "text": "The results of LOOKUP and READDIR operations may be cached to avoid the cost of subsequent LOOKUP operations. Just as in the case of attribute caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies and given the context of typical file system APIs, an upper time boundary is maintained for how long a client name cache entry can be kept without verifying that the entry has not been made invalid by a directory change operation performed by another client.",
      "ja": "LOOKUPとREADDIR操作の結果は、その後のLOOKUP操作のコストを回避するためにキャッシュされる場合があります。ただ、属性のキャッシングの場合のように、矛盾がさまざまなクライアントキャッシュ間生じる可能性があります。これらの不整合の影響を緩和し、一般的なファイルシステムAPIのコンテキストを与えるために、上側の時間境界は、クライアント名のキャッシュエントリが行われたディレクトリ変更操作によってエントリが無効にされていないことを確認せずに維持することができるどのくらいのために維持されています別のクライアントによる。"
    },
    {
      "indent": 3,
      "text": "When a client is not making changes to a directory for which there exist name cache entries, the client needs to periodically fetch attributes for that directory to ensure that it is not being modified. After determining that no modification has occurred, the expiration time for the associated name cache entries may be updated to be the current time plus the name cache staleness bound.",
      "ja": "クライアントが名前のキャッシュエントリが存在するためにディレクトリを変更するされていない場合、クライアントは定期的にそれが修正されていないことを確認するために、そのディレクトリの属性を取得する必要があります。何も変更が発生していないことを決定した後、関連する名前のキャッシュエントリの有効期限は、現在の時刻プラスバインド名キャッシュ古さに更新することができます。"
    },
    {
      "indent": 3,
      "text": "When a client is making changes to a given directory, it needs to determine whether there have been changes made to the directory by other clients. It does this by using the change attribute as reported before and after the directory operation in the associated change_info4 value returned for the operation. The server is able to communicate to the client whether the change_info4 data is provided atomically with respect to the directory operation. If the change values are provided atomically, the client has a basis for determining, given proper care, whether other clients are modifying the directory in question.",
      "ja": "クライアントが指定したディレクトリに変更を行っているとき、それは他のクライアントがディレクトリへの変更があったかどうかを決定する必要があります。これは、操作のために返される関連する変化_info4値のディレクトリ操作の前と後に報告されたように変化属性を使用してこれを行います。サーバは変化_info4データがディレクトリ動作に関してアトミックに設けられているかどうかをクライアントに通信することができます。変更値をアトミックに提供されている場合、クライアントは他のクライアントが問題のディレクトリを変更しているかどうか、判断する、与えられた適切なケアのための基礎を持っています。"
    },
    {
      "indent": 3,
      "text": "The simplest way to enable the client to make this determination is for the client to serialize all changes made to a specific directory. When this is done, and the server provides before and after values of the change attribute atomically, the client can simply compare the after value of the change attribute from one operation on a directory with the before value on the subsequent operation modifying that directory. When these are equal, the client is assured that no other client is modifying the directory in question.",
      "ja": "この決意をするために、クライアントを有効にする最も簡単な方法は、特定のディレクトリに加えられたすべての変更をシリアル化するクライアントのためです。変更の値がアトミック属性の前と後にこれが行われ、サーバが提供されている場合、クライアントは単純にそのディレクトリを変更し、その後の操作で前の値を持つディレクトリ上の一つの操作からの変更属性の値の後に比較することができます。これらが等しい場合、クライアントは、他のクライアントが問題のディレクトリを変更していないことが保証されます。"
    },
    {
      "indent": 3,
      "text": "When such serialization is not used, and there may be multiple simultaneous outstanding operations modifying a single directory sent from a single client, making this sort of determination can be more complicated. If two such operations complete in a different order than they were actually performed, that might give an appearance consistent with modification being made by another client. Where this appears to happen, the client needs to await the completion of all such modifications that were started previously, to see if the outstanding before and after change numbers can be sorted into a chain such that the before value of one change number matches the after value of a previous one, in a chain consistent with this client being the only one modifying the directory.",
      "ja": "こうした直列化が使用されていない、単一のクライアントから送信された単一のディレクトリを変更する複数の未同時操作があるかもしれない場合には、決意のこの種を作ることは、より複雑になる可能性があります。修正と一貫した外観を与えるかもしれない、彼らが実際に行われたものとは異なる順序で完全に二つのそのような操作は、別のクライアントによって行われている場合。これが起こるように見えますが、クライアントが優れている場合、変更番号が1つの変更番号の前の値が後に一致するようにチェーンに分類することができます前に、と後に見るために、以前に開始された全てのそのような変更の完了を待つ必要がある場合このクライアントがディレクトリを変更するだけであることと一致チェーン内の前の1、の値。"
    },
    {
      "indent": 3,
      "text": "In either of these cases, the client is able to determine whether the directory is being modified by another client. If the comparison indicates that the directory was updated by another client, the name cache associated with the modified directory is purged from the client. If the comparison indicates no modification, the name cache can be updated on the client to reflect the directory operation and the associated timeout can be extended. The post-operation change value needs to be saved as the basis for future change_info4 comparisons.",
      "ja": "これらの場合のいずれにおいても、クライアントはディレクトリが別のクライアントによって修飾されているかどうかを決定することができます。比較はディレクトリが別のクライアントによって更新されたことを示している場合、修正ディレクトリに関連付けられた名前のキャッシュは、クライアントからパージされます。比較は何も変更がないことを示す場合は、名前のキャッシュは、ディレクトリ操作を反映するために、クライアント上で更新することができ、関連するタイムアウトを延長することができます。術後変化値は、将来の変化_info4比較のための基礎として保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "As demonstrated by the scenario above, name caching requires that the client revalidate name cache data by inspecting the change attribute of a directory at the point when the name cache item was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory is modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre- and post-operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.",
      "ja": "上記のシナリオによって示されるように、名前のキャッシュは、クライアントが名前のキャッシュ項目がキャッシュされた時点で、ディレクトリの変更属性を調べることによって、名前のキャッシュデータを再検証する必要があります。これは、対応するディレクトリの内容が変更されたときに、サーバがディレクトリの変更属性を更新する必要があります。適切かつ正確に変化_info4情報を使用するクライアントの場合、サーバーは、前後の動作変更がアトミック属性値を報告しなければなりません。サーバーは、ディレクトリ操作に関して原子論前後の値を報告することができない場合は、サーバーは変化_info4の戻り値であることを示す必要があります。情報がアトミックに報告されていない場合、クライアントは他のクライアントがディレクトリを変更していないことを仮定するべきではありません。"
    },
    {
      "indent": 0,
      "text": "10.8.2. Directory Caching",
      "section_title": true,
      "ja": "10.8.2. ディレクトリのキャッシング"
    },
    {
      "indent": 3,
      "text": "The results of READDIR operations may be used to avoid subsequent READDIR operations. Just as in the cases of attribute and name caching, inconsistencies may arise among the various client caches. To mitigate the effects of these inconsistencies, and given the context of typical file system APIs, the following rules should be followed:",
      "ja": "READDIR操作の結果は、その後のREADDIR操作を回避するために使用されてもよいです。ただ、属性と名前のキャッシュの例のように、矛盾がさまざまなクライアントキャッシュ間生じる可能性があります。これらの不整合の影響を軽減し、一般的なファイルシステムAPIのコンテキストを与えるために、次の規則に従ってください。"
    },
    {
      "indent": 3,
      "text": "o Cached READDIR information for a directory that is not obtained in a single READDIR operation must always be a consistent snapshot of directory contents. This is determined by using a GETATTR before the first READDIR and after the last READDIR that contributes to the cache.",
      "ja": "OシングルREADDIR操作で得られていないディレクトリのキャッシュREADDIR情報は常に、ディレクトリの内容の一貫性のあるスナップショットでなければなりません。これは最初のREADDIR前に、キャッシュに寄与し、最後のREADDIR後GETATTRを用いて決定されます。"
    },
    {
      "indent": 3,
      "text": "o An upper time boundary is maintained to indicate the length of time a directory cache entry is considered valid before the client must revalidate the cached information.",
      "ja": "O上側の時間境界は、クライアントがキャッシュされた情報を再検証する必要があります前に、ディレクトリキャッシュエントリが有効と考えられている時間の長さを示すために維持されています。"
    },
    {
      "indent": 3,
      "text": "The revalidation technique parallels that discussed in the case of name caching. When the client is not changing the directory in question, checking the change attribute of the directory with GETATTR is adequate. The lifetime of the cache entry can be extended at these checkpoints. When a client is modifying the directory, the client needs to use the change_info4 data to determine whether there are other clients modifying the directory. If it is determined that no other client modifications are occurring, the client may update its directory cache to reflect its own changes.",
      "ja": "名前キャッシュの場合で説明した再検証技術の緯線。クライアントがGETATTRとディレクトリの変更属性をチェックし、問題のディレクトリを変更していない場合は十分です。キャッシュエントリの寿命は、これらのチェックポイントに拡張することができます。クライアントがディレクトリを変更している場合は、クライアントがディレクトリを変更する他のクライアントが存在するかどうかを判断するために変化_info4データを使用する必要があります。他のクライアントの変更が発生していないと判断された場合、クライアントは自身の変更を反映するために、そのディレクトリキャッシュを更新することができます。"
    },
    {
      "indent": 3,
      "text": "As demonstrated previously, directory caching requires that the client revalidate directory cache data by inspecting the change attribute of a directory at the point when the directory was cached. This requires that the server update the change attribute for directories when the contents of the corresponding directory is modified. For a client to use the change_info4 information appropriately and correctly, the server must report the pre- and post-operation change attribute values atomically. When the server is unable to report the before and after values atomically with respect to the directory operation, the server must indicate that fact in the change_info4 return value. When the information is not atomically reported, the client should not assume that other clients have not changed the directory.",
      "ja": "以前に実証されているように、ディレクトリキャッシュは、クライアントがディレクトリがキャッシュされた時点でのディレクトリの変更属性を調べることによって、ディレクトリキャッシュデータを再検証する必要があります。これは、対応するディレクトリの内容が変更されたときに、サーバがディレクトリの変更属性を更新する必要があります。適切かつ正確に変化_info4情報を使用するクライアントの場合、サーバーは、前後の動作変更がアトミック属性値を報告しなければなりません。サーバーは、ディレクトリ操作に関して原子論前後の値を報告することができない場合は、サーバーは変化_info4の戻り値であることを示す必要があります。情報がアトミックに報告されていない場合、クライアントは他のクライアントがディレクトリを変更していないことを仮定するべきではありません。"
    },
    {
      "indent": 0,
      "text": "10.9. Directory Delegations",
      "section_title": true,
      "ja": "10.9. ディレクトリ代表団"
    },
    {
      "indent": 0,
      "text": "10.9.1. Introduction to Directory Delegations",
      "section_title": true,
      "ja": "10.9.1. ディレクトリ代表団の概要"
    },
    {
      "indent": 3,
      "text": "Directory caching for the NFSv4.1 protocol, as previously described, is similar to file caching in previous versions. Clients typically cache directory information for a duration determined by the client. At the end of a predefined timeout, the client will query the server to see if the directory has been updated. By caching attributes, clients reduce the number of GETATTR calls made to the server to validate attributes. Furthermore, frequently accessed files and directories, such as the current working directory, have their attributes cached on the client so that some NFS operations can be performed without having to make an RPC call. By caching name and inode information about most recently looked up entries in a Directory Name Lookup Cache (DNLC), clients do not need to send LOOKUP calls to the server every time these files are accessed.",
      "ja": "NFSv4.1プロトコルのディレクトリキャッシュは、前述したように、以前のバージョンでキャッシュをファイルに類似しています。クライアントは通常、クライアントによって決定期間のディレクトリ情報をキャッシュします。事前に定義されたタイムアウトの終わりには、クライアントは、ディレクトリが更新されているかどうかを確認するためにサーバーを照会します。属性をキャッシュすることで、クライアントは属性を検証するためにサーバーに対して行われたGETATTR呼び出しの回数を減らします。いくつかのNFS操作がRPCコールを加えることなく実行することができるように、また、このような現在の作業ディレクトリとして頻繁にアクセスされるファイルやディレクトリは、クライアントにキャッシュされたその属性を持っています。最近ディレクトリ名ルックアップキャッシュ（DNLC）のエントリを見上げについて名前とiノード情報をキャッシュすることにより、クライアントがサーバーにこれらのファイルをアクセスするたびにLOOKUPコールを送信する必要はありません。"
    },
    {
      "indent": 3,
      "text": "This caching approach works reasonably well at reducing network traffic in many environments. However, it does not address environments where there are numerous queries for files that do not exist. In these cases of \"misses\", the client sends requests to the server in order to provide reasonable application semantics and promptly detect the creation of new directory entries. Examples of high miss activity are compilation in software development environments. The current behavior of NFS limits its potential scalability and wide-area sharing effectiveness in these types of environments. Other distributed stateful file system architectures such as AFS and DFS have proven that adding state around directory contents can greatly reduce network traffic in high-miss environments.",
      "ja": "このキャッシュ・アプローチは、多くの環境でネットワークトラフィックを削減することを合理的にうまく機能します。しかし、それは存在しないファイルのための多数のクエリが存在する環境には対応していません。 「ミス」のこれらのケースでは、クライアントは、合理的なアプリケーションのセマンティクスを提供し、速やかに新しいディレクトリエントリの作成を検出するためにサーバに要求を送信します。高いミス活動の例としては、ソフトウェア開発環境でコンパイルされています。 NFSの現在の動作は、このようなタイプの環境におけるその潜在的なスケーラビリティと広域共有の有効性を制限します。このようAFSとDFSのような他の分散ステートフルなファイル・システム・アーキテクチャは、ディレクトリの内容を中心に状態を追加することで大幅高ミス環境でのネットワークトラフィックを減少させることができることが実証されています。"
    },
    {
      "indent": 3,
      "text": "Delegation of directory contents is an OPTIONAL feature of NFSv4.1. Directory delegations provide similar traffic reduction benefits as with file delegations. By allowing clients to cache directory contents (in a read-only fashion) while being notified of changes, the client can avoid making frequent requests to interrogate the contents of slowly-changing directories, reducing network traffic and improving client performance. It can also simplify the task of determining whether other clients are making changes to the directory when the client itself is making many changes to the directory and changes are not serialized.",
      "ja": "ディレクトリの内容の委任は、NFSv4.1のオプション機能です。ディレクトリ代表団は、ファイルの代表団と同様のトラフィック削減の利点を提供します。クライアントは変更が通知されながら（読み取り専用形式で）ディレクトリの内容をキャッシュさせることにより、クライアントは、ネットワークトラフィックを削減し、クライアントのパフォーマンスを向上させること、ゆっくりと変化するディレクトリの内容を調べるために、頻繁な要求を避けることができます。また、他のクライアントは、クライアント自身がディレクトリに多くの変更を行っている際に、ディレクトリへの変更を行っていると、変更がシリアライズされていないかどうかを決定する作業を簡素化することができます。"
    },
    {
      "indent": 3,
      "text": "Directory delegations allow improved namespace cache consistency to be achieved through delegations and synchronous recalls, in the absence of notifications. In addition, if time-based consistency is sufficient, asynchronous notifications can provide performance benefits for the client, and possibly the server, under some common operating conditions such as slowly-changing and/or very large directories.",
      "ja": "ディレクトリ代表団は、通知がない場合には、改善された名前空間のキャッシュの一貫性は代表団と同期リコールを通じて達成することができます。時間ベースの一貫性が十分であればまた、非同期通知は、このようないくつかのゆっくりと変化するなどの一般的な動作条件および/または非常に大きなディレクトリの下に、クライアントのパフォーマンス上の利点を提供し、そしておそらくサーバーことができます。"
    },
    {
      "indent": 0,
      "text": "10.9.2. Directory Delegation Design",
      "section_title": true,
      "ja": "10.9.2. ディレクトリ委任デザイン"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 introduces the GET_DIR_DELEGATION (Section 18.39) operation to allow the client to ask for a directory delegation. The delegation covers directory attributes and all entries in the directory. If either of these change, the delegation will be recalled synchronously. The operation causing the recall will have to wait before the recall is complete. Any changes to directory entry attributes will not cause the delegation to be recalled.",
      "ja": "NFSv4.1は、クライアントがディレクトリの委任を求めることができるようにGET_DIR_DELEGATION（セクション18.39）の操作を紹介します。代表団は、ディレクトリの属性と、ディレクトリ内のすべてのエントリをカバーしています。これらの変更のいずれかの場合には、代表団は同期リコールされます。リコールの原因となる操作はリコールが完了する前に待機する必要があります。ディレクトリエントリの属性に対する変更は、代表団がリコールされることはありません。"
    },
    {
      "indent": 3,
      "text": "In addition to asking for delegations, a client can also ask for notifications for certain events. These events include changes to the directory's attributes and/or its contents. If a client asks for notification for a certain event, the server will notify the client when that event occurs. This will not result in the delegation being recalled for that client. The notifications are asynchronous and provide a way of avoiding recalls in situations where a directory is changing enough that the pure recall model may not be effective while trying to allow the client to get substantial benefit. In the absence of notifications, once the delegation is recalled the client has to refresh its directory cache; this might not be very efficient for very large directories.",
      "ja": "代表団を求めることに加えて、クライアントは、特定のイベントの通知を求めることができます。これらのイベントは、ディレクトリの属性および/またはその内容に変更が含まれています。クライアントは、特定のイベントの通知を要求する場合は、そのイベントが発生した場合、サーバはクライアントに通知します。これは、そのクライアントのためにリコールされた代表団にはなりません。通知は非同期であり、ディレクトリは、クライアントが実質的な利益を得ることができるようにしようとしているときに、純粋なリコールモデルが効果的ではないかもしれないことを十分に変化している状況でリコールを回避する方法を提供します。委任がリコールされるとの通知がない場合には、クライアントはそのディレクトリキャッシュを更新する必要があります。これは非常に大きなディレクトリのために非常に効率的ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "The delegation is read-only and the client may not make changes to the directory other than by performing NFSv4.1 operations that modify the directory or the associated file attributes so that the server has knowledge of these changes. In order to keep the client's namespace synchronized with the server, the server will notify the delegation-holding client (assuming it has requested notifications) of the changes made as a result of that client's directory-modifying operations. This is to avoid any need for that client to send subsequent GETATTR or READDIR operations to the server. If a single client is holding the delegation and that client makes any changes to the directory (i.e., the changes are made via operations sent on a session associated with the client ID holding the delegation), the delegation will not be recalled. Multiple clients may hold a delegation on the same directory, but if any such client modifies the directory, the server MUST recall the delegation from the other clients, unless those clients have made provisions to be notified of that sort of modification.",
      "ja": "代表団は、読み取り専用で、クライアントは、サーバがこれらの変更の知識を持っているように、ディレクトリまたは関連するファイルの属性を変更NFSv4.1操作を行うことによって以外のディレクトリに変更を加えることはできません。サーバと同期クライアントの名前空間を保つために、サーバーはそのクライアントのディレクトリ変更などの操作の結果として行われた変更の（それが通知を要求したと仮定した場合）委任保持をクライアントに通知します。これは、サーバへのその後のGETATTRまたはREADDIR操作を送信するために、そのクライアントのための任意の必要性を回避するためです。単一のクライアントが委任を保持していると、そのクライアントがディレクトリへの変更を行った場合（すなわち、変更が委任を保持しているクライアントのIDに関連付けられたセッションで送信操作を経て作られています）、委任がリコールされません。複数のクライアントが同じディレクトリに委任を保持することができるが、どのようにクライアントがディレクトリを変更する場合、それらのクライアントが変更のその種を通知する規定を作っていない限り、サーバーは、他のクライアントからの委任をリコールしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Delegations can be recalled by the server at any time. Normally, the server will recall the delegation when the directory changes in a way that is not covered by the notification, or when the directory changes and notifications have not been requested. If another client removes the directory for which a delegation has been granted, the server will recall the delegation.",
      "ja": "代表団は、任意の時点でサーバによって呼び出すことができます。通知によってカバーされていない方法で、ディレクトリの変更は、ディレクトリの変更および通知が要求されていない場合や、ときに通常、サーバーは、委任を思い出します。別のクライアントが委任が付与されているディレクトリを削除した場合、サーバーは、委任を思い出します。"
    },
    {
      "indent": 0,
      "text": "10.9.3. Attributes in Support of Directory Notifications",
      "section_title": true,
      "ja": "10.9.3. ディレクトリ通知のサポートの属性"
    },
    {
      "indent": 3,
      "text": "See Section 5.11 for a description of the attributes associated with directory notifications.",
      "ja": "ディレクトリの通知に関連付けられた属性の説明については、セクション5.11を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.9.4. Directory Delegation Recall",
      "section_title": true,
      "ja": "10.9.4. ディレクトリ委任リコール"
    },
    {
      "indent": 3,
      "text": "The server will recall the directory delegation by sending a callback to the client. It will use the same callback procedure as used for recalling file delegations. The server will recall the delegation when the directory changes in a way that is not covered by the notification. However, the server need not recall the delegation if attributes of an entry within the directory change.",
      "ja": "サーバーは、クライアントへのコールバックを送信することにより、ディレクトリ委任を思い出します。ファイルの代表団を呼び出すために使用されるようなことは、同じコールバックプロシージャを使用します。ディレクトリは、通知によって覆われていない方法で変更したときにサーバが委任を思い出します。ただし、サーバーは、ディレクトリの変更内のエントリの属性場合は委任を思い出す必要はありません。"
    },
    {
      "indent": 3,
      "text": "If the server notices that handing out a delegation for a directory is causing too many notifications to be sent out, it may decide to not hand out delegations for that directory and/or recall those already granted. If a client tries to remove the directory for which a delegation has been granted, the server will recall all associated delegations.",
      "ja": "ディレクトリの委任を配って、サーバーの通知が送信されるようにあまりにも多くの通知を引き起こしている場合は、そのディレクトリのための代表団を配るないことを決定および/またはすでに付与されたものを思い出すことがあります。クライアントは、委任が付与されているディレクトリを削除しようとすると、サーバーは、すべての関連する代表団を思い出します。"
    },
    {
      "indent": 3,
      "text": "The implementation sections for a number of operations describe situations in which notification or delegation recall would be required under some common circumstances. In this regard, a similar set of caveats to those listed in Section 10.2 apply.",
      "ja": "操作の数の実装のセクションでは、通知または委任リコールは、いくつかの一般的な状況下で必要とされるであろう状況を記述する。この点で、セクション10.2に記載されているものと同様の警告のセットが適用されます。"
    },
    {
      "indent": 3,
      "text": "o For CREATE, see Section 18.4.4.",
      "ja": "Oは項18.4.4を参照してください、CREATE。"
    },
    {
      "indent": 3,
      "text": "o For LINK, see Section 18.9.4.",
      "ja": "O LINKは、項18.9.4を参照。"
    },
    {
      "indent": 3,
      "text": "o For OPEN, see Section 18.16.4.",
      "ja": "O OPENについては、項18.16.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o For REMOVE, see Section 18.25.4.",
      "ja": "O REMOVEについては、項18.25.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o For RENAME, see Section 18.26.4.",
      "ja": "O RENAMEについては、項18.26.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o For SETATTR, see Section 18.30.4.",
      "ja": "O SETATTRについては、項18.30.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.9.5. Directory Delegation Recovery",
      "section_title": true,
      "ja": "10.9.5. ディレクトリ委任回復"
    },
    {
      "indent": 3,
      "text": "Recovery from client or server restart for state on regular files has two main goals: avoiding the necessity of breaking application guarantees with respect to locked files and delivery of updates cached at the client. Neither of these goals applies to directories protected by OPEN_DELEGATE_READ delegations and notifications. Thus, no provision is made for reclaiming directory delegations in the event of client or server restart. The client can simply establish a directory delegation in the same fashion as was done initially.",
      "ja": "ロックされたファイルと、クライアントでキャッシュアップデートの配信に関して、アプリケーションの保証を壊すの必要性を回避：通常のファイルの状態のために、クライアントまたはサーバの再起動からの回復は、主に2つの目標があります。これらの目標のどちらもOPEN_DELEGATE_READ代表団との通知によって保護されたディレクトリに適用されます。このように、何の規定は、クライアントまたはサーバの再起動の際にディレクトリの代表団を再生するために行われません。最初に行ったように、クライアントは、単純に同じ方法でディレクトリの委任を確立することができます。"
    },
    {
      "indent": 0,
      "text": "11. Multi-Server Namespace",
      "section_title": true,
      "ja": "11.マルチサーバの名前空間"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 supports attributes that allow a namespace to extend beyond the boundaries of a single server. It is RECOMMENDED that clients and servers support construction of such multi-server namespaces. Use of such multi-server namespaces is OPTIONAL, however, and for many purposes, single-server namespaces are perfectly acceptable. Use of multi-server namespaces can provide many advantages, however, by separating a file system's logical position in a namespace from the (possibly changing) logistical and administrative considerations that result in particular file systems being located on particular servers.",
      "ja": "NFSv4.1は、名前空間は、単一のサーバーの境界を超えて拡張することを可能にする属性をサポートしています。クライアントとサーバは、このようなマルチサーバの名前空間の構築をサポートすることが推奨されます。こうしたマルチサーバの名前空間の使用は、しかし、オプションであり、多くの目的のために、単一サーバーの名前空間は完全に許容されています。マルチサーバの名前空間を使用すると、特定のサーバー上に配置されている特定のファイルシステムになる（おそらく変更）物流や行政の配慮から、名前空間にファイルシステムの論理的な位置を分離することによって、しかし、多くの利点を提供することができます。"
    },
    {
      "indent": 0,
      "text": "11.1. Location Attributes",
      "section_title": true,
      "ja": "11.1. 場所属性"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 contains RECOMMENDED attributes that allow file systems on one server to be associated with one or more instances of that file system on other servers. These attributes specify such file system instances by specifying a server address target (either as a DNS name representing one or more IP addresses or as a literal IP address) together with the path of that file system within the associated single-server namespace.",
      "ja": "NFSv4.1は、一つのサーバ上のファイルシステムは、他のサーバー上のファイルシステムの1つ以上のインスタンスに関連付けることができるように推奨属性が含まれています。これらの属性は一緒に関連付けられている単一サーバーの名前空間内のそのファイルシステムのパスに（1つまたは複数のIPアドレスを表すDNS名として、またはリテラルIPアドレスなどのいずれか）サーバアドレスターゲットを指定して、ファイル・システム・インスタンスを指定します。"
    },
    {
      "indent": 3,
      "text": "The fs_locations_info RECOMMENDED attribute allows specification of one or more file system instance locations where the data corresponding to a given file system may be found. This attribute provides to the client, in addition to information about file system instance locations, significant information about the various file system instance choices (e.g., priority for use, writability, currency, etc.). It also includes information to help the client efficiently effect as seamless a transition as possible among multiple file system instances, when and if that should be necessary.",
      "ja": "fs_locations_info推奨属性は、特定のファイルシステムに対応するデータを見つけることができる1つ以上のファイル・システム・インスタンスの場所を指定することができます。この属性は、ファイル・システム・インスタンスの場所、さまざまなファイル・システム・インスタンスの選択肢についての重要な情報（例えば、使用のための優先順位、筆記、通貨など）に関する情報に加えて、クライアントに提供します。また、効率的に複数のファイル・システム・インスタンス間で可能な限りシームレスな移行をもたらし、ときにそれが必要であるべき場合に、クライアントを支援するための情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The fs_locations RECOMMENDED attribute is inherited from NFSv4.0 and only allows specification of the file system locations where the data corresponding to a given file system may be found. Servers SHOULD make this attribute available whenever fs_locations_info is supported, but client use of fs_locations_info is to be preferred.",
      "ja": "fs_位置推奨属性がNFSv4.0から継承のみ与えられたファイルシステムに対応するデータを見つけることができるファイルシステムの場所の指定を可能にします。 fs_locations_infoがサポートされるたびにサーバは、この属性を利用できるようにする必要がありますが、fs_locations_infoのクライアントの使用が好まれるべきです。"
    },
    {
      "indent": 0,
      "text": "11.2. File System Presence or Absence",
      "section_title": true,
      "ja": "11.2. システムの有無をファイル"
    },
    {
      "indent": 3,
      "text": "A given location in an NFSv4.1 namespace (typically but not necessarily a multi-server namespace) can have a number of file system instance locations associated with it (via the fs_locations or fs_locations_info attribute). There may also be an actual current file system at that location, accessible via normal namespace operations (e.g., LOOKUP). In this case, the file system is said to be \"present\" at that position in the namespace, and clients will typically use it, reserving use of additional locations specified via the location-related attributes to situations in which the principal location is no longer available.",
      "ja": "NFSv4.1名前空間（典型的には必ずしも必要ではないが、マルチサーバの名前空間）内の指定された位置は（fs_位置又はfs_locations_info属性を介して）、それに関連付けられたファイル・システム・インスタンスの位置の数を有することができます。また、（例えば、参照）、その位置で通常名前空間操作を介してアクセス可能な実際の現在のファイルシステムが存在してもよいです。この場合、ファイルシステムは、名前空間内のその位置で「存在」であると言われ、そしてクライアントは、典型的には、主位置は、もはやである状況に位置関連の属性を介して指定された追加の場所の使用を予約する、それを使用します利用可能。"
    },
    {
      "indent": 3,
      "text": "When there is no actual file system at the namespace location in question, the file system is said to be \"absent\". An absent file system contains no files or directories other than the root. Any reference to it, except to access a small set of attributes useful in determining alternate locations, will result in an error, NFS4ERR_MOVED. Note that if the server ever returns the error NFS4ERR_MOVED, it MUST support the fs_locations attribute and SHOULD support the fs_locations_info and fs_status attributes.",
      "ja": "問題のネームスペースの場所での実際のファイルシステムが存在しない場合、ファイルシステムは、「不在」と言われています。不在のファイルシステムは、ルート以外のファイルやディレクトリが含まれていません。別の場所を決定するのに有用な属性の小さなセットにアクセスすることを除いて、それへの参照は、エラー、NFS4ERR_MOVEDをもたらすであろう。サーバーが今までエラーNFS4ERR_MOVEDを返した場合、それはfs_位置の属性をサポートしなければならないとfs_locations_infoとfs_status属性をサポートすべきであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "While the error name suggests that we have a case of a file system that once was present, and has only become absent later, this is only one possibility. A position in the namespace may be permanently absent with the set of file system(s) designated by the location attributes being the only realization. The name NFS4ERR_MOVED reflects an earlier, more limited conception of its function, but this error will be returned whenever the referenced file system is absent, whether it has moved or not.",
      "ja": "エラー名は、我々がかつて存在したファイルシステムのケースを持っていることを示唆している、とだけ後で不在となっているが、これは唯一の可能性です。名前空間内の位置にのみ実現される場所属性で指定されたファイル・システム（単数または複数）のセットと恒久的に存在しなくてもよいです。名前NFS4ERR_MOVEDは、その機能の以前のバージョンでは、より限定された概念を反映しているが、参照されるファイルシステムは、それが移動したか否か、存在しないときには、このエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Except in the case of GETATTR-type operations (to be discussed later), when the current filehandle at the start of an operation is within an absent file system, that operation is not performed and the error NFS4ERR_MOVED is returned, to indicate that the file system is absent on the current server.",
      "ja": "GETATTR型操作の場合を除いて運転開始時の現在のファイルハンドルが存在しないファイル・システム内にある場合、その操作が行われないとNFS4ERR_MOVEDが返されるエラーは、ファイルがあることを示すために、（後述します）システムは、現在のサーバー上に存在しません。"
    },
    {
      "indent": 3,
      "text": "Because a GETFH cannot succeed if the current filehandle is within an absent file system, filehandles within an absent file system cannot be transferred to the client. When a client does have filehandles within an absent file system, it is the result of obtaining them when the file system was present, and having the file system become absent subsequently.",
      "ja": "現在のファイルハンドルは、存在しないファイルシステム内にある場合GETFHが成功することはできませんので、不在のファイルシステム内のファイルハンドルをクライアントに転送することはできません。クライアントは、存在しないファイルシステム内のファイルハンドルを持っている場合は、ファイルシステムが存在していたときにそれらを取得し、その後不在となったファイルシステムを持つことの結果です。"
    },
    {
      "indent": 3,
      "text": "It should be noted that because the check for the current filehandle being within an absent file system happens at the start of every operation, operations that change the current filehandle so that it is within an absent file system will not result in an error. This allows such combinations as PUTFH-GETATTR and LOOKUP-GETATTR to be used to get attribute information, particularly location attribute information, as discussed below.",
      "ja": "現在のファイルハンドルは、存在しないファイルシステム内にあることのチェックは、すべての操作の開始時に起こるので、それがないファイルシステム内にあるように、現在のファイルハンドルを変更する操作はエラーになりませんことに留意すべきです。これは、後述するようにPUTFH-GETATTRおよびLOOKUP、GETATTRのような組み合わせが、特に位置属性情報を、属性情報を取得するために使用されることを可能にします。"
    },
    {
      "indent": 3,
      "text": "The RECOMMENDED file system attribute fs_status can be used to interrogate the present/absent status of a given file system.",
      "ja": "推奨されるファイルシステムは、fs_statusは、特定のファイルシステムの存在/不在の状態を調べるために使用することができる属性。"
    },
    {
      "indent": 0,
      "text": "11.3. Getting Attributes for an Absent File System",
      "section_title": true,
      "ja": "11.3. 不在ファイルシステム用の属性の取得"
    },
    {
      "indent": 3,
      "text": "When a file system is absent, most attributes are not available, but it is necessary to allow the client access to the small set of attributes that are available, and most particularly those that give information about the correct current locations for this file system: fs_locations and fs_locations_info.",
      "ja": "ファイルシステムが存在しない場合、ほとんどの属性は利用できませんが、最も特に、このファイルシステムの正しい現在の場所についての情報を提供しているもの使用可能な属性の小さなセットへのクライアントアクセスを許可する必要があり、かつ：fs_位置そしてfs_locations_info。"
    },
    {
      "indent": 0,
      "text": "11.3.1. GETATTR within an Absent File System",
      "section_title": true,
      "ja": "11.3.1. 不在ファイルシステム内のGETATTR"
    },
    {
      "indent": 3,
      "text": "As mentioned above, an exception is made for GETATTR in that attributes may be obtained for a filehandle within an absent file system. This exception only applies if the attribute mask contains at least one attribute bit that indicates the client is interested in a result regarding an absent file system: fs_locations, fs_locations_info, or fs_status. If none of these attributes is requested, GETATTR will result in an NFS4ERR_MOVED error.",
      "ja": "上述のようにそれが存在しないファイルシステム内のファイルハンドルのために得ることができる属性では、例外がGETATTRのために作られています。 fs_位置、fs_locations_info、またはfs_status：属性マスクは、クライアントが存在しないファイルシステムについての結果に興味があることを示し、少なくとも1つの属性のビットが含まれている場合、この例外にのみ適用されます。これらの属性のどれもが要求されていない場合、GETATTRはNFS4ERR_MOVEDエラーになります。"
    },
    {
      "indent": 3,
      "text": "When a GETATTR is done on an absent file system, the set of supported attributes is very limited. Many attributes, including those that are normally REQUIRED, will not be available on an absent file system. In addition to the attributes mentioned above (fs_locations, fs_locations_info, fs_status), the following attributes SHOULD be available on absent file systems. In the case of RECOMMENDED attributes, they should be available at least to the same degree that they are available on present file systems.",
      "ja": "GETATTRが不在のファイルシステム上で実行された場合、サポートされる属性のセットは非常に限られています。通常必要とされるものを含む多くの属性は、存在しないファイルシステム上で使用できなくなります。 （fs_位置、fs_locations_info、fs_status）上記の属性に加えて、以下の属性が存在しないファイルシステム上で利用可能であるべきです。推奨属性の場合、彼らは現在のファイルシステム上で利用可能であること、少なくとも同じ程度に利用可能であるべきです。"
    },
    {
      "indent": 3,
      "text": "change_policy: This attribute is useful for absent file systems and can be helpful in summarizing to the client when any of the location-related attributes change.",
      "ja": "change_policy：この属性は存在しないファイルシステムに有用であり、位置関連の属性のいずれかが変更されたときにクライアントにまとめるのに役立つことができます。"
    },
    {
      "indent": 3,
      "text": "fsid: This attribute should be provided so that the client can determine file system boundaries, including, in particular, the boundary between present and absent file systems. This value must be different from any other fsid on the current server and need have no particular relationship to fsids on any particular destination to which the client might be directed.",
      "ja": "FSID：クライアントは、ファイルシステムの境界を決定することができるように、この属性は、特に、を含む、現在および不在のファイルシステムとの間の境界を提供する必要があります。この値は、現行のサーバー上の他のFSIDと異なることと、クライアントが向けられる可能性があるに任意の特定の宛先にfsidsには特に関係がない必要なければなりません。"
    },
    {
      "indent": 3,
      "text": "mounted_on_fileid: For objects at the top of an absent file system, this attribute needs to be available. Since the fileid is within the present parent file system, there should be no need to reference the absent file system to provide this information.",
      "ja": "mounted_on_fileid：不在のファイルシステムの一番上にあるオブジェクトの場合、この属性は利用できるようにする必要があります。 FILEID本親ファイル・システム内にあるので、この情報を提供するために存在しないファイルシステムを参照する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Other attributes SHOULD NOT be made available for absent file systems, even when it is possible to provide them. The server should not assume that more information is always better and should avoid gratuitously providing additional information.",
      "ja": "他の属性は、それらを提供することが可能である場合でも、不在のファイルシステムのために利用可能行うべきではありません。サーバは、より多くの情報が常に優れていることを前提とすべきではなく、付加的な情報を提供する無償避けるべきです。"
    },
    {
      "indent": 3,
      "text": "When a GETATTR operation includes a bit mask for one of the attributes fs_locations, fs_locations_info, or fs_status, but where the bit mask includes attributes that are not supported, GETATTR will not return an error, but will return the mask of the actual attributes supported with the results.",
      "ja": "GETATTR操作がビットマスクがサポートされない属性を含むビット属性fs_位置の一つのためのマスク、fs_locations_info、又はfs_status、しかしを含む場合、GETATTRはエラーを返しませんが、でサポートされている実際の属性のマスクが返され結果。"
    },
    {
      "indent": 3,
      "text": "Handling of VERIFY/NVERIFY is similar to GETATTR in that if the attribute mask does not include fs_locations, fs_locations_info, or fs_status, the error NFS4ERR_MOVED will result. It differs in that any appearance in the attribute mask of an attribute not supported for an absent file system (and note that this will include some normally REQUIRED attributes) will also cause an NFS4ERR_MOVED result.",
      "ja": "VERIFY / NVERIFYを処理する属性マスクはfs_位置、fs_locations_info、またはfs_statusが含まれていない場合は、エラーNFS4ERR_MOVEDが発生することでGETATTRに似ています。それは存在しないファイルシステムではサポートされていない属性の属性マスク（これは、いくつかの通常必要な属性が含まれることに注意）のいずれかの外見もNFS4ERR_MOVED結果を引き起こすことで異なっています。"
    },
    {
      "indent": 0,
      "text": "11.3.2. READDIR and Absent File Systems",
      "section_title": true,
      "ja": "11.3.2.  READDIRと不在ファイルシステム"
    },
    {
      "indent": 3,
      "text": "A READDIR performed when the current filehandle is within an absent file system will result in an NFS4ERR_MOVED error, since, unlike the case of GETATTR, no such exception is made for READDIR.",
      "ja": "現在のファイルハンドルがGETATTRの場合とは異なり、そのような例外がREADDIRのために作られていない、ので、NFS4ERR_MOVEDエラーになります存在しないファイル・システム内にある場合READDIRを行います。"
    },
    {
      "indent": 3,
      "text": "Attributes for an absent file system may be fetched via a READDIR for a directory in a present file system, when that directory contains the root directories of one or more absent file systems. In this case, the handling is as follows:",
      "ja": "存在しないファイルシステムの属性は、そのディレクトリが1つの以上存在しないファイルシステムのルートディレクトリを含む場合、本ファイルシステム内のディレクトリのREADDIRを介してフェッチされてもよいです。この場合、以下のように、取り扱いは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the attribute set requested includes one of the attributes fs_locations, fs_locations_info, or fs_status, then fetching of attributes proceeds normally and no NFS4ERR_MOVED indication is returned, even when the rdattr_error attribute is requested.",
      "ja": "要求された属性セットが属性fs_位置の一つ、fs_locations_info、又はfs_statusを含む場合、O、次いで属性のフェッチするrdattr_error属性が要求された場合でも、正常に移行しないNFS4ERR_MOVED指示が返されていません。"
    },
    {
      "indent": 3,
      "text": "o If the attribute set requested does not include one of the attributes fs_locations, fs_locations_info, or fs_status, then if the rdattr_error attribute is requested, each directory entry for the root of an absent file system will report NFS4ERR_MOVED as the value of the rdattr_error attribute.",
      "ja": "要求された属性セットに属性fs_位置の1、fs_locations_info、またはfs_statusが含まれていない場合rdattr_error属性が要求された場合、O、そして、不在のファイルシステムのルートの各ディレクトリエントリはrdattr_error属性の値としてNFS4ERR_MOVEDを報告します。"
    },
    {
      "indent": 3,
      "text": "o If the attribute set requested does not include any of the attributes fs_locations, fs_locations_info, fs_status, or rdattr_error, then the occurrence of the root of an absent file system within the directory will result in the READDIR failing with an NFS4ERR_MOVED error.",
      "ja": "要求された属性セットに属性fs_位置、fs_locations_info、fs_status、またはrdattr_errorのいずれかが含まれていない場合は、O、そのディレクトリ内に存在し、ファイルシステムのルートの発生がNFS4ERR_MOVEDエラーで失敗READDIRになります。"
    },
    {
      "indent": 3,
      "text": "o The unavailability of an attribute because of a file system's absence, even one that is ordinarily REQUIRED, does not result in any error indication. The set of attributes returned for the root directory of the absent file system in that case is simply restricted to those actually available.",
      "ja": "なぜなら、ファイルシステムの不在の属性が利用できない、通常必要な場合でも1 O、任意のエラー表示にはなりません。その場合には存在しないファイルシステムのルートディレクトリのために返される属性のセットは、単に実際に利用可能なものに限定されます。"
    },
    {
      "indent": 0,
      "text": "11.4. Uses of Location Information",
      "section_title": true,
      "ja": "11.4. 位置情報を使用しています"
    },
    {
      "indent": 3,
      "text": "The location-bearing attributes (fs_locations and fs_locations_info), together with the possibility of absent file systems, provide a number of important facilities in providing reliable, manageable, and scalable data access.",
      "ja": "一緒に存在しないファイルシステムの可能性のある場所担持属性（fs_位置とfs_locations_info）は、信頼性管理、およびスケーラブルなデータアクセスを提供する際に重要な設備の数を提供します。"
    },
    {
      "indent": 3,
      "text": "When a file system is present, these attributes can provide alternative locations, to be used to access the same data, in the event of server failures, communications problems, or other difficulties that make continued access to the current file system impossible or otherwise impractical. Under some circumstances, multiple alternative locations may be used simultaneously to provide higher-performance access to the file system in question. Provision of such alternate locations is referred to as \"replication\" although there are cases in which replicated sets of data are not in fact present, and the replicas are instead different paths to the same data.",
      "ja": "ファイルシステムが存在する場合、これらの属性は、サーバの障害、コミュニケーションの問題、または不可能あるいは実用的でない現在のファイルシステムへの継続的なアクセスを行う他の困難の場合には、同じデータにアクセスするために使用されるように、代わりの場所を提供することができます。いくつかの状況下では、複数の代替の場所は、問題のファイルシステムへの高性能なアクセスを提供するために同時に使用することができます。そのような別の場所の提供は、データのセットが実際に存在しない、およびレプリカではなく、同じデータに対して異なる経路で複製される場合があるが、「複製」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "When a file system is present and becomes absent, clients can be given the opportunity to have continued access to their data, at an alternate location. In this case, a continued attempt to use the data in the now-absent file system will result in an NFS4ERR_MOVED error and, at that point, the successor locations (typically only one although multiple choices are possible) can be fetched and used to continue access. Transfer of the file system contents to the new location is referred to as \"migration\", but it should be kept in mind that there are cases in which this term can be used, like \"replication\", when there is no actual data migration per se.",
      "ja": "ファイルシステムが存在し、存在しなくなった場合、クライアントは、別の場所で、それらのデータへのアクセスを継続する機会を与えることができます。この場合には、今では存在しないファイル・システム内のデータを使用し続けて試みはNFS4ERR_MOVEDエラーになりますと、その時点で、後続の位置は、（典型的には唯一の複数の選択肢が可能であるが）フェッチさと継続するために使用することができアクセス。新しい場所へのファイルシステムの内容の転送は、「移行」と呼ばれていますが、この用語は実際のデータ移行あたりがない「複製」、のように、使用することができる場合があることを心に留めておくべきですSE。"
    },
    {
      "indent": 3,
      "text": "Where a file system was not previously present, specification of file system location provides a means by which file systems located on one server can be associated with a namespace defined by another server, thus allowing a general multi-server namespace facility. A designation of such a location, in place of an absent file system, is called a \"referral\".",
      "ja": "ファイルシステムが以前に存在しなかった場合、ファイルシステムの場所の指定は、1台のサーバー上にあるファイルシステムは、このように一般的なマルチサーバのネームスペースの機能を可能にする、別のサーバによって定義された名前空間に関連付けすることができる手段を提供します。そのような場所の指定は、存在しないファイルシステムの代わりに、「照会」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Because client support for location-related attributes is OPTIONAL, a server may (but is not required to) take action to hide migration and referral events from such clients, by acting as a proxy, for example. The server can determine the presence of client support from the arguments of the EXCHANGE_ID operation (see Section 18.35.3).",
      "ja": "場所関連の属性のためのクライアントのサポートはオプションであるため、サーバーは、例えば、プロキシとして機能することによって、このようなクライアントからの移行と紹介イベントを非表示にする行動を取る（ただし、する必要はありません）があります。サーバがEXCHANGE_ID操作の引数からクライアントのサポートの有無を決定することができます（項18.35.3を参照してください）。"
    },
    {
      "indent": 0,
      "text": "11.4.1. File System Replication",
      "section_title": true,
      "ja": "11.4.1. システムのレプリケーションファイル"
    },
    {
      "indent": 3,
      "text": "The fs_locations and fs_locations_info attributes provide alternative locations, to be used to access data in place of or in addition to the current file system instance. On first access to a file system, the client should obtain the value of the set of alternate locations by interrogating the fs_locations or fs_locations_info attribute, with the latter being preferred.",
      "ja": "fs_位置と属性fs_locations_infoの代わりに、または現在のファイルシステムインスタンスに加えて、データにアクセスするために使用されるように、代替の場所を提供しています。ファイルシステムへの最初のアクセスで、クライアントは、後者が好ましいと、fs_位置又はfs_locations_info属性を問い合わせることによって、別の場所のセットの値を得るべきです。"
    },
    {
      "indent": 3,
      "text": "In the event that server failures, communications problems, or other difficulties make continued access to the current file system impossible or otherwise impractical, the client can use the alternate locations as a way to get continued access to its data. Depending on specific attributes of these alternate locations, as indicated within the fs_locations_info attribute, multiple locations may be used simultaneously, to provide higher performance through the exploitation of multiple paths between client and target file system.",
      "ja": "サーバの障害、コミュニケーションの問題、または他の困難は、現在のファイルシステムへの継続的なアクセスが不可能あるいは実用的でないという場合には、クライアントはそのデータへの継続的なアクセスを取得する方法として、別の場所を使用することができます。これらの代替の場所の特定の属性に応じて、fs_locations_info属性内に示されるように、複数の場所は、クライアントとターゲット・ファイルシステムとの間の複数のパスの利用を通じて、より高い性能を提供するために、同時に使用することができます。"
    },
    {
      "indent": 3,
      "text": "The alternate locations may be physical replicas of the (typically read-only) file system data, or they may reflect alternate paths to the same server or provide for the use of various forms of server clustering in which multiple servers provide alternate ways of accessing the same physical file system. How these different modes of file system transition are represented within the fs_locations and fs_locations_info attributes and how the client deals with file system transition issues will be discussed in detail below.",
      "ja": "別の場所（通常は読み取り専用）ファイル・システム・データの物理的複製とすることができる、またはそれらは同じサーバに代替パスを反映するか、複数のサーバがアクセスする別の方法を提供しているサーバのクラスタリングの種々の形態の使用を提供することができます同じ物理ファイルシステム。どのファイルシステム移行のこれらの異なるモードはfs_位置の範囲内と属性fs_locations_info表現され、どのようにファイルシステムの移行の問題とクライアントのお得な情報は、以下に詳細に説明します。"
    },
    {
      "indent": 3,
      "text": "Multiple server addresses, whether they are derived from a single entry with a DNS name representing a set of IP addresses or from multiple entries each with its own server address, may correspond to the same actual server. The fact that two addresses correspond to the same server is shown by a common so_major_id field within the eir_server_owner field returned by EXCHANGE_ID (see Section 18.35.3).",
      "ja": "それらは、それ自身のサーバアドレスと各IPアドレスの組を表すDNS名を持つ単一のエントリまたは複数のエントリから誘導されるかどうか複数のサーバアドレスは、同じ実際のサーバに対応することができます。 2つのアドレスが同一のサーバに対応するという事実をEXCHANGE_IDによって返さeir_server_ownerフィールド内の共通so_major_idフィールドによって示されている（セクション18.35.3を参照のこと）。"
    },
    {
      "indent": 3,
      "text": "For a detailed discussion of how server address targets interact with the determination of server identity specified by the server owner field, see Section 11.5.",
      "ja": "サーバアドレスのターゲットは、サーバーの所有者フィールドで指定されたサーバーIDの決意と対話する方法の詳細については、11.5節を参照してください。"
    },
    {
      "indent": 0,
      "text": "11.4.2. File System Migration",
      "section_title": true,
      "ja": "11.4.2. ファイルシステムへの移行"
    },
    {
      "indent": 3,
      "text": "When a file system is present and becomes absent, clients can be given the opportunity to have continued access to their data, at an alternate location, as specified by the fs_locations or fs_locations_info attribute. Typically, a client will be accessing the file system in question, get an NFS4ERR_MOVED error, and then use the fs_locations or fs_locations_info attribute to determine the new location of the data. When fs_locations_info is used, additional information will be available that will define the nature of the client's handling of the transition to a new server.",
      "ja": "ファイルシステムが存在し、存在しなくなったときfs_位置又はfs_locations_info属性によって指定されるように、クライアントは、別の場所で、それらのデータへの継続的なアクセスを有する機会を与えることができます。一般的に、クライアントはNFS4ERR_MOVEDのエラーを取得し、問題のファイルシステムにアクセスされ、その後、データの新しい場所を決定するためにfs_位置やfs_locations_info属性を使用します。 fs_locations_infoを使用する場合は、追加情報が新しいサーバーへの移行のクライアントの取り扱いの性質を定義することを利用できるようになります。"
    },
    {
      "indent": 3,
      "text": "Such migration can be helpful in providing load balancing or general resource reallocation. The protocol does not specify how the file system will be moved between servers. It is anticipated that a number of different server-to-server transfer mechanisms might be used with the choice left to the server implementor. The NFSv4.1 protocol specifies the method used to communicate the migration event between client and server.",
      "ja": "このような移行は、負荷分散や、一般的なリソースの再配分を提供するのに役立つことができます。プロトコルは、ファイルシステムがサーバ間で移動する方法を指定しません。異なるサーバー間の転送メカニズムの数は、サーバの実装者に任さ選択して使用されるかもしれないことが予想されます。 NFSv4.1プロトコルは、クライアントとサーバとの間の移行イベントを通信するために使用される方法を指定します。"
    },
    {
      "indent": 3,
      "text": "The new location may be an alternate communication path to the same server or, in the case of various forms of server clustering, another server providing access to the same physical file system. The client's responsibilities in dealing with this transition depend on the specific nature of the new access path as well as how and whether data was in fact migrated. These issues will be discussed in detail below.",
      "ja": "新しい場所は、同じサーバまたはサーバのクラスタリングの種々の形態の場合には、同一の物理ファイルシステムへのアクセスを提供する他のサーバへの代替通信経路であってもよいです。この移行に対処するクライアントの責任は、特定の新しいアクセス・パスの性質だけでなく、どのようにして、データが実際に移行されたかどうかに依存します。これらの問題は、以下に詳細に説明します。"
    },
    {
      "indent": 3,
      "text": "When multiple server addresses correspond to the same actual server, as shown by a common value for the so_major_id field of the eir_server_owner field returned by EXCHANGE_ID, the location or locations may designate alternate server addresses in the form of specific server network addresses. These can be used to access the file system in question at those addresses and when it is no longer accessible at the original address.",
      "ja": "複数のサーバー・アドレスが同じ実際のサーバに対応する場合EXCHANGE_IDによって返さeir_server_ownerフィールドのso_major_idフィールドの共通の値によって示されるように、位置または場所は、特定のサーバのネットワークアドレスの形で代替サーバのアドレスを指定することができます。これらは、これらのアドレスで、問題のファイルシステムにアクセスするために使用することができ、それは元のアドレスにアクセスできなくなったとき。"
    },
    {
      "indent": 3,
      "text": "Although a single successor location is typical, multiple locations may be provided, together with information that allows priority among the choices to be indicated, via information in the fs_locations_info attribute. Where suitable, clustering mechanisms make it possible to provide multiple identical file systems or paths to them; this allows the client the opportunity to deal with any resource or communications issues that might limit data availability.",
      "ja": "単一後継位置が典型的であるが、複数の位置が一緒fs_locations_info属性の情報を介して、選択肢のうち優先順位が指示されることを可能にする情報を、提供してもよいです。ここで適切な、クラスタリング機構が、それらに複数の同一のファイルシステムまたは経路を提供することを可能にします。これはクライアントにデータの可用性を制限する可能性がある任意のリソースまたは通信の問題に対処するための機会を可能にします。"
    },
    {
      "indent": 3,
      "text": "When an alternate location is designated as the target for migration, it must designate the same data (with metadata being the same to the degree indicated by the fs_locations_info attribute). Where file systems are writable, a change made on the original file system must be visible on all migration targets. Where a file system is not writable but represents a read-only copy (possibly periodically updated) of a writable file system, similar requirements apply to the propagation of updates. Any change visible in the original file system must already be effected on all migration targets, to avoid any possibility that a client, in effecting a transition to the migration target, will see any reversion in file system state.",
      "ja": "別の場所を移動するための対象として指定された場合には、（メタデータがfs_locations_info属性によって示される程度に同じである）同じデータを指定しなければなりません。ファイルシステムが書き込み可能である場合、元のファイルシステム上で行われた変更は、すべての移行のターゲットに表示されなければなりません。ファイルシステムが書き込み可能ではありませんが、書き込み可能なファイルシステムの読み取り専用コピー（おそらく定期的に更新）を表し、同様の要件は、更新の伝播に適用されます。元のファイルシステムに見える変更はすでにクライアントは、移行先への移行を行うには、ファイルシステムの状態のいずれかの復帰を参照することを任意の可能性を回避するために、すべての移行対象に行なわれなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.4.3. Referrals",
      "section_title": true,
      "ja": "11.4.3. 紹介"
    },
    {
      "indent": 3,
      "text": "Referrals provide a way of placing a file system in a location within the namespace essentially without respect to its physical location on a given server. This allows a single server or a set of servers to present a multi-server namespace that encompasses file systems located on multiple servers. Some likely uses of this include establishment of site-wide or organization-wide namespaces, or even knitting such together into a truly global namespace.",
      "ja": "照会は、指定されたサーバー上の物理的位置に関係なく、本質的に名前空間内の場所にファイルシステムを配置する方法を提供します。これは、単一のサーバまたはサーバのセットは、複数のサーバー上にあるファイル・システムを含むマルチサーバーの名前空間を提示することができます。このいくつかの可能性の高い用途は、サイト全体または組織全体のネームスペース、あるいは真のグローバル名前空間に一緒に、このような編みの確立が含まれます。"
    },
    {
      "indent": 3,
      "text": "Referrals occur when a client determines, upon first referencing a position in the current namespace, that it is part of a new file system and that the file system is absent. When this occurs, typically by receiving the error NFS4ERR_MOVED, the actual location or locations of the file system can be determined by fetching the fs_locations or fs_locations_info attribute.",
      "ja": "クライアントが判断した場合紹介は、新しいファイルシステムの一部であり、ファイルシステムが存在しないことをことを、最初に現在の名前空間での位置を参照すると、発生します。これが発生すると、典型的には、エラーNFS4ERR_MOVEDを受信することによって、ファイルシステムの実際の位置または位置はfs_位置又はfs_locations_info属性をフェッチすることによって決定することができます。"
    },
    {
      "indent": 3,
      "text": "The locations-related attribute may designate a single file system location or multiple file system locations, to be selected based on the needs of the client. The server, in the fs_locations_info attribute, may specify priorities to be associated with various file system location choices. The server may assign different priorities to different locations as reported to individual clients, in order to adapt to client physical location or to effect load balancing. When both read-only and read-write file systems are present, some of the read-only locations might not be absolutely up-to-date (as they would have to be in the case of replication and migration). Servers may also specify file system locations that include client-substituted variables so that different clients are referred to different file systems (with different data contents) based on client attributes such as CPU architecture.",
      "ja": "位置関連の属性は、クライアントのニーズに基づいて選択される、単一のファイルシステムの場所または複数のファイルシステムの場所を指定することができます。サーバは、fs_locations_info属性で、優先順位は、さまざまなファイルシステムの場所の選択に関連すると指定してもよいです。個々のクライアントに報告したように、サーバはクライアントの物理的な場所に適応するか、負荷分散を行うために、別の場所に異なる優先順位を割り当てることができます。両方の読み取り専用および読み書きファイルシステムが存在する場合、読み取り専用の場所のいくつかはではないかもしれません絶対に最新の（彼らは複製と移行の場合にはでなければならないであろうと）。サーバはまた、異なるクライアントは、クライアントがそのようなCPUアーキテクチャなどの属性に基づいて、（異なるデータ内容を有する）異なるファイルシステムと呼ばれているように、クライアント置換変数を含むファイルシステムの場所を指定することができます。"
    },
    {
      "indent": 3,
      "text": "When the fs_locations_info attribute indicates that there are multiple possible targets listed, the relationships among them may be important to the client in selecting which one to use. The same rules specified in Section 11.4.1 defining the appropriate standards",
      "ja": "fs_locations_info属性がリストされている複数の可能な目標があることを示している場合、それらの間の関係は、使用する1選択中のクライアントに重要かもしれません。適切な標準を定義11.4.1項で指定された同じルール"
    },
    {
      "indent": 3,
      "text": "for the data propagation apply to these multiple replicas as well. For example, the client might prefer a writable target on a server that has additional writable replicas to which it subsequently might switch. Note that, as distinguished from the case of replication, there is no need to deal with the case of propagation of updates made by the current client, since the current client has not accessed the file system in question.",
      "ja": "データ伝播のためにも、これらの複数のレプリカに適用されます。例えば、クライアントは、それがその後に切り替える可能性があるために、追加の書き込み可能なレプリカを持つサーバー上の書き込み可能なターゲットを好むかもしれません。現在のクライアントは、問題のファイルシステムにアクセスしていないため、複製の場合と区別として、現在のクライアントで行われた更新の伝播の場合に対処する必要がない、ということに注意してください。"
    },
    {
      "indent": 3,
      "text": "Use of multi-server namespaces is enabled by NFSv4.1 but is not required. The use of multi-server namespaces and their scope will depend on the applications used and system administration preferences.",
      "ja": "マルチサーバーの名前空間の使用はNFSv4.1で有効になっていますが、必須ではありません。マルチサーバの名前空間とその範囲の使用は、使用するアプリケーションやシステム管理の好みに依存します。"
    },
    {
      "indent": 3,
      "text": "Multi-server namespaces can be established by a single server providing a large set of referrals to all of the included file systems. Alternatively, a single multi-server namespace may be administratively segmented with separate referral file systems (on separate servers) for each separately administered portion of the namespace. The top-level referral file system or any segment may use replicated referral file systems for higher availability.",
      "ja": "マルチサーバの名前空間が含まれるファイルシステムのすべてに紹介の大規模なセットを提供する単一のサーバによって確立することができます。あるいは、単一のマルチサーバの名前空間は、名前空間管理のそれぞれ別々に投与するための部分（別のサーバー上の）別リファーラルファイルシステムに分割することができます。トップレベルのリファーラルファイルシステムまたは任意のセグメントは、より高い可用性のために複製リファーラルファイルシステムを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Generally, multi-server namespaces are for the most part uniform, in that the same data made available to one client at a given location in the namespace is made available to all clients at that location. However, there are facilities provided that allow different clients to be directed to different sets of data, so as to adapt to such client characteristics as CPU architecture.",
      "ja": "一般的に、マルチサーバの名前空間は、その名前空間内の指定された場所にあるクライアントが利用できるように同じデータがその場所ですべてのクライアントで使用できるようになり、大部分の均一なためです。しかし、CPUのアーキテクチャなどのクライアントの特性に適応するように、異なるクライアントが異なるデータセットを対象とすることができるように提供される機能があります。"
    },
    {
      "indent": 0,
      "text": "11.5. Location Entries and Server Identity",
      "section_title": true,
      "ja": "11.5. 場所エントリとサーバのアイデンティティ"
    },
    {
      "indent": 3,
      "text": "As mentioned above, a single location entry may have a server address target in the form of a DNS name that may represent multiple IP addresses, while multiple location entries may have their own server address targets that reference the same server. Whether two IP addresses designate the same server is indicated by the existence of a common so_major_id field within the eir_server_owner field returned by EXCHANGE_ID (see Section 18.35.3), subject to further verification (for details see Section 2.10.5).",
      "ja": "上述したように、複数の位置のエントリが同じサーバを参照する独自のサーバ・アドレス・ターゲットを有することができる、単一の位置エントリは、複数のIPアドレスを表すことができるDNS名の形式でサーバアドレスターゲットを有していてもよいです。 2つのIPアドレスが同じサーバはEXCHANGE_IDによって返さeir_server_ownerフィールド内の共通so_major_idフィールドの存在によって示されるかどうかを指定する（詳細はセクション2.10.5を参照）、さらに、検証の対象、（セクション18.35.3を参照のこと）。"
    },
    {
      "indent": 3,
      "text": "When multiple addresses for the same server exist, the client may assume that for each file system in the namespace of a given server network address, there exist file systems at corresponding namespace locations for each of the other server network addresses. It may do this even in the absence of explicit listing in fs_locations and fs_locations_info. Such corresponding file system locations can be used as alternate locations, just as those explicitly specified via the fs_locations and fs_locations_info attributes. Where these specific addresses are explicitly designated in the fs_locations_info attribute, the conditions of use specified in this attribute (e.g., priorities, specification of simultaneous use) may limit the client's use of these alternate locations.",
      "ja": "同じサーバに対して複数のアドレスが存在する場合、クライアントが特定のサーバのネットワーク・アドレスの名前空間内の各ファイルシステムのためにそれをとることができる、他のサーバのネットワーク・アドレスのそれぞれについて、名前空間の対応する位置にファイルシステムが存在します。それも、fs_位置とfs_locations_info内の明示的なリストが存在しない場合に、これを行うことがあります。そのような対応するファイルシステムの場所は、単に明示的fs_位置とfs_locations_info属性を介して指定されたもののように、別の場所として使用することができます。これらの特定のアドレスを明示的にfs_locations_info属性に指定されている場合は、この属性で指定された使用条件は、（例えば、優先順位は、同時使用の仕様は）これらの代替の場所のクライアントの使用を制限することがあります。"
    },
    {
      "indent": 3,
      "text": "If a single location entry designates multiple server IP addresses, the client cannot assume that these addresses are multiple paths to the same server. In most cases, they will be, but the client MUST verify that before acting on that assumption. When two server addresses are designated by a single location entry and they correspond to different servers, this normally indicates some sort of misconfiguration, and so the client should avoid using such location entries when alternatives are available. When they are not, clients should pick one of IP addresses and use it, without using others that are not directed to the same server.",
      "ja": "単一の場所のエントリは、複数のサーバーのIPアドレスを指定した場合、クライアントはこれらのアドレスは同じサーバへの複数のパスであると仮定することはできません。ほとんどの場合、彼らはなりますが、クライアントはその仮定に作用する前に、そのことを確認しなければなりません。 2つのサーバーアドレスが単一の場所のエントリで指定された、彼らは別のサーバーに対応している場合、これは通常、設定ミスのいくつかの並べ替えを示し、そのクライアントは、選択肢が用意されていたときに、そのような場所のエントリを使用しないでください。そうでない場合は、クライアントがIPアドレスのいずれかを選ぶ必要がありますし、同じサーバーに送られていない他の人を使用せずに、それを使用しています。"
    },
    {
      "indent": 0,
      "text": "11.6. Additional Client-Side Considerations",
      "section_title": true,
      "ja": "11.6. 追加のクライアント側の考慮事項"
    },
    {
      "indent": 3,
      "text": "When clients make use of servers that implement referrals, replication, and migration, care should be taken that a user who mounts a given file system that includes a referral or a relocated file system continues to see a coherent picture of that user-side file system despite the fact that it contains a number of server-side file systems that may be on different servers.",
      "ja": "クライアントが紹介を実装するサーバの使用、複製、および移行を行う場合は、注意が紹介や再配置、ファイルシステムが含まれ、指定されたファイルシステムをマウントし、ユーザがそのユーザ側のファイルシステムのコヒーレントな絵を見るために続けていることを注意する必要がありますそれは別のサーバー上にあるサーバー側のファイルシステムの数が含まれているという事実にもかかわらず。"
    },
    {
      "indent": 3,
      "text": "One important issue is upward navigation from the root of a server-side file system to its parent (specified as \"..\" in UNIX), in the case in which it transitions to that file system as a result of referral, migration, or a transition as a result of replication. When the client is at such a point, and it needs to ascend to the parent, it must go back to the parent as seen within the multi-server namespace rather than sending a LOOKUPP operation to the server, which would result in the parent within that server's single-server namespace. In order to do this, the client needs to remember the filehandles that represent such file system roots and use these instead of sending a LOOKUPP operation to the current server. This will allow the client to present to applications a consistent namespace, where upward navigation and downward navigation are consistent.",
      "ja": "一つの重要な問題は、上向きの親にサーバ側のファイルシステムのルートからのナビゲーション（UNIXで「..」として指定された）、それは照会の結果として、そのファイルシステムに移行する場合には、移行、またはあります複製の結果として推移。クライアントは、このような点にある、それは親に上昇する必要がある場合、それは親の中につながるというサーバにLOOKUPP操作を送信するよりも、マルチサーバーの名前空間の中に見られるように、親に戻って行かなければなりませんそのサーバーの単一サーバーの名前空間。これを行うためには、クライアントは、ファイルシステムのルートを表すファイルハンドルを覚えているし、代わりに現在のサーバーにLOOKUPP操作を送信するのではこれらを使用する必要があります。これは、クライアントがアプリケーションに上向きと下向きのナビゲーションナビゲーションが一貫している一貫性のある名前空間を提示することができます。"
    },
    {
      "indent": 3,
      "text": "Another issue concerns refresh of referral locations. When referrals are used extensively, they may change as server configurations change. It is expected that clients will cache information related to traversing referrals so that future client-side requests are resolved locally without server communication. This is usually rooted in client-side name look up caching. Clients should periodically purge this data for referral points in order to detect changes in location information. When the change_policy attribute changes for directories that hold referral entries or for the referral entries themselves, clients should consider any associated cached referral information to be out of date.",
      "ja": "もう一つの問題の懸念が紹介場所のリフレッシュ。紹介が広く使用されている場合は、サーバーの構成が変化するように、彼らは変更されることがあります。将来のクライアント側の要求がサーバ通信せずにローカルで解決されるように、クライアントが横断紹介に関連する情報をキャッシュすることが期待されます。これは通常、クライアント側の名のルックアップキャッシュに根ざしています。クライアントは、定期的に位置情報の変化を検出するために、紹介ポイントについては、このデータを削除する必要があります。 change_policyは照会エントリを保持ディレクトリまたは紹介のための属性変更をするときに自分自身をエントリ、クライアントが古い可能するために、任意の関連するキャッシュされた紹介情報を考慮すべきです。"
    },
    {
      "indent": 0,
      "text": "11.7. Effecting File System Transitions",
      "section_title": true,
      "ja": "11.7. ファイルシステムの移行を行います"
    },
    {
      "indent": 3,
      "text": "Transitions between file system instances, whether due to switching between replicas upon server unavailability or to server-initiated migration events, are best dealt with together. This is so even though, for the server, pragmatic considerations will normally force different implementation strategies for planned and unplanned transitions. Even though the prototypical use cases of replication and migration contain distinctive sets of features, when all possibilities for these operations are considered, there is an underlying unity of these operations, from the client's point of view, that makes treating them together desirable.",
      "ja": "ファイル・システム・インスタンス間の遷移は、原因サーバを使用できない時や、サーバ起動移行イベントにレプリカを切り替えるにするかどうか、最高一緒に対処されています。これは、サーバーのために、実用的な考慮事項は、通常、計画的および計画外の移行のためのさまざまな実装戦略を強制的にも、かかわらず、そうです。複製や移行のプロトタイプユースケースは、機能の特徴的なセットが含まれているにもかかわらず、これらの操作についてあらゆる可能性を考慮すると、望ましいそれらを一緒に処理することになりクライアントの観点から、これらの操作の基本的な統一は、そこにあります。"
    },
    {
      "indent": 3,
      "text": "A number of methods are possible for servers to replicate data and to track client state in order to allow clients to transition between file system instances with a minimum of disruption. Such methods vary between those that use inter-server clustering techniques to limit the changes seen by the client, to those that are less aggressive, use more standard methods of replicating data, and impose a greater burden on the client to adapt to the transition.",
      "ja": "サーバは、データを複製すると、クライアントが混乱を最小限に抑えて、ファイルシステムのインスタンス間で移行することを可能にするために、クライアントの状態を追跡するための多くの方法が可能です。このような方法は、あまり積極的である複製データのより標準的な方法を使用するものにクライアントによって見られる変化を制限するために、サーバ間のクラスタリング技術を使用するもの、の間で変化し、遷移に適応するために、クライアント上の大きな負担を課します。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol does not impose choices on clients and servers with regard to that spectrum of transition methods. In fact, there are many valid choices, depending on client and application requirements and their interaction with server implementation choices. The NFSv4.1 protocol does define the specific choices that can be made, how these choices are communicated to the client, and how the client is to deal with any discontinuities.",
      "ja": "NFSv4.1プロトコルは、移行方法のスペクトルに関しては、クライアントとサーバー上の選択肢を課すことはありません。実際には、クライアントとアプリケーション要件とサーバーの実装の選択肢との相互作用に応じて、多くの有効な選択肢があります。 NFSv4.1プロトコルは、これらの選択肢をクライアントに伝達されるか、行うことができる特定の選択肢を定義し、どのようにクライアントが任意の不連続性に対処するためです。"
    },
    {
      "indent": 3,
      "text": "In the sections below, references will be made to various possible server implementation choices as a way of illustrating the transition scenarios that clients may deal with. The intent here is not to define or limit server implementations but rather to illustrate the range of issues that clients may face.",
      "ja": "以下のセクションでは、参照は、クライアントが対処できる遷移シナリオを説明する方法として、様々な可能なサーバの実装の選択肢について説明します。ここでの意図は、定義または制限するサーバの実装ではなく、クライアントが直面する問題の範囲を例示するためではありません。"
    },
    {
      "indent": 3,
      "text": "In the discussion below, references will be made to a file system having a particular property or to two file systems (typically the source and destination) belonging to a common class of any of several types. Two file systems that belong to such a class share some important aspects of file system behavior that clients may depend upon when present, to easily effect a seamless transition between file system instances. Conversely, where the file systems do not belong to such a common class, the client has to deal with various sorts of implementation discontinuities that may cause performance or other issues in effecting a transition.",
      "ja": "以下の説明では、参照は、特定の特性を有するファイル・システム、またはいくつかのタイプの任意の一般的なクラスに属する2つのファイルシステム（典型的には、送信元および宛先）について説明します。簡単にファイル・システム・インスタンス間のシームレスな移行を達成するために、存在する場合、クライアントが依存することができるように、クラスの共有にファイルシステムの動作のいくつかの重要な側面を所属する2つのファイルシステム。逆に、ファイルシステムは、このような一般的なクラスに属していない場合は、クライアントは、移行を行うには、パフォーマンスやその他の問題を引き起こす可能性があり、実装の不連続の様々な種類に対処しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Where the fs_locations_info attribute is available, such file system classification data will be made directly available to the client (see Section 11.10 for details). When only fs_locations is available, default assumptions with regard to such classifications have to be inferred (see Section 11.9 for details).",
      "ja": "fs_locations_info属性が利用可能である場合、そのようなファイルシステムの分類データ（詳細は11.10節を参照）、クライアントに直接利用できるようになります。唯一のfs_位置が利用可能である場合には、そのような分類に関して、デフォルトの仮定を推測する必要がある（詳細はセクション11.9を参照してください）。"
    },
    {
      "indent": 3,
      "text": "In cases in which one server is expected to accept opaque values from the client that originated from another server, the servers SHOULD encode the \"opaque\" values in big-endian byte order. If this is done, servers acting as replicas or immigrating file systems will be able to parse values like stateids, directory cookies, filehandles, etc., even if their native byte order is different from that of other servers cooperating in the replication and migration of the file system.",
      "ja": "一方のサーバーが別のサーバーから発信クライアントからの不透明な値を受け入れることが予想される場合には、サーバはビッグエンディアンバイト順に「不透明」の値をエンコードする必要があります。これが行われた場合、サーバのレプリカとして動作するか、ファイルシステムを移住は、ネイティブのバイト順序は、レプリケーションに協力し、他のサーバーとは異なるとの移行であっても、その他のstateids、ディレクトリクッキー、ファイルハンドル、のような値を解析することができるようになりますファイルシステム。"
    },
    {
      "indent": 0,
      "text": "11.7.1. File System Transitions and Simultaneous Access",
      "section_title": true,
      "ja": "11.7.1. システム移行と同時アクセスファイル"
    },
    {
      "indent": 3,
      "text": "When a single file system may be accessed at multiple locations, either because of an indication of file system identity as reported by the fs_locations or fs_locations_info attributes or because two file system instances have corresponding locations on server addresses that connect to the same server (as indicated by a common so_major_id field in the eir_server_owner field returned by EXCHANGE_ID), the client will, depending on specific circumstances as discussed below, either:",
      "ja": "示されるように、単一のファイルシステムは、（いずれかのためfs_位置によって、または属性fs_locations_infoまたは2つのファイル・システム・インスタンスは、同じサーバーに接続するサーバーのアドレスに対応する位置を持っているので、報告されているように、ファイルシステムの識別の指示の複数の場所にアクセスすることができる場合EXCHANGE_IDによって返さeir_server_ownerフィールド）における共通so_major_idフィールドによって、クライアントは、特定の状況に応じて以下に説明するように、次のいずれか"
    },
    {
      "indent": 3,
      "text": "o Access multiple instances simultaneously, each of which represents an alternate path to the same data and metadata.",
      "ja": "同一のデータおよびメタデータへの代替パスを表しそれぞれが同時にOアクセスの複数のインスタンス。"
    },
    {
      "indent": 3,
      "text": "o Access one instance (or set of instances) and then transition to an alternative instance (or set of instances) as a result of network issues, server unresponsiveness, or server-directed migration. The transition may involve changes in filehandles, fileids, the change attribute, and/or locking state, depending on the attributes of the source and destination file system instances, as specified in the fs_locations_info attribute.",
      "ja": "Oアクセスつのインスタンス（またはインスタンスのセット）は、ネットワークの問題、サーバ無反応、またはサーバ向けの移行の結果として、その後、別のインスタンスに移行（またはインスタンスのセット）。 fs_locations_info属性で指定されたような遷移は、ソースおよび宛先ファイルシステムインスタンスの属性に応じて、ファイルハンドルの変化、fileids、変化属性、及び/又はロック状態を含んでもよいです。"
    },
    {
      "indent": 3,
      "text": "Which of these choices is possible, and how a transition is effected, is governed by equivalence classes of file system instances as reported by the fs_locations_info attribute, and for file system instances in the same location within a multi-homed single-server namespace, as indicated by the value of the so_major_id field of the eir_server_owner field returned by EXCHANGE_ID.",
      "ja": "マルチホーム単一サーバーの名前空間内の同じ場所にこれらの選択肢のどちらも可能で、そしてどのように遷移が行われ、fs_locations_info属性によって報告されたファイル・システム・インスタンスの等価クラスによって支配され、ファイル・システム・インスタンスのための、などEXCHANGE_IDによって返さeir_server_ownerフィールドのso_major_idフィールドの値で示されます。"
    },
    {
      "indent": 0,
      "text": "11.7.2. Simultaneous Use and Transparent Transitions",
      "section_title": true,
      "ja": "11.7.2. 同時使用や透明トランジション"
    },
    {
      "indent": 3,
      "text": "When two file system instances have the same location within their respective single-server namespaces and those two server network addresses designate the same server (as indicated by the same value of the so_major_id field of the eir_server_owner field returned in response to EXCHANGE_ID), those file system instances can be treated as the same, and either used together simultaneously or serially with no transition activity required on the part of the client. In this case, we refer to the transition as \"transparent\", and the client in transferring access from one to the other is acting as it would in the event that communication is interrupted, with a new connection and possibly a new session being established to continue access to the same file system.",
      "ja": "2つのファイルシステム・インスタンスがそれぞれの単一サーバーの名前空間内の同じ位置を有しており、これら2つのサーバのネットワーク・アドレスが同じサーバを指定する場合、それらのファイルを（eir_server_ownerフィールドのso_major_idフィールドの同じ値によって示されるようにEXCHANGE_IDに応答して返されます）システム・インスタンスは、同じように処理し、クライアントの一部に不要転移活性を同時にまたは連続併用のいずれかであり得ます。この場合、私たちは「透明」とトランジションを参照してください、そして、それは通信が新しい接続で、中断され、おそらく新しいセッションがに確立された場合と同じように一方から他方へのアクセスを転送する際にクライアントが動作しています同じファイルシステムへのアクセスを継続します。"
    },
    {
      "indent": 3,
      "text": "Whether simultaneous use of the two file system instances is valid is controlled by whether the fs_locations_info attribute shows the two instances as having the same simultaneous-use class. See Section 11.10.1 for information about the definition of the various use classes, including the simultaneous-use class.",
      "ja": "2つのファイルシステム・インスタンスの同時使用が有効であるかどうかは、fs_locations_info属性が同じ同時使用のクラスを持つように2つのインスタンスを示しているかどうかによって制御されます。同時使用クラスなど、さまざまな使用クラスの定義の詳細については、セクション11.10.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that for two such file systems, any information within the fs_locations_info attribute that indicates the need for special transition activity, i.e., the appearance of the two file system instances with different handle, fileid, write-verifier, change, and readdir classes, indicates a serious problem. The client, if it allows transition to the file system instance at all, must not treat this as a transparent transition. The server SHOULD NOT indicate that these instances belong to different handle, fileid, write-verifier, change, and readdir classes, whether or not the two instances are shown belonging to the same simultaneous-use class.",
      "ja": "二つのそのようなファイルシステム、特殊な遷移活動の必要性を示してfs_locations_info属性内の任意の情報、異なるハンドルを持つ2つのファイルシステムインスタンスのすなわち、外観、FILEID、書き込みベリファイアを、変更、およびREADDIRクラスのために、示すことに注意してください深刻な問題。それがすべてのファイル・システム・インスタンスへの移行を可能にする場合、クライアントは、透明なトランジションとして扱いしてはなりません。サーバーは、書き込み検証、変更、およびREADDIRクラスを、2つのインスタンスが同じ同時利用のクラスに属する示しているかどうかにかかわらず、これらのインスタンスは異なるハンドル、FILEIDに属していることを示すべきではありません。"
    },
    {
      "indent": 3,
      "text": "Where these conditions do not apply, a non-transparent file system instance transition is required with the details depending on the respective handle, fileid, write-verifier, change, and readdir classes of the two file system instances, and whether the two servers' addresses in question have the same eir_server_scope value as reported by EXCHANGE_ID.",
      "ja": "これらの条件が適用されない場合は、非透過的なファイルシステムのインスタンスの移行は、それぞれのハンドル、FILEID、書き込み検証、変更、および2つのファイルシステム・インスタンスのreaddirのクラスに応じて、詳細を必要とされ、2台のサーバかどうかEXCHANGE_IDによって報告されるように、当該アドレスは、同じeir_server_scope値を持っています。"
    },
    {
      "indent": 0,
      "text": "11.7.2.1. Simultaneous Use of File System Instances",
      "section_title": true,
      "ja": "11.7.2.1。ファイル・システム・インスタンスの同時使用"
    },
    {
      "indent": 3,
      "text": "When the conditions in Section 11.7.2 hold, in either of the following two cases, the client may use the two file system instances simultaneously.",
      "ja": "セクション11.7.2保留中の条件は、次の二つのいずれかの場合、クライアントは、同時に2つのファイルシステムインスタンスを使用される場合があります。"
    },
    {
      "indent": 3,
      "text": "o The fs_locations_info attribute does not contain separate per-network-address entries for file system instances at the distinct network addresses. This includes the case in which the fs_locations_info attribute is unavailable. In this case, the fact that the two server addresses connect to the same server (as indicated by the two addresses sharing the same the so_major_id value and subsequently confirmed as described in Section 2.10.5) justifies simultaneous use, and there is no fs_locations_info attribute information contradicting that.",
      "ja": "O fs_locations_info属性は、個別のネットワークアドレスにファイルシステムインスタンスに個別の単位のネットワーク・アドレスのエントリが含まれていません。これはfs_locations_info属性が利用できない場合を含んでいます。この場合、実際に（2.10.5項で説明したのと同じに確認され、その後so_major_id値とを共有する二つのアドレスによって示されるように）同時使用を正当化する2つのサーバのアドレスは、同じサーバーに接続し、no fs_locations_info属性が存在しないことその矛盾の情報。"
    },
    {
      "indent": 3,
      "text": "o The fs_locations_info attribute indicates that two file system instances belong to the same simultaneous-use class.",
      "ja": "O fs_locations_info属性は、2つのファイルシステムインスタンスが同じ同時利用のクラスに属することを示しています。"
    },
    {
      "indent": 3,
      "text": "In this case, the client may use both file system instances simultaneously, as representations of the same file system, whether that happens because the two network addresses connect to the same physical server or because different servers connect to clustered file systems and export their data in common. When simultaneous use is in effect, any change made to one file system instance must be immediately reflected in the other file system instance(s). Locks are treated as part of a common lease, associated with a common client ID. Depending on the details of the eir_server_owner returned by EXCHANGE_ID, the two server instances may be accessed by different sessions or a single session in common.",
      "ja": "この場合、クライアントは、2つのネットワークアドレスが同じ物理サーバーに接続するため、または別のサーバがクラスタ化されたファイル・システムに接続して、で自分のデータをエクスポートするのでそれが起こるかどうか、同じファイルシステムの表現として、同時に両方のファイル・システム・インスタンスを使用することができます一般。同時使用が有効である場合、一つのファイル・システム・インスタンスに対して行われた変更はすぐに他のファイル・システム・インスタンス（複数可）に反映されなければなりません。ロックは、共通のクライアントIDに関連付けられた、共通リースの一部として扱われます。 EXCHANGE_IDによって返さeir_server_ownerの内容によっては、2つのサーバーインスタンスは、異なるセッションや共通の単一のセッションによってアクセスすることができます。"
    },
    {
      "indent": 0,
      "text": "11.7.2.2. Transparent File System Transitions",
      "section_title": true,
      "ja": "11.7.2.2。透明なファイルシステムの移行"
    },
    {
      "indent": 3,
      "text": "When the conditions in Section 11.7.2.1 hold and the fs_locations_info attribute explicitly shows the file system instances for these distinct network addresses as belonging to different simultaneous-use classes, the file system instances should not be used by the client simultaneously. Rather, they should be used serially with one being used unless and until communication difficulties, lack of responsiveness, or an explicit migration event causes another file system instance (or set of file system instances sharing a common simultaneous-use class) to be used.",
      "ja": "セクション11.7.2.1保留中の条件とfs_locations_infoが明示的に属性別の同時使用のクラスに属するものとしてこれらの異なるネットワークアドレスのファイル・システム・インスタンスを示していた場合、ファイル・システム・インスタンスが同時にクライアントで使用すべきではありません。むしろ、彼らは通信問題ないとされるまで使用されているものと直列に使用されるべきである、応答性の欠如、または明示的な移行イベントは、別のファイル・システム・インスタンスを引き起こす（または共通の同時使用のクラスを共有ファイル・システム・インスタンスのセット）を使用することができます。"
    },
    {
      "indent": 3,
      "text": "When a change of file system instance is to be done, the client will use the same client ID already in effect. If the client already has connections to the new server address, these will be used. Otherwise, new connections to existing sessions or new sessions associated with the existing client ID are established as indicated by the eir_server_owner returned by EXCHANGE_ID.",
      "ja": "ファイル・システム・インスタンスの変更を行う必要がある場合は、クライアントは、実際にはすでに同じクライアントIDを使用します。クライアントがすでに新しいサーバアドレスへの接続を持っている場合、これらが使用されます。 EXCHANGE_IDによって返さeir_server_ownerによって示されるようにそれ以外の場合は、既存のセッションまたは既存のクライアントIDに関連付けられた新しいセッションへの新しい接続が確立されています。"
    },
    {
      "indent": 3,
      "text": "In all such transparent transition cases, the following apply:",
      "ja": "すべてのこのような透明の遷移例では、以下が適用されます。"
    },
    {
      "indent": 3,
      "text": "o If filehandles are persistent, they stay the same. If filehandles are volatile, they either stay the same or expire, but the reason for expiration is not due to the file system transition.",
      "ja": "ファイルハンドルは永続的である場合には、O、彼らは同じまま。ファイルハンドルが揮発性である場合、それらは同じままか、有効期限が切れますが、有効期限の理由は、ファイルシステムの移行によるものではないのいずれか。"
    },
    {
      "indent": 3,
      "text": "o Fileid values do not change across the transition.",
      "ja": "O FILEID値は、移行の前後で変化しません。"
    },
    {
      "indent": 3,
      "text": "o The file system will have the same fsid in both the old and new locations.",
      "ja": "Oファイルシステムは、新旧両方の場所で同じFSIDを持つことになります。"
    },
    {
      "indent": 3,
      "text": "o Change attribute values are consistent across the transition and do not have to be refetched. When change attributes indicate that a cached object is still valid, it can remain cached.",
      "ja": "Oの変更は、移行全体で一貫性があり、再フェッチする必要はありません属性値。変更属性はキャッシュされたオブジェクトがまだ有効であることを示している場合は、キャッシュされたままにすることができます。"
    },
    {
      "indent": 3,
      "text": "o Client and state identifiers retain their validity across the transition, except where their staleness is recognized and reported by the new server. Except where such staleness requires it, no lock reclamation is needed. Any such staleness is an indication that the server should be considered to have restarted and is reported as discussed in Section 8.4.2.",
      "ja": "oクライアントと状態識別子は、その陳腐化が認識され、新しいサーバーによって報告された場合を除いて、移行の前後でその有効性を維持します。そのような古さがそれを必要とする場合を除き、一切のロックの再利用は必要ありません。任意のそのような失効は、サーバが再起動したとみなされるべきであり、セクション8.4.2で説明したように報告されていることを示しています。"
    },
    {
      "indent": 3,
      "text": "o Write verifiers are presumed to retain their validity and can be used to compare with verifiers returned by COMMIT on the new server. If COMMIT on the new server returns an identical verifier, then it is expected that the new server has all of the data that was written unstably to the original server and has committed that data to stable storage as requested.",
      "ja": "O検証がその有効性を保持すると推定され、新しいサーバー上のCOMMITによって返された検証と比較するために使用することができます書きます。新しいサーバが同一のベリファイアを返しにCOMMITした場合、新しいサーバーは元のサーバーに不安定に書かれていたし、安定した記憶領域にデータが要求されるようにすることを約束しているすべてのデータを持っていることが期待されます。"
    },
    {
      "indent": 3,
      "text": "o Readdir cookies are presumed to retain their validity and can be presented to subsequent READDIR requests together with the readdir verifier with which they are associated. When the verifier is accepted as valid, the cookie will continue the READDIR operation so that the entire directory can be obtained by the client.",
      "ja": "O READDIRクッキーは、その有効性を保持するために、それらが関連付けられているのreaddir検証とともに、その後のREADDIR要求に提示することが可能と推定されています。検証が有効なものとして受け入れている場合は、ディレクトリ全体がクライアントによって得ることができるように、クッキーはREADDIR操作を継続します。"
    },
    {
      "indent": 0,
      "text": "11.7.3. Filehandles and File System Transitions",
      "section_title": true,
      "ja": "11.7.3. ファイルハンドルとファイルシステムの変遷"
    },
    {
      "indent": 3,
      "text": "There are a number of ways in which filehandles can be handled across a file system transition. These can be divided into two broad classes depending upon whether the two file systems across which the transition happens share sufficient state to effect some sort of continuity of file system handling.",
      "ja": "ファイルハンドルは、ファイルシステムの移行を横切って取り扱うことが可能ないくつかの方法があります。これらの遷移は、ファイルシステム処理の継続のいくつかの並べ替えを行うのに十分な共有状態を発生しこれを横切って2つのファイルシステムかどうかに応じて2つの広範なクラスに分けることができます。"
    },
    {
      "indent": 3,
      "text": "When there is no such cooperation in filehandle assignment, the two file systems are reported as being in different handle classes. In this case, all filehandles are assumed to expire as part of the file system transition. Note that this behavior does not depend on the fh_expire_type attribute and supersedes the specification of the FH4_VOL_MIGRATION bit, which only affects behavior when fs_locations_info is not available.",
      "ja": "ファイルハンドルの割り当てには、このような協力関係が存在しない場合には、2つのファイルシステムは、異なるハンドルクラスであると報告されています。この場合、全てのファイルハンドルは、ファイルシステムの移行の一環として、期限切れと仮定されます。この動作はfh_expire_type属性に依存し、fs_locations_infoが利用できない場合にのみ動作に影響を与えFH4_VOL_MIGRATIONビットの仕様を優先していないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When there is cooperation in filehandle assignment, the two file systems are reported as being in the same handle classes. In this case, persistent filehandles remain valid after the file system transition, while volatile filehandles (excluding those that are only volatile due to the FH4_VOL_MIGRATION bit) are subject to expiration on the target server.",
      "ja": "ファイルハンドルの割り当てでの協力があった場合、2つのファイルシステムは、同じハンドルクラスであると報告されています。 （起因FH4_VOL_MIGRATIONビットにのみ揮発性であるものを除く）揮発性ファイルハンドルは、ターゲットサーバ上の期限切れの対象としながら、この場合には、永続的なファイルハンドルは、ファイルシステムの移行後に有効なまま。"
    },
    {
      "indent": 0,
      "text": "11.7.4. Fileids and File System Transitions",
      "section_title": true,
      "ja": "11.7.4.  Fileidsとファイルシステムの変遷"
    },
    {
      "indent": 3,
      "text": "In NFSv4.0, the issue of continuity of fileids in the event of a file system transition was not addressed. The general expectation had been that in situations in which the two file system instances are created by a single vendor using some sort of file system image copy, fileids will be consistent across the transition, while in the analogous multi-vendor transitions they will not. This poses difficulties, especially for the client without special knowledge of the transition mechanisms adopted by the server. Note that although fileid is not a REQUIRED attribute, many servers support fileids and many clients provide APIs that depend on fileids.",
      "ja": "NFSv4.0では、ファイルシステムの移行の際にfileidsの継続性の問題が対処されていませんでした。一般的な期待は、類似のマルチベンダー遷移におけるこれらはありませんが2つのファイル・システム・インスタンスはファイル・システム・イメージ・コピーのいくつかの並べ替えを使用して、単一のベンダによって作成された状況では、fileidsは、遷移間で一貫性となることでした。これは特に、サーバーによって採用された移行メカニズムの特別な知識がなくても、クライアントのために、困難をもたらします。 FILEIDは必須の属性ではないが、多くのサーバーがfileidsをサポートし、多くのクライアントがfileidsに依存するAPIを提供しています。"
    },
    {
      "indent": 3,
      "text": "It is important to note that while clients themselves may have no trouble with a fileid changing as a result of a file system transition event, applications do typically have access to the fileid (e.g., via stat). The result is that an application may work perfectly well if there is no file system instance transition or if any such transition is among instances created by a single vendor, yet be unable to deal with the situation in which a multi-vendor transition occurs at the wrong time.",
      "ja": "クライアント自身がファイルシステムの移行イベントの結果として変化するFILEIDで支障がないかもしれないが、アプリケーションは通常、（STAT経由例えば、）FILEIDへのアクセス権を持っていないことに注意することが重要です。結果には、ファイル・システム・インスタンスの遷移、またはそのような遷移は、単一のベンダによって作成されたインスタンスの中で、まだマルチベンダ遷移がで発生する状況に対処することができない場合が存在しない場合、アプリケーションが完全にうまく機能することができるということです間違った時間。"
    },
    {
      "indent": 3,
      "text": "Providing the same fileids in a multi-vendor (multiple server vendors) environment has generally been held to be quite difficult. While there is work to be done, it needs to be pointed out that this difficulty is partly self-imposed. Servers have typically identified fileid with inode number, i.e. with a quantity used to find the file in question. This identification poses special difficulties for migration of a file system between vendors where assigning the same index to a given file may not be possible. Note here that a fileid is not required to be useful to find the file in question, only that it is unique within the given file system. Servers prepared to accept a fileid as a single piece of metadata and store it apart from the value used to index the file information can relatively easily maintain a fileid value across a migration event, allowing a truly transparent migration event.",
      "ja": "マルチベンダー（複数のサーバー・ベンダー）環境で同じfileidsの提供は、一般的には非常に困難であることが開催されました。なすべき仕事があるが、それはこの問題の一部は自主であることを指摘する必要があります。サーバーは通常、すなわち、問題のファイルを見つけるために使用量で、iノード番号とFILEIDを同定しました。この識別は、指定されたファイルに同じインデックスを割り当てることはできないことがベンダー間のファイルシステムの移行のための特別な問題を提起します。それは与えられたファイルシステム内で一意であることだけが、FILEIDは、問題のファイルを見つけることが有用であることが必要とされていないことをここで注意してください。メタデータの単一片としてFILEIDを受け入れ、比較的容易に真に透明移行イベントを可能にする、移行イベントを横切るFILEID値を維持することができるファイル情報インデックスに使用される値とは別に、それを格納するために用意サーバー。"
    },
    {
      "indent": 3,
      "text": "In any case, where servers can provide continuity of fileids, they should, and the client should be able to find out that such continuity is available and take appropriate action. Information about the continuity (or lack thereof) of fileids across a file system transition is represented by specifying whether the file systems in question are of the same fileid class.",
      "ja": "いずれの場合も、サーバはfileidsの連続性を提供することができ、彼らが必要、とクライアントは、このような連続性が利用可能であることを知り、適切な行動を取ることができるはずどこ。ファイルシステム移行を横切るfileidsの連続性（またはその欠如）に関する情報は、当該ファイルシステムは同じFILEIDクラスのものであるかどうかを指定することによって表されています。"
    },
    {
      "indent": 3,
      "text": "Note that when consistent fileids do not exist across a transition (either because there is no continuity of fileids or because fileid is not a supported attribute on one of instances involved), and there are no reliable filehandles across a transition event (either because there is no filehandle continuity or because the filehandles are volatile), the client is in a position where it cannot verify that files it was accessing before the transition are the same objects. It is forced to assume that no object has been renamed, and, unless there are guarantees that provide this (e.g., the file system is read-only), problems for applications may occur. Therefore, use of such configurations should be limited to situations where the problems that this may cause can be tolerated.",
      "ja": "一貫性のあるfileidsは、移行の前後存在しないときがあります（どちらかfileidsのない連続性がないためか、FILEIDが関与インスタンスのいずれかでサポートされる属性ではないので）、および信頼できるファイルハンドルは、遷移イベント全体ではありません（どちらかがあるので、ファイルハンドルの連続または）ファイルハンドルが揮発性であるため、何が、クライアントは、それが移行する前にアクセスされたファイルが同じオブジェクトであることを確認することができない位置ではありません。これを提供保証は（例えば、ファイルシステムは読み取り専用である）がない限り、アプリケーションで問題が発生する可能性があり、何のオブジェクトの名前が変更されていないことを前提とすることを余儀なくされ、。したがって、このような構成の使用は、これが原因となる問題を許容できる状況に限定されなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.7.5. Fsids and File System Transitions",
      "section_title": true,
      "ja": "11.7.5.  Fsidsとファイルシステムの変遷"
    },
    {
      "indent": 3,
      "text": "Since fsids are generally only unique within a per-server basis, it is likely that they will change during a file system transition. One exception is the case of transparent transitions, but in that case we have multiple network addresses that are defined as the same server (as specified by a common value of the so_major_id field of eir_server_owner). Clients should not make the fsids received from the server visible to applications since they may not be globally unique, and because they may change during a file system transition event. Applications are best served if they are isolated from such transitions to the extent possible.",
      "ja": "fsidsはサーバ単位の範囲内、一般的にのみ一意であるので、彼らが、ファイルシステムの移行時に変更される可能性があります。唯一の例外は、透明遷移の場合であるが、その場合には、我々は同じサーバ（eir_server_ownerのso_major_id分野の共通の値で指定された）のように定義されている複数のネットワークアドレスを持っています。彼らは、ファイルシステムの遷移イベント中に変更されることがあるため、クライアントは、彼らがグローバルに一意ではないかもしれないので、アプリケーションに表示サーバから受信fsidsを作り、そしてべきではありません。彼らは可能な限り、そのような遷移から隔離されている場合アプリケーションは最高の提供しています。"
    },
    {
      "indent": 3,
      "text": "Although normally a single source file system will transition to a single target file system, there is a provision for splitting a single source file system into multiple target file systems, by specifying the FSLI4F_MULTI_FS flag.",
      "ja": "通常、単一のソース・ファイル・システムは、単一のターゲット・ファイル・システムに移行するが、FSLI4F_MULTI_FSフラグを指定することにより、複数のターゲット・ファイル・システムに単一のソース・ファイル・システムを分割するための規定があります。"
    },
    {
      "indent": 0,
      "text": "11.7.5.1. File System Splitting",
      "section_title": true,
      "ja": "11.7.5.1。ファイルシステムの分割"
    },
    {
      "indent": 3,
      "text": "When a file system transition is made and the fs_locations_info indicates that the file system in question may be split into multiple file systems (via the FSLI4F_MULTI_FS flag), the client SHOULD do GETATTRs to determine the fsid attribute on all known objects within the file system undergoing transition to determine the new file system boundaries.",
      "ja": "ファイルシステムの移行が行われ、fs_locations_infoが問題のファイルシステムが（FSLI4F_MULTI_FSフラグを介して）複数のファイルシステムに分割することができることを示す場合、GETATTRsを行う必要があり、クライアントは、ファイルシステム受け内のすべての既知のオブジェクトのFSID属性を決定します移行は、新しいファイルシステムの境界を決定します。"
    },
    {
      "indent": 3,
      "text": "Clients may maintain the fsids passed to existing applications by mapping all of the fsids for the descendant file systems to the common fsid used for the original file system.",
      "ja": "クライアントは、元のファイルシステムに使用される一般的なFSIDに子孫ファイルシステム用fsidsのすべてをマッピングすることにより、既存のアプリケーションに渡されたfsidsを維持することができます。"
    },
    {
      "indent": 3,
      "text": "Splitting a file system may be done on a transition between file systems of the same fileid class, since the fact that fileids are unique within the source file system ensure they will be unique in each of the target file systems.",
      "ja": "fileidsは、ソース・ファイル・システム内で一意であるという事実は、それらがターゲット・ファイル・システムのそれぞれにユニークであろう保証ので、ファイルシステムを分割すること、同じFILEIDクラスのファイルシステムとの間の遷移に行うことができます。"
    },
    {
      "indent": 0,
      "text": "11.7.6. The Change Attribute and File System Transitions",
      "section_title": true,
      "ja": "11.7.6. 属性変更やファイルシステムの変遷"
    },
    {
      "indent": 3,
      "text": "Since the change attribute is defined as a server-specific one, change attributes fetched from one server are normally presumed to be invalid on another server. Such a presumption is troublesome since it would invalidate all cached change attributes, requiring refetching. Even more disruptive, the absence of any assured continuity for the change attribute means that even if the same value is retrieved on refetch, no conclusions can be drawn as to whether the object in question has changed. The identical change attribute could be merely an artifact of a modified file with a different change attribute construction algorithm, with that new algorithm just happening to result in an identical change value.",
      "ja": "変化属性がサーバ固有のものとして定義されているので、変更は1つのサーバーからフェッチされた属性は、通常は別のサーバー上で無効であると推定されます。それが再フェッチを必要とする、すべてのキャッシュされた変更の属性を無効になるので、このような推定は面倒です。さらに破壊、変更属性のいずれかの確実な継続性の欠如は、同じ値を再フェッチで取得されていても、何の結論は問題のオブジェクトが変更されたかどうかに関して引き出すことはできないことを意味します。同じ属性変更は、新しいアルゴリズムがちょうど同じ変動値をもたらすことが起こって、さまざまな変化属性構成アルゴリズムで修正されたファイルの単なるアーティファクトである可能性があります。"
    },
    {
      "indent": 3,
      "text": "When the two file systems have consistent change attribute formats, and this fact is communicated to the client by reporting in the same change class, the client may assume a continuity of change attribute construction and handle this situation just as it would be handled without any file system transition.",
      "ja": "2つのファイルシステムが一貫性の変化属性の形式を持っており、この事実は、同じ変更クラスに報告することによって、クライアントに伝達されると、クライアントは、変化属性の建設の継続を前提とし、それがどのファイルを使用せずに処理されるのと同じように、このような状況を処理することができますシステムの移行。"
    },
    {
      "indent": 0,
      "text": "11.7.7. Lock State and File System Transitions",
      "section_title": true,
      "ja": "11.7.7. システム移行の状態をロックし、ファイル"
    },
    {
      "indent": 3,
      "text": "In a file system transition, the client needs to handle cases in which the two servers have cooperated in state management and in which they have not. Cooperation by two servers in state management requires coordination of client IDs. Before the client attempts to use a client ID associated with one server in a request to the server of the other file system, it must eliminate the possibility that two non-cooperating servers have assigned the same client ID by accident. The client needs to compare the eir_server_scope values returned by each server. If the scope values do not match, then the servers have not cooperated in state management. If the scope values match, then this indicates the servers have cooperated in assigning client IDs to the point that they will reject client IDs that refer to state they do not know about. See Section 2.10.4 for more information about the use of server scope.",
      "ja": "ファイルシステムの移行では、クライアントは、2台のサーバーが状態管理で、彼らがいない持っているに協力している場合を処理する必要があります。状態管理における二つのサーバによって協力は、クライアントIDの連携が必要となります。クライアントは、他のファイルシステムのサーバにリクエスト内の1台のサーバに関連付けられたクライアントIDを使用しようとする前に、それは二つの非協力のサーバーが偶然同じクライアントIDが割り当てられている可能性を排除しなければなりません。クライアントは各サーバーによって返さeir_server_scope値を比較する必要があります。スコープ値が一致しない場合、サーバは、状態管理に協力していません。スコープ値が一致する場合、このサーバーは、彼らが知らない状態を参照クライアントIDを拒否することをポイントにクライアントIDを割り当てる際に協力しているを示しています。サーバースコープの使用についての詳細は、2.10.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "In the case of migration, the servers involved in the migration of a file system SHOULD transfer all server state from the original to the new server. When this is done, it must be done in a way that is transparent to the client. With replication, such a degree of common state is typically not the case. Clients, however, should use the information provided by the eir_server_scope returned by EXCHANGE_ID (as modified by the validation procedures described in Section 2.10.4) to determine whether such sharing may be in effect, rather than making assumptions based on the reason for the transition.",
      "ja": "移行の場合には、ファイルシステムの移行に関係するサーバーは、元から新しいサーバーにすべてのサーバーの状態を転送する必要があります。これが行われると、それはクライアントに対して透過的な方法で行われなければなりません。レプリケーションでは、共通の状態の程度は、一般的にそうではありません。 （セクション2.10.4に記載の検証手順によって修正されるように）クライアントが、しかし、EXCHANGE_IDによって返さeir_server_scopeによって提供される情報を使用する必要があり、このような共有はなく遷移した理由に基づいて仮定を行うよりも、有効であることができるかどうかを決定します。"
    },
    {
      "indent": 3,
      "text": "This state transfer will reduce disruption to the client when a file system transition occurs. If the servers are successful in transferring all state, the client can attempt to establish sessions associated with the client ID used for the source file system instance. If the server accepts that as a valid client ID, then the client may use the existing stateids associated with that client ID for the old file system instance in connection with that same client ID in connection with the transitioned file system instance. If the client in question already had a client ID on the target system, it may interrogate the stateid values from the source system under that new client ID, with the assurance that if they are accepted as valid, then they represent validly transferred lock state for the source file system, which has been transferred to the target server.",
      "ja": "ファイルシステムの移行が発生したときに、この状態転送は、クライアントに混乱を軽減します。サーバはすべての状態を転送することに成功している場合、クライアントは、ソース・ファイル・システム・インスタンスに使用されるクライアントIDに関連付けられたセッションを確立しようとすることができます。サーバーは、有効なクライアントIDとして、クライアントは、移行ファイル・システム・インスタンスに関連して、同じクライアントIDに関連して、古いファイル・システム・インスタンスのそのクライアントIDに関連付けられている既存のstateidsを使用することを受け入れた場合。問題のクライアントがすでにターゲット・システム上のクライアントIDを持っていた場合、それは彼らが有効なものとして受け入れられている場合、彼らが有効に転送ロック状態を表していることを保証し、その新しいクライアントIDの下でソースシステムからのstateid値を問い合わせることができますターゲット・サーバーに転送されたソース・ファイル・システム、。"
    },
    {
      "indent": 3,
      "text": "When the two servers belong to the same server scope, it does not mean that when dealing with the transition, the client will not have to reclaim state. However, it does mean that the client may proceed using its current client ID when establishing communication with the new server, and the new server will either recognize the client ID as valid or reject it, in which case locks must be reclaimed by the client.",
      "ja": "2つのサーバーが同じサーバーのスコープに属している場合は、移行を扱うときに、クライアントは状態を再利用する必要がないという意味ではありません。しかし、それは、クライアントが新しいサーバーとの通信を確立し、新しいサーバーがその場合には、ロックは、クライアントによって再利用されなければならない、などの有効なクライアントIDを認識したり、それを拒否するかときに現在のクライアントIDを使用して進めることができることを意味しています。"
    },
    {
      "indent": 3,
      "text": "File systems cooperating in state management may actually share state or simply divide the identifier space so as to recognize (and reject as stale) each other's stateids and client IDs. Servers that do share state may not do so under all conditions or at all times. If the server cannot be sure when accepting a client ID that it reflects the locks the client was given, the server must treat all associated state as stale and report it as such to the client.",
      "ja": "状態管理に協力ファイルシステムは、実際に状態を共有したり、単に認識（およびAS失効リジェクト）の互いのstateids及びクライアントIDように識別子空間を分割してもよいです。状態を共有しないサーバーは、すべての条件の下で、またはすべての回で、そうしない場合があります。それは、クライアントが与えられたロックを反映したクライアントIDを受け付けた場合に、サーバが確認できない場合は、サーバーが古くなったとして、すべての関連する状態を治療し、クライアントにそのように報告しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the two file system instances are on servers that do not share a server scope value, the client must establish a new client ID on the destination, if it does not have one already, and reclaim locks if allowed by the server. In this case, old stateids and client IDs should not be presented to the new server since there is no assurance that they will not conflict with IDs valid on that server. Note that in this case, lock reclaim may be attempted even when the servers involved in the transfer have different server scope values (see Section 8.4.2.1 for the contrary case of reclaim after server reboot). Servers with different server scope values may cooperate to allow reclaim for locks associated with the transfer of a file system even if they do not cooperate sufficiently to share a server scope.",
      "ja": "2つのファイルシステムインスタンスがサーバーのスコープ値を共有していないサーバー上にある場合、それは既に持っている、そしてサーバーによって許可された場合にロックを再要求していない場合、クライアントは、先に新しいクライアントIDを確立する必要があります。彼らはそのサーバー上の有効なIDと競合しないという保証はありませんので、この場合は、古いのstateidsとクライアントIDは、新しいサーバーに提示すべきではありません。この場合には、ロック再利用が転送に関係するサーバーは、（サーバーの再起動後に再利用の反対の場合は項8.4.2.1を参照）別のサーバーのスコープ値を持つ場合にも試行されることに注意してください。別のサーバーのスコープ値を持つサーバーは、サーバーのスコープを共有するために十分に協力しない場合でも、ファイルシステムの移転に関連したロックを再利用できるように協力することができます。"
    },
    {
      "indent": 3,
      "text": "In either case, when actual locks are not known to be maintained, the destination server may establish a grace period specific to the given file system, with non-reclaim locks being rejected for that file system, even though normal locks are being granted for other file systems. Clients should not infer the absence of a grace period for file systems being transitioned to a server from responses to requests for other file systems.",
      "ja": "いずれの場合においても、実際のロックが維持されることが知られていない場合、宛先サーバは、通常、ロックが他に付与されているにもかかわらず、非再利用ロックがそのファイルシステムに拒否された状態で、所定のファイルシステムに固有の猶予期間を確立することができますファイルシステム。クライアントは、他のファイルシステムの要求に対する応答からサーバーに移行されているファイルシステムの猶予期間がないことを推測するべきではありません。"
    },
    {
      "indent": 3,
      "text": "In the case of lock reclamation for a given file system after a file system transition, edge conditions can arise similar to those for reclaim after server restart (although in the case of the planned state transfer associated with migration, these can be avoided by securely recording lock state as part of state migration). Unless the destination server can guarantee that locks will not be incorrectly granted, the destination server should not allow lock reclaims and should avoid establishing a grace period.",
      "ja": "マイグレーションに関連付けられた予定状態転送の場合には、これらを確実に記録することによって回避することができるが、ファイルシステムの移行後に特定のファイルシステムのロック再生の場合には、エッジ条件は、（サーバの再起動後に再利用のためのものと同様で生じ得ます状態移行の一部）などの状態をロック。宛先サーバーがロックが誤って許可されないことを保証することができない限り、送信先サーバーは、ロックが再利用し、猶予期間を確立することは避けてください許してはなりません。"
    },
    {
      "indent": 3,
      "text": "Once all locks have been reclaimed, or there were no locks to reclaim, the client indicates that there are no more reclaims to be done for the file system in question by sending a RECLAIM_COMPLETE operation with the rca_one_fs parameter set to true. Once this has been done, non-reclaim locking operations may be done, and any subsequent request to do reclaims will be rejected with the error NFS4ERR_NO_GRACE.",
      "ja": "一旦、全てのロックが再利用されている、または再利用する一切ロックがありませんでした、クライアントがもう存在しないことを示すtrueに設定rca_one_fsパラメータでRECLAIM_COMPLETE操作を送信することによって、問題のファイルシステムのために行われるように再利用します。これが行われた後、非再利用ロック操作を行うことができ、および再要求を行うには、後続の要求はエラーNFS4ERR_NO_GRACEで拒否されます。"
    },
    {
      "indent": 3,
      "text": "Information about client identity may be propagated between servers in the form of client_owner4 and associated verifiers, under the assumption that the client presents the same values to all the servers with which it deals.",
      "ja": "クライアントのアイデンティティに関する情報は、クライアントは、それが扱っていると、すべてのサーバに同じ値を提示仮定の下で、client_owner4と関連する検証の形でのサーバー間で伝播することができます。"
    },
    {
      "indent": 3,
      "text": "Servers are encouraged to provide facilities to allow locks to be reclaimed on the new server after a file system transition. Often, however, in cases in which the two servers do not share a server scope value, such facilities may not be available and the client should be prepared to re-obtain locks, even though it is possible that the client may have its LOCK or OPEN request denied due to a conflicting lock.",
      "ja": "サーバーは、ロックが、ファイルシステムの移行後に新しいサーバー上で再利用できるようにする機能を提供することが奨励されています。しかし、多くの場合、2台のサーバーが、サーバーのスコープ値を共有しないれる場合には、クライアントがそのLOCKを持っているか、可能性があるにもかかわらず、このような施設が利用できない場合があり、クライアントはロックを再取得するために準備する必要がありますOPEN要求が競合ロックが原因拒否されました。"
    },
    {
      "indent": 3,
      "text": "The consequences of having no facilities available to reclaim locks on the new server will depend on the type of environment. In some environments, such as the transition between read-only file systems, such denial of locks should not pose large difficulties in practice. When an attempt to re-establish a lock on a new server is denied, the client should treat the situation as if its original lock had been revoked. Note that when the lock is granted, the client cannot assume that no conflicting lock could have been granted in the interim. Where change attribute continuity is present, the client may check the change attribute to check for unwanted file modifications. Where even this is not available, and the file system is not read-only, a client may reasonably treat all pending locks as having been revoked.",
      "ja": "新しいサーバーにロックを再利用するために利用可能な機能を有していないの結果は、環境の種類によって異なります。このよう読み取り専用ファイルシステム間の移行などの一部の環境では、ロックのように否定は実際には大きな困難をもたらすべきではありません。新しいサーバーにロックを再確立しようとする試みが拒否された場合は、元のロックが取り消されたかのように、クライアントは状況を扱うべきです。ロックが許可されている場合、クライアントは競合するロックが暫定的に許可されていない可能性があることを前提とすることはできません。変化属性の連続性が存在する場合、クライアントは、不要なファイルの変更をチェックするために変化属性を確認することができます。どこでもこれは利用できず、ファイルシステムは読み取り専用ではありませんが、クライアントが合理的に取り消されたとして、すべての保留中のロックを扱うことがあります。"
    },
    {
      "indent": 0,
      "text": "11.7.7.1. Leases and File System Transitions",
      "section_title": true,
      "ja": "11.7.7.1。リースとファイルシステムの移行"
    },
    {
      "indent": 3,
      "text": "In the case of lease renewal, the client may not be submitting requests for a file system that has been transferred to another server. This can occur because of the lease renewal mechanism. The client renews the lease associated with all file systems when submitting a request on an associated session, regardless of the specific file system being referenced.",
      "ja": "リース更新の場合、クライアントは別のサーバーに転送されたファイルシステムに対する要求を提出することはできません。これは、リース更新機構から発生する可能性があります。クライアントに関係なく、参照されている特定のファイルシステムの、関連するセッションに要求を提出する際、すべてのファイルシステムに関連付けられているリースを更新します。"
    },
    {
      "indent": 3,
      "text": "In order for the client to schedule renewal of its lease where there is locking state that may have been relocated to the new server, the client must find out about lease relocation before that lease expire. To accomplish this, the SEQUENCE operation will return the status bit SEQ4_STATUS_LEASE_MOVED if responsibility for any of the renewed locking state has been transferred to a new server. This will continue until the client receives an NFS4ERR_MOVED error for each of the file systems for which there has been locking state relocation.",
      "ja": "そのリースの有効期限が切れる前に新しいサーバーに移転されている可能性があり状態がロックされ、そのリースの更新をスケジュールするクライアントのために、クライアントは、リースの再配置を知る必要があります。新たなロック状態のいずれかの責任は、新しいサーバーに転送された場合は、これを達成するために、シーケンス動作は、ステータスビットSEQ4_STATUS_LEASE_MOVEDを返します。クライアントは状態の再配置がロックされたファイルシステムごとにNFS4ERR_MOVEDエラーを受信するまでこれが継続されます。"
    },
    {
      "indent": 3,
      "text": "When a client receives an SEQ4_STATUS_LEASE_MOVED indication from a server, for each file system of the server for which the client has locking state, the client should perform an operation. For simplicity, the client may choose to reference all file systems, but what is important is that it must reference all file systems for which there was locking state where that state has moved. Once the client receives an NFS4ERR_MOVED error for each such file system, the server will clear the SEQ4_STATUS_LEASE_MOVED indication. The client can terminate the process of checking file systems once this indication is cleared (but only if the client has received a reply for all outstanding SEQUENCE requests on all sessions it has with the server), since there are no others for which locking state has moved.",
      "ja": "クライアントがサーバからSEQ4_STATUS_LEASE_MOVED指示を受信した場合、クライアントは状態をロックしたため、サーバのファイルシステムごとに、クライアントが操作を行うべきです。簡単にするために、クライアントはすべてのファイルシステムを参照することを選択したが、重要なことは、それはその状態が移動したロック状態があったため、すべてのファイルシステムを参照しなければならないということであることがあります。クライアントは、このような各ファイルシステムのNFS4ERR_MOVEDエラーを受信すると、サーバはSEQ4_STATUS_LEASE_MOVED表示をクリアします。この表示がクリアされます（ただし、場合にのみ、クライアントはサーバーとの持っているすべてのセッション上のすべての未SEQUENCE要求に対する応答を受信した）後にロック状態を持っている何も他の人が存在しないため、クライアントは、ファイル・システムをチェックするプロセスを終了させることができます移動。"
    },
    {
      "indent": 3,
      "text": "A client may use GETATTR of the fs_status (or fs_locations_info) attribute on all of the file systems to get absence indications in a single (or a few) request(s), since absent file systems will not cause an error in this context. However, it still must do an operation that receives NFS4ERR_MOVED on each file system, in order to clear the SEQ4_STATUS_LEASE_MOVED indication.",
      "ja": "クライアントは存在しないファイルシステムでは、このコンテキストでエラーが発生しないので、単一（または少数の）要求（複数可）で不在の適応症を取得するためにfs_statusのGETATTR（またはfs_locations_info）ファイルシステムのすべての属性を使用することができます。しかし、それはまだSEQ4_STATUS_LEASE_MOVED表示をクリアするために、各ファイルシステム上NFS4ERR_MOVEDを受信した場合の動作を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Once the set of file systems with transferred locking state has been determined, the client can follow the normal process to obtain the new server information (through the fs_locations and fs_locations_info attributes) and perform renewal of that lease on the new server, unless information in the fs_locations_info attribute shows that no state could have been transferred. If the server has not had state transferred to it transparently, the client will receive NFS4ERR_STALE_CLIENTID from the new server, as described above, and the client can then reclaim locks as is done in the event of server failure.",
      "ja": "転送状態が決定されているロックを持つファイルシステムのセットと、クライアントは、（fs_位置を通って、属性fs_locations_info）新しいサーバー情報を取得し、新しいサーバーにそのリースの更新を実行するために、通常のプロセスに従うことができます内の情報がない限り属性fs_locations_info何の状態が転送されていない可能性があることを示しています。サーバは状態が透過的に転送されなかった場合は、上記のように、クライアントは、新しいサーバーからNFS4ERR_STALE_CLIENTIDを受信すると、サーバーに障害が発生した場合に行われるように、クライアントは、ロックを取り戻すことができます。"
    },
    {
      "indent": 0,
      "text": "11.7.7.2. Transitions and the Lease_time Attribute",
      "section_title": true,
      "ja": "11.7.7.2。トランジションとLease_time属性"
    },
    {
      "indent": 3,
      "text": "In order that the client may appropriately manage its lease in the case of a file system transition, the destination server must establish proper values for the lease_time attribute.",
      "ja": "クライアントが適切にファイルシステムの移行の場合にはそのリースを管理できるように、送信先サーバーはlease_time属性の適切な値を確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "When state is transferred transparently, that state should include the correct value of the lease_time attribute. The lease_time attribute on the destination server must never be less than that on the source, since this would result in premature expiration of a lease granted by the source server. Upon transitions in which state is transferred transparently, the client is under no obligation to refetch the lease_time attribute and may continue to use the value previously fetched (on the source server).",
      "ja": "状態が透過的に転送されると、その状態はlease_time属性の正しい値を含むべきです。これは、ソースサーバによって付与されたリースの早期満了ことになるので、先サーバー上のlease_time属性は、ソース上のそれよりも少ないにすることはできません。透過的に転送される状態に遷移すると、クライアントはlease_time属性を再フェッチし、（ソースサーバ上の）以前にフェッチされた値を使用し続けるかもしれない義務です。"
    },
    {
      "indent": 3,
      "text": "If state has not been transferred transparently, either because the associated servers are shown as having different eir_server_scope strings or because the client ID is rejected when presented to the new server, the client should fetch the value of lease_time on the new (i.e., destination) server, and use it for subsequent locking requests. However, the server must respect a grace period of at least as long as the lease_time on the source server, in order to ensure that clients have ample time to reclaim their lock before potentially conflicting non-reclaimed locks are granted.",
      "ja": "関連するサーバが異なるeir_server_scopeストリングを有するように示されているので、状態はどちらか、透過的に転送されていないか、または新しいサーバーに提示したときにクライアントIDが拒否されているため、クライアントは、新しい（すなわち、宛先）にlease_timeの値をフェッチする必要がある場合サーバは、その後のロック要求のためにそれを使用します。ただし、サーバは潜在的に競合非埋立ロックが付与される前に、クライアントがロックを取り戻すために十分な時間を持っていることを確実にするためには、少なくとも限り、ソースサーバー上のlease_timeとしての猶予期間を尊重しなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.7.8. Write Verifiers and File System Transitions",
      "section_title": true,
      "ja": "11.7.8. システム移行の検証方法を書くとファイル"
    },
    {
      "indent": 3,
      "text": "In a file system transition, the two file systems may be clustered in the handling of unstably written data. When this is the case, and the two file systems belong to the same write-verifier class, write verifiers returned from one system may be compared to those returned by the other and superfluous writes avoided.",
      "ja": "ファイルシステムの移行において、2つのファイルシステムが不安定に書き込まれたデータの処理にクラスタ化されてもよいです。このような場合であり、2つのファイルシステムが同じ書き込みベリファイアクラスに属している場合、回避他と余分な書き込みによって返されたものと比較することができる1つのシステムから返された検証を書き込みます。"
    },
    {
      "indent": 3,
      "text": "When two file systems belong to different write-verifier classes, any verifier generated by one must not be compared to one provided by the other. Instead, it should be treated as not equal even when the values are identical.",
      "ja": "2つのファイルシステムが異なる書き込みベリファイアのクラスに属している場合は、いずれかによって生成された検証は、他が提供するものと比較してはいけません。代わりに、値が同一である場合でも等しくないとして扱われるべきです。"
    },
    {
      "indent": 0,
      "text": "11.7.9. Readdir Cookies and Verifiers and File System Transitions",
      "section_title": true,
      "ja": "11.7.9.  READDIRクッキーと検証者とファイルシステムの変遷"
    },
    {
      "indent": 3,
      "text": "In a file system transition, the two file systems may be consistent in their handling of READDIR cookies and verifiers. When this is the case, and the two file systems belong to the same readdir class, READDIR cookies and verifiers from one system may be recognized by the other and READDIR operations started on one server may be validly continued on the other, simply by presenting the cookie and verifier returned by a READDIR operation done on the first file system to the second.",
      "ja": "ファイルシステムの移行において、2つのファイルシステムは、READDIRクッキー及び検証のそれらの取り扱いに一致し得ます。これが事実である、と2つのファイルシステムが同じでreaddirクラスに属している場合には、一つのシステムからのREADDIRクッキーと検証は、単純に提示することで、有効に他の上で継続することができる1台のサーバー上で開始し、他のとREADDIR操作によって認識することができます第二に、最初のファイルシステム上で行わREADDIR操作によって返されたクッキーと検証。"
    },
    {
      "indent": 3,
      "text": "When two file systems belong to different readdir classes, any READDIR cookie and verifier generated by one is not valid on the second, and must not be presented to that server by the client. The client should act as if the verifier was rejected.",
      "ja": "2つのファイルシステムが異なるのreaddirクラスに属している場合は、いずれかによって生成されたREADDIRクッキーと検証は、第二には有効ではありません、そしてクライアントによって、そのサーバーに提示されてはなりません。クライアントは、検証が拒否されたかのように行動しなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.7.10. File System Data and File System Transitions",
      "section_title": true,
      "ja": "11.7.10. システム移行のシステムデータファイルとファイル"
    },
    {
      "indent": 3,
      "text": "When multiple replicas exist and are used simultaneously or in succession by a client, applications using them will normally expect that they contain either the same data or data that is consistent with the normal sorts of changes that are made by other clients updating the data of the file system (with metadata being the same to the degree indicated by the fs_locations_info attribute). However, when multiple file systems are presented as replicas of one another, the precise relationship between the data of one and the data of another is not, as a general matter, specified by the NFSv4.1 protocol. It is quite possible to present as replicas file systems where the data of those file systems is sufficiently different that some applications have problems dealing with the transition between replicas. The namespace will typically be constructed so that applications can choose an appropriate level of support, so that in one position in the namespace a varied set of replicas will be listed, while in another only those that are up-to-date may be considered replicas. The protocol does define four special cases of the relationship among replicas to be specified by the server and relied upon by clients:",
      "ja": "複数のレプリカが存在し、クライアントが同時に、または連続して使用されている場合は、それらを使用するアプリケーションは、通常、それらが同じデータまたはデータが含まれていることを期待してのデータを更新し、他のクライアントによって行われた変更の通常の種類と一致していること（メタデータはfs_locations_info属性によって示される程度に同じである）のファイル・システム。複数のファイルシステムが互いのレプリカとして提示されている場合しかし、一つのデータと他のデータとの間の正確な関係は、NFSv4.1プロトコルによって指定された、一般的な事項として、ではありません。それらのファイルシステムのデータは、いくつかのアプリケーションがレプリカ間の遷移を扱う問題を抱えていることを十分に異なっているレプリカのファイル・システムとして提示することは十分に可能です。別だけ最新であるものが複製と考えることができるが、名前空間内の1つの位置に複製の変動セットは、リストされるように、アプリケーションは、支持体の適切なレベルを選択できるように、名前空間は、典型的に構築されます。プロトコルは、サーバーによって指定され、クライアントが依拠するレプリカ間の関係の4つの特殊ケースを定義します："
    },
    {
      "indent": 3,
      "text": "o When multiple server addresses correspond to the same actual server, as indicated by a common so_major_id field within the eir_server_owner field returned by EXCHANGE_ID, the client may depend on the fact that changes to data, metadata, or locks made on one file system are immediately reflected on others.",
      "ja": "複数のサーバー・アドレスが同じ実際のサーバに対応する場合、O、EXCHANGE_IDによって返さeir_server_ownerフィールド内の共通so_major_idフィールドによって示されるように、クライアントは、一つのファイルシステム上で行われたデータへの変更、メタデータ、またはロックがすぐにであるという事実に依存してもよいです他人に反映。"
    },
    {
      "indent": 3,
      "text": "o When multiple replicas exist and are used simultaneously by a client (see the FSLIB4_CLSIMUL definition within fs_locations_info), they must designate the same data. Where file systems are writable, a change made on one instance must be visible on all instances, immediately upon the earlier of the return of the modifying requester or the visibility of that change on any of the associated replicas. This allows a client to use these replicas simultaneously without any special adaptation to the fact that there are multiple replicas. In this case, locks (whether share reservations or byte-range locks) and delegations obtained on one replica are immediately reflected on all replicas, even though these locks will be managed under a set of client IDs.",
      "ja": "複数のレプリカが存在し、（fs_locations_info内FSLIB4_CLSIMUL定義を参照）クライアントによって同時に使用される場合、O、同じデータを指定しなければなりません。ファイルシステムが書き込み可能である場合、一例で行われた変更は、直ちに修正要求者のリターンまたは関連のレプリカのいずれかにその変化の視認性の以前の時、すべてのインスタンスに表示されなければなりません。これは、クライアントが複数のレプリカがあるという事実に特別な適応せずに同時にこれらのレプリカを使用することができます。この場合、一方のレプリカで得られたロック（株予約またはバイト範囲ロックするかどうか）と代表団は直ちにこれらのロックは、クライアントIDのセットの下で管理されていても、すべてのレプリカに反映されます。"
    },
    {
      "indent": 3,
      "text": "o When one replica is designated as the successor instance to another existing instance after return NFS4ERR_MOVED (i.e., the case of migration), the client may depend on the fact that all changes written to stable storage on the original instance are written to stable storage of the successor (uncommitted writes are dealt with in Section 11.7.8).",
      "ja": "つのレプリカが別の既存のインスタンスの後継インスタンスとして指定されている場合、OリターンNFS4ERR_MOVED（すなわち、マイグレーションの場合）、クライアントは元のインスタンスに安定したストレージに書き込まれたすべての変更が安定記憶装置に書き込まれているという事実に依存してもよいした後後継者（コミットされていない書き込みは、セクション11.7.8で対処されています）。"
    },
    {
      "indent": 3,
      "text": "o Where a file system is not writable but represents a read-only copy (possibly periodically updated) of a writable file system, clients have similar requirements with regard to the propagation of updates. They may need a guarantee that any change visible on the original file system instance must be immediately visible on any replica before the client transitions access to that replica, in order to avoid any possibility that a client, in effecting a transition to a replica, will see any reversion in file system state. The specific means of this guarantee varies based on the value of the fss_type field that is reported as part of the fs_status attribute (see Section 11.11). Since these file systems are presumed to be unsuitable for simultaneous use, there is no specification of how locking is handled; in general, locks obtained on one file system will be separate from those on others. Since these are going to be read-only file systems, this is not expected to pose an issue for clients or applications.",
      "ja": "Oファイルシステムが書き込み可能ではありませんが、書き込み可能なファイルシステムの読み取り専用コピーを（おそらく定期的に更新）を表す場合、クライアントは、更新の伝播に関して同様の要件を持っています。彼らは、クライアントの遷移はそのレプリカにアクセスする前に、元のファイル・システム・インスタンス上に表示変更がレプリカへの移行を行うには、クライアントそのいずれかの可能性を避けるために、すべてのレプリカですぐに表示されなければならないことを保証します必要があるかもしれませんファイルシステムの状態のいずれかの復帰を参照してください。この保証の具体的な手段はfs_status属性の一部として報告されてfss_typeフィールドの値によって異なります（項11.11を参照してください）。これらのファイルシステムを同時に使用するには不適当であると推定されているので、ロックの処理方法の全く指定されていません。一般的に、一つのファイルシステム上で得られたロックは、他に、これらとは別であろう。これらは読み取り専用にするファイルシステムを行っているので、これは、クライアントやアプリケーションのための問題を提起することが期待されていません。"
    },
    {
      "indent": 0,
      "text": "11.8. Effecting File System Referrals",
      "section_title": true,
      "ja": "11.8. ファイルシステムの紹介を行います"
    },
    {
      "indent": 3,
      "text": "Referrals are effected when an absent file system is encountered and one or more alternate locations are made available by the fs_locations or fs_locations_info attributes. The client will typically get an NFS4ERR_MOVED error, fetch the appropriate location information, and proceed to access the file system on a different server, even though it retains its logical position within the original namespace. Referrals differ from migration events in that they happen only when the client has not previously referenced the file system in question (so there is nothing to transition). Referrals can only come into effect when an absent file system is encountered at its root.",
      "ja": "存在しないファイル・システムが検出されると、1つ以上の代替位置がfs_位置又はfs_locations_info属性によって利用可能にされるときに照会が行われます。クライアントは一般的に、それは、元の名前空間内のその論理的位置を保持していても、NFS4ERR_MOVEDエラーを取得し、適切な位置情報を取得し、別のサーバー上のファイルシステムにアクセスすることを進めてまいります。紹介は、彼らは、クライアントが以前に問題のファイルシステムを参照していないときにのみ起こることで、移行イベント異なる（その移行には何もありません）。不在のファイルシステムがそのルートに遭遇したときに、紹介にのみ発効することができます。"
    },
    {
      "indent": 3,
      "text": "The examples given in the sections below are somewhat artificial in that an actual client will not typically do a multi-component look up, but will have cached information regarding the upper levels of the name hierarchy. However, these example are chosen to make the required behavior clear and easy to put within the scope of a small number of requests, without getting unduly into details of how specific clients might choose to cache things.",
      "ja": "以下のセクションで与えられた例は、実際のクライアントは、通常、多成分を見上げるしないだろうという点で、やや人工的ですが、名前の階層の上位レベルに関する情報をキャッシュしています。しかし、これらの例は、物事をキャッシュすることを選択するかもしれない方法特定のクライアントの詳細を不当に取得せずに、リクエストの数が少ないの範囲内に置くために必要な行動を明確かつ簡単にするために選択されています。"
    },
    {
      "indent": 0,
      "text": "11.8.1. Referral Example (LOOKUP)",
      "section_title": true,
      "ja": "11.8.1. 紹介例（LOOKUP）"
    },
    {
      "indent": 3,
      "text": "Let us suppose that the following COMPOUND is sent in an environment in which /this/is/the/path is absent from the target server. This may be for a number of reasons. It may be that the file system has moved, or it may be that the target server is functioning mainly, or solely, to refer clients to the servers on which various file systems are located.",
      "ja": "私たちは、以下の化合物は、これは/である/ /パスは、ターゲットサーバーから不在である/環境に送られているとしましょう。これは、いくつかの理由のためのものであってもよいです。これは、ファイルシステムが移動したことであってもよいし、様々なファイルシステムが配置されているサーバにクライアントを参照するために、ターゲットサーバは、主に、または単に機能している可能性があります。"
    },
    {
      "indent": 3,
      "text": "o PUTROOTFH",
      "ja": "O putarutaphaha"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"this\"",
      "ja": "O LOOKUP \"この\""
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"is\"",
      "ja": "O LOOKUPは \"あります\""
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"the\"",
      "ja": "LOOKUP O \"\""
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"path\"",
      "ja": "OのLOOKUP \"パス\""
    },
    {
      "indent": 3,
      "text": "o GETFH",
      "ja": "O GETFH"
    },
    {
      "indent": 3,
      "text": "o GETATTR (fsid, fileid, size, time_modify)",
      "ja": "O GETATTR（FSID、FILEID、サイズ、time_modify）"
    },
    {
      "indent": 3,
      "text": "Under the given circumstances, the following will be the result.",
      "ja": "与えられた状況下では、以下の結果になります。"
    },
    {
      "indent": 3,
      "text": "o PUTROOTFH --> NFS_OK. The current fh is now the root of the pseudo-fs.",
      "ja": "O PUTROOTFH  - > NFS_OK。現在のFHは現在、疑似FSのルートです。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"this\" --> NFS_OK. The current fh is for /this and is within the pseudo-fs.",
      "ja": "O LOOKUP \"この\"  - > NFS_OK。現在のFH /このためのものであり、擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"is\" --> NFS_OK. The current fh is for /this/is and is within the pseudo-fs.",
      "ja": "> NFS_OK  -  O LOOKUP \"です\"。現在のFHは、/ /これをであり、擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"the\" --> NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.",
      "ja": "O LOOKUP \"\"  - > NFS_OK。現在のFHは、これが/である/のためのものである/擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"path\" --> NFS_OK. The current fh is for /this/is/the/path and is within a new, absent file system, but ... the client will never see the value of that fh.",
      "ja": "O LOOKUP \"パス\"  - > NFS_OK。現在のFHは、この/です/ /パス/のためのものであり、新たに、不在のファイルシステム内にある、しかし...クライアントは、そのFHの値を参照することはありません。"
    },
    {
      "indent": 3,
      "text": "o GETFH --> NFS4ERR_MOVED. Fails because current fh is in an absent file system at the start of the operation, and the specification makes no exception for GETFH.",
      "ja": "O GETFH  - > NFS4ERR_MOVED。現在のFHは、操作の開始時に存在しないファイルシステムであり、仕様はGETFHための例外をしないので、失敗します。"
    },
    {
      "indent": 3,
      "text": "o GETATTR (fsid, fileid, size, time_modify). Not executed because the failure of the GETFH stops processing of the COMPOUND.",
      "ja": "O GETATTR（FSID、FILEID、サイズ、time_modify）。 GETFHの障害が化合物の処理を停止するために実行されていません。"
    },
    {
      "indent": 3,
      "text": "Given the failure of the GETFH, the client has the job of determining the root of the absent file system and where to find that file system, i.e., the server and path relative to that server's root fh. Note that in this example, the client did not obtain filehandles and attribute information (e.g., fsid) for the intermediate directories, so that it would not be sure where the absent file system starts. It could be the case, for example, that /this/is/the is the root of the moved file system and that the reason that the look up of \"path\" succeeded is that the file system was not absent on that operation but was moved between the last LOOKUP and the GETFH (since COMPOUND is not atomic). Even if we had the fsids for all of the intermediate directories, we could have no way of knowing that /this/is/the/path was the root of a new file system, since we don't yet have its fsid.",
      "ja": "GETFHの失敗を考えると、クライアントは存在しないファイルシステムのルートを決定する仕事とどこそのファイルシステム、すなわち、サーバとそのサーバのルートFHへの相対パスを見つけるためにしています。不在のファイルシステムが始まることを確認しないように、この例では、クライアントがファイルハンドルを取得し、中間ディレクトリのための情報（例えば、FSID）を属性なかったことに注意してください。これは、移動したファイルシステムのルートであり、「パス」のルックアップが成功したことを理由は、ファイルシステムがその操作に存在しなかったことであることが、だった/ /これは/であること、例えば、ケースかもしれません最後LOOKUPとGETFH（化合物がアトミックではないので）との間で移動。我々は中間ディレクトリのすべてのためのfsidsを持っていたとしても、我々はまだそのFSIDを持っていないので、この/ / /パスは、新しいファイルシステムのルートは、/していることを知る方法はありませんでした。"
    },
    {
      "indent": 3,
      "text": "In order to get the necessary information, let us re-send the chain of LOOKUPs with GETFHs and GETATTRs to at least get the fsids so we can be sure where the appropriate file system boundaries are. The client could choose to get fs_locations_info at the same time but in most cases the client will have a good guess as to where file system boundaries are (because of where NFS4ERR_MOVED was, and was not, received) making fetching of fs_locations_info unnecessary.",
      "ja": "必要な情報を得るために、私たちは適切なファイルシステムの境界がどこにあるかを確認することができますように、少なくともfsidsを取得するGETFHsとGETATTRsと検索の連鎖を再送信してみましょう。クライアントが同時にfs_locations_info取得することを選択することができますが、ほとんどの場合、クライアントは、ファイルシステムの境界がfs_locations_infoのフェッチが不要になって（なぜならNFS4ERR_MOVEDだった、としなかった、受信場所の）どこにとして良い推測を持っています。"
    },
    {
      "indent": 3,
      "text": "OP01: PUTROOTFH --> NFS_OK",
      "ja": "オペアンプ01：putarutaphaha  - > naphsaoka"
    },
    {
      "indent": 3,
      "text": "- Current fh is root of pseudo-fs.",
      "ja": " - 現在のFHは、擬似FSのルートです。"
    },
    {
      "indent": 3,
      "text": "OP02: GETATTR(fsid) --> NFS_OK",
      "ja": "OP02：GETATTR（出血） - > NFS_OK"
    },
    {
      "indent": 3,
      "text": "- Just for completeness. Normally, clients will know the fsid of the pseudo-fs as soon as they establish communication with a server.",
      "ja": " - ただ、完全性のために。通常、クライアントは、すぐに彼らは、サーバとの通信を確立するよう疑似-FSのFSIDを知っています。"
    },
    {
      "indent": 3,
      "text": "OP03: LOOKUP \"this\" --> NFS_OK",
      "ja": "OP03：LOOKUP \"この\"  - > NFS_OK"
    },
    {
      "indent": 3,
      "text": "OP04: GETATTR(fsid) --> NFS_OK",
      "ja": "OP04：GETATTR（出血） - > NFS_OK"
    },
    {
      "indent": 3,
      "text": "- Get current fsid to see where file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.",
      "ja": " - ファイルシステムの境界がどこにあるか確認するために、現在のFSIDを取得します。 FSIDは、この例では、擬似FS、それほどない境界のためにそれをあろう。"
    },
    {
      "indent": 3,
      "text": "OP05: GETFH --> NFS_OK",
      "ja": "ウェブ05：Jtvh  - >自分"
    },
    {
      "indent": 3,
      "text": "- Current fh is for /this and is within pseudo-fs.",
      "ja": " - 現在のFHは/このためであると擬似FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "OP06: LOOKUP \"is\" --> NFS_OK",
      "ja": "OP06：LOOKUPは \"ある\"  - > NFS_OK"
    },
    {
      "indent": 3,
      "text": "- Current fh is for /this/is and is within pseudo-fs.",
      "ja": " - 現在のFHは、/ /のためにこれをであると擬似FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "OP07: GETATTR(fsid) --> NFS_OK",
      "ja": "OP07：GETATTR（出血） - > NFS_OK"
    },
    {
      "indent": 3,
      "text": "- Get current fsid to see where file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.",
      "ja": " - ファイルシステムの境界がどこにあるか確認するために、現在のFSIDを取得します。 FSIDは、この例では、擬似FS、それほどない境界のためにそれをあろう。"
    },
    {
      "indent": 3,
      "text": "OP08: GETFH --> NFS_OK",
      "ja": "ウェブ08：Jtvh  - >自分"
    },
    {
      "indent": 3,
      "text": "- Current fh is for /this/is and is within pseudo-fs.",
      "ja": " - 現在のFHは、/ /のためにこれをであると擬似FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "OP09: LOOKUP \"the\" --> NFS_OK",
      "ja": "OP09：LOOKUP \"\"  - > NFS_OK"
    },
    {
      "indent": 3,
      "text": "- Current fh is for /this/is/the and is within pseudo-fs.",
      "ja": " - 現在のFHは、これが/である/のためのものである/擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "OP10: GETATTR(fsid) --> NFS_OK",
      "ja": "OP10：GETATTR（出血） - > NFS_OK"
    },
    {
      "indent": 3,
      "text": "- Get current fsid to see where file system boundaries are. The fsid will be that for the pseudo-fs in this example, so no boundary.",
      "ja": " - ファイルシステムの境界がどこにあるか確認するために、現在のFSIDを取得します。 FSIDは、この例では、擬似FS、それほどない境界のためにそれをあろう。"
    },
    {
      "indent": 3,
      "text": "OP11: GETFH --> NFS_OK",
      "ja": "B 11：Jtvh  - >自分"
    },
    {
      "indent": 3,
      "text": "- Current fh is for /this/is/the and is within pseudo-fs.",
      "ja": " - 現在のFHは、これが/である/のためのものである/擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "OP12: LOOKUP \"path\" --> NFS_OK",
      "ja": "OP12：LOOKUP \"パス\"  - > NFS_OK"
    },
    {
      "indent": 3,
      "text": "- Current fh is for /this/is/the/path and is within a new, absent file system, but ...",
      "ja": " - 現在のFHは、この/です/ /パス/のためのものであり、新たに、不在のファイルシステム内にある、しかし..."
    },
    {
      "indent": 3,
      "text": "- The client will never see the value of that fh.",
      "ja": " - クライアントは、そのFHの値を参照することはありません。"
    },
    {
      "indent": 3,
      "text": "OP13: GETATTR(fsid, fs_locations_info) --> NFS_OK",
      "ja": "OP13：GETATTR（出血、fs_locations_info） - > NFS_OK"
    },
    {
      "indent": 3,
      "text": "- We are getting the fsid to know where the file system boundaries are. In this operation, the fsid will be different than that of the parent directory (which in turn was retrieved in OP10). Note that the fsid we are given will not necessarily be preserved at the new location. That fsid might be different, and in fact the fsid we have for this file system might be a valid fsid of a different file system on that new server.",
      "ja": " - 私たちは、ファイルシステムの境界がどこにあるか知っているFSIDを得ています。この操作では、FSIDは（順番にOP10で取得された）親ディレクトリとは異なるであろう。私たちは与えられたFSIDは必ずしも新しい場所で保存されないことに注意してください。それFSIDは異なる場合があり、実際には、このファイルシステムのための私たちが持っているFSIDはその新しいサーバ上の異なるファイルシステムの有効FSIDかもしれません。"
    },
    {
      "indent": 3,
      "text": "- In this particular case, we are pretty sure anyway that what has moved is /this/is/the/path rather than /this/is/the since we have the fsid of the latter and it is that of the pseudo-fs, which presumably cannot move. However, in other examples, we might not have this kind of information to rely on (e.g., /this/is/the might be a non-pseudo file system separate from /this/is/the/path), so we need to have other reliable source information on the boundary of the file system that is moved. If, for example, the file system /this/is had moved, we would have a case of migration rather than referral, and once the boundaries of the migrated file system was clear we could fetch fs_locations_info.",
      "ja": " - この特定のケースでは、我々はとにかく何を移動していること/本/である/ /パスではなくであることをかなり確信している/この/である/私たちは後者のFSIDを持っており、それはその疑似Fのであるから、これはおそらく移動することはできません。しかし、他の例では、我々はに頼るこの種の情報を持っていない可能性があります（例えば、/この/ /このは別に非擬似ファイルシステムであるかもしれない/ / /パス/です）ので、私たちのようにする必要があり移動されたファイルシステムの境界上の他の信頼できる情報源の情報を持っています。例えば、ファイルシステムが/これは/移動したならば、我々は、移行ではなく、紹介のケースを持っているでしょうし、移行したファイルシステムの境界が明確になったら、私たちはfs_locations_infoフェッチできます。"
    },
    {
      "indent": 3,
      "text": "- We are fetching fs_locations_info because the fact that we got an NFS4ERR_MOVED at this point means that it is most likely that this is a referral and we need the destination. Even if it is the case that /this/is/the is a file system that has migrated, we will still need the location information for that file system.",
      "ja": " - 私たちは、この時点でNFS4ERR_MOVEDを得たという事実は、これは紹介され、私たちは先を必要とする可能性が最も高いことを意味するので、私たちはfs_locations_infoフェッチされています。それは、これは/移行したファイルシステムである/である/場合であっても、我々はまだそのファイルシステムの位置情報が必要になります。"
    },
    {
      "indent": 3,
      "text": "OP14: GETFH --> NFS4ERR_MOVED",
      "ja": "OP14：GETFH  - > NFS4ERR_MOVED"
    },
    {
      "indent": 3,
      "text": "- Fails because current fh is in an absent file system at the start of the operation, and the specification makes no exception for GETFH. Note that this means the server will never send the client a filehandle from within an absent file system.",
      "ja": " - 現在のFHは、操作の開始時に存在しないファイルシステムであり、仕様はGETFHための例外をしないため失敗。これは、サーバーが不在のファイルシステム内からクライアントにファイルハンドルを送信することはありませんを意味します。"
    },
    {
      "indent": 3,
      "text": "Given the above, the client knows where the root of the absent file system is (/this/is/the/path) by noting where the change of fsid occurred (between \"the\" and \"path\"). The fs_locations_info attribute also gives the client the actual location of the absent file system, so that the referral can proceed. The server gives the client the bare minimum of information about the absent file system so that there will be very little scope for problems of conflict between information sent by the referring server and information of the file system's home. No filehandles and very few attributes are present on the referring server, and the client can treat those it receives as transient information with the function of enabling the referral.",
      "ja": "上記を考えると、クライアントはFSIDの変更が（「」と「パス」の間で）発生した場所を注意することによって（/本/である/ /パス）不在のファイルシステムのルートがどこにあるか知っています。紹介を進めることができるようにfs_locations_info属性も、クライアントに欠け、ファイルシステムの実際の場所を提供します。ファイルシステムのホームの参照サーバとの情報から送信された情報間の紛争の問題のための非常に小さな範囲が存在することになるように、サーバーはクライアントに不在のファイルシステムに関する情報の最低限を提供します。いいえ、ファイルハンドルと非常に少数の属性が参照するサーバー上に存在しない、そしてクライアントが紹介を可能にする機能を備えた過渡的な情報として受け取るものを扱うことができます。"
    },
    {
      "indent": 0,
      "text": "11.8.2. Referral Example (READDIR)",
      "section_title": true,
      "ja": "11.8.2. 紹介例（READDIR）"
    },
    {
      "indent": 3,
      "text": "Another context in which a client may encounter referrals is when it does a READDIR on a directory in which some of the sub-directories are the roots of absent file systems.",
      "ja": "それはサブディレクトリの一部が欠けているファイルシステムの根されているディレクトリにREADDIRをしたときに、クライアントは紹介に遭遇する可能性のある別のコンテキストがあります。"
    },
    {
      "indent": 3,
      "text": "Suppose such a directory is read as follows:",
      "ja": "次のようなディレクトリが読まれていると仮定します。"
    },
    {
      "indent": 3,
      "text": "o PUTROOTFH",
      "ja": "O putarutaphaha"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"this\"",
      "ja": "O LOOKUP \"この\""
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"is\"",
      "ja": "O LOOKUPは \"あります\""
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"the\"",
      "ja": "LOOKUP O \"\""
    },
    {
      "indent": 3,
      "text": "o READDIR (fsid, size, time_modify, mounted_on_fileid)",
      "ja": "O READDIR（FSID、サイズ、time_modify、mounted_on_fileid）"
    },
    {
      "indent": 3,
      "text": "In this case, because rdattr_error is not requested, fs_locations_info is not requested, and some of the attributes cannot be provided, the result will be an NFS4ERR_MOVED error on the READDIR, with the detailed results as follows:",
      "ja": "次のようにrdattr_errorが要求されていないので、この場合には、fs_locations_info要求されていない、および属性のいくつかを提供することができず、結果は、詳細な結果を、READDIRにNFS4ERR_MOVEDエラーになります。"
    },
    {
      "indent": 3,
      "text": "o PUTROOTFH --> NFS_OK. The current fh is at the root of the pseudo-fs.",
      "ja": "O PUTROOTFH  - > NFS_OK。現在のFHは、擬似-FSのルートです。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"this\" --> NFS_OK. The current fh is for /this and is within the pseudo-fs.",
      "ja": "O LOOKUP \"この\"  - > NFS_OK。現在のFH /このためのものであり、擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"is\" --> NFS_OK. The current fh is for /this/is and is within the pseudo-fs.",
      "ja": "> NFS_OK  -  O LOOKUP \"です\"。現在のFHは、/ /これをであり、擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"the\" --> NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.",
      "ja": "O LOOKUP \"\"  - > NFS_OK。現在のFHは、これが/である/のためのものである/擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "o READDIR (fsid, size, time_modify, mounted_on_fileid) --> NFS4ERR_MOVED. Note that the same error would have been returned if /this/is/the had migrated, but it is returned because the directory contains the root of an absent file system.",
      "ja": "O READDIR（FSID、サイズ、time_modify、mounted_on_fileid） - > NFS4ERR_MOVED。同じエラーがこの/ / /移動した場合に返されたであろう、しかし、ディレクトリが存在しないファイルシステムのルートが含まれているため、それが返されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "So now suppose that we re-send with rdattr_error:",
      "ja": "だから今、私たちはrdattr_errorで再送信したとします。"
    },
    {
      "indent": 3,
      "text": "o PUTROOTFH",
      "ja": "O putarutaphaha"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"this\"",
      "ja": "O LOOKUP \"この\""
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"is\"",
      "ja": "O LOOKUPは \"あります\""
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"the\"",
      "ja": "LOOKUP O \"\""
    },
    {
      "indent": 3,
      "text": "o READDIR (rdattr_error, fsid, size, time_modify, mounted_on_fileid)",
      "ja": "O READDIR（rdattr_error、FSID、サイズ、time_modify、mounted_on_fileid）"
    },
    {
      "indent": 3,
      "text": "The results will be:",
      "ja": "結果は次のようになります。"
    },
    {
      "indent": 3,
      "text": "o PUTROOTFH --> NFS_OK. The current fh is at the root of the pseudo-fs.",
      "ja": "O PUTROOTFH  - > NFS_OK。現在のFHは、擬似-FSのルートです。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"this\" --> NFS_OK. The current fh is for /this and is within the pseudo-fs.",
      "ja": "O LOOKUP \"この\"  - > NFS_OK。現在のFH /このためのものであり、擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"is\" --> NFS_OK. The current fh is for /this/is and is within the pseudo-fs.",
      "ja": "> NFS_OK  -  O LOOKUP \"です\"。現在のFHは、/ /これをであり、擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"the\" --> NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.",
      "ja": "O LOOKUP \"\"  - > NFS_OK。現在のFHは、これが/である/のためのものである/擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "o READDIR (rdattr_error, fsid, size, time_modify, mounted_on_fileid) --> NFS_OK. The attributes for directory entry with the component named \"path\" will only contain rdattr_error with the value NFS4ERR_MOVED, together with an fsid value and a value for mounted_on_fileid.",
      "ja": "O READDIR（rdattr_error、FSID、サイズ、time_modify、mounted_on_fileid） - > NFS_OK。 「パス」という名前のコンポーネントを持つディレクトリエントリの属性は、唯一のFSID値とmounted_on_fileidの値と一緒に、値NFS4ERR_MOVEDとrdattr_errorが含まれています。"
    },
    {
      "indent": 3,
      "text": "So suppose we do another READDIR to get fs_locations_info (although we could have used a GETATTR directly, as in Section 11.8.1).",
      "ja": "だから我々は（我々は、セクション11.8.1のように、直接GETATTRを使用することもできましたが）別のREADDIRがfs_locations_infoを得るために行うとします。"
    },
    {
      "indent": 3,
      "text": "o PUTROOTFH",
      "ja": "O putarutaphaha"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"this\"",
      "ja": "O LOOKUP \"この\""
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"is\"",
      "ja": "O LOOKUPは \"あります\""
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"the\"",
      "ja": "LOOKUP O \"\""
    },
    {
      "indent": 3,
      "text": "o READDIR (rdattr_error, fs_locations_info, mounted_on_fileid, fsid, size, time_modify)",
      "ja": "O READDIR（rdattr_error、fs_locations_info、mounted_on_fileid、FSID、サイズ、time_modify）"
    },
    {
      "indent": 3,
      "text": "The results would be:",
      "ja": "結果は次のようになります。"
    },
    {
      "indent": 3,
      "text": "o PUTROOTFH --> NFS_OK. The current fh is at the root of the pseudo-fs.",
      "ja": "O PUTROOTFH  - > NFS_OK。現在のFHは、擬似-FSのルートです。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"this\" --> NFS_OK. The current fh is for /this and is within the pseudo-fs.",
      "ja": "O LOOKUP \"この\"  - > NFS_OK。現在のFH /このためのものであり、擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"is\" --> NFS_OK. The current fh is for /this/is and is within the pseudo-fs.",
      "ja": "> NFS_OK  -  O LOOKUP \"です\"。現在のFHは、/ /これをであり、擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "o LOOKUP \"the\" --> NFS_OK. The current fh is for /this/is/the and is within the pseudo-fs.",
      "ja": "O LOOKUP \"\"  - > NFS_OK。現在のFHは、これが/である/のためのものである/擬似-FSの範囲内です。"
    },
    {
      "indent": 3,
      "text": "o READDIR (rdattr_error, fs_locations_info, mounted_on_fileid, fsid, size, time_modify) --> NFS_OK. The attributes will be as shown below.",
      "ja": "O READDIR（rdattr_error、fs_locations_info、mounted_on_fileid、FSID、サイズ、time_modify） - > NFS_OK。属性は以下のように表示されます。"
    },
    {
      "indent": 3,
      "text": "The attributes for the directory entry with the component named \"path\" will only contain:",
      "ja": "「パス」という名前のコンポーネントを持つディレクトリエントリの属性にのみ含まれます。"
    },
    {
      "indent": 3,
      "text": "o rdattr_error (value: NFS_OK)",
      "ja": "入出力rdattr_error（値：NFS_OK）"
    },
    {
      "indent": 3,
      "text": "o fs_locations_info",
      "ja": "O fs_locations_info"
    },
    {
      "indent": 3,
      "text": "o mounted_on_fileid (value: unique fileid within referring file system)",
      "ja": "O mounted_on_fileid（値：参照するファイルシステム内で一意FILEID）"
    },
    {
      "indent": 3,
      "text": "o fsid (value: unique value within referring server)",
      "ja": "O FSID（値：参照サーバー内で一意の値）"
    },
    {
      "indent": 3,
      "text": "The attributes for entry \"path\" will not contain size or time_modify because these attributes are not available within an absent file system.",
      "ja": "これらの属性は、存在しないファイルシステム内で利用できないため、エントリ「パス」の属性は、サイズやtime_modifyは含まれません。"
    },
    {
      "indent": 0,
      "text": "11.9. The Attribute fs_locations",
      "section_title": true,
      "ja": "11.9. 属性fs_位置"
    },
    {
      "indent": 3,
      "text": "The fs_locations attribute is structured in the following way:",
      "ja": "fs_位置は次のように構成されている属性："
    },
    {
      "indent": 3,
      "text": "struct fs_location4 {\n        utf8str_cis     server<>;\n        pathname4       rootpath;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct fs_locations4 {\n        pathname4       fs_root;\n        fs_location4    locations<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fs_location4 data type is used to represent the location of a file system by providing a server name and the path to the root of the file system within that server's namespace. When a set of servers have corresponding file systems at the same path within their namespaces, an array of server names may be provided. An entry in the server array is a UTF-8 string and represents one of a traditional DNS host name, IPv4 address, IPv6 address, or a zero-length string. An IPv4 or IPv6 address is represented as a universal address (see Section 3.3.9 and [15]), minus the netid, and either with or without the trailing \".p1.p2\" suffix that represents the port number. If the suffix is omitted, then the default port, 2049, SHOULD be assumed. A zero-length string SHOULD be used to indicate the current address being used for the RPC call. It is not a requirement that all servers that share the same rootpath be listed in one fs_location4 instance. The array of server names is provided for convenience. Servers that share the same rootpath may also be listed in separate fs_location4 entries in the fs_locations attribute.",
      "ja": "fs_location4データ型は、サーバ名とそのサーバの名前空間内のファイル・システムのルートへのパスを提供することによって、ファイルシステムの位置を表すために使用されます。サーバのセットは、その名前空間内の同じパスに対応するファイルシステムを持っている場合は、サーバー名の配列を提供することができます。サーバーアレイ内のエントリは、UTF-8文字列であり、伝統的なDNSホスト名、IPv4アドレス、IPv6アドレス、または長さゼロの文字列の1つを表します。 IPv4またはIPv6アドレスを汎用アドレス（セクション3.3.9および[15]を参照）、マイナスNETIDとして表され、そして付きまたはポート番号を表し、末尾の「.p1.p2\" 接尾辞無しのいずれかです。接尾語を省略すると、デフォルトのポート、2049年には、想定されるべきです。長さゼロの文字列は、RPC呼び出しのために使用されている現在のアドレスを示すために使用されるべきです。これは、同じROOTPATHを共有するすべてのサーバーが1つのfs_location4インスタンスに一覧表示され要件ではありません。サーバー名の配列は、便宜のために提供されます。同じROOTPATHを共有するサーバもfs_位置の属性で別のfs_location4エントリに表示されることがあります。"
    },
    {
      "indent": 3,
      "text": "The fs_locations4 data type and fs_locations attribute contain an array of such locations. Since the namespace of each server may be constructed differently, the \"fs_root\" field is provided. The path represented by fs_root represents the location of the file system in the current server's namespace, i.e., that of the server from which the fs_locations attribute was obtained. The fs_root path is meant to aid the client by clearly referencing the root of the file system whose locations are being reported, no matter what object within the current file system the current filehandle designates. The fs_root is simply the pathname the client used to reach the object on the current server (i.e., the object to which the fs_locations attribute applies).",
      "ja": "fs_locations4データタイプとfs_位置は、位置のアレイを含む属性。各サーバーの名前空間が異なって構成することができるので、「fs_root」欄が設けられています。 fs_rootで表される経路は、fs_位置の属性が取得されたサーバのもの、すなわち、現在のサーバの名前空間内のファイル・システムの位置を表します。 fs_rootパスが明確に場所に関係なく、現在のファイルハンドルを指定し、現在のファイルシステム内のどのオブジェクト、報告されていないされているファイルシステムのルートを参照することで、クライアントを支援するためのものです。 fs_rootは単にパス名現在のサーバー（すなわち、fs_位置がどの属性にオブジェクトが適用される）上のオブジェクトに到達するために使用されるクライアントです。"
    },
    {
      "indent": 3,
      "text": "When the fs_locations attribute is interrogated and there are no alternate file system locations, the server SHOULD return a zero-length array of fs_location4 structures, together with a valid fs_root.",
      "ja": "fs_位置が調べられる属性と全く別のファイルシステムの場所が存在しない場合、サーバは、一緒に有効fs_rootと、fs_location4構造の長さゼロの配列を返すべきです。"
    },
    {
      "indent": 3,
      "text": "As an example, suppose there is a replicated file system located at two servers (servA and servB). At servA, the file system is located at path /a/b/c. At, servB the file system is located at path /x/y/z. If the client were to obtain the fs_locations value for the directory at /a/b/c/d, it might not necessarily know that the file system's root is located in servA's namespace at /a/b/c. When the client switches to servB, it will need to determine that the directory it first referenced at servA is now represented by the path /x/y/z/d on servB. To facilitate this, the fs_locations attribute provided by servA would have an fs_root value of /a/b/c and two entries in fs_locations. One entry in fs_locations will be for itself (servA) and the other will be for servB with a path of /x/y/z. With this information, the client is able to substitute /x/y/z for the /a/b/c at the beginning of its access path and construct /x/y/z/d to use for the new server.",
      "ja": "一例として、2台のサーバ（SERVAとservB）に位置する複製されたファイルシステムがあると仮定する。 SERVAで、ファイルシステムは、パス/ A / B / Cに位置しています。 servBにおいて、ファイルシステムは、パス/ X / Y / Zに位置しています。クライアントは/ A / B / C / Dでのディレクトリのfs_位置の値を取得した場合、それは必ずしも、ファイルシステムのルートが/ A / B / Cでセルバの名前空間に配置されていることを知らないかもしれません。クライアントはservBに切り替わるときに、それは最初SERVAで参照されるディレクトリは現在servBのパス/ X / Y / Z / Dで表されることを決定する必要があります。これを容易にするために、SERVAによって提供される属性fs_位置はfs_rootの/ A / B / Cの値とfs_位置に2つのエントリを有することになります。 fs_位置における1つのエントリがそれ自身のために（SERVA）になり、他方は/ X / Y / ZのパスとservBためであろう。この情報により、クライアントは、そのアクセスパスの先頭に/ A / B / Cのための/ X / Y / Zを代入して、新しいサーバに使用する/ X / Y / Z / Dを構築することが可能です。"
    },
    {
      "indent": 3,
      "text": "Note that there is no requirement that the number of components in each rootpath be the same; there is no relation between the number of components in rootpath or fs_root, and none of the components in a rootpath and fs_root have to be the same. In the above example, we could have had a third element in the locations array, with server equal to \"servC\" and rootpath equal to \"/I/II\", and a fourth element in locations with server equal to \"servD\" and rootpath equal to \"/aleph/beth/gimel/daleth/he\".",
      "ja": "各ROOTPATH中の成分の数は同じである必要はないことに留意されたいです。 ROOTPATH又はfs_root、およびROOTPATHとfs_root中の成分のいずれの成分数との間には関係がないが、同じでなければなりません。上記の例では、サーバ等しい「SERVC」および「/ I / II」に等しいROOTPATH、及び「servD」に等しいサーバとROOTPATHと場所で第4要素と、位置のアレイの3番目の要素を持っていた可能性が\"/アレフ/ベス/ギメル/ daleth /彼\" に等しいです。"
    },
    {
      "indent": 3,
      "text": "The relationship between fs_root to a rootpath is that the client replaces the pathname indicated in fs_root for the current server for the substitute indicated in rootpath for the new server.",
      "ja": "ROOTPATHにfs_rootとの関係は、クライアントが新しいサーバーのROOTPATHに示されている代替のための現在のサーバー用fs_rootに示されたパス名を置き換えることです。"
    },
    {
      "indent": 3,
      "text": "For an example of a referred or migrated file system, suppose there is a file system located at serv1. At serv1, the file system is located at /az/buky/vedi/glagoli. The client finds that object at glagoli has migrated (or is a referral). The client gets the fs_locations attribute, which contains an fs_root of /az/buky/vedi/ glagoli, and one element in the locations array, with server equal to serv2, and rootpath equal to /izhitsa/fita. The client replaces /az/ buky/vedi/glagoli with /izhitsa/fita, and uses the latter pathname on serv2.",
      "ja": "参照またはマイグレーションファイルシステムの例については、SERV1に位置するファイルシステムが存在すると仮定する。 SERV1では、ファイルシステムは/ AZ / buky / vedi / glagoliに位置しています。クライアントはglagoliのオブジェクトが移行していることを見つけた（または紹介です）。クライアントは、SERV2に等しいサーバ、および/ izhitsa /フィッタに等しいROOTPATHと/ AZ / buky / vedi / glagoliのfs_root、及び場所アレイ内の1つの要素を含む、fs_位置属性を取得します。クライアントは/ izhitsa /フィッタで/ AZ / buky / vedi / glagoliを置き換え、そしてSERV2に後者のパス名を使用しています。"
    },
    {
      "indent": 3,
      "text": "Thus, the server MUST return an fs_root that is equal to the path the client used to reach the object to which the fs_locations attribute applies. Otherwise, the client cannot determine the new path to use on the new server.",
      "ja": "したがって、サーバーは、クライアントがfs_位置が適用されるどの属性にオブジェクトに到達するために使用されるパスに等しいfs_rootを返さなければなりません。そうでない場合、クライアントは、新しいサーバーで使用する新しいパスを決定することはできません。"
    },
    {
      "indent": 3,
      "text": "Since the fs_locations attribute lacks information defining various attributes of the various file system choices presented, it SHOULD only be interrogated and used when fs_locations_info is not available. When fs_locations is used, information about the specific locations should be assumed based on the following rules.",
      "ja": "fs_位置が提示された様々なファイルシステムの選択肢のさまざまな属性を定義する情報が欠けている属性ので、それだけで尋問されるべきであり、fs_locations_infoが利用できないときに使用されます。 fs_位置が使用される場合、特定の場所についての情報は、次の規則に基づいて想定されるべきです。"
    },
    {
      "indent": 3,
      "text": "The following rules are general and apply irrespective of the context.",
      "ja": "以下の規則は、一般的であり、文脈に関係なく適用されます。"
    },
    {
      "indent": 3,
      "text": "o All listed file system instances should be considered as of the same handle class, if and only if, the current fh_expire_type attribute does not include the FH4_VOL_MIGRATION bit. Note that in the case of referral, filehandle issues do not apply since there can be no filehandles known within the current file system, nor is there any access to the fh_expire_type attribute on the referring (absent) file system.",
      "ja": "Oすべて記載されているファイル・システム・インスタンスがあればと場合にのみ、現在のfh_expire_type属性がFH4_VOL_MIGRATIONビットが含まれていない、同じハンドルクラスのとして考慮されるべきです。現在のファイルシステム内で知られている何のファイルハンドルがないことができるので、紹介の場合には、ファイルハンドルの問題は適用されないことに注意してください、また参照（不在）ファイルシステム上のfh_expire_type属性へのアクセスがあります。"
    },
    {
      "indent": 3,
      "text": "o All listed file system instances should be considered as of the same fileid class if and only if the fh_expire_type attribute indicates persistent filehandles and does not include the FH4_VOL_MIGRATION bit. Note that in the case of referral, fileid issues do not apply since there can be no fileids known within the referring (absent) file system, nor is there any access to the fh_expire_type attribute.",
      "ja": "Oすべて記載されているファイル・システム・インスタンスがあれば、同じFILEIDクラスのとして考慮されるべきであるとfh_expire_type属性が永続的なファイルハンドルを示し、FH4_VOL_MIGRATIONビットが含まれていない場合に限ります。紹介の場合には、参照（不在）、ファイルシステム内で知られているいかなるfileidsはあり得ないので、問題は適用されません、またfh_expire_type属性へのアクセスがあるFILEIDことに注意してください。"
    },
    {
      "indent": 3,
      "text": "o All file system instances servers should be considered as of different change classes.",
      "ja": "Oすべてのファイル・システム・インスタンスのサーバーでは、さまざまな変更クラスのとして考慮されるべきです。"
    },
    {
      "indent": 3,
      "text": "For other class assignments, handling of file system transitions depends on the reasons for the transition:",
      "ja": "他のクラスの割り当てについては、ファイルシステムの移行の取り扱いは、移行の理由によって異なります。"
    },
    {
      "indent": 3,
      "text": "o When the transition is due to migration, that is, the client was directed to a new file system after receiving an NFS4ERR_MOVED error, the target should be treated as being of the same write-verifier class as the source.",
      "ja": "移行は、移行によるものである場合、O、それは、クライアントがNFS4ERR_MOVEDエラーを受信した後に新しいファイルシステムを対象としており、ターゲットはソースと同じ書き込みベリファイアクラスであるものとして扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "o When the transition is due to failover to another replica, that is, the client selected another replica without receiving an NFS4ERR_MOVED error, the target should be treated as being of a different write-verifier class from the source.",
      "ja": "O移行はそれがNFS4ERR_MOVEDエラーを受信せずに別のレプリカを選択したクライアントは、ターゲットは、ソースとは異なる書き込みベリファイアクラスであるものとして扱われるべきである、別のレプリカにフェイルオーバーによるものである場合。"
    },
    {
      "indent": 3,
      "text": "The specific choices reflect typical implementation patterns for failover and controlled migration, respectively. Since other choices are possible and useful, this information is better obtained by using fs_locations_info. When a server implementation needs to communicate other choices, it MUST support the fs_locations_info attribute.",
      "ja": "具体的な選択肢は、それぞれ、フェイルオーバーおよび制御の移行のための典型的な実装パターンを反映しています。他の選択肢は、可能かつ有用であるので、この情報は、より良いfs_locations_infoを使用することによって得られます。サーバの実装は、他の選択肢を通信する必要がある場合、それはfs_locations_info属性をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "See Section 21 for a discussion on the recommendations for the security flavor to be used by any GETATTR operation that requests the \"fs_locations\" attribute.",
      "ja": "「fs_位置」属性を要求した任意のGETATTR操作で使用されるセキュリティ風味のための勧告に関する議論については、セクション21を参照してください。"
    },
    {
      "indent": 0,
      "text": "11.10. The Attribute fs_locations_info",
      "section_title": true,
      "ja": "11.10. 属性fs_locations_info"
    },
    {
      "indent": 3,
      "text": "The fs_locations_info attribute is intended as a more functional replacement for fs_locations that will continue to exist and be supported. Clients can use it to get a more complete set of information about alternative file system locations. When the server does not support fs_locations_info, fs_locations can be used to get a subset of the information. A server that supports fs_locations_info MUST support fs_locations as well.",
      "ja": "fs_locations_info属性は存在し続けると、サポートされfs_位置のためのより多くの機能代替として意図されています。クライアントは、代替ファイルシステムの場所に関する情報のより完全なセットを取得するためにそれを使用することができます。サーバがfs_locations_infoをサポートしていない場合は、fs_位置は、情報のサブセットを取得するために使用することができます。 fs_locations_infoをサポートするサーバーは、同様にfs_位置をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "There is additional information present in fs_locations_info, that is not available in fs_locations:",
      "ja": "fs_位置では使用できませんfs_locations_infoに存在する追加情報があります："
    },
    {
      "indent": 3,
      "text": "o Attribute continuity information. This information will allow a client to select a location that meets the transparency requirements of the applications accessing the data and to leverage optimizations due to the server guarantees of attribute continuity (e.g., if between multiple server locations the change attribute of a file of the file system is continuous, the client does not have to invalidate the file's cache if the change attribute is the same among all locations).",
      "ja": "O連続性情報を属性。複数のサーバーの場所ファイルのファイルの変更属性の間であれば、この情報は、例えば（クライアントがデータにアクセスするアプリケーションの透明性の要件を満たす場所を選択し、原因属性の継続のサーバー保証への最適化を活用することができます変化属性は、すべての場所の間で同じであれば、システムが連続している、クライアント）は、ファイルのキャッシュを無効にする必要はありません。"
    },
    {
      "indent": 3,
      "text": "o File system identity information that indicates when multiple replicas, from the client's point of view, correspond to the same target file system, allowing them to be used interchangeably, without disruption, as multiple paths to the same thing.",
      "ja": "クライアントの観点から、O複数のレプリカを示しているファイルシステムの識別情報は、同じ事への複数のパスとして、それらを中断することなく、互換的に使用することができるように、同じターゲット・ファイル・システムに対応しています。"
    },
    {
      "indent": 3,
      "text": "o Information that will bear on the suitability of various replicas, depending on the use that the client intends. For example, many applications need an absolutely up-to-date copy (e.g., those that write), while others may only need access to the most up-to-date copy reasonably available.",
      "ja": "クライアントが意図する用途に応じて、様々なレプリカの適性に負担になる情報を、O。たとえば、多くのアプリケーションは絶対に最新のコピーを必要とする（例えば、書きもの）、他は唯一の合理的に利用できる最新のコピーへのアクセスを必要とするかもしれません。"
    },
    {
      "indent": 3,
      "text": "o Server-derived preference information for replicas, which can be used to implement load-balancing while giving the client the entire file system list to be used in case the primary fails.",
      "ja": "クライアントをプライマリに障害が発生した場合に使用するファイルシステム全体のリストを与えながら、負荷分散を実装するために使用することができレプリカ、のためのOサーバー由来の選好情報。"
    },
    {
      "indent": 3,
      "text": "The fs_locations_info attribute is structured similarly to the fs_locations attribute. A top-level structure (fs_locations_info4) contains the entire attribute including the root pathname of the file system and an array of lower-level structures that define replicas that share a common rootpath on their respective servers. The lower-level structure in turn (fs_locations_item4) contains a specific pathname and information on one or more individual server replicas. For that last lowest-level, fs_locations_info has an fs_locations_server4 structure that contains per-server-replica information in addition to the server name. This per-server-replica information includes a nominally opaque array, fls_info, in which specific pieces of information are located at the specific indices listed below.",
      "ja": "fs_locations_info属性はfs_位置の属性と同様に構成されています。トップレベル構造（fs_locations_info4）は、ファイル・システムのルート・パス名と、それぞれのサーバ上の共通ROOTPATHを共有複製を定義する下位構造のアレイを含む全体の属性を含んでいます。次に下位構造（fs_locations_item4）は、1つ以上の個々のサーバ・レプリカ上の特定のパス名情報を含んでいます。その最後の最下位レベルの場合、fs_locations_infoは、サーバー名に加えて、サーバ毎の-レプリカの情報が含まれていfs_locations_server4構造を有しています。このごとのサーバレプリカ情報は、特定の情報を以下に列挙する特定のインデックスに配置された名目上の不透明な配列、fls_infoを含みます。"
    },
    {
      "indent": 3,
      "text": "The attribute will always contain at least a single fs_locations_server entry. Typically, this will be an entry with the FS4LIGF_CUR_REQ flag set, although in the case of a referral there will be no entry with that flag set.",
      "ja": "属性は常に、少なくとも一つのfs_locations_serverエントリが含まれています。照会の場合には、そのフラグが設定されたエントリが存在しないであろうが、典型的には、これは、FS4LIGF_CUR_REQフラグが設定されたエントリであろう。"
    },
    {
      "indent": 3,
      "text": "It should be noted that fs_locations_info attributes returned by servers for various replicas may differ for various reasons. One server may know about a set of replicas that are not known to other servers. Further, compatibility attributes may differ. Filehandles might be of the same class going from replica A to replica B but not going in the reverse direction. This might happen because the filehandles are the same, but replica B's server implementation might not have provision to note and report that equivalence.",
      "ja": "様々なレプリカのためにサーバによって返さfs_locations_info属性はさまざまな理由で異なることに留意すべきです。 1台のサーバが他のサーバに知られていないレプリカのセットについて知っていることがあります。さらに、互換性の属性が異なる場合があります。ファイルハンドルは、同じクラスのレプリカBにレプリカAから行くが、逆方向に行くのではないのかもしれません。ファイルハンドルが同じであるので、これは起こるかもしれませんが、レプリカBのサーバーの実装は注意して、その等価性を報告する規定を持っていない可能性があります。"
    },
    {
      "indent": 3,
      "text": "The fs_locations_info attribute consists of a root pathname (fli_fs_root, just like fs_root in the fs_locations attribute), together with an array of fs_location_item4 structures. The fs_location_item4 structures in turn consist of a root pathname (fli_rootpath) together with an array (fli_entries) of elements of data type fs_locations_server4, all defined as follows.",
      "ja": "fs_locations_info属性は一緒にfs_location_item4構造体のアレイと、（fs_位置でfs_root属性と同じように、fli_fs_root）ルートパス名から成ります。次にfs_location_item4構造は一緒に次のように全ての定義データ型fs_locations_server4の素子のアレイ（fli_entries）とルートパス名（fli_rootpath）から成ります。"
    },
    {
      "indent": 3,
      "text": "/*\n * Defines an individual server replica\n */\nstruct  fs_locations_server4 {\n        int32_t         fls_currency;\n        opaque          fls_info<>;\n        utf8str_cis     fls_server;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Byte indices of items within\n * fls_info: flag fields, class numbers,\n * bytes indicating ranks and orders.\n */\nconst FSLI4BX_GFLAGS            = 0;\nconst FSLI4BX_TFLAGS            = 1;\nconst FSLI4BX_CLSIMUL           = 2;\nconst FSLI4BX_CLHANDLE          = 3;\nconst FSLI4BX_CLFILEID          = 4;\nconst FSLI4BX_CLWRITEVER        = 5;\nconst FSLI4BX_CLCHANGE          = 6;\nconst FSLI4BX_CLREADDIR         = 7;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const FSLI4BX_READRANK          = 8;\nconst FSLI4BX_WRITERANK         = 9;\nconst FSLI4BX_READORDER         = 10;\nconst FSLI4BX_WRITEORDER        = 11;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Bits defined within the general flag byte.\n */\nconst FSLI4GF_WRITABLE          = 0x01;\nconst FSLI4GF_CUR_REQ           = 0x02;\nconst FSLI4GF_ABSENT            = 0x04;\nconst FSLI4GF_GOING             = 0x08;\nconst FSLI4GF_SPLIT             = 0x10;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Bits defined within the transport flag byte.\n */\nconst FSLI4TF_RDMA              = 0x01;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Defines a set of replicas sharing\n * a common value of the rootpath\n * with in the corresponding\n * single-server namespaces.\n */\nstruct  fs_locations_item4 {\n        fs_locations_server4    fli_entries<>;\n        pathname4               fli_rootpath;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Defines the overall structure of\n * the fs_locations_info attribute.\n */\nstruct  fs_locations_info4 {\n        uint32_t                fli_flags;\n        int32_t                 fli_valid_for;\n        pathname4               fli_fs_root;\n        fs_locations_item4      fli_items<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Flag bits in fli_flags.\n */\nconst FSLI4IF_VAR_SUB           = 0x00000001;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "typedef fs_locations_info4 fattr4_fs_locations_info;",
      "ja": "typedefのfs_locations_info4 fattr4_fs_locations_info。"
    },
    {
      "indent": 3,
      "text": "As noted above, the fs_locations_info attribute, when supported, may be requested of absent file systems without causing NFS4ERR_MOVED to be returned. It is generally expected that it will be available for both present and absent file systems even if only a single fs_locations_server4 entry is present, designating the current (present) file system, or two fs_locations_server4 entries designating the previous location of an absent file system (the one just referenced) and its successor location. Servers are strongly urged to support this attribute on all file systems if they support it on any file system.",
      "ja": "上述のように、サポートfs_locations_info属性は、NFS4ERR_MOVEDが返させることなく、存在しないファイル・システムに要求することができます。一般的に、現在の（現在の）ファイル・システム、または存在しないファイルシステムの以前の位置を指定する2つのfs_locations_server4エントリ（指定、唯一の単一fs_locations_server4エントリが存在しても存在と不在の両方のファイルシステムのために利用可能であることが期待されますただ参照1）およびその後継の場所。サーバーが強く、彼らは任意のファイルシステム上でそれをサポートしている場合、すべてのファイルシステム上でこの属性をサポートするよう促されています。"
    },
    {
      "indent": 3,
      "text": "The data presented in the fs_locations_info attribute may be obtained by the server in any number of ways, including specification by the administrator or by current protocols for transferring data among replicas and protocols not yet developed. NFSv4.1 only defines how this information is presented by the server to the client.",
      "ja": "fs_locations_info属性に提示されたデータは、管理者またはまだ開発されていない複製およびプロトコルの間でデータを転送するための現在のプロトコルによって仕様を含む方法、任意の数のサーバによって得ることができます。 NFSv4.1は、この情報がサーバからクライアントに提示される方法を定義します。"
    },
    {
      "indent": 0,
      "text": "11.10.1. The fs_locations_server4 Structure",
      "section_title": true,
      "ja": "11.10.1.  fs_locations_server4構造"
    },
    {
      "indent": 3,
      "text": "The fs_locations_server4 structure consists of the following items:",
      "ja": "fs_locations_server4構造は、以下の項目で構成されています。"
    },
    {
      "indent": 3,
      "text": "o An indication of how up-to-date the file system is (fls_currency) in seconds. This value is relative to the master copy. A negative value indicates that the server is unable to give any reasonably useful value here. A value of zero indicates that the file system is the actual writable data or a reliably coherent and fully up-to-date copy. Positive values indicate how out-of-date this copy can normally be before it is considered for update. Such a value is not a guarantee that such updates will always be performed on the required schedule but instead serves as a hint about how far the copy of the data would be expected to be behind the most up-to-date copy.",
      "ja": "最新のファイルシステムは秒単位（fls_currency）であるかの目安O。この値は、マスターコピーに相対的です。負の値は、サーバーがここに任意の合理的に有益な価値を与えることができないことを示しています。ゼロの値は、ファイルシステムは、実際の書き込み可能なデータまたは確実にコヒーレントと完全最新のコピーであることを示しています。正の値は、それが更新のために考慮される前に、このコピーを正常にすることができますどのように古く示しています。このような値は、このような更新は常に必要なスケジュールで行われますが代わりにデータのコピーが最新のコピーの後ろにあることが予想されるどのくらいのヒントとして機能されることを保証するものではありません。"
    },
    {
      "indent": 3,
      "text": "o A counted array of one-byte values (fls_info) containing information about the particular file system instance. This data includes general flags, transport capability flags, file system equivalence class information, and selection priority information. The encoding will be discussed below.",
      "ja": "O特定のファイル・システム・インスタンスに関する情報を含む1バイト値のカウント配列（fls_info）。このデータは、一般的なフラグ、輸送能力フラグ、ファイルシステムの等価クラス情報、及び選択優先度情報を含みます。符号化は、以下に説明します。"
    },
    {
      "indent": 3,
      "text": "o The server string (fls_server). For the case of the replica currently being accessed (via GETATTR), a zero-length string MAY be used to indicate the current address being used for the RPC call. The fls_server field can also be an IPv4 or IPv6 address, formatted the same way as an IPv4 or IPv6 address in the \"server\" field of the fs_location4 data type (see Section 11.9).",
      "ja": "Oサーバーストリング（fls_server）。現在（GETATTRを介して）アクセスされているレプリカの場合には、長さゼロの文字列は、RPC呼び出しのために使用されている現在のアドレスを示すために使用され得ます。 fls_serverフィールドはまた、IPv4またはIPv6アドレスを指定でき、fs_location4データタイプの「サーバー」フィールドでIPv4またはIPv6アドレスと同じようにフォーマットされた（セクション11.9を参照）。"
    },
    {
      "indent": 3,
      "text": "Data within the fls_info array is in the form of 8-bit data items with constants giving the offsets within the array of various values describing this particular file system instance. This style of definition was chosen, in preference to explicit XDR structure definitions for these values, for a number of reasons.",
      "ja": "fls_infoアレイ内のデータは、この特定のファイル・システム・インスタンスを記述する種々の値のアレイ内のオフセットを与える定数を有する8ビットのデータ項目の形式です。定義のこのスタイルは、いくつかの理由で、これらの値の明示的なXDR構造定義に優先して、選ばれました。"
    },
    {
      "indent": 3,
      "text": "o The kinds of data in the fls_info array, representing flags, file system classes, and priorities among sets of file systems representing the same data, are such that 8 bits provide a quite acceptable range of values. Even where there might be more than 256 such file system instances, having more than 256 distinct classes or priorities is unlikely.",
      "ja": "フラグは、ファイル・システム・クラスと同じデータを表すファイルシステムのセットの間で優先度を表すfls_infoアレイ内のデータの種類O、8ビット値のかなり許容範囲を提供するようなものです。場合でも256以上の異なるクラスまたは優先順位を持つことはほとんどありません、256以上のようなファイルシステムインスタンスがあるかもしれません。"
    },
    {
      "indent": 3,
      "text": "o Explicit definition of the various specific data items within XDR would limit expandability in that any extension within a subsequent minor version would require yet another attribute, leading to specification and implementation clumsiness.",
      "ja": "O XDR内の様々な特定のデータ項目の明示的な定義は、後続のマイナーバージョンの内のいずれかの拡張仕様と実装不器用につながる、さらに他の属性を必要とするであろうという点で拡張性を制限します。"
    },
    {
      "indent": 3,
      "text": "o Such explicit definitions would also make it impossible to propose Standards Track extensions apart from a full minor version.",
      "ja": "Oこのような明示的な定義も、それは不可能フルマイナーバージョンとは別に標準化過程の拡張を提案するになるだろう。"
    },
    {
      "indent": 3,
      "text": "This encoding scheme can be adapted to the specification of multi-byte numeric values, even though none are currently defined. If extensions are made via Standards Track RFCs, multi-byte quantities will be encoded as a range of bytes with a range of indices, with the byte interpreted in big-endian byte order. Further, any such index assignments are constrained so that the relevant quantities will not cross XDR word boundaries.",
      "ja": "この符号化方式はいずれも、現在定義されていないにも関わらず、マルチバイトの数値の仕様に適合させることができます。拡張機能が標準化過程のRFCを介して行われている場合、マルチバイト量は、ビッグエンディアンバイト順に解釈バイトと、インデックスの範囲のバイトの範囲としてエンコードされます。関連量はXDRワード境界を越えないように、さらに、任意のそのようなインデックス割り当てが制約されます。"
    },
    {
      "indent": 3,
      "text": "The set of fls_info data is subject to expansion in a future minor version, or in a Standards Track RFC, within the context of a single minor version. The server SHOULD NOT send and the client MUST NOT use indices within the fls_info array that are not defined in Standards Track RFCs.",
      "ja": "fls_infoデータのセットは、単一のマイナーバージョンの文脈の中で、将来のマイナーバージョンで、または標準化過程RFCでの展開の対象です。サーバは、送信すべきではなく、クライアントが標準化過程のRFCで定義されていないfls_info配列内のインデックスを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "The fls_info array contains:",
      "ja": "fls_info配列が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Two 8-bit flag fields, one devoted to general file-system characteristics and a second reserved for transport-related capabilities.",
      "ja": "O 2つの8ビットフラグフィールド、輸送関連の機能のために予約さ一般的なファイル・システムの特性と第二のに専念1。"
    },
    {
      "indent": 3,
      "text": "o Six 8-bit class values that define various file system equivalence classes as explained below.",
      "ja": "以下に説明するように、様々なファイルシステム同値類を定義O 6つの8ビット・クラス値。"
    },
    {
      "indent": 3,
      "text": "o Four 8-bit priority values that govern file system selection as explained below.",
      "ja": "以下に説明するように、ファイルシステムの選択を支配する4つの8ビットの優先値O。"
    },
    {
      "indent": 3,
      "text": "The general file system characteristics flag (at byte index FSLI4BX_GFLAGS) has the following bits defined within it:",
      "ja": "（バイトインデックスFSLI4BX_GFLAGSで）一般的なファイルシステムの特性フラグは、その中に定義された以下のビットを有します。"
    },
    {
      "indent": 3,
      "text": "o FSLI4GF_WRITABLE indicates that this file system target is writable, allowing it to be selected by clients that may need to write on this file system. When the current file system instance is writable and is defined as of the same simultaneous use class (as specified by the value at index FSLI4BX_CLSIMUL) to which the client was previously writing, then it must incorporate within its data any committed write made on the source file system instance. See Section 11.7.8, which discusses the write-verifier class. While there is no harm in not setting this flag for a file system that turns out to be writable, turning the flag on for a read-only file system can cause problems for clients that select a migration or replication target based on the flag and then find themselves unable to write.",
      "ja": "O FSLI4GF_WRITABLEは、このファイルシステムに書き込む必要があり、クライアントが選択することができるように、このファイルシステムの対象が書き込み可能であることを示しています。現在のファイルシステムインスタンスが書き込み可能で、クライアントが以前に書いていたために（インデックスFSLI4BX_CLSIMULの値で指定）と同じ同時使用クラスのように定義されている場合、それはそのデータの中にソース上で行われたすべてのコミットの書き込みを組み込む必要がありますファイル・システム・インスタンス。書き込みベリファイアのクラスについて説明し、セクション11.7.8を参照してください。害が書き込み可能であることが判明したファイルシステムのために、このフラグを設定しないではありませんが、読み取り専用ファイルシステムのためにフラグをオンにすると、フラグに基づいて、移行または複製先を選択し、クライアントのために問題を引き起こす可能性があり、その後、書くこと自体ができない見つけます。"
    },
    {
      "indent": 3,
      "text": "o FSLI4GF_CUR_REQ indicates that this replica is the one on which the request is being made. Only a single server entry may have this flag set and, in the case of a referral, no entry will have it.",
      "ja": "O FSLI4GF_CUR_REQこのレプリカ要求がなされているれているものであることを示しています。唯一の単一サーバ・エントリには、このフラグが設定されていることと、照会の場合には、エントリがそれを持っていません。"
    },
    {
      "indent": 3,
      "text": "o FSLI4GF_ABSENT indicates that this entry corresponds to an absent file system replica. It can only be set if FSLI4GF_CUR_REQ is set. When both such bits are set, it indicates that a file system instance is not usable but that the information in the entry can be used to determine the sorts of continuity available when switching from this replica to other possible replicas. Since this bit can only be true if FSLI4GF_CUR_REQ is true, the value could be determined using the fs_status attribute, but the information is also made available here for the convenience of the client. An entry with this bit, since it represents a true file system (albeit absent), does not appear in the event of a referral, but only when a file system has been accessed at this location and has subsequently been migrated.",
      "ja": "O FSLI4GF_ABSENTこのエントリが存在しないファイル・システム・レプリカに対応することを示しています。 FSLI4GF_CUR_REQが設定されている場合にのみ設定することができます。このようなビットの両方が設定されている場合、それはファイル・システム・インスタンスが使用可能ではなく、エントリ内の情報が他の可能なレプリカに、このレプリカから切り替えるとき利用できる連続の種類を決定するために用いることができることをことを示しています。 FSLI4GF_CUR_REQがtrueの場合、このビットは、唯一の真のすることができますので、値がfs_status属性を使用して決定することができますが、情報は、クライアントの便宜のために、ここで使用できるようになります。それは実際のファイルシステムを（存在しないとはいえ）を表すので、このビットのエントリは、が、ファイルシステムは、この場所でアクセスされ、続いて移行された場合にのみ、照会の場合には表示されません。"
    },
    {
      "indent": 3,
      "text": "o FSLI4GF_GOING indicates that a replica, while still available, should not be used further. The client, if using it, should make an orderly transfer to another file system instance as expeditiously as possible. It is expected that file systems going out of service will be announced as FSLI4GF_GOING some time before the actual loss of service. It is also expected that the fli_valid_for value will be sufficiently small to allow clients to detect and act on scheduled events, while large enough that the cost of the requests to fetch the fs_locations_info values will not be excessive. Values on the order of ten minutes seem reasonable.",
      "ja": "O FSLI4GF_GOINGレプリカは、まだ利用しながら、さらに使用すべきではないことを示しています。クライアントは、それを使用する場合は、可能な限り迅速、別のファイル・システム・インスタンスへの秩序ある移行を行う必要があります。サービスの出入りのファイルシステムは、サービスの実際の損失前にいくつかの時間をFSLI4GF_GOINGとして発表されることが期待されます。またfli_valid_for値がfs_locations_info値をフェッチする要求のコストが過大にならないだろう十分に大きいことながら、クライアントは、スケジュールされたイベントに検出して行動できるようにするために十分に小さいことが期待されます。 10分程度の値が妥当なようです。"
    },
    {
      "indent": 6,
      "text": "When this flag is seen as part of a transition into a new file system, a client might choose to transfer immediately to another replica, or it may reference the current file system and only transition when a migration event occurs. Similarly, when this flag appears as a replica in the referral, clients would likely avoid being referred to this instance whenever there is another choice.",
      "ja": "このフラグは、新しいファイル・システムへの移行の一部として見られている場合、クライアントは、別のレプリカに直ちに転送することを選択するかもしれない、または移行イベントが発生した場合には、現在のファイルシステムのみ遷移を参照することができます。このフラグは、紹介でレプリカとして現れる場合も同様に、クライアントはおそらく、別の選択肢があるたびに、このインスタンスと呼ばれることを避けるでしょう。"
    },
    {
      "indent": 3,
      "text": "o FSLI4GF_SPLIT indicates that when a transition occurs from the current file system instance to this one, the replacement may consist of multiple file systems. In this case, the client has to be prepared for the possibility that objects on the same file system before migration will be on different ones after. Note that FSLI4GF_SPLIT is not incompatible with the file systems belonging to the same fileid class since, if one has a set of fileids that are unique within a file system, each subset assigned to a smaller file system after migration would not have any conflicts internal to that file system.",
      "ja": "O FSLI4GF_SPLIT遷移はこの1つに、現在のファイル・システム・インスタンスから発生した場合、交換が複数のファイルシステムから構成されてもよいことを示しています。この場合、クライアントは、移行が後に異なるものになります前に、同じファイルシステム上のオブジェクト可能性のために準備する必要があります。一つは、ファイルシステム内で一意であるfileidsのセットを持っている場合、移行後小さいファイルシステムに割り当てられた各サブセットは内部競合を持たない、ためFSLI4GF_SPLITは同じFILEIDクラスに属しているファイルシステムと互換性がないことに注意してくださいそのファイルシステム。"
    },
    {
      "indent": 6,
      "text": "A client, in the case of a split file system, will interrogate existing files with which it has continuing connection (it is free to simply forget cached filehandles). If the client remembers the directory filehandle associated with each open file, it may proceed upward using LOOKUPP to find the new file system boundaries. Note that in the event of a referral, there will not be any such files and so these actions will not be performed. Instead, a reference to a portion of the original file system now split off into other file systems will encounter an fsid change and possibly a further referral.",
      "ja": "クライアントは、分割されたファイルシステムの場合には、それは接続を継続していると、既存のファイルを問い合わせます（単に、キャッシュされたファイルハンドルを忘れて自由です）。クライアントが開いている各ファイルに関連付けられたディレクトリのファイルハンドルを覚えている場合は、新しいファイルシステムの境界を見つけるために、LOOKUPPを使用して上向きに進むことができます。紹介のイベントで、そこにどのようなファイルではありませんので、これらのアクションが実行されないことに注意してください。代わりに、元のファイルシステムの部分への参照は、現在FSID変化およびおそらくさらに照会に遭遇する他のファイルシステムに離脱します。"
    },
    {
      "indent": 6,
      "text": "Once the client recognizes that one file system has been split into two, it can prevent the disruption of running applications by presenting the two file systems as a single one until a convenient point to recognize the transition, such as a restart. This would require a mapping from the server's fsids to fsids as seen by the client, but this is already necessary for other reasons. As noted above, existing fileids within the two descendant file systems will not conflict. Providing non-conflicting fileids for newly created files on the split file systems is the responsibility of the server (or servers working in concert). The server can encode filehandles such that filehandles generated before the split event can be discerned from those generated after the split, allowing the server to determine when the need for emulating two file systems as one is over.",
      "ja": "クライアントを1つのファイルシステムを2つに分割されていることを認識すると、そのような再起動など、移行を認識するために便利なポイントまで、単一のものとして、2つのファイルシステムを提示することによって、実行中のアプリケーションの破壊を防ぐことができます。これは、クライアントから見たfsidsに、サーバーのfsidsからのマッピングが必要となるが、これは他の理由のために既に必要です。上で述べたように、2つの子孫ファイルシステム内の既存のfileidsは競合しません。分割されたファイル・システム上で新たに作成されたファイルのための競合しないfileidsを提供することは、サーバー（やコンサートでの作業のサーバー）の責任です。サーバは、一つとして、2つのファイルシステムをエミュレートする必要が終わったときに、サーバが判断できるように、分割イベントの前に生成されたファイルハンドルは、分割後に生成されるものから識別することができるようにファイルハンドルをコードすることができます。"
    },
    {
      "indent": 6,
      "text": "Although it is possible for this flag to be present in the event of referral, it would generally be of little interest to the client, since the client is not expected to have information regarding the current contents of the absent file system.",
      "ja": "このフラグは、紹介の際に存在することは可能ですが、クライアントが不在で、ファイルシステムの現在の内容に関する情報を持つことが期待されていないため、それは一般的に、クライアントにはほとんど興味があるでしょう。"
    },
    {
      "indent": 3,
      "text": "The transport-flag field (at byte index FSLI4BX_TFLAGS) contains the following bits related to the transport capabilities of the specific file system.",
      "ja": "（バイトインデックスFSLI4BX_TFLAGSで）トランスポート・フラグ・フィールドは、特定のファイルシステムの輸送能力に関連する次のビットを含みます。"
    },
    {
      "indent": 3,
      "text": "o FSLI4TF_RDMA indicates that this file system provides NFSv4.1 file system access using an RDMA-capable transport.",
      "ja": "O FSLI4TF_RDMAは、このファイルシステムは、RDMA対応のトランスポートを使用してNFSv4.1ファイルシステムへのアクセスを提供することを示しています。"
    },
    {
      "indent": 3,
      "text": "Attribute continuity and file system identity information are expressed by defining equivalence relations on the sets of file systems presented to the client. Each such relation is expressed as a set of file system equivalence classes. For each relation, a file system has an 8-bit class number. Two file systems belong to the same class if both have identical non-zero class numbers. Zero is treated as non-matching. Most often, the relevant question for the client will be whether a given replica is identical to / continuous with the current one in a given respect, but the information should be available also as to whether two other replicas match in that respect as well.",
      "ja": "継続性とファイルシステムの識別情報をクライアントに提示したファイルシステムのセット上の同値関係を定義することによって表現されている属性。各そのような関係は、ファイルシステムの等価クラスの集合として表現されます。各関係のために、ファイルシステムは、8ビットのクラス番号を有しています。両者が同一の非ゼロクラス番号を持っている場合、2つのファイルシステムは、同じクラスに属しています。ゼロは、非マッチングとして扱われます。ほとんどの場合、クライアントに関連する問題は、与えられたレプリカが与えられた点で、現在の1で/連続と同じですが、情報が同様にその点でか2個の他のレプリカが一致するようにも利用可能であるべきかどうかになります。"
    },
    {
      "indent": 3,
      "text": "The following fields specify the file system's class numbers for the equivalence relations used in determining the nature of file system transitions. See Section 11.7 and its various subsections for details about how this information is to be used. Servers may assign these values as they wish, so long as file system instances that share the same value have the specified relationship to one another; conversely, file systems that have the specified relationship to one another share a common class value. As each instance entry is added, the relationships of this instance to previously entered instances can be consulted, and if one is found that bears the specified relationship, that entry's class value can be copied to the new entry. When no such previous entry exists, a new value for that byte index (not previously used) can be selected, most likely by incrementing the value of the last class value assigned for that index.",
      "ja": "次のフィールドは、ファイルシステムの移行の性質を決定する際に使用同値関係のファイル・システムのクラス番号を指定します。セクション11.7と、この情報を使用する方法の詳細については、その様々なサブセクションを参照してください。彼らは同じ価値を共有し、相互に指定された関係を持っているファイル・システム・インスタンスとして限り、望むようにサーバは、これらの値を割り当てることができ、逆に、互いに共通のクラス値に指定された関係を持っているファイルシステム。各インスタンスのエントリが追加されると、以前に入力されたインスタンスに、このインスタンスの関係を相談することができ、1つは、指定された関係を有することを発見された場合、そのエントリのクラス値は、新しいエントリにコピーすることができます。そのような以前のエントリが存在しない場合は、そのバイトインデックス（以前に使用されていない）のための新しい値は、そのインデックスに割り当てられた最後のクラス値の値をインクリメントすることによって、最も可能性の高い、選択することができます。"
    },
    {
      "indent": 3,
      "text": "o The field with byte index FSLI4BX_CLSIMUL defines the simultaneous-use class for the file system.",
      "ja": "OバイトインデックスFSLI4BX_CLSIMULを持つフィールドは、ファイルシステムの同時使用のクラスを定義します。"
    },
    {
      "indent": 3,
      "text": "o The field with byte index FSLI4BX_CLHANDLE defines the handle class for the file system.",
      "ja": "OバイトインデックスFSLI4BX_CLHANDLEを持つフィールドは、ファイル・システムのためにハンドルクラスを定義します。"
    },
    {
      "indent": 3,
      "text": "o The field with byte index FSLI4BX_CLFILEID defines the fileid class for the file system.",
      "ja": "OバイトインデックスFSLI4BX_CLFILEIDを持つフィールドは、ファイルシステムのFILEIDクラスを定義します。"
    },
    {
      "indent": 3,
      "text": "o The field with byte index FSLI4BX_CLWRITEVER defines the write-verifier class for the file system.",
      "ja": "OバイトインデックスFSLI4BX_CLWRITEVERを持つフィールドは、ファイルシステムの書き込みベリファイアのクラスを定義します。"
    },
    {
      "indent": 3,
      "text": "o The field with byte index FSLI4BX_CLCHANGE defines the change class for the file system.",
      "ja": "OバイトインデックスFSLI4BX_CLCHANGEを持つフィールドは、ファイルシステムの変更クラスを定義します。"
    },
    {
      "indent": 3,
      "text": "o The field with byte index FSLI4BX_CLREADDIR defines the readdir class for the file system.",
      "ja": "OバイトインデックスFSLI4BX_CLREADDIRを持つフィールドは、ファイル・システムのためのreaddirクラスを定義します。"
    },
    {
      "indent": 3,
      "text": "Server-specified preference information is also provided via 8-bit values within the fls_info array. The values provide a rank and an order (see below) to be used with separate values specifiable for the cases of read-only and writable file systems. These values are compared for different file systems to establish the server-specified preference, with lower values indicating \"more preferred\".",
      "ja": "サーバが指定した嗜好情報もfls_infoアレイ内の8ビット値を介して提供されます。値は、ランクと、読み取り専用および書き込み可能なファイルシステムの場合の指定できる別の値で使用するため（以下を参照）を提供します。これらの値は、「より好ましい」を示す低い値で、サーバー指定のプリファレンスを確立するために、異なるファイルシステムのために比較されます。"
    },
    {
      "indent": 3,
      "text": "Rank is used to express a strict server-imposed ordering on clients, with lower values indicating \"more preferred\". Clients should attempt to use all replicas with a given rank before they use one with a higher rank. Only if all of those file systems are unavailable should the client proceed to those of a higher rank. Because specifying a rank will override client preferences, servers should be conservative about using this mechanism, particularly when the environment is one in which client communication characteristics are neither tightly controlled nor visible to the server.",
      "ja": "ランクは低い値が「より好ましい」を示すと、クライアント上の厳密サーバ課し順序を発現するために使用されます。クライアントは、高いランクのいずれかを使用する前に与えられたランクのすべてのレプリカを使用することを試みるべきです。それらのファイルシステムのすべてが利用できない場合にのみ、クライアントは、より高いランクのものに進む必要があります。ランクを指定すると、クライアント設定を上書きしますので、サーバーは、環境は、クライアントの通信特性がどちらも厳密に制御されなかったり、サーバーに見えているものである場合は特に、このメカニズムを使用する方法について慎重でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Within a rank, the order value is used to specify the server's preference to guide the client's selection when the client's own preferences are not controlling, with lower values of order indicating \"more preferred\". If replicas are approximately equal in all respects, clients should defer to the order specified by the server. When clients look at server latency as part of their selection, they are free to use this criterion but it is suggested that when latency differences are not significant, the server-specified order should guide selection.",
      "ja": "ランク内の、順序の値は、クライアントの好みが制御されていない場合に「より好ましい」を示すための低い値と、クライアントの選択を導くためにサーバの好みを指定するために使用されます。レプリカはすべての点でほぼ等しい場合、クライアントはサーバによって指定された順序に延期する必要があります。クライアントは自分の選択の一部として、サーバの待ち時間を見てみると、彼らはこの基準を使用するのは自由ですが、待ち時間の差は有意でない場合には、サーバーが指定した順序で選択を導く必要があることを示唆しています。"
    },
    {
      "indent": 3,
      "text": "o The field at byte index FSLI4BX_READRANK gives the rank value to be used for read-only access.",
      "ja": "OバイトインデックスFSLI4BX_READRANKでのフィールドは、読み取り専用アクセスに使用するランク値を与えます。"
    },
    {
      "indent": 3,
      "text": "o The field at byte index FSLI4BX_READORDER gives the order value to be used for read-only access.",
      "ja": "OバイトインデックスFSLI4BX_READORDERでのフィールドは、読み取り専用アクセスに使用するための値を与えます。"
    },
    {
      "indent": 3,
      "text": "o The field at byte index FSLI4BX_WRITERANK gives the rank value to be used for writable access.",
      "ja": "OバイトインデックスFSLI4BX_WRITERANKでのフィールドは、書き込み可能なアクセスのために使用されるランク値を与えます。"
    },
    {
      "indent": 3,
      "text": "o The field at byte index FSLI4BX_WRITEORDER gives the order value to be used for writable access.",
      "ja": "OバイトインデックスFSLI4BX_WRITEORDERでのフィールドは、書き込み可能なアクセスに使用するための値を与えます。"
    },
    {
      "indent": 3,
      "text": "Depending on the potential need for write access by a given client, one of the pairs of rank and order values is used. The read rank and order should only be used if the client knows that only reading will ever be done or if it is prepared to switch to a different replica in the event that any write access capability is required in the future.",
      "ja": "与えられたクライアントによる書き込みアクセスのための潜在的な必要性に応じて、ランクと順位値のペアの一つが使用されています。読み取りランクと順序は、クライアントだけが唯一の読書がこれまでに行われることを知っている場合に使用したりする必要があり、それは任意の書き込みアクセス機能は、将来的に必要とされる場合に、別のレプリカに切り替えるために用意されている場合。"
    },
    {
      "indent": 0,
      "text": "11.10.2. The fs_locations_info4 Structure",
      "section_title": true,
      "ja": "11.10.2.  fs_locations_info4構造"
    },
    {
      "indent": 3,
      "text": "The fs_locations_info4 structure, encoding the fs_locations_info attribute, contains the following:",
      "ja": "fs_locations_info4構造は、fs_locations_info属性をコードする、以下が含まれています。"
    },
    {
      "indent": 3,
      "text": "o The fli_flags field, which contains general flags that affect the interpretation of this fs_locations_info4 structure and all fs_locations_item4 structures within it. The only flag currently defined is FSLI4IF_VAR_SUB. All bits in the fli_flags field that are not defined should always be returned as zero.",
      "ja": "このfs_locations_info4構造の解釈とその中のすべてのfs_locations_item4構造に影響を与える一般的なフラグを含んfli_flagsフィールド、O。現在定義されている唯一のフラグがFSLI4IF_VAR_SUBです。定義されていないfli_flagsフィールド内のすべてのビットは常に0として返されるべきです。"
    },
    {
      "indent": 3,
      "text": "o The fli_fs_root field, which contains the pathname of the root of the current file system on the current server, just as it does in the fs_locations4 structure.",
      "ja": "それはfs_locations4構造でないのと同様に、現在のサーバー上の現在のファイルシステムのルートのパス名が含まれているfli_fs_rootフィールド、O。"
    },
    {
      "indent": 3,
      "text": "o An array called fli_items of fs_locations4_item structures, which contain information about replicas of the current file system. Where the current file system is actually present, or has been present, i.e., this is not a referral situation, one of the fs_locations_item4 structures will contain an fs_locations_server4 for the current server. This structure will have FSLI4GF_ABSENT set if the current file system is absent, i.e., normal access to it will return NFS4ERR_MOVED.",
      "ja": "O配列は、現在のファイルシステムの複製に関する情報が含まれているfs_locations4_item構造のfli_itemsと呼ばれます。現在のファイルシステムが実際に存在する、または存在している、すなわち、これは紹介の状況ではない場合は、fs_locations_item4構造の一つは、現在のサーバのfs_locations_server4が含まれます。この構造はFSLI4GF_ABSENTは、現在のファイルシステムが存在しない場合、すなわち、それへの通常のアクセスがNFS4ERR_MOVEDを返します。設定されています。"
    },
    {
      "indent": 3,
      "text": "o The fli_valid_for field specifies a time in seconds for which it is reasonable for a client to use the fs_locations_info attribute without refetch. The fli_valid_for value does not provide a guarantee of validity since servers can unexpectedly go out of service or become inaccessible for any number of reasons. Clients are well-advised to refetch this information for an actively accessed file system at every fli_valid_for seconds. This is particularly important when file system replicas may go out of service in a controlled way using the FSLI4GF_GOING flag to communicate an ongoing change. The server should set fli_valid_for to a value that allows well-behaved clients to notice the FSLI4GF_GOING flag and make an orderly switch before the loss of service becomes effective. If this value is zero, then no refetch interval is appropriate and the client need not refetch this data on any particular schedule. In the event of a transition to a new file system instance, a new value of the fs_locations_info attribute will be fetched at the destination. It is to be expected that this may have a different fli_valid_for value, which the client should then use in the same fashion as the previous value.",
      "ja": "O fli_valid_forフィールドは、クライアントが再フェッチなしfs_locations_info属性を使用することが合理的であるために時間を秒単位で指定します。サーバーが予期せずサービスの外出や任意の数の理由のためにアクセスできなくなることができるのでfli_valid_for値は妥当性の保証を提供していません。クライアントは、すべてのfli_valid_for秒で積極的にアクセスし、ファイルシステムのためにこの情報を再フェッチするために、よくお勧めします。ファイルシステムの複製が進行中の変化を伝えるためにFSLI4GF_GOINGフラグを使用して制御された方法でサービスの外に出ることがありとき、これは特に重要です。サーバーは、行儀のクライアントがFSLI4GF_GOINGフラグに気づくとサービスの損失が有効になる前に、整然とした切り替えを行うことができます値にfli_valid_for設定する必要があります。この値がゼロの場合は、何の再フェッチ間隔が適切でないと、クライアントは、特定のスケジュールで、このデータを再フェッチする必要はありません。新しいファイル・システム・インスタンスへの移行の際に、fs_locations_info属性の新しい値は、先にフェッチされます。これは、クライアントは、以前の値と同じ方法で使用する必要があります異なるfli_valid_for値を有していてもよいことが予想されます。"
    },
    {
      "indent": 3,
      "text": "The FSLI4IF_VAR_SUB flag within fli_flags controls whether variable substitution is to be enabled. See Section 11.10.3 for an explanation of variable substitution.",
      "ja": "FSLI4IF_VAR_SUBフラグは、内の変数置換を有効にするかどうかを制御しfli_flags。変数の置換の説明については、セクション11.10.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "11.10.3. The fs_locations_item4 Structure",
      "section_title": true,
      "ja": "11.10.3.  fs_locations_item4構造"
    },
    {
      "indent": 3,
      "text": "The fs_locations_item4 structure contains a pathname (in the field fli_rootpath) that encodes the path of the target file system replicas on the set of servers designated by the included fs_locations_server4 entries. The precise manner in which this target location is specified depends on the value of the FSLI4IF_VAR_SUB flag within the associated fs_locations_info4 structure.",
      "ja": "fs_locations_item4構造が含まfs_locations_server4エントリによって指定されたサーバのセットにターゲット・ファイル・システムの複製の経路をコードする（フィールドfli_rootpathで）パス名を含んでいます。この目標位置が指定される正確な方法は、関連fs_locations_info4構造内FSLI4IF_VAR_SUBフラグの値に依存します。"
    },
    {
      "indent": 3,
      "text": "If this flag is not set, then fli_rootpath simply designates the location of the target file system within each server's single-server namespace just as it does for the rootpath within the fs_location4 structure. When this bit is set, however, component entries of a certain form are subject to client-specific variable substitution so as to allow a degree of namespace non-uniformity in order to accommodate the selection of client-specific file system targets to adapt to different client architectures or other characteristics.",
      "ja": "このフラグが設定されていない場合は、単にそれがfs_location4構造内ROOTPATHの場合と同じように、各サーバーの単一サーバーの名前空間内のターゲット・ファイル・システムの場所を指定fli_rootpath。このビットが設定されている場合、しかし、特定の形態の構成エントリがクライアント固有の変数置換の対象となっている別に適応するために、クライアント固有のファイル・システム・ターゲットの選択を収容するために、名前空間の不均一性の程度を可能にするようにクライアントアーキテクチャまたはその他の特性。"
    },
    {
      "indent": 3,
      "text": "When such substitution is in effect, a variable beginning with the string \"${\" and ending with the string \"}\" and containing a colon is to be replaced by the client-specific value associated with that variable. The string \"unknown\" should be used by the client when it has no value for such a variable. The pathname resulting from such substitutions is used to designate the target file system, so that different clients may have different file systems, corresponding to that location in the multi-server namespace.",
      "ja": "そのような置換が有効である場合、可変文字列から始まる「$ {」との文字列で終わる「}」および結腸を含むが、その変数に関連付けられたクライアント固有の値によって置き換えられます。それは、このような変数の値がない場合、「不明」文字列は、クライアントが使用する必要があります。異なるクライアントは異なるファイルシステムを有することができるように、このような置換に起因するパス名は、マルチサーバの名前空間内のその位置に対応する、ターゲット・ファイル・システムを指定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "As mentioned above, such substituted pathname variables contain a colon. The part before the colon is to be a DNS domain name, and the part after is to be a case-insensitive alphanumeric string.",
      "ja": "上述したように、そのような置換されたパス名の変数はコロンを含みます。コロンの前の部分がDNSドメイン名であることであり、一部は後に、大文字と小文字を区別しない英数字の文字列になることです。"
    },
    {
      "indent": 3,
      "text": "Where the domain is \"ietf.org\", only variable names defined in this document or subsequent Standards Track RFCs are subject to such substitution. Organizations are free to use their domain names to create their own sets of client-specific variables, to be subject to such substitution. In cases where such variables are intended to be used more broadly than a single organization, publication of an Informational RFC defining such variables is RECOMMENDED.",
      "ja": "ドメインは「ietf.org」である場合には、この文書またはその後の標準化過程のRFCで定義された唯一の変数名は、そのような置換の対象となります。組織は、そのような置換の対象となるために、クライアント固有の変数の独自のセットを作成するために自分のドメイン名を自由に使用できます。そのような変数は、単一の組織よりも広く使用されることが意図される場合には、そのような変数を定義する情報RFCの出版物が推奨されます。"
    },
    {
      "indent": 3,
      "text": "The variable ${ietf.org:CPU_ARCH} is used to denote that the CPU architecture object files are compiled. This specification does not limit the acceptable values (except that they must be valid UTF-8 strings), but such values as \"x86\", \"x86_64\", and \"sparc\" would be expected to be used in line with industry practice.",
      "ja": "変数$ {ietf.org:CPU_ARCHは} CPUアーキテクチャオブジェクトファイルがコンパイルされていることを示すために使用されます。この仕様は、（彼らは有効なUTF-8文字列でなければならないことを除いて）許容値を制限するものではありませんが、「x86の」、「x86_64版」、および「SPARC」などの値は、業界の慣行に沿って使用されることが期待されるだろう。"
    },
    {
      "indent": 3,
      "text": "The variable ${ietf.org:OS_TYPE} is used to denote the operating system, and thus the kernel and library APIs, for which code might be compiled. This specification does not limit the acceptable values (except that they must be valid UTF-8 strings), but such values as \"linux\" and \"freebsd\" would be expected to be used in line with industry practice.",
      "ja": "変数$ {ietf.org:OS_TYPEは}従って、コードがコンパイルされるかもしれないため、カーネルお​​よびライブラリAPIは、オペレーティング・システムを示すために使用され、。この仕様は、（彼らは有効なUTF-8文字列でなければならないことを除いて）許容値を制限するものではありませんが、「Linuxの」と「FreeBSDの」などの値は、業界の慣行に沿って使用されることが期待されるだろう。"
    },
    {
      "indent": 3,
      "text": "The variable ${ietf.org:OS_VERSION} is used to denote the operating system version, and thus the specific details of versioned interfaces, for which code might be compiled. This specification does not limit the acceptable values (except that they must be valid UTF-8 strings). However, combinations of numbers and letters with interspersed dots would be expected to be used in line with industry practice, with the details of the version format depending on the specific value of the variable ${ietf.org:OS_TYPE} with which it is used.",
      "ja": "変数$ {ietf.org:OS_VERSION}は、オペレーティングシステムのバージョンを示すために使用され、従ってコードがコンパイルされる可能性があるためバージョンインターフェースの具体的な詳細されています。 （彼らは有効なUTF-8文字列でなければならないことを除いて）この仕様は許容値を制限するものではありません。しかしながら、散在したドットと数字と文字の組合せはそれが使用されると、変数$ {ietf.org:OS_TYPE}の特定の値に応じてバージョンの形式の詳細は、業界の慣行に沿って使用されることが期待されるであろう。"
    },
    {
      "indent": 3,
      "text": "Use of these variables could result in the direction of different clients to different file systems on the same server, as appropriate to particular clients. In cases in which the target file systems are located on different servers, a single server could serve as a referral point so that each valid combination of variable values would designate a referral hosted on a single server, with the targets of those referrals on a number of different servers.",
      "ja": "これらの変数を使用すると、特定のクライアントに対して、必要に応じて、同じサーバ上の異なるファイルシステムに異なるクライアントの方向につながる可能性があります。変数の値のそれぞれの有効な組み合わせは、単一のサーバ上でホストされている照会を指定なるように、ターゲット・ファイル・システムが異なるサーバーに配置されている例では、単一のサーバは数にそれらの紹介のターゲットを、紹介ポイントとして役立ち得ます異なるサーバーの。"
    },
    {
      "indent": 3,
      "text": "Because namespace administration is affected by the values selected to substitute for various variables, clients should provide convenient means of determining what variable substitutions a client will implement, as well as, where appropriate, providing means to control the substitutions to be used. The exact means by which this will be done is outside the scope of this specification.",
      "ja": "名前空間の管理は、様々な変数の代わりに選択した値に影響されるので、クライアントは、クライアントが実装、など、適切な場合には、使用する置換を制御するための手段を提供しますどのような変数の置換を決定する便利な手段を提供しなければなりません。これを行うされる正確な手段は、本明細書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Although variable substitution is most suitable for use in the context of referrals, it may be used in the context of replication and migration. If it is used in these contexts, the server must ensure that no matter what values the client presents for the substituted variables, the result is always a valid successor file system instance to that from which a transition is occurring, i.e., that the data is identical or represents a later image of a writable file system.",
      "ja": "変数置換が紹介の文脈での使用に最も適しているが、それは複製や移動の状況において使用することができます。それはこれらのコンテキストで使用されている場合は、サーバがデータであること、すなわち、クライアントをどの値に関係なく、置換変数のために提示し、結果は常に遷移が発生しているから、それに有効な後継ファイルシステムのインスタンスであることを確認する必要があります同一または書き込み可能なファイルシステムの後画像を表します。"
    },
    {
      "indent": 3,
      "text": "Note that when fli_rootpath is a null pathname (that is, one with zero components), the file system designated is at the root of the specified server, whether or not the FSLI4IF_VAR_SUB flag within the associated fs_locations_info4 structure is set.",
      "ja": "fli_rootpathがnullパス名（つまり、ゼロ成分を有するものである）である場合、指定されたファイルシステムは、関連fs_locations_info4構造内FSLI4IF_VAR_SUBフラグがセットされているか否かを、指定されたサーバのルートであることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "11.11. The Attribute fs_status",
      "section_title": true,
      "ja": "11.11. 属性fs_status"
    },
    {
      "indent": 3,
      "text": "In an environment in which multiple copies of the same basic set of data are available, information regarding the particular source of such data and the relationships among different copies can be very helpful in providing consistent data to applications.",
      "ja": "データの同じ基本セットの複数のコピーが利用可能である環境では、そのようなデータと異なるコピー間の関係の特定のソースについての情報は、アプリケーションに一貫性のあるデータを提供するのに非常に有用であることができます。"
    },
    {
      "indent": 3,
      "text": "enum fs4_status_type { STATUS4_FIXED = 1, STATUS4_UPDATED = 2, STATUS4_VERSIONED = 3, STATUS4_WRITABLE = 4, STATUS4_REFERRAL = 5 };",
      "ja": "列挙fs4_status_type {STATUS4_FIXED = 1、STATUS4_UPDATED = 2、STATUS4_VERSIONED = 3、STATUS4_WRITABLE = 4、STATUS4_REFERRAL = 5}。"
    },
    {
      "indent": 3,
      "text": "struct fs4_status {\n        bool            fss_absent;\n        fs4_status_type fss_type;\n        utf8str_cs      fss_source;\n        utf8str_cs      fss_current;\n        int32_t         fss_age;\n        nfstime4        fss_version;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The boolean fss_absent indicates whether the file system is currently absent. This value will be set if the file system was previously present and becomes absent, or if the file system has never been present and the type is STATUS4_REFERRAL. When this boolean is set and the type is not STATUS4_REFERRAL, the remaining information in the fs4_status reflects that last valid when the file system was present.",
      "ja": "ブールfss_absentは、ファイルシステムが現在存在しないかどうかを示します。ファイルシステムが以前に存在し、不在になった場合、この値が設定される、またはファイルシステムが存在ではなかったとタイプがSTATUS4_REFERRALある場合。このブール値を設定し、タイプがSTATUS4_REFERRALではありませんされている場合、ファイルシステムが存在したとき、fs4_statusの残りの情報は、その最後の有効を反映しています。"
    },
    {
      "indent": 3,
      "text": "The fss_type field indicates the kind of file system image represented. This is of particular importance when using the version values to determine appropriate succession of file system images. When fss_absent is set, and the file system was previously present, the value of fss_type reflected is that when the file was last present. Five values are distinguished:",
      "ja": "fss_typeフィールドが表され、ファイル・システム・イメージの種類を示します。ファイル・システム・イメージの適切な連続を決定するために、バージョン値を使用する場合、これは特に重要です。 fss_absentが設定され、ファイルシステムが以前に存在した、fss_typeの値が反映されている場合、ファイルが最後に存在したときです。 5つの値は区別されます。"
    },
    {
      "indent": 3,
      "text": "o STATUS4_FIXED, which indicates a read-only image in the sense that it will never change. The possibility is allowed that, as a result of migration or switch to a different image, changed data can be accessed, but within the confines of this instance, no change is allowed. The client can use this fact to cache aggressively.",
      "ja": "それは決して変わらないという意味で、読み取り専用のイメージを示しSTATUS4_FIXED、O。可能性は別の画像への移行、またはスイッチの結果として、データにアクセスすることができる変更、ことを許可されているが、この例の範囲内で、変化が許容されません。クライアントは、積極的にキャッシュするために、この事実を使用することができます。"
    },
    {
      "indent": 3,
      "text": "o STATUS4_VERSIONED, which indicates that the image, like the STATUS4_UPDATED case, is updated externally, but it provides a guarantee that the server will carefully update an associated version value so that the client can protect itself from a situation in which it reads data from one version of the file system and then later reads data from an earlier version of the same file system. See below for a discussion of how this can be done.",
      "ja": "画像は、STATUS4_UPDATEDの場合と同様に、外部から更新されますが、それは、クライアントが1からデータを読み出すには状況から自分自身を守ることができるように、サーバーは慎重に関連したバージョン値を更新するという保証を提供していることを示しO STATUS4_VERSIONED、次に、ファイルシステムのバージョンとは、後に同じファイルシステムの以前のバージョンからデータを読み出します。これを行う方法の議論については、以下を参照してください。"
    },
    {
      "indent": 3,
      "text": "o STATUS4_UPDATED, which indicates an image that cannot be updated by the user writing to it but that may be changed externally, typically because it is a periodically updated copy of another writable file system somewhere else. In this case, version information is not provided, and the client does not have the responsibility of making sure that this version only advances upon a file system instance transition. In this case, it is the responsibility of the server to make sure that the data presented after a file system instance transition is a proper successor image and includes all changes seen by the client and any change made before all such changes.",
      "ja": "そこにユーザーの書き込みによって更新することはできませんが、それはどこか別の書き込み可能なファイルシステムの定期的に更新されたコピーで、通常そのためには、外部から変更することができる画像を示しSTATUS4_UPDATED、O。この場合、バージョン情報が提供されていない、そしてクライアントは、このバージョンでは、専用のファイルシステムインスタンスの移行時に進んでいることを確認することの責任を持ちません。ファイル・システム・インスタンスの移行が適切な後継イメージであり、クライアントから見たすべての変更及びそのようなすべての変更の前に行われたすべての変更が含まれた後、このような場合には、データを提示していることを確認するために、サーバの責任です。"
    },
    {
      "indent": 3,
      "text": "o STATUS4_WRITABLE, which indicates that the file system is an actual writable one. The client need not, of course, actually write to the file system, but once it does, it should not accept a transition to anything other than a writable instance of that same file system.",
      "ja": "ファイルシステムは、実際の書き込み可能なものであることを示しているSTATUS4_WRITABLE、O。クライアントは、もちろん、実際にはファイルシステムに書き込む必要はなく、それがないと、それはその同じファイルシステムの書き込み可能なインスタンス以外への移行を受け入れるべきではありません。"
    },
    {
      "indent": 3,
      "text": "o STATUS4_REFERRAL, which indicates that the file system in question is absent and has never been present on this server.",
      "ja": "問題のファイルシステムが存在しないと、このサーバー上に存在ではなかったことを示しSTATUS4_REFERRAL、O。"
    },
    {
      "indent": 3,
      "text": "Note that in the STATUS4_UPDATED and STATUS4_VERSIONED cases, the server is responsible for the appropriate handling of locks that are inconsistent with external changes to delegations. If a server gives out delegations, they SHOULD be recalled before an inconsistent change is made to the data, and MUST be revoked if this is not possible. Similarly, if an OPEN is inconsistent with data that is changed (the OPEN has OPEN4_SHARE_DENY_WRITE/OPEN4_SHARE_DENY_BOTH and the data is changed), that OPEN SHOULD be considered administratively revoked.",
      "ja": "STATUS4_UPDATEDとSTATUS4_VERSIONED例では、サーバは代表団への外部の変更と矛盾しているロックの適切な取扱いのための責任があることに注意してください。サーバが代表団を与えた場合、矛盾変更がデータに対して行われる前に、彼らはリコールする必要があり、これが不可能な場合は取り消さなければなりません。 OPENが変更されたデータと一致しない場合は同様に、OPENが管理失効考慮されるべきであること、（OPENはOPEN4_SHARE_DENY_WRITE / OPEN4_SHARE_DENY_BOTHを有しており、データが変更されます）。"
    },
    {
      "indent": 3,
      "text": "The opaque strings fss_source and fss_current provide a way of presenting information about the source of the file system image being present. It is not intended that the client do anything with this information other than make it available to administrative tools. It is intended that this information be helpful when researching possible problems with a file system image that might arise when it is unclear if the correct image is being accessed and, if not, how that image came to be made. This kind of diagnostic information will be helpful, if, as seems likely, copies of file systems are made in many different ways (e.g., simple user-level copies, file-system-level point-in-time copies, clones of the underlying storage), under a variety of administrative arrangements. In such environments, determining how a given set of data was constructed can be very helpful in resolving problems.",
      "ja": "不透明な文字列fss_sourceとfss_currentが存在しているファイル・システム・イメージのソースに関する情報を提示する方法を提供します。クライアントが管理ツールが利用できるようする以外に、この情報を使って何を行うことを意図するものではありません。その画像が作られるようになったか、そうでない場合、正しい画像がアクセスされている場合、それは不明である場合に生じる可能性があるとファイル・システム・イメージを持つ可能性のある問題を研究する際に、この情報が役立つことが意図されています。思わとして、ファイルシステムのコピーが多くの異なる方法（例えば、シンプルなユーザー・レベルのコピー、ファイル・システム・レベルのポイント・イン・タイム・コピー、基礎となるのクローンに行われた場合、診断この種の情報は、参考になりますストレージ）、行政配置の様々な下。そのような環境では、データの所与のセットを構築した方法を決定する問題を解決するのに非常に有用であることができます。"
    },
    {
      "indent": 3,
      "text": "The opaque string fss_source is used to indicate the source of a given file system with the expectation that tools capable of creating a file system image propagate this information, when possible. It is understood that this may not always be possible since a user-level copy may be thought of as creating a new data set and the tools used may have no mechanism to propagate this data. When a file system is initially created, it is desirable to associate with it data regarding how the file system was created, where it was created, who created it, etc. Making this information available in this attribute in a human-readable string will be helpful for applications and system administrators and will also serve to make it available when the original file system is used to make subsequent copies.",
      "ja": "不透明な文字列fss_sourceが可能なファイルシステムイメージを作成することが可能なツールは、この情報を伝達することを期待して、与えられたファイルシステムのソースを示すために使用されます。ユーザレベルのコピーは、新しいデータセットを作成すると考えることができると使用するツールは、このデータを伝播するメカニズムを持っていないかもしれないので、これは常に可能ではないかもしれないことが理解されます。ファイルシステムが最初に作成されると、判読できる文字列で、この属性では、この情報を利用可能にすることになるなど、それを作成した人、それでそれを作成したところ、ファイルシステムは、どのように作成されたかに関するデータを関連付けることが望ましいです。アプリケーションやシステム管理者のために役立つとも元のファイルシステムは、その後のコピーを作成するために使用されている場合、それを利用可能にするのに役立つであろう。"
    },
    {
      "indent": 3,
      "text": "The opaque string fss_current should provide whatever information is available about the source of the current copy. Such information includes the tool creating it, any relevant parameters to that tool, the time at which the copy was done, the user making the change, the server on which the change was made, etc. All information should be in a human-readable string.",
      "ja": "不透明な文字列fss_currentは、現在のコピーの源について利用可能なあらゆる情報を提供すべきです。このような情報は、そのツールに関連するすべてのパラメータを、それを作成するツールが含まれ、コピーが行われた時間は、などの変更、変更が行われたサーバーを、行っているユーザーは、すべての情報は、人間が読めるにする必要があります文字列。"
    },
    {
      "indent": 3,
      "text": "The field fss_age provides an indication of how out-of-date the file system currently is with respect to its ultimate data source (in case of cascading data updates). This complements the fls_currency field of fs_locations_server4 (see Section 11.10) in the following way: the information in fls_currency gives a bound for how out of date the data in a file system might typically get, while the value in fss_age gives a bound on how out-of-date that data actually is. Negative values imply that no information is available. A zero means that this data is known to be current. A positive value means that this data is known to be no older than that number of seconds with respect to the ultimate data source. Using this value, the client may be able to decide that a data copy is too old, so that it may search for a newer version to use.",
      "ja": "フィールドfss_ageは、期限切れのファイルシステムが現在（データ更新をカスケード接続の場合）、その最終的なデータソースに対してどのようの指標を提供します。これは、次のように（項11.10を参照）fs_locations_server4のfls_currencyフィールドを補完：fss_ageの値はどのようにアウトにバインド与えながらfls_currency内の情報は、ファイルシステムの日付のうち、データが一般的になるかもしれない方法については、バウンドを与えます-of-日付データが実際にあります。負の値は情報がないことを示唆しています。ゼロは、このデータが現在あることが知られていることを意味します。正の値は、このデータは、最終的なデータ・ソースに対する秒の数よりも古いことがないことが知られていることを意味します。この値を使用して、クライアントはそれを使用するには、新しいバージョンを検索することができるように、データのコピーが、古すぎると判断することができるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The fss_version field provides a version identification, in the form of a time value, such that successive versions always have later time values. When the fs_type is anything other than STATUS4_VERSIONED, the server may provide such a value, but there is no guarantee as to its validity and clients will not use it except to provide additional information to add to fss_source and fss_current.",
      "ja": "fss_versionフィールドは、連続するバージョンが常に後で値を有するように、時間値の形式で、バージョンIDを提供します。 fs_typeがSTATUS4_VERSIONED以外の場合は、サーバーは、そのような価値を提供することができるが、その有効性と顧客への保証などfss_sourceとfss_currentに追加する追加情報を提供する以外には使用しませんがありません。"
    },
    {
      "indent": 3,
      "text": "When fss_type is STATUS4_VERSIONED, servers SHOULD provide a value of fss_version that progresses monotonically whenever any new version of the data is established. This allows the client, if reliable image progression is important to it, to fetch this attribute as part of each COMPOUND where data or metadata from the file system is used.",
      "ja": "fss_typeがSTATUS4_VERSIONEDされている場合、サーバは、データの任意の新しいバージョンが確立されるたびに単調に進行fss_versionの価値を提供する必要があります。これにより、クライアントは、信頼性の高い画像の進行がそれにとって重要である場合は、ファイルシステムからのデータやメタデータが使用されている各化合物の一部として、この属性を取得することができます。"
    },
    {
      "indent": 3,
      "text": "When it is important to the client to make sure that only valid successor images are accepted, it must make sure that it does not read data or metadata from the file system without updating its sense of the current state of the image. This is to avoid the possibility that the fs_status that the client holds will be one for an earlier image, which would cause the client to accept a new file system instance that is later than that but still earlier than the updated data read by the client.",
      "ja": "それが唯一の有効な後継イメージが受け入れられることを確認するために、クライアントにとって重要である場合には、それはそれは、画像の現在の状態のその感覚を更新せずに、ファイル・システムからのデータやメタデータを読み取らないことを確認する必要があります。これは、クライアントが保持しているfs_statusは、クライアントが後でそれよりも、まだ以前のクライアントによって読み取ら更新されたデータよりも新しいファイル・システム・インスタンスを受け入れるように原因となる以前の画像、のためのものになるという可能性を避けるためです。"
    },
    {
      "indent": 3,
      "text": "In order to accept valid images reliably, the client must do a GETATTR of the fs_status attribute that follows any interrogation of data or metadata within the file system in question. Often this is most conveniently done by appending such a GETATTR after all other operations that reference a given file system. When errors occur between reading file system data and performing such a GETATTR, care must be exercised to make sure that the data in question is not used before obtaining the proper fs_status value. In this connection, when an OPEN is done within such a versioned file system and the associated GETATTR of fs_status is not successfully completed, the open file in question must not be accessed until that fs_status is fetched.",
      "ja": "確実に有効な画像を受け入れるためには、クライアントは、問題のファイルシステム内のデータやメタデータの任意の取り調べを次のfs_status属性のGETATTRを行う必要があります。多くの場合、これは、最も便利に与えられたファイルシステムを参照する他のすべての操作の後に、このようなGETATTRを追加することで行われます。エラーは、ファイルシステムのデータを読み込むと、このようなGETATTRを実行する間に発生した場合は、注意が問題のデータが適切なfs_status値を取得する前に使用されていないことを確認するために払わなければなりません。そのfs_statusがフェッチされるまで、これに関連して、OPENは、このようなバージョン管理されたファイルシステム内で行われ、fs_statusの関連するGETATTRが正常に完了しない場合には、問題の開いているファイルにはアクセスしてはいけません。"
    },
    {
      "indent": 3,
      "text": "The procedure above will ensure that before using any data from the file system the client has in hand a newly-fetched current version of the file system image. Multiple values for multiple requests in flight can be resolved by assembling them into the required partial order (and the elements should form a total order within the partial order) and using the last. The client may then, when switching among file system instances, decline to use an instance that does not have an fss_type of STATUS4_VERSIONED or whose fss_version field is earlier than the last one obtained from the predecessor file system instance.",
      "ja": "上記の手順は、クライアントが手にファイルシステムイメージの新たにフェッチされた現在のバージョンを持つファイルシステムから任意のデータを使用する前にそれを確実にします。飛行中の複数の要求のために複数の値が必要な半順序にそれらを組み立てることによって解決することができ（及び要素は、半順序内の全順序を形成しなければならない）と最後を使用。ファイル・システム・インスタンス間で切り替えるときに、クライアントは、その後、減少はfss_versionフィールド前身のファイル・システム・インスタンスから取得した最後のものよりも前であるSTATUS4_VERSIONEDのfss_typeかを持っていないインスタンスを使用することがあります。"
    },
    {
      "indent": 0,
      "text": "12. Parallel NFS (pNFS)",
      "section_title": true,
      "ja": "12.パラレルNFS（pNFSの）"
    },
    {
      "indent": 0,
      "text": "12.1. Introduction",
      "section_title": true,
      "ja": "12.1. 前書き"
    },
    {
      "indent": 3,
      "text": "pNFS is an OPTIONAL feature within NFSv4.1; the pNFS feature set allows direct client access to the storage devices containing file data. When file data for a single NFSv4 server is stored on multiple and/or higher-throughput storage devices (by comparison to the server's throughput capability), the result can be significantly better file access performance. The relationship among multiple clients, a single server, and multiple storage devices for pNFS (server and clients have access to all storage devices) is shown in Figure 1.",
      "ja": "pNFSのはNFSv4.1内のオプション機能です。 pNFSのセットは、ファイルデータを含むストレージ・デバイスへの直接のクライアントアクセスを可能に備わっています。単一のNFSv4サーバのファイルデータ（サーバのスループット能力と比較することによって）、複数のおよび/またはより高いスループットのストレージデバイスに格納されている場合、結果が有意に良好なファイルアクセス性能とすることができます。 pNFSの（サーバとクライアントは、すべてのストレージデバイスへのアクセス権を持っている）のための複数のクライアントの関係、単一サーバ、および複数の記憶装置は、図1に示されています。"
    },
    {
      "indent": 7,
      "text": "+-----------+\n|+-----------+                                 +-----------+\n||+-----------+                                |           |\n|||           |        NFSv4.1 + pNFS          |           |\n+||  Clients  |<------------------------------>|   Server  |\n +|           |                                |           |\n  +-----------+                                |           |\n       |||                                     +-----------+\n       |||                                           |\n       |||                                           |\n       ||| Storage        +-----------+              |\n       ||| Protocol       |+-----------+             |\n       ||+----------------||+-----------+  Control   |\n       |+-----------------|||           |    Protocol|\n       +------------------+||  Storage  |------------+\n                           +|  Devices  |\n                            +-----------+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "In this model, the clients, server, and storage devices are responsible for managing file access. This is in contrast to NFSv4 without pNFS, where it is primarily the server's responsibility; some of this responsibility may be delegated to the client under strictly specified conditions. See Section 12.2.5 for a discussion of the Storage Protocol. See Section 12.2.6 for a discussion of the Control Protocol.",
      "ja": "このモデルでは、クライアント、サーバー、およびストレージデバイスは、ファイルへのアクセスを管理する責任があります。これは主に、サーバの責任であるのpNFS、なしNFSv4のとは対照的です。この責任の一部は、厳密に指定された条件の下で、クライアントに委任することができます。ストレージプロトコルの議論については、セクション12.2.5を参照してください。制御プロトコルの議論については、セクション12.2.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "pNFS takes the form of OPTIONAL operations that manage protocol objects called 'layouts' (Section 12.2.7) that contain a byte-range and storage location information. The layout is managed in a similar fashion as NFSv4.1 data delegations. For example, the layout is leased, recallable, and revocable. However, layouts are distinct abstractions and are manipulated with new operations. When a client holds a layout, it is granted the ability to directly access the byte-range at the storage location specified in the layout.",
      "ja": "pNFSのはバイト範囲と格納場所情報が含まれている「レイアウト」（セクション12.2.7）と呼ばれるプロトコルオブジェクトを管理OPTIONAL操作の形態をとります。レイアウトはNFSv4.1データの代表団と同様の方法で管理されています。例えば、レイアウトは、リコール、および取り消しをリースしています。しかし、レイアウトは明確な抽象化され、新しい操作で操作されています。クライアントは、レイアウトを保持している場合は、直接レイアウトで指定された保管場所でバイト範囲にアクセスする能力を付与されます。"
    },
    {
      "indent": 3,
      "text": "There are interactions between layouts and other NFSv4.1 abstractions such as data delegations and byte-range locking. Delegation issues are discussed in Section 12.5.5. Byte-range locking issues are discussed in Sections 12.2.9 and 12.5.1.",
      "ja": "レイアウトと、データ委任およびバイト範囲ロックのような他のNFSv4.1の抽象化との間の相互作用があります。委任の問題は、セクション12.5.5で説明されています。バイト範囲ロックの問題はセクション12.2.9および12.5.1に記載されています。"
    },
    {
      "indent": 0,
      "text": "12.2. pNFS Definitions",
      "section_title": true,
      "ja": "12.2.  pNFSの定義"
    },
    {
      "indent": 3,
      "text": "NFSv4.1's pNFS feature provides parallel data access to a file system that stripes its content across multiple storage servers. The first instantiation of pNFS, as part of NFSv4.1, separates the file system protocol processing into two parts: metadata processing and data processing. Data consist of the contents of regular files that are striped across storage servers. Data striping occurs in at least two ways: on a file-by-file basis and, within sufficiently large files, on a block-by-block basis. In contrast, striped access to metadata by pNFS clients is not provided in NFSv4.1, even though the file system back end of a pNFS server might stripe metadata. Metadata consist of everything else, including the contents of non-regular files (e.g., directories); see Section 12.2.1. The metadata functionality is implemented by an NFSv4.1 server that supports pNFS and the operations described in Section 18; such a server is called a metadata server (Section 12.2.2).",
      "ja": "NFSv4.1のpNFSの機能は、そのストライプ複数のストレージサーバー間でその内容をファイルシステムに平行なデータアクセスを提供します。メタデータ処理およびデータ処理：pNFSの最初のインスタンスは、NFSv4.1の一部として、二つの部分にファイルシステムプロトコル処理を分離します。データは、ストレージサーバにまたがってストライプされ、通常のファイルの内容で構成されています。データストライピングは、少なくとも2つの方法で行われます。ファイルごとにと、十分に大きなファイル内で、ブロックごとに。これとは対照的に、pNFSのクライアントによるメタデータへのアクセスストライプはpNFSのサーバーのファイルシステムのバックエンドは、メタデータをストライプ場合でも、NFSv4.1で提供されていません。メタデータは、非正規のファイル（例えば、ディレクトリ）の内容を含め、他のすべてから成り; 12.2.1項を参照してください。メタデータ機能はpNFSの、セクション18で説明した動作をサポートするNFSv4.1サーバによって実現されます。そのようなサーバは、メタデータサーバ（12.2.2）と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "The data functionality is implemented by one or more storage devices, each of which are accessed by the client via a storage protocol. A subset (defined in Section 13.6) of NFSv4.1 is one such storage protocol. New terms are introduced to the NFSv4.1 nomenclature and existing terms are clarified to allow for the description of the pNFS feature.",
      "ja": "データ機能は、ストレージプロトコルを介してクライアントによってアクセスされるそれぞれが1つ以上の記憶装置によって実現されます。 NFSv4.1の（セクション13.6で定義された）サブセットは、そのようなストレージ・プロトコルです。新しい用語は、NFSv4.1命名法に導入され、既存の用語は、pNFSの機能の説明を可能にすることを明らかにしています。"
    },
    {
      "indent": 0,
      "text": "12.2.1. Metadata",
      "section_title": true,
      "ja": "12.2.1. メタデータ"
    },
    {
      "indent": 3,
      "text": "Information about a file system object, such as its name, location within the namespace, owner, ACL, and other attributes. Metadata may also include storage location information, and this will vary based on the underlying storage mechanism that is used.",
      "ja": "ファイルシステムオブジェクトに関する情報は、そのような名前、名前空間内の位置、所有者、ACL、およびその他の属性として。メタデータは、保存場所情報を含むことができ、これは使用される基礎をなす記憶メカニズムに基づいて変化するであろう。"
    },
    {
      "indent": 0,
      "text": "12.2.2. Metadata Server",
      "section_title": true,
      "ja": "12.2.2. メタデータサーバ"
    },
    {
      "indent": 3,
      "text": "An NFSv4.1 server that supports the pNFS feature. A variety of architectural choices exist for the metadata server and its use of file system information held at the server. Some servers may contain metadata only for file objects residing at the metadata server, while the file data resides on associated storage devices. Other metadata servers may hold both metadata and a varying degree of file data.",
      "ja": "pNFSの機能をサポートしているNFSv4.1サーバー。建築の選択肢の様々なメタデータサーバとサーバで開催されたファイルシステム情報の使用のために存在します。ファイルデータが関連付けられているストレージ・デバイスに常駐しながら、いくつかのサーバは、メタデータだけサーバに常駐するファイルオブジェクトのメタデータが含まれていてもよいです。その他のメタデータサーバは、メタデータとファイルデータの様々な程度の両方を保持することができます。"
    },
    {
      "indent": 0,
      "text": "12.2.3. pNFS Client",
      "section_title": true,
      "ja": "12.2.3.  pNFSのクライアント"
    },
    {
      "indent": 3,
      "text": "An NFSv4.1 client that supports pNFS operations and supports at least one storage protocol for performing I/O to storage devices.",
      "ja": "pNFSの操作をサポートし、ストレージ・デバイスへのI / Oを実行するための少なくとも一つのストレージプロトコルをサポートしていNFSv4.1クライアント。"
    },
    {
      "indent": 0,
      "text": "12.2.4. Storage Device",
      "section_title": true,
      "ja": "12.2.4. ストレージデバイス"
    },
    {
      "indent": 3,
      "text": "A storage device stores a regular file's data, but leaves metadata management to the metadata server. A storage device could be another NFSv4.1 server, an object-based storage device (OSD), a block device accessed over a System Area Network (SAN, e.g., either FiberChannel or iSCSI SAN), or some other entity.",
      "ja": "ストレージデバイスは、通常のファイルのデータを格納しますが、メタデータサーバへのメタデータの管理を離れました。記憶装置は、別のNFSv4.1サーバ、オブジェクトベースの記憶装置（OSD）、システムエリアネットワーク（SAN、例えば、ファイバーチャネルまたはiSCSI SANのいずれか）、または何らかの他のエンティティを介してアクセスブロックデバイスとすることができます。"
    },
    {
      "indent": 0,
      "text": "12.2.5. Storage Protocol",
      "section_title": true,
      "ja": "12.2.5. ストレージ・プロトコル"
    },
    {
      "indent": 3,
      "text": "As noted in Figure 1, the storage protocol is the method used by the client to store and retrieve data directly from the storage devices.",
      "ja": "図1で述べたように、ストレージ・プロトコルは、ストレージデバイスから直接データを格納および検索するためにクライアントによって使用される方法です。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 pNFS feature has been structured to allow for a variety of storage protocols to be defined and used. One example storage protocol is NFSv4.1 itself (as documented in Section 13). Other options for the storage protocol are described elsewhere and include:",
      "ja": "NFSv4.1 pNFSの機能を定義して使用するストレージプロトコルの多様を可能にするために構成されています。一例としてストレージプロトコルはNFSv4.1自体（項13に記載のように）です。ストレージプロトコルのための他のオプションは、他の場所に記載して含まれています。"
    },
    {
      "indent": 3,
      "text": "o Block/volume protocols such as Internet SCSI (iSCSI) [48] and FCP [49]. The block/volume protocol support can be independent of the addressing structure of the block/volume protocol used, allowing more than one protocol to access the same file data and enabling extensibility to other block/volume protocols. See [41] for a layout specification that allows pNFS to use block/volume storage protocols.",
      "ja": "[49]ブロック/体積、インターネットSCSI（iSCSIの）などのプロトコル[48]およびFCP O。ブロック/ボリュームプロトコルのサポートは、同じファイルデータにアクセスするために複数のプロトコルを可能にし、他のブロック/体積プロトコルに拡張を可能にする、使用されるブロック/ボリュームプロトコルのアドレッシング構造とは無関係であることができます。 pNFSのブロック/ボリューム・ストレージ・プロトコルを使用することができ、レイアウトの仕様のために[41]を参照。"
    },
    {
      "indent": 3,
      "text": "o Object protocols such as OSD over iSCSI or Fibre Channel [50]. See [40] for a layout specification that allows pNFS to use object storage protocols.",
      "ja": "そのようなiSCSIまたはファイバチャネル[50]上にOSDとしてOオブジェクトプロトコル。 pNFSのオブジェクト・ストレージ・プロトコルを使用することができ、レイアウトの仕様のために[40]を参照。"
    },
    {
      "indent": 3,
      "text": "It is possible that various storage protocols are available to both client and server and it may be possible that a client and server do not have a matching storage protocol available to them. Because of this, the pNFS server MUST support normal NFSv4.1 access to any file accessible by the pNFS feature; this will allow for continued interoperability between an NFSv4.1 client and server.",
      "ja": "さまざまなストレージ・プロトコルは、クライアントとサーバーの両方に利用可能であり、クライアントとサーバがそれらに利用可能なマッチング・ストレージ・プロトコルを持っていない可能性があり得ることも可能です。このため、pNFSのサーバーはpNFSの機能によってアクセス可能な任意のファイルへの通常NFSv4.1のアクセスをサポートしなければなりません。これはNFSv4.1のクライアントとサーバの間の継続的な相互運用を可能にします。"
    },
    {
      "indent": 0,
      "text": "12.2.6. Control Protocol",
      "section_title": true,
      "ja": "12.2.6. 制御プロトコル"
    },
    {
      "indent": 3,
      "text": "As noted in Figure 1, the control protocol is used by the exported file system between the metadata server and storage devices. Specification of such protocols is outside the scope of the NFSv4.1 protocol. Such control protocols would be used to control activities such as the allocation and deallocation of storage, the management of state required by the storage devices to perform client access control, and, depending on the storage protocol, the enforcement of authentication and authorization so that restrictions that would be enforced by the metadata server are also enforced by the storage device.",
      "ja": "図1で述べたように、制御プロトコルは、メタデータサーバとストレージデバイス間のエクスポートされたファイルシステムによって使用されます。そのようなプロトコルの仕様は、NFSv4.1プロトコルの範囲外です。このような制御プロトコルは、このようなストレージの割り当てと解放などの活動を制御するために使用される、状態の管理は、クライアントのアクセス制御を実行するためにストレージデバイスで必要とされる、および、ストレージ・プロトコルに応じて、認証と認可の施行制限するようにそれはまた、ストレージデバイスによって強制されているメタデータサーバによって強制されるだろう。"
    },
    {
      "indent": 3,
      "text": "A particular control protocol is not REQUIRED by NFSv4.1 but requirements are placed on the control protocol for maintaining attributes like modify time, the change attribute, and the end-of-file (EOF) position. Note that if pNFS is layered over a clustered, parallel file system (e.g., PVFS [51]), the mechanisms that enable clustering and parallelism in that file system can be considered the control protocol.",
      "ja": "特定の制御プロトコルはNFSv4.1によって必要とされず、要求は時間を変更するような属性を維持するための制御プロトコル、変化属性、及びエンド・オブ・ファイル（EOF）の位置に配置されています。 pNFSのクラスタ化、並列ファイルシステム上に積層されている場合（例えば、PVFS [51]）、そのファイルシステム内のクラスタリングおよび並列処理を可能にメカニズムが制御プロトコルとみなすことができることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "12.2.7. Layout Types",
      "section_title": true,
      "ja": "12.2.7. レイアウトタイプ"
    },
    {
      "indent": 3,
      "text": "A layout describes the mapping of a file's data to the storage devices that hold the data. A layout is said to belong to a specific layout type (data type layouttype4, see Section 3.3.13). The layout type allows for variants to handle different storage protocols, such as those associated with block/volume [41], object [40], and file (Section 13) layout types. A metadata server, along with its control protocol, MUST support at least one layout type. A private sub-range of the layout type namespace is also defined. Values from the private layout type range MAY be used for internal testing or experimentation (see Section 3.3.13).",
      "ja": "レイアウトは、データを保持するストレージデバイスへのファイルのデータのマッピングを記述します。レイアウトは、特定のレイアウトタイプ（データ型layouttype4、セクション3.3.13を参照のこと）に属すると言われています。レイアウトタイプは、変異体は、このようなブロック/ボリュームに関連付けられているもののような異なるストレージプロトコルを処理するために、[41]可能オブジェクト[40]、およびファイル（セクション13）レイアウトタイプ。メタデータサーバは、その制御プロトコルと一緒に、少なくとも1つのレイアウトタイプをサポートしなければなりません。レイアウトタイプの名前空間のプライベートサブ範囲も定義されています。プライベートレイアウトタイプの範囲から値が（セクション3.3.13を参照）内部テストや実験のために使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "As an example, the organization of the file layout type could be an array of tuples (e.g., device ID, filehandle), along with a definition of how the data is stored across the devices (e.g., striping). A block/volume layout might be an array of tuples that store <device ID, block number, block count> along with information about block size and the associated file offset of the block number. An object layout might be an array of tuples <device ID, object ID> and an additional structure (i.e., the aggregation map) that defines how the logical byte sequence of the file data is serialized into the different objects. Note that the actual layouts are typically more complex than these simple expository examples.",
      "ja": "一例として、ファイル・レイアウト・タイプの組織は、データがデバイス（例えば、ストライピング）を横切って格納されている方法の定義とともにタプルの配列（例えば、デバイスID、ファイルハンドル）とすることができます。ブロック/ボリュームレイアウトは、ブロックサイズとブロック番号のオフセット関連付けられたファイルについての情報と一緒に<デバイスID、ブロック番号、ブロック数>を格納タプルの配列であるかもしれません。オブジェクトのレイアウトは、タプル<デバイスID、オブジェクトID>、ファイルデータの論理的なバイトシーケンスが異なるオブジェクトにシリアル化される方法を定義する追加の構造（すなわち、集計マップ）のアレイであるかもしれません。実際のレイアウトは一般的にこれらの簡単な解説の例よりも複雑であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Requests for pNFS-related operations will often specify a layout type. Examples of such operations are GETDEVICEINFO and LAYOUTGET. The response for these operations will include structures such as a device_addr4 or a layout4, each of which includes a layout type within it. The layout type sent by the server MUST always be the same one requested by the client. When a server sends a response that includes a different layout type, the client SHOULD ignore the response and behave as if the server had returned an error response.",
      "ja": "pNFSの関連の操作のための要求は、多くの場合、レイアウトの種類を指定します。このような操作の例としては、GETDEVICEINFOとLAYOUTGETあります。これらの操作のための応答は、その中のレイアウトタイプを含むそれぞれがdevice_addr4又はlayout4、などの構造を含むであろう。サーバーから送信されたレイアウトタイプは常にクライアントから要求されたものと同じものでなければなりません。サーバが別のレイアウトタイプを含む応答を送信すると、クライアントは応答を無視しなければなりません。サーバーがエラー応答を返したかのように振る舞います。"
    },
    {
      "indent": 0,
      "text": "12.2.8. Layout",
      "section_title": true,
      "ja": "12.2.8. レイアウト"
    },
    {
      "indent": 3,
      "text": "A layout defines how a file's data is organized on one or more storage devices. There are many potential layout types; each of the layout types are differentiated by the storage protocol used to access data and by the aggregation scheme that lays out the file data on the underlying storage devices. A layout is precisely identified by the tuple <client ID, filehandle, layout type, iomode, range>, where filehandle refers to the filehandle of the file on the metadata server.",
      "ja": "レイアウトは、ファイルのデータは、1つまたは複数のストレージデバイス上に編成される方法を定義します。多くの潜在的なレイアウトのタイプがあります。レイアウトタイプの各々は、アクセスデータ及び基礎となるストレージデバイス上のファイルのデータをレイアウト集計方式が使用するストレージプロトコルによって区別されます。レイアウトが正確にファイルハンドルは、メタデータサーバ上のファイルのファイルハンドルを指すタプル<クライアントID、ファイルハンドル、レイアウトタイプ、IOModeに、範囲>によって識別されます。"
    },
    {
      "indent": 3,
      "text": "It is important to define when layouts overlap and/or conflict with each other. For two layouts with overlapping byte-ranges to actually overlap each other, both layouts must be of the same layout type, correspond to the same filehandle, and have the same iomode. Layouts conflict when they overlap and differ in the content of the layout (i.e., the storage device/file mapping parameters differ). Note that differing iomodes do not lead to conflicting layouts. It is permissible for layouts with different iomodes, pertaining to the same byte-range, to be held by the same client. An example of this would be copy-on-write functionality for a block/volume layout type.",
      "ja": "レイアウトは、互いに及び/又は衝突重複する場合には、定義することが重要です。バイト範囲実際に互いに重なるように重複する2つのレイアウトのために、両方のレイアウトは、同じレイアウトタイプである必要があり、同じファイルハンドルに対応し、同じIOModeにしています。レイアウトは競合それらが重なると、レイアウトの内容が異なる（すなわち、記憶デバイス/ファイルマッピングパラメータが異なります）。異なるiomodesは競合レイアウトにつながらないことに注意してください。これは、同じクライアントによって保持されるように、同じバイト範囲に属する、異なるiomodesとレイアウトの許容です。この例では、ブロック/ボリュームレイアウトタイプのコピー・オン・ライト機能であろう。"
    },
    {
      "indent": 0,
      "text": "12.2.9. Layout Iomode",
      "section_title": true,
      "ja": "12.2.9. レイアウトIOModeに"
    },
    {
      "indent": 3,
      "text": "The layout iomode (data type layoutiomode4, see Section 3.3.20) indicates to the metadata server the client's intent to perform either just READ operations or a mixture containing READ and WRITE operations. For certain layout types, it is useful for a client to specify this intent at the time it sends LAYOUTGET (Section 18.43). For example, for block/volume-based protocols, block allocation could occur when a LAYOUTIOMODE4_RW iomode is specified. A special LAYOUTIOMODE4_ANY iomode is defined and can only be used for LAYOUTRETURN and CB_LAYOUTRECALL, not for LAYOUTGET. It specifies that layouts pertaining to both LAYOUTIOMODE4_READ and LAYOUTIOMODE4_RW iomodes are being returned or recalled, respectively.",
      "ja": "レイアウトIOModeに（データ・タイプlayoutiomode4、セクション3.3.20を参照）は、メタデータサーバのいずれかだけで操作やREADを含む混合物を、読み出し動作と書き込み動作を実行するために、クライアントの意図を示しています。特定のレイアウトタイプの場合、それはLAYOUTGET（セクション18.43）を送る時に、この意図を指定するには、クライアントのために有用です。 LAYOUTIOMODE4_RWのIOModeには、指定された場合、例えば、ブロック/体積ベースのプロトコルのために、ブロックの割り当てが発生する可能性があります。特別LAYOUTIOMODE4_ANYのIOModeには定義されているだけではないLAYOUTGETためLAYOUTRETURNとCB_LAYOUTRECALL、使用することができます。これは、両方のLAYOUTIOMODE4_READとLAYOUTIOMODE4_RW iomodesに関連するレイアウトは、それぞれ、返品・リコールされていることを指定します。"
    },
    {
      "indent": 3,
      "text": "A storage device may validate I/O with regard to the iomode; this is dependent upon storage device implementation and layout type. Thus, if the client's layout iomode is inconsistent with the I/O being performed, the storage device may reject the client's I/O with an error indicating that a new layout with the correct iomode should be obtained via LAYOUTGET. For example, if a client gets a layout with a LAYOUTIOMODE4_READ iomode and performs a WRITE to a storage device, the storage device is allowed to reject that WRITE.",
      "ja": "記憶装置はIOModeにに関してI / Oを検証することができます。これは、ストレージデバイスの実装とレイアウトの種類に依存します。クライアントのレイアウトIOModeには、I / Oが実行さと一致しない場合従って、記憶装置は、正しいIOModeに持つ新しいレイアウトがLAYOUTGETを介して取得しなければならないことを示すエラーをクライアントのI / Oを拒否することができます。クライアントはLAYOUTIOMODE4_READのIOModeにしてレイアウトを取得し、記憶装置への書き込みを行う場合、例えば、記憶装置はそのWRITEを拒否することができます。"
    },
    {
      "indent": 3,
      "text": "The use of the layout iomode does not conflict with OPEN share modes or byte-range LOCK operations; open share mode and byte-range lock conflicts are enforced as they are without the use of pNFS and are logically separate from the pNFS layout level. Open share modes and byte-range locks are the preferred method for restricting user access to data files. For example, an OPEN of OPEN4_SHARE_ACCESS_WRITE does not conflict with a LAYOUTGET containing an iomode of LAYOUTIOMODE4_RW performed by another client. Applications that depend on writing into the same file concurrently may use byte-range locking to serialize their accesses.",
      "ja": "レイアウトIOModeにの使用は、OPEN共有モードまたはバイト範囲ロック操作と競合しません。彼らはpNFSのを使用せずにいると、論理的にpNFSのレイアウトレベルから分離されているとして、オープン共有モードとバイト範囲ロックの競合が適用されます。オープン共有モードとバイト範囲ロックは、データファイルへのユーザーアクセスを制限するための好ましい方法です。例えば、OPEN4_SHARE_ACCESS_WRITEのOPENは、別のクライアントによって実行さLAYOUTIOMODE4_RWのIOModeにを含むLAYOUTGETと競合することはありません。同時に同じファイルへの書き込みに依存するアプリケーションは、自分のアクセスをシリアル化するためにバイト範囲ロックを使用することができます。"
    },
    {
      "indent": 0,
      "text": "12.2.10. Device IDs",
      "section_title": true,
      "ja": "12.2.10. デバイスID"
    },
    {
      "indent": 3,
      "text": "The device ID (data type deviceid4, see Section 3.3.14) identifies a group of storage devices. The scope of a device ID is the pair <client ID, layout type>. In practice, a significant amount of information may be required to fully address a storage device. Rather than embedding all such information in a layout, layouts embed device IDs. The NFSv4.1 operation GETDEVICEINFO (Section 18.40) is used to retrieve the complete address information (including all device addresses for the device ID) regarding the storage device according to its layout type and device ID. For example, the address of an NFSv4.1 data server or of an object-based storage device could be an IP address and port. The address of a block storage device could be a volume label.",
      "ja": "デバイスID（データ型deviceid4は、セクション3.3.14を参照のこと）ストレージデバイスのグループを識別する。デバイスIDの範囲は、対<クライアントID、レイアウトタイプ>です。実際には、情報のかなりの量は、完全にストレージデバイスに対処するために必要とされ得ます。むしろ、レイアウト内のすべてのそのような情報を埋め込むよりも、レイアウトは、デバイスIDを埋め込みます。 NFSv4.1操作GETDEVICEINFO（セクション18.40）は、レイアウトタイプとデバイスIDに係る記憶装置について（デバイスIDのためのすべてのデバイスアドレスを含む）完全なアドレス情報を取得するために使用されます。例えば、NFSv4.1データサーバーまたはオブジェクトベースの記憶装置のアドレスは、IPアドレスとポートであってもよいです。ブロック・ストレージ・デバイスのアドレスは、ボリュームラベルである可能性があります。"
    },
    {
      "indent": 3,
      "text": "Clients cannot expect the mapping between a device ID and its storage device address(es) to persist across metadata server restart. See Section 12.7.4 for a description of how recovery works in that situation.",
      "ja": "クライアントは、デバイスIDとそのストレージデバイスのアドレス（複数可）との間のマッピングは、メタデータ・サーバの再起動も持続することを期待することはできません。回復はそのような状況でどのように動作するかの説明については、セクション12.7.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "A device ID lives as long as there is a layout referring to the device ID. If there are no layouts referring to the device ID, the server is free to delete the device ID any time. Once a device ID is deleted by the server, the server MUST NOT reuse the device ID for the same layout type and client ID again. This requirement is feasible because the device ID is 16 bytes long, leaving sufficient room to store a generation number if the server's implementation requires most of the rest of the device ID's content to be reused. This requirement is necessary because otherwise the race conditions between asynchronous notification of device ID addition and deletion would be too difficult to sort out.",
      "ja": "デバイスIDがあれば、デバイスIDを参照するレイアウトが存在するように住んでいます。デバイスIDを参照一切のレイアウトがない場合、サーバは、デバイスIDをいつでも削除して自由です。デバイスIDがサーバーによって削除されると、サーバは再び同じレイアウトタイプとクライアントIDのデバイスIDを再利用してはいけません。デバイスIDは、サーバーの実装を再利用するデバイスIDのコンテンツの残りの部分のほとんどを必要とする場合に世代番号を格納するのに十分な余地を残して、16バイト長であるため、この要件が実現可能です。非同期デバイスIDの追加の通知と削除の間にそれ以外のレース条件が整理するにはあまりにも難しいだろうので、この要件が必要です。"
    },
    {
      "indent": 3,
      "text": "Device ID to device address mappings are not leased, and can be changed at any time. (Note that while device ID to device address mappings are likely to change after the metadata server restarts, the server is not required to change the mappings.) A server has two choices for changing mappings. It can recall all layouts referring to the device ID or it can use a notification mechanism.",
      "ja": "デバイス・アドレス・マッピングへのデバイスIDがリースされていない、いつでも変更することができます。 （デバイス・アドレス・マッピングへのデバイスIDがメタデータサーバの再起動後に変更する可能性があるが、サーバーはマッピングを変更する必要がないことに注意してください。）サーバは、マッピングを変更するための2つの選択肢を有しています。これは、デバイスIDを参照するすべてのレイアウトを思い出すことができるか、それが通知メカニズムを使用することができます。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol has no optimal way to recall all layouts that referred to a particular device ID (unless the server associates a single device ID with a single fsid or a single client ID; in which case, CB_LAYOUTRECALL has options for recalling all layouts associated with the fsid, client ID pair, or just the client ID).",
      "ja": "NFSv4.1プロトコルは、サーバーが単一のFSIDを有する単一のデバイスIDまたは単一のクライアントIDを関連付けるしない限り、特定のデバイスID（と呼ばれるすべてのレイアウトを呼び出すない最適な方法を持っていない。その場合には、CB_LAYOUTRECALLは、すべてのレイアウトを呼び出すためのオプションを有していますFSID、クライアントIDのペア、または単にクライアントID）に関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Via a notification mechanism (see Section 20.12), device ID to device address mappings can change over the duration of server operation without recalling or revoking the layouts that refer to device ID.",
      "ja": "通知メカニズム（セクション20.12を参照）を介して、デバイスアドレスのマッピングにデバイスIDは、デバイスIDを参照してレイアウトをリコールまたは取り消すことなく、サーバの動作の期間にわたって変更することができます。"
    },
    {
      "indent": 3,
      "text": "The notification mechanism can also delete a device ID, but only if the client has no layouts referring to the device ID. A notification of a change to a device ID to device address mapping will immediately or eventually invalidate some or all of the device ID's mappings. The server MUST support notifications and the client must request them before they can be used. For further information about the notification types Section 20.12.",
      "ja": "通知メカニズムは、デバイスIDを削除することができますが、クライアントは、デバイスIDを参照一切のレイアウトを持っていない場合に限ります。デバイスアドレスマッピングへのデバイスIDへの変更の通知は、直ちにまたは最終的には、デバイスIDのマッピングの一部またはすべてを無効にします。サーバは、通知をサポートしなければならないと、彼らが使用することができます前に、クライアントがそれらを要求する必要があります。通知タイプのセクション20.12の詳細については。"
    },
    {
      "indent": 0,
      "text": "12.3. pNFS Operations",
      "section_title": true,
      "ja": "12.3.  pNFSの操作"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 has several operations that are needed for pNFS servers, regardless of layout type or storage protocol. These operations are all sent to a metadata server and summarized here. While pNFS is an OPTIONAL feature, if pNFS is implemented, some operations are REQUIRED in order to comply with pNFS. See Section 17.",
      "ja": "NFSv4.1は関係なく、レイアウトタイプやストレージプロトコルの、pNFSのサーバに必要とされるいくつかの事業を展開しています。これらの操作は、すべてのメタデータ・サーバに送信され、ここに要約されています。 pNFSのはオプション機能ですがpNFSのが実装されている場合、一部の操作は、pNFSのに準拠するために必要とされます。第17を参照してください。"
    },
    {
      "indent": 3,
      "text": "These are the fore channel pNFS operations:",
      "ja": "これらは、前部チャネルのpNFS操作です："
    },
    {
      "indent": 3,
      "text": "GETDEVICEINFO (Section 18.40), as noted previously (Section 12.2.10), returns the mapping of device ID to storage device address.",
      "ja": "GETDEVICEINFO（セクション18.40）、前述したように（セクション12.2.10）は、記憶装置のアドレスにデバイスIDのマッピングを返します。"
    },
    {
      "indent": 3,
      "text": "GETDEVICELIST (Section 18.41) allows clients to fetch all device IDs for a specific file system.",
      "ja": "GETDEVICELIST（セクション18.41）は、クライアントが特定のファイルシステムのすべてのデバイスIDを取得することができます。"
    },
    {
      "indent": 3,
      "text": "LAYOUTGET (Section 18.43) is used by a client to get a layout for a file.",
      "ja": "LAYOUTGET（セクション18.43）は、ファイルのレイアウトを取得するために、クライアントによって使用されます。"
    },
    {
      "indent": 3,
      "text": "LAYOUTCOMMIT (Section 18.42) is used to inform the metadata server of the client's intent to commit data that has been written to the storage device (the storage device as originally indicated in the return value of LAYOUTGET).",
      "ja": "LAYOUTCOMMIT（セクション18.42）は、ストレージデバイス（元々LAYOUTGETの戻り値で示されるように、記憶装置）に書き込まれたデータをコミットするために、クライアントの意図のメタデータ・サーバに通知するために使用されています。"
    },
    {
      "indent": 3,
      "text": "LAYOUTRETURN (Section 18.44) is used to return layouts for a file, a file system ID (FSID), or a client ID.",
      "ja": "LAYOUTRETURN（セクション18.44）は、ファイルのレイアウト、ファイルシステムID（FSID）、またはクライアントIDを返すために使用されます。"
    },
    {
      "indent": 3,
      "text": "These are the backchannel pNFS operations:",
      "ja": "これらは、バックチャネルpNFSの操作です："
    },
    {
      "indent": 3,
      "text": "CB_LAYOUTRECALL (Section 20.3) recalls a layout, all layouts belonging to a file system, or all layouts belonging to a client ID.",
      "ja": "CB_LAYOUTRECALL（20.3）は、レイアウト、ファイルシステム、またはクライアントIDに属するすべてのレイアウトに属するすべてのレイアウトを思い出します。"
    },
    {
      "indent": 3,
      "text": "CB_RECALL_ANY (Section 20.6) tells a client that it needs to return some number of recallable objects, including layouts, to the metadata server.",
      "ja": "CB_RECALL_ANY（セクション20.6）は、メタデータサーバに、レイアウトを含め、リコール対象物のいくつかの数を返す必要があるクライアントに指示します。"
    },
    {
      "indent": 3,
      "text": "CB_RECALLABLE_OBJ_AVAIL (Section 20.7) tells a client that a recallable object that it was denied (in case of pNFS, a layout denied by LAYOUTGET) due to resource exhaustion is now available.",
      "ja": "CB_RECALLABLE_OBJ_AVAIL（セクション20.7）が原因資源の枯渇へ（pNFSの、LAYOUTGETによって拒否されたレイアウトの場合）、それが拒否されたことをリコール対象は、現在利用可能であることをクライアントに伝えます。"
    },
    {
      "indent": 3,
      "text": "CB_NOTIFY_DEVICEID (Section 20.12) notifies the client of changes to device IDs.",
      "ja": "CB_NOTIFY_DEVICEID（セクション20.12）は、デバイスIDへの変更をクライアントに通知します。"
    },
    {
      "indent": 0,
      "text": "12.4. pNFS Attributes",
      "section_title": true,
      "ja": "12.4.  pNFSの属性"
    },
    {
      "indent": 3,
      "text": "A number of attributes specific to pNFS are listed and described in Section 5.12.",
      "ja": "pNFSの固有の属性の数が表示され、5.12節で説明されています。"
    },
    {
      "indent": 0,
      "text": "12.5. Layout Semantics",
      "section_title": true,
      "ja": "12.5. レイアウトセマンティクス"
    },
    {
      "indent": 0,
      "text": "12.5.1. Guarantees Provided by Layouts",
      "section_title": true,
      "ja": "12.5.1. 保証レイアウト提供"
    },
    {
      "indent": 3,
      "text": "Layouts grant to the client the ability to access data located at a storage device with the appropriate storage protocol. The client is guaranteed the layout will be recalled when one of two things occur: either a conflicting layout is requested or the state encapsulated by the layout becomes invalid (this can happen when an event directly or indirectly modifies the layout). When a layout is recalled and returned by the client, the client continues with the ability to access file data with normal NFSv4.1 operations through the metadata server. Only the ability to access the storage devices is affected.",
      "ja": "レイアウトは、クライアントに適切なストレージプロトコルと記憶装置に位置するデータにアクセスする能力を付与します。クライアントは、2つのうちの1つが発生したときにレイアウトが想起されることが保証されています。競合レイアウトのいずれかが要求されたり、レイアウトによってカプセル化された状態では（イベントが直接または間接的にレイアウトを変更したときにこの現象が発生することができます）は無効となります。レイアウトが呼び戻され、クライアントによって返されると、クライアントは、メタデータサーバを介して、通常のNFSv4.1操作でファイルデータにアクセスする能力を続行します。ストレージデバイスにアクセスするための唯一の能力が影響を受けています。"
    },
    {
      "indent": 3,
      "text": "The requirement of NFSv4.1 that all user access rights MUST be obtained through the appropriate OPEN, LOCK, and ACCESS operations is not modified with the existence of layouts. Layouts are provided to NFSv4.1 clients, and user access still follows the rules of the protocol as if they did not exist. It is a requirement that for a client to access a storage device, a layout must be held by the client. If a storage device receives an I/O request for a byte-range for which the client does not hold a layout, the storage device SHOULD reject that I/O request. Note that the act of modifying a file for which a layout is held does not necessarily conflict with the holding of the layout that describes the file being modified. Therefore, it is the requirement of the storage protocol or layout type that determines the necessary behavior. For example, block/ volume layout types require that the layout's iomode agree with the type of I/O being performed.",
      "ja": "すべてのユーザのアクセス権は、適切なOPEN、LOCK、およびACCESSオペレーションを通じて得なければならないNFSv4.1の要件は、レイアウトの存在で変性されていません。レイアウトはNFSv4.1のクライアントに提供されており、彼らは存在しなかったかのようにユーザのアクセスは、まだプロトコルのルールに従います。これは、ストレージデバイスにアクセスするためのクライアントのために、レイアウトは、クライアントによって保持されなければならない要件です。ストレージデバイスは、クライアントがレイアウトを保持しないためにバイト範囲のためのI / O要求を受信した場合、ストレージデバイスは、そのI / O要求を拒否すべきです。レイアウトが保持されているファイルを変更する動作は必ずしも変更されたファイルを記述するレイアウトの保持と矛盾しないことに留意されたいです。したがって、必要な行動を決定するストレージプロトコルまたはレイアウトタイプの要件です。例えば、ブロック/ボリュームレイアウトのタイプは、レイアウトのIOModeには、実行されているI / Oのタイプと一致している必要があります。"
    },
    {
      "indent": 3,
      "text": "Depending upon the layout type and storage protocol in use, storage device access permissions may be granted by LAYOUTGET and may be encoded within the type-specific layout. For an example of storage device access permissions, see an object-based protocol such as [50]. If access permissions are encoded within the layout, the metadata server SHOULD recall the layout when those permissions become invalid for any reason -- for example, when a file becomes unwritable or inaccessible to a client. Note, clients are still required to perform the appropriate OPEN, LOCK, and ACCESS operations as described above. The degree to which it is possible for the client to circumvent these operations and the consequences of doing so must be clearly specified by the individual layout type specifications. In addition, these specifications must be clear about the requirements and non-requirements for the checking performed by the server.",
      "ja": "使用中のレイアウトタイプとストレージ・プロトコルに応じて、記憶装置へのアクセス権限がLAYOUTGETによって付与することができ、型特異的レイアウト内符号化することができます。記憶装置アクセス許可の例については、例えば[50]のようなオブジェクトベースのプロトコルを参照してください。アクセス許可がレイアウト内で符号化されている場合は、メタデータサーバは、これらのアクセス許可が何らかの理由で無効になってレイアウトを思い出す必要があります - たとえば、ファイルがクライアントへの書き込み不可またはアクセス不能になった場合。音符、クライアントは依然として上記のように適切なOPEN、LOCK、及びアクセス動作を実行するために必要とされます。クライアントは、これらの操作とそうすることの影響を回避することが可能である度合いは明らかに個々のレイアウトタイプの仕様で指定する必要があります。また、これらの仕様は、サーバによって実行されるチェックのための要件と非要件について明確にする必要があります。"
    },
    {
      "indent": 3,
      "text": "In the presence of pNFS functionality, mandatory byte-range locks MUST behave as they would without pNFS. Therefore, if mandatory file locks and layouts are provided simultaneously, the storage device MUST be able to enforce the mandatory byte-range locks. For example, if one client obtains a mandatory byte-range lock and a second client accesses the storage device, the storage device MUST appropriately restrict I/O for the range of the mandatory byte-range lock. If the storage device is incapable of providing this check in the presence of mandatory byte-range locks, then the metadata server MUST NOT grant layouts and mandatory byte-range locks simultaneously.",
      "ja": "pNFSの機能の存在下で、必須バイト範囲ロックは、彼らがpNFSのなしで同じように動作しなければなりません。必須のファイルロックおよびレイアウトが同時に提供される場合従って、記憶装置は必須のバイト範囲ロックを強制することができなければなりません。あるクライアントは必須バイト範囲ロックを取得し、第2のクライアントがストレージデバイスにアクセスする場合、例えば、記憶装置が適切に必須のバイト範囲ロックの範囲のI / Oを制限しなければなりません。ストレージデバイスは必須バイト範囲ロックの存在下で、このチェックを提供することができない場合には、メタデータサーバは、同時にレイアウトや必須バイト範囲ロックを付与してはなりません。"
    },
    {
      "indent": 0,
      "text": "12.5.2. Getting a Layout",
      "section_title": true,
      "ja": "12.5.2. レイアウトを取得"
    },
    {
      "indent": 3,
      "text": "A client obtains a layout with the LAYOUTGET operation. The metadata server will grant layouts of a particular type (e.g., block/volume, object, or file). The client selects an appropriate layout type that the server supports and the client is prepared to use. The layout returned to the client might not exactly match the requested byte-range as described in Section 18.43.3. As needed a client may send multiple LAYOUTGET operations; these might result in multiple overlapping, non-conflicting layouts (see Section 12.2.8).",
      "ja": "クライアントはLAYOUTGET操作でレイアウトを取得します。メタデータサーバは、特定のタイプ（例えば、ブロック/体積、オブジェクト、又はファイル）のレイアウトを許可します。クライアントは、サーバーがサポートする適切なレイアウトの種類を選択して、クライアントが使用する用意があります。セクション18.43.3で説明したように、クライアントに返されたレイアウトは、正確に要求されたバイト範囲と一致しない場合があります。必要に応じてクライアントは、複数のLAYOUTGETオペレーションを送ることができ;これらは、複数の重複、競合しないレイアウト（セクション12.2.8を参照）になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "In order to get a layout, the client must first have opened the file via the OPEN operation. When a client has no layout on a file, it MUST present an open stateid, a delegation stateid, or a byte-range lock stateid in the loga_stateid argument. A successful LAYOUTGET result includes a layout stateid. The first successful LAYOUTGET processed by the server using a non-layout stateid as an argument MUST have the \"seqid\" field of the layout stateid in the response set to one. Thereafter, the client MUST use a layout stateid (see Section 12.5.3) on future invocations of LAYOUTGET on the file, and the \"seqid\" MUST NOT be set to zero. Once the layout has been retrieved, it can be held across multiple OPEN and CLOSE sequences. Therefore, a client may hold a layout for a file that is not currently open by any user on the client. This allows for the caching of layouts beyond CLOSE.",
      "ja": "レイアウトを得るために、クライアントは、最初にOPEN操作を経由してファイルを開いている必要があります。クライアントは、ファイルには何のレイアウトを持っていない場合は、loga_stateid引数にオープンのstateid、委譲のstateid、またはバイト範囲ロックのstateidを提示しなければなりません。成功LAYOUTGET結果は、レイアウトのstateidを含んでいます。引数として非レイアウトのstateidを使用して、サーバーによって処理最初に成功したLAYOUTGETは1に設定応じてレイアウトのstateidの「SEQID」フィールドを持たなければなりません。その後、レイアウトのstateidを使用しなければならないクライアントは、ファイル上のLAYOUTGETの将来の呼び出しに（項12.5.3を参照）、および「SEQIDは」ゼロに設定することはできません。レイアウトが取り出された後、それは複数の開閉シーケンスを横切って保持することができます。そのため、クライアントは現在、クライアント上の任意のユーザーによって開かれていないファイルのレイアウトを保持することができます。これは、CLOSEを超えたレイアウトのキャッシングが可能になります。"
    },
    {
      "indent": 3,
      "text": "The storage protocol used by the client to access the data on the storage device is determined by the layout's type. The client is responsible for matching the layout type with an available method to interpret and use the layout. The method for this layout type selection is outside the scope of the pNFS functionality.",
      "ja": "ストレージデバイス上のデータにアクセスするためにクライアントによって使用されるストレージ・プロトコルは、レイアウトの種類によって決定されます。クライアントが解釈し、レイアウトを使用するために利用可能な方法でレイアウトタイプを照合する責任があります。このレイアウトタイプの選択方法は、pNFSの機能の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Although the metadata server is in control of the layout for a file, the pNFS client can provide hints to the server when a file is opened or created about the preferred layout type and aggregation schemes. pNFS introduces a layout_hint attribute (Section 5.12.4) that the client can set at file creation time to provide a hint to the server for new files. Setting this attribute separately, after the file has been created might make it difficult, or impossible, for the server implementation to comply.",
      "ja": "メタデータサーバは、ファイルのレイアウトを制御しているが、ファイルを開くか、優先レイアウトタイプと集約スキームについて作成されたときに、pNFSのクライアントは、サーバーにヒントを提供することができます。 pNFSのは、クライアントが新規ファイルのサーバへのヒントを提供するために、ファイル作成時に設定できることをlayout_hint属性（セクション5.12.4）を紹介します。ファイルが作成された後、個別にこの属性を設定することは、困難、または不可能サーバの実装が準拠するために作るかもしれません。"
    },
    {
      "indent": 3,
      "text": "Because the EXCLUSIVE4 createmode4 does not allow the setting of attributes at file creation time, NFSv4.1 introduces the EXCLUSIVE4_1 createmode4, which does allow attributes to be set at file creation time. In addition, if the session is created with persistent reply caches, EXCLUSIVE4_1 is neither necessary nor allowed. Instead, GUARDED4 both works better and is prescribed. Table 10 in Section 18.16.3 summarizes how a client is allowed to send an exclusive create.",
      "ja": "EXCLUSIVE4 createmode4は、ファイル作成時の属性の設定を許可しないので、NFSv4.1は、属性がファイル作成時に設定することはできないEXCLUSIVE4_1のcreatemode4を、紹介します。また、セッションが持続応答キャッシュを使用して作成されている場合、EXCLUSIVE4_1は必要でも許可でもありません。その代わり、GUARDED4は良い作品と規定されている両方。セクション18.16.3表10は、クライアントが排他的に作成、送信することが許可されている方法をまとめたものです。"
    },
    {
      "indent": 0,
      "text": "12.5.3. Layout Stateid",
      "section_title": true,
      "ja": "12.5.3. レイアウトのstateid"
    },
    {
      "indent": 3,
      "text": "As with all other stateids, the layout stateid consists of a \"seqid\" and \"other\" field. Once a layout stateid is established, the \"other\" field will stay constant unless the stateid is revoked or the client returns all layouts on the file and the server disposes of the stateid. The \"seqid\" field is initially set to one, and is never zero on any NFSv4.1 operation that uses layout stateids, whether it is a fore channel or backchannel operation. After the layout stateid is established, the server increments by one the value of the \"seqid\" in each subsequent LAYOUTGET and LAYOUTRETURN response, and in each CB_LAYOUTRECALL request.",
      "ja": "他のすべてのstateidsと同じように、レイアウトのstateidは「SEQID」と「その他」のフィールドで構成されています。レイアウトのstateidが確立されるとのstateidが取り消さまたはクライアントがファイル上のすべてのレイアウトとのstateidのサーバー処分を返すされていない限り、「その他」の欄には、一定のままになります。 「SEQID」フィールドは、最初は1に設定され、それが前部チャネルまたはバックチャネル操作であるか否か、レイアウトのstateidsを使用するすべてのNFSv4.1操作上のゼロされることはありません。レイアウトのstateid後、後続の各LAYOUTGETとLAYOUTRETURN応じて、各CB_LAYOUTRECALL要求における「SEQID」の値によって、サーバ増分を確立しています。"
    },
    {
      "indent": 3,
      "text": "Given the design goal of pNFS to provide parallelism, the layout stateid differs from other stateid types in that the client is expected to send LAYOUTGET and LAYOUTRETURN operations in parallel. The \"seqid\" value is used by the client to properly sort responses to LAYOUTGET and LAYOUTRETURN. The \"seqid\" is also used to prevent race conditions between LAYOUTGET and CB_LAYOUTRECALL. Given that the processing rules differ from layout stateids and other stateid types, only the pNFS sections of this document should be considered to determine proper layout stateid handling.",
      "ja": "並列処理を提供するのpNFSの設計目標を考えると、レイアウトのstateidは、クライアントが並列にLAYOUTGETとLAYOUTRETURN操作を送信するために期待されているという点で他のstateidの種類は異なります。 「SEQID」の値が正しくLAYOUTGETとLAYOUTRETURNに対する応答をソートするために、クライアントによって使用されます。 「SEQID」もLAYOUTGETとCB_LAYOUTRECALL間の競合状態を防ぐために使用されます。処理ルールは、レイアウトのstateidsおよび他のstateidタイプ異なることを考えると、この文書の唯一pNFSのセクションでは、適切なレイアウトのstateidの取り扱いを決定するために考慮されるべきです。"
    },
    {
      "indent": 3,
      "text": "Once the client receives a layout stateid, it MUST use the correct \"seqid\" for subsequent LAYOUTGET or LAYOUTRETURN operations. The correct \"seqid\" is defined as the highest \"seqid\" value from responses of fully processed LAYOUTGET or LAYOUTRETURN operations or arguments of a fully processed CB_LAYOUTRECALL operation. Since the server is incrementing the \"seqid\" value on each layout operation, the client may determine the order of operation processing by inspecting the \"seqid\" value. In the case of overlapping layout ranges, the ordering information will provide the client the knowledge of which layout ranges are held. Note that overlapping layout ranges may occur because of the client's specific requests or because the server is allowed to expand the range of a requested layout and notify the client in the LAYOUTRETURN results. Additional layout stateid sequencing requirements are provided in Section 12.5.5.2.",
      "ja": "クライアントは、レイアウトのstateidを受信すると、それ以降のLAYOUTGETまたはLAYOUTRETURN操作のための正しい「SEQID」を使用しなければなりません。正しい「SEQID」が完全に処理LAYOUTGET又はLAYOUTRETURN操作または完全に処理CB_LAYOUTRECALL操作の引数の応答から最高「SEQID」値として定義されます。サーバは、各レイアウト操作の「SEQID」の値をインクリメントしているので、クライアントは「SEQID」値を検査することにより、演算処理の順序を決定してもよいです。レイアウト範囲が重複する場合は、注文情報はクライアントにレイアウト範囲が開催されるの知識を提供します。サーバは要求されたレイアウトの範囲を拡大し、LAYOUTRETURN結果にクライアントに通知するために許可されているので、重複したレイアウトの範囲があるため、クライアントの特定の要求の発生または可能性があります。追加のレイアウトのstateidのシーケンス要件は、セクション12.5.5.2で提供されています。"
    },
    {
      "indent": 3,
      "text": "The client's receipt of a \"seqid\" is not sufficient for subsequent use. The client must fully process the operations before the \"seqid\" can be used. For LAYOUTGET results, if the client is not using the forgetful model (Section 12.5.5.1), it MUST first update its record of what ranges of the file's layout it has before using the seqid. For LAYOUTRETURN results, the client MUST delete the range from its record of what ranges of the file's layout it had before using the seqid. For CB_LAYOUTRECALL arguments, the client MUST send a response to the recall before using the seqid. The fundamental requirement in client processing is that the \"seqid\" is used to provide the order of processing. LAYOUTGET results may be processed in parallel. LAYOUTRETURN results may be processed in parallel. LAYOUTGET and LAYOUTRETURN responses may be processed in parallel as long as the ranges do not overlap. CB_LAYOUTRECALL request processing MUST be processed in \"seqid\" order at all times.",
      "ja": "「SEQID」のクライアントの領収書は、その後の使用のために十分ではありません。 「SEQID」を使用することができます前に、クライアントは完全に業務を処理しなければなりません。クライアントは忘れっぽいモデル（セクション12.5.5.1）を使用していない場合はLAYOUTGETの結果を得るために、それは最初にそれがSEQIDを使用する前に、持っているもの、ファイルのレイアウトの範囲のその記録を更新する必要があります。 LAYOUTRETURNの結果を得るために、クライアントは、それがSEQIDを使用する前に持っていたファイルのレイアウトのどの範囲のそのレコードから範囲を削除しなければなりません。 CB_LAYOUTRECALL引数の場合、クライアントはSEQIDを使用する前に、リコールへの応答を送らなければなりません。クライアント処理における基本的な要件は、「SEQIDは」処理の順序を提供するために使用されていることです。 LAYOUTGET結果を並列に処理することができます。 LAYOUTRETURN結果を並列に処理することができます。 LAYOUTGETとLAYOUTRETURN応答は限り範囲が重ならないように並列に処理することができます。 CB_LAYOUTRECALL要求処理は、すべての回で「SEQID」の順序で処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once a client has no more layouts on a file, the layout stateid is no longer valid and MUST NOT be used. Any attempt to use such a layout stateid will result in NFS4ERR_BAD_STATEID.",
      "ja": "クライアントがファイルにはより多くのレイアウトを持っていないならば、レイアウトのstateidは、もはや有効ではないため、使用しないでください。そのようなレイアウトのstateidを使用しようとすると、NFS4ERR_BAD_STATEIDになります。"
    },
    {
      "indent": 0,
      "text": "12.5.4. Committing a Layout",
      "section_title": true,
      "ja": "12.5.4. レイアウトのコミット"
    },
    {
      "indent": 3,
      "text": "Allowing for varying storage protocol capabilities, the pNFS protocol does not require the metadata server and storage devices to have a consistent view of file attributes and data location mappings. Data location mapping refers to aspects such as which offsets store data as opposed to storing holes (see Section 13.4.4 for a discussion). Related issues arise for storage protocols where a layout may hold provisionally allocated blocks where the allocation of those blocks does not survive a complete restart of both the client and server.",
      "ja": "ストレージプロトコル能力を変化させることができ、pNFSのプロトコルは、ファイル属性とデータの場所のマッピングの一貫性のあるビューを持つように、メタデータ・サーバとストレージデバイスを必要としません。データロケーションマッピングが収納孔（議論のために、セクション13.4.4を参照）とは対照的に、ストアデータを相殺するようなどのような側面を指します。関連する問題は、レイアウトはこれらのブロックの割り当ては、クライアントとサーバーの両方の完全な再起動を存続しない仮に割り当てられたブロックを保持することができるストレージプロトコルのために発生します。"
    },
    {
      "indent": 3,
      "text": "Because of this inconsistency, it is necessary to resynchronize the client with the metadata server and its storage devices and make any potential changes available to other clients. This is accomplished by use of the LAYOUTCOMMIT operation.",
      "ja": "このため矛盾するのではなく、メタデータ・サーバとそのストレージデバイスとクライアントを再同期して他のクライアントへの潜在的な変化を利用可能にする必要があります。これはLAYOUTCOMMIT操作を使用することによって達成されます。"
    },
    {
      "indent": 3,
      "text": "The LAYOUTCOMMIT operation is responsible for committing a modified layout to the metadata server. The data should be written and committed to the appropriate storage devices before the LAYOUTCOMMIT occurs. The scope of the LAYOUTCOMMIT operation depends on the storage protocol in use. It is important to note that the level of synchronization is from the point of view of the client that sent the LAYOUTCOMMIT. The updated state on the metadata server need only reflect the state as of the client's last operation previous to the LAYOUTCOMMIT. The metadata server is not REQUIRED to maintain a global view that accounts for other clients' I/O that may have occurred within the same time frame.",
      "ja": "LAYOUTCOMMIT操作は、メタデータサーバに変更されたレイアウトをコミットする責任があります。 LAYOUTCOMMITが発生する前にデータが書き込まれると、適切なストレージデバイスにコミットする必要があります。 LAYOUTCOMMIT動作の範囲は、使用中のストレージプロトコルに依存します。同期のレベルがLAYOUTCOMMITを送信したクライアントの観点からのものであることに注意することが重要です。メタデータ・サーバ上の更新された状態では唯一LAYOUTCOMMITに以前のクライアントの最後の操作のような状態を反映する必要が。メタデータサーバは、同じ時間枠内で発生した可能性があり、他のクライアントのI / Oを占めているグローバルな視点を維持するために必要とされていません。"
    },
    {
      "indent": 3,
      "text": "For block/volume-based layouts, LAYOUTCOMMIT may require updating the block list that comprises the file and committing this layout to stable storage. For file-based layouts, synchronization of attributes between the metadata and storage devices, primarily the size attribute, is required.",
      "ja": "ブロック/体積ベースのレイアウトのために、LAYOUTCOMMITファイルを含むブロックのリストを更新し、安定したストレージにこのレイアウトをコミット必要とするかもしれません。ファイルベースのレイアウト、メタデータとストレージデバイス間の属性の同期、主にサイズ属性のために、必要です。"
    },
    {
      "indent": 3,
      "text": "The control protocol is free to synchronize the attributes before it receives a LAYOUTCOMMIT; however, upon successful completion of a LAYOUTCOMMIT, state that exists on the metadata server that describes the file MUST be synchronized with the state that exists on the storage devices that comprise that file as of the client's last sent operation. Thus, a client that queries the size of a file between a WRITE to a storage device and the LAYOUTCOMMIT might observe a size that does not reflect the actual data written.",
      "ja": "制御プロトコルは、それがLAYOUTCOMMITを受信する前に属性を同期して自由です。しかし、LAYOUTCOMMITが正常に完了すると、ファイルを記述するメタデータサーバ上に存在する状態は、クライアントの最後に送られた操作のように、そのファイルを構成するストレージデバイス上に存在する状態と同期する必要があります。このように、ストレージデバイスとLAYOUTCOMMITにWRITEの間でファイルのサイズを照会クライアントが書かれた実際のデータを反映していないサイズを観察することがあります。"
    },
    {
      "indent": 3,
      "text": "The client MUST have a layout in order to send a LAYOUTCOMMIT operation.",
      "ja": "クライアントはLAYOUTCOMMIT操作を送信するために、レイアウトを持たなければなりません。"
    },
    {
      "indent": 0,
      "text": "12.5.4.1. LAYOUTCOMMIT and change/time_modify",
      "section_title": true,
      "ja": "12.5.4.1。 LAYOUTCOMMITおよび変更/ time_modify"
    },
    {
      "indent": 3,
      "text": "The change and time_modify attributes may be updated by the server when the LAYOUTCOMMIT operation is processed. The reason for this is that some layout types do not support the update of these attributes when the storage devices process I/O operations. If a client has a layout with the LAYOUTIOMODE4_RW iomode on the file, the client MAY provide a suggested value to the server for time_modify within the arguments to LAYOUTCOMMIT. Based on the layout type, the provided value may or may not be used. The server should sanity-check the client-provided values before they are used. For example, the server should ensure that time does not flow backwards. The client always has the option to set time_modify through an explicit SETATTR operation.",
      "ja": "LAYOUTCOMMIT操作が処理されるときに変更とtime_modify属性は、サーバーによって更新することができます。この理由は、いくつかのレイアウトタイプは、これらの属性のストレージデバイス・プロセスがI / O操作の更新をサポートしていないということです。クライアントがファイルにLAYOUTIOMODE4_RWのIOModeにしてレイアウトされている場合、クライアントはLAYOUTCOMMITの引数内time_modifyのためのサーバに推奨値を提供することができます。レイアウトタイプに基づいて、与えられた値を用いても用いなくてもよいです。サーバは、健全性を確認する必要があり、それらを使用する前に、クライアントが提供する値を。例えば、サーバは、その時は逆方向に流れないようにする必要があります。クライアントは、常に明示的なSETATTR操作によってtime_modify設定するオプションがあります。"
    },
    {
      "indent": 3,
      "text": "For some layout protocols, the storage device is able to notify the metadata server of the occurrence of an I/O; as a result, the change and time_modify attributes may be updated at the metadata server. For a metadata server that is capable of monitoring updates to the change and time_modify attributes, LAYOUTCOMMIT processing is not required to update the change attribute. In this case, the metadata server must ensure that no further update to the data has occurred since the last update of the attributes; file-based protocols may have enough information to make this determination or may update the change attribute upon each file modification. This also applies for the time_modify attribute. If the server implementation is able to determine that the file has not been modified since the last time_modify update, the server need not update time_modify at LAYOUTCOMMIT. At LAYOUTCOMMIT completion, the updated attributes should be visible if that file was modified since the latest previous LAYOUTCOMMIT or LAYOUTGET.",
      "ja": "いくつかのレイアウト・プロトコルのため、記憶装置は、I / Oが発生したメタデータサーバに通知することができます。結果として、変化とtime_modify属性は、メタデータサーバで更新することができます。変化とtime_modify属性への更新を監視することが可能であるメタデータ・サーバの場合は、LAYOUTCOMMIT処理が変化属性を更新する必要はありません。この場合、メタデータサーバは、データへの更なる更新は、属性の最後の更新以降に発生していないことを確認する必要があります。ファイルベースのプロトコルは、この決意をするのに十分な情報を有していてもよく、または各ファイルの変更時に変更属性を更新することができます。また、これはtime_modify属性に適用されます。サーバの実装は、ファイルが最後time_modifyの更新以降に変更されていないことを決定することができる場合は、サーバがLAYOUTCOMMITでtime_modifyを更新する必要はありません。そのファイルが最新の以前のLAYOUTCOMMITまたはLAYOUTGET以降に変更された場合LAYOUTCOMMITの終了時に、更新された属性が表示されるはずです。"
    },
    {
      "indent": 0,
      "text": "12.5.4.2. LAYOUTCOMMIT and size",
      "section_title": true,
      "ja": "12.5.4.2。 LAYOUTCOMMITとサイズ"
    },
    {
      "indent": 3,
      "text": "The size of a file may be updated when the LAYOUTCOMMIT operation is used by the client. One of the fields in the argument to LAYOUTCOMMIT is loca_last_write_offset; this field indicates the highest byte offset written but not yet committed with the LAYOUTCOMMIT operation. The data type of loca_last_write_offset is newoffset4 and is switched on a boolean value, no_newoffset, that indicates if a previous write occurred or not. If no_newoffset is FALSE, an offset is not given. If the client has a layout with LAYOUTIOMODE4_RW iomode on the file, with a byte-range (denoted by the values of lo_offset and lo_length) that overlaps loca_last_write_offset, then the client MAY set no_newoffset to TRUE and provide an offset that will update the file size. Keep in mind that offset is not the same as length, though they are related. For example, a loca_last_write_offset value of zero means that one byte was written at offset zero, and so the length of the file is at least one byte.",
      "ja": "LAYOUTCOMMIT操作がクライアントによって使用されているときに、ファイルのサイズを更新することができます。 LAYOUTCOMMITへの引数のフィールドの一つはloca_last_write_offsetです。このフィールドは、最上位バイト書かれたオフセットが、まだLAYOUTCOMMIT操作をコミットしていないことを示します。 loca_last_write_offsetのデータ・タイプはnewoffset4であり、前の書き込みが発生したかどうかを示すブール値、no_newoffset、スイッチオンされます。 no_newoffsetがFALSEの場合、オフセットは与えられていません。クライアントはloca_last_write_offsetに重なる（lo_offsetとlo_lengthの値によって示される）バイトレンジを持つファイルにLAYOUTIOMODE4_RWのIOModeに有するレイアウトを有する場合、クライアントはTRUEにno_newoffset設定ファイルサイズを更新し、そのオフセット提供MAY 。それらが関連しているものの、長さと同じではありませんオフセットを覚えておいてください。例えば、ゼロのloca_last_write_offset値は1つのバイトオフセットゼロで書かれた、およびので、ファイルの長さは、少なくとも1バイトであることを意味します。"
    },
    {
      "indent": 3,
      "text": "The metadata server may do one of the following:",
      "ja": "メタデータサーバは、次のいずれかを行うことができます。"
    },
    {
      "indent": 3,
      "text": "1. Update the file's size using the last write offset provided by the client as either the true file size or as a hint of the file size. If the metadata server has a method available, any new value for file size should be sanity-checked. For example, the file must not be truncated if the client presents a last write offset less than the file's current size.",
      "ja": "1.いずれかの実際のファイルサイズとして、またはファイルサイズのヒントとして、クライアントが提供する最後の書き込みオフセットを使用してファイルのサイズを更新します。メタデータサーバが利用できるメソッドを持っている場合は、ファイルサイズのための新たな値は、健全性チェックする必要があります。クライアントは最後の書き込みがファイルの現在のサイズよりも小さいオフセット提示した場合たとえば、ファイルが切り捨てられてはいけません。"
    },
    {
      "indent": 3,
      "text": "2. Ignore the client-provided last write offset; the metadata server must have sufficient knowledge from other sources to determine the file's size. For example, the metadata server queries the storage devices with the control protocol.",
      "ja": "2.オフセットクライアントが提供する最後の書き込みは無視してください。メタデータサーバは、ファイルのサイズを決定するために、他のソースからの十分な知識を持っている必要があります。例えば、メタデータサーバは、制御プロトコルのストレージデバイスに問い合わせます。"
    },
    {
      "indent": 3,
      "text": "The method chosen to update the file's size will depend on the storage device's and/or the control protocol's capabilities. For example, if the storage devices are block devices with no knowledge of file size, the metadata server must rely on the client to set the last write offset appropriately.",
      "ja": "ファイルのサイズを更新するために、選択された方法は、記憶デバイスのおよび/または制御プロトコルの能力に依存します。ストレージデバイスは、ファイルサイズの無い知識を持つブロックデバイスであれば、例えば、メタデータサーバが適切にオフセット最後の書き込みを設定するために、クライアントに依存しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The results of LAYOUTCOMMIT contain a new size value in the form of a newsize4 union data type. If the file's size is set as a result of LAYOUTCOMMIT, the metadata server must reply with the new size; otherwise, the new size is not provided. If the file size is updated, the metadata server SHOULD update the storage devices such that the new file size is reflected when LAYOUTCOMMIT processing is complete. For example, the client should be able to read up to the new file size.",
      "ja": "LAYOUTCOMMITの結果はnewsize4組合データ型の形式で新しいサイズの値が含まれています。ファイルのサイズがLAYOUTCOMMITの結果として設定されている場合は、メタデータサーバは、新しいサイズで応答しなければなりません。そうでない場合は、新しいサイズが用意されていません。ファイルサイズが更新されると、メタデータサーバは、LAYOUTCOMMIT処理が完了すると、新しいファイルサイズが反映されるようなストレージデバイスを更新する必要があります。例えば、クライアントは、新しいファイルのサイズまで読むことができるはずです。"
    },
    {
      "indent": 3,
      "text": "The client can extend the length of a file or truncate a file by sending a SETATTR operation to the metadata server with the size attribute specified. If the size specified is larger than the current size of the file, the file is \"zero extended\", i.e., zeros are implicitly added between the file's previous EOF and the new EOF. (In many implementations, the zero-extended byte-range of the file consists of unallocated holes in the file.) When the client writes past EOF via WRITE, the SETATTR operation does not need to be used.",
      "ja": "クライアントは、ファイルの長さを延長するか、指定したサイズの属性を持つメタデータサーバにSETATTR操作を送信することで、ファイルを切り捨てることができます。指定されたサイズは、ファイルの現在のサイズよりも大きい場合、ファイルは「ゼロ拡張」である、すなわち、ゼロが暗黙的にファイルの以前のEOFと新しいEOFの間に追加されます。 （多くの実装では、ファイルのゼロ拡張バイト範囲は、ファイル内の割り当てられていない穴で構成されている。）クライアントがWRITE介しEOFを越えて書き込むとき、SETATTR操作が使用される必要はありません。"
    },
    {
      "indent": 0,
      "text": "12.5.4.3. LAYOUTCOMMIT and layoutupdate",
      "section_title": true,
      "ja": "12.5.4.3。 LAYOUTCOMMITとlayoutupdate"
    },
    {
      "indent": 3,
      "text": "The LAYOUTCOMMIT argument contains a loca_layoutupdate field (Section 18.42.1) of data type layoutupdate4 (Section 3.3.18). This argument is a layout-type-specific structure. The structure can be used to pass arbitrary layout-type-specific information from the client to the metadata server at LAYOUTCOMMIT time. For example, if using a block/volume layout, the client can indicate to the metadata server which reserved or allocated blocks the client used or did not use. The content of loca_layoutupdate (field lou_body) need not be the same layout-type-specific content returned by LAYOUTGET (Section 18.43.2) in the loc_body field of the lo_content field of the logr_layout field. The content of loca_layoutupdate is defined by the layout type specification and is opaque to LAYOUTCOMMIT.",
      "ja": "LAYOUTCOMMIT引数は、データ・タイプlayoutupdate4（セクション3.3.18）のloca_layoutupdateフィールド（セクション18.42.1）が含まれています。この引数は、レイアウト・タイプ固有の構造です。構造はLAYOUTCOMMIT時にメタデータサーバにクライアントから任意のレイアウト・タイプ固有の情報を渡すために使用することができます。例えば、ブロック/ボリュームレイアウトを使用している場合、クライアントは、クライアントが使用されるか、または使用していないブロックを予約または割り当てられたメタデータサーバに指示することができます。 loca_layoutupdate（フィールドlou_body）の含有量がlogr_layoutフィールドのlo_contentフィールドのloc_body分野でLAYOUTGET（セクション18.43.2）によって返された同じレイアウト・タイプ固有のコンテンツである必要はありません。 loca_layoutupdateのコンテンツは、レイアウトタイプ仕様によって定義され、LAYOUTCOMMITに対して不透明です。"
    },
    {
      "indent": 0,
      "text": "12.5.5. Recalling a Layout",
      "section_title": true,
      "ja": "12.5.5. レイアウトを想起"
    },
    {
      "indent": 3,
      "text": "Since a layout protects a client's access to a file via a direct client-storage-device path, a layout need only be recalled when it is semantically unable to serve this function. Typically, this occurs when the layout no longer encapsulates the true location of the file over the byte-range it represents. Any operation or action, such as server-driven restriping or load balancing, that changes the layout will result in a recall of the layout. A layout is recalled by the CB_LAYOUTRECALL callback operation (see Section 20.3) and returned with LAYOUTRETURN (see Section 18.44). The CB_LAYOUTRECALL operation may recall a layout identified by a byte-range, all layouts associated with a file system ID (FSID), or all layouts associated with a client ID. Section 12.5.5.2 discusses sequencing issues surrounding the getting, returning, and recalling of layouts.",
      "ja": "レイアウトは、直接クライアント・ストレージ・デバイス・パスを経由してファイルへのクライアントのアクセスを保護しているので、この機能を果たすことが、意味的にできない場合、レイアウトが唯一のリコールされる必要があります。レイアウトは、もはやそれが表すバイト範囲にわたってファイルの真の位置をカプセル化する際に、典型的に、これは発生しません。レイアウトを変更するようなサーバ主導のストライピングや負荷分散などの任意の操作や動作は、レイアウトのリコールになります。レイアウトはCB_LAYOUTRECALLコールバック操作によってリコール（セクション20.3を参照）、LAYOUTRETURN（セクション18.44を参照）で返されます。 CB_LAYOUTRECALL動作はバイト範囲によって同定レイアウト、ファイルシステムID（FSID）、またはクライアントIDに関連付けられたすべてのレイアウトに関連付けられたすべてのレイアウトをリコールすることができます。セクション12.5.5.2は、レイアウトの取得、返却、およびリコールを取り巻くシーケンスの問題について説明します。"
    },
    {
      "indent": 3,
      "text": "An iomode is also specified when recalling a layout. Generally, the iomode in the recall request must match the layout being returned; for example, a recall with an iomode of LAYOUTIOMODE4_RW should cause the client to only return LAYOUTIOMODE4_RW layouts and not LAYOUTIOMODE4_READ layouts. However, a special LAYOUTIOMODE4_ANY enumeration is defined to enable recalling a layout of any iomode; in other words, the client must return both LAYOUTIOMODE4_READ and LAYOUTIOMODE4_RW layouts.",
      "ja": "レイアウトをリコールするときIOModeにも指定されています。一般的に、リコール要求でIOModeには、返されるレイアウトと一致する必要があります。例えば、LAYOUTIOMODE4_RWのIOModeにとのリコールはLAYOUTIOMODE4_RWレイアウトとLAYOUTIOMODE4_READないレイアウトを返すようにクライアントを起こす必要があります。しかし、特別なLAYOUTIOMODE4_ANY列挙は、任意IOModeにレイアウトを想起可能にするために定義されています。言い換えれば、クライアントはLAYOUTIOMODE4_READとLAYOUTIOMODE4_RW両方のレイアウトを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "A REMOVE operation SHOULD cause the metadata server to recall the layout to prevent the client from accessing a non-existent file and to reclaim state stored on the client. Since a REMOVE may be delayed until the last close of the file has occurred, the recall may also be delayed until this time. After the last reference on the file has been released and the file has been removed, the client should no longer be able to perform I/O using the layout. In the case of a file-based layout, the data server SHOULD return NFS4ERR_STALE in response to any operation on the removed file.",
      "ja": "REMOVE操作は、メタデータサーバが存在しないファイルにアクセスしてからクライアントを防ぐために、クライアントに保存されている状態を取り戻すために、レイアウトをリコールするようになります。ファイルの最後のクローズが発生するまでREMOVEが遅れる場合がありますので、リコールも、この時点まで遅延することができます。ファイルの最後の参照が解放されたと、ファイルが削除された後、クライアントはもはやレイアウトを使用してI / Oを実行することはできないはずです。ファイルベースのレイアウトの場合には、データ・サーバは、削除されたファイル上の任意の操作に応じてNFS4ERR_STALEを返すべきです。"
    },
    {
      "indent": 3,
      "text": "Once a layout has been returned, the client MUST NOT send I/Os to the storage devices for the file, byte-range, and iomode represented by the returned layout. If a client does send an I/O to a storage device for which it does not hold a layout, the storage device SHOULD reject the I/O.",
      "ja": "レイアウトが返された後、クライアントは、返されたレイアウトによって表されるファイル、バイト範囲、およびIOModeにするストレージデバイスへのI / Oを送ってはいけません。クライアントは、それがレイアウトを保持していないため、ストレージデバイスへのI / Oを送信した場合、ストレージデバイスは、I / Oを拒否すべきです。"
    },
    {
      "indent": 3,
      "text": "Although pNFS does not alter the file data caching capabilities of clients, or their semantics, it recognizes that some clients may perform more aggressive write-behind caching to optimize the benefits provided by pNFS. However, write-behind caching may negatively affect the latency in returning a layout in response to a CB_LAYOUTRECALL; this is similar to file delegations and the impact that file data caching has on DELEGRETURN. Client implementations",
      "ja": "pNFSのは、ファイル・データ・キャッシング・クライアントの機能、またはそのセマンティクスを変更しませんが、それはいくつかのクライアントはpNFSのが提供するメリットを最適化するために、より積極的なライトビハインドのキャッシングを行うことができることを認識しています。しかし、後書きキャッシング負CB_LAYOUTRECALLに応じてレイアウトを返す際の待ち時間に影響を与える可能性があります。これは代表団とファイルデータのキャッシングがDELEGRETURNに与える影響をファイルに似ています。クライアントの実装"
    },
    {
      "indent": 3,
      "text": "SHOULD limit the amount of unwritten data they have outstanding at any one time in order to prevent excessively long responses to CB_LAYOUTRECALL. Once a layout is recalled, a server MUST wait one lease period before taking further action. As soon as a lease period has passed, the server may choose to fence the client's access to the storage devices if the server perceives the client has taken too long to return a layout. However, just as in the case of data delegation and DELEGRETURN, the server may choose to wait, given that the client is showing forward progress on its way to returning the layout. This forward progress can take the form of successful interaction with the storage devices or of sub-portions of the layout being returned by the client. The server can also limit exposure to these problems by limiting the byte-ranges initially provided in the layouts and thus the amount of outstanding modified data.",
      "ja": "CB_LAYOUTRECALLに過度に長い応答を防止するために、任意の時点で、彼らが優れてい書き込まれていないデータの量を制限する必要があります。レイアウトがリコールされると、サーバーは、さらなる行動を取る前に1つのリース期間を待たなければなりません。サーバは、クライアントがレイアウトを返すために、あまりにも長い間とっている感じるかのようにすぐにリース期間が経過したとして、サーバーは、フェンスにストレージデバイスへのクライアントのアクセスを選択することができます。しかし、単にデータの代表団とDELEGRETURNの場合のように、サーバは、クライアントが前方にレイアウトを返すに向かう途中に進展を見せていることを考えると、待つことを選択することもできます。この前方進歩は、クライアントによって返されるストレージデバイスまたはレイアウトのサブ部分の成功した対話の形をとることができます。サーバはまた、このようにして、最初のレイアウトに設けられたバイト範囲と優れた変更されたデータの量を制限することによって、これらの問題への曝露を制限することができます。"
    },
    {
      "indent": 0,
      "text": "12.5.5.1. Layout Recall Callback Robustness",
      "section_title": true,
      "ja": "12.5.5.1。レイアウトリコールコールバックロバストネス"
    },
    {
      "indent": 3,
      "text": "It has been assumed thus far that pNFS client state (layout ranges and iomode) for a file exactly matches that of the pNFS server for that file. This assumption leads to the implication that any callback results in a LAYOUTRETURN or set of LAYOUTRETURNs that exactly match the range in the callback, since both client and server agree about the state being maintained. However, it can be useful if this assumption does not always hold. For example:",
      "ja": "ファイルのためのpNFSクライアントの状態（レイアウト範囲とIOModeには）まさにそのファイルに対してのpNFSサーバのそれと一致することを、これまで考えられてきました。この仮定は、クライアントとサーバーの両方が維持されている状態について同意するので、正確に、コールバックで範囲と一致LAYOUTRETURNsのセットLAYOUTRETURNにおける任意のコールバックの結果というか、暗示につながります。この仮定が必ずしも成り立たない場合しかし、それは便利です。例えば："
    },
    {
      "indent": 3,
      "text": "o If conflicts that require callbacks are very rare, and a server can use a multi-file callback to recover per-client resources (e.g., via an FSID recall or a multi-file recall within a single CB_COMPOUND), the result may be significantly less client-server pNFS traffic.",
      "ja": "コールバックを必要と競合が非常にまれであり、サーバは（FSIDリコールまたは単一CB_COMPOUND内の複数ファイルのリコールを経て、例えば）クライアントごとのリソースを回復するために、複数ファイルのコールバックを使用することができた場合は、O、結果は大きくなることがあり以下、クライアント - サーバのpNFSトラフィック。"
    },
    {
      "indent": 3,
      "text": "o It may be useful for servers to maintain information about what ranges are held by a client on a coarse-grained basis, leading to the server's layout ranges being beyond those actually held by the client. In the extreme, a server could manage conflicts on a per-file basis, only sending whole-file callbacks even though clients may request and be granted sub-file ranges.",
      "ja": "サーバーは、実際にクライアントが保持しているもの以外の範囲であること、サーバのレイアウトに至る範囲は粗粒基づいて、クライアントが保持しているかについての情報を維持するためのOそれは有用である可能性があります。極端な場合、サーバは、クライアントが要求することができるとサブファイルの範囲を付与されていても、全ファイルのコールバックを送信し、ファイル単位で競合を管理することができます。"
    },
    {
      "indent": 3,
      "text": "o It may be useful for clients to \"forget\" details about what layouts and ranges the client actually has, leading to the server's layout ranges being beyond those that the client \"thinks\" it has. As long as the client does not assume it has layouts that are beyond what the server has granted, this is a safe practice. When a client forgets what ranges and layouts it has, and it receives a CB_LAYOUTRECALL operation, the client MUST follow up with a LAYOUTRETURN for what the server recalled, or alternatively return the NFS4ERR_NOMATCHING_LAYOUT error if it has no layout to return in the recalled range.",
      "ja": "クライアントがどのようなレイアウトの詳細を「忘れる」と、クライアントはそれが持っている「と考えて」いるものを超えている範囲、サーバーのレイアウトにつながる、実際にクライアントの範囲があるためにのためにOそれは有用である可能性があります。限り、クライアントはサーバが付与されているものを超えているレイアウトを持っていると仮定していないとして、これは安全な方法です。クライアントは、それが持っているものの範囲やレイアウト忘れ、それはCB_LAYOUTRECALL操作を受信すると、クライアントは、サーバがリコール何のためにLAYOUTRETURNをフォローアップしなければならない、あるいはそれがリコール範囲で返すように何のレイアウトを持っていない場合はNFS4ERR_NOMATCHING_LAYOUTエラーを返します。"
    },
    {
      "indent": 3,
      "text": "o In order to avoid errors, it is vital that a client not assign itself layout permissions beyond what the server has granted, and that the server not forget layout permissions that have been granted. On the other hand, if a server believes that a client holds a layout that the client does not know about, it is useful for the client to cleanly indicate completion of the requested recall either by sending a LAYOUTRETURN operation for the entire requested range or by returning an NFS4ERR_NOMATCHING_LAYOUT error to the CB_LAYOUTRECALL.",
      "ja": "Oエラーを回避するためには、クライアントは、サーバが与えたものを超えて、それ自体にレイアウト権限を割り当てていないこと、およびサーバが付与されているレイアウトの権限を忘れないことが重要です。サーバは、クライアントが認識できないレイアウトを保持していると考えている場合、クライアントは、全要求された範囲のためかによってLAYOUTRETURN操作を送信することにより、いずれかの要求されたリコールの完了をきれいに指示する一方で、それは便利ですCB_LAYOUTRECALLにNFS4ERR_NOMATCHING_LAYOUTエラーを返します。"
    },
    {
      "indent": 3,
      "text": "Thus, in light of the above, it is useful for a server to be able to send callbacks for layout ranges it has not granted to a client, and for a client to return ranges it does not hold. A pNFS client MUST always return layouts that comprise the full range specified by the recall. Note, the full recalled layout range need not be returned as part of a single operation, but may be returned in portions. This allows the client to stage the flushing of dirty data and commits and returns of layouts. Also, it indicates to the metadata server that the client is making progress.",
      "ja": "サーバは、レイアウトのためのコールバックを送信できるようにするためにこのように、上記の光の中で、それが有用であることがクライアントに付与されておらず、クライアントのためにそれを保持していない範囲を返すために及びます。 pNFSのクライアントは、常にリコールで指定されたすべての範囲を含む、レイアウトを返さなければなりません。メモ、完全リコールレイアウトの範囲は、単一の操作の一部として返される必要はなく、部分に戻すことができます。これは、クライアントがダーティデータとコミットやレイアウトのリターンのフラッシュを上演することができます。また、それは、クライアントが進捗状況を作っているメタデータサーバに示します。"
    },
    {
      "indent": 3,
      "text": "When a layout is returned, the client MUST NOT have any outstanding I/O requests to the storage devices involved in the layout. Rephrasing, the client MUST NOT return the layout while it has outstanding I/O requests to the storage device.",
      "ja": "レイアウトが返されると、クライアントは、レイアウトに関わるストレージデバイスへの未処理のI / O要求を持ってはいけません。それは、ストレージデバイスへの未処理のI / O要求を持ちながら、言い換え、クライアントは、レイアウトを返してはなりません。"
    },
    {
      "indent": 3,
      "text": "Even with this requirement for the client, it is possible that I/O requests may be presented to a storage device no longer allowed to perform them. Since the server has no strict control as to when the client will return the layout, the server may later decide to unilaterally revoke the client's access to the storage devices as provided by the layout. In choosing to revoke access, the server must deal with the possibility of lingering I/O requests, i.e., I/O requests that are still in flight to storage devices identified by the revoked layout. All layout type specifications MUST define whether unilateral layout revocation by the metadata server is supported; if it is, the specification must also describe how lingering writes are processed. For example, storage devices identified by the revoked layout could be fenced off from the client that held the layout.",
      "ja": "でも、クライアントのためのこの要件には、I / O要求がもはやそれらを実行するために許可されるストレージデバイスに提示される可能性があります。サーバは、クライアントがレイアウトを返しますがある場合の厳密なコントロールを持っていないので、サーバーは、後でレイアウトによって提供されるように一方的にストレージデバイスへのクライアントのアクセスを取り消すことを決定することができます。アクセスを取り消すことを選択して、サーバは、取り消されたレイアウトで識別されるストレージデバイスへの飛行中に残っている、すなわち、I / O要求をI / O要求を長引く可能性に対処しなければなりません。すべてのレイアウトタイプの仕様は、メタデータサーバによる一方的なレイアウトの失効がサポートされているかどうかを定義しなければなりません。それがある場合、仕様では、長引く書き込みがどのように処理されるかを記述しなければなりません。例えば、失効レイアウトによって識別されるストレージデバイスは、レイアウトを保持クライアントから柵することができます。"
    },
    {
      "indent": 3,
      "text": "In order to ensure client/server convergence with regard to layout state, the final LAYOUTRETURN operation in a sequence of LAYOUTRETURN operations for a particular recall MUST specify the entire range being recalled, echoing the recalled layout type, iomode, recall/ return type (FILE, FSID, or ALL), and byte-range, even if layouts pertaining to partial ranges were previously returned. In addition, if the client holds no layouts that overlap the range being recalled, the client should return the NFS4ERR_NOMATCHING_LAYOUT error code to CB_LAYOUTRECALL. This allows the server to update its view of the client's layout state.",
      "ja": "レイアウトの状態に関連してクラ​​イアント/サーバ収束を確保するために、特定のリコールのためLAYOUTRETURN動作のシーケンスの最後LAYOUTRETURN動作がリコールレイアウトタイプ、IOModeに、リコール/戻り型（FILEをエコー、リコールされる全範囲を指定しなければなりません、FSID、またはALL）、およびバイト範囲、部分的範囲に属するレイアウトは以前に返された場合でも。クライアントがリコールされる範囲と重ならないレイアウトを保持していない場合に加えて、クライアントはCB_LAYOUTRECALLにNFS4ERR_NOMATCHING_LAYOUTエラーコードを返すべきです。これは、サーバーがクライアントのレイアウト状態のビューを更新することができます。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2. Sequencing of Layout Operations",
      "section_title": true,
      "ja": "12.5.5.2。レイアウトの操作のシーケンシング"
    },
    {
      "indent": 3,
      "text": "As with other stateful operations, pNFS requires the correct sequencing of layout operations. pNFS uses the \"seqid\" in the layout stateid to provide the correct sequencing between regular operations and callbacks. It is the server's responsibility to avoid inconsistencies regarding the layouts provided and the client's responsibility to properly serialize its layout requests and layout returns.",
      "ja": "他のステートフル操作と同じように、pNFSのは、レイアウト操作の正しい順序付けを必要とします。 pNFSのは、通常の操作とコールバック間の正しい順序付けを提供するために、レイアウトのstateidで「SEQID」を使用しています。提供レイアウトと適切にレイアウト要求とレイアウトリターンをシリアル化するために、クライアントの責任に関する不整合を回避するために、サーバの責任です。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2.1. Layout Recall and Return Sequencing",
      "section_title": true,
      "ja": "12.5.5.2.1。レイアウトリコールおよび配列を返します"
    },
    {
      "indent": 3,
      "text": "One critical issue with regard to layout operations sequencing concerns callbacks. The protocol must defend against races between the reply to a LAYOUTGET or LAYOUTRETURN operation and a subsequent CB_LAYOUTRECALL. A client MUST NOT process a CB_LAYOUTRECALL that implies one or more outstanding LAYOUTGET or LAYOUTRETURN operations to which the client has not yet received a reply. The client detects such a CB_LAYOUTRECALL by examining the \"seqid\" field of the recall's layout stateid. If the \"seqid\" is not exactly one higher than what the client currently has recorded, and the client has at least one LAYOUTGET and/or LAYOUTRETURN operation outstanding, the client knows the server sent the CB_LAYOUTRECALL after sending a response to an outstanding LAYOUTGET or LAYOUTRETURN. The client MUST wait before processing such a CB_LAYOUTRECALL until it processes all replies for outstanding LAYOUTGET and LAYOUTRETURN operations for the corresponding file with seqid less than the seqid given by CB_LAYOUTRECALL (lor_stateid; see Section 20.3.)",
      "ja": "レイアウト操作の順序に関して、1つの重要な問題は、コールバックに関するものです。プロトコルはLAYOUTGET又はLAYOUTRETURN操作への応答とそれに続くCB_LAYOUTRECALL間レースを防御しなければなりません。クライアントは、クライアントがまだ応答を受信して​​いないために1つの以上の優れたLAYOUTGETまたはLAYOUTRETURN操作を意味CB_LAYOUTRECALLを処理してはいけません。クライアントは、リコールのレイアウトのstateidの「SEQID」フィールドを調べることによって、このようなCB_LAYOUTRECALLを検出します。 「SEQID」は現在クライアントが記録したものよりもない、正確に1つ大きくなり、そしてクライアントは、少なくとも1 LAYOUTGETおよび/または優れたLAYOUTRETURN操作を持っている場合、クライアントはサーバーが未LAYOUTGETへの応答を送信した後CB_LAYOUTRECALLを送ったかを知っていますLAYOUTRETURN。それはCB_LAYOUTRECALLによって与えられたSEQID未満SEQIDと、対応するファイルのための優れたLAYOUTGETとLAYOUTRETURN操作のためのすべての返信を処理するまで、クライアントは、このようなCB_LAYOUTRECALLを処理する前に待たなければなりません（lor_stateid;セクション20.3を参照してください。）"
    },
    {
      "indent": 3,
      "text": "In addition to the seqid-based mechanism, Section 2.10.6.3 describes the sessions mechanism for allowing the client to detect callback race conditions and delay processing such a CB_LAYOUTRECALL. The server MAY reference conflicting operations in the CB_SEQUENCE that precedes the CB_LAYOUTRECALL. Because the server has already sent replies for these operations before sending the callback, the replies may race with the CB_LAYOUTRECALL. The client MUST wait for all the referenced calls to complete and update its view of the layout state before processing the CB_LAYOUTRECALL.",
      "ja": "SEQIDベースのメカニズムに加えて、セクション2.10.6.3は、クライアントがコールバックレースの条件と遅延処理などCB_LAYOUTRECALLを検出することを可能にするためのセッションのメカニズムを説明しています。サーバーはCB_LAYOUTRECALLの前CB_SEQUENCEに相反する操作を参照してもよいです。サーバがすでにコールバックを送信する前にこれらの操作に応答を送信したので、返信はCB_LAYOUTRECALLでレースがあります。クライアントが完了し、CB_LAYOUTRECALLを処理する前に、レイアウトの状態のビューを更新するために参照されるすべての呼び出しを待つ必要があります。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2.1.1. Get/Return Sequencing",
      "section_title": true,
      "ja": "12.5.5.2.1.1。取得/シーケンスを返します。"
    },
    {
      "indent": 3,
      "text": "The protocol allows the client to send concurrent LAYOUTGET and LAYOUTRETURN operations to the server. The protocol does not provide any means for the server to process the requests in the same order in which they were created. However, through the use of the \"seqid\" field in the layout stateid, the client can determine the order in which parallel outstanding operations were processed by the server. Thus, when a layout retrieved by an outstanding LAYOUTGET operation intersects with a layout returned by an outstanding LAYOUTRETURN on the same file, the order in which the two conflicting operations are processed determines the final state of the overlapping layout. The order is determined by the \"seqid\" returned in each operation: the operation with the higher seqid was executed later.",
      "ja": "プロトコルは、クライアントがサーバーへの同時LAYOUTGETとLAYOUTRETURN操作を送信することができます。プロトコルは、それらが作成されたのと同じ順序で要求を処理するためのサーバーのための任意の手段を提供していません。しかしながら、レイアウトのstateidで「SEQID」フィールドを使用することにより、クライアントは、並列未処理の操作がサーバで処理された順序を決定することができます。未処理LAYOUTGET操作によって取得レイアウトが同じファイルに未処理LAYOUTRETURNによって返されたレイアウトと交差する場合したがって、2つの競合する操作が処理される順序は、オーバーラップレイアウトの最終状態を決定します。注文は「SEQID」によって決定される各オペレーションに返さ：高いSEQIDでの動作については、後に実行されました。"
    },
    {
      "indent": 3,
      "text": "It is permissible for the client to send multiple parallel LAYOUTGET operations for the same file or multiple parallel LAYOUTRETURN operations for the same file or a mix of both.",
      "ja": "クライアントが同じファイルまたは両方の組み合わせのために同じファイルまたは複数の並列LAYOUTRETURN操作のために複数の並列LAYOUTGET操作を送信することは許されています。"
    },
    {
      "indent": 3,
      "text": "It is permissible for the client to use the current stateid (see Section 16.2.3.1.2) for LAYOUTGET operations, for example, when compounding LAYOUTGETs or compounding OPEN and LAYOUTGETs. It is also permissible to use the current stateid when compounding LAYOUTRETURNs.",
      "ja": "LAYOUTGETsを配合またはOPENとLAYOUTGETs配合する場合、クライアントは、例えば、LAYOUTGET操作のための現在のstateid（セクション16.2.3.1.2を参照）を使用することは許されています。 LAYOUTRETURNsを配合する際に、現在のstateidを使用することも許されます。"
    },
    {
      "indent": 3,
      "text": "It is permissible for the client to use the current stateid when combining LAYOUTRETURN and LAYOUTGET operations for the same file in the same COMPOUND request since the server MUST process these in order. However, if a client does send such COMPOUND requests, it MUST NOT have more than one outstanding for the same file at the same time, and it MUST NOT have other LAYOUTGET or LAYOUTRETURN operations outstanding at the same time for that same file.",
      "ja": "サーバがためにこれらを処理しなければならないので、同じ化合物の要求で同じファイルに対してLAYOUTRETURNとLAYOUTGET操作を組み合わせる場合、クライアントは現在のstateidを使用することが許されています。クライアントは、このような化合物の要求を送信した場合しかし、それは同時に同じファイルのための優れた以上のものを持ってはいけません、それはその同じファイルに対して同時に優れた他のLAYOUTGETまたはLAYOUTRETURN操作を持ってはいけません。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2.1.2. Client Considerations",
      "section_title": true,
      "ja": "12.5.5.2.1.2。クライアントの考慮事項"
    },
    {
      "indent": 3,
      "text": "Consider a pNFS client that has sent a LAYOUTGET, and before it receives the reply to LAYOUTGET, it receives a CB_LAYOUTRECALL for the same file with an overlapping range. There are two possibilities, which the client can distinguish via the layout stateid in the recall.",
      "ja": "LAYOUTGETを送信したのpNFSクライアントを考えてみましょう、そしてそれはLAYOUTGETへの応答を受信する前に、それは重複範囲で同じファイルに対してCB_LAYOUTRECALLを受けます。クライアントがリコールでのレイアウトのstateidを経由して区別することができる2つの可能性があります。"
    },
    {
      "indent": 3,
      "text": "1. The server processed the LAYOUTGET before sending the recall, so the LAYOUTGET must be waited for because it may be carrying layout information that will need to be returned to deal with the CB_LAYOUTRECALL.",
      "ja": "1.サーバーは、リコールを送信する前にLAYOUTGETを処理し、それはCB_LAYOUTRECALLに対処するために返される必要がありますレイアウト情報を運ぶ可能性があるためLAYOUTGET待ちをしなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. The server sent the callback before receiving the LAYOUTGET. The server will not respond to the LAYOUTGET until the CB_LAYOUTRECALL is processed.",
      "ja": "2.サーバーはLAYOUTGETを受信する前に、コールバックを送りました。 CB_LAYOUTRECALLが処理されるまで、サーバーはLAYOUTGETに応答しません。"
    },
    {
      "indent": 3,
      "text": "If these possibilities cannot be distinguished, a deadlock could result, as the client must wait for the LAYOUTGET response before processing the recall in the first case, but that response will not arrive until after the recall is processed in the second case. Note that in the first case, the \"seqid\" in the layout stateid of the recall is two greater than what the client has recorded; in the second case, the \"seqid\" is one greater than what the client has recorded. This allows the client to disambiguate between the two cases. The client thus knows precisely which possibility applies.",
      "ja": "これらの可能性を区別することができない場合は、クライアントが最初のケースでリコールを処理する前にLAYOUTGET応答を待たなければなりませんが、その応答はリコールが第二の場合には処理された後まで到着しないだろうとして、デッドロックは、発生する可能性があります。最初のケースでは、リコールのレイアウトのstateidで「SEQID」は、クライアントが記録したものよりも2大きいことに注意してください。後者の場合には、「SEQIDは、」クライアントが記録したものよりも大きいものです。これは、クライアントが2例の間で明確にすることができます。クライアントは、このように可能性が適用される正確に知っています。"
    },
    {
      "indent": 3,
      "text": "In case 1, the client knows it needs to wait for the LAYOUTGET response before processing the recall (or the client can return NFS4ERR_DELAY).",
      "ja": "ケース1では、クライアントは、それがリコール（またはNFS4ERR_DELAYを返すことができるクライアント）を処理する前にLAYOUTGET応答を待つ必要がある知っています。"
    },
    {
      "indent": 3,
      "text": "In case 2, the client will not wait for the LAYOUTGET response before processing the recall because waiting would cause deadlock. Therefore, the action at the client will only require waiting in the case that the client has not yet seen the server's earlier responses to the LAYOUTGET operation(s).",
      "ja": "待機はデッドロックを引き起こすので、ケース2では、クライアントがリコールを処理する前にLAYOUTGET応答を待ちません。そのため、クライアントでのアクションは、クライアントがまだLAYOUTGET操作（複数可）に、サーバの以前の回答を見ていない場合には待機している必要があります。"
    },
    {
      "indent": 3,
      "text": "The recall process can be considered completed when the final LAYOUTRETURN operation for the recalled range is completed. The LAYOUTRETURN uses the layout stateid (with seqid) specified in CB_LAYOUTRECALL. If the client uses multiple LAYOUTRETURNs in processing the recall, the first LAYOUTRETURN will use the layout stateid as specified in CB_LAYOUTRECALL. Subsequent LAYOUTRETURNs will use the highest seqid as is the usual case.",
      "ja": "リコール範囲のための最終的なLAYOUTRETURN動作が完了したときにリコールプロセスが完了とみなすことができます。 LAYOUTRETURNはCB_LAYOUTRECALLで指定された（SEQID付き）レイアウトのstateidを使用します。クライアントがリコールを処理する際に、複数のLAYOUTRETURNsを使用する場合は、最初のLAYOUTRETURNはCB_LAYOUTRECALLで指定されたstateidレイアウトを使用します。いつもそうであるように、後続のLAYOUTRETURNsは最高SEQIDを使用します。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2.1.3. Server Considerations",
      "section_title": true,
      "ja": "12.5.5.2.1.3。サーバーの考慮事項"
    },
    {
      "indent": 3,
      "text": "Consider a race from the metadata server's point of view. The metadata server has sent a CB_LAYOUTRECALL and receives an overlapping LAYOUTGET for the same file before the LAYOUTRETURN(s) that respond to the CB_LAYOUTRECALL. There are three cases:",
      "ja": "ビューのメタデータ・サーバの視点からレースを考えてみましょう。メタデータサーバはCB_LAYOUTRECALLを送ったとCB_LAYOUTRECALLに応えるLAYOUTRETURN（S）の前に、同じファイルの重複LAYOUTGETを受けています。 3例があります。"
    },
    {
      "indent": 3,
      "text": "1. The client sent the LAYOUTGET before processing the CB_LAYOUTRECALL. The \"seqid\" in the layout stateid of the arguments of LAYOUTGET is one less than the \"seqid\" in CB_LAYOUTRECALL. The server returns NFS4ERR_RECALLCONFLICT to the client, which indicates to the client that there is a pending recall.",
      "ja": "1.クライアントがCB_LAYOUTRECALLを処理する前にLAYOUTGETを送りました。 LAYOUTGETの引数のレイアウトのstateidで「SEQIDは」CB_LAYOUTRECALLで「SEQID」より1少ないです。サーバーは、保留中のリコールがあることをクライアントに通知し、クライアントにNFS4ERR_RECALLCONFLICTを返します。"
    },
    {
      "indent": 3,
      "text": "2. The client sent the LAYOUTGET after processing the CB_LAYOUTRECALL, but the LAYOUTGET arrived before the LAYOUTRETURN and the response to CB_LAYOUTRECALL that completed that processing. The \"seqid\" in the layout stateid of LAYOUTGET is equal to or greater than that of the \"seqid\" in CB_LAYOUTRECALL. The server has not received a response to the CB_LAYOUTRECALL, so it returns NFS4ERR_RECALLCONFLICT.",
      "ja": "2.クライアントはCB_LAYOUTRECALLを処理した後LAYOUTGETを送ったが、LAYOUTGETはLAYOUTRETURNとその処理を完了しCB_LAYOUTRECALLへの応答の前に到着しました。 LAYOUTGETのレイアウトのstateidにおける「SEQID」はCB_LAYOUTRECALLにおける「SEQID」のそれ以上です。サーバーはCB_LAYOUTRECALLへの応答を受信して​​いないので、NFS4ERR_RECALLCONFLICTを返します。"
    },
    {
      "indent": 3,
      "text": "3. The client sent the LAYOUTGET after processing the",
      "section_title": true,
      "ja": "3.クライアントは、処理後にLAYOUTGETを送りました"
    },
    {
      "indent": 7,
      "text": "CB_LAYOUTRECALL; the server received the CB_LAYOUTRECALL\nresponse, but the LAYOUTGET arrived before the LAYOUTRETURN that\ncompleted that processing.  The \"seqid\" in the layout stateid of\nLAYOUTGET is equal to that of the \"seqid\" in CB_LAYOUTRECALL.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "The server has received a response to the CB_LAYOUTRECALL, so it returns NFS4ERR_RETURNCONFLICT.",
      "ja": "サーバーはCB_LAYOUTRECALLへの応答を受信したので、NFS4ERR_RETURNCONFLICTを返します。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2.1.4. Wraparound and Validation of Seqid",
      "section_title": true,
      "ja": "12.5.5.2.1.4。 SEQIDのラップアラウンドと検証"
    },
    {
      "indent": 3,
      "text": "The rules for layout stateid processing differ from other stateids in the protocol because the \"seqid\" value cannot be zero and the stateid's \"seqid\" value changes in a CB_LAYOUTRECALL operation. The non-zero requirement combined with the inherent parallelism of layout operations means that a set of LAYOUTGET and LAYOUTRETURN operations may contain the same value for \"seqid\". The server uses a slightly modified version of the modulo arithmetic as described in Section 2.10.6.1 when incrementing the layout stateid's \"seqid\". The difference is that zero is not a valid value for \"seqid\"; when the value of a \"seqid\" is 0xFFFFFFFF, the next valid value will be 0x00000001. The modulo arithmetic is also used for the comparisons of \"seqid\" values in the processing of CB_LAYOUTRECALL events as described above in Section 12.5.5.2.1.3.",
      "ja": "「SEQID」値はゼロであるとCB_LAYOUTRECALL動作でのstateidの「SEQID」値が変化することができないので、レイアウトのstateid処理のためのルールは、プロトコル内の他のstateids異なります。レイアウト操作の固有の並列性と組み合わせた非ゼロの要件はLAYOUTGETとLAYOUTRETURN操作のセットが「SEQID」に対して同じ値を含んでいてもよいことを意味します。第2.10.6.1で説明したように、レイアウトのstateidの「SEQID」をインクリメントするとき、サーバは、モジュロ演算のわずかに変更されたバージョンを使用します。違いは、ゼロは「SEQID」の有効な値ではないということです。 「SEQID」の値が0xFFFFFFFFのとき、次の有効な値は0x00000001になります。節12.5.5.2.1.3に上記のようにモジュロ演算もCB_LAYOUTRECALLイベントの処理で「SEQID」値の比較に使用されます。"
    },
    {
      "indent": 3,
      "text": "Just as the server validates the \"seqid\" in the event of CB_LAYOUTRECALL usage, as described in Section 12.5.5.2.1.3, the server also validates the \"seqid\" value to ensure that it is within an appropriate range. This range represents the degree of parallelism the server supports for layout stateids. If the client is sending multiple layout operations to the server in parallel, by definition, the \"seqid\" value in the supplied stateid will not be the current \"seqid\" as held by the server. The range of parallelism spans from the highest or current \"seqid\" to a \"seqid\" value in the past. To assist in the discussion, the server's current \"seqid\" value for a layout stateid is defined as SERVER_CURRENT_SEQID. The lowest \"seqid\" value that is acceptable to the server is represented by PAST_SEQID. And the value for the range of valid \"seqid\"s or range of parallelism is VALID_SEQID_RANGE. Therefore, the following holds: VALID_SEQID_RANGE = SERVER_CURRENT_SEQID - PAST_SEQID. In the following, all arithmetic is the modulo arithmetic as described above.",
      "ja": "サーバはCB_LAYOUTRECALLの使用の場合に「SEQIDを」検証と同様項12.5.5.2.1.3に記載されているように、サーバはまた、それが適切な範囲内にあることを確実にするために「SEQID」値を検証します。この範囲は、サーバがレイアウトのstateidsのためにサポートして並列度を表しています。クライアントは、定義により、並行してサーバに複数のレイアウトオペレーションを送信している場合、サーバが保持しているように、供給のstateidの「SEQID」値は、現在の「SEQID」ではないだろう。並列処理の範囲は、過去に「SEQID」の値に最高または現在の「SEQID」から及びます。議論を支援するために、レイアウトのstateidのためのサーバーの現在の「SEQID」値がSERVER_CURRENT_SEQIDとして定義されます。サーバに許容できる最低の「SEQID」値はPAST_SEQIDで表されます。そして、有効な「SEQID」sの範囲や並列処理の範囲の値がVALID_SEQID_RANGEです。したがって、以下が成り立つ：VALID_SEQID_RANGE = SERVER_CURRENT_SEQID  -  PAST_SEQIDを。上述したように、以下では、全ての演算はモジュロ演算です。"
    },
    {
      "indent": 3,
      "text": "The server MUST support a minimum VALID_SEQID_RANGE. The minimum is defined as: VALID_SEQID_RANGE = summation over 1..N of (ca_maxoperations(i) - 1), where N is the number of session fore channels and ca_maxoperations(i) is the value of the ca_maxoperations returned from CREATE_SESSION of the i'th session. The reason for \"- 1\" is to allow for the required SEQUENCE operation. The server MAY support a VALID_SEQID_RANGE value larger than the minimum. The maximum VALID_SEQID_RANGE is (2 ^ 32 - 2) (accounting for zero not being a valid \"seqid\" value).",
      "ja": "サーバーは、最小VALID_SEQID_RANGEをサポートしなければなりません。 （ca_maxoperations（I） -  1）の1..N上VALID_SEQID_RANGE =総和、Nはca_maxoperationsの値は、iのCREATE_SESSIONからセッション前方チャネルとca_maxoperationsの数（I）が返されている場合：最小値は以下のように定義されます番目のセッション。 「 -  1」の理由は、必要なシーケンス動作を可能にすることです。サーバーは、最小値よりも大きなVALID_SEQID_RANGE値をサポートするかもしれません。 （有効 \"SEQID\" 値ではないゼロを占める） - 最大VALID_SEQID_RANGE（2 2 ^ 32）です。"
    },
    {
      "indent": 3,
      "text": "If the server finds the \"seqid\" is zero, the NFS4ERR_BAD_STATEID error is returned to the client. The server further validates the \"seqid\" to ensure it is within the range of parallelism, VALID_SEQID_RANGE. If the \"seqid\" value is outside of that range, the error NFS4ERR_OLD_STATEID is returned to the client. Upon receipt of NFS4ERR_OLD_STATEID, the client updates the stateid in the layout request based on processing of other layout requests and re-sends the operation to the server.",
      "ja": "サーバは「SEQID」を見つけた場合NFS4ERR_BAD_STATEIDエラーがクライアントに返され、ゼロです。サーバは、さらに、それは並列処理、VALID_SEQID_RANGEの範囲内であることを確認するために「SEQID」を検証します。 「SEQID」値がその範囲の外にある場合、エラーNFS4ERR_OLD_STATEIDがクライアントに返されます。 NFS4ERR_OLD_STATEIDを受信すると、クライアントは、他のレイアウト要求の処理に基づいてレイアウト要求の中のstateidを更新し、サーバに操作​​を再送信します。"
    },
    {
      "indent": 0,
      "text": "12.5.5.2.1.5. Bulk Recall and Return",
      "section_title": true,
      "ja": "12.5.5.2.1.5。バルクリコールとリターン"
    },
    {
      "indent": 3,
      "text": "pNFS supports recalling and returning all layouts that are for files belonging to a particular fsid (LAYOUTRECALL4_FSID, LAYOUTRETURN4_FSID) or client ID (LAYOUTRECALL4_ALL, LAYOUTRETURN4_ALL). There are no \"bulk\" stateids, so detection of races via the seqid is not possible. The server MUST NOT initiate bulk recall while another recall is in progress, or the corresponding LAYOUTRETURN is in progress or pending. In the event the server sends a bulk recall while the client has a pending or in-progress LAYOUTRETURN, CB_LAYOUTRECALL, or LAYOUTGET, the client returns NFS4ERR_DELAY. In the event the client sends a LAYOUTGET or LAYOUTRETURN while a bulk recall is in progress, the server returns NFS4ERR_RECALLCONFLICT. If the client sends a LAYOUTGET or LAYOUTRETURN after the server receives NFS4ERR_DELAY from a bulk recall, then to ensure forward progress, the server MAY return NFS4ERR_RECALLCONFLICT.",
      "ja": "pNFSのは、特定のFSID（LAYOUTRECALL4_FSID、LAYOUTRETURN4_FSID）またはクライアントID（LAYOUTRECALL4_ALL、LAYOUTRETURN4_ALL）に属するファイルのためのものであるすべてのレイアウトをリコールして返すサポートしています。そこには「バルク」のstateidsはありませんので、SEQID経由レースの検出は可能ではありません。別のリコールが進行している間、サーバーは、バルクリコールを開始してはいけません、または対応LAYOUTRETURNが進行又は係属中です。クライアントは、保留中または進行中LAYOUTRETURN、CB_LAYOUTRECALL、またはLAYOUTGET、クライアントが返すNFS4ERR_DELAYを有している場合には、サーバは、バルクリコールを送信します。バルクリコールの進行中にイベントでは、クライアントはLAYOUTGETまたはLAYOUTRETURNを送信し、サーバがNFS4ERR_RECALLCONFLICTを返します。サーバーは、バルクリコールからNFS4ERR_DELAYを受信した後、クライアントがLAYOUTGETまたはLAYOUTRETURNを送信した場合、順方向の進行を確保するために、サーバはNFS4ERR_RECALLCONFLICTを返す場合があります。"
    },
    {
      "indent": 3,
      "text": "Once a CB_LAYOUTRECALL of LAYOUTRECALL4_ALL is sent, the server MUST NOT allow the client to use any layout stateid except for LAYOUTCOMMIT operations. Once the client receives a CB_LAYOUTRECALL of LAYOUTRECALL4_ALL, it MUST NOT use any layout stateid except for LAYOUTCOMMIT operations. Once a LAYOUTRETURN of LAYOUTRETURN4_ALL is sent, all layout stateids granted to the client ID are freed. The client MUST NOT use the layout stateids again. It MUST use LAYOUTGET to obtain new layout stateids.",
      "ja": "LAYOUTRECALL4_ALLのCB_LAYOUTRECALLが送信されると、サーバーは、クライアントがLAYOUTCOMMIT操作以外の任意のレイアウトのstateidを使用することを許してはなりません。クライアントはLAYOUTRECALL4_ALLのCB_LAYOUTRECALLを受信すると、それはLAYOUTCOMMIT操作以外の任意のレイアウトのstateidを使用してはなりません。 LAYOUTRETURN4_ALLのLAYOUTRETURNが送信されると、クライアントIDに付与されたすべてのレイアウトのstateidsが解放されます。クライアントは、再度、レイアウトのstateidsを使用してはなりません。これは、新しいレイアウトのstateidsを取得するためにLAYOUTGETを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once a CB_LAYOUTRECALL of LAYOUTRECALL4_FSID is sent, the server MUST NOT allow the client to use any layout stateid that refers to a file with the specified fsid except for LAYOUTCOMMIT operations. Once the client receives a CB_LAYOUTRECALL of LAYOUTRECALL4_ALL, it MUST NOT use any layout stateid that refers to a file with the specified fsid except for LAYOUTCOMMIT operations. Once a LAYOUTRETURN of LAYOUTRETURN4_FSID is sent, all layout stateids granted to the referenced fsid are freed. The client MUST NOT use those freed layout stateids for files with the referenced fsid again. Subsequently, for any file with the referenced fsid, to use a layout, the client MUST first send a LAYOUTGET operation in order to obtain a new layout stateid for that file.",
      "ja": "LAYOUTRECALL4_FSIDのCB_LAYOUTRECALLが送信されると、サーバーは、クライアントが指定したLAYOUTCOMMIT操作以外のFSIDを使用してファイルを参照する任意のレイアウトのstateidを使用することを許してはなりません。クライアントはLAYOUTRECALL4_ALLのCB_LAYOUTRECALLを受信すると、指定されたLAYOUTCOMMIT操作以外のFSIDを使用してファイルを参照する任意のレイアウトのstateidを使用してはなりません。 LAYOUTRETURN4_FSIDのLAYOUTRETURNが送信されると、参照されたfsidに付与されたすべてのレイアウトのstateidsが解放されます。クライアントが再び参照さFSIDを持つファイルを、これらの解放されたレイアウトのstateidsを使用してはなりません。その後、参照FSIDを持つ任意のファイルに対して、レイアウトを使用するために、クライアントはまずそのファイルの新しいレイアウトのstateidを得るために、LAYOUTGET操作を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the server has sent a bulk CB_LAYOUTRECALL and receives a LAYOUTGET, or a LAYOUTRETURN with a stateid, the server MUST return NFS4ERR_RECALLCONFLICT. If the server has sent a bulk CB_LAYOUTRECALL and receives a LAYOUTRETURN with an lr_returntype that is not equal to the lor_recalltype of the CB_LAYOUTRECALL, the server MUST return NFS4ERR_RECALLCONFLICT.",
      "ja": "サーバはバルクCB_LAYOUTRECALLを送ったとのstateidでLAYOUTGET、またはLAYOUTRETURNを受信して​​いる場合、サーバーはNFS4ERR_RECALLCONFLICTを返さなければなりません。サーバは、バルクCB_LAYOUTRECALLを送信しCB_LAYOUTRECALLのlor_recalltypeに等しくないlr_returntypeとLAYOUTRETURNを受信した場合、サーバはNFS4ERR_RECALLCONFLICTを返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "12.5.6. Revoking Layouts",
      "section_title": true,
      "ja": "12.5.6. 取り消しレイアウト"
    },
    {
      "indent": 3,
      "text": "Parallel NFS permits servers to revoke layouts from clients that fail to respond to recalls and/or fail to renew their lease in time. Depending on the layout type, the server might revoke the layout and might take certain actions with respect to the client's I/O to data servers.",
      "ja": "パラレルNFSは、リコールへの対応および/または時間でのリースの更新に失敗して失敗したクライアントからレイアウトを取り消すために、サーバを許可します。レイアウトの種類に応じて、サーバーは、レイアウトを取り消す可能性があり、データ・サーバへのクライアントのI / Oに対する特定のアクションをとるかもしれません。"
    },
    {
      "indent": 0,
      "text": "12.5.7. Metadata Server Write Propagation",
      "section_title": true,
      "ja": "12.5.7. メタデータサーバ書き込み伝播"
    },
    {
      "indent": 3,
      "text": "Asynchronous writes written through the metadata server may be propagated lazily to the storage devices. For data written asynchronously through the metadata server, a client performing a read at the appropriate storage device is not guaranteed to see the newly written data until a COMMIT occurs at the metadata server. While the write is pending, reads to the storage device may give out either the old data, the new data, or a mixture of new and old. Upon completion of a synchronous WRITE or COMMIT (for asynchronously written data), the metadata server MUST ensure that storage devices give out the new data and that the data has been written to stable storage. If the server implements its storage in any way such that it cannot obey these constraints, then it MUST recall the layouts to prevent reads being done that cannot be handled correctly. Note that the layouts MUST be recalled prior to the server responding to the associated WRITE operations.",
      "ja": "メタデータサーバを経由して書かれた非同期書き込みはストレージデバイスにいい加減に伝播することができます。メタデータサーバを介して非同期に書き込まれたデータについては、適切なストレージデバイスで読み取りを実行するクライアントは、COMMITは、メタデータ・サーバで発生するまで、新たに書き込まれたデータを見ることが保証されていません。書き込みが保留されている一方で、古いデータ、新しいデータ、または新旧の混合物のいずれかを与える可能性があり、ストレージデバイスに読み込みます。同期書き込みが完了すると、または（非同期的に書き込まれたデータのために）COMMIT、メタデータサーバは、ストレージデバイスが新しいデータを与え、データが安定したストレージに書き込まれたことを確認しなければなりません。サーバは、これらの制約に従うことができないようにどのような方法でそのストレージを実装している場合、それは正しく処理できない行われて読み取りを防止するためにレイアウトをリコールしなければなりません。レイアウトは、関連する書き込み操作に応答するサーバの前にリコールしなければならないことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "12.6. pNFS Mechanics",
      "section_title": true,
      "ja": "12.6.  pNFSの力学"
    },
    {
      "indent": 3,
      "text": "This section describes the operations flow taken by a pNFS client to a metadata server and storage device.",
      "ja": "このセクションでは、操作は、メタデータ・サーバとストレージ・デバイスへのpNFSクライアントによって撮影した流れを説明します。"
    },
    {
      "indent": 3,
      "text": "When a pNFS client encounters a new FSID, it sends a GETATTR to the NFSv4.1 server for the fs_layout_type (Section 5.12.1) attribute. If the attribute returns at least one layout type, and the layout types returned are among the set supported by the client, the client knows that pNFS is a possibility for the file system. If, from the server that returned the new FSID, the client does not have a client ID that came from an EXCHANGE_ID result that returned EXCHGID4_FLAG_USE_PNFS_MDS, it MUST send an EXCHANGE_ID to the server with the EXCHGID4_FLAG_USE_PNFS_MDS bit set. If the server's response does not have EXCHGID4_FLAG_USE_PNFS_MDS, then contrary to what the fs_layout_type attribute said, the server does not support pNFS, and the client will not be able use pNFS to that server; in this case, the server MUST return NFS4ERR_NOTSUPP in response to any pNFS operation.",
      "ja": "pNFSのクライアントが新しいFSIDに遭遇すると、それはfs_layout_type（セクション5.12.1）属性のNFSv4.1サーバーにGETATTRを送信します。属性は、少なくとも1つのレイアウトタイプを返し、返されたレイアウトタイプは、クライアントでサポートされているセットの中にある場合、クライアントはpNFSのは、ファイルシステムの可能性であることを知っています。 、新しいFSIDを返されたサーバから、クライアントがEXCHGID4_FLAG_USE_PNFS_MDSを返さEXCHANGE_ID結果から来たクライアントIDを持っていない場合EXCHGID4_FLAG_USE_PNFS_MDSビットが設定して、それがサーバーにEXCHANGE_IDを送らなければなりません。サーバの応答がEXCHGID4_FLAG_USE_PNFS_MDSを持っていない場合は、fs_layout_type属性が言ったに反し、サーバーはpNFSのをサポートしていない、とクライアントは、そのサーバーへの可能な利用のpNFSではありません。この場合には、サーバがどのpNFSの操作に応じてNFS4ERR_NOTSUPPを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client then creates a session, requesting a persistent session, so that exclusive creates can be done with single round trip via the createmode4 of GUARDED4. If the session ends up not being persistent, the client will use EXCLUSIVE4_1 for exclusive creates.",
      "ja": "排他がGUARDED4のcreatemode4を経由して、1回のラウンドトリップで行うことができます作成​​されますように、クライアントは次に、永続的なセッションを要求し、セッションを作成します。セッションが永続されていない終わる場合、クライアントは排他的に作成するためにEXCLUSIVE4_1を使用します。"
    },
    {
      "indent": 3,
      "text": "If a file is to be created on a pNFS-enabled file system, the client uses the OPEN operation. With the normal set of attributes that may be provided upon OPEN used for creation, there is an OPTIONAL layout_hint attribute. The client's use of layout_hint allows the client to express its preference for a layout type and its associated layout details. The use of a createmode4 of UNCHECKED4, GUARDED4, or EXCLUSIVE4_1 will allow the client to provide the layout_hint attribute at create time. The client MUST NOT use EXCLUSIVE4 (see Table 10). The client is RECOMMENDED to combine a GETATTR operation after the OPEN within the same COMPOUND. The GETATTR may then retrieve the layout_type attribute for the newly created file. The client will then know what layout type the server has chosen for the file and therefore what storage protocol the client must use.",
      "ja": "ファイルはpNFSの対応のファイルシステム上で作成する場合は、クライアントがOPENオペレーションを使用しています。 OPENに応じて提供することができる属性の通常のセットが作成に使用して、オプションlayout_hint属性があります。 layout_hintのクライアントの使用は、クライアントが、レイアウトタイプとそれに関連するレイアウトの詳細については、その嗜好を表現することを可能にします。 UNCHECKED4、GUARDED4、またはEXCLUSIVE4_1のcreatemode4の使用は、クライアントが作成時にlayout_hint属性を提供することができます。クライアントはEXCLUSIVE4（表10を参照）を使用してはなりません。クライアントは、同じ化合物の中にOPENした後GETATTR操作を組み合わせることが推奨されます。 GETATTRは、新しく作成されたファイルのlayout_type属性を検索することができます。その後、クライアントは、サーバがファイル用に選択されたものをレイアウトタイプ、したがって、クライアントが使用する必要がありますどのようなストレージプロトコルを知ることができます。"
    },
    {
      "indent": 3,
      "text": "If the client wants to open an existing file, then it also includes a GETATTR to determine what layout type the file supports.",
      "ja": "クライアントは、既存のファイルを開くしようとする場合、それはまた、ファイルがサポートしているレイアウトタイプを決定するGETATTRが含まれています。"
    },
    {
      "indent": 3,
      "text": "The GETATTR in either the file creation or plain file open case can also include the layout_blksize and layout_alignment attributes so that the client can determine optimal offsets and lengths for I/O on the file.",
      "ja": "クライアントがファイル上でI / Oの最適なオフセットと長さを決定することができるように、ファイルの作成またはプレーンファイルオープンの場合のいずれかでGETATTRもlayout_blksizeとlayout_alignment属性を含めることができます。"
    },
    {
      "indent": 3,
      "text": "Assuming the client supports the layout type returned by GETATTR and it chooses to use pNFS for data access, it then sends LAYOUTGET using the filehandle and stateid returned by OPEN, specifying the range it wants to do I/O on. The response is a layout, which may be a subset of the range for which the client asked. It also includes device IDs and a description of how data is organized (or in the case of writing, how data is to be organized) across the devices. The device IDs and data description are encoded in a format that is specific to the layout type, but the client is expected to understand.",
      "ja": "クライアントがGETATTRによって返されたレイアウトタイプをサポートし、データアクセスのためのpNFSを使用することを選択したと仮定すると、それは、ファイルハンドルを使用してLAYOUTGETを送信し、OPENによって返されたstateid、それがI / Oを上やりたい範囲を指定します。応答は、クライアントが尋ねれる範囲のサブセットであり得るレイアウトです。また、デバイス間（データを整理する方法、または書き込みの場合）デバイスIDとデータの編成方法の説明を含みます。デバイスIDとデータ記述は、レイアウトタイプに固有のフォーマットで符号化されているが、クライアントが理解することが期待されます。"
    },
    {
      "indent": 3,
      "text": "When the client wants to send an I/O, it determines to which device ID it needs to send the I/O command by examining the data description in the layout. It then sends a GETDEVICEINFO to find the device address(es) of the device ID. The client then sends the I/O request to one of device ID's device addresses, using the storage protocol defined for the layout type. Note that if a client has multiple I/Os to send, these I/O requests may be done in parallel.",
      "ja": "クライアントは、O / Iを送信したい場合は、それがレイアウトでデータ記述を調べることによって、I / Oコマンドを送信する必要があるとどのデバイスIDを決定します。その後、デバイスIDのデバイスアドレスを見つけるために、GETDEVICEINFOを送信します。次に、クライアントは、レイアウトタイプに対して定義されたストレージ・プロトコルを使用して、デバイスIDのデバイスアドレスの1つにI / O要求を送信します。クライアントが送信するために、複数のI / Oを持っている場合、これらのI / O要求を並行して行うことができることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the I/O was a WRITE, then at some point the client may want to use LAYOUTCOMMIT to commit the modification time and the new size of the file (if it believes it extended the file size) to the metadata server and the modified data to the file system.",
      "ja": "I / OがWRITEた場合（それがファイルサイズを拡張信じている場合）、その後、いくつかの点で、クライアントは、メタデータサーバと変更されたデータへの更新時刻とファイルの新しいサイズをコミットするLAYOUTCOMMITを使用することもできますファイルシステムへ。"
    },
    {
      "indent": 0,
      "text": "12.7. Recovery",
      "section_title": true,
      "ja": "12.7. 回復"
    },
    {
      "indent": 3,
      "text": "Recovery is complicated by the distributed nature of the pNFS protocol. In general, crash recovery for layouts is similar to crash recovery for delegations in the base NFSv4.1 protocol. However, the client's ability to perform I/O without contacting the metadata server introduces subtleties that must be handled correctly if the possibility of file system corruption is to be avoided.",
      "ja": "回復はpNFSのプロトコルの分散性によって複雑になります。一般的に、レイアウトのクラッシュ回復は、ベースNFSv4.1プロトコルに委任するための回復をクラッシュと同様です。しかし、メタデータサーバーに接続しなくても、I / Oを実行するためのクライアントの機能は、ファイルシステムの破損の可能性を回避すべきである場合に正しく処理されなければならない微妙な違いを紹介します。"
    },
    {
      "indent": 0,
      "text": "12.7.1. Recovery from Client Restart",
      "section_title": true,
      "ja": "12.7.1. クライアントの再起動からの回復"
    },
    {
      "indent": 3,
      "text": "Client recovery for layouts is similar to client recovery for other lock and delegation state. When a pNFS client restarts, it will lose all information about the layouts that it previously owned. There are two methods by which the server can reclaim these resources and allow otherwise conflicting layouts to be provided to other clients.",
      "ja": "レイアウトのためのクライアントの回復は他のロックと委任状態のクライアント回復に似ています。 pNFSのクライアントを再起動すると、それが以前所有していレイアウトに関するすべての情報を失うことになります。サーバーは、これらのリソースを再利用し、それ以外の場合は、競合するレイアウトは、他のクライアントに提供することを可能にすることが可能な2つの方法があります。"
    },
    {
      "indent": 3,
      "text": "The first is through the expiry of the client's lease. If the client recovery time is longer than the lease period, the client's lease will expire and the server will know that state may be released. For layouts, the server may release the state immediately upon lease expiry or it may allow the layout to persist, awaiting possible lease revival, as long as no other layout conflicts.",
      "ja": "最初は、クライアントのリースの満了を介して行われます。クライアントの回復時間が長いリース期間を超える場合、クライアントのリースが期限切れになり、サーバーは状態を解除することができることを知っているだろう。レイアウトのために、サーバは、リース満了時に直ちに状態を解除することができるか、それがない他のレイアウトの競合限り、可能リース復活を​​待って、レイアウトが持続することを可能にし得ます。"
    },
    {
      "indent": 3,
      "text": "The second is through the client restarting in less time than it takes for the lease period to expire. In such a case, the client will contact the server through the standard EXCHANGE_ID protocol. The server will find that the client's co_ownerid matches the co_ownerid of the previous client invocation, but that the verifier is different. The server uses this as a signal to release all layout state associated with the client's previous invocation. In this scenario, the data written by the client but not covered by a successful LAYOUTCOMMIT is in an undefined state; it may have been written or it may now be lost. This is acceptable behavior and it is the client's responsibility to use LAYOUTCOMMIT to achieve the desired level of stability.",
      "ja": "第二は、それが期限切れにリース期間の時間よりも短い時間で再起動するクライアントを介してです。このような場合、クライアントは、標準EXCHANGE_IDプロトコルを介してサーバーに接続します。サーバーは、クライアントのco_owneridは、前回のクライアント呼び出しのco_owneridを一致しますが、検証が異なっていることがわかります。サーバーはクライアントの以前の呼び出しに関連付けられたすべてのレイアウト状態を解除する信号としてこれを使用しています。このシナリオでは、データはクライアントによって書かれたが、未定義の状態になって成功したLAYOUTCOMMITでカバーされていません。それが書かれていたり、それが今失われることがあります。これは、許容できる動作であり、安定性の所望のレベルを達成するためにLAYOUTCOMMITを使用するようにクライアントの責任です。"
    },
    {
      "indent": 0,
      "text": "12.7.2. Dealing with Lease Expiration on the Client",
      "section_title": true,
      "ja": "12.7.2. クライアントにリースの有効期限への対処"
    },
    {
      "indent": 3,
      "text": "If a client believes its lease has expired, it MUST NOT send I/O to the storage device until it has validated its lease. The client can send a SEQUENCE operation to the metadata server. If the SEQUENCE operation is successful, but sr_status_flag has SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED, SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED, or SEQ4_STATUS_ADMIN_STATE_REVOKED set, the client MUST NOT use currently held layouts. The client has two choices to recover from the lease expiration. First, for all modified but uncommitted data, the client writes it to the metadata server using the FILE_SYNC4 flag for the WRITEs, or WRITE and COMMIT. Second, the client re-establishes a client ID and session with the server and obtains new layouts and device-ID-to-device-address mappings for the modified data ranges and then writes the data to the storage devices with the newly obtained layouts.",
      "ja": "クライアントがリースが期限切れになったと考えている場合は、そのリースを検証するまで、それはストレージデバイスにI / Oを送ってはいけません。クライアントは、メタデータサーバへのシーケンス動作を送ることができます。シーケンス動作が成功したが、sr_status_flagはSEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED、SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED、またはSEQ4_STATUS_ADMIN_STATE_REVOKEDセットを持っている場合、クライアントは、現在開催されたレイアウトを使用してはなりません。クライアントは、リース満了から回復するには、2つの選択肢があります。まず、すべての変更が、コミットされていないデータのために、クライアントは書き込みのFILE_SYNC4フラグを使用してメタデータ・サーバに書き込み、またはWRITEとCOMMIT。第二に、クライアントは、サーバとのクライアントIDとセッションを再確立し、変更されたデータ範囲のための新しいレイアウトとデバイスIDとデバイス・アドレスのマッピングを取得し、新たに得られたレイアウトでのストレージデバイスにデータを書き込みます。"
    },
    {
      "indent": 3,
      "text": "If sr_status_flags from the metadata server has SEQ4_STATUS_RESTART_RECLAIM_NEEDED set (or SEQUENCE returns NFS4ERR_BAD_SESSION and CREATE_SESSION returns NFS4ERR_STALE_CLIENTID), then the metadata server has restarted, and the client SHOULD recover using the methods described in Section 12.7.4.",
      "ja": "メタデータサーバからsr_status_flagsがセット（またはSEQUENCE NFS4ERR_BAD_SESSIONとCREATE_SESSIONはNFS4ERR_STALE_CLIENTIDを返します）をSEQ4_STATUS_RESTART_RECLAIM_NEEDEDしている場合は、メタデータサーバが再起動され、クライアントは、セクション12.7.4に記載された方法を使用して回復する必要があります。"
    },
    {
      "indent": 3,
      "text": "If sr_status_flags from the metadata server has SEQ4_STATUS_LEASE_MOVED set, then the client recovers by following the procedure described in Section 11.7.7.1. After that, the client may get an indication that the layout state was not moved with the file system. The client recovers as in the other applicable situations discussed in the first two paragraphs of this section.",
      "ja": "メタデータサーバからsr_status_flagsが設定SEQ4_STATUS_LEASE_MOVEDしている場合、クライアントは、セクション11.7.7.1に記載されている手順に従うことによって回復します。その後、クライアントは、レイアウトの状態がファイルシステムに移動していなかったことを示す指標を得ることができます。クライアントは、このセクションの最初の二つの段落で論じた他の適用状況と回復します。"
    },
    {
      "indent": 3,
      "text": "If sr_status_flags reports no loss of state, then the lease for the layouts that the client has are valid and renewed, and the client can once again send I/O requests to the storage devices.",
      "ja": "sr_status_flagsレポートの状態を損なうことなく、クライアントが有効と更新されたレイアウトのため、その後リース、およびクライアントが再びストレージデバイスへのI / O要求を送信することができます。もし"
    },
    {
      "indent": 3,
      "text": "While clients SHOULD NOT send I/Os to storage devices that may extend past the lease expiration time period, this is not always possible, for example, an extended network partition that starts after the I/O is sent and does not heal until the I/O request is received by the storage device. Thus, the metadata server and/or storage devices are responsible for protecting themselves from I/Os that are both sent before the lease expires and arrive after the lease expires. See Section 12.7.3.",
      "ja": "クライアントはリース満了期間を過ぎて延長することができるストレージデバイスへのI / Oを送るべきではありませんが、これは常に可能ではない、例えば、I / Oが送信された後に開始され、拡張されたネットワークパーティションはIまで治癒しません/ O要求は、ストレージデバイスによって受信されます。このように、メタデータサーバおよび/またはストレージデバイスは、両方のリースの期限が切れる前に送信され、リースの期限が切れた後に到着されているI / Oのから身を守るための責任があります。セクション12.7.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "12.7.3. Dealing with Loss of Layout State on the Metadata Server",
      "section_title": true,
      "ja": "12.7.3. メタデータサーバ上のレイアウト国家の損失に対処"
    },
    {
      "indent": 3,
      "text": "This is a description of the case where all of the following are true:",
      "ja": "これは、次のすべてに該当する例の説明です："
    },
    {
      "indent": 3,
      "text": "o the metadata server has not restarted",
      "ja": "Oメタデータサーバーが再起動されていません"
    },
    {
      "indent": 3,
      "text": "o a pNFS client's layouts have been discarded (usually because the client's lease expired) and are invalid",
      "ja": "OのpNFSクライアントのレイアウトは破棄（クライアントのリースが期限切れ通常ため）、無効ですされています"
    },
    {
      "indent": 3,
      "text": "o an I/O from the pNFS client arrives at the storage device",
      "ja": "OのpNFSクライアントからのI / Oは、記憶装置に到着します"
    },
    {
      "indent": 3,
      "text": "The metadata server and its storage devices MUST solve this by fencing the client. In other words, they MUST solve this by preventing the execution of I/O operations from the client to the storage devices after layout state loss. The details of how fencing is done are specific to the layout type. The solution for NFSv4.1 file-based layouts is described in (Section 13.11), and solutions for other layout types are in their respective external specification documents.",
      "ja": "メタデータ・サーバとそのストレージデバイスには、クライアントをフェンシングすることでこれを解決しなければなりません。言い換えれば、彼らはレイアウト状態喪失後のストレージデバイスにクライアントからのI / O操作の実行を防止することによって、この問題を解決しなければなりません。フェンシングがどのように行われるかの詳細については、レイアウトの種類に固有のものです。 NFSv4.1ファイルベースのレイアウトのための溶液（セクション13.11）に記載されており、他のレイアウトタイプのソリューションは、それぞれの外部仕様書です。"
    },
    {
      "indent": 0,
      "text": "12.7.4. Recovery from Metadata Server Restart",
      "section_title": true,
      "ja": "12.7.4. メタデータサーバの再起動からの回復"
    },
    {
      "indent": 3,
      "text": "The pNFS client will discover that the metadata server has restarted via the methods described in Section 8.4.2 and discussed in a pNFS-specific context in Paragraph 2, of Section 12.7.2. The client MUST stop using layouts and delete the device ID to device address mappings it previously received from the metadata server. Having done that, if the client wrote data to the storage device without committing the layouts via LAYOUTCOMMIT, then the client has additional work to do in order to have the client, metadata server, and storage device(s) all synchronized on the state of the data.",
      "ja": "pNFSのクライアントは、メタデータサーバは、セクション8.4.2に記載された方法を介して再開及び第2項にpNFSの固有のコンテキストで説明し、セクション12.7.2でいることを発見します。クライアントは、レイアウトの使用を停止し、それ以前に、メタデータサーバから受信したデバイスアドレスのマッピングにデバイスIDを削除しなければなりません。クライアントがLAYOUTCOMMIT経由でレイアウトをコミットせずにストレージデバイスにデータを書いた場合、クライアントは、クライアント、メタデータサーバ、およびストレージ・デバイス（複数可）を持つために、追加的な作業を持っている、というの状態に同期され、すべてをやりましたデータ。"
    },
    {
      "indent": 3,
      "text": "o If the client has data still modified and unwritten in the client's memory, the client has only two choices.",
      "ja": "クライアントがデータまだ修正され、クライアントのメモリに書き込まれていないしている場合は、O、クライアントは2つの選択肢があります。"
    },
    {
      "indent": 6,
      "text": "1. The client can obtain a layout via LAYOUTGET after the server's grace period and write the data to the storage devices.",
      "ja": "1.クライアントは、サーバーの猶予期間の後LAYOUTGETを経由して、レイアウトを取得し、ストレージデバイスにデータを書き込むことができます。"
    },
    {
      "indent": 6,
      "text": "2. The client can WRITE that data through the metadata server using the WRITE (Section 18.32) operation, and then obtain layouts as desired.",
      "ja": "2.クライアントは、WRITE（セクション18.32）操作を使用してメタデータサーバを介してそのデータを書き込み、その後、所望に応じてレイアウトを得ることができます。"
    },
    {
      "indent": 3,
      "text": "o If the client asynchronously wrote data to the storage device, but still has a copy of the data in its memory, then it has available to it the recovery options listed above in the previous bullet point. If the metadata server is also in its grace period, the client has available to it the options below in the next bullet point.",
      "ja": "Oクライアントは非同期で、ストレージデバイスにデータを書きましたが、以前の箇条書きで、上記の回復オプションを、まだ、そのメモリ内のデータのコピーを持って、それはそれで利用できる持っている場合。メタデータサーバは、その猶予期間中でもある場合、クライアントは次の箇条書きで以下のオプションも利用可能にしています。"
    },
    {
      "indent": 3,
      "text": "o The client does not have a copy of the data in its memory and the metadata server is still in its grace period. The client cannot use LAYOUTGET (within or outside the grace period) to reclaim a layout because the contents of the response from LAYOUTGET may not match what it had previously. The range might be different or the client might get the same range but the content of the layout might be different. Even if the content of the layout appears to be the same, the device IDs may map to different device addresses, and even if the device addresses are the same, the device addresses could have been assigned to a different storage device. The option of retrieving the data from the storage device and writing it to the metadata server per the recovery scenario described above is not available because, again, the mappings of range to device ID, device ID to device address, and device address to physical device are stale, and new mappings via new LAYOUTGET do not solve the problem.",
      "ja": "Oクライアントは、そのメモリ内のデータのコピーを持っていないとメタデータ・サーバは、その猶予期間中です。 LAYOUTGETからの応答の内容は、それが以前に持っていたものと一致していない可能性があるため、クライアントは、レイアウトを再利用する（猶予期間内または外）LAYOUTGETを使用することはできません。範囲は異なる可能性がありますまたはクライアントは同じ範囲を取得する可能性がありますが、レイアウトの内容が異なる場合があります。レイアウトの内容は同じように見える場合でも、デバイスIDは、異なるデバイスアドレスにマッピングすることができる、およびデバイスアドレスが同一であっても、デバイスアドレスが異なるストレージデバイスに割り当てられている可能性があります。記憶装置からデータを取得し、上記の回復シナリオごとのメタデータ・サーバに書き込むのオプションが利用できない、なぜなら、再び、物理デバイスへのデバイスID、デバイスアドレスへのデバイスID、およびデバイスのアドレス範囲のマッピング古くなっており、新しいLAYOUTGETを介した新しいマッピングは、問題を解決しません。"
    },
    {
      "indent": 6,
      "text": "The only recovery option for this scenario is to send a LAYOUTCOMMIT in reclaim mode, which the metadata server will accept as long as it is in its grace period. The use of LAYOUTCOMMIT in reclaim mode informs the metadata server that the layout has changed. It is critical that the metadata server receive this information before its grace period ends, and thus before it starts allowing updates to the file system.",
      "ja": "このシナリオのための唯一の回復オプションは、メタデータサーバがあれば、その猶予期間であるとして受け入れる、再利用モードでLAYOUTCOMMITを送信することです。再利用モードでLAYOUTCOMMITの使用は、レイアウトが変更されたメタデータ・サーバに通知します。メタデータサーバは、その猶予期間が終了する前にこの情報を受信し、したがって、それは、ファイルシステムへの更新を許可する開始する前にすることが重要です。"
    },
    {
      "indent": 6,
      "text": "To send LAYOUTCOMMIT in reclaim mode, the client sets the loca_reclaim field of the operation's arguments (Section 18.42.1) to TRUE. During the metadata server's recovery grace period (and only during the recovery grace period) the metadata server is prepared to accept LAYOUTCOMMIT requests with the loca_reclaim field set to TRUE.",
      "ja": "再利用モードでLAYOUTCOMMITを送信するには、クライアントがTRUEに操作の引数のloca_reclaimフィールド（セクション18.42.1）を設定します。 （そして唯一の回復の猶予期間中に）メタデータサーバーの回復の猶予期間中にメタデータサーバがTRUEに設定されloca_reclaimフィールドとLAYOUTCOMMIT要求を受け入れる用意があります。"
    },
    {
      "indent": 6,
      "text": "When loca_reclaim is TRUE, the client is attempting to commit changes to the layout that occurred prior to the restart of the metadata server. The metadata server applies some consistency checks on the loca_layoutupdate field of the arguments to determine whether the client can commit the data written to the storage device to the file system. The loca_layoutupdate field is of data type layoutupdate4 and contains layout-type-specific content (in the lou_body field of loca_layoutupdate). The layout-type-specific information that loca_layoutupdate might have is discussed in Section 12.5.4.3. If the metadata server's consistency checks on loca_layoutupdate succeed, then the metadata server MUST commit the data (as described by the loca_offset, loca_length, and loca_layoutupdate fields of the arguments) that was written to the storage device. If the metadata server's consistency checks on loca_layoutupdate fail, the metadata server rejects the LAYOUTCOMMIT operation and makes no changes to the file system. However, any time LAYOUTCOMMIT with loca_reclaim TRUE fails, the pNFS client has lost all the data in the range defined by <loca_offset, loca_length>. A client can defend against this risk by caching all data, whether written synchronously or asynchronously in its memory, and by not releasing the cached data until a successful LAYOUTCOMMIT. This condition does not hold true for all layout types; for example, file-based storage devices need not suffer from this limitation.",
      "ja": "loca_reclaimがTRUEの場合、クライアントは、メタデータサーバの再起動前に発生したレイアウトに変更をコミットしようとしています。メタデータサーバは、クライアントがファイルシステムにストレージデバイスに書き込まれたデータをコミットできるかどうかを判断するために、引数のloca_layoutupdateフィールド上のいくつかの整合性チェックを適用します。 loca_layoutupdateフィールドは、データ型layoutupdate4であり、（loca_layoutupdateのlou_body分野に）レイアウトタイプ固有のコンテンツを含んでいます。ている可能性がありますloca_layoutupdateレイアウト・タイプ固有の情報は、セクション12.5.4.3で議論されています。 loca_layoutupdate上のメタデータサーバーの整合性チェックが成功した場合、ストレージデバイスに書き込まれた（loca_offset、loca_length、および引数のloca_layoutupdateフィールドによって記載されているように）、その後、メタデータサーバは、データをコミットする必要があります。 loca_layoutupdate上のメタデータサーバーの整合性チェックが失敗した場合、メタデータサーバは、LAYOUTCOMMIT操作を拒否し、ファイルシステムを変更しません。しかし、TRUE loca_reclaimとLAYOUTCOMMITが失敗した任意の時間は、pNFSのクライアントは<loca_offset、loca_length>で定義された範囲内のすべてのデータを失ってしまいました。クライアントは、そのメモリ内に、成功LAYOUTCOMMITまでキャッシュされたデータを解放しないことにより、同期的または非同期的に書かれているかどうか、すべてのデータをキャッシュすることにより、このリスクを防御することができます。この条件は、すべてのレイアウトタイプのために当てはまりません。例えば、ファイルベースのストレージデバイスは、この制限に苦しむ必要はありません。"
    },
    {
      "indent": 3,
      "text": "o The client does not have a copy of the data in its memory and the metadata server is no longer in its grace period; i.e., the metadata server returns NFS4ERR_NO_GRACE. As with the scenario in the above bullet point, the failure of LAYOUTCOMMIT means the data in the range <loca_offset, loca_length> lost. The defense against the risk is the same -- cache all written data on the client until a successful LAYOUTCOMMIT.",
      "ja": "Oクライアントは、そのメモリ内のデータのコピーを持っていませんし、メタデータ・サーバは、その猶予期間中でなくなりました。すなわち、メタデータサーバはNFS4ERR_NO_GRACEを返します。上記の箇条書きにシナリオと同様に、LAYOUTCOMMITの故障は<loca_offset、loca_length>が失われた範囲のデータを意味します。リスクに対する防御は同じである - 成功LAYOUTCOMMITまで、クライアント上のすべての書き込まれたデータをキャッシュします。"
    },
    {
      "indent": 0,
      "text": "12.7.5. Operations during Metadata Server Grace Period",
      "section_title": true,
      "ja": "12.7.5. メタデータサーバーの猶予期間中の操作"
    },
    {
      "indent": 3,
      "text": "Some of the recovery scenarios thus far noted that some operations (namely, WRITE and LAYOUTGET) might be permitted during the metadata server's grace period. The metadata server may allow these operations during its grace period. For LAYOUTGET, the metadata server must reliably determine that servicing such a request will not conflict with an impending LAYOUTCOMMIT reclaim request. For WRITE, the metadata server must reliably determine that servicing the request will not conflict with an impending OPEN or with a LOCK where the file has mandatory byte-range locking enabled.",
      "ja": "回復シナリオのいくつかは、これまでいくつかの操作が（すなわち、WRITEとLAYOUTGET）メタデータサーバーの猶予期間中に許可されるかもしれないと指摘しました。メタデータサーバは、その猶予期間中にこれらの操作を可能にすることができます。 LAYOUTGETのために、メタデータサーバは、確実にそのような要求にサービスを提供することは差し迫ったLAYOUTCOMMITの再利用要求と競合しないことを決定する必要があります。 WRITEのために、メタデータサーバは、確実にリクエストを処理することは差し迫ったOPENまたはファイルは必須バイト範囲ロックが有効になっているLOCKと競合しないことを決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "As mentioned previously, for expediency, the metadata server might reject some operations (namely, WRITE and LAYOUTGET) during its grace period, because the simplest correct approach is to reject all non-reclaim pNFS requests and WRITE operations by returning the NFS4ERR_GRACE error. However, depending on the storage protocol (which is specific to the layout type) and metadata server implementation, the metadata server may be able to determine that a particular request is safe. For example, a metadata server may save provisional allocation mappings for each file to stable storage, as well as information about potentially conflicting OPEN share modes and mandatory byte-range locks that might have been in effect at the time of restart, and the metadata server may use this information during the recovery grace period to determine that a WRITE request is safe.",
      "ja": "前述したように、最も単純な正しいアプローチはNFS4ERR_GRACEエラーを返すことによって、すべての非再利用pNFSの要求と書き込み操作を拒否することであるため、便宜のために、メタデータサーバは、その猶予期間中（すなわち、WRITEとLAYOUTGET）一部の操作を拒否することがあります。しかし、（レイアウトタイプに特異的である）ストレージプロトコル及びメタデータサーバの実装に応じて、メタデータサーバは、特定の要求が安全であることを決定することができます。例えば、メタデータサーバは、安定したストレージだけでなく、潜在的にOPEN共有モードと再起動時に有効であったかもしれない必須バイト範囲ロックの競合に関する情報、およびメタデータサーバへのファイルごとに仮割当マッピングを保存することがWRITE要求が安全であることを決定するために、回復の猶予期間中にこの情報を使用することができます。"
    },
    {
      "indent": 0,
      "text": "12.7.6. Storage Device Recovery",
      "section_title": true,
      "ja": "12.7.6. ストレージデバイスの回復"
    },
    {
      "indent": 3,
      "text": "Recovery from storage device restart is mostly dependent upon the layout type in use. However, there are a few general techniques a client can use if it discovers a storage device has crashed while holding modified, uncommitted data that was asynchronously written. First and foremost, it is important to realize that the client is the only one that has the information necessary to recover non-committed data since it holds the modified data and probably nothing else does. Second, the best solution is for the client to err on the side of caution and attempt to rewrite the modified data through another path.",
      "ja": "ストレージデバイスの再起動からの回復は、使用中のレイアウトタイプに主に依存しています。しかし、それは非同期に書かれていた修正、コミットされていないデータを保持しながら、ストレージデバイスがクラッシュした検出した場合、クライアントが使用できるいくつかの一般的なテクニックがあります。まず第一に、クライアントが変更されたデータを保持し、おそらく他に何もしませんので、非コミットされたデータを回復するために必要な情報を持っている唯一のものであることを認識することが重要です。第二に、最善の解決策は、注意の側に誤ると、別の経路を通って変更されたデータを書き換えしようとするクライアントのためです。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD immediately WRITE the data to the metadata server, with the stable field in the WRITE4args set to FILE_SYNC4. Once it does this, there is no need to wait for the original storage device.",
      "ja": "クライアントはすぐにFILE_SYNC4に設定WRITE4argsで安定したフィールドで、メタデータサーバにデータを書き込む必要があります。それがこれを行うと、元のストレージデバイスを待つ必要はありません。"
    },
    {
      "indent": 0,
      "text": "12.8. Metadata and Storage Device Roles",
      "section_title": true,
      "ja": "12.8. メタデータとストレージデバイスの役割"
    },
    {
      "indent": 3,
      "text": "If the same physical hardware is used to implement both a metadata server and storage device, then the same hardware entity is to be understood to be implementing two distinct roles and it is important that it be clearly understood on behalf of which role the hardware is executing at any given time.",
      "ja": "同一の物理ハードウェアは、メタデータサーバおよび記憶装置の両方を実装するために使用される場合、同一のハードウェアエンティティは、2つの別個の役割を実装することが理解されるべきであり、それが明確にハードウェアが実行されている役割の代わりに理解することが重要です任意の時点で。"
    },
    {
      "indent": 3,
      "text": "Two sub-cases can be distinguished.",
      "ja": "二つのサブケースを区別することができます。"
    },
    {
      "indent": 3,
      "text": "1. The storage device uses NFSv4.1 as the storage protocol, i.e., the same physical hardware is used to implement both a metadata and data server. See Section 13.1 for a description of how multiple roles are handled.",
      "ja": "1ストレージ装置は、ストレージプロトコルとしてNFSv4.1を使用し、すなわち、同一の物理ハードウェアは、メタデータとデータ・サーバの両方を実装するために使用されます。どのように扱われるか複数の役割の説明については、セクション13.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "2. The storage device does not use NFSv4.1 as the storage protocol, and the same physical hardware is used to implement both a metadata and storage device. Whether distinct network addresses are used to access the metadata server and storage device is immaterial. This is because it is always clear to the pNFS client and server, from the upper-layer protocol being used (NFSv4.1 or non-NFSv4.1), to which role the request to the common server network address is directed.",
      "ja": "前記ストレージ装置は、ストレージプロトコルとしてNFSv4.1使用せず、同じ物理ハードウェアは、メタデータとストレージデバイスの両方を実装するために使用されます。個別のネットワークアドレスは、メタデータサーバとストレージデバイスにアクセスするために使用されているかどうかは重要ではありません。それは役割一般的なサーバのネットワークアドレスへの要求が向けられるために使用される上位層プロトコル（NFSv4.1または非NFSv4.1）から、常にpNFSのクライアントとサーバには明らかであるからです。"
    },
    {
      "indent": 0,
      "text": "12.9. Security Considerations for pNFS",
      "section_title": true,
      "ja": "12.9.  pNFSのためのセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "pNFS separates file system metadata and data and provides access to both. There are pNFS-specific operations (listed in Section 12.3) that provide access to the metadata; all existing NFSv4.1 conventional (non-pNFS) security mechanisms and features apply to accessing the metadata. The combination of components in a pNFS system (see Figure 1) is required to preserve the security properties of NFSv4.1 with respect to an entity that is accessing a storage device from a client, including security countermeasures to defend against threats for which NFSv4.1 provides defenses in environments where these threats are considered significant.",
      "ja": "pNFSのは、ファイルシステムのメタデータとデータを分離し、両方へのアクセスを提供します。メタデータへのアクセスを提供する（12.3節に記載されている）のpNFS固有の操作があります。すべての既存のNFSv4.1従来の（非pNFSの）セキュリティメカニズムと機能は、メタデータへのアクセスに適用されます。 pNFSのシステム内の構成要素の組み合わせは、脅威のNFSv4を防御するために、セキュリティ対策を含むクライアントからのストレージデバイスにアクセスしているエンティティに対してNFSv4.1のセキュリティ特性を維持するために必要とされる（図1参照します）。図1は、これらの脅威が重要と考えられている環境での防御を提供します。"
    },
    {
      "indent": 3,
      "text": "In some cases, the security countermeasures for connections to storage devices may take the form of physical isolation or a recommendation to avoid the use of pNFS in an environment. For example, it may be impractical to provide confidentiality protection for some storage protocols to protect against eavesdropping. In environments where eavesdropping on such protocols is of sufficient concern to require countermeasures, physical isolation of the communication channel (e.g., via direct connection from client(s) to storage device(s)) and/or a decision to forgo use of pNFS (e.g., and fall back to conventional NFSv4.1) may be appropriate courses of action.",
      "ja": "いくつかのケースでは、ストレージデバイスへの接続のためのセキュリティ対策は、環境中のpNFSの使用を避けるために、物理的な隔離や勧告の形をとることができます。例えば、盗聴から保護するために、いくつかのストレージプロトコルのための機密保護を提供するために実用的ではありません。そのようなプロトコルの盗聴が（記憶装置（複数可）へのクライアント（複数可）からの直接接続を介して、例えば、）対策を必要とするのに十分な関心、通信チャネルの物理的な分離である環境および/またはpNFSのの使用を差し控えることを決定（IN例えば、バック従来NFSv4.1にフォール）は、アクションの適切なコースかもしれません。"
    },
    {
      "indent": 3,
      "text": "Where communication with storage devices is subject to the same threats as client-to-metadata server communication, the protocols used for that communication need to provide security mechanisms as strong as or no weaker than those available via RPCSEC_GSS for NFSv4.1. Except for the storage protocol used for the LAYOUT4_NFSV4_1_FILES layout (see Section 13), i.e., except for NFSv4.1, it is beyond the scope of this document to specify the security mechanisms for storage access protocols.",
      "ja": "ストレージ・デバイスとの通信は、クライアントとメタデータサーバ間の通信と同じ脅威にさらされる場合には、その通信のために使用されるプロトコルは同じくらい強いかNFSv4.1ためRPCSEC_GSSを経由して利用可能なものに過ぎない弱いセキュリティメカニズムを提供する必要があります。 LAYOUT4_NFSV4_1_FILESレイアウトに使用されるストレージ・プロトコル以外はNFSv4.1を除いては、ストレージ・アクセス・プロトコルのためのセキュリティ・メカニズムを指定するには、この文書の範囲を超えて、即ち、（第13章を参照のこと）。"
    },
    {
      "indent": 3,
      "text": "pNFS implementations MUST NOT remove NFSv4.1's access controls. The combination of clients, storage devices, and the metadata server are responsible for ensuring that all client-to-storage-device file data access respects NFSv4.1's ACLs and file open modes. This entails performing both of these checks on every access in the client, the storage device, or both (as applicable; when the storage device is an NFSv4.1 server, the storage device is ultimately responsible for controlling access as described in Section 13.9.2). If a pNFS configuration performs these checks only in the client, the risk of a misbehaving client obtaining unauthorized access is an important consideration in determining when it is appropriate to use such a pNFS configuration. Such layout types SHOULD NOT be used when client-only access checks do not provide sufficient assurance that NFSv4.1 access control is being applied correctly. (This is not a problem for the file layout type described in Section 13 because the storage access protocol for LAYOUT4_NFSV4_1_FILES is NFSv4.1, and thus the security model for storage device access via LAYOUT4_NFSv4_1_FILES is the same as that of the metadata server.) For handling of access control specific to a layout, the reader should examine the layout specification, such as the NFSv4.1/ file-based layout (Section 13) of this document, the blocks layout [41], and objects layout [40].",
      "ja": "pNFSの実装はNFSv4.1のアクセス制御を削除してはなりません。クライアント、ストレージデバイスの組み合わせ、およびメタデータサーバは、すべてのクライアント・ツー・ストレージ・デバイスのファイルデータへのアクセスがNFSv4.1のACLを尊重し、オープンモードを提出することを確保する責任があります。これは、クライアント内のすべてのアクセス、記憶装置、またはその両方（該当する場合にこれらのチェックの両方を行うことを伴う、記憶装置はNFSv4.1サーバである場合、記憶装置は、セクション13.9で説明したようにアクセスを制御するための最終的な責任です。 2）。 pNFSの構成がクライアントにのみ、これらのチェックを実行した場合、不正なアクセスを得る誤動作クライアントのリスクは、そのようなpNFSの構成を使用することが適切であるときを決定する上で重要な考慮事項です。クライアントのみのアクセスチェックがNFSv4.1アクセス制御が正しく適用されていることを十分に保証を提供していない場合、そのようなレイアウトのタイプを使用しないでください。 （LAYOUT4_NFSV4_1_FILESためのストレージアクセスプロトコルはNFSv4.1であり、したがってLAYOUT4_NFSv4_1_FILESを介して記憶装置へのアクセスのためのセキュリティモデルは、メタデータサーバと同じであるので、これは、セクション13で説明したファイルレイアウトタイプに問題ではありません。）についてレイアウトへの特定のアクセス制御の取り扱い、読者は、NFSv4.1 /ファイルベースのレイアウト、この文書の（セクション13）、ブロックレイアウト[41]のように、レイアウト仕様を調べ、レイアウトオブジェクトなければならない[40]。"
    },
    {
      "indent": 0,
      "text": "13. NFSv4.1 as a Storage Protocol in pNFS: the File Layout Type",
      "section_title": true,
      "ja": "ファイルのレイアウトタイプ：pNFSの中ストレージプロトコルとして13 NFSv4.1"
    },
    {
      "indent": 3,
      "text": "This section describes the semantics and format of NFSv4.1 file-based layouts for pNFS. NFSv4.1 file-based layouts use the LAYOUT4_NFSV4_1_FILES layout type. The LAYOUT4_NFSV4_1_FILES type defines striping data across multiple NFSv4.1 data servers.",
      "ja": "このセクションでは、pNFSのためのNFSv4.1ファイルベースのレイアウトの意味と形式について説明します。 NFSv4.1ファイルベースのレイアウトはLAYOUT4_NFSV4_1_FILESレイアウトタイプを使用します。 LAYOUT4_NFSV4_1_FILESタイプは、複数のNFSv4.1データサーバー間でストライピングデータを定義します。"
    },
    {
      "indent": 0,
      "text": "13.1. Client ID and Session Considerations",
      "section_title": true,
      "ja": "13.1. クライアントIDとセッションの考慮事項"
    },
    {
      "indent": 3,
      "text": "Sessions are a REQUIRED feature of NFSv4.1, and this extends to both the metadata server and file-based (NFSv4.1-based) data servers.",
      "ja": "セッションはNFSv4.1の必須の機能であり、これは、メタデータサーバおよびファイルベース（NFSv4.1ベース）のデータ・サーバの両方に及びます。"
    },
    {
      "indent": 3,
      "text": "The role a server plays in pNFS is determined by the result it returns from EXCHANGE_ID. The roles are:",
      "ja": "サーバーはpNFSの中で果たしている役割は、それがEXCHANGE_IDから返された結果によって決定されます。役割は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Metadata server (EXCHGID4_FLAG_USE_PNFS_MDS is set in the result eir_flags).",
      "ja": "Oメタデータサーバ（EXCHGID4_FLAG_USE_PNFS_MDSが結果eir_flagsに設定されています）。"
    },
    {
      "indent": 3,
      "text": "o Data server (EXCHGID4_FLAG_USE_PNFS_DS).",
      "ja": "Oデータ・サーバ（EXCHGID4_FLAG_USE_PNFS_DS）。"
    },
    {
      "indent": 3,
      "text": "o Non-metadata server (EXCHGID4_FLAG_USE_NON_PNFS). This is an NFSv4.1 server that does not support operations (e.g., LAYOUTGET) or attributes that pertain to pNFS.",
      "ja": "O非メタデータサーバ（EXCHGID4_FLAG_USE_NON_PNFS）。これは、pNFSのに関連する操作（例えば、LAYOUTGET）または属性をサポートしていないNFSv4.1サーバーです。"
    },
    {
      "indent": 3,
      "text": "The client MAY request zero or more of EXCHGID4_FLAG_USE_NON_PNFS, EXCHGID4_FLAG_USE_PNFS_DS, or EXCHGID4_FLAG_USE_PNFS_MDS, even though some combinations (e.g., EXCHGID4_FLAG_USE_NON_PNFS | EXCHGID4_FLAG_USE_PNFS_MDS) are contradictory. However, the server MUST only return the following acceptable combinations:",
      "ja": "矛盾している|クライアントは、いくつかの組み合わせ（EXCHGID4_FLAG_USE_PNFS_MDS例えば、EXCHGID4_FLAG_USE_NON_PNFSは）にもかかわらず、EXCHGID4_FLAG_USE_NON_PNFS、EXCHGID4_FLAG_USE_PNFS_DS、またはEXCHGID4_FLAG_USE_PNFS_MDSのゼロ個以上を要求することができます。ただし、サーバーは、以下の許容可能な組み合わせを返す必要があります。"
    },
    {
      "indent": 8,
      "text": "+--------------------------------------------------------+\n| Acceptable Results from EXCHANGE_ID                    |\n+--------------------------------------------------------+\n| EXCHGID4_FLAG_USE_PNFS_MDS                             |\n| EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_PNFS_DS |\n| EXCHGID4_FLAG_USE_PNFS_DS                              |\n| EXCHGID4_FLAG_USE_NON_PNFS                             |\n| EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_NON_PNFS |\n+--------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "As the above table implies, a server can have one or two roles. A server can be both a metadata server and a data server, or it can be both a data server and non-metadata server. In addition to returning two roles in the EXCHANGE_ID's results, and thus serving both roles via a common client ID, a server can serve two roles by returning a unique client ID and server owner for each role in each of two EXCHANGE_ID results, with each result indicating each role.",
      "ja": "上記の表が示すように、サーバーは、1つのまたは2つの役割を持つことができます。サーバは、メタデータ・サーバとデータ・サーバの両方にすることも、データ・サーバと非メタデータサーバ両方にすることができます。 EXCHANGE_IDの結果には二つの役割を返すため、一般的なクライアントIDを経由して両方の役割を提供することに加えて、サーバは、各結果と、2つのEXCHANGE_ID結果の各役割ごとに固有のクライアントIDとサーバの所有者を返すことによって、二つの役割を果たすことができますそれぞれの役割を示しています。"
    },
    {
      "indent": 3,
      "text": "In the case of a server with concurrent pNFS roles that are served by a common client ID, if the EXCHANGE_ID request from the client has zero or a combination of the bits set in eia_flags, the server result should set bits that represent the higher of the acceptable combination of the server roles, with a preference to match the roles requested by the client. Thus, if a client request has (EXCHGID4_FLAG_USE_NON_PNFS | EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_PNFS_DS) flags set, and the server is both a metadata server and a data server, serving both the roles by a common client ID, the server SHOULD return with (EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_PNFS_DS) set.",
      "ja": "クライアントからEXCHANGE_ID要求がゼロ又はeia_flagsに設定されたビットの組み合わせを持っている場合、サーバ結果は、より高い表すビットを設定する必要があり、共通のクライアントIDによって配信される同時pNFSの役割を持つサーバーの場合好みにサーバーの役割の許容可能な組み合わせは、クライアントから要求された役割と一致します。 （| EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_NON_PNFS EXCHGID4_FLAG_USE_PNFS_DS）クライアントの要求がある場合はこのように、フラグが設定され、サーバーが共通のクライアントIDでの役割の両方を提供し、メタデータ・サーバとデータ・サーバの両方で、サーバーがで返すべきである（EXCHGID4_FLAG_USE_PNFS_MDS | EXCHGID4_FLAG_USE_PNFS_DS）セットする。"
    },
    {
      "indent": 3,
      "text": "In the case of a server that has multiple concurrent pNFS roles, each role served by a unique client ID, if the client specifies zero or a combination of roles in the request, the server results SHOULD return only one of the roles from the combination specified by the client request. If the role specified by the server result does not match the intended use by the client, the client should send the EXCHANGE_ID specifying just the interested pNFS role.",
      "ja": "クライアントがゼロか、要求における役割の組み合わせを指定している場合、一意のクライアントIDによって提供されるそれぞれの役割を複数の同時pNFSの役割を持つサーバーの場合は、サーバーの結果は、指定された組み合わせから役割の一つだけを返すべきクライアント要求による。サーバーの結果によって指定された役割は、クライアントによって、使用目的と一致しない場合、クライアントは単に興味pNFSの役割を指定するEXCHANGE_IDを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a pNFS metadata client gets a layout that refers it to an NFSv4.1 data server, it needs a client ID on that data server. If it does not yet have a client ID from the server that had the EXCHGID4_FLAG_USE_PNFS_DS flag set in the EXCHANGE_ID results, then the client needs to send an EXCHANGE_ID to the data server, using the same co_ownerid as it sent to the metadata server, with the EXCHGID4_FLAG_USE_PNFS_DS flag set in the arguments. If the server's EXCHANGE_ID results have EXCHGID4_FLAG_USE_PNFS_DS set, then the client may use the client ID to create sessions that will exchange pNFS data operations. The client ID returned by the data server has no relationship with the client ID returned by a metadata server unless the client IDs are equal, and the server owners and server scopes of the data server and metadata server are equal.",
      "ja": "pNFSのメタデータクライアントはNFSv4.1データサーバーにそれを参照するレイアウトを取得した場合、そのデータ・サーバ上のクライアントIDを必要とします。それはまだEXCHANGE_ID結果に設定されEXCHGID4_FLAG_USE_PNFS_DSフラグを持っていた、サーバーからクライアントIDを持っていない場合、クライアントはと、それはメタデータサーバに送信されたのと同じco_owneridを使用して、データ・サーバにEXCHANGE_IDを送信する必要があります引数に設定されEXCHGID4_FLAG_USE_PNFS_DSフラグ。サーバーのEXCHANGE_ID結果はEXCHGID4_FLAG_USE_PNFS_DSが設定している場合、クライアントはpNFSのデータ操作を交換するセッションを作成するために、クライアントのIDを使用することができます。データ・サーバから返されたクライアントIDは、クライアントIDが同じである場合を除き、メタデータ・サーバによって返されたクライアントIDとは関係がなく、データ・サーバとメタデータサーバーのサーバーの所有者とサーバーのスコープは同じです。"
    },
    {
      "indent": 3,
      "text": "In NFSv4.1, the session ID in the SEQUENCE operation implies the client ID, which in turn might be used by the server to map the stateid to the right client/server pair. However, when a data server is presented with a READ or WRITE operation with a stateid, because the stateid is associated with a client ID on a metadata server, and because the session ID in the preceding SEQUENCE operation is tied to the client ID of the data server, the data server has no obvious way to determine the metadata server from the COMPOUND procedure, and thus has no way to validate the stateid. One RECOMMENDED approach is for pNFS servers to encode metadata server routing and/or identity information in the data server filehandles as returned in the layout.",
      "ja": "NFSv4.1では、シーケンス動作中のセッションIDは、順番に右のクライアント/サーバのペアへのstateidをマップするために、サーバによって使用される可能性のあるクライアントのIDを、意味しています。ただし、のstateidは、メタデータサーバ上のクライアントIDに関連付けられているため、先行シーケンス動作中のセッションIDをクライアントIDに関連付けられているため、データ・サーバは、のstateidとREADまたはWRITE動作に提示されたときデータ・サーバは、データ・サーバは、COMPOUND手順からメタデータ・サーバを決定するための明白な方法を持っていないので、たstateidを検証する方法はありません。一の推奨されるアプローチは、レイアウトに返されるpNFSのサーバがデータサーバファイルハンドルのメタデータサーバのルーティングおよび/または識別情報を符号化するためのものです。"
    },
    {
      "indent": 3,
      "text": "If metadata server routing and/or identity information is encoded in data server filehandles, when the metadata server identity or location changes, the data server filehandles it gave out will become invalid (stale), and so the metadata server MUST first recall the layouts. Invalidating a data server filehandle does not render the NFS client's data cache invalid. The client's cache should map a data server filehandle to a metadata server filehandle, and a metadata server filehandle to cached data.",
      "ja": "メタデータサーバのルーティングおよび/または識別情報がメタデータサーバの同一性または位置の変更は、データ・サーバは、ファイルハンドルのデータ・サーバ・ファイルハンドル、にエンコードされている場合、それは無効（失効）になるであろうアウト与え、そのため、メタデータサーバは、最初のレイアウトをリコールしなければなりません。 NFSクライアントのデータキャッシュが無効にレンダリングされませんファイルハンドルのデータ・サーバを無効化。クライアントのキャッシュは、キャッシュされたデータにメタデータサーバのファイルハンドルへのデータ・サーバのファイルハンドル、およびメタデータサーバのファイルハンドルをマップする必要があります。"
    },
    {
      "indent": 3,
      "text": "If a server is both a metadata server and a data server, the server might need to distinguish operations on files that are directed to the metadata server from those that are directed to the data server. It is RECOMMENDED that the values of the filehandles returned by the LAYOUTGET operation be different than the value of the filehandle returned by the OPEN of the same file.",
      "ja": "サーバは、メタデータ・サーバとデータ・サーバの両方である場合、サーバはデータサーバに送られているものから、メタデータ・サーバに送信されたファイルに対する操作を区別する必要がある場合があります。 LAYOUTGET操作によって返されたファイルハンドルの値が同じファイルのOPENによって返されたファイルハンドルの値と異なることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Another scenario is for the metadata server and the storage device to be distinct from one client's point of view, and the roles reversed from another client's point of view. For example, in the cluster file system model, a metadata server to one client might be a data server to another client. If NFSv4.1 is being used as the storage protocol, then pNFS servers need to encode the values of filehandles according to their specific roles.",
      "ja": "別のシナリオでは、メタデータサーバとストレージデバイスビューの1つのクライアントの視点から区別すべき、とビューの別のクライアントの視点から反転した役割のためです。たとえば、クラスタファイルシステムモデルに、1つのクライアントにメタデータサーバは別のクライアントへのデータ・サーバであるかもしれません。 NFSv4.1ストレージプロトコルとして使用されている場合、その後のpNFSサーバは、それらの特定の役割に応じてファイルハンドルの値を符号化するために必要。"
    },
    {
      "indent": 0,
      "text": "13.1.1. Sessions Considerations for Data Servers",
      "section_title": true,
      "ja": "13.1.1. データ・サーバーのためのセッションの考慮事項"
    },
    {
      "indent": 3,
      "text": "Section 2.10.11.2 states that a client has to keep its lease renewed in order to prevent a session from being deleted by the server. If the reply to EXCHANGE_ID has just the EXCHGID4_FLAG_USE_PNFS_DS role set, then (as noted in Section 13.6) the client will not be able to determine the data server's lease_time attribute because GETATTR will not be permitted. Instead, the rule is that any time a client receives a layout referring it to a data server that returns just the EXCHGID4_FLAG_USE_PNFS_DS role, the client MAY assume that the lease_time attribute from the metadata server that returned the layout applies to the data server. Thus, the data server MUST be aware of the values of all lease_time attributes of all metadata servers for which it is providing I/O, and it MUST use the maximum of all such lease_time values as the lease interval for all client IDs and sessions established on it.",
      "ja": "クライアントがサーバによって削除されたセッションを防ぐために、新たなリースを維持するために持っていると述べて2.10.11.2節。 EXCHANGE_IDへの返信がちょうどEXCHGID4_FLAG_USE_PNFS_DSの役割が設定されている場合はGETATTRが許可されないため、その後、（セクション13.6で述べたように）クライアントは、データ・サーバのlease_time属性を決定することができません。代わりに、ルールは、クライアントがちょうどEXCHGID4_FLAG_USE_PNFS_DSの役割を返し、データ・サーバにそれを参照するレイアウトを受け取る任意の時間は、クライアントがレイアウトを返されたメタデータサーバからlease_time属性は、データ・サーバに適用されることを仮定してもよいということです。このように、データ・サーバは、それがI / Oを提供されているすべてのメタデータ・サーバのすべてのlease_time属性の値を認識する必要があり、それが確立されたすべてのクライアントIDとセッションのリース期間としてこのようなすべてのlease_time値の最大値を使用しなければなりませんその上に。"
    },
    {
      "indent": 3,
      "text": "For example, if one metadata server has a lease_time attribute of 20 seconds, and a second metadata server has a lease_time attribute of 10 seconds, then if both servers return layouts that refer to an",
      "ja": "1つのメタデータサーバは、20秒のlease_time属性を有し、第2のメタデータ・サーバは、10秒のlease_time属性を持っている場合たとえば、その後、両方のサーバーが参照レイアウトを返す場合"
    },
    {
      "indent": 3,
      "text": "EXCHGID4_FLAG_USE_PNFS_DS-only data server, the data server MUST renew a client's lease if the interval between two SEQUENCE operations on different COMPOUND requests is less than 20 seconds.",
      "ja": "異なるCOMPOUND要求上の2つのSEQUENCEの操作間の間隔は20秒未満である場合EXCHGID4_FLAG_USE_PNFS_DS専用データ・サーバは、データ・サーバは、クライアントのリースを更新しなければなりません。"
    },
    {
      "indent": 0,
      "text": "13.2. File Layout Definitions",
      "section_title": true,
      "ja": "13.2. ファイル・レイアウトの定義"
    },
    {
      "indent": 3,
      "text": "The following definitions apply to the LAYOUT4_NFSV4_1_FILES layout type and may be applicable to other layout types.",
      "ja": "以下の定義はLAYOUT4_NFSV4_1_FILESレイアウトタイプに適用され、他のレイアウトタイプにも適用可能です。"
    },
    {
      "indent": 3,
      "text": "Unit. A unit is a fixed-size quantity of data written to a data server.",
      "ja": "単位。ユニットは、データ・サーバに書き込まれたデータの固定サイズの量です。"
    },
    {
      "indent": 3,
      "text": "Pattern. A pattern is a method of distributing one or more equal sized units across a set of data servers. A pattern is iterated one or more times.",
      "ja": "パターン。パターンは、データ・サーバのセットを横切って一つ以上の等しいサイズの単位を分配する方法です。パターンは、1回以上繰り返されます。"
    },
    {
      "indent": 3,
      "text": "Stripe. A stripe is a set of data distributed across a set of data servers in a pattern before that pattern repeats.",
      "ja": "ストライプ。ストライプは、そのパターンが繰り返される前に、パターン内のデータ・サーバのセット全体に分散したデータの集合です。"
    },
    {
      "indent": 3,
      "text": "Stripe Count. A stripe count is the number of units in a pattern.",
      "ja": "ストライプカウント。ストライプの数は、パターン内のユニットの数です。"
    },
    {
      "indent": 3,
      "text": "Stripe Width. A stripe width is the size of a stripe in bytes. The stripe width = the stripe count * the size of the stripe unit.",
      "ja": "ストライプ幅。ストライプの幅は、バイト単位でストライプのサイズです。ストライプ幅=ストライプ・カウント*ストライプユニットのサイズ。"
    },
    {
      "indent": 3,
      "text": "Hereafter, this document will refer to a unit that is a written in a pattern as a \"stripe unit\".",
      "ja": "以下、本文書では「ストライプ単位」としてパターンに書き込まれる単位を指します。"
    },
    {
      "indent": 3,
      "text": "A pattern may have more stripe units than data servers. If so, some data servers will have more than one stripe unit per stripe. A data server that has multiple stripe units per stripe MAY store each unit in a different data file (and depending on the implementation, will possibly assign a unique data filehandle to each data file).",
      "ja": "パターンは、データ・サーバよりも多くのストライプユニットを有することができます。その場合、一部のデータ・サーバは、ストライプごとに複数のストライプユニットを持つことになります。ストライプごとに複数のストライプユニットを有するデータ・サーバは、異なるデータ・ファイル内の各ユニットを格納することができる（及び実装に応じて、おそらく各データファイルに固有のデータファイルハンドルが割り当てられます）。"
    },
    {
      "indent": 0,
      "text": "13.3. File Layout Data Types",
      "section_title": true,
      "ja": "13.3. レイアウトデータ型ファイル"
    },
    {
      "indent": 3,
      "text": "The high level NFSv4.1 layout types are nfsv4_1_file_layouthint4, nfsv4_1_file_layout_ds_addr4, and nfsv4_1_file_layout4.",
      "ja": "ハイレベルNFSv4.1レイアウトタイプは、nfsv4_1_file_layouthint4 nfsv4_1_file_layout_ds_addr4、及びnfsv4_1_file_layout4あります。"
    },
    {
      "indent": 3,
      "text": "The SETATTR operation supports a layout hint attribute (Section 5.12.4). When the client sets a layout hint (data type layouthint4) with a layout type of LAYOUT4_NFSV4_1_FILES (the loh_type field), the loh_body field contains a value of data type nfsv4_1_file_layouthint4.",
      "ja": "SETATTR操作は、レイアウトのヒント属性（セクション5.12.4）をサポートしています。クライアントがLAYOUT4_NFSV4_1_FILES（loh_typeフィールド）のレイアウトタイプとレイアウトヒント（データ型layouthint4）を設定した場合、loh_bodyフィールドは、データ型nfsv4_1_file_layouthint4の値を含みます。"
    },
    {
      "indent": 3,
      "text": "const NFL4_UFLG_MASK            = 0x0000003F;\nconst NFL4_UFLG_DENSE           = 0x00000001;\nconst NFL4_UFLG_COMMIT_THRU_MDS = 0x00000002;\nconst NFL4_UFLG_STRIPE_UNIT_SIZE_MASK\n                                = 0xFFFFFFC0;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "typedef uint32_t nfl_util4;",
      "ja": "typedefでのuint32_t nfl_util4。"
    },
    {
      "indent": 3,
      "text": "enum filelayout_hint_care4 { NFLH4_CARE_DENSE = NFL4_UFLG_DENSE,",
      "ja": "列挙filelayout_hint_care4 {NFLH4_CARE_DENSE = NFL4_UFLG_DENSE、"
    },
    {
      "indent": 11,
      "text": "NFLH4_CARE_COMMIT_THRU_MDS\n                        = NFL4_UFLG_COMMIT_THRU_MDS,",
      "raw": true
    },
    {
      "indent": 11,
      "text": "NFLH4_CARE_STRIPE_UNIT_SIZE = 0x00000040,",
      "ja": "NFLH4_CARE_STRIPE_UNIT_SIZE = 0x00000040、"
    },
    {
      "indent": 3,
      "text": " NFLH4_CARE_STRIPE_COUNT = 0x00000080 };",
      "ja": "NFLH4_CARE_STRIPE_COUNT = 0x00000080}。"
    },
    {
      "indent": 3,
      "text": "/* Encoded in the loh_body field of data type layouthint4: */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct nfsv4_1_file_layouthint4 {\n        uint32_t        nflh_care;\n        nfl_util4       nflh_util;\n        count4          nflh_stripe_count;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The generic layout hint structure is described in Section 3.3.19. The client uses the layout hint in the layout_hint (Section 5.12.4) attribute to indicate the preferred type of layout to be used for a newly created file. The LAYOUT4_NFSV4_1_FILES layout-type-specific content for the layout hint is composed of three fields. The first field, nflh_care, is a set of flags indicating which values of the hint the client cares about. If the NFLH4_CARE_DENSE flag is set, then the client indicates in the second field, nflh_util, a preference for how the data file is packed (Section 13.4.4), which is controlled by the value of the expression nflh_util & NFL4_UFLG_DENSE (\"&\" represents the bitwise AND operator). If the NFLH4_CARE_COMMIT_THRU_MDS flag is set, then the client indicates a preference for whether the client should send COMMIT operations to the metadata server or data server (Section 13.7), which is controlled by the value of nflh_util & NFL4_UFLG_COMMIT_THRU_MDS. If the NFLH4_CARE_STRIPE_UNIT_SIZE flag is set, the client indicates its preferred stripe unit size, which is indicated in nflh_util & NFL4_UFLG_STRIPE_UNIT_SIZE_MASK (thus, the stripe unit size MUST be a multiple of 64 bytes). The minimum stripe unit size is 64 bytes. If the NFLH4_CARE_STRIPE_COUNT flag is set, the client indicates in the third field, nflh_stripe_count, the stripe count. The stripe count multiplied by the stripe unit size is the stripe width.",
      "ja": "一般的なレイアウトのヒント構造は、セクション3.3.19に記載されています。クライアントはlayout_hint（セクション5.12.4）でレイアウトのヒントを使用して、新しく作成されたファイルに使用されるように、レイアウトの好ましい型を示すために属性。レイアウトヒントのLAYOUT4_NFSV4_1_FILESレイアウト・タイプ固有のコンテンツを三つのフィールドで構成されています。最初のフィールドは、nflh_care、クライアントは気ヒント値かを示すフラグのセットです。 NFLH4_CARE_DENSEフラグが設定されている場合、クライアントは、第2のフィールド、nflh_utilに示し、どのようにデータファイルの嗜好が充填されている（セクション13.4.4）、発現nflh_util＆NFL4_UFLG_DENSEの値によって制御されます（「＆」ビット単位のAND演算子）を表しています。 NFLH4_CARE_COMMIT_THRU_MDSフラグが設定されている場合、クライアントは、クライアントがnflh_util＆NFL4_UFLG_COMMIT_THRU_MDSの値によって制御されるメタデータサーバまたはデータサーバ（セクション13.7）にCOMMIT操作を送信するかどうかに対する選好を示します。 NFLH4_CARE_STRIPE_UNIT_SIZEフラグが設定されている場合、クライアントはnflh_util＆NFL4_UFLG_STRIPE_UNIT_SIZE_MASKに示されているその好ましいストライプユニットサイズは、（従って、ストライプユニットサイズは64バイトの倍数でなければならない）を示しています。最小ストライプユニットサイズは64バイトです。 NFLH4_CARE_STRIPE_COUNTフラグが設定されている場合、クライアントは3番目のフィールド、nflh_stripe_count、ストライプ数で示します。ストライプユニットサイズを掛けたストライプ数は、ストライプ幅です。"
    },
    {
      "indent": 3,
      "text": "When LAYOUTGET returns a LAYOUT4_NFSV4_1_FILES layout (indicated in the loc_type field of the lo_content field), the loc_body field of the lo_content field contains a value of data type nfsv4_1_file_layout4. Among other content, nfsv4_1_file_layout4 has a storage device ID (field nfl_deviceid) of data type deviceid4. The GETDEVICEINFO operation maps a device ID to a storage device address (type device_addr4). When GETDEVICEINFO returns a device address with a layout type of LAYOUT4_NFSV4_1_FILES (the da_layout_type field), the da_addr_body field contains a value of data type nfsv4_1_file_layout_ds_addr4.",
      "ja": "LAYOUTGETは（lo_contentフィールドのloc_typeフィールドに示されている）LAYOUT4_NFSV4_1_FILESレイアウトを返す場合、lo_contentフィールドのloc_bodyフィールドは、データ型nfsv4_1_file_layout4の値を含みます。他のコンテンツのうち、nfsv4_1_file_layout4は、データ型deviceid4の記憶デバイスID（フィールドnfl_deviceid）を有しています。 GETDEVICEINFO動作は、記憶装置アドレス（タイプdevice_addr4）にデバイスIDをマッピングします。 GETDEVICEINFOはLAYOUT4_NFSV4_1_FILES（da_layout_typeフィールド）のレイアウトタイプとデバイスアドレスを返す場合、da_addr_bodyフィールドは、データ型nfsv4_1_file_layout_ds_addr4の値を含みます。"
    },
    {
      "indent": 3,
      "text": "typedef netaddr4 multipath_list4<>;",
      "ja": "typedefのnetaddr4 multipath_list4 <>。"
    },
    {
      "indent": 3,
      "text": "/*\n * Encoded in the da_addr_body field of\n * data type device_addr4:\n */\nstruct nfsv4_1_file_layout_ds_addr4 {\n        uint32_t        nflda_stripe_indices<>;\n        multipath_list4 nflda_multipath_ds_list<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The nfsv4_1_file_layout_ds_addr4 data type represents the device address. It is composed of two fields:",
      "ja": "nfsv4_1_file_layout_ds_addr4データタイプは、デバイスアドレスを表します。これは、2つのフィールドから構成されています。"
    },
    {
      "indent": 3,
      "text": "1. nflda_multipath_ds_list: An array of lists of data servers, where each list can be one or more elements, and each element represents a data server address that may serve equally as the target of I/O operations (see Section 13.5). The length of this array might be different than the stripe count.",
      "ja": "1. nflda_multipath_ds_list：各リストは、1つ以上の要素であることができるデータ・サーバのリストのアレイと、各要素がI / O操作（セクション13.5を参照）の対象と同等に機能することができるデータ・サーバのアドレスを表します。この配列の長さは、ストライプ数と異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "2. nflda_stripe_indices: An array of indices used to index into nflda_multipath_ds_list. The value of each element of nflda_stripe_indices MUST be less than the number of elements in nflda_multipath_ds_list. Each element of nflda_multipath_ds_list SHOULD be referred to by one or more elements of nflda_stripe_indices. The number of elements in nflda_stripe_indices is always equal to the stripe count.",
      "ja": "2. nflda_stripe_indices：nflda_multipath_ds_listへのインデックスに使用されるインデックスのアレイ。 nflda_stripe_indicesの各要素の値はnflda_multipath_ds_listの要素数よりも小さくなければなりません。 nflda_multipath_ds_listの各要素はnflda_stripe_indicesの1つのまたは複数の要素によって参照されたいです。 nflda_stripe_indices内の要素の数は、常にストライプ数に等しいです。"
    },
    {
      "indent": 3,
      "text": "/*\n * Encoded in the loc_body field of\n * data type layout_content4:\n */\nstruct nfsv4_1_file_layout4 {\n         deviceid4      nfl_deviceid;\n         nfl_util4      nfl_util;\n         uint32_t       nfl_first_stripe_index;\n         offset4        nfl_pattern_offset;\n         nfs_fh4        nfl_fh_list<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The nfsv4_1_file_layout4 data type represents the layout. It is composed of the following fields:",
      "ja": "nfsv4_1_file_layout4データタイプは、レイアウトを表します。それは、次のフィールドで構成されています。"
    },
    {
      "indent": 3,
      "text": "1. nfl_deviceid: The device ID that maps to a value of type nfsv4_1_file_layout_ds_addr4.",
      "ja": "1. nfl_deviceid：タイプnfsv4_1_file_layout_ds_addr4の値にマップするデバイスID。"
    },
    {
      "indent": 3,
      "text": "2. nfl_util: Like the nflh_util field of data type nfsv4_1_file_layouthint4, a compact representation of how the data on a file on each data server is packed, whether the client should send COMMIT operations to the metadata server or data server, and the stripe unit size. If a server returns two or more overlapping layouts, each stripe unit size in each overlapping layout MUST be the same.",
      "ja": "2. nfl_util：データ型nfsv4_1_file_layouthint4のnflh_util分野と同様に、各データ・サーバ上のファイルにデータをパックする方法のコンパクトな表現、クライアントは、メタデータサーバやデータサーバ、およびストライプユニットサイズにCOMMIT操作を送信するかどうか。サーバは、2つの以上の重複レイアウトを返す場合、各重複レイアウトにおける各ストライプユニットサイズは同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. nfl_first_stripe_index: The index into the first element of the nflda_stripe_indices array to use.",
      "ja": "3. nfl_first_stripe_index：nflda_stripe_indices配列の最初の要素へのインデックスを使用します。"
    },
    {
      "indent": 3,
      "text": "4. nfl_pattern_offset: This field is the logical offset into the file where the striping pattern starts. It is required for converting the client's logical I/O offset (e.g., the current offset in a POSIX file descriptor before the read() or write() system call is sent) into the stripe unit number (see Section 13.4.1).",
      "ja": "4. nfl_pattern_offset：このフィールドは、ストライピングパターンが開始されるファイルへのオフセット論理的です。これは、ストライプユニット番号（項13.4.1を参照）の中に、クライアントの論理I / Oのオフセット（例えば、読み取りの前にPOSIXファイルディスクリプタ（現在のオフセット）やwrite（）システムコールが送られる）に変換するために必要です。"
    },
    {
      "indent": 7,
      "text": "If dense packing is used, then nfl_pattern_offset is also needed\nto convert the client's logical I/O offset to an offset on the\nfile on the data server corresponding to the stripe unit number\n(see Section 13.4.4).",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Note that nfl_pattern_offset is not always the same as lo_offset. For example, via the LAYOUTGET operation, a client might request a layout starting at offset 1000 of a file that has its striping pattern start at offset zero.",
      "ja": "nfl_pattern_offsetは常にlo_offsetと同じではないことに注意してください。例えば、LAYOUTGET操作によって、クライアントはから始まるレイアウトを要求するかもしれない1000年をオフセットのストライプパターンを持つファイルので始まりゼロを相殺しました。"
    },
    {
      "indent": 3,
      "text": "5. nfl_fh_list: An array of data server filehandles for each list of data servers in each element of the nflda_multipath_ds_list array. The number of elements in nfl_fh_list depends on whether sparse or dense packing is being used.",
      "ja": "5. nfl_fh_list：nflda_multipath_ds_list配列の各要素におけるデータ・サーバの各リストのデータ・サーバのファイルハンドルの配列。 nfl_fh_list内の要素の数は、疎または密なパッキングが使用されているかどうかに依存します。"
    },
    {
      "indent": 7,
      "text": "*  If sparse packing is being used, the number of elements in\n   nfl_fh_list MUST be one of three values:",
      "raw": true
    },
    {
      "indent": 10,
      "text": "+ Zero. This means that filehandles used for each data server are the same as the filehandle returned by the OPEN operation from the metadata server.",
      "ja": "+ゼロ。これは、各データ・サーバで使用ファイルハンドルは、メタデータサーバからOPEN操作によって返されたファイルハンドルと同じであることを意味します。"
    },
    {
      "indent": 10,
      "text": "+ One. This means that every data server uses the same filehandle: what is specified in nfl_fh_list[0].",
      "ja": "ワン+。これは、すべてのデータ・サーバが同じファイルハンドルを使用することを意味します：[0] nfl_fh_listに指定されているもの。"
    },
    {
      "indent": 10,
      "text": "+ The same number of elements in nflda_multipath_ds_list. Thus, in this case, when sending an I/O operation to any data server in nflda_multipath_ds_list[X], the filehandle in nfl_fh_list[X] MUST be used.",
      "ja": "+ nflda_multipath_ds_listに同じ数の要素。 nflda_multipath_ds_list [X]内の任意のデータ・サーバへのI / O操作を送信するときしたがって、この場合には、nfl_fh_list [X]でファイルハンドルを使用しなければなりません。"
    },
    {
      "indent": 10,
      "text": "See the discussion on sparse packing in Section 13.4.4.",
      "ja": "セクション13.4.4にまばらな包装の説明を参照してください。"
    },
    {
      "indent": 7,
      "text": "* If dense packing is being used, the number of elements in nfl_fh_list MUST be the same as the number of elements in nflda_stripe_indices. Thus, when sending an I/O operation to any data server in nflda_multipath_ds_list[nflda_stripe_indices[Y]], the filehandle in nfl_fh_list[Y] MUST be used. In addition, any time there exists i and j, (i != j), such that the intersection of nflda_multipath_ds_list[nflda_stripe_indices[i]] and nflda_multipath_ds_list[nflda_stripe_indices[j]] is not empty, then nfl_fh_list[i] MUST NOT equal nfl_fh_list[j]. In other words, when dense packing is being used, if a data server appears in two or more units of a striping pattern, each reference to the data server MUST use a different filehandle.",
      "ja": "密なパッキングが使用されている場合*、nfl_fh_list内の要素の数はnflda_stripe_indices内の要素の数と同じでなければなりません。 nflda_multipath_ds_list内の任意のデータ・サーバへのI / O操作を送信するときにこのようにして、[nflda_stripe_indices [Y]、nfl_fh_listにおけるファイルハンドル[Y]は使用しなければなりません。加えて、そこに任意の時間がnflda_multipath_ds_listの交差点[nflda_stripe_indicesは、[I]とnflda_multipath_ds_list [nflda_stripe_indicesは[J] [i]と等しくないMUST nfl_fh_list次いで、空でないように、（I！= j）は、iとjが存在しますnfl_fh_list [J]。密なパッキングが使用されているときに、データ・サーバは、ストライピングパターンの2個の以上の単位で表示される場合、換言すれば、データ・サーバへの各参照は、別のファイルハンドルを使用しなければなりません。"
    },
    {
      "indent": 10,
      "text": "Indeed, if there are multiple striping patterns, as indicated by the presence of multiple objects of data type layout4 (either returned in one or multiple LAYOUTGET operations), and a data server is the target of a unit of one pattern and another unit of another pattern, then each reference to each data server MUST use a different filehandle.",
      "ja": "複数のデータ型layout4のオブジェクト（1又は複数LAYOUTGET操作で返さいずれか）、およびデータサーバの存在によって示されるように、複数のストライピングパターンが、存在する場合、実際、一つのパターンの単位の目標と他の別の手段でありますパターンは、その後、各データ・サーバへの各参照は、別のファイルハンドルを使用しなければなりません。"
    },
    {
      "indent": 10,
      "text": "See the discussion on dense packing in Section 13.4.4.",
      "ja": "セクション13.4.4での密な包装の説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "The details on the interpretation of the layout are in Section 13.4.",
      "ja": "レイアウトの解釈についての詳細は、セクション13.4です。"
    },
    {
      "indent": 0,
      "text": "13.4. Interpreting the File Layout",
      "section_title": true,
      "ja": "13.4. ファイルのレイアウトを解釈"
    },
    {
      "indent": 0,
      "text": "13.4.1. Determining the Stripe Unit Number",
      "section_title": true,
      "ja": "13.4.1. ストライプユニット数の決定"
    },
    {
      "indent": 3,
      "text": "To find the stripe unit number that corresponds to the client's logical file offset, the pattern offset will also be used. The i'th stripe unit (SUi) is:",
      "ja": "オフセットクライアントの論理ファイルに対応するストライプユニット番号を確認するには、オフセットパターンも使用されます。 i番目のストライプユニット（SUi上）です。"
    },
    {
      "indent": 7,
      "text": "relative_offset = file_offset - nfl_pattern_offset;\nSUi = floor(relative_offset / stripe_unit_size);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "13.4.2. Interpreting the File Layout Using Sparse Packing",
      "section_title": true,
      "ja": "13.4.2. スパースパッキングを使用したファイルのレイアウトを解釈"
    },
    {
      "indent": 3,
      "text": "When sparse packing is used, the algorithm for determining the filehandle and set of data-server network addresses to write stripe unit i (SUi) to is:",
      "ja": "疎なパッキングを使用する場合、私はファイルハンドルを決定し、ストライプユニットを書き込むために、データ・サーバ・ネットワーク・アドレスのセットのためのアルゴリズム（SUi上）には、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "stripe_count = number of elements in nflda_stripe_indices;",
      "ja": "stripe_count = nflda_stripe_indices内の要素の数。"
    },
    {
      "indent": 6,
      "text": "j = (SUi + nfl_first_stripe_index) % stripe_count;",
      "ja": "J =（SUiと+ nfl_first_stripe_index）％のstripe_count。"
    },
    {
      "indent": 6,
      "text": "idx = nflda_stripe_indices[j];",
      "ja": "IDX = nflda_stripe_indices [J]。"
    },
    {
      "indent": 6,
      "text": "fh_count = number of elements in nfl_fh_list;\nds_count = number of elements in nflda_multipath_ds_list;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "switch (fh_count) {\n  case ds_count:\n    fh = nfl_fh_list[idx];\n    break;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "case 1:\n  fh = nfl_fh_list[0];\n  break;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "case 0:\n  fh = filehandle returned by OPEN;\n  break;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "  default:\n    throw a fatal exception;\n    break;\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "address_list = nflda_multipath_ds_list[idx];",
      "ja": "ADDRESS_LIST = nflda_multipath_ds_list [IDX]。"
    },
    {
      "indent": 3,
      "text": "The client would then select a data server from address_list, and send a READ or WRITE operation using the filehandle specified in fh.",
      "ja": "次に、クライアントは、ADDRESS_LISTからのデータ・サーバを選択し、FHで指定されたファイルハンドルを使用してREADまたはWRITE操作を送信します。"
    },
    {
      "indent": 3,
      "text": "Consider the following example:",
      "ja": "次の例を考えてみます。"
    },
    {
      "indent": 3,
      "text": "Suppose we have a device address consisting of seven data servers, arranged in three equivalence (Section 13.5) classes:",
      "ja": "我々は3つの等価（13.5節）のクラスに配置された7台のデータ・サーバからなるデバイスアドレスを持っていると仮定します。"
    },
    {
      "indent": 6,
      "text": "{ A, B, C, D }, { E }, { F, G }",
      "ja": "{A、B、C、D}、{E}、{F、G}"
    },
    {
      "indent": 3,
      "text": "where A through G are network addresses.",
      "ja": "ここで、Gを介して、ネットワークアドレスです。"
    },
    {
      "indent": 3,
      "text": "Then",
      "ja": "それから"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list<> = { A, B, C, D }, { E }, { F, G }",
      "ja": "nflda_multipath_ds_list <> = {A、B、C、D}、{E}、{F、G}"
    },
    {
      "indent": 3,
      "text": "i.e.,",
      "ja": "い。え。、"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[0] = { A, B, C, D }",
      "ja": "nflda_multipath_ds_list [0] = {A、B、C、D}"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[1] = { E }",
      "ja": "nflda_multipath_ds_list [1] = {E}"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[2] = { F, G }",
      "ja": "nflda_multipath_ds_list [2] = {F、G}"
    },
    {
      "indent": 3,
      "text": "Suppose the striping index array is:",
      "ja": "ストライピングインデックス配列があると仮定します。"
    },
    {
      "indent": 6,
      "text": "nflda_stripe_indices<> = { 2, 0, 1, 0 }",
      "ja": "nflda_stripe_indices <> = {2、0、1、0}"
    },
    {
      "indent": 3,
      "text": "Now suppose the client gets a layout that has a device ID that maps to the above device address. The initial index contains",
      "ja": "今、クライアントは、上記のデバイスアドレスにマップするデバイスのIDを持っていレイアウトを取得したとします。最初のインデックスが含まれています"
    },
    {
      "indent": 6,
      "text": "nfl_first_stripe_index = 2,",
      "ja": "nfl_first_stripe_index = 2、"
    },
    {
      "indent": 3,
      "text": "and the filehandle list is",
      "ja": "そしてファイルハンドルリストです"
    },
    {
      "indent": 6,
      "text": "nfl_fh_list = { 0x36, 0x87, 0x67 }.",
      "ja": "nfl_fh_list = {0x36、0x87の、0x67}。"
    },
    {
      "indent": 3,
      "text": "If the client wants to write to SU0, the set of valid { network address, filehandle } combinations for SUi are determined by:",
      "ja": "クライアントがSU0に書き込みたい場合は、有効の集合{ネットワークアドレスは、ファイルハンドル} SUi上のための組み合わせは、によって決定されます。"
    },
    {
      "indent": 6,
      "text": "nfl_first_stripe_index = 2",
      "ja": "nfl_first_stripe_index = 2"
    },
    {
      "indent": 3,
      "text": "So",
      "ja": "祖"
    },
    {
      "indent": 6,
      "text": "idx = nflda_stripe_indices[(0 + 2) % 4]",
      "ja": "IDX = nflda_stripe_indices [（0 + 1）％4]"
    },
    {
      "indent": 9,
      "text": "= nflda_stripe_indices[2]",
      "ja": "= nflda_stripe_indices [2]"
    },
    {
      "indent": 9,
      "text": "= 1",
      "ja": "＝ １"
    },
    {
      "indent": 3,
      "text": "So",
      "ja": "祖"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[1] = { E }",
      "ja": "nflda_multipath_ds_list [1] = {E}"
    },
    {
      "indent": 3,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "nfl_fh_list[1] = { 0x87 }",
      "ja": "nfl_fh_list [1] = {0x87の}"
    },
    {
      "indent": 3,
      "text": "The client can thus write SU0 to { 0x87, { E } }.",
      "ja": "クライアントは、したがって、{0x87の、{E}}にSU0を書き込むことができます。"
    },
    {
      "indent": 3,
      "text": "The destinations of the first 13 storage units are:",
      "ja": "第13の記憶ユニットの目的地："
    },
    {
      "indent": 20,
      "text": "+-----+------------+--------------+\n| SUi | filehandle | data servers |\n+-----+------------+--------------+\n| 0   | 87         | E            |\n| 1   | 36         | A,B,C,D      |\n| 2   | 67         | F,G          |\n| 3   | 36         | A,B,C,D      |\n| 4   | 87         | E            |\n| 5   | 36         | A,B,C,D      |\n| 6   | 67         | F,G          |\n| 7   | 36         | A,B,C,D      |\n| 8   | 87         | E            |\n| 9   | 36         | A,B,C,D      |\n| 10  | 67         | F,G          |\n| 11  | 36         | A,B,C,D      |\n| 12  | 87         | E            |\n+-----+------------+--------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "13.4.3. Interpreting the File Layout Using Dense Packing",
      "section_title": true,
      "ja": "13.4.3. 高密度パッキングを使用したファイルのレイアウトを解釈"
    },
    {
      "indent": 3,
      "text": "When dense packing is used, the algorithm for determining the filehandle and set of data server network addresses to write stripe unit i (SUi) to is:",
      "ja": "緻密なパッキングを使用する場合、I（SUi上に）にストライプユニットを書き込むために、データ・サーバ・ネットワーク・アドレスのファイルハンドルセットを決定するためのアルゴリズムです。"
    },
    {
      "indent": 6,
      "text": "stripe_count = number of elements in nflda_stripe_indices;",
      "ja": "stripe_count = nflda_stripe_indices内の要素の数。"
    },
    {
      "indent": 6,
      "text": "j = (SUi + nfl_first_stripe_index) % stripe_count;",
      "ja": "J =（SUiと+ nfl_first_stripe_index）％のstripe_count。"
    },
    {
      "indent": 6,
      "text": "idx = nflda_stripe_indices[j];",
      "ja": "IDX = nflda_stripe_indices [J]。"
    },
    {
      "indent": 6,
      "text": "fh_count = number of elements in nfl_fh_list;\nds_count = number of elements in nflda_multipath_ds_list;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "switch (fh_count) {\n  case stripe_count:\n    fh = nfl_fh_list[j];\n    break;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "  default:\n    throw a fatal exception;\n    break;\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "address_list = nflda_multipath_ds_list[idx];",
      "ja": "ADDRESS_LIST = nflda_multipath_ds_list [IDX]。"
    },
    {
      "indent": 3,
      "text": "The client would then select a data server from address_list, and send a READ or WRITE operation using the filehandle specified in fh.",
      "ja": "次に、クライアントは、ADDRESS_LISTからのデータ・サーバを選択し、FHで指定されたファイルハンドルを使用してREADまたはWRITE操作を送信します。"
    },
    {
      "indent": 3,
      "text": "Consider the following example (which is the same as the sparse packing example, except for the filehandle list):",
      "ja": "（ファイルハンドルの一覧を除いて、まばらな梱包の例と同じである）次の例を考えてみましょう。"
    },
    {
      "indent": 3,
      "text": "Suppose we have a device address consisting of seven data servers, arranged in three equivalence (Section 13.5) classes:",
      "ja": "我々は3つの等価（13.5節）のクラスに配置された7台のデータ・サーバからなるデバイスアドレスを持っていると仮定します。"
    },
    {
      "indent": 6,
      "text": "{ A, B, C, D }, { E }, { F, G }",
      "ja": "{A、B、C、D}、{E}、{F、G}"
    },
    {
      "indent": 3,
      "text": "where A through G are network addresses.",
      "ja": "ここで、Gを介して、ネットワークアドレスです。"
    },
    {
      "indent": 3,
      "text": "Then",
      "ja": "それから"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list<> = { A, B, C, D }, { E }, { F, G }",
      "ja": "nflda_multipath_ds_list <> = {A、B、C、D}、{E}、{F、G}"
    },
    {
      "indent": 3,
      "text": "i.e.,",
      "ja": "い。え。、"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[0] = { A, B, C, D }",
      "ja": "nflda_multipath_ds_list [0] = {A、B、C、D}"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[1] = { E }",
      "ja": "nflda_multipath_ds_list [1] = {E}"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[2] = { F, G }",
      "ja": "nflda_multipath_ds_list [2] = {F、G}"
    },
    {
      "indent": 3,
      "text": "Suppose the striping index array is:",
      "ja": "ストライピングインデックス配列があると仮定します。"
    },
    {
      "indent": 6,
      "text": "nflda_stripe_indices<> = { 2, 0, 1, 0 }",
      "ja": "nflda_stripe_indices <> = {2、0、1、0}"
    },
    {
      "indent": 3,
      "text": "Now suppose the client gets a layout that has a device ID that maps to the above device address. The initial index contains",
      "ja": "今、クライアントは、上記のデバイスアドレスにマップするデバイスのIDを持っていレイアウトを取得したとします。最初のインデックスが含まれています"
    },
    {
      "indent": 6,
      "text": "nfl_first_stripe_index = 2,",
      "ja": "nfl_first_stripe_index = 2、"
    },
    {
      "indent": 3,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "nfl_fh_list = { 0x67, 0x37, 0x87, 0x36 }.",
      "ja": "nfl_fh_list = {0x67、0x37は、0x87の、0x36}。"
    },
    {
      "indent": 3,
      "text": "The interesting examples for dense packing are SU1 and SU3 because each stripe unit refers to the same data server list, yet each stripe unit MUST use a different filehandle. If the client wants to write to SU1, the set of valid { network address, filehandle } combinations for SUi are determined by:",
      "ja": "各ストライプユニットは、同じデータ・サーバーのリストを参照し、まだ各ストライプユニットは別のファイルハンドルを使用する必要があるため、密なパッキングのための興味深い例は、SU1とSU3です。クライアントはSU1に書き込みたい場合は、有効の集合{ネットワークアドレスは、ファイルハンドル} SUi上のための組み合わせは、によって決定されます。"
    },
    {
      "indent": 6,
      "text": "nfl_first_stripe_index = 2",
      "ja": "nfl_first_stripe_index = 2"
    },
    {
      "indent": 3,
      "text": "So",
      "ja": "祖"
    },
    {
      "indent": 6,
      "text": "j = (1 + 2) % 4 = 3",
      "ja": "J =（1 + 2）％4 = 3"
    },
    {
      "indent": 9,
      "text": "idx = nflda_stripe_indices[j]",
      "ja": "IDX = nflda_stripe_indices [J]"
    },
    {
      "indent": 9,
      "text": "= nflda_stripe_indices[3]",
      "ja": "= nflda_stripe_indices [3]"
    },
    {
      "indent": 9,
      "text": "= 0",
      "ja": "＝ ０"
    },
    {
      "indent": 3,
      "text": "So",
      "ja": "祖"
    },
    {
      "indent": 6,
      "text": "nflda_multipath_ds_list[0] = { A, B, C, D }",
      "ja": "nflda_multipath_ds_list [0] = {A、B、C、D}"
    },
    {
      "indent": 3,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "nfl_fh_list[3] = { 0x36 }",
      "ja": "nfl_fh_list [3] = {0x36}"
    },
    {
      "indent": 3,
      "text": "The client can thus write SU1 to { 0x36, { A, B, C, D } }.",
      "ja": "クライアントは、したがって、{0x36、{A、B、C、D}にSU1を書き込むことができます。"
    },
    {
      "indent": 3,
      "text": "For SU3, j = (3 + 2) % 4 = 1, and nflda_stripe_indices[1] = 0. Then nflda_multipath_ds_list[0] = { A, B, C, D }, and nfl_fh_list[1] = 0x37. The client can thus write SU3 to { 0x37, { A, B, C, D } }.",
      "ja": "SU3、J =（3 + 2）％4 = 1、およびnflda_stripe_indices [1] = 0次にnflda_multipath_ds_list [0] = {A、B、C、D}、およびnfl_fh_list [1] =の0x37は。クライアントは、したがって、{0x37は、{A、B、C、D}にSU3を書き込むことができます。"
    },
    {
      "indent": 3,
      "text": "The destinations of the first 13 storage units are:",
      "ja": "第13の記憶ユニットの目的地："
    },
    {
      "indent": 20,
      "text": "+-----+------------+--------------+\n| SUi | filehandle | data servers |\n+-----+------------+--------------+\n| 0   | 87         | E            |\n| 1   | 36         | A,B,C,D      |\n| 2   | 67         | F,G          |\n| 3   | 37         | A,B,C,D      |\n| 4   | 87         | E            |\n| 5   | 36         | A,B,C,D      |\n| 6   | 67         | F,G          |\n| 7   | 37         | A,B,C,D      |\n| 8   | 87         | E            |\n| 9   | 36         | A,B,C,D      |\n| 10  | 67         | F,G          |\n| 11  | 37         | A,B,C,D      |\n| 12  | 87         | E            |\n+-----+------------+--------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "13.4.4. Sparse and Dense Stripe Unit Packing",
      "section_title": true,
      "ja": "13.4.4. 疎密ストライプユニットパッキング"
    },
    {
      "indent": 3,
      "text": "The flag NFL4_UFLG_DENSE of the nfl_util4 data type (field nflh_util of the data type nfsv4_1_file_layouthint4 and field nfl_util of data type nfsv4_1_file_layout_ds_addr4) specifies how the data is packed within the data file on a data server. It allows for two different data packings: sparse and dense. The packing type determines the calculation that will be made to map the client-visible file offset to the offset within the data file located on the data server.",
      "ja": "nfl_util4データ型（データ型nfsv4_1_file_layout_ds_addr4のnfl_utilデータ型nfsv4_1_file_layouthint4とフィールドのnflh_utilフィールド）のフラグNFL4_UFLG_DENSEは、データをデータ・サーバ上のデータファイル内にパックされる方法を指定します。粗密：これは、2つの異なるデータパッキングが可能になります。梱包タイプは、データ・サーバ上にあるデータファイル内のオフセットにオフセットクライアントから見えるファイルをマッピングするために行われる計算を決定します。"
    },
    {
      "indent": 3,
      "text": "If nfl_util & NFL4_UFLG_DENSE is zero, this means that sparse packing is being used. Hence, the logical offsets of the file as viewed by a client sending READs and WRITEs directly to the metadata server are the same offsets each data server uses when storing a stripe unit. The effect then, for striping patterns consisting of at least two stripe units, is for each data server file to be sparse or \"holey\". So for example, suppose there is a pattern with three stripe units, the stripe unit size is 4096 bytes, and there are three data servers in the pattern. Then, the file in data server 1 will have stripe units 0, 3, 6, 9, ... filled; data server 2's file will have stripe units 1, 4, 7, 10, ... filled; and data server 3's file will have stripe units 2, 5, 8, 11, ... filled. The unfilled stripe units of each file will be holes; hence, the files in each data server are sparse.",
      "ja": "nfl_util＆NFL4_UFLG_DENSEがゼロの場合、これはまばらな梱包が使用されていることを意味します。したがって、ファイルの論理オフセットは、送信側クライアントから見た読み取り、メタデータサーバに直接書き込むストライプユニットを格納する際に、各データ・サーバが使用するのと同じオフセットです。効果は、その後、少なくとも二つのストライプユニットからなるストライピングパターンを、疎または「穴あき」される各データ・サーバ・ファイルのためのものです。だから、例えば、3つのストライプユニットのパターンがあると、ストライプユニットサイズは4096バイトで、3台のデータ・サーバがパターンです。そして、データサーバ1内のファイルは、ストライプユニット0、3、6、9、...充填を有することになります。ストライプユニットを持つことになり、データサーバ2のファイル1、4、7、10、...いっぱい。そして、データサーバ3のファイルには、ストライプユニット2、5、8、11、...いっぱいになります。各ファイルの未充填ストライプユニットは穴であろう。したがって、各データ・サーバ内のファイルはスパースです。"
    },
    {
      "indent": 3,
      "text": "If sparse packing is being used and a client attempts I/O to one of the holes, then an error MUST be returned by the data server. Using the above example, if data server 3 received a READ or WRITE operation for block 4, the data server would return NFS4ERR_PNFS_IO_HOLE. Thus, data servers need to understand the striping pattern in order to support sparse packing.",
      "ja": "まばらな梱包を使用して、クライアントが穴の一つにI / Oをしようとしている場合は、エラーがデータ・サーバによって返さなければなりません。データサーバ3は、ブロック4に対する読み出し又は書き込み動作を受信した場合は、上記の例を使用して、データ・サーバはNFS4ERR_PNFS_IO_HOLEを返します。このように、データ・サーバは、まばらな梱包をサポートするために、ストライピングパターンを理解する必要があります。"
    },
    {
      "indent": 3,
      "text": "If nfl_util & NFL4_UFLG_DENSE is one, this means that dense packing is being used, and the data server files have no holes. Dense packing might be selected because the data server does not (efficiently) support holey files or because the data server cannot recognize read-ahead unless there are no holes. If dense packing is indicated in the layout, the data files will be packed. Using the same striping pattern and stripe unit size that were used for the sparse packing example, the corresponding dense packing example would have all stripe units of all data files filled as follows:",
      "ja": "nfl_util＆NFL4_UFLG_DENSEが1である場合、これは密なパッキングが使用されていることを意味し、データ・サーバ・ファイルには穴がありません。データ・サーバは、（効率的に）ホーリーファイルをサポートしていないため、密なパッキングが選択される可能性がありますまたはデータサーバが先読みを認識できないので、何の穴が存在しない場合は除きます。密なパッキングがレイアウトで表示されている場合は、データファイルがパックされます。疎充填例えば使用された同一のストライプパターンとストライプユニットサイズを使用して、対応する密なパッキングの例は次のように充填されたすべてのデータファイルのすべてのストライプユニットを有するであろう。"
    },
    {
      "indent": 3,
      "text": "o Logical stripe units 0, 3, 6, ... of the file would live on stripe units 0, 1, 2, ... of the file of data server 1.",
      "ja": "O論理ストライプユニット0、3、6、...ファイルのストライプユニット0、1、2、...データサーバ1のファイルの上で生きるでしょう。"
    },
    {
      "indent": 3,
      "text": "o Logical stripe units 1, 4, 7, ... of the file would live on stripe units 0, 1, 2, ... of the file of data server 2.",
      "ja": "O論理ストライプユニット1、4、7、...ファイルのストライプユニット0、1、2、...データサーバ2のファイルの上で生きるでしょう。"
    },
    {
      "indent": 3,
      "text": "o Logical stripe units 2, 5, 8, ... of the file would live on stripe units 0, 1, 2, ... of the file of data server 3.",
      "ja": "O論理ストライプユニット2、5、8、...ファイルのストライプユニット0、1、2、...データサーバ3のファイルの上で生きるでしょう。"
    },
    {
      "indent": 3,
      "text": "Because dense packing does not leave holes on the data servers, the pNFS client is allowed to write to any offset of any data file of any data server in the stripe. Thus, the data servers need not know the file's striping pattern.",
      "ja": "密なパッキングは、データ・サーバ上の穴を残していないため、pNFSのクライアントは、任意のストライプ内の任意のデータ・サーバの任意のデータファイルのオフセットへの書き込みを許可されています。このように、データ・サーバは、ファイルのストライピングパターンを知っている必要はありません。"
    },
    {
      "indent": 3,
      "text": "The calculation to determine the byte offset within the data file for dense data server layouts is:",
      "ja": "高密度のデータ・サーバ・レイアウトのデータファイル内のバイトオフセットを決定するための計算は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "stripe_width = stripe_unit_size * N; where N = number of elements in nflda_stripe_indices.",
      "ja": "STRIPE_WIDTH = stripe_unit_size * N;ここで、Nはnflda_stripe_indices内の要素の数を=。"
    },
    {
      "indent": 6,
      "text": "relative_offset = file_offset - nfl_pattern_offset;",
      "ja": "relative_offset = file_offset  -  nfl_pattern_offset。"
    },
    {
      "indent": 6,
      "text": "data_file_offset = floor(relative_offset / stripe_width) * stripe_unit_size + relative_offset % stripe_unit_size",
      "ja": "data_file_offset =フロア（relative_offset / STRIPE_WIDTH）* stripe_unit_size + relative_offset％stripe_unit_size"
    },
    {
      "indent": 3,
      "text": "If dense packing is being used, and a data server appears more than once in a striping pattern, then to distinguish one stripe unit from another, the data server MUST use a different filehandle. Let's suppose there are two data servers. Logical stripe units 0, 3, 6 are served by data server 1; logical stripe units 1, 4, 7 are served by data server 2; and logical stripe units 2, 5, 8 are also served by data server 2. Unless data server 2 has two filehandles (each referring to a different data file), then, for example, a write to logical stripe unit 1 overwrites the write to logical stripe unit 2 because both logical stripe units are located in the same stripe unit (0) of data server 2.",
      "ja": "密なパッキングを使用して、データ・サーバは、その後から別のストライプユニットを区別するために、ストライプパターンで複数回表示されている場合は、データ・サーバは、別のファイルハンドルを使用しなければなりません。 2台のデータ・サーバがあるとしましょう。論理ストライプユニット0、3、6、データサーバ1が配信されます。論理ストライプユニット1、4、7はデータサーバ2によってサービスされます。および論理ストライプユニット2,5,8は、データサーバ2によって配信されたデータサーバ2は、2つのファイルハンドル（それぞれ異なるデータファイルを参照）を有している場合を除き、次いで、例えば、論理ストライプユニット1への書き込みは、への書き込みを上書き論理ストライプユニットの両方が、データサーバ2の同じストライプユニット（0）に配置されているので、論理ストライプユニット2。"
    },
    {
      "indent": 0,
      "text": "13.5. Data Server Multipathing",
      "section_title": true,
      "ja": "13.5.  Data Serverのマルチパス"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 file layout supports multipathing to multiple data server addresses. Data-server-level multipathing is used for bandwidth scaling via trunking (Section 2.10.5) and for higher availability of use in the case of a data-server failure. Multipathing allows the client to switch to another data server address which may be that of another data server that is exporting the same data stripe unit, without having to contact the metadata server for a new layout.",
      "ja": "NFSv4.1ファイルのレイアウトは、複数のデータ・サーバ・アドレスへのマルチパスをサポートしています。データ・サーバ・レベルのマルチパス（セクション2.10.5）をトランキングを介してデータ・サーバに障害が発生した場合における使用のより高い可用性のための帯域幅のスケーリングのために使用されます。マルチパスは、クライアントが新しいレイアウトのメタデータサーバに連絡することなく、同じデータ・ストライプ・ユニットをエクスポートしている他のデータ・サーバとすることができる他のデータサーバのアドレスに切り替えることを可能にします。"
    },
    {
      "indent": 3,
      "text": "To support data server multipathing, each element of the nflda_multipath_ds_list contains an array of one more data server network addresses. This array (data type multipath_list4) represents a list of data servers (each identified by a network address), with the possibility that some data servers will appear in the list multiple times.",
      "ja": "データ・サーバのマルチパスをサポートするために、nflda_multipath_ds_listの各要素は、1つの以上のデータ・サーバ・ネットワーク・アドレスの配列が含まれています。この配列（データ型multipath_list4）は、いくつかのデータ・サーバがリストに複数回出現する可能性のあるデータ・サーバ（それぞれがネットワークアドレスで識別される）のリストを表しています。"
    },
    {
      "indent": 3,
      "text": "The client is free to use any of the network addresses as a destination to send data server requests. If some network addresses are less optimal paths to the data than others, then the MDS SHOULD NOT include those network addresses in an element of nflda_multipath_ds_list. If less optimal network addresses exist to provide failover, the RECOMMENDED method to offer the addresses is to provide them in a replacement device-ID-to-device-address mapping, or a replacement device ID. When a client finds that no data server in an element of nflda_multipath_ds_list responds, it SHOULD send a GETDEVICEINFO to attempt to replace the existing device-ID-to-device-address mappings. If the MDS detects that all data servers represented by an element of nflda_multipath_ds_list are unavailable, the MDS SHOULD send a CB_NOTIFY_DEVICEID (if the client has indicated it wants device ID notifications for changed device IDs) to change the device-ID-to-device-address mappings to the available data servers. If the device ID itself will be replaced, the MDS SHOULD recall all layouts with the device ID, and thus force the client to get new layouts and device ID mappings via LAYOUTGET and GETDEVICEINFO.",
      "ja": "クライアントは、データ・サーバ要求を送信する宛先としてネットワークアドレスのいずれかを使用して自由です。いくつかのネットワークアドレスが他よりデータが少ない最適な経路である場合には、MDSはnflda_multipath_ds_listの要素でこれらのネットワークアドレスを含めるべきではありません。より少ない最適なネットワークアドレスがフェールオーバーを提供するために存在する場合、アドレスを提供するために推奨される方法は、交換デバイスIDとデバイスアドレスのマッピング、または交換装置IDでそれらを提供することです。クライアントはnflda_multipath_ds_listの要素には、データ・サーバが応答しないことを発見した場合は、既存のデバイスIDとデバイスアドレスのマッピングを交換しようとするGETDEVICEINFOを送るべきです。 MDSはnflda_multipath_ds_listの要素によって表されるすべてのデータ・サーバが使用できないことを検出した場合、MDSは、TO-、デバイスにデバイスID-変更する（クライアントが変更されたデバイスIDのデバイスIDの通知を望んで示した場合）CB_NOTIFY_DEVICEIDを送るべき利用可能なデータ・サーバへのアドレスマッピング。デバイスID自体を交換する場合、MDSは、デバイスIDを持つすべてのレイアウトを思い出し、ひいてはLAYOUTGETとGETDEVICEINFOを通じて新しいレイアウトとデバイスIDのマッピングを取得するようにクライアントを強制すべきです。"
    },
    {
      "indent": 3,
      "text": "Generally, if two network addresses appear in an element of nflda_multipath_ds_list, they will designate the same data server, and the two data server addresses will support the implementation of client ID or session trunking (the latter is RECOMMENDED) as defined in Section 2.10.5. The two data server addresses will share the same server owner or major ID of the server owner. It is not always necessary for the two data server addresses to designate the same server with trunking being used. For example, the data could be read-only, and the data consist of exact replicas.",
      "ja": "一般的に、2つのネットワークアドレスがnflda_multipath_ds_listの要素に表示される場合、それらは同じデータ・サーバを指定し、セクション2.10.5に定義されている二つのデータ・サーバ・アドレスは、クライアントIDまたはセッション・トランキング（後者が推奨される）の実施を支援します。二つのデータ・サーバのアドレスは、同じサーバーの所有者またはサーバーの所有者の主要なIDを共有します。二つのデータ・サーバのアドレスが使用されているトランキングで同じサーバーを指定することは必ずしも必要ではありません。例えば、データは、読み取り専用ことができ、データは、正確な複製から成ります。"
    },
    {
      "indent": 0,
      "text": "13.6. Operations Sent to NFSv4.1 Data Servers",
      "section_title": true,
      "ja": "13.6.  NFSv4.1データサーバーに送信操作"
    },
    {
      "indent": 3,
      "text": "Clients accessing data on an NFSv4.1 data server MUST send only the NULL procedure and COMPOUND procedures whose operations are taken only from two restricted subsets of the operations defined as valid NFSv4.1 operations. Clients MUST use the filehandle specified by the layout when accessing data on NFSv4.1 data servers.",
      "ja": "NFSv4.1データサーバー上のデータにアクセスするクライアントは、その操作のみ有効NFSv4.1操作として定義された2つの動作制限されたサブセットから取られているだけNULL手続きとCOMPOUND手順を送らなければなりません。クライアントは、NFSv4.1データ・サーバ上のデータにアクセスする際のレイアウトで指定されたファイルハンドルを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The first of these operation subsets consists of management operations. This subset consists of the BACKCHANNEL_CTL, BIND_CONN_TO_SESSION, CREATE_SESSION, DESTROY_CLIENTID, DESTROY_SESSION, EXCHANGE_ID, SECINFO_NO_NAME, SET_SSV, and SEQUENCE operations. The client may use these operations in order to set up and maintain the appropriate client IDs, sessions, and security contexts involved in communication with the data server. Henceforth, these will be referred to as data-server housekeeping operations.",
      "ja": "これらの操作のサブセットの第一は、管理操作から成ります。このサブセットはBACKCHANNEL_CTL、BIND_CONN_TO_SESSION、CREATE_SESSION、DESTROY_CLIENTID、DESTROY_SESSION、EXCHANGE_ID、SECINFO_NO_NAME、SET_SSV、シーケンス動作から成ります。クライアントを設定し、データ・サーバとの通信に関与し、適切なクライアントID、セッション、およびセキュリティコンテキストを維持するために、これらの操作を使用することができます。今後は、これらは、データ・サーバーのハウスキーピング操作と呼ぶことにします。"
    },
    {
      "indent": 3,
      "text": "The second subset consists of COMMIT, READ, WRITE, and PUTFH. These operations MUST be used with a current filehandle specified by the layout. In the case of PUTFH, the new current filehandle MUST be one taken from the layout. Henceforth, these will be referred to as data-server I/O operations. As described in Section 12.5.1, a client MUST NOT send an I/O to a data server for which it does not hold a valid layout; the data server MUST reject such an I/O.",
      "ja": "第二のサブセットは、COMMIT、読み取り、書き込み、およびPUTFHから成ります。これらの動作は、レイアウトで指定された現在のファイルハンドルを使用する必要があります。 PUTFHの場合には、新たな現在のファイルハンドルは、レイアウトから1を払わなければなりません。今後は、これらのデータは、サーバI / O操作と呼ぶことにします。 12.5.1項で説明したように、クライアントは、それが有効なレイアウトを保持していない対象のデータ・サーバへのI / Oを送ってはいけません。データ・サーバは、このようなI / Oを拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Unless the server has a concurrent non-data-server personality -- i.e., EXCHANGE_ID results returned (EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_PNFS_MDS) or (EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_NON_PNFS) see Section 13.1 -- any attempted use of operations against a data server other than those specified in the two subsets above MUST return NFS4ERR_NOTSUPP to the client.",
      "ja": "サーバーは、同時非データサーバーの個性を持っていない限り - すなわち、EXCHANGE_ID結果が返される（EXCHGID4_FLAG_USE_PNFS_DSを| EXCHGID4_FLAG_USE_PNFS_MDS）または（EXCHGID4_FLAG_USE_PNFS_DS | EXCHGID4_FLAG_USE_NON_PNFSは） - で指定された以外のデータ・サーバに対する操作のいずれか未遂使用項13.1を参照してください2つのサブセットは、上記クライアントにNFS4ERR_NOTSUPPを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the server has concurrent data-server and non-data-server personalities, each COMPOUND sent by the client MUST be constructed so that it is appropriate to one of the two personalities, and it MUST NOT contain operations directed to a mix of those personalities. The server MUST enforce this. To understand the constraints, operations within a COMPOUND are divided into the following three classes:",
      "ja": "サーバが同時データ・サーバと非データサーバー個性を持っている場合、それは2つの人格の一つに適切になるように、クライアントから送信された各化合物を構成しなければなりません、そして、それは、それらの個性のミックスに向け事業を含んではなりません。サーバはこれを強制しなければなりません。制約を理解するために、化合物内の操作は、次の3つのクラスに分かれています。"
    },
    {
      "indent": 3,
      "text": "1. An operation that is ambiguous regarding its personality assignment. This includes all of the data-server housekeeping operations. Additionally, if the server has assigned filehandles so that the ones defined by the layout are the same as those used by the metadata server, all operations using such filehandles are within this class, with the following exception. The exception is that if the operation uses a stateid that is incompatible with a data-server personality (e.g., a special stateid or the stateid has a non-zero \"seqid\" field, see Section 13.9.1), the operation is in class 3, as described below. A COMPOUND containing multiple class 1 operations (and operations of no other class) MAY be sent to a server with multiple concurrent data server and non-data-server personalities.",
      "ja": "1.その人格の割り当てに関するあいまいです操作。これは、データ・サーバーのハウスキーピング操作のすべてを含んでいます。レイアウトによって定義されたものは、メタデータサーバによって使用されるものと同じになるようにサーバーがファイルハンドルを割り当てた場合に加えて、そのようなファイルハンドルを使用して、すべての操作は、以下の例外を除いて、このクラスの範囲内です。例外は、操作がデータ・サーバーパーソナリティ（例えば、特別なstateidかなstateidが非ゼロ「SEQID」フィールドを持っている、セクション13.9.1を参照）と互換性がないのstateidを使用する場合、操作はクラスであるということです図3に示すように、後述のように。複数のクラス（他のクラスのと動作1つの）の動作を含む化合物は、複数の同時データ・サーバと非データサーバ個性を持つサーバーに送ってもよいです。"
    },
    {
      "indent": 3,
      "text": "2. An operation that is unambiguously referable to the data-server personality. This includes data-server I/O operations where the filehandle is one that can only be validly directed to the data-server personality.",
      "ja": "2.データ・サーバーの個性に明確に参照可能である操作。これはファイルハンドルのみ有効にデータ・サーバーの人格に向けることができるものであるデータ・サーバのI / O操作を含んでいます。"
    },
    {
      "indent": 3,
      "text": "3. An operation that is unambiguously referable to the non-data-server personality. This includes all COMPOUND operations that are neither data-server housekeeping nor data-server I/O operations, plus data-server I/O operations where the current fh (or the one to be made the current fh in the case of PUTFH) is only valid on the metadata server or where a stateid is used that is incompatible with the data server, i.e., is a special stateid or has a non-zero seqid value.",
      "ja": "3.非データサーバーの個性に明確に参照可能である操作。これは、データ・サーバ・ハウスキーピングやデータサーバI / O操作、プラス電流FH（または一方がPUTFHの場合に現在のFHを行うべき）データサーバI / O操作でもないすべての複合操作を含みますつまり、データ・サーバと互換性がないのstateidが使用されているメタデータ・サーバや、上でのみ有効な、特別なstateidであるか非ゼロSEQID値を持っています。"
    },
    {
      "indent": 3,
      "text": "When a COMPOUND first executes an operation from class 3 above, it acts as a normal COMPOUND on any other server, and the data-server personality ceases to be relevant. There are no special restrictions on the operations in the COMPOUND to limit them to those for a data server. When a PUTFH is done, filehandles derived from the layout are not valid. If their format is not normally acceptable, then NFS4ERR_BADHANDLE MUST result. Similarly, current filehandles for other operations do not accept filehandles derived from layouts and are not normally usable on the metadata server. Using these will result in NFS4ERR_STALE.",
      "ja": "化合物は最初、上記クラス3からの操作を実行すると、それは他のサーバ上で正常化合物として作用し、データサーバパーソナリティは、関連ではなくなります。データ・サーバー用のものにそれらを制限するための化合物中の操作に特別な制限はありません。 PUTFHが行われた場合、レイアウト由来ファイルハンドルが有効ではありません。その形式が正常に受け入れられない場合は、NFS4ERR_BADHANDLEをもたらさなければなりません。同様に、他の操作のための現在のファイルハンドルは、レイアウトに由来するファイルハンドルを受け付けていないと、メタデータサーバに正常に使用できませんか。これらを使用すると、NFS4ERR_STALEになります。"
    },
    {
      "indent": 3,
      "text": "When a COMPOUND first executes an operation from class 2, which would be PUTFH where the filehandle is one from a layout, the COMPOUND henceforth is interpreted with respect to the data-server personality. Operations outside the two classes discussed above MUST result in NFS4ERR_NOTSUPP. Filehandles are validated using the rules of the data server, resulting in NFS4ERR_BADHANDLE and/or NFS4ERR_STALE even when they would not normally do so when addressed to the non-data-server personality. Stateids must obey the rules of the data server in that any use of special stateids or stateids with non-zero seqid values must result in NFS4ERR_BAD_STATEID.",
      "ja": "化合物は、最初のファイルハンドルは、レイアウトから1である、化合物が、今後データサーバパーソナリティに関して解釈さPUTFHされるであろう、クラス2からの操作を実行します。上述の二つのクラス外の操作がNFS4ERR_NOTSUPPをもたらさなければなりません。ファイルハンドルは、非データサーバーの人格に宛てたとき、彼らは通常、そうでないときでさえNFS4ERR_BADHANDLEおよび/またはNFS4ERR_STALEその結果、データ・サーバの規則を使用して検証しています。 stateidsは非ゼロSEQID値を持つ特別のstateidsかのstateidsのいずれかの使用はNFS4ERR_BAD_STATEIDになる必要があることで、データ・サーバの規則に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "Until the server first executes an operation from class 2 or class 3, the client MUST NOT depend on the operation being executed by either the data-server or the non-data-server personality. The server MUST pick one personality consistently for a given COMPOUND, with the only possible transition being a single one when the first operation from class 2 or class 3 is executed.",
      "ja": "サーバーは、最初のクラス2またはクラス3から操作を実行するまで、クライアントは、データ・サーバーまたは非データサーバ人格のいずれかによって実行される操作に依存してはなりません。サーバは、クラス2又はクラス3からの最初の操作が実行された場合にのみ可能な遷移は単一のものであると、所与の化合物のために一貫して1人のパーソナリティを選択しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Because of the complexity induced by assigning filehandles so they can be used on both a data server and a metadata server, it is RECOMMENDED that where the same server can have both personalities, the server assign separate unique filehandles to both personalities. This makes it unambiguous for which server a given request is intended.",
      "ja": "なぜならそれらはデータ・サーバとメタデータサーバの両方で使用できるようにファイルハンドルを割り当てることによって誘導された複雑さのために、それは、同じサーバーが両方の性格を持つことができる場合、サーバは両方のパーソナリティに別個の固有のファイルハンドルを割り当てることが推奨されます。これは、特定のリクエストが意図されているサーバーのことが明確なことができます。"
    },
    {
      "indent": 3,
      "text": "GETATTR and SETATTR MUST be directed to the metadata server. In the case of a SETATTR of the size attribute, the control protocol is responsible for propagating size updates/truncations to the data servers. In the case of extending WRITEs to the data servers, the new size must be visible on the metadata server once a LAYOUTCOMMIT has completed (see Section 12.5.4.2). Section 13.10 describes the mechanism by which the client is to handle data-server files that do not reflect the metadata server's size.",
      "ja": "GETATTRとSETATTRは、メタデータサーバに送らなければなりません。サイズ属性のSETATTRの場合には、制御プロトコルは、データ・サーバにサイズの更新/短縮型を伝播する責任があります。 LAYOUTCOMMITが完了すると、データ・サーバへの書き込みを拡張する場合は、新しいサイズは（セクション12.5.4.2を参照）メタデータサーバ上で表示されなければなりません。 13.10項には、クライアントは、メタデータサーバの大きさを反映していないデータ・サーバー・ファイルを処理するためにされる機構を説明します。"
    },
    {
      "indent": 0,
      "text": "13.7. COMMIT through Metadata Server",
      "section_title": true,
      "ja": "13.7. メタデータサーバ経由COMMIT"
    },
    {
      "indent": 3,
      "text": "The file layout provides two alternate means of providing for the commit of data written through data servers. The flag NFL4_UFLG_COMMIT_THRU_MDS in the field nfl_util of the file layout (data type nfsv4_1_file_layout4) is an indication from the metadata server to the client of the REQUIRED way of performing COMMIT, either by sending the COMMIT to the data server or the metadata server. These two methods of dealing with the issue correspond to broad styles of implementation for a pNFS server supporting the file layout type.",
      "ja": "ファイルレイアウトは、データサーバーを介して書き込まれたデータのコミットを提供する2つの代替手段を提供します。ファイルレイアウト（データ型nfsv4_1_file_layout4）のnfl_utilフィールドのフラグNFL4_UFLG_COMMIT_THRU_MDSメタデータサーバからCOMMIT実行に必要な方法のクライアントに表示され、いずれかのデータ・サーバまたはメタデータサーバにCOMMITを送信することによって。問題に対処するためのこれらの2つの方法は、ファイルのレイアウトタイプをサポートしているのpNFSサーバの実装の幅広いスタイルに対応しています。"
    },
    {
      "indent": 3,
      "text": "o When the flag is FALSE, COMMIT operations MUST to be sent to the data server to which the corresponding WRITE operations were sent. This approach is sometimes useful when file striping is implemented within the pNFS server (instead of the file system), with the individual data servers each implementing their own file systems.",
      "ja": "フラグがFALSEである場合、O、動作をCOMMIT対応する書き込み操作が送信された先のデータ・サーバに送信する必要があります。ファイルストライピングは、それぞれ独自のファイルシステムを実装する個々のデータ・サーバと、（代わりにファイルシステムの）pNFSのサーバ内に実装されている場合、このアプローチは、しばしば有用です。"
    },
    {
      "indent": 3,
      "text": "o When the flag is TRUE, COMMIT operations MUST be sent to the metadata server, rather than to the individual data servers. This approach is sometimes useful when file striping is implemented within the clustered file system that is the backend to the pNFS server. In such an implementation, each COMMIT to each data server might result in repeated writes of metadata blocks to the detriment of write performance. Sending a single COMMIT to the metadata server can be more efficient when there exists a clustered file system capable of implementing such a coordinated COMMIT.",
      "ja": "フラグがTRUEである場合、O、COMMIT操作は、メタデータサーバにではなく、個々のデータ・サーバに送信する必要があります。ファイルのストライピングはpNFSのサーバへのバックエンドでクラスタ化されたファイルシステム内に実装されている場合、このアプローチは、時には便利です。このような実装では、それぞれが各データ・サーバにCOMMIT書き込みパフォーマンスを犠牲にしたメタデータブロックの繰り返しの書き込みになる可能性があります。このようCOMMIT協調を実現することが可能なクラスタファイルシステムが存在する場合、メタデータ・サーバにコミットする単一の送信は、より効率的にすることができます。"
    },
    {
      "indent": 6,
      "text": "If nfl_util & NFL4_UFLG_COMMIT_THRU_MDS is TRUE, then in order to maintain the current NFSv4.1 commit and recovery model, the data servers MUST return a common writeverf verifier in all WRITE responses for a given file layout, and the metadata server's COMMIT implementation must return the same writeverf. The value of the writeverf verifier MUST be changed at the metadata server or any data server that is referenced in the layout, whenever there is a server event that can possibly lead to loss of uncommitted data. The scope of the verifier can be for a file or for the entire pNFS server. It might be more difficult for the server to maintain the verifier at the file level, but the benefit is that only events that impact a given file will require recovery action.",
      "ja": "nfl_util＆NFL4_UFLG_COMMIT_THRU_MDSがTRUEの場合、現在のコミットNFSv4.1を維持し、復旧モデルにするために、データ・サーバは、指定されたファイルレイアウトのためのすべてのWRITE応答で共通writeverf検証を返し、メタデータ・サーバの実装をコミットする必要があります返す必要があります同じwriteverf。おそらくコミットされていないデータの損失につながる可能性がサーバーイベントがあるたびwriteverf検証の値は、メタデータサーバやレイアウトで参照される任意のデータ・サーバに変更しなければなりません。検証の範囲は、ファイルの全体のpNFSサーバとすることができます。サーバーは、ファイルレベルでの検証を維持することがより困難かもしれませんが、利点は、与えられたファイルに影響を与えるだけのイベントが回復処置を必要とすることです。"
    },
    {
      "indent": 3,
      "text": "Note that if the layout specified dense packing, then the offset used to a COMMIT to the MDS may differ than that of an offset used to a COMMIT to the data server.",
      "ja": "レイアウトが密充填を指定した場合、次にオフセットMDSにコミットするために使用されることに注意してくださいオフセットデータ・サーバにコミットするために使用されるよりも異なっていてもよいです。"
    },
    {
      "indent": 3,
      "text": "The single COMMIT to the metadata server will return a verifier, and the client should compare it to all the verifiers from the WRITEs and fail the COMMIT if there are any mismatched verifiers. If COMMIT to the metadata server fails, the client should re-send WRITEs for all the modified data in the file. The client should treat modified data with a mismatched verifier as a WRITE failure and try to recover by resending the WRITEs to the original data server or using another path to that data if the layout has not been recalled. Alternatively, the client can obtain a new layout or it could rewrite the data directly to the metadata server. If nfl_util & NFL4_UFLG_COMMIT_THRU_MDS is FALSE, sending a COMMIT to the metadata server might have no effect. If nfl_util & NFL4_UFLG_COMMIT_THRU_MDS is FALSE, a COMMIT sent to the metadata server should be used only to commit data that was written to the metadata server. See Section 12.7.6 for recovery options.",
      "ja": "メタデータサーバにCOMMITシングルはベリファイアを返し、クライアントは書いてから、すべての検証と比較し、いずれかの不一致検証があるかどうCOMMIT失敗する必要があります。メタデータサーバにCOMMITが失敗した場合、クライアントは、ファイル内のすべての変更されたデータに対して書き込みを再送信する必要があります。クライアントは、WRITE障害などの不一致検証と修正されたデータを処理し、元のデータ・サーバへの書き込みを再送信するか、レイアウトがリコールされていない場合、そのデータを別のパスを使用して回復しようとする必要があります。また、クライアントは、新しいレイアウトを得ることも、メタデータサーバに直接データを書き換えることができます。 nfl_util＆NFL4_UFLG_COMMIT_THRU_MDSがFALSEの場合、メタデータサーバにCOMMITを送信しても効果がないかもしれません。 nfl_util＆NFL4_UFLG_COMMIT_THRU_MDSがFALSEの場合、メタデータ・サーバに送信されたCOMMITメタデータサーバに書き込まれたデータをコミットするためにのみ使用する必要があります。リカバリオプションについては、セクション12.7.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "13.8. The Layout Iomode",
      "section_title": true,
      "ja": "13.8. レイアウトIOModeに"
    },
    {
      "indent": 3,
      "text": "The layout iomode need not be used by the metadata server when servicing NFSv4.1 file-based layouts, although in some circumstances it may be useful. For example, if the server implementation supports reading from read-only replicas or mirrors, it would be useful for the server to return a layout enabling the client to do so. As such, the client SHOULD set the iomode based on its intent to read or write the data. The client may default to an iomode of LAYOUTIOMODE4_RW.",
      "ja": "NFSv4.1ファイルベースのレイアウトを保守するとき、いくつかの状況では、それは有用である可能性があるが、レイアウトIOModeには、メタデータ・サーバで使用する必要はありません。サーバの実装は、読み取り専用レプリカまたはミラーからの読み取りサポートしている場合、サーバがそうするようにクライアントを有効にするレイアウトを返すようにするために、例えば、それは有用であろう。そのため、クライアントは、データを読み書きする意向をもとにIOModeに設定する必要があります。クライアントはLAYOUTIOMODE4_RWのIOModeににデフォルト設定があります。"
    },
    {
      "indent": 3,
      "text": "The iomode need not be checked by the data servers when clients perform I/O. However, the data servers SHOULD still validate that the client holds a valid layout and return an error if the client does not.",
      "ja": "クライアントは、I / Oを実行するときIOModeには、データ・サーバによって確認される必要がありません。しかし、データ・サーバは、まだクライアントが有効なレイアウトを保持していることを検証し、クライアントがない場合はエラーを返すべきです。"
    },
    {
      "indent": 0,
      "text": "13.9. Metadata and Data Server State Coordination",
      "section_title": true,
      "ja": "13.9. メタデータとデータサーバの状態コーディネーション"
    },
    {
      "indent": 0,
      "text": "13.9.1. Global Stateid Requirements",
      "section_title": true,
      "ja": "13.9.1. グローバルなstateid要件"
    },
    {
      "indent": 3,
      "text": "When the client sends I/O to a data server, the stateid used MUST NOT be a layout stateid as returned by LAYOUTGET or sent by CB_LAYOUTRECALL. Permitted stateids are based on one of the following: an OPEN stateid (the stateid field of data type OPEN4resok as returned by OPEN), a delegation stateid (the stateid field of data types open_read_delegation4 and open_write_delegation4 as returned by OPEN or WANT_DELEGATION, or as sent by CB_PUSH_DELEG), or a stateid returned by the LOCK or LOCKU operations. The stateid sent to the data server MUST be sent with the seqid set to zero, indicating the most current version of that stateid, rather than indicating a specific non-zero seqid value. In no case is the use of special stateid values allowed.",
      "ja": "クライアントがデータ・サーバーにI / Oを送信するとLAYOUTGETによって返されたかCB_LAYOUTRECALLによって送られたとして、使用のstateidは、レイアウトのstateidしているはずがありません。 OPENのstateid（OPENによって返されるデータ型OPEN4resokののstateidフィールド）、委任のstateid（OPENまたはWANT_DELEGATIONによって返されるopen_read_delegation4とopen_write_delegation4データ型のstateidフィールド、または送信された：許可のstateidsは、次のいずれかに基づいていますCB_PUSH_DELEGによって）、またはLOCKまたはLOCKU操作によって返されたstateid。データ・サーバに送信されたのstateidは、のstateidの最新バージョンを示すのではなく、特定の非ゼロSEQID値を示し、ゼロに設定SEQIDで送らなければなりません。いかなる場合も許可され特別なstateid値を使用することです。"
    },
    {
      "indent": 3,
      "text": "The stateid used for I/O MUST have the same effect and be subject to the same validation on a data server as it would if the I/O was being performed on the metadata server itself in the absence of pNFS. This has the implication that stateids are globally valid on both the metadata and data servers. This requires the metadata server to propagate changes in LOCK and OPEN state to the data servers, so that the data servers can validate I/O accesses. This is discussed further in Section 13.9.2. Depending on when stateids are propagated, the existence of a valid stateid on the data server may act as proof of a valid layout.",
      "ja": "I / Oに使用されるのstateidは同じ効果を有し、それがI / Oは、pNFSのが存在しない場合に、メタデータサーバ自体で実行されたかのようにデータサーバに同じ検証を受けなければなりません。これは、のstateidsは、メタデータとデータ・サーバの両方でグローバルに有効であることを暗示しています。データ・サーバが検証できるようにこれは、データ・サーバにLOCKとOPEN状態の変更を反映するために、メタデータ・サーバを必要とI / Oアクセス。これは、セクション13.9.2でさらに議論されています。 stateidsが伝播されたときに応じて、データ・サーバ上の有効なstateidの存在は、有効なレイアウトの証拠として作用することができます。"
    },
    {
      "indent": 3,
      "text": "Clients performing I/O operations need to select an appropriate stateid based on the locks (including opens and delegations) held by the client and the various types of state-owners sending the I/O requests. The rules for doing so when referencing data servers are somewhat different from those discussed in Section 8.2.5, which apply when accessing metadata servers.",
      "ja": "I / O操作を実行するクライアントは、クライアントが保持している（開いて代表団を含む）ロックおよびI / O要求を送信状態の所有者の様々なタイプに基づいて適切なstateidを選択する必要があります。データ・サーバを参照するときにそれを行うためのルールは、メタデータサーバにアクセスする際に適用される8.2.5項で説明したもの、多少異なります。"
    },
    {
      "indent": 3,
      "text": "The following rules, applied in order of decreasing priority, govern the selection of the appropriate stateid:",
      "ja": "優先度の高いものから順に適用される以下の規則は、適切なのstateidの選択を支配します。"
    },
    {
      "indent": 3,
      "text": "o If the client holds a delegation for the file in question, the delegation stateid should be used.",
      "ja": "クライアントは、問題のファイルのための委任を保持している場合は、O、委任のstateidを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, there must be an OPEN stateid for the current open-owner, and that OPEN stateid for the open file in question is used, unless mandatory locking prevents that. See below.",
      "ja": "Oそれ以外の場合は、現在開いている所有者のためのOPENのstateid、および強制ロックはそれを防止しない限り、問題の開いているファイルは、使用されているため、そのOPENのstateidがなければなりません。下記参照。"
    },
    {
      "indent": 3,
      "text": "o If the data server had previously responded with NFS4ERR_LOCKED to use of the OPEN stateid, then the client should use the byte-range lock stateid whenever one exists for that open file with the current lock-owner.",
      "ja": "データ・サーバは、以前にOPENのstateidの使用NFS4ERR_LOCKEDで応答した場合は1が、現在のロック所有者とその開いているファイルのために存在するたびO、その後、クライアントは、バイト範囲ロックのstateidを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Special stateids should never be used. If they are used, the data server MUST reject the I/O with an NFS4ERR_BAD_STATEID error.",
      "ja": "O特別のstateidsを使用すべきではありません。それらが使用されている場合は、データ・サーバは、NFS4ERR_BAD_STATEIDエラーでI / Oを拒絶しなければなりません。"
    },
    {
      "indent": 0,
      "text": "13.9.2. Data Server State Propagation",
      "section_title": true,
      "ja": "13.9.2.  Data Serverの状態の伝達"
    },
    {
      "indent": 3,
      "text": "Since the metadata server, which handles byte-range lock and open-mode state changes as well as ACLs, might not be co-located with the data servers where I/O accesses are validated, the server implementation MUST take care of propagating changes of this state to the data servers. Once the propagation to the data servers is complete, the full effect of those changes MUST be in effect at the data servers. However, some state changes need not be propagated immediately, although all changes SHOULD be propagated promptly. These state propagations have an impact on the design of the control protocol, even though the control protocol is outside of the scope of this specification. Immediate propagation refers to the synchronous propagation of state from the metadata server to the data server(s); the propagation must be complete before returning to the client.",
      "ja": "バイト範囲ロックとオープンモードの状態の変化だけでなく、ACLを処理するメタデータサーバ、以来、サーバーの実装はの変更を伝播するの世話をしなければならない、I / Oアクセスが検証され、データ・サーバと同じ場所に配置されない場合がありますデータ・サーバにこの状態。データ・サーバへの伝播が完了すると、それらの変更の完全な効果は、データ・サーバで有効でなければなりません。すべての変更が迅速に伝播されるべきであるものの、いくつかの状態の変化は、すぐに伝播する必要はありません。これらの状態の伝播は、制御プロトコルは、本明細書の範囲外であっても、制御プロトコルの設計に影響を与えます。即時伝搬は、データ・サーバ（群）にメタデータサーバからの状態の同期伝播を指します。伝播は、クライアントに戻る前に完了しなければなりません。"
    },
    {
      "indent": 0,
      "text": "13.9.2.1. Lock State Propagation",
      "section_title": true,
      "ja": "13.9.2.1。ロック状態の伝達"
    },
    {
      "indent": 3,
      "text": "If the pNFS server supports mandatory byte-range locking, any mandatory byte-range locks on a file MUST be made effective at the data servers before the request that establishes them returns to the caller. The effect MUST be the same as if the mandatory byte-range lock state were synchronously propagated to the data servers, even though the details of the control protocol may avoid actual transfer of the state under certain circumstances.",
      "ja": "pNFSのサーバーが必須バイト範囲ロックをサポートしている場合は、ファイル上の任意の必須のバイト範囲ロックは、彼らが呼び出し元に返し確立要求する前に、データ・サーバで有効にしなければなりません。必須のバイト範囲ロック状態が同期制御プロトコルの詳細は、特定の状況下での状態の実際の転送を回避することができるにもかかわらず、データ・サーバに伝播されたかのような効果は同じである必要があります。"
    },
    {
      "indent": 3,
      "text": "On the other hand, since advisory byte-range lock state is not used for checking I/O accesses at the data servers, there is no semantic reason for propagating advisory byte-range lock state to the data servers. Since updates to advisory locks neither confer nor remove privileges, these changes need not be propagated immediately, and may not need to be propagated promptly. The updates to advisory locks need only be propagated when the data server needs to resolve a question about a stateid. In fact, if byte-range locking is not mandatory (i.e., is advisory) the clients are advised to avoid using the byte-range lock-based stateids for I/O. The stateids returned by OPEN are sufficient and eliminate overhead for this kind of state propagation.",
      "ja": "諮問バイト範囲ロック状態がI / Oは、データ・サーバにアクセスし確認するために使用されていないので、一方、データ・サーバへの助言バイト範囲ロック状態を伝播するためのセマンティックな理由はありません。勧告的ロックへのアップデートもない与えたり削除権限ので、これらの変更はすぐに伝播する必要はなく、かつ迅速に伝播する必要はないかもしれません。勧告的ロックへの更新は、データ・サーバがのstateidについての質問を解決する必要がある場合にのみ伝播することが必要です。 （すなわち、顧問である）、実際には、バイト範囲ロックは必須でない場合、クライアントは、I / Oのためのバイト範囲ロックベースのstateidsを使用しないように助言されます。 OPENによって返さのstateidsは十分であり、状態伝播のこの種のためのオーバーヘッドを排除します。"
    },
    {
      "indent": 3,
      "text": "If a client gets back an NFS4ERR_LOCKED error from a data server, this is an indication that mandatory byte-range locking is in force. The client recovers from this by getting a byte-range lock that covers the affected range and re-sends the I/O with the stateid of the byte-range lock.",
      "ja": "クライアントはデータサーバからNFS4ERR_LOCKEDエラーが戻って取得した場合、これは必須バイト範囲ロックが力であることを示しています。クライアントは、影響を受ける範囲をカバーし、バイト範囲ロックののstateidとのI / Oを再送信バイト範囲ロックを取得することによって、このから回復します。"
    },
    {
      "indent": 0,
      "text": "13.9.2.2. Open and Deny Mode Validation",
      "section_title": true,
      "ja": "13.9.2.2。オープンとモードの検証を拒否"
    },
    {
      "indent": 3,
      "text": "Open and deny mode validation MUST be performed against the open and deny mode(s) held by the data servers. When access is reduced or a deny mode made more restrictive (because of CLOSE or OPEN_DOWNGRADE), the data server MUST prevent any I/Os that would be denied if performed on the metadata server. When access is expanded, the data server MUST make sure that no requests are subsequently rejected because of open or deny issues that no longer apply, given the previous relaxation.",
      "ja": "オープンと拒否モードの検証は、データ・サーバに保持されたオープンおよび拒否モード（S）に対して実行されなければなりません。アクセスが（理由はCLOSEまたはOPEN_DOWNGRADEの）減少または拒否モードがより制限行われると、データ・サーバは、メタデータサーバ上で実行された場合拒否されることになる任意のI / Oを防止しなければなりません。アクセスが展開されると、データ・サーバは、何の要求がその後、前のリラクゼーション与えられ、なぜなら、もはや適用されないオープンまたは拒否の問題により拒否されていないことを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "13.9.2.3. File Attributes",
      "section_title": true,
      "ja": "13.9.2.3。ファイル属性"
    },
    {
      "indent": 3,
      "text": "Since the SETATTR operation has the ability to modify state that is visible on both the metadata and data servers (e.g., the size), care must be taken to ensure that the resultant state across the set of data servers is consistent, especially when truncating or growing the file.",
      "ja": "SETATTR操作は、メタデータとデータサーバ（例えば、サイズ）の両方で表示される状態を変更する能力を有しているので、注意を切り捨てる場合は特に、データ・サーバのセットにわたって得られた状態が一貫していることを保証するために注意しなければならない、またはファイルを栽培。"
    },
    {
      "indent": 3,
      "text": "As described earlier, the LAYOUTCOMMIT operation is used to ensure that the metadata is synchronized with changes made to the data servers. For the NFSv4.1-based data storage protocol, it is necessary to re-synchronize state such as the size attribute, and the setting of mtime/change/atime. See Section 12.5.4 for a full description of the semantics regarding LAYOUTCOMMIT and attribute synchronization. It should be noted that by using an NFSv4.1-based layout type, it is possible to synchronize this state before LAYOUTCOMMIT occurs. For example, the control protocol can be used to query the attributes present on the data servers.",
      "ja": "前述したように、LAYOUTCOMMIT操作は、メタデータは、データ・サーバに加えられた変更と同期していることを確実にするために使用されます。 NFSv4.1ベースのデータ・ストレージ・プロトコルのために、そのようなサイズ属性、および最終変更時刻/変更/のatimeの設定と再同期状態にする必要があります。 LAYOUTCOMMITと属性の同期に関するセマンティクスの完全な説明については、セクション12.5.4を参照してください。 NFSv4.1ベースのレイアウトタイプを使用して、LAYOUTCOMMITが発生する前にこの状態を同期することが可能であることに留意すべきです。例えば、制御プロトコルは、データ・サーバー上に存在する属性を照会するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Any changes to file attributes that control authorization or access as reflected by ACCESS calls or READs and WRITEs on the metadata server, MUST be propagated to the data servers for enforcement on READ and WRITE I/O calls. If the changes made on the metadata server result in more restrictive access permissions for any user, those changes MUST be propagated to the data servers synchronously.",
      "ja": "アクセス呼び出しによって反射または読み込み、メタデータ・サーバ上で書いているように、許可またはアクセスを制御する属性をファイルへの変更は、READおよびWRITE I / O呼び出しに施行するためのデータ・サーバに伝播されなければなりません。すべてのユーザーのためのより限定的なアクセス権限内のメタデータ・サーバの結果に加えられた変更した場合、それらの変更が同期してデータ・サーバに伝播されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The OPEN operation (Section 18.16.4) does not impose any requirement that I/O operations on an open file have the same credentials as the OPEN itself (unless EXCHGID4_FLAG_BIND_PRINC_STATEID is set when EXCHANGE_ID creates the client ID), and so it requires the server's READ and WRITE operations to perform appropriate access checking. Changes to ACLs also require new access checking by READ and WRITE on the server. The propagation of access-right changes due to changes in ACLs may be asynchronous only if the server implementation is able to determine that the updated ACL is not more restrictive for any user specified in the old ACL. Due to the relative infrequency of ACL updates, it is suggested that all changes be propagated synchronously.",
      "ja": "OPEN操作（セクション18.16.4）（EXCHANGE_IDは、クライアントIDを作成するときにEXCHGID4_FLAG_BIND_PRINC_STATEIDが設定されていない限り）開いたファイルへのI / O操作がOPEN自体と同じ資格情報を持っているどのような要件を課していない、ので、それは、サーバーのが必要です適切なアクセスチェックを実行するための操作を読み書きします。 ACLのへの変更もREADでチェックし、新たなアクセスを必要とし、サーバー上で書き込み。 ACLの変化に起因するアクセス権の変更の伝播は、サーバの実装が更新ACLが古いACLに指定されたすべてのユーザーのために、より限定されないことを判断することができる場合にのみ、非同期かもしれません。 ACLの更新の相対的な低頻度のために、すべての変更が同期伝播されることが示唆されます。"
    },
    {
      "indent": 0,
      "text": "13.10. Data Server Component File Size",
      "section_title": true,
      "ja": "13.10. データ・サーバー・コンポーネントのファイルサイズ"
    },
    {
      "indent": 3,
      "text": "A potential problem exists when a component data file on a particular data server has grown past EOF; the problem exists for both dense and sparse layouts. Imagine the following scenario: a client creates a new file (size == 0) and writes to byte 131072; the client then seeks to the beginning of the file and reads byte 100. The client should receive zeroes back as a result of the READ. However, if the striping pattern directs the client to send the READ to a data server other than the one that received the client's original WRITE, the data server servicing the READ may believe that the file's size is still 0 bytes. In that event, the data server's READ response will contain zero bytes and an indication of EOF. The data server can only return zeroes if it knows that the file's size has been extended. This would require the immediate propagation of the file's size to all data servers, which is potentially very costly. Therefore, the client that has initiated the extension of the file's size MUST be prepared to deal with these EOF conditions. When the offset in the arguments to READ is less than the client's view of the file size, if the READ response indicates EOF and/or contains fewer bytes than requested, the client will interpret such a response as a hole in the file, and the NFS client will substitute zeroes for the data.",
      "ja": "潜在的な問題は、特定のデータ・サーバ上のコンポーネントデータファイルがEOFを越えて成長したときに存在します。問題が密と疎のレイアウトの両方のために存在します。次のシナリオを想像します。クライアントは新しいファイル（サイズ== 0）を作成し、バイト131072に書き込みます。その後、クライアントは、ファイルの先頭にシークし、クライアントがREADの結果としてゼロをバック受け取るべきバイト100を読み込みます。ストライピングパターンがクライアントの元のWRITEを受信した1つ以外のデータ・サーバへのREADを送信するためにクライアントを指示した場合ただし、READにサービスを提供するデータ・サーバは、ファイルのサイズは依然として0バイトであることを信じていることがあります。その場合には、データ・サーバのREAD応答がゼロバイトとEOFの表示が含まれています。それは、ファイルのサイズが拡張されていることを知っている場合、データ・サーバーは、ゼロだけを返すことができます。これは潜在的に非常に高価であり、すべてのデータ・サーバへのファイルのサイズの直接の伝播を必要とします。そのため、ファイルのサイズの拡張を開始したクライアントは、これらのEOF条件に対処するために準備しなければなりません。 READ応答がEOFを示し、および/または要求されたよりも少ないバイトが含まれている場合は、ファイルサイズのクライアントの観点より小さいREADする引数でオフセットすると、クライアントは、ファイル内の穴のような応答を解釈し、かつますNFSクライアントは、データのためのゼロを代用します。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol only provides close-to-open file data cache semantics; meaning that when the file is closed, all modified data is written to the server. When a subsequent OPEN of the file is done, the change attribute is inspected for a difference from a cached value for the change attribute. For the case above, this means that a LAYOUTCOMMIT will be done at close (along with the data WRITEs) and will update the file's size and change attribute. Access from another client after that point will result in the appropriate size being returned.",
      "ja": "NFSv4.1プロトコルは唯一に近いツーオープンファイルのデータ・キャッシュ・セマンティクスを提供します。ファイルを閉じたときに、すべての変更されたデータがサーバに書かれていることを意味しています。ファイルのその後のOPENが行われた場合、変更属性が変化属性のキャッシュされた値との差のために検査されます。上記の場合では、これはLAYOUTCOMMITが（データへの書き込みと一緒に）終了時点で行われますと、ファイルのサイズと変更属性を更新することを意味します。その時点の後に、別のクライアントからのアクセスは、適切なサイズが返されることになります。"
    },
    {
      "indent": 0,
      "text": "13.11. Layout Revocation and Fencing",
      "section_title": true,
      "ja": "13.11. レイアウト失効とフェンシング"
    },
    {
      "indent": 3,
      "text": "As described in Section 12.7, the layout-type-specific storage protocol is responsible for handling the effects of I/Os that started before lease expiration and extend through lease expiration. The LAYOUT4_NFSV4_1_FILES layout type can prevent all I/Os to data servers from being executed after lease expiration (this prevention is called \"fencing\"), without relying on a precise client lease timer and without requiring data servers to maintain lease timers. The LAYOUT4_NFSV4_1_FILES pNFS server has the flexibility to revoke individual layouts, and thus fence I/O on a per-file basis.",
      "ja": "12.7節で説明したように、レイアウト・タイプ固有のストレージプロトコルは、リース満了前に開始し、リース満了を通って延びてI / Oの影響を処理する責任を負っています。 LAYOUT4_NFSV4_1_FILESのレイアウトタイプは、正確なクライアントのリースタイマーに頼ることなく、リースタイマーを維持するために、データ・サーバを必要とせずに、（この予防は「フェンシング」と呼ばれている）、リース満了後に実行されることから、データ・サーバへのすべてのI / Oを防ぐことができます。 LAYOUT4_NFSV4_1_FILESのpNFSサーバーは、ファイルごとに個別のレイアウト、ひいてはフェンスI / Oを取り消すための柔軟性を持っています。"
    },
    {
      "indent": 3,
      "text": "In addition to lease expiration, the reasons a layout can be revoked include: client fails to respond to a CB_LAYOUTRECALL, the metadata server restarts, or administrative intervention. Regardless of the reason, once a client's layout has been revoked, the pNFS server MUST prevent the client from sending I/O for the affected file from and to all data servers; in other words, it MUST fence the client from the affected file on the data servers.",
      "ja": "有効期限をリースに加えて、レイアウトを取り消すことができる理由は、次のとおりです。クライアントがCB_LAYOUTRECALL、メタデータサーバの再起動、または管理者の介入への応答に失敗しました。クライアントのレイアウトが取り消された後理由の如何を問わず、pNFSのサーバから、すべてのデータ・サーバへの影響を受けるファイルのI / Oを送信してからクライアントを防止しなければなりません。換言すれば、データ・サーバ上の影響を受けるファイルからフェンスのクライアントをしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Fencing works as follows. As described in Section 13.1, in COMPOUND procedure requests to the data server, the data filehandle provided by the PUTFH operation and the stateid in the READ or WRITE operation are used to ensure that the client has a valid layout for the I/O being performed; if it does not, the I/O is rejected with NFS4ERR_PNFS_NO_LAYOUT. The server can simply check the stateid and, additionally, make the data filehandle stale if the layout specified a data filehandle that is different from the metadata server's filehandle for the file (see the nfl_fh_list description in Section 13.3).",
      "ja": "次のようにフェンシングが動作します。データ・サーバへの化合物の手続き要求で、セクション13.1で説明したように、PUTFH動作とREADまたはWRITE動作中のstateidによって提供されたデータファイルハンドルは、クライアントが実行されるI / Oのための有効な配置であることを保証するために使用されています;そうでない場合は、I / OはNFS4ERR_PNFS_NO_LAYOUTで拒否されます。サーバは単にたstateidをチェックし、さらに、レイアウトは（セクション13.3でnfl_fh_list説明を参照）、ファイルのメタデータ・サーバのファイルハンドルと異なるデータファイルハンドルを指定した場合、データファイルハンドルが古いことができます。"
    },
    {
      "indent": 3,
      "text": "Before the metadata server takes any action to revoke layout state given out by a previous instance, it must make sure that all layout state from that previous instance are invalidated at the data servers. This has the following implications.",
      "ja": "メタデータサーバは、前のインスタンスによって与えられたレイアウト状態を取り消すために、任意のアクションを実行する前に、その前のインスタンスからすべてのレイアウト状態は、データ・サーバで無効にされていることを確認する必要があります。これは、次のような意義があります。"
    },
    {
      "indent": 3,
      "text": "o The metadata server must not restripe a file until it has contacted all of the data servers to invalidate the layouts from the previous instance.",
      "ja": "それは前のインスタンスからレイアウトを無効にするために、データ・サーバのすべてに接触したまではOメタデータサーバは、ファイルを再ストライプしてはなりません。"
    },
    {
      "indent": 3,
      "text": "o The metadata server must not give out mandatory locks that conflict with layouts from the previous instance without either doing a specific layout invalidation (as it would have to do anyway) or doing a global data server invalidation.",
      "ja": "oをメタデータサーバは、特定のレイアウトの無効化を行っている（それはとにかくしなければならないように）またはグローバル・データ・サーバの無効化を行うことのいずれかせずに前のインスタンスからのレイアウトとの競合強制ロックを与えてはいけません。"
    },
    {
      "indent": 0,
      "text": "13.12. Security Considerations for the File Layout Type",
      "section_title": true,
      "ja": "13.12. ファイルのレイアウトタイプのセキュリティに関する注意点"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 file layout type MUST adhere to the security considerations outlined in Section 12.9. NFSv4.1 data servers MUST make all of the required access checks on each READ or WRITE I/O as determined by the NFSv4.1 protocol. If the metadata server would deny a READ or WRITE operation on a file due to its ACL, mode attribute, open access mode, open deny mode, mandatory byte-range lock state, or any other attributes and state, the data server MUST also deny the READ or WRITE operation. This impacts the control protocol and the propagation of state from the metadata server to the data servers; see Section 13.9.2 for more details.",
      "ja": "NFSv4.1ファイルのレイアウトタイプは、セクション12.9に概説されたセキュリティ上の考慮事項に従わなければなりません。 NFSv4.1データ・サーバのI / O NFSv4.1プロトコルによって決定された各READまたはWRITEに必要なアクセスチェックのすべてを行う必要があります。メタデータサーバが原因ACLは、mode属性、オープンアクセスモードは、オープンモード、必須バイト範囲ロック状態、または任意の他の属性と状態を否定し、データ・サーバも拒否しなければならないのに対して、ファイルのREADまたはWRITE操作を拒否したい場合READまたはWRITE操作。この影響制御プロトコルとデータ・サーバにメタデータサーバからの状態の伝播。詳細については、セクション13.9.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The methods for authentication, integrity, and privacy for data servers based on the LAYOUT4_NFSV4_1_FILES layout type are the same as those used by metadata servers. Metadata and data servers use ONC RPC security flavors to authenticate, and SECINFO and SECINFO_NO_NAME to negotiate the security mechanism and services to be used. Thus, when using the LAYOUT4_NFSV4_1_FILES layout type, the impact on the RPC-based security model due to pNFS (as alluded to in Sections 1.7.1 and 1.7.2.2) is zero.",
      "ja": "LAYOUT4_NFSV4_1_FILESのレイアウトタイプに基づいて、データ・サーバの認証、整合性、およびプライバシーのための方法は、メタデータサーバによって使用されるものと同じです。メタデータとデータのサーバが認証するためにONC RPCセキュリティ風味を使用し、SECINFOとSECINFO_NO_NAMEは、使用するセキュリティ・メカニズムとサービスを交渉します。 LAYOUT4_NFSV4_1_FILESレイアウトタイプを使用する場合したがって、pNFSのによるRPCベースのセキュリティモデル（セクション1.7.1および1.7.2.2に示唆したように）への影響はゼロです。"
    },
    {
      "indent": 3,
      "text": "For a given file object, a metadata server MAY require different security parameters (secinfo4 value) than the data server. For a given file object with multiple data servers, the secinfo4 value SHOULD be the same across all data servers. If the secinfo4 values across a metadata server and its data servers differ for a specific file, the mapping of the principal to the server's internal user identifier MUST be the same in order for the access-control checks based on ACL, mode, open and deny mode, and mandatory locking to be consistent across on the pNFS server.",
      "ja": "与えられたファイルオブジェクトの場合は、メタデータサーバは、データ・サーバとは別のセキュリティパラメータ（secinfo4値）を必要とするかもしれません。複数のデータ・サーバで指定したファイルオブジェクトの場合は、secinfo4値は、すべてのデータ・サーバ間で同じでなければなりません。 secinfo4メタデータサーバを横切る値とそのデータサーバが特定ファイルに対して異なる場合、サーバ内部のユーザ識別子にプリンシパルのマッピングは、ACL、モードに基づいてアクセス制御をチェックするためにオープン同じであると拒否する必要がありますモード、およびpNFSのサーバ上で一致しているために強制ロック。"
    },
    {
      "indent": 3,
      "text": "If an NFSv4.1 implementation supports pNFS and supports NFSv4.1 file layouts, then the implementation MUST support the SECINFO_NO_NAME operation on both the metadata and data servers.",
      "ja": "NFSv4.1実装がpNFSのをサポートし、NFSv4.1ファイルのレイアウトをサポートしている場合は、その実装は、メタデータとデータ・サーバの両方でSECINFO_NO_NAME操作をサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "14. Internationalization",
      "section_title": true,
      "ja": "14.国際化"
    },
    {
      "indent": 3,
      "text": "The primary issue in which NFSv4.1 needs to deal with internationalization, or I18N, is with respect to file names and other strings as used within the protocol. The choice of string representation must allow reasonable name/string access to clients that use various languages. The UTF-8 encoding of the UCS (Universal Multiple-Octet Coded Character Set) as defined by ISO10646 [21] allows for this type of access and follows the policy described in \"IETF Policy on Character Sets and Languages\", RFC 2277 [22].",
      "ja": "NFSv4.1は、国際化、またはI18Nに対処する必要のある主な問題は、プロトコル内で使用される名前や他の文字列をファイルに関連しています。文字列表現の選択は、さまざまな言語を使用するクライアントへの合理的な名前/文字列へのアクセスを許可する必要があります。 ISO10646 [21]によって定義されるようにUCSのUTF-8エンコーディング（ユニバーサルマルチオクテット符号化文字セットが）このタイプのアクセスを可能にし、「文字セットと言語でIETF方針」に記載されたポリシーに従う、RFC 2277 [22 ]。"
    },
    {
      "indent": 3,
      "text": "RFC 3454 [19], otherwise know as \"stringprep\", documents a framework for using Unicode/UTF-8 in networking protocols so as \"to increase the likelihood that string input and string comparison work in ways that make sense for typical users throughout the world\". A protocol must define a profile of stringprep \"in order to fully specify the processing options\". The remainder of this section defines the NFSv4.1 stringprep profiles. Much of the terminology used for the remainder of this section comes from stringprep.",
      "ja": "RFC 3454 [19]、それ以外の場合は「文字列前」として知っている、全体の典型的なユーザーのために意味をなすかの方法で「可能性を高めるために、その文字列を入力し、文字列の比較の作品としてネットワークプロトコルでのUnicode / UTF-8をして使用するためのフレームワークを文書化世界\"。プロトコルは、「完全に処理オプションを指定するために」文字列準備のプロファイルを定義しなければなりません。このセクションの残りの部分は、NFSv4.1文字列準備プロファイルを定義します。このセクションの残りのために使用される用語の多くは、文字列前から来ています。"
    },
    {
      "indent": 3,
      "text": "There are three UTF-8 string types defined for NFSv4.1: utf8str_cs, utf8str_cis, and utf8str_mixed. Separate profiles are defined for each. Each profile defines the following, as required by stringprep:",
      "ja": "utf8str_cs、utf8str_cis、およびutf8str_mixed：3 UTF-8文字列NFSv4.1のために定義されたタイプがあります。個別のプロファイルがそれぞれのために定義されています。文字列準備することにより、必要に応じて、各プロファイルには、次のように定義しています。"
    },
    {
      "indent": 3,
      "text": "o The intended applicability of the profile.",
      "ja": "プロファイルの意図適用O。"
    },
    {
      "indent": 3,
      "text": "o The character repertoire that is the input and output to stringprep (which is Unicode 3.2 for the referenced version of stringprep). However, NFSv4.1 implementations are not limited to 3.2.",
      "ja": "（文字列準備の参照バージョンのUnicode 3.2である）STRINGPREPする入力と出力される文字レパートリO。しかし、NFSv4.1実装は3.2に限定されるものではありません。"
    },
    {
      "indent": 3,
      "text": "o The mapping tables from stringprep used (as described in Section 3 of stringprep).",
      "ja": "文字列準備からマッピングテーブルO（文字列準備のセクション3に記載されているように）を使用しました。"
    },
    {
      "indent": 3,
      "text": "o Any additional mapping tables specific to the profile.",
      "ja": "プロファイルに固有の追加のマッピングテーブルO。"
    },
    {
      "indent": 3,
      "text": "o The Unicode normalization used, if any (as described in Section 4 of stringprep).",
      "ja": "O Unicode正規化を用い、もしあれば（文字列準備のセクション4に記載されているように）。"
    },
    {
      "indent": 3,
      "text": "o The tables from the stringprep listing of characters that are prohibited as output (as described in Section 5 of stringprep).",
      "ja": "出力として禁止されている文字の文字列準備リストからテーブルO（文字列準備のセクション5に記載されているように）。"
    },
    {
      "indent": 3,
      "text": "o The bidirectional string testing used, if any (as described in Section 6 of stringprep).",
      "ja": "O双方向ストリング試験を用い、もしあれば（文字列準備の第6章に記載されているように）。"
    },
    {
      "indent": 3,
      "text": "o Any additional characters that are prohibited as output specific to the profile.",
      "ja": "プロファイルに固有の出力として禁止されている任意の追加の文字O。"
    },
    {
      "indent": 3,
      "text": "Stringprep discusses Unicode characters, whereas NFSv4.1 renders UTF-8 characters. Since there is a one-to-one mapping from UTF-8 to Unicode, when the remainder of this document refers to Unicode, the reader should assume UTF-8.",
      "ja": "NFSv4.1は、UTF-8文字をレンダリングするのに対し。文字列は、Unicode文字を説明します。 UTF-8からUnicodeへの1対1のマッピングがあるので、この文書の残りはユニコードを指す場合、読者は、UTF-8を想定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Much of the text for the profiles comes from RFC 3491 [23].",
      "ja": "プロファイル用のテキストの多くはRFC 3491 [23]から来ています。"
    },
    {
      "indent": 0,
      "text": "14.1. Stringprep Profile for the utf8str_cs Type",
      "section_title": true,
      "ja": "14.1.  utf8str_csタイプのためのstringprepプロフィール"
    },
    {
      "indent": 3,
      "text": "Every use of the utf8str_cs type definition in the NFSv4 protocol specification follows the profile named nfs4_cs_prep.",
      "ja": "NFSv4のプロトコル仕様でutf8str_cs型定義のすべての使用はnfs4_cs_prepという名前のプロファイルに従っています。"
    },
    {
      "indent": 0,
      "text": "14.1.1. Intended Applicability of the nfs4_cs_prep Profile",
      "section_title": true,
      "ja": "14.1.1.  nfs4_cs_prepプロフィールの意図の適用"
    },
    {
      "indent": 3,
      "text": "The utf8str_cs type is a case-sensitive string of UTF-8 characters. Its primary use in NFSv4.1 is for naming components and pathnames. Components and pathnames are stored on the server's file system. Two valid distinct UTF-8 strings might be the same after processing via the utf8str_cs profile. If the strings are two names inside a directory, the NFSv4.1 server will need to either:",
      "ja": "utf8str_cs型はUTF-8文字の大文字と小文字を区別した文字列です。 NFSv4.1での主な用途は、コンポーネントとパス名の命名です。コンポーネントとパス名は、サーバーのファイルシステムに格納されています。 2つの有効な個別のUTF-8文字列は、utf8str_csプロファイルを経由して処理した後、同じかもしれません。文字列は、ディレクトリ内の2名の場合は、NFSv4.1サーバーは、どちらかにする必要があります。"
    },
    {
      "indent": 3,
      "text": "o disallow the creation of a second name if its post-processed form collides with that of an existing name, or",
      "ja": "Oその後処理フォームが既存の名前のそれと衝突する場合は、2番目の名前の作成を許可しない、または"
    },
    {
      "indent": 3,
      "text": "o allow the creation of the second name, but arrange so that after post-processing, the second name is different than the post-processed form of the first name.",
      "ja": "O 2番目の名前の作成を可能にするが、後処理の後に、2番目の名前が最初に名前の後処理形態とは異なるようにアレンジ。"
    },
    {
      "indent": 0,
      "text": "14.1.2. Character Repertoire of nfs4_cs_prep",
      "section_title": true,
      "ja": "14.1.2.  nfs4_cs_prepの文字レパートリ"
    },
    {
      "indent": 3,
      "text": "The nfs4_cs_prep profile uses Unicode 3.2, as defined in stringprep's Appendix A.1. However, NFSv4.1 implementations are not limited to 3.2.",
      "ja": "文字列前の付録A.1で定義されているnfs4_cs_prepプロファイルは、ユニコード3.2を使用しています。しかし、NFSv4.1実装は3.2に限定されるものではありません。"
    },
    {
      "indent": 0,
      "text": "14.1.3. Mapping Used by nfs4_cs_prep",
      "section_title": true,
      "ja": "14.1.3.  nfs4_cs_prepによって使用されるマッピング"
    },
    {
      "indent": 3,
      "text": "The nfs4_cs_prep profile specifies mapping using the following tables from stringprep:",
      "ja": "nfs4_cs_prepプロファイルは、文字列前から、次の表を使用してマッピングを指定します。"
    },
    {
      "indent": 6,
      "text": "Table B.1",
      "ja": "表B.1"
    },
    {
      "indent": 3,
      "text": "Table B.2 is normally not part of the nfs4_cs_prep profile as it is primarily for dealing with case-insensitive comparisons. However, if the NFSv4.1 file server supports the case_insensitive file system attribute, and if case_insensitive is TRUE, the NFSv4.1 server MUST use Table B.2 (in addition to Table B1) when processing utf8str_cs strings, and the NFSv4.1 client MUST assume Table B.2 (in addition to Table B.1) is being used.",
      "ja": "それは大文字と小文字を区別しない比較に対処するため、主なように表B.2は、通常nfs4_cs_prepプロファイルの一部ではありません。しかし、utf8str_cs文字列を処理し、NFSv4.1ときNFSv4.1ファイルサーバはCASE_INSENSITIVEファイルシステム属性をサポートし、CASE_INSENSITIVEがTRUEの場合、NFSv4.1サーバーが（表B1に加えて）表B.2を使用する必要がある場合クライアントは、表B.2（表B.1に加えて）が使用されている仮定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the case_preserving attribute is present and set to FALSE, then the NFSv4.1 server MUST use Table B.2 to map case when processing utf8str_cs strings. Whether the server maps from lower to upper case or from upper to lower case is an implementation dependency.",
      "ja": "case_preserving属性がFALSEに存在し、設定されている場合、NFSv4.1サーバーがutf8str_cs文字列を処理する際にケースをマッピングするには、表B.2を使用しなければなりません。下ケースに大文字に下から又は上からサーバマップかどうかは実装依存です。"
    },
    {
      "indent": 0,
      "text": "14.1.4. Normalization used by nfs4_cs_prep",
      "section_title": true,
      "ja": "14.1.4.  nfs4_cs_prepで使用される正規化"
    },
    {
      "indent": 3,
      "text": "The nfs4_cs_prep profile does not specify a normalization form. A later revision of this specification may specify a particular normalization form. Therefore, the server and client can expect that they may receive unnormalized characters within protocol requests and responses. If the operating environment requires normalization, then the implementation must normalize utf8str_cs strings within the protocol before presenting the information to an application (at the client) or local file system (at the server).",
      "ja": "nfs4_cs_prepプロファイルは、正規化形式を指定しません。本明細書の以降の改訂は、特定の正規化形式を指定することができます。そのため、サーバとクライアントは、彼らがプロトコルの要求と応答の中に正規化されていない文字を受け取ることができることを期待することができます。動作環境が正常化が必要な場合は、その実装は、（サーバーで）（クライアントで）アプリケーションまたはローカルファイルシステムに情報を提示する前に、プロトコル内utf8str_cs文字列を正規化しなければなりません。"
    },
    {
      "indent": 0,
      "text": "14.1.5. Prohibited Output for nfs4_cs_prep",
      "section_title": true,
      "ja": "14.1.5.  nfs4_cs_prepのための出力禁止"
    },
    {
      "indent": 3,
      "text": "The nfs4_cs_prep profile RECOMMENDS prohibiting the use of the following tables from stringprep:",
      "ja": "nfs4_cs_prepプロファイルは文字列前から、次の表の使用を禁止するお勧めします。"
    },
    {
      "indent": 6,
      "text": "Table C.5",
      "ja": "表C.5"
    },
    {
      "indent": 6,
      "text": "Table C.6",
      "ja": "表C.6"
    },
    {
      "indent": 0,
      "text": "14.1.6. Bidirectional Output for nfs4_cs_prep",
      "section_title": true,
      "ja": "14.1.6.  nfs4_cs_prepのための双方向出力"
    },
    {
      "indent": 3,
      "text": "The nfs4_cs_prep profile does not specify any checking of bidirectional strings.",
      "ja": "nfs4_cs_prepプロファイルは双方向の文字列のいずれかのチェックを指定していません。"
    },
    {
      "indent": 0,
      "text": "14.2. Stringprep Profile for the utf8str_cis Type",
      "section_title": true,
      "ja": "14.2.  utf8str_cisタイプのためのstringprepプロフィール"
    },
    {
      "indent": 3,
      "text": "Every use of the utf8str_cis type definition in the NFSv4.1 protocol specification follows the profile named nfs4_cis_prep.",
      "ja": "NFSv4.1プロトコル仕様でutf8str_cis型定義のすべての使用はnfs4_cis_prepという名前のプロファイルに従っています。"
    },
    {
      "indent": 0,
      "text": "14.2.1. Intended Applicability of the nfs4_cis_prep Profile",
      "section_title": true,
      "ja": "14.2.1.  nfs4_cis_prepプロフィールの意図の適用"
    },
    {
      "indent": 3,
      "text": "The utf8str_cis type is a case-insensitive string of UTF-8 characters. Its primary use in NFSv4.1 is for naming NFS servers.",
      "ja": "utf8str_cis型はUTF-8文字の大文字と小文字を区別しない文字列です。 NFSv4.1での主な用途は、NFSサーバに名前を付けるためのものです。"
    },
    {
      "indent": 0,
      "text": "14.2.2. Character Repertoire of nfs4_cis_prep",
      "section_title": true,
      "ja": "14.2.2.  nfs4_cis_prepの文字レパートリ"
    },
    {
      "indent": 3,
      "text": "The nfs4_cis_prep profile uses Unicode 3.2, as defined in stringprep's Appendix A.1. However, NFSv4.1 implementations are not limited to 3.2.",
      "ja": "文字列前の付録A.1で定義されているnfs4_cis_prepプロファイルは、ユニコード3.2を使用しています。しかし、NFSv4.1実装は3.2に限定されるものではありません。"
    },
    {
      "indent": 0,
      "text": "14.2.3. Mapping Used by nfs4_cis_prep",
      "section_title": true,
      "ja": "14.2.3.  nfs4_cis_prepによって使用されるマッピング"
    },
    {
      "indent": 3,
      "text": "The nfs4_cis_prep profile specifies mapping using the following tables from stringprep:",
      "ja": "nfs4_cis_prepプロファイルは、文字列前から、次の表を使用してマッピングを指定します。"
    },
    {
      "indent": 6,
      "text": "Table B.1",
      "ja": "表B.1"
    },
    {
      "indent": 6,
      "text": "Table B.2",
      "ja": "表B.2"
    },
    {
      "indent": 0,
      "text": "14.2.4. Normalization Used by nfs4_cis_prep",
      "section_title": true,
      "ja": "14.2.4.  nfs4_cis_prepで使用される正規化"
    },
    {
      "indent": 3,
      "text": "The nfs4_cis_prep profile specifies using Unicode normalization form KC, as described in stringprep.",
      "ja": "nfs4_cis_prepプロファイルは、文字列準備で説明したように、KC形態ユニコード正規化を使用して指定します。"
    },
    {
      "indent": 0,
      "text": "14.2.5. Prohibited Output for nfs4_cis_prep",
      "section_title": true,
      "ja": "14.2.5.  nfs4_cis_prepのための出力禁止"
    },
    {
      "indent": 3,
      "text": "The nfs4_cis_prep profile specifies prohibiting using the following tables from stringprep:",
      "ja": "nfs4_cis_prepプロファイルは、文字列前から、次の表を使用禁止に指定します。"
    },
    {
      "indent": 6,
      "text": "Table C.1.2",
      "ja": "表C.1.2"
    },
    {
      "indent": 6,
      "text": "Table C.2.2",
      "ja": "表C.2.2"
    },
    {
      "indent": 6,
      "text": "Table C.3",
      "ja": "表C.3"
    },
    {
      "indent": 6,
      "text": "Table C.4",
      "ja": "表C.4"
    },
    {
      "indent": 6,
      "text": "Table C.5",
      "ja": "表C.5"
    },
    {
      "indent": 6,
      "text": "Table C.6",
      "ja": "表C.6"
    },
    {
      "indent": 6,
      "text": "Table C.7",
      "ja": "表C.7"
    },
    {
      "indent": 6,
      "text": "Table C.8",
      "ja": "表C.8"
    },
    {
      "indent": 6,
      "text": "Table C.9",
      "ja": "表C.9"
    },
    {
      "indent": 0,
      "text": "14.2.6. Bidirectional Output for nfs4_cis_prep",
      "section_title": true,
      "ja": "14.2.6.  nfs4_cis_prepのための双方向出力"
    },
    {
      "indent": 3,
      "text": "The nfs4_cis_prep profile specifies checking bidirectional strings as described in stringprep's Section 6.",
      "ja": "nfs4_cis_prepプロファイルは、文字列前の第6節で説明したように、双方向の文字列をチェックする指定します。"
    },
    {
      "indent": 0,
      "text": "14.3. Stringprep Profile for the utf8str_mixed Type",
      "section_title": true,
      "ja": "14.3.  utf8str_mixedタイプのためのstringprepプロフィール"
    },
    {
      "indent": 3,
      "text": "Every use of the utf8str_mixed type definition in the NFSv4.1 protocol specification follows the profile named nfs4_mixed_prep.",
      "ja": "NFSv4.1プロトコル仕様でutf8str_mixed型定義のすべての使用はnfs4_mixed_prepという名前のプロファイルに従っています。"
    },
    {
      "indent": 0,
      "text": "14.3.1. Intended Applicability of the nfs4_mixed_prep Profile",
      "section_title": true,
      "ja": "14.3.1.  nfs4_mixed_prepプロフィールの意図の適用"
    },
    {
      "indent": 3,
      "text": "The utf8str_mixed type is a string of UTF-8 characters, with a prefix that is case sensitive, a separator equal to '@', and a suffix that is a fully qualified domain name. Its primary use in NFSv4.1 is for naming principals identified in an Access Control Entry.",
      "ja": "utf8str_mixedタイプは大文字と小文字が区別され、プレフィックス、「@」に等しく、セパレータ、および完全修飾ドメイン名である接尾辞UTF-8文字の文字列です。 NFSv4.1での主な用途は、アクセス制御エントリで識別プリンシパルに名前を付けるためのものです。"
    },
    {
      "indent": 0,
      "text": "14.3.2. Character Repertoire of nfs4_mixed_prep",
      "section_title": true,
      "ja": "14.3.2.  nfs4_mixed_prepの文字レパートリ"
    },
    {
      "indent": 3,
      "text": "The nfs4_mixed_prep profile uses Unicode 3.2, as defined in stringprep's Appendix A.1. However, NFSv4.1 implementations are not limited to 3.2.",
      "ja": "文字列前の付録A.1で定義されているnfs4_mixed_prepプロファイルは、ユニコード3.2を使用しています。しかし、NFSv4.1実装は3.2に限定されるものではありません。"
    },
    {
      "indent": 0,
      "text": "14.3.3. Mapping Used by nfs4_cis_prep",
      "section_title": true,
      "ja": "14.3.3.  nfs4_cis_prepによって使用されるマッピング"
    },
    {
      "indent": 3,
      "text": "For the prefix and the separator of a utf8str_mixed string, the nfs4_mixed_prep profile specifies mapping using the following table from stringprep:",
      "ja": "プレフィックスとutf8str_mixed列の分離のために、nfs4_mixed_prepプロファイルが文字列準備から次の表を使用してマッピングを指定します。"
    },
    {
      "indent": 6,
      "text": "Table B.1",
      "ja": "表B.1"
    },
    {
      "indent": 3,
      "text": "For the suffix of a utf8str_mixed string, the nfs4_mixed_prep profile specifies mapping using the following tables from stringprep:",
      "ja": "utf8str_mixed文字列のサフィックスについて、nfs4_mixed_prepプロファイルは、文字列前から、次の表を使用してマッピングを指定します。"
    },
    {
      "indent": 6,
      "text": "Table B.1",
      "ja": "表B.1"
    },
    {
      "indent": 6,
      "text": "Table B.2",
      "ja": "表B.2"
    },
    {
      "indent": 0,
      "text": "14.3.4. Normalization Used by nfs4_mixed_prep",
      "section_title": true,
      "ja": "14.3.4.  nfs4_mixed_prepで使用される正規化"
    },
    {
      "indent": 3,
      "text": "The nfs4_mixed_prep profile specifies using Unicode normalization form KC, as described in stringprep.",
      "ja": "nfs4_mixed_prepプロファイルは、文字列準備で説明したように、KC形態ユニコード正規化を使用して指定します。"
    },
    {
      "indent": 0,
      "text": "14.3.5. Prohibited Output for nfs4_mixed_prep",
      "section_title": true,
      "ja": "14.3.5.  nfs4_mixed_prepのための出力禁止"
    },
    {
      "indent": 3,
      "text": "The nfs4_mixed_prep profile specifies prohibiting using the following tables from stringprep:",
      "ja": "nfs4_mixed_prepプロファイルは、文字列前から、次の表を使用禁止に指定します。"
    },
    {
      "indent": 6,
      "text": "Table C.1.2",
      "ja": "表C.1.2"
    },
    {
      "indent": 6,
      "text": "Table C.2.2",
      "ja": "表C.2.2"
    },
    {
      "indent": 6,
      "text": "Table C.3",
      "ja": "表C.3"
    },
    {
      "indent": 6,
      "text": "Table C.4",
      "ja": "表C.4"
    },
    {
      "indent": 6,
      "text": "Table C.5",
      "ja": "表C.5"
    },
    {
      "indent": 6,
      "text": "Table C.6",
      "ja": "表C.6"
    },
    {
      "indent": 6,
      "text": "Table C.7",
      "ja": "表C.7"
    },
    {
      "indent": 6,
      "text": "Table C.8",
      "ja": "表C.8"
    },
    {
      "indent": 6,
      "text": "Table C.9",
      "ja": "表C.9"
    },
    {
      "indent": 0,
      "text": "14.3.6. Bidirectional Output for nfs4_mixed_prep",
      "section_title": true,
      "ja": "14.3.6.  nfs4_mixed_prepのための双方向出力"
    },
    {
      "indent": 3,
      "text": "The nfs4_mixed_prep profile specifies checking bidirectional strings as described in stringprep's Section 6.",
      "ja": "nfs4_mixed_prepプロファイルは、文字列前の第6節で説明したように、双方向の文字列をチェックする指定します。"
    },
    {
      "indent": 0,
      "text": "14.4. UTF-8 Capabilities",
      "section_title": true,
      "ja": "14.4.  UTF-8機能"
    },
    {
      "indent": 3,
      "text": "const FSCHARSET_CAP4_CONTAINS_NON_UTF8  = 0x1;\nconst FSCHARSET_CAP4_ALLOWS_ONLY_UTF8   = 0x2;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "typedef uint32_t fs_charset_cap4;",
      "ja": "typedefでのuint32_t fs_charset_cap4。"
    },
    {
      "indent": 3,
      "text": "Because some operating environments and file systems do not enforce character set encodings, NFSv4.1 supports the fs_charset_cap attribute (Section 5.8.2.11) that indicates to the client a file system's UTF-8 capabilities. The attribute is an integer containing a pair of flags. The first flag is FSCHARSET_CAP4_CONTAINS_NON_UTF8, which, if set to one, tells the client that the file system contains non-UTF-8 characters, and the server will not convert non-UTF characters to UTF-8 if the client reads a symlink or directory, neither will operations with component names or pathnames in the arguments convert the strings to UTF-8. The second flag is FSCHARSET_CAP4_ALLOWS_ONLY_UTF8, which, if set to one, indicates that the server will accept (and generate) only UTF-8 characters on the file system. If FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 is set to one, FSCHARSET_CAP4_CONTAINS_NON_UTF8 MUST be set to zero. FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 SHOULD always be set to one.",
      "ja": "いくつかのオペレーティング環境やファイル・システムは、文字セットエンコーディングを強制しないので、NFSv4.1は、クライアントにファイルシステムのUTF-8の能力を示してfs_charset_cap属性（セクション5.8.2.11）をサポートしています。属性は、フラグのペアを含む整数です。最初のフラグは、1に設定すると、ファイルシステムが非UTF-8文字が含まれていることをクライアントに伝えますFSCHARSET_CAP4_CONTAINS_NON_UTF8、であり、クライアントがシンボリックリンクまたはディレクトリを読み込む場合、サーバーはUTF-8に非UTF文字を変換しません、どちらの引数でコンポーネント名またはパス名を持つ操作がUTF-8に文字列を変換します。第2のフラグが1に設定されている場合、ファイルシステムにサーバが受け入れる（および生成）することのみUTF-8文字を示し、FSCHARSET_CAP4_ALLOWS_ONLY_UTF8、です。 FSCHARSET_CAP4_ALLOWS_ONLY_UTF8が1に設定されている場合は、FSCHARSET_CAP4_CONTAINS_NON_UTF8をゼロに設定しなければなりません。 FSCHARSET_CAP4_ALLOWS_ONLY_UTF8は常に1に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "14.5. UTF-8 Related Errors",
      "section_title": true,
      "ja": "14.5.  UTF-8関連のエラー"
    },
    {
      "indent": 3,
      "text": "Where the client sends an invalid UTF-8 string, the server should return NFS4ERR_INVAL (see Table 5). This includes cases in which inappropriate prefixes are detected and where the count includes trailing bytes that do not constitute a full UCS character.",
      "ja": "クライアントが無効なUTF-8文字列を送信する場合、サーバはNFS4ERR_INVAL（表5参照）を返す必要があります。これは、不適切なプレフィックスが検出されている場合も含むとカウントがフルUCS文字を構成しないバイトを末尾に含みます。"
    },
    {
      "indent": 3,
      "text": "Where the client-supplied string is valid UTF-8 but contains characters that are not supported by the server as a value for that string (e.g., names containing characters outside of Unicode plane 0 on file systems that fail to support such characters despite their presence in the Unicode standard), the server should return NFS4ERR_BADCHAR.",
      "ja": "クライアントが提供する文字列が有効なUTF-8であるが、その文字列（の値として、サーバでサポートされていない文字を含む場合など、その存在にもかかわらず、このような文字をサポートしないファイルシステム上でUnicodeのプレーン0の外の文字を含む名前）Unicode標準では、サーバがNFS4ERR_BADCHARを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Where a UTF-8 string is used as a file name, and the file system (while supporting all of the characters within the name) does not allow that particular name to be used, the server should return the error NFS4ERR_BADNAME (Table 5). This includes situations in which the server file system imposes a normalization constraint on name strings, but will also include such situations as file system prohibitions of \".\" and \"..\" as file names for certain operations, and other such constraints.",
      "ja": "（名前の中のすべての文字をサポートしながら）UTF-8文字列は、特定の名前を使用することはできませんファイル名、およびファイルシステムとして使用される場合、サーバーはエラーNFS4ERR_BADNAME（表5）を返す必要があります。これは、サーバー・ファイル・システムは、名前文字列の正規化制約を課しているが、またのファイルシステムの禁止などの状況を含むであろう状況を含みます「」そして、「..」ファイルの特定の操作の名前、および他のそのような制約など。"
    },
    {
      "indent": 0,
      "text": "15. Error Values",
      "section_title": true,
      "ja": "15.エラー値"
    },
    {
      "indent": 3,
      "text": "NFS error numbers are assigned to failed operations within a Compound (COMPOUND or CB_COMPOUND) request. A Compound request contains a number of NFS operations that have their results encoded in sequence in a Compound reply. The results of successful operations will consist of an NFS4_OK status followed by the encoded results of the operation. If an NFS operation fails, an error status will be entered in the reply and the Compound request will be terminated.",
      "ja": "NFSエラー番号は化合物（化合物またはCB_COMPOUND）要求内で失敗した操作に割り当てられています。複合要求は、化合物応答で順番に、その結​​果をエンコードしているNFS操作の回数が含まれています。成功した操作の結果は、動作の符号化された結果に続いNFS4_OK状態で構成されます。 NFS操作が失敗した場合、エラー状態は、返信に入力されますと化合物の要求が終了します。"
    },
    {
      "indent": 0,
      "text": "15.1. Error Definitions",
      "section_title": true,
      "ja": "15.1. エラーの定義"
    },
    {
      "indent": 24,
      "text": "Protocol Error Definitions",
      "ja": "プロトコルエラーの定義"
    },
    {
      "indent": 4,
      "text": "+-----------------------------------+--------+-------------------+\n| Error                             | Number | Description       |\n+-----------------------------------+--------+-------------------+\n| NFS4_OK                           | 0      | Section 15.1.3.1  |\n| NFS4ERR_ACCESS                    | 13     | Section 15.1.6.1  |\n| NFS4ERR_ATTRNOTSUPP               | 10032  | Section 15.1.15.1 |\n| NFS4ERR_ADMIN_REVOKED             | 10047  | Section 15.1.5.1  |\n| NFS4ERR_BACK_CHAN_BUSY            | 10057  | Section 15.1.12.1 |\n| NFS4ERR_BADCHAR                   | 10040  | Section 15.1.7.1  |\n| NFS4ERR_BADHANDLE                 | 10001  | Section 15.1.2.1  |\n| NFS4ERR_BADIOMODE                 | 10049  | Section 15.1.10.1 |\n| NFS4ERR_BADLAYOUT                 | 10050  | Section 15.1.10.2 |\n| NFS4ERR_BADNAME                   | 10041  | Section 15.1.7.2  |\n| NFS4ERR_BADOWNER                  | 10039  | Section 15.1.15.2 |\n| NFS4ERR_BADSESSION                | 10052  | Section 15.1.11.1 |\n| NFS4ERR_BADSLOT                   | 10053  | Section 15.1.11.2 |\n| NFS4ERR_BADTYPE                   | 10007  | Section 15.1.4.1  |\n| NFS4ERR_BADXDR                    | 10036  | Section 15.1.1.1  |\n| NFS4ERR_BAD_COOKIE                | 10003  | Section 15.1.1.2  |\n| NFS4ERR_BAD_HIGH_SLOT             | 10077  | Section 15.1.11.3 |\n| NFS4ERR_BAD_RANGE                 | 10042  | Section 15.1.8.1  |",
      "raw": true
    },
    {
      "indent": 4,
      "text": "| NFS4ERR_BAD_SEQID | 10026 | Section 15.1.16.1 | | NFS4ERR_BAD_SESSION_DIGEST | 10051 | Section 15.1.12.2 | | NFS4ERR_BAD_STATEID | 10025 | Section 15.1.5.2 | | NFS4ERR_CB_PATH_DOWN | 10048 | Section 15.1.11.4 | | NFS4ERR_CLID_INUSE | 10017 | Section 15.1.13.2 | | NFS4ERR_CLIENTID_BUSY | 10074 | Section 15.1.13.1 | | NFS4ERR_COMPLETE_ALREADY | 10054 | Section 15.1.9.1 | | NFS4ERR_CONN_NOT_BOUND_TO_SESSION | 10055 | Section 15.1.11.6 | | NFS4ERR_DEADLOCK | 10045 | Section 15.1.8.2 | | NFS4ERR_DEADSESSION | 10078 | Section 15.1.11.5 | | NFS4ERR_DELAY | 10008 | Section 15.1.1.3 | | NFS4ERR_DELEG_ALREADY_WANTED | 10056 | Section 15.1.14.1 | | NFS4ERR_DELEG_REVOKED | 10087 | Section 15.1.5.3 | | NFS4ERR_DENIED | 10010 | Section 15.1.8.3 | | NFS4ERR_DIRDELEG_UNAVAIL | 10084 | Section 15.1.14.2 | | NFS4ERR_DQUOT | 69 | Section 15.1.4.2 | | NFS4ERR_ENCR_ALG_UNSUPP | 10079 | Section 15.1.13.3 | | NFS4ERR_EXIST | 17 | Section 15.1.4.3 | | NFS4ERR_EXPIRED | 10011 | Section 15.1.5.4 | | NFS4ERR_FBIG | 27 | Section 15.1.4.4 | | NFS4ERR_FHEXPIRED | 10014 | Section 15.1.2.2 | | NFS4ERR_FILE_OPEN | 10046 | Section 15.1.4.5 | | NFS4ERR_GRACE | 10013 | Section 15.1.9.2 | | NFS4ERR_HASH_ALG_UNSUPP | 10072 | Section 15.1.13.4 | | NFS4ERR_INVAL | 22 | Section 15.1.1.4 | | NFS4ERR_IO | 5 | Section 15.1.4.6 | | NFS4ERR_ISDIR | 21 | Section 15.1.2.3 | | NFS4ERR_LAYOUTTRYLATER | 10058 | Section 15.1.10.3 | | NFS4ERR_LAYOUTUNAVAILABLE | 10059 | Section 15.1.10.4 | | NFS4ERR_LEASE_MOVED | 10031 | Section 15.1.16.2 | | NFS4ERR_LOCKED | 10012 | Section 15.1.8.4 | | NFS4ERR_LOCKS_HELD | 10037 | Section 15.1.8.5 | | NFS4ERR_LOCK_NOTSUPP | 10043 | Section 15.1.8.6 | | NFS4ERR_LOCK_RANGE | 10028 | Section 15.1.8.7 | | NFS4ERR_MINOR_VERS_MISMATCH | 10021 | Section 15.1.3.2 | | NFS4ERR_MLINK | 31 | Section 15.1.4.7 | | NFS4ERR_MOVED | 10019 | Section 15.1.2.4 | | NFS4ERR_NAMETOOLONG | 63 | Section 15.1.7.3 | | NFS4ERR_NOENT | 2 | Section 15.1.4.8 | | NFS4ERR_NOFILEHANDLE | 10020 | Section 15.1.2.5 | | NFS4ERR_NOMATCHING_LAYOUT | 10060 | Section 15.1.10.5 | | NFS4ERR_NOSPC | 28 | Section 15.1.4.9 | | NFS4ERR_NOTDIR | 20 | Section 15.1.2.6 | | NFS4ERR_NOTEMPTY | 66 | Section 15.1.4.10 | | NFS4ERR_NOTSUPP | 10004 | Section 15.1.1.5 | | NFS4ERR_NOT_ONLY_OP | 10081 | Section 15.1.3.3 | | NFS4ERR_NOT_SAME | 10027 | Section 15.1.15.3 | | NFS4ERR_NO_GRACE | 10033 | Section 15.1.9.3 |",
      "ja": "| NFS4ERR_BAD_SEQID | 10026 |第15.1.16.1 | | NFS4ERR_BAD_SESSION_DIGEST | 10051 |第15.1.12.2 | | NFS4ERR_BAD_STATEID | 10025 |セクション15.1.5.2 | | NFS4ERR_CB_PATH_DOWN | 10048 |第15.1.11.4 | | NFS4ERR_CLID_INUSE | 10017 |第15.1.13.2 | | NFS4ERR_CLIENTID_BUSY | 10074 |第15.1.13.1 | | NFS4ERR_COMPLETE_ALREADY | 10054 |セクション15.1.9.1 | | NFS4ERR_CONN_NOT_BOUND_TO_SESSION | 10055 |第15.1.11.6 | | NFS4ERR_DEADLOCK | 10045 |セクション15.1.8.2 | | NFS4ERR_DEADSESSION | 10078 |第15.1.11.5 | | NFS4ERR_DELAY | 10008 |セクション15.1.1.3 | | NFS4ERR_DELEG_ALREADY_WANTED | 10056 |第15.1.14.1 | | NFS4ERR_DELEG_REVOKED | 10087 |セクション15.1.5.3 | | NFS4ERR_DENIED | 10010 |セクション15.1.8.3 | | NFS4ERR_DIRDELEG_UNAVAIL | 10084 |第15.1.14.2 | | NFS4ERR_DQUOT | 69 |セクション15.1.4.2 | | NFS4ERR_ENCR_ALG_UNSUPP | 10079 |第15.1.13.3 | | NFS4ERR_EXIST | 17 |セクション15.1.4.3 | | NFS4ERR_EXPIRED | 10011 |セクション15.1.5.4 | | NFS4ERR_FBIG | 27 |セクション15.1.4.4 | | NFS4ERR_FHEXPIRED | 10014 |セクション15.1.2.2 | | NFS4ERR_FILE_OPEN | 10046 |セクション15.1.4.5 | | NFS4ERR_GRACE | 10013 |セクション15.1.9.2 | | NFS4ERR_HASH_ALG_UNSUPP | 10072 |第15.1.13.4 | | NFS4ERR_INVAL | 22 |セクション15.1.1.4 | | NFS4ERR_IO | 5 |セクション15.1.4.6 | | NFS4ERR_ISDIR | 21 |セクション15.1.2.3 | | NFS4ERR_LAYOUTTRYLATER | 10058 |第15.1.10.3 | | NFS4ERR_LAYOUTUNAVAILABLE | 10059 |第15.1.10.4 | | NFS4ERR_LEASE_MOVED | 10031 |第15.1.16.2 | | NFS4ERR_LOCKED | 10012 |セクション15.1.8.4 | | NFS4ERR_LOCKS_HELD | 10037 |セクション15.1.8.5 | | NFS4ERR_LOCK_NOTSUPP | 10043 |セクション15.1.8.6 | | NFS4ERR_LOCK_RANGE | 10028 |セクション15.1.8.7 | | NFS4ERR_MINOR_VERS_MISMATCH | 10021 |セクション15.1.3.2 | | NFS4ERR_MLINK | 31 |セクション15.1.4.7 | | NFS4ERR_MOVED | 10019 |セクション15.1.2.4 | | NFS4ERR_NAMETOOLONG | 63 |セクション15.1.7.3 | | NFS4ERR_NOENT | 2 |セクション15.1.4.8 | | NFS4ERR_NOFILEHANDLE | 10020 |セクション15.1.2.5 | | NFS4ERR_NOMATCHING_LAYOUT | 10060 |第15.1.10.5 | | NFS4ERR_NOSPC | 28 |セクション15.1.4.9 | | NFS4ERR_NOTDIR | 20 |セクション15.1.2.6 | | NFS4ERR_NOTEMPTY | 66 |第15.1.4.10 | | NFS4ERR_NOTSUPP | 10004 |セクション15.1.1.5 | | NFS4ERR_NOT_ONLY_OP | 10081 |セクション15.1.3.3 | | NFS4ERR_NOT_SAME | 10027 |第15.1.15.3 | | NFS4ERR_NO_GRACE | 10033 |セクション15.1.9.3 |"
    },
    {
      "indent": 4,
      "text": "| NFS4ERR_NXIO                      | 6      | Section 15.1.16.3 |\n| NFS4ERR_OLD_STATEID               | 10024  | Section 15.1.5.5  |\n| NFS4ERR_OPENMODE                  | 10038  | Section 15.1.8.8  |\n| NFS4ERR_OP_ILLEGAL                | 10044  | Section 15.1.3.4  |\n| NFS4ERR_OP_NOT_IN_SESSION         | 10071  | Section 15.1.3.5  |\n| NFS4ERR_PERM                      | 1      | Section 15.1.6.2  |\n| NFS4ERR_PNFS_IO_HOLE              | 10075  | Section 15.1.10.6 |\n| NFS4ERR_PNFS_NO_LAYOUT            | 10080  | Section 15.1.10.7 |\n| NFS4ERR_RECALLCONFLICT            | 10061  | Section 15.1.14.3 |\n| NFS4ERR_RECLAIM_BAD               | 10034  | Section 15.1.9.4  |\n| NFS4ERR_RECLAIM_CONFLICT          | 10035  | Section 15.1.9.5  |\n| NFS4ERR_REJECT_DELEG              | 10085  | Section 15.1.14.4 |\n| NFS4ERR_REP_TOO_BIG               | 10066  | Section 15.1.3.6  |\n| NFS4ERR_REP_TOO_BIG_TO_CACHE      | 10067  | Section 15.1.3.7  |\n| NFS4ERR_REQ_TOO_BIG               | 10065  | Section 15.1.3.8  |\n| NFS4ERR_RESTOREFH                 | 10030  | Section 15.1.16.4 |\n| NFS4ERR_RETRY_UNCACHED_REP        | 10068  | Section 15.1.3.9  |\n| NFS4ERR_RETURNCONFLICT            | 10086  | Section 15.1.10.8 |\n| NFS4ERR_ROFS                      | 30     | Section 15.1.4.11 |\n| NFS4ERR_SAME                      | 10009  | Section 15.1.15.4 |\n| NFS4ERR_SHARE_DENIED              | 10015  | Section 15.1.8.9  |\n| NFS4ERR_SEQUENCE_POS              | 10064  | Section 15.1.3.10 |\n| NFS4ERR_SEQ_FALSE_RETRY           | 10076  | Section 15.1.11.7 |\n| NFS4ERR_SEQ_MISORDERED            | 10063  | Section 15.1.11.8 |\n| NFS4ERR_SERVERFAULT               | 10006  | Section 15.1.1.6  |\n| NFS4ERR_STALE                     | 70     | Section 15.1.2.7  |\n| NFS4ERR_STALE_CLIENTID            | 10022  | Section 15.1.13.5 |\n| NFS4ERR_STALE_STATEID             | 10023  | Section 15.1.16.5 |\n| NFS4ERR_SYMLINK                   | 10029  | Section 15.1.2.8  |\n| NFS4ERR_TOOSMALL                  | 10005  | Section 15.1.1.7  |\n| NFS4ERR_TOO_MANY_OPS              | 10070  | Section 15.1.3.11 |\n| NFS4ERR_UNKNOWN_LAYOUTTYPE        | 10062  | Section 15.1.10.9 |\n| NFS4ERR_UNSAFE_COMPOUND           | 10069  | Section 15.1.3.12 |\n| NFS4ERR_WRONGSEC                  | 10016  | Section 15.1.6.3  |\n| NFS4ERR_WRONG_CRED                | 10082  | Section 15.1.6.4  |\n| NFS4ERR_WRONG_TYPE                | 10083  | Section 15.1.2.9  |\n| NFS4ERR_XDEV                      | 18     | Section 15.1.4.12 |\n+-----------------------------------+--------+-------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 5",
      "ja": "表5"
    },
    {
      "indent": 0,
      "text": "15.1.1. General Errors",
      "section_title": true,
      "ja": "15.1.1. 一般的なエラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors that are applicable to a broad set of different purposes.",
      "ja": "このセクションでは、異なる目的の広範なセットに適用されるエラーを扱っています。"
    },
    {
      "indent": 0,
      "text": "15.1.1.1. NFS4ERR_BADXDR (Error Code 10036)",
      "section_title": true,
      "ja": "15.1.1.1。 NFS4ERR_BADXDR（エラーコード10036）"
    },
    {
      "indent": 3,
      "text": "The arguments for this operation do not match those specified in the XDR definition. This includes situations in which the request ends before all the arguments have been seen. Note that this error applies when fixed enumerations (these include booleans) have a value within the input stream that is not valid for the enum. A replier may pre-parse all operations for a Compound procedure before doing any operation execution and return RPC-level XDR errors in that case.",
      "ja": "この操作の引数は、XDR定義に指定されたものと一致しません。これは、すべての引数が見られている前に、要求が終了する状況が含まれます。固定の列挙は、（これらはブール値を含む）に列挙型に対して有効ではありません入力ストリーム内の値を持っている場合、このエラーが適用されることに注意してください。リプライヤは、任意の操作の実行を行う前に、化合物の手続きのために、すべての操作を事前に解析し、その場合のRPCレベルのXDRのエラーを返すことがあります。"
    },
    {
      "indent": 0,
      "text": "15.1.1.2. NFS4ERR_BAD_COOKIE (Error Code 10003)",
      "section_title": true,
      "ja": "15.1.1.2。 NFS4ERR_BAD_COOKIE（エラーコード10003）"
    },
    {
      "indent": 3,
      "text": "Used for operations that provide a set of information indexed by some quantity provided by the client or cookie sent by the server for an earlier invocation. Where the value cannot be used for its intended purpose, this error results.",
      "ja": "以前の呼び出しのためにサーバから送信されたクライアントまたはクッキーが提供するいくつかの量によってインデックスされる情報のセットを提供業務に使用されます。値がその意図する目的のために使用することができない場合は、このエラーが発生します。"
    },
    {
      "indent": 0,
      "text": "15.1.1.3. NFS4ERR_DELAY (Error Code 10008)",
      "section_title": true,
      "ja": "15.1.1.3。 NFS4ERR_DELAY（エラーコード10008）"
    },
    {
      "indent": 3,
      "text": "For any of a number of reasons, the replier could not process this operation in what was deemed a reasonable time. The client should wait and then try the request with a new slot and sequence value.",
      "ja": "いくつかの理由のいずれかの場合、リプライヤは、合理的な時間とみなされたもので、この操作を処理できませんでした。クライアントが待機して新しいスロットおよびシーケンス値との要求を試してみてください。"
    },
    {
      "indent": 3,
      "text": "Some examples of scenarios that might lead to this situation:",
      "ja": "このような状況につながる可能性があるシナリオのいくつかの例："
    },
    {
      "indent": 3,
      "text": "o A server that supports hierarchical storage receives a request to process a file that had been migrated.",
      "ja": "O階層型ストレージをサポートするサーバーが移行されたファイルを処理するための要求を受け取ります。"
    },
    {
      "indent": 3,
      "text": "o An operation requires a delegation recall to proceed, and waiting for this delegation recall makes processing this request in a timely fashion impossible.",
      "ja": "O操作を続行するには、委任のリコールを必要とし、この委任のリコールを待っていることは不可能タイムリーに、この要求を処理します。"
    },
    {
      "indent": 3,
      "text": "In such cases, the error NFS4ERR_DELAY allows these preparatory operations to proceed without holding up client resources such as a session slot. After delaying for period of time, the client can then re-send the operation in question (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send).",
      "ja": "このような場合には、エラーNFS4ERR_DELAYは、これらの準備作業は、このようなセッションスロットとしてクライアントのリソースを保持せずに続行することができます。 （;いずれかまたは両方は、再送信に異なっていなければなりませんではなく、同じスロットID及び配列IDで）一定期間遅延させた後、クライアントは、次いで、当該操作を再送信することができます。"
    },
    {
      "indent": 3,
      "text": "Note that without the ability to return NFS4ERR_DELAY and the client's willingness to re-send when receiving it, deadlock might result. For example, if a recall is done, and if the delegation return or operations preparatory to delegation return are held up by other operations that need the delegation to be returned, session slots might not be available. The result could be deadlock.",
      "ja": "NFS4ERR_DELAYを返す機能と、それを受信したときに、デッドロックがなる可能性があり、再送信するために、クライアントの意欲なしであることに注意してください。例えば、リコールが行われた場合、および委任返品または委任復帰への準備作業が返される委任を必要とする他の操作によって、最大保有している場合、セッションスロットが使用できない場合があります。その結果、デッドロック可能性があります。"
    },
    {
      "indent": 0,
      "text": "15.1.1.4. NFS4ERR_INVAL (Error Code 22)",
      "section_title": true,
      "ja": "15.1.1.4。 NFS4ERR_INVAL（エラーコード22）"
    },
    {
      "indent": 3,
      "text": "The arguments for this operation are not valid for some reason, even though they do match those specified in the XDR definition for the request.",
      "ja": "この操作の引数は、彼らが要求のためのXDR定義に指定されたものと一致して行うにもかかわらず、何らかの理由で有効ではありません。"
    },
    {
      "indent": 0,
      "text": "15.1.1.5. NFS4ERR_NOTSUPP (Error Code 10004)",
      "section_title": true,
      "ja": "15.1.1.5。 NFS4ERR_NOTSUPP（エラーコード10004）"
    },
    {
      "indent": 3,
      "text": "Operation not supported, either because the operation is an OPTIONAL one and is not supported by this server or because the operation MUST NOT be implemented in the current minor version.",
      "ja": "操作はオプション1であり、このサーバーまたは操作は、現在のマイナーバージョンで実装されてはならないので、サポートされていないため、操作のいずれか、サポートされていません。"
    },
    {
      "indent": 0,
      "text": "15.1.1.6. NFS4ERR_SERVERFAULT (Error Code 10006)",
      "section_title": true,
      "ja": "15.1.1.6。 NFS4ERR_SERVERFAULT（エラーコード10006）"
    },
    {
      "indent": 3,
      "text": "An error occurred on the server that does not map to any of the specific legal NFSv4.1 protocol error values. The client should translate this into an appropriate error. UNIX clients may choose to translate this to EIO.",
      "ja": "エラーは特定の法的NFSv4.1プロトコルエラー値のいずれかにマップされないサーバー上で発生しました。クライアントは、適切なエラーにこれを変換する必要があります。 UNIXクライアントがEIOにこれを翻訳することもできます。"
    },
    {
      "indent": 0,
      "text": "15.1.1.7. NFS4ERR_TOOSMALL (Error Code 10005)",
      "section_title": true,
      "ja": "15.1.1.7。 NFS4ERR_TOOSMALL（エラーコード10005）"
    },
    {
      "indent": 3,
      "text": "Used where an operation returns a variable amount of data, with a limit specified by the client. Where the data returned cannot be fit within the limit specified by the client, this error results.",
      "ja": "動作は、クライアントによって指定された制限と、データの可変量を返す場合に使用。どこに返されるデータは、クライアントによって指定された制限内にこのエラーが発生フィットすることはできません。"
    },
    {
      "indent": 0,
      "text": "15.1.2. Filehandle Errors",
      "section_title": true,
      "ja": "15.1.2. ファイルハンドルエラー"
    },
    {
      "indent": 3,
      "text": "These errors deal with the situation in which the current or saved filehandle, or the filehandle passed to PUTFH intended to become the current filehandle, is invalid in some way. This includes situations in which the filehandle is a valid filehandle in general but is not of the appropriate object type for the current operation.",
      "ja": "これらのエラーは、現在または保存されたファイルハンドルの状況に対処する、またはPUTFHに渡されたファイルハンドルは、現在のファイルハンドルになることを意図し、何らかの方法で無効です。これは、ファイルハンドルは、一般的に有効でファイルハンドルであるが、現在の操作のための適切なオブジェクトタイプのされていない状況を含みます。"
    },
    {
      "indent": 3,
      "text": "Where the error description indicates a problem with the current or saved filehandle, it is to be understood that filehandles are only checked for the condition if they are implicit arguments of the operation in question.",
      "ja": "エラーの説明は、現在または保存されたファイルハンドルに問題があることを示す場合、それは彼らが問題の操作の暗黙の引数であればファイルハンドルが唯一の条件をチェックしていることを理解すべきです。"
    },
    {
      "indent": 0,
      "text": "15.1.2.1. NFS4ERR_BADHANDLE (Error Code 10001)",
      "section_title": true,
      "ja": "15.1.2.1。 NFS4ERR_BADHANDLE（エラーコード10001）"
    },
    {
      "indent": 3,
      "text": "Illegal NFS filehandle for the current server. The current file handle failed internal consistency checks. Once accepted as valid (by PUTFH), no subsequent status change can cause the filehandle to generate this error.",
      "ja": "現在のサーバーの不正なNFSファイルハンドル。現在のファイルハンドルは、内部整合性チェックに失敗しました。一度（PUTFHによって）有効なものとして受け入れられ、後続のステータス変更は、ファイルハンドルは、このエラーを発生させないことができます。"
    },
    {
      "indent": 0,
      "text": "15.1.2.2. NFS4ERR_FHEXPIRED (Error Code 10014)",
      "section_title": true,
      "ja": "15.1.2.2。 NFS4ERR_FHEXPIRED（エラーコード10014）"
    },
    {
      "indent": 3,
      "text": "A current or saved filehandle that is an argument to the current operation is volatile and has expired at the server.",
      "ja": "現在の操作の引数で、現在または保存されたファイルハンドルが揮発性であり、サーバーで有効期限が切れています。"
    },
    {
      "indent": 0,
      "text": "15.1.2.3. NFS4ERR_ISDIR (Error Code 21)",
      "section_title": true,
      "ja": "15.1.2.3。 NFS4ERR_ISDIR（エラーコード21）"
    },
    {
      "indent": 3,
      "text": "The current or saved filehandle designates a directory when the current operation does not allow a directory to be accepted as the target of this operation.",
      "ja": "現在または保存されたファイルハンドルは、現在の操作は、ディレクトリは、この操作の対象として受け入れられることはできませんディレクトリを指定します。"
    },
    {
      "indent": 0,
      "text": "15.1.2.4. NFS4ERR_MOVED (Error Code 10019)",
      "section_title": true,
      "ja": "15.1.2.4。 NFS4ERR_MOVED（エラーコード10019）"
    },
    {
      "indent": 3,
      "text": "The file system that contains the current filehandle object is not present at the server. It may have been relocated or migrated to another server, or it may have never been present. The client may obtain the new file system location by obtaining the \"fs_locations\" or \"fs_locations_info\" attribute for the current filehandle. For further discussion, refer to Section 11.2.",
      "ja": "現在のファイルハンドルオブジェクトを含むファイルシステムがサーバーに存在しません。これは、移転したり、別のサーバに移行、またはそれが存在したことがないかもしれされた可能性があります。クライアントは、現在のファイルハンドルのために、「fs_位置」または「fs_locations_info」属性を取得することによって、新しいファイルシステムの場所を得ることができます。さらなる議論については、11.2節を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.2.5. NFS4ERR_NOFILEHANDLE (Error Code 10020)",
      "section_title": true,
      "ja": "15.1.2.5。 NFS4ERR_NOFILEHANDLE（エラーコード10020）"
    },
    {
      "indent": 3,
      "text": "The logical current or saved filehandle value is required by the current operation and is not set. This may be a result of a malformed COMPOUND operation (i.e., no PUTFH or PUTROOTFH before an operation that requires the current filehandle be set).",
      "ja": "論理現在または保存されたファイルハンドルの値は、現在の操作で必要とされると設定されていません。これは、（現在のファイルハンドルを設定する必要があり、操作の前に、すなわち、無PUTFH又はPUTROOTFH）不正な複合操作の結果であり得ます。"
    },
    {
      "indent": 0,
      "text": "15.1.2.6. NFS4ERR_NOTDIR (Error Code 20)",
      "section_title": true,
      "ja": "15.1.2.6。 NFS4ERR_NOTDIR（エラーコード20）"
    },
    {
      "indent": 3,
      "text": "The current (or saved) filehandle designates an object that is not a directory for an operation in which a directory is required.",
      "ja": "現在の（または保存）ファイルハンドルは、ディレクトリが必要とされる動作のディレクトリではないオブジェクトを指定します。"
    },
    {
      "indent": 0,
      "text": "15.1.2.7. NFS4ERR_STALE (Error Code 70)",
      "section_title": true,
      "ja": "15.1.2.7。 NFS4ERR_STALE（エラーコード70）"
    },
    {
      "indent": 3,
      "text": "The current or saved filehandle value designating an argument to the current operation is invalid. The file referred to by that filehandle no longer exists or access to it has been revoked.",
      "ja": "現在の操作に引数を指定し、現在または保存されたファイルハンドルの値が無効です。そのファイルハンドルが参照するファイルは、もはや存在しないか、それへのアクセス取り消されました。"
    },
    {
      "indent": 0,
      "text": "15.1.2.8. NFS4ERR_SYMLINK (Error Code 10029)",
      "section_title": true,
      "ja": "15.1.2.8。 NFS4ERR_SYMLINK（エラーコード10029）"
    },
    {
      "indent": 3,
      "text": "The current filehandle designates a symbolic link when the current operation does not allow a symbolic link as the target.",
      "ja": "現在のファイルハンドルは、現在の操作が対象としてシンボリックリンクを許可していないシンボリックリンクを指定します。"
    },
    {
      "indent": 0,
      "text": "15.1.2.9. NFS4ERR_WRONG_TYPE (Error Code 10083)",
      "section_title": true,
      "ja": "15.1.2.9。 NFS4ERR_WRONG_TYPE（エラーコード10083）"
    },
    {
      "indent": 3,
      "text": "The current (or saved) filehandle designates an object that is of an invalid type for the current operation, and there is no more specific error (such as NFS4ERR_ISDIR or NFS4ERR_SYMLINK) that applies. Note that in NFSv4.0, such situations generally resulted in the less-specific error NFS4ERR_INVAL.",
      "ja": "現在の（または保存）ファイルハンドルは、現在の操作の無効なタイプのものであるオブジェクトを指定し、適用（例えばNFS4ERR_ISDIR又はNFS4ERR_SYMLINKなど）が、より具体的なエラーはありません。 NFSv4.0に、このような状況は、一般的により少ない固有のエラーNFS4ERR_INVALをもたらしたことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "15.1.3. Compound Structure Errors",
      "section_title": true,
      "ja": "15.1.3. 複合構造のエラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors that relate to the overall structure of a Compound request (by which we mean to include both COMPOUND and CB_COMPOUND), rather than to particular operations.",
      "ja": "化合要求（我々は、化合物とCB_COMPOUNDの両方を含むことを意味れる）の全体的な構造にはなく、特定の操作に関連するエラーのこのセクションで扱います。"
    },
    {
      "indent": 3,
      "text": "There are a number of basic constraints on the operations that may appear in a Compound request. Sessions add to these basic constraints by requiring a Sequence operation (either SEQUENCE or CB_SEQUENCE) at the start of the Compound.",
      "ja": "複合要求に表示される可能性のある操作上の基本的な制約がいくつかあります。セッションは、化合物の開始時にシーケンス動作（SEQUENCEまたはCB_SEQUENCEのいずれか）を必要とすることにより、これらの基本的な制約のために追加します。"
    },
    {
      "indent": 0,
      "text": "15.1.3.1. NFS_OK (Error code 0)",
      "section_title": true,
      "ja": "15.1.3.1。 NFS_OK（エラーコード0）"
    },
    {
      "indent": 3,
      "text": "Indicates the operation completed successfully, in that all of the constituent operations completed without error.",
      "ja": "正常に完了した操作がエラーなしで完了し、構成操作の全てで、示します。"
    },
    {
      "indent": 0,
      "text": "15.1.3.2. NFS4ERR_MINOR_VERS_MISMATCH (Error code 10021)",
      "section_title": true,
      "ja": "15.1.3.2。 NFS4ERR_MINOR_VERS_MISMATCH（エラーコード10021）"
    },
    {
      "indent": 3,
      "text": "The minor version specified is not one that the current listener supports. This value is returned in the overall status for the Compound but is not associated with a specific operation since the results will specify a result count of zero.",
      "ja": "指定されたマイナーバージョンは、現在のリスナーがサポートするものではありません。この値は、化合物の全体的な状態に戻っているが、結果がゼロの結果数を指定しますので、特定の操作に関連付けられていません。"
    },
    {
      "indent": 0,
      "text": "15.1.3.3. NFS4ERR_NOT_ONLY_OP (Error Code 10081)",
      "section_title": true,
      "ja": "15.1.3.3。 NFS4ERR_NOT_ONLY_OP（エラーコード10081）"
    },
    {
      "indent": 3,
      "text": "Certain operations, which are allowed to be executed outside of a session, MUST be the only operation within a Compound whenever the Compound does not start with a Sequence operation. This error results when that constraint is not met.",
      "ja": "化合物がシーケンス動作で開始しないときはいつでもセッションの外で実行することが許可されている特定の操作は、化合物内にのみ動作していなければなりません。その制約が満たされていない場合、このエラーが結果。"
    },
    {
      "indent": 0,
      "text": "15.1.3.4. NFS4ERR_OP_ILLEGAL (Error Code 10044)",
      "section_title": true,
      "ja": "15.1.3.4。 NFS4ERR_OP_ILLEGAL（エラーコード10044）"
    },
    {
      "indent": 3,
      "text": "The operation code is not a valid one for the current Compound procedure. The opcode in the result stream matched with this error is the ILLEGAL value, although the value that appears in the request stream may be different. Where an illegal value appears and the replier pre-parses all operations for a Compound procedure before doing any operation execution, an RPC-level XDR error may be returned.",
      "ja": "操作コードは、現在の化合物の手続きのために有効なものではありません。要求ストリームに表示される値が異なっていてもよいが、この誤差と一致する結果ストリームにおけるオペコードは、不正な値です。不正な値が表示され、リプライヤは、任意の操作の実行を行う前に、化合物の手続きのためのすべての操作を事前に解析した場合、RPCレベルのXDRエラーが返されることがあります。"
    },
    {
      "indent": 0,
      "text": "15.1.3.5. NFS4ERR_OP_NOT_IN_SESSION (Error Code 10071)",
      "section_title": true,
      "ja": "15.1.3.5。 NFS4ERR_OP_NOT_IN_SESSION（エラーコード10071）"
    },
    {
      "indent": 3,
      "text": "Most forward operations and all callback operations are only valid within the context of a session, so that the Compound request in question MUST begin with a Sequence operation. If an attempt is made to execute these operations outside the context of session, this error results.",
      "ja": "問題の化合物の要求は、シーケンス動作を開始しなければならないように、ほとんどの前進操作し、すべてのコールバック操作は、セッションのコンテキスト内でのみ有効です。試みは、セッションのコンテキスト外でこのエラー結果をこれらの操作を実行するために行われた場合。"
    },
    {
      "indent": 0,
      "text": "15.1.3.6. NFS4ERR_REP_TOO_BIG (Error Code 10066)",
      "section_title": true,
      "ja": "15.1.3.6。 NFS4ERR_REP_TOO_BIG（エラーコード10066）"
    },
    {
      "indent": 3,
      "text": "The reply to a Compound would exceed the channel's negotiated maximum response size.",
      "ja": "化合物への返信は、チャネルの交渉された最大応答サイズを超えます。"
    },
    {
      "indent": 0,
      "text": "15.1.3.7. NFS4ERR_REP_TOO_BIG_TO_CACHE (Error Code 10067)",
      "section_title": true,
      "ja": "15.1.3.7。 NFS4ERR_REP_TOO_BIG_TO_CACHE（エラーコード10067）"
    },
    {
      "indent": 3,
      "text": "The reply to a Compound would exceed the channel's negotiated maximum size for replies cached in the reply cache when the Sequence for the current request specifies that this request is to be cached.",
      "ja": "現在の要求のためのシーケンスは、この要求がキャッシュされることを指定したときに化合物に対する応答は、応答キャッシュ内にキャッシュされた応答を、チャネルの交渉された最大サイズを超えてしまいます。"
    },
    {
      "indent": 0,
      "text": "15.1.3.8. NFS4ERR_REQ_TOO_BIG (Error Code 10065)",
      "section_title": true,
      "ja": "15.1.3.8。 NFS4ERR_REQ_TOO_BIG（エラーコード10065）"
    },
    {
      "indent": 3,
      "text": "The Compound request exceeds the channel's negotiated maximum size for requests.",
      "ja": "複合要求は、要求のためのチャネルの交渉された最大サイズを超えています。"
    },
    {
      "indent": 0,
      "text": "15.1.3.9. NFS4ERR_RETRY_UNCACHED_REP (Error Code 10068)",
      "section_title": true,
      "ja": "15.1.3.9。 NFS4ERR_RETRY_UNCACHED_REP（エラーコード10068）"
    },
    {
      "indent": 3,
      "text": "The requester has attempted a retry of a Compound that it previously requested not be placed in the reply cache.",
      "ja": "依頼者は、それが以前に返信キャッシュに配置されていない要求された化合物の再試行を試みてきました。"
    },
    {
      "indent": 0,
      "text": "15.1.3.10. NFS4ERR_SEQUENCE_POS (Error Code 10064)",
      "section_title": true,
      "ja": "15.1.3.10。 NFS4ERR_SEQUENCE_POS（エラーコード10064）"
    },
    {
      "indent": 3,
      "text": "A Sequence operation appeared in a position other than the first operation of a Compound request.",
      "ja": "シーケンス動作は、複合要求の第1の動作以外の位置に現れました。"
    },
    {
      "indent": 0,
      "text": "15.1.3.11. NFS4ERR_TOO_MANY_OPS (Error Code 10070)",
      "section_title": true,
      "ja": "15.1.3.11。 NFS4ERR_TOO_MANY_OPS（エラーコード10070）"
    },
    {
      "indent": 3,
      "text": "The Compound request has too many operations, exceeding the count negotiated when the session was created.",
      "ja": "複合要求は、セッションが作成されたときに交渉回数を超えて、あまりにも多くの事業を展開しています。"
    },
    {
      "indent": 0,
      "text": "15.1.3.12. NFS4ERR_UNSAFE_COMPOUND (Error Code 10068)",
      "section_title": true,
      "ja": "15.1.3.12。 NFS4ERR_UNSAFE_COMPOUND（エラーコード10068）"
    },
    {
      "indent": 3,
      "text": "The client has sent a COMPOUND request with an unsafe mix of operations -- specifically, with a non-idempotent operation that changes the current filehandle and that is not followed by a GETFH.",
      "ja": "現在のファイルハンドルを変更し、それはGETFH続いない非冪等の操作で、具体的 - クライアントは、操作の危険な混合を有する化合物の要求を送信しました。"
    },
    {
      "indent": 0,
      "text": "15.1.4. File System Errors",
      "section_title": true,
      "ja": "15.1.4. ファイルシステムエラー"
    },
    {
      "indent": 3,
      "text": "These errors describe situations that occurred in the underlying file system implementation rather than in the protocol or any NFSv4.x feature.",
      "ja": "これらのエラーは、基本的なファイルシステムの実装ではなく、プロトコルまたは任意のNFSv4.x機能で発生した状況を説明します。"
    },
    {
      "indent": 0,
      "text": "15.1.4.1. NFS4ERR_BADTYPE (Error Code 10007)",
      "section_title": true,
      "ja": "15.1.4.1。 NFS4ERR_BADTYPE（エラーコード10007）"
    },
    {
      "indent": 3,
      "text": "An attempt was made to create an object with an inappropriate type specified to CREATE. This may be because the type is undefined, because the type is not supported by the server, or because the type is not intended to be created by CREATE (such as a regular file or named attribute, for which OPEN is used to do the file creation).",
      "ja": "試みは、CREATEするために指定された不適切なタイプのオブジェクトを作成しました。タイプがサーバーでサポートされていないので、タイプは、定義されていないため、またはタイプは、CREATEにより作成されるものではないので、これは、そのようなOPENは、ファイルを実行するために使用されている通常のファイルまたは名前付き属性として（かもしれ創造）。"
    },
    {
      "indent": 0,
      "text": "15.1.4.2. NFS4ERR_DQUOT (Error Code 19)",
      "section_title": true,
      "ja": "15.1.4.2。 NFS4ERR_DQUOT（エラーコード19）"
    },
    {
      "indent": 3,
      "text": "Resource (quota) hard limit exceeded. The user's resource limit on the server has been exceeded.",
      "ja": "リソース（クォータ）ハードリミットを超えました。サーバー上のユーザーのリソース制限を超えました。"
    },
    {
      "indent": 0,
      "text": "15.1.4.3. NFS4ERR_EXIST (Error Code 17)",
      "section_title": true,
      "ja": "15.1.4.3。 NFS4ERR_EXIST（エラーコード17）"
    },
    {
      "indent": 3,
      "text": "A file of the specified target name (when creating, renaming, or linking) already exists.",
      "ja": "指定されたターゲット名のファイル（作成、名前変更、またはリンク時に）すでに存在します。"
    },
    {
      "indent": 0,
      "text": "15.1.4.4. NFS4ERR_FBIG (Error Code 27)",
      "section_title": true,
      "ja": "15.1.4.4。 NFS4ERR_FBIG（エラーコード27）"
    },
    {
      "indent": 3,
      "text": "The file is too large. The operation would have caused the file to grow beyond the server's limit.",
      "ja": "ファイルが大きすぎます。操作は、ファイルがサーバーの制限を超えて成長させただろう。"
    },
    {
      "indent": 0,
      "text": "15.1.4.5. NFS4ERR_FILE_OPEN (Error Code 10046)",
      "section_title": true,
      "ja": "15.1.4.5。 NFS4ERR_FILE_OPEN（エラーコード10046）"
    },
    {
      "indent": 3,
      "text": "The operation is not allowed because a file involved in the operation is currently open. Servers may, but are not required to, disallow linking-to, removing, or renaming open files.",
      "ja": "操作に関連するファイルが現在開いているため、操作は許可されていません。サーバーは、かもしれませんが、削除、または開いているファイルの名前を変更し、リンク-に禁止する必要はありません。"
    },
    {
      "indent": 0,
      "text": "15.1.4.6. NFS4ERR_IO (Error Code 5)",
      "section_title": true,
      "ja": "15.1.4.6。 NFS4ERR_IO（エラーコード5）"
    },
    {
      "indent": 3,
      "text": "Indicates that an I/O error occurred for which the file system was unable to provide recovery.",
      "ja": "ファイルシステムが回復を提供することができませんでしたこれのためにI / Oエラーが発生したことを示します。"
    },
    {
      "indent": 0,
      "text": "15.1.4.7. NFS4ERR_MLINK (Error Code 31)",
      "section_title": true,
      "ja": "15.1.4.7。 NFS4ERR_MLINK（エラーコード31）"
    },
    {
      "indent": 3,
      "text": "The request would have caused the server's limit for the number of hard links a file may have to be exceeded.",
      "ja": "要求は、ファイルが超えなければならないかもしれないハードリンクの数に対するサーバーの制限を引き起こしているだろう。"
    },
    {
      "indent": 0,
      "text": "15.1.4.8. NFS4ERR_NOENT (Error Code 2)",
      "section_title": true,
      "ja": "15.1.4.8。 NFS4ERR_NOENT（エラーコード2）"
    },
    {
      "indent": 3,
      "text": "Indicates no such file or directory. The file or directory name specified does not exist.",
      "ja": "そのようなファイルやディレクトリを示していません。指定したファイルまたはディレクトリ名は存在しません。"
    },
    {
      "indent": 0,
      "text": "15.1.4.9. NFS4ERR_NOSPC (Error Code 28)",
      "section_title": true,
      "ja": "15.1.4.9。 NFS4ERR_NOSPC（エラーコード28）"
    },
    {
      "indent": 3,
      "text": "Indicates there is no space left on the device. The operation would have caused the server's file system to exceed its limit.",
      "ja": "デバイス上の空間が残っていないことを示します。操作は、その限界を超えるサーバのファイルシステムを引き起こしているだろう。"
    },
    {
      "indent": 0,
      "text": "15.1.4.10. NFS4ERR_NOTEMPTY (Error Code 66)",
      "section_title": true,
      "ja": "15.1.4.10。 NFS4ERR_NOTEMPTY（エラーコード66）"
    },
    {
      "indent": 3,
      "text": "An attempt was made to remove a directory that was not empty.",
      "ja": "試みは、空ではなかったディレクトリを削除しました。"
    },
    {
      "indent": 0,
      "text": "15.1.4.11. NFS4ERR_ROFS (Error Code 30)",
      "section_title": true,
      "ja": "15.1.4.11。 NFS4ERR_ROFS（エラーコード30）"
    },
    {
      "indent": 3,
      "text": "Indicates a read-only file system. A modifying operation was attempted on a read-only file system.",
      "ja": "読み取り専用ファイルシステムを示します。変更操作は、読み取り専用ファイルシステム上で実行しようとしました。"
    },
    {
      "indent": 0,
      "text": "15.1.4.12. NFS4ERR_XDEV (Error Code 18)",
      "section_title": true,
      "ja": "15.1.4.12。 NFS4ERR_XDEV（エラーコード18）"
    },
    {
      "indent": 3,
      "text": "Indicates an attempt to do an operation, such as linking, that inappropriately crosses a boundary. This may be due to such boundaries as:",
      "ja": "不適切な境界を越えることは、そのようなリンクなど、操作を行うための試みを示します。これは、境界などに起因することがあります。"
    },
    {
      "indent": 3,
      "text": "o that between file systems (where the fsids are different).",
      "ja": "（fsidsが異なる）ファイルシステムとの間のO。"
    },
    {
      "indent": 3,
      "text": "o that between different named attribute directories or between a named attribute directory and an ordinary directory.",
      "ja": "その異なるという名前の属性のディレクトリ間または名前付き属性ディレクトリと通常のディレクトリ間のO。"
    },
    {
      "indent": 3,
      "text": "o that between byte-ranges of a file system that the file system implementation treats as separate (for example, for space accounting purposes), and where cross-connection between the byte-ranges are not allowed.",
      "ja": "Oファイルシステムの実装の扱いは別として（例えば、空間会計目的のために）、およびバイト範囲の間の相互接続が許可されていないファイルシステムのバイト範囲の間です。"
    },
    {
      "indent": 0,
      "text": "15.1.5. State Management Errors",
      "section_title": true,
      "ja": "15.1.5. 状態管理のエラー"
    },
    {
      "indent": 3,
      "text": "These errors indicate problems with the stateid (or one of the stateids) passed to a given operation. This includes situations in which the stateid is invalid as well as situations in which the stateid is valid but designates locking state that has been revoked. Depending on the operation, the stateid when valid may designate opens, byte-range locks, file or directory delegations, layouts, or device maps.",
      "ja": "これらのエラーは、のstateid（またはのstateidsの1つ）に問題があることを示す所定の操作に渡されます。これは、たstateidが無効である状況などのstateidが有効である状況は含まれますが取り消されたロック状態を指します。操作によっては、有効に指定することができるのstateidは、バイト範囲ロック、ファイルやディレクトリの代表団、レイアウト、またはデバイスマップを開きます。"
    },
    {
      "indent": 0,
      "text": "15.1.5.1. NFS4ERR_ADMIN_REVOKED (Error Code 10047)",
      "section_title": true,
      "ja": "15.1.5.1。 NFS4ERR_ADMIN_REVOKED（エラーコード10047）"
    },
    {
      "indent": 3,
      "text": "A stateid designates locking state of any type that has been revoked due to administrative interaction, possibly while the lease is valid.",
      "ja": "stateidは、リースが有効である可能性が、原因管理インタラクションに取り消された任意のタイプのロック状態を示しています。"
    },
    {
      "indent": 0,
      "text": "15.1.5.2. NFS4ERR_BAD_STATEID (Error Code 10026)",
      "section_title": true,
      "ja": "15.1.5.2。 NFS4ERR_BAD_STATEID（エラーコード10026）"
    },
    {
      "indent": 3,
      "text": "A stateid does not properly designate any valid state. See Sections 8.2.4 and 8.2.3 for a discussion of how stateids are validated.",
      "ja": "stateidは、適切に任意の有効な状態を指定していません。セクションにのstateidsが検証されるかについての説明は8.2.4と8.2.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.5.3. NFS4ERR_DELEG_REVOKED (Error Code 10087)",
      "section_title": true,
      "ja": "15.1.5.3。 NFS4ERR_DELEG_REVOKED（エラーコード10087）"
    },
    {
      "indent": 3,
      "text": "A stateid designates recallable locking state of any type (delegation or layout) that has been revoked due to the failure of the client to return the lock when it was recalled.",
      "ja": "stateidは起因し、それが呼び出されたロックを返すために、クライアントの失敗に取り消された任意のタイプ（委任又はレイアウト）のリコールロック状態を示しています。"
    },
    {
      "indent": 0,
      "text": "15.1.5.4. NFS4ERR_EXPIRED (Error Code 10011)",
      "section_title": true,
      "ja": "15.1.5.4。 NFS4ERR_EXPIRED（エラーコード10011）"
    },
    {
      "indent": 3,
      "text": "A stateid designates locking state of any type that has been revoked due to expiration of the client's lease, either immediately upon lease expiration, or following a later request for a conflicting lock.",
      "ja": "stateidはすぐに、リース満了時のいずれか、原因クライアントのリースの満了に取り消された任意のタイプの状態をロックする、または競合するロックの後の要求を次のよう指定します。"
    },
    {
      "indent": 0,
      "text": "15.1.5.5. NFS4ERR_OLD_STATEID (Error Code 10024)",
      "section_title": true,
      "ja": "15.1.5.5。 NFS4ERR_OLD_STATEID（エラーコード10024）"
    },
    {
      "indent": 3,
      "text": "A stateid with a non-zero seqid value does match the current seqid for the state designated by the user.",
      "ja": "非ゼロSEQID値とのstateidは、ユーザにより指定された状態の現在SEQIDと一致しません。"
    },
    {
      "indent": 0,
      "text": "15.1.6. Security Errors",
      "section_title": true,
      "ja": "15.1.6. セキュリティエラー"
    },
    {
      "indent": 3,
      "text": "These are the various permission-related errors in NFSv4.1.",
      "ja": "これらは、NFSv4.1のさまざまな許可関連のエラーです。"
    },
    {
      "indent": 0,
      "text": "15.1.6.1. NFS4ERR_ACCESS (Error Code 13)",
      "section_title": true,
      "ja": "15.1.6.1。 NFS4ERR_ACCESS（エラーコード13）"
    },
    {
      "indent": 3,
      "text": "Indicates permission denied. The caller does not have the correct permission to perform the requested operation. Contrast this with NFS4ERR_PERM (Section 15.1.6.2), which restricts itself to owner or privileged-user permission failures, and NFS4ERR_WRONG_CRED (Section 15.1.6.4), which deals with appropriate permission to delete or modify transient objects based on the credentials of the user that created them.",
      "ja": "許可が拒否されたことを示します。呼び出し側は、要求された操作を実行するための正しい権限がありません。ユーザーの資格情報に基づいて、一時オブジェクトを削除または修正するために、適切なアクセス権を扱う所有者または特権ユーザー権限の失敗に自分自身を制限NFS4ERR_PERM（セクション15.1.6.2）、およびNFS4ERR_WRONG_CRED（セクション15.1.6.4）、とは対照的それは、それらを作成しました。"
    },
    {
      "indent": 0,
      "text": "15.1.6.2. NFS4ERR_PERM (Error Code 1)",
      "section_title": true,
      "ja": "15.1.6.2。 NFS4ERR_PERM（エラーコード1）"
    },
    {
      "indent": 3,
      "text": "Indicates requester is not the owner. The operation was not allowed because the caller is neither a privileged user (root) nor the owner of the target of the operation.",
      "ja": "要求者が所有者ではないことを示します。呼び出し側が特権ユーザー（root）や操作の対象の所有者でもないため、操作は許可されませんでした。"
    },
    {
      "indent": 0,
      "text": "15.1.6.3. NFS4ERR_WRONGSEC (Error Code 10016)",
      "section_title": true,
      "ja": "15.1.6.3。 NFS4ERR_WRONGSEC（エラーコード10016）"
    },
    {
      "indent": 3,
      "text": "Indicates that the security mechanism being used by the client for the operation does not match the server's security policy. The client should change the security mechanism being used and re-send the operation (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send). SECINFO and SECINFO_NO_NAME can be used to determine the appropriate mechanism.",
      "ja": "操作のためにクライアントによって使用されているセキュリティメカニズムは、サーバーのセキュリティポリシーと一致していないことを示します。クライアントは、使用されるセキュリティメカニズム及び再送信動作を変更しなければならない（ただし、同じスロットIDとシーケンスIDとを、一方または両方は、再送信に異なっていなければなりません）。 SECINFOとSECINFO_NO_NAME適切な機構を決定するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "15.1.6.4. NFS4ERR_WRONG_CRED (Error Code 10082)",
      "section_title": true,
      "ja": "15.1.6.4。 NFS4ERR_WRONG_CRED（エラーコード10082）"
    },
    {
      "indent": 3,
      "text": "An operation that manipulates state was attempted by a principal that was not allowed to modify that piece of state.",
      "ja": "状態を操作する操作は、状態のその部分を変更することはできなかったプリンシパルによって試みました。"
    },
    {
      "indent": 0,
      "text": "15.1.7. Name Errors",
      "section_title": true,
      "ja": "15.1.7. 名前のエラー"
    },
    {
      "indent": 3,
      "text": "Names in NFSv4 are UTF-8 strings. When the strings are not valid UTF-8 or are of length zero, the error NFS4ERR_INVAL results. Besides this, there are a number of other errors to indicate specific problems with names.",
      "ja": "NFSv4の中の名前は、UTF-8文字列です。文字列はUTF-8有効でないか、エラーNFS4ERR_INVALの結果は、長さがゼロである場合。このほかに、名前の特定の問題を示すために、他のエラーの数があります。"
    },
    {
      "indent": 0,
      "text": "15.1.7.1. NFS4ERR_BADCHAR (Error Code 10040)",
      "section_title": true,
      "ja": "15.1.7.1。 NFS4ERR_BADCHAR（エラーコード10040）"
    },
    {
      "indent": 3,
      "text": "A UTF-8 string contains a character that is not supported by the server in the context in which it being used.",
      "ja": "UTF-8文字列は、それが使用されている文脈では、サーバーでサポートされていない文字が含まれています。"
    },
    {
      "indent": 0,
      "text": "15.1.7.2. NFS4ERR_BADNAME (Error Code 10041)",
      "section_title": true,
      "ja": "15.1.7.2。 NFS4ERR_BADNAME（エラーコード10041）"
    },
    {
      "indent": 3,
      "text": "A name string in a request consisted of valid UTF-8 characters supported by the server, but the name is not supported by the server as a valid name for the current operation. An example might be creating a file or directory named \"..\" on a server whose file system uses that name for links to parent directories.",
      "ja": "リクエスト内の名前の文字列は、サーバーでサポートされている有効なUTF-8文字から成っていますが、名前が現在の操作のための有効な名称として、サーバーによってサポートされていません。例では、という名前のファイルまたはディレクトリを作成する可能性がある「..」を持つファイルシステムの親ディレクトリへのリンクについてはその名前を使用するサーバーで。"
    },
    {
      "indent": 0,
      "text": "15.1.7.3. NFS4ERR_NAMETOOLONG (Error Code 63)",
      "section_title": true,
      "ja": "15.1.7.3。 NFS4ERR_NAMETOOLONG（エラーコード63）"
    },
    {
      "indent": 3,
      "text": "Returned when the filename in an operation exceeds the server's implementation limit.",
      "ja": "操作中のファイル名は、サーバの実装の制限を超えた場合に返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.8. Locking Errors",
      "section_title": true,
      "ja": "15.1.8. ロックエラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors related to locking, both as to share reservations and byte-range locking. It does not deal with errors specific to the process of reclaiming locks. Those are dealt with in Section 15.1.9.",
      "ja": "両方の予約およびバイト範囲ロックを共有するように、ロックに関連するエラーこのセクションで扱います。これは、ロックを再利用するプロセスに固有のエラーに対処しません。これらは、セクション15.1.9で対処されています。"
    },
    {
      "indent": 0,
      "text": "15.1.8.1. NFS4ERR_BAD_RANGE (Error Code 10042)",
      "section_title": true,
      "ja": "15.1.8.1。 NFS4ERR_BAD_RANGE（エラーコード10042）"
    },
    {
      "indent": 3,
      "text": "The byte-range of a LOCK, LOCKT, or LOCKU operation is not allowed by the server. For example, this error results when a server that only supports 32-bit ranges receives a range that cannot be handled by that server. (See Section 18.10.3.)",
      "ja": "LOCK、LOCKT、又はLOCKU動作のバイト範囲をサーバによって許可されていません。のみ32ビットの範囲をサポートするサーバは、そのサーバによって処理することができない範囲を受信した場合、例えば、このエラーが生じます。 （項18.10.3を参照してください。）"
    },
    {
      "indent": 0,
      "text": "15.1.8.2. NFS4ERR_DEADLOCK (Error Code 10045)",
      "section_title": true,
      "ja": "15.1.8.2。 NFS4ERR_DEADLOCK（エラーコード10045）"
    },
    {
      "indent": 3,
      "text": "The server has been able to determine a byte-range locking deadlock condition for a READW_LT or WRITEW_LT LOCK operation.",
      "ja": "サーバはREADW_LT又はWRITEW_LT LOCK動作のためのバイト範囲ロックのデッドロック状態を決定することができました。"
    },
    {
      "indent": 0,
      "text": "15.1.8.3. NFS4ERR_DENIED (Error Code 10010)",
      "section_title": true,
      "ja": "15.1.8.3。 NFS4ERR_DENIED（エラーコード10010）"
    },
    {
      "indent": 3,
      "text": "An attempt to lock a file is denied. Since this may be a temporary condition, the client is encouraged to re-send the lock request (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send) until the lock is accepted. See Section 9.6 for a discussion of the re-send.",
      "ja": "ファイルをロックしようとする試みは拒否されます。これは一時的な状態であってもよいので、クライアントは、（ただし、同じスロットIDおよびシーケンスIDと、一方または両方は、再送信に異なっていなければなりません）ロック要求を再送信することが推奨されているロックが受け入れられるまで。再送信の議論については、セクション9.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.8.4. NFS4ERR_LOCKED (Error Code 10012)",
      "section_title": true,
      "ja": "15.1.8.4。 NFS4ERR_LOCKED（エラーコード10012）"
    },
    {
      "indent": 3,
      "text": "A READ or WRITE operation was attempted on a file where there was a conflict between the I/O and an existing lock:",
      "ja": "READまたはWRITE操作は、I / Oと既存のロックとの間に矛盾があったファイル上で試行されました："
    },
    {
      "indent": 3,
      "text": "o There is a share reservation inconsistent with the I/O being done.",
      "ja": "O I / Oが行われていると矛盾シェア予約があります。"
    },
    {
      "indent": 3,
      "text": "o The range to be read or written intersects an existing mandatory byte-range lock.",
      "ja": "範囲が読み書きさに対するO既存の必須のバイト範囲ロックを交差します。"
    },
    {
      "indent": 0,
      "text": "15.1.8.5. NFS4ERR_LOCKS_HELD (Error Code 10037)",
      "section_title": true,
      "ja": "15.1.8.5。 NFS4ERR_LOCKS_HELD（エラーコード10037）"
    },
    {
      "indent": 3,
      "text": "An operation was prevented by the unexpected presence of locks.",
      "ja": "操作はロックの予期せぬ存在によって阻止されました。"
    },
    {
      "indent": 0,
      "text": "15.1.8.6. NFS4ERR_LOCK_NOTSUPP (Error Code 10043)",
      "section_title": true,
      "ja": "15.1.8.6。 NFS4ERR_LOCK_NOTSUPP（エラーコード10043）"
    },
    {
      "indent": 3,
      "text": "A LOCK operation was attempted that would require the upgrade or downgrade of a byte-range lock range already held by the owner, and the server does not support atomic upgrade or downgrade of locks.",
      "ja": "LOCK操作は、既に所有者が保持しているバイト範囲ロックレンジのアップグレードまたはダウングレードしている必要があるしようとしました、そして、サーバは、ロックの原子アップグレードまたはダウングレードをサポートしていません。"
    },
    {
      "indent": 0,
      "text": "15.1.8.7. NFS4ERR_LOCK_RANGE (Error Code 10028)",
      "section_title": true,
      "ja": "15.1.8.7。 NFS4ERR_LOCK_RANGE（エラーコード10028）"
    },
    {
      "indent": 3,
      "text": "A LOCK operation is operating on a range that overlaps in part a currently held byte-range lock for the current lock-owner and does not precisely match a single such byte-range lock where the server does not support this type of request, and thus does not implement",
      "ja": "LOCK操作は、部分的には現在のロック所有者のために現在保持されているバイト範囲ロックをオーバーラップし、正確サーバが要求のこのタイプをサポートしていない単一のそのようなバイト範囲ロックと一致しない範囲で動作し、したがってされ実装されていません。"
    },
    {
      "indent": 3,
      "text": "POSIX locking semantics [24]. See Sections 18.10.4, 18.11.4, and 18.12.4 for a discussion of how this applies to LOCK, LOCKT, and LOCKU respectively.",
      "ja": "POSIXロック意味論[24]。これは、それぞれ、LOCKT、およびLOCKUをLOCKに適用する方法の議論については、セクション18.10.4、18.11.4、および18.12.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.8.8. NFS4ERR_OPENMODE (Error Code 10038)",
      "section_title": true,
      "ja": "15.1.8.8。 NFS4ERR_OPENMODE（エラーコード10038）"
    },
    {
      "indent": 3,
      "text": "The client attempted a READ, WRITE, LOCK, or other operation not sanctioned by the stateid passed (e.g., writing to a file opened for read-only access).",
      "ja": "クライアントは、WRITE、LOCKをREADを実行しようとしました、または他の操作（例えば、ファイルへの書き込みは、読み出し専用アクセス用に開かれた）のstateid渡さによって認可ません。"
    },
    {
      "indent": 0,
      "text": "15.1.8.9. NFS4ERR_SHARE_DENIED (Error Code 10015)",
      "section_title": true,
      "ja": "15.1.8.9。 NFS4ERR_SHARE_DENIED（エラーコード10015）"
    },
    {
      "indent": 3,
      "text": "An attempt to OPEN a file with a share reservation has failed because of a share conflict.",
      "ja": "シェア予約でファイルを開こうとは理由共有競合が失敗しました。"
    },
    {
      "indent": 0,
      "text": "15.1.9. Reclaim Errors",
      "section_title": true,
      "ja": "15.1.9. エラーを取り戻します"
    },
    {
      "indent": 3,
      "text": "These errors relate to the process of reclaiming locks after a server restart.",
      "ja": "これらのエラーは、サーバの再起動後にロックを再利用するプロセスに関係します。"
    },
    {
      "indent": 0,
      "text": "15.1.9.1. NFS4ERR_COMPLETE_ALREADY (Error Code 10054)",
      "section_title": true,
      "ja": "15.1.9.1。 NFS4ERR_COMPLETE_ALREADY（エラーコード10054）"
    },
    {
      "indent": 3,
      "text": "The client previously sent a successful RECLAIM_COMPLETE operation. An additional RECLAIM_COMPLETE operation is not necessary and results in this error.",
      "ja": "クライアントは、以前に成功したRECLAIM_COMPLETE操作を送りました。追加RECLAIM_COMPLETE操作は不要であり、このエラーが発生します。"
    },
    {
      "indent": 0,
      "text": "15.1.9.2. NFS4ERR_GRACE (Error Code 10013)",
      "section_title": true,
      "ja": "15.1.9.2。 NFS4ERR_GRACE（エラーコード10013）"
    },
    {
      "indent": 3,
      "text": "The server was in its recovery or grace period. The locking request was not a reclaim request and so could not be granted during that period.",
      "ja": "サーバーは、その回復または猶予期間中でした。ロック要求は、再利用の要求ではなかったので、その期間中に付与されませんでした。"
    },
    {
      "indent": 0,
      "text": "15.1.9.3. NFS4ERR_NO_GRACE (Error Code 10033)",
      "section_title": true,
      "ja": "15.1.9.3。 NFS4ERR_NO_GRACE（エラーコード10033）"
    },
    {
      "indent": 3,
      "text": "A reclaim of client state was attempted in circumstances in which the server cannot guarantee that conflicting state has not been provided to another client. This can occur because the reclaim has been done outside of the grace period of the server, after the client has done a RECLAIM_COMPLETE operation, or because previous operations have created a situation in which the server is not able to determine that a reclaim-interfering edge condition does not exist.",
      "ja": "クライアントの状態の再利用は、サーバーが競合状態が他のクライアントに提供されていないことを保証することができない状況にしようとしました。クライアントがRECLAIM_COMPLETE操作を行っている後に再利用は、サーバーの猶予期間の外で行われているため、または以前の操作は、サーバーが再利用干渉エッジいることを決定することができないような状況を作成しているため、これが発生する可能性があります条件は存在しません。"
    },
    {
      "indent": 0,
      "text": "15.1.9.4. NFS4ERR_RECLAIM_BAD (Error Code 10034)",
      "section_title": true,
      "ja": "15.1.9.4。 NFS4ERR_RECLAIM_BAD（エラーコード10034）"
    },
    {
      "indent": 3,
      "text": "The server has determined that a reclaim attempted by the client is not valid, i.e. the lock specified as being reclaimed could not possibly have existed before the server restart. A server is not obliged to make this determination and will typically rely on the client to only reclaim locks that the client was granted prior to restart. However, when a server does have reliable information to enable it make this determination, this error indicates that the reclaim has been rejected as invalid. This is as opposed to the error NFS4ERR_RECLAIM_CONFLICT (see Section 15.1.9.5) where the server can only determine that there has been an invalid reclaim, but cannot determine which request is invalid.",
      "ja": "サーバーは、クライアントによって試み再利用は再利用されているものとして指定されたロックはおそらく、サーバーの再起動前に存在していることができなかった、すなわち、有効でないと判断しました。サーバーは、この決定を行うことが義務付けされておらず、一般的にのみ、クライアントが再起動する前に許可されたロックを再要求するクライアントに依存しています。サーバは、それがこの決意を作る可能にするための信頼できる情報を持っているときただし、このエラーは再利用が無効として拒否されたことを示します。サーバーのみ無効な再利用があったと判断することができますが、無効である、要求判断できないエラーNFS4ERR_RECLAIM_CONFLICT（項15.1.9.5を参照）とは対照的に、これがあります。"
    },
    {
      "indent": 0,
      "text": "15.1.9.5. NFS4ERR_RECLAIM_CONFLICT (Error Code 10035)",
      "section_title": true,
      "ja": "15.1.9.5。 NFS4ERR_RECLAIM_CONFLICT（エラーコード10035）"
    },
    {
      "indent": 3,
      "text": "The reclaim attempted by the client has encountered a conflict and cannot be satisfied. Potentially indicates a misbehaving client, although not necessarily the one receiving the error. The misbehavior might be on the part of the client that established the lock with which this client conflicted. See also Section 15.1.9.4 for the related error, NFS4ERR_RECLAIM_BAD.",
      "ja": "クライアントによって試み再利用は、競合が発生したため、満足することはできません。潜在的なエラーを受け取っ1必ずしもではないが、ふらちなクライアントを示します。不正行為は、このクライアントが衝突したとのロックを確立し、クライアントの一部であるかもしれません。また、関連のエラー、NFS4ERR_RECLAIM_BADについては、セクション15.1.9.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.10. pNFS Errors",
      "section_title": true,
      "ja": "15.1.10.  pNFSのエラー"
    },
    {
      "indent": 3,
      "text": "This section deals with pNFS-related errors including those that are associated with using NFSv4.1 to communicate with a data server.",
      "ja": "データ・サーバと通信するNFSv4.1の使用に関連しているものを含むpNFSの関連エラーこのセクションで扱います。"
    },
    {
      "indent": 0,
      "text": "15.1.10.1. NFS4ERR_BADIOMODE (Error Code 10049)",
      "section_title": true,
      "ja": "15.1.10.1。 NFS4ERR_BADIOMODE（エラーコード10049）"
    },
    {
      "indent": 3,
      "text": "An invalid or inappropriate layout iomode was specified. For example an inappropriate layout iomode, suppose a client's LAYOUTGET operation specified an iomode of LAYOUTIOMODE4_RW, and the server is neither able nor willing to let the client send write requests to data servers; the server can reply with NFS4ERR_BADIOMODE. The client would then send another LAYOUTGET with an iomode of LAYOUTIOMODE4_READ.",
      "ja": "無効または不適切なレイアウトIOModeには、指定されました。例えば、不適切なレイアウトIOModeに、クライアントのLAYOUTGET操作がLAYOUTIOMODE4_RWのIOModeに指定し、サーバーができず、クライアントがデータ・サーバへの書き込み要求を送信できるように喜んでもないと仮定。サーバーはNFS4ERR_BADIOMODEで返信することができます。次に、クライアントはLAYOUTIOMODE4_READのIOModeにして別のLAYOUTGETを送信します。"
    },
    {
      "indent": 0,
      "text": "15.1.10.2. NFS4ERR_BADLAYOUT (Error Code 10050)",
      "section_title": true,
      "ja": "15.1.10.2。 NFS4ERR_BADLAYOUT（エラーコード10050）"
    },
    {
      "indent": 3,
      "text": "The layout specified is invalid in some way. For LAYOUTCOMMIT, this indicates that the specified layout is not held by the client or is not of mode LAYOUTIOMODE4_RW. For LAYOUTGET, it indicates that a layout matching the client's specification as to minimum length cannot be granted.",
      "ja": "指定されたレイアウトは、何らかの方法で無効です。 LAYOUTCOMMITの場合、これは、指定されたレイアウトがクライアントによって保有されていないことを示しているか、モードLAYOUTIOMODE4_RWのではありません。 LAYOUTGETの場合は、最小の長さに、クライアントの仕様に合致するレイアウトを付与することはできませんことを示しています。"
    },
    {
      "indent": 0,
      "text": "15.1.10.3. NFS4ERR_LAYOUTTRYLATER (Error Code 10058)",
      "section_title": true,
      "ja": "15.1.10.3。 NFS4ERR_LAYOUTTRYLATER（エラーコード10058）"
    },
    {
      "indent": 3,
      "text": "Layouts are temporarily unavailable for the file. The client should re-send later (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send).",
      "ja": "レイアウトは、ファイルのために一時的に利用できません。 （;いずれかまたは両方は、再送信に異なっていなければなりません同じスロットID及び配列IDではなく）クライアントは、後に再送信しなければなりません。"
    },
    {
      "indent": 0,
      "text": "15.1.10.4. NFS4ERR_LAYOUTUNAVAILABLE (Error Code 10059)",
      "section_title": true,
      "ja": "15.1.10.4。 NFS4ERR_LAYOUTUNAVAILABLE（エラーコード10059）"
    },
    {
      "indent": 3,
      "text": "Returned when layouts are not available for the current file system or the particular specified file.",
      "ja": "レイアウトは現在のファイルシステムまたは特定の指定されたファイルのために利用できない場合に返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.10.5. NFS4ERR_NOMATCHING_LAYOUT (Error Code 10060)",
      "section_title": true,
      "ja": "15.1.10.5。 NFS4ERR_NOMATCHING_LAYOUT（エラーコード10060）"
    },
    {
      "indent": 3,
      "text": "Returned when layouts are recalled and the client has no layouts matching the specification of the layouts being recalled.",
      "ja": "レイアウトはリコールされたときに返されると、クライアントは、リコールされているレイアウトの仕様に一致するレイアウトを持っていません。"
    },
    {
      "indent": 0,
      "text": "15.1.10.6. NFS4ERR_PNFS_IO_HOLE (Error Code 10075)",
      "section_title": true,
      "ja": "15.1.10.6。 NFS4ERR_PNFS_IO_HOLE（エラーコード10075）"
    },
    {
      "indent": 3,
      "text": "The pNFS client has attempted to read from or write to an illegal hole of a file of a data server that is using sparse packing. See Section 13.4.4.",
      "ja": "pNFSのクライアントから読み取りまたはスパース梱包を使用しているデータ・サーバのファイルの違法穴に書き込もうとしています。セクション13.4.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.10.7. NFS4ERR_PNFS_NO_LAYOUT (Error Code 10080)",
      "section_title": true,
      "ja": "15.1.10.7。 NFS4ERR_PNFS_NO_LAYOUT（エラーコード10080）"
    },
    {
      "indent": 3,
      "text": "The pNFS client has attempted to read from or write to a file (using a request to a data server) without holding a valid layout. This includes the case where the client had a layout, but the iomode does not allow a WRITE.",
      "ja": "pNFSのクライアントから読み込むか、有効なレイアウトを保持せずに（データ・サーバへのリクエストを使用して）、ファイルに書き込もうとしています。これにより、クライアントは、レイアウトを持っていた場合を含むが、IOModeには、WRITEを許可していません。"
    },
    {
      "indent": 0,
      "text": "15.1.10.8. NFS4ERR_RETURNCONFLICT (Error Code 10086)",
      "section_title": true,
      "ja": "15.1.10.8。 NFS4ERR_RETURNCONFLICT（エラーコード10086）"
    },
    {
      "indent": 3,
      "text": "A layout is unavailable due to an attempt to perform the LAYOUTGET before a pending LAYOUTRETURN on the file has been received. See Section 12.5.5.2.1.3.",
      "ja": "レイアウトが原因ファイルに保留LAYOUTRETURNが受信された前LAYOUTGETを実行しようとする試みには使用できません。節12.5.5.2.1.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.10.9. NFS4ERR_UNKNOWN_LAYOUTTYPE (Error Code 10062)",
      "section_title": true,
      "ja": "15.1.10.9。 NFS4ERR_UNKNOWN_LAYOUTTYPE（エラーコード10062）"
    },
    {
      "indent": 3,
      "text": "The client has specified a layout type that is not supported by the server.",
      "ja": "クライアントは、サーバーでサポートされていないレイアウトタイプを指定しています。"
    },
    {
      "indent": 0,
      "text": "15.1.11. Session Use Errors",
      "section_title": true,
      "ja": "15.1.11. セッションの使用エラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors encountered when using sessions, that is, errors encountered when a request uses a Sequence (i.e., either SEQUENCE or CB_SEQUENCE) operation.",
      "ja": "セッションを使用する場合、すなわち、発生したエラー、要求シーケンス（すなわち、いずれかの配列またはCB_SEQUENCE）動作を使用するときに発生したエラーこのセクションで扱います。"
    },
    {
      "indent": 0,
      "text": "15.1.11.1. NFS4ERR_BADSESSION (Error Code 10052)",
      "section_title": true,
      "ja": "15.1.11.1。 NFS4ERR_BADSESSION（エラーコード10052）"
    },
    {
      "indent": 3,
      "text": "The specified session ID is unknown to the server to which the operation is addressed.",
      "ja": "指定されたセッションIDは、操作がアドレス指定されているサーバーには不明です。"
    },
    {
      "indent": 0,
      "text": "15.1.11.2. NFS4ERR_BADSLOT (Error Code 10053)",
      "section_title": true,
      "ja": "15.1.11.2。 NFS4ERR_BADSLOT（エラーコード10053）"
    },
    {
      "indent": 3,
      "text": "The requester sent a Sequence operation that attempted to use a slot the replier does not have in its slot table. It is possible the slot may have been retired.",
      "ja": "依頼者はリプライヤは、そのスロットテーブルに持っていないスロットを使用しようとしましたシーケンス動作を送りました。スロットが廃止されている可能性が可能です。"
    },
    {
      "indent": 0,
      "text": "15.1.11.3. NFS4ERR_BAD_HIGH_SLOT (Error Code 10077)",
      "section_title": true,
      "ja": "15.1.11.3。 NFS4ERR_BAD_HIGH_SLOT（エラーコード10077）"
    },
    {
      "indent": 3,
      "text": "The highest_slot argument in a Sequence operation exceeds the replier's enforced highest_slotid.",
      "ja": "シーケンス動作中highest_slot引数はリプライヤの施行highest_slotidを超えています。"
    },
    {
      "indent": 0,
      "text": "15.1.11.4. NFS4ERR_CB_PATH_DOWN (Error Code 10048)",
      "section_title": true,
      "ja": "15.1.11.4。 NFS4ERR_CB_PATH_DOWN（エラーコード10048）"
    },
    {
      "indent": 3,
      "text": "There is a problem contacting the client via the callback path. The function of this error has been mostly superseded by the use of status flags in the reply to the SEQUENCE operation (see Section 18.46).",
      "ja": "コールバックパスを介してクライアントとの接触の問題があります。このエラーの機能は、主に（項18.46を参照してください）シーケンス動作への応答におけるステータスフラグの使用によって取って代わられました。"
    },
    {
      "indent": 0,
      "text": "15.1.11.5. NFS4ERR_DEADSESSION (Error Code 10078)",
      "section_title": true,
      "ja": "15.1.11.5。 NFS4ERR_DEADSESSION（エラーコード10078）"
    },
    {
      "indent": 3,
      "text": "The specified session is a persistent session that is dead and does not accept new requests or perform new operations on existing requests (in the case in which a request was partially executed before server restart).",
      "ja": "指定されたセッションが死んでいると新しい要求を受け入れるか（要求が部分的にサーバの再起動前に実行された場合）既存の要求に新しい操作を実行しない永続的なセッションです。"
    },
    {
      "indent": 0,
      "text": "15.1.11.6. NFS4ERR_CONN_NOT_BOUND_TO_SESSION (Error Code 10055)",
      "section_title": true,
      "ja": "15.1.11.6。 NFS4ERR_CONN_NOT_BOUND_TO_SESSION（エラーコード10055）"
    },
    {
      "indent": 3,
      "text": "A Sequence operation was sent on a connection that has not been associated with the specified session, where the client specified that connection association was to be enforced with SP4_MACH_CRED or SP4_SSV state protection.",
      "ja": "シーケンス動作は、クライアントが接続アソシエーションがSP4_MACH_CRED又はSP4_SSV状態の保護に適用されるようになったことを指定し、指定されたセッションと関連付けられていない接続上で送信されました。"
    },
    {
      "indent": 0,
      "text": "15.1.11.7. NFS4ERR_SEQ_FALSE_RETRY (Error Code 10076)",
      "section_title": true,
      "ja": "15.1.11.7。 NFS4ERR_SEQ_FALSE_RETRY（エラーコード10076）"
    },
    {
      "indent": 3,
      "text": "The requester sent a Sequence operation with a slot ID and sequence ID that are in the reply cache, but the replier has detected that the retried request is not the same as the original request. See Section 2.10.6.1.3.1.",
      "ja": "リクエスタが応答キャッシュ内にあるスロットID及びシーケンス番号とシーケンス動作を送ったが、回答者が再試行要求が元の要求と同じでないことが検出されました。第2.10.6.1.3.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "15.1.11.8. NFS4ERR_SEQ_MISORDERED (Error Code 10063)",
      "section_title": true,
      "ja": "15.1.11.8。 NFS4ERR_SEQ_MISORDERED（エラーコード10063）"
    },
    {
      "indent": 3,
      "text": "The requester sent a Sequence operation with an invalid sequence ID.",
      "ja": "依頼者は、無効なシーケンスIDとシーケンス動作を送りました。"
    },
    {
      "indent": 0,
      "text": "15.1.12. Session Management Errors",
      "section_title": true,
      "ja": "15.1.12. セッション管理エラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors associated with requests used in session management.",
      "ja": "このセクションでは、セッション管理に使用される要求に関連するエラーを扱っています。"
    },
    {
      "indent": 0,
      "text": "15.1.12.1. NFS4ERR_BACK_CHAN_BUSY (Error Code 10057)",
      "section_title": true,
      "ja": "15.1.12.1。 NFS4ERR_BACK_CHAN_BUSY（エラーコード10057）"
    },
    {
      "indent": 3,
      "text": "An attempt was made to destroy a session when the session cannot be destroyed because the server has callback requests outstanding.",
      "ja": "試みは、サーバーが未解決のコールバック要求を持っているため、セッションを破壊することができないときに、セッションを破棄しました。"
    },
    {
      "indent": 0,
      "text": "15.1.12.2. NFS4ERR_BAD_SESSION_DIGEST (Error Code 10051)",
      "section_title": true,
      "ja": "15.1.12.2。 NFS4ERR_BAD_SESSION_DIGEST（エラーコード10051）"
    },
    {
      "indent": 3,
      "text": "The digest used in a SET_SSV request is not valid.",
      "ja": "SET_SSV要求で使用されるダイジェストが有効ではありません。"
    },
    {
      "indent": 0,
      "text": "15.1.13. Client Management Errors",
      "section_title": true,
      "ja": "15.1.13. クライアント管理のエラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors associated with requests used to create and manage client IDs.",
      "ja": "このセクションでは、クライアントIDを作成し、管理するために使用される要求に関連するエラーを扱っています。"
    },
    {
      "indent": 0,
      "text": "15.1.13.1. NFS4ERR_CLIENTID_BUSY (Error Code 10074)",
      "section_title": true,
      "ja": "15.1.13.1。 NFS4ERR_CLIENTID_BUSY（エラーコード10074）"
    },
    {
      "indent": 3,
      "text": "The DESTROY_CLIENTID operation has found there are sessions and/or unexpired state associated with the client ID to be destroyed.",
      "ja": "DESTROY_CLIENTID操作が破壊されるクライアントIDに関連付けられたセッションおよび/または有効期限内の状態がある発見しました。"
    },
    {
      "indent": 0,
      "text": "15.1.13.2. NFS4ERR_CLID_INUSE (Error Code 10017)",
      "section_title": true,
      "ja": "15.1.13.2。 NFS4ERR_CLID_INUSE（エラーコード10017）"
    },
    {
      "indent": 3,
      "text": "While processing an EXCHANGE_ID operation, the server was presented with a co_ownerid field that matches an existing client with valid leased state, but the principal sending the EXCHANGE_ID operation differs from the principal that established the existing client. This indicates a collision (most likely due to chance) between clients. The client should recover by changing the co_ownerid and re-sending EXCHANGE_ID (but not with the same slot ID and sequence ID; one or both MUST be different on the re-send).",
      "ja": "EXCHANGE_ID操作の処理中に、サーバーは有効なリースの状態で、既存のクライアントと一致しますが、EXCHANGE_ID操作を送信するプリンシパルは、既存のクライアントを確立校長は異なりco_ownerid場で発表されました。これは、クライアント間の衝突（偶然による最も可能性が高い）を示しています。クライアントはco_owneridを変更しEXCHANGE_ID再送信することにより、回復すべきである（ただし、同じスロットIDとシーケンスIDと、一方または両方は、再送信に異なっていなければなりません）。"
    },
    {
      "indent": 0,
      "text": "15.1.13.3. NFS4ERR_ENCR_ALG_UNSUPP (Error Code 10079)",
      "section_title": true,
      "ja": "15.1.13.3。 NFS4ERR_ENCR_ALG_UNSUPP（エラーコード10079）"
    },
    {
      "indent": 3,
      "text": "An EXCHANGE_ID was sent that specified state protection via SSV, and where the set of encryption algorithms presented by the client did not include any supported by the server.",
      "ja": "EXCHANGE_IDは、SSVを経由して、状態の保護を指定し、クライアントが提示する暗号化アルゴリズムのセットが含まれていなかったところいずれかがサーバーによってサポートされている送信されました。"
    },
    {
      "indent": 0,
      "text": "15.1.13.4. NFS4ERR_HASH_ALG_UNSUPP (Error Code 10072)",
      "section_title": true,
      "ja": "15.1.13.4。 NFS4ERR_HASH_ALG_UNSUPP（エラーコード10072）"
    },
    {
      "indent": 3,
      "text": "An EXCHANGE_ID was sent that specified state protection via SSV, and where the set of hashing algorithms presented by the client did not include any supported by the server.",
      "ja": "EXCHANGE_IDは、SSVを経由して、状態の保護を指定し、クライアントが提示するハッシュアルゴリズムのセットが含まれていなかったところいずれかがサーバーによってサポートされている送信されました。"
    },
    {
      "indent": 0,
      "text": "15.1.13.5. NFS4ERR_STALE_CLIENTID (Error Code 10022)",
      "section_title": true,
      "ja": "15.1.13.5。 NFS4ERR_STALE_CLIENTID（エラーコード10022）"
    },
    {
      "indent": 3,
      "text": "A client ID not recognized by the server was passed to an operation. Note that unlike the case of NFSv4.0, client IDs are not passed explicitly to the server in ordinary locking operations and cannot result in this error. Instead, when there is a server restart, it is first manifested through an error on the associated session, and the staleness of the client ID is detected when trying to associate a client ID with a new session.",
      "ja": "サーバーが認識していないクライアントIDは、操作に渡されました。 NFSv4.0の場合と異なり、クライアントIDは、通常のロック操作でサーバーに明示的に渡されていないと、このエラーになることができないことに注意してください。代わりに、サーバの再起動がある場合は、最初に関連するセッション上のエラーによって明らかにされて、新しいセッションでクライアントのIDを関連付けるしようとすると、クライアントIDの古さが検出されました。"
    },
    {
      "indent": 0,
      "text": "15.1.14. Delegation Errors",
      "section_title": true,
      "ja": "15.1.14. 委任エラー"
    },
    {
      "indent": 3,
      "text": "This section deals with errors associated with requesting and returning delegations.",
      "ja": "このセクションでは、要求と委任を返すに関連したエラーを扱っています。"
    },
    {
      "indent": 0,
      "text": "15.1.14.1. NFS4ERR_DELEG_ALREADY_WANTED (Error Code 10056)",
      "section_title": true,
      "ja": "15.1.14.1。 NFS4ERR_DELEG_ALREADY_WANTED（エラーコード10056）"
    },
    {
      "indent": 3,
      "text": "The client has requested a delegation when it had already registered that it wants that same delegation.",
      "ja": "それはすでにそれは同じ委任を望んでいることを登録した際にクライアントが委任を要求しています。"
    },
    {
      "indent": 0,
      "text": "15.1.14.2. NFS4ERR_DIRDELEG_UNAVAIL (Error Code 10084)",
      "section_title": true,
      "ja": "15.1.14.2。 NFS4ERR_DIRDELEG_UNAVAIL（エラーコード10084）"
    },
    {
      "indent": 3,
      "text": "This error is returned when the server is unable or unwilling to provide a requested directory delegation.",
      "ja": "サーバは要求されたディレクトリの委任を提供することができないか、不本意である場合、このエラーが返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.14.3. NFS4ERR_RECALLCONFLICT (Error Code 10061)",
      "section_title": true,
      "ja": "15.1.14.3。 NFS4ERR_RECALLCONFLICT（エラーコード10061）"
    },
    {
      "indent": 3,
      "text": "A recallable object (i.e., a layout or delegation) is unavailable due to a conflicting recall operation that is currently in progress for that object.",
      "ja": "リコール対象（即ち、レイアウトまたは委譲）が起因し、そのオブジェクトの現在進行中の競合リコール操作に使用できません。"
    },
    {
      "indent": 0,
      "text": "15.1.14.4. NFS4ERR_REJECT_DELEG (Error Code 10085)",
      "section_title": true,
      "ja": "15.1.14.4。 NFS4ERR_REJECT_DELEG（エラーコード10085）"
    },
    {
      "indent": 3,
      "text": "The callback operation invoked to deal with a new delegation has rejected it.",
      "ja": "新しい代表団に対処するために呼び出されるコールバック操作は、それを拒否しました。"
    },
    {
      "indent": 0,
      "text": "15.1.15. Attribute Handling Errors",
      "section_title": true,
      "ja": "15.1.15. エラー処理の属性"
    },
    {
      "indent": 3,
      "text": "This section deals with errors specific to attribute handling within NFSv4.",
      "ja": "このセクションでは、NFSv4の内ハンドリング属性に特定のエラーを扱っています。"
    },
    {
      "indent": 0,
      "text": "15.1.15.1. NFS4ERR_ATTRNOTSUPP (Error Code 10032)",
      "section_title": true,
      "ja": "15.1.15.1。 NFS4ERR_ATTRNOTSUPP（エラーコード10032）"
    },
    {
      "indent": 3,
      "text": "An attribute specified is not supported by the server. This error MUST NOT be returned by the GETATTR operation.",
      "ja": "指定された属性は、サーバーによってサポートされていません。このエラーはGETATTR操作で返されてはなりません。"
    },
    {
      "indent": 0,
      "text": "15.1.15.2. NFS4ERR_BADOWNER (Error Code 10039)",
      "section_title": true,
      "ja": "15.1.15.2。 NFS4ERR_BADOWNER（エラーコード10039）"
    },
    {
      "indent": 3,
      "text": "This error is returned when an owner or owner_group attribute value or the who field of an ACE within an ACL attribute value cannot be translated to a local representation.",
      "ja": "ACL属性値内の所有者またはowner_group属性値またはACEのフィールドは、ローカルの表現に変換することができない場合に、このエラーが返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.15.3. NFS4ERR_NOT_SAME (Error Code 10027)",
      "section_title": true,
      "ja": "15.1.15.3。 NFS4ERR_NOT_SAME（エラーコード10027）"
    },
    {
      "indent": 3,
      "text": "This error is returned by the VERIFY operation to signify that the attributes compared were not the same as those provided in the client's request.",
      "ja": "このエラーは、比較属性は、クライアントの要求に提供されるものと同じではなかったことを意味するベリファイ動作によって返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.15.4. NFS4ERR_SAME (Error Code 10009)",
      "section_title": true,
      "ja": "15.1.15.4。 NFS4ERR_SAME（エラーコード10009）"
    },
    {
      "indent": 3,
      "text": "This error is returned by the NVERIFY operation to signify that the attributes compared were the same as those provided in the client's request.",
      "ja": "このエラーは、比較属性は、クライアントの要求に提供したものと同じであったことを意味するNVERIFY操作によって返されます。"
    },
    {
      "indent": 0,
      "text": "15.1.16. Obsoleted Errors",
      "section_title": true,
      "ja": "15.1.16. 廃止されたエラー"
    },
    {
      "indent": 3,
      "text": "These errors MUST NOT be generated by any NFSv4.1 operation. This can be for a number of reasons.",
      "ja": "これらのエラーは、任意のNFSv4.1操作によって生成されてはなりません。これは多くの理由のためにすることができます。"
    },
    {
      "indent": 3,
      "text": "o The function provided by the error has been superseded by one of the status bits returned by the SEQUENCE operation.",
      "ja": "Oエラーによって提供される機能は、シーケンス動作によって返されるステータスビットの1つに置き換えられました。"
    },
    {
      "indent": 3,
      "text": "o The new session structure and associated change in locking have made the error unnecessary.",
      "ja": "O新しいセッション構造とロックの関連する変更は、エラーが不要になりました。"
    },
    {
      "indent": 3,
      "text": "o There has been a restructuring of some errors for NFSv4.1 that resulted in the elimination of certain errors.",
      "ja": "O、特定のエラーの解消が生じNFSv4.1のため多少の誤差の再編がありました。"
    },
    {
      "indent": 0,
      "text": "15.1.16.1. NFS4ERR_BAD_SEQID (Error Code 10026)",
      "section_title": true,
      "ja": "15.1.16.1。 NFS4ERR_BAD_SEQID（エラーコード10026）"
    },
    {
      "indent": 3,
      "text": "The sequence number (seqid) in a locking request is neither the next expected number or the last number processed. These seqids are ignored in NFSv4.1.",
      "ja": "ロック要求のシーケンス番号（SEQID）は次の予想数又は処理された最後の番号でもありません。これらのseqidsはNFSv4.1では無視されます。"
    },
    {
      "indent": 0,
      "text": "15.1.16.2. NFS4ERR_LEASE_MOVED (Error Code 10031)",
      "section_title": true,
      "ja": "15.1.16.2。 NFS4ERR_LEASE_MOVED（エラーコード10031）"
    },
    {
      "indent": 3,
      "text": "A lease being renewed is associated with a file system that has been migrated to a new server. The error has been superseded by the SEQ4_STATUS_LEASE_MOVED status bit (see Section 18.46).",
      "ja": "リニューアルされたリースを新しいサーバに移行されたファイルシステムに関連付けられています。エラーがSEQ4_STATUS_LEASE_MOVEDステータスビットに取って代わられている（セクション18.46を参照してください）。"
    },
    {
      "indent": 0,
      "text": "15.1.16.3. NFS4ERR_NXIO (Error Code 5)",
      "section_title": true,
      "ja": "15.1.16.3。 NFS4ERR_NXIO（エラーコード5）"
    },
    {
      "indent": 3,
      "text": "I/O error. No such device or address. This error is for errors involving block and character device access, but because NFSv4.1 is not a device-access protocol, this error is not applicable.",
      "ja": "I / Oエラー。そのようなデバイスんまたはアドレス。このエラーはブロックやキャラクタデバイスへのアクセスを伴うエラーのですが、NFSv4.1は、デバイスアクセスプロトコルではないので、このエラーは該当しません。"
    },
    {
      "indent": 0,
      "text": "15.1.16.4. NFS4ERR_RESTOREFH (Error Code 10030)",
      "section_title": true,
      "ja": "15.1.16.4。 NFS4ERR_RESTOREFH（エラーコード10030）"
    },
    {
      "indent": 3,
      "text": "The RESTOREFH operation does not have a saved filehandle (identified by SAVEFH) to operate upon. In NFSv4.1, this error has been superseded by NFS4ERR_NOFILEHANDLE.",
      "ja": "RESTOREFH操作は時に動作するように（SAVEFHによって識別される）保存されたファイルハンドルを持っていません。 NFSv4.1では、このエラーはNFS4ERR_NOFILEHANDLEに取って代わられました。"
    },
    {
      "indent": 0,
      "text": "15.1.16.5. NFS4ERR_STALE_STATEID (Error Code 10023)",
      "section_title": true,
      "ja": "15.1.16.5。 NFS4ERR_STALE_STATEID（エラーコード10023）"
    },
    {
      "indent": 3,
      "text": "A stateid generated by an earlier server instance was used. This error is moot in NFSv4.1 because all operations that take a stateid MUST be preceded by the SEQUENCE operation, and the earlier server instance is detected by the session infrastructure that supports SEQUENCE.",
      "ja": "以前のサーバインスタンスによって生成されたのstateidを使用しました。たstateidを取るすべての操作がシーケンス動作が先行されなければならない、と以前のサーバーインスタンスがSEQUENCEをサポートしているセッションインフラストラクチャによって検出されたため、このエラーがNFSv4.1で議論の余地があります。"
    },
    {
      "indent": 0,
      "text": "15.2. Operations and Their Valid Errors",
      "section_title": true,
      "ja": "15.2. オペレーションとその有効なエラー"
    },
    {
      "indent": 3,
      "text": "This section contains a table that gives the valid error returns for each protocol operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all operations with two important exceptions:",
      "ja": "このセクションでは、各プロトコルの動作のために有効なエラーリターンを与えるテーブルが含まれています。 （エラーがないことを示す）エラーコードNFS4_OKが記載されていないが、2つの重要な例外を除いて、すべての操作によって返却であると理解されるべきです。"
    },
    {
      "indent": 3,
      "text": "o The operations that MUST NOT be implemented: OPEN_CONFIRM, RELEASE_LOCKOWNER, RENEW, SETCLIENTID, and SETCLIENTID_CONFIRM.",
      "ja": "オープン_CONFIRM、RELEASE_LOCKOWNER、RENEW、SETCLIENTID、およびSETCLIENTID_CONFIRMを：実装されてはならない操作O。"
    },
    {
      "indent": 3,
      "text": "o The invalid operation: ILLEGAL.",
      "ja": "無効な操作○：ILLEGAL。"
    },
    {
      "indent": 14,
      "text": "Valid Error Returns for Each Protocol Operation",
      "ja": "各プロトコル動作のための有効なエラーを返します"
    },
    {
      "indent": 3,
      "text": "+----------------------+--------------------------------------------+\n| Operation            | Errors                                     |\n+----------------------+--------------------------------------------+\n| ACCESS               | NFS4ERR_ACCESS, NFS4ERR_BADXDR,            |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL,          |\n|                      | NFS4ERR_IO, NFS4ERR_MOVED,                 |\n|                      | NFS4ERR_NOFILEHANDLE,                      |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,                 |\n|                      | NFS4ERR_REP_TOO_BIG,                       |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |\n|                      | NFS4ERR_REQ_TOO_BIG,                       |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,                |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |\n|                      | NFS4ERR_TOO_MANY_OPS                       |\n| BACKCHANNEL_CTL      | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION,       |\n|                      | NFS4ERR_DELAY, NFS4ERR_INVAL,              |\n|                      | NFS4ERR_NOENT, NFS4ERR_OP_NOT_IN_SESSION,  |\n|                      | NFS4ERR_REP_TOO_BIG,                       |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |\n|                      | NFS4ERR_REQ_TOO_BIG,                       |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,                |\n|                      | NFS4ERR_TOO_MANY_OPS                       |\n| BIND_CONN_TO_SESSION | NFS4ERR_BADSESSION, NFS4ERR_BADXDR,        |\n|                      | NFS4ERR_BAD_SESSION_DIGEST,                |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |\n|                      | NFS4ERR_INVAL, NFS4ERR_NOT_ONLY_OP,        |\n|                      | NFS4ERR_REP_TOO_BIG,                       |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |\n|                      | NFS4ERR_REQ_TOO_BIG,                       |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,                |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS  |\n| CLOSE                | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,     |\n|                      | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION,  |\n|                      | NFS4ERR_DELAY, NFS4ERR_EXPIRED,            |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_LOCKS_HELD,     |\n|                      | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE,       |\n|                      | NFS4ERR_OLD_STATEID,                       |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,                 |\n|                      | NFS4ERR_REP_TOO_BIG,                       |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |\n|                      | NFS4ERR_REQ_TOO_BIG,                       |\n|                      | NFS4ERR_RETRY_UNCACHED_REP,                |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |\n|                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED   |\n| COMMIT               | NFS4ERR_ACCESS, NFS4ERR_BADXDR,            |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_IO, | | | NFS4ERR_ISDIR, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_WRONG_TYPE | | CREATE | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP, | | | NFS4ERR_BADCHAR, NFS4ERR_BADNAME, | | | NFS4ERR_BADOWNER, NFS4ERR_BADTYPE, | | | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_DQUOT, | | | NFS4ERR_EXIST, NFS4ERR_FHEXPIRED, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MLINK, | | | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC, | | | NFS4ERR_NOTDIR, NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_PERM, NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_UNSAFE_COMPOUND | | CREATE_SESSION | NFS4ERR_BADXDR, NFS4ERR_CLID_INUSE, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_INVAL, NFS4ERR_NOENT, | | | NFS4ERR_NOT_ONLY_OP, NFS4ERR_NOSPC, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SEQ_MISORDERED, | | | NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE_CLIENTID, NFS4ERR_TOOSMALL, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED | | DELEGPURGE | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_NOTSUPP, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, |",
      "ja": "| | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_IO、| | | NFS4ERR_ISDIR、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_SYMLINK、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_WRONG_TYPE | | CREATE | NFS4ERR_ACCESS、NFS4ERR_ATTRNOTSUPP、| | | NFS4ERR_BADCHAR、NFS4ERR_BADNAME、| | | NFS4ERR_BADOWNER、NFS4ERR_BADTYPE、| | | NFS4ERR_BADXDR、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_DQUOT、| | | NFS4ERR_EXIST、NFS4ERR_FHEXPIRED、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_MLINK、| | | NFS4ERR_MOVED、NFS4ERR_NAMETOOLONG、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOSPC、| | | NFS4ERR_NOTDIR、NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_PERM、NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_UNSAFE_COMPOUND | | CREATE_SESSION | NFS4ERR_BADXDR、NFS4ERR_CLID_INUSE、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_INVAL、NFS4ERR_NOENT、| | | NFS4ERR_NOT_ONLY_OP、NFS4ERR_NOSPC、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SEQ_MISORDERED、| | | NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE_CLIENTID、NFS4ERR_TOOSMALL、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONG_CRED | | DELEGPURGE | NFS4ERR_BADXDR、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_NOTSUPP、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_WRONG_CRED | | DELEGRETURN | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR, | | | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED, | | | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED, | | | NFS4ERR_INVAL, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, | | | NFS4ERR_OLD_STATEID, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED | | DESTROY_CLIENTID | NFS4ERR_BADXDR, NFS4ERR_CLIENTID_BUSY, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_NOT_ONLY_OP, NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE_CLIENTID, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED | | DESTROY_SESSION | NFS4ERR_BACK_CHAN_BUSY, | | | NFS4ERR_BADSESSION, NFS4ERR_BADXDR, | | | NFS4ERR_CB_PATH_DOWN, | | | NFS4ERR_CONN_NOT_BOUND_TO_SESSION, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_NOT_ONLY_OP, NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, | | | NFS4ERR_STALE_CLIENTID, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED | | EXCHANGE_ID | NFS4ERR_BADCHAR, NFS4ERR_BADXDR, | | | NFS4ERR_CLID_INUSE, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_ENCR_ALG_UNSUPP, | | | NFS4ERR_HASH_ALG_UNSUPP, NFS4ERR_INVAL, | | | NFS4ERR_NOENT, NFS4ERR_NOT_ONLY_OP, | | | NFS4ERR_NOT_SAME, NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS | | FREE_STATEID | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID, |",
      "ja": "| | NFS4ERR_SERVERFAULT、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_WRONG_CRED | | DELEGRETURN | NFS4ERR_ADMIN_REVOKED、NFS4ERR_BADXDR、| | | NFS4ERR_BAD_STATEID、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_DELEG_REVOKED、| | | NFS4ERR_EXPIRED、NFS4ERR_FHEXPIRED、| | | NFS4ERR_INVAL、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTSUPP、| | | NFS4ERR_OLD_STATEID、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONG_CRED | | DESTROY_CLIENTID | NFS4ERR_BADXDR、NFS4ERR_CLIENTID_BUSY、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_NOT_ONLY_OP、NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE_CLIENTID、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONG_CRED | | DESTROY_SESSION | NFS4ERR_BACK_CHAN_BUSY、| | | NFS4ERR_BADSESSION、NFS4ERR_BADXDR、| | | NFS4ERR_CB_PATH_DOWN、| | | NFS4ERR_CONN_NOT_BOUND_TO_SESSION、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_NOT_ONLY_OP、NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、| | | NFS4ERR_STALE_CLIENTID、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONG_CRED | | EXCHANGE_ID | NFS4ERR_BADCHAR、NFS4ERR_BADXDR、| | | NFS4ERR_CLID_INUSE、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_ENCR_ALG_UNSUPP、| | | NFS4ERR_HASH_ALG_UNSUPP、NFS4ERR_INVAL、| | | NFS4ERR_NOENT、NFS4ERR_NOT_ONLY_OP、| | | NFS4ERR_NOT_SAME、NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_TOO_MANY_OPS | | FREE_STATEID | NFS4ERR_BADXDR、NFS4ERR_BAD_STATEID、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_LOCKS_HELD, NFS4ERR_OLD_STATEID, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_WRONG_CRED | | GET_DIR_DELEGATION | NFS4ERR_ACCESS, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_DIRDELEG_UNAVAIL, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR, | | | NFS4ERR_NOTSUPP, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS | | GETATTR | NFS4ERR_ACCESS, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE | | GETDEVICEINFO | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_INVAL, | | | NFS4ERR_NOENT, NFS4ERR_NOTSUPP, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_TOOSMALL, | | | NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_UNKNOWN_LAYOUTTYPE | | GETDEVICELIST | NFS4ERR_BADXDR, NFS4ERR_BAD_COOKIE, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, |",
      "ja": "| | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_LOCKS_HELD、NFS4ERR_OLD_STATEID、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_WRONG_CRED | | GET_DIR_DELEGATION | NFS4ERR_ACCESS、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_DIRDELEG_UNAVAIL、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTDIR、| | | NFS4ERR_NOTSUPP、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS | | GETATTR | NFS4ERR_ACCESS、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONG_TYPE | | GETDEVICEINFO | NFS4ERR_BADXDR、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_INVAL、| | | NFS4ERR_NOENT、NFS4ERR_NOTSUPP、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_TOOSMALL、| | | NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_UNKNOWN_LAYOUTTYPE | | GETDEVICELIST | NFS4ERR_BADXDR、NFS4ERR_BAD_COOKIE、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL, | | | NFS4ERR_IO, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_NOTSUPP, NFS4ERR_NOT_SAME, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_UNKNOWN_LAYOUTTYPE | | GETFH | NFS4ERR_FHEXPIRED, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_STALE | | ILLEGAL | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL | | LAYOUTCOMMIT | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, | | | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADIOMODE, | | | NFS4ERR_BADLAYOUT, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED, | | | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO, | | | NFS4ERR_ISDIR NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, | | | NFS4ERR_NO_GRACE, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_RECLAIM_BAD, | | | NFS4ERR_RECLAIM_CONFLICT, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_UNKNOWN_LAYOUTTYPE, | | | NFS4ERR_WRONG_CRED | | LAYOUTGET | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, | | | NFS4ERR_BADIOMODE, NFS4ERR_BADLAYOUT, | | | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_IO, | | | NFS4ERR_LAYOUTTRYLATER, | | | NFS4ERR_LAYOUTUNAVAILABLE, NFS4ERR_LOCKED, | | | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_NOSPC, NFS4ERR_NOTSUPP, | | | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE, | | | NFS4ERR_OP_NOT_IN_SESSION, |",
      "ja": "| | NFS4ERR_FHEXPIRED、NFS4ERR_INVAL、| | | NFS4ERR_IO、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_NOTSUPP、NFS4ERR_NOT_SAME、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_UNKNOWN_LAYOUTTYPE | | GETFH | NFS4ERR_FHEXPIRED、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_OP_NOT_IN_SESSION、NFS4ERR_STALE | | ILLEGAL | NFS4ERR_BADXDR、NFS4ERR_OP_ILLEGAL | | LAYOUTCOMMIT | NFS4ERR_ACCESS、NFS4ERR_ADMIN_REVOKED、| | | NFS4ERR_ATTRNOTSUPP、NFS4ERR_BADIOMODE、| | | NFS4ERR_BADLAYOUT、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_DELEG_REVOKED、NFS4ERR_EXPIRED、| | | NFS4ERR_FBIG、NFS4ERR_FHEXPIRED、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、NFS4ERR_IO、| | | NFS4ERR_ISDIR NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTSUPP、| | | NFS4ERR_NO_GRACE、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_RECLAIM_BAD、| | | NFS4ERR_RECLAIM_CONFLICT、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_SYMLINK、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_UNKNOWN_LAYOUTTYPE、| | | NFS4ERR_WRONG_CRED | | LAYOUTGET | NFS4ERR_ACCESS、NFS4ERR_ADMIN_REVOKED、| | | NFS4ERR_BADIOMODE、NFS4ERR_BADLAYOUT、| | | NFS4ERR_BADXDR、NFS4ERR_BAD_STATEID、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_DELEG_REVOKED、NFS4ERR_DQUOT、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_IO、| | | NFS4ERR_LAYOUTTRYLATER、| | | NFS4ERR_LAYOUTUNAVAILABLE、NFS4ERR_LOCKED、| | | NFS4ERR_MOVED、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_NOSPC、NFS4ERR_NOTSUPP、| | | NFS4ERR_OLD_STATEID、NFS4ERR_OPENMODE、| | | NFS4ERR_OP_NOT_IN_SESSION、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_RECALLCONFLICT, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOOSMALL, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_UNKNOWN_LAYOUTTYPE, | | | NFS4ERR_WRONG_TYPE | | LAYOUTRETURN | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR, | | | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED, | | | NFS4ERR_EXPIRED, NFS4ERR_FHEXPIRED, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, | | | NFS4ERR_ISDIR, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, | | | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_UNKNOWN_LAYOUTTYPE, | | | NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE | | LINK | NFS4ERR_ACCESS, NFS4ERR_BADCHAR, | | | NFS4ERR_BADNAME, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_DQUOT, NFS4ERR_EXIST, | | | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, | | | NFS4ERR_ISDIR, NFS4ERR_IO, NFS4ERR_MLINK, | | | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC, | | | NFS4ERR_NOTDIR, NFS4ERR_NOTSUPP, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_WRONGSEC, NFS4ERR_WRONG_TYPE, | | | NFS4ERR_XDEV | | LOCK | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, | | | NFS4ERR_BADXDR, NFS4ERR_BAD_RANGE, | | | NFS4ERR_BAD_STATEID, NFS4ERR_DEADLOCK, |",
      "ja": "| | NFS4ERR_RECALLCONFLICT、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOOSMALL、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_UNKNOWN_LAYOUTTYPE、| | | NFS4ERR_WRONG_TYPE | | LAYOUTRETURN | NFS4ERR_ADMIN_REVOKED、NFS4ERR_BADXDR、| | | NFS4ERR_BAD_STATEID、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_DELEG_REVOKED、| | | NFS4ERR_EXPIRED、NFS4ERR_FHEXPIRED、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、| | | NFS4ERR_ISDIR、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTSUPP、| | | NFS4ERR_NO_GRACE、NFS4ERR_OLD_STATEID、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_UNKNOWN_LAYOUTTYPE、| | | NFS4ERR_WRONG_CRED、NFS4ERR_WRONG_TYPE | | LINK | NFS4ERR_ACCESS、NFS4ERR_BADCHAR、| | | NFS4ERR_BADNAME、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_DQUOT、NFS4ERR_EXIST、| | | NFS4ERR_FHEXPIRED、NFS4ERR_FILE_OPEN、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、| | | NFS4ERR_ISDIR、NFS4ERR_IO、NFS4ERR_MLINK、| | | NFS4ERR_MOVED、NFS4ERR_NAMETOOLONG、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOSPC、| | | NFS4ERR_NOTDIR、NFS4ERR_NOTSUPP、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_SYMLINK、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_WRONGSEC、NFS4ERR_WRONG_TYPE、| | | NFS4ERR_XDEV | | LOCK | NFS4ERR_ACCESS、NFS4ERR_ADMIN_REVOKED、| | | NFS4ERR_BADXDR、NFS4ERR_BAD_RANGE、| | | NFS4ERR_BAD_STATEID、NFS4ERR_DEADLOCK、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_DENIED, NFS4ERR_EXPIRED, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_ISDIR, | | | NFS4ERR_LOCK_NOTSUPP, NFS4ERR_LOCK_RANGE, | | | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_NO_GRACE, NFS4ERR_OLD_STATEID, | | | NFS4ERR_OPENMODE, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_RECLAIM_BAD, | | | NFS4ERR_RECLAIM_CONFLICT, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE | | LOCKT | NFS4ERR_ACCESS, NFS4ERR_BADXDR, | | | NFS4ERR_BAD_RANGE, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_DENIED, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_ISDIR, | | | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS, | | | NFS4ERR_STALE, NFS4ERR_SYMLINK, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED, | | | NFS4ERR_WRONG_TYPE | | LOCKU | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, | | | NFS4ERR_BADXDR, NFS4ERR_BAD_RANGE, | | | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_EXPIRED, | | | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL, | | | NFS4ERR_LOCK_RANGE, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED | | LOOKUP | NFS4ERR_ACCESS, NFS4ERR_BADCHAR, |",
      "ja": "| | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_DENIED、NFS4ERR_EXPIRED、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_ISDIR、| | | NFS4ERR_LOCK_NOTSUPP、NFS4ERR_LOCK_RANGE、| | | NFS4ERR_MOVED、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_NO_GRACE、NFS4ERR_OLD_STATEID、| | | NFS4ERR_OPENMODE、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_RECLAIM_BAD、| | | NFS4ERR_RECLAIM_CONFLICT、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_SYMLINK、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_WRONG_CRED、NFS4ERR_WRONG_TYPE | | LOCKT | NFS4ERR_ACCESS、NFS4ERR_BADXDR、| | | NFS4ERR_BAD_RANGE、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_DENIED、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_ISDIR、| | | NFS4ERR_LOCK_RANGE、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、NFS4ERR_ROFS、| | | NFS4ERR_STALE、NFS4ERR_SYMLINK、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONG_CRED、| | | NFS4ERR_WRONG_TYPE | | LOCKU | NFS4ERR_ACCESS、NFS4ERR_ADMIN_REVOKED、| | | NFS4ERR_BADXDR、NFS4ERR_BAD_RANGE、| | | NFS4ERR_BAD_STATEID、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_EXPIRED、| | | NFS4ERR_FHEXPIRED、NFS4ERR_INVAL、| | | NFS4ERR_LOCK_RANGE、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_OLD_STATEID、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONG_CRED | | LOOKUP | NFS4ERR_ACCESS、NFS4ERR_BADCHAR、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_BADNAME, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL, | | | NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_WRONGSEC | | LOOKUPP | NFS4ERR_ACCESS, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED, | | | NFS4ERR_IO, NFS4ERR_MOVED, NFS4ERR_NOENT, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_WRONGSEC | | NVERIFY | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP, | | | NFS4ERR_BADCHAR, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_SAME, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_UNKNOWN_LAYOUTTYPE, | | | NFS4ERR_WRONG_TYPE | | OPEN | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, | | | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR, | | | NFS4ERR_BADNAME, NFS4ERR_BADOWNER, | | | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_DELEG_ALREADY_WANTED, | | | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT, |",
      "ja": "| | NFS4ERR_BADNAME、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_INVAL、| | | NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NAMETOOLONG、NFS4ERR_NOENT、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTDIR、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_SYMLINK、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_WRONGSEC | | LOOKUPP | NFS4ERR_ACCESS、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_FHEXPIRED、| | | NFS4ERR_IO、NFS4ERR_MOVED、NFS4ERR_NOENT、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTDIR、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_SYMLINK、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_WRONGSEC | | NVERIFY | NFS4ERR_ACCESS、NFS4ERR_ATTRNOTSUPP、| | | NFS4ERR_BADCHAR、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、NFS4ERR_SAME、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_UNKNOWN_LAYOUTTYPE、| | | NFS4ERR_WRONG_TYPE | | OPEN | NFS4ERR_ACCESS、NFS4ERR_ADMIN_REVOKED、| | | NFS4ERR_ATTRNOTSUPP、NFS4ERR_BADCHAR、| | | NFS4ERR_BADNAME、NFS4ERR_BADOWNER、| | | NFS4ERR_BADXDR、NFS4ERR_BAD_STATEID、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_DELEG_ALREADY_WANTED、| | | NFS4ERR_DELEG_REVOKED、NFS4ERR_DQUOT、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_EXIST, NFS4ERR_EXPIRED, | | | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, | | | NFS4ERR_ISDIR, NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC, | | | NFS4ERR_NOTDIR, NFS4ERR_NO_GRACE, | | | NFS4ERR_OLD_STATEID, | | | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PERM, | | | NFS4ERR_RECLAIM_BAD, | | | NFS4ERR_RECLAIM_CONFLICT, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_SHARE_DENIED, | | | NFS4ERR_STALE, NFS4ERR_SYMLINK, | | | NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_UNSAFE_COMPOUND, NFS4ERR_WRONGSEC, | | | NFS4ERR_WRONG_TYPE | | OPEN_CONFIRM | NFS4ERR_NOTSUPP | | OPEN_DOWNGRADE | NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR, | | | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_EXPIRED, | | | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL, | | | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_OLD_STATEID, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED | | OPENATTR | NFS4ERR_ACCESS, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_DQUOT, NFS4ERR_FHEXPIRED, | | | NFS4ERR_IO, NFS4ERR_MOVED, NFS4ERR_NOENT, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC, | | | NFS4ERR_NOTSUPP, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_UNSAFE_COMPOUND, |",
      "ja": "| | NFS4ERR_EXIST、NFS4ERR_EXPIRED、| | | NFS4ERR_FBIG、NFS4ERR_FHEXPIRED、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、| | | NFS4ERR_ISDIR、NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NAMETOOLONG、NFS4ERR_NOENT、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOSPC、| | | NFS4ERR_NOTDIR、NFS4ERR_NO_GRACE、| | | NFS4ERR_OLD_STATEID、| | | NFS4ERR_OP_NOT_IN_SESSION、NFS4ERR_PERM、| | | NFS4ERR_RECLAIM_BAD、| | | NFS4ERR_RECLAIM_CONFLICT、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_SHARE_DENIED、| | | NFS4ERR_STALE、NFS4ERR_SYMLINK、| | | NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_UNSAFE_COMPOUND、NFS4ERR_WRONGSEC、| | | NFS4ERR_WRONG_TYPE | |オープン_CONFIRM | NFS4ERR_NOTSUPP | | OPEN_DOWNGRADE | NFS4ERR_ADMIN_REVOKED、NFS4ERR_BADXDR、| | | NFS4ERR_BAD_STATEID、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_EXPIRED、| | | NFS4ERR_FHEXPIRED、NFS4ERR_INVAL、| | | NFS4ERR_MOVED、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_OLD_STATEID、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONG_CRED | | OPENATTR | NFS4ERR_ACCESS、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_DQUOT、NFS4ERR_FHEXPIRED、| | | NFS4ERR_IO、NFS4ERR_MOVED、NFS4ERR_NOENT、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOSPC、| | | NFS4ERR_NOTSUPP、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_UNSAFE_COMPOUND、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_WRONG_TYPE | | PUTFH | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_MOVED, NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC | | PUTPUBFH | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_WRONGSEC | | PUTROOTFH | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_WRONGSEC | | READ | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, | | | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_DELEG_REVOKED, NFS4ERR_EXPIRED, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_ISDIR, NFS4ERR_IO, | | | NFS4ERR_LOCKED, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_OLD_STATEID, | | | NFS4ERR_OPENMODE, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_PNFS_IO_HOLE, | | | NFS4ERR_PNFS_NO_LAYOUT, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_WRONG_TYPE | | READDIR | NFS4ERR_ACCESS, NFS4ERR_BADXDR, | | | NFS4ERR_BAD_COOKIE, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED, |",
      "ja": "| | NFS4ERR_WRONG_TYPE | | PUTFH | NFS4ERR_BADHANDLE、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_MOVED、NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONGSEC | | PUTPUBFH | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_WRONGSEC | | PUTROOTFH | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_WRONGSEC | | READ | NFS4ERR_ACCESS、NFS4ERR_ADMIN_REVOKED、| | | NFS4ERR_BADXDR、NFS4ERR_BAD_STATEID、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_DELEG_REVOKED、NFS4ERR_EXPIRED、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_ISDIR、NFS4ERR_IO、| | | NFS4ERR_LOCKED、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_OLD_STATEID、| | | NFS4ERR_OPENMODE、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_PNFS_IO_HOLE、| | | NFS4ERR_PNFS_NO_LAYOUT、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_SYMLINK、NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_WRONG_TYPE | | READDIR | NFS4ERR_ACCESS、NFS4ERR_BADXDR、| | | NFS4ERR_BAD_COOKIE、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_FHEXPIRED、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR, | | | NFS4ERR_NOT_SAME, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOOSMALL, NFS4ERR_TOO_MANY_OPS | | READLINK | NFS4ERR_ACCESS, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_FHEXPIRED, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE | | RECLAIM_COMPLETE | NFS4ERR_BADXDR, NFS4ERR_COMPLETE_ALREADY, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL, | | | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_CRED, | | | NFS4ERR_WRONG_TYPE | | RELEASE_LOCKOWNER | NFS4ERR_NOTSUPP | | REMOVE | NFS4ERR_ACCESS, NFS4ERR_BADCHAR, | | | NFS4ERR_BADNAME, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO, | | | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG, | | | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_NOTDIR, NFS4ERR_NOTEMPTY, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, |",
      "ja": "| | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTDIR、| | | NFS4ERR_NOT_SAME、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOOSMALL、NFS4ERR_TOO_MANY_OPS | | READLINK | NFS4ERR_ACCESS、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_FHEXPIRED、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONG_TYPE | | RECLAIM_COMPLETE | NFS4ERR_BADXDR、NFS4ERR_COMPLETE_ALREADY、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_INVAL、| | | NFS4ERR_MOVED、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONG_CRED、| | | NFS4ERR_WRONG_TYPE | | RELEASE_LOCKOWNER | NFS4ERR_NOTSUPP | | REMOVE | NFS4ERR_ACCESS、NFS4ERR_BADCHAR、| | | NFS4ERR_BADNAME、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_FILE_OPEN、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、NFS4ERR_IO、| | | NFS4ERR_MOVED、NFS4ERR_NAMETOOLONG、| | | NFS4ERR_NOENT、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_NOTDIR、NFS4ERR_NOTEMPTY、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_TOO_MANY_OPS | | RENAME | NFS4ERR_ACCESS, NFS4ERR_BADCHAR, | | | NFS4ERR_BADNAME, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_DQUOT, NFS4ERR_EXIST, | | | NFS4ERR_FHEXPIRED, NFS4ERR_FILE_OPEN, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO, | | | NFS4ERR_MLINK, NFS4ERR_MOVED, | | | NFS4ERR_NAMETOOLONG, NFS4ERR_NOENT, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC, | | | NFS4ERR_NOTDIR, NFS4ERR_NOTEMPTY, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC, | | | NFS4ERR_XDEV | | RENEW | NFS4ERR_NOTSUPP | | RESTOREFH | NFS4ERR_DEADSESSION, NFS4ERR_FHEXPIRED, | | | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONGSEC | | SAVEFH | NFS4ERR_DEADSESSION, NFS4ERR_FHEXPIRED, | | | NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS | | SECINFO | NFS4ERR_ACCESS, NFS4ERR_BADCHAR, | | | NFS4ERR_BADNAME, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL, | | | NFS4ERR_MOVED, NFS4ERR_NAMETOOLONG, | | | NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE, | | | NFS4ERR_NOTDIR, NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, |",
      "ja": "| | NFS4ERR_TOO_MANY_OPS | | RENAME | NFS4ERR_ACCESS、NFS4ERR_BADCHAR、| | | NFS4ERR_BADNAME、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_DQUOT、NFS4ERR_EXIST、| | | NFS4ERR_FHEXPIRED、NFS4ERR_FILE_OPEN、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、NFS4ERR_IO、| | | NFS4ERR_MLINK、NFS4ERR_MOVED、| | | NFS4ERR_NAMETOOLONG、NFS4ERR_NOENT、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOSPC、| | | NFS4ERR_NOTDIR、NFS4ERR_NOTEMPTY、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONGSEC、| | | NFS4ERR_XDEV | | RENEW | NFS4ERR_NOTSUPP | | RESTOREFH | NFS4ERR_DEADSESSION、NFS4ERR_FHEXPIRED、| | | NFS4ERR_MOVED、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、NFS4ERR_WRONGSEC | | SAVEFH | NFS4ERR_DEADSESSION、NFS4ERR_FHEXPIRED、| | | NFS4ERR_MOVED、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS | | SECINFO | NFS4ERR_ACCESS、NFS4ERR_BADCHAR、| | | NFS4ERR_BADNAME、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_INVAL、| | | NFS4ERR_MOVED、NFS4ERR_NAMETOOLONG、| | | NFS4ERR_NOENT、NFS4ERR_NOFILEHANDLE、| | | NFS4ERR_NOTDIR、NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS | | SECINFO_NO_NAME | NFS4ERR_ACCESS, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_INVAL, | | | NFS4ERR_MOVED, NFS4ERR_NOENT, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTDIR, | | | NFS4ERR_NOTSUPP, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS | | SEQUENCE | NFS4ERR_BADSESSION, NFS4ERR_BADSLOT, | | | NFS4ERR_BADXDR, NFS4ERR_BAD_HIGH_SLOT, | | | NFS4ERR_CONN_NOT_BOUND_TO_SESSION, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SEQUENCE_POS, | | | NFS4ERR_SEQ_FALSE_RETRY, | | | NFS4ERR_SEQ_MISORDERED, | | | NFS4ERR_TOO_MANY_OPS | | SET_SSV | NFS4ERR_BADXDR, | | | NFS4ERR_BAD_SESSION_DIGEST, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_INVAL, NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_TOO_MANY_OPS | | SETATTR | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, | | | NFS4ERR_ATTRNOTSUPP, NFS4ERR_BADCHAR, | | | NFS4ERR_BADOWNER, NFS4ERR_BADXDR, | | | NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED, | | | NFS4ERR_DQUOT, NFS4ERR_EXPIRED, | | | NFS4ERR_FBIG, NFS4ERR_FHEXPIRED, | | | NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO, | | | NFS4ERR_LOCKED, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC, | | | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE, |",
      "ja": "| | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS | | SECINFO_NO_NAME | NFS4ERR_ACCESS、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_INVAL、| | | NFS4ERR_MOVED、NFS4ERR_NOENT、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTDIR、| | | NFS4ERR_NOTSUPP、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS | | SEQUENCE | NFS4ERR_BADSESSION、NFS4ERR_BADSLOT、| | | NFS4ERR_BADXDR、NFS4ERR_BAD_HIGH_SLOT、| | | NFS4ERR_CONN_NOT_BOUND_TO_SESSION、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SEQUENCE_POS、| | | NFS4ERR_SEQ_FALSE_RETRY、| | | NFS4ERR_SEQ_MISORDERED、| | | NFS4ERR_TOO_MANY_OPS | | SET_SSV | NFS4ERR_BADXDR、| | | NFS4ERR_BAD_SESSION_DIGEST、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_INVAL、NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_TOO_MANY_OPS | | SETATTR | NFS4ERR_ACCESS、NFS4ERR_ADMIN_REVOKED、| | | NFS4ERR_ATTRNOTSUPP、NFS4ERR_BADCHAR、| | | NFS4ERR_BADOWNER、NFS4ERR_BADXDR、| | | NFS4ERR_BAD_STATEID、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_DELEG_REVOKED、| | | NFS4ERR_DQUOT、NFS4ERR_EXPIRED、| | | NFS4ERR_FBIG、NFS4ERR_FHEXPIRED、| | | NFS4ERR_GRACE、NFS4ERR_INVAL、NFS4ERR_IO、| | | NFS4ERR_LOCKED、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOSPC、| | | NFS4ERR_OLD_STATEID、NFS4ERR_OPENMODE、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PERM, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_UNKNOWN_LAYOUTTYPE, | | | NFS4ERR_WRONG_TYPE | | SETCLIENTID | NFS4ERR_NOTSUPP | | SETCLIENTID_CONFIRM | NFS4ERR_NOTSUPP | | TEST_STATEID | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_TOO_MANY_OPS | | VERIFY | NFS4ERR_ACCESS, NFS4ERR_ATTRNOTSUPP, | | | NFS4ERR_BADCHAR, NFS4ERR_BADXDR, | | | NFS4ERR_DEADSESSION, NFS4ERR_DELAY, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOT_SAME, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, NFS4ERR_STALE, | | | NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_UNKNOWN_LAYOUTTYPE, | | | NFS4ERR_WRONG_TYPE | | WANT_DELEGATION | NFS4ERR_BADXDR, NFS4ERR_DEADSESSION, | | | NFS4ERR_DELAY, | | | NFS4ERR_DELEG_ALREADY_WANTED, | | | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, | | | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED, | | | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, | | | NFS4ERR_NO_GRACE, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_RECALLCONFLICT, | | | NFS4ERR_RECLAIM_BAD, | | | NFS4ERR_RECLAIM_CONFLICT, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, |",
      "ja": "| | NFS4ERR_OP_NOT_IN_SESSION、NFS4ERR_PERM、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、NFS4ERR_ROFS、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_UNKNOWN_LAYOUTTYPE、| | | NFS4ERR_WRONG_TYPE | | SETCLIENTID | NFS4ERR_NOTSUPP | | SETCLIENTID_CONFIRM | NFS4ERR_NOTSUPP | | TEST_STATEID | NFS4ERR_BADXDR、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_TOO_MANY_OPS | | VERIFY | NFS4ERR_ACCESS、NFS4ERR_ATTRNOTSUPP、| | | NFS4ERR_BADCHAR、NFS4ERR_BADXDR、| | | NFS4ERR_DEADSESSION、NFS4ERR_DELAY、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOT_SAME、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、NFS4ERR_STALE、| | | NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_UNKNOWN_LAYOUTTYPE、| | | NFS4ERR_WRONG_TYPE | | WANT_DELEGATION | NFS4ERR_BADXDR、NFS4ERR_DEADSESSION、| | | NFS4ERR_DELAY、| | | NFS4ERR_DELEG_ALREADY_WANTED、| | | NFS4ERR_FHEXPIRED、NFS4ERR_GRACE、| | | NFS4ERR_INVAL、NFS4ERR_IO、NFS4ERR_MOVED、| | | NFS4ERR_NOFILEHANDLE、NFS4ERR_NOTSUPP、| | | NFS4ERR_NO_GRACE、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_RECALLCONFLICT、| | | NFS4ERR_RECLAIM_BAD、| | | NFS4ERR_RECLAIM_CONFLICT、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、|"
    },
    {
      "indent": 3,
      "text": "|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |\n|                      | NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE   |\n| WRITE                | NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED,     |\n|                      | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID,       |\n|                      | NFS4ERR_DEADSESSION, NFS4ERR_DELAY,        |\n|                      | NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT,      |\n|                      | NFS4ERR_EXPIRED, NFS4ERR_FBIG,             |\n|                      | NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,          |\n|                      | NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR,  |\n|                      | NFS4ERR_LOCKED, NFS4ERR_MOVED,             |\n|                      | NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,       |\n|                      | NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,     |\n|                      | NFS4ERR_OP_NOT_IN_SESSION,                 |\n|                      | NFS4ERR_PNFS_IO_HOLE,                      |\n|                      | NFS4ERR_PNFS_NO_LAYOUT,                    |\n|                      | NFS4ERR_REP_TOO_BIG,                       |\n|                      | NFS4ERR_REP_TOO_BIG_TO_CACHE,              |\n|                      | NFS4ERR_REQ_TOO_BIG,                       |\n|                      | NFS4ERR_RETRY_UNCACHED_REP, NFS4ERR_ROFS,  |\n|                      | NFS4ERR_SERVERFAULT, NFS4ERR_STALE,        |\n|                      | NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,     |\n|                      | NFS4ERR_WRONG_TYPE                         |\n+----------------------+--------------------------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 6",
      "ja": "表6"
    },
    {
      "indent": 0,
      "text": "15.3. Callback Operations and Their Valid Errors",
      "section_title": true,
      "ja": "15.3. コールバックオペレーションとその有効なエラー"
    },
    {
      "indent": 3,
      "text": "This section contains a table that gives the valid error returns for each callback operation. The error code NFS4_OK (indicating no error) is not listed but should be understood to be returnable by all callback operations with the exception of CB_ILLEGAL.",
      "ja": "このセクションでは、各コールバック操作のための有効なエラーリターンを与えるテーブルが含まれています。 （エラーがないことを示す）エラーコードNFS4_OKが記載されていないが、CB_ILLEGALを除くすべてのコールバックオペレーションによって返却であると理解されるべきです。"
    },
    {
      "indent": 9,
      "text": "Valid Error Returns for Each Protocol Callback Operation",
      "ja": "各プロトコルのコールバック操作のための有効なエラーを返します"
    },
    {
      "indent": 3,
      "text": "+-------------------------+-----------------------------------------+\n| Callback Operation      | Errors                                  |\n+-------------------------+-----------------------------------------+\n| CB_GETATTR              | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR,      |\n|                         | NFS4ERR_DELAY, NFS4ERR_INVAL,           |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,              |\n|                         | NFS4ERR_REP_TOO_BIG,                    |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |\n|                         | NFS4ERR_REQ_TOO_BIG,                    |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,             |\n|                         | NFS4ERR_SERVERFAULT,                    |\n|                         | NFS4ERR_TOO_MANY_OPS,                   |\n| CB_ILLEGAL              | NFS4ERR_BADXDR, NFS4ERR_OP_ILLEGAL      |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| CB_LAYOUTRECALL | NFS4ERR_BADHANDLE, NFS4ERR_BADIOMODE, | | | NFS4ERR_BADXDR, NFS4ERR_BAD_STATEID, | | | NFS4ERR_DELAY, NFS4ERR_INVAL, | | | NFS4ERR_NOMATCHING_LAYOUT, | | | NFS4ERR_NOTSUPP, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_UNKNOWN_LAYOUTTYPE, | | | NFS4ERR_WRONG_TYPE | | CB_NOTIFY | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR, | | | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY, | | | NFS4ERR_INVAL, NFS4ERR_NOTSUPP, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, | | | NFS4ERR_TOO_MANY_OPS | | CB_NOTIFY_DEVICEID | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_INVAL, NFS4ERR_NOTSUPP, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, | | | NFS4ERR_TOO_MANY_OPS | | CB_NOTIFY_LOCK | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR, | | | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY, | | | NFS4ERR_NOTSUPP, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, | | | NFS4ERR_TOO_MANY_OPS | | CB_PUSH_DELEG | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR, | | | NFS4ERR_DELAY, NFS4ERR_INVAL, | | | NFS4ERR_NOTSUPP, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REJECT_DELEG, | | | NFS4ERR_REP_TOO_BIG, |",
      "ja": "| CB_LAYOUTRECALL | NFS4ERR_BADHANDLE、NFS4ERR_BADIOMODE、| | | NFS4ERR_BADXDR、NFS4ERR_BAD_STATEID、| | | NFS4ERR_DELAY、NFS4ERR_INVAL、| | | NFS4ERR_NOMATCHING_LAYOUT、| | | NFS4ERR_NOTSUPP、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_UNKNOWN_LAYOUTTYPE、| | | NFS4ERR_WRONG_TYPE | | CB_NOTIFY | NFS4ERR_BADHANDLE、NFS4ERR_BADXDR、| | | NFS4ERR_BAD_STATEID、NFS4ERR_DELAY、| | | NFS4ERR_INVAL、NFS4ERR_NOTSUPP、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、| | | NFS4ERR_TOO_MANY_OPS | | CB_NOTIFY_DEVICEID | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_INVAL、NFS4ERR_NOTSUPP、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、| | | NFS4ERR_TOO_MANY_OPS | | CB_NOTIFY_LOCK | NFS4ERR_BADHANDLE、NFS4ERR_BADXDR、| | | NFS4ERR_BAD_STATEID、NFS4ERR_DELAY、| | | NFS4ERR_NOTSUPP、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、| | | NFS4ERR_TOO_MANY_OPS | | CB_PUSH_DELEG | NFS4ERR_BADHANDLE、NFS4ERR_BADXDR、| | | NFS4ERR_DELAY、NFS4ERR_INVAL、| | | NFS4ERR_NOTSUPP、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REJECT_DELEG、| | | NFS4ERR_REP_TOO_BIG、|"
    },
    {
      "indent": 3,
      "text": "| | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, | | | NFS4ERR_TOO_MANY_OPS, | | | NFS4ERR_WRONG_TYPE | | CB_RECALL | NFS4ERR_BADHANDLE, NFS4ERR_BADXDR, | | | NFS4ERR_BAD_STATEID, NFS4ERR_DELAY, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, | | | NFS4ERR_TOO_MANY_OPS | | CB_RECALL_ANY | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_INVAL, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_TOO_MANY_OPS | | CB_RECALLABLE_OBJ_AVAIL | NFS4ERR_BADXDR, NFS4ERR_DELAY, | | | NFS4ERR_INVAL, NFS4ERR_NOTSUPP, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SERVERFAULT, | | | NFS4ERR_TOO_MANY_OPS | | CB_RECALL_SLOT | NFS4ERR_BADXDR, NFS4ERR_BAD_HIGH_SLOT, | | | NFS4ERR_DELAY, | | | NFS4ERR_OP_NOT_IN_SESSION, | | | NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_TOO_MANY_OPS | | CB_SEQUENCE | NFS4ERR_BADSESSION, NFS4ERR_BADSLOT, | | | NFS4ERR_BADXDR, NFS4ERR_BAD_HIGH_SLOT, | | | NFS4ERR_CONN_NOT_BOUND_TO_SESSION, | | | NFS4ERR_DELAY, NFS4ERR_REP_TOO_BIG, | | | NFS4ERR_REP_TOO_BIG_TO_CACHE, | | | NFS4ERR_REQ_TOO_BIG, | | | NFS4ERR_RETRY_UNCACHED_REP, | | | NFS4ERR_SEQUENCE_POS, |",
      "ja": "| | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、| | | NFS4ERR_TOO_MANY_OPS、| | | NFS4ERR_WRONG_TYPE | | CB_RECALL | NFS4ERR_BADHANDLE、NFS4ERR_BADXDR、| | | NFS4ERR_BAD_STATEID、NFS4ERR_DELAY、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、| | | NFS4ERR_TOO_MANY_OPS | | CB_RECALL_ANY | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_INVAL、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_TOO_MANY_OPS | | CB_RECALLABLE_OBJ_AVAIL | NFS4ERR_BADXDR、NFS4ERR_DELAY、| | | NFS4ERR_INVAL、NFS4ERR_NOTSUPP、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SERVERFAULT、| | | NFS4ERR_TOO_MANY_OPS | | CB_RECALL_SLOT | NFS4ERR_BADXDR、NFS4ERR_BAD_HIGH_SLOT、| | | NFS4ERR_DELAY、| | | NFS4ERR_OP_NOT_IN_SESSION、| | | NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_TOO_MANY_OPS | | CB_SEQUENCE | NFS4ERR_BADSESSION、NFS4ERR_BADSLOT、| | | NFS4ERR_BADXDR、NFS4ERR_BAD_HIGH_SLOT、| | | NFS4ERR_CONN_NOT_BOUND_TO_SESSION、| | | NFS4ERR_DELAY、NFS4ERR_REP_TOO_BIG、| | | NFS4ERR_REP_TOO_BIG_TO_CACHE、| | | NFS4ERR_REQ_TOO_BIG、| | | NFS4ERR_RETRY_UNCACHED_REP、| | | NFS4ERR_SEQUENCE_POS、|"
    },
    {
      "indent": 3,
      "text": "|                         | NFS4ERR_SEQ_FALSE_RETRY,                |\n|                         | NFS4ERR_SEQ_MISORDERED,                 |\n|                         | NFS4ERR_TOO_MANY_OPS                    |\n| CB_WANTS_CANCELLED      | NFS4ERR_BADXDR, NFS4ERR_DELAY,          |\n|                         | NFS4ERR_NOTSUPP,                        |\n|                         | NFS4ERR_OP_NOT_IN_SESSION,              |\n|                         | NFS4ERR_REP_TOO_BIG,                    |\n|                         | NFS4ERR_REP_TOO_BIG_TO_CACHE,           |\n|                         | NFS4ERR_REQ_TOO_BIG,                    |\n|                         | NFS4ERR_RETRY_UNCACHED_REP,             |\n|                         | NFS4ERR_SERVERFAULT,                    |\n|                         | NFS4ERR_TOO_MANY_OPS                    |\n+-------------------------+-----------------------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 7",
      "ja": "表7"
    },
    {
      "indent": 0,
      "text": "15.4. Errors and the Operations That Use Them",
      "section_title": true,
      "ja": "15.4. エラーおよびそれらを使用する操作"
    },
    {
      "indent": 3,
      "text": "+-----------------------------------+-------------------------------+\n| Error                             | Operations                    |\n+-----------------------------------+-------------------------------+\n| NFS4ERR_ACCESS                    | ACCESS, COMMIT, CREATE,       |\n|                                   | GETATTR, GET_DIR_DELEGATION,  |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LINK, LOCK, LOCKT, LOCKU,     |\n|                                   | LOOKUP, LOOKUPP, NVERIFY,     |\n|                                   | OPEN, OPENATTR, READ,         |\n|                                   | READDIR, READLINK, REMOVE,    |\n|                                   | RENAME, SECINFO,              |\n|                                   | SECINFO_NO_NAME, SETATTR,     |\n|                                   | VERIFY, WRITE                 |\n| NFS4ERR_ADMIN_REVOKED             | CLOSE, DELEGRETURN,           |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, LOCK, LOCKU,    |\n|                                   | OPEN, OPEN_DOWNGRADE, READ,   |\n|                                   | SETATTR, WRITE                |\n| NFS4ERR_ATTRNOTSUPP               | CREATE, LAYOUTCOMMIT,         |\n|                                   | NVERIFY, OPEN, SETATTR,       |\n|                                   | VERIFY                        |\n| NFS4ERR_BACK_CHAN_BUSY            | DESTROY_SESSION               |\n| NFS4ERR_BADCHAR                   | CREATE, EXCHANGE_ID, LINK,    |\n|                                   | LOOKUP, NVERIFY, OPEN,        |\n|                                   | REMOVE, RENAME, SECINFO,      |\n|                                   | SETATTR, VERIFY               |\n| NFS4ERR_BADHANDLE                 | CB_GETATTR, CB_LAYOUTRECALL,  |\n|                                   | CB_NOTIFY, CB_NOTIFY_LOCK,    |\n|                                   | CB_PUSH_DELEG, CB_RECALL,     |\n|                                   | PUTFH                         |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| NFS4ERR_BADIOMODE | CB_LAYOUTRECALL, | | | LAYOUTCOMMIT, LAYOUTGET | | NFS4ERR_BADLAYOUT | LAYOUTCOMMIT, LAYOUTGET | | NFS4ERR_BADNAME | CREATE, LINK, LOOKUP, OPEN, | | | REMOVE, RENAME, SECINFO | | NFS4ERR_BADOWNER | CREATE, OPEN, SETATTR | | NFS4ERR_BADSESSION | BIND_CONN_TO_SESSION, | | | CB_SEQUENCE, DESTROY_SESSION, | | | SEQUENCE | | NFS4ERR_BADSLOT | CB_SEQUENCE, SEQUENCE | | NFS4ERR_BADTYPE | CREATE | | NFS4ERR_BADXDR | ACCESS, BACKCHANNEL_CTL, | | | BIND_CONN_TO_SESSION, | | | CB_GETATTR, CB_ILLEGAL, | | | CB_LAYOUTRECALL, CB_NOTIFY, | | | CB_NOTIFY_DEVICEID, | | | CB_NOTIFY_LOCK, | | | CB_PUSH_DELEG, CB_RECALL, | | | CB_RECALLABLE_OBJ_AVAIL, | | | CB_RECALL_ANY, | | | CB_RECALL_SLOT, CB_SEQUENCE, | | | CB_WANTS_CANCELLED, CLOSE, | | | COMMIT, CREATE, | | | CREATE_SESSION, DELEGPURGE, | | | DELEGRETURN, | | | DESTROY_CLIENTID, | | | DESTROY_SESSION, EXCHANGE_ID, | | | FREE_STATEID, GETATTR, | | | GETDEVICEINFO, GETDEVICELIST, | | | GET_DIR_DELEGATION, ILLEGAL, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | NVERIFY, OPEN, OPENATTR, | | | OPEN_DOWNGRADE, PUTFH, READ, | | | READDIR, RECLAIM_COMPLETE, | | | REMOVE, RENAME, SECINFO, | | | SECINFO_NO_NAME, SEQUENCE, | | | SETATTR, SET_SSV, | | | TEST_STATEID, VERIFY, | | | WANT_DELEGATION, WRITE | | NFS4ERR_BAD_COOKIE | GETDEVICELIST, READDIR | | NFS4ERR_BAD_HIGH_SLOT | CB_RECALL_SLOT, CB_SEQUENCE, | | | SEQUENCE | | NFS4ERR_BAD_RANGE | LOCK, LOCKT, LOCKU | | NFS4ERR_BAD_SESSION_DIGEST | BIND_CONN_TO_SESSION, SET_SSV | | NFS4ERR_BAD_STATEID | CB_LAYOUTRECALL, CB_NOTIFY, | | | CB_NOTIFY_LOCK, CB_RECALL, |",
      "ja": "| NFS4ERR_BADIOMODE | CB_LAYOUTRECALL、| | | LAYOUTCOMMIT、LAYOUTGET | | NFS4ERR_BADLAYOUT | LAYOUTCOMMIT、LAYOUTGET | | NFS4ERR_BADNAME | CREATE、LINK、LOOKUP、OPEN、| | | REMOVE、RENAME、SECINFO | | NFS4ERR_BADOWNER | CREATE、OPEN、SETATTR | | NFS4ERR_BADSESSION | BIND_CONN_TO_SESSION、| | | CB_SEQUENCE、DESTROY_SESSION、| | | SEQUENCE | | NFS4ERR_BADSLOT | CB_SEQUENCE、SEQUENCE | | NFS4ERR_BADTYPE | CREATE | | NFS4ERR_BADXDR | ACCESS、BACKCHANNEL_CTL、| | | BIND_CONN_TO_SESSION、| | | CB_GETATTR、CB_ILLEGAL、| | | CB_LAYOUTRECALL、CB_NOTIFY、| | | CB_NOTIFY_DEVICEID、| | | CB_NOTIFY_LOCK、| | | CB_PUSH_DELEG、CB_RECALL、| | | CB_RECALLABLE_OBJ_AVAIL、| | | CB_RECALL_ANY、| | | CB_RECALL_SLOT、CB_SEQUENCE、| | | CB_WANTS_CANCELLED、CLOSE、| | | COMMIT、CREATE、| | | CREATE_SESSION、DELEGPURGE、| | | DELEGRETURN、| | | DESTROY_CLIENTID、| | | DESTROY_SESSION、EXCHANGE_ID、| | | FREE_STATEID、GETATTR、| | | GETDEVICEINFO、GETDEVICELIST、| | | GET_DIR_DELEGATION、ILLEGAL、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | NVERIFY、OPEN、OPENATTR、| | | OPEN_DOWNGRADE、PUTFH、READ、| | | READDIR、RECLAIM_COMPLETE、| | | REMOVE、RENAME、SECINFO、| | | SECINFO_NO_NAME、SEQUENCE、| | | SETATTR、SET_SSV、| | | TEST_STATEID、確認し| | | WANT_DELEGATION、WRITE | | NFS4ERR_BAD_COOKIE | GETDEVICELIST、READDIR | | NFS4ERR_BAD_HIGH_SLOT | CB_RECALL_SLOT、CB_SEQUENCE、| | | SEQUENCE | | NFS4ERR_BAD_RANGE | LOCK、LOCKT、LOCKU | | NFS4ERR_BAD_SESSION_DIGEST | BIND_CONN_TO_SESSION、SET_SSV | | NFS4ERR_BAD_STATEID | CB_LAYOUTRECALL、CB_NOTIFY、| | | CB_NOTIFY_LOCK、CB_RECALL、|"
    },
    {
      "indent": 3,
      "text": "| | CLOSE, DELEGRETURN, | | | FREE_STATEID, LAYOUTGET, | | | LAYOUTRETURN, LOCK, LOCKU, | | | OPEN, OPEN_DOWNGRADE, READ, | | | SETATTR, WRITE | | NFS4ERR_CB_PATH_DOWN | DESTROY_SESSION | | NFS4ERR_CLID_INUSE | CREATE_SESSION, EXCHANGE_ID | | NFS4ERR_CLIENTID_BUSY | DESTROY_CLIENTID | | NFS4ERR_COMPLETE_ALREADY | RECLAIM_COMPLETE | | NFS4ERR_CONN_NOT_BOUND_TO_SESSION | CB_SEQUENCE, DESTROY_SESSION, | | | SEQUENCE | | NFS4ERR_DEADLOCK | LOCK | | NFS4ERR_DEADSESSION | ACCESS, BACKCHANNEL_CTL, | | | BIND_CONN_TO_SESSION, CLOSE, | | | COMMIT, CREATE, | | | CREATE_SESSION, DELEGPURGE, | | | DELEGRETURN, | | | DESTROY_CLIENTID, | | | DESTROY_SESSION, EXCHANGE_ID, | | | FREE_STATEID, GETATTR, | | | GETDEVICEINFO, GETDEVICELIST, | | | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, OPEN_DOWNGRADE, | | | PUTFH, PUTPUBFH, PUTROOTFH, | | | READ, READDIR, READLINK, | | | RECLAIM_COMPLETE, REMOVE, | | | RENAME, RESTOREFH, SAVEFH, | | | SECINFO, SECINFO_NO_NAME, | | | SEQUENCE, SETATTR, SET_SSV, | | | TEST_STATEID, VERIFY, | | | WANT_DELEGATION, WRITE | | NFS4ERR_DELAY | ACCESS, BACKCHANNEL_CTL, | | | BIND_CONN_TO_SESSION, | | | CB_GETATTR, CB_LAYOUTRECALL, | | | CB_NOTIFY, | | | CB_NOTIFY_DEVICEID, | | | CB_NOTIFY_LOCK, | | | CB_PUSH_DELEG, CB_RECALL, | | | CB_RECALLABLE_OBJ_AVAIL, | | | CB_RECALL_ANY, | | | CB_RECALL_SLOT, CB_SEQUENCE, | | | CB_WANTS_CANCELLED, CLOSE, | | | COMMIT, CREATE, | | | CREATE_SESSION, DELEGPURGE, |",
      "ja": "| | CLOSE、DELEGRETURN、| | | FREE_STATEID、LAYOUTGET、| | | LAYOUTRETURN、LOCK、LOCKU、| | | OPEN、OPEN_DOWNGRADE、READ、| | | SETATTR、WRITE | | NFS4ERR_CB_PATH_DOWN | DESTROY_SESSION | | NFS4ERR_CLID_INUSE | CREATE_SESSION、EXCHANGE_ID | | NFS4ERR_CLIENTID_BUSY | DESTROY_CLIENTID | | NFS4ERR_COMPLETE_ALREADY | RECLAIM_COMPLETE | | NFS4ERR_CONN_NOT_BOUND_TO_SESSION | CB_SEQUENCE、DESTROY_SESSION、| | | SEQUENCE | | NFS4ERR_DEADLOCK | LOCK | | NFS4ERR_DEADSESSION | ACCESS、BACKCHANNEL_CTL、| | | BIND_CONN_TO_SESSION、CLOSE、| | | COMMIT、CREATE、| | | CREATE_SESSION、DELEGPURGE、| | | DELEGRETURN、| | | DESTROY_CLIENTID、| | | DESTROY_SESSION、EXCHANGE_ID、| | | FREE_STATEID、GETATTR、| | | GETDEVICEINFO、GETDEVICELIST、| | | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、OPEN_DOWNGRADE、| | | PUTFH、PUTPUBFH、PUTROOTFH、| | | READ、READDIR、READLINK、| | | RECLAIM_COMPLETE、削除| | | | RESTOREFH、SAVEFH、RENAME | | SECINFO、SECINFO_NO_NAME、| | | SEQUENCE、SETATTR、SET_SSV、| | | TEST_STATEID、確認し| | | WANT_DELEGATION、WRITE | | NFS4ERR_DELAY | ACCESS、BACKCHANNEL_CTL、| | | BIND_CONN_TO_SESSION、| | | CB_GETATTR、CB_LAYOUTRECALL、| | | CB_NOTIFY、| | | CB_NOTIFY_DEVICEID、| | | CB_NOTIFY_LOCK、| | | CB_PUSH_DELEG、CB_RECALL、| | | CB_RECALLABLE_OBJ_AVAIL、| | | CB_RECALL_ANY、| | | CB_RECALL_SLOT、CB_SEQUENCE、| | | CB_WANTS_CANCELLED、CLOSE、| | | COMMIT、CREATE、| | | CREATE_SESSION、DELEGPURGE、|"
    },
    {
      "indent": 3,
      "text": "| | DELEGRETURN, | | | DESTROY_CLIENTID, | | | DESTROY_SESSION, EXCHANGE_ID, | | | FREE_STATEID, GETATTR, | | | GETDEVICEINFO, GETDEVICELIST, | | | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, OPEN_DOWNGRADE, | | | PUTFH, PUTPUBFH, PUTROOTFH, | | | READ, READDIR, READLINK, | | | RECLAIM_COMPLETE, REMOVE, | | | RENAME, SECINFO, | | | SECINFO_NO_NAME, SEQUENCE, | | | SETATTR, SET_SSV, | | | TEST_STATEID, VERIFY, | | | WANT_DELEGATION, WRITE | | NFS4ERR_DELEG_ALREADY_WANTED | OPEN, WANT_DELEGATION | | NFS4ERR_DELEG_REVOKED | DELEGRETURN, LAYOUTCOMMIT, | | | LAYOUTGET, LAYOUTRETURN, | | | OPEN, READ, SETATTR, WRITE | | NFS4ERR_DENIED | LOCK, LOCKT | | NFS4ERR_DIRDELEG_UNAVAIL | GET_DIR_DELEGATION | | NFS4ERR_DQUOT | CREATE, LAYOUTGET, LINK, | | | OPEN, OPENATTR, RENAME, | | | SETATTR, WRITE | | NFS4ERR_ENCR_ALG_UNSUPP | EXCHANGE_ID | | NFS4ERR_EXIST | CREATE, LINK, OPEN, RENAME | | NFS4ERR_EXPIRED | CLOSE, DELEGRETURN, | | | LAYOUTCOMMIT, LAYOUTRETURN, | | | LOCK, LOCKU, OPEN, | | | OPEN_DOWNGRADE, READ, | | | SETATTR, WRITE | | NFS4ERR_FBIG | LAYOUTCOMMIT, OPEN, SETATTR, | | | WRITE | | NFS4ERR_FHEXPIRED | ACCESS, CLOSE, COMMIT, | | | CREATE, DELEGRETURN, GETATTR, | | | GETDEVICELIST, GETFH, | | | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, OPEN_DOWNGRADE, | | | READ, READDIR, READLINK, | | | RECLAIM_COMPLETE, REMOVE, |",
      "ja": "| | DELEGRETURN、| | | DESTROY_CLIENTID、| | | DESTROY_SESSION、EXCHANGE_ID、| | | FREE_STATEID、GETATTR、| | | GETDEVICEINFO、GETDEVICELIST、| | | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、OPEN_DOWNGRADE、| | | PUTFH、PUTPUBFH、PUTROOTFH、| | | READ、READDIR、READLINK、| | | RECLAIM_COMPLETE、削除| | | RENAME、SECINFO、| | | SECINFO_NO_NAME、SEQUENCE、| | | SETATTR、SET_SSV、| | | TEST_STATEID、確認し| | | WANT_DELEGATION、WRITE | | NFS4ERR_DELEG_ALREADY_WANTED | OPEN、WANT_DELEGATION | | NFS4ERR_DELEG_REVOKED | DELEGRETURN、LAYOUTCOMMIT、| | | LAYOUTGET、LAYOUTRETURN、| | | OPEN、READ、SETATTR、WRITE | | NFS4ERR_DENIED | LOCK、LOCKT | | NFS4ERR_DIRDELEG_UNAVAIL | GET_DIR_DELEGATION | | NFS4ERR_DQUOT | CREATE、LAYOUTGET、LINK、| | | OPEN、OPENATTR、RENAME、| | | SETATTR、WRITE | | NFS4ERR_ENCR_ALG_UNSUPP | EXCHANGE_ID | | NFS4ERR_EXIST | LINK、OPENは、RENAME、CREATE | | NFS4ERR_EXPIRED | CLOSE、DELEGRETURN、| | | LAYOUTCOMMIT、LAYOUTRETURN、| | | LOCK、LOCKU、OPEN、| | | OPEN_DOWNGRADE、READ、| | | SETATTR、WRITE | | NFS4ERR_FBIG | LAYOUTCOMMIT、OPEN、SETATTR、| | | WRITE | | NFS4ERR_FHEXPIRED | ACCESS、CLOSE、COMMIT、| | | | DELEGRETURN、GETATTR、CREATE | | GETDEVICELIST、GETFH、| | | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、OPEN_DOWNGRADE、| | | READ、READDIR、READLINK、| | | RECLAIM_COMPLETE、削除|"
    },
    {
      "indent": 3,
      "text": "| | RENAME, RESTOREFH, SAVEFH, | | | SECINFO, SECINFO_NO_NAME, | | | SETATTR, VERIFY, | | | WANT_DELEGATION, WRITE | | NFS4ERR_FILE_OPEN | LINK, REMOVE, RENAME | | NFS4ERR_GRACE | GETATTR, GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, NVERIFY, OPEN, READ, | | | REMOVE, RENAME, SETATTR, | | | VERIFY, WANT_DELEGATION, | | | WRITE | | NFS4ERR_HASH_ALG_UNSUPP | EXCHANGE_ID | | NFS4ERR_INVAL | ACCESS, BACKCHANNEL_CTL, | | | BIND_CONN_TO_SESSION, | | | CB_GETATTR, CB_LAYOUTRECALL, | | | CB_NOTIFY, | | | CB_NOTIFY_DEVICEID, | | | CB_PUSH_DELEG, | | | CB_RECALLABLE_OBJ_AVAIL, | | | CB_RECALL_ANY, CREATE, | | | CREATE_SESSION, DELEGRETURN, | | | EXCHANGE_ID, GETATTR, | | | GETDEVICEINFO, GETDEVICELIST, | | | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | NVERIFY, OPEN, | | | OPEN_DOWNGRADE, READ, | | | READDIR, READLINK, | | | RECLAIM_COMPLETE, REMOVE, | | | RENAME, SECINFO, | | | SECINFO_NO_NAME, SETATTR, | | | SET_SSV, VERIFY, | | | WANT_DELEGATION, WRITE | | NFS4ERR_IO | ACCESS, COMMIT, CREATE, | | | GETATTR, GETDEVICELIST, | | | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LINK, LOOKUP, LOOKUPP, | | | NVERIFY, OPEN, OPENATTR, | | | READ, READDIR, READLINK, | | | REMOVE, RENAME, SETATTR, | | | VERIFY, WANT_DELEGATION, | | | WRITE | | NFS4ERR_ISDIR | COMMIT, LAYOUTCOMMIT, | | | LAYOUTRETURN, LINK, LOCK, |",
      "ja": "| | | RESTOREFH、SAVEFH、RENAME | | SECINFO、SECINFO_NO_NAME、| | | | SETATTRは、VERIFY | | WANT_DELEGATION、WRITE | | NFS4ERR_FILE_OPEN | LINK、REMOVE、名前の変更| | NFS4ERR_GRACE | GETATTR、GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、NVERIFY、OPEN、READ、| | | REMOVE、RENAME、SETATTR、| | | |、、WANT_DELEGATIONを確認| | WRITE | | NFS4ERR_HASH_ALG_UNSUPP | EXCHANGE_ID | | NFS4ERR_INVAL | ACCESS、BACKCHANNEL_CTL、| | | BIND_CONN_TO_SESSION、| | | CB_GETATTR、CB_LAYOUTRECALL、| | | CB_NOTIFY、| | | CB_NOTIFY_DEVICEID、| | | CB_PUSH_DELEG、| | | CB_RECALLABLE_OBJ_AVAIL、| | | | CB_RECALL_ANYは、CREATE | | CREATE_SESSION、DELEGRETURN、| | | EXCHANGE_ID、GETATTR、| | | GETDEVICEINFO、GETDEVICELIST、| | | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | NVERIFY、OPEN、| | | OPEN_DOWNGRADE、READ、| | | READDIR、READLINK、| | | RECLAIM_COMPLETE、削除| | | RENAME、SECINFO、| | | SECINFO_NO_NAME、SETATTR、| | | SET_SSV、確認し| | | WANT_DELEGATION、WRITE | | NFS4ERR_IO | | ACCESSは、COMMIT、CREATE | | GETATTR、GETDEVICELIST、| | | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LINK、LOOKUP、LOOKUPP、| | | NVERIFY、OPEN、OPENATTR、| | | READ、READDIR、READLINK、| | | REMOVE、RENAME、SETATTR、| | | |、、WANT_DELEGATIONを確認| | WRITE | | NFS4ERR_ISDIR | COMMIT、LAYOUTCOMMIT、| | | LAYOUTRETURN、LINK、LOCK、|"
    },
    {
      "indent": 3,
      "text": "| | LOCKT, OPEN, READ, WRITE | | NFS4ERR_LAYOUTTRYLATER | LAYOUTGET | | NFS4ERR_LAYOUTUNAVAILABLE | LAYOUTGET | | NFS4ERR_LOCKED | LAYOUTGET, READ, SETATTR, | | | WRITE | | NFS4ERR_LOCKS_HELD | CLOSE, FREE_STATEID | | NFS4ERR_LOCK_NOTSUPP | LOCK | | NFS4ERR_LOCK_RANGE | LOCK, LOCKT, LOCKU | | NFS4ERR_MLINK | CREATE, LINK, RENAME | | NFS4ERR_MOVED | ACCESS, CLOSE, COMMIT, | | | CREATE, DELEGRETURN, GETATTR, | | | GETFH, GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, OPEN_DOWNGRADE, | | | PUTFH, READ, READDIR, | | | READLINK, RECLAIM_COMPLETE, | | | REMOVE, RENAME, RESTOREFH, | | | SAVEFH, SECINFO, | | | SECINFO_NO_NAME, SETATTR, | | | VERIFY, WANT_DELEGATION, | | | WRITE | | NFS4ERR_NAMETOOLONG | CREATE, LINK, LOOKUP, OPEN, | | | REMOVE, RENAME, SECINFO | | NFS4ERR_NOENT | BACKCHANNEL_CTL, | | | CREATE_SESSION, EXCHANGE_ID, | | | GETDEVICEINFO, LOOKUP, | | | LOOKUPP, OPEN, OPENATTR, | | | REMOVE, RENAME, SECINFO, | | | SECINFO_NO_NAME | | NFS4ERR_NOFILEHANDLE | ACCESS, CLOSE, COMMIT, | | | CREATE, DELEGRETURN, GETATTR, | | | GETDEVICELIST, GETFH, | | | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, OPEN_DOWNGRADE, | | | READ, READDIR, READLINK, | | | RECLAIM_COMPLETE, REMOVE, | | | RENAME, RESTOREFH, SAVEFH, | | | SECINFO, SECINFO_NO_NAME, | | | SETATTR, VERIFY, | | | WANT_DELEGATION, WRITE | | NFS4ERR_NOMATCHING_LAYOUT | CB_LAYOUTRECALL |",
      "ja": "| | LOCKT、OPEN、READ、WRITE | | NFS4ERR_LAYOUTTRYLATER | LAYOUTGET | | NFS4ERR_LAYOUTUNAVAILABLE | LAYOUTGET | | NFS4ERR_LOCKED | LAYOUTGET、READ、SETATTR、| | | WRITE | | NFS4ERR_LOCKS_HELD | CLOSE、FREE_STATEID | | NFS4ERR_LOCK_NOTSUPP | LOCK | | NFS4ERR_LOCK_RANGE | LOCK、LOCKT、LOCKU | | NFS4ERR_MLINK | CREATE、LINK、RENAME | | NFS4ERR_MOVED | ACCESS、CLOSE、COMMIT、| | | | DELEGRETURN、GETATTR、CREATE | | GETFH、GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、OPEN_DOWNGRADE、| | | PUTFH、READ、READDIR、| | | READLINK、RECLAIM_COMPLETE、| | | REMOVE、RENAME、RESTOREFH、| | | SAVEFH、SECINFO、| | | SECINFO_NO_NAME、SETATTR、| | | |、、WANT_DELEGATIONを確認| | WRITE | | NFS4ERR_NAMETOOLONG | CREATE、LINK、LOOKUP、OPEN、| | | REMOVE、RENAME、SECINFO | | NFS4ERR_NOENT | BACKCHANNEL_CTL、| | | CREATE_SESSION、EXCHANGE_ID、| | | GETDEVICEINFO、LOOKUP、| | | LOOKUPP、OPEN、OPENATTR、| | | REMOVE、RENAME、SECINFO、| | | SECINFO_NO_NAME | | NFS4ERR_NOFILEHANDLE | ACCESS、CLOSE、COMMIT、| | | | DELEGRETURN、GETATTR、CREATE | | GETDEVICELIST、GETFH、| | | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、OPEN_DOWNGRADE、| | | READ、READDIR、READLINK、| | | RECLAIM_COMPLETE、削除| | | | RESTOREFH、SAVEFH、RENAME | | SECINFO、SECINFO_NO_NAME、| | | | SETATTRは、VERIFY | | WANT_DELEGATION、WRITE | | NFS4ERR_NOMATCHING_LAYOUT | CB_LAYOUTRECALL |"
    },
    {
      "indent": 3,
      "text": "| NFS4ERR_NOSPC | CREATE, CREATE_SESSION, | | | LAYOUTGET, LINK, OPEN, | | | OPENATTR, RENAME, SETATTR, | | | WRITE | | NFS4ERR_NOTDIR | CREATE, GET_DIR_DELEGATION, | | | LINK, LOOKUP, LOOKUPP, OPEN, | | | READDIR, REMOVE, RENAME, | | | SECINFO, SECINFO_NO_NAME | | NFS4ERR_NOTEMPTY | REMOVE, RENAME | | NFS4ERR_NOTSUPP | CB_LAYOUTRECALL, CB_NOTIFY, | | | CB_NOTIFY_DEVICEID, | | | CB_NOTIFY_LOCK, | | | CB_PUSH_DELEG, | | | CB_RECALLABLE_OBJ_AVAIL, | | | CB_WANTS_CANCELLED, | | | DELEGPURGE, DELEGRETURN, | | | GETDEVICEINFO, GETDEVICELIST, | | | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, OPENATTR, | | | OPEN_CONFIRM, | | | RELEASE_LOCKOWNER, RENEW, | | | SECINFO_NO_NAME, SETCLIENTID, | | | SETCLIENTID_CONFIRM, | | | WANT_DELEGATION | | NFS4ERR_NOT_ONLY_OP | BIND_CONN_TO_SESSION, | | | CREATE_SESSION, | | | DESTROY_CLIENTID, | | | DESTROY_SESSION, EXCHANGE_ID | | NFS4ERR_NOT_SAME | EXCHANGE_ID, GETDEVICELIST, | | | READDIR, VERIFY | | NFS4ERR_NO_GRACE | LAYOUTCOMMIT, LAYOUTRETURN, | | | LOCK, OPEN, WANT_DELEGATION | | NFS4ERR_OLD_STATEID | CLOSE, DELEGRETURN, | | | FREE_STATEID, LAYOUTGET, | | | LAYOUTRETURN, LOCK, LOCKU, | | | OPEN, OPEN_DOWNGRADE, READ, | | | SETATTR, WRITE | | NFS4ERR_OPENMODE | LAYOUTGET, LOCK, READ, | | | SETATTR, WRITE | | NFS4ERR_OP_ILLEGAL | CB_ILLEGAL, ILLEGAL | | NFS4ERR_OP_NOT_IN_SESSION | ACCESS, BACKCHANNEL_CTL, | | | CB_GETATTR, CB_LAYOUTRECALL, | | | CB_NOTIFY, | | | CB_NOTIFY_DEVICEID, | | | CB_NOTIFY_LOCK, | | | CB_PUSH_DELEG, CB_RECALL, | | | CB_RECALLABLE_OBJ_AVAIL, |",
      "ja": "| NFS4ERR_NOSPC | CREATE、CREATE_SESSION、| | | LAYOUTGET、LINK、OPEN、| | | OPENATTR、RENAME、SETATTR、| | | WRITE | | NFS4ERR_NOTDIR | 、GET_DIR_DELEGATIONをCREATE、| | | LINK、LOOKUP、LOOKUPP、OPEN、| | | READDIR、REMOVE、RENAME、| | | SECINFO、SECINFO_NO_NAME | | NFS4ERR_NOTEMPTY | REMOVE、RENAME | | NFS4ERR_NOTSUPP | CB_LAYOUTRECALL、CB_NOTIFY、| | | CB_NOTIFY_DEVICEID、| | | CB_NOTIFY_LOCK、| | | CB_PUSH_DELEG、| | | CB_RECALLABLE_OBJ_AVAIL、| | | CB_WANTS_CANCELLED、| | | DELEGPURGE、DELEGRETURN、| | | GETDEVICEINFO、GETDEVICELIST、| | | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、OPENATTR、| | |オープン_CONFIRM、| | | RELEASE_LOCKOWNER、RENEW、| | | SECINFO_NO_NAME、SETCLIENTID、| | | SETCLIENTID_CONFIRM、| | | WANT_DELEGATION | | NFS4ERR_NOT_ONLY_OP | BIND_CONN_TO_SESSION、| | | CREATE_SESSION、| | | DESTROY_CLIENTID、| | | DESTROY_SESSION、EXCHANGE_ID | | NFS4ERR_NOT_SAME | EXCHANGE_ID、GETDEVICELIST、| | | READDIR、VERIFY | | NFS4ERR_NO_GRACE | LAYOUTCOMMIT、LAYOUTRETURN、| | | LOCK、OPEN、WANT_DELEGATION | | NFS4ERR_OLD_STATEID | CLOSE、DELEGRETURN、| | | FREE_STATEID、LAYOUTGET、| | | LAYOUTRETURN、LOCK、LOCKU、| | | OPEN、OPEN_DOWNGRADE、READ、| | | SETATTR、WRITE | | NFS4ERR_OPENMODE | LAYOUTGET、LOCK、READ、| | | SETATTR、WRITE | | NFS4ERR_OP_ILLEGAL | CB_ILLEGAL、ILLEGAL | | NFS4ERR_OP_NOT_IN_SESSION | ACCESS、BACKCHANNEL_CTL、| | | CB_GETATTR、CB_LAYOUTRECALL、| | | CB_NOTIFY、| | | CB_NOTIFY_DEVICEID、| | | CB_NOTIFY_LOCK、| | | CB_PUSH_DELEG、CB_RECALL、| | | CB_RECALLABLE_OBJ_AVAIL、|"
    },
    {
      "indent": 3,
      "text": "| | CB_RECALL_ANY, | | | CB_RECALL_SLOT, | | | CB_WANTS_CANCELLED, CLOSE, | | | COMMIT, CREATE, DELEGPURGE, | | | DELEGRETURN, FREE_STATEID, | | | GETATTR, GETDEVICEINFO, | | | GETDEVICELIST, GETFH, | | | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, OPEN_DOWNGRADE, | | | PUTFH, PUTPUBFH, PUTROOTFH, | | | READ, READDIR, READLINK, | | | RECLAIM_COMPLETE, REMOVE, | | | RENAME, RESTOREFH, SAVEFH, | | | SECINFO, SECINFO_NO_NAME, | | | SETATTR, SET_SSV, | | | TEST_STATEID, VERIFY, | | | WANT_DELEGATION, WRITE | | NFS4ERR_PERM | CREATE, OPEN, SETATTR | | NFS4ERR_PNFS_IO_HOLE | READ, WRITE | | NFS4ERR_PNFS_NO_LAYOUT | READ, WRITE | | NFS4ERR_RECALLCONFLICT | LAYOUTGET, WANT_DELEGATION | | NFS4ERR_RECLAIM_BAD | LAYOUTCOMMIT, LOCK, OPEN, | | | WANT_DELEGATION | | NFS4ERR_RECLAIM_CONFLICT | LAYOUTCOMMIT, LOCK, OPEN, | | | WANT_DELEGATION | | NFS4ERR_REJECT_DELEG | CB_PUSH_DELEG | | NFS4ERR_REP_TOO_BIG | ACCESS, BACKCHANNEL_CTL, | | | BIND_CONN_TO_SESSION, | | | CB_GETATTR, CB_LAYOUTRECALL, | | | CB_NOTIFY, | | | CB_NOTIFY_DEVICEID, | | | CB_NOTIFY_LOCK, | | | CB_PUSH_DELEG, CB_RECALL, | | | CB_RECALLABLE_OBJ_AVAIL, | | | CB_RECALL_ANY, | | | CB_RECALL_SLOT, CB_SEQUENCE, | | | CB_WANTS_CANCELLED, CLOSE, | | | COMMIT, CREATE, | | | CREATE_SESSION, DELEGPURGE, | | | DELEGRETURN, | | | DESTROY_CLIENTID, | | | DESTROY_SESSION, EXCHANGE_ID, | | | FREE_STATEID, GETATTR, | | | GETDEVICEINFO, GETDEVICELIST, |",
      "ja": "| | CB_RECALL_ANY、| | | CB_RECALL_SLOT、| | | CB_WANTS_CANCELLED、CLOSE、| | | COMMIT、CREATE、DELEGPURGE、| | | DELEGRETURN、FREE_STATEID、| | | GETATTR、GETDEVICEINFO、| | | GETDEVICELIST、GETFH、| | | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、OPEN_DOWNGRADE、| | | PUTFH、PUTPUBFH、PUTROOTFH、| | | READ、READDIR、READLINK、| | | RECLAIM_COMPLETE、削除| | | | RESTOREFH、SAVEFH、RENAME | | SECINFO、SECINFO_NO_NAME、| | | SETATTR、SET_SSV、| | | TEST_STATEID、確認し| | | WANT_DELEGATION、WRITE | | NFS4ERR_PERM | CREATE、OPEN、SETATTR | | NFS4ERR_PNFS_IO_HOLE | READ、WRITE | | NFS4ERR_PNFS_NO_LAYOUT | READ、WRITE | | NFS4ERR_RECALLCONFLICT | LAYOUTGET、WANT_DELEGATION | | NFS4ERR_RECLAIM_BAD | LAYOUTCOMMIT、LOCK、OPEN、| | | WANT_DELEGATION | | NFS4ERR_RECLAIM_CONFLICT | LAYOUTCOMMIT、LOCK、OPEN、| | | WANT_DELEGATION | | NFS4ERR_REJECT_DELEG | CB_PUSH_DELEG | | NFS4ERR_REP_TOO_BIG | ACCESS、BACKCHANNEL_CTL、| | | BIND_CONN_TO_SESSION、| | | CB_GETATTR、CB_LAYOUTRECALL、| | | CB_NOTIFY、| | | CB_NOTIFY_DEVICEID、| | | CB_NOTIFY_LOCK、| | | CB_PUSH_DELEG、CB_RECALL、| | | CB_RECALLABLE_OBJ_AVAIL、| | | CB_RECALL_ANY、| | | CB_RECALL_SLOT、CB_SEQUENCE、| | | CB_WANTS_CANCELLED、CLOSE、| | | COMMIT、CREATE、| | | CREATE_SESSION、DELEGPURGE、| | | DELEGRETURN、| | | DESTROY_CLIENTID、| | | DESTROY_SESSION、EXCHANGE_ID、| | | FREE_STATEID、GETATTR、| | | GETDEVICEINFO、GETDEVICELIST、|"
    },
    {
      "indent": 3,
      "text": "| | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, OPEN_DOWNGRADE, | | | PUTFH, PUTPUBFH, PUTROOTFH, | | | READ, READDIR, READLINK, | | | RECLAIM_COMPLETE, REMOVE, | | | RENAME, RESTOREFH, SAVEFH, | | | SECINFO, SECINFO_NO_NAME, | | | SEQUENCE, SETATTR, SET_SSV, | | | TEST_STATEID, VERIFY, | | | WANT_DELEGATION, WRITE | | NFS4ERR_REP_TOO_BIG_TO_CACHE | ACCESS, BACKCHANNEL_CTL, | | | BIND_CONN_TO_SESSION, | | | CB_GETATTR, CB_LAYOUTRECALL, | | | CB_NOTIFY, | | | CB_NOTIFY_DEVICEID, | | | CB_NOTIFY_LOCK, | | | CB_PUSH_DELEG, CB_RECALL, | | | CB_RECALLABLE_OBJ_AVAIL, | | | CB_RECALL_ANY, | | | CB_RECALL_SLOT, CB_SEQUENCE, | | | CB_WANTS_CANCELLED, CLOSE, | | | COMMIT, CREATE, | | | CREATE_SESSION, DELEGPURGE, | | | DELEGRETURN, | | | DESTROY_CLIENTID, | | | DESTROY_SESSION, EXCHANGE_ID, | | | FREE_STATEID, GETATTR, | | | GETDEVICEINFO, GETDEVICELIST, | | | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, OPEN_DOWNGRADE, | | | PUTFH, PUTPUBFH, PUTROOTFH, | | | READ, READDIR, READLINK, | | | RECLAIM_COMPLETE, REMOVE, | | | RENAME, RESTOREFH, SAVEFH, | | | SECINFO, SECINFO_NO_NAME, | | | SEQUENCE, SETATTR, SET_SSV, | | | TEST_STATEID, VERIFY, | | | WANT_DELEGATION, WRITE | | NFS4ERR_REQ_TOO_BIG | ACCESS, BACKCHANNEL_CTL, | | | BIND_CONN_TO_SESSION, |",
      "ja": "| | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、OPEN_DOWNGRADE、| | | PUTFH、PUTPUBFH、PUTROOTFH、| | | READ、READDIR、READLINK、| | | RECLAIM_COMPLETE、削除| | | | RESTOREFH、SAVEFH、RENAME | | SECINFO、SECINFO_NO_NAME、| | | SEQUENCE、SETATTR、SET_SSV、| | | TEST_STATEID、確認し| | | WANT_DELEGATION、WRITE | | NFS4ERR_REP_TOO_BIG_TO_CACHE | ACCESS、BACKCHANNEL_CTL、| | | BIND_CONN_TO_SESSION、| | | CB_GETATTR、CB_LAYOUTRECALL、| | | CB_NOTIFY、| | | CB_NOTIFY_DEVICEID、| | | CB_NOTIFY_LOCK、| | | CB_PUSH_DELEG、CB_RECALL、| | | CB_RECALLABLE_OBJ_AVAIL、| | | CB_RECALL_ANY、| | | CB_RECALL_SLOT、CB_SEQUENCE、| | | CB_WANTS_CANCELLED、CLOSE、| | | COMMIT、CREATE、| | | CREATE_SESSION、DELEGPURGE、| | | DELEGRETURN、| | | DESTROY_CLIENTID、| | | DESTROY_SESSION、EXCHANGE_ID、| | | FREE_STATEID、GETATTR、| | | GETDEVICEINFO、GETDEVICELIST、| | | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、OPEN_DOWNGRADE、| | | PUTFH、PUTPUBFH、PUTROOTFH、| | | READ、READDIR、READLINK、| | | RECLAIM_COMPLETE、削除| | | | RESTOREFH、SAVEFH、RENAME | | SECINFO、SECINFO_NO_NAME、| | | SEQUENCE、SETATTR、SET_SSV、| | | TEST_STATEID、確認し| | | WANT_DELEGATION、WRITE | | NFS4ERR_REQ_TOO_BIG | ACCESS、BACKCHANNEL_CTL、| | | BIND_CONN_TO_SESSION、|"
    },
    {
      "indent": 3,
      "text": "| | CB_GETATTR, CB_LAYOUTRECALL, | | | CB_NOTIFY, | | | CB_NOTIFY_DEVICEID, | | | CB_NOTIFY_LOCK, | | | CB_PUSH_DELEG, CB_RECALL, | | | CB_RECALLABLE_OBJ_AVAIL, | | | CB_RECALL_ANY, | | | CB_RECALL_SLOT, CB_SEQUENCE, | | | CB_WANTS_CANCELLED, CLOSE, | | | COMMIT, CREATE, | | | CREATE_SESSION, DELEGPURGE, | | | DELEGRETURN, | | | DESTROY_CLIENTID, | | | DESTROY_SESSION, EXCHANGE_ID, | | | FREE_STATEID, GETATTR, | | | GETDEVICEINFO, GETDEVICELIST, | | | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, OPEN_DOWNGRADE, | | | PUTFH, PUTPUBFH, PUTROOTFH, | | | READ, READDIR, READLINK, | | | RECLAIM_COMPLETE, REMOVE, | | | RENAME, RESTOREFH, SAVEFH, | | | SECINFO, SECINFO_NO_NAME, | | | SEQUENCE, SETATTR, SET_SSV, | | | TEST_STATEID, VERIFY, | | | WANT_DELEGATION, WRITE | | NFS4ERR_RETRY_UNCACHED_REP | ACCESS, BACKCHANNEL_CTL, | | | BIND_CONN_TO_SESSION, | | | CB_GETATTR, CB_LAYOUTRECALL, | | | CB_NOTIFY, | | | CB_NOTIFY_DEVICEID, | | | CB_NOTIFY_LOCK, | | | CB_PUSH_DELEG, CB_RECALL, | | | CB_RECALLABLE_OBJ_AVAIL, | | | CB_RECALL_ANY, | | | CB_RECALL_SLOT, CB_SEQUENCE, | | | CB_WANTS_CANCELLED, CLOSE, | | | COMMIT, CREATE, | | | CREATE_SESSION, DELEGPURGE, | | | DELEGRETURN, | | | DESTROY_CLIENTID, | | | DESTROY_SESSION, EXCHANGE_ID, | | | FREE_STATEID, GETATTR, | | | GETDEVICEINFO, GETDEVICELIST, |",
      "ja": "| | CB_GETATTR、CB_LAYOUTRECALL、| | | CB_NOTIFY、| | | CB_NOTIFY_DEVICEID、| | | CB_NOTIFY_LOCK、| | | CB_PUSH_DELEG、CB_RECALL、| | | CB_RECALLABLE_OBJ_AVAIL、| | | CB_RECALL_ANY、| | | CB_RECALL_SLOT、CB_SEQUENCE、| | | CB_WANTS_CANCELLED、CLOSE、| | | COMMIT、CREATE、| | | CREATE_SESSION、DELEGPURGE、| | | DELEGRETURN、| | | DESTROY_CLIENTID、| | | DESTROY_SESSION、EXCHANGE_ID、| | | FREE_STATEID、GETATTR、| | | GETDEVICEINFO、GETDEVICELIST、| | | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、OPEN_DOWNGRADE、| | | PUTFH、PUTPUBFH、PUTROOTFH、| | | READ、READDIR、READLINK、| | | RECLAIM_COMPLETE、削除| | | | RESTOREFH、SAVEFH、RENAME | | SECINFO、SECINFO_NO_NAME、| | | SEQUENCE、SETATTR、SET_SSV、| | | TEST_STATEID、確認し| | | WANT_DELEGATION、WRITE | | NFS4ERR_RETRY_UNCACHED_REP | ACCESS、BACKCHANNEL_CTL、| | | BIND_CONN_TO_SESSION、| | | CB_GETATTR、CB_LAYOUTRECALL、| | | CB_NOTIFY、| | | CB_NOTIFY_DEVICEID、| | | CB_NOTIFY_LOCK、| | | CB_PUSH_DELEG、CB_RECALL、| | | CB_RECALLABLE_OBJ_AVAIL、| | | CB_RECALL_ANY、| | | CB_RECALL_SLOT、CB_SEQUENCE、| | | CB_WANTS_CANCELLED、CLOSE、| | | COMMIT、CREATE、| | | CREATE_SESSION、DELEGPURGE、| | | DELEGRETURN、| | | DESTROY_CLIENTID、| | | DESTROY_SESSION、EXCHANGE_ID、| | | FREE_STATEID、GETATTR、| | | GETDEVICEINFO、GETDEVICELIST、|"
    },
    {
      "indent": 3,
      "text": "| | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, OPEN_DOWNGRADE, | | | PUTFH, PUTPUBFH, PUTROOTFH, | | | READ, READDIR, READLINK, | | | RECLAIM_COMPLETE, REMOVE, | | | RENAME, RESTOREFH, SAVEFH, | | | SECINFO, SECINFO_NO_NAME, | | | SEQUENCE, SETATTR, SET_SSV, | | | TEST_STATEID, VERIFY, | | | WANT_DELEGATION, WRITE | | NFS4ERR_ROFS | CREATE, LINK, LOCK, LOCKT, | | | OPEN, OPENATTR, | | | OPEN_DOWNGRADE, REMOVE, | | | RENAME, SETATTR, WRITE | | NFS4ERR_SAME | NVERIFY | | NFS4ERR_SEQUENCE_POS | CB_SEQUENCE, SEQUENCE | | NFS4ERR_SEQ_FALSE_RETRY | CB_SEQUENCE, SEQUENCE | | NFS4ERR_SEQ_MISORDERED | CB_SEQUENCE, CREATE_SESSION, | | | SEQUENCE | | NFS4ERR_SERVERFAULT | ACCESS, BIND_CONN_TO_SESSION, | | | CB_GETATTR, CB_NOTIFY, | | | CB_NOTIFY_DEVICEID, | | | CB_NOTIFY_LOCK, | | | CB_PUSH_DELEG, CB_RECALL, | | | CB_RECALLABLE_OBJ_AVAIL, | | | CB_WANTS_CANCELLED, CLOSE, | | | COMMIT, CREATE, | | | CREATE_SESSION, DELEGPURGE, | | | DELEGRETURN, | | | DESTROY_CLIENTID, | | | DESTROY_SESSION, EXCHANGE_ID, | | | FREE_STATEID, GETATTR, | | | GETDEVICEINFO, GETDEVICELIST, | | | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKU, LOOKUP, LOOKUPP, | | | NVERIFY, OPEN, OPENATTR, | | | OPEN_DOWNGRADE, PUTFH, | | | PUTPUBFH, PUTROOTFH, READ, | | | READDIR, READLINK, | | | RECLAIM_COMPLETE, REMOVE, | | | RENAME, RESTOREFH, SAVEFH, | | | SECINFO, SECINFO_NO_NAME, |",
      "ja": "| | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、OPEN_DOWNGRADE、| | | PUTFH、PUTPUBFH、PUTROOTFH、| | | READ、READDIR、READLINK、| | | RECLAIM_COMPLETE、削除| | | | RESTOREFH、SAVEFH、RENAME | | SECINFO、SECINFO_NO_NAME、| | | SEQUENCE、SETATTR、SET_SSV、| | | TEST_STATEID、確認し| | | WANT_DELEGATION、WRITE | | NFS4ERR_ROFS | CREATE、LINK、LOCK、LOCKT、| | | OPEN、OPENATTR、| | | OPEN_DOWNGRADE、削除| | | SETATTR、WRITE、RENAME | | NFS4ERR_SAME | NVERIFY | | NFS4ERR_SEQUENCE_POS | CB_SEQUENCE、SEQUENCE | | NFS4ERR_SEQ_FALSE_RETRY | CB_SEQUENCE、SEQUENCE | | NFS4ERR_SEQ_MISORDERED | CB_SEQUENCE、CREATE_SESSION、| | | SEQUENCE | | NFS4ERR_SERVERFAULT | ACCESS、BIND_CONN_TO_SESSION、| | | CB_GETATTR、CB_NOTIFY、| | | CB_NOTIFY_DEVICEID、| | | CB_NOTIFY_LOCK、| | | CB_PUSH_DELEG、CB_RECALL、| | | CB_RECALLABLE_OBJ_AVAIL、| | | CB_WANTS_CANCELLED、CLOSE、| | | COMMIT、CREATE、| | | CREATE_SESSION、DELEGPURGE、| | | DELEGRETURN、| | | DESTROY_CLIENTID、| | | DESTROY_SESSION、EXCHANGE_ID、| | | FREE_STATEID、GETATTR、| | | GETDEVICEINFO、GETDEVICELIST、| | | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKU、LOOKUP、LOOKUPP、| | | NVERIFY、OPEN、OPENATTR、| | | OPEN_DOWNGRADE、PUTFH、| | | PUTPUBFH、PUTROOTFH、READ、| | | READDIR、READLINK、| | | RECLAIM_COMPLETE、削除| | | | RESTOREFH、SAVEFH、RENAME | | SECINFO、SECINFO_NO_NAME、|"
    },
    {
      "indent": 3,
      "text": "| | SETATTR, TEST_STATEID, | | | VERIFY, WANT_DELEGATION, | | | WRITE | | NFS4ERR_SHARE_DENIED | OPEN | | NFS4ERR_STALE | ACCESS, CLOSE, COMMIT, | | | CREATE, DELEGRETURN, GETATTR, | | | GETFH, GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, | | | LAYOUTRETURN, LINK, LOCK, | | | LOCKT, LOCKU, LOOKUP, | | | LOOKUPP, NVERIFY, OPEN, | | | OPENATTR, OPEN_DOWNGRADE, | | | PUTFH, READ, READDIR, | | | READLINK, RECLAIM_COMPLETE, | | | REMOVE, RENAME, RESTOREFH, | | | SAVEFH, SECINFO, | | | SECINFO_NO_NAME, SETATTR, | | | VERIFY, WANT_DELEGATION, | | | WRITE | | NFS4ERR_STALE_CLIENTID | CREATE_SESSION, | | | DESTROY_CLIENTID, | | | DESTROY_SESSION | | NFS4ERR_SYMLINK | COMMIT, LAYOUTCOMMIT, LINK, | | | LOCK, LOCKT, LOOKUP, LOOKUPP, | | | OPEN, READ, WRITE | | NFS4ERR_TOOSMALL | CREATE_SESSION, | | | GETDEVICEINFO, LAYOUTGET, | | | READDIR | | NFS4ERR_TOO_MANY_OPS | ACCESS, BACKCHANNEL_CTL, | | | BIND_CONN_TO_SESSION, | | | CB_GETATTR, CB_LAYOUTRECALL, | | | CB_NOTIFY, | | | CB_NOTIFY_DEVICEID, | | | CB_NOTIFY_LOCK, | | | CB_PUSH_DELEG, CB_RECALL, | | | CB_RECALLABLE_OBJ_AVAIL, | | | CB_RECALL_ANY, | | | CB_RECALL_SLOT, CB_SEQUENCE, | | | CB_WANTS_CANCELLED, CLOSE, | | | COMMIT, CREATE, | | | CREATE_SESSION, DELEGPURGE, | | | DELEGRETURN, | | | DESTROY_CLIENTID, | | | DESTROY_SESSION, EXCHANGE_ID, | | | FREE_STATEID, GETATTR, | | | GETDEVICEINFO, GETDEVICELIST, | | | GET_DIR_DELEGATION, | | | LAYOUTCOMMIT, LAYOUTGET, |",
      "ja": "| | SETATTR、TEST_STATEID、| | | |、、WANT_DELEGATIONを確認| | WRITE | | NFS4ERR_SHARE_DENIED | OPEN | | NFS4ERR_STALE | ACCESS、CLOSE、COMMIT、| | | | DELEGRETURN、GETATTR、CREATE | | GETFH、GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、| | | LAYOUTRETURN、LINK、LOCK、| | | LOCKT、LOCKU、LOOKUP、| | | LOOKUPP、NVERIFY、OPEN、| | | OPENATTR、OPEN_DOWNGRADE、| | | PUTFH、READ、READDIR、| | | READLINK、RECLAIM_COMPLETE、| | | REMOVE、RENAME、RESTOREFH、| | | SAVEFH、SECINFO、| | | SECINFO_NO_NAME、SETATTR、| | | |、、WANT_DELEGATIONを確認| | WRITE | | NFS4ERR_STALE_CLIENTID | CREATE_SESSION、| | | DESTROY_CLIENTID、| | | DESTROY_SESSION | | NFS4ERR_SYMLINK | | LAYOUTCOMMIT、LINK、COMMIT | | LOCK、LOCKT、LOOKUP、LOOKUPP、| | | OPEN、READ、WRITE | | NFS4ERR_TOOSMALL | CREATE_SESSION、| | | GETDEVICEINFO、LAYOUTGET、| | | READDIR | | NFS4ERR_TOO_MANY_OPS | ACCESS、BACKCHANNEL_CTL、| | | BIND_CONN_TO_SESSION、| | | CB_GETATTR、CB_LAYOUTRECALL、| | | CB_NOTIFY、| | | CB_NOTIFY_DEVICEID、| | | CB_NOTIFY_LOCK、| | | CB_PUSH_DELEG、CB_RECALL、| | | CB_RECALLABLE_OBJ_AVAIL、| | | CB_RECALL_ANY、| | | CB_RECALL_SLOT、CB_SEQUENCE、| | | CB_WANTS_CANCELLED、CLOSE、| | | COMMIT、CREATE、| | | CREATE_SESSION、DELEGPURGE、| | | DELEGRETURN、| | | DESTROY_CLIENTID、| | | DESTROY_SESSION、EXCHANGE_ID、| | | FREE_STATEID、GETATTR、| | | GETDEVICEINFO、GETDEVICELIST、| | | GET_DIR_DELEGATION、| | | LAYOUTCOMMIT、LAYOUTGET、|"
    },
    {
      "indent": 3,
      "text": "|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, LOCKU, LOOKUP,         |\n|                                   | LOOKUPP, NVERIFY, OPEN,       |\n|                                   | OPENATTR, OPEN_DOWNGRADE,     |\n|                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |\n|                                   | READ, READDIR, READLINK,      |\n|                                   | RECLAIM_COMPLETE, REMOVE,     |\n|                                   | RENAME, RESTOREFH, SAVEFH,    |\n|                                   | SECINFO, SECINFO_NO_NAME,     |\n|                                   | SEQUENCE, SETATTR, SET_SSV,   |\n|                                   | TEST_STATEID, VERIFY,         |\n|                                   | WANT_DELEGATION, WRITE        |\n| NFS4ERR_UNKNOWN_LAYOUTTYPE        | CB_LAYOUTRECALL,              |\n|                                   | GETDEVICEINFO, GETDEVICELIST, |\n|                                   | LAYOUTCOMMIT, LAYOUTGET,      |\n|                                   | LAYOUTRETURN, NVERIFY,        |\n|                                   | SETATTR, VERIFY               |\n| NFS4ERR_UNSAFE_COMPOUND           | CREATE, OPEN, OPENATTR        |\n| NFS4ERR_WRONGSEC                  | LINK, LOOKUP, LOOKUPP, OPEN,  |\n|                                   | PUTFH, PUTPUBFH, PUTROOTFH,   |\n|                                   | RENAME, RESTOREFH             |\n| NFS4ERR_WRONG_CRED                | CLOSE, CREATE_SESSION,        |\n|                                   | DELEGPURGE, DELEGRETURN,      |\n|                                   | DESTROY_CLIENTID,             |\n|                                   | DESTROY_SESSION,              |\n|                                   | FREE_STATEID, LAYOUTCOMMIT,   |\n|                                   | LAYOUTRETURN, LOCK, LOCKT,    |\n|                                   | LOCKU, OPEN_DOWNGRADE,        |\n|                                   | RECLAIM_COMPLETE              |\n| NFS4ERR_WRONG_TYPE                | CB_LAYOUTRECALL,              |\n|                                   | CB_PUSH_DELEG, COMMIT,        |\n|                                   | GETATTR, LAYOUTGET,           |\n|                                   | LAYOUTRETURN, LINK, LOCK,     |\n|                                   | LOCKT, NVERIFY, OPEN,         |\n|                                   | OPENATTR, READ, READLINK,     |\n|                                   | RECLAIM_COMPLETE, SETATTR,    |\n|                                   | VERIFY, WANT_DELEGATION,      |\n|                                   | WRITE                         |\n| NFS4ERR_XDEV                      | LINK, RENAME                  |\n+-----------------------------------+-------------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 8",
      "ja": "表8"
    },
    {
      "indent": 0,
      "text": "16. NFSv4.1 Procedures",
      "section_title": true,
      "ja": "16. NFSv4.1手順"
    },
    {
      "indent": 3,
      "text": "Both procedures, NULL and COMPOUND, MUST be implemented.",
      "ja": "両方の手順、NULLおよび化合物が、実施されなければなりません。"
    },
    {
      "indent": 0,
      "text": "16.1. Procedure 0: NULL - No Operation",
      "section_title": true,
      "ja": "16.1. 手順0：NULL  - 動作なし"
    },
    {
      "indent": 0,
      "text": "16.1.1. ARGUMENTS",
      "section_title": true,
      "ja": "16.1.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "16.1.2. RESULTS",
      "section_title": true,
      "ja": "16.1.2. 結果"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "16.1.3. DESCRIPTION",
      "section_title": true,
      "ja": "16.1.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This is the standard NULL procedure with the standard void argument and void response. This procedure has no functionality associated with it. Because of this, it is sometimes used to measure the overhead of processing a service request. Therefore, the server SHOULD ensure that no unnecessary work is done in servicing this procedure.",
      "ja": "これは、標準のボイド引数と、ボイド応答で標準NULL手続きです。この手順は、それに関連付けられた機能を持っていません。このため、時々、サービス要求の処理のオーバーヘッドを測定するために使用されます。そのため、サーバは不要な作業は、この手順を整備中で行われていないことを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "16.1.4. ERRORS",
      "section_title": true,
      "ja": "16.1.4. エラー"
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "無し。"
    },
    {
      "indent": 0,
      "text": "16.2. Procedure 1: COMPOUND - Compound Operations",
      "section_title": true,
      "ja": "16.2. 手順1：COMPOUND  - 化合物の操作"
    },
    {
      "indent": 0,
      "text": "16.2.1. ARGUMENTS",
      "section_title": true,
      "ja": "16.2.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "enum nfs_opnum4 {\n OP_ACCESS              = 3,\n OP_CLOSE               = 4,\n OP_COMMIT              = 5,\n OP_CREATE              = 6,\n OP_DELEGPURGE          = 7,\n OP_DELEGRETURN         = 8,\n OP_GETATTR             = 9,\n OP_GETFH               = 10,\n OP_LINK                = 11,\n OP_LOCK                = 12,\n OP_LOCKT               = 13,\n OP_LOCKU               = 14,\n OP_LOOKUP              = 15,\n OP_LOOKUPP             = 16,\n OP_NVERIFY             = 17,\n OP_OPEN                = 18,\n OP_OPENATTR            = 19,\n OP_OPEN_CONFIRM        = 20, /* Mandatory not-to-implement */\n OP_OPEN_DOWNGRADE      = 21,\n OP_PUTFH               = 22,",
      "raw": true
    },
    {
      "indent": 4,
      "text": "OP_PUTPUBFH            = 23,\nOP_PUTROOTFH           = 24,\nOP_READ                = 25,\nOP_READDIR             = 26,\nOP_READLINK            = 27,\nOP_REMOVE              = 28,\nOP_RENAME              = 29,\nOP_RENEW               = 30, /* Mandatory not-to-implement */\nOP_RESTOREFH           = 31,\nOP_SAVEFH              = 32,\nOP_SECINFO             = 33,\nOP_SETATTR             = 34,\nOP_SETCLIENTID         = 35, /* Mandatory not-to-implement */\nOP_SETCLIENTID_CONFIRM = 36, /* Mandatory not-to-implement */\nOP_VERIFY              = 37,\nOP_WRITE               = 38,\nOP_RELEASE_LOCKOWNER   = 39, /* Mandatory not-to-implement */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* new operations for NFSv4.1 */\n OP_BACKCHANNEL_CTL     = 40,\n OP_BIND_CONN_TO_SESSION = 41,\n OP_EXCHANGE_ID         = 42,\n OP_CREATE_SESSION      = 43,\n OP_DESTROY_SESSION     = 44,\n OP_FREE_STATEID        = 45,\n OP_GET_DIR_DELEGATION  = 46,\n OP_GETDEVICEINFO       = 47,\n OP_GETDEVICELIST       = 48,\n OP_LAYOUTCOMMIT        = 49,\n OP_LAYOUTGET           = 50,\n OP_LAYOUTRETURN        = 51,\n OP_SECINFO_NO_NAME     = 52,\n OP_SEQUENCE            = 53,\n OP_SET_SSV             = 54,\n OP_TEST_STATEID        = 55,\n OP_WANT_DELEGATION     = 56,\n OP_DESTROY_CLIENTID    = 57,\n OP_RECLAIM_COMPLETE    = 58,\n OP_ILLEGAL             = 10044\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union nfs_argop4 switch (nfs_opnum4 argop) {\n case OP_ACCESS:        ACCESS4args opaccess;\n case OP_CLOSE:         CLOSE4args opclose;\n case OP_COMMIT:        COMMIT4args opcommit;\n case OP_CREATE:        CREATE4args opcreate;\n case OP_DELEGPURGE:    DELEGPURGE4args opdelegpurge;\n case OP_DELEGRETURN:   DELEGRETURN4args opdelegreturn;\n case OP_GETATTR:       GETATTR4args opgetattr;\n case OP_GETFH:         void;\n case OP_LINK:          LINK4args oplink;\n case OP_LOCK:          LOCK4args oplock;\n case OP_LOCKT:         LOCKT4args oplockt;\n case OP_LOCKU:         LOCKU4args oplocku;\n case OP_LOOKUP:        LOOKUP4args oplookup;\n case OP_LOOKUPP:       void;\n case OP_NVERIFY:       NVERIFY4args opnverify;\n case OP_OPEN:          OPEN4args opopen;\n case OP_OPENATTR:      OPENATTR4args opopenattr;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_OPEN_CONFIRM:  OPEN_CONFIRM4args opopen_confirm;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "case OP_OPEN_DOWNGRADE: OPEN_DOWNGRADE4args opopen_downgrade;",
      "ja": "ケースOP_OPEN_DOWNGRADE：OPEN_DOWNGRADE4argsのopopen_downgrade。"
    },
    {
      "indent": 4,
      "text": "case OP_PUTFH:         PUTFH4args opputfh;\ncase OP_PUTPUBFH:      void;\ncase OP_PUTROOTFH:     void;\ncase OP_READ:          READ4args opread;\ncase OP_READDIR:       READDIR4args opreaddir;\ncase OP_READLINK:      void;\ncase OP_REMOVE:        REMOVE4args opremove;\ncase OP_RENAME:        RENAME4args oprename;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_RENEW:         RENEW4args oprenew;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "case OP_RESTOREFH:     void;\ncase OP_SAVEFH:        void;\ncase OP_SECINFO:       SECINFO4args opsecinfo;\ncase OP_SETATTR:       SETATTR4args opsetattr;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_SETCLIENTID: SETCLIENTID4args opsetclientid;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_SETCLIENTID_CONFIRM: SETCLIENTID_CONFIRM4args\n                               opsetclientid_confirm;\ncase OP_VERIFY:        VERIFY4args opverify;\ncase OP_WRITE:         WRITE4args opwrite;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_RELEASE_LOCKOWNER:\n                       RELEASE_LOCKOWNER4args\n                       oprelease_lockowner;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Operations new to NFSv4.1 */\ncase OP_BACKCHANNEL_CTL:\n                       BACKCHANNEL_CTL4args opbackchannel_ctl;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "case OP_BIND_CONN_TO_SESSION: BIND_CONN_TO_SESSION4args opbind_conn_to_session;",
      "ja": "ケースOP_BIND_CONN_TO_SESSION：BIND_CONN_TO_SESSION4argsのopbind_conn_to_session。"
    },
    {
      "indent": 4,
      "text": "case OP_EXCHANGE_ID: EXCHANGE_ID4args opexchange_id;",
      "ja": "ケースOP_EXCHANGE_ID：EXCHANGE_ID4argsはopexchange_id。"
    },
    {
      "indent": 4,
      "text": "case OP_CREATE_SESSION: CREATE_SESSION4args opcreate_session;",
      "ja": "ケースOP_CREATE_SESSION：CREATE_SESSION4args opcreate_session。"
    },
    {
      "indent": 4,
      "text": "case OP_DESTROY_SESSION: DESTROY_SESSION4args opdestroy_session;",
      "ja": "ケースOP_DESTROY_SESSION：DESTROY_SESSION4argsのopdestroy_session。"
    },
    {
      "indent": 4,
      "text": "case OP_FREE_STATEID: FREE_STATEID4args opfree_stateid;",
      "ja": "OP_FREE_STATEIDケース：FREE_STATEID4argsはopfree_stateid。"
    },
    {
      "indent": 4,
      "text": "case OP_GET_DIR_DELEGATION: GET_DIR_DELEGATION4args opget_dir_delegation;",
      "ja": "ケースOP_GET_DIR_DELEGATION：GET_DIR_DELEGATION4argsのopget_dir_delegation。"
    },
    {
      "indent": 4,
      "text": "case OP_GETDEVICEINFO: GETDEVICEINFO4args opgetdeviceinfo;\ncase OP_GETDEVICELIST: GETDEVICELIST4args opgetdevicelist;\ncase OP_LAYOUTCOMMIT:  LAYOUTCOMMIT4args oplayoutcommit;\ncase OP_LAYOUTGET:     LAYOUTGET4args oplayoutget;\ncase OP_LAYOUTRETURN:  LAYOUTRETURN4args oplayoutreturn;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "case OP_SECINFO_NO_NAME: SECINFO_NO_NAME4args opsecinfo_no_name;",
      "ja": "ケースOP_SECINFO_NO_NAME：SECINFO_NO_NAME4argsのopsecinfo_no_name。"
    },
    {
      "indent": 4,
      "text": "case OP_SEQUENCE:      SEQUENCE4args opsequence;\ncase OP_SET_SSV:       SET_SSV4args opset_ssv;\ncase OP_TEST_STATEID:  TEST_STATEID4args optest_stateid;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "case OP_WANT_DELEGATION: WANT_DELEGATION4args opwant_delegation;",
      "ja": "ケースOP_WANT_DELEGATION：WANT_DELEGATION4args opwant_delegation。"
    },
    {
      "indent": 4,
      "text": "case OP_DESTROY_CLIENTID: DESTROY_CLIENTID4args opdestroy_clientid;",
      "ja": "ケースOP_DESTROY_CLIENTID：DESTROY_CLIENTID4args opdestroy_clientid。"
    },
    {
      "indent": 4,
      "text": "case OP_RECLAIM_COMPLETE: RECLAIM_COMPLETE4args opreclaim_complete;",
      "ja": "ケースOP_RECLAIM_COMPLETE：RECLAIM_COMPLETE4args opreclaim_complete。"
    },
    {
      "indent": 3,
      "text": " /* Operations not new to NFSv4.1 */\n case OP_ILLEGAL:       void;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct COMPOUND4args {\n        utf8str_cs      tag;\n        uint32_t        minorversion;\n        nfs_argop4      argarray<>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "16.2.2. RESULTS",
      "section_title": true,
      "ja": "16.2.2. 結果"
    },
    {
      "indent": 3,
      "text": "union nfs_resop4 switch (nfs_opnum4 resop) {\n case OP_ACCESS:        ACCESS4res opaccess;\n case OP_CLOSE:         CLOSE4res opclose;\n case OP_COMMIT:        COMMIT4res opcommit;\n case OP_CREATE:        CREATE4res opcreate;\n case OP_DELEGPURGE:    DELEGPURGE4res opdelegpurge;\n case OP_DELEGRETURN:   DELEGRETURN4res opdelegreturn;\n case OP_GETATTR:       GETATTR4res opgetattr;\n case OP_GETFH:         GETFH4res opgetfh;\n case OP_LINK:          LINK4res oplink;\n case OP_LOCK:          LOCK4res oplock;\n case OP_LOCKT:         LOCKT4res oplockt;\n case OP_LOCKU:         LOCKU4res oplocku;\n case OP_LOOKUP:        LOOKUP4res oplookup;\n case OP_LOOKUPP:       LOOKUPP4res oplookupp;\n case OP_NVERIFY:       NVERIFY4res opnverify;\n case OP_OPEN:          OPEN4res opopen;\n case OP_OPENATTR:      OPENATTR4res opopenattr;\n /* Not for NFSv4.1 */\n case OP_OPEN_CONFIRM:  OPEN_CONFIRM4res opopen_confirm;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "case OP_OPEN_DOWNGRADE: OPEN_DOWNGRADE4res opopen_downgrade;",
      "ja": "ケースOP_OPEN_DOWNGRADE：OPEN_DOWNGRADE4resのopopen_downgrade。"
    },
    {
      "indent": 4,
      "text": "case OP_PUTFH:         PUTFH4res opputfh;\ncase OP_PUTPUBFH:      PUTPUBFH4res opputpubfh;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "case OP_PUTROOTFH:     PUTROOTFH4res opputrootfh;\ncase OP_READ:          READ4res opread;\ncase OP_READDIR:       READDIR4res opreaddir;\ncase OP_READLINK:      READLINK4res opreadlink;\ncase OP_REMOVE:        REMOVE4res opremove;\ncase OP_RENAME:        RENAME4res oprename;\n/* Not for NFSv4.1 */\ncase OP_RENEW:         RENEW4res oprenew;\ncase OP_RESTOREFH:     RESTOREFH4res oprestorefh;\ncase OP_SAVEFH:        SAVEFH4res opsavefh;\ncase OP_SECINFO:       SECINFO4res opsecinfo;\ncase OP_SETATTR:       SETATTR4res opsetattr;\n/* Not for NFSv4.1 */\ncase OP_SETCLIENTID: SETCLIENTID4res opsetclientid;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_SETCLIENTID_CONFIRM:\n                       SETCLIENTID_CONFIRM4res\n                               opsetclientid_confirm;\ncase OP_VERIFY:        VERIFY4res opverify;\ncase OP_WRITE:         WRITE4res opwrite;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Not for NFSv4.1 */\ncase OP_RELEASE_LOCKOWNER:\n                       RELEASE_LOCKOWNER4res\n                               oprelease_lockowner;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Operations new to NFSv4.1 */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "case OP_BACKCHANNEL_CTL: BACKCHANNEL_CTL4res opbackchannel_ctl;",
      "ja": "ケースOP_BACKCHANNEL_CTL：BACKCHANNEL_CTL4resのopbackchannel_ctl。"
    },
    {
      "indent": 4,
      "text": "case OP_BIND_CONN_TO_SESSION: BIND_CONN_TO_SESSION4res opbind_conn_to_session;",
      "ja": "ケースOP_BIND_CONN_TO_SESSION：BIND_CONN_TO_SESSION4resのopbind_conn_to_session。"
    },
    {
      "indent": 4,
      "text": "case OP_EXCHANGE_ID: EXCHANGE_ID4res opexchange_id;",
      "ja": "ケースOP_EXCHANGE_ID：EXCHANGE_ID4resはopexchange_id。"
    },
    {
      "indent": 4,
      "text": "case OP_CREATE_SESSION: CREATE_SESSION4res opcreate_session;",
      "ja": "ケースOP_CREATE_SESSION：CREATE_SESSION4resのopcreate_session。"
    },
    {
      "indent": 4,
      "text": "case OP_DESTROY_SESSION: DESTROY_SESSION4res opdestroy_session;",
      "ja": "ケースOP_DESTROY_SESSION：DESTROY_SESSION4resのopdestroy_session。"
    },
    {
      "indent": 4,
      "text": "case OP_FREE_STATEID: FREE_STATEID4res opfree_stateid;",
      "ja": "OP_FREE_STATEIDケース：FREE_STATEID4resはopfree_stateid。"
    },
    {
      "indent": 4,
      "text": "case OP_GET_DIR_DELEGATION: GET_DIR_DELEGATION4res opget_dir_delegation;",
      "ja": "ケースOP_GET_DIR_DELEGATION：GET_DIR_DELEGATION4resのopget_dir_delegation。"
    },
    {
      "indent": 4,
      "text": "case OP_GETDEVICEINFO: GETDEVICEINFO4res opgetdeviceinfo;",
      "ja": "ケースOP_GETDEVICEINFO：GETDEVICEINFO4resはopgetdeviceinfo。"
    },
    {
      "indent": 4,
      "text": "case OP_GETDEVICELIST: GETDEVICELIST4res opgetdevicelist;",
      "ja": "ケースOP_GETDEVICELIST：GETDEVICELIST4resのopgetdevicelist。"
    },
    {
      "indent": 4,
      "text": "case OP_LAYOUTCOMMIT:  LAYOUTCOMMIT4res oplayoutcommit;\ncase OP_LAYOUTGET:     LAYOUTGET4res oplayoutget;\ncase OP_LAYOUTRETURN:  LAYOUTRETURN4res oplayoutreturn;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "case OP_SECINFO_NO_NAME: SECINFO_NO_NAME4res opsecinfo_no_name;",
      "ja": "ケースOP_SECINFO_NO_NAME：SECINFO_NO_NAME4resのopsecinfo_no_name。"
    },
    {
      "indent": 4,
      "text": "case OP_SEQUENCE:      SEQUENCE4res opsequence;\ncase OP_SET_SSV:       SET_SSV4res opset_ssv;\ncase OP_TEST_STATEID:  TEST_STATEID4res optest_stateid;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "case OP_WANT_DELEGATION: WANT_DELEGATION4res opwant_delegation;",
      "ja": "ケースOP_WANT_DELEGATION：WANT_DELEGATION4resのopwant_delegation。"
    },
    {
      "indent": 4,
      "text": "case OP_DESTROY_CLIENTID:",
      "ja": "ケースOP_DESTROY_CLIENTID："
    },
    {
      "indent": 27,
      "text": "DESTROY_CLIENTID4res\n        opdestroy_clientid;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "case OP_RECLAIM_COMPLETE: RECLAIM_COMPLETE4res opreclaim_complete;",
      "ja": "ケースOP_RECLAIM_COMPLETE：RECLAIM_COMPLETE4res opreclaim_complete。"
    },
    {
      "indent": 3,
      "text": " /* Operations not new to NFSv4.1 */\n case OP_ILLEGAL:       ILLEGAL4res opillegal;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct COMPOUND4res {\n        nfsstat4        status;\n        utf8str_cs      tag;\n        nfs_resop4      resarray<>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "16.2.3. DESCRIPTION",
      "section_title": true,
      "ja": "16.2.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The COMPOUND procedure is used to combine one or more NFSv4 operations into a single RPC request. The server interprets each of the operations in turn. If an operation is executed by the server and the status of that operation is NFS4_OK, then the next operation in the COMPOUND procedure is executed. The server continues this process until there are no more operations to be executed or until one of the operations has a status value other than NFS4_OK.",
      "ja": "COMPOUND手順は、単一のRPC要求に一つまたは複数のNFSv4操作を組み合わせるために使用されます。サーバは、順番にそれぞれの操作を解釈します。動作は、サーバによって実行され、その操作のステータスがNFS4_OKである場合、COMPOUND手順における次の動作が実行されます。もはや実行される操作または操作のいずれNFS4_OK以外の状態値を有するまでが存在しなくなるまで、サーバは、このプロセスを継続します。"
    },
    {
      "indent": 3,
      "text": "In the processing of the COMPOUND procedure, the server may find that it does not have the available resources to execute any or all of the operations within the COMPOUND sequence. See Section 2.10.6.4 for a more detailed discussion.",
      "ja": "COMPOUND手順の処理では、サーバはそれがCOMPOUND配列内の操作のいずれか、またはすべてを実行するために使用可能なリソースを持っていないことがあります。より詳細な議論については、セクション2.10.6.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "The server will generally choose between two methods of decoding the client's request. The first would be the traditional one-pass XDR decode. If there is an XDR decoding error in this case, the RPC XDR decode error would be returned. The second method would be to make an initial pass to decode the basic COMPOUND request and then to XDR decode the individual operations; the most interesting is the decode of attributes. In this case, the server may encounter an XDR decode error during the second pass. If it does, the server would return the error NFS4ERR_BADXDR to signify the decode error.",
      "ja": "サーバは、一般的にクライアントの要求を復号化する二つの方法のどちらかを選択します。最初は、伝統的なワンパスXDRデコードだろう。この場合XDRデコードエラーがある場合、RPCのXDRデコードエラーが返されることになります。第二の方法は、塩基性化合物の要求を復号化するための初期のパスを作成し、次いでXDRに個々の操作をデコードすることであろう。最も興味深いのは、属性のデコードです。この場合、サーバは、第二パス中XDRデコードエラーが発生する場合があります。それがない場合は、サーバがデコードエラーを示すためにエラーNFS4ERR_BADXDRを返します。"
    },
    {
      "indent": 3,
      "text": "The COMPOUND arguments contain a \"minorversion\" field. For NFSv4.1, the value for this field is 1. If the server receives a COMPOUND procedure with a minorversion field value that it does not support, the server MUST return an error of NFS4ERR_MINOR_VERS_MISMATCH and a zero-length resultdata array.",
      "ja": "COMPOUNDの引数は「MINORVERSION」フィールドが含まれています。サーバがサポートしていないMINORVERSIONフィールド値を有する化合物の手続きを受信した場合NFSv4.1ため、このフィールドの値は1であり、サーバはNFS4ERR_MINOR_VERS_MISMATCHの誤差およびゼロ長resultdata配列を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Contained within the COMPOUND results is a \"status\" field. If the results array length is non-zero, this status must be equivalent to the status of the last operation that was executed within the COMPOUND procedure. Therefore, if an operation incurred an error then the \"status\" value will be the same error value as is being returned for the operation that failed.",
      "ja": "COMPOUND結果に含まれる「状態」フィールドです。結果の配列の長さがゼロでない場合、このステータスはCOMPOUND手順の中で実行された最後の操作の状態と同等でなければなりません。操作がエラーを発生した場合、したがって、次に「状態」の値は、失敗した操作のために返される同じエラー値となります。"
    },
    {
      "indent": 3,
      "text": "Note that operations zero and one are not defined for the COMPOUND procedure. Operation 2 is not defined and is reserved for future definition and use with minor versioning. If the server receives an operation array that contains operation 2 and the minorversion field has a value of zero, an error of NFS4ERR_OP_ILLEGAL, as described in the next paragraph, is returned to the client. If an operation array contains an operation 2 and the minorversion field is non-zero and the server does not support the minor version, the server returns an error of NFS4ERR_MINOR_VERS_MISMATCH. Therefore, the NFS4ERR_MINOR_VERS_MISMATCH error takes precedence over all other errors.",
      "ja": "動作は、ゼロと1は、化合物処置のために定義されていないことに留意されたいです。操作2が定義されておらず、将来の定義のために予約されており、マイナーバージョン管理を使用しています。サーバが受信した場合、操作2及びMINORVERSIONフィールドを含む動作アレイはゼロの値、NFS4ERR_OP_ILLEGALの誤差は、次の段落で説明したように、クライアントに返されています。操作配列が操作2を含んでおり、MINORVERSIONフィールドがゼロでないと、サーバがマイナーバージョンをサポートしていない場合、サーバーはNFS4ERR_MINOR_VERS_MISMATCHのエラーを返します。したがって、NFS4ERR_MINOR_VERS_MISMATCHエラーは、他のすべてのエラーよりも優先されます。"
    },
    {
      "indent": 3,
      "text": "It is possible that the server receives a request that contains an operation that is less than the first legal operation (OP_ACCESS) or greater than the last legal operation (OP_RELEASE_LOCKOWNER). In this case, the server's response will encode the opcode OP_ILLEGAL rather than the illegal opcode of the request. The status field in the ILLEGAL return results will be set to NFS4ERR_OP_ILLEGAL. The COMPOUND procedure's return results will also be NFS4ERR_OP_ILLEGAL.",
      "ja": "サーバが最後の法的な操作（OP_RELEASE_LOCKOWNER）よりも第1の法的動作（OP_ACCESS）未満以上である動作を含む要求を受信することが可能です。この場合、サーバの応答は、オペコードOP_ILLEGALではなく、要求の不正命令コードをエンコードします。 ILLEGALリターン結果のステータスフィールドはNFS4ERR_OP_ILLEGALに設定されます。 COMPOUND手順のリターン結果もNFS4ERR_OP_ILLEGALになります。"
    },
    {
      "indent": 3,
      "text": "The definition of the \"tag\" in the request is left to the implementor. It may be used to summarize the content of the Compound request for the benefit of packet-sniffers and engineers debugging implementations. However, the value of \"tag\" in the response SHOULD be the same value as provided in the request. This applies to the tag field of the CB_COMPOUND procedure as well.",
      "ja": "リクエスト内の「タグ」の定義は実装者に任されています。実装、デバッグ、パケットスニッファとエンジニアの利益のための化合物の要求の内容を要約するために使用することができます。しかし、応答の「タグ」の値は、要求で提供されるような同じ値であるべきです。これは、同様にCB_COMPOUND手順のタグフィールドに適用されます。"
    },
    {
      "indent": 0,
      "text": "16.2.3.1. Current Filehandle and Stateid",
      "section_title": true,
      "ja": "16.2.3.1。現在のファイルハンドルとSTATEID"
    },
    {
      "indent": 3,
      "text": "The COMPOUND procedure offers a simple environment for the execution of the operations specified by the client. The first two relate to the filehandle while the second two relate to the current stateid.",
      "ja": "COMPOUND手順は、クライアントによって指定された操作を実行するためのシンプルな環境を提供しています。第2は、現在のstateidに関連しながら最初の二つは、ファイルハンドルに関連します。"
    },
    {
      "indent": 0,
      "text": "16.2.3.1.1. Current Filehandle",
      "section_title": true,
      "ja": "16.2.3.1.1。現在のファイルハンドル"
    },
    {
      "indent": 3,
      "text": "The current and saved filehandles are used throughout the protocol. Most operations implicitly use the current filehandle as an argument, and many set the current filehandle as part of the results. The combination of client-specified sequences of operations and current and saved filehandle arguments and results allows for greater protocol flexibility. The best or easiest example of current filehandle usage is a sequence like the following:",
      "ja": "現在、保存されたファイルハンドルは、プロトコルで使用されています。ほとんどの操作は、暗黙のうちに引数として現在のファイルハンドルを使用しており、多くは結果の一部として、現在のファイルハンドルを設定します。操作と、現在、保存されたファイルハンドルを引数と結果のクライアント指定の配列の組み合わせは、より大きなプロトコルの柔軟性を可能にします。現在のファイルハンドルの使用状況の最高または最も簡単な例は、以下のような配列です。"
    },
    {
      "indent": 9,
      "text": "PUTFH fh1              {fh1}\nLOOKUP \"compA\"         {fh2}\nGETATTR                {fh2}\nLOOKUP \"compB\"         {fh3}\nGETATTR                {fh3}\nLOOKUP \"compC\"         {fh4}\nGETATTR                {fh4}\nGETFH",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 3,
      "text": "In this example, the PUTFH (Section 18.19) operation explicitly sets the current filehandle value while the result of each LOOKUP operation sets the current filehandle value to the resultant file system object. Also, the client is able to insert GETATTR operations using the current filehandle as an argument.",
      "ja": "各ルックアップ操作の結果が得られたファイル・システム・オブジェクトに現在のファイルハンドル値を設定している。この例では、PUTFH（セクション18.19）の動作は、明示的に現在のファイルハンドル値を設定しますまた、クライアントは引数として現在のファイルハンドルを使用してGETATTR操作を挿入することができます。"
    },
    {
      "indent": 3,
      "text": "The PUTROOTFH (Section 18.21) and PUTPUBFH (Section 18.20) operations also set the current filehandle. The above example would replace \"PUTFH fh1\" with PUTROOTFH or PUTPUBFH with no filehandle argument in order to achieve the same effect (on the assumption that \"compA\" is directly below the root of the namespace).",
      "ja": "PUTROOTFH（セクション18.21）とPUTPUBFH（セクション18.20）の操作は、現在のファイルハンドルを設定します。上記の例では、（「コンパ」は、直接、名前空間のルートの下にあると仮定して）同じ効果を達成するために、なしファイルハンドル引数でPUTROOTFHまたはPUTPUBFHで「PUTFH FH1」を置き換えます。"
    },
    {
      "indent": 3,
      "text": "Along with the current filehandle, there is a saved filehandle. While the current filehandle is set as the result of operations like LOOKUP, the saved filehandle must be set directly with the use of the SAVEFH operation. The SAVEFH operation copies the current filehandle value to the saved value. The saved filehandle value is used in combination with the current filehandle value for the LINK and RENAME operations. The RESTOREFH operation will copy the saved filehandle value to the current filehandle value; as a result, the saved filehandle value may be used a sort of \"scratch\" area for the client's series of operations.",
      "ja": "現在のファイルハンドルとともに、保存されたファイルハンドルがあります。現在のファイルハンドルをLOOKUPなどの操作の結果として設定されているときに、保存されたファイルハンドルはSAVEFH操作を使用して直接設定しなければなりません。 SAVEFH操作コピー保存された値に現在のファイルハンドル値。保存されたファイルハンドル値は、リンクの現在のファイルハンドル値と組み合わせて使用​​され、操作の名前を変更しています。 RESTOREFH操作は、現在のファイルハンドルの値に保存されたファイルハンドル値をコピーします。結果として、保存されたファイルハンドル値は、操作のクライアントのシリーズの「スクラッチ」領域の並べ替えを使用することができます。"
    },
    {
      "indent": 0,
      "text": "16.2.3.1.2. Current Stateid",
      "section_title": true,
      "ja": "16.2.3.1.2。現在のstateid"
    },
    {
      "indent": 3,
      "text": "With NFSv4.1, additions of a current stateid and a saved stateid have been made to the COMPOUND processing environment; this allows for the passing of stateids between operations. There are no changes to the syntax of the protocol, only changes to the semantics of a few operations.",
      "ja": "NFSv4.1では、現在のstateidと保存のstateidの追加はCOMPOUND処理環境に行われました。これは、操作の間のstateidsの受け渡しが可能になります。プロトコルの構文への変更、いくつかの操作の意味論への唯一の変更はありません。"
    },
    {
      "indent": 3,
      "text": "A \"current stateid\" is the stateid that is associated with the current filehandle. The current stateid may only be changed by an operation that modifies the current filehandle or returns a stateid.",
      "ja": "「現在のstateidは、」現在のファイルハンドルに関連付けられているのstateidです。現在のstateidは、現在のファイルハンドルを変更またはのstateidを戻す操作によって変更することができます。"
    },
    {
      "indent": 3,
      "text": "If an operation returns a stateid, it MUST set the current stateid to the returned value. If an operation sets the current filehandle but does not return a stateid, the current stateid MUST be set to the all-zeros special stateid, i.e., (seqid, other) = (0, 0). If an operation uses a stateid as an argument but does not return a stateid, the current stateid MUST NOT be changed. For example, PUTFH, PUTROOTFH, and PUTPUBFH will change the current server state from {ocfh, (osid)} to {cfh, (0, 0)}, while LOCK will change the current state from {cfh, (osid} to {cfh, (nsid)}. Operations like LOOKUP that transform a current filehandle and component name into a new current filehandle will also change the current state to {0, 0}. The SAVEFH and RESTOREFH operations will save and restore both the current filehandle and the current stateid as a set.",
      "ja": "操作がたstateidを返した場合、それが返された値を現在のstateidを設定しなければなりません。操作は、現在のファイルハンドルを設定しかしのstateidを返さない場合は、現在のstateidはすべてゼロに特別のstateid、すなわち、（SEQID、その他）=設定しなければならない（0,0）。操作は、引数としてのstateidを使用していますが、たstateidを返さない場合は、現在のstateidは変更してはいけません。 LOCKは{CFH、（OSID}から{に現在の状態を変更する一方、例えば、PUTFH、PUTROOTFH、及びPUTPUBFHは、{CFH、（0、0）}と{OCFH、（OSID）}から現在のサーバの状態を変化させますCFH、（NSID）}。新しい現在のファイルハンドルに現在のファイルハンドルおよびコンポーネント名を変換LOOKUPような操作はまた、{0、現在の状態が変更され、0}。SAVEFHとRESTOREFH操作は、現在のファイルハンドルの両方を保存して復元し、セットとして現在のstateid。"
    },
    {
      "indent": 3,
      "text": "The following example is the common case of a simple READ operation with a normal stateid showing that the PUTFH initializes the current stateid to (0, 0). The subsequent READ with stateid (sid1) leaves the current stateid unchanged.",
      "ja": "次の例は、PUTFH（0、0）現在のstateidを初期化することを示す通常のstateidを有する単純なREAD動作の一般的なケースです。 stateid（SID1）とそれに続くREADは現在のstateidは変更されません。"
    },
    {
      "indent": 7,
      "text": "PUTFH fh1                             - -> {fh1, (0, 0)}\nREAD (sid1), 0, 1024      {fh1, (0, 0)} -> {fh1, (0, 0)}",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 3,
      "text": "This next example performs an OPEN with the root filehandle and, as a result, generates stateid (sid1). The next operation specifies the READ with the argument stateid set such that (seqid, other) are equal to (1, 0), but the current stateid set by the previous operation is actually used when the operation is evaluated. This allows correct interaction with any existing, potentially conflicting, locks.",
      "ja": "この次の例では、ルートファイルハンドルとOPENを実行し、結果としてのstateid（SID1）を生成します。次の操作は、引数でREADを指定し（他のSEQIDが、）（1、0）に等しいが、操作が評価されるときに、前の操作により設定された電流のstateidが実際に使用されるように設定のstateid。これは、既存の、潜在的に競合、ロックとの正しい相互作用することができます。"
    },
    {
      "indent": 7,
      "text": "PUTROOTFH                             - -> {fh1, (0, 0)}\nOPEN \"compA\"              {fh1, (0, 0)} -> {fh2, (sid1)}\nREAD (1, 0), 0, 1024      {fh2, (sid1)} -> {fh2, (sid1)}\nCLOSE (1, 0)              {fh2, (sid1)} -> {fh2, (sid2)}",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 3,
      "text": "This next example is similar to the second in how it passes the stateid sid2 generated by the LOCK operation to the next READ operation. This allows the client to explicitly surround a single I/O operation with a lock and its appropriate stateid to guarantee correctness with other client locks. The example also shows how SAVEFH and RESTOREFH can save and later reuse a filehandle and stateid, passing them as the current filehandle and stateid to a READ operation.",
      "ja": "次の例は、次のREAD動作にLOCK操作によって生成されたのstateidのSID2を渡す方法で第二と同様です。これは、クライアントが明示的にロックし、他のクライアントのロックと正確さを保証するための適切なのstateidで単一I / O操作を包囲することができます。例では、READ動作に現在のファイルハンドルとのstateidとしてそれらを渡し、SAVEFHとRESTOREFHを保存し、後でファイルハンドルとのstateidを再利用する方法を示しています。"
    },
    {
      "indent": 7,
      "text": "PUTFH fh1                             - -> {fh1, (0, 0)}\nLOCK 0, 1024, (sid1)      {fh1, (sid1)} -> {fh1, (sid2)}\nREAD (1, 0), 0, 1024      {fh1, (sid2)} -> {fh1, (sid2)}\nLOCKU 0, 1024, (1, 0)     {fh1, (sid2)} -> {fh1, (sid3)}\nSAVEFH                    {fh1, (sid3)} -> {fh1, (sid3)}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "PUTFH fh2 {fh1, (sid3)} -> {fh2, (0, 0)} WRITE (1, 0), 0, 1024 {fh2, (0, 0)} -> {fh2, (0, 0)}",
      "ja": "PUTFH FH2 {FH1、（SID3）}  - > {FH2、（0、0）} WRITE（1、0）、0 1024 {FH2、（0、0）}  - > {FH2、（0,0）}"
    },
    {
      "indent": 7,
      "text": "RESTOREFH {fh2, (0, 0)} -> {fh1, (sid3)} READ (1, 0), 1024, 1024 {fh1, (sid3)} -> {fh1, (sid3)}",
      "ja": "RESTOREFH {FH2、（0、0）}  - > {FH1、（SID3）} READ（1、0）1024 1024 {FH1、（SID3）}  - > {FH1、（SID3）}"
    },
    {
      "indent": 33,
      "text": "Figure 5",
      "ja": "図5"
    },
    {
      "indent": 3,
      "text": "The final example shows a disallowed use of the current stateid. The client is attempting to implicitly pass an anonymous special stateid, (0,0), to the READ operation. The server MUST return NFS4ERR_BAD_STATEID in the reply to the READ operation.",
      "ja": "最後の例は、現在のstateidの不許可使用を示します。クライアントは、暗黙的にREAD動作に、匿名の特別なstateid、（0,0）を通過しようとしています。サーバーは、読み出し動作に応答してNFS4ERR_BAD_STATEIDを返さなければなりません。"
    },
    {
      "indent": 7,
      "text": "PUTFH fh1                             - -> {fh1, (0, 0)}\nREAD (1, 0), 0, 1024      {fh1, (0, 0)} -> NFS4ERR_BAD_STATEID",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 6",
      "ja": "図6"
    },
    {
      "indent": 0,
      "text": "16.2.4. ERRORS",
      "section_title": true,
      "ja": "16.2.4. エラー"
    },
    {
      "indent": 3,
      "text": "COMPOUND will of course return every error that each operation on the fore channel can return (see Table 6). However, if COMPOUND returns zero operations, obviously the error returned by COMPOUND has nothing to do with an error returned by an operation. The list of errors COMPOUND will return if it processes zero operations include:",
      "ja": "化合物の進路前方チャネル上の各操作が返す（表6参照）ことができるすべてのエラーを返します。化合物がゼロの操作を返す場合は、化合物によって返された、明らかにエラーが操作によって返されたエラーとは何の関係もありません。それがゼロの操作が含まれている場合、エラー処理化合物のリストが返されます。"
    },
    {
      "indent": 26,
      "text": "COMPOUND Error Returns",
      "ja": "COMPOUNDエラーを返します"
    },
    {
      "indent": 3,
      "text": "+------------------------------+------------------------------------+\n| Error                        | Notes                              |\n+------------------------------+------------------------------------+\n| NFS4ERR_BADCHAR              | The tag argument has a character   |\n|                              | the replier does not support.      |\n| NFS4ERR_BADXDR               |                                    |\n| NFS4ERR_DELAY                |                                    |\n| NFS4ERR_INVAL                | The tag argument is not in UTF-8   |\n|                              | encoding.                          |\n| NFS4ERR_MINOR_VERS_MISMATCH  |                                    |\n| NFS4ERR_SERVERFAULT          |                                    |\n| NFS4ERR_TOO_MANY_OPS         |                                    |\n| NFS4ERR_REP_TOO_BIG          |                                    |\n| NFS4ERR_REP_TOO_BIG_TO_CACHE |                                    |\n| NFS4ERR_REQ_TOO_BIG          |                                    |\n+------------------------------+------------------------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 9",
      "ja": "表9"
    },
    {
      "indent": 0,
      "text": "17. Operations: REQUIRED, RECOMMENDED, or OPTIONAL",
      "section_title": true,
      "ja": "17.操作：おすすめREQUIRED、またはOPTIONAL"
    },
    {
      "indent": 3,
      "text": "The following tables summarize the operations of the NFSv4.1 protocol and the corresponding designation of REQUIRED, RECOMMENDED, and OPTIONAL to implement or MUST NOT implement. The designation of MUST NOT implement is reserved for those operations that were defined in NFSv4.0 and MUST NOT be implemented in NFSv4.1.",
      "ja": "以下の表は、実装するために、または実装してはいけません推奨、NFSv4.1プロトコルと必要な対応する指定の動作を要約すると、OPTIONAL。実装してはいけませんの指定はNFSv4.0で定義され、NFSv4.1に実装してはいけませんこれらの操作のために予約されています。"
    },
    {
      "indent": 3,
      "text": "For the most part, the REQUIRED, RECOMMENDED, or OPTIONAL designation for operations sent by the client is for the server implementation. The client is generally required to implement the operations needed for the operating environment for which it serves. For example, a read-only NFSv4.1 client would have no need to implement the WRITE operation and is not required to do so.",
      "ja": "ほとんどの部分については、REQUIREDは、推奨、またはクライアントから送信された操作のためのオプションの指定は、サーバの実装のためです。クライアントは一般的に、それが機能するための動作環境のために必要な操作を実現するために必要とされます。例えば、読み取り専用NFSv4.1のクライアントは、書き込み動作を実装する必要がないだろうし、そうする必要はありません。"
    },
    {
      "indent": 3,
      "text": "The REQUIRED or OPTIONAL designation for callback operations sent by the server is for both the client and server. Generally, the client has the option of creating the backchannel and sending the operations on the fore channel that will be a catalyst for the server sending callback operations. A partial exception is CB_RECALL_SLOT; the only way the client can avoid supporting this operation is by not creating a backchannel.",
      "ja": "サーバーから送信されたコールバック操作のための必須またはオプションの指定は、クライアントとサーバーの両方のためです。一般的に、クライアントはバックチャネルを作成し、コールバックオペレーションを送信するサーバのための触媒となり、前部チャネル上で操作を送信するオプションがあります。部分的な例外はCB_RECALL_SLOTです。クライアントがこの操作をサポートして避けることができる唯一の方法は、バックチャネルを作成しないことです。"
    },
    {
      "indent": 3,
      "text": "Since this is a summary of the operations and their designation, there are subtleties that are not presented here. Therefore, if there is a question of the requirements of implementation, the operation descriptions themselves must be consulted along with other relevant explanatory text within this specification.",
      "ja": "これは事業の概要とその名称であるので、ここで提示されていない微妙な点があります。実装の要件の問題がある場合はそのため、操作の説明自体は、この明細書内の他の関連する説明文と一緒に相談しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The abbreviations used in the second and third columns of the table are defined as follows.",
      "ja": "次のように表の第2列と第3列で使用された略語が定義されています。"
    },
    {
      "indent": 3,
      "text": "REQ REQUIRED to implement",
      "ja": "実装するために必要なREQ"
    },
    {
      "indent": 3,
      "text": "REC RECOMMEND to implement",
      "ja": "RECは、実装することをお勧めします"
    },
    {
      "indent": 3,
      "text": "OPT OPTIONAL to implement",
      "ja": "実装するには、オプションのOPT"
    },
    {
      "indent": 3,
      "text": "MNI MUST NOT implement",
      "ja": "MNIは実装してはなりません"
    },
    {
      "indent": 3,
      "text": "For the NFSv4.1 features that are OPTIONAL, the operations that support those features are OPTIONAL, and the server would return NFS4ERR_NOTSUPP in response to the client's use of those operations. If an OPTIONAL feature is supported, it is possible that a set of operations related to the feature become REQUIRED to implement. The third column of the table designates the feature(s) and if the operation is REQUIRED or OPTIONAL in the presence of support for the feature.",
      "ja": "オプションであるNFSv4.1機能については、これらの機能をサポートする操作は任意であり、サーバはそれらの操作のクライアントの使用に応じてNFS4ERR_NOTSUPPを返します。オプション機能がサポートされている場合は、機能に関連する一連の操作が必須実装になっている可能性があります。テーブルの第3列は、機能（複数可）を指定して操作が必要または機能に対するサポートの存在下でのオプションの場合。"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL features identified and their abbreviations are as follows:",
      "ja": "オプション機能を識別し、次のように彼らの略語は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "pNFS Parallel NFS",
      "ja": "pNFSのは、NFSをパラレル"
    },
    {
      "indent": 3,
      "text": "FDELG File Delegations",
      "ja": "FDELGファイルの代表団"
    },
    {
      "indent": 3,
      "text": "DDELG Directory Delegations",
      "ja": "DDELGディレクトリ代表団"
    },
    {
      "indent": 32,
      "text": "Operations",
      "ja": "オペレーション"
    },
    {
      "indent": 3,
      "text": "+----------------------+------------+--------------+----------------+\n| Operation            | REQ, REC,  | Feature      | Definition     |\n|                      | OPT, or    | (REQ, REC,   |                |\n|                      | MNI        | or OPT)      |                |\n+----------------------+------------+--------------+----------------+\n| ACCESS               | REQ        |              | Section 18.1   |\n| BACKCHANNEL_CTL      | REQ        |              | Section 18.33  |\n| BIND_CONN_TO_SESSION | REQ        |              | Section 18.34  |\n| CLOSE                | REQ        |              | Section 18.2   |\n| COMMIT               | REQ        |              | Section 18.3   |\n| CREATE               | REQ        |              | Section 18.4   |\n| CREATE_SESSION       | REQ        |              | Section 18.36  |\n| DELEGPURGE           | OPT        | FDELG (REQ)  | Section 18.5   |\n| DELEGRETURN          | OPT        | FDELG,       | Section 18.6   |\n|                      |            | DDELG, pNFS  |                |\n|                      |            | (REQ)        |                |\n| DESTROY_CLIENTID     | REQ        |              | Section 18.50  |\n| DESTROY_SESSION      | REQ        |              | Section 18.37  |\n| EXCHANGE_ID          | REQ        |              | Section 18.35  |\n| FREE_STATEID         | REQ        |              | Section 18.38  |\n| GETATTR              | REQ        |              | Section 18.7   |\n| GETDEVICEINFO        | OPT        | pNFS (REQ)   | Section 18.40  |\n| GETDEVICELIST        | OPT        | pNFS (OPT)   | Section 18.41  |\n| GETFH                | REQ        |              | Section 18.8   |\n| GET_DIR_DELEGATION   | OPT        | DDELG (REQ)  | Section 18.39  |\n| LAYOUTCOMMIT         | OPT        | pNFS (REQ)   | Section 18.42  |\n| LAYOUTGET            | OPT        | pNFS (REQ)   | Section 18.43  |\n| LAYOUTRETURN         | OPT        | pNFS (REQ)   | Section 18.44  |\n| LINK                 | OPT        |              | Section 18.9   |\n| LOCK                 | REQ        |              | Section 18.10  |\n| LOCKT                | REQ        |              | Section 18.11  |\n| LOCKU                | REQ        |              | Section 18.12  |\n| LOOKUP               | REQ        |              | Section 18.13  |\n| LOOKUPP              | REQ        |              | Section 18.14  |\n| NVERIFY              | REQ        |              | Section 18.15  |\n| OPEN                 | REQ        |              | Section 18.16  |\n| OPENATTR             | OPT        |              | Section 18.17  |\n| OPEN_CONFIRM         | MNI        |              | N/A            |\n| OPEN_DOWNGRADE       | REQ        |              | Section 18.18  |\n| PUTFH                | REQ        |              | Section 18.19  |\n| PUTPUBFH             | REQ        |              | Section 18.20  |\n| PUTROOTFH            | REQ        |              | Section 18.21  |\n| READ                 | REQ        |              | Section 18.22  |\n| READDIR              | REQ        |              | Section 18.23  |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| READLINK             | OPT        |              | Section 18.24  |\n| RECLAIM_COMPLETE     | REQ        |              | Section 18.51  |\n| RELEASE_LOCKOWNER    | MNI        |              | N/A            |\n| REMOVE               | REQ        |              | Section 18.25  |\n| RENAME               | REQ        |              | Section 18.26  |\n| RENEW                | MNI        |              | N/A            |\n| RESTOREFH            | REQ        |              | Section 18.27  |\n| SAVEFH               | REQ        |              | Section 18.28  |\n| SECINFO              | REQ        |              | Section 18.29  |\n| SECINFO_NO_NAME      | REC        | pNFS file    | Section 18.45, |\n|                      |            | layout (REQ) | Section 13.12  |\n| SEQUENCE             | REQ        |              | Section 18.46  |\n| SETATTR              | REQ        |              | Section 18.30  |\n| SETCLIENTID          | MNI        |              | N/A            |\n| SETCLIENTID_CONFIRM  | MNI        |              | N/A            |\n| SET_SSV              | REQ        |              | Section 18.47  |\n| TEST_STATEID         | REQ        |              | Section 18.48  |\n| VERIFY               | REQ        |              | Section 18.31  |\n| WANT_DELEGATION      | OPT        | FDELG (OPT)  | Section 18.49  |\n| WRITE                | REQ        |              | Section 18.32  |\n+----------------------+------------+--------------+----------------+",
      "raw": true
    },
    {
      "indent": 28,
      "text": "Callback Operations",
      "ja": "コールバックオペレーション"
    },
    {
      "indent": 3,
      "text": "+-------------------------+-----------+-------------+---------------+\n| Operation               | REQ, REC, | Feature     | Definition    |\n|                         | OPT, or   | (REQ, REC,  |               |\n|                         | MNI       | or OPT)     |               |\n+-------------------------+-----------+-------------+---------------+\n| CB_GETATTR              | OPT       | FDELG (REQ) | Section 20.1  |\n| CB_LAYOUTRECALL         | OPT       | pNFS (REQ)  | Section 20.3  |\n| CB_NOTIFY               | OPT       | DDELG (REQ) | Section 20.4  |\n| CB_NOTIFY_DEVICEID      | OPT       | pNFS (OPT)  | Section 20.12 |\n| CB_NOTIFY_LOCK          | OPT       |             | Section 20.11 |\n| CB_PUSH_DELEG           | OPT       | FDELG (OPT) | Section 20.5  |\n| CB_RECALL               | OPT       | FDELG,      | Section 20.2  |\n|                         |           | DDELG, pNFS |               |\n|                         |           | (REQ)       |               |\n| CB_RECALL_ANY           | OPT       | FDELG,      | Section 20.6  |\n|                         |           | DDELG, pNFS |               |\n|                         |           | (REQ)       |               |\n| CB_RECALL_SLOT          | REQ       |             | Section 20.8  |\n| CB_RECALLABLE_OBJ_AVAIL | OPT       | DDELG, pNFS | Section 20.7  |\n|                         |           | (REQ)       |               |\n| CB_SEQUENCE             | OPT       | FDELG,      | Section 20.9  |\n|                         |           | DDELG, pNFS |               |\n|                         |           | (REQ)       |               |\n| CB_WANTS_CANCELLED      | OPT       | FDELG,      | Section 20.10 |\n|                         |           | DDELG, pNFS |               |\n|                         |           | (REQ)       |               |\n+-------------------------+-----------+-------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18. NFSv4.1 Operations",
      "section_title": true,
      "ja": "18. NFSv4.1操作"
    },
    {
      "indent": 0,
      "text": "18.1. Operation 3: ACCESS - Check Access Rights",
      "section_title": true,
      "ja": "18.1. 動作3：アクセス - アクセス権限をチェック"
    },
    {
      "indent": 0,
      "text": "18.1.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.1.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "const ACCESS4_READ      = 0x00000001;\nconst ACCESS4_LOOKUP    = 0x00000002;\nconst ACCESS4_MODIFY    = 0x00000004;\nconst ACCESS4_EXTEND    = 0x00000008;\nconst ACCESS4_DELETE    = 0x00000010;\nconst ACCESS4_EXECUTE   = 0x00000020;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct ACCESS4args {\n        /* CURRENT_FH: object */\n        uint32_t        access;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.1.2. RESULTS",
      "section_title": true,
      "ja": "18.1.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct ACCESS4resok {\n        uint32_t        supported;\n        uint32_t        access;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union ACCESS4res switch (nfsstat4 status) {\n case NFS4_OK:\n         ACCESS4resok   resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.1.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.1.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "ACCESS determines the access rights that a user, as identified by the credentials in the RPC request, has with respect to the file system object specified by the current filehandle. The client encodes the set of access rights that are to be checked in the bit mask \"access\". The server checks the permissions encoded in the bit mask. If a status of NFS4_OK is returned, two bit masks are included in the response. The first, \"supported\", represents the access rights for which the server can verify reliably. The second, \"access\", represents the access rights available to the user for the filehandle provided. On success, the current filehandle retains its value.",
      "ja": "ACCESSは、RPC要求に資格情報によって識別されるユーザは、現在のファイルハンドルに指定されたファイル・システム・オブジェクトに対して有するアクセス権を決定します。クライアントは、ビットマスク「アクセス」にチェックされるアクセス権のセットを符号化します。サーバはビットマスクで符号化権限をチェックします。 NFS4_OKのステータスが返された場合、2枚のビットマスクが応答に含まれています。 、まず、「サポート」は、サーバが確実に確認することができますするアクセス権を表します。二、「アクセス」、提供ファイルハンドルのためにユーザに利用可能なアクセス権を表します。成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 3,
      "text": "Note that the reply's supported and access fields MUST NOT contain more values than originally set in the request's access field. For example, if the client sends an ACCESS operation with just the ACCESS4_READ value set and the server supports this value, the server MUST NOT set more than ACCESS4_READ in the supported field even if it could have reliably checked other values.",
      "ja": "もともと要求のアクセスフィールドに設定よりも、返信のサポートおよびアクセスのフィールドに複数の値を含んではならないことに注意してください。クライアントは設定だけACCESS4_READ値にアクセス動作を送信し、サーバーがこの値をサポートしている場合たとえば、サーバーは、それが確実に他の値をチェックすることができた場合でも、サポート分野でACCESS4_READ以上に設定してはいけません。"
    },
    {
      "indent": 3,
      "text": "The reply's access field MUST NOT contain more values than the supported field.",
      "ja": "返信のアクセスフィールドは、サポートされているフィールドより多くの値を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "The results of this operation are necessarily advisory in nature. A return status of NFS4_OK and the appropriate bit set in the bit mask do not imply that such access will be allowed to the file system object in the future. This is because access rights can be revoked by the server at any time.",
      "ja": "この操作の結果は、自然の中で必然的に助言しています。 NFS4_OKの戻りステータスとビットマスクに設定された適切なビットは、そのようなアクセスは、将来的にファイル・システム・オブジェクトに許可されることを意味するものではありません。アクセス権限は、いつでもサーバーによって取り消すことができるからです。"
    },
    {
      "indent": 3,
      "text": "The following access permissions may be requested:",
      "ja": "以下のアクセス許可を要求することができます。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_READ Read data from file or read a directory.",
      "ja": "ACCESS4_READ読むデータファイルまたはディレクトリをお読みください。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_LOOKUP Look up a name in a directory (no meaning for non-directory objects).",
      "ja": "ACCESS4_LOOKUPディレクトリ（非ディレクトリオブジェクトのための意味無し）で名前を検索します。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_MODIFY Rewrite existing file data or modify existing directory entries.",
      "ja": "既存のファイルのデータを書き換えたり、既存のディレクトリエントリを変更ACCESS4_MODIFY。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_EXTEND Write new data or add directory entries.",
      "ja": "ACCESS4_EXTENDは、新しいデータを書き込むか、ディレクトリエントリを追加します。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_DELETE Delete an existing directory entry.",
      "ja": "ACCESS4_DELETEは、既存のディレクトリエントリを削除します。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_EXECUTE Execute a regular file (no meaning for a directory).",
      "ja": "ACCESS4_EXECUTEは、通常のファイル（ディレクトリの意味無し）を実行します。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 3,
      "text": "ACCESS4_EXECUTE is a challenging semantic to implement because NFS provides remote file access, not remote execution. This leads to the following:",
      "ja": "ACCESS4_EXECUTEは、NFSはリモートファイルアクセスではなく、リモート実行を提供するため、実装するための挑戦的なセマンティックです。これは、次のようになります："
    },
    {
      "indent": 3,
      "text": "o Whether or not a regular file is executable ought to be the responsibility of the NFS client and not the server. And yet the ACCESS operation is specified to seemingly require a server to own that responsibility.",
      "ja": "通常のファイルは、NFSクライアントではなくサーバーの責任であるべき実行可能であるか否かを、O。そして、まだアクセス動作は一見その責任を所有するサーバーを必要とするように指定されています。"
    },
    {
      "indent": 3,
      "text": "o When a client executes a regular file, it has to read the file from the server. Strictly speaking, the server should not allow the client to read a file being executed unless the user has read permissions on the file. Requiring explicit read permissions on executable files in order to access them over NFS is not going to be acceptable to some users and storage administrators. Historically, NFS servers have allowed a user to READ a file if the user has execute access to the file.",
      "ja": "クライアントは、通常のファイルを実行すると、O、それがサーバーからファイルを読み込む必要があります。厳密にユーザーがファイルのパーミッションを読んでいない限り、サーバーは、クライアントが実行されているファイルを読み取ることができるようにはならない、話します。 NFS上でそれらにアクセスするために、実行可能ファイルに明示的に読み取りアクセス許可を必要とするが、一部のユーザーおよびストレージ管理者に受け入れられるだろうされていません。歴史的に、NFSサーバーでは、ユーザーがファイルへのアクセスを実行している場合、ユーザーがファイルを読み取ることができました。"
    },
    {
      "indent": 3,
      "text": "As a practical example, the UNIX specification [52] states that an implementation claiming conformance to UNIX may indicate in the access() programming interface's result that a privileged user has execute rights, even if no execute permission bits are set on the regular file's attributes. It is possible to claim conformance to the UNIX specification and instead not indicate execute rights in that situation, which is true for some operating environments. Suppose the operating environments of the client and server are implementing the access() semantics for privileged users differently, and the ACCESS operation implementations of the client and server follow their respective access() semantics. This can cause undesired behavior:",
      "ja": "実用的な例として、UNIX仕様[52]は、特権ユーザーが何も実行許可ビットが通常のファイルの属性に設定されていない場合でも、実行権限を持っていることのインターフェイスの結果をプログラミング）（UNIXへの適合性を主張する実装は、アクセスに示すことと述べています。 UNIXの仕様への適合を主張し、代わりにいくつかの動作環境のために真である、そのような状況で実行権限を示すものではありませすることが可能です。クライアントとサーバの動作環境が異なり、特権ユーザーのアクセス（）のセマンティクスを実装している、そしてクライアントとサーバーのアクセス動作の実装は、それぞれのアクセス（）のセマンティクスに従うと仮定します。これは、望ましくない動作を引き起こす可能性があります："
    },
    {
      "indent": 3,
      "text": "o Suppose the client's access() interface returns X_OK if the user is privileged and no execute permission bits are set on the regular file's attribute, and the server's access() interface does not return X_OK in that situation. Then the client will be unable to execute files stored on the NFS server that could be executed if stored on a non-NFS file system.",
      "ja": "Oユーザーが特権ではありませんし、何の許可ビットを実行した場合、クライアントのアクセス（）インタフェースはX_OKを返すとし、通常のファイルの属性に設定されており、サーバのアクセス（）インタフェースは、そのような状況でX_OKを返しません。その後、クライアントは非NFSファイルシステムに保存された場合に実行することができNFSサーバに保存されたファイルを実行することができません。"
    },
    {
      "indent": 3,
      "text": "o Suppose the client's access() interface does not return X_OK if the user is privileged, and no execute permission bits are set on the regular file's attribute, and the server's access() interface does return X_OK in that situation. Then:",
      "ja": "Oクライアントのアクセス（）インタフェースは、ユーザが特権である場合X_OKを返さないし、何の許可ビットを実行していないと仮定し、通常のファイルの属性に設定されており、サーバのアクセス（）インタフェースは、そのような状況でX_OKを返すん。その後："
    },
    {
      "indent": 6,
      "text": "* The client will be able to execute files stored on the NFS server that could be executed if stored on a non-NFS file system, unless the client's execution subsystem also checks for execute permission bits.",
      "ja": "*クライアントは、クライアントの実行サブシステムはまた、許可ビットを実行するためにチェックしていない限り、非NFSファイルシステムに保存された場合に実行することができNFSサーバに保存されたファイルを実行することができるようになります。"
    },
    {
      "indent": 6,
      "text": "* Even if the execution subsystem is checking for execute permission bits, there are more potential issues. For example, suppose the client is invoking access() to build a \"path search table\" of all executable files in the user's \"search path\", where the path is a list of directories each containing executable files. Suppose there are two files each in separate directories of the search path, such that files have the same component name. In the first directory the file has no execute permission bits set, and in the second directory the file has execute bits set. The path search table will indicate that the first directory has the executable file, but the execute subsystem will fail to execute it. The command shell might fail to try the second file in the second directory. And even if it did, this is a potential performance issue. Clearly, the desired outcome for the client is for the path search table to not contain the first file.",
      "ja": "*実行サブシステムが実行許可ビットをチェックしても、より多くの潜在的な問題があります。例えば、クライアントはパスがディレクトリのリストをそれぞれ含む実行可能ファイルがあるユーザーの「検索パス」内のすべての実行可能ファイルの「経路検索テーブル」を構築するためのアクセスを（）を呼び出すされているとします。ファイルが同じコンポーネント名を持つように検索パスの別々のディレクトリ内の2つのファイルそれぞれが、そこにあると仮定します。最初のディレクトリ内のファイルには設定許可ビットを実行していない、及び第2のディレクトリにファイルが設定されたビットを実行しました。パスサーチテーブルには、最初のディレクトリは、実行可能ファイルを持っていることを示しますが、実行するサブシステムは、それを実行に失敗します。コマンドシェルは、2番目のディレクトリにある第二のファイルを試して失敗することがあります。そして、それがなかった場合でも、これは潜在的なパフォーマンスの問題です。経路検索テーブルは、最初のファイルが含まれていないためにのために明らかに、クライアントのために望ましい結果があります。"
    },
    {
      "indent": 3,
      "text": "To deal with the problems described above, the \"smart client, stupid server\" principle is used. The client owns overall responsibility for determining execute access and relies on the server to parse the execution permissions within the file's mode, acl, and dacl attributes. The rules for the client and server follow:",
      "ja": "上記の問題に対処するには、「スマートクライアント、愚かなサーバー」の原則が使用されます。クライアントがアクセスを実行し、ファイルのモード、ACL、およびDACL属性内の実行権限を解析するために、サーバーに依存して決定するための全体的な責任を保有しています。クライアントとサーバーのフォローのための規則："
    },
    {
      "indent": 3,
      "text": "o If the client is sending ACCESS in order to determine if the user can read the file, the client SHOULD set ACCESS4_READ in the request's access field.",
      "ja": "ユーザーがファイルを読むことができるかどうかを判断するために、クライアントがアクセスを送信している場合は、O、クライアントはリクエストのアクセスフィールドにACCESS4_READを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the client's operating environment only grants execution to the user if the user has execute access according to the execute permissions in the mode, acl, and dacl attributes, then if the client wants to determine execute access, the client SHOULD send an ACCESS request with ACCESS4_EXECUTE bit set in the request's access field.",
      "ja": "ユーザが実行モードでアクセス権、ACL、およびDACLの属性に応じたアクセスを実行している場合は、O、クライアントの動作環境は、クライアントがアクセスを実行するかを決定したい場合、クライアントがアクセス要求を送るべきで、ユーザーに実行を許可した場合ACCESS4_EXECUTEでリクエストのアクセスフィールドにビットセット。"
    },
    {
      "indent": 3,
      "text": "o If the client's operating environment grants execution to the user even if the user does not have execute access according to the execute permissions in the mode, acl, and dacl attributes, then if the client wants to determine execute access, it SHOULD send an ACCESS request with both the ACCESS4_EXECUTE and ACCESS4_READ bits set in the request's access field. This way, if any read or execute permission grants the user read or execute access (or if the server interprets the user as privileged), as indicated by the presence of ACCESS4_EXECUTE and/or ACCESS4_READ in the reply's access field, the client will be able to grant the user execute access to the file.",
      "ja": "Oユーザーへのクライアントの動作環境助成金の実行は、ユーザーが持っていない場合でも場合モード、ACLでの実行権限に応じたアクセスを実行し、クライアントがアクセスを実行するかを決定したい場合DACLの属性は、それから、それはアクセスを送るべきですACCESS4_EXECUTEとリクエストのアクセスフィールドに設定さACCESS4_READビットの両方を使用して要求。この方法で、任意の読み取りまたは実行権限を、ユーザーが読み取りまたはアクセスを実行する（またはサーバーがのように特権ユーザを解釈している場合）、ACCESS4_EXECUTEおよび/または応答のアクセス分野におけるACCESS4_READの存在によって示されるように、クライアントができるようになります許可している場合許可するユーザーがファイルへのアクセスを実行します。"
    },
    {
      "indent": 3,
      "text": "o If the server supports execute permission bits, or some other method for denoting executability (e.g., the suffix of the name of the file might indicate execute), it MUST check only execute permissions, not read permissions, when determining whether or not the reply will have ACCESS4_EXECUTE set in the access field. The server MUST NOT also examine read permission bits when determining whether or not the reply will have ACCESS4_EXECUTE set in the access field. Even if the server's operating environment would grant execute access to the user (e.g., the user is privileged), the server MUST NOT reply with ACCESS4_EXECUTE set in reply's access field unless there is at least one execute permission bit set in the mode, acl, or dacl attributes. In the case of acl and dacl, the \"one execute permission bit\" MUST be an ACE4_EXECUTE bit set in an ALLOW ACE.",
      "ja": "サーバは（例えば、ファイル名の接尾辞が実行示している可能性があります）実行可能を示すために許可ビット、または他のいくつかの方法を実行してサポートしている場合は、O、か否かの応答を決定する際に、アクセス権を読んで、権限だけを実行しませチェックしなければなりませんACCESS4_EXECUTEがアクセスフィールドに設定されています。返信がアクセスフィールドに設定ACCESS4_EXECUTEを持っているかどうかを決定する際、サーバーにも、読み取り許可ビットを調べてはなりません。サーバの動作環境は、ユーザーへのアクセスを実行する許可しまう場合であっても（例えば、ユーザーが特権である）少なくとも一つのモード、ACLに設定された許可ビットを実行しない限り、サーバーは応答のアクセスフィールドに設定ACCESS4_EXECUTEで返答してはなりません、またはDACL属性。 ACLおよびDACLの場合、ACE4_EXECUTE許可ACEに設定されたビットでなければなりません「一つは許可ビットを実行します」。"
    },
    {
      "indent": 3,
      "text": "o If the server does not support execute permission bits or some other method for denoting executability, it MUST NOT set ACCESS4_EXECUTE in the reply's supported and access fields. If the client set ACCESS4_EXECUTE in the ACCESS request's access field, and ACCESS4_EXECUTE is not set in the reply's supported field, then the client will have to send an ACCESS request with the ACCESS4_READ bit set in the request's access field.",
      "ja": "サーバが許可ビットまたは実行可能を示すための他のいくつかの方法を実行しサポートしていない場合は、O、それは回答者のサポートおよびアクセスの分野でACCESS4_EXECUTEを設定してはいけません。クライアントがアクセス要求のアクセスフィールドでACCESS4_EXECUTEを設定し、ACCESS4_EXECUTEが回答者のサポートフィールドに設定されていない場合、クライアントはACCESS4_READが要求のアクセスフィールドにビットを設定して、アクセス要求を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the server supports read permission bits, it MUST only check for read permissions in the mode, acl, and dacl attributes when it receives an ACCESS request with ACCESS4_READ set in the access field. The server MUST NOT also examine execute permission bits when determining whether the reply will have ACCESS4_READ set in the access field or not.",
      "ja": "Oサーバーが読ん許可ビットをサポートしている場合、それだけで、モードで読み取りアクセス許可のACLをチェックしなければなりませんし、それがアクセスフィールドでACCESS4_READがセットされたアクセス要求を受信したときにDACL属性。また、サーバは、応答がアクセスフィールドにACCESS4_READセットを持っているか、いないかどうかを決定する際に許可ビットを実行して調べてはなりません。"
    },
    {
      "indent": 3,
      "text": "Note that if the ACCESS reply has ACCESS4_READ or ACCESS_EXECUTE set, then the user also has permissions to OPEN (Section 18.16) or READ (Section 18.22) the file. In other words, if the client sends an ACCESS request with the ACCESS4_READ and ACCESS_EXECUTE set in the access field (or two separate requests, one with ACCESS4_READ set and the other with ACCESS4_EXECUTE set), and the reply has just",
      "ja": "アクセス応答がACCESS4_READまたはACCESS_EXECUTEが設定されている場合、ユーザーはまた、（項18.16）またはREAD（セクション18.22）ファイルを開くための権限を持っていることに注意してください。つまり、クライアントがアクセスフィールド（または2つの別々のリクエスト、ACCESS4_EXECUTEセットとACCESS4_READセットと他との1）に設定されたACCESS4_READとACCESS_EXECUTEとのアクセス要求を送信し、返信がちょうど持っている場合"
    },
    {
      "indent": 3,
      "text": "ACCESS4_EXECUTE set in the access field (or just one reply has ACCESS4_EXECUTE set), then the user has authorization to OPEN or READ the file.",
      "ja": "ACCESS4_EXECUTEアクセスフィールドに設定（または単に1返信がACCESS4_EXECUTEが設定されている）、その後、ユーザーがファイルを開くまたはREADする権限を持っています。"
    },
    {
      "indent": 0,
      "text": "18.1.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.1.4. 実装"
    },
    {
      "indent": 3,
      "text": "In general, it is not sufficient for the client to attempt to deduce access permissions by inspecting the uid, gid, and mode fields in the file attributes or by attempting to interpret the contents of the ACL attribute. This is because the server may perform uid or gid mapping or enforce additional access-control restrictions. It is also possible that the server may not be in the same ID space as the client. In these cases (and perhaps others), the client cannot reliably perform an access check with only current file attributes.",
      "ja": "クライアントがファイル属性でUID、GID、およびモードフィールドを検査することによって、またはACL属性の内容を解釈しようとすることで、アクセス権限を推測しようとするために一般的には、それは十分ではありません。サーバーは、UIDまたはGIDマッピングを実行するか、追加のアクセス制御制限を実施する可能性があるからです。サーバがクライアントと同じIDスペースにないかもしれないことも可能です。 （おそらく他）これらの例では、クライアントは確実にのみ、現在のファイル属性とアクセスチェックを実行することはできません。"
    },
    {
      "indent": 3,
      "text": "In the NFSv2 protocol, the only reliable way to determine whether an operation was allowed was to try it and see if it succeeded or failed. Using the ACCESS operation in the NFSv4.1 protocol, the client can ask the server to indicate whether or not one or more classes of operations are permitted. The ACCESS operation is provided to allow clients to check before doing a series of operations that will result in an access failure. The OPEN operation provides a point where the server can verify access to the file object and a method to return that information to the client. The ACCESS operation is still useful for directory operations or for use in the case that the UNIX interface access() is used on the client.",
      "ja": "NFSv2プロトコルでは、操作が許可されたかどうかを判断する唯一の確実な方法は、それを試してみて、それが成功したか失敗したかどうかを確認することでした。 NFSv4.1プロトコルでアクセス動作を使用して、クライアントは操作の1つまたは複数のクラスが許可されているかどうかを示すために、サーバに依頼することができます。アクセス動作は、クライアントがアクセス障害につながる一連の操作を行う前にチェックできるようにするために提供されます。 OPEN操作はサーバがクライアントに情報を返すためにファイルオブジェクトとメソッドへのアクセスを確認することができますポイントを提供します。アクセス動作は、まだディレクトリ操作用またはUNIXインターフェイスへのアクセスは、（）クライアントで使用する場合の使用に有用です。"
    },
    {
      "indent": 3,
      "text": "The information returned by the server in response to an ACCESS call is not permanent. It was correct at the exact time that the server performed the checks, but not necessarily afterwards. The server can revoke access permission at any time.",
      "ja": "アクセスの呼び出しに応じてサーバから返された情報は永久的ではありません。それは必ずしも必要ではないが、その後、サーバがチェックを行って正確な時間で正しかったです。サーバーは、いつでもアクセス許可を取り消すことができます。"
    },
    {
      "indent": 3,
      "text": "The client should use the effective credentials of the user to build the authentication information in the ACCESS request used to determine access rights. It is the effective user and group credentials that are used in subsequent READ and WRITE operations.",
      "ja": "クライアントは、アクセス権を決定するために使用するアクセス要求で認証情報を構築するために、ユーザーの効果的な資格情報を使用する必要があります。これは、その後の読み取りおよび書き込み操作に使用されている有効なユーザおよびグループの資格情報です。"
    },
    {
      "indent": 3,
      "text": "Many implementations do not directly support the ACCESS4_DELETE permission. Operating systems like UNIX will ignore the ACCESS4_DELETE bit if set on an access request on a non-directory object. In these systems, delete permission on a file is determined by the access permissions on the directory in which the file resides, instead of being determined by the permissions of the file itself. Therefore, the mask returned enumerating which access rights can be determined will have the ACCESS4_DELETE value set to 0. This indicates to the client that the server was unable to check that particular access right. The ACCESS4_DELETE bit in the access mask returned will then be ignored by the client.",
      "ja": "多くの実装では、直接ACCESS4_DELETE許可をサポートしていません。非ディレクトリ・オブジェクトに対するアクセス要求に設定した場合、UNIXのようなオペレーティングシステムはACCESS4_DELETEビットを無視します。これらのシステムでは、ファイルのアクセス許可を削除する代わりに、ファイル自体の権限によって決定されるのファイルが存在するディレクトリへのアクセス権限によって決定されます。そのため、マスクは、これは、サーバーがその特定のアクセス権を確認することができなかったことをクライアントに指示する0に設定ACCESS4_DELETE値を持つことになります判断することができる権利にアクセス列挙を返しました。返されたアクセスマスクでACCESS4_DELETEビットは、クライアントによって無視されます。"
    },
    {
      "indent": 0,
      "text": "18.2. Operation 4: CLOSE - Close File",
      "section_title": true,
      "ja": "18.2. 操作4：CLOSE  - ファイルを閉じます"
    },
    {
      "indent": 0,
      "text": "18.2.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.2.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct CLOSE4args {\n        /* CURRENT_FH: object */\n        seqid4          seqid;\n        stateid4        open_stateid;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.2.2. RESULTS",
      "section_title": true,
      "ja": "18.2.2. 結果"
    },
    {
      "indent": 3,
      "text": "union CLOSE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         stateid4       open_stateid;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.2.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.2.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The CLOSE operation releases share reservations for the regular or named attribute file as specified by the current filehandle. The share reservations and other state information released at the server as a result of this CLOSE are only those associated with the supplied stateid. State associated with other OPENs is not affected.",
      "ja": "現在のファイルハンドルで指定されCLOSE操作は、通常のまたは名前付き属性ファイルの共有の予約を解放します。このCLOSEの結果としてサーバで放出共有の予約および他の状態情報は、供給のstateidに関連するものです。他のOPENsに関連した状態は影響を受けません。"
    },
    {
      "indent": 3,
      "text": "If byte-range locks are held, the client SHOULD release all locks before sending a CLOSE. The server MAY free all outstanding locks on CLOSE, but some servers may not support the CLOSE of a file that still has byte-range locks held. The server MUST return failure if any locks would exist after the CLOSE.",
      "ja": "バイト範囲ロックが保持されている場合、クライアントはCLOSEを送信する前に、すべてのロックを解除しなければなりません。サーバーは、CLOSE上のすべての未解決のロックを解放するかもしれが、一部のサーバーがまだ開催されたバイト範囲ロックを持つファイルのCLOSEをサポートしていないかもしれません。すべてのロックは、CLOSEの後に存在するならば、サーバーは失敗を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The argument seqid MAY have any value, and the server MUST ignore seqid.",
      "ja": "引数SEQIDは、任意の値を有していてもよいし、サーバがSEQIDを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 3,
      "text": "The server MAY require that the combination of principal, security flavor, and, if applicable, GSS mechanism that sent the OPEN request also be the one to CLOSE the file. This might not be possible if credentials for the principal are no longer available. The server MAY allow the machine credential or SSV credential (see Section 18.35) to send CLOSE.",
      "ja": "サーバは元本、セキュリティ風味の組み合わせを必要とする場合があり、及び、該当する場合は、OPEN要求を送信したGSSメカニズムは、ファイルを閉じるには一つです。主体の資格が利用できなくなっている場合、これはできないかもしれません。サーバーは、マシンの資格やSSV資格は（項18.35を参照）CLOSEを送信することを可能にします。"
    },
    {
      "indent": 0,
      "text": "18.2.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.2.4. 実装"
    },
    {
      "indent": 3,
      "text": "Even though CLOSE returns a stateid, this stateid is not useful to the client and should be treated as deprecated. CLOSE \"shuts down\" the state associated with all OPENs for the file by a single open-owner. As noted above, CLOSE will either release all file-locking state or return an error. Therefore, the stateid returned by CLOSE is not useful for operations that follow. To help find any uses of this stateid by clients, the server SHOULD return the invalid special stateid (the \"other\" value is zero and the \"seqid\" field is NFS4_UINT32_MAX, see Section 8.2.3).",
      "ja": "CLOSEがたstateidを返すにもかかわらず、これのstateidは、クライアントにとって有用なものではなく、非推奨として扱われるべきです。 CLOSE単一のオープン所有者がファイルのすべてのOPENsに関連付けられている状態を「シャットダウンします」。上述したように、CLOSEは、すべてのファイルロック状態を解除またはエラーが返されるいずれかです。したがって、CLOSEによって返されたstateidは続く操作のために有用ではありません。クライアントによる本のstateidのいずれかの用途を見つけやすくするために、サーバーが無効な特別なstateidを返すべきである（「その他」の値がゼロであり、「SEQID」フィールドがNFS4_UINT32_MAXで、8.2.3項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "A CLOSE operation may make delegations grantable where they were not previously. Servers may choose to respond immediately if there are pending delegation want requests or may respond to the situation at a later time.",
      "ja": "彼らは以前にはなかったところCLOSE操作は、代表団が許可できることがあります。サーバーは保留中の委任がある場合、リクエストをしたいか、後で状況に応答することができる即座に応答することもできます。"
    },
    {
      "indent": 0,
      "text": "18.3. Operation 5: COMMIT - Commit Cached Data",
      "section_title": true,
      "ja": "18.3. 操作5：COMMITは - キャッシュされたデータをコミット"
    },
    {
      "indent": 0,
      "text": "18.3.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.3.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct COMMIT4args {\n        /* CURRENT_FH: file */\n        offset4         offset;\n        count4          count;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.3.2. RESULTS",
      "section_title": true,
      "ja": "18.3.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct COMMIT4resok {\n        verifier4       writeverf;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union COMMIT4res switch (nfsstat4 status) {\n case NFS4_OK:\n         COMMIT4resok   resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.3.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.3.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The COMMIT operation forces or flushes uncommitted, modified data to stable storage for the file specified by the current filehandle. The flushed data is that which was previously written with one or more WRITE operations that had the \"committed\" field of their results field set to UNSTABLE4.",
      "ja": "操作力をCOMMITまたは現在のファイルハンドルで指定されたファイルの保存安定性にコミットしていない、変更されたデータをフラッシュします。フラッシュされたデータは、以前UNSTABLE4に設定され、その結果フィールドの「コミット」フィールドを持っていた一つ以上のWRITE操作で書かれたものです。"
    },
    {
      "indent": 3,
      "text": "The offset specifies the position within the file where the flush is to begin. An offset value of zero means to flush data starting at the beginning of the file. The count specifies the number of bytes of data to flush. If the count is zero, a flush from the offset to the end of the file is done.",
      "ja": "オフセットは、フラッシュが開始するファイル内の位置を指定します。ゼロのオフセット値は、ファイルの先頭からデータをフラッシュすることを意味します。カウントは、フラッシュへのデータのバイト数を指定します。カウントがゼロの場合、ファイルの最後にオフセットからのフラッシュが行われます。"
    },
    {
      "indent": 3,
      "text": "The server returns a write verifier upon successful completion of the COMMIT. The write verifier is used by the client to determine if the server has restarted between the initial WRITE operations and the COMMIT. The client does this by comparing the write verifier returned from the initial WRITE operations and the verifier returned by the COMMIT operation. The server must vary the value of the write verifier at each server event or instantiation that may lead to a loss of uncommitted data. Most commonly this occurs when the server is restarted; however, other events at the server may result in uncommitted data loss as well.",
      "ja": "サーバーは、COMMITが正常に完了すると、書き込みベリファイアを返します。書き込みベリファイアは、サーバが最初の書き込み操作とCOMMITの間で再起動したかどうかを判断するために、クライアントによって使用されます。クライアントは、最初の書き込み操作から返された書き込み検証およびCOMMIT操作によって返された検証を比較することによって、これを行います。サーバは、コミットされていないデータの損失につながる可能性があり、各サーバイベントまたはインスタンスに書き込み検証の値を変更しなければなりません。サーバーを再起動したときに最も一般的には、これは発生します。ただし、サーバーで他のイベントも同様にコミットされていないデータが失われることがあります。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.3.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.3.4. 実装"
    },
    {
      "indent": 3,
      "text": "The COMMIT operation is similar in operation and semantics to the POSIX fsync() [25] system interface that synchronizes a file's state with the disk (file data and metadata is flushed to disk or stable storage). COMMIT performs the same operation for a client, flushing any unsynchronized data and metadata on the server to the server's disk or stable storage for the specified file. Like fsync(), it may be that there is some modified data or no modified data to synchronize. The data may have been synchronized by the server's normal periodic buffer synchronization activity. COMMIT should return NFS4_OK, unless there has been an unexpected error.",
      "ja": "COMMIT操作は、ディスクにファイルの状態を同期POSIX FSYNC（）[25]システム・インターフェース（ファイルデータとメタデータがディスクまたは安定記憶にフラッシュされる）の動作と意味論に類似しています。 COMMIT指定されたファイルは、サーバーのディスクにサーバーまたは安定したストレージ上の任意の非同期のデータとメタデータをフラッシュする、クライアントのために同じ操作を実行します。 FSYNC（）のように、それはいくつかの変更されたデータ又は同期させるない変更されたデータが存在することであってもよいです。データは、サーバーの正常な周期的なバッファ同期活動で同期されている可能性があります。予期せぬエラーがあった場合を除き、NFS4_OKを返す必要がCOMMIT。"
    },
    {
      "indent": 3,
      "text": "COMMIT differs from fsync() in that it is possible for the client to flush a range of the file (most likely triggered by a buffer-reclamation scheme on the client before the file has been completely written).",
      "ja": "クライアントがファイルの範囲を（ファイルが完全に書き込まれる前に、最も可能性の高いクライアント上のバッファ・再生スキームによってトリガ）フラッシュすることが可能であるという点ではfsync異なるのを（）COMMIT。"
    },
    {
      "indent": 3,
      "text": "The server implementation of COMMIT is reasonably simple. If the server receives a full file COMMIT request, that is, starting at offset zero and count zero, it should do the equivalent of applying fsync() to the entire file. Otherwise, it should arrange to have the modified data in the range specified by offset and count to be flushed to stable storage. In both cases, any metadata associated with the file must be flushed to stable storage before returning. It is not an error for there to be nothing to flush on the server. This means that the data and metadata that needed to be flushed have already been flushed or lost during the last server failure.",
      "ja": "COMMITのサーバの実装は合理的に簡単です。サーバーは、完全なファイルが要求をCOMMIT受信した場合、それはで始まる、ゼロオフセットとゼロを数え、それはファイル全体へのfsync（）を適用するのと同等を行う必要があります。それ以外の場合は、offsetで指定した範囲の変更されたデータを持っており、安定したストレージにフラッシュされるようにカウントするように手配しなければなりません。どちらの場合も、ファイルに関連付けられたすべてのメタデータが戻る前に、安定したストレージにフラッシュする必要があります。サーバー上で洗い流すことは何もないことはエラーではありません。これはフラッシュするために必要なデータおよびメタデータがすでに最後のサーバ障害時のフラッシュまたは失われていることを意味します。"
    },
    {
      "indent": 3,
      "text": "The client implementation of COMMIT is a little more complex. There are two reasons for wanting to commit a client buffer to stable storage. The first is that the client wants to reuse a buffer. In this case, the offset and count of the buffer are sent to the server in the COMMIT request. The server then flushes any modified data based on the offset and count, and flushes any modified metadata associated with the file. It then returns the status of the flush and the write verifier. The second reason for the client to generate a COMMIT is for a full file flush, such as may be done at close. In this case, the client would gather all of the buffers for this file that contain uncommitted data, do the COMMIT operation with an offset of zero and count of zero, and then free all of those buffers. Any other dirty buffers would be sent to the server in the normal fashion.",
      "ja": "COMMITのクライアントの実装はもう少し複雑です。安定したストレージにクライアントバッファをコミットしたいのための2つの理由があります。最初は、クライアントがバッファを再利用したいということです。この場合、オフセットおよびバッファのカウントがCOMMITリクエストでサーバーに送信されます。次に、サーバーはオフセットとカウントに基づいてすべての変更されたデータをフラッシュし、ファイルに関連付けられたすべての変更されたメタデータをフラッシュします。その後、フラッシュやライト・ベリファイアの状態を返します。 COMMITを生成するためのクライアントのための第二の理由は、近くで行うことができるよう、完全なファイルのフラッシュのためです。この場合、クライアントがゼロのゼロカウントのオフセット、およびそれらのバッファをすべて、その後自由にCOMMIT操作を行い、コミットされていないデータが含まれているこのファイルのバッファのすべてを収集します。その他のダーティバッファは、通常の方法でサーバに送信されます。"
    },
    {
      "indent": 3,
      "text": "After a buffer is written (via the WRITE operation) by the client with the \"committed\" field in the result of WRITE set to UNSTABLE4, the buffer must be considered as modified by the client until the buffer has either been flushed via a COMMIT operation or written via a WRITE operation with the \"committed\" field in the result set to FILE_SYNC4 or DATA_SYNC4. This is done to prevent the buffer from being freed and reused before the data can be flushed to stable storage on the server.",
      "ja": "バッファがUNSTABLE4にWRITEセットの結果に「コミット」フィールドと、クライアントによって（WRITE動作を介して）書き込まれた後にクライアントによって修正され、バッファのいずれかCOMMIT操作によってフラッシュされるまで、バッファを考慮しなければなりませんまたはFILE_SYNC4またはDATA_SYNC4に設定し、結果に「コミット」フィールドでWRITE操作によって書かれました。これは、データはサーバー上の安定したストレージにフラッシュする前に解放され、再利用されることから、バッファを防止するために行われます。"
    },
    {
      "indent": 3,
      "text": "When a response is returned from either a WRITE or a COMMIT operation and it contains a write verifier that differs from that previously returned by the server, the client will need to retransmit all of the buffers containing uncommitted data to the server. How this is to be done is up to the implementor. If there is only one buffer of interest, then it should be sent in a WRITE request with the FILE_SYNC4 stable parameter. If there is more than one buffer, it might be worthwhile retransmitting all of the buffers in WRITE operations with the stable parameter set to UNSTABLE4 and then retransmitting the COMMIT operation to flush all of the data on the server to stable storage. However, if the server repeatably returns from COMMIT a verifier that differs from that returned by WRITE, the only way to ensure progress is to retransmit all of the buffers with WRITE requests with the FILE_SYNC4 stable parameter.",
      "ja": "応答がWRITEかCOMMIT操作のいずれかから返されると、それはそれ以前に、サーバから返されたとは異なり、書き込みベリファイアが含まれている場合、クライアントはサーバーにコミットされていないデータを含む全てのバッファを再送信する必要があります。これを実行する方法を実装までです。関心の一つだけのバッファがあれば、それはFILE_SYNC4安定したパラメータを使用してWRITE要求で送信する必要があります。複数のバッファが存在する場合、それはUNSTABLE4に設定し、安定したパラメータとWRITE操作でのバッファのすべてを再送して、安定したストレージにサーバー上のすべてのデータをフラッシュするCOMMIT操作を再送信する価値があるかもしれません。サーバが繰り返しWRITEによって返されたものとは異なる検証をCOMMITから返す場合は、進捗状況を確保するための唯一の方法は、FILE_SYNC4安定したパラメータを使用してWRITE要求でバッ​​ファのすべてを再送することです。"
    },
    {
      "indent": 3,
      "text": "The above description applies to page-cache-based systems as well as buffer-cache-based systems. In the former systems, the virtual memory system will need to be modified instead of the buffer cache.",
      "ja": "上記の説明は、ページキャッシュベースのシステムと同様に、バッファ・キャッシュベースのシステムに適用されます。前者のシステムでは、仮想メモリシステムは、バッファ・キャッシュの代わりに変更する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.4. Operation 6: CREATE - Create a Non-Regular File Object",
      "section_title": true,
      "ja": "18.4. 操作6：CREATE  - 非正規ファイルオブジェクトを作成します。"
    },
    {
      "indent": 0,
      "text": "18.4.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.4.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "union createtype4 switch (nfs_ftype4 type) {\n case NF4LNK:\n         linktext4 linkdata;\n case NF4BLK:\n case NF4CHR:\n         specdata4 devdata;\n case NF4SOCK:\n case NF4FIFO:\n case NF4DIR:\n         void;\n default:\n         void;  /* server should return NFS4ERR_BADTYPE */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct CREATE4args {\n        /* CURRENT_FH: directory for creation */\n        createtype4     objtype;\n        component4      objname;\n        fattr4          createattrs;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.4.2. RESULTS",
      "section_title": true,
      "ja": "18.4.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CREATE4resok {\n        change_info4    cinfo;\n        bitmap4         attrset;        /* attributes set */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union CREATE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         /* new CURRENTFH: created object */\n         CREATE4resok resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.4.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.4.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The CREATE operation creates a file object other than an ordinary file in a directory with a given name. The OPEN operation MUST be used to create a regular file or a named attribute.",
      "ja": "CREATE操作は、指定した名前のディレクトリにある通常のファイル以外のファイルオブジェクトを作成します。 OPEN操作は、通常のファイルまたは名前の属性を作成するために使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The current filehandle must be a directory: an object of type NF4DIR. If the current filehandle is an attribute directory (type NF4ATTRDIR), the error NFS4ERR_WRONG_TYPE is returned. If the current file handle designates any other type of object, the error NFS4ERR_NOTDIR results.",
      "ja": "タイプNF4DIRの対象：現在のファイルハンドルはディレクトリでなければなりません。現在のファイルハンドルが属性ディレクトリ（NF4ATTRDIR型）である場合、エラーNFS4ERR_WRONG_TYPEが返されます。現在のファイルハンドルは、その他の型のオブジェクト、エラーNFS4ERR_NOTDIR結果を指定した場合。"
    },
    {
      "indent": 3,
      "text": "The objname specifies the name for the new object. The objtype determines the type of object to be created: directory, symlink, etc. If the object type specified is that of an ordinary file, a named attribute, or a named attribute directory, the error NFS4ERR_BADTYPE results.",
      "ja": "objnameには、新しいオブジェクトの名前を指定します。指定されたオブジェクト・タイプは、通常のファイル、名前付き属性、または名前付き属性ディレクトリ、エラーNFS4ERR_BADTYPE結果のものである場合など、ディレクトリ、シンボリックリンク、：OBJTYPEは、作成するオブジェクトの種類を決定します。"
    },
    {
      "indent": 3,
      "text": "If an object of the same name already exists in the directory, the server will return the error NFS4ERR_EXIST.",
      "ja": "同じ名前のオブジェクトがすでにディレクトリに存在する場合、サーバーはエラーNFS4ERR_EXISTを返します。"
    },
    {
      "indent": 3,
      "text": "For the directory where the new file object was created, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the file object creation.",
      "ja": "新しいファイルオブジェクトが作成されたディレクトリのために、サーバはcinfoの変化_info4情報を返します。前と後の変更属性はファイルオブジェクトの作成に関して原子論が得られた場合には変化_info4データ型の原子分野、意志が示すサーバ。"
    },
    {
      "indent": 3,
      "text": "If the objname has a length of zero, or if objname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.",
      "ja": "objnameには、UTF-8定義に従わない場合はobjnameにはゼロの長さを持っている場合、または、エラーNFS4ERR_INVALが返されます。"
    },
    {
      "indent": 3,
      "text": "The current filehandle is replaced by that of the new object.",
      "ja": "現在のファイルハンドルは、新しいオブジェクトのものに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "The createattrs specifies the initial set of attributes for the object. The set of attributes may include any writable attribute valid for the object type. When the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.",
      "ja": "createattrsは、オブジェクトの属性の初期セットを指定します。一連の属性は、オブジェクト・タイプに対して有効な任意の書き込み可能な属性を含むことができます。操作が成功すると、サーバーはクライアントに正常にオブジェクトに設定された属性の属性マスクの意味を返します。"
    },
    {
      "indent": 3,
      "text": "If createattrs includes neither the owner attribute nor an ACL with an ACE for the owner, and if the server's file system both supports and requires an owner attribute (or an owner ACE), then the server MUST derive the owner (or the owner ACE). This would typically be from the principal indicated in the RPC credentials of the call, but the server's operating environment or file system semantics may dictate other methods of derivation. Similarly, if createattrs includes neither the group attribute nor a group ACE, and if the server's file system both supports and requires the notion of a group attribute (or group ACE), the server MUST derive the group attribute (or the corresponding owner ACE) for the file. This could be from the RPC call's credentials, such as the group principal if the credentials include it (such as with AUTH_SYS), from the group identifier associated with the principal in the credentials (e.g., POSIX systems have a user database [26] that has a group identifier for every user identifier), inherited from the directory in which the object is created, or whatever else the server's operating environment or file system semantics dictate. This applies to the OPEN operation too.",
      "ja": "createattrsは、所有者属性も所有者のACEとのACLでもないが含まれており、サーバのファイルシステムの場合の両方をサポートし、所有者の属性（または所有者のACE）が必要な場合、サーバは、所有者（または所有者のACE）を導出しなければなりません。これは通常、コールのRPC資格で示さ校長からだろうが、サーバーの動作環境やファイルシステムのセマンティクスが派生する他の方法を指示することができます。 createattrsは、グループ属性やグループACE、およびサーバのファイルシステムならば、両方のサポートもないが含まれており、グループ属性（またはグループACE）の概念を必要とする場合も同様に、サーバはグループ属性（または対応する所有者のACE）を導出しなければなりませんファイルの。これは、クレデンシャルにプリンシパル（関連付けられたグループ識別子から、資格情報が（例えばAUTH_SYS有するように）を含む場合、そのようなグループプリンシパルとしてRPCコールの資格情報、からとすることができる、例えば、POSIXシステムでは、ユーザ・データベースを持っている[26]その）すべてのユーザ識別子のためのグループ識別子を持つ、オブジェクトが作成されたディレクトリから継承された、または任意の他のサーバの動作環境やファイルシステムのセマンティクスが決まります。これは、あまりにもOPEN操作に適用されます。"
    },
    {
      "indent": 3,
      "text": "Conversely, it is possible that the client will specify in createattrs an owner attribute, group attribute, or ACL that the principal indicated the RPC call's credentials does not have permissions to create files for. The error to be returned in this instance is NFS4ERR_PERM. This applies to the OPEN operation too.",
      "ja": "逆に、クライアントがcreateattrsに本人がためにファイルを作成する権限を持っていないRPC呼び出しの資格を示したことを、所有者の属性、グループ属性、またはACLを指定することが可能です。この例で返されるエラーはNFS4ERR_PERMです。これは、あまりにもOPEN操作に適用されます。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle designates a directory for which another client holds a directory delegation, then, unless the delegation is such that the situation can be resolved by sending a notification, the delegation MUST be recalled, and the CREATE operation MUST NOT proceed until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.",
      "ja": "現在のファイルハンドルは、代表団は状況が通知を送信することで解決できるようなものである場合を除き、他のクライアントは、その後、ディレクトリ委任を保持するためのディレクトリを指定した場合、代表団は、リコールされなければならない、とCREATE操作が委任されるまで続行てはなりません返品取り消されます。これは非常に迅速に起こる場合を除いて、一つ以上のNFS4ERR_DELAYエラーが代表団は優れたまま行われる要求に返されます。"
    },
    {
      "indent": 3,
      "text": "When the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_ADD_ENTRY will be generated as a result of this operation.",
      "ja": "現在のファイルハンドルは、1つのまたは複数のディレクトリ委任が存在するディレクトリを指定すると、それらの代表は、そのような通知を要求すると、次に、NOTIFY4_ADD_ENTRYは、この操作の結果として生成されます。"
    },
    {
      "indent": 3,
      "text": "If the capability FSCHARSET_CAP4_ALLOWS_ONLY_UTF8 is set (Section 14.4), and a symbolic link is being created, then the content of the symbolic link MUST be in UTF-8 encoding.",
      "ja": "能力FSCHARSET_CAP4_ALLOWS_ONLY_UTF8が設定されている場合（セクション14.4）、及びシンボリックリンクが作成され、その後、シンボリックリンクの内容は、UTF-8エンコーディングである必要があります。"
    },
    {
      "indent": 0,
      "text": "18.4.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.4.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the client desires to set attribute values after the create, a SETATTR operation can be added to the COMPOUND request so that the appropriate attributes will be set.",
      "ja": "クライアントが作成した後、属性値を設定したい場合、適切な属性が設定されるように、SETATTR操作はCOMPOUND要求に追加することができます。"
    },
    {
      "indent": 0,
      "text": "18.5. Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery",
      "section_title": true,
      "ja": "18.5. 操作7：DELEGPURGE  - 回復を待ちパージ代表団"
    },
    {
      "indent": 0,
      "text": "18.5.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.5.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct DELEGPURGE4args {\n        clientid4       clientid;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.5.2. RESULTS",
      "section_title": true,
      "ja": "18.5.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct DELEGPURGE4res {\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.5.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.5.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation purges all of the delegations awaiting recovery for a given client. This is useful for clients that do not commit delegation information to stable storage to indicate that conflicting requests need not be delayed by the server awaiting recovery of delegation information.",
      "ja": "この操作は、指定されたクライアントの回復を待っている代表団のすべてを消去します。これは矛盾する要求が委任情報の回復を待って、サーバーによって遅延される必要がないことを示すために、安定したストレージへの委任情報をコミットしていないクライアントのために有用です。"
    },
    {
      "indent": 3,
      "text": "The client is NOT specified by the clientid field of the request. The client SHOULD set the client field to zero, and the server MUST ignore the clientid field. Instead, the server MUST derive the client ID from the value of the session ID in the arguments of the SEQUENCE operation that precedes DELEGPURGE in the COMPOUND request.",
      "ja": "クライアントがリクエストのClientIDをフィールドで指定されていません。クライアントがゼロにクライアントのフィールドを設定する必要があり、サーバはclientidのフィールドを無視しなければなりません。代わりに、サーバはCOMPOUND要求にDELEGPURGEの前にシーケンス動作の引数でセッションIDの値から、クライアントのIDを導出しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The DELEGPURGE operation should be used by clients that record delegation information on stable storage on the client. In this case, after the client recovers all delegations it knows of, it should immediately send a DELEGPURGE operation. Doing so will notify the server that no additional delegations for the client will be recovered allowing it to free resources, and avoid delaying other clients which make requests that conflict with the unrecovered delegations. The set of delegations known to the server and the client might be different. The reason for this is that after sending a request that resulted in a delegation, the client might experience a failure before it both received the delegation and committed the delegation to the client's stable storage.",
      "ja": "DELEGPURGE操作は、クライアント上で安定したストレージに記録委任情報というクライアントによって使用されなければなりません。クライアントが知っているすべての代表団を回復した後、この場合、それはすぐにDELEGPURGE操作を送信する必要があります。そうすることで、クライアントのための追加の代表団は、リソースを解放することが可能に回復されませんサーバーに通知し、リクエスト未回収の代表団との競合を作る他のクライアントを遅らせる避けることができます。サーバとクライアントに知られている代表団のセットは異なる場合があります。この理由は、それが両方の委任を受け、クライアントの安定したストレージへの委任をコミットする前に委任が生じた要求を送信した後、クライアントは失敗を経験するかもしれないということです。"
    },
    {
      "indent": 3,
      "text": "The server MAY support DELEGPURGE, but if it does not, it MUST NOT support CLAIM_DELEGATE_PREV and MUST NOT support CLAIM_DELEG_PREV_FH.",
      "ja": "サーバーはDELEGPURGEをサポートするかもしれないが、それがない場合、それはCLAIM_DELEGATE_PREVをサポートしてはならないとCLAIM_DELEG_PREV_FHをサポートしてはなりません。"
    },
    {
      "indent": 0,
      "text": "18.6. Operation 8: DELEGRETURN - Return Delegation",
      "section_title": true,
      "ja": "18.6. 操作8：DELEGRETURN  - 戻る委任"
    },
    {
      "indent": 0,
      "text": "18.6.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.6.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct DELEGRETURN4args {\n        /* CURRENT_FH: delegated object */\n        stateid4        deleg_stateid;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.6.2. RESULTS",
      "section_title": true,
      "ja": "18.6.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct DELEGRETURN4res {\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.6.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.6.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The DELEGRETURN operation returns the delegation represented by the current filehandle and stateid.",
      "ja": "DELEGRETURN操作は、現在のファイルハンドルとのstateidで表さ委任を返します。"
    },
    {
      "indent": 3,
      "text": "Delegations may be returned voluntarily (i.e., before the server has recalled them) or when recalled. In either case, the client must properly propagate state changed under the context of the delegation to the server before returning the delegation.",
      "ja": "代表団は自発的に戻さ（サーバは、それらをリコールしている、すなわち、前）またはリコールするときことができます。いずれの場合も、クライアントは正常に状態を伝播しなければならない委任を返す前に、サーバーへの委任のコンテキストで変更。"
    },
    {
      "indent": 3,
      "text": "The server MAY require that the principal, security flavor, and if applicable, the GSS mechanism, combination that acquired the delegation also be the one to send DELEGRETURN on the file. This might not be possible if credentials for the principal are no longer available. The server MAY allow the machine credential or SSV credential (see Section 18.35) to send DELEGRETURN.",
      "ja": "サーバが必要とするかもしれないことに元本、セキュリティ風味、および該当する場合、GSSメカニズム、代表団はまた、ファイルにDELEGRETURNを送信するために一つで買収組み合わせ。主体の資格が利用できなくなっている場合、これはできないかもしれません。サーバーは、マシンの資格やSSV資格は（項18.35を参照）DELEGRETURNを送信することを可能にします。"
    },
    {
      "indent": 0,
      "text": "18.7. Operation 9: GETATTR - Get Attributes",
      "section_title": true,
      "ja": "18.7. 操作9：GETATTR  - 属性を取得します。"
    },
    {
      "indent": 0,
      "text": "18.7.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.7.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct GETATTR4args {\n        /* CURRENT_FH: object */\n        bitmap4         attr_request;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.7.2. RESULTS",
      "section_title": true,
      "ja": "18.7.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct GETATTR4resok {\n        fattr4          obj_attributes;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union GETATTR4res switch (nfsstat4 status) {\n case NFS4_OK:\n         GETATTR4resok  resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.7.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.7.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The GETATTR operation will obtain attributes for the file system object specified by the current filehandle. The client sets a bit in the bitmap argument for each attribute value that it would like the server to return. The server returns an attribute bitmap that indicates the attribute values that it was able to return, which will include all attributes requested by the client that are attributes supported by the server for the target file system. This bitmap is followed by the attribute values ordered lowest attribute number first.",
      "ja": "GETATTR操作は、現在のファイルハンドルで指定されたファイル・システム・オブジェクトの属性を取得します。クライアントは、サーバーが返すしたい各属性値のビットマップ引数のビットを設定します。サーバーは、ターゲット・ファイル・システムのサーバーでサポートされている属性であるクライアントから要求されたすべての属性が含まれる、返すことができた属性値を示す属性ビットマップを返します。このビットマップは最初に最低の属性番号を注文した属性値が続いています。"
    },
    {
      "indent": 3,
      "text": "The server MUST return a value for each attribute that the client requests if the attribute is supported by the server for the target file system. If the server does not support a particular attribute on the target file system, then it MUST NOT return the attribute value and MUST NOT set the attribute bit in the result bitmap. The server MUST return an error if it supports an attribute on the target but cannot obtain its value. In that case, no attribute values will be returned.",
      "ja": "属性がターゲット・ファイル・システムのサーバーでサポートされている場合、サーバーはクライアントの要求する各属性の値を返さなければなりません。サーバーは、ターゲット・ファイル・システム上に特定の属性をサポートしていない場合、それは属性値を返してはならないと、結果のビットマップ内の属性ビットを設定してはいけません。それは、ターゲットの属性をサポートしていますが、その値を取得できない場合、サーバーはエラーを返さなければなりません。その場合には、何の属性値は返されません。"
    },
    {
      "indent": 3,
      "text": "File systems that are absent should be treated as having support for a very small set of attributes as described in Section 11.3.1, even if previously, when the file system was present, more attributes were supported.",
      "ja": "存在しないファイルシステムでも、以前場合、ファイルシステムが存在した場合、より多くの属性がサポートされていた、セクション11.3.1に記載されているように属性の非常に小さなセットのための支持体を有するものとして扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "All servers MUST support the REQUIRED attributes as specified in Section 5.6, for all file systems, with the exception of absent file systems.",
      "ja": "すべてのサーバーは存在しないファイルシステムを除いて、すべてのファイルシステムのために、5.6節で指定されREQUIRED属性をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.7.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.7.4. 実装"
    },
    {
      "indent": 3,
      "text": "Suppose there is an OPEN_DELEGATE_WRITE delegation held by another client for the file in question and size and/or change are among the set of attributes being interrogated. The server has two choices. First, the server can obtain the actual current value of these attributes from the client holding the delegation by using the CB_GETATTR callback. Second, the server, particularly when the delegated client is unresponsive, can recall the delegation in question. The GETATTR MUST NOT proceed until one of the following occurs:",
      "ja": "質問とサイズおよび/または変更ファイルを別のクライアントが保持しているOPEN_DELEGATE_WRITEの代表団は、尋問されている属性のセットの中で存在していると仮定します。サーバーは、2つの選択肢があります。まず、サーバはCB_GETATTRコールバックを使用して委任を保持しているクライアントからこれらの属性の実際の電流値を得ることができます。第二に、サーバは、委任クライアントが応答しない場合は特に、問題の委任を思い出すことができます。以下のいずれかが発生するまでGETATTRが進んではいけません。"
    },
    {
      "indent": 3,
      "text": "o The requested attribute values are returned in the response to CB_GETATTR.",
      "ja": "O要求された属性値はCB_GETATTRへの応答で返されます。"
    },
    {
      "indent": 3,
      "text": "o The OPEN_DELEGATE_WRITE delegation is returned.",
      "ja": "O OPEN_DELEGATE_WRITE代表団が返されます。"
    },
    {
      "indent": 3,
      "text": "o The OPEN_DELEGATE_WRITE delegation is revoked.",
      "ja": "O OPEN_DELEGATE_WRITE委任が取り消されます。"
    },
    {
      "indent": 3,
      "text": "Unless one of the above happens very quickly, one or more NFS4ERR_DELAY errors will be returned while a delegation is outstanding.",
      "ja": "上記のいずれかが非常に迅速に起こる場合を除き代表団が顕著である一方で、一つ以上のNFS4ERR_DELAYエラーが返されます。"
    },
    {
      "indent": 0,
      "text": "18.8. Operation 10: GETFH - Get Current Filehandle",
      "section_title": true,
      "ja": "18.8. 操作10：GETFH  - 現在のファイルハンドルを取得します。"
    },
    {
      "indent": 0,
      "text": "18.8.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.8.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "/* CURRENT_FH: */\nvoid;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.8.2. RESULTS",
      "section_title": true,
      "ja": "18.8.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct GETFH4resok {\n        nfs_fh4         object;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union GETFH4res switch (nfsstat4 status) {\n case NFS4_OK:\n        GETFH4resok     resok4;\n default:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.8.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.8.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation returns the current filehandle value.",
      "ja": "この操作は、現在のファイルハンドル値を返します。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 3,
      "text": "As described in Section 2.10.6.4, GETFH is REQUIRED or RECOMMENDED to immediately follow certain operations, and servers are free to reject such operations if the client fails to insert GETFH in the request as REQUIRED or RECOMMENDED. Section 18.16.4.1 provides additional justification for why GETFH MUST follow OPEN.",
      "ja": "セクション2.10.6.4に説明したように、GETFHは必須か、すぐに特定の操作に従うことを推奨し、クライアントが必須または推奨として要求にGETFHを挿入するために失敗した場合、サーバは、このような操作を拒否するのは自由ですされています。第18.16.4.1はGETFHがOPEN従わなければならない理由のための追加的な正当化を提供します。"
    },
    {
      "indent": 0,
      "text": "18.8.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.8.4. 実装"
    },
    {
      "indent": 3,
      "text": "Operations that change the current filehandle like LOOKUP or CREATE do not automatically return the new filehandle as a result. For instance, if a client needs to look up a directory entry and obtain its filehandle, then the following request is needed.",
      "ja": "LOOKUPのような現在のファイルハンドルを変更したり、CREATE操作は、自動的に結果として新しいファイルハンドルを返しません。クライアントは、ディレクトリエントリを検索し、そのファイルハンドルを取得する必要がある場合、つぎのよう要求が必要とされています。"
    },
    {
      "indent": 6,
      "text": "PUTFH (directory filehandle) LOOKUP (entry name) GETFH",
      "ja": "PUTFH（ディレクトリのファイルハンドル）LOOKUP（エントリ名）GETFH"
    },
    {
      "indent": 0,
      "text": "18.9. Operation 11: LINK - Create Link to a File",
      "section_title": true,
      "ja": "18.9. 操作11：LINK  - ファイルへのリンクを作成します。"
    },
    {
      "indent": 0,
      "text": "18.9.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.9.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct LINK4args {\n        /* SAVED_FH: source object */\n        /* CURRENT_FH: target directory */\n        component4      newname;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.9.2. RESULTS",
      "section_title": true,
      "ja": "18.9.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct LINK4resok {\n        change_info4    cinfo;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union LINK4res switch (nfsstat4 status) {\n case NFS4_OK:\n         LINK4resok resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.9.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.9.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The LINK operation creates an additional newname for the file represented by the saved filehandle, as set by the SAVEFH operation, in the directory represented by the current filehandle. The existing file and the target directory must reside within the same file system on the server. On success, the current filehandle will continue to be the target directory. If an object exists in the target directory with the same name as newname, the server must return NFS4ERR_EXIST.",
      "ja": "現在のファイルハンドルによって表されるディレクトリに、SAVEFH操作によって設定されたLINK操作は、保存されたファイルハンドルによって表されるファイルのための追加NEWNAMEを作成します。既存のファイルとターゲット・ディレクトリは、サーバー上の同じファイルシステム内に存在する必要があります。成功すると、現在のファイルハンドルは、ターゲットディレクトリであり続けるだろう。オブジェクトがNEWNAMEと同じ名前のターゲットディレクトリに存在する場合、サーバはNFS4ERR_EXISTを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.",
      "ja": "ターゲットディレクトリの場合、サーバはcinfoの変化_info4情報を返します。前と後の変更属性がリンク作成に関して原子論が得られた場合には変化_info4データ型の原子分野、意志が示すサーバ。"
    },
    {
      "indent": 3,
      "text": "If the newname has a length of zero, or if newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.",
      "ja": "NEWNAMEがUTF-8定義に従わない場合NEWNAMEがゼロの長さを持っている場合、または、エラーNFS4ERR_INVALが返されます。"
    },
    {
      "indent": 0,
      "text": "18.9.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.9.4. 実装"
    },
    {
      "indent": 3,
      "text": "The server MAY impose restrictions on the LINK operation such that LINK may not be done when the file is open or when that open is done by particular protocols, or with particular options or access modes. When LINK is rejected because of such restrictions, the error NFS4ERR_FILE_OPEN is returned.",
      "ja": "ファイルがそのオープンは特定のプロトコルによって行われたとき、または特定のオプションまたはアクセスモードを持つか、開いているときに、サーバーは、LINKが行われないように、LINK操作に制限を課すことができます。 LINKがあるため、このような制約から拒否された場合、エラーNFS4ERR_FILE_OPENが返されます。"
    },
    {
      "indent": 3,
      "text": "If a server does implement such restrictions and those restrictions include cases of NFSv4 opens preventing successful execution of a link, the server needs to recall any delegations that could hide the existence of opens relevant to that decision. The reason is that when a client holds a delegation, the server might not have an accurate account of the opens for that client, since the client may execute OPENs and CLOSEs locally. The LINK operation must be delayed only until a definitive result can be obtained. For example, suppose there are multiple delegations and one of them establishes an open whose presence would prevent the link. Given the server's semantics, NFS4ERR_FILE_OPEN may be returned to the caller as soon as that delegation is returned without waiting for other delegations to be returned. Similarly, if such opens are not associated with delegations, NFS4ERR_FILE_OPEN can be returned immediately with no delegation recall being done.",
      "ja": "サーバがそのような制限を実装しないと、これらの制限はNFSv4のの例が含まれている場合、リンクが正常に実行されるのを防止開き、サーバーはその決定に関連開くの存在を隠すことができ任意の委任をリコールする必要があります。その理由は、クライアントが委任を保持している場合、サーバはクライアントが開きますを実行する可能性があるため、そのクライアントのために開き、ローカルに閉じの正確なアカウントを持っていないかもしれないということです。 LINK操作は決定的な結果が得られるまでの間だけ遅延させなければなりません。例えば、そこに複数の代表団があり、そのうちの一つは、その存在のリンクを妨げるオープンを確立したとします。その代表団は、他の代表団が返されるのを待たずに返されると、サーバーのセマンティクスを考えると、NFS4ERR_FILE_OPENはすぐに呼び出し側に返されることがあります。そのようなものが代表団に関連付けられていない開いた場合も同様に、NFS4ERR_FILE_OPENには、委任のリコールが行われていないされていると、すぐに返すことができます。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle designates a directory for which another client holds a directory delegation, then, unless the delegation is such that the situation can be resolved by sending a notification, the delegation MUST be recalled, and the operation cannot be performed successfully until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.",
      "ja": "現在のファイルハンドルが別のクライアントがディレクトリの委任を保持するためのディレクトリを指定した場合、代表団は、状況が通知を送信することにより解決することができるようになっている場合を除き、その後、代表団は、リコールされなければならない、と操作が委任されるまで正常に実行することができません返品取り消されます。これは非常に迅速に起こる場合を除いて、一つ以上のNFS4ERR_DELAYエラーが代表団は優れたまま行われる要求に返されます。"
    },
    {
      "indent": 3,
      "text": "When the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, instead of a recall, NOTIFY4_ADD_ENTRY will be generated as a result of the LINK operation.",
      "ja": "現在のファイルハンドルは、1つのまたは複数のディレクトリ委任が存在するディレクトリを指定すると、それらの代表は、そのような通知を要求した場合、その後、代わりにリコール、NOTIFY4_ADD_ENTRYリンク操作の結果として生成されます。"
    },
    {
      "indent": 3,
      "text": "If the current file system supports the numlinks attribute, and other clients have delegations to the file being linked, then those delegations MUST be recalled and the LINK operation MUST NOT proceed until all delegations are returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.",
      "ja": "現在のファイルシステムがnumlinks属性をサポートし、他のクライアントがファイルへの代表団リンクされている場合は、それらの代表団は、リコールされなければならないし、すべての代表団が返さまたは取り消されるまでLINK操作が続行してはなりません。これは非常に迅速に起こる場合を除いて、一つ以上のNFS4ERR_DELAYエラーが代表団は優れたまま行われる要求に返されます。"
    },
    {
      "indent": 3,
      "text": "Changes to any property of the \"hard\" linked files are reflected in all of the linked files. When a link is made to a file, the attributes for the file should have a value for numlinks that is one greater than the value before the LINK operation.",
      "ja": "「ハード」リンクされたファイルの任意のプロパティを変更すると、リンクされたファイルのすべてに反映されています。リンクをファイルにするとき、ファイルの属性はLINK操作前の値より1大きいnumlinksの値を持つ必要があります。"
    },
    {
      "indent": 3,
      "text": "The statement \"file and the target directory must reside within the same file system on the server\" means that the fsid fields in the attributes for the objects are the same. If they reside on different file systems, the error NFS4ERR_XDEV is returned. This error may be returned by some servers when there is an internal partitioning of a file system that the LINK operation would violate.",
      "ja": "声明「ファイルとターゲット・ディレクトリは、サーバー上の同じファイルシステム内に存在しなければならない」オブジェクトの属性でFSIDフィールドが同じであることを意味します。彼らは異なるファイルシステム上に存在する場合は、エラーNFS4ERR_XDEVが返されます。 LINK操作が違反するファイルシステムの内部パーティションがある場合に、このエラーが一部のサーバーによって返されることがあります。"
    },
    {
      "indent": 3,
      "text": "On some servers, \".\" and \"..\" are illegal values for newname and the error NFS4ERR_BADNAME will be returned if they are specified.",
      "ja": "一部のサーバでは、「」そして、「..」newnameのために不正な値があり、それらが指定されている場合、エラーNFS4ERR_BADNAMEが返されます。"
    },
    {
      "indent": 3,
      "text": "When the current filehandle designates a named attribute directory and the object to be linked (the saved filehandle) is not a named attribute for the same object, the error NFS4ERR_XDEV MUST be returned. When the saved filehandle designates a named attribute and the current filehandle is not the appropriate named attribute directory, the error NFS4ERR_XDEV MUST also be returned.",
      "ja": "現在のファイルハンドルが指定された属性のディレクトリを指定してリンクするオブジェクト（保存されたファイルハンドル）は、同じオブジェクトの名前付き属性でない場合は、エラーNFS4ERR_XDEVを返さなければなりません。保存されたファイルハンドルは、名前の属性を指定し、現在のファイルハンドルが属性という名前のディレクトリ適切でない場合は、エラーNFS4ERR_XDEVも返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the current filehandle designates a named attribute directory and the object to be linked (the saved filehandle) is a named attribute within that directory, the server may return the error NFS4ERR_NOTSUPP.",
      "ja": "現在のファイルハンドルが指定された属性のディレクトリを指定してリンクするオブジェクト（保存されたファイルハンドル）がそのディレクトリ内の名前付き属性である場合には、サーバがエラーNFS4ERR_NOTSUPPを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "In the case that newname is already linked to the file represented by the saved filehandle, the server will return NFS4ERR_EXIST.",
      "ja": "NEWNAMEがすでに保存されたファイルハンドルによって表されるファイルにリンクされている場合には、サーバがNFS4ERR_EXISTを返します。"
    },
    {
      "indent": 3,
      "text": "Note that symbolic links are created with the CREATE operation.",
      "ja": "シンボリックリンクが作成操作で作成されていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "18.10. Operation 12: LOCK - Create Lock",
      "section_title": true,
      "ja": "18.10. 操作12：LOCK  - ロックを作成します。"
    },
    {
      "indent": 0,
      "text": "18.10.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.10.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "/*\n * For LOCK, transition from open_stateid and lock_owner\n * to a lock stateid.\n */\nstruct open_to_lock_owner4 {\n        seqid4          open_seqid;\n        stateid4        open_stateid;\n        seqid4          lock_seqid;\n        lock_owner4     lock_owner;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * For LOCK, existing lock stateid continues to request new\n * file lock for the same lock_owner and open_stateid.\n */\nstruct exist_lock_owner4 {\n        stateid4        lock_stateid;\n        seqid4          lock_seqid;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union locker4 switch (bool new_lock_owner) {\n case TRUE:\n        open_to_lock_owner4     open_owner;\n case FALSE:\n        exist_lock_owner4       lock_owner;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * LOCK/LOCKT/LOCKU: Record lock management\n */\nstruct LOCK4args {\n        /* CURRENT_FH: file */\n        nfs_lock_type4  locktype;\n        bool            reclaim;\n        offset4         offset;\n        length4         length;\n        locker4         locker;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.10.2. RESULTS",
      "section_title": true,
      "ja": "18.10.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct LOCK4denied {\n        offset4         offset;\n        length4         length;\n        nfs_lock_type4  locktype;\n        lock_owner4     owner;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct LOCK4resok {\n        stateid4        lock_stateid;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union LOCK4res switch (nfsstat4 status) {\n case NFS4_OK:\n         LOCK4resok     resok4;\n case NFS4ERR_DENIED:\n         LOCK4denied    denied;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.10.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.10.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The LOCK operation requests a byte-range lock for the byte-range specified by the offset and length parameters, and lock type specified in the locktype parameter. If this is a reclaim request, the reclaim parameter will be TRUE.",
      "ja": "LOCK操作は、オフセットおよび長さパラメータ、及び種類のLockTypeパラメータで指定されたロックタイプで指定されたバイト範囲のバイト範囲ロックを要求します。これは再利用要求がある場合は、再利用パラメータがTRUEになります。"
    },
    {
      "indent": 3,
      "text": "Bytes in a file may be locked even if those bytes are not currently allocated to the file. To lock the file from a specific offset through the end-of-file (no matter how long the file actually is) use a length field equal to NFS4_UINT64_MAX. The server MUST return NFS4ERR_INVAL under the following combinations of length and offset:",
      "ja": "それらのバイトが現在のファイルに割り当てられていない場合でも、ファイル内のバイトをロックすることができます。エンド・オブ・ファイルを介して特定のオフセット（ファイルが実際にどのくらいの時間に関係なく）からファイルをロックするにはNFS4_UINT64_MAXに等しい長さフィールドを使用します。サーバーは、長さとオフセットの次の組み合わせの下でNFS4ERR_INVALを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "o Length is equal to zero.",
      "ja": "Oの長さはゼロに等しいです。"
    },
    {
      "indent": 3,
      "text": "o Length is not equal to NFS4_UINT64_MAX, and the sum of length and offset exceeds NFS4_UINT64_MAX.",
      "ja": "O LengthはNFS4_UINT64_MAXに等しくない場合、長さの和とNFS4_UINT64_MAXを超えるオフセット。"
    },
    {
      "indent": 3,
      "text": "32-bit servers are servers that support locking for byte offsets that fit within 32 bits (i.e., less than or equal to NFS4_UINT32_MAX). If the client specifies a range that overlaps one or more bytes beyond offset NFS4_UINT32_MAX but does not end at offset NFS4_UINT64_MAX, then such a 32-bit server MUST return the error NFS4ERR_BAD_RANGE.",
      "ja": "32ビット・サーバは32ビット内に（すなわち、より少ない又はNFS4_UINT32_MAXに等しい）を取り付けバイトオフセットのロックサポートするサーバーです。クライアントオフセットNFS4_UINT32_MAX超えて1バイト以上に重なるが、オフセットNFS4_UINT64_MAXで終了しない範囲を指定した場合、そのような32ビット・サーバはエラーNFS4ERR_BAD_RANGEを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the server returns NFS4ERR_DENIED, the owner, offset, and length of a conflicting lock are returned.",
      "ja": "サーバはNFS4ERR_DENIED、所有者を返した場合、オフセット、および競合ロックの長さが返されます。"
    },
    {
      "indent": 3,
      "text": "The locker argument specifies the lock-owner that is associated with the LOCK operation. The locker4 structure is a switched union that indicates whether the client has already created byte-range locking state associated with the current open file and lock-owner. In the case in which it has, the argument is just a stateid representing the set of locks associated with that open file and lock-owner, together with a lock_seqid value that MAY be any value and MUST be ignored by the server. In the case where no byte-range locking state has been established, or the client does not have the stateid available, the argument contains the stateid of the open file with which this lock is to be associated, together with the lock-owner with which the lock is to be associated. The open_to_lock_owner case covers the very first lock done by a lock-owner for a given open file and offers a method to use the established state of the open_stateid to transition to the use of a lock stateid.",
      "ja": "ロッカーの引数は、LOCK操作に関連付けられたロック所有者を指定します。 locker4構造は、クライアントがすでに現在開いているファイルに関連付けられているバイト範囲ロック状態とロック所有者が作成したかどうかを示す切り替え組合です。それが有する場合に、引数が一緒に任意の値であってもよく、サーバによって無視されなければならないlock_seqid値と、そのファイルを開き、ロック所有者に関連付けられているロックのセットを表すだけのstateidあります。何のバイト範囲ロック状態が確立されていない、またはクライアントが利用可能なstateidを持っていない場合には、引数は、ロック所有者と一緒に、このロックが関連付けられる開いているファイルのたstateidが含まれているとロックが関連していることがあります。 open_to_lock_ownerケースは、所与のオープンファイルのロック所有者によって行われ、非常に最初のロックをカバーし、ロックのstateidの使用に移行するopen_stateidの確立された状態を使用する方法を提供します。"
    },
    {
      "indent": 3,
      "text": "The following fields of the locker parameter MAY be set to any value by the client and MUST be ignored by the server:",
      "ja": "ロッカーパラメータの次のフィールドは、クライアントによって任意の値に設定することができ、サーバによって無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The clientid field of the lock_owner field of the open_owner field (locker.open_owner.lock_owner.clientid). The reason the server MUST ignore the clientid field is that the server MUST derive the client ID from the session ID from the SEQUENCE operation of the COMPOUND request.",
      "ja": "open_ownerフィールド（locker.open_owner.lock_owner.clientid）のlock_ownerフィールドのクライアントIDフィールドO。サーバはclientidのフィールドを無視しなければならない理由は、サーバがCOMPOUND要求のシーケンス動作からセッションIDからのクライアントIDを導出しなければならないということです。"
    },
    {
      "indent": 3,
      "text": "o The open_seqid and lock_seqid fields of the open_owner field (locker.open_owner.open_seqid and locker.open_owner.lock_seqid).",
      "ja": "O open_seqidとopen_ownerフィールド（locker.open_owner.open_seqidとlocker.open_owner.lock_seqid）のlock_seqidフィールド。"
    },
    {
      "indent": 3,
      "text": "o The lock_seqid field of the lock_owner field (locker.lock_owner.lock_seqid).",
      "ja": "lock_ownerフィールド（locker.lock_owner.lock_seqid）のlock_seqidフィールドO。"
    },
    {
      "indent": 3,
      "text": "Note that the client ID appearing in a LOCK4denied structure is the actual client associated with the conflicting lock, whether this is the client ID associated with the current session or a different one. Thus, if the server returns NFS4ERR_DENIED, it MUST set the clientid field of the owner field of the denied field.",
      "ja": "これは現在のセッションまたは別のものに関連付けられたクライアントIDであるかどうか、LOCK4denied構造に現れるクライアントIDが競合するロックに関連付けられた実際のクライアントであることに留意されたいです。サーバがNFS4ERR_DENIEDを返した場合このように、それは拒否されたフィールドの所有者フィールドのClientIDをフィールドを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.",
      "ja": "現在のファイルハンドルが通常のファイルでない場合、エラーがクライアントに返されます。現在のファイルハンドルが型NF4DIRのオブジェクトを表す場合には、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定した場合、NFS4ERR_SYMLINKが返されます。他のすべてのケースでは、NFS4ERR_WRONG_TYPEが返されます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.10.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.10.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the server is unable to determine the exact offset and length of the conflicting byte-range lock, the same offset and length that were provided in the arguments should be returned in the denied results.",
      "ja": "サーバが競合バイト範囲ロックの正確なオフセットと長さを決定することができない場合は、同じオフセットと引数で提供された長さが拒否された結果で返されるべきです。"
    },
    {
      "indent": 3,
      "text": "LOCK operations are subject to permission checks and to checks against the access type of the associated file. However, the specific right and modes required for various types of locks reflect the semantics of the server-exported file system, and are not specified by the protocol. For example, Windows 2000 allows a write lock of a file open for read access, while a POSIX-compliant system does not.",
      "ja": "LOCK操作は、権限チェックにと関連付けられたファイルのアクセスタイプに対するチェックの対象となります。しかし、具体的な権利とロックの様々なタイプのために必要なモードでは、サーバー・エクスポートされたファイルシステムのセマンティクスを反映しており、プロトコルによって指定されていません。 POSIX準拠のシステムではそうではないたとえば、Windows 2000は、読み取りアクセスのために開いているファイルの書き込みロックを可能にします。"
    },
    {
      "indent": 3,
      "text": "When the client sends a LOCK operation that corresponds to a range that the lock-owner has locked already (with the same or different lock type), or to a sub-range of such a range, or to a byte-range that includes multiple locks already granted to that lock-owner, in whole or in part, and the server does not support such locking operations (i.e., does not support POSIX locking semantics), the server will return the error NFS4ERR_LOCK_RANGE. In that case, the client may return an error, or it may emulate the required operations, using only LOCK for ranges that do not include any bytes already locked by that lock-owner and LOCKU of locks held by that lock-owner (specifying an exactly matching range and type). Similarly, when the client sends a LOCK operation that amounts to upgrading (changing from a READ_LT lock to a WRITE_LT lock) or downgrading (changing from WRITE_LT lock to a READ_LT lock) an existing byte-range lock, and the server does not support such a lock, the server will return NFS4ERR_LOCK_NOTSUPP. Such operations may not perfectly reflect the required semantics in the face of conflicting LOCK operations from other clients.",
      "ja": "クライアントは、ロック所有者は、（同一または異なるロックタイプで）既にロックされた範囲に対応する、またはそのような範囲のサブ範囲、または複数含むバイト範囲ロック操作を送信する場合ロックは、すでに全体的または部分的に、そのロックの所有者に付与され、サーバは（つまり、POSIXロックのセマンティクスをサポートしていません）、サーバーがエラーNFS4ERR_LOCK_RANGEを返します、このようなロック操作をサポートしていません。その場合には、（既にロック所有者が保持しているロックのロック所有者とLOCKUによってロック任意のバイトを含まない範囲のロックを指定するだけ用い、クライアントは、エラーを返すことがあり、あるいは、必要な操作をエミュレートすることができます正確に）範囲およびタイプ一致。同様に、クライアントは、（WRITE_LTロックにREAD_LTロックから変更）またはダウングレード（READ_LTロックにWRITE_LTロックから変更）既存のバイト範囲ロックのアップグレードになるLOCK操作を送信し、サーバは、そのようなをサポートしていないときロックは、サーバがNFS4ERR_LOCK_NOTSUPPを返します。このような操作は完全に他のクライアントからLOCK操作の競合に直面して必要なセマンティクスを反映していないことがあります。"
    },
    {
      "indent": 3,
      "text": "When a client holds an OPEN_DELEGATE_WRITE delegation, the client holding that delegation is assured that there are no opens by other clients. Thus, there can be no conflicting LOCK operations from such clients. Therefore, the client may be handling locking requests locally, without doing LOCK operations on the server. If it does that, it must be prepared to update the lock status on the server, by sending appropriate LOCK and LOCKU operations before returning the delegation.",
      "ja": "クライアントがOPEN_DELEGATE_WRITE委任を保持している場合は、その委任を保持しているクライアントは、他のクライアントで開く何が存在しないことが保証されます。したがって、そのようなクライアントからの競合LOCK操作がないことができます。そのため、クライアントは、サーバ上のLOCK操作を行うことなく、ローカルにロック要求を処理することができます。それはない場合、代表団を返す前に、適切なLOCKとLOCKU操作を送信することにより、サーバー上のロック状態を更新するために準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "When one or more clients hold OPEN_DELEGATE_READ delegations, any LOCK operation where the server is implementing mandatory locking semantics MUST result in the recall of all such delegations. The LOCK operation may not be granted until all such delegations are returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding.",
      "ja": "1つ以上のクライアントがOPEN_DELEGATE_READ代表団を保持する場合、サーバは強制ロックセマンティクスを実装している任意のLOCK操作はすべて、このような代表団のリコールをもたらさなければなりません。このようなすべての代表団が返されるか取り消されるまでLOCK操作は許可されない場合があります。これは非常に迅速に起こる場合を除いて、一つ以上のNFS4ERR_DELAYエラーが代表団は優れたまま行われる要求に返されます。"
    },
    {
      "indent": 0,
      "text": "18.11. Operation 13: LOCKT - Test for Lock",
      "section_title": true,
      "ja": "11.18. 操作13：ルアー - ロックのテスト"
    },
    {
      "indent": 0,
      "text": "18.11.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.11.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct LOCKT4args {\n        /* CURRENT_FH: file */\n        nfs_lock_type4  locktype;\n        offset4         offset;\n        length4         length;\n        lock_owner4     owner;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.11.2. RESULTS",
      "section_title": true,
      "ja": "18.11.2. 結果"
    },
    {
      "indent": 3,
      "text": "union LOCKT4res switch (nfsstat4 status) {\n case NFS4ERR_DENIED:\n         LOCK4denied    denied;\n case NFS4_OK:\n         void;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.11.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.11.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The LOCKT operation tests the lock as specified in the arguments. If a conflicting lock exists, the owner, offset, length, and type of the conflicting lock are returned. The owner field in the results includes the client ID of the owner of the conflicting lock, whether this is the client ID associated with the current session or a different client ID. If no lock is held, nothing other than NFS4_OK is returned. Lock types READ_LT and READW_LT are processed in the same way in that a conflicting lock test is done without regard to blocking or non-blocking. The same is true for WRITE_LT and WRITEW_LT.",
      "ja": "LOCKT操作は、引数で指定されたロックをテストします。競合するロックが存在する場合、競合するロックの所有者、オフセット、長さ、およびタイプが戻されます。結果に所有者フィールドは、これが現在のセッションまたは異なるクライアントIDに関連付けられたクライアントIDであるか否かを、競合するロックの所有者のクライアントIDを含みます。何もロックが保持されていない場合は、NFS4_OK以外何も返されません。ロックタイプREAD_LTとREADW_LTがその矛盾するロックテストで同じように処理されているが、ブロッキングまたは非ブロッキングとは関係なく行われます。同じことがWRITE_LTとWRITEW_LTについても同様です。"
    },
    {
      "indent": 3,
      "text": "The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.",
      "ja": "範囲はLOCK用として指定されています。 NFS4ERR_INVALとNFS4ERR_BAD_RANGEエラーがLOCKと同じ状況下で返されます。"
    },
    {
      "indent": 3,
      "text": "The clientid field of the owner MAY be set to any value by the client and MUST be ignored by the server. The reason the server MUST ignore the clientid field is that the server MUST derive the client ID from the session ID from the SEQUENCE operation of the COMPOUND request.",
      "ja": "所有者のClientIDをフィールドは、クライアントによって任意の値に設定することができ、サーバによって無視しなければなりません。サーバはclientidのフィールドを無視しなければならない理由は、サーバがCOMPOUND要求のシーケンス動作からセッションIDからのクライアントIDを導出しなければならないということです。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.",
      "ja": "現在のファイルハンドルが通常のファイルでない場合、エラーがクライアントに返されます。現在のファイルハンドルが型NF4DIRのオブジェクトを表す場合には、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定した場合、NFS4ERR_SYMLINKが返されます。他のすべてのケースでは、NFS4ERR_WRONG_TYPEが返されます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.11.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.11.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the server is unable to determine the exact offset and length of the conflicting lock, the same offset and length that were provided in the arguments should be returned in the denied results.",
      "ja": "サーバは競合ロックの正確なオフセットと長さを決定することができない場合は、引数に与えたのと同じオフセットと長さが拒否された結果で返されるべきです。"
    },
    {
      "indent": 3,
      "text": "LOCKT uses a lock_owner4 rather a stateid4, as is used in LOCK to identify the owner. This is because the client does not have to open the file to test for the existence of a lock, so a stateid might not be available.",
      "ja": "LOCKTは、所有者を識別するためにLOCKに使用されるように、むしろstateid4をlock_owner4を使用します。クライアントはロックが存在するかどうかをテストするためにファイルを開く必要がないので、のstateidは使用できない可能性があるためです。"
    },
    {
      "indent": 3,
      "text": "As noted in Section 18.10.4, some servers may return NFS4ERR_LOCK_RANGE to certain (otherwise non-conflicting) LOCK operations that overlap ranges already granted to the current lock-owner.",
      "ja": "セクション18.10.4で述べたように、いくつかのサーバは、既に現在のロックの所有者に付与された範囲と重なる一定（そうでなければ非競合）LOCK操作にNFS4ERR_LOCK_RANGEを返すことができます。"
    },
    {
      "indent": 3,
      "text": "The LOCKT operation's test for conflicting locks SHOULD exclude locks for the current lock-owner, and thus should return NFS4_OK in such cases. Note that this means that a server might return NFS4_OK to a LOCKT request even though a LOCK operation for the same range and lock-owner would fail with NFS4ERR_LOCK_RANGE.",
      "ja": "競合するロック用LOCKT操作のテストは、現在のロック所有者のためにロックを除外する必要があり、したがって、そのような場合にNFS4_OKを返す必要があります。これは、サーバーが同じ範囲とロック所有者のためのLOCK操作はNFS4ERR_LOCK_RANGEで失敗していてもLOCKT要求にNFS4_OKを返す可能性があることを意味することに注意してください。"
    },
    {
      "indent": 3,
      "text": "When a client holds an OPEN_DELEGATE_WRITE delegation, it may choose (see Section 18.10.4) to handle LOCK requests locally. In such a case, LOCKT requests will similarly be handled locally.",
      "ja": "クライアントがOPEN_DELEGATE_WRITE委任を保持している場合は、ローカルでLOCK要求を処理するために（セクション18.10.4を参照）を選択することができます。このような場合には、LOCKT要求は同様にローカルに処理されるであろう。"
    },
    {
      "indent": 0,
      "text": "18.12. Operation 14: LOCKU - Unlock File",
      "section_title": true,
      "ja": "18.12. 操作14：LOCKU  - ファイルのロックを解除"
    },
    {
      "indent": 0,
      "text": "18.12.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.12.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct LOCKU4args {\n        /* CURRENT_FH: file */\n        nfs_lock_type4  locktype;\n        seqid4          seqid;\n        stateid4        lock_stateid;\n        offset4         offset;\n        length4         length;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.12.2. RESULTS",
      "section_title": true,
      "ja": "18.12.2. 結果"
    },
    {
      "indent": 3,
      "text": "union LOCKU4res switch (nfsstat4 status) {\n case   NFS4_OK:\n         stateid4       lock_stateid;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.12.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.12.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The LOCKU operation unlocks the byte-range lock specified by the parameters. The client may set the locktype field to any value that is legal for the nfs_lock_type4 enumerated type, and the server MUST accept any legal value for locktype. Any legal value for locktype has no effect on the success or failure of the LOCKU operation.",
      "ja": "LOCKU操作は、パラメータで指定されたバイト範囲ロックを解除します。クライアントはnfs_lock_type4列挙型のために合法的である任意の値にLockTypeのフィールドを設定すること、およびサーバーがのLockTypeのための法的な価値を受け入れなければなりません。 LockTypeのための任意の有効な値はLOCKU操作の成功または失敗には影響を与えません。"
    },
    {
      "indent": 3,
      "text": "The ranges are specified as for LOCK. The NFS4ERR_INVAL and NFS4ERR_BAD_RANGE errors are returned under the same circumstances as for LOCK.",
      "ja": "範囲はLOCK用として指定されています。 NFS4ERR_INVALとNFS4ERR_BAD_RANGEエラーがLOCKと同じ状況下で返されます。"
    },
    {
      "indent": 3,
      "text": "The seqid parameter MAY be any value and the server MUST ignore it.",
      "ja": "SEQIDパラメータは任意の値であってもよいし、サーバはそれを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.",
      "ja": "現在のファイルハンドルが通常のファイルでない場合、エラーがクライアントに返されます。現在のファイルハンドルが型NF4DIRのオブジェクトを表す場合には、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定した場合、NFS4ERR_SYMLINKが返されます。他のすべてのケースでは、NFS4ERR_WRONG_TYPEが返されます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 3,
      "text": "The server MAY require that the principal, security flavor, and if applicable, the GSS mechanism, combination that sent a LOCK operation also be the one to send LOCKU on the file. This might not be possible if credentials for the principal are no longer available. The server MAY allow the machine credential or SSV credential (see Section 18.35) to send LOCKU.",
      "ja": "サーバーは、LOCK操作を送っ校長、セキュリティ風味、および該当する場合、GSSメカニズムは、組み合わせはまた、ファイルにLOCKUを送信するために一つであることを必要とする場合があります。主体の資格が利用できなくなっている場合、これはできないかもしれません。サーバーは、マシンの資格やSSV資格は（項18.35を参照）LOCKUを送信することを可能にします。"
    },
    {
      "indent": 0,
      "text": "18.12.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.12.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the area to be unlocked does not correspond exactly to a lock actually held by the lock-owner, the server may return the error NFS4ERR_LOCK_RANGE. This includes the case in which the area is not locked, where the area is a sub-range of the area locked, where it overlaps the area locked without matching exactly, or the area specified includes multiple locks held by the lock-owner. In all of these cases, allowed by POSIX locking [24] semantics, a client receiving this error should, if it desires support for such operations, simulate the operation using LOCKU on ranges corresponding to locks it actually holds, possibly followed by LOCK operations for the sub-ranges not being unlocked.",
      "ja": "ロックを解除するための領域が実際にロック所有者が保持しているロックに正確に対応していない場合、サーバーはエラーNFS4ERR_LOCK_RANGEを返すことがあります。これは、領域は、それが正確に一致せずにロックされた領域と重なる、または指定された領域は、ロック所有者が保持している複数のロックを含むロックされた領域のサブ領域である領域がロックされていない場合を含みます。 POSIXによって許さこれらの場合の全てにおいて、[24]のセマンティクスをロックする、そのような操作をサポートしたい場合、それが実際に可能性のロック操作に続いて、保持しているロックに対応する範囲にLOCKUを使用して動作をシミュレートする必要があり、このエラーを受信したクライアント小範囲のロックが解除されていません。"
    },
    {
      "indent": 3,
      "text": "When a client holds an OPEN_DELEGATE_WRITE delegation, it may choose (see Section 18.10.4) to handle LOCK requests locally. In such a case, LOCKU operations will similarly be handled locally.",
      "ja": "クライアントがOPEN_DELEGATE_WRITE委任を保持している場合は、ローカルでLOCK要求を処理するために（セクション18.10.4を参照）を選択することができます。このような場合には、LOCKU動作は同様にローカルに処理されるであろう。"
    },
    {
      "indent": 0,
      "text": "18.13. Operation 15: LOOKUP - Lookup Filename",
      "section_title": true,
      "ja": "18.13. 操作15：LOOKUP  - 検索ファイル名"
    },
    {
      "indent": 0,
      "text": "18.13.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.13.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct LOOKUP4args {\n        /* CURRENT_FH: directory */\n        component4      objname;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.13.2. RESULTS",
      "section_title": true,
      "ja": "18.13.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct LOOKUP4res {\n        /* New CURRENT_FH: object */\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.13.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.13.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The LOOKUP operation looks up or finds a file system object using the directory specified by the current filehandle. LOOKUP evaluates the component and if the object exists, the current filehandle is replaced with the component's filehandle.",
      "ja": "LOOKUP操作は見上げたり、現在のファイルハンドルで指定されたディレクトリを使用してファイル・システム・オブジェクトを検索します。 LOOKUPは、コンポーネントを評価したオブジェクトが存在する場合、現在のファイルハンドルは、コンポーネントのファイルハンドルに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "If the component cannot be evaluated either because it does not exist or because the client does not have permission to evaluate the component, then an error will be returned and the current filehandle will be unchanged.",
      "ja": "コンポーネントは評価できない場合、クライアントはコンポーネントを評価する権限を持っていないので、それが存在したりしないのでどちらか、エラーが返され、現在のファイルハンドルは変更されません。"
    },
    {
      "indent": 3,
      "text": "If the component is a zero-length string or if any component does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.",
      "ja": "部品は長さゼロの文字列である場合、またはいずれかのコンポーネントがUTF-8定義に従わない場合は、エラーNFS4ERR_INVALが返されます。"
    },
    {
      "indent": 0,
      "text": "18.13.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.13.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the client wants to achieve the effect of a multi-component look up, it may construct a COMPOUND request such as (and obtain each filehandle):",
      "ja": "クライアントが見上げる多成分の効果を実現したい場合は、このような複合要求を構築（および各ファイルハンドルを得る）ことがあります。"
    },
    {
      "indent": 9,
      "text": "PUTFH  (directory filehandle)\nLOOKUP \"pub\"\nGETFH\nLOOKUP \"foo\"\nGETFH\nLOOKUP \"bar\"\nGETFH",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Unlike NFSv3, NFSv4.1 allows LOOKUP requests to cross mountpoints on the server. The client can detect a mountpoint crossing by comparing the fsid attribute of the directory with the fsid attribute of the directory looked up. If the fsids are different, then the new directory is a server mountpoint. UNIX clients that detect a mountpoint crossing will need to mount the server's file system. This needs to be done to maintain the file object identity checking mechanisms common to UNIX clients.",
      "ja": "NFSv3のとは異なり、NFSv4.1はLOOKUP要求がサーバー上でマウントポイントを横断することができます。ディレクトリのFSID属性を持つディレクトリのFSID属性を比較することにより、マウントポイントの交差を検出することができ、クライアントは見上げました。 fsidsが異なる場合は、新しいディレクトリには、サーバーのマウントポイントです。マウントポイントの交差点を検出するUNIXクライアントは、サーバーのファイルシステムをマウントする必要があります。これは、UNIXクライアントに共通のメカニズムをチェックするファイルオブジェクトのアイデンティティを維持するために行われる必要があります。"
    },
    {
      "indent": 3,
      "text": "Servers that limit NFS access to \"shared\" or \"exported\" file systems should provide a pseudo file system into which the exported file systems can be integrated, so that clients can browse the server's namespace. The clients view of a pseudo file system will be limited to paths that lead to exported file systems.",
      "ja": "「共有」またはファイル・システムは、クライアントがサーバーの名前空間を参照できるように、エクスポートされたファイルシステムは、統合することができますその中に擬似ファイルシステムを提供しなければならない「エクスポート」へのNFSアクセスを制限するサーバー。擬似ファイルシステムのクライアント・ビューは、エクスポートされたファイルシステムに至る経路に限定されるであろう。"
    },
    {
      "indent": 3,
      "text": "Note: previous versions of the protocol assigned special semantics to the names \".\" and \"..\". NFSv4.1 assigns no special semantics to these names. The LOOKUPP operator must be used to look up a parent directory.",
      "ja": "注意：名前に特別な意味を割り当てるプロトコルの以前のバージョン「」そして、 \"..\"。 NFSv4.1は、これらの名前に特別な意味を割り当てません。 LOOKUPP演算子は、親ディレクトリを検索するために使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that this operation does not follow symbolic links. The client is responsible for all parsing of filenames including filenames that are modified by symbolic links encountered during the look up process.",
      "ja": "この操作はシンボリックリンクをたどらないことに注意してください。クライアントは、ルックアッププロセス中に遭遇したシンボリックリンクで変更されたファイル名を含むファイル名のすべての解析を担当しています。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle supplied is not a directory but a symbolic link, the error NFS4ERR_SYMLINK is returned as the error. For all other non-directory file types, the error NFS4ERR_NOTDIR is returned.",
      "ja": "供給される電流のファイルハンドルがディレクトリが、シンボリックリンクではない場合は、エラーNFS4ERR_SYMLINKはエラーとして返されます。他のすべてのディレクトリ以外のファイルタイプの場合は、エラーNFS4ERR_NOTDIRが返されます。"
    },
    {
      "indent": 0,
      "text": "18.14. Operation 16: LOOKUPP - Lookup Parent Directory",
      "section_title": true,
      "ja": "18.14. 操作16：LOOKUPP  - 検索親ディレクトリ"
    },
    {
      "indent": 0,
      "text": "18.14.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.14.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "/* CURRENT_FH: object */\nvoid;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.14.2. RESULTS",
      "section_title": true,
      "ja": "18.14.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct LOOKUPP4res {\n        /* new CURRENT_FH: parent directory */\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.14.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.14.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The current filehandle is assumed to refer to a regular directory or a named attribute directory. LOOKUPP assigns the filehandle for its parent directory to be the current filehandle. If there is no parent directory, an NFS4ERR_NOENT error must be returned. Therefore, NFS4ERR_NOENT will be returned by the server when the current filehandle is at the root or top of the server's file tree.",
      "ja": "現在のファイルハンドルは通常のディレクトリや名前付き属性のディレクトリを参照すると想定されます。 LOOKUPPは、現在のファイルハンドルであることを、その親ディレクトリのファイルハンドルを割り当てます。親ディレクトリが存在しない場合は、NFS4ERR_NOENTエラーが返されなければなりません。現在のファイルハンドルは、ルートまたはサーバーのファイルツリーの最上部にあるときにそのため、NFS4ERR_NOENTは、サーバーによって返されます。"
    },
    {
      "indent": 3,
      "text": "As is the case with LOOKUP, LOOKUPP will also cross mountpoints.",
      "ja": "LOOKUPと同様に、LOOKUPはまた、マウントポイントを横断します。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is not a directory or named attribute directory, the error NFS4ERR_NOTDIR is returned.",
      "ja": "現在のファイルハンドルがディレクトリまたは名前付き属性ディレクトリでない場合は、エラーNFS4ERR_NOTDIRが返されます。"
    },
    {
      "indent": 3,
      "text": "If the requester's security flavor does not match that configured for the parent directory, then the server SHOULD return NFS4ERR_WRONGSEC (a future minor revision of NFSv4 may upgrade this to MUST) in the LOOKUPP response. However, if the server does so, it MUST support the SECINFO_NO_NAME operation (Section 18.45), so that the client can gracefully determine the correct security flavor.",
      "ja": "要求者のセキュリティ風味が親ディレクトリ用に構成されていることと一致しない場合、サーバーはLOOKUPP応答で（NFSv4の将来のマイナーリビジョンがMUSTにこれをアップグレードする場合があります）NFS4ERR_WRONGSECを返すべきです。サーバーがそうするならば、クライアントは優雅に正しいセキュリティ風味を決定することができるようにしかし、それは、SECINFO_NO_NAME操作（セクション18.45）をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is a named attribute directory that is associated with a file system object via OPENATTR (i.e., not a sub-directory of a named attribute directory), LOOKUPP SHOULD return the filehandle of the associated file system object.",
      "ja": "現在のファイルハンドルがOPENATTRを介してファイル・システム・オブジェクトに関連付けられている名前付き属性ディレクトリである場合（すなわち、指定された属性ディレクトリのないサブディレクトリ）、LOOKUPPは、関連するファイル・システム・オブジェクトのファイルハンドルを返すべきです。"
    },
    {
      "indent": 0,
      "text": "18.14.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.14.4. 実装"
    },
    {
      "indent": 3,
      "text": "An issue to note is upward navigation from named attribute directories. The named attribute directories are essentially detached from the namespace, and this property should be safely represented in the client operating environment. LOOKUPP on a named attribute directory may return the filehandle of the associated file, and conveying this to applications might be unsafe as many applications expect the parent of an object to always be a directory. Therefore, the client may want to hide the parent of named attribute directories (represented as \"..\" in UNIX) or represent the named attribute directory as its own parent (as is typically done for the file system root directory in UNIX).",
      "ja": "注意すべき問題は、名前付き属性のディレクトリから上向きのナビゲーションです。名前付き属性のディレクトリは、本質的に、名前空間から切り離されており、このプロパティは、安全に、クライアントの動作環境で表現されなければなりません。名前の属性ディレクトリ上のLOOKUPPは、関連するファイルのファイルハンドルを返すことがあり、多くのアプリケーションは、オブジェクトの親は常にディレクトリであることを期待などのアプリケーションにこれを伝えることは安全ではないかもしれません。そのため、クライアントは、（通常はUNIXのファイルシステムのルートディレクトリのために行われているように）という名前の属性ディレクトリの親を非表示にする（UNIXで「..」として表される）や、自身の親として名前の属性ディレクトリを表すことができます。"
    },
    {
      "indent": 0,
      "text": "18.15. Operation 17: NVERIFY - Verify Difference in Attributes",
      "section_title": true,
      "ja": "18.15. 操作17：NVERIFY  - 属性の違いを確認してください"
    },
    {
      "indent": 0,
      "text": "18.15.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.15.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct NVERIFY4args {\n        /* CURRENT_FH: object */\n        fattr4          obj_attributes;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.15.2. RESULTS",
      "section_title": true,
      "ja": "18.15.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct NVERIFY4res {\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.15.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.15.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation is used to prefix a sequence of operations to be performed if one or more attributes have changed on some file system object. If all the attributes match, then the error NFS4ERR_SAME MUST be returned.",
      "ja": "この操作は、1つ以上の属性は、いくつかのファイル・システム・オブジェクトに変更した場合に実行する一連の操作の前に付けるために使用されます。すべての属性が一致する場合、エラーNFS4ERR_SAMEを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.15.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.15.4. 実装"
    },
    {
      "indent": 3,
      "text": "This operation is useful as a cache validation operator. If the object to which the attributes belong has changed, then the following operations may obtain new data associated with that object, for instance, to check if a file has been changed and obtain new data if it has:",
      "ja": "この操作は、キャッシュ検証オペレーターとして有用です。属性が所属するオブジェクトが変更された場合は、以下の操作は、ファイルが変更されているかどうかを確認し、それが持っている場合は、新しいデータを取得するために、たとえば、そのオブジェクトに関連付けられた新しいデータを、取得することがあります。"
    },
    {
      "indent": 9,
      "text": "SEQUENCE\nPUTFH fh\nNVERIFY attrbits attrs\nREAD 0 32767",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Contrast this with NFSv3, which would first send a GETATTR in one request/reply round trip, and then if attributes indicated that the client's cache was stale, then send a READ in another request/reply round trip.",
      "ja": "最初の要求/往復の返信にGETATTRを送り、および属性は、クライアントのキャッシュが古くなったことが示された場合、その後、その後、別の要求/往復の返信でREADを送信することになる、NFSv3のとは対照的。"
    },
    {
      "indent": 3,
      "text": "In the case that a RECOMMENDED attribute is specified in the NVERIFY operation and the server does not support that attribute for the file system object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.",
      "ja": "推奨属性がNVERIFY操作で指定され、サーバがファイル・システム・オブジェクトのためにその属性をサポートしていない場合は、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "When the attribute rdattr_error or any set-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.",
      "ja": "属性rdattr_errorまたは任意のセット専用の属性（例えば、time_modify_set）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。"
    },
    {
      "indent": 0,
      "text": "18.16. Operation 18: OPEN - Open a Regular File",
      "section_title": true,
      "ja": "18.16. 操作18：OPEN  - は、通常のファイルを開きます。"
    },
    {
      "indent": 0,
      "text": "18.16.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.16.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "/*\n * Various definitions for OPEN\n */\nenum createmode4 {\n        UNCHECKED4      = 0,\n        GUARDED4        = 1,\n        /* Deprecated in NFSv4.1. */\n        EXCLUSIVE4      = 2,\n        /*\n         * New to NFSv4.1. If session is persistent,\n         * GUARDED4 MUST be used.  Otherwise, use\n         * EXCLUSIVE4_1 instead of EXCLUSIVE4.\n         */\n        EXCLUSIVE4_1    = 3\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct creatverfattr {\n         verifier4      cva_verf;\n         fattr4         cva_attrs;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union createhow4 switch (createmode4 mode) {\n case UNCHECKED4:\n case GUARDED4:\n         fattr4         createattrs;\n case EXCLUSIVE4:\n         verifier4      createverf;\n case EXCLUSIVE4_1:\n         creatverfattr  ch_createboth;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "enum opentype4 { OPEN4_NOCREATE = 0, OPEN4_CREATE = 1 };",
      "ja": "列挙opentype4 {OPEN4_NOCREATE = 0、OPEN4_CREATE = 1}。"
    },
    {
      "indent": 3,
      "text": "union openflag4 switch (opentype4 opentype) {\n case OPEN4_CREATE:\n         createhow4     how;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Next definitions used for OPEN delegation */\nenum limit_by4 {\n        NFS_LIMIT_SIZE          = 1,\n        NFS_LIMIT_BLOCKS        = 2\n        /* others as needed */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct nfs_modified_limit4 {\n        uint32_t        num_blocks;\n        uint32_t        bytes_per_block;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union nfs_space_limit4 switch (limit_by4 limitby) {\n /* limit specified as file size */\n case NFS_LIMIT_SIZE:\n         uint64_t               filesize;\n /* limit specified by number of blocks */\n case NFS_LIMIT_BLOCKS:\n         nfs_modified_limit4    mod_blocks;\n} ;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Share Access and Deny constants for open argument\n */\nconst OPEN4_SHARE_ACCESS_READ   = 0x00000001;\nconst OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;\nconst OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_DENY_NONE     = 0x00000000;\nconst OPEN4_SHARE_DENY_READ     = 0x00000001;\nconst OPEN4_SHARE_DENY_WRITE    = 0x00000002;\nconst OPEN4_SHARE_DENY_BOTH     = 0x00000003;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* new flags for share_access field of OPEN4args */\nconst OPEN4_SHARE_ACCESS_WANT_DELEG_MASK        = 0xFF00;\nconst OPEN4_SHARE_ACCESS_WANT_NO_PREFERENCE     = 0x0000;\nconst OPEN4_SHARE_ACCESS_WANT_READ_DELEG        = 0x0100;\nconst OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG       = 0x0200;\nconst OPEN4_SHARE_ACCESS_WANT_ANY_DELEG         = 0x0300;\nconst OPEN4_SHARE_ACCESS_WANT_NO_DELEG          = 0x0400;\nconst OPEN4_SHARE_ACCESS_WANT_CANCEL            = 0x0500;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL = 0x10000;",
      "ja": "constのOPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL = 0x10000番地。"
    },
    {
      "indent": 3,
      "text": "const OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED = 0x20000;",
      "ja": "constのOPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED = 0x200000の。"
    },
    {
      "indent": 3,
      "text": "enum open_delegation_type4 {\n        OPEN_DELEGATE_NONE      = 0,\n        OPEN_DELEGATE_READ      = 1,\n        OPEN_DELEGATE_WRITE     = 2,\n        OPEN_DELEGATE_NONE_EXT  = 3 /* new to v4.1 */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "enum open_claim_type4 {\n        /*\n         * Not a reclaim.\n         */\n        CLAIM_NULL              = 0,",
      "raw": true
    },
    {
      "indent": 11,
      "text": "CLAIM_PREVIOUS          = 1,\nCLAIM_DELEGATE_CUR      = 2,\nCLAIM_DELEGATE_PREV     = 3,",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/*\n * Not a reclaim.\n *\n * Like CLAIM_NULL, but object identified\n * by the current filehandle.\n */\nCLAIM_FH                = 4, /* new to v4.1 */",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/*\n * Like CLAIM_DELEGATE_CUR, but object identified\n * by current filehandle.\n */\nCLAIM_DELEG_CUR_FH      = 5, /* new to v4.1 */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        /*\n         * Like CLAIM_DELEGATE_PREV, but object identified\n         * by current filehandle.\n         */\n        CLAIM_DELEG_PREV_FH     = 6 /* new to v4.1 */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct open_claim_delegate_cur4 {\n        stateid4        delegate_stateid;\n        component4      file;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union open_claim4 switch (open_claim_type4 claim) {\n /*\n  * No special rights to file.\n  * Ordinary OPEN of the specified file.\n  */\n case CLAIM_NULL:\n        /* CURRENT_FH: directory */\n        component4      file;\n /*\n  * Right to the file established by an\n  * open previous to server reboot.  File\n  * identified by filehandle obtained at\n  * that time rather than by name.\n  */\n case CLAIM_PREVIOUS:\n        /* CURRENT_FH: file being reclaimed */\n        open_delegation_type4   delegate_type;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/*\n * Right to file based on a delegation\n * granted by the server.  File is\n * specified by name.\n */\ncase CLAIM_DELEGATE_CUR:\n       /* CURRENT_FH: directory */\n       open_claim_delegate_cur4        delegate_cur_info;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/*\n * Right to file based on a delegation\n * granted to a previous boot instance\n * of the client.  File is specified by name.\n */\ncase CLAIM_DELEGATE_PREV:\n        /* CURRENT_FH: directory */\n       component4      file_delegate_prev;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/*\n * Like CLAIM_NULL.  No special rights\n * to file.  Ordinary OPEN of the\n * specified file by current filehandle.\n */\ncase CLAIM_FH: /* new to v4.1 */\n       /* CURRENT_FH: regular file to open */\n       void;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/*\n * Like CLAIM_DELEGATE_PREV.  Right to file based on a\n * delegation granted to a previous boot\n * instance of the client.  File is identified by\n * by filehandle.\n */\ncase CLAIM_DELEG_PREV_FH: /* new to v4.1 */\n       /* CURRENT_FH: file being opened */\n       void;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/*\n * Like CLAIM_DELEGATE_CUR.  Right to file based on\n * a delegation granted by the server.\n * File is identified by filehandle.\n */\ncase CLAIM_DELEG_CUR_FH: /* new to v4.1 */\n        /* CURRENT_FH: file being opened */\n        stateid4       oc_delegate_stateid;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "};",
      "ja": "｝；"
    },
    {
      "indent": 3,
      "text": "/*\n * OPEN: Open a file, potentially receiving an OPEN delegation\n */\nstruct OPEN4args {\n        seqid4          seqid;\n        uint32_t        share_access;\n        uint32_t        share_deny;\n        open_owner4     owner;\n        openflag4       openhow;\n        open_claim4     claim;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.16.2. RESULTS",
      "section_title": true,
      "ja": "18.16.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct open_read_delegation4 {\n stateid4 stateid;    /* Stateid for delegation*/\n bool     recall;     /* Pre-recalled flag for\n                         delegations obtained\n                         by reclaim (CLAIM_PREVIOUS) */",
      "raw": true
    },
    {
      "indent": 3,
      "text": " nfsace4 permissions; /* Defines users who don't\n                         need an ACCESS call to\n                         open for read */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct open_write_delegation4 {\n stateid4 stateid;      /* Stateid for delegation */\n bool     recall;       /* Pre-recalled flag for\n                           delegations obtained\n                           by reclaim\n                           (CLAIM_PREVIOUS) */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "nfs_space_limit4\n          space_limit; /* Defines condition that\n                          the client must check to\n                          determine whether the\n                          file needs to be flushed\n                          to the server on close.  */",
      "raw": true
    },
    {
      "indent": 3,
      "text": " nfsace4   permissions; /* Defines users who don't\n                           need an ACCESS call as\n                           part of a delegated\n                           open. */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "enum why_no_delegation4 { /* new to v4.1 */\n        WND4_NOT_WANTED         = 0,\n        WND4_CONTENTION         = 1,\n        WND4_RESOURCE           = 2,\n        WND4_NOT_SUPP_FTYPE     = 3,\n        WND4_WRITE_DELEG_NOT_SUPP_FTYPE = 4,\n        WND4_NOT_SUPP_UPGRADE   = 5,\n        WND4_NOT_SUPP_DOWNGRADE = 6,\n        WND4_CANCELLED          = 7,\n        WND4_IS_DIR             = 8\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union open_none_delegation4 /* new to v4.1 */\nswitch (why_no_delegation4 ond_why) {\n        case WND4_CONTENTION:\n                bool ond_server_will_push_deleg;\n        case WND4_RESOURCE:\n                bool ond_server_will_signal_avail;\n        default:\n                void;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union open_delegation4\nswitch (open_delegation_type4 delegation_type) {\n        case OPEN_DELEGATE_NONE:\n                void;\n        case OPEN_DELEGATE_READ:\n                open_read_delegation4 read;\n        case OPEN_DELEGATE_WRITE:\n                open_write_delegation4 write;\n        case OPEN_DELEGATE_NONE_EXT: /* new to v4.1 */\n                open_none_delegation4 od_whynone;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Result flags\n */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Client must confirm open */\nconst OPEN4_RESULT_CONFIRM      = 0x00000002;\n/* Type of file locking behavior at the server */\nconst OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004;\n/* Server will preserve file if removed while open */\nconst OPEN4_RESULT_PRESERVE_UNLINKED = 0x00000008;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Server may use CB_NOTIFY_LOCK on locks\n * derived from this open\n */\nconst OPEN4_RESULT_MAY_NOTIFY_LOCK = 0x00000020;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct OPEN4resok {\n stateid4       stateid;      /* Stateid for open */\n change_info4   cinfo;        /* Directory Change Info */\n uint32_t       rflags;       /* Result flags */\n bitmap4        attrset;      /* attribute set for create*/\n open_delegation4 delegation; /* Info on any open\n                                 delegation */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union OPEN4res switch (nfsstat4 status) {\n case NFS4_OK:\n        /* New CURRENT_FH: opened file */\n        OPEN4resok      resok4;\n default:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.16.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.16.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The OPEN operation opens a regular file in a directory with the provided name or filehandle. OPEN can also create a file if a name is provided, and the client specifies it wants to create a file. Specification of whether or not a file is to be created, and the method of creation is via the openhow parameter. The openhow parameter consists of a switched union (data type opengflag4), which switches on the value of opentype (OPEN4_NOCREATE or OPEN4_CREATE). If OPEN4_CREATE is specified, this leads to another switched union (data type createhow4) that supports four cases of creation methods: UNCHECKED4, GUARDED4, EXCLUSIVE4, or EXCLUSIVE4_1. If opentype is OPEN4_CREATE, then the claim field of the claim field MUST be one of CLAIM_NULL, CLAIM_DELEGATE_CUR, or CLAIM_DELEGATE_PREV, because these claim methods include a component of a file name.",
      "ja": "OPEN操作は、指定された名前やファイルハンドルを持つディレクトリ内の通常のファイルを開きます。名前が提供されている場合、OPENは、ファイルを作成することができ、そしてクライアントがファイルを作成しようと指定します。ファイルが作成される、と創造の方法はopenhowパラメータであるかどうかの指定。 openhowパラメータは、OpenTypeフォント（OPEN4_NOCREATE又はOPEN4_CREATE）の値に切り替える切り替え連合（データ型opengflag4）、から成ります。 UNCHECKED4、GUARDED4、EXCLUSIVE4、またはEXCLUSIVE4_1：OPEN4_CREATEが指定されている場合、これは別のにつながる、作成方法の4例をサポート組合（データ・タイプcreatehow4）を切り替えます。 OpenTypeフォントがOPEN4_CREATEであれば、これらの請求方法は、ファイル名の構成要素を含むので、次にクレームフィールドの請求フィールドは、CLAIM_NULL、CLAIM_DELEGATE_CUR、又はCLAIM_DELEGATE_PREVのいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Upon success (which might entail creation of a new file), the current filehandle is replaced by that of the created or existing object.",
      "ja": "成功（新規ファイルの作成を伴う可能性がある）の際に、現在のファイルハンドルを作成したり、既存のオブジェクトのものに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is a named attribute directory, OPEN will then create or open a named attribute file. Note that exclusive create of a named attribute is not supported. If the createmode is EXCLUSIVE4 or EXCLUSIVE4_1 and the current filehandle is a named attribute directory, the server will return EINVAL.",
      "ja": "現在のファイルハンドルが指定された属性ディレクトリである場合、OPENは、名前の属性ファイルを作成または開きます。排他的にサポートされていないという属性を作成することに注意してください。 createmodeがEXCLUSIVE4またはEXCLUSIVE4_1であり、現在のファイルハンドルが指定された属性ディレクトリである場合、サーバはEINVALを返します。"
    },
    {
      "indent": 3,
      "text": "UNCHECKED4 means that the file should be created if a file of that name does not exist and encountering an existing regular file of that name is not an error. For this type of create, createattrs specifies the initial set of attributes for the file. The set of attributes may include any writable attribute valid for regular files. When an UNCHECKED4 create encounters an existing file, the attributes specified by createattrs are not used, except that when createattrs specifies the size attribute with a size of zero, the existing file is truncated.",
      "ja": "UNCHECKED4は、その名前のファイルが存在しない場合、ファイルが作成されなければならないことを意味し、その名前の既存の通常のファイルに遭遇すると、エラーではありません。作成のこのタイプのため、createattrsは、ファイルの属性の初期セットを指定します。属性のセットは、通常のファイルに有効な任意の書き込み可能な属性を含むことができます。 UNCHECKED4は出会いに既存のファイルを作成すると、createattrsによって指定された属性はcreateattrsがゼロのサイズとサイズ属性を指定した場合、既存のファイルが切り捨てられることを除いて、使用されていません。"
    },
    {
      "indent": 3,
      "text": "If GUARDED4 is specified, the server checks for the presence of a duplicate object by name before performing the create. If a duplicate exists, NFS4ERR_EXIST is returned. If the object does not exist, the request is performed as described for UNCHECKED4.",
      "ja": "GUARDED4を作成実行する前に、名前の重複したオブジェクトが存在するサーバーのチェックを指定された場合。重複が存在する場合は、NFS4ERR_EXISTが返されます。オブジェクトが存在しない場合UNCHECKED4について説明したように、要求が行われます。"
    },
    {
      "indent": 3,
      "text": "For the UNCHECKED4 and GUARDED4 cases, where the operation is successful, the server will return to the client an attribute mask signifying which attributes were successfully set for the object.",
      "ja": "操作が成功するUNCHECKED4とGUARDED4例については、サーバがクライアントに正常にオブジェクトに設定された属性の属性マスクの意味を返します。"
    },
    {
      "indent": 3,
      "text": "EXCLUSIVE4_1 and EXCLUSIVE4 specify that the server is to follow exclusive creation semantics, using the verifier to ensure exclusive creation of the target. The server should check for the presence of a duplicate object by name. If the object does not exist, the server creates the object and stores the verifier with the object. If the object does exist and the stored verifier matches the client provided verifier, the server uses the existing object as the newly created object. If the stored verifier does not match, then an error of NFS4ERR_EXIST is returned.",
      "ja": "EXCLUSIVE4_1とEXCLUSIVE4は、サーバがターゲットの排他的な作成を確保するために検証を使用して、排他的な作成のセマンティクスに従うことであることを指定します。サーバーは名前で重複したオブジェクトが存在するかどうかをチェックする必要があります。オブジェクトが存在しない場合は、サーバーはオブジェクトを作成し、オブジェクトに検証を保存します。オブジェクトが存在しないと保存された検証がクライアントに提供ベリファイアと一致した場合、サーバーは、新しく作成されたオブジェクトとして既存のオブジェクトを使用しています。保存された検証が一致しない場合は、NFS4ERR_EXISTのエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "If using EXCLUSIVE4, and if the server uses attributes to store the exclusive create verifier, the server will signify which attributes it used by setting the appropriate bits in the attribute mask that is returned in the results. Unlike UNCHECKED4, GUARDED4, and EXCLUSIVE4_1, EXCLUSIVE4 does not support the setting of attributes at file creation, and after a successful OPEN via EXCLUSIVE4, the client MUST send a SETATTR to set attributes to a known state.",
      "ja": "EXCLUSIVE4を使用している場合は、サーバが排他的に検証を作成し保存するための属性を使用している場合、サーバーは、それが結果に返された属性マスクの適切なビットを設定することにより、使用属性を意味します。 UNCHECKED4、GUARDED4、およびEXCLUSIVE4_1とは異なり、EXCLUSIVE4は、ファイル作成時の属性の設定をサポートしていない、とEXCLUSIVE4経由成功OPENした後、クライアントは、既知の状態に属性を設定するSETATTRを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "In NFSv4.1, EXCLUSIVE4 has been deprecated in favor of EXCLUSIVE4_1. Unlike EXCLUSIVE4, attributes may be provided in the EXCLUSIVE4_1 case, but because the server may use attributes of the target object to store the verifier, the set of allowable attributes may be fewer than the set of attributes SETATTR allows. The allowable attributes for EXCLUSIVE4_1 are indicated in the suppattr_exclcreat (Section 5.8.1.14) attribute. If the client attempts to set in cva_attrs an attribute that is not in suppattr_exclcreat, the server MUST return NFS4ERR_INVAL. The response field, attrset, indicates both which attributes the server set from cva_attrs and which attributes the server used to store the verifier. As described in",
      "ja": "NFSv4.1では、EXCLUSIVE4はEXCLUSIVE4_1の賛成で廃止されました。 EXCLUSIVE4とは異なり、属性はEXCLUSIVE4_1ケースに設けられていてもよいが、サーバーが検証を保存するために、ターゲットオブジェクトの属性を使用することができるので、許容属性のセットは、属性のセットよりも少ないかもしれSETATTR可能にします。 EXCLUSIVE4_1の許容属性がsuppattr_exclcreat（セクション5.8.1.14）属性で示されています。クライアントがcva_attrsでsuppattr_exclcreatにない属性を設定しようとすると、サーバーはNFS4ERR_INVALを返さなければなりません。応答フィールドは、attrset、cva_attrsから設定されたサーバをどの属性の両方を示し、検証を格納するために使用するサーバをどの属性。で説明したように"
    },
    {
      "indent": 3,
      "text": "Section 18.16.4, the client can compare cva_attrs.attrmask with attrset to determine which attributes were used to store the verifier.",
      "ja": "第18.16.4、クライアントがベリファイアを格納するために使用された属性を決定するためにattrsetでcva_attrs.attrmaskを比較することができます。"
    },
    {
      "indent": 3,
      "text": "With the addition of persistent sessions and pNFS, under some conditions EXCLUSIVE4 MUST NOT be used by the client or supported by the server. The following table summarizes the appropriate and mandated exclusive create methods for implementations of NFSv4.1:",
      "ja": "永続セッションとのpNFSの追加により、いくつかの条件の下でEXCLUSIVE4は、クライアントが使用してはいけませんまたはサーバーでサポートされています。次の表は、適切な要約し、排他的にはNFSv4.1の実装のためのメソッドを作成命じ："
    },
    {
      "indent": 19,
      "text": "Required methods for exclusive create",
      "ja": "排他的な作成のために必要なメソッド"
    },
    {
      "indent": 3,
      "text": "+----------------+-----------+---------------+----------------------+\n| Persistent     | Server    | Server        | Client Allowed       |\n| Reply Cache    | Supports  | REQUIRED      |                      |\n| Enabled        | pNFS      |               |                      |\n+----------------+-----------+---------------+----------------------+\n| no             | no        | EXCLUSIVE4_1  | EXCLUSIVE4_1         |\n|                |           | and           | (SHOULD) or          |\n|                |           | EXCLUSIVE4    | EXCLUSIVE4 (SHOULD   |\n|                |           |               | NOT)                 |\n| no             | yes       | EXCLUSIVE4_1  | EXCLUSIVE4_1         |\n| yes            | no        | GUARDED4      | GUARDED4             |\n| yes            | yes       | GUARDED4      | GUARDED4             |\n+----------------+-----------+---------------+----------------------+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Table 10",
      "ja": "表10"
    },
    {
      "indent": 3,
      "text": "If CREATE_SESSION4_FLAG_PERSIST is set in the results of CREATE_SESSION, the reply cache is persistent (see Section 18.36). If the EXCHGID4_FLAG_USE_PNFS_MDS flag is set in the results from EXCHANGE_ID, the server is a pNFS server (see Section 18.35). If the client attempts to use EXCLUSIVE4 on a persistent session, or a session derived from an EXCHGID4_FLAG_USE_PNFS_MDS client ID, the server MUST return NFS4ERR_INVAL.",
      "ja": "CREATE_SESSION4_FLAG_PERSISTがCREATE_SESSIONの結果に設定されている場合は、返信用キャッシュ（項18.36を参照）永続的です。 EXCHGID4_FLAG_USE_PNFS_MDSフラグがEXCHANGE_IDからの結果に設定されている場合、サーバは、pNFSのサーバ（セクション18.35を参照）です。クライアントが永続セッション、またはEXCHGID4_FLAG_USE_PNFS_MDSクライアントIDから派生したセッションにEXCLUSIVE4を使用しようとすると、サーバーはNFS4ERR_INVALを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "With persistent sessions, exclusive create semantics are fully achievable via GUARDED4, and so EXCLUSIVE4 or EXCLUSIVE4_1 MUST NOT be used. When pNFS is being used, the layout_hint attribute might not be supported after the file is created. Only the EXCLUSIVE4_1 and GUARDED methods of exclusive file creation allow the atomic setting of attributes.",
      "ja": "永続セッション、排他的な作成セマンティクスでGUARDED4を経由して完全に達成可能であるので、EXCLUSIVE4またはEXCLUSIVE4_1を使用してはいけません。 pNFSのが使用されている場合は、ファイルが作成された後、layout_hint属性がサポートされない場合があります。唯一の排他的なファイル作成のEXCLUSIVE4_1と守ら方法は属性の原子の設定を可能にします。"
    },
    {
      "indent": 3,
      "text": "For the target directory, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the link creation.",
      "ja": "ターゲットディレクトリの場合、サーバはcinfoの変化_info4情報を返します。前と後の変更属性がリンク作成に関して原子論が得られた場合には変化_info4データ型の原子分野、意志が示すサーバ。"
    },
    {
      "indent": 3,
      "text": "The OPEN operation provides for Windows share reservation capability with the use of the share_access and share_deny fields of the OPEN arguments. The client specifies at OPEN the required share_access and share_deny modes. For clients that do not directly support SHAREs (i.e., UNIX), the expected deny value is OPEN4_SHARE_DENY_NONE. In the case that there is an existing SHARE reservation that conflicts with the OPEN request, the server returns the error NFS4ERR_SHARE_DENIED. For additional discussion of SHARE semantics, see Section 9.7.",
      "ja": "OPEN操作がOPEN引数のshare_accessとshare_denyフィールドを使用して、Windowsのシェア予約機能を提供します。クライアントは、OPENで必要share_accessとshare_denyモードを指定します。直接株（すなわち、UNIX）をサポートしていないクライアントの場合、期待値はOPEN4_SHARE_DENY_NONEで否定しています。 OPEN要求と競合する既存のSHAREの予約がある場合には、サーバがエラーNFS4ERR_SHARE_DENIEDを返します。 SHARE意味論の追加の議論については、セクション9.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "For each OPEN, the client provides a value for the owner field of the OPEN argument. The owner field is of data type open_owner4, and contains a field called clientid and a field called owner. The client can set the clientid field to any value and the server MUST ignore it. Instead, the server MUST derive the client ID from the session ID of the SEQUENCE operation of the COMPOUND request.",
      "ja": "各OPENのために、クライアントがOPEN引数の所有者フィールドに値を提供します。所有者フィールドは、データ・タイプopen_owner4のものであり、そのclientidと所有者と呼ばれるフィールドと呼ばれるフィールドが含まれています。クライアントは、任意の値にのClientIDフィールドを設定することができ、サーバはそれを無視しなければなりません。代わりに、サーバは、複合要求のシーケンス動作のセッションIDからのクライアントIDを導出しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"seqid\" field of the request is not used in NFSv4.1, but it MAY be any value and the server MUST ignore it.",
      "ja": "リクエストの「SEQID」フィールドには、NFSv4.1で使用されていないが、それは任意の値であってもよいし、サーバはそれを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the case that the client is recovering state from a server failure, the claim field of the OPEN argument is used to signify that the request is meant to reclaim state previously held.",
      "ja": "クライアントがサーバー障害から状態を回復している場合には、OPEN引数の請求フィールドには、要求が以前に開催された状態を取り戻すことを意図していることを意味するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The \"claim\" field of the OPEN argument is used to specify the file to be opened and the state information that the client claims to possess. There are seven claim types as follows:",
      "ja": "OPEN引数の「主張」フィールドがオープンするファイルとクライアントが持っていると主張している状態情報を指定するために使用されます。次のように7つの請求タイプがあります。"
    },
    {
      "indent": 3,
      "text": "+----------------------+--------------------------------------------+\n| open type            | description                                |\n+----------------------+--------------------------------------------+\n| CLAIM_NULL, CLAIM_FH | For the client, this is a new OPEN request |\n|                      | and there is no previous state associated  |\n|                      | with the file for the client.  With        |\n|                      | CLAIM_NULL, the file is identified by the  |\n|                      | current filehandle and the specified       |\n|                      | component name.  With CLAIM_FH (new to     |\n|                      | NFSv4.1), the file is identified by just   |\n|                      | the current filehandle.                    |\n| CLAIM_PREVIOUS       | The client is claiming basic OPEN state    |\n|                      | for a file that was held previous to a     |\n|                      | server restart.  Generally used when a     |\n|                      | server is returning persistent             |\n|                      | filehandles; the client may not have the   |\n|                      | file name to reclaim the OPEN.             |\n| CLAIM_DELEGATE_CUR,  | The client is claiming a delegation for    |\n| CLAIM_DELEG_CUR_FH   | OPEN as granted by the server.  Generally, |\n|                      | this is done as part of recalling a        |\n|                      | delegation.  With CLAIM_DELEGATE_CUR, the  |\n|                      | file is identified by the current          |\n|                      | filehandle and the specified component     |\n|                      | name.  With CLAIM_DELEG_CUR_FH (new to     |\n|                      | NFSv4.1), the file is identified by just   |\n|                      | the current filehandle.                    |\n| CLAIM_DELEGATE_PREV, | The client is claiming a delegation        |\n| CLAIM_DELEG_PREV_FH  | granted to a previous client instance;     |\n|                      | used after the client restarts.  The       |\n|                      | server MAY support CLAIM_DELEGATE_PREV     |\n|                      | and/or CLAIM_DELEG_PREV_FH (new to         |\n|                      | NFSv4.1).  If it does support either claim |\n|                      | type, CREATE_SESSION MUST NOT remove the   |\n|                      | client's delegation state, and the server  |\n|                      | MUST support the DELEGPURGE operation.     |\n+----------------------+--------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For OPEN requests that reach the server during the grace period, the server returns an error of NFS4ERR_GRACE. The following claim types are exceptions:",
      "ja": "猶予期間中にサーバに到達OPEN要求の場合、サーバーはNFS4ERR_GRACEのエラーを返します。以下の請求の種類は例外です。"
    },
    {
      "indent": 3,
      "text": "o OPEN requests specifying the claim type CLAIM_PREVIOUS are devoted to reclaiming opens after a server restart and are typically only valid during the grace period.",
      "ja": "O要求の種類のCLAIM_PREVIOUSを指定するOPEN要求は、再利用に専念しているサーバの再起動後に開かれ、猶予期間中に一般的にのみ有効です。"
    },
    {
      "indent": 3,
      "text": "o OPEN requests specifying the claim types CLAIM_DELEGATE_CUR and CLAIM_DELEG_CUR_FH are valid both during and after the grace period. Since the granting of the delegation that they are subordinate to assures that there is no conflict with locks to be reclaimed by other clients, the server need not return NFS4ERR_GRACE when these are received during the grace period.",
      "ja": "O要求の種類CLAIM_DELEGATE_CURとCLAIM_DELEG_CUR_FHを指定するOPEN要求は、猶予期間中と後の両方に有効です。これらは、猶予期間中に受信されたとき、彼らは他のクライアントによって再利用されるロックと競合がないことを保証するために従属する代表団の付与ので、サーバーはNFS4ERR_GRACEを返す必要はありません。"
    },
    {
      "indent": 3,
      "text": "For any OPEN request, the server may return an OPEN delegation, which allows further opens and closes to be handled locally on the client as described in Section 10.4. Note that delegation is up to the server to decide. The client should never assume that delegation will or will not be granted in a particular instance. It should always be prepared for either case. A partial exception is the reclaim (CLAIM_PREVIOUS) case, in which a delegation type is claimed. In this case, delegation will always be granted, although the server may specify an immediate recall in the delegation structure.",
      "ja": "任意のOPEN要求の場合、サーバーはさらに可能に開き、セクション10.4で説明したように、クライアント上でローカルに処理されるように閉じOPEN委任を返すことがあります。代表団が決定するサーバー次第であることに注意してください。クライアントは、代表団は、または特定のインスタンスで付与されないだろうと想定してはいけません。それは、常にどちらかの場合のために準備する必要があります。部分的な例外は、委譲タイプが記載されて再利用（CLAIM_PREVIOUS）場合、です。サーバが委任構造で即時リコールを指定することもできますが、この場合には、代表団は常に、付与されます。"
    },
    {
      "indent": 3,
      "text": "The rflags returned by a successful OPEN allow the server to return information governing how the open file is to be handled.",
      "ja": "成功OPENによって返さRFLAGSは、サーバが開いているファイルを処理する方法を規定する情報を返すことができます。"
    },
    {
      "indent": 3,
      "text": "o OPEN4_RESULT_CONFIRM is deprecated and MUST NOT be returned by an NFSv4.1 server.",
      "ja": "O OPEN4_RESULT_CONFIRMが廃止されており、NFSv4.1サーバーから返されてはなりません。"
    },
    {
      "indent": 3,
      "text": "o OPEN4_RESULT_LOCKTYPE_POSIX indicates that the server's byte-range locking behavior supports the complete set of POSIX locking techniques [24]. From this, the client can choose to manage byte-range locking state in a way to handle a mismatch of byte-range locking management.",
      "ja": "O OPEN4_RESULT_LOCKTYPE_POSIXは、サーバのバイト範囲ロック動作は、POSIXロックのテクニック[24]の完全なセットをサポートしていることを示しています。このことから、クライアントは、バイト範囲ロック管理の不一致を処理する方法で、バイト範囲ロック状態を管理するために選択することができます。"
    },
    {
      "indent": 3,
      "text": "o OPEN4_RESULT_PRESERVE_UNLINKED indicates that the server will preserve the open file if the client (or any other client) removes the file as long as it is open. Furthermore, the server promises to preserve the file through the grace period after server restart, thereby giving the client the opportunity to reclaim its open.",
      "ja": "O OPEN4_RESULT_PRESERVE_UNLINKEDは、クライアント（または他のクライアント）がある限り、それが開いていると、ファイルを削除した場合、サーバーがファイルを開いて保存することを示します。さらに、サーバは、これにより、クライアントにそのオープンを再利用する機会を与え、サーバの再起動後に猶予期間を経てファイルを保存することを約束します。"
    },
    {
      "indent": 3,
      "text": "o OPEN4_RESULT_MAY_NOTIFY_LOCK indicates that the server may attempt CB_NOTIFY_LOCK callbacks for locks on this file. This flag is a hint only, and may be safely ignored by the client.",
      "ja": "O OPEN4_RESULT_MAY_NOTIFY_LOCKは、サーバーがこのファイルのロックをCB_NOTIFY_LOCKコールバックを試みる可能性があることを示します。このフラグはヒントだけで、安全にクライアントによって無視されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "If the component is of zero length, NFS4ERR_INVAL will be returned. The component is also subject to the normal UTF-8, character support, and name checks. See Section 14.5 for further discussion.",
      "ja": "コンポーネントは、長さゼロである場合、NFS4ERR_INVALが返されます。コンポーネントは、通常のUTF-8文字のサポート、および名前のチェックの対象となります。さらなる議論については項14.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "When an OPEN is done and the specified open-owner already has the resulting filehandle open, the result is to \"OR\" together the new share and deny status together with the existing status. In this case, only a single CLOSE need be done, even though multiple OPENs were completed. When such an OPEN is done, checking of share reservations for the new OPEN proceeds normally, with no exception for the existing OPEN held by the same open-owner. In this case, the stateid returned as an \"other\" field that matches that of the previous open while the \"seqid\" field is incremented to reflect the change status due to the new open.",
      "ja": "OPENが行われ、指定されたオープン所有者が既に開いたファイルハンドルを持っている場合は、その結果が「OR」一緒に新しい共有され、既存のステータスと一緒に状況を否定します。この場合、単一のCLOSEは、複数のOPENsが完了したにもかかわらず、行われる必要があります。そのようなOPENが行われると、同じオープン所有者が保有する既存のOPENのための例外なく、通常は新しいOPEN収益の共有予約の確認。この場合、のstateidは「SEQID」フィールドが原因新しいオープンに変更ステータスを反映するためにインクリメントしながら、前のオープンのものと一致した「その他」のフィールドとして返されます。"
    },
    {
      "indent": 3,
      "text": "If the underlying file system at the server is only accessible in a read-only mode and the OPEN request has specified ACCESS_WRITE or ACCESS_BOTH, the server will return NFS4ERR_ROFS to indicate a read-only file system.",
      "ja": "サーバーの基本となるファイルシステムが読み取り専用モードでのみアクセス可能で、OPEN要求がACCESS_WRITEまたはACCESS_BOTHを指定した場合、サーバーは、読み取り専用ファイルシステムを示すためにNFS4ERR_ROFSを返します。"
    },
    {
      "indent": 3,
      "text": "As with the CREATE operation, the server MUST derive the owner, owner ACE, group, or group ACE if any of the four attributes are required and supported by the server's file system. For an OPEN with the EXCLUSIVE4 createmode, the server has no choice, since such OPEN calls do not include the createattrs field. Conversely, if createattrs (UNCHECKED4 or GUARDED4) or cva_attrs (EXCLUSIVE4_1) is specified, and includes an owner, owner_group, or ACE that the principal in the RPC call's credentials does not have authorization to create files for, then the server may return NFS4ERR_PERM.",
      "ja": "4つの属性のいずれかが必要とサーバのファイルシステムによってサポートされている場合は、CREATE操作と同じように、サーバは、所有者、所有者のACE、グループ、またはグループのACEを導出しなければなりません。 EXCLUSIVE4のcreatemodeとOPENの場合、サーバーは、OPEN呼び出しがcreateattrsフィールドが含まれないので、選択の余地はありません。逆に、createattrs（UNCHECKED4またはGUARDED4）またはcva_attrs（EXCLUSIVE4_1）は、サーバはNFS4ERR_PERMを返すことがあり、RPCコールの資格でプリンシパルがためのファイルを作成する権限を持っていないことを指定し、所有者を含み、owner_group、またはACEされます。"
    },
    {
      "indent": 3,
      "text": "In the case of an OPEN that specifies a size of zero (e.g., truncation) and the file has named attributes, the named attributes are left as is and are not removed.",
      "ja": "ゼロ（例えば、切り捨て）のサイズを指定し、ファイル属性と名付けたOPENの場合には、名前付き属性はそのまま残され、除去されません。"
    },
    {
      "indent": 3,
      "text": "NFSv4.1 gives more precise control to clients over acquisition of delegations via the following new flags for the share_access field of OPEN4args:",
      "ja": "NFSv4.1はOPEN4argsのshare_accessフィールドに、次の新しいフラグを経て代表団の買収を介してクライアントに、より正確に制御できます。"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_READ_DELEG",
      "ja": "OPEN4_SHARE_ACCESS_WANT_READ_DELEG"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG",
      "ja": "OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_ANY_DELEG",
      "ja": "OPEN4_SHARE_ACCESS_WANT_ANY_DELEG"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_NO_DELEG",
      "ja": "OPEN4_SHARE_ACCESS_WANT_NO_DELEG"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_CANCEL",
      "ja": "OPEN4_SHARE_ACCESS_WANT_CANCEL"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL",
      "ja": "OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED",
      "ja": "OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED"
    },
    {
      "indent": 3,
      "text": "If (share_access & OPEN4_SHARE_ACCESS_WANT_DELEG_MASK) is not zero, then the client will have specified one and only one of:",
      "ja": "（share_access＆OPEN4_SHARE_ACCESS_WANT_DELEG_MASK）がゼロでない場合、クライアントは1とを1つだけ指定しています："
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_READ_DELEG",
      "ja": "OPEN4_SHARE_ACCESS_WANT_READ_DELEG"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG",
      "ja": "OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_ANY_DELEG",
      "ja": "OPEN4_SHARE_ACCESS_WANT_ANY_DELEG"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_NO_DELEG",
      "ja": "OPEN4_SHARE_ACCESS_WANT_NO_DELEG"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_CANCEL",
      "ja": "OPEN4_SHARE_ACCESS_WANT_CANCEL"
    },
    {
      "indent": 3,
      "text": "Otherwise, the client is neither indicating a desire nor a non-desire for a delegation, and the server MAY or MAY not return a delegation in the OPEN response.",
      "ja": "そうでない場合、クライアントはどちらの欲求も代表団のための非意欲を示していない、そしてサーバーがまたはOPEN応じて委任を返さない場合があります。"
    },
    {
      "indent": 3,
      "text": "If the server supports the new _WANT_ flags and the client sends one or more of the new flags, then in the event the server does not return a delegation, it MUST return a delegation type of OPEN_DELEGATE_NONE_EXT. The field ond_why in the reply indicates why no delegation was returned and will be one of:",
      "ja": "サーバが新しい_WANT_フラグをサポートし、クライアントが新しいの1つ以上のフラグを送信し、そのイベントに、サーバーが委任を返さない場合、それはOPEN_DELEGATE_NONE_EXTの委譲タイプを返さなければなりません。何の代表団が返されなかったとのいずれかになりますなぜ返信のフィールドond_whyを示します。"
    },
    {
      "indent": 3,
      "text": "WND4_NOT_WANTED The client specified OPEN4_SHARE_ACCESS_WANT_NO_DELEG.",
      "ja": "OPEN4_SHARE_ACCESS_WANT_NO_DELEG指定されたクライアントをWND4_NOT_WANTED。"
    },
    {
      "indent": 3,
      "text": "WND4_CONTENTION There is a conflicting delegation or open on the file.",
      "ja": "WND4_CONTENTIONは矛盾委任またはファイルのオープンがあります。"
    },
    {
      "indent": 3,
      "text": "WND4_RESOURCE Resource limitations prevent the server from granting a delegation.",
      "ja": "WND4_RESOURCEリソース制限が委任を許可するからサーバーを防ぎます。"
    },
    {
      "indent": 3,
      "text": "WND4_NOT_SUPP_FTYPE The server does not support delegations on this file type.",
      "ja": "WND4_NOT_SUPP_FTYPEサーバーは、このファイルタイプの委任をサポートしていません。"
    },
    {
      "indent": 3,
      "text": "WND4_WRITE_DELEG_NOT_SUPP_FTYPE The server does not support OPEN_DELEGATE_WRITE delegations on this file type.",
      "ja": "WND4_WRITE_DELEG_NOT_SUPP_FTYPEサーバーは、このファイルタイプにOPEN_DELEGATE_WRITE委任をサポートしていません。"
    },
    {
      "indent": 3,
      "text": "WND4_NOT_SUPP_UPGRADE The server does not support atomic upgrade of an OPEN_DELEGATE_READ delegation to an OPEN_DELEGATE_WRITE delegation.",
      "ja": "WND4_NOT_SUPP_UPGRADEサーバーはOPEN_DELEGATE_WRITE代表団にOPEN_DELEGATE_READ代表団の原子アップグレードをサポートしていません。"
    },
    {
      "indent": 3,
      "text": "WND4_NOT_SUPP_DOWNGRADE The server does not support atomic downgrade of an OPEN_DELEGATE_WRITE delegation to an OPEN_DELEGATE_READ delegation.",
      "ja": "WND4_NOT_SUPP_DOWNGRADEサーバーはOPEN_DELEGATE_READ代表団にOPEN_DELEGATE_WRITE代表団の原子ダウングレードをサポートしていません。"
    },
    {
      "indent": 3,
      "text": "WND4_CANCELED The client specified OPEN4_SHARE_ACCESS_WANT_CANCEL and now any \"want\" for this file object is cancelled.",
      "ja": "クライアントはOPEN4_SHARE_ACCESS_WANT_CANCELを指定して、今、このファイルオブジェクトがキャンセルされるために任意の「欲しい」WND4_CANCELED。"
    },
    {
      "indent": 3,
      "text": "WND4_IS_DIR The specified file object is a directory, and the operation is OPEN or WANT_DELEGATION, which do not support delegations on directories.",
      "ja": "WND4_IS_DIR指定されたファイルオブジェクトがディレクトリで、操作は、ディレクトリに代表団をサポートしていません。これは、OPENまたはWANT_DELEGATIONです。"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_READ_DELEG, OPEN_SHARE_ACCESS_WANT_WRITE_DELEG, or OPEN_SHARE_ACCESS_WANT_ANY_DELEG mean, respectively, the client wants an OPEN_DELEGATE_READ, OPEN_DELEGATE_WRITE, or any delegation regardless which of OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH is set. If the client has an OPEN_DELEGATE_READ delegation on a file and requests an OPEN_DELEGATE_WRITE delegation, then the client is requesting atomic upgrade of its OPEN_DELEGATE_READ delegation to an OPEN_DELEGATE_WRITE delegation. If the client has an OPEN_DELEGATE_WRITE delegation on a file and requests an OPEN_DELEGATE_READ delegation, then the client is requesting atomic downgrade to an OPEN_DELEGATE_READ delegation. A server MAY support atomic upgrade or downgrade. If it does, then the returned delegation_type of OPEN_DELEGATE_READ or OPEN_DELEGATE_WRITE that is different from the delegation type the client currently has, indicates successful upgrade or downgrade. If the server does not support atomic delegation upgrade or downgrade, then ond_why will be set to WND4_NOT_SUPP_UPGRADE or WND4_NOT_SUPP_DOWNGRADE.",
      "ja": "OPEN4_SHARE_ACCESS_WANT_READ_DELEG、OPEN_SHARE_ACCESS_WANT_WRITE_DELEG、またはOPEN_SHARE_ACCESS_WANT_ANY_DELEG意味は、それぞれ、クライアントはOPEN_DELEGATE_READ、OPEN_DELEGATE_WRITE、またはOPEN4_SHARE_ACCESS_READの、OPEN4_SHARE_ACCESS_WRITE、またはOPEN4_SHARE_ACCESS_BOTHが設定されているにかかわらず、任意の委任を望んでいます。クライアントがファイルにOPEN_DELEGATE_READ委任を持っているとOPEN_DELEGATE_WRITE委任を要求した場合、クライアントはOPEN_DELEGATE_WRITE代表団へのOPEN_DELEGATE_READ代表団の原子アップグレードを要求しています。クライアントがファイルにOPEN_DELEGATE_WRITE委任を持っているとOPEN_DELEGATE_READ委任を要求した場合、クライアントはOPEN_DELEGATE_READ代表団にアトミックダウングレードを要求しています。サーバは、原子アップグレードまたはダウングレードをサポートするかもしれません。それがない場合には、代表団は異なっているOPEN_DELEGATE_READまたはOPEN_DELEGATE_WRITEの返却delegation_typeは、クライアントが現在持って入力し、正常なアップグレードまたはダウングレードを示します。サーバは、原子委任アップグレードまたはダウングレードをサポートしていない場合は、ond_whyはWND4_NOT_SUPP_UPGRADEまたはWND4_NOT_SUPP_DOWNGRADEに設定されます。"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_NO_DELEG means that the client wants no delegation.",
      "ja": "OPEN4_SHARE_ACCESS_WANT_NO_DELEGは、クライアントが何の委任を望んでいないことを意味します。"
    },
    {
      "indent": 3,
      "text": "OPEN4_SHARE_ACCESS_WANT_CANCEL means that the client wants no delegation and wants to cancel any previously registered \"want\" for a delegation.",
      "ja": "OPEN4_SHARE_ACCESS_WANT_CANCELは、クライアントが何の委任を望んでいないことを意味し、以前に登録された委任のための「欲しい」をキャンセルしたいです。"
    },
    {
      "indent": 3,
      "text": "The client may set one or both of OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL and OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED. However, they will have no effect unless one of following is set:",
      "ja": "クライアントは、1またはOPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAILとOPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDEDの両方を設定することもできます。以下のいずれかが設定されていない限り、しかし、彼らは効果がありません。"
    },
    {
      "indent": 3,
      "text": "o OPEN4_SHARE_ACCESS_WANT_READ_DELEG",
      "ja": "O OPEN4_SHARE_ACCESS_WANT_READ_DELEG"
    },
    {
      "indent": 3,
      "text": "o OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG",
      "ja": "O OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG"
    },
    {
      "indent": 3,
      "text": "o OPEN4_SHARE_ACCESS_WANT_ANY_DELEG",
      "ja": "O OPEN4_SHARE_ACCESS_WANT_ANY_DELEG"
    },
    {
      "indent": 3,
      "text": "If the client specifies OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL, then it wishes to register a \"want\" for a delegation, in the event the OPEN results do not include a delegation. If so and the server denies the delegation due to insufficient resources, the server MAY later inform the client, via the CB_RECALLABLE_OBJ_AVAIL operation, that the resource limitation condition has eased. The server will tell the client that it intends to send a future CB_RECALLABLE_OBJ_AVAIL operation by setting delegation_type in the results to OPEN_DELEGATE_NONE_EXT, ond_why to WND4_RESOURCE, and ond_server_will_signal_avail set to TRUE. If ond_server_will_signal_avail is set to TRUE, the server MUST later send a CB_RECALLABLE_OBJ_AVAIL operation.",
      "ja": "クライアントがOPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAILを指定した場合、それはOPEN結果が委任が含まれていない場合には、委任に対して「欲しい」を登録することを希望します。そう、サーバーがリソース不足のため代表団を拒否した場合、サーバは、後にリソースの制限条件を緩和したこと、CB_RECALLABLE_OBJ_AVAIL操作によって、クライアントに通知することができます。サーバーは、それがWND4_RESOURCEにond_why、OPEN_DELEGATE_NONE_EXTに結果にdelegation_typeを設定することで、将来のCB_RECALLABLE_OBJ_AVAIL操作を送信しようとクライアントを教えてくれますし、TRUEに設定しond_server_will_signal_avail。 ond_server_will_signal_availがTRUEに設定されている場合、サーバは後でCB_RECALLABLE_OBJ_AVAIL操作を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the client specifies OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_UNCONTENDED, then it wishes to register a \"want\" for a delegation, in the event the OPEN results do not include a delegation. If so and the server denies the delegation due to contention, the server MAY later inform the client, via the CB_PUSH_DELEG operation, that the contention condition has eased. The server will tell the client that it intends to send a future CB_PUSH_DELEG operation by setting delegation_type in the results to OPEN_DELEGATE_NONE_EXT, ond_why to WND4_CONTENTION, and ond_server_will_push_deleg to TRUE. If ond_server_will_push_deleg is TRUE, the server MUST later send a CB_PUSH_DELEG operation.",
      "ja": "クライアントがOPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_UNCONTENDEDを指定した場合、それはOPEN結果が委任が含まれていない場合には、委任に対して「欲しい」を登録することを希望します。そう、サーバが原因の競合への委任を拒否した場合、サーバは、後に競合条件が緩和されたことを、CB_PUSH_DELEG操作によって、クライアントに通知することができます。サーバーは、それがWND4_CONTENTIONにond_why、そしてTRUEにond_server_will_push_deleg、OPEN_DELEGATE_NONE_EXTに結果にdelegation_typeを設定することで、将来のCB_PUSH_DELEG操作を送信しようというクライアントを教えてくれます。 ond_server_will_push_delegがTRUEの場合、サーバーは後でCB_PUSH_DELEG操作を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the client has previously registered a want for a delegation on a file, and then sends a request to register a want for a delegation on the same file, the server MUST return a new error: NFS4ERR_DELEG_ALREADY_WANTED. If the client wishes to register a different type of delegation want for the same file, it MUST cancel the existing delegation WANT.",
      "ja": "NFS4ERR_DELEG_ALREADY_WANTED：クライアントが以前のファイルに委任希望を登録し、同じファイルに対して委任希望の登録要求を送信した場合、サーバは新しいエラーを返さなければなりません。クライアントが同じファイルに必要委譲の異なるタイプを登録したい場合は、既存の委任WANTをキャンセルする必要があります。"
    },
    {
      "indent": 0,
      "text": "18.16.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.16.4. 実装"
    },
    {
      "indent": 3,
      "text": "In absence of a persistent session, the client invokes exclusive create by setting the how parameter to EXCLUSIVE4 or EXCLUSIVE4_1. In these cases, the client provides a verifier that can reasonably be expected to be unique. A combination of a client identifier, perhaps the client network address, and a unique number generated by the client, perhaps the RPC transaction identifier, may be appropriate.",
      "ja": "永続的なセッションがない場合には、クライアントはEXCLUSIVE4またはEXCLUSIVE4_1にどのようにパラメータを設定することにより、作成排他的な呼び出します。これらのケースでは、クライアントは、合理的に一意であることが期待できる検証を提供します。クライアント識別子の組み合わせ、恐らくクライアントネットワークアドレス、およびクライアントによって生成された固有の番号、恐らくRPCトランザクション識別子は、適切であり得ます。"
    },
    {
      "indent": 3,
      "text": "If the object does not exist, the server creates the object and stores the verifier in stable storage. For file systems that do not provide a mechanism for the storage of arbitrary file attributes, the server may use one or more elements of the object's metadata to store the verifier. The verifier MUST be stored in stable storage to prevent erroneous failure on retransmission of the request. It is assumed that an exclusive create is being performed because exclusive semantics are critical to the application. Because of the expected usage, exclusive CREATE does not rely solely on the server's reply cache for storage of the verifier. A nonpersistent reply cache does not survive a crash and the session and reply cache may be deleted after a network partition that exceeds the lease time, thus opening failure windows.",
      "ja": "オブジェクトが存在しない場合は、サーバーはオブジェクトを作成し、安定したストレージに検証を保存します。任意のファイルの属性を格納するためのメカニズムを提供しないファイルシステムでは、サーバが検証を保存するために、オブジェクトのメタデータの1つの以上の要素を使用することができます。検証者は、要求の再送に誤った故障を防ぐために、安定したストレージに格納されなければなりません。排他的な意味はアプリケーションに不可欠であるため、排他が行われて作成することを想定しています。そのため、予想される使用法の、排他的には、CREATE検証を格納するためのサーバの応答をキャッシュのみに依存しません。キャッシュがクラッシュして、セッションを生き残るためには、キャッシュを返信しない非永続返信は、このように、障害の窓を開け、リース期間を超えたネットワークパーティションの後に削除される場合があります。"
    },
    {
      "indent": 3,
      "text": "An NFSv4.1 server SHOULD NOT store the verifier in any of the file's RECOMMENDED or REQUIRED attributes. If it does, the server SHOULD use time_modify_set or time_access_set to store the verifier. The server SHOULD NOT store the verifier in the following attributes:",
      "ja": "NFSv4.1サーバーは、ファイルの推奨または必須の属性のいずれかに検証を保存しないでください。それがない場合は、サーバーはベリファイアを格納するtime_modify_setまたはtime_access_setを使用すべきです。サーバーは、次の属性で検証を保存しないでください。"
    },
    {
      "indent": 6,
      "text": "acl (it is desirable for access control to be established at creation),",
      "ja": "ACL（アクセス制御は、作成時に確立されることが望ましいです）、"
    },
    {
      "indent": 6,
      "text": "dacl (ditto),",
      "ja": "、（同上）タックル"
    },
    {
      "indent": 6,
      "text": "mode (ditto),",
      "ja": "もで （ぢっと）、"
    },
    {
      "indent": 6,
      "text": "owner (ditto),",
      "ja": "所有者（同上）、"
    },
    {
      "indent": 6,
      "text": "owner_group (ditto),",
      "ja": "owner_group（同上）、"
    },
    {
      "indent": 6,
      "text": "retentevt_set (it may be desired to establish retention at creation)",
      "ja": "retentevt_set（作成時に保持を確立することが望ましいです）"
    },
    {
      "indent": 6,
      "text": "retention_hold (ditto),",
      "ja": "retention_hold（同上）、"
    },
    {
      "indent": 6,
      "text": "retention_set (ditto),",
      "ja": "retention_set（同上）、"
    },
    {
      "indent": 6,
      "text": "sacl (it is desirable for auditing control to be established at creation),",
      "ja": "SACL（監査制御は、作成時に確立されることが望ましいです）"
    },
    {
      "indent": 6,
      "text": "size (on some servers, size may have a limited range of values),",
      "ja": "サイズ（いくつかのサーバーで、サイズは値の限られた範囲を有していてもよいです）、"
    },
    {
      "indent": 6,
      "text": "mode_set_masked (as with mode),",
      "ja": "（モードと同様に）mode_set_masked、"
    },
    {
      "indent": 9,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "time_creation (a meaningful file creation should be set when the file is created).",
      "ja": "time_creation（意味のあるファイルの作成は、ファイルが作成されるときに設定する必要があります）。"
    },
    {
      "indent": 3,
      "text": "Another alternative for the server is to use a named attribute to store the verifier.",
      "ja": "サーバーのための別の方法としては、ベリファイアを格納するという名前の属性を使用することです。"
    },
    {
      "indent": 3,
      "text": "Because the EXCLUSIVE4 create method does not specify initial attributes when processing an EXCLUSIVE4 create, the server",
      "ja": "処理するときEXCLUSIVE4作成方法は、初期の属性を指定していないのでEXCLUSIVE4は、サーバーを作成します"
    },
    {
      "indent": 3,
      "text": "o SHOULD set the owner of the file to that corresponding to the credential of request's RPC header.",
      "ja": "O要求のRPCヘッダの資格に対応するものにファイルの所有者を設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o SHOULD NOT leave the file's access control to anyone but the owner of the file.",
      "ja": "oは、誰が、ファイルの所有者に、ファイルのアクセス制御ままにしないでください。"
    },
    {
      "indent": 3,
      "text": "If the server cannot support exclusive create semantics, possibly because of the requirement to commit the verifier to stable storage, it should fail the OPEN request with the error NFS4ERR_NOTSUPP.",
      "ja": "サーバはおそらく安定したストレージに検証をコミットするための要件の、セマンティクスを排他的な作成をサポートできない場合は、エラーNFS4ERR_NOTSUPPとOPEN要求を失敗するはずです。"
    },
    {
      "indent": 3,
      "text": "During an exclusive CREATE request, if the object already exists, the server reconstructs the object's verifier and compares it with the verifier in the request. If they match, the server treats the request as a success. The request is presumed to be a duplicate of an earlier, successful request for which the reply was lost and that the server duplicate request cache mechanism did not detect. If the verifiers do not match, the request is rejected with the status NFS4ERR_EXIST.",
      "ja": "オブジェクトがすでに存在する場合、排他的、CREATE要求の間に、サーバーは、オブジェクトの検証を再構築し、要求で検証とそれを比較します。それらが一致した場合、サーバは成功として要求を処理します。要求は応答が失われたとサーバーの重複要求キャッシュメカニズムが検出されなかったことをそのため、以前、成功した要求の重複であると推定されます。検証が一致しない場合、要求はステータスNFS4ERR_EXISTで拒否されます。"
    },
    {
      "indent": 3,
      "text": "After the client has performed a successful exclusive create, the attrset response indicates which attributes were used to store the verifier. If EXCLUSIVE4 was used, the attributes set in attrset were used for the verifier. If EXCLUSIVE4_1 was used, the client determines the attributes used for the verifier by comparing attrset with cva_attrs.attrmask; any bits set in the former but not the latter identify the attributes used to store the verifier. The client MUST immediately send a SETATTR to set attributes used to store the verifier. Until it does so, the attributes used to store the verifier cannot be relied upon. The subsequent SETATTR MUST NOT occur in the same COMPOUND request as the OPEN.",
      "ja": "クライアントが作成した排他的な成功を行った後、attrset応答がベリファイアを格納するために使用された属性を示します。 EXCLUSIVE4を使用した場合、attrsetに設定された属性は、検証のために使用されました。 EXCLUSIVE4_1を使用した場合、クライアントはcva_attrs.attrmaskでattrsetを比較して検証するために使用される属性を決定します。前者ではなく後者に設定されたビットは、検証を格納するために使用される属性を識別する。クライアントはすぐにベリファイアを格納するために使用する属性を設定するSETATTRを送らなければなりません。それがそうするまでは、検証を格納するために使用される属性が依拠することはできません。その後のSETATTRはOPENと同じCOMPOUND要求に発生してはなりません。"
    },
    {
      "indent": 3,
      "text": "Unless a persistent session is used, use of the GUARDED4 attribute does not provide exactly once semantics. In particular, if a reply is lost and the server does not detect the retransmission of the request, the operation can fail with NFS4ERR_EXIST, even though the create was performed successfully. The client would use this behavior in the case that the application has not requested an exclusive create but has asked to have the file truncated when the file is opened. In the case of the client timing out and retransmitting the create request, the client can use GUARDED4 to prevent against a sequence like create, write, create (retransmitted) from occurring.",
      "ja": "永続的なセッションが使用されていない限り、GUARDED4属性の使用は、正確に一度のセマンティクスを提供していません。回答が失われ、サーバが要求の再送信を検出しない場合は特に、操作が正常に実行されました作成していても、NFS4ERR_EXISTで失敗する可能性があります。クライアントは、アプリケーションが排他的に作成し、要求されていませんが、ファイルを開いたときに切り捨てられたファイルを持っているように頼まれた場合には、この動作を使用します。クライアントのタイムアウト、要求を作成する再送信の場合、クライアントは、作成のような配列に対する予防書き込み、発生から（再送）を作成するためにGUARDED4を使用することができます。"
    },
    {
      "indent": 3,
      "text": "For SHARE reservations, the value of the expression (share_access & ~OPEN4_SHARE_ACCESS_WANT_DELEG_MASK) MUST be one of OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH. If not, the server MUST return NFS4ERR_INVAL. The value of share_deny MUST be one of OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH. If not, the server MUST return NFS4ERR_INVAL.",
      "ja": "SHAREの予約の場合、式（share_access＆〜OPEN4_SHARE_ACCESS_WANT_DELEG_MASK）の値がOPEN4_SHARE_ACCESS_READ、OPEN4_SHARE_ACCESS_WRITE、またはOPEN4_SHARE_ACCESS_BOTHの一つでなければなりません。そうでない場合、サーバはNFS4ERR_INVALを返さなければなりません。 share_denyの値はOPEN4_SHARE_DENY_NONE、OPEN4_SHARE_DENY_READ、OPEN4_SHARE_DENY_WRITE、又はOPEN4_SHARE_DENY_BOTHのいずれかでなければなりません。そうでない場合、サーバはNFS4ERR_INVALを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Based on the share_access value (OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH), the client should check that the requester has the proper access rights to perform the specified operation. This would generally be the results of applying the ACL access rules to the file for the current requester. However, just as with the ACCESS operation, the client should not attempt to second-guess the server's decisions, as access rights may change and may be subject to server administrative controls outside the ACL framework. If the requester's READ or WRITE operation is not authorized (depending on the share_access value), the server MUST return NFS4ERR_ACCESS.",
      "ja": "share_access値（OPEN4_SHARE_ACCESS_READ、OPEN4_SHARE_ACCESS_WRITE、またはOPEN4_SHARE_ACCESS_BOTH）に基づいて、クライアントは、要求者が指定した操作を実行するための適切なアクセス権を持っていることを確認する必要があります。これは、一般的に、現在の要求者用のファイルにACLのアクセスルールを適用した結果だろう。しかし、単にアクセス動作と同様に、クライアントは、アクセス権が変更される可能性とACLのフレームワーク外部のサーバ管理統制を受ける可能性があるとして、サーバーの決定を第二推測を試みるべきではありません。依頼者のREADまたはWRITE操作は（share_access値に応じて）許可されていない場合、サーバーはNFS4ERR_ACCESSを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that if the client ID was not created with the EXCHGID4_FLAG_BIND_PRINC_STATEID capability set in the reply to EXCHANGE_ID, then the server MUST NOT impose any requirement that READs and WRITEs sent for an open file have the same credentials as the OPEN itself, and the server is REQUIRED to perform access checking on the READs and WRITEs themselves. Otherwise, if the reply to EXCHANGE_ID did have EXCHGID4_FLAG_BIND_PRINC_STATEID set, then with one exception, the credentials used in the OPEN request MUST match those used in the READs and WRITEs, and the stateids in the READs and WRITEs MUST match, or be derived from the stateid from the reply to OPEN. The exception is if SP4_SSV or SP4_MACH_CRED state protection is used, and the spo_must_allow result of EXCHANGE_ID includes the READ and/or WRITE operations. In that case, the machine or SSV credential will be allowed to send READ and/or WRITE. See Section 18.35.",
      "ja": "クライアントIDがEXCHANGE_IDへの返信で設定EXCHGID4_FLAG_BIND_PRINC_STATEID機能で作成されていない場合、サーバは読み込み、開いているファイルのために送られた書き込みがOPEN自体と同じ資格情報を持っているどのような要件を課してはならない、とサーバーがあることに注意してください読み込み、自分自身の書き込みを行うには、アクセスチェックを実行するために必要。 EXCHANGE_IDへの返信がEXCHGID4_FLAG_BIND_PRINC_STATEIDセットを持っていた場合はそれ以外の場合は、その後、一つの例外を除いて、OPEN要求で使用される資格情報は、読み込みと書き込み、および読み込みと書き込みが一致しなければならない、または由来することでのstateidsで使用されているものと一致しなければなりません。 OPENへの回答からのstateid。 SP4_SSV又はSP4_MACH_CRED状態の保護を使用する場合は例外であり、EXCHANGE_IDのspo_must_allow結果は、READ及び/又はWRITE動作を含みます。その場合には、機械やSSV資格はREADおよび/またはWRITEを送信することを許可されます。セクション18.35を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the component provided to OPEN is a symbolic link, the error NFS4ERR_SYMLINK will be returned to the client, while if it is a directory the error NFS4ERR_ISDIR will be returned. If the component is neither of those but not an ordinary file, the error NFS4ERR_WRONG_TYPE is returned. If the current filehandle is not a directory, the error NFS4ERR_NOTDIR will be returned.",
      "ja": "OPENに提供コンポーネントがシンボリックリンクの場合、それがディレクトリである場合は、エラーNFS4ERR_ISDIRが返されますが、エラーNFS4ERR_SYMLINKは、クライアントに返されます。コンポーネントはそれらのではなく、通常のファイルのいずれでもない場合は、エラーNFS4ERR_WRONG_TYPEが返されます。現在のファイルハンドルがディレクトリでない場合は、エラーNFS4ERR_NOTDIRが返されます。"
    },
    {
      "indent": 3,
      "text": "The use of the OPEN4_RESULT_PRESERVE_UNLINKED result flag allows a client to avoid the common implementation practice of renaming an open file to \".nfs<unique value>\" after it removes the file. After the server returns OPEN4_RESULT_PRESERVE_UNLINKED, if a client sends a REMOVE operation that would reduce the file's link count to zero, the server SHOULD report a value of zero for the numlinks attribute on the file.",
      "ja": "OPEN4_RESULT_PRESERVE_UNLINKED結果フラグの使用は、クライアントがファイルを削除した後、「.nfs <一意の値>」に開いているファイルの名前を変更する一般的な実装の練習を避けることができます。サーバがOPEN4_RESULT_PRESERVE_UNLINKEDを返した後、クライアントがゼロにファイルのリンク数を減らすことがREMOVE操作を送信した場合、サーバーは、ファイルの属性numlinksのためのゼロの値を報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "If another client has a delegation of the file being opened that conflicts with open being done (sometimes depending on the share_access or share_deny value specified), the delegation(s) MUST be recalled, and the operation cannot proceed until each such delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding. In the case of an OPEN_DELEGATE_WRITE delegation, any open by a different client will conflict, while for an OPEN_DELEGATE_READ delegation, only opens with one of the following characteristics will be considered conflicting:",
      "ja": "別のクライアントがファイルの代表団が開いているとの競合が行われていること開かれている場合は、委任（s）がリコールされなければならない（時々、指定share_accessまたはshare_deny値に応じて）、および操作は、そのような各代表団が返されるまで続行するか、またはすることはできません取り消されました。これは非常に迅速に起こる場合を除いて、一つ以上のNFS4ERR_DELAYエラーが代表団は優れたまま行われる要求に返されます。 OPEN_DELEGATE_READ代表団のために、唯一以下の特徴の一つで開きながらOPEN_DELEGATE_WRITE代表団、競合する別のクライアントが開いているの場合には、競合とみなされます。"
    },
    {
      "indent": 3,
      "text": "o The value of share_access includes the bit OPEN4_SHARE_ACCESS_WRITE.",
      "ja": "O share_accessの値は、ビットOPEN4_SHARE_ACCESS_WRITEを含みます。"
    },
    {
      "indent": 3,
      "text": "o The value of share_deny specifies OPEN4_SHARE_DENY_READ or OPEN4_SHARE_DENY_BOTH.",
      "ja": "O share_denyの値がOPEN4_SHARE_DENY_READまたはOPEN4_SHARE_DENY_BOTH指定します。"
    },
    {
      "indent": 3,
      "text": "o OPEN4_CREATE is specified together with UNCHECKED4, the size attribute is specified as zero (for truncation), and an existing file is truncated.",
      "ja": "O OPEN4_CREATEが一緒UNCHECKED4で指定され、サイズ属性はゼロ（トランケーション用）として指定され、既存のファイルは切り捨てられます。"
    },
    {
      "indent": 3,
      "text": "If OPEN4_CREATE is specified and the file does not exist and the current filehandle designates a directory for which another client holds a directory delegation, then, unless the delegation is such that the situation can be resolved by sending a notification, the delegation MUST be recalled, and the operation cannot proceed until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.",
      "ja": "OPEN4_CREATEが指定され、ファイルが存在しないと、現在のファイルハンドルが別のクライアントがディレクトリの委任を保持するためのディレクトリを指定した場合、委任は状況が通知を送信することにより解決することができるようになっている場合を除き、その後、代表団は、リコールされなければなりません代表団が返さまたは取り消されるまで、操作は続行できません。これは非常に迅速に起こる場合を除いて、一つ以上のNFS4ERR_DELAYエラーが代表団は優れたまま行われる要求に返されます。"
    },
    {
      "indent": 3,
      "text": "If OPEN4_CREATE is specified and the file does not exist and the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_ADD_ENTRY will be generated as a result of this operation.",
      "ja": "OPEN4_CREATEが指定され、ファイルが存在せず、現在のファイルハンドルは、1つのまたは複数のディレクトリ委任が存在するディレクトリを指定した場合、それらの代表は、そのような通知を要求すると、次に、NOTIFY4_ADD_ENTRYは、この操作の結果として生成されます。"
    },
    {
      "indent": 0,
      "text": "18.16.4.1. Warning to Client Implementors",
      "section_title": true,
      "ja": "18.16.4.1。クライアントの実装者に警告"
    },
    {
      "indent": 3,
      "text": "OPEN resembles LOOKUP in that it generates a filehandle for the client to use. Unlike LOOKUP though, OPEN creates server state on the filehandle. In normal circumstances, the client can only release this state with a CLOSE operation. CLOSE uses the current filehandle to determine which file to close. Therefore, the client MUST follow every OPEN operation with a GETFH operation in the same COMPOUND procedure. This will supply the client with the filehandle such that CLOSE can be used appropriately.",
      "ja": "OPEN似ているが、それは、クライアントが使用するファイルハンドルを生成するルックアップ。しかしLOOKUPとは異なり、OPENはファイルハンドルの上にサーバの状態を作成します。通常の状況では、クライアントはCLOSE操作で、この状態を解除することができます。 CLOSEは閉鎖するファイルを決定するために、現在のファイルハンドルを使用しています。そのため、クライアントは同じCOMPOUND手順でGETFH操作ですべてのOPEN操作に従わなければなりません。これは、CLOSEを適切に使用することができるように、ファイルハンドルをクライアントに提供します。"
    },
    {
      "indent": 3,
      "text": "Simply waiting for the lease on the file to expire is insufficient because the server may maintain the state indefinitely as long as another client does not attempt to make a conflicting access to the same file.",
      "ja": "サーバが無期限に限り、別のクライアントが同じファイルへの競合アクセスを作るしようとしないような状態を維持することができるので、単純に期限切れにするファイルのリースを待っていることは不十分です。"
    },
    {
      "indent": 3,
      "text": "See also Section 2.10.6.4.",
      "ja": "セクション2.10.6.4も参照してください。"
    },
    {
      "indent": 0,
      "text": "18.17. Operation 19: OPENATTR - Open Named Attribute Directory",
      "section_title": true,
      "ja": "18.17. 操作19：OPENATTR  - オープン名前付き属性ディレクトリ"
    },
    {
      "indent": 0,
      "text": "18.17.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.17.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct OPENATTR4args {\n        /* CURRENT_FH: object */\n        bool    createdir;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.17.2. RESULTS",
      "section_title": true,
      "ja": "18.17.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct OPENATTR4res {\n        /*\n         * If status is NFS4_OK,\n         *   new CURRENT_FH: named attribute\n         *                   directory\n         */\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.17.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.17.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The OPENATTR operation is used to obtain the filehandle of the named attribute directory associated with the current filehandle. The result of the OPENATTR will be a filehandle to an object of type NF4ATTRDIR. From this filehandle, READDIR and LOOKUP operations can be used to obtain filehandles for the various named attributes associated with the original file system object. Filehandles returned within the named attribute directory will designate objects of type of NF4NAMEDATTR.",
      "ja": "OPENATTR操作は、現在のファイルハンドルに関連付けられた名前の属性ディレクトリのファイルハンドルを取得するために使用されます。 OPENATTRの結果は、タイプNF4ATTRDIRのオブジェクトへのファイルハンドルであろう。このファイルハンドルから、READDIRとLOOKUP操作は、元のファイル・システム・オブジェクトに関連付けられたさまざまな名前の属性のファイルハンドルを取得するために使用することができます。ファイルハンドルはNF4NAMEDATTRの型のオブジェクトを指定しますという名前の属性ディレクトリに戻りました。"
    },
    {
      "indent": 3,
      "text": "The createdir argument allows the client to signify if a named attribute directory should be created as a result of the OPENATTR operation. Some clients may use the OPENATTR operation with a value of FALSE for createdir to determine if any named attributes exist for the object. If none exist, then NFS4ERR_NOENT will be returned. If createdir has a value of TRUE and no named attribute directory exists, one is created and its filehandle becomes the current filehandle. On the other hand, if createdir has a value of TRUE and the named attribute directory already exists, no error results and the filehandle of the existing directory becomes the current filehandle. The creation of a named attribute directory assumes that the server has implemented named attribute support in this fashion and is not required to do so by this definition.",
      "ja": "createdir引数が指定された属性ディレクトリがOPENATTR操作の結果として作成されなければならない場合、クライアントが意味することができます。任意の名前の属性がオブジェクトのために存在している場合、一部のクライアントが決定するためにcreatedirためFALSEの値でOPENATTR操作を使用することができます。何も存在しない場合、NFS4ERR_NOENTが返されます。 createdirがTRUEの値を持ち、何という名前の属性ディレクトリが存在しない場合は、1が作成され、そのファイルハンドルは、現在のファイルハンドルとなっています。一方、createdirがTRUEの値を持っていないし、名前付き属性のディレクトリがすでに存在して、エラーの結果と既存のディレクトリのファイルハンドルは、現在のファイルハンドルになった場合。名前の属性ディレクトリの作成は、サーバが、このやり方でという名前の属性のサポートを実装しており、この定義によってそうするために必要とされていないことを前提としています。"
    },
    {
      "indent": 3,
      "text": "If the current file handle designates an object of type NF4NAMEDATTR (a named attribute) or NF4ATTRDIR (a named attribute directory), an error of NFS4ERR_WRONG_TYPE is returned to the client. Named attributes or a named attribute directory MUST NOT have their own named attributes.",
      "ja": "現在のファイルハンドルがタイプNF4NAMEDATTR（名前付き属性）またはNF4ATTRDIR（名前付き属性のディレクトリ）のオブジェクトを指定した場合、NFS4ERR_WRONG_TYPEのエラーがクライアントに返されます。名前付き属性または名前付き属性のディレクトリには、自分の名前の属性を持ってはいけません。"
    },
    {
      "indent": 0,
      "text": "18.17.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.17.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the server does not support named attributes for the current filehandle, an error of NFS4ERR_NOTSUPP will be returned to the client.",
      "ja": "サーバは、現在のファイルハンドルの名前が付いた属性をサポートしていない場合は、NFS4ERR_NOTSUPPのエラーがクライアントに返されます。"
    },
    {
      "indent": 0,
      "text": "18.18. Operation 21: OPEN_DOWNGRADE - Reduce Open File Access",
      "section_title": true,
      "ja": "18.18. 操作21：OPEN_DOWNGRADE  - オープンファイルアクセスを削減"
    },
    {
      "indent": 0,
      "text": "18.18.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.18.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct OPEN_DOWNGRADE4args {\n        /* CURRENT_FH: opened file */\n        stateid4        open_stateid;\n        seqid4          seqid;\n        uint32_t        share_access;\n        uint32_t        share_deny;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.18.2. RESULTS",
      "section_title": true,
      "ja": "18.18.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct OPEN_DOWNGRADE4resok {\n        stateid4        open_stateid;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union OPEN_DOWNGRADE4res switch(nfsstat4 status) {\n case NFS4_OK:\n        OPEN_DOWNGRADE4resok    resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.18.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.18.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation is used to adjust the access and deny states for a given open. This is necessary when a given open-owner opens the same file multiple times with different access and deny values. In this situation, a close of one of the opens may change the appropriate share_access and share_deny flags to remove bits associated with opens no longer in effect.",
      "ja": "この操作は、アクセス権を調整し、特定のオープンのために状態を拒否するために使用されます。与えられたオープン所有者が異なるアクセス権を持つ同じファイルを複数回開き、値を否定するときに必要です。この状況では、開きの一つの近くには有効でなくなった開きに関連するビットを除去するために適切なshare_accessとshare_denyフラグを変更することができます。"
    },
    {
      "indent": 3,
      "text": "Valid values for the expression (share_access & ~OPEN4_SHARE_ACCESS_WANT_DELEG_MASK) are OPEN4_SHARE_ACCESS_READ, OPEN4_SHARE_ACCESS_WRITE, or OPEN4_SHARE_ACCESS_BOTH. If the client specifies other values, the server MUST reply with NFS4ERR_INVAL.",
      "ja": "式（share_access＆〜OPEN4_SHARE_ACCESS_WANT_DELEG_MASK）の有効な値はOPEN4_SHARE_ACCESS_READ、OPEN4_SHARE_ACCESS_WRITE、またはOPEN4_SHARE_ACCESS_BOTHです。クライアントが他の値を指定した場合、サーバはNFS4ERR_INVALに返答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Valid values for the share_deny field are OPEN4_SHARE_DENY_NONE, OPEN4_SHARE_DENY_READ, OPEN4_SHARE_DENY_WRITE, or OPEN4_SHARE_DENY_BOTH. If the client specifies other values, the server MUST reply with NFS4ERR_INVAL.",
      "ja": "share_denyフィールドの有効な値はOPEN4_SHARE_DENY_NONE、OPEN4_SHARE_DENY_READ、OPEN4_SHARE_DENY_WRITE、またはOPEN4_SHARE_DENY_BOTHです。クライアントが他の値を指定した場合、サーバはNFS4ERR_INVALに返答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "After checking for valid values of share_access and share_deny, the server replaces the current access and deny modes on the file with share_access and share_deny subject to the following constraints:",
      "ja": "share_accessとshare_denyの有効な値をチェックした後、サーバーは現在のアクセスを置き換え、share_accessと、次の制約を受けるshare_denyでファイルにモードを拒否します："
    },
    {
      "indent": 3,
      "text": "o The bits in share_access SHOULD equal the union of the share_access bits (not including OPEN4_SHARE_WANT_* bits) specified for some subset of the OPENs in effect for the current open-owner on the current file.",
      "ja": "O share_accessのビットは、現在のファイルの現在のオープン所有者のための効果で開きのサブセットのために指定された（OPEN4_SHARE_WANT_含まない*ビット）share_accessビットの和に等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The bits in share_deny SHOULD equal the union of the share_deny bits specified for some subset of the OPENs in effect for the current open-owner on the current file.",
      "ja": "O share_denyのビットは、現在のファイルの現在のオープン所有者のための効果で開きのサブセットに指定share_denyビットの和に等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the above constraints are not respected, the server SHOULD return the error NFS4ERR_INVAL. Since share_access and share_deny bits should be subsets of those already granted, short of a defect in the client or server implementation, it is not possible for the OPEN_DOWNGRADE request to be denied because of conflicting share reservations.",
      "ja": "上記の制約が尊重されていない場合は、サーバがエラーNFS4ERR_INVALを返すべきです。 share_accessとshare_denyビットは、クライアントまたはサーバの実装における欠陥の短いすでに付与されたもののサブセットである必要がありますのでOPEN_DOWNGRADE要求が原因で矛盾シェアの予約を拒否されるため、それは不可能です。"
    },
    {
      "indent": 3,
      "text": "The seqid argument is not used in NFSv4.1, MAY be any value, and MUST be ignored by the server.",
      "ja": "SEQID引数がNFSv4.1で使用されていない、任意の値であり、サーバによって無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.18.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.18.4. 実装"
    },
    {
      "indent": 3,
      "text": "An OPEN_DOWNGRADE operation may make OPEN_DELEGATE_READ delegations grantable where they were not previously. Servers may choose to respond immediately if there are pending delegation want requests or may respond to the situation at a later time.",
      "ja": "彼らは以前にはなかったところOPEN_DOWNGRADE操作がOPEN_DELEGATE_READの代表団が許可できることがあります。サーバーは保留中の委任がある場合、リクエストをしたいか、後で状況に応答することができる即座に応答することもできます。"
    },
    {
      "indent": 0,
      "text": "18.19. Operation 22: PUTFH - Set Current Filehandle",
      "section_title": true,
      "ja": "18.19. 操作22：PUTFH  - 設定された現在のファイルハンドル"
    },
    {
      "indent": 0,
      "text": "18.19.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.19.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct PUTFH4args {\n        nfs_fh4         object;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.19.2. RESULTS",
      "section_title": true,
      "ja": "18.19.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct PUTFH4res {\n        /*\n         * If status is NFS4_OK,\n         *    new CURRENT_FH: argument to PUTFH\n         */\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.19.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.19.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation replaces the current filehandle with the filehandle provided as an argument. It clears the current stateid.",
      "ja": "この操作は、引数として与えられたファイルハンドルと、現在のファイルハンドルを置き換えます。これは、現在のstateidをクリアします。"
    },
    {
      "indent": 3,
      "text": "If the security mechanism used by the requester does not meet the requirements of the filehandle provided to this operation, the server MUST return NFS4ERR_WRONGSEC.",
      "ja": "依頼者が使用するセキュリティ・メカニズムは、この操作に提供されるファイルハンドルの要件を満たしていない場合、サーバーはNFS4ERR_WRONGSECを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.1 for more details on the current filehandle.",
      "ja": "現在のファイルハンドルの詳細については、セクション16.2.3.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.2 for more details on the current stateid.",
      "ja": "現在のstateidの詳細については、セクション16.2.3.1.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.19.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.19.4. 実装"
    },
    {
      "indent": 3,
      "text": "This operation is used in an NFS request to set the context for file accessing operations that follow in the same COMPOUND request.",
      "ja": "この操作は、ファイルが同じCOMPOUND要求に従うの操作にアクセスするためのコンテキストを設定するには、NFS要求に使用されています。"
    },
    {
      "indent": 0,
      "text": "18.20. Operation 23: PUTPUBFH - Set Public Filehandle",
      "section_title": true,
      "ja": "18.20. 操作23：PUTPUBFH  - セットの公開ファイルハンドル"
    },
    {
      "indent": 0,
      "text": "18.20.1. ARGUMENT",
      "section_title": true,
      "ja": "18.20.1. 引数"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "18.20.2. RESULT",
      "section_title": true,
      "ja": "18.20.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct PUTPUBFH4res {\n        /*\n         * If status is NFS4_OK,\n         *   new CURRENT_FH: public fh\n         */\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.20.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.20.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation replaces the current filehandle with the filehandle that represents the public filehandle of the server's namespace. This filehandle may be different from the \"root\" filehandle that may be associated with some other directory on the server.",
      "ja": "この操作は、サーバーの名前空間の公開ファイルハンドルを表し、ファイルハンドルと、現在のファイルハンドルを置き換えます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けすることができる「ルート」ファイルハンドルは異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "PUTPUBFH also clears the current stateid.",
      "ja": "PUTPUBFHは、現在のstateidをクリアします。"
    },
    {
      "indent": 3,
      "text": "The public filehandle represents the concepts embodied in RFC 2054 [42], RFC 2055 [43], and RFC 2224 [53]. The intent for NFSv4.1 is that the public filehandle (represented by the PUTPUBFH operation) be used as a method of providing WebNFS server compatibility with NFSv3.",
      "ja": "公共ファイルハンドルは、[53] RFC 2054 [42]、RFC 2055 [43]、およびRFC 2224で具現する概念を表します。 NFSv4.1のための意図は、（PUTPUBFH動作によって表される）は、公開ファイルハンドルはNFSv3のとWebNFSのサーバとの互換性を提供する方法として使用することです。"
    },
    {
      "indent": 3,
      "text": "The public filehandle and the root filehandle (represented by the PUTROOTFH operation) SHOULD be equivalent. If the public and root filehandles are not equivalent, then the directory corresponding to the public filehandle MUST be a descendant of the directory corresponding to the root filehandle.",
      "ja": "（PUTROOTFH操作によって表される）は、公開ファイルハンドルとルートファイルハンドルは同等であるべきです。公共とルートファイルハンドルが等しくない場合には、公共ファイルハンドルに対応するディレクトリは、ルートファイルハンドルに対応するディレクトリの子孫でなければなりません。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.1 for more details on the current filehandle.",
      "ja": "現在のファイルハンドルの詳細については、セクション16.2.3.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.2 for more details on the current stateid.",
      "ja": "現在のstateidの詳細については、セクション16.2.3.1.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.20.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.20.4. 実装"
    },
    {
      "indent": 3,
      "text": "This operation is used in an NFS request to set the context for file accessing operations that follow in the same COMPOUND request.",
      "ja": "この操作は、ファイルが同じCOMPOUND要求に従うの操作にアクセスするためのコンテキストを設定するには、NFS要求に使用されています。"
    },
    {
      "indent": 3,
      "text": "With the NFSv3 public filehandle, the client is able to specify whether the pathname provided in the LOOKUP should be evaluated as either an absolute path relative to the server's root or relative to the public filehandle. RFC 2224 [53] contains further discussion of the functionality. With NFSv4.1, that type of specification is not directly available in the LOOKUP operation. The reason for this is because the component separators needed to specify absolute vs. relative are not allowed in NFSv4. Therefore, the client is responsible for constructing its request such that the use of either PUTROOTFH or PUTPUBFH signifies absolute or relative evaluation of an NFS URL, respectively.",
      "ja": "NFSv3の公共ファイルハンドルを使用すると、クライアントはLOOKUPで提供パス名は、サーバのルートからの相対または公共ファイルハンドルからの相対、絶対パスのいずれかのように評価されるべきかどうかを指定することができます。 RFC 2224 [53]機能のさらなる議論を含んでいます。 NFSv4.1では、仕様のそのタイプはLOOKUP操作で直接使用できません。相対的な対絶対指定するのに必要なコンポーネントセパレータは、NFSv4ので許可されていないためです。そのため、クライアントはPUTROOTFHまたはPUTPUBFHのいずれかの使用は、それぞれ、NFS URLの絶対的または相対的な評価を意味するように、その要求を構築するための責任があります。"
    },
    {
      "indent": 3,
      "text": "Note that there are warnings mentioned in RFC 2224 [53] with respect to the use of absolute evaluation and the restrictions the server may place on that evaluation with respect to how much of its namespace has been made available. These same warnings apply to NFSv4.1. It is likely, therefore, that because of server implementation details, an NFSv3 absolute public filehandle look up may behave differently than an NFSv4.1 absolute resolution.",
      "ja": "RFC 2224に記載された警告は、絶対評価の利用と、サーバーが利用可能になってきたどのくらいその名前空間のに対し、評価の上に置くことの制限に関して[53]があることに注意してください。これらの同じ警告はNFSv4.1に適用されます。これは、ため、サーバーの実装の詳細を、NFSv3の絶対的な公共ファイルハンドルが異なっNFSv4.1絶対解像度よりも振る舞うことを調べること、したがって、可能性があります。"
    },
    {
      "indent": 3,
      "text": "There is a form of security negotiation as described in RFC 2755 [54] that uses the public filehandle and an overloading of the pathname. This method is not available with NFSv4.1 as filehandles are not overloaded with special meaning and therefore do not provide the same framework as NFSv3. Clients should therefore use the security negotiation mechanisms described in Section 2.6.",
      "ja": "公共ファイルハンドルとパス名のオーバーロードを使用して、RFC 2755 [54]で説明したようにセキュリティネゴシエーションの形式があります。ファイルハンドルは特別な意味を持つオーバーロードされていないため、NFSv3のと同じフレームワークを提供していないとして、この方法は、NFSv4.1では使用できません。クライアントは、したがって、2.6節で説明したセキュリティ交渉メカニズムを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.21. Operation 24: PUTROOTFH - Set Root Filehandle",
      "section_title": true,
      "ja": "18.21. 操作24：PUTROOTFH  - セットのルートファイルハンドル"
    },
    {
      "indent": 0,
      "text": "18.21.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.21.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "18.21.2. RESULTS",
      "section_title": true,
      "ja": "18.21.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct PUTROOTFH4res {\n        /*\n         * If status is NFS4_OK,\n         *   new CURRENT_FH: root fh\n         */\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.21.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.21.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation replaces the current filehandle with the filehandle that represents the root of the server's namespace. From this filehandle, a LOOKUP operation can locate any other filehandle on the server. This filehandle may be different from the \"public\" filehandle that may be associated with some other directory on the server.",
      "ja": "この操作は、サーバーの名前空間のルートを表すファイルハンドルと、現在のファイルハンドルを置き換えます。このファイルハンドルから、LOOKUP操作は、サーバー上の他のファイルハンドルを見つけることができます。このファイルハンドルは、サーバー上の他のディレクトリに関連付けすることができる「パブリック」ファイルハンドルは異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "PUTROOTFH also clears the current stateid.",
      "ja": "PUTROOTFHは、現在のstateidをクリアします。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.1 for more details on the current filehandle.",
      "ja": "現在のファイルハンドルの詳細については、セクション16.2.3.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.2 for more details on the current stateid.",
      "ja": "現在のstateidの詳細については、セクション16.2.3.1.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.21.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.21.4. 実装"
    },
    {
      "indent": 3,
      "text": "This operation is used in an NFS request to set the context for file accessing operations that follow in the same COMPOUND request.",
      "ja": "この操作は、ファイルが同じCOMPOUND要求に従うの操作にアクセスするためのコンテキストを設定するには、NFS要求に使用されています。"
    },
    {
      "indent": 0,
      "text": "18.22. Operation 25: READ - Read from File",
      "section_title": true,
      "ja": "18.22. 操作25：READ  - ファイルから読み込みます"
    },
    {
      "indent": 0,
      "text": "18.22.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.22.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct READ4args {\n        /* CURRENT_FH: file */\n        stateid4        stateid;\n        offset4         offset;\n        count4          count;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.22.2. RESULTS",
      "section_title": true,
      "ja": "18.22.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct READ4resok {\n        bool            eof;\n        opaque          data<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union READ4res switch (nfsstat4 status) {\n case NFS4_OK:\n         READ4resok     resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.22.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.22.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The READ operation reads data from the regular file identified by the current filehandle.",
      "ja": "READ操作は、現在のファイルハンドルで識別される通常のファイルからデータを読み込みます。"
    },
    {
      "indent": 3,
      "text": "The client provides an offset of where the READ is to start and a count of how many bytes are to be read. An offset of zero means to read data starting at the beginning of the file. If offset is greater than or equal to the size of the file, the status NFS4_OK is returned with a data length set to zero and eof is set to TRUE. The READ is subject to access permissions checking.",
      "ja": "クライアントはREADが開始することで、どのように多くのバイト数を読み取ることがどこのオフセットを提供します。ゼロのオフセットをファイルの先頭から始まるデータを読み取ることを意味します。オフセットがより大きいかまたはファイルのサイズに等しい場合、ステータスNFS4_OKはゼロに設定されたデータ長で返され、EOFがTRUEに設定されています。 READは、チェックアクセス許可の対象となります。"
    },
    {
      "indent": 3,
      "text": "If the client specifies a count value of zero, the READ succeeds and returns zero bytes of data again subject to access permissions checking. The server may choose to return fewer bytes than specified by the client. The client needs to check for this condition and handle the condition appropriately.",
      "ja": "クライアントがゼロのカウント値を指定した場合、READは成功し、アクセス権限チェックの対象と再び0バイトのデータを返します。サーバーは、クライアントによって指定されたよりも少ないバイト数を返すように選択することができます。クライアントは、この状態を確認し、適切な条件を処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Except when special stateids are used, the stateid value for a READ request represents a value returned from a previous byte-range lock or share reservation request or the stateid associated with a delegation. The stateid identifies the associated owners if any and is used by the server to verify that the associated locks are still valid (e.g., have not been revoked).",
      "ja": "特別のstateidsが使用される場合を除き、READ要求のためのstateid値は、以前のバイト範囲ロックまたは共有の予約要求又は委任に関連付けられたstateidから返された値を表します。 stateidは、もしあれば、関連する所有者を識別し、関連するロックがまだ有効（例えば、失効していない）であることを確認するためにサーバによって使用されます。"
    },
    {
      "indent": 3,
      "text": "If the read ended at the end-of-file (formally, in a correctly formed READ operation, if offset + count is equal to the size of the file), or the READ operation extends beyond the size of the file (if offset + count is greater than the size of the file), eof is returned as TRUE; otherwise, it is FALSE. A successful READ of an empty file will always return eof as TRUE.",
      "ja": "オフセットが（ファイルの終わりで終了読み取り（オフセット+回数場合、正しく形成さREAD操作で、正式には、ファイルのサイズと同じである）、またはREAD操作はファイルのサイズを超えて拡張する場合+カウントは、EOFがTRUEとして返され、）ファイルのサイズよりも大きいです。それ以外の場合はFALSEです。空のファイルの成功READは常にEOFとしてTRUEを返します。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle is not an ordinary file, an error will be returned to the client. In the case that the current filehandle represents an object of type NF4DIR, NFS4ERR_ISDIR is returned. If the current filehandle designates a symbolic link, NFS4ERR_SYMLINK is returned. In all other cases, NFS4ERR_WRONG_TYPE is returned.",
      "ja": "現在のファイルハンドルが通常のファイルでない場合、エラーがクライアントに返されます。現在のファイルハンドルが型NF4DIRのオブジェクトを表す場合には、NFS4ERR_ISDIRが返されます。現在のファイルハンドルがシンボリックリンクを指定した場合、NFS4ERR_SYMLINKが返されます。他のすべてのケースでは、NFS4ERR_WRONG_TYPEが返されます。"
    },
    {
      "indent": 3,
      "text": "For a READ with a stateid value of all bits equal to zero, the server MAY allow the READ to be serviced subject to mandatory byte-range locks or the current share deny modes for the file. For a READ with a stateid value of all bits equal to one, the server MAY allow READ operations to bypass locking checks at the server.",
      "ja": "ゼロに等しいすべてのビットのstateid値がREADのために、サーバは、READが必須のバイト範囲ロックまたは現在の共有ファイルのためのモードを拒否する対象サービスを受けることを可能にすることができます。 1に等しいすべてのビットのstateid値がREADのために、サーバは、READ操作はサーバにロックチェックをバイパスすることを可能にし得ます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.22.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.22.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the server returns a \"short read\" (i.e., fewer data than requested and eof is set to FALSE), the client should send another READ to get the remaining data. A server may return less data than requested under several circumstances. The file may have been truncated by another client or perhaps on the server itself, changing the file size from what the requesting client believes to be the case. This would reduce the actual amount of data available to the client. It is possible that the server reduce the transfer size and so return a short read result. Server resource exhaustion may also occur in a short read.",
      "ja": "サーバは「短い読み取りを」返した場合（つまり、要求されたとEOFがFALSEに設定されているよりも少ないデータ）、クライアントが残りのデータを取得するために別のREADを送信する必要があります。サーバーには、いくつかの状況下で要求されたよりも少ないデータを返すことがあります。ファイルが要求しているクライアントは、ケースのように信じているから、ファイルサイズを変更し、別のクライアントによって、またはおそらく、サーバー自体に切り捨てられている可能性があります。これは、クライアントが利用可能なデータの実際の量を減少させるであろう。サーバーが転送サイズを削減し、短いので読んで結果を返すことも可能です。サーバーリソースの枯渇も短い読み取りに発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "If mandatory byte-range locking is in effect for the file, and if the byte-range corresponding to the data to be read from the file is WRITE_LT locked by an owner not associated with the stateid, the server will return the NFS4ERR_LOCKED error. The client should try to get the appropriate READ_LT via the LOCK operation before re-attempting the READ. When the READ completes, the client should release the byte-range lock via LOCKU.",
      "ja": "必須のバイト範囲ロックは、ファイルのための有効であり、データに対応するバイト範囲をファイルから読み出される場合のstateidに関連付けられていない所有者によってロックWRITE_LTされている場合、サーバはNFS4ERR_LOCKEDエラーを返します。クライアントはREADを再試行する前にLOCK操作を経由して、適切なREAD_LTを取得しようとする必要があります。 READが完了すると、クライアントはLOCKU経由バイト範囲ロックを解除する必要があります。"
    },
    {
      "indent": 3,
      "text": "If another client has an OPEN_DELEGATE_WRITE delegation for the file being read, the delegation must be recalled, and the operation cannot proceed until that delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding. Normally, delegations will not be recalled as a result of a READ operation since the recall will occur as a result of an earlier OPEN. However, since it is possible for a READ to be done with a special stateid, the server needs to check for this case even though the client should have done an OPEN previously.",
      "ja": "別のクライアントが読み込まれるファイルのOPEN_DELEGATE_WRITE委任を持っている場合は、委任をリコールする必要があり、その代表団が返さまたは取り消されるまで操作を続行できません。これは非常に迅速に起こる場合を除いて、一つ以上のNFS4ERR_DELAYエラーが代表団は優れたまま行われる要求に返されます。リコールは、以前のOPENの結果として発生しますので、通常、代表団はREAD操作の結果としてリコールされることはありません。 READは、特別なstateidで行われることが可能であるので、サーバーは、クライアントが以前にOPENを行っている必要があるにもかかわらず、このような場合のためにチェックする必要があります。"
    },
    {
      "indent": 0,
      "text": "18.23. Operation 26: READDIR - Read Directory",
      "section_title": true,
      "ja": "18.23. 操作26：READDIR  - 読むディレクトリ"
    },
    {
      "indent": 0,
      "text": "18.23.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.23.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct READDIR4args {\n        /* CURRENT_FH: directory */\n        nfs_cookie4     cookie;\n        verifier4       cookieverf;\n        count4          dircount;\n        count4          maxcount;\n        bitmap4         attr_request;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.23.2. RESULTS",
      "section_title": true,
      "ja": "18.23.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct entry4 {\n        nfs_cookie4     cookie;\n        component4      name;\n        fattr4          attrs;\n        entry4          *nextentry;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct dirlist4 {\n        entry4          *entries;\n        bool            eof;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct READDIR4resok {\n        verifier4       cookieverf;\n        dirlist4        reply;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union READDIR4res switch (nfsstat4 status) {\n case NFS4_OK:\n         READDIR4resok  resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.23.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.23.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The READDIR operation retrieves a variable number of entries from a file system directory and returns client-requested attributes for each entry along with information to allow the client to request additional directory entries in a subsequent READDIR.",
      "ja": "READDIR操作は、ファイル・システム・ディレクトリのエントリの可変数を取得し、クライアントがその後のREADDIRに追加のディレクトリエントリを要求することを可能にする情報とともに、各エントリのクライアント要求された属性を返します。"
    },
    {
      "indent": 3,
      "text": "The arguments contain a cookie value that represents where the READDIR should start within the directory. A value of zero for the cookie is used to start reading at the beginning of the directory. For subsequent READDIR requests, the client specifies a cookie value that is provided by the server on a previous READDIR request.",
      "ja": "引数はREADDIRがディレクトリ内の開始すべき場所を表すクッキー値が含まれています。クッキーのためのゼロの値は、ディレクトリの始めに読み始めるために使用されます。その後のREADDIR要求の場合、クライアントは前のREADDIR要求にサーバーによって提供されたクッキーの値を指定します。"
    },
    {
      "indent": 3,
      "text": "The request's cookieverf field should be set to 0 zero) when the request's cookie field is zero (first read of the directory). On subsequent requests, the cookieverf field must match the cookieverf returned by the READDIR in which the cookie was acquired. If the server determines that the cookieverf is no longer valid for the directory, the error NFS4ERR_NOT_SAME must be returned.",
      "ja": "リクエストのにcookieverfフィールドは0ゼロ）要求のクッキーフィールドがゼロの場合（最初のディレクトリの読み取り）に設定する必要があります。後続の要求では、にcookieverfフィールドには、Cookieが取得されたREADDIRによって返さにcookieverfと一致する必要があります。サーバはにcookieverfは、もはや有効なディレクトリのためではないと判断した場合、エラーNFS4ERR_NOT_SAMEを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The dircount field of the request is a hint of the maximum number of bytes of directory information that should be returned. This value represents the total length of the names of the directory entries and the cookie value for these entries. This length represents the XDR encoding of the data (names and cookies) and not the length in the native format of the server.",
      "ja": "要求のdircountフィールドが返されるべきであるディレクトリ情報のバイトの最大数のヒントです。この値は、ディレクトリエントリとこれらのエントリのクッキー値の名前の長さの合計を表します。この長さは、XDRデータ（名前およびクッキー）の符号化ではなく、サーバのネイティブフォーマットにおける長さを表します。"
    },
    {
      "indent": 3,
      "text": "The maxcount field of the request represents the maximum total size of all of the data being returned within the READDIR4resok structure and includes the XDR overhead. The server MAY return less data. If the server is unable to return a single directory entry within the maxcount limit, the error NFS4ERR_TOOSMALL MUST be returned to the client.",
      "ja": "要求のMAXCOUNTフィールドはREADDIR4resok構造内に返されるすべてのデータの最大合計サイズを表し、XDRオーバーヘッドを含みます。サーバーは、以下のデータを返す場合があります。サーバがMAXCOUNT限度内の単一のディレクトリエントリを返すことができない場合は、エラーNFS4ERR_TOOSMALLは、クライアントに返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Finally, the request's attr_request field represents the list of attributes to be returned for each directory entry supplied by the server.",
      "ja": "最後に、リクエストのattr_requestフィールドは、サーバーによって供給される各ディレクトリエントリのために返される属性のリストを表します。"
    },
    {
      "indent": 3,
      "text": "A successful reply consists of a list of directory entries. Each of these entries contains the name of the directory entry, a cookie value for that entry, and the associated attributes as requested. The \"eof\" flag has a value of TRUE if there are no more entries in the directory.",
      "ja": "正常な応答は、ディレクトリエントリのリストで構成されています。要求に応じてこれらの各エントリには、ディレクトリエントリ、そのエントリのクッキー値、および関連する属性の名前が含まれています。ディレクトリには複数のエントリが存在しない場合は、「EOF」フラグがTRUEの値を持ちます。"
    },
    {
      "indent": 3,
      "text": "The cookie value is only meaningful to the server and is used as a cursor for the directory entry. As mentioned, this cookie is used by the client for subsequent READDIR operations so that it may continue reading a directory. The cookie is similar in concept to a READ offset but MUST NOT be interpreted as such by the client. Ideally, the cookie value SHOULD NOT change if the directory is modified since the client may be caching these values.",
      "ja": "クッキー値は、サーバにのみ意味があり、ディレクトリエントリのカーソルとして使用されます。前述のように、それはディレクトリを読み続けることができるように、このクッキーは、その後のREADDIR操作のためにクライアントによって使用されます。クッキーは、オフセットREADの概念と似ていますが、クライアントによってそのように解釈してはなりません。ディレクトリが変更された場合、クライアントは、これらの値をキャッシュすることができるので、理想的には、クッキーの値は変更しないでください。"
    },
    {
      "indent": 3,
      "text": "In some cases, the server may encounter an error while obtaining the attributes for a directory entry. Instead of returning an error for the entire READDIR operation, the server can instead return the attribute rdattr_error (Section 5.8.1.12). With this, the server is able to communicate the failure to the client and not fail the entire operation in the instance of what might be a transient failure. Obviously, the client must request the fattr4_rdattr_error attribute for this method to work properly. If the client does not request the attribute, the server has no choice but to return failure for the entire READDIR operation.",
      "ja": "ディレクトリエントリの属性を取得しながら、いくつかのケースでは、サーバがエラーが発生することがあります。代わりに、全体のREADDIR操作のためのエラーを返すので、サーバーではなく、属性rdattr_error（セクション5.8.1.12）を返すことができます。これにより、サーバはクライアントに障害が発生して通信し、一時的な障害であるかもしれないもののインスタンスで全体の動作を失敗しないことが可能です。もちろん、クライアントは正常に動作するために、このメソッドのfattr4_rdattr_error属性を要求する必要があります。クライアントが属性を要求しない場合、サーバは全体のREADDIR操作のために失敗を返すしかありません。"
    },
    {
      "indent": 3,
      "text": "For some file system environments, the directory entries \".\" and \"..\" have special meaning, and in other environments, they do not. If the server supports these special entries within a directory, they SHOULD NOT be returned to the client as part of the READDIR response. To enable some client environments, the cookie values of zero, 1, and 2 are to be considered reserved. Note that the UNIX client will use these values when combining the server's response and local representations to enable a fully formed UNIX directory presentation to the application.",
      "ja": "いくつかのファイルシステム環境では、ディレクトリエントリ「」そして、「..」は特別な意味を持っており、他の環境では、そうではありません。サーバーは、ディレクトリ内のこれらの特別項目をサポートしている場合、彼らはREADDIR応答の一部としてクライアントに返されるべきではありません。いくつかのクライアント環境を有効にするには、ゼロ、1、および2のクッキー値は、予約された考慮されるべきです。アプリケーションに完全に形成されたUNIXディレクトリのプレゼンテーションを可能にするために、サーバーの応答とローカル表現を組み合わせる場合、UNIXクライアントはこれらの値を使用することに注意してください。"
    },
    {
      "indent": 3,
      "text": "For READDIR arguments, cookie values of one and two SHOULD NOT be used, and for READDIR results, cookie values of zero, one, and two SHOULD NOT be returned.",
      "ja": "READDIRの引数については、1と2のクッキー値を使用すべきでない、とREADDIR結果について、ゼロのクッキー値、1、および2が返されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.23.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.23.4. 実装"
    },
    {
      "indent": 3,
      "text": "The server's file system directory representations can differ greatly. A client's programming interfaces may also be bound to the local operating environment in a way that does not translate well into the NFS protocol. Therefore, the use of the dircount and maxcount fields are provided to enable the client to provide hints to the server. If the client is aggressive about attribute collection during a READDIR, the server has an idea of how to limit the encoded response.",
      "ja": "サーバのファイルシステムのディレクトリ表現は大きく異なることができます。クライアントのプログラミング・インタフェースは、NFSプロトコルにうまく変換されないように、ローカルの動作環境に結合させることができます。したがって、dircountとMAXCOUNTフィールドの使用は、サーバーにヒントを提供するために、クライアントを可能にするために提供されています。クライアントは、READDIR時の属性コレクションについて積極的である場合、サーバーはエンコードされた応答を制限する方法のアイデアを持っています。"
    },
    {
      "indent": 3,
      "text": "If dircount is zero, the server bounds the reply's size based on the request's maxcount field.",
      "ja": "dircountがゼロの場合、サーバーはその要求のMAXCOUNTフィールドに基づいて応答の大きさの境界。"
    },
    {
      "indent": 3,
      "text": "The cookieverf may be used by the server to help manage cookie values that may become stale. It should be a rare occurrence that a server is unable to continue properly reading a directory with the provided cookie/cookieverf pair. The server SHOULD make every effort to avoid this condition since the application at the client might be unable to properly handle this type of failure.",
      "ja": "cookieverfは古くなる可能性がクッキー値の管理を支援するためにサーバが使用することができます。これは、サーバーが提供するクッキー/にcookieverfペアでディレクトリを読み、適切に継続することができないまれな出来事でなければなりません。サーバーは、クライアントのアプリケーションが正常にこのタイプの障害を扱うことができない場合がありますので、この状態を回避するためにあらゆる努力をするべきです。"
    },
    {
      "indent": 3,
      "text": "The use of the cookieverf will also protect the client from using READDIR cookie values that might be stale. For example, if the file system has been migrated, the server might or might not be able to use the same cookie values to service READDIR as the previous server used. With the client providing the cookieverf, the server is able to provide the appropriate response to the client. This prevents the case where the server accepts a cookie value but the underlying directory has changed and the response is invalid from the client's context of its previous READDIR.",
      "ja": "cookieverfの使用も古いかもしれませんREADDIRクッキー値を使用してからクライアントを保護します。ファイルシステムが移行された場合、例えば、サーバは、または使用前のサーバとしてREADDIRにサービスを提供するために同じクッキー値を使用することができない場合があります。クライアントがにcookieverfを提供すると、サーバはクライアントに適切な応答を提供することができます。これは、サーバがクッキー値を受け入れますが、基本となるディレクトリが変更されたケースを防ぎ、応答がその前のREADDIRのクライアントの文脈から無効です。"
    },
    {
      "indent": 3,
      "text": "Since some servers will not be returning \".\" and \"..\" entries as has been done with previous versions of the NFS protocol, the client that requires these entries be present in READDIR responses must fabricate them.",
      "ja": "いくつかのサーバは戻ることはありませんので、「」そして、「..」エントリNFSプロトコルの以前のバージョンで行われているように、これらのエントリはREADDIR応答に存在することが必要とするクライアントは、それらを製作しなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.24. Operation 27: READLINK - Read Symbolic Link",
      "section_title": true,
      "ja": "18.24. 操作27：READLINK  - シンボリックリンクを読みます"
    },
    {
      "indent": 0,
      "text": "18.24.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.24.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "/* CURRENT_FH: symlink */\nvoid;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.24.2. RESULTS",
      "section_title": true,
      "ja": "18.24.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct READLINK4resok {\n        linktext4       link;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union READLINK4res switch (nfsstat4 status) {\n case NFS4_OK:\n         READLINK4resok resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.24.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.24.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "READLINK reads the data associated with a symbolic link. Depending on the value of the UTF-8 capability attribute (Section 14.4), the data is encoded in UTF-8. Whether created by an NFS client or created locally on the server, the data in a symbolic link is not interpreted (except possibly to check for proper UTF-8 encoding) when created, but is simply stored.",
      "ja": "READLINKは、シンボリックリンクに関連付けられたデータを読み込みます。 UTF-8能力属性（14.4節）の値に応じて、データはUTF-8でエンコードされます。 NFSクライアントによって作成されたか、サーバー上でローカルに作成されたかどうか、シンボリックリンクのデータが作成されたときに（適切なUTF-8エンコーディングをチェックするために可能性を除く）と解釈されていませんが、単純に保存されています。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.24.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.24.4. 実装"
    },
    {
      "indent": 3,
      "text": "A symbolic link is nominally a pointer to another file. The data is not necessarily interpreted by the server, just stored in the file. It is possible for a client implementation to store a pathname that is not meaningful to the server operating system in a symbolic link. A READLINK operation returns the data to the client for interpretation. If different implementations want to share access to symbolic links, then they must agree on the interpretation of the data in the symbolic link.",
      "ja": "シンボリックリンクは、名目上は別のファイルへのポインタです。データは必ずしも単にファイルに保存され、サーバーによって解釈されていません。クライアントの実装がシンボリックリンクで、サーバーのオペレーティングシステムには意味がありませんパス名を保存することが可能です。 READLINK操作は、解釈のために、クライアントにデータを返します。異なる実装がシンボリックリンクへのアクセスを共有したい場合は、それらはシンボリックリンクでのデータの解釈に同意しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The READLINK operation is only allowed on objects of type NF4LNK. The server should return the error NFS4ERR_WRONG_TYPE if the object is not of type NF4LNK.",
      "ja": "READLINK操作は、タイプがNF4LNKのオブジェクトに許可されています。オブジェクトの型がNF4LNKでない場合、サーバーはエラーNFS4ERR_WRONG_TYPEを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "18.25. Operation 28: REMOVE - Remove File System Object",
      "section_title": true,
      "ja": "18.25. 操作28：REMOVE  - ファイルシステムオブジェクトを削除します"
    },
    {
      "indent": 0,
      "text": "18.25.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.25.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct REMOVE4args {\n        /* CURRENT_FH: directory */\n        component4      target;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.25.2. RESULTS",
      "section_title": true,
      "ja": "18.25.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct REMOVE4resok {\n        change_info4    cinfo;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union REMOVE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         REMOVE4resok   resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.25.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.25.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The REMOVE operation removes (deletes) a directory entry named by filename from the directory corresponding to the current filehandle. If the entry in the directory was the last reference to the corresponding file system object, the object may be destroyed. The directory may be either of type NF4DIR or NF4ATTRDIR.",
      "ja": "REMOVE操作は、現在のファイルハンドルに対応するディレクトリからファイル名で指定されたディレクトリエントリを削除（消去します）。ディレクトリ内のエントリは、対応するファイル・システム・オブジェクトへの最後の参照であった場合、オブジェクトが破棄されてもよいです。ディレクトリ型NF4DIRまたはNF4ATTRDIRのいずれであってもよいです。"
    },
    {
      "indent": 3,
      "text": "For the directory where the filename was removed, the server returns change_info4 information in cinfo. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the removal.",
      "ja": "ファイル名が削除されたディレクトリのために、サーバはcinfoの変化_info4情報を返します。前と後の変更属性が除去に関して原子論が得られた場合には変化_info4データ型の原子分野、意志が示すサーバ。"
    },
    {
      "indent": 3,
      "text": "If the target has a length of zero, or if the target does not obey the UTF-8 definition (and the server is enforcing UTF-8 encoding; see Section 14.4), the error NFS4ERR_INVAL will be returned.",
      "ja": "ターゲットがゼロの長さを有し、またはターゲットがUTF-8定義に従わない場合場合（及びサーバーはUTF-8エンコーディングを強制され、セクション14.4を参照）、エラーNFS4ERR_INVALが返されます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.25.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.25.4. 実装"
    },
    {
      "indent": 3,
      "text": "NFSv3 required a different operator RMDIR for directory removal and REMOVE for non-directory removal. This allowed clients to skip checking the file type when being passed a non-directory delete system call (e.g., unlink() [27] in POSIX) to remove a directory, as well as the converse (e.g., a rmdir() on a non-directory) because they knew the server would check the file type. NFSv4.1 REMOVE can be used to delete any directory entry independent of its file type. The implementor of an NFSv4.1 client's entry points from the unlink() and rmdir() system calls should first check the file type against the types the system call is allowed to remove before sending a REMOVE operation. Alternatively, the implementor can produce a COMPOUND call that includes a LOOKUP/VERIFY sequence of operations to verify the file type before a REMOVE operation in the same COMPOUND call.",
      "ja": "NFSv3のは、ディレクトリを除去するための別のオペレータRMDIRを必要とし、非ディレクトリの除去のために削除します。これは、上の）ディレクトリを削除するだけでなく、その逆（例えば、RMDIR（する非ディレクトリは（POSIXには例えば、（解除）[27]）システムコールを削除渡されるときに、クライアントは、ファイルの種類をチェックするスキップすることができ非ディレクトリ）は、サーバーがファイルの種類を確認することを知っていたので。 NFSv4.1のREMOVEは、そのファイルの種類のいずれかのディレクトリエントリの独立を削除するために使用することができます。アンリンクからNFSv4.1のクライアントのエントリポイントの実装（）とは、rmdir（）システムコールは、最初のシステムコールがREMOVE操作を送信する前に削除することが許可されているタイプに対してファイルの種類を確認する必要があります。代替として、実装者は、同じ化合物の呼び出しでREMOVE操作の前にファイルの種類を確認するために一連の動作を検証/ LOOKUPを含む化合物のコールを生成することができます。"
    },
    {
      "indent": 3,
      "text": "The concept of last reference is server specific. However, if the numlinks field in the previous attributes of the object had the value 1, the client should not rely on referring to the object via a filehandle. Likewise, the client should not rely on the resources (disk space, directory entry, and so on) formerly associated with the object becoming immediately available. Thus, if a client needs to be able to continue to access a file after using REMOVE to remove it, the client should take steps to make sure that the file will still be accessible. While the traditional mechanism used is to RENAME the file from its old name to a new hidden name, the NFSv4.1 OPEN operation MAY return a result flag, OPEN4_RESULT_PRESERVE_UNLINKED, which indicates to the client that the file will be preserved if the file has an outstanding open (see Section 18.16).",
      "ja": "最後の参照の概念は、サーバ固有のものです。オブジェクトの前の属性でnumlinksフィールドが値1を持っていた場合は、クライアントがファイルハンドルを経由してオブジェクトを参照するに頼るべきではありません。同様に、クライアントは以前すぐに利用可能になってきたオブジェクトに関連付けられたリソース（ディスク容量、ディレクトリエントリなど）に依存しないでください。クライアントは、それを削除するREMOVEを使用した後、ファイルへのアクセスを継続できるようにする必要がある場合はこのように、クライアントは、ファイルがまだアクセス可能になることを確認する手順を実行する必要があります。使用される伝統的なメカニズムは新しい隠された名前に古い名前からファイルの名前を変更することであるが、NFSv4.1 OPEN操作は、ファイルがある場合、ファイルが保存されることをクライアントに指示する結果フラグ、OPEN4_RESULT_PRESERVE_UNLINKEDを、返してもよいです優れたオープン（項18.16を参照してください）。"
    },
    {
      "indent": 3,
      "text": "If the server finds that the file is still open when the REMOVE arrives:",
      "ja": "サーバーは、REMOVEが到着したときにファイルがまだ開いていることを発見した場合："
    },
    {
      "indent": 3,
      "text": "o The server SHOULD NOT delete the file's directory entry if the file was opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH.",
      "ja": "ファイルがOPEN4_SHARE_DENY_WRITEまたはOPEN4_SHARE_DENY_BOTHで開かれた場合、Oサーバは、ファイルのディレクトリエントリを削除しないでください。"
    },
    {
      "indent": 3,
      "text": "o If the file was not opened with OPEN4_SHARE_DENY_WRITE or OPEN4_SHARE_DENY_BOTH, the server SHOULD delete the file's directory entry. However, until last CLOSE of the file, the server MAY continue to allow access to the file via its filehandle.",
      "ja": "ファイルがOPEN4_SHARE_DENY_WRITEまたはOPEN4_SHARE_DENY_BOTHで開かれていない場合は、O、サーバーは、ファイルのディレクトリエントリを削除する必要があります。ただし、ファイルの最後のCLOSEまで、サーバーはそのファイルハンドルを経由してファイルへのアクセスを許可し続けることができます。"
    },
    {
      "indent": 3,
      "text": "o The server MUST NOT delete the directory entry if the reply from OPEN had the flag OPEN4_RESULT_PRESERVE_UNLINKED set.",
      "ja": "OPENからの返信はフラグが設定OPEN4_RESULT_PRESERVE_UNLINKEDていた場合、Oサーバーは、ディレクトリエントリを削除してはなりません。"
    },
    {
      "indent": 3,
      "text": "The server MAY implement its own restrictions on removal of a file while it is open. The server might disallow such a REMOVE (or a removal that occurs as part of RENAME). The conditions that influence the restrictions on removal of a file while it is still open include:",
      "ja": "それが開いている間、サーバーは、ファイルの削除に独自の制限を実施することができます。サーバは、REMOVE（またはRENAMEの一部として発生除去）禁止かもしれません。それはまだ開いている間、ファイルの削除に関する制限に影響を与える条件は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Whether certain access protocols (i.e., not just NFS) are holding the file open.",
      "ja": "特定のアクセスプロトコル（すなわち、だけでなくNFS）が開かれているファイルを保持しているかどうか、O。"
    },
    {
      "indent": 3,
      "text": "o Whether particular options, access modes, or policies on the server are enabled.",
      "ja": "サーバー上の特定のオプション、アクセスモード、またはポリシーが有効になっているかどうか、O。"
    },
    {
      "indent": 3,
      "text": "If a file has an outstanding OPEN and this prevents the removal of the file's directory entry, the error NFS4ERR_FILE_OPEN is returned.",
      "ja": "ファイルは、優れOPENを持っており、これは、ファイルのディレクトリエントリの削除を防止した場合は、エラーNFS4ERR_FILE_OPENが返されます。"
    },
    {
      "indent": 3,
      "text": "Where the determination above cannot be made definitively because delegations are being held, they MUST be recalled to allow processing of the REMOVE to continue. When a delegation is held, the server has no reliable knowledge of the status of OPENs for that client, so unless there are files opened with the particular deny modes by clients without delegations, the determination cannot be made until delegations are recalled, and the operation cannot proceed until each sufficient delegation has been returned or revoked to allow the server to make a correct determination.",
      "ja": "委任が保持されているので、上記判定が決定的に行うことができない場合、それらは、REMOVEの処理を継続できるようにするためにリコールされなければなりません。委任が保持されている場合は代表団ずにクライアントによってモードを拒否し、特定して開かれたファイルがある場合を除き代表団がリコールされるまで、決意を行うことができないので、サーバーは、そのクライアントのためのOPENsのステータスのない信頼性の高い知識を持っていない、と操作それぞれ十分な代表団は、サーバーが正しい決意を行うことができるように返されるか取り消されるまで進めることができません。"
    },
    {
      "indent": 3,
      "text": "In all cases in which delegations are recalled, the server is likely to return one or more NFS4ERR_DELAY errors while delegations remain outstanding.",
      "ja": "代表団がリコールされているすべての場合において、サーバは、代表団は、優れたままで一つ以上のNFS4ERR_DELAYエラーを返す可能性があります。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle designates a directory for which another client holds a directory delegation, then, unless the situation can be resolved by sending a notification, the directory delegation MUST be recalled, and the operation MUST NOT proceed until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.",
      "ja": "現在のファイルハンドルが別のクライアントがディレクトリの委任を保持するためのディレクトリを指定した場合、状況は通知を送信することにより解決することができない限り、その後、ディレクトリの代表団は、リコールされなければならない、と委任を返すか、取り消されるまで操作が続行してはなりません。これは非常に迅速に起こる場合を除いて、一つ以上のNFS4ERR_DELAYエラーが代表団は優れたまま行われる要求に返されます。"
    },
    {
      "indent": 3,
      "text": "When the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_REMOVE_ENTRY will be generated as a result of this operation.",
      "ja": "現在のファイルハンドルは、1つのまたは複数のディレクトリ委任が存在するディレクトリを指定すると、それらの代表は、そのような通知を要求すると、次に、NOTIFY4_REMOVE_ENTRYは、この操作の結果として生成されます。"
    },
    {
      "indent": 3,
      "text": "Note that when a remove occurs as a result of a RENAME, NOTIFY4_REMOVE_ENTRY will only be generated if the removal happens as a separate operation. In the case in which the removal is integrated and atomic with RENAME, the notification of the removal is integrated with notification for the RENAME. See the discussion of the NOTIFY4_RENAME_ENTRY notification in Section 20.4.",
      "ja": "削除は、RENAMEの結果として発生したときに除去が別の操作として発生する場合、NOTIFY4_REMOVE_ENTRYにのみ生成されることに留意されたいです。除去は、統合およびRENAME有する原子である場合には、除去の通知はRENAMEの通知と一体化されています。 20.4項にNOTIFY4_RENAME_ENTRY通知の説明を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.26. Operation 29: RENAME - Rename Directory Entry",
      "section_title": true,
      "ja": "18.26. 操作29：RENAME  - ディレクトリエントリの名前を変更"
    },
    {
      "indent": 0,
      "text": "18.26.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.26.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct RENAME4args {\n        /* SAVED_FH: source directory */\n        component4      oldname;\n        /* CURRENT_FH: target directory */\n        component4      newname;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.26.2. RESULTS",
      "section_title": true,
      "ja": "18.26.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct RENAME4resok {\n        change_info4    source_cinfo;\n        change_info4    target_cinfo;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union RENAME4res switch (nfsstat4 status) {\n case NFS4_OK:\n        RENAME4resok    resok4;\n default:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.26.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.26.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The RENAME operation renames the object identified by oldname in the source directory corresponding to the saved filehandle, as set by the SAVEFH operation, to newname in the target directory corresponding to the current filehandle. The operation is required to be atomic to the client. Source and target directories MUST reside on the same file system on the server. On success, the current filehandle will continue to be the target directory.",
      "ja": "現在のファイルハンドルに対応するターゲットディレクトリにnewnameに、SAVEFH操作によって設定さRENAME操作は、保存されたファイルハンドルに対応するソースディレクトリにOLDNAMEによって識別されたオブジェクトの名前を変更します。操作は、クライアント原子であることが必要です。ソースとターゲットのディレクトリには、サーバー上の同じファイルシステム上に存在する必要があります。成功すると、現在のファイルハンドルは、ターゲットディレクトリであり続けるだろう。"
    },
    {
      "indent": 3,
      "text": "If the target directory already contains an entry with the name newname, the source object MUST be compatible with the target: either both are non-directories or both are directories and the target MUST be empty. If compatible, the existing target is removed before the rename occurs or, preferably, the target is removed atomically as part of the rename. See Section 18.25.4 for client and server actions whenever a target is removed. Note however that when the removal is performed atomically with the rename, certain parts of the removal described there are integrated with the rename. For example, notification of the removal will not be via a NOTIFY4_REMOVE_ENTRY but will be indicated as part of the NOTIFY4_ADD_ENTRY or NOTIFY4_RENAME_ENTRY generated by the rename.",
      "ja": "ターゲットディレクトリが既に名前NEWNAMEのエントリが含まれている場合は、ソースオブジェクトがターゲットと互換性がなければなりません：両方が非ディレクトリであるか、両方のディレクトリであり、ターゲットは空である必要があります。互換性のある場合にリネームが発生した場合、または、好ましくは、対象は、名前変更の一部として、アトミックに除去される前に、既存のターゲットが除去されます。ターゲットが削除されるたびに、クライアントとサーバーの操作については、セクション18.25.4を参照してください。除去はリネームでアトミックに行われた場合、除去の特定の部分が説明リネームと一体化されていることに注意してください。例えば、除去の通知がNOTIFY4_REMOVE_ENTRYを介してではありませんが、名前変更によって生成NOTIFY4_ADD_ENTRY又はNOTIFY4_RENAME_ENTRYの一部として示されます。"
    },
    {
      "indent": 3,
      "text": "If the source object and the target are not compatible or if the target is a directory but not empty, the server will return the error NFS4ERR_EXIST.",
      "ja": "ソースオブジェクトとターゲットに互換性がないか、ターゲットがディレクトリが、空でない場合ならば、サーバはエラーNFS4ERR_EXISTを返します。"
    },
    {
      "indent": 3,
      "text": "If oldname and newname both refer to the same file (e.g., they might be hard links of each other), then unless the file is open (see Section 18.26.4), RENAME MUST perform no action and return NFS4_OK.",
      "ja": "OLDNAMEとnewnameの両方が同じファイルを参照する場合は、ファイルが（セクション18.26.4を参照）が開いている場合を除き、その後、RENAMEは何もアクションを実行しないとNFS4_OKを返さなければならない、（例えば、彼らは互いのハードリンクであるかもしれません）。"
    },
    {
      "indent": 3,
      "text": "For both directories involved in the RENAME, the server returns change_info4 information. With the atomic field of the change_info4 data type, the server will indicate if the before and after change attributes were obtained atomically with respect to the rename.",
      "ja": "RENAMEにかかわる両方のディレクトリの場合、サーバーは変化_info4情報を返します。前と後の変更属性が名前の変更に関して原子論が得られた場合には変化_info4データ型の原子分野、意志が示すサーバ。"
    },
    {
      "indent": 3,
      "text": "If oldname refers to a named attribute and the saved and current filehandles refer to different file system objects, the server will return NFS4ERR_XDEV just as if the saved and current filehandles represented directories on different file systems.",
      "ja": "OLDNAMEという名前の属性を参照し、保存され、現在のファイルハンドルは異なるファイル・システム・オブジェクトを参照する場合、サーバーが保存され、現在のファイルハンドルは異なるファイルシステム上のディレクトリを表すかのようにNFS4ERR_XDEVを返します。"
    },
    {
      "indent": 3,
      "text": "If oldname or newname has a length of zero, or if oldname or newname does not obey the UTF-8 definition, the error NFS4ERR_INVAL will be returned.",
      "ja": "OLDNAMEまたはnewnameの場合はゼロの長さを持っている、またはOLDNAMEまたはnewnameのは、UTF-8定義に従わない場合は、エラーNFS4ERR_INVALが返されます。"
    },
    {
      "indent": 0,
      "text": "18.26.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.26.4. 実装"
    },
    {
      "indent": 3,
      "text": "The server MAY impose restrictions on the RENAME operation such that RENAME may not be done when the file being renamed is open or when that open is done by particular protocols, or with particular options or access modes. Similar restrictions may be applied when a file exists with the target name and is open. When RENAME is rejected because of such restrictions, the error NFS4ERR_FILE_OPEN is returned.",
      "ja": "サーバーは、名前を変更されているファイルが開いているとき、またはそのオープンは特定のプロトコルによって、または特定のオプションまたはアクセス・モードで実行されたときにRENAMEが行われない可能性があることなどRENAME操作に制限を課すことができます。ファイルがターゲット名前で存在し、開かれている場合にも、同様の制限が適用されてもよいです。 RENAMEがあるため、このような制約から拒否された場合、エラーNFS4ERR_FILE_OPENが返されます。"
    },
    {
      "indent": 3,
      "text": "When oldname and rename refer to the same file and that file is open in a fashion such that RENAME would normally be rejected with NFS4ERR_FILE_OPEN if oldname and newname were different files, then RENAME SHOULD be rejected with NFS4ERR_FILE_OPEN.",
      "ja": "OLDNAMEと名前の変更は、同じファイルを参照し、そのファイルがOLDNAMEとnewnameのは、別のファイルであればRENAMEは通常NFS4ERR_FILE_OPENで拒否されるような様式で開いている場合は、その後、NFS4ERR_FILE_OPENで拒絶されるべきで名前を変更します。"
    },
    {
      "indent": 3,
      "text": "If a server does implement such restrictions and those restrictions include cases of NFSv4 opens preventing successful execution of a rename, the server needs to recall any delegations that could hide the existence of opens relevant to that decision. This is because when a client holds a delegation, the server might not have an accurate account of the opens for that client, since the client may execute OPENs and CLOSEs locally. The RENAME operation need only be delayed until a definitive result can be obtained. For example, if there are multiple delegations and one of them establishes an open whose presence would prevent the rename, given the server's semantics, NFS4ERR_FILE_OPEN may be returned to the caller as soon as that delegation is returned without waiting for other delegations to be returned. Similarly, if such opens are not associated with delegations, NFS4ERR_FILE_OPEN can be returned immediately with no delegation recall being done.",
      "ja": "サーバがそのような制限を実装しないと、これらの制限はNFSv4のの例が含まれている場合、名前変更が正常に実行を防止開き、サーバーはその決定に関連開くの存在を隠すことができ任意の委任をリコールする必要があります。クライアントが委任を保持している場合、サーバはクライアントが開きますを実行する可能性があるため、そのクライアントのために開き、ローカルに閉じの正確なアカウントを持っていない可能性があるためです。最終的な結果が得られるまで、RENAME操作のみが遅延する必要があります。そこに複数の代表団があり、そのうちの一つは、サーバーのセマンティクス与えられ、その存在が名前の変更を妨げるオープンを確立した場合、NFS4ERR_FILE_OPENはすぐにその委任が返される他の代表団を待たずに返されると、呼び出し元に戻すことができます。そのようなものが代表団に関連付けられていない開いた場合も同様に、NFS4ERR_FILE_OPENには、委任のリコールが行われていないされていると、すぐに返すことができます。"
    },
    {
      "indent": 3,
      "text": "If the current filehandle or the saved filehandle designates a directory for which another client holds a directory delegation, then, unless the situation can be resolved by sending a notification, the delegation MUST be recalled, and the operation cannot proceed until the delegation is returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while delegation remains outstanding.",
      "ja": "現在のファイルハンドルまたは保存されたファイルハンドルが別のクライアントがディレクトリの委任を保持するためのディレクトリを指定した場合、状況は通知を送信することにより解決することができない限り、その後、代表団は、リコールされなければならない、と委任が返されるまで操作を続行できませんか取り消されました。これは非常に迅速に起こる場合を除いて、一つ以上のNFS4ERR_DELAYエラーが代表団は優れたまま行われる要求に返されます。"
    },
    {
      "indent": 3,
      "text": "When the current and saved filehandles are the same and they designate a directory for which one or more directory delegations exist, then, when those delegations request such notifications, a notification of type NOTIFY4_RENAME_ENTRY will be generated as a result of this operation. When oldname and rename refer to the same file, no notification is generated (because, as Section 18.26.3 states, the server MUST take no action). When a file is removed because it has the same name as the target, if that removal is done atomically with the rename, a NOTIFY4_REMOVE_ENTRY notification will not be generated. Instead, the deletion of the file will be reported as part of the NOTIFY4_RENAME_ENTRY notification.",
      "ja": "現在、保存されたファイルハンドルが同じであり、それらは1つ以上のディレクトリ委任が存在するディレクトリを指定する場合、それらの代表は、そのような通知を要求すると、次に、型NOTIFY4_RENAME_ENTRYの通知は、この操作の結果として生成されます。ときOLDNAMEと同じファイルを参照する名前を変更（セクション18.26.3状態として、サーバは何の行動も取らないしなければならない、ので）、通知は生成されません。その除去は、名前の変更をアトミックに行われている場合には、ターゲットと同じ名前を持っているため、ファイルが削除されると、NOTIFY4_REMOVE_ENTRY通知は生成されません。代わりに、ファイルの削除はNOTIFY4_RENAME_ENTRY通知の一部として報告されます。"
    },
    {
      "indent": 3,
      "text": "When the current and saved filehandles are not the same:",
      "ja": "現在、保存されたファイルハンドルは同じではありません時："
    },
    {
      "indent": 3,
      "text": "o If the current filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_ADD_ENTRY will be generated as a result of this operation. When a file is removed because it has the same name as the target, if that removal is done atomically with the rename, a NOTIFY4_REMOVE_ENTRY notification will not be generated. Instead, the deletion of the file will be reported as part of the NOTIFY4_ADD_ENTRY notification.",
      "ja": "現在のファイルハンドルは、1つのまたは複数のディレクトリ委任が存在するディレクトリを指定した場合、それらの代表は、そのような通知を要求したとき、O、次いで、NOTIFY4_ADD_ENTRYは、この操作の結果として生成されます。その除去は、名前の変更をアトミックに行われている場合には、ターゲットと同じ名前を持っているため、ファイルが削除されると、NOTIFY4_REMOVE_ENTRY通知は生成されません。代わりに、ファイルの削除はNOTIFY4_ADD_ENTRY通知の一部として報告されます。"
    },
    {
      "indent": 3,
      "text": "o If the saved filehandle designates a directory for which one or more directory delegations exist, then, when those delegations request such notifications, NOTIFY4_REMOVE_ENTRY will be generated as a result of this operation.",
      "ja": "保存されたファイルハンドルは、1つのまたは複数のディレクトリ委任が存在するディレクトリを指定した場合、それらの代表は、そのような通知を要求したとき、O、次いで、NOTIFY4_REMOVE_ENTRYは、この操作の結果として生成されます。"
    },
    {
      "indent": 3,
      "text": "If the object being renamed has file delegations held by clients other than the one doing the RENAME, the delegations MUST be recalled, and the operation cannot proceed until each such delegation is returned or revoked. Note that in the case of multiply linked files, the delegation recall requirement applies even if the delegation was obtained through a different name than the one being renamed. In all cases in which delegations are recalled, the server is likely to return one or more NFS4ERR_DELAY errors while the delegation(s) remains outstanding, although it might not do that if the delegations are returned quickly.",
      "ja": "名前を変更されているオブジェクトは、RENAMEをやって1以外のクライアントが保持しているファイルの委任を持っている場合は、代表団はリコールされなければならない、このような各代表団が返されるか取り消されるまで操作を続行できません。複数のリンクファイルの場合には、委任リコール要件は、委任の名前が変更されているものとは別の名前を介して取得された場合にも適用されることに注意してください。代表団がリコールされているすべての場合において、サーバは、委任（s）は、優れたまま、それは代表団がすぐに返される場合があることを行うではないかもしれないが、一つ以上のNFS4ERR_DELAYエラーを返す可能性があります。"
    },
    {
      "indent": 3,
      "text": "The RENAME operation must be atomic to the client. The statement \"source and target directories MUST reside on the same file system on the server\" means that the fsid fields in the attributes for the directories are the same. If they reside on different file systems, the error NFS4ERR_XDEV is returned.",
      "ja": "RENAME操作はクライアントにアトミックでなければなりません。声明「ソースとターゲットのディレクトリサーバー上の同じファイルシステム上に存在する必要があり、」ディレクトリの属性におけるFSIDフィールドが同じであることを意味します。彼らは異なるファイルシステム上に存在する場合は、エラーNFS4ERR_XDEVが返されます。"
    },
    {
      "indent": 3,
      "text": "Based on the value of the fh_expire_type attribute for the object, the filehandle may or may not expire on a RENAME. However, server implementors are strongly encouraged to attempt to keep filehandles from expiring in this fashion.",
      "ja": "オブジェクトのfh_expire_type属性の値に基づいて、ファイルハンドルは、名前の変更には有効期限が切れていない場合があります。ただし、サーバーの実装は強く、この方法で期限切れからファイルハンドルを維持しようとすることが奨励されています。"
    },
    {
      "indent": 3,
      "text": "On some servers, the file names \".\" and \"..\" are illegal as either oldname or newname, and will result in the error NFS4ERR_BADNAME. In addition, on many servers the case of oldname or newname being an alias for the source directory will be checked for. Such servers will return the error NFS4ERR_INVAL in these cases.",
      "ja": "一部のサーバでは、ファイル名「」そして、「..」OLDNAMEかnewnameのいずれかとして違法であり、エラーNFS4ERR_BADNAMEになります。また、多くのサーバ上OLDNAMEまたはnewnameのソースディレクトリの別名であることの場合は、チェックされます。このようなサーバは、これらの場合にエラーNFS4ERR_INVALを返します。"
    },
    {
      "indent": 3,
      "text": "If either of the source or target filehandles are not directories, the server will return NFS4ERR_NOTDIR.",
      "ja": "ソースまたはターゲットファイルハンドルのいずれかがディレクトリでない場合、サーバはNFS4ERR_NOTDIRを返します。"
    },
    {
      "indent": 0,
      "text": "18.27. Operation 31: RESTOREFH - Restore Saved Filehandle",
      "section_title": true,
      "ja": "18.27. 操作31：RESTOREFH  - 保存されたファイルハンドルを復元"
    },
    {
      "indent": 0,
      "text": "18.27.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.27.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "/* SAVED_FH: */\nvoid;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.27.2. RESULTS",
      "section_title": true,
      "ja": "18.27.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct RESTOREFH4res {\n        /*\n         * If status is NFS4_OK,\n         *     new CURRENT_FH: value of saved fh\n         */\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.27.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.27.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The RESTOREFH operation sets the current filehandle and stateid to the values in the saved filehandle and stateid. If there is no saved filehandle, then the server will return the error NFS4ERR_NOFILEHANDLE.",
      "ja": "RESTOREFH動作は保存ファイルハンドルとのstateidの値に現在のファイルハンドルとのstateidを設定します。何も保存されたファイルハンドルが存在しない場合、サーバーはエラーNFS4ERR_NOFILEHANDLEを返します。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.1 for more details on the current filehandle.",
      "ja": "現在のファイルハンドルの詳細については、セクション16.2.3.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.2 for more details on the current stateid.",
      "ja": "現在のstateidの詳細については、セクション16.2.3.1.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.27.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.27.4. 実装"
    },
    {
      "indent": 3,
      "text": "Operations like OPEN and LOOKUP use the current filehandle to represent a directory and replace it with a new filehandle. Assuming that the previous filehandle was saved with a SAVEFH operator, the previous filehandle can be restored as the current filehandle. This is commonly used to obtain post-operation attributes for the directory, e.g.,",
      "ja": "OPENとLOOKUPのような操作は、ディレクトリを表し、新しいファイルハンドルでそれを置き換えるために、現在のファイルハンドルを使用します。以前のファイルハンドルをSAVEFHオペレータで保存されたと仮定すると、以前のファイルハンドルは、現在のファイルハンドルとして復元することができます。これは、一般的に、術後は、例えば、ディレクトリの属性を取得するために使用されます"
    },
    {
      "indent": 9,
      "text": "PUTFH (directory filehandle)\nSAVEFH\nGETATTR attrbits     (pre-op dir attrs)\nCREATE optbits \"foo\" attrs\nGETATTR attrbits     (file attributes)\nRESTOREFH\nGETATTR attrbits     (post-op dir attrs)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.28. Operation 32: SAVEFH - Save Current Filehandle",
      "section_title": true,
      "ja": "18.28. 操作32：SAVEFH  - 保存現在のファイルハンドル"
    },
    {
      "indent": 0,
      "text": "18.28.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.28.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "/* CURRENT_FH: */\nvoid;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.28.2. RESULTS",
      "section_title": true,
      "ja": "18.28.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct SAVEFH4res {\n        /*\n         * If status is NFS4_OK,\n         *    new SAVED_FH: value of current fh\n         */\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.28.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.28.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The SAVEFH operation saves the current filehandle and stateid. If a previous filehandle was saved, then it is no longer accessible. The saved filehandle can be restored as the current filehandle with the RESTOREFH operator.",
      "ja": "SAVEFH操作は、現在のファイルハンドルとのstateidが保存されます。以前のファイルハンドルを保存した場合、それはアクセスできなくなります。保存されたファイルハンドルはRESTOREFH演算子で、現在のファイルハンドルとして復元することができます。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.1 for more details on the current filehandle.",
      "ja": "現在のファイルハンドルの詳細については、セクション16.2.3.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Section 16.2.3.1.2 for more details on the current stateid.",
      "ja": "現在のstateidの詳細については、セクション16.2.3.1.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.28.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.28.4. 実装"
    },
    {
      "indent": 0,
      "text": "18.29. Operation 33: SECINFO - Obtain Available Security",
      "section_title": true,
      "ja": "18.29. 操作33：SECINFO  - 利用可能なセキュリティを取得"
    },
    {
      "indent": 0,
      "text": "18.29.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.29.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct SECINFO4args {\n        /* CURRENT_FH: directory */\n        component4      name;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.29.2. RESULTS",
      "section_title": true,
      "ja": "18.29.2. 結果"
    },
    {
      "indent": 3,
      "text": "/*\n * From RFC 2203\n */\nenum rpc_gss_svc_t {\n        RPC_GSS_SVC_NONE        = 1,\n        RPC_GSS_SVC_INTEGRITY   = 2,\n        RPC_GSS_SVC_PRIVACY     = 3\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct rpcsec_gss_info {\n        sec_oid4        oid;\n        qop4            qop;\n        rpc_gss_svc_t   service;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* RPCSEC_GSS has a value of '6' - See RFC 2203 */\nunion secinfo4 switch (uint32_t flavor) {\n case RPCSEC_GSS:\n         rpcsec_gss_info        flavor_info;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "typedef secinfo4 SECINFO4resok<>;",
      "ja": "typedefのsecinfo4 SECINFO4resok <>。"
    },
    {
      "indent": 3,
      "text": "union SECINFO4res switch (nfsstat4 status) {\n case NFS4_OK:\n        /* CURRENTFH: consumed */\n         SECINFO4resok resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.29.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.29.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The SECINFO operation is used by the client to obtain a list of valid RPC authentication flavors for a specific directory filehandle, file name pair. SECINFO should apply the same access methodology used for LOOKUP when evaluating the name. Therefore, if the requester does not have the appropriate access to LOOKUP the name, then SECINFO MUST behave the same way and return NFS4ERR_ACCESS.",
      "ja": "SECINFO操作は特定のディレクトリのファイルハンドル、ファイル名のペアのための有効なRPC認証フレーバのリストを取得するために、クライアントによって使用されます。名前を評価するときSECINFOは、LOOKUPのために使用したのと同じアクセス方法論を適用する必要があります。要求者が名前を検索するための適切なアクセス権を持っていない場合、したがって、その後、SECINFOは同じように動作し、NFS4ERR_ACCESSを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The result will contain an array that represents the security mechanisms available, with an order corresponding to the server's preferences, the most preferred being first in the array. The client is free to pick whatever security mechanism it both desires and supports, or to pick in the server's preference order the first one it supports. The array entries are represented by the secinfo4 structure. The field 'flavor' will contain a value of AUTH_NONE, AUTH_SYS (as defined in RFC 5531 [3]), or RPCSEC_GSS (as defined in RFC 2203 [4]). The field flavor can also be any other security flavor registered with IANA.",
      "ja": "結果が最も好ましいが、アレイ内の最初であり、サーバの好みに対応する順序で、セキュリティメカニズムが利用可能で表す配列を含むであろう。クライアントは、どのようなセキュリティメカニズム、それの両方の欲望とサポートを選択するか、サーバーの優先順位、それがサポートする最初のものに選択する自由です。アレイエントリはsecinfo4構造によって表されます。フィールド '風味'（[4] RFC 2203で定義されている）（RFC 5531で定義されている[3]）AUTH_NONE、AUTH_SYSの値を含む、またはRPCSEC_GSSう。フィールドの風味もIANAに登録された他のセキュリティ味することができます。"
    },
    {
      "indent": 3,
      "text": "For the flavors AUTH_NONE and AUTH_SYS, no additional security information is returned. The same is true of many (if not most) other security flavors, including AUTH_DH. For a return value of RPCSEC_GSS, a security triple is returned that contains the mechanism object identifier (OID, as defined in RFC 2743 [7]), the quality of protection (as defined in RFC 2743 [7]), and the service type (as defined in RFC 2203 [4]). It is possible for SECINFO to return multiple entries with flavor equal to RPCSEC_GSS with different security triple values.",
      "ja": "味AUTH_NONEおよびAUTH_SYSの場合は、追加のセキュリティ情報が返されません。同じことはAUTH_DHを含む多くの（ないほとんどの場合）他のセキュリティ風味の真実です。 RPCSEC_GSSの戻り値を、三重セキュリティは機構オブジェクト識別子（OID、RFC 2743で定義されるように[7]）、保護の品質（RFC 2743で定義されている[7]）、およびサービスタイプが含まれて戻されます（RFC 2203で定義されている[4]）。 SECINFOが異なるセキュリティトリプル値のRPCSEC_GSSと等しい味で複数のエントリを返すことが可能です。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle is consumed (see Section 2.6.3.1.1.8), and if the next operation after SECINFO tries to use the current filehandle, that operation will fail with the status NFS4ERR_NOFILEHANDLE.",
      "ja": "成功すると、現在のファイルハンドルは、（セクション2.6.3.1.1.8を参照）が消費され、そしてSECINFO後、次の操作は、現在のファイルハンドルを使用しようとした場合、その操作は、ステータスNFS4ERR_NOFILEHANDLEで失敗します。"
    },
    {
      "indent": 3,
      "text": "If the name has a length of zero, or if the name does not obey the UTF-8 definition (assuming UTF-8 capabilities are enabled; see Section 14.4), the error NFS4ERR_INVAL will be returned.",
      "ja": "名前がゼロの長さを有し、または名前がUTF-8定義に従わない場合には（UTF-8の機能が有効になっていると仮定すると、14.4節を参照）した場合、エラーNFS4ERR_INVALが返されます。"
    },
    {
      "indent": 3,
      "text": "See Section 2.6 for additional information on the use of SECINFO.",
      "ja": "SECINFOの使用に関する追加情報については、2.6節を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.29.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.29.4. 実装"
    },
    {
      "indent": 3,
      "text": "The SECINFO operation is expected to be used by the NFS client when the error value of NFS4ERR_WRONGSEC is returned from another NFS operation. This signifies to the client that the server's security policy is different from what the client is currently using. At this point, the client is expected to obtain a list of possible security flavors and choose what best suits its policies.",
      "ja": "SECINFO操作はNFS4ERR_WRONGSECのエラー値が別のNFS操作から返されたNFSクライアントによって使用されることが期待されます。これは、サーバーのセキュリティポリシーは、クライアントが現在使用しているものと異なっていることをクライアントに示します。この時点で、クライアントが可能なセキュリティ風味のリストを取得し、最高のは、そのポリシーに合ったものを選択することが期待されています。"
    },
    {
      "indent": 3,
      "text": "As mentioned, the server's security policies will determine when a client request receives NFS4ERR_WRONGSEC. See Table 8 for a list of operations that can return NFS4ERR_WRONGSEC. In addition, when READDIR returns attributes, the rdattr_error (Section 5.8.1.12) can contain NFS4ERR_WRONGSEC. Note that CREATE and REMOVE MUST NOT return NFS4ERR_WRONGSEC. The rationale for CREATE is that unless the target name exists, it cannot have a separate security policy from the parent directory, and the security policy of the parent was checked when its filehandle was injected into the COMPOUND request's operations stream (for similar reasons, an OPEN operation that creates the target MUST NOT return NFS4ERR_WRONGSEC). If the target name exists, while it might have a separate security policy, that is irrelevant because CREATE MUST return NFS4ERR_EXIST. The rationale for REMOVE is that while that target might have a separate security policy, the target is going to be removed, and so the security policy of the parent trumps that of the object being removed. RENAME and LINK MAY return NFS4ERR_WRONGSEC, but the NFS4ERR_WRONGSEC error applies only to the saved filehandle (see Section 2.6.3.1.2). Any NFS4ERR_WRONGSEC error on the current filehandle used by LINK and RENAME MUST be returned by the PUTFH, PUTPUBFH, PUTROOTFH, or RESTOREFH operation that injected the current filehandle.",
      "ja": "前述のように、クライアントの要求がNFS4ERR_WRONGSECを受信したときに、サーバーのセキュリティポリシーが決定されます。 NFS4ERR_WRONGSECを返すことができる操作のリストについては、表8を参照してください。 READDIRが属性を返すときに加えて、rdattr_error（セクション5.8.1.12）はNFS4ERR_WRONGSECを含めることができます。 CREATEおよびREMOVE注意NFS4ERR_WRONGSECを返してはなりません。 CREATEの理論的根拠は、ターゲット名が存在しない限り、それは親ディレクトリとは別のセキュリティポリシーを持つことができないということであり、そのファイルハンドルが複合要求の業務の流れの中に注入したときの親のセキュリティポリシーは、同様の理由（チェックされました、ターゲットを作成するOPEN操作）NFS4ERR_WRONGSECを返してはなりません。それは別のセキュリティポリシーを持っているかもしれないが、ターゲット名が、存在する場合は、CREATEはNFS4ERR_EXISTを返さなければならないので、それは関係ありません。 REMOVEの理論的根拠は、そのターゲットは、個別のセキュリティポリシーを持っているかもしれないが、ターゲットが削除されようとしている、とその親のセキュリティポリシーは、オブジェクトの削除されていることを切り札ということです。名前を変更し、LINKがNFS4ERR_WRONGSECを返してもよいが、NFS4ERR_WRONGSECエラーのみ保存されたファイルハンドルに適用されます（セクション2.6.3.1.2を参照）。 LINKとRENAMEによって使用される現在のファイルハンドル上の任意NFS4ERR_WRONGSECエラーは、現在のファイルハンドルを注入PUTFH、PUTPUBFH、PUTROOTFH、又はRESTOREFH操作によって返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "With the exception of LINK and RENAME, the set of operations that can return NFS4ERR_WRONGSEC represents the point at which the client can inject a filehandle into the \"current filehandle\" at the server. The filehandle is either provided by the client (PUTFH, PUTPUBFH, PUTROOTFH), generated as a result of a name-to-filehandle translation (LOOKUP and OPEN), or generated from the saved filehandle via RESTOREFH. As Section 2.6.3.1.1.1 states, a put filehandle operation followed by SAVEFH MUST NOT return NFS4ERR_WRONGSEC. Thus, the RESTOREFH operation, under certain conditions (see Section 2.6.3.1.1), is permitted to return NFS4ERR_WRONGSEC so that security policies can be honored.",
      "ja": "LINKとRENAMEを除いて、NFS4ERR_WRONGSECを返すことができる操作のセットは、クライアントがサーバに「現在のファイルハンドル」にファイルハンドルを注入することができる点を表します。ファイルハンドルは、名前からファイルハンドル翻訳（LOOKUPとOPEN）の結果として生成されたクライアント（PUTFH、PUTPUBFH、PUTROOTFH）、が提供する、またはRESTOREFH経由で保存されたファイルハンドルから生成されますか。第2.6.3.1.1.1状態として、SAVEFH続い置くファイルハンドル操作がNFS4ERR_WRONGSECを返してはなりません。このように、RESTOREFH操作は、一定の条件（セクション2.6.3.1.1を参照）の下で、セキュリティポリシーを光栄にすることができるようにNFS4ERR_WRONGSECを返すことが許可されています。"
    },
    {
      "indent": 3,
      "text": "The READDIR operation will not directly return the NFS4ERR_WRONGSEC error. However, if the READDIR request included a request for attributes, it is possible that the READDIR request's security triple did not match that of a directory entry. If this is the case and the client has requested the rdattr_error attribute, the server will return the NFS4ERR_WRONGSEC error in rdattr_error for the entry.",
      "ja": "READDIR操作は直接NFS4ERR_WRONGSECエラーを返しません。 READDIR要求が属性を要求が含まれている場合しかし、READDIR要求のセキュリティはトリプルディレクトリエントリのものと一致していない可能性があります。このような場合は、クライアントがrdattr_error属性を要求した場合、サーバはエントリのrdattr_errorにNFS4ERR_WRONGSECエラーを返します。"
    },
    {
      "indent": 3,
      "text": "To resolve an error return of NFS4ERR_WRONGSEC, the client does the following: o For LOOKUP and OPEN, the client will use SECINFO with the same current filehandle and name as provided in the original LOOKUP or OPEN to enumerate the available security triples.",
      "ja": "NFS4ERR_WRONGSECのエラーリターンを解決するには、クライアントは次の処理を行います。元LOOKUPまたはOPENで提供されるLOOKUPとOPENのためにO、クライアントが利用可能なセキュリティトリプルを列挙するために同じ電流ファイルハンドルと名前をSECINFOを使用します。"
    },
    {
      "indent": 3,
      "text": "o For the rdattr_error, the client will use SECINFO with the same current filehandle as provided in the original READDIR. The name passed to SECINFO will be that of the directory entry (as returned from READDIR) that had the NFS4ERR_WRONGSEC error in the rdattr_error attribute.",
      "ja": "元READDIRで提供されるO rdattr_errorのために、クライアントは同じ電流ファイルハンドルでSECINFOを使用します。 SECINFOに渡された名前はrdattr_error属性にNFS4ERR_WRONGSECのエラーが発生しました（READDIRから返される）ディレクトリエントリのものになります。"
    },
    {
      "indent": 3,
      "text": "o For PUTFH, PUTROOTFH, PUTPUBFH, RESTOREFH, LINK, and RENAME, the client will use SECINFO_NO_NAME { style = SECINFO_STYLE4_CURRENT_FH }. The client will prefix the SECINFO_NO_NAME operation with the appropriate PUTFH, PUTPUBFH, or PUTROOTFH operation that provides the filehandle originally provided by the PUTFH, PUTPUBFH, PUTROOTFH, or RESTOREFH operation.",
      "ja": "O PUTFH、PUTROOTFH、PUTPUBFH、RESTOREFH、LINK、名前の変更のために、クライアントはSECINFO_NO_NAME {スタイル= SECINFO_STYLE4_CURRENT_FH}を使用します。クライアントは、もともとPUTFH、PUTPUBFH、PUTROOTFH、またはRESTOREFH操作により提供されるファイルハンドルを提供し、適切なPUTFH、PUTPUBFH、またはPUTROOTFH操作でSECINFO_NO_NAME操作の前に付けます。"
    },
    {
      "indent": 6,
      "text": "NOTE: In NFSv4.0, the client was required to use SECINFO, and had to reconstruct the parent of the original filehandle and the component name of the original filehandle. The introduction in NFSv4.1 of SECINFO_NO_NAME obviates the need for reconstruction.",
      "ja": "注：NFSv4.0では、クライアントがSECINFOを使用するために必要な、そしてオリジナルのファイルハンドルと、元のファイルハンドルのコンポーネント名の親を再構築しなければなりませんでした。 SECINFO_NO_NAMEのNFSv4.1での導入は、復興のための必要性を取り除きます。"
    },
    {
      "indent": 3,
      "text": "o For LOOKUPP, the client will use SECINFO_NO_NAME { style = SECINFO_STYLE4_PARENT } and provide the filehandle that equals the filehandle originally provided to LOOKUPP.",
      "ja": "O LOOKUPPために、クライアントはSECINFO_NO_NAME {スタイル= SECINFO_STYLE4_PARENT}を使用して、元々LOOKUPPに提供ファイルハンドルに等しいファイルハンドルを提供します。"
    },
    {
      "indent": 3,
      "text": "See Section 21 for a discussion on the recommendations for the security flavor used by SECINFO and SECINFO_NO_NAME.",
      "ja": "SECINFOとSECINFO_NO_NAMEで使用されるセキュリティ風味のための提言についての議論のための第21を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.30. Operation 34: SETATTR - Set Attributes",
      "section_title": true,
      "ja": "18.30. 操作34：SETATTR  - 属性セット"
    },
    {
      "indent": 0,
      "text": "18.30.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.30.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct SETATTR4args {\n        /* CURRENT_FH: target object */\n        stateid4        stateid;\n        fattr4          obj_attributes;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.30.2. RESULTS",
      "section_title": true,
      "ja": "18.30.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct SETATTR4res {\n        nfsstat4        status;\n        bitmap4         attrsset;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.30.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.30.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The SETATTR operation changes one or more of the attributes of a file system object. The new attributes are specified with a bitmap and the attributes that follow the bitmap in bit order.",
      "ja": "SETATTR操作は、ファイル・システム・オブジェクトの属性の一つ以上を変更します。新しい属性は、ビットマップとビット順にビットマップに従った属性で指定されています。"
    },
    {
      "indent": 3,
      "text": "The stateid argument for SETATTR is used to provide byte-range locking context that is necessary for SETATTR requests that set the size attribute. Since setting the size attribute modifies the file's data, it has the same locking requirements as a corresponding WRITE. Any SETATTR that sets the size attribute is incompatible with a share reservation that specifies OPEN4_SHARE_DENY_WRITE. The area between the old end-of-file and the new end-of-file is considered to be modified just as would have been the case had the area in question been specified as the target of WRITE, for the purpose of checking conflicts with byte-range locks, for those cases in which a server is implementing mandatory byte-range locking behavior. A valid stateid SHOULD always be specified. When the file size attribute is not set, the special stateid consisting of all bits equal to zero MAY be passed.",
      "ja": "SETATTRのためのstateid引数は、サイズ属性を設定するSETATTR要求するために必要なバイト範囲ロックのコンテキストを提供するために使用されます。サイズ属性を設定すると、ファイルのデータを変更するので、それは、対応するWRITEと同じロッキング要件があります。サイズ属性を設定し、任意のSETATTRはOPEN4_SHARE_DENY_WRITEを指定シェア予約と互換性がありません。問題の領域はWRITEの対象として指定されていた場合であったであろうと、古いファイルの終わりと新しいファイルの終端との間の領域は、との衝突をチェックする目的のために、単に変更されていると考えられますサーバは必須バイト範囲ロック動作を実現しているような場合のためにバイト範囲ロック、。有効なstateidは必ず指定する必要があります。ファイルサイズ属性が設定されていない場合、ゼロに等しいすべてのビットからなる特別のstateidを渡すことができます。"
    },
    {
      "indent": 3,
      "text": "On either success or failure of the operation, the server will return the attrsset bitmask to represent what (if any) attributes were successfully set. The attrsset in the response is a subset of the attrmask field of the obj_attributes field in the argument.",
      "ja": "操作の成功または失敗のいずれかで、サーバーは、属性設定に成功した（もしあれば）何を表現するためにattrssetビットマスクを返します。応答attrssetは、引数でobj_属性フィールドのattrmaskフィールドのサブセットです。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.30.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.30.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the request specifies the owner attribute to be set, the server SHOULD allow the operation to succeed if the current owner of the object matches the value specified in the request. Some servers may be implemented in a way as to prohibit the setting of the owner attribute unless the requester has privilege to do so. If the server is lenient in this one case of matching owner values, the client implementation may be simplified in cases of creation of an object (e.g., an exclusive create via OPEN) followed by a SETATTR.",
      "ja": "要求を設定する所有者属性を指定している場合、サーバーはオブジェクトの現在の所有者がリクエストで指定された値と一致した場合、操作が成功できるようにする必要があります。一部のサーバーは、要求者がそうする権限を持っていない限り、所有者属性の設定を禁止するような方法で実現することができます。サーバが一致する所有者値のこの一つの場合に寛大である場合、クライアントの実装はSETATTR続くオブジェクト（例えば、排他的ではOPENを介して作成）の作成の場合に簡素化することができます。"
    },
    {
      "indent": 3,
      "text": "The file size attribute is used to request changes to the size of a file. A value of zero causes the file to be truncated, a value less than the current size of the file causes data from new size to the end of the file to be discarded, and a size greater than the current size of the file causes logically zeroed data bytes to be added to the end of the file. Servers are free to implement this using unallocated bytes (holes) or allocated data bytes set to zero. Clients should not make any assumptions regarding a server's implementation of this feature, beyond that the bytes in the affected byte-range returned by READ will be zeroed. Servers MUST support extending the file size via SETATTR.",
      "ja": "ファイルサイズ属性は、ファイルのサイズの変更を要求するために使用されます。ゼロの値は、ファイルがファイルの現在のサイズより小さい値を廃棄するファイルの末尾に新たなサイズのデータ​​を生じ、切り捨て、およびファイルの現在のサイズよりも大きいサイズを論理的にゼロ化させるさせますデータファイルの末尾に追加されるバイト。サーバは、ゼロに設定され、この使用して未割り当てのバイト（ホール）または割り当てられたデータ・バイトを実装して自由です。クライアントは、READから返された影響を受けたバイト範囲内のバイトがゼロにされることを超えて、この機能のサーバの実装に関するいかなる仮定を行うべきではありません。サーバはSETATTRを経由してファイルサイズを拡張しサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "SETATTR is not guaranteed to be atomic. A failed SETATTR may partially change a file's attributes, hence the reason why the reply always includes the status and the list of attributes that were set.",
      "ja": "SETATTRは原子であることが保証されていません。失敗したSETATTRは、部分的にので、返事はいつもの状態と設定された属性のリストが含まれている理由、ファイルの属性を変更することがあります。"
    },
    {
      "indent": 3,
      "text": "If the object whose attributes are being changed has a file delegation that is held by a client other than the one doing the SETATTR, the delegation(s) must be recalled, and the operation cannot proceed to actually change an attribute until each such delegation is returned or revoked. In all cases in which delegations are recalled, the server is likely to return one or more NFS4ERR_DELAY errors while the delegation(s) remains outstanding, although it might not do that if the delegations are returned quickly.",
      "ja": "属性が変更されているオブジェクトがSETATTRをやっ以外のクライアントによって保持されているファイルの委任がある場合は、代表団（S）がリコールされている必要があり、このような各代表団があるまで、操作は、実際の属性を変更するために進むことができません返却または取り消します。代表団がリコールされているすべての場合において、サーバは、委任（s）は、優れたまま、それは代表団がすぐに返される場合があることを行うではないかもしれないが、一つ以上のNFS4ERR_DELAYエラーを返す可能性があります。"
    },
    {
      "indent": 3,
      "text": "If the object whose attributes are being set is a directory and another client holds a directory delegation for that directory, then if enabled, asynchronous notifications will be generated when the set of attributes changed has a non-null intersection with the set of attributes for which notification is requested. Notifications of type NOTIFY4_CHANGE_DIR_ATTRS will be sent to the appropriate client(s), but the SETATTR is not delayed by waiting for these notifications to be sent.",
      "ja": "属性が設定されているオブジェクトがディレクトリであり、他のクライアントが有効になっている場合、属性のセットが変更されたとき、その後、非同期通知が生成されます、そのディレクトリのディレクトリの委任を、保持している場合は一連の属性を持つnull以外の交差点を有しているため通知が要求されています。型NOTIFY4_CHANGE_DIR_ATTRSの通知は適切なクライアント（複数可）に送信されますが、SETATTRは、これらの通知が送信されるのを待つによって遅延されていません。"
    },
    {
      "indent": 3,
      "text": "If the object whose attributes are being set is a member of the directory for which another client holds a directory delegation, then asynchronous notifications will be generated when the set of attributes changed has a non-null intersection with the set of attributes for which notification is requested. Notifications of type NOTIFY4_CHANGE_CHILD_ATTRS will be sent to the appropriate clients, but the SETATTR is not delayed by waiting for these notifications to be sent.",
      "ja": "属性が設定されているオブジェクトは、別のクライアントがディレクトリの委任を保持している属性のセットが通知された一連の属性を持つnull以外の交差点を持って変更する場合は、非同期通知が生成されるディレクトリのメンバーである場合要求されました。型NOTIFY4_CHANGE_CHILD_ATTRSの通知は、適切なクライアントに送信されますが、SETATTRは、これらの通知が送信されるのを待つによって遅延されていません。"
    },
    {
      "indent": 3,
      "text": "Changing the size of a file with SETATTR indirectly changes the time_modify and change attributes. A client must account for this as size changes can result in data deletion.",
      "ja": "SETATTRとファイルのサイズを変更すると、間接的にtime_modifyと変更属性を変更します。サイズの変更は、データの削除につながることができますように、クライアントは、このことを考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The attributes time_access_set and time_modify_set are write-only attributes constructed as a switched union so the client can direct the server in setting the time values. If the switched union specifies SET_TO_CLIENT_TIME4, the client has provided an nfstime4 to be used for the operation. If the switch union does not specify SET_TO_CLIENT_TIME4, the server is to use its current time for the SETATTR operation.",
      "ja": "属性time_access_setとtime_modify_setは、クライアントが時間値を設定することで、サーバーに指示することができるように切り替え組合として構成書き込み専用属性です。切り替え組合がSET_TO_CLIENT_TIME4を指定した場合、クライアントは、操作に使用するnfstime4を提供してきました。スイッチ組合がSET_TO_CLIENT_TIME4を指定しない場合、サーバはSETATTR操作のために、現在の時刻を使用することです。"
    },
    {
      "indent": 3,
      "text": "If server and client times differ, programs that compare client time to file times can break. A time synchronization protocol should be used to limit client/server time skew.",
      "ja": "サーバーとクライアントの時間が異なる場合は、時間をファイルにクライアントの時間を比較するプログラムが壊れることができます。時刻同期プロトコルは、クライアント/サーバ時間スキューを制限するために使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Use of a COMPOUND containing a VERIFY operation specifying only the change attribute, immediately followed by a SETATTR, provides a means whereby a client may specify a request that emulates the functionality of the SETATTR guard mechanism of NFSv3. Since the function of the guard mechanism is to avoid changes to the file attributes based on stale information, delays between checking of the guard condition and the setting of the attributes have the potential to compromise this function, as would the corresponding delay in the NFSv4 emulation. Therefore, NFSv4.1 servers SHOULD take care to avoid such delays, to the degree possible, when executing such a request.",
      "ja": "すぐにSETATTRが続くだけ変化属性を指定して検証動作を含む化合物の使用は、クライアントがNFSv3ののSETATTRガード機構の機能をエミュレート要求を指定するおそれが手段を提供します。ガード機構の機能は古い情報に基づいてファイルの属性への変更を回避することであるので同じように、ガード条件の確認と属性の設定間の遅延は、この機能を妥協する可能性を秘めているNFSv4のエミュレーションで対応する遅延。したがって、NFSv4.1サーバは、そのような要求を実行する際に、可能な程度まで、このような遅延を避けるために世話をする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the server does not support an attribute as requested by the client, the server SHOULD return NFS4ERR_ATTRNOTSUPP.",
      "ja": "クライアントによって要求されるように、サーバが属性をサポートしていない場合、サーバーはNFS4ERR_ATTRNOTSUPPを返すべきです。"
    },
    {
      "indent": 3,
      "text": "A mask of the attributes actually set is returned by SETATTR in all cases. That mask MUST NOT include attribute bits not requested to be set by the client. If the attribute masks in the request and reply are equal, the status field in the reply MUST be NFS4_OK.",
      "ja": "実際に設定された属性のマスクは、すべての場合にSETATTRによって返されます。そのマスクは、クライアントによって設定されるように要求していない属性ビットを含んではいけません。要求と応答の属性マスクが等しい場合、応答のステータス・フィールドはNFS4_OKでなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.31. Operation 37: VERIFY - Verify Same Attributes",
      "section_title": true,
      "ja": "18.31. 操作37：VERIFY  - 同じ属性を確認してください"
    },
    {
      "indent": 0,
      "text": "18.31.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.31.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "struct VERIFY4args {\n        /* CURRENT_FH: object */\n        fattr4          obj_attributes;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.31.2. RESULTS",
      "section_title": true,
      "ja": "18.31.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct VERIFY4res {\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.31.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.31.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The VERIFY operation is used to verify that attributes have the value assumed by the client before proceeding with the following operations in the COMPOUND request. If any of the attributes do not match, then the error NFS4ERR_NOT_SAME must be returned. The current filehandle retains its value after successful completion of the operation.",
      "ja": "ベリファイ動作は、属性が複合要求で、次の操作に進む前に、クライアントによって値を想定していることを確認するために使用されます。属性のいずれかが一致しない場合、エラーNFS4ERR_NOT_SAMEを返さなければなりません。現在のファイルハンドルは、操作が正常に完了した後にその値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.31.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.31.4. 実装"
    },
    {
      "indent": 3,
      "text": "One possible use of the VERIFY operation is the following series of operations. With this, the client is attempting to verify that the file being removed will match what the client expects to be removed. This series can help prevent the unintended deletion of a file.",
      "ja": "ベリファイ動作の一つの可能​​な用途は次の一連の動作です。これにより、クライアントが削除されたファイルは、クライアントが削除されることを想定しているものと一致することを検証しようとしています。このシリーズでは、ファイルの意図しない削除を防ぐことができます。"
    },
    {
      "indent": 9,
      "text": "PUTFH (directory filehandle)\nLOOKUP (file name)\nVERIFY (filehandle == fh)\nPUTFH (directory filehandle)\nREMOVE (file name)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This series does not prevent a second client from removing and creating a new file in the middle of this sequence, but it does help avoid the unintended result.",
      "ja": "このシリーズは、このシーケンスの途中で新しいファイルを削除し、作成から2番目のクライアントを防ぐことはできませんが、それは予期しない結果を回避するのに役立つん。"
    },
    {
      "indent": 3,
      "text": "In the case that a RECOMMENDED attribute is specified in the VERIFY operation and the server does not support that attribute for the file system object, the error NFS4ERR_ATTRNOTSUPP is returned to the client.",
      "ja": "推奨属性がVERIFY操作で指定され、サーバがファイル・システム・オブジェクトのためにその属性をサポートしていない場合は、エラーNFS4ERR_ATTRNOTSUPPがクライアントに返されます。"
    },
    {
      "indent": 3,
      "text": "When the attribute rdattr_error or any set-only attribute (e.g., time_modify_set) is specified, the error NFS4ERR_INVAL is returned to the client.",
      "ja": "属性rdattr_errorまたは任意のセット専用の属性（例えば、time_modify_set）が指定されている場合、エラーNFS4ERR_INVALがクライアントに返されます。"
    },
    {
      "indent": 0,
      "text": "18.32. Operation 38: WRITE - Write to File",
      "section_title": true,
      "ja": "18.32. 操作38：WRITE  - ファイルに書き込みます"
    },
    {
      "indent": 0,
      "text": "18.32.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.32.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "enum stable_how4 { UNSTABLE4 = 0, DATA_SYNC4 = 1, FILE_SYNC4 = 2 };",
      "ja": "列挙stable_how4 {UNSTABLE4 = 0、DATA_SYNC4 = 1、FILE_SYNC4 = 2}。"
    },
    {
      "indent": 3,
      "text": "struct WRITE4args {\n        /* CURRENT_FH: file */\n        stateid4        stateid;\n        offset4         offset;\n        stable_how4     stable;\n        opaque          data<>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.32.2. RESULTS",
      "section_title": true,
      "ja": "18.32.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct WRITE4resok {\n        count4          count;\n        stable_how4     committed;\n        verifier4       writeverf;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union WRITE4res switch (nfsstat4 status) {\n case NFS4_OK:\n         WRITE4resok    resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.32.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.32.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The WRITE operation is used to write data to a regular file. The target file is specified by the current filehandle. The offset specifies the offset where the data should be written. An offset of zero specifies that the write should start at the beginning of the file. The count, as encoded as part of the opaque data parameter, represents the number of bytes of data that are to be written. If the count is zero, the WRITE will succeed and return a count of zero subject to permissions checking. The server MAY write fewer bytes than requested by the client.",
      "ja": "WRITE操作は、通常のファイルにデータを書き込むために使用されます。対象のファイルは、現在のファイルハンドルで指定されています。オフセットは、データが書き込まれるべき場所オフセットを指定します。ゼロオフセットの書き込みは、ファイルの先頭から開始することを指定します。カウントは、不透明なデータパラメータの一部として符号化として、書き込まれるデータのバイト数を表します。カウントがゼロの場合、WRITEは成功し、チェック権限にゼロ対象の数を返します。サーバは、クライアントから要求されたよりも少ないバイトを書き込むことができます。"
    },
    {
      "indent": 3,
      "text": "The client specifies with the stable parameter the method of how the data is to be processed by the server. If stable is FILE_SYNC4, the server MUST commit the data written plus all file system metadata to stable storage before returning results. This corresponds to the NFSv2 protocol semantics. Any other behavior constitutes a protocol violation. If stable is DATA_SYNC4, then the server MUST commit all of the data to stable storage and enough of the metadata to retrieve the data before returning. The server implementor is free to implement DATA_SYNC4 in the same fashion as FILE_SYNC4, but with a possible performance drop. If stable is UNSTABLE4, the server is free to commit any part of the data and the metadata to stable storage, including all or none, before returning a reply to the client. There is no guarantee whether or when any uncommitted data will subsequently be committed to stable storage. The only guarantees made by the server are that it will not destroy any data without changing the value of writeverf and that it will not commit the data and metadata at a level less than that requested by the client.",
      "ja": "クライアントは、安定したパラメータを使用してデータがサーバによって処理されるかの方法を指定します。安定がFILE_SYNC4であれば、サーバは結果を返す前に、安定したストレージに書き込まれたデータに加えて、すべてのファイルシステムのメタデータをコミットする必要があります。これは、のNFSv2プロトコルのセマンティクスに対応しています。その他の動作は、プロトコル違反を構成しています。安定がDATA_SYNC4ある場合、サーバーは安定して保管し、返す前にデータを取得するメタデータの十分にすべてのデータをコミットする必要があります。サーバ実装者はFILE_SYNC4と同じように、しかし、可能性、パフォーマンスの低下とDATA_SYNC4を実装して自由です。安定がUNSTABLE4ある場合、サーバーはクライアントへの応答を返す前に、すべてまたはnoneを含む安定したストレージへのデータの任意の部分とメタデータをコミットして自由です。コミットされていないデータは、その後安定したストレージにコミットするかどうかとき保証はありません。サーバによって作られた唯一の保証は、それがwriteverfの値を変更することなく、任意のデータを破壊し、それがクライアントによって要求されたよりも低いレベルでのデータとメタデータをコミットしていないということではないだろうということです。"
    },
    {
      "indent": 3,
      "text": "Except when special stateids are used, the stateid value for a WRITE request represents a value returned from a previous byte-range LOCK or OPEN request or the stateid associated with a delegation. The stateid identifies the associated owners if any and is used by the server to verify that the associated locks are still valid (e.g., have not been revoked).",
      "ja": "特別のstateidsが使用される場合を除いて、WRITE要求のためのstateid値は、以前のバイト範囲ロックまたはOPEN要求または委任に関連付けられたstateidから返された値を表します。 stateidは、もしあれば、関連する所有者を識別し、関連するロックがまだ有効（例えば、失効していない）であることを確認するためにサーバによって使用されます。"
    },
    {
      "indent": 3,
      "text": "Upon successful completion, the following results are returned. The count result is the number of bytes of data written to the file. The server may write fewer bytes than requested. If so, the actual number of bytes written starting at location, offset, is returned.",
      "ja": "正常に完了すると、次の結果が返されます。カウント結果はファイルに書き込まれたデータのバイト数です。サーバーは、要求されたよりも少ないバイトを書き込むことができます。その場合、位置から始まる書き込まれたバイトの実際の数は、オフセット、戻されます。"
    },
    {
      "indent": 3,
      "text": "The server also returns an indication of the level of commitment of the data and metadata via committed. Per Table 11,",
      "ja": "また、サーバーはコミットを介したデータおよびメタデータのコミットメントのレベルを示す値を返します。表11あたり、"
    },
    {
      "indent": 3,
      "text": "o The server MAY commit the data at a stronger level than requested.",
      "ja": "oをサーバは、要求されたよりも強いレベルでデータをコミットしてもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "o The server MUST commit the data at a level at least as high as that committed.",
      "ja": "Oサーバは、そのコミットと少なくとも同じ高レベルでデータをコミットする必要があります。"
    },
    {
      "indent": 3,
      "text": "Valid combinations of the fields stable in the request and committed in the reply.",
      "ja": "リクエストで安定し、応答でコミットフィールドの有効な組み合わせ。"
    },
    {
      "indent": 12,
      "text": "+------------+-----------------------------------+\n| stable     | committed                         |\n+------------+-----------------------------------+\n| UNSTABLE4  | FILE_SYNC4, DATA_SYNC4, UNSTABLE4 |\n| DATA_SYNC4 | FILE_SYNC4, DATA_SYNC4            |\n| FILE_SYNC4 | FILE_SYNC4                        |\n+------------+-----------------------------------+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Table 11",
      "ja": "表11"
    },
    {
      "indent": 3,
      "text": "The final portion of the result is the field writeverf. This field is the write verifier and is a cookie that the client can use to determine whether a server has changed instance state (e.g., server restart) between a call to WRITE and a subsequent call to either WRITE or COMMIT. This cookie MUST be unchanged during a single instance of the NFSv4.1 server and MUST be unique between instances of the NFSv4.1 server. If the cookie changes, then the client MUST assume that any data written with an UNSTABLE4 value for committed and an old writeverf in the reply has been lost and will need to be recovered.",
      "ja": "結果の最後の部分は、フィールドwriteverfあります。このフィールドは、書き込みベリファイアであり、クライアントがサーバーインスタンスの状態を変更したかどうかを決定するために使用できるクッキー（例えば、サーバの再起動）呼び出しの間には、ライトし、WRITEまたはCOMMITのいずれかへのその後の呼び出しです。このクッキーは、NFSv4.1サーバーの単一のインスタンスの間不変のでなければならないとNFSv4.1サーバーのインスタンス間でユニークでなければなりません。クッキーが変更された場合、クライアントはコミットと回答の古いwriteverfためUNSTABLE4値で書き込まれたデータが失われた、回復する必要がありますと仮定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a client writes data to the server with the stable argument set to UNSTABLE4 and the reply yields a committed response of DATA_SYNC4 or UNSTABLE4, the client will follow up some time in the future with a COMMIT operation to synchronize outstanding asynchronous data and metadata with the server's stable storage, barring client error. It is possible that due to client crash or other error that a subsequent COMMIT will not be received by the server.",
      "ja": "クライアントがUNSTABLE4に設定された安定した引数を使用してサーバにデータを書き込み、返信がDATA_SYNC4またはUNSTABLE4のコミット応答を生成する場合は、クライアントが持つ優れた非同期データおよびメタデータを同期させるためにCOMMIT操作で、将来的にいくつかの時間をフォローアップしますサーバの安定したストレージ、クライアントエラーがなければ。その後のCOMMITというクライアントのクラッシュまたはその他のエラーが原因で、サーバによって受信されない可能性があります。"
    },
    {
      "indent": 3,
      "text": "For a WRITE with a stateid value of all bits equal to zero, the server MAY allow the WRITE to be serviced subject to mandatory byte-range locks or the current share deny modes for the file. For a WRITE with a stateid value of all bits equal to 1, the server MUST NOT allow the WRITE operation to bypass locking checks at the server and otherwise is treated as if a stateid of all bits equal to zero were used.",
      "ja": "ゼロに等しいすべてのビットのstateid値がWRITEのために、サーバは、WRITEは必須バイト範囲ロックまたは現在の共有ファイルのためのモードを拒否する対象サービスを受けることを可能にすることができます。 1に等しいすべてのビットのstateid値がWRITEのために、サーバは、サーバでチェックをロックし、それ以外の場合はゼロに等しいすべてのビットのstateidを使用したかのように扱われているバイパスする書き込み動作を可能にしてはいけません。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.32.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.32.4. 実装"
    },
    {
      "indent": 3,
      "text": "It is possible for the server to write fewer bytes of data than requested by the client. In this case, the server SHOULD NOT return an error unless no data was written at all. If the server writes less than the number of bytes specified, the client will need to send another WRITE to write the remaining data.",
      "ja": "サーバは、クライアントから要求されたよりも少ないデータのバイト数を書き込むことが可能です。データが全く書かれていない限りこの場合、サーバがエラーを返すべきではありません。サーバーは、指定されたバイト数よりも少ないが書き込まれた場合、クライアントは残りのデータを書き込むための別の書き込みを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the act of writing data to a file will cause the time_modified and change attributes of the file to be updated. However, these attributes SHOULD NOT be changed unless the contents of the file are changed. Thus, a WRITE request with count set to zero SHOULD NOT cause the time_modified and change attributes of the file to be updated.",
      "ja": "ファイルにデータを書き込む行為は、ファイルのtime_modifiedと変更属性が更新されますと仮定されます。ファイルの内容が変更されない限りしかし、これらの属性を変更する必要はありません。このように、ゼロに設定されたカウントと書き込み要求がファイルのtime_modifiedと変更属性がアップデートするべきではありません。"
    },
    {
      "indent": 3,
      "text": "Stable storage is persistent storage that survives:",
      "ja": "安定したストレージは生き残る永続的なストレージです。"
    },
    {
      "indent": 3,
      "text": "1. Repeated power failures.",
      "section_title": true,
      "ja": "1.繰り返し停電。"
    },
    {
      "indent": 3,
      "text": "2. Hardware failures (of any board, power supply, etc.).",
      "section_title": true,
      "ja": "（任意ボード、電源などの）2.ハードウェア障害。"
    },
    {
      "indent": 3,
      "text": "3. Repeated software crashes and restarts.",
      "section_title": true,
      "ja": "3.繰り返しソフトウェアがクラッシュして再起動します。"
    },
    {
      "indent": 3,
      "text": "This definition does not address failure of the stable storage module itself.",
      "ja": "この定義は、安定したストレージモジュール自体の故障に対応していません。"
    },
    {
      "indent": 3,
      "text": "The verifier is defined to allow a client to detect different instances of an NFSv4.1 protocol server over which cached, uncommitted data may be lost. In the most likely case, the verifier allows the client to detect server restarts. This information is required so that the client can safely determine whether the server could have lost cached data. If the server fails unexpectedly and the client has uncommitted data from previous WRITE requests (done with the stable argument set to UNSTABLE4 and in which the result committed was returned as UNSTABLE4 as well), the server might not have flushed cached data to stable storage. The burden of recovery is on the client, and the client will need to retransmit the data to the server.",
      "ja": "検証者は、コミットされていないデータが失われる可能性があり、キャッシュされたその上NFSv4.1プロトコルサーバの異なるインスタンスを検出するためのクライアントを許可するように定義されています。最も可能性が高い場合には、検証は、クライアントがサーバーの再起動を検出することができます。クライアントが安全にサーバがキャッシュされたデータを失っていることができるかどうかを判断できるように、この情報が必要になります。サーバーが予期せずに失敗し、クライアントは、前のWRITE要求（UNSTABLE4に設定された安定した引数で行われ、結果はコミットしているが、同様UNSTABLE4として返された）からのコミットされていないデータを持っている場合、サーバーは安定したストレージにキャッシュされたデータをフラッシュしていない可能性があります。回復の負担は、クライアント上で、クライアントがサーバにデータを再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "A suggested verifier would be to use the time that the server was last started (if restarting the server results in lost buffers).",
      "ja": "提案検証者は、（失われたバッファにサーバー結果を再起動した場合）、サーバが最後に起動時間を用いることであろう。"
    },
    {
      "indent": 3,
      "text": "The reply's committed field allows the client to do more effective caching. If the server is committing all WRITE requests to stable storage, then it SHOULD return with committed set to FILE_SYNC4, regardless of the value of the stable field in the arguments. A server that uses an NVRAM accelerator may choose to implement this policy. The client can use this to increase the effectiveness of the cache by discarding cached data that has already been committed on the server.",
      "ja": "回答者のコミットフィールドは、クライアントがより効果的なキャッシングを行うことができます。サーバーが安定したストレージにすべてのWRITE要求をコミットしている場合、それは関係なく、引数で安定したフィールドの値の、FILE_SYNC4にコミットセットで返すべきです。 NVRAMアクセラレータを使用するサーバーは、このポリシーを実装することを選択できます。クライアントがすでにサーバーにコミットされたキャッシュされたデータを破棄することにより、キャッシュの有効性を高めるためにこれを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Some implementations may return NFS4ERR_NOSPC instead of NFS4ERR_DQUOT when a user's quota is exceeded.",
      "ja": "ユーザのクォータを超えた場合、いくつかの実装がNFS4ERR_DQUOTの代わりにNFS4ERR_NOSPCを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "In the case that the current filehandle is of type NF4DIR, the server will return NFS4ERR_ISDIR. If the current file is a symbolic link, the error NFS4ERR_SYMLINK will be returned. Otherwise, if the current filehandle does not designate an ordinary file, the server will return NFS4ERR_WRONG_TYPE.",
      "ja": "現在のファイルハンドルがタイプNF4DIRである場合、サーバはNFS4ERR_ISDIRを返します。現在のファイルがシンボリックリンクの場合、エラーNFS4ERR_SYMLINKが返されます。現在のファイルハンドルは通常のファイルを指定しない場合はそれ以外の場合は、サーバーはNFS4ERR_WRONG_TYPEを返します。"
    },
    {
      "indent": 3,
      "text": "If mandatory byte-range locking is in effect for the file, and the corresponding byte-range of the data to be written to the file is READ_LT or WRITE_LT locked by an owner that is not associated with the stateid, the server MUST return NFS4ERR_LOCKED. If so, the client MUST check if the owner corresponding to the stateid used with the WRITE operation has a conflicting READ_LT lock that overlaps with the byte-range that was to be written. If the stateid's owner has no conflicting READ_LT lock, then the client SHOULD try to get the appropriate write byte-range lock via the LOCK operation before re-attempting the WRITE. When the WRITE completes, the client SHOULD release the byte-range lock via LOCKU.",
      "ja": "必須のバイト範囲ロックがファイルに対して有効であり、ファイルに書き込まれるデータの対応するバイト範囲のstateidに関連付けられていない所有者によってロックREAD_LT又はWRITE_LTである場合、サーバはNFS4ERR_LOCKEDを返さなければなりません。もしそうであればWRITE動作と使用のstateidに対応する所有者が書き込まれることになっていたバイト範囲と重複競合READ_LTロックを持っている場合、クライアントはチェックしなければなりません。 stateidの所有者が競合するREAD_LTロックを持っていない場合、クライアントは再試行する前に、WRITE LOCK操作を介して適切な書き込みバイト範囲ロックを取得しようとする必要があります。 WRITEが完了すると、クライアントはLOCKU経由バイト範囲ロックを解放する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the stateid's owner had a conflicting READ_LT lock, then the client has no choice but to return an error to the application that attempted the WRITE. The reason is that since the stateid's owner had a READ_LT lock, either the server attempted to temporarily effectively upgrade this READ_LT lock to a WRITE_LT lock or the server has no upgrade capability. If the server attempted to upgrade the READ_LT lock and failed, it is pointless for the client to re-attempt the upgrade via the LOCK operation, because there might be another client also trying to upgrade. If two clients are blocked trying to upgrade the same lock, the clients deadlock. If the server has no upgrade capability, then it is pointless to try a LOCK operation to upgrade.",
      "ja": "stateidの所有者が競合READ_LTロックを持っていた場合、クライアントはWRITEを試みたアプリケーションにエラーを返すしかありません。その理由は、以降のstateidの所有者は、READ_LTロックを持っていた、どちらかのサーバーが一時的に効果的WRITE_LTロックにこのREAD_LTロックをアップグレードしようとしたか、サーバーが何のアップグレード機能を持っていないということです。サーバがREAD_LTロックをアップグレードしようとして失敗した場合は、別のクライアントもアップグレードしようとしているがあるかもしれないので、クライアントは、LOCK操作を経由してアップグレードを再試行するために、それは無意味です。 2つのクライアントが同じロックをアップグレードしようとしてブロックされている場合、クライアントがデッドロック。サーバが何のアップグレード機能を持っていない場合、アップグレードするためにLOCK操作を試して無意味です。"
    },
    {
      "indent": 3,
      "text": "If one or more other clients have delegations for the file being written, those delegations MUST be recalled, and the operation cannot proceed until those delegations are returned or revoked. Except where this happens very quickly, one or more NFS4ERR_DELAY errors will be returned to requests made while the delegation remains outstanding. Normally, delegations will not be recalled as a result of a WRITE operation since the recall will occur as a result of an earlier OPEN. However, since it is possible for a WRITE to be done with a special stateid, the server needs to check for this case even though the client should have done an OPEN previously.",
      "ja": "一台の以上の他のクライアントが書き込まれているファイルのための代表団を持っている場合は、それらの代表団はリコールされなければならない、そして、それらの代表団が返さまたは取り消されるまで操作を続行できません。これは非常に迅速に起こる場合を除いて、一つ以上のNFS4ERR_DELAYエラーが代表団は優れたまま行われる要求に返されます。リコールは、以前のOPENの結果として発生しますので、通常、代表団は、WRITE操作の結果としてリコールされることはありません。 WRITEは、特別なstateidで行われることが可能であるので、サーバーは、クライアントが以前にOPENを行っている必要があるにもかかわらず、このような場合のためにチェックする必要があります。"
    },
    {
      "indent": 0,
      "text": "18.33. Operation 40: BACKCHANNEL_CTL - Backchannel Control",
      "section_title": true,
      "ja": "18.33. 操作40：BACKCHANNEL_CTL  - バックチャネルコントロール"
    },
    {
      "indent": 0,
      "text": "18.33.1. ARGUMENT",
      "section_title": true,
      "ja": "18.33.1. 引数"
    },
    {
      "indent": 3,
      "text": "typedef opaque gsshandle4_t<>;",
      "ja": "不透明gsshandle4_tのtypedef <>。"
    },
    {
      "indent": 3,
      "text": "struct gss_cb_handles4 {\n        rpc_gss_svc_t           gcbp_service; /* RFC 2203 */\n        gsshandle4_t            gcbp_handle_from_server;\n        gsshandle4_t            gcbp_handle_from_client;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union callback_sec_parms4 switch (uint32_t cb_secflavor) {\ncase AUTH_NONE:\n        void;\ncase AUTH_SYS:\n        authsys_parms   cbsp_sys_cred; /* RFC 1831 */\ncase RPCSEC_GSS:\n        gss_cb_handles4 cbsp_gss_handles;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct BACKCHANNEL_CTL4args {\n        uint32_t                bca_cb_program;\n        callback_sec_parms4     bca_sec_parms<>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.33.2. RESULT",
      "section_title": true,
      "ja": "18.33.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct BACKCHANNEL_CTL4res {\n        nfsstat4                bcr_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.33.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.33.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The BACKCHANNEL_CTL operation replaces the backchannel's callback program number and adds (not replaces) RPCSEC_GSS handles for use by the backchannel.",
      "ja": "BACKCHANNEL_CTL操作は、バックチャネルのコールバックプログラム番号を置き換えて、追加されます（置き換えられない）RPCSEC_GSSは、バックチャネルで使用するために処理します。"
    },
    {
      "indent": 3,
      "text": "The arguments of the BACKCHANNEL_CTL call are a subset of the CREATE_SESSION parameters. In the arguments of BACKCHANNEL_CTL, the bca_cb_program field and bca_sec_parms fields correspond respectively to the csa_cb_program and csa_sec_parms fields of the arguments of CREATE_SESSION (Section 18.36).",
      "ja": "BACKCHANNEL_CTL呼び出しの引数はCREATE_SESSIONパラメータのサブセットです。 BACKCHANNEL_CTLの引数では、bca_cb_programフィールドとbca_sec_parmsフィールドはCREATE_SESSIONの引数のcsa_cb_programとcsa_sec_parmsフィールド（セクション18.36）にそれぞれ対応します。"
    },
    {
      "indent": 3,
      "text": "BACKCHANNEL_CTL MUST appear in a COMPOUND that starts with SEQUENCE.",
      "ja": "BACKCHANNEL_CTLはSEQUENCEで始まるCOMPOUNDに現れなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the RPCSEC_GSS handle identified by gcbp_handle_from_server does not exist on the server, the server MUST return NFS4ERR_NOENT.",
      "ja": "gcbp_handle_from_serverで識別されるRPCSEC_GSSハンドルがサーバー上に存在しない場合は、サーバーはNFS4ERR_NOENTを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an RPCSEC_GSS handle is using the SSV context (see Section 2.10.9), then because each SSV RPCSEC_GSS handle shares a common SSV GSS context, there are security considerations specific to this situation discussed in Section 2.10.10.",
      "ja": "RPCSEC_GSSハンドルが（セクション2.10.9を参照）SSVコンテキストを使用している場合は、各SSV RPCSEC_GSSは、株式に共通SSV GSSコンテキストを扱うので、節2.10.10で説明し、このような状況に固有のセキュリティ上の考慮事項があります。"
    },
    {
      "indent": 0,
      "text": "18.34. Operation 41: BIND_CONN_TO_SESSION - Associate Connection with Session",
      "ja": "18.34. 操作41：BIND_CONN_TO_SESSION  - セッションの関連付けの接続"
    },
    {
      "indent": 0,
      "text": "18.34.1. ARGUMENT",
      "section_title": true,
      "ja": "18.34.1. 引数"
    },
    {
      "indent": 3,
      "text": "enum channel_dir_from_client4 { CDFC4_FORE = 0x1, CDFC4_BACK = 0x2, CDFC4_FORE_OR_BOTH = 0x3, CDFC4_BACK_OR_BOTH = 0x7 };",
      "ja": "列挙channel_dir_from_client4 {CDFC4_FORE = 0x1の、CDFC4_BACK = 0x2の、CDFC4_FORE_OR_BOTH = 0x3の、CDFC4_BACK_OR_BOTHは= 0x7の}。"
    },
    {
      "indent": 3,
      "text": "struct BIND_CONN_TO_SESSION4args { sessionid4 bctsa_sessid;",
      "ja": "構造体BIND_CONN_TO_SESSION4args {sessionid4 bctsa_sessid。"
    },
    {
      "indent": 4,
      "text": "channel_dir_from_client4 bctsa_dir;",
      "ja": "channel_dir_from_client4のbctsa_dir。"
    },
    {
      "indent": 3,
      "text": " bool           bctsa_use_conn_in_rdma_mode;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.34.2. RESULT",
      "section_title": true,
      "ja": "18.34.2. 結果"
    },
    {
      "indent": 3,
      "text": "enum channel_dir_from_server4 { CDFS4_FORE = 0x1, CDFS4_BACK = 0x2, CDFS4_BOTH = 0x3 };",
      "ja": "列挙channel_dir_from_server4 {CDFS4_FORE = 0x1の、CDFS4_BACK = 0x2の、CDFS4_BOTH =を0x3}。"
    },
    {
      "indent": 3,
      "text": "struct BIND_CONN_TO_SESSION4resok { sessionid4 bctsr_sessid;",
      "ja": "構造体BIND_CONN_TO_SESSION4resok {sessionid4 bctsr_sessid。"
    },
    {
      "indent": 4,
      "text": "channel_dir_from_server4 bctsr_dir;",
      "ja": "channel_dir_from_server4のbctsr_dir。"
    },
    {
      "indent": 3,
      "text": " bool           bctsr_use_conn_in_rdma_mode;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union BIND_CONN_TO_SESSION4res switch (nfsstat4 bctsr_status) {",
      "ja": "組合BIND_CONN_TO_SESSION4resスイッチ（nfsstat4のbctsr_status）{"
    },
    {
      "indent": 4,
      "text": "case NFS4_OK: BIND_CONN_TO_SESSION4resok bctsr_resok4;",
      "ja": "ケースNFS4_OK：BIND_CONN_TO_SESSION4resok bctsr_resok4。"
    },
    {
      "indent": 3,
      "text": " default:       void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.34.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.34.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "BIND_CONN_TO_SESSION is used to associate additional connections with a session. It MUST be used on the connection being associated with the session. It MUST be the only operation in the COMPOUND procedure. If SP4_NONE (Section 18.35) state protection is used, any principal, security flavor, or RPCSEC_GSS context MAY be used to invoke the operation. If SP4_MACH_CRED is used, RPCSEC_GSS MUST be used with the integrity or privacy services, using the principal that created the client ID. If SP4_SSV is used, RPCSEC_GSS with the SSV GSS mechanism (Section 2.10.9) and integrity or privacy MUST be used.",
      "ja": "BIND_CONN_TO_SESSIONは、セッションで追加の接続を関連付けるために使用されます。これは、セッションに関連付けられている接続で使用しなければなりません。それはCOMPOUND手順における動作のみでなければなりません。 SP4_NONE（セクション18.35）状態の保護が使用される場合、任意のプリンシパル、セキュリティ風味、またはRPCSEC_GSSコンテキストは操作を呼び出すために使用されるかもしれません。 SP4_MACH_CREDが使用されている場合は、RPCSEC_GSSは、クライアントIDを作成したプリンシパルを使用して、完全性またはプライバシサービスを使用しなければなりません。 SP4_SSVを使用する場合は、SSV GSSメカニズム（セクション2.10.9）との整合性やプライバシーをRPCSEC_GSSを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If, when the client ID was created, the client opted for SP4_NONE state protection, the client is not required to use BIND_CONN_TO_SESSION to associate the connection with the session, unless the client wishes to associate the connection with the backchannel. When SP4_NONE protection is used, simply sending a COMPOUND request with a SEQUENCE operation is sufficient to associate the connection with the session specified in SEQUENCE.",
      "ja": "、クライアントIDが作成されたとき、クライアントはSP4_NONE状態の保護のために選択した場合、クライアントは、クライアントがバックチャネルとの接続を関連付けることを希望しない限り、セッションとの接続を関連付けるためにBIND_CONN_TO_SESSIONを使用する必要はありません。 SP4_NONE保護が使用されている場合は、単にシーケンス動作を有する化合物の要求を送信すると、SEQUENCEで指定されたセッションとの接続を関連付けるのに十分です。"
    },
    {
      "indent": 3,
      "text": "The field bctsa_dir indicates whether the client wants to associate the connection with the fore channel or the backchannel or both channels. The value CDFC4_FORE_OR_BOTH indicates that the client wants to associate the connection with both the fore channel and backchannel, but will accept the connection being associated to just the fore channel. The value CDFC4_BACK_OR_BOTH indicates that the client wants to associate with both the fore channel and backchannel, but will accept the connection being associated with just the backchannel. The server replies in bctsr_dir which channel(s) the connection is associated with. If the client specified CDFC4_FORE, the server MUST return CDFS4_FORE. If the client specified CDFC4_BACK, the server MUST return CDFS4_BACK. If the client specified CDFC4_FORE_OR_BOTH, the server MUST return CDFS4_FORE or CDFS4_BOTH. If the client specified CDFC4_BACK_OR_BOTH, the server MUST return CDFS4_BACK or CDFS4_BOTH.",
      "ja": "フィールドbctsa_dirは、クライアントが前部チャネルまたはバックチャネルまたは両方のチャネルとの接続を関連付けるために望んでいるかどうかを示します。値CDFC4_FORE_OR_BOTHは、クライアントが前部チャネルおよびバックチャネルの両方との接続を関連付けるために望んでいることを示しているが、ちょうど前部チャネルに関連付けられている接続を受け入れます。値CDFC4_BACK_OR_BOTHは、クライアントが前部チャネルおよびバックチャネルの両方に関連させたいことを示しているが、ちょうどバックチャネルに関連付けられている接続を受け入れます。サーバは、接続が関連付けられているチャネル（複数可）bctsr_dirに応答します。クライアントはCDFC4_FOREを指定した場合、サーバーはCDFS4_FOREを返さなければなりません。クライアントはCDFC4_BACKを指定した場合、サーバーはCDFS4_BACKを返さなければなりません。クライアントはCDFC4_FORE_OR_BOTHを指定した場合、サーバーはCDFS4_FOREまたはCDFS4_BOTHを返さなければなりません。クライアントはCDFC4_BACK_OR_BOTHを指定した場合、サーバーはCDFS4_BACKまたはCDFS4_BOTHを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "See the CREATE_SESSION operation (Section 18.36), and the description of the argument csa_use_conn_in_rdma_mode to understand bctsa_use_conn_in_rdma_mode, and the description of csr_use_conn_in_rdma_mode to understand bctsr_use_conn_in_rdma_mode.",
      "ja": "CREATE_SESSION操作（セクション18.36）、およびbctsa_use_conn_in_rdma_modeを理解するために、引数csa_use_conn_in_rdma_modeの説明、およびbctsr_use_conn_in_rdma_modeを理解するcsr_use_conn_in_rdma_modeの説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "Invoking BIND_CONN_TO_SESSION on a connection already associated with the specified session has no effect, and the server MUST respond with NFS4_OK, unless the client is demanding changes to the set of channels the connection is associated with. If so, the server MUST return NFS4ERR_INVAL.",
      "ja": "すでに指定されたセッションに関連付けられている接続にBIND_CONN_TO_SESSIONを起動しても効果はありません、そして、クライアントは、接続が関連付けられているチャネルのセットへの変更を要求されない限り、サーバーは、NFS4_OKで応じなければなりません。その場合、サーバはNFS4ERR_INVALを返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.34.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.34.4. 実装"
    },
    {
      "indent": 3,
      "text": "If a session's channel loses all connections, depending on the client ID's state protection and type of channel, the client might need to use BIND_CONN_TO_SESSION to associate a new connection. If the server restarted and does not keep the reply cache in stable storage, the server will not recognize the session ID. The client will ultimately have to invoke EXCHANGE_ID to create a new client ID and session.",
      "ja": "セッションのチャネルは、クライアントIDの状態の保護とチャネルの種類に応じて、すべての接続を失った場合、クライアントは新しい接続を関連付けるためにBIND_CONN_TO_SESSIONを使用する必要があります。サーバーを再起動し、安定したストレージに返信キャッシュを保持していない場合、サーバーは、セッションIDを認識しません。クライアントは、最終的には新しいクライアントIDとセッションを作成するEXCHANGE_IDを起動する必要があります。"
    },
    {
      "indent": 3,
      "text": "Suppose SP4_SSV state protection is being used, and BIND_CONN_TO_SESSION is among the operations included in the spo_must_enforce set when the client ID was created (Section 18.35). If so, there is an issue if SET_SSV is sent, no response is returned, and the last connection associated with the client ID drops. The client, per the sessions model, MUST retry the SET_SSV. But it needs a new connection to do so, and MUST associate that connection with the session via a BIND_CONN_TO_SESSION authenticated with the SSV GSS mechanism. The problem is that the RPCSEC_GSS message integrity codes use a subkey derived from the SSV as the key and the SSV may have changed. While there are multiple recovery strategies, a single, general strategy is described here.",
      "ja": "SP4_SSV状態の保護が使用されていると仮定し、BIND_CONN_TO_SESSIONは動作のうちでクライアントIDが作成されたspo_must_enforceセット（セクション18.35）に含まれています。もしそうなら、SET_SSVが送信された場合は問題があり、何の応答が返されず、クライアントIDに関連付けられている最後の接続がドロップされます。クライアントは、セッションのモデルごとに、SET_SSVを再試行しなければなりません。しかし、それはそうするために新しい接続を必要とし、SSV GSSメカニズムで認証BIND_CONN_TO_SESSION経由のセッションでその接続を関連付ける必要があります。問題は、RPCSEC_GSSメッセージインテグリティコードをキーとしてSSVとSSVから誘導サブキー変更された可能性を使用することです。複数のリカバリ戦略がありますが、シングル、一般的な戦略は、ここで記述されています。"
    },
    {
      "indent": 3,
      "text": "o The client reconnects.",
      "ja": "Oクライアントが再接続します。"
    },
    {
      "indent": 3,
      "text": "o The client assumes that the SET_SSV was executed, and so sends BIND_CONN_TO_SESSION with the subkey (derived from the new SSV, i.e., what SET_SSV would have set the SSV to) used as the key for the RPCSEC_GSS credential message integrity codes.",
      "ja": "OクライアントはRPCSEC_GSS資格メッセージ完全性コードのキーとして使用される（即ち、何SET_SSVはにSSVを設定しているであろう、新しいSSV由来）SET_SSVが実行されたと仮定し、そのためのサブキーとBIND_CONN_TO_SESSIONを送信します。"
    },
    {
      "indent": 3,
      "text": "o If the request succeeds, this means that the original attempted SET_SSV did execute successfully. The client re-sends the original SET_SSV, which the server will reply to via the reply cache.",
      "ja": "リクエストが成功した場合、O、これはオリジナル未遂SET_SSVが正常に実行なかったことを意味します。クライアントサーバーが応答キャッシュ経由に返信させていただきます、元SET_SSVは、再送信します。"
    },
    {
      "indent": 3,
      "text": "o If the server returns an RPC authentication error, this means that the server's current SSV was not changed (and the SET_SSV was likely not executed). The client then tries BIND_CONN_TO_SESSION with the subkey derived from the old SSV as the key for the RPCSEC_GSS message integrity codes.",
      "ja": "サーバーは、RPC認証エラーを返した場合、O、これは、サーバーの現在のSSVが変更されなかったことを意味します（とSET_SSVはおそらく実行されませんでした）。次に、クライアントはRPCSEC_GSSメッセージ整合性コードのキーとして古いSSV由来のサブキーでBIND_CONN_TO_SESSIONをしようとします。"
    },
    {
      "indent": 3,
      "text": "o The attempted BIND_CONN_TO_SESSION with the old SSV should succeed. If so, the client re-sends the original SET_SSV. If the original SET_SSV was not executed, then the server executes it. If the original SET_SSV was executed but failed, the server will return the SET_SSV from the reply cache.",
      "ja": "O古いSSVと試みたBIND_CONN_TO_SESSIONは成功するはずです。その場合は、クライアントの元SET_SSVを再送信します。元SET_SSVが実行されなかった場合、サーバーはそれを実行します。元SET_SSVを実行したが失敗した場合、サーバは応答キャッシュからSET_SSVを返します。"
    },
    {
      "indent": 0,
      "text": "18.35. Operation 42: EXCHANGE_ID - Instantiate Client ID",
      "section_title": true,
      "ja": "18.35. 操作42：EXCHANGE_ID  - インスタンス化クライアントID"
    },
    {
      "indent": 3,
      "text": "The EXCHANGE_ID exchanges long-hand client and server identifiers (owners), and creates a client ID.",
      "ja": "EXCHANGE_ID交流の長い手のクライアントとサーバの識別子（所有者）、およびクライアントIDを作成します。"
    },
    {
      "indent": 0,
      "text": "18.35.1. ARGUMENT",
      "section_title": true,
      "ja": "18.35.1. 引数"
    },
    {
      "indent": 3,
      "text": "const EXCHGID4_FLAG_SUPP_MOVED_REFER    = 0x00000001;\nconst EXCHGID4_FLAG_SUPP_MOVED_MIGR     = 0x00000002;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const EXCHGID4_FLAG_BIND_PRINC_STATEID = 0x00000100;",
      "ja": "constのEXCHGID4_FLAG_BIND_PRINC_STATEID = 0x00000100;"
    },
    {
      "indent": 3,
      "text": "const EXCHGID4_FLAG_USE_NON_PNFS        = 0x00010000;\nconst EXCHGID4_FLAG_USE_PNFS_MDS        = 0x00020000;\nconst EXCHGID4_FLAG_USE_PNFS_DS         = 0x00040000;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const EXCHGID4_FLAG_MASK_PNFS = 0x00070000;",
      "ja": "constのEXCHGID4_FLAG_MASK_PNFS = 0x00070000;"
    },
    {
      "indent": 3,
      "text": "const EXCHGID4_FLAG_UPD_CONFIRMED_REC_A = 0x40000000;\nconst EXCHGID4_FLAG_CONFIRMED_R         = 0x80000000;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct state_protect_ops4 {\n        bitmap4 spo_must_enforce;\n        bitmap4 spo_must_allow;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct ssv_sp_parms4 {\n        state_protect_ops4      ssp_ops;\n        sec_oid4                ssp_hash_algs<>;\n        sec_oid4                ssp_encr_algs<>;\n        uint32_t                ssp_window;\n        uint32_t                ssp_num_gss_handles;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "enum state_protect_how4 { SP4_NONE = 0, SP4_MACH_CRED = 1, SP4_SSV = 2 };",
      "ja": "列挙state_protect_how4 {SP4_NONE = 0、SP4_MACH_CRED = 1、SP4_SSV = 2}。"
    },
    {
      "indent": 3,
      "text": "union state_protect4_a switch(state_protect_how4 spa_how) {\n        case SP4_NONE:\n                void;\n        case SP4_MACH_CRED:\n                state_protect_ops4      spa_mach_ops;\n        case SP4_SSV:\n                ssv_sp_parms4           spa_ssv_parms;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct EXCHANGE_ID4args {\n        client_owner4           eia_clientowner;\n        uint32_t                eia_flags;\n        state_protect4_a        eia_state_protect;\n        nfs_impl_id4            eia_client_impl_id<1>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.35.2. RESULT",
      "section_title": true,
      "ja": "18.35.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct ssv_prot_info4 {\n state_protect_ops4     spi_ops;\n uint32_t               spi_hash_alg;\n uint32_t               spi_encr_alg;\n uint32_t               spi_ssv_len;\n uint32_t               spi_window;\n gsshandle4_t           spi_handles<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union state_protect4_r switch(state_protect_how4 spr_how) {\n case SP4_NONE:\n         void;\n case SP4_MACH_CRED:\n         state_protect_ops4     spr_mach_ops;\n case SP4_SSV:\n         ssv_prot_info4         spr_ssv_info;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct EXCHANGE_ID4resok {\n clientid4        eir_clientid;\n sequenceid4      eir_sequenceid;\n uint32_t         eir_flags;\n state_protect4_r eir_state_protect;\n server_owner4    eir_server_owner;\n opaque           eir_server_scope<NFS4_OPAQUE_LIMIT>;\n nfs_impl_id4     eir_server_impl_id<1>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union EXCHANGE_ID4res switch (nfsstat4 eir_status) { case NFS4_OK: EXCHANGE_ID4resok eir_resok4;",
      "ja": "組合EXCHANGE_ID4resスイッチ（nfsstat4のeir_status）{ケースNFS4_OK：EXCHANGE_ID4resok eir_resok4。"
    },
    {
      "indent": 3,
      "text": "default:\n void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.35.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.35.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The client uses the EXCHANGE_ID operation to register a particular client owner with the server. The client ID returned from this operation will be necessary for requests that create state on the server and will serve as a parent object to sessions created by the client. In order to confirm the client ID it must first be used, along with the returned eir_sequenceid, as arguments to CREATE_SESSION. If the flag EXCHGID4_FLAG_CONFIRMED_R is set in the result, eir_flags, then eir_sequenceid MUST be ignored, as it has no relevancy.",
      "ja": "クライアントは、サーバーと特定のクライアントの所有者を登録するEXCHANGE_ID操作を使用しています。この操作から返されたクライアントIDは、サーバー上での状態を作成し、クライアントによって作成されたセッションに親オブジェクトとなるの要求のために必要となります。クライアントのIDを確認するためには、まずCREATE_SESSIONの引数として、返さeir_sequenceidとともに、使用する必要があります。フラグEXCHGID4_FLAG_CONFIRMED_Rが結果に設定されている場合、それは何の関連性を持たないように、eir_flagsは、その後eir_sequenceidは、無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "EXCHANGE_ID MAY be sent in a COMPOUND procedure that starts with SEQUENCE. However, when a client communicates with a server for the first time, it will not have a session, so using SEQUENCE will not be possible. If EXCHANGE_ID is sent without a preceding SEQUENCE, then it MUST be the only operation in the COMPOUND procedure's request. If it is not, the server MUST return NFS4ERR_NOT_ONLY_OP.",
      "ja": "EXCHANGE_IDはSEQUENCEで始まるCOMPOUND手順で送信することができます。クライアントが初めてサーバーと通信するときしかし、それはセッションを持っていないので、SEQUENCEを使用することはできません。 EXCHANGE_IDが前SEQUENCEなしで送信された場合、それはCOMPOUND手順の要求で動作のみでなければなりません。そうでない場合は、サーバがNFS4ERR_NOT_ONLY_OPを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The eia_clientowner field is composed of a co_verifier field and a co_ownerid string. As noted in Section 2.4, the co_ownerid describes the client, and the co_verifier is the incarnation of the client. An EXCHANGE_ID sent with a new incarnation of the client will lead to the server removing lock state of the old incarnation. Whereas an EXCHANGE_ID sent with the current incarnation and co_ownerid will result in an error or an update of the client ID's properties, depending on the arguments to EXCHANGE_ID.",
      "ja": "eia_clientownerフィールドはco_verifierフィールドとco_ownerid文字列で構成されています。 2.4節で述べたように、co_owneridは、クライアントを記述し、co_verifierは、クライアントの化身です。クライアントの新しい化身で送信されたEXCHANGE_IDは、古いインカネーションのロック状態を取り除くサーバーにつながります。現在の化身とco_owneridで送らEXCHANGE_IDがEXCHANGE_IDの引数に応じて、エラーまたはクライアントIDのプロパティの更新になります一方。"
    },
    {
      "indent": 3,
      "text": "A server MUST NOT use the same client ID for two different incarnations of an eir_clientowner.",
      "ja": "サーバーはeir_clientownerの二つの異なる化身のための同じクライアントIDを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "In addition to the client ID and sequence ID, the server returns a server owner (eir_server_owner) and server scope (eir_server_scope). The former field is used for network trunking as described in Section 2.10.5. The latter field is used to allow clients to determine when client IDs sent by one server may be recognized by another in the event of file system migration (see Section 11.7.7).",
      "ja": "クライアントIDとシーケンスIDに加えて、サーバは、サーバの所有者（eir_server_owner）とサーバースコープ（eir_server_scope）を返します。 2.10.5項で説明したように、元のフィールドは、ネットワークトランキングのために使用されています。後者のフィールドは、1台のサーバから送信されたクライアントIDは、ファイルシステムの移行の際に別のものを認識することができる場合、クライアントが決定できるようにするために使用される（セクション11.7.7を参照）。"
    },
    {
      "indent": 3,
      "text": "The client ID returned by EXCHANGE_ID is only unique relative to the combination of eir_server_owner.so_major_id and eir_server_scope. Thus, if two servers return the same client ID, the onus is on the client to distinguish the client IDs on the basis of eir_server_owner.so_major_id and eir_server_scope. In the event two different servers claim matching server_owner.so_major_id and eir_server_scope, the client can use the verification techniques discussed in Section 2.10.5 to determine if the servers are distinct. If they are distinct, then the client will need to note the destination network addresses of the connections used with each server, and use the network address as the final discriminator.",
      "ja": "EXCHANGE_IDによって返されたクライアントIDはeir_server_owner.so_major_idとeir_server_scopeの組み合わせのみユニークな相対的なものです。 2つのサーバーが同じクライアントIDを返す場合はこのように、責任はeir_server_owner.so_major_idとeir_server_scopeに基づいてクライアントIDを区別するために、クライアント上にあります。イベントに2台の異なるサーバーがマッチングserver_owner.so_major_idとeir_server_scopeを特徴、クライアントは、サーバが明瞭であるかどうかを決定するために、セクション2.10.5で議論検証技術を使用することができます。彼らは異なっている場合、クライアントは、各サーバーで使用する接続の宛先ネットワークアドレスを注意し、そして最終的に弁別などのネットワークアドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The server, as defined by the unique identity expressed in the so_major_id of the server owner and the server scope, needs to track several properties of each client ID it hands out. The properties apply to the client ID and all sessions associated with the client ID. The properties are derived from the arguments and results of EXCHANGE_ID. The client ID properties include:",
      "ja": "サーバーは、サーバーの所有者とサーバースコープのso_major_idで表した一意のIDによって定義され、それが出て渡し各クライアントIDのいくつかのプロパティを追跡する必要があります。プロパティは、クライアントIDとクライアントIDに関連付けられているすべてのセッションに適用されます。プロパティはEXCHANGE_IDの引数と結果に由来しています。クライアントのIDプロパティは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The capabilities expressed by the following bits, which come from the results of EXCHANGE_ID:",
      "ja": "EXCHANGE_IDの結果から来る次のビットによって表現能力O："
    },
    {
      "indent": 6,
      "text": "* EXCHGID4_FLAG_SUPP_MOVED_REFER",
      "ja": "* EXCHGID4_FLAG_SUPP_MOVED_REFER"
    },
    {
      "indent": 6,
      "text": "* EXCHGID4_FLAG_SUPP_MOVED_MIGR",
      "ja": "* EXCHGID4_FLAG_SUPP_MOVED_MIGR"
    },
    {
      "indent": 6,
      "text": "* EXCHGID4_FLAG_BIND_PRINC_STATEID",
      "ja": "* EXCHGID4_FLAG_BIND_PRINC_STATEID"
    },
    {
      "indent": 6,
      "text": "* EXCHGID4_FLAG_USE_NON_PNFS",
      "ja": "* EXCHGID4_FLAG_USE_NON_PNFS"
    },
    {
      "indent": 6,
      "text": "* EXCHGID4_FLAG_USE_PNFS_MDS",
      "ja": "* EXCHGID4_FLAG_USE_PNFS_MDS"
    },
    {
      "indent": 6,
      "text": "* EXCHGID4_FLAG_USE_PNFS_DS",
      "ja": "* EXCHGID4_FLAG_USE_PNFS_DS"
    },
    {
      "indent": 6,
      "text": "These properties may be updated by subsequent EXCHANGE_ID requests on confirmed client IDs though the server MAY refuse to change them.",
      "ja": "サーバはそれらを変更することを拒否かもしれませんが、これらのプロパティを確認し、クライアントIDのその後のEXCHANGE_ID要求することによって更新することができます。"
    },
    {
      "indent": 3,
      "text": "o The state protection method used, one of SP4_NONE, SP4_MACH_CRED, or SP4_SSV, as set by the spa_how field of the arguments to EXCHANGE_ID. Once the client ID is confirmed, this property cannot be updated by subsequent EXCHANGE_ID requests.",
      "ja": "使用状態の保護方法O、EXCHANGE_IDの引数のspa_howフィールドによって設定さSP4_NONE、SP4_MACH_CRED、又はSP4_SSVの一つ。クライアントIDが確​​認されると、このプロパティは、後続のEXCHANGE_IDリクエストによって更新することはできません。"
    },
    {
      "indent": 3,
      "text": "o For SP4_MACH_CRED or SP4_SSV state protection:",
      "ja": "O SP4_MACH_CREDまたはSP4_SSV状態の保護のために："
    },
    {
      "indent": 6,
      "text": "* The list of operations (spo_must_enforce) that MUST use the specified state protection. This list comes from the results of EXCHANGE_ID.",
      "ja": "*指定された状態の保護を使用しなければならない操作（spo_must_enforce）のリスト。このリストは、EXCHANGE_IDの結果から来ています。"
    },
    {
      "indent": 6,
      "text": "* The list of operations (spo_must_allow) that MAY use the specified state protection. This list comes from the results of EXCHANGE_ID.",
      "ja": "*指定された状態の保護を使用するかもしれ操作（spo_must_allow）のリスト。このリストは、EXCHANGE_IDの結果から来ています。"
    },
    {
      "indent": 6,
      "text": "Once the client ID is confirmed, these properties cannot be updated by subsequent EXCHANGE_ID requests.",
      "ja": "クライアントIDが確​​認されると、これらのプロパティは、後続のEXCHANGE_IDリクエストによって更新することはできません。"
    },
    {
      "indent": 3,
      "text": "o For SP4_SSV protection:",
      "ja": "SP4_SSV保護のためのO："
    },
    {
      "indent": 6,
      "text": "* The OID of the hash algorithm. This property is represented by one of the algorithms in the ssp_hash_algs field of the EXCHANGE_ID arguments. Once the client ID is confirmed, this property cannot be updated by subsequent EXCHANGE_ID requests.",
      "ja": "*ハッシュアルゴリズムのOID。このプロパティはEXCHANGE_ID引数のssp_hash_algs分野におけるアルゴリズムのいずれかで表されます。クライアントIDが確​​認されると、このプロパティは、後続のEXCHANGE_IDリクエストによって更新することはできません。"
    },
    {
      "indent": 6,
      "text": "* The OID of the encryption algorithm. This property is represented by one of the algorithms in the ssp_encr_algs field of the EXCHANGE_ID arguments. Once the client ID is confirmed, this property cannot be updated by subsequent EXCHANGE_ID requests.",
      "ja": "*暗号化アルゴリズムのOID。このプロパティはEXCHANGE_ID引数のssp_encr_algs分野におけるアルゴリズムのいずれかで表されます。クライアントIDが確​​認されると、このプロパティは、後続のEXCHANGE_IDリクエストによって更新することはできません。"
    },
    {
      "indent": 6,
      "text": "* The length of the SSV. This property is represented by the spi_ssv_len field in the EXCHANGE_ID results. Once the client ID is confirmed, this property cannot be updated by subsequent EXCHANGE_ID requests.",
      "ja": "* SSVの長さ。このプロパティはEXCHANGE_ID結果にspi_ssv_lenフィールドで表されます。クライアントIDが確​​認されると、このプロパティは、後続のEXCHANGE_IDリクエストによって更新することはできません。"
    },
    {
      "indent": 9,
      "text": "There are REQUIRED and RECOMMENDED relationships among the length of the key of the encryption algorithm (\"key length\"), the length of the output of hash algorithm (\"hash length\"), and the length of the SSV (\"SSV length\").",
      "ja": "暗号化アルゴリズム（「キー長」）、ハッシュアルゴリズム（「ハッシュ長」）の出力の長さ、およびSSV（「SSV長」）の長さの鍵の長さの間の必須および推奨の関係があります。"
    },
    {
      "indent": 9,
      "text": "+ key length MUST be <= hash length. This is because the keys used for the encryption algorithm are actually subkeys derived from the SSV, and the derivation is via the hash algorithm. The selection of an encryption algorithm with a key length that exceeded the length of the output of the hash algorithm would require padding, and thus weaken the use of the encryption algorithm.",
      "ja": "+キーの長さは、<=ハッシュの長さでなければなりません。暗号化アルゴリズムのために使用されるキーは、実際にSSV由来のサブキーで、導出は、ハッシュアルゴリズムを経由しているためです。パディングを必要とするハッシュアルゴリズムの出力の長さを超えたため、暗号化アルゴリズムの使用を弱める鍵長の暗号化アルゴリズムの選択。"
    },
    {
      "indent": 9,
      "text": "+ hash length SHOULD be <= SSV length. This is because the SSV is a key used to derive subkeys via an HMAC, and it is recommended that the key used as input to an HMAC be at least as long as the length of the HMAC's hash algorithm's output (see Section 3 of RFC2104 [11]).",
      "ja": "+ハッシュ長が<= SSVの長さでなければなりません。これは、SSVは、HMACを介しサブキーを導出するために使用されるキーであり、そしてHMACへの入力として使用されるキーは、HMACのハッシュアルゴリズムの出力の長さと少なくとも同じ長であることが推奨されるからである（[RFC2104のセクション3を参照してください11]）。"
    },
    {
      "indent": 9,
      "text": "+ key length SHOULD be <= SSV length. This is a transitive result of the above two invariants.",
      "ja": "+キーの長さは、<= SSVの長さでなければなりません。これは、上記の二つの不変量の推移結果です。"
    },
    {
      "indent": 9,
      "text": "+ key length SHOULD be >= hash length / 2. This is because the subkey derivation is via an HMAC and it is recommended that if the HMAC has to be truncated, it should not be truncated to less than half the hash length (see Section 4 of RFC2104 [11]).",
      "ja": "+キーの長さは次のようになりサブキー導出はHMACを介してであり、HMACを切り捨てなければならない場合、それは半分未満ハッシュ長さに切り捨てられるべきではないことが推奨されているので、これは（章を参照された長さ/ 2> =ハッシュRFC2104の4 [11]）。"
    },
    {
      "indent": 6,
      "text": "* Number of concurrent versions of the SSV the client and server will support (Section 2.10.9). This property is represented by spi_window in the EXCHANGE_ID results. The property may be updated by subsequent EXCHANGE_ID requests.",
      "ja": "*クライアントとサーバがサポートするSSVの同時バージョン（2.10.9節）の数。このプロパティはEXCHANGE_ID結果のspi_windowで表されます。プロパティは、後続のEXCHANGE_ID要求することによって更新することができます。"
    },
    {
      "indent": 3,
      "text": "o The client's implementation ID as represented by the eia_client_impl_id field of the arguments. The property may be updated by subsequent EXCHANGE_ID requests.",
      "ja": "引数のeia_client_impl_idフィールドによって表されるように、クライアントの実装ID O。プロパティは、後続のEXCHANGE_ID要求することによって更新することができます。"
    },
    {
      "indent": 3,
      "text": "o The server's implementation ID as represented by the eir_server_impl_id field of the reply. The property may be updated by replies to subsequent EXCHANGE_ID requests.",
      "ja": "返信のeir_server_impl_idフィールドによって表されるように、サーバーの実装ID O。プロパティは、後続のEXCHANGE_ID要求に回答することによって更新することができます。"
    },
    {
      "indent": 3,
      "text": "The eia_flags passed as part of the arguments and the eir_flags results allow the client and server to inform each other of their capabilities as well as indicate how the client ID will be used. Whether a bit is set or cleared on the arguments' flags does not force the server to set or clear the same bit on the results' side. Bits not defined above cannot be set in the eia_flags field. If they are, the server MUST reject the operation with NFS4ERR_INVAL.",
      "ja": "引数とeir_flags結果の一部として渡さeia_flagsは、クライアントとサーバがその能力のお互いを知らせるだけでなく、クライアントのIDを使用する方法を示すことができます。ビットが側設定や結果に同じビットをクリアするには、サーバーに強制しないフラグを引数にセットまたはクリアされているかどうか。上記で定義されていないビットがeia_flagsフィールドに設定することができません。その場合、サーバはNFS4ERR_INVALを使用して操作を拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The EXCHGID4_FLAG_UPD_CONFIRMED_REC_A bit can only be set in eia_flags; it is always off in eir_flags. The EXCHGID4_FLAG_CONFIRMED_R bit can only be set in eir_flags; it is always off in eia_flags. If the server recognizes the co_ownerid and co_verifier as mapping to a confirmed client ID, it sets EXCHGID4_FLAG_CONFIRMED_R in eir_flags. The EXCHGID4_FLAG_CONFIRMED_R flag allows a client to tell if the client ID it is trying to create already exists and is confirmed.",
      "ja": "EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aビットのみeia_flagsに設定することができます。それはeir_flagsで常にオフです。 EXCHGID4_FLAG_CONFIRMED_Rビットのみeir_flagsに設定することができます。それはeia_flagsで常にオフです。サーバが確認されたクライアントIDへのマッピングなどco_owneridとco_verifierを認識すると、それはeir_flagsでEXCHGID4_FLAG_CONFIRMED_Rを設定します。 EXCHGID4_FLAG_CONFIRMED_Rフラグは、作成しようとしているクライアントIDはすでに存在していると確認された場合、クライアントは伝えることができます。"
    },
    {
      "indent": 3,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set in eia_flags, this means that the client is attempting to update properties of an existing confirmed client ID (if the client wants to update properties of an unconfirmed client ID, it MUST NOT set EXCHGID4_FLAG_UPD_CONFIRMED_REC_A). If so, it is RECOMMENDED that the client send the update EXCHANGE_ID operation in the same COMPOUND as a SEQUENCE so that the EXCHANGE_ID is executed exactly once. Whether the client can update the properties of client ID depends on the state protection it selected when the client ID was created, and the principal and security flavor it uses when sending the EXCHANGE_ID request. The situations described in items 6, 7, 8, or 9 of the second numbered list of Section 18.35.4 will apply. Note that if the operation succeeds and returns a client ID that is already confirmed, the server MUST set the EXCHGID4_FLAG_CONFIRMED_R bit in eir_flags.",
      "ja": "EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aがeia_flagsに設定されている場合、これは、クライアントが（クライアントが未確認のクライアントIDのプロパティを更新したい場合、それはEXCHGID4_FLAG_UPD_CONFIRMED_REC_Aを設定してはいけません）、既存確認したクライアントIDのプロパティを更新しようとしていることを意味します。もしそうなら、クライアントがEXCHANGE_IDは一度だけ実行されるように、シーケンスと同じ化合物中の更新EXCHANGE_ID操作を送信することが推奨されます。クライアントは、クライアントIDのプロパティを更新できるかどうかは、クライアントIDが作成されたとき、それは選択された状態の保護に依存し、EXCHANGE_IDリクエストを送信するときにそれが使用する主要なセキュリティ味。アイテム6、7、8、またはセクション18.35.4の第二の番号付きリストの9に記載の状況が適用されます。操作が成功し、すでに確認されているクライアントのIDを返した場合、サーバはeir_flagsにEXCHGID4_FLAG_CONFIRMED_Rビットを設定しなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set in eia_flags, this means that the client is trying to establish a new client ID; it is attempting to trunk data communication to the server (Section 2.10.5); or it is attempting to update properties of an unconfirmed client ID. The situations described in items 1, 2, 3, 4, or 5 of the second numbered list of Section 18.35.4 will apply. Note that if the operation succeeds and returns a client ID that was previously confirmed, the server MUST set the EXCHGID4_FLAG_CONFIRMED_R bit in eir_flags.",
      "ja": "EXCHGID4_FLAG_UPD_CONFIRMED_REC_Aがeia_flagsに設定されていない場合、これは、クライアントが新しいクライアントIDを確立しようとしていることを意味します。サーバ（セクション2.10.5）へのデータ通信をトランクにしようとしています。または未確認のクライアントIDのプロパティを更新しようとしています。項目1、2、3、4、またはセクション18.35.4の第二の番号付きリストの5に記載の状況が適用されます。操作が成功し、以前に確認されたクライアントIDを返した場合、サーバはeir_flagsにEXCHGID4_FLAG_CONFIRMED_Rビットを設定しなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When the EXCHGID4_FLAG_SUPP_MOVED_REFER flag bit is set, the client indicates that it is capable of dealing with an NFS4ERR_MOVED error as part of a referral sequence. When this bit is not set, it is still legal for the server to perform a referral sequence. However, a server may use the fact that the client is incapable of correctly responding to a referral, by avoiding it for that particular client. It may, for instance, act as a proxy for that particular file system, at some cost in performance, although it is not obligated to do so. If the server will potentially perform a referral, it MUST set EXCHGID4_FLAG_SUPP_MOVED_REFER in eir_flags.",
      "ja": "EXCHGID4_FLAG_SUPP_MOVED_REFERフラグビットがセットされている場合、クライアントは、それが照会シーケンスの一部としてNFS4ERR_MOVEDエラーに対処することが可能であることを示しています。このビットがセットされていない場合は、サーバーが照会シーケンスを実行するために、それはまだ合法です。ただし、サーバーは、クライアントが正しくその特定のクライアントのためにそれを回避することにより、照会に応じることができないという事実を使用することができます。そうする義務はないが、それは、例えば、パフォーマンスのいくつかのコストで、その特定のファイルシステムのプロキシとして動作することができます。サーバーは、潜在的に紹介を行います場合は、eir_flagsにEXCHGID4_FLAG_SUPP_MOVED_REFERを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the EXCHGID4_FLAG_SUPP_MOVED_MIGR is set, the client indicates that it is capable of dealing with an NFS4ERR_MOVED error as part of a file system migration sequence. When this bit is not set, it is still legal for the server to indicate that a file system has moved, when this in fact happens. However, a server may use the fact that the client is incapable of correctly responding to a migration in its scheduling of file systems to migrate so as to avoid migration of file systems being actively used. It may also hide actual migrations from clients unable to deal with them by acting as a proxy for a migrated file system for particular clients, at some cost in performance, although it is not obligated to do so. If the server will potentially perform a migration, it MUST set EXCHGID4_FLAG_SUPP_MOVED_MIGR in eir_flags.",
      "ja": "EXCHGID4_FLAG_SUPP_MOVED_MIGRが設定されている場合、クライアントは、ファイルシステムの移行シーケンスの一部としてNFS4ERR_MOVEDエラーに対処することが可能であることを示しています。このビットが設定されていない場合、これは実際に発生したときに、ファイル・システムは、移動したことを示すために、サーバーのため、まだ法的です。ただし、サーバーは、クライアントが正常に積極的に使用されているファイルシステムの移行を避けるように移行するには、ファイルシステムのそのスケジューリングにおいて、移行への対応が不可能であるという事実を使用することができます。そうする義務はないが、それはまた、パフォーマンスの一部の費用で、特定のクライアント用の移行ファイルシステムのプロキシとして機能することによってそれらに対処することができませんでしクライアントから実際の移行を隠すことがあります。サーバーは、潜在的に移行を実行する場合は、それがeir_flagsにEXCHGID4_FLAG_SUPP_MOVED_MIGRを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When EXCHGID4_FLAG_BIND_PRINC_STATEID is set, the client indicates that it wants the server to bind the stateid to the principal. This means that when a principal creates a stateid, it has to be the one to use the stateid. If the server will perform binding, it will return EXCHGID4_FLAG_BIND_PRINC_STATEID. The server MAY return EXCHGID4_FLAG_BIND_PRINC_STATEID even if the client does not request it. If an update to the client ID changes the value of EXCHGID4_FLAG_BIND_PRINC_STATEID's client ID property, the effect applies only to new stateids. Existing stateids (and all stateids with the same \"other\" field) that were created with stateid to principal binding in force will continue to have binding in force. Existing stateids (and all stateids with the same \"other\" field) that were created with stateid to principal not in force will continue to have binding not in force.",
      "ja": "EXCHGID4_FLAG_BIND_PRINC_STATEIDが設定されている場合、クライアントは、それがプリンシパルにたstateidをバインドするためにサーバーを望んでいることを示しています。これは、プリンシパルがたstateidを作成するとき、それはのstateidを使用する1つなければならないことを意味します。サーバーは、結合を実行する場合は、それがEXCHGID4_FLAG_BIND_PRINC_STATEIDを返します。サーバーは、クライアントがそれを要求しない場合でも、EXCHGID4_FLAG_BIND_PRINC_STATEIDが返されることがあります。クライアントIDへの更新がEXCHGID4_FLAG_BIND_PRINC_STATEIDのクライアントIDプロパティの値を変更した場合、効果は新しいのstateidsにのみ適用されます。力で結合校長へのstateidを使用して作成された既存のstateids（と同じ「その他」フィールドを持つすべてのstateidsは）力で結合していていきます。プリンシパルにない力でのstateidを使用して作成された既存のstateids（と同じ「その他」フィールドを持つすべてのstateidsは）力ではない結合しているしていきます。"
    },
    {
      "indent": 3,
      "text": "The EXCHGID4_FLAG_USE_NON_PNFS, EXCHGID4_FLAG_USE_PNFS_MDS, and EXCHGID4_FLAG_USE_PNFS_DS bits are described in Section 13.1 and convey roles the client ID is to be used for in a pNFS environment. The server MUST set one of the acceptable combinations of these bits (roles) in eir_flags, as specified in Section 13.1. Note that the same client owner/server owner pair can have multiple roles. Multiple roles can be associated with the same client ID or with different client IDs. Thus, if a client sends EXCHANGE_ID from the same client owner to the same server owner multiple times, but specifies different pNFS roles each time, the server might return different client IDs. Given that different pNFS roles might have different client IDs, the client may ask for different properties for each role/client ID.",
      "ja": "EXCHGID4_FLAG_USE_NON_PNFS、EXCHGID4_FLAG_USE_PNFS_MDS、およびEXCHGID4_FLAG_USE_PNFS_DSビットは13.1節で説明し、クライアントIDは、pNFSの環境にするために使用される役割を伝えています。セクション13.1で指定されるように、サーバは、eir_flagsにこれらのビット（ロール）の許容される組み合わせのいずれかを設定しなければなりません。同じクライアント所有者/サーバーの所有者のペアが複数の役割を持つことができることに注意してください。複数の役割は、同じクライアントIDまたは異なるクライアントIDに関連付けることができます。クライアントが同じサーバーの所有者に同じクライアントの所有者から複数回EXCHANGE_IDを送りますが、異なるpNFSの役割を毎回指定する場合はこのように、サーバは異なるクライアントIDを返すことがあります。異なるpNFSの役割が異なるクライアントIDを持っているかもしれないことを考えると、クライアントは、各役割/クライアントIDのために異なる特性を求めることができます。"
    },
    {
      "indent": 3,
      "text": "The spa_how field of the eia_state_protect field specifies how the client wants to protect its client, locking, and session states from unauthorized changes (Section 2.10.8.3):",
      "ja": "eia_state_protectフィールドのspa_howフィールドは、クライアントが、無許可の変更（セクション2.10.8.3）からそのクライアント、ロック、およびセッションの状態を保護したい方法を指定します："
    },
    {
      "indent": 3,
      "text": "o SP4_NONE. The client does not request the NFSv4.1 server to enforce state protection. The NFSv4.1 server MUST NOT enforce state protection for the returned client ID.",
      "ja": "OのSP4_NONE。クライアントは、状態の保護を強化するためにNFSv4.1サーバーを要求しません。 NFSv4.1サーバーが返されたクライアントIDの状態の保護を強制してはなりません。"
    },
    {
      "indent": 3,
      "text": "o SP4_MACH_CRED. If spa_how is SP4_MACH_CRED, then the client MUST send the EXCHANGE_ID request with RPCSEC_GSS as the security flavor, and with a service of RPC_GSS_SVC_INTEGRITY or",
      "ja": "SP4_MACH_CRED O。 spa_howがSP4_MACH_CREDある場合、クライアントは、セキュリティの味として、及びRPC_GSS_SVC_INTEGRITYのサービスとRPCSEC_GSSでEXCHANGE_ID要求を送らなければなりませんか"
    },
    {
      "indent": 6,
      "text": "RPC_GSS_SVC_PRIVACY. If SP4_MACH_CRED is specified, then the client wants to use an RPCSEC_GSS-based machine credential to protect its state. The server MUST note the principal the EXCHANGE_ID operation was sent with, and the GSS mechanism used. These notes collectively comprise the machine credential.",
      "ja": "RPC_GSS_SVC_PRIVACY。 SP4_MACH_CREDが指定されている場合、クライアントはその状態を保護するためにRPCSEC_GSSベースのマシンの資格情報を使用することを望んでいます。サーバはEXCHANGE_ID動作を用いて送信された主、及び使用されるGSS機構を注意しなければなりません。これらのノートは、総称して、マシンの資格を備えています。"
    },
    {
      "indent": 6,
      "text": "After the client ID is confirmed, as long as the lease associated with the client ID is unexpired, a subsequent EXCHANGE_ID operation that uses the same eia_clientowner.co_owner as the first EXCHANGE_ID MUST also use the same machine credential as the first EXCHANGE_ID. The server returns the same client ID for the subsequent EXCHANGE_ID as that returned from the first EXCHANGE_ID.",
      "ja": "クライアントIDが確​​認された後に限り、クライアントIDに関連付けられたリースが期限切れであるように、第1 EXCHANGE_ID同じeia_clientowner.co_ownerを使用して、後続のEXCHANGE_ID動作も第EXCHANGE_ID同じマシン証明書を使用しなければなりません。それは最初EXCHANGE_IDから返されたサーバーは、後続EXCHANGE_IDのための同じクライアントIDを返します。"
    },
    {
      "indent": 3,
      "text": "o SP4_SSV. If spa_how is SP4_SSV, then the client MUST send the EXCHANGE_ID request with RPCSEC_GSS as the security flavor, and with a service of RPC_GSS_SVC_INTEGRITY or RPC_GSS_SVC_PRIVACY. If SP4_SSV is specified, then the client wants to use the SSV to protect its state. The server records the credential used in the request as the machine credential (as defined above) for the eia_clientowner.co_owner. The CREATE_SESSION operation that confirms the client ID MUST use the same machine credential.",
      "ja": "SP4_SSV O。 spa_howがSP4_SSVある場合、クライアントは、セキュリティの味として、及びRPC_GSS_SVC_INTEGRITYまたはRPC_GSS_SVC_PRIVACYのサービスとRPCSEC_GSSでEXCHANGE_ID要求を送らなければなりません。 SP4_SSVが指定されている場合、クライアントはその状態を保護するためにSSVを使用したいです。サーバはeia_clientowner.co_ownerための（上記で定義した）マシンの資格のような要求に使用される資格情報を記録します。クライアントのIDを確認CREATE_SESSION操作は、同じマシンの資格情報を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a client specifies SP4_MACH_CRED or SP4_SSV, it also provides two lists of operations (each expressed as a bitmap). The first list is spo_must_enforce and consists of those operations the client MUST send (subject to the server confirming the list of operations in the result of EXCHANGE_ID) with the machine credential (if SP4_MACH_CRED protection is specified) or the SSV-based credential (if SP4_SSV protection is used). The client MUST send the operations with RPCSEC_GSS credentials that specify the RPC_GSS_SVC_INTEGRITY or RPC_GSS_SVC_PRIVACY security service. Typically, the first list of operations includes EXCHANGE_ID, CREATE_SESSION, DELEGPURGE, DESTROY_SESSION, BIND_CONN_TO_SESSION, and DESTROY_CLIENTID. The client SHOULD NOT specify in this list any operations that require a filehandle because the server's access policies MAY conflict with the client's choice, and thus the client would then be unable to access a subset of the server's namespace.",
      "ja": "クライアントがSP4_MACH_CRED又はSP4_SSVを指定した場合、それはまた、（各々がビットマップとして表される）の動作の二つのリストを提供します。最初のリストはSP4_SSV場合、クライアントは（（SP4_MACH_CRED保護が指定されている場合）マシンの資格を持つ（EXCHANGE_IDの結果におけるオペレーションのリストを確認し、サーバーの対象を）またはSSVベースの資格証明送らなければなりませんspo_must_enforceで、それらの操作で構成されてい保護）が使用されています。クライアントはRPC_GSS_SVC_INTEGRITYまたはRPC_GSS_SVC_PRIVACYセキュリティサービスを指定するRPCSEC_GSS資格情報を使用して操作を送らなければなりません。典型的には、操作の最初のリストはEXCHANGE_ID、CREATE_SESSION、DELEGPURGE、DESTROY_SESSION、BIND_CONN_TO_SESSION、及びDESTROY_CLIENTIDを含みます。サーバのアクセスポリシーは、クライアントの選択肢と競合する可能性があるため、クライアントは、このリストにファイルハンドルを必要とする操作を指定してはなりませんので、クライアントは、サーバーの名前空間の一部にアクセスすることができないであろう。"
    },
    {
      "indent": 3,
      "text": "Note that if SP4_SSV protection is specified, and the client indicates that CREATE_SESSION must be protected with SP4_SSV, because the SSV cannot exist without a confirmed client ID, the first CREATE_SESSION MUST instead be sent using the machine credential, and the server MUST accept the machine credential.",
      "ja": "SP4_SSV保護が指定されている、とSSVが確認されたクライアントIDなしでは存在できないため、クライアントは、CREATE_SESSIONがSP4_SSVで保護されなければならないことを示している場合、最初のCREATE_SESSIONではなく、マシンの資格情報を使用して送信されなければならないことに注意してください、そして、サーバマシンを受け入れなければなりません資格。"
    },
    {
      "indent": 3,
      "text": "There is a corresponding result, also called spo_must_enforce, of the operations for which the server will require SP4_MACH_CRED or SP4_SSV protection. Normally, the server's result equals the client's argument, but the result MAY be different. If the client requests one or more operations in the set { EXCHANGE_ID, CREATE_SESSION, DELEGPURGE, DESTROY_SESSION, BIND_CONN_TO_SESSION, DESTROY_CLIENTID }, then the result spo_must_enforce MUST include the operations the client requested from that set.",
      "ja": "また、サーバがSP4_MACH_CREDまたはSP4_SSVの保護を必要とする対象の操作の、spo_must_enforceと呼ばれる対応する結果は、あります。通常、サーバの結果は、クライアントの引数に等しいが、結果は異なる場合があります。クライアントは、集合{EXCHANGE_ID、CREATE_SESSION、DELEGPURGE、DESTROY_SESSION、BIND_CONN_TO_SESSION、DESTROY_CLIENTID}内の1つまたは複数の操作を要求した場合、その結果のspo_must_enforceは、そのセットから要求された操作クライアントを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If spo_must_enforce in the results has BIND_CONN_TO_SESSION set, then connection binding enforcement is enabled, and the client MUST use the machine (if SP4_MACH_CRED protection is used) or SSV (if SP4_SSV protection is used) credential on calls to BIND_CONN_TO_SESSION.",
      "ja": "結果でspo_must_enforceがBIND_CONN_TO_SESSIONセットを持っている場合、接続結合執行が有効化され、そしてクライアントがBIND_CONN_TO_SESSIONへの呼び出しに（SP4_MACH_CRED保護が使用されている場合）、マシンを使用するか、SSV（SP4_SSV保護が使用されている場合）資格しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The second list is spo_must_allow and consists of those operations the client wants to have the option of sending with the machine credential or the SSV-based credential, even if the object the operations are performed on is not owned by the machine or SSV credential.",
      "ja": "第二のリストはspo_must_allowで、クライアントは操作が上で実行されるオブジェクトは、マシンやSSV資格によって所有されていない場合でも、マシンの資格やSSVベースの資格証明を送信するオプションを持って望んでいるそれらのオペレーションで構成されています。"
    },
    {
      "indent": 3,
      "text": "The corresponding result, also called spo_must_allow, consists of the operations the server will allow the client to use SP4_SSV or SP4_MACH_CRED credentials with. Normally, the server's result equals the client's argument, but the result MAY be different.",
      "ja": "またspo_must_allow呼ばれる対応する結果は、サーバはクライアントがでSP4_SSVまたはSP4_MACH_CRED資格情報を使用することができます操作で構成されています。通常、サーバの結果は、クライアントの引数に等しいが、結果は異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "The purpose of spo_must_allow is to allow clients to solve the following conundrum. Suppose the client ID is confirmed with EXCHGID4_FLAG_BIND_PRINC_STATEID, and it calls OPEN with the RPCSEC_GSS credentials of a normal user. Now suppose the user's credentials expire, and cannot be renewed (e.g., a Kerberos ticket granting ticket expires, and the user has logged off and will not be acquiring a new ticket granting ticket). The client will be unable to send CLOSE without the user's credentials, which is to say the client has to either leave the state on the server or re-send EXCHANGE_ID with a new verifier to clear all state, that is, unless the client includes CLOSE on the list of operations in spo_must_allow and the server agrees.",
      "ja": "spo_must_allowの目的は、クライアントが、次の難問を解決できるようにすることです。クライアントIDがEXCHGID4_FLAG_BIND_PRINC_STATEIDで確認されたと仮定し、それが通常のユーザのRPCSEC_GSS資格を持つOPEN呼び出します。今、ユーザーの資格情報の有効期限が切れると、更新することができない（例えば、Kerberosチケット認可チケットの有効期限が切れると、ユーザーがログオフしていると、チケットを付与する新しいチケットを取得することはありません）。仮定クライアントはCLOSE含まれていない限り、クライアントは、つまり、クライアントはすべての状態をクリアするには、サーバー上の状態のままにするか、新しい検証とEXCHANGE_IDを再送信するかを持っていると言うことですユーザーの資格情報、なしCLOSE送信することができませんspo_must_allowでの操作のリストと、サーバー上で同意します。"
    },
    {
      "indent": 3,
      "text": "The SP4_SSV protection parameters also have:",
      "ja": "SP4_SSV保護パラメータもあります。"
    },
    {
      "indent": 3,
      "text": "ssp_hash_algs:",
      "ja": "ssp_hash_algs："
    },
    {
      "indent": 6,
      "text": "This is the set of algorithms the client supports for the purpose of computing the digests needed for the internal SSV GSS mechanism and for the SET_SSV operation. Each algorithm is specified as an object identifier (OID). The REQUIRED algorithms for a server are id-sha1, id-sha224, id-sha256, id-sha384, and id-sha512 [28]. The algorithm the server selects among the set is indicated in spi_hash_alg, a field of spr_ssv_prot_info. The field spi_hash_alg is an index into the array ssp_hash_algs. If the server does not support any of the offered algorithms, it returns NFS4ERR_HASH_ALG_UNSUPP. If ssp_hash_algs is empty, the server MUST return NFS4ERR_INVAL.",
      "ja": "これは、クライアントが内部SSV GSSメカニズムのためとSET_SSVの動作に必要なダイジェストを計算する目的のためにサポートしてアルゴリズムのセットです。各アルゴリズムは、オブジェクト識別子（OID）として指定されています。サーバに必要なアルゴリズムは、ID-SHA1、ID-SHA224、ID-SHA256、ID-SHA384、及びID-SHA512 [28]です。サーバは、セットの中から選択アルゴリズムは、spi_hash_algにspr_ssv_prot_infoのフィールドを示しています。フィールドspi_hash_algは配列ssp_hash_algsへのインデックスです。サーバが提供するアルゴリズムのいずれかをサポートしていない場合、それはNFS4ERR_HASH_ALG_UNSUPPを返します。 ssp_hash_algsが空の場合、サーバーはNFS4ERR_INVALを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "ssp_encr_algs:",
      "ja": "ssp_encr_algs："
    },
    {
      "indent": 6,
      "text": "This is the set of algorithms the client supports for the purpose of providing privacy protection for the internal SSV GSS mechanism. Each algorithm is specified as an OID. The REQUIRED algorithm for a server is id-aes256-CBC. The RECOMMENDED algorithms are id-aes192-CBC and id-aes128-CBC [29]. The selected algorithm is returned in spi_encr_alg, an index into ssp_encr_algs. If the server does not support any of the offered algorithms, it returns NFS4ERR_ENCR_ALG_UNSUPP. If ssp_encr_algs is empty, the server MUST return NFS4ERR_INVAL. Note that due to previously stated requirements and recommendations on the relationships between key length and hash length, some combinations of RECOMMENDED and REQUIRED encryption algorithm and hash algorithm either SHOULD NOT or MUST NOT be used. Table 12 summarizes the illegal and discouraged combinations.",
      "ja": "これは、クライアントが内部SSV GSSメカニズムのプライバシー保護を提供する目的のためにサポートしてアルゴリズムのセットです。各アルゴリズムは、OIDとして指定されています。サーバーに必要なアルゴリズムは、ID-AES256-CBCです。推奨アルゴリズムは、ID-AES192-CBCおよびID-AES128-CBC [29]です。選択したアルゴリズムは、spi_encr_algにssp_encr_algsへのインデックスを返します。サーバが提供するアルゴリズムのいずれかをサポートしていない場合、それはNFS4ERR_ENCR_ALG_UNSUPPを返します。 ssp_encr_algsが空の場合、サーバーはNFS4ERR_INVALを返さなければなりません。キーの長さとハッシュ長との関係についての前述の要件および推奨事項になお、推奨および必須の暗号化アルゴリズムとハッシュアルゴリズムのいくつかの組み合わせは、いずれか、または使用してはいけませんない（SHOULD NOT）。表12には、違法と落胆の組み合わせをまとめたもの。"
    },
    {
      "indent": 3,
      "text": "ssp_window:",
      "ja": "ssp_window："
    },
    {
      "indent": 6,
      "text": "This is the number of SSV versions the client wants the server to maintain (i.e., each successful call to SET_SSV produces a new version of the SSV). If ssp_window is zero, the server MUST return NFS4ERR_INVAL. The server responds with spi_window, which MUST NOT exceed ssp_window, and MUST be at least one. Any requests on the backchannel or fore channel that are using a version of the SSV that is outside the window will fail with an ONC RPC authentication error, and the requester will have to retry them with the same slot ID and sequence ID.",
      "ja": "これにより、クライアントは、サーバーが（すなわち、SET_SSVへの各呼び出しが成功SSVの新バージョンを作成する）を維持したいと考えていSSVバージョンの数です。 ssp_windowがゼロの場合、サーバーはNFS4ERR_INVALを返さなければなりません。サーバーはssp_windowを超えてはならないspi_window、で応答し、そして少なくとも1でなければなりません。ウィンドウの外側にあるSSVのバージョンを使用しているバックチャネル又は前方チャネル上の要求は、ONC RPC認証エラーで失敗し、リクエスタが同一のスロットIDとシーケンスIDとそれらを再試行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "ssp_num_gss_handles:",
      "ja": "ssp_num_gss_handles："
    },
    {
      "indent": 6,
      "text": "This is the number of RPCSEC_GSS handles the server should create that are based on the GSS SSV mechanism (Section 2.10.9). It is not the total number of RPCSEC_GSS handles for the client ID. Indeed, subsequent calls to EXCHANGE_ID will add RPCSEC_GSS handles. The server responds with a list of handles in spi_handles. If the client asks for at least one handle and the server cannot create it, the server MUST return an error. The handles in spi_handles are not available for use until the client ID is confirmed, which could be immediately if EXCHANGE_ID returns EXCHGID4_FLAG_CONFIRMED_R, or upon successful confirmation from CREATE_SESSION.",
      "ja": "これは、サーバーがGSS SSVメカニズム（セクション2.10.9）に基づいていることに作成する必要がありますハンドルRPCSEC_GSSの数です。これは、クライアントIDのRPCSEC_GSSハンドルの合計数ではありません。実際、EXCHANGE_IDへの後続の呼び出しは、RPCSEC_GSSハンドルを追加します。サーバーはspi_handlesにおけるハンドルのリストで応答します。クライアントは、少なくとも一つのハンドルを要求し、サーバはそれを作成することができない場合、サーバーはエラーを返さなければなりません。 spi_handlesでハンドルはEXCHANGE_IDがEXCHGID4_FLAG_CONFIRMED_Rを返し、またはCREATE_SESSIONから成功の確認時にあれば、すぐにも可能性があり、クライアントのIDが確認されるまで使用できません。"
    },
    {
      "indent": 6,
      "text": "While a client ID can span all the connections that are connected to a server sharing the same eir_server_owner.so_major_id, the RPCSEC_GSS handles returned in spi_handles can only be used on connections connected to a server that returns the same the eir_server_owner.so_major_id and eir_server_owner.so_minor_id on each connection. It is permissible for the client to set ssp_num_gss_handles to zero; the client can create more handles with another EXCHANGE_ID call.",
      "ja": "クライアントIDが同じeir_server_owner.so_major_idを共有サーバーに接続されているすべての接続をまたがることができますが、RPCSEC_GSSがspi_handlesで返さハンドルは、同じeir_server_owner.so_major_idとeir_server_owner.so_minor_idを返すサーバーに接続の接続に使用することができます各接続に。クライアントがゼロにssp_num_gss_handlesを設定することが許されています。クライアントは、別のEXCHANGE_ID呼び出しで複数のハンドルを作成することができます。"
    },
    {
      "indent": 6,
      "text": "Because each SSV RPCSEC_GSS handle shares a common SSV GSS context, there are security considerations specific to this situation discussed in Section 2.10.10.",
      "ja": "各SSV RPCSEC_GSSは、株式に共通SSV GSSコンテキストを扱うので、節2.10.10で説明し、このような状況に固有のセキュリティ上の考慮事項があります。"
    },
    {
      "indent": 6,
      "text": "The seq_window (see Section 5.2.3.1 of RFC2203 [4]) of each RPCSEC_GSS handle in spi_handle MUST be the same as the seq_window of the RPCSEC_GSS handle used for the credential of the RPC request that the EXCHANGE_ID request was sent with.",
      "ja": "seq_windowはspi_handle各RPCSEC_GSSハンドルのEXCHANGE_ID要求を用いて送信されたRPC要求の資格情報のために使用さRPCSEC_GSSハンドルのseq_windowと同じである必要があります（[4] RFC2203のセクション5.2.3.1を参照します）。"
    },
    {
      "indent": 3,
      "text": "+-------------------+----------------------+------------------------+\n| Encryption        | MUST NOT be combined | SHOULD NOT be combined |\n| Algorithm         | with                 | with                   |\n+-------------------+----------------------+------------------------+\n| id-aes128-CBC     |                      | id-sha384, id-sha512   |\n| id-aes192-CBC     | id-sha1              | id-sha512              |\n| id-aes256-CBC     | id-sha1, id-sha224   |                        |\n+-------------------+----------------------+------------------------+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Table 12",
      "ja": "表12"
    },
    {
      "indent": 3,
      "text": "The arguments include an array of up to one element in length called eia_client_impl_id. If eia_client_impl_id is present, it contains the information identifying the implementation of the client. Similarly, the results include an array of up to one element in length called eir_server_impl_id that identifies the implementation of the server. Servers MUST accept a zero-length eia_client_impl_id array, and clients MUST accept a zero-length eir_server_impl_id array.",
      "ja": "引数はeia_client_impl_idと呼ばれる長さは最大1つの要素のアレイを含みます。 eia_client_impl_idが存在する場合、それはクライアントの実装を識別する情報が含まれています。同様に、結果は、サーバの実装を識別するeir_server_impl_idと呼ばれる長さは最大1つの要素のアレイを含みます。サーバーは、長さゼロeia_client_impl_idアレイを受け入れなければなりません、そしてクライアントが長さゼロeir_server_impl_idアレイを受け入れなければなりません。"
    },
    {
      "indent": 3,
      "text": "An example use for implementation identifiers would be diagnostic software that extracts this information in an attempt to identify interoperability problems, performance workload behaviors, or general usage statistics. Since the intent of having access to this information is for planning or general diagnosis only, the client and server MUST NOT interpret this implementation identity information in a way that affects interoperational behavior of the implementation. The reason is that if clients and servers did such a thing, they might use fewer capabilities of the protocol than the peer can support, or the client and server might refuse to interoperate.",
      "ja": "実装識別子の使用例は、相互運用性の問題、パフォーマンスのワークロードの行動、または一般的な使用統計を同定する試みで、この情報を抽出し、診断ソフトウェアになります。この情報へのアクセスを持っていることの意図は、計画や一般的な診断のためにあるだけなので、クライアントとサーバーは、実装のinteroperational動作に影響を与えるような、この実装識別情報を解釈してはいけません。その理由は、クライアントとサーバは、そのようなことをした場合、ピアがサポートできるよりも、彼らは、プロトコルの少ない機能を使用するかもしれない、またはクライアントとサーバーが相互運用することを拒否する可能性があるということです。"
    },
    {
      "indent": 3,
      "text": "Because it is possible that some implementations will violate the protocol specification and interpret the identity information, implementations MUST allow the users of the NFSv4 client and server to set the contents of the sent nfs_impl_id structure to any value.",
      "ja": "それはいくつかの実装は、プロトコル仕様に違反して識別情報を解釈することは可能であるので、実装はNFSv4クライアントとサーバのユーザが任意の値に送らnfs_impl_id構造体の内容を設定することができるようにしなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.35.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.35.4. 実装"
    },
    {
      "indent": 3,
      "text": "A server's client record is a 5-tuple:",
      "ja": "サーバのクライアントレコードは、5タプルです："
    },
    {
      "indent": 3,
      "text": "1. co_ownerid",
      "section_title": true,
      "ja": "1. co_ownerid"
    },
    {
      "indent": 10,
      "text": "The client identifier string, from the eia_clientowner\nstructure of the EXCHANGE_ID4args structure.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. co_verifier:",
      "section_title": true,
      "ja": "2. co_verifier："
    },
    {
      "indent": 10,
      "text": "A client-specific value used to indicate incarnations (where a\nclient restart represents a new incarnation), from the\neia_clientowner structure of the EXCHANGE_ID4args structure.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. principal:",
      "section_title": true,
      "ja": "3.校長："
    },
    {
      "indent": 10,
      "text": "The principal that was defined in the RPC header's credential\nand/or verifier at the time the client record was established.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4. client ID:",
      "section_title": true,
      "ja": "4.クライアントID："
    },
    {
      "indent": 10,
      "text": "The shorthand client identifier, generated by the server and\nreturned via the eir_clientid field in the EXCHANGE_ID4resok\nstructure.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5. confirmed:",
      "section_title": true,
      "ja": "5.確認しました："
    },
    {
      "indent": 10,
      "text": "A private field on the server indicating whether or not a\nclient record has been confirmed.  A client record is\nconfirmed if there has been a successful CREATE_SESSION\noperation to confirm it.  Otherwise, it is unconfirmed.  An\nunconfirmed record is established by an EXCHANGE_ID call.  Any\nunconfirmed record that is not confirmed within a lease period\nSHOULD be removed.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following identifiers represent special values for the fields in the records.",
      "ja": "以下の識別子は、レコード内のフィールドのための特別な値を表します。"
    },
    {
      "indent": 3,
      "text": "ownerid_arg:",
      "ja": "ownerid_arg："
    },
    {
      "indent": 6,
      "text": "The value of the eia_clientowner.co_ownerid subfield of the EXCHANGE_ID4args structure of the current request.",
      "ja": "現在の要求のEXCHANGE_ID4args構造のeia_clientowner.co_owneridサブフィールドの値。"
    },
    {
      "indent": 3,
      "text": "verifier_arg:",
      "ja": "verifier_arg："
    },
    {
      "indent": 6,
      "text": "The value of the eia_clientowner.co_verifier subfield of the EXCHANGE_ID4args structure of the current request.",
      "ja": "現在の要求のEXCHANGE_ID4args構造のeia_clientowner.co_verifierサブフィールドの値。"
    },
    {
      "indent": 3,
      "text": "old_verifier_arg:",
      "ja": "old_verifier_arg："
    },
    {
      "indent": 6,
      "text": "A value of the eia_clientowner.co_verifier field of a client record received in a previous request; this is distinct from verifier_arg.",
      "ja": "クライアントレコードのeia_clientowner.co_verifierフィールドの値は、前の要求で受信。これはverifier_argとは区別されます。"
    },
    {
      "indent": 3,
      "text": "principal_arg:",
      "ja": "principal_arg："
    },
    {
      "indent": 6,
      "text": "The value of the RPCSEC_GSS principal for the current request.",
      "ja": "現在の要求のRPCSEC_GSSプリンシパルの値。"
    },
    {
      "indent": 3,
      "text": "old_principal_arg:",
      "ja": "old_principal_arg："
    },
    {
      "indent": 6,
      "text": "A value of the principal of a client record as defined by the RPC header's credential or verifier of a previous request. This is distinct from principal_arg.",
      "ja": "RPCヘッダーの資格又は前の要求の検証者によって定義されたクライアントレコードの主の値。これはprincipal_argとは区別されます。"
    },
    {
      "indent": 3,
      "text": "clientid_ret:",
      "ja": "clientid_ret："
    },
    {
      "indent": 6,
      "text": "The value of the eir_clientid field the server will return in the EXCHANGE_ID4resok structure for the current request.",
      "ja": "eir_clientidフィールドの値は、サーバは、現在の要求のためにEXCHANGE_ID4resok構造に戻ります。"
    },
    {
      "indent": 3,
      "text": "old_clientid_ret:",
      "ja": "old_clientid_ret："
    },
    {
      "indent": 6,
      "text": "The value of the eir_clientid field the server returned in the EXCHANGE_ID4resok structure for a previous request. This is distinct from clientid_ret.",
      "ja": "eir_clientidフィールドの値は、サーバーは以前の要求のためにEXCHANGE_ID4resok構造体に戻りました。これはclientid_retとは区別されます。"
    },
    {
      "indent": 3,
      "text": "confirmed:",
      "ja": "確認しました："
    },
    {
      "indent": 6,
      "text": "The client ID has been confirmed.",
      "ja": "クライアントのIDは確認されています。"
    },
    {
      "indent": 3,
      "text": "unconfirmed:",
      "ja": "未確認："
    },
    {
      "indent": 6,
      "text": "The client ID has not been confirmed.",
      "ja": "クライアントのIDは確認されていません。"
    },
    {
      "indent": 3,
      "text": "Since EXCHANGE_ID is a non-idempotent operation, we must consider the possibility that retries occur as a result of a client restart, network partition, malfunctioning router, etc. Retries are identified by the value of the eia_clientowner field of EXCHANGE_ID4args, and the method for dealing with them is outlined in the scenarios below.",
      "ja": "EXCHANGE_IDが非冪等操作ですので、我々は再試行がEXCHANGE_ID4argsのeia_clientownerフィールドの値、およびのための方法により同定されているなどの再試行は、クライアントの再起動の結果として発生している可能性、ネットワークパーティション、誤動作ルータを、考慮しなければなりませんそれらに対処するには、以下のシナリオに概説されています。"
    },
    {
      "indent": 3,
      "text": "The scenarios are described in terms of the client record(s) a server has for a given co_ownerid. Note that if the client ID was created specifying SP4_SSV state protection and EXCHANGE_ID as the one of the operations in spo_must_allow, then the server MUST authorize EXCHANGE_IDs with the SSV principal in addition to the principal that created the client ID.",
      "ja": "シナリオは、クライアントレコード（複数可）、サーバが与えられたco_owneridのために持っているの観点から説明されています。クライアントIDがspo_must_allowにおける事業の一つとしてSP4_SSV状態の保護とEXCHANGE_IDを指定して作成された場合、サーバーはクライアントのIDを作成した元本に加えて、SSVプリンシパルでEXCHANGE_IDsを認可しなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "1. New Owner ID",
      "section_title": true,
      "ja": "1.新しい所有者ID"
    },
    {
      "indent": 10,
      "text": "If the server has no client records with\neia_clientowner.co_ownerid matching ownerid_arg, and\nEXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set in the\nEXCHANGE_ID, then a new shorthand client ID (let us call it\nclientid_ret) is generated, and the following unconfirmed\nrecord is added to the server's state.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, unconfirmed }",
      "ja": "{ownerid_arg、verifier_arg、principal_arg、clientid_ret、未確認}"
    },
    {
      "indent": 10,
      "text": "Subsequently, the server returns clientid_ret.",
      "ja": "その後、サーバーはclientid_retを返します。"
    },
    {
      "indent": 3,
      "text": "2. Non-Update on Existing Client ID",
      "section_title": true,
      "ja": "既存のクライアントID 2.非更新"
    },
    {
      "indent": 10,
      "text": "If the server has the following confirmed record, and the\nrequest does not have EXCHGID4_FLAG_UPD_CONFIRMED_REC_A set,\nthen the request is the result of a retried request due to a\nfaulty router or lost connection, or the client is trying to\ndetermine if it can perform trunking.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, confirmed }",
      "ja": "{ownerid_arg、verifier_arg、principal_arg、clientid_ret、確認}"
    },
    {
      "indent": 10,
      "text": "Since the record has been confirmed, the client must have received the server's reply from the initial EXCHANGE_ID request. Since the server has a confirmed record, and since EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set, with the possible exception of eir_server_owner.so_minor_id, the server returns the same result it did when the client ID's properties were last updated (or if never updated, the result when the client ID was created). The confirmed record is unchanged.",
      "ja": "レコードが確認されているので、クライアントは初期EXCHANGE_ID要求からサーバの応答を受けていなければなりません。サーバが確認されたレコードを持っている、とEXCHGID4_FLAG_UPD_CONFIRMED_REC_Aがeir_server_owner.so_minor_idの可能性を除いて、設定されていないので、サーバは同じ結果を返し、クライアントIDのプロパティが最後に更新されたときにはなかった（または更新されない場合、結果はいつからクライアントID）を作成しました。確認されたレコードは変更されません。"
    },
    {
      "indent": 3,
      "text": "3. Client Collision",
      "section_title": true,
      "ja": "3.クライアント衝突"
    },
    {
      "indent": 10,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set, and if the\nserver has the following confirmed record, then this request\nis likely the result of a chance collision between the values\nof the eia_clientowner.co_ownerid subfield of EXCHANGE_ID4args\nfor two different clients.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "{ ownerid_arg, *, old_principal_arg, old_clientid_ret, confirmed }",
      "ja": "{ownerid_arg、*、old_principal_arg、old_clientid_ret、確認}"
    },
    {
      "indent": 10,
      "text": "If there is currently no state associated with old_clientid_ret, or if there is state but the lease has expired, then this case is effectively equivalent to the New Owner ID case of Paragraph 1. The confirmed record is deleted, the old_clientid_ret and its lock state are deleted, a new shorthand client ID is generated, and the following unconfirmed record is added to the server's state.",
      "ja": "そこold_clientid_retに関連した状態が、現在ではありません、またはそこに状態があるが、リースが期限切れになった場合、このケースは確認されたレコード1段落の新しい所有者のIDケースに効果的に同等であるが削除され、old_clientid_ret、そのロック状態である場合削除された、新しい速記クライアントIDが生成され、以下の未確認のレコードは、サーバの状態に追加されます。"
    },
    {
      "indent": 10,
      "text": "{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, unconfirmed }",
      "ja": "{ownerid_arg、verifier_arg、principal_arg、clientid_ret、未確認}"
    },
    {
      "indent": 10,
      "text": "Subsequently, the server returns clientid_ret.",
      "ja": "その後、サーバーはclientid_retを返します。"
    },
    {
      "indent": 10,
      "text": "If old_clientid_ret has an unexpired lease with state, then no state of old_clientid_ret is changed or deleted. The server returns NFS4ERR_CLID_INUSE to indicate that the client should retry with a different value for the eia_clientowner.co_ownerid subfield of EXCHANGE_ID4args. The client record is not changed.",
      "ja": "old_clientid_ret状態で期限が切れていないリースを持っている場合は、old_clientid_retのない状態が変化していないか、削除されます。サーバーは、クライアントがEXCHANGE_ID4argsのeia_clientowner.co_owneridサブフィールドに別の値を再試行する必要があることを示すためにNFS4ERR_CLID_INUSEを返します。クライアントレコードは変更されません。"
    },
    {
      "indent": 3,
      "text": "4. Replacement of Unconfirmed Record",
      "section_title": true,
      "ja": "未確認のレコードの4交換"
    },
    {
      "indent": 10,
      "text": "If the EXCHGID4_FLAG_UPD_CONFIRMED_REC_A flag is not set, and\nthe server has the following unconfirmed record, then the\nclient is attempting EXCHANGE_ID again on an unconfirmed\nclient ID, perhaps due to a retry, a client restart before\nclient ID confirmation (i.e., before CREATE_SESSION was\ncalled), or some other reason.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "{ ownerid_arg, *, *, old_clientid_ret, unconfirmed }",
      "ja": "{ownerid_arg、*、*、old_clientid_ret、未確認}"
    },
    {
      "indent": 10,
      "text": "It is possible that the properties of old_clientid_ret are different than those specified in the current EXCHANGE_ID. Whether or not the properties are being updated, to eliminate ambiguity, the server deletes the unconfirmed record, generates a new client ID (clientid_ret), and establishes the following unconfirmed record:",
      "ja": "old_clientid_retの特性は、現在のEXCHANGE_IDで指定されたものとは異なっている可能性があります。プロパティが更新されているかどうかにかかわらず、あいまいさを排除するために、サーバは、未確認のレコードを削除し、新しいクライアントID（clientid_ret）を生成し、以下の未確認のレコードを確立します："
    },
    {
      "indent": 10,
      "text": "{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, unconfirmed }",
      "ja": "{ownerid_arg、verifier_arg、principal_arg、clientid_ret、未確認}"
    },
    {
      "indent": 3,
      "text": "5. Client Restart",
      "section_title": true,
      "ja": "5.クライアントを再起動します"
    },
    {
      "indent": 10,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is not set, and if the\nserver has the following confirmed client record, then this\nrequest is likely from a previously confirmed client that has\nrestarted.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "{ ownerid_arg, old_verifier_arg, principal_arg, old_clientid_ret, confirmed }",
      "ja": "{ownerid_arg、old_verifier_arg、principal_arg、old_clientid_ret、確認}"
    },
    {
      "indent": 10,
      "text": "Since the previous incarnation of the same client will no longer be making requests, once the new client ID is confirmed by CREATE_SESSION, byte-range locks and share reservations should be released immediately rather than forcing the new incarnation to wait for the lease time on the previous incarnation to expire. Furthermore, session state should be removed since if the client had maintained that information across restart, this request would not have been sent. If the server supports neither the CLAIM_DELEGATE_PREV nor CLAIM_DELEG_PREV_FH claim types, associated delegations should be purged as well; otherwise, delegations are retained and recovery proceeds according to Section 10.2.1.",
      "ja": "同じクライアントの以前の化身は、もはや新しいクライアントIDがCREATE_SESSIONによって確認されると、要求を行うことがないので、バイト範囲ロックとシェア予約は、むしろ上のリース時間を待つために、新たな化身を強制するよりも、すぐに解放されなければなりません期限切れに前の化身。さらに、セッション状態は、クライアントが再起動間でその情報を維持していた場合、この要求が送信されていませんので、削除する必要があります。サーバがCLAIM_DELEGATE_PREVもCLAIM_DELEG_PREV_FH要求の種類どちらもサポートしている場合は、関連した代表団は、同様にパージする必要があります。それ以外の場合は、代表団は、10.2.1項に基づいて保持され、回復が進行しています。"
    },
    {
      "indent": 10,
      "text": "After processing, clientid_ret is returned to the client and this client record is added:",
      "ja": "処理の後、clientid_retがクライアントに返されると、このクライアントのレコードが追加されます。"
    },
    {
      "indent": 10,
      "text": "{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, unconfirmed }",
      "ja": "{ownerid_arg、verifier_arg、principal_arg、clientid_ret、未確認}"
    },
    {
      "indent": 10,
      "text": "The previously described confirmed record continues to exist, and thus the same ownerid_arg exists in both a confirmed and unconfirmed state at the same time. The number of states can collapse to one once the server receives an applicable CREATE_SESSION or EXCHANGE_ID.",
      "ja": "前述した確認レコードが存在し続け、したがって同じownerid_arg同時に両方確認し、未確認の状態で存在します。サーバが該当CREATE_SESSIONまたはEXCHANGE_IDを受信すると状態の数は1つに折りたたむことができます。"
    },
    {
      "indent": 10,
      "text": "+ If the server subsequently receives a successful CREATE_SESSION that confirms clientid_ret, then the server atomically destroys the confirmed record and makes the unconfirmed record confirmed as described in Section 18.36.4.",
      "ja": "サーバは、その後clientid_retを確認して成功したCREATE_SESSIONを受信した場合+、サーバはアトミック確認したレコードを破棄し、未確認のレコードは、セクション18.36.4で説明したように確認します。"
    },
    {
      "indent": 10,
      "text": "+ If the server instead subsequently receives an EXCHANGE_ID with the client owner equal to ownerid_arg, one strategy is to simply delete the unconfirmed record, and process the EXCHANGE_ID as described in the entirety of Section 18.35.4.",
      "ja": "+サーバが代わりに続いownerid_argに等しいクライアント所有者とEXCHANGE_IDを受信した場合、1つの戦略は、単に未確認のレコードを削除すること、およびセクション18.35.4の全体に記載されているようにEXCHANGE_IDを処理します。"
    },
    {
      "indent": 3,
      "text": "6. Update",
      "section_title": true,
      "ja": "6.アップデート"
    },
    {
      "indent": 10,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set, and the server\nhas the following confirmed record, then this request is an\nattempt at an update.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "{ ownerid_arg, verifier_arg, principal_arg, clientid_ret, confirmed }",
      "ja": "{ownerid_arg、verifier_arg、principal_arg、clientid_ret、確認}"
    },
    {
      "indent": 10,
      "text": "Since the record has been confirmed, the client must have received the server's reply from the initial EXCHANGE_ID request. The server allows the update, and the client record is left intact.",
      "ja": "レコードが確認されているので、クライアントは初期EXCHANGE_ID要求からサーバの応答を受けていなければなりません。サーバーは、更新を可能にし、クライアントのレコードがそのまま残されています。"
    },
    {
      "indent": 3,
      "text": "7. Update but No Confirmed Record",
      "section_title": true,
      "ja": "7.更新したがありません確認済みのレコード"
    },
    {
      "indent": 10,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set, and the server\nhas no confirmed record corresponding ownerid_arg, then the\nserver returns NFS4ERR_NOENT and leaves any unconfirmed record\nintact.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8. Update but Wrong Verifier",
      "section_title": true,
      "ja": "8.アップデートが、間違った検証"
    },
    {
      "indent": 10,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set, and the server\nhas the following confirmed record, then this request is an\nillegal attempt at an update, perhaps because of a retry from\na previous client incarnation.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "{ ownerid_arg, old_verifier_arg, *, clientid_ret, confirmed }",
      "ja": "{ownerid_arg、old_verifier_arg、*、clientid_ret、確認}"
    },
    {
      "indent": 10,
      "text": "The server returns NFS4ERR_NOT_SAME and leaves the client record intact.",
      "ja": "サーバーはNFS4ERR_NOT_SAMEを返し、そのままクライアントレコードを残します。"
    },
    {
      "indent": 3,
      "text": "9. Update but Wrong Principal",
      "section_title": true,
      "ja": "9.更新したが、間違った校長"
    },
    {
      "indent": 10,
      "text": "If EXCHGID4_FLAG_UPD_CONFIRMED_REC_A is set, and the server\nhas the following confirmed record, then this request is an\nillegal attempt at an update by an unauthorized principal.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "{ ownerid_arg, verifier_arg, old_principal_arg, clientid_ret, confirmed }",
      "ja": "{ownerid_arg、verifier_arg、old_principal_arg、clientid_ret、確認}"
    },
    {
      "indent": 10,
      "text": "The server returns NFS4ERR_PERM and leaves the client record intact.",
      "ja": "サーバーはNFS4ERR_PERMを返し、そのままクライアントレコードを残します。"
    },
    {
      "indent": 0,
      "text": "18.36. Operation 43: CREATE_SESSION - Create New Session and Confirm Client ID",
      "ja": "18.36. 操作43：CREATE_SESSION  - 新しいセッションを作成し、クライアントのIDを確認してください"
    },
    {
      "indent": 0,
      "text": "18.36.1. ARGUMENT",
      "section_title": true,
      "ja": "18.36.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct channel_attrs4 {\n        count4                  ca_headerpadsize;\n        count4                  ca_maxrequestsize;\n        count4                  ca_maxresponsesize;\n        count4                  ca_maxresponsesize_cached;\n        count4                  ca_maxoperations;\n        count4                  ca_maxrequests;\n        uint32_t                ca_rdma_ird<1>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "const CREATE_SESSION4_FLAG_PERSIST              = 0x00000001;\nconst CREATE_SESSION4_FLAG_CONN_BACK_CHAN       = 0x00000002;\nconst CREATE_SESSION4_FLAG_CONN_RDMA            = 0x00000004;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct CREATE_SESSION4args {\n        clientid4               csa_clientid;\n        sequenceid4             csa_sequence;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "uint32_t csa_flags;",
      "ja": "uint32_t csa_flags;"
    },
    {
      "indent": 11,
      "text": "channel_attrs4          csa_fore_chan_attrs;\nchannel_attrs4          csa_back_chan_attrs;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        uint32_t                csa_cb_program;\n        callback_sec_parms4     csa_sec_parms<>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.36.2. RESULT",
      "section_title": true,
      "ja": "18.36.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CREATE_SESSION4resok {\n        sessionid4              csr_sessionid;\n        sequenceid4             csr_sequence;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "uint32_t csr_flags;",
      "ja": "uint32_t csr_flags;"
    },
    {
      "indent": 3,
      "text": "        channel_attrs4          csr_fore_chan_attrs;\n        channel_attrs4          csr_back_chan_attrs;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union CREATE_SESSION4res switch (nfsstat4 csr_status) {\ncase NFS4_OK:\n        CREATE_SESSION4resok    csr_resok4;\ndefault:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.36.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.36.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation is used by the client to create new session objects on the server.",
      "ja": "この操作は、サーバー上に新しいセッションオブジェクトを作成するために、クライアントによって使用されます。"
    },
    {
      "indent": 3,
      "text": "CREATE_SESSION can be sent with or without a preceding SEQUENCE operation in the same COMPOUND procedure. If CREATE_SESSION is sent with a preceding SEQUENCE operation, any session created by CREATE_SESSION has no direct relation to the session specified in the SEQUENCE operation, although the two sessions might be associated with the same client ID. If CREATE_SESSION is sent without a preceding SEQUENCE, then it MUST be the only operation in the COMPOUND procedure's request. If it is not, the server MUST return NFS4ERR_NOT_ONLY_OP.",
      "ja": "CREATE_SESSIONは、同じ化合物の手順に先行するシーケンス動作の有無にかかわらず送信することができます。 CREATE_SESSIONは、前回のシーケンス動作で送信された場合は2つのセッションが同一のクライアントIDに関連付けられているかもしれませんが、CREATE_SESSIONによって作成されたセッションは、SEQUENCE操作で指定されたセッションとは直接関係ありません。 CREATE_SESSIONが前SEQUENCEなしで送信された場合、それはCOMPOUND手順の要求で動作のみでなければなりません。そうでない場合は、サーバがNFS4ERR_NOT_ONLY_OPを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "In addition to creating a session, CREATE_SESSION has the following effects:",
      "ja": "セッションの作成に加えて、CREATE_SESSIONは、次のような効果があります。"
    },
    {
      "indent": 3,
      "text": "o The first session created with a new client ID serves to confirm the creation of that client's state on the server. The server returns the parameter values for the new session.",
      "ja": "O新しいクライアントIDを作成した最初のセッションは、サーバー上のそのクライアントの状態の作成を確認するのに役立ちます。サーバーは、新しいセッションのパラメータ値を返します。"
    },
    {
      "indent": 3,
      "text": "o The connection CREATE_SESSION that is sent over is associated with the session's fore channel.",
      "ja": "Oを介して送信される接続CREATE_SESSIONは、セッションの前部チャネルに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "The arguments and results of CREATE_SESSION are described as follows:",
      "ja": "次のように引数とCREATE_SESSIONの結果が説明されています。"
    },
    {
      "indent": 3,
      "text": "csa_clientid:",
      "ja": "csa_clientid："
    },
    {
      "indent": 6,
      "text": "This is the client ID with which the new session will be associated. The corresponding result is csr_sessionid, the session ID of the new session.",
      "ja": "これは、新しいセッションが関連されると、クライアントのIDです。対応する結果は、新しいセッションのセッションID csr_sessionidです。"
    },
    {
      "indent": 3,
      "text": "csa_sequence:",
      "ja": "csa_sequence："
    },
    {
      "indent": 6,
      "text": "Each client ID serializes CREATE_SESSION via a per-client ID sequence number (see Section 18.36.4). The corresponding result is csr_sequence, which MUST be equal to csa_sequence.",
      "ja": "各クライアントIDは、クライアントごとのIDのシーケンス番号（項18.36.4を参照）を介してCREATE_SESSIONをシリアル化します。対応する結果はcsa_sequenceに等しくなければならないcsr_sequence、です。"
    },
    {
      "indent": 3,
      "text": "In the next three arguments, the client offers a value that is to be a property of the session. Except where stated otherwise, it is RECOMMENDED that the server accept the value. If it is not acceptable, the server MAY use a different value. Regardless, the server MUST return the value the session will use (which will be either what the client offered, or what the server is insisting on) to the client.",
      "ja": "次の3つの引数では、クライアントは、セッションの財産になることです価値を提供しています。特に明記しない場合を除いて、サーバーが値を受け入れることが推奨されます。それが受け入れられない場合は、サーバが別の値を使用するかもしれません。関係なく、サーバはクライアントに（どちらかのクライアントが提供されるか、またはどのサーバが主張している）セッションが使用する値を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "csa_flags:",
      "ja": "csa_flags："
    },
    {
      "indent": 6,
      "text": "The csa_flags field contains a list of the following flag bits:",
      "ja": "csa_flagsフィールドには、次のフラグビットのリストが含まれています。"
    },
    {
      "indent": 6,
      "text": "CREATE_SESSION4_FLAG_PERSIST:",
      "ja": "CREATE_SESSION4_FLAG_PERSIST："
    },
    {
      "indent": 9,
      "text": "If CREATE_SESSION4_FLAG_PERSIST is set, the client wants the server to provide a persistent reply cache. For sessions in which only idempotent operations will be used (e.g., a read-only session), clients SHOULD NOT set CREATE_SESSION4_FLAG_PERSIST. If the server does not or cannot provide a persistent reply cache, the server MUST NOT set CREATE_SESSION4_FLAG_PERSIST in the field csr_flags.",
      "ja": "CREATE_SESSION4_FLAG_PERSISTが設定されている場合、クライアントは、サーバーが持続応答のキャッシュを提供したいと考えています。のみ冪等操作が使用されたセッション（例えば、読み出し専用セッション）のために、クライアントはCREATE_SESSION4_FLAG_PERSISTを設定しないでください。サーバーがないか、持続応答のキャッシュを提供することができない場合、サーバーは、フィールドcsr_flagsにCREATE_SESSION4_FLAG_PERSISTを設定してはいけません。"
    },
    {
      "indent": 9,
      "text": "If the server is a pNFS metadata server, for reasons described in Section 12.5.2 it SHOULD support CREATE_SESSION4_FLAG_PERSIST if it supports the layout_hint (Section 5.12.4) attribute.",
      "ja": "サーバーはpNFSのメタデータ・サーバである場合、それはlayout_hint（セクション5.12.4）属性をサポートしている場合は、12.5.2項で説明した理由ではCREATE_SESSION4_FLAG_PERSISTをサポートする必要があります。"
    },
    {
      "indent": 6,
      "text": "CREATE_SESSION4_FLAG_CONN_BACK_CHAN:",
      "ja": "CREATE_SESSION4_FLAG_CONN_BACK_CHAN："
    },
    {
      "indent": 9,
      "text": "If CREATE_SESSION4_FLAG_CONN_BACK_CHAN is set in csa_flags, the client is requesting that the connection over which the CREATE_SESSION operation arrived be associated with the session's backchannel in addition to its fore channel. If the server agrees, it sets CREATE_SESSION4_FLAG_CONN_BACK_CHAN in the result field csr_flags. If CREATE_SESSION4_FLAG_CONN_BACK_CHAN is not set in csa_flags, then CREATE_SESSION4_FLAG_CONN_BACK_CHAN MUST NOT be set in csr_flags.",
      "ja": "CREATE_SESSION4_FLAG_CONN_BACK_CHANがcsa_flagsに設定されている場合、クライアントはCREATE_SESSION操作が到着した上で、接続がその前部チャネルに加えて、セッションのバックチャネルに関連付けられることを要求しています。サーバーが同意すれば、それは結果フィールドcsr_flagsにCREATE_SESSION4_FLAG_CONN_BACK_CHANを設定します。 CREATE_SESSION4_FLAG_CONN_BACK_CHANがcsa_flagsに設定されていない場合、CREATE_SESSION4_FLAG_CONN_BACK_CHANはcsr_flagsに設定してはいけません。"
    },
    {
      "indent": 6,
      "text": "CREATE_SESSION4_FLAG_CONN_RDMA:",
      "ja": "CREATE_SESSION4_FLAG_CONN_RDMA："
    },
    {
      "indent": 9,
      "text": "If CREATE_SESSION4_FLAG_CONN_RDMA is set in csa_flags, and if the connection over which the CREATE_SESSION operation arrived is currently in non-RDMA mode but has the capability to operate in RDMA mode, then the client is requesting that the server \"step up\" to RDMA mode on the connection. If the server agrees, it sets CREATE_SESSION4_FLAG_CONN_RDMA in the result field csr_flags. If CREATE_SESSION4_FLAG_CONN_RDMA is not set in csa_flags, then CREATE_SESSION4_FLAG_CONN_RDMA MUST NOT be set in csr_flags. Note that once the server agrees to step up, it and the client MUST exchange all future traffic on the connection with RPC RDMA framing and not Record Marking ([8]).",
      "ja": "CREATE_SESSION4_FLAG_CONN_RDMAがcsa_flagsに設定されている場合CREATE_SESSION操作が到着した上で、接続が非RDMAモードに現在あるが、RDMAモードで動作する能力を持っている場合、クライアントは、サーバーが上のRDMAモードに「ステップアップ」することを要求されます接続。サーバーが同意すれば、それは結果フィールドcsr_flagsにCREATE_SESSION4_FLAG_CONN_RDMAを設定します。 CREATE_SESSION4_FLAG_CONN_RDMAがcsa_flagsに設定されていない場合、CREATE_SESSION4_FLAG_CONN_RDMAはcsr_flagsに設定してはいけません。サーバがステップアップすることに同意したら、それとクライアントがRPC RDMAフレーミングとの接続には、すべての将来のトラフィックを交換し、（[8]）マーキングを録音してはならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "csa_fore_chan_attrs, csa_fore_chan_attrs:",
      "ja": "csa_fore_chan_attrs、csa_fore_chan_attrs："
    },
    {
      "indent": 6,
      "text": "The csa_fore_chan_attrs and csa_back_chan_attrs fields apply to attributes of the fore channel (which conveys requests originating from the client to the server), and the backchannel (the channel that conveys callback requests originating from the server to the client), respectively. The results are in corresponding structures called csr_fore_chan_attrs and csr_back_chan_attrs. The results establish attributes for each channel, and on all subsequent use of each channel of the session. Each structure has the following fields:",
      "ja": "csa_fore_chan_attrsとcsa_back_chan_attrsフィールドはそれぞれ（クライアントからサーバに送信された要求を伝える）前部チャネルの属性、およびバックチャネル（サーバからクライアントに発信さコールバック要求を伝えるチャネル）に適用されます。結果はcsr_fore_chan_attrsとcsr_back_chan_attrsと呼ばれる対応する構造です。結果は、各チャネルの属性を確立し、セッションの各チャンネルのすべてのその後の使用に。各構造体は、次のフィールドがあります。"
    },
    {
      "indent": 6,
      "text": "ca_headerpadsize:",
      "ja": "ca_headerpadsize："
    },
    {
      "indent": 9,
      "text": "The maximum amount of padding the requester is willing to apply to ensure that write payloads are aligned on some boundary at the replier. For each channel, the server",
      "ja": "依頼者をパディングの最大量は、書き込みペイロードがリプライヤでいくつかの境界に整列されていることを確実にするために適用していく所存です。各チャネルのために、サーバー"
    },
    {
      "indent": 9,
      "text": "+ will reply in ca_headerpadsize with its preferred value, or zero if padding is not in use, and",
      "ja": "パディングが使用されていない場合+は、その好ましい値、またはゼロとca_headerpadsizeに返信し、"
    },
    {
      "indent": 9,
      "text": "+ MAY decrease this value but MUST NOT increase it.",
      "ja": "+この値を減少させることができるが、それを増やしてはなりません。"
    },
    {
      "indent": 6,
      "text": "ca_maxrequestsize:",
      "ja": "ca_maxrequestsize："
    },
    {
      "indent": 9,
      "text": "The maximum size of a COMPOUND or CB_COMPOUND request that will be sent. This size represents the XDR encoded size of the request, including the RPC headers (including security flavor credentials and verifiers) but excludes any RPC transport framing headers. Imagine a request coming over a non-RDMA TCP/IP connection, and that it has a single Record Marking header preceding it. The maximum allowable count encoded in the header will be ca_maxrequestsize. If a requester sends a request that exceeds ca_maxrequestsize, the error NFS4ERR_REQ_TOO_BIG will be returned per the description in Section 2.10.6.4. For each channel, the server MAY decrease this value but MUST NOT increase it.",
      "ja": "化合物または送信されますCB_COMPOUND要求の最大サイズ。このサイズは、（セキュリティ風味資格及び検証を含む）RPCヘッダを含むリクエストのXDR符号化された大きさを表すが、任意のRPC輸送フレーミングヘッダを除外する。非RDMA TCP / IP接続を介してくる要求を想像し、そしてそれに先行するヘッダをマーキング単一のレコードを有します。ヘッダで符号化された最大許容数はca_maxrequestsizeします。リクエスタがca_maxrequestsizeを超えた要求を送信すると、エラーNFS4ERR_REQ_TOO_BIGは、セクション2.10.6.4に説明ごとに返されます。チャネルごとに、サーバーは、この値を減少させることができるが、それを増やしてはなりません。"
    },
    {
      "indent": 6,
      "text": "ca_maxresponsesize:",
      "ja": "ca_maxresponsesize："
    },
    {
      "indent": 9,
      "text": "The maximum size of a COMPOUND or CB_COMPOUND reply that the requester will accept from the replier including RPC headers (see the ca_maxrequestsize definition). For each channel, the server MAY decrease this value, but MUST NOT increase it. However, if the client selects a value for ca_maxresponsesize such that a replier on a channel could never send a response, the server SHOULD return NFS4ERR_TOOSMALL in the CREATE_SESSION reply. After the session is created, if a requester sends a request for which the size of the reply would exceed this value, the replier will return NFS4ERR_REP_TOO_BIG, per the description in Section 2.10.6.4.",
      "ja": "化合物またはCB_COMPOUNDの最大サイズは、リクエスタがRPCヘッダー（ca_maxrequestsize定義を参照）を含めた回答者から受け付けることを返信。チャネルごとに、サーバーは、この値を下げるかもしれないが、それを増加させてはなりません。クライアントは、チャネル上のリプライヤが応答を送信することができませんでしたようにca_maxresponsesizeの値を選択した場合は、サーバーはCREATE_SESSION応答でNFS4ERR_TOOSMALLを返すべきです。セッションが作成された後、依頼者が回答のサイズがこの値を超えることになるため、要求を送信した場合、リプライヤはセクション2.10.6.4に説明につき、NFS4ERR_REP_TOO_BIGを返します。"
    },
    {
      "indent": 6,
      "text": "ca_maxresponsesize_cached:",
      "ja": "ca_maxresponsesize_cached："
    },
    {
      "indent": 9,
      "text": "Like ca_maxresponsesize, but the maximum size of a reply that will be stored in the reply cache (Section 2.10.6.1). For each channel, the server MAY decrease this value, but MUST NOT increase it. If, in the reply to CREATE_SESSION, the value of ca_maxresponsesize_cached of a channel is less than the value of ca_maxresponsesize of the same channel, then this is an indication to the requester that it needs to be selective about which replies it directs the replier to cache; for example, large replies from nonidempotent operations (e.g., COMPOUND requests with a READ operation) should not be cached. The requester decides which replies to cache via an argument to the SEQUENCE (the sa_cachethis field, see Section 18.46) or CB_SEQUENCE (the csa_cachethis field, see Section 20.9) operations. After the session is created, if a requester sends a request for which the size of the reply would exceed ca_maxresponsesize_cached, the replier will return NFS4ERR_REP_TOO_BIG_TO_CACHE, per the description in Section 2.10.6.4.",
      "ja": "ca_maxresponsesizeのような、しかし応答キャッシュ（第2.10.6.1）に格納される応答の最大サイズ。チャネルごとに、サーバーは、この値を下げるかもしれないが、それを増加させてはなりません。 、CREATE_SESSIONに対する応答において、チャネルのca_maxresponsesize_cachedの値が同じチャネルのca_maxresponsesizeの値未満である場合、これは、それがキャッシュに回答を指示応答するかについて選択する必要があることを要求者への指示であります;例えば、非アイデンポテント動作（例えば、READ動作を有する化合物の要求）から大きな応答がキャッシュされるべきではありません。依頼者は、SEQUENCEへの引数を介してキャッシュへの返信かを決定する操作（項20.9を参照してください、csa_cachethisフィールド）またはCB_SEQUENCE（sa_cachethisフィールド、セクション18.46を参照してください）。セッションが作成された後、依頼者が回答の大きさはca_maxresponsesize_cachedを超えることになるため、要求を送信した場合、リプライヤはセクション2.10.6.4で説明につき、NFS4ERR_REP_TOO_BIG_TO_CACHEを返します。"
    },
    {
      "indent": 6,
      "text": "ca_maxoperations:",
      "ja": "ca_maxoperations："
    },
    {
      "indent": 9,
      "text": "The maximum number of operations the replier will accept in a COMPOUND or CB_COMPOUND. For the backchannel, the server MUST NOT change the value the client offers. For the fore channel, the server MAY change the requested value. After the session is created, if a requester sends a COMPOUND or CB_COMPOUND with more operations than ca_maxoperations, the replier MUST return NFS4ERR_TOO_MANY_OPS.",
      "ja": "操作の最大数は、回答者は、化合物又はCB_COMPOUNDに受け入れます。バックチャネルの場合、サーバーは、クライアントが提供する値を変更しないでください。前部チャネルの場合、サーバは要求された値を変更することがあります。セッションが作成された後、リクエスタがca_maxoperationsよりも多くの操作を有する化合物またはCB_COMPOUNDを送信した場合、リプライヤはNFS4ERR_TOO_MANY_OPSを返さなければなりません。"
    },
    {
      "indent": 6,
      "text": "ca_maxrequests:",
      "ja": "ca_maxrequests："
    },
    {
      "indent": 9,
      "text": "The maximum number of concurrent COMPOUND or CB_COMPOUND requests the requester will send on the session. Subsequent requests will each be assigned a slot identifier by the requester within the range zero to ca_maxrequests - 1 inclusive. For the backchannel, the server MUST NOT change the value the client offers. For the fore channel, the server MAY change the requested value.",
      "ja": "同時化合物またはCB_COMPOUNDの最大数は、要求者がセッションに送信されます要求します。後続の要求は、各ca_maxrequestsの範囲内でゼロリクエスタによってスロット識別子を割り当てられる -  1以下です。バックチャネルの場合、サーバーは、クライアントが提供する値を変更しないでください。前部チャネルの場合、サーバは要求された値を変更することがあります。"
    },
    {
      "indent": 6,
      "text": "ca_rdma_ird:",
      "ja": "Ka_rdhm_ird："
    },
    {
      "indent": 9,
      "text": "This array has a maximum of one element. If this array has one element, then the element contains the inbound RDMA read queue depth (IRD). For each channel, the server MAY decrease this value, but MUST NOT increase it.",
      "ja": "この配列は、一つの要素の最大値を有します。この配列は、一つの要素を持っている場合、その要素は、インバウンドRDMA読みキューの深さ（IRD）が含まれています。チャネルごとに、サーバーは、この値を下げるかもしれないが、それを増加させてはなりません。"
    },
    {
      "indent": 3,
      "text": "csa_cb_program",
      "ja": "csa_cb_program"
    },
    {
      "indent": 6,
      "text": "This is the ONC RPC program number the server MUST use in any callbacks sent through the backchannel to the client. The server MUST specify an ONC RPC program number equal to csa_cb_program and an ONC RPC version number equal to 4 in callbacks sent to the client. If a CB_COMPOUND is sent to the client, the server MUST use a minor version number of 1. There is no corresponding result.",
      "ja": "これは、サーバーがクライアントにバックチャネルを介して送信される任意のコールバックに使用しなければならないONC RPCプログラム番号です。サーバーはcsa_cb_programに等しいONC RPCプログラム番号およびクライアントに送信されたコールバックでは4に等しいONC RPCのバージョン番号を指定する必要があります。 CB_COMPOUNDがクライアントに送信されている場合は、サーバーには、対応する結果がありません1のマイナーバージョン番号を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "csa_sec_parms",
      "ja": "csa_sec_parms"
    },
    {
      "indent": 6,
      "text": "The field csa_sec_parms is an array of acceptable security credentials the server can use on the session's backchannel. Three security flavors are supported: AUTH_NONE, AUTH_SYS, and RPCSEC_GSS. If AUTH_NONE is specified for a credential, then this says the client is authorizing the server to use AUTH_NONE on all callbacks for the session. If AUTH_SYS is specified, then the client is authorizing the server to use AUTH_SYS on all callbacks, using the credential specified cbsp_sys_cred. If RPCSEC_GSS is specified, then the server is allowed to use the RPCSEC_GSS context specified in cbsp_gss_parms as the RPCSEC_GSS context in the credential of the RPC header of callbacks to the client. There is no corresponding result.",
      "ja": "フィールドcsa_sec_parmsサーバーがセッションのバックチャネル上で使用することができる許容可能なセキュリティ資格情報の配列です。 3つのセキュリティ風味がサポートされています：AUTH_NONE、AUTH_SYS、およびRPCSEC_GSS。 AUTH_NONEが資格のために指定されている場合は、これは、クライアントがセッションのすべてのコールバックでAUTH_NONEを使用するようにサーバーを承認されると言います。 AUTH_SYSが指定されている場合、クライアントはcbsp_sys_cred指定された資格情報を使用して、すべてのコールバックでAUTH_SYSを使用するようにサーバーを許可されます。 RPCSEC_GSSが指定されている場合、サーバは、クライアントへのコールバックのRPCヘッダの資格でRPCSEC_GSSコンテキストとしてcbsp_gss_parmsで指定RPCSEC_GSSコンテキストを使用することができます。該当する結果がありません。"
    },
    {
      "indent": 6,
      "text": "The RPCSEC_GSS context for the backchannel is specified via a pair of values of data type gsshandle4_t. The data type gsshandle4_t represents an RPCSEC_GSS handle, and is precisely the same as the data type of the \"handle\" field of the rpc_gss_init_res data type defined in Section 5.2.3.1, \"Context Creation Response - Successful Acceptance\", of [4].",
      "ja": "バックチャネル用RPCSEC_GSSコンテキストは、データ型gsshandle4_tの値の対を介して指定されています。データ型gsshandle4_tはRPCSEC_GSSハンドルを表し、かつ正確セクション5.2.3.1で定義されたrpc_gss_init_resデータタイプの「ハンドル」フィールドのデータ・タイプと同じで、「コンテキスト作成応答 - 成功受け入れ」の、[4]。"
    },
    {
      "indent": 6,
      "text": "The first RPCSEC_GSS handle, gcbp_handle_from_server, is the fore handle the server returned to the client (either in the handle field of data type rpc_gss_init_res or as one of the elements of the spi_handles field returned in the reply to EXCHANGE_ID) when the RPCSEC_GSS context was created on the server. The second handle, gcbp_handle_from_client, is the back handle to which the client will map the RPCSEC_GSS context. The server can immediately use the value of gcbp_handle_from_client in the RPCSEC_GSS credential in callback RPCs. That is, the value in gcbp_handle_from_client can be used as the value of the field \"handle\" in data type rpc_gss_cred_t (see Section 5, \"Elements of the RPCSEC_GSS Security Protocol\", of [4]) in callback RPCs. The server MUST use the RPCSEC_GSS security service specified in gcbp_service, i.e., it MUST set the \"service\" field of the rpc_gss_cred_t data type in RPCSEC_GSS credential to the value of gcbp_service (see Section 5.3.1, \"RPC Request Header\", of [4]).",
      "ja": "第RPCSEC_GSSハンドル、gcbp_handle_from_serverは、前部がRPCSEC_GSSコンテキストが作成されたとき、サーバが（データ型rpc_gss_init_resのハンドルフィールドまたはEXCHANGE_IDに対する応答で返さspi_handlesフィールドの要素の一つとしてのいずれかで）クライアントに返されたハンドルでありますサーバー上。第2のハンドル、gcbp_handle_from_clientは、クライアントがRPCSEC_GSSコンテキストをマップする先のバックハンドルです。サーバーはすぐにコールバックのRPCでのRPCSEC_GSS資格にgcbp_handle_from_clientの値を使用することができます。すなわち、gcbp_handle_from_clientの値は、コールバックのRPCに（[4]の第5章、「RPCSEC_GSSセキュリティプロトコルの要素」を参照）データ型rpc_gss_cred_tに「ハンドル」フィールドの値として使用することができるされています。サーバは（[の、セクション5.3.1、「RPCリクエスト・ヘッダー」を参照してください。つまり、それはgcbp_serviceの値にRPCSEC_GSS資格でrpc_gss_cred_tデータ型の「サービス」フィールドを設定しなければなりません、gcbp_serviceで指定RPCSEC_GSSセキュリティサービスを使用しなければなりません4]）。"
    },
    {
      "indent": 6,
      "text": "If the RPCSEC_GSS handle identified by gcbp_handle_from_server does not exist on the server, the server will return NFS4ERR_NOENT.",
      "ja": "gcbp_handle_from_serverで識別されるRPCSEC_GSSハンドルがサーバー上に存在しない場合は、サーバーはNFS4ERR_NOENTを返します。"
    },
    {
      "indent": 6,
      "text": "Within each element of csa_sec_parms, the fore and back RPCSEC_GSS contexts MUST share the same GSS context and MUST have the same seq_window (see Section 5.2.3.1 of RFC2203 [4]). The fore and back RPCSEC_GSS context state are independent of each other as far as the RPCSEC_GSS sequence number (see the seq_num field in the rpc_gss_cred_t data type of Sections 5 and 5.3.1 of [4]).",
      "ja": "csa_sec_parmsの各要素内で、前方及びバックRPCSEC_GSSコンテキストが同じGSSコンテキストを共有する必要があり、同じseq_windowがなければなりません（[4] RFC2203のセクション5.2.3.1を参照）。前面と背面RPCSEC_GSSコンテキスト状態（SEQ_NUMセクション5のrpc_gss_cred_tデータタイプのフィールドとの5.3.1を参照[4]）までRPCSEC_GSSシーケンス番号として互いに独立しています。"
    },
    {
      "indent": 6,
      "text": "If an RPCSEC_GSS handle is using the SSV context (see Section 2.10.9), then because each SSV RPCSEC_GSS handle shares a common SSV GSS context, there are security considerations specific to this situation discussed in Section 2.10.10.",
      "ja": "RPCSEC_GSSハンドルが（セクション2.10.9を参照）SSVコンテキストを使用している場合は、各SSV RPCSEC_GSSは、株式に共通SSV GSSコンテキストを扱うので、節2.10.10で説明し、このような状況に固有のセキュリティ上の考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "Once the session is created, the first SEQUENCE or CB_SEQUENCE received on a slot MUST have a sequence ID equal to 1; if not, the replier MUST return NFS4ERR_SEQ_MISORDERED.",
      "ja": "セッションが作成されると、第一の配列またはCB_SEQUENCEは1に等しいシーケンス番号を持たなければならないスロットで受信しました。ない場合は、リプライヤはNFS4ERR_SEQ_MISORDEREDを返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.36.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.36.4. 実装"
    },
    {
      "indent": 3,
      "text": "To describe a possible implementation, the same notation for client records introduced in the description of EXCHANGE_ID is used with the following addition:",
      "ja": "可能な実装を記述するために、EXCHANGE_IDの説明で導入クライアントレコードについて同じ表記法は、次の添加と共に使用されます。"
    },
    {
      "indent": 6,
      "text": "clientid_arg: The value of the csa_clientid field of the CREATE_SESSION4args structure of the current request.",
      "ja": "clientid_arg：現在の要求のCREATE_SESSION4args構造のcsa_clientidフィールドの値。"
    },
    {
      "indent": 3,
      "text": "Since CREATE_SESSION is a non-idempotent operation, we need to consider the possibility that retries may occur as a result of a client restart, network partition, malfunctioning router, etc. For each client ID created by EXCHANGE_ID, the server maintains a separate reply cache (called the CREATE_SESSION reply cache) similar to the session reply cache used for SEQUENCE operations, with two distinctions.",
      "ja": "CREATE_SESSIONが非冪等操作ですので、我々はEXCHANGE_IDによって作成された各クライアントIDの場合など、クライアントの再起動、ネットワークパーティション、誤動作ルータの結果として発生する可能性が再試行可能性を考慮する必要があり、サーバが別々の応答キャッシュを維持します2つの違いと、SEQUENCEの操作に使用されるセッション応答キャッシュと同様（CREATE_SESSION応答キャッシュと呼ばれます）。"
    },
    {
      "indent": 3,
      "text": "o First, this is a reply cache just for detecting and processing CREATE_SESSION requests for a given client ID.",
      "ja": "Oまず、これは単に与えられたクライアントIDのCREATE_SESSION要求を検出し、処理するための応答キャッシュです。"
    },
    {
      "indent": 3,
      "text": "o Second, the size of the client ID reply cache is of one slot (and as a result, the CREATE_SESSION request does not carry a slot number). This means that at most one CREATE_SESSION request for a given client ID can be outstanding.",
      "ja": "O第二に、クライアントID応答キャッシュのサイズは、一つのスロットであり（その結果、CREATE_SESSION要求スロット数を運びません）。これは、特定のクライアントIDの高々1つのCREATE_SESSIONの要求が未処理できることを意味します。"
    },
    {
      "indent": 3,
      "text": "As previously stated, CREATE_SESSION can be sent with or without a preceding SEQUENCE operation. Even if a SEQUENCE precedes CREATE_SESSION, the server MUST maintain the CREATE_SESSION reply cache, which is separate from the reply cache for the session associated with a SEQUENCE. If CREATE_SESSION was originally sent by itself, the client MAY send a retry of the CREATE_SESSION operation within a COMPOUND preceded by a SEQUENCE. If CREATE_SESSION was originally sent in a COMPOUND that started with a SEQUENCE, then the client SHOULD send a retry in a COMPOUND that starts with a SEQUENCE that has the same session ID as the SEQUENCE of the original request. However, the client MAY send a retry in a COMPOUND that either has no preceding SEQUENCE, or has a preceding SEQUENCE that refers to a different session than the original CREATE_SESSION. This might be necessary if the client sends a CREATE_SESSION in a COMPOUND preceded by a SEQUENCE with session ID X, and session X no longer exists. Regardless, any retry of CREATE_SESSION, with or without a preceding SEQUENCE, MUST use the same value of csa_sequence as the original.",
      "ja": "先に述べたように、CREATE_SESSIONは、先行するシーケンス動作の有無にかかわらず送信することができます。 SEQUENCEはCREATE_SESSIONに先行している場合でも、サーバはSEQUENCEに関連したセッションの応答キャッシュから分離されCREATE_SESSION応答キャッシュを維持しなければなりません。 CREATE_SESSIONは元々自身によって送信された場合、クライアントは、配列が先行化合物内CREATE_SESSION操作の再試行を送信することができます。 CREATE_SESSIONは、もともとSEQUENCEで開始COMPOUNDに送信された場合、クライアントは元の要求のシーケンスと同じセッションIDを有する配列で始まる化合物中の再試行を送るべきです。ただし、クライアントには、先行する配列を有していない、または元CREATE_SESSION異なるセッションを指す前の配列を有するいずれかの化合物において、リトライを送信することができます。クライアントがセッションID Xと配列が先行COMPOUNDでCREATE_SESSIONを送信していない、とのセッションXがもう存在しない場合、これが必要になることがあります。かかわらず、先行SEQUENCEを伴うまたは伴わないCREATE_SESSIONのいずれかの再試行は、元としてcsa_sequenceの同じ値を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "After the client received a reply to an EXCHANGE_ID operation that contains a new, unconfirmed client ID, the server expects the client to follow with a CREATE_SESSION operation to confirm the client ID. The server expects value of csa_sequenceid in the arguments to that CREATE_SESSION to be to equal the value of the field eir_sequenceid that was returned in results of the EXCHANGE_ID that returned the unconfirmed client ID. Before the server replies to that EXCHANGE_ID operation, it initializes the client ID slot to be equal to eir_sequenceid - 1 (accounting for underflow), and records a contrived CREATE_SESSION result with a \"cached\" result of NFS4ERR_SEQ_MISORDERED. With the client ID slot thus initialized, the processing of the CREATE_SESSION operation is divided into four phases:",
      "ja": "クライアントが新しい、未確認のクライアントIDが含まれているEXCHANGE_ID操作に対する応答を受け取った後、サーバは、クライアントがクライアントのIDを確認するためにCREATE_SESSION操作に従うことを期待しています。サーバーは、そのCREATE_SESSIONの引数でcsa_sequenceidの値が未確認のクライアントIDを返さEXCHANGE_IDの結果で返されたフィールドeir_sequenceidの値を等しくすることを期待しています。 （アンダーフローを占める）1、及びNFS4ERR_SEQ_MISORDEREDの「キャッシュされた」結果に不自然CREATE_SESSION結果を記録する - サーバがそのEXCHANGE_ID操作に応答する前に、クライアントIDスロットはeir_sequenceidに等しくなるように初期化します。クライアントIDのスロットは、このように初期化して、CREATE_SESSION動作の処理は、4つのフェーズに分割されます。"
    },
    {
      "indent": 3,
      "text": "1. Client record look up. The server looks up the client ID in its client record table. If the server contains no records with client ID equal to clientid_arg, then most likely the client's state has been purged during a period of inactivity, possibly due to a loss of connectivity. NFS4ERR_STALE_CLIENTID is returned, and no changes are made to any client records on the server. Otherwise, the server goes to phase 2.",
      "ja": "1.クライアントレコードが見上げます。サーバは、そのクライアントレコードテーブル内のクライアントIDを検索します。サーバはclientid_argに等しいクライアントIDを持つレコードが含まれていない場合は、最も可能性の高いクライアントの状態はおそらく、接続の損失に、非アクティブの期間中にパージされました。 NFS4ERR_STALE_CLIENTIDが返され、変更は、サーバー上の任意のクライアントレコードに行われません。そうしないと、サーバはフェーズ2に移行します。"
    },
    {
      "indent": 3,
      "text": "2. Sequence ID processing. If csa_sequenceid is equal to the sequence ID in the client ID's slot, then this is a replay of the previous CREATE_SESSION request, and the server returns the cached result. If csa_sequenceid is not equal to the sequence ID in the slot, and is more than one greater (accounting for wraparound), then the server returns the error NFS4ERR_SEQ_MISORDERED, and does not change the slot. If csa_sequenceid is equal to the slot's sequence ID + 1 (accounting for wraparound), then the slot's sequence ID is set to csa_sequenceid, and the CREATE_SESSION processing goes to the next phase. A subsequent new CREATE_SESSION call over the same client ID MUST use a csa_sequenceid that is one greater than the sequence ID in the slot.",
      "ja": "2.シーケンスID処理。 csa_sequenceidは、クライアントIDのスロット内のシーケンスIDに等しい場合、これは、以前のCREATE_SESSION要求のリプレイであり、サーバはキャッシュされた結果を返します。 csa_sequenceidスロットのシーケンスIDと等しくない、および（ラップアラウンドを占める）2つ以上が大きい場合、サーバはエラーNFS4ERR_SEQ_MISORDEREDを返し、スロットを変更しません。 csa_sequenceidスロットのシーケンス番号+ 1（ラップアラウンドを占める）に等しい場合、スロットのシーケンスIDはcsa_sequenceidに設定され、CREATE_SESSION処理は、次のフェーズに進みます。同じクライアントIDの上に、その後の新しいCREATE_SESSIONコールは、スロット内のシーケンス番号より1大きいcsa_sequenceidを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. Client ID confirmation. If this would be the first session for the client ID, the CREATE_SESSION operation serves to confirm the client ID. Otherwise, the client ID confirmation phase is skipped and only the session creation phase occurs. Any case in which there is more than one record with identical values for client ID represents a server implementation error. Operation in the potential valid cases is summarized as follows.",
      "ja": "3.クライアントID確認。これは、クライアントIDのための最初のセッションになる場合は、CREATE_SESSION操作はクライアントのIDを確認するのに役立ちます。それ以外の場合は、クライアントIDの確認フェーズはスキップされ、唯一のセッション作成フェーズが発生します。クライアントIDのために同じ値を持つ複数のレコードが存在している任意の場合は、サーバーの実装エラーを表します。次のように潜在的な有効な場合の操作が要約されています。"
    },
    {
      "indent": 7,
      "text": "* Successful Confirmation",
      "ja": "*成功確認"
    },
    {
      "indent": 13,
      "text": "If the server has the following unconfirmed record, then\nthis is the expected confirmation of an unconfirmed record.",
      "raw": true
    },
    {
      "indent": 13,
      "text": "{ ownerid, verifier, principal_arg, clientid_arg, unconfirmed }",
      "ja": "{OWNERID、検証、principal_arg、clientid_arg、未確認}"
    },
    {
      "indent": 13,
      "text": "As noted in Section 18.35.4, the server might also have the following confirmed record.",
      "ja": "セクション18.35.4で述べたように、サーバーは、次の確認の記録を持っているかもしれません。"
    },
    {
      "indent": 13,
      "text": "{ ownerid, old_verifier, principal_arg, old_clientid, confirmed }",
      "ja": "{OWNERID、old_verifier、principal_arg、old_clientid、確認}"
    },
    {
      "indent": 13,
      "text": "The server schedules the replacement of both records with:",
      "ja": "サーバーのスケジュールとの両方のレコードの交換："
    },
    {
      "indent": 13,
      "text": "{ ownerid, verifier, principal_arg, clientid_arg, confirmed }",
      "ja": "{OWNERID、検証、principal_arg、clientid_arg、確認}"
    },
    {
      "indent": 13,
      "text": "The processing of CREATE_SESSION continues on to session creation. Once the session is successfully created, the scheduled client record replacement is committed. If the session is not successfully created, then no changes are made to any client records on the server.",
      "ja": "CREATE_SESSIONの処理は、セッションの作成に上で続けています。セッションが正常に作成されたら、予定のクライアントレコードの交換がコミットされます。セッションが正常に作成されていない場合は、変更は、サーバー上の任意のクライアントレコードに行われません。"
    },
    {
      "indent": 7,
      "text": "* Unsuccessful Confirmation",
      "ja": "*失敗確認"
    },
    {
      "indent": 13,
      "text": "If the server has the following record, then the client has\nchanged principals after the previous EXCHANGE_ID request,\nor there has been a chance collision between shorthand\nclient identifiers.",
      "raw": true
    },
    {
      "indent": 13,
      "text": "{ *, *, old_principal_arg, clientid_arg, * }",
      "ja": "{*、*、old_principal_arg、clientid_arg、*}"
    },
    {
      "indent": 13,
      "text": "Neither of these cases is permissible. Processing stops and NFS4ERR_CLID_INUSE is returned to the client. No changes are made to any client records on the server.",
      "ja": "これらの例はいずれも、許容されます。処理が停止し、NFS4ERR_CLID_INUSEがクライアントに返されます。変更は、サーバー上の任意のクライアントレコードに行われません。"
    },
    {
      "indent": 3,
      "text": "4. Session creation. The server confirmed the client ID, either in this CREATE_SESSION operation, or a previous CREATE_SESSION operation. The server examines the remaining fields of the arguments.",
      "ja": "4.セッションの作成。サーバーは、このCREATE_SESSION操作、または前CREATE_SESSION操作のいずれかで、クライアントのIDを確認しました。サーバーは、引数の残りのフィールドを調べます。"
    },
    {
      "indent": 7,
      "text": "The server creates the session by recording the parameter values\nused (including whether the CREATE_SESSION4_FLAG_PERSIST flag is\nset and has been accepted by the server) and allocating space for\nthe session reply cache (if there is not enough space, the server\nreturns NFS4ERR_NOSPC).  For each slot in the reply cache, the\nserver sets the sequence ID to zero, and records an entry\ncontaining a COMPOUND reply with zero operations and the error\nNFS4ERR_SEQ_MISORDERED.  This way, if the first SEQUENCE request\nsent has a sequence ID equal to zero, the server can simply\nreturn what is in the reply cache: NFS4ERR_SEQ_MISORDERED.  The\nclient initializes its reply cache for receiving callbacks in the\nsame way, and similarly, the first CB_SEQUENCE operation on a\nslot after session creation MUST have a sequence ID of one.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "If the session state is created successfully, the server associates the session with the client ID provided by the client.",
      "ja": "セッション状態が正常に作成されている場合は、サーバーは、クライアントによって提供されるクライアントIDとセッションを関連付けます。"
    },
    {
      "indent": 7,
      "text": "When a request that had CREATE_SESSION4_FLAG_CONN_RDMA set needs to be retried, the retry MUST be done on a new connection that is in non-RDMA mode. If properties of the new connection are different enough that the arguments to CREATE_SESSION need to change, then a non-retry MUST be sent. The server will eventually dispose of any session that was created on the original connection.",
      "ja": "CREATE_SESSION4_FLAG_CONN_RDMAセットを持っていた要求を再試行する必要がある場合、再試行が非RDMAモードになっている新しい接続で行う必要があります。新しい接続のプロパティがCREATE_SESSIONへの引数は変更する必要があることを十分に異なっている場合には、非リトライが送らなければなりません。サーバーは最終的に元の接続で作成されたすべてのセッションを処分します。"
    },
    {
      "indent": 3,
      "text": "On the backchannel, the client and server might wish to have many slots, in some cases perhaps more that the fore channel, in order to deal with the situations where the network link has high latency and is the primary bottleneck for response to recalls. If so, and if the client provides too few slots to the backchannel, the server might limit the number of recallable objects it gives to the client.",
      "ja": "バックチャネルでは、クライアントとサーバは、ネットワークリンクが高く、待ち時間があり、リコールへの対応のための主要なボトルネックとなっている状況に対処するために、前部チャネルそのおそらくよりいくつかのケースでは、多くのスロットを持つことを望むかもしれません。その場合、クライアントはバックチャネルに少なすぎるのスロットを提供する場合、サーバはクライアントに与えるリコールオブジェクトの数が制限される場合があります。"
    },
    {
      "indent": 3,
      "text": "Implementing RPCSEC_GSS callback support requires changes to both the client and server implementations of RPCSEC_GSS. One possible set of changes includes:",
      "ja": "RPCSEC_GSSコールバックのサポートを実装するRPCSEC_GSSの両方のクライアントとサーバーの実装を変更する必要があります。変化の一つの可能​​なセットが含まれています："
    },
    {
      "indent": 3,
      "text": "o Adding a data structure that wraps the GSS-API context with a reference count.",
      "ja": "O参照カウントとGSS-APIコンテキストをラップするデータ構造を追加します。"
    },
    {
      "indent": 3,
      "text": "o New functions to increment and decrement the reference count. If the reference count is decremented to zero, the wrapper data structure and the GSS-API context it refers to would be freed.",
      "ja": "Oの新機能は、参照カウントをインクリメントし、デクリメントします。参照カウントがゼロにされている場合は、ラッパーのデータ構造とGSS-APIコンテキストはそれが解放されるだろうことをいいます。"
    },
    {
      "indent": 3,
      "text": "o Change RPCSEC_GSS to create the wrapper data structure upon receiving GSS-API context from gss_accept_sec_context() and gss_init_sec_context(). The reference count would be initialized to 1.",
      "ja": "O変更場合gss_accept_sec_context（からGSS-APIのコンテキストを受信すると、ラッパー・データ構造を作成するRPCSEC_GSS）とにgss_init_sec_context（）。参照カウントは1に初期化されるだろう。"
    },
    {
      "indent": 3,
      "text": "o Adding a function to map an existing RPCSEC_GSS handle to a pointer to the wrapper data structure. The reference count would be incremented.",
      "ja": "Oラッパー・データ構造へのポインタを既存のRPCSEC_GSSハンドルをマッピングする機能を追加します。参照カウントがインクリメントされます。"
    },
    {
      "indent": 3,
      "text": "o Adding a function to create a new RPCSEC_GSS handle from a pointer to the wrapper data structure. The reference count would be incremented.",
      "ja": "Oラッパー・データ構造へのポインタから新たなRPCSEC_GSSハンドルを作成する機能を追加します。参照カウントがインクリメントされます。"
    },
    {
      "indent": 3,
      "text": "o Replacing calls from RPCSEC_GSS that free GSS-API contexts, with calls to decrement the reference count on the wrapper data structure.",
      "ja": "通話と無料のGSS-APIコンテキストは、ラッパーのデータ構造の参照カウントをデクリメントすることRPCSEC_GSSからの呼び出しを置き換えるO。"
    },
    {
      "indent": 0,
      "text": "18.37. Operation 44: DESTROY_SESSION - Destroy a Session",
      "section_title": true,
      "ja": "18.37. 操作44：DESTROY_SESSION  - セッションを破壊します"
    },
    {
      "indent": 0,
      "text": "18.37.1. ARGUMENT",
      "section_title": true,
      "ja": "18.37.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct DESTROY_SESSION4args {\n        sessionid4      dsa_sessionid;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.37.2. RESULT",
      "section_title": true,
      "ja": "18.37.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct DESTROY_SESSION4res {\n        nfsstat4        dsr_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.37.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.37.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The DESTROY_SESSION operation closes the session and discards the session's reply cache, if any. Any remaining connections associated with the session are immediately disassociated. If the connection has no remaining associated sessions, the connection MAY be closed by the server. Locks, delegations, layouts, wants, and the lease, which are all tied to the client ID, are not affected by DESTROY_SESSION.",
      "ja": "もしあればDESTROY_SESSION操作は、セッションを閉じ、セッションの応答キャッシュを破棄します。セッションに関連付けられている任意の残りの接続が直ちに関連付けが解除されています。接続が残っ関連するセッションを持っていない場合は、接続がサーバによって閉じられてもよいです。ロック、代表団、レイアウトは、望んでいる、とすべてのクライアントIDに関連付けられているリースは、DESTROY_SESSIONの影響を受けません。"
    },
    {
      "indent": 3,
      "text": "DESTROY_SESSION MUST be invoked on a connection that is associated with the session being destroyed. In addition, if SP4_MACH_CRED state protection was specified when the client ID was created, the RPCSEC_GSS principal that created the session MUST be the one that destroys the session, using RPCSEC_GSS privacy or integrity. If SP4_SSV state protection was specified when the client ID was created, RPCSEC_GSS using the SSV mechanism (Section 2.10.9) MUST be used, with integrity or privacy.",
      "ja": "DESTROY_SESSIONセッションが破壊されると関連付けられている接続上で呼び出さなければなりません。また、クライアントIDが作成されたときSP4_MACH_CRED状態の保護が指定された場合は、RPCSEC_GSSプライバシーや整合性を使用して、セッションを破壊する1でなければならないのセッションを作成しRPCSEC_GSSプリンシパル。クライアントIDが作成されたときSP4_SSV状態の保護が指定された場合は、SSVメカニズム（セクション2.10.9）を使用して、RPCSEC_GSSは、整合性やプライバシーを、使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the COMPOUND request starts with SEQUENCE, and if the sessionids specified in SEQUENCE and DESTROY_SESSION are the same, then",
      "ja": "COMPOUND要求は、SEQUENCEで始まる場合、およびSEQUENCEとDESTROY_SESSIONで指定sessionidsはその後、同じであれば、"
    },
    {
      "indent": 3,
      "text": "o DESTROY_SESSION MUST be the final operation in the COMPOUND request.",
      "ja": "O DESTROY_SESSIONは、複合要求の最後の操作でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o It is advisable to avoid placing DESTROY_SESSION in a COMPOUND request with other state-modifying operations, because the DESTROY_SESSION will destroy the reply cache.",
      "ja": "彼らはSESSIONが応答キャッシュを破壊するDESTROYのでO他の状態変更などの操作を有する化合物の要求にSESSIONを破壊置くことを避けることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o Because the session and its reply cache are destroyed, a client that retries the request may receive an error in reply to the retry, even though the original request was successful.",
      "ja": "セッションとその応答のキャッシュが破壊されているので、O、要求を再試行するクライアントは、元の要求が成功したにも関わらず、再試行への応答でエラーが発生することがあります。"
    },
    {
      "indent": 3,
      "text": "If the COMPOUND request starts with SEQUENCE, and if the sessionids specified in SEQUENCE and DESTROY_SESSION are different, then DESTROY_SESSION can appear in any position of the COMPOUND request (except for the first position). The two sessionids can belong to different client IDs.",
      "ja": "複合要求がシーケンスで始まる場合、シーケンス及びDESTROY_SESSIONで指定sessionidsが異なる場合、DESTROY_SESSIONは、（第一の位置を除く）複合要求の任意の位置に表示できます。 2 sessionidsは異なるクライアントIDに属することができます。"
    },
    {
      "indent": 3,
      "text": "If the COMPOUND request does not start with SEQUENCE, and if DESTROY_SESSION is not the sole operation, then server MUST return NFS4ERR_NOT_ONLY_OP.",
      "ja": "COMPOUND要求がSEQUENCEに起動しない場合、およびDESTROY_SESSIONは唯一運転されていない場合、サーバーはNFS4ERR_NOT_ONLY_OPを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If there is a backchannel on the session and the server has outstanding CB_COMPOUND operations for the session which have not been replied to, then the server MAY refuse to destroy the session and return an error. If so, then in the event the backchannel is down, the server SHOULD return NFS4ERR_CB_PATH_DOWN to inform the client that the backchannel needs to be repaired before the server will allow the session to be destroyed. Otherwise, the error CB_BACK_CHAN_BUSY SHOULD be returned to indicate that there are CB_COMPOUNDs that need to be replied to. The client SHOULD reply to all outstanding CB_COMPOUNDs before re-sending DESTROY_SESSION.",
      "ja": "そこセッションのバックチャネルであり、サーバーが回答されていないセッションのための優れたCB_COMPOUND操作を持っている場合、サーバーは、セッションを破棄し、エラーを返すことを拒否することができます。そう、そのイベントにバックチャネルがダウンしている場合、サーバは、サーバは、セッションが破棄されることを可能にする前に、バックチャネルを修復する必要があるクライアントに通知するNFS4ERR_CB_PATH_DOWNを返すべきです。そうでない場合は、エラーCB_BACK_CHAN_BUSYはに答えする必要がCB_COMPOUNDsがあることを示すために返されるべきです。クライアントはDESTROY_SESSIONを再送信する前にすべての未CB_COMPOUNDsに返信すべきです。"
    },
    {
      "indent": 0,
      "text": "18.38. Operation 45: FREE_STATEID - Free Stateid with No Locks",
      "section_title": true,
      "ja": "18.38. 操作45：FREE_STATEID  - ノーロックで無料STATEID"
    },
    {
      "indent": 0,
      "text": "18.38.1. ARGUMENT",
      "section_title": true,
      "ja": "18.38.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct FREE_STATEID4args {\n        stateid4        fsa_stateid;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.38.2. RESULT",
      "section_title": true,
      "ja": "18.38.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct FREE_STATEID4res {\n        nfsstat4        fsr_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.38.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.38.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The FREE_STATEID operation is used to free a stateid that no longer has any associated locks (including opens, byte-range locks, delegations, and layouts). This may be because of client LOCKU operations or because of server revocation. If there are valid locks (of any kind) associated with the stateid in question, the error NFS4ERR_LOCKS_HELD will be returned, and the associated stateid will not be freed.",
      "ja": "FREE_STATEID動作はもはや（開き、バイト範囲ロック、代表団、およびレイアウトを含む）任意の関連するロックを持っていないのstateidを解放するために使用されます。これは、クライアントLOCKU操作のため、またはサーバーの取消しのものであってもよいです。問題になっているのstateidに関連付けられている（あらゆる種類の）有効なロックがある場合は、エラーNFS4ERR_LOCKS_HELDが返され、および関連のstateidは解放されません。"
    },
    {
      "indent": 3,
      "text": "When a stateid is freed that had been associated with revoked locks, by sending the FREE_STATEID operation, the client acknowledges the loss of those locks. This allows the server, once all such revoked state is acknowledged, to allow that client again to reclaim locks, without encountering the edge conditions discussed in Section 8.4.2.",
      "ja": "stateidはFREE_STATEID操作を送信することにより、失効したロックに関連付けられていたという解放されると、クライアントはそれらのロックの喪失を認めています。これは、サーバ、一度そのようなすべての取り消された状態が確認されたが、そのクライアントが再び8.4.2項で説明したエッジ条件に遭遇することなく、ロックを再利用できるようにすることができます。"
    },
    {
      "indent": 3,
      "text": "Once a successful FREE_STATEID is done for a given stateid, any subsequent use of that stateid will result in an NFS4ERR_BAD_STATEID error.",
      "ja": "成功FREE_STATEIDが与えられたstateidのために行われると、そののstateidの任意のその後の使用はNFS4ERR_BAD_STATEIDエラーになります。"
    },
    {
      "indent": 0,
      "text": "18.39. Operation 46: GET_DIR_DELEGATION - Get a Directory Delegation",
      "section_title": true,
      "ja": "18.39. 操作46：GET_DIR_DELEGATION  - ディレクトリ委任を取得"
    },
    {
      "indent": 0,
      "text": "18.39.1. ARGUMENT",
      "section_title": true,
      "ja": "18.39.1. 引数"
    },
    {
      "indent": 3,
      "text": "typedef nfstime4 attr_notice4;",
      "ja": "typedefのnfstime4 attr_notice4。"
    },
    {
      "indent": 3,
      "text": "struct GET_DIR_DELEGATION4args {\n        /* CURRENT_FH: delegated directory */\n        bool            gdda_signal_deleg_avail;\n        bitmap4         gdda_notification_types;\n        attr_notice4    gdda_child_attr_delay;\n        attr_notice4    gdda_dir_attr_delay;\n        bitmap4         gdda_child_attributes;\n        bitmap4         gdda_dir_attributes;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.39.2. RESULT",
      "section_title": true,
      "ja": "18.39.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct GET_DIR_DELEGATION4resok {\n        verifier4       gddr_cookieverf;\n        /* Stateid for get_dir_delegation */\n        stateid4        gddr_stateid;\n        /* Which notifications can the server support */\n        bitmap4         gddr_notification;\n        bitmap4         gddr_child_attributes;\n        bitmap4         gddr_dir_attributes;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "enum gddrnf4_status { GDD4_OK = 0, GDD4_UNAVAIL = 1 };",
      "ja": "列挙gddrnf4_status {GDD4_OK = 0、GDD4_UNAVAIL = 1}。"
    },
    {
      "indent": 3,
      "text": "union GET_DIR_DELEGATION4res_non_fatal\n switch (gddrnf4_status gddrnf_status) {\n case GDD4_OK:\n  GET_DIR_DELEGATION4resok      gddrnf_resok4;\n case GDD4_UNAVAIL:\n  bool                          gddrnf_will_signal_deleg_avail;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union GET_DIR_DELEGATION4res\n switch (nfsstat4 gddr_status) {\n case NFS4_OK:\n  GET_DIR_DELEGATION4res_non_fatal      gddr_res_non_fatal4;\n default:\n  void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.39.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.39.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The GET_DIR_DELEGATION operation is used by a client to request a directory delegation. The directory is represented by the current filehandle. The client also specifies whether it wants the server to notify it when the directory changes in certain ways by setting one or more bits in a bitmap. The server may refuse to grant the delegation. In that case, the server will return NFS4ERR_DIRDELEG_UNAVAIL. If the server decides to hand out the delegation, it will return a cookie verifier for that directory. If the cookie verifier changes when the client is holding the delegation, the delegation will be recalled unless the client has asked for notification for this event.",
      "ja": "GET_DIR_DELEGATION操作は、ディレクトリ委任を要求するためにクライアントによって使用されます。ディレクトリは、現在のファイルハンドルによって表されます。また、クライアントはそれを通知するために、サーバーを望んでいるかどうかを指定する場合、ビットマップ内の1つのまたは複数のビットを設定することによって、特定の方法でディレクトリの変更。サーバーは委託を付与するために拒否することができます。その場合、サーバーはNFS4ERR_DIRDELEG_UNAVAILを返します。サーバが委任を配ることを決定した場合、そのディレクトリのクッキー検証を返します。クライアントが委任を保持している際に、クッキー検証が変更された場合、クライアントがこのイベントの通知を求めていない限り、代表団が想起されます。"
    },
    {
      "indent": 3,
      "text": "The server will also return a directory delegation stateid, gddr_stateid, as a result of the GET_DIR_DELEGATION operation. This stateid will appear in callback messages related to the delegation, such as notifications and delegation recalls. The client will use this stateid to return the delegation voluntarily or upon recall. A delegation is returned by calling the DELEGRETURN operation.",
      "ja": "また、サーバはGET_DIR_DELEGATION操作の結果として、ディレクトリ委任のstateid、gddr_stateidを返します。これのstateidは、このような通知と委任リコールなどの委任に関連するコールバックメッセージに表示されます。クライアントは、自発的にまたはリコール時に委任を返すために、このたstateidを使用します。代表団はDELEGRETURN操作を呼び出すことによって返されます。"
    },
    {
      "indent": 3,
      "text": "The server might not be able to support notifications of certain events. If the client asks for such notifications, the server MUST inform the client of its inability to do so as part of the GET_DIR_DELEGATION reply by not setting the appropriate bits in the supported notifications bitmask, gddr_notification, contained in the reply. The server MUST NOT add bits to gddr_notification that the client did not request.",
      "ja": "サーバーは、特定のイベントの通知をサポートすることができない場合があります。クライアントは、このような通知を要求した場合、サーバは応答に含まれているサポートの通知ビットマスク、gddr_notification、中に適切なビットを設定しないことにより、GET_DIR_DELEGATION応答の一部として、そうすることができないことをクライアントに通知しなければなりません。サーバーは、クライアントが要求しなかったことをgddr_notificationするビットを追加してはなりません。"
    },
    {
      "indent": 3,
      "text": "The GET_DIR_DELEGATION operation can be used for both normal and named attribute directories.",
      "ja": "GET_DIR_DELEGATION操作は、通常と名付けられた属性ディレクトリの両方のために使用することができます。"
    },
    {
      "indent": 3,
      "text": "If client sets gdda_signal_deleg_avail to TRUE, then it is registering with the client a \"want\" for a directory delegation. If the delegation is not available, and the server supports and will honor the \"want\", the results will have gddrnf_will_signal_deleg_avail set to TRUE and no error will be indicated on return. If so, the client should expect a future CB_RECALLABLE_OBJ_AVAIL operation to indicate that a directory delegation is available. If the server does not wish to honor the",
      "ja": "クライアントのセットがTRUEにgdda_signal_deleg_avail場合、それは、ディレクトリ委任のための「欲しい」クライアントに登録されています。代表団は利用できず、サーバがサポートしており、「欲しい」尊重するならば、結果がTRUEに設定さgddrnf_will_signal_deleg_avail有することになり、エラーがリターンに表示されません。その場合、クライアントは将来CB_RECALLABLE_OBJ_AVAIL操作はディレクトリの代表団が利用可能であることを示すことを期待すべきです。サーバーは、名誉を希望しない場合"
    },
    {
      "indent": 3,
      "text": "\"want\" or is not able to do so, it returns the error NFS4ERR_DIRDELEG_UNAVAIL. If the delegation is immediately available, the server SHOULD return it with the response to the operation, rather than via a callback.",
      "ja": "「欲しい」またはそうすることはできません、それはエラーNFS4ERR_DIRDELEG_UNAVAILを返します。代表団は、すぐに使用可能な場合、サーバーではなく、コールバックを経由して、操作に応答して、それを返すべきです。"
    },
    {
      "indent": 3,
      "text": "When a client makes a request for a directory delegation while it already holds a directory delegation for that directory (including the case where it has been recalled but not yet returned by the client or revoked by the server), the server MUST reply with the value of gddr_status set to NFS4_OK, the value of gddrnf_status set to GDD4_UNAVAIL, and the value of gddrnf_will_signal_deleg_avail set to FALSE. The delegation the client held before the request remains intact, and its state is unchanged. The current stateid is not changed (see Section 16.2.3.1.2 for a description of the current stateid).",
      "ja": "それはすでに（それはリコールがまだサーバーがクライアントから返されたか、失効していないされている場合を含む）は、そのディレクトリのディレクトリ委任を保持しながら、クライアントがディレクトリの委任を要求すると、サーバは値で返答しなければなりませんgddr_statusのNFS4_OK、GDD4_UNAVAILに設定gddrnf_statusの値、およびFALSEに設定gddrnf_will_signal_deleg_availの値に設定します。クライアントが要求する前に開催された代表団はそのまま残り、そしてその状態は変更されません。現在のstateidは、（現在のstateidの説明はセクション16.2.3.1.2を参照）変更されません。"
    },
    {
      "indent": 0,
      "text": "18.39.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.39.4. 実装"
    },
    {
      "indent": 3,
      "text": "Directory delegations provide the benefit of improving cache consistency of namespace information. This is done through synchronous callbacks. A server must support synchronous callbacks in order to support directory delegations. In addition to that, asynchronous notifications provide a way to reduce network traffic as well as improve client performance in certain conditions.",
      "ja": "ディレクトリ代表団は、名前空間情報のキャッシュの一貫性を向上させることの利点を提供します。これは、同期コールバックを介して行われます。サーバーは、ディレクトリの代表団をサポートするために、同期コールバックをサポートしている必要があります。それに加えて、非同期通知は、ネットワークトラフィックを削減するだけでなく、特定の条件でのクライアントのパフォーマンスを改善するための方法を提供します。"
    },
    {
      "indent": 3,
      "text": "Notifications are specified in terms of potential changes to the directory. A client can ask to be notified of events by setting one or more bits in gdda_notification_types. The client can ask for notifications on addition of entries to a directory (by setting the NOTIFY4_ADD_ENTRY in gdda_notification_types), notifications on entry removal (NOTIFY4_REMOVE_ENTRY), renames (NOTIFY4_RENAME_ENTRY), directory attribute changes (NOTIFY4_CHANGE_DIR_ATTRIBUTES), and cookie verifier changes (NOTIFY4_CHANGE_COOKIE_VERIFIER) by setting one or more corresponding bits in the gdda_notification_types field.",
      "ja": "通知は、ディレクトリへの電位変化の観点で指定されています。クライアントはgdda_notification_typesに1つ以上のビットを設定することで、イベントが通知されるように依頼することができます。クライアントは、エントリの削除（NOTIFY4_REMOVE_ENTRY）、リネーム（NOTIFY4_RENAME_ENTRY）、ディレクトリ上の通知が変化（NOTIFY4_CHANGE_DIR_ATTRIBUTES）、およびクッキー検証の変更（NOTIFY4_CHANGE_COOKIE_VERIFIER）によって属性（gdda_notification_typesでNOTIFY4_ADD_ENTRYを設定することによって）ディレクトリへのエントリの追加の通知を求めることができますgdda_notification_typesフィールドに1つまたは複数の対応するビットを設定します。"
    },
    {
      "indent": 3,
      "text": "The client can also ask for notifications of changes to attributes of directory entries (NOTIFY4_CHANGE_CHILD_ATTRIBUTES) in order to keep its attribute cache up to date. However, any changes made to child attributes do not cause the delegation to be recalled. If a client is interested in directory entry caching or negative name caching, it can set the gdda_notification_types appropriately to its particular need and the server will notify it of all changes that would otherwise invalidate its name cache. The kind of notification a client asks for may depend on the directory size, its rate of change, and the applications being used to access that directory. The enumeration of the conditions under which a client might ask for a notification is out of the scope of this specification.",
      "ja": "また、クライアントは最新の属性キャッシュを維持するために、ディレクトリエントリ（NOTIFY4_CHANGE_CHILD_ATTRIBUTES）の属性への変更の通知を求めることができます。ただし、子の属性に加えた変更は、代表団がリコールされることはありません。クライアントは、ディレクトリエントリのキャッシュや、ネガティブ名前キャッシュに興味があるならば、それはその特定のニーズに適切にgdda_notification_typesを設定することができ、サーバはそれ以外の場合は、その名前のキャッシュを無効になり、すべての変更を、それを通知します。ディレクトリのサイズ、その変化率、およびそのディレクトリにアクセスするために使用されているアプリケーションに依存してもよいため、通知の種類クライアントが要求します。クライアントが通知を求める可能性のある条件の列挙は、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "For attribute notifications, the client will set bits in the gdda_dir_attributes bitmap to indicate which attributes it wants to be notified of. If the server does not support notifications for changes to a certain attribute, it SHOULD NOT set that attribute in the supported attribute bitmap specified in the reply (gddr_dir_attributes). The client will also set in the gdda_child_attributes bitmap the attributes of directory entries it wants to be notified of, and the server will indicate in gddr_child_attributes which attributes of directory entries it will notify the client of.",
      "ja": "属性通知の場合、クライアントはそれをを通知することを希望する属性を示すために、gdda_dir_attributesビットマップのビットを設定します。サーバは特定の属性への変更の通知をサポートしていない場合、それはリプライ（gddr_dir_attributes）に指定されたサポートされる属性のビットマップでその属性を設定しないでください。また、クライアントはgdda_child_attributesに設定されます、それはを通知することを希望するディレクトリエントリの属性をビットマップ、およびサーバはクライアントに通知するディレクトリエントリの属性gddr_child_attributesに示します。"
    },
    {
      "indent": 3,
      "text": "The client will also let the server know if it wants to get the notification as soon as the attribute change occurs or after a certain delay by setting a delay factor; gdda_child_attr_delay is for attribute changes to directory entries and gdda_dir_attr_delay is for attribute changes to the directory. If this delay factor is set to zero, that indicates to the server that the client wants to be notified of any attribute changes as soon as they occur. If the delay factor is set to N seconds, the server will make a best-effort guarantee that attribute updates are synchronized within N seconds. If the client asks for a delay factor that the server does not support or that may cause significant resource consumption on the server by causing the server to send a lot of notifications, the server should not commit to sending out notifications for attributes and therefore must not set the appropriate bit in the gddr_child_attributes and gddr_dir_attributes bitmaps in the response.",
      "ja": "また、クライアントは、それができるだけ早く属性変更が発生するか、遅延係数を設定することにより、一定の遅延後などの通知を取得したい場合は、サーバーに知らせます。 gdda_child_attr_delayは、ディレクトリエントリへの属性の変更のためのものであり、gdda_dir_attr_delayは、ディレクトリへの属性の変更のためです。この遅延係数がゼロに設定されている場合、それは、クライアントが、すぐに彼らが起こるように変更任意の属性を通知することを希望するサーバに示します。遅延率がN秒に設定されている場合、サーバーはN秒以内に同期されているアップデートの属性ベストエフォート保証を行います。クライアントが遅延要因を要求した場合、サーバがサポートしていないか、またはそれは、通知の多くを送信するために、サーバーを引き起こすことによって、サーバー上の重要なリソース消費を引き起こすかもしれない、サーバーはそのためではない必要がある属性のための通知を送信することを約束してはいけませんgddr_child_attributesに適切なビットを設定し、それに応答してビットマップをgddr_dir_attributes。"
    },
    {
      "indent": 3,
      "text": "The client MUST use a security tuple (Section 2.6.1) that the directory or its applicable ancestor (Section 2.6) is exported with. If not, the server MUST return NFS4ERR_WRONGSEC to the operation that both precedes GET_DIR_DELEGATION and sets the current filehandle (see Section 2.6.3.1).",
      "ja": "クライアントは、ディレクトリやその適用祖先（2.6節）をしてエクスポートされたセキュリティタプル（2.6.1）を使用する必要があります。 、サーバーが両方ともGET_DIR_DELEGATIONの前に、現在のファイルハンドルを設定操作にNFS4ERR_WRONGSECを返さなければならない場合（セクション2.6.3.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The directory delegation covers all the entries in the directory except the parent entry. That means if a directory and its parent both hold directory delegations, any changes to the parent will not cause a notification to be sent for the child even though the child's parent entry points to the parent directory.",
      "ja": "ディレクトリ代表団は親エントリを除くディレクトリ内のすべてのエントリをカバーしています。それは、ディレクトリとその親の両方がディレクトリ代表団を保持している場合、親への変更が通知が親ディレクトリにも、子供の親エントリポイントかかわらず子供のために送信されることはありませんを意味します。"
    },
    {
      "indent": 0,
      "text": "18.40. Operation 47: GETDEVICEINFO - Get Device Information",
      "section_title": true,
      "ja": "18.40. 操作47：GETDEVICEINFO  - デバイス情報を取得します。"
    },
    {
      "indent": 0,
      "text": "18.40.1. ARGUMENT",
      "section_title": true,
      "ja": "18.40.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct GETDEVICEINFO4args {\n        deviceid4       gdia_device_id;\n        layouttype4     gdia_layout_type;\n        count4          gdia_maxcount;\n        bitmap4         gdia_notify_types;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.40.2. RESULT",
      "section_title": true,
      "ja": "18.40.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct GETDEVICEINFO4resok {\n        device_addr4    gdir_device_addr;\n        bitmap4         gdir_notification;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union GETDEVICEINFO4res switch (nfsstat4 gdir_status) {\ncase NFS4_OK:\n        GETDEVICEINFO4resok     gdir_resok4;\ncase NFS4ERR_TOOSMALL:\n        count4                  gdir_mincount;\ndefault:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.40.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.40.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The GETDEVICEINFO operation returns pNFS storage device address information for the specified device ID. The client identifies the device information to be returned by providing the gdia_device_id and gdia_layout_type that uniquely identify the device. The client provides gdia_maxcount to limit the number of bytes for the result. This maximum size represents all of the data being returned within the GETDEVICEINFO4resok structure and includes the XDR overhead. The server may return less data. If the server is unable to return any information within the gdia_maxcount limit, the error NFS4ERR_TOOSMALL will be returned. However, if gdia_maxcount is zero, NFS4ERR_TOOSMALL MUST NOT be returned.",
      "ja": "GETDEVICEINFO操作は、指定されたデバイスIDのpNFSの記憶装置アドレス情報を返します。クライアントは、デバイスを一意に識別gdia_device_idとgdia_layout_typeを提供することによって返されるデバイス情報を識別する。クライアントは、結果のバイト数を制限するgdia_maxcount提供します。この最大サイズはGETDEVICEINFO4resok構造内に返されるすべてのデータを表し、XDRオーバーヘッドを含みます。サーバーは、少ないデータを返すことがあります。サーバがgdia_maxcount制限内の任意の情報を返すことができない場合、エラーNFS4ERR_TOOSMALLが返されます。 gdia_maxcountがゼロの場合は、NFS4ERR_TOOSMALLが返されてはなりません。"
    },
    {
      "indent": 3,
      "text": "The da_layout_type field of the gdir_device_addr returned by the server MUST be equal to the gdia_layout_type specified by the client. If it is not equal, the client SHOULD ignore the response as invalid and behave as if the server returned an error, even if the client does have support for the layout type returned.",
      "ja": "サーバから返さgdir_device_addrのda_layout_typeフィールドは、クライアントによって指定さgdia_layout_typeに等しくなければなりません。それが等しくない場合、クライアントは無効としてレスポンスを無視すべきであると、サーバーは、クライアントが返されたレイアウトタイプをサポートしていない場合でも、エラーを返したかのように振る舞います。"
    },
    {
      "indent": 3,
      "text": "The client also provides a notification bitmap, gdia_notify_types, for the device ID mapping notification for which it is interested in receiving; the server must support device ID notifications for the notification request to have affect. The notification mask is composed in the same manner as the bitmap for file attributes (Section 3.3.7). The numbers of bit positions are listed in the notify_device_type4 enumeration type (Section 20.12). Only two enumerated values of notify_device_type4 currently apply to GETDEVICEINFO: NOTIFY_DEVICEID4_CHANGE and NOTIFY_DEVICEID4_DELETE (see Section 20.12).",
      "ja": "クライアントはまた、受信に関心されたデバイスIDマッピング通知の通知ビットマップ、gdia_notify_typesを提供します。通知要求が影響を与える持っているため、サーバは、デバイスIDの通知をサポートしている必要があります。通知マスクは、ファイル属性（セクション3.3.7）のためのビットマップと同様に構成されています。ビット位置の数はnotify_device_type4列挙タイプ（セクション20.12）に記載されています。 notify_device_type4の2つだけ列挙値は、現在GETDEVICEINFOに適用されます。NOTIFY_DEVICEID4_CHANGEとNOTIFY_DEVICEID4_DELETE（項20.12を参照してください）。"
    },
    {
      "indent": 3,
      "text": "The notification bitmap applies only to the specified device ID. If a client sends a GETDEVICEINFO operation on a deviceID multiple times, the last notification bitmap is used by the server for subsequent notifications. If the bitmap is zero or empty, then the device ID's notifications are turned off.",
      "ja": "通知ビットマップは、指定されたデバイスIDに適用されます。クライアントはdeviceIDの複数回にGETDEVICEINFO操作を送信した場合は、最後の通知ビットマップは、後続の通知のためにサーバーによって使用されます。ビットマップがゼロまたは空の場合、デバイスIDの通知はオフになっています。"
    },
    {
      "indent": 3,
      "text": "If the client wants to just update or turn off notifications, it MAY send a GETDEVICEINFO operation with gdia_maxcount set to zero. In that event, if the device ID is valid, the reply's da_addr_body field of the gdir_device_addr field will be of zero length.",
      "ja": "クライアントは、ちょうど更新または通知をオフにしたい場合は、それがゼロにgdia_maxcountセットでGETDEVICEINFO操作を送信することができます。デバイスIDが有効である場合は、そのイベントでは、gdir_device_addrフィールドの回答者da_addr_bodyフィールドはゼロの長さになります。"
    },
    {
      "indent": 3,
      "text": "If an unknown device ID is given in gdia_device_id, the server returns NFS4ERR_NOENT. Otherwise, the device address information is returned in gdir_device_addr. Finally, if the server supports notifications for device ID mappings, the gdir_notification result will contain a bitmap of which notifications it will actually send to the client (via CB_NOTIFY_DEVICEID, see Section 20.12).",
      "ja": "不明なデバイスIDがgdia_device_idに指定された場合、サーバはNFS4ERR_NOENTを返します。そうでない場合は、デバイスのアドレス情報をgdir_device_addrに返されます。サーバは、デバイスIDのマッピングのための通知をサポートしている場合最後に、gdir_notification結果は（CB_NOTIFY_DEVICEIDを経由して、セクション20.12を参照）、それは実際にクライアントに送信されますどの通知のビットマップが含まれています。"
    },
    {
      "indent": 3,
      "text": "If NFS4ERR_TOOSMALL is returned, the results also contain gdir_mincount. The value of gdir_mincount represents the minimum size necessary to obtain the device information.",
      "ja": "NFS4ERR_TOOSMALLが返された場合、結果もまたgdir_mincountが含まれています。 gdir_mincountの値は、デバイス情報を得るために必要な最小サイズを表します。"
    },
    {
      "indent": 0,
      "text": "18.40.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.40.4. 実装"
    },
    {
      "indent": 3,
      "text": "Aside from updating or turning off notifications, another use case for gdia_maxcount being set to zero is to validate a device ID.",
      "ja": "別に更新または通知をオフにすることから、ゼロに設定されるgdia_maxcountための別のユースケースは、デバイスIDを検証することです。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD request a notification for changes or deletion of a device ID to device address mapping so that the server can allow the client gracefully use a new mapping, without having pending I/O fail abruptly, or force layouts using the device ID to be recalled or revoked.",
      "ja": "クライアントがあることを、デバイスIDを使用して、サーバーは、クライアントが優雅にI / Oが突然失敗保留せずに、新しいマッピングを使用できるようにすることができるように、デバイスのアドレスマッピングへのデバイスIDの変更や削除のための通知を要求、または力のレイアウトすべきですリコールまたは取り消します。"
    },
    {
      "indent": 3,
      "text": "It is possible that GETDEVICEINFO (and GETDEVICELIST) will race with CB_NOTIFY_DEVICEID, i.e., CB_NOTIFY_DEVICEID arrives before the client gets and processes the response to GETDEVICEINFO or",
      "ja": "GETDEVICEINFO（およびGETDEVICELIST）はCB_NOTIFY_DEVICEIDでレースをする可能性があり、クライアントがGETDEVICEINFOかへの応答を取得し、処理する前に、すなわち、CB_NOTIFY_DEVICEIDが到着します"
    },
    {
      "indent": 3,
      "text": "GETDEVICELIST. The analysis of the race leverages the fact that the server MUST NOT delete a device ID that is referred to by a layout the client has.",
      "ja": "GETDEVICELIST。レースの分析では、サーバは、クライアントが持っていレイアウトによって参照されているデバイスIDを削除してはならないという事実を利用しています。"
    },
    {
      "indent": 3,
      "text": "o CB_NOTIFY_DEVICEID deletes a device ID. If the client believes it has layouts that refer to the device ID, then it is possible that layouts referring to the deleted device ID have been revoked. The client should send a TEST_STATEID request using the stateid for each layout that might have been revoked. If TEST_STATEID indicates that any layouts have been revoked, the client must recover from layout revocation as described in Section 12.5.6. If TEST_STATEID indicates that at least one layout has not been revoked, the client should send a GETDEVICEINFO operation on the supposedly deleted device ID to verify that the device ID has been deleted.",
      "ja": "O CB_NOTIFY_DEVICEIDは、デバイスIDを削除します。クライアントは、それがデバイスIDを参照するレイアウトを有していると考えている場合、削除されたデバイスIDを参照レイアウトが取り消されている可能性があります。クライアントが取り消された可能性があります各レイアウトのためのstateidを使用してTEST_STATEID要求を送信する必要があります。 TEST_STATEIDは、任意のレイアウトが失効していることを示している場合は、セクション12.5.6で説明したように、クライアントは、レイアウトの失効から回復しなければなりません。 TEST_STATEIDは、少なくとも1つのレイアウトが失効していないことを示している場合、クライアントは、デバイスIDが削除されたことを確認するために、おそらく削除されたデバイスIDにGETDEVICEINFO操作を送信する必要があります。"
    },
    {
      "indent": 6,
      "text": "If GETDEVICEINFO indicates that the device ID does not exist, then the client assumes the server is faulty and recovers by sending an EXCHANGE_ID operation. If GETDEVICEINFO indicates that the device ID does exist, then while the server is faulty for sending an erroneous device ID deletion notification, the degree to which it is faulty does not require the client to create a new client ID.",
      "ja": "GETDEVICEINFOは、デバイスIDが存在しないことを示している場合、クライアントはサーバーに障害が発生しており、EXCHANGE_ID操作を送信することにより、回復を前提としています。 GETDEVICEINFOは、デバイスIDが存在しないことを示している場合、サーバーが誤ったデバイスID削除通知を送信するための障害がある一方で、それから、それが故障している度合いは、新しいクライアントIDを作成するには、クライアントを必要としません。"
    },
    {
      "indent": 6,
      "text": "If the client does not have layouts that refer to the device ID, no harm is done. The client should mark the device ID as deleted, and when GETDEVICEINFO or GETDEVICELIST results are received that indicate that the device ID has been in fact deleted, the device ID should be removed from the client's cache.",
      "ja": "クライアントがデバイスIDを参照するレイアウトを持っていない場合は、害は行われません。削除されたように、クライアントは、デバイスIDをマークしなければならない、とGETDEVICEINFOまたはGETDEVICELIST結果は、デバイスIDが実際に削除されたことを示している受信された場合、デバイスIDは、クライアントのキャッシュから削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "o CB_NOTIFY_DEVICEID indicates that a device ID's device addressing mappings have changed. The client should assume that the results from the in-progress GETDEVICEINFO will be stale for the device ID once received, and so it should send another GETDEVICEINFO on the device ID.",
      "ja": "O CB_NOTIFY_DEVICEIDは、デバイスIDのデバイスアドレス指定のマッピングが変更されていることを示しています。クライアントは、進行中のGETDEVICEINFOからの結果は、一度受信したデバイスIDのために古くなることを想定する必要があり、そのためには、デバイスIDに別のGETDEVICEINFOを送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.41. Operation 48: GETDEVICELIST - Get All Device Mappings for a File System",
      "ja": "18.41. 操作48：GETDEVICELIST  - ファイルシステムのすべてのデバイスマッピングを取得します。"
    },
    {
      "indent": 0,
      "text": "18.41.1. ARGUMENT",
      "section_title": true,
      "ja": "18.41.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct GETDEVICELIST4args {\n        /* CURRENT_FH: object belonging to the file system */\n        layouttype4     gdla_layout_type;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "/* number of deviceIDs to return */\ncount4          gdla_maxdevices;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        nfs_cookie4     gdla_cookie;\n        verifier4       gdla_cookieverf;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.41.2. RESULT",
      "section_title": true,
      "ja": "18.41.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct GETDEVICELIST4resok {\n        nfs_cookie4             gdlr_cookie;\n        verifier4               gdlr_cookieverf;\n        deviceid4               gdlr_deviceid_list<>;\n        bool                    gdlr_eof;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union GETDEVICELIST4res switch (nfsstat4 gdlr_status) {\ncase NFS4_OK:\n        GETDEVICELIST4resok     gdlr_resok4;\ndefault:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.41.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.41.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation is used by the client to enumerate all of the device IDs that a server's file system uses.",
      "ja": "この操作は、サーバーのファイルシステムが使用するデバイスIDのすべてを列挙するために、クライアントによって使用されます。"
    },
    {
      "indent": 3,
      "text": "The client provides a current filehandle of a file object that belongs to the file system (i.e., all file objects sharing the same fsid as that of the current filehandle) and the layout type in gdia_layout_type. Since this operation might require multiple calls to enumerate all the device IDs (and is thus similar to the READDIR (Section 18.23) operation), the client also provides gdia_cookie and gdia_cookieverf to specify the current cursor position in the list. When the client wants to read from the beginning of the file system's device mappings, it sets gdla_cookie to zero. The field gdla_cookieverf MUST be ignored by the server when gdla_cookie is zero. The client provides gdla_maxdevices to limit the number of device IDs in the result. If gdla_maxdevices is zero, the server MUST return NFS4ERR_INVAL. The server MAY return fewer device IDs.",
      "ja": "クライアントがファイルシステムに属するファイルオブジェクトの現在のファイルハンドルを提供する（すなわち、現在のファイルハンドルと同じFSIDを共有するすべてのファイルオブジェクト）とgdia_layout_typeにおけるレイアウトタイプ。この操作は、すべてのデバイスIDを列挙するために複数のコールを必要とする（したがって、READDIR（セクション18.23）動作と同様である）かもしれないので、クライアントは、リスト内の現在のカーソル位置を指定するgdia_cookieとgdia_cookieverfを提供します。クライアントは、ファイル・システムのデバイス・マッピングの最初から読みたい場合は、それがゼロにgdla_cookieを設定します。 gdla_cookieがゼロの場合、フィールドgdla_cookieverfは、サーバーによって無視されなければなりません。クライアントは、結果のデバイスIDの数を制限するgdla_maxdevicesを提供します。 gdla_maxdevicesがゼロの場合、サーバーはNFS4ERR_INVALを返さなければなりません。サーバは少ないデバイスIDを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "The successful response to the operation will contain the cookie, gdlr_cookie, and the cookie verifier, gdlr_cookieverf, to be used on the subsequent GETDEVICELIST. A gdlr_eof value of TRUE signifies that there are no remaining entries in the server's device list. Each element of gdlr_deviceid_list contains a device ID.",
      "ja": "操作に成功した応答は、その後のGETDEVICELISTで使用するクッキー、gdlr_cookie、およびクッキーの検証、gdlr_cookieverfを、含まれています。 TRUEのgdlr_eof値は、サーバのデバイスリストには残りのエントリが存在しないことを意味します。 gdlr_deviceid_listの各要素は、デバイスIDが含まれています。"
    },
    {
      "indent": 0,
      "text": "18.41.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.41.4. 実装"
    },
    {
      "indent": 3,
      "text": "An example of the use of this operation is for pNFS clients and servers that use LAYOUT4_BLOCK_VOLUME layouts. In these environments it may be helpful for a client to determine device accessibility upon first file system access.",
      "ja": "この操作の使用例は、LAYOUT4_BLOCK_VOLUMEレイアウトを使用のpNFSクライアントとサーバのためです。これらの環境では、最初のファイルシステムへのアクセス時にデバイスのアクセス可能性を決定するために、クライアントのために役に立つかもしれません。"
    },
    {
      "indent": 0,
      "text": "18.42. Operation 49: LAYOUTCOMMIT - Commit Writes Made Using a Layout",
      "section_title": true,
      "ja": "18.42. 操作49：LAYOUTCOMMIT  - レイアウトを使用して作ら書き込みをコミット"
    },
    {
      "indent": 0,
      "text": "18.42.1. ARGUMENT",
      "section_title": true,
      "ja": "18.42.1. 引数"
    },
    {
      "indent": 3,
      "text": "union newtime4 switch (bool nt_timechanged) {\ncase TRUE:\n        nfstime4           nt_time;\ncase FALSE:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union newoffset4 switch (bool no_newoffset) {\ncase TRUE:\n        offset4           no_offset;\ncase FALSE:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct LAYOUTCOMMIT4args {\n        /* CURRENT_FH: file */\n        offset4                 loca_offset;\n        length4                 loca_length;\n        bool                    loca_reclaim;\n        stateid4                loca_stateid;\n        newoffset4              loca_last_write_offset;\n        newtime4                loca_time_modify;\n        layoutupdate4           loca_layoutupdate;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.42.2. RESULT",
      "section_title": true,
      "ja": "18.42.2. 結果"
    },
    {
      "indent": 3,
      "text": "union newsize4 switch (bool ns_sizechanged) {\ncase TRUE:\n        length4         ns_size;\ncase FALSE:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct LAYOUTCOMMIT4resok {\n        newsize4                locr_newsize;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union LAYOUTCOMMIT4res switch (nfsstat4 locr_status) {\ncase NFS4_OK:\n        LAYOUTCOMMIT4resok      locr_resok4;\ndefault:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.42.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.42.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The LAYOUTCOMMIT operation commits changes in the layout represented by the current filehandle, client ID (derived from the session ID in the preceding SEQUENCE operation), byte-range, and stateid. Since layouts are sub-dividable, a smaller portion of a layout, retrieved via LAYOUTGET, can be committed. The byte-range being committed is specified through the byte-range (loca_offset and loca_length). This byte-range MUST overlap with one or more existing layouts previously granted via LAYOUTGET (Section 18.43), each with an iomode of LAYOUTIOMODE4_RW. In the case where the iomode of any held layout segment is not LAYOUTIOMODE4_RW, the server should return the error NFS4ERR_BAD_IOMODE. For the case where the client does not hold matching layout segment(s) for the defined byte-range, the server should return the error NFS4ERR_BAD_LAYOUT.",
      "ja": "LAYOUTCOMMIT動作は、現在のファイルハンドル、（前回のシーケンス動作のセッションIDに由来する）は、クライアントID、バイト範囲、およびのstateidで表されるレイアウトの変更をコミット。レイアウトは、サブ分割可能であるので、LAYOUTGETを介して検索レイアウトの小さい部分は、コミットすることができます。コミットされたバイト範囲は、バイトレンジ（loca_offsetとloca_length）を介して指定されています。このバイト範囲は、以前LAYOUTGET（セクション18.43）を介して付与された1つのまたは複数の既存のレイアウト、LAYOUTIOMODE4_RWのIOModeに各と重複しなければなりません。任意の保持されたレイアウト・セグメントのIOModeにはLAYOUTIOMODE4_RWされていない場合、サーバはエラーNFS4ERR_BAD_IOMODEを返すべきです。クライアントが定義されたバイト範囲のレイアウトのセグメントを一致保持していない場合、サーバはエラーNFS4ERR_BAD_LAYOUTを返すべきです。"
    },
    {
      "indent": 3,
      "text": "The LAYOUTCOMMIT operation indicates that the client has completed writes using a layout obtained by a previous LAYOUTGET. The client may have only written a subset of the data range it previously requested. LAYOUTCOMMIT allows it to commit or discard provisionally allocated space and to update the server with a new end-of-file. The layout referenced by LAYOUTCOMMIT is still valid after the operation completes and can be continued to be referenced by the client ID, filehandle, byte-range, layout type, and stateid.",
      "ja": "LAYOUTCOMMIT操作は、クライアントが以前LAYOUTGETによって得られたレイアウトを使用して書き込みを完了したことを示しています。クライアントは、それが以前に要求されたデータ範囲のサブセットを書かれている場合があります。 LAYOUTCOMMITは、それがコミットまたは暫定的に割り当てられたスペースを破棄して新しいファイルの終わりでサーバーを更新することができます。操作が完了すると、クライアントID、ファイルハンドル、バイト範囲、レイアウトタイプ、およびのstateidによって参照されるように続けることができた後LAYOUTCOMMITによって参照レイアウトがまだ有効です。"
    },
    {
      "indent": 3,
      "text": "If the loca_reclaim field is set to TRUE, this indicates that the client is attempting to commit changes to a layout after the restart of the metadata server during the metadata server's recovery grace period (see Section 12.7.4). This type of request may be necessary when the client has uncommitted writes to provisionally allocated byte-ranges of a file that were sent to the storage devices before the restart of the metadata server. In this case, the layout provided by the client MUST be a subset of a writable layout that the client held immediately before the restart of the metadata server. The value of the field loca_stateid MUST be a value that the metadata server returned before it restarted. The metadata server is free to accept or reject this request based on its own internal metadata consistency checks. If the metadata server finds that the layout provided by the client does not pass its consistency checks, it MUST reject the request with the status NFS4ERR_RECLAIM_BAD. The successful completion of the LAYOUTCOMMIT request with loca_reclaim set to TRUE does NOT provide the client with a layout for the file. It simply commits the changes to the layout specified in the loca_layoutupdate field. To obtain a layout for the file, the client must send a LAYOUTGET request to the server after the server's grace period has expired. If the metadata server receives a LAYOUTCOMMIT request with loca_reclaim set to TRUE when the metadata server is not in its recovery grace period, it MUST reject the request with the status NFS4ERR_NO_GRACE.",
      "ja": "loca_reclaimフィールドがTRUEに設定されている場合、これはクライアントがメタデータサーバーの回復の猶予期間中にメタデータ・サーバの再起動後のレイアウトへの変更をコミットしようとしていることを示します（項12.7.4を参照してください）。 UNCOMMITTEDしたクライアントは、メタデータサーバの再起動前に、ストレージ・デバイスに送られたファイルの暫定割り当てられたバイト範囲に書き込むとき、要求のこのタイプは、必要になることがあります。この場合、クライアントが提供するレイアウトは、クライアントがメタデータサーバの再起動の直前に開催された書き込み可能なレイアウトのサブセットでなければなりません。フィールドloca_stateidの値は、それが再起動する前に、メタデータ・サーバが返す値でなければなりません。メタデータサーバは、独自の内部メタデータの整合性チェックに基づいて、この要求を受け入れるか拒否して自由です。メタデータサーバは、クライアントが提供するレイアウトは、その整合性チェックに合格しないことが判明した場合、それはステータスNFS4ERR_RECLAIM_BADとの要求を拒絶しなければなりません。 TRUEに設定されloca_reclaimとLAYOUTCOMMIT要求が正常に完了したが、ファイルのレイアウトをクライアントに提供していません。それは単にloca_layoutupdateフィールドで指定したレイアウトに変更をコミットします。サーバーの猶予期間が経過した後に、ファイルのレイアウトを取得するには、クライアントはサーバーにLAYOUTGET要求を送信する必要があります。メタデータサーバがTRUEにloca_reclaimセットでLAYOUTCOMMIT要求を受信した場合、メタデータ・サーバは、その回復の猶予期間内にないとき、それはステータスNFS4ERR_NO_GRACEとの要求を拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Setting the loca_reclaim field to TRUE is required if and only if the committed layout was acquired before the metadata server restart. If the client is committing a layout that was acquired during the metadata server's grace period, it MUST set the \"reclaim\" field to FALSE.",
      "ja": "そしてコミットレイアウトは、メタデータ・サーバの再起動の前に取得された場合だけTRUEにloca_reclaimフィールドの設定が必要です。クライアントは、メタデータサーバーの猶予期間中に取得されたレイアウトをコミットしている場合、それはFALSEに「再利用」フィールドを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The loca_stateid is a layout stateid value as returned by previously successful layout operations (see Section 12.5.3).",
      "ja": "loca_stateidは、以前に成功したレイアウト操作（セクション12.5.3を参照）によって返されるレイアウトのstateid値です。"
    },
    {
      "indent": 3,
      "text": "The loca_last_write_offset field specifies the offset of the last byte written by the client previous to the LAYOUTCOMMIT. Note that this value is never equal to the file's size (at most it is one byte less than the file's size) and MUST be less than or equal to NFS4_MAXFILEOFF. Also, loca_last_write_offset MUST overlap the range described by loca_offset and loca_length. The metadata server may use this information to determine whether the file's size needs to be updated. If the metadata server updates the file's size as the result of the LAYOUTCOMMIT operation, it must return the new size (locr_newsize.ns_size) as part of the results.",
      "ja": "loca_last_write_offsetフィールドはLAYOUTCOMMITに以前のクライアントによって書かれた最後のバイトのオフセットを指定します。この値は、ファイルのサイズと同じになることはありませんことに注意してください（最大で、それがファイルのサイズより1バイト以下）よりも小さいかNFS4_MAXFILEOFFに等しくなければなりません。また、loca_last_write_offsetはloca_offsetとloca_lengthによって記述範囲と重複しなければなりません。メタデータサーバは、ファイルのサイズを更新する必要があるかどうかを判断するために、この情報を使用することができます。メタデータサーバはLAYOUTCOMMIT操作の結果として、ファイルのサイズを更新した場合、それは結果の一部として、新しいサイズ（locr_newsize.ns_size）を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "The loca_time_modify field allows the client to suggest a modification time it would like the metadata server to set. The metadata server may use the suggestion or it may use the time of the LAYOUTCOMMIT operation to set the modification time. If the metadata server uses the client-provided modification time, it should ensure that time does not flow backwards. If the client wants to force the metadata server to set an exact time, the client should use a SETATTR operation in a COMPOUND right after LAYOUTCOMMIT. See Section 12.5.4 for more details. If the client desires the resultant modification time, it should construct the COMPOUND so that a GETATTR follows the LAYOUTCOMMIT.",
      "ja": "loca_time_modifyフィールドは、クライアントが、それがメタデータサーバを設定したいの変更時間を提案することができます。メタデータサーバは、提案を使用する場合もあれば、修正時刻を設定するLAYOUTCOMMIT操作の時間を使用することができます。メタデータサーバは、クライアントが提供する更新時刻を使用している場合、それはその時は逆方向に流れないようにする必要があります。クライアントは正確な時刻を設定するには、メタデータ・サーバを強制したい場合、クライアントは、右LAYOUTCOMMIT後COMPOUNDにSETATTR操作を使用する必要があります。詳細は、12.5.4項を参照してください。クライアントは、得られる修正時刻を望む場合GETATTRがLAYOUTCOMMITを以下のように、それは、化合物を構築する必要があります。"
    },
    {
      "indent": 3,
      "text": "The loca_layoutupdate argument to LAYOUTCOMMIT provides a mechanism for a client to provide layout-specific updates to the metadata server. For example, the layout update can describe what byte-ranges of the original layout have been used and what byte-ranges can be deallocated. There is no NFSv4.1 file layout-specific layoutupdate4 structure.",
      "ja": "LAYOUTCOMMITにloca_layoutupdate引数には、メタデータサーバにレイアウト固有のアップデートを提供するためのクライアントのためのメカニズムを提供します。例えば、レイアウトの更新は、元のレイアウトのバイト範囲が使用されており、どのようなバイト範囲が割り当てを解除することができるものを記述することができます。何NFSv4.1ファイルのレイアウト固有のlayoutupdate4構造はありません。"
    },
    {
      "indent": 3,
      "text": "The layout information is more verbose for block devices than for objects and files because the latter two hide the details of block allocation behind their storage protocols. At the minimum, the client needs to communicate changes to the end-of-file location back to the server, and, if desired, its view of the file's modification time. For block/volume layouts, it needs to specify precisely which blocks have been used.",
      "ja": "後者の二つは彼らのストレージプロトコルの背後にあるブロックの割り当ての詳細を隠すため、レイアウト情報は、オブジェクトやファイルよりもブロック・デバイスのためのより冗長です。最低でも、クライアントは、ファイルの修正時刻のビューを必要に応じて、バックサーバにファイルの終わりの場所への変更を通信する必要がある、と。ブロック/ボリュームレイアウトの場合は、ブロックが使用されている正確に指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the layout identified in the arguments does not exist, the error NFS4ERR_BADLAYOUT is returned. The layout being committed may also be rejected if it does not correspond to an existing layout with an iomode of LAYOUTIOMODE4_RW.",
      "ja": "引数で特定されたレイアウトが存在しない場合は、エラーNFS4ERR_BADLAYOUTが返されます。それはLAYOUTIOMODE4_RWのIOModeにして既存のレイアウトに対応していない場合は、コミットされているレイアウトも拒否されることがあります。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value and the current stateid retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持し、現在のstateidは、その値を保持します。"
    },
    {
      "indent": 0,
      "text": "18.42.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.42.4. 実装"
    },
    {
      "indent": 3,
      "text": "The client MAY also use LAYOUTCOMMIT with the loca_reclaim field set to TRUE to convey hints to modified file attributes or to report layout-type specific information such as I/O errors for object-based storage layouts, as normally done during normal operation. Doing so may help the metadata server to recover files more efficiently after restart. For example, some file system implementations may require expansive recovery of file system objects if the metadata server does not get a positive indication from all clients holding a LAYOUTIOMODE4_RW layout that they have successfully completed all their writes. Sending a LAYOUTCOMMIT (if required) and then following with LAYOUTRETURN can provide such an indication and allow for graceful and efficient recovery.",
      "ja": "通常は、通常の動作中に行われるように、クライアントはまた、変更されたファイルの属性にヒントを伝えるために、あるいはオブジェクトベースのストレージレイアウトのI / Oエラーなどのレイアウト・タイプ固有の情報を報告するためにTRUEにloca_reclaimフィールドセットでLAYOUTCOMMITを使用するかもしれません。そうすることで、メタデータサーバが再起動後に、より効率的にファイルを回復するのを助けることができます。メタデータサーバは、彼らが成功したすべての書き込みを完了したLAYOUTIOMODE4_RWレイアウトを保持しているすべてのクライアントからの陽性表示を取得していない場合たとえば、いくつかのファイルシステムの実装では、ファイルシステムオブジェクトの広大な回復が必要な場合があります。 （必要な場合）LAYOUTCOMMITを送信した後、そのような指示を提供し、優美かつ効率的な回復を可能にすることができるLAYOUTRETURNと以下。"
    },
    {
      "indent": 3,
      "text": "If loca_reclaim is TRUE, the metadata server is free to either examine or ignore the value in the field loca_stateid. The metadata server implementation might or might not encode in its layout stateid information that allows the metadate server to perform a consistency check on the LAYOUTCOMMIT request.",
      "ja": "loca_reclaimがTRUEの場合、メタデータサーバは、フィールドloca_stateidの値を調べたり、無視することのどちらか自由です。メタデータサーバの実装は、またはmetadateサーバがLAYOUTCOMMITのリクエストに応じて整合性チェックを実行することができ、レイアウトのstateid情報にエンコードしない場合があります。"
    },
    {
      "indent": 0,
      "text": "18.43. Operation 50: LAYOUTGET - Get Layout Information",
      "section_title": true,
      "ja": "18.43. 操作50：LAYOUTGET  - ゲットのレイアウト情報"
    },
    {
      "indent": 0,
      "text": "18.43.1. ARGUMENT",
      "section_title": true,
      "ja": "18.43.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct LAYOUTGET4args {\n        /* CURRENT_FH: file */\n        bool                    loga_signal_layout_avail;\n        layouttype4             loga_layout_type;\n        layoutiomode4           loga_iomode;\n        offset4                 loga_offset;\n        length4                 loga_length;\n        length4                 loga_minlength;\n        stateid4                loga_stateid;\n        count4                  loga_maxcount;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.43.2. RESULT",
      "section_title": true,
      "ja": "18.43.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct LAYOUTGET4resok {\n        bool               logr_return_on_close;\n        stateid4           logr_stateid;\n        layout4            logr_layout<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union LAYOUTGET4res switch (nfsstat4 logr_status) {\ncase NFS4_OK:\n        LAYOUTGET4resok     logr_resok4;\ncase NFS4ERR_LAYOUTTRYLATER:\n        bool                logr_will_signal_layout_avail;\ndefault:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.43.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.43.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The LAYOUTGET operation requests a layout from the metadata server for reading or writing the file given by the filehandle at the byte-range specified by offset and length. Layouts are identified by the client ID (derived from the session ID in the preceding SEQUENCE operation), current filehandle, layout type (loga_layout_type), and the layout stateid (loga_stateid). The use of the loga_iomode field depends upon the layout type, but should reflect the client's data access intent.",
      "ja": "LAYOUTGET操作はオフセットと長さで指定されたバイト範囲でファイルハンドルで指定したファイルを読み書きするためのメタデータサーバからレイアウトを要求します。レイアウトは、クライアント（前のシーケンス動作のセッションIDに由来する）ID、現在のファイルハンドル、レイアウトタイプ（loga_layout_type）、及びレイアウトのstateid（loga_stateid）によって識別されます。 loga_iomodeフィールドを使用すると、レイアウトタイプに依存しますが、クライアントのデータアクセスの意図を反映すべきです。"
    },
    {
      "indent": 3,
      "text": "If the metadata server is in a grace period, and does not persist layouts and device ID to device address mappings, then it MUST return NFS4ERR_GRACE (see Section 8.4.2.1).",
      "ja": "メタデータサーバは、猶予期間内にあり、デバイスアドレスのマッピングにレイアウトし、デバイスIDを保持されません、それはNFS4ERR_GRACE（セクション8.4.2.1を参照）を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The LAYOUTGET operation returns layout information for the specified byte-range: a layout. The client actually specifies two ranges, both starting at the offset in the loga_offset field. The first range is between loga_offset and loga_offset + loga_length - 1 inclusive. This range indicates the desired range the client wants the layout to cover. The second range is between loga_offset and loga_offset + loga_minlength - 1 inclusive. This range indicates the required range the client needs the layout to cover. Thus, loga_minlength MUST be less than or equal to loga_length.",
      "ja": "レイアウト：LAYOUTGET動作は、指定されたバイト範囲のレイアウト情報を返します。クライアントは、実際には両方がloga_offsetフィールドのオフセットで始まる、二つの範囲を指定します。 1包括 - 第1の範囲はloga_offsetとloga_offset + loga_lengthの間です。この範囲は、クライアントは、レイアウトがカバーしたい所望の範囲を示しています。 1包括 - 第二範囲はloga_offsetとloga_offset + loga_minlengthの間です。この範囲は、クライアントがカバーするために、レイアウトを必要とし、必要な範囲を示しています。したがって、loga_minlengthはloga_lengthより小さいか等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a length field is set to NFS4_UINT64_MAX, this indicates a desire (when loga_length is NFS4_UINT64_MAX) or requirement (when loga_minlength is NFS4_UINT64_MAX) to get a layout from loga_offset through the end-of-file, regardless of the file's length.",
      "ja": "長さフィールドはNFS4_UINT64_MAXに設定されている場合、これは関係なく、ファイルの長さの、エンド・オブ・ファイルを介してloga_offsetからレイアウトを取得する欲求（loga_lengthはNFS4_UINT64_MAX）または要件（loga_minlengthがNFS4_UINT64_MAXある場合）を示しています。"
    },
    {
      "indent": 3,
      "text": "The following rules govern the relationships among, and the minima of, loga_length, loga_minlength, and loga_offset.",
      "ja": "以下の規則が関係、及び、loga_length、loga_minlength、及びloga_offsetの最小値を支配します。"
    },
    {
      "indent": 3,
      "text": "o If loga_length is less than loga_minlength, the metadata server MUST return NFS4ERR_INVAL.",
      "ja": "loga_lengthがloga_minlength未満の場合は、O、メタデータサーバはNFS4ERR_INVALを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If loga_minlength is zero, this is an indication to the metadata server that the client desires any layout at offset loga_offset or less that the metadata server has \"readily available\". Readily is subjective, and depends on the layout type and the pNFS server implementation. For example, some metadata servers might have to pre-allocate stable storage when they receive a request for a range of a file that goes beyond the file's current length. If loga_minlength is zero and loga_length is greater than zero, this tells the metadata server what range of the layout the client would prefer to have. If loga_length and loga_minlength are both zero, then the client is indicating that it desires a layout of any length with the ending offset of the range no less than the value specified loga_offset, and the starting offset at or below loga_offset. If the metadata server does not have a layout that is readily available, then it MUST return NFS4ERR_LAYOUTTRYLATER.",
      "ja": "loga_minlengthがゼロの場合、O、これは、クライアントがメタデータサーバは、「容易に入手可能」であることオフセットloga_offset以下で任意のレイアウトを希望するメタデータ・サーバへの指示です。容易に主観的であり、かつレイアウトタイプとのpNFSサーバの実装に依存します。例えば、いくつかのメタデータサーバは、彼らは、ファイルの現在の長さを超えたファイルの範囲に対する要求を受信したときに安定したストレージを事前に割り当てる必要があります。 loga_minlengthがゼロでloga_lengthがゼロより大きい場合、これは、クライアントが持っていることを好むだろう、レイアウトのどの範囲メタデータ・サーバに指示します。 loga_lengthとloga_minlengthが両方ともゼロである場合、クライアントは、それが値指定loga_offset下回らない範囲の終了オフセットを有する任意の長さのレイアウトを希望することを示しており、loga_offsetで以下に開始オフセット。メタデータサーバが容易に利用可能であるレイアウトを持っていない場合、それはNFS4ERR_LAYOUTTRYLATERを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the sum of loga_offset and loga_minlength exceeds NFS4_UINT64_MAX, and loga_minlength is not NFS4_UINT64_MAX, the error NFS4ERR_INVAL MUST result.",
      "ja": "loga_offsetとloga_minlengthの合計がNFS4_UINT64_MAXを超える場合、及びloga_minlengthがNFS4_UINT64_MAXないO、エラーNFS4ERR_INVALが発生しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the sum of loga_offset and loga_length exceeds NFS4_UINT64_MAX, and loga_length is not NFS4_UINT64_MAX, the error NFS4ERR_INVAL MUST result.",
      "ja": "loga_offsetとloga_lengthの合計がNFS4_UINT64_MAXを超える場合、及びloga_lengthがNFS4_UINT64_MAXないO、エラーNFS4ERR_INVALが発生しなければなりません。"
    },
    {
      "indent": 3,
      "text": "After the metadata server has performed the above checks on loga_offset, loga_minlength, and loga_offset, the metadata server MUST return a layout according to the rules in Table 13.",
      "ja": "メタデータサーバはloga_offset、loga_minlength、及びloga_offsetに上記のチェックを行った後に、メタデータサーバは、表13の規則に従ってレイアウトを返さなければなりません。"
    },
    {
      "indent": 5,
      "text": " Acceptable layouts based on loga_minlength. Note: u64m = NFS4_UINT64_MAX; a_off = loga_offset; a_minlen = loga_minlength.",
      "ja": "loga_minlengthに基づいて許容できるレイアウト。注意：u64m = NFS4_UINT64_MAXを。 a_off = loga_offset。 a_minlen = loga_minlength。"
    },
    {
      "indent": 3,
      "text": "+-----------+-----------+----------+----------+---------------------+\n| Layout    | Layout    | Layout   | Layout   | Layout length of    |\n| iomode of | a_minlen  | iomode   | offset   | reply               |\n| request   | of        | of reply | of reply |                     |\n|           | request   |          |          |                     |\n+-----------+-----------+----------+----------+---------------------+\n| _READ     | u64m      | MAY be   | MUST be  | MUST be >= file     |\n|           |           | _READ    | <= a_off | length - layout     |\n|           |           |          |          | offset              |\n| _READ     | u64m      | MAY be   | MUST be  | MUST be u64m        |\n|           |           | _RW      | <= a_off |                     |\n| _READ     | > 0 and < | MAY be   | MUST be  | MUST be >= MIN(file |\n|           | u64m      | _READ    | <= a_off | length, a_minlen +  |\n|           |           |          |          | a_off) - layout     |\n|           |           |          |          | offset              |\n| _READ     | > 0 and < | MAY be   | MUST be  | MUST be >= a_off -  |\n|           | u64m      | _RW      | <= a_off | layout offset +     |\n|           |           |          |          | a_minlen            |\n| _READ     | 0         | MAY be   | MUST be  | MUST be > 0         |\n|           |           | _READ    | <= a_off |                     |\n| _READ     | 0         | MAY be   | MUST be  | MUST be > 0         |\n|           |           | _RW      | <= a_off |                     |\n| _RW       | u64m      | MUST be  | MUST be  | MUST be u64m        |\n|           |           | _RW      | <= a_off |                     |\n| _RW       | > 0 and < | MUST be  | MUST be  | MUST be >= a_off -  |\n|           | u64m      | _RW      | <= a_off | layout offset +     |\n|           |           |          |          | a_minlen            |\n| _RW       | 0         | MUST be  | MUST be  | MUST be > 0         |\n|           |           | _RW      | <= a_off |                     |\n+-----------+-----------+----------+----------+---------------------+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Table 13",
      "ja": "表13"
    },
    {
      "indent": 3,
      "text": "If loga_minlength is not zero and the metadata server cannot return a layout according to the rules in Table 13, then the metadata server MUST return the error NFS4ERR_BADLAYOUT. If loga_minlength is zero and the metadata server cannot or will not return a layout according to the rules in Table 13, then the metadata server MUST return the error NFS4ERR_LAYOUTTRYLATER. Assuming that loga_length is greater than loga_minlength or equal to zero, the metadata server SHOULD return a layout according to the rules in Table 14.",
      "ja": "loga_minlengthがゼロではなく、メタデータサーバは、表13の規則に従ってレイアウトを返すことができない場合は、メタデータサーバは、エラーNFS4ERR_BADLAYOUTを返さなければなりません。 loga_minlengthはゼロであり、メタデータサーバができないか、表13の規則に従ってレイアウトを返さない場合は、メタデータサーバは、エラーNFS4ERR_LAYOUTTRYLATERを返さなければなりません。 loga_lengthがloga_minlengthゼロ以上であると仮定すると、メタデータサーバは、表14の規則に従ってレイアウトを返すべきです。"
    },
    {
      "indent": 3,
      "text": "Desired layouts based on loga_length. The rules of Table 13 MUST be applied first. Note: u64m = NFS4_UINT64_MAX; a_off = loga_offset; a_len = loga_length.",
      "ja": "loga_lengthに基づいて、所望のレイアウト。表13の規則が最初に適用されなければなりません。注意：u64m = NFS4_UINT64_MAXを。 a_off = loga_offset。 a_len = loga_length。"
    },
    {
      "indent": 3,
      "text": "+------------+------------+-----------+-----------+-----------------+\n| Layout     | Layout     | Layout    | Layout    | Layout length   |\n| iomode of  | a_len of   | iomode of | offset of | of reply        |\n| request    | request    | reply     | reply     |                 |\n+------------+------------+-----------+-----------+-----------------+\n| _READ      | u64m       | MAY be    | MUST be   | SHOULD be u64m  |\n|            |            | _READ     | <= a_off  |                 |\n| _READ      | u64m       | MAY be    | MUST be   | SHOULD be u64m  |\n|            |            | _RW       | <= a_off  |                 |\n| _READ      | > 0 and <  | MAY be    | MUST be   | SHOULD be >=    |\n|            | u64m       | _READ     | <= a_off  | a_off - layout  |\n|            |            |           |           | offset + a_len  |\n| _READ      | > 0 and <  | MAY be    | MUST be   | SHOULD be >=    |\n|            | u64m       | _RW       | <= a_off  | a_off - layout  |\n|            |            |           |           | offset + a_len  |\n| _READ      | 0          | MAY be    | MUST be   | SHOULD be >     |\n|            |            | _READ     | <= a_off  | a_off - layout  |\n|            |            |           |           | offset          |\n| _READ      | 0          | MAY be    | MUST be   | SHOULD be >     |\n|            |            | _READ     | <= a_off  | a_off - layout  |\n|            |            |           |           | offset          |\n| _RW        | u64m       | MUST be   | MUST be   | SHOULD be u64m  |\n|            |            | _RW       | <= a_off  |                 |\n| _RW        | > 0 and <  | MUST be   | MUST be   | SHOULD be >=    |\n|            | u64m       | _RW       | <= a_off  | a_off - layout  |\n|            |            |           |           | offset + a_len  |\n| _RW        | 0          | MUST be   | MUST be   | SHOULD be >     |\n|            |            | _RW       | <= a_off  | a_off - layout  |\n|            |            |           |           | offset          |\n+------------+------------+-----------+-----------+-----------------+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Table 14",
      "ja": "表14"
    },
    {
      "indent": 3,
      "text": "The loga_stateid field specifies a valid stateid. If a layout is not currently held by the client, the loga_stateid field represents a stateid reflecting the correspondingly valid open, byte-range lock, or delegation stateid. Once a layout is held on the file by the client, the loga_stateid field MUST be a stateid as returned from a previous LAYOUTGET or LAYOUTRETURN operation or provided by a CB_LAYOUTRECALL operation (see Section 12.5.3).",
      "ja": "loga_stateidフィールドが有効なstateidを指定します。レイアウトは現在クライアントによって保持されていない場合は、loga_stateidフィールドには、それに対応し、有効なオープン、バイト範囲ロック、または委任のstateidを反映したstateidを表します。レイアウトがクライアントによってファイルに保持された後、以前のLAYOUTGET又はLAYOUTRETURN操作から返された又はCB_LAYOUTRECALL動作によって提供される、loga_stateidフィールド（セクション12.5.3を参照）のstateidでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The loga_maxcount field specifies the maximum layout size (in bytes) that the client can handle. If the size of the layout structure exceeds the size specified by maxcount, the metadata server will return the NFS4ERR_TOOSMALL error.",
      "ja": "loga_maxcountフィールドは、クライアントが処理できる（バイト単位）の最大レイアウトサイズを指定します。レイアウト構造のサイズはMAXCOUNTで指定されたサイズを超えた場合、メタデータサーバは、NFS4ERR_TOOSMALLエラーを返します。"
    },
    {
      "indent": 3,
      "text": "The returned layout is expressed as an array, logr_layout, with each element of type layout4. If a file has a single striping pattern, then logr_layout SHOULD contain just one entry. Otherwise, if the requested range overlaps more than one striping pattern, logr_layout will contain the required number of entries. The elements of logr_layout MUST be sorted in ascending order of the value of the lo_offset field of each element. There MUST be no gaps or overlaps in the range between two successive elements of logr_layout. The lo_iomode field in each element of logr_layout MUST be the same.",
      "ja": "返されたレイアウトは、タイプlayout4の各要素と、アレイ、logr_layoutとして表現されます。ファイルは、単一のストライプパターンを持っている場合は、logr_layoutはただ一つのエントリを含むべきです。要求された範囲が複数のストライプパターンと重なる場合にそうでなければ、logr_layoutエントリの必要数を含むことになります。 logr_layoutの要素は、各要素のlo_offsetフィールドの値の昇順にソートしなければなりません。 logr_layoutの二つの連続する要素間の範囲には隙間や重複があってはなりません。 logr_layoutの各要素におけるlo_iomodeフィールドは同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Table 13 and Table 14 both refer to a returned layout iomode, offset, and length. Because the returned layout is encoded in the logr_layout array, more description is required.",
      "ja": "表13および表14の両方が返されるレイアウトIOModeに、オフセット、および長さを指します。返されたレイアウトがlogr_layout配列にコードされているため、より多くの説明が必要です。"
    },
    {
      "indent": 3,
      "text": "iomode",
      "ja": "IOModeに"
    },
    {
      "indent": 6,
      "text": "The value of the returned layout iomode listed in Table 13 and Table 14 is equal to the value of the lo_iomode field in each element of logr_layout. As shown in Table 13 and Table 14, the metadata server MAY return a layout with an lo_iomode different from the requested iomode (field loga_iomode of the request). If it does so, it MUST ensure that the lo_iomode is more permissive than the loga_iomode requested. For example, this behavior allows an implementation to upgrade LAYOUTIOMODE4_READ requests to LAYOUTIOMODE4_RW requests at its discretion, within the limits of the layout type specific protocol. A lo_iomode of either LAYOUTIOMODE4_READ or LAYOUTIOMODE4_RW MUST be returned.",
      "ja": "表13および表14に記載されて戻されたレイアウトIOModeにの値はlo​​gr_layoutの各要素におけるlo_iomodeフィールドの値に等しいです。表13および表14に示すように、メタデータサーバは、要求されたIOModeに（リクエストのフィールドloga_iomode）異なるlo_iomodeとレイアウトを返すことができます。それはそうするならば、それはlo_iomodeが要求loga_iomodeよりも寛容であることを保証しなければなりません。たとえば、この動作は、実装は、レイアウトタイプ、特定のプロトコルの制限内で、その裁量で要求をLAYOUTIOMODE4_RWするLAYOUTIOMODE4_READ要求をアップグレードすることを可能にします。 LAYOUTIOMODE4_READまたはLAYOUTIOMODE4_RWのいずれかのlo_iomodeを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "offset",
      "ja": "オフセット"
    },
    {
      "indent": 6,
      "text": "The value of the returned layout offset listed in Table 13 and Table 14 is always equal to the lo_offset field of the first element logr_layout.",
      "ja": "表13および表14に列挙されたオフセット返さレイアウトの値は、常に第1の素子logr_layoutのlo_offsetフィールドに等しいです。"
    },
    {
      "indent": 3,
      "text": "length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "When setting the value of the returned layout length, the situation is complicated by the possibility that the special layout length value NFS4_UINT64_MAX is involved. For a logr_layout array of N elements, the lo_length field in the first N-1 elements MUST NOT be NFS4_UINT64_MAX. The lo_length field of the last element of logr_layout can be NFS4_UINT64_MAX under some conditions as described in the following list.",
      "ja": "返されたレイアウトの長さの値を設定する場合、状況は特殊なレイアウトの長さの値NFS4_UINT64_MAXが関与している可能性によって複雑になります。 N個の要素のlogr_layoutアレイに対して、最初のN-1個の要素でlo_lengthフィールドはNFS4_UINT64_MAXはずがありません。以下のリストで説明するようにlogr_layoutの最後の要素のlo_lengthフィールドには、いくつかの条件の下でNFS4_UINT64_MAXすることができます。"
    },
    {
      "indent": 6,
      "text": "* If an applicable rule of Table 13 states that the metadata server MUST return a layout of length NFS4_UINT64_MAX, then the lo_length field of the last element of logr_layout MUST be NFS4_UINT64_MAX.",
      "ja": "*メタデータサーバは長NFS4_UINT64_MAXのレイアウトを返さなければならない表13の状態の適用可能なルールは、その後logr_layoutの最後の要素のlo_lengthフィールドはNFS4_UINT64_MAXしなければならない場合。"
    },
    {
      "indent": 6,
      "text": "* If an applicable rule of Table 13 states that the metadata server MUST NOT return a layout of length NFS4_UINT64_MAX, then the lo_length field of the last element of logr_layout MUST NOT be NFS4_UINT64_MAX.",
      "ja": "*メタデータサーバは、長さNFS4_UINT64_MAXのレイアウトを返してはならない。表13の州の適用可能なルールは、その後、logr_layoutの最後の要素のlo_lengthフィールドはNFS4_UINT64_MAXにすることはできません場合。"
    },
    {
      "indent": 6,
      "text": "* If an applicable rule of Table 14 states that the metadata server SHOULD return a layout of length NFS4_UINT64_MAX, then the lo_length field of the last element of logr_layout SHOULD be NFS4_UINT64_MAX.",
      "ja": "*メタデータサーバは長NFS4_UINT64_MAXのレイアウトを返すべきである。表14の状態の適用可能なルールは、その後logr_layoutの最後の要素のlo_lengthフィールドはNFS4_UINT64_MAXする必要がある場合。"
    },
    {
      "indent": 6,
      "text": "* When the value of the returned layout length of Table 13 and Table 14 is not NFS4_UINT64_MAX, then the returned layout length is equal to the sum of the lo_length fields of each element of logr_layout.",
      "ja": "表13および表14の戻りレイアウト長さの値がないNFS4_UINT64_MAX、ある場合*戻さレイアウトの長さはlogr_layoutの各要素のlo_lengthフィールドの和に等しいです。"
    },
    {
      "indent": 3,
      "text": "The logr_return_on_close result field is a directive to return the layout before closing the file. When the metadata server sets this return value to TRUE, it MUST be prepared to recall the layout in the case in which the client fails to return the layout before close. For the metadata server that knows a layout must be returned before a close of the file, this return value can be used to communicate the desired behavior to the client and thus remove one extra step from the client's and metadata server's interaction.",
      "ja": "logr_return_on_close結果フィールドは、ファイルを閉じる前に、レイアウトを返すように指示されます。メタデータサーバがTRUEにこの戻り値を設定すると、クライアントがクローズする前に、レイアウトを返すことに失敗した場合には、レイアウトを思い出すために準備しなければなりません。レイアウトを知っているメタデータサーバは、ファイルのクローズ前に返却しなければならないために、この戻り値は、クライアントに必要な行動を通信するため、クライアントのメタデータとサーバーの相互作用から、1つの余分のステップを削除するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "The logr_stateid stateid is returned to the client for use in subsequent layout related operations. See Sections 8.2, 12.5.3, and 12.5.5.2 for a further discussion and requirements.",
      "ja": "logr_stateidののstateidは、後続のレイアウト関連の操作で使用するためにクライアントに返されます。さらなる議論と要件については、セクション8.2、12.5.3、および12.5.5.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The format of the returned layout (lo_content) is specific to the layout type. The value of the layout type (lo_content.loc_type) for each of the elements of the array of layouts returned by the metadata server (logr_layout) MUST be equal to the loga_layout_type specified by the client. If it is not equal, the client SHOULD ignore the response as invalid and behave as if the metadata server returned an error, even if the client does have support for the layout type returned.",
      "ja": "返されたレイアウト（lo_content）のフォーマットは、レイアウトタイプに特異的です。メタデータサーバ（logr_layout）によって返されたレイアウトの配列の各要素のレイアウトタイプ（lo_content.loc_type）の値は、クライアントによって指定さloga_layout_typeに等しくなければなりません。それが等しくない場合、クライアントは無効としてレスポンスを無視すべきであり、メタデータサーバは、クライアントが返されたレイアウトタイプをサポートしていない場合でも、エラーを返したかのように振る舞います。"
    },
    {
      "indent": 3,
      "text": "If neither the requested file nor its containing file system support layouts, the metadata server MUST return NFS4ERR_LAYOUTUNAVAILABLE. If the layout type is not supported, the metadata server MUST return NFS4ERR_UNKNOWN_LAYOUTTYPE. If layouts are supported but no layout matches the client provided layout identification, the metadata server MUST return NFS4ERR_BADLAYOUT. If an invalid loga_iomode is specified, or a loga_iomode of LAYOUTIOMODE4_ANY is specified, the metadata server MUST return NFS4ERR_BADIOMODE.",
      "ja": "要求されたファイルもその含むファイルシステムのサポートのレイアウトでもない場合は、メタデータサーバはNFS4ERR_LAYOUTUNAVAILABLEを返さなければなりません。レイアウトタイプがサポートされていない場合、メタデータサーバはNFS4ERR_UNKNOWN_LAYOUTTYPEを返さなければなりません。レイアウトはサポートされていますが、何のレイアウトがクライアントに提供レイアウト識別と一致していない場合は、メタデータサーバはNFS4ERR_BADLAYOUTを返さなければなりません。無効なloga_iomodeが指定されている、またはLAYOUTIOMODE4_ANYのloga_iomodeが指定されている場合は、メタデータサーバはNFS4ERR_BADIOMODEを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the layout for the file is unavailable due to transient conditions, e.g., file sharing prohibits layouts, the metadata server MUST return NFS4ERR_LAYOUTTRYLATER.",
      "ja": "ファイルのレイアウトが原因の過渡条件に使用できない場合、例えば、ファイル共有は、レイアウトを禁止し、メタデータサーバはNFS4ERR_LAYOUTTRYLATERを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the layout request is rejected due to an overlapping layout recall, the metadata server MUST return NFS4ERR_RECALLCONFLICT. See Section 12.5.5.2 for details.",
      "ja": "レイアウト要求が重複レイアウトリコールが原因で拒否された場合は、メタデータサーバはNFS4ERR_RECALLCONFLICTを返さなければなりません。詳細については、セクション12.5.5.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the layout conflicts with a mandatory byte-range lock held on the file, and if the storage devices have no method of enforcing mandatory locks, other than through the restriction of layouts, the metadata server SHOULD return NFS4ERR_LOCKED.",
      "ja": "ストレージデバイスは、レイアウトの制約による以外の強制ロックを、強制のない方法を持っていないファイルに開催された必須バイト範囲ロック付きレイアウト競合した場合、および場合は、メタデータサーバはNFS4ERR_LOCKEDを返すべきです。"
    },
    {
      "indent": 3,
      "text": "If client sets loga_signal_layout_avail to TRUE, then it is registering with the client a \"want\" for a layout in the event the layout cannot be obtained due to resource exhaustion. If the metadata server supports and will honor the \"want\", the results will have logr_will_signal_layout_avail set to TRUE. If so, the client should expect a CB_RECALLABLE_OBJ_AVAIL operation to indicate that a layout is available.",
      "ja": "クライアントがTRUEにloga_signal_layout_availを設定した場合、それはクライアントに登録されているイベントで、レイアウトのための「欲しい」レイアウトは、リソースの枯渇に取得することはできません。メタデータサーバがサポートしており、「欲しい」尊重するならば、結果がTRUEに設定さlogr_will_signal_layout_availています。その場合、クライアントはCB_RECALLABLE_OBJ_AVAIL操作はレイアウトが利用可能であることを示すことを期待すべきです。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value and the current stateid is updated to match the value as returned in the results.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持し、現在のstateidが結果に返される値と一致するように更新されます。"
    },
    {
      "indent": 0,
      "text": "18.43.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.43.4. 実装"
    },
    {
      "indent": 3,
      "text": "Typically, LAYOUTGET will be called as part of a COMPOUND request after an OPEN operation and results in the client having location information for the file. This requires that loga_stateid be set to the special stateid that tells the metadata server to use the current stateid, which is set by OPEN (see Section 16.2.3.1.2). A client may also hold a layout across multiple OPENs. The client specifies a layout type that limits what kind of layout the metadata server will return. This prevents metadata servers from granting layouts that are unusable by the client.",
      "ja": "典型的には、LAYOUTGETはクライアントでOPEN操作と結果はファイルの位置情報を有する後、化合物の要求の一部として呼び出されます。これはloga_stateidがOPEN（セクション16.2.3.1.2を参照）で設定されている現在のstateidを使用するメタデータ・サーバに指示します特別なstateidに設定されている必要があります。また、クライアントは、複数のOPENs全体のレイアウトを保持することができます。クライアントは、メタデータ・サーバが返すレイアウトの種類を制限し、レイアウトのタイプを指定します。これは、クライアントによって使用できないレイアウトを付与からメタデータ・サーバを防ぎます。"
    },
    {
      "indent": 3,
      "text": "As indicated by Table 13 and Table 14, the specification of LAYOUTGET allows a pNFS client and server considerable flexibility. A pNFS client can take several strategies for sending LAYOUTGET. Some examples are as follows.",
      "ja": "表13および表14で示されるように、LAYOUTGETの仕様は、pNFSのクライアントおよびサーバかなりの柔軟性を可能にします。 pNFSのクライアントはLAYOUTGETを送信するためのいくつかの戦略を取ることができます。次のようにいくつかの例があります。"
    },
    {
      "indent": 3,
      "text": "o If LAYOUTGET is preceded by OPEN in the same COMPOUND request and the OPEN requests OPEN4_SHARE_ACCESS_READ access, the client might opt to request a _READ layout with loga_offset set to zero, loga_minlength set to zero, and loga_length set to NFS4_UINT64_MAX. If the file has space allocated to it, that space is striped over one or more storage devices, and there is either no conflicting layout or the concept of a conflicting layout does not apply to the pNFS server's layout type or implementation, then the metadata server might return a layout with a starting offset of zero, and a length equal to the length of the file, if not NFS4_UINT64_MAX. If the length of the file is not a multiple of the pNFS server's stripe width (see Section 13.2 for a formal definition), the metadata server might round up the returned layout's length.",
      "ja": "LAYOUTGETが同じCOMPOUND要求とOPEN要求OPEN4_SHARE_ACCESS_READアクセスにOPENによって先行されている場合は、O、クライアントがゼロに設定loga_offsetで_readレイアウトを要求することを選ぶかもしれませんが、ゼロに設定loga_minlength、およびNFS4_UINT64_MAXに設定loga_length。ファイルがそれに割り当てられたスペースを持っている場合は、そのスペースは、1つのまたは複数のストレージ・デバイスにストライプ、および競合するレイアウトまたは競合するレイアウトの概念のいずれかが存在していない、メタデータサーバ、のpNFSサーバのレイアウトタイプまたは実装には適用されません。 NFS4_UINT64_MAXない場合、ゼロの開始オフセット、およびファイルの長さに等しい長さのレイアウトを返すかもしれません。ファイルの長さは、pNFSのサーバーのストライプ幅の倍数でない場合（正式な定義については、セクション13.2を参照）、メタデータサーバは、返されたレイアウトの長さを切り上げる可能性があります。"
    },
    {
      "indent": 3,
      "text": "o If LAYOUTGET is preceded by OPEN in the same COMPOUND request, and the OPEN requests OPEN4_SHARE_ACCESS_WRITE access and does not truncate the file, the client might opt to request a _RW layout with loga_offset set to zero, loga_minlength set to zero, and loga_length set to the file's current length (if known), or NFS4_UINT64_MAX. As with the previous case, under some conditions the metadata server might return a layout that covers the entire length of the file or beyond.",
      "ja": "O LAYOUTGETは同じCOMPOUND要求にOPENが先行し、OPEN要求OPEN4_SHARE_ACCESS_WRITEアクセスをして、ファイルを切り捨てられませんが、クライアントがゼロに設定loga_offsetで_RWレイアウトを要求することを選ぶかもしれませんが、ゼロに設定loga_minlength、およびloga_lengthがに設定されている場合ファイルの現在の長さ（既知の場合）、またはNFS4_UINT64_MAX。前のケースと同様に、いくつかの条件の下で、メタデータ・サーバは、ファイルまたは越えての全体の長さをカバーしていレイアウトを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "o This strategy is as above, but the OPEN truncates the file. In this case, the client might anticipate it will be writing to the file from offset zero, and so loga_offset and loga_minlength are set to zero, and loga_length is set to the value of threshold4_write_iosize. The metadata server might return a layout from offset zero with a length at least as long as threshold4_write_iosize.",
      "ja": "Oこの戦略は、上記のようですが、OPENはファイルを切り捨てます。この場合、クライアントは、それがゼロオフセットからファイルへの書き込みなどloga_offsetとloga_minlengthされる予想される可能性がゼロに設定されている、とloga_lengthはthreshold4_write_iosizeの値に設定されています。メタデータサーバは、threshold4_write_iosizeとして、少なくとも同じ長さでオフセットゼロからレイアウトを返すことがあります。"
    },
    {
      "indent": 3,
      "text": "o A process on the client invokes a request to read from offset 10000 for length 50000. The client is using buffered I/O, and has buffer sizes of 4096 bytes. The client intends to map the request of the process into a series of READ requests starting at offset 8192. The end offset needs to be higher than 10000 + 50000 = 60000, and the next offset that is a multiple of 4096 is 61440. The difference between 61440 and that starting offset of the layout is 53248 (which is the product of 4096 and 15). The value of threshold4_read_iosize is less than 53248, so the client sends a LAYOUTGET request with loga_offset set to 8192, loga_minlength set to 53248, and loga_length set to the file's length (if known) minus 8192 or NFS4_UINT64_MAX (if the file's length is not known). Since this LAYOUTGET request exceeds the metadata server's threshold, it grants the layout, possibly with an initial offset of zero, with an end offset of at least 8192 + 53248 - 1 = 61439, but preferably a layout with an offset aligned on the stripe width and a length that is a multiple of the stripe width.",
      "ja": "クライアントがバッファI / Oを使用して、4096バイトのバッファサイズを有する長50000 10000オフセットクライアント上のプロセスOから読み出し要求を呼び出します。クライアントはから始まるREAD要求のシリーズにプロセスの要求をマッピングする意向エンド8192をオフセット= 60000 10000 + 50000よりも高く、かつ次のようにニーズをオフセットそれは4096の倍数であるオフセット61440.差です61440の間のレイアウトの開始オフセットは、（4096と15の積である）53248です。 threshold4_read_iosizeの値が53248未満であるので、クライアントが8192に設定されloga_offsetとLAYOUTGET要求を送信し、ファイルの長さが知られていない場合は、loga_minlengthは53248に設定し、ファイルの長さ（もし知られている）、マイナス8192またはNFS4_UINT64_MAX（に設定loga_length ）。このLAYOUTGET要求がメタデータサーバの閾値を超えているので、それは少なくとも8192 + 53248のオフセット端部と、おそらくゼロの初期オフセットと、レイアウトを許可 -  1 = 61439、しかしオフセットストライプ幅に整列し、好ましくはレイアウトストライプ幅の倍数である長さ。"
    },
    {
      "indent": 3,
      "text": "o This strategy is as above, but the client is not using buffered I/O, and instead all internal I/O requests are sent directly to the server. The LAYOUTGET request has loga_offset equal to 10000 and loga_minlength set to 50000. The value of loga_length is set to the length of the file. The metadata server is free to return a layout that fully overlaps the requested range, with a starting offset and length aligned on the stripe width.",
      "ja": "Oこの戦略は、上記のようですが、クライアントは、I / Oバッファリングを使用していない、その代わりに、すべての内部I / O要求がサーバーに直接送信されます。 LAYOUTGET要求は10000に等しいloga_offsetており、ファイルの長さに設定されているloga_lengthの値を50000に設定loga_minlength。メタデータサーバは、ストライプ幅に整列開始オフセットと長さで、完全に要求された範囲と重なるレイアウトを返すために自由です。"
    },
    {
      "indent": 3,
      "text": "o Again, a process on the client invokes a request to read from offset 10000 for length 50000 (i.e. a range with a starting offset of 10000 and an ending offset of 69999), and buffered I/O is in use. The client is expecting that the server might not be able to return the layout for the full I/O range. The client intends to map the request of the process into a series of thirteen READ requests starting at offset 8192, each with length 4096, with a total length of 53248 (which equals 13 * 4096), which fully contains the range that client's process wants to read. Because the value of threshold4_read_iosize is equal to 4096, it is practical and reasonable for the client to use several LAYOUTGET operations to complete the series of READs. The client sends a LAYOUTGET request with loga_offset set to 8192, loga_minlength set to 4096, and loga_length set to 53248 or higher. The server will grant a layout possibly with an initial offset of zero, with an end offset of at least 8192 + 4096 - 1 = 12287, but preferably a layout with an offset aligned on the stripe width and a length that is a multiple of the stripe width. This will allow the client to make forward progress, possibly sending more LAYOUTGET operations for the remainder of the range.",
      "ja": "O再び、クライアント上のプロセスは、長さ50000（10000と69999の終了オフセットの開始オフセットを有する即ち範囲）10000オフセット、およびI / Oが使用されている緩衝から読み出し要求を呼び出します。クライアントは、サーバーが完全なI / O範囲のレイアウトを返すことができない場合がありますことを期待しています。クライアントは完全にクライアントのプロセスが望んでいることの範囲が含まれています（* 4096 13に等しい）53248の全体の長さ、で、長さ4096と8192は、それぞれのオフセットで始まる13のREAD要求のシリーズへのプロセスの要求をマッピングする予定読み取ります。 threshold4_read_iosizeの値が4096に等しいので、クライアントREAD文のシリーズを完了するのに数LAYOUTGET操作を使用することは実用的かつ合理的です。クライアントは、8192に設定loga_offset、4096に設定loga_minlength、およびloga_length 53248以上に設定してLAYOUTGET要求を送信します。 1 = 12287、しかしオフセットストライプ幅の倍数である長さに整列し、好ましくはレイアウト - サーバーは、少なくとも8192 + 4096のオフセット端部と、ゼロの初期オフセットと、おそらくレイアウトを許可しますストライプ幅。これはおそらく範囲の残りの部分よりLAYOUTGET操作を送信し、クライアントは前進を行うことができます。"
    },
    {
      "indent": 3,
      "text": "o An NFS client detects a sequential read pattern, and so sends a LAYOUTGET operation that goes well beyond any current or pending read requests to the server. The server might likewise detect this pattern, and grant the LAYOUTGET request. Once the client reads from an offset of the file that represents 50% of the way through the range of the last layout it received, in order to avoid stalling I/O that would wait for a layout, the client sends more operations from an offset of the file that represents 50% of the way through the last layout it received. The client continues to request layouts with byte-ranges that are well in advance of the byte-ranges of recent and/or read requests of processes running on the client.",
      "ja": "O NFSクライアントは、シーケンシャルリードのパターンを検出し、とてもうまく、サーバーへの現在または保留中の読取り要求を超えLAYOUTGET操作を送信します。サーバーは同様に、このパターンを検出し、LAYOUTGET要求を許可することがあります。クライアントは、レイアウトのために待って失速I / Oを避けるために、それは最後に受信したレイアウトの範囲による方法の50％を表すファイルのオフセットから読み取ると、クライアントは、オフセットからより多くの業務を送りますそれが受信した最後のレイアウトを通る道の50％を表すファイル。クライアントは、最近および/またはクライアント上で実行中のプロセスの読み取り要求のバイト範囲のかなり前にあるバイトの範囲でレイアウトを要求し続けています。"
    },
    {
      "indent": 3,
      "text": "o This strategy is as above, but the client fails to detect the pattern, but the server does. The next time the metadata server gets a LAYOUTGET, it returns a layout with a length that is well beyond loga_minlength.",
      "ja": "Oこの戦略は、上記のようですが、クライアントがパターンを検出するために失敗したが、サーバーはありません。メタデータサーバはLAYOUTGETを取得し、次回は、それがうまくloga_minlengthを超えている長さのレイアウトを返します。"
    },
    {
      "indent": 3,
      "text": "o A client is using buffered I/O, and has a long queue of write-behinds to process and also detects a sequential write pattern. It sends a LAYOUTGET for a layout that spans the range of the queued write-behinds and well beyond, including ranges beyond the filer's current length. The client continues to send LAYOUTGET operations once the write-behind queue reaches 50% of the maximum queue length.",
      "ja": "クライアントoをバッファードI / Oを使用し、かつ処理するための書き込み尻の長い行列があり、また、シーケンシャル書き込みパターンを検出しています。これは、ファイラーの現在の長さを超えた範囲を含む、キューに入れられた書き込み尻の、よく超えた範囲にまたがるレイアウトのLAYOUTGETを送信します。クライアントは、ライトビハインドキューがキューの最大長の50％に達するとLAYOUTGETオペレーションを送信し続けます。"
    },
    {
      "indent": 3,
      "text": "Once the client has obtained a layout referring to a particular device ID, the metadata server MUST NOT delete the device ID until the layout is returned or revoked.",
      "ja": "クライアントは、特定のデバイスIDを参照するレイアウトを取得した後はレイアウトが返されるか取り消されるまで、メタデータサーバは、デバイスIDを削除してはなりません。"
    },
    {
      "indent": 3,
      "text": "CB_NOTIFY_DEVICEID can race with LAYOUTGET. One race scenario is that LAYOUTGET returns a device ID for which the client does not have device address mappings, and the metadata server sends a CB_NOTIFY_DEVICEID to add the device ID to the client's awareness and meanwhile the client sends GETDEVICEINFO on the device ID. This scenario is discussed in Section 18.40.4. Another scenario is that the CB_NOTIFY_DEVICEID is processed by the client before it processes the results from LAYOUTGET. The client will send a GETDEVICEINFO on the device ID. If the results from GETDEVICEINFO are received before the client gets results from LAYOUTGET, then there is no longer a race. If the results from LAYOUTGET are received before the results from GETDEVICEINFO, the client can either wait for results of GETDEVICEINFO or send another one to get possibly more up-to-date device address mappings for the device ID.",
      "ja": "CB_NOTIFY_DEVICEIDはLAYOUTGETでレースをすることができます。一つのレースシナリオはLAYOUTGETは、クライアントがデバイスのアドレスマッピングを持たないため、デバイスIDを返し、メタデータサーバがクライアントの意識にデバイスIDを追加するCB_NOTIFY_DEVICEIDを送信し、一方で、クライアントがデバイスIDにGETDEVICEINFOを送信していることです。このシナリオは、セクション18.40.4で説明されています。別のシナリオは、それがLAYOUTGETからの結果を処理する前にCB_NOTIFY_DEVICEIDがクライアントによって処理されていることです。クライアントは、デバイスIDにGETDEVICEINFOを送信します。クライアントがLAYOUTGETから結果を取得する前に、GETDEVICEINFOから結果が受信される場合、レースはもはやありません。 LAYOUTGETからの結果は、GETDEVICEINFOからの結果の前に受信された場合、クライアントはGETDEVICEINFOの結果を待つか、デバイスIDのために、おそらくより多くの最新のデバイスアドレスのマッピングを取得するために別のものを送ることができます。"
    },
    {
      "indent": 0,
      "text": "18.44. Operation 51: LAYOUTRETURN - Release Layout Information",
      "section_title": true,
      "ja": "18.44. 操作51：LAYOUTRETURN  - リリースレイアウト情報"
    },
    {
      "indent": 0,
      "text": "18.44.1. ARGUMENT",
      "section_title": true,
      "ja": "18.44.1. 引数"
    },
    {
      "indent": 3,
      "text": "/* Constants used for LAYOUTRETURN and CB_LAYOUTRECALL */\nconst LAYOUT4_RET_REC_FILE      = 1;\nconst LAYOUT4_RET_REC_FSID      = 2;\nconst LAYOUT4_RET_REC_ALL       = 3;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "enum layoutreturn_type4 { LAYOUTRETURN4_FILE = LAYOUT4_RET_REC_FILE, LAYOUTRETURN4_FSID = LAYOUT4_RET_REC_FSID, LAYOUTRETURN4_ALL = LAYOUT4_RET_REC_ALL };",
      "ja": "列挙layoutreturn_type4 {LAYOUTRETURN4_FILE = LAYOUT4_RET_REC_FILE、LAYOUTRETURN4_FSID = LAYOUT4_RET_REC_FSID、LAYOUTRETURN4_ALL = LAYOUT4_RET_REC_ALL}。"
    },
    {
      "indent": 3,
      "text": "struct layoutreturn_file4 {\n        offset4         lrf_offset;\n        length4         lrf_length;\n        stateid4        lrf_stateid;\n        /* layouttype4 specific data */\n        opaque          lrf_body<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union layoutreturn4 switch(layoutreturn_type4 lr_returntype) {\n        case LAYOUTRETURN4_FILE:\n                layoutreturn_file4      lr_layout;\n        default:\n                void;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct LAYOUTRETURN4args {\n        /* CURRENT_FH: file */\n        bool                    lora_reclaim;\n        layouttype4             lora_layout_type;\n        layoutiomode4           lora_iomode;\n        layoutreturn4           lora_layoutreturn;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.44.2. RESULT",
      "section_title": true,
      "ja": "18.44.2. 結果"
    },
    {
      "indent": 3,
      "text": "union layoutreturn_stateid switch (bool lrs_present) {\ncase TRUE:\n        stateid4                lrs_stateid;\ncase FALSE:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union LAYOUTRETURN4res switch (nfsstat4 lorr_status) {\ncase NFS4_OK:\n        layoutreturn_stateid    lorr_stateid;\ndefault:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.44.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.44.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation returns from the client to the server one or more layouts represented by the client ID (derived from the session ID in the preceding SEQUENCE operation), lora_layout_type, and lora_iomode. When lr_returntype is LAYOUTRETURN4_FILE, the returned layout is further identified by the current filehandle, lrf_offset, lrf_length, and lrf_stateid. If the lrf_length field is NFS4_UINT64_MAX, all bytes of the layout, starting at lrf_offset, are returned. When lr_returntype is LAYOUTRETURN4_FSID, the current filehandle is used to identify the file system and all layouts matching the client ID, the fsid of the file system, lora_layout_type, and lora_iomode are returned. When lr_returntype is LAYOUTRETURN4_ALL, all layouts matching the client ID, lora_layout_type, and lora_iomode are returned and the current filehandle is not used. After this call, the client MUST NOT use the returned layout(s) and the associated storage protocol to access the file data.",
      "ja": "この操作は、クライアントからサーバに（前回のシーケンス動作中のセッションIDに由来する）は、クライアントIDで表される1つまたは複数のレイアウト、lora_layout_type、及びlora_iomodeを返します。 lr_returntypeがLAYOUTRETURN4_FILEである場合、返されたレイアウトは、さらに、現在のファイルハンドル、lrf_offset、lrf_length、及びlrf_stateidによって識別されます。 lrf_lengthフィールドがNFS4_UINT64_MAXであれば、レイアウトのすべてのバイトは、lrf_offsetから始まる、返されます。 lr_returntypeがLAYOUTRETURN4_FSIDある場合は、現在のファイルハンドルは、ファイルシステムおよびクライアントIDに一致するすべてのレイアウトを識別するために使用され、ファイルシステム、lora_layout_type、およびlora_iomodeのFSIDが返されます。 lr_returntypeがLAYOUTRETURN4_ALLある場合は、クライアントID、lora_layout_type、およびlora_iomodeに一致するすべてのレイアウトが返され、現在のファイルハンドルが使用されていません。この呼び出しの後、クライアントは、ファイル・データにアクセスするために返されたレイアウト（S）と関連したストレージ・プロトコルを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "If the set of layouts designated in the case of LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL is empty, then no error results. In the case of LAYOUTRETURN4_FILE, the byte-range specified is returned even if it is a subdivision of a layout previously obtained with LAYOUTGET, a combination of multiple layouts previously obtained with LAYOUTGET, or a combination including some layouts previously obtained with LAYOUTGET, and one or more subdivisions of such layouts. When the byte-range does not designate any bytes for which a layout is held for the specified file, client ID, layout type and mode, no error results. See Section 12.5.5.2.1.5 for considerations with \"bulk\" return of layouts.",
      "ja": "LAYOUTRETURN4_FSID又はLAYOUTRETURN4_ALLの場合に指定されたレイアウトのセットが空である場合、エラー無しの結果。 LAYOUTRETURN4_FILEの場合には、指定されたバイト範囲は、それが以前にLAYOUTGETで得られたレイアウトの再分割、以前LAYOUTGETを用いて得られた複数のレイアウトの組み合わせ、またはいくつかの以前にLAYOUTGETで得られたレイアウトと、1つを含む組合せであっても返されますこのようなレイアウトの以上の細分化。バイト範囲は、レイアウトが指定されたファイル、クライアントID、レイアウトタイプとモード、エラー結果を得るために保持されている任意のバイトを指定していない場合。レイアウトの「バルク」のリターンとの考慮事項については、第12.5.5.2.1.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "The layout being returned may be a subset or superset of a layout specified by CB_LAYOUTRECALL. However, if it is a subset, the recall is not complete until the full recalled scope has been returned. Recalled scope refers to the byte-range in the case of LAYOUTRETURN4_FILE, the use of LAYOUTRETURN4_FSID, or the use of LAYOUTRETURN4_ALL. There must be a LAYOUTRETURN with a matching scope to complete the return even if all current layout ranges have been previously individually returned.",
      "ja": "返されるレイアウトはCB_LAYOUTRECALLによって指定されたレイアウトのサブセットまたはスーパーセットであってもよいです。それはサブセットである場合、完全なリコール範囲が戻ってきたまでしかし、リコールは完全ではありません。リコール範囲はLAYOUTRETURN4_FILE、LAYOUTRETURN4_FSIDの使用、又はLAYOUTRETURN4_ALLの使用の場合にはバイト範囲を指します。すべての現在のレイアウトの範囲は、以前に個別に戻ってきた場合でも返還を完了するために一致するスコープとLAYOUTRETURNがなければなりません。"
    },
    {
      "indent": 3,
      "text": "For all lr_returntype values, an iomode of LAYOUTIOMODE4_ANY specifies that all layouts that match the other arguments to LAYOUTRETURN (i.e., client ID, lora_layout_type, and one of current filehandle and range; fsid derived from current filehandle; or LAYOUTRETURN4_ALL) are being returned.",
      "ja": "返却されている全てlr_returntype値に対して、LAYOUTIOMODE4_ANYのIOModeにはLAYOUTRETURN（;現在のファイルハンドルに由来FSID又はLAYOUTRETURN4_ALLすなわち、クライアントID、lora_layout_type、及び現在のファイルハンドルと範囲のうちの1つ）に他の引数と一致するすべてのレイアウトがあることを指定します。"
    },
    {
      "indent": 3,
      "text": "In the case that lr_returntype is LAYOUTRETURN4_FILE, the lrf_stateid provided by the client is a layout stateid as returned from previous layout operations. Note that the \"seqid\" field of lrf_stateid MUST NOT be zero. See Sections 8.2, 12.5.3, and 12.5.5.2 for a further discussion and requirements.",
      "ja": "以前のレイアウト操作から返されるlr_returntypeがLAYOUTRETURN4_FILEである場合には、クライアントによって提供lrf_stateidは、レイアウトのstateidあります。 lrf_stateidの「SEQID」フィールドがゼロにされてはならないことに注意してください。さらなる議論と要件については、セクション8.2、12.5.3、および12.5.5.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Return of a layout or all layouts does not invalidate the mapping of storage device ID to a storage device address. The mapping remains in effect until specifically changed or deleted via device ID notification callbacks. Of course if there are no remaining layouts that refer to a previously used device ID, the server is free to delete a device ID without a notification callback, which will be the case when notifications are not in effect.",
      "ja": "レイアウトやすべてのレイアウトの戻り値は、記憶装置アドレスへのストレージデバイスIDのマッピングを無効にしません。具体的には、デバイスIDの通知コールバックを介して変更または削除されるまで、マッピングは有効のままです。以前に使用されているデバイスIDを参照してください何も残ってレイアウトが存在しない場合はもちろん、サーバは、通知が有効でないとき場合される、通知コールバックせずにデバイスIDを削除して自由です。"
    },
    {
      "indent": 3,
      "text": "If the lora_reclaim field is set to TRUE, the client is attempting to return a layout that was acquired before the restart of the metadata server during the metadata server's grace period. When returning layouts that were acquired during the metadata server's grace period, the client MUST set the lora_reclaim field to FALSE. The lora_reclaim field MUST be set to FALSE also when lr_layoutreturn is LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL. See LAYOUTCOMMIT (Section 18.42) for more details.",
      "ja": "lora_reclaimフィールドがTRUEに設定されている場合、クライアントは、メタデータサーバーの猶予期間中にメタデータ・サーバの再起動前に取得されたレイアウトを返すようにしようとしています。メタデータサーバーの猶予期間中に取得されたレイアウトを返すとき、クライアントはFALSEにlora_reclaimフィールドを設定しなければなりません。 lr_layoutreturnがLAYOUTRETURN4_FSIDまたはLAYOUTRETURN4_ALLあるときlora_reclaimフィールドもfalseに設定する必要があります。詳細は、LAYOUTCOMMIT（セクション18.42）を参照してください。"
    },
    {
      "indent": 3,
      "text": "Layouts may be returned when recalled or voluntarily (i.e., before the server has recalled them). In either case, the client must properly propagate state changed under the context of the layout to the storage device(s) or to the metadata server before returning the layout.",
      "ja": "（サーバは、それらをリコールしている、すなわち、前に）自発的にリコール時やレイアウトが返されてもよいです。いずれの場合においても、クライアントが適切な状態を伝達しなければならないレイアウトを戻す前に、記憶装置（複数可）またはメタデータサーバへのレイアウトのコンテキストで変化しました。"
    },
    {
      "indent": 3,
      "text": "If the client returns the layout in response to a CB_LAYOUTRECALL where the lor_recalltype field of the clora_recall field was LAYOUTRECALL4_FILE, the client should use the lor_stateid value from CB_LAYOUTRECALL as the value for lrf_stateid. Otherwise, it should use logr_stateid (from a previous LAYOUTGET result) or lorr_stateid (from a previous LAYRETURN result). This is done to indicate the point in time (in terms of layout stateid transitions) when the recall was sent. The client uses the precise lora_recallstateid value and MUST NOT set the stateid's seqid to zero; otherwise, NFS4ERR_BAD_STATEID MUST be returned. NFS4ERR_OLD_STATEID can be returned if the client is using an old seqid, and the server knows the client should not be using the old seqid. For example, the client uses the seqid on slot 1 of the session, receives the response with the new seqid, and uses the slot to send another request with the old seqid.",
      "ja": "クライアントはclora_recallフィールドのlor_recalltypeフィールドはLAYOUTRECALL4_FILEたCB_LAYOUTRECALLに応じてレイアウトを返した場合、クライアントはlrf_stateidの値としてCB_LAYOUTRECALLからlor_stateid値を使用すべきです。それ以外の場合は、（前LAYRETURN結果から）（前LAYOUTGET結果から）logr_stateid又はlorr_stateidを使用すべきです。これは、リコールが送信されたとき（レイアウトのstateid遷移の点で）時点を示すために行われます。クライアントは、正確なlora_recallstateid値を使用し、ゼロにたstateidのSEQIDを設定してはいけません。そうでない場合は、NFS4ERR_BAD_STATEIDを返さなければなりません。クライアントが古いSEQIDを使用している場合NFS4ERR_OLD_STATEIDを返すことができ、サーバは、クライアントが古いSEQIDを使用すべきではありません知っています。たとえば、クライアントがセッションのスロット1にSEQIDを使用して、新しいSEQIDでレスポンスを受信して​​、古いSEQIDで別の要求を送信するためのスロットを使用しています。"
    },
    {
      "indent": 3,
      "text": "If a client fails to return a layout in a timely manner, then the metadata server SHOULD use its control protocol with the storage devices to fence the client from accessing the data referenced by the layout. See Section 12.5.5 for more details.",
      "ja": "クライアントがタイムリーにレイアウトを返すことに失敗した場合は、メタデータサーバは、レイアウトによって参照されるデータにアクセスすることからフェンスへのストレージデバイスをクライアントにその制御プロトコルを使用すべきです。詳細については、セクション12.5.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the LAYOUTRETURN request sets the lora_reclaim field to TRUE after the metadata server's grace period, NFS4ERR_NO_GRACE is returned.",
      "ja": "LAYOUTRETURN要求がメタデータサーバーの猶予期間の後TRUEにlora_reclaimフィールドを設定した場合、NFS4ERR_NO_GRACEが返されます。"
    },
    {
      "indent": 3,
      "text": "If the LAYOUTRETURN request sets the lora_reclaim field to TRUE and lr_returntype is set to LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL, NFS4ERR_INVAL is returned.",
      "ja": "LAYOUTRETURN要求が設定した場合はTRUEとlr_returntypeにlora_reclaimフィールドがLAYOUTRETURN4_FSIDまたはLAYOUTRETURN4_ALLに設定されている、NFS4ERR_INVALが返されます。"
    },
    {
      "indent": 3,
      "text": "If the client sets the lr_returntype field to LAYOUTRETURN4_FILE, then the lrs_stateid field will represent the layout stateid as updated for this operation's processing; the current stateid will also be updated to match the returned value. If the last byte of any layout for the current file, client ID, and layout type is being returned and there are no remaining pending CB_LAYOUTRECALL operations for which a LAYOUTRETURN operation must be done, lrs_present MUST be FALSE, and no stateid will be returned. In addition, the COMPOUND request's current stateid will be set to the all-zeroes special stateid (see Section 16.2.3.1.2). The server MUST reject with NFS4ERR_BAD_STATEID any further use of the current stateid in that COMPOUND until the current stateid is re-established by a later stateid-returning operation.",
      "ja": "クライアントがLAYOUTRETURN4_FILEにlr_returntypeフィールドを設定した場合、この操作の処理のために更新され、その後、lrs_stateidフィールドは、レイアウトのstateidを表します。現在のstateidはまた、返された値と一致するように更新されます。現在のファイル、クライアントID、およびレイアウトタイプのための任意のレイアウトの最後のバイトが返されているとLAYOUTRETURN操作を行わなければならないために残っ保留CB_LAYOUTRECALL操作がない場合、lrs_presentはFALSEでなければならない、と何のstateidは返されません。また、複合要求の現在のstateidはすべてゼロの特別なstateidに設定されます（セクション16.2.3.1.2を参照してください）。現在のstateidは、後のstateid戻し操作によって再確立されるまで、サーバは、その化合物中NFS4ERR_BAD_STATEIDと現在のstateidの任意のさらなる使用を拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle retains its value.",
      "ja": "成功すると、現在のファイルハンドルは、その値を保持します。"
    },
    {
      "indent": 3,
      "text": "If the EXCHGID4_FLAG_BIND_PRINC_STATEID capability is set on the client ID (see Section 18.35), the server will require that the principal, security flavor, and if applicable, the GSS mechanism, combination that acquired the layout also be the one to send LAYOUTRETURN. This might not be possible if credentials for the principal are no longer available. The server will allow the machine credential or SSV credential (see Section 18.35) to send LAYOUTRETURN if LAYOUTRETURN's operation code was set in the spo_must_allow result of EXCHANGE_ID.",
      "ja": "EXCHGID4_FLAG_BIND_PRINC_STATEID機能は（項18.35を参照）、クライアントIDに設定されている場合、サーバーはその主要なセキュリティ風味を必要とし、該当する場合は、レイアウトを取得GSSメカニズム、組み合わせもLAYOUTRETURNを送信するために一つです。主体の資格が利用できなくなっている場合、これはできないかもしれません。サーバはLAYOUTRETURNの操作コードがEXCHANGE_IDのspo_must_allow結果に設定された場合、マシンの資格やSSV資格は（項18.35を参照）LAYOUTRETURNを送信することができます。"
    },
    {
      "indent": 0,
      "text": "18.44.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.44.4. 実装"
    },
    {
      "indent": 3,
      "text": "The final LAYOUTRETURN operation in response to a CB_LAYOUTRECALL callback MUST be serialized with any outstanding, intersecting LAYOUTRETURN operations. Note that it is possible that while a client is returning the layout for some recalled range, the server may recall a superset of that range (e.g., LAYOUTRECALL4_ALL); the final return operation for the latter must block until the former layout recall is done.",
      "ja": "CB_LAYOUTRECALLコールバックに応答して、最終LAYOUTRETURN動作が未処理、交差LAYOUTRETURN操作で直列化されなければなりません。クライアントがいくつかのリコール範囲のレイアウトを返している間に、サーバは、その範囲（例えば、LAYOUTRECALL4_ALL）のスーパーセットを呼び出すことが可能であることに留意されたいです。前者レイアウトリコールが完了するまで後者のための最終的な復帰動作をブロックしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Returning all layouts in a file system using LAYOUTRETURN4_FSID is typically done in response to a CB_LAYOUTRECALL for that file system as the final return operation. Similarly, LAYOUTRETURN4_ALL is used in response to a recall callback for all layouts. It is possible that the client already returned some outstanding layouts via individual LAYOUTRETURN calls and the call for LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL marks the end of the LAYOUTRETURN sequence. See Section 12.5.5.1 for more details.",
      "ja": "LAYOUTRETURN4_FSIDを使用して、ファイルシステム内のすべてのレイアウトを返すは、典型的には、最終的な復帰動作として、そのファイルシステムのCB_LAYOUTRECALLに応答して行われます。同様に、LAYOUTRETURN4_ALLは、すべてのレイアウトのためのリコールコールバックに応じて使用されています。クライアントがすでに個々LAYOUTRETURNコールを経由して、いくつかの優れたレイアウトを返し、LAYOUTRETURN4_FSIDまたはLAYOUTRETURN4_ALLための呼び出しがLAYOUTRETURNシーケンスの終わりを示している可能性があります。詳細はセクション12.5.5.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Once the client has returned all layouts referring to a particular device ID, the server MAY delete the device ID.",
      "ja": "クライアントは、特定のデバイスIDを参照するすべてのレイアウトを返した後は、サーバは、デバイスIDを削除することができます。"
    },
    {
      "indent": 0,
      "text": "18.45. Operation 52: SECINFO_NO_NAME - Get Security on Unnamed Object",
      "section_title": true,
      "ja": "18.45. 操作52：SECINFO_NO_NAME  - 無名オブジェクトのセキュリティを入手"
    },
    {
      "indent": 0,
      "text": "18.45.1. ARGUMENT",
      "section_title": true,
      "ja": "18.45.1. 引数"
    },
    {
      "indent": 3,
      "text": "enum secinfo_style4 { SECINFO_STYLE4_CURRENT_FH = 0, SECINFO_STYLE4_PARENT = 1 };",
      "ja": "列挙secinfo_style4 {SECINFO_STYLE4_CURRENT_FH = 0、SECINFO_STYLE4_PARENT = 1}。"
    },
    {
      "indent": 3,
      "text": "/* CURRENT_FH: object or child directory */\ntypedef secinfo_style4 SECINFO_NO_NAME4args;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.45.2. RESULT",
      "section_title": true,
      "ja": "18.45.2. 結果"
    },
    {
      "indent": 3,
      "text": "/* CURRENTFH: consumed if status is NFS4_OK */\ntypedef SECINFO4res SECINFO_NO_NAME4res;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.45.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.45.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "Like the SECINFO operation, SECINFO_NO_NAME is used by the client to obtain a list of valid RPC authentication flavors for a specific file object. Unlike SECINFO, SECINFO_NO_NAME only works with objects that are accessed by filehandle.",
      "ja": "SECINFO操作と同様に、SECINFO_NO_NAMEは、特定のファイルオブジェクトの有効なRPC認証フレーバのリストを取得するために、クライアントによって使用されます。 SECINFOとは異なり、SECINFO_NO_NAMEはファイルハンドルによってアクセスされるオブジェクトで動作します。"
    },
    {
      "indent": 3,
      "text": "There are two styles of SECINFO_NO_NAME, as determined by the value of the secinfo_style4 enumeration. If SECINFO_STYLE4_CURRENT_FH is passed, then SECINFO_NO_NAME is querying for the required security for the current filehandle. If SECINFO_STYLE4_PARENT is passed, then SECINFO_NO_NAME is querying for the required security of the current filehandle's parent. If the style selected is SECINFO_STYLE4_PARENT, then SECINFO should apply the same access methodology used for LOOKUPP when evaluating the traversal to the parent directory. Therefore, if the requester does not have the appropriate access to LOOKUPP the parent, then SECINFO_NO_NAME must behave the same way and return NFS4ERR_ACCESS.",
      "ja": "secinfo_style4列挙の値によって決定されるSECINFO_NO_NAMEの2つのスタイルがあります。 SECINFO_STYLE4_CURRENT_FHが渡された場合、SECINFO_NO_NAMEは、現在のファイルハンドルのために必要なセキュリティのために照会されます。 SECINFO_STYLE4_PARENTが渡された場合、SECINFO_NO_NAMEは、現在のファイルハンドルの親の必要なセキュリティのために照会されます。選択されたスタイルがSECINFO_STYLE4_PARENTであれば、SECINFOは、親ディレクトリにトラバーサルを評価するときにLOOKUPPのために使用したのと同じアクセス方法論を適用する必要があります。依頼者が親をLOOKUPPするための適切なアクセス権を持っていない場合、したがって、その後、SECINFO_NO_NAMEは同じように動作し、NFS4ERR_ACCESSを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If PUTFH, PUTPUBFH, PUTROOTFH, or RESTOREFH returns NFS4ERR_WRONGSEC, then the client resolves the situation by sending a COMPOUND request that consists of PUTFH, PUTPUBFH, or PUTROOTFH immediately followed by SECINFO_NO_NAME, style SECINFO_STYLE4_CURRENT_FH. See Section 2.6 for instructions on dealing with NFS4ERR_WRONGSEC error returns from PUTFH, PUTROOTFH, PUTPUBFH, or RESTOREFH.",
      "ja": "PUTFH、PUTPUBFH、PUTROOTFH、またはRESTOREFHはNFS4ERR_WRONGSECを返した場合、クライアントはすぐにSECINFO_NO_NAME、スタイルSECINFO_STYLE4_CURRENT_FH続いPUTFH、PUTPUBFH、またはPUTROOTFHで構成COMPOUND要求を送信することによって、状況を解決します。 PUTFH、PUTROOTFH、PUTPUBFH、またはRESTOREFHからNFS4ERR_WRONGSECエラーリターンを扱う方法については、2.6節を参照してください。"
    },
    {
      "indent": 3,
      "text": "If SECINFO_STYLE4_PARENT is specified and there is no parent directory, SECINFO_NO_NAME MUST return NFS4ERR_NOENT.",
      "ja": "SECINFO_STYLE4_PARENTが指定され、親ディレクトリが存在しない場合、SECINFO_NO_NAMEはNFS4ERR_NOENTを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "On success, the current filehandle is consumed (see Section 2.6.3.1.1.8), and if the next operation after SECINFO_NO_NAME tries to use the current filehandle, that operation will fail with the status NFS4ERR_NOFILEHANDLE.",
      "ja": "成功すると、現在のファイルハンドルは、（セクション2.6.3.1.1.8を参照）が消費され、そしてSECINFO_NO_NAME後、次の操作は、現在のファイルハンドルを使用しようとした場合、その操作は、ステータスNFS4ERR_NOFILEHANDLEで失敗します。"
    },
    {
      "indent": 3,
      "text": "Everything else about SECINFO_NO_NAME is the same as SECINFO. See the discussion on SECINFO (Section 18.29.3).",
      "ja": "SECINFO_NO_NAMEについての他のすべてはSECINFOと同じです。 SECINFO（セクション18.29.3）の説明を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.45.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.45.4. 実装"
    },
    {
      "indent": 3,
      "text": "See the discussion on SECINFO (Section 18.29.4).",
      "ja": "SECINFO（セクション18.29.4）の説明を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.46. Operation 53: SEQUENCE - Supply Per-Procedure Sequencing and Control",
      "ja": "18.46. 操作53：SEQUENCE  - サプライごとの手順シーケンシングおよびコントロール"
    },
    {
      "indent": 0,
      "text": "18.46.1. ARGUMENT",
      "section_title": true,
      "ja": "18.46.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct SEQUENCE4args {\n        sessionid4     sa_sessionid;\n        sequenceid4    sa_sequenceid;\n        slotid4        sa_slotid;\n        slotid4        sa_highest_slotid;\n        bool           sa_cachethis;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.46.2. RESULT",
      "section_title": true,
      "ja": "18.46.2. 結果"
    },
    {
      "indent": 3,
      "text": "const SEQ4_STATUS_CB_PATH_DOWN                  = 0x00000001;\nconst SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING      = 0x00000002;\nconst SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED       = 0x00000004;\nconst SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED     = 0x00000008;\nconst SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED    = 0x00000010;\nconst SEQ4_STATUS_ADMIN_STATE_REVOKED           = 0x00000020;\nconst SEQ4_STATUS_RECALLABLE_STATE_REVOKED      = 0x00000040;\nconst SEQ4_STATUS_LEASE_MOVED                   = 0x00000080;\nconst SEQ4_STATUS_RESTART_RECLAIM_NEEDED        = 0x00000100;\nconst SEQ4_STATUS_CB_PATH_DOWN_SESSION          = 0x00000200;\nconst SEQ4_STATUS_BACKCHANNEL_FAULT             = 0x00000400;\nconst SEQ4_STATUS_DEVID_CHANGED                 = 0x00000800;\nconst SEQ4_STATUS_DEVID_DELETED                 = 0x00001000;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct SEQUENCE4resok {\n        sessionid4      sr_sessionid;\n        sequenceid4     sr_sequenceid;\n        slotid4         sr_slotid;\n        slotid4         sr_highest_slotid;\n        slotid4         sr_target_highest_slotid;\n        uint32_t        sr_status_flags;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union SEQUENCE4res switch (nfsstat4 sr_status) {\ncase NFS4_OK:\n        SEQUENCE4resok  sr_resok4;\ndefault:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.46.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.46.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The SEQUENCE operation is used by the server to implement session request control and the reply cache semantics.",
      "ja": "シーケンス動作は、セッション要求コントロールと応答キャッシュのセマンティクスを実装するためにサーバーによって使用されます。"
    },
    {
      "indent": 3,
      "text": "SEQUENCE MUST appear as the first operation of any COMPOUND in which it appears. The error NFS4ERR_SEQUENCE_POS will be returned when it is found in any position in a COMPOUND beyond the first. Operations other than SEQUENCE, BIND_CONN_TO_SESSION, EXCHANGE_ID, CREATE_SESSION, and DESTROY_SESSION, MUST NOT appear as the first operation in a COMPOUND. Such operations MUST yield the error NFS4ERR_OP_NOT_IN_SESSION if they do appear at the start of a COMPOUND.",
      "ja": "SEQUENCEは、それが表示される任意の化合物の第1の動作として現れなければなりません。それは最初に越えた化合物中の任意の位置で発見されたときにエラーNFS4ERR_SEQUENCE_POSが返されます。 SEQUENCE以外の操作、BIND_CONN_TO_SESSION、EXCHANGE_ID、CREATE_SESSION、およびDESTROY_SESSIONは、化合物中の最初の操作として表示されてはなりません。彼らはCOMPOUNDの開始時に表示されない場合、このような操作は、エラーNFS4ERR_OP_NOT_IN_SESSIONを得なければなりません。"
    },
    {
      "indent": 3,
      "text": "If SEQUENCE is received on a connection not associated with the session via CREATE_SESSION or BIND_CONN_TO_SESSION, and connection association enforcement is enabled (see Section 18.35), then the server returns NFS4ERR_CONN_NOT_BOUND_TO_SESSION.",
      "ja": "配列が有効になっているCREATE_SESSION又はBIND_CONN_TO_SESSION、接続関連執行を介してセッションに関連付けられていない接続上で受信された場合（セクション18.35を参照）、サーバはNFS4ERR_CONN_NOT_BOUND_TO_SESSIONを返します。"
    },
    {
      "indent": 3,
      "text": "The sa_sessionid argument identifies the session to which this request applies. The sr_sessionid result MUST equal sa_sessionid.",
      "ja": "sa_sessionid引数は、この要求が適用されるセッションを識別する。 sr_sessionid結果はsa_sessionid等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sa_slotid argument is the index in the reply cache for the request. The sa_sequenceid field is the sequence number of the request for the reply cache entry (slot). The sr_slotid result MUST equal sa_slotid. The sr_sequenceid result MUST equal sa_sequenceid.",
      "ja": "sa_slotid引数は、要求に対する応答キャッシュのインデックスです。 sa_sequenceidフィールドは、応答キャッシュエントリ（スロット）要求のシーケンス番号です。 sr_slotid結果はsa_slotidに等しくなければなりません。 sr_sequenceid結果はsa_sequenceidに等しくなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sa_highest_slotid argument is the highest slot ID for which the client has a request outstanding; it could be equal to sa_slotid. The server returns two \"highest_slotid\" values: sr_highest_slotid and sr_target_highest_slotid. The former is the highest slot ID the server will accept in future SEQUENCE operation, and SHOULD NOT be less than the value of sa_highest_slotid (but see Section 2.10.6.1 for an exception). The latter is the highest slot ID the server would prefer the client use on a future SEQUENCE operation.",
      "ja": "sa_highest_slotid引数は、クライアントが未処理の要求を持っている最高のスロットIDです。それはsa_slotidに等しい可能性があります。 sr_highest_slotidとsr_target_highest_slotid：サーバーは、二つの「highest_slotid」の値を返します。前者は、サーバが、将来のシーケンス動作に受け入れる、とsa_highest_slotidの値未満であるべきではない（ただし、例外は、セクション2.10.6.1を参照）最高スロットIDです。後者は、サーバが、将来のシーケンス動作上のクライアントの使用を好むだろう最高のスロットIDです。"
    },
    {
      "indent": 3,
      "text": "If sa_cachethis is TRUE, then the client is requesting that the server cache the entire reply in the server's reply cache; therefore, the server MUST cache the reply (see Section 2.10.6.1.3). The server MAY cache the reply if sa_cachethis is FALSE. If the server does not cache the entire reply, it MUST still record that it executed the request at the specified slot and sequence ID.",
      "ja": "sa_cachethisがTRUEの場合、クライアントは、サーバがサーバの応答をキャッシュに全体の応答をキャッシュすることを要求しています。そのため、サーバは（セクション2.10.6.1.3を参照）、応答をキャッシュしなければなりません。 sa_cachethisがFALSEの場合、サーバーは応答をキャッシュしてもよいです。サーバー全体の応答をキャッシュしていない場合、それはまだそれが指定されたスロットおよびシーケンスIDで要求を実行したことを記録しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The response to the SEQUENCE operation contains a word of status flags (sr_status_flags) that can provide to the client information related to the status of the client's lock state and communications paths. Note that any status bits relating to lock state MAY be reset when lock state is lost due to a server restart (even if the session is persistent across restarts; session persistence does not imply lock state persistence) or the establishment of a new client instance.",
      "ja": "シーケンス動作に対する応答は、クライアントのロック状態及び通信パスの状態に関するクライアント情報を提供することができる状態フラグ（sr_status_flags）の単語を含んでいます。ロック状態が失われたときの状態をロックに関連するステータスビットが（セッションが再起動して、永続的である場合でも、セッションの永続性は、ロック状態の持続を意味するものではありません）により、サーバの再起動にリセットされるかもしれないことに注意してください、または新しいクライアント・インスタンスの設立。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_CB_PATH_DOWN When set, indicates that the client has no operational backchannel path for any session associated with the client ID, making it necessary for the client to re-establish one. This bit remains set on all SEQUENCE responses on all sessions associated with the client ID until at least one backchannel is available on any session associated with the client ID. If the client fails to re-establish a backchannel for the client ID, it is subject to having recallable state revoked.",
      "ja": "設定した場合SEQ4_STATUS_CB_PATH_DOWNは、クライアントは、それが必要なクライアントが1を再確立するために作る、クライアントIDに関連付けられているすべてのセッションのための運用バックチャネルパスを持っていないことを示しています。このビットは、少なくとも一つのバックチャネルまでのクライアントIDに関連付けられているすべてのセッションのすべてのSEQUENCE応答にセットされたままでは、クライアントIDに関連付けられているすべてのセッションで使用可能です。クライアントは、クライアントIDのためのバックチャネルを再確立するために失敗した場合は、リコール状態が取り消された対象です。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_CB_PATH_DOWN_SESSION When set, indicates that the session has no operational backchannel. There are two reasons why SEQ4_STATUS_CB_PATH_DOWN_SESSION may be set and not SEQ4_STATUS_CB_PATH_DOWN. First is that a callback operation that applies specifically to the session (e.g., CB_RECALL_SLOT, see Section 20.8) needs to be sent. Second is that the server did send a callback operation, but the connection was lost before the reply. The server cannot be sure whether or not the client received the callback operation, and so, per rules on request retry, the server MUST retry the callback operation over the same session. The SEQ4_STATUS_CB_PATH_DOWN_SESSION bit is the indication to the client that it needs to associate a connection to the session's backchannel. This bit remains set on all SEQUENCE responses of the session until a connection is associated with the session's a backchannel. If the client fails to re-establish a backchannel for the session, it is subject to having recallable state revoked.",
      "ja": "SEQ4_STATUS_CB_PATH_DOWN_SESSION設定すると、セッションが何の操作バックチャネルを持っていないことを示しています。 SEQ4_STATUS_CB_PATH_DOWN_SESSIONがSEQ4_STATUS_CB_PATH_DOWNを設定していないことも理由は2つあります。最初のセッション（例えば、CB_RECALL_SLOTは、セクション20.8を参照のこと）に特異的に適用されるコールバックオペレーションを送信する必要があることです。第二には、サーバーがコールバック操作を送ったことですが、接続が応答する前に失われました。サーバーは、クライアントがコールバック操作を受けたかどうかを確認することはできません、そのため、要求の再試行のルールごとに、サーバーは、同じセッションでコールバック操作を再試行しなければなりません。 SEQ4_STATUS_CB_PATH_DOWN_SESSIONビットは、それがセッションのバックチャネルへの接続を関連付ける必要があるクライアントへの指示です。接続がセッションのバックチャネルに関連付けされるまで、このビットは、セッションのすべてのSEQUENCE応答にセットされたまま。クライアントがセッションのためのバックチャネルを再確立するために失敗した場合は、リコール状態が取り消された対象です。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING When set, indicates that all GSS contexts or RPCSEC_GSS handles assigned to the session's backchannel will expire within a period equal to the lease time. This bit remains set on all SEQUENCE replies until at least one of the following are true:",
      "ja": "SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRINGセットは、セッションのバックチャネルに割り当てられたすべてのGSSコンテキストまたはRPCSEC_GSSハンドルがリース期間に等しい期間内に期限切れになることを示している場合。このビットは、すべての配列に設定されたまま、次の少なくとも一つに該当するまでの返信："
    },
    {
      "indent": 6,
      "text": "* All SSV RPCSEC_GSS handles on the session's backchannel have been destroyed and all non-SSV GSS contexts have expired.",
      "ja": "* SSV RPCSEC_GSSは、セッションのバックチャネル上で扱うすべてが破壊されていると、すべての非SSV GSSコンテキストの有効期限が切れています。"
    },
    {
      "indent": 6,
      "text": "* At least one more SSV RPCSEC_GSS handle has been added to the backchannel.",
      "ja": "*少なくとも1つの以上SSVのRPCSEC_GSSハンドルがバックチャネルに追加されました。"
    },
    {
      "indent": 6,
      "text": "* The expiration time of at least one non-SSV GSS context of an RPCSEC_GSS handle is beyond the lease period from the current time (relative to the time of when a SEQUENCE response was sent)",
      "ja": "* RPCSEC_GSSハンドルの少なくとも一つの非SSV GSSコンテキストの有効期限は、現在の時刻（SEQUENCE応答が送信されたときの時間に対して）からリース期間を超えています"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED When set, indicates all non-SSV GSS contexts and all SSV RPCSEC_GSS handles assigned to the session's backchannel have expired or have been destroyed. This bit remains set on all SEQUENCE replies until at least one non-expired non-SSV GSS context for the session's backchannel has been established or at least one SSV RPCSEC_GSS handle has been assigned to the backchannel.",
      "ja": "設定SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIREDは、すべての非SSV GSSコンテキストを示し、すべてのSSV RPCSEC_GSSは、期限が切れたセッションのバックチャネルに割り当てられたハンドルまたは破壊されました。このビットは、すべての配列に設定されたままのセッションのバックチャネルのための少なくとも一つの非期限切れの非SSV GSSコンテキストが確立されているか、または少なくとも一つのSSVのRPCSEC_GSSハンドルがバックチャネルに割り当てられるまで応答します。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED When set, indicates that the lease has expired and as a result the server released all of the client's locking state. This status bit remains set on all SEQUENCE replies until the loss of all such locks has been acknowledged by use of FREE_STATEID (see Section 18.38), or by establishing a new client instance by destroying all sessions (via DESTROY_SESSION), the client ID (via DESTROY_CLIENTID), and then invoking EXCHANGE_ID and CREATE_SESSION to establish a new client ID.",
      "ja": "SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKEDセットは、リースの有効期限が切れていると、結果としてサーバーがクライアントのロック状態のすべてをリリースしていることを示します。このステータスビットは、すべての配列に設定されたままになり、すべてのそのようなロックの損失がFREE_STATEIDの使用によって確認されるまで（項18.38を参照してください）返信、または（DESTROY_SESSIONを経由して）すべてのセッションを破壊することによって、新しいクライアントのインスタンスを設定することにより、クライアントID（経由DESTROY_CLIENTID）、その後、新しいクライアントIDを確立するEXCHANGE_IDとCREATE_SESSIONを呼び出します。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED When set, indicates that some subset of the client's locks have been revoked due to expiration of the lease period followed by another client's conflicting LOCK operation. This status bit remains set on all SEQUENCE replies until the loss of all such locks has been acknowledged by use of FREE_STATEID.",
      "ja": "設定した場合SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKEDは、クライアントのロックのいくつかのサブセットが原因別のクライアントの競合LOCK操作に続いて、リース期間の満了に失効したことを示しています。このステータスビットは、すべての配列に設定されたままになり、すべてのそのようなロックの損失がFREE_STATEIDの使用によって確認されるまで応答します。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_ADMIN_STATE_REVOKED When set, indicates that one or more locks have been revoked without expiration of the lease period, due to administrative action. This status bit remains set on all SEQUENCE replies until the loss of all such locks has been acknowledged by use of FREE_STATEID.",
      "ja": "設定した場合SEQ4_STATUS_ADMIN_STATE_REVOKEDは、一つ以上のロックが原因行政行為に、リース期間の満了せずに失効したことを示しています。このステータスビットは、すべての配列に設定されたままになり、すべてのそのようなロックの損失がFREE_STATEIDの使用によって確認されるまで応答します。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_RECALLABLE_STATE_REVOKED When set, indicates that one or more recallable objects have been revoked without expiration of the lease period, due to the client's failure to return them when recalled, which may be a consequence of there being no working backchannel and the client failing to re-establish a backchannel per the SEQ4_STATUS_CB_PATH_DOWN, SEQ4_STATUS_CB_PATH_DOWN_SESSION, or SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED status flags. This status bit remains set on all SEQUENCE replies until the loss of all such locks has been acknowledged by use of FREE_STATEID.",
      "ja": "SEQ4_STATUS_RECALLABLE_STATE_REVOKEDセットは、一つ以上のリコール対象物が原因そこには働いてバックチャネルであることないの結果及び再に失敗したクライアントかもしれリコールときにそれらを返すために、クライアントの失敗に、リース期間の満了せずに失効したことを示している場合SEQ4_STATUS_CB_PATH_DOWNあたりのバックチャネル、SEQ4_STATUS_CB_PATH_DOWN_SESSION、またはSEQ4_STATUS_CB_GSS_CONTEXTS_EXPIREDステータスフラグを確立します。このステータスビットは、すべての配列に設定されたままになり、すべてのそのようなロックの損失がFREE_STATEIDの使用によって確認されるまで応答します。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_LEASE_MOVED When set, indicates that responsibility for lease renewal has been transferred to one or more new servers. This condition will continue until the client receives an NFS4ERR_MOVED error and the server receives the subsequent GETATTR for the fs_locations or fs_locations_info attribute for an access to each file system for which a lease has been moved to a new server. See Section 11.7.7.1.",
      "ja": "SEQ4_STATUS_LEASE_MOVED設定した場合、リース更新のための責任が1つ以上の新しいサーバに転送されたことを示します。クライアントがNFS4ERR_MOVEDエラーを受信して​​、サーバがfs_位置またはリースを新しいサーバーに移動された各ファイルシステムへのアクセスのための属性fs_locations_infoその後のGETATTRを受信するまでこの状態が継続されます。セクション11.7.7.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_RESTART_RECLAIM_NEEDED When set, indicates that due to server restart, the client must reclaim locking state. Until the client sends a global RECLAIM_COMPLETE (Section 18.51), every SEQUENCE operation will return SEQ4_STATUS_RESTART_RECLAIM_NEEDED.",
      "ja": "設定した場合SEQ4_STATUS_RESTART_RECLAIM_NEEDEDは、サーバの再起動のために、クライアントは状態をロック取り戻す必要があることを示します。クライアントがグローバルRECLAIM_COMPLETE（セクション18.51）を送信するまで、すべてのシーケンス動作はSEQ4_STATUS_RESTART_RECLAIM_NEEDEDを返します。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_BACKCHANNEL_FAULT The server has encountered an unrecoverable fault with the backchannel (e.g., it has lost track of the sequence ID for a slot in the backchannel). The client MUST stop sending more requests on the session's fore channel, wait for all outstanding requests to complete on the fore and back channel, and then destroy the session.",
      "ja": "SEQ4_STATUS_BACKCHANNEL_FAULTサーバは、（例えば、それはバックチャネルのスロットのシーケンスIDの追跡を失った）バックチャネルと、回復不能な障害が発生しました。クライアントは、セッションの前部チャネル上の多くのリクエストの送信を停止し、すべての未処理の要求がフォア、バックチャネル上で完了するのを待ち、その後、セッションを破棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_DEVID_CHANGED The client is using device ID notifications and the server has changed a device ID mapping held by the client. This flag will stay present until the client has obtained the new mapping with GETDEVICEINFO.",
      "ja": "SEQ4_STATUS_DEVID_CHANGEDクライアントは、デバイスIDの通知を使用していると、サーバは、クライアントが保持しているデバイスIDのマッピングを変更しました。クライアントがGETDEVICEINFOで新しいマッピングを取得するまで、このフラグは、現在のままになります。"
    },
    {
      "indent": 3,
      "text": "SEQ4_STATUS_DEVID_DELETED The client is using device ID notifications and the server has deleted a device ID mapping held by the client. This flag will stay in effect until the client sends a GETDEVICEINFO on the device ID with a null value in the argument gdia_notify_types.",
      "ja": "SEQ4_STATUS_DEVID_DELETEDクライアントは、デバイスIDの通知を使用していると、サーバは、クライアントが保持しているデバイスIDのマッピングを削除しました。クライアントは、引数gdia_notify_typesにNULL値を持つデバイスIDにGETDEVICEINFOを送信するまで、このフラグは有効のままになります。"
    },
    {
      "indent": 3,
      "text": "The value of the sa_sequenceid argument relative to the cached sequence ID on the slot falls into one of three cases.",
      "ja": "スロット上のキャッシュされたシーケンスIDに対してsa_sequenceid引数の値は、3つの状況に陥ります。"
    },
    {
      "indent": 3,
      "text": "o If the difference between sa_sequenceid and the server's cached sequence ID at the slot ID is two (2) or more, or if sa_sequenceid is less than the cached sequence ID (accounting for wraparound of the unsigned sequence ID value), then the server MUST return NFS4ERR_SEQ_MISORDERED.",
      "ja": "O sa_sequenceidとサーバのキャッシュされたシーケンスIDとの間の差は、スロットIDは、2つ（2）以上、またはsa_sequenceidは、キャッシュされたシーケンス番号よりも小さい場合（符号なしシーケンス番号値のラップアラウンドを占める）、その後、サーバは必要がありで場合NFS4ERR_SEQ_MISORDEREDを返します。"
    },
    {
      "indent": 3,
      "text": "o If sa_sequenceid and the cached sequence ID are the same, this is a retry, and the server replies with what is recorded in the reply cache. The lease is possibly renewed as described below.",
      "ja": "sa_sequenceidとキャッシュされたシーケンスIDが同じであれば、O、これは再試行され、サーバが応答キャッシュ内に記録されているもので応答します。リースは、おそらく以下に記載するように更新されます。"
    },
    {
      "indent": 3,
      "text": "o If sa_sequenceid is one greater (accounting for wraparound) than the cached sequence ID, then this is a new request, and the slot's sequence ID is incremented. The operations subsequent to SEQUENCE, if any, are processed. If there are no other operations, the only other effects are to cache the SEQUENCE reply in the slot, maintain the session's activity, and possibly renew the lease.",
      "ja": "sa_sequenceidが1より大きい場合には、キャッシュされたシーケンス番号よりも、（ラップアラウンドを占める）O、これは新しい要求で、スロットのシーケンス番号がインクリメントされます。 SEQUENCE以降の操作は、もしあれば、処理されます。他の操作がない場合、唯一の他の効果は、スロット内のSEQUENCE応答をキャッシュセッションの活性を維持し、おそらくリースを更新することです。"
    },
    {
      "indent": 3,
      "text": "If the client reuses a slot ID and sequence ID for a completely different request, the server MAY treat the request as if it is a retry of what it has already executed. The server MAY however detect the client's illegal reuse and return NFS4ERR_SEQ_FALSE_RETRY.",
      "ja": "クライアントは完全に異なる要求のためのスロットIDとシーケンスIDを再利用する場合は、それがすでに実行されたものの再試行であるかのように、サーバがリクエストを処理するかもしれません。サーバーは、しかし、クライアントの不正な再利用を検出し、NFS4ERR_SEQ_FALSE_RETRYが返されることがあります。"
    },
    {
      "indent": 3,
      "text": "If SEQUENCE returns an error, then the state of the slot (sequence ID, cached reply) MUST NOT change, and the associated lease MUST NOT be renewed.",
      "ja": "SEQUENCEがエラーを返す場合、スロット（シーケンスID、キャッシュされた応答）の状態は変化してはいけません、そして関連するリースを更新してはいけません。"
    },
    {
      "indent": 3,
      "text": "If SEQUENCE returns NFS4_OK, then the associated lease MUST be renewed (see Section 8.3), except if SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED is returned in sr_status_flags.",
      "ja": "SEQUENCEはNFS4_OKを返す場合、関連するリースはSEQ4_STATUS_EXPIRED_ALL_STATE_REVOKEDがsr_status_flagsに返された場合を除き、（セクション8.3を参照）更新する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.46.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.46.4. 実装"
    },
    {
      "indent": 3,
      "text": "The server MUST maintain a mapping of session ID to client ID in order to validate any operations that follow SEQUENCE that take a stateid as an argument and/or result.",
      "ja": "サーバーは、引数および/または結果としてのstateidを取るSEQUENCEに続くすべての操作を検証するために、クライアントIDにセッションIDのマッピングを維持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the client establishes a persistent session, then a SEQUENCE received after a server restart might encounter requests performed and recorded in a persistent reply cache before the server restart. In this case, SEQUENCE will be processed successfully, while requests that were not previously performed and recorded are rejected with NFS4ERR_DEADSESSION.",
      "ja": "クライアントが永続セッションを確立した場合、サーバの再起動後に受信したシーケンスは、サーバーの再起動の前に持続応答キャッシュで行われ、記録要求が発生する場合があります。以前に実行され、記録されていなかった要求はNFS4ERR_DEADSESSIONで拒否されている間、この場合は、SEQUENCEは、正常に処理されます。"
    },
    {
      "indent": 3,
      "text": "Depending on which of the operations within the COMPOUND were successfully performed before the server restart, these operations will also have replies sent from the server reply cache. Note that when these operations establish locking state, it is locking state that applies to the previous server instance and to the previous client ID, even though the server restart, which logically happened after these operations, eliminated that state. In the case of a partially executed COMPOUND, processing may reach an operation not processed during the earlier server instance, making this operation a new one and not performable on the existing session. In this case, NFS4ERR_DEADSESSION will be returned from that operation.",
      "ja": "成功したサーバの再起動前に実行された化合物内の操作のどちらに応じて、これらの操作は、サーバーの応答キャッシュから送信された応答をも持つことになります。これらの操作がロック状態を確立するとき、それは論理的にこれらの操作の後に起こったサーバの再起動は、その状態を解消しても、以前のサーバーインスタンスに、前のクライアントIDに適用される状態をロックしていることに注意してください。部分的に実行される化合物の場合、処理は、この操作新しいものと既存のセッションで実行可能ではないなって、以前のサーバーインスタンス中に処理されない動作に到達することができます。この場合、NFS4ERR_DEADSESSIONは、その操作から返されます。"
    },
    {
      "indent": 0,
      "text": "18.47. Operation 54: SET_SSV - Update SSV for a Client ID",
      "section_title": true,
      "ja": "18.47. 操作54：SET_SSV  - クライアントIDのアップデートSSV"
    },
    {
      "indent": 0,
      "text": "18.47.1. ARGUMENT",
      "section_title": true,
      "ja": "18.47.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct ssa_digest_input4 {\n        SEQUENCE4args sdi_seqargs;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct SET_SSV4args {\n        opaque          ssa_ssv<>;\n        opaque          ssa_digest<>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.47.2. RESULT",
      "section_title": true,
      "ja": "18.47.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct ssr_digest_input4 {\n        SEQUENCE4res sdi_seqres;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct SET_SSV4resok {\n        opaque          ssr_digest<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union SET_SSV4res switch (nfsstat4 ssr_status) {\ncase NFS4_OK:\n        SET_SSV4resok   ssr_resok4;\ndefault:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.47.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.47.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation is used to update the SSV for a client ID. Before SET_SSV is called the first time on a client ID, the SSV is zero. The SSV is the key used for the SSV GSS mechanism (Section 2.10.9)",
      "ja": "この操作は、クライアントIDのためのSSVを更新するために使用されます。 SET_SSVは、クライアントIDで初めて呼び出される前に、SSVはゼロです。 SSVは、SSV GSSメカニズムのために使用されるキーである（セクション2.10.9）"
    },
    {
      "indent": 3,
      "text": "SET_SSV MUST be preceded by a SEQUENCE operation in the same COMPOUND. It MUST NOT be used if the client did not opt for SP4_SSV state protection when the client ID was created (see Section 18.35); the server returns NFS4ERR_INVAL in that case.",
      "ja": "SET_SSVは同じ化合物中のシーケンス動作が先行されなければなりません。クライアントIDが作成されたとき、クライアントはSP4_SSV状態の保護のために選ぶなかった場合は（項18.35を参照）使用してはいけません。サーバは、そのような場合にはNFS4ERR_INVALを返します。"
    },
    {
      "indent": 3,
      "text": "The field ssa_digest is computed as the output of the HMAC (RFC 2104 [11]) using the subkey derived from the SSV4_SUBKEY_MIC_I2T and current SSV as the key (see Section 2.10.9 for a description of subkeys), and an XDR encoded value of data type ssa_digest_input4. The field sdi_seqargs is equal to the arguments of the SEQUENCE operation for the COMPOUND procedure that SET_SSV is within.",
      "ja": "フィールドssa_digestはHMACの出力として計算される（RFC 2104 [11]）（サブキーの説明については、セクション2.10.9を参照）をキーとしてSSV4_SUBKEY_MIC_I2Tと現在SSV由来するサブキーを使用して、そしてXDR符号化された値のデータ・タイプssa_digest_input4。フィールドsdi_seqargs SET_SSVの範囲内であるCOMPOUND手順のシーケンス動作の引数と同じです。"
    },
    {
      "indent": 3,
      "text": "The argument ssa_ssv is XORed with the current SSV to produce the new SSV. The argument ssa_ssv SHOULD be generated randomly.",
      "ja": "引数ssa_ssvは新しいSSVを生成するために、現在のSSVとXORされます。引数ssa_ssvは、ランダムに生成されるべきです。"
    },
    {
      "indent": 3,
      "text": "In the response, ssr_digest is the output of the HMAC using the subkey derived from SSV4_SUBKEY_MIC_T2I and new SSV as the key, and an XDR encoded value of data type ssr_digest_input4. The field sdi_seqres is equal to the results of the SEQUENCE operation for the COMPOUND procedure that SET_SSV is within.",
      "ja": "これに応答して、ssr_digestキーとしてSSV4_SUBKEY_MIC_T2Iと新しいSSVから誘導サブキー、およびデータ型ssr_digest_input4のXDR符号化された値を使用してHMACの出力です。フィールドsdi_seqres SET_SSVの範囲内であるCOMPOUND手順のシーケンス動作の結果と同じです。"
    },
    {
      "indent": 3,
      "text": "As noted in Section 18.35, the client and server can maintain multiple concurrent versions of the SSV. The client and server each MUST maintain an internal SSV version number, which is set to one the first time SET_SSV executes on the server and the client receives the first SET_SSV reply. Each subsequent SET_SSV increases the internal SSV version number by one. The value of this version number corresponds to the smpt_ssv_seq, smt_ssv_seq, sspt_ssv_seq, and ssct_ssv_seq fields of the SSV GSS mechanism tokens (see Section 2.10.9).",
      "ja": "セクション18.35で述べたように、クライアントとサーバは、SSVの複数の同時のバージョンを維持することができます。クライアントおよびサーバはそれぞれSET_SSVがサーバ上で実行され、クライアントが最初SET_SSV応答を受信する一つの第一の時間に設定されている内部SSVバージョン番号を維持しなければなりません。後続の各SET_SSVは一つによって内部SSVのバージョン番号を増加させます。このバージョン番号の値がsmpt_ssv_seq、smt_ssv_seq、sspt_ssv_seq、及びSSV GSS機構トークンのssct_ssv_seqフィールドに対応する（セクション2.10.9を参照）。"
    },
    {
      "indent": 0,
      "text": "18.47.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.47.4. 実装"
    },
    {
      "indent": 3,
      "text": "When the server receives ssa_digest, it MUST verify the digest by computing the digest the same way the client did and comparing it with ssa_digest. If the server gets a different result, this is an error, NFS4ERR_BAD_SESSION_DIGEST. This error might be the result of another SET_SSV from the same client ID changing the SSV. If so, the client recovers by sending a SET_SSV operation again with a recomputed digest based on the subkey of the new SSV. If the transport connection is dropped after the SET_SSV request is sent, but before the SET_SSV reply is received, then there are special considerations for recovery if the client has no more connections associated with sessions associated with the client ID of the SSV. See Section 18.34.4.",
      "ja": "サーバがssa_digest受信すると、それはクライアントがやったのと同じ方法を消化し、ssa_digestと比較計算することによってダイジェストを確かめなければなりません。サーバが別の結果を取得した場合、これは、NFS4ERR_BAD_SESSION_DIGESTエラーです。このエラーは、SSVを変え同じクライアントIDから別のSET_SSVの結果である可能性があります。その場合、クライアントは新しいSSVのサブキーに基づいて再計算したダイジェストで再びSET_SSV操作を送信することで回復します。 SET_SSVリクエストが送信された後、トランスポート接続が切断されている場合は、しかしSET_SSV応答が受信される前に、クライアントは、SSVのクライアントIDに関連付けられたセッションに関連付けられた複数の接続を持っていない場合は、回復のための特別な考慮事項があります。セクション18.34.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD NOT send an ssa_ssv that is equal to a previous ssa_ssv, nor equal to a previous or current SSV (including an ssa_ssv equal to zero since the SSV is initialized to zero when the client ID is created).",
      "ja": "クライアントは、前のssa_ssvに等しいssa_ssv、また以前または現在のSSVに等しい（クライアントIDが作成されたときSSVがゼロに初期化されているので、ゼロに等しいssa_ssv含む）を送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD send SET_SSV with RPCSEC_GSS privacy. Servers MUST support RPCSEC_GSS with privacy for any COMPOUND that has { SEQUENCE, SET_SSV }.",
      "ja": "クライアントは、RPCSEC_GSSプライバシーとSET_SSVを送るべきです。サーバーは{SEQUENCE、SET_SSV}を有する任意の化合物のためのプライバシーとRPCSEC_GSSをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "A client SHOULD NOT send SET_SSV with the SSV GSS mechanism's credential because the purpose of SET_SSV is to seed the SSV from non-SSV credentials. Instead, SET_SSV SHOULD be sent with the credential of a user that is accessing the client ID for the first time (Section 2.10.8.3). However, if the client does send SET_SSV with SSV credentials, the digest protecting the arguments uses the value of the SSV before ssa_ssv is XORed in, and the digest protecting the results uses the value of the SSV after the ssa_ssv is XORed in.",
      "ja": "SET_SSVの目的は、非SSV資格情報からSSVをシードすることであるため、クライアントは、SSV GSSメカニズムの資格をSET_SSVを送るべきではありません。その代わり、SET_SSVは初めて（セクション2.10.8.3）のクライアントIDにアクセスしているユーザーの資格情報を送ってください。クライアントは、SSVの資格情報を使用してSET_SSVを送信した場合しかし、ssa_ssvがでXOR演算される前に、引数を保護するダイジェストは、SSVの値を使用し、その結果を保護ダイジェストはssa_ssvがでXORされた後、SSVの値を使用しています。"
    },
    {
      "indent": 0,
      "text": "18.48. Operation 55: TEST_STATEID - Test Stateids for Validity",
      "section_title": true,
      "ja": "18.48. 操作55：TEST_STATEID  - 有効性のテストのstateids"
    },
    {
      "indent": 0,
      "text": "18.48.1. ARGUMENT",
      "section_title": true,
      "ja": "18.48.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct TEST_STATEID4args {\n        stateid4        ts_stateids<>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.48.2. RESULT",
      "section_title": true,
      "ja": "18.48.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct TEST_STATEID4resok {\n        nfsstat4        tsr_status_codes<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union TEST_STATEID4res switch (nfsstat4 tsr_status) {\n    case NFS4_OK:\n        TEST_STATEID4resok tsr_resok4;\n    default:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.48.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.48.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The TEST_STATEID operation is used to check the validity of a set of stateids. It can be used at any time, but the client should definitely use it when it receives an indication that one or more of its stateids have been invalidated due to lock revocation. This occurs when the SEQUENCE operation returns with one of the following sr_status_flags set:",
      "ja": "TEST_STATEID操作はのstateidsのセットの妥当性をチェックするために使用されます。これは、いつでも使用することができますが、それはそののstateidsの1つ以上が取消しをロックすることにより無効にされているという指示を受信したとき、クライアントは間違いなく、それを使用する必要があります。シーケンス動作が設定され、次のsr_status_flagsのいずれかで返したときにこれが発生します。"
    },
    {
      "indent": 3,
      "text": "o SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED",
      "ja": "O SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED"
    },
    {
      "indent": 3,
      "text": "o SEQ4_STATUS_EXPIRED_ADMIN_STATE_REVOKED",
      "ja": "O SEQ4_STATUS_EXPIRED_ADMIN_STATE_REVOKED"
    },
    {
      "indent": 3,
      "text": "o SEQ4_STATUS_EXPIRED_RECALLABLE_STATE_REVOKED",
      "ja": "O SEQ4_STATUS_EXPIRED_RECALLABLE_STATE_REVOKED"
    },
    {
      "indent": 3,
      "text": "The client can use TEST_STATEID one or more times to test the validity of its stateids. Each use of TEST_STATEID allows a large set of such stateids to be tested and avoids problems with earlier stateids in a COMPOUND request from interfering with the checking of subsequent stateids, as would happen if individual stateids were tested by a series of corresponding by operations in a COMPOUND request.",
      "ja": "クライアントは、そののstateidsの有効性をテストするためにTEST_STATEIDを1回以上使用することができます。 TEST_STATEIDの各使用は、のstateidsの大きなセットを試験することを可能にし、個々のstateidsがで操作することにより、対応する一連の試験を行った場合に起こるように、後続のstateidsのチェックと干渉複合要求における以前のstateidsの問題を回避します複合要求。"
    },
    {
      "indent": 3,
      "text": "For each stateid, the server returns the status code that would be returned if that stateid were to be used in normal operation. Returning such a status indication is not an error and does not cause COMPOUND processing to terminate. Checks for the validity of the stateid proceed as they would for normal operations with a number of exceptions:",
      "ja": "それぞれのstateidのために、サーバは、のstateidは、通常動作で使用された場合に返されるステータスコードを返します。このような状態表示を返すことはエラーではなく、合成処理が終了することはありません。彼らは例外の数が通常の操作と同じようなstateidの妥当性をチェックしに進んでください。"
    },
    {
      "indent": 3,
      "text": "o There is no check for the type of stateid object, as would be the case for normal use of a stateid.",
      "ja": "Oのstateidの通常の使用のための場合のように、のstateidオブジェクトのタイプのための検査は行われません。"
    },
    {
      "indent": 3,
      "text": "o There is no reference to the current filehandle.",
      "ja": "O現在のファイルハンドルへの参照はありません。"
    },
    {
      "indent": 3,
      "text": "o Special stateids are always considered invalid (they result in the error code NFS4ERR_BAD_STATEID).",
      "ja": "特別のstateidsは常に無効とみなされ、O（彼らは、エラーコードNFS4ERR_BAD_STATEIDになります）。"
    },
    {
      "indent": 3,
      "text": "All stateids are interpreted as being associated with the client for the current session. Any possible association with a previous instance of the client (as stale stateids) is not considered.",
      "ja": "すべてのstateidsは、現在のセッションのためのクライアントに関連するものとして解釈されます。 （失効のstateidsなど）クライアントの以前のインスタンスと任意の可能な関連は考慮されていません。"
    },
    {
      "indent": 3,
      "text": "The valid status values in the returned status_code array are NFS4ERR_OK, NFS4ERR_BAD_STATEID, NFS4ERR_OLD_STATEID, NFS4ERR_EXPIRED, NFS4ERR_ADMIN_REVOKED, and NFS4ERR_DELEG_REVOKED.",
      "ja": "返さSTATUS_CODE配列内の有効なステータス値はNFS4ERR_OK、NFS4ERR_BAD_STATEID、NFS4ERR_OLD_STATEID、NFS4ERR_EXPIRED、NFS4ERR_ADMIN_REVOKED、およびNFS4ERR_DELEG_REVOKEDです。"
    },
    {
      "indent": 0,
      "text": "18.48.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.48.4. 実装"
    },
    {
      "indent": 3,
      "text": "See Sections 8.2.2 and 8.2.4 for a discussion of stateid structure, lifetime, and validation.",
      "ja": "セクションにのstateid構造、寿命、および検証の議論のための8.2.2と8.2.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.49. Operation 56: WANT_DELEGATION - Request Delegation",
      "section_title": true,
      "ja": "18.49. 操作56：WANT_DELEGATION  - 委任をリクエスト"
    },
    {
      "indent": 0,
      "text": "18.49.1. ARGUMENT",
      "section_title": true,
      "ja": "18.49.1. 引数"
    },
    {
      "indent": 3,
      "text": "union deleg_claim4 switch (open_claim_type4 dc_claim) {\n/*\n * No special rights to object.  Ordinary delegation\n * request of the specified object.  Object identified\n * by filehandle.\n */\ncase CLAIM_FH: /* new to v4.1 */\n        /* CURRENT_FH: object being delegated */\n        void;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Right to file based on a delegation granted\n * to a previous boot instance of the client.\n * File is specified by filehandle.\n */\ncase CLAIM_DELEG_PREV_FH: /* new to v4.1 */\n        /* CURRENT_FH: object being delegated */\n        void;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Right to the file established by an open previous\n * to server reboot.  File identified by filehandle.\n * Used during server reclaim grace period.\n */\ncase CLAIM_PREVIOUS:\n        /* CURRENT_FH: object being reclaimed */\n        open_delegation_type4   dc_delegate_type;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct WANT_DELEGATION4args {\n        uint32_t        wda_want;\n        deleg_claim4    wda_claim;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.49.2. RESULT",
      "section_title": true,
      "ja": "18.49.2. 結果"
    },
    {
      "indent": 3,
      "text": "union WANT_DELEGATION4res switch (nfsstat4 wdr_status) {\ncase NFS4_OK:\n        open_delegation4 wdr_resok4;\ndefault:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.49.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.49.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "Where this description mandates the return of a specific error code for a specific condition, and where multiple conditions apply, the server MAY return any of the mandated error codes.",
      "ja": "この説明は、特定の条件のために特定のエラーコードのリターンを義務付け、そしてここで、複数の条件が適用される場合、サーバは、義務付けエラーコードのいずれかを返すことができます。"
    },
    {
      "indent": 3,
      "text": "This operation allows a client to:",
      "ja": "この操作は、クライアントにすることができます："
    },
    {
      "indent": 3,
      "text": "o Get a delegation on all types of files except directories.",
      "ja": "Oディレクトリを除くすべての種類のファイルに委任します。"
    },
    {
      "indent": 3,
      "text": "o Register a \"want\" for a delegation for the specified file object, and be notified via a callback when the delegation is available. The server MAY support notifications of availability via callbacks. If the server does not support registration of wants, it MUST NOT return an error to indicate that, and instead MUST return with ond_why set to WND4_CONTENTION or WND4_RESOURCE and ond_server_will_push_deleg or ond_server_will_signal_avail set to FALSE. When the server indicates that it will notify the client by means of a callback, it will either provide the delegation using a CB_PUSH_DELEG operation or cancel its promise by sending a CB_WANTS_CANCELLED operation.",
      "ja": "O指定されたファイルオブジェクトの委任のための「欲しい」登録し、委任が使用可能になったときにコールバックを介して通知します。サーバは、コールバックを経由して可用性の通知をサポートするかもしれません。サーバーが望んでいるの登録をサポートしていない場合、それはそれを示すために、エラーを返してはならない、と代わりにond_why WND4_CONTENTIONまたはWND4_RESOURCEに設定され、ond_server_will_push_delegまたはfalseに設定ond_server_will_signal_avail返さなければなりません。サーバーがコールバックによってクライアントに通知することを示している場合、それはどちらかCB_PUSH_DELEG操作を使用して委任を提供したり、CB_WANTS_CANCELLED操作を送信することによって、その約束をキャンセルします。"
    },
    {
      "indent": 3,
      "text": "o Cancel a want for a delegation.",
      "ja": "O委任希望をキャンセルします。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD NOT set OPEN4_SHARE_ACCESS_READ and SHOULD NOT set OPEN4_SHARE_ACCESS_WRITE in wda_want. If it does, the server MUST ignore them.",
      "ja": "クライアントはOPEN4_SHARE_ACCESS_READを設定しないでくださいとwda_wantにOPEN4_SHARE_ACCESS_WRITEを設定しないでください。それがない場合は、サーバーはそれらを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The meanings of the following flags in wda_want are the same as they are in OPEN, except as noted below.",
      "ja": "wda_wantで、次のフラグの意味は以下に記載される場合を除き、彼らはOPENにしているものと同じです。"
    },
    {
      "indent": 3,
      "text": "o OPEN4_SHARE_ACCESS_WANT_READ_DELEG",
      "ja": "O OPEN4_SHARE_ACCESS_WANT_READ_DELEG"
    },
    {
      "indent": 3,
      "text": "o OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG",
      "ja": "O OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG"
    },
    {
      "indent": 3,
      "text": "o OPEN4_SHARE_ACCESS_WANT_ANY_DELEG o OPEN4_SHARE_ACCESS_WANT_NO_DELEG. Unlike the OPEN operation, this flag SHOULD NOT be set by the client in the arguments to WANT_DELEGATION, and MUST be ignored by the server.",
      "ja": "O OPEN4_SHARE_ACCESS_WANT_ANY_DELEG O OPEN4_SHARE_ACCESS_WANT_NO_DELEG。 OPEN操作とは異なり、このフラグはWANT_DELEGATIONへの引数には、クライアントで設定しないでください、そして、サーバによって無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o OPEN4_SHARE_ACCESS_WANT_CANCEL",
      "ja": "O OPEN4_SHARE_ACCESS_WANT_CANCEL"
    },
    {
      "indent": 3,
      "text": "o OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL",
      "ja": "O OPEN4_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL"
    },
    {
      "indent": 3,
      "text": "o OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED",
      "ja": "O OPEN4_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED"
    },
    {
      "indent": 3,
      "text": "The handling of the above flags in WANT_DELEGATION is the same as in OPEN. Information about the delegation and/or the promises the server is making regarding future callbacks are the same as those described in the open_delegation4 structure.",
      "ja": "WANT_DELEGATIONで上記のフラグの取り扱いは、OPENと同じです。代表団および/または将来のコールバックに関するサーバーを作っているの約束に関する情報はopen_delegation4構造で説明したものと同じです。"
    },
    {
      "indent": 3,
      "text": "The successful results of WANT_DELEGATION are of data type open_delegation4, which is the same data type as the \"delegation\" field in the results of the OPEN operation (see Section 18.16.3). The server constructs wdr_resok4 the same way it constructs OPEN's \"delegation\" with one difference: WANT_DELEGATION MUST NOT return a delegation type of OPEN_DELEGATE_NONE.",
      "ja": "WANT_DELEGATIONの成果は、OPEN操作の結果で「委任」フィールド（セクション18.16.3を参照）と同じデータ型であるデータ・タイプopen_delegation4、です。サーバー構築物は、それが1つの違いがOPENの「委任」を構築するのと同じ方法をwdr_resok4：WANT_DELEGATIONはOPEN_DELEGATE_NONEの委譲タイプを返してはなりません。"
    },
    {
      "indent": 3,
      "text": "If ((wda_want & OPEN4_SHARE_ACCESS_WANT_DELEG_MASK) & ~OPEN4_SHARE_ACCESS_WANT_NO_DELEG) is zero, then the client is indicating no explicit desire or non-desire for a delegation and the server MUST return NFS4ERR_INVAL.",
      "ja": "（（wda_want＆OPEN4_SHARE_ACCESS_WANT_DELEG_MASK）＆〜OPEN4_SHARE_ACCESS_WANT_NO_DELEG）がゼロである場合、クライアントは委譲のための明示的な欲求や非願望を示していないと、サーバはNFS4ERR_INVALを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client uses the OPEN4_SHARE_ACCESS_WANT_CANCEL flag in the WANT_DELEGATION operation to cancel a previously requested want for a delegation. Note that if the server is in the process of sending the delegation (via CB_PUSH_DELEG) at the time the client sends a cancellation of the want, the delegation might still be pushed to the client.",
      "ja": "クライアントは、委譲のために以前に要求希望をキャンセルするWANT_DELEGATION操作でOPEN4_SHARE_ACCESS_WANT_CANCELフラグを使用しています。サーバはクライアント希望の取り消しを送る時（CB_PUSH_DELEG経由）委任を送信するプロセスである場合、委任がまだクライアントにプッシュされるかもしれないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "If WANT_DELEGATION fails to return a delegation, and the server returns NFS4_OK, the server MUST set the delegation type to OPEN4_DELEGATE_NONE_EXT, and set od_whynone, as described in Section 18.16. Write delegations are not available for file types that are not writable. This includes file objects of types NF4BLK, NF4CHR, NF4LNK, NF4SOCK, and NF4FIFO. If the client requests OPEN4_SHARE_ACCESS_WANT_WRITE_DELEG without OPEN4_SHARE_ACCESS_WANT_READ_DELEG on an object with one of the aforementioned file types, the server must set wdr_resok4.od_whynone.ond_why to WND4_WRITE_DELEG_NOT_SUPP_FTYPE.",
      "ja": "WANT_DELEGATIONが委任を返すことに失敗し、サーバーがNFS4_OKを返した場合、サーバーはOPEN4_DELEGATE_NONE_EXTへの委任の種類を設定しなければなりません、そして、セクション18.16で説明したように、od_whynoneを設定します。書き込みの代表団が書き込み可能でないファイル・タイプでは使用できません。これはタイプNF4BLK、NF4CHR、NF4LNK、NF4SOCK、およびNF4FIFOのファイルオブジェクトが含まれています。クライアントは、前述のファイルタイプのいずれかを対象にOPEN4_SHARE_ACCESS_WANT_READ_DELEGなしOPEN4_SHARE_ACCESS_WANT_WRITE_DELEGを要求した場合、サーバーはWND4_WRITE_DELEG_NOT_SUPP_FTYPEにwdr_resok4.od_whynone.ond_whyを設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.49.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.49.4. 実装"
    },
    {
      "indent": 3,
      "text": "A request for a conflicting delegation is not normally intended to trigger the recall of the existing delegation. Servers may choose to treat some clients as having higher priority such that their wants will trigger recall of an existing delegation, although that is expected to be an unusual situation.",
      "ja": "競合委任のための要求は、通常、既存の委任のリコールをトリガーするものではありません。それは異常事態であることが予想されるものの、サーバーは、自分の欲求は、既存の委任のリコールをトリガーするように高い優先順位を持つものとして、いくつかのクライアントを処理するために選択することができます。"
    },
    {
      "indent": 3,
      "text": "Servers will generally recall delegations assigned by WANT_DELEGATION on the same basis as those assigned by OPEN. CB_RECALL will generally be done only when other clients perform operations inconsistent with the delegation. The normal response to aging of delegations is to use CB_RECALL_ANY, in order to give the client the opportunity to keep the delegations most useful from its point of view.",
      "ja": "サーバは、一般的にOPENによって割り当てられたものと同じ基準でWANT_DELEGATIONによって割り当てられた代表団を思い出します。他のクライアントが委任と矛盾する操作を実行する場合にのみCB_RECALLは一般的に行われます。代表団の老化に対する正常な応答がクライアントにビューのその点から最も有用な代表団を維持する機会を与えるために、CB_RECALL_ANYを使用することです。"
    },
    {
      "indent": 0,
      "text": "18.50. Operation 57: DESTROY_CLIENTID - Destroy a Client ID",
      "section_title": true,
      "ja": "18.50. 操作57：DESTROY_CLIENTID  - クライアントIDを破壊します"
    },
    {
      "indent": 0,
      "text": "18.50.1. ARGUMENT",
      "section_title": true,
      "ja": "18.50.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct DESTROY_CLIENTID4args {\n        clientid4       dca_clientid;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.50.2. RESULT",
      "section_title": true,
      "ja": "18.50.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct DESTROY_CLIENTID4res {\n        nfsstat4        dcr_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.50.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.50.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The DESTROY_CLIENTID operation destroys the client ID. If there are sessions (both idle and non-idle), opens, locks, delegations, layouts, and/or wants (Section 18.49) associated with the unexpired lease of the client ID, the server MUST return NFS4ERR_CLIENTID_BUSY. DESTROY_CLIENTID MAY be preceded with a SEQUENCE operation as long as the client ID derived from the session ID of SEQUENCE is not the same as the client ID to be destroyed. If the client IDs are the same, then the server MUST return NFS4ERR_CLIENTID_BUSY.",
      "ja": "DESTROY_CLIENTID操作は、クライアントのIDを破壊します。 （アイドルと非アイドルの両方）のセッションがある場合は、ロック、代表団、レイアウトを開き、および/または望んでいる（セクション18.49）クライアントIDの期限が切れていないリースに関連した、サーバーはNFS4ERR_CLIENTID_BUSYを返さなければなりません。 DESTROY_CLIENTIDは限りSEQUENCEのセッションIDから派生したクライアントIDが破壊されるクライアントIDと同じではないようにシーケンス動作が先行されるかもしれません。クライアントIDが同じである場合、サーバーはNFS4ERR_CLIENTID_BUSYを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If DESTROY_CLIENTID is not prefixed by SEQUENCE, it MUST be the only operation in the COMPOUND request (otherwise, the server MUST return NFS4ERR_NOT_ONLY_OP). If the operation is sent without a SEQUENCE preceding it, a client that retransmits the request may receive an error in response, because the original request might have been successfully executed.",
      "ja": "DESTROY_CLIENTIDがSEQUENCEが付けされていない場合は、複合要求（そうでない場合、サーバはNFS4ERR_NOT_ONLY_OPを返さなければならない）での動作のみでなければなりません。操作は、それに先立つSEQUENCEせずに送信された場合は、元の要求が正常に実行されている可能性があるため、要求を再送信するクライアントは、応答でエラーが発生することがあります。"
    },
    {
      "indent": 0,
      "text": "18.50.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.50.4. 実装"
    },
    {
      "indent": 3,
      "text": "DESTROY_CLIENTID allows a server to immediately reclaim the resources consumed by an unused client ID, and also to forget that it ever generated the client ID. By forgetting that it ever generated the client ID, the server can safely reuse the client ID on a future EXCHANGE_ID operation.",
      "ja": "DESTROY_CLIENTIDは、サーバーがすぐに使用されていないクライアントIDが消費するリソースを回収するために、また、それが今までのクライアントIDを生成することを忘れることができます。それが今までのクライアントIDを生成することを忘れすることにより、サーバは安全に将来EXCHANGE_ID操作上のクライアントIDを再利用することができます。"
    },
    {
      "indent": 0,
      "text": "18.51. Operation 58: RECLAIM_COMPLETE - Indicates Reclaims Finished",
      "section_title": true,
      "ja": "18.51. 操作58：RECLAIM_COMPLETEは - 再要求が完了しましたことを示し"
    },
    {
      "indent": 0,
      "text": "18.51.1. ARGUMENT",
      "section_title": true,
      "ja": "18.51.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct RECLAIM_COMPLETE4args {\n        /*\n         * If rca_one_fs TRUE,\n         *\n         *    CURRENT_FH: object in\n         *    file system reclaim is\n         *    complete for.\n         */\n        bool            rca_one_fs;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.51.2. RESULTS",
      "section_title": true,
      "ja": "18.51.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct RECLAIM_COMPLETE4res {\n        nfsstat4        rcr_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.51.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.51.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "A RECLAIM_COMPLETE operation is used to indicate that the client has reclaimed all of the locking state that it will recover, when it is recovering state due to either a server restart or the transfer of a file system to another server. There are two types of RECLAIM_COMPLETE operations:",
      "ja": "RECLAIM_COMPLETE操作は、それが原因のサーバーの再起動、または別のサーバーへのファイルシステムの転送いずれかの状態に回復しているとき、クライアントは、それが回復することをロック状態のすべてを再利用していることを示すために使用されます。 RECLAIM_COMPLETE操作の2種類があります。"
    },
    {
      "indent": 3,
      "text": "o When rca_one_fs is FALSE, a global RECLAIM_COMPLETE is being done. This indicates that recovery of all locks that the client held on the previous server instance have been completed.",
      "ja": "rca_one_fsがFALSEである場合には、O、グローバルRECLAIM_COMPLETEが行われています。これにより、クライアントは、以前のサーバインスタンスに開催されたすべてのロックの回復が完了していることを示しています。"
    },
    {
      "indent": 3,
      "text": "o When rca_one_fs is TRUE, a file system-specific RECLAIM_COMPLETE is being done. This indicates that recovery of locks for a single fs (the one designated by the current filehandle) due to a file system transition have been completed. Presence of a current filehandle is only required when rca_one_fs is set to TRUE.",
      "ja": "rca_one_fsがTRUEである場合には、O、ファイルシステム固有のRECLAIM_COMPLETEが行われています。これは、ファイルシステムの移行に単一のFSのためのロックの回復（現在のファイルハンドルで指定された1）が完了したことを示しています。 rca_one_fsがTRUEに設定されている場合、現在のファイルハンドルの存在にのみ必要です。"
    },
    {
      "indent": 3,
      "text": "Once a RECLAIM_COMPLETE is done, there can be no further reclaim operations for locks whose scope is defined as having completed recovery. Once the client sends RECLAIM_COMPLETE, the server will not allow the client to do subsequent reclaims of locking state for that scope and, if these are attempted, will return NFS4ERR_NO_GRACE.",
      "ja": "RECLAIM_COMPLETEが行われると、その範囲の回復を完了したとして定義されているロックの操作を再利用もはや存在しないことができます。クライアントがRECLAIM_COMPLETEを送信すると、これらが試行されている場合、サーバーは、クライアントがそのスコープのロック状態のその後の再要求を行うことができなくなり、NFS4ERR_NO_GRACEを返します。"
    },
    {
      "indent": 3,
      "text": "Whenever a client establishes a new client ID and before it does the first non-reclaim operation that obtains a lock, it MUST send a RECLAIM_COMPLETE with rca_one_fs set to FALSE, even if there are no locks to reclaim. If non-reclaim locking operations are done before the RECLAIM_COMPLETE, an NFS4ERR_GRACE error will be returned.",
      "ja": "たびクライアントは新しいクライアントIDを確立し、それがロックを取得し、最初の非再生操作を行う前に、それは再利用するロックがない場合でも、FALSEに設定rca_one_fsでRECLAIM_COMPLETEを送らなければなりません。非再利用ロック操作がRECLAIM_COMPLETE前に行われた場合は、NFS4ERR_GRACEエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Similarly, when the client accesses a file system on a new server, before it sends the first non-reclaim operation that obtains a lock on this new server, it MUST send a RECLAIM_COMPLETE with rca_one_fs set to TRUE and current filehandle within that file system, even if there are no locks to reclaim. If non-reclaim locking operations are done on that file system before the RECLAIM_COMPLETE, an NFS4ERR_GRACE error will be returned.",
      "ja": "クライアントは、それがこの新しいサーバー上のロックを取得し、最初の非再生操作を送信する前に、それはそのファイルシステム内でTRUEと現在のファイルハンドルに設定rca_one_fsでRECLAIM_COMPLETEを送らなければなりません、新しいサーバー上のファイルシステムにアクセス同様に、再利用する一切ロックが存在しない場合でも。非取り戻すロック操作がRECLAIM_COMPLETE前に、そのファイルシステム上で行われている場合、NFS4ERR_GRACEエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Any locks not reclaimed at the point at which RECLAIM_COMPLETE is done become non-reclaimable. The client MUST NOT attempt to reclaim them, either during the current server instance or in any subsequent server instance, or on another server to which responsibility for that file system is transferred. If the client were to do so, it would be violating the protocol by representing itself as owning locks that it does not own, and so has no right to reclaim. See Section 8.4.3 for a discussion of edge conditions related to lock reclaim.",
      "ja": "すべてのロックはRECLAIM_COMPLETEは、非再生可能となって行われた時点で回収されません。クライアントは、現在のサーバーインスタンス間、またはそれ以降のサーバーインスタンスで、またはそのファイルシステムの責任が転送されている別のサーバー上のいずれか、それらを取り戻すのを試みてはいけません。クライアントがそうした場合、それが所有していないロックを所有しているとして自分自身を表現することにより、プロトコルに違反し、その再利用する権利を持っていないであろう。再利用をロックするために関連するエッジ条件の議論については、セクション8.4.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "By sending a RECLAIM_COMPLETE, the client indicates readiness to proceed to do normal non-reclaim locking operations. The client should be aware that such operations may temporarily result in NFS4ERR_GRACE errors until the server is ready to terminate its grace period.",
      "ja": "RECLAIM_COMPLETEを送信することにより、クライアントは、通常の非再利用ロック操作を行うことを続行する準備状況を示します。クライアントは、サーバがその猶予期間を終了する準備ができるまで、このような操作は一時的にNFS4ERR_GRACEのエラーが発生する可能性があることに注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.51.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.51.4. 実装"
    },
    {
      "indent": 3,
      "text": "Servers will typically use the information as to when reclaim activity is complete to reduce the length of the grace period. When the server maintains in persistent storage a list of clients that might have had locks, it is in a position to use the fact that all such clients have done a RECLAIM_COMPLETE to terminate the grace period and begin normal operations (i.e., grant requests for new locks) sooner than it might otherwise.",
      "ja": "サーバーは通常、再利用活動は猶予期間の長さを短くすることが完了したときになどの情報を使用します。サーバが永続ストレージにロックを持っていたかもしれないクライアントのリストを維持した場合、すべてのこのようなクライアントは、猶予期間を終了し、新しいのための通常の操作（すなわち、補助金の要求を開始するRECLAIM_COMPLETEを行っていること、それは事実を使用する立場にありますそれはそうかもしれないより早くロック）。"
    },
    {
      "indent": 3,
      "text": "Latency can be minimized by doing a RECLAIM_COMPLETE as part of the COMPOUND request in which the last lock-reclaiming operation is done. When there are no reclaims to be done, RECLAIM_COMPLETE should be done immediately in order to allow the grace period to end as soon as possible.",
      "ja": "待ち時間は最後のロック・再利用の操作が行われた化合物の要求の一部としてRECLAIM_COMPLETEを行うことによって最小限に抑えることができます。やるべき何の再要求が存在しない場合は、RECLAIM_COMPLETEは猶予期間ができるだけ早く終了することを可能にするために、すぐに行うべきです。"
    },
    {
      "indent": 3,
      "text": "RECLAIM_COMPLETE should only be done once for each server instance or occasion of the transition of a file system. If it is done a second time, the error NFS4ERR_COMPLETE_ALREADY will result. Note that because of the session feature's retry protection, retries of COMPOUND requests containing RECLAIM_COMPLETE operation will not result in this error.",
      "ja": "RECLAIM_COMPLETEは、専用のファイルシステムの移行の各サーバインスタンスや機会のために一度行われるべきです。それが二度目に実行された場合は、エラーNFS4ERR_COMPLETE_ALREADYが発生します。なぜならセッション機能の再試行保護のため、RECLAIM_COMPLETE操作を含む化合物要求の再試行は、このエラーが発生しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When a RECLAIM_COMPLETE is sent, the client effectively acknowledges any locks not yet reclaimed as lost. This allows the server to re-enable the client to recover locks if the occurrence of edge conditions, as described in Section 8.4.3, had caused the server to disable the client from recovering locks.",
      "ja": "RECLAIM_COMPLETEが送信されると、クライアントは、効果的に失われたとして、まだ埋め立てていないすべてのロックを認めます。これは、8.4.3項で説明したようにエッジ状態の発生は、回復のロックからクライアントを無効にするには、サーバーを引き起こした場合、サーバーがロックを回復するために、クライアントを再度有効にすることができます。"
    },
    {
      "indent": 0,
      "text": "18.52. Operation 10044: ILLEGAL - Illegal Operation",
      "section_title": true,
      "ja": "18.52. オペレーション10044：ILLEGAL  - 無効な操作"
    },
    {
      "indent": 0,
      "text": "18.52.1. ARGUMENTS",
      "section_title": true,
      "ja": "18.52.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "18.52.2. RESULTS",
      "section_title": true,
      "ja": "18.52.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct ILLEGAL4res {\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.52.3. DESCRIPTION",
      "section_title": true,
      "ja": "18.52.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation is a placeholder for encoding a result to handle the case of the client sending an operation code within COMPOUND that is not supported. See the COMPOUND procedure description for more details.",
      "ja": "この操作はサポートされていない化合物内のオペレーションコードを送信したクライアントの場合を処理するために結果を符号化するためのプレースホルダです。詳細はCOMPOUND手順の説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "The status field of ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.",
      "ja": "ILLEGAL4resのステータスフィールドはNFS4ERR_OP_ILLEGALに設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.52.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "18.52.4. 実装"
    },
    {
      "indent": 3,
      "text": "A client will probably not send an operation with code OP_ILLEGAL but if it does, the response will be ILLEGAL4res just as it would be with any other invalid operation code. Note that if the server gets an illegal operation code that is not OP_ILLEGAL, and if the server checks for legal operation codes during the XDR decode phase, then the ILLEGAL4res would not be returned.",
      "ja": "クライアントは、おそらくコードOP_ILLEGALで操作を送信しませんが、それがない場合、応答は、それが他の不正なオペレーションコードを持つことと同じようにILLEGAL4resになります。注意サーバがOP_ILLEGALない不正な操作コードを取得した場合、およびXDRデコード段階の間法的操作コードのサーバをチェックし、次にILLEGAL4resが返されない場合に。"
    },
    {
      "indent": 0,
      "text": "19. NFSv4.1 Callback Procedures",
      "section_title": true,
      "ja": "19. NFSv4.1コールバック手続き"
    },
    {
      "indent": 3,
      "text": "The procedures used for callbacks are defined in the following sections. In the interest of clarity, the terms \"client\" and \"server\" refer to NFS clients and servers, despite the fact that for an individual callback RPC, the sense of these terms would be precisely the opposite.",
      "ja": "コールバックのために使用される手順は、次のセクションで定義されています。明瞭にするために、用語「クライアント」と「サーバー」は、個々のコールバックRPCのために、これらの用語の意味は正反対になるという事実にもかかわらず、NFSクライアントとサーバを参照してください。"
    },
    {
      "indent": 3,
      "text": "Both procedures, CB_NULL and CB_COMPOUND, MUST be implemented.",
      "ja": "両方の手順、CB_NULLとCB_COMPOUNDは、実装しなければなりません。"
    },
    {
      "indent": 0,
      "text": "19.1. Procedure 0: CB_NULL - No Operation",
      "section_title": true,
      "ja": "19.1. 手順0：CB_NULL  - 動作なし"
    },
    {
      "indent": 0,
      "text": "19.1.1. ARGUMENTS",
      "section_title": true,
      "ja": "19.1.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "19.1.2. RESULTS",
      "section_title": true,
      "ja": "19.1.2. 結果"
    },
    {
      "indent": 3,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "19.1.3. DESCRIPTION",
      "section_title": true,
      "ja": "19.1.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "CB_NULL is the standard ONC RPC NULL procedure, with the standard void argument and void response. Even though there is no direct functionality associated with this procedure, the server will use CB_NULL to confirm the existence of a path for RPCs from the server to client.",
      "ja": "CB_NULLは、標準のボイド引数ボイド応答して、標準ONC RPCのNULL手続きです。この手順に関連した直接的な機能はありませんにもかかわらず、サーバーは、サーバーからクライアントへのRPCのパスの存在を確認するためにCB_NULLを使用します。"
    },
    {
      "indent": 0,
      "text": "19.1.4. ERRORS",
      "section_title": true,
      "ja": "19.1.4. エラー"
    },
    {
      "indent": 3,
      "text": "None.",
      "ja": "無し。"
    },
    {
      "indent": 0,
      "text": "19.2. Procedure 1: CB_COMPOUND - Compound Operations",
      "section_title": true,
      "ja": "19.2. 手順1：CB_COMPOUND  - 化合物の操作"
    },
    {
      "indent": 0,
      "text": "19.2.1. ARGUMENTS",
      "section_title": true,
      "ja": "19.2.1.  ARGUMENTS"
    },
    {
      "indent": 3,
      "text": "enum nfs_cb_opnum4 {\n        OP_CB_GETATTR           = 3,\n        OP_CB_RECALL            = 4,\n/* Callback operations new to NFSv4.1 */\n        OP_CB_LAYOUTRECALL      = 5,\n        OP_CB_NOTIFY            = 6,\n        OP_CB_PUSH_DELEG        = 7,\n        OP_CB_RECALL_ANY        = 8,\n        OP_CB_RECALLABLE_OBJ_AVAIL = 9,\n        OP_CB_RECALL_SLOT       = 10,\n        OP_CB_SEQUENCE          = 11,\n        OP_CB_WANTS_CANCELLED   = 12,\n        OP_CB_NOTIFY_LOCK       = 13,\n        OP_CB_NOTIFY_DEVICEID   = 14,",
      "raw": true
    },
    {
      "indent": 3,
      "text": " OP_CB_ILLEGAL = 10044 };",
      "ja": "OP_CB_ILLEGAL = 10044}。"
    },
    {
      "indent": 3,
      "text": "union nfs_cb_argop4 switch (unsigned argop) {\n case OP_CB_GETATTR:\n      CB_GETATTR4args           opcbgetattr;\n case OP_CB_RECALL:\n      CB_RECALL4args            opcbrecall;\n case OP_CB_LAYOUTRECALL:\n      CB_LAYOUTRECALL4args      opcblayoutrecall;\n case OP_CB_NOTIFY:\n      CB_NOTIFY4args            opcbnotify;\n case OP_CB_PUSH_DELEG:\n      CB_PUSH_DELEG4args        opcbpush_deleg;\n case OP_CB_RECALL_ANY:\n      CB_RECALL_ANY4args        opcbrecall_any;\n case OP_CB_RECALLABLE_OBJ_AVAIL:\n      CB_RECALLABLE_OBJ_AVAIL4args opcbrecallable_obj_avail;\n case OP_CB_RECALL_SLOT:\n      CB_RECALL_SLOT4args       opcbrecall_slot;\n case OP_CB_SEQUENCE:\n      CB_SEQUENCE4args          opcbsequence;\n case OP_CB_WANTS_CANCELLED:\n      CB_WANTS_CANCELLED4args   opcbwants_cancelled;\n case OP_CB_NOTIFY_LOCK:\n      CB_NOTIFY_LOCK4args       opcbnotify_lock;\n case OP_CB_NOTIFY_DEVICEID:\n      CB_NOTIFY_DEVICEID4args   opcbnotify_deviceid;\n case OP_CB_ILLEGAL:            void;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct CB_COMPOUND4args {\n        utf8str_cs      tag;\n        uint32_t        minorversion;\n        uint32_t        callback_ident;\n        nfs_cb_argop4   argarray<>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "19.2.2. RESULTS",
      "section_title": true,
      "ja": "19.2.2. 結果"
    },
    {
      "indent": 3,
      "text": "union nfs_cb_resop4 switch (unsigned resop) {\n case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;\n case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* new NFSv4.1 operations */\ncase OP_CB_LAYOUTRECALL:\n                       CB_LAYOUTRECALL4res\n                                       opcblayoutrecall;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "case OP_CB_NOTIFY: CB_NOTIFY4res opcbnotify;",
      "ja": "ケースOP_CB_NOTIFY：CB_NOTIFY4resはopcbnotify。"
    },
    {
      "indent": 4,
      "text": "case OP_CB_PUSH_DELEG: CB_PUSH_DELEG4res opcbpush_deleg;",
      "ja": "ケースOP_CB_PUSH_DELEG：CB_PUSH_DELEG4res opcbpush_deleg。"
    },
    {
      "indent": 4,
      "text": "case OP_CB_RECALL_ANY: CB_RECALL_ANY4res opcbrecall_any;",
      "ja": "ケースOP_CB_RECALL_ANY：CB_RECALL_ANY4resのopcbrecall_any。"
    },
    {
      "indent": 4,
      "text": "case OP_CB_RECALLABLE_OBJ_AVAIL: CB_RECALLABLE_OBJ_AVAIL4res opcbrecallable_obj_avail;",
      "ja": "ケースOP_CB_RECALLABLE_OBJ_AVAIL：CB_RECALLABLE_OBJ_AVAIL4resのopcbrecallable_obj_avail。"
    },
    {
      "indent": 4,
      "text": "case OP_CB_RECALL_SLOT: CB_RECALL_SLOT4res opcbrecall_slot;",
      "ja": "ケースOP_CB_RECALL_SLOT：CB_RECALL_SLOT4resのopcbrecall_slot。"
    },
    {
      "indent": 4,
      "text": "case OP_CB_SEQUENCE: CB_SEQUENCE4res opcbsequence;",
      "ja": "ケースOP_CB_SEQUENCE：CB_SEQUENCE4resのopcbsequence。"
    },
    {
      "indent": 4,
      "text": "case OP_CB_WANTS_CANCELLED: CB_WANTS_CANCELLED4res opcbwants_cancelled;",
      "ja": "ケースOP_CB_WANTS_CANCELLED：CB_WANTS_CANCELLED4resはopcbwants_cancelled。"
    },
    {
      "indent": 4,
      "text": "case OP_CB_NOTIFY_LOCK: CB_NOTIFY_LOCK4res opcbnotify_lock;",
      "ja": "ケースOP_CB_NOTIFY_LOCK：CB_NOTIFY_LOCK4resのopcbnotify_lock。"
    },
    {
      "indent": 4,
      "text": "case OP_CB_NOTIFY_DEVICEID: CB_NOTIFY_DEVICEID4res opcbnotify_deviceid;",
      "ja": "ケースOP_CB_NOTIFY_DEVICEID：CB_NOTIFY_DEVICEID4resはopcbnotify_deviceid。"
    },
    {
      "indent": 3,
      "text": " /* Not new operation */\n case OP_CB_ILLEGAL:    CB_ILLEGAL4res  opcbillegal;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct CB_COMPOUND4res {\n        nfsstat4 status;\n        utf8str_cs      tag;\n        nfs_cb_resop4   resarray<>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "19.2.3. DESCRIPTION",
      "section_title": true,
      "ja": "19.2.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The CB_COMPOUND procedure is used to combine one or more of the callback procedures into a single RPC request. The main callback RPC program has two main procedures: CB_NULL and CB_COMPOUND. All other operations use the CB_COMPOUND procedure as a wrapper.",
      "ja": "CB_COMPOUND手順は、単一のRPC要求にコールバック手続きの一つ以上を組み合わせるために使用されます。 CB_NULLとCB_COMPOUND：メインのコールバックRPCプログラムは、主に2つの手順があります。他のすべての操作は、ラッパーとしてCB_COMPOUNDプロシージャを使用します。"
    },
    {
      "indent": 3,
      "text": "During the processing of the CB_COMPOUND procedure, the client may find that it does not have the available resources to execute any or all of the operations within the CB_COMPOUND sequence. Refer to Section 2.10.6.4 for details.",
      "ja": "CB_COMPOUND手順の処理中に、クライアントは、それがCB_COMPOUND配列内の操作のいずれか、またはすべてを実行するために使用可能なリソースを持っていないことがあります。詳細はセクション2.10.6.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "The minorversion field of the arguments MUST be the same as the minorversion of the COMPOUND procedure used to create the client ID and session. For NFSv4.1, minorversion MUST be set to 1.",
      "ja": "引数のMINORVERSIONフィールドは、クライアントIDとセッションを作成するために使用される化合物の手順のMINORVERSIONと同じでなければなりません。 NFSv4.1について、MINORVERSIONは1に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Contained within the CB_COMPOUND results is a \"status\" field. This status MUST be equal to the status of the last operation that was executed within the CB_COMPOUND procedure. Therefore, if an operation incurred an error, then the \"status\" value will be the same error value as is being returned for the operation that failed.",
      "ja": "CB_COMPOUND結果に含まれる「状態」フィールドです。このステータスはCB_COMPOUND手順内で実行された最後の操作の状態に等しくなければなりません。操作がエラーを発生した場合従って、次に「状態」の値は、失敗した操作のために返される同じエラー値となります。"
    },
    {
      "indent": 3,
      "text": "The \"tag\" field is handled the same way as that of the COMPOUND procedure (see Section 16.2.3).",
      "ja": "「タグ」フィールドはCOMPOUND手順（セクション16.2.3を参照）の場合と同じように扱われます。"
    },
    {
      "indent": 3,
      "text": "Illegal operation codes are handled in the same way as they are handled for the COMPOUND procedure.",
      "ja": "不正操作コードは、それらは、化合物処置のために処理されるのと同じ方法で処理されます。"
    },
    {
      "indent": 0,
      "text": "19.2.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "19.2.4. 実装"
    },
    {
      "indent": 3,
      "text": "The CB_COMPOUND procedure is used to combine individual operations into a single RPC request. The client interprets each of the operations in turn. If an operation is executed by the client and the status of that operation is NFS4_OK, then the next operation in the CB_COMPOUND procedure is executed. The client continues this process until there are no more operations to be executed or one of the operations has a status value other than NFS4_OK.",
      "ja": "CB_COMPOUND手順は、単一のRPC要求に個々の操作を組み合わせるために使用されます。クライアントは、順番にそれぞれの操作を解釈します。操作は、クライアントで実行されると、その操作のステータスがNFS4_OKでされている場合は、CB_COMPOUNDの手順の次の動作が実行されます。が実行されるべきそれ以上の操作がされないかのいずれかの操作がNFS4_OK以外の状態値を有するまで、クライアントは、このプロセスを継続します。"
    },
    {
      "indent": 0,
      "text": "19.2.5. ERRORS",
      "section_title": true,
      "ja": "19.2.5. エラー"
    },
    {
      "indent": 3,
      "text": "CB_COMPOUND will of course return every error that each operation on the backchannel can return (see Table 7). However, if CB_COMPOUND returns zero operations, obviously the error returned by COMPOUND has nothing to do with an error returned by an operation. The list of errors CB_COMPOUND will return if it processes zero operations includes:",
      "ja": "CB_COMPOUNDはもちろん、バックチャネル上の各操作は、（表7を参照）を返すことができ、すべてのエラーを返します。 CB_COMPOUNDがゼロの操作を返す場合は、明らかにCOMPOUNDによって返されるエラーは、操作によって返されるエラーとは何の関係もありません。 ：それは含まゼロの操作を処理する場合CB_COMPOUNDが返すエラーの一覧"
    },
    {
      "indent": 25,
      "text": "CB_COMPOUND error returns",
      "ja": "CB_COMPOUNDエラーを返します"
    },
    {
      "indent": 3,
      "text": "+------------------------------+------------------------------------+\n| Error                        | Notes                              |\n+------------------------------+------------------------------------+\n| NFS4ERR_BADCHAR              | The tag argument has a character   |\n|                              | the replier does not support.      |\n| NFS4ERR_BADXDR               |                                    |\n| NFS4ERR_DELAY                |                                    |\n| NFS4ERR_INVAL                | The tag argument is not in UTF-8   |\n|                              | encoding.                          |\n| NFS4ERR_MINOR_VERS_MISMATCH  |                                    |\n| NFS4ERR_SERVERFAULT          |                                    |\n| NFS4ERR_TOO_MANY_OPS         |                                    |\n| NFS4ERR_REP_TOO_BIG          |                                    |\n| NFS4ERR_REP_TOO_BIG_TO_CACHE |                                    |\n| NFS4ERR_REQ_TOO_BIG          |                                    |\n+------------------------------+------------------------------------+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Table 15",
      "ja": "表15"
    },
    {
      "indent": 0,
      "text": "20. NFSv4.1 Callback Operations",
      "section_title": true,
      "ja": "20. NFSv4.1コールバックオペレーション"
    },
    {
      "indent": 0,
      "text": "20.1. Operation 3: CB_GETATTR - Get Attributes",
      "section_title": true,
      "ja": "20.1. 動作3：CB_GETATTR  - 属性を取得します。"
    },
    {
      "indent": 0,
      "text": "20.1.1. ARGUMENT",
      "section_title": true,
      "ja": "20.1.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct CB_GETATTR4args {\n        nfs_fh4 fh;\n        bitmap4 attr_request;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.1.2. RESULT",
      "section_title": true,
      "ja": "20.1.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_GETATTR4resok {\n        fattr4  obj_attributes;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union CB_GETATTR4res switch (nfsstat4 status) {\n case NFS4_OK:\n         CB_GETATTR4resok       resok4;\n default:\n         void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.1.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.1.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The CB_GETATTR operation is used by the server to obtain the current modified state of a file that has been OPEN_DELEGATE_WRITE delegated. The size and change attributes are the only ones guaranteed to be serviced by the client. See Section 10.4.3 for a full description of how the client and server are to interact with the use of CB_GETATTR.",
      "ja": "CB_GETATTR動作がOPEN_DELEGATE_WRITE委任されたファイルの現在の修正された状態を得るためにサーバによって使用されます。サイズと変更属性は、クライアントがサービスを提供することが保証だけです。クライアントとサーバがCB_GETATTRの使用と対話するある方法の完全な記述については10.4.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the filehandle specified is not one for which the client holds an OPEN_DELEGATE_WRITE delegation, an NFS4ERR_BADHANDLE error is returned.",
      "ja": "指定されたファイルハンドルは、クライアントがOPEN_DELEGATE_WRITE委任を保持するためのものではない場合は、NFS4ERR_BADHANDLEエラーが返されます。"
    },
    {
      "indent": 0,
      "text": "20.1.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.1.4. 実装"
    },
    {
      "indent": 3,
      "text": "The client returns attrmask bits and the associated attribute values only for the change attribute, and attributes that it may change (time_modify, and size).",
      "ja": "クライアントは、変更属性のattrmaskビットと関連付けられた属性値を返し、それが（time_modify、およびサイズ）を変更してもよいこと属性。"
    },
    {
      "indent": 0,
      "text": "20.2. Operation 4: CB_RECALL - Recall a Delegation",
      "section_title": true,
      "ja": "20.2. 操作4：CB_RECALL  - 委任を思い出してください"
    },
    {
      "indent": 0,
      "text": "20.2.1. ARGUMENT",
      "section_title": true,
      "ja": "20.2.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALL4args {\n        stateid4        stateid;\n        bool            truncate;\n        nfs_fh4         fh;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.2.2. RESULT",
      "section_title": true,
      "ja": "20.2.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALL4res {\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.2.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.2.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The CB_RECALL operation is used to begin the process of recalling a delegation and returning it to the server.",
      "ja": "CB_RECALL操作が委任を想起し、それをサーバーに戻す処理を開​​始するために使用されています。"
    },
    {
      "indent": 3,
      "text": "The truncate flag is used to optimize recall for a file object that is a regular file and is about to be truncated to zero. When it is TRUE, the client is freed of the obligation to propagate modified data for the file to the server, since this data is irrelevant.",
      "ja": "TRUNCATEフラグが通常ファイルであり、ゼロに切り捨てされようとしているファイルオブジェクトのリコールを最適化するために使用されます。それがtrueの場合、クライアントは、このデータが無関係であることから、サーバへのファイルの変更されたデータを伝達する義務が除去されます。"
    },
    {
      "indent": 3,
      "text": "If the handle specified is not one for which the client holds a delegation, an NFS4ERR_BADHANDLE error is returned.",
      "ja": "指定されたハンドルは、クライアントが委任を保持するためのものではない場合は、NFS4ERR_BADHANDLEエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "If the stateid specified is not one corresponding to an OPEN delegation for the file specified by the filehandle, an NFS4ERR_BAD_STATEID is returned.",
      "ja": "指定されたstateidは、ファイルハンドルで指定されたファイルのOPEN委譲に対応していないものである場合、NFS4ERR_BAD_STATEIDが返されます。"
    },
    {
      "indent": 0,
      "text": "20.2.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.2.4. 実装"
    },
    {
      "indent": 3,
      "text": "The client SHOULD reply to the callback immediately. Replying does not complete the recall except when the value of the reply's status field is neither NFS4ERR_DELAY nor NFS4_OK. The recall is not complete until the delegation is returned using a DELEGRETURN operation.",
      "ja": "クライアントはすぐにコールバックに返信すべきです。返信するには、回答者のステータスフィールドの値がいずれもNFS4ERR_DELAY NFS4_OKある場合を除いて、リコールを完了していません。代表団はDELEGRETURN操作を使用して返されるまで、リコールは完全ではありません。"
    },
    {
      "indent": 0,
      "text": "20.3. Operation 5: CB_LAYOUTRECALL - Recall Layout from Client",
      "section_title": true,
      "ja": "20.3. 操作5：CB_LAYOUTRECALL  - クライアントからリコールのレイアウト"
    },
    {
      "indent": 0,
      "text": "20.3.1. ARGUMENT",
      "section_title": true,
      "ja": "20.3.1. 引数"
    },
    {
      "indent": 3,
      "text": "/*\n * NFSv4.1 callback arguments and results\n */",
      "raw": true
    },
    {
      "indent": 3,
      "text": "enum layoutrecall_type4 { LAYOUTRECALL4_FILE = LAYOUT4_RET_REC_FILE, LAYOUTRECALL4_FSID = LAYOUT4_RET_REC_FSID, LAYOUTRECALL4_ALL = LAYOUT4_RET_REC_ALL };",
      "ja": "列挙layoutrecall_type4 {LAYOUTRECALL4_FILE = LAYOUT4_RET_REC_FILE、LAYOUTRECALL4_FSID = LAYOUT4_RET_REC_FSID、LAYOUTRECALL4_ALL = LAYOUT4_RET_REC_ALL}。"
    },
    {
      "indent": 3,
      "text": "struct layoutrecall_file4 {\n        nfs_fh4         lor_fh;\n        offset4         lor_offset;\n        length4         lor_length;\n        stateid4        lor_stateid;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union layoutrecall4 switch(layoutrecall_type4 lor_recalltype) {\ncase LAYOUTRECALL4_FILE:\n        layoutrecall_file4 lor_layout;\ncase LAYOUTRECALL4_FSID:\n        fsid4              lor_fsid;\ncase LAYOUTRECALL4_ALL:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct CB_LAYOUTRECALL4args {\n        layouttype4             clora_type;\n        layoutiomode4           clora_iomode;\n        bool                    clora_changed;\n        layoutrecall4           clora_recall;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.3.2. RESULT",
      "section_title": true,
      "ja": "20.3.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_LAYOUTRECALL4res {\n        nfsstat4        clorr_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.3.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.3.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The CB_LAYOUTRECALL operation is used by the server to recall layouts from the client; as a result, the client will begin the process of returning layouts via LAYOUTRETURN. The CB_LAYOUTRECALL operation specifies one of three forms of recall processing with the value of layoutrecall_type4. The recall is for one of the following: a specific layout of a specific file (LAYOUTRECALL4_FILE), an entire file system ID (LAYOUTRECALL4_FSID), or all file systems (LAYOUTRECALL4_ALL).",
      "ja": "CB_LAYOUTRECALL操作はクライアントからのレイアウトを思い出すためにサーバによって使用されます。結果として、クライアントはLAYOUTRETURNを経由してレイアウトを戻す処理を開​​始します。 CB_LAYOUTRECALL動作はlayoutrecall_type4の値にリコール処理の三つの形式のいずれかを指定します。リコールは、次のいずれかのためのものである：特定のファイル（LAYOUTRECALL4_FILE）の特定のレイアウト、ファイルシステム全体のID（LAYOUTRECALL4_FSID）、またはすべてのファイルシステム（LAYOUTRECALL4_ALL）。"
    },
    {
      "indent": 3,
      "text": "The behavior of the operation varies based on the value of the layoutrecall_type4. The value and behaviors are:",
      "ja": "操作の挙動はlayoutrecall_type4の値に基づいて変化します。値と行動は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "LAYOUTRECALL4_FILE",
      "ja": "LAYOUTRECALL4_FILE"
    },
    {
      "indent": 6,
      "text": "For a layout to match the recall request, the values of the following fields must match those of the layout: clora_type, clora_iomode, lor_fh, and the byte-range specified by lor_offset and lor_length. The clora_iomode field may have a special value of LAYOUTIOMODE4_ANY. The special value LAYOUTIOMODE4_ANY will match any iomode originally returned in a layout; therefore, it acts as a wild card. The other special value used is for lor_length. If lor_length has a value of NFS4_UINT64_MAX, the lor_length field means the maximum possible file size. If a matching layout is found, it MUST be returned using the",
      "ja": "clora_type、clora_iomode、lor_fh、及びlor_offsetとlor_lengthによって指定されたバイト範囲：リコール要求に合わせてレイアウトするため、以下のフィールドの値は、レイアウトのものと一致しなければなりません。 clora_iomodeフィールドはLAYOUTIOMODE4_ANYの特別な値を有することができます。特別な値LAYOUTIOMODE4_ANYは当初のレイアウトで返されたIOModeにマッチします。したがって、それはワイルドカードとして機能します。使用される他の特別な値はlor_lengthためです。 lor_lengthがNFS4_UINT64_MAXの価値を持っている場合、lor_lengthフィールドは可能な最大ファイルサイズを意味しています。マッチングのレイアウトが見つかった場合、それを使用して返さなければなりません"
    },
    {
      "indent": 6,
      "text": "LAYOUTRETURN operation (see Section 18.44). An example of the field's special value use is if clora_iomode is LAYOUTIOMODE4_ANY, lor_offset is zero, and lor_length is NFS4_UINT64_MAX, then the entire layout is to be returned.",
      "ja": "LAYOUTRETURN操作（項18.44を参照してください）。フィールドの特殊値使用の例はclora_iomodeがLAYOUTIOMODE4_ANYある場合、lor_offsetはゼロであり、そしてlor_lengthはNFS4_UINT64_MAXであり、その後、全体のレイアウトが返されます。"
    },
    {
      "indent": 6,
      "text": "The NFS4ERR_NOMATCHING_LAYOUT error is only returned when the client does not hold layouts for the file or if the client does not have any overlapping layouts for the specification in the layout recall.",
      "ja": "クライアントは、ファイルのレイアウトを保持していない場合や、クライアントがレイアウトリコールでの仕様のための任意の重複のレイアウトを持っていない場合NFS4ERR_NOMATCHING_LAYOUTエラーのみが返されます。"
    },
    {
      "indent": 3,
      "text": "LAYOUTRECALL4_FSID and LAYOUTRECALL4_ALL",
      "ja": "LAYOUTRECALL4_FSIDとLAYOUTRECALL4_ALL"
    },
    {
      "indent": 6,
      "text": "If LAYOUTRECALL4_FSID is specified, the fsid specifies the file system for which any outstanding layouts MUST be returned. If LAYOUTRECALL4_ALL is specified, all outstanding layouts MUST be returned. In addition, LAYOUTRECALL4_FSID and LAYOUTRECALL4_ALL specify that all the storage device ID to storage device address mappings in the affected file system(s) are also recalled. The respective LAYOUTRETURN with either LAYOUTRETURN4_FSID or LAYOUTRETURN4_ALL acknowledges to the server that the client invalidated the said device mappings. See Section 12.5.5.2.1.5 for considerations with \"bulk\" recall of layouts.",
      "ja": "LAYOUTRECALL4_FSIDが指定されている場合、FSIDは、未処理のレイアウトが返さなければならないため、ファイルシステムを指定します。 LAYOUTRECALL4_ALLが指定されている場合は、すべての未レイアウトが返されなければなりません。また、LAYOUTRECALL4_FSIDとLAYOUTRECALL4_ALLは、影響を受けるファイル・システム（単数または複数）の記憶装置アドレス・マッピングへのすべてのストレージ・デバイスIDを指定しても想起されます。 LAYOUTRETURN4_FSIDまたはLAYOUTRETURN4_ALLのいずれかで、それぞれのLAYOUTRETURNは、クライアントが言ったデバイスのマッピングを無効にサーバに認識しています。レイアウトの「バルク」のリコールとの考慮事項については、第12.5.5.2.1.5を参照してください。"
    },
    {
      "indent": 6,
      "text": "The NFS4ERR_NOMATCHING_LAYOUT error is only returned when the client does not hold layouts and does not have valid deviceid mappings.",
      "ja": "クライアントは、レイアウトを保持していないと、有効なデバイスIDのマッピングを持っていない場合NFS4ERR_NOMATCHING_LAYOUTエラーのみが返されます。"
    },
    {
      "indent": 3,
      "text": "In processing the layout recall request, the client also varies its behavior based on the value of the clora_changed field. This field is used by the server to provide additional context for the reason why the layout is being recalled. A FALSE value for clora_changed indicates that no change in the layout is expected and the client may write modified data to the storage devices involved; this must be done prior to returning the layout via LAYOUTRETURN. A TRUE value for clora_changed indicates that the server is changing the layout. Examples of layout changes and reasons for a TRUE indication are the following: the metadata server is restriping the file or a permanent error has occurred on a storage device and the metadata server would like to provide a new layout for the file. Therefore, a clora_changed value of TRUE indicates some level of change for the layout and the client SHOULD NOT write and commit modified data to the storage devices. In this case, the client writes and commits data through the metadata server.",
      "ja": "レイアウトのリコール要求を処理するには、クライアントもclora_changedフィールドの値に基づいて、その動作を変化させます。このフィールドはレイアウトがリコールされている理由のための追加のコンテキストを提供するために、サーバーによって使用されます。 clora_changedためFALSE値は、レイアウトの変更が予想されていないと、クライアントが関与するストレージデバイスに変更されたデータを書き込むことができることを示しています。これはLAYOUTRETURNを経由して、レイアウトを返す前に行う必要があります。 clora_changedためのTRUE値は、サーバがレイアウトを変更していることを示します。レイアウト変更やTRUE適応症の理由の例は次のとおりです。メタデータ・サーバがファイルを再ストライピングされたか、永続的なエラーがストレージデバイス上で発生していると、メタデータサーバは、ファイルの新しいレイアウトを提供したいと思います。したがって、TRUEのclora_changed値は、レイアウトの変更のいくつかのレベルを示し、クライアントは、ストレージ・デバイスに変更されたデータを書き込み、コミットすべきではありません。この場合、クライアントは、書き込み、メタデータサーバを介してデータをコミットします。"
    },
    {
      "indent": 3,
      "text": "See Section 12.5.3 for a description of how the lor_stateid field in the arguments is to be constructed. Note that the \"seqid\" field of lor_stateid MUST NOT be zero. See Sections 8.2, 12.5.3, and 12.5.5.2 for a further discussion and requirements.",
      "ja": "引数でlor_stateidフィールドを構築する方法については、セクション12.5.3を参照してください。 lor_stateidの「SEQID」フィールドがゼロにされてはならないことに注意してください。さらなる議論と要件については、セクション8.2、12.5.3、および12.5.5.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "20.3.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.3.4. 実装"
    },
    {
      "indent": 3,
      "text": "The client's processing for CB_LAYOUTRECALL is similar to CB_RECALL (recall of file delegations) in that the client responds to the request before actually returning layouts via the LAYOUTRETURN operation. While the client responds to the CB_LAYOUTRECALL immediately, the operation is not considered complete (i.e., considered pending) until all affected layouts are returned to the server via the LAYOUTRETURN operation.",
      "ja": "CB_LAYOUTRECALLのためのクライアントの処理は、実際にLAYOUTRETURN操作によってレイアウトを返す前に、クライアントが要求に応答することでCB_RECALL（ファイルの代表団のリコール）に似ています。クライアントはすぐにCB_LAYOUTRECALLに応答しながら、影響を受けるすべてのレイアウトはLAYOUTRETURN操作を介してサーバに戻されるまで、操作が（すなわち、保留中と見なさ）完了したとみなされていません。"
    },
    {
      "indent": 3,
      "text": "Before returning the layout to the server via LAYOUTRETURN, the client should wait for the response from in-process or in-flight READ, WRITE, or COMMIT operations that use the recalled layout.",
      "ja": "LAYOUTRETURNを介してサーバにレイアウトを戻す前に、クライアントは、READプロセス中または機内からの応答を待つWRITE、またはリコールレイアウトを使用する操作をコミットする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client is holding modified data that is affected by a recalled layout, the client has various options for writing the data to the server. As always, the client may write the data through the metadata server. In fact, the client may not have a choice other than writing to the metadata server when the clora_changed argument is TRUE and a new layout is unavailable from the server. However, the client may be able to write the modified data to the storage device if the clora_changed argument is FALSE; this needs to be done before returning the layout via LAYOUTRETURN. If the client were to obtain a new layout covering the modified data's byte-range, then writing to the storage devices is an available alternative. Note that before obtaining a new layout, the client must first return the original layout.",
      "ja": "クライアントがリコールレイアウトの影響を受けて変更されたデータを保持している場合は、クライアントがサーバーにデータを書き込むためのさまざまなオプションがあります。いつものように、クライアントは、メタデータサーバを介してデータを書き込むことができます。 clora_changed引数がTRUEで、新しいレイアウトがサーバから利用できない場合実際には、クライアントは、メタデータサーバへの書き込み以外の選択肢を持っていないかもしれません。しかしながら、クライアントはclora_changed引数がFALSEである場合にストレージデバイスに変更されたデータを書き込むことができるかもしれません。これはLAYOUTRETURNを経由して、レイアウトを返す前に行われる必要があります。クライアントが変更されたデータのバイト範囲をカバーする新しいレイアウトを取得した場合は、ストレージ・デバイスへの書き込みは利用可能な代替です。新しいレイアウトを取得する前に、クライアントが最初に元のレイアウトを返さなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "In the case of modified data being written while the layout is held, the client must use LAYOUTCOMMIT operations at the appropriate time; as required LAYOUTCOMMIT must be done before the LAYOUTRETURN. If a large amount of modified data is outstanding, the client may send LAYOUTRETURNs for portions of the recalled layout; this allows the server to monitor the client's progress and adherence to the original recall request. However, the last LAYOUTRETURN in a sequence of returns MUST specify the full range being recalled (see Section 12.5.5.1 for details).",
      "ja": "レイアウトが保持された状態で書き込まれる変更されたデータの場合には、クライアントが適切な時間にLAYOUTCOMMIT操作を使用しなければなりません。必要に応じてLAYOUTCOMMITはLAYOUTRETURN前に行う必要があります。修飾された大量のデータが未処理である場合、クライアントは、リコールレイアウトの部分についてLAYOUTRETURNsを送信することができます。これは、サーバが、元のリコール要求に、クライアントの進捗状況と遵守を監視することができます。しかし、リターンのシーケンスの最後のLAYOUTRETURNは（詳細はセクション12.5.5.1を参照）リコールされている完全な範囲を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a server needs to delete a device ID and there are layouts referring to the device ID, CB_LAYOUTRECALL MUST be invoked to cause the client to return all layouts referring to the device ID before the server can delete the device ID. If the client does not return the affected layouts, the server MAY revoke the layouts.",
      "ja": "サーバは、デバイスIDを削除する必要があり、デバイスIDを参照するレイアウトがある場合、CB_LAYOUTRECALLは、サーバがデバイスIDを削除することができます前に、デバイスIDを参照するすべてのレイアウトを返すようにクライアントを引き起こすために呼び出さなければなりません。クライアントが影響を受けたレイアウトを返さない場合、サーバーは、レイアウトを取り消すことができます。"
    },
    {
      "indent": 0,
      "text": "20.4. Operation 6: CB_NOTIFY - Notify Client of Directory Changes",
      "section_title": true,
      "ja": "20.4. 操作6：CB_NOTIFY  - ディレクトリの変更をクライアントに通知"
    },
    {
      "indent": 0,
      "text": "20.4.1. ARGUMENT",
      "section_title": true,
      "ja": "20.4.1. 引数"
    },
    {
      "indent": 3,
      "text": "/*\n * Directory notification types.\n */\nenum notify_type4 {\n        NOTIFY4_CHANGE_CHILD_ATTRS = 0,\n        NOTIFY4_CHANGE_DIR_ATTRS = 1,\n        NOTIFY4_REMOVE_ENTRY = 2,\n        NOTIFY4_ADD_ENTRY = 3,\n        NOTIFY4_RENAME_ENTRY = 4,\n        NOTIFY4_CHANGE_COOKIE_VERIFIER = 5\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Changed entry information.  */\nstruct notify_entry4 {\n        component4      ne_file;\n        fattr4          ne_attrs;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* Previous entry information */\nstruct prev_entry4 {\n        notify_entry4   pe_prev_entry;\n        /* what READDIR returned for this entry */\n        nfs_cookie4     pe_prev_entry_cookie;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct notify_remove4 {\n        notify_entry4   nrm_old_entry;\n        nfs_cookie4     nrm_old_entry_cookie;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct notify_add4 {\n        /*\n         * Information on object\n         * possibly renamed over.\n         */\n        notify_remove4      nad_old_entry<1>;\n        notify_entry4       nad_new_entry;\n        /* what READDIR would have returned for this entry */\n        nfs_cookie4         nad_new_entry_cookie<1>;\n        prev_entry4         nad_prev_entry<1>;\n        bool                nad_last_entry;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct notify_attr4 {\n        notify_entry4   na_changed_entry;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct notify_rename4 {\n        notify_remove4  nrn_old_entry;\n        notify_add4     nrn_new_entry;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct notify_verifier4 {\n        verifier4       nv_old_cookieverf;\n        verifier4       nv_new_cookieverf;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/*\n * Objects of type notify_<>4 and\n * notify_device_<>4 are encoded in this.\n */\ntypedef opaque notifylist4<>;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct notify4 {\n        /* composed from notify_type4 or notify_deviceid_type4 */\n        bitmap4         notify_mask;\n        notifylist4     notify_vals;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct CB_NOTIFY4args {\n        stateid4    cna_stateid;\n        nfs_fh4     cna_fh;\n        notify4     cna_changes<>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.4.2. RESULT",
      "section_title": true,
      "ja": "20.4.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_NOTIFY4res {\n        nfsstat4    cnr_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.4.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.4.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The CB_NOTIFY operation is used by the server to send notifications to clients about changes to delegated directories. The registration of notifications for the directories occurs when the delegation is established using GET_DIR_DELEGATION. These notifications are sent over the backchannel. The notification is sent once the original request has been processed on the server. The server will send an array of notifications for changes that might have occurred in the directory. The notifications are sent as list of pairs of bitmaps and values. See Section 3.3.7 for a description of how NFSv4.1 bitmaps work.",
      "ja": "CB_NOTIFY操作が委任ディレクトリへの変更についてクライアントに通知を送信するためにサーバーによって使用されます。代表団はGET_DIR_DELEGATIONを使用して確立されたときのディレクトリの通知の登録が発生します。これらの通知は、バックチャネルを介して送信されます。元の要求がサーバー上で処理された後に通知が送信されます。サーバーは、ディレクトリに発生した可能性のある変更の通知の配列を送信します。通知は、ビットマップと値のペアのリストとして送信されます。 NFSv4.1ビットマップがどのように動作するかの説明については、セクション3.3.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the server has more notifications than can fit in the CB_COMPOUND request, it SHOULD send a sequence of serial CB_COMPOUND requests so that the client's view of the directory does not become confused. For example, if the server indicates that a file named \"foo\" is added and that the file \"foo\" is removed, the order in which the client receives these notifications needs to be the same as the order in which the corresponding operations occurred on the server.",
      "ja": "サーバはCB_COMPOUND要求に合うことができるよりも多くの通知を持っている場合は、ディレクトリのクライアントのビューが混乱しないように、それはシリアルCB_COMPOUND要求のシーケンスを送信すべきです。例えば、サーバが「foo」という名前のファイルが追加されていることを示し、ファイル「fooが」削除されたことならば、クライアントはこれらの通知を受信する順序は、対応する操作は、上の発生した順序と同じにする必要がありますサーバー。"
    },
    {
      "indent": 3,
      "text": "If the client holding the delegation makes any changes in the directory that cause files or sub-directories to be added or removed, the server will notify that client of the resulting change(s). If the client holding the delegation is making attribute or cookie verifier changes only, the server does not need to send notifications to that client. The server will send the following information for each operation:",
      "ja": "委任を保持しているクライアントは、ファイルやサブディレクトリを追加または削除することが原因とディレクトリの変更を行った場合、サーバーは、結果の変化（S）のことをクライアントに通知します。委任を保持しているクライアントは、唯一の属性やクッキー検証の変更を行っている場合は、サーバーはそのクライアントに通知を送信する必要はありません。サーバは、各操作のために、以下の情報をお送りします。"
    },
    {
      "indent": 3,
      "text": "NOTIFY4_ADD_ENTRY The server will send information about the new directory entry being created along with the cookie for that entry. The entry information (data type notify_add4) includes the component name of the entry and attributes. The server will send this type of entry when a file is actually being created, when an entry is being added to a directory as a result of a rename across directories (see below), and when a hard link is being created to an existing file. If this entry is added to the end of the directory, the server will set the nad_last_entry flag to TRUE. If the file is added such that there is at least one entry before it, the server will also return the previous entry information (nad_prev_entry, a variable-length array of up to one element. If the array is of zero length, there is no previous entry), along with its cookie. This is to help clients find the right location in their file name caches and directory caches where this entry should be cached. If the new entry's cookie is available, it will be in the nad_new_entry_cookie (another variable-length array of up to one element) field. If the addition of the entry causes another entry to be deleted (which can only happen in the rename case) atomically with the addition, then information on this entry is reported in nad_old_entry.",
      "ja": "NOTIFY4_ADD_ENTRYは、サーバーはそのエントリのためのクッキーと一緒に作成される新しいディレクトリエントリに関する情報が送信されます。エントリ情報（データ型notify_add4）エントリと属性の部品名を含みます。ファイルが実際にエントリが（下記参照）のディレクトリ間で名前変更の結果として、ディレクトリに追加されている場合、作成されているとき、およびハードリンクが既存のファイルに作成されているとき、サーバは、エントリのこのタイプを送信します。このエントリがディレクトリの最後に追加されている場合は、サーバがTRUEにnad_last_entryフラグを設定します。ファイルがその前少なくとも1つのエントリが存在するように添加された場合、サーバは、以前のエントリ情報まで一つの元素の（nad_prev_entry、可変長配列を返します。配列は、長さゼロである場合、ないあります前のエントリ）、そのクッキーと一緒に。これは、クライアントがファイル名のキャッシュとこのエントリがキャッシュされるべきディレクトリのキャッシュに適切な場所を見つけることです。新しいエントリのクッキーが使用可能である場合、それはnad_new_entry_cookieフィールド（最大1素子の他の可変長配列）になります。エントリの追加は（のみリネーム場合に発生する可能性がある）アトミックに添加して、別のエントリが削除される場合は、このエントリにその情報がnad_old_entryで報告されます。"
    },
    {
      "indent": 3,
      "text": "NOTIFY4_REMOVE_ENTRY The server will send information about the directory entry being deleted. The server will also send the cookie value for the deleted entry so that clients can get to the cached information for this entry.",
      "ja": "NOTIFY4_REMOVE_ENTRYサーバーは、ディレクトリエントリが削除されている情報を送信します。クライアントは、このエントリのキャッシュされた情報を得ることができるように、サーバーも削除されたエントリのCookie値を送信します。"
    },
    {
      "indent": 3,
      "text": "NOTIFY4_RENAME_ENTRY The server will send information about both the old entry and the new entry. This includes the name and attributes for each entry. In addition, if the rename causes the deletion of an entry (i.e., the case of a file renamed over), then this is reported in nrn_new_new_entry.nad_old_entry. This notification is only sent if both entries are in the same directory. If the rename is across directories, the server will send a remove notification to one directory and an add notification to the other directory, assuming both have a directory delegation.",
      "ja": "NOTIFY4_RENAME_ENTRYサーバーは、古いエントリと新しいエントリの両方についての情報が送信されます。これは、各エントリの名前と属性が含まれています。リネーム（すなわち、ファイルの場合は、オーバー改名）のエントリの削除が発生する場合に加えて、これはnrn_new_new_entry.nad_old_entryに報告されています。両方のエントリが同じディレクトリにある場合は、この通知にのみ送信されます。名前の変更は、ディレクトリ間であれば、サーバは両方とも、ディレクトリ委任を持っていると仮定すると、他のディレクトリにあるディレクトリおよび追加通知に削除通知を送信します。"
    },
    {
      "indent": 3,
      "text": "NOTIFY4_CHANGE_CHILD_ATTRS/NOTIFY4_CHANGE_DIR_ATTRS The client will use the attribute mask to inform the server of attributes for which it wants to receive notifications. This change notification can be requested for changes to the attributes of the directory as well as changes to any file's attributes in the directory by using two separate attribute masks. The client cannot ask for change attribute notification for a specific file. One attribute mask covers all the files in the directory. Upon any attribute change, the server will send back the values of changed attributes. Notifications might not make sense for some file system-wide attributes, and it is up to the server to decide which subset it wants to support. The client can negotiate the frequency of attribute notifications by letting the server know how often it wants to be notified of an attribute change. The server will return supported notification frequencies or an indication that no notification is permitted for directory or child attributes by setting the dir_notif_delay and dir_entry_notif_delay attributes, respectively.",
      "ja": "NOTIFY4_CHANGE_CHILD_ATTRS /クライアントが通知を受信したいの属性のサーバーに通知するために、属性マスクを使用しますNOTIFY4_CHANGE_DIR_ATTRS。この変更通知は、ディレクトリの属性への変更だけでなく、二つの別々の属性マスクを使用して、ディレクトリ内のファイルの属性への変更を要求することができます。クライアントは、特定のファイルの属性変更通知を求めることはできません。 1つの属性マスクは、ディレクトリ内のすべてのファイルをカバーしています。任意の属性を変更すると、サーバが変更された属性の値を返送します。通知は、いくつかのファイルシステム全体の属性のための意味を成していない可能性があり、そしてそれがサポートしたいサブセットを決定するサーバー次第です。クライアントは、サーバが属性変更の通知を受けることを希望する頻度を知らせることにより、属性通知の頻度を交渉することができます。サーバーは、通知頻度あるいは全く通知がディレクトリや子供のために許可されていないことを示し、それぞれ、dir_notif_delayとdir_entry_notif_delay属性を設定することで、属性をサポート返します。"
    },
    {
      "indent": 3,
      "text": "NOTIFY4_CHANGE_COOKIE_VERIFIER If the cookie verifier changes while a client is holding a delegation, the server will notify the client so that it can invalidate its cookies and re-send a READDIR to get the new set of cookies.",
      "ja": "クライアントが委任を保持している間、それはそのクッキーを無効にし、クッキーの新しいセットを取得するREADDIRを再送信できるようにNOTIFY4_CHANGE_COOKIE_VERIFIERクッキー検証が変更された場合は、サーバがクライアントに通知します。"
    },
    {
      "indent": 0,
      "text": "20.5. Operation 7: CB_PUSH_DELEG - Offer Previously Requested Delegation to Client",
      "ja": "20.5. 操作7：CB_PUSH_DELEG  - クライアントに以前に要求委任を提供"
    },
    {
      "indent": 0,
      "text": "20.5.1. ARGUMENT",
      "section_title": true,
      "ja": "20.5.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct CB_PUSH_DELEG4args {\n        nfs_fh4          cpda_fh;\n        open_delegation4 cpda_delegation;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "};",
      "ja": "｝；"
    },
    {
      "indent": 0,
      "text": "20.5.2. RESULT",
      "section_title": true,
      "ja": "20.5.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_PUSH_DELEG4res {\n        nfsstat4 cpdr_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.5.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.5.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "CB_PUSH_DELEG is used by the server both to signal to the client that the delegation it wants (previously indicated via a want established from an OPEN or WANT_DELEGATION operation) is available and to simultaneously offer the delegation to the client. The client has the choice of accepting the delegation by returning NFS4_OK to the server, delaying the decision to accept the offered delegation by returning NFS4ERR_DELAY, or permanently rejecting the offer of the delegation by returning NFS4ERR_REJECT_DELEG. When a delegation is rejected in this fashion, the want previously established is permanently deleted and the delegation is subject to acquisition by another client.",
      "ja": "CB_PUSH_DELEGは、両方のは、それが望んでいる代表団は（以前にOPENまたはWANT_DELEGATION操作から確立希望を経由して示されている）が利用可能であることをクライアントに通知するために、同時にクライアントへの委任を提供するために、サーバによって使用されます。クライアントは、サーバーへのNFS4_OKを返すNFS4ERR_DELAYを返す、または恒久NFS4ERR_REJECT_DELEGを返すことによって委任の提供を拒否することによって提供する代表団を受け入れる決定を遅らせることによって代表団を受け入れるの選択肢を持っています。代表団は、この方法で拒否された場合には、以前に確立された希望を完全に削除し、代表団は、他のクライアントによる取得の対象とされます。"
    },
    {
      "indent": 0,
      "text": "20.5.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.5.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the client does return NFS4ERR_DELAY and there is a conflicting delegation request, the server MAY process it at the expense of the client that returned NFS4ERR_DELAY. The client's want will not be cancelled, but MAY be processed behind other delegation requests or registered wants.",
      "ja": "クライアントがNFS4ERR_DELAYを返さず、矛盾する委譲要求があった場合、サーバはNFS4ERR_DELAYを返されたクライアントを犠牲にして、それを処理することができます。クライアントの希望はキャンセルされませんが、他の委譲要求または登録欲求の後ろに加工することができます。"
    },
    {
      "indent": 3,
      "text": "When a client returns a status other than NFS4_OK, NFS4ERR_DELAY, or NFS4ERR_REJECT_DELAY, the want remains pending, although servers may decide to cancel the want by sending a CB_WANTS_CANCELLED.",
      "ja": "クライアントはNFS4_OK、NFS4ERR_DELAY、またはNFS4ERR_REJECT_DELAY以外のステータスを返した場合、サーバはCB_WANTS_CANCELLEDを送信して、お好きを中止することを決定するかもしれないが、希望は、保留中のまま。"
    },
    {
      "indent": 0,
      "text": "20.6. Operation 8: CB_RECALL_ANY - Keep Any N Recallable Objects",
      "section_title": true,
      "ja": "20.6. 操作8：CB_RECALL_ANY  - どれリコールのオブジェクトを保持"
    },
    {
      "indent": 0,
      "text": "20.6.1. ARGUMENT",
      "section_title": true,
      "ja": "20.6.1. 引数"
    },
    {
      "indent": 3,
      "text": "const RCA4_TYPE_MASK_RDATA_DLG          = 0;\nconst RCA4_TYPE_MASK_WDATA_DLG          = 1;\nconst RCA4_TYPE_MASK_DIR_DLG            = 2;\nconst RCA4_TYPE_MASK_FILE_LAYOUT        = 3;\nconst RCA4_TYPE_MASK_BLK_LAYOUT         = 4;\nconst RCA4_TYPE_MASK_OBJ_LAYOUT_MIN     = 8;\nconst RCA4_TYPE_MASK_OBJ_LAYOUT_MAX     = 9;\nconst RCA4_TYPE_MASK_OTHER_LAYOUT_MIN   = 12;\nconst RCA4_TYPE_MASK_OTHER_LAYOUT_MAX   = 15;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct  CB_RECALL_ANY4args      {\n        uint32_t        craa_objects_to_keep;\n        bitmap4         craa_type_mask;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.6.2. RESULT",
      "section_title": true,
      "ja": "20.6.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALL_ANY4res {\n        nfsstat4        crar_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.6.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.6.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The server may decide that it cannot hold all of the state for recallable objects, such as delegations and layouts, without running out of resources. In such a case, while not optimal, the server is free to recall individual objects to reduce the load.",
      "ja": "サーバはリソースが不足することなく、そのような代表団やレイアウトなどのリコールオブジェクトのための状態のすべてを保持することはできませんことを決定することができます。そのような場合には、最適ではないながら、サーバー負荷を減らすために、個々のオブジェクトをリコールして自由です。"
    },
    {
      "indent": 3,
      "text": "Because the general purpose of such recallable objects as delegations is to eliminate client interaction with the server, the server cannot interpret lack of recent use as indicating that the object is no longer useful. The absence of visible use is consistent with a delegation keeping potential operations from being sent to the server. In the case of layouts, while it is true that the usefulness of a layout is indicated by the use of the layout when storage devices receive I/O requests, because there is no mandate that a storage device indicate to the metadata server any past or present use of a layout, the metadata server is not likely to know which layouts are good candidates to recall in response to low resources.",
      "ja": "代表団などのリコール対象物の一般的な目的は、サーバーとクライアントの相互作用を排除することであるため、サーバーは、オブジェクトがもはや有用であることを示していないとして、最近の使用の欠如を解釈することはできません。可視使用の欠如はサーバに送信されるの電位操作を維持委任と一致しています。それが真である間、記憶装置は、I / O要求を受信したとき、記憶装置は、メタデータサーバ、任意の過去以上に示すない義務がないため、レイアウトの場合には、レイアウトの有用性は、レイアウトの使用によって示されていることレイアウトの現在の使用、メタデータサーバは、低リソースに応じてリコールする良い候補であるレイアウトを知ってそうではありません。"
    },
    {
      "indent": 3,
      "text": "In order to implement an effective reclaim scheme for such objects, the server's knowledge of available resources must be used to determine when objects must be recalled with the clients selecting the actual objects to be returned.",
      "ja": "そのようなオブジェクトのための効果的な再利用方式を実施するためには、利用可能なリソースのサーバーの知識は、オブジェクトが返される実際のオブジェクトを選択したクライアントでリコールされなければならないときを決定するために使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Server implementations may differ in their resource allocation requirements. For example, one server may share resources among all classes of recallable objects, whereas another may use separate resource pools for layouts and for delegations, or further separate resources by types of delegations.",
      "ja": "サーバ実装は、そのリソース割り当ての要件に異なる場合があります。別の代表団の種類によってレイアウトおよび委任、またはさらに別のリソースのための別のリソースプールを使用することができるのに対し、例えば、1台のサーバが、リコール対象のすべてのクラス間でリソースを共有することができます。"
    },
    {
      "indent": 3,
      "text": "When a given resource pool is over-utilized, the server can send a CB_RECALL_ANY to clients holding recallable objects of the types involved, allowing it to keep a certain number of such objects and return any excess. A mask specifies which types of objects are to be limited. The client chooses, based on its own knowledge of current usefulness, which of the objects in that class should be returned.",
      "ja": "与えられたリソースプールが過利用の場合、サーバーは、クライアントが、それがこのようなオブジェクトの一定数を維持し、余分を戻すことができる、関連する型のリコール対象物を保持するCB_RECALL_ANYを送ることができます。マスクは、オブジェクトの種類が限定されるべきであるかを指定します。クライアントは、そのクラスのオブジェクトで返されるべき現在の有用性、独自の知識に基づいて、選択します。"
    },
    {
      "indent": 3,
      "text": "A number of bits are defined. For some of these, ranges are defined and it is up to the definition of the storage protocol to specify how these are to be used. There are ranges reserved for object-based storage protocols and for other experimental storage protocols. An RFC defining such a storage protocol needs to specify how particular bits within its range are to be used. For example, it may specify a mapping between attributes of the layout (read vs. write, size of area) and the bit to be used, or it may define a field in the layout where the associated bit position is made available by the server to the client.",
      "ja": "ビット数が規定されています。これらのいくつかのために、範囲が定義されており、これらが使用される方法を指定するためのストレージプロトコルの定義次第です。オブジェクトベースのストレージプロトコルのためにと他の実験のストレージプロトコルのために予約範囲があります。このようなストレージプロトコルを定義するRFCは、その範囲内で使用される方法の特定のビットを指定する必要があります。例えば、レイアウトの属性との間のマッピングを指定することができる（ライト対面積の大きさを読み取る）とビットが使用されるか、関連するビット位置はサーバによって利用可能にされるレイアウトにフィールドを定義することができますクライアントへ。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_RDATA_DLG",
      "ja": "RCA4_TYPE_MASK_RDATA_DLG"
    },
    {
      "indent": 6,
      "text": "The client is to return OPEN_DELEGATE_READ delegations on non-directory file objects.",
      "ja": "クライアントは、非ディレクトリファイルオブジェクトのOPEN_DELEGATE_READの委任を返すことです。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_WDATA_DLG",
      "ja": "RCA4_TYPE_MASK_WDATA_DLG"
    },
    {
      "indent": 6,
      "text": "The client is to return OPEN_DELEGATE_WRITE delegations on regular file objects.",
      "ja": "クライアントは、通常のファイルオブジェクトにOPEN_DELEGATE_WRITE委任を返すことです。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_DIR_DLG",
      "ja": "RCA4_TYPE_MASK_DIR_DLG"
    },
    {
      "indent": 6,
      "text": "The client is to return directory delegations.",
      "ja": "クライアントは、ディレクトリ委任を返すことです。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_FILE_LAYOUT",
      "ja": "RCA4_TYPE_MASK_FILE_LAYOUT"
    },
    {
      "indent": 6,
      "text": "The client is to return layouts of type LAYOUT4_NFSV4_1_FILES.",
      "ja": "クライアントは、タイプLAYOUT4_NFSV4_1_FILESのレイアウトを返すことです。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_BLK_LAYOUT",
      "ja": "RCA4_TYPE_MASK_BLK_LAYOUT"
    },
    {
      "indent": 6,
      "text": "See [41] for a description.",
      "ja": "詳細については、[41]を参照してください。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_OBJ_LAYOUT_MIN to RCA4_TYPE_MASK_OBJ_LAYOUT_MAX",
      "ja": "RCA4_TYPE_MASK_OBJ_LAYOUT_MAXにRCA4_TYPE_MASK_OBJ_LAYOUT_MIN"
    },
    {
      "indent": 6,
      "text": "See [40] for a description.",
      "ja": "詳細については、[40]を参照してください。"
    },
    {
      "indent": 3,
      "text": "RCA4_TYPE_MASK_OTHER_LAYOUT_MIN to RCA4_TYPE_MASK_OTHER_LAYOUT_MAX",
      "ja": "RCA4_TYPE_MASK_OTHER_LAYOUT_MAXにRCA4_TYPE_MASK_OTHER_LAYOUT_MIN"
    },
    {
      "indent": 6,
      "text": "This range is reserved for telling the client to recall layouts of experimental or site-specific layout types (see Section 3.3.13).",
      "ja": "この範囲は、実験やサイト固有のレイアウトタイプのレイアウトを思い出すために、クライアントに伝えるために予約されている（セクション3.3.13を参照してください）。"
    },
    {
      "indent": 3,
      "text": "When a bit is set in the type mask that corresponds to an undefined type of recallable object, NFS4ERR_INVAL MUST be returned. When a bit is set that corresponds to a defined type of object but the client does not support an object of the type, NFS4ERR_INVAL MUST NOT be returned. Future minor versions of NFSv4 may expand the set of valid type mask bits.",
      "ja": "ビットは、リコール対象の未定義のタイプに対応するタイプのマスクに設定されている場合、NFS4ERR_INVALが返さなければなりません。ビットは、オブジェクトの定義された型に対応するが、クライアントは型のオブジェクトをサポートしていないように設定されている場合、NFS4ERR_INVALが返されてはなりません。 NFSv4の将来のマイナーバージョンでは有効なタイプのマスクビットのセットを拡張することがあります。"
    },
    {
      "indent": 3,
      "text": "CB_RECALL_ANY specifies a count of objects that the client may keep as opposed to a count that the client must return. This is to avoid a potential race between a CB_RECALL_ANY that had a count of objects to free with a set of client-originated operations to return layouts or delegations. As a result of the race, the client and server would have differing ideas as to how many objects to return. Hence, the client could mistakenly free too many.",
      "ja": "CB_RECALL_ANYは、クライアントは、クライアントが返す必要がありますカウントにとして反対保つ可能性のあるオブジェクトの数を指定します。これは、レイアウトや委任を返すために、クライアントから発信操作の集合を解放するオブジェクトの数を持っていたCB_RECALL_ANY間の潜在的な競合を避けるためです。レースの結果、クライアントとサーバが返す方法を多くのオブジェクトへとアイデアが異なるだろう。したがって、クライアントが誤ってあまりにも多くを解放することができます。"
    },
    {
      "indent": 3,
      "text": "If resource demands prompt it, the server may send another CB_RECALL_ANY with a lower count, even if it has not yet received an acknowledgment from the client for a previous CB_RECALL_ANY with the same type mask. Although the possibility exists that these will be received by the client in an order different from the order in which they were sent, any such permutation of the callback stream is harmless. It is the job of the client to bring down the size of the recallable object set in line with each CB_RECALL_ANY received, and until that obligation is met, it cannot be cancelled or modified by any subsequent CB_RECALL_ANY for the same type mask. Thus, if the server sends two CB_RECALL_ANYs, the effect will be the same as if the lower count was sent, whatever the order of recall receipt. Note that this means that a server may not cancel the effect of a CB_RECALL_ANY by sending another recall with a higher count. When a CB_RECALL_ANY is received and the count is already within the limit set or is above a limit that the client is working to get down to, that callback has no effect.",
      "ja": "リソース要求がそれを要求した場合、サーバーは、それがまだ同じタイプのマスクで、前のCB_RECALL_ANYのためにクライアントからの確認応答を受信して​​いない場合でも、低カウントは別のCB_RECALL_ANYを送信することができます。可能性は、これらは、それらが送信された順序とは異なる順序でクライアントによって受信されることが存在するが、コールバック・ストリームの任意のこのような置換は無害です。 CB_RECALL_ANYが受信それぞれに沿って設定されリコールオブジェクトのサイズをダウンさせるために、クライアントの仕事であり、その義務が満たされるまで、それは同じ型マスクのための任意の後続のCB_RECALL_ANYによってキャンセル又は変更することができません。サーバが2 CB_RECALL_ANYsを送信する場合下のカウントがリコール領収書のどのような順序、送信された場合と同じ結果になります。これは、サーバーが高い数を持つ別のリコールを送信することにより、CB_RECALL_ANYの影響をキャンセルしない可能性があることを意味することに注意してください。 CB_RECALL_ANYが受信された場合、カウントは、そのコールバックが効果がありません、上限設定の中にすでにあるか、クライアントがダウンに取得するために取り組んでいる限度を超えています。"
    },
    {
      "indent": 3,
      "text": "Servers are generally free to deny recallable objects when insufficient resources are available. Note that the effect of such a policy is implicitly to give precedence to existing objects relative to requested ones, with the result that resources might not be optimally used. To prevent this, servers are well advised to make the point at which they start sending CB_RECALL_ANY callbacks somewhat below that at which they cease to give out new delegations and layouts. This allows the client to purge its less-used objects whenever appropriate and so continue to have its subsequent requests given new resources freed up by object returns.",
      "ja": "サーバは、一般的に不十分なリソースが利用可能であるとき、リコール対象を否定するのは自由です。こうした政策の効果がリソースを最適に使用されない場合があります、その結果、要求されたものに比べて、既存のオブジェクトを優先するために、暗黙的であることに注意してください。これを防ぐために、サーバはよく彼らは多少、彼らは新しい代表団とレイアウトを与えることをやめた時にその下にCB_RECALL_ANYコールバックの送信を開始するポイントを作ることをお勧めします。これは、クライアントが適切な場合はいつでもそのあまり使用されているオブジェクトを削除し、そのオブジェクトを返しますによって解放された新しいリソース与えられたその後続の要求を持ち続けることができます。"
    },
    {
      "indent": 0,
      "text": "20.6.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.6.4. 実装"
    },
    {
      "indent": 3,
      "text": "The client can choose to return any type of object specified by the mask. If a server wishes to limit the use of objects of a specific type, it should only specify that type in the mask it sends. Should the client fail to return requested objects, it is up to the server to handle this situation, typically by sending specific recalls (i.e., sending CB_RECALL operations) to properly limit resource usage. The server should give the client enough time to return objects before proceeding to specific recalls. This time should not be less than the lease period.",
      "ja": "クライアントは、マスクで指定されたオブジェクトの任意の型を返すように選択することができます。サーバが特定の型のオブジェクトの使用を制限したい場合は、それだけで、それが送信マスクで、そのタイプを指定する必要があります。クライアントが要求されたオブジェクトを返すのに失敗すると、それは一般的に適切にリソースの使用を制限するために、具体的なリコール（すなわち、CB_RECALL操作を送信する）を送信することにより、この状況に対処するために、サーバー次第です。サーバーは、クライアントに特定のリコールに進む前に、オブジェクトを返すのに十分な時間を与える必要があります。この時間は、リース期間を下回ってはいけません。"
    },
    {
      "indent": 0,
      "text": "20.7. Operation 9: CB_RECALLABLE_OBJ_AVAIL - Signal Resources for Recallable Objects",
      "ja": "20.7. 操作9：CB_RECALLABLE_OBJ_AVAIL  - リコールオブジェクトのシグナル・リソース"
    },
    {
      "indent": 0,
      "text": "20.7.1. ARGUMENT",
      "section_title": true,
      "ja": "20.7.1. 引数"
    },
    {
      "indent": 3,
      "text": "typedef CB_RECALL_ANY4args CB_RECALLABLE_OBJ_AVAIL4args;",
      "ja": "CB_RECALL_ANY4args CB_RECALLABLE_OBJ_AVAIL4argsのtypedef。"
    },
    {
      "indent": 0,
      "text": "20.7.2. RESULT",
      "section_title": true,
      "ja": "20.7.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALLABLE_OBJ_AVAIL4res {\n        nfsstat4        croa_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.7.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.7.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "CB_RECALLABLE_OBJ_AVAIL is used by the server to signal the client that the server has resources to grant recallable objects that might previously have been denied by OPEN, WANT_DELEGATION, GET_DIR_DELEG, or LAYOUTGET.",
      "ja": "CB_RECALLABLE_OBJ_AVAILは、サーバーが以前にOPEN、WANT_DELEGATION、GET_DIR_DELEG、またはLAYOUTGETによって拒否された可能性がありますリコールオブジェクトを付与するためのリソースを持っていることをクライアントに通知するために、サーバによって使用されます。"
    },
    {
      "indent": 3,
      "text": "The argument craa_objects_to_keep means the total number of recallable objects of the types indicated in the argument type_mask that the server believes it can allow the client to have, including the number of such objects the client already has. A client that tries to acquire more recallable objects than the server informs it can have runs the risk of having objects recalled.",
      "ja": "引数craa_objects_to_keepは、サーバがクライアントがすでに持っているようなオブジェクトの数を含め、クライアントが持ってできるようにすることができます信じている引数type_maskに示されているタイプのリコールオブジェクトの合計数を意味します。サーバは、それが持つことができます知らせるよりも多くのリコールオブジェクトを取得しようとするクライアントは、オブジェクトがリコール持つことのリスクを実行します。"
    },
    {
      "indent": 3,
      "text": "The server is not obligated to reserve the difference between the number of the objects the client currently has and the value of craa_objects_to_keep, nor does delaying the reply to CB_RECALLABLE_OBJ_AVAIL prevent the server from using the resources of the recallable objects for another purpose. Indeed, if a client responds slowly to CB_RECALLABLE_OBJ_AVAIL, the server might interpret the client as having reduced capability to manage recallable objects, and so cancel or reduce any reservation it is maintaining on behalf of the client. Thus, if the client desires to acquire more recallable objects, it needs to reply quickly to CB_RECALLABLE_OBJ_AVAIL, and then send the appropriate operations to acquire recallable objects.",
      "ja": "サーバーは、クライアントが現在持っているオブジェクトの数とcraa_objects_to_keepの値の差を確保する義務を負いません、また別の目的のためにリコールオブジェクトのリソースを使用してからサーバーを防ぐCB_RECALLABLE_OBJ_AVAILに返信を遅らせるん。クライアントがCB_RECALLABLE_OBJ_AVAILにゆっくりと応答した場合確かに、サーバーは、リコールのオブジェクトを管理するための削減能力を有するように、クライアントを解釈するかもしれない、ので、それがクライアントの代わりに維持されている任意の予約をキャンセルまたは削減します。クライアントは、より多くのリコールのオブジェクトを取得することを希望する場合はこのように、それはCB_RECALLABLE_OBJ_AVAILに迅速に返信する必要があり、その後、リコールのオブジェクトを取得するために、適切なオペレーションを送信します。"
    },
    {
      "indent": 0,
      "text": "20.8. Operation 10: CB_RECALL_SLOT - Change Flow Control Limits",
      "section_title": true,
      "ja": "20.8. 操作10：CB_RECALL_SLOT  - 変更フロー制御の制限"
    },
    {
      "indent": 0,
      "text": "20.8.1. ARGUMENT",
      "section_title": true,
      "ja": "20.8.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALL_SLOT4args {\n        slotid4       rsa_target_highest_slotid;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.8.2. RESULT",
      "section_title": true,
      "ja": "20.8.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALL_SLOT4res {\n        nfsstat4   rsr_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.8.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.8.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The CB_RECALL_SLOT operation requests the client to return session slots, and if applicable, transport credits (e.g., RDMA credits for connections associated with the operations channel) of the session's fore channel. CB_RECALL_SLOT specifies rsa_target_highest_slotid, the value of the target highest slot ID the server wants for the session. The client MUST then progress toward reducing the session's highest slot ID to the target value.",
      "ja": "CB_RECALL_SLOT動作はセッション・スロットを返すようにクライアントに要求し、該当する場合、トランスポート・クレジット（例えば、動作チャネルに関連する接続のためのRDMAクレジット）セッションの前方チャネルの。 CB_RECALL_SLOTはrsa_target_highest_slotid、サーバはセッションのために望んでいる目標最高スロットIDの値を指定します。次に、クライアントは、目標値にセッションの最高のスロットIDの削減に向かって進行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the session has only non-RDMA connections associated with its operations channel, then the client need only wait for all outstanding requests with a slot ID > rsa_target_highest_slotid to complete, then send a single COMPOUND consisting of a single SEQUENCE operation, with the sa_highestslot field set to rsa_target_highest_slotid. If there are RDMA-based connections associated with operation channel, then the client needs to also send enough zero-length \"RDMA Send\" messages to take the total RDMA credit count to rsa_target_highest_slotid + 1 or below.",
      "ja": "セッションは、その業務のチャネルに関連付けられている唯一の非RDMA接続を持っている場合、クライアントは唯一のスロットIDを持つすべての未処理の要求を待つ必要が> rsa_target_highest_slotidが完了するまでに、その後、sa_highestslotフィールドで、単一のシーケンス動作からなる単一の化合物を送りますrsa_target_highest_slotidに設定します。動作チャネルに関連したRDMAベースの接続がある場合、クライアントは1以下+ rsa_target_highest_slotidする総RDMAクレジット・カウントを取るために十分な長さゼロ「のRDMA送信」メッセージを送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "20.8.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.8.4. 実装"
    },
    {
      "indent": 3,
      "text": "If the client fails to reduce highest slot it has on the fore channel to what the server requests, the server can force the issue by asserting flow control on the receive side of all connections bound to the fore channel, and then finish servicing all outstanding requests that are in slots greater than rsa_target_highest_slotid. Once that is done, the server can then open the flow control, and any time the client sends a new request on a slot greater than rsa_target_highest_slotid, the server can return NFS4ERR_BADSLOT.",
      "ja": "クライアントは、それがどのようなサーバー要求に前部チャネルであり、最高のスロットを減らすために失敗した場合、サーバーは前部チャネルにバインドされたすべての接続の受信側でフロー制御をアサートすることによって、問題を強制して、すべての未解決の要求にサービスを提供し終えることができますスロットにrsa_target_highest_slotidより大きいこと。それが完了すると、サーバは、フロー制御を開くことができ、かつ任意の時間は、クライアントがrsa_target_highest_slotidより大きいスロットに新しい要求を送信し、サーバーはNFS4ERR_BADSLOTを返すことができます。"
    },
    {
      "indent": 0,
      "text": "20.9. Operation 11: CB_SEQUENCE - Supply Backchannel Sequencing and Control",
      "ja": "20.9. 操作11：CB_SEQUENCE  - 供給バックチャネルシーケンシングおよびコントロール"
    },
    {
      "indent": 0,
      "text": "20.9.1. ARGUMENT",
      "section_title": true,
      "ja": "20.9.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct referring_call4 {\n        sequenceid4     rc_sequenceid;\n        slotid4         rc_slotid;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct referring_call_list4 {\n        sessionid4      rcl_sessionid;\n        referring_call4 rcl_referring_calls<>;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct CB_SEQUENCE4args {\n        sessionid4           csa_sessionid;\n        sequenceid4          csa_sequenceid;\n        slotid4              csa_slotid;\n        slotid4              csa_highest_slotid;\n        bool                 csa_cachethis;\n        referring_call_list4 csa_referring_call_lists<>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.9.2. RESULT",
      "section_title": true,
      "ja": "20.9.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_SEQUENCE4resok {\n        sessionid4         csr_sessionid;\n        sequenceid4        csr_sequenceid;\n        slotid4            csr_slotid;\n        slotid4            csr_highest_slotid;\n        slotid4            csr_target_highest_slotid;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "union CB_SEQUENCE4res switch (nfsstat4 csr_status) {\ncase NFS4_OK:\n        CB_SEQUENCE4resok   csr_resok4;\ndefault:\n        void;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.9.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.9.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The CB_SEQUENCE operation is used to manage operational accounting for the backchannel of the session on which a request is sent. The contents include the session ID to which this request belongs, the slot ID and sequence ID used by the server to implement session request control and exactly once semantics, and exchanged slot ID maxima that are used to adjust the size of the reply cache. In each CB_COMPOUND request, CB_SEQUENCE MUST appear once and MUST be the first operation. The error NFS4ERR_SEQUENCE_POS MUST be returned when CB_SEQUENCE is found in any position in a CB_COMPOUND beyond the first. If any other operation is in the first position of CB_COMPOUND, NFS4ERR_OP_NOT_IN_SESSION MUST be returned.",
      "ja": "CB_SEQUENCE操作は、リクエストが送信されているセッションのバックチャネルの運用の会計を管理するために使用されます。コンテンツは、セッション要求制御と正確セマンティクス後を実装するためにサーバによって使用される、このリクエストが属するセッションID、スロットIDとシーケンスIDを含み、応答キャッシュのサイズを調整するために使用されるスロットIDの最大値を交換しました。各CB_COMPOUND要求で、CB_SEQUENCE一度現れなければなりません、そして、最初の操作でなければなりません。 CB_SEQUENCEが最初超えてCB_COMPOUNDにおける任意の位置に発見された場合、エラーNFS4ERR_SEQUENCE_POSが返さなければなりません。他の動作はCB_COMPOUNDの第一の位置にある場合、NFS4ERR_OP_NOT_IN_SESSIONが返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "See Section 18.46.3 for a description of how slots are processed.",
      "ja": "スロットがどのように処理されるかの説明については、セクション18.46.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "If csa_cachethis is TRUE, then the server is requesting that the client cache the reply in the callback reply cache. The client MUST cache the reply (see Section 2.10.6.1.3).",
      "ja": "csa_cachethisがTRUEの場合、サーバーは、クライアントがコールバック応答キャッシュ内の応答をキャッシュすることを要求しています。クライアントは、応答（セクション2.10.6.1.3を参照）をキャッシュしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The csa_referring_call_lists array is the list of COMPOUND requests, identified by session ID, slot ID, and sequence ID. These are requests that the client previously sent to the server. These previous requests created state that some operation(s) in the same CB_COMPOUND as the csa_referring_call_lists are identifying. A session ID is included because leased state is tied to a client ID, and a client ID can have multiple sessions. See Section 2.10.6.3.",
      "ja": "csa_referring_call_listsアレイは、セッションID、スロットID、およびシーケンスIDによって同定された化合物の要求のリストです。これらは、クライアントが以前にサーバーに送信された要求されています。これらの以前の要求は、同じCB_COMPOUNDに何らかの操作（単数または複数）csa_referring_call_listsが識別される状態を作成しました。リース状態がクライアントIDに関連付けられているため、セッションIDが含まれており、クライアントのIDは、複数のセッションを持つことができます。セクション2.10.6.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "The value of the csa_sequenceid argument relative to the cached sequence ID on the slot falls into one of three cases.",
      "ja": "スロット上のキャッシュされたシーケンスIDに対してcsa_sequenceid引数の値は、3つの状況に陥ります。"
    },
    {
      "indent": 3,
      "text": "o If the difference between csa_sequenceid and the client's cached sequence ID at the slot ID is two (2) or more, or if csa_sequenceid is less than the cached sequence ID (accounting for wraparound of the unsigned sequence ID value), then the client MUST return NFS4ERR_SEQ_MISORDERED.",
      "ja": "OスロットIDでcsa_sequenceidとクライアントのキャッシュされたシーケンスIDとの間の差は、2つ（2）またはcsa_sequenceidは、キャッシュされたシーケンス番号よりも小さい場合、または（符号なしシーケンス番号値のラップアラウンドを占める）より、クライアントの必要があり場合NFS4ERR_SEQ_MISORDEREDを返します。"
    },
    {
      "indent": 3,
      "text": "o If csa_sequenceid and the cached sequence ID are the same, this is a retry, and the client returns the CB_COMPOUND request's cached reply.",
      "ja": "csa_sequenceidとキャッシュされたシーケンスIDが同じであれば、O、これは再試行され、そしてクライアントがCB_COMPOUND要求のキャッシュされた応答を返します。"
    },
    {
      "indent": 3,
      "text": "o If csa_sequenceid is one greater (accounting for wraparound) than the cached sequence ID, then this is a new request, and the slot's sequence ID is incremented. The operations subsequent to CB_SEQUENCE, if any, are processed. If there are no other operations, the only other effects are to cache the CB_SEQUENCE reply in the slot, maintain the session's activity, and when the server receives the CB_SEQUENCE reply, renew the lease of state related to the client ID.",
      "ja": "csa_sequenceidが1より大きい場合には、キャッシュされたシーケンス番号よりも、（ラップアラウンドを占める）O、これは新しい要求で、スロットのシーケンス番号がインクリメントされます。 CB_SEQUENCE以降の操作は、もしあれば、処理されます。他の操作がない場合、唯一の他の効果は、スロット内のCB_SEQUENCE応答をキャッシュセッションの活動を維持するためであり、サーバはCB_SEQUENCE応答を受信したときに、クライアントIDに関連した状態のリースを更新します。"
    },
    {
      "indent": 3,
      "text": "If the server reuses a slot ID and sequence ID for a completely different request, the client MAY treat the request as if it is a retry of what it has already executed. The client MAY however detect the server's illegal reuse and return NFS4ERR_SEQ_FALSE_RETRY.",
      "ja": "サーバーが完全に異なる要求のためのスロットIDとシーケンスIDを再利用する場合は、それがすでに実行されたものの再試行であるかのように、クライアントが要求を扱うかもしれ。クライアントは、しかし、サーバーの不正な再利用を検出し、NFS4ERR_SEQ_FALSE_RETRYが返されることがあります。"
    },
    {
      "indent": 3,
      "text": "If CB_SEQUENCE returns an error, then the state of the slot (sequence ID, cached reply) MUST NOT change. See Section 2.10.6.1.3 for the conditions when the error NFS4ERR_RETRY_UNCACHED_REP might be returned.",
      "ja": "CB_SEQUENCEがエラーを返す場合、スロット（シーケンスID、キャッシュされた応答）の状態は変化してはいけません。エラーNFS4ERR_RETRY_UNCACHED_REPが返されるかもしれない条件については、第2.10.6.1.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "The client returns two \"highest_slotid\" values: csr_highest_slotid and csr_target_highest_slotid. The former is the highest slot ID the client will accept in a future CB_SEQUENCE operation, and SHOULD NOT be less than the value of csa_highest_slotid (but see",
      "ja": "csr_highest_slotidとcsr_target_highest_slotid：クライアントは、二つの「highest_slotid」の値を返します。前者は、クライアントが将来CB_SEQUENCE操作で受け入れる、とcsa_highest_slotidの値を下回ってはいけません（ただし、参照最高のスロットIDです"
    },
    {
      "indent": 3,
      "text": "Section 2.10.6.1 for an exception). The latter is the highest slot ID the client would prefer the server use on a future CB_SEQUENCE operation.",
      "ja": "例外のセクション2.10.6.1）。後者は、クライアントが将来CB_SEQUENCE操作上のサーバーの使用を好むだろう最高のスロットIDです。"
    },
    {
      "indent": 0,
      "text": "20.10. Operation 12: CB_WANTS_CANCELLED - Cancel Pending Delegation Wants",
      "ja": "20.10. 操作12：CB_WANTS_CANCELLED  - キャンセル保留委任ウォンツ"
    },
    {
      "indent": 0,
      "text": "20.10.1. ARGUMENT",
      "section_title": true,
      "ja": "20.10.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct CB_WANTS_CANCELLED4args {\n        bool cwca_contended_wants_cancelled;\n        bool cwca_resourced_wants_cancelled;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.10.2. RESULT",
      "section_title": true,
      "ja": "20.10.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_WANTS_CANCELLED4res {\n        nfsstat4        cwcr_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.10.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.10.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The CB_WANTS_CANCELLED operation is used to notify the client that some or all of the wants it registered for recallable delegations and layouts have been cancelled.",
      "ja": "CB_WANTS_CANCELLED操作は、それがリコール代表団とレイアウトのために登録された欲求の一部または全部が取り消されたことをクライアントに通知するために使用されています。"
    },
    {
      "indent": 3,
      "text": "If cwca_contended_wants_cancelled is TRUE, this indicates that the server will not be pushing to the client any delegations that become available after contention passes.",
      "ja": "cwca_contended_wants_cancelledがTRUEの場合、これは、サーバがクライアントに競合が通過した後に利用可能になる任意の代表団をプッシュされないことを示します。"
    },
    {
      "indent": 3,
      "text": "If cwca_resourced_wants_cancelled is TRUE, this indicates that the server will not notify the client when there are resources on the server to grant delegations or layouts.",
      "ja": "cwca_resourced_wants_cancelledがTRUEの場合、これは代表団やレイアウトを付与するには、サーバー上のリソースがある場合、サーバーがクライアントに通知しないことを示しています。"
    },
    {
      "indent": 3,
      "text": "After receiving a CB_WANTS_CANCELLED operation, the client is free to attempt to acquire the delegations or layouts it was waiting for, and possibly re-register wants.",
      "ja": "CB_WANTS_CANCELLED操作を受け取った後、クライアントはそれを待っていた代表団やレイアウトを取得しようとして自由であり、おそらく再登録を望んでいます。"
    },
    {
      "indent": 0,
      "text": "20.10.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.10.4. 実装"
    },
    {
      "indent": 3,
      "text": "When a client has an OPEN, WANT_DELEGATION, or GET_DIR_DELEGATION request outstanding, when a CB_WANTS_CANCELLED is sent, the server may need to make clear to the client whether a promise to signal delegation availability happened before the CB_WANTS_CANCELLED and is thus covered by it, or after the CB_WANTS_CANCELLED in which case it was not covered by it. The server can make this distinction by putting the appropriate requests into the list of referring calls in the associated CB_SEQUENCE.",
      "ja": "クライアントがCB_WANTS_CANCELLEDが送信されるOPEN、WANT_DELEGATION、または優れたGET_DIR_DELEGATION要求を、持っている場合は、サーバーは約束は委任の可用性がCB_WANTS_CANCELLED前に起こったので、それで覆われている、または後の信号にするかどうかをクライアントに明確にする必要があるかもしれませんそれはそれでカバーされなかった場合にはCB_WANTS_CANCELLED。サーバーは、関連するCB_SEQUENCE中のコールを参照のリストに適切な要求を置くことによって、この区別を行うことができます。"
    },
    {
      "indent": 0,
      "text": "20.11. Operation 13: CB_NOTIFY_LOCK - Notify Client of Possible Lock Availability",
      "ja": "20.11. 操作13：CB_NOTIFY_LOCK  - 可能性のあるロック可用性の通知クライアント"
    },
    {
      "indent": 0,
      "text": "20.11.1. ARGUMENT",
      "section_title": true,
      "ja": "20.11.1. 引数"
    },
    {
      "indent": 3,
      "text": "struct CB_NOTIFY_LOCK4args {\n    nfs_fh4     cnla_fh;\n    lock_owner4 cnla_lock_owner;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.11.2. RESULT",
      "section_title": true,
      "ja": "20.11.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_NOTIFY_LOCK4res {\n        nfsstat4        cnlr_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.11.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.11.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The server can use this operation to indicate that a byte-range lock for the given file and lock-owner, previously requested by the client via an unsuccessful LOCK operation, might be available.",
      "ja": "サーバは、以前に失敗したLOCK操作を介して、クライアントから要求された指定したファイルおよびロック所有者のためのバイト範囲ロックは、利用可能であるかもしれないことを示すために、この操作を使用することができます。"
    },
    {
      "indent": 3,
      "text": "This callback is meant to be used by servers to help reduce the latency of blocking locks in the case where they recognize that a client that has been polling for a blocking byte-range lock may now be able to acquire the lock. If the server supports this callback for a given file, it MUST set the OPEN4_RESULT_MAY_NOTIFY_LOCK flag when responding to successful opens for that file. This does not commit the server to the use of CB_NOTIFY_LOCK, but the client may use this as a hint to decide how frequently to poll for locks derived from that open.",
      "ja": "このコールバックは、それらがブロッキングバイト範囲ロックのためにポーリングされているクライアントは、現在ロックを取得することがあり得ることを認識した場合にロックをブロックするの待ち時間を減らすために、サーバによって使用されることを意味しています。サーバーが指定されたファイルに対して、このコールバックをサポートしている場合は成功への対応は、そのファイルのために開いたとき、それはOPEN4_RESULT_MAY_NOTIFY_LOCKフラグを設定しなければなりません。これはCB_NOTIFY_LOCKの使用にサーバーをコミットしませんが、クライアントはそのオープン由来ロックをポーリングする頻度を決定するためのヒントとしてこれを使用することができます。"
    },
    {
      "indent": 3,
      "text": "If an OPEN operation results in an upgrade, in which the stateid returned has an \"other\" value matching that of a stateid already allocated, with a new \"seqid\" indicating a change in the lock being represented, then the value of the OPEN4_RESULT_MAY_NOTIFY_LOCK flag when responding to that new OPEN controls handling from that point going forward. When parallel OPENs are done on the same file and open-owner, the ordering of the \"seqid\" fields of the returned stateids (subject to wraparound) are to be used to select the controlling value of the OPEN4_RESULT_MAY_NOTIFY_LOCK flag.",
      "ja": "OPEN4_RESULT_MAY_NOTIFY_LOCKフラグのstateidが既にロックの変化を示す新しい「SEQID」と、割り当てられたstateidのものに一致する「その他」の値を有する戻されたアップグレード、でOPEN操作結果が表される場合、その値今後その時点から取り扱うことの新しいOPENのコントロールに応答するとき。並列のOPENsが同じファイルオープン所有者で行われている場合、返されるのstateids（回り込みによる）の「SEQID」フィールドの順序はOPEN4_RESULT_MAY_NOTIFY_LOCKフラグの制御値を選択するために使用されます。"
    },
    {
      "indent": 0,
      "text": "20.11.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.11.4. 実装"
    },
    {
      "indent": 3,
      "text": "The server MUST NOT grant the byte-range lock to the client unless and until it receives a LOCK operation from the client. Similarly, the client receiving this callback cannot assume that it now has the lock or that a subsequent LOCK operation for the lock will be successful.",
      "ja": "それは、クライアントからLOCK操作を受け付けないとまで、サーバーは、クライアントにバイト範囲ロックを付与してはなりません。同様に、このコールバックを受信するクライアントは、それが今のロックを持っているか、ロックのために、後続のLOCK操作が成功することを仮定することはできません。"
    },
    {
      "indent": 3,
      "text": "The server is not required to implement this callback, and even if it does, it is not required to use it in any particular case. Therefore, the client must still rely on polling for blocking locks, as described in Section 9.6.",
      "ja": "サーバーは、このコールバックを実装するために必要とされていない、そしてそれがない場合でも、いずれかの特定の場合には、それを使用する必要はありません。そのため、クライアントは、セクション9.6で説明したように、ロックを阻止するためのポーリングに依存しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Similarly, the client is not required to implement this callback, and even it does, is still free to ignore it. Therefore, the server MUST NOT assume that the client will act based on the callback.",
      "ja": "同様に、クライアントはこのコールバックを実装するために必要とされていない、とさえそれがない、まだそれを無視して自由です。そのため、サーバーは、クライアントがコールバックに基づいて行動すると仮定してはいけません。"
    },
    {
      "indent": 0,
      "text": "20.12. Operation 14: CB_NOTIFY_DEVICEID - Notify Client of Device ID Changes",
      "ja": "20.12. 操作14：CB_NOTIFY_DEVICEID  - デバイスIDの変更をクライアントに通知"
    },
    {
      "indent": 0,
      "text": "20.12.1. ARGUMENT",
      "section_title": true,
      "ja": "20.12.1. 引数"
    },
    {
      "indent": 3,
      "text": "/*\n * Device notification types.\n */\nenum notify_deviceid_type4 {\n        NOTIFY_DEVICEID4_CHANGE = 1,\n        NOTIFY_DEVICEID4_DELETE = 2\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* For NOTIFY4_DEVICEID4_DELETE */\nstruct notify_deviceid_delete4 {\n        layouttype4     ndd_layouttype;\n        deviceid4       ndd_deviceid;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "/* For NOTIFY4_DEVICEID4_CHANGE */\nstruct notify_deviceid_change4 {\n        layouttype4     ndc_layouttype;\n        deviceid4       ndc_deviceid;\n        bool            ndc_immediate;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct CB_NOTIFY_DEVICEID4args {\n        notify4 cnda_changes<>;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.12.2. RESULT",
      "section_title": true,
      "ja": "20.12.2. 結果"
    },
    {
      "indent": 3,
      "text": "struct CB_NOTIFY_DEVICEID4res {\n        nfsstat4        cndr_status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.12.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.12.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "The CB_NOTIFY_DEVICEID operation is used by the server to send notifications to clients about changes to pNFS device IDs. The registration of device ID notifications is optional and is done via GETDEVICEINFO. These notifications are sent over the backchannel once the original request has been processed on the server. The server will send an array of notifications, cnda_changes, as a list of pairs of bitmaps and values. See Section 3.3.7 for a description of how NFSv4.1 bitmaps work.",
      "ja": "CB_NOTIFY_DEVICEID操作はpNFSのデバイスIDの変更に関するクライアントに通知を送信するためにサーバーによって使用されます。デバイスIDの通知の登録は任意であり、GETDEVICEINFOを介して行われます。元の要求がサーバー上で処理された後、これらの通知は、バックチャネルを介して送信されます。サーバーは、ビットマップと値のペアのリストとして、通知、cnda_changesの配列を送信します。 NFSv4.1ビットマップがどのように動作するかの説明については、セクション3.3.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "As with CB_NOTIFY (Section 20.4.3), it is possible the server has more notifications than can fit in a CB_COMPOUND, thus requiring multiple CB_COMPOUNDs. Unlike CB_NOTIFY, serialization is not an issue because unlike directory entries, device IDs cannot be re-used after being deleted (Section 12.2.10).",
      "ja": "CB_NOTIFY（セクション20.4.3）と同様に、サーバーは、このように複数のCB_COMPOUNDsを必要とし、CB_COMPOUNDに合うことができるよりも多くの通知を持っている可能です。ディレクトリエントリとは異なり、デバイスID（セクション12.2.10）が削除された後に再使用することはできませんのでCB_NOTIFYとは異なり、シリアル化が問題ではありません。"
    },
    {
      "indent": 3,
      "text": "All device ID notifications contain a device ID and a layout type. The layout type is necessary because two different layout types can share the same device ID, and the common device ID can have completely different mappings for each layout type.",
      "ja": "すべてのデバイスIDの通知は、デバイスIDとレイアウトタイプが含まれています。二つの異なるレイアウトタイプが同じデバイスIDを共有することができ、かつ共通のデバイスIDは、各レイアウトタイプの完全に異なるマッピングを有することができるので、レイアウトタイプが必要です。"
    },
    {
      "indent": 3,
      "text": "The server will send the following notifications:",
      "ja": "サーバーは、次の通知を送信します。"
    },
    {
      "indent": 3,
      "text": "NOTIFY_DEVICEID4_CHANGE A previously provided device-ID-to-device-address mapping has changed and the client uses GETDEVICEINFO to obtain the updated mapping. The notification is encoded in a value of data type notify_deviceid_change4. This data type also contains a boolean field, ndc_immediate, which if TRUE indicates that the change will be enforced immediately, and so the client might not be able to complete any pending I/O to the device ID. If ndc_immediate is FALSE, then for an indefinite time, the client can complete pending I/O. After pending I/O is complete, the client SHOULD get the new device-ID-to-device-address mappings before sending new I/O requests to the storage devices addressed by the device ID.",
      "ja": "NOTIFY_DEVICEID4_CHANGE A以前に提供され、デバイスIDとデバイスアドレスのマッピングが変更され、クライアントが更新されたマッピングを取得するためにGETDEVICEINFOを使用しています。通知は、データ型notify_deviceid_change4の値で符号化されます。このデータ型はまた、TRUE、変更がすぐに施行されることを示し、そのため、クライアントは、デバイスIDに保留中のI / Oを完了することができない可能性がある場合、ブールフィールド、ndc_immediateが、含まれています。 ndc_immediateがFALSEの場合は、無期限のため、クライアントは、保留中のI / Oを完了することができます。 I / Oが完了し、保留した後、クライアントは、デバイスIDによってアドレス・ストレージ・デバイスに新しいI / O要求を送信する前に、新しいデバイスIDとデバイス・アドレスのマッピングを取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "NOTIFY4_DEVICEID_DELETE Deletes a device ID from the mappings. This notification MUST NOT be sent if the client has a layout that refers to the device ID. In other words, if the server is sending a delete device ID notification, one of the following is true for layouts associated with the layout type:",
      "ja": "NOTIFY4_DEVICEID_DELETEは、マッピングからデバイスIDを削除します。クライアントがデバイスIDを参照するレイアウトを持っている場合は、この通知は送ってはいけません。換言すれば、サーバは、削除デバイスIDの通知を送信している場合は、次のいずれかは、レイアウトタイプに関連付けられたレイアウトについても同様です。"
    },
    {
      "indent": 6,
      "text": "* The client never had a layout referring to that device ID.",
      "ja": "*クライアントは、そのデバイスIDを参照するレイアウトを持っていませんでした。"
    },
    {
      "indent": 6,
      "text": "* The client has returned all layouts referring to that device ID.",
      "ja": "*クライアントは、そのデバイスIDを参照するすべてのレイアウトを返しました。"
    },
    {
      "indent": 6,
      "text": "* The server has revoked all layouts referring to that device ID.",
      "ja": "*サーバは、そのデバイスIDを参照するすべてのレイアウトを取り消しました。"
    },
    {
      "indent": 6,
      "text": "The notification is encoded in a value of data type notify_deviceid_delete4. After a server deletes a device ID, it MUST NOT reuse that device ID for the same layout type until the client ID is deleted.",
      "ja": "通知は、データ型notify_deviceid_delete4の値で符号化されます。サーバは、デバイスIDを削除した後、クライアントのIDが削除されるまで、それは同じレイアウトのタイプについて、そのデバイスIDを再利用してはいけません。"
    },
    {
      "indent": 0,
      "text": "20.13. Operation 10044: CB_ILLEGAL - Illegal Callback Operation",
      "section_title": true,
      "ja": "20.13. オペレーション10044：CB_ILLEGAL  - 不正なコールバックの操作"
    },
    {
      "indent": 0,
      "text": "20.13.1. ARGUMENT",
      "section_title": true,
      "ja": "20.13.1. 引数"
    },
    {
      "indent": 11,
      "text": "void;",
      "ja": "無効;"
    },
    {
      "indent": 0,
      "text": "20.13.2. RESULT",
      "section_title": true,
      "ja": "20.13.2. 結果"
    },
    {
      "indent": 3,
      "text": "/*\n * CB_ILLEGAL: Response for illegal operation numbers\n */\nstruct CB_ILLEGAL4res {\n        nfsstat4        status;\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "20.13.3. DESCRIPTION",
      "section_title": true,
      "ja": "20.13.3.  DESCRIPTION"
    },
    {
      "indent": 3,
      "text": "This operation is a placeholder for encoding a result to handle the case of the server sending an operation code within CB_COMPOUND that is not defined in the NFSv4.1 specification. See Section 19.2.3 for more details.",
      "ja": "この操作はNFSv4.1仕様で定義されていないCB_COMPOUND内のオペレーションコードを送信するサーバの場合を処理するために結果を符号化するためのプレースホルダです。詳細は、19.2.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The status field of CB_ILLEGAL4res MUST be set to NFS4ERR_OP_ILLEGAL.",
      "ja": "CB_ILLEGAL4resのステータスフィールドはNFS4ERR_OP_ILLEGALに設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "20.13.4. IMPLEMENTATION",
      "section_title": true,
      "ja": "20.13.4. 実装"
    },
    {
      "indent": 3,
      "text": "A server will probably not send an operation with code OP_CB_ILLEGAL, but if it does, the response will be CB_ILLEGAL4res just as it would be with any other invalid operation code. Note that if the client gets an illegal operation code that is not OP_ILLEGAL, and if the client checks for legal operation codes during the XDR decode phase, then an instance of data type CB_ILLEGAL4res will not be returned.",
      "ja": "サーバーは、おそらくコードOP_CB_ILLEGALで操作を送信しませんが、それがない場合、応答は、それが他の不正なオペレーションコードを持つことと同じようにCB_ILLEGAL4resになります。クライアントがOP_ILLEGALない不正な操作コードを取得した場合には注意、およびXDRデコード段階の間法的操作コードのクライアントチェックは、データ型CB_ILLEGAL4resのインスタンスが返されない場合。"
    },
    {
      "indent": 0,
      "text": "21. Security Considerations",
      "section_title": true,
      "ja": "21.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Historically, the authentication model of NFS was based on the entire machine being the NFS client, with the NFS server trusting the NFS client to authenticate the end-user. The NFS server in turn shared its files only to specific clients, as identified by the client's source network address. Given this model, the AUTH_SYS RPC security flavor simply identified the end-user using the client to the NFS server. When processing NFS responses, the client ensured that the responses came from the same network address and port number to which the request was sent. While such a model is easy to implement and simple to deploy and use, it is unsafe. Thus, NFSv4.1 implementations are REQUIRED to support a security model that uses end-to-end authentication, where an end-user on a client mutually authenticates (via cryptographic schemes that do not expose passwords or keys in the clear on the network) to a principal on an NFS server. Consideration is also given to the integrity and privacy of NFS requests and responses. The issues of end-to-end mutual authentication, integrity, and privacy are discussed in Section 2.2.1.1.1. There are specific considerations when using Kerberos V5 as described in Section 2.2.1.1.1.2.1.1.",
      "ja": "歴史的に、NFSの認証モデルは、全体のマシンがNFSサーバは、エンドユーザを認証するためにNFSクライアントを信頼して、NFSクライアントであることに基づいていました。クライアントのソースネットワークアドレスによって識別されるように順番にNFSサーバは、特定のクライアントだけにそのファイルを共有しました。このモデルを考えると、AUTH_SYS RPCセキュリティ風味は、単純にNFSサーバーにクライアントを使用して、エンドユーザを特定しました。 NFS応答を処理する場合、クライアントは応答が、要求が送信されたと同じネットワークアドレスとポート番号から来たことを確実にしました。このようなモデルを展開し、使用するために実装するのは簡単でシンプルですが、それは安全ではありません。このように、NFSv4.1実装は（ネットワーク上で平文でパスワードやキーを公開していない暗号方式を経由して）クライアント上のエンドユーザーが相互に認証し、エンドツーエンドの認証を使用するセキュリティモデルを、サポートする必要がありますNFSサーバー上の元本へ。検討は、NFS要求と応答の整合性とプライバシーに与えられています。エンド・ツー・エンドの相互認証、整合性、およびプライバシーの問題は、セクション2.2.1.1.1で説明されています。第2.2.1.1.1.2.1.1で説明したようにKerberos V5を使用して、特定の考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "Note that being REQUIRED to implement does not mean REQUIRED to use; AUTH_SYS can be used by NFSv4.1 clients and servers. However, AUTH_SYS is merely an OPTIONAL security flavor in NFSv4.1, and so interoperability via AUTH_SYS is not assured.",
      "ja": "使用するために必要なことを意味しない実装するために必要とされていることに注意してください。 AUTH_SYSはNFSv4.1のクライアントとサーバで使用することができます。しかし、AUTH_SYSはNFSv4.1で、単にオプションのセキュリティ風味などAUTH_SYSを経由して相互運用性が保証されていないです。"
    },
    {
      "indent": 3,
      "text": "For reasons of reduced administration overhead, better performance, and/or reduction of CPU utilization, users of NFSv4.1 implementations might decline to use security mechanisms that enable integrity protection on each remote procedure call and response. The use of mechanisms without integrity leaves the user vulnerable to a man-in-the-middle of the NFS client and server that modifies the RPC request and/or the response. While implementations are free to provide the option to use weaker security mechanisms, there are three operations in particular that warrant the implementation overriding user choices.",
      "ja": "削減管理オーバーヘッド、より良い性能、および/またはCPU使用率の削減の理由から、NFSv4.1実装のユーザーは、各リモート・プロシージャ・コールとレスポンスの完全性保護を可能にするセキュリティ・メカニズムを使用することを拒否することがあります。整合性のないメカニズムを使用すると、RPC要求および/または応答を変更するNFSクライアントとサーバののman-in-the-middleに対して脆弱ユーザーを残します。実装が弱いセキュリティメカニズムを使用するためのオプションを提供するために自由ですが、ユーザーの選択をオーバーライド実装を保証し、特に3つの操作があります。"
    },
    {
      "indent": 3,
      "text": "o The first two such operations are SECINFO and SECINFO_NO_NAME. It is RECOMMENDED that the client send both operations such that they are protected with a security flavor that has integrity protection, such as RPCSEC_GSS with either the rpc_gss_svc_integrity or rpc_gss_svc_privacy service. Without integrity protection encapsulating SECINFO and SECINFO_NO_NAME and their results, a man-in-the-middle could modify results such that the client might select a weaker algorithm in the set allowed by the server, making the client and/or server vulnerable to further attacks.",
      "ja": "最初の二つのこのような動作oをSECINFOとSECINFO_NO_NAMEあります。クライアントは、彼らがそのようなrpc_gss_svc_integrityやrpc_gss_svc_privacyサービスのいずれかでRPCSEC_GSSとして完全性保護を、持っているセキュリティ風味で保護されているように、両方の操作を送ることが推奨されます。 SECINFOとSECINFO_NO_NAMEとその結果をカプセル化する完全性保護がなければ、のman-in-the-middleは、さらなる攻撃へのクライアントおよび/またはサーバが脆弱作り、クライアントがサーバーによって許可されたセットの中の弱いアルゴリズムを選択するかもしれないというような結果を修正することができます。"
    },
    {
      "indent": 3,
      "text": "o The third operation that SHOULD use integrity protection is any GETATTR for the fs_locations and fs_locations_info attributes, in order to mitigate the severity of a man-in-the-middle attack. The attack has two steps. First the attacker modifies the unprotected results of some operation to return NFS4ERR_MOVED. Second, when the client follows up with a GETATTR for the fs_locations or fs_locations_info attributes, the attacker modifies the results to cause the client to migrate its traffic to a server controlled by the attacker. With integrity protection, this attack is mitigated.",
      "ja": "oを完全性保護を使用すべきである第3の動作は、man-in-the-middle攻撃の重症度を軽減するために、fs_位置とfs_locations_info属性のいずれかのGETATTRです。攻撃は、2つのステップがあります。まず、攻撃者はNFS4ERR_MOVEDを返すために、いくつかの操作の保護されていない結果を変更します。クライアントはfs_位置やfs_locations_info属性のGETATTRに追従したときに第二に、攻撃者は、クライアントが攻撃者によって制御されるサーバーへのトラフィックを移行させる結果を変更します。完全性保護では、この攻撃が軽減されます。"
    },
    {
      "indent": 3,
      "text": "Relative to previous NFS versions, NFSv4.1 has additional security considerations for pNFS (see Sections 12.9 and 13.12), locking and session state (see Section 2.10.8.3), and state recovery during grace period (see Section 8.4.2.1.1). With respect to locking and session state, if SP4_SSV state protection is being used, Section 2.10.10 has specific security considerations for the NFSv4.1 client and server.",
      "ja": "以前のNFSバージョンと比較して、NFSv4.1は、追加のセキュリティpNFSのための考慮事項（セクション12.9と13.12を参照）、ロックおよびセッションの状態（セクション2.10.8.3を参照）、および猶予期間中の状態の回復を持っている（セクション8.4.2.1.1を参照してください） 。 SP4_SSV状態の保護が使用されている場合、ロックおよびセッションの状態に関しては、セクション2.10.10はNFSv4.1のクライアントとサーバーの特定のセキュリティ上の考慮事項があります。"
    },
    {
      "indent": 0,
      "text": "22. IANA Considerations",
      "section_title": true,
      "ja": "22. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section uses terms that are defined in [55].",
      "ja": "このセクションでは、[55]で定義される用語を使用します。"
    },
    {
      "indent": 0,
      "text": "22.1. Named Attribute Definitions",
      "section_title": true,
      "ja": "22.1. 名前の属性の定義"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"NFSv4 Named Attribute Definitions Registry\".",
      "ja": "IANAは、レジストリは「NFSv4の名前の属性の定義レジストリ」と呼ばれる作成しました。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 protocol supports the association of a file with zero or more named attributes. The namespace identifiers for these attributes are defined as string names. The protocol does not define the specific assignment of the namespace for these file attributes. The IANA registry promotes interoperability where common interests exist. While application developers are allowed to define and use attributes as needed, they are encouraged to register the attributes with IANA.",
      "ja": "NFSv4.1プロトコルは、ゼロ以上の名前付き属性を持つファイルの関連付けをサポートしています。これらの属性の名前空間識別子は、文字列名として定義されています。プロトコルは、これらのファイル属性の名前空間の特定の割り当てを定義していません。 IANAレジストリは共通の利益が存在し、相互運用性を促進します。アプリケーション開発者は、必要に応じて属性を定義して使用することを許可されているが、それらは、IANAで属性を登録することが奨励されています。"
    },
    {
      "indent": 3,
      "text": "Such registered named attributes are presumed to apply to all minor versions of NFSv4, including those defined subsequently to the registration. If the named attribute is intended to be limited to specific minor versions, this will be clearly stated in the registry's assignment.",
      "ja": "このような登録された名前の属性が登録に続いて定義されているものを含めNFSv4のすべてのマイナーバージョンに適用すると推定されています。名前の属性が特定のマイナーバージョンに限定されるものである場合、これは明らかに、レジストリの割り当てに記載されます。"
    },
    {
      "indent": 3,
      "text": "All assignments to the registry are made on a First Come First Served basis, per Section 4.1 of [55]. The policy for each assignment is Specification Required, per Section 4.1 of [55].",
      "ja": "レジストリへのすべての割り当ては、[55]のセクション4.1あたりに、最初に来まず添え基づいて作られています。各割り当てのポリシーは、[55]のセクション4.1当たり、仕様が必要です。"
    },
    {
      "indent": 3,
      "text": "Under the NFSv4.1 specification, the name of a named attribute can in theory be up to 2^32 - 1 bytes in length, but in practice NFSv4.1 clients and servers will be unable to handle a string that long. IANA should reject any assignment request with a named attribute that exceeds 128 UTF-8 characters. To give the IESG the flexibility to set up bases of assignment of Experimental Use and Standards Action, the prefixes of \"EXPE\" and \"STDS\" are Reserved. The named attribute with a zero-length name is Reserved.",
      "ja": "長さは1バイトで、実際にはNFSv4.1のクライアントとサーバは、長いその文字列を処理することができません -  NFSv4.1仕様の下では、指定された属性の名前は、理論的には、最大2 ^ 32することができます。 IANAは128 UTF-8文字を超える名前の属性を持つ任意の割り当て要求を拒否しなければなりません。 IESGに実験的使用と標準アクションの割り当ての拠点を設置するための柔軟性を与えるために、「EXPE」と「性感染症」のプレフィックスが予約されています。ゼロ長の名を持つという名前の属性が予約されています。"
    },
    {
      "indent": 3,
      "text": "The prefix \"PRIV\" is designated for Private Use. A site that wants to make use of unregistered named attributes without risk of conflicting with an assignment in IANA's registry should use the prefix \"PRIV\" in all of its named attributes.",
      "ja": "接頭辞「PRIVは、」私的使用のために指定されています。 IANAのレジストリに割り当てと競合する危険なしに未登録の名前の属性を使用するように望んでいるサイトでは、その名前の属性すべてに接頭辞「PRIV」を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Because some NFSv4.1 clients and servers have case-insensitive semantics, the fifteen additional lower case and mixed case permutations of each of \"EXPE\", \"PRIV\", and \"STDS\" are Reserved (e.g., \"expe\", \"expE\", \"exPe\", etc. are Reserved). Similarly, IANA must not allow two assignments that would conflict if both named attributes were converted to a common case.",
      "ja": "いくつかのNFSv4.1のクライアントとサーバは、大文字と小文字を区別しない意味を持っているので、「EXPE」、「PRIV」、および「性感染症」のそれぞれの15個の追加の小文字と大文字と小文字の順列が予約されている（例えば、「EXPE」、「EXPE」 、 \"EXPE\" など）が予約されています。同様に、IANAは、両方の名前の属性が一般的なケースに変換された場合に競合する2つの割り当てを許可してはいけません。"
    },
    {
      "indent": 3,
      "text": "The registry of named attributes is a list of assignments, each containing three fields for each assignment.",
      "ja": "名前の属性のレジストリは、各割り当てについて、各含む3つのフィールド割り当てのリストです。"
    },
    {
      "indent": 3,
      "text": "1. A US-ASCII string name that is the actual name of the attribute. This name must be unique. This string name can be 1 to 128 UTF-8 characters long.",
      "ja": "属性の実際の名前です。1. A US-ASCII文字列名。この名前は一意である必要があります。この文字列名は1〜128 UTF-8文字の長さにすることができます。"
    },
    {
      "indent": 3,
      "text": "2. A reference to the specification of the named attribute. The reference can consume up to 256 bytes (or more if IANA permits).",
      "ja": "2.指定された属性の仕様を参照します。 （IANAが許可されている場合、またはそれ以上）の参照は、256のバイトまで消費することができます。"
    },
    {
      "indent": 3,
      "text": "3. The point of contact of the registrant. The point of contact can consume up to 256 bytes (or more if IANA permits).",
      "ja": "3.登録者の接触点。 （IANAが許可されている場合、またはそれ以上）の接触点は、256のバイトまで消費することができます。"
    },
    {
      "indent": 0,
      "text": "22.1.1. Initial Registry",
      "section_title": true,
      "ja": "22.1.1. 初期のレジストリ"
    },
    {
      "indent": 3,
      "text": "There is no initial registry.",
      "ja": "何の初期のレジストリはありません。"
    },
    {
      "indent": 0,
      "text": "22.1.2. Updating Registrations",
      "section_title": true,
      "ja": "22.1.2. 登録の更新"
    },
    {
      "indent": 3,
      "text": "The registrant is always permitted to update the point of contact field. Any other change will require Expert Review or IESG Approval.",
      "ja": "登録者は、常に連絡先フィールドのポイントを更新することが許可されています。その他の変更は、専門家のレビューやIESGの承認が必要になります。"
    },
    {
      "indent": 0,
      "text": "22.2. Device ID Notifications",
      "section_title": true,
      "ja": "22.2. デバイスIDの通知"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"NFSv4 Device ID Notifications Registry\".",
      "ja": "IANAは、「NFSv4のデバイスIDの通知レジストリ」と呼ばれるレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "The potential exists for new notification types to be added to the CB_NOTIFY_DEVICEID operation (see Section 20.12). This can be done via changes to the operations that register notifications, or by adding new operations to NFSv4. This requires a new minor version of NFSv4, and requires a Standards Track document from the IETF. Another way to add a notification is to specify a new layout type (see Section 22.4).",
      "ja": "電位（セクション20.12を参照）CB_NOTIFY_DEVICEID動作に追加される新たな通知タイプが存在します。これは、またはのNFSv4に新しい操作を追加することにより、通知を登録する操作への変更を介して行うことができます。これは、NFSv4のの新しいマイナーバージョンを必要とし、IETFから標準化過程ドキュメントが必要です。通知を追加する別の方法は、（項22.4を参照してください）新しいレイアウトタイプを指定することです。"
    },
    {
      "indent": 3,
      "text": "Hence, all assignments to the registry are made on a Standards Action basis per Section 4.1 of [55], with Expert Review required.",
      "ja": "このため、レジストリへのすべての割り当ては、[55]のセクション4.1あたりの標準化アクションに基づいて行われ、専門家レビューでは必要。"
    },
    {
      "indent": 3,
      "text": "The registry is a list of assignments, each containing five fields per assignment.",
      "ja": "レジストリは、各割り当てごとに5つのフィールドを含む、割り当てのリストです。"
    },
    {
      "indent": 3,
      "text": "1. The name of the notification type. This name must have the prefix \"NOTIFY_DEVICEID4_\". This name must be unique.",
      "ja": "1.通知型の名前。この名前は、接頭辞「NOTIFY_DEVICEID4_」を持っている必要があります。この名前は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The value of the notification. IANA will assign this number, and the request from the registrant will use TBD1 instead of an actual value. IANA MUST use a whole number that can be no higher than 2^32-1, and should be the next available value. The value assigned must be unique. A Designated Expert must be used to ensure that when the name of the notification type and its value are added to the NFSv4.1 notify_deviceid_type4 enumerated data type in the NFSv4.1 XDR description ([13]), the result continues to be a valid XDR description.",
      "ja": "通知の値2。 IANAは、この番号を割り当てし、登録者からの要求は、実際の値の代わりにTBD1を使用します。 IANAは2 ^ 32-1よりも高くなることはできません全体の番号を使用する必要があり、そして次の使用可能な値である必要があります。割り当てられた値は一意である必要があります。指定された専門家は、通知タイプとその値の名前がNFSv4.1 XDR記述（[13]）に列挙データ型notify_deviceid_type4 NFSv4.1に追加された場合、結果が有効であり続けることを保証するために使用されなければなりませんXDRの説明。"
    },
    {
      "indent": 3,
      "text": "3. The Standards Track RFC(s) that describe the notification. If the RFC(s) have not yet been published, the registrant will use RFCTBD2, RFCTBD3, etc. instead of an actual RFC number.",
      "ja": "3.通知を記述する標準化過程RFC（複数可）。 RFC（s）はまだ公開されていない場合は、登録者ではなく、実際のRFC番号のなどRFCTBD2、RFCTBD3を使用します。"
    },
    {
      "indent": 3,
      "text": "4. How the RFC introduces the notification. This is indicated by a single US-ASCII value. If the value is N, it means a minor revision to the NFSv4 protocol. If the value is L, it means a new pNFS layout type. Other values can be used with IESG Approval.",
      "ja": "RFCが通知を紹介する方法4。これは、単一のUS-ASCII値で示されています。値がNである場合には、NFSv4のプロトコルにマイナーリビジョンを意味します。値がLであれば、それは新しいpNFSのレイアウトタイプを意味します。他の値はIESGの承認を得て使用することができます。"
    },
    {
      "indent": 3,
      "text": "5. The minor versions of NFSv4 that are allowed to use the notification. While these are numeric values, IANA will not allocate and assign them; the author of the relevant RFCs with IESG Approval assigns these numbers. Each time there is a new minor version of NFSv4 approved, a Designated Expert should review the registry to make recommended updates as needed.",
      "ja": "5.通知を使用することが許可されているのNFSv4のマイナーバージョン。これらは数値ですが、IANAは、それらを割り当て、割り当てられません。 IESGの承認を得て、関連するRFCの著者は、これらの番号を割り当てます。 NFSv4の承認の新しいマイナーバージョンがあるたびに、指定Expertは、必要に応じて推奨される更新を行うために、レジストリを確認してください。"
    },
    {
      "indent": 0,
      "text": "22.2.1. Initial Registry",
      "section_title": true,
      "ja": "22.2.1. 初期のレジストリ"
    },
    {
      "indent": 3,
      "text": "The initial registry is in Table 16. Note that the next available value is zero.",
      "ja": "最初のレジストリは、次の使用可能な値がゼロであることを表16注意です。"
    },
    {
      "indent": 3,
      "text": "+-------------------------+-------+---------+-----+----------------+\n| Notification Name       | Value | RFC     | How | Minor Versions |\n+-------------------------+-------+---------+-----+----------------+\n| NOTIFY_DEVICEID4_CHANGE | 1     | RFC5661 | N   | 1              |\n| NOTIFY_DEVICEID4_DELETE | 2     | RFC5661 | N   | 1              |\n+-------------------------+-------+---------+-----+----------------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Table 16: Initial Device ID Notification Assignments",
      "ja": "表16：初期デバイスIDの通知の割り当て"
    },
    {
      "indent": 0,
      "text": "22.2.2. Updating Registrations",
      "section_title": true,
      "ja": "22.2.2. 登録の更新"
    },
    {
      "indent": 3,
      "text": "The update of a registration will require IESG Approval on the advice of a Designated Expert.",
      "ja": "登録の更新は、指定専門家のアドバイスにIESGの承認が必要になります。"
    },
    {
      "indent": 0,
      "text": "22.3. Object Recall Types",
      "section_title": true,
      "ja": "22.3. オブジェクトリコールタイプ"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"NFSv4 Recallable Object Types Registry\".",
      "ja": "IANAは「NFSv4のリコールオブジェクトの種類レジストリ」と呼ばれるレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "The potential exists for new object types to be added to the CB_RECALL_ANY operation (see Section 20.6). This can be done via changes to the operations that add recallable types, or by adding new operations to NFSv4. This requires a new minor version of NFSv4, and requires a Standards Track document from IETF. Another way to add a new recallable object is to specify a new layout type (see Section 22.4).",
      "ja": "新しいオブジェクトタイプがCB_RECALL_ANY動作に追加するための電位が存在する（セクション20.6を参照）。これは、リコールの種類を追加操作への変更を経由して、またはのNFSv4に新しい操作を追加することによって行うことができます。これは、NFSv4のの新しいマイナーバージョンを必要とし、IETFから標準化過程ドキュメントが必要です。新しいリコールオブジェクトを追加するもう1つの方法は、（項22.4を参照してください）新しいレイアウトタイプを指定することです。"
    },
    {
      "indent": 3,
      "text": "All assignments to the registry are made on a Standards Action basis per Section 4.1 of [55], with Expert Review required.",
      "ja": "専門家レビューが必要で、レジストリへのすべての割り当ては、[55]のセクション4.1あたりの標準化アクションに基づいて行われています。"
    },
    {
      "indent": 3,
      "text": "Recallable object types are 32-bit unsigned numbers. There are no Reserved values. Values in the range 12 through 15, inclusive, are designated for Private Use.",
      "ja": "リコールオブジェクトタイプは、32ビットの符号なしの数です。何の予約値はありません。範囲12〜15の値は、包括的、私的使用のために指定されています。"
    },
    {
      "indent": 3,
      "text": "The registry is a list of assignments, each containing five fields per assignment.",
      "ja": "レジストリは、各割り当てごとに5つのフィールドを含む、割り当てのリストです。"
    },
    {
      "indent": 3,
      "text": "1. The name of the recallable object type. This name must have the prefix \"RCA4_TYPE_MASK_\". The name must be unique.",
      "ja": "リコールオブジェクト型の1名。この名前は、接頭辞「RCA4_TYPE_MASK_」を持っている必要があります。名前は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The value of the recallable object type. IANA will assign this number, and the request from the registrant will use TBD1 instead of an actual value. IANA MUST use a whole number that can be no higher than 2^32-1, and should be the next available value. The value must be unique. A Designated Expert must be used to ensure that when the name of the recallable type and its value are added to the NFSv4 XDR description [13], the result continues to be a valid XDR description.",
      "ja": "リコールオブジェクトタイプの値2。 IANAは、この番号を割り当てし、登録者からの要求は、実際の値の代わりにTBD1を使用します。 IANAは2 ^ 32-1よりも高くなることはできません全体の番号を使用する必要があり、そして次の使用可能な値である必要があります。値は一意である必要があります。指定された専門家は、リコールのタイプの名前とその値はNFSv4のXDR記述[13]に追加された場合、結果が有効XDR記述であり続けることを保証するために使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. The Standards Track RFC(s) that describe the recallable object type. If the RFC(s) have not yet been published, the registrant will use RFCTBD2, RFCTBD3, etc. instead of an actual RFC number.",
      "ja": "3.リコールオブジェクトタイプを記述する標準化過程RFC（S）。 RFC（s）はまだ公開されていない場合は、登録者ではなく、実際のRFC番号のなどRFCTBD2、RFCTBD3を使用します。"
    },
    {
      "indent": 3,
      "text": "4. How the RFC introduces the recallable object type. This is indicated by a single US-ASCII value. If the value is N, it means a minor revision to the NFSv4 protocol. If the value is L, it means a new pNFS layout type. Other values can be used with IESG Approval.",
      "ja": "RFCは、リコール対象の種類を紹介しますどのように4。これは、単一のUS-ASCII値で示されています。値がNである場合には、NFSv4のプロトコルにマイナーリビジョンを意味します。値がLであれば、それは新しいpNFSのレイアウトタイプを意味します。他の値はIESGの承認を得て使用することができます。"
    },
    {
      "indent": 3,
      "text": "5. The minor versions of NFSv4 that are allowed to use the recallable object type. While these are numeric values, IANA will not allocate and assign them; the author of the relevant RFCs with IESG Approval assigns these numbers. Each time there is a new minor version of NFSv4 approved, a Designated Expert should review the registry to make recommended updates as needed.",
      "ja": "5.リコールオブジェクト型を使用することを許可されているのNFSv4のマイナーバージョン。これらは数値ですが、IANAは、それらを割り当て、割り当てられません。 IESGの承認を得て、関連するRFCの著者は、これらの番号を割り当てます。 NFSv4の承認の新しいマイナーバージョンがあるたびに、指定Expertは、必要に応じて推奨される更新を行うために、レジストリを確認してください。"
    },
    {
      "indent": 0,
      "text": "22.3.1. Initial Registry",
      "section_title": true,
      "ja": "22.3.1. 初期のレジストリ"
    },
    {
      "indent": 3,
      "text": "The initial registry is in Table 17. Note that the next available value is five.",
      "ja": "最初のレジストリは、次の使用可能な値は5です。表17.ノートです。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------+-------+--------+-----+------------+\n| Recallable Object Type Name   | Value | RFC    | How | Minor      |\n|                               |       |        |     | Versions   |\n+-------------------------------+-------+--------+-----+------------+\n| RCA4_TYPE_MASK_RDATA_DLG      | 0     | RFC    | N   | 1          |\n|                               |       | 5661   |     |            |\n| RCA4_TYPE_MASK_WDATA_DLG      | 1     | RFC    | N   | 1          |\n|                               |       | 5661   |     |            |\n| RCA4_TYPE_MASK_DIR_DLG        | 2     | RFC    | N   | 1          |\n|                               |       | 5661   |     |            |\n| RCA4_TYPE_MASK_FILE_LAYOUT    | 3     | RFC    | N   | 1          |\n|                               |       | 5661   |     |            |\n| RCA4_TYPE_MASK_BLK_LAYOUT     | 4     | RFC    | L   | 1          |\n|                               |       | 5661   |     |            |\n| RCA4_TYPE_MASK_OBJ_LAYOUT_MIN | 8     | RFC    | L   | 1          |\n|                               |       | 5661   |     |            |\n| RCA4_TYPE_MASK_OBJ_LAYOUT_MAX | 9     | RFC    | L   | 1          |\n|                               |       | 5661   |     |            |\n+-------------------------------+-------+--------+-----+------------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Table 17: Initial Recallable Object Type Assignments",
      "ja": "表17：初期リコールオブジェクトタイプの割り当て"
    },
    {
      "indent": 0,
      "text": "22.3.2. Updating Registrations",
      "section_title": true,
      "ja": "22.3.2. 登録の更新"
    },
    {
      "indent": 3,
      "text": "The update of a registration will require IESG Approval on the advice of a Designated Expert.",
      "ja": "登録の更新は、指定専門家のアドバイスにIESGの承認が必要になります。"
    },
    {
      "indent": 0,
      "text": "22.4. Layout Types",
      "section_title": true,
      "ja": "22.4. レイアウトタイプ"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"pNFS Layout Types Registry\".",
      "ja": "IANAは、「pNFSのレイアウトタイプレジストリ」と呼ばれるレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "All assignments to the registry are made on a Standards Action basis, with Expert Review required.",
      "ja": "専門家レビューが必要で、レジストリへのすべての割り当ては、標準のアクションに基づいて行われています。"
    },
    {
      "indent": 3,
      "text": "Layout types are 32-bit numbers. The value zero is Reserved. Values in the range 0x80000000 to 0xFFFFFFFF inclusive are designated for Private Use. IANA will assign numbers from the range 0x00000001 to 0x7FFFFFFF inclusive.",
      "ja": "レイアウトタイプは、32ビットの数です。ゼロの値が予約されています。 0xFFFFFFFFのの包括範囲は0x80000000の値は、私的使用のために指定されています。 IANAは、包括的0x7FFFFFFFでの範囲は0x00000001から番号を割り当てます。"
    },
    {
      "indent": 3,
      "text": "The registry is a list of assignments, each containing five fields.",
      "ja": "レジストリは、それぞれ含む5つのフィールド割り当てのリストです。"
    },
    {
      "indent": 3,
      "text": "1. The name of the layout type. This name must have the prefix \"LAYOUT4_\". The name must be unique.",
      "ja": "レイアウトタイプの1名。この名前は、接頭辞「LAYOUT4_」を持っている必要があります。名前は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The value of the layout type. IANA will assign this number, and the request from the registrant will use TBD1 instead of an actual value. The value assigned must be unique. A Designated Expert must be used to ensure that when the name of the layout type and its value are added to the NFSv4.1 layouttype4 enumerated data type in the NFSv4.1 XDR description ([13]), the result continues to be a valid XDR description.",
      "ja": "レイアウトタイプの値2。 IANAは、この番号を割り当てし、登録者からの要求は、実際の値の代わりにTBD1を使用します。割り当てられた値は一意である必要があります。指定された専門家は、レイアウトの種類とその値の名前がNFSv4.1 XDR記述のNFSv4.1のlayouttype4列挙データ型に追加された場合（[13]）、結果が有効であり続けることを保証するために使用されなければなりませんXDRの説明。"
    },
    {
      "indent": 3,
      "text": "3. The Standards Track RFC(s) that describe the notification. If the RFC(s) have not yet been published, the registrant will use RFCTBD2, RFCTBD3, etc. instead of an actual RFC number. Collectively, the RFC(s) must adhere to the guidelines listed in Section 22.4.3.",
      "ja": "3.通知を記述する標準化過程RFC（複数可）。 RFC（s）はまだ公開されていない場合は、登録者ではなく、実際のRFC番号のなどRFCTBD2、RFCTBD3を使用します。まとめると、RFC（複数可）、セクション22.4.3に記載されているガイドラインに準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "4. How the RFC introduces the layout type. This is indicated by a single US-ASCII value. If the value is N, it means a minor revision to the NFSv4 protocol. If the value is L, it means a new pNFS layout type. Other values can be used with IESG Approval.",
      "ja": "4. RFCは、レイアウトの種類を紹介する方法。これは、単一のUS-ASCII値で示されています。値がNである場合には、NFSv4のプロトコルにマイナーリビジョンを意味します。値がLであれば、それは新しいpNFSのレイアウトタイプを意味します。他の値はIESGの承認を得て使用することができます。"
    },
    {
      "indent": 3,
      "text": "5. The minor versions of NFSv4 that are allowed to use the notification. While these are numeric values, IANA will not allocate and assign them; the author of the relevant RFCs with IESG Approval assigns these numbers. Each time there is a new minor version of NFSv4 approved, a Designated Expert should review the registry to make recommended updates as needed.",
      "ja": "5.通知を使用することが許可されているのNFSv4のマイナーバージョン。これらは数値ですが、IANAは、それらを割り当て、割り当てられません。 IESGの承認を得て、関連するRFCの著者は、これらの番号を割り当てます。 NFSv4の承認の新しいマイナーバージョンがあるたびに、指定Expertは、必要に応じて推奨される更新を行うために、レジストリを確認してください。"
    },
    {
      "indent": 0,
      "text": "22.4.1. Initial Registry",
      "section_title": true,
      "ja": "22.4.1. 初期のレジストリ"
    },
    {
      "indent": 3,
      "text": "The initial registry is in Table 18.",
      "ja": "最初のレジストリは、表18です。"
    },
    {
      "indent": 4,
      "text": "+-----------------------+-------+----------+-----+----------------+\n| Layout Type Name      | Value | RFC      | How | Minor Versions |\n+-----------------------+-------+----------+-----+----------------+\n| LAYOUT4_NFSV4_1_FILES | 0x1   | RFC 5661 | N   | 1              |\n| LAYOUT4_OSD2_OBJECTS  | 0x2   | RFC 5664 | L   | 1              |\n| LAYOUT4_BLOCK_VOLUME  | 0x3   | RFC 5663 | L   | 1              |\n+-----------------------+-------+----------+-----+----------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Table 18: Initial Layout Type Assignments",
      "ja": "表18：初期レイアウトタイプの割り当て"
    },
    {
      "indent": 0,
      "text": "22.4.2. Updating Registrations",
      "section_title": true,
      "ja": "22.4.2. 登録の更新"
    },
    {
      "indent": 3,
      "text": "The update of a registration will require IESG Approval on the advice of a Designated Expert.",
      "ja": "登録の更新は、指定専門家のアドバイスにIESGの承認が必要になります。"
    },
    {
      "indent": 0,
      "text": "22.4.3. Guidelines for Writing Layout Type Specifications",
      "section_title": true,
      "ja": "22.4.3. ライティングレイアウトタイプの仕様に関するガイドライン"
    },
    {
      "indent": 3,
      "text": "The author of a new pNFS layout specification must follow these steps to obtain acceptance of the layout type as a Standards Track RFC:",
      "ja": "新しいpNFSのレイアウト仕様の作者は、標準化過程のRFCとしてレイアウトタイプの受け入れを得るために、次の手順を実行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "1. The author devises the new layout specification.",
      "section_title": true,
      "ja": "1.著者は、新しいレイアウト仕様を策定します。"
    },
    {
      "indent": 3,
      "text": "2. The new layout type specification MUST, at a minimum:",
      "section_title": true,
      "ja": "2.新しいレイアウトタイプを指定しなければならない最低限："
    },
    {
      "indent": 7,
      "text": "*  Define the contents of the layout-type-specific fields of the\n   following data types:",
      "raw": true
    },
    {
      "indent": 10,
      "text": "+ the da_addr_body field of the device_addr4 data type;",
      "ja": "+ device_addr4データタイプのda_addr_bodyフィールドと"
    },
    {
      "indent": 10,
      "text": "+ the loh_body field of the layouthint4 data type;",
      "ja": "+ layouthint4データ型のloh_bodyフィールドと"
    },
    {
      "indent": 10,
      "text": "+ the loc_body field of layout_content4 data type (which in turn is the lo_content field of the layout4 data type);",
      "ja": "+（これはlayout4データタイプのlo_contentフィールドである）layout_content4データ型のloc_bodyフィールドと"
    },
    {
      "indent": 10,
      "text": "+ the lou_body field of the layoutupdate4 data type;",
      "ja": "+ layoutupdate4データ型のlou_bodyフィールドと"
    },
    {
      "indent": 7,
      "text": "* Describe or define the storage access protocol used to access the storage devices.",
      "ja": "*記述またはストレージ・デバイスにアクセスするために使用されるストレージ・アクセス・プロトコルを定義します。"
    },
    {
      "indent": 7,
      "text": "* Describe whether revocation of layouts is supported.",
      "ja": "*レイアウトの失効がサポートされているかどうかを説明してください。"
    },
    {
      "indent": 7,
      "text": "* At a minimum, describe the methods of recovery from:",
      "ja": "*最低限、からの回復の方法について説明します。"
    },
    {
      "indent": 10,
      "text": "1. Failure and restart for client, server, storage device.",
      "section_title": true,
      "ja": "クライアント、サーバ、ストレージ・デバイスのための1.失敗して再起動。"
    },
    {
      "indent": 10,
      "text": "2. Lease expiration from perspective of the active client, server, storage device.",
      "ja": "アクティブなクライアント、サーバー、ストレージデバイスの観点から、2リースの有効期限。"
    },
    {
      "indent": 10,
      "text": "3. Loss of layout state resulting in fencing of client access to storage devices (for an example, see Section 12.7.3).",
      "ja": "ストレージデバイスへのクライアントアクセスのフェンシングをもたらすレイアウト状態の3喪失（例えば、セクション12.7.3を参照のこと）。"
    },
    {
      "indent": 7,
      "text": "* Include an IANA considerations section, which will in turn include:",
      "ja": "*順番に含まれますIANAの考慮事項のセクションを、含めます："
    },
    {
      "indent": 10,
      "text": "+ A request to IANA for a new layout type per Section 22.4.",
      "ja": "+ 22.4項ごとに新しいレイアウトタイプについてIANAに要求。"
    },
    {
      "indent": 10,
      "text": "+ A list of requests to IANA for any new recallable object types for CB_RECALL_ANY; each entry is to be presented in the form described in Section 22.3.",
      "ja": "CB_RECALL_ANYのための新たなリコールのオブジェクトタイプのためのIANAへのリクエストのリストを+。各エントリは、セクション22.3で説明した形態で提示することです。"
    },
    {
      "indent": 10,
      "text": "+ A list of requests to IANA for any new notification values for CB_NOTIFY_DEVICEID; each entry is to be presented in the form described in Section 22.2.",
      "ja": "CB_NOTIFY_DEVICEIDのための新たな通知値のIANAへのリクエストのリストを+。各エントリは、セクション22.2で説明した形態で提示することです。"
    },
    {
      "indent": 7,
      "text": "* Include a security considerations section. This section MUST explain how the NFSv4.1 authentication, authorization, and access-control models are preserved. That is, if a metadata server would restrict a READ or WRITE operation, how would pNFS via the layout similarly restrict a corresponding input or output operation?",
      "ja": "*セキュリティの考慮事項のセクションを含めます。このセクションでは、NFSv4.1認証、承認、およびアクセス制御モデルが保存されている方法を説明しなければなりません。メタデータサーバは、どのようにレイアウト介しpNFSのは、同様に、対応する入力または出力操作を制限するであろう、READまたはWRITE動作を制限することになる場合には、ですか？"
    },
    {
      "indent": 3,
      "text": "3. The author documents the new layout specification as an Internet-Draft.",
      "ja": "3.著者はインターネットドラフトとして新しいレイアウト仕様を説明します。"
    },
    {
      "indent": 3,
      "text": "4. The author submits the Internet-Draft for review through the IETF standards process as defined in \"The Internet Standards Process-- Revision 3\" (BCP 9). The new layout specification will be submitted for eventual publication as a Standards Track RFC.",
      "ja": "「インターネット規格Process--改訂3」（BCP 9）で定義されている4.著者はIETF標準化プロセスを通じて審査のためのインターネットドラフトを提出します。新しいレイアウト仕様は、標準化過程のRFCとして最終的な出版のために提出されます。"
    },
    {
      "indent": 3,
      "text": "5. The layout specification progresses through the IETF standards process.",
      "ja": "5.レイアウト仕様は、IETF標準化プロセスを経て進行します。"
    },
    {
      "indent": 0,
      "text": "22.5. Path Variable Definitions",
      "section_title": true,
      "ja": "22.5. パス変数の定義"
    },
    {
      "indent": 3,
      "text": "This section deals with the IANA considerations associated with the variable substitution feature for location names as described in Section 11.10.3. As described there, variables subject to substitution consist of a domain name and a specific name within that domain, with the two separated by a colon. There are two sets of IANA considerations here:",
      "ja": "セクション11.10.3で説明したように、ロケーション名の変数置換機能に関連付けられたIANAの考慮事項このセクションでは扱っています。そこに記載されているように、置換対象の変数は、コロンで区切られた2つと、そのドメイン内のドメイン名と、特定の名前から成ります。ここでIANAの考慮の2セットがあります。"
    },
    {
      "indent": 3,
      "text": "1. The list of variable names.",
      "section_title": true,
      "ja": "変数名のリスト1。"
    },
    {
      "indent": 3,
      "text": "2. For each variable name, the list of possible values.",
      "section_title": true,
      "ja": "各変数名、可能な値のリストについては、2。"
    },
    {
      "indent": 3,
      "text": "Thus, there will be one registry for the list of variable names, and possibly one registry for listing the values of each variable name.",
      "ja": "このように、変数名のリストに1つのレジストリ、および各変数名の値をリストするための、おそらく1レジストリが存在します。"
    },
    {
      "indent": 0,
      "text": "22.5.1. Path Variables Registry",
      "section_title": true,
      "ja": "22.5.1. パス変数のレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"NFSv4 Path Variables Registry\".",
      "ja": "IANAは「NFSv4のパス変数レジストリ」と呼ばれるレジストリを作成しました。"
    },
    {
      "indent": 0,
      "text": "22.5.1.1. Path Variable Values",
      "section_title": true,
      "ja": "22.5.1.1。パス変数値"
    },
    {
      "indent": 3,
      "text": "Variable names are of the form \"${\", followed by a domain name, followed by a colon (\":\"), followed by a domain-specific portion of the variable name, followed by \"}\". When the domain name is \"ietf.org\", all variables names must be registered with IANA on a Standards Action basis, with Expert Review required. Path variables with registered domain names neither part of nor equal to ietf.org are assigned on a Hierarchical Allocation basis (delegating to the domain owner) and thus of no concern to IANA, unless the domain owner chooses to register a variable name from his domain. If the domain owner chooses to do so, IANA will do so on a First Come First Serve basis. To accommodate registrants who do not have their own domain, IANA will accept requests to register variables with the prefix \"${FCFS.ietf.org:\" on a First Come First Served basis. Assignments on a First Come First Basis do not require Expert Review, unless the registrant also wants IANA to establish a registry for the values of the registered variable.",
      "ja": "「{：続いて、変数名のドメイン特異的部分、続いて、コロン（「」）に続いて、ドメイン名、続いて、「}」の変数名の形式は$」です。ドメイン名は「ietf.org」である場合には専門家のレビューが必要で、すべての変数名は、標準アクションベースでIANAに登録する必要があります。ドメインの所有者が自分のドメインから変数名を登録することを選択しない限り、登録したドメイン名の一部もietf.orgに等しいどちらとパス変数は、IANAには関係ないのため、（ドメインの所有者に委任）階層割当ごとに割り当てられています。ドメインの所有者がそうすることを選択した場合、IANAは、まず最初にサーブ来基づいてそうします。最初にまず添え基礎を来る：独自のドメインを持っていない登録者に対応するために、IANAは、接頭辞「$ {FCFS.ietf.org」を持つ変数が登録する要求を受け入れます。登録者はまた、IANAが登録された変数の値のレジストリを確立したいと考えていない限り、まず上の割り当ては、専門家レビューを必要としませんまず基礎を来ります。"
    },
    {
      "indent": 3,
      "text": "The registry is a list of assignments, each containing three fields.",
      "ja": "レジストリは、それぞれ3つのフィールドを含む、割り当てのリストです。"
    },
    {
      "indent": 3,
      "text": "1. The name of the variable. The name of this variable must start with a \"${\" followed by a registered domain name, followed by \":\", or it must start with \"${FCFS.ietf.org\". The name must be no more than 64 UTF-8 characters long. The name must be unique.",
      "ja": "変数の1名。 、またはそれは「$ {FCFS.ietf.org」で開始する必要があります：「」この変数の名前は、続いて登録したドメイン名に続く「$ {」で開始する必要があります。名前は、これ以上のUTF-8 64文字以内の長さでなければなりません。名前は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "2. For assignments made on Standards Action basis, the Standards Track RFC(s) that describe the variable. If the RFC(s) have not yet been published, the registrant will use RFCTBD1, RFCTBD2, etc. instead of an actual RFC number. Note that the RFCs do not have to be a part of an NFS minor version. For assignments made on a First Come First Serve basis, an explanation (consuming no more than 1024 bytes, or more if IANA permits) of the purpose of the variable. A reference to the explanation can be substituted.",
      "ja": "標準アクションに基づいて行わ割り当て2.、変数を記述する標準化過程RFC（複数可）。 RFC（s）はまだ公開されていない場合は、登録者ではなく、実際のRFC番号のなどRFCTBD1、RFCTBD2を使用します。 RFCはNFSマイナーバージョンの一部である必要はありませんので注意してください。最初に作られた割り当ては先着ために、説明は（高々1024のバイトを消費しない、またはIANAが許せばそれ以上）の変数の目的の。説明への参照が置換されていてもよいです。"
    },
    {
      "indent": 3,
      "text": "3. The point of contact, including an email address. The point of contact can consume up to 256 bytes (or more if IANA permits). For assignments made on a Standards Action basis, the point of contact is always IESG.",
      "ja": "3.電子メールアドレスなどの連絡先のポイント。 （IANAが許可されている場合、またはそれ以上）の接触点は、256のバイトまで消費することができます。標準アクションに基づいて行わ割り当てのために、接触のポイントは常にIESGです。"
    },
    {
      "indent": 0,
      "text": "22.5.1.1.1. Initial Registry",
      "section_title": true,
      "ja": "22.5.1.1.1。初期のレジストリ"
    },
    {
      "indent": 3,
      "text": "The initial registry is in Table 19.",
      "ja": "最初のレジストリは、表19にあります。"
    },
    {
      "indent": 9,
      "text": "+------------------------+----------+------------------+\n| Variable Name          | RFC      | Point of Contact |\n+------------------------+----------+------------------+\n| ${ietf.org:CPU_ARCH}   | RFC 5661 | IESG             |\n| ${ietf.org:OS_TYPE}    | RFC 5661 | IESG             |\n| ${ietf.org:OS_VERSION} | RFC 5661 | IESG             |\n+------------------------+----------+------------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Table 19: Initial List of Path Variables",
      "ja": "表19：パス変数の初期リスト"
    },
    {
      "indent": 3,
      "text": "IANA has created registries for the values of the variable names ${ietf.org:CPU_ARCH} and ${ietf.org:OS_TYPE}. See Sections 22.5.2 and 22.5.3.",
      "ja": "IANAは、変数名$ {ietf.org:CPU_ARCH}と$ {ietf.org:OS_TYPE}の値のためのレジストリを作成しました。セクション22.5.2および22.5.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "For the values of the variable ${ietf.org:OS_VERSION}, no registry is needed as the specifics of the values of the variable will vary with the value of ${ietf.org:OS_TYPE}. Thus, values for ${ietf.org: OS_VERSION} are on a Hierarchical Allocation basis and are of no concern to IANA.",
      "ja": "変数の値の詳細は$ {ietf.org:OS_TYPE}の値に応じて変化するように変数$ {ietf.org:OS_VERSION}の値に対して、何レジストリは必要とされません。したがって、$ {ietf.org：OS_VERSION}の値は、階層割当基準であり、IANAにない関心事です。"
    },
    {
      "indent": 0,
      "text": "22.5.1.1.2. Updating Registrations",
      "section_title": true,
      "ja": "22.5.1.1.2。登録の更新"
    },
    {
      "indent": 3,
      "text": "The update of an assignment made on a Standards Action basis will require IESG Approval on the advice of a Designated Expert.",
      "ja": "標準アクションに基づいて行わ割り当ての更新は、指定専門家のアドバイスにIESGの承認が必要になります。"
    },
    {
      "indent": 3,
      "text": "The registrant can always update the point of contact of an assignment made on a First Come First Serve basis. Any other update will require Expert Review.",
      "ja": "登録者は常に先着順で作られた割り当ての接触のポイントを更新することができます。他の更新プログラムは、専門家の審査が必要になります。"
    },
    {
      "indent": 0,
      "text": "22.5.2. Values for the ${ietf.org:CPU_ARCH} Variable",
      "section_title": true,
      "ja": "22.5.2.  $ {ietf.org:CPU_ARCH}変数の値"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"NFSv4 ${ietf.org:CPU_ARCH} Value Registry\".",
      "ja": "IANAは「NFSv4の$ {ietf.org:CPU_ARCH}値レジストリ」と呼ばれるレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "Assignments to the registry are made on a First Come First Serve basis. The zero-length value of ${ietf.org:CPU_ARCH} is Reserved. Values with a prefix of \"PRIV\" are designated for Private Use.",
      "ja": "レジストリへの割り当ては、先着順で作られています。 $ {ietf.org:CPU_ARCH}の長さゼロの値が予約されています。 「PRIV」の接頭辞を持つ値は、私的使用のために指定されています。"
    },
    {
      "indent": 3,
      "text": "The registry is a list of assignments, each containing three fields.",
      "ja": "レジストリは、それぞれ3つのフィールドを含む、割り当てのリストです。"
    },
    {
      "indent": 3,
      "text": "1. A value of the ${ietf.org:CPU_ARCH} variable. The value must be 1 to 32 UTF-8 characters long. The value must be unique.",
      "ja": "1. $ {ietf.org:CPU_ARCH}変数の値。値は1〜32 UTF-8文字でなければなりません。値は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "2. An explanation (consuming no more than 1024 bytes, or more if IANA permits) of what CPU architecture the value denotes. A reference to the explanation can be substituted.",
      "ja": "2.値が表す何CPUアーキテクチャの説明（IANAが許す場合はせいぜい1024バイト、またはそれ以上を消費していません）。説明への参照が置換されていてもよいです。"
    },
    {
      "indent": 3,
      "text": "3. The point of contact, including an email address. The point of contact can consume up to 256 bytes (or more if IANA permits).",
      "ja": "3.電子メールアドレスなどの連絡先のポイント。 （IANAが許可されている場合、またはそれ以上）の接触点は、256のバイトまで消費することができます。"
    },
    {
      "indent": 0,
      "text": "22.5.2.1. Initial Registry",
      "section_title": true,
      "ja": "22.5.2.1。初期のレジストリ"
    },
    {
      "indent": 3,
      "text": "There is no initial registry.",
      "ja": "何の初期のレジストリはありません。"
    },
    {
      "indent": 0,
      "text": "22.5.2.2. Updating Registrations",
      "section_title": true,
      "ja": "22.5.2.2。登録の更新"
    },
    {
      "indent": 3,
      "text": "The registrant is free to update the assignment, i.e., change the explanation and/or point-of-contact fields.",
      "ja": "登録者は、すなわち、説明及び/又はポイントオブコンタクトフィールドを変更し、割当てを更新して自由です。"
    },
    {
      "indent": 0,
      "text": "22.5.3. Values for the ${ietf.org:OS_TYPE} Variable",
      "section_title": true,
      "ja": "22.5.3.  $ {ietf.org:OS_TYPE}変数の値"
    },
    {
      "indent": 3,
      "text": "IANA created a registry called the \"NFSv4 ${ietf.org:OS_TYPE} Value Registry\".",
      "ja": "IANAは「NFSv4の$ {ietf.org:OS_TYPE}値レジストリ」と呼ばれるレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "Assignments to the registry are made on a First Come First Serve basis. The zero-length value of ${ietf.org:OS_TYPE} is Reserved. Values with a prefix of \"PRIV\" are designated for Private Use.",
      "ja": "レジストリへの割り当ては、先着順で作られています。 $ {ietf.org:OS_TYPE}の長さゼロの値が予約されています。 「PRIV」の接頭辞を持つ値は、私的使用のために指定されています。"
    },
    {
      "indent": 3,
      "text": "The registry is a list of assignments, each containing three fields.",
      "ja": "レジストリは、それぞれ3つのフィールドを含む、割り当てのリストです。"
    },
    {
      "indent": 3,
      "text": "1. A value of the ${ietf.org:OS_TYPE} variable. The value must be 1 to 32 UTF-8 characters long. The value must be unique.",
      "ja": "1. $ {ietf.org:OS_TYPE}変数の値。値は1〜32 UTF-8文字でなければなりません。値は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "2. An explanation (consuming no more than 1024 bytes, or more if IANA permits) of what CPU architecture the value denotes. A reference to the explanation can be substituted.",
      "ja": "2.値が表す何CPUアーキテクチャの説明（IANAが許す場合はせいぜい1024バイト、またはそれ以上を消費していません）。説明への参照が置換されていてもよいです。"
    },
    {
      "indent": 3,
      "text": "3. The point of contact, including an email address. The point of contact can consume up to 256 bytes (or more if IANA permits).",
      "ja": "3.電子メールアドレスなどの連絡先のポイント。 （IANAが許可されている場合、またはそれ以上）の接触点は、256のバイトまで消費することができます。"
    },
    {
      "indent": 0,
      "text": "22.5.3.1. Initial Registry",
      "section_title": true,
      "ja": "22.5.3.1。初期のレジストリ"
    },
    {
      "indent": 3,
      "text": "There is no initial registry.",
      "ja": "何の初期のレジストリはありません。"
    },
    {
      "indent": 0,
      "text": "22.5.3.2. Updating Registrations",
      "section_title": true,
      "ja": "22.5.3.2。登録の更新"
    },
    {
      "indent": 3,
      "text": "The registrant is free to update the assignment, i.e., change the explanation and/or point of contact fields.",
      "ja": "登録者は、すなわち、コンタクトフィールドの説明及び/又は位置を変更、割り当てを更新して自由です。"
    },
    {
      "indent": 0,
      "text": "23. References",
      "section_title": true,
      "ja": "23.参考文献"
    },
    {
      "indent": 0,
      "text": "23.1. Normative References",
      "section_title": true,
      "ja": "23.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[1] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[1]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[2] Eisler, M., Ed., \"XDR: External Data Representation Standard\", STD 67, RFC 4506, May 2006.",
      "ja": "[2]アイスラー、M.、エド、 \"XDR：外部データ表現標準\"。、STD 67、RFC 4506、2006年5月。"
    },
    {
      "indent": 3,
      "text": "[3] Thurlow, R., \"RPC: Remote Procedure Call Protocol Specification Version 2\", RFC 5531, May 2009.",
      "ja": "[3] Thurlow、R.、 \"RPC：リモートプロシージャコールプロトコル仕様バージョン2\"、RFC 5531、2009年05月05日。"
    },
    {
      "indent": 3,
      "text": "[4] Eisler, M., Chiu, A., and L. Ling, \"RPCSEC_GSS Protocol Specification\", RFC 2203, September 1997.",
      "ja": "[4]アイスラー、M.、チウ、A.、およびL.リン、 \"RPCSEC_GSSプロトコル仕様\"、RFC 2203、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[5] Zhu, L., Jaganathan, K., and S. Hartman, \"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism Version 2\", RFC 4121, July 2005.",
      "ja": "[5]朱、L.、Jaganathan、K.、およびS.ハートマン、 \"Kerberosバージョン5の汎用セキュリティサービスアプリケーションプログラムインタフェース（GSS-API）メカニズムバージョン2\"、RFC 4121、2005年7月。"
    },
    {
      "indent": 3,
      "text": "[6] The Open Group, \"Section 3.191 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\", 2004.",
      "ja": "[6]オープングループ、 \"Open Groupの基本仕様問題6 IEEE STD 1003.1、2004年版の基本定義の章3節3.191、HTMLバージョン（www.opengroup.org）、ISBN 1931624232\"、2004年。"
    },
    {
      "indent": 3,
      "text": "[7] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, January 2000.",
      "ja": "[7]リン、J.、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェースバージョン2、アップデート1\"、RFC 2743、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[8] Talpey, T. and B. Callaghan, \"Remote Direct Memory Access Transport for Remote Procedure Call\", RFC 5666, January 2010.",
      "ja": "[8] Talpey、T.とB.キャラハン、 \"リモートプロシージャコールのためのリモートダイレクトメモリアクセス交通\"、RFC 5666、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[9] Talpey, T. and B. Callaghan, \"Network File System (NFS) Direct Data Placement\", RFC 5667, January 2010.",
      "ja": "[9] Talpey、T.とB.キャラハン、 \"ネットワークファイルシステム（NFS）直接データ配置\"、RFC 5667、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[10] Recio, R., Metzler, B., Culley, P., Hilland, J., and D. Garcia, \"A Remote Direct Memory Access Protocol Specification\", RFC 5040, October 2007.",
      "ja": "[10] Recio、R.、メッツラー、B.、Culley、P.、Hilland、J.、およびD.ガルシア、 \"リモートダイレクトメモリアクセスプロトコル仕様\"、RFC 5040、2007年10月。"
    },
    {
      "indent": 3,
      "text": "[11] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[11] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[12] Eisler, M., \"RPCSEC_GSS Version 2\", RFC 5403, February 2009.",
      "ja": "[12]アイスラー、M.、 \"RPCSEC_GSSバージョン2\"、RFC 5403、2009年2月。"
    },
    {
      "indent": 3,
      "text": "[13] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 External Data Representation Standard (XDR) Description\", RFC 5662, January 2010.",
      "ja": "[13] Shepler、S.編、アイスラー、M.、編、及びD. Noveck編、 \"ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1外部データ表現標準（XDR）の説明\"、RFC 5662、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[14] The Open Group, \"Section 3.372 of Chapter 3 of Base Definitions of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\", 2004.",
      "ja": "[14]オープングループ、 \"Open Groupの基本仕様問題6 IEEE STD 1003.1、2004年版の基本定義の章3節3.372、HTMLバージョン（www.opengroup.org）、ISBN 1931624232\"、2004年。"
    },
    {
      "indent": 3,
      "text": "[15] Eisler, M., \"IANA Considerations for Remote Procedure Call (RPC) Network Identifiers and Universal Address Formats\", RFC 5665, January 2010.",
      "ja": "[15]アイスラー、M.、 \"IANAの考慮事項リモートプロシージャコール（RPC）ネットワーク識別子とユニバーサルアドレス形式用\"、RFC 5665、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[16] The Open Group, \"Section 'read()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\", 2004.",
      "ja": "2004年 \"システムインターフェースOpen Groupの基本仕様発行の6 IEEE STD 1003.1、2004年版、HTMLバージョン（www.opengroup.org）、ISBN 1931624232のセクション '（読み）'\" [16]オープングループ、。"
    },
    {
      "indent": 3,
      "text": "[17] The Open Group, \"Section 'readdir()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\", 2004.",
      "ja": "[17]オープングループ、 \"節 'のreaddir（）' Open Groupの基本仕様問題6 IEEE STD 1003.1、2004年版、HTMLバージョン（www.opengroup.org）、ISBN 1931624232のシステムインターフェースの\" 2004年。"
    },
    {
      "indent": 3,
      "text": "[18] The Open Group, \"Section 'write()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\", 2004.",
      "ja": "[18]オープングループ、 \"セクション '書き込み（）' Open Groupの基本仕様問題6 IEEE STD 1003.1、2004年版、HTMLバージョン（www.opengroup.org）、ISBN 1931624232のシステムインターフェースの\" 2004年。"
    },
    {
      "indent": 3,
      "text": "[19] Hoffman, P. and M. Blanchet, \"Preparation of Internationalized Strings (\"stringprep\")\", RFC 3454, December 2002.",
      "ja": "[19]ホフマン、P.及びM.ブランシェ、 \"国際化された文字列の調製（\" 文字列準備 \"）\"、RFC 3454、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[20] The Open Group, \"Section 'chmod()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\", 2004.",
      "ja": "[20]オープングループ、 \"節 'はchmod（）' Open Groupの基本仕様問題6 IEEE STD 1003.1、2004年版、HTMLバージョン（www.opengroup.org）、ISBN 1931624232のシステムインターフェースの\" 2004年。"
    },
    {
      "indent": 3,
      "text": "[21] International Organization for Standardization, \"Information Technology - Universal Multiple-octet coded Character Set (UCS) - Part 1: Architecture and Basic Multilingual Plane\", ISO Standard 10646-1, May 1993.",
      "ja": "[21]国際標準化機構、「情報技術 - ユニバーサルマルチオクテット符号化文字集合（UCS） - 第1部：アーキテクチャと基本多言語面」、ISO規格10646-1、1993年5月。"
    },
    {
      "indent": 3,
      "text": "[22] Alvestrand, H., \"IETF Policy on Character Sets and Languages\", BCP 18, RFC 2277, January 1998.",
      "ja": "[22] Alvestrand、H.、 \"文字セットと言語のIETF方針\"、BCP 18、RFC 2277、1998年1月。"
    },
    {
      "indent": 3,
      "text": "[23] Hoffman, P. and M. Blanchet, \"Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)\", RFC 3491, March 2003.",
      "ja": "[23]ホフマン、P.とM.ブランシェ、 \"NAMEPREP：国際化ドメイン名のためのstringprepプロフィール（IDN）\"、RFC 3491、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[24] The Open Group, \"Section 'fcntl()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\", 2004.",
      "ja": "[24]オープングループ、 \"節 'のfcntl（）' Open Groupの基本仕様問題6 IEEE STD 1003.1、2004年版、HTMLバージョン（www.opengroup.org）、ISBN 1931624232のシステムインターフェースの\" 2004年。"
    },
    {
      "indent": 3,
      "text": "[25] The Open Group, \"Section 'fsync()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\", 2004.",
      "ja": "[25]オープングループ、 \"節 'のfsync（）' Open Groupの基本仕様問題6 IEEE STD 1003.1、2004年版、HTMLバージョン（www.opengroup.org）、ISBN 1931624232のシステムインターフェースの\" 2004年。"
    },
    {
      "indent": 3,
      "text": "[26] The Open Group, \"Section 'getpwnam()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\", 2004.",
      "ja": "[26]オープングループ、 \"節 'のgetpwnam（）' Open Groupの基本仕様問題6 IEEE STD 1003.1、2004年版、HTMLバージョン（www.opengroup.org）、ISBN 1931624232のシステムインターフェースの\" 2004年。"
    },
    {
      "indent": 3,
      "text": "[27] The Open Group, \"Section 'unlink()' of System Interfaces of The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition, HTML Version (www.opengroup.org), ISBN 1931624232\", 2004.",
      "ja": "[27]オープングループ、 \"節 'はunlink（）' Open Groupの基本仕様問題6 IEEE STD 1003.1、2004年版、HTMLバージョン（www.opengroup.org）、ISBN 1931624232のシステムインターフェースの\" 2004年。"
    },
    {
      "indent": 3,
      "text": "[28] Schaad, J., Kaliski, B., and R. Housley, \"Additional Algorithms and Identifiers for RSA Cryptography for use in the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 4055, June 2005.",
      "ja": "[28] Schaad、J.、Kaliski、B.、およびR. Housley氏、 \"インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）プロフィールで使用するRSA暗号のための追加のアルゴリズムと識別子\"、RFC 4055 、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[29] National Institute of Standards and Technology, \"Cryptographic Algorithm Object Registration\", URL http://csrc.nist.gov/ groups/ST/crypto_apps_infra/csor/algorithms.html, November 2007.",
      "ja": "[29]米国国立標準技術研究所、 \"暗号アルゴリズムオブジェクトの登録\"、URLのhttp://csrc.nist.gov/グループ/ ST / crypto_apps_infra / csor / algorithms.html、2007年11月。"
    },
    {
      "indent": 0,
      "text": "23.2. Informative References",
      "section_title": true,
      "ja": "23.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[30] Shepler, S., Callaghan, B., Robinson, D., Thurlow, R., Beame, C., Eisler, M., and D. Noveck, \"Network File System (NFS) version 4 Protocol\", RFC 3530, April 2003.",
      "ja": "[30] Shepler、S.、キャラハン、B.、ロビンソン、D.、Thurlow、R.、Beame、C.、アイスラー、M.、およびD. Noveck、 \"ネットワークファイルシステム（NFS）バージョン4プロトコル\"、 RFC 3530、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[31] Callaghan, B., Pawlowski, B., and P. Staubach, \"NFS Version 3 Protocol Specification\", RFC 1813, June 1995.",
      "ja": "[31]キャラハン、B.、ポロウスキー、B.、およびP.ストーバック、 \"NFSバージョン3プロトコル仕様\"、RFC 1813、1995年6月。"
    },
    {
      "indent": 3,
      "text": "[32] Eisler, M., \"LIPKEY - A Low Infrastructure Public Key Mechanism Using SPKM\", RFC 2847, June 2000.",
      "ja": "[32]アイスラー、M.、 \"LIPKEY  -  SPKMを用いた低インフラストラクチャ公開鍵メカニズム\"、RFC 2847、2000年6月。"
    },
    {
      "indent": 3,
      "text": "[33] Eisler, M., \"NFS Version 2 and Version 3 Security Issues and the NFS Protocol's Use of RPCSEC_GSS and Kerberos V5\", RFC 2623, June 1999.",
      "ja": "[33]アイスラー、M.、 \"NFSバージョン2およびバージョン3のセキュリティ問題とRPCSEC_GSSとケルベロスV5のNFSプロトコルの使用\"、RFC 2623、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[34] Juszczak, C., \"Improving the Performance and Correctness of an NFS Server\", USENIX Conference Proceedings, June 1990.",
      "ja": "[34] Juszczak、C.、 \"パフォーマンスとNFSサーバーの正しさを改善\"、USENIX会議議事録、1990年6月。"
    },
    {
      "indent": 3,
      "text": "[35] Reynolds, J., Ed., \"Assigned Numbers: RFC 1700 is Replaced by an On-line Database\", RFC 3232, January 2002.",
      "ja": "。[35]レイノルズ、J.、エド、 \"番号が割り当てられ：RFC 1700は、オンラインデータベースで置き換えられる\"、RFC 3232、2002年1月。"
    },
    {
      "indent": 3,
      "text": "[36] Srinivasan, R., \"Binding Protocols for ONC RPC Version 2\", RFC 1833, August 1995.",
      "ja": "[36]スリニバサン、R.、 \"ONC RPCバージョン2への結合プロトコル\"、RFC 1833、1995年8月。"
    },
    {
      "indent": 3,
      "text": "[37] Werme, R., \"RPC XID Issues\", USENIX Conference Proceedings, February 1996.",
      "ja": "[37] Werme、R.、 \"RPC XID問題\"、USENIX会議議事録、1996年2月。"
    },
    {
      "indent": 3,
      "text": "[38] Nowicki, B., \"NFS: Network File System Protocol specification\", RFC 1094, March 1989.",
      "ja": "[38] Nowicki、B.、 \"NFS：ネットワークシステムプロトコル仕様書ファイル\"、RFC 1094、1989年3月を。"
    },
    {
      "indent": 3,
      "text": "[39] Bhide, A., Elnozahy, E., and S. Morgan, \"A Highly Available Network Server\", USENIX Conference Proceedings, January 1991.",
      "ja": "[39] Bhide、A.、Elnozahy、E.、およびS.モルガン、 \"可用性の高いネットワークサーバー\"、USENIX会議議事録、1991年1月。"
    },
    {
      "indent": 3,
      "text": "[40] Halevy, B., Welch, B., and J. Zelenka, \"Object-Based Parallel NFS (pNFS) Operations\", RFC 5664, January 2010.",
      "ja": "[40] HALEVY、B.、ウェルチ、B.、およびJ.ゼレンカ、 \"オブジェクトベースのパラレルNFS（pNFSの）操作\"、RFC 5664、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[41] Black, D., Glasgow, J., and S. Fridella, \"Parallel NFS (pNFS) Block/Volume Layout\", RFC 5663, January 2010.",
      "ja": "[41]ブラック、D.、グラスゴー、J.、およびS. Fridella、 \"パラレルNFS（pNFSの）ブロック/ボリュームレイアウト\"、RFC 5663、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[42] Callaghan, B., \"WebNFS Client Specification\", RFC 2054, October 1996.",
      "ja": "[42]キャラハン、B.、 \"WebNFSのクライアント仕様\"、RFC 2054、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[43] Callaghan, B., \"WebNFS Server Specification\", RFC 2055, October 1996.",
      "ja": "[43]キャラハン、B.、 \"WebNFSのサーバー仕様\"、RFC 2055、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[44] IESG, \"IESG Processing of RFC Errata for the IETF Stream\", July 2008.",
      "ja": "[44] IESG、 \"IETF RFCストリームのための正誤表のIESG処理\"、2008年7月。"
    },
    {
      "indent": 3,
      "text": "[45] Shepler, S., \"NFS Version 4 Design Considerations\", RFC 2624, June 1999.",
      "ja": "[45] Shepler、S.、 \"NFSバージョン4の設計上の考慮事項\"、RFC 2624、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[46] The Open Group, \"Protocols for Interworking: XNFS, Version 3W, ISBN 1-85912-184-5\", February 1998.",
      "ja": "[46]オープングループ、 \"インターワーキングのためのプロトコル：XNFS、バージョン3W、ISBN 1-85912-184-5\"、1998年2月。"
    },
    {
      "indent": 3,
      "text": "[47] Floyd, S. and V. Jacobson, \"The Synchronization of Periodic Routing Messages\", IEEE/ACM Transactions on Networking 2(2), pp. 122-136, April 1994.",
      "ja": "[47]フロイド、S.およびV. Jacobsonの、ネットワーク2（2）、頁122から136まで、1994年4月にIEEE / ACMトランザクション \"定期的なルーティングメッセージの同期\"。"
    },
    {
      "indent": 3,
      "text": "[48] Satran, J., Meth, K., Sapuntzakis, C., Chadalapaka, M., and E. Zeidner, \"Internet Small Computer Systems Interface (iSCSI)\", RFC 3720, April 2004.",
      "ja": "[48] Satran、J.、メタ、K.、Sapuntzakis、C.、Chadalapaka、M.、およびE. Zeidner、 \"インターネットの小さいコンピュータシステム（のiSCSI）\"、RFC 3720、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[49] Snively, R., \"Fibre Channel Protocol for SCSI, 2nd Version (FCP-2)\", ANSI/INCITS 350-2003, Oct 2003.",
      "ja": "[49] Snively、R.、 \"SCSIのためのファイバチャネルプロトコル、第二のバージョン（FCP-2）\"、ANSI / INCITS 350から2003まで、2003年10月。"
    },
    {
      "indent": 3,
      "text": "[50] Weber, R., \"Object-Based Storage Device Commands (OSD)\", ANSI/ INCITS 400-2004, July 2004, <http://www.t10.org/ftp/t10/drafts/osd/osd-r10.pdf>.",
      "ja": "[50]ウェーバー、R.、 \"オブジェクト・ベースのストレージ・デバイス・コマンド（OSD）\"、ANSI / INCITS 400から2004、2004年7月、<http://www.t10.org/ftp/t10/drafts/osd/osd -r10.pdf>。"
    },
    {
      "indent": 3,
      "text": "[51] Carns, P., Ligon III, W., Ross, R., and R. Thakur, \"PVFS: A Parallel File System for Linux Clusters.\", Proceedings of the 4th Annual Linux Showcase and Conference, 2000.",
      "ja": "[51] Carns、P.、Ligon III、W.、ロス、R.、およびR.タクール、 \"PVFS：Linuxのクラスタのための並列ファイルシステム\"、第4回Linuxのショーケースや会議、2000年の議事。"
    },
    {
      "indent": 3,
      "text": "[52] The Open Group, \"The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition\", 2004.",
      "ja": "[52]オープングループ、 \"Open Groupの基本仕様問題6、IEEE STD 1003.1、2004年版\"、2004年。"
    },
    {
      "indent": 3,
      "text": "[53] Callaghan, B., \"NFS URL Scheme\", RFC 2224, October 1997.",
      "ja": "[53]キャラハン、B.、 \"NFS URLスキーム\"、RFC 2224、1997年10月。"
    },
    {
      "indent": 3,
      "text": "[54] Chiu, A., Eisler, M., and B. Callaghan, \"Security Negotiation for WebNFS\", RFC 2755, January 2000.",
      "ja": "[54]チウ、A.、アイスラー、M.、およびB.キャラハン、 \"WebNFSのためのセキュリティネゴシエーション\"、RFC 2755、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[55] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[55] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Acknowledgments",
      "ja": "付録A.謝辞"
    },
    {
      "indent": 3,
      "text": "The initial text for the SECINFO extensions were edited by Mike Eisler with contributions from Peng Dai, Sergey Klyushin, and Carl Burnett.",
      "ja": "SECINFO拡張のための最初のテキストは鵬大、セルゲイKlyushin、そしてカール・バーネットからの貢献とマイク・アイスラーによって編集されました。"
    },
    {
      "indent": 3,
      "text": "The initial text for the SESSIONS extensions were edited by Tom Talpey, Spencer Shepler, Jon Bauman with contributions from Charles Antonelli, Brent Callaghan, Mike Eisler, John Howard, Chet Juszczak, Trond Myklebust, Dave Noveck, John Scott, Mike Stolarchuk, and Mark Wittle.",
      "ja": "SESSIONSの拡張のための最初のテキストはチャールズ・アントネッリ、ブレントキャラハン、マイク・アイスラー、ジョン・ハワード、チェットJuszczak、トロンMyklebust、デイブNoveck、ジョン・スコット、マイク・Stolarchuk、およびマークからの寄付でトムTalpey、スペンサーShepler、ジョン・バウマンによって編集されましたWittle。"
    },
    {
      "indent": 3,
      "text": "Initial text relating to multi-server namespace features, including the concept of referrals, were contributed by Dave Noveck, Carl Burnett, and Charles Fan with contributions from Ted Anderson, Neil Brown, and Jon Haswell.",
      "ja": "紹介の概念を含むマルチサーバーの名前空間の機能に関連する最初のテキストは、テッド・アンダーソン、ニール・ブラウン、そしてジョン・ハスウェルからの貢献とデイブNoveck、カール・バーネット、そしてチャールズ・ファンによって寄与されました。"
    },
    {
      "indent": 3,
      "text": "The initial text for the Directory Delegations support were contributed by Saadia Khan with input from Dave Noveck, Mike Eisler, Carl Burnett, Ted Anderson, and Tom Talpey.",
      "ja": "ディレクトリ代表団をサポートするための最初のテキストはデイブNoveck、マイク・アイスラー、カール・バーネット、テッド・アンダーソン、そしてトムTalpeyからの入力でサーディア・カーンによって寄与されました。"
    },
    {
      "indent": 3,
      "text": "The initial text for the ACL explanations were contributed by Sam Falkner and Lisa Week.",
      "ja": "ACLの説明のための最初のテキストは、サム・フォークナーとリサ・ウィークで貢献しました。"
    },
    {
      "indent": 3,
      "text": "The pNFS work was inspired by the NASD and OSD work done by Garth Gibson. Gary Grider has also been a champion of high-performance parallel I/O. Garth Gibson and Peter Corbett started the pNFS effort with a problem statement document for the IETF that formed the basis for the pNFS work in NFSv4.1.",
      "ja": "pNFSの作業はガース・ギブソンによって行わNASDとOSDの仕事に触発されました。ゲイリー・グライダーも高性能なパラレルI / Oのチャンピオンとなっています。ガース・ギブソンとピーターコルベットはNFSv4.1でpNFSの作業の基礎を形成IETFのための問題文文書とpNFSの努力を開始しました。"
    },
    {
      "indent": 3,
      "text": "The initial text for the parallel NFS support was edited by Brent Welch and Garth Goodson. Additional authors for those documents were Benny Halevy, David Black, and Andy Adamson. Additional input came from the informal group that contributed to the construction of the initial pNFS drafts; specific acknowledgment goes to Gary Grider, Peter Corbett, Dave Noveck, Peter Honeyman, and Stephen Fridella.",
      "ja": "パラレルNFSをサポートするための最初のテキストは、ブレントウェルチとガース・グッドソンが編集しました。それらの文書のための追加の作者はベニー・アレヴィ、デビッド・ブラック、そしてアンディ・アダムソンました。追加の入力は、初期pNFSのドラフトの建設に貢献した非公式のグループから来ました。具体的な確認はゲイリー・グライダー、ピーターコルベット、デイブNoveck、ピーターハニーマン、およびスティーブンFridellaに行きます。"
    },
    {
      "indent": 3,
      "text": "Fredric Isaman found several errors in draft versions of the ONC RPC XDR description of the NFSv4.1 protocol.",
      "ja": "フレデリックIsamanはNFSv4.1プロトコルのONC RPC XDR記述のドラフトバージョンでいくつかのエラーを発見しました。"
    },
    {
      "indent": 3,
      "text": "Audrey Van Belleghem provided, in numerous ways, essential co-ordination and management of the process of editing the specification documents.",
      "ja": "オードリー・ヴァンBelleghemは、多数の方法、仕様書の編集プロセスの不可欠な協調と管理で、提供します。"
    },
    {
      "indent": 3,
      "text": "Richard Jernigan gave feedback on the file layout's striping pattern design.",
      "ja": "リチャード・ジャーニガンは、ファイルレイアウトのストライプパターン設計にフィードバックを与えました。"
    },
    {
      "indent": 3,
      "text": "Several formal inspection teams were formed to review various areas of the protocol. All the inspections found significant errors and room for improvement. NFSv4.1's inspection teams were:",
      "ja": "いくつかの正式な検査チームは、プロトコルのさまざまな領域を確認するように形成されました。すべての検査は重大なエラーや改善の余地を見つけました。 NFSv4.1の検査チームは以下の通りでした。"
    },
    {
      "indent": 3,
      "text": "o ACLs, with the following inspectors: Sam Falkner, Bruce Fields, Rahul Iyer, Saadia Khan, Dave Noveck, Lisa Week, Mario Wurzl, and Alan Yoder.",
      "ja": "OのACL、以下の検査官を持つ：サム・フォークナー、ブルース・フィールズ、ラーフルアイヤル、サーディア・カーン、デイブNoveck、リサ・ウィーク、マリオWurzl、そしてアランYoderの。"
    },
    {
      "indent": 3,
      "text": "o Sessions, with the following inspectors: William Brown, Tom Doeppner, Robert Gordon, Benny Halevy, Fredric Isaman, Rick Macklem, Trond Myklebust, Dave Noveck, Karen Rochford, John Scott, and Peter Shah.",
      "ja": "Oセッション、以下の検査官と：ウィリアム・ブラウン、トム・Doeppner、ロバート・ゴードン、ベニー・アレヴィ、フレドリックIsaman、リックMacklem、トロンMyklebust、デイブNoveck、カレン・ロックフォード、ジョン・スコット、そしてピーター・シャー。"
    },
    {
      "indent": 3,
      "text": "o Initial pNFS inspection, with the following inspectors: Andy Adamson, David Black, Mike Eisler, Marc Eshel, Sam Falkner, Garth Goodson, Benny Halevy, Rahul Iyer, Trond Myklebust, Spencer Shepler, and Lisa Week.",
      "ja": "O初期pNFSの検査、以下の検査官を持つ：アンディ・アダムソン、デビッド・ブラック、マイク・アイスラー、マルク・Eshel、サム・フォークナー、ガースグッドソン、ベニー・アレヴィ、ラーフルアイヤル、トロンMyklebust、スペンサーShepler、リサ・ウィーク。"
    },
    {
      "indent": 3,
      "text": "o Global namespace, with the following inspectors: Mike Eisler, Dan Ellard, Craig Everhart, Fredric Isaman, Trond Myklebust, Dave Noveck, Theresa Raj, Spencer Shepler, Renu Tewari, and Robert Thurlow.",
      "ja": "Oグローバル名前空間、以下の検査官と：マイク・アイスラー、ダンEllard、クレイグ・エバハート、フレドリックIsaman、トロンMyklebust、デイブNoveck、テレサ・ラジ、スペンサーShepler、レーヌTewari、およびロバートThurlow。"
    },
    {
      "indent": 3,
      "text": "o NFSv4.1 file layout type, with the following inspectors: Andy Adamson, Marc Eshel, Sam Falkner, Garth Goodson, Rahul Iyer, Trond Myklebust, and Lisa Week.",
      "ja": "O NFSv4.1ファイルのレイアウトタイプは、以下の検査官を持つ：アンディ・アダムソン、マルク・Eshel、サム・フォークナー、ガースグッドソン、ラーフルアイヤル、トロンMyklebust、リサ・ウィーク。"
    },
    {
      "indent": 3,
      "text": "o NFSv4.1 locking and directory delegations, with the following inspectors: Mike Eisler, Pranoop Erasani, Robert Gordon, Saadia Khan, Eric Kustarz, Dave Noveck, Spencer Shepler, and Amy Weaver.",
      "ja": "マイク・アイスラー、Pranoop Erasani、ロバート・ゴードン、サーディア・カーン、エリックKustarz、デイブNoveck、スペンサーShepler、そしてエイミー・ウィーバー：O NFSv4.1は、以下の検査官で、代表団をロックし、ディレクトリ。"
    },
    {
      "indent": 3,
      "text": "o EXCHANGE_ID and DESTROY_CLIENTID, with the following inspectors: Mike Eisler, Pranoop Erasani, Robert Gordon, Benny Halevy, Fredric Isaman, Saadia Khan, Ricardo Labiaga, Rick Macklem, Trond Myklebust, Spencer Shepler, and Brent Welch.",
      "ja": "O EXCHANGE_IDとDESTROY_CLIENTID、以下の検査官を持つ：マイク・アイスラー、Pranoop Erasani、ロバート・ゴードン、ベニー・アレヴィ、フレドリックIsaman、サーディア・カーン、リカルドLabiaga、リックMacklem、トロンMyklebust、スペンサーShepler、およびブレントウェルチ。"
    },
    {
      "indent": 3,
      "text": "o Final pNFS inspection, with the following inspectors: Andy Adamson, Mike Eisler, Mark Eshel, Sam Falkner, Jason Glasgow, Garth Goodson, Robert Gordon, Benny Halevy, Dean Hildebrand, Rahul Iyer, Suchit Kaura, Trond Myklebust, Anatoly Pinchuk, Spencer Shepler, Renu Tewari, Lisa Week, and Brent Welch.",
      "ja": "アンディ・アダムソン、マイク・アイスラー、マーク・Eshel、サム・フォークナー、ジェイソン・グラスゴー、ガースグッドソン、ロバート・ゴードン、ベニー・アレヴィ、ディーン・ヒルデブラント、ラーフルアイヤル、Suchit Kaura、トロンMyklebust、アナトリーPinchuk、スペンサー：以下の検査官とO最終pNFSの検査、 Shepler、レーヌTewari、リサ・ウィーク、およびブレントウェルチ。"
    },
    {
      "indent": 3,
      "text": "A review team worked together to generate the tables of assignments of error sets to operations and make sure that each such assignment had two or more people validating it. Participating in the process were Andy Adamson, Mike Eisler, Sam Falkner, Garth Goodson, Robert Gordon, Trond Myklebust, Dave Noveck, Spencer Shepler, Tom Talpey, Amy Weaver, and Lisa Week.",
      "ja": "審査チームは、操作に誤りセットの割り当てのテーブルを生成し、各ような割り当ては、2つ以上の人々がそれを検証していたことを確認するために一緒に働きました。アンディ・アダムソン、マイク・アイスラー、サム・フォークナー、ガースグッドソン、ロバート・ゴードン、トロンMyklebust、デイブNoveck、スペンサーShepler、トムTalpey、エイミー・ウィーバー、そしてリサ・ウィークプロセスに参加されました。"
    },
    {
      "indent": 3,
      "text": "Jari Arkko, David Black, Scott Bradner, Lisa Dusseault, Lars Eggert, Chris Newman, and Tim Polk provided valuable review and guidance.",
      "ja": "ヤリArkko、デビッド・ブラック、スコット・ブラッドナー、リサDusseault、ラースEggertの、クリス・ニューマン、およびティムポークは、貴重なレビューとガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "Olga Kornievskaia found several errors in the SSV specification.",
      "ja": "オルガKornievskaiaはSSV仕様でいくつかのエラーを発見しました。"
    },
    {
      "indent": 3,
      "text": "Ricardo Labiaga found several places where the use of RPCSEC_GSS was underspecified.",
      "ja": "リカルドLabiagaはRPCSEC_GSSの使用がunderspecifiedされたいくつかの場所を発見しました。"
    },
    {
      "indent": 3,
      "text": "Those who provided miscellaneous comments include: Andy Adamson, Sunil Bhargo, Alex Burlyga, Pranoop Erasani, Bruce Fields, Vadim Finkelstein, Jason Goldschmidt, Vijay K. Gurbani, Sergey Klyushin, Ricardo Labiaga, James Lentini, Anshul Madan, Daniel Muntz, Daniel Picken, Archana Ramani, Jim Rees, Mahesh Siddheshwar, Tom Talpey, and Peter Varga.",
      "ja": "その他のコメントを提供した者は、次のとおりです。アンディ・アダムソン、スニルBhargo、アレックスBurlyga、Pranoop Erasani、ブルース・フィールズ、ヴァディム・フィンケルシュタイン、ジェイソン・ゴールドシュミット、ビジェイK. Gurbani、セルゲイKlyushin、リカルドLabiaga、ジェームズ・レンティーニ、Anshulマダン、ダニエルMuntz、ダニエルピッケンを、アーチャーナラマニ、ジム・リース、マヘシュシッドゥシュワー、トムTalpey、そしてピーター・ヴァルガ。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Spencer Shepler (editor) Storspeed, Inc. 7808 Moonflower Drive Austin, TX 78750 USA",
      "ja": "スペンサーShepler（編集者）Storspeed、Inc.の7808ムーンフラワードライブオースティン、TX 78750 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-512-402-5811 ext 8530 EMail: shepler@storspeed.com",
      "ja": "電話：+ 1-512-402-5811 ext 8530 Eメール：shepler@storspeed.com"
    },
    {
      "indent": 3,
      "text": "Mike Eisler (editor) NetApp 5765 Chase Point Circle Colorado Springs, CO 80919 USA",
      "ja": "マイク・アイスラー（エディタ）NetAppの5765チェイスポイントサークルコロラドスプリングス、CO 80919 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-719-599-9026 EMail: mike@eisler.com URI: http://www.eisler.com",
      "ja": "電話：+ 1-719-599-9026 Eメール：mike@eisler.com URI：http://www.eisler.com"
    },
    {
      "indent": 3,
      "text": "David Noveck (editor) NetApp 1601 Trapelo Road, Suite 16 Waltham, MA 02451 USA",
      "ja": "デビッドNoveck（エディタ）NetAppの1601 Trapelo道路、スイート16、ウォルサム、MA 02451 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-781-768-5347 EMail: dnoveck@netapp.com",
      "ja": "電話：+ 1-781-768-5347 Eメール：dnoveck@netapp.com"
    }
  ]
}