{
  "title": {
    "text": "RFC 6476 - Using Message Authentication Code (MAC) Encryption in the Cryptographic Message Syntax (CMS)",
    "ja": "RFC 6476 - メッセージ認証コード（MAC）暗号メッセージ構文（CMS）での暗号化を使用します"
  },
  "number": 6476,
  "created_at": "2019-10-31 15:31:26.390623+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        P. Gutmann\nRequest for Comments: 6476                        University of Auckland\nCategory: Standards Track                                   January 2012\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Using Message Authentication Code (MAC) Encryption\n    in the Cryptographic Message Syntax (CMS)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies the conventions for using Message Authentication Code (MAC) encryption with the Cryptographic Message Syntax (CMS) authenticated-enveloped-data content type. This mirrors the use of a MAC combined with an encryption algorithm that's already employed in IPsec, Secure Socket Layer / Transport Layer Security (SSL/TLS) and Secure SHell (SSH), which is widely supported in existing crypto libraries and hardware and has been extensively analysed by the crypto community.",
      "ja": "この文書は、暗号メッセージ構文（CMS）認証されたエンベロープデータコンテンツタイプにメッセージ認証コード（MAC）暗号化を使用するための規則を指定します。これは、既にIPsecので採用の暗号化アルゴリズム、セキュアソケットレイヤ/トランスポート層セキュリティ（SSL / TLS）と組み合わせたMACの使用を反映して広く、既存の暗号化ライブラリやハードウェアでサポートされているとされているシェル（SSH）、セキュア広範囲に暗号コミュニティによって分析しました。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6476.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6476で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2012 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n   1.1. Conventions Used in This Document ..........................2\n2. Background ......................................................2\n3. CMS Encrypt-and-Authenticate Overview ...........................3\n   3.1. Rationale ..................................................3\n4. CMS Encrypt-and-Authenticate ....................................4\n   4.1. Encrypt-and-Authenticate Message Processing ................5\n   4.2. Rationale ..................................................6\n   4.3. Test Vectors ...............................................8\n5. SMIMECapabilities Attribute ....................................12\n6. Security Considerations ........................................12\n7. IANA Considerations ............................................13\n8. Acknowledgements ...............................................14\n9. References .....................................................14\n   9.1. Normative References ......................................14\n   9.2. Informative References ....................................14",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies the conventions for using MAC-authenticated encryption with the Cryptographic Message Syntax (CMS) authenticated-enveloped-data content type. This mirrors the use of a MAC combined with an encryption algorithm that's already employed in IPsec, SSL/ TLS and SSH, which is widely supported in existing crypto libraries and hardware and has been extensively analysed by the crypto community.",
      "ja": "この文書は、暗号メッセージ構文（CMS）認証されたエンベロープデータのコンテンツタイプとMAC認証の暗号化を使用するための規則を指定します。これは、広く、既存の暗号化ライブラリやハードウェアでサポートされており、広範囲に暗号コミュニティによって分析されているすでにのIPsec、SSL / TLSおよびSSHで採用の暗号化アルゴリズムと組み合わせMACの使用を反映しています。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1. このドキュメントの表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Background",
      "section_title": true,
      "ja": "2.背景"
    },
    {
      "indent": 3,
      "text": "Integrity-protected encryption is a standard feature of session-oriented security protocols like [IPsec], [SSH], and [TLS]. Until recently, however, integrity-protected encryption wasn't available for message-based security protocols like CMS, although [OpenPGP] added a form of integrity protection by encrypting a SHA-1 hash of the message alongside the message contents to provide authenticate-and-encrypt protection. Usability studies have shown that users expect encryption to provide integrity protection [Garfinkel], creating cognitive dissonance problems when the security mechanisms don't in fact provide this assurance.",
      "ja": "完全性保護された暗号化[TLS] [IPsecの]、[SSH]のようなセッション指向セキュリティプロトコルの標準機能である、と。 [のOpenPGP] authenticate-を提供するために、メッセージの内容と一緒にメッセージのSHA-1ハッシュを暗号化することにより、完全性保護の形式を追加しましたが、最近まで、しかし、完全性保護された暗号化は、CMSのようなメッセージベースのセキュリティプロトコルでは使用できませんでした保護をして、暗号化します。ユーザビリティ調査は、ユーザーがセキュリティメカニズムが実際にこの保証を提供していないとき、認知的不協和の問題を作成し、完全性保護[Garfinkel]を提供するために、暗号化を期待することが示されています。"
    },
    {
      "indent": 3,
      "text": "This document applies the same encrypt-and-authenticate mechanism already employed in IPsec, SSH, and SSL/TLS to CMS (technically some of these actually use authenticate-and-encrypt rather than encrypt-and-authenticate, since what's authenticated is the plaintext and not the ciphertext). This mechanism is widely supported in existing crypto libraries and hardware and has been extensively analysed by the crypto community [EncryptThenAuth].",
      "ja": "この文書では、CMSにすでにIPsecの、SSH、およびSSL / TLSで使用したのと同じ暗号化-と-認証メカニズムを適用します（これらの技術的にいくつかのものを認証されていますが平文であるため、実際には、認証-および暗号化ではなく、暗号化、および-認証を使用しますそしてない暗号文）。このメカニズムは広く、既存の暗号化ライブラリやハードウェアでサポートされており、広範囲に暗号コミュニティ[EncryptThenAuth]によって分析されました。"
    },
    {
      "indent": 0,
      "text": "3. CMS Encrypt-and-Authenticate Overview",
      "section_title": true,
      "ja": "3. CMS暗号化-と、認証の概要"
    },
    {
      "indent": 3,
      "text": "Conventional CMS encryption uses a content-encryption key (CEK) to encrypt a message payload, with the CEK typically being in turn encrypted by a key-encryption key (KEK). Authenticated encryption requires two keys: one for encryption and a second one for authentication. Like other mechanisms that use authenticated encryption, this document employs a pseudorandom function (PRF) to convert a single block of keying material into the two keys required for encryption and authentication. This converts the standard CMS encryption operation:",
      "ja": "従来のCMSの暗号化CEKは、典型的には、鍵暗号鍵（KEK）で暗号化された順番であると、メッセージペイロードを暗号化するコンテンツ暗号鍵（CEK）を使用します。暗号化用と認証のための第二1：認証済みの暗号化は、2つのキーを必要とします。認証された暗号化を使用する他の機構のように、この文書は、暗号化と認証に必要な2つの鍵に鍵材料の単一のブロックを変換する擬似ランダム関数（PRF）を採用しています。これは、標準のCMSの暗号化操作を変換します。"
    },
    {
      "indent": 7,
      "text": "KEK( CEK ) || CEK( data )",
      "ja": "KEK（CEK）|| CEK（データ）"
    },
    {
      "indent": 3,
      "text": "into:",
      "ja": "に："
    },
    {
      "indent": 7,
      "text": "KEK( master_secret ) || MAC( CEK( data ) )",
      "ja": "KEK（でマスター_）|| MAC（CEK（データ））"
    },
    {
      "indent": 3,
      "text": "where the MAC key MAC-K and encryption key CEK-K are derived from the master_secret via:",
      "ja": "MACキーMAC-Kおよび暗号化キーCEK-Kを経由して、マスター_由来されている場合："
    },
    {
      "indent": 7,
      "text": "MAC-K := PRF( master_secret, \"authentication\" );\nCEK-K := PRF( master_secret, \"encryption\" );",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1. Rationale",
      "section_title": true,
      "ja": "3.1. 理由"
    },
    {
      "indent": 3,
      "text": "There are several possible means of deriving the two keys required for the encrypt-and-authenticate process from the single key normally provided by the key exchange or key transport mechanisms. Several of these, however, have security or practical issues. For example, any mechanism that uses the single exchanged key in its entirety for encryption (using, perhaps, PRF( key ) as the MAC key) can be converted back to unauthenticated data by removing the outer MAC layer and rewriting the CMS envelope back to plain EnvelopedData or EncryptedData. By applying the PRF intermediate step, any attempt at a rollback attack will result in a decryption failure.",
      "ja": "通常、鍵交換またはキー輸送機構によって提供される単一の鍵で暗号化・アンド・認証処理に必要な2つのキーを導出するいくつかの可能な手段があります。これらのいくつかは、しかし、セキュリティや実用的な問題を抱えています。例えば、暗号化のためにその全体が単一の交換鍵を使用する任意の機構（使用は、おそらく、PRF MAC鍵として（キー））は、外側のMAC層を除去し、裏面にCMSエンベロープを書き換えることにより、バック認証されていないデータに変換することができます。平野EnvelopedDataのかはEncryptedData。 PRF中間ステップを適用することにより、ロールバック攻撃の試みは、復号失敗になります。"
    },
    {
      "indent": 3,
      "text": "The option chosen here -- the use of a PRF to derive the necessary sets of keying material from a master secret -- is well-established through its use in IPsec, SSH, and SSL/TLS and is widely supported in both crypto libraries and in encryption hardware.",
      "ja": "ここで選択したオプション - マスターシークレットから鍵材料の必要なセットを導出するためにPRFの使用は - のIPsec、SSH、およびSSL / TLSでの使用によって十分に確立され、広く両方の暗号ライブラリでサポートされており、暗号化ハードウェアインチ"
    },
    {
      "indent": 3,
      "text": "The PRF used is Password-Based Key Derivation Function 2 (PBKDF2) because its existing use in CMS makes it the most obvious candidate for such a function. In the future, if a universal PRF -- for example, [HKDF] -- is adopted, then this can be substituted for PBKDF2 by specifying it in the prfAlgorithm field covered in Section 4.",
      "ja": "CMSでの既存の使用はそのような関数のための最も明白な候補となりますので、使用PRFは、パスワードベース鍵導出関数2（PBKDF2）です。将来的には、ユニバーサルPRF場合 - 例えば、[HKDF]  - これは、セクション4で覆われprfAlgorithmのフィールドに指定することにより、PBKDF2に置換することができ、採用されています。"
    },
    {
      "indent": 3,
      "text": "The resulting processing operations consist of a combination of the operations used for the existing CMS content types EncryptedData and AuthenticatedData, allowing them to be implemented relatively simply using existing code.",
      "ja": "得られた処理動作は、彼らが既存のコードを使用して比較的簡単に実現することができるように、既存のCMSコンテンツタイプはEncryptedDataとAuthenticatedDataために使用される動作の組み合わせから成ります。"
    },
    {
      "indent": 0,
      "text": "4. CMS Encrypt-and-Authenticate",
      "section_title": true,
      "ja": "4. CMS暗号化-と、認証"
    },
    {
      "indent": 3,
      "text": "The encrypt-and-authenticate mechanism is implemented within the existing CMS RecipientInfo framework by defining a new pseudo-algorithm type, authEnc, which is used in place of a monolithic encrypt and hash algorithm. The RecipientInfo is used as a key container for the master secret used by the pseudo-algorithm from which the encryption and authentication keys for existing single-purpose encrypt-only and MAC-only algorithms are derived. Thus, instead of using the RecipientInfo to communicate (for example) an AES or HMAC-SHA1 key, it communicates a master secret from which the required AES encryption and HMAC-SHA1 authentication keys are derived.",
      "ja": "暗号化・アンド・認証機構は、モノリシック暗号化とハッシュアルゴリズムの代わりに使用される新たな擬似アルゴリズムタイプ、authEncを定義することによって、既存のCMSのRecipientInfoの枠組み内で実施されます。 RecipientInfoは、単一目的の暗号化のみとMAC-のみアルゴリズムが導出される既存の暗号化および認証鍵から擬似アルゴリズムによって使用されるマスター秘密鍵のためのコンテナとして使用されます。したがって、代わりに、（例えば）AESまたはHMAC-SHA1キーを通信するためのRecipientInfoを使用する、必要なAES暗号化およびHMAC-SHA1認証キーが導出されるマスター秘密を通信します。"
    },
    {
      "indent": 3,
      "text": "The authEnc pseudo-algorithm comes in two forms: one conveying 128 bits of keying material and one conveying 256 bits:",
      "ja": "鍵材料と1つの256ビットを搬送するの搬送128ビット：authEnc擬似アルゴリズムは、2つの形で来ます。"
    },
    {
      "indent": 7,
      "text": "id-smime OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n            us(840) rsadsi(113549) pkcs(1) pkcs9(9) 16 }",
      "raw": true
    },
    {
      "indent": 7,
      "text": "id-alg  OBJECT IDENTIFIER ::= { id-smime 3 }",
      "raw": true
    },
    {
      "indent": 7,
      "text": "id-alg-authEnc-128 OBJECT IDENTIFIER ::= { id-alg 15 }\nid-alg-authEnc-256 OBJECT IDENTIFIER ::= { id-alg 16 }",
      "raw": true
    },
    {
      "indent": 4,
      "text": "The algorithm parameters are as follows:",
      "ja": "次のようにアルゴリズムのパラメータは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "AuthEncParams ::= SEQUENCE {\n    prfAlgorithm   [0] AlgorithmIdentifier DEFAULT PBKDF2,\n    encAlgorithm       AlgorithmIdentifier,\n    macAlgorithm       AlgorithmIdentifier\n    }",
      "raw": true
    },
    {
      "indent": 6,
      "text": "prfAlgorithm is the PRF algorithm used to convert the master secret into the encryption and MAC keys. The default PRF is [PBKDF2], which in turn has a default PRF algorithm of HMAC-SHA1. When this default setting is used, the PBKDF2-params 'salt' parameter is an empty string, and the 'iterationCount' parameter is one, turning the KDF into a pure PRF.",
      "ja": "prfAlgorithmは、暗号化とMAC鍵にマスターシークレットを変換するために使用されるPRFアルゴリズムです。デフォルトPRFは、順番にHMAC-SHA1の既定のPRFアルゴリズムを持っている、[PBKDF2]です。このデフォルト設定を使用すると、PBKDF2-paramsは「塩」パラメータは、空の文字列で、「iterationCount」パラメータは一つであり、純粋なPRFにKDFを回します。"
    },
    {
      "indent": 6,
      "text": "encAlgorithm is the encryption algorithm and associated parameters to be used to encrypt the content.",
      "ja": "encAlgorithmは、暗号化アルゴリズムおよび関連するパラメータは、コンテンツを暗号化するために使用されるべきです。"
    },
    {
      "indent": 6,
      "text": "macAlgorithm is the MAC algorithm and associated parameters to be used to authenticate/integrity-protect the content.",
      "ja": "macAlgorithmは、MACアルゴリズムおよび/整合性保護コンテンツを認証するために使用される関連するパラメータです。"
    },
    {
      "indent": 3,
      "text": "When the prfAlgorithm AlgorithmIdentifier is used in conjunction with PBKDF2 to specify a PRF other than the default PBKDF2-with-HMAC-SHA1 one, the PBKDF2-params require that two additional algorithm parameters be specified. The 'salt' parameter MUST be an empty (zero-length) string, and the 'iterationCount' parameter MUST be one, since these values aren't used in the PRF process. In their encoded form as used for the PBKDF2-params, these two parameters have the value 08 00 02 01 01.",
      "ja": "prfAlgorithmのAlgorithmIdentifierがデフォルトPBKDF2-HMAC-SHA1を有するもの以外のPRFを指定するPBKDF2と組み合わせて使用​​される場合、PBKDF2-paramsは、2つの追加のアルゴリズムパラメータを指定することを必要とします。 「塩」パラメータは、空（長さゼロ）文字列である必要があり、これらの値は、PRFプロセスで使用されていないので、「iterationCount」パラメータは、1でなければなりません。 PBKDF2-paramsはのために使用されるようなそれらのエンコードされた形式で、これら2つのパラメータが値08 00 02 01 01を有しています。"
    },
    {
      "indent": 3,
      "text": "As a guideline for authors specifying the use of PRFs other than PBKDF2, any additional parameters such as salts, tags, and identification strings SHOULD be set to empty strings, and any iteration count SHOULD be set to one.",
      "ja": "PBKDF2以外のPRFの使用を特定の著者のガイドラインとして、このような塩、タグ、識別文字列のような任意の追加のパラメータは、文字列を空に設定する必要があり、任意の繰り返し回数は1に設定されるべきです。"
    },
    {
      "indent": 0,
      "text": "4.1. Encrypt-and-Authenticate Message Processing",
      "section_title": true,
      "ja": "4.1. メッセージ処理認証暗号化、および、"
    },
    {
      "indent": 3,
      "text": "The randomly generated master secret to be communicated via the RecipientInfo(s) is converted to separate encryption and authentication keys and applied to the encrypt-and-authenticate process as follows. The notation \"PRF( key, salt, iterations )\" is used to denote an application of the PRF to the given keying value and salt, for the given number of iterations:",
      "ja": "RecipientInfo（S）を介して通信されるランダムに生成されたマスターシークレットは、別個の暗号化および認証鍵に変換され、次のように暗号化・アンド・認証プロセスに適用されます。表記「PRF（キー、塩、反復）」が反復の所定の数のために、与えられたキー値および塩にPRFの適用を示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "1. The MAC algorithm key is derived from the master secret via:",
      "section_title": true,
      "ja": "1. MACアルゴリズムキーが経由してマスターシークレットから導出されます。"
    },
    {
      "indent": 11,
      "text": "MAC-K ::= PRF( master_secret, \"authentication\", 1 );",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. The encryption algorithm key is derived from the master secret via:",
      "ja": "2.暗号化アルゴリズムのキーを介して、マスターシークレットから導出されます。"
    },
    {
      "indent": 11,
      "text": "Enc-K ::= PRF( master_secret, \"encryption\", 1 );",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. The data is processed as described in [AuthEnv], and specifically since the mechanisms used are a union of EncryptedData and AuthenticatedData, as per [CMS]. The one exception to this is that the EncryptedContentInfo.ContentEncryptionAlgorithmIdentifier data is MACed before the encrypted content is MACed. The EncryptedData processing is applied to the data first, and then the AuthenticatedData processing is applied to the result, so that the nesting is as follows:",
      "ja": "【AuthEnv]で説明されるように前記データが処理され、そして使用されるメカニズムは、[CMS]あたりとしてはEncryptedDataとAuthenticatedDataの組合は、ある具体的ので。これに対する唯一の例外は、暗号化されたコンテンツがMACedされる前に、EncryptedContentInfo.ContentEncryptionAlgorithmIdentifierデータがMACedされていることです。入れ子になるように、次のようにはEncryptedData処理は、第1のデータに適用され、その後、AuthenticatedData処理結果に適用されます。"
    },
    {
      "indent": 11,
      "text": "MAC( contentEncrAlgoID || encrypt( content ) );",
      "ja": "MAC（contentEncrAlgoID ||暗号化（コンテンツ））。"
    },
    {
      "indent": 3,
      "text": "4. If authenticated attributes are present, then they are encoded as described in [AuthEnv] and MACed after the encrypted content, so that the processing is as follows:",
      "ja": "認証された属性が存在する場合【AuthEnv]に記載の暗号化コンテンツ後MACedとして次のような処理となるよう4は、それらが、符号化されます。"
    },
    {
      "indent": 11,
      "text": "MAC( contentEncrAlgoID || encrypt( content ) || authAttr );",
      "ja": "MAC（contentEncrAlgoID ||暗号化（コンテンツ）|| authAttr）。"
    },
    {
      "indent": 0,
      "text": "4.2. Rationale",
      "section_title": true,
      "ja": "4.2. 理由"
    },
    {
      "indent": 3,
      "text": "When choosing between encrypt-and-authenticate and authenticate-and-encrypt, the more secure option is encrypt-and-authenticate. There has been extensive analysis of this in the literature; the best coverage is probably [EncryptThenAuth].",
      "ja": "暗号化・アンド・認証し、認証-と暗号化の間で選択すると、より安全なオプションは、暗号化、および-認証されます。文献にこの大規模な分析がなされてきました。最高のカバレッジは[EncryptThenAuth]おそらくです。"
    },
    {
      "indent": 3,
      "text": "The EncryptedContentInfo.ContentEncryptionAlgorithmIdentifier is the SEQUENCE containing the id-alg-authEnc-128/id-alg-authEnc-256 OBJECT IDENTIFIER and its associated AuthEncParams. This data is MACed exactly as encoded, without any attempt to re-code it into a canonical form like DER.",
      "ja": "EncryptedContentInfo.ContentEncryptionAlgorithmIdentifierは、ID-ALG-authEnc-128 / ID-ALG-authEnc-256オブジェクト識別子とその関連AuthEncParamsを含む配列です。このデータは、再コードにDERような標準形にいかなる試みずに、正確としてエンコードMACedれます。"
    },
    {
      "indent": 3,
      "text": "The EncryptedContentInfo.ContentEncryptionAlgorithmIdentifier must be protected alongside the encrypted content; otherwise, an attacker could manipulate the encrypted data indirectly by manipulating the encryption algorithm parameters, which wouldn't be detected through MACing the encrypted content alone. For example, by changing the encryption IV, it's possible to modify the results of the decryption after the encrypted data has been verified via a MAC check.",
      "ja": "EncryptedContentInfo.ContentEncryptionAlgorithmIdentifierは暗号化されたコンテンツと一緒に保護されなければなりません。そうでない場合、攻撃者は一人で暗号化されたコンテンツをMACingによって検出されない暗号化アルゴリズムパラメータを操作することにより、間接的に暗号化されたデータを操作することができます。例えば、暗号化IVを変化させることにより、暗号化されたデータは、MACチェックを経て検証された後の復号の結果を変更することが可能です。"
    },
    {
      "indent": 3,
      "text": "The authEnc pseudo-algorithm has two \"key sizes\" rather than the one-size-fits-all that the PRF impedance-matching would provide. This is done to address real-world experience in the use of AES keys, where users demanded AES-256 alongside AES-128 because of some perception that the former was \"twice as good\" as the latter. Providing an option for keys that go to 11 avoids potential user acceptance problems when someone notices that the authEnc pseudo-key has \"only\" 128 bits when they expect their AES keys to be 256 bits long.",
      "ja": "authEnc擬似アルゴリズムは、2つの「鍵のサイズ」ではなくフリーサイズPRFのインピーダンス整合を提供することがあります。これは、ユーザーがあるため、前者が後者のように、「二倍良い」だったことをいくつかの知覚のAES-128と一緒にAES-256を要求したAESキーの使用で、実世界での経験を、対処するために行われます。誰かが、彼らは彼らのAESキーは256ビット長であることを期待するときauthEnc擬似キーは「のみ」128ビットを持っていることに気づくとき、11に行くキーのオプションを提供することは、潜在的なユーザーの受け入れの問題を回避することができます。"
    },
    {
      "indent": 3,
      "text": "Using a fixed-length key rather than making it a user-selectable parameter is done for the same reason as AES's quantised key lengths: there's no benefit to allowing, say, 137-bit keys over basic 128- and 256-bit lengths; it adds unnecessary complexity; if the lengths are user-defined, then there'll always be someone who wants keys that go up to 12. Providing a choice of two commonly used lengths gives users the option of choosing a \"better\" key size should they feel the need, while not overloading the system with unneeded flexibility.",
      "ja": "このユーザ選択パラメータはAESの量子化されたキーの長さと同じ理由のために行われを行うのではなく、固定長キーを使用して：基本的な128と256ビットの長さにわたって、たとえば、137ビット・キーを可能にすることに何の利点はありません。それは不必要な複雑さを追加します。長さは、ユーザ定義されている場合は、常に、ユーザーに彼らが必要性を感じなければならない「より良い」キーサイズを選択するオプションを提供します2つの一般的に使用される長さの選択肢を提供する12まで行くのキーを望んでいる誰かがあるでしょう不必要な柔軟性を備えたシステムが過負荷にされていないが。"
    },
    {
      "indent": 3,
      "text": "The use of the PRF AlgorithmIdentifier presents some problems, because it's usually not specified in a manner that allows it to be easily used as a straight KDF. For example, PBKDF2 has the following parameters:",
      "ja": "それは通常、それが簡単にまっすぐKDFとして使用することができるような方法で指定されていないので、PRFのAlgorithmIdentifierの使用は、いくつかの問題を提起します。例えば、PBKDF2は、以下のパラメータがあります。"
    },
    {
      "indent": 7,
      "text": "PBKDF2-params ::= SEQUENCE {\n    salt OCTET STRING,\n    iterationCount INTEGER (1..MAX),\n    prf AlgorithmIdentifier {{PBKDF2-PRFs}}\n                            DEFAULT algid-hmacWithSHA1\n    }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "of which only the prf AlgorithmIdentifier is used here. In order to avoid having to define new AlgorithmIdentifiers for each possible PRF, this specification sets any parameters not required for KDF functionality to no-op values. In the case of PBKDF2, this means that the salt has length zero and the iteration count is set to one, with only the prf AlgorithmIdentifier playing a part in the processing. Although it's not possible to know what form other PRFs-as-KDFs will take, a general note for their application within this specification is that any non-PRF parameters should similarly be set to no-op values.",
      "ja": "その唯一のPRFのAlgorithmIdentifierは、ここで使用されます。各可能なPRFのための新しいAlgorithmIdentifiersを定義することを避けるために、この仕様はノーオペレーション値にKDF機能のために必要とされない任意のパラメータを設定します。 PBKDF2の場合、これは塩が長さゼロを有し、繰り返し回数のみPRFのAlgorithmIdentifierが処理中に一部を再生して、いずれかに設定されることを意味します。それは他のPRF-AS-KDFsが取るかを知る形成することはできませんが、この仕様書内でのアプリケーションのための一般的なノートでは、任意の非PRFパラメータも同様にノーオペレーション値に設定しなければならないということです。"
    },
    {
      "indent": 3,
      "text": "Specifying a MAC key size gets a bit tricky; most MAC algorithms have some de facto standard key size, and for HMAC algorithms, this is usually the same as the hash output size. For example, for HMAC-MD5, it's 128 bits; for HMAC-SHA1, it's 160 bits; and for HMAC-SHA256, it's 256 bits. Other MAC algorithms also have de facto standard key sizes. For example, for AES-based MACs, it's the AES key size -- 128 bits for AES-128 and 256 bits for AES-256. This situation makes it difficult to specify the key size in a normative fashion, since it's dependent on the algorithm type that's being used. If there is any ambiguity over which key size should be used, then it's RECOMMENDED that either the size be specified explicitly in the macAlgorithm AlgorithmIdentifier or that an RFC or similar standards document be created that makes the key sizes explicit.",
      "ja": "MACキーサイズを指定すると、少しトリッキー取得します。ほとんどのMACアルゴリズムは、いくつかの事実上の標準キーサイズを有し、およびHMACアルゴリズムのために、これは通常、ハッシュ出力サイズと同じです。例えば、HMAC-MD5のために、それは128ビットです。 HMAC-SHA1のために、それは160ビットです。そして、HMAC-SHA256のために、それは256ビットです。他のMACアルゴリズムはまた、事実上の標準キーのサイズを持っています。 AES-128のための128ビット、AES-256のための256ビット - 例えば、AESベースのMacのために、それは、AES鍵のサイズです。この状況は、それが使われているアルゴリズムの種類に依存しますので、それは難しい、規範的な方法で鍵のサイズを指定することができます。キーサイズを使用する必要があり、その上任意のあいまいさがある場合、サイズのいずれかがmacAlgorithmのAlgorithmIdentifierまたはRFCまたは類似の規格文書は、キーのサイズが明示的になりますが作成されることを明示的に指定することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "As with other uses of PRFs for crypto impedance-matching in protocols, like IPsec, SSL/TLS, and SSH, the amount of input to the PRF generally doesn't match the amount of output. The general philosophical implications of this are covered in various analyses of the properties and uses of PRFs. If you're worried about this, then you can try and approximately match the authEnc \"key size\" to the key size of the encryption algorithm being used, although even there, a perfect match for algorithms like Blowfish (448 bits) or RC5 (832 bits) is going to be difficult.",
      "ja": "IPsec、SSL / TLS、およびSSHなどのプロトコルで暗号インピーダンス整合のためのPRFの他の用途と同様に、PRFへの入力の量は、一般に、出力量と一致していません。この一般的な哲学的含意は、のPRFの特性及び用途の各種分析に覆われています。あなたはこのことについて心配している場合は、試してみて、およそさえあったが使用されている暗号化アルゴリズムのキーサイズにauthEnc「キーサイズ」、フグ（448ビット）またはRC5などのアルゴリズムのための完璧な試合を（一致させることができます832ビット）が困難になるだろう。"
    },
    {
      "indent": 3,
      "text": "The term \"master secret\" comes from its use in SSL/TLS, which uses a similar PRF-based mechanism to convert its master_secret value into encryption and MAC keys (as do SSH and IPsec). The master_secret value isn't a key in the conventional sense, but merely a secret value that's then used to derive two (or, in the cases of SSL/TLS, SSH, and IPsec, several) keys and related cryptovariables.",
      "ja": "用語「マスター秘密は」（SSHとIPsecがそうであるように）暗号化とMAC鍵にその、マスター_値を変換するために、同様のPRFベースのメカニズムを使用してSSL / TLSでの使用、から来ています。 、マスター_値は、従来の意味でのキーが、その後2つ（または、SSL / TLSの例では、SSH、およびIPSec、いくつかの）キーと関連cryptovariablesを導き出すために使われているだけで秘密の値ではありません。"
    },
    {
      "indent": 3,
      "text": "Apart from the extra step added to key management, all of the processing is already specified as part of the definition of the standard CMS content-types Encrypted/EnvelopedData and AuthenticatedData. This significantly simplifies both the specification and the implementation task, as no new content-processing mechanisms are introduced.",
      "ja": "別に鍵管理に追加余分なステップから、全ての処理は、既に/ EnvelopedDataのとAuthenticatedData暗号化された標準CMSのコンテンツ・タイプの定義の一部として指定されています。新しいコンテンツ処理メカニズムが導入されないので、これはかなり、仕様および実装作業の両方を簡素化します。"
    },
    {
      "indent": 0,
      "text": "4.3. Test Vectors",
      "section_title": true,
      "ja": "4.3. テストベクトル"
    },
    {
      "indent": 3,
      "text": "The following test vectors may be used to verify an implementation of MAC-authenticated encryption. This represents a text string encrypted and authenticated using the ever-popular password \"password\" via CMS PasswordRecipientInfo. The encryption algorithm used for the first value is triple DES, whose short block size (compared to AES) makes it easier to corrupt arbitrary bytes for testing purposes within the self-healing Cipher Block Chaining (CBC) mode, which will result in correct decryption but a failed MAC check. The encryption algorithm used for the second value is AES.",
      "ja": "次のテストベクトルは、MAC認証の暗号化の実装を検証するために使用されてもよいです。これは、暗号化され、CMS PasswordRecipientInfo経由で常に人気のパスワード「パスワード」を使用して認証テキスト文字列を表します。最初の値のために使用される暗号化アルゴリズムは、その短い（AESと比較して）ブロックサイズ正しい復号化をもたらす自己修復暗号ブロック連鎖（CBC）モード、内テストのために破損し、任意のバイトにそれが容易になり、トリプルDES、ありますしかし、MACのチェックに失敗しました。第二の値に使用する暗号化アルゴリズムはAESです。"
    },
    {
      "indent": 3,
      "text": "For the triple DES-encrypted data, corrupting a byte at positions 192-208 can be used to check that payload-data corruption is detected, and corrupting a byte at positions 168-174 can be used to check that metadata corruption is detected. The corruption in these byte ranges doesn't affect normal processing and so wouldn't normally be detected.",
      "ja": "トリプルDES暗号化データに対して、位置192から208にバイトを破損そのペイロードデータの破損が検出されたチェックするために使用することができ、そして位置168から174にバイトを破損が検出されたメタデータの破損をチェックするために使用することができます。これらのバイト範囲での破損は通常の処理に影響を与えませんので、通常は検出されません。"
    },
    {
      "indent": 3,
      "text": "The test data has the following characteristics:",
      "ja": "テストデータは、次の特徴があります。"
    },
    {
      "indent": 6,
      "text": "version is set to 0.",
      "ja": "バージョンが0に設定されています。"
    },
    {
      "indent": 6,
      "text": "originatorInfo isn't needed and is omitted.",
      "ja": "originatorInfoが必要とされず、省略されています。"
    },
    {
      "indent": 6,
      "text": "recipientInfo uses passwordRecipientInfo to allow easy testing with a fixed text string.",
      "ja": "RecipientInfoは、固定されたテキスト文字列で簡単にテストを許可するようにpasswordRecipientInfoを使用しています。"
    },
    {
      "indent": 6,
      "text": "authEncryptedContentInfo uses the authEnc128 pseudo-algorithm with a key of 128 bits used to derive triple DES/AES and HMAC-SHA1 keys.",
      "ja": "authEncryptedContentInfoは、トリプルDES / AESとHMAC-SHA1キーを導出するために使用される128ビットの鍵でauthEnc128擬似アルゴリズムを使用します。"
    },
    {
      "indent": 6,
      "text": "authAttrs aren't used and are omitted.",
      "ja": "authAttrsは使用されず、省略されています。"
    },
    {
      "indent": 6,
      "text": "mac is the 20-byte HMAC-SHA1 MAC value.",
      "ja": "MACは20バイトのHMAC-SHA1 MAC値です。"
    },
    {
      "indent": 6,
      "text": "unauthAttrs aren't used and are omitted.",
      "ja": "unauthAttrsは使用されず、省略されています。"
    },
    {
      "indent": 4,
      "text": " 0 227: SEQUENCE { 3 11: OBJECT IDENTIFIER id-ct-authEnvelopedData (1 2 840 113549 1 9 16 1 23) 16 211: [0] { 19 208: SEQUENCE { 22 1: INTEGER 0 25 97: SET { 27 95: [3] { 29 1: INTEGER 0 32 27: [0] { 34 9: OBJECT IDENTIFIER pkcs5PBKDF2 (1 2 840 113549 1 5 12) 45 14: SEQUENCE { 47 8: OCTET STRING B7 EB 23 A7 6B D2 05 16 57 2: INTEGER 5000 : } : } 61 35: SEQUENCE { 63 11: OBJECT IDENTIFIER pwriKEK (1 2 840 113549 1 9 16 3 9)",
      "ja": "0 227：SEQUENCE {3 11：オブジェクト識別子ID-CT-authEnvelopedData（1 2 840 113549 1 9 16 1 23）16 211：[0] {19 208：SEQUENCE {22 1：INTEGER 0 25 97：SET {27 95 [3] {29 1：INTEGER 0 32 27：[0] {34 9：OBJECT IDENTIFIER pkcs5PBKDF2（1 2 840 113549 1 5 12）45 14：SEQUENCE {47 8：OCTET STRING B7 EB 23 A7 6B D2 05 16 57 2：INTEGER：5000}} 61 35：SEQUENCE {63 11：OBJECT IDENTIFIER pwriKEK（1 2 840 113549 1 9 16 3 9）"
    },
    {
      "indent": 3,
      "text": " 76 20: SEQUENCE { 78 8: OBJECT IDENTIFIER des-EDE3-CBC (1 2 840 113549 3 7) 88 8: OCTET STRING 66 91 02 45 6B 73 BB 99 : } : } 98 24: OCTET STRING : 30 A3 7A B5 D8 F2 87 50 EC 41 04 AE 89 99 26 F0 : 2E AE 4F E3 F3 52 2B A3 : } : } 124 82: SEQUENCE { 126 9: OBJECT IDENTIFIER data (1 2 840 113549 1 7 1) 137 51: SEQUENCE { 139 11: OBJECT IDENTIFIER authEnc128 (1 2 840 113549 1 9 16 3 15) 152 36: SEQUENCE { 154 20: SEQUENCE { 156 8: OBJECT IDENTIFIER des-EDE3-CBC (1 2 840 113549 3 7) 166 8: OCTET STRING D2 D0 81 71 4D 3D 9F 11 : } 176 12: SEQUENCE { 178 8: OBJECT IDENTIFIER hmacSHA (1 3 6 1 5 5 8 1 2) 188 0: NULL : } : } : } 190 16: [0] 3A C6 06 61 41 5D 00 7D 11 35 CD 69 E1 56 CA 10 : } 208 20: OCTET STRING : 33 65 E8 F0 F3 07 06 86 1D A8 47 2C 6D 3A 1D 94 : 21 40 64 7E : } : } : }",
      "ja": "76 20：SEQUENCE {78 8：オブジェクト識別子DES-EDE3-CBC（1 2 840 113549 3 7）88 8：OCTET STRINGを66 91 02 45 6B 73 BB 99：}} 98 24：OCTET STRING：30 A3 7AはB5 D8 F2 87 50 EC 41 04 AE 89 99 26 F0：2E AE 4F E3 F3 52（b）A3：}} 124 82：SEQUENCE {126 9：オブジェクト識別子データ（1 2 840 113549 1 7 1）137 51：SEQUENCE { 139 11：OBJECT IDENTIFIER authEnc128（1 2 840 113549 1 9 16 3 15）152 36：SEQUENCE {154 20：SEQUENCE {156 8：オブジェクト識別子DES-EDE3-CBC（1 2 840 113549 3 7）166 8：OCTET STRING D2 D0 81 71 4D 3D 9F 11：} 176 12：SEQUENCE {178 8：オブジェクト識別子HMACSHA（1 3 6 1 5 8 1 2）188 0：NULL：}}} 190 16：[0] 3A C6 06 61 41（d）00 7D 11 35 CD 69 E1 56 CA 10：} 208 20：OCTET STRING：33 65 E8 F0 F3 07 06 86 1D A8 47（c）（d）（a）（d）94：21 40 64 7E：}}}"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PKCS7-----\nMIHjBgsqhkiG9w0BCRABF6CB0zCB0AIBADFho18CAQCgGwYJKoZIhvcNAQUMMA4E\nCLfrI6dr0gUWAgITiDAjBgsqhkiG9w0BCRADCTAUBggqhkiG9w0DBwQIZpECRWtz\nu5kEGDCjerXY8odQ7EEEromZJvAurk/j81IrozBSBgkqhkiG9w0BBwEwMwYLKoZI\nhvcNAQkQAw8wJDAUBggqhkiG9w0DBwQI0tCBcU09nxEwDAYIKwYBBQUIAQIFAIAQ\nOsYGYUFdAH0RNc1p4VbKEAQUM2Xo8PMHBoYdqEcsbTodlCFAZH4=\n-----END PKCS7-----",
      "raw": true
    },
    {
      "indent": 1,
      "text": " 0 253: SEQUENCE { 3 11: OBJECT IDENTIFIER id-ct-authEnvelopedData (1 2 840 113549 1 9 16 1 23) 16 237: [0] { 19 234: SEQUENCE { 22 1: INTEGER 0 25 114: SET { 27 112: [3] { 29 1: INTEGER 0 32 27: [0] { 34 9: OBJECT IDENTIFIER pkcs5PBKDF2 (1 2 840 113549 1 5 12) 45 14: SEQUENCE { 47 8: OCTET STRING E7 B7 87 DF 82 1D 12 CC 57 2: INTEGER 5000 : } : } 61 44: SEQUENCE { 63 11: OBJECT IDENTIFIER pwriKEK (1 2 840 113549 1 9 16 3 9) 76 29: SEQUENCE { 78 9: OBJECT IDENTIFIER aes128-CBC (2 16 840 1 101 3 4 1 2) 89 16: OCTET STRING : 11 D9 5C 52 0A 3A BF 22 B2 30 70 EF F4 7D 6E F6 : } : } 107 32: OCTET STRING : 18 39 22 27 C3 C2 2C 2A A6 9F 2A B0 77 24 75 AA : D8 58 9C CD BB 4C AE D3 0D C2 CB 1D 83 94 6C 37 : } : } 141 91: SEQUENCE { 143 9: OBJECT IDENTIFIER data (1 2 840 113549 1 7 1) 154 60: SEQUENCE { 156 11: OBJECT IDENTIFIER authEnc128 (1 2 840 113549 1 9 16 3 15) 169 45: SEQUENCE { 171 29: SEQUENCE { 173 9: OBJECT IDENTIFIER aes128-CBC (2 16 840 1 101 3 4 1 2) 184 16: OCTET STRING : B7 25 02 76 84 3C 58 1B A5 30 E2 40 27 EE C3 06 : }",
      "ja": "0 253：SEQUENCE {3 11：オブジェクト識別子ID-CT-authEnvelopedData（1 2 840 113549 1 9 16 1 23）16 237：[0] {19 234：SEQUENCE {22 1：INTEGER 0 25 114：SET {27 112 [3] {29 1：INTEGER 0 32 27：[0] {34 9：OBJECT IDENTIFIER pkcs5PBKDF2（1 2 840 113549 1 5 12）45 14：SEQUENCE {47 8：OCTET STRING E7 B7 87 DF 82 1D 12 CC 57 2：INTEGER：5000}} 61 44：SEQUENCE {63 11：OBJECT IDENTIFIER pwriKEK（1 2 840 113549 1 9 16 3 9）76 29：SEQUENCE {78 9：オブジェクト識別子AES128-CBC（2 16 840 1 101 3 4 1 2）89 16：OCTET STRING：11 D9 5C 52 0A 3AはBF 22 B2 30 70 EF F4 7D 6E F6：}} 107 32：OCTET STRING：18 39 22 27 C3 C2 2C 2A A6 9F 2AのB0 77 24 75 AA：D8 58 9C CD BB 4C AE D3 0D C2 CB 1D 83 94 6C 37：}} 141 91：SEQUENCE {143 9：オブジェクト識別子データ（1 2 840 113549 1 7 1）154 60：SEQUENCE {156 11：OBJECT IDENTIFIER authEnc128（1 2 840 113549 1 9 16 3 15）169 45：SEQUENCE {171 29：SEQUENCE {173 9：オブジェクト識別子AES128-CBC（2 16 840 1 101 3 4 1 2）184 16：OCTET STRING ：B7 25 02 76 84（c）58（b）A5 30 E2 40 27 EE C3 06：}"
    },
    {
      "indent": 1,
      "text": "202 12: SEQUENCE { 204 8: OBJECT IDENTIFIER hmacSHA (1 3 6 1 5 5 8 1 2) 214 0: NULL : } : } : } 216 16: [0] 98 36 0F 0C 79 62 36 B5 2D 2D 9E 1C 62 85 1E 10 : } 234 20: OCTET STRING : 88 A4 C1 B2 BA 78 1B CA F9 14 B0 E5 FC D1 8D F8 : 02 E2 B2 9E : } : } : }",
      "ja": "202 12：SEQUENCE {204 8：オブジェクト識別子HMACSHA（1 3 6 1 5 8 1 2）214 0：NULL：}}} 216 16：[0] 98 36 0F 0C 79 62 36 B5 2D 2D 9E 1C 62 85 1E 10：} 234 20：オクテットSTRING：88 A4 C1 B2 BA 78 1B CA F9 14 B0 E5 FC D1 8D F8：02 E2 B2の9E：}}}"
    },
    {
      "indent": 3,
      "text": "-----BEGIN PKCS7-----\nMIH9BgsqhkiG9w0BCRABF6CB7TCB6gIBADFyo3ACAQCgGwYJKoZIhvcNAQUMMA4E\nCOe3h9+CHRLMAgITiDAsBgsqhkiG9w0BCRADCTAdBglghkgBZQMEAQIEEBHZXFIK\nOr8isjBw7/R9bvYEIBg5IifDwiwqpp8qsHckdarYWJzNu0yu0w3Cyx2DlGw3MFsG\nCSqGSIb3DQEHATA8BgsqhkiG9w0BCRADDzAtMB0GCWCGSAFlAwQBAgQQtyUCdoQ8\nWBulMOJAJ+7DBjAMBggrBgEFBQgBAgUAgBCYNg8MeWI2tS0tnhxihR4QBBSIpMGy\nungbyvkUsOX80Y34AuKyng==\n-----END PKCS7-----",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. SMIMECapabilities Attribute",
      "section_title": true,
      "ja": "5. SMIMEケーパビリティは、属性"
    },
    {
      "indent": 3,
      "text": "An S/MIME client SHOULD announce the set of cryptographic functions that it supports by using the SMIMECapabilities attribute [SMIME]. If the client wishes to indicate support for MAC-authenticated encryption, the capabilities attribute MUST contain the authEnc128 and/or authEnc256 OID specified above with algorithm parameters ABSENT. The other algorithms used in the authEnc algorithm, such as the MAC and encryption algorithm, are selected based on the presence of these algorithms in the SMIMECapabilities attribute or by mutual agreement.",
      "ja": "S / MIMEクライアントは、それがSMIMEケーパビリティ[SMIME]属性を使用してサポートしている暗号化機能のセットを発表すべきです。クライアントがMAC認証暗号化のサポートを示すことを望む場合、機能属性がauthEnc128および/またはアルゴリズムパラメータABSENTして上に指定されたauthEnc256 OIDを含まなければなりません。そのようなMACおよび暗号化アルゴリズムとしてauthEncアルゴリズムで使用される他のアルゴリズムは、SMIMEケーパビリティ属性または相互の合意により、これらのアルゴリズムの存在に基づいて選択されます。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Unlike other CMS authenticated-data mechanisms, such as SignedData and AuthenticatedData, AuthEnv's primary transformation isn't authentication but encryption; so AuthEnvData may decrypt successfully (in other words, the primary data transformation present in the mechanism will succeed), but the secondary function of authentication using the MAC value that follows the encrypted data could still fail. This can lead to a situation in which an implementation might output decrypted data before it reaches and verifies the MAC value. In other words, decryption is performed inline and the result is available immediately, while the authentication result isn't available until all of the content has been processed. If the implementation prematurely provides data to the user and later comes back to inform them that the earlier data was, in retrospect, tainted, this may cause users to act prematurely on the tainted data.",
      "ja": "このようのSignedDataやAuthenticatedDataなどの他のCMS認証されたデータのメカニズムとは異なり、AuthEnvの主な変換は、認証が、暗号化ではありません。そうAuthEnvDataが正常に復号化することができる（換言すれば、成功する機構に存在する主データ変換）、まだ失敗する可能性が暗号化されたデータを次のMAC値を用いた認証の二次関数。これは、それが到達したとMAC値の検証を行う前に、実装はデータを出力する復号化された可能性のある状況につながることができます。換言すれば、解読はインラインで実行され、コンテンツのすべてが処理されるまで、認証結果が利用可能でないが、結果は、すぐに利用可能です。実装が途中でユーザにデータを提供し、後でそれ以前のデータは、振り返ってみると、汚染されたことを通知するために戻ってきた場合、これは、ユーザーが汚染されたデータに途中で行動する可能性があります。"
    },
    {
      "indent": 3,
      "text": "This situation could occur in a streaming implementation where data has to be made available as soon as possible (so that the initial plaintext is emitted before the final ciphertext and MAC value are read), or one where the quantity of data involved rules out buffering the recovered plaintext until the MAC value can be read and verified. In addition, an implementation that tries to be overly helpful may treat missing non-payload trailing data as non-fatal, allowing an attacker to truncate the data somewhere before the MAC value and thereby defeat the data authentication. This is complicated even further by the fact that an implementation may not be able to determine, when it encounters truncated data, whether the remainder (including the MAC value) will arrive presently (a non-failure) or whether it's been truncated by an attacker and should therefore be treated as a MAC failure. (Note that this same issue affects other types of data authentication like signed and MACed data as well, since an over-optimistic implementation may return data to the user before checking for a verification failure is possible.)",
      "ja": "このような状況は、データが（最終的な暗号文とMAC値が読み出される前に、最初の平文が放出されるように）可能な限り早く利用可能にしなければならない、またはデータの量がバッファリング外ルール関与する1つのストリーミングの実装で発生する可能性がMAC値を読み取って検証することができるようになるまで、平文を回復しました。また、過度に役立つことを試みる実装は、MAC値の前にどこかにデータを切り捨てることにより、データ認証を敗北させるために、攻撃者ができるように、致命的ではないような非ペイロード末尾の欠落データを扱うことがあります。これは、切り捨てられたデータに遭遇したとき（MAC値を含む）残りは現在の（非故障）に到着するかどうかの実装は、決定することができないかもしれないという事実によってさらに複雑化されるかどうか、それが攻撃者によって切り捨てられていしたがって、MAC不良として扱われるべきです。 （過剰楽観的実装が失敗が可能である検証をチェックする前に、ユーザにデータを返すことができるので、この同じ問題は、同様に署名しMACedデータのようなデータ認証の他のタイプに影響を与えることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "The exact solution to these issues is somewhat implementation-specific, with some suggested mitigations being as follows: implementations should buffer the entire message if possible and verify the MAC before performing any decryption. If this isn't possible due to streaming or message-size constraints, then implementations should consider breaking long messages into a sequence of smaller ones, each of which can be processed atomically as above. If even this isn't possible, then implementations should make obvious to the caller or user that an authentication failure has occurred and that the previously returned or output data shouldn't be used. Finally, any data-formatting problem, such as obviously truncated data or missing trailing data, should be treated as a MAC verification failure even if the rest of the data was processed correctly.",
      "ja": "実装が可能な場合、メッセージ全体をバッファリングし、任意の復号化を実行する前に、MACを検証するべきである：これらの問題に対する厳密解は、以下のようにいくつかの提案緩和策があると、幾分実装固有です。これが原因ストリーミングやメッセージサイズの制約のために不可能な場合は、実装は、上記のようにアトミックに処理することができ、それぞれが小さいもの、の順に長いメッセージを壊す検討すべきです。でも、これが不可能な場合、実装は、認証の失敗が発生した発信者または使用者に明らかにするべきであり、その前に返品出力データは使用すべきではありません。最後に、明らかに切り捨てられたデータまたは欠落末尾のデータなどの任意のデータの書式設定の問題は、残りのデータが正しく処理された場合でも、MAC検証失敗として扱われるべきです。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document contains two algorithm identifiers defined by the S/MIME Working Group Registrar in an arc delegated by RSA to the S/MIME Working Group: iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) modules(0).",
      "ja": "（2）米国（840）RSADSI（113549）PKCS（1 ISO（1）部材ボディ：この文書では、S / MIME作業部会にRSAによって委任円弧状にS / MIME作業部会レジストラによって定義された2つのアルゴリズム識別子が含まれています）PKCS-9（9）SMIME（16）モジュール（0）。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgements",
      "section_title": true,
      "ja": "8.謝辞"
    },
    {
      "indent": 3,
      "text": "The author would like to thank Jim Schaad and the members of the S/MIME mailing list for their feedback on this document, and David Ireland for help with the test vectors.",
      "ja": "著者は、テストベクトルとの助けのためにジムSchaad、このドキュメントの彼らのフィードバックのためのS / MIMEメーリングリストのメンバー、およびデビッド・アイルランドに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[AuthEnv] Housley, R., \"Cryptographic Message Syntax (CMS) Authenticated-Enveloped-Data Content Type\", RFC 5083, November 2007.",
      "ja": "[AuthEnv] Housley氏、R.、 \"暗号メッセージ構文（CMS）認証されたエンベロープ・データコンテンツの種類\"、RFC 5083、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[CMS] Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70, RFC 5652, September 2009.",
      "ja": "[CMS] Housley氏、R.、 \"暗号メッセージ構文（CMS）\"、STD 70、RFC 5652、2009年9月。"
    },
    {
      "indent": 3,
      "text": "[PBKDF2] Kaliski, B., \"PKCS #5: Password-Based Cryptography Specification Version 2\", RFC 2898, September 2000.",
      "ja": "[PBKDF2] Kaliski、B.、 \"PKCS＃5：パスワードベースの暗号化仕様バージョン2\"、RFC 2898、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[SMIME] Ramsdell, B. and S. Turner, \"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification\", RFC 5751, January 2010.",
      "ja": "[SMIME] Ramsdell、B.、およびS.ターナー、RFC 5751、2010年1月 \"/多目的インターネットメール拡張（S / MIME）バージョン3.2メッセージ仕様を固定\"。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[EncryptThenAuth] Krawczyk, H., \"The Order of Encryption and Authentication for Protecting Communications (or: How Secure Is SSL?)\", Springer-Verlag LNCS 2139, August 2001.",
      "ja": "[EncryptThenAuth] Krawczyk、H.、 \"通信を保護するための暗号化および認証の順序（または：？SSLどのように安全です）\"、シュプリンガー・フェアラークLNCS 2139、2001年8月。"
    },
    {
      "indent": 3,
      "text": "[Garfinkel] Garfinkel, S., \"Design Principles and Patterns for Computer Systems That Are Simultaneously Secure and Usable\", May 2005.",
      "ja": "[Garfinkel] Garfinkel、S.、「デザイン原則と同時に安全で使用可能なコンピュータシステムのためのパターン」、2005年5月。"
    },
    {
      "indent": 3,
      "text": "[HKDF] Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\", RFC 5869, May 2010.",
      "ja": "[HKDF] Krawczyk、H.、およびP. Eronen、 \"HMACベースの抽出物と、拡大鍵導出関数（HKDF）\"、RFC 5869、2010年5月。"
    },
    {
      "indent": 3,
      "text": "[IPsec] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[IPsecの]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[OpenPGP] Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, \"OpenPGP Message Format\", RFC 4880, November 2007.",
      "ja": "[OpenPGPの]カラス、J.、Donnerhacke、L.、フィニー、H.、ショー、D.、およびR.セイヤー、 \"OpenPGPのメッセージフォーマット\"、RFC 4880、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[SSH] Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell (SSH) Transport Layer Protocol\", RFC 4253, January 2006.",
      "ja": "[SSH] Ylonenと、T.とC. Lonvick、エド。、 \"セキュアシェル（SSH）トランスポート層プロトコル\"、RFC 4253、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[TLS] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[TLS]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Peter Gutmann University of Auckland Department of Computer Science New Zealand",
      "ja": "コンピュータサイエンスニュージーランドのオークランド部門のピーター・ガットマン大学"
    },
    {
      "indent": 3,
      "text": "EMail: pgut001@cs.auckland.ac.nz",
      "ja": "メールアドレス：pgut001@cs.auckland.ac.nz"
    }
  ]
}