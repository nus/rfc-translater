{
  "title": {
    "text": "RFC 6126 - The Babel Routing Protocol",
    "ja": "RFC 6126 - バベルルーティングプロトコル"
  },
  "number": 6126,
  "created_at": "2019-10-28 19:49:01.415071+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                     J. Chroboczek\nRequest for Comments: 6126                    PPS, University of Paris 7\nCategory: Experimental                                        April 2011\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 23,
      "text": "The Babel Routing Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Babel is a loop-avoiding distance-vector routing protocol that is robust and efficient both in ordinary wired networks and in wireless mesh networks.",
      "ja": "バベルは、通常の有線ネットワークおよび無線メッシュネットワークの両方堅牢かつ効率的であるループ回避距離ベクトルルーティングプロトコルです。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。これは、独立して、他のRFCストリームの、RFCシリーズへの貢献です。 RFC Editorはその裁量でこの文書を公開することを選択し、実装や展開のためにその値についての声明を出すていません。 RFC編集者によって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6126.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6126で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2011 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n  1.1.  Features . . . . . . . . . . . . . . . . . . . . . . . . .  3\n  1.2.  Limitations  . . . . . . . . . . . . . . . . . . . . . . .  4\n  1.3.  Specification of Requirements  . . . . . . . . . . . . . .  4\n2.  Conceptual Description of the Protocol . . . . . . . . . . . .  4\n  2.1.  Costs, Metrics, and Neighbourship  . . . . . . . . . . . .  5\n  2.2.  The Bellman-Ford Algorithm . . . . . . . . . . . . . . . .  5\n  2.3.  Transient Loops in Bellman-Ford  . . . . . . . . . . . . .  6\n  2.4.  Feasibility Conditions . . . . . . . . . . . . . . . . . .  6\n  2.5.  Solving Starvation: Sequencing Routes  . . . . . . . . . .  8\n  2.6.  Requests . . . . . . . . . . . . . . . . . . . . . . . . .  9\n  2.7.  Multiple Routers . . . . . . . . . . . . . . . . . . . . . 10\n  2.8.  Overlapping Prefixes . . . . . . . . . . . . . . . . . . . 11\n3.  Protocol Operation . . . . . . . . . . . . . . . . . . . . . . 11\n  3.1.  Message Transmission and Reception . . . . . . . . . . . . 11\n  3.2.  Data Structures  . . . . . . . . . . . . . . . . . . . . . 12\n  3.3.  Acknowledged Packets . . . . . . . . . . . . . . . . . . . 15\n  3.4.  Neighbour Acquisition  . . . . . . . . . . . . . . . . . . 15\n  3.5.  Routing Table Maintenance  . . . . . . . . . . . . . . . . 17\n  3.6.  Route Selection  . . . . . . . . . . . . . . . . . . . . . 21\n  3.7.  Sending Updates  . . . . . . . . . . . . . . . . . . . . . 22\n  3.8.  Explicit Route Requests  . . . . . . . . . . . . . . . . . 24\n4.  Protocol Encoding  . . . . . . . . . . . . . . . . . . . . . . 27\n  4.1.  Data Types . . . . . . . . . . . . . . . . . . . . . . . . 28\n  4.2.  Packet Format  . . . . . . . . . . . . . . . . . . . . . . 29\n  4.3.  TLV Format . . . . . . . . . . . . . . . . . . . . . . . . 29\n  4.4.  Details of Specific TLVs . . . . . . . . . . . . . . . . . 30\n5.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 39\n6.  Security Considerations  . . . . . . . . . . . . . . . . . . . 39\n7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n  7.1.  Normative References . . . . . . . . . . . . . . . . . . . 40\n  7.2.  Informative References . . . . . . . . . . . . . . . . . . 40\nAppendix A.  Cost and Metric Computation . . . . . . . . . . . . . 41\n  A.1.  Maintaining Hello History  . . . . . . . . . . . . . . . . 41\n  A.2.  Cost Computation . . . . . . . . . . . . . . . . . . . . . 42\n  A.3.  Metric Computation . . . . . . . . . . . . . . . . . . . . 43\nAppendix B.  Constants . . . . . . . . . . . . . . . . . . . . . . 43\nAppendix C.  Simplified Implementations  . . . . . . . . . . . . . 44\nAppendix D.  Software Availability . . . . . . . . . . . . . . . . 45",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Babel is a loop-avoiding distance-vector routing protocol that is designed to be robust and efficient both in networks using prefix-based routing and in networks using flat routing (\"mesh networks\"), and both in relatively stable wired networks and in highly dynamic wireless networks.",
      "ja": "バベルは、プレフィックス・ベースのルーティングを使用してネットワーク内及びフラットルーティング（「メッシュネットワーク」）を用いてネットワークで、比較的安定した有線ネットワークにおいて、高度の両方の両方堅牢かつ効率的であるように設計されたループ回避距離ベクトルルーティングプロトコルでありますダイナミックなワイヤレスネットワーク。"
    },
    {
      "indent": 0,
      "text": "1.1. Features",
      "section_title": true,
      "ja": "1.1. 特徴"
    },
    {
      "indent": 3,
      "text": "The main property that makes Babel suitable for unstable networks is that, unlike naive distance-vector routing protocols [RIP], it strongly limits the frequency and duration of routing pathologies such as routing loops and black-holes during reconvergence. Even after a mobility event is detected, a Babel network usually remains loop-free. Babel then quickly reconverges to a configuration that preserves the loop-freedom and connectedness of the network, but is not necessarily optimal; in many cases, this operation requires no packet exchanges at all. Babel then slowly converges, in a time on the scale of minutes, to an optimal configuration. This is achieved by using sequenced routes, a technique pioneered by Destination-Sequenced Distance-Vector routing [DSDV].",
      "ja": "不安定なネットワークのバベルが適して主性は、ナイーブ距離ベクトルルーティングプロトコル[RIP]とは異なり、それは強く、このような再コンバージェンス中にループとブラックホールルーティングなど病状のルーティングの頻度および持続時間を制限することです。モビリティイベントが検出された後も、バベルのネットワークは、通常、ループフリーのまま。バベルは、その後すぐに、ネットワークのループ自由とつながりを維持構成に再コンバージェンス、必ずしも最適ではありません。多くの場合、この操作は全くパケット交換を必要としません。バベルはゆっくり最適な構成に、数分のスケール上の時間に、収束します。これは、配列決定の経路、[DSDV]ルーティング先順距離ベクトルによって開発技術を使用することによって達成されます。"
    },
    {
      "indent": 3,
      "text": "More precisely, Babel has the following properties:",
      "ja": "より正確には、バベルは、次のプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "o when every prefix is originated by at most one router, Babel never suffers from routing loops;",
      "ja": "すべてのプレフィックスは最大1つのルータによって発信されたときに、O、バベルは、ルーティングループに苦しんでいることはありません。"
    },
    {
      "indent": 3,
      "text": "o when a prefix is originated by multiple routers, Babel may occasionally create a transient routing loop for this particular prefix; this loop disappears in a time proportional to its diameter, and never again (up to an arbitrary garbage-collection (GC) time) will the routers involved participate in a routing loop for the same prefix;",
      "ja": "プレフィックスが複数のルータによって発信されたときにO、バベルは時折、この特定のプレフィックスの過渡ルーティングループを作成することができます。このループは、その直径に比例する時間で消え、二度と（任意ガベージコレクション（GC）時間まで）関与のルータが同じプレフィックスのルーティングループに参加します。"
    },
    {
      "indent": 3,
      "text": "o assuming reasonable packet loss rates, any routing black-holes that may appear after a mobility event are corrected in a time at most proportional to the network's diameter.",
      "ja": "合理的なパケット損失率を想定してO、モビリティイベント後に表示される可能性のあるルーティングのブラックホールは、ネットワークの直径にせいぜい比例する時間で修正されています。"
    },
    {
      "indent": 3,
      "text": "Babel has provisions for link quality estimation and for fairly arbitrary metrics. When configured suitably, Babel can implement shortest-path routing, or it may use a metric based, for example, on measured packet loss.",
      "ja": "バベルは、リンク品質推定のため、かなり任意のメトリックの規定を持っています。適切に構成された場合、バベルは、最短パスルーティングを実装することができ、またはそれは、測定されたパケット損失に、例えば、ベースのメトリックを使用してもよいです。"
    },
    {
      "indent": 3,
      "text": "Babel nodes will successfully establish an association even when they are configured with different parameters. For example, a mobile node that is low on battery may choose to use larger time constants (hello and update intervals, etc.) than a node that has access to wall power. Conversely, a node that detects high levels of mobility may choose to use smaller time constants. The ability to build such heterogeneous networks makes Babel particularly adapted to the wireless environment.",
      "ja": "バベル・ノードが正常にそれらが異なるパラメータで設定されている場合でも、アソシエーションを確立します。例えば、バッテリの低いモバイルノードは、壁の電源へのアクセスを有するノードよりも大きな時定数（ハローと更新間隔、等）を使用することを選択してもよいです。逆に、モビリティの高いレベルを検出したノードは、より小さな時定数を使用することを選択することができます。そのような異種ネットワークを構築する能力は、バベルは、特に無線環境に適応します。"
    },
    {
      "indent": 3,
      "text": "Finally, Babel is a hybrid routing protocol, in the sense that it can carry routes for multiple network-layer protocols (IPv4 and IPv6), whichever protocol the Babel packets are themselves being carried over.",
      "ja": "最後に、バベルは、バベルパケットが自身が引き継がれているいずれかのプロトコル複数のネットワーク層プロトコル（IPv4およびIPv6）のためのルートを運ぶことができるという意味で、ハイブリッドルーティングプロトコルです。"
    },
    {
      "indent": 0,
      "text": "1.2. Limitations",
      "section_title": true,
      "ja": "1.2. 制限事項"
    },
    {
      "indent": 3,
      "text": "Babel has two limitations that make it unsuitable for use in some environments. First, Babel relies on periodic routing table updates rather than using a reliable transport; hence, in large, stable networks it generates more traffic than protocols that only send updates when the network topology changes. In such networks, protocols such as OSPF [OSPF], IS-IS [IS-IS], or the Enhanced Interior Gateway Routing Protocol (EIGRP) [EIGRP] might be more suitable.",
      "ja": "バベルは、一部の環境での使用には適さない2つの制限があります。まず、バベルは、定期的なルーティングテーブルの更新ではなく、信頼性の高いトランスポートを使用してに依存しています。したがって、大規模な、安定したネットワークでは、ネットワークトポロジの変更のみ更新を送信プロトコルよりも多くのトラフィックを生成します。そのようなネットワークでは、そのようなOSPF [OSPF]などのプロトコル、IS-IS、または拡張インテリアゲートウェイルーティングプロトコル（EIGRP）EIGRP]より適切かもしれない[-ISは、IS]。"
    },
    {
      "indent": 3,
      "text": "Second, Babel does impose a hold time when a prefix is retracted (Section 3.5.5). While this hold time does not apply to the exact prefix being retracted, and hence does not prevent fast reconvergence should it become available again, it does apply to any shorter prefix that covers it. Hence, if a previously deaggregated prefix becomes aggregated, it will be unreachable for a few minutes. This makes Babel unsuitable for use in mobile networks that implement automatic prefix aggregation.",
      "ja": "第二に、バベルは、接頭辞が後退するホールド時間（セクション3.5.5）を課します。このホールド時間が後退している正確な接頭辞には適用されませんし、それが再び利用可能になるはずですので、高速な再コンバージェンスを防ぐことはできませんが、それはそれをカバーして任意の短いプレフィックスに適用されません。以前邂逅プレフィックスが集約さになった場合したがって、それは数分間到達不能になります。これは、自動プレフィックス集約を実装するモバイルネットワークでの使用のためのバベルは適しません。"
    },
    {
      "indent": 0,
      "text": "1.3. Specification of Requirements",
      "section_title": true,
      "ja": "1.3. 要件の仕様"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Conceptual Description of the Protocol",
      "section_title": true,
      "ja": "議定書の2.概念の説明"
    },
    {
      "indent": 3,
      "text": "Babel is a mostly loop-free distance vector protocol: it is based on the Bellman-Ford protocol, just like the venerable RIP [RIP], but includes a number of refinements that either prevent loop formation altogether, or ensure that a loop disappears in a timely manner and doesn't form again.",
      "ja": "ちょうど由緒RIP [RIP]のように、それは、ベルマン - フォードプロトコルに基づいているが、完全にループの形成を防止、またはループに消えることを確認いずれかのことを改良点の数を含む：バベルは、主ループフリー距離ベクトルプロトコルでありますタイムリーかつ再び形成されません。"
    },
    {
      "indent": 3,
      "text": "Conceptually, Bellman-Ford is executed in parallel for every source of routing information (destination of data traffic). In the following discussion, we fix a source S; the reader will recall that the same algorithm is executed for all sources.",
      "ja": "概念的に、ベルマン・フォードは、ルーティング情報（データトラフィックの宛先）のすべてのソースに対して並列に実行されます。以下の議論では、我々はソースSを修正します。読者は、同じアルゴリズムがすべてのソースに対して実行されたことを思い出します。"
    },
    {
      "indent": 0,
      "text": "2.1. Costs, Metrics, and Neighbourship",
      "section_title": true,
      "ja": "2.1. コスト、メトリクス、およびNeighbourship"
    },
    {
      "indent": 3,
      "text": "As many routing algorithms, Babel computes costs of links between any two neighbouring nodes, abstract values attached to the edges between two nodes. We write C(A, B) for the cost of the edge from node A to node B.",
      "ja": "などの多くのルーティングアルゴリズムは、バベルは、任意の二つの隣接ノード間のリンクのコストを計算し、2つのノード間のエッジに取り付けられた抽象的な値。我々は、ノードAからノードBへのエッジのコストのためにC（A、B）を書き込みます"
    },
    {
      "indent": 3,
      "text": "Given a route between any two nodes, the metric of the route is the sum of the costs of all the edges along the route. The goal of the routing algorithm is to compute, for every source S, the tree of the routes of lowest metric to S.",
      "ja": "任意の2つのノード間の経路を考えると、経路のメトリックは、ルートに沿ったすべてのエッジのコストの合計です。ルーティングアルゴリズムの目標は、すべてのソースSのために、Sに最も低いメトリックのルートのツリーを計算することです"
    },
    {
      "indent": 3,
      "text": "Costs and metrics need not be integers. In general, they can be values in any algebra that satisfies two fairly general conditions (Section 3.5.2).",
      "ja": "コストとメトリックは整数である必要はありません。一般的に、彼らは、二つのかなり一般的な条件（3.5.2）を満たす任意の代数の値とすることができます。"
    },
    {
      "indent": 3,
      "text": "A Babel node periodically broadcasts Hello messages to all of its neighbours; it also periodically sends an IHU (\"I Heard You\") message to every neighbour from which it has recently heard a Hello. From the information derived from Hello and IHU messages received from its neighbour B, a node A computes the cost C(A, B) of the link from A to B.",
      "ja": "バベルのノードは、定期的にその隣人のすべてにメッセージをブロードキャストこんにちは。それはまた、定期的にそれが最近のHelloを聞いていたから、すべてのネイバーにIHU（「私はあなたを聞いた」）メッセージを送信します。その隣接Bから受信したハローとIHUメッセージから得られた情報から、ノードAからBへのリンクのコストC（A、B）を計算します"
    },
    {
      "indent": 0,
      "text": "2.2. The Bellman-Ford Algorithm",
      "section_title": true,
      "ja": "2.2. ベルマン・フォード・アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Every node A maintains two pieces of data: its estimated distance to S, written D(A), and its next-hop router to S, written NH(A). Initially, D(S) = 0, D(A) is infinite, and NH(A) is undefined.",
      "ja": "D（A）が書き込まSへの推定距離、及びSへのネクストホップルータ、書き込まNH（A）：すべてのノードAは、データの2つの部分を維持します。最初に、D（S）= 0、D（A）は無限大であり、NH（A）は未定義です。"
    },
    {
      "indent": 3,
      "text": "Periodically, every node B sends to all of its neighbours a route update, a message containing D(B). When a neighbour A of B receives the route update, it checks whether B is its selected next hop; if that is the case, then NH(A) is set to B, and D(A) is set to C(A, B) + D(B). If that is not the case, then A compares C(A, B) + D(B) to its current value of D(A). If that value is smaller, meaning that the received update advertises a route that is better than the currently selected route, then NH(A) is set to B, and D(A) is set to C(A, B) + D(B).",
      "ja": "定期的に、すべてのノードBは、その近隣のすべてに経路更新、D（B）を含むメッセージを送信します。 Bの隣接Aは、ルート更新を受信すると、Bは、その選択された次のホップであるかどうかをチェックします。その場合は、次に、NH（A）はBに設定され、D（A）は、C（A、B）+ D（B）に設定されています。それがない場合は、Aは、D（A）の現在の値をC（A、B）+ D（B）とを比較します。その値が小さい場合、受信した更新は、現在選択されたルートよりも優れているルートをアドバタイズすることを意味するが、その後、NH（A）はBに設定され、D（A）は、C（A、B）+ D（に設定されていますB）。"
    },
    {
      "indent": 3,
      "text": "A number of refinements to this algorithm are possible, and are used by Babel. In particular, convergence speed may be increased by sending unscheduled \"triggered updates\" whenever a major change in the topology is detected, in addition to the regular, scheduled updates. Additionally, a node may maintain a number of alternate routes, which are being advertised by neighbours other than its selected neighbour, and which can be used immediately if the selected route were to fail.",
      "ja": "このアルゴリズムの改良の数が可能であり、バベルで使用されています。具体的には、収束速度が予定外送信することによって増加させることができる「更新をトリガ」トポロジに大きな変化が検出されるたびに、定期的に、スケジュールされたアップデートに加えました。また、ノードは、その選択された隣接以外のネイバーによってアドバタイズされており、選択されたルートに障害が発生した場合、すぐに使用することができる代替ルートの数を維持することができます。"
    },
    {
      "indent": 0,
      "text": "2.3. Transient Loops in Bellman-Ford",
      "section_title": true,
      "ja": "2.3. ベルマン・フォードの過渡ループ"
    },
    {
      "indent": 3,
      "text": "It is well known that a naive application of Bellman-Ford to distributed routing can cause transient loops after a topology change. Consider for example the following diagram:",
      "ja": "よく分散ルーティングにベルマン・フォードの素朴なアプリケーションは、トポロジ変更後の過渡ループを引き起こすことが知られています。例えば次の図を考えてみましょう。"
    },
    {
      "indent": 3,
      "text": "         B\n      1 /|\n   1   / |\nS --- A  |1\n       \\ |\n      1 \\|\n         C",
      "raw": true
    },
    {
      "indent": 3,
      "text": "After convergence, D(B) = D(C) = 2, with NH(B) = NH(C) = A.",
      "ja": "収束後、D（B）= NH（B）とD（C）= 2、= NH（C）= A."
    },
    {
      "indent": 3,
      "text": "Suppose now that the link between S and A fails:",
      "ja": "SとAの間のリンクに障害が発生したことを今仮定します。"
    },
    {
      "indent": 3,
      "text": " B 1 /| / | S A |1 \\ | 1 \\| C",
      "ja": "B 1 / | / | S A | 1 \\ | 1 \\ | C"
    },
    {
      "indent": 3,
      "text": "When it detects the failure of the link, A switches its next hop to B (which is still advertising a route to S with metric 2), and advertises a metric equal to 3, and then advertises a new route with metric 3. This process of nodes changing selected neighbours and increasing their metric continues until the advertised metric reaches \"infinity\", a value larger than all the metrics that the routing protocol is able to carry.",
      "ja": "それはリンクの障害を検出したとき、Aは（まだメトリック2とSへのルートをアドバタイズしている）Bへの次のホップを切り替え、3に等しいメトリックをアドバタイズし、次にメトリック3.このプロセスに新しいルートをアドバタイズノードの選択されたネイバーを変更し、そのメトリックを増加アドバタイズメトリックは、ルーティングプロトコルを実行することができるすべてのメトリックよりも大きい値を「無限」に達するまで続きます。"
    },
    {
      "indent": 0,
      "text": "2.4. Feasibility Conditions",
      "section_title": true,
      "ja": "2.4. フィージビリティ条件"
    },
    {
      "indent": 3,
      "text": "Bellman-Ford is a very robust algorithm: its convergence properties are preserved when routers delay route acquisition or when they discard some updates. Babel routers discard received route announcements unless they can prove that accepting them cannot possibly cause a routing loop.",
      "ja": "ベルマン・フォードは非常に堅牢なアルゴリズムである：彼らはいくつかの更新を破棄したときにルータがルートの取得を遅らせる場合、またはその収束性が保持されています。彼らはそれらを受け入れることは、おそらく、ルーティングループが発生することができないことを証明できない限りバベルルータは、受信したルートアナウンスを捨てます。"
    },
    {
      "indent": 3,
      "text": "More formally, we define a condition over route announcements, known as the feasibility condition, that guarantees the absence of routing loops whenever all routers ignore route updates that do not satisfy the feasibility condition. In effect, this makes Bellman-Ford into a family of routing algorithms, parameterised by the feasibility condition.",
      "ja": "より正式に、私たちは、すべてのルータが到達可能条件を満たしていないルート更新を無視するたびに、ルーティングループがないことを保証して実現可能性条件、として知られているルートのアナウンス、上の条件を定義します。実際には、これは、実行可能性条件によってパラメータ化ルーティングアルゴリズムのファミリーにベルマン・フォードを行います。"
    },
    {
      "indent": 3,
      "text": "Many different feasibility conditions are possible. For example, BGP can be modelled as being a distance-vector protocol with a (rather drastic) feasibility condition: a routing update is only accepted when the receiving node's AS number is not included in the update's AS-Path attribute (note that BGP's feasibility condition does not ensure the absence of transitory \"micro-loops\" during reconvergence).",
      "ja": "多くの異なる可能性の条件が可能です。例えば、BGPは、（むしろ劇的）実行可能性条件と距離ベクトルプロトコルであるとしてモデル化することができる：受信ノードのAS番号が更新のAS-Path属性に含まれていない場合、ルーティング更新のみ受け付けられる（すなわちBGPの実現可能性に注意してください条件は、再収束時一過「マイクロループ」）が存在しないことを保証するものではありません。"
    },
    {
      "indent": 3,
      "text": "Another simple feasibility condition, used in Destination-Sequenced Distance-Vector (DSDV) routing [DSDV] and in Ad hoc On-Demand Distance Vector (AODV) routing, stems from the following observation: a routing loop can only arise after a router has switched to a route with a larger metric than the route that it had previously selected. Hence, one could decide that a route is feasible only when its metric at the local node would be no larger than the metric of the currently selected route, i.e., an announcement carrying a metric D(B) is accepted by A when C(A, B) + D(B) <= D(A). If all routers obey this constraint, then the metric at every router is nonincreasing, and the following invariant is always preserved: if A has selected B as its successor, then D(B) < D(A), which implies that the forwarding graph is loop-free.",
      "ja": "[DSDV]とアドホックオンデマンド距離ベクトル（AODV）ルーティングでは、ルーティング先順距離ベクトル（DSDV）で使用される別の簡単な実現可能性の条件は、以下の観察から茎：ルータが持っている後に、ルーティングループにのみ発生する可能性がそれは以前に選択したことの経路よりも大きなメトリックを持つルートに切り替えます。したがって、一つの経路は、ローカル・ノードで、そのメトリックは、現在選択された経路、すなわちのメトリックよりも大きくないであろう場合にのみ、メトリックD（B）を担持するアナウンスがA C（によって受け入れられる可能であることを決定することができ、B）+ D（B）<= D（A）。すべてのルータがこの制約に従う場合には、すべてのルータにおけるメトリックは非増加され、そして以下の不変量は、常に保存され：Aは、転送グラフことを意味し、その後継、次にD（B）<D（A）としてBを選択した場合ループフリーです。"
    },
    {
      "indent": 3,
      "text": "Babel uses a slightly more refined feasibility condition, used in EIGRP [DUAL]. Given a router A, define the feasibility distance of A, written FD(A), as the smallest metric that A has ever advertised for S to any of its neighbours. An update sent by a neighbour B of A is feasible when the metric D(B) advertised by B is strictly smaller than A's feasibility distance, i.e., when D(B) < FD(A).",
      "ja": "バベルはEIGRP [DUAL]で使用されるやや洗練実行可能性条件を使用します。ルータAを考えると、Aはこれまでその隣人のいずれかにSのために広告していることを、最小のメトリックとしてA、書かれたFD（A）、実現可能性の距離を定義します。 BによってアドバタイズメトリックD（B）は、すなわち、場合D（B）<FD（A）、Aの実現可能距離よりも厳密に小さい場合、Aの隣接Bによって送信された更新が可能です。"
    },
    {
      "indent": 3,
      "text": "It is easy to see that this latter condition is no more restrictive than DSDV-feasibility. Suppose that node A obeys DSDV-feasibility; then D(A) is nonincreasing, hence at all times D(A) <= FD(A). Suppose now that A receives a DSDV-feasible update that advertises a metric D(B). Since the update is DSDV-feasible, C(A, B) + D(B) <= D(A), hence D(B) < D(A), and since D(A) <= FD(A), D(B) < FD(A).",
      "ja": "この後者の条件は、DSDV、実現可能性よりも何より制限されていないことを確認することは容易です。ノードAは、DSDV-実現可能性に従うと仮定する。次に、D（A）は、従って、常にD（A）<= FD（A）において、非増加されます。今AメトリックD（B）をアドバタイズDSDV-可能アップデートを受信すると仮定する。更新がDSDV-可能であるため、C（A、B）+ D（B）<= D（A）、したがってD（B）<D（A）、及びD（A）<= FD（A）ので、 D（B）<FD（A）。"
    },
    {
      "indent": 3,
      "text": "To see that it is strictly less restrictive, consider the following diagram, where A has selected the route through B, and D(A) = FD(A) = 2. Since D(C) = 1 < FD(A), the alternate route through C is feasible for A, although its metric C(A, C) + D(C) = 5 is larger than that of the currently selected route:",
      "ja": "それは厳密に小さい制限であることを確認するために、AがBを通るルートを選択している以下の図を考慮し、D（A）= FD（A）= 2であるのでD（C）= 1 <FD（A）、 Cを介して代替ルートがAのために実行可能で、そのメトリックC（A、C）が+ D（C）= 5、現在選択されたルートよりも大きいです。"
    },
    {
      "indent": 3,
      "text": " B 1 / \\ 1 / \\ S A \\ / 1 \\ / 4 C",
      "ja": "B 1 / \\ 1 / \\ S A \\ / 1 \\ / 4 C"
    },
    {
      "indent": 3,
      "text": "To show that this feasibility condition still guarantees loop-freedom, recall that at the time when A accepts an update from B, the metric D(B) announced by B is no smaller than FD(B); since it is smaller than FD(A), at that point in time FD(B) < FD(A). Since this property is preserved when A sends updates, it remains true at all times, which ensures that the forwarding graph has no loops.",
      "ja": "この実行可能性条件は依然としてループ自由を保証することを示すために、AがBから更新を受け付ける時、Bが発表メトリックD（B）はFD（B）よりも小さくないことを想起されたいです。それは時間FD（B）<FD（A）中のその時点で、FD（A）よりも小さくなっているからです。 Aが更新を送信するときに、このプロパティが保存されているので、それはフォワーディンググラフは何のループを持っていないことが保証され、常に真です。"
    },
    {
      "indent": 0,
      "text": "2.5. Solving Starvation: Sequencing Routes",
      "section_title": true,
      "ja": "2.5. 解決飢餓：シーケンシングルート"
    },
    {
      "indent": 3,
      "text": "Obviously, the feasibility conditions defined above cause starvation when a router runs out of feasible routes. Consider the following diagram, where both A and B have selected the direct route to S:",
      "ja": "ルータが実現可能なルートを使い果たしたときに明らかに、実現可能性の条件が原因の飢餓上で定義されました。 AとBの両方がSへの直接の経路を選択している以下の図を考慮してください。"
    },
    {
      "indent": 3,
      "text": " A 1 /| D(A) = 1 / | FD(A) = 1 S |1 \\ | D(B) = 2 2 \\| FD(B) = 2 B",
      "ja": "1 / | D（A）= 1 / | FD（A）= 1つのS | 1 \\ | D（B）= 2 2 \\ | FD（B）= 2 B"
    },
    {
      "indent": 3,
      "text": "Suppose now that the link between A and S breaks:",
      "ja": "AとSの間のリンクが壊れていることになりましたと仮定します。"
    },
    {
      "indent": 3,
      "text": " A | | FD(A) = 1 S |1 \\ | D(B) = 2 2 \\| FD(B) = 2 B",
      "ja": "| | FD（A）= 1つのS | 1 \\ | D（B）= 2 2 \\ | FD（B）= 2 B"
    },
    {
      "indent": 3,
      "text": "The only route available from A to S, the one that goes through B, is not feasible: A suffers from a spurious starvation.",
      "ja": "Sへの利用可能な唯一の経路Bを経由一つは、不可能である：Aが偽飢餓に苦しんでいます。"
    },
    {
      "indent": 3,
      "text": "At this point, the whole network must be rebooted in order to solve the starvation; this is essentially what EIGRP does when it performs a global synchronisation of all the routers in the network with the source (the \"active\" phase of EIGRP).",
      "ja": "この時点で、ネットワーク全体の飢餓を解決するために再起動しなければなりません。これは、ソース（EIGRPの「能動的」相）を用いて、ネットワーク内のすべてのルータのグローバル同期化を行う際にEIGRPが何をするか、本質的です。"
    },
    {
      "indent": 3,
      "text": "Babel reacts to starvation in a less drastic manner, by using sequenced routes, a technique introduced by DSDV and adopted by AODV. In addition to a metric, every route carries a sequence number, a nondecreasing integer that is propagated unchanged through the network and is only ever incremented by the source; a pair (s, m), where s is a sequence number and m a metric, is called a distance.",
      "ja": "バベルは、技術がDSDVによって導入とAODVによって採用された、配列決定されたルートを使用して、以下大幅な方法で飢餓に反応します。メトリックに加えて、すべてのルートは、シーケンス番号、ネットワークを介して不変伝播される非減少整数を担持ししか源によってインクリメントされます。 Sメトリックシーケンス番号であり、M対（S、M）は、距離と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "A received update is feasible when either it is more recent than the feasibility distance maintained by the receiving node, or it is equally recent and the metric is strictly smaller. More formally, if FD(A) = (s, m), then an update carrying the distance (s', m') is feasible when either s' > s, or s = s' and m' < m.",
      "ja": "どちらかが受信ノードによって維持される可能性の距離よりも新しい、またはそれが等しく最近あり、メトリックが厳密に小さい場合、受信した更新が可能です。より正式に、FD（A）=（S、M）は、その後、距離（S'、M '）を担持し、更新が可能であれば場合のいずれかS'> S、又はS = S'及びM」<M。"
    },
    {
      "indent": 3,
      "text": "Assuming the sequence number of S is 137, the diagram above becomes:",
      "ja": "Sのシーケンス番号が137であると仮定すると、図は、上記のようになります。"
    },
    {
      "indent": 3,
      "text": " A | | FD(A) = (137, 1) S |1 \\ | D(B) = (137, 2) 2 \\| FD(B) = (137, 2) B",
      "ja": "| | FD（A）=（137、1）S | 1 \\ | D（B）=（137、2）2 \\ | FD（B）=（137、2）B"
    },
    {
      "indent": 3,
      "text": "After S increases its sequence number, and the new sequence number is propagated to B, we have:",
      "ja": "Sは、そのシーケンス番号を増加させ、新しいシーケンス番号がBに伝播された後、我々は持っています："
    },
    {
      "indent": 3,
      "text": " A | | FD(A) = (137, 1) S |1 \\ | D(B) = (138, 2) 2 \\| FD(B) = (138, 2) B",
      "ja": "| | FD（A）=（137、1）S | 1 \\ | D（B）=（138、2）2 \\ | FD（B）=（138、2）B"
    },
    {
      "indent": 3,
      "text": "at which point the route through B becomes feasible again.",
      "ja": "その時点でBを通るルートが再び可能となります。"
    },
    {
      "indent": 3,
      "text": "Note that while sequence numbers are used for determining feasibility, they are not necessarily used in route selection: a node will normally ignore the sequence number when selecting a route (Section 3.6).",
      "ja": "経路（セクション3.6）を選択するとき、ノードは、通常、シーケンス番号を無視する：シーケンス番号が実現可能性を決定するために使用されているが、それらは必ずしも経路選択に使用されていないことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "2.6. Requests",
      "section_title": true,
      "ja": "2.6. リクエスト"
    },
    {
      "indent": 3,
      "text": "In DSDV, the sequence number of a source is increased periodically. A route becomes feasible again after the source increases its sequence number, and the new sequence number is propagated through the network, which may, in general, require a significant amount of time.",
      "ja": "DSDVにおいて、ソースのシーケンス番号は、定期的に増加させます。ソースは、そのシーケンス番号を増加させ、新たなシーケンス番号は、一般的に、かなりの時間を必要とするかもしれないネットワークを介して伝播された後、ルートが再び可能となります。"
    },
    {
      "indent": 3,
      "text": "Babel takes a different approach. When a node detects that it is suffering from a potentially spurious starvation, it sends an explicit request to the source for a new sequence number. This request is forwarded hop by hop to the source, with no regard to the feasibility condition. Upon receiving the request, the source increases its sequence number and broadcasts an update, which is forwarded to the requesting node.",
      "ja": "バベルは異なるアプローチを採用しています。ノードは、それが潜在的に偽の飢餓に苦しんでいることを検出すると、それは、新しいシーケンス番号のソースへの明示的な要求を送信します。この要求は、実行可能性条件とは関係なく、ソースにホップすることによってホップに転送されます。要求を受信すると、ソースはそのシーケンス番号を増加させ、要求ノードに転送された更新プログラムを、ブロードキャストします。"
    },
    {
      "indent": 3,
      "text": "Note that after a change in network topology not all such requests will, in general, reach the source, as some will be sent over links that are now broken. However, if the network is still connected, then at least one among the nodes suffering from spurious starvation has an (unfeasible) route to the source; hence, in the absence of packet loss, at least one such request will reach the source. (Resending requests a small number of times compensates for packet loss.)",
      "ja": "いくつかは今壊れているリンク上で送信されますよう、ネットワークトポロジの変更後に、すべてのそのような要求は、一般的には、元に達するないことに注意してください。しかし、ネットワークがまだ接続されている場合、スプリアス飢餓に罹患しているノードのうち、次に少なくとも一つのソースに（不可能）経路を有しています。したがって、パケット損失の非存在下で、少なくとも一つのそのような要求は、ソースに到達します。 （の再送は、少ない回数は、パケット損失を補償する要求します。）"
    },
    {
      "indent": 3,
      "text": "Since requests are forwarded with no regard to the feasibility condition, they may, in general, be caught in a forwarding loop; this is avoided by having nodes perform duplicate detection for the requests that they forward.",
      "ja": "要求が実行可能性条件に関係なくして転送されるので、それらは、一般的には、転送ループに陥ることができます。これは、ノードが、彼らは転送要求のための重複検出を行うことによって回避されます。"
    },
    {
      "indent": 0,
      "text": "2.7. Multiple Routers",
      "section_title": true,
      "ja": "2.7. 複数のルータ"
    },
    {
      "indent": 3,
      "text": "The above discussion assumes that every prefix is originated by a single router. In real networks, however, it is often necessary to have a single prefix originated by multiple routers; for example, the default route will be originated by all of the edge routers of a routing domain.",
      "ja": "上記の議論は、すべての接頭辞は、単一のルータによって発信されていることを前提としています。実際のネットワークでは、しかし、複数のルータによって発信され、単一の接頭辞を持つことがしばしば必要です。例えば、デフォルトルートは、ルーティングドメインのエッジルータのすべてによって発信されるであろう。"
    },
    {
      "indent": 3,
      "text": "Since synchronising sequence numbers between distinct routers is problematic, Babel treats routes for the same prefix as distinct entities when they are originated by different routers: every route announcement carries the router-id of its originating router, and feasibility distances are not maintained per prefix, but per source, where a source is a pair of a router-id and a prefix. In effect, Babel guarantees loop-freedom for the forwarding graph to every source; since the union of multiple acyclic graphs is not in general acyclic, Babel does not in general guarantee loop-freedom when a prefix is originated by multiple routers, but any loops will be broken in a time at most proportional to the diameter of the loop -- as soon as an update has \"gone around\" the routing loop.",
      "ja": "異なるルータ間のシーケンス番号を同期化する問題があるので、それらが異なるルータによって発信された場合、バベルは、別個のエンティティとして同じプレフィックスのルートを扱う：すべての経路アナウンスメントは、その発信元ルータのルータIDを搬送し、実行可能性距離は、プレフィックスごとに維持されていませんしかし、ソースがルータIDとプレフィックスの組であるソース、あたり。実際には、バベルは、すべてのソースに転送グラフのループの自由を保証します。複数の非環式のグラフの労働組合は、一般的な非環式ではないのでプレフィックスが複数のルータによって発信されていますが、ループは、せいぜい比例ループの直径までの時間に分割されますと、バベルは、一般的な保証ループ自由でありません -  - できるだけ早く更新は、ルーティングループ「の周りに行って」いるとして。"
    },
    {
      "indent": 3,
      "text": "Consider for example the following diagram, where A has selected the default route through S, and B has selected the one through S':",
      "ja": "例えば、AがSを介してデフォルトルートを選択した、及びB 'はSを介していずれかを選択した次の図を考えます。"
    },
    {
      "indent": 3,
      "text": "           1     1     1\n::/0 -- S --- A --- B --- S' -- ::/0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Suppose that both default routes fail at the same time; then nothing prevents A from switching to B, and B simultaneously switching to A. However, as soon as A has successfully advertised the new route to B, the route through A will become unfeasible for B. Conversely, as soon as B will have advertised the route through A, the route through B will become unfeasible for A.",
      "ja": "両方のデフォルトルートが同時に故障したと。その後、何も、すぐにAが正常にBへの新しい経路を広告しているように、Bへの切り替え、およびBが同時にしかしA.への切り替えからAを妨げるものはない、を通るルートは逆に、できるだけ早くBとして宣伝しているだろうB.ために実行不可能になりますA、Bを通る経路を通るルートがAに対して実行不可能になるであろう"
    },
    {
      "indent": 3,
      "text": "In effect, the routing loop disappears at the latest when routing information has gone around the loop. Since this process can be delayed by lost packets, Babel makes certain efforts to ensure that updates are sent reliably after a router-id change.",
      "ja": "ルーティング情報がループの周りに行った時に有効で、ルーティングループが最新で消えます。このプロセスは、失われたパケットによって遅延させることができるので、バベルは更新がルータIDの変更後に確実に送信されることを保証するために一定の努力を払っています。"
    },
    {
      "indent": 3,
      "text": "Additionally, after the routers have advertised the two routes, both sources will be in their source tables, which will prevent them from ever again participating in a routing loop involving routes from S and S' (up to the source GC time, which, available memory permitting, can be set to arbitrarily large values).",
      "ja": "ルータが2つのルートをアドバタイズした後、さらに、両方のソースは二度と（ソースGC時間までのSとS」からのルートを含むルーティングループに参加してからそれらを防ぐことができますされ、そのソース表になり利用できました、メモリ許可が）任意の大きな値に設定することができます。"
    },
    {
      "indent": 0,
      "text": "2.8. Overlapping Prefixes",
      "section_title": true,
      "ja": "2.8. 重複プレフィックス"
    },
    {
      "indent": 3,
      "text": "In the above discussion, we have assumed that all prefixes are disjoint, as is the case in flat (\"mesh\") routing. In practice, however, prefixes may overlap: for example, the default route overlaps with all of the routes present in the network.",
      "ja": "上記の議論において、我々は、フラット（「メッシュ」）ルーティングの場合のようにすべてのプレフィックスは、互いに素であると仮定しています。しかし、実際には、接頭辞が重複してもよい：例えば、デフォルトルートは、ネットワーク内に存在する経路の全てと重なります。"
    },
    {
      "indent": 3,
      "text": "After a route fails, it is not correct in general to switch to a route that subsumes the failed route. Consider for example the following configuration:",
      "ja": "ルートが失敗した後、それが失敗したルートを包含した経路に切り替えるには、一般的には正しくありません。例えば次のような構成を考えてみましょう。"
    },
    {
      "indent": 3,
      "text": "           1     1\n::/0 -- A --- B --- C",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Suppose that node C fails. If B forwards packets destined to C by following the default route, a routing loop will form, and persist until A learns of B's retraction of the direct route to C. Babel avoids this pitfall by maintaining an \"unreachable\" route for a few minutes after a route is retracted; the time for which such a route must be maintained should be the worst-case propagation time of the retraction of the route to C.",
      "ja": "ノードCに障害が発生したと仮定します。 Bは、デフォルトルートに従うことによってC宛てのパケットを転送する場合、ルーティングループが形成され、C.バベルへの直接経路のBの後退を学習の後数分間「到達不能」経路を維持することによって、この落とし穴を回避するまで存続しますルートを退避させます。そのような経路が維持されなければならない時間は、Cまでの経路の後退の最悪の場合の伝播時間であるべきです"
    },
    {
      "indent": 0,
      "text": "3. Protocol Operation",
      "section_title": true,
      "ja": "3.プロトコル動作"
    },
    {
      "indent": 3,
      "text": "Every Babel speaker is assigned a router-id, which is an arbitrary string of 8 octets that is assumed unique across the routing domain. We suggest that router-ids should be assigned in modified EUI-64 format [ADDRARCH]. (As a matter of fact, the protocol encoding is slightly more compact when router-ids are assigned in the same manner as the IPv6 layer assigns host IDs.)",
      "ja": "すべてのバベルスピーカーは、ルーティングドメイン全体で一意のものとする8つのオクテットの任意の文字列であるルータIDを割り当てられます。私たちは、ルータIDが変更さEUI-64形式[ADDRARCH]に割り当てられるべきであることを示唆しています。 （IPv6の層は、ホストIDを割り当てるようにルータIDが同じように割り当てられている場合、実際の問題として、プロトコル符号化は、わずかによりコンパクトです。）"
    },
    {
      "indent": 0,
      "text": "3.1. Message Transmission and Reception",
      "section_title": true,
      "ja": "3.1. メッセージ送受信"
    },
    {
      "indent": 3,
      "text": "Babel protocol packets are sent in the body of a UDP datagram. Each Babel packet consists of one or more TLVs.",
      "ja": "バベルプロトコルパケットは、UDPデータグラムの本体に送信されます。各バベルパケットは、一の以上のTLVで構成されています。"
    },
    {
      "indent": 3,
      "text": "The source address of a Babel packet is always a unicast address, link-local in the case of IPv6. Babel packets may be sent to a well-known (link-local) multicast address (this is the usual case) or to a (link-local) unicast address. In normal operation, a Babel speaker sends both multicast and unicast packets to its neighbours.",
      "ja": "バベルパケットの送信元アドレスは、常にユニキャストアドレス、リンクローカルIPv6の場合です。バベルパケットはよく知られている（リンクローカル）マルチキャストアドレスに送信され（これは通常の場合である）、または（リンクローカル）のユニキャストアドレスにしてもよいです。通常の動作では、バベルスピーカーはその近隣にマルチキャストおよびユニキャストパケットの両方を送信します。"
    },
    {
      "indent": 3,
      "text": "With the exception of Hello TLVs and acknowledgements, all Babel TLVs can be sent to either unicast or multicast addresses, and their semantics does not depend on whether the destination was a unicast or multicast address. Hence, a Babel speaker does not need to determine the destination address of a packet that it receives in order to interpret it.",
      "ja": "こんにちはのTLVと謝辞を除いて、すべてのバベルのTLVは、ユニキャストまたはマルチキャストアドレスに送信することができ、その意味は、宛先がユニキャストまたはマルチキャストアドレスであったかどうかには依存しません。したがって、バベルのスピーカーは、それはそれを解釈するために、受信パケットの宛先アドレスを決定する必要がありません。"
    },
    {
      "indent": 3,
      "text": "A moderate amount of jitter is applied to packets sent by a Babel speaker: outgoing TLVs are buffered and SHOULD be sent with a small random delay. This is done for two purposes: it avoids synchronisation of multiple Babel speakers across a network [JITTER], and it allows for the aggregation of multiple TLVs into a single packet.",
      "ja": "ジッタの適度な量は、バベルのスピーカーによって送信されたパケットに適用されます：送信TLVがバッファされ、小さなランダムな遅延で送ってください。これは2つの目的のために行われます。それは[JITTER】ネットワークを介して複数バベルスピーカの同期化を回避し、それが単一のパケットに複数のTLVの集約を可能にします。"
    },
    {
      "indent": 3,
      "text": "The exact delay and amount of jitter applied to a packet depends on whether it contains any urgent TLVs. Acknowledgement TLVs MUST be sent before the deadline specified in the corresponding request. The particular class of updates specified in Section 3.7.2 MUST be sent in a timely manner. The particular class of request and update TLVs specified in Section 3.8.2 SHOULD be sent in a timely manner.",
      "ja": "パケットに適用されるジッタの正確な遅延および量は、それがどんな緊急TLVを含んでいるかどうかに依存します。謝辞のTLVは、対応する要求に指定された期限までに送らなければなりません。セクション3.7.2で指定されたアップデートの特定のクラスは、タイムリーに送らなければなりません。セクション3.8.2で指定された要求と更新のTLVの特定のクラスは、タイムリーに送ってください。"
    },
    {
      "indent": 0,
      "text": "3.2. Data Structures",
      "section_title": true,
      "ja": "3.2. データ構造"
    },
    {
      "indent": 3,
      "text": "Every Babel speaker maintains a number of data structures.",
      "ja": "すべてのバベルのスピーカーは、データ構造の数を維持します。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Sequence Number",
      "section_title": true,
      "ja": "3.2.1. シーケンス番号"
    },
    {
      "indent": 3,
      "text": "A node's sequence number is a 16-bit integer that is included in route updates sent for routes originated by this node. A node increments its sequence number (modulo 2^16) whenever it receives a request for a new sequence number (Section 3.8.1.2).",
      "ja": "ノードのシーケンス番号がこのノードによって発信されたルートのために送信された経路更新に含まれている16ビットの整数です。それは新たなシーケンス番号（セクション3.8.1.2）の要求を受信するたびにノードがシーケンス番号（モジュロ2 ^ 16）をインクリメントします。"
    },
    {
      "indent": 3,
      "text": "A node SHOULD NOT increment its sequence number (seqno) spontaneously, since increasing seqnos makes it less likely that other nodes will have feasible alternate routes when their selected routes fail.",
      "ja": "seqnosを増加させると、その選択されたルートが失敗した場合に他のノードが実行可能な代替経路を有することになることが少ないことになるので、ノードは、自発的にそのシーケンス番号（SEQNO）をインクリメントすべきではありません。"
    },
    {
      "indent": 0,
      "text": "3.2.2. The Interface Table",
      "section_title": true,
      "ja": "3.2.2. インタフェース表"
    },
    {
      "indent": 3,
      "text": "The interface table contains the list of interfaces on which the node speaks the Babel protocol. Every interface table entry contains the interface's Hello seqno, a 16-bit integer that is sent with each",
      "ja": "インタフェーステーブルは、ノードがバベルプロトコルを話しているインターフェイスのリストを含みます。すべてのインターフェース・テーブル・エントリは、インタフェースのHello seqnoが、それぞれに送信される16ビットの整数が含まれています"
    },
    {
      "indent": 3,
      "text": "Hello TLV on this interface and is incremented (modulo 2^16) whenever a Hello is sent. (Note that an interface's Hello seqno is unrelated to the node's seqno.)",
      "ja": "このインターフェイス上及びハローが送信されたとき（モジュロ2 ^ 16）インクリメントされるTLVこんにちは。 （インターフェースのHello SEQNOは、ノードのSEQNOとは無関係であることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "There are two timers associated with each interface table entry -- the Hello timer, which governs the sending of periodic Hello and IHU packets, and the update timer, which governs the sending of periodic route updates.",
      "ja": "定期的こんにちは、IHUパケットの送信を支配Helloタイマー、および定期的なルートアップデートの送信を管理する更新タイマー、 - 各インターフェイステーブルエントリに関連付けられた2つのタイマがあります。"
    },
    {
      "indent": 0,
      "text": "3.2.3. The Neighbour Table",
      "section_title": true,
      "ja": "3.2.3. ネイバーテーブル"
    },
    {
      "indent": 3,
      "text": "The neighbour table contains the list of all neighbouring interfaces from which a Babel packet has been recently received. The neighbour table is indexed by pairs of the form (interface, address), and every neighbour table entry contains the following data:",
      "ja": "ネイバーテーブルは、バベルパケットが最近受信されたすべての隣接インターフェイスのリストを含みます。ネイバーテーブルは、フォーム（インターフェース、アドレス）の対により索引付けされ、すべての隣接テーブルエントリは、以下のデータが含まれています。"
    },
    {
      "indent": 3,
      "text": "o the local node's interface over which this neighbour is reachable;",
      "ja": "このネイバー到達が可能なOローカル・ノードのインタフェース。"
    },
    {
      "indent": 3,
      "text": "o the address of the neighbouring interface;",
      "ja": "近接インターフェイスのアドレスO;"
    },
    {
      "indent": 3,
      "text": "o  a history of recently received Hello packets from this neighbour;\n   this can, for example, be a sequence of n bits, for some small\n   value n, indicating which of the n hellos most recently sent by\n   this neighbour have been received by the local node;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o the \"transmission cost\" value from the last IHU packet received from this neighbour, or FFFF hexadecimal (infinity) if the IHU hold timer for this neighbour has expired;",
      "ja": "O最後IHUパケットから「送信コスト」値は、このネイバーが満了したためIHUタイマーを保持する場合は、この隣人、またはFFFF進数（無限大）から受け取りました。"
    },
    {
      "indent": 3,
      "text": "o the neighbour's expected Hello sequence number, an integer modulo 2^16.",
      "ja": "隣人のHello期待シーケンス番号、整数剰余2 ^ 16 O。"
    },
    {
      "indent": 3,
      "text": "There are two timers associated with each neighbour entry -- the hello timer, which is initialised from the interval value carried by Hello TLVs, and the IHU timer, which is initialised to a small multiple of the interval carried in IHU TLVs.",
      "ja": "こんにちはのTLVで運ば間隔値から初期化されるハロータイマー、およびIHUタイマー、IHUのTLVで運ば間隔の小さな倍数に初期化される - 各ネイバーエントリに関連付けられた2つのタイマがあります。"
    },
    {
      "indent": 3,
      "text": "Note that the neighbour table is indexed by IP addresses, not by router-ids: neighbourship is a relationship between interfaces, not between nodes. Therefore, two nodes with multiple interfaces can participate in multiple neighbourship relationships, a fairly common situation when wireless nodes with multiple radios are involved.",
      "ja": "ネイバーテーブルは、IPアドレスによってではなく、ルータIDによってインデックスされることに注意：neighbourshipはインターフェイス間ではなく、ノード間の関係です。そのため、複数のインタフェースを持つ2つのノードが、複数のneighbourship関係で複数の無線機との無線ノードが関与しているかなり一般的な状況を参加することができます。"
    },
    {
      "indent": 0,
      "text": "3.2.4. The Source Table",
      "section_title": true,
      "ja": "3.2.4. ソース表"
    },
    {
      "indent": 3,
      "text": "The source table is used to record feasibility distances. It is indexed by triples of the form (prefix, plen, router-id), and every source table entry contains the following data: o the prefix (prefix, plen), where plen is the prefix length, that this entry applies to;",
      "ja": "ソーステーブルは、実現可能性の距離を記録するために使用されます。これは、フォーム（接頭辞、PLEN、ルータID）のトリプルによって索引付け、およびすべてのソース・テーブル・エントリは、以下のデータが含まれている：PLENがプレフィックス長であるプレフィックス（接頭辞、PLEN）、O、このエントリが適用されます。"
    },
    {
      "indent": 3,
      "text": "o the router-id of a router originating this prefix;",
      "ja": "このプレフィックスを発信側ルータのルータID O;"
    },
    {
      "indent": 3,
      "text": "o a pair (seqno, metric), this source's feasibility distance.",
      "ja": "Oペア（SEQNO、メトリック）、このソースの実現可能性距離。"
    },
    {
      "indent": 3,
      "text": "There is one timer associated with each entry in the source table -- the source garbage-collection timer. It is initialised to a time on the order of minutes and reset as specified in Section 3.7.3.",
      "ja": "ソースガベージコレクションタイマー - ソーステーブルの各エントリに関連付けられた1つのタイマーがあります。これは、数分のオーダーの時間に初期化し、3.7.3項で指定されるようにリセットされます。"
    },
    {
      "indent": 0,
      "text": "3.2.5. The Route Table",
      "section_title": true,
      "ja": "3.2.5. ルートテーブル"
    },
    {
      "indent": 3,
      "text": "The route table contains the routes known to this node. It is indexed by triples of the form (prefix, plen, neighbour), and every route table entry contains the following data:",
      "ja": "ルートテーブルは、このノードに知られている経路を含んでいます。これは、フォームのトリプル（接頭辞、PLEN、隣人）によってインデックスされ、すべてのルートテーブルエントリには、次のデータが含まれます："
    },
    {
      "indent": 3,
      "text": "o the source (prefix, plen, router-id) for which this route is advertised;",
      "ja": "このルートがアドバタイズされたソース（接頭辞、PLEN、ルータID）O。"
    },
    {
      "indent": 3,
      "text": "o the neighbour that advertised this route;",
      "ja": "このルートをアドバタイズし、近隣O;"
    },
    {
      "indent": 3,
      "text": "o the metric with which this route was advertised by the neighbour, or FFFF hexadecimal (infinity) for a recently retracted route;",
      "ja": "この経路は、最近後退経路を隣人、またはFFFF進数（無限大）によってアドバタイズされたときのメトリックO。"
    },
    {
      "indent": 3,
      "text": "o the sequence number with which this route was advertised;",
      "ja": "このルートがアドバタイズされたときのシーケンス番号を、O。"
    },
    {
      "indent": 3,
      "text": "o the next-hop address of this route;",
      "ja": "このルートのネクストホップアドレスO;"
    },
    {
      "indent": 3,
      "text": "o a boolean flag indicating whether this route is selected, i.e., whether it is currently being used for forwarding and is being advertised.",
      "ja": "Oこのルートは、現在転送に使用されており、アドバタイズされているかどうか、すなわち、選択されたかどうかを示すブールフラグ。"
    },
    {
      "indent": 3,
      "text": "There is one timer associated with each route table entry -- the route expiry timer. It is initialised and reset as specified in Section 3.5.4.",
      "ja": "ルート期限切れタイマー - 各ルートテーブルエントリに関連付けられた1つのタイマーがあります。これは、初期化して、セクション3.5.4で指定されるようにリセットされます。"
    },
    {
      "indent": 0,
      "text": "3.2.6. The Table of Pending Requests",
      "section_title": true,
      "ja": "3.2.6. 保留中の要求の表"
    },
    {
      "indent": 3,
      "text": "The table of pending requests contains a list of seqno requests that the local node has sent (either because they have been originated locally, or because they were forwarded) and to which no reply has been received yet. This table is indexed by prefixes, and every entry in this table contains the following data:",
      "ja": "保留中の要求の表では、ローカル・ノードが送信した（これらはローカル発信されているため、またはそれらが転送されたためのいずれか）とその返事がまだ受信されていないためにSEQNO要求のリストを含みます。このテーブルは接頭辞でインデックスされ、この表の各エントリには、次のデータが含まれます："
    },
    {
      "indent": 3,
      "text": "o the prefix, router-id, and seqno being requested;",
      "ja": "O接頭辞、ルータID、およびSEQNOが要求されています。"
    },
    {
      "indent": 3,
      "text": "o the neighbour, if any, on behalf of which we are forwarding this request;",
      "ja": "もしあれば隣人O、に代わって、私たちは、この要求を転送しています。"
    },
    {
      "indent": 3,
      "text": "o a small integer indicating the number of times that this request will be resent if it remains unsatisfied.",
      "ja": "Oが満たされないままである場合、この要求が再送信される回数を示す小さな整数。"
    },
    {
      "indent": 3,
      "text": "There is one timer associated with each pending request; it governs both the resending of requests and their expiry.",
      "ja": "各保留中の要求に関連付けられた1つのタイマーがあります。それは、リクエストの再送とその有効期限の両方を支配します。"
    },
    {
      "indent": 0,
      "text": "3.3. Acknowledged Packets",
      "section_title": true,
      "ja": "3.3.  ADIは、パケット"
    },
    {
      "indent": 3,
      "text": "A Babel speaker may request that any neighbour receiving a given packet reply with an explicit acknowledgement within a given time. While the use of acknowledgement requests is optional, every Babel speaker MUST be able to reply to such a request.",
      "ja": "バベルスピーカは、任意のネイバーが所定の時間内に明示的な肯定応答で与えられたパケットの応答を受信することを要求することができます。承認要求の使用は任意ですが、すべてのバベルのスピーカーは、そのような要求に答えることができなければなりません。"
    },
    {
      "indent": 3,
      "text": "An acknowledgement MUST be sent to a unicast destination. On the other hand, acknowledgement requests may be sent to either unicast or multicast destinations, in which case they request an acknowledgement from all of the receiving nodes.",
      "ja": "肯定応答はユニキャスト宛先に送信されなければなりません。一方、送達確認要求は、それらが受信ノードの全てから肯定応答を要求するその場合、ユニキャストまたはマルチキャストの宛先のいずれかに送信することができます。"
    },
    {
      "indent": 3,
      "text": "When to request acknowledgements is a matter of local policy; the simplest strategy is to never request acknowledgements and to rely on periodic updates to ensure that any reachable routes are eventually propagated throughout the routing domain. For increased efficiency, we suggest that acknowledged packets should be used in order to send urgent updates (Section 3.7.2) when the number of neighbours on a given interface is small. Since Babel is designed to deal gracefully with packet loss on unreliable media, sending all packets with acknowledgement requests is not necessary, and not even recommended, as the acknowledgements cause additional traffic and may force additional Address Resolution Protocol (ARP) or Neighbour Discovery exchanges.",
      "ja": "確認応答を要求する場合は、ローカルポリシーの問題です。最も単純な戦略は、確認応答を要求しないようにし、任意の到達可能なルートが最終的には、ルーティングドメイン全体に伝播されることを保証するために、定期的な更新に依存することです。効率向上のために、我々は定評のパケットが特定のインターフェイス上のネイバーの数が少ない場合には、緊急アップデート（3.7.2）を送信するために使用すべきであることを示唆しています。バベルは、承認要求にすべてのパケットを送信する必要がないが、信頼できないメディア上のパケットロスで優雅に対処するために設計されており、確認応答が追加のトラフィックが発生し、追加のアドレス解決プロトコル（ARP）または近隣探索交換を強制するようにも、お勧めできません。されているので"
    },
    {
      "indent": 0,
      "text": "3.4. Neighbour Acquisition",
      "section_title": true,
      "ja": "3.4. 近隣の取得"
    },
    {
      "indent": 3,
      "text": "Neighbour acquisition is the process by which a Babel node discovers the set of neighbours heard over each of its interfaces and ascertains bidirectional reachability. On unreliable media, neighbour acquisition additionally provides some statistics that MAY be used in link quality computation.",
      "ja": "隣接取得はバベルノードは、そのインターフェースのそれぞれを介して聞いた隣人のセットを発見および双方向到達可能性を確認するプロセスです。信頼できないメディアに、隣人の買収は、さらにリンク品質の計算に使用することができるいくつかの統計情報を提供します。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Reverse Reachability Detection",
      "section_title": true,
      "ja": "3.4.1. 逆到達可能性検出"
    },
    {
      "indent": 3,
      "text": "Every Babel node sends periodic Hellos over each of its interfaces. Each Hello TLV carries an increasing (modulo 2^16) sequence number and the interval between successive periodic packets sent on this particular interface.",
      "ja": "すべてのバベルノードは、そのインターフェースのそれぞれを介して定期的helloを送信します。各ハローTLVが増加し（モジュロ2 ^ 16）のシーケンス番号と、この特定のインターフェイス上で送信される連続した周期的なパケット間の間隔を運びます。"
    },
    {
      "indent": 3,
      "text": "In addition to the periodic Hello packets, a node MAY send unscheduled Hello packets, e.g., to accelerate link cost estimation when a new neighbour is discovered, or when link conditions have suddenly changed.",
      "ja": "定期的にHelloパケットに加えて、ノードは、リンクの状態が急に変化しているときに、新しい隣人が発見されたときにリンクコスト推定を加速する、またはして、例えば、予定外のHelloパケットを送信することができます。"
    },
    {
      "indent": 3,
      "text": "A node MAY change its Hello interval. The Hello interval MAY be decreased at any time; it SHOULD NOT be increased, except immediately before sending a Hello packet. (Equivalently, a node SHOULD send an unscheduled Hello immediately after increasing its Hello interval.)",
      "ja": "ノードは、そのハロー間隔を変更することがあります。こんにちは間隔は、任意の時点で減少させてもよいです。それはすぐにHelloパケットを送信する前に除いて、増加されるべきではありません。 （等価的に、ノードは、そのハロー間隔を長くした直後に予定外のHelloを送るべきです。）"
    },
    {
      "indent": 3,
      "text": "How to deal with received Hello TLVs and what statistics to maintain are considered local implementation matters; typically, a node will maintain some sort of history of recently received Hellos. A possible algorithm is described in Appendix A.1.",
      "ja": "受信こんにちはTLVは、どのような統計情報を維持するために、ローカルの実装の問題と考えられているに対処する方法。一般的に、ノードは、最近受信ハローズの歴史のいくつかの並べ替えを維持します。可能なアルゴリズムは、付録A.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "After receiving a Hello, or determining that it has missed one, the node recomputes the association's cost (Section 3.4.3) and runs the route selection procedure (Section 3.6).",
      "ja": "ハローを受信し、またはそれが1つを逃したことを決定した後、ノードは、関連のコスト（3.4.3）を再計算し、経路選択手順（セクション3.6）を実行します。"
    },
    {
      "indent": 0,
      "text": "3.4.2. Bidirectional Reachability Detection",
      "section_title": true,
      "ja": "3.4.2. 双方向到達可能性検出"
    },
    {
      "indent": 3,
      "text": "In order to establish bidirectional reachability, every node sends periodic IHU (\"I Heard You\") TLVs to each of its neighbours. Since IHUs carry an explicit interval value, they MAY be sent less often than Hellos in order to reduce the amount of routing traffic in dense networks; in particular, they SHOULD be sent less often than Hellos over links with little packet loss. While IHUs are conceptually unicast, they SHOULD be sent to a multicast address in order to avoid an ARP or Neighbour Discovery exchange and to aggregate multiple IHUs in a single packet.",
      "ja": "双方向の到達可能性を確立するために、すべてのノードは、その近隣のそれぞれに定期的にIHU（「私はあなたを聞いた」）TLVを送信します。 IHUsは、明示的な間隔値を運ぶので、密なネットワークにトラフィックをルーティングの量を減らすために、あまり頻繁にハローズより送信されるかもしれません。特に、彼らは少しのパケットロスとのリンク上でhelloメッセージよりも頻繁に送ってください。 IHUsは概念的にユニキャストであるが、それらは、ARPまたは近隣探索交換を回避し、単一のパケットで複数IHUsを集約するために、マルチキャストアドレスに送信されるべきです。"
    },
    {
      "indent": 3,
      "text": "In addition to the periodic IHUs, a node MAY, at any time, send an unscheduled IHU packet. It MAY also, at any time, decrease its IHU interval, and it MAY increase its IHU interval immediately before sending an IHU.",
      "ja": "定期的IHUsに加えて、ノードは、任意の時点で、予定外のIHUパケットを送信することができます。それはまた、任意の時点で、そのIHU間隔を減少させることができる、そしてそれはすぐにIHUを送信する前にそのIHU間隔を増大させることができます。"
    },
    {
      "indent": 3,
      "text": "Every IHU TLV contains two pieces of data: the link's rxcost (reception cost) from the sender's perspective, used by the neighbour for computing link costs (Section 3.4.3), and the interval between periodic IHU packets. A node receiving an IHU updates the value of the sending neighbour's txcost (transmission cost), from its perspective, to the value contained in the IHU, and resets this neighbour's IHU timer to a small multiple of the value received in the IHU.",
      "ja": "リンクコスト（3.4.3項）、および定期的なIHUパケット間の間隔を計算するために隣人によって使用される送信者の視点からのリンクのrxcost（受信コスト）、：すべてのIHU TLVは、データの2枚が含まれています。 IHUを受信したノードは、その観点から、IHUに含まれる値に、送信隣人のtxcost（伝送コスト）の値を更新し、IHUで受信された値の小さい倍数にこの隣人のIHUタイマーをリセットします。"
    },
    {
      "indent": 3,
      "text": "When a neighbour's IHU timer expires, its txcost is set to infinity.",
      "ja": "隣人のIHUタイマーの期限が切れると、そのtxcostは無限大に設定されています。"
    },
    {
      "indent": 3,
      "text": "After updating a neighbour's txcost, the receiving node recomputes the neighbour's cost (Section 3.4.3) and runs the route selection procedure (Section 3.6).",
      "ja": "隣人のtxcostを更新した後、受信ノードは、隣人のコスト（3.4.3）を再計算し、経路選択手順（セクション3.6）を実行します。"
    },
    {
      "indent": 0,
      "text": "3.4.3. Cost Computation",
      "section_title": true,
      "ja": "3.4.3. コスト計算"
    },
    {
      "indent": 3,
      "text": "A neighbourship association's link cost is computed from the values maintained in the neighbour table -- namely, the statistics kept in the neighbour table about the reception of Hellos, and the txcost computed from received IHU packets.",
      "ja": "neighbourship関連のリンクコストは、ネイバーテーブルに維持値から計算される - すなわち、統計はハローズの受信、および受信IHUパケットから計算txcostについてネイバーテーブルに保持しました。"
    },
    {
      "indent": 3,
      "text": "For every neighbour, a Babel node computes a value known as this neighbour's rxcost. This value is usually derived from the Hello history, which may be combined with other data, such as statistics maintained by the link layer. The rxcost is sent to a neighbour in each IHU.",
      "ja": "すべての隣人のために、バベルのノードは、この隣人のrxcostとして知られている値を計算します。この値は、通常、リンク層によって維持統計などの他のデータと組み合わせることができるハロー履歴、から誘導されます。 rxcostは、各IHUで隣人に送られます。"
    },
    {
      "indent": 3,
      "text": "How the txcost and rxcost are combined in order to compute a link's cost is a matter of local policy; as far as Babel's correctness is concerned, only the following conditions MUST be satisfied:",
      "ja": "txcostとrxcostは、リンクのコストを計算するために組み合わされてどのようにローカルポリシーの問題です。限りバベルの正確性に関しては、唯一の次の条件を満たす必要があります。"
    },
    {
      "indent": 3,
      "text": "o the cost is strictly positive;",
      "ja": "Oコストは厳密に正です。"
    },
    {
      "indent": 3,
      "text": "o if no hellos were received recently, then the cost is infinite;",
      "ja": "何のhelloパケットを最近受信しなかった場合は、O、そしてコストが無限です。"
    },
    {
      "indent": 3,
      "text": "o if the txcost is infinite, then the cost is infinite.",
      "ja": "txcostが無限大である場合、O、そしてコストが無限です。"
    },
    {
      "indent": 3,
      "text": "Note that while this document does not constrain cost computation any further, not all cost computation strategies will give good results. We give a few examples of strategies for computing a link's cost that are known to work well in practice in Appendix A.2.",
      "ja": "このドキュメントは、任意のさらなるコスト計算を制限しませんが、すべてではないコスト計算戦略は良い結果を与えることに注意してください。私たちは、付録A.2で実際にうまく機能することが知られているリンクのコストを計算するための戦略のいくつかの例を与えます。"
    },
    {
      "indent": 0,
      "text": "3.5. Routing Table Maintenance",
      "section_title": true,
      "ja": "3.5. ルーティングテーブルのメンテナンス"
    },
    {
      "indent": 3,
      "text": "Conceptually, a Babel update is a quintuple (prefix, plen, router-id, seqno, metric), where (prefix, plen) is the prefix for which a route is being advertised, router-id is the router-id of the router originating this update, seqno is a nondecreasing (modulo 2^16) integer that carries the originating router seqno, and metric is the announced metric.",
      "ja": "概念的に、バベル更新が（接頭辞、PLEN）のルートがアドバタイズされている接頭辞である五重（接頭辞、PLEN、ルータID、SEQNO、メトリック）である、ルータIDは、ルータのルータIDでありますこの更新を発信、SEQNOは非減少（モジュロ2 ^ 16）発信元ルータSEQNOを担持整数であり、メトリックメトリック発表です。"
    },
    {
      "indent": 3,
      "text": "Before being accepted, an update is checked against the feasibility condition (Section 3.5.1), which ensures that the route does not create a routing loop. If the feasibility condition is not satisfied, the update is either ignored or treated as a retraction, depending on some other conditions (Section 3.5.4). If the feasibility condition is satisfied, then the update cannot possibly cause a routing loop, and the update is accepted.",
      "ja": "受け入れられる前に、更新は、経路がルーティングループを作成しないことを確実に実行可能性条件（セクション3.5.1）に対してチェックされます。実行可能性の条件が満たされない場合、更新は、他の条件（セクション3.5.4）に依存して、無視されるか、または後退として扱われますか。実現可能性の条件が満たされた場合、更新はおそらく、ルーティングループが発生することができない、そして更新が受け入れられています。"
    },
    {
      "indent": 0,
      "text": "3.5.1. The Feasibility Condition",
      "section_title": true,
      "ja": "3.5.1. フィージビリティコンディション"
    },
    {
      "indent": 3,
      "text": "The feasibility condition is applied to all received updates. The feasibility condition compares the metric in the received update with the metrics of the updates previously sent by the receiving node; updates with finite metrics large enough to cause a loop are discarded.",
      "ja": "実現可能性の条件は、受信したすべての更新プログラムに適用されます。実行可能性条件は、以前に受信ノードによって送信されたアップデートのメトリックと受信した更新にメトリックを比較します。ループを引き起こすのに十分な大き有限メトリックと更新は破棄されます。"
    },
    {
      "indent": 3,
      "text": "A feasibility distance is a pair (seqno, metric), where seqno is an integer modulo 2^16 and metric is a positive integer. Feasibility distances are compared lexicographically, with the first component inverted: we say that a distance (seqno, metric) is strictly better than a distance (seqno', metric'), written",
      "ja": "実現可能距離はSEQNOは、2 ^ 16の整数モジュロであり、メトリックは正の整数ペア（SEQNO、メトリック）です。フィージビリティ距離は反転された第1の成分と、辞書的に比較されています。我々は、距離（SEQNO、メトリックが）書かれた距離（SEQNO「メトリック」）、より厳密に優れていると言います"
    },
    {
      "indent": 6,
      "text": "(seqno, metric) < (seqno', metric')",
      "ja": "（SEQNO、メトリック）<（SEQNO 'メトリック'）"
    },
    {
      "indent": 3,
      "text": "when",
      "ja": "いつ"
    },
    {
      "indent": 6,
      "text": "seqno > seqno' or (seqno = seqno' and metric < metric')",
      "ja": "SEQNO> SEQNO 'または（SEQNO = SEQNO' およびメトリック<メトリック '）"
    },
    {
      "indent": 3,
      "text": "where sequence numbers are compared modulo 2^16.",
      "ja": "シーケンス番号はモジュロ^ 16 2と比較されます。"
    },
    {
      "indent": 3,
      "text": "Given a source (p, plen, id), a node's feasibility distance for this source is the minimum, according to the ordering defined above, of the distances of all the finite updates ever sent by this particular node for the prefix (p, plen) carrying the router-id id. Feasibility distances are maintained in the source table; the exact procedure is given in Section 3.7.3.",
      "ja": "ソース（P、PLEN、ID）が与えられると、このソースのノードの実現可能性距離は、これまでのプレフィックスのためのこの特定のノード（P、PLENによって送信されたすべての有限の更新の距離の、上記で定義された順序に従って、最小値であります）ルータIDのIDを運びます。実現可能距離は、ソーステーブルに維持されます。正確な手順は、セクション3.7.3に記載されています。"
    },
    {
      "indent": 3,
      "text": "A received update is feasible when either it is a retraction (its metric is FFFF hexadecimal), or the advertised distance is strictly better, in the sense defined above, than the feasibility distance for the corresponding source. More precisely, a route advertisement carrying the quintuple (prefix, plen, router-id, seqno, metric) is feasible if one of the following conditions holds:",
      "ja": "それは後退（そのメトリックがFFFF進数である）であるか、またはアドバタイズ距離は、対応するソースのための実現可能距離よりも、上記で定義された意味において、厳密に優れているいずれかのときに受信した更新が可能です。次のいずれかの条件が成立する場合より正確には、五重（接頭辞、PLEN、ルータID、SEQNO、メトリック）を運ぶルート広告が可能です。"
    },
    {
      "indent": 3,
      "text": "o metric is infinite; or",
      "ja": "Oメトリックは無限です。または"
    },
    {
      "indent": 3,
      "text": "o no entry exists in the source table indexed by (id, prefix, plen); or",
      "ja": "Oエントリは、（ID、接頭辞、PLEN）によって索引付けソーステーブルに存在しません。または"
    },
    {
      "indent": 3,
      "text": "o an entry (prefix, plen, router-id, seqno', metric') exists in the source table, and either",
      "ja": "エントリ（接頭辞、PLEN、ルータID、SEQNO「メトリック」）のいずれかのソーステーブルに存在し、およびo"
    },
    {
      "indent": 6,
      "text": "* seqno' < seqno or",
      "ja": "* SEQNO」<seqnoをか"
    },
    {
      "indent": 6,
      "text": "* seqno = seqno' and metric < metric'.",
      "ja": "* SEQNO = SEQNO 'とメトリック<メトリック'。"
    },
    {
      "indent": 3,
      "text": "Note that the feasibility condition considers the metric advertised by the neighbour, not the route's metric; hence, a fluctuation in a neighbour's cost cannot render a selected route unfeasible.",
      "ja": "実現可能性の条件が隣人ではなく、ルートのメトリックによってアドバタイズメトリックを考慮することに注意してください。それゆえ、隣人のコストの変動は、選択したルートは実現不可能なレンダリングすることはできません。"
    },
    {
      "indent": 0,
      "text": "3.5.2. Metric Computation",
      "section_title": true,
      "ja": "3.5.2. メトリック計算"
    },
    {
      "indent": 3,
      "text": "A route's metric is computed from the metric advertised by the neighbour and the neighbour's link cost. Just like cost computation, metric computation is considered a local policy matter; as far as Babel is concerned, the function M(c, m) used for computing a metric from a locally computed link cost and the metric advertised by a neighbour MUST only satisfy the following conditions:",
      "ja": "ルートのメトリックは、隣人と隣人のリンクコストによってアドバタイズメトリックから計算されます。ただ、コスト計算のように、メトリック計算は、ローカルポリシーの問題と考えられています。限りバベルに関しては、関数M（C、M）は、局所的に計算されたリンクコストのみ、次の条件を満たさなければならない隣人によってアドバタイズメトリックのメトリックを計算するために使用されます。"
    },
    {
      "indent": 3,
      "text": "o if c is infinite, then M(c, m) is infinite;",
      "ja": "cが無限大である場合、O、次いで、M（C、M）は無限です。"
    },
    {
      "indent": 3,
      "text": "o M is strictly monotonic: M(c, m) > m.",
      "ja": "O Mは、厳密に単調である：M（C、M）> M。"
    },
    {
      "indent": 3,
      "text": "Additionally, the metric SHOULD satisfy the following condition:",
      "ja": "また、メトリックは、以下の条件を満たしている必要があります。"
    },
    {
      "indent": 3,
      "text": "o M is isotonic: if m <= m', then M(c, m) <= M(c, m').",
      "ja": "O Mは等張性である：M <= M 'は、M（C、M）<= M（C、M'）場合。"
    },
    {
      "indent": 3,
      "text": "Note that while strict monotonicity is essential to the integrity of the network (persistent routing loops may appear if it is not satisfied), isotonicity is not: if it is not satisfied, Babel will still converge to a locally optimal routing table, but might not reach a global optimum (in fact, such a global optimum may not even exist).",
      "ja": "しばらく厳しい単調性は、ネットワークの整合性に不可欠であることに注意してください（それが満たされない場合は永続的なルーティングループが表示される場合があります）、等張性ではない：それは満たされていない場合は、バベルは、まだローカルに最適なルーティングテーブルに収束しますが、ない場合がありますでしょう（実際には、そのような大域的最適解も存在しなくてもよい）大域的最適に到達します。"
    },
    {
      "indent": 3,
      "text": "As with cost computation, not all strategies for computing route metrics will give good results. In particular, some metrics are more likely than others to lead to routing instabilities (route flapping). In Appendix A.3, we give a number of examples of strictly monotonic, isotonic routing metrics that are known to work well in practice.",
      "ja": "コストの計算と同様に、ルートメトリックを計算するためのすべてではない戦略は良い結果が得られます。特に、いくつかのメトリックは、ルーティングの不安定性（ルートフラッピング）につながる他のものよりも可能性が高いです。付録A.3では、我々は実際にうまく機能することが知られている厳密に単調な、等張ルーティングメトリックの多くの例を与えます。"
    },
    {
      "indent": 0,
      "text": "3.5.3. Encoding of Updates",
      "section_title": true,
      "ja": "3.5.3. アップデートのエンコーディング"
    },
    {
      "indent": 3,
      "text": "In a large network, the bulk of Babel traffic consists of route updates; hence, some care has been given to encoding them efficiently. An Update TLV itself only contains the prefix, seqno, and metric, while the next hop is derived either from the network-layer source address of the packet or from an explicit Next Hop TLV in the same packet. The router-id is derived from a separate Router-Id TLV in the same packet, which optimises the case when multiple updates are sent with the same router-id.",
      "ja": "大規模なネットワークでは、バベルのトラフィックの大部分は、ルート更新から成ります。したがって、いくつかの注意が効率的にそれらをコードするために与えられています。次ホップがパケットのネットワーク層のソースアドレスから、または同じパケットに明示的ネクストホップTLVのいずれかから誘導されながら更新TLV自体は、プレフィックス、SEQNO、およびメトリックを含んでいます。ルータIDは、複数の更新が同じルータIDを用いて送信される場合を最適化する同じパケットに別個のルータID TLVに由来します。"
    },
    {
      "indent": 3,
      "text": "Additionally, a prefix of the advertised prefix can be omitted in an Update TLV, in which case it is copied from a previous Update TLV in the same packet -- this is known as address compression [PACKETBB].",
      "ja": "これは、アドレス圧縮[PACKETBB]として知られている - また、アドバタイズ接頭辞の接頭辞は、それが同一のパケット内の前の更新TLVからコピーされた場合には、更新TLVに省略することができます。"
    },
    {
      "indent": 3,
      "text": "Finally, as a special optimisation for the case when a router-id coincides with the interface-id part of an IPv6 address, the router-id can optionally be derived from the low-order bits of the advertised prefix.",
      "ja": "最後に、ルータIDは、IPv6アドレスのインタフェースID部と一致している場合のための特別な最適化として、ルータIDは、必要に応じて広告を出して、プレフィックスの下位ビットから導出することができます。"
    },
    {
      "indent": 3,
      "text": "The encoding of updates is described in detail in Section 4.4.",
      "ja": "更新の符号化は、セクション4.4で詳細に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.5.4. Route Acquisition",
      "section_title": true,
      "ja": "3.5.4. ルート獲得"
    },
    {
      "indent": 3,
      "text": "When a Babel node receives an update (id, prefix, seqno, metric) from a neighbour neigh with a link cost value equal to cost, it checks whether it already has a routing table entry indexed by (neigh, id, prefix).",
      "ja": "バベルノードがコストに等しいリンクコスト値といななきネイバーからのアップデート（ID、接頭辞、SEQNO、メトリック）を受信すると、それは既に（いななき、ID、接頭辞）によってインデックス付けルーティングテーブルエントリを有するかどうかをチェックします。"
    },
    {
      "indent": 3,
      "text": "If no such entry exists:",
      "ja": "このようなエントリが存在しない場合："
    },
    {
      "indent": 3,
      "text": "o if the update is unfeasible, it is ignored;",
      "ja": "アップデートが実行不可能である場合には、O、それは無視されます。"
    },
    {
      "indent": 3,
      "text": "o if the metric is infinite (the update is a retraction), the update is ignored;",
      "ja": "メトリックは、（更新が後退である）無限大である場合、O、更新は無視されます。"
    },
    {
      "indent": 3,
      "text": "o otherwise, a new route table entry is created, indexed by (neigh, id, prefix), with seqno equal to seqno and an advertised metric equal to the metric carried by the update.",
      "ja": "Oそうでなければ、新しいルートテーブルエントリが作成され、SEQNOに等しいと更新によって運ばれるメトリックと同じメトリックをアドバタイズSEQNOと、（いななき、ID、接頭辞）によってインデックス付け。"
    },
    {
      "indent": 3,
      "text": "If such an entry exists:",
      "ja": "そのようなエントリが存在する場合："
    },
    {
      "indent": 3,
      "text": "o if the entry is currently installed and the update is unfeasible, then the behaviour depends on whether the router-ids of the two entries match. If the router-ids are different, the update is treated as though it were a retraction (i.e., as though the metric were FFFF hexadecimal). If the router-ids are equal, the update is ignored;",
      "ja": "エントリが現在インストールとアップデートが実行不可能であるされている場合、O、その後の行動は、2つのエントリのルータIDが一致するかどうかによって異なります。ルータIDが異なっている場合、それは（すなわち、メトリックがFFFF進であるかのように）後退したかのように、更新が処理されます。ルータIDが等しい場合、更新は無視されます。"
    },
    {
      "indent": 3,
      "text": "o otherwise (i.e., if either the update is feasible or the entry is not currently installed), then the entry's sequence number, advertised metric, metric, and router-id are updated and, unless the advertised metric is infinite, the route's expiry timer is reset to a small multiple of the Interval value included in the update.",
      "ja": "（アップデートのいずれかが実行可能であるかのエントリは、現在インストールされていない場合、すなわち、）Oそれ以外の場合は、エントリのシーケンス番号は、アドバタイズされたメトリックが無限でない限り、ルートの有効期限タイマー、メトリック、メトリック宣伝、およびルータIDが更新され、更新プログラムに含まれる間隔値の小さい倍数にリセットされます。"
    },
    {
      "indent": 3,
      "text": "When a route's expiry timer triggers, the behaviour depends on whether the route's metric is finite. If the metric is finite, it is set to infinity and the expiry timer is reset. If the metric is already infinite, the route is flushed from the route table.",
      "ja": "ルートの有効期限タイマーがトリガすると、動作がルートのメトリックが有限であるかどうかに依存します。メトリックが有限である場合、それは無限大に設定され、有効期限タイマーがリセットされます。メトリックがすでに無限大の場合、ルートがルートテーブルからフラッシュされます。"
    },
    {
      "indent": 3,
      "text": "After the routing table is updated, the route selection procedure (Section 3.6) is run.",
      "ja": "ルーティングテーブルが更新された後、経路選択手順（セクション3.6）が実行されます。"
    },
    {
      "indent": 0,
      "text": "3.5.5. Hold Time",
      "section_title": true,
      "ja": "3.5.5. ホールドタイム"
    },
    {
      "indent": 3,
      "text": "When a prefix p is retracted, because all routes are unfeasible, too old, or have an infinite metric, and a shorter prefix p' that covers p is reachable, p' cannot in general be used for routing packets destined to p without running the risk of creating a routing loop (Section 2.8).",
      "ja": "接頭辞pはすべてのルートは、あまりにも古い実現不可能であるか、あるいは無限のメトリックを持っているので、収納され、かつ短いプレフィックスP、P「をカバーして到達可能である、p」は、一般的には実行せずにP宛のパケットをルーティングするために使用することができない場合ルーティング・ループ（セクション2.8）を作成するリスク。"
    },
    {
      "indent": 3,
      "text": "To avoid this issue, whenever a prefix is retracted, a routing table entry with infinite metric is maintained as described in Section 3.5.4 above, and packets destined for that prefix MUST NOT be forwarded by following a route for a shorter prefix. The infinite metric entry is maintained until it is superseded by a feasible update; if no such update arrives within the route hold time, the entry is flushed.",
      "ja": "接頭辞が後退するときには、この問題を回避するには、無限のメトリックを持つルーティングテーブルエントリは、上記のセクション3.5.4で説明したように維持され、そしてそのプレフィックス宛てのパケットは、短いプレフィックスのルートに従うことによって転送されてはなりません。それが実現可能な更新によって取って代わられるまで、無限のメトリックエントリが維持されています。そのような更新は、ルートホールド時間内に到着しない場合は、エントリがフラッシュされます。"
    },
    {
      "indent": 0,
      "text": "3.6. Route Selection",
      "section_title": true,
      "ja": "3.6. ルート選択"
    },
    {
      "indent": 3,
      "text": "Route selection is the process by which a single route for a given prefix is selected to be used for forwarding packets and to be re-advertised to a node's neighbours.",
      "ja": "経路選択は、所定のプレフィクスのための単一の経路がパケットを転送するために使用されるように、ノードの近隣に再アドバタイズされるように選択されるプロセスです。"
    },
    {
      "indent": 3,
      "text": "Babel is designed to allow flexible route selection policies. As far as the protocol's correctness is concerned, the route selection policy MUST only satisfy the following properties:",
      "ja": "バベルは、柔軟なルート選択ポリシーを許可するように設計されています。限りプロトコルの正しさが関係しているように、経路選択ポリシーは、以下の特性を満たしている必要があります。"
    },
    {
      "indent": 3,
      "text": "o a route with infinite metric (a retracted route) is never selected;",
      "ja": "O無限のメトリック（後退経路）を有する経路が選択されることはありません。"
    },
    {
      "indent": 3,
      "text": "o an unfeasible route is never selected.",
      "ja": "O実現不可能なルートが選択されることはありません。"
    },
    {
      "indent": 3,
      "text": "Note, however, that Babel does not naturally guarantee the stability of routing, and configuring conflicting route selection policies on different routers may lead to persistent route oscillation.",
      "ja": "バベルは当然ルーティングの安定性を保証するものではありませんし、別のルータ上で、競合経路選択ポリシーを設定すると、永続的なルート振動につながる可能性があること、しかし、注意してください。"
    },
    {
      "indent": 3,
      "text": "Defining a good route selection policy for Babel is an open research problem. Route selection can take into account multiple mutually contradictory criteria; in roughly decreasing order of importance, these are:",
      "ja": "バベルのための良好な経路選択ポリシーを定義すると、開いている研究課題です。ルート選択は、アカウントに複数の相反する基準を取ることができます。おおまかな重要性の順に、これらは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o routes with a small metric should be preferred over routes with a large metric;",
      "ja": "小さいメトリックの入出力経路は、大きなメトリックの経路よりも優先されるべきです。"
    },
    {
      "indent": 3,
      "text": "o switching router-ids should be avoided;",
      "ja": "ルータIDを切り替えoを避けるべきです。"
    },
    {
      "indent": 3,
      "text": "o routes through stable neighbours should be preferred over routes through unstable ones;",
      "ja": "O安定ネイバーを通じてルートが不安定なもの経由のルートよりも優先されるべきです。"
    },
    {
      "indent": 3,
      "text": "o stable routes should be preferred over unstable ones;",
      "ja": "O安定した経路が不安定なものよりも優先されるべきです。"
    },
    {
      "indent": 3,
      "text": "o switching next hops should be avoided.",
      "ja": "次のホップを切り替えoを避けるべきです。"
    },
    {
      "indent": 3,
      "text": "A simple strategy is to choose the feasible route with the smallest metric, with a small amount of hysteresis applied to avoid switching router-ids.",
      "ja": "シンプルな戦略は、ルータIDの切り替えを避けるために適用される少量のヒステリシスで、最小のメトリックを持つ実行可能なルートを選択することです。"
    },
    {
      "indent": 3,
      "text": "After the route selection procedure is run, triggered updates (Section 3.7.2) and requests (Section 3.8.2) are sent.",
      "ja": "経路選択手順が実行された後、トリガアップデート（3.7.2）と要求（3.8.2）が送信されます。"
    },
    {
      "indent": 0,
      "text": "3.7. Sending Updates",
      "section_title": true,
      "ja": "3.7. アップデートを送信"
    },
    {
      "indent": 3,
      "text": "A Babel speaker advertises to its neighbours its set of selected routes. Normally, this is done by sending one or more multicast packets containing Update TLVs on all of its connected interfaces; however, on link technologies where multicast is significantly more expensive than unicast, a node MAY choose to send multiple copies of updates in unicast packets when the number of neighbours is small.",
      "ja": "バベルのスピーカーは、その隣に選択されたルートのセットをアドバタイズします。通常、これは、その接続されたすべてのインターフェイスに更新TLVを含む1つまたは複数のマルチキャストパケットを送信することによって行われます。しかし、マルチキャスト、ユニキャストよりもかなり高価であるリンク技術の上に、ノードが隣人の数が少ない場合には、ユニキャストパケットで更新の複数のコピーを送信することを選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "Additionally, in order to ensure that any black-holes are reliably cleared in a timely manner, a Babel node sends retractions (updates with an infinite metric) for any recently retracted prefixes.",
      "ja": "また、任意のブラックホールが確実に適時にクリアされることを保証するために、バベルノードは、任意の最近後退プレフィックスの撤回（無限のメトリックの更新）を送信します。"
    },
    {
      "indent": 3,
      "text": "If an update is for a route injected into the Babel domain by the local node (e.g., the address of a local interface, the prefix of a directly attached network, or redistributed from a different routing protocol), the router-id is set to the local id, the metric is set to some arbitrary finite value (typically 0), and the seqno is set to the local router's sequence number.",
      "ja": "更新は、ローカルノードによってバベルドメイン内に注入経路のためのものである場合（例えば、ローカルインタフェースのアドレスは、直接接続されたネットワークのプレフィックスが、又は異なるルーティングプロトコルから再配布）、ルータIDは次のように設定されていますローカルIDは、メトリックは、いくつかの任意の有限値（典型的には0）に設定され、SEQNOは、ローカルルータのシーケンス番号に設定されています。"
    },
    {
      "indent": 3,
      "text": "If an update is for a route learned from another Babel speaker, the router-id and sequence number are copied from the routing table entry, and the metric is computed as specified in Section 3.5.2.",
      "ja": "更新が別のバベルスピーカから学習した経路のためのものである場合、ルータID及びシーケンス番号は、ルーティングテーブルエントリからコピーされ、セクション3.5.2で指定されたメトリックが計算されます。"
    },
    {
      "indent": 0,
      "text": "3.7.1. Periodic Updates",
      "section_title": true,
      "ja": "3.7.1. 定期的な更新"
    },
    {
      "indent": 3,
      "text": "Every Babel speaker periodically advertises all of its selected routes on all of its interfaces, including any recently retracted routes. Since Babel doesn't suffer from routing loops (there is no \"counting to infinity\") and relies heavily on triggered updates (Section 3.7.2), this full dump only needs to happen infrequently.",
      "ja": "すべてのバベルのスピーカーは、定期的に任意の最近引き込まルートを含むすべてのインターフェイス上での選択されたルート、のすべてをアドバタイズします。バベルは、ルーティングループを苦しむ（なし「無限カウント」はありません）とトリガアップデート（3.7.2）に大きく依存していないので、この完全なダンプはまれにしか発生する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.7.2. Triggered Updates",
      "section_title": true,
      "ja": "3.7.2. トリガ更新"
    },
    {
      "indent": 3,
      "text": "In addition to the periodic routing updates, a Babel speaker sends unscheduled, or triggered, updates in order to inform its neighbours of a significant change in the network topology.",
      "ja": "定期的なルーティングアップデートに加えて、バベルのスピーカーは、ネットワークトポロジに大きな変化の隣人に通知するために、予定外の、またはトリガ更新を送信します。"
    },
    {
      "indent": 3,
      "text": "A change of router-id for the selected route to a given prefix may be indicative of a routing loop in formation; hence, a node MUST send a triggered update in a timely manner whenever it changes the selected router-id for a given destination. Additionally, it SHOULD make a reasonable attempt at ensuring that all neighbours receive this update.",
      "ja": "与えられたプレフィックスに選択されたルートのためのルータIDの変化は、形成中のルーティンを示すことができます。それは、所与の宛先の選択ルータIDを変更するたびに、したがって、ノードは、タイムリーにトリガ更新を送信しなければなりません。さらに、それはすべてのネイバーは、この更新プログラムを受けることを確実にすることで、合理的な試みを行う必要があります。"
    },
    {
      "indent": 3,
      "text": "There are two strategies for ensuring that. If the number of neighbours is small, then it is reasonable to send the update together with an acknowledgement request; the update is resent until all neighbours have acknowledged the packet, up to some number of times. If the number of neighbours is large, however, requesting acknowledgements from all of them might cause a non-negligible amount of network traffic; in that case, it may be preferable to simply repeat the update some reasonable number of times (say, 5 for wireless and 2 for wired links).",
      "ja": "これを確実にするための2つの方法があります。隣人の数が少ない場合には、確認要求とともに更新を送信するのが妥当です。すべてのネイバーは、何回かまで、パケットを認識するまで、更新が再送信されます。隣人の数が多い場合は、しかし、それらのすべてからの肯定応答を要求すると、ネットワークトラフィックの無視できない量が発生することがあります。その場合、単に更新（有線リンクの無線用たとえば、5および2）いくつかの合理的な回数繰り返すことが好ましいかもしれません。"
    },
    {
      "indent": 3,
      "text": "A route retraction is somewhat less worrying: if the route retraction doesn't reach all neighbours, a black-hole might be created, which, unlike a routing loop, does not endanger the integrity of the network. When a route is retracted, a node SHOULD send a triggered update and SHOULD make a reasonable attempt at ensuring that all neighbours receive this retraction.",
      "ja": "ルート後退はやや少ない心配です：ルートの後退は、すべてのネイバーに到達しない場合は、ブラックホールが作成されることがあり、ルーティングループとは異なり、ネットワークの整合性を危険にさらすしません、。ルートが後退すると、ノードは、トリガ更新を送信すべきであり、すべてのネイバーは、この後退を受けることを確実にすることで、合理的な試みを行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, a node MAY send a triggered update when the metric for a given prefix changes in a significant manner, either due to a received update or because a link cost has changed. A node SHOULD NOT send triggered updates for other reasons, such as when there is a minor fluctuation in a route's metric, when the selected next hop changes, or to propagate a new sequence number (except to satisfy a request, as specified in Section 3.8).",
      "ja": "リンクコスト受信した更新のため、またはいずれかの重要な方法で、与えられたプレフィックスの変更のためのメトリックは、変更されたときに最後に、ノードは、トリガ更新を送信することができます。ノードは、このようなルートのメトリックではマイナーな変動があった場合に、選択されたネクストホップの変更など、他の理由でトリガ更新を送信することはできません、または3.8節で指定され、要求を満たすために除いて新しいシーケンス番号を（伝播します）。"
    },
    {
      "indent": 0,
      "text": "3.7.3. Maintaining Feasibility Distances",
      "section_title": true,
      "ja": "3.7.3. 実現可能性の距離を維持します"
    },
    {
      "indent": 3,
      "text": "Before sending an update (prefix, plen, router-id, seqno, metric) with finite metric (i.e., not a route retraction), a Babel node updates the feasibility distance maintained in the source table. This is done as follows.",
      "ja": "有限のメトリック（すなわち、しない経路後退）で更新（接頭辞、PLEN、ルータID、SEQNO、メトリック）を送信する前に、バベルノードは、ソーステーブル内で維持可能性の距離を更新します。これは次のように行われます。"
    },
    {
      "indent": 3,
      "text": "If no entry indexed by (prefix, plen, router-id) exists in the source table, then one is created with value (prefix, plen, router-id, seqno, metric).",
      "ja": "（接頭辞、PLEN、ルータID）によって指標付けエントリは、ソーステーブルに存在しない場合、一方が値（プレフィックス、PLEN、ルータID、SEQNO、メトリック）を使用して作成されます。"
    },
    {
      "indent": 3,
      "text": "If an entry (prefix, plen, router-id, seqno', metric') exists, then it is updated as follows:",
      "ja": "エントリ（接頭辞、PLEN、ルータID、SEQNO「メトリック」）が存在する場合は、次のように、それが更新されます。"
    },
    {
      "indent": 3,
      "text": "o if seqno > seqno', then seqno' := seqno, metric' := metric;",
      "ja": "O場合SEQNO> SEQNO '次いでSEQNO'：= SEQNO、メトリック」：=メトリック。"
    },
    {
      "indent": 3,
      "text": "o if seqno = seqno' and metric' > metric, then metric' := metric;",
      "ja": "O「メトリック次に、メトリック> SEQNO = SEQNO「およびメトリック」の場合：=メトリック。"
    },
    {
      "indent": 3,
      "text": "o otherwise, nothing needs to be done.",
      "ja": "Oそれ以外の場合は、何も実行する必要がありません。"
    },
    {
      "indent": 3,
      "text": "The garbage-collection timer for the modified entry is then reset. Note that the garbage-collection timer is not reset when a retraction is sent.",
      "ja": "変更されたエントリのためのガベージコレクションタイマーがリセットされ、その後です。後退が送信されたときにガベージコレクションタイマーがリセットされないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.7.4. Split Horizon",
      "section_title": true,
      "ja": "3.7.4. スプリットホライズン"
    },
    {
      "indent": 3,
      "text": "When running over a transitive, symmetric link technology, e.g., a point-to-point link or a wired LAN technology such as Ethernet, a Babel node SHOULD use an optimisation known as split horizon. When split horizon is used on a given interface, a routing update is not sent on this particular interface when the advertised route was learnt from a neighbour over the same interface.",
      "ja": "推移的、対称的なリンク技術、例えば上で実行されている場合、イーサネットなどのポイントツーポイントリンクまたは有線LAN技術は、バベルノードは、スプリットホライズンとして知られている最適化を使用すべきです。スプリットホライズンは、所定のインターフェイス上で使用される場合、ルーティングアップデートをアドバタイズされたルートが同じインタフェースを介してネイバーから学習されたこの特定のインターフェイス上で送信されていません。"
    },
    {
      "indent": 3,
      "text": "Split horizon SHOULD NOT be applied to an interface unless the interface is known to be symmetric and transitive; in particular, split horizon is not applicable to decentralised wireless link technologies (e.g., IEEE 802.11 in ad hoc mode).",
      "ja": "インタフェースは対称と推移的であることが知られていない限りスプリットホライズンは、インターフェイスに適用されるべきではありません。特に、スプリットホライズンは、分散型の無線リンク技術（例えば、IEEE 802.11におけるアドホックモード）には適用できません。"
    },
    {
      "indent": 0,
      "text": "3.8. Explicit Route Requests",
      "section_title": true,
      "ja": "3.8. 明示的経路要求"
    },
    {
      "indent": 3,
      "text": "In normal operation, a node's routing table is populated by the regular and triggered updates sent by its neighbours. Under some circumstances, however, a node sends explicit requests to cause a resynchronisation with the source after a mobility event or to prevent a route from spuriously expiring.",
      "ja": "通常の動作では、ノードのルーティングテーブルは、そのネイバーによって送信された定期的な及びトリガ更新によって取り込まれます。いくつかの状況下では、しかし、ノードは、モビリティイベント後にソースとの再同期を引き起こすか、誤って期限切れの経路を防ぐために、明示的な要求を送信します。"
    },
    {
      "indent": 3,
      "text": "The Babel protocol provides two kinds of explicit requests: route requests, which simply request an update for a given prefix, and seqno requests, which request an update for a given prefix with a specific sequence number. The former are never forwarded; the latter are forwarded if they cannot be satisfied by a neighbour.",
      "ja": "特定のシーケンス番号で指定されたプレフィックスの更新を要求単に指定された接頭辞の更新を要求するルート要求、およびSEQNO要求、：バベルプロトコルは、明示的な要求の二種類を提供します。前者は転送されることはありません。彼らは隣人によって満たすことができない場合は、後者が転送されます。"
    },
    {
      "indent": 0,
      "text": "3.8.1. Handling Requests",
      "section_title": true,
      "ja": "3.8.1. 要求の処理"
    },
    {
      "indent": 3,
      "text": "Upon receiving a request, a node either forwards the request or sends an update in reply to the request, as described in the following sections. If this causes an update to be sent, the update is either sent to a multicast address on the interface on which the request was received, or to the unicast address of the neighbour that sent the update.",
      "ja": "要求を受信すると、ノードが要求を転送いずれか、または次のセクションで説明したように、要求に対する応答に更新を送信します。この更新が送信される場合は、更新は、いずれかの要求を受信し、または更新を送信したネイバーのユニキャストアドレスにされたインターフェイス上のマルチキャストアドレスに送信されます。"
    },
    {
      "indent": 3,
      "text": "The exact behaviour is different for route requests and seqno requests.",
      "ja": "正確な動作は、ルート要求とSEQNO要求のために異なっています。"
    },
    {
      "indent": 0,
      "text": "3.8.1.1. Route Requests",
      "section_title": true,
      "ja": "3.8.1.1。ルート要求"
    },
    {
      "indent": 3,
      "text": "When a node receives a route request for a prefix (prefix, plen), it checks its route table for a selected route to this exact prefix. If such a route exists, it MUST send an update; if such a route does not, it MUST send a retraction for that prefix.",
      "ja": "ノードプレフィックス（接頭辞、PLEN）のルート要求を受信すると、この正確なプレフィックスに選択された経路に対するそのルートテーブルをチェックします。このような経路が存在する場合は、アップデートを送らなければなりません。このような経路がない場合は、その接頭語のための後退を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a node receives a wildcard route request, it SHOULD send a full routing table dump.",
      "ja": "ノードは、ワイルドカードルート要求を受信すると、それは完全なルーティングテーブルダンプを送信すべきです。"
    },
    {
      "indent": 0,
      "text": "3.8.1.2. Seqno Requests",
      "section_title": true,
      "ja": "3.8.1.2。 SEQNO要求"
    },
    {
      "indent": 3,
      "text": "When a node receives a seqno request for a given router-id and sequence number, it checks whether its routing table contains a selected entry for that prefix; if no such entry exists, or the entry has infinite metric, it ignores the request.",
      "ja": "ノードは、所与のルータIDおよびシーケンス番号のSEQNO要求を受信すると、そのルーティングテーブルは、そのプレフィックスの選択されたエントリが含まれているかどうかをチェックします。そのようなエントリが存在しない、またはエントリが無限のメトリックを有する場合、それは要求を無視します。"
    },
    {
      "indent": 3,
      "text": "If a selected route for the given prefix exists, and either the router-ids are different or the router-ids are equal and the entry's sequence number is no smaller than the requested sequence number, it MUST send an update for the given prefix.",
      "ja": "与えられたプレフィックスの選択されたルートが存在し、いずれかのルータIDが異なっているか、ルータIDが等しく、エントリのシーケンス番号が要求されたシーケンス番号より小さくない場合、それは、与えられたプレフィックスの更新を送信しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the router-ids match but the requested seqno is larger than the route entry's, the node compares the router-id against its own router-id. If the router-id is its own, then it increases its sequence number by 1 and sends an update. A node MUST NOT increase its sequence number by more than 1 in response to a route request.",
      "ja": "ルータIDが一致するだけで、要求SEQNOは、ルートエントリのよりも大きい場合、ノードは、自身のルータIDに対するルータIDを比較します。ルータIDが独自である場合、それは1によって、そのシーケンス番号を増加させ、更新を送信します。ノードは、ルート要求に応答して1以上によって、そのシーケンス番号を増加させなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the requested router-id is not its own, the received request's hop count is 2 or more, and the node has a route (not necessarily a feasible one) for the requested prefix that does not use the requestor as a next hop, the node SHOULD forward the request. It does so by decreasing the hop count and sending the request in a unicast packet destined to a neighbour that advertises the given prefix (not necessarily the selected neighbour) and that is distinct from the neighbour from which the request was received.",
      "ja": "要求されたルータIDは、独自でない場合は、受信した要求のホップ数が2以上であり、かつノードがネクストホップとして、リクエスタを使用していない要求されたプレフィックスのルート（必ずしも実現可能なもの）を持っています、ノードは、要求を転送する必要があります。これはホップカウントを減少させ、所定のプレフィクス（必ずしも選択された隣接）をアドバタイズし、その要求が受信されたネイバーから区別されるネイバー宛てのユニキャストパケットで要求を送信することによってそうします。"
    },
    {
      "indent": 3,
      "text": "A node SHOULD maintain a list of recently forwarded requests and forward the reply in a timely manner. A node SHOULD compare every incoming request against its list of recently forwarded requests and avoid forwarding it if it is redundant.",
      "ja": "ノードは、最近転送された要求のリストを維持し、タイムリーに返信を転送する必要があります。ノードは、最近転送された要求のリストに対するすべての着信要求を比較し、それが冗長である場合は、それを転送することは避けてください。"
    },
    {
      "indent": 3,
      "text": "Since the request-forwarding mechanism does not necessarily obey the feasibility condition, it may get caught in routing loops; hence, requests carry a hop count to limit the time for which they remain in the network. However, since requests are only ever forwarded as unicast packets, the initial hop count need not be kept particularly low, and performing an expanding horizon search is not necessary. A request MUST NOT be forwarded to a multicast address, and it MUST be forwarded to a single neighbour only.",
      "ja": "要求転送メカニズムは必ずしも実行可能性条件に従わないので、ルーティングループに引っかかることができます。したがって、要求は、彼らがネットワークに残っている時間を制限するホップ数を運びます。要求がしかユニキャストパケットとして転送されているので、最初のホップ数が特に低く保つことがない、と拡大地平線の検索を実行する必要はありません必要は。要求は、マルチキャストアドレスに転送してはならない、そしてそれは、単一の隣人に転送されなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.8.2. Sending Requests",
      "section_title": true,
      "ja": "3.8.2. リクエストの送信"
    },
    {
      "indent": 3,
      "text": "A Babel node MAY send a route or seqno request at any time, to a multicast or a unicast address; there is only one case when originating requests is required (Section 3.8.2.1).",
      "ja": "バベルノードは、マルチキャストまたはユニキャストアドレスに、任意の時点で経路又はSEQNO要求を送信することができます。元の要求が必要とされる唯一のケース（セクション3.8.2.1）があります。"
    },
    {
      "indent": 0,
      "text": "3.8.2.1. Avoiding Starvation",
      "section_title": true,
      "ja": "3.8.2.1。飢餓を回避"
    },
    {
      "indent": 3,
      "text": "When a route is retracted or expires, a Babel node usually switches to another feasible route for the same prefix. It may be the case, however, that no such routes are available.",
      "ja": "ルートが後退または満了した場合には、バベルノードは通常、同じプレフィクスの別の実現可能な経路に切り替わります。これは、そのような経路が利用可能でないこと、しかし、場合であってもよいです。"
    },
    {
      "indent": 3,
      "text": "A node that has lost all feasible routes to a given destination MUST send a seqno request. The router-id of the request is set to the router-id of the route that it has just lost, and the requested seqno is the value contained in the source table, plus 1.",
      "ja": "特定の宛先へのすべての実現可能なルートを失ったノードは、SEQNO要求を送信しなければなりません。リクエストのルータIDは、それだけ失った経路のルータIDに設定され、要求されたSEQNOは、ソーステーブルに含まれる値は、プラス1です。"
    },
    {
      "indent": 3,
      "text": "Such a request SHOULD be multicast over all of the node's attached interfaces. Similar requests will be sent by other nodes that are affected by the route's loss and will be forwarded by neighbouring nodes up to the source. If the network is connected, and there is no packet loss, this will result in a route being advertised with a new sequence number. (Note that, due to duplicate suppression, only a small number of such requests will actually reach the source.)",
      "ja": "そのような要求は、ノードの取り付けられたインターフェースの全てを介してマルチキャストされるべきです。同様の要求は、ルートの損失の影響を受けているとソースまでの隣接ノードによって転送される他のノードによって送信されます。ネットワークが接続されており、パケットロスがない場合、これは、新しいシーケンス番号で公示されているルートになります。 （抑制重複するため、そのような要求のごく少数が実際にソースに到達することに留意されたいです。）"
    },
    {
      "indent": 3,
      "text": "In order to compensate for packet loss, a node SHOULD repeat such a request a small number of times if no route becomes feasible within a short time. Under heavy packet loss, however, all such requests may be lost; in that case, the second mechanism in the next section will eventually ensure that a new seqno is received.",
      "ja": "NOルートを短時間で可能になっていない場合は、パケット損失を補償するために、ノードは、そのような要求を少ない回数を繰り返すべきです。重いパケットロスの下では、しかし、すべてのそのような要求が失われることがあります。その場合には、次のセクションの第2のメカニズムは、最終的に新しいSEQNOが受信されることを保証します。"
    },
    {
      "indent": 0,
      "text": "3.8.2.2. Dealing with Unfeasible Updates",
      "section_title": true,
      "ja": "3.8.2.2。実現不可能なアップデートで対処"
    },
    {
      "indent": 3,
      "text": "When a route's metric increases, a node might receive an unfeasible update for a route that it has currently selected. As specified in Section 3.5.1, the receiving node will either ignore the update or retract the route.",
      "ja": "場合は、ルートのメトリック増加し、ノードは、それが現在選択されていることルートの実現不可能なアップデートを受け取ることがあります。セクション3.5.1で指定されるように、受信ノードは、更新を無視するか、ルートを撤回しますか。"
    },
    {
      "indent": 3,
      "text": "In order to keep routes from spuriously expiring because they have become unfeasible, a node SHOULD send a unicast seqno request whenever it receives an unfeasible update for a route that is currently selected. The requested sequence number is computed from the source table as above.",
      "ja": "それは現在選択されているルートに実現不可能更新を受信するたびに、それらが不可能となっているので、誤って期限切れからのルートを維持するために、ノードは、ユニキャストSEQNO要求を送信すべきです。要求されたシーケンス番号は、上記のように、ソーステーブルから計算されます。"
    },
    {
      "indent": 3,
      "text": "Additionally, a node SHOULD send a unicast seqno request whenever it receives an unfeasible update from a currently unselected neighbour that is \"good enough\", i.e., that would lead to the received route becoming selected were it feasible.",
      "ja": "それが可能であった、選択しつつ、受信した経路につながる「十分に良い」で現在選択されていない隣人、すなわち、から実行不可能更新を受信するたびに加えて、ノードは、ユニキャストSEQNO要求を送信すべきです。"
    },
    {
      "indent": 0,
      "text": "3.8.2.3. Preventing Routes from Expiring",
      "section_title": true,
      "ja": "3.8.2.3。期限切れからのルートの防止"
    },
    {
      "indent": 3,
      "text": "In normal operation, a route's expiry timer should never trigger: since a route's hold time is computed from an explicit interval included in Update TLVs, a new update should arrive in time to prevent a route from expiring.",
      "ja": "通常の操作では、ルートの有効期限タイマーがトリガーすることはありません：ルートのホールド時間が更新のTLVに含ま明示的な間隔から計算されるため、新しい更新は期限切れの経路を防ぐために、時間内に到着しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the presence of packet loss, however, it may be the case that no update is successfully received for an extended period of time, causing a route to expire. In order to avoid such spurious expiry, shortly before a selected route expires, a Babel node SHOULD send a unicast route request to the neighbour that advertised this route; since nodes always send retractions in response to non-wildcard route requests (Section 3.8.1.1), this will usually result in either the route being refreshed or a retraction being received.",
      "ja": "パケット損失の存在下で、しかし、それが期限切れに経路を引き起こし、何の更新が正常に長期間にわたって受信されない場合であってもよいです。そのような偽の満了を回避するために、選択された経路の有効期限が切れる直前に、バベルノードは、このルートをアドバタイズ隣人へのユニキャストルート要求を送信すべきです。ノードは常に非ワイルドカードルート要求（セクション3.8.1.1）に対応して撤回を送信するので、これは通常、リフレッシュされた経路または受信されて後退のいずれかになります。"
    },
    {
      "indent": 0,
      "text": "3.8.2.4. Acquiring New Neighbours",
      "section_title": true,
      "ja": "3.8.2.4。新しい隣人を獲得"
    },
    {
      "indent": 3,
      "text": "In order to speed up convergence after a mobility event, a node MAY send a unicast wildcard request after acquiring a new neighbour. Additionally, a node MAY send a small number of multicast wildcard requests shortly after booting.",
      "ja": "モビリティイベント後の収束をスピードアップするためには、ノードは、新しい隣人を取得した後に、ユニキャストワイルドカード要求を送信することができます。また、ノードはすぐに起動後にマルチキャストワイルドカード要求の数が少ないを送信することができます。"
    },
    {
      "indent": 0,
      "text": "4. Protocol Encoding",
      "section_title": true,
      "ja": "4.プロトコルエンコーディング"
    },
    {
      "indent": 3,
      "text": "A Babel packet is sent as the body of a UDP datagram, with network-layer hop count set to 1, destined to a well-known multicast address or to a unicast address, over IPv4 or IPv6; in the case of IPv6, these addresses are link-local. Both the source and destination UDP port are set to a well-known port number. A Babel packet MUST be silently ignored unless its source address is either a link-local IPv6 address, or an IPv4 address belonging to the local network, and its source port is the well-known Babel port. Babel packets MUST NOT be sent as IPv6 Jumbograms.",
      "ja": "バベルパケットはIPv4またはIPv6の上に、よく知られているマルチキャストアドレス又はユニキャストアドレスを宛先と1に設定されたネットワークレイヤのホップカウントと、UDPデータグラムの本体として送信されます。 IPv6の場合には、これらのアドレスはリンクローカルです。両方のソースと宛先UDPポートは、周知のポート番号に設定されています。そのソースアドレスがリンクローカルIPv6アドレス、またはローカルネットワークに属しているIPv4アドレスのいずれかであり、そのソース・ポートは、周知バベルポートでない限りバベルパケットは無視されなければなりません。バベルパケットは、IPv6ジャンボグラムとして送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "In order to minimise the number of packets being sent while avoiding lower-layer fragmentation, a Babel node SHOULD attempt to maximise the size of the packets it sends, up to the outgoing interface's MTU adjusted for lower-layer headers (28 octets for UDP/IPv4, 48 octets for UDP/IPv6). It MUST NOT send packets larger than the attached interface's MTU (adjusted for lower-layer headers) or 512 octets, whichever is larger, but not exceeding 2^16 - 1 adjusted for lower- layer headers. Every Babel speaker MUST be able to receive packets that are as large as any attached interface's MTU (adjusted for lower-layer headers) or 512 octets, whichever is larger.",
      "ja": "下層の断片化を回避しながら、送信されるパケットの数を最小限にするために、バベルノードは/（発信インターフェースのMTUまで下層ヘッダーの調整、それが送信するパケットのサイズを最大にするために、UDPの28個のオクテットを試みるべきですIPv4の、UDP / IPv6の48オクテット）。それは添付のインターフェースのMTUよりも大きいパケットを送ってはいけません大きい方又は512個のオクテット（下層ヘッダーの調整）が、2 ^ 16を超えない - 低級層ヘッダーの調整1。すべてのバベルスピーカーが接続されているすべてのインターフェイスのMTUと同じ大きされたパケットを受信できなければならない大きい方又は512個のオクテット（下層ヘッダーのために調整）。"
    },
    {
      "indent": 3,
      "text": "In order to avoid global synchronisation of a Babel network and to aggregate multiple TLVs into large packets, a Babel node MUST buffer every TLV and delay sending a UDP packet by a small, randomly chosen delay [JITTER]. In order to allow accurate computation of packet loss rates, this delay MUST NOT be larger than half the advertised Hello interval.",
      "ja": "バベルネットワークのグローバル同期化を回避し、大きなパケットに複数のTLVを集約するために、バベルノードは小さな、ランダムに選択された遅延[JITTER]でUDPパケットを送信するすべてのTLV及び遅延バッファしなければなりません。パケット損失率の正確な計算を可能にするために、この遅延は半分宣伝のHello間隔よりも大きくすることはできません。"
    },
    {
      "indent": 0,
      "text": "4.1. Data Types",
      "section_title": true,
      "ja": "4.1. データの種類"
    },
    {
      "indent": 0,
      "text": "4.1.1. Interval",
      "section_title": true,
      "ja": "4.1.1. 間隔"
    },
    {
      "indent": 3,
      "text": "Relative times are carried as 16-bit values specifying a number of centiseconds (hundredths of a second). This allows times up to roughly 11 minutes with a granularity of 10 ms, which should cover all reasonable applications of Babel.",
      "ja": "相対時間はセンチ秒（1/100秒）の数を指定する16ビット値として実施されます。これは、バベルのすべての合理的なアプリケーションをカバーする必要があり、10ミリ秒の粒度でおおよそ11分までの時間を可能にします。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Router-Id",
      "section_title": true,
      "ja": "4.1.2. ルータID"
    },
    {
      "indent": 3,
      "text": "A router-id is an arbitrary 8-octet value. Router-ids SHOULD be assigned in modified EUI-64 format [ADDRARCH].",
      "ja": "ルータIDは任意の8オクテット値です。ルータIDは[ADDRARCH]修飾EUI-64フォーマットで割り当てられるべきです。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Address",
      "section_title": true,
      "ja": "4.1.3. 住所"
    },
    {
      "indent": 3,
      "text": "Since the bulk of the protocol is taken by addresses, multiple ways of encoding addresses are defined. Additionally, a common subnet prefix may be omitted when multiple addresses are sent in a single packet -- this is known as address compression [PACKETBB].",
      "ja": "プロトコルの大部分はアドレスによって行われるので、符号化アドレスの複数の方法が定義されています。複数のアドレスを単一のパケットで送信される場合に加えて、共通のサブネットプレフィックスを省略することができる - これは、アドレス圧縮[PACKETBB]として知られています。"
    },
    {
      "indent": 3,
      "text": "Address encodings:",
      "ja": "アドレスエンコード："
    },
    {
      "indent": 3,
      "text": "o AE 0: wildcard address. The value is 0 octets long.",
      "ja": "O AE 0：ワイルドカードアドレス。値は0オクテットの長さです。"
    },
    {
      "indent": 3,
      "text": "o AE 1: IPv4 address. Compression is allowed. 4 octets or less.",
      "ja": "O AE 1：IPv4アドレス。圧縮は許可されています。 4つのオクテット以下です。"
    },
    {
      "indent": 3,
      "text": "o AE 2: IPv6 address. Compression is allowed. 16 octets or less.",
      "ja": "O AE 2：IPv6アドレス。圧縮は許可されています。 16オクテット以下です。"
    },
    {
      "indent": 3,
      "text": "o AE 3: link-local IPv6 address. The value is 8 octets long, a prefix of fe80::/64 is implied.",
      "ja": "O AE 3：リンクローカルIPv6アドレス。値は、長い8つのオクテット、FE80のプレフィックス:: / 64が暗示されています。"
    },
    {
      "indent": 3,
      "text": "The address family of an address is either IPv4 or IPv6; it is undefined for AE 0, IPv4 for AE 1, and IPv6 for AE 2 and 3.",
      "ja": "アドレスのアドレスファミリはIPv4またはIPv6のいずれかです。これはAE 0、AE 1のIPv4、及びAE 2及び3のIPv6のために定義されていません。"
    },
    {
      "indent": 0,
      "text": "4.1.4. Prefixes",
      "section_title": true,
      "ja": "4.1.4. 接頭辞"
    },
    {
      "indent": 3,
      "text": "A network prefix is encoded just like a network address, but it is stored in the smallest number of octets that are enough to hold the significant bits (up to the prefix length).",
      "ja": "ネットワークプレフィックスは、単にネットワークアドレスのような符号化されているが、それは、上位ビット（プレフィックス長まで）を保持するのに十分であるオクテットの最小数に格納されています。"
    },
    {
      "indent": 0,
      "text": "4.2. Packet Format",
      "section_title": true,
      "ja": "4.2. パケットフォーマット"
    },
    {
      "indent": 3,
      "text": "A Babel packet consists of a 4-octet header, followed by a sequence of TLVs.",
      "ja": "バベルパケットのTLVのシーケンスが続く4オクテットのヘッダから成ります。"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Magic     |    Version    |        Body length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Packet Body ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Magic The arbitrary but carefully chosen value 42 (decimal); packets with a first octet different from 42 MUST be silently ignored.",
      "ja": "マジック任意であるが、注意深く選択された値が42（10進数）。 42異なる最初のオクテットのパケットを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Version This document specifies version 2 of the Babel protocol. Packets with a second octet different from 2 MUST be silently ignored.",
      "ja": "バージョンは、この文書では、バベルプロトコルのバージョン2を指定します。 2とは異なる第2オクテットのパケットを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Body length The length in octets of the body following the packet header.",
      "ja": "体長パケットヘッダに続く本体のオクテット単位の長さ。"
    },
    {
      "indent": 3,
      "text": "Body The packet body; a sequence of TLVs.",
      "ja": "ボディパケット本体と、 TLVのシーケンス。"
    },
    {
      "indent": 3,
      "text": "Any data following the body MUST be silently ignored.",
      "ja": "身体以下のいずれかのデータは黙って無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.3. TLV Format",
      "section_title": true,
      "ja": "4.3.  TLVのフォーマット"
    },
    {
      "indent": 3,
      "text": "With the exception of Pad1, all TLVs have the following structure:",
      "ja": "パッド1を除いて、すべてのTLVは以下の構造を有します："
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Type      |    Length     |     Body...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type The type of the TLV.",
      "ja": "TLVの種類を入力します。"
    },
    {
      "indent": 3,
      "text": "Length The length of the body, exclusive of the Type and Length fields. If the body is longer than the expected length of a given type of TLV, any extra data MUST be silently ignored.",
      "ja": "タイプと長さフィールドの排他的な長さ本体の長さ、。ボディはTLVの特定のタイプの予想される長さよりも長い場合、余分なデータは黙って無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Body The TLV body, the interpretation of which depends on the type.",
      "ja": "ボディザ・TLV本体、種類に依存するの解釈。"
    },
    {
      "indent": 3,
      "text": "TLVs with an unknown type value MUST be silently ignored.",
      "ja": "未知のタイプの値を持つTLVが静かに無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4. Details of Specific TLVs",
      "section_title": true,
      "ja": "4.4. 特定のTLVの詳細"
    },
    {
      "indent": 0,
      "text": "4.4.1. Pad1",
      "section_title": true,
      "ja": "4.4.1.  PAD1"
    },
    {
      "indent": 3,
      "text": "0\n0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|   Type = 0    |\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 0 to indicate a Pad1 TLV.",
      "ja": "タイプは、パッド1 TLVを示すために0に設定します。"
    },
    {
      "indent": 3,
      "text": "This TLV is silently ignored on reception.",
      "ja": "このTLVは黙って、レセプションで無視されます。"
    },
    {
      "indent": 0,
      "text": "4.4.2. PadN",
      "section_title": true,
      "ja": "4.4.2.  PADN"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 1   |    Length     |      MBZ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 1 to indicate a PadN TLV.",
      "ja": "タイプは、パッドN TLVを示すために1に設定します。"
    },
    {
      "indent": 3,
      "text": "Length The length of the body, exclusive of the Type and Length fields.",
      "ja": "タイプと長さフィールドの排他的な長さ本体の長さ、。"
    },
    {
      "indent": 3,
      "text": "MBZ Set to 0 on transmission.",
      "ja": "MBZは、送信時に0に設定してください。"
    },
    {
      "indent": 3,
      "text": "This TLV is silently ignored on reception.",
      "ja": "このTLVは黙って、レセプションで無視されます。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Acknowledgement Request",
      "section_title": true,
      "ja": "4.4.3. 謝辞リクエスト"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 2   |    Length     |          Reserved             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Nonce              |          Interval             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This TLV requests that the receiver send an Acknowledgement TLV within the number of centiseconds specified by the Interval field.",
      "ja": "このTLVは、受信機は間隔]フィールドで指定されたセンチ秒数以内に謝辞TLVを送信することを要求します。"
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 2 to indicate an Acknowledgement Request TLV.",
      "ja": "タイプは、確認応答要求TLVを示すために、2に設定します。"
    },
    {
      "indent": 3,
      "text": "Length The length of the body, exclusive of the Type and Length fields.",
      "ja": "タイプと長さフィールドの排他的な長さ本体の長さ、。"
    },
    {
      "indent": 3,
      "text": "Reserved Sent as 0 and MUST be ignored on reception.",
      "ja": "予約済み0として送信され、受信時に無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Nonce An arbitrary value that will be echoed in the receiver's Acknowledgement TLV.",
      "ja": "受信者の謝辞TLVにエコーされる任意の値をナンス。"
    },
    {
      "indent": 3,
      "text": "Interval A time interval in centiseconds after which the sender will assume that this packet has been lost. This MUST NOT be 0. The receiver MUST send an acknowledgement before this time has elapsed (with a margin allowing for propagation time).",
      "ja": "送信側はこのパケットが失われていると仮定しますそのあとセンチ秒の時間間隔を間隔。これは、この時間（伝搬時間を可能にする余裕をもって）経過する前に受信機が肯定応答を送信しなければならない0であるはずがありません。"
    },
    {
      "indent": 0,
      "text": "4.4.4. Acknowledgement",
      "section_title": true,
      "ja": "4.4.4. 了承"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 3   |    Length     |            Nonce              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This TLV is sent by a node upon receiving an Acknowledgement Request.",
      "ja": "このTLVは、応答要求を受信するノードによって送信されます。"
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 3 to indicate an Acknowledgement TLV.",
      "ja": "タイプは謝辞TLVを示すために、3に設定します。"
    },
    {
      "indent": 3,
      "text": "Length The length of the body, exclusive of the Type and Length fields.",
      "ja": "タイプと長さフィールドの排他的な長さ本体の長さ、。"
    },
    {
      "indent": 3,
      "text": "Nonce Set to the Nonce value of the Acknowledgement Request that prompted this Acknowledgement.",
      "ja": "この謝辞を促した承認要求のNonceの値に設定しナンス。"
    },
    {
      "indent": 3,
      "text": "Since nonce values are not globally unique, this TLV MUST be sent to a unicast address.",
      "ja": "ナンス値はグローバルに一意ではありませんので、このTLVは、ユニキャストアドレスに送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.5. Hello",
      "section_title": true,
      "ja": "4.4.5. こんにちは"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 4   |    Length     |          Reserved             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Seqno              |          Interval             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This TLV is used for neighbour discovery and for determining a link's reception cost.",
      "ja": "このTLVは、近隣探索のためにと、リンクの受信コストを決定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 4 to indicate a Hello TLV.",
      "ja": "タイプこんにちはTLVを示すために、4に設定します。"
    },
    {
      "indent": 3,
      "text": "Length The length of the body, exclusive of the Type and Length fields.",
      "ja": "タイプと長さフィールドの排他的な長さ本体の長さ、。"
    },
    {
      "indent": 3,
      "text": "Reserved Sent as 0 and MUST be ignored on reception.",
      "ja": "予約済み0として送信され、受信時に無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Seqno The value of the sending node's Hello seqno for this interface.",
      "ja": "このインタフェースの送信ノードのHello SEQNOの値をSEQNO。"
    },
    {
      "indent": 3,
      "text": "Interval An upper bound, expressed in centiseconds, on the time after which the sending node will send a new Hello TLV. This MUST NOT be 0.",
      "ja": "インターバル・アン上限は、送信ノードが新しいこんにちはTLVを送信するまでの時間に、センチ秒で表されます。これは、0にすることはできません。"
    },
    {
      "indent": 3,
      "text": "Since there is a single seqno counter for all the Hellos sent by a given node over a given interface, this TLV MUST be sent to a multicast destination. In order to avoid large discontinuities in link quality, multiple Hello TLVs SHOULD NOT be sent in the same packet.",
      "ja": "所定のインタフェースを介して所定のノードによって送信されたすべてのハローズのための単一のSEQNOカウンタがあるので、このTLVは、マルチキャストの宛先に送信されなければなりません。リンク品質に大きな不連続性を避けるために、複数こんにちはTLVが同じパケットで送るべきではありません。"
    },
    {
      "indent": 0,
      "text": "4.4.6. IHU",
      "section_title": true,
      "ja": "4.4.6.  JESUS"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 5   |    Length     |       AE      |    Reserved   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Rxcost             |          Interval             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Address...\n+-+-+-+-+-+-+-+-+-+-+-+-",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An IHU (\"I Heard You\") TLV is used for confirming bidirectional reachability and carrying a link's transmission cost.",
      "ja": "IHU（「私はあなたを聞いた」）TLVは、双方向の到達可能性を確認し、リンクの送信コストを実施するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 5 to indicate an IHU TLV.",
      "ja": "タイプはIHU TLVを示すために、5に設定します。"
    },
    {
      "indent": 3,
      "text": "Length The length of the body, exclusive of the Type and Length fields.",
      "ja": "タイプと長さフィールドの排他的な長さ本体の長さ、。"
    },
    {
      "indent": 3,
      "text": "AE The encoding of the Address field. This should be 1 or 3 in most cases. As an optimisation, it MAY be 0 if the TLV is sent to a unicast address, if the association is over a point-to-point link, or when bidirectional reachability is ascertained by means outside of the Babel protocol.",
      "ja": "AEアドレスフィールドのエンコーディング。これは、ほとんどの場合、1または3でなければなりません。アソシエーションはポイントツーポイントリンク上にある場合、または双方向到達可能性は、バベルプロトコルの外部手段によって確認された場合TLVは、ユニキャストアドレスに送信された場合に最適化されるように、それは0であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Reserved Sent as 0 and MUST be ignored on reception.",
      "ja": "予約済み0として送信され、受信時に無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Rxcost The rxcost according to the sending node of the interface whose address is specified in the Address field. The value FFFF hexadecimal (infinity) indicates that this interface is unreachable.",
      "ja": "宛先アドレスフィールドに指定されたインターフェイスの送信ノードに応じrxcostをRxcost。値FFFF 16進数（無限大）は、このインターフェイスが到達不能であることを示しています。"
    },
    {
      "indent": 3,
      "text": "Interval An upper bound, expressed in centiseconds, on the time after which the sending node will send a new IHU; this MUST NOT be 0. The receiving node will use this value in order to compute a hold time for this symmetric association.",
      "ja": "インターバル・アン上限は、送信ノードが新しいIHUを送信するまでの時間に、センチ秒で表しました。これは、0が受信ノードがこの対称関連のホールド時間を計算するためにこの値を使用することはいけません。"
    },
    {
      "indent": 3,
      "text": "Address The address of the destination node, in the format specified by the AE field. Address compression is not allowed.",
      "ja": "AEフィールドで指定された形式で、宛先ノードのアドレス。アドレス圧縮が許可されていません。"
    },
    {
      "indent": 3,
      "text": "Conceptually, an IHU is destined to a single neighbour. However, IHU TLVs contain an explicit destination address, and it SHOULD be sent to a multicast address, as this allows aggregation of IHUs destined to distinct neighbours into a single packet and avoids the need for an ARP or Neighbour Discovery exchange when a neighbour is not being used for data traffic.",
      "ja": "概念的には、IHUは、単一の隣人に運命づけられています。しかし、IHUのTLVは、明示的な宛先アドレスが含まれており、これはIHUsの凝集が単一のパケットに明確な隣人に宛てと隣人がいないときARPや近隣探索交換の必要性を回避することができるとして、それは、マルチキャストアドレスに送ってくださいデータトラフィックのために使用されています。"
    },
    {
      "indent": 3,
      "text": "IHU TLVs with an unknown value for the AE field MUST be silently ignored.",
      "ja": "AEフィールドの未知の値を持つIHU TLVが静かに無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.7. Router-Id",
      "section_title": true,
      "ja": "4.4.7. ルータID"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 6   |    Length     |          Reserved             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                           Router-Id                           +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A Router-Id TLV establishes a router-id that is implied by subsequent Update TLVs.",
      "ja": "ルータID TLVは、後続の更新のTLVによって暗示されているルータIDを確立します。"
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 6 to indicate a Router-Id TLV.",
      "ja": "ルータID TLVを示すために、6に設定を入力します。"
    },
    {
      "indent": 3,
      "text": "Length The length of the body, exclusive of the Type and Length fields.",
      "ja": "タイプと長さフィールドの排他的な長さ本体の長さ、。"
    },
    {
      "indent": 3,
      "text": "Reserved Sent as 0 and MUST be ignored on reception.",
      "ja": "予約済み0として送信され、受信時に無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Router-Id The router-id for routes advertised in subsequent Update TLVs",
      "ja": "ルータID後続の更新のTLVでアドバタイズされるルートのルータID"
    },
    {
      "indent": 0,
      "text": "4.4.8. Next Hop",
      "section_title": true,
      "ja": "4.4.8. ネクストホップ"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 7   |    Length     |      AE       |   Reserved    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Next hop...\n+-+-+-+-+-+-+-+-+-+-+-+-",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A Next Hop TLV establishes a next-hop address for a given address family (IPv4 or IPv6) that is implied by subsequent Update TLVs.",
      "ja": "ネクストホップTLVは​​、後続の更新のTLVによって暗示された所定のアドレスファミリー（IPv4またはIPv6）のための次のホップアドレスを確立します。"
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 7 to indicate a Next Hop TLV.",
      "ja": "タイプは次のホップTLVを示すために7に設定します。"
    },
    {
      "indent": 3,
      "text": "Length The length of the body, exclusive of the Type and Length fields.",
      "ja": "タイプと長さフィールドの排他的な長さ本体の長さ、。"
    },
    {
      "indent": 3,
      "text": "AE The encoding of the Address field. This SHOULD be 1 or 3 and MUST NOT be 0.",
      "ja": "AEアドレスフィールドのエンコーディング。これは、1または3でなければならず、0であってはなりません。"
    },
    {
      "indent": 3,
      "text": "Reserved Sent as 0 and MUST be ignored on reception.",
      "ja": "予約済み0として送信され、受信時に無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Next hop The next-hop address advertised by subsequent Update TLVs, for this address family.",
      "ja": "次のこのアドレスファミリのために、その後の更新のTLVによってアドバタイズネクストホップアドレスをホップ。"
    },
    {
      "indent": 3,
      "text": "When the address family matches the network-layer protocol that this packet is transported over, a Next Hop TLV is not needed: in that case, the next hop is taken to be the source address of the packet.",
      "ja": "アドレスファミリは、このパケットが上に搬送されているネットワーク層プロトコルと一致する場合、ネクストホップTLVは​​不要である。その場合、次のホップがパケットの送信元アドレスであると解釈されます。"
    },
    {
      "indent": 3,
      "text": "Next Hop TLVs with an unknown value for the AE field MUST be silently ignored.",
      "ja": "AEフィールドの未知の値を持つネクストホップのTLVは黙って無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.9. Update",
      "section_title": true,
      "ja": "4.4.9. 更新"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 8   |    Length     |       AE      |    Flags      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Plen      |    Omitted    |            Interval           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Seqno             |            Metric             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Prefix...\n+-+-+-+-+-+-+-+-+-+-+-+-",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An Update TLV advertises or retracts a route. As an optimisation, this can also have the side effect of establishing a new implied router-id and a new default prefix.",
      "ja": "アップデートTLVはルートをアドバタイズしたり後退させます。最適化として、これはまた、新しい暗黙のルータIDと新しいデフォルトの接頭辞を確立する副作用を持つことができます。"
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 8 to indicate an Update TLV.",
      "ja": "タイプはアップデートTLVを示すために、8に設定します。"
    },
    {
      "indent": 3,
      "text": "Length The length of the body, exclusive of the Type and Length fields.",
      "ja": "タイプと長さフィールドの排他的な長さ本体の長さ、。"
    },
    {
      "indent": 3,
      "text": "AE The encoding of the Prefix field.",
      "ja": "AEプレフィックス]フィールドのエンコーディング。"
    },
    {
      "indent": 3,
      "text": "Flags The individual bits of this field specify special handling of this TLV (see below). Every node MUST be able to interpret the flags with values 80 and 40 hexadecimal; unknown flags MUST be silently ignored.",
      "ja": "フラグは、この分野の個々のビットは、（下記参照）、このTLVの特別な処理を指定します。すべてのノードは、値80と40進数でフラグを解釈できなければなりません。未知のフラグは黙って無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Plen The length of the advertised prefix.",
      "ja": "PLENアドバタイズされたプレフィックスの長さ。"
    },
    {
      "indent": 3,
      "text": "Omitted The number of octets that have been omitted at the beginning of the advertised prefix and that should be taken from a preceding Update TLV with the flag with value 80 hexadecimal set.",
      "ja": "アドバタイズされたプレフィックスの先頭に省略されており、それは値80進数が設定されたフラグで前回更新TLVから取られるべきオクテットの数を省略する。"
    },
    {
      "indent": 3,
      "text": "Interval An upper bound, expressed in centiseconds, on the time after which the sending node will send a new update for this prefix. This MUST NOT be 0 and SHOULD NOT be less than 10. The receiving node will use this value to compute a hold time for this routing table entry. The value FFFF hexadecimal (infinity) expresses that this announcement will not be repeated unless a request is received (Section 3.8.2.3).",
      "ja": "インターバル・アン上限は、送信ノードがこのプレフィックスのための新しい更新を送信するまでの時間に、センチ秒で表されます。これは、0てはならず、受信ノードは、このルーティングテーブルエントリのホールド時間を計算するためにこの値を使用する10未満であるべきではありません。値FFFF 16進数（無限大）は、要求（セクション3.8.2.3）を受信しない限り、このアナウンスが繰り返されないことを表しています。"
    },
    {
      "indent": 3,
      "text": "Seqno The originator's sequence number for this update.",
      "ja": "このアップデートの創始者のシーケンス番号SEQNO。"
    },
    {
      "indent": 3,
      "text": "Metric The sender's metric for this route. The value FFFF hexadecimal (infinity) means that this is a route retraction.",
      "ja": "このルートのメトリック、送信者のメトリック。値FFFF 16進数（無限大）は、このルート後退であることを意味します。"
    },
    {
      "indent": 3,
      "text": "Prefix The prefix being advertised. This field's size is (Plen/8 - Omitted) rounded upwards.",
      "ja": "プレフィックスプレフィックスは公示されています。このフィールドのサイズは（PLEN / 8  - 中略）切り上げ。"
    },
    {
      "indent": 3,
      "text": "The Flags field is interpreted as follows:",
      "ja": "次のようにFlagsフィールドが解釈されます。"
    },
    {
      "indent": 3,
      "text": "o if the bit with value 80 hexadecimal is set, then this Update establishes a new default prefix for subsequent Update TLVs with a matching address family within the same packet;",
      "ja": "値は80進数を持つビットが設定されている場合、O、次いで、この更新は、同じパケット内の一致するアドレスファミリーとその後の更新のTLVの新しいデフォルトプレフィックスを確立します。"
    },
    {
      "indent": 3,
      "text": "o if the bit with value 40 hexadecimal is set, then the low-order 8 octets of the advertised prefix establish a new default router-id for this TLV and subsequent Update TLVs in the same packet.",
      "ja": "値は40進数を持つビットが設定されている場合、O、次いでアドバタイズプレフィックスの下位8つのオクテットが同じパケットでこのTLV及びその後の更新のTLVの新しいデフォルトルータIDを確立します。"
    },
    {
      "indent": 3,
      "text": "The prefix being advertised by an Update TLV is computed as follows:",
      "ja": "次のようにアップデートTLVにより公示されている接頭辞が計算されます。"
    },
    {
      "indent": 3,
      "text": "o the first Omitted octets of the prefix are taken from the previous Update TLV with flag 80 hexadecimal set and the same address family;",
      "ja": "Oプレフィックスの最初の省略オクテットはフラグ80進数のセットと同じアドレスファミリーと前回の更新TLVから取られます。"
    },
    {
      "indent": 3,
      "text": "o the next (Plen/8 - Omitted) (rounded upwards) octets are taken from the Prefix field;",
      "ja": "（切り上げ）オクテットPrefixフィールドから取られる - （省略PLEN / 8）次は、Oであり;"
    },
    {
      "indent": 3,
      "text": "o the remaining octets are set to 0.",
      "ja": "Oの残りのオクテットは0に設定されています。"
    },
    {
      "indent": 3,
      "text": "If the Metric field is finite, the router-id of the originating node for this announcement is taken from the low-order 8 octets of the prefix advertised by this Update if the bit with value 40 hexadecimal is set in the Flags field. Otherwise, it is taken either from the preceding Router-Id packet, or the preceding Update packet with flag 40 hexadecimal set, whichever comes last.",
      "ja": "メトリックフィールドが有限である場合、この発表のための発信元ノードのルータIDの値40進数を持つビットはフラグフィールドに設定されている場合、この更新によってアドバタイズプレフィックスの下位8つのオクテットから取られます。それ以外の場合は、最後に来る方先行ルータIDパケット、またはフラグ40進数が設定された前のアップデートパケット、のいずれかから取られます。"
    },
    {
      "indent": 3,
      "text": "The next-hop address for this update is taken from the last preceding Next Hop TLV with a matching address family in the same packet; if no such TLV exists, it is taken from the network-layer source address of this packet.",
      "ja": "この更新のネクストホップアドレスが同じパケットに一致するアドレスファミリーと最後の前のネクストホップTLVから取られます。そのようなTLVが存在しない場合は、このパケットのネットワーク層の送信元アドレスから取られます。"
    },
    {
      "indent": 3,
      "text": "If the metric field is FFFF hexadecimal, this TLV specifies a retraction. In that case, the current router-id and the Seqno are not used. AE MAY then be 0, in which case this Update retracts all of the routes previously advertised on this interface.",
      "ja": "メトリックフィールドがFFFF進数であれば、このTLVは撤回を指定します。その場合には、現在のルータIDとSEQNOは使用されません。 AEは、このアップデートは、以前は、このインターフェイス上でアドバタイズされたルートの全てを後退その場合に0とすることができます。"
    },
    {
      "indent": 3,
      "text": "Update TLVs with an unknown value for the AE field MUST be silently ignored.",
      "ja": "AEフィールドの未知の値で更新のTLVは黙って無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.10. Route Request",
      "section_title": true,
      "ja": "4.4.10. ルート要求"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 9   |    Length     |      AE       |     Plen      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Prefix...\n+-+-+-+-+-+-+-+-+-+-+-+-",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A Route Request TLV prompts the receiver to send an update for a given prefix, or a full routing table dump.",
      "ja": "ルート要求TLVは、与えられたプレフィックス、又は完全なルーティングテーブルダンプの更新を送信するために受信機を促します。"
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 9 to indicate a Route Request TLV.",
      "ja": "タイプは、ルート要求TLVを示すために9に設定します。"
    },
    {
      "indent": 3,
      "text": "Length The length of the body, exclusive of the Type and Length fields.",
      "ja": "タイプと長さフィールドの排他的な長さ本体の長さ、。"
    },
    {
      "indent": 3,
      "text": "AE The encoding of the Prefix field. The value 0 specifies that this is a request for a full routing table dump (a wildcard request).",
      "ja": "AEプレフィックス]フィールドのエンコーディング。値0は、これは完全なルーティングテーブルダンプ（ワイルドカードの要求）の要求であることを指定します。"
    },
    {
      "indent": 3,
      "text": "Plen The length of the requested prefix.",
      "ja": "PLEN要求されたプレフィックスの長さ。"
    },
    {
      "indent": 3,
      "text": "Prefix The prefix being requested. This field's size is Plen/8 rounded upwards.",
      "ja": "要求されている接頭辞。このフィールドのサイズは、PLEN / 8を切り上げています。"
    },
    {
      "indent": 3,
      "text": "A Request TLV prompts the receiving node to send an update message for the prefix specified by the AE, Plen, and Prefix fields, or a full dump of its routing table if AE is 0 (in which case Plen MUST be 0, and Prefix is of length 0). A Request may be sent to a unicast address if it is destined to a single node, or to a multicast address if the request is destined to all of the neighbours of the sending interface.",
      "ja": "AEは、0（この場合、PLENでなければなりません0であり、接頭辞である場合、要求TLVはAE、PLEN、及びプレフィックスフィールド、またはそのルーティングテーブルの完全なダンプで指定されたプレフィックスの更新メッセージを送信する受信ノードを促します長さ0の）。要求が送信インターフェースの近傍の全てを宛先としている場合は、それが単一のノードに、またはマルチキャストアドレスを宛先とする場合、要求は、ユニキャストアドレスに送信することができます。"
    },
    {
      "indent": 0,
      "text": "4.4.11. Seqno Request",
      "section_title": true,
      "ja": "4.4.11.  SEQNOリクエスト"
    },
    {
      "indent": 3,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 10  |    Length     |      AE       |    Plen       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Seqno             |  Hop Count    |   Reserved    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                          Router-Id                            +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Prefix...\n+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A Seqno Request TLV prompts the receiver to send an Update for a given prefix with a given sequence number, or to forward the request further if it cannot be satisfied locally.",
      "ja": "SEQNO要求TLVは、与えられたシーケンス番号で指定された接頭辞のために更新を送信する、またはそれがローカルに満たすことができない場合に、さらに要求を転送するために受信機を促します。"
    },
    {
      "indent": 3,
      "text": "Fields :",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 10 to indicate a Seqno Request message.",
      "ja": "タイプは、SEQNO要求メッセージを示すために10に設定します。"
    },
    {
      "indent": 3,
      "text": "Length The length of the body, exclusive of the Type and Length fields.",
      "ja": "タイプと長さフィールドの排他的な長さ本体の長さ、。"
    },
    {
      "indent": 3,
      "text": "AE The encoding of the Prefix field. This MUST NOT be 0.",
      "ja": "AEプレフィックス]フィールドのエンコーディング。これは、0にすることはできません。"
    },
    {
      "indent": 3,
      "text": "Plen The length of the requested prefix.",
      "ja": "PLEN要求されたプレフィックスの長さ。"
    },
    {
      "indent": 3,
      "text": "Seqno The sequence number that is being requested.",
      "ja": "要求されているシーケンス番号をSEQNO。"
    },
    {
      "indent": 3,
      "text": "Hop Count The maximum number of times that this TLV may be forwarded, plus 1. This MUST NOT be 0.",
      "ja": "ホップは、このTLVが転送できる最大回数をカウントし、プラス1。これが0であってはなりません。"
    },
    {
      "indent": 3,
      "text": "Prefix The prefix being requested. This field's size is Plen/8 rounded upwards.",
      "ja": "要求されている接頭辞。このフィールドのサイズは、PLEN / 8を切り上げています。"
    },
    {
      "indent": 3,
      "text": "A Seqno Request TLV prompts the receiving node to send an Update for the prefix specified by the AE, Plen, and Prefix fields, with either a router-id different from what is specified by the Router-Id field, or a Seqno no less than what is specified by the Seqno field. If this request cannot be satisfied locally, then it is forwarded according to the rules set out in Section 3.8.1.2.",
      "ja": "SEQNO要求TLVは、よりルータIDルータIDフィールドによって指定されたものとは異なる、またはSEQNOない以下のいずれかを用いて、AE、PLEN、及びプレフィックスフィールドによって指定されたプレフィックスの更新を送信する受信ノードを促します何SEQNOフィールドで指定されています。この要求がローカルで満たすことができない場合、それは、セクション3.8.1.2に定めるルールに従って転送されます。"
    },
    {
      "indent": 3,
      "text": "While a Seqno Request MAY be sent to a multicast address, it MUST NOT be forwarded to a multicast address and MUST NOT be forwarded to more than one neighbour. A request MUST NOT be forwarded if its Hop Count field is 1.",
      "ja": "SEQNOリクエストがマルチキャストアドレスに送信することができるが、それはマルチキャストアドレスに転送してはならないし、複数のネイバーに転送されてはなりません。そのホップカウントフィールドが1であれば要求が転送されてはなりません。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has registered the UDP port number 6697, called \"babel\", for use by the Babel protocol.",
      "ja": "IANAはバベルのプロトコルで使用するために、「バベル」と呼ばれ、UDPポート番号6697が登録されています。"
    },
    {
      "indent": 3,
      "text": "IANA has registered the IPv6 multicast group ff02:0:0:0:0:0:1:6 and the IPv4 multicast group 224.0.0.111 for use by the Babel protocol.",
      "ja": "0：0：0：0：0：1：6とバベルプロトコルで使用するためのIPv4マルチキャストグループ224.0.0.111 IANAは、IPv6マルチキャストグループFF02が登録されています。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "As defined in this document, Babel is a completely insecure protocol. Any attacker can attract data traffic by advertising routes with a low metric. This particular issue can be solved either by lower-layer security mechanisms (e.g., IPsec or link-layer security), or by appending a cryptographic key to Babel packets; the provision of ignoring any data contained within a Babel packet beyond the body length declared by the header is designed for just such a purpose.",
      "ja": "この文書で定義されているように、バベルは完全に安全ではないプロトコルです。任意の攻撃者は、低いメトリックを持つ広告経路でデータトラフィックを引き付けることができます。この特定の問題は、下位層のセキュリティメカニズム（例えば、IPSecまたはリンク・レイヤ・セキュリティ）によって、又はバベルパケットに暗号鍵を付加することによってのいずれかで解決することができます。ヘッダで宣言さ本体長さを超えてバベルパケット内に含まれる任意のデータを無視するの提供はまさにこのような目的のために設計されています。"
    },
    {
      "indent": 3,
      "text": "The information that a Babel node announces to the whole routing domain is often sufficient to determine a mobile node's physical location with reasonable precision. The privacy issues that this causes can be mitigated somewhat by using randomly chosen router-ids and randomly chosen IP addresses, and changing them periodically.",
      "ja": "バベルノードが全体のルーティングドメインに発表した情報は、多くの場合、合理的な精度で移動ノードの物理的な位置を決定するのに十分です。これは、引き起こすことがプライバシーの問題は、ランダムに選択されたルータIDとランダムに選ばれたIPアドレスを使用して、定期的に変更することで多少緩和することができます。"
    },
    {
      "indent": 3,
      "text": "When carried over IPv6, Babel packets are ignored unless they are sent from a link-local IPv6 address; since routers don't forward link-local IPv6 packets, this provides protection against spoofed Babel packets being sent from the global Internet. No such natural protection exists when Babel packets are carried over IPv4.",
      "ja": "IPv6の上で搬送される場合には、それらがリンクローカルIPv6アドレスから送信された場合を除き、バベルパケットは無視されます。ルータはリンクローカルIPv6パケットを転送しないので、これはグローバルなインターネットから送信される偽装されたバベルパケットに対する保護を提供します。バベルパケットがIPv4の上で実行されたときにそのような自然の保護が存在しません。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[ADDRARCH] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 4291, February 2006.",
      "ja": "[ADDRARCH] HindenとR.とS.デアリング、 \"IPバージョン6アドレッシング体系\"、RFC 4291、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[DSDV] Perkins, C. and P. Bhagwat, \"Highly Dynamic Destination-Sequenced Distance-Vector Routing (DSDV) for Mobile Computers\", ACM SIGCOMM'94 Conference on Communications Architectures, Protocols and Applications 234-244, 1994.",
      "ja": "[DSDV]パーキンス、C.およびP. Bhagwat、「モバイルコンピュータのための非常にダイナミックなデスティネーション・シーケンス・ディスタンスベクタルーティング（DSDV）」、コミュニケーションアーキテクチャ、プロトコルとアプリケーション234-244上のACM SIGCOMM'94会議、1994。"
    },
    {
      "indent": 3,
      "text": "[DUAL] Garcia Luna Aceves, J., \"Loop-Free Routing Using Diffusing Computations\", IEEE/ACM Transactions on Networking 1:1, February 1993.",
      "ja": "1993年2月、1：ガルシアルナACEVES、J.、 \"拡散性の計算を使用してループフリールーティング\"、IEEE / ACM取引1をネットワーク上の[DUAL]。"
    },
    {
      "indent": 3,
      "text": "[EIGRP] Albrightson, B., Garcia Luna Aceves, J., and J. Boyle, \"EIGRP -- a Fast Routing Protocol Based on Distance Vectors\", Proc. Interop 94, 1994.",
      "ja": "[EIGRP] Albrightson、B.、ガルシアルナACEVES、J.、およびJ.ボイル、 \"EIGRP  - 距離ベクトルに基づく高速ルーティングプロトコル\"、PROC。インターロップ94、1994。"
    },
    {
      "indent": 3,
      "text": "[ETX] De Couto, D., Aguayo, D., Bicket, J., and R. Morris, \"A high-throughput path metric for multi-hop wireless networks\", Proc. MobiCom 2003, 2003.",
      "ja": "[ETX]デクート、D.、Aguayo、D.、Bicket、J.、およびR.モリス、 \"マルチホップ無線ネットワークのための高スループットのパスメトリック\"、PROC。モビコム2003、2003。"
    },
    {
      "indent": 3,
      "text": "[IS-IS] \"Information technology -- Telecommunications and information exchange between systems -- Intermediate System to Intermediate System intra-domain routeing information exchange protocol for use in conjunction with the protocol for providing the connectionless-mode network service (ISO 8473)\", ISO/IEC 10589:2002.",
      "ja": "「 - 電気通信及びシステム間情報交換 - 中間システム中間システムのドメイン内に（ISO 8473）接続モード・ネットワーク・サービスを提供するためのプロトコルと組み合わせて使用​​するための情報交換プロトコルをrouteingする情報技術」[-ISはIS] 、ISO / IEC 10589：2002。"
    },
    {
      "indent": 3,
      "text": "[JITTER] Floyd, S. and V. Jacobson, \"The synchronization of periodic routing messages\", IEEE/ACM Transactions on Networking 2, 2, 122-136, April 1994.",
      "ja": "【JITTER]フロイド、S.およびV. Jacobsonの \"定期的なルーティングメッセージの同期\"、ネットワーク2、2、122から136まで、1994年4月にIEEE / ACMトランザクション。"
    },
    {
      "indent": 3,
      "text": "[OSPF] Moy, J., \"OSPF Version 2\", STD 54, RFC 2328, April 1998.",
      "ja": "[OSPF]モイ、J.、 \"OSPFバージョン2\"、STD 54、RFC 2328、1998年4月。"
    },
    {
      "indent": 3,
      "text": "[PACKETBB] Clausen, T., Dearlove, C., Dean, J., and C. Adjih, \"Generalized Mobile Ad Hoc Network (MANET) Packet/Message Format\", RFC 5444, February 2009.",
      "ja": "【PACKETBB] Clausenの、T.、Dearlove、C.、ディーン、J.、およびC. Adjih、 \"一般モバイルアドホックネットワーク（MANET）パケット/メッセージフォーマット\"、RFC 5444、2009年2月。"
    },
    {
      "indent": 3,
      "text": "[RIP] Malkin, G., \"RIP Version 2\", STD 56, RFC 2453, November 1998.",
      "ja": "[RIP]マルキン、G.、 \"RIPバージョン2\"、STD 56、RFC 2453、1998年11月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Cost and Metric Computation",
      "ja": "付録A.コストとメトリック計算"
    },
    {
      "indent": 3,
      "text": "The strategy for computing link costs and route metrics is a local matter; Babel itself only requires that it comply with the conditions given in Sections 3.4.3 and 3.5.2. Different nodes MAY use different strategies in a single network and MAY use different strategies on different interface types. This section gives a few examples of such strategies.",
      "ja": "リンクコストおよびルートメトリックを計算するための戦略は、ローカルの問題です。バベル自体は、それはセクション3.4.3と3.5.2で与えられた条件に従うことが必要です。別のノードが単一のネットワークで異なる戦略を使用するかもしれなくて、別のインターフェイスタイプに異なる戦略を使用するかもしれません。このセクションでは、このような戦略のいくつかの例を示します。"
    },
    {
      "indent": 3,
      "text": "The sample implementation of Babel maintains statistics about the last 16 received Hello TLVs (Appendix A.1), computes costs by using the 2-out-of-3 strategy (Appendix A.2.1) on wired links, and ETX [ETX] on wireless links. It uses an additive algebra for metric computation (Appendix A.3.1).",
      "ja": "バベルのサンプル実装は、最後の16の上にハローのTLV（付録A.1）は、有線リンク上の2アウトオブ3戦略（付録A.2.1）を用いてコストを計算し、受信し、及びETX [ETX]に関する統計を維持します無線リンク。これは、メトリック計算（付録A.3.1）のための添加剤代数を使用しています。"
    },
    {
      "indent": 0,
      "text": "A.1. Maintaining Hello History",
      "ja": "A.1。こんにちは歴史を維持します"
    },
    {
      "indent": 3,
      "text": "For each neighbour, the sample implementation of Babel maintains a Hello history and an expected sequence number. The Hello history is a vector of 16 bits, where a 1 value represents a received Hello, and a 0 value a missed Hello. The expected sequence number, written ne, is the sequence number that is expected to be carried by the next received hello from this neighbour.",
      "ja": "各隣人のために、バベルのサンプル実装は、ハロー歴史と予想されるシーケンス番号を維持します。ハロー履歴は1つの値がハロー受信表す16ビットのベクトルであり、0値はハロー逃しました。期待シーケンス番号、記述されたNEは、このネイバーからの次の受信したハローによって担持されることが期待されるシーケンス番号です。"
    },
    {
      "indent": 3,
      "text": "Whenever it receives a Hello packet from a neighbour, a node compares the received sequence number nr with its expected sequence number ne. Depending on the outcome of this comparison, one of the following actions is taken:",
      "ja": "それは隣人からHelloパケットを受信するたびに、ノードは、その期待シーケンス番号NEとNR受信したシーケンス番号を比較します。この比較の結果に応じて、次のいずれかのアクションが取られます。"
    },
    {
      "indent": 3,
      "text": "o if the two differ by more than 16 (modulo 2^16), then the sending node has probably rebooted and lost its sequence number; the associated neighbour table entry is flushed;",
      "ja": "O 2が16以上（モジュロ2 ^ 16）だけ異なる場合、送信ノードは、おそらく再起動し、そのシーケンス番号を失いました。関連するネイバーテーブルエントリがフラッシュされます。"
    },
    {
      "indent": 3,
      "text": "o otherwise, if the received nr is smaller (modulo 2^16) than the expected sequence number ne, then the sending node has increased its Hello interval without our noticing; the receiving node removes the last (ne - nr) entries from this neighbour's Hello history (we \"undo history\");",
      "ja": "受信されたNrが期待されるシーケンス数NEよりも小さく（モジュロ2 ^ 16）である場合、Oそうでなければ、次に、送信ノードは、我々の気付かず、そのハローインターバルを増加しています。受信ノードは、最後の（NE  -  NR）を削除し、この隣人のHello履歴からエントリー（私たちは「歴史を元に戻す」を参照）。"
    },
    {
      "indent": 3,
      "text": "o otherwise, if nr is larger (modulo 2^16) than ne, then the sending node has decreased its Hello interval, and some Hellos were lost; the receiving node adds (nr - ne) 0 bits to the Hello history (we \"fast-forward\").",
      "ja": "NRは、（モジュロ2 ^ 16）NEよりも大きい場合、Oそうでなければ、次に、送信ノードは、ハローインターバルを減少している、といくつかのハローズは失われました。こんにちは履歴に0ビット（私たちは、「早送り」） - 受信ノードは、（NE NR）を追加します。"
    },
    {
      "indent": 3,
      "text": "The receiving node then appends a 1 bit to the neighbour's Hello history, resets the neighbour's Hello timer, and sets ne to (nr + 1). It then resets the neighbour's Hello timer to 1.5 times the value advertised in the received Hello (the extra margin allows for the delay due to jitter).",
      "ja": "受信ノードは、その後、隣人のHello履歴に1ビットを付加し、隣人のHelloタイマーをリセットし、（NR + 1）にNEを設定します。これは、受信したハロー（余分なマージンは、ジッタによる遅延することができます）でアドバタイズ1.5倍の値に隣人のHelloタイマーをリセットします。"
    },
    {
      "indent": 3,
      "text": "Whenever the Hello timer associated to a neighbour expires, the local node adds a 0 bit to this neighbour's Hello history, and increments the expected Hello number. If the Hello history is empty (it contains 0 bits only), the neighbour entry is flushed; otherwise, it resets the neighbour's Hello timer to the value advertised in the last Hello received from this neighbour (no extra margin is necessary in this case).",
      "ja": "隣人に関連したHelloタイマーの期限が切れるたびに、ローカル・ノードは、この隣人のHello歴史に0ビットを付加し、期待こんにちは番号をインクリメントします。こんにちは履歴が空の場合、ネイバーエントリがフラッシュされる（これは、0ビットのみが含まれています）。それ以外の場合は、最後のHelloでアドバタイズ値に隣人のHelloタイマーをリセットします（余分なマージンが、この場合には必要ありません）このネイバーから受信しました。"
    },
    {
      "indent": 0,
      "text": "A.2. Cost Computation",
      "ja": "A.2。コスト計算"
    },
    {
      "indent": 0,
      "text": "A.2.1. k-out-of-j",
      "ja": "A.2.1。 K-アウト・オブ・J"
    },
    {
      "indent": 3,
      "text": "K-out-of-j link sensing is suitable for wired links that are either up, in which case they only occasionally drop a packet, or down, in which case they drop all packets.",
      "ja": "K-外のJリンクセンシングは、彼らがすべてのパケットをドロップした場合には、彼らはたまにしかダウンパケットをドロップするか、その場合には、いずれかアップしている有線リンク、に適しています。"
    },
    {
      "indent": 3,
      "text": "The k-out-of-j strategy is parameterised by two small integers k and j, such that 0 < k <= j, and the nominal link cost, a constant K >= 1. A node keeps a history of the last j hellos; if k or more of those have been correctly received, the link is assumed to be up, and the rxcost is set to K; otherwise, the link is assumed to be down, and the rxcost is set to infinity.",
      "ja": "K-アウトJ戦略は二つの小さな整数でパラメータ化されたkおよびjを、例えば0 <K <= jのこと、公称リンクコスト、定数K> = 1のノードが最後のJの履歴を保持helloパケット;それらのK以上が正しく受信されている場合、リンクがアップであると仮定され、そしてrxcostをKに設定されています。そうでない場合、リンクはダウンであると仮定され、そしてrxcostは無限大に設定されています。"
    },
    {
      "indent": 3,
      "text": "The cost of such a link is defined as",
      "ja": "そのようなリンクのコストは、以下のように定義されます"
    },
    {
      "indent": 3,
      "text": "o cost = FFFF hexadecimal if rxcost = FFFF hexadecimal;",
      "ja": "Oコスト= FFFF進rxcost = FFFF進数であれば、"
    },
    {
      "indent": 3,
      "text": "o cost = txcost otherwise.",
      "ja": "Oコスト= txcostそう。"
    },
    {
      "indent": 0,
      "text": "A.2.2. ETX",
      "ja": "A.2.2。 ETX"
    },
    {
      "indent": 3,
      "text": "The Estimated Transmission Cost metric [ETX] estimates the number of times that a unicast frame will be retransmitted by the IEEE 802.11 MAC, assuming infinite persistence.",
      "ja": "推定された伝送コストメトリック[ETX]はユニキャストフレームが無限の持続性を仮定すると、IEEE 802.11 MACによって再送信される回数を推定します。"
    },
    {
      "indent": 3,
      "text": "A node uses a neighbour's Hello history to compute an estimate, written beta, of the probability that a Hello TLV is successfully received. The rxcost is defined as 256/beta.",
      "ja": "ノードは、こんにちはTLVが正常に受信される確率の推定値、書かれたベータ版を、計算するために隣人のHello履歴を使用しています。 rxcostは256 /ベータとして定義されます。"
    },
    {
      "indent": 3,
      "text": "Let alpha be MIN(1, 256/txcost), an estimate of the probability of successfully sending a Hello TLV. The cost is then computed by",
      "ja": "アルファは、MIN（1、256 / txcost）、首尾こんにちはTLVを送信する確率の推定値とします。費用は、それまでに計算されます"
    },
    {
      "indent": 6,
      "text": "cost = 256/(alpha * beta)",
      "ja": "コスト= 256 /（アルファ*ベータ版）"
    },
    {
      "indent": 3,
      "text": "or, equivalently,",
      "ja": "または、同等に、"
    },
    {
      "indent": 6,
      "text": "cost = (MAX(txcost, 256) * rxcost) / 256.",
      "ja": "コスト=（MAX（txcost、256）* rxcost）/ 256。"
    },
    {
      "indent": 0,
      "text": "A.3. Metric Computation",
      "ja": "A.3。メトリック計算"
    },
    {
      "indent": 0,
      "text": "A.3.1. Additive Metrics",
      "ja": "A.3.1。添加物メトリクス"
    },
    {
      "indent": 3,
      "text": "The simplest approach for obtaining a monotonic, isotonic metric is to define the metric of a route as the sum of the costs of the component links. More formally, if a neighbour advertises a route with metric m over a link with cost c, then the resulting route has metric M(c, m) = c + m.",
      "ja": "単調、等張性メトリックを取得するための最も簡単な方法は、コンポーネントリンクのコストの和としてルートのメトリックを定義することです。ネイバーがコストcとリンク上メトリックMのルートをアドバタイズした場合、より正式には、その結果の経路メトリックM（C、M）= C + Mを有します。"
    },
    {
      "indent": 3,
      "text": "A multiplicative metric can be converted to an additive one by taking the logarithm (in some suitable base) of the link costs.",
      "ja": "乗法メトリックは、リンクコストの（いくつかの適切な塩基で）対数を取ることによって添加いずれかに変換することができます。"
    },
    {
      "indent": 0,
      "text": "A.3.2. External Sources of Willingness",
      "ja": "A.3.2。意欲の外部ソース"
    },
    {
      "indent": 3,
      "text": "A node may want to vary its willingness to forward packets by taking into account information that is external to the Babel protocol, such as the monetary cost of a link, the node's battery status, CPU load, etc. This can be done by adding to every route's metric a value k that depends on the external data. For example, if a battery-powered node receives an update with metric m over a link with cost c, it might compute a metric M(c, m) = k + c + m, where k depends on the battery status.",
      "ja": "ノードは、これはに加えることによって行うことができるなど、リンクの金銭的コスト、ノードのバッテリー状態、CPU負荷、など、アカウントにバベルプロトコルの外部にある情報を取ることによって、パケットを転送する意向を変更することもできます外部データに依存して、すべてのルートのメトリック値k。電池式ノードは、コストCとリンク上メトリックmの更新を受信した場合、例えば、それは、kはバッテリーの状態に依存するメトリックM（C、M）= K + C + Mを計算するかもしれません。"
    },
    {
      "indent": 3,
      "text": "In order to preserve strict monotonicity (Section 3.5.2), the value k must be greater than -c.",
      "ja": "厳密な単調性（3.5.2）を保持するために、kの値は、-cよりも大きくなければなりません。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Constants",
      "ja": "付録B.定数"
    },
    {
      "indent": 3,
      "text": "The choice of time constants is a trade-off between fast detection of mobility events and protocol overhead. Two implementations of Babel with different time constants will interoperate, although the resulting convergence time will most likely be dictated by the slowest of the two implementations.",
      "ja": "時定数の選択は、モビリティイベントやプロトコルのオーバーヘッドの高速検出とのトレードオフです。結果の収束時間が最も可能性の高い2つの実装の最も遅いによって決定されるであろうが、異なる時定数を持つバベルの2つの実装は、相互運用します。"
    },
    {
      "indent": 3,
      "text": "Experience with the sample implementation of Babel indicates that the Hello interval is the most important time constant: a mobility event is detected within 1.5 to 3 Hello intervals. Due to Babel's reliance on triggered updates and explicit requests, the Update interval only has an effect on the time it takes for accurate metrics to be propagated after variations in link costs too small to trigger an unscheduled update.",
      "ja": "バベルのサンプル実装での経験は、こんにちは間隔が最も重要な時定数であることを示している：モビリティイベントは、1.5〜3のHello間隔内で検出されました。トリガ更新と明示的な要求にバベルの依存度に、更新間隔は、正確な測定基準は、予定外の更新をトリガするには小さすぎるリンクコストの変化の後に伝播するのにかかる時間に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "At the time of writing, the sample implementation of Babel uses the following default values:",
      "ja": "執筆時点では、バベルのサンプル実装は、次のデフォルト値を使用しています："
    },
    {
      "indent": 6,
      "text": "Hello Interval: 4 seconds on wireless links, 20 seconds on wired links.",
      "ja": "こんにちは間隔：有線リンク上の無線リンク上の4秒、20秒。"
    },
    {
      "indent": 6,
      "text": "IHU Interval: the advertised IHU interval is always 3 times the Hello interval. IHUs are actually sent with each Hello on lossy links (as determined from the Hello history), but only with every third Hello on lossless links.",
      "ja": "IHU間隔：宣伝IHU間隔が常に3回のHello間隔です。 IHUsは実際にだけ、すべての第三のHelloとロスレスリンク上、損失の多いリンク上の各こんにちは（ハロー履歴から決定される）で送信されます。"
    },
    {
      "indent": 6,
      "text": "Update Interval: 4 times the Hello interval.",
      "ja": "更新間隔：helloインターバルの4倍。"
    },
    {
      "indent": 6,
      "text": "IHU Hold Time: 3.5 times the advertised IHU interval.",
      "ja": "3.5倍の宣伝IHU間隔：IHUは、ホールド時間。"
    },
    {
      "indent": 6,
      "text": "Route Expiry Time: 3.5 times the advertised update interval.",
      "ja": "ルート有効期限：3.5倍アドバタイズされた更新間隔。"
    },
    {
      "indent": 6,
      "text": "Source GC time: 3 minutes.",
      "ja": "ソースGC時間：3分。"
    },
    {
      "indent": 3,
      "text": "The amount of jitter applied to a packet depends on whether it contains any urgent TLVs or not. Urgent triggered updates and urgent requests are delayed by no more than 200 ms; other TLVs are delayed by no more than one-half the Hello interval.",
      "ja": "パケットに適用されるジッタの量は、それがどんな緊急のTLVが含まれているかどうかに依存します。緊急の更新をトリガし、緊急の要求がこれ以上200未満ミリ秒遅れで表示されています。他のTLVはありません半分以上のHello間隔遅れで表示されています。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Simplified Implementations",
      "ja": "付録C.簡体実装"
    },
    {
      "indent": 3,
      "text": "Babel is a fairly economic protocol. Route updates take between 12 and 40 octets per destination, depending on how successful compression is; in a double-stack mesh network, an average of less than 24 octets is typical. The route table occupies about 35 octets per IPv6 entry. To put these values into perspective, a single full-size Ethernet frame can carry some 65 route updates, and a megabyte of memory can contain a 20000-entry routing table and the associated source table.",
      "ja": "バベルはかなり経済的プロトコルです。ルートの更新が成功した圧縮方法に応じて、目的地ごとに12〜40オクテットを取ります。ダブルスタックメッシュネットワークでは、24未満のオクテットの平均が典型的です。ルートテーブルは、IPv6エントリあたり約35オクテットを占めています。パースペクティブにこれらの値を入れて、単一のフルサイズのイーサネットフレームは、いくつかの65ルートアップデートを運ぶことができ、そしてメモリのメガバイトは20000エントリールーティングテーブルと関連付けられたソーステーブルを含むことができます。"
    },
    {
      "indent": 3,
      "text": "Babel is also a reasonably simple protocol. The sample implementation consists of less than 8000 lines of C code, and it compiles to less than 60 kB of text on a 32-bit CISC architecture.",
      "ja": "バベルはまた、合理的に単純なプロトコルです。サンプルの実装は、Cコード未満の8000行で構成され、それは32ビットのCISCアーキテクチャにテキスト未満の60キロバイトにコンパイル。"
    },
    {
      "indent": 3,
      "text": "Nonetheless, in some very constrained environments, such as PDAs, microwave ovens, or abacuses, it may be desirable to have subset implementations of the protocol.",
      "ja": "それにもかかわらず、いくつかの非常に制約された環境では、そのようなPDAなど、電子レンジ、又はそろばんのように、プロトコルのサブセットの実装を有することが望ましいです。"
    },
    {
      "indent": 3,
      "text": "A parasitic implementation is one that uses a Babel network for routing its packets but does not announce any of the routes that it has learnt from its neighbours. (This is slightly more than a passive implementation, which doesn't even announce routes to itself.) It may either maintain a full routing table or simply select a gateway amongst any one of its neighbours that announces a default route. Since a parasitic implementation never forwards packets, it cannot possibly participate in a routing loop; hence, it need not evaluate the feasibility condition and need not maintain a source table.",
      "ja": "寄生実装は、そのパケットをルーティングするためのバベルのネットワークを使用していますが、それはそのネイバーから学習した経路のいずれかをアナウンスしないものです。 （これもそれ自体へのルートをアナウンスしない受動的実装、よりわずかである。）これは、いずれかの完全なルーティングテーブルを維持するか、または単にデフォルトルートを発表その近傍のいずれかの間でゲートウェイを選択してもよいです。寄生実装がパケットを転送することはないので、それはおそらくルーティングループに参加することができません。したがって、それは実現可能性の条件を評価する必要はないとソーステーブルを維持する必要はありません。"
    },
    {
      "indent": 3,
      "text": "A parasitic implementation MUST answer acknowledgement requests and MUST participate in the Hello/IHU protocol. Finally, it MUST be able to reply to seqno requests for routes that it announces and SHOULD be able to reply to route requests.",
      "ja": "寄生実装が承認要求に応答しなければならなくて、こんにちは/ IHUプロトコルに参加しなければなりません。最後に、発表したルートのSEQNO要求に答えることができなければならないし、ルート要求に応答することができるべきです。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Software Availability",
      "ja": "付録D.ソフトウェアの可用性"
    },
    {
      "indent": 3,
      "text": "The sample implementation of Babel is available from <http://www.pps.jussieu.fr/~jch/software/babel/>.",
      "ja": "バベルのサンプル実装は、<http://www.pps.jussieu.fr/~jch/software/babel/>から入手可能です。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Juliusz Chroboczek PPS, University of Paris 7 Case 7014 75205 Paris Cedex 13, France",
      "ja": "Juliusz Chroboczek PPS、パリ7大学の事例7014 75205パリセデックス13、フランス"
    },
    {
      "indent": 3,
      "text": "EMail: jch@pps.jussieu.fr",
      "ja": "メールアドレス：jch@pps.jussieu.fr"
    }
  ]
}