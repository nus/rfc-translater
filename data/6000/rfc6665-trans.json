{
  "title": {
    "text": "RFC 6665 - SIP-Specific Event Notification",
    "ja": "RFC 6665 - SIP固有のイベント通知"
  },
  "number": 6665,
  "created_at": "2019-10-28 23:24:41.467449+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        A.B. Roach\nRequest for Comments: 6665                                       Tekelec\nObsoletes: 3265                                                July 2012\nUpdates: 3261, 4660\nCategory: Standards Track\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 20,
      "text": "SIP-Specific Event Notification",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes an extension to the Session Initiation Protocol (SIP) defined by RFC 3261. The purpose of this extension is to provide an extensible framework by which SIP nodes can request notification from remote nodes indicating that certain events have occurred.",
      "ja": "この文書は、この拡張の目的は、SIPノードは、特定のイベントが発生したことを示すリモートノードからの通知を要求することが可能な拡張可能なフレームワークを提供することであるRFC 3261によって定義されたセッション開始プロトコル（SIP）の拡張を記述しています。"
    },
    {
      "indent": 3,
      "text": "Note that the event notification mechanisms defined herein are NOT intended to be a general-purpose infrastructure for all classes of event subscription and notification.",
      "ja": "本明細書に定義されたイベント通知メカニズムは、イベントサブスクリプションと通知のすべてのクラスの汎用的なインフラであることを意図していないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "This document represents a backwards-compatible improvement on the original mechanism described by RFC 3265, taking into account several years of implementation experience. Accordingly, this document obsoletes RFC 3265. This document also updates RFC 4660 slightly to accommodate some small changes to the mechanism that were discussed in that document.",
      "ja": "この文書では、考慮に実装経験の数年を取って、RFC 3265で説明した元のメカニズムの後方互換性の改善を表しています。したがって、この文書はRFC 3265を廃止する。このドキュメントでは、RFC 4660をわずかにその文書で説明したメカニズムにはいくつかの小さな変更に対応するために更新されます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6665.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6665で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2012 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  5\n  1.1.  Overview of Operation  . . . . . . . . . . . . . . . . . .  5\n  1.2.  Documentation Conventions  . . . . . . . . . . . . . . . .  6\n2.  Definitions  . . . . . . . . . . . . . . . . . . . . . . . . .  6\n3.  SIP Methods for Event Notification . . . . . . . . . . . . . .  7\n  3.1.  SUBSCRIBE  . . . . . . . . . . . . . . . . . . . . . . . .  7\n    3.1.1.  Subscription Duration  . . . . . . . . . . . . . . . .  7\n    3.1.2.  Identification of Subscribed Events and Event\n            Classes  . . . . . . . . . . . . . . . . . . . . . . .  8\n    3.1.3.  Additional SUBSCRIBE Header Field Values . . . . . . .  9\n  3.2.  NOTIFY . . . . . . . . . . . . . . . . . . . . . . . . . .  9\n    3.2.1.  Identification of Reported Events, Event Classes,\n            and Current State  . . . . . . . . . . . . . . . . . .  9\n4.  Node Behavior  . . . . . . . . . . . . . . . . . . . . . . . . 10\n  4.1.  Subscriber Behavior  . . . . . . . . . . . . . . . . . . . 10\n    4.1.1.  Detecting Support for SIP Events . . . . . . . . . . . 10\n    4.1.2.  Creating and Maintaining Subscriptions . . . . . . . . 10\n    4.1.3.  Receiving and Processing State Information . . . . . . 14\n    4.1.4.  Forking of SUBSCRIBE Requests  . . . . . . . . . . . . 16\n  4.2.  Notifier Behavior  . . . . . . . . . . . . . . . . . . . . 17\n    4.2.1.  Subscription Establishment and Maintenance . . . . . . 17\n    4.2.2.  Sending State Information to Subscribers . . . . . . . 20\n    4.2.3.  PSTN/Internet Interworking (PINT) Compatibility  . . . 23\n  4.3.  Proxy Behavior . . . . . . . . . . . . . . . . . . . . . . 23\n  4.4.  Common Behavior  . . . . . . . . . . . . . . . . . . . . . 24\n    4.4.1.  Dialog Creation and Termination  . . . . . . . . . . . 24\n    4.4.2.  Notifier Migration . . . . . . . . . . . . . . . . . . 24\n    4.4.3.  Polling Resource State . . . . . . . . . . . . . . . . 25\n    4.4.4.  \"Allow-Events\" Header Field Usage  . . . . . . . . . . 26\n  4.5.  Targeting Subscriptions at Devices . . . . . . . . . . . . 26\n    4.5.1.  Using GRUUs to Route to Devices  . . . . . . . . . . . 27",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    4.5.2.  Sharing Dialogs  . . . . . . . . . . . . . . . . . . . 27\n  4.6.  CANCEL Requests for SUBSCRIBE and NOTIFY Transactions  . . 29\n5.  Event Packages . . . . . . . . . . . . . . . . . . . . . . . . 29\n  5.1.  Appropriateness of Usage . . . . . . . . . . . . . . . . . 29\n  5.2.  Event Template-Packages  . . . . . . . . . . . . . . . . . 30\n  5.3.  Amount of State to Be Conveyed . . . . . . . . . . . . . . 31\n    5.3.1.  Complete State Information . . . . . . . . . . . . . . 31\n    5.3.2.  State Deltas . . . . . . . . . . . . . . . . . . . . . 32\n  5.4.  Event Package Responsibilities . . . . . . . . . . . . . . 32\n    5.4.1.  Event Package Name . . . . . . . . . . . . . . . . . . 33\n    5.4.2.  Event Package Parameters . . . . . . . . . . . . . . . 33\n    5.4.3.  SUBSCRIBE Request Bodies . . . . . . . . . . . . . . . 33\n    5.4.4.  Subscription Duration  . . . . . . . . . . . . . . . . 33\n    5.4.5.  NOTIFY Request Bodies  . . . . . . . . . . . . . . . . 34\n    5.4.6.  Notifier Processing of SUBSCRIBE Requests  . . . . . . 34\n    5.4.7.  Notifier generation of NOTIFY requests . . . . . . . . 34\n    5.4.8.  Subscriber Processing of NOTIFY Requests . . . . . . . 34\n    5.4.9.  Handling of Forked Requests  . . . . . . . . . . . . . 34\n    5.4.10. Rate of Notifications  . . . . . . . . . . . . . . . . 35\n    5.4.11. State Aggregation  . . . . . . . . . . . . . . . . . . 35\n    5.4.12. Examples . . . . . . . . . . . . . . . . . . . . . . . 36\n    5.4.13. Use of URIs to Retrieve State  . . . . . . . . . . . . 36\n6.  Security Considerations  . . . . . . . . . . . . . . . . . . . 36\n  6.1.  Access Control . . . . . . . . . . . . . . . . . . . . . . 36\n  6.2.  Notifier Privacy Mechanism . . . . . . . . . . . . . . . . 36\n  6.3.  Denial-of-Service Attacks  . . . . . . . . . . . . . . . . 37\n  6.4.  Replay Attacks . . . . . . . . . . . . . . . . . . . . . . 37\n  6.5.  Man-in-the-Middle Attacks  . . . . . . . . . . . . . . . . 37\n  6.6.  Confidentiality  . . . . . . . . . . . . . . . . . . . . . 38\n7.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 38\n  7.1.  Event Packages . . . . . . . . . . . . . . . . . . . . . . 38\n    7.1.1.  Registration Information . . . . . . . . . . . . . . . 39\n    7.1.2.  Registration Template  . . . . . . . . . . . . . . . . 40\n  7.2.  Reason Codes . . . . . . . . . . . . . . . . . . . . . . . 40\n  7.3.  Header Field Names . . . . . . . . . . . . . . . . . . . . 41\n  7.4.  Response Codes . . . . . . . . . . . . . . . . . . . . . . 41\n8.  Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42\n  8.1.  New Methods  . . . . . . . . . . . . . . . . . . . . . . . 42\n    8.1.1.  SUBSCRIBE Method . . . . . . . . . . . . . . . . . . . 42\n    8.1.2.  NOTIFY Method  . . . . . . . . . . . . . . . . . . . . 42\n  8.2.  New Header Fields  . . . . . . . . . . . . . . . . . . . . 42\n    8.2.1.  \"Event\" Header Field . . . . . . . . . . . . . . . . . 42\n    8.2.2.  \"Allow-Events\" Header Field  . . . . . . . . . . . . . 43\n    8.2.3.  \"Subscription-State\" Header Field  . . . . . . . . . . 43\n  8.3.  New Response Codes . . . . . . . . . . . . . . . . . . . . 43\n    8.3.1.  202 (Accepted) Response Code . . . . . . . . . . . . . 43\n    8.3.2.  489 (Bad Event) Response Code  . . . . . . . . . . . . 44\n  8.4.  Augmented BNF Definitions  . . . . . . . . . . . . . . . . 44",
      "raw": true
    },
    {
      "indent": 3,
      "text": "9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 45\n  9.1.  Normative References . . . . . . . . . . . . . . . . . . . 45\n  9.2.  Informative References . . . . . . . . . . . . . . . . . . 46\nAppendix A.  Acknowledgements  . . . . . . . . . . . . . . . . . . 48\nAppendix B.  Changes from RFC 3265 . . . . . . . . . . . . . . . . 48\n  B.1.  Bug 666: Clarify use of \"expires=xxx\" with \"terminated\"  . 48\n  B.2.  Bug 667: Reason code for unsub/poll not clearly\n        spelled out  . . . . . . . . . . . . . . . . . . . . . . . 48\n  B.3.  Bug 669: Clarify: SUBSCRIBE for a duration might be\n        answered with a NOTIFY/expires=0 . . . . . . . . . . . . . 48\n  B.4.  Bug 670: Dialog State Machine needs clarification  . . . . 49\n  B.5.  Bug 671: Clarify timeout-based removal of subscriptions  . 49\n  B.6.  Bug 672: Mandate \"expires\" in NOTIFY . . . . . . . . . . . 49\n  B.7.  Bug 673: INVITE 481 response effect clarification  . . . . 49\n  B.8.  Bug 677: SUBSCRIBE response matching text in error . . . . 49\n  B.9.  Bug 695: Document is not explicit about response to\n        NOTIFY at subscription termination . . . . . . . . . . . . 49\n  B.10. Bug 696: Subscription state machine needs clarification  . 49\n  B.11. Bug 697: Unsubscription behavior could be clarified  . . . 49\n  B.12. Bug 699: NOTIFY and SUBSCRIBE are target refresh\n        requests . . . . . . . . . . . . . . . . . . . . . . . . . 50\n  B.13. Bug 722: Inconsistent 423 reason phrase text . . . . . . . 50\n  B.14. Bug 741: Guidance needed on when to not include\n        \"Allow-Events\" . . . . . . . . . . . . . . . . . . . . . . 50\n  B.15. Bug 744: 5xx to NOTIFY terminates a subscription, but\n        should not . . . . . . . . . . . . . . . . . . . . . . . . 50\n  B.16. Bug 752: Detection of forked requests is incorrect . . . . 50\n  B.17. Bug 773: Reason code needs IANA registry . . . . . . . . . 50\n  B.18. Bug 774: Need new reason for terminating subscriptions\n        to resources that never change . . . . . . . . . . . . . . 50\n  B.19. Clarify Handling of \"Route\"/\"Record-Route\" in NOTIFY . . . 50\n  B.20. Eliminate Implicit Subscriptions . . . . . . . . . . . . . 51\n  B.21. Deprecate Dialog Reuse . . . . . . . . . . . . . . . . . . 51\n  B.22. Rationalize Dialog Creation  . . . . . . . . . . . . . . . 51\n  B.23. Refactor Behavior Sections . . . . . . . . . . . . . . . . 51\n  B.24. Clarify Sections That Need to Be Present in Event\n        Packages . . . . . . . . . . . . . . . . . . . . . . . . . 51\n  B.25. Make CANCEL Handling More Explicit . . . . . . . . . . . . 51\n  B.26. Remove \"State Agent\" Terminology . . . . . . . . . . . . . 51\n  B.27. Miscellaneous Changes  . . . . . . . . . . . . . . . . . . 52",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The ability to request asynchronous notification of events proves useful in many types of SIP services for which cooperation between end-nodes is required. Examples of such services include automatic callback services (based on terminal state events), buddy lists (based on user presence events), message waiting indications (based on mailbox state change events), and PSTN and Internet Internetworking (PINT) [RFC2848] status (based on call state events).",
      "ja": "イベントの非同期通知を要求する能力は、エンドノード間の連携が必要なSIPサービスの多くのタイプに役立ち。そのようなサービスの例としては、自動（端末状態イベントに基づいて）コールバックサービス、バディリスト（ユーザープレゼンスイベントに基づく）、（メールボックスの状態変化イベントに基づいて）メッセージ待機指示、およびPSTNとインターネットインターネットワーキング（PINT）[RFC2848]ステータスを含みます（通話状態イベントに基づいて）。"
    },
    {
      "indent": 3,
      "text": "The methods described in this document provide a framework by which notification of these events can be ordered.",
      "ja": "この文書に記載された方法は、これらのイベントの通知を注文することが可能なフレームワークを提供します。"
    },
    {
      "indent": 3,
      "text": "The event notification mechanisms defined herein are NOT intended to be a general-purpose infrastructure for all classes of event subscription and notification. Meeting requirements for the general problem set of subscription and notification is far too complex for a single protocol. Our goal is to provide a SIP-specific framework for event notification that is not so complex as to be unusable for simple features, but that is still flexible enough to provide powerful services. Note, however, that event packages based on this framework may define arbitrarily elaborate rules that govern the subscription and notification for the events or classes of events they describe.",
      "ja": "本明細書に定義されたイベント通知メカニズムは、イベントサブスクリプションと通知のすべてのクラスの汎用的なインフラであることを意図していません。サブスクリプションと通知の設定一般的な問題のための要件を満たすことは、単一のプロトコルのためにあまりにも複雑です。私たちの目標は、シンプルな機能のために使用できないほど複雑ではありませんが、それはまだ強力なサービスを提供するのに十分な柔軟性があり、イベント通知のためのSIP固有のフレームワークを提供することです。注意は、しかし、このフレームワークに基づいて、そのイベントパッケージは、彼らが説明したイベントのイベントやクラスのサブスクリプションと通知を管理する任意の精巧な規則を定義してもよいです。"
    },
    {
      "indent": 3,
      "text": "This document does not describe an extension that may be used directly; it must be extended by other documents (herein referred to as \"event packages\"). In object-oriented design terminology, it may be thought of as an abstract base class that must be derived into an instantiable class by further extensions. Guidelines for creating these extensions are described in Section 5.",
      "ja": "この文書では、直接使用することができる拡張機能については説明しません。それは他の文書（本明細書では「イベントパッケージ」と呼ばれる）によって拡張される必要があります。オブジェクト指向設計の用語には、さらに拡張することによってインスタンス化クラスに由来しなければならない抽象基底クラスと考えることができます。これらの拡張機能を作成するためのガイドラインは、第5章で説明されています。"
    },
    {
      "indent": 0,
      "text": "1.1. Overview of Operation",
      "section_title": true,
      "ja": "1.1。操作の概要"
    },
    {
      "indent": 3,
      "text": "The general concept is that entities in the network can subscribe to resource or call state for various resources or calls in the network, and those entities (or entities acting on their behalf) can send notifications when those states change.",
      "ja": "一般的な概念は、ネットワーク内のエンティティは、リソースまたはそれらの状態が変化したときに通知を送信することができます（そのために行動するか、エンティティ）は、さまざまなリソースまたはネットワーク内のコール、およびそれらのエンティティの状態を呼び出すために購読することができるということです。"
    },
    {
      "indent": 3,
      "text": "A typical flow of messages would be:",
      "ja": "メッセージの典型的な流れは次のようになります。"
    },
    {
      "indent": 3,
      "text": "Subscriber          Notifier\n    |-----SUBSCRIBE---->|     Request state subscription\n    |<-------200--------|     Acknowledge subscription\n    |<------NOTIFY----- |     Return current state information\n    |--------200------->|\n    |<------NOTIFY----- |     Return current state information\n    |--------200------->|",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Subscriptions are expired and must be refreshed by subsequent SUBSCRIBE requests.",
      "ja": "サブスクリプションの有効期限が切れていると、後続のSUBSCRIBEリクエストによってリフレッシュされなければなりません。"
    },
    {
      "indent": 0,
      "text": "1.2. Documentation Conventions",
      "section_title": true,
      "ja": "1.2。マニュアルの表記規則"
    },
    {
      "indent": 3,
      "text": "There are several paragraphs throughout this document that provide motivational or clarifying text. Such passages are non-normative and are provided only to assist with reader comprehension. These passages are set off from the remainder of the text by being indented thus:",
      "ja": "動機付けのか明確にテキストを提供し、この文書全体にいくつかの段落があります。このような通路は非規範的であり、唯一の読者の理解を助けるために提供されます。これらの通路は、このようにインデントされて、テキストの残りの部分からオフに設定されています。"
    },
    {
      "indent": 6,
      "text": "This is an example of non-normative explanatory text. It does not form part of the specification and is used only for clarification.",
      "ja": "これは、非規範的な説明文の例です。これは、明細書の一部を形成するものではないとだけ明確化のために使用されています。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "In particular, implementors need to take careful note of the meaning of \"SHOULD\" defined in RFC 2119. To rephrase: violation of \"SHOULD\"- strength requirements requires careful analysis and clearly enumerable reasons. It is a protocol violation to fail to comply with \"SHOULD\"-strength requirements whimsically or for ease of implementation.",
      "ja": "具体的には、実装者は、言い換えるするには、RFC 2119で定義された「べきである」の意味を慎重に留意する必要があります：「SHOULD」の違反 - 強度要件を慎重に分析し、明確に列挙の理由が必要です。これは、プロトコル違反が「SHOULD」-Strength要件気まぐれや実装を容易にするために従わないことです。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2.定義"
    },
    {
      "indent": 3,
      "text": "Event Package: An event package is an additional specification that defines a set of state information to be reported by a notifier to a subscriber. Event packages also define further syntax and semantics that are based on the framework defined by this document and are required to convey such state information.",
      "ja": "イベントパッケージ：イベントパッケージは、加入者に通知することによって報告される状態情報のセットを定義する追加の仕様です。イベントパッケージも、この文書で定義されたフレームワークに基づいており、このような状態情報を伝達するために必要とされ、さらに、構文とセマンティクスを定義します。"
    },
    {
      "indent": 3,
      "text": "Event Template-Package: An event template-package is a special kind of event package that defines a set of states that may be applied to all possible event packages, including itself.",
      "ja": "イベントテンプレートパッケージ：イベントテンプレートパッケージは自身を含め、すべての可能なイベントパッケージに適用することができる状態のセットを定義するイベントパッケージの特別な種類です。"
    },
    {
      "indent": 3,
      "text": "Notification: Notification is the act of a notifier sending a NOTIFY request to a subscriber to inform the subscriber of the state of a resource.",
      "ja": "通知：通知は、リソースの状態の加入者に通知するために、加入者にNOTIFYリクエストを送信する通知の行為です。"
    },
    {
      "indent": 3,
      "text": "Notifier: A notifier is a user agent that generates NOTIFY requests for the purpose of notifying subscribers of the state of a resource. Notifiers typically also accept SUBSCRIBE requests to create subscriptions.",
      "ja": "通知：通知は、リソースの状態の加入者に通知するために、NOTIFYリクエストを生成し、ユーザエージェントです。通知機能はまた、典型的には、サブスクリプションを作成するためのSUBSCRIBEリクエスト受け入れます。"
    },
    {
      "indent": 3,
      "text": "Subscriber: A subscriber is a user agent that receives NOTIFY requests from notifiers; these NOTIFY requests contain information about the state of a resource in which the subscriber is interested. Subscribers typically also generate SUBSCRIBE requests and send them to notifiers to create subscriptions.",
      "ja": "加入者：加入者はノーティファイアからNOTIFYリクエストを受信するユーザ・エージェントです。これらの要求は、加入者が関心を持っているリソースの状態に関する情報が含まれていNOTIFY。加入者はまた、典型的には、SUBSCRIBEリクエストを生成し、サブスクリプションを作成するために、通知者に送信します。"
    },
    {
      "indent": 3,
      "text": "Subscription: A subscription is a set of application state associated with a dialog. This application state includes a pointer to the associated dialog, the event package name, and possibly an identification token. Event packages will define additional subscription state information. By definition, subscriptions exist in both a subscriber and a notifier.",
      "ja": "サブスクリプション：サブスクリプションは、ダイアログに関連付けられたアプリケーション状態のセットです。このアプリケーション状態は、関連するダイアログへのポインタ、イベントパッケージ名、及びおそらくは識別トークンを含みます。イベントパッケージは、追加のサブスクリプションの状態情報を定義します。定義により、サブスクリプションはサブスクライバとノーティファイアの両方に存在します。"
    },
    {
      "indent": 3,
      "text": "Subscription Migration: Subscription migration is the act of moving a subscription from one notifier to another notifier.",
      "ja": "サブスクリプションの移行：サブスクリプションの移行は別の通知に1つの通知からサブスクリプションを移動する行為です。"
    },
    {
      "indent": 0,
      "text": "3. SIP Methods for Event Notification",
      "section_title": true,
      "ja": "イベント通知のための3 SIPメソッド"
    },
    {
      "indent": 0,
      "text": "3.1. SUBSCRIBE",
      "section_title": true,
      "ja": "3.1。申し込む"
    },
    {
      "indent": 3,
      "text": "The SUBSCRIBE method is used to request current state and state updates from a remote node. SUBSCRIBE requests are target refresh requests, as that term is defined in [RFC3261].",
      "ja": "SUBSCRIBEメソッドは、リモートノードから現在の状態と状態の更新を要求するために使用されます。その用語は、[RFC3261]で定義されるよう要求は、ターゲットリフレッシュ要求であるSUBSCRIBE。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Subscription Duration",
      "section_title": true,
      "ja": "3.1.1。サブスクリプション期間"
    },
    {
      "indent": 3,
      "text": "SUBSCRIBE requests SHOULD contain an \"Expires\" header field (defined in [RFC3261]). This expires value indicates the duration of the subscription. In order to keep subscriptions effective beyond the duration communicated in the \"Expires\" header field, subscribers need to refresh subscriptions on a periodic basis using a new SUBSCRIBE request on the same dialog as defined in [RFC3261].",
      "ja": "リクエストが「期限切れ」ヘッダフィールドを含むべきであるSUBSCRIBE（で定義された[RFC3261]）。この値は、サブスクリプションの期間を示す有効期限が切れます。ヘッダフィールドを「有効期限」で通信継続時間を超えて有効なサブスクリプションを維持するために、加入者は[RFC3261]で定義されるものと同じダイアログで新たなSUBSCRIBEリクエストを使用して、定期的にサブスクリプションを更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "If no \"Expires\" header field is present in a SUBSCRIBE request, the implied default MUST be defined by the event package being used.",
      "ja": "いかなる「有効期限」ヘッダフィールドはSUBSCRIBEリクエストに存在する場合、暗黙のデフォルトが使用されているイベントパッケージによって定義されてはなりません。"
    },
    {
      "indent": 3,
      "text": "200-class responses to SUBSCRIBE requests also MUST contain an \"Expires\" header field. The period of time in the response MAY be shorter but MUST NOT be longer than specified in the request. The notifier is explicitly allowed to shorten the duration to zero. The period of time in the response is the one that defines the duration of the subscription.",
      "ja": "200クラスの応答は、「有効期限」ヘッダフィールドを含まなければならないもSUBSCRIBE要求します。応答時間の期間が短くなることがありますが、要求に指定されたよりも長くてはなりません。通知は、明示的にゼロに期間を短縮することが許可されています。応答時間は、サブスクリプションの継続時間を定義するものです。"
    },
    {
      "indent": 3,
      "text": "An \"expires\" parameter on the \"Contact\" header field has no semantics for the SUBSCRIBE method and is explicitly not equivalent to an \"Expires\" header field in a SUBSCRIBE request or response.",
      "ja": "「連絡先」ヘッダフィールド上の「期限が切れる」パラメータは、SUBSCRIBEメソッドのセマンティクスを持っていないし、明示的にSUBSCRIBE要求または応答で「期限切れ」ヘッダフィールドと同等ではありません。"
    },
    {
      "indent": 3,
      "text": "A natural consequence of this scheme is that a SUBSCRIBE request with an \"Expires\" of 0 constitutes a request to unsubscribe from the matching subscription.",
      "ja": "このスキームの自然な結果が0の「有効期限」とSUBSCRIBEリクエストすることであるマッチング・サブスクリプションの登録を解除する要求を構成します。"
    },
    {
      "indent": 6,
      "text": "In addition to being a request to unsubscribe, a SUBSCRIBE request with \"Expires\" of 0 also causes a fetch of state; see Section 4.4.3.",
      "ja": "解除要求であることに加えて、0の「有効期限」とSUBSCRIBE要求は、状態のフェッチを引き起こします。 4.4.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Notifiers may also wish to cancel subscriptions to events; this is useful, for example, when the resource to which a subscription refers is no longer available. Further details on this mechanism are discussed in Section 4.2.2.",
      "ja": "通知機能は、イベントへのサブスクリプションをキャンセルすることを望むかもしれません。これは、サブスクリプションが参照するリソースが利用できなくなったときなどに便利ではありません。このメカニズムの詳細は、セクション4.2.2で説明されています。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Identification of Subscribed Events and Event Classes",
      "section_title": true,
      "ja": "3.1.2。サブスクライブイベントとイベントクラスの同定"
    },
    {
      "indent": 3,
      "text": "Identification of events is provided by three pieces of information: Request URI, Event Type, and (optionally) message body.",
      "ja": "イベントの識別は、3つの情報によって提供されるURI、イベントの種類、および（オプション）メッセージ本体を求めます。"
    },
    {
      "indent": 3,
      "text": "The Request URI of a SUBSCRIBE request, most importantly, contains enough information to route the request to the appropriate entity per the request routing procedures outlined in [RFC3261]. It also contains enough information to identify the resource for which event notification is desired, but not necessarily enough information to uniquely identify the nature of the event (e.g., \"sip:adam@example.com\" would be an appropriate URI to subscribe to for my presence state; it would also be an appropriate URI to subscribe to the state of my voice mailbox).",
      "ja": "SUBSCRIBEリクエストのリクエストURIは、最も重要なのは、ルートに[RFC3261]に概説リクエストルーティング手順に従って適切なエンティティに要求を十分な情報を含んでいます。また、イベント通知を希望するリソースを識別するために十分な情報が含まれているが、必ずしも十分ではない情報が一意にイベントの性質を識別するために（例えば、「SIP：adam@example.comは」のために加入するために、適切なURIになります私のプレゼンス状態;また、私のボイスメールボックスの状態に加入するために、適切なURIになります）。"
    },
    {
      "indent": 3,
      "text": "Subscribers MUST include exactly one \"Event\" header field in SUBSCRIBE requests, indicating to which event or class of events they are subscribing. The \"Event\" header field will contain a token that indicates the type of state for which a subscription is being requested. This token will be registered with the IANA and will correspond to an event package that further describes the semantics of the event or event class.",
      "ja": "加入者は、彼らがサブスクライブしているイベントのどのイベントやクラスに示す、SUBSCRIBEリクエストで正確に一つの「イベント」ヘッダフィールドを含まなければなりません。 「イベント」ヘッダフィールドは、サブスクリプションが要求されている状態のタイプを示すトークンを含むであろう。このトークンはIANAに登録され、さらにイベントやイベントクラスの意味を記述したイベントパッケージに対応します。"
    },
    {
      "indent": 3,
      "text": "If the event package to which the event token corresponds defines behavior associated with the body of its SUBSCRIBE requests, those semantics apply.",
      "ja": "イベントトークンが対応するイベントパッケージは、そのSUBSCRIBEリクエストのボディに関連付けられた動作を定義している場合、これらのセマンティクスが適用されます。"
    },
    {
      "indent": 3,
      "text": "Event packages may also define parameters for the \"Event\" header field; if they do so, they must define the semantics for such parameters.",
      "ja": "イベントパッケージは、「イベント」ヘッダフィールドのパラメータを定義することができます。彼らがそうするならば、彼らはそのようなパラメータのためのセマンティクスを定義する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.3. Additional SUBSCRIBE Header Field Values",
      "section_title": true,
      "ja": "3.1.3。追加のヘッダーフィールド値をSUBSCRIBE"
    },
    {
      "indent": 3,
      "text": "Because SUBSCRIBE requests create a dialog usage as defined in [RFC3261], they MAY contain an \"Accept\" header field. This header field, if present, indicates the body formats allowed in subsequent NOTIFY requests. Event packages MUST define the behavior for SUBSCRIBE requests without \"Accept\" header fields; usually, this will connote a single, default body type.",
      "ja": "[RFC3261]で定義されている要求は、ダイアログの使用を作成するSUBSCRIBEので、それらは「同意する」ヘッダフィールドを含むかもしれません。このヘッダーフィールドは、存在する場合、後続のNOTIFYリクエストで許可ボディフォーマットを示しています。イベントパッケージは、ヘッダフィールドを「受け入れ」のないSUBSCRIBEリクエストのための動作を定義しなければなりません。通常、これは、単一の、デフォルトのボディタイプを暗示します。"
    },
    {
      "indent": 3,
      "text": "Header values not described in this document are to be interpreted as described in [RFC3261].",
      "ja": "この文書に記載されていないヘッダ値は[RFC3261]で説明されるように解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "3.2. NOTIFY",
      "section_title": true,
      "ja": "3.2。 NOTIFY"
    },
    {
      "indent": 3,
      "text": "NOTIFY requests are sent to inform subscribers of changes in state to which the subscriber has a subscription. Subscriptions are created using the SUBSCRIBE method. In legacy implementations, it is possible that other means of subscription creation have been used. However, this specification does not allow the creation of subscriptions except through SUBSCRIBE requests and (for backwards-compatibility) REFER requests [RFC3515].",
      "ja": "NOTIFYリクエストは、加入者が加入している先の状態の変化の加入者に通知するために送信されます。サブスクリプションは、SUBSCRIBEメソッドを使用して作成されます。従来の実装では、サブスクリプションの作成の他の手段が使用されている可能性があります。ただし、この仕様は通じ除き、サブスクリプションの作成を許可しないSUBSCRIBE要求し、（後方互換性のために）要求[RFC3515]を参照してください。"
    },
    {
      "indent": 3,
      "text": "NOTIFY is a target refresh request, as that term is defined in [RFC3261].",
      "ja": "NOTIFYその用語は[RFC3261]で定義されているように、ターゲットリフレッシュ要求です。"
    },
    {
      "indent": 3,
      "text": "A NOTIFY request does not terminate its corresponding subscription; in other words, a single SUBSCRIBE request may trigger several NOTIFY requests.",
      "ja": "Aそれに対応するサブスクリプションを終了しませんNOTIFYリクエストを。言い換えれば、単一SUBSCRIBEリクエストには、いくつかのNOTIFYリクエストをトリガすることができます。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Identification of Reported Events, Event Classes, and Current State",
      "ja": "3.2.1。報告されたイベント、イベントクラス、および現状の同定"
    },
    {
      "indent": 3,
      "text": "Identification of events being reported in a notification is very similar to that described for subscription to events (see Section 3.1.2).",
      "ja": "通知で報告された事象の同定は、イベントへのサブスクリプションのために説明したものと非常に類似している（3.1.2項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "As in SUBSCRIBE requests, NOTIFY request \"Event\" header fields MUST contain a single event package name for which a notification is being generated. The package name in the \"Event\" header field MUST match the \"Event\" header field in the corresponding SUBSCRIBE request.",
      "ja": "SUBSCRIBEリクエストのように、要求「イベントを」NOTIFYヘッダフィールドは、通知が生成されている単一のイベントパッケージ名を含まなければなりません。 「イベント」ヘッダフィールドにパッケージ名が、対応するSUBSCRIBEリクエストの「イベント」ヘッダフィールドに一致しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Event packages may define semantics associated with the body of their NOTIFY requests; if they do so, those semantics apply. NOTIFY request bodies are expected to provide additional details about the nature of the event that has occurred and the resultant resource state.",
      "ja": "イベントパッケージは、そのNOTIFYリクエストのボディに関連付けられた意味を定義します。彼らがそうするならば、これらのセマンティクスが適用されます。 NOTIFYリクエスト体が発生したイベントの性質と結果のリソースの状態に関する追加の詳細を提供することが期待されています。"
    },
    {
      "indent": 3,
      "text": "When present, the body of the NOTIFY request MUST be formatted into one of the body formats specified in the \"Accept\" header field of the corresponding SUBSCRIBE request (or the default type according to the event package description, if no \"Accept\" header field was specified). This body will contain either the state of the subscribed resource or a pointer to such state in the form of a URI (see Section 5.4.13).",
      "ja": "、NOTIFYリクエストのボディで指定本体のいずれかの形式にフォーマットしなければならないときに存在しないヘッダ・フィールド「同意する」場合、イベントパッケージの説明に従って、対応するSUBSCRIBEリクエストのヘッダフィールド（またはデフォルトのタイプを「同意しません」 ）指定されました。この体が加入資源の状態又はURIの形でそのような状態へのポインタのいずれかを含有するであろう（セクション5.4.13を参照のこと）。"
    },
    {
      "indent": 0,
      "text": "4. Node Behavior",
      "section_title": true,
      "ja": "4.ノードの動作"
    },
    {
      "indent": 0,
      "text": "4.1. Subscriber Behavior",
      "section_title": true,
      "ja": "4.1。加入者の行動"
    },
    {
      "indent": 0,
      "text": "4.1.1. Detecting Support for SIP Events",
      "section_title": true,
      "ja": "4.1.1。 SIPイベントの検出をサポート"
    },
    {
      "indent": 3,
      "text": "The extension described in this document does not make use of the \"Require\" or \"Proxy-Require\" header fields; similarly, there is no token defined for \"Supported\" header fields. Potential subscribers may probe for the support of SIP events using the OPTIONS request defined in [RFC3261].",
      "ja": "この文書に記載され拡張子が「必要」又は「プロキシ要求」ヘッダーフィールドを使用しません。同様に、「サポート」ヘッダフィールドに定義されたトークンは存在しません。潜在的な加入者は[RFC3261]で定義されたOPTIONS要求を使用してSIPイベントのサポートを探索してもよいです。"
    },
    {
      "indent": 3,
      "text": "The presence of \"SUBSCRIBE\" in the \"Allow\" header field of any request or response indicates support for SIP events; further, in the absence of an \"Allow\" header field, the simple presence of an \"Allow-Events\" header field is sufficient to indicate that the node that sent the message is capable of acting as a notifier (see Section 4.4.4).",
      "ja": "任意の要求または応答のヘッダフィールドは、SIPイベントのサポートを示す「許可」の「SUBSCRIBE」の存在。さらに、「許可」ヘッダフィールドが存在しない場合に、「許可・イベント」ヘッダフィールドの単純な存在は、メッセージを送信したノードが通知として作用することが可能であることを示すのに十分である（セクション4.4.4を参照） 。"
    },
    {
      "indent": 6,
      "text": "The \"methods\" parameter for Contact may also be used to specifically announce support for SUBSCRIBE and NOTIFY requests when registering. (See [RFC3840] for details on the \"methods\" parameter.)",
      "ja": "問い合わせのための「方法」パラメータも登録する際に、具体的SUBSCRIBEとNOTIFYリクエストのサポートを発表するために使用することができます。 （「メソッド」パラメータの詳細については、[RFC3840]を参照してください。）"
    },
    {
      "indent": 0,
      "text": "4.1.2. Creating and Maintaining Subscriptions",
      "section_title": true,
      "ja": "4.1.2。サブスクリプションの作成およびメンテナンス"
    },
    {
      "indent": 3,
      "text": "From the subscriber's perspective, a subscription proceeds according to the following state diagram. Events that result in a transition back to the same state are not represented in this diagram.",
      "ja": "加入者の観点から、サブスクリプションは、次の状態図に従って進行します。バック同じ状態への遷移をもたらすイベントが、この図には示されません。"
    },
    {
      "indent": 3,
      "text": "                       +-------------+\n                       |    init     |<-----------------------+\n                       +-------------+                        |\n                              |                           Retry-after\n                        Send SUBSCRIBE                    expires\n                              |                               |\n                              V          Timer N Fires;       |\n                       +-------------+   SUBSCRIBE failure    |\n          +------------| notify_wait |-- response; --------+  |\n          |            +-------------+   or NOTIFY,        |  |\n          |                   |          state=terminated  |  |\n          |                   |                            |  |\n++========|===================|============================|==|====++\n||        |                   |                            V  |    ||\n||  Receive NOTIFY,    Receive NOTIFY,             +-------------+ ||\n||  state=active       state=pending               | terminated  | ||\n||        |                   |                    +-------------+ ||\n||        |                   |          Re-subscription     A  A  ||\n||        |                   V          times out;          |  |  ||\n||        |            +-------------+   Receive NOTIFY,     |  |  ||\n||        |            |   pending   |-- state=terminated; --+  |  ||\n||        |            +-------------+   or 481 response        |  ||\n||        |                   |          to SUBSCRIBE           |  ||\n||        |            Receive NOTIFY,   refresh                |  ||\n||        |            state=active                             |  ||\n||        |                   |          Re-subscription        |  ||\n||        |                   V          times out;             |  ||\n||        |            +-------------+   Receive NOTIFY,        |  ||\n||        +----------->|   active    |-- state=terminated; -----+  ||\n||                     +-------------+   or 481 response           ||\n||                                       to SUBSCRIBE              ||\n|| Subscription                          refresh                   ||\n++=================================================================++",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the state diagram, \"Re-subscription times out\" means that an attempt to refresh or update the subscription using a new SUBSCRIBE request does not result in a NOTIFY request before the corresponding Timer N expires.",
      "ja": "状態図では、「再加入時間外」に対応するタイマーNの有効期限が切れる前に新しいSUBSCRIBEリクエストがNOTIFYリクエストにはなりません使用してサブスクリプションをリフレッシュまたは更新するために、その試みを意味します。"
    },
    {
      "indent": 3,
      "text": "Any transition from \"notify_wait\" into a \"pending\" or \"active\" state results in a new subscription. Note that multiple subscriptions can be generated as the result of a single SUBSCRIBE request (see Section 4.4.1). Each of these new subscriptions exists in its own independent state machine and runs its own set of timers.",
      "ja": "新しいサブスクリプションの「保留中」または「アクティブ」状態の結果に「notify_wait」から任意の遷移。複数のサブスクリプションは、単一SUBSCRIBEリクエスト（セクション4.4.1を参照）の結果として生成することができることに留意されたいです。これらの新しいサブスクリプションは、それぞれ独自の独立したステートマシンに存在し、タイマーの独自のセットを実行します。"
    },
    {
      "indent": 0,
      "text": "4.1.2.1. Requesting a Subscription",
      "section_title": true,
      "ja": "4.1.2.1。購読を要求"
    },
    {
      "indent": 3,
      "text": "SUBSCRIBE is a dialog-creating method, as described in [RFC3261].",
      "ja": "SUBSCRIBE [RFC3261]に記載されているように、ダイアログ作成方法です。"
    },
    {
      "indent": 3,
      "text": "When a subscriber wishes to subscribe to a particular state for a resource, it forms a SUBSCRIBE request. If the initial SUBSCRIBE request represents a request outside of a dialog (as it typically will), its construction follows the procedures outlined in [RFC3261] for User Agent Client (UAC) request generation outside of a dialog.",
      "ja": "加入者は、リソースの特定の状態に加入することを望む場合には、SUBSCRIBEリクエストを形成します。 （それは、典型的には、のように）、その構造は、ダイアログの外側ユーザエージェントクライアント（UAC）要求の発生のために[RFC3261]に概説された手順に従う最初の要求は、ダイアログの外部要求を表すSUBSCRIBE場合。"
    },
    {
      "indent": 3,
      "text": "This SUBSCRIBE request will be confirmed with a final response. 200-class responses indicate that the subscription has been accepted and that a NOTIFY request will be sent immediately.",
      "ja": "このSUBSCRIBEリクエストは、最終的な応答で確認されます。 200クラスの応答は、サブスクリプションが受け入れられたこととNOTIFYリクエストがすぐに送信されることを示しています。"
    },
    {
      "indent": 3,
      "text": "The \"Expires\" header field in a 200-class response to SUBSCRIBE request indicates the actual duration for which the subscription will remain active (unless refreshed). The received value might be smaller than the value indicated in the SUBSCRIBE request but cannot be larger; see Section 4.2.1 for details.",
      "ja": "SUBSCRIBEリクエストする200クラス応答のヘッダフィールドを「有効期限」（リフレッシュしない限り）サブスクリプションがアクティブのままになるため、実際の時間を示しています。受信された値は、SUBSCRIBEリクエストで示された値よりも小さいかもしれないが、大きくすることができません。詳細については、4.2.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Non-200-class final responses indicate that no subscription or new dialog usage has been created, and no subsequent NOTIFY request will be sent. All non-200-class responses (with the exception of 489 (Bad Event), described herein) have the same meanings and handling as described in [RFC3261]. For the sake of clarity: if a SUBSCRIBE request contains an \"Accept\" header field, but that field does not indicate a media type that the notifier is capable of generating in its NOTIFY requests, then the proper error response is 406 (Not Acceptable).",
      "ja": "非200クラスの最終応答には、サブスクリプションまたは新しいダイアログ用法が作成されていない、と後続NOTIFYリクエストが送信されないことを示しています。 （本明細書中に記載さ489（不良イベント）を除いて、）すべての非200クラス応答は、同じ意味を有し、[RFC3261]に記載されているように扱います。要求は、ヘッダフィールド「同意」が含まSUBSCRIBEが、そのフィールドは、通知は、そのNOTIFYリクエストで生成することができるメディアタイプを示していない場合、適切なエラー応答406（許容できない）である。明確にするために。"
    },
    {
      "indent": 0,
      "text": "4.1.2.2. Refreshing of Subscriptions",
      "section_title": true,
      "ja": "4.1.2.2。サブスクリプションのリフレッシュ"
    },
    {
      "indent": 3,
      "text": "At any time before a subscription expires, the subscriber may refresh the timer on such a subscription by sending another SUBSCRIBE request on the same dialog as the existing subscription. The handling for such a request is the same as for the initial creation of a subscription except as described below.",
      "ja": "サブスクリプションの有効期限が切れる前に、任意の時点で、加入者は、別の既存のサブスクリプションと同じダイアログ上のSUBSCRIBEリクエストを送信することにより、このようなサブスクリプションにタイマーをリフレッシュします。そのような要求のための処理は、以下に記載されている場合を除き、サブスクリプションの初期作成の場合と同じです。"
    },
    {
      "indent": 3,
      "text": "If a SUBSCRIBE request to refresh a subscription receives a 404, 405, 410, 416, 480-485, 489, 501, or 604 response, the subscriber MUST consider the subscription terminated. (See [RFC5057] for further details and notes about the effect of error codes on dialogs and usages within dialog, such as subscriptions). If the subscriber wishes to re-subscribe to the state, he does so by composing an unrelated initial SUBSCRIBE request with a freshly generated Call-ID and a new, unique \"From\" tag (see Section 4.1.2.1).",
      "ja": "SUBSCRIBEサブスクリプションを更新するための要求が受信した場合404、405、410、416、480から485、489、501、または604応答は、加入者が終了スクリプションを考慮しなければなりません。 （例えば、サブスクリプションのように、ダイアログ内のダイアログと用途にエラーコードの効果についてのさらなる詳細および注意事項については、[RFC5057]を参照）。加入者が状態に再加入することを希望する場合、彼は関係のない初期たて生成されたコールIDと（セクション4.1.2.1を参照）タグ「から」新しい、ユニークでSUBSCRIBEリクエストを構成することにより、そうします。"
    },
    {
      "indent": 3,
      "text": "If a SUBSCRIBE request to refresh a subscription fails with any error code other than those listed above, the original subscription is still considered valid for the duration of the most recently known \"Expires\" value as negotiated by the most recent successful SUBSCRIBE transaction, or as communicated by a NOTIFY request in its \"Subscription-State\" header field \"expires\" parameter.",
      "ja": "サブスクリプションをリフレッシュするSUBSCRIBEリクエストは、上記以外のエラーコードで失敗した場合は、元のサブスクリプションは、まだ最近成功した最新のトランザクションをSUBSCRIBEによって交渉された値を「有効期限」、またはとして知られているの期間中有効と考えられていますその「サブスクリプション状態」ヘッダフィールドのNOTIFYリクエストによって通信パラメータを「満了します」。"
    },
    {
      "indent": 6,
      "text": "Note that many such errors indicate that there may be a problem with the network or the notifier such that no further NOTIFY requests will be received.",
      "ja": "多くのこのようなエラーは、ネットワークに問題またはそれ以上の要求が受信されるNOTIFYないような通知があるかもしれないことを示していることに注意してください。"
    },
    {
      "indent": 3,
      "text": "When refreshing a subscription, a subscriber starts Timer N, set to 64*T1, when it sends the SUBSCRIBE request. If this Timer N expires prior to the receipt of a NOTIFY request, the subscriber considers the subscription terminated. If the subscriber receives a success response to the SUBSCRIBE request that indicates that no NOTIFY request will be generated -- such as the 204 response defined for use with the optional extension described in [RFC5839] -- then it MUST cancel Timer N.",
      "ja": "サブスクリプションをリフレッシュすると、それはSUBSCRIBEリクエストを送信する際に、加入者は、64 * T1に設定タイマーNを、開始します。このタイマーNは、NOTIFYリクエストの受信前に期限切れになった場合、加入者は、サブスクリプションが終了と見なします。このような[RFC5839]に記載の任意の拡張子で使用するために定義された204応答として -   - それはタイマNをキャンセルする必要があり、加入者には、要求が生成される通知することを示していないSUBSCRIBEリクエストに対する成功応答を受信した場合"
    },
    {
      "indent": 0,
      "text": "4.1.2.3. Unsubscribing",
      "section_title": true,
      "ja": "4.1.2.3。退会"
    },
    {
      "indent": 3,
      "text": "Unsubscribing is handled in the same way as refreshing of a subscription, with the \"Expires\" header field set to \"0\". Note that a successful unsubscription will also trigger a final NOTIFY request.",
      "ja": "ヘッダフィールドセットを「0」に「有効期限」と退会は、サブスクリプションのリフレッシュと同じ方法で処理されます。成功退会も最終NOTIFYリクエストをトリガすることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The final NOTIFY request may or may not contain information about the state of the resource; subscribers need to be prepared to receive final NOTIFY requests both with and without state.",
      "ja": "最終NOTIFYリクエストは、またはリソースの状態に関する情報を含んでも含まなくてもよいです。加入者が持つと状態なしの両方の最後のNOTIFYリクエストを受け取るために準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.2.4. Confirmation of Subscription Creation",
      "section_title": true,
      "ja": "4.1.2.4。サブスクリプションの作成の確認"
    },
    {
      "indent": 3,
      "text": "The subscriber can expect to receive a NOTIFY request from each node which has processed a successful subscription or subscription refresh. To ensure that subscribers do not wait indefinitely for a subscription to be established, a subscriber starts a Timer N, set to 64*T1, when it sends a SUBSCRIBE request. If this Timer N expires prior to the receipt of a NOTIFY request, the subscriber considers the subscription failed, and cleans up any state associated with the subscription attempt.",
      "ja": "加入者は、成功したサブスクリプションまたはサブスクリプションの更新を処理した各ノードからNOTIFYリクエストを受け取ることを期待することができます。加入者が確立されるサブスクリプションを無期限に待機していないことを確認するために、加入者は、それがSUBSCRIBEリクエストを送信すると、64 * T1に設定し、タイマーNを開始します。このタイマーNは、NOTIFYリクエストの受信前に期限切れになった場合、加入者は、サブスクリプションが失敗したとみなし、およびサブスクリプションの試みに関連するすべての状態をクリーンアップします。"
    },
    {
      "indent": 3,
      "text": "Until Timer N expires, several NOTIFY requests may arrive from different destinations (see Section 4.4.1). Each of these requests establishes a new dialog usage and a new subscription. After the expiration of Timer N, the subscriber SHOULD reject any such NOTIFY requests that would otherwise establish a new dialog usage with a 481 (Subscription does not exist) response code.",
      "ja": "タイマーNが切れるまで、いくつかの要求が異なる宛先（セクション4.4.1を参照）から到着するNOTIFY。これらの要求のそれぞれには、新しいダイアログの使用量と、新しいサブスクリプションを確立します。タイマーNの満了後に、加入者がどのようには、そうでない場合は481（サブスクリ存在しない）応答コードを持つ新しいダイアログの使用を確立するNOTIFYリクエストを拒否すべきです。"
    },
    {
      "indent": 3,
      "text": "Until the first NOTIFY request arrives, the subscriber should consider the state of the subscribed resource to be in a neutral state. Event package specifications MUST define this \"neutral state\" in such a way that makes sense for their application (see Section 5.4.7).",
      "ja": "最初のNOTIFYリクエストが到着するまで、加入者が加入し、リソースの状態がニュートラル状態であることを考慮すべきです。イベントパッケージの仕様は、アプリケーション（第5.4.7項を参照）のために理にかなっているように、この「ニュートラル状態」を定義しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Due to the potential for out-of-order messages, packet loss, and forking, the subscriber MUST be prepared to receive NOTIFY requests before the SUBSCRIBE transaction has completed.",
      "ja": "アウトオブオーダーメッセージ、パケット損失、およびフォークの潜在的に、加入者はSUBSCRIBEトランザクションが完了する前にNOTIFYリクエストを受け取るために準備しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Except as noted above, processing of this NOTIFY request is the same as in Section 4.1.3.",
      "ja": "このNOTIFY要求を、上述の処理を除き、セクション4.1.3と同じです。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Receiving and Processing State Information",
      "section_title": true,
      "ja": "4.1.3。受信し、処理状態情報"
    },
    {
      "indent": 3,
      "text": "Subscribers receive information about the state of a resource to which they have subscribed in the form of NOTIFY requests.",
      "ja": "加入者は、彼らがNOTIFYリクエストの形で加入していると、リソースの状態に関する情報を受信します。"
    },
    {
      "indent": 3,
      "text": "Upon receiving a NOTIFY request, the subscriber should check that it matches at least one of its outstanding subscriptions; if not, it MUST return a 481 (Subscription does not exist) response unless another 400- or 500-class response is more appropriate. The rules for matching NOTIFY requests with subscriptions that create a new dialog usage are described in Section 4.4.1. Notifications for subscriptions that were created inside an existing dialog match if they are in the same dialog and the \"Event\" header fields match (as described in Section 8.2.1).",
      "ja": "NOTIFY要求を受信すると、加入者は、その優れたサブスクリプションの少なくとも一つと一致することを確認しなければなりません。ない場合は、別の400-または500クラスの応答がより適切でない限り、それは481（サブスクリ存在しない）応答を返さなければなりません。新しいダイアログの使用を作成するサブスクリプションとNOTIFYリクエストをマッチングするための規則は、4.4.1項で説明されています。それらが同じダイアログ及び「イベント」ヘッダフィールドが一致する（セクション8.2.1で説明したように）にある場合、既存のダイアログ一致内で作成されたサブスクリプションの通知。"
    },
    {
      "indent": 3,
      "text": "If, for some reason, the event package designated in the \"Event\" header field of the NOTIFY request is not supported, the subscriber will respond with a 489 (Bad Event) response.",
      "ja": "、何らかの理由で、NOTIFYリクエストの「イベント」ヘッダフィールドで指定されたイベントパッケージのためにサポートされていない場合、加入者は489（不良イベント）応答で応答します。"
    },
    {
      "indent": 3,
      "text": "To prevent spoofing of events, NOTIFY requests SHOULD be authenticated using any defined SIP authentication mechanism, such as those described in Sections 22.2 and 23 of [RFC3261].",
      "ja": "イベントのなりすましを防ぐために、NOTIFYリクエストは、セクション22.2及び[RFC3261]の23に記載されているような任意の定義されたSIP認証メカニズムを使用して認証されるべきです。"
    },
    {
      "indent": 3,
      "text": "NOTIFY requests MUST contain \"Subscription-State\" header fields that indicate the status of the subscription.",
      "ja": "NOTIFYリクエストは、サブスクリプションのステータスを示す「サブスクリプション・ステート」ヘッダフィールドを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the \"Subscription-State\" header field value is \"active\", it means that the subscription has been accepted and (in general) has been authorized. If the header field also contains an \"expires\" parameter, the subscriber SHOULD take it as the authoritative subscription duration and adjust accordingly. The \"retry-after\" and \"reason\" parameters have no semantics for \"active\".",
      "ja": "「サブスクリプション状態」ヘッダフィールドの値が「アクティブ」である場合、それは、サブスクリプションを受け付けたと（一般的に）許可されたことを意味します。ヘッダフィールドはまた、「期限が切れる」パラメータが含まれている場合、加入者は、信頼できるサブスクリプション期間としてそれを取るし、それに応じて調整する必要があります。 「後の再試行」と「理由」パラメータが「アクティブ」には意味を持ちません。"
    },
    {
      "indent": 3,
      "text": "If the \"Subscription-State\" value is \"pending\", the subscription has been received by the notifier, but there is insufficient policy information to grant or deny the subscription yet. If the header field also contains an \"expires\" parameter, the subscriber SHOULD take it as the authoritative subscription duration and adjust accordingly. No further action is necessary on the part of the subscriber. The \"retry-after\" and \"reason\" parameters have no semantics for \"pending\".",
      "ja": "「サブスクリプション・ステート」の値が「保留」されている場合は、サブスクリプションは、通知によって受信されているが、まだサブスクリプションを許可または拒否するのに十分なポリシー情報があります。ヘッダフィールドはまた、「期限が切れる」パラメータが含まれている場合、加入者は、信頼できるサブスクリプション期間としてそれを取るし、それに応じて調整する必要があります。これ以上のアクションは、加入者の一部には必要ありません。 「-後の再試行」と「理由」パラメータが「保留」には意味を持ちません。"
    },
    {
      "indent": 3,
      "text": "If the \"Subscription-State\" value is \"terminated\", the subscriber MUST consider the subscription terminated. The \"expires\" parameter has no semantics for \"terminated\" -- notifiers SHOULD NOT include an \"expires\" parameter on a \"Subscription-State\" header field with a value of \"terminated\", and subscribers MUST ignore any such parameter, if present. If a reason code is present, the client should behave as described below. If no reason code or an unknown reason code is present, the client MAY attempt to re-subscribe at any time (unless a \"retry-after\" parameter is present, in which case the client SHOULD NOT attempt re-subscription until after the number of seconds specified by the \"retry-after\" parameter). The reason codes defined by this document are:",
      "ja": "「サブスクリプション・ステート」の値が「終了」した場合、加入者は終了し、サブスクリプションを考慮する必要があります。パラメータが「終了」のための意味を持っていない「期限が切れる」 - 届出者が存在する場合、「終了」の値を「サブスクリプション・ステート」ヘッダフィールドにパラメータを「期限が切れる」、および加入者がどのようなパラメータを無視しなければならない含めるべきではありません。理由コードが存在する場合は以下に述べるように、クライアントが振る舞うべき。理由コードまたは未知の理由コードが存在しない場合、クライアントは（いつでも再サブスクライブしようとするかもしれない限り、「リトライ-後」パラメータは、クライアントが数後までの再加入を試みるべきではありません、その場合には、存在しています「リトライ-後」パラメータで指定した秒）。この文書で定義された理由コードは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "deactivated: The subscription has been terminated, but the subscriber SHOULD retry immediately with a new subscription. One primary use of such a status code is to allow migration of subscriptions between nodes. The \"retry-after\" parameter has no semantics for \"deactivated\".",
      "ja": "非アクティブ：サブスクリプションは終了したが、加入者は、新しいサブスクリプションをすぐに再試行する必要があります。このようなステータスコードの一の主要用途は、ノード間のサブスクリプションの移行を可能にすることです。 「リトライ-後」パラメータが「無効」には意味を持ちません。"
    },
    {
      "indent": 3,
      "text": "probation: The subscription has been terminated, but the client SHOULD retry at some later time (as long as the resource's state is still relevant to the client at that time). If a \"retry-after\" parameter is also present, the client SHOULD wait at least the number of seconds specified by that parameter before attempting to re-subscribe.",
      "ja": "保護観察：（リソースの状態は、その時点ではまだ、クライアントに関連する限り）サブスクリプションが終了したが、クライアントは、いくつか後で再試行する必要があります。 「リトライ-後」場合は、パラメータも存在する、クライアントは再サブスクライブを試みる前に、そのパラメータで指定された秒の少なくとも数を待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "rejected: The subscription has been terminated due to change in authorization policy. Clients SHOULD NOT attempt to re-subscribe. The \"retry-after\" parameter has no semantics for \"rejected\".",
      "ja": "拒否：サブスクリプションは、認可ポリシーに変更することにより終了しました。クライアントは再サブスクライブを試みるべきではありません。 「リトライ-後の」パラメータが「拒否」のための意味を持っていません。"
    },
    {
      "indent": 3,
      "text": "timeout: The subscription has been terminated because it was not refreshed before it expired. Clients MAY re-subscribe immediately. The \"retry-after\" parameter has no semantics for \"timeout\". This reason code is also associated with polling of resource state, as detailed in Section 4.4.3.",
      "ja": "タイムアウト：それは期限が切れる前にそれがリフレッシュされていなかったので、サブスクリプションが終了しました。クライアントは、すぐに再加入することができます。 「リトライ-後」パラメータは「タイムアウト」には意味を持ちません。 4.4.3項で詳述するように、この理由コードは、リソースの状態のポーリングに関連しています。"
    },
    {
      "indent": 3,
      "text": "giveup: The subscription has been terminated because the notifier could not obtain authorization in a timely fashion. If a \"retry-after\" parameter is also present, the client SHOULD wait at least the number of seconds specified by that parameter before attempting to re-subscribe; otherwise, the client MAY retry immediately, but will likely get put back into pending state.",
      "ja": "ギブアップ：通知がタイムリーに承認を取得できなかったため、サブスクリプションが終了しました。 「リトライ-後」パラメータも存在している場合、クライアントは再サブスクライブを試みる前に、そのパラメータで指定された秒の少なくとも数を待つ必要があります。そうでない場合、クライアントはすぐに再試行するかもしれないが、おそらく保留状態に戻されます。"
    },
    {
      "indent": 3,
      "text": "noresource: The subscription has been terminated because the resource state that was being monitored no longer exists. Clients SHOULD NOT attempt to re-subscribe. The \"retry-after\" parameter has no semantics for \"noresource\".",
      "ja": "NORESOURCE：もはや監視されたリソースの状態が存在するため、サブスクリプションが終了しました。クライアントは再サブスクライブを試みるべきではありません。 「リトライ-後」パラメータが「NORESOURCE」には意味を持ちません。"
    },
    {
      "indent": 3,
      "text": "invariant: The subscription has been terminated because the resource state is guaranteed not to change for the foreseeable future. This may be the case, for example, when subscribing to the location information of a fixed-location land-line telephone. When using this reason code, notifiers are advised to include a \"retry-after\" parameter with a large value (for example, 31536000 -- or one year) to prevent older clients that are RFC 3265 compliant from periodically re-subscribing. Clients SHOULD NOT attempt to re-subscribe after receiving a reason code of \"invariant\", regardless of the presence of or value of a \"retry-after\" parameter.",
      "ja": "不変：リソースの状態が予見可能な将来のために変化しないことが保証されているため、サブスクリプションが終了しました。固定位置陸線電話の位置情報をサブスクライブするとき、これは、例えば、場合であってもよいです。定期的に再サブスクライブしてから対応RFC 3265ある古いクライアントを防ぐために - この理由コードを使用する場合、届出者は「リトライ-後」（または1年例えば、31536000）大きな値を持つパラメータを含めることをお勧めします。クライアントは関係なく、の存在または「再試行-後の」パラメータの値の、「不変」の理由コードを受け取った後に再加入することを試みるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Other specifications may define new reason codes for use with the \"Subscription-State\" header field.",
      "ja": "その他の仕様は、「サブスクリプション・ステート」ヘッダフィールドで使用する新しい理由コードを定義することもできます。"
    },
    {
      "indent": 3,
      "text": "Once the notification is deemed acceptable to the subscriber, the subscriber SHOULD return a 200 response. In general, it is not expected that NOTIFY responses will contain bodies; however, they MAY, if the NOTIFY request contained an \"Accept\" header field.",
      "ja": "通知が加入者に許容されるとみなされると、加入者は200応答を返すべきです。一般的には、応答は体が含まれます通知することを期待されていません。しかし、彼らはMAY、NOTIFYリクエストは、「同意する」ヘッダフィールドが含まれている場合。"
    },
    {
      "indent": 3,
      "text": "Other responses defined in [RFC3261] may also be returned, as appropriate. In no case should a NOTIFY transaction extend for any longer than the time necessary for automated processing. In particular, subscribers MUST NOT wait for a user response before returning a final response to a NOTIFY request.",
      "ja": "[RFC3261]で定義された他の応答はまた、必要に応じて、戻すことができます。いかなる場合にNOTIFYトランザクションは、自動処理のために必要な時間よりもはやために拡張する必要があります。具体的には、加入者はNOTIFYリクエストに対する最終的な応答を返す前に、ユーザーの応答を待ってはなりません。"
    },
    {
      "indent": 0,
      "text": "4.1.4. Forking of SUBSCRIBE Requests",
      "section_title": true,
      "ja": "4.1.4。 SUBSCRIBEリクエストのフォーク"
    },
    {
      "indent": 3,
      "text": "In accordance with the rules for proxying non-INVITE requests as defined in [RFC3261], successful SUBSCRIBE requests will receive only one 200-class response; however, due to forking, the subscription may have been accepted by multiple nodes. The subscriber MUST therefore be prepared to receive NOTIFY requests with \"From:\" tags that differ from the \"To:\" tag received in the SUBSCRIBE 200-class response.",
      "ja": "成功した要求が唯一200クラス応答を受信するSUBSCRIBE [RFC3261]で定義されるように、非INVITEリクエストをプロキシするためのルールによれば、しかし、フォークのために、サブスクリプションは、複数のノードに受け入れられている可能性があります。 「：を」異なるタグ200クラスをSUBSCRIBE応答して受信したタグ：加入者は、したがって、「から」とNOTIFYリクエストを受信するように準備しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If multiple NOTIFY requests are received in different dialogs in response to a single SUBSCRIBE request, each dialog represents a different destination to which the SUBSCRIBE request was forked. Subscriber handling in such situations varies by event package; see Section 5.4.9 for details.",
      "ja": "複数のNOTIFYリクエストが単一のSUBSCRIBE要求に応じて、異なるダイアログボックスで受信される場合、各ダイアログはSUBSCRIBEリクエストがフォークされたために、異なる宛先を表します。このような状況での取り扱い加入者がイベントパッケージによって異なります。詳細については、セクション5.4.9を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2. Notifier Behavior",
      "section_title": true,
      "ja": "4.2。 Notifierの行動"
    },
    {
      "indent": 0,
      "text": "4.2.1. Subscription Establishment and Maintenance",
      "section_title": true,
      "ja": "4.2.1。サブスクリプションの確立と維持"
    },
    {
      "indent": 3,
      "text": "Notifiers learn about subscription requests by receiving SUBSCRIBE requests from interested parties. Notifiers MUST NOT create subscriptions except upon receipt of a SUBSCRIBE request. However, for historical reasons, the implicit creation of subscriptions as defined in [RFC3515] is still permitted.",
      "ja": "通知機能は、利害関係者からの要求をSUBSCRIBE受信することにより、サブスクリプション要求について学びます。ノーティファイアはSUBSCRIBEリクエストの受信時を除いて、サブスクリプションを作成してはいけません。しかし、歴史的な理由のために、[RFC3515]で定義されるようにサブスクリプションの暗黙的な作成はまだ許可されています。"
    },
    {
      "indent": 6,
      "text": "[RFC3265] allowed the creation of subscriptions using means other than the SUBSCRIBE method. The only standardized use of this mechanism is the REFER method [RFC3515]. Implementation experience with REFER has shown that the implicit creation of a subscription has a number of undesirable effects, such as the inability to signal the success of a REFER request while signaling a problem with the subscription, and difficulty performing one action without the other. Additionally, the proper exchange of dialog identifiers is difficult without dialog reuse (which has its own set of problems; see Section 4.5).",
      "ja": "[RFC3265]は、SUBSCRIBEメソッド以外の手段を使用して、サブスクリプションの作成を可能にしました。このメカニズムの唯一の標準化された使用は、REFERメソッド[RFC3515]です。サブスクリプションの暗黙の作成は、このようなサブスクリプションの問題を、シグナリング、および難易度は他なしのアクションを実行しながら、REFERリクエストの成功を知らせることができないことなどの望ましくない影響、多くのを持っていることが示されているREFERと実装経験。 （; 4.5節を参照してください問題の独自のセットを持っている）また、ダイアログ識別子の適切な交換は、ダイアログの再利用せずに困難です。"
    },
    {
      "indent": 0,
      "text": "4.2.1.1. Initial SUBSCRIBE Transaction Processing",
      "section_title": true,
      "ja": "4.2.1.1。初期SUBSCRIBEトランザクション処理"
    },
    {
      "indent": 3,
      "text": "In no case should a SUBSCRIBE transaction extend for any longer than the time necessary for automated processing. In particular, notifiers MUST NOT wait for a user response before returning a final response to a SUBSCRIBE request.",
      "ja": "いかなる場合にSUBSCRIBEトランザクションは、自動処理のために必要な時間よりもはやために拡張する必要があります。特に、ノーティファイアはSUBSCRIBEリクエストに対する最終応答を返す前に、ユーザーの応答を待ってはなりません。"
    },
    {
      "indent": 6,
      "text": "This requirement is imposed primarily to prevent the non-INVITE transaction timeout timer F (see [RFC3261]) from firing during the SUBSCRIBE transaction, since interaction with a user would often exceed 64*T1 seconds.",
      "ja": "ユーザーとの相互作用は、多くの場合、64 * T1秒を超えてしまうので、この要件は、SUBSCRIBEトランザクション中に発射からF（参照[RFC3261]）非INVITEトランザクションのタイムアウトタイマーを防ぐために、主に課されています。"
    },
    {
      "indent": 3,
      "text": "The notifier SHOULD check that the event package specified in the \"Event\" header field is understood. If not, the notifier SHOULD return a 489 (Bad Event) response to indicate that the specified event/event class is not understood.",
      "ja": "通知は、「イベント」ヘッダフィールドで指定されたイベントパッケージが理解されていることを確認する必要があります。そうでない場合、通知は、指定されたイベント/イベントクラスが理解されていないことを示すために489（不良イベント）レスポンスを返すべきです。"
    },
    {
      "indent": 3,
      "text": "The notifier SHOULD also perform any necessary authentication and authorization per its local policy. See Section 4.2.1.3.",
      "ja": "通知はまた、ローカルポリシーごとにすべての必要な認証および承認を実行する必要があります。 4.2.1.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The notifier MAY also check that the duration in the \"Expires\" header field is not too small. If and only if the expiration interval is greater than zero AND smaller than one hour AND less than a notifier-configured minimum, the notifier MAY return a 423 (Interval Too Brief) error that contains a \"Min-Expires\" header field. The \"Min-Expires\" header field is described in [RFC3261].",
      "ja": "通知はまた、「有効期限」ヘッダフィールドの期間が小さすぎないことを確認すること。場合にのみ有効期間が通知設定の最小値よりゼロより大きく1より小さい時間未満である場合、「Minは、有効期限」ヘッダフィールドを含む423（間隔あまりに簡単な）エラーが返されることが通知。 「ミン期限切れ」ヘッダフィールドは、[RFC3261]に記載されています。"
    },
    {
      "indent": 3,
      "text": "Once the notifier determines that it has enough information to create the subscription (i.e., it understands the event package, the subscription pertains to a known resource, and there are no other barriers to creating the subscription), it creates the subscription and a dialog usage, and returns a 200 (OK) response.",
      "ja": "通知は、それがサブスクリプションを作成するのに十分な情報を持っていると判断したら、それはサブスクリプションおよびダイアログの使用を作成する（すなわち、それはサブスクリプションが知られているリソースに関連する、イベントパッケージを理解し、サブスクリプションを作成するには他の障壁が存在しません） 、200（OK）レスポンスを返します。"
    },
    {
      "indent": 3,
      "text": "When a subscription is created in the notifier, it stores the event package name as part of the subscription information.",
      "ja": "サブスクリプションが通知に作成されると、それは、サブスクリプション情報の一部としてイベントパッケージ名を格納します。"
    },
    {
      "indent": 3,
      "text": "The \"Expires\" values present in SUBSCRIBE 200-class responses behave in the same way as they do in REGISTER responses: the server MAY shorten the interval but MUST NOT lengthen it.",
      "ja": "サーバは間隔を短くするかもしれないが、それを長くしてはならない：値は200クラスの応答は、彼らがREGISTER応答で行うのと同じように動作SUBSCRIBEに存在する「有効期限」。"
    },
    {
      "indent": 6,
      "text": "If the duration specified in a SUBSCRIBE request is unacceptably short, the notifier may be able to send a 423 response, as described earlier in this section.",
      "ja": "SUBSCRIBEリクエストで指定された時間が許容できないほど短い場合、通知は、前にこのセクションで説明したように、423応答を送信することができるかもしれません。"
    },
    {
      "indent": 3,
      "text": "200-class responses to SUBSCRIBE requests will not generally contain any useful information beyond subscription duration; their primary purpose is to serve as a reliability mechanism. State information will be communicated via a subsequent NOTIFY request from the notifier.",
      "ja": "一般的に、サブスクリプション期間を超えた任意の有用な情報が含まれていませんSUBSCRIBE要求する200クラスの応答;彼らの主な目的は、信頼性のメカニズムとして機能することです。状態情報は、通知からの後続のNOTIFYリクエストを介して通信します。"
    },
    {
      "indent": 3,
      "text": "The other response codes defined in [RFC3261] may be used in response to SUBSCRIBE requests, as appropriate.",
      "ja": "[RFC3261]で定義された他のレスポンスコードは、必要に応じて、SUBSCRIBE要求に応答して使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.2.1.2. Confirmation of Subscription Creation/Refreshing",
      "section_title": true,
      "ja": "4.2.1.2。サブスクリプションの作成の確認/リフレッシュ"
    },
    {
      "indent": 3,
      "text": "Upon successfully accepting or refreshing a subscription, notifiers MUST send a NOTIFY request immediately to communicate the current resource state to the subscriber. This NOTIFY request is sent on the same dialog as created by the SUBSCRIBE response. If the resource has no meaningful state at the time that the SUBSCRIBE request is processed, this NOTIFY request MAY contain an empty or neutral body. See Section 4.2.2 for further details on NOTIFY request generation.",
      "ja": "成功したサブスクリプションを受け入れるか、リフレッシュ時には、届出者は、加入者に現在のリソースの状態を伝えるために、すぐにNOTIFYリクエストを送らなければなりません。このNOTIFYリクエストは、SUBSCRIBE応答によって作成されたものと同じダイアログ上で送信されます。リソースはSUBSCRIBEリクエストが処理された時点で意味のある状態を持っていない場合は、このNOTIFYリクエストは空または中性体を含むかもしれません。要求の発生をNOTIFYの詳細については、セクション4.2.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that a NOTIFY request is always sent immediately after any 200-class response to a SUBSCRIBE request, regardless of whether the subscription has already been authorized.",
      "ja": "NOTIFYリクエストは関係なく、常にサブスクリプションが既に認可されているかどうかの、SUBSCRIBEリクエストへの200クラスの応答直後に送信されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.2.1.3. Authentication/Authorization of SUBSCRIBE Requests",
      "section_title": true,
      "ja": "4.2.1.3。 SUBSCRIBE要求の認証/承認"
    },
    {
      "indent": 3,
      "text": "Privacy concerns may require that notifiers apply policy to determine whether a particular subscriber is authorized to subscribe to a certain set of events. Such policy may be defined by mechanisms such as access control lists or real-time interaction with a user. In general, authorization of subscribers prior to authentication is not particularly useful.",
      "ja": "プライバシーの懸念は、届出者は、特定の加入者がイベントの特定のセットに加入することが許可されているかどうかを判断するためにポリシーを適用することを必要とするかもしれません。そのようなポリシーは、アクセス制御リストなどの機構またはユーザとのリアルタイム相互作用によって定義されてもよいです。一般的には、認証する前に、加入者の許可は特に有用ではありません。"
    },
    {
      "indent": 3,
      "text": "SIP authentication mechanisms are discussed in [RFC3261]. Note that, even if the notifier node typically acts as a proxy, authentication for SUBSCRIBE requests will always be performed via a 401 (Unauthorized) response, not a 407 (Proxy Authentication Required). Notifiers always act as user agents when accepting subscriptions and sending notifications.",
      "ja": "SIP認証メカニズムは、[RFC3261]に記載されています。通知ノードは、典型的には、プロキシとして動作しても、なお、SUBSCRIBEリクエストの認証は、常に401（不正な）応答しない407（プロキシ認証が必要）を介して行われます。サブスクリプションを受け入れ、通知を送信するときのNotifierは、常にユーザー剤として作用します。"
    },
    {
      "indent": 6,
      "text": "Of course, when acting as a proxy, a node will perform normal proxy authentication (using 407). The foregoing explanation is a reminder that notifiers are always user agents and, as such, perform user agent authentication.",
      "ja": "プロキシとして動作する場合もちろん、ノードは、（407を使用して）通常のプロキシ認証を実行します。以上の説明は、ノーティファイアのような、ユーザエージェントの認証を行い、常にユーザーエージェントであり、ことを思い出させてくれます。"
    },
    {
      "indent": 3,
      "text": "If authorization fails based on an access list or some other automated mechanism (i.e., it can be automatically authoritatively determined that the subscriber is not authorized to subscribe), the notifier SHOULD reply to the request with a 403 (Forbidden) or 603 (Decline) response, unless doing so might reveal information that should stay private; see Section 6.2.",
      "ja": "認証は、アクセスリストまたはその他の自動化されたメカニズム（すなわち、自動的に正式加入者が加入することを許可されていないと判断することができる）に基づいて失敗した場合、通知は、403（禁止）または603（下落）で要求に応答すべきです応答、そうしない限り、プライベートとどまるべき情報を明らかにするかもしれません。 6.2節を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the notifier owner is interactively queried to determine whether a subscription is allowed, a 200 (OK) response is returned immediately. Note that a NOTIFY request is still formed and sent under these circumstances, as described in the previous section.",
      "ja": "通知の所有者が対話的にサブスクリプションが許可されているかどうかを判断するために照会されている場合は、200（OK）応答が即座に返されます。前のセクションで説明したようにNOTIFY要求は依然として、これらの状況の下で形成されて送信されることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "If subscription authorization was delayed and the notifier wishes to convey that such authorization has been declined, it may do so by sending a NOTIFY request containing a \"Subscription-State\" header field with a value of \"terminated\" and a reason parameter of \"rejected\".",
      "ja": "サブスクリプションの承認が遅れたと通知は、そのような許可が拒否されたことを伝えたいていた場合、それは「終了」の値を持つ「サブスクリプション・ステート」ヘッダフィールドと「拒否の理由パラメータを含むNOTIFYリクエストを送信することによってそれを行うことができます」。"
    },
    {
      "indent": 0,
      "text": "4.2.1.4. Refreshing of Subscriptions",
      "section_title": true,
      "ja": "4.2.1.4。サブスクリプションのリフレッシュ"
    },
    {
      "indent": 3,
      "text": "When a notifier receives a subscription refresh, assuming that the subscriber is still authorized, the notifier updates the expiration time for subscription. As with the initial subscription, the server MAY shorten the amount of time until expiration but MUST NOT increase it. The final expiration time is placed in the \"Expires\" header field in the response. If the duration specified in a SUBSCRIBE request is unacceptably short, the notifier SHOULD respond with a 423 (Interval Too Brief) response.",
      "ja": "通知は、加入者がまだ承認されていることを仮定して、サブスクリプションの更新を受信すると、通知は、サブスクリプションの有効期限を更新します。最初のサブスクリプションと同じように、サーバが満了するまでの時間を短縮することができるが、それを増やしてはなりません。最終的な有効期限を応答に「期限切れ」ヘッダフィールドに置かれます。 SUBSCRIBEリクエストで指定された期間が許容できないほど短い場合、通知は、423（間隔短すぎる）応答で応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "If no refresh for a notification address is received before its expiration time, the subscription is removed. When removing a subscription, the notifier SHOULD send a NOTIFY request with a \"Subscription-State\" value of \"terminated\" to inform it that the subscription is being removed. If such a request is sent, the \"Subscription-State\" header field SHOULD contain a \"reason=timeout\" parameter.",
      "ja": "通知アドレスのためのリフレッシュは、その有効期限の前に受信されない場合は、サブスクリプションが削除されます。サブスクリプションを削除する場合は、通知がサブスクリプションが削除されていることを知らせるために、「終了」の「サブスクリプション・ステート」の値を持つNOTIFYリクエストを送るべきです。そのような要求が送信される場合は、「サブスクリプション・ステート」ヘッダフィールドは「理由=タイムアウト」パラメータを含むべきです。"
    },
    {
      "indent": 3,
      "text": "Clients can cause a subscription to be terminated immediately by sending a SUBSCRIBE request with an \"Expires\" header field set to '0'. Notifiers largely treat this the same way as any other subscription expiration: they send a NOTIFY request containing a \"Subscription-State\" of \"terminated\", with a reason code of \"timeout.\" For consistency with state polling (see Section 4.4.3) and subscription refreshes, the notifier may choose to include resource state in this final NOTIFY request. However, in some cases, including such state makes no sense. Under such circumstances, the notifier may choose to omit state information from the terminal NOTIFY request.",
      "ja": "クライアントは、サブスクリプションが「0」に設定されている「有効期限」ヘッダフィールドを持つSUBSCRIBEリクエストを送信することにより、直ちに終了させることができます。通知機能は、主にこのに他のサブスクリプションの有効期限と同じように扱う：彼らは、「終了」の「サブスクリプション・ステート」を含むNOTIFYリクエストを送信し、理由コードで「タイムアウト。」状態ポーリング（4.4.3項を参照）、およびサブスクリプションの更新との一貫性を保つために、通知は、この最後のNOTIFYリクエストにリソース状態を含めるように選択することができます。しかし、いくつかのケースでは、このような状態を含めても意味がありません。このような状況下では、通知は、NOTIFY要求を端末から状態情報を省略することを選択することができます。"
    },
    {
      "indent": 6,
      "text": "The sending of a NOTIFY request when a subscription expires allows the corresponding dialog usage to be terminated, if appropriate.",
      "ja": "適切な場合は、サブスクリプションの有効期限が切れたときにNOTIFYリクエストの送信は、対応するダイアログの使用を終了することができます。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Sending State Information to Subscribers",
      "section_title": true,
      "ja": "4.2.2。サブスクライバに状態情報を送信します"
    },
    {
      "indent": 3,
      "text": "Notifiers use the NOTIFY method to send information about the state of a resource to subscribers. The notifier's view of a subscription is shown in the following state diagram. Events that result in a transition back to the same state are not represented in this diagram.",
      "ja": "通知機能は、加入者に、リソースの状態に関する情報を送信するためにNOTIFYメソッドを使用します。サブスクリプションの通知のビューは、次の状態図に示されています。バック同じ状態への遷移をもたらすイベントが、この図には示されません。"
    },
    {
      "indent": 6,
      "text": "                   +-------------+\n                   |    init     |\n                   +-------------+\n                          |\n                    Receive SUBSCRIBE,\n                    Send NOTIFY\n                          |\n                          V          NOTIFY failure,\n                   +-------------+   subscription expires,\n      +------------|  resp_wait  |-- or terminated ----+\n      |            +-------------+   per local policy  |\n      |                   |                            |\n      |                   |                            |\n      |                   |                            V\nPolicy grants       Policy needed              +-------------+\npermission                |                    | terminated  |\n      |                   |                    +-------------+\n      |                   |                               A A\n      |                   V          NOTIFY failure,      | |\n      |            +-------------+   subscription expires,| |\n      |            |   pending   |-- or terminated -------+ |\n      |            +-------------+   per local policy       |\n      |                   |                                 |\n      |            Policy changed to                        |\n      |            grant permission                         |\n      |                   |                                 |\n      |                   V          NOTIFY failure,        |\n      |            +-------------+   subscription expires,  |\n      +----------->|   active    |-- or terminated ---------+\n                   +-------------+   per local policy",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When a SUBSCRIBE request is answered with a 200-class response, the notifier MUST immediately construct and send a NOTIFY request to the subscriber. When a change in the subscribed state occurs, the notifier SHOULD immediately construct and send a NOTIFY request, unless the state transition is caused by a NOTIFY transaction failure. The sending of this NOTIFY message is also subject to authorization, local policy, and throttling considerations.",
      "ja": "SUBSCRIBEリクエストが200クラスの応答と回答された場合、通知はすぐに構築し、加入者にNOTIFYリクエストを送らなければなりません。加入状態の変化が発生した場合、通知はすぐに構築すべきであり、状態遷移は、NOTIFYトランザクション障害によって引き起こされていない限り、NOTIFYリクエストを送信します。このNOTIFYメッセージの送信も、認可、ローカルポリシー、およびスロットリングの考慮の対象となります。"
    },
    {
      "indent": 3,
      "text": "If the NOTIFY request fails due to expiration of SIP Timer F (transaction timeout), the notifier SHOULD remove the subscription.",
      "ja": "NOTIFYリクエストは、SIPタイマーF（トランザクションタイムアウト）の満了のために失敗した場合、通知は、サブスクリプションを削除する必要があります。"
    },
    {
      "indent": 6,
      "text": "This behavior prevents unnecessary transmission of state information for subscribers who have crashed or disappeared from the network. Because such transmissions will be sent multiple times, per the retransmission algorithm defined in [RFC3261] (instead of the typical single transmission for functioning clients), continuing to service them when no client is available to acknowledge them could place undue strain on a network. Upon client restart or reestablishment of a network connection, it is expected that clients will send SUBSCRIBE requests to refresh potentially stale state information; such requests will reinstall subscriptions in all relevant nodes.",
      "ja": "この動作は、クラッシュしたり、ネットワークから消えている加入者の状態情報の不必要な送信を防ぐことができます。このような変速機が複数回送信されますので、（代わりにクライアントを機能させるための典型的な単一の送信の）[RFC3261]で定義された再送アルゴリズムごとに、どのクライアントがそれらを認識するために利用されていないときにそれらにサービスを提供するために継続することで、ネットワークに過度の負担をかけることができます。クライアントの再起動やネットワーク接続の再確立されると、クライアントが潜在的に古い状態情報を更新するためにリクエストを送信購読することが期待されます。そのような要求は、関連するすべてのノードでのサブスクリプションを再インストールします。"
    },
    {
      "indent": 3,
      "text": "If the NOTIFY transaction fails due to the receipt of a 404, 405, 410, 416, 480-485, 489, 501, or 604 response to the NOTIFY request, the notifier MUST remove the corresponding subscription. See [RFC5057] for further details and notes about the effect of error codes on dialogs and usages within dialog (such as subscriptions).",
      "ja": "NOTIFYトランザクションが原因404、405、410、416、480から485、489、501、またはNOTIFYリクエストに対する604応答の受信に失敗した場合、通知は、対応するサブスクリプションを削除する必要があります。 （例えば、サブスクリプションなど）ダイアログ内のダイアログと用途にエラーコードの効果についてのさらなる詳細および注意事項については、[RFC5057]を参照。"
    },
    {
      "indent": 6,
      "text": "A notify error response would generally indicate that something has gone wrong with the subscriber or with some proxy on the way to the subscriber. If the subscriber is in error, it makes the most sense to allow the subscriber to rectify the situation (by re-subscribing) once the error condition has been handled. If a proxy is in error, the periodic sending of SUBSCRIBE requests to refresh the expiration timer will reinstall subscription state once the network problem has been resolved.",
      "ja": "通知エラー応答は、一般的に何かが加入者または加入者に途中でいくつかのプロキシと間違っていることを示します。加入者が誤りである場合には、エラー条件が処理された後、加入者が（再加入することによって）状況を是正することを可能にするために、最も理にかなっています。プロキシがエラーになっている場合、ネットワークの問題が解決された後、期限タイマーをリフレッシュするSUBSCRIBEリクエストの送信を定期的には、サブスクリプションの状態を再インストールします。"
    },
    {
      "indent": 3,
      "text": "NOTIFY requests MUST contain a \"Subscription-State\" header field with a value of \"active\", \"pending\", or \"terminated\". The \"active\" value indicates that the subscription has been accepted and has been authorized (in most cases; see Section 6.2). The \"pending\" value indicates that the subscription has been received, but that policy information is insufficient to accept or deny the subscription at this time. The \"terminated\" value indicates that the subscription is not active.",
      "ja": "要求は、「保留」「アクティブ」、または「終了」の値を「サブスクリプション・ステート」ヘッダフィールドを含まなければならないNOTIFY。 「アクティブ」の値は、サブスクリプションが受け入れられていると（;セクション6.2を参照してくださいほとんどの場合）許可されたことを示しています。 「保留中」の値は、サブスクリプションが受信されたことを示しているが、そのポリシー情報は、この時点でサブスクリプションを受け入れるか拒否するには不十分です。 「終了」の値は、サブスクリプションがアクティブでないことを示しています。"
    },
    {
      "indent": 3,
      "text": "If the value of the \"Subscription-State\" header field is \"active\" or \"pending\", the notifier MUST also include in the \"Subscription-State\" header field an \"expires\" parameter that indicates the time remaining on the subscription. The notifier MAY use this mechanism to shorten a subscription; however, this mechanism MUST NOT be used to lengthen a subscription.",
      "ja": "「サブスクリプション状態」ヘッダフィールドの値が「アクティブ」または「保留中」である場合、通知は、「サブスクリプション状態」ヘッダフィールドにサブスクリプションの残り時間を示す「満了する」パラメータを含まなければなりません。通知は、サブスクリプションを短縮するために、このメカニズムを使用することができます。しかし、このメカニズムは、サブスクリプションを長くするために使用してはいけません。"
    },
    {
      "indent": 6,
      "text": "Including expiration information for active and pending subscriptions is necessary in case the SUBSCRIBE request forks, since the response to a forked SUBSCRIBE request may not be received by the subscriber. [RFC3265] allowed the notifier some discretion in the inclusion of this parameter, so subscriber implementations are warned to handle the lack of an \"expires\" parameter gracefully. Note well that this \"expires\" value is a parameter on the \"Subscription-State\" header field NOT the \"Expires\" header field.",
      "ja": "SUBSCRIBE二股要求に対する応答が加入者によって受信されなくてもよいので、アクティブおよび保留中のサブスクリプションを含む有効期限情報は、場合に要求フォークをSUBSCRIBE必要です。加入者実装が正常に「満了する」パラメータの欠如を処理するように警告されるように[RFC3265]は、通知にこのパラメータを含めることで、いくつかの判断を可能にしました。この値は、「サブスクリプション・ステート」ヘッダフィールドNOT「有効期限」ヘッダフィールドのパラメータである「期限が切れる」ことにも注意してください。"
    },
    {
      "indent": 6,
      "text": "The period of time for a subscription can be shortened to zero by the notifier. In other words, it is perfectly valid for a SUBSCRIBE request with a non-zero expires to be answered with a NOTIFY request that contains \"Subscription-Status: terminated;reason=expired\". This merely means that the notifier has shortened the subscription timeout to zero, and the subscription has expired instantaneously. The body may contain valid state, or it may contain a neutral state (see Section 5.4.7).",
      "ja": "サブスクリプションの期間は、通知によってゼロに短縮することができます。言い換えれば、それは非ゼロのSUBSCRIBEリクエストに対して完全に有効であることは含まれていNOTIFYリクエストに答えられるために有効期限が切れる「サブスクリプション・ステータス：終了;理由=期限切れ」。これは単なる通知がゼロにサブスクリプションタイムアウトを短くしたことを意味し、サブスクリプションが瞬時に有効期限が切れています。体が有効な状態を含むことができ、またはそれは中立状態を（第5.4.7項を参照）が含まれていてもよいです。"
    },
    {
      "indent": 3,
      "text": "If the value of the \"Subscription-State\" header field is \"terminated\", the notifier SHOULD also include a \"reason\" parameter. The notifier MAY also include a \"retry-after\" parameter, where appropriate. For details on the value and semantics of the \"reason\" and \"retry-after\" parameters, see Section 4.1.3.",
      "ja": "「サブスクリプション・ステート」ヘッダフィールドの値が「終了」した場合、通知は「理由」パラメータを含めるべきです。通知はまた、適切な「リトライ-後に」パラメータを含むことができます。値の詳細と「理由」の意味と「リトライ・後」のパラメータについては、4.1.3項を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2.3. PSTN/Internet Interworking (PINT) Compatibility",
      "section_title": true,
      "ja": "4.2.3。 PSTN /インターネットインターワーキング（PINT）の互換性"
    },
    {
      "indent": 3,
      "text": "The \"Event\" header field is considered mandatory for the purposes of this document. However, to maintain compatibility with PINT (see [RFC2848]), notifiers MAY interpret a SUBSCRIBE request with no \"Event\" header field as requesting a subscription to PINT events. If a notifier does not support PINT, it SHOULD return 489 (Bad Event) to any SUBSCRIBE requests without an \"Event\" header field.",
      "ja": "「イベント」ヘッダフィールドは、この文書の目的のために必須と考えられています。しかしながら、PINTとの互換性を維持するために、通知機能がイベントをPINTへのサブスクリプションを要求するようになし「イベント」ヘッダフィールドにSUBSCRIBEリクエストを解釈してもよい（[RFC2848]を参照）。通知はPINTをサポートしていない場合、それは「イベント」ヘッダフィールドなしにはSUBSCRIBEリクエストに489（不良イベント）を返すべきです。"
    },
    {
      "indent": 0,
      "text": "4.3. Proxy Behavior",
      "section_title": true,
      "ja": "4.3。プロキシの挙動"
    },
    {
      "indent": 3,
      "text": "Proxies need no additional behavior beyond that described in [RFC3261] to support SUBSCRIBE and NOTIFY transactions. If a proxy wishes to see all of the SUBSCRIBE and NOTIFY requests for a given dialog, it MUST add a \"Record-Route\" header field to the initial SUBSCRIBE request and all NOTIFY requests. It MAY choose to include \"Record-Route\" in subsequent SUBSCRIBE requests; however, these requests cannot cause the dialog's route set to be modified.",
      "ja": "プロキシは、SUBSCRIBEとNOTIFYトランザクションをサポートするために、[RFC3261]に記載されているもの以外の追加の動作を必要としません。プロキシが与えられたダイアログのSUBSCRIBEとNOTIFYリクエストのすべてを見たい場合は、それが初期に「レコード-Route」ヘッダフィールドを追加しなければならない要求と、すべてがNOTIFY要求SUBSCRIBE。それは、その後のSUBSCRIBEリクエストで「レコード・ルート」を含めるのを選ぶかもしれ。しかし、これらの要求は、ダイアログのルートセットを変更させることができません。"
    },
    {
      "indent": 3,
      "text": "Proxies that did not add a \"Record-Route\" header field to the initial SUBSCRIBE request MUST NOT add a \"Record-Route\" header field to any of the associated NOTIFY requests.",
      "ja": "初期に「レコード-Route」ヘッダフィールドを追加しませんでしたプロキシは、要求が関連するNOTIFYリクエストのいずれかに「レコード-Route」ヘッダフィールドを追加してはならないSUBSCRIBE。"
    },
    {
      "indent": 6,
      "text": "Note that subscribers and notifiers may elect to use Secure/ Multipurpose Internet Mail Extensions (S/MIME) encryption of SUBSCRIBE and NOTIFY requests; consequently, proxies cannot rely on being able to access any information that is not explicitly required to be proxy-readable by [RFC3261].",
      "ja": "加入者とノーティファイアはSUBSCRIBEとNOTIFYリクエストのセキュア/多目的インターネットメール拡張（S / MIME）暗号化を使用するように選択するかもしれないことに注意してください。その結果、プロキシが明示的に[RFC3261]でプロキシ可読である必要はなく、任意の情報にアクセスできることに依存することはできません。"
    },
    {
      "indent": 0,
      "text": "4.4. Common Behavior",
      "section_title": true,
      "ja": "4.4。共通の動作"
    },
    {
      "indent": 0,
      "text": "4.4.1. Dialog Creation and Termination",
      "section_title": true,
      "ja": "4.4.1。ダイアログの作成と終了"
    },
    {
      "indent": 3,
      "text": "Dialogs usages are created upon completion of a NOTIFY transaction for a new subscription, unless the NOTIFY request contains a \"Subscription-State\" of \"terminated.\"",
      "ja": "NOTIFYリクエストはの「サブスクリプション・ステート」が含まれていない限り、ダイアログの使用法は、新しいサブスクリプションのためにNOTIFYトランザクションの完了時に作成される「終了」を"
    },
    {
      "indent": 3,
      "text": "Because the dialog usage is established by the NOTIFY request, the route set at the subscriber is taken from the NOTIFY request itself, as opposed to the route set present in the 200-class response to the SUBSCRIBE request.",
      "ja": "ダイアログ使用がNOTIFYリクエストによって確立されているので、SUBSCRIBEリクエストに対する200クラス応答では、本設定された経路とは対照的に、加入者に設定された経路は、NOTIFY要求自体から取られます。"
    },
    {
      "indent": 3,
      "text": "NOTIFY requests are matched to such SUBSCRIBE requests if they contain the same \"Call-ID\", a \"To\" header field \"tag\" parameter that matches the \"From\" header field \"tag\" parameter of the SUBSCRIBE request, and the same \"Event\" header field. Rules for comparisons of the \"Event\" header fields are described in Section 8.2.1.",
      "ja": "彼らはSUBSCRIBEリクエストのヘッダフィールドの「From」「タグ」パラメータ、および同じ」と一致し、同じ「コールIDを」、「へ」ヘッダフィールド「タグ」のパラメータが含まれている場合、要求は、このようなSUBSCRIBE要求に適合しているNOTIFYイベント」ヘッダフィールド。 「イベント」ヘッダフィールドの比較のための規則は、8.2.1項で説明されています。"
    },
    {
      "indent": 3,
      "text": "A subscription is destroyed after a notifier sends a NOTIFY request with a \"Subscription-State\" of \"terminated\", or in certain error situations described elsewhere in this document. The subscriber will generally answer such final requests with a 200 (OK) response (unless a condition warranting an alternate response has arisen). Except when the mechanism described in Section 4.5.2 is used, the destruction of a subscription results in the termination of its associated dialog.",
      "ja": "通知は、「終了」、または本文書内の別の場所に記載される特定のエラー状況での「サブスクリプション・ステート」とNOTIFYリクエストを送信した後、サブスクリプションは破棄されます。加入者は、一般的に200（OK）レスポンス（代替応答を保証する条件が発生した場合を除く）を有するような最終的な要求に答えます。 4.5.2項で説明したメカニズムが使用されている場合を除き、それに関連するダイアログの終了で購読結果の破壊。"
    },
    {
      "indent": 6,
      "text": "A subscriber may send a SUBSCRIBE request with an \"Expires\" header field of 0 in order to trigger the sending of such a NOTIFY request; however, for the purposes of subscription and dialog lifetime, the subscription is not considered terminated until the NOTIFY transaction with a \"Subscription-State\" of \"terminated\" completes.",
      "ja": "加入者は、NOTIFY要求の送信をトリガするために0のヘッダフィールドを「有効期限」とSUBSCRIBEリクエストを送信することができます。ただし、サブスクリプション、ダイアログ寿命の目的のために、サブスクリプションは、「終了」完了の「サブスクリプション・ステート」とNOTIFYトランザクションまで終了したと見なされていません。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Notifier Migration",
      "section_title": true,
      "ja": "4.4.2。移行を通知"
    },
    {
      "indent": 3,
      "text": "It is often useful to allow migration of subscriptions between notifiers. Such migration may be effected by sending a NOTIFY request with a \"Subscription-State\" header field of \"terminated\" and a reason parameter of \"deactivated\". This NOTIFY request is otherwise normal and is formed as described in Section 4.2.2.",
      "ja": "ノーティファイアの間にサブスクリプションの移行を可能にするために便利です。そのような移動は、「終了」の「サブスクリプション状態」ヘッダフィールドと「非アクティブ」の理由パラメータとNOTIFYリクエストを送信することによって行うことができます。このNOTIFYリクエストは、そうでなければ正常であり、セクション4.2.2に記載したように形成されています。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of this NOTIFY request, the subscriber SHOULD attempt to re-subscribe (as described in the preceding sections). Note that this subscription is established on a new dialog, and does not reuse the route set from the previous subscription dialog.",
      "ja": "このNOTIFYリクエストを受信すると、加入者は、（前のセクションで説明したように）再加入を試みます。このサブスクリプションは、新しいダイアログ上で確立され、以前のサブスクリプションのダイアログから設定した経路を再利用しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The actual migration is effected by making a change to the policy (such as routing decisions) of one or more servers to which the SUBSCRIBE request will be sent in such a way that a different node ends up responding to the SUBSCRIBE request. This may be as simple as a change in the local policy in the notifier from which the subscription is migrating so that it serves as a proxy or redirect server instead of a notifier.",
      "ja": "実際の移行は、そのSUBSCRIBEリクエストが異なるノードがSUBSCRIBE要求に応答してしまうような方法で送信される1台のまたは複数のサーバ（例えば、ルーティングの決定など）ポリシーに変更を加えることによって行われます。これは、プロキシとして機能又は代わり通知をサーバにリダイレクトするようにサブスクリプションが移行された通知にローカルポリシーの変更のように単純であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Whether, when, and why to perform notifier migrations may be described in individual event packages; otherwise, such decisions are a matter of local notifier policy and are left up to individual implementations.",
      "ja": "個々のイベントパッケージに記載されてもよい、と理由通知の移行を実行するかどうか、。そうでない場合は、そのような決定は、ローカル通知ポリシーの問題であり、個々の実装に一任されています。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Polling Resource State",
      "section_title": true,
      "ja": "4.4.3。ポーリングリソースの状態"
    },
    {
      "indent": 3,
      "text": "A natural consequence of the behavior described in the preceding sections is that an immediate fetch without a persistent subscription may be effected by sending a SUBSCRIBE with an \"Expires\" of 0.",
      "ja": "前のセクションに記載された動作の自然な結果は、即時0の「有効期限」とSUBSCRIBE送信することによって行うことができる永続的な加入せずにフェッチすることです。"
    },
    {
      "indent": 3,
      "text": "Of course, an immediate fetch while a subscription is active may be effected by sending a SUBSCRIBE request with an \"Expires\" equal to the number of seconds remaining in the subscription.",
      "ja": "もちろん、サブスクリプションがアクティブである間フェッチ即時は、サブスクリプション内の残りの秒数と等しい「有効期限」とSUBSCRIBEリクエストを送信することによって行うことができます。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of this SUBSCRIBE request, the notifier (or notifiers, if the SUBSCRIBE request was forked) will send a NOTIFY request containing resource state in the same dialog.",
      "ja": "このSUBSCRIBEリクエストを受信し、通知すると（又は通知機能、SUBSCRIBEリクエストがフォークされた場合）、同じダイアログでリソースの状態を含むNOTIFYリクエストを送信します。"
    },
    {
      "indent": 3,
      "text": "Note that the NOTIFY requests triggered by SUBSCRIBE requests with \"Expires\" header fields of 0 will contain a \"Subscription-State\" value of \"terminated\" and a \"reason\" parameter of \"timeout\".",
      "ja": "「終了」の「サブスクリプション・ステート」値と「タイムアウト」の「理由」パラメータが含まれています0のヘッダフィールド「有効期限」とSUBSCRIBEリクエストによってトリガNOTIFYリクエストをすることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Polling of event state can cause significant increases in load on the network and notifiers; as such, it should be used only sparingly. In particular, polling SHOULD NOT be used in circumstances in which it will typically result in more network messages than long-running subscriptions.",
      "ja": "イベント状態のポーリングは、ネットワークとノーティファイアへの負荷の大幅な増加を引き起こす可能性があります。など、それだけで慎重に使用する必要があります。特に、ポーリングが状況で使用すべきでないことは、一般的に長時間実行するサブスクリプションよりも多くのネットワークメッセージになります。"
    },
    {
      "indent": 3,
      "text": "When polling is used, subscribers SHOULD attempt to cache authentication credentials between polls so as to reduce the number of messages sent.",
      "ja": "ポーリングを使用する場合、加入者は、送信されたメッセージの数を低減するようにポーリング間の認証資格情報をキャッシュすることを試みるべきです。"
    },
    {
      "indent": 6,
      "text": "Due to the requirement on notifiers to send a NOTIFY request immediately upon receipt of a SUBSCRIBE request, the state provided by polling is limited to the information that the notifier has immediate local access to when it receives the SUBSCRIBE request. If, for example, the notifier generally needs to retrieve state from another network server, then that state will be absent from the NOTIFY request that results from polling.",
      "ja": "届出者の要求にSUBSCRIBEリクエストを受信したときに、すぐにNOTIFYリクエストを送信するために、ポーリングにより提供される状態が通知は、それがSUBSCRIBEリクエストを受信したときにすぐにローカルアクセスを持っていることの情報に限定されています。例えば、通知は一般的に別のネットワークサーバーから状態を取得する必要がある場合、その状態をポーリングした結果NOTIFYリクエストを欠席となります。"
    },
    {
      "indent": 0,
      "text": "4.4.4. \"Allow-Events\" Header Field Usage",
      "section_title": true,
      "ja": "4.4.4。 「許可 - イベント」ヘッダーフィールドの使用方法"
    },
    {
      "indent": 3,
      "text": "The \"Allow-Events\" header field, if present, MUST include a comprehensive and inclusive list of tokens that indicates the event packages for which the user agent can act as a notifier. In other words, a user agent sending an \"Allow-Events\" header field is advertising that it can process SUBSCRIBE requests and generate NOTIFY requests for all of the event packages listed in that header field.",
      "ja": "「許可 - イベント」ヘッダフィールドは、存在する場合、ユーザーエージェントは、通知としての役割を果たすことができたイベントパッケージを示しトークンの包括的かつ包括的なリストを含まなければなりません。言い換えれば、「許可 - イベント」ヘッダフィールドを送信するユーザエージェントは、それが処理SUBSCRIBE要求し、そのヘッダフィールドにリストされているイベントパッケージのすべてのためのNOTIFYリクエストを生成できることを広告しています。"
    },
    {
      "indent": 3,
      "text": "Any user agent that can act as a notifier for one or more event packages SHOULD include an appropriate \"Allow-Events\" header field indicating all supported events in all methods which initiate dialogs and their responses (such as INVITE) and OPTIONS responses.",
      "ja": "1つ以上のイベントパッケージの通知として作用することができる任意のユーザエージェントは、ダイアログと（例えばINVITEなど）、それらの応答とOPTIONSの応答を開始するすべての方法でサポートされているすべてのイベントを示す適切な「許可・イベント」ヘッダフィールドを含むべきです。"
    },
    {
      "indent": 6,
      "text": "This information is very useful, for example, in allowing user agents to render particular interface elements appropriately according to whether the events required to implement the features they represent are supported by the appropriate nodes.",
      "ja": "この情報は、ユーザエージェントはそれが表す機能を実装するために必要なイベントを適切なノードによってサポートされているかどうかに応じて、適宜特定のインターフェース要素をレンダリングすることができ、例えば、非常に有用です。"
    },
    {
      "indent": 6,
      "text": "On the other hand, it doesn't necessarily make much sense to indicate supported events inside a dialog established by a NOTIFY request if the only event package supported is the one associated with that subscription.",
      "ja": "一方、それは必ずしもサポートされる唯一のイベントパッケージは、そのサブスクリプションに関連付けられているものであればNOTIFYリクエストによって確立されたダイアログ内のサポートされているイベントを示すために、あまり意味がありません。"
    },
    {
      "indent": 3,
      "text": "Note that \"Allow-Events\" header fields MUST NOT be inserted by proxies.",
      "ja": "「許可 - イベント」ヘッダフィールドは、プロキシが挿入されてはならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The \"Allow-Events\" header field does not include a list of the event template-packages supported by an implementation. If a subscriber wishes to determine which event template-packages are supported by a notifier, it can probe for such support by attempting to subscribe to the event template-packages it wishes to use.",
      "ja": "「許可 - イベント」ヘッダフィールドは、実装によってサポートされているイベントテンプレートパッケージのリストが含まれていません。加入者がテンプレートパッケージは通知によってサポートされているイベントを決定することを希望する場合は、それが使用することを希望するイベントテンプレートパッケージに加入しようとすることによって、そのようなサポートのために調べることができます。"
    },
    {
      "indent": 6,
      "text": "For example: to check for support for the templatized package \"presence.winfo\", a client may attempt to subscribe to that event package for a known resource, using an \"Expires\" header value of 0. If the response is a 489 error code, then the client can deduce that \"presence.winfo\" is unsupported.",
      "ja": "たとえば、次のテンプレート化パッケージ「presence.winfo」のサポートを確認するために、クライアントは、応答が489エラーコードである場合は0のヘッダの値を「有効期限」を用いて、既知のリソースのそのイベントパッケージに加入しようと試みることができます、クライアントは「presence.winfo」はサポートされていないことを推測することができます。"
    },
    {
      "indent": 0,
      "text": "4.5. Targeting Subscriptions at Devices",
      "section_title": true,
      "ja": "4.5。デバイスのサブスクリプションをターゲット"
    },
    {
      "indent": 3,
      "text": "[RFC3265] defined a mechanism by which subscriptions could share dialogs with invite usages and with other subscriptions. The purpose of this behavior was to allow subscribers to ensure that a subscription arrived at the same device as an established dialog. Unfortunately, the reuse of dialogs has proven to be exceedingly confusing. [RFC5057] attempted to clarify proper behavior in a",
      "ja": "[RFC3265]はサブスクリプションが招待用法とし、他のサブスクリプションとのダイアログを共有する可能性があるメカニズムを定義しました。この動作の目的は、加入者は、サブスクリプションを確立し、ダイアログと同じデバイスに到着していることを確認できるようにすることでした。残念ながら、ダイアログの再利用が非常に混乱することが証明されています。 [RFC5057]はで適切な行動を明確にしようとしました"
    },
    {
      "indent": 3,
      "text": "variety of circumstances; however, the ensuing rules remain confusing and prone to implementation error. At the same time, the mechanism described in [RFC5627] now provides a far more elegant and unambiguous means to achieve the same goal.",
      "ja": "様々な状況。しかし、その後のルールは紛らわしいと実装エラーを起こしやすいまま。同時に、[RFC5627]で説明したメカニズムは今、同じ目標を達成するためにはるかにエレガントで明確な手段を提供します。"
    },
    {
      "indent": 3,
      "text": "Consequently, the dialog reuse technique described in RFC 3265 is now deprecated.",
      "ja": "その結果、RFC 3265に記述ダイアログ再利用技術が廃止されます。"
    },
    {
      "indent": 3,
      "text": "This dialog-sharing technique has also historically been used as a means for targeting an event package at a dialog. This usage can be seen, for example, in certain applications of the REFER method [RFC3515]. With the removal of dialog reuse, an alternate (and more explicit) means of targeting dialogs needs to be used for this type of correlation. The appropriate means of such targeting is left up to the actual event packages. Candidates include the \"Target-Dialog\" header field [RFC4538], the \"Join\" header field [RFC3911], and the \"Replaces\" header field [RFC3891], depending on the semantics desired. Alternately, if the semantics of those header fields do not match the event package's purpose for correlation, event packages can devise their own means of identifying dialogs. For an example of this approach, see the Dialog Event Package [RFC4235].",
      "ja": "このダイアログ・共有技術はまた、歴史的に、ダイアログでイベントパッケージを標的とするための手段として使用されてきました。この用法は、REFERメソッド[RFC3515]の特定の用途において、例えば、見ることができます。ダイアログリユースの除去、代替の（より明示的）でダイアログを標的化する手段は、相関のこのタイプのために使用される必要があります。そのようなターゲティングの適切な手段は、実際のイベントパッケージに任されています。候補は、「ターゲット・ダイアログ」ヘッダフィールド[RFC4538]、「参加」ヘッダフィールド[RFC3911]を含む、所望のセマンティクスに依存して、ヘッダフィールド[RFC3891]を「置き換え」。これらのヘッダフィールドのセマンティクスは、相関のためのイベントパッケージの目的と一致しない場合は別の方法として、イベントパッケージは、ダイアログを特定の独自の手段を考案することができます。このアプローチの例については、ダイアログイベントパッケージ[RFC4235]を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.5.1. Using GRUUs to Route to Devices",
      "section_title": true,
      "ja": "4.5.1。デバイスへのルートにGRUUsを使用して"
    },
    {
      "indent": 3,
      "text": "Notifiers MUST implement the Globally Routable User Agent URI (GRUU) extension defined in [RFC5627], and MUST use a GRUU as their local target. This allows subscribers to explicitly target desired devices.",
      "ja": "通知機能は、[RFC5627]で定義されたグローバルにルーティング可能なユーザエージェントURI（GRUU）拡張を実装しなければならない、と彼らのローカルターゲットとしてGRUUを使用しなければなりません。これは、加入者が明示的に必要なデバイスをターゲットとすることができます。"
    },
    {
      "indent": 3,
      "text": "If a subscriber wishes to subscribe to a resource on the same device as an established dialog, it should check whether the remote contact in that dialog is a GRUU (i.e., whether it contains a \"gr\" URI parameter). If so, the subscriber creates a new dialog, using the GRUU as the Request URI for the new SUBSCRIBE request.",
      "ja": "加入者が確立ダイアログと同じデバイス上のリソースにサブスクライブしたい場合、そのダイアログ内の遠隔接触は（それは「GR」URIパラメータが含まれているかどうか、すなわち、）GRUUであるか否かを確認しなければなりません。その場合、加入者は新しいSUBSCRIBEリクエストのリクエストURIとしてGRUUを使用して、新しいダイアログを作成します。"
    },
    {
      "indent": 6,
      "text": "Because GRUUs are guaranteed to route to a specific device, this ensures that the subscription will be routed to the same place as the established dialog.",
      "ja": "GRUUsが特定のデバイスにルーティングすることが保証されているので、これは、サブスクリプションを確立し、ダイアログと同じ場所にルーティングされるようになります。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Sharing Dialogs",
      "section_title": true,
      "ja": "4.5.2。共有ダイアログ"
    },
    {
      "indent": 3,
      "text": "For compatibility with older clients, subscriber and notifier implementations may choose to allow dialog sharing. The behavior of multiple usages within a dialog are described in [RFC5057].",
      "ja": "古いクライアントとの互換性のために、加入者および通知の実装は、ダイアログの共有を許可することもできます。ダイアログ内の複数の用途の挙動は、[RFC5057]に記載されています。"
    },
    {
      "indent": 3,
      "text": "Subscribers MUST NOT attempt to reuse dialogs whose remote target is a GRUU.",
      "ja": "加入者は、そのリモートターゲットGRUUでダイアログを再利用することを試みてはいけません。"
    },
    {
      "indent": 6,
      "text": "Note that the techniques described in this section are included for backwards-compatibility purposes only. Because subscribers cannot reuse dialogs with a GRUU for their remote target, and because notifiers must use GRUUs as their local target, any two implementations that conform to this specification will automatically use the mechanism described in Section 4.5.1.",
      "ja": "このセクションで説明する技術は、下位互換性の目的のみのために含まれていることに留意されたいです。加入者がリモートターゲットのGRUUとダイアログを再利用することはできませんし、届出者が地元のターゲットとしてGRUUsを使用する必要があるため、この仕様に準拠する任意の2つの実装が自動的に4.5.1項で説明したメカニズムを使用しますので。"
    },
    {
      "indent": 6,
      "text": "Further note that the prohibition on reusing dialogs does not exempt implicit subscriptions created by the REFER method. This means that implementations complying with this specification are required to use the \"Target-Dialog\" mechanism described in [RFC4538] when the remote target is a GRUU.",
      "ja": "また、再利用のダイアログ上の禁止がREFERメソッドによって作成された暗黙のサブスクリプションを免除しないことに注意してください。これは、この仕様に準拠した実装では、リモートターゲットがGRUUは[RFC4538]に記載された「ターゲット・ダイアログ」メカニズムを使用する必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "If a subscriber wishes to subscribe to a resource on the same device as an established dialog and the remote contact is not a GRUU, it MAY revert to dialog-sharing behavior. Alternately, it MAY choose to treat the remote party as incapable of servicing the subscription (i.e., the same way it would behave if the remote party did not support SIP events at all).",
      "ja": "加入者が確立し、ダイアログと同じデバイス上のリソースに加入することを希望すると、リモートの接触がGRUUない場合は、ダイアログ共有動作に戻ることがあります。代わりに、それはサブスクリプションにサービスを提供する相手ができないように処理することを選ぶかもしれ（すなわち、相手が全くSIPイベントをサポートしていない場合、それが振る舞うと同じ方法）。"
    },
    {
      "indent": 3,
      "text": "If a notifier receives a SUBSCRIBE request for a new subscription on an existing dialog, it MAY choose to implement dialog sharing behavior. Alternately, it may choose to fail the SUBSCRIBE request with a 403 (Forbidden) response. The error text of such 403 responses SHOULD indicate that dialog sharing is not supported.",
      "ja": "通知は、既存のダイアログに新しいサブスクリプション用のSUBSCRIBEリクエストを受信した場合には、ダイアログの共有の動作を実装することを選択できます。代わりに、それは403（禁止）応答でSUBSCRIBEリクエストに失敗することもできます。そのような403の応答のエラーテキストは、ダイアログの共有がサポートされていないことを示す必要があります。"
    },
    {
      "indent": 3,
      "text": "To implement dialog sharing, subscribers and notifiers perform the following additional processing:",
      "ja": "ダイアログの共有を実現するために、加入者及び届出者は、次の追加処理を実行します。"
    },
    {
      "indent": 3,
      "text": "o When subscriptions exist in dialogs associated with INVITE-created application state and/or other subscriptions, these sets of application state do not interact beyond the behavior described for a dialog (e.g., route set handling). In particular, multiple subscriptions within a dialog expire independently and require independent subscription refreshes.",
      "ja": "サブスクリプションは、INVITEが作成したアプリケーションの状態及び/又は他のサブスクリプションに関連付けられたダイアログに存在する場合にO、アプリケーションの状態のこれらのセットは、ダイアログ（例えば、ルートセット処理）のために記載された動作を越えて相互作用しません。特に、ダイアログ内の複数のサブスクリプションは、独立して有効期限が切れると、独立したサブスクリプションの更新が必要です。"
    },
    {
      "indent": 3,
      "text": "o If a subscription's destruction leaves no other application state associated with the dialog, the dialog terminates. The destruction of other application state (such as that created by an INVITE) will not terminate the dialog if a subscription is still associated with that dialog. This means that, when dialogs are reused, a dialog created with an INVITE does not necessarily terminate upon receipt of a BYE. Similarly, in the case that several subscriptions are associated with a single dialog, the dialog does not terminate until all the subscriptions in it are destroyed.",
      "ja": "サブスクリプションの破壊は、ダイアログに関連した他のアプリケーションの状態を残さない場合は、O、ダイアログが終了します。サブスクリプションがまだそのダイアログに関連付けられている場合（例えば、INVITEによって作成されたもののような）他のアプリケーション状態の破壊は、ダイアログを終了しないであろう。これは、ダイアログが再利用されている場合、INVITEで作成したダイアログが必ずしもBYEの受信時に終了しない、ということを意味します。その中のすべてのサブスクリプションが破壊されるまで同様に、いくつかのサブスクリプションは、単一のダイアログに関連付けられている場合には、ダイアログは終了しません。"
    },
    {
      "indent": 3,
      "text": "o Subscribers MAY include an \"id\" parameter in a SUBSCRIBE request's \"Event\" header field to allow differentiation between multiple subscriptions in the same dialog. This \"id\" parameter, if present, contains an opaque token that identifies the specific subscription within a dialog. An \"id\" parameter is only valid within the scope of a single dialog.",
      "ja": "O加入者は、同じダイアログで複数のサブスクリプションの区別を可能にするために、SUBSCRIBEリクエストの「イベント」ヘッダフィールドに「ID」パラメータを含むかもしれません。この「ID」パラメータは、存在する場合、ダイアログ内の特定のサブスクリプションを識別し、不透明なトークンが含まれています。 「ID」パラメータは、単一の対話の範囲内でのみ有効です。"
    },
    {
      "indent": 3,
      "text": "o If an \"id\" parameter is present in the SUBSCRIBE request used to establish a subscription, that \"id\" parameter MUST also be present in all corresponding NOTIFY requests.",
      "ja": "「ID」パラメータが「ID」のパラメータは、すべての要求をNOTIFY対応に存在しなければならないこと、サブスクリプションを確立するために使用されるSUBSCRIBEリクエストに存在する場合、O。"
    },
    {
      "indent": 3,
      "text": "o When a subscriber refreshes the subscription timer, the SUBSCRIBE request MUST contain the same \"Event\" header field \"id\" parameter as was present in the SUBSCRIBE request that created the subscription. (Otherwise, the notifier will interpret the SUBSCRIBE request as a request for a new subscription in the same dialog.)",
      "ja": "加入者がサブスクリプション・タイマをリフレッシュすると、サブスクリプションを作成したSUBSCRIBE要求に存在していたとしてO、SUBSCRIBEリクエストが同一の「イベント」ヘッダフィールド「ID」のパラメータを含まなければなりません。 （そうしないと、通知は同じダイアログで新しいサブスクリプションのための要求としてSUBSCRIBEリクエストを解釈します。）"
    },
    {
      "indent": 3,
      "text": "o When a subscription is created in the notifier, it stores any \"Event\" header field \"id\" parameter as part of the subscription information (along with the event package name).",
      "ja": "サブスクリプションが通知で作成されたO場合は、サブスクリプション情報の一部として（イベントパッケージ名と共に）任意の「イベント」ヘッダフィールド「ID」のパラメータを格納します。"
    },
    {
      "indent": 3,
      "text": "o If an initial SUBSCRIBE request is sent on a pre-existing dialog, a matching NOTIFY request merely creates a new subscription associated with that dialog.",
      "ja": "最初の要求が既存のダイアログ上で送信されたSUBSCRIBE場合は、O、マッチングは、要求が単にそのダイアログに関連付けられている新しいサブスクリプションを作成しますNOTIFY。"
    },
    {
      "indent": 0,
      "text": "4.6. CANCEL Requests for SUBSCRIBE and NOTIFY Transactions",
      "section_title": true,
      "ja": "4.6。 SUBSCRIBEとNOTIFY取引のための要求を取り消します"
    },
    {
      "indent": 3,
      "text": "Neither SUBSCRIBE nor NOTIFY requests can be canceled. If a User Agent Server (UAS) receives a CANCEL request that matches a known SUBSCRIBE or NOTIFY transaction, it MUST respond to the CANCEL request, but otherwise ignore it. In particular, the CANCEL request MUST NOT affect processing of the SUBSCRIBE or NOTIFY request in any way.",
      "ja": "SUBSCRIBE要求もなく、NOTIFYどちらもキャンセルすることができます。ユーザエージェントサーバ（UAS）が知られているSUBSCRIBEまたはNOTIFYトランザクションにマッチするCANCELリクエストを受信した場合、CANCEL要求に応答するが、そうでない場合は、それを無視しなければなりません。具体的には、CANCELリクエストは、どのような方法でSUBSCRIBEまたはNOTIFYリクエストの処理に影響してはいけません。"
    },
    {
      "indent": 3,
      "text": "UACs SHOULD NOT send CANCEL requests for SUBSCRIBE or NOTIFY transactions.",
      "ja": "求めるUACはCANCEL SUBSCRIBEまたはNOTIFYトランザクションに対するリクエストを送るべきではありません。"
    },
    {
      "indent": 0,
      "text": "5. Event Packages",
      "section_title": true,
      "ja": "5.イベントパッケージ"
    },
    {
      "indent": 3,
      "text": "This section covers several issues that should be taken into consideration when event packages based on the SUBSCRIBE and NOTIFY methods are proposed.",
      "ja": "このセクションでは、SUBSCRIBEとNOTIFYメソッドに基づいてイベントパッケージが提案されている時に考慮すべきいくつかの問題をカバーしています。"
    },
    {
      "indent": 0,
      "text": "5.1. Appropriateness of Usage",
      "section_title": true,
      "ja": "5.1。使用方法の妥当"
    },
    {
      "indent": 3,
      "text": "When designing an event package using the methods described in this document for event notification, it is important to consider: is SIP an appropriate mechanism for the problem set? Is SIP being selected because of some unique feature provided by the protocol (e.g., user mobility) or merely because \"it can be done\"? If you find yourself defining event packages for notifications related to, for example, network management or the temperature inside your car's engine, you may want to reconsider your selection of protocols.",
      "ja": "設定の問題のための適切なメカニズムをSIPさ：イベント通知のために、この文書に記載された方法を使用して、イベントパッケージを設計するとき、考慮することが重要なのでしょうか？ SIPがあるため、プロトコルによって提供されるいくつかのユニークな特徴（例えば、ユーザのモビリティ）のか、単に「それは行うことができます」ので、選択されていますか？あなた自身あなたの車のエンジン内部例えば、に関連したことを通知するためのイベントパッケージを定義し、ネットワーク管理や温度見つけた場合は、プロトコルの選択を再考することをお勧めします。"
    },
    {
      "indent": 6,
      "text": "Those interested in extending the mechanism defined in this document are urged to follow the development of \"Guidelines for Authors of SIP Extensions\" [RFC4485] for further guidance regarding appropriate uses of SIP.",
      "ja": "この文書で定義されたメカニズムを拡張するに興味のある人は、SIPの適切な使用に関する更なるガイダンスについては、「SIPの拡張機能の作成者のためのガイドライン」[RFC4485]の開発に従うことを促しています。"
    },
    {
      "indent": 3,
      "text": "Further, it is expected that this mechanism is not to be used in applications where the frequency of reportable events is excessively rapid (e.g., more than about once per second). A SIP network is generally going to be provisioned for a reasonable signaling volume; sending a notification every time a user's GPS position changes by one hundredth of a second could easily overload such a network.",
      "ja": "さらに、それは報告イベントの頻度が過度に急速であり、この機構は、アプリケーションで使用されるべきではないことが予想される（例えば、約1秒に1回以上）。 SIPネットワークは、一般的に合理的なシグナリング・ボリュームにプロビジョニングされようとしています。通知に100分の1秒によって、ユーザーのGPS位置の変更は、このようなネットワークを簡単に過負荷になる可能性がありたびに送信します。"
    },
    {
      "indent": 0,
      "text": "5.2. Event Template-Packages",
      "section_title": true,
      "ja": "5.2。イベントテンプレートパッケージ"
    },
    {
      "indent": 3,
      "text": "Normal event packages define a set of state applied to a specific type of resource, such as user presence, call state, and messaging mailbox state.",
      "ja": "通常のイベントパッケージは状態のセットは、このようなユーザーのプレゼンス、状態を呼び出し、およびメッセージングメールボックスの状態として、特定のタイプのリソースに適用される定義します。"
    },
    {
      "indent": 3,
      "text": "Event template-packages are a special type of package that define a set of state applied to other packages, such as statistics, access policy, and subscriber lists. Event template-packages may even be applied to other event template-packages.",
      "ja": "イベントテンプレートパッケージは、このような統計、アクセスポリシー、および加入者のリストなど、他のパッケージに適用される状態の集合を定義するパッケージの特殊なタイプです。イベントテンプレートパッケージは、さらに他のイベントテンプレートパッケージに適用することができます。"
    },
    {
      "indent": 3,
      "text": "To extend the object-oriented analogy made earlier, event template-packages can be thought of as templatized C++ packages that must be applied to other packages to be useful.",
      "ja": "先に作られたオブジェクト指向のアナロジーを拡張するには、イベントテンプレートパッケージは有用であることが他のパッケージに適用されなければならない、テンプレートC ++のパッケージと考えることができます。"
    },
    {
      "indent": 3,
      "text": "The name of an event template-package as applied to a package is formed by appending a period followed by the event template-package name to the end of the package. For example, if a template-package called \"winfo\" were being applied to a package called \"presence\", the event token used in the \"Event\" header field would be \"presence.winfo\".",
      "ja": "パッケージに適用されるイベント・テンプレート・パッケージの名前は、パッケージの最後にイベント・テンプレート・パッケージ名に続くピリオドを追加することによって形成されています。例えば、「プレゼンス」と呼ばれるパッケージに適用されていた「winfo」と呼ばれるテンプレートパッケージ場合、「イベント」ヘッダフィールドに使用されるイベントトークンは「presence.winfo」であろう。"
    },
    {
      "indent": 6,
      "text": "This scheme may be arbitrarily extended. For example, application of the \"winfo\" package to the \"presence.winfo\" state of a resource would be represented by the name \"presence.winfo.winfo\". It naturally follows from this syntax that the order in which templates are specified is significant.",
      "ja": "この方式は、任意に延長することができます。たとえば、リソースの「presence.winfo」状態に「winfo」パッケージの適用は、名前「presence.winfo.winfo」で表されます。それは自然のテンプレートが指定される順序が重要である。この構文に従います。"
    },
    {
      "indent": 6,
      "text": "For example: consider a theoretical event template-package called \"list\". The event \"presence.winfo.list\" would be the application of the \"list\" template to \"presence.winfo\", which would presumably be a list of winfo state associated with presence. On the other hand, the event \"presence.list.winfo\" would represent the application of winfo to \"presence.list\", which would be represent the winfo state of a list of presence information.",
      "ja": "例：「リスト」と呼ばれる理論上のイベントテンプレートパッケージを検討してください。イベント「presence.winfo.list」はおそらく存在に関連winfo状態のリストであろう「presence.winfo」から「リスト」テンプレートのアプリケーションであろう。一方、イベント「presence.list.winfo」はwinfoプレゼンス情報のリストのwinfo状態を表すであろう「presence.list」への応用を表すことになります。"
    },
    {
      "indent": 3,
      "text": "Event template-packages must be defined so that they can be applied to any arbitrary package. In other words, event template-packages cannot be specifically tied to one or a few \"parent\" packages in such a way that they will not work with other packages.",
      "ja": "彼らは、任意のパッケージに適用することができるようにイベントテンプレートパッケージを定義する必要があります。つまり、イベントテンプレートパッケージは、特に、彼らは他のパッケージでは動作しないような方法で、1つまたは少数の「親」のパッケージに接続することはできません。"
    },
    {
      "indent": 0,
      "text": "5.3. Amount of State to Be Conveyed",
      "section_title": true,
      "ja": "5.3。国家の量は、搬送されます"
    },
    {
      "indent": 3,
      "text": "When designing event packages, it is important to consider the type of information that will be conveyed during a notification.",
      "ja": "イベントパッケージを設計するとき、通知中に搬送されることになる情報の種類を考慮することが重要です。"
    },
    {
      "indent": 3,
      "text": "A natural temptation is to convey merely the event (e.g., \"a new voice message just arrived\") without accompanying state (e.g., \"7 total voice messages\"). This complicates implementation of subscribing entities (since they have to maintain complete state for the entity to which they have subscribed), and also is particularly susceptible to synchronization problems.",
      "ja": "自然の誘惑は、状態（例えば、「7総音声メッセージ」）を伴わずに（例えば、「新しいボイスメッセージが到着したばかり」）単にイベントを伝えることです。これは、（彼らが加入していると、エンティティのための完全な状態を維持する必要があるため）、エンティティをサブスクライブの実装を複雑にし、また、同期の問題に特に敏感です。"
    },
    {
      "indent": 3,
      "text": "This problem has two possible solutions that event packages may choose to implement.",
      "ja": "この問題は、イベントパッケージを実装することもできます2つの解決策を持っています。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Complete State Information",
      "section_title": true,
      "ja": "5.3.1。完全な状態情報"
    },
    {
      "indent": 3,
      "text": "In general, event packages need to be able to convey a well-defined and complete state, rather than just a stream of events. If it is not possible to describe complete system state for transmission in NOTIFY requests, then the problem set is not a good candidate for an event package.",
      "ja": "一般的に、イベントパッケージではなく、イベントの単なる流れよりも、明確に定義された、完全な状態を伝えることができるようにする必要があります。それはNOTIFYリクエストを伝送のための完全なシステムの状態を記述することができない場合は、設定の問題は、イベントパッケージのための良い候補ではありません。"
    },
    {
      "indent": 3,
      "text": "For packages that typically convey state information that is reasonably small (on the order of 1 KB or so), it is suggested that event packages are designed so as to send complete state information whenever an event occurs.",
      "ja": "典型的には、（1キロバイト程度のオーダーで）合理的に小さい状態情報を伝えるパッケージの場合、イベントが発生するたびに、完全な状態情報を送信するようにイベントパッケージが設計されていることが示唆されます。"
    },
    {
      "indent": 3,
      "text": "In some circumstances, conveying the current state alone may be insufficient for a particular class of events. In these cases, the event packages should include complete state information along with the event that occurred. For example, conveying \"no customer service representatives available\" may not be as useful as conveying \"no customer service representatives available; representative sip:46@cs.xyz.int just logged off\".",
      "ja": "いくつかの状況において、単独で現在の状態を伝達することは、イベントの特定のクラスには不十分であってもよいです。これらのケースでは、イベントパッケージは、発生したイベントと一緒に完全な状態情報を含むべきです。例えば、「NO顧客サービス担当者が利用できる」搬送する搬送ないほど有用ではないかもしれない、「利用可能な顧客サービス担当者と、代表SIP：46@cs.xyz.intだけログオフ」。"
    },
    {
      "indent": 0,
      "text": "5.3.2. State Deltas",
      "section_title": true,
      "ja": "5.3.2。州デルタ"
    },
    {
      "indent": 3,
      "text": "In the case that the state information to be conveyed is large, the event package may choose to detail a scheme by which NOTIFY requests contain state deltas instead of complete state.",
      "ja": "搬送される状態情報が大きい場合には、イベントパッケージを詳細に要求する代わりに、完全な状態の状態デルタを含むNOTIFYれるスキームを選択することができます。"
    },
    {
      "indent": 3,
      "text": "Such a scheme would work as follows: any NOTIFY request sent in immediate response to a SUBSCRIBE request contains full state information. NOTIFY requests sent because of a state change will contain only the state information that has changed; the subscriber will then merge this information into its current knowledge about the state of the resource.",
      "ja": "次のようにこのような方式は動作します：いずれかがSUBSCRIBEリクエストに即座に応答して送信された要求がフルの状態情報が含まれていNOTIFY。なぜなら、状態変化の送信された要求が変化しただけの状態情報が含まれていますNOTIFY。加入者は、リソースの状態に関する現在の知識には、この情報をマージします。"
    },
    {
      "indent": 3,
      "text": "Any event package that supports delta changes to states MUST include a version number that increases by exactly one for each NOTIFY transaction in a subscription. Note that the state version number appears in the body of the message, not in a SIP header field.",
      "ja": "状態にデルタの変更をサポートする任意のイベントパッケージは、サブスクリプションでトランザクションをNOTIFYごとに、正確に1ずつ増加するバージョン番号を含まなければなりません。状態のバージョン番号がないSIPヘッダフィールドに、メッセージの本文に表示されることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "If a NOTIFY request arrives that has a version number that is incremented by more than one, the subscriber knows that a state delta has been missed; it ignores the NOTIFY request containing the state delta (except for the version number, which it retains to detect message loss), and re-sends a SUBSCRIBE request to force a NOTIFY request containing a complete state snapshot.",
      "ja": "NOTIFYリクエストはそれ以上インクリメントされているバージョン番号を持って到着した場合、加入者は状態のデルタが見逃されていることを知っています。それは（それがメッセージの損失を検出するために保持するバージョン番号を除く）状態デルタを含むNOTIFYリクエストを無視し、完全な状態のスナップショットを含むNOTIFYリクエストを強制的にSUBSCRIBEリクエストを再送信します。"
    },
    {
      "indent": 0,
      "text": "5.4. Event Package Responsibilities",
      "section_title": true,
      "ja": "5.4。イベントパッケージの責務"
    },
    {
      "indent": 3,
      "text": "Event packages are not required to reiterate any of the behavior described in this document, although they may choose to do so for clarity or emphasis. In general, though, such packages are expected to describe only the behavior that extends or modifies the behavior described in this document.",
      "ja": "彼らは明確さや強調のためにそうすることを選択するかもしれないが、イベントパッケージは、この文書で説明した動作のいずれかをあらためて表明する必要はありません。一般的に、しかし、そのようなパッケージは、この文書に記載された動作を拡張または変更する動作のみを説明することが期待されます。"
    },
    {
      "indent": 3,
      "text": "Note that any behavior designated with \"SHOULD\" or \"MUST\" in this document is not allowed to be weakened by extension documents; however, such documents may elect to strengthen \"SHOULD\" requirements to \"MUST\" requirements if required by their application.",
      "ja": "どんな行動がまたはこのドキュメントの拡張文書によって弱体化することを許可されていない「MUST」、「すべきである」と指定されたことに注意してください。しかし、そのような文書は、そのアプリケーションで必要な場合、「SHOULD」要件に「MUST」の要件を強化するために選ぶことができます。"
    },
    {
      "indent": 3,
      "text": "In addition to the normal sections expected in Standards Track RFCs and SIP extension documents, authors of event packages need to address each of the issues detailed in the following subsections. For clarity: well-formed event package definitions contain sections addressing each of these issues, ideally in the same order and with the same titles as these subsections.",
      "ja": "標準化過程のRFCおよびSIP拡張文書に期待される通常のセクションに加えて、イベントパッケージの作者は以下のサブセクションで詳述の各問題に対処する必要があります。明確にするために：整形式イベントパッケージの定義は、理想的には同じ順序で、これらのサブセクションと同じタイトルで、これらの問題のそれぞれに対処セクションが含まれています。"
    },
    {
      "indent": 0,
      "text": "5.4.1. Event Package Name",
      "section_title": true,
      "ja": "5.4.1。イベントパッケージ名"
    },
    {
      "indent": 3,
      "text": "This section, which MUST be present, defines the token name to be used to designate the event package. It MUST include the information that appears in the IANA registration of the token. For information on registering such types, see Section 7.",
      "ja": "存在しなければならない、トークン名を定義このセクションでは、イベントパッケージを指定するために使用されます。これは、トークンのIANA登録に表示される情報を含まなければなりません。このようなタイプの登録については、セクション7を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Event Package Parameters",
      "section_title": true,
      "ja": "5.4.2。イベントパッケージのパラメータ"
    },
    {
      "indent": 3,
      "text": "If parameters are to be used on the \"Event\" header field to modify the behavior of the event package, the syntax and semantics of such header fields MUST be clearly defined.",
      "ja": "パラメータは、イベントパッケージの動作を変更するために「イベント」ヘッダフィールドで使用する場合は、そのようなヘッダフィールドの構文とセマンティクスが明確に定義されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Any \"Event\" header field parameters defined by an event package MUST be registered in the \"Header Field Parameters and Parameter Values\" registry defined by [RFC3968]. An \"Event\" header field parameter, once registered in conjunction with an event package, MUST NOT be reused with any other event package. Non-event-package specifications MAY define \"Event\" header field parameters that apply across all event packages (with emphasis on \"all\", as opposed to \"several\"), such as the \"id\" parameter defined in this document. The restriction of a parameter to use with a single event package only applies to parameters that are defined in conjunction with an event package.",
      "ja": "イベントパッケージによって定義された任意の「イベント」ヘッダフィールドパラメータは、[RFC3968]で定義された「ヘッダーフィールドパラメータとパラメータ値」レジストリに登録されなければなりません。一度イベントパッケージと一緒に登録された「イベント」ヘッダフィールドのパラメータは、他のイベントパッケージを再利用してはいけません。非イベントパッケージの仕様は、この文書で定義された「ID」をパラメータとして、（「数個」とは対照的に、「全て」に重点を置いて）すべてのイベントパッケージ全体に適用「イベント」ヘッダフィールドパラメータを定義することができます。シングルイベントパッケージで使用するためのパラメータの制限は、イベントパッケージに関連して定義されたパラメータに適用されます。"
    },
    {
      "indent": 0,
      "text": "5.4.3. SUBSCRIBE Request Bodies",
      "section_title": true,
      "ja": "5.4.3。リクエストボディをSUBSCRIBE"
    },
    {
      "indent": 3,
      "text": "It is expected that most, but not all, event packages will define syntax and semantics for SUBSCRIBE request bodies; these bodies will typically modify, expand, filter, throttle, and/or set thresholds for the class of events being requested. Designers of event packages are strongly encouraged to reuse existing media types for message bodies where practical. See [RFC4288] for information on media type specification and registration.",
      "ja": "ほとんどが、すべてではなく、イベントパッケージは、リクエストボディをSUBSCRIBEための構文とセマンティクスを定義することが期待されます。これらの機関は、通常、変更展開し、フィルタ、スロットル、および/または要求されているイベントのクラスのしきい値を設定します。イベントパッケージの設計者が強く実用的なメッセージ本文のための既存のメディアタイプを再利用することをお勧めします。メディアタイプの仕様と登録については、[RFC4288]を参照してください。"
    },
    {
      "indent": 3,
      "text": "This mandatory section of an event package defines what type or types of event bodies are expected in SUBSCRIBE requests (or specify that no event bodies are expected). It should point to detailed definitions of syntax and semantics for all referenced body types.",
      "ja": "イベントパッケージのこの必須セクションでは、SUBSCRIBE要求（あるいは全くイベント体が期待されていないことを指定）に期待されているどのような種類やイベント体の種類が定義されます。これは、すべての参照のボディタイプのための構文とセマンティクスの詳細な定義を指している必要があります。"
    },
    {
      "indent": 0,
      "text": "5.4.4. Subscription Duration",
      "section_title": true,
      "ja": "5.4.4。サブスクリプション期間"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that event packages give a suggested range of times considered reasonable for the duration of a subscription. Such packages MUST also define a default \"Expires\" value to be used if none is specified.",
      "ja": "そのイベントパッケージはサブスクリプションの期間のための合理的な考えられ倍の推奨範囲を与えることを推奨します。また、デフォルトを定義しなければならないようなパッケージには、何も指定されていない場合、値が使用されるように、「有効期限」。"
    },
    {
      "indent": 0,
      "text": "5.4.5. NOTIFY Request Bodies",
      "section_title": true,
      "ja": "5.4.5。リクエストボディをNOTIFY"
    },
    {
      "indent": 3,
      "text": "The NOTIFY request body is used to report state on the resource being monitored. Each package MUST define what type or types of event bodies are expected in NOTIFY requests. Such packages MUST specify or cite detailed specifications for the syntax and semantics associated with such event bodies.",
      "ja": "NOTIFYリクエストボディは監視されているリソースに状態を報告するために使用されます。各パッケージには、NOTIFYリクエストをして期待されているどのような種類やイベント体のタイプを定義しなければなりません。このようなパッケージには、このようなイベントボディに関連付けられた構文とセマンティクスの詳細な仕様を指定したり、引用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Event packages also MUST define which media type is to be assumed if none are specified in the \"Accept\" header field of the SUBSCRIBE request.",
      "ja": "イベントパッケージはまた、いずれもSUBSCRIBEリクエストの「同意」ヘッダフィールドで指定されていない場合に想定されるべきメディアタイプを定義しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.4.6. Notifier Processing of SUBSCRIBE Requests",
      "section_title": true,
      "ja": "5.4.6。 SUBSCRIBE要求の通知処理"
    },
    {
      "indent": 3,
      "text": "This section describes the processing to be performed by the notifier upon receipt of a SUBSCRIBE request. Such a section is required.",
      "ja": "このセクションでは、SUBSCRIBEリクエストの受信時に通知することによって実行される処理について説明します。このようなセクションが必要です。"
    },
    {
      "indent": 3,
      "text": "Information in this section includes details of how to authenticate subscribers and authorization issues for the package.",
      "ja": "このセクションの情報は、パッケージの加入者と承認の問題を認証する方法の詳細が含まれます。"
    },
    {
      "indent": 0,
      "text": "5.4.7. Notifier generation of NOTIFY requests",
      "section_title": true,
      "ja": "5.4.7。 NOTIFYリクエストのノーティ世代"
    },
    {
      "indent": 3,
      "text": "This section of an event package describes the process by which the notifier generates and sends a NOTIFY request. This includes detailed information about what events cause a NOTIFY request to be sent, how to compute the state information in the NOTIFY, how to generate neutral or fake state information to hide authorization delays and decisions from users, and whether state information is complete or what the deltas are for notifications; see Section 5.3. Such a section is required.",
      "ja": "イベントパッケージのこのセクションでは、通知を生成し、NOTIFYリクエストを送信するプロセスを記載しています。これは、ユーザーからの承認の遅れや判断を隠すために、中性または偽の状態情報を生成する方法を、NOTIFY、および状態情報が完全であるか、何か状態情報を計算する方法を、送信するNOTIFYリクエストを引き起こすどのようなイベントに関する詳細な情報を含んでいますデルタは、通知のためのものです。 5.3節を参照してください。このようなセクションが必要です。"
    },
    {
      "indent": 3,
      "text": "This section may optionally describe the behavior used to process the subsequent response.",
      "ja": "このセクションでは、必要に応じてその後の応答を処理するために使用される挙動を記述することができます。"
    },
    {
      "indent": 0,
      "text": "5.4.8. Subscriber Processing of NOTIFY Requests",
      "section_title": true,
      "ja": "5.4.8。 NOTIFYリクエストのサブスクライバ処理"
    },
    {
      "indent": 3,
      "text": "This section of an event package describes the process followed by the subscriber upon receipt of a NOTIFY request, including any logic required to form a coherent resource state (if applicable).",
      "ja": "イベントパッケージのこのセクションでは、コヒーレントリソース状態（該当する場合）を形成するために必要なロジックを含むNOTIFYリクエストを受け取ると、加入者が続く方法を記載しています。"
    },
    {
      "indent": 0,
      "text": "5.4.9. Handling of Forked Requests",
      "section_title": true,
      "ja": "5.4.9。フォーク要求の処理"
    },
    {
      "indent": 3,
      "text": "Each event package MUST specify whether forked SUBSCRIBE requests are allowed to install multiple subscriptions.",
      "ja": "各イベントパッケージは、SUBSCRIBEフォーク要求が複数のサブスクリプションをインストールするために許可されているかどうかを指定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If such behavior is not allowed, the first potential dialog-establishing message will create a dialog. All subsequent NOTIFY requests that correspond to the SUBSCRIBE request (i.e., have matching \"To\", \"From\", \"Call-ID\", and \"Event\" header fields, as well as \"From\" header field \"tag\" parameter and \"Event\" header field \"id\" parameter) but that do not match the dialog would be rejected with a 481 response. Note that the 200-class response to the SUBSCRIBE request can arrive after a matching NOTIFY request has been received; such responses might not correlate to the same dialog established by the NOTIFY request. Except as required to complete the SUBSCRIBE transaction, such non-matching 200-class responses are ignored.",
      "ja": "そのような行動が許可されていない場合は、第一の電位のダイアログ確立メッセージダイアログを作成します。 SUBSCRIBEリクエストに対応して後続のすべてのNOTIFYリクエストは（すなわち、「から」、マッチング「を」持っていると、「イベント」のヘッダフィールドだけでなく、「差出人」ヘッダフィールド「タグ」パラメータと「「-IDを呼び出します」ダイアログに一致しないイベント」ヘッダフィールド 『ID』パラメータ）が、それは481応答で拒否されるだろう。 SUBSCRIBEリクエストに対する200クラス応答がマッチング後に到着要求が受信された通知することができることに留意されたいです。そのような応答は、NOTIFYリクエストによって確立された同じダイアログに相関しない場合があります。 SUBSCRIBEトランザクションを完了するために必要なものを除き、このような非マッチング200クラスの応答は無視されます。"
    },
    {
      "indent": 3,
      "text": "If installing of multiple subscriptions by way of a single forked SUBSCRIBE request is allowed, the subscriber establishes a new dialog towards each notifier by returning a 200-class response to each NOTIFY request. Each dialog is then handled as its own entity and is refreshed independently of the other dialogs.",
      "ja": "要求が許可された単一のフォークを介して複数のサブスクリプションをインストールする購読している場合、加入者は、各要求を通知する200クラス応答を返すことによって、各通知に向かって新しいダイアログを確立します。各ダイアログは、その後、独自のエンティティとして扱われ、独立して、他のダイアログのリフレッシュされます。"
    },
    {
      "indent": 3,
      "text": "In the case that multiple subscriptions are allowed, the event package MUST specify whether merging of the notifications to form a single state is required, and how such merging is to be performed. Note that it is possible that some event packages may be defined in such a way that each dialog is tied to a mutually exclusive state that is unaffected by the other dialogs; this MUST be clearly stated if it is the case.",
      "ja": "複数のサブスクリプションが許可されている場合に、イベントパッケージは、単一の状態を形成するように通知をマージするかどうかを指定しなければならない必要、及び実行する方法、このようなマージされます。いくつかのイベントパッケージは、各ダイアログは、他のダイアログに影響されない相互に排他的な状態に接続されるように定義することができる可能性があることに留意されたいです。それがそうであるならば、これは明確に記載しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.4.10. Rate of Notifications",
      "section_title": true,
      "ja": "5.4.10。通知のレート"
    },
    {
      "indent": 3,
      "text": "Each event package is expected to define a requirement (\"SHOULD\" or \"MUST\" strength) that defines an absolute maximum on the rate at which notifications are allowed to be generated by a single notifier.",
      "ja": "各イベントパッケージは、通知は、単一の通知によって生成することが許可されている速度に絶対最大値を規定する要件（「SHOULD」や「MUST」強度）を定義することが期待されます。"
    },
    {
      "indent": 3,
      "text": "Each package MAY further define a throttle mechanism that allows subscribers to further limit the rate of notification.",
      "ja": "各パッケージは、加入者がさらに通知のレートを制限することを可能にするスロットル機構を定義することができます。"
    },
    {
      "indent": 0,
      "text": "5.4.11. State Aggregation",
      "section_title": true,
      "ja": "5.4.11。国家集計"
    },
    {
      "indent": 3,
      "text": "Many event packages inherently work by collecting information about a resource from a number of other sources -- either through the use of PUBLISH [RFC3903], by subscribing to state information, or through other state-gathering mechanisms.",
      "ja": "多くのイベント・パッケージは、本質的に他の多くの供給源からのリソースに関する情報を収集することによって動作する - のいずれかの状態情報をサブスクライブすることによって、または他の状態収集機構を介して、[RFC3903]をPUBLISHを使用することによって。"
    },
    {
      "indent": 3,
      "text": "Event packages that involve retrieval of state information for a single resource from more than one source need to consider how notifiers aggregate information into a single, coherent state. Such packages MUST specify how notifiers aggregate information and how they provide authentication and authorization.",
      "ja": "複数のソースから単一のリソースの状態情報の取得を伴うイベントパッケージは、単一の、コヒーレント状態に集計情報を通知機能方法を検討する必要があります。このようなパッケージには、情報を集約し、それらがどのように認証と承認を提供する通知機能方法を指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.4.12. Examples",
      "section_title": true,
      "ja": "5.4.12。例"
    },
    {
      "indent": 3,
      "text": "Event packages SHOULD include several demonstrative message flow diagrams paired with several typical, syntactically correct, and complete messages.",
      "ja": "イベントパッケージは、典型的ないくつかの構文的に正しい、と完全なメッセージと対になって、いくつかの実証メッセージ・フロー・ダイアグラムを含むべきです。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that documents describing event packages clearly indicate that such examples are informative and not normative, with instructions that implementors refer to the main text of the document for exact protocol details.",
      "ja": "イベントパッケージを記述した文書は明確にそのような例は、実装者が正確なプロトコルの詳細について文書の本文を参照する命令で、規範的、有益ではないことを示していることが推奨されます。"
    },
    {
      "indent": 0,
      "text": "5.4.13. Use of URIs to Retrieve State",
      "section_title": true,
      "ja": "5.4.13。状態を取得するためのURIの使用"
    },
    {
      "indent": 3,
      "text": "Some types of event packages may define state information that is potentially too large to reasonably send in a SIP message. To alleviate this problem, event packages may include the ability to convey a URI instead of state information; this URI will then be used to retrieve the actual state information.",
      "ja": "イベントパッケージの種類によっては、潜在的に合理的なSIPメッセージで送信するには大きすぎる状態情報を定義することもできます。この問題を軽減するために、イベントパッケージは、URIを伝える能力の代わりに、状態情報を含むことができます。このURIは、実際の状態情報を取得するために使用されます。"
    },
    {
      "indent": 3,
      "text": "[RFC4483] defines a mechanism that can be used by event packages to convey information in such a fashion.",
      "ja": "[RFC4483]は、このような方法で情報を伝達するために、イベント・パッケージで使用することができるメカニズムを定義します。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. Access Control",
      "section_title": true,
      "ja": "6.1。アクセス制御"
    },
    {
      "indent": 3,
      "text": "The ability to accept subscriptions should be under the direct control of the notifier's user, since many types of events may be considered private. Similarly, the notifier should have the ability to selectively reject subscriptions based on the subscriber identity (based on access control lists), using standard SIP authentication mechanisms. The methods for creation and distribution of such access control lists are outside the scope of this document.",
      "ja": "イベントには多くの種類がプライベートと見なすことができるので、サブスクリプションを受け入れる能力は、通知のユーザーの直接の管理下にある必要があります。同様に、通知は、標準的なSIP認証メカニズムを使用して、選択的に（アクセス制御リストに基づいて）加入者識別情報に基づいてサブスクリプションを除去する能力を有するべきです。このようなアクセス制御リストの作成と配布のための方法は、この文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "6.2. Notifier Privacy Mechanism",
      "section_title": true,
      "ja": "6.2。 Notifierのプライバシーメカニズム"
    },
    {
      "indent": 3,
      "text": "The mere act of returning certain 400- and 600-class responses to SUBSCRIBE requests may, under certain circumstances, create privacy concerns by revealing sensitive policy information. In these cases, the notifier SHOULD always return a 200 (OK) response. While the subsequent NOTIFY request may not convey true state, it MUST appear to contain a potentially correct piece of data from the point of view of the subscriber, indistinguishable from a valid response. Information about whether a user is authorized to subscribe to the requested state is never conveyed back to the original user under these circumstances.",
      "ja": "SUBSCRIBE要求する特定400-を返すと600クラスの応答の単なる行為は、特定の状況下で、機密ポリシー情報を明らかにすることにより、プライバシーの問題を作成することができます。これらのケースでは、通知は、常に200（OK）レスポンスを返すべきです。その後のNOTIFY要求が真の状態を伝えないかもしれないが、有効な応答と区別できない加入者の観点からデータの潜在的に正確なピースを含むように表示される必要があります。ユーザーが要求された状態に加入することが許可されているかどうかについての情報は、このような状況下で、元のユーザーに戻って伝えされることはありません。"
    },
    {
      "indent": 3,
      "text": "Individual packages and their related documents for which such a mode of operation makes sense can further describe how and why to generate such potentially correct data. For example, such a mode of operation is mandated by [RFC2779] for user presence information.",
      "ja": "そのような動作モードは理にかなっている個々のパッケージとその関連文書は、さらにどのように、なぜ、このような潜在的に正しいデータを生成するために記述することができます。例えば、動作のそのようなモードは、ユーザプレゼンス情報の[RFC2779]によって義務付けられています。"
    },
    {
      "indent": 0,
      "text": "6.3. Denial-of-Service Attacks",
      "section_title": true,
      "ja": "6.3。サービス拒否攻撃"
    },
    {
      "indent": 3,
      "text": "The current model (one SUBSCRIBE request triggers a SUBSCRIBE response and one or more NOTIFY requests) is a classic setup for an amplifier node to be used in a smurf attack [CERT1998a].",
      "ja": "現在のモデル（一方の要求がSUBSCRIBE応答および1つまたは複数のNOTIFY要求をトリガSUBSCRIBE）は、スマーフ攻撃[CERT1998a]で使用される増幅器ノードのための古典的な設定です。"
    },
    {
      "indent": 3,
      "text": "Also, the creation of state upon receipt of a SUBSCRIBE request can be used by attackers to consume resources on a victim's machine, rendering it unusable.",
      "ja": "また、SUBSCRIBEリクエストを受信したときの状態の作成は、それが使用できなくなる、被害者のマシン上のリソースを消費するために攻撃者によって使用することができます。"
    },
    {
      "indent": 3,
      "text": "To reduce the chances of such an attack, implementations of notifiers SHOULD require authentication. Authentication issues are discussed in [RFC3261].",
      "ja": "このような攻撃の可能性を減らすために、ノーティファイアの実装は認証を必要とすべきです。認証の問題は、[RFC3261]に記載されています。"
    },
    {
      "indent": 0,
      "text": "6.4. Replay Attacks",
      "section_title": true,
      "ja": "6.4。リプレイ攻撃"
    },
    {
      "indent": 3,
      "text": "Replaying of either SUBSCRIBE or NOTIFY requests can have detrimental effects.",
      "ja": "SUBSCRIBEまたはNOTIFYのいずれかの要求を再生すると、有害な影響を持つことができます。"
    },
    {
      "indent": 3,
      "text": "In the case of SUBSCRIBE requests, an attacker may be able to install any arbitrary subscription that it witnessed being installed at some point in the past. Replaying of NOTIFY requests may be used to spoof old state information (although a good versioning mechanism in the body of the NOTIFY requests may help mitigate such an attack). Note that the prohibition on sending NOTIFY requests to nodes that have not subscribed to an event also aids in mitigating the effects of such an attack.",
      "ja": "SUBSCRIBEリクエストの場合、攻撃者は、それは過去のある時点でインストールされている目撃任意のサブスクリプションをインストールすることができるかもしれません。 NOTIFYリクエストをのリプレイする（NOTIFYリクエストのボディに優れたバージョン管理メカニズムがこのような攻撃を軽減するのに役立つかもしれないが）古い状態情報を偽装するために使用することができます。イベントに加入していないノードにNOTIFYリクエストを送信の禁止はまた、このような攻撃の影響を緩和するのに役立つことに注意してください。"
    },
    {
      "indent": 3,
      "text": "To prevent such attacks, implementations SHOULD require authentication with anti-replay protection. Authentication issues are discussed in [RFC3261].",
      "ja": "このような攻撃を防ぐために、実装はリプレイ保護を備えた認証を必要とすべきです。認証の問題は、[RFC3261]に記載されています。"
    },
    {
      "indent": 0,
      "text": "6.5. Man-in-the-Middle Attacks",
      "section_title": true,
      "ja": "6.5。 man-in-the-middle攻撃"
    },
    {
      "indent": 3,
      "text": "Even with authentication, man-in-the-middle attacks using SUBSCRIBE requests may be used to install arbitrary subscriptions, hijack existing subscriptions, terminate outstanding subscriptions, or modify the resource to which a subscription is being made. To prevent such attacks, implementations SHOULD provide integrity protection across \"Contact\", \"Route\", \"Expires\", \"Event\", and \"To\" header fields (at a minimum) of SUBSCRIBE requests. If SUBSCRIBE request bodies are used to define further information about the state of the call, they SHOULD be included in the integrity protection scheme.",
      "ja": "でも認証を使用して、man-in-the-middle攻撃は、要求が任意のサブスクリプションをインストールするために使用することができるSUBSCRIBE既存のサブスクリプションをハイジャック、優れたサブスクリプションを終了、またはサブスクリプションが行われているためにリソースを変更します。このような攻撃を防ぐために、実装は、「連絡先」、「ルート」を越え完全性保護を提供すべきで、「有効期限」、「イベント」、およびSUBSCRIBEリクエストの「へ」ヘッダフィールド（最低でも）。 SUBSCRIBEリクエスト体がコールの状態に関する更なる情報を定義するために使用されている場合、それらは、完全性保護スキームに含まれるべきです。"
    },
    {
      "indent": 3,
      "text": "Man-in-the-middle attacks may also attempt to use NOTIFY requests to spoof arbitrary state information and/or terminate outstanding subscriptions. To prevent such attacks, implementations SHOULD provide integrity protection across the \"Call-ID\", \"CSeq\", and \"Subscription-State\" header fields and the bodies of NOTIFY requests.",
      "ja": "man-in-the-middle攻撃はまた、任意の状態情報を偽装するNOTIFYリクエストを使用しようとする、および/または優れたサブスクリプションを終了することができます。このような攻撃を防ぐために、実装は、「のCSeq」、および「サブスクリプション・ステート」「-IDを呼び出し、」ヘッダーフィールドとNOTIFYリクエストのボディ全体の完全性保護を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Integrity protection of message header fields and bodies is discussed in [RFC3261].",
      "ja": "メッセージヘッダフィールドと体の完全性保護は、[RFC3261]に記載されています。"
    },
    {
      "indent": 0,
      "text": "6.6. Confidentiality",
      "section_title": true,
      "ja": "6.6。機密性"
    },
    {
      "indent": 3,
      "text": "The state information contained in a NOTIFY request has the potential to contain sensitive information. Implementations MAY encrypt such information to ensure confidentiality.",
      "ja": "NOTIFYリクエストに含まれる状態情報は、機密情報が含まれている可能性を秘めています。実装は、機密性を確保するために、このような情報を暗号化してもよいです。"
    },
    {
      "indent": 3,
      "text": "While less likely, it is also possible that the information contained in a SUBSCRIBE request contains information that users might not want to have revealed. Implementations MAY encrypt such information to ensure confidentiality.",
      "ja": "可能性が低いが、SUBSCRIBEリクエストに含まれる情報は、ユーザーが明らかになっているしたくないかもしれないという情報が含まれていることも可能です。実装は、機密性を確保するために、このような情報を暗号化してもよいです。"
    },
    {
      "indent": 3,
      "text": "To allow the remote party to hide information it considers sensitive, all implementations SHOULD be able to handle encrypted SUBSCRIBE and NOTIFY requests.",
      "ja": "相手はそれが機密と考えられる情報を非表示にできるようにするには、すべての実装は、暗号化されたSUBSCRIBEとNOTIFYリクエストを処理できる必要があります。"
    },
    {
      "indent": 3,
      "text": "The mechanisms for providing confidentiality are detailed in [RFC3261].",
      "ja": "機密性を提供するためのメカニズムは、[RFC3261]に詳述されています。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "With the exception of Section 7.2, the subsections here are for current reference, carried over from the original specification (RFC 3265). IANA has updated all registry references that pointed to RFC 3265 to instead indicate this document and created the new \"reason code\" registry described in Section 7.2.",
      "ja": "セクション7.2を除いて、ここでサブセクションは、現在の参照のために、元の仕様（RFC 3265）から引き継がれています。 IANAは、代わりにこの文書を示すために、RFC 3265を指摘し、7.2節で説明した、新たな「理由コード」のレジストリを作成したすべてのレジストリの参照を更新しました。"
    },
    {
      "indent": 0,
      "text": "7.1. Event Packages",
      "section_title": true,
      "ja": "7.1。イベントパッケージ"
    },
    {
      "indent": 3,
      "text": "This document defines an event-type namespace that requires a central coordinating body. The body chosen for this coordination is the Internet Assigned Numbers Authority (IANA).",
      "ja": "この文書では、中央調整機関を必要とするイベント型の名前空間を定義します。この調整のために選ばれたボディは、Internet Assigned Numbers Authority（IANA）です。"
    },
    {
      "indent": 3,
      "text": "There are two different types of event-types: normal event packages and event template-packages; see Section 5.2. To avoid confusion, template-package names and package names share the same namespace; in other words, an event template-package is forbidden from sharing a name with a package.",
      "ja": "イベント・タイプの2種類があります：通常のイベントパッケージとイベントテンプレートパッケージは、 5.2節を参照してください。混乱を避けるために、テンプレートパッケージ名とパッケージ名は同じ名前空間を共有します。言い換えれば、イベントテンプレートパッケージは、パッケージと名前を共有してから禁止されています。"
    },
    {
      "indent": 3,
      "text": "Policies for registration of SIP event packages and SIP event package templates are defined in Section 4.1 of [RFC5727].",
      "ja": "SIPイベントパッケージとSIPイベントパッケージテンプレートの登録のための政策は、[RFC5727]のセクション4.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "Registrations with the IANA are required to include the token being registered and whether the token is a package or a template-package. Further, packages must include contact information for the party responsible for the registration and/or a published document that describes the event package. Event template-package token registrations are also required to include a pointer to the published RFC that defines the event template-package.",
      "ja": "IANAに登録は、登録されたトークンと、トークンがパッケージまたはテンプレートパッケージであるかどうかを含むことが必要です。さらに、パッケージは、登録および/またはイベントパッケージを説明し、公開文書のための責任者の連絡先情報を含める必要があります。イベントテンプレートパッケージのトークンの登録は、イベントテンプレートパッケージを定義し、公開RFCへのポインタを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Registered tokens to designate packages and template-packages are disallowed from containing the character \".\", which is used to separate template-packages from packages.",
      "ja": "パッケージとテンプレートパッケージを指定する登録トークンは、文字「」、パッケージから独立したテンプレートのパッケージに使用されている含むから禁止されています。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Registration Information",
      "section_title": true,
      "ja": "7.1.1。登録情報"
    },
    {
      "indent": 3,
      "text": "This document specifies no package or template-package names. All entries in this table are added by other documents. The remainder of the text in this section gives an example of the type of information to be maintained by the IANA; it also demonstrates all four possible permutations of package type, contact, and reference.",
      "ja": "この文書には、パッケージまたはテンプレートのパッケージ名を指定していません。この表のすべてのエントリは、他の文書によって追加されています。このセクション内のテキストの残りはIANAによって維持される情報の種類の例を示します。それはまた、パッケージの種類、連絡先、および参照の4つのすべての可能な順列を示しています。"
    },
    {
      "indent": 3,
      "text": "The table below lists the event packages and template-packages defined for use with the \"SIP-Specific Event Notification\" mechanism [RFC 6665]. Each name is designated as a package or a template-package under \"Type\".",
      "ja": "以下の表は、「SIP固有のイベント通知」メカニズム[RFC 6665]で使用するために定義されたイベントパッケージとテンプレートパッケージを示しています。それぞれの名前は、「タイプ」の下で、パッケージまたはテンプレートパッケージに指定されています。"
    },
    {
      "indent": 3,
      "text": "Package Name      Type         Contact      Reference\n------------      ----         -------      ---------\nexample1          package      [Doe]        [RFCnnnn]\nexample2          package                   [RFCnnnn]\nexample3          template     [Doe]        [RFCnnnn]\nexample4          template                  [RFCnnnn]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "PEOPLE\n------\n[Doe] John Doe <john.doe@example.com>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "REFERENCES\n----------\n[RFCnnnn] Doe, J., \"Sample Document\", RFC nnnn, Month YYYY.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.1.2. Registration Template",
      "section_title": true,
      "ja": "7.1.2。登録テンプレート"
    },
    {
      "indent": 3,
      "text": "To: ietf-sip-events@iana.org Subject: Registration of new SIP event package",
      "ja": "To：ietf-sip-events@iana.org件名：新しいSIPイベントパッケージの登録"
    },
    {
      "indent": 3,
      "text": "Package name:",
      "ja": "パッケージ名："
    },
    {
      "indent": 6,
      "text": "(Package names must conform to the syntax described in Section 8.2.1.)",
      "ja": "（パッケージ名は、8.2.1項で説明した構文に準拠する必要があります。）"
    },
    {
      "indent": 3,
      "text": "Is this registration for a Template-Package:",
      "ja": "テンプレート・パッケージのためのこの登録は、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "(indicate yes or no)",
      "ja": "（yesまたはnoを示していません）"
    },
    {
      "indent": 3,
      "text": "Published specification(s):",
      "ja": "公開された仕様（S）："
    },
    {
      "indent": 6,
      "text": "(Template-packages require a published RFC. Other packages may reference a specification when appropriate.)",
      "ja": "（テンプレートパッケージは、公開されたRFCを必要とする。適切な場合他のパッケージは、仕様を参照することができます。）"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information:",
      "ja": "詳細のために連絡する人とEメールアドレス："
    },
    {
      "indent": 6,
      "text": "(self-explanatory)",
      "ja": "（自明）"
    },
    {
      "indent": 0,
      "text": "7.2. Reason Codes",
      "section_title": true,
      "ja": "7.2。理由コード"
    },
    {
      "indent": 3,
      "text": "This document further defines \"reason\" codes for use in the \"Subscription-State\" header field (see Section 4.1.3).",
      "ja": "この文書でさらに定義する「理由」「サブスクリプション状態」ヘッダフィールドで使用するためのコード（セクション4.1.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Following the policies outlined in \"Guidelines for Writing an IANA Considerations Section in RFCs\" [RFC5226], new reason codes require a Standards Action.",
      "ja": "「RFCsにIANA問題部に書くためのガイドライン」[RFC5226]に概説された方針に続いて、新しい理由コードは、標準アクションが必要です。"
    },
    {
      "indent": 3,
      "text": "Registrations with the IANA include the reason code being registered and a reference to a published document that describes the event package. Insertion of such values takes place as part of the RFC publication process or as the result of liaison activity between standards development organizations (SDOs), the result of which will be publication of an associated RFC. New reason codes must conform to the syntax of the ABNF \"token\" element defined in [RFC3261].",
      "ja": "IANAでの登録は、登録されている理由コードとイベントパッケージを記述する公開されたドキュメントへの参照が含まれています。このような値の挿入は、RFC公開プロセスの一部として、または規格開発組織（のSDO）、関連するRFCの出版される結果と連絡活動の結果として行われます。新しい理由コードは、[RFC3261]で定義されたABNF「トークン」要素の構文に準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "[RFC4660] defined a new reason code prior to the establishment of an IANA registry. We include its reason code (\"badfilter\") in the initial list of reason codes to ensure a complete registry.",
      "ja": "[RFC4660]はIANAレジストリの確立に先立って新たな理由コードを定義しました。私たちは、完全なレジストリを確実にする理由コードの最初のリストにその理由コード（「badfilter」）が含まれます。"
    },
    {
      "indent": 3,
      "text": "The IANA registry for reason codes has been initialized with the following values:",
      "ja": "理由コードのためのIANAレジストリは、次の値で初期化されています。"
    },
    {
      "indent": 3,
      "text": "Reason Code            Reference\n-----------            ---------\ndeactivated            [RFC6665]\nprobation              [RFC6665]\nrejected               [RFC6665]\ntimeout                [RFC6665]\ngiveup                 [RFC6665]\nnoresource             [RFC6665]\ninvariant              [RFC6665]\nbadfilter              [RFC4660]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "REFERENCES\n----------\n[RFC6665]  A.B. Roach, \"SIP-Specific Event Notification\", RFC 6665,\n           July 2012.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[RFC4660] Khartabil, H., Leppanen, E., Lonnfors, M., and J. Costa-Requena, \"Functional Description of Event Notification Filtering\", September 2006.",
      "ja": "[RFC4660] Khartabil、H.、Leppanen、E.、Lonnfors、M.、およびJ.コスタ・レケーナ、 \"イベント通知フィルタリングの機能説明\"、2006年9月。"
    },
    {
      "indent": 0,
      "text": "7.3. Header Field Names",
      "section_title": true,
      "ja": "7.3。ヘッダーフィールド名"
    },
    {
      "indent": 3,
      "text": "This document registers three new header field names, described elsewhere in this document. These header fields are defined by the following information, which is to be added to the header field sub-registry under http://www.iana.org/assignments/sip-parameters.",
      "ja": "この文書は、本文書の他の場所で説明した3人の新しいヘッダフィールド名を、登録します。これらのヘッダーフィールドはhttp://www.iana.org/assignments/sip-parameters下ヘッダフィールドのサブレジストリに追加される次の情報によって定義されます。"
    },
    {
      "indent": 3,
      "text": "Header Name: Allow-Events Compact Form: u",
      "ja": "ヘッダー名：許可 - イベントコンパクト形：U"
    },
    {
      "indent": 3,
      "text": "Header Name: Subscription-State Compact Form: (none)",
      "ja": "ヘッダー名：サブスクリプション・ステート・コンパクトなフォーム：（なし）"
    },
    {
      "indent": 3,
      "text": "Header Name: Event Compact Form: o",
      "ja": "ヘッダー名：イベントコンパクト形：O"
    },
    {
      "indent": 0,
      "text": "7.4. Response Codes",
      "section_title": true,
      "ja": "7.4。応答コード"
    },
    {
      "indent": 3,
      "text": "This document registers two new response codes. These response codes are defined by the following information, which is to be added to the method and response-code sub-registry under http://www.iana.org/assignments/sip-parameters.",
      "ja": "この文書では、2つの新しい応答コードを登録します。これらのレスポンスコードはhttp://www.iana.org/assignments/sip-parameters下方法と応答コードのサブレジストリに追加される次の情報によって定義されます。"
    },
    {
      "indent": 3,
      "text": "Response Code Number: 202 Default Reason Phrase: Accepted",
      "ja": "応答コード番号：202デフォルトの理由フレーズ：受け入れ"
    },
    {
      "indent": 3,
      "text": "Response Code Number: 489 Default Reason Phrase: Bad Event",
      "ja": "応答コード番号：489デフォルトの理由フレーズ：バート・イベント"
    },
    {
      "indent": 0,
      "text": "8. Syntax",
      "section_title": true,
      "ja": "8.構文"
    },
    {
      "indent": 3,
      "text": "This section describes the syntax extensions required for event notification in SIP. Semantics are described in Section 4. Note that the formal syntax definitions described in this document are expressed in the ABNF format used in [RFC3261] and contain references to elements defined therein.",
      "ja": "このセクションでは、SIPのイベント通知に必要な構文の拡張機能について説明します。セマンティクスは、この文書に記載され正式な構文定義は[RFC3261]で使用されるABNF形式で表現し、その中に定義された要素への参照が含まれていることを第4の注記に記載されています。"
    },
    {
      "indent": 0,
      "text": "8.1. New Methods",
      "section_title": true,
      "ja": "8.1。新しいメソッド"
    },
    {
      "indent": 3,
      "text": "This document describes two new SIP methods: SUBSCRIBE and NOTIFY.",
      "ja": "この文書では、2つの新しいSIP方法について説明しますSUBSCRIBEとNOTIFY。"
    },
    {
      "indent": 0,
      "text": "8.1.1. SUBSCRIBE Method",
      "section_title": true,
      "ja": "8.1.1。メソッドのSUBSCRIBE"
    },
    {
      "indent": 3,
      "text": "\"SUBSCRIBE\" is added to the definition of the element \"Method\" in the SIP message grammar.",
      "ja": "「SUBSCRIBE」SIPメッセージ文法の要素「方法」の定義に追加されます。"
    },
    {
      "indent": 3,
      "text": "Like all SIP method names, the SUBSCRIBE method name is case sensitive. The SUBSCRIBE method is used to request asynchronous notification of an event or set of events at a later time.",
      "ja": "すべてのSIPメソッド名と同様に、SUBSCRIBEメソッド名は大文字と小文字が区別されます。 SUBSCRIBEメソッドは、後で非同期イベントの通知またはイベントのセットを要求するために使用されます。"
    },
    {
      "indent": 0,
      "text": "8.1.2. NOTIFY Method",
      "section_title": true,
      "ja": "8.1.2。メソッドをNOTIFY"
    },
    {
      "indent": 3,
      "text": "\"NOTIFY\" is added to the definition of the element \"Method\" in the SIP message grammar.",
      "ja": "「NOTIFY」SIPメッセージ文法の要素「方法」の定義に追加されます。"
    },
    {
      "indent": 3,
      "text": "The NOTIFY method is used to notify a SIP node that an event that has been requested by an earlier SUBSCRIBE method has occurred. It may also provide further details about the event.",
      "ja": "NOTIFYメソッドは、以前のSUBSCRIBEメソッドによって要求されたイベントが発生したSIPノードに通知するために使用されます。また、イベントに関する詳細を提供することができます。"
    },
    {
      "indent": 0,
      "text": "8.2. New Header Fields",
      "section_title": true,
      "ja": "8.2。新しいヘッダフィールド"
    },
    {
      "indent": 0,
      "text": "8.2.1. \"Event\" Header Field",
      "section_title": true,
      "ja": "8.2.1。 「イベント」ヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "Event is added to the definition of the element \"message-header field\" in the SIP message grammar.",
      "ja": "イベントは、SIPメッセージ文法の要素「メッセージヘッダフィールド」の定義に追加されます。"
    },
    {
      "indent": 3,
      "text": "For the purposes of matching NOTIFY requests with SUBSCRIBE requests, the event-type portion of the \"Event\" header field is compared byte by byte, and the \"id\" parameter token (if present) is compared byte by byte. An \"Event\" header field containing an \"id\" parameter never matches an \"Event\" header field without an \"id\" parameter. No other parameters are considered when performing a comparison. SUBSCRIBE responses are matched per the transaction handling rules in [RFC3261].",
      "ja": "SUBSCRIBEリクエストとNOTIFYリクエストをマッチングする目的のため、「イベント」ヘッダフィールドのイベント型部分は、バイトごとに比較され、「ID」パラメータトークン（存在する場合）はバイトごとに比較されます。 「ID」パラメータを含む「イベント」ヘッダフィールドは「ID」パラメータなしで「イベント」ヘッダフィールドに一致することはありません。比較を実行するときは、他のパラメータは考慮されていません。 SUBSCRIBE応答は[RFC3261]でルールを扱うトランザクションごとに一致しています。"
    },
    {
      "indent": 6,
      "text": "Note that the foregoing text means that \"Event: foo; id=1234\" would match \"Event: foo; param=abcd; id=1234\", but not \"Event: foo\" (\"id\" does not match) or \"Event: Foo; id=1234\" (\"Event\" portion does not match).",
      "ja": "（注）上記のテキストは、その \"イベント：FOO; ID = 1234\" を意味することと一致するであろう \"イベント：FOO; PARAM = ABCD; ID = 1234\" ではなく、 \"イベント：FOO\"（ \"ID\" と一致しない）、または「イベント：フー; ID = 1234\" （ \"イベント\" の部分が一致しません）。"
    },
    {
      "indent": 3,
      "text": "This document does not define values for event-types. These values will be defined by individual event packages and MUST be registered with the IANA.",
      "ja": "この文書では、イベント・タイプの値を定義していません。これらの値は、個々のイベントパッケージで定義されるであろうし、IANAに登録しなければなりません。"
    },
    {
      "indent": 3,
      "text": "There MUST be exactly one event type listed per \"Event\" header field. Multiple events per message are disallowed.",
      "ja": "「イベント」ヘッダフィールドごとに列挙された正確に一つのイベントタイプがあるに違いありません。メッセージごとに複数のイベントが許可されていません。"
    },
    {
      "indent": 3,
      "text": "The \"Event\" header field is defined only for use in SUBSCRIBE and NOTIFY requests and other requests whose definition explicitly calls for its use. It MUST NOT appear in any other SIP requests and MUST NOT appear in responses.",
      "ja": "「イベント」ヘッダフィールドのみSUBSCRIBEとNOTIFYリクエストとその定義が明示的にその使用を求めて他の要求で使用するために定義されています。これは、他のSIP要求に現れてはならないと応答に現れてはいけません。"
    },
    {
      "indent": 0,
      "text": "8.2.2. \"Allow-Events\" Header Field",
      "section_title": true,
      "ja": "8.2.2。 「許可 - イベント」ヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "\"Allow-Events\" is added to the definition of the element \"general-header field\" in the SIP message grammar. Its usage is described in Section 4.4.4.",
      "ja": "「許可・イベントは、」SIPメッセージ文法の要素「一般的なヘッダフィールド」の定義に追加されます。その使用法は、セクション4.4.4に記載されています。"
    },
    {
      "indent": 3,
      "text": "User agents MAY include the \"Allow-Events\" header field in any request or response, as long as its contents comply with the behavior described in Section 4.4.4.",
      "ja": "ユーザエージェントは限りその内容は、4.4.4項で説明した動作に準拠して、任意の要求または応答で「許可 - イベント」ヘッダフィールドを含んでいてもよいです。"
    },
    {
      "indent": 0,
      "text": "8.2.3. \"Subscription-State\" Header Field",
      "section_title": true,
      "ja": "8.2.3。 「サブスクリプション・ステート」ヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "\"Subscription-State\" is added to the definition of the element \"request-header\" field in the SIP message grammar. Its usage is described in Section 4.1.3. \"Subscription-State\" header fields are defined for use in NOTIFY requests only. They MUST NOT appear in other SIP requests or responses.",
      "ja": "「サブスクリプション・ステート」はSIPメッセージ文法の要素「リクエストヘッダ」フィールドの定義に追加されます。その使用法は、セクション4.1.3に記載されています。 「サブスクリプション・ステート」ヘッダフィールドは、リクエストのみをNOTIFYでの使用のために定義されています。彼らは、他のSIP要求または応答に現れてはいけません。"
    },
    {
      "indent": 0,
      "text": "8.3. New Response Codes",
      "section_title": true,
      "ja": "8.3。新しい応答コード"
    },
    {
      "indent": 0,
      "text": "8.3.1. 202 (Accepted) Response Code",
      "section_title": true,
      "ja": "8.3.1。 202（受理）応答コード"
    },
    {
      "indent": 3,
      "text": "For historical purposes, the 202 (Accepted) response code is added to the \"Success\" header field definition.",
      "ja": "歴史的目的のために、202（承認）応答コードが「成功」ヘッダフィールド定義に追加されます。"
    },
    {
      "indent": 3,
      "text": "This document does not specify the use of the 202 response code in conjunction with the SUBSCRIBE or NOTIFY methods. Previous versions of the SIP Events Framework assigned specific meaning to the 202 response code.",
      "ja": "この文書では、SUBSCRIBEまたはNOTIFY方法と併せて202応答コードの使用を指定していません。 SIPイベントフレームワークの以前のバージョンでは、202応答コードに特定の意味を割り当てます。"
    },
    {
      "indent": 3,
      "text": "Due to response handling in forking cases, any 202 response to a SUBSCRIBE request may be absorbed by a proxy, and thus it can never be guaranteed to be received by the UAC. Furthermore, there is no actual processing difference for a 202 as compared to a 200; a NOTIFY request is sent after the subscription is processed, and it conveys the correct state. SIP interoperability tests found that implementations were handling 202 differently from 200, leading to incompatibilities. Therefore, the 202 response is being deprecated to make it clear there is no such difference and 202 should not be handled differently than 200.",
      "ja": "例をフォークでハンドリング応答に、SUBSCRIBEリクエストへの202応答はプロキシによって吸収することができるので、UACによって受信されることを保証することはできません。また、200と比較して、202のための実際の処理の違いはありません。 A要求は、サブスクリプションが処理された後に送信されるNOTIFY、それが正しい状態を伝えます。 SIPの相互運用性テストは、非互換性につながる、実装が200とは異なる202を処理していることを見出しました。したがって、202応答がそこには、このような違いはありませんし、202は200よりも異なる方法で処理すべきではないことを明確にするために推奨されています。"
    },
    {
      "indent": 3,
      "text": "Implementations conformant with the current specification MUST treat an incoming 202 response as identical to a 200 response and MUST NOT generate 202 response codes to SUBSCRIBE or NOTIFY requests.",
      "ja": "現在の仕様に準拠した実装は、200応答と同じように、着信202応答を扱わなければなりませんし、SUBSCRIBE要求又は通知する202のレスポンスコードを生成してはいけません。"
    },
    {
      "indent": 3,
      "text": "This document also updates [RFC4660], which reiterates the 202-based behavior in several places. Implementations compliant with the present document MUST NOT send a 202 response to a SUBSCRIBE request and will send an alternate success response (such as 200) in its stead.",
      "ja": "この文書はまた、いくつかの場所で202ベースの行動を改めて表明[RFC4660]を、更新します。本文書に対応する実装は、SUBSCRIBEリクエストに対する202応答を送信してはいけません、その代わりに代替の成功応答（例えば、200）を送信します。"
    },
    {
      "indent": 0,
      "text": "8.3.2. 489 (Bad Event) Response Code",
      "section_title": true,
      "ja": "8.3.2。 489（不良イベント）応答コード"
    },
    {
      "indent": 3,
      "text": "The 489 event response is added to the \"Client-Error\" header field definition. 489 (Bad Event) is used to indicate that the server did not understand the event package specified in a \"Event\" header field.",
      "ja": "489イベント応答は、「クライアントエラー」ヘッダフィールド定義に追加されます。 489（不良イベント）は、サーバーが「イベント」ヘッダフィールドで指定されたイベントパッケージを理解していなかったことを示すために使用されます。"
    },
    {
      "indent": 0,
      "text": "8.4. Augmented BNF Definitions",
      "section_title": true,
      "ja": "8.4。拡張BNFの定義"
    },
    {
      "indent": 3,
      "text": "The Augmented BNF [RFC5234] definitions for the various new and modified syntax elements follows. The notation is as used in [RFC3261], and any elements not defined in this section are as defined in SIP and the documents to which it refers.",
      "ja": "増補BNF [RFC5234]様々な新しい及び修飾シンタックス要素の定義は以下の通りです。 [RFC3261]で使用される表記法であり、SIPおよびそれが参照する文書で定義されるように、このセクションで定義されていない任意の要素です。"
    },
    {
      "indent": 3,
      "text": "SUBSCRIBEm = %x53.55.42.53.43.52.49.42.45 ; SUBSCRIBE in caps NOTIFYm = %x4E.4F.54.49.46.59 ; NOTIFY in caps extension-method = SUBSCRIBEm / NOTIFYm / token",
      "ja": "SUBSCRIBEm =％x53.55.42.53.43.52.49.42.45。キャップにSUBSCRIBE NOTIFYm =％x4E.4F.54.49.46.59。キャップ拡張方式= SUBSCRIBEm / NOTIFYm /トークンにNOTIFY"
    },
    {
      "indent": 3,
      "text": "Event = ( \"Event\" / \"o\" ) HCOLON event-type *( SEMI event-param ) event-type = event-package *( \".\" event-template ) event-package = token-nodot event-template = token-nodot token-nodot = 1*( alphanum / \"-\" / \"!\" / \"%\" / \"*\" / \"_\" / \"+\" / \"`\" / \"'\" / \"~\" )",
      "ja": "イベント=（「イベント」/「O」）HCOLONイベント型*（SEMIイベントのparam）イベント型=イベントパッケージ*（「」イベントテンプレート）イベント・パッケージ=トークンnodotイベント・テンプレート=トークン-nodotトークンnodot = 1 *（alphanum / \" - \" \"！\" / / \"％\" / \"*\" / \"_\" / \"+\" / \"`\"/ \"'\"/ \"〜\"）"
    },
    {
      "indent": 3,
      "text": "; The use of the \"id\" parameter is deprecated; it is included ; for backwards-compatibility purposes only.",
      "ja": "; 「ID」パラメータの使用が推奨されていません。それが含まれています。唯一の後方互換性の目的のために。"
    },
    {
      "indent": 3,
      "text": "event-param = generic-param / ( \"id\" EQUAL token )",
      "ja": "イベント-PARAM =ジェネリック-PARAM /（ \"ID\" EQUALトークン）"
    },
    {
      "indent": 3,
      "text": "Allow-Events = ( \"Allow-Events\" / \"u\" ) HCOLON event-type *(COMMA event-type)",
      "ja": "許可 - イベント=（「許可 - イベント」/「U」）HCOLONイベント型*（COMMAイベント型）"
    },
    {
      "indent": 3,
      "text": "Subscription-State = \"Subscription-State\" HCOLON substate-value *( SEMI subexp-params ) substate-value = \"active\" / \"pending\" / \"terminated\" / extension-substate extension-substate = token subexp-params = (\"reason\" EQUAL event-reason-value) / (\"expires\" EQUAL delta-seconds) / (\"retry-after\" EQUAL delta-seconds) / generic-param event-reason-value = \"deactivated\" / \"probation\" / \"rejected\" / \"timeout\" / \"giveup\" / \"noresource\" / \"invariant\" / event-reason-extension event-reason-extension = token",
      "ja": "サブスクリプション・ステート= \"サブスクリプション・ステート\" HCOLONサブ状態値*（SEMI subexp-のparams）サブステート値= \"アクティブ\" / \"保留\" / \"終了\" /拡張サブステート延長-サブステート=トークンsubexp-のparams =（」理由は \"EQUALイベント-理由値）/（ \"期限が切れる\"）EQUALデルタ秒/（ \"リトライ-後に\" EQUALデルタ秒）/ジェネリック-PARAMイベント-理由-値は= \"非アクティブ化\"/ \"執行猶予\"/\" 「/ 『タイムアウト』 / 『ギブアップ』 / 『NORESOURCE』 / 『不変』 /イベント-理由拡張イベントの理由-延長=トークン拒否"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2848] Petrack, S. and L. Conroy, \"The PINT Service Protocol: Extensions to SIP and SDP for IP Access to Telephone Call Services\", RFC 2848, June 2000.",
      "ja": "[RFC2848] 2000 Petrackと、S.とL.コンロイ、 \"パイントサービスプロトコル：電話コールサービスへのIPアクセスのためのSIPとSDPへの拡張\"、RFC 2848、2000年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[RFC3261]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 \"SIP：セッション開始プロトコル\" 、RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3265] Roach, A., \"Session Initiation Protocol (SIP)-Specific Event Notification\", RFC 3265, June 2002.",
      "ja": "[RFC3265]ローチ、A.、 \"セッション開始プロトコル（SIP）特異的イベント通知\"、RFC 3265、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3968] Camarillo, G., \"The Internet Assigned Number Authority (IANA) Header Field Parameter Registry for the Session Initiation Protocol (SIP)\", BCP 98, RFC 3968, December 2004.",
      "ja": "[RFC3968]キャマリロ、G.、BCP 98、RFC 3968、2004年12月 \"インターネットは、セッション開始プロトコル（SIP）のための番号機関（IANA）ヘッダーフィールドパラメータレジストリを割り当てられました\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4483] Burger, E., \"A Mechanism for Content Indirection in Session Initiation Protocol (SIP) Messages\", RFC 4483, May 2006.",
      "ja": "[RFC4483]バーガー、E.、 \"セッション開始プロトコル（SIP）におけるコンテンツの間接化の仕組みメッセージ\"、RFC 4483、2006年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5627] Rosenberg, J., \"Obtaining and Using Globally Routable User Agent URIs (GRUUs) in the Session Initiation Protocol (SIP)\", RFC 5627, October 2009.",
      "ja": "[RFC5627]ローゼンバーグ、J.、RFC 5627、2009年10月 \"セッション開始プロトコル（SIP）でグローバルにルーティング可能なユーザエージェントのURI（GRUUs）の取得と使用\" を参照してください。"
    },
    {
      "indent": 3,
      "text": "[RFC5727] Peterson, J., Jennings, C., and R. Sparks, \"Change Process for the Session Initiation Protocol (SIP) and the Real-time Applications and Infrastructure Area\", BCP 67, RFC 5727, March 2010.",
      "ja": "[RFC5727]ピーターソン、J.、ジェニングス、C.、およびR.スパークス、BCP 67、RFC 5727、2010年3月 \"セッション開始プロトコル（SIP）とリアルタイムアプリケーションとインフラストラクチャ領域の変更処理\"。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC2779] Day, M., Aggarwal, S., Mohr, G., and J. Vincent, \"Instant Messaging / Presence Protocol Requirements\", RFC 2779, February 2000.",
      "ja": "[RFC2779]の日、M.、アガルワル、S.、モール、G.、およびJ.ヴィンセント、 \"インスタントメッセージング/プレゼンスプロトコル要件\"、RFC 2779、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3515] Sparks, R., \"The Session Initiation Protocol (SIP) Refer Method\", RFC 3515, April 2003.",
      "ja": "[RFC3515]スパークス、R.、 \"セッション開始プロトコル（SIP）メソッドを参照してください\"、RFC 3515、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3840] Rosenberg, J., Schulzrinne, H., and P. Kyzivat, \"Indicating User Agent Capabilities in the Session Initiation Protocol (SIP)\", RFC 3840, August 2004.",
      "ja": "[RFC3840]ローゼンバーグ、J.、Schulzrinneと、H.、およびP. Kyzivat、RFC 3840、2004年8月 \"セッション開始プロトコル（SIP）におけるユーザエージェントの能力を示します\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3891] Mahy, R., Biggs, B., and R. Dean, \"The Session Initiation Protocol (SIP) \"Replaces\" Header\", RFC 3891, September 2004.",
      "ja": "[RFC3891]マーイ、R.、ビッグス、B.、およびR.ディーン、 \"セッション開始プロトコル（SIP） \"は、\" ヘッダ\" を置き換えRFC 3891、2004年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3903] Niemi, A., \"Session Initiation Protocol (SIP) Extension for Event State Publication\", RFC 3903, October 2004.",
      "ja": "[RFC3903]ニエミ、A.、 \"イベント状態の出版のためのセッション開始プロトコル（SIP）の拡張\"、RFC 3903、2004年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC3911] Mahy, R. and D. Petrie, \"The Session Initiation Protocol (SIP) \"Join\" Header\", RFC 3911, October 2004.",
      "ja": "[RFC3911]マーイ、R.とD.ペトリー、 \"セッション開始プロトコル（SIP）は、 \"\" ヘッダ\"、RFC 3911、2004年10月に参加しましょう。"
    },
    {
      "indent": 3,
      "text": "[RFC4235] Rosenberg, J., Schulzrinne, H., and R. Mahy, \"An INVITE-Initiated Dialog Event Package for the Session Initiation Protocol (SIP)\", RFC 4235, November 2005.",
      "ja": "[RFC4235]ローゼンバーグ、J.、Schulzrinneと、H.、およびR.マーイ、RFC 4235、2005年11月 \"セッション開始プロトコル（SIP）のためのINVITEが開始ダイアログイベントパッケージ\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4288] Freed, N. and J. Klensin, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 4288, December 2005.",
      "ja": "[RFC4288]解放され、N.とJ. Klensin、 \"メディアタイプの仕様と登録手順\"、BCP 13、RFC 4288、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4485] Rosenberg, J. and H. Schulzrinne, \"Guidelines for Authors of Extensions to the Session Initiation Protocol (SIP)\", RFC 4485, May 2006.",
      "ja": "[RFC4485]ローゼンバーグ、J.とH. Schulzrinneと、RFC 4485、2006年5月 \"セッション開始プロトコル（SIP）への拡張の作者のためのガイドライン\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4538] Rosenberg, J., \"Request Authorization through Dialog Identification in the Session Initiation Protocol (SIP)\", RFC 4538, June 2006.",
      "ja": "[RFC4538]、RFC 4538、2006年6月ローゼンバーグ、J.、 \"セッション開始プロトコル（SIP）におけるダイアログ識別介して要求承認\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4660] Khartabil, H., Leppanen, E., Lonnfors, M., and J. Costa-Requena, \"Functional Description of Event Notification Filtering\", RFC 4660, September 2006.",
      "ja": "[RFC4660] Khartabil、H.、Leppanen、E.、Lonnfors、M.、およびJ.コスタ・レケーナ、 \"イベント通知フィルタリングの機能説明\"、RFC 4660、2006年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5057] Sparks, R., \"Multiple Dialog Usages in the Session Initiation Protocol\", RFC 5057, November 2007.",
      "ja": "[RFC5057]スパークス、R.、 \"セッション開始プロトコルの複数の対話用法\"、RFC 5057、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5839] Niemi, A. and D. Willis, \"An Extension to Session Initiation Protocol (SIP) Events for Conditional Event Notification\", RFC 5839, May 2010.",
      "ja": "[RFC5839]ニエミ、A.とD.ウィリス、RFC 5839、2010年5月 \"条件付きイベント通知のためのセッション開始プロトコル（SIP）のイベントへの拡大\"。"
    },
    {
      "indent": 3,
      "text": "[CERT1998a] CERT, \"CERT Advisory CA-1998-01: Smurf IP Denial-of-Service Attacks\", 1998, <http://www.cert.org/advisories/CA-1998-01.html>.",
      "ja": "[CERT1998a] CERT、 \"CERT勧告CA-1998から01：スマーフIPサービス拒否攻撃\"、1998年、<http://www.cert.org/advisories/CA-1998-01.html>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Acknowledgements",
      "ja": "付録A.謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to the participants in the Events BOF at the 48th IETF meeting in Pittsburgh, as well as those who gave ideas and suggestions on the SIP Events mailing list. In particular, I wish to thank Henning Schulzrinne of Columbia University for coming up with the final three-tiered event identification scheme, Sean Olson for miscellaneous guidance, Jonathan Rosenberg for a thorough scrubbing of the first draft version, and the authors of the \"SIP Extensions for Presence\" document for their input to SUBSCRIBE and NOTIFY request semantics.",
      "ja": "ピッツバーグの第48回IETF会合でイベントBOFと同様に、メーリングリストSIPイベントにアイデアや提案を与えた人たちの参加者に感謝します。具体的には、私が最初のドラフト版を徹底的にスクラブのための最終的な3階層イベント識別方式で、雑多な指導のためのショーン・オルソン、ジョナサン・ローゼンバーグを考え出すためにコロンビア大学のヘニングSchulzrinneとに感謝したい、と「SIPの著者彼らの入力のためのプレゼンス」文書のための拡張機能は、SUBSCRIBEリクエストのセマンティクスに通知します。"
    },
    {
      "indent": 3,
      "text": "I also owe a debt of gratitude to all the implementors who have provided feedback on areas of confusion or difficulty in the original specification. In particular, Robert Sparks' Herculean efforts organizing, running, and collecting data from the SIPit events have proven invaluable in shaking out specification bugs. Robert Sparks is also responsible for untangling the dialog usage mess, in the form of RFC 5057 [RFC5057].",
      "ja": "私はまた、元の仕様で混乱や難易度の領域にフィードバックを提供している全ての実装者への感謝の負債を負います。具体的には、ロバート・スパークス超人的な努力は、組織ランニング、とSIPitイベントからのデータを収集することは仕様上のバグを振っに貴重であることが判明しました。ロバート・スパークスもRFC 5057 [RFC5057]の形式で、ダイアログ用法の混乱をuntanglingする責任があります。"
    },
    {
      "indent": 1,
      "text": "Appendix B. Changes from",
      "ja": "付録B.変更から"
    },
    {
      "indent": 3,
      "text": "This document represents several changes from the mechanism originally described in RFC 3265. This section summarizes those changes. Bug numbers refer to the identifiers for the bug reports kept on file at http://bugs.sipit.net/.",
      "ja": "この文書は、もともとRFC 3265このセクションでは、これらの変更をまとめたもので説明した機構からのいくつかの変化を表します。バグ番号はhttp://bugs.sipit.net/でファイルに保管バグレポートのための識別子を参照してください。"
    },
    {
      "indent": 0,
      "text": "B.1. Bug 666: Clarify use of \"expires=xxx\" with \"terminated\"",
      "ja": "B.1。バグ666：「終了」と「= xxxの満了」の使用を明確に"
    },
    {
      "indent": 3,
      "text": "Strengthened language in Section 4.1.3 to clarify that \"expires\" should not be sent with \"terminated\", and must be ignored if received.",
      "ja": "セクション4.1.3で強化言語は、「期限が切れる」「終了」を送るべきではありませんし、受信した場合は無視されなければならないことを明確にします。"
    },
    {
      "indent": 0,
      "text": "B.2. Bug 667: Reason code for unsub/poll not clearly spelled out",
      "ja": "B.2。バグ667：UNSUB /世論調査はっきり綴らないための理由コード"
    },
    {
      "indent": 3,
      "text": "Clarified description of \"timeout\" in Section 4.1.3. (n.b., the text in Section 4.4.3 is actually pretty clear about this).",
      "ja": "4.1.3項で「タイムアウト」の記述を明らかにしました。 （n.b.、4.4.3のテキストは、実際にはこのことについてかなり明確です）。"
    },
    {
      "indent": 0,
      "text": "B.3. Bug 669: Clarify: SUBSCRIBE for a duration might be answered with a NOTIFY/expires=0",
      "ja": "B.3。バグ669：明確化：期間中、SUBSCRIBEは= 0期限切れになる/ NOTIFYと答えたことがあります"
    },
    {
      "indent": 3,
      "text": "Added clarifying text to Section 4.2.2 explaining that shortening a subscription to zero seconds is valid. Also added sentence to Section 3.1.1 explicitly allowing shortening to zero.",
      "ja": "ゼロ秒にサブスクリプションを短縮することは有効であることを説明するセクション4.2.2にテキストを明確に追加しました。また、明示的にゼロに短縮することができ、セクション3.1.1に文を追加しました。"
    },
    {
      "indent": 0,
      "text": "B.4. Bug 670: Dialog State Machine needs clarification",
      "ja": "B.4。バグ670：ダイアログステートマシンを明確にする必要があります"
    },
    {
      "indent": 3,
      "text": "The issues associated with the bug deal exclusively with the handling of multiple usages with a dialog. This behavior has been deprecated and moved to Section 4.5.2. This section, in turn, cites [RFC5057], which addresses all of the issues in Bug 670.",
      "ja": "ダイアログで複数の用法の取り扱いに専用のバグの契約に関連する問題。この動作は非推奨と4.5.2に移動されました。このセクションでは、今度は、バグ670で問題のすべてを解決する[RFC5057]を、引用しています。"
    },
    {
      "indent": 0,
      "text": "B.5. Bug 671: Clarify timeout-based removal of subscriptions",
      "ja": "B.5。バグ671：サブスクリプションのタイムアウトベースの除去を明確化"
    },
    {
      "indent": 3,
      "text": "Changed Section 4.2.2 to specifically cite Timer F (so as to avoid ambiguity between transaction timeouts and retransmission timeouts).",
      "ja": "変更4.2.2項では、具体的タイマF（トランザクションタイムアウトと再送タイムアウト間のあいまいさを避けるように）引用します。"
    },
    {
      "indent": 0,
      "text": "B.6. Bug 672: Mandate \"expires\" in NOTIFY",
      "ja": "B.6。バグ672：任務はでNOTIFY「期限が切れ」"
    },
    {
      "indent": 3,
      "text": "Changed strength of including of \"expires\" in a NOTIFY from \"SHOULD\" to \"MUST\" in Section 4.2.2.",
      "ja": "4.2.2での「MUST」「SHOULD」からNOTIFYに「期限が切れる」の含むの変更強。"
    },
    {
      "indent": 0,
      "text": "B.7. Bug 673: INVITE 481 response effect clarification",
      "ja": "B.7。バグ673：481応答効果の明確化をINVITE"
    },
    {
      "indent": 3,
      "text": "This bug was addressed in [RFC5057].",
      "ja": "このバグは、[RFC5057]で扱われました。"
    },
    {
      "indent": 0,
      "text": "B.8. Bug 677: SUBSCRIBE response matching text in error",
      "ja": "B.8。バグ677：エラーのレスポンス一致するテキストをSUBSCRIBE"
    },
    {
      "indent": 3,
      "text": "Fixed Section 8.2.1 to remove incorrect \"...responses and...\" -- explicitly pointed to SIP for transaction response handling.",
      "ja": "間違った「...応答と...」を削除するには、セクション8.2.1を修正 - 明示的にトランザクションのレスポンスの処理のためのSIPに指摘しました。"
    },
    {
      "indent": 0,
      "text": "B.9. Bug 695: Document is not explicit about response to NOTIFY at subscription termination",
      "ja": "B.9。バグ695：ドキュメントは、サブスクリプションの終了時に通知するために、応答に関する明示的ではありません"
    },
    {
      "indent": 3,
      "text": "Added text to Section 4.4.1 indicating that the typical response to a terminal NOTIFY is a 200 (OK).",
      "ja": "端末への典型的な応答は、200（OK）であることを示すNOTIFY 4.4.1にテキストを追加しました。"
    },
    {
      "indent": 0,
      "text": "B.10. Bug 696: Subscription state machine needs clarification",
      "ja": "B.10。バグ696：サブスクリプションの状態マシンが明確化が必要です"
    },
    {
      "indent": 3,
      "text": "Added state machine diagram to Section 4.1.2 with explicit handling of what to do when a SUBSCRIBE never shows up. Added definition of and handling for new Timer N to Section 4.1.2.4. Added state machine to Section 4.2.2 to reinforce text.",
      "ja": "SUBSCRIBEときに何をすべきかの明示的な取り扱いと4.1.2項を追加しましたステートマシン図は決して現れません。 4.1.2.4節に新しいタイマーNのための定義および取り扱いを追加しました。テキストを強化するために、セクション4.2.2にステートマシンを追加しました。"
    },
    {
      "indent": 0,
      "text": "B.11. Bug 697: Unsubscription behavior could be clarified",
      "ja": "B.11。バグ697：脱退行動を明確にすることができ"
    },
    {
      "indent": 3,
      "text": "Added text to Section 4.2.1.4 encouraging (but not requiring) full state in final NOTIFY request. Also added text to Section 4.1.2.3 warning subscribers that full state may or may not be present in the final NOTIFY.",
      "ja": "セクション4.2.1.4は心強い（しかし必要としない）NOTIFYリクエストを最終的に完全な状態にするテキストを追加しました。また、フル状態がまたは最終NOTIFYであってもなくてもよいというセクション4.1.2.3警告加入者にテキストを追加しました。"
    },
    {
      "indent": 0,
      "text": "B.12. Bug 699: NOTIFY and SUBSCRIBE are target refresh requests",
      "ja": "B.12。バグ699：NOTIFYおよびSUBSCRIBEターゲットリフレッシュ要求されています"
    },
    {
      "indent": 3,
      "text": "Added text to both Sections 3.1 and 3.2 explicitly indicating that SUBSCRIBE and NOTIFY are target refresh methods.",
      "ja": "明示的には、ターゲットリフレッシュ方法ですSUBSCRIBEとNOTIFY示す両方のセクション3.1および3.2に追加されたテキスト。"
    },
    {
      "indent": 0,
      "text": "B.13. Bug 722: Inconsistent 423 reason phrase text",
      "ja": "B.13。バグ722：一貫性のない423の理由フレーズテキスト"
    },
    {
      "indent": 3,
      "text": "Changed reason phrase to \"Interval Too Brief\" in Sections 4.2.1.1 and 4.2.1.4, to match 423 reason phrase in SIP [RFC3261].",
      "ja": "「間隔短すぎる」のセクション4.2.1.1と4.2.1.4に変更理由フレーズは、SIP [RFC3261]で423理由フレーズを一致させます。"
    },
    {
      "indent": 0,
      "text": "B.14. Bug 741: Guidance needed on when to not include \"Allow-Events\"",
      "ja": "B.14。バグ741：ガイダンスは、「許可 - イベント」を含まないようにする場合に必要"
    },
    {
      "indent": 3,
      "text": "Added non-normative clarification to Section 4.4.4 regarding inclusion of \"Allow-Events\" in a NOTIFY for the one-and-only package supported by the notifier.",
      "ja": "通知でサポートされている1つ-とのみのパッケージのためにNOTIFYで「許可 - イベント」を含めることについて、セクション4.4.4に非規範的な説明を追加しました。"
    },
    {
      "indent": 0,
      "text": "B.15. Bug 744: 5xx to NOTIFY terminates a subscription, but should not",
      "ja": "B.15。バグ744：5xxのNOTIFYするには、サブスクリプションを終了しますが、いけません"
    },
    {
      "indent": 3,
      "text": "Issue of subscription (usage) termination versus dialog termination is handled in [RFC5057]. The text in Section 4.2.2 has been updated to summarize the behavior described by RFC 5057, and cites it for additional detail and rationale.",
      "ja": "ダイアログ終了に対するサブスクリプション（使用）終了の問題は、[RFC5057]で処理されます。 4.2.2内のテキストはRFC 5057で説明した動作を要約するように更新され、追加の詳細と根拠のためにそれを引用されています。"
    },
    {
      "indent": 0,
      "text": "B.16. Bug 752: Detection of forked requests is incorrect",
      "ja": "B.16。バグ752：フォーク要求の検出が正しくありません"
    },
    {
      "indent": 3,
      "text": "Removed erroneous \"CSeq\" from list of matching criteria in Section 5.4.9.",
      "ja": "セクション5.4.9で一致する基準のリストから誤って「のCSeq」を削除しました。"
    },
    {
      "indent": 0,
      "text": "B.17. Bug 773: Reason code needs IANA registry",
      "ja": "B.17。バグ773：理由コードは、IANAレジストリを必要とします"
    },
    {
      "indent": 3,
      "text": "Added Section 7.2 to create and populate IANA registry.",
      "ja": "IANAレジストリを作成して移入するセクション7.2を追加しました。"
    },
    {
      "indent": 0,
      "text": "B.18. Bug 774: Need new reason for terminating subscriptions to resources that never change",
      "ja": "B.18。バグ774：決して変更リソースへのサブスクリプションを終了するための新しい理由が必要"
    },
    {
      "indent": 3,
      "text": "Added new \"invariant\" reason code to Section 4.1.3 and to ABNF syntax in Section 8.4.",
      "ja": "セクション4.1.3に新しい「不変」理由コードを追加し、8.4節の構文をABNFします。"
    },
    {
      "indent": 0,
      "text": "B.19. Clarify Handling of \"Route\"/\"Record-Route\" in NOTIFY",
      "ja": "B.19。 NOTIFYに「ルート」/「レコード・ルート」の取り扱いを明確に"
    },
    {
      "indent": 3,
      "text": "Changed text in Section 4.3 in order to mandate \"Record-Route\" in initial SUBSCRIBE and all NOTIFY requests, and add \"MAY\"-level statements for subsequent SUBSCRIBE requests.",
      "ja": "SUBSCRIBEと、すべての要求を通知し、その後のSUBSCRIBEリクエストのための「MAY」レベルの文を追加し、最初に「レコード・ルート」を義務化するために、4.3節で変更されたテキスト。"
    },
    {
      "indent": 0,
      "text": "B.20. Eliminate Implicit Subscriptions",
      "ja": "B.20。暗黙のサブスクリプションを排除"
    },
    {
      "indent": 3,
      "text": "Added text to Section 4.2.1 explaining some of the problems associated with implicit subscriptions, and added normative language prohibiting them. Removed language from Section 3.2 describing \"non-SUBSCRIBE\" mechanisms for creating subscriptions. Simplified language in Section 4.2.2, now that the soft-state/non-soft-state distinction is unnecessary.",
      "ja": "追加しました暗黙のサブスクリプションに関連付けられている問題のいくつかを説明するセクション4.2.1にテキスト、およびそれらを禁止する規範的な言語を追加しました。サブスクリプションを作成するための「非SUBSCRIBE」のメカニズムを説明3.2節から言語を削除しました。セクション4.2.2で簡体語、今やソフトステート/非ソフトステートの区別が不要であること。"
    },
    {
      "indent": 0,
      "text": "B.21. Deprecate Dialog Reuse",
      "ja": "B.21。廃止ダイアログの再利用"
    },
    {
      "indent": 3,
      "text": "Moved handling of dialog reuse and \"id\" handling to Section 4.5.2. It is documented only for backwards-compatibility purposes.",
      "ja": "ダイアログの再利用および4.5.2に扱う「ID」の取り扱いを移動しました。これは、後方互換性のためにのみ記載されています。"
    },
    {
      "indent": 0,
      "text": "B.22. Rationalize Dialog Creation",
      "ja": "B.22。ダイアログの作成を合理化"
    },
    {
      "indent": 3,
      "text": "Section 4.4.1 has been updated to specify that dialogs should be created when the NOTIFY arrives. Previously, the dialog was established by the SUBSCRIBE 200 or by the NOTIFY transaction. This was unnecessarily complicated; the newer rules are easier to implement (and result in effectively the same behavior on the wire).",
      "ja": "4.4.1項ではインクルードが到着したNOTIFY時にダイアログを作成するように指定するように更新されました。以前は、ダイアログはSUBSCRIBE 200またはNOTIFYトランザクションによって設立されました。これは、不必要に複雑でした。新しいルールが実装（およびワイヤ上の実質的に同じ動作を引き起こす）が容易です。"
    },
    {
      "indent": 0,
      "text": "B.23. Refactor Behavior Sections",
      "ja": "B.23。リファクタリングの動作セクション"
    },
    {
      "indent": 3,
      "text": "Reorganized Section 4 to consolidate behavior along role lines (subscriber/notifier/proxy) instead of method lines.",
      "ja": "再編成セクション4は、ロールライン（加入/通知/プロキシ）の代わりに、メソッド線に沿って行動を統合します。"
    },
    {
      "indent": 0,
      "text": "B.24. Clarify Sections That Need to Be Present in Event Packages",
      "ja": "B.24。イベントパッケージに存在する必要がセクションを明確に"
    },
    {
      "indent": 3,
      "text": "Added sentence to Section 5 clarifying that event packages are expected to include explicit sections covering the issues discussed in this section.",
      "ja": "そのイベントパッケージを明確に第5節に追加しましたセンテンスは、このセクションで説明する問題をカバーする、明示的なセクションを含むことが予想されます。"
    },
    {
      "indent": 0,
      "text": "B.25. Make CANCEL Handling More Explicit",
      "ja": "B.25。より明示的な取り扱い中止してください"
    },
    {
      "indent": 3,
      "text": "Text in Section 4.6 now clearly calls out behavior upon receipt of a CANCEL. We also echo the \"...SHOULD NOT send...\" requirement from [RFC3261].",
      "ja": "セクション4.6のテキストは今はっきりとCANCELの受信時の挙動を呼び出します。また、[RFC3261]から「...送っべきではありません...」の要件をエコー。"
    },
    {
      "indent": 0,
      "text": "B.26. Remove \"State Agent\" Terminology",
      "ja": "B.26。 「国家エージェント」の用語を削除"
    },
    {
      "indent": 3,
      "text": "As originally planned, we anticipated a fairly large number of event packages that would move back and forth between end-user devices and servers in the network. In practice, this has ended up not being the case. Certain events, like dialog state, are inherently hosted at end-user devices; others, like presence, are almost always hosted in the network (due to issues like composition, and the ability to deliver information when user devices are offline). Further, the concept of State Agents is the most misunderstood by event package authors. In my expert review of event packages, I have yet to find one that got the concept of State Agents completely correct -- and most of them start out with the concept being 100% backwards from the way RFC 3265 described it.",
      "ja": "当初の計画通り、我々はネットワーク内のエンドユーザデバイスとサーバーの間で前後に移動するイベントパッケージのかなり大きな数を予想しました。実際には、これはケースされていない終わりました。特定のイベントは、対話状態のように、本質的にエンドユーザデバイスでホストされています。存在のような他のものは、ほとんど常に（による構図のような問題に、ユーザデバイスがオフラインになっているときの情報をお届けする能力）ネットワークでホストされています。さらに、国家のエージェントの概念は、ほとんどのイベントパッケージの作者によって誤解されます。イベントパッケージの私の専門家のレビューでは、私は完全に正しい状態エージェントの概念を得たものを見つけるためには至っていない - と、それらのほとんどは、RFC 3265がそれを説明した方法から100％後方というコンセプトでスタート。"
    },
    {
      "indent": 3,
      "text": "Rather than remove the ability to perform the actions previously attributed to the widely misunderstood term \"State Agent\", we have simply eliminated this term. Instead, we talk about the behaviors required to create state agents (state aggregation, subscription notification) without defining a formal term to describe the servers that exhibit these behaviors. In effect, this is an editorial change to make life easier for event package authors; the actual protocol does not change as a result.",
      "ja": "むしろ以前に広く誤解される用語「国家エージェント」に起因するアクションを実行する機能を削除するよりも、我々は単にこの用語を排除しました。代わりに、私たちは、これらの行動を示すのサーバーを記述するための正式な用語を定義することなく、状態エージェント（状態集約、サブスクリプションの通知）を作成するために必要な行動について話しています。実際には、これは、イベントパッケージの作者のための人生を容易にするために、編集上の変更です。実際のプロトコルは、結果として変化しません。"
    },
    {
      "indent": 3,
      "text": "The definition of \"State Agent\" has been removed from Section 2. Section 4.4.2 has been retooled to discuss migration of subscription in general, without calling out the specific example of state agents. Section 5.4.11 has been focused on state aggregation in particular, instead of state aggregation as an aspect of state agents.",
      "ja": "「国家エージェント」の定義は、4.4.2項は、状態の薬剤の具体的な例を呼び出さずに、一般的にはサブスクリプションの移行を議論するために一新された第2節から削除されました。セクション5.4.11状態剤の態様として、代わりに状態凝集の、特定の状態の集合が注目されています。"
    },
    {
      "indent": 0,
      "text": "B.27. Miscellaneous Changes",
      "ja": "B.27。その他の変更"
    },
    {
      "indent": 3,
      "text": "The following changes are relatively minor revisions to the document that resulted primarily from review of this document in the working group and IESG, rather than implementation reports.",
      "ja": "次の変更は、ワーキンググループでは、この文書のレビューとIESGはなく、実装の報告から主になった文書への比較的軽微な改定されています。"
    },
    {
      "indent": 3,
      "text": "o Clarified scope of \"Event\" header field parameters. In RFC 3265, the scope is ambiguous, which causes problems with the registry in RFC 3968. The new text ensures that \"Event\" header field parameters are unique across all event packages.",
      "ja": "O「イベント」ヘッダフィールドパラメータの範囲を明らかにしました。 RFC 3265では、スコープがRFC 3968.でレジストリの問題を引き起こす、曖昧で新しいテキストは、「イベント」ヘッダフィールドのパラメータは、すべてのイベントパッケージ全体で一意であることを保証します。"
    },
    {
      "indent": 3,
      "text": "o Removed obsoleted language around IANA registration policies for event packages. Instead, we now cite RFC 5727, which updates RFC 3265, and is authoritative on event package registration policy.",
      "ja": "OイベントパッケージのためのIANA登録ポリシーの周りに廃止された言語を削除しました。代わりに、私たちは今、RFC 3265を更新し、イベントパッケージの登録ポリシーに関する権威であるRFC 5727を引用します。"
    },
    {
      "indent": 3,
      "text": "o Several editorial updates after input from working group, including proper designation of \"dialog usage\" rather than \"dialog\" where needed.",
      "ja": "必要に応じてではなく、「ダイアログ」よりも「ダイアログの使用」の適切な指定を含む、ワーキンググループからの入力後にいくつかの編集上の更新O。"
    },
    {
      "indent": 3,
      "text": "o Clarified two normative statements about subscription termination by changing from plain English prose to RFC2119 language.",
      "ja": "O RFC2119言語に平易な英語散文から変更することによって、サブスクリプション終了の約2規範的な文を明らかにしました。"
    },
    {
      "indent": 3,
      "text": "o Removed \"Table 2\" expansions, per WG consensus on how SIP Table 2 is to be handled.",
      "ja": "O SIP表2を処理する方法にWGコンセンサスあたり「表2」の拡張を除去。"
    },
    {
      "indent": 3,
      "text": "o Removed 202 response code.",
      "ja": "O 202応答コードを削除。"
    },
    {
      "indent": 3,
      "text": "o Clarified that \"Allow-Events\" does not list event template-packages.",
      "ja": "O「許可 - イベントは」イベントテンプレートパッケージをリストしないことを明らかにしました。"
    },
    {
      "indent": 3,
      "text": "o Added clarification about proper response when the SUBSCRIBE indicates an unknown media type in its \"Accept\" header field.",
      "ja": "SUBSCRIBEは、そのヘッダフィールドを「受け入れ」で、未知のメディアタイプを示している場合、Oの適切な対応についての説明を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Minor clarifications to \"Route\" and \"Record-Route\" behavior.",
      "ja": "「ルート」と「レコード・ルート」行動にOマイナー明確化。"
    },
    {
      "indent": 3,
      "text": "o Added non-normative warning about the limitations of state polling.",
      "ja": "O状態のポーリングの制限に関する非規範的な警告を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Added information about targeting subscriptions at specific dialogs.",
      "ja": "O特定のダイアログでサブスクリプションをターゲットに関する情報を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Added RFC 3261 to list of documents updated by this one (rather than the \"2543\" indicated by RFC 3265).",
      "ja": "O（むしろRFC 3265で示される「2543」より）この1によって更新された文書のリストにRFC 3261を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Clarified text in Section 3.1.1 explaining the meaning of \"Expires: 0\".",
      "ja": "O「：0期限」の意味を説明するセクション3.1.1のテキストを明確化。"
    },
    {
      "indent": 3,
      "text": "o Changed text in definition of \"probation\" reason code to indicate that subscribers don't need to re-subscribe if the associated state is no longer of use to them.",
      "ja": "O加入者が関連する状態は、彼らにはもはや使用のある場合に再加入していないする必要がないことを示すために「保護観察」理由コードの定義にテキストを変更しました。"
    },
    {
      "indent": 3,
      "text": "o Specified that the termination of a subscription due to a NOTIFY transaction failure does not require sending another NOTIFY message.",
      "ja": "O指定したため、別のNOTIFYメッセージを送信する必要はありませんトランザクション障害を通知するために、サブスクリプションの終了。"
    },
    {
      "indent": 3,
      "text": "o Clarified how order of template application affects the meaning of an \"Event\" header field value (e.g., \"foo.bar.baz\" is different than \"foo.baz.bar\").",
      "ja": "Oテンプレートアプリケーションの順序は「イベント」ヘッダフィールド値の意味（例えば、「foo.bar.baz」が「foo.baz.bar」とは異なる）どのように影響するかを明らかにしました。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Adam Roach Tekelec 17210 Campbell Rd. Suite 250 Dallas, TX 75252 US",
      "ja": "アダムローチTekelec 17210キャンベルRdを。スイート250、ダラス、TX 75252米国"
    },
    {
      "indent": 3,
      "text": "EMail: adam@nostrum.com",
      "ja": "メールアドレス：adam@nostrum.com"
    }
  ]
}