{
  "title": {
    "text": "RFC 6290 - A Quick Crash Detection Method for the Internet Key Exchange Protocol (IKE)",
    "ja": "RFC 6290 - インターネット鍵交換プロトコル（IKE）のクイッククラッシュ検出法"
  },
  "number": 6290,
  "created_at": "2019-11-01 19:58:54.124735+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       Y. Nir, Ed.\nRequest for Comments: 6290                                   Check Point\nCategory: Standards Track                                  D. Wierbowski\nISSN: 2070-1721                                                      IBM\n                                                             F. Detienne\n                                                                P. Sethi\n                                                                   Cisco\n                                                               June 2011",
      "raw": true
    },
    {
      "indent": 17,
      "text": "A Quick Crash Detection Method for the\n Internet Key Exchange Protocol (IKE)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes an extension to the Internet Key Exchange Protocol version 2 (IKEv2) that allows for faster detection of Security Association (SA) desynchronization using a saved token.",
      "ja": "この文書は、保存されたトークンを使用してセキュリティアソシエーション（SA）非同期化の速い検出を可能にするインターネット鍵交換プロトコルバージョン2（IKEv2の）への拡張について説明します。"
    },
    {
      "indent": 3,
      "text": "When an IPsec tunnel between two IKEv2 peers is disconnected due to a restart of one peer, it can take as much as several minutes for the other peer to discover that the reboot has occurred, thus delaying recovery. In this text, we propose an extension to the protocol that allows for recovery immediately following the restart.",
      "ja": "2つのIKEv2ピア間のIPsecトンネルを伴う一方のピアの再起動するように切断されると、それは、このように、回復を遅らせ、リブートが発生したことを発見するために、他のピアの数分だけ多く取ることができます。このテキストでは、我々はすぐに再起動後の回復が可能になりますプロトコルの拡張を提案します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6290.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6290で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2011 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n  1.1.  Conventions Used in This Document  . . . . . . . . . . . .  3\n2.  RFC 5996 Crash Recovery  . . . . . . . . . . . . . . . . . . .  4\n3.  Protocol Outline . . . . . . . . . . . . . . . . . . . . . . .  5\n4.  Formats and Exchanges  . . . . . . . . . . . . . . . . . . . .  6\n  4.1.  Notification Format  . . . . . . . . . . . . . . . . . . .  6\n  4.2.  Passing a Token in the AUTH Exchange . . . . . . . . . . .  7\n  4.3.  Replacing Tokens after Rekey or Resumption . . . . . . . .  8\n  4.4.  Replacing the Token for an Existing SA . . . . . . . . . .  9\n  4.5.  Presenting the Token in an Unprotected Message . . . . . .  9\n5.  Token Generation and Verification  . . . . . . . . . . . . . . 10\n  5.1.  A Stateless Method of Token Generation . . . . . . . . . . 11\n  5.2.  A Stateless Method with IP Addresses . . . . . . . . . . . 11\n  5.3.  Token Lifetime . . . . . . . . . . . . . . . . . . . . . . 12\n6.  Backup Gateways  . . . . . . . . . . . . . . . . . . . . . . . 12\n7.  Interaction with Session Resumption  . . . . . . . . . . . . . 13\n8.  Operational Considerations . . . . . . . . . . . . . . . . . . 14\n  8.1.  Who Should Implement This Specification  . . . . . . . . . 14\n  8.2.  Response to Unknown Child SPI  . . . . . . . . . . . . . . 15\n9.  Security Considerations  . . . . . . . . . . . . . . . . . . . 16\n  9.1.  QCD Token Generation and Handling  . . . . . . . . . . . . 16\n  9.2.  QCD Token Transmission . . . . . . . . . . . . . . . . . . 17\n  9.3.  QCD Token Enumeration  . . . . . . . . . . . . . . . . . . 18\n10. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 18\n11. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 18\n12. References . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n  12.1. Normative References . . . . . . . . . . . . . . . . . . . 19\n  12.2. Informative References . . . . . . . . . . . . . . . . . . 19\nAppendix A.  The Path Not Taken  . . . . . . . . . . . . . . . . . 20\n  A.1.  Initiating a New IKE SA  . . . . . . . . . . . . . . . . . 20\n  A.2.  SIR  . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n  A.3.  Birth Certificates . . . . . . . . . . . . . . . . . . . . 20\n  A.4.  Reducing Liveness Check Length . . . . . . . . . . . . . . 21",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "IKEv2, as described in [RFC5996] and its predecessor RFC 4306, has a method for recovering from a reboot of one peer. As long as traffic flows in both directions, the rebooted peer should re-establish the tunnels immediately. However, in many cases, the rebooted peer is a VPN gateway that protects only servers, so all traffic is inbound. In other cases, the non-rebooted peer has a dynamic IP address, so the rebooted peer cannot initiate IKE because its current IP address is unknown. In such cases, the rebooted peer will not be able to re-establish the tunnels. Section 2 describes how recovery works under RFC 5996, and explains why it may take several minutes.",
      "ja": "IKEv2のは、[RFC5996]及びその前身RFC 4306に記載されているように、一方のピアの再起動から回復するための方法を有しています。限り、トラフィックが両方向に流れるよう、再起動ピアはすぐにトンネルを再確立する必要があります。しかし、多くの場合、再起動ピアはので、すべてのトラフィックがインバウンドで、サーバーのみを保護VPNゲートウェイです。他の場合では、非再起動ピアは、動的IPアドレスを持っているので、現在のIPアドレスが不明であるため、再起動ピアがIKEを開始することができません。このような場合には、再起動ピアは、トンネルを再確立することができません。第2節では回復がRFC 5996の下でどのように動作するかを説明し、それは数分かかることがあります理由を説明します。"
    },
    {
      "indent": 3,
      "text": "The method proposed here is to send an octet string, called a \"QCD token\", in the IKE_AUTH exchange that establishes the tunnel. That token can be stored on the peer as part of the IKE SA. After a reboot, the rebooted implementation can re-generate the token and send it to the peer, so as to delete the IKE SA. Deleting the IKE SA results in a quick establishment of new IPsec tunnels. This is described in Section 3.",
      "ja": "ここで提案する方法は、オクテットストリングを送信することである、トンネルを確立IKE_AUTH交換において、「QCDトークン」と呼ばれます。そのトークンは、IKE SAの一部として、ピア上に格納することができます。再起動後、再起動の実装は、トークンを再生成することができますし、IKE SAを削除するように、ピアに送信します。新しいIPsecトンネルの迅速な確立にIKE SAの結果を削除します。これは、第3節で説明されています。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1。このドキュメントの表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The term \"token\" refers to an octet string that an implementation can generate using only the properties of a protected IKE message (such as IKE Security Parameter Indexes (SPIs)) as input. A conforming implementation MUST be able to generate the same token from the same input even after rebooting.",
      "ja": "用語「トークン」は、インプリメンテーションは、入力として（例えばIKEセキュリティパラメータインデックス（SPIの）のような）保護IKEメッセージのプロパティのみを使用して生成することができるオクテットストリングを指します。適合実装があっても、再起動後に同じ入力から同じトークンを生成できなければなりません。"
    },
    {
      "indent": 3,
      "text": "The term \"token maker\" refers to an implementation that generates a token and sends it to the peer as specified in this document.",
      "ja": "用語「トークンメーカーは、」トークンを生成し、この文書で指定されたピアに送信し、実装を指します。"
    },
    {
      "indent": 3,
      "text": "The term \"token taker\" refers to an implementation that stores such a token or a digest thereof, in order to verify that a new token it receives is identical to the old token it has stored.",
      "ja": "用語「トークン係」は、受信する新しいトークンは、それが格納された古いトークンと同一であることを確認するために、そのようなトークンまたはダイジェストを格納する実装を指します。"
    },
    {
      "indent": 3,
      "text": "The term \"non-volatile storage\" in this document refers to a data storage module that persists across restarts of the token maker. Examples of such a storage module include an internal disk, an internal flash memory module, an external disk, and an external database. A small non-volatile storage module is required for a token maker, but a larger one can be used to enhance performance, as described in Section 8.2.",
      "ja": "この文書に記載されている用語「不揮発性記憶装置は、」トークンメーカの再起動しても持続するデータ記憶モジュールを指します。そのようなストレージモジュールの例は、内部ディスク、内蔵フラッシュメモリモジュール、外部ディスク、および外部データベースを含みます。小さな不揮発性記憶モジュールは、トークンのメーカーのために必要とされるが、8.2節で説明したように大きい方が、性能を向上させるために使用することができます。"
    },
    {
      "indent": 0,
      "text": "2. Crash Recovery",
      "section_title": true,
      "ja": "2.クラッシュリカバリ"
    },
    {
      "indent": 3,
      "text": "When one peer loses state or reboots, the other peer does not get any notification, so unidirectional IPsec traffic can still flow. The rebooted peer will not be able to decrypt it, however, and the only remedy is to send an unprotected INVALID_SPI notification as described in Section 3.10.1 of [RFC5996]. That section also describes the processing of such a notification:",
      "ja": "一方のピア状態または再起動が失うと、他のピアは、任意の通知を取得していないので、一方向のIPSecトラフィックはまだ流れることができます。再起動ピアはしかし、それを解読することができなくなり、唯一の救済は、[RFC5996]のセクション3.10.1に記載されているように保護されていないINVALID_SPI通知を送信することです。その部分はまた、そのような通知の処理について説明します。"
    },
    {
      "indent": 6,
      "text": "If this Informational Message is sent outside the context of an IKE_SA, it should be used by the recipient only as a \"hint\" that something might be wrong (because it could easily be forged).",
      "ja": "この情報メッセージはIKE_SAの文脈の外に送信された場合、それだけで（それが簡単に偽造できる可能性があるため）何かが間違っているかもしれないことを、「ヒント」として、受信者によって使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Since the INVALID_SPI can only be used as a hint, the non-rebooted peer has to determine whether the IPsec SA and indeed the parent IKE SA are still valid. The method of doing this is described in Section 2.4 of [RFC5996]. This method, called \"liveness check\", involves sending a protected empty INFORMATIONAL message, and awaiting a response. This procedure is sometimes referred to as \"Dead Peer Detection\" or DPD.",
      "ja": "INVALID_SPIのみヒントとして使用することができるので、非再起動ピアは、IPsec SAかどうかを決定する必要があり、実際、親IKE SAがまだ有効です。これを行う方法は、[RFC5996]のセクション2.4に記載されています。 「生存性チェック」と呼ばれるこの方法では、保護された空の情報メッセージを送信し、応答を待っていることを伴います。この手順は、時々「デッドピア検出」やDPDと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Section 2.4 does not mandate how many times the liveness check message should be retransmitted, or for how long, but does recommend the following:",
      "ja": "2.4節は、またはどのくらいのために、生存性チェックメッセージを再送しなければならない回数を強制しませんが、次のことをお勧めしますありません。"
    },
    {
      "indent": 6,
      "text": "It is suggested that messages be retransmitted at least a dozen times over a period of at least several minutes before giving up on an SA...",
      "ja": "メッセージがSAをあきらめる前に、少なくとも数分間にわたって少なくとも12回を再送することが示唆されています..."
    },
    {
      "indent": 3,
      "text": "Those \"at least several minutes\" are a time during part of which both peers are active, but IPsec cannot be used.",
      "ja": "これらの「少なくとも数分」が両方のピアがアクティブであるの一部の間の時間であるが、IPsecは使用できません。"
    },
    {
      "indent": 3,
      "text": "Especially in the case of a reboot (rather than fail-over or administrative clearing of state), the peer does not recover immediately. Reboot, depending on the system, may take from a few seconds to a few minutes. This means that at first the peer just goes silent, i.e., does not send or respond to any messages. IKEv2 implementations can detect this situation and follow the rules given in Section 2.4:",
      "ja": "特にリブート（というよりもフェイルオーバーまたは状態の管理クリア）の場合には、ピアがすぐに回復しません。再起動は、システムに応じて、数秒から数分かかる場合があります。これは最初のピアがちょうどすなわち、送信または任意のメッセージに応答しない、サイレント行くことを意味しています。 IKEv2の実装は、この状況を検出し、2.4節で与えられたルールに従うことができます。"
    },
    {
      "indent": 6,
      "text": "If there has only been outgoing traffic on all of the SAs associated with an IKE SA, it is essential to confirm liveness of the other endpoint to avoid black holes. If no cryptographically protected messages have been received on an IKE SA or any of its Child SAs recently, the system needs to perform a liveness check in order to prevent sending messages to a dead peer.",
      "ja": "唯一のIKE SAに関連付けられたSAのすべての発信トラフィックがあった場合、ブラックホールを避けるために、他のエンドポイントの生存性を確認することが不可欠です。何の暗号化によって保護されたメッセージは、最近、IKE SAまたはその子のSAのいずれかで受信されていない場合は、システムが死んだピアへのメッセージ送信を防止するために、生存性チェックを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "[RFC5996] does not mandate any time limits, but it is possible that the peer will start liveness checks even before the other end is sending INVALID_SPI notification, as it detected that the other end is not sending any packets anymore while it is still rebooting or recovering from the situation.",
      "ja": "[RFC5996]は、任意の時間制限を強制しないが、それがまだ再起動又はている間にもう一方の端はもう任意のパケットを送信していないことが検出されるように、ピアは、INVALID_SPI通知を送信しても、もう一方の端の前にライブネス・チェックを開始することが可能です状況から回復。"
    },
    {
      "indent": 3,
      "text": "This means that the several minutes recovery period is overlapping the actual recover time of the other peer; i.e., if the security gateway requires several minutes to boot up from the crash, then the other peers have already finished their liveness checks before the crashing peer even has a chance to send INVALID_SPI notifications.",
      "ja": "これには数分の回復期間は、他のピアの実際の回復時間が重複していることを意味します。セキュリティゲートウェイは、クラッシュからの起動に数分を必要とする場合、クラッシュピアもINVALID_SPI通知を送信する機会を持つ前に、すなわち、その後、他のピアは、すでに彼らの生存性のチェックを終了しました。"
    },
    {
      "indent": 3,
      "text": "There are cases where the peer loses state and is able to recover immediately; in those cases it might take several minutes to recreate the IPsec SAs.",
      "ja": "ピアが状態を失い、すぐに回復することができる場合があります。これらの例では、IPsec SAを再作成するのに数分かかることがあります。"
    },
    {
      "indent": 3,
      "text": "Note that the IKEv2 specification specifically gives no guidance for the number of retries or the length of timeouts, as these do not affect interoperability. This means that implementations are allowed to use the hints provided by the INVALID_SPI messages to shorten those timeouts (i.e., a different environment and situation requiring different rules).",
      "ja": "これらは相互運用性に影響しないので、IKEv2の仕様は、特に再試行回数やタイムアウトの長さのための指導を与えないことに注意してください。これは実装がそれらのタイムアウト（即ち、異なる環境及び状況異なるルールが必要）を短くするINVALID_SPIメッセージによって提供されるヒントを使用することを許可されていることを意味します。"
    },
    {
      "indent": 3,
      "text": "Some existing IKEv2 implementations already do that (i.e., shorten timeouts or limit number of retries) based on these kinds of hints and also start liveness checks quickly after the other end goes silent. However, see Appendix A.4 for a discussion of why this may not be enough.",
      "ja": "いくつかの既存のIKEv2の実装は、すでにヒントこれらの種類に基づいて（すなわち、タイムアウトを短くするか、再試行の回数を制限する）ことを行うと、もう一方の端を静かになった後もすぐに生存性チェックを開始します。しかし、これは十分ではないかもしれない理由の説明については、付録A.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Protocol Outline",
      "section_title": true,
      "ja": "3.プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "Supporting implementations will send a notification, called a \"QCD token\", as described in Section 4.1 in the first IKE_AUTH exchange messages. These are the first IKE_AUTH request and final IKE_AUTH response that contain the AUTH payloads. The generation of these tokens is a local matter for implementations, but considerations are described in Section 5. Implementations that send such a token will be called \"token makers\".",
      "ja": "最初のIKE_AUTH交換メッセージで、セクション4.1で説明したように、通知を送信する実装をサポートする、「QCDトークン」と呼ばれます。これらは、AUTHペイロードが含まれている最初のIKE_AUTH要求と最終IKE_AUTH応答です。これらのトークンの生成は、実装のためのローカルの問題であるが、考察は、そのようなトークンを送信5.実装は、「トークンメーカー」と呼ばれるセクションに記載されています。"
    },
    {
      "indent": 3,
      "text": "A supporting implementation receiving such a token MUST store it (or a digest thereof) along with the IKE SA. Implementations that support this part of the protocol will be called \"token takers\". Section 8.1 has considerations for which implementations need to be token takers, and which should be token makers. Implementations that are not token takers will silently ignore QCD tokens.",
      "ja": "そのようなトークンを受信した支持実装は、IKE SAと一緒に（またはそのダイジェスト）を記憶しなければなりません。プロトコルのこの部分をサポートする実装は、「トークン受験者」と呼ばれます。 8.1節では実装がトークン受験する必要のある注意事項があり、これは、トークンのメーカーでなければなりません。トークン受験者でない実装は黙っQCD・トークンを無視します。"
    },
    {
      "indent": 3,
      "text": "When a token maker receives a protected IKE request message with unknown IKE SPIs, it SHOULD generate a new token that is identical to the previous token, and send it to the requesting peer in an unprotected IKE message as described in Section 4.5.",
      "ja": "トークンメーカーは不明IKEのSPIで保護IKEリクエストメッセージを受信すると、前のトークンと同一の新しいトークンを生成する必要がありますし、4.5節で説明したように保護されていないIKEメッセージの中で要求側ピアに送信します。"
    },
    {
      "indent": 3,
      "text": "When a token taker receives the QCD token in an unprotected notification, it MUST verify that the TOKEN_SECRET_DATA matches the token stored with the matching IKE SA. If the verification fails, or if the IKE SPIs in the message do not match any existing IKE SA, it SHOULD log the event. If it succeeds, it MUST silently delete the IKE SA associated with the IKE_SPI fields and all dependent child SAs. This event MAY also be logged. The token taker MUST accept such tokens from any IP address and port combination, so as to allow different kinds of high-availability configurations of the token maker.",
      "ja": "トークンテイカーが保護されていない通知にQCDトークンを受信すると、TOKEN_SECRET_DATAが一致IKE SAに格納されたトークンと一致することを確認しなければなりません。検証が失敗した、またはメッセージでIKEのSPIは、既存のIKE SAと一致しない場合、それはイベントをログに記録するかどうか。それが成功した場合、それは静かにIKE_SPIフィールドとすべての依存子のSAに関連したIKE SAを削除しなければなりません。このイベントも記録されることがあります。トークンメーカーの高可用性構成の異なる種類を可能にするように、トークン受け手は、任意のIPアドレスとポートの組み合わせから、このようなトークンを受け入れなければなりません。"
    },
    {
      "indent": 3,
      "text": "A supporting token taker MAY immediately create new SAs using an Initial exchange, or it may wait for subsequent traffic to trigger the creation of new SAs.",
      "ja": "サポートトークン受け手はすぐに最初の交換を使用して新しいSAを作成することができ、またはそれは新しいSAの作成をトリガするために、後続のトラフィックを待つことができます。"
    },
    {
      "indent": 3,
      "text": "See Section 7 for a short discussion about this extension's interaction with IKEv2 Session Resumption ([RFC5723]).",
      "ja": "IKEv2のセッション再開と、この拡張機能の相互作用についての短い説明についてはセクション7を参照してください（[RFC5723]）。"
    },
    {
      "indent": 0,
      "text": "4. Formats and Exchanges",
      "section_title": true,
      "ja": "4.フォーマットと交流"
    },
    {
      "indent": 0,
      "text": "4.1. Notification Format",
      "section_title": true,
      "ja": "4.1。通知のフォーマット"
    },
    {
      "indent": 3,
      "text": "The notification payload called \"QCD token\" is formatted as follows:",
      "ja": "次のように「QCDトークン」と呼ばれる通知ペイロードがフォーマットされます："
    },
    {
      "indent": 7,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n! Next Payload  !C!  RESERVED   !         Payload Length        !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n!  Protocol ID  !   SPI Size    ! QCD Token Notify Message Type !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n!                                                               !\n~                       TOKEN_SECRET_DATA                       ~\n!                                                               !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Protocol ID (1 octet) MUST be 1, as this message is related to an IKE SA.",
      "ja": "このメッセージは、IKE SAに関連しているように、OプロトコルID（1オクテット）は、1でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o SPI Size (1 octet) MUST be zero, in conformance with Section 3.10 of [RFC5996].",
      "ja": "O SPIサイズ（1オクテット）は、[RFC5996]のセクション3.10に準拠し、ゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o QCD Token Notify Message Type (2 octets) - MUST be 16419, the value assigned for QCD token notifications.",
      "ja": "16419でなければなりません、QCDトークン通知のために割り当てられた値 -  O QCDトークンは、メッセージタイプ（2オクテット）を通知します。"
    },
    {
      "indent": 3,
      "text": "o TOKEN_SECRET_DATA (variable) contains a generated token as described in Section 5.",
      "ja": "セクション5で説明したように、O TOKEN_SECRET_DATA（変数）が生成されたトークンを含んでいます。"
    },
    {
      "indent": 0,
      "text": "4.2. Passing a Token in the AUTH Exchange",
      "section_title": true,
      "ja": "4.2。 AUTHのExchangeでトークンを渡します"
    },
    {
      "indent": 3,
      "text": "For brevity, only the Extensible Authentication Protocol (EAP) version of an AUTH exchange will be presented here. The non-EAP version is very similar. The figures below are based on Appendix C.3 of [RFC5996].",
      "ja": "簡潔にするため、AUTH交換の唯一の拡張認証プロトコル（EAP）のバージョンは、ここに表示されます。非EAPバージョンは非常に似ています。以下の図は、[RFC5996]の付録C.3に基づいています。"
    },
    {
      "indent": 4,
      "text": "first request --> IDi, [N(INITIAL_CONTACT)], [[N(HTTP_CERT_LOOKUP_SUPPORTED)], CERTREQ+], [IDr], [N(QCD_TOKEN)] [CP(CFG_REQUEST)], [N(IPCOMP_SUPPORTED)+], [N(USE_TRANSPORT_MODE)], [N(ESP_TFC_PADDING_NOT_SUPPORTED)], [N(NON_FIRST_FRAGMENTS_ALSO)], SA, TSi, TSr, [V+]",
      "ja": "最初の要求 - > IDI、[N（INITIAL_CONTACT）]、[N（HTTP_CERT_LOOKUP_SUPPORTED）]、CERTREQ +]、[IDR]、[N（QCD_TOKEN）] [CP（CFG_REQUEST）]、[N（IPCOMP_SUPPORTED）+]、 [N（USE_TRANSPORT_MODE）]、[N（ESP_TFC_PADDING_NOT_SUPPORTED）]、[N（NON_FIRST_FRAGMENTS_ALSO）]、SA、をTSi、TSrを、[Vの+]"
    },
    {
      "indent": 4,
      "text": "first response <-- IDr, [CERT+], AUTH, EAP, [V+]",
      "ja": "最初の応答< -  IDR [CERT +]、AUTH、EAP、[Vの+]"
    },
    {
      "indent": 4,
      "text": " / --> EAP repeat 1..N times | \\ <-- EAP",
      "ja": "/  - > EAPリピート1..N回| \\ < -  EAP"
    },
    {
      "indent": 4,
      "text": "last request --> AUTH",
      "ja": "最後の要求 - > AUTH"
    },
    {
      "indent": 4,
      "text": "last response <-- AUTH, [N(QCD_TOKEN)] [CP(CFG_REPLY)], [N(IPCOMP_SUPPORTED)], [N(USE_TRANSPORT_MODE)], [N(ESP_TFC_PADDING_NOT_SUPPORTED)], [N(NON_FIRST_FRAGMENTS_ALSO)], SA, TSi, TSr, [N(ADDITIONAL_TS_POSSIBLE)], [V+]",
      "ja": "最後応答< -  AUTH、[N（QCD_TOKEN）] [CP（CFG_REPLY）]、[N（IPCOMP_SUPPORTED）]、[N（USE_TRANSPORT_MODE）]、[N（ESP_TFC_PADDING_NOT_SUPPORTED）]、[N（NON_FIRST_FRAGMENTS_ALSO）]、SA、 TSi、TSrを、[N（ADDITIONAL_TS_POSSIBLE）]、[V +]"
    },
    {
      "indent": 3,
      "text": "Note that the QCD_TOKEN notification is marked as optional because it is not required by this specification that every implementation be both token maker and token taker. If only one peer sends the QCD token, then a reboot of the other peer will not be recoverable by this method. This may be acceptable if traffic typically originates from the other peer.",
      "ja": "それは、すべての実装でトークンメーカー、トークン受け手の両方もこの仕様によって必要とされていないため、QCD_TOKEN通知がオプションとしてマークされていることに注意してください。唯一のピアがQCDトークンを送信した場合は、他のピアの再起動は、この方法で回復できないであろう。トラフィックは、典型的には、他のピアから発信場合、これは許容可能であり得ます。"
    },
    {
      "indent": 3,
      "text": "In any case, the lack of a QCD_TOKEN notification MUST NOT be taken as an indication that the peer does not support this standard. Conversely, if a peer does not understand this notification, it will simply ignore it. Therefore, a peer may send this notification freely, even if it does not know whether the other side supports it.",
      "ja": "いずれの場合においても、QCD_TOKEN通知の欠如は、ピアがこの規格をサポートしていないことを示すと解釈されてはいけません。ピアがこの通知を理解していない場合は逆に、それは単にそれを無視します。したがって、ピアは、他の側がそれをサポートしているかどうかを知らなくても、自由にこの通知を送信することができます。"
    },
    {
      "indent": 3,
      "text": "The QCD_TOKEN notification is related to the IKE SA and should follow the AUTH payload and precede the Configuration payload and all payloads related to the child SA.",
      "ja": "QCD_TOKEN通知は、IKE SAに関連し、AUTHペイロードをたどると設定ペイロードと子SAに関連するすべてのペイロードを前に置く必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. Replacing Tokens after Rekey or Resumption",
      "section_title": true,
      "ja": "4.3。リキーまたは再開後にトークンの交換"
    },
    {
      "indent": 3,
      "text": "After rekeying an IKE SA, the IKE SPIs are replaced, so the new SA also needs to have a token. If only the responder in the rekey exchange is the token maker, this can be done within the CREATE_CHILD_SA exchange. If the initiator is a token maker, then we need an extra informational exchange.",
      "ja": "IKE SAを再入力した後、IKEのSPIが交換されるので、新しいSAにもトークンを持っている必要があります。リキー交換の唯一の応答は、トークンメーカーであるならば、これはCREATE_CHILD_SA交換中に行うことができます。イニシエータはトークンメーカーであれば、私たちは余分な情報交換が必要です。"
    },
    {
      "indent": 3,
      "text": "The following figure shows the CREATE_CHILD_SA exchange for rekeying the IKE SA. Only the responder sends a QCD token.",
      "ja": "次の図は、IKE SAを再入力するためのCREATE_CHILD_SA交換を示します。唯一の応答は、QCDのトークンを送信します。"
    },
    {
      "indent": 6,
      "text": "request --> SA, Ni, [KEi]",
      "ja": "れくえｓｔ ーー＞ さ、 に、 「けい」"
    },
    {
      "indent": 6,
      "text": "response <-- SA, Nr, [KEr], N(QCD_TOKEN)",
      "ja": "応答< -  SA NRC、[REC]、N（QCD_TOKEN）"
    },
    {
      "indent": 3,
      "text": "If the initiator is also a token maker, it SHOULD initiate an INFORMATIONAL exchange immediately after the CREATE_CHILD_SA exchange as follows:",
      "ja": "イニシエータがトークンメーカーでもある場合は、次のように、それはCREATE_CHILD_SA交換直後INFORMATIONAL交換を開始する必要があります。"
    },
    {
      "indent": 6,
      "text": "request --> N(QCD_TOKEN)",
      "ja": "要求 - > N（QCD_TOKEN）"
    },
    {
      "indent": 6,
      "text": "response <--",
      "ja": "応答< - "
    },
    {
      "indent": 3,
      "text": "For session resumption, as specified in [RFC5723], the situation is similar. The responder, which is necessarily the peer that has crashed, SHOULD send a new ticket within the protected payload of the IKE_SESSION_RESUME exchange. If the Initiator is also a token maker, it needs to send a QCD_TOKEN in a separate INFORMATIONAL exchange.",
      "ja": "[RFC5723]で指定されたセッションの再開については、状況は似ています。必ずしもクラッシュしたピアであるレスポンダは、IKE_SESSION_RESUME交換の保護されたペイロード内の新しいチケットを送るべきです。イニシエータはトークンメーカーでもある場合は、それは別のINFORMATIONAL交換でQCD_TOKENを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The INFORMATIONAL exchange described in this section can also be used if QCD tokens need to be replaced due to a key rollover. However, since token takers are required to verify at least 4 QCD tokens, this is only necessary if secret QCD keys are rolled over more than four times as often as IKE SAs are rekeyed. See Section 5.1 for an example method that uses secret keys that may require rollover.",
      "ja": "QCDのトークンは、キーロールオーバーに起因して交換する必要がある場合は、このセクションで説明するINFORMATIONAL交換にも使用することができます。トークンの受験者は、少なくとも4つのQCDトークンを検証するために必要とされているので、秘密QCDキーはできるだけ頻繁にIKE SAがリキーされているとして4倍以上のロールオーバーされている場合は、これにのみ必要です。ロールオーバーを必要とするかもしれない秘密鍵を使用する例示的な方法については、セクション5.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.4. Replacing the Token for an Existing SA",
      "section_title": true,
      "ja": "4.4。既存のSAのためのトークンの交換"
    },
    {
      "indent": 3,
      "text": "With some token generation methods, such as that described in Section 5.2, a QCD token may sometimes become invalid, although the IKE SA is still perfectly valid.",
      "ja": "IKE SAは、まだ完全に有効ですが、このようなセクション5.2に記載されているようないくつかのトークン生成方法、で、QCDのトークンは時々、無効になる場合があります。"
    },
    {
      "indent": 3,
      "text": "In such a case, the token maker MUST send the new token in a protected message under that IKE SA. That exchange could be a simple INFORMATIONAL, such as in the last figure in the previous section, or else it can be part of a MOBIKE INFORMATIONAL exchange such as in the following figure taken from Section 2.2 of [RFC4555] and modified by adding a QCD_TOKEN notification:",
      "ja": "そのような場合には、トークンのメーカーはそのIKE SAの下で保護されたメッセージに新しいトークンを送らなければなりません。その交換は、前のセクションの最後の図のような単純なINFORMATIONAL、かもしれない、あるいはそのようなQCD_TOKENを添加することによって、[RFC4555]のセクション2.2から採取し、変性以下の図のように、MOBIKE INFORMATIONAL交換の一部とすることができます通知："
    },
    {
      "indent": 5,
      "text": "(IP_I2:4500 -> IP_R1:4500) HDR, SK { N(UPDATE_SA_ADDRESSES), N(NAT_DETECTION_SOURCE_IP), N(NAT_DETECTION_DESTINATION_IP) } -->",
      "ja": "（IP_I2：4500  - > IP_R1：4500）HDR、SK {N（UPDATE_SA_ADDRESSES）、N（NAT_DETECTION_SOURCE_IP）、N（NAT_DETECTION_DESTINATION_IP）}  - >"
    },
    {
      "indent": 27,
      "text": "<-- (IP_R1:4500 -> IP_I2:4500)\n    HDR, SK { N(NAT_DETECTION_SOURCE_IP),\n         N(NAT_DETECTION_DESTINATION_IP) }",
      "raw": true
    },
    {
      "indent": 27,
      "text": "<-- (IP_R1:4500 -> IP_I2:4500) HDR, SK { N(COOKIE2), [N(QCD_TOKEN)] }",
      "ja": "< - （IP_R1：4500  - > IP_I2：4500）HDR、SK {N（COOKIE2）、[N（QCD_TOKEN）]}"
    },
    {
      "indent": 5,
      "text": "(IP_I2:4500 -> IP_R1:4500) HDR, SK { N(COOKIE2), [N(QCD_TOKEN)] } -->",
      "ja": "（IP_I2：4500  - > IP_R1：4500）HDR、SK {N（COOKIE2）、[N（QCD_TOKEN）]}  - >"
    },
    {
      "indent": 3,
      "text": "A token taker MUST accept such gratuitous QCD_TOKEN notifications as long as they are carried in protected exchanges. A token maker SHOULD NOT generate them unless it is no longer able to generate the old QCD_TOKEN.",
      "ja": "トークン係がいる限り、彼らが保護取引所に運ばれているような無償QCD_TOKEN通知を受け入れなければなりません。もはや古いQCD_TOKENを生成することができる場合を除きトークンメーカーは、それらを生成しないべきではありません。"
    },
    {
      "indent": 0,
      "text": "4.5. Presenting the Token in an Unprotected Message",
      "section_title": true,
      "ja": "4.5。保護されていないメッセージにトークンを提示"
    },
    {
      "indent": 3,
      "text": "This QCD_TOKEN notification is unprotected, and is sent as a response to a protected IKE request, which uses an IKE SA that is unknown.",
      "ja": "このQCD_TOKEN通知は保護されていないで、不明なIKE SAを使用して保護されたIKE要求への応答として送信されます。"
    },
    {
      "indent": 12,
      "text": "message --> N(INVALID_IKE_SPI), N(QCD_TOKEN)+",
      "ja": "メッセージ - > N（INVALID_IKE_SPI）、N（QCD_TOKEN）+"
    },
    {
      "indent": 3,
      "text": "If child SPIs are persistently mapped to IKE SPIs as described in Section 8.2, a token taker may get the following unprotected message in response to an Encapsulating Security Payload (ESP) or Authentication Header (AH) packet.",
      "ja": "8.2節で説明したように、子のSPIが持続的にIKEのSPIにマップされている場合は、トークン受け手は、カプセル化セキュリティペイロード（ESP）または認証ヘッダー（AH）パケットに応じて、以下の保護されていないメッセージを受け取ることがあります。"
    },
    {
      "indent": 12,
      "text": "message --> N(INVALID_SPI), N(QCD_TOKEN)+",
      "ja": "メッセージ - > N（INVALID_SPI）、N（QCD_TOKEN）+"
    },
    {
      "indent": 3,
      "text": "The QCD_TOKEN and INVALID_IKE_SPI notifications are sent together to support both implementations that conform to this specification and implementations that don't. Similar to the description in Section 2.21 of [RFC5996], the IKE SPI and message ID fields in the packet headers are taken from the protected IKE request.",
      "ja": "QCD_TOKENとINVALID_IKE_SPI通知はしません両方のこの仕様に準拠して実装し、実装をサポートするために一緒に送信されます。 [RFC5996]のセクション2.21での説明と同様に、IKE SPI、パケットヘッダ内のメッセージIDフィールドは、保護されたIKE要求から取り出されます。"
    },
    {
      "indent": 3,
      "text": "To support a periodic rollover of the secret used for token generation, the token taker MUST support at least four QCD_TOKEN notifications in a single packet. The token is considered verified if any of the QCD_TOKEN notifications matches. The token maker MAY generate up to four QCD_TOKEN notifications, based on several generations of keys.",
      "ja": "トークンの生成に使用される秘密の定期的なロールオーバーをサポートするために、トークン受け手は、単一のパケットで少なくとも4つのQCD_TOKEN通知をサポートしなければなりません。 QCD_TOKEN通知のいずれかが一致した場合にトークンを検証考えられています。トークンメーカーは、キーの数世代に基づいて、4つのQCD_TOKEN通知まで発生するかもしれません。"
    },
    {
      "indent": 3,
      "text": "If the QCD_TOKEN verifies OK, the receiver MUST silently discard the IKE SA and all associated child SAs. If the QCD_TOKEN cannot be validated, a response MUST NOT be sent, and the event may be logged. Section 5 defines token verification.",
      "ja": "QCD_TOKENがOKを確認した場合、受信機は静かにIKE SAと関連するすべての子SAを捨てなければなりません。 QCD_TOKENが検証できない場合は、応答が送信されてはならない、とイベントが記録されることがあります。第5節では、トークンの検証を定義します。"
    },
    {
      "indent": 0,
      "text": "5. Token Generation and Verification",
      "section_title": true,
      "ja": "5.トークンの生成と検証"
    },
    {
      "indent": 3,
      "text": "No token generation method is mandated by this document. Two methods are documented in the following sub-sections, but they only serve as examples.",
      "ja": "いいえトークン生成方法は、この文書で義務付けられていません。二つの方法は、以下のサブセクションに記載されていますが、それらは単なる例として役立ちます。"
    },
    {
      "indent": 3,
      "text": "The following lists the requirements for a token generation mechanism:",
      "ja": "以下は、トークン生成メカニズムのための要件を示しています。"
    },
    {
      "indent": 3,
      "text": "o Tokens MUST be at least 16 octets long, and no more than 128 octets long, to facilitate storage and transmission. Tokens SHOULD be indistinguishable from random data.",
      "ja": "Oトークンは記憶および伝送を容易にするために、せいぜい128オクテット長の少なくとも16オクテットの長さ、およびなければなりません。トークンは、ランダムデータと区別できないであるべきです。"
    },
    {
      "indent": 3,
      "text": "o It should not be possible for an external attacker to guess the QCD token generated by an implementation. Cryptographic mechanisms such as a pseudo-random number generator (PRNG) and hash functions are RECOMMENDED.",
      "ja": "Oそれはトークンの実装によって生成されたQCDを推測するために、外部の攻撃者のために可能にすべきではありません。このような擬似乱数生成器（PRNG）とハッシュ関数などの暗号メカニズムが推奨されます。"
    },
    {
      "indent": 3,
      "text": "o The token maker MUST be able to re-generate or retrieve the token based on the IKE SPIs even after it reboots.",
      "ja": "Oトークンメーカーは、それがリブートした後も、IKEのSPIに基づいてトークンを再生成したり、取得できなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The method of token generation MUST be such that a collision of QCD tokens between different pairs of IKE SPI will be highly unlikely.",
      "ja": "トークン生成方法O IKE SPIの異なる対の間QCDトークンの衝突が非常に低いであろうようなものでなければなりません。"
    },
    {
      "indent": 3,
      "text": "For verification, the token taker makes a bitwise comparison of the token stored along with the IKE SA with the token sent in the unprotected message. Multihomed takers might flip back-and-forth between several addresses, and have their tokens replaced as described in Section 4.4. To help avoid the case where the latest stored token does not match the address used after the maker lost state, the token taker MAY store several earlier tokens associated with the IKE SA, and silently discard the SA if any of them matches.",
      "ja": "検証のために、トークン受け手が保護されていないメッセージで送信されたトークンとIKE SAと一緒に格納されたトークンのビット単位の比較を行います。マルチホームの受験者は、複数のアドレス間で前後を反転し、4.4節で説明したように、そのトークンが置き換えられている可能性があります。最新の保存されたトークンは、メーカーが状態を失った後に使用されたアドレスと一致しない場合を避けるために、トークンの受け手は、IKE SAに関連付けられているいくつかの以前のトークンを格納し、静かにそれらのいずれかが一致した場合にSAを捨てるかもしれ。"
    },
    {
      "indent": 0,
      "text": "5.1. A Stateless Method of Token Generation",
      "section_title": true,
      "ja": "5.1。トークン生成のステートレス方法"
    },
    {
      "indent": 3,
      "text": "The following describes a stateless method of generating a token. In this case, 'stateless' means not maintaining any per-tunnel state, although there is a small amount of non-volatile storage required.",
      "ja": "以下は、トークンを生成するステートレス方法を説明します。必要な不揮発性記憶装置の少量存在するが、この場合には、「ステートレス」は、任意の単位のトンネル状態を維持しないことを意味します。"
    },
    {
      "indent": 3,
      "text": "o At installation or immediately after the first boot of the token maker, 32 random octets are generated using a secure random number generator or a PRNG.",
      "ja": "Oインストール時か、すぐにトークンメーカの最初のブート後、32個のランダムオクテットは、安全な乱数ジェネレータまたはPRNGを使用して生成されます。"
    },
    {
      "indent": 3,
      "text": "o Those 32 bytes, called the \"QCD_SECRET\", are stored in non-volatile storage on the machine, and kept indefinitely.",
      "ja": "これらの32バイトO、「QCD_SECRET」と呼ばれ、マシン上の不揮発性記憶装置に記憶され、そして無期限に保持されます。"
    },
    {
      "indent": 3,
      "text": "o If key rollover is required by policy, the implementation MAY periodically generate a new QCD_SECRET and keep up to 3 previous generations. When sending an unprotected QCD_TOKEN, as many as 4 notification payloads may be sent, each from a different QCD_SECRET.",
      "ja": "キーロールオーバーがポリシーによって必要とされている場合は、O、実装は、定期的に新しいQCD_SECRETを生成し、3つの以前の世代に追いつくかもしれません。保護されていないQCD_TOKENを送信するときに、のような多く4として通知ペイロードは異なるQCD_SECRETからそれぞれ送信されても​​よいです。"
    },
    {
      "indent": 3,
      "text": "o The TOKEN_SECRET_DATA is calculated as follows:",
      "ja": "次のようにO TOKEN_SECRET_DATAが計算されます。"
    },
    {
      "indent": 12,
      "text": "TOKEN_SECRET_DATA = HASH(QCD_SECRET | SPI-I | SPI-R)",
      "ja": "TOKEN_SECRET_DATA = HASH（QCD_SECRET | SPI-I | SPI-R）"
    },
    {
      "indent": 0,
      "text": "5.2. A Stateless Method with IP Addresses",
      "section_title": true,
      "ja": "5.2。 IPアドレスとステートレス方法"
    },
    {
      "indent": 3,
      "text": "This method is similar to the one in the previous section, except that the IP address of the token taker is also added to the block being hashed. This has the disadvantage that the token needs to be replaced (as described in Section 4.4) whenever the token taker changes its address.",
      "ja": "この方法は、トークンテイカーのIPアドレスはまた、ハッシュされたブロックに追加されることを除いて、前のセクションのものと同様です。これは、（セクション4.4で説明したように）トークン受け手がそのアドレスを変更するたびに、トークンを交換する必要があるという欠点を有します。"
    },
    {
      "indent": 3,
      "text": "See Section 9.2 for a discussion of a use-case for this method. When using this method, the TOKEN_SECRET_DATA field is calculated as follows:",
      "ja": "この方法のためのユースケースの議論については、セクション9.2を参照してください。この方法を使用する場合は、次のように、TOKEN_SECRET_DATAフィールドが計算されます。"
    },
    {
      "indent": 9,
      "text": "TOKEN_SECRET_DATA = HASH(QCD_SECRET | SPI-I | SPI-R | IPaddr-T)",
      "ja": "TOKEN_SECRET_DATA = HASH（QCD_SECRET | SPI-I | SPI-R | IPADDR-T）"
    },
    {
      "indent": 3,
      "text": "The IPaddr-T field specifies the IP address of the token taker. Secret rollover considerations are similar to those in the previous section.",
      "ja": "IPADDR-Tフィールドは、トークンテイカーのIPアドレスを指定します。秘密のロールオーバーの考慮事項は、前節と同様です。"
    },
    {
      "indent": 3,
      "text": "Note that with a multihomed token taker, the QCD token matches just one of the token taker IP addresses. Usually this is not a problem, as packets sent to the token maker come out the same IP address. If for some reason this changes, then the token maker can replace the token as described in Section 4.4. If IKEv2 Mobility and Multihoming (MOBIKE) is used, replacing the tokens SHOULD be piggybacked on the INFORMATIONAL exchange with the UPDATE_SA_ADDRESSES notifications.",
      "ja": "マルチホームトークン係で、QCDのトークンはちょうどトークン係のIPアドレスのいずれかに一致することに注意してください。トークンメーカーに送信されたパケットは、同じIPアドレスを出てくるよう通常これは、問題ではありません。何らかの理由でこれが変更された場合、セクション4.4で説明したように、その後、トークンのメーカーは、トークンを置き換えることができます。 IKEv2のモビリティとマルチホーミング（MOBIKE）が使用されている場合は、トークンを交換するとUPDATE_SA_ADDRESSES通知とINFORMATIONAL交換に便乗するべきです。"
    },
    {
      "indent": 3,
      "text": "There is a corner case where the token taker begins using a new IP address (because of multihoming, roaming, or normal network operations) and the token maker loses state before replacing the token. In that case, it will send a correct QCD token, but the token taker will still have the old token. In that case, the extension will not work, and the peers will revert to RFC 5996 recovery.",
      "ja": "トークンテイカーが（理由はマルチホーミング、ローミング、または通常のネットワーク運用の）新しいIPアドレスを使用して開始し、トークンメーカーがトークンを交換する前の状態を失うコーナーケースがあります。その場合には、それが正しいQCDトークンを送信しますが、トークン受け手はまだ古いトークンを持つことになります。その場合には、拡張子が動作しません、とピアは5996の回復をRFCに戻ります。"
    },
    {
      "indent": 0,
      "text": "5.3. Token Lifetime",
      "section_title": true,
      "ja": "5.3。トークンの有効期間"
    },
    {
      "indent": 3,
      "text": "The token is associated with a single IKE SA and SHOULD be deleted by the token taker when the SA is deleted or expires. More formally, the token is associated with the pair (SPI-I, SPI-R).",
      "ja": "トークンは、単一のIKE SAに関連付けられており、SAが削除または有効期限が切れている場合、トークン受験者によって削除されるべきです。より正式に、トークンが対（SPI-I、SPI-R）に関連付けられています。"
    },
    {
      "indent": 0,
      "text": "6. Backup Gateways",
      "section_title": true,
      "ja": "6.バックアップゲートウェイ"
    },
    {
      "indent": 3,
      "text": "Making crash detection and recovery quick is a worthy goal, but since rebooting a gateway takes a non-zero amount of time, many implementations choose to have a standby gateway ready to take over as soon as the primary gateway fails for any reason. [RFC6027] describes considerations for such clusters of gateways with synchronized state, but the rest of this section is relevant even when there is no synchronized state.",
      "ja": "クラッシュの検出と回復の迅速を作ることは立派な目標ですが、ゲートウェイを再起動すると、時間の非ゼロの量がかかるため、多くの実装は、すぐにプライマリゲートウェイが何らかの理由で失敗したとして引き継ぐ準備ができて、スタンバイゲートウェイを持っていることを選択します。 [RFC6027]は同期状態とゲートウェイのようなクラスタのための考慮事項について説明しますが、何の同期状態が存在しない場合でも、このセクションの残りの部分は関連性があります。"
    },
    {
      "indent": 3,
      "text": "If such a configuration is available, it is RECOMMENDED that the standby gateway be able to generate the same token as the active gateway. If the method described in Section 5.1 is used, this means that the QCD_SECRET field is identical in both gateways. This has the effect of having the crash recovery available immediately.",
      "ja": "このような構成が利用可能である場合は、スタンバイゲートウェイは、アクティブゲートウェイと同じトークンを生成できることが推奨されます。セクション5.1に記載した方法が使用される場合、これはQCD_SECRETフィールドは両方のゲートウェイで同じであることを意味します。これはすぐにクラッシュリカバリが可能なことの効果があります。"
    },
    {
      "indent": 3,
      "text": "Note that this refers to \"high-availability\" configurations, where only one gateway is active at any given moment. This is different from \"load sharing\" configurations where more than one gateway is active at the same time. For load sharing configurations, please see Section 9.2 for security considerations.",
      "ja": "これが唯一つのゲートウェイは、任意の所与の時点でアクティブである「高可用性」構成を指すことに留意されたいです。これは、複数のゲートウェイが同時にアクティブである「ロードシェアリング」構成と異なっています。負荷分散構成では、セキュリティ上の考慮事項については、セクション9.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "7. Interaction with Session Resumption",
      "section_title": true,
      "ja": "セッション再開7.相互作用"
    },
    {
      "indent": 3,
      "text": "Session resumption, specified in [RFC5723], allows the setting up of a new IKE SA to consume less computing resources. This is particularly useful in the case of a remote access gateway that has many tunnels. A failure of such a gateway requires all these many remote access clients to establish an IKE SA either with the rebooted gateway or with a backup. This tunnel re-establishment occurs within a short period of time, creating a burden on the remote access gateway. Session resumption addresses this problem by having the clients store an encrypted derivative of the IKE SA for quick re-establishment.",
      "ja": "[RFC5723]で指定されたセッション再開は、新しいIKE SAの設定は以下のコンピューティングリソースを消費することができます。これは、多くのトンネルを有するリモートアクセスゲートウェイの場合に特に有用です。そのようなゲートウェイの失敗は再起動ゲートウェイまたはバックアップのいずれかでIKE SAを確立するために、すべてのこれらの多くのリモートアクセスクライアントが必要です。このトンネルの再確立は、リモート・アクセス・ゲートウェイの負担を作成し、時間の短い期間内に起こります。セッション再開アドレスクライアントが速い再確立のためのIKE SAの暗号化された派生物を保管したことによって、この問題に対処。"
    },
    {
      "indent": 3,
      "text": "What Session Resumption does not help is the problem of detecting that the peer gateway has failed. A failed gateway may go undetected for an arbitrarily long time, because IPsec does not have packet acknowledgement, and applications cannot signal the IPsec layer that the tunnel \"does not work\". Section 2.4 of RFC 5996 does not specify how long an implementation needs to wait before beginning a liveness check, and only says \"not recently\" (see full quote in Section 2). In practice, some mobile devices wait a very long time before beginning a liveness check, in order to extend battery life by allowing parts of the device to remain in low-power modes.",
      "ja": "どのようなセッション再開を助けていないピア・ゲートウェイに障害が発生したことを検出する問題です。 IPsecは、パケットの確認応答を持っていないため失敗したゲートウェイは、任意の長さの時間のために検出されないこと、およびアプリケーションは、トンネルは、「動作しない」というのIPsec層に信号を送ることができません。 RFC 5996のセクション2.4には、実装が（第2節では、完全な引用を参照）生存性チェックを開始する前に待機する必要がある、とだけ「ではない最近」と言うどのくらい指定されていません。実際には、一部のモバイルデバイスは、デバイスの部品は、低電力モードのままにできるようにすることで、バッテリの寿命を延ばすために、生存性チェックを開始する前に、非常に長い時間を待ちます。"
    },
    {
      "indent": 3,
      "text": "QCD tokens provide a way to detect the failure of the peer in the case where a liveness check has not yet ended (or begun).",
      "ja": "QCDのトークンは、生存性チェックがまだ終了（または開始）されていない場合には、ピアの障害を検出する方法を提供します。"
    },
    {
      "indent": 3,
      "text": "A remote access client conforming to both specifications will store QCD tokens, as well as the Session Resumption ticket, if provided by the gateway. A remote access gateway conforming to both specifications will generate a QCD token for the client. When the gateway reboots, the client will discover this in either of two ways:",
      "ja": "ゲートウェイによって提供されている場合、両方の仕様に準拠したリモートアクセスクライアントは、QCDのトークンだけでなく、セッション再開チケットを格納します。両方の仕様に準拠したリモート・アクセス・ゲートウェイは、クライアントのQCDトークンを生成します。ゲートウェイを再起動すると、クライアントは次の2つの方法のいずれかでこれを発見します。"
    },
    {
      "indent": 3,
      "text": "1. The client does regular liveness checks, or else the time for some other IKE exchange has come. Since the gateway is still down, the IKE exchange times out after several minutes. In this case, QCD does not help.",
      "ja": "1.クライアントは、定期的な生存性のチェックを行い、または他のいくつかの他のIKE交換のための時間が来ています。ゲートウェイ以来IKE交換時間は、数分後に、まだダウンしています。この場合、QCDは役立ちません。"
    },
    {
      "indent": 3,
      "text": "2. Either the primary gateway or a backup gateway (see Section 6) is ready and sends a QCD token to the client. In that case, the client will quickly re-establish the IPsec tunnel, either with the rebooted primary gateway or the backup gateway as described in this document.",
      "ja": "2.プライマリゲートウェイまたはバックアップゲートウェイ（セクション6を参照）のいずれかの準備ができて、クライアントにQCDトークンを送信します。その場合、クライアントは、迅速いずれか再起動プライマリゲートウェイまたは本文書に記載されているようにバックアップゲートウェイと、IPsecトンネルを再確立します。"
    },
    {
      "indent": 3,
      "text": "The full combined protocol looks like this:",
      "ja": "フル組み合わせたプロトコルは、次のようになります。"
    },
    {
      "indent": 7,
      "text": " Initiator                Responder\n -----------              -----------\nHDR, SAi1, KEi, Ni  -->",
      "raw": true
    },
    {
      "indent": 27,
      "text": "<-- HDR, SAr1, KEr, Nr, [CERTREQ]",
      "ja": "< -  HDR、SAR1、KER、Nrと、[CERTREQ]"
    },
    {
      "indent": 7,
      "text": "HDR, SK {IDi, [CERT,] [CERTREQ,] [IDr,] AUTH, N(QCD_TOKEN) SAi2, TSi, TSr, N(TICKET_REQUEST)} --> <-- HDR, SK {IDr, [CERT,] AUTH, N(QCD_TOKEN), SAr2, TSi, TSr, N(TICKET_LT_OPAQUE) }",
      "ja": "HDR、SK {IDI、[CERT、] [CERTREQ、] [IDR、】AUTH、N（QCD_TOKEN）SAI2、をTSi、TSrを、N（TICKET_REQUEST）}  - > < -  HDR、SK {IDR [CERT、 ] AUTH、N（QCD_TOKEN）、SAR2、をTSi、TSrを、N（TICKET_LT_OPAQUE）}"
    },
    {
      "indent": 16,
      "text": "---- Reboot -----",
      "raw": true
    },
    {
      "indent": 7,
      "text": "HDR, {} --> <-- HDR, N(QCD_TOKEN)",
      "ja": "HDR、{}  - > < -  HDR、N（QCD_TOKEN）"
    },
    {
      "indent": 7,
      "text": "HDR, [N(COOKIE),] Ni, N(TICKET_OPAQUE) [,N+] --> <-- HDR, Nr [,N+]",
      "ja": "HDR、[N（COOKIE）]のNi、N（TICKET_OPAQUE）、N +]  - > < -  HDR、Nrの[N +]"
    },
    {
      "indent": 0,
      "text": "8. Operational Considerations",
      "section_title": true,
      "ja": "8.運用に関する注意事項"
    },
    {
      "indent": 0,
      "text": "8.1. Who Should Implement This Specification",
      "section_title": true,
      "ja": "8.1。誰がこの仕様を実装すべき"
    },
    {
      "indent": 3,
      "text": "Throughout this document, we have referred to reboot time alternatingly as the time that the implementation crashes and the time when it is ready to process IPsec packets and IKE exchanges. Depending on the hardware and software platforms and the cause of the reboot, rebooting may take anywhere from a few seconds to several minutes. If the implementation is down for a long time, the benefit of this protocol extension is reduced. For this reason, critical systems should implement backup gateways as described in Section 6.",
      "ja": "このドキュメントでは、我々は、実装がクラッシュして、IPsecパケットとIKE交換を処理する準備ができている時間という交互時間として時間を再起動するように言及しています。ハードウェアおよびソフトウェアプラットフォームと、再起動の原因によっては、再起動は数秒から数分かかります。実装が長時間ダウンしている場合は、このプロトコル拡張の利益が減少します。第6節で説明したようにこのような理由から、重要なシステムは、バックアップゲートウェイを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementing the \"token maker\" side of QCD makes sense for IKE implementation where protected connections originate from the peer, such as inter-domain VPNs and remote access gateways. Implementing the \"token taker\" side of QCD makes sense for IKE implementations where protected connections originate, such as inter-domain VPNs and remote access clients.",
      "ja": "QCDの「トークンメーカ」側を実装する保護された接続は、ドメイン間VPNおよびリモート・アクセス・ゲートウェイとして、ピアから発信IKEの実装のために理にかなっています。 QCDの「トークン係」側を実装すると、保護された接続は、このようなドメイン間VPNおよびリモートアクセスクライアントとして、発信IKEの実装のために理にかなっています。"
    },
    {
      "indent": 3,
      "text": "To clarify this discussion:",
      "ja": "この議論を明確にするには："
    },
    {
      "indent": 3,
      "text": "o For remote-access clients it makes sense to implement the token taker role.",
      "ja": "Oリモートアクセスクライアントの場合には、トークン係の役割を実装するために理にかなっています。"
    },
    {
      "indent": 3,
      "text": "o For remote-access gateways it makes sense to implement the token maker role.",
      "ja": "Oリモートアクセスゲートウェイの場合には、トークンのメーカーの役割を実装するために理にかなっています。"
    },
    {
      "indent": 3,
      "text": "o For inter-domain VPN gateways it makes sense to implement both roles, because it can't be known in advance where the traffic originates.",
      "ja": "トラフィックの出所は事前に知ることができないので、Oドメイン間VPNゲートウェイの場合には、両方の役割を実装するために理にかなっています。"
    },
    {
      "indent": 3,
      "text": "o It is perfectly valid to implement both roles in any case, for example, when using a single library or a single gateway to perform several roles.",
      "ja": "Oいくつかの役割を実行するために単一のライブラリーまたは単一のゲートウェイを使用する場合、例えば、いずれの場合にも両方の役割を実装するために完全に有効です。"
    },
    {
      "indent": 3,
      "text": "In order to limit the effects of Denial-of-Service (DoS) attacks, a token taker SHOULD limit the rate of QCD_TOKENs verified from a particular source.",
      "ja": "サービス拒否（DoS）攻撃の影響を制限するために、トークン受け手は、特定のソースから確認QCD_TOKENsの速度を制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "If excessive amounts of IKE requests protected with unknown IKE SPIs arrive at a token maker, the IKE module SHOULD revert to the behavior described in Section 2.21 of [RFC5996] and either send an INVALID_IKE_SPI notification or ignore it entirely.",
      "ja": "未知のIKEのSPIで保護されたIKE要求の過剰な量がトークンメーカに到着した場合は、IKEモジュールは、[RFC5996]のセクション2.21で説明した動作に戻す必要があり、どちらかINVALID_IKE_SPI通知を送信したり、それを完全に無視します。"
    },
    {
      "indent": 3,
      "text": "Section 9.2 requires that token makers never send a QCD token in the clear for a valid IKE SA and describes some configurations where this could occur. Implementations that may be installed in such configurations SHOULD automatically detect this and disable this extension in unsafe configurations and MUST allow the user to control whether the extension is enabled or disabled.",
      "ja": "9.2節は、トークンメーカーが有効なIKE SAのための明確でQCDトークンを送信しないことを要求し、これが発生する可能性があるいくつかの構成について説明します。このような構成で設置することができる実装がこれを自動的に検出し、安全でない構成でこの拡張機能を無効にし、ユーザが拡張を有効にするか無効にするかを制御することを可能にしなければならないべきです。"
    },
    {
      "indent": 0,
      "text": "8.2. Response to Unknown Child SPI",
      "section_title": true,
      "ja": "8.2。不明児童SPIへの対応"
    },
    {
      "indent": 3,
      "text": "After a reboot, it is more likely that an implementation will receive IPsec packets than IKE packets. In that case, the rebooted implementation will send an INVALID_SPI notification, triggering a liveness check. The token will only be sent in a response to the liveness check, thus requiring an extra round trip.",
      "ja": "再起動後、実装がIKEパケットよりも、IPsecパケットを受信する可能性が高いです。その場合には、再起動の実装は、生存性チェックをトリガー、INVALID_SPI通知を送信します。トークンは唯一のため、余分なラウンドトリップを必要とする、ライブネス・チェックに応答して送信されます。"
    },
    {
      "indent": 3,
      "text": "To avoid this, an implementation that has access to enough non-volatile storage MAY store a mapping of child SPIs to owning IKE SPIs, or to generated tokens. If such a mapping is available and persistent across reboots, the rebooted implementation SHOULD respond to the IPsec packet with an INVALID_SPI notification, along with the appropriate QCD_TOKEN notifications. A token taker SHOULD verify the QCD token that arrives with an INVALID_SPI notification the same as if it arrived with the IKE SPIs of the parent IKE SA.",
      "ja": "これを避けるために、十分な不揮発性ストレージへのアクセス権を持っている実装は、IKE SPIを所有する、または生成されたトークンに子のSPIのマッピングを格納することができます。このようなマッピングが使用可能とリブート後に永続的である場合は、再起動の実装は、適切なQCD_TOKEN通知とともに、INVALID_SPI通知でIPsecパケットに応答する必要があります。トークン受け手はそれが親IKE SAのIKEのSPIに到着したかのように同じINVALID_SPI通知に到着したQCDトークンを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "However, a persistent storage module might not be updated in a timely manner and could be populated with tokens relating to IKE SPIs that have already been rekeyed. A token taker MUST NOT take an invalid QCD token sent along with an INVALID_SPI notification as evidence that the peer is either malfunctioning or attacking, but it SHOULD limit the rate at which such notifications are processed.",
      "ja": "しかし、永続ストレージ・モジュールは、タイムリーに更新されないことがあり、すでにリキーされているIKEのSPIに関連するトークンを移入することができます。トークン受け手は、ピアが誤動作したり、攻撃のいずれかであることの証拠としてINVALID_SPI通知と一緒に送られた無効なQCDトークンを取るてはならないが、それは、そのような通知が処理される速度を制限する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The extension described in this document must not reduce the security of IKEv2 or IPsec. Specifically, an eavesdropper must not learn any non-public information about the peers.",
      "ja": "この文書で説明する拡張機能は、IKEv2のやIPsecのセキュリティを低下させなければなりません。具体的には、盗聴者は、ピアに関するすべての非公開情報を知る必要がありません。"
    },
    {
      "indent": 3,
      "text": "The proposed mechanism should be secure against attacks by a passive man in the middle (MITM) (eavesdropper). Such an attacker must not be able to disrupt an existing IKE session, either by resetting the session or by introducing significant delays. This requirement is especially significant, because this document introduces a new way to reset an IKE SA.",
      "ja": "提案されたメカニズムは、中間（MITM）（盗聴者）に受動的人による攻撃に対して安全であるべきです。このような攻撃者がセッションをリセットすることにより、または大幅な遅延を導入することにより、いずれか、既存のIKEセッションを中断させることができない必要があります。このドキュメントでは、IKE SAをリセットするための新しい方法を紹介しますので、この要件は、特に重要です。"
    },
    {
      "indent": 3,
      "text": "The mechanism need not be similarly secure against an active MITM, since this type of attacker is already able to disrupt IKE sessions.",
      "ja": "メカニズムは、攻撃者のこのタイプはすでにIKEセッションを中断させることが可能であるため、同様に、アクティブなMITMに対して安全である必要はありません。"
    },
    {
      "indent": 0,
      "text": "9.1. QCD Token Generation and Handling",
      "section_title": true,
      "ja": "9.1。 QCDトークン生成および取扱い"
    },
    {
      "indent": 3,
      "text": "Tokens MUST be hard to guess. This is critical, because if an attacker can guess the token associated with an IKE SA, they can tear down the IKE SA and associated tunnels at will. When the token is delivered in the IKE_AUTH exchange, it is encrypted. When it is sent again in an unprotected notification, it is not, but that is the last time this token is ever used.",
      "ja": "トークンは推測するのは難しいでなければなりません。攻撃者がIKE SAに関連付けられたトークンを推測することができれば、彼らは意志でIKE SAと関連するトンネルを取り壊すことができますので、これは、非常に重要です。トークンはIKE_AUTH交換に配信されると、それが暗号化されています。それが保護されていない通知に再び送信されると、そうではありませんが、それは、このトークンがこれまで使用されている最後の時間です。"
    },
    {
      "indent": 3,
      "text": "An aggregation of some tokens generated by one maker together with the related IKE SPIs MUST NOT give an attacker the ability to guess other tokens. Specifically, if one taker does not properly secure the QCD tokens and an attacker gains access to them, this attacker MUST NOT be able to guess other tokens generated by the same maker. This is the reason that the QCD_SECRET in Section 5.1 needs to be sufficiently long.",
      "ja": "一緒に関連するIKEのSPIと1メーカーによって生成されたいくつかのトークンの凝集が攻撃者に他のトークンを推測する能力を与えてはなりません。 1つの係が正しくQCDトークンとそれらへの攻撃者のアクセスを確保していない場合は具体的に、この攻撃者は、同じメーカーによって生成された他のトークンを推測できないようにする必要があり。これは、セクション5.1ニーズのQCD_SECRETは十分な長さにすることの理由です。"
    },
    {
      "indent": 3,
      "text": "The token taker MUST store the token in a secure manner. No attacker should be able to gain access to a stored token.",
      "ja": "トークン受け手は、安全な方法でトークンを保存しなければなりません。いいえ、攻撃者は、格納されたトークンにアクセスすることはできないはずです。"
    },
    {
      "indent": 3,
      "text": "The QCD_SECRET MUST be protected from access by other parties. Anyone gaining access to this value will be able to delete all the IKE SAs for this token maker.",
      "ja": "QCD_SECRETは、他の当事者によるアクセスから保護されなければなりません。この値にアクセスする誰もがこのトークンのメーカーのためにすべてのIKE SAを削除することができます。"
    },
    {
      "indent": 3,
      "text": "The QCD token is sent by the rebooted peer in an unprotected message. A message like that is subject to modification, deletion, and replay by an attacker. However, these attacks will not compromise the security of either side. Modification is meaningless because a modified token is simply an invalid token. Deletion will only cause the protocol not to work, resulting in a delay in tunnel re-establishment as described in Section 2. Replay is also meaningless, because the IKE SA has been deleted after the first transmission.",
      "ja": "QCDトークンは保護されていないメッセージに再起動ピアによって送信されます。そのようなメッセージは、攻撃者によって修正、削除、および再生の対象です。しかし、これらの攻撃は、どちらかの側のセキュリティを脅かすことはありません。変更されたトークンは、単に無効なトークンであるため、変更は無意味です。節に記載したようにIKE SAが最初の送信後に削除されているので、削除のみ、2リプレイも無意味であるトンネル再確立の遅延をもたらす、プロトコルが動作しないようになります。"
    },
    {
      "indent": 0,
      "text": "9.2. QCD Token Transmission",
      "section_title": true,
      "ja": "9.2。 QCDトークン送信"
    },
    {
      "indent": 3,
      "text": "A token maker MUST NOT send a valid QCD token in an unprotected message for an existing IKE SA.",
      "ja": "トークンメーカーは、既存のIKE SAのために保護されていないメッセージに有効なQCDトークンを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "This requirement is obvious and easy in the case of a single gateway. However, some implementations use a load balancer to divide the load between several physical gateways. It MUST NOT be possible even in such a configuration to trick one gateway into sending a valid QCD token for an IKE SA that is valid on another gateway. This is true whether the attempt to trick the gateway uses the token taker's IP address or a different IP address.",
      "ja": "この要件は、単一のゲートウェイの場合には明白で簡単です。しかし、いくつかの実装は、いくつかの物理的ゲートウェイ間の負荷を分割するためにロード・バランサを使用します。それは別のゲートウェイ上で有効なIKE SAの有効なQCDトークンを送るに1つのゲートウェイをだましても、このような構成で可能にすることはできません。これは、ゲートウェイを騙ししようとする試みは、トークン係のIPアドレスまたは異なるIPアドレスを使用するかどうか本当です。"
    },
    {
      "indent": 3,
      "text": "IPsec failure detection is not applicable to deployments where the QCD secret is shared by multiple gateways and the gateways cannot assess whether the token can be legitimately sent in the clear while another gateway may actually still own the SA's. Load balancing configurations typically fall in this category. In order for a load balancing configuration of IPsec gateways to support this specification, all members MUST be able to tell whether a particular IKE SA is active anywhere in the cluster. One way to do this is to synchronize a list of active IKE SPIs among all the cluster members.",
      "ja": "IPsecの障害検出は、QCDの秘密は、複数のゲートウェイによって共有され、ゲートウェイが他のゲートウェイが実際にはまだSAのを所有している間、トークンが合法的に平文で送信することが可能かどうかを評価することができない展開には適用されません。負荷分散構成は、通常、このカテゴリーに入ります。この仕様をサポートするためのIPsecゲートウェイの負荷分散構成にするためには、すべてのメンバーは、特定のIKE SAはどこにでもクラスタ内でアクティブであるかどうかを伝えることができなければなりません。これを行う1つの方法は、すべてのクラスタメンバー間でのアクティブIKEのSPIのリストを同期させることです。"
    },
    {
      "indent": 3,
      "text": "Because it includes the token taker's IP address in the token generation, the method in Section 5.2 can (under certain conditions) prevent revealing the QCD token for an existing pair of IKE SPIs to an attacker who is using a different IP address, even in a load-sharing cluster without state synchronization. That method does not prevent revealing the QCD token to an active attacker who is spoofing the token taker's IP address. Such an attacker may attempt to direct messages to a cluster member other than the member responsible for the IKE SA in an attempt to trick that gateway into sending a QCD token for a valid IKE SA. That method should not be used unless the load balancer guarantees that IKE packets from the same source IP address always go to the same cluster member.",
      "ja": "それはトークン生成トークン係のIPアドレスが含まれているため、第5.2節に方法が（一定の条件の下で）異なるIPアドレスを使用している攻撃者にIKEのSPIの既存のペアのためのQCDトークンを明らかに防止することができ、偶数で状態の同期なし負荷分散クラスタ。その方法は、トークン受け手のIPアドレスを偽装されたアクティブな攻撃者にQCDトークンを明らかに防ぐことはできません。このような攻撃者は、有効なIKE SAのためのQCDトークンを送信するにそのゲートウェイをだまししようとする試みでIKE SAのための責任ある一員以外のクラスタメンバーにメッセージを指示するために試みることができます。ロードバランサは、同じソースIPアドレスからIKEパケットは、常に同じクラスタメンバに行くことが保証されない限り、このメソッドは使用すべきではありません。"
    },
    {
      "indent": 0,
      "text": "9.3. QCD Token Enumeration",
      "section_title": true,
      "ja": "9.3。 QCDトークン列挙"
    },
    {
      "indent": 3,
      "text": "An attacker may try to attack QCD if the generation algorithm described in Section 5.1 is used. The attacker will send several fake IKE requests to the gateway under attack, receiving and recording the QCD tokens in the responses. This will allow the attacker to create a dictionary of IKE SPIs to QCD tokens, which can later be used to tear down any IKE SA.",
      "ja": "攻撃者は、セクション5.1で説明した生成アルゴリズムが使用されている場合QCDを攻撃しようとするかもしれません。攻撃者は、応答におけるQCDトークンを受信して​​記録し、攻撃を受けてゲートウェイにいくつかの偽のIKE要求を送信します。これにより、攻撃者は、後に任意のIKE SAを切断するために使用することができQCDトークンにIKEのSPIの辞書を作成することができます。"
    },
    {
      "indent": 3,
      "text": "Three factors mitigate this threat:",
      "ja": "3つの要因が、この脅威を緩和します："
    },
    {
      "indent": 3,
      "text": "o The space of all possible IKE SPI pairs is huge: 2^128, so making such a dictionary is impractical. Even if we assume that one implementation always generates predictable IKE SPIs, the space is still at least 2^64 entries, so making the dictionary is extremely hard. To ensure this, token makers MUST generate unpredictable IKE SPIs by using a cryptographically strong pseudo-random number generator.",
      "ja": "O可能なすべてのIKE SPIペアのスペースは巨大である：2 ^ 128、ので、このような辞書は非現実的である作ります。私たちは一つの実施は常に予測IKE SPIを生成することを前提としていても、スペースがとても辞書を作ることは非常に困難であり、まだ少なくとも2 ^ 64のエントリです。これを確実にするために、トークンメーカーは、暗号用に強化した擬似乱数生成器を使用することにより、予測不可能なIKE SPIを発生させなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Throttling the amount of QCD_TOKEN notifications sent out, as discussed in Section 8.1, especially when not soon after a crash will limit the attacker's ability to construct a dictionary.",
      "ja": "8.1節で述べたように、O QCD_TOKEN通知の量をスロットリングすることはありませんすぐにクラッシュした後、辞書を構築するために攻撃者の能力を制限する場合は特に、送り出されました。"
    },
    {
      "indent": 3,
      "text": "o The methods in Section 5.1 and Section 5.2 allow for a periodic change of the QCD_SECRET. Any such change invalidates the entire dictionary.",
      "ja": "5.1節と5.2節のメソッドoをQCD_SECRETの周期的な変化を可能とします。任意のそのような変更は、辞書全体が無効になります。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has assigned a notify message type (16419) from the status types range (16406-40959) of the \"IKEv2 Notify Message Types\" registry with the name \"QUICK_CRASH_DETECTION\".",
      "ja": "IANAは、名前「QUICK_CRASH_DETECTION」と「IKEv2のNOTIFYメッセージタイプ」レジストリの（16406から40959まで）の範囲ステータスタイプから通知メッセージタイプ（16419）を割り当てました。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgements",
      "section_title": true,
      "ja": "11.謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Hannes Tschofenig and Yaron Sheffer for their comments about Session Resumption.",
      "ja": "私たちは、セッション再開についての彼らのコメントのためのハンネスTschofenigとヤロンシェファーに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "Others who have contributed valuable comments are, in alphabetical order, Lakshminath Dondeti, Paul Hoffman, Tero Kivinen, Scott C Moonen, Magnus Nystrom, and Keith Welter.",
      "ja": "アルファベット順に、貴重なコメントをしている貢献してきた他、Lakshminath Dondeti、ポール・ホフマン、TERO Kivinen、スコット・C Moonen、マグナスNystrom、そしてキースウェルター。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12.参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4555] Eronen, P., \"IKEv2 Mobility and Multihoming Protocol (MOBIKE)\", RFC 4555, June 2006.",
      "ja": "[RFC4555] Eronen、P.、 \"IKEv2のモビリティとマルチホーミングプロトコル（MOBIKE）\"、RFC 4555、2006年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5996] Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", RFC 5996, September 2010.",
      "ja": "[RFC5996]カウフマン、C.、ホフマン、P.、ニール、Y.、およびP. Eronen、 \"インターネット鍵交換プロトコルバージョン2（IKEv2の）\"、RFC 5996、2010年9月。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC5723] Sheffer, Y. and H. Tschofenig, \"Internet Key Exchange Protocol Version 2 (IKEv2) Session Resumption\", RFC 5723, January 2010.",
      "ja": "[RFC5723]シェファー、Y.およびH. Tschofenig、 \"インターネット鍵交換プロトコルバージョン2（IKEv2の）セッション再開\"、RFC 5723、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6027] Nir, Y., \"IPsec Cluster Problem Statement\", RFC 6027, October 2010.",
      "ja": "[RFC6027]ニール、Y.、 \"IPsecのクラスタの問題に関する声明\"、RFC 6027、2010年10月。"
    },
    {
      "indent": 3,
      "text": "[recovery] Detienne, F., Sethi, P., and Y. Nir, \"Safe IKE Recovery\", Work in Progress, July 2009.",
      "ja": "[回復] Detienne、F.、セティ、P.、およびY.ニール、 \"安全なIKE回復\"、進捗状況、2009年7月での作業。"
    },
    {
      "indent": 0,
      "text": "Appendix A. The Path Not Taken",
      "ja": "付録A.パスが取られていません"
    },
    {
      "indent": 0,
      "text": "A.1. Initiating a New IKE SA",
      "ja": "A.1。新しいIKE SAを開始"
    },
    {
      "indent": 3,
      "text": "Instead of sending a QCD token, we could have the rebooted implementation start an Initial exchange with the peer, including the INITIAL_CONTACT notification. This would have the same effect, instructing the peer to erase the old IKE SA, as well as establishing a new IKE SA with fewer rounds.",
      "ja": "代わりに、QCDトークンを送信するのでは、我々は再起動実装がINITIAL_CONTACTの通知を含むピア、との最初の交換を開始する可能性があります。これは、古いIKE SAを消去するだけでなく、少数のラウンドで新しいIKE SAを確立するためにピアを指示し、同じ効果を持っているでしょう。"
    },
    {
      "indent": 3,
      "text": "The disadvantage here is that in IKEv2, an authentication exchange MUST have a piggybacked Child SA set up. Since our use-case is such that the rebooted implementation does not have traffic flowing to the peer, there are no good selectors for such a Child SA.",
      "ja": "ここでの欠点は、IKEv2の中で、認証交換は、SAを設定し、ピギーバックの子を持たなければならないということです。私たちのユースケースを再起動実装は、トラフィックがピアに流れていないようなものであるので、そのような子供SAには良いのセレクタはありません。"
    },
    {
      "indent": 3,
      "text": "Additionally, when authentication is asymmetric, such as when EAP is used, it is not possible for the rebooted implementation to initiate IKE.",
      "ja": "認証は、EAPを使用する場合のように、非対称である場合に加えて、それはIKEを開始するために再起動の実装のために不可能です。"
    },
    {
      "indent": 0,
      "text": "A.2. SIR",
      "ja": "A.2。お客様"
    },
    {
      "indent": 3,
      "text": "Another proposal that was considered for this work item is the SIR extension, which is described in [recovery]. Under that proposal, the non-rebooted peer sends a non-protected query to the possibly rebooted peer, asking whether the IKE SA exists. The peer replies with either a positive or negative response, and the absence of a positive response, along with the existence of a negative response, is taken as proof that the IKE SA has really been lost.",
      "ja": "この作業項目のために考えられたもう一つの提案は、[回復]で説明されたSIRの拡張子、です。その提案の下では、非再起動ピアは、IKE SAが存在するかどうかを尋ね、おそらく再起動ピアに保護されていないクエリを送信します。ピアは否定応答の有無とともに、IKE SAは本当に失われていることの証明とされ、正または負の応答、および肯定応答の欠如のいずれかで応答します。"
    },
    {
      "indent": 3,
      "text": "The working group preferred the QCD proposal to this one.",
      "ja": "ワーキンググループは、このいずれかにQCDの提案を好みました。"
    },
    {
      "indent": 0,
      "text": "A.3. Birth Certificates",
      "ja": "A.3。出生証明書"
    },
    {
      "indent": 3,
      "text": "Birth Certificates is a method of crash detection that has never been formally defined. Bill Sommerfeld suggested this idea in a mail to the IPsec mailing list on August 7, 2000, in a thread discussing methods of crash detection:",
      "ja": "出生証明書は、正式に定義されていないクラッシュ検出する方法です。ビル・ゾンマーフェルトは、衝突検出の方法を議論スレッドで、2000年8月7日にIPsecのメーリングリストにメールでこの考えを示唆しました。"
    },
    {
      "indent": 7,
      "text": "If we have the system sign a \"birth certificate\" when it\nreboots (including a reboot time or boot sequence number),\nwe could include that with a \"bad spi\" ICMP error and in\nthe negotiation of the IKE SA.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "We believe that this method would have some problems. First, it requires Alice to store the certificate, so as to be able to compare the public keys. That requires more storage than does a QCD token. Additionally, the public key operations needed to verify the self-signed certificates are more expensive for Alice.",
      "ja": "私たちは、この方法は、いくつかの問題を抱えているだろうと信じています。まず、公開鍵を比較することができるように、証明書を保存するためにアリスが必要です。これは、QCDのトークンよりも多くのストレージを必要とします。また、自己署名証明書を検証するために必要な公開鍵の操作はアリスのために、より高価です。"
    },
    {
      "indent": 3,
      "text": "We believe that a symmetric-key operation such as proposed here is more light-weight and simple than that implied by the Birth Certificate idea.",
      "ja": "私たちは、ここで提案のような対称キーの操作は、より軽量で出生証明書のアイデアによって暗示さよりもシンプルであると信じています。"
    },
    {
      "indent": 0,
      "text": "A.4. Reducing Liveness Check Length",
      "ja": "A.4。生体検知長を短縮"
    },
    {
      "indent": 3,
      "text": "Some implementations require fewer retransmissions over a shorter period of time for cases of liveness check started because of an INVALID_SPI or INVALID_IKE_SPI notification.",
      "ja": "一部の実装では、生存性チェックの例があるためINVALID_SPIまたはINVALID_IKE_SPI通知の開始のための時間の短い期間にわたって、より少ない再送信を要求します。"
    },
    {
      "indent": 3,
      "text": "We believe that the default retransmission policy should represent a good balance between the need for a timely discovery of a dead peer, and a low probability of false detection. We expect the policy to be set to take the shortest time such that this probability achieves a certain target. Therefore, we believe that reducing the elapsed time and retransmission count may create an unacceptably high probability of false detection, and this can be triggered by a single INVALID_IKE_SPI notification.",
      "ja": "私たちは、デフォルトの再送信ポリシーが死んだピアのタイムリーな発見のための必要性、および誤検出の確率が低いとの間に良好なバランスを表現しなければならないと考えています。私たちは、ポリシーは、この確率は、特定の目標を達成すること、このような最短時間を取るように設定されることを期待します。したがって、我々は、経過時間と再送回数を低減することが誤検出の許容できないほど高い確率を作成する可能性があると考えているが、これは、単一のINVALID_IKE_SPI通知によってトリガすることができます。"
    },
    {
      "indent": 3,
      "text": "Additionally, even if the retransmission policy is reduced to, say, one minute, it is still a very noticeable delay from a human perspective, from the time that the gateway has come up (i.e., is able to respond with an INVALID_SPI or INVALID_IKE_SPI notification) and until the tunnels are active, or from the time the backup gateway has taken over until the tunnels are active. The use of QCD tokens can reduce this delay.",
      "ja": "また、再送ポリシーは1分、たとえば、に縮小されている場合でも、それはまだ人間の観点から非常に顕著な遅延で、ゲートウェイが来ている時間（すなわちから、INVALID_SPIまたはINVALID_IKE_SPI通知で応答することができます）とトンネルがアクティブであるか、またはトンネルがアクティブになるまでの時間からバックアップゲートウェイが引き継ぐまで。 QCDトークンの使用は、この遅延を低減することができます。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Yoav Nir (editor) Check Point Software Technologies, Ltd. 5 Hasolelim st. Tel Aviv 67897 Israel",
      "ja": "ヨアフニール（編集者）、（株）5 Hasolelim STのチェック・ポイント・ソフトウェア・テクノロジーズ。テルアビブ67897イスラエル"
    },
    {
      "indent": 3,
      "text": "EMail: ynir@checkpoint.com",
      "ja": "メールアドレス：ynir@checkpoint.com"
    },
    {
      "indent": 3,
      "text": "David Wierbowski International Business Machines 1701 North Street Endicott, New York 13760 United States",
      "ja": "デビッドWierbowskiはInternational Business Machines 1701ノースストリートエンディコット、ニューヨーク13760米国"
    },
    {
      "indent": 3,
      "text": "EMail: wierbows@us.ibm.com",
      "ja": "メールアドレス：wierbows@us.ibm.com"
    },
    {
      "indent": 3,
      "text": "Frederic Detienne Cisco Systems, Inc. De Kleetlaan, 7 Diegem B-1831 Belgium",
      "ja": "フレデリックDetienneシスコシステムズ、株式会社デKleetlaan、7ディーゲムB-1831ベルギー"
    },
    {
      "indent": 3,
      "text": "Phone: +32 2 704 5681 EMail: fd@cisco.com",
      "ja": "電話：+32 2 704 5681 Eメール：fd@cisco.com"
    },
    {
      "indent": 3,
      "text": "Pratima Sethi Cisco Systems, Inc. O'Shaugnessy Road, 11 Bangalore, Karnataka 560027 India",
      "ja": "Pratimaセティシスコシステムズ、株式会社O'Shaugnessy道路、11カルナータカ州バンガロール560027インド"
    },
    {
      "indent": 3,
      "text": "Phone: +91 80 4154 1654 EMail: psethi@cisco.com",
      "ja": "電話：+91 80 4154 1654 Eメール：psethi@cisco.com"
    }
  ]
}