{
  "title": {
    "text": "RFC 6238 - TOTP: Time-Based One-Time Password Algorithm",
    "ja": "RFC 6238 - TOTP：時間ベースのワンタイムパスワードアルゴリズム"
  },
  "number": 6238,
  "created_at": "2019-11-01 00:11:24.874461+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        D. M'Raihi\nRequest for Comments: 6238                                Verisign, Inc.\nCategory: Informational                                       S. Machani\nISSN: 2070-1721                                         Diversinet Corp.\n                                                                  M. Pei\n                                                                Symantec\n                                                               J. Rydell\n                                                          Portwise, Inc.\n                                                                May 2011",
      "raw": true
    },
    {
      "indent": 14,
      "text": "TOTP: Time-Based One-Time Password Algorithm",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes an extension of the One-Time Password (OTP) algorithm, namely the HMAC-based One-Time Password (HOTP) algorithm, as defined in RFC 4226, to support the time-based moving factor. The HOTP algorithm specifies an event-based OTP algorithm, where the moving factor is an event counter. The present work bases the moving factor on a time value. A time-based variant of the OTP algorithm provides short-lived OTP values, which are desirable for enhanced security.",
      "ja": "時間ベースの移動率をサポートするために、RFC 4226で定義されるように、この文書では、ワンタイムパスワード（OTP）アルゴリズム、すなわちHMACベースのワンタイムパスワード（HOTP）アルゴリズムの拡張を記述しています。 HOTPアルゴリズムは移動係数は、イベントカウンタでイベントベースのOTPアルゴリズムを指定します。本研究拠点の時間値に移動する要因。 OTPアルゴリズムの時間ベースの変形は、セキュリティを強化するために望ましい短命OTP値を、提供します。"
    },
    {
      "indent": 3,
      "text": "The proposed algorithm can be used across a wide range of network applications, from remote Virtual Private Network (VPN) access and Wi-Fi network logon to transaction-oriented Web applications. The authors believe that a common and shared algorithm will facilitate adoption of two-factor authentication on the Internet by enabling interoperability across commercial and open-source implementations.",
      "ja": "提案したアルゴリズムは、トランザクション指向のWebアプリケーションへのリモート仮想プライベートネットワーク（VPN）アクセスとWi-Fiネットワークログオンから、ネットワークアプリケーションの広い範囲にわたって使用することができます。著者は、共通の共有アルゴリズムは、商用およびオープンソース実装で相互運用性を可能にすることにより、インターネット上の二要素認証の採用を容易にするであろうと信じています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6238.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6238で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2011 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n   1.1. Scope ......................................................2\n   1.2. Background .................................................3\n2. Notation and Terminology ........................................3\n3. Algorithm Requirements ..........................................3\n4. TOTP Algorithm ..................................................4\n   4.1. Notations ..................................................4\n   4.2. Description ................................................4\n5. Security Considerations .........................................5\n   5.1. General ....................................................5\n   5.2. Validation and Time-Step Size ..............................6\n6. Resynchronization ...............................................7\n7. Acknowledgements ................................................7\n8. References ......................................................8\n   8.1. Normative References .......................................8\n   8.2. Informative References .....................................8\nAppendix A. TOTP Algorithm: Reference Implementation ...............9\nAppendix B. Test Vectors ..........................................14",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. Scope",
      "section_title": true,
      "ja": "1.1。範囲"
    },
    {
      "indent": 3,
      "text": "This document describes an extension of the One-Time Password (OTP) algorithm, namely the HMAC-based One-Time Password (HOTP) algorithm, as defined in [RFC4226], to support the time-based moving factor.",
      "ja": "[RFC4226]で定義されるように、この文書では、時間ベースのファクタを移動をサポートするために、ワンタイムパスワード（OTP）アルゴリズム、すなわちHMACベースのワンタイムパスワード（HOTP）アルゴリズムの拡張を記述しています。"
    },
    {
      "indent": 0,
      "text": "1.2. Background",
      "section_title": true,
      "ja": "1.2。バックグラウンド"
    },
    {
      "indent": 3,
      "text": "As defined in [RFC4226], the HOTP algorithm is based on the HMAC-SHA-1 algorithm (as specified in [RFC2104]) and applied to an increasing counter value representing the message in the HMAC computation.",
      "ja": "[RFC4226]で定義されるように、HOTPアルゴリズムはHMAC-SHA-1アルゴリズム（[RFC2104]で指定されるように）に基づいてHMAC計算におけるメッセージを表す増加するカウンタ値に適用されます。"
    },
    {
      "indent": 3,
      "text": "Basically, the output of the HMAC-SHA-1 calculation is truncated to obtain user-friendly values:",
      "ja": "基本的には、HMAC-SHA-1計算の出力は、ユーザーフレンドリーな値を得るために切り捨てられます。"
    },
    {
      "indent": 6,
      "text": "HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))",
      "ja": "HOTP（K、C）=切捨て（HMAC-SHA-1（K、C））"
    },
    {
      "indent": 3,
      "text": "where Truncate represents the function that can convert an HMAC-SHA-1 value into an HOTP value. K and C represent the shared secret and counter value; see [RFC4226] for detailed definitions.",
      "ja": "切り捨ては、HOTP値にHMAC-SHA-1値を変換することができる機能を表します。 KおよびCは、共有秘密とカウンタ値を表します。詳細な定義については、[RFC4226]を参照してください。"
    },
    {
      "indent": 3,
      "text": "TOTP is the time-based variant of this algorithm, where a value T, derived from a time reference and a time step, replaces the counter C in the HOTP computation.",
      "ja": "TOTPは時間基準との時間ステップから得られた値Tが、HOTP計算にカウンタCを置き換えこのアルゴリズムの時間ベースの変異体です。"
    },
    {
      "indent": 3,
      "text": "TOTP implementations MAY use HMAC-SHA-256 or HMAC-SHA-512 functions, based on SHA-256 or SHA-512 [SHA2] hash functions, instead of the HMAC-SHA-1 function that has been specified for the HOTP computation in [RFC4226].",
      "ja": "TOTP実装は代わりにHOTP計算のために指定されたHMAC-SHA-1機能の、SHA-256やSHA-512 [SHA2]ハッシュ関数に基づいて、HMAC-SHA-256またはHMAC-SHA-512の機能を使用するかもしれ[RFC4226]。"
    },
    {
      "indent": 0,
      "text": "2. Notation and Terminology",
      "section_title": true,
      "ja": "2.表記と用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Algorithm Requirements",
      "section_title": true,
      "ja": "3.アルゴリズムの要件"
    },
    {
      "indent": 3,
      "text": "This section summarizes the requirements taken into account for designing the TOTP algorithm.",
      "ja": "このセクションでは、TOTPアルゴリズムを設計するために考慮要件をまとめたもの。"
    },
    {
      "indent": 3,
      "text": "R1: The prover (e.g., token, soft token) and verifier (authentication or validation server) MUST know or be able to derive the current Unix time (i.e., the number of seconds elapsed since midnight UTC of January 1, 1970) for OTP generation. See [UT] for a more detailed definition of the commonly known \"Unix time\". The precision of the time used by the prover affects how often the clock synchronization should be done; see Section 6.",
      "ja": "R1：OTPのための証明（例えば、トークン、ソフトトークン）と検証（認証又は検証サーバ）知っているか、または現在のUnix時間を導出できなければならない（1970年1月1日の真夜中のUTCからの経過秒すなわち、数）世代。一般的に知られている「Unixの時間」のより詳細な定義について[UT]を参照してください。証明によって使用される時間の精度は、クロック同期が行われるべき頻度に影響します。第6章を参照してください。"
    },
    {
      "indent": 3,
      "text": "R2: The prover and verifier MUST either share the same secret or the knowledge of a secret transformation to generate a shared secret.",
      "ja": "R2：証明者と検証者は同じ秘密または共有秘密を生成するために秘密の変換の知識を共有する必要があります。"
    },
    {
      "indent": 3,
      "text": "R3: The algorithm MUST use HOTP [RFC4226] as a key building block.",
      "ja": "R3：アルゴリズムは、重要なビルディングブロックとしてHOTP [RFC4226]を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "R4: The prover and verifier MUST use the same time-step value X.",
      "ja": "R4：証明者と検証者が同じ時間ステップ値を使用しなければならないX."
    },
    {
      "indent": 3,
      "text": "R5: There MUST be a unique secret (key) for each prover.",
      "ja": "R5：各証明のためのユニークな秘密（キー）が存在でなければなりません。"
    },
    {
      "indent": 3,
      "text": "R6: The keys SHOULD be randomly generated or derived using key derivation algorithms.",
      "ja": "R6：キーがランダムに生成又はキー導出アルゴリズムを用いて導出されるべきです。"
    },
    {
      "indent": 3,
      "text": "R7: The keys MAY be stored in a tamper-resistant device and SHOULD be protected against unauthorized access and usage.",
      "ja": "R7：鍵は耐タンパデバイスに格納されてもよいし、不正アクセスおよび使用に対して保護されるべきです。"
    },
    {
      "indent": 0,
      "text": "4. TOTP Algorithm",
      "section_title": true,
      "ja": "4. TOTPアルゴリズム"
    },
    {
      "indent": 3,
      "text": "This variant of the HOTP algorithm specifies the calculation of a one-time password value, based on a representation of the counter as a time factor.",
      "ja": "HOTPアルゴリズムのこの変形は、時間因子としてのカウンタの表示に基づいてワンタイムパスワード値の計算を、指定します。"
    },
    {
      "indent": 0,
      "text": "4.1. Notations",
      "section_title": true,
      "ja": "4.1。表記"
    },
    {
      "indent": 3,
      "text": "o X represents the time step in seconds (default value X = 30 seconds) and is a system parameter.",
      "ja": "O Xは、秒単位の時間ステップ（デフォルト値X = 30秒）を表し、システムパラメータです。"
    },
    {
      "indent": 3,
      "text": "o T0 is the Unix time to start counting time steps (default value is 0, i.e., the Unix epoch) and is also a system parameter.",
      "ja": "O T0は、時間ステップのカウントを開始するには、UNIX時間（デフォルト値は0、即ち、Unixエポックである）であり、また、システム・パラメータです。"
    },
    {
      "indent": 0,
      "text": "4.2. Description",
      "section_title": true,
      "ja": "4.2。説明"
    },
    {
      "indent": 3,
      "text": "Basically, we define TOTP as TOTP = HOTP(K, T), where T is an integer and represents the number of time steps between the initial counter time T0 and the current Unix time.",
      "ja": "基本的に、我々は、Tは整数であり、初期のカウンタ時間T0と現在のUnix時刻の間の時間ステップの数を表しTOTP = HOTP（K、T）としてTOTPを定義します。"
    },
    {
      "indent": 3,
      "text": "More specifically, T = (Current Unix time - T0) / X, where the default floor function is used in the computation.",
      "ja": "より具体的には、T =（現在のUnix時間 -  T0）/デフォルトフロア関数が計算に使用されるX、。"
    },
    {
      "indent": 3,
      "text": "For example, with T0 = 0 and Time Step X = 30, T = 1 if the current Unix time is 59 seconds, and T = 2 if the current Unix time is 60 seconds.",
      "ja": "現在のUnix時間は60秒である場合、例えば、T0 = 0と時間ステップX = 30で、T = 1の現在のUnixタイム場合は59秒であり、T = 2。"
    },
    {
      "indent": 3,
      "text": "The implementation of this algorithm MUST support a time value T larger than a 32-bit integer when it is beyond the year 2038. The value of the system parameters X and T0 are pre-established during the provisioning process and communicated between a prover and verifier as part of the provisioning step. The provisioning flow is out of scope of this document; refer to [RFC6030] for such provisioning container specifications.",
      "ja": "それは年間2038を越えてXおよびT0は、プロビジョニングプロセス中に予め確立されたと証明者と検証者との間で通信されるシステム・パラメータの値である場合、このアルゴリズムの実装は、32ビット整数よりも大きなT時間値をサポートしなければなりませんプロビジョニング・ステップの一部として。プロビジョニング・フローは、この文書の範囲外です。そのようなプロビジョニングコンテナの仕様のために[RFC6030]を参照。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 0,
      "text": "5.1. General",
      "section_title": true,
      "ja": "5.1。一般的な"
    },
    {
      "indent": 3,
      "text": "The security and strength of this algorithm depend on the properties of the underlying building block HOTP, which is a construction based on HMAC [RFC2104] using SHA-1 as the hash function.",
      "ja": "このアルゴリズムのセキュリティと強度は、ハッシュ関数としてSHA-1を用いたHMAC [RFC2104]に基づいて構築され、基礎となるビルディングブロックHOTPの特性に依存します。"
    },
    {
      "indent": 3,
      "text": "The conclusion of the security analysis detailed in [RFC4226] is that, for all practical purposes, the outputs of the dynamic truncation on distinct inputs are uniformly and independently distributed strings.",
      "ja": "[RFC4226]に詳細なセキュリティ解析の結論は、すべての実用的な目的のために、別個の入力のダイナミックトランケーションの出力が一様にかつ独立して文字列を分散している、ということです。"
    },
    {
      "indent": 3,
      "text": "The analysis demonstrates that the best possible attack against the HOTP function is the brute force attack.",
      "ja": "分析は、HOTP機能に対する最善の攻撃はブルートフォース攻撃であることを示しています。"
    },
    {
      "indent": 3,
      "text": "As indicated in the algorithm requirement section, keys SHOULD be chosen at random or using a cryptographically strong pseudorandom generator properly seeded with a random value.",
      "ja": "アルゴリズム要件セクションで示されるように、キーがランダムに選択されたか、正しくランダム値を播種暗号的に強い疑似乱数発生器を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Keys SHOULD be of the length of the HMAC output to facilitate interoperability.",
      "ja": "キーは相互運用性を促進するために、HMAC出力の長さであるべきです。"
    },
    {
      "indent": 3,
      "text": "We RECOMMEND following the recommendations in [RFC4086] for all pseudorandom and random number generations. The pseudorandom numbers used for generating the keys SHOULD successfully pass the randomness test specified in [CN], or a similar well-recognized test.",
      "ja": "我々は、すべての擬似乱数と乱数の世代のために[RFC4086]の推奨事項に従うことを推奨します。キーを生成するために使用される擬似乱数が正常[CN]で指定された乱数検定、または類似のよく認識テストを通過させなければなりません。"
    },
    {
      "indent": 3,
      "text": "All the communications SHOULD take place over a secure channel, e.g., Secure Socket Layer/Transport Layer Security (SSL/TLS) [RFC5246] or IPsec connections [RFC4301].",
      "ja": "すべての通信は、例えば、セキュア・ソケット・レイヤー/トランスポート層セキュリティ（SSL / TLS）[RFC5246]またはIPsec接続[RFC4301]、安全なチャネルを介して行われるべきです。"
    },
    {
      "indent": 3,
      "text": "We also RECOMMEND storing the keys securely in the validation system, and, more specifically, encrypting them using tamper-resistant hardware encryption and exposing them only when required: for example, the key is decrypted when needed to verify an OTP value, and re-encrypted immediately to limit exposure in the RAM to a short period of time.",
      "ja": "我々はまた、検証システムに安全に鍵を格納する、そして、より具体的には、耐タンパ性ハードウェア暗号化を使用して暗号化し、必要な場合にのみ、それらを露光するお勧め：OTP値を確認する必要がある場合、例えば、鍵が解読され、そして再短期間にRAMに露出を制限するために、すぐに暗号化されました。"
    },
    {
      "indent": 3,
      "text": "The key store MUST be in a secure area, to avoid, as much as possible, direct attack on the validation system and secrets database. Particularly, access to the key material should be limited to programs and processes required by the validation system only.",
      "ja": "キーストアは、可能な限り、検証システムと秘密のデータベースに直接攻撃を避けるために、安全な場所になければなりません。特に、キーマテリアルへのアクセスは、検証システムで必要なプログラムやプロセスに限定されるべきです。"
    },
    {
      "indent": 0,
      "text": "5.2. Validation and Time-Step Size",
      "section_title": true,
      "ja": "5.2。検証と時間ステップサイズ"
    },
    {
      "indent": 3,
      "text": "An OTP generated within the same time step will be the same. When an OTP is received at a validation system, it doesn't know a client's exact timestamp when an OTP was generated. The validation system may typically use the timestamp when an OTP is received for OTP comparison. Due to network latency, the gap (as measured by T, that is, the number of time steps since T0) between the time that the OTP was generated and the time that the OTP arrives at the receiving system may be large. The receiving time at the validation system and the actual OTP generation may not fall within the same time-step window that produced the same OTP. When an OTP is generated at the end of a time-step window, the receiving time most likely falls into the next time-step window. A validation system SHOULD typically set a policy for an acceptable OTP transmission delay window for validation. The validation system should compare OTPs not only with the receiving timestamp but also the past timestamps that are within the transmission delay. A larger acceptable delay window would expose a larger window for attacks. We RECOMMEND that at most one time step is allowed as the network delay.",
      "ja": "同じ時間ステップ内で生成されたOTPは同じになります。 OTPは、検証システムで受信されるとOTPが生成されたとき、それはクライアントの正確なタイムスタンプを知りません。 OTPは、OTPの比較のために受信されたときに検証システムは、典型的には、タイムスタンプを使用してもよいです。ネットワーク遅延に、ギャップ（Tによって測定されるように、すなわち、T0から時間ステップ数）OTPが生成された時間とOTPが受信システムに到着する時間との間には、大きくてもよいです。検証システム時刻を受信し、実際のOTP生成には同じOTPを生成同じ時間ステップのウィンドウ内に入らないかもしれません。 OTPは、時間ステップのウィンドウの終了時に発生した場合、受信時刻が最も可能性の高い次の時間ステップウィンドウに落ちます。検証システムは、典型的には、検証のために許容可能なOTP送信遅延ウィンドウのポリシーを設定する必要があります。検証システムは、受信タイムスタンプを持つだけでなく、伝送遅延の範囲内にある過去のタイムスタンプだけでなく、OTPを比較すべきです。より大きな許容遅延ウィンドウには、攻撃のための大きな窓を公開します。私たちは、最大で1時間ステップは、ネットワーク遅延として許されることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The time-step size has an impact on both security and usability. A larger time-step size means a larger validity window for an OTP to be accepted by a validation system. There are implications for using a larger time-step size, as follows:",
      "ja": "時間ステップのサイズは、セキュリティと使いやすさの両方に影響を与えます。より大きな時間ステップのサイズは、検証システムによって受け入れられるようにOTPのためのより大きな有効性ウィンドウを意味します。以下のように、より大きな時間ステップサイズを使用するための含意があります。"
    },
    {
      "indent": 3,
      "text": "First, a larger time-step size exposes a larger window to attack. When an OTP is generated and exposed to a third party before it is consumed, the third party can consume the OTP within the time-step window.",
      "ja": "まず、大きな時間ステップのサイズは、攻撃への大きなウィンドウを公開します。 OTPを生成し、それが消費される前に、第三者にさらされた場合、第三者が、時間ステップのウィンドウ内でOTPを消費することができます。"
    },
    {
      "indent": 3,
      "text": "We RECOMMEND a default time-step size of 30 seconds. This default value of 30 seconds is selected as a balance between security and usability.",
      "ja": "私たちは、30秒のデフォルトの時間ステップサイズをお勧めします。 30秒のこのデフォルト値は、セキュリティと利便性のバランスとして選択されています。"
    },
    {
      "indent": 3,
      "text": "Second, the next different OTP must be generated in the next time-step window. A user must wait until the clock moves to the next time-step window from the last submission. The waiting time may not be exactly the length of the time step, depending on when the last OTP was generated. For example, if the last OTP was generated at the halfway point in a time-step window, the waiting time for the next OTP is half the length of the time step. In general, a larger time-step window means a longer waiting time for a user to get the next valid OTP after the last successful OTP validation. A too-large window (for example, 10 minutes) most probably won't be suitable for typical Internet login use cases; a user may not be able to get the next OTP within 10 minutes and therefore will have to re-login to the same site in 10 minutes.",
      "ja": "第二に、次の異なるOTPは、次の時間ステップのウィンドウで生成されなければなりません。クロックは最後の提出から、次の時間ステップのウィンドウに移動するまで、ユーザーが待たなければなりません。待機時間は、最後のOTPが生成されたときに応じて、時間ステップの長さが正確ではないかもしれません。最後OTPが時間ステップウィンドウの途中の時点で生成された場合、例えば、次のOTPの待ち時間は、時間ステップの半分の長さです。一般的に、より大きな時間ステップウィンドウには、ユーザーが最後に成功したOTPを検証した後、次の有効なOTPを取得するための長い待ち時間を意味します。あまりにも大きな窓（例えば、10分）は、おそらく一般的なインターネットのログインユースケースに適していないでしょう。利用者は、10分以内に次のOTPを取得することができない場合がありますので、10分以内に同じサイトに再ログインする必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that a prover may send the same OTP inside a given time-step window multiple times to a verifier. The verifier MUST NOT accept the second attempt of the OTP after the successful validation has been issued for the first OTP, which ensures one-time only use of an OTP.",
      "ja": "証明者が検証者に与えられた時間ステップウィンドウ内で複数回同じOTPを送信してもよいことに留意されたいです。成功した検証がOTPの一回のみの使用を保証最初のOTP、のために発行された後の検証は、OTPの第二の試みを受け入れてはいけません。"
    },
    {
      "indent": 0,
      "text": "6. Resynchronization",
      "section_title": true,
      "ja": "6.再同期"
    },
    {
      "indent": 3,
      "text": "Because of possible clock drifts between a client and a validation server, we RECOMMEND that the validator be set with a specific limit to the number of time steps a prover can be \"out of synch\" before being rejected.",
      "ja": "クライアントと検証サーバ間の可能なクロックドリフトのため、私たちはバリデータは、時間の数に特定の制限を設定することをお勧めしますので証明者が拒否される前に、「同期外」することができ、ステップ。"
    },
    {
      "indent": 3,
      "text": "This limit can be set both forward and backward from the calculated time step on receipt of the OTP value. If the time step is 30 seconds as recommended, and the validator is set to only accept two time steps backward, then the maximum elapsed time drift would be around 89 seconds, i.e., 29 seconds in the calculated time step and 60 seconds for two backward time steps.",
      "ja": "この制限は、両方の前後OTP値の受領に基づいて計算時間ステップから設定することができます。時間ステップが推奨されるように30秒で、バリデータのみに設定されている場合は、2つの時間が後方ステップ、最大経過時間ドリフトが後方2について計算時間ステップで約89秒、すなわち、29秒と60秒となり受け入れます時間ステップ。"
    },
    {
      "indent": 3,
      "text": "This would mean the validator could perform a validation against the current time and then two further validations for each backward step (for a total of 3 validations). Upon successful validation, the validation server can record the detected clock drift for the token in terms of the number of time steps. When a new OTP is received after this step, the validator can validate the OTP with the current timestamp adjusted with the recorded number of time-step clock drifts for the token.",
      "ja": "このバリデータは、現在の時間に対して検証を実行した後（3つの検証の合計）は、各下位段階のために、さらに2つの検証可能性を意味します。検証が成功したときに、検証サーバは、時間ステップの数に関してトークンの検出されたクロックドリフトを記録することができます。新しいOTPこのステップの後に受信された場合、バリデータは、時間ステップのクロックの記録数で調整現在のタイムスタンプトークンのためにドリフトしてOTPを検証することができます。"
    },
    {
      "indent": 3,
      "text": "Also, it is important to note that the longer a prover has not sent an OTP to a validation system, the longer (potentially) the accumulated clock drift between the prover and the verifier. In such cases, the automatic resynchronization described above may not work if the drift exceeds the allowed threshold. Additional authentication measures should be used to safely authenticate the prover and explicitly resynchronize the clock drift between the prover and the validator.",
      "ja": "また、より長い証明者が検証システムにOTP、証明者と検証者との間のより長い（潜在的に）蓄積されたクロックドリフトを送信していないことに注意することが重要です。ドリフトが許容閾値を超えた場合、このような場合には、上述した自動再同期が動作しない場合があります。追加の認証対策が安全証明を認証し、明示的に証明とバリデータ間のクロックドリフトを再同期するために使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "7. Acknowledgements",
      "section_title": true,
      "ja": "7.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors of this document would like to thank the following people for their contributions and support to make this a better specification: Hannes Tschofenig, Jonathan Tuliani, David Dix, Siddharth Bajaj, Stu Veath, Shuh Chang, Oanh Hoang, John Huang, and Siddhartha Mohapatra.",
      "ja": "本書の著者は、彼らの貢献のために、以下の人々に感謝し、この優れた仕様にするためにサポートしたいと思います：ハンネスTschofenig、ジョナサンTuliani、デビッド・ディックス、シッダールタバジャジ、ステューVeath、Shuhチャン、Oanhホアン、ジョン・黄、およびシッダールタMohapatra。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Recommendations for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク3、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム推奨事項\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4226] M'Raihi, D., Bellare, M., Hoornaert, F., Naccache, D., and O. Ranen, \"HOTP: An HMAC-Based One-Time Password Algorithm\", RFC 4226, December 2005.",
      "ja": "[RFC4226] M'Raihi、D.、ベラー、M.、Hoornaert、F.、Naccache、D.、およびO. Ranen、 \"HOTP：HMACベースのワンタイムパスワードアルゴリズム\"、RFC 4226、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[SHA2] NIST, \"FIPS PUB 180-3: Secure Hash Standard (SHS)\", October 2008, <http://csrc.nist.gov/publications/fips/ fips180-3/fips180-3_final.pdf>.",
      "ja": "[SHA2] NIST、 \"FIPS PUB 180-3の：セキュアハッシュ標準（SHS）\"、2008年10月、<http://csrc.nist.gov/publications/fips/ fips180-3 / fips180-3_final.pdf>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[CN] Coron, J. and D. Naccache, \"An Accurate Evaluation of Maurer's Universal Test\", LNCS 1556, February 1999, <http://www.gemplus.com/smart/rd/publications/pdf/ CN99maur.pdf>.",
      "ja": "[CN]コロン、J.およびD. Naccache、 \"マウラーのユニバーサル試験の正確な評価\"、LNCS 1556、1999年2月、<http://www.gemplus.com/smart/rd/publications/pdf/ CN99maur.pdf >。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[RFC4301]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6030] Hoyer, P., Pei, M., and S. Machani, \"Portable Symmetric Key Container (PSKC)\", RFC 6030, October 2010.",
      "ja": "[RFC6030]ホイヤー、P.、ペイ、M.、およびS. Machani、 \"ポータブル対称キーコンテナ（PSKC）\"、RFC 6030、2010年10月。"
    },
    {
      "indent": 3,
      "text": "[UT] Wikipedia, \"Unix time\", February 2011, <http://en.wikipedia.org/wiki/Unix_time>.",
      "ja": "[UT]ウィキペディア、 \"Unixの時間\"、2011年2月、<http://en.wikipedia.org/wiki/Unix_time>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. TOTP Algorithm: Reference Implementation",
      "ja": "付録A. TOTPアルゴリズム：リファレンス実装"
    },
    {
      "indent": 1,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 1,
      "text": "/**\nCopyright (c) 2011 IETF Trust and the persons identified as\nauthors of the code. All rights reserved.",
      "raw": true
    },
    {
      "indent": 1,
      "text": "Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info). */",
      "ja": "、に基づき許可されており、中に含まれるライセンス条項に従う、簡体BSDライセンスは、IETFドキュメントに関連IETFトラストの法律規定（のセクション4.Cに記載されている変更の有無にかかわらず、ソースおよびバイナリ形式での再配布および使用http://trustee.ietf.org/license-info）。 * /"
    },
    {
      "indent": 1,
      "text": "import java.lang.reflect.UndeclaredThrowableException;\nimport java.security.GeneralSecurityException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.math.BigInteger;\nimport java.util.TimeZone;",
      "raw": true
    },
    {
      "indent": 1,
      "text": "/**\n * This is an example implementation of the OATH\n * TOTP algorithm.\n * Visit www.openauthentication.org for more information.\n *\n * @author Johan Rydell, PortWise, Inc.\n */",
      "raw": true
    },
    {
      "indent": 1,
      "text": "public class TOTP {",
      "ja": "パブリッククラスTOTP {"
    },
    {
      "indent": 5,
      "text": "private TOTP() {}",
      "ja": "プライベートTOTP（）{}"
    },
    {
      "indent": 5,
      "text": "/**\n * This method uses the JCE to provide the crypto algorithm.\n * HMAC computes a Hashed Message Authentication Code with the\n * crypto hash algorithm as a parameter.\n *\n * @param crypto: the crypto algorithm (HmacSHA1, HmacSHA256,\n *                             HmacSHA512)\n * @param keyBytes: the bytes to use for the HMAC key\n * @param text: the message or text to be authenticated\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "private static byte[] hmac_sha(String crypto, byte[] keyBytes,\n        byte[] text){\n    try {\n        Mac hmac;\n        hmac = Mac.getInstance(crypto);\n        SecretKeySpec macKey =\n            new SecretKeySpec(keyBytes, \"RAW\");\n        hmac.init(macKey);\n        return hmac.doFinal(text);\n    } catch (GeneralSecurityException gse) {\n        throw new UndeclaredThrowableException(gse);\n    }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/**\n * This method converts a HEX string to Byte[]\n *\n * @param hex: the HEX string\n *\n * @return: a byte array\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "private static byte[] hexStr2Bytes(String hex){ // Adding one byte to get the right conversion // Values starting with \"0\" can be converted byte[] bArray = new BigInteger(\"10\" + hex,16).toByteArray();",
      "ja": "1バイトの追加プライベート静的バイト[] hexStr2Bytes（文字列六角）{//バイト[] bArray =新規のBigInteger（「10」+進、16）.toByteArray変換することができる「0」で始まる右変換//値を取得します（）;"
    },
    {
      "indent": 5,
      "text": "    // Copy all the REAL bytes, not the \"first\"\n    byte[] ret = new byte[bArray.length - 1];\n    for (int i = 0; i < ret.length; i++)\n        ret[i] = bArray[i+1];\n    return ret;\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "private static final int[] DIGITS_POWER // 0 1 2 3 4 5 6 7 8 = {1,10,100,1000,10000,100000,1000000,10000000,100000000 };",
      "ja": "プライベート静的最終int型= {1,10,100,1000,10000,100000,1000000,10000000,100000000} // 0 1 2 3 4 5 6 7 8 [] DIGITS_POWER。"
    },
    {
      "indent": 5,
      "text": "/**\n * This method generates a TOTP value for the given\n * set of parameters.\n *\n * @param key: the shared secret, HEX encoded\n * @param time: a value that reflects a time\n * @param returnDigits: number of digits to return\n *\n * @return: a numeric String in base 10 that includes\n *              {@link truncationDigits} digits\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "public static String generateTOTP(String key, String time, String returnDigits){ return generateTOTP(key, time, returnDigits, \"HmacSHA1\"); }",
      "ja": "公共の静的な文字列generateTOTP（文字列キー、文字列の時間、ストリングreturnDigits）{generateTOTP（キー、時間、returnDigits、 \"HmacSHA1\"）を返します。 }"
    },
    {
      "indent": 5,
      "text": "/**\n * This method generates a TOTP value for the given\n * set of parameters.\n *\n * @param key: the shared secret, HEX encoded\n * @param time: a value that reflects a time\n * @param returnDigits: number of digits to return\n *\n * @return: a numeric String in base 10 that includes\n *              {@link truncationDigits} digits\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "public static String generateTOTP256(String key, String time, String returnDigits){ return generateTOTP(key, time, returnDigits, \"HmacSHA256\"); }",
      "ja": "公共の静的な文字列generateTOTP256（文字列キーは、文字列の時間は、文字列returnDigits）{generateTOTPを返す（キー、時間、returnDigits、 \"HMACSHA256\"）。 }"
    },
    {
      "indent": 5,
      "text": "/**\n * This method generates a TOTP value for the given\n * set of parameters.\n *\n * @param key: the shared secret, HEX encoded\n * @param time: a value that reflects a time\n * @param returnDigits: number of digits to return\n *\n * @return: a numeric String in base 10 that includes\n *              {@link truncationDigits} digits\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "public static String generateTOTP512(String key, String time, String returnDigits){ return generateTOTP(key, time, returnDigits, \"HmacSHA512\"); }",
      "ja": "公共の静的な文字列generateTOTP512（文字列キーは、文字列の時間は、文字列returnDigits）{generateTOTPを返す（キー、時間、returnDigits、 \"HmacSHA512\"）。 }"
    },
    {
      "indent": 5,
      "text": "/**\n * This method generates a TOTP value for the given\n * set of parameters.\n *\n * @param key: the shared secret, HEX encoded\n * @param time: a value that reflects a time\n * @param returnDigits: number of digits to return\n * @param crypto: the crypto function to use\n *\n * @return: a numeric String in base 10 that includes\n *              {@link truncationDigits} digits\n */",
      "raw": true
    },
    {
      "indent": 5,
      "text": "public static String generateTOTP(String key,\n        String time,\n        String returnDigits,\n        String crypto){\n    int codeDigits = Integer.decode(returnDigits).intValue();\n    String result = null;",
      "raw": true
    },
    {
      "indent": 9,
      "text": "// Using the counter\n// First 8 bytes are for the movingFactor\n// Compliant with base RFC 4226 (HOTP)\nwhile (time.length() < 16 )\n    time = \"0\" + time;",
      "raw": true
    },
    {
      "indent": 9,
      "text": "// Get the HEX in a Byte[]\nbyte[] msg = hexStr2Bytes(time);\nbyte[] k = hexStr2Bytes(key);",
      "raw": true
    },
    {
      "indent": 9,
      "text": "byte[] hash = hmac_sha(crypto, k, msg);",
      "ja": "バイト[]ハッシュ= HMAC_SHA（暗号、K、MSG）。"
    },
    {
      "indent": 9,
      "text": "// put selected bytes into result int int offset = hash[hash.length - 1] & 0xf;",
      "ja": "//は、結果INT INTオフセット=ハッシュ[hash.length  -  1]に選択されたバイトを入れ＆0xFの。"
    },
    {
      "indent": 9,
      "text": "int binary = ((hash[offset] & 0x7f) << 24) | ((hash[offset + 1] & 0xff) << 16) | ((hash[offset + 2] & 0xff) << 8) | (hash[offset + 3] & 0xff);",
      "ja": "int型のバイナリ=（（ハッシュ[オフセット]＆から0x7f）<< 24）| （（ハッシュ0xffの＆[+ 1オフセット]）<< 16）| （（ハッシュ[+ 2オフセット]＆0xffの）<< 8）| （ハッシュ[+ 3のオフセット]＆0xffで）。"
    },
    {
      "indent": 9,
      "text": "int otp = binary % DIGITS_POWER[codeDigits];",
      "ja": "INT OTP =バイナリ％DIGITS_POWER [codeDigits]。"
    },
    {
      "indent": 5,
      "text": "    result = Integer.toString(otp);\n    while (result.length() < codeDigits) {\n        result = \"0\" + result;\n    }\n    return result;\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "public static void main(String[] args) {\n    // Seed for HMAC-SHA1 - 20 bytes\n    String seed = \"3132333435363738393031323334353637383930\";\n    // Seed for HMAC-SHA256 - 32 bytes\n    String seed32 = \"3132333435363738393031323334353637383930\" +\n    \"313233343536373839303132\";\n    // Seed for HMAC-SHA512 - 64 bytes\n    String seed64 = \"3132333435363738393031323334353637383930\" +\n    \"3132333435363738393031323334353637383930\" +\n    \"3132333435363738393031323334353637383930\" +\n    \"31323334\";\n    long T0 = 0;\n    long X = 30;\n    long testTime[] = {59L, 1111111109L, 1111111111L,\n            1234567890L, 2000000000L, 20000000000L};",
      "raw": true
    },
    {
      "indent": 9,
      "text": "String steps = \"0\";\nDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\ndf.setTimeZone(TimeZone.getTimeZone(\"UTC\"));",
      "raw": true
    },
    {
      "indent": 9,
      "text": "try {\n    System.out.println(\n            \"+---------------+-----------------------+\" +\n    \"------------------+--------+--------+\");\n    System.out.println(\n            \"|  Time(sec)    |   Time (UTC format)   \" +\n    \"| Value of T(Hex)  |  TOTP  | Mode   |\");\n    System.out.println(\n            \"+---------------+-----------------------+\" +\n    \"------------------+--------+--------+\");",
      "raw": true
    },
    {
      "indent": 13,
      "text": "for (int i=0; i<testTime.length; i++) {\n    long T = (testTime[i] - T0)/X;\n    steps = Long.toHexString(T).toUpperCase();\n    while (steps.length() < 16) steps = \"0\" + steps;\n    String fmtTime = String.format(\"%1$-11s\", testTime[i]);\n    String utcTime = df.format(new Date(testTime[i]*1000));\n    System.out.print(\"|  \" + fmtTime + \"  |  \" + utcTime +\n            \"  | \" + steps + \" |\");\n    System.out.println(generateTOTP(seed, steps, \"8\",\n    \"HmacSHA1\") + \"| SHA1   |\");\n    System.out.print(\"|  \" + fmtTime + \"  |  \" + utcTime +\n            \"  | \" + steps + \" |\");\n    System.out.println(generateTOTP(seed32, steps, \"8\",\n    \"HmacSHA256\") + \"| SHA256 |\");\n    System.out.print(\"|  \" + fmtTime + \"  |  \" + utcTime +\n            \"  | \" + steps + \" |\");\n    System.out.println(generateTOTP(seed64, steps, \"8\",\n    \"HmacSHA512\") + \"| SHA512 |\");",
      "raw": true
    },
    {
      "indent": 1,
      "text": "                System.out.println(\n                        \"+---------------+-----------------------+\" +\n                \"------------------+--------+--------+\");\n            }\n        }catch (final Exception e){\n            System.out.println(\"Error : \" + e);\n        }\n    }\n}",
      "raw": true
    },
    {
      "indent": 1,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 0,
      "text": "Appendix B. Test Vectors",
      "ja": "付録B.テストベクトル"
    },
    {
      "indent": 3,
      "text": "This section provides test values that can be used for the HOTP time-based variant algorithm interoperability test.",
      "ja": "このセクションでは、HOTP時間ベースの変異アルゴリズム相互運用性試験のために使用することができる試験値を提供します。"
    },
    {
      "indent": 3,
      "text": "The test token shared secret uses the ASCII string value \"12345678901234567890\". With Time Step X = 30, and the Unix epoch as the initial value to count time steps, where T0 = 0, the TOTP algorithm will display the following values for specified modes and timestamps.",
      "ja": "テストトークン共有秘密は、ASCII文字列値「12345678901234567890」を使用しています。 T0 = 0の時間ステップをカウントするための初期値として、時間ステップX = 30、およびUnixエポックでは、TOTPアルゴリズムは、指定されたモードとタイムスタンプのために、以下の値が表示されます。"
    },
    {
      "indent": 2,
      "text": "+-------------+--------------+------------------+----------+--------+\n|  Time (sec) |   UTC Time   | Value of T (hex) |   TOTP   |  Mode  |\n+-------------+--------------+------------------+----------+--------+\n|      59     |  1970-01-01  | 0000000000000001 | 94287082 |  SHA1  |\n|             |   00:00:59   |                  |          |        |\n|      59     |  1970-01-01  | 0000000000000001 | 46119246 | SHA256 |\n|             |   00:00:59   |                  |          |        |\n|      59     |  1970-01-01  | 0000000000000001 | 90693936 | SHA512 |\n|             |   00:00:59   |                  |          |        |\n|  1111111109 |  2005-03-18  | 00000000023523EC | 07081804 |  SHA1  |\n|             |   01:58:29   |                  |          |        |\n|  1111111109 |  2005-03-18  | 00000000023523EC | 68084774 | SHA256 |\n|             |   01:58:29   |                  |          |        |\n|  1111111109 |  2005-03-18  | 00000000023523EC | 25091201 | SHA512 |\n|             |   01:58:29   |                  |          |        |\n|  1111111111 |  2005-03-18  | 00000000023523ED | 14050471 |  SHA1  |\n|             |   01:58:31   |                  |          |        |\n|  1111111111 |  2005-03-18  | 00000000023523ED | 67062674 | SHA256 |\n|             |   01:58:31   |                  |          |        |\n|  1111111111 |  2005-03-18  | 00000000023523ED | 99943326 | SHA512 |\n|             |   01:58:31   |                  |          |        |\n|  1234567890 |  2009-02-13  | 000000000273EF07 | 89005924 |  SHA1  |\n|             |   23:31:30   |                  |          |        |\n|  1234567890 |  2009-02-13  | 000000000273EF07 | 91819424 | SHA256 |\n|             |   23:31:30   |                  |          |        |\n|  1234567890 |  2009-02-13  | 000000000273EF07 | 93441116 | SHA512 |\n|             |   23:31:30   |                  |          |        |\n|  2000000000 |  2033-05-18  | 0000000003F940AA | 69279037 |  SHA1  |\n|             |   03:33:20   |                  |          |        |\n|  2000000000 |  2033-05-18  | 0000000003F940AA | 90698825 | SHA256 |\n|             |   03:33:20   |                  |          |        |\n|  2000000000 |  2033-05-18  | 0000000003F940AA | 38618901 | SHA512 |\n|             |   03:33:20   |                  |          |        |\n| 20000000000 |  2603-10-11  | 0000000027BC86AA | 65353130 |  SHA1  |\n|             |   11:33:20   |                  |          |        |\n| 20000000000 |  2603-10-11  | 0000000027BC86AA | 77737706 | SHA256 |\n|             |   11:33:20   |                  |          |        |\n| 20000000000 |  2603-10-11  | 0000000027BC86AA | 47863826 | SHA512 |\n|             |   11:33:20   |                  |          |        |\n+-------------+--------------+------------------+----------+--------+",
      "raw": true
    },
    {
      "indent": 28,
      "text": "Table 1: TOTP Table",
      "ja": "表1：TOTP表"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "David M'Raihi Verisign, Inc. 685 E. Middlefield Road Mountain View, CA 94043 USA",
      "ja": "デビッドM'Raihiベリサイン社685 E.ミドルロード、マウンテンビュー、CA 94043 USA"
    },
    {
      "indent": 3,
      "text": "EMail: davidietf@gmail.com",
      "ja": "メールアドレス：davidietf@gmail.com"
    },
    {
      "indent": 3,
      "text": "Salah Machani Diversinet Corp. 2225 Sheppard Avenue East, Suite 1801 Toronto, Ontario M2J 5C2 Canada",
      "ja": "サラMachani Diversinet社2225シェパードアベニューイースト、スイート1801トロント、オンタリオM2J 5C2カナダ"
    },
    {
      "indent": 3,
      "text": "EMail: smachani@diversinet.com",
      "ja": "メールアドレス：smachani@diversinet.com"
    },
    {
      "indent": 3,
      "text": "Mingliang Pei Symantec 510 E. Middlefield Road Mountain View, CA 94043 USA",
      "ja": "Mingliangペイシマンテック510 E.ミドルロード、マウンテンビュー、CA 94043 USA"
    },
    {
      "indent": 3,
      "text": "EMail: Mingliang_Pei@symantec.com",
      "ja": "メールアドレス：Mingliang_Pei@symantec.com"
    },
    {
      "indent": 3,
      "text": "Johan Rydell Portwise, Inc. 275 Hawthorne Ave., Suite 119 Palo Alto, CA 94301 USA",
      "ja": "ヨハン・ライデルPortwise、Inc.の275ホーソーンアベニュー、スイート119パロアルト、CA 94301 USA"
    },
    {
      "indent": 3,
      "text": "EMail: johanietf@gmail.com",
      "ja": "メールアドレス：johanietf@gmail.com"
    }
  ]
}