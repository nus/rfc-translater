{
  "title": {
    "text": "RFC 6063 - Dynamic Symmetric Key Provisioning Protocol (DSKPP)",
    "ja": "RFC 6063 - ダイナミックな対称キープロビジョニングプロトコル（DSKPP）"
  },
  "number": 6063,
  "created_at": "2019-10-27 15:16:51.039935+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        A. Doherty\nRequest for Comments: 6063             RSA, The Security Division of EMC\nCategory: Standards Track                                         M. Pei\nISSN: 2070-1721                                           VeriSign, Inc.\n                                                              S. Machani\n                                                        Diversinet Corp.\n                                                              M. Nystrom\n                                                         Microsoft Corp.\n                                                           December 2010",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Dynamic Symmetric Key Provisioning Protocol (DSKPP)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Dynamic Symmetric Key Provisioning Protocol (DSKPP) is a client-server protocol for initialization (and configuration) of symmetric keys to locally and remotely accessible cryptographic modules. The protocol can be run with or without private key capabilities in the cryptographic modules and with or without an established public key infrastructure.",
      "ja": "ダイナミックな対称キープロビジョニングプロトコル（DSKPP）は、ローカルおよびリモートアクセスの暗号モジュールへの対称鍵の初期化（およびコンフィギュレーション）のためのクライアント・サーバ・プロトコルです。プロトコルは、の有無にかかわらず、暗号モジュール内およびプライベートキーの機能または確立し、公開鍵インフラストラクチャなしで実行することができます。"
    },
    {
      "indent": 3,
      "text": "Two variations of the protocol support multiple usage scenarios. With the four-pass variant, keys are mutually generated by the provisioning server and cryptographic module; provisioned keys are not transferred over-the-wire or over-the-air. The two-pass variant enables secure and efficient download and installation of pre-generated symmetric keys to a cryptographic module.",
      "ja": "プロトコルの2つの変形例は、複数の使用シナリオをサポートします。 4パス変異体と、キーが相互プロビジョニングサーバ及び暗号モジュールによって生成されます。プロビジョニングされたキーは、ワイヤ上または過剰空気転送されません。ツーパス変異体は、暗号モジュールへの安全かつ効率的なダウンロードと事前生成された対称鍵のインストールを可能にします。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6063.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6063で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2010 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................6\n   1.1. Key Words ..................................................6\n   1.2. Version Support ............................................6\n   1.3. Namespace Identifiers ......................................7\n        1.3.1. Defined Identifiers .................................7\n        1.3.2. Identifiers Defined in Related Specifications .......7\n        1.3.3. Referenced Identifiers ..............................8\n2. Terminology .....................................................8\n   2.1. Definitions ................................................8\n   2.2. Notation ..................................................10\n   2.3. Abbreviations .............................................11\n3. DSKPP Overview .................................................11\n   3.1. Protocol Entities .........................................12\n   3.2. Basic DSKPP Exchange ......................................12\n        3.2.1. User Authentication ................................12\n        3.2.2. Protocol Initiated by the DSKPP Client .............14\n        3.2.3. Protocol Triggered by the DSKPP Server .............16\n        3.2.4. Variants ...........................................17\n               3.2.4.1. Criteria for Using the Four-Pass Variant ..17\n               3.2.4.2. Criteria for Using the Two-Pass Variant ...18\n   3.3. Status Codes ..............................................18\n   3.4. Basic Constructs ..........................................20\n        3.4.1. User Authentication Data (AD) ......................20\n               3.4.1.1. Authentication Code Format ................20\n               3.4.1.2. User Authentication Data Calculation ......23\n        3.4.2. The DSKPP One-Way Pseudorandom Function,\n               DSKPP-PRF ..........................................24\n        3.4.3. The DSKPP Message Hash Algorithm ...................24\n4. Four-Pass Protocol Usage .......................................25\n   4.1. The Key Agreement Mechanism ...............................25\n        4.1.1. Data Flow ..........................................25\n        4.1.2. Computation ........................................27\n   4.2. Message Flow ..............................................28\n        4.2.1. KeyProvTrigger .....................................28\n        4.2.2. KeyProvClientHello .................................29\n        4.2.3. KeyProvServerHello .................................30\n        4.2.4. KeyProvClientNonce .................................32\n        4.2.5. KeyProvServerFinished ..............................34\n5. Two-Pass Protocol Usage ........................................35\n   5.1. Key Protection Methods ....................................36\n        5.1.1. Key Transport ......................................36\n        5.1.2. Key Wrap ...........................................37\n        5.1.3. Passphrase-Based Key Wrap ..........................37\n   5.2. Message Flow ..............................................38\n        5.2.1. KeyProvTrigger .....................................38\n        5.2.2. KeyProvClientHello .................................39",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        5.2.3. KeyProvServerFinished ..............................43\n6. Protocol Extensions ............................................44\n   6.1. The ClientInfoType Extension ..............................45\n   6.2. The ServerInfoType Extension ..............................45\n7. Protocol Bindings ..............................................45\n   7.1. General Requirements ......................................45\n   7.2. HTTP/1.1 Binding for DSKPP ................................46\n        7.2.1. Identification of DSKPP Messages ...................46\n        7.2.2. HTTP Headers .......................................46\n        7.2.3. HTTP Operations ....................................47\n        7.2.4. HTTP Status Codes ..................................47\n        7.2.5. HTTP Authentication ................................47\n        7.2.6. Initialization of DSKPP ............................47\n        7.2.7. Example Messages ...................................48\n8. DSKPP XML Schema ...............................................49\n   8.1. General Processing Requirements ...........................49\n   8.2. Schema ....................................................49\n9. Conformance Requirements .......................................58\n10. Security Considerations .......................................59\n   10.1. General ..................................................59\n   10.2. Active Attacks ...........................................60\n        10.2.1. Introduction ......................................60\n        10.2.2. Message Modifications .............................60\n        10.2.3. Message Deletion ..................................61\n        10.2.4. Message Insertion .................................62\n        10.2.5. Message Replay ....................................62\n        10.2.6. Message Reordering ................................62\n        10.2.7. Man in the Middle .................................63\n   10.3. Passive Attacks ..........................................63\n   10.4. Cryptographic Attacks ....................................63\n   10.5. Attacks on the Interaction between DSKPP and User\n         Authentication ...........................................64\n   10.6. Miscellaneous Considerations .............................65\n        10.6.1. Client Contributions to K_TOKEN Entropy ...........65\n        10.6.2. Key Confirmation ..................................65\n        10.6.3. Server Authentication .............................65\n        10.6.4. User Authentication ...............................66\n        10.6.5. Key Protection in Two-Pass DSKPP ..................66\n        10.6.6. Algorithm Agility .................................67\n11. Internationalization Considerations ...........................68\n12. IANA Considerations ...........................................68\n   12.1. URN Sub-Namespace Registration ...........................68\n   12.2. XML Schema Registration ..................................69\n   12.3. MIME Media Type Registration .............................69\n   12.4. Status Code Registration .................................70\n   12.5. DSKPP Version Registration ...............................70\n   12.6. PRF Algorithm ID Sub-Registry ............................70\n        12.6.1. DSKPP-PRF-AES .....................................71",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        12.6.2. DSKPP-PRF-SHA256 ..................................71\n   12.7. Key Container Registration ...............................72\n13. Intellectual Property Considerations ..........................73\n14. Contributors ..................................................73\n15. Acknowledgements ..............................................73\n16. References ....................................................74\n   16.1. Normative References .....................................74\n   16.2. Informative References ...................................76\nAppendix A.  Usage Scenarios ......................................78\n  A.1.  Single Key Request ........................................78\n  A.2.  Multiple Key Requests .....................................78\n  A.3.  User Authentication .......................................78\n  A.4.  Provisioning Time-Out Policy ............................78\n  A.5.  Key Renewal ...............................................79\n  A.6.  Pre-Loaded Key Replacement ..............................79\n  A.7.  Pre-Shared Manufacturing Key ............................79\n  A.8.  End-to-End Protection of Key Material ...................80\nAppendix B.  Examples .............................................80\n  B.1.  Trigger Message ...........................................80\n  B.2.  Four-Pass Protocol ......................................81\n    B.2.1.  <KeyProvClientHello> without a Preceding Trigger ......81\n    B.2.2.  <KeyProvClientHello> Assuming a Preceding Trigger .....82\n    B.2.3.  <KeyProvServerHello> Without a Preceding Trigger ......83\n    B.2.4.  <KeyProvServerHello> Assuming Key Renewal .............84\n    B.2.5.  <KeyProvClientNonce> Using Default Encryption .........85\n    B.2.6.  <KeyProvServerFinished> Using Default Encryption ......85\n  B.3.  Two-Pass Protocol .......................................86\n    B.3.1.  Example Using the Key Transport Method ................86\n    B.3.2.  Example Using the Key Wrap Method .....................90\n    B.3.3.  Example Using the Passphrase-Based Key Wrap Method ..94\nAppendix C.  Integration with PKCS #11 ............................98\n  C.1.  The Four-Pass Variant ...................................98\n  C.2.  The Two-Pass Variant ....................................98\nAppendix D.  Example of DSKPP-PRF Realizations .................101\n  D.1.  Introduction .............................................101\n  D.2.  DSKPP-PRF-AES ..........................................101\n    D.2.1.  Identification .......................................101\n    D.2.2.  Definition ...........................................101\n    D.2.3.  Example ..............................................102\n  D.3.  DSKPP-PRF-SHA256 .......................................103\n    D.3.1.  Identification .......................................103\n    D.3.2.  Definition ...........................................103\n    D.3.3.  Example ..............................................104",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Symmetric-key-based cryptographic systems (e.g., those providing authentication mechanisms such as one-time passwords and challenge-response) offer performance and operational advantages over public key schemes. Such use requires a mechanism for the provisioning of symmetric keys providing equivalent functionality to mechanisms such as the Certificate Management Protocol (CMP) [RFC4210] and Certificate Management over CMS (CMC) [RFC5272] in a Public Key Infrastructure.",
      "ja": "対称鍵ベースの暗号化システムの公開鍵方式を超える（例えば、ワンタイムパスワードとチャレンジレスポンスなどの認証メカニズムを提供するもの）を提供性能及び作用効果。このような使用は、このような公開鍵基盤でCMSを超える証明書管理プロトコル（CMP）[RFC4210]と証明書の管理（CMC）[RFC5272]などのメカニズムと同等の機能を提供する対称鍵のプロビジョニングのための仕組みが必要となります。"
    },
    {
      "indent": 3,
      "text": "Traditionally, cryptographic modules have been provisioned with keys during device manufacturing, and the keys have been imported to the cryptographic server using, e.g., a CD-ROM disc shipped with the devices. Some vendors also have proprietary provisioning protocols, which often have not been publicly documented (the Cryptographic Token Key Initialization Protocol (CT-KIP) is one exception [RFC4758]).",
      "ja": "伝統的には、暗号モジュールは、デバイス製造中に鍵がプロビジョニングされており、キーは、例えば、機器に同梱のCD-ROMディスクを使用して暗号化サーバにインポートされています。一部のベンダーは、また、多くの場合、一般に公開されていない独自のプロビジョニングプロトコルを持っている（暗号トークン鍵の初期化プロトコル（CT-KIP）は一つの例外[RFC4758]です）。"
    },
    {
      "indent": 3,
      "text": "This document describes the Dynamic Symmetric Key Provisioning Protocol (DSKPP), a client-server protocol for provisioning symmetric keys between a cryptographic module (corresponding to DSKPP Client) and a key provisioning server (corresponding to DSKPP Server).",
      "ja": "このドキュメントは、Dynamic対称キープロビジョニングプロトコル（DSKPP）、暗号モジュール（DSKPPクライアントに対応）および（DSKPPサーバーに対応する）キープロビジョニング・サーバーとの間の対称鍵をプロビジョニングするためのクライアントサーバプロトコルを記述します。"
    },
    {
      "indent": 3,
      "text": "DSKPP provides an open and interoperable mechanism for initializing and configuring symmetric keys to cryptographic modules that are accessible over the Internet. The description is based on the information contained in [RFC4758], and contains specific enhancements, such as user authentication and support for the [RFC6030] format for transmission of keying material.",
      "ja": "DSKPPは、インターネット経由でアクセス可能な暗号モジュールへの対称鍵を初期化して設定するためのオープンで相互運用可能なメカニズムを提供します。説明は、[RFC4758]に含まれる情報に基づいて、そのような鍵材料の送信のために[RFC6030]形式のユーザ認証及びサポートなどの特定の機能強化が含まれています。"
    },
    {
      "indent": 3,
      "text": "DSKPP has two principal protocol variants. The four-pass protocol variant permits a symmetric key to be established that includes randomness contributed by both the client and the server. The two-pass protocol requires only one round trip instead of two and permits a server specified key to be established.",
      "ja": "DSKPPは二つの主要なプロトコルのバリアントを持っています。 4パスプロトコルバリアントは、クライアントとサーバの両方が寄与するランダム性を含むことが確立される対称鍵を許可します。ツーパスプロトコルではなく、両者の唯一の1往復を必要として確立されるサーバー指定したキーを許可します。"
    },
    {
      "indent": 0,
      "text": "1.1. Key Words",
      "section_title": true,
      "ja": "1.1。キーワード"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Version Support",
      "section_title": true,
      "ja": "1.2。バージョンのサポート"
    },
    {
      "indent": 3,
      "text": "There is a provision made in the syntax for an explicit version number. Only version \"1.0\" is currently specified.",
      "ja": "明示的なバージョン番号の構文で作られた規定があります。唯一のバージョン「1.0」は、現在指定されています。"
    },
    {
      "indent": 3,
      "text": "The purpose for versioning the protocol is to provide a mechanism by which changes to required cryptographic algorithms (e.g., SHA-256) and attributes (e.g., key size) can be deployed without disrupting existing implementations; likewise, outdated implementations can be de-commissioned without disrupting operations involving newer protocol versions.",
      "ja": "プロトコルバージョンのための目的は、既存の実装を中断することなく展開することができる必要な暗号アルゴリズム（例えば、SHA-256）と属性（例えば、キーサイズ）に変化するメカニズムを提供することです。同様に、旧式の実装は脱委託することができる新しいプロトコルバージョンを伴う操作を中断することなく。"
    },
    {
      "indent": 3,
      "text": "The numbering scheme for DSKPP versions is \"<major>.<minor>\". The major and minor numbers MUST be treated as separate integers and each number MAY be incremented higher than a single digit. Thus, \"DSKPP 2.4\" would be a lower version than \"DSKPP 2.13\", which in turn would be lower than \"DSKPP 12.3\". Leading zeros (e.g., \"DSKPP 6.01\") MUST be ignored by recipients and MUST NOT be sent.",
      "ja": "DSKPPバージョンの番号付けスキームは、「<主要な>。<マイナー>」です。メジャー番号とマイナー番号は、別々の整数として扱わなければならないと、それぞれ番号が一桁以上高い増分することができます。このように、「DSKPP 2.4は、」順番に「DSKPP 12.3」よりも低くなると思われる、「DSKPP 2.13」より低いバージョンになります。先頭のゼロ（例えば、「DSKPP 6.01」）は、受信者によって無視されなければならないと送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "The major version number should be incremented only if the data formats or security algorithms have changed so dramatically that an older version implementation would not be able to interoperate with a newer version (e.g., removing support for a previously mandatory-to-implement algorithm now found to be insecure). The minor version number indicates new capabilities (e.g., introducing a new algorithm option) and MUST be ignored by an entity with a smaller minor version number but be used for informational purposes by the entity with the larger minor version number.",
      "ja": "メジャーバージョン番号は、データ形式やセキュリティアルゴリズムは、古いバージョンの実装は今見つけあらかじめ実装に必須のアルゴリズムのサポートを削除し、新しいバージョン（例えば、と相互運用することができないほど劇的に変化した場合にのみインクリメントされなければなりません）安全ではないことにします。マイナーバージョン番号は、新しい機能を示している（例えば、新しいアルゴリズムのオプションを導入）と小さなマイナーバージョン番号とエンティティによって無視されなければならないが、より大きなマイナーバージョン番号を持つエンティティによって情報提供の目的のために使用することができます。"
    },
    {
      "indent": 0,
      "text": "1.3. Namespace Identifiers",
      "section_title": true,
      "ja": "1.3。名前空間識別子"
    },
    {
      "indent": 3,
      "text": "This document uses Uniform Resource Identifiers (URIs) [RFC3986] to identify resources, algorithms, and semantics.",
      "ja": "この文書では、リソース、アルゴリズム、およびセマンティクスを識別するために、ユニフォームリソース識別子（URIを）[RFC3986]を使用しています。"
    },
    {
      "indent": 0,
      "text": "1.3.1. Defined Identifiers",
      "section_title": true,
      "ja": "1.3.1。定義の識別子"
    },
    {
      "indent": 3,
      "text": "The XML namespace [XMLNS] URI for Version 1.0 of DSKPP is:",
      "ja": "DSKPPのバージョン1.0のXML名前空間[XMLNS] URIは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "\"urn:ietf:params:xml:ns:keyprov:dskpp\"",
      "ja": "\"URN：IETF：のparams：XML：NS：keyprov：dskpp\""
    },
    {
      "indent": 3,
      "text": "References to qualified elements in the DSKPP schema defined herein use the prefix \"dskpp\", but any prefix is allowed.",
      "ja": "本明細書に定義されるDSKPPスキーマで修飾された要素への参照は、接頭辞「dskpp」を使用しますが、任意のプレフィックスが許可されます。"
    },
    {
      "indent": 0,
      "text": "1.3.2. Identifiers Defined in Related Specifications",
      "section_title": true,
      "ja": "1.3.2。関連する仕様で定義された識別子"
    },
    {
      "indent": 3,
      "text": "This document relies on qualified elements already defined in the Portable Symmetric Key Container [RFC6030] namespace, which is represented by the prefix \"pskc\" and declared as:",
      "ja": "この文書は、すでに接頭辞「pskc」に代表されるとして宣言されているポータブル対称キーコンテナ[RFC6030]の名前空間で定義された資格要素に依存しています："
    },
    {
      "indent": 3,
      "text": "xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"",
      "ja": "xmlns：pskc = \"壷：IETF：のparams：XML：NS：keyprov：pskc\""
    },
    {
      "indent": 0,
      "text": "1.3.3. Referenced Identifiers",
      "section_title": true,
      "ja": "1.3.3。参照された識別子"
    },
    {
      "indent": 3,
      "text": "Finally, the DSKPP syntax presented in this document relies on algorithm identifiers defined in the XML Signature [XMLDSIG] namespace:",
      "ja": "最後に、この文書のDSKPP構文は、XML署名[XMLDSIG]名前空間で定義されたアルゴリズム識別子に依存しています："
    },
    {
      "indent": 3,
      "text": "xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"",
      "ja": "xmlns：DS = \"http://www.w3.org/2000/09/xmldsig#\""
    },
    {
      "indent": 3,
      "text": "References to algorithm identifiers in the XML Signature namespace are represented by the prefix \"ds\".",
      "ja": "XML署名名前空間のアルゴリズム識別子への参照は、接頭辞「DS」で表されます。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 0,
      "text": "2.1. Definitions",
      "section_title": true,
      "ja": "2.1。定義"
    },
    {
      "indent": 3,
      "text": "Terms are defined below as they are used in this document. The same terms may be defined differently in other documents.",
      "ja": "彼らはこの文書で使用されるような用語を以下に定義されています。同じ用語は、他のドキュメントで異なって定義することができます。"
    },
    {
      "indent": 3,
      "text": "Authentication Code (AC): User Authentication Code comprised of a string of hexadecimal characters known to the device and the server and containing at a minimum a client identifier and a password. This ClientID/password combination is used only once and may have a time limit, and then discarded.",
      "ja": "認証コード（AC）：ユーザ認証コードデバイスとサーバと最小のクライアント識別子を含むパスワードに知られている進数の文字列で構成される。このクライアントID /パスワードの組み合わせは一度だけ使用され、制限時間を有していてもよく、その後、廃棄されました。"
    },
    {
      "indent": 3,
      "text": "Authentication Data (AD): User Authentication Data that is derived from the Authentication Code (AC)",
      "ja": "認証データ（AD）：認証コード（AC）から誘導されたユーザ認証データ"
    },
    {
      "indent": 3,
      "text": "Client ID: An identifier that the DSKPP Server uses to locate the real username or account identifier on the server. It can be a short random identifier that is unrelated to any real usernames.",
      "ja": "クライアントID：DSKPP Serverは、サーバー上の実際のユーザ名またはアカウント識別子を見つけるために使用する識別子。これは、任意の実際のユーザ名とは関係ありません短いランダム識別子であることができます。"
    },
    {
      "indent": 3,
      "text": "Cryptographic Module: A component of an application, which enables symmetric key cryptographic functionality",
      "ja": "暗号モジュール：アプリケーションのコンポーネント、対称鍵暗号化機能を有効に"
    },
    {
      "indent": 3,
      "text": "Device: A physical piece of hardware, or a software framework, that hosts symmetric key cryptographic modules",
      "ja": "装置：ハードウェアの物理的部分、またはソフトウェアフレームワーク、対称鍵暗号モジュールをホスト"
    },
    {
      "indent": 3,
      "text": "Device ID (DeviceID): A unique identifier for the device that houses the cryptographic module, e.g., a mobile phone",
      "ja": "デバイスID（デバイスID）：暗号モジュールを収容するデバイスの一意の識別子、例えば、携帯電話"
    },
    {
      "indent": 3,
      "text": "DSKPP Client: Manages communication between the symmetric key cryptographic module and the DSKPP Server",
      "ja": "DSKPPクライアント：対称鍵暗号モジュールとDSKPP・サーバ間の通信を管理します"
    },
    {
      "indent": 3,
      "text": "DSKPP Server: The symmetric key provisioning server that participates in the DSKPP run",
      "ja": "DSKPPサーバー：DSKPPランに参加して対称鍵プロビジョニング・サーバー"
    },
    {
      "indent": 3,
      "text": "DSKPP Server ID (ServerID): The unique identifier of a DSKPP Server",
      "ja": "DSKPPサーバID（サーバID）：DSKPPサーバーの一意の識別子"
    },
    {
      "indent": 3,
      "text": "Key Agreement: A key establishment protocol whereby two or more parties can agree on a key in such a way that both influence the outcome",
      "ja": "キー契約：2人の以上の当事者の両方が結果に影響を与えるような方法でキーに同意することができる鍵確立プロトコル"
    },
    {
      "indent": 3,
      "text": "Key Confirmation: The assurance of the rightful participants in a key-establishment protocol that the intended recipient of the shared key actually possesses the shared key",
      "ja": "鍵確認：共有鍵の意図された受信者が実際に共有鍵を所有するキー確立プロトコルにおける正当な参加者の保証"
    },
    {
      "indent": 3,
      "text": "Key Issuer: An organization that issues symmetric keys to end-users",
      "ja": "キー発行者：エンドユーザーに対称鍵を発行する組織"
    },
    {
      "indent": 3,
      "text": "Key Package (KP): An object that encapsulates a symmetric key and its configuration data",
      "ja": "キーパッケージ（KP）：対称キーとその構成データをカプセル化するオブジェクト"
    },
    {
      "indent": 3,
      "text": "Key ID (KeyID): A unique identifier for the symmetric key",
      "ja": "キーID（鍵ID）：対称キーの一意の識別子"
    },
    {
      "indent": 3,
      "text": "Key Protection Method (KPM): The key transport method used during two-pass DSKPP",
      "ja": "キー保護方法（KPM）：ツーパスDSKPP中に使用されるキー転送方法"
    },
    {
      "indent": 3,
      "text": "Key Protection Method List (KPML): The list of key protection methods supported by a cryptographic module",
      "ja": "鍵の保護方法一覧（KPML）：暗号モジュールでサポートされているキーの保護方法のリスト"
    },
    {
      "indent": 3,
      "text": "Key Provisioning Server: A lifecycle management system that provides a key issuer with the ability to provision keys to cryptographic modules hosted on end-users' devices",
      "ja": "キープロビジョニングサーバー：エンドユーザーのデバイス上にホストされている暗号モジュールに提供キーに機能してキー発行者を提供し、ライフサイクル管理システム"
    },
    {
      "indent": 3,
      "text": "Key Transport: A key establishment procedure whereby the DSKPP Server selects and encrypts the keying material and then sends the material to the DSKPP Client [NIST-SP800-57]",
      "ja": "主な交通機関：DSKPP Serverが選択され、暗号化の鍵材料を、次にDSKPPクライアントに材料を送ることにより、キー確立手順[NIST-SP800-57]"
    },
    {
      "indent": 3,
      "text": "Key Transport Key: The private key that resides on the cryptographic module. This key is paired with the DSKPP Client's public key, which the DSKPP Server uses to encrypt keying material during key transport [NIST-SP800-57]",
      "ja": "キートランスポートキー：暗号モジュールに常駐する秘密鍵。このキーはDSKPP Serverは、キー輸送中に鍵材料を暗号化するために使用していますDSKPPクライアントの公開鍵と対になっている[NIST-SP800-57]"
    },
    {
      "indent": 3,
      "text": "Key Type: The type of symmetric key cryptographic methods for which the key will be used (e.g., Open AUTHentication HMAC-Based One-Time Password (OATH HOTP) or RSA SecurID authentication, AES encryption, etc.)",
      "ja": "キータイプ：鍵が使用されるための対称鍵暗号方式の種類（例えば、オープン認証HMACをベースのワンタイムパスワード（宣誓HOTP）またはRSA SecurID認証、AES暗号化、等）"
    },
    {
      "indent": 3,
      "text": "Key Wrapping: A method of encrypting keys for key transport [NIST-SP800-57]",
      "ja": "鍵ラッピング：キー輸送のための鍵を暗号化する方法[NIST-SP800-57]"
    },
    {
      "indent": 3,
      "text": "Key Wrapping Key: A symmetric key encrypting key used for key wrapping [NIST-SP800-57]",
      "ja": "キーラッピングキー：キーラッピングのために使用される対称鍵暗号化キー[NIST-SP800-57]"
    },
    {
      "indent": 3,
      "text": "Keying Material: The data necessary (e.g., keys and key configuration data) necessary to establish and maintain cryptographic keying relationships [NIST-SP800-57]",
      "ja": "鍵材料：必要なデータ（例えば、キー及びキー設定データ）を暗号化キーイング関係を確立し、維持するために必要[NIST-SP800-57]"
    },
    {
      "indent": 3,
      "text": "Manufacturer's Key: A unique master key pre-issued to a hardware device, e.g., a smart card, during the manufacturing process. If present, this key may be used by a cryptographic module to derive secret keys",
      "ja": "メーカーのキー：ユニークなマスターキーハードウェアデバイスに予め発行され、例えば、スマートカード、製造工程中。存在する場合、このキーは、秘密鍵を導出するために暗号モジュールによって使用することができます"
    },
    {
      "indent": 3,
      "text": "Protocol Run: Complete execution of the DSKPP that involves one exchange (two-pass) or two exchanges (four-pass)",
      "ja": "プロトコル実行：DSKPPの完全な実行を伴う1つの交換（2パス）または2つの交換（4パス）"
    },
    {
      "indent": 3,
      "text": "Security Attribute List (SAL): A payload that contains the DSKPP version, DSKPP variant (four- or two-pass), key package formats, key types, and cryptographic algorithms that the cryptographic module is capable of supporting",
      "ja": "セキュリティ属性リスト（SAL）：暗号モジュールがサポートすることができるDSKPPバージョン、DSKPP変異体（四又はツーパス）、キーパッケージフォーマット、キータイプ、および暗号化アルゴリズムが含まペイロード"
    },
    {
      "indent": 0,
      "text": "2.2. Notation",
      "section_title": true,
      "ja": "2.2。表記法"
    },
    {
      "indent": 3,
      "text": "|| String concatenation [x] Optional element x A ^ B Exclusive-OR operation on strings A and B (where A and B are of equal length) <XMLElement> A typographical convention used in the body of the text DSKPP-PRF(k,s,dsLen) A keyed pseudorandom function E(k,m) Encryption of m with the key k K Key used to encrypt R_C (either K_SERVER or K_SHARED), or in MAC or DSKPP_PRF computations K_AC Secret key that is derived from the Authentication Code and used for user authentication purposes K_MAC Secret key derived during a DSKPP exchange for use with key confirmation K_MAC' A second secret key used for server authentication K_PROV A provisioning master key from which two keys are derived: K_TOKEN and K_MAC K_SERVER Public key of the DSKPP Server; used for encrypting R_C in the four-pass protocol variant",
      "ja": "||文字列（AとBは、等しい長さ）AとB <のXMLElement>テキストDSKPP-PRF（K、Sの本体で使用される表記規則上の文字列の連結[x]はオプションの要素X A ^ B排他的OR演算、dsLen）Kキーは、認証コードに由来するR_C（K_SERVER又はK_SHAREDいずれか）、またはMACまたはDSKPP_PRF計算におけるK_AC秘密鍵を暗号化するために使用される鍵KとMの鍵付き擬似ランダム関数E（k、m）の暗号化及びDSKPPサーバーのK_TOKENとK_MAC K_SERVER公開キー：キー確認K_MACで使用するためのDSKPP交換中に派生したユーザ認証目的K_MAC秘密キー」の二つの鍵が誘導されるマスターキーをプロビジョニングサーバ認証K_PROV Aのために使用される第二の秘密鍵を使用; 4パスプロトコルの変形でR_Cを暗号化するために使用"
    },
    {
      "indent": 3,
      "text": "K_SHARED Secret key that is pre-shared between the DSKPP Client and the DSKPP Server; used for encrypting R_C in the four-pass protocol variant K_TOKEN Secret key that is established in a cryptographic module using DSKPP R Pseudorandom value chosen by the DSKPP Client and used for MAC computations R_C Pseudorandom value chosen by the DSKPP Client and used as input to the generation of K_TOKEN R_S Pseudorandom value chosen by the DSKPP Server and used as input to the generation of K_TOKEN URL_S DSKPP Server address, as a URL",
      "ja": "DSKPPクライアントとDSKPPサーバーの間で事前共有されK_SHARED秘密鍵。 DSKPPクライアントによって選択され、MACに使用DSKPP R擬似ランダム値を用いて、暗号モジュールに確立される4パスプロトコルバリアントK_TOKEN秘密キーにR_Cを暗号化するために使用するR_C擬似ランダム値がDSKPPクライアントによって選択されたとへの入力として使用される計算しますURLとして、DSKPPサーバによって選択されたとK_TOKEN URL_S DSKPPサーバアドレスの生成への入力として使用K_TOKEN R_S擬似ランダム値の生成"
    },
    {
      "indent": 0,
      "text": "2.3. Abbreviations",
      "section_title": true,
      "ja": "2.3。略語"
    },
    {
      "indent": 3,
      "text": "AC Authentication Code AD Authentication Data DSKPP Dynamic Symmetric Key Provisioning Protocol HTTP Hypertext Transfer Protocol KP Key Package KPM Key Protection Method KPML Key Protection Method List MAC Message Authentication Code PC Personal Computer PDU Protocol Data Unit PKCS Public Key Cryptography Standards PRF Pseudorandom Function PSKC Portable Symmetric Key Container SAL Security Attribute List (see Section 2.1) TLS Transport Layer Security URL Uniform Resource Locator USB Universal Serial Bus XML eXtensible Markup Language",
      "ja": "AC認証コードAD認証データDSKPPダイナミック対称鍵プロビジョニングプロトコルHTTPハイパーテキスト転送プロトコルKPキーパッケージKPMキー保護方法KPML鍵の保護方式リストMACメッセージ認証コードPCパーソナルコンピュータPDUプロトコルデータユニットPKCS公開鍵暗号規格PRF擬似ランダム関数PSKCポータブル対称キーコンテナSALセキュリティ一覧（2.1節を参照）TLSトランスポート層セキュリティのURLユニフォームリソースロケータのUSBユニバーサルシリアルバスXML拡張マークアップ言語の属性"
    },
    {
      "indent": 0,
      "text": "3. DSKPP Overview",
      "section_title": true,
      "ja": "3. DSKPP概要"
    },
    {
      "indent": 3,
      "text": "The following sub-sections provide a high-level view of protocol internals and how they interact with external provisioning applications. Usage scenarios are provided in Appendix A.",
      "ja": "以下のサブセクションでは、プロトコルの内部の高レベルのビューを提供し、それらが外部のプロビジョニング・アプリケーションと対話する方法。使用シナリオは、付録Aに提供されています"
    },
    {
      "indent": 0,
      "text": "3.1. Protocol Entities",
      "section_title": true,
      "ja": "3.1。プロトコルエンティティ"
    },
    {
      "indent": 3,
      "text": "A DSKPP provisioning transaction has three entities:",
      "ja": "DSKPPプロビジョニングトランザクションは、3つのエンティティがあります。"
    },
    {
      "indent": 3,
      "text": "Server: The DSKPP provisioning server.",
      "ja": "サーバー：DSKPPプロビジョニングサーバー。"
    },
    {
      "indent": 3,
      "text": "Cryptographic Module: The cryptographic module to which the symmetric keys are to be provisioned, e.g., an authentication token.",
      "ja": "暗号モジュール：対称鍵は、例えば、プロビジョニングする認証トークンであると暗号モジュール。"
    },
    {
      "indent": 3,
      "text": "Client: The DSKPP Client that manages communication between the cryptographic module and the key provisioning server.",
      "ja": "クライアント：暗号モジュールとキープロビジョニングサーバー間の通信を管理DSKPPクライアント。"
    },
    {
      "indent": 3,
      "text": "The principal syntax is XML [XML] and it is layered on a transport mechanism such as HTTP [RFC2616] and HTTP Over TLS [RFC2818]. While it is highly desirable for the entire communication between the DSKPP Client and server to be protected by means of a transport providing confidentiality and integrity protection such as HTTP over Transport Layer Security (TLS), such protection is not sufficient to protect the exchange of the symmetric key data between the server and the cryptographic module and DSKPP is designed to permit implementations that satisfy this requirement.",
      "ja": "主構文は、XML [XML]であり、これは、そのようなHTTP [RFC2616]とHTTPオーバーTLS [RFC2818]として搬送機構上に積層されています。それはトランスポート層セキュリティ（TLS）を介して、HTTPなどの機密性と完全性保護を提供する輸送手段によって保護されるべきDSKPPクライアントとサーバ間の通信全体のために非常に望ましいことであるが、そのような保護は、交換を保護するのに十分ではありませんサーバと暗号モジュールとDSKPPの間で対称鍵データは、この要件を満たす実装を可能にするように設計されています。"
    },
    {
      "indent": 3,
      "text": "The server only communicates to the client. As far as the server is concerned, the client and cryptographic module may be considered to be a single entity.",
      "ja": "サーバーは、クライアントと通信します。限り、サーバーに関しては、クライアントと暗号モジュールは、単一のエンティティと見なすことができます。"
    },
    {
      "indent": 3,
      "text": "From a client-side security perspective, however, the client and the cryptographic module are separate logical entities and may in some implementations be separate physical entities as well.",
      "ja": "クライアント側のセキュリティの観点から、しかし、クライアントと暗号モジュールは、別個の論理エンティティであり、いくつかの実装においても、別個の物理エンティティであってもよいです。"
    },
    {
      "indent": 3,
      "text": "It is assumed that a device will host an application layered above the cryptographic module, and this application will manage communication between the DSKPP Client and cryptographic module. The manner in which the communicating application will transfer DSKPP elements to and from the cryptographic module is transparent to the DSKPP Server. One method for this transfer is described in [CT-KIP-P11].",
      "ja": "デバイスは、暗号モジュールの上に積層アプリケーションをホストすることが想定され、この出願はDSKPPクライアントと暗号モジュールの間の通信を管理します。通信アプリケーションは、暗号モジュールへとからDSKPP要素を転送するする方法はDSKPPサーバに対して透過的です。この転送のための一つの方法は、[CT-KIP-P11]に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.2. Basic DSKPP Exchange",
      "section_title": true,
      "ja": "3.2。基本DSKPP交換"
    },
    {
      "indent": 0,
      "text": "3.2.1. User Authentication",
      "section_title": true,
      "ja": "3.2.1。ユーザ認証"
    },
    {
      "indent": 3,
      "text": "In a DSKPP message flow, the user has obtained a new hardware or software device embedded with a cryptographic module. The goal of DSKPP is to provision the same symmetric key and related information to the cryptographic module and the key management server, and associate the key with the correct username (or other account identifier) on the server. To do this, the DSKPP Server MUST authenticate the user to be sure he is authorized for the new key.",
      "ja": "DSKPPメッセージフローでは、ユーザは、暗号モジュールが埋め込まれた新しいハードウェアまたはソフトウェアデバイスを得ました。 DSKPPの目標は、提供に暗号モジュールと鍵管理サーバに同じ対称鍵および関連情報であり、サーバ上の正しいユーザ名（または他のアカウント識別子）を持つキーを関連付けます。これを行うには、DSKPP Serverは、彼が新しいキーのために許可されていることを確認するため、ユーザーを認証する必要があります。"
    },
    {
      "indent": 3,
      "text": "User authentication occurs within the protocol itself *after* the DSKPP Client initiates the first message. In this case, the DSKPP Client MUST have access to the DSKPP Server URL.",
      "ja": "DSKPPクライアントが最初のメッセージを開始*後にユーザー認証は*プロトコル自体の中で発生します。この場合、DSKPPクライアントがDSKPPサーバーのURLにアクセスできる必要があります。"
    },
    {
      "indent": 3,
      "text": "Alternatively, a DSKPP web service or other form of web application can authenticate a user *before* the first message is exchanged. In this case, the DSKPP Server MUST trigger the DSKPP Client to initiate the first message in the protocol transaction.",
      "ja": "また、DSKPP WebサービスやWebアプリケーションの他の形式は、*最初のメッセージが交換される前に、*ユーザを認証することができます。この場合、DSKPPサーバーは、プロトコルトランザクションの最初のメッセージを開始するDSKPPクライアントをトリガしなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Protocol Initiated by the DSKPP Client",
      "section_title": true,
      "ja": "3.2.2。 DSKPPのクライアントによって開始プロトコル"
    },
    {
      "indent": 3,
      "text": "In the following example, the DSKPP Client first initiates DSKPP, and then the user is authenticated using a Client ID and Authentication Code.",
      "ja": "次の例では、DSKPPクライアントは最初DSKPPを開始し、その後、ユーザは、クライアントIDと認証コードを使用して認証されます。"
    },
    {
      "indent": 3,
      "text": "Crypto       DSKPP                          DSKPP    Key Provisioning\nModule       Client                         Server        Server\n |             |                              |             |\n |             |                              |     +---------------+\n |             |                              |     |Server creates |\n |             |                              |     |and stores     |\n |             |                              |     |Client ID and  |\n |             |                              |     |Auth. Code and |\n |             |                              |     |delivers them  |\n |             |                              |     |to user out-of-|\n |             |                              |     |band.          |\n |             |                              |     +---------------+\n |             |                              |             |\n |  +----------------------+                  |             |\n |  |User enters Client ID,|                  |             |\n |  |Auth. Code, and URL   |                  |             |\n |  +----------------------+                  |             |\n |             |                              |             |\n |             |<-- 1. TLS handshake with --->|             |\n |             |        server auth.          |             |\n |             |                              |             |\n |             | 2. <KeyProvClientHello> ---->|     User -->|\n |             |                              |     Auth.   |\n |             |<-- [3. <KeyProvServerHello>] |             |\n |             |                              |             |\n |             | [4. <KeyProvClientNonce>] -->|             |\n |             |                              |             |\n |             |<- 5. <KeyProvServerFinished> |             |\n |             |                              |             |\n |             |                              |             |\n |<-- Key      |                              |      Key -->|\n |    Package  |                              |   Package   |",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 1: Basic DSKPP Exchange",
      "ja": "図1：基本的なDSKPP交換"
    },
    {
      "indent": 3,
      "text": "Before DSKPP begins: o The Authentication Code is generated by the DSKPP Server, and delivered to the user via an out-of-band trustworthy channel (e.g., a paper slip delivered by IT department staff). o The user typically enters the Client ID and Authentication Code manually, possibly on a device with only a numeric keypad. Thus, they are often short numeric values (for example, 8 decimal digits). However, the DSKPP Server is free to generate them in any way it wishes. o The DSKPP Client needs the URL [RFC3986] of the DSKPP Server (which is not user specific or secret, and may be pre-configured somehow), and a set of trust anchors for verifying the server certificate. o There must be an account for the user that has an identifier and long-term username (or other account identifier) to which the token will be associated. The DSKPP Server will use the Client ID to find the corresponding Authentication Code for user authentication.",
      "ja": "DSKPPが始まる前に：認証コードoをDSKPP Serverによって生成され、アウトオブバンド信頼できるチャネルを介してユーザーに配信（例えば、IT部門のスタッフによって提供さ紙片）。 Oユーザーは、典型的には、おそらく唯一の数字キーパッドを有する装置に、手動でクライアントのIDと認証コードを入力します。従って、それらはしばしば短い数値（例えば、8桁）です。しかし、DSKPP Serverは、それが希望するどのような方法でそれらを生成して自由です。 O DSKPPクライアントは、（特定や秘密のユーザーではなく、何らかの形で事前に構成されていてもよい）DSKPPサーバーのURL [RFC3986]、およびサーバ証明書を検証するためのトラストアンカーのセットを必要とします。 Oトークンが関連付けられる先の識別子と長期のユーザー名（または他のアカウント識別子）を持つユーザーのアカウントが存在しなければなりません。 DSKPPサーバーは、ユーザー認証のための対応する認証コードを見つけるために、クライアントのIDを使用します。"
    },
    {
      "indent": 3,
      "text": "In Step 1, the client establishes a TLS connection, authenticates the server (that is, validates the certificate, and compares the host name in the URL with the certificate) as described in Section 3.1 of [RFC2818].",
      "ja": "ステップ1において、クライアントは、TLS接続を確立し、サーバを認証する（つまり、証明書を検証し、証明書を使用してURLのホスト名を比較）[RFC2818]のセクション3.1に記載されているように。"
    },
    {
      "indent": 3,
      "text": "Next, the DSKPP Client and DSKPP Server exchange DSKPP messages (which are sent over HTTPS). In these messages: o The client and server negotiate which cryptographic algorithms they want to use, which algorithms are supported for protecting DSKPP messages, and other DSKPP details. o The client sends the Client ID to the server, and proves that it knows the corresponding Authentication Code. o The client and server agree on a secret key (token key or K_TOKEN); depending on the negotiated protocol variant, this is either a fresh key derived during the DSKPP run (called \"four-pass variant\", since it involves four DSKPP messages) or is generated by (or pre-exists on) the server and transported to the client (called \"two-pass variant\" in the rest of this document, since it involves two DSKPP messages). o The server sends a \"key package\" to the client. The package only includes the key itself in the case of the \"two-pass variant\"; with either variant, the key package contains attributes that influence how the provisioned key will be later used by the cryptographic module and cryptographic server. The exact contents depend on the cryptographic algorithm (e.g., for a one-time password algorithm that supports variable-length OTP values, the length of the OTP value would be one attribute in the key package).",
      "ja": "次に、（HTTPS経由で送信される）DSKPPクライアントとDSKPPサーバー為替DSKPPメッセージ。これらのメッセージでは：クライアントとサーバーoを、彼らはDSKPPメッセージ、およびその他のDSKPPの詳細情報を保護するためにサポートされているアルゴリズム、使用する暗号アルゴリズムいる交渉。 Oクライアントは、サーバーへのクライアントIDを送信し、それが対応する認証コードを知っていることを証明します。 Oクライアントとサーバは、秘密鍵（トークンキーまたはK_TOKEN）に合意します。ネゴシエートされたプロトコルの変形に応じて、これはDSKPP実行中に誘導された新鮮な鍵のいずれかである（これは、4つのDSKPPメッセージを含むので、「4パス変異体」と呼ばれる）又は（またはオンプレ存在）サーバによって生成さに搬送されますクライアント（それが2つのDSKPPメッセージを伴うため、このドキュメントの残りの部分では「2パス変異体」と呼ばれます）。 Oサーバーは、クライアントへの「キーパッケージ」を送信します。パッケージは、「ツーパス変異体」の場合には、キー自体を含みます。バリアントのいずれかで、キーパッケージは、プロビジョニングされたキーが、後に暗号モジュールと暗号サーバによって使用される方法に影響する属性が含まれています。正確な内容は、暗号化アルゴリズム（例えば、可変長OTP値をサポートするワンタイムパスワードアルゴリズムに、OTP値の長さは、キーパッケージ内の1つの属性であろう）に依存します。"
    },
    {
      "indent": 3,
      "text": "After the protocol run has been successfully completed, the cryptographic modules stores the contents of the key package. Likewise, the DSKPP provisioning server stores the contents of the key package with the cryptographic server, and associates these with the correct username. The user can now use the their device to perform symmetric-key based operations.",
      "ja": "プロトコルの実行が正常に完了した後は、暗号モジュールは、キーパッケージの内容を保存します。同様に、DSKPPプロビジョニングサーバーは、暗号サーバとキーパッケージの内容を格納し、正しいユーザ名でこれらを関連付けます。ユーザーは対称鍵ベースの操作を実行するために自分のデバイスを使用することができます。"
    },
    {
      "indent": 3,
      "text": "The exact division of work between the cryptographic module and the DSKPP Client -- and key Provisioning server and DSKPP Server -- are not specified in this document. The figure above shows one possible case, but this is intended for illustrative purposes only.",
      "ja": "キーのプロビジョニングサーバとDSKPPサーバ -   - 暗号モジュールとDSKPPクライアント間の作業の正確な分割は、この文書で指定されていません。上図は、一つの可能​​な場合を示しているが、これは例示の目的のみのために意図されています。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Protocol Triggered by the DSKPP Server",
      "section_title": true,
      "ja": "3.2.3。 DSKPP Serverによってトリガプロトコル"
    },
    {
      "indent": 3,
      "text": "In the first message flow (previous section), the Client ID and Authentication Code were delivered to the client by some out-of-band means (such as paper sent to the user).",
      "ja": "最初のメッセージ・フロー（前のセクション）に、クライアントIDと認証コード（ユーザに送信される紙などの）いくつかのアウトオブバンドによってクライアントに配信されました。"
    },
    {
      "indent": 3,
      "text": "Web           DSKPP                          DSKPP            Web\nBrowser       Client                         Server          Server\n  |              |                              |               |\n  |<-------- HTTPS browsing + some kind of user auth. --------->|\n  |              |                              |               |\n  | some HTTP request ----------------------------------------->|\n  |              |                              |\n  |              |                              |<------------->|\n  |              |                              |               |\n  |<----------------------- HTTP response with <KeyProvTrigger> |\n  |              |                              |               |\n  | Trigger ---->|                              |               |\n  |              |                              |               |\n  |              |<-- 1. TLS handshake with --->|               |\n  |              |        server auth.          |               |\n  |              |                              |               |\n  |              |     ... continues...         |               |",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 2: DSKPP Exchange with Web-Based Authentication",
      "ja": "図2：Webベース認証でDSKPP交換"
    },
    {
      "indent": 3,
      "text": "In the second message flow, the user first authenticates to a web server (for example, an IT department's \"self-service\" Intranet page), using an ordinary web browser and some existing credentials.",
      "ja": "第2のメッセージフローでは、ユーザはまず、通常のWebブラウザといくつかの既存の資格情報を使用して、ウェブサーバ（例えば、IT部門の「セルフサービス」イントラネットページ）に認証を行います。"
    },
    {
      "indent": 3,
      "text": "The user then requests (by clicking a link or submitting a form) provisioning of a new key to the cryptographic module. The web server will reply with a <KeyProvTrigger> message that contains the Client ID, Authentication Code, and URL of the DSKPP Server. This information is also needed by the DSKPP Server; how the web server and DSKPP Server interact is beyond the scope of this document.",
      "ja": "その後、ユーザは、暗号モジュールへの新しい鍵のプロビジョニング（リンクをクリックするか、フォームを提出することによって）を要求します。 Webサーバは、<KeyProvTrigger>クライアントIDを含むメッセージ、認証コード、およびDSKPPサーバーのURLを返信いたします。この情報は、DSKPP Serverが必要とされます。どのようにWebサーバとDSKPPサーバーが相互作用することは、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "The <KeyProvTrigger> message is sent in an HTTP response, and it is marked with MIME type \"application/dskpp+xml\". It is assumed the web browser has been configured to recognize this MIME type; the browser will start the DSKPP Client and provide it with the <KeyProvTrigger> message.",
      "ja": "<KeyProvTrigger>メッセージがHTTP応答で送信され、それがMIMEタイプ「アプリケーション/ dskpp + xmlの」とマークされています。これは、このMIMEタイプを認識するように設定されているWebブラウザを想定しています。ブラウザはDSKPP Clientを起動し、<KeyProvTrigger>メッセージでそれを提供します。"
    },
    {
      "indent": 3,
      "text": "The DSKPP Client then contacts the DSKPP Server and uses the Client ID and Authentication Code (from the <KeyProvTrigger> message) the same way as in the first message flow.",
      "ja": "DSKPPクライアント次いで、コンタクトDSKPPサーバと最初のメッセージ・フローと同様に、クライアントIDと認証コード（<KeyProvTrigger>メッセージから）を使用します。"
    },
    {
      "indent": 0,
      "text": "3.2.4. Variants",
      "section_title": true,
      "ja": "3.2.4。バリアント"
    },
    {
      "indent": 3,
      "text": "As noted in the previous section, once the protocol has started, the client and server MAY engage in either a two-pass or four-pass message exchange. The four-pass and two-pass protocols are appropriate in different deployment scenarios. The biggest differentiator between the two is that the two-pass protocol supports transport of an existing key to a cryptographic module, while the four-pass involves key generation on-the-fly via key agreement. In either case, both protocol variants support algorithm agility through the negotiation of encryption mechanisms and key types at the beginning of each protocol run.",
      "ja": "前節で述べたようにプロトコルが起動した後、クライアントとサーバは、2パスまたは4パスメッセージ交換のいずれかに従事することができます。 4パスと2パスプロトコルが異なる展開シナリオに応じた適切な。両者間の最大微分器は、4つのパスがオンザフライ鍵合意を介して鍵生成を伴いながら、ツーパスプロトコルは、暗号モジュールに既存の鍵の転送をサポートしていることです。いずれの場合も、両方のプロトコルは、各プロトコルの実行の開始時に暗号化メカニズムとキータイプの交渉を通じて支援アルゴリズムの俊敏性をバリアント。"
    },
    {
      "indent": 0,
      "text": "3.2.4.1. Criteria for Using the Four-Pass Variant",
      "section_title": true,
      "ja": "3.2.4.1。四路バリアントを使用するための基準"
    },
    {
      "indent": 3,
      "text": "The four-pass protocol is needed under one or more of the following conditions:",
      "ja": "4パスプロトコルは、以下の1つまたは複数の条件によって必要とされています。"
    },
    {
      "indent": 3,
      "text": "o Policy requires that both parties engaged in the protocol jointly contribute entropy to the key. Enforcing this policy mitigates the risk of exposing a key during the provisioning process as the key is generated through mutual agreement without being transferred over-the-air or over-the-wire. It also mitigates risk of exposure after the key is provisioned, as the key will not be vulnerable to a single point of attack in the system.",
      "ja": "Oポリシーは、プロトコルに従事する両当事者が共同でキーにエントロピーを貢献することが必要です。このポリシーを適用する鍵は、空気を介して、またはオーバーザワイヤ転写されず合意を介して生成されるようにプロビジョニング・プロセス中に鍵を露出する危険性を軽減します。キーがプロビジョニングされた後にキーがシステムに攻撃の単一のポイントに対して脆弱ではありませんように、それはまた、暴露のリスクを軽減します。"
    },
    {
      "indent": 3,
      "text": "o A cryptographic module does not have private key capabilities.",
      "ja": "O暗号モジュールは、プライベートキーの機能を持っていません。"
    },
    {
      "indent": 3,
      "text": "o The cryptographic module is hosted by a device that neither was pre-issued with a manufacturer's key or other form of pre-shared key (as might be the case with a smart card or Subscriber Identity Module (SIM) card) nor has a keypad that can be used for entering a passphrase (such as present on a mobile phone).",
      "ja": "O暗号モジュールは、（スマートカードまたは加入者識別モジュール（SIM）カードの場合であるかもしれないと）どちらも事前共有キーのメーカーのキーまたは他の形で事前に発行されたデバイスによってホストされてもキーパッドを持っていますそれは（例えば、携帯電話上に存在するような）パスフレーズを入力するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.2.4.2. Criteria for Using the Two-Pass Variant",
      "section_title": true,
      "ja": "3.2.4.2。 2パスバリアントを使用するための基準"
    },
    {
      "indent": 3,
      "text": "The two-pass protocol is needed under one or more of the following conditions:",
      "ja": "2パス・プロトコルは、以下の1つまたは複数の条件によって必要とされています。"
    },
    {
      "indent": 3,
      "text": "o Pre-existing (i.e., legacy) keys must be provisioned via transport to the cryptographic module.",
      "ja": "Oプレ既存の（すなわち、レガシー）鍵は、暗号モジュールへの輸送を介してプロビジョニングされなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The cryptographic module is hosted on a device that was pre-issued with a manufacturer's key (such as may exist on a smart card), or other form of pre-shared key (such as may exist on a SIM-card), and is capable of performing private key operations.",
      "ja": "暗号モジュールがあったデバイス上でホストされているO（例えばSIMカード上に存在することができるように）事前共有鍵の製造業者（スマートカード上に存在し得るような）キー、または他の形で事前に発行され、そしてプライベートキー操作を実行することが可能です。"
    },
    {
      "indent": 3,
      "text": "o The cryptographic module is hosted by a device that has a built-in keypad with which a user may enter a passphrase, useful for deriving a key wrapping key for distribution of keying material.",
      "ja": "O暗号モジュールは、ユーザがキーイングマテリアルの配布用の鍵ラッピング鍵を導出するために有用なパスフレーズを入力することができるれる内蔵キーパッドを有するデバイスによってホストされます。"
    },
    {
      "indent": 0,
      "text": "3.3. Status Codes",
      "section_title": true,
      "ja": "3.3。ステータスコード"
    },
    {
      "indent": 3,
      "text": "Upon transmission or receipt of a message for which the Status attribute's value is not \"Success\" or \"Continue\", the default behavior, unless explicitly stated otherwise below, is that both the DSKPP Server and the DSKPP Client MUST immediately terminate the DSKPP run. DSKPP Servers and DSKPP Clients MUST delete any secret values generated as a result of failed runs of DSKPP. Session identifiers MAY be retained from successful or failed protocol runs for replay detection purposes, but such retained identifiers MUST NOT be reused for subsequent runs of the protocol.",
      "ja": "明示的に以下の記載がない限りStatus属性の値は、「成功」または「続行」、デフォルトの動作ではありませんそのため、メッセージの送信または受信すると、DSKPPサーバーとDSKPPクライアントの両方がすぐDSKPPの実行を終了させなければならないということです。 DSKPPサーバーとDSKPPクライアントはDSKPPの失敗した実行の結果として生成された秘密の値を削除しなければなりません。セッション識別子は、成功したか失敗したプロトコルから保持してもよいリプレイ検出目的のために動作しますが、そのような保持識別子は、プロトコルの後続の実行のために再利用してはなりません。"
    },
    {
      "indent": 3,
      "text": "When possible, the DSKPP Client SHOULD present an appropriate error message to the user.",
      "ja": "可能な場合、DSKPPクライアントは、ユーザに適切なエラーメッセージを提示しなければなりません。"
    },
    {
      "indent": 3,
      "text": "These status codes are valid in all DSKPP Response messages unless explicitly stated otherwise:",
      "ja": "特に明記しない限り、これらのステータスコードは、すべてのDSKPP応答メッセージに有効です。"
    },
    {
      "indent": 3,
      "text": "Continue: The DSKPP Server is ready for a subsequent request from the DSKPP Client. It cannot be sent in the server's final message.",
      "ja": "続行：DSKPP ServerはDSKPPクライアントからの後続の要求のための準備ができています。これは、サーバーの最後のメッセージで送信することはできません。"
    },
    {
      "indent": 3,
      "text": "Success: Successful completion of the DSKPP session. It can only be sent in the server's final message.",
      "ja": "成功：DSKPPセッションが正常に完了。それだけで、サーバの最後のメッセージで送信することができます。"
    },
    {
      "indent": 3,
      "text": "Abort: The DSKPP Server rejected the DSKPP Client's request for unspecified reasons.",
      "ja": "中止：DSKPP Serverは、不特定の理由でDSKPPクライアントの要求を拒否しました。"
    },
    {
      "indent": 3,
      "text": "AccessDenied: The DSKPP Client is not authorized to contact this DSKPP Server.",
      "ja": "アクセス拒否：DSKPPクライアントは、このDSKPP Serverに接続を許可されていません。"
    },
    {
      "indent": 3,
      "text": "MalformedRequest: The DSKPP Server failed to parse the DSKPP Client's request.",
      "ja": "MalformedRequest：DSKPP ServerはDSKPPクライアントの要求の解析に失敗しました。"
    },
    {
      "indent": 3,
      "text": "UnknownRequest: The DSKPP Client made a request that is unknown to the DSKPP Server.",
      "ja": "UnknownRequest：DSKPPクライアントがDSKPPサーバーに不明な要求を行いました。"
    },
    {
      "indent": 3,
      "text": "UnknownCriticalExtension: A DSKPP extension marked as \"Critical\" could not be interpreted by the receiving party.",
      "ja": "UnknownCriticalExtension：「クリティカル」は受信側で解釈することができなかったとしてマークされたDSKPP拡張。"
    },
    {
      "indent": 3,
      "text": "UnsupportedVersion: The DSKPP Client used a DSKPP version not supported by the DSKPP Server. This error is only valid in the DSKPP Server's first response message.",
      "ja": "UnsupportedVersion：DSKPPクライアントがDSKPPサーバーでサポートされていないDSKPPバージョンを使用していました。このエラーはDSKPP Serverの最初の応答メッセージにのみ有効です。"
    },
    {
      "indent": 3,
      "text": "NoSupportedKeyTypes: \"NoSupportedKeyTypes\" indicates that the DSKPP Client only suggested key types that are not supported by the DSKPP Server. This error is only valid in the DSKPP Server's first response message.",
      "ja": "NoSupportedKeyTypes：「NoSupportedKeyTypesは」DSKPPクライアントのみDSKPP Serverでサポートされていないキーのタイプを示唆していることを示しています。このエラーはDSKPP Serverの最初の応答メッセージにのみ有効です。"
    },
    {
      "indent": 3,
      "text": "NoSupportedEncryptionAlgorithms: The DSKPP Client only suggested encryption algorithms that are not supported by the DSKPP Server. This error is only valid in the DSKPP Server's first response message.",
      "ja": "NoSupportedEncryptionAlgorithms：DSKPP ServerでサポートされていませんDSKPPクライアントのみを示唆した暗号化アルゴリズム。このエラーはDSKPP Serverの最初の応答メッセージにのみ有効です。"
    },
    {
      "indent": 3,
      "text": "NoSupportedMacAlgorithms: The DSKPP Client only suggested MAC algorithms that are not supported by the DSKPP Server. This error is only valid in the DSKPP Server's first response message.",
      "ja": "NoSupportedMacAlgorithms：DSKPPクライアントにのみDSKPP ServerでサポートされていないMACアルゴリズムを提案しました。このエラーはDSKPP Serverの最初の応答メッセージにのみ有効です。"
    },
    {
      "indent": 3,
      "text": "NoProtocolVariants: The DSKPP Client did not suggest a required protocol variant (either two-pass or four-pass). This error is only valid in the DSKPP Server's first response message.",
      "ja": "NoProtocolVariants：DSKPPクライアントが必要なプロトコルのバリアント（2パスまたは4パスのいずれか）を示唆しませんでした。このエラーはDSKPP Serverの最初の応答メッセージにのみ有効です。"
    },
    {
      "indent": 3,
      "text": "NoSupportedKeyPackages: The DSKPP Client only suggested key package formats that are not supported by the DSKPP Server. This error is only valid in the DSKPP Server's first response message.",
      "ja": "NoSupportedKeyPackages：DSKPPクライアントにのみDSKPP Serverでサポートされていないキーパッケージ形式を提案しました。このエラーはDSKPP Serverの最初の応答メッセージにのみ有効です。"
    },
    {
      "indent": 3,
      "text": "AuthenticationDataMissing: The DSKPP Client didn't provide Authentication Data that the DSKPP Server required.",
      "ja": "AuthenticationDataMissing：DSKPPクライアントはDSKPP Serverが必要なことを認証データを提供していませんでした。"
    },
    {
      "indent": 3,
      "text": "AuthenticationDataInvalid: The DSKPP Client supplied User Authentication Data that the DSKPP Server failed to validate.",
      "ja": "AuthenticationDataInvalid：DSKPPクライアントがDSKPP Serverが検証に失敗したことをユーザ認証データを供給しました。"
    },
    {
      "indent": 3,
      "text": "InitializationFailed: The DSKPP Server could not generate a valid key given the provided data. When this status code is received, the DSKPP Client SHOULD try to restart DSKPP, as it is possible that a new run will succeed.",
      "ja": "InitializationFailed：DSKPP Serverが提供されたデータ指定した有効な鍵を生成することができませんでした。このステータスコードを受信した場合、DSKPPクライアントが、新しい実行が成功する可能性があるとして、DSKPPを再起動してみてください。"
    },
    {
      "indent": 3,
      "text": "ProvisioningPeriodExpired: The provisioning period set by the DSKPP Server has expired. When the status code is received, the DSKPP Client SHOULD report the reason for key initialization failure to the user and the user MUST register with the DSKPP Server to initialize a new key.",
      "ja": "ProvisioningPeriodExpired：DSKPPサーバーによって設定されたプロビジョニング期間が経過しました。ステータスコードを受信した場合、DSKPPクライアントは、ユーザーに鍵初期化失敗の理由を報告する必要がありますし、ユーザーが新しいキーを初期化するためにDSKPPサーバーに登録する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4. Basic Constructs",
      "section_title": true,
      "ja": "3.4。基本的な構築"
    },
    {
      "indent": 3,
      "text": "The following calculations are used in both DSKPP variants.",
      "ja": "以下の計算は、両方のDSKPPバリアントで使用されています。"
    },
    {
      "indent": 0,
      "text": "3.4.1. User Authentication Data (AD)",
      "section_title": true,
      "ja": "3.4.1。ユーザ認証データ（AD）"
    },
    {
      "indent": 3,
      "text": "User Authentication Data (AD) is derived from a Client ID and Authentication Code that the user enters before the first DSKPP message is sent.",
      "ja": "ユーザ認証データ（AD）は、第一DSKPPメッセージが送信される前にユーザーが入力したクライアントIDと認証コードから誘導されます。"
    },
    {
      "indent": 3,
      "text": "Note: The user will typically enter the Client ID and Authentication Code manually, possibly on a device with only numeric keypad. Thus, they are often short numeric values (for example, 8 decimal digits). However, the DSKPP Server is free to generate them in any way it wishes.",
      "ja": "注：ユーザーは、一般的に、おそらく唯一のテンキーを備えたデバイス上で、手動でクライアントのIDと認証コードを入力します。従って、それらはしばしば短い数値（例えば、8桁）です。しかし、DSKPP Serverは、それが希望するどのような方法でそれらを生成して自由です。"
    },
    {
      "indent": 0,
      "text": "3.4.1.1. Authentication Code Format",
      "section_title": true,
      "ja": "3.4.1.1。認証コードのフォーマット"
    },
    {
      "indent": 3,
      "text": "AC is encoded in Type-Length-Value (TLV) format. The format consists of a minimum of two TLVs and a variable number of additional TLVs, depending on implementation.",
      "ja": "ACは、タイプレングス値（TLV）形式でエンコードされています。フォーマットは、二つのTLV及び実装に応じて、追加のTLVの可変数の最小値から成ります。"
    },
    {
      "indent": 3,
      "text": "The TLV fields are defined as follows:",
      "ja": "次のようにTLVフィールドが定義されています。"
    },
    {
      "indent": 3,
      "text": "Type (1 character) A hexadecimal character identifying the type of information contained in the Value field.",
      "ja": "タイプ（1文字）Valueフィールドに含まれる情報のタイプを識別する16進文字。"
    },
    {
      "indent": 3,
      "text": "Length (2 characters) Two hexadecimal characters indicating the length of the Value field to follow. The field value MAY be up to 255 characters. The Length value 00 MAY be used to specify custom tags without any field values.",
      "ja": "長さ（2文字）に追従する値フィールドの長さを示す2進数の文字。フィールド値は最大255文字です。 Length値00は、任意のフィールド値なしでカスタムタグを指定するために使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Value (variable length) A variable-length string of hexadecimal characters containing the instance-specific information for this TLV.",
      "ja": "値（可変長）は、このTLVのインスタンス固有の情報を含む進文字の可変長文字列。"
    },
    {
      "indent": 3,
      "text": "The following table summarizes the TLVs defined in this document. Optional TLVs are allowed for vendor-specific extensions with the constraint that the high bit MUST be set to indicate a vendor-specific type. Other TLVs are left for later revisions of this protocol.",
      "ja": "次の表に、この文書で定義されたTLVをまとめたもの。オプションのTLVは、高ビットがベンダー固有のタイプを示すために設定しなければならないという制約を持つベンダー固有の拡張機能のために許可されています。その他のTLVは、このプロトコルの後の改正のために残されています。"
    },
    {
      "indent": 3,
      "text": "+------+------------+-------------------------------------------+\n| Type | TLV Name   | Conformance | Example Usage               |\n+------+------------+-------------------------------------------+\n|  1   | Client ID  | Mandatory   | { \"AC00000A\" }              |\n+------+------------+-------------+-----------------------------+\n|  2   | Password   | Mandatory   | { \"3582AF0C3E\" }            |\n+------+------------+-------------+-----------------------------+\n|  3   | Checksum   | Optional    | { \"4D5\" }                   |\n+------+------------+-------------+-----------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Client ID is a mandatory TLV that represents the requester's identifier of maximum length 255. The value is represented as a string of hexadecimal characters that identifies the key request. For example, suppose Client ID is set to \"AC00000A\", the Client ID TLV in the AC will be represented as \"108AC00000A\".",
      "ja": "クライアントIDは、値がキー要求を識別する進文字列として表現される最大長255の要求者の識別子を表す必須のTLVです。例えば、と仮定するクライアントIDは、ACのクライアントID TLVが「108AC00000A」として表現され、「AC00000A」に設定されています。"
    },
    {
      "indent": 3,
      "text": "The Password is a mandatory TLV the contains a one-time use shared secret known by the user and the Provisioning Server. The Password value is unique and SHOULD be a random string to make AC more difficult to guess. The string MUST contain hexadecimal characters only. For example, suppose password is set to \"3582AF0C3E\", then the Password TLV would be \"20A3582AF0C3E\".",
      "ja": "パスワードは必須TLVのインクルードは、ユーザーおよびプロビジョニングサーバによって知られている1回の使用共有秘密が含まれています。パスワードの値は一意であると推測するACをより困難にするために、ランダムな文字列でなければなりません。文字列は、16進数の文字だけを含まなければなりません。例えば、仮定するパスワードは「3582AF0C3E」に設定され、その後、パスワードTLVは「20A3582AF0C3E」になります。"
    },
    {
      "indent": 3,
      "text": "The Checksum is an OPTIONAL TLV, which is generated by the issuing server and sent to the user as part of the AC. If the TLV is provided, the checksum value MUST be computed using the CRC16 algorithm [ISO3309]. When the user enters the AC, the typed AC string of characters is verified with the checksum to ensure it is correctly entered by the user. For example, suppose the AC with combined Client ID tag and Password tag is set to \"108AC00000A20A3582AF0C3E\", then the CRC16 calculation would generate a checksum of 0x356, resulting in a Checksum TLV of \"334D5\". The complete AC string in this example would be \"108AC00000A20A3582AF0C3E3034D5\".",
      "ja": "チェックサムは、発行サーバによって生成され、ACの一部としてユーザに送信されるオプションTLV、です。 TLVが提供されている場合、チェックサム値は、CRC16アルゴリズム[ISO3309]を用いて計算されなければなりません。ユーザーがACに入ると、文字の入力されたAC文字列は、それが正しく、ユーザによって入力されていることを確認するためのチェックサムを検証しています。例えば、複合クライアントIDタグとパスワードタグが「108AC00000A20A3582AF0C3E」に設定されると、次にCRC16演算は「334D5」のチェックサムTLVをもたらす、0x356のチェックサムを生成するACと仮定する。この例では、完全なAC文字列は「108AC00000A20A3582AF0C3E3034D5」になります。"
    },
    {
      "indent": 3,
      "text": "Although this specification recommends using hexadecimal characters only for the AC at the application's user interface layer and making the TLV triples non-transparent to the user as described in the example above; implementations MAY additionally choose to use other printable Unicode characters [UNICODE] at the application's user interface layer in order to meet specific local, context or usability requirements. When non-hexadecimal characters are desired at the user interface layer such as when other printable US-ASCII characters or international characters are used, SASLprep [RFC4013] MUST be used to normalize user input before converting it to a string of hexadecimal characters. For example, if a given application allows the use of any printable US-ASCII characters and extended ASCII characters for Client ID and Password fields, and the Client ID is set to \"myclient!D\" and the associated Password is set to \"mYpas&#rD\", the user enters through the keyboard or other means a Client ID of \"myclient!D\" and a Password of \"mYpas&#rD\" in separate form fields or as instructed by the provider. The application's layer processing user input MUST then convert the values entered by the user to the following string for use in the protocol: \"1146D79636C69656E7421442126D5970617326237244\" (note that in this example the Checksum TLV is not added).",
      "ja": "この仕様は、アプリケーションのユーザインターフェイス層でのみAC 16進文字を使用し、上記実施例に記載したようにTLVがユーザに不透明トリプル行うお勧めしますが。実装は、さらに、特定のローカルコンテキストまたはユーザビリティの要件を満たすために他の印刷可能なUnicode文字を使用するアプリケーションのユーザインターフェイス層における[UNICODE]を選ぶかもしれません。非進数の文字は、このような他の印刷可能なUS-ASCII文字や国際文字が使用される場合などのユーザインタフェース層に望まれる場合、SASLprep [RFC4013]は進文字列に変換する前に、ユーザ入力を正規化するために使用されなければなりません。例えば、与えられたアプリケーションは、任意の印刷可能なUS-ASCII文字とクライアントIDとパスワードフィールドの拡張ASCII文字の使用を可能にし、クライアントIDは「MyClientという！D」に設定され、関連するパスワードは「mYpas＆＃に設定されている場合RDは」、ユーザーがキーボードから入力するか、他には、クライアントのIDを意味し、 『MyClientという！D』とのパスワード 『個別のフォームフィールド内またはプロバイダから指示されたとしてmYpas＆＃RDは』。アプリケーションのレイヤの処理、ユーザ入力は、プロトコルで使用するための次の文字列に、ユーザによって入力された値を変換しなければならない：「1146D79636C69656E7421442126D5970617326237244」は（この例ではチェックサムTLVが添加されないことに留意されたいです）。"
    },
    {
      "indent": 3,
      "text": "The example is explained further below in detail:",
      "ja": "例は、さらに詳細に説明します。"
    },
    {
      "indent": 3,
      "text": "Assume that the raw Client ID value or the value entered by the use is: myclient!ID",
      "ja": "生のクライアントID値または使用によって入力された値であることを前提としています！MyClientというID"
    },
    {
      "indent": 3,
      "text": "The Client ID value as characters names is:",
      "ja": "文字名などのクライアントID値は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "U+006D LATIN SMALL LETTER M character U+0079 LATIN SMALL LETTER Y character U+0063 LATIN SMALL LETTER C character U+006C LATIN SMALL LETTER L character U+0069 LATIN SMALL LETTER I character U+0065 LATIN SMALL LETTER E character U+006E LATIN SMALL LETTER N character U+0074 LATIN SMALL LETTER T character U+0021 EXCLAMATION MARK character (!) U+0044 LATIN CAPITAL LETTER D character",
      "ja": "U + 006Dラテン小文字M文字U + 0079ラテン小文字Yの文字U + 0063ラテン小文字C文字U + 006Cラテン小文字のLの文字U + 0069ラテン小文字I文字U + 0065ラテン小文字E文字U + 006E LATIN SMALL LETTER N文字U + 0074 LATIN SMALL LETTER Tの文字U + 0021感嘆符文字（！）U + 0044 LATIN CAPITAL LETTER Dの文字"
    },
    {
      "indent": 3,
      "text": "The UTF-8 conversion of the Client ID value is: 6D 79 63 6C 69 65 6E 74 21 44",
      "ja": "クライアントID値のUTF-8の変換は：（c）69 65 6E 74 21 44 6D 79 63"
    },
    {
      "indent": 3,
      "text": "The length of the Client ID value in hexadecimal characters is: 14",
      "ja": "進文字のクライアントID値の長さは14"
    },
    {
      "indent": 3,
      "text": "The TLV presentation of the Client ID field is: 1146D79636C69656E742144",
      "ja": "クライアントIDフィールドのTLVプレゼンテーションは、次のとおりです。1146D79636C69656E742144"
    },
    {
      "indent": 3,
      "text": "The raw Password value or the value entered by the user is: mYpas&#rD",
      "ja": "生のパスワード値またはユーザーが入力した値は次のとおりです。mYpas＆＃rDが"
    },
    {
      "indent": 3,
      "text": "The Password value as character names is:",
      "ja": "キャラクター名などのパスワード値は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "U+006D LATIN SMALL LETTER M character U+0059 LATIN LARGE LETTER Y character U+0070 LATIN SMALL LETTER P character",
      "ja": "U + 006Dラテン小文字M文字U + 0059ラテンLARGE LETTER Yの文字U + 0070ラテン小文字P文字"
    },
    {
      "indent": 6,
      "text": "U+0061 LATIN SMALL LETTER A character U+0073 LATIN SMALL LETTER S character U+0026 AMPERSAND character (&) U+0023 POUND SIGN character (#) U+0072 LATIN SMALL LETTER R character U+0044 LATIN LARGE LETTER D character",
      "ja": "U + 0061ラテン小文字文字U + 0073ラテン小文字S文字U​​ + 0026アンパサンド（＆）U + 0023ポンド記号（＃）U + 0072ラテン小文字R文字U + 0044ラテンLARGE文字Dの文字"
    },
    {
      "indent": 3,
      "text": "The UTF-8 conversion of the password value is: 6D 59 70 61 73 26 23 72 44",
      "ja": "パスワード値のUTF-8の変換は、次のとおり6D 59 70 61 73 26 23 72 44"
    },
    {
      "indent": 3,
      "text": "The length of the password value in hexadecimal characters is: 12",
      "ja": "進文字のパスワード値の長さがある：12"
    },
    {
      "indent": 3,
      "text": "The TLV presentation of the password field is: 2126D5970617326237244",
      "ja": "パスワードフィールドのTLVプレゼンテーションは、次のとおりです。2126D5970617326237244"
    },
    {
      "indent": 3,
      "text": "The combined Client ID and password fields value or the AC value is: 1146D79636C69656E7421442126D5970617326237244",
      "ja": "組み合わせたクライアントIDとパスワードのフィールド値またはAC値は次のとおりです。1146D79636C69656E7421442126D5970617326237244"
    },
    {
      "indent": 0,
      "text": "3.4.1.2. User Authentication Data Calculation",
      "section_title": true,
      "ja": "3.4.1.2。ユーザー認証データの計算"
    },
    {
      "indent": 3,
      "text": "The Authentication Data consists of a Client ID (extracted from the AC) and a value, which is derived from AC as follows (refer to Section 3.4.2 for a description of DSKPP-PRF in general and Appendix D for a description of DSKPP-PRF-AES):",
      "ja": "認証データ（ACから抽出された）クライアントIDで構成され、以下のようにACから誘導された値は、（DSKPP-の説明のために一般にDSKPP-PRFおよび付録Dの説明については、セクション3.4.2を参照してくださいPRF-AES）："
    },
    {
      "indent": 3,
      "text": "MAC = DSKPP-PRF(K_AC, AC->ClientID||URL_S||R_C||[R_S], 16)",
      "ja": "MAC = DSKPP-PRF（K_AC、AC->クライアントID || || URL_S R_C || [R_S]、16）"
    },
    {
      "indent": 3,
      "text": "In four-pass DSKPP, the cryptographic module uses R_C, R_S, and URL_S to calculate the MAC, where URL_S is the URL the DSKPP Client uses when contacting the DSKPP Server. In two-pass DSKPP, the cryptographic module does not have access to R_S, therefore only R_C is used in combination with URL_S to produce the MAC. In either case, K_AC MUST be derived from AC->password as follows [PKCS-5]:",
      "ja": "四通過DSKPPにおいて、暗号モジュールはURL_SがDSKPPサーバーに接続するときDSKPPクライアントが使用するURLであるMACを計算するR_C、R_S、及びURL_Sを使用します。ツーパスDSKPPにおいて、暗号モジュールは、したがってのみR_CはMACを生成するためにURL_Sと組み合わせて使用​​され、R_Sへのアクセスを持っていません。 [PKCS-5]を以下のようにいずれの場合も、K_ACはAC->パスワードから導出されなければなりません"
    },
    {
      "indent": 3,
      "text": "K_AC = PBKDF2(AC->password, R_C || K, iter_count, 16)",
      "ja": "K_AC = PBKDF2（AC->パスワード、R_C || K、iter_count、16）"
    },
    {
      "indent": 3,
      "text": "One of the following values for K MUST be used:",
      "ja": "Kは、次のいずれかの値を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "a. In four-pass: * The public key of the DSKPP Server (K_SERVER), or (in the pre-shared key variant) the pre-shared key between the client and the server (K_SHARED). b. In two-pass: * The public key of the DSKPP Client, or the public key of the device when a device certificate is available. * The pre-shared key between the client and the server (K_SHARED). * A passphrase-derived key.",
      "ja": "A。 4パスで：*（事前共有鍵バリアントで）DSKPPサーバー（K_SERVER）、またはの公開鍵、クライアントとサーバー（K_SHARED）間の事前共有鍵。 B。 2パスで：* DSKPPクライアントの公開鍵、またはデバイス証明書が利用可能なデバイスの公開鍵。 *クライアントとサーバ（K_SHARED）間の事前共有キー。 *パスフレーズ派生キー。"
    },
    {
      "indent": 3,
      "text": "The iteration count, iter_count, MUST be set to at least 100,000 except in the last two two-pass cases (where K is set to K_SHARED or a passphrase-derived key), in which case iter_count MUST be set to 1.",
      "ja": "繰り返し回数は、iter_countは、iter_countを1に設定しなければならない場合には（KはK_SHAREDまたはパスフレーズ派生キーに設定されている）最後の2つの2パスの場合、を除いて少なくとも100,000を設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.4.2. The DSKPP One-Way Pseudorandom Function, DSKPP-PRF",
      "section_title": true,
      "ja": "3.4.2。 DSKPPワンウェイ擬似ランダム関数、DSKPP-PRF"
    },
    {
      "indent": 3,
      "text": "Regardless of the protocol variant employed, there is a requirement for a cryptographic primitive that provides a deterministic transformation of a secret key k and a varying length octet string s to a bit string of specified length dsLen.",
      "ja": "かかわらず、使用プロトコル変異体の、指定された長さdsLenのビット列に決定的秘密鍵Kの変換及び可変長オクテット列sを提供する暗号プリミティブのための要件が​​あります。"
    },
    {
      "indent": 3,
      "text": "This primitive must meet the same requirements as for a keyed hash function: it MUST take an arbitrary length input and generate an output that is one way and collision free (for a definition of these terms, see, e.g., [FAQ]). Further, its output MUST be unpredictable even if other outputs for the same key are known.",
      "ja": "このプリミティブは、鍵付きハッシュ関数と同じ要件を満たす必要があります。それは一方通行と衝突フリーである出力任意の長さの入力を取り、生成しなければなりません（これらの用語の定義については、参照、例えば、[FAQ]）。さらに、その出力は、同じキーの他の出力が知られていても予測不可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "From the point of view of this specification, DSKPP-PRF is a \"black-box\" function that, given the inputs, generates a pseudorandom value and MAY be realized by any appropriate and competent cryptographic technique. Appendix D contains two example realizations of DSKPP-PRF.",
      "ja": "本明細書の観点から、DSKPP-PRFは、入力が与えられると、擬似ランダム値を生成し、任意の適切かつ有能な暗号技術によって実現することができる、「ブラックボックス」機能です。付録DはDSKPP-PRFの2例の実現が含まれています。"
    },
    {
      "indent": 3,
      "text": "DSKPP-PRF(k, s, dsLen)",
      "ja": "DSKPP-PRF（K、S、dsLen）"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "k secret key in octet string format s octet string of varying length consisting of variable data distinguishing the particular string being derived dsLen desired length of the output",
      "ja": "出力のdsLen所望の長さを派生されている特定の文字列を区別可変データからなる可変長のオクテットストリング形式のオクテット文字列に秘密鍵k個"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "DS pseudorandom string, dsLen octets long",
      "ja": "dsLenオクテット長いDSの擬似乱数列、"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, the secret key k MUST be at least 16 octets long.",
      "ja": "このドキュメントの目的のために、秘密鍵kは、少なくとも16オクテット長でなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.4.3. The DSKPP Message Hash Algorithm",
      "section_title": true,
      "ja": "3.4.3。 DSKPPメッセージハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "When sending its last message in a protocol run, the DSKPP Server generates a MAC that is used by the client for key confirmation. Computation of the MAC MUST include a hash of all DSKPP messages sent by the client and server during the transaction. To compute a message hash for the MAC given a sequence of DSKPP messages msg_1, ..., msg_n, the following operations MUST be carried out: a. The sequence of messages contains all DSKPP Request and Response messages up to but not including this message. b. Re-transmitted messages are removed from the sequence of messages. Note: The resulting sequence of messages MUST be an alternating sequence of DSKPP Request and DSKPP Response messages c. The contents of each message is concatenated together. d. The resultant string is hashed using SHA-256 in accordance with [FIPS180-SHA].",
      "ja": "プロトコルの実行で最後のメッセージを送信すると、DSKPP Serverが鍵確認のためにクライアントによって使用されるMACを生成します。 MACの計算は、トランザクション中にクライアントとサーバから送信されたすべてのDSKPPメッセージのハッシュを含まなければなりません。メッセージはmsg_1 DSKPPのシーケンス与えられたMACのメッセージのハッシュを計算するには、...、msg_nは、以下の操作を行わなければなりません：。メッセージのシーケンスは、このメッセージを含むすべてのDSKPP要求と応答メッセージまでではなく、含まれています。 B。再送信されたメッセージは、メッセージのシーケンスから削除されます。注：メッセージの結果として生じる配列はDSKPP要求とDSKPP応答メッセージcの交互の配列でなければなりません。各メッセージの内容が一緒に連結されています。 D。得られた文字列は、[FIPS180-SHA]に従ってSHA-256を使用してハッシュされます。"
    },
    {
      "indent": 0,
      "text": "4. Four-Pass Protocol Usage",
      "section_title": true,
      "ja": "4.四路プロトコルの使用"
    },
    {
      "indent": 3,
      "text": "This section describes the methods and message flow that comprise the four-pass protocol variant. Four-pass DSKPP depends on a client-server key agreement mechanism.",
      "ja": "このセクションでは、4パスプロトコルバリアントを含む方法及びメッセージフローを記述する。四路DSKPPは、クライアント - サーバーの鍵合意のメカニズムに依存します。"
    },
    {
      "indent": 0,
      "text": "4.1. The Key Agreement Mechanism",
      "section_title": true,
      "ja": "4.1。鍵共有メカニズム"
    },
    {
      "indent": 3,
      "text": "With four-pass DSKPP, the symmetric key that is the target of provisioning, is generated on-the-fly without being transferred between the DSKPP Client and DSKPP Server. The data flow and computation are described below.",
      "ja": "四パスDSKPP、プロビジョニングの対象である対称鍵を用いて、DSKPPクライアントとDSKPPサーバとの間で転送されることなく、オンザフライで生成されます。データフロー及び計算は、以下に記載されます。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Data Flow",
      "section_title": true,
      "ja": "4.1.1。データフロー"
    },
    {
      "indent": 3,
      "text": "A sample data flow showing key generation during the four-pass protocol is shown in Figure 3.",
      "ja": "4パスプロトコル中に鍵の生成を示すサンプル・データ・フローは、図3に示されています。"
    },
    {
      "indent": 3,
      "text": "+----------------------+                  +----------------------+\n|    +------------+    |                  |                      |\n|    | Server key |    |                  |                      |\n| +<-|  Public    |------>------------->-------------+---------+ |\n| |  |  Private   |    |                  |          |         | |\n| |  +------------+    |                  |          |         | |\n| |        |           |                  |          |         | |\n| V        V           |                  |          V         V |\n| |   +---------+      |                  |        +---------+ | |\n| |   | Decrypt |<-------<-------------<-----------| Encrypt | | |\n| |   +---------+      |                  |        +---------+ | |\n| |      |  +--------+ |                  |            ^       | |\n| |      |  | Server | |                  |            |       | |\n| |      |  | Random |--->------------->------+  +----------+  | |\n| |      |  +--------+ |                  |   |  | Client   |  | |\n| |      |      |      |                  |   |  | Random   |  | |\n| |      |      |      |                  |   |  +----------+  | |\n| |      |      |      |                  |   |        |       | |\n| |      V      V      |                  |   V        V       | |\n| |   +------------+   |                  | +------------+     | |\n| +-->|  DSKPP PRF |   |                  | |  DSKPP PRF |<----+ |\n|     +------------+   |                  | +------------+       |\n|           |          |                  |       |              |\n|           V          |                  |       V              |\n|       +-------+      |                  |   +-------+          |\n|       |  Key  |      |                  |   |  Key  |          |\n|       +-------+      |                  |   +-------+          |\n|       +-------+      |                  |   +-------+          |\n|       |Key Id |-------->------------->------|Key Id |          |\n|       +-------+      |                  |   +-------+          |\n+----------------------+                  +----------------------+\n      DSKPP Server                              DSKPP Client",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 3: Principal Data Flow for DSKPP Key Generation Using Public Server Key",
      "ja": "図3：公開サーバキーを使用してDSKPPキー生成のための主要なデータフロー"
    },
    {
      "indent": 3,
      "text": "The inclusion of the two random nonces (R_S and R_C) in the key generation provides assurance to both sides (the cryptographic module and the DSKPP Server) that they have contributed to the key's randomness and that the key is unique. The inclusion of the encryption key (K) ensures that no man in the middle may be present, or else the cryptographic module will end up with a key different from the one stored by the legitimate DSKPP Server.",
      "ja": "鍵生成における2つのランダムなノンス（R_SとR_C）を含めることは、それらがキーのランダム性に寄与し、キーが一意であることをしていることを両側（暗号モジュールとDSKPPサーバ）への保証を提供します。暗号化キー（K）の包含は中央には人が存在しなくてもよい、あるいは暗号モジュールが正当DSKPPサーバによって記憶された1つのキーは異なるで終わることを保証します。"
    },
    {
      "indent": 3,
      "text": "Conceptually, although R_C is one pseudorandom string, it may be viewed as consisting of two components, R_C1 and R_C2, where R_C1 is generated during the protocol run, and R_C2 can be pre-generated and loaded on the cryptographic module before the device is issued to the user. In that case, the latter string, R_C2, SHOULD be unique for each cryptographic module.",
      "ja": "概念的R_C一擬似乱数列であるが、それはR_C1プロトコルの実行中に生成される二つの成分、R_C1とR_C2、からなるとみなすことができる、とR_C2は、事前に生成し、デバイスが発行される前に、暗号モジュールにロードすることができますユーザーへ。その場合には、後者の文字列、R_C2は、各暗号モジュールのために一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "A man in the middle (in the form of corrupt client software or a mistakenly contacted server) may present his own public key to the cryptographic module. This will enable the attacker to learn the client's version of K_TOKEN. However, the attacker is not able to persuade the legitimate server to derive the same value for K_TOKEN, since K_TOKEN is a function of the public key involved, and the attacker's public key must be different than the correct server's (or else the attacker would not be able to decrypt the information received from the client). Therefore, once the attacker is no longer \"in the middle,\" the client and server will detect that they are \"out of sync\" when they try to use their keys. In the case of encrypting R_C with K_SERVER, it is therefore important to verify that K_SERVER really is the legitimate server's key. One way to do this is to independently validate a newly generated K_TOKEN against some validation service at the server (e.g., using a connection independent from the one used for the key generation).",
      "ja": "（壊れたクライアントソフトウェアまたは誤って連絡サーバーの形で）真ん中の男が暗号モジュールに自分の公開鍵を提示することができます。これはK_TOKENのクライアントのバージョンを学ぶために、攻撃者が有効になります。 K_TOKENが関与公開鍵の関数であり、攻撃者の公開鍵が正しいサーバーの（または他の攻撃者はいないだろうと異なっている必要がありますので、攻撃者は、K_TOKENに同じ値を導出するために正当なサーバーを説得することができませんクライアントから受信した情報）を解読することができます。攻撃者は、もはや一度そのため、「途中で、」クライアントとサーバは、彼らが自分のキーを使用しようとすると、彼らは「同期の外」であることを検出します。 K_SERVERでR_Cを暗号化する場合には、K_SERVERが本当に正当なサーバーの鍵であることを確認することが重要です。これを行う1つの方法は、独立して、（例えば、鍵生成のために使用されるものから独立した接続を使用して）サーバでいくつかの検証サービスに対して新たに生成されたK_TOKENを検証することです。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Computation",
      "section_title": true,
      "ja": "4.1.2。算出"
    },
    {
      "indent": 3,
      "text": "In four-pass DSKPP, the client and server both generate K_TOKEN and K_MAC by deriving them from a provisioning key (K_PROV) using the DSKPP-PRF (refer to Section 3.4.2) as follows:",
      "ja": "DSKPP、クライアントとサーバの両方DSKPP-PRF（セクション3.4.2を参照）を次のように使用して、プロビジョニング・キー（K_PROV）からそれらを導出することによってK_TOKENとK_MACを生成する四渡し："
    },
    {
      "indent": 3,
      "text": "K_PROV = DSKPP-PRF(k,s,dsLen), where",
      "ja": "K_PROV = DSKPP-PRF（K、S、dsLen）"
    },
    {
      "indent": 7,
      "text": "k = R_C (i.e., the secret random value chosen by the DSKPP\nClient)\ns = \"Key generation\" || K || R_S (where K is the key used to\nencrypt R_C and R_S is the random value chosen by the DSKPP\nServer)\ndsLen = (desired length of K_PROV whose first half constitutes\nK_MAC and second half constitutes K_TOKEN)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Then, K_TOKEN and K_MAC are derived from K_PROV, where",
      "ja": "その後、K_TOKENとK_MACがK_PROV、由来しています"
    },
    {
      "indent": 7,
      "text": "K_PROV = K_MAC || K_TOKEN",
      "ja": "K_PROV = K_MAC || K_TOKEN"
    },
    {
      "indent": 3,
      "text": "When computing K_PROV, the derived keys, K_MAC and K_TOKEN, MAY be subject to an algorithm-dependent transform before being adopted as a key of the selected type. One example of this is the need for parity in DES keys.",
      "ja": "K_PROVを計算するときに、導出鍵、K_MACとK_TOKENは、アルゴリズムに依存するが、選択されたタイプのキーとして採用される前に変換を受ける可能性があります。この一例はDESキーでパリティの必要性です。"
    },
    {
      "indent": 3,
      "text": "Note that this computation pertains to four-pass DSKPP only.",
      "ja": "この計算は4つだけのパスDSKPPに関係することに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.2. Message Flow",
      "section_title": true,
      "ja": "4.2。メッセージフロー"
    },
    {
      "indent": 3,
      "text": "The four-pass protocol flow consists of two message exchanges: 1: Pass 1 = <KeyProvClientHello>, Pass 2 = <KeyProvServerHello> 2: Pass 3 = <KeyProvClientNonce>, Pass 4 = <KeyProvServerFinished>",
      "ja": "4パスプロトコルフローは、2つのメッセージ交換から成る：1：1 = <KeyProvClientHello>、合格合格2 = <KeyProvServerHello> 2：パス3 = <KeyProvClientNonce>、パス4 = <KeyProvServerFinished>"
    },
    {
      "indent": 3,
      "text": "The first pair of messages negotiate cryptographic algorithms and exchange nonces. The second pair of messages establishes a symmetric key using mutually authenticated key agreement.",
      "ja": "メッセージの最初のペアは、暗号化アルゴリズムと交換ナンスを交渉します。メッセージの第二の対は、相互認証鍵合意を使用して対称鍵を確立します。"
    },
    {
      "indent": 3,
      "text": "The purpose and content of each message are described below. XML format and examples are in Section 8 and Appendix B.",
      "ja": "目的と各メッセージの内容を以下に説明します。 XML形式と例は、第8章および付録Bにあります"
    },
    {
      "indent": 0,
      "text": "4.2.1. KeyProvTrigger",
      "section_title": true,
      "ja": "4.2.1。 KeyProvTrigger"
    },
    {
      "indent": 11,
      "text": "DSKPP Client                         DSKPP Server\n------------                         ------------\n                     [<---]       AD, [DeviceID],\n                                 [KeyID], [URL_S]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When this message is sent: The \"trigger\" message is optional. The DSKPP Server sends this message after the following out-of-band steps are performed: 1. A user directed their browser to a key provisioning web application and signs in (i.e., authenticates). 2. The user requests a key. 3. The web application processes the request and returns an Authentication Code to the user, e.g., in response to an enrollment request via a secure web session. 4. The web application retrieves the Authentication Code from the user (possibly by asking the user to enter it using a web form, or alternatively by the user selecting a URL in which the Authentication Code is embedded). 5. The web application derives Authentication Data (AD) from the Authentication Code as described in Section 3.4.1. 6. The web application passes AD, and possibly a DeviceID (identifies a particular device to which the key is to be provisioned) and/or KeyID (identifies a key that will be replaced) to the DSKPP Server.",
      "ja": "このメッセージが送信された場合：「トリガー」のメッセージはオプションです。以下の帯域外ステップが実行された後DSKPPサーバは、このメッセージを送信する：1.ユーザーは（即ち、認証）で鍵プロビジョニングWebアプリケーションおよび徴候にブラウザに指示しました。 2.ユーザーがキーを要求します。 3. Webアプリケーションは、要求を処理し、安全なウェブセッションを介して登録要求に応答して、例えば、ユーザに認証コードを返します。前記ウェブアプリケーションは、ユーザ（おそらくウェブフォームを使用して入力するようにユーザに要求することによって、あるいは認証コードが埋め込まれたURLをユーザが選択することによって）から認証コードを取得します。セクション3.4.1に記載されるように前記ウェブアプリケーションは、認証コードの認証データ（AD）を導出します。 6. DSKPPサーバへのWebアプリケーションは、ADを通過し、そしておそらくデバイスID（鍵がプロビジョニングされるべき特定のデバイスを識別し）、および/またはKeyIDをは（置換されるキーを識別する）。"
    },
    {
      "indent": 3,
      "text": "Purpose of this message: To start a DSKPP session: The DSKPP Server uses this message to trigger a client-side application to send the first DSKPP message. To provide a way for the key provisioning system to get the DSKPP Server URL to the DSKPP Client.",
      "ja": "このメッセージの目的：DSKPPセッションを開始するには、次のDSKPP Serverは、最初のDSKPPメッセージを送信するために、クライアント側のアプリケーションを起動するために、このメッセージを使用しています。 DSKPPクライアントにDSKPPサーバーのURLを取得するための鍵プロビジョニング・システムのための方法を提供します。"
    },
    {
      "indent": 6,
      "text": "So the key provisioning system can point the DSKPP Client to a particular cryptographic module that was pre-configured in the DSKPP provisioning server.",
      "ja": "そう鍵プロビジョニングシステムはDSKPPプロビジョニングサーバに予め設定された特定の暗号モジュールにDSKPPクライアントを指すことができます。"
    },
    {
      "indent": 6,
      "text": "In the case of key renewal, to identify the key to be replaced.",
      "ja": "キー更新の場合は、交換するキーを識別します。"
    },
    {
      "indent": 3,
      "text": "What is contained in this message: AD MUST be provided to allow the DSKPP Server to authenticate the user before completing the protocol run.",
      "ja": "何がこのメッセージに含まれている：ADはDSKPP Serverは、プロトコルの実行を完了する前に、ユーザーを認証できるようにするために提供されなければなりません。"
    },
    {
      "indent": 6,
      "text": "A DeviceID MAY be included to allow a key provisioning application to bind the provisioned key to a specific device.",
      "ja": "デバイスIDは、鍵プロビジョニング・アプリケーションが特定のデバイスにプロビジョニングされた鍵を結合させるために含まれるかもしれません。"
    },
    {
      "indent": 6,
      "text": "A KeyID MAY be included to allow the key provisioning application to identify a key to be replaced, e.g., in the case of key renewal.",
      "ja": "KeyIDを、キーの更新の場合には、例えば、置換されるキーを識別するための鍵プロビジョニング・アプリケーションを可能にするために含まれるかもしれません。"
    },
    {
      "indent": 6,
      "text": "The Server URL MAY be included to allow the key provisioning application to inform the DSKPP Client of which server to contact.",
      "ja": "サーバーのURLは、鍵プロビジョニング・アプリケーションは連絡するサーバーのDSKPPクライアントに通知できるようにするために含まれるかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.2.2. KeyProvClientHello",
      "section_title": true,
      "ja": "4.2.2。 KeyProvClientHello"
    },
    {
      "indent": 11,
      "text": "DSKPP Client                         DSKPP Server\n------------                         ------------\nSAL, [AD],\n[DeviceID], [KeyID]     --->",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When this message is sent: When a DSKPP Client first connects to a DSKPP Server, it is required to send the <KeyProvClientHello> as its first message. The client can also send a <KeyProvClientHello> in response to a <KeyProvTrigger>.",
      "ja": "このメッセージが送信されると：DSKPPクライアントが最初DSKPP Serverに接続すると、その最初のメッセージとして、<KeyProvClientHello>を送信するために必要とされます。また、クライアントは、<KeyProvTrigger>に応じて、<KeyProvClientHello>を送ることができます。"
    },
    {
      "indent": 3,
      "text": "What is contained in this message: The Security Attribute List (SAL) included with <KeyProvClientHello> contains the combinations of DSKPP versions, variants, key package formats, key types, and cryptographic algorithms that the DSKPP Client supports in order of the client's preference (favorite choice first).",
      "ja": "何このメッセージに含まれています。セキュリティは、リスト（SAL）は<KeyProvClientHello>に含まれる属性は、（DSKPPクライアントは、クライアントの好みの順でサポートされていることをDSKPPバージョン、バリアント、キーパッケージフォーマット、キータイプ、および暗号化アルゴリズムの組み合わせが含まれています最初のお気に入りの選択肢）。"
    },
    {
      "indent": 6,
      "text": "If <KeyProvClientHello> was preceded by a <KeyProvTrigger>, then this message MUST also include the Authentication Data (AD), DeviceID, and/or KeyID that was provided with the trigger.",
      "ja": "<KeyProvClientHello>が<KeyProvTrigger>が先行した場合、このメッセージは、トリガーを備えたことを認証データ（AD）、デバイスID、および/またはKeyIDをを含まなければなりません。"
    },
    {
      "indent": 6,
      "text": "If <KeyProvClientHello> was not preceded by a <KeyProvTrigger>, then this message MAY contain a DeviceID that was pre-shared with the DSKPP Server, and a key ID associated with a key previously provisioned by the DSKPP provisioning server.",
      "ja": "<KeyProvClientHello>が<KeyProvTrigger>によって先行されなかった場合、このメッセージはDSKPPサーバーで事前共有されたデバイスID、および以前にDSKPPプロビジョニングサーバによってプロビジョニングキーに関連付けられている鍵IDを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "Application note: If this message is preceded by trigger message <KeyProvTrigger>, then the application will already have AD available (see Section 4.2.1). However, if this message was not preceded by <KeyProvTrigger>, then the application MUST retrieve the User Authentication Code, possibly by prompting the user to manually enter their Authentication Code, e.g., on a device with only a numeric keypad.",
      "ja": "アプリケーションノート：このメッセージは、トリガメッセージ<KeyProvTrigger>が付いている場合は、アプリケーションがすでに利用可能なADを持つことになります（4.2.1項を参照してください）。このメッセージは、<KeyProvTrigger>が先行していなかった場合は、そのアプリケーションはおそらく手動でのみテンキーとデバイス上で、例えば自分の認証コードを入力するようにユーザを促すことにより、ユーザ認証コードを取得する必要があります。"
    },
    {
      "indent": 6,
      "text": "The application MUST also derive Authentication Data (AD) from the Authentication Code, as described in Section 3.4.1, and save it for use in its next message, <KeyProvClientNonce>.",
      "ja": "アプリケーションはまた、セクション3.4.1で説明したように、認証コードの認証データ（AD）を導出し、その次のメッセージで使用するためにそれを保存する必要があり、<KeyProvClientNonce>。"
    },
    {
      "indent": 3,
      "text": "How the DSKPP Server uses this message: The DSKPP Server will look for an acceptable combination of DSKPP version, variant (in this case, four-pass), key package format, key type, and cryptographic algorithms. If the DSKPP Client's SAL does not match the capabilities of the DSKPP Server, or does not comply with key provisioning policy, then the DSKPP Server will set the Status attribute to something other than \"Continue\". Otherwise, the Status attribute will be set to \"Continue\".",
      "ja": "DSKPP Serverは、このメッセージをどのように使用するか：DSKPP Serverは、（この場合は、4パス）DSKPPバージョン、バリアント、キーパッケージ形式、キータイプ、および暗号化アルゴリズムの許容可能な組み合わせを探します。 DSKPPクライアントのSALがDSKPP Serverの機能と一致していない、またはキープロビジョニング・ポリシーに準拠していない場合は、DSKPP Serverは、「続行」以外の何かにステータス属性を設定します。それ以外の場合は、Status属性は、「続行」に設定されます。"
    },
    {
      "indent": 6,
      "text": "If included in <KeyProvClientHello>, the DSKPP Server will validate the Authentication Data (AD), DeviceID, and KeyID. The DSKPP Server MUST NOT accept the DeviceID unless the server sent the DeviceID in a preceding trigger message. Note that it is also legitimate for a DSKPP Client to initiate the DSKPP run without having received a <KeyProvTrigger> message from a server, but in this case any provided DeviceID MUST NOT be accepted by the DSKPP Server unless the server has access to a unique key for the identified device and that key will be used in the protocol.",
      "ja": "<KeyProvClientHello>に含まれている場合、DSKPPサーバーは認証データ（AD）、デバイスID、および鍵IDを検証します。サーバは、先行トリガメッセージにデバイスIDを送信しない限り、DSKPP Serverは、デバイスIDを受け入れてはいけません。 DSKPPクライアントがサーバから<KeyProvTrigger>メッセージを受信したことなく、DSKPPの実行を開始することも正当であることに注意してくださいが、サーバーがユニークにアクセスすることがない限り、このような場合には任意の提供デバイスIDはDSKPPサーバーで受け入れてはなりません識別されたデバイスとそのキーのキーは、プロトコルで使用されます。"
    },
    {
      "indent": 0,
      "text": "4.2.3. KeyProvServerHello",
      "section_title": true,
      "ja": "4.2.3。 KeyProvServerHello"
    },
    {
      "indent": 11,
      "text": "DSKPP Client                         DSKPP Server\n------------                         ------------\n                      <---    SAL, R_S, [K], [MAC]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When this message is sent: The DSKPP Server will send this message in response to a <KeyProvClientHello> message after it looks for an acceptable combination of DSKPP version, variant (in this case, four-pass), key package format, key type, and set of cryptographic algorithms. If it could not find an acceptable combination, then it will still send the message, but with a failure status.",
      "ja": "このメッセージが送信されるとき：それはDSKPPバージョン、変異体（ここでは4パス）、キーパッケージ形式、キータイプの許容される組み合わせを探した後DSKPPサーバーは<KeyProvClientHello>メッセージに応答し、このメッセージを送信します、暗号アルゴリズムのセット。それが許容可能な組み合わせを見つけることができなかった場合、それはまだしかし、障害の状態と、メッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "Purpose of this message: With this message, the context for the protocol run is set. Furthermore, the DSKPP Server uses this message to transmit a random nonce, which is required for each side to agree upon the same symmetric key (K_TOKEN).",
      "ja": "このメッセージの目的：このメッセージでは、プロトコルの実行のためのコンテキストが設定されています。また、DSKPPサーバは、各辺が同じ対称鍵（K_TOKEN）について合意するために必要とされるランダムなノンスを送信するためにこのメッセージを使用します。"
    },
    {
      "indent": 3,
      "text": "What is contained in this message: A status attribute equivalent to the server's return code to <KeyProvClientHello>. If the server found an acceptable set of attributes from the client's SAL, then it sets status to Continue and returns an SAL (selected from the SAL that it received in <KeyProvClientHello>). The Server's SAL specifies the DSKPP version and variant (in this case, four-pass), key type, cryptographic algorithms, and key package format that the DSKPP Client MUST use for the remainder of the protocol run.",
      "ja": "このメッセージに含まれるもの：ステータスが<KeyProvClientHello>に、サーバーのリターンコードと同等の属性。サーバーがクライアントのSALから属性の許容セットを見つけた場合、それは（それが<KeyProvClientHello>で受信していることSALから選択）SALを続行して返すために、ステータスを設定します。サーバのSALはDSKPPバージョン及び変異体（ここでは4パス）、キータイプ、暗号化アルゴリズム、およびDSKPPクライアントプロトコルランの残りのために使用しなければならないキーパッケージ形式を指定します。"
    },
    {
      "indent": 6,
      "text": "A random nonce (R_S) for use in generating a symmetric key through key agreement; the length of R_S may depend on the selected key type.",
      "ja": "鍵合意を介して対称鍵を生成する際に使用するためのランダムなノンス（R_S）。 R_Sの長さは、選択されたキーの種類に依存してもよいです。"
    },
    {
      "indent": 6,
      "text": "A key (K) for the DSKPP Client to use for encrypting the client nonce included with <KeyProvClientNonce>. K represents the server's public key (K_SERVER) or a pre-shared secret key (K_SHARED).",
      "ja": "DSKPPクライアントは、クライアント・ナンスを暗号化するために使用するためのキー（K）は、<KeyProvClientNonce>に含まれています。 Kは、サーバの公開鍵（K_SERVER）または事前共有秘密鍵（K_SHARED）を表しています。"
    },
    {
      "indent": 6,
      "text": "A MAC MUST be present if a key is being renewed so that the DSKPP Client can confirm that the replacement key came from a trusted server. This MAC MUST be computed using DSKPP-PRF (see Section 3.4.2), where the input parameter k MUST be set to the existing MAC key K_MAC' (i.e., the value of the MAC key that existed before this protocol run; the implementation MAY specify K_MAC' to be the value of the K_TOKEN that is being replaced), and input parameter dsLen MUST be set to the length of R_S.",
      "ja": "DSKPPクライアントは、交換キーは、信頼できるサーバから来たことを確認できるように、キーが更新されている場合、MACが存在しなければなりません。このMACは、入力パラメータkが既存のMAC鍵K_MAC」（すなわち、このプロトコルの実行前に存在MACキーの値に設定しなければならないDSKPP-PRF（セクション3.4.2を参照）、使用して計算されなければならない。実装）置換されているK_TOKENの値に「K_MACを指定することができ、入力パラメータdsLenはR_Sの長さに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "How the DSKPP Client uses this message: When the Status attribute is not set to \"Continue\", this indicates failure and the DSKPP Client MUST abort the protocol.",
      "ja": "どのようにDSKPPクライアントは、このメッセージを使用しています：ステータス属性は「続行」に設定されていない場合は、これは失敗したことを示し、DSKPPクライアントは、プロトコルを中止しなければなりません。"
    },
    {
      "indent": 6,
      "text": "If successful execution of the protocol will result in the replacement of an existing key with a newly generated one, the DSKPP Client MUST verify the MAC provided in <KeyProvServerHello>. The DSKPP Client MUST terminate the DSKPP session if the MAC does not verify, and MUST delete any nonces, keys, and/or secrets associated with the failed run.",
      "ja": "プロトコルが正常に実行が新しく生成された1を持つ既存のキーの交換になります場合は、DSKPPクライアントは、<KeyProvServerHello>で提供MACを確かめなければなりません。 DSKPPクライアントがMACが検証されない場合DSKPPセッションを終えなければなりませんし、任意のナンス、キー、および/または失敗した実行に関連付けられた秘密を削除しなければなりません。"
    },
    {
      "indent": 6,
      "text": "If the Status attribute is set to \"Continue\", the cryptographic module generates a random nonce (R_C) using the cryptographic algorithm specified in the SAL. The length of the nonce R_C will depend on the selected key type.",
      "ja": "ステータス属性は「続行」に設定されている場合は、暗号モジュールは、SALに指定された暗号アルゴリズムを使用してランダムなナンス（R_C）を生成します。ナンスR_Cの長さは、選択したキータイプによって異なります。"
    },
    {
      "indent": 6,
      "text": "Encrypt R_C using K and the encryption algorithm included in the SAL.",
      "ja": "KおよびSALに含まれる暗号化アルゴリズムを使用して暗号化R_C。"
    },
    {
      "indent": 3,
      "text": "The method the DSKPP Client MUST use to encrypt R_C: If K is equivalent to K_SERVER (i.e., the public key of the DSKPP Server), then an RSA encryption scheme from PKCS #1 [PKCS-1] MAY be used. If K is equivalent to K_SERVER, then the cryptographic module SHOULD verify the server's certificate before using it to encrypt R_C as described in [RFC2818], Section 3.1, and [RFC5280].",
      "ja": "方法DSKPPクライアントがR_Cを暗号化するために使用しなければならない：KはK_SERVER（DSKPPサーバのすなわち、公開鍵）と同等である場合、PKCS＃1 [PKCS-1]から、次にRSA暗号方式を用いてもよいです。 KはK_SERVERと同等である場合には、暗号モジュールは、[RFC2818]、セクション3.1、および[RFC5280]に記載されているようにR_Cを暗号化するためにそれを使用する前に、サーバの証明書を確認する必要があります。"
    },
    {
      "indent": 6,
      "text": "If K is equivalent to K_SHARED, the DSKPP Client MAY use the DSKPP-PRF to avoid dependence on other algorithms. In this case, the client uses K_SHARED as input parameter k (K_SHARED SHOULD be used solely for this purpose) as follows:",
      "ja": "KはK_SHAREDと同等であれば、DSKPPクライアントは、他のアルゴリズムへの依存を避けるためにDSKPP-PRFを使用するかもしれません。この場合、クライアントは次のように（K_SHAREDこの目的のためにのみ使用されてください）入力パラメータkとK_SHAREDを使用します。"
    },
    {
      "indent": 6,
      "text": "dsLen = len(R_C), where \"len\" is the length of R_C DS = DSKPP-PRF(K_SHARED, \"Encryption\" || R_S, dsLen)",
      "ja": "\"LEN\" はR_C DS = DSKPP-PRF（K_SHARED、 \"暗号化\" || R_S、dsLen）の長さであるdsLen = LEN（R_C）"
    },
    {
      "indent": 6,
      "text": "This will produce a pseudorandom string DS of length equal to R_C. Encryption of R_C MAY then be achieved by XOR-ing DS with R_C:",
      "ja": "これはR_Cに等しい長さの擬似乱数列DSを生成します。 R_Cの暗号化は、その後R_CでDSをXORすることによって達成することができます。"
    },
    {
      "indent": 6,
      "text": "E(DS, R_C) = DS ^ R_C",
      "ja": "E（DS、R_C）= DS ^ R_C"
    },
    {
      "indent": 6,
      "text": "The DSKPP Server will then perform the reverse operation to extract R_C from E(DS, R_C).",
      "ja": "DSKPP Serverは、E（DS、R_C）からR_Cを抽出するために逆の動作を実行します。"
    },
    {
      "indent": 0,
      "text": "4.2.4. KeyProvClientNonce",
      "section_title": true,
      "ja": "4.2.4。 KeyProvClientNonce"
    },
    {
      "indent": 11,
      "text": "DSKPP Client                         DSKPP Server\n------------                         ------------\nE(K,R_C), AD          --->",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When this message is sent: The DSKPP Client will send this message immediately following a <KeyProvServerHello> message whose status was set to \"Continue\".",
      "ja": "このメッセージが送信された場合：DSKPPクライアントは、ステータスが「続行」に設定された<KeyProvServerHello>メッセージの直後にこのメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "Purpose of this message: With this message the DSKPP Client transmits User Authentication Data (AD) and a random nonce encrypted with the DSKPP Server's key (K). The client's random nonce is required for each side to agree upon the same symmetric key (K_TOKEN).",
      "ja": "このメッセージの目的：DSKPPクライアントはユーザー認証データ（AD）とDSKPPサーバーのキー（K）で暗号化されたランダムなnonceを送信し、このメッセージで。それぞれの側が同じ対称鍵（K_TOKEN）に合意するために、クライアントのランダムなナンスが必要です。"
    },
    {
      "indent": 3,
      "text": "What is contained in this message: Authentication Data (AD) that was derived from an Authentication Code entered by the user before <KeyProvClientHello> was sent (refer to Section 3.2).",
      "ja": "このメッセージに含まれるもの：認証データ<KeyProvClientHello>の前にユーザーが入力した認証コードから派生した（AD）が送信されました（3.2節を参照してください）。"
    },
    {
      "indent": 6,
      "text": "The DSKPP Client's random nonce (R_C), which was encrypted as described in Section 4.2.3.",
      "ja": "セクション4.2.3で説明したように、暗号化されたDSKPPクライアントのランダムなナンス（R_C）、。"
    },
    {
      "indent": 3,
      "text": "How the DSKPP Server uses this message: The DSKPP Server MUST use AD to authenticate the user. If authentication fails, then the DSKPP Server MUST set the return code to a failure status.",
      "ja": "どのようにDSKPP Serverは、このメッセージを使用しています。DSKPPサーバは、ユーザを認証するためにADを使用しなければなりません。認証が失敗した場合、DSKPPサーバーは、障害の状態に戻りコードを設定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "If user authentication passes, the DSKPP Server decrypts R_C using its key (K). The decryption method is based on whether K that was transmitted to the client in <KeyProvServerHello> was equal to the server's public key (K_SERVER) or a pre-shared key (K_SHARED) (refer to Section 4.2.3 for a description of how the DSKPP Client encrypts R_C).",
      "ja": "ユーザ認証に合格した場合、DSKPP Serverは、そのキー（K）を使用してR_Cを復号化します。復号化方法は、クライアントに送信されたかどうかKに基づいている<KeyProvServerHello>サーバの公開鍵（K_SERVER）または事前共有鍵（K_SHARED）（方法については、セクション4.2.3を参照するために等しかったですDSKPPクライアント）がR_Cを暗号化します。"
    },
    {
      "indent": 6,
      "text": "After extracting R_C, the DSKPP Server computes K_TOKEN using a combination of the two random nonces R_S and R_C and its encryption key, K, as described in Section 4.1.2. The particular realization of DSKPP-PRF (e.g., those defined in Appendix D) depends on the MAC algorithm contained in the <KeyProvServerHello> message. The DSKPP Server then generates a key package that contains key usage attributes such as expiry date and length. The key package MUST NOT include K_TOKEN since in the four-pass variant K_TOKEN is never transmitted between the DSKPP Server and Client. The server stores K_TOKEN and the key package with the user's account on the cryptographic server.",
      "ja": "R_Cを抽出した後、DSKPPサーバは、セクション4.1.2に記載したように2つのランダムなノンスR_SとR_Cその暗号鍵、K、の組み合わせを使用してK_TOKENを計算します。 （例えば、付録Dで定義されたもの）DSKPP-PRFの特定の実現は<KeyProvServerHello>メッセージに含まれるMACアルゴリズムに依存します。 DSKPP Serverは、このような有効期限や長さなどの主要な使用属性が含まれているキーパッケージを生成します。 4パスバリアントにK_TOKENがDSKPPサーバとクライアントの間で送信されることはありませんので、キーパッケージはK_TOKENを含んではいけません。サーバーに格納K_TOKENと暗号サーバー上のユーザーのアカウントを持つキーパッケージ。"
    },
    {
      "indent": 6,
      "text": "Finally, the server generates a key confirmation MAC that the client will use to avoid a false \"Commit\" message that would cause the cryptographic module to end up in state in which the server does not recognize the stored key.",
      "ja": "最後に、サーバは、クライアントが暗号モジュールは、サーバが格納されたキーを認識していない状態で終わるさせるような偽の「コミット」メッセージを回避するために使用するキーの確認MACを生成します。"
    },
    {
      "indent": 3,
      "text": "The MAC used for key confirmation MUST be calculated as follows:",
      "ja": "MACは、鍵確認のために使用され、以下のように計算しなければなりません。"
    },
    {
      "indent": 6,
      "text": "msg_hash = SHA-256(msg_1, ..., msg_n)",
      "ja": "msg_hash = SHA-256（msg_1、...、msg_n）"
    },
    {
      "indent": 6,
      "text": "dsLen = len(msg_hash)",
      "ja": "dsLen = LEN（msg_hash）"
    },
    {
      "indent": 6,
      "text": "MAC = DSKPP-PRF (K_MAC, \"MAC 1 computation\" || msg_hash, dsLen) where",
      "ja": "MAC = DSKPP-PRF（K_MAC、 \"MAC 1つの演算\" || msg_hash、dsLen）"
    },
    {
      "indent": 6,
      "text": "MAC The DSKPP Pseudorandom Function defined in Section 3.4.2 is used to compute the MAC. The particular realization of DSKPP-PRF (e.g., those defined in Appendix D) depends on the MAC algorithm contained in the <KeyProvServerHello> message. The MAC MUST be computed using the existing MAC key (K_MAC), and a string that is formed by concatenating the (ASCII) string \"MAC 1 computation\" and a msg_hash.",
      "ja": "3.4.2項で定義されたMACザ・DSKPP擬似ランダム関数は、MACを計算するために使用されます。 （例えば、付録Dで定義されたもの）DSKPP-PRFの特定の実現は<KeyProvServerHello>メッセージに含まれるMACアルゴリズムに依存します。 MACは、既存のMAC鍵（K_MAC）、及び（ASCII）文字列「MAC 1演算」とmsg_hashを連結することによって形成されている文字列を使用して計算されなければなりません。"
    },
    {
      "indent": 6,
      "text": "K_MAC The key derived from K_PROV, as described in Section 4.1.2.",
      "ja": "K_MAC 4.1.2項で説明したように、K_PROV由来キー。"
    },
    {
      "indent": 6,
      "text": "msg_hash The message hash (defined in Section 3.4.3) of messages msg_1, ..., msg_n.",
      "ja": "msg_1、...、msg_nメッセージの（セクション3.4.3で定義された）メッセージハッシュをmsg_hash。"
    },
    {
      "indent": 0,
      "text": "4.2.5. KeyProvServerFinished",
      "section_title": true,
      "ja": "4.2.5。 KeyProvServerFinished"
    },
    {
      "indent": 11,
      "text": "DSKPP Client                         DSKPP Server\n------------                         ------------\n                       <---               KP, MAC",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When this message is sent: The DSKPP Server will send this message after authenticating the user and, if authentication passed, generating K_TOKEN and a key package, and associating them with the user's account on the cryptographic server.",
      "ja": "このメッセージが送信されると：DSKPP Serverは、ユーザーを認証し、認証が渡された場合、K_TOKENとキーパッケージを生成し、暗号サーバ上のユーザのアカウントでそれらを関連付けた後、このメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "Purpose of this message: With this message, the DSKPP Server confirms generation of the key (K_TOKEN) and transmits the associated identifier and application-specific attributes, but not the key itself, in a key package to the client for protocol completion.",
      "ja": "このメッセージの目的：このメッセージで、DSKPPサーバキー（K_TOKEN）の生成を確認し、プロトコル終了のためにクライアントにキーパッケージに、関連する識別子とアプリケーション固有の属性ではなく、キー自体を送信します。"
    },
    {
      "indent": 3,
      "text": "What is contained in this message: A status attribute equivalent to the server's return code to <KeyProvClientNonce>. If user authentication passed, and the server successfully computed K_TOKEN, generated a key package, and associated them with the user's account on the cryptographic server, then it sets the Status attribute to \"Success\". If the Status attribute is set to \"Success\", then this message acts as a \"Commit\" message, instructing the cryptographic module to store the generated key (K_TOKEN) and associate the given key identifier with this key. As such, a key package (KP) MUST be included in this message, which holds an identifier for the generated key (but not the key itself) and additional configuration, e.g., the identity of the DSKPP Server, key usage attributes, etc. The default symmetric key package format MUST be based on the Portable Symmetric Key Container (PSKC) defined in [RFC6030]. Alternative formats MAY include [RFC6031], PKCS #12 [PKCS-12], or PKCS #5 XML [PKCS-5-XML] format.",
      "ja": "このメッセージに含まれるもの：ステータスが<KeyProvClientNonce>に、サーバーのリターンコードと同等の属性。ユーザー認証が渡された場合は、サーバが正常にキーパッケージを生成し、暗号サーバ上のユーザのアカウントでそれらを関連付けられ、K_TOKENを計算し、それは「成功」にステータス属性を設定します。ステータス属性が「成功」に設定されている場合、このメッセージが生成されたキー（K_TOKEN）を格納し、このキーで指定されたキー識別子を関連付けるために暗号化モジュールを指示するメッセージを「コミット」として作用します。このように、キーパッケージ（KP）は、生成された鍵の識別子を保持し、このメッセージに含まれなければならない（ただし、鍵自体など）などと追加の構成、DSKPPサーバのアイデンティティ、キー使用属性、デフォルト対称鍵パッケージ形式は、[RFC6030]で定義されたポータブル対称キーコンテナ（PSKC）に基づいていなければなりません。代替フォーマットは、[RFC6031]、PKCS＃12 [PKCS-12]、またはPKCS＃5 XML [PKCS-5-XML]の形式を含むかもしれません。"
    },
    {
      "indent": 6,
      "text": "With KP, the server includes a key confirmation MAC that the client uses to avoid a false \"Commit\" message. The MAC algorithm is the same DSKPP-PRF that was sent in the <KeyProvServerHello> message.",
      "ja": "KPでは、サーバは、クライアントが偽の「コミット」メッセージを回避するために使用するキーの確認MACを含んでいます。 MACアルゴリズムは<KeyProvServerHello>メッセージで送信されたのと同じDSKPP-PRFです。"
    },
    {
      "indent": 3,
      "text": "How the DSKPP Client uses this message: When the Status attribute is not set to \"Success\", this indicates failure and the DSKPP Client MUST abort the protocol.",
      "ja": "どのようにDSKPPクライアントは、このメッセージを使用しています：Status属性が「成功」に設定されていない場合は、これは失敗したことを示し、DSKPPクライアントは、プロトコルを中止しなければなりません。"
    },
    {
      "indent": 6,
      "text": "After receiving a <KeyProvServerFinished> message with Status = \"Success\", the DSKPP Client MUST verify the key confirmation MAC that was transmitted with this message. The DSKPP Client MUST terminate the DSKPP session if the MAC does not verify, and MUST, in this case, also delete any nonces, keys, and/or secrets associated with the failed run of the protocol.",
      "ja": "ステータス=「成功」で<KeyProvServerFinished>メッセージを受信した後、DSKPPクライアントは、このメッセージで送信されたキーの確認MACを確かめなければなりません。 DSKPPクライアントがMACが検証されない場合DSKPPセッションを終えなければなりません、そして、この場合には、また任意のナンス、キー、および/またはプロトコルの失敗実行に関連付けられた秘密を削除しなければなりません。"
    },
    {
      "indent": 6,
      "text": "If <KeyProvServerFinished> has Status = \"Success\", and the MAC was verified, then the DSKPP Client MUST calculate K_TOKEN from the combination of the two random nonces R_S and R_C and the server's encryption key, K, as described in Section 4.1.2. The DSKPP-PRF is the same one used for MAC computation. The DSKPP Client associates the key package contained in <KeyProvServerFinished> with the generated key, K_TOKEN, and stores this data permanently on the cryptographic module.",
      "ja": "<KeyProvServerFinished>ステータス=「成功」を持っている、とMACが確認された場合は、セクション4.1.2で説明したように、その後、DSKPPクライアントは、2つのランダムなナンスのR_SとR_Cとサーバーの暗号化キー、Kの組み合わせからK_TOKENを計算しなければなりません。 。 DSKPP-PRFは、MACの計算に使用したのと同じものです。 DSKPPクライアントは、暗号モジュールに恒久的にこのデータを生成した鍵、K_TOKENで<KeyProvServerFinished>に含まれているキーパッケージを関連付けて記憶します。"
    },
    {
      "indent": 6,
      "text": "After this operation, it MUST NOT be possible to overwrite the key unless knowledge of an authorizing key is proven through a MAC on a later <KeyProvServerHello> (and <KeyProvServerFinished>) message.",
      "ja": "この操作の後、認可キーの知識は後<KeyProvServerHello>（および<KeyProvServerFinished>）メッセージにMACによって証明されていない限りキーを上書きすることが可能であるはずがありません。"
    },
    {
      "indent": 0,
      "text": "5. Two-Pass Protocol Usage",
      "section_title": true,
      "ja": "5. 2パスプロトコルの使用"
    },
    {
      "indent": 3,
      "text": "This section describes the methods and message flow that comprise the two-pass protocol variant. Two-pass DSKPP is essentially a transport of keying material from the DSKPP Server to the DSKPP Client. The DSKPP Server transmits keying material in a key package formatted in accordance with [RFC6030], [RFC6031], PKCS #12 [PKCS-12], or PKCS #5 XML [PKCS-5-XML].",
      "ja": "このセクションでは、2つのパス・プロトコル・バリアントを含む方法及びメッセージフローを記述する。ツーパスDSKPPは、基本的にDSKPPクライアントへDSKPPサーバーから材料をキーイングの輸送です。 DSKPPサーバは[RFC6030]、[RFC6031]、PKCS＃12 [PKCS-12]、またはPKCS＃5 XML [PKCS-5-XML]に従ってフォーマットキーパッケージに材料を合わせる送信します。"
    },
    {
      "indent": 3,
      "text": "The keying material includes a provisioning master key, K_PROV, from which the DSKPP Client derives two keys: the symmetric key to be established in the cryptographic module, K_TOKEN, and a key, K_MAC, used for key confirmation. The keying material also includes key usage attributes, such as expiry date and length.",
      "ja": "対称暗号モジュールに確立されるキー、K_TOKEN、およびキー確認のために使用されるキー、K_MAC：鍵材料はDSKPPクライアントは2つのキーを派生元プロビジョニングマスターキー、K_PROVを含みます。鍵材料はまた、有効期限と長さキー使用属性を含みます。"
    },
    {
      "indent": 3,
      "text": "The DSKPP Server encrypts K_PROV to ensure that it is not exposed to any other entity than the DSKPP Server and the cryptographic module itself. The DSKPP Server uses any of three key protection methods to encrypt K_PROV: Key Transport, Key Wrap, and Passphrase-Based Key Wrap Key Protection methods.",
      "ja": "DSKPPサーバーは、それがDSKPPサーバーと暗号モジュール自体よりも、他のエンティティに公開されていないことを確認するためにK_PROVを暗号化します。主な交通、キーラップ、およびパスフレーズベースのキーラップキーの保護方法：DSKPP ServerはK_PROVを暗号化するために、3つのキーの保護方法のいずれかを使用しています。"
    },
    {
      "indent": 3,
      "text": "While the DSKPP Client and server may negotiate the key protection method to use, the actual key protection is carried out in the KeyPackage. The format of a KeyPackage specifies how a key should be protected using the three key protection methods. The following KeyPackage formats are defined for DSKPP:",
      "ja": "DSKPPクライアントとサーバが使用するキーの保護方法を交渉するかもしれないが、実際のキーの保護をKeyPackageで行われます。 KeyPackageのフォーマットは、キーが3つの主要な保護方法を使用して保護する方法を指定します。次KeyPackage形式はDSKPPのために定義されています。"
    },
    {
      "indent": 3,
      "text": "o PSKC Key Container [RFC6030] at urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container",
      "ja": "O PSKCキーコンテナ壷で[RFC6030]：IETF：のparams：XML：NS：keyprov：dskpp：pskcキーコンテナ"
    },
    {
      "indent": 3,
      "text": "o SKPC Key Container [RFC6031] at urn:ietf:params:xml:ns:keyprov:dskpp:skpc-key-container",
      "ja": "O SKPCキーコンテナ壷で[RFC6031]：IETF：のparams：XML：NS：keyprov：dskpp：skpcキーコンテナ"
    },
    {
      "indent": 3,
      "text": "o PKCS12 Key Container [PKCS-12] at urn:ietf:params:xml:ns:keyprov:dskpp:pkcs12-key-container",
      "ja": "O PKCS12キーコンテナ[PKCS12] URNで：IETF：のparams：XML：NS：keyprov：dskpp：PKCS12キーコンテナ"
    },
    {
      "indent": 3,
      "text": "o PKCS5-XML Key Container [PKCS-5-XML] at urn:ietf:params:xml:ns:keyprov:dskpp:pkcs5-xml-key-container",
      "ja": "IETF：：のparams：XML：NS：keyprov：dskpp：PKCS5-XML-キーコンテナ壷でO PKCS5-XMLキーコンテナ[PKCS5-XML]"
    },
    {
      "indent": 3,
      "text": "Each of the key protection methods is described below.",
      "ja": "キーの保護方法の各々は、以下に説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Key Protection Methods",
      "section_title": true,
      "ja": "5.1。キーの保護方法"
    },
    {
      "indent": 3,
      "text": "This section introduces three key protection methods for the two-pass variant. Additional methods MAY be defined by external entities or through the IETF process.",
      "ja": "このセクションでは、2つのパスのバリアントのための3つのキーの保護方法を紹介します。さらなる方法は、外部エンティティによって、またはIETFプロセスを定義することができる（MAY）。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Key Transport",
      "section_title": true,
      "ja": "5.1.1。主な交通機関"
    },
    {
      "indent": 3,
      "text": "Purpose of this method: This method is intended for PKI-capable devices. The DSKPP Server encrypts keying material and transports it to the DSKPP Client. The server encrypts the keying material using the public key of the DSKPP Client, whose private key part resides in the cryptographic module. The DSKPP Client decrypts the keying material and uses it to derive the symmetric key, K_TOKEN.",
      "ja": "この方法の目的：この方法は、PKI対応デバイスを対象としています。 DSKPP Serverが鍵材料を暗号化し、DSKPPクライアントに搬送します。サーバーは、秘密鍵の部分暗号モジュールに常駐DSKPPクライアントの公開鍵を使って鍵素材を暗号化します。 DSKPPクライアントは鍵を復号化し、対称鍵、K_TOKENを導出するためにそれを使用しています。"
    },
    {
      "indent": 3,
      "text": "This method is identified with the following URN: urn:ietf:params:xml:schema:keyprov:dskpp:transport",
      "ja": "URN：IETF：のparams：XML：スキーマ：このメソッドは、次のURNで識別されkeyprov：dskpp：輸送"
    },
    {
      "indent": 3,
      "text": "The DSKPP Server and Client MUST support the following mechanism: http://www.w3.org/2001/04/xmlenc#rsa-1_5 encryption mechanism defined in [XMLENC].",
      "ja": "http://www.w3.org/2001/04/xmlenc#rsa-1_5 [XMLENC]で定義された暗号化メカニズム：DSKPPサーバーとクライアントは、次のようなメカニズムをサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Key Wrap",
      "section_title": true,
      "ja": "5.1.2。キーラップ"
    },
    {
      "indent": 3,
      "text": "Purpose of this method: This method is ideal for pre-keyed devices, e.g., SIM cards. The DSKPP Server encrypts keying material using a pre-shared key wrapping key and transports it to the DSKPP Client. The DSKPP Client decrypts the keying material, and uses it to derive the symmetric key, K_TOKEN.",
      "ja": "この方法の目的：この方法は、予めキー付きデバイス、例えば、SIMカードのために理想的です。 DSKPP Serverは、事前共有キーラッピングキーを使用して鍵材料を暗号化し、DSKPPクライアントに搬送します。 DSKPPクライアントは鍵を復号化し、対称鍵、K_TOKENを導出するためにそれを使用しています。"
    },
    {
      "indent": 3,
      "text": "This method is identified with the following URN: urn:ietf:params:xml:schema:keyprov:dskpp:wrap",
      "ja": "URN：IETF：のparams：XML：スキーマ：このメソッドは、次のURNで識別されkeyprov：dskpp：ラップ"
    },
    {
      "indent": 3,
      "text": "The DSKPP Server and Client MUST support all of the following key wrapping mechanisms:",
      "ja": "DSKPPサーバーとクライアントは、次の主要なラッピングメカニズムのすべてをサポートしなければなりません："
    },
    {
      "indent": 3,
      "text": "AES128 KeyWrap Refer to id-aes128-wrap in [RFC3394] and http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC]",
      "ja": "AES128 KeyWrapは[XMLENC]の[RFC3394]にID-AES128ラップを参照しhttp://www.w3.org/2001/04/xmlenc#kw-aes128"
    },
    {
      "indent": 3,
      "text": "AES128 KeyWrap with Padding Refer to id-aes128-wrap-pad in [RFC5649] and http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC]",
      "ja": "パディングの[RFC5649]にID-AES128ラップパッドを参照し、http://www.w3.org/2001/04/xmlenc#kw-aes128とAES128 KeyWrap [XMLENC]"
    },
    {
      "indent": 3,
      "text": "AES-CBC-128 Refer to [FIPS197-AES] and http://www.w3.org/2001/04/xmlenc#aes128-cbc in [XMLENC]",
      "ja": "AES-CBC-128は、[FIPS197-AES]を参照し、http://www.w3.org/2001/04/xmlenc#aes128-cbc [XMLENC]で"
    },
    {
      "indent": 0,
      "text": "5.1.3. Passphrase-Based Key Wrap",
      "section_title": true,
      "ja": "5.1.3。パスフレーズベースのキーラップ"
    },
    {
      "indent": 3,
      "text": "Purpose of this method: This method is a variation of the Key Wrap Method that is applicable to constrained devices with keypads, e.g., mobile phones. The DSKPP Server encrypts keying material using a wrapping key derived from a user-provided passphrase, and transports the encrypted material to the DSKPP Client. The DSKPP Client decrypts the keying material, and uses it to derive the symmetric key, K_TOKEN.",
      "ja": "この方法の目的：このメソッドは、キーパッド、例えば、携帯電話との制約のあるデバイスにも適用することがキーラップ方式のバリエーションです。 DSKPP Serverは、ユーザー提供のパスフレーズから派生ラッピング鍵を使って鍵材料を暗号化し、DSKPPクライアントに暗号化された材料を運びます。 DSKPPクライアントは鍵を復号化し、対称鍵、K_TOKENを導出するためにそれを使用しています。"
    },
    {
      "indent": 6,
      "text": "To preserve the property of not exposing K_TOKEN to any other entity than the DSKPP Server and the cryptographic module itself, the method SHOULD be employed only when the device contains facilities (e.g., a keypad) for direct entry of the passphrase.",
      "ja": "DSKPPサーバーと暗号モジュール自体以外のエンティティにK_TOKENを露出しない性質を維持するために、方法は、デバイスがパスフレーズの直接入力のための設備（例えば、キーパッド）が含まれている場合にのみ使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "This method is identified with the following URN: urn:ietf:params:xml:schema:keyprov:dskpp:passphrase-wrap",
      "ja": "URN：IETF：のparams：XML：スキーマ：keyprov：dskpp：パスフレーズラップこの方法は、以下のURNで識別されます"
    },
    {
      "indent": 3,
      "text": "The DSKPP Server and Client MUST support the following:",
      "ja": "DSKPPサーバーとクライアントは、次のことをサポートしなければなりません："
    },
    {
      "indent": 6,
      "text": "* The PBES2 password-based encryption scheme defined in [PKCS-5] (and identified as http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2 in [PKCS-5-XML]).",
      "ja": "* [PKCS-5]で定義さPBES2パスワードベースの暗号化スキーム（及びhttp://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2として同定[PKCS-5-XML]）。"
    },
    {
      "indent": 6,
      "text": "* The PBKDF2 passphrase-based key derivation function also defined in [PKCS-5] (and identified as http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2 in [PKCS-5-XML]).",
      "ja": "* PBKDF2パスフレーズベースの鍵導出関数はまた、[PKCS-5]で定義された（および[PKCS-5-XML]でhttp://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2として同定します）。"
    },
    {
      "indent": 6,
      "text": "* All of the following key wrapping mechanisms:",
      "ja": "*次のキーラッピングメカニズムのすべて："
    },
    {
      "indent": 9,
      "text": "AES128 KeyWrap Refer to id-aes128-wrap in [RFC3394] and http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC]",
      "ja": "AES128 KeyWrapは[XMLENC]の[RFC3394]にID-AES128ラップを参照しhttp://www.w3.org/2001/04/xmlenc#kw-aes128"
    },
    {
      "indent": 9,
      "text": "AES128 KeyWrap with Padding Refer to id-aes128-wrap-pad in [RFC5649] and http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC]",
      "ja": "パディングの[RFC5649]にID-AES128ラップパッドを参照し、http://www.w3.org/2001/04/xmlenc#kw-aes128とAES128 KeyWrap [XMLENC]"
    },
    {
      "indent": 9,
      "text": "AES-CBC-128 Refer to [FIPS197-AES] and http://www.w3.org/2001/04/xmlenc#aes128-cbc in [XMLENC]",
      "ja": "AES-CBC-128は、[FIPS197-AES]を参照し、http://www.w3.org/2001/04/xmlenc#aes128-cbc [XMLENC]で"
    },
    {
      "indent": 0,
      "text": "5.2. Message Flow",
      "section_title": true,
      "ja": "5.2。メッセージフロー"
    },
    {
      "indent": 3,
      "text": "The two-pass protocol flow consists of one exchange: 1: Pass 1 = <KeyProvClientHello>, Pass 2 = <KeyProvServerFinished>",
      "ja": "ツーパスプロトコルフローは、一つの交換から成る：1：パス1 = <KeyProvClientHello>、パス2 = <KeyProvServerFinished>"
    },
    {
      "indent": 3,
      "text": "Although there is no exchange of the <ServerHello> message or the <ClientNonce> message, the DSKPP Client is still able to specify algorithm preferences and supported key types in the <KeyProvClientHello> message.",
      "ja": "<のServerHello>メッセージまたは<ClientNonce>メッセージのない交換はありませんが、DSKPP Clientは、まだ<KeyProvClientHello>メッセージに、アルゴリズムの好みとサポートされているキーのタイプを指定することができます。"
    },
    {
      "indent": 3,
      "text": "The purpose and content of each message are described below. XML format and examples are in Section 8 and Appendix B.",
      "ja": "目的と各メッセージの内容を以下に説明します。 XML形式と例は、第8章および付録Bにあります"
    },
    {
      "indent": 0,
      "text": "5.2.1. KeyProvTrigger",
      "section_title": true,
      "ja": "5.2.1。 KeyProvTrigger"
    },
    {
      "indent": 3,
      "text": "The trigger message is used in exactly the same way for the two-pass variant as for the four-pass variant; refer to Section 4.2.1.",
      "ja": "トリガメッセージは、4パスバリアントのような2つのパスの変形のためにまったく同じ方法で使用されています。 4.2.1項を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.2. KeyProvClientHello",
      "section_title": true,
      "ja": "5.2.2。 KeyProvClientHello"
    },
    {
      "indent": 11,
      "text": "DSKPP Client                         DSKPP Server\n------------                         ------------\nSAL, AD, R_C,\n[DeviceID], [KeyID],\nKPML                   --->",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When this message is sent: When a DSKPP Client first connects to a DSKPP Server, it is required to send the <KeyProvClientHello> as its first message. The client can also send <KeyProvClientHello> in response to a <KeyProvTrigger> message.",
      "ja": "このメッセージが送信されると：DSKPPクライアントが最初DSKPP Serverに接続すると、その最初のメッセージとして、<KeyProvClientHello>を送信するために必要とされます。また、クライアントは、<KeyProvTrigger>メッセージに応答して、<KeyProvClientHello>を送ることができます。"
    },
    {
      "indent": 3,
      "text": "Purpose of this message: With this message, the DSKPP Client specifies its algorithm preferences and supported key types as well as which DSKPP versions, protocol variants (in this case \"two-pass\"), key package formats, and key protection methods that it supports. Furthermore, the DSKPP Client facilitates user authentication by transmitting the Authentication Data (AD) that was provided by the user before the first DSKPP message was sent.",
      "ja": "キータイプをサポートだけでなく、どのDSKPPはバージョン、プロトコルバリアント（この場合は「2パス」）、キーパッケージフォーマット、およびそのキーの保護方法このメッセージでは、DSKPPクライアントは、そのアルゴリズムの優先順位を指定し、このメッセージの目的サポートされています。また、DSKPPクライアントはまずDSKPPメッセージが送信される前にユーザによって提供された認証データ（AD）を送信することによってユーザ認証を容易にします。"
    },
    {
      "indent": 3,
      "text": "Application note: This message MUST send User Authentication Data (AD) to the DSKPP Server. If this message is preceded by trigger message <KeyProvTrigger>, then the application will already have AD available (see Section 4.2.1). However, if this message was not preceded by <KeyProvTrigger>, then the application MUST retrieve the User Authentication Code, possibly by prompting the user to manually enter their Authentication Code, e.g., on a device with only a numeric keypad. The application MUST also derive Authentication Data (AD) from the Authentication Code, as described in Section 3.4.1, and save it for use in its next message, <KeyProvClientNonce>.",
      "ja": "アプリケーションノート：このメッセージは、DSKPPサーバーにユーザー認証データ（AD）を送らなければなりません。このメッセージがトリガメッセージ<KeyProvTrigger>が付いている場合、アプリケーションはすでに利用可能なADを（4.2.1項を参照）を持つことになります。このメッセージは、<KeyProvTrigger>が先行していなかった場合は、そのアプリケーションはおそらく手動でのみテンキーとデバイス上で、例えば自分の認証コードを入力するようにユーザを促すことにより、ユーザ認証コードを取得する必要があります。アプリケーションはまた、セクション3.4.1で説明したように、認証コードの認証データ（AD）を導出し、その次のメッセージで使用するためにそれを保存する必要があり、<KeyProvClientNonce>。"
    },
    {
      "indent": 3,
      "text": "What is contained in this message: The Security Attribute List (SAL) included with <KeyProvClientHello> contains the combinations of DSKPP versions, variants, key package formats, key types, and cryptographic algorithms that the DSKPP Client supports in order of the client's preference (favorite choice first).",
      "ja": "何このメッセージに含まれています。セキュリティは、リスト（SAL）は<KeyProvClientHello>に含まれる属性は、（DSKPPクライアントは、クライアントの好みの順でサポートされていることをDSKPPバージョン、バリアント、キーパッケージフォーマット、キータイプ、および暗号化アルゴリズムの組み合わせが含まれています最初のお気に入りの選択肢）。"
    },
    {
      "indent": 6,
      "text": "Authentication Data (AD) that was either included with <KeyProvTrigger>, or generated as described in the \"Application Note\" above.",
      "ja": "上記の「アプリケーションノート」に記載されているようにいずれか<KeyProvTrigger>に含まれ、または生成された認証データ（AD）。"
    },
    {
      "indent": 6,
      "text": "The DSKPP Client's random nonce (R_C), which was used by the client when generating AD. By inserting R_C into the DSKPP session, the DSKPP Client is able to ensure the DSKPP Server is live before committing the key.",
      "ja": "ADを生成するときに、クライアントが使用したDSKPPクライアントのランダムなナンス（R_C）、。 DSKPPセッションにR_Cを挿入することにより、DSKPP ClientはDSKPP Serverが鍵をコミットする前に、ライブであることを確認することができます。"
    },
    {
      "indent": 6,
      "text": "If <KeyProvClientHello> was preceded by a <KeyProvTrigger>, then this message MUST also include the DeviceID and/or KeyID that was provided with the trigger. Otherwise, if a trigger message did not precede <KeyProvClientHello>, then this message MAY include a DeviceID that was pre-shared with the DSKPP Server, and MAY contain a key ID associated with a key previously provisioned by the DSKPP provisioning server.",
      "ja": "<KeyProvClientHello>が<KeyProvTrigger>が先行した場合、このメッセージは、トリガーを備えたデバイスID及び/又はKeyIDをを含まなければなりません。トリガメッセージは、<KeyProvClientHello>先行していなかった場合はそうでない場合は、このメッセージがDSKPPサーバーで事前共有されたデバイスIDを含むことができ、以前DSKPPプロビジョニングサーバーによってプロビジョニングキーに関連付けられたキーIDを含むかもしれません。"
    },
    {
      "indent": 6,
      "text": "The list of key protection methods (KPML) that the DSKPP Client supports. Each item in the list MAY include an encryption key \"payload\" for the DSKPP Server to use to protect keying material that it sends back to the client. The payload MUST be of type <ds:KeyInfoType> ([XMLDSIG]). For each key protection method, the allowable choices for <ds:KeyInfoType> are:",
      "ja": "DSKPPクライアントがサポートするキーの保護方法（KPML）のリスト。リストの各項目は、DSKPP Serverがクライアントに送り返す鍵材料を保護するために使用するための暗号鍵「ペイロード」を含むことができます。ペイロードは<DS：KeyInfoType>型でなければならない（[XMLDSIG]）。各キーの保護方法については、<DS：KeyInfoType>の許容選択肢は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* Key Transport Only those choices of <ds:KeyInfoType> that identify a public key (i.e., <ds:KeyName>, <ds:KeyValue>, <ds:X509Data>, or <ds: PGPData>). The <ds:X509Certificate> option of the <ds: X509Data> alternative is RECOMMENDED when the public key corresponding to the private key on the cryptographic module has been certified.",
      "ja": "*の主要交通機関のみが選択肢：公開鍵を識別する<dsのKeyInfoType>（すなわち、<DS：キー名>：<DS：X509Data>、<です。KeyValue DS>、または<DS：PGPData>）。 <DS：のX509Certificate> <DS：X509Data>のオプション暗号モジュール上の秘密鍵に対応する公開鍵が認証されていたときに、代替をお勧めします。"
    },
    {
      "indent": 6,
      "text": "* Key Wrap Only those choices of <ds:KeyInfoType> that identify a symmetric key (i.e., <ds:KeyName> and <ds:KeyValue>). The <ds: KeyName> alternative is RECOMMENDED.",
      "ja": "* <DS：KeyInfoType>のキーラップのみが選択肢対称鍵を識別（すなわち、<DSを：キー名>と<DS：です。KeyValue>）。 <DS：キー名>の代替をお勧めします。"
    },
    {
      "indent": 6,
      "text": "* Passphrase-Based Key Wrap The <ds:KeyName> option MUST be used and the key name MUST identify the passphrase that will be used by the server to generate the key wrapping key. The identifier and passphrase components of <ds:KeyName> MUST be set to the Client ID and Authentication Code components of AD (same AD as contained in this message).",
      "ja": "*パスフレーズベースのキーラップザ・<DS：キー名>オプションを使用しなければなりませんし、キー名は、キーラッピングキーを生成するためにサーバによって使用されるパスフレーズを特定しなければなりません。識別子とパスフレーズ成分<DS：キー名>はADのクライアントIDおよび認証コード・コンポーネント（このメッセージに含まれるのと同じAD）に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "How the DSKPP Server uses this message: The DSKPP Server will look for an acceptable combination of DSKPP version, variant (in this case, two-pass), key package format, key type, and cryptographic algorithms. If the DSKPP Client's SAL does not match the capabilities of the DSKPP Server, or does not comply with key provisioning policy, then the DSKPP Server will set the Status attribute to something other than \"Success\". Otherwise, the Status attribute will be set to \"Success\".",
      "ja": "DSKPP Serverは、このメッセージをどのように使用するか：DSKPP Serverは、（この場合は、2パス）DSKPPバージョン、バリアント、キーパッケージ形式、キータイプ、および暗号化アルゴリズムの許容可能な組み合わせを探します。 DSKPPクライアントのSALがDSKPP Serverの機能と一致していない、またはキープロビジョニング・ポリシーに準拠していない場合は、DSKPP Serverは「成功」以外の何かにステータス属性を設定します。それ以外の場合は、ステータス属性が「成功」に設定されます。"
    },
    {
      "indent": 6,
      "text": "The DSKPP Server will validate the DeviceID and KeyID if included in <KeyProvClientHello>. The DSKPP Server MUST NOT accept the DeviceID unless the server sent the DeviceID in a preceding trigger message. Note that it is also legitimate for a DSKPP Client to initiate the DSKPP run without having received a <KeyProvTrigger> message from a server, but in this case any provided DeviceID MUST NOT be accepted by the DSKPP Server unless the server has access to a unique key for the identified device and that key will be used in the protocol.",
      "ja": "<KeyProvClientHello>に含まれている場合DSKPP Serverは、デバイスIDと鍵IDを検証します。サーバは、先行トリガメッセージにデバイスIDを送信しない限り、DSKPP Serverは、デバイスIDを受け入れてはいけません。 DSKPPクライアントがサーバから<KeyProvTrigger>メッセージを受信したことなく、DSKPPの実行を開始することも正当であることに注意してくださいが、サーバーがユニークにアクセスすることがない限り、このような場合には任意の提供デバイスIDはDSKPPサーバーで受け入れてはなりません識別されたデバイスとそのキーのキーは、プロトコルで使用されます。"
    },
    {
      "indent": 6,
      "text": "The DSKPP Server MUST use AD to authenticate the user. If authentication fails, then the DSKPP Server MUST set the return code to a failure status, and MUST, in this case, also delete any nonces, keys, and/or secrets associated with the failed run of the protocol.",
      "ja": "DSKPPサーバは、ユーザを認証するためにADを使用しなければなりません。認証が失敗した場合、DSKPPサーバーは、障害の状態に戻りコードを設定しなければなりません、そして、この場合には、また任意のナンス、キー、および/またはプロトコルの失敗実行に関連付けられた秘密を削除しなければなりません。"
    },
    {
      "indent": 6,
      "text": "If user authentication passes, the DSKPP Server generates a key K_PROV. In the two-pass case, wherein the client does not have access to R_S, K_PROV is randomly generated solely by the DSKPP Server wherein K_PROV MUST consist of two parts of equal length, i.e.,",
      "ja": "ユーザ認証に合格した場合、DSKPP Serverは、キーK_PROVを生成します。 K_PROVは等しい長さの2つの部分で構成する必要があり、前記2パスの場合に、前記クライアントがR_Sへのアクセスを持たない、K_PROVがランダムDSKPPサーバーによってのみ生成される、すなわち、"
    },
    {
      "indent": 9,
      "text": "K_PROV = K_MAC || K_TOKEN",
      "ja": "K_PROV = K_MAC || K_TOKEN"
    },
    {
      "indent": 6,
      "text": "The length of K_TOKEN (and hence also the length of K_MAC) is determined by the type of K_TOKEN, which MUST be one of the key types supported by the DSKPP Client. In cases where the desired key length for K_TOKEN is different from the length of K_MAC for the underlying MAC algorithm, the greater length of the two MUST be chosen to generate K_PROV. The actual MAC key is truncated from the resulting K_MAC when it is used in the MAC algorithm when K_MAC is longer than necessary in order to match the desired K_TOKEN length. If K_TOKEN is longer than needed in order to match the K_MAC length, the provisioning server and the receiving client must determine the actual secret key length from the target key algorithm and store only the truncated portion of the K_TOKEN. The truncation MUST take the beginning bytes of the desired length from K_TOKEN or K_MAC for the actual key. For example, when a provisioning server provisions an event based HOTP secret key with length 20 and MAC algorithm DSKPP-PRF-SHA256 (Appendix D), K_PROV length will be 64. The derived K_TOKEN and K_MAC will each consist of 32 bytes. The actual HOTP key should be the first 20 bytes of the K_TOKEN.",
      "ja": "（従っても及びK_MACの長さ）K_TOKENの長さはDSKPPクライアントによってサポートされるキーの種類のいずれかである必要がありK_TOKENの種類によって決定されます。 K_TOKENための所望のキーの長さは、基礎となるMACアルゴリズムのK_MACの長さと異なっている場合では、二つの大きな長さがK_PROVを生成するように選択されなければなりません。実際のMAC鍵はK_MACが所望K_TOKEN長さを一致させるために必要以上に長くなる場合には、MACアルゴリズムで使用され得K_MACから切り捨てられます。 K_TOKENがK_MAC長を一致させるために必要なより長い場合、プロビジョニング・サーバーと受信クライアントがターゲット鍵アルゴリズムから実際の秘密鍵の長さを決定し、K_TOKENの唯一の切り捨て部分を格納する必要があります。トランケーションは、実際のキーのK_TOKEN又はK_MACから所望の長さの開始バイトを取らなければなりません。例えば、プロビジョニング・サーバーの規定長さ20およびMACアルゴリズムDSKPP-PRF-SHA256（付録D）とイベントベースのHOTP秘密鍵、K_PROV長が64由来K_TOKENとK_MACはそれぞれ32バイトから構成されることになるであろう。実際のHOTPキーはK_TOKENの最初の20バイトでなければなりません。"
    },
    {
      "indent": 6,
      "text": "Once K_PROV is computed, the DSKPP Server selects one of the key protection methods from the DSKPP Client's KPML, and uses that method and corresponding payload to encrypt K_PROV. The DSKPP Server generates a key package to transport the key encryption method information and the encrypted provisioning key (K_PROV). The encrypted data format is subject to the choice supported by the selected key package. The key package MUST specify and use the selected key protection method and the key information that was received in <KeyProvClientHello>. The key package also includes key usage attributes such as expiry date and length. The server stores the key package and K_TOKEN with a user account on the cryptographic server.",
      "ja": "K_PROVが計算されると、DSKPP ServerはDSKPPクライアントのKPMLからキーの保護方法のいずれかを選択し、K_PROVを暗号化するために、そのメソッドと対応するペイロードを使用しています。 DSKPP Serverが鍵暗号方式情報と暗号化されたプロビジョニングキー（K_PROV）を輸送するためのキーパッケージを生成します。暗号化されたデータの形式は、選択したキーパッケージでサポートされている選択肢の対象となります。キーパッケージは、選択したキーの保護方法および<KeyProvClientHello>で受信したキー情報を指定して使用しなければなりません。キーパッケージはまた、有効期限や長さなどの主要な使用属性を含んでいます。サーバは暗号サーバ上のユーザアカウントとキーパッケージとK_TOKENを格納します。"
    },
    {
      "indent": 6,
      "text": "The server generates a MAC for key confirmation, which the client will use to avoid a false \"Commit\" message that would cause the cryptographic module to end up in state in which the server does not recognize the stored key.",
      "ja": "サーバーは、クライアントが暗号モジュールは、サーバが格納されたキーを認識していない状態で終わるさせるような偽の「コミット」メッセージを回避するために使用するキーの確認のためにMACを生成します。"
    },
    {
      "indent": 6,
      "text": "In addition, if an existing key is being renewed, the server generates a second MAC that it will return to the client as server Authentication Data (AD) so that the DSKPP Client can confirm that the replacement key came from a trusted server.",
      "ja": "また、既存のキーが更新されている場合、サーバはクライアントがDSKPP交換キーが信頼できるサーバから来たことを確認できるように、それは、サーバー認証データ（AD）としてクライアントに返すことを第2のMACを生成します。"
    },
    {
      "indent": 3,
      "text": "The method the DSKPP Server MUST use to calculate the key confirmation MAC:",
      "ja": "この方法は、DSKPP Serverが鍵確認MACを計算するために使用しなければなりません："
    },
    {
      "indent": 6,
      "text": "msg_hash = SHA-256(msg_1, ..., msg_n)",
      "ja": "msg_hash = SHA-256（msg_1、...、msg_n）"
    },
    {
      "indent": 6,
      "text": "dsLen = len(msg_hash)",
      "ja": "dsLen = LEN（msg_hash）"
    },
    {
      "indent": 6,
      "text": "MAC = DSKPP-PRF (K_MAC, \"MAC 1 computation\" || msg_hash || ServerID, dsLen)",
      "ja": "MAC = DSKPP-PRF（K_MAC、 \"MAC 1演算\" || || msg_hashのServerID、dsLen）"
    },
    {
      "indent": 6,
      "text": "where",
      "ja": "どこ"
    },
    {
      "indent": 6,
      "text": "MAC The MAC MUST be calculated using the already established MAC algorithm and MUST be computed on the (ASCII) string \"MAC 1 computation\", msg_hash, and ServerID using the existing MAC key K_MAC.",
      "ja": "MACザMACは、既に確立されたMACアルゴリズムを使用して計算しなければならなくて、既存のMAC鍵K_MACを使用して（ASCII）文字列「MAC 1演算」、msg_hash、及びサーバIDに基づいて計算されなければなりません。"
    },
    {
      "indent": 6,
      "text": "K_MAC The key that is derived from K_PROV, which the DSKPP Server MUST provide to the cryptographic module.",
      "ja": "K_MAC DSKPP Serverは、暗号モジュールに提供しなければならないK_PROVに由来するキー。"
    },
    {
      "indent": 6,
      "text": "msg_hash The message hash, defined in Section 3.4.3, of messages msg_1, ..., msg_n.",
      "ja": "メッセージmsg_1、...、msg_nの3.4.3項で定義されたメッセージのハッシュを、msg_hash。"
    },
    {
      "indent": 6,
      "text": "ServerID The identifier that the DSKPP Server MUST include in the <KeyPackage> element of <KeyProvServerFinished>.",
      "ja": "DSKPPサーバーは<KeyProvServerFinished>の<KeyPackage>要素に含める必要が識別子をSERVERID。"
    },
    {
      "indent": 6,
      "text": "If DSKPP-PRF (defined in Section 3.4.2) is used as the MAC algorithm, then the input parameter s MUST consist of the concatenation of the (ASCII) string \"MAC 1 computation\", msg_hash, and ServerID, and the parameter dsLen MUST be set to the length of msg_hash.",
      "ja": "（セクション3.4.2で定義された）DSKPP-PRFがMACアルゴリズムとして使用される場合、入力パラメータsは（ASCII）文字列「MAC 1演算」、msg_hash、及びサーバID、およびパラメータdsLenの連結で構成する必要がありますmsg_hashの長さに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The method the DSKPP Server MUST use to calculate the server authentication MAC:",
      "ja": "この方法は、DSKPP Serverは、サーバー認証MACを計算するために使用しなければなりません："
    },
    {
      "indent": 6,
      "text": "The MAC MUST be computed on the (ASCII) string \"MAC 2 computation\", the server identifier ServerID, and R, using a pre-existing MAC key K_MAC' (the MAC key that existed before this protocol run). Note that the implementation may specify K_MAC' to be the value of the K_TOKEN that is being replaced.",
      "ja": "MACは、既存のMAC鍵K_MAC」（このプロトコルの実行前に存在MAC鍵）を使用して、（ASCII）文字列「MAC 2演算」、サーバ識別子のServerID、及びRで計算されなければなりません。実装は置換されているK_TOKENの値にK_MAC」を指定することができることに留意されたいです。"
    },
    {
      "indent": 6,
      "text": "If DSKPP-PRF is used as the MAC algorithm, then the input parameter s MUST consist of the concatenation of the (ASCII) string \"MAC 2 computation\" ServerID, and R. The parameter dsLen MUST be set to at least 16 (i.e., the length of the MAC MUST be at least 16 octets):",
      "ja": "DSKPP-PRFがMACアルゴリズムとして使用される場合、入力パラメータsは（ASCII）文字列の連結で構成する必要があり、「MAC 2の計算」のServerID、及びR. dsLenは、少なくとも16（すなわち、に設定しなければならないパラメータMACの長さ）は、少なくとも16オクテットでなければなりません。"
    },
    {
      "indent": 6,
      "text": "dsLen >= 16",
      "ja": "dsLen> = 16"
    },
    {
      "indent": 6,
      "text": "MAC = DSKPP-PRF (K_MAC', \"MAC 2 computation\" || ServerID || R, dsLen)",
      "ja": "MAC = DSKPP-PRF（K_MAC」、 \"MAC 2演算\" ||サーバID || R、dsLen）"
    },
    {
      "indent": 6,
      "text": "The MAC algorithm MUST be the same as the algorithm used by the DSKPP Server to calculate the key confirmation MAC.",
      "ja": "MACアルゴリズムは、鍵確認MACを計算するDSKPP Serverで使用されるアルゴリズムと同じでなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.3. KeyProvServerFinished",
      "section_title": true,
      "ja": "5.2.3。 KeyProvServerFinished"
    },
    {
      "indent": 10,
      "text": "DSKPP Client                         DSKPP Server\n ------------                         ------------\n                        <---           KP, MAC, AD",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When this message is sent: The DSKPP Server will send this message after authenticating the user and, if authentication passed, generating K_TOKEN and a key package, and associating them with the user's account on the cryptographic server.",
      "ja": "このメッセージが送信されると：DSKPP Serverは、ユーザーを認証し、認証が渡された場合、K_TOKENとキーパッケージを生成し、暗号サーバ上のユーザのアカウントでそれらを関連付けた後、このメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "Purpose of this message: With this message, the DSKPP Server transports a key package containing the encrypted provisioning key (K_PROV) and key usage attributes.",
      "ja": "このメッセージの目的：このメッセージでは、DSKPP Serverは、暗号化されたプロビジョニング・キー（K_PROV）とキー使用属性を含むキーパッケージを転送します。"
    },
    {
      "indent": 3,
      "text": "What is contained in this message: A Status attribute equivalent to the server's return code to <KeyProvClientHello>. If the server found an acceptable set of attributes from the client's SAL, then it sets Status to \"Success\".",
      "ja": "このメッセージに含まれるもの：ステータスが<KeyProvClientHello>に、サーバーのリターンコードと同等の属性。サーバーがクライアントのSALから属性の許容セットを見つけた場合、それは「成功」へのステータスを設定します。"
    },
    {
      "indent": 6,
      "text": "The confirmation message MUST include the Key Package (KP) that holds the DSKPP Server's ID, key ID, key type, encrypted provisioning key (K_PROV), encryption method, and additional configuration information. The default symmetric key package format MUST be based on the Portable Symmetric Key Container (PSKC) defined in [RFC6030]. Alternative formats MAY include [RFC6031], PKCS #12 [PKCS-12], or PKCS #5 XML [PKCS-5-XML].",
      "ja": "確認メッセージがDSKPPサーバーのIDを保持しているキーパッケージ（KP）、キーID、キータイプ、暗号化されたプロビジョニング・キー（K_PROV）、暗号化方式、および追加の設定情報を含まなければなりません。デフォルト対称鍵パッケージ形式は、[RFC6030]で定義されたポータブル対称キーコンテナ（PSKC）に基づいていなければなりません。代替フォーマットは、[RFC6031]、PKCS＃12 [PKCS-12]、またはPKCS＃5 XML [PKCS-5-XML]を含むかもしれません。"
    },
    {
      "indent": 6,
      "text": "This message MUST include a MAC that the DSKPP Client will use for key confirmation. This key confirmation MAC is calculated using the \"MAC 1 computation\" as described in the previous section.",
      "ja": "このメッセージは、DSKPPクライアントがキーの確認に使用するMACを含まなければなりません。前のセクションで説明したように、このキー確認MACは、「MAC 1演算」を用いて計算されます。"
    },
    {
      "indent": 6,
      "text": "Finally, if an existing key is being replaced, then this message MUST also include a server authentication MAC (calculated using the \"MAC 2 computation\" as described in the previous section), which is passed as AD to the DSKPP Client.",
      "ja": "既存のキーが交換されている場合、最終的に、このメッセージは、DSKPPクライアントにADとして渡され（前のセクションで説明したように、「MAC 2演算」を用いて計算された）サーバー認証MACを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "How the DSKPP Client uses this message: After receiving a <KeyProvServerFinished> message with Status = \"Success\", the DSKPP Client MUST verify both MACs (MAC and AD). The DSKPP Client MUST terminate the DSKPP run if either MAC does not verify, and MUST, in this case, also delete any nonces, keys, and/or secrets associated with the failed run of the protocol.",
      "ja": "DSKPPクライアントは、このメッセージを使用する方法：ステータス=「成功」で<KeyProvServerFinished>メッセージを受信した後、DSKPPクライアントは両方のMAC（MACおよびAD）を確かめなければなりません。 DSKPPクライアントは、いずれかのMACは検証しない場合DSKPPが実行終えなければなりません、そして、この場合には、また任意のナンス、キー、および/またはプロトコルの失敗実行に関連付けられた秘密を削除しなければなりません。"
    },
    {
      "indent": 6,
      "text": "If <KeyProvServerFinished> has Status = \"Success\" and the MACs were verified, then the DSKPP Client MUST extract K_PROV from the provided key package, and derive K_TOKEN. Finally, the DSKPP Client initializes the cryptographic module with K_TOKEN and the corresponding key usage attributes. After this operation, it MUST NOT be possible to overwrite the key unless knowledge of an authorizing key is proven through a MAC on a later <KeyProvServerFinished> message.",
      "ja": "<KeyProvServerFinished>ステータス=「成功」とMacが確認されたた場合、DSKPPクライアントが提供するキーパッケージからK_PROVを抽出し、K_TOKENを導出しなければなりません。最後に、DSKPPクライアントはK_TOKENと対応するキー使用属性を持つ暗号モジュールを初期化します。この操作の後は、認可キーの知識は、後に<KeyProvServerFinished>メッセージにMACによって証明されない限り、キーを上書きすることも可能にすることはできません。"
    },
    {
      "indent": 0,
      "text": "6. Protocol Extensions",
      "section_title": true,
      "ja": "6.プロトコル拡張"
    },
    {
      "indent": 3,
      "text": "DSKPP has been designed to be extensible. The sub-sections below define two extensions that are included with the DSKPP schema. Since it is possible that the use of extensions will harm interoperability, protocol designers are advised to carefully consider the use of extensions. For example, if a particular implementation relies on the presence of a proprietary extension, then it may not be able to interoperate with independent implementations that have no knowledge of this extension.",
      "ja": "DSKPPは拡張できるように設計されています。以下のサブセクションではDSKPPスキーマに含まれている2つの拡張を定義します。それは拡張の使用は相互運用性を害するなる可能性があるので、プロトコル設計者は、慎重に拡張の使用を検討することをお勧めします。特定の実装では、独自拡張の存在に依存している場合、例えば、この拡張の知識を持たない独立した実装と相互運用することができないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Extensions may be sent with any DSKPP message using the ExtensionsType. The ExtensionsType type is a list of Extensions containing type-value pairs that define optional features supported by a DSKPP Client or server. Each extension MAY be marked as Critical by setting the Critical attribute of the Extension to \"true\". Unless an extension is marked as Critical, a receiving party need not be able to interpret it; a receiving party is always free to disregard any (non-critical) extensions.",
      "ja": "拡張機能はExtensionsTypeを使用して、任意のDSKPPメッセージを送ることができます。 ExtensionsTypeタイプはDSKPPクライアントまたはサーバーでサポートされているオプション機能を定義するタイプと値のペアを含む拡張機能のリストです。各拡張子は「真」への拡張の重要な属性を設定することにより、クリティカルとしてマークされることがあります。拡張子がクリティカルとしてマークされていない限り、受信側はそれを解釈することはできません必要があります。受信側は常に（非重要）の拡張機能を無視して自由です。"
    },
    {
      "indent": 0,
      "text": "6.1. The ClientInfoType Extension",
      "section_title": true,
      "ja": "6.1。 ClientInfoType拡張"
    },
    {
      "indent": 3,
      "text": "The ClientInfoType extension MAY contain any client-specific data required of an application. This extension MAY be present in a <KeyProvClientHello> or <KeyProvClientNonce> message. When present, this extension MUST NOT be marked as Critical.",
      "ja": "ClientInfoType拡張は、アプリケーションに必要なすべてのクライアント固有のデータを含むかもしれません。この拡張は、<KeyProvClientHello>または<KeyProvClientNonce>メッセージ中に存在してもよいです。存在する場合、この拡張機能は、クリティカルとしてマークされてはなりません。"
    },
    {
      "indent": 3,
      "text": "DSKPP Servers MUST support this extension. DSKPP Servers MUST NOT attempt to interpret the data it carries and, if received, MUST include it unmodified in the current protocol run's next server response. DSKPP Servers need not retain the ClientInfoType data.",
      "ja": "DSKPPサーバーは、この拡張機能をサポートしなければなりません。 DSKPPサーバーは、受信した場合、それは、保持し、データを解釈することを試みてはいけません、現在のプロトコルの実行の次のサーバ応答に変更されていないことを含まなければなりません。 DSKPPサーバーはClientInfoTypeデータを保持する必要はありません。"
    },
    {
      "indent": 0,
      "text": "6.2. The ServerInfoType Extension",
      "section_title": true,
      "ja": "6.2。 ServerInfoType拡張"
    },
    {
      "indent": 3,
      "text": "The ServerInfoType extension MAY contain any server-specific data required of an application, e.g., state information. This extension is only valid in <KeyProvServerHello> messages for which the Status attribute is set to \"Continue\". When present, this extension MUST NOT be marked as Critical.",
      "ja": "ServerInfoType拡張は、アプリケーション、例えば、状態情報の必要なサーバー固有のデータを含むことができます。この拡張は、ステータス属性は「続行」に設定されている<KeyProvServerHello>メッセージでのみ有効です。存在する場合、この拡張機能は、クリティカルとしてマークされてはなりません。"
    },
    {
      "indent": 3,
      "text": "DSKPP Clients MUST support this extension. DSKPP Clients MUST NOT attempt to interpret the data it carries and, if received, MUST include it unmodified in the current protocol run's next client request (i.e., the <KeyProvClientNonce> message). DSKPP Clients need not retain the ServerInfoType data.",
      "ja": "DSKPPクライアントは、この拡張機能をサポートしなければなりません。 DSKPPクライアントは、それが運ぶと、受け取った場合、現在のプロトコルの実行の次のクライアント要求（すなわち、<KeyProvClientNonce>メッセージ）で、それがそのまま含まなければならないデータを解釈することを試みてはいけません。 DSKPPクライアントがServerInfoTypeデータを保持する必要はありません。"
    },
    {
      "indent": 0,
      "text": "7. Protocol Bindings",
      "section_title": true,
      "ja": "7.プロトコルバインディング"
    },
    {
      "indent": 0,
      "text": "7.1. General Requirements",
      "section_title": true,
      "ja": "7.1。一般要件"
    },
    {
      "indent": 3,
      "text": "DSKPP assumes a reliable transport.",
      "ja": "DSKPPは、信頼性の高い輸送を想定しています。"
    },
    {
      "indent": 0,
      "text": "7.2. HTTP/1.1 Binding for DSKPP",
      "section_title": true,
      "ja": "7.2。 DSKPPのバインディングHTTP / 1.1"
    },
    {
      "indent": 3,
      "text": "This section presents a binding of the previous messages to HTTP/1.1 [RFC2616]. This HTTP binding is mandatory to implement, although newer versions of the specification might define additional bindings in the future. Note that the HTTP client will normally be different from the DSKPP Client (i.e., the HTTP client will \"proxy\" DSKPP messages from the DSKPP Client to the DSKPP Server). Likewise, on the HTTP server side, the DSKPP Server MAY receive DSKPP message from a \"front-end\" HTTP server. The DSKPP Server will be identified by a specific URL, which may be pre-configured, or provided to the client during initialization.",
      "ja": "このセクションでは、HTTP / 1.1 [RFC2616]へ前のメッセージの結合を提示します。仕様の新しいバージョンは、将来的に追加のバインディングを定義するかもしれませんが、このHTTPバインディングは、実装が必須です。 HTTPクライアントは通常DSKPPクライアント（DSKPPクライアントからサーバへのDSKPPつまり、HTTPクライアントがします「プロキシ」DSKPPメッセージ）とは異なることに注意してください。同様に、HTTPサーバ側で、DSKPP Serverは、「フロントエンド」HTTPサーバーからDSKPPメッセージを受け取ることができます。 DSKPP Serverは、事前に構成することができる特定のURLによって識別される、または初期化中に、クライアントに提供されます。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Identification of DSKPP Messages",
      "section_title": true,
      "ja": "7.2.1。 DSKPPメッセージの識別"
    },
    {
      "indent": 3,
      "text": "The MIME type for all DSKPP messages MUST be",
      "ja": "すべてDSKPPメッセージのMIMEタイプでなければなりません"
    },
    {
      "indent": 3,
      "text": "application/dskpp+xml",
      "ja": "アプリケーション/ dskpp + xmlの"
    },
    {
      "indent": 0,
      "text": "7.2.2. HTTP Headers",
      "section_title": true,
      "ja": "7.2.2。 HTTPヘッダ"
    },
    {
      "indent": 3,
      "text": "In order to avoid caching of responses carrying DSKPP messages by proxies, the following holds:",
      "ja": "プロキシによってDSKPPメッセージを運ぶ応答のキャッシュを避けるためには、以下が成り立ちます："
    },
    {
      "indent": 3,
      "text": "o When using HTTP/1.1, requesters SHOULD: * Include a Cache-Control header field set to \"no-cache, no-store\". * Include a Pragma header field set to \"no-cache\".",
      "ja": "HTTP / 1.1を使用する場合は、O、依頼者は、必要があります：*へのCache-Controlヘッダフィールドセット \"キャッシュなし、無店舗\" が挙げられます。 *は、「キャッシュなし」に設定されたPragmaヘッダフィールドを含めます。"
    },
    {
      "indent": 3,
      "text": "o When using HTTP/1.1, responders SHOULD: * Include a Cache-Control header field set to \"no-cache, no-must-revalidate, private\". * Include a Pragma header field set to \"no-cache\". * NOT include a Validator, such as a Last-Modified or ETag header.",
      "ja": "HTTP / 1.1を使用する場合は、O、レスポンダは、必要があります：*に設定Cache-Controlヘッダフィールドを含める \"キャッシュなしに、民間無-再検証する必要がありません\"。 *は、「キャッシュなし」に設定されたPragmaヘッダフィールドを含めます。 *このよう-最終更新日やETagのヘッダとしてバリデータは含まれませ。"
    },
    {
      "indent": 3,
      "text": "To handle content negotiation, HTTP requests MAY include an HTTP Accept header field. This header field SHOULD should be identified using the MIME type specified in Section 7.2.1. The Accept header MAY include additional content types defined by future versions of this protocol.",
      "ja": "コンテンツネゴシエーションを処理するには、HTTPリクエストヘッダフィールドを受け入れるHTTPを含むかもしれません。このヘッダーフィールドはセクション7.2.1で指定されたMIMEタイプを使用して識別されるべきであるべきです。 Acceptヘッダーは、このプロトコルの将来のバージョンによって定義された追加コンテンツタイプを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "There are no other restrictions on HTTP headers, besides the requirement to set the Content-Type header value to the MIME type specified in Section 7.2.1.",
      "ja": "HTTPヘッダには他の制限は、セクション7.2.1で指定されたMIMEタイプにContent-Typeヘッダの値を設定するための要件のほかに、ありません。"
    },
    {
      "indent": 0,
      "text": "7.2.3. HTTP Operations",
      "section_title": true,
      "ja": "7.2.3。 HTTP操作"
    },
    {
      "indent": 3,
      "text": "Persistent connections as defined in HTTP/1.1 are OPTIONAL. DSKPP requests are mapped to HTTP requests with the POST method. DSKPP responses are mapped to HTTP responses.",
      "ja": "HTTP / 1.1で定義された持続的接続はオプションです。 DSKPP要求は、POSTメソッドでHTTPリクエストにマッピングされます。 DSKPP応答は、HTTPレスポンスにマッピングされます。"
    },
    {
      "indent": 3,
      "text": "For the four-pass DSKPP, messages within the protocol run are bound together. In particular, <KeyProvServerHello> is bound to the preceding <KeyProvClientHello> by being transmitted in the corresponding HTTP response. <KeyProvServerHello> MUST have a SessionID attribute, and the SessionID attribute of the subsequent <KeyProvClientNonce> message MUST be identical. <KeyProvServerFinished> is then once again bound to the rest through HTTP (and possibly through a SessionID).",
      "ja": "4パスDSKPPのために、プロトコルの実行中のメッセージが一緒にバインドされています。特に、<KeyProvServerHello>対応するHTTP応答して送信されることによって先行<KeyProvClientHello>に結合されます。 <KeyProvServerHello>セッションID属性を持たなければならない、そしてそれに続く<KeyProvClientNonce>メッセージのセッションID属性は同一でなければなりません。 <KeyProvServerFinished>もう一度HTTP経由（そしておそらくセッションIDを介して）残りの部分にバインドされています。"
    },
    {
      "indent": 0,
      "text": "7.2.4. HTTP Status Codes",
      "section_title": true,
      "ja": "7.2.4。 HTTPステータスコード"
    },
    {
      "indent": 3,
      "text": "A DSKPP HTTP responder that refuses to perform a message exchange with a DSKPP HTTP requester SHOULD return a 403 (Forbidden) response. In this case, the content of the HTTP body is not significant. In the case of an HTTP error while processing a DSKPP request, the HTTP server MUST return a 500 (Internal Server Error) response. This type of error SHOULD be returned for HTTP-related errors detected before control is passed to the DSKPP processor, or when the DSKPP processor reports an internal error (for example, the DSKPP XML namespace is incorrect, or the DSKPP schema cannot be located). If a request is received that is not a DSKPP Client message, the DSKPP responder MUST return a 400 (Bad request) response.",
      "ja": "DSKPP HTTP要求者とメッセージ交換を行うことを拒否DSKPP HTTPレスポンダ403（禁止）応答を返すべきです。この場合、HTTP本体の内容は重要ではありません。 DSKPP要求の処理中にHTTPエラーの場合には、HTTPサーバ500（内部サーバーエラー）応答を返さなければなりません。 DSKPPプロセッサが内部エラーを報告するとき、エラーこのタイプの制御はDSKPPプロセッサに渡される前に検出されたHTTP関連のエラーが返されるべきであり、または（例えば、DSKPPのXML名前空間は間違っている、またはDSKPPスキーマを配置することができません） 。リクエストがDSKPPクライアントのメッセージではありませんが受信される場合は、DSKPP応答者は400（不正なリクエスト）応答を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "In these cases (i.e., when the HTTP response code is 4xx or 5xx), the content of the HTTP body is not significant.",
      "ja": "（HTTP応答コードが4XXまたは5xxのとき、すなわち、）これらのケースでは、HTTPボディの内容は重要ではありません。"
    },
    {
      "indent": 3,
      "text": "Redirection status codes (3xx) apply as usual.",
      "ja": "リダイレクションステータスコード（300番台）いつものように適用されます。"
    },
    {
      "indent": 3,
      "text": "Whenever the HTTP POST is successfully invoked, the DSKPP HTTP responder MUST use the 200 status code and provide a suitable DSKPP message (possibly with DSKPP error information included) in the HTTP body.",
      "ja": "HTTP POSTが正常に呼び出されるたびに、DSKPP HTTPの応答は、HTTPボディに（DSKPPエラー情報が含まれる可能性を有する）200のステータスコードを使用して、適切なDSKPPメッセージを提供しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.2.5. HTTP Authentication",
      "section_title": true,
      "ja": "7.2.5。 HTTP認証"
    },
    {
      "indent": 3,
      "text": "No support for HTTP/1.1 authentication is assumed.",
      "ja": "HTTP / 1.1の認証を想定してはサポートされていません。"
    },
    {
      "indent": 0,
      "text": "7.2.6. Initialization of DSKPP",
      "section_title": true,
      "ja": "7.2.6。 DSKPPの初期化"
    },
    {
      "indent": 3,
      "text": "If a user requests key initialization in a browsing session, and if that request has an appropriate Accept header (e.g., to a specific DSKPP Server URL), the DSKPP Server MAY respond by sending a DSKPP initialization message in an HTTP response with Content-Type set according to Section 7.2.1 and response code set to 200 (OK). The initialization message MAY carry data in its body, such as the URL for the DSKPP Client to use when contacting the DSKPP Server. If the message does carry data, the data MUST be a valid instance of a <KeyProvTrigger> element.",
      "ja": "ブラウジングセッションにおけるユーザーの要求キー初期化する場合、その要求は（例えば、特定のDSKPPサーバーのURLに）ヘッダを受け入れ、適切なを持っている場合、DSKPP Serverは、コンテンツタイプとHTTP応答にDSKPP初期化メッセージを送信することによって応答することができます第7.2.1項及び200（OK）に設定された応答コードに応じて設定。初期化メッセージは、このようなDSKPP Serverに接続するときDSKPPクライアントが使用するURLとしてその本体内のデータを、運ぶことができます。メッセージは、データを運ぶない場合、データは<KeyProvTrigger>要素の有効なインスタンスでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that if the user's request was directed to some other resource, the DSKPP Server MUST NOT respond by combining the DSKPP content type with response code 200. In that case, the DSKPP Server SHOULD respond by sending a DSKPP initialization message in an HTTP response with Content-Type set according to Section 7.2.1 and response code set to 406 (Not Acceptable).",
      "ja": "ユーザの要求が他のリソースに向けられた場合、DSKPPサーバはその場合、レスポンスコード200とDSKPPコンテンツタイプを組み合わせることによって、応答しない必要があります、DSKPP Serverが持つHTTPレスポンスにDSKPP初期化メッセージを送信することによって応答するべきですコンテンツタイプは406に設定し、セクション7.2.1および応答コード（許容できない）に応じて設定します。"
    },
    {
      "indent": 0,
      "text": "7.2.7. Example Messages",
      "section_title": true,
      "ja": "7.2.7。例のメッセージ"
    },
    {
      "indent": 3,
      "text": "a. Initialization from DSKPP Server: HTTP/1.1 200 OK",
      "ja": "A。 DSKPPサーバーからの初期化：HTTP / 1.1 200 OK"
    },
    {
      "indent": 7,
      "text": "Cache-Control: no-store\nContent-Type: application/dskpp+xml\nContent-Length: <some value>",
      "raw": true
    },
    {
      "indent": 7,
      "text": "DSKPP initialization data in XML form...",
      "ja": "XML形式でDSKPP初期化データ..."
    },
    {
      "indent": 3,
      "text": "b. Initial request from DSKPP Client: POST http://example.com/cgi-bin/DSKPP-server HTTP/1.1",
      "ja": "B。 DSKPPクライアントからの最初の要求：POST http://example.com/cgi-bin/DSKPP-server HTTP / 1.1"
    },
    {
      "indent": 7,
      "text": "Cache-Control: no-cache, no-store\nPragma: no-cache\nHost: www.example.com\nContent-Type: application/dskpp+xml\nContent-Length: <some value>",
      "raw": true
    },
    {
      "indent": 7,
      "text": "DSKPP data in XML form (supported version, supported algorithms...)",
      "ja": "XML形式でDSKPPデータ（サポートされているバージョン、サポートされているアルゴリズム...）"
    },
    {
      "indent": 3,
      "text": "c. Initial response from DSKPP Server: HTTP/1.1 200 OK",
      "ja": "C。 DSKPPサーバーからの初期応答：HTTP / 1.1 200 OK"
    },
    {
      "indent": 7,
      "text": "Cache-Control: no-cache, no-must-revalidate, private\nPragma: no-cache\nContent-Type: application/dskpp+xml\nContent-Length: <some value>",
      "raw": true
    },
    {
      "indent": 7,
      "text": "DSKPP data in XML form (server random nonce, server public key, ...)",
      "ja": "XML形式でDSKPPデータ（サーバーランダムナンス、サーバ公開鍵、...）"
    },
    {
      "indent": 0,
      "text": "8. DSKPP XML Schema",
      "section_title": true,
      "ja": "8. DSKPP XMLスキーマ"
    },
    {
      "indent": 0,
      "text": "8.1. General Processing Requirements",
      "section_title": true,
      "ja": "8.1。一般的な処理の要件"
    },
    {
      "indent": 3,
      "text": "Some DSKPP elements rely on the parties being able to compare received values with stored values. Unless otherwise noted, all elements that have the XML schema \"xs:string\" type, or a type derived from it, MUST be compared using an exact binary comparison. In particular, DSKPP implementations MUST NOT depend on case-insensitive string comparisons, normalization or trimming of white space, or conversion of locale-specific formats such as numbers.",
      "ja": "いくつかのDSKPP要素が格納された値で受け取った値を比較することができるという政党に依存しています。特に断りのない限り、XMLスキーマ「XS：string」は持っているすべての要素タイプ、又はそれから誘導されるタイプは、正確なバイナリ比較を用いて比較しなければなりません。特に、DSKPP実装は大文字と小文字を区別しない文字列比較、ホワイトスペースの正規化又はトリミング、又は数字などのロケール固有のフォーマットの変換に依存してはなりません。"
    },
    {
      "indent": 3,
      "text": "Implementations that compare values that are represented using different character encodings MUST use a comparison method that returns the same result as converting both values to the Unicode character encoding [UNICODE] and then performing an exact binary comparison.",
      "ja": "Unicode文字エンコーディングに[UNICODE]を両方の値を変換した後、正確なバイナリ比較を行うと同じ結果を返す比較方法を使用しなければならない異なる文字エンコーディングを使用して表現されている値を比較実装。"
    },
    {
      "indent": 3,
      "text": "No collation or sorting order for attributes or element values is defined. Therefore, DSKPP implementations MUST NOT depend on specific sorting orders for values.",
      "ja": "属性または要素値のための照合やソート順は定義されていません。したがって、DSKPP実装は、値のため、特定のソート順序に依存してはなりません。"
    },
    {
      "indent": 0,
      "text": "8.2. Schema",
      "section_title": true,
      "ja": "8.2。スキーマ"
    },
    {
      "indent": 4,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<xs:schema\n   xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n   xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n   xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n   xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n   targetNamespace=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n   elementFormDefault=\"qualified\" attributeFormDefault=\"unqualified\"\n      version=\"1.0\">\n   <xs:import namespace=\"http://www.w3.org/2000/09/xmldsig#\"\n      schemaLocation=\n      \"http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/\n      xmldsig-core-schema.xsd\"/>\n   <xs:import namespace=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n      schemaLocation=\"keyprov-pskc-1.0.xsd\"/>\n   <xs:complexType name=\"AbstractRequestType\" abstract=\"true\">\n      <xs:annotation>\n         <xs:documentation> Basic types </xs:documentation>\n      </xs:annotation>\n      <xs:attribute name=\"Version\" type=\"dskpp:VersionType\"\n         use=\"required\"/>\n   </xs:complexType>",
      "raw": true
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"AbstractResponseType\" abstract=\"true\"> <xs:annotation> <xs:documentation> Basic types </xs:documentation> </xs:annotation> <xs:attribute name=\"Version\" type=\"dskpp:VersionType\" use=\"required\"/> <xs:attribute name=\"SessionID\" type=\"dskpp:IdentifierType\" /> <xs:attribute name=\"Status\" type=\"dskpp:StatusCode\" use=\"required\"/> </xs:complexType>",
      "ja": "<XS：complexTypeの名前= \"AbstractResponseType\" 抽象= \"真\"> <XS：注釈> <XS：ドキュメント>ベーシックタイプ</ XS：ドキュメンテーション> </ XS：注釈> <XS：属性名= \"バージョン\" タイプ= \"dskpp：VersionType\" 使用= \"必要\" /> <XS：属性名= \"セッションID\" タイプ= \"dskpp：IdentifierType\" /> <XS：属性名= \"ステータス\" タイプ= \"dskpp：のStatusCode\" 使用= \"必要「/> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:simpleType name=\"VersionType\"> <xs:restriction base=\"xs:string\"> <xs:pattern value=\"\\d{1,2}\\.\\d{1,3}\" /> </xs:restriction> </xs:simpleType>",
      "ja": "<XS：単純型名= \"VersionType\"> <XS：制限ベース= \"XS：文字列\"> <XS：パターン値= \"\\ D {1,2} \\ \\ D {1,3}\" /> </ XS：制限> </ XS：単純>"
    },
    {
      "indent": 7,
      "text": "<xs:simpleType name=\"IdentifierType\"> <xs:restriction base=\"xs:string\"> <xs:maxLength value=\"128\" /> </xs:restriction> </xs:simpleType>",
      "ja": "<XS：単純型名= \"IdentifierType\"> <XS：制限ベース= \"XS：文字列\"> <XS：maxLengthの値= \"128\" /> </ XS：制限> </ XS：simpleTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:simpleType name=\"StatusCode\"> <xs:restriction base=\"xs:string\"> <xs:enumeration value=\"Continue\" /> <xs:enumeration value=\"Success\" /> <xs:enumeration value=\"Abort\" /> <xs:enumeration value=\"AccessDenied\" /> <xs:enumeration value=\"MalformedRequest\" /> <xs:enumeration value=\"UnknownRequest\" /> <xs:enumeration value=\"UnknownCriticalExtension\" /> <xs:enumeration value=\"UnsupportedVersion\" /> <xs:enumeration value=\"NoSupportedKeyTypes\" /> <xs:enumeration value=\"NoSupportedEncryptionAlgorithms\" /> <xs:enumeration value=\"NoSupportedMacAlgorithms\" /> <xs:enumeration value=\"NoProtocolVariants\" /> <xs:enumeration value=\"NoSupportedKeyPackages\" /> <xs:enumeration value=\"AuthenticationDataMissing\" /> <xs:enumeration value=\"AuthenticationDataInvalid\" /> <xs:enumeration value=\"InitializationFailed\" /> <xs:enumeration value=\"ProvisioningPeriodExpired\" /> </xs:restriction> </xs:simpleType>",
      "ja": "<XS：単純型名= \"のStatusCode\"> <XS：制限ベース= \"XS：文字列\"> <XS：列挙値= \"続行\" /> <XS：列挙値= \"成功\" /> <XS：列挙値= XS /> < \"中止\"：列挙値= \"アクセス拒否\" /> <XS：列挙値= \"MalformedRequest\" /> <XS：列挙値= \"UnknownRequest\" /> <XS：列挙値= \"UnknownCriticalExtension\" /> < XS：列挙値= \"UnsupportedVersion\" /> <XS：列挙値= \"NoSupportedKeyTypes\" /> <XS：列挙値= \"NoSupportedEncryptionAlgorithms\" /> <XS：列挙値= \"NoSupportedMacAlgorithms\" /> <XS：列挙値=」 NoProtocolVariants」/> <XS：列挙値= \"NoSupportedKeyPackages\" /> <XS：列挙値= \"AuthenticationDataMissing\" /> <XS：列挙値= \"AuthenticationDataInvalid\" /> <XS：列挙値= \"InitializationFailed\" /> <XS ：列挙値= \"ProvisioningPeriodExpired\" /> </ XS：制限> </ XS：simpleTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"DeviceIdentifierDataType\"> <xs:choice> <xs:element name=\"DeviceId\" type=\"pskc:DeviceInfoType\" /> <xs:any namespace=\"##other\" processContents=\"strict\" /> </xs:choice> </xs:complexType>",
      "ja": "<XS：complexTypeの名前= \"DeviceIdentifierDataType\"> <XS：選択> <XS：要素名= \"デバイスID\" タイプ= \"pskc：DeviceInfoType\" /> <XS：任意の名前空間= \"##他の\" = \"厳しい\" のprocessContents / > </ XS：選択> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:simpleType name=\"PlatformType\"> <xs:restriction base=\"xs:string\"> <xs:enumeration value=\"Hardware\" /> <xs:enumeration value=\"Software\" /> <xs:enumeration value=\"Unspecified\" /> </xs:restriction> </xs:simpleType>",
      "ja": "<XS：単純型名= \"PlatformType\"> <XS：制限ベース= \"XS：文字列\"> <XS：列挙値= \"ハードウェア\" /> <XS：列挙値= \"ソフトウェア\" /> <XS：列挙値= \"未指定\" /> </ XS：制限> </ XS：単純>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"TokenPlatformInfoType\"> <xs:attribute name=\"KeyLocation\" type=\"dskpp:PlatformType\"/> <xs:attribute name=\"AlgorithmLocation\" type=\"dskpp:PlatformType\"/> </xs:complexType>",
      "ja": "<XS：complexTypeの名前= \"TokenPlatformInfoType\"> <XS：属性名= \"KeyLocation\" タイプ= \"dskpp：PlatformType\" /> <XS：属性名= \"AlgorithmLocation\" タイプ= \"dskpp：PlatformType\" /> </ XS： complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:simpleType name=\"NonceType\"> <xs:restriction base=\"xs:base64Binary\"> <xs:minLength value=\"16\" /> </xs:restriction> </xs:simpleType>",
      "ja": "<XS：simpleTypeの名前= \"NonceType\"> <XS：制限ベース= \"XS：base64Binaryの\"> <XS：はminLength値= \"16\" /> </ XS：制限> </ XS：simpleTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"AlgorithmsType\"> <xs:sequence maxOccurs=\"unbounded\"> <xs:element name=\"Algorithm\" type=\"dskpp:AlgorithmType\"/> </xs:sequence> </xs:complexType>",
      "ja": "<XS：complexTypeの名前= \"AlgorithmsType\"> <XS：配列のmaxOccurs = \"無制限\"> <XS：要素名= \"アルゴリズム\" タイプ= \"dskpp：AlgorithmType\" /> </ XS：配列> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:simpleType name=\"AlgorithmType\"> <xs:restriction base=\"xs:anyURI\" /> </xs:simpleType>",
      "ja": "<XS：simpleTypeの名前= \"アルゴリズムタイプ\"> <XS：制限ベース= \"XS：anyURIの\" /> </のxsd：simpleTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"ProtocolVariantsType\"> <xs:sequence> <xs:element name=\"FourPass\" minOccurs=\"0\" /> <xs:element name=\"TwoPass\" type=\"dskpp:KeyProtectionDataType\" minOccurs=\"0\"/> </xs:sequence> </xs:complexType>",
      "ja": "<XS：complexTypeの名= \"ProtocolVariantsType\"> <XS：配列> <XS：要素名= \"FourPass\" のminOccurs = \"0\" /> <XS：要素名= \"2パス\" タイプ= \"dskpp：KeyProtectionDataType\" のminOccurs =」 0\" /> </ XS：シーケンス> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"KeyProtectionDataType\"> <xs:annotation> <xs:documentation xml:lang=\"en\"> This element is only valid for two-pass DSKPP. </xs:documentation> </xs:annotation> <xs:sequence maxOccurs=\"unbounded\"> <xs:element name=\"SupportedKeyProtectionMethod\" type=\"xs:anyURI\"/> <xs:element name=\"Payload\" type=\"dskpp:PayloadType\" minOccurs=\"0\"/> </xs:sequence> </xs:complexType>",
      "ja": "<XS：complexTypeの名= \"KeyProtectionDataType\"> <XS：注釈> <XS：ドキュメントのxml：langは= \"en\" が>この要素はDSKPPを2-パスに対してのみ有効です。 </ XS：ドキュメンテーション> </ XS：注釈> <XS：シーケンスのmaxOccurs = \"無制限\"> <XS：要素名= \"SupportedKeyProtectionMethod\" タイプ= \"XS：anyURIの\" /> <XS：要素名= \"ペイロード\" タイプ= \"dskpp：PayloadType\" のminOccurs = \"0\" /> </ XS：配列> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"PayloadType\"> <xs:choice> <xs:element name=\"Nonce\" type=\"dskpp:NonceType\" /> <xs:any namespace=\"##other\" processContents=\"strict\"/> </xs:choice> </xs:complexType>",
      "ja": "<XS：complexTypeの名前= \"PayloadType\"> <XS：選択> <XS：要素名= \"ナンス\" タイプ= \"dskpp：NonceType\" /> <XS：任意の名前空間= \"##他\" のprocessContents = \"厳しいです\" / > </ XS：選択> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"KeyPackagesFormatType\"> <xs:sequence maxOccurs=\"unbounded\"> <xs:element name=\"KeyPackageFormat\" type=\"dskpp:KeyPackageFormatType\"/> </xs:sequence> </xs:complexType>",
      "ja": "<XS：complexTypeの名= \"KeyPackagesFormatType\"> <XS：配列のmaxOccurs = \"無制限\"> <XS：要素名= \"KeyPackageFormat\" タイプ= \"dskpp：KeyPackageFormatType\" /> </ XS：配列> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:simpleType name=\"KeyPackageFormatType\"> <xs:restriction base=\"xs:anyURI\" /> </xs:simpleType>",
      "ja": "<XS：単純型名= \"KeyPackageFormatType\"> <XS：制限ベース= \"XS：anyURIの\" /> </ XS：simpleTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"AuthenticationDataType\"> <xs:annotation> <xs:documentation xml:lang=\"en\"> Authentication Data contains a MAC. </xs:documentation> </xs:annotation> <xs:sequence> <xs:element name=\"ClientID\" type=\"dskpp:IdentifierType\" minOccurs=\"0\"/> <xs:choice> <xs:element name=\"AuthenticationCodeMac\" type=\"dskpp:AuthenticationMacType\"/> <xs:any namespace=\"##other\" processContents=\"strict\" /> </xs:choice> </xs:sequence> </xs:complexType>",
      "ja": "<XS：complexTypeの名= \"AuthenticationDataType\"> <XS：注釈> <XS：ドキュメントのXML：LANG = \"EN\">認証データは、MACが含まれています。 </ XS：ドキュメンテーション> </ XS：注釈> <XS：シーケンス> <XS：要素名= \"クライアントID\" タイプ= \"dskpp：IdentifierType\" のminOccurs = \"0\" /> <XS：選択> <XS：要素名= \"AuthenticationCodeMac\" タイプ= \"dskpp：AuthenticationMacType\" /> <XS：任意の名前空間= \"##他\" のprocessContents = \"厳しい\" /> </ XS：選択> </ XS：シーケンス> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"AuthenticationMacType\"> <xs:sequence> <xs:element minOccurs=\"0\" name=\"Nonce\" type=\"dskpp:NonceType\"/> <xs:element minOccurs=\"0\" name=\"IterationCount\" type=\"xs:int\"/> <xs:element name=\"Mac\" type=\"dskpp:MacType\" /> </xs:sequence> </xs:complexType>",
      "ja": "<XS：complexTypeの名前= \"AuthenticationMacType\"> <XS：配列> <XS：要素のminOccurs = \"0\" NAME = \"ノンス\" タイプ= \"dskpp：NonceType\" /> <XS：要素のminOccurs = \"0\" NAME =」 IterationCount」タイプ= \"XS：int型\" /> <XS：要素名= \"マック\" タイプ= \"dskpp：MacType\" /> </ XS：シーケンス> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"MacType\"> <xs:simpleContent> <xs:extension base=\"xs:base64Binary\"> <xs:attribute name=\"MacAlgorithm\" type=\"xs:anyURI\"/> </xs:extension> </xs:simpleContent> </xs:complexType>",
      "ja": "<XS：complexTypeの名前= \"MacType\"> <XS：simpleContentを> <XS：増設ベース= \"XS：base64Binaryの\"> <XS：属性名= \"MacAlgorithm\" タイプ= \"XS：anyURIの\" /> </ XS：拡張> </ XS：simpleContentを> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"KeyPackageType\"> <xs:sequence> <xs:element minOccurs=\"0\" name=\"ServerID\" type=\"xs:anyURI\"/> <xs:element minOccurs=\"0\" name=\"KeyProtectionMethod\" type=\"xs:anyURI\" /> <xs:choice> <xs:element name=\"KeyContainer\" type=\"pskc:KeyContainerType\"/> <xs:any namespace=\"##other\" processContents=\"strict\"/> </xs:choice> </xs:sequence> </xs:complexType>",
      "ja": "<XS：complexTypeの名前= \"KeyPackageType\"> <XS：配列> <XS：要素のminOccurs = \"0\" NAME = \"サーバID\" タイプ= \"XS：anyURIの\" /> <XS：要素のminOccurs = \"0\" NAME =」 KeyProtectionMethod」タイプ= \"XS：anyURIの\" /> <XS：選択> <XS：要素名= \"KeyContainer\" タイプ= \"pskc：KeyContainerType\" /> <XS：任意の名前空間= \"##他\" のprocessContents = \"厳しいです\" /> </ XS：選択> </ XS：シーケンス> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"InitializationTriggerType\"> <xs:sequence> <xs:element minOccurs=\"0\" name=\"DeviceIdentifierData\" type=\"dskpp:DeviceIdentifierDataType\" /> <xs:element minOccurs=\"0\" name=\"KeyID\" type=\"xs:base64Binary\"/> <xs:element minOccurs=\"0\" name=\"TokenPlatformInfo\" type=\"dskpp:TokenPlatformInfoType\" /> <xs:element name=\"AuthenticationData\" type=\"dskpp:AuthenticationDataType\" /> <xs:element minOccurs=\"0\" name=\"ServerUrl\" type=\"xs:anyURI\"/> <xs:any minOccurs=\"0\" namespace=\"##other\" processContents=\"strict\" /> </xs:sequence> </xs:complexType>",
      "ja": "<XS：complexTypeの名前= \"InitializationTriggerType\"> <XS：配列> <XS：要素のminOccurs = \"0\" NAME = \"DeviceIdentifierData\" タイプ= \"dskpp：DeviceIdentifierDataType\" /> <XS：要素のminOccurs = \"0\" NAME =」 KeyIDを」TYPE = \"XS：base64Binaryの\" /> <XS：要素のminOccurs = \"0\" NAME = \"TokenPlatformInfo\" タイプ= \"dskpp：TokenPlatformInfoType\" /> <XS：要素名= \"AuthenticationData\" タイプ= \"dskpp：AuthenticationDataType\" /> <XS：要素のminOccurs = \"0\" NAME = \"SERVERURL\" タイプ= \"XS：anyURIの\" /> <XS：任意のminOccurs = \"0\" 名前空間= \"##その他\" のprocessContents = \"厳格な\" /> </ XS：シーケンス> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"ExtensionsType\"> <xs:annotation> <xs:documentation> Extension types </xs:documentation> </xs:annotation> <xs:sequence maxOccurs=\"unbounded\"> <xs:element name=\"Extension\" type=\"dskpp:AbstractExtensionType\"/> </xs:sequence> </xs:complexType>",
      "ja": "<XS：complexTypeの名前= \"ExtensionsType\"> <XS：注釈> <XS：ドキュメント>拡張タイプ</ XS：ドキュメンテーション> </ XS：注釈> <XS：シーケンスのmaxOccurs = \"無制限\"> <XS：要素名= \"拡張\" タイプ= \"dskpp：AbstractExtensionType\" /> </ XS：配列> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"AbstractExtensionType\" abstract=\"true\"> <xs:attribute name=\"Critical\" type=\"xs:boolean\" /> </xs:complexType>",
      "ja": "<XS：complexTypeの名= \"AbstractExtensionType\" 抽象= \"真\"> <XS：属性名= \"クリティカル\" タイプ= \"XS：ブール値\" /> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"ClientInfoType\"> <xs:complexContent mixed=\"false\"> <xs:extension base=\"dskpp:AbstractExtensionType\"> <xs:sequence> <xs:element name=\"Data\" type=\"xs:base64Binary\"/> </xs:sequence> </xs:extension> </xs:complexContent> </xs:complexType>",
      "ja": "<XS：complexTypeの名前= \"ClientInfoType\"> <XS：complexContentを混在= \"偽\"> <XS：拡張ベース= \"dskpp：AbstractExtensionType\"> <XS：配列> <XS：要素名= \"データ\" タイプ= \"XS ：base64Binaryの \"/> </ XS：シーケンス> </ XS：拡張> </ XS：complexContentを> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"ServerInfoType\"> <xs:complexContent mixed=\"false\"> <xs:extension base=\"dskpp:AbstractExtensionType\"> <xs:sequence> <xs:element name=\"Data\" type=\"xs:base64Binary\"/> </xs:sequence> </xs:extension> </xs:complexContent> </xs:complexType>",
      "ja": "<XS：complexTypeの名前= \"ServerInfoType\"> <XS：complexContentを混在= \"偽\"> <XS：拡張ベース= \"dskpp：AbstractExtensionType\"> <XS：配列> <XS：要素名= \"データ\" タイプ= \"XS ：base64Binaryの \"/> </ XS：シーケンス> </ XS：拡張> </ XS：complexContentを> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:element name=\"KeyProvTrigger\" type=\"dskpp:KeyProvTriggerType\"> <xs:annotation> <xs:documentation> DSKPP PDUs </xs:documentation> </xs:annotation> </xs:element>",
      "ja": "<XS：要素名= \"KeyProvTrigger\" タイプ= \"dskpp：KeyProvTriggerType\"> <XS：注釈> <XS：ドキュメント> DSKPPのPDU </ XS：ドキュメンテーション> </ XS：注釈> </ XS：要素>"
    },
    {
      "indent": 7,
      "text": "<xs:complexType name=\"KeyProvTriggerType\"> <xs:annotation> <xs:documentation xml:lang=\"en\"> Message used to trigger the device to initiate a DSKPP run. </xs:documentation> </xs:annotation> <xs:sequence> <xs:choice> <xs:element name=\"InitializationTrigger\" type=\"dskpp:InitializationTriggerType\" /> <xs:any namespace=\"##other\" processContents=\"strict\"/> </xs:choice> </xs:sequence> <xs:attribute name=\"Version\" type=\"dskpp:VersionType\"/> </xs:complexType>",
      "ja": "<XS：complexTypeの名= \"KeyProvTriggerType\"> <XS：注釈> <XS：ドキュメントのXML：LANG = \"EN\"> DSKPPの実行を開始するために、デバイスをトリガするために使用されるメッセージ。 </ XS：ドキュメンテーション> </ XS：注釈> <XS：シーケンス> <XS：選択> <XS：要素名= \"InitializationTrigger\" タイプ= \"dskpp：InitializationTriggerType\" /> <XS：任意の名前空間= \"##他\"のprocessContents =\" 厳しい \"/> </ XS：選択> </ XS：シーケンス> <XS：属性名=\" バージョン」タイプ= \"dskpp：VersionType\" /> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:element name=\"KeyProvClientHello\" type=\"dskpp:KeyProvClientHelloPDU\"> <xs:annotation> <xs:documentation>KeyProvClientHello PDU</xs:documentation> </xs:annotation> </xs:element> <xs:complexType name=\"KeyProvClientHelloPDU\"> <xs:annotation> <xs:documentation xml:lang=\"en\"> Message sent from DSKPP Client to DSKPP Server to initiate a DSKPP session. </xs:documentation> </xs:annotation> <xs:complexContent mixed=\"false\"> <xs:extension base=\"dskpp:AbstractRequestType\"> <xs:sequence> <xs:element minOccurs=\"0\" name=\"DeviceIdentifierData\" type=\"dskpp:DeviceIdentifierDataType\" /> <xs:element minOccurs=\"0\" name=\"KeyID\" type=\"xs:base64Binary\" /> <xs:element minOccurs=\"0\" name=\"ClientNonce\" type=\"dskpp:NonceType\" /> <xs:element name=\"SupportedKeyTypes\" type=\"dskpp:AlgorithmsType\" /> <xs:element name=\"SupportedEncryptionAlgorithms\" type=\"dskpp:AlgorithmsType\" /> <xs:element name=\"SupportedMacAlgorithms\" type=\"dskpp:AlgorithmsType\" /> <xs:element minOccurs=\"0\" name=\"SupportedProtocolVariants\" type=\"dskpp:ProtocolVariantsType\" />",
      "ja": "<XS：要素名= \"KeyProvClientHello\" タイプ= \"dskpp：KeyProvClientHelloPDU\"> <XS：注釈> <XS：ドキュメント> KeyProvClientHello PDU </ XS：ドキュメント> </ XS：注釈> </ XS：要素> <XS： complexTypeの名前= \"KeyProvClientHelloPDU\"> <XS：注釈> <XS：ドキュメントのxml：DSKPPセッションを開始するDSKPP ServerにDSKPPクライアントから送信されたLANG = \"EN\">メッセージ。 </ XS：ドキュメント> </ XS：注釈> <XS：complexContentを混在= \"偽\"> <XS：拡張ベース= \"dskpp：AbstractRequestType\"> <XS：配列> <XS：要素のminOccurs = \"0\" 名前= \"DeviceIdentifierData\" タイプ= \"dskpp：DeviceIdentifierDataType\" /> <XS：要素のminOccurs = \"0\" NAME = \"KeyIDを\" タイプ= \"XS：base64Binaryの\" /> <XS：要素のminOccurs = \"0\" NAME = \"ClientNonce\" タイプ= \"dskpp：NonceType\" /> <XS：要素名= \"SupportedKeyTypes\" タイプ= \"dskpp：AlgorithmsType\" /> <XS：要素名= \"SupportedEncryptionAlgorithms\" タイプ= \"dskpp：AlgorithmsType\" /> <XS：要素名= \"SupportedMacAlgorithms\" タイプ= \"dskpp：AlgorithmsType\" /> <XS：要素のminOccurs = \"0\" NAME = \"SupportedProtocolVariants\" タイプ= \"dskpp：ProtocolVariantsType\" />"
    },
    {
      "indent": 7,
      "text": " <xs:element minOccurs=\"0\" name=\"SupportedKeyPackages\" type=\"dskpp:KeyPackagesFormatType\" /> <xs:element minOccurs=\"0\" name=\"AuthenticationData\" type=\"dskpp:AuthenticationDataType\" /> <xs:element minOccurs=\"0\" name=\"Extensions\" type=\"dskpp:ExtensionsType\" /> </xs:sequence> </xs:extension> </xs:complexContent> </xs:complexType>",
      "ja": "<XS：要素のminOccurs = \"0\" NAME = \"SupportedKeyPackages\" タイプ= \"dskpp：KeyPackagesFormatType\" /> <XS：要素のminOccurs = \"0\" NAME = \"AuthenticationData\" タイプ= \"dskpp：AuthenticationDataType\" /> <XS：要素minOccurs = \"0\" 名前= \"拡張機能\" タイプ= \"dskpp：ExtensionsType\" /> </ XS：シーケンス> </ XS：拡張> </ XS：complexContentを> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:element name=\"KeyProvServerHello\" type=\"dskpp:KeyProvServerHelloPDU\"> <xs:annotation> <xs:documentation>KeyProvServerHello PDU</xs:documentation> </xs:annotation> </xs:element> <xs:complexType name=\"KeyProvServerHelloPDU\"> <xs:annotation> <xs:documentation xml:lang=\"en\"> Response message sent from DSKPP Server to DSKPP Client in four-pass DSKPP. </xs:documentation> </xs:annotation> <xs:complexContent mixed=\"false\"> <xs:extension base=\"dskpp:AbstractResponseType\"> <xs:sequence minOccurs=\"0\"> <xs:element name=\"KeyType\" type=\"dskpp:AlgorithmType\"/> <xs:element name=\"EncryptionAlgorithm\" type=\"dskpp:AlgorithmType\" /> <xs:element name=\"MacAlgorithm\" type=\"dskpp:AlgorithmType\"/> <xs:element name=\"EncryptionKey\" type=\"ds:KeyInfoType\"/> <xs:element name=\"KeyPackageFormat\" type=\"dskpp:KeyPackageFormatType\" /> <xs:element name=\"Payload\" type=\"dskpp:PayloadType\"/> <xs:element minOccurs=\"0\" name=\"Extensions\" type=\"dskpp:ExtensionsType\" /> <xs:element minOccurs=\"0\" name=\"Mac\" type=\"dskpp:MacType\"/> </xs:sequence> </xs:extension> </xs:complexContent> </xs:complexType>",
      "ja": "<XS：要素名= \"KeyProvServerHello\" タイプ= \"dskpp：KeyProvServerHelloPDU\"> <XS：注釈> <XS：ドキュメント> KeyProvServerHello PDU </ XS：ドキュメント> </ XS：注釈> </ XS：要素> <XS： complexTypeの名= \"KeyProvServerHelloPDU\"> <XS：注釈> <XS：ドキュメントのxml：langは= \"EN\">でDSKPPクライアントにDSKPPサーバーから送信された応答メッセージDSKPPを4-渡します。 </ XS：ドキュメント> </ XS：注釈> <XS：complexContentを混在= \"偽\"> <XS：増設ベース= \"dskpp：AbstractResponseType\"> <XS：配列のminOccurs = \"0\"> <XS：要素名= \"ます。KeyType\" タイプ= \"dskpp：AlgorithmType\" /> <XS：要素名= \"EncryptionAlgorithm\" タイプ= \"dskpp：AlgorithmType\" /> <XS：要素名= \"MacAlgorithm\" タイプ= \"dskpp：AlgorithmType\" /> <XS ：要素名= \"EncryptionKey\" タイプ= \"DS：KeyInfoType\" /> <XS：要素名= \"KeyPackageFormat\" タイプ= \"dskpp：KeyPackageFormatType\" /> <XS：要素名= \"ペイロード\" タイプ= \"dskpp：PayloadType\" /> <XS：要素のminOccurs = \"0\" 名前= \"拡張機能\" タイプ= \"dskpp：ExtensionsType\" /> <XS：要素のminOccurs = \"0\" 名前= \"マック\" タイプ= \"dskpp：MacType\" /> </ XS：シーケンス> </ XS：拡張> </ XS：complexContentを> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:element name=\"KeyProvClientNonce\" type=\"dskpp:KeyProvClientNoncePDU\"> <xs:annotation> <xs:documentation>KeyProvClientNonce PDU</xs:documentation> </xs:annotation> </xs:element> <xs:complexType name=\"KeyProvClientNoncePDU\"> <xs:annotation> <xs:documentation xml:lang=\"en\"> Response message sent from DSKPP Client to DSKPP Server in a four-pass DSKPP session. </xs:documentation> </xs:annotation> <xs:complexContent mixed=\"false\"> <xs:extension base=\"dskpp:AbstractRequestType\"> <xs:sequence> <xs:element name=\"EncryptedNonce\" type=\"xs:base64Binary\"/> <xs:element minOccurs=\"0\" name=\"AuthenticationData\" type=\"dskpp:AuthenticationDataType\" /> <xs:element minOccurs=\"0\" name=\"Extensions\" type=\"dskpp:ExtensionsType\" /> </xs:sequence> <xs:attribute name=\"SessionID\" type=\"dskpp:IdentifierType\" use=\"required\"/> </xs:extension> </xs:complexContent> </xs:complexType>",
      "ja": "<XS：要素名= \"KeyProvClientNonce\" タイプ= \"dskpp：KeyProvClientNoncePDU\"> <XS：注釈> <XS：ドキュメント> KeyProvClientNonce PDU </ XS：ドキュメント> </ XS：注釈> </ XS：要素> <XS： complexTypeの名= \"KeyProvClientNoncePDU\"> <XS：注釈> <XS：ドキュメントのxml：4-渡すDSKPPセッションでDSKPPサーバーにDSKPPクライアントから送信されたLANG = \"EN\">応答メッセージ。 </ XS：ドキュメント> </ XS：注釈> <XS：complexContentを混在= \"偽\"> <XS：拡張ベース= \"dskpp：AbstractRequestType\"> <XS：配列> <XS：要素名= \"EncryptedNonce\" タイプ= \"XS：base64Binaryの\" /> <XS：要素のminOccurs = \"0\" 名前= \"AuthenticationData\" タイプ= \"dskpp：AuthenticationDataType\" /> <XS：要素のminOccurs = \"0\" 名前= \"拡張機能\" タイプ= \"dskpp：ExtensionsType \"/> </ XS：シーケンス> <XS：属性名=\" セッションID」タイプ= \"dskpp：IdentifierType\" 使用= \"\" /> </ XS必要：拡張> </ XS：complexContentを> </ XS：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "<xs:element name=\"KeyProvServerFinished\" type=\"dskpp:KeyProvServerFinishedPDU\"> <xs:annotation> <xs:documentation> KeyProvServerFinished PDU </xs:documentation> </xs:annotation> </xs:element> <xs:complexType name=\"KeyProvServerFinishedPDU\"> <xs:annotation> <xs:documentation xml:lang=\"en\"> Final message sent from DSKPP Server to DSKPP Client in a DSKPP session. A MAC value serves for key confirmation, and optional AuthenticationData serves for server authentication. </xs:documentation> </xs:annotation> <xs:complexContent mixed=\"false\"> <xs:extension base=\"dskpp:AbstractResponseType\">",
      "ja": "<XS：要素名= \"KeyProvServerFinished\" タイプ= \"dskpp：KeyProvServerFinishedPDU\"> <XS：注釈> <XS：ドキュメント> KeyProvServerFinished PDU </ XS：ドキュメント> </ XS：注釈> </ XS：要素> <XS： complexTypeの名= \"KeyProvServerFinishedPDU\"> <XS：注釈> <XS：ドキュメントのXML：LANG = \"EN\"> DSKPPセッションでDSKPP ClientにDSKPPサーバーから送信された最終的なメッセージ。 MAC値は、鍵確認のためのものであり、オプションのAuthenticationDataは、サーバー認証のために機能します。 </ XS：ドキュメント> </ XS：注釈> <XS：complexContentを混在= \"偽\"> <XS：拡張ベース= \"dskpp：AbstractResponseType\">"
    },
    {
      "indent": 5,
      "text": " <xs:sequence minOccurs=\"0\"> <xs:element name=\"KeyPackage\" type=\"dskpp:KeyPackageType\" /> <xs:element minOccurs=\"0\" name=\"Extensions\" type=\"dskpp:ExtensionsType\" /> <xs:element name=\"Mac\" type=\"dskpp:MacType\" /> <xs:element minOccurs=\"0\" name=\"AuthenticationData\" type=\"dskpp:AuthenticationMacType\" /> </xs:sequence> </xs:extension> </xs:complexContent> </xs:complexType> </xs:schema>",
      "ja": "<XS：シーケンスのminOccurs = \"0\"> <XS：要素名= \"KeyPackage\" タイプ= \"dskpp：KeyPackageType\" /> <XS：要素のminOccurs = \"0\" 名前= \"拡張機能\" タイプ= \"dskpp：ExtensionsType\" / > <XS：要素名= \"マック\" タイプ= \"dskpp：MacType\" /> <XS：要素のminOccurs = \"0\" 名前= \"AuthenticationData\" タイプ= \"dskpp：AuthenticationMacType\" /> </ XS：シーケンス> </ XS：拡張機能> </ XS：complexContentを> </ XS：complexTypeの> </ XS：スキーマ>"
    },
    {
      "indent": 0,
      "text": "9. Conformance Requirements",
      "section_title": true,
      "ja": "9.適合性要件"
    },
    {
      "indent": 3,
      "text": "In order to assure that all implementations of DSKPP can interoperate, the DSKPP Server:",
      "ja": "DSKPPのすべての実装が相互運用できることを保証するために、DSKPPサーバー："
    },
    {
      "indent": 3,
      "text": "a. MUST implement the four-pass variation of the protocol (Section 4)",
      "ja": "A。プロトコルの4パス変化を実装しなければならない（第4章）"
    },
    {
      "indent": 3,
      "text": "b. MUST implement the two-pass variation of the protocol (Section 5)",
      "ja": "B。プロトコルの二パス変動を実装しなければならない（第5章）"
    },
    {
      "indent": 3,
      "text": "c. MUST support user authentication (Section 3.2.1)",
      "ja": "C。ユーザ認証をサポートしなければならない（3.2.1項）"
    },
    {
      "indent": 3,
      "text": "d. MUST support the following key derivation functions: * DSKPP-PRF-AES DSKPP-PRF realization (Appendix D) * DSKPP-PRF-SHA256 DSKPP-PRF realization (Appendix D)",
      "ja": "D。次のキー導出関数をサポートしなければならない：* DSKPP-PRF-AES DSKPP-PRF実現（付録D）* DSKPP-PRF-SHA256 DSKPP-PRF実現（付録D）"
    },
    {
      "indent": 3,
      "text": "e. MUST support the following encryption mechanisms for protection of the client nonce in the four-pass protocol: * Mechanism described in Section 4.2.4",
      "ja": "電子。 4パスプロトコルでクライアントナンスの保護のため、以下の暗号化メカニズムをサポートしなければならない：*メカニズムは、セクション4.2.4で説明"
    },
    {
      "indent": 3,
      "text": "f. MUST support one of the following encryption algorithms for symmetric key operations, e.g., key wrap: * KW-AES128 without padding; refer to http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC] * KW-AES128 with padding; refer to http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC] and [RFC5649] * AES-CBC-128; refer to [FIPS197-AES]",
      "ja": "F。パディングなし* KW-AES128;：例えば、対称キー操作については、以下の暗号化アルゴリズムの1、、キーラップをサポートしなければなりませんパディング付き[XMLENC] * KW-AES128にhttp://www.w3.org/2001/04/xmlenc#kw-aes128を指します。 【XMLENC]及び[RFC5649] * AES-CBC-128 http://www.w3.org/2001/04/xmlenc#kw-aes128を指します。 [FIPS197-AES]を参照"
    },
    {
      "indent": 3,
      "text": "g. MUST support the following encryption algorithms for asymmetric key operations, e.g., key transport: * RSA Encryption Scheme [PKCS-1]",
      "ja": "グラム。 * RSA暗号化スキーム[PKCS-1]：非対称キー操作については、以下の暗号化アルゴリズム、例えば、キートランスポートをサポートしなければなりません"
    },
    {
      "indent": 3,
      "text": "h. MUST support the following integrity/KDF MAC functions: * DSKPP-PRF-AES (Appendix D) * DSKPP-PRF-SHA256 (Appendix D)",
      "ja": "時間。以下の整合性/ KDF MAC機能をサポートしなければならない：* DSKPP-PRF-AES（付録D）* DSKPP-PRF-SHA256（付録D）"
    },
    {
      "indent": 3,
      "text": "i. MUST support the PSKC key package [RFC6030]; all three PSKC key protection methods (Key Transport, Key Wrap, and Passphrase-Based Key Wrap) MUST be implemented",
      "ja": "私。 PSKCキーパッケージ[RFC6030]をサポートしなければなりません。すべての3つのPSKCキーの保護方法（主要交通、キーラップ、およびパスフレーズベースのキーラップ）が実装されなければなりません"
    },
    {
      "indent": 3,
      "text": "j. MAY support the ASN.1 key package as defined in [RFC6031]",
      "ja": "J。 [RFC6031]で定義されているASN.1キーパッケージをサポートしてもよい（MAY）"
    },
    {
      "indent": 3,
      "text": "DSKPP Clients MUST support either the two-pass or the four-pass variant of the protocol. DSKPP Clients MUST fulfill all requirements listed in item (c) - (j).",
      "ja": "DSKPPクライアントは、2パスまたはプロトコルの4パスバリアントのいずれかをサポートしなければなりません。 （J） -  DSKPPクライアントは、項目（c）に記載されているすべての要件を満たす必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, implementations of DSKPP MUST bind DSKPP messages to HTTP/1.1 as described in Section 7.2.",
      "ja": "セクション7.2で説明したように、最終的に、DSKPPの実装は、HTTP / 1.1にDSKPPメッセージを結合しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Of course, DSKPP is a security protocol, and one of its major functions is to allow only authorized parties to successfully initialize a cryptographic module with a new symmetric key. Therefore, a particular implementation may be configured with any of a number of restrictions concerning algorithms and trusted authorities that will prevent universal interoperability.",
      "ja": "もちろん、DSKPPは、セキュリティプロトコルであり、その主要な機能の一つは、唯一認可当事者が成功し、新たな対称鍵で暗号モジュールを初期化することができるようにすることです。そのため、特定の実装には、普遍的な相互運用性を防ぐことができますアルゴリズムと信頼された機関に関する制約の数のいずれかを用いて構成することができます。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "10.1. General",
      "section_title": true,
      "ja": "10.1。一般的な"
    },
    {
      "indent": 3,
      "text": "DSKPP is designed to protect generated keying material from exposure. No entities other than the DSKPP Server and the cryptographic module will have access to a generated K_TOKEN if the cryptographic algorithms used are of sufficient strength and, on the DSKPP Client side, generation and encryption of R_C and generation of K_TOKEN take place as specified in the cryptographic module. This applies even if malicious software is present in the DSKPP Client. However, as discussed in the following sub-sections, DSKPP does not protect against certain other threats resulting from man-in-the-middle attacks and other forms of attacks. DSKPP MUST, therefore, be run over a transport providing confidentiality and integrity, such as HTTP over Transport Layer Security (TLS) with a suitable ciphersuite [RFC2818], when such threats are a concern. Note that TLS ciphersuites with anonymous key exchanges are not suitable in those situations [RFC5246].",
      "ja": "DSKPPは、露光から生成された鍵材料を保護するように設計されています。使用される暗号アルゴリズムは十分な強度とR_Cの、DSKPPクライアント側では、生成と暗号化とK_TOKENの世代である場合にDSKPPサーバ以外のエンティティと暗号モジュールは、生成されたK_TOKENへのアクセスを持っていないだろうに指定されている場所を取ります暗号モジュール。これは、悪意のあるソフトウェアがDSKPPクライアントに存在している場合にも適用されます。ただし、以下のサブセクションで説明したように、DSKPPはman-in-the-middle攻撃および攻撃の他の形態に起因するある種の他の脅威から保護しません。 DSKPPは、したがって、そのような脅威が懸念されているときに、適切な暗号スイート[RFC2818]でトランスポート層セキュリティ（TLS）を介して、HTTPなど、機密性と完全性を提供するトランスポート上で実行する必要があります。匿名の鍵交換とのTLS暗号スイートは、これらの状況では適切ではないことに注意してください[RFC5246]。"
    },
    {
      "indent": 0,
      "text": "10.2. Active Attacks",
      "section_title": true,
      "ja": "10.2。アクティブな攻撃"
    },
    {
      "indent": 0,
      "text": "10.2.1. Introduction",
      "section_title": true,
      "ja": "10.2.1。前書き"
    },
    {
      "indent": 3,
      "text": "An active attacker MAY attempt to modify, delete, insert, replay, or reorder messages for a variety of purposes including service denial and compromise of generated keying material.",
      "ja": "アクティブな攻撃者は、変更しようと削除、挿入、リプレイ、またはサービス拒否および生成された鍵材料の妥協を含む種々の目的のために、メッセージの順序を変更するかもしれません。"
    },
    {
      "indent": 0,
      "text": "10.2.2. Message Modifications",
      "section_title": true,
      "ja": "10.2.2。メッセージの変更"
    },
    {
      "indent": 3,
      "text": "Modifications to a <KeyProvTrigger> message will either cause denial of service (modifications of any of the identifiers or the Authentication Code) or will cause the DSKPP Client to contact the wrong DSKPP Server. The latter is in effect a man-in-the-middle attack and is discussed further in Section 10.2.7.",
      "ja": "<KeyProvTrigger>メッセージへの変更は、サービス拒否（識別子または認証コードのいずれかの変更）が発生するかまたはDSKPPクライアントが間違っDSKPPサーバーに連絡するようになります。後者は、実際にはman-in-the-middle攻撃であり、セクション10.2.7でさらに議論されます。"
    },
    {
      "indent": 3,
      "text": "An attacker may modify a <KeyProvClientHello> message. This means that the attacker could indicate a different key or device than the one intended by the DSKPP Client, and could also suggest other cryptographic algorithms than the ones preferred by the DSKPP Client, e.g., cryptographically weaker ones. The attacker could also suggest earlier versions of DSKPP, in case these versions have been shown to have vulnerabilities. These modifications could lead to an attacker succeeding in initializing or modifying another cryptographic module than the one intended (i.e., the server assigning the generated key to the wrong module) or gaining access to a generated key through the use of weak cryptographic algorithms or protocol versions. DSKPP implementations MAY protect against the latter by having strict policies about what versions and algorithms they support and accept. The former threat (assignment of a generated key to the wrong module) is not possible when the shared-key variant of DSKPP is employed (assuming existing shared keys are unique per cryptographic module), but is possible in the public key variation. Therefore, DSKPP Servers MUST NOT accept unilaterally provided device identifiers in the public key variation. This is also indicated in the protocol description. In the shared-key variation, however, an attacker may be able to provide the wrong identifier (possibly also leading to the incorrect user being associated with the generated key) if the attacker has real-time access to the cryptographic module with the identified key. The result of this attack could be that the generated key is associated with the correct cryptographic module but the module is associated with the incorrect user. See Section 10.5 for a further discussion of this threat and possible countermeasures.",
      "ja": "攻撃者は、<KeyProvClientHello>メッセージを変更することがあります。これにより、攻撃者はDSKPPクライアントによって意図とは異なる鍵またはデバイスを示している可能性があり、またDSKPPクライアント、例えば、暗号弱いものに好ま以外の暗号化アルゴリズムを提案することができることを意味します。攻撃者はまた、これらのバージョンは、脆弱性を有することが示されている場合にはDSKPPの以前のバージョンを、お勧めできます。これらの改変は、意図のものより他の暗号モジュールを初期化または変更に成功した攻撃につながる可能性がある（すなわち、間違ったモジュールに生成されたキーを割り当てるサーバ）または弱い暗号化アルゴリズムまたはプロトコルのバージョンを使用することによって生成されたキーにアクセスします。 DSKPPの実装は、サポートと受け入れどのバージョンやアルゴリズムに関する厳格なポリシーを持っていることによって、後者に対して保護することができます。 （間違ったモジュールに生成されたキーの割り当て）前者の脅威はDSKPPの共有鍵変異体を用いた場合（仮定既存の共有鍵は、暗号モジュールごとに一意である）ことは不可能であるが、公開鍵変形可能です。したがって、DSKPPサーバーは、公開鍵の変化に一方的に提供されるデバイス識別子を受け入れてはいけません。これは、プロトコルの説明で示されています。共有鍵の変形例では、しかし、攻撃者は、攻撃者が識別されたキーで暗号モジュールへのリアルタイムアクセスを有する場合（おそらくは生成した鍵に関連付けられている不正なユーザを導く）間違った識別子を提供することができます。この攻撃の結果は、生成されたキーが正しい暗号モジュールに関連付けられているが、モジュールが誤ったユーザーに関連付けられている可能性があります。この脅威と可能な対策のさらなる議論については、セクション10.5を参照してください。"
    },
    {
      "indent": 3,
      "text": "An attacker may also modify a <KeyProvServerHello> message. This means that the attacker could indicate different key types, algorithms, or protocol versions than the legitimate server would, e.g., cryptographically weaker ones. The attacker may also provide a different nonce than the one sent by the legitimate server. Clients MAY protect against the former through strict adherence to policies regarding permissible algorithms and protocol versions. The latter (wrong nonce) will not constitute a security problem, as a generated key will not match the key generated on the legitimate server. Also, whenever the DSKPP run would result in the replacement of an existing key, the <Mac> element protects against modifications of R_S.",
      "ja": "攻撃者はまた、<KeyProvServerHello>メッセージを変更することがあります。これにより、攻撃者は正当なサーバでしょう、例えば、暗号的に弱いものとは異なるキータイプ、アルゴリズム、またはプロトコルのバージョンを示すことができることを意味します。また、攻撃者は正当なサーバによって送信されたものとは異なるノンスを提供してもよいです。クライアントは許容アルゴリズムとプロトコルバージョンに関する方針を厳守を通じて元に対して保護することができます。後者（間違ったナンス）、生成した鍵が正当なサーバ上で生成されたキーと一致しないので、セキュリティ上の問題を構成するものではありません。また、DSKPPの実行は既存のキーの交換につながるたび、<MAC>要素は、R_Sの変更から保護します。"
    },
    {
      "indent": 3,
      "text": "Modifications of <KeyProvClientNonce> messages are also possible. If an attacker modifies the SessionID attribute, then, in effect, a switch to another session will occur at the server, assuming the new SessionID is valid at that time on the server. It still will not allow the attacker to learn a generated K_TOKEN since R_C has been wrapped for the legitimate server. Modifications of the <EncryptedNonce> element, e.g., replacing it with a value for which the attacker knows an underlying R'C, will not result in the client changing its pre-DSKPP state, since the server will be unable to provide a valid MAC in its final message to the client. The server MAY, however, end up storing K'TOKEN rather than K_TOKEN. If the cryptographic module has been associated with a particular user, then this could constitute a security problem. For a further discussion about this threat, and a possible countermeasure, see Section 10.5 below. Note that use of TLS does not protect against this attack if the attacker has access to the DSKPP Client (e.g., through malicious software, \"Trojans\") [RFC5246].",
      "ja": "<KeyProvClientNonce>メッセージの変更も可能です。攻撃者がセッションID属性を変更する場合は、その後、実際には、別のセッションへの切り替えは、新しいセッションIDがサーバー上でその時点で有効であると仮定すると、サーバーで発生します。それはまだR_Cが正当なサーバー用に包まれているため、攻撃者が発生したK_TOKENを学習することはできません。サーバーが有効なMACを提供することができませんので、<EncryptedNonce>要素の変更は、例えば、攻撃者は、基礎となるR'Cを知っている値で置き換え、その前DSKPP状態を変更するクライアントにはなりませんクライアントへの最後のメッセージインチサーバーは、しかし、むしろK_TOKENよりK'TOKENを保存するに終わる可能性があります。暗号モジュールは、特定のユーザに関連付けられている場合、これはセキュリティ上の問題となる可能性があります。この脅威についてさらに議論し、可能な対策については、セクションの下に10.5を参照してください。攻撃者はDSKPPクライアント（例えば、悪質なソフトウェアを介して、「トロイの木馬」）[RFC5246]へのアクセス権を持っている場合、この攻撃を防ぐことはできませんTLSの使用に注意してください。"
    },
    {
      "indent": 3,
      "text": "Finally, attackers may also modify the <KeyProvServerFinished> message. Replacing the <Mac> element will only result in denial of service. Replacement of any other element may cause the DSKPP Client to associate, e.g., the wrong service with the generated key. DSKPP SHOULD be run over a transport providing confidentiality and integrity when this is a concern.",
      "ja": "最後に、攻撃者はまた、<KeyProvServerFinished>メッセージを変更することがあります。 <MAC>要素を交換するだけでサービス拒否が発生します。他の要素の交換は、生成されたキーで、例えば、間違ったサービスを関連付けるためにDSKPPクライアントを引き起こす可能性があります。 DSKPPは、これが懸念されるとき、機密性と完全性を提供するトランスポート上で実行する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2.3. Message Deletion",
      "section_title": true,
      "ja": "10.2.3。メッセージの削除"
    },
    {
      "indent": 3,
      "text": "Message deletion will not cause any other harm than denial of service, since a cryptographic module MUST NOT change its state (i.e., \"commit\" to a generated key) until it receives the final message from the DSKPP Server and successfully has processed that message, including validation of its MAC. A deleted <KeyProvServerFinished> message will not cause the server to end up in an inconsistent state vis-a-vis the cryptographic module if the server implements the suggestions in Section 10.5.",
      "ja": "暗号モジュールは（すなわち、生成されたキーに「コミット」）、その状態を変更してはなりませんので、それが成功し、そのメッセージを処理したDSKPPサーバーから、最終的なメッセージを受信して​​まで、メッセージの削除は、サービス拒否以外の害を引き起こすことはありませんそのMACの検証を含みます。サーバは、セクション10.5で提案を実装している場合削除<KeyProvServerFinished>メッセージは、サーバが暗号モジュール矛盾した状態で向かい合って終了することはありません。"
    },
    {
      "indent": 0,
      "text": "10.2.4. Message Insertion",
      "section_title": true,
      "ja": "10.2.4。メッセージ挿入"
    },
    {
      "indent": 3,
      "text": "An active attacker may initiate a DSKPP run at any time, and suggest any device identifier. DSKPP Server implementations MAY receive some protection against inadvertently initializing a key or inadvertently replacing an existing key or assigning a key to a cryptographic module by initializing the DSKPP run by use of the <KeyProvTrigger>. The <AuthenticationData> element allows the server to associate a DSKPP run e.g., with an earlier user-authenticated session. The security of this method, therefore, depends on the ability to protect the <AuthenticationData> element in the DSKPP initialization message. If an eavesdropper is able to capture this message, he may race the legitimate user for a key initialization. DSKPP over a transport providing confidentiality and integrity, coupled with the recommendations in Section 10.5, is RECOMMENDED when this is a concern.",
      "ja": "活発な攻撃者は、いつでもDSKPP実行を開始し、任意のデバイス識別子を示唆し得ます。 DSKPPサーバーの実装は、誤ってキーを初期化するか、不注意、既存のキーを交換するか、<KeyProvTrigger>を使用することによって実行さDSKPPを初期化することによって暗号モジュールにキーを割り当てることに対する何らかの保護を受けることができます。 <AuthenticationData>要素は、以前のユーザ認証セッションと、サーバは、例えば実行DSKPPを関連付けることを可能にします。この方法のセキュリティは、従って、DSKPP初期化メッセージの<AuthenticationData>要素を保護する能力に依存します。盗聴者がこのメッセージを捕捉することができるならば、彼は鍵の初期化のための正当なユーザーをレースがあります。これが懸念されるときDSKPPは、セクション10.5の推奨事項と相まって機密性と整合性を提供するトランスポート上で、推奨されます。"
    },
    {
      "indent": 3,
      "text": "Insertion of other messages into an existing protocol run is seen as equivalent to modification of legitimately sent messages.",
      "ja": "既存のプロトコルの実行に他のメッセージの挿入は、合法的に送信されたメッセージの変更に相当すると見られています。"
    },
    {
      "indent": 0,
      "text": "10.2.5. Message Replay",
      "section_title": true,
      "ja": "10.2.5。メッセージリプレイ"
    },
    {
      "indent": 3,
      "text": "During four-pass DSKPP, attempts to replay a previously recorded DSKPP message will be detected, as the use of nonces ensures that both parties are live. For example, a DSKPP Client knows that a server it is communicating with is \"live\" since the server MUST create a MAC on information sent by the client.",
      "ja": "一回だけの使用は、両方の当事者が生きていることを保証するように4パスDSKPP中、以前に記録DSKPPメッセージが検出される再生しようとします。例えば、DSKPPクライアントは、サーバがクライアントから送信された情報にMACを作成しなければならないので、それが通信しているサーバは、「ライブ」であることを知っています。"
    },
    {
      "indent": 3,
      "text": "The same is true for two-pass DSKPP thanks to the requirement that the client sends R in the <KeyProvClientHello> message and that the server includes R in the MAC computation.",
      "ja": "DSKPPにクライアントが<KeyProvClientHello>メッセージにRを送信し、サーバは、MACの計算においてRが含まれていることを要件のおかげで2つのパスのために同じことが当てはまります。"
    },
    {
      "indent": 0,
      "text": "10.2.6. Message Reordering",
      "section_title": true,
      "ja": "10.2.6。メッセージの順序変更"
    },
    {
      "indent": 3,
      "text": "An attacker may attempt to re-order four-pass DSKPP messages but this will be detected, as each message is of a unique type. Note: Message re-ordering attacks cannot occur in two-pass DSKPP since each party sends at most one message each.",
      "ja": "攻撃者は、4パスDSKPPメッセージ順序を再を試みることができるが、各メッセージは固有のタイプのものであるように、これは、検出されます。注意：再順序付け攻撃は、各当事者は最大で1つのメッセージごとに送信しますので、DSKPPを、二パスで発生することができないメッセージを。"
    },
    {
      "indent": 0,
      "text": "10.2.7. Man in the Middle",
      "section_title": true,
      "ja": "10.2.7。真ん中の男"
    },
    {
      "indent": 3,
      "text": "In addition to other active attacks, an attacker posing as a man in the middle may be able to provide his own public key to the DSKPP Client. This threat and countermeasures to it are discussed in Section 4.1.1. An attacker posing as a man in the middle may also be acting as a proxy and, hence, may not interfere with DSKPP runs but still learn valuable information; see Section 10.3.",
      "ja": "他の能動的な攻撃に加えて、真ん中の男のふりを攻撃者がDSKPPクライアントに自分の公開鍵を提供することができます。それまでこの脅威と対策は、4.1.1項で説明されています。途中で男を装った攻撃者はまた、実行さDSKPPに干渉するが、それでも貴重な情報を学習していないこと、したがって、プロキシとして動作してもよいです。セクション10.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.3. Passive Attacks",
      "section_title": true,
      "ja": "10.3。受動的攻撃"
    },
    {
      "indent": 3,
      "text": "Passive attackers may eavesdrop on DSKPP runs to learn information that later on may be used to impersonate users, mount active attacks, etc.",
      "ja": "受動的攻撃者はなど、能動的な攻撃をマウントし、後でユーザーを偽装するために使用することができる情報を学ぶためにDSKPPを実行を盗聴します"
    },
    {
      "indent": 3,
      "text": "If DSKPP is not run over a transport providing confidentiality, a passive attacker may learn:",
      "ja": "DSKPPは、機密性を提供するトランスポート上で実行されていない場合は、受動的攻撃者が学ぶことがあります。"
    },
    {
      "indent": 3,
      "text": "o What cryptographic modules a particular user possesses",
      "ja": "特定のユーザが所有する暗号モジュールは何O"
    },
    {
      "indent": 3,
      "text": "o The identifiers of keys on those cryptographic modules and other attributes pertaining to those keys, e.g., the lifetime of the keys",
      "ja": "これらのキーに係るもの暗号化モジュールにキーの識別子と他の属性O、キーの例えば、寿命"
    },
    {
      "indent": 3,
      "text": "o DSKPP versions and cryptographic algorithms supported by a particular DSKPP Client or server",
      "ja": "DSKPPバージョンと特定DSKPPクライアントまたはサーバによってサポートされる暗号アルゴリズムO"
    },
    {
      "indent": 3,
      "text": "o Any value present in an <extension> that is part of <KeyProvClientHello>",
      "ja": "<KeyProvClientHello>の一部である<拡張>に存在する任意の値O"
    },
    {
      "indent": 3,
      "text": "Whenever the above is a concern, DSKPP MUST be run over a transport providing confidentiality. If man-in-the-middle attacks for the purposes described above are a concern, the transport MUST also offer server-side authentication.",
      "ja": "上記が懸念されるたびに、DSKPPは、機密性を提供するトランスポート上で実行する必要があります。上記の目的のためにman-in-the-middle攻撃が懸念される場合は、トランスポートは、サーバー側の認証を提供しなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.4. Cryptographic Attacks",
      "section_title": true,
      "ja": "10.4。暗号攻撃"
    },
    {
      "indent": 3,
      "text": "An attacker with unlimited access to an initialized cryptographic module may use the module as an \"oracle\" to pre-compute values that later on may be used to impersonate the DSKPP Server. Section 4.1.1 contains a discussion of this threat and steps RECOMMENDED to protect against it.",
      "ja": "初期化された暗号モジュールへの無制限のアクセスを持つ攻撃者は、後にDSKPPサーバーを偽装するために使用される値は、計算事前に「神託」としてモジュールを使用することができます。 4.1.1項では、この脅威とそれから保護するための推奨手順の議論が含まれています。"
    },
    {
      "indent": 3,
      "text": "Implementers are advised that cryptographic algorithms become weaker with time. As new cryptographic techniques are developed and computing performance improves, the work factor to break a particular cryptographic algorithm will reduce. Therefore, cryptographic algorithm implementations SHOULD be modular allowing new algorithms to be readily inserted. That is, implementers SHOULD be prepared to regularly update the algorithms in their implementations.",
      "ja": "実装者は、暗号化アルゴリズムは、時間とともに弱くなることをお勧めします。新しい暗号化技術が開発され、コンピューティング性能が向上しているように、特定の暗号アルゴリズムを破る仕事率が低下します。したがって、暗号アルゴリズムの実装を容易に挿入するモジュラー可能新しいアルゴリズムであるべきです。それは、実装者が定期的に彼らの実装でアルゴリズムを更新するために準備する必要があり、です。"
    },
    {
      "indent": 0,
      "text": "10.5. Attacks on the Interaction between DSKPP and User Authentication",
      "section_title": true,
      "ja": "10.5。 DSKPPとユーザー認証の相互作用に対する攻撃"
    },
    {
      "indent": 3,
      "text": "If keys generated in DSKPP will be associated with a particular user at the DSKPP Server (or a server trusted by, and communicating with the DSKPP Server), then in order to protect against threats where an attacker replaces a client-provided encrypted R_C with his own R'C (regardless of whether the public key variation or the shared-secret variation of DSKPP is employed to encrypt the client nonce), the server SHOULD NOT commit to associate a generated K_TOKEN with the given cryptographic module until the user simultaneously has proven both possession of the device that hosts the cryptographic module containing K_TOKEN and some out-of-band provided authenticating information (e.g., an Authentication Code). For example, if the cryptographic module is a one-time password token, the user could be required to authenticate with both a one-time password generated by the cryptographic module and an out-of-band provided Authentication Code in order to have the server \"commit\" to the generated OTP value for the given user. Preferably, the user SHOULD perform this operation from another host than the one used to initialize keys on the cryptographic module, in order to minimize the risk of malicious software on the client interfering with the process.",
      "ja": "DSKPPで生成されたキーは、攻撃者が彼とクライアントが提供する暗号化R_Cを置き換える脅威から保護するために、その後、DSKPPサーバーで特定のユーザーに関連付けられている（またはで信頼できるサーバ、およびDSKPPサーバーとの通信）する場合自分のR'C（関わらず、公開鍵変動やDSKPPの共有秘密変動がクライアントnonceを暗号化するために採用されているかどうかの）、サーバは、ユーザが同時に証明したまで与えられた暗号モジュールで生成K_TOKENを関連付けるためにコミットすべきではありませんK_TOKEN、一部の帯域外設けられた認証情報（例えば、認証コード）を含む暗号モジュールをホスト装置の所有両方。暗号モジュールは、ワンタイムパスワードトークンである場合、例えば、ユーザは、サーバを有するために認証コードを提供した暗号モジュールによって生成されたワンタイムパスワードと、帯域外の両方で認証するために必要とされ得ます与えられたユーザのために生成されたOTP値に「コミット」。好ましくは、ユーザは、プロセスを妨害するクライアント上の悪意のあるソフトウェアのリスクを最小限にするために、暗号モジュールのキーを初期化するために使用されるものとは別のホストからこの操作を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: This scenario, wherein the attacker replaces a client-provided R_C with his own R'C, does not apply to two-pass DSKPP as the client does not provide any entropy to K_TOKEN. The attack as such (and its countermeasures) still applies to two-pass DSKPP, however, as it essentially is a man-in-the-middle attack.",
      "ja": "注意：クライアントがK_TOKENへのエントロピーを提供していないと、攻撃者は自分のR'Cをクライアントに提供R_Cを置き換わっこのシナリオでは、2パスDSKPPには適用されません。それは本質的にman-in-the-middle攻撃であるような（およびその対策）などの攻撃は依然として、しかし、2パスDSKPPに適用されます。"
    },
    {
      "indent": 3,
      "text": "Another threat arises when an attacker is able to trick a user into authenticating to the attacker rather than to the legitimate service before the DSKPP run. If successful, the attacker will then be able to impersonate the user towards the legitimate service, and subsequently receive a valid DSKPP trigger. If the public key variant of DSKPP is used, this may result in the attacker being able to (after a successful DSKPP run) impersonate the user. Ordinary precautions MUST, therefore, be in place to ensure that users authenticate only to legitimate services.",
      "ja": "攻撃者は、攻撃者にではなく、DSKPPの実行前に合法的なサービスへの認証にユーザーをだますことが可能であるとき、もう一つの脅威が発生します。成功した場合、攻撃者は、その後、正当なサービスへのユーザーを偽装し、その後、有効なDSKPPトリガを受け取ることができるようになります。 DSKPPの公開鍵バリアントが使用されている場合、これは、攻撃者は（成功DSKPPの実行後に）ユーザーを偽装することができることになることがあります。通常の予防策は、そのため、ユーザーが唯一の合法的なサービスに対して認証することを確実にするための場所でなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.6. Miscellaneous Considerations",
      "section_title": true,
      "ja": "10.6。その他の考慮事項"
    },
    {
      "indent": 0,
      "text": "10.6.1. Client Contributions to K_TOKEN Entropy",
      "section_title": true,
      "ja": "10.6.1。 K_TOKENエントロピーへのクライアントの貢献"
    },
    {
      "indent": 3,
      "text": "In four-pass DSKPP, both the client and the server provide randomizing material to K_TOKEN, in a manner that allows both parties to verify that they did contribute to the resulting key. In the two-pass DSKPP version defined herein, only the server contributes to the entropy of K_TOKEN. This means that a broken or compromised (pseudo)random number generator in the server may cause more damage than it would in the four-pass variant. Server implementations SHOULD therefore take extreme care to ensure that this situation does not occur.",
      "ja": "4パスDSKPPでは、クライアントとサーバーの両方が、両当事者は、彼らが結果としてキーに貢献したことを確認することができるような方法で、K_TOKENにランダム化材料を提供します。本明細書で定義された2つのパスDSKPPバージョンでは、唯一のサーバはK_TOKENのエントロピーに寄与する。これは、サーバに（擬似）壊れたまたは損なわ乱数発生器は、それが4パス変異体の場合と比べてより多くの損傷を引き起こすことができることを意味します。サーバ実装は、したがって、このような状況が発生しないことを保証するために細心の注意を取る必要があります。"
    },
    {
      "indent": 0,
      "text": "10.6.2. Key Confirmation",
      "section_title": true,
      "ja": "10.6.2。鍵確認"
    },
    {
      "indent": 3,
      "text": "four-pass DSKPP Servers provide key confirmation through the MAC on R_C in the <KeyProvServerFinished> message. In the two-pass DSKPP variant described herein, key confirmation is provided by the MAC including R, using K_MAC.",
      "ja": "4パスDSKPPサーバーは<KeyProvServerFinished>メッセージでR_CのMACを通じてキー確認を提供します。本明細書に記載された2パスDSKPPの変形例では、鍵確認はK_MACを使用して、Rを含むMACによって提供されます。"
    },
    {
      "indent": 0,
      "text": "10.6.3. Server Authentication",
      "section_title": true,
      "ja": "10.6.3。サーバー認証"
    },
    {
      "indent": 3,
      "text": "DSKPP Servers MUST authenticate themselves whenever a successful DSKPP two-pass protocol run would result in an existing K_TOKEN being replaced by a K_TOKEN', or else a denial-of-service attack where an unauthorized DSKPP Server replaces a K_TOKEN with another key would be possible. In two-pass DSKPP, servers authenticate by including the AuthenticationDataType extension containing a MAC as described in Section 5 for two-pass DSKPP.",
      "ja": "成功DSKPPツーパスプロトコルの実行は既存のK_TOKENがK_TOKEN」に置き換えられていることになるたびDSKPPサーバーは、自分自身を認証しなければならないか、あるいは不正DSKPP Serverが別のキーとK_TOKENを置き換えるサービス拒否攻撃が可能になります。ツーパスDSKPPについては、セクション5で説明したように、二通過DSKPPのでは、サーバーは、MACを含むAuthenticationDataType拡張などによって認証します。"
    },
    {
      "indent": 3,
      "text": "Whenever a successful DSKPP two-pass protocol run would result in an existing K_TOKEN being replaced by a K_TOKEN', the DSKPP Client and Server MUST do the following to prevent a denial-of-service attack where an unauthorized DSKPP Server replaces a K_TOKEN with another key:",
      "ja": "成功DSKPPツーパスプロトコルの実行は、「K_TOKENによって置き換えられ、既存のK_TOKENにつながるたびに、DSKPPクライアントとサーバーが不正DSKPPサーバーが相互にK_TOKENを置き換えるサービス拒否攻撃を防ぐために、次の手順を実行しなければならキー："
    },
    {
      "indent": 3,
      "text": "o The DSKPP Server MUST use the AuthenticationDataType extension to transmit a second MAC, calculated as described in Section 5.2.2.",
      "ja": "O DSKPPサーバは、セクション5.2.2に記載したように算出された第2のMACを送信するAuthenticationDataType拡張子を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The DSKPP Client MUST authenticate the server using the MAC contained in the AuthenticationDataType extension received from the DSKPP Server to which it is connected.",
      "ja": "O DSKPPクライアントは、それが接続されているDSKPPサーバーから受信したAuthenticationDataType拡張子に含まれるMACを使用してサーバーを認証しなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.6.4. User Authentication",
      "section_title": true,
      "ja": "10.6.4。ユーザ認証"
    },
    {
      "indent": 3,
      "text": "A DSKPP Server MUST authenticate a client to ensure that K_TOKEN is delivered to the intended device. The following measures SHOULD be considered:",
      "ja": "DSKPP ServerはK_TOKENが意図したデバイスに配信されることを保証するために、クライアントを認証しなければなりません。次のような対策を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "o When an Authentication Code is used for client authentication, a password dictionary attack on the Authentication Data is possible.",
      "ja": "認証コードがクライアント認証のために使用されている場合は、O、認証データにパスワード辞書攻撃が可能です。"
    },
    {
      "indent": 3,
      "text": "o The length of the Authentication Code when used over a non-secure channel SHOULD be longer than what is used over a secure channel. When a device, e.g., some mobile phones with small screens, cannot handle a long Authentication Code in a user-friendly manner, DSKPP SHOULD rely on a secure channel for communication.",
      "ja": "O非セキュアチャネルを介して使用される認証コードの長さは、安全なチャネルを介して使用されるものよりもべきです。デバイスは、例えば、一部の携帯電話は、小さな画面で、ユーザーフレンドリーな方法で長い認証コードを処理できない場合、DSKPPは、通信のためのセキュアなチャネルに依存しているべきです。"
    },
    {
      "indent": 3,
      "text": "o In the case that a non-secure channel has to be used, the Authentication Code SHOULD be sent to the server MAC'd as specified in Section 3.4.1. The Authentication Code and nonce value MUST be strong enough to prevent offline brute-force recovery of the Authentication Code from the Hashed MAC (HMAC) data. Given that the nonce value is sent in plaintext format over a non-secure transport, the cryptographic strength of the Authentication Data depends more on the quality of the Authentication Code.",
      "ja": "セクション3.4.1で指定されるように、O非セキュアなチャネルを使用しなければならない場合、認証コードは、サーバMAC'dに送信されるべきです。認証コードとナンス値は、ハッシュMAC（HMAC）のデータから、認証コードのオフラインブルートフォース回復を防ぐのに十分に強くなければなりません。一回だけの値が非セキュアトランスポート上でプレーンテキスト形式で送信されていることを考えると、認証データの暗号化強度は、認証コードの品質に多くを依存しています。"
    },
    {
      "indent": 3,
      "text": "o When the Authentication Code is sent from the DSKPP Server to the device in a DSKPP initialization trigger message, an eavesdropper may be able to capture this message and race the legitimate user for a key initialization. To prevent this, the transport layer used to send the DSKPP trigger MUST provide confidentiality and integrity, e.g. a secure browser session.",
      "ja": "認証コードがDSKPP初期トリガメッセージにDSKPPサーバからデバイスに送信されると、O、盗聴者は、このメッセージを捕捉し、鍵初期化のために正当なユーザをレースすることができてもよいです。これを防ぐために、DSKPPトリガを送信するために使用されるトランスポート層は、例えば、機密性と整合性を提供しなければなりませんセキュアなブラウザセッション。"
    },
    {
      "indent": 0,
      "text": "10.6.5. Key Protection in Two-Pass DSKPP",
      "section_title": true,
      "ja": "10.6.5。 2パスDSKPPで鍵の保護"
    },
    {
      "indent": 3,
      "text": "Three key protection methods are defined for the different usages of two-pass DSKPP, which MUST be supported by a key package format, such as [RFC6030] and [RFC6031]. Therefore, key protection in the two-pass DSKPP is dependent upon the security of the key package format selected for a protocol run. Some considerations for the Passphrase-Based Key Wrap method follow.",
      "ja": "3つの主要な保護方法は、[RFC6030]及び[RFC6031]などのキーパッケージフォーマットによってサポートされなければならない2つのパスDSKPPの異なる用途、のために定義されています。したがって、2つのパスDSKPPにおけるキーの保護は、プロトコルの実行のために選択されたキーパッケージ形式のセキュリティに依存しています。パスフレーズベースのキーラップ方式のフォローのためのいくつかの考慮事項。"
    },
    {
      "indent": 3,
      "text": "The Passphrase-Based Key Wrap method SHOULD depend upon the PBKDF2 function from [PKCS-5] to generate an encryption key from a passphrase and salt string. It is important to note that passphrase-based encryption is generally limited in the security that it provides despite the use of salt and iteration count in PBKDF2 to increase the complexity of attack. Implementations SHOULD therefore take additional measures to strengthen the security of the Passphrase-Based Key Wrap method. The following measures SHOULD be considered where applicable:",
      "ja": "パスフレーズベースのキーラップ方式は、パスフレーズと塩文字列から暗号化キーを生成するために、[PKCS-5]からPBKDF2機能に依存すべきです。一般的には、攻撃の複雑さを増加させるためPBKDF2中の塩と繰り返し回数の使用にもかかわらず提供するセキュリティに限定されているパスフレーズベースの暗号化を注意することが重要です。実装は、したがって、パスフレーズベースのキーラップ方式のセキュリティを強化するための追加的措置をとるべきです。次の措置は、該当する場合に考慮すべきです："
    },
    {
      "indent": 3,
      "text": "o The passphrase is the same as the one-time password component of the Authentication Code (see Section 3.4.1) for a description of the AC format). The passphrase SHOULD be selected well, and usage guidelines such as the ones in [NIST-PWD] SHOULD be taken into account.",
      "ja": "Oパスフレーズは認証コードのワンタイムパスワードの成分と同じである）ACフォーマットの説明については、（セクション3.4.1を参照）。パスフレーズは、よく選択されるべきで、そのような[NIST-PWD]におけるものと使用上の注意事項を考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A different passphrase SHOULD be used for every key initialization wherever possible (the use of a global passphrase for a batch of cryptographic modules SHOULD be avoided, for example). One way to achieve this is to use randomly generated passphrases.",
      "ja": "O異なるパスフレーズ（暗号モジュールのバッチのためのグローバルパスフレーズの使用は、例えば、避けるべきである）すべてのキーの初期化可能な限りのために使用されるべきです。これを達成する1つの方法は、ランダムに生成されたパスフレーズを使用することです。"
    },
    {
      "indent": 3,
      "text": "o The passphrase SHOULD be protected well if stored on the server and/or on the cryptographic module and SHOULD be delivered to the device's user using secure methods.",
      "ja": "サーバーおよび/または暗号モジュールに格納され、安全な方法を使用してデバイスのユーザに配信する必要がある場合、Oパスフレーズはよく保護されるべきです。"
    },
    {
      "indent": 3,
      "text": "o User pre-authentication SHOULD be implemented to ensure that K_TOKEN is not delivered to a rogue recipient.",
      "ja": "Oユーザ事前認証はK_TOKENが不正な受信者に配信されないことを保証するために実施されるべきです。"
    },
    {
      "indent": 3,
      "text": "o The iteration count in PBKDF2 SHOULD be high to impose more work for an attacker using brute-force methods (see [PKCS-5] for recommendations). However, it MUST be noted that the higher the count, the more work is required on the legitimate cryptographic module to decrypt the newly delivered K_TOKEN. Servers MAY use relatively low iteration counts to accommodate devices with limited processing power such as some PDA and cell phones when other security measures are implemented and the security of the Passphrase-Based Key Wrap method is not weakened.",
      "ja": "O PBKDF2における反復回数がブルートフォース方法を使用して、攻撃者のためのより多くの作業を課すことが高くなければならない（参照[PKCS-5]推奨事項について）。しかし、数が高いほど、より多くの作業が新たに配信K_TOKENを復号化するために、正当な暗号モジュールに必要であることに留意しなければなりません。サーバーは、他のセキュリティ対策が実装され、パスフレーズベースのキーラップ方式のセキュリティが弱くなっていないときに、このようないくつかのPDAや携帯電話などの限られた処理能力を備えたデバイスに対応するために、比較的低い反復回数を使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "o TLS [RFC5246] SHOULD be used where possible to protect a two-pass protocol run. Transport level security provides a second layer of protection for the newly generated K_TOKEN.",
      "ja": "O TLS [RFC5246]はツーパスプロトコル実行を保護するために、可能な場合に使用されるべきです。トランスポートレベルのセキュリティは、新しく生成されたK_TOKENの保護の第二の層を提供します。"
    },
    {
      "indent": 0,
      "text": "10.6.6. Algorithm Agility",
      "section_title": true,
      "ja": "10.6.6。アルゴリズムアジリティ"
    },
    {
      "indent": 3,
      "text": "Many protocols need to be algorithm agile. One reason for this is that in the past many protocols had fixed sized fields for information such as hash outputs, keys, etc. This is not the case for DSKPP, except for the key size in the computation of DSKPP-PRF. Another reason was that protocols did not support algorithm negotiation. This is also not the case for DSKPP, except for the use of SHA-256 in the MAC confirmation message. Updating the key size for DSKPP-PRF or the MAC confirmation message algorithm will require a new version of the protocol, which is supported with the Version attribute.",
      "ja": "多くのプロトコルは、アルゴリズムアジャイルにする必要があります。その理由の一つは、過去に多くのプロトコルは、これはDSKPP-PRFの計算におけるキーサイズを除いて、DSKPPには当てはまらないなどのハッシュ出力、キー、などの情報のためのサイズフィールドを固定していたということです。もう一つの理由は、プロトコルは、アルゴリズムのネゴシエーションをサポートしていませんでしたということでした。これは、MAC確認メッセージにSHA-256を用いた点を除いて、またDSKPPには当てはまりません。 DSKPP-PRFまたはMAC確認メッセージアルゴリズムのキーサイズを更新すると、バージョン属性でサポートされるプロトコルの新しいバージョンが必要になります。"
    },
    {
      "indent": 0,
      "text": "11. Internationalization Considerations",
      "section_title": true,
      "ja": "11.国際化に関する注意事項"
    },
    {
      "indent": 3,
      "text": "DSKPP is meant for machine-to-machine communications; as such, its elements are tokens not meant for direct human consumption. DSKPP exchanges information using XML. All XML processors are required to understand UTF-8 [RFC3629] encoding, and therefore all DSKPP Clients and servers MUST understand UTF-8 encoded XML. Additionally, DSKPP Servers and clients MUST NOT encode XML with encodings other than UTF-8.",
      "ja": "DSKPPは、マシン・ツー・マシン通信のためのものです。など、その要素は、直接人間の消費のためのものではないトークンです。 DSKPPは、XMLを使用して情報を交換します。すべてのXMLプロセッサは、UTF-8 [RFC3629]エンコードを理解するために必要とされるので、すべてのDSKPPのクライアントとサーバーはUTF-8でエンコードされたXMLを理解する必要があります。また、DSKPPサーバーとクライアントは、UTF-8以外のエンコーディングでXMLをエンコードしてはなりません。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document requires several IANA registrations, detailed below.",
      "ja": "この文書では、以下の詳細ないくつかのIANA登録が必要です。"
    },
    {
      "indent": 0,
      "text": "12.1. URN Sub-Namespace Registration",
      "section_title": true,
      "ja": "12.1。 URNサブ名前空間の登録"
    },
    {
      "indent": 3,
      "text": "This section registers a new XML namespace, \"urn:ietf:params:xml:ns:keyprov:dskpp\" per the guidelines in [RFC3688]:",
      "ja": "このセクションでは、新しいXML名前空間を登録し、 \"URN：IETF：のparams：XML：NS：keyprov：dskpp\" のガイドラインあたり[RFC3688]："
    },
    {
      "indent": 3,
      "text": "URI: urn:ietf:params:xml:ns:keyprov:dskpp Registrant Contact: IETF, KEYPROV Working Group (keyprov@ietf.org), Andrea Doherty (andrea.doherty@rsa.com)",
      "ja": "URI：URN：IETF：のparams：XML：NS：keyprov：dskpp登録者の連絡先：IETF、KEYPROVワーキンググループ（keyprov@ietf.org）、アンドレア・ドハーティ（andrea.doherty@rsa.com）"
    },
    {
      "indent": 3,
      "text": "XML: BEGIN <?xml version=\"1.0\"?> <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"> <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\"> <head> <title>DSKPP Messages</title> </head> <body> <h1>Namespace for DSKPP Messages</h1> <h2>urn:ietf:params:xml:ns:keyprov:dskpp</h2> <p>See RFC 6063</p> </body> </html> END",
      "ja": "！XML：BEGIN <？xmlのバージョン= \"1.0\"> <DOCTYPE用HTML PUBLIC \" -  // W3C // DTD XHTML 1.0厳格// EN\"「http://www.w3.org/TR/xhtml1/DTD/ XHTML1-strict.dtd \"> <HTMLのxmlns =\" http://www.w3.org/1999/xhtml」のxml：langは= \"EN\"> <HEAD> <TITLE> DSKPPメッセージ</ TITLE> </ HEAD> <身体> <H1> DSKPPメッセージの名前空間</ H1> <H2> URN：IETF：のparams：XML：NS：keyprov：dskpp </ H2> <P> RFC 6063 </ P> </ BODY> </を参照してください。 HTML> END"
    },
    {
      "indent": 0,
      "text": "12.2. XML Schema Registration",
      "section_title": true,
      "ja": "12.2。 XML Schemaの登録"
    },
    {
      "indent": 3,
      "text": "This section registers an XML schema as per the guidelines in [RFC3688].",
      "ja": "このセクションでは、[RFC3688]のガイドラインに従ってXMLスキーマを登録します。"
    },
    {
      "indent": 3,
      "text": "URI: urn:ietf:params:xml:ns:keyprov:dskpp Registrant Contact: IETF, KEYPROV Working Group (keyprov@ietf.org), Andrea Doherty (andrea.doherty@rsa.com) Schema: The XML for this schema can be found as the entirety of Section 8 of this document.",
      "ja": "URI：URN：IETF：のparams：XML：NS：keyprov：dskppの登録者の連絡先：IETF、KEYPROVワーキンググループ（keyprov@ietf.org）、アンドレア・ドハーティ（andrea.doherty@rsa.com）スキーマ：このスキーマのXMLすることができますこのドキュメントのセクション8の全体として見ること。"
    },
    {
      "indent": 0,
      "text": "12.3. MIME Media Type Registration",
      "section_title": true,
      "ja": "12.3。 MIMEメディアタイプ登録"
    },
    {
      "indent": 3,
      "text": "This section registers the \"application/dskpp+xml\" MIME type:",
      "ja": "このセクションでは、「アプリケーション/ dskpp + xmlの」MIMEタイプを登録します。"
    },
    {
      "indent": 3,
      "text": "To: ietf-types@iana.org Subject: Registration of MIME media type application/dskpp+xml MIME media type name: application MIME subtype name: dskpp+xml Required parameters: (none) Optional parameters: charset Indicates the character encoding of enclosed XML. Encoding considerations: Uses XML, which can employ 8-bit characters, depending on the character encoding used. See [RFC3023], Section 3.2. Implementations need to support UTF-8 [RFC3629]. Security considerations: This content type is designed to carry protocol data related to key management. Security mechanisms are built into the protocol to ensure that various threats are dealt with. Refer to Section 10 of RFC 6063 for more details Interoperability considerations: None Published specification: RFC 6063. Applications that use this media type: Protocol for key exchange. Additional information: Magic Number(s): (none) File extension(s): .xmls Macintosh File Type Code(s): (none) Person & email address to contact for further information: Andrea Doherty (andrea.doherty@rsa.com) Intended usage: LIMITED USE Author/Change controller: The IETF Other information: This media type is a specialization of application/xml [RFC3023], and many of the considerations described there also apply to application/dskpp+xml.",
      "ja": "To：ietf-types@iana.org件名：MIMEメディアタイプapplication / dskpp +のxml MIMEメディアタイプ名の登録：application MIMEサブタイプ名：dskpp + xmlの必須パラメータ：（なし）オプションのパラメータ：文字セットは、同封の文字コードを示しますXML。エンコードの考慮事項：使用される文字エンコーディングに応じて、8ビット文字を採用することができるXMLを使用しています。 [RFC3023]、セクション3.2を参照してください。実装は、UTF-8 [RFC3629]をサポートする必要があります。セキュリティの考慮事項：このコンテンツタイプは、キー管理に関連するプロトコルデータを伝送するように設計されています。セキュリティ・メカニズムは、様々な脅威が処理されることを保証するために、プロトコルに組み込まれています。詳細の相互運用性を考慮して、RFC 6063のセクション10を参照してください：なし公開された仕様：RFCこのメディアタイプを使用するアプリケーション6063：鍵交換のためのプロトコル。追加情報：マジックナンバー（S）：（なし）ファイルの拡張子（s）は：詳細のために連絡する（なし）人とEメールアドレス：アンドレア・ドハーティ（andrea.doherty@rsa Macintoshはタイプコード（複数可）ファイル.xmls。 COM）意図している用法：限定された使用者/変更コントローラ：IETFその他情報：このメディアタイプは、アプリケーション/ XMLの専門である[RFC3023]、および注意事項の多くは、アプリケーション/ dskpp + XMLに適用されますが説明しました。"
    },
    {
      "indent": 0,
      "text": "12.4. Status Code Registration",
      "section_title": true,
      "ja": "12.4。ステータスコード登録"
    },
    {
      "indent": 3,
      "text": "This section registers status codes included in each DSKPP response message. The status codes are defined in the schema in the <StatusCode> type definition contained in the XML schema in Section 8. The following summarizes the registry:",
      "ja": "このセクションでは、各DSKPP応答メッセージに含まれるステータスコードを登録します。ステータスコードは、次のレジストリをまとめたもので、セクション8にXMLスキーマに含まれる<のStatusCode>型定義のスキーマで定義されています。"
    },
    {
      "indent": 3,
      "text": "Related Registry: KEYPROV DSKPP Registries, Status codes for DSKPP",
      "ja": "関連レジストリ：KEYPROV DSKPPレジストリ、DSKPPのステータス・コード"
    },
    {
      "indent": 3,
      "text": "Defining RFC: RFC 6063. Registration/Assignment Procedures: Following the policies outlined in [RFC3575], the IANA policy for assigning new values for the status codes for DSKPP MUST be \"Specification Required\" and their meanings MUST be documented in an RFC or in some other permanent and readily available reference, in sufficient detail that interoperability between independent implementations is possible. No mechanism to mark entries as \"deprecated\" is envisioned. It is possible to update entries from the registry.",
      "ja": "RFCの定義：RFC 6063登録/割り当て手順：[RFC3575]に概説された方針に従い、DSKPPのためのステータスコードについての新しい値を割り当てるためのIANAポリシーは、「仕様が必要」でなければならないとその意味は、RFCまたはに文書化されなければなりませんいくつかの他の永久的かつ容易に利用可能な基準は、十分詳細に独立している実装の間の相互運用が可能です。 「非推奨」としてエントリをマークするメカニズムが想定されていません。レジストリからエントリを更新することが可能です。"
    },
    {
      "indent": 3,
      "text": "Registrant Contact: IETF, KEYPROV working group (keyprov@ietf.org), Andrea Doherty (andrea.doherty@rsa.com)",
      "ja": "登録者連絡先：IETF、KEYPROVワーキンググループ（keyprov@ietf.org）、アンドレア・ドハーティ（andrea.doherty@rsa.com）"
    },
    {
      "indent": 0,
      "text": "12.5. DSKPP Version Registration",
      "section_title": true,
      "ja": "12.5。 DSKPPバージョンの登録"
    },
    {
      "indent": 3,
      "text": "This section registers DSKPP version numbers.  The registry has the\nfollowing structure:\n+-------------------------------------------+\n|  DSKPP Version    | Specification         |\n+-------------------------------------------+\n|  1.0              | This document         |\n+-------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Standards action is required to define new versions of DSKPP. It is not envisioned to deprecate, delete, or modify existing DSKPP versions.",
      "ja": "標準アクションはDSKPPの新しいバージョンを定義するために必要とされます。廃止、削除、または既存のDSKPPのバージョンを変更することが想定されていません。"
    },
    {
      "indent": 0,
      "text": "12.6. PRF Algorithm ID Sub-Registry",
      "section_title": true,
      "ja": "12.6。 PRFアルゴリズムIDサブレジストリ"
    },
    {
      "indent": 3,
      "text": "This specification relies on a cryptographic primitive, called \"DSKPP-PRF\" that provides a deterministic transformation of a secret key k and a varying length octet string s to a bit string of specified length dsLen. From the point of view of this specification, DSKPP-PRF is a \"black-box\" function that, given the inputs, generates a pseudorandom value that can be realized by any appropriate and competent cryptographic technique. Section 3.4.2 provides two realizations of DSKPP-PRF, DSKPP-PRF-AES, and DSKPP-PRF-SHA256.",
      "ja": "この仕様は、指定された長さdsLenのビット列に決定的秘密鍵Kの変換及び可変長オクテット列sを提供する「DSKPP-PRF」と呼ばれ、プリミティブ暗号に頼っています。本明細書の観点から、DSKPP-PRFは入力所与、任意の適切かつ有能な暗号化技術により実現することができる擬似ランダム値を生成し、「ブラックボックス」機能です。 3.4.2はDSKPP-PRF、DSKPP-PRF-AES、およびDSKPP-PRF-SHA256の2つの実現を提供します。"
    },
    {
      "indent": 3,
      "text": "This section registers the identifiers associated with these realizations. PRF Algorithm ID Sub-registries are to be subject to \"Specification Required\" as per RFC 5226 [RFC5226]. Updates MUST be documented in an RFC or in some other permanent and readily available reference, in sufficient detail that interoperability between independent implementations is possible.",
      "ja": "このセクションでは、これらの実現に関連した識別子を登録します。 PRFアルゴリズムIDサブレジストリは、RFC 5226 [RFC5226]に従って「仕様が必要」を受けることになっています。更新は独立実装間の相互運用性が可能であることを十分に詳細に、RFCまたは何らかの他の永久的かつ容易に入手可能な文献に文書化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Expert approval is required to deprecate a sub-registry. Once deprecated, the PRF Algorithm ID SHOULD NOT be used in any new implementations.",
      "ja": "専門家の承認は、サブレジストリを廃止するために必要とされます。非推奨たら、PRFアルゴリズムIDは、任意の新しい実装では使用しないでください。"
    },
    {
      "indent": 0,
      "text": "12.6.1. DSKPP-PRF-AES",
      "section_title": true,
      "ja": "12.6.1。 DSKPP-PRF-AES"
    },
    {
      "indent": 3,
      "text": "This section registers the following in the IETF XML namespace registry.",
      "ja": "このセクションでは、IETF XML名前空間のレジストリに次のように登録します。"
    },
    {
      "indent": 3,
      "text": "Common Name: DSKPP-PRF-AES",
      "ja": "一般名：DSKPP-PRF-AES"
    },
    {
      "indent": 3,
      "text": "URI: urn:ietf:params:xml:ns:keyprov:dskpp:prf-aes-128",
      "ja": "URI：URN：IETF：のparams：XML：NS：keyprov：dskpp：PRF-AES-128"
    },
    {
      "indent": 3,
      "text": "Identifier Definition: The DSKPP-PRF-AES algorithm realization is defined in Appendix D.2.2 of this document.",
      "ja": "識別子定義：DSKPP-PRF-AESアルゴリズムの実現は、このドキュメントの付録D.2.2に定義されています。"
    },
    {
      "indent": 3,
      "text": "Registrant Contact: IETF, KEYPROV working group (keyprov@ietf.org), Andrea Doherty (andrea.doherty@rsa.com)",
      "ja": "登録者連絡先：IETF、KEYPROVワーキンググループ（keyprov@ietf.org）、アンドレア・ドハーティ（andrea.doherty@rsa.com）"
    },
    {
      "indent": 0,
      "text": "12.6.2. DSKPP-PRF-SHA256",
      "section_title": true,
      "ja": "12.6.2。 DSKPP-PRF-SHA256"
    },
    {
      "indent": 3,
      "text": "This section registers the following in the IETF XML namespace registry.",
      "ja": "このセクションでは、IETF XML名前空間のレジストリに次のように登録します。"
    },
    {
      "indent": 3,
      "text": "Common Name: DSKPP-PRF-SHA256",
      "ja": "一般名：DSKPP-PRF-SHA256"
    },
    {
      "indent": 3,
      "text": "URI: urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256",
      "ja": "URI：URN：IETF：のparams：XML：NS：keyprov：dskpp：PRF-SHA256"
    },
    {
      "indent": 3,
      "text": "Identifier Definition: The DSKPP-PRF-SHA256 algorithm realization is defined in Appendix D.3.2 of this document.",
      "ja": "識別子定義：DSKPP-PRF-SHA256アルゴリズムの実現は、このドキュメントの付録D.3.2に定義されています。"
    },
    {
      "indent": 3,
      "text": "Registrant Contact: IETF, KEYPROV working group (keyprov@ietf.org), Andrea Doherty (andrea.doherty@rsa.com)",
      "ja": "登録者連絡先：IETF、KEYPROVワーキンググループ（keyprov@ietf.org）、アンドレア・ドハーティ（andrea.doherty@rsa.com）"
    },
    {
      "indent": 0,
      "text": "12.7. Key Container Registration",
      "section_title": true,
      "ja": "12.7。キーコンテナの登録"
    },
    {
      "indent": 3,
      "text": "This section registers the Key Container type.",
      "ja": "このセクションでは、キーコンテナタイプを登録します。"
    },
    {
      "indent": 3,
      "text": "Key Container: The registration name for the Key Container.",
      "ja": "キーコンテナ：キーコンテナの登録名。"
    },
    {
      "indent": 3,
      "text": "Specification: Key Container defines a key package format that specifies how a key should be protected using the three key protection methods provided in Section 5.1.",
      "ja": "仕様：キーコンテナは、キーは、セクション5.1に設けられた3つのキーの保護方法を使用して保護する方法を指定するキーパッケージ形式を定義します。"
    },
    {
      "indent": 3,
      "text": "Registration Procedure: Following the policies outlined in [RFC3575], the IANA policy for assigning new values for the status codes for DSKPP MUST be \"Specification Required\" and their meanings MUST be documented in an RFC or in some other permanent and readily available reference, in sufficient detail that interoperability between independent implementations is possible.",
      "ja": "登録手順：[RFC3575]に概説された方針に従い、DSKPPのためのステータスコードについての新しい値を割り当てるためのIANAポリシーは、「仕様が必要」でなければならないとその意味は、RFCや他のいくつかの永続的かつ容易に利用可能な基準に文書化されなければなりません、独立した実装間の相互運用が可能であることを十分に詳細に示します。"
    },
    {
      "indent": 3,
      "text": "Deprecated: TRUE if based on expert approval this entry has been deprecated and SHOULD NOT be used in any new implementations. Otherwise, FALSE.",
      "ja": "非推奨：TRUE専門家の承認に基づいて、このエントリは廃止され、任意の新しい実装では使用しないでください場合。それ以外の場合は、FALSE。"
    },
    {
      "indent": 3,
      "text": "Identifiers: The initial URIs for the Key Container defined for this version of the document are listed here:",
      "ja": "識別子：ドキュメントのこのバージョンのために定義されたキーコンテナの初期のURIは、ここに記載されています："
    },
    {
      "indent": 6,
      "text": "Name: PSKC Key Container URI: urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container Specification: [RFC6030] Deprecated: FALSE",
      "ja": "名前：PSKCキーコンテナURI：URN：IETF：のparams：XML：NS：keyprov：dskpp：pskcキーコンテナ仕様：[RFC6030]非推奨：FALSE"
    },
    {
      "indent": 6,
      "text": "Name: SKPC Key Container URI: urn:ietf:params:xml:ns:keyprov:dskpp:skpc-key-container Specification: [RFC6031] Deprecated: FALSE",
      "ja": "名前：SKPCキーコンテナURI：URN：IETF：のparams：XML：NS：keyprov：dskpp：skpcキーコンテナ仕様：[RFC6031]非推奨：FALSE"
    },
    {
      "indent": 6,
      "text": "Name: PKCS12 Key Container URI: urn:ietf:params:xml:ns:keyprov:dskpp:pkcs12-key-container Specification: [PKCS-12] Deprecated: FALSE",
      "ja": "名前：PKCS12キーコンテナURI：URN：IETF：のparams：XML：NS：keyprov：dskpp：PKCS12キーコンテナ仕様：[PKCS12]非推奨：FALSE"
    },
    {
      "indent": 6,
      "text": "Name: PKCS5-XML Key Container URI: urn:ietf:params:xml:ns:keyprov:dskpp:pkcs5-xml-key-container Specification: [PKCS-5-XML] Deprecated: FALSE",
      "ja": "名前：PKCS5-XMLキーコンテナURI：URN：IETF：のparams：XML：NS：keyprov：dskpp：PKCS5-XML-キーコンテナ仕様：[PKCS5-XML]非推奨：FALSE"
    },
    {
      "indent": 3,
      "text": "Registrant Contact: IETF, KEYPROV working group (keyprov@ietf.org), Andrea Doherty (andrea.doherty@rsa.com)",
      "ja": "登録者連絡先：IETF、KEYPROVワーキンググループ（keyprov@ietf.org）、アンドレア・ドハーティ（andrea.doherty@rsa.com）"
    },
    {
      "indent": 0,
      "text": "13. Intellectual Property Considerations",
      "section_title": true,
      "ja": "13.知的財産権に関する注意事項"
    },
    {
      "indent": 3,
      "text": "RSA and RSA Security are registered trademarks or trademarks of RSA Security, Inc. in the United States and/or other countries. The names of other products and services mentioned may be the trademarks of their respective owners.",
      "ja": "RSAおよびRSAセキュリティは、米国および/またはその他の国における商標またはRSAセキュリティ、Inc.の登録商標です。言及した他の製品およびサービスの名称はそれぞれの所有者の商標である場合があります。"
    },
    {
      "indent": 0,
      "text": "14. Contributors",
      "section_title": true,
      "ja": "14.協力者"
    },
    {
      "indent": 3,
      "text": "This work is based on information contained in [RFC4758], authored by Magnus Nystrom, with enhancements borrowed from an individual document coauthored by Mingliang Pei and Salah Machani (e.g., user authentication, and support for multiple key package formats).",
      "ja": "この作業はMingliangペイとサラーMachaniによって共著個々の文書（例えば、ユーザー認証、および複数のキーパッケージ形式のサポート）から借用の拡張と、マグナスNystrom著[RFC4758]に含まれる情報に基づいています。"
    },
    {
      "indent": 3,
      "text": "We would like to thank Philip Hoyer for his work in aligning DSKPP and PSKC schemas.",
      "ja": "私たちは、DSKPPとPSKCスキーマを揃えるには彼の仕事のためにフィリップ・ホイヤーに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "We would also like to thank Hannes Tschofenig and Phillip Hallam-Baker for their reviews, feedback, and text contributions.",
      "ja": "我々はまた、彼らのレビュー、フィードバック、およびテキストの貢献のためのハンネスTschofenigとフィリップハラム・ベイカーに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "15. Acknowledgements",
      "section_title": true,
      "ja": "15.謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank the following for review of previous DSKPP document versions:",
      "ja": "我々は以前DSKPPドキュメントのバージョンのレビューのために次のことを感謝したいと思います："
    },
    {
      "indent": 3,
      "text": "o Dr. Ulrike Meyer (Review June 2007) o Niklas Neumann (Review June 2007) o Shuh Chang (Review June 2007) o Hannes Tschofenig (Review June 2007 and again in August 2007) o Sean Turner (Reviews August 2007 and again in July 2008) o John Linn (Review August 2007) o Philip Hoyer (Review September 2007) o Thomas Roessler (Review November 2007) o Lakshminath Dondeti (Comments December 2007) o Pasi Eronen (Comments December 2007) o Phillip Hallam-Baker (Review and Edits November 2008 and again in January 2009) o Alexey Melnikov (Review May 2010) o Peter Saint-Andre (Review May 2010)",
      "ja": "Oショーン・ターナーOハンネスTschofenig（2007年8月にレビュー2007年6月と再び）O Shuhチャン（レビュー2007年6月）Oニクラス・ノイマン（レビュー2007年6月）のO先生ウルリケ・マイヤー（レビュー2007年6月）（7月に2007年8月と再びレビュー2008）トーマス・レスラー（レビュー2007年11月）Oフィリップ・ホイヤー（レビュー2007年9月）Oジョン・リン（レビュー2007年8月）O Lakshminath Dondeti（コメント2007年12月）oがパシEronen（2007年12月コメント）Oフィリップハラム - ベイカー（レビューOとピーター・サン・アンドレ（レビュー2010年5月）Oアレクセイ・メルニコフ（レビュー2010年5月）O 2009年1月編集2008年11月と再び）"
    },
    {
      "indent": 3,
      "text": "We would also like to thank the following for their input to selected design aspects of DSKPP:",
      "ja": "また、DSKPPの選択デザイン面への入力のために次のことを感謝したいと思います："
    },
    {
      "indent": 3,
      "text": "o Anders Rundgren (Key Package Format and Client Authentication Data) o Thomas Roessler (HTTP Binding) o Hannes Tschofenig (HTTP Binding) o Phillip Hallam-Baker (Registry for Algorithms) o N. Asokan (original observation of weakness in Authentication Data)",
      "ja": "トーマスレスラー〇〇アンダース・ラングレン（キーパッケージ形式とクライアント認証データ）フィリップ・ハラム - ベイカーN. Asokan O（アルゴリズムのレジストリ）（認証データの弱点の元の観察）O（HTTPバインディング）ハンネスTschofenig O（HTTPバインディング）"
    },
    {
      "indent": 3,
      "text": "Finally, we would like to thank Robert Griffin for opening communication channels for us with the IEEE P1619.3 Key Management Group, and facilitating our groups in staying informed of potential areas (especially key provisioning and global key identifiers of collaboration) of collaboration.",
      "ja": "最後に、我々は、IEEE P1619.3キー管理グループとの私たちのための通信チャネルを開くこと、およびコラボレーションの可能性がある領域（特にキープロビジョニングおよびコラボレーションのグローバルキー識別子）の通知を滞在中に私たちのグループを容易にするためのロバート・グリフィンに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16.参考文献"
    },
    {
      "indent": 0,
      "text": "16.1. Normative References",
      "section_title": true,
      "ja": "16.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[FIPS180-SHA] National Institute of Standards and Technology, \"Secure Hash Standard\", FIPS 180-2, February 2004, <http://csrc.nist.gov/publications/fips/fips180-2/ fips180-2withchangenotice.pdf>.",
      "ja": "[FIPS180-SHA]アメリカ国立標準技術研究所、 \"ハッシュ標準セキュア\" には、<http://csrc.nist.gov/publications/fips/fips180-2/ fips180-2withchangenotice.pdf、2004年2月、180-2をFIPS >。"
    },
    {
      "indent": 3,
      "text": "[FIPS197-AES] National Institute of Standards and Technology, \"Specification for the Advanced Encryption Standard (AES)\", FIPS 197, November 2001, <http:// csrc.nist.gov/publications/fips/fips197/ fips-197.pdf>.",
      "ja": "[FIPS197-AES]は国立標準技術研究所、 \"高度暗号化標準（AES）のための仕様は、\" 2001年11月、197 FIPS、<のhttp：// csrc.nist.gov/publications/fips/fips197/ FIPS-197 .PDF>。"
    },
    {
      "indent": 3,
      "text": "[ISO3309] International Organization for Standardization, \"ISO Information Processing Systems - Data Communication - High-Level Data Link Control Procedure - Frame Structure\", ISO 3309, 3rd Edition, October 1984.",
      "ja": "[ISO3309]国際標準化機構、「ISO情報処理システム - データ通信 - ハイレベルデータリンク制御手順 - フレーム構造」、ISO 3309、第3版、1984年10月。"
    },
    {
      "indent": 3,
      "text": "[PKCS-1] RSA Laboratories, \"RSA Cryptography Standard\", PKCS #1 Version 2.1, June 2002, <http://www.rsasecurity.com/rsalabs/pkcs/>.",
      "ja": "[PKCS-1] RSA Laboratories社、 \"RSA暗号化標準\"、PKCS＃1バージョン2.1、2002年6月、<http://www.rsasecurity.com/rsalabs/pkcs/>。"
    },
    {
      "indent": 3,
      "text": "[PKCS-5] RSA Laboratories, \"Password-Based Cryptography Standard\", PKCS #5 Version 2.0, March 1999, <http://www.rsasecurity.com/rsalabs/pkcs/>.",
      "ja": "[PKCS-5] RSA Laboratories社、 \"パスワードベースの暗号化規格\"、PKCS＃5バージョン2.0、1999年3月、<http://www.rsasecurity.com/rsalabs/pkcs/>。"
    },
    {
      "indent": 3,
      "text": "[PKCS-5-XML] RSA Laboratories, \"XML Schema for PKCS #5 Version 2.0\", PKCS #5 Version 2.0 Amd.1 (FINAL DRAFT), October 2006, <http://www.rsasecurity.com/rsalabs/pkcs/>.",
      "ja": "[PKCS-5-XML] RSA Laboratories社、PKCS＃5バージョン2.0 Amd.1（FINAL DRAFT）、2006年10月、<http://www.rsasecurity.com/rsalabs/ \"PKCS＃5バージョン2.0のXMLスキーマ\" PKCS />。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3394] Schaad, J. and R. Housley, \"Advanced Encryption Standard (AES) Key Wrap Algorithm\", RFC 3394, September 2002.",
      "ja": "[RFC3394] Schaad、J.とR. Housley氏、 \"高度暗号化標準（AES）キーラップアルゴリズム\"、RFC 3394、2002年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4013] Zeilenga, K., \"SASLprep: Stringprep Profile for User Names and Passwords\", RFC 4013, February 2005.",
      "ja": "[RFC4013] Zeilenga、K.、 \"SASLprep：ユーザ名とパスワードのためのstringprepプロフィール\"、RFC 4013、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4210] Adams, C., Farrell, S., Kause, T., and T. Mononen, \"Internet X.509 Public Key Infrastructure Certificate Management Protocol (CMP)\", RFC 4210, September 2005.",
      "ja": "[RFC4210]アダムス、C.、ファレル、S.、Kause、T.、およびT. Mononen、 \"インターネットX.509公開鍵基盤証明書管理プロトコル（CMP）\"、RFC 4210、2005年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5272] Schaad, J. and M. Myers, \"Certificate Management over CMS (CMC)\", RFC 5272, June 2008.",
      "ja": "[RFC5272] Schaad、J.とM.マイヤーズ、 \"CMSオーバー証明書の管理（CMC）\"、RFC 5272、2008年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5649] Housley, R. and M. Dworkin, \"Advanced Encryption Standard (AES) Key Wrap with Padding Algorithm\", RFC 5649, September 2009.",
      "ja": "[RFC5649] Housley氏、R.とM. Dworkin、 \"パディングアルゴリズムとのAdvanced Encryption Standard（AES）キーラップ\"、RFC 5649、2009年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC6030] Hoyer, P., Pei, M., and S. Machani, \"Portable Symmetric Key Container (PSKC)\", RFC 6030, October 2010.",
      "ja": "[RFC6030]ホイヤー、P.、ペイ、M.、およびS. Machani、 \"ポータブル対称キーコンテナ（PSKC）\"、RFC 6030、2010年10月。"
    },
    {
      "indent": 3,
      "text": "[UNICODE] Davis, M. and M. Duerst, \"Unicode Normalization Forms\", March 2001, <http://www.unicode.org/ unicode/reports/tr15/tr15-21.html>.",
      "ja": "[UNICODE]デイビス、M.とM. Duerst、 \"Unicode正規化フォーム、\" 2001年3月、<http://www.unicode.org/フォーム/レポート/ TR15 / tr15-21.html>。"
    },
    {
      "indent": 3,
      "text": "[XML] W3C, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", W3C Recommendation, November 2008, <http://www.w3.org/TR/2006/REC-xml-20060816/>.",
      "ja": "[XML] W3C、 \"拡張マークアップ言語（XML）1.0（第5版）\"、W3C勧告、2008年11月、<http://www.w3.org/TR/2006/REC-xml-20060816/>。"
    },
    {
      "indent": 3,
      "text": "[XMLDSIG] W3C, \"XML Signature Syntax and Processing\", W3C Recommendation, February 2002, <http:// www.w3.org/TR/2002/REC-xmldsig-core-20020212/>.",
      "ja": "[XMLDSIG] W3C、 \"XML署名構文と処理\"、W3C勧告、2002年2月、<のhttp：// www.w3.org/TR/2002/REC-xmldsig-core-20020212/>。"
    },
    {
      "indent": 3,
      "text": "[XMLENC] W3C, \"XML Encryption Syntax and Processing\", W3C Recommendation, December 2002, <http:// www.w3.org/TR/2002/REC-xmldsig-core-20020212/>.",
      "ja": "[XMLENC] W3C、 \"XML暗号化構文と処理\"、W3C勧告、2002年12月、<のhttp：// www.w3.org/TR/2002/REC-xmldsig-core-20020212/>。"
    },
    {
      "indent": 0,
      "text": "16.2. Informative References",
      "section_title": true,
      "ja": "16.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[CT-KIP-P11] RSA Laboratories, \"PKCS #11 Mechanisms for the Cryptographic Token Key Initialization Protocol\", PKCS #11 Version 2.20 Amd.2, December 2005, <http://www.rsasecurity.com/rsalabs/pkcs/>.",
      "ja": "、PKCS＃11バージョン2.20 Amd.2、2005年12月、<http://www.rsasecurity.com/rsalabs/pkcs [CT-KIP-P11] RSA Laboratories社、 \"暗号トークン鍵の初期化プロトコルのためのPKCS＃11メカニズム\" />。"
    },
    {
      "indent": 3,
      "text": "[FAQ] RSA Laboratories, \"Frequently Asked Questions About Today's Cryptography\", Version 4.1, 2000.",
      "ja": "[FAQ] RSA研究所は、バージョン4.1、2000年 \"よく今日の暗号化についてよくあるご質問します\"。"
    },
    {
      "indent": 3,
      "text": "[NIST-PWD] National Institute of Standards and Technology, \"Password Usage\", FIPS 112, May 1985, <http://www.itl.nist.gov/fipspubs/fip112.htm>.",
      "ja": "[NIST-PWD]アメリカ国立標準技術研究所、 \"パスワードの使用\"、FIPS 112、1985年5月、<http://www.itl.nist.gov/fipspubs/fip112.htm>。"
    },
    {
      "indent": 3,
      "text": "[NIST-SP800-38B] International Organization for Standardization, \"Recommendations for Block Cipher Modes of Operation: The CMAC Mode for Authentication\", NIST SP800-38B, May 2005, <http://csrc.nist.gov/ publications/nistpubs/800-38B/SP_800-38B.pdf>.",
      "ja": "[NIST-SP800-38B]国際標準化機構、 \"操作のブロック暗号モードへの提言：認証のためのCMACモード\"、NIST SP800-38B、2005年5月、<http://csrc.nist.gov/出版/ nistpubs /800-38B/SP_800-38B.pdf>。"
    },
    {
      "indent": 3,
      "text": "[NIST-SP800-57] National Institute of Standards and Technology, \"Recommendation for Key Management - Part I: General (Revised)\", NIST 800-57, March 2007, <http: //csrc.nist.gov/publications/nistpubs/800-57/ sp800-57-Part1-revised2_Mar08-2007.pdf>.",
      "ja": "[NIST-SP800-57]米国国立標準技術研究所、 \"キー管理のための推奨事項 - パートI：一般（改訂）\"、NIST 800-57、2007年3月、<のhttp：//csrc.nist.gov/publications/ nistpubs / 800-57 / sp800-57  - パート1  -  revised2_Mar08-2007.pdf>。"
    },
    {
      "indent": 3,
      "text": "[PKCS-11] RSA Laboratories, \"Cryptographic Token Interface Standard\", PKCS #11 Version 2.20, June 2004, <http://www.rsasecurity.com/rsalabs/pkcs/>.",
      "ja": "[PKCS-11] RSA Laboratories社、 \"暗号トークンインターフェイス規格\"、PKCS＃11バージョン2.20、2004年6月、<http://www.rsasecurity.com/rsalabs/pkcs/>。"
    },
    {
      "indent": 3,
      "text": "[PKCS-12] \"Personal Information Exchange Syntax Standard\", PKCS #12 Version 1.0, 2005, <ftp:// ftp.rsasecurity.com/pub/pkcs/pkcs-12/ pkcs-12v1.pdf>.",
      "ja": "[PKCS-12] \"個人情報交換シンタックス標準\"、PKCS＃12バージョン1.0、2005年、<FTP：// ftp.rsasecurity.com/pub/pkcs/pkcs-12/ PKCS-12v1.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.",
      "ja": "[RFC2818]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3023] Murata, M., St. Laurent, S., and D. Kohn, \"XML Media Types\", RFC 3023, January 2001.",
      "ja": "[RFC3023]村田、M.、サンローラン、S.、およびD.コーン、 \"XMLのメディアタイプ\"、RFC 3023、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3575] Aboba, B., \"IANA Considerations for RADIUS (Remote Authentication Dial In User Service)\", RFC 3575, July 2003.",
      "ja": "[RFC3575] Aboba、B.、 \"RADIUSのためのIANAの考慮事項（ユーザサービスにおけるリモート認証ダイヤル）\"、RFC 3575、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3688] Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, January 2004.",
      "ja": "[RFC3688] Mealling、M.、 \"IETF XMLレジストリ\"、BCP 81、RFC 3688、2004年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4758] Nystroem, M., \"Cryptographic Token Key Initialization Protocol (CT-KIP) Version 1.0 Revision 1\", RFC 4758, November 2006.",
      "ja": "[RFC4758] Nystroem、M.、 \"暗号トークンキーの初期化プロトコル（CT-KIP）バージョン1.0改訂1\"、RFC 4758、2006年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6031] Turner, S. and R. , \"Cryptographic Message Syntax (CMS) Symmetric Key Package Content Type\", RFC 6031, December 2010.",
      "ja": "[RFC6031]ターナー、S.とR.、 \"暗号メッセージ構文（CMS）対称鍵パッケージのコンテンツタイプ\"、RFC 6031、2010年12月。"
    },
    {
      "indent": 3,
      "text": "[XMLNS] W3C, \"Namespaces in XML\", W3C Recommendation, January 1999, <http://www.w3.org/TR/2009/REC-xml-names-20091208>.",
      "ja": "[XMLNS] W3C、 \"XMLで名前空間\"、W3C勧告、1999年1月、<http://www.w3.org/TR/2009/REC-xml-names-20091208>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Usage Scenarios",
      "ja": "付録A.の使用シナリオ"
    },
    {
      "indent": 3,
      "text": "DSKPP is expected to be used to provision symmetric keys to cryptographic modules in a number of different scenarios, each with its own special requirements, as described below. This appendix forms an informative part of the document.",
      "ja": "以下に説明するようにDSKPPは、独自の特殊な要件を持つそれぞれ、異なるシナリオの数の暗号化モジュールに提供対称キーに使用されることが期待されます。この付録では、文書の有益な部分を形成します。"
    },
    {
      "indent": 0,
      "text": "A.1. Single Key Request",
      "ja": "A.1。シングルキーリクエスト"
    },
    {
      "indent": 3,
      "text": "The usual scenario is that a cryptographic module makes a request for a symmetric key from a provisioning server that is located on the local network or somewhere on the Internet. Depending upon the deployment scenario, the provisioning server may generate a new key on-the-fly or use a pre-generated key, e.g., one provided by a legacy back-end issuance server. The provisioning server assigns a unique key ID to the symmetric key and provisions it to the cryptographic module.",
      "ja": "通常のシナリオでは、暗号モジュールが、ローカルネットワーク上のどこかインターネット上に配置され、プロビジョニングサーバからの対称鍵を要求するということです。配備シナリオに応じて、プロビジョニング・サーバーは、例えば、従来のバックエンド発行サーバが提供するものをオンザフライで新しいキーを生成したり、事前に生成された鍵を使用してもよいです。プロビジョニング・サーバーは、対称鍵暗号モジュールの規定をする一意の鍵IDを割り当てます。"
    },
    {
      "indent": 0,
      "text": "A.2. Multiple Key Requests",
      "ja": "A.2。複数のキーの要求"
    },
    {
      "indent": 3,
      "text": "A cryptographic module makes multiple requests for symmetric keys from the same provisioning server. The symmetric keys need not be of the same type, i.e., the keys may be used with different symmetric key cryptographic algorithms, including one-time password authentication algorithms, and the AES encryption algorithm.",
      "ja": "暗号モジュールは、同じプロビジョニングサーバからの対称鍵のために複数の要求を行います。対称鍵、すなわち、キーはワンタイムパスワード認証アルゴリズム、およびAES暗号化アルゴリズムを含む異なる対称鍵暗号化アルゴリズムと共に使用することができる、同じタイプである必要はありません。"
    },
    {
      "indent": 0,
      "text": "A.3. User Authentication",
      "ja": "A.3。ユーザ認証"
    },
    {
      "indent": 3,
      "text": "In some deployment scenarios, a key issuer may rely on a third-party provisioning service. In this case, the issuer directs provisioning requests from the cryptographic module to the provisioning service. As such, it is the responsibility of the issuer to authenticate the user through some out-of-band means before granting him rights to acquire keys. Once the issuer has granted those rights, the issuer provides an Authentication Code to the user and makes it available to the provisioning service, so that the user can prove that he is authorized to acquire keys.",
      "ja": "いくつかの展開シナリオでは、キー発行者は、サードパーティのプロビジョニングサービスに依存してもよいです。この場合、発行者は、プロビジョニングサービスへの暗号モジュールからのプロビジョニング要求を指示します。このように、いくつかのアウトオブバンドを介してユーザを認証するために、発行者の責任である彼にキーを取得する権利を付与する前に、意味。発行者がこれらの権利を付与した後、発行者は、ユーザーに認証コードを提供し、ユーザーは、彼が鍵を取得するために許可されていることを証明することができるように、プロビジョニングサービスで使用できるようにします。"
    },
    {
      "indent": 0,
      "text": "A.4. Provisioning Time-Out Policy",
      "ja": "A.4。タイムアウトポリシーのプロビジョニング"
    },
    {
      "indent": 3,
      "text": "An issuer may provide a time-limited Authentication Code to a user during registration, which the user will input into the cryptographic module to authenticate themselves with the provisioning server. The server will allow a key to be provisioned to the cryptographic module hosted by the user's device when user authentication is required only if the user inputs a valid Authentication Code within the fixed time period established by the issuer.",
      "ja": "発行者は、ユーザが暗号モジュールに入力がプロビジョニングサーバで自身を認証するようになる、登録時にユーザに時間制限認証コードを提供してもよいです。サーバは、ユーザ認証は、ユーザが発行者によって確立された一定の時間内に有効な認証コードを入力する場合にのみ必要とされている場合、キーはユーザーのデバイスによってホストされている暗号モジュールにプロビジョニングできるようになります。"
    },
    {
      "indent": 0,
      "text": "A.5. Key Renewal",
      "ja": "A.5。キー更新"
    },
    {
      "indent": 3,
      "text": "A cryptographic module requests renewal of the symmetric key material attached to a key ID, as opposed to keeping the key value constant and refreshing the metadata. Such a need may occur in the case when a user wants to upgrade her device that houses the cryptographic module or when a key has expired. When a user uses the same cryptographic module for example, to perform strong authentication at multiple Web login sites, keeping the same key ID removes the need for the user to register a new key ID at each site.",
      "ja": "キー値を一定に維持し、メタデータのリフレッシュとは対照的に、暗号モジュールは、鍵IDに取り付けられた対称鍵の更新を要求します。ユーザーが暗号モジュールを収容するか、キーの有効期限が切れているとき、彼女のデバイスをアップグレードしたい場合には、このような必要性は、場合に発生する可能性があります。ユーザーが同じキーIDは、各サイトで新しいキーIDを登録するユーザーのための必要性を取り除く維持、複数のWebログインサイトで強力な認証を行うために、例えば同じ暗号モジュールを使用する場合。"
    },
    {
      "indent": 0,
      "text": "A.6. Pre-Loaded Key Replacement",
      "ja": "A.6。プリロードされたキー交換"
    },
    {
      "indent": 3,
      "text": "This scenario represents a special case of symmetric key renewal in which a local administrator can authenticate the user procedurally before initiating the provisioning process. It also allows for a device issuer to pre-load a key onto a cryptographic module with a restriction that the key is replaced with a new key prior to use of the cryptographic module. Another variation of this scenario is the organization who recycles devices. In this case, a key issuer would provision a new symmetric key to a cryptographic module hosted on a device that was previously owned by another user.",
      "ja": "このシナリオでは、ローカル管理者は、プロビジョニング・プロセスを開始する前に手続きユーザを認証可能な対称鍵更新の特殊なケースを表しています。デバイスの発行者は、鍵が暗号モジュールの使用前に新しいキーに置き換えられた制限付き暗号モジュールへの鍵を事前にロードすることも可能となります。このシナリオのもう一つの変化は、デバイスをリサイクルする組織です。この場合、キー発行者は、提供前に、別のユーザーが所有していたデバイス上にホストされている暗号モジュールに新しい対称鍵をでしょう。"
    },
    {
      "indent": 3,
      "text": "Note that this usage scenario is essentially the same as the previous scenario wherein the same key ID is used for renewal.",
      "ja": "この使用シナリオは、本質的に同じキーIDを更新するために使用される前のシナリオと同じであることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "A.7. Pre-Shared Manufacturing Key",
      "ja": "A.7。事前共有鍵製造業"
    },
    {
      "indent": 3,
      "text": "A cryptographic module is loaded onto a smart card after the card is issued to a user. The symmetric key for the cryptographic module will then be provisioned using a secure channel mechanism present in many smart card platforms. This allows a direct secure channel to be established between the smart card chip and the provisioning server. For example, the card commands (i.e., Application Protocol Data Units, or APDUs) are encrypted with a pre-issued card manufacturer's key and sent directly to the smart card chip, allowing secure post-issuance in-the-field provisioning. This secure flow can pass Transport Layer Security (TLS) [RFC5246] and other transport security boundaries.",
      "ja": "カードがユーザに発行された後、暗号モジュールは、スマートカードにロードされます。暗号モジュールのための対称鍵は、多くのスマートカード・プラットフォームに存在するセキュリティで保護されたチャネルのメカニズムを使用してプロビジョニングされます。これは、直接安全なチャネルは、スマートカードチップとプロビジョニングサーバ間で確立することができます。例えば、カードコマンド（すなわち、アプリケーションプロトコルデータユニット、またはのAPDU）は、事前に発行されたカードの製造元の鍵で暗号化され、安全な発行後のインフィールドのプロビジョニングが可能、スマートカードチップに直接送信しました。このセキュアフローは、トランスポート層セキュリティ（TLS）[RFC5246]や他のトランスポートセキュリティの境界を渡すことができます。"
    },
    {
      "indent": 3,
      "text": "Note that two pre-conditions for this usage scenario are for the protocol to be tunneled and the provisioning server to know the correct pre-established manufacturer's key.",
      "ja": "プロトコルは、トンネリングされると、プロビジョニングサーバーが正しい事前に確立されたメーカーのキーを知っているため、この使用シナリオのための2つの前提条件であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "A.8. End-to-End Protection of Key Material",
      "ja": "A.8。暗号化キーのエンドツーエンドの保護"
    },
    {
      "indent": 3,
      "text": "In this scenario, Transport Layer Security does not provide end-to-end protection of keying material transported from the provisioning server to the cryptographic module. For example, TLS may terminate at an application hosted on a PC rather than at the cryptographic module (i.e., the endpoint) located on a data storage device [RFC5246]. Mutually authenticated key agreement provides end-to-end protection, which TLS cannot provide.",
      "ja": "このシナリオでは、トランスポートレイヤセキュリティは、暗号モジュールにプロビジョニングサーバから輸送材料をキーイングのエンド・ツー・エンドの保護を提供していません。例えば、TLSは、PC上ではなく、データ記憶装置[RFC5246]に位置する暗号化モジュール（すなわち、エンドポイント）でホストされるアプリケーションで終了することができます。相互に認証鍵合意は、TLSが提供できないエンド・ツー・エンドの保護を提供します。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Examples",
      "ja": "付録B.例"
    },
    {
      "indent": 3,
      "text": "This appendix contains example messages that illustrate parameters, encoding, and semantics in four- and two-pass DSKPP exchanges. The examples are written using XML, and are syntactically correct. MAC and cipher values are fictitious, however. This appendix forms an informative part of the document.",
      "ja": "この付録では、四二パスDSKPP交換のパラメータ、符号化、及び意味論を示す例示的なメッセージを含んでいます。例は、XMLを使って書かれた、と構文的に正しいされています。 MACおよび暗号値は、しかし、架空のものです。この付録では、文書の有益な部分を形成します。"
    },
    {
      "indent": 0,
      "text": "B.1. Trigger Message",
      "ja": "B.1。トリガーメッセージ"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <dskpp:KeyProvTrigger Version=\"1.0\" xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\" xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"> <dskpp:InitializationTrigger> <dskpp:DeviceIdentifierData> <dskpp:DeviceId> <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer> <pskc:SerialNo>987654321</pskc:SerialNo> <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate> <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate> </dskpp:DeviceId> </dskpp:DeviceIdentifierData> <dskpp:KeyID>SE9UUDAwMDAwMDAx</dskpp:KeyID> <dskpp:TokenPlatformInfo KeyLocation=\"Hardware\" AlgorithmLocation=\"Software\"/> <dskpp:AuthenticationData> <dskpp:ClientID>31300257</dskpp:ClientID> <dskpp:AuthenticationCodeMac> <dskpp:IterationCount>512</dskpp:IterationCount> <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac> </dskpp:AuthenticationCodeMac> </dskpp:AuthenticationData> <dskpp:ServerUrl>keyprovservice.example.com </dskpp:ServerUrl> </dskpp:InitializationTrigger> </dskpp:KeyProvTrigger>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\" スタンドアロン= \"はい\"？> <dskpp：KeyProvTriggerバージョン= \"1.0\" のxmlns：dskpp = \"壷：IETF：のparams：XML：NSを：keyprov：dskpp\" xmlns：pskc = \"壷：IETF：のparams：XML：NS：keyprov：pskc\"> <dskpp：InitializationTrigger> <dskpp：DeviceIdentifierData> <dskpp：DEVICEID> <pskc：メーカー> TokenVendorAcme </ pskc：メーカー> <pskc： SerialNo> 987654321 </ pskc：のSerialNo> <pskc：開始日> 2009-09-01T00：00：00Z </ pskc：開始日> <pskc：ExpiryDate> 2014-09-01T00：00：00Z </ pskc：ExpiryDate> < / dskpp：DEVICEID> </ dskpp：DeviceIdentifierData> <dskpp：鍵ID> SE9UUDAwMDAwMDAx </ dskpp：鍵ID> <dskpp：TokenPlatformInfo KeyLocation = \"ハードウェア\" AlgorithmLocation = \"ソフトウェア\" /> <dskpp：AuthenticationData> <dskpp：クライアントID> 31300257 </ dskpp：ClientIDを> <dskpp：AuthenticationCodeMac> <dskpp：IterationCount> 512 </ dskpp：IterationCount> <dskpp：マック> 4bRJf9xXd3KchKoTenHJiw == </ dskpp：マック> </ dskpp：AuthenticationCodeMac> </ dskpp：AuthenticationData> < dskpp：SERVERURL> keyprovservice.example.com </ dskpp：SERVERURL> </ dskpp：InitializationTrigger> </ DSK PP：KeyProvTrigger>"
    },
    {
      "indent": 0,
      "text": "B.2. Four-Pass Protocol",
      "ja": "B.2。 4パスプロトコル"
    },
    {
      "indent": 0,
      "text": "B.2.1. <KeyProvClientHello> without a Preceding Trigger",
      "ja": "B.2.1。 <KeyProvClientHello>前のトリガなし"
    },
    {
      "indent": 4,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<dskpp:KeyProvClientHello\n    xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n    xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n    xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n    xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n    Version=\"1.0\">\n    <dskpp:DeviceIdentifierData>\n        <dskpp:DeviceId>\n            <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>\n            <pskc:SerialNo>987654321</pskc:SerialNo>\n            <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>\n            <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>\n        </dskpp:DeviceId>\n    </dskpp:DeviceIdentifierData>\n    <dskpp:SupportedKeyTypes>\n        <dskpp:Algorithm>\n            urn:ietf:params:xml:ns:keyprov:pskc:hotp\n        </dskpp:Algorithm>\n        <dskpp:Algorithm>\nhttp://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES\n        </dskpp:Algorithm>\n    </dskpp:SupportedKeyTypes>\n    <dskpp:SupportedEncryptionAlgorithms>\n        <dskpp:Algorithm>\n            http://www.w3.org/2001/04/xmlenc#aes128-cbc\n        </dskpp:Algorithm>\n    </dskpp:SupportedEncryptionAlgorithms>\n    <dskpp:SupportedMacAlgorithms>\n        <dskpp:Algorithm>\n            urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\n        </dskpp:Algorithm>\n    </dskpp:SupportedMacAlgorithms>\n    <dskpp:SupportedProtocolVariants>\n        <dskpp:FourPass/>\n    </dskpp:SupportedProtocolVariants>\n    <dskpp:SupportedKeyPackages>\n        <dskpp:KeyPackageFormat>\n            urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container\n        </dskpp:KeyPackageFormat>\n    </dskpp:SupportedKeyPackages>\n</dskpp:KeyProvClientHello>",
      "raw": true
    },
    {
      "indent": 0,
      "text": "B.2.2. <KeyProvClientHello> Assuming a Preceding Trigger",
      "ja": "B.2.2。 <KeyProvClientHello>前述のトリガーを仮定すると、"
    },
    {
      "indent": 4,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<dskpp:KeyProvClientHello\n    xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n    xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n    xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n    xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n    Version=\"1.0\">\n    <dskpp:DeviceIdentifierData>\n        <dskpp:DeviceId>\n            <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>\n            <pskc:SerialNo>987654321</pskc:SerialNo>\n            <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>\n            <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>\n        </dskpp:DeviceId>\n    </dskpp:DeviceIdentifierData>\n    <dskpp:KeyID>SE9UUDAwMDAwMDAx</dskpp:KeyID>\n    <dskpp:SupportedKeyTypes>\n        <dskpp:Algorithm>\n            urn:ietf:params:xml:ns:keyprov:pskc:hotp\n        </dskpp:Algorithm>\n        <dskpp:Algorithm>\nhttp://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES\n        </dskpp:Algorithm>\n    </dskpp:SupportedKeyTypes>\n    <dskpp:SupportedEncryptionAlgorithms>\n        <dskpp:Algorithm>\n            http://www.w3.org/2001/04/xmlenc#aes128-cbc\n        </dskpp:Algorithm>\n    </dskpp:SupportedEncryptionAlgorithms>\n    <dskpp:SupportedMacAlgorithms>\n        <dskpp:Algorithm>\n            urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\n        </dskpp:Algorithm>\n    </dskpp:SupportedMacAlgorithms>\n    <dskpp:SupportedProtocolVariants>\n      <dskpp:FourPass/>\n    </dskpp:SupportedProtocolVariants>\n    <dskpp:SupportedKeyPackages>\n        <dskpp:KeyPackageFormat>\n            urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container\n        </dskpp:KeyPackageFormat>\n    </dskpp:SupportedKeyPackages>\n</dskpp:KeyProvClientHello>",
      "raw": true
    },
    {
      "indent": 0,
      "text": "B.2.3. <KeyProvServerHello> Without a Preceding Trigger",
      "ja": "B.2.3。 <KeyProvServerHello>前のトリガなし"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <dskpp:KeyProvServerHello xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\" xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\" xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\" xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\" Version=\"1.0\" Status=\"Continue\" SessionID=\"4114\"> <dskpp:KeyType> urn:ietf:params:xml:ns:keyprov:pskc:hotp </dskpp:KeyType> <dskpp:EncryptionAlgorithm> http://www.w3.org/2001/04/xmlenc#aes128-cbc </dskpp:EncryptionAlgorithm> <dskpp:MacAlgorithm> urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256 </dskpp:MacAlgorithm> <dskpp:EncryptionKey> <ds:KeyName>Example-Key1</ds:KeyName> </dskpp:EncryptionKey> <dskpp:KeyPackageFormat> urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container </dskpp:KeyPackageFormat> <dskpp:Payload> <dskpp:Nonce>EjRWeJASNFZ4kBI0VniQEg==</dskpp:Nonce> </dskpp:Payload> </dskpp:KeyProvServerHello>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\" スタンドアロン= \"はい\"？> <dskpp：KeyProvServerHelloのxmlns：pskc = \"壷：IETF：のparams：XML：NS：keyprov：pskc\" のxmlns：dskpp =」 URN：IETF：のparams：XML：NS：keyprov：dskpp \"のxmlns：また、xenc = \"http://www.w3.org/2001/04/xmlenc#\" のxmlns：DS =\" http://www.w3.org / 2000/09 / XMLDSIG＃」バージョン= \"1.0\" ステータス= \"続行\" セッションID = \"4114\"> <dskpp：ます。KeyType> URN：IETF：のparams：XML：NS：keyprov：pskc：HOTP </ dskpp：ます。KeyType> <dskpp：EncryptionAlgorithm> http://www.w3.org/2001/04/xmlenc#aes128-cbc </ dskpp：EncryptionAlgorithm> <dskpp：MacAlgorithm> URN：IETF：のparams：XML：NS：keyprov：dskpp：PRF -sha256 </ dskpp：MacAlgorithm> <dskpp：EncryptionKey> <DS：キー名>例-キー1 </ DS：キー名> </ dskpp：EncryptionKey> <dskpp：KeyPackageFormat> URN：IETF：paramsは：XML：NS：keyprov： dskpp：pskcキーコンテナ</ dskpp：KeyPackageFormat> <dskpp：ペイロード> <dskpp：ナンス> EjRWeJASNFZ4kBI0VniQEg == </ dskpp：ナンス> </ dskpp：ペイロード> </ dskpp：KeyProvServerHello>"
    },
    {
      "indent": 0,
      "text": "B.2.4. <KeyProvServerHello> Assuming Key Renewal",
      "ja": "B.2.4。 <KeyProvServerHello>キー更新を想定すると、"
    },
    {
      "indent": 4,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<dskpp:KeyProvServerHello\n  xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n  xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n  xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n  xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n  Version=\"1.0\"\n  SessionID=\"4114\"\n  Status=\"Continue\">\n  <dskpp:KeyType>\n    urn:ietf:params:xml:schema:keyprov:otpalg#SecurID-AES\n  </dskpp:KeyType>\n  <dskpp:EncryptionAlgorithm>\n     http://www.w3.org/2001/04/xmlenc#aes128-cbc\n  </dskpp:EncryptionAlgorithm>\n  <dskpp:MacAlgorithm>\n     urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\n  </dskpp:MacAlgorithm>\n  <dskpp:EncryptionKey>\n    <ds:KeyName>Example-Key1</ds:KeyName>\n  </dskpp:EncryptionKey>\n  <dskpp:KeyPackageFormat>\n    urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container\n  </dskpp:KeyPackageFormat>\n  <dskpp:Payload>\n    <dskpp:Nonce>qw2ewasde312asder394jw==</dskpp:Nonce>\n  </dskpp:Payload>\n  <dskpp:Mac\n    MacAlgorithm=\"urn:ietf:params:xml:ns:keyprov:dskpp:prf-aes-128\">\n    cXcycmFuZG9tMzEyYXNkZXIzOTRqdw==\n  </dskpp:Mac>\n</dskpp:KeyProvServerHello>",
      "raw": true
    },
    {
      "indent": 0,
      "text": "B.2.5. <KeyProvClientNonce> Using Default Encryption",
      "ja": "B.2.5。 <KeyProvClientNonce>デフォルトの暗号化を使用します"
    },
    {
      "indent": 3,
      "text": "This message contains the nonce chosen by the cryptographic module, R_C, encrypted by the specified encryption key and encryption algorithm.",
      "ja": "このメッセージは、指定された暗号化キーと暗号化アルゴリズムによって暗号化された暗号モジュール、R_C、によって選ばれたナンスが含まれています。"
    },
    {
      "indent": 4,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <dskpp:KeyProvClientNonce xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\" xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\" xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\" xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\" SessionID=\"4114\" Version=\"1.0\"> <dskpp:EncryptedNonce> oTvo+S22nsmS2Z/RtcoF8CTwadRa1PVsRXkZnCihHkU1rPueggrd0NpEWVZR 16Rg16+FHuTg33GK1wH3wffDZQ== </dskpp:EncryptedNonce> </dskpp:KeyProvClientNonce>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\" スタンドアロン= \"はい\"？> <dskpp：KeyProvClientNonceののxmlns：pskc = \"壷：IETF：のparams：XML：NS：keyprov：pskc\" のxmlns：dskpp =」 URN：IETF：のparams：XML：NS：keyprov：dskpp \"のxmlns：また、xenc = \"http://www.w3.org/2001/04/xmlenc#\" のxmlns：DS =\" http://www.w3.org / 2000/09 / XMLDSIG＃」セッションID = \"4114\" バージョン= \"1.0\"> <dskpp：EncryptedNonce> oTvo + S22nsmS2Z / RtcoF8CTwadRa1PVsRXkZnCihHkU1rPueggrd0NpEWVZR 16Rg16 + FHuTg33GK1wH3wffDZQ == </ dskpp：EncryptedNonce> </ dskpp：KeyProvClientNonce>"
    },
    {
      "indent": 0,
      "text": "B.2.6. <KeyProvServerFinished> Using Default Encryption",
      "ja": "B.2.6。 <KeyProvServerFinished>デフォルトの暗号化を使用します"
    },
    {
      "indent": 6,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<dskpp:KeyProvServerFinished\n    xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n    xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n    xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n    xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n    Version=\"1.0\"\n    Status=\"Success\"\n    SessionID=\"4114\">\n    <dskpp:KeyPackage>\n        <dskpp:KeyContainer Version=\"1.0\" Id=\"KC0001\">\n            <pskc:KeyPackage>\n                <pskc:DeviceInfo>\n                    <pskc:Manufacturer>\n                       TokenVendorAcme\n                    </pskc:Manufacturer>\n                    <pskc:SerialNo>\n                       987654321\n                    </pskc:SerialNo>\n                    <pskc:StartDate>\n                       2009-09-01T00:00:00Z\n                    </pskc:StartDate>\n                    <pskc:ExpiryDate>\n                       2014-09-01T00:00:00Z\n                    </pskc:ExpiryDate>\n                </pskc:DeviceInfo>",
      "raw": true
    },
    {
      "indent": 6,
      "text": " <pskc:CryptoModuleInfo> <pskc:Id>CM_ID_001</pskc:Id> </pskc:CryptoModuleInfo> <pskc:Key Id=\"MBK000000001\" Algorithm= \"urn:ietf:params:xml:ns:keyprov:pskc:hotp\"> <pskc:Issuer>Example-Issuer</pskc:Issuer> <pskc:AlgorithmParameters> <pskc:ResponseFormat Length=\"6\" Encoding=\"DECIMAL\"/> </pskc:AlgorithmParameters> <pskc:Data> <pskc:Counter> <pskc:PlainValue>0</pskc:PlainValue> </pskc:Counter> </pskc:Data> <pskc:Policy> <pskc:KeyUsage>OTP</pskc:KeyUsage> </pskc:Policy> </pskc:Key> </pskc:KeyPackage> </dskpp:KeyContainer> </dskpp:KeyPackage> <dskpp:Mac MacAlgorithm= \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\"> 151yAR2NqU5dJzETK+SGYqN6sq6DEH5AgHohra3Jpp4= </dskpp:Mac> </dskpp:KeyProvServerFinished>",
      "ja": "<pskc：CryptoModuleInfo> <pskc：ID> CM_ID_001 </ pskc：ID> </ pskc：CryptoModuleInfo> <pskc：キーID = \"MBK000000001\" アルゴリズム=「壷：IETF：のparams：XML：NS：keyprov：pskc：HOTP \"> <pskc：発行者>実施例-発行</ pskc：発行者> <pskc：ない、AlgorithmParameters> <pskc：ResponseFormat長=\" 6\" エンコード= \"DECIMAL\" /> </ pskc：ない、AlgorithmParameters> <pskc：データ> <pskc ：カウンター> <pskc：PlainValue> 0 </ pskc：PlainValue> </ pskc：カウンタ> </ pskc：データ> <pskc：ポリシー> <pskc：のKeyUsage> OTP </ pskc：KeyUsageの> </ pskc：ポリシー> </ pskc：キー> </ pskc：KeyPackage> </ dskpp：KeyContainer> </ dskpp：KeyPackage> <dskpp：MacのMacAlgorithm = \"壷：IETF：のparams：XML：NS：keyprov：dskpp：PRF-SHA256\"> 151yAR2NqU5dJzETK + SGYqN6sq6DEH5AgHohra3Jpp4 = </ dskpp：マック> </ dskpp：KeyProvServerFinished>"
    },
    {
      "indent": 0,
      "text": "B.3. Two-Pass Protocol",
      "ja": "B.3。ツーパスプロトコル"
    },
    {
      "indent": 0,
      "text": "B.3.1. Example Using the Key Transport Method",
      "ja": "B.3.1。キー転送方法を使った例"
    },
    {
      "indent": 3,
      "text": "The client indicates support for all the Key Transport, Key Wrap, and Passphrase-Based Key Wrap key protection methods:",
      "ja": "クライアントは、すべての主要な交通、キーラップ、およびパスフレーズベースのキーラップキーの保護方法のサポートを示しています。"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <dskpp:KeyProvClientHello xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\" xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\" xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\" xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\" Version=\"1.0\"> <dskpp:DeviceIdentifierData> <dskpp:DeviceId> <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\" スタンドアロン= \"はい\"？> <dskpp：KeyProvClientHelloのxmlns：pskc = \"壷：IETF：のparams：XML：NS：keyprov：pskc\" のxmlns：dskpp =」 URN：IETF：のparams：XML：NS：keyprov：dskpp \"のxmlns：また、xenc = \"http://www.w3.org/2001/04/xmlenc#\" のxmlns：DS =\" http://www.w3.org / 2000/09 /＃」バージョン= \"1.0\"> <dskpp XMLDSIG：DeviceIdentifierData> <dskpp：DEVICEID> <pskc：メーカー> TokenVendorAcme </ pskc：メーカー>"
    },
    {
      "indent": 3,
      "text": " <pskc:SerialNo>987654321</pskc:SerialNo> <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate> <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate> </dskpp:DeviceId> </dskpp:DeviceIdentifierData> <dskpp:SupportedKeyTypes> <dskpp:Algorithm> urn:ietf:params:xml:ns:keyprov:pskc:hotp </dskpp:Algorithm> <dskpp:Algorithm> http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES </dskpp:Algorithm> </dskpp:SupportedKeyTypes> <dskpp:SupportedEncryptionAlgorithms> <dskpp:Algorithm> http://www.w3.org/2001/04/xmlenc#rsa_1_5 </dskpp:Algorithm> </dskpp:SupportedEncryptionAlgorithms> <dskpp:SupportedMacAlgorithms> <dskpp:Algorithm> urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256 </dskpp:Algorithm> </dskpp:SupportedMacAlgorithms> <dskpp:SupportedProtocolVariants> <dskpp:TwoPass> <dskpp:SupportedKeyProtectionMethod> urn:ietf:params:xml:schema:keyprov:dskpp:transport </dskpp:SupportedKeyProtectionMethod> <dskpp:Payload> <ds:KeyInfo> <ds:X509Data> <ds:X509Certificate> MIIB5zCCAVCgAwIBAgIESZp/vDANBgkqhkiG9w0BAQUFADA4MQ0wCwYDVQQKEwRJRVRGM RMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwHhcNMDkwMjE3MD kxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXl Qcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ AoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt/aS6Q/eDsKjsPyFIODsxeKVV/uA 3wLT4jQJM5euKJXkDajzGGOy92+ypfzTX4zDJMkh61SZwlHNJxBKilAM5aW7C+BQ0RvCx vdYtzx2LTdB+X/KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQYJKoZIhvcNAQEFBQADgYE Ae875m84sYUJ8qPeZ+NG7REgTvlHTmoCdoByU0LBBLotUKuqfrnRuXJRMeZXaaEGmzY1k LonVjQGzjAkU4dJ+RPmiDlYuHLZS41Pg6VMwY+03lhk6I5A/w4rnqdkmwZX/NgXg06aln c2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo= </ds:X509Certificate> </ds:X509Data> </ds:KeyInfo> </dskpp:Payload> </dskpp:TwoPass> </dskpp:SupportedProtocolVariants>",
      "ja": "<pskc：のSerialNo> 987654321 </ pskc：のSerialNo> <pskc：開始日> 2009-09-01T00：00：00Z </ pskc：開始日> <pskc：ExpiryDate> 2014-09-01T00：00：00Z </ pskc。 ExpiryDate> </ dskpp：DEVICEID> </ dskpp：DeviceIdentifierData> <dskpp：SupportedKeyTypes> <dskpp：アルゴリズム> URN：IETF：のparams：XML：NS：keyprov：pskc：HOTP </ dskpp：アルゴリズム> <dskpp：アルゴリズム> http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES </ dskpp：アルゴリズム> </ dskpp：SupportedKeyTypes> <dskpp：SupportedEncryptionAlgorithms> <dskpp：アルゴリズム> HTTP ：//www.w3.org/2001/04/xmlenc#rsa_1_5 </ dskpp：アルゴリズム> </ dskpp：SupportedEncryptionAlgorithms> <dskpp：SupportedMacAlgorithms> <dskpp：アルゴリズム> URN：IETF：paramsは：XML：NS：keyprov： dskpp：PRF-SHA256 </ dskpp：アルゴリズム> </ dskpp：SupportedMacAlgorithms> <dskpp：SupportedProtocolVariants> <dskpp：2パス> <dskpp：SupportedKeyProtectionMethod> URN：IETF：paramsは：XML：スキーマ：keyprov：dskpp：トランスポート</ dskpp ：SupportedKeyProtectionMethod> <dskpp：ペイロード> <DS：KeyInfoの> <DS：X509Data> <DS：のX509Certificate> MIIB5zCCAVCgAwIBAgIES ZP / vDANBgkqhkiG9w0BAQUFADA4MQ0wCwYDVQQKEwRJRVRGM RMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwHhcNMDkwMjE3MD kxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXl Qcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ AoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt / aS6Q / eDsKjsPyFIODsxeKVV /マイクロアンペア3wLT4jQJM5euKJXkDajzGGOy92 + ypfzTX4zDJMkh61SZwlHNJxBKilAM5aW7C + BQ0RvCx vdYtzx2LTdB + X / KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQYJKoZIhvcNAQEFBQADgYE Ae875m84sYUJ8qPeZ + NG7REgTvlHTmoCdoByU0LBBLotUKuqfrnRuXJRMeZXaaEGmzY1k LonVjQGzjAkU4dJ + RPmiDlYuHLZS41Pg6VMwY + 03lhk6I5A / w4rnqdkmwZX / NgXg06aln c2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo = </ DS：のX509Certificate> </ DS：X509Data> < / DS：KeyInfoの> </ dskpp：ペイロード> </ dskpp：2パス> </ dskpp：SupportedProtocolVariants>"
    },
    {
      "indent": 3,
      "text": " <dskpp:SupportedKeyPackages> <dskpp:KeyPackageFormat> urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container </dskpp:KeyPackageFormat> </dskpp:SupportedKeyPackages> <dskpp:AuthenticationData> <dskpp:ClientID>AC00000A</dskpp:ClientID> <dskpp:AuthenticationCodeMac> <dskpp:Nonce> ESIzRFVmd4iZqrvM3e7/ESIzRFVmd4iZqrvM3e7/ESI= </dskpp:Nonce> <dskpp:IterationCount>100000</dskpp:IterationCount> <dskpp:Mac MacAlgorithm= \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\"> 3eRz51ILqiG+dJW2iLcjuA== </dskpp:Mac> </dskpp:AuthenticationCodeMac> </dskpp:AuthenticationData> </dskpp:KeyProvClientHello>",
      "ja": "<dskpp：SupportedKeyPackages> <dskpp：KeyPackageFormat> URN：IETF：paramsは：XML：NS：keyprov：dskpp：pskcキーコンテナ</ dskpp：KeyPackageFormat> </ dskpp：SupportedKeyPackages> <dskpp：AuthenticationData> <dskpp：のClientID > AC00000A </ dskpp：ClientIDを> <dskpp：AuthenticationCodeMac> <dskpp：ナンス> ESIzRFVmd4iZqrvM3e7 / ESIzRFVmd4iZqrvM3e7 / ESI = </ dskpp：ナンス> <dskpp：IterationCount> 100000 </ dskpp：IterationCount> <dskpp：MacのMacAlgorithm =「壷：IETF：のparams：XML：NS：keyprov：dskpp：PRF-SHA256\" > 3eRz51ILqiG + dJW2iLcjuA == </ dskpp：マック> </ dskpp：AuthenticationCodeMac> </ dskpp：AuthenticationData> </ dskpp：KeyProvClientHello>"
    },
    {
      "indent": 3,
      "text": "In this example, the server responds to the previous request by returning a key package in which the provisioning key was encrypted using the Key Transport key protection method.",
      "ja": "この例では、サーバーは、プロビジョニングキーはキー交通キーの保護方法を使用して暗号化されたキーパッケージを返すことによって、前の要求に応答します。"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <dskpp:KeyProvServerFinished xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\" xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\" xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\" xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\" xmlns:dkey=\"http://www.w3.org/2009/xmlsec-derivedkey#\" xmlns:pkcs5= \"http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#\" Version=\"1.0\" Status=\"Success\" SessionID=\"4114\"> <dskpp:KeyPackage> <dskpp:KeyContainer Version=\"1.0\" Id=\"KC0001\"> <pskc:EncryptionKey> <ds:X509Data> <ds:X509Certificate> MIIB5zCCAVCgAwIBAgIESZp/vDANBgkqhkiG9w0BAQUFADA4MQ0wCwYDVQQKEwRJRVRGM RMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwHhcNMDkwMjE3MD kxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXl Qcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ AoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt/aS6Q/eDsKjsPyFIODsxeKVV/uA 3wLT4jQJM5euKJXkDajzGGOy92+ypfzTX4zDJMkh61SZwlHNJxBKilAM5aW7C+BQ0RvCx vdYtzx2LTdB+X/KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQYJKoZIhvcNAQEFBQADgYE Ae875m84sYUJ8qPeZ+NG7REgTvlHTmoCdoByU0LBBLotUKuqfrnRuXJRMeZXaaEGmzY1k LonVjQGzjAkU4dJ+RPmiDlYuHLZS41Pg6VMwY+03lhk6I5A/w4rnqdkmwZX/NgXg06aln c2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo= </ds:X509Certificate> </ds:X509Data> </pskc:EncryptionKey> <pskc:KeyPackage> <pskc:DeviceInfo> <pskc:Manufacturer> TokenVendorAcme </pskc:Manufacturer> <pskc:SerialNo> 987654321 </pskc:SerialNo> <pskc:StartDate> 2009-09-01T00:00:00Z </pskc:StartDate> <pskc:ExpiryDate> 2014-09-01T00:00:00Z </pskc:ExpiryDate> </pskc:DeviceInfo> <pskc:Key Id=\"MBK000000001\" Algorithm= \"urn:ietf:params:xml:ns:keyprov:pskc:hotp\"> <pskc:Issuer>Example-Issuer</pskc:Issuer> <pskc:AlgorithmParameters> <pskc:ResponseFormat Length=\"6\" Encoding=\"DECIMAL\"/> </pskc:AlgorithmParameters> <pskc:Data> <pskc:Secret> <pskc:EncryptedValue> <xenc:EncryptionMethod Algorithm= \"http://www.w3.org/2001/04/xmlenc#rsa_1_5\"/> <xenc:CipherData> <xenc:CipherValue> eyjr23WMy9S2UdKgGnQEbs44T1jmX1TNWEBq48xfS20PK2VWF4ZK1iSctHj/u3uk+7+y8 uKrAzHEm5mujKPAU4DCbb5mSibXMnAbbIoAi2cJW60/l8FlzwaU4EZsZ1LyQ1GcBQKACE eylG5vK8NTo47vZTatL5UxmbmOX2HvaVQ= </xenc:CipherValue> </xenc:CipherData> </pskc:EncryptedValue> </pskc:Secret> <pskc:Counter> <pskc:PlainValue>0</pskc:PlainValue>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\" スタンドアロン= \"はい\"？> <dskpp：KeyProvServerFinishedのxmlns：pskc = \"壷：IETF：のparams：XML：NS：keyprov：pskc\" のxmlns：dskpp =」 URN：IETF：のparams：XML：NS：keyprov：dskpp \"のxmlns：また、xenc = \"http://www.w3.org/2001/04/xmlenc#\" のxmlns：DS =\" http://www.w3.org / 2000/09 / XMLDSIG番号 \"のxmlns：DKEY = \"http://www.w3.org/2009/xmlsec-derivedkey#\" のxmlns：PKCS5 =\" http://www.rsasecurity.com/rsalabs/pkcs/schemas / PKCS-5v2-0＃」バージョン= \"1.0\" ステータス= \"成功\" のSessionID = \"4114\"> <dskpp：KeyPackage> <dskpp：KeyContainerバージョン= \"1.0\" ID = \"KC0001\"> <pskc：EncryptionKey> < DS：X509Data> <DS：のX509Certificate> MIIB5zCCAVCgAwIBAgIESZp / vDANBgkqhkiG9w0BAQUFADA4MQ0wCwYDVQQKEwRJRVRGM RMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwHhcNMDkwMjE3MD kxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXl Qcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ AoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt / aS6Q / eDsKjsPyFIODsxeKVV / uAで3wLT4jQJM5euKJXkDajzGGOy92 + ypfzTX4zDJMkh61SZwlHNJxBKilAM5aW7C + BQ0RvCx V dYtzx2LTdB + X / KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQYJKoZIhvcNAQEFBQADgYE Ae875m84sYUJ8qPeZ + NG7REgTvlHTmoCdoByU0LBBLotUKuqfrnRuXJRMeZXaaEGmzY1k LonVjQGzjAkU4dJ + RPmiDlYuHLZS41Pg6VMwY + 03lhk6I5A / w4rnqdkmwZX / NgXg06aln c2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo = </ DS：のX509Certificate> </ DS：X509Data> </ pskc：EncryptionKey> <pskc：KeyPackage> <pskc：DEVICEINFO> <pskc。メーカー> TokenVendorAcme </ pskc：メーカー> <pskc：のSerialNo> 987654321 </ pskc：のSerialNo> <pskc：開始日> 2009-09-01T00：00：00Z </ pskc：開始日> <pskc：ExpiryDate> 2014-09- 01T00：00：00Z </ pskc：ExpiryDate> </ pskc：DEVICEINFO> <pskc：キーID = \"MBK000000001\" アルゴリズム= \"壷：IETF：のparams：XML：NS：keyprov：pskc：HOTP\"> <pskc：発行者>例 - 発行者</ pskc：発行者> <pskc：ない、AlgorithmParameters> <pskc：ResponseFormat長= \"6\" エンコード= \"DECIMAL\" /> </ pskc：ない、AlgorithmParameters> <pskc：データ> <pskc：秘密> <pskc。 EncryptedValue> <また、xenc：はEncryptionMethodアルゴリズム= \"http://www.w3.org/2001/04/xmlenc#rsa_1_5\" /> <また、xenc：CipherData> <また、xenc：CipherValue> eyjr23WMy9S2UdKgGnQEbs44T1jmX1 TNWEBq48xfS20PK2VWF4ZK1iSctHj / u3uk + 7 + Y8 uKrAzHEm5mujKPAU4DCbb5mSibXMnAbbIoAi2cJW60 / l8FlzwaU4EZsZ1LyQ1GcBQKACE eylG5vK8NTo47vZTatL5UxmbmOX2HvaVQ = </また、xenc：CipherValue> </また、xenc：CipherData> </ pskc：EncryptedValue> </ pskc：シークレット> <pskc：カウンタ> <pskc：PlainValue> 0 </ pskc ：PlainValue>"
    },
    {
      "indent": 3,
      "text": " </pskc:Counter> </pskc:Data> <pskc:Policy> <pskc:KeyUsage>OTP</pskc:KeyUsage> </pskc:Policy> </pskc:Key> </pskc:KeyPackage> </dskpp:KeyContainer> </dskpp:KeyPackage> <dskpp:Mac MacAlgorithm= \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\"> GHZ0H6Y+KpxdlVZ7zgcJDiDdqc8Gcmlcf+HQi4EUxYU= </dskpp:Mac> </dskpp:KeyProvServerFinished>",
      "ja": "</ pskc：カウンタ> </ pskc：データ> <pskc：ポリシー> <pskc：のKeyUsage> OTP </ pskc：KeyUsageの> </ pskc：ポリシー> </ pskc：キー> </ pskc：KeyPackage> </ dskpp ：KeyContainer> </ dskpp：KeyPackage> <dskpp：MacのMacAlgorithm = \"壷：IETF：のparams：XML：NS：keyprov：dskpp：PRF-SHA256を\"> GHZ0H6Y + KpxdlVZ7zgcJDiDdqc8Gcmlcf + HQi4EUxYU = </ dskpp：マック> </ dskpp ：KeyProvServerFinished>"
    },
    {
      "indent": 0,
      "text": "B.3.2. Example Using the Key Wrap Method",
      "ja": "B.3.2。キーラップメソッドの使用例"
    },
    {
      "indent": 3,
      "text": "The client sends a request that specifies a shared key to protect the K_TOKEN, and the server responds using the Key Wrap key protection method. Authentication Data in this example is based on an Authentication Code rather than a device certificate.",
      "ja": "クライアントはK_TOKENを保護するために、共有キーを指定する要求を送信し、サーバはキーラップキーの保護方法を使用して応答します。この例では、認証データは認証コードではなく、装置証明書に基づいています。"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <dskpp:KeyProvClientHello xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\" xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\" xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\" xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\" Version=\"1.0\"> <dskpp:DeviceIdentifierData> <dskpp:DeviceId> <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer> <pskc:SerialNo>987654321</pskc:SerialNo> <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate> <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate> </dskpp:DeviceId> </dskpp:DeviceIdentifierData> <dskpp:SupportedKeyTypes> <dskpp:Algorithm> urn:ietf:params:xml:ns:keyprov:pskc:hotp </dskpp:Algorithm> <dskpp:Algorithm> http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES </dskpp:Algorithm> </dskpp:SupportedKeyTypes> <dskpp:SupportedEncryptionAlgorithms> <dskpp:Algorithm>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\" スタンドアロン= \"はい\"？> <dskpp：KeyProvClientHelloのxmlns：pskc = \"壷：IETF：のparams：XML：NS：keyprov：pskc\" のxmlns：dskpp =」 URN：IETF：のparams：XML：NS：keyprov：dskpp \"のxmlns：また、xenc = \"http://www.w3.org/2001/04/xmlenc#\" のxmlns：DS =\" http://www.w3.org / 2000/09 /＃」バージョン= \"1.0\"> <dskpp XMLDSIG：DeviceIdentifierData> <dskpp：DEVICEID> <pskc：メーカー> TokenVendorAcme </ pskc：メーカー> <pskc：のSerialNo> 987654321 </ pskc：のSerialNo> <pskc ：開始日> 2009-09-01T00：00：00Z </ pskc：開始日> <pskc：ExpiryDate> 2014-09-01T00：00：00Z </ pskc：ExpiryDate> </ dskpp：デバイスID> </ dskpp：DeviceIdentifierData> <dskpp：SupportedKeyTypes> <dskpp：アルゴリズム> URN：IETF：paramsは：XML：NS：keyprov：pskc：HOTP </ dskpp：アルゴリズム> <dskpp：アルゴリズム> http://www.rsa.com/rsalabs/otps/スキーマ/ 2005/09 / OTPを-WST＃SecurIDの-AES </ dskpp：アルゴリズム> </ dskpp：SupportedKeyTypes> <dskpp：SupportedEncryptionAlgorithms> <dskpp：アルゴリズム>"
    },
    {
      "indent": 3,
      "text": " http://www.w3.org/2001/04/xmlenc#aes128-cbc </dskpp:Algorithm> </dskpp:SupportedEncryptionAlgorithms> <dskpp:SupportedMacAlgorithms> <dskpp:Algorithm> urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256 </dskpp:Algorithm> </dskpp:SupportedMacAlgorithms> <dskpp:SupportedProtocolVariants> <dskpp:TwoPass> <dskpp:SupportedKeyProtectionMethod> urn:ietf:params:xml:schema:keyprov:dskpp:wrap </dskpp:SupportedKeyProtectionMethod> <dskpp:Payload> <ds:KeyInfo> <ds:KeyName>Pre-shared-key-1</ds:KeyName> </ds:KeyInfo> </dskpp:Payload> </dskpp:TwoPass> </dskpp:SupportedProtocolVariants> <dskpp:SupportedKeyPackages> <dskpp:KeyPackageFormat> urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container </dskpp:KeyPackageFormat> </dskpp:SupportedKeyPackages> <dskpp:AuthenticationData> <dskpp:ClientID>AC00000A</dskpp:ClientID> <dskpp:AuthenticationCodeMac> <dskpp:Nonce> ESIzRFVmd4iZqrvM3e7/ESIzRFVmd4iZqrvM3e7/ESI= </dskpp:Nonce> <dskpp:IterationCount>1</dskpp:IterationCount> <dskpp:Mac MacAlgorithm= \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\"> 3eRz51ILqiG+dJW2iLcjuA== </dskpp:Mac> </dskpp:AuthenticationCodeMac> </dskpp:AuthenticationData> </dskpp:KeyProvClientHello>",
      "ja": "http://www.w3.org/2001/04/xmlenc#aes128-cbc </ dskpp：アルゴリズム> </ dskpp：SupportedEncryptionAlgorithms> <dskpp：SupportedMacAlgorithms> <dskpp：アルゴリズム> URN：IETF：のparams：XML：NS ：keyprov：dskpp：PRF-SHA256 </ dskpp：アルゴリズム> </ dskpp：SupportedMacAlgorithms> <dskpp：SupportedProtocolVariants> <dskpp：2パス> <dskpp：SupportedKeyProtectionMethod> URN：IETF：のparams：XML：スキーマ：keyprov：dskpp：ラップ</ dskpp：SupportedKeyProtectionMethod> <dskpp：ペイロード> <DS：のKeyInfo> <DS：キー名>事前共有鍵-1 </ DS：キー名> </ DS：のKeyInfo> </ dskpp：ペイロード> </ dskpp。 2パス> </ dskpp：SupportedProtocolVariants> <dskpp：SupportedKeyPackages> <dskpp：KeyPackageFormat> URN：IETF：のparams：XML：NS：keyprov：dskpp：pskcキーコンテナ</ dskpp：KeyPackageFormat> </ dskpp：SupportedKeyPackages> < dskpp：AuthenticationData> <dskpp：クライアントID> AC00000A </ dskpp：クライアントID> <dskpp：AuthenticationCodeMac> <dskpp：ノンス> ESIzRFVmd4iZqrvM3e7 / ESIzRFVmd4iZqrvM3e7 / ESI = </ dskpp：ノンス> <dskpp：IterationCount> 1 </ dskpp：IterationCount> <dskpp：MacのMacAlgorithm =「壷：IETF：パラMS：XML：NS：keyprov：dskpp：PRF-SHA256\" > 3eRz51ILqiG + dJW2iLcjuA == </ dskpp：マック> </ dskpp：AuthenticationCodeMac> </ dskpp：AuthenticationData> </ dskpp：KeyProvClientHello>"
    },
    {
      "indent": 3,
      "text": "In this example, the server responds to the previous request by returning a key package in which the provisioning key was encrypted using the Key Wrap key protection method.",
      "ja": "この例では、サーバーは、プロビジョニングキーはキーラップキーの保護方法を使用して暗号化されたキーパッケージを返すことによって、前の要求に応答します。"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <dskpp:KeyProvServerFinished xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\" xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\" xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\" xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\" xmlns:dkey=\"http://www.w3.org/2009/xmlsec-derivedkey#\" xmlns:pkcs5= \"http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#\" Version=\"1.0\" Status=\"Success\" SessionID=\"4114\"> <dskpp:KeyPackage> <dskpp:KeyContainer Version=\"1.0\" Id=\"KC0001\"> <pskc:EncryptionKey> <ds:KeyName>Pre-shared-key-1</ds:KeyName> </pskc:EncryptionKey> <pskc:MACMethod Algorithm= \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\"> <pskc:MACKey> <xenc:EncryptionMethod Algorithm= \"http://www.w3.org/2001/04/xmlenc#aes128-cbc\"/> <xenc:CipherData> <xenc:CipherValue> 2GTTnLwM3I4e5IO5FkufoMUBJBuAf25hARFv0Z7MFk9Ecdb04PWY/qaeCbrgz7Es </xenc:CipherValue> </xenc:CipherData> </pskc:MACKey> </pskc:MACMethod> <pskc:KeyPackage> <pskc:DeviceInfo> <pskc:Manufacturer> TokenVendorAcme </pskc:Manufacturer> <pskc:SerialNo> 987654321 </pskc:SerialNo> <pskc:StartDate> 2009-09-01T00:00:00Z </pskc:StartDate> <pskc:ExpiryDate> 2014-09-01T00:00:00Z </pskc:ExpiryDate> </pskc:DeviceInfo> <pskc:CryptoModuleInfo> <pskc:Id>CM_ID_001</pskc:Id> </pskc:CryptoModuleInfo> <pskc:Key Id=\"MBK000000001\"",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\" スタンドアロン= \"はい\"？> <dskpp：KeyProvServerFinishedのxmlns：pskc = \"壷：IETF：のparams：XML：NS：keyprov：pskc\" のxmlns：dskpp =」 URN：IETF：のparams：XML：NS：keyprov：dskpp \"のxmlns：また、xenc = \"http://www.w3.org/2001/04/xmlenc#\" のxmlns：DS =\" http://www.w3.org / 2000/09 / XMLDSIG番号 \"のxmlns：DKEY = \"http://www.w3.org/2009/xmlsec-derivedkey#\" のxmlns：PKCS5 =\" http://www.rsasecurity.com/rsalabs/pkcs/schemas / PKCS-5v2-0＃」バージョン= \"1.0\" ステータス= \"成功\" のSessionID = \"4114\"> <dskpp：KeyPackage> <dskpp：KeyContainerバージョン= \"1.0\" ID = \"KC0001\"> <pskc：EncryptionKey> < DS：キー名>事前共有鍵-1 </ DS：キー名> </ pskc：EncryptionKey> <pskc：MACMethodアルゴリズム= \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\" > <pskc：マッキー> <また、xenc：はEncryptionMethodアルゴリズム= \"http://www.w3.org/2001/04/xmlenc#aes128-cbc\" /> <また、xenc：CipherData> <また、xenc：CipherValue> 2GTTnLwM3I4e5IO5FkufoMUBJBuAf25hARFv0Z7MFk9Ecdb04PWY / qaeCbrgz7Es </また、xenc：CipherValue> </また、xenc：CipherData> </ pskc：マッキー> </ pskc：MACMethod> <pskc：KeyPackage> <pskc：DEVICEINFO> <pskc：Manufa cturer> TokenVendorAcme </ pskc：メーカー> <pskc：のSerialNo> 987654321 </ pskc：のSerialNo> <pskc：開始日> 2009-09-01T00：00：00Z </ pskc：開始日> <pskc：ExpiryDate> 2014-09- 01T00：00：00Z </ pskc：ExpiryDate> </ pskc：DEVICEINFO> <pskc：CryptoModuleInfo> <pskc：ID> CM_ID_001 </ pskc：ID> </ pskc：CryptoModuleInfo> <pskc：キーID = \"MBK000000001\""
    },
    {
      "indent": 3,
      "text": " Algorithm= \"urn:ietf:params:xml:ns:keyprov:pskc:hotp\"> <pskc:Issuer>Example-Issuer</pskc:Issuer> <pskc:AlgorithmParameters> <pskc:ResponseFormat Length=\"6\" Encoding=\"DECIMAL\"/> </pskc:AlgorithmParameters> <pskc:Data> <pskc:Secret> <pskc:EncryptedValue> <xenc:EncryptionMethod Algorithm= \"http://www.w3.org/2001/04/xmlenc#aes128-cbc\"/> <xenc:CipherData> <xenc:CipherValue> oTvo+S22nsmS2Z/RtcoF8AabC6vr 09sh0QIU+E224S96sZjpV+6nFYgn 6525OoepbPnL/fGuuey64WCYXoqh Tg== </xenc:CipherValue> </xenc:CipherData> </pskc:EncryptedValue> <pskc:ValueMAC> o+e9xgMVUbYuZH9UHe0W9dIo88A= </pskc:ValueMAC> </pskc:Secret> <pskc:Counter> <pskc:PlainValue>0</pskc:PlainValue> </pskc:Counter> </pskc:Data> <pskc:Policy> <pskc:KeyUsage>OTP</pskc:KeyUsage> </pskc:Policy> </pskc:Key> </pskc:KeyPackage> </dskpp:KeyContainer> </dskpp:KeyPackage> <dskpp:Mac MacAlgorithm= \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\"> l53BmSO6qUzoIgbQegimsKk2es+WRpEl0YFqaOp5PGE= </dskpp:Mac> </dskpp:KeyProvServerFinished>",
      "ja": "アルゴリズム= \"URN：IETF：paramsは：XML：NS：keyprov：pskc：HOTP\"> <pskc：発行者>実施例-発行</ pskc：発行者> <pskc：ない、AlgorithmParameters> <pskc：ResponseFormat長= \"6\" エンコード= \"DECIMAL\" /> </ pskc：ない、AlgorithmParameters> <pskc：データ> <pskc：シークレット> <pskc：EncryptedValue> <また、xenc：はEncryptionMethodアルゴリズム=「http://www.w3.org/2001/04/xmlenc#aes128 -cbc \"/> <また、xenc：CipherData> <また、xenc：CipherValue> oTvo + S22nsmS2Z / RtcoF8AabC6vr 09sh0QIU + E224S96sZjpV + 6nFYgn 6525OoepbPnL / fGuuey64WCYXoqh Tgは== </また、xenc：CipherValue> </また、xenc：CipherData> </ pskc：EncryptedValue> < pskc：ValueMAC> O + e9xgMVUbYuZH9UHe0W9dIo88A = </ pskc：ValueMAC> </ pskc：シークレット> <pskc：カウンタ> <pskc：PlainValue> 0 </ pskc：PlainValue> </ pskc：カウンタ> </ pskc：データ> < pskc：ポリシー> <pskc：のKeyUsage> OTP </ pskc：KeyUsageの> </ pskc：ポリシー> </ pskc：キー> </ pskc：KeyPackage> </ dskpp：KeyContainer> </ dskpp：KeyPackage> <dskpp：マックMacAlgorithm = \"壷：IETF：のparams：XML：NS：keyprov：dskpp：PRF-SHA256\"> l53BmSO6qUzoIgbQegimsKk2es + WRpEl0YFqaOp5PGE = </ dskpp：マック> </ dskpp：KeyProvServerFinished>"
    },
    {
      "indent": 0,
      "text": "B.3.3. Example Using the Passphrase-Based Key Wrap Method",
      "ja": "B.3.3。パスフレーズベースのキーラップメソッドの使用例"
    },
    {
      "indent": 3,
      "text": "The client sends a request similar to that in Appendix B.3.1 with Authentication Data based on an Authentication Code, and the server responds using the Passphrase-Based Key Wrap method to encrypt the provisioning key (note that the encryption is derived from the password component of the Authentication Code). The Authentication Data is set in clear text when it is sent over a secure transport channel such as TLS [RFC5246].",
      "ja": "クライアントは、認証コードに基づいて認証データと付録B.3.1と同様の要求を送信し、（暗号化パスワードの成分から誘導されることに注意して、サーバは、プロビジョニングキーを暗号化するために、パスフレーズベースのキーラップ方式を使用して応答します認証コードの）。それはそのようなTLS [RFC5246]などの安全なトランスポートチャネルを介して送信されたときに認証データをクリアテキストで設定されています。"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <dskpp:KeyProvClientHello xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\" xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\" xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\" xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\" Version=\"1.0\"> <dskpp:DeviceIdentifierData> <dskpp:DeviceId> <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer> <pskc:SerialNo>987654321</pskc:SerialNo> <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate> <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate> </dskpp:DeviceId> </dskpp:DeviceIdentifierData> <dskpp:SupportedKeyTypes> <dskpp:Algorithm> urn:ietf:params:xml:ns:keyprov:pskc:hotp </dskpp:Algorithm> <dskpp:Algorithm> http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES </dskpp:Algorithm> </dskpp:SupportedKeyTypes> <dskpp:SupportedEncryptionAlgorithms> <dskpp:Algorithm> http://www.w3.org/2001/04/xmlenc#rsa_1_5 </dskpp:Algorithm> </dskpp:SupportedEncryptionAlgorithms> <dskpp:SupportedMacAlgorithms> <dskpp:Algorithm> urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256 </dskpp:Algorithm> </dskpp:SupportedMacAlgorithms> <dskpp:SupportedProtocolVariants> <dskpp:TwoPass> <dskpp:SupportedKeyProtectionMethod> urn:ietf:params:xml:schema:keyprov:dskpp:passphrase-wrap </dskpp:SupportedKeyProtectionMethod>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\" スタンドアロン= \"はい\"？> <dskpp：KeyProvClientHelloのxmlns：pskc = \"壷：IETF：のparams：XML：NS：keyprov：pskc\" のxmlns：dskpp =」 URN：IETF：のparams：XML：NS：keyprov：dskpp \"のxmlns：また、xenc = \"http://www.w3.org/2001/04/xmlenc#\" のxmlns：DS =\" http://www.w3.org / 2000/09 /＃」バージョン= \"1.0\"> <dskpp XMLDSIG：DeviceIdentifierData> <dskpp：DEVICEID> <pskc：メーカー> TokenVendorAcme </ pskc：メーカー> <pskc：のSerialNo> 987654321 </ pskc：のSerialNo> <pskc ：開始日> 2009-09-01T00：00：00Z </ pskc：開始日> <pskc：ExpiryDate> 2014-09-01T00：00：00Z </ pskc：ExpiryDate> </ dskpp：デバイスID> </ dskpp：DeviceIdentifierData> <dskpp：SupportedKeyTypes> <dskpp：アルゴリズム> URN：IETF：paramsは：XML：NS：keyprov：pskc：HOTP </ dskpp：アルゴリズム> <dskpp：アルゴリズム> http://www.rsa.com/rsalabs/otps/スキーマ/ 2005/09 / OTPを-WST＃SecurIDの-AES </ dskpp：アルゴリズム> </ dskpp：SupportedKeyTypes> <dskpp：SupportedEncryptionAlgorithms> <dskpp：アルゴリズム> http://www.w3.org/2001/04/xmlenc ＃rsa_1_5 </ dskpp：アルゴリズム> </ dskpp：SupportedEncryptionAlgorithms> <dskpp：SupportedMa cAlgorithms> <dskpp：アルゴリズム> URN：IETF：paramsは：XML：NS：keyprov：dskpp：PRF-SHA256 </ dskpp：アルゴリズム> </ dskpp：SupportedMacAlgorithms> <dskpp：SupportedProtocolVariants> <dskpp：2パス> <dskpp：SupportedKeyProtectionMethod > URN：IETF：のparams：XML：スキーマ：keyprov：dskpp：パスフレーズラップ</ dskpp：SupportedKeyProtectionMethod>"
    },
    {
      "indent": 3,
      "text": " <dskpp:Payload> <ds:KeyInfo> <ds:KeyName>Passphrase-1</ds:KeyName> </ds:KeyInfo> </dskpp:Payload> </dskpp:TwoPass> </dskpp:SupportedProtocolVariants> <dskpp:SupportedKeyPackages> <dskpp:KeyPackageFormat> urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container </dskpp:KeyPackageFormat> </dskpp:SupportedKeyPackages> <dskpp:AuthenticationData> <dskpp:ClientID>AC00000A</dskpp:ClientID> <dskpp:AuthenticationCodeMac> <dskpp:Nonce> ESIzRFVmd4iZqrvM3e7/ESIzRFVmd4iZqrvM3e7/ESI= </dskpp:Nonce> <dskpp:IterationCount>1</dskpp:IterationCount> <dskpp:Mac MacAlgorithm= \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\"> K4YvLMN6Q1DZvtShoCxQag== </dskpp:Mac> </dskpp:AuthenticationCodeMac> </dskpp:AuthenticationData> </dskpp:KeyProvClientHello>",
      "ja": "<dskpp：ペイロード> <DS：のKeyInfo> <DS：キー名>パスフレーズ-1 </ DS：キー名> </ DS：のKeyInfo> </ dskpp：ペイロード> </ dskpp：2パス> </ dskpp：SupportedProtocolVariants> <dskpp ：SupportedKeyPackages> <dskpp：KeyPackageFormat> URN：IETF：paramsは：XML：NS：keyprov：dskpp：pskcキーコンテナ</ dskpp：KeyPackageFormat> </ dskpp：SupportedKeyPackages> <dskpp：AuthenticationData> <dskpp：クライアントID> AC00000A </ dskpp：ClientIDを> <dskpp：AuthenticationCodeMac> <dskpp：ナンス> ESIzRFVmd4iZqrvM3e7 / ESIzRFVmd4iZqrvM3e7 / ESI = </ dskpp：ナンス> <dskpp：IterationCount> 1 </ dskpp：IterationCount> <dskpp：MacのMacAlgorithm =「壷：IETF ：のparams：XML：NS：keyprov：dskpp：PRF-SHA256\" > K4YvLMN6Q1DZvtShoCxQag == </ dskpp：マック> </ dskpp：AuthenticationCodeMac> </ dskpp：AuthenticationData> </ dskpp：KeyProvClientHello>"
    },
    {
      "indent": 3,
      "text": "In this example, the server responds to the previous request by returning a key package in which the provisioning key was encrypted using the Passphrase-Based Key Wrap key protection method.",
      "ja": "この例では、サーバーは、プロビジョニングキーがパスフレーズベースのキーラップキーの保護方法を使用して暗号化されたキーパッケージを返すことによって、前の要求に応答します。"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <dskpp:KeyProvServerFinished xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\" xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\" xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\" xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\" xmlns:dkey=\"http://www.w3.org/2009/xmlsec-derivedkey#\" xmlns:pkcs5= \"http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#\" Version=\"1.0\" Status=\"Success\" SessionID=\"4114\"> <dskpp:KeyPackage> <dskpp:KeyContainer Version=\"1.0\" Id=\"KC0002\"> <pskc:EncryptionKey> <dkey:DerivedKey>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\" スタンドアロン= \"はい\"？> <dskpp：KeyProvServerFinishedのxmlns：pskc = \"壷：IETF：のparams：XML：NS：keyprov：pskc\" のxmlns：dskpp =」 URN：IETF：のparams：XML：NS：keyprov：dskpp \"のxmlns：また、xenc = \"http://www.w3.org/2001/04/xmlenc#\" のxmlns：DS =\" http://www.w3.org / 2000/09 / XMLDSIG番号 \"のxmlns：DKEY = \"http://www.w3.org/2009/xmlsec-derivedkey#\" のxmlns：PKCS5 =\" http://www.rsasecurity.com/rsalabs/pkcs/schemas / PKCS-5v2-0＃」バージョン= \"1.0\" ステータス= \"成功\" のSessionID = \"4114\"> <dskpp：KeyPackage> <dskpp：KeyContainerバージョン= \"1.0\" ID = \"KC0002\"> <pskc：EncryptionKey> < DKEY：DerivedKey>"
    },
    {
      "indent": 8,
      "text": "               <dkey:KeyDerivationMethod\n               Algorithm=\n               \"http://www.rsasecurity.com/rsalabs/pkcs/schemas/\n               pkcs-5v2-0#pbkdf2\">\n                   <pkcs5:PBKDF2-params>\n                       <Salt>\n                           <Specified>Ej7/PEpyEpw=</Specified>\n                       </Salt>\n                       <IterationCount>1000</IterationCount>\n                       <KeyLength>16</KeyLength>\n                   </pkcs5:PBKDF2-params>\n               </dkey:KeyDerivationMethod>\n               <xenc:ReferenceList>\n                   <xenc:DataReference URI=\"#ED\"/>\n               </xenc:ReferenceList>\n               <dkey:MasterKeyName>\n                  Passphrase1\n               </dkey:MasterKeyName>\n           </dkey:DerivedKey>\n       </pskc:EncryptionKey>\n       <pskc:MACMethod\n           Algorithm=\n              \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\">\n           <pskc:MACKey>\n               <xenc:EncryptionMethod\n                   Algorithm=\n                 \"http://www.w3.org/2001/04/xmlenc#aes128-cbc\"/>\n               <xenc:CipherData>\n                   <xenc:CipherValue>\n2GTTnLwM3I4e5IO5FkufoOEiOhNj91fhKRQBtBJYluUDsPOLTfUvoU2dStyOwYZx\n                   </xenc:CipherValue>\n               </xenc:CipherData>\n           </pskc:MACKey>\n       </pskc:MACMethod>\n       <pskc:KeyPackage>\n           <pskc:DeviceInfo>\n               <pskc:Manufacturer>\n                  TokenVendorAcme\n               </pskc:Manufacturer>\n               <pskc:SerialNo>\n                  987654321\n               </pskc:SerialNo>\n               <pskc:StartDate>\n                  2009-09-01T00:00:00Z\n               </pskc:StartDate>\n               <pskc:ExpiryDate>\n                  2014-09-01T00:00:00Z\n               </pskc:ExpiryDate>",
      "raw": true
    },
    {
      "indent": 3,
      "text": " </pskc:DeviceInfo> <pskc:CryptoModuleInfo> <pskc:Id>CM_ID_001</pskc:Id> </pskc:CryptoModuleInfo> <pskc:Key Id=\"MBK000000001\" Algorithm= \"urn:ietf:params:xml:ns:keyprov:pskc:hotp\"> <pskc:Issuer>Example-Issuer</pskc:Issuer> <pskc:AlgorithmParameters> <pskc:ResponseFormat Length=\"6\" Encoding=\"DECIMAL\"/> </pskc:AlgorithmParameters> <pskc:Data> <pskc:Secret> <pskc:EncryptedValue> <xenc:EncryptionMethod Algorithm= \"http://www.w3.org/2001/04/ xmlenc#aes128-cbc\"/> <xenc:CipherData> <xenc:CipherValue> oTvo+S22nsmS2Z/RtcoF8HX385uMWgJ myIFMESBmcvtHQXp/6T1TgCS9CsgKtm cOrF8VoK254tZKnrAjiD5cdw== </xenc:CipherValue> </xenc:CipherData> </pskc:EncryptedValue> <pskc:ValueMAC> pbgEbVYxoYs0x41wdeC7eDRbUEk= </pskc:ValueMAC> </pskc:Secret> <pskc:Counter> <pskc:PlainValue>0</pskc:PlainValue> </pskc:Counter> </pskc:Data> <pskc:Policy> <pskc:KeyUsage>OTP</pskc:KeyUsage> </pskc:Policy> </pskc:Key> </pskc:KeyPackage> </dskpp:KeyContainer> </dskpp:KeyPackage> <dskpp:Mac MacAlgorithm= \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\"> Jc4VsNODYXgfbDmTn9qQZgcL3cKoa//j/NRT7sTpKOM= </dskpp:Mac> </dskpp:KeyProvServerFinished>",
      "ja": "</ pskc：DEVICEINFO> <pskc：CryptoModuleInfo> <pskc：ID> CM_ID_001 </ pskc：ID> </ pskc：CryptoModuleInfo> <pskc：キーID = \"MBK000000001\" アルゴリズム=「壷：IETF：のparams：XML：NS ：keyprov：pskc：HOTP \"> <pskc：発行者>実施例-発行</ pskc：発行者> <pskc：ない、AlgorithmParameters> <pskc：ResponseFormat長=\" 6\" エンコード= \"DECIMAL\" /> </ pskc：ない、AlgorithmParameters> < pskc：データ> <pskc：シークレット> <pskc：EncryptedValue> <また、xenc：はEncryptionMethodアルゴリズム= \"http://www.w3.org/2001/04/ xmlenc＃AES128-CBC\" /> <また、xenc：CipherData> <また、xenc ：CipherValue> oTvo + S22nsmS2Z / RtcoF8HX385uMWgJ myIFMESBmcvtHQXp / 6T1TgCS9CsgKtm cOrF8VoK254tZKnrAjiD5cdw == </また、xenc：CipherValue> </また、xenc：CipherData> </ pskc：EncryptedValue> <pskc：ValueMAC> pbgEbVYxoYs0x41wdeC7eDRbUEk = </ pskc：ValueMAC> </ pskc：シークレット> <pskc：カウンタ> <pskc：PlainValue> 0 </ pskc：PlainValue> </ pskc：カウンタ> </ pskc：データ> <pskc：ポリシー> <pskc：のKeyUsage> OTP </ pskc：KeyUsageの> </ pskc ：ポリシー> </ pskc：キー> </ pskc：KeyPackage> </ dskpp：KeyContainer> </ dskpp：KeyPackage> <dskpp：MacのMacAlgorithm =「壷：IETF：のparams：XML：NS：keypr OV：dskpp：PRF-SHA256\" > Jc4VsNODYXgfbDmTn9qQZgcL3cKoa // J / NRT7sTpKOM = </ dskpp：マック> </ dskpp：KeyProvServerFinished>"
    },
    {
      "indent": 0,
      "text": "Appendix C. Integration with PKCS #11",
      "ja": "PKCS＃11と付録C.統合"
    },
    {
      "indent": 3,
      "text": "A DSKPP Client that needs to communicate with a connected cryptographic module to perform a DSKPP exchange MAY use PKCS #11 [PKCS-11] as a programming interface as described herein. This appendix forms an informative part of the document.",
      "ja": "本明細書に記載されるようDSKPP交換を行うように接続された暗号モジュールと通信する必要があるDSKPPクライアントは、プログラミングインタフェースとしてPKCS＃11 [PKCS-11]を使用するかもしれ。この付録では、文書の有益な部分を形成します。"
    },
    {
      "indent": 0,
      "text": "C.1. The Four-Pass Variant",
      "ja": "C.1。四路バリアント"
    },
    {
      "indent": 3,
      "text": "When performing four-pass DSKPP with a cryptographic module using the PKCS #11 programming interface, the procedure described in [CT-KIP-P11], Appendix B, is RECOMMENDED.",
      "ja": "PKCS＃11プログラミング・インタフェース、[CT-KIP-P11]に記載の手順を用いて、暗号モジュールと四つ通過DSKPPを行う際に、付録Bは、推奨されています。"
    },
    {
      "indent": 0,
      "text": "C.2. The Two-Pass Variant",
      "ja": "C.2。 2パスバリアント"
    },
    {
      "indent": 3,
      "text": "A suggested procedure to perform two-pass DSKPP with a cryptographic module through the PKCS #11 interface using the mechanisms defined in [CT-KIP-P11] is as follows:",
      "ja": "以下のようにCT-KIP-P11]で定義されたメカニズムを使用して、PKCS＃11インタフェースを介して暗号モジュールと二通過DSKPPを実行するための提案手順は次のとおり"
    },
    {
      "indent": 3,
      "text": "a. On the client side,",
      "ja": "A。クライアント側では、"
    },
    {
      "indent": 7,
      "text": "1.  The client selects a suitable slot and token (e.g., through\n    use of the <DeviceIdentifier> or the <PlatformInfo> element\n    of the DSKPP trigger message).",
      "raw": true
    },
    {
      "indent": 7,
      "text": "2. A nonce R is generated, e.g., by calling C_SeedRandom and C_GenerateRandom.",
      "ja": "2.ノンスRはC_SeedRandomとC_GenerateRandomを呼び出すことによって、例えば、生成されます。"
    },
    {
      "indent": 7,
      "text": "3. The client sends its first message to the server, including the nonce R.",
      "ja": "3.クライアントは、ナンスR.含めて、サーバーへの最初のメッセージを送ります"
    },
    {
      "indent": 3,
      "text": "b. On the server side,",
      "ja": "B。サーバー側では、"
    },
    {
      "indent": 7,
      "text": "1.  A generic key K_PROV = K_TOKEN | K_MAC (where '|' denotes\n    concatenation) is generated, e.g., by calling C_GenerateKey\n    (using key type CKK_GENERIC_SECRET).  The template for K_PROV\n    MUST allow it to be exported (but only in wrapped form, i.e.,\n    CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST\n    also be set to CK_TRUE), and also to be used for further key\n    derivation.  From K, a token key K_TOKEN of suitable type is\n    derived by calling C_DeriveKey using the PKCS #11 mechanism\n    CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to\n    the first bit of the generic secret key (i.e., set to 0).\n    Likewise, a MAC key K_MAC is derived from K_PROV by calling\n    C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism,\n    this time setting CK_EXTRACT_PARAMS to the length of K_PROV\n    (in bits) divided by two.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "2. The server wraps K_PROV with either the public key of the DSKPP Client or device, the pre-shared secret key, or the derived shared secret key by using C_WrapKey. If use of the DSKPP key wrap algorithm has been negotiated, then the CKM_KIP_WRAP mechanism MUST be used to wrap K. When calling C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure MUST be set to NULL_PTR. The pSeed parameter in the CK_KIP_PARAMS structure MUST point to the nonce R provided by the DSKPP Client, and the ulSeedLen parameter MUST indicate the length of R. The hWrappingKey parameter in the call to C_WrapKey MUST be set to refer to the key wrapping key.",
      "ja": "2.サーバはDSKPPクライアント又はデバイスの公開鍵、事前共有秘密鍵、またはC_WrapKeyを用いて誘導された共有秘密鍵のいずれかでK_PROVをラップ。 DSKPPキーラップアルゴリズムの使用が交渉されている場合は、CKM_KIP_WRAPメカニズムはC_WrapKeyを呼び出すときK.をラップするために使用されなければならない、CK_KIP_PARAMS構造でHKEYハンドルがNULL_PTRに設定しなければなりません。 CK_KIP_PARAMS構造におけるpSeedパラメータはDSKPPクライアントによって提供さノンスRを指している必要があり、そしてulSeedLenパラメータがキーラッピングキーを参照するように設定する必要がありC_WrapKeyの呼び出しでR.ザhWrappingKeyパラメーターの長さを示さなければなりません。"
    },
    {
      "indent": 7,
      "text": "3. Next, the server needs to calculate a MAC using K_MAC. If use of the DSKPP MAC algorithm has been negotiated, then the MAC is calculated by calling C_SignInit with the CKM_KIP_MAC mechanism followed by a call to C_Sign. In the call to C_SignInit, K_MAC MUST be the signature key, the hKey parameter in the CK_KIP_PARAMS structure MUST be set to NULL_PTR, the pSeed parameter of the CT_KIP_PARAMS structure MUST be set to NULL_PTR, and the ulSeedLen parameter MUST be set to zero. In the call to C_Sign, the pData parameter MUST be set to the concatenation of the string ServerID and the nonce R, and the ulDataLen parameter MUST be set to the length of the concatenated string. The desired length of the MAC MUST be specified through the pulSignatureLen parameter and MUST be set to the length of R.",
      "ja": "3.次に、サーバーはK_MACを使用してMACを計算する必要があります。 DSKPP MACアルゴリズムの使用が交渉されている場合、MACはC_Signへの呼び出しに続くCKM_KIP_MAC機構をC_SignInitを呼び出すことによって計算されます。 C_SignInitの呼び出しで、K_MACは、署名鍵でなければなりません、CK_KIP_PARAMS構造でHKEYパラメータがNULL_PTRに設定しなければなりません、CT_KIP_PARAMS構造のpSeedパラメータはNULL_PTRに設定しなければなりません、そしてulSeedLenパラメータはゼロに設定しなければなりません。 C_Signの呼び出しで、pDataをパラメータは、文字列のServerIDの連結およびノンスRに設定しなければなりません、そしてulDataLenパラメータが連結された文字列の長さに設定しなければなりません。 MACの所望の長さはpulSignatureLenパラメータで指定されなければならないとRの長さに設定しなければなりません"
    },
    {
      "indent": 7,
      "text": "4. If the server also needs to authenticate its message (due to an existing K_TOKEN being replaced), the server MUST calculate a second MAC. Again, if use of the DSKPP MAC algorithm has been negotiated, then the MAC is calculated by calling C_SignInit with the CKM_KIP_MAC mechanism followed by a call to C_Sign. In this call to C_SignInit, the K_MAC' existing before this DSKPP run MUST be the signature key (the implementation may specify K_MAC' to be the value of the K_TOKEN that is being replaced, or a version of K_MAC from the previous protocol run), the hKey parameter in the CK_KIP_PARAMS structure MUST be set to NULL, the pSeed parameter of the CT_KIP_PARAMS structure MUST be set to NULL_PTR, and the ulSeedLen parameter MUST be set to zero. In the call to C_Sign, the pData parameter MUST be set to the concatenation of the string ServerID and the nonce R, and the ulDataLen parameter MUST be set to the length of concatenated string. The desired length of the MAC MUST be specified through the pulSignatureLen parameter and MUST be set to the length of R.",
      "ja": "4.サーバはまた、（これは置換されている既存のK_TOKENに）そのメッセージを認証する必要がある場合、サーバは、第2のMACを計算しなければなりません。 DSKPP MACアルゴリズムの使用が交渉された場合は、再度、その後、MACはC_Signへの呼び出しに続くCKM_KIP_MAC機構をC_SignInitを呼び出すことによって計算されます。 「（置換されているK_TOKENの値、または以前のプロトコルの実行からK_MACのバージョンであることC_SignInitにこの呼び出しにおいて、K_MACは、このDSKPP実行が署名鍵実装がK_MACを指定することができる）でなければならない前に、既存の」 CK_KIP_PARAMS構造でHKEYパラメータがNULLに設定しなければなりません、CT_KIP_PARAMS構造のpSeedパラメータがNULL_PTRに設定しなければなりません、そしてulSeedLenパラメータがゼロに設定されなければなりません。 C_Signの呼び出しで、pDataをパラメータは、文字列のServerIDの連結およびノンスRに設定しなければなりません、そしてulDataLenパラメータが連結された文字列の長さに設定しなければなりません。 MACの所望の長さはpulSignatureLenパラメータで指定されなければならないとRの長さに設定しなければなりません"
    },
    {
      "indent": 7,
      "text": "5. The server sends its message to the client, including the wrapped key K_TOKEN, the MAC and possibly also the authenticating MAC.",
      "ja": "5.サーバーは、ラップされた鍵K_TOKEN、MACおよびおそらくは認証MACを含め、クライアントにメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "c. On the client side,",
      "ja": "C。クライアント側では、"
    },
    {
      "indent": 7,
      "text": "1.  The client calls C_UnwrapKey to receive a handle to K.  After\n    this, the client calls C_DeriveKey twice: once to derive\n    K_TOKEN and once to derive K_MAC.  The client MUST use the\n    same mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same\n    mechanism parameters as used by the server above.  When\n    calling C_UnwrapKey and C_DeriveKey, the pTemplate parameter\n    MUST be used to set additional key attributes in accordance\n    with local policy and as negotiated and expressed in the\n    protocol.  In particular, the value of the <KeyID> element in\n    the server's response message MAY be used as CKA_ID for\n    K_TOKEN.  The key K_PROV MUST be destroyed after deriving\n    K_TOKEN and K_MAC.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "2. The MAC is verified in a reciprocal fashion as it was generated by the server. If use of the CKM_KIP_MAC mechanism has been negotiated, then in the call to C_VerifyInit, the hKey parameter in the CK_KIP_PARAMS structure MUST be set to NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and ulSeedLen MUST be set to 0. The hKey parameter of C_VerifyInit MUST refer to K_MAC. In the call to C_Verify, pData MUST be set to the concatenation of the string ServerID and the nonce R, and the ulDataLen parameter MUST be set to the length of the concatenated string, pSignature to the MAC value received from the server, and ulSignatureLen to the length of the MAC. If the MAC does not verify the protocol session ends with a failure. The token MUST be constructed to not \"commit\" to the new K_TOKEN or the new K_MAC unless the MAC verifies.",
      "ja": "それは、サーバによって生成されたとして2.ザ・MACは相互的な方法で検証されます。 CKM_KIP_MAC機構の使用がネゴシエートされている場合C_VerifyInitの呼び出しで、CK_KIP_PARAMS構造でHKEYパラメータがNULL_PTRに設定しなければなりません、そして、pSeedパラメータがNULL_PTRに設定しなければなりません、そしてulSeedLenはHKEYパラメータを0に設定しなければなりませんC_VerifyInitのK_MACを参照する必要があります。 C_Verifyへの呼び出しでは、pDataを文字列のServerIDの連結およびノンスRに設定しなければなりません、そしてulDataLenパラメータが連結された文字列の長さに設定しなければなりません、サーバから受信したMAC値とpSignature、及びulSignatureLenにMACの長さ。 MACが検証されない場合は、プロトコルセッションは失敗に終わります。トークンは、MACが検証されない限り、新たなK_TOKENまたは新しいK_MACに「コミット」しないように構成しなければなりません。"
    },
    {
      "indent": 7,
      "text": "3. If an authenticating MAC was received (REQUIRED if the new K_TOKEN will replace an existing key on the token), then it is verified in a similar vein but using the K_MAC' associated with this server and existing before the protocol run (the implementation may specify K_MAC' to be the value of the K_TOKEN that is being replaced, or a version of K_MAC from the previous protocol run). Again, if the MAC does not verify the protocol session ends with a failure, and the token MUST be constructed not to \"commit\" to the new K_TOKEN or the new K_MAC unless the MAC verifies.",
      "ja": "3.認証MACを受信した場合、それは同様の静脈で検証が、使用している、（新しいK_TOKENトークン上の既存のキーを置き換えます場合は必須）K_MAC」このサーバとプロトコルの実行前に、既存の（実装に関連付けられています）置換されているK_TOKENの値、または以前のプロトコルの実行からK_MACのバージョンであることK_MAC」を指定することができます。 MACは、プロトコルセッションを検証していない場合は、再度、失敗して終了し、トークンはMACが検証されない限り、新たなK_TOKENまたは新しいK_MACに「コミット」しないように構成しなければなりません。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Example of DSKPP-PRF Realizations",
      "ja": "DSKPP-PRFによる実現の付録D.例"
    },
    {
      "indent": 0,
      "text": "D.1. Introduction",
      "ja": "D.1。前書き"
    },
    {
      "indent": 3,
      "text": "This example appendix defines DSKPP-PRF in terms of AES [FIPS197-AES] and HMAC [RFC2104]. This appendix forms a normative part of the document.",
      "ja": "この例では付録では、AES [FIPS197-AES]及びHMAC [RFC2104]の観点DSKPP-PRFを定義します。この付録では、文書の規範的部分を形成します。"
    },
    {
      "indent": 0,
      "text": "D.2. DSKPP-PRF-AES",
      "ja": "D.2。 DSKPP-PRF-AES"
    },
    {
      "indent": 0,
      "text": "D.2.1. Identification",
      "ja": "D.2.1。識別"
    },
    {
      "indent": 3,
      "text": "For cryptographic modules supporting this realization of DSKPP-PRF, the following URN MUST be used to identify this algorithm in DSKPP:",
      "ja": "DSKPP-PRFのこの実現をサポートする暗号化モジュールは、次のURNはDSKPPにこのアルゴリズムを識別するために使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "urn:ietf:params:xml:ns:keyprov:dskpp:prf-aes-128",
      "ja": "URN：IETF：のparams：XML：NS：keyprov：dskpp：PRF-AES-128"
    },
    {
      "indent": 3,
      "text": "When this URN is used to identify the encryption algorithm, the method for encryption of R_C values described in Section 4.2.4 MUST be used.",
      "ja": "このURNは、暗号化アルゴリズムを識別するために使用される場合、セクション4.2.4に記載R_C値を暗号化するための方法を使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "D.2.2. Definition",
      "ja": "D.2.2。定義"
    },
    {
      "indent": 3,
      "text": "DSKPP-PRF-AES (k, s, dsLen)",
      "ja": "DSKPP-PRF-AES（K、S、dsLen）"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "k Encryption key to use s Octet string consisting of randomizing material. The length of the string s is sLen. dsLen Desired length of the output",
      "ja": "k個の暗号化キーは、材料をランダムで構成されるsのオクテット文字列を使用します。文字列sの長さはSLENです。出力のdsLen所望の長さ"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "DS A pseudorandom string, dsLen-octets long",
      "ja": "DS擬似乱数列、dsLen-オクテット"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Let bLen be the output block size of AES in octets:",
      "section_title": true,
      "ja": "1. BLENがオクテットでAESの出力ブロックサイズにしてみましょう："
    },
    {
      "indent": 7,
      "text": "bLen = (AES output block length in octets)\n(normally, bLen = 16)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. If dsLen > (2**32 - 1) * bLen, output \"derived data too long\" and stop",
      "ja": "2. dsLen>（2 ** 32から1）であれば* BLEN、出力は \"データ長すぎ由来する\" と停止"
    },
    {
      "indent": 3,
      "text": "3. Let n be the number of bLen-octet blocks in the output data, rounding up, and let j be the number of octets in the last block:",
      "ja": "3. nは切り上げ、出力データにおけるBLENオクテットブロックの数であり、jが最後のブロックでオクテット数も聞かせてみましょう："
    },
    {
      "indent": 7,
      "text": "n = CEILING( dsLen / bLen)\nj = dsLen - (n - 1) * bLen",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4. For each block of the pseudorandom string DS, apply the function F defined below to the key k, the string s and the block index to compute the block:",
      "ja": "擬似ランダムストリングDSの各ブロックについて4、Fブロックを計算するために鍵k、文字列s及びブロックインデックスに下に定義された関数を適用します。"
    },
    {
      "indent": 7,
      "text": "B1 = F (k, s, 1) ,\nB2 = F (k, s, 2) ,\n...\nBn = F (k, s, n)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The function F is defined in terms of the CMAC construction from [NIST-SP800-38B], using AES as the block cipher:",
      "ja": "関数Fは、ブロック暗号としてAESを使用して、[NIST-SP800-38B]からCMAC構造に関して定義されます。"
    },
    {
      "indent": 3,
      "text": "F (k, s, i) = CMAC-AES (k, INT (i) || s)",
      "ja": "F（K、S、I）= CMAC-AES（K、INT（I）|| S）"
    },
    {
      "indent": 3,
      "text": "where INT (i) is a four-octet encoding of the integer i, most significant octet first, and the output length of CMAC is set to bLen.",
      "ja": "ここで、INT（i）は、最初の整数I、最も重要なオクテットの4オクテットの符号化され、CMACの出力長はBLENに設定されています。"
    },
    {
      "indent": 3,
      "text": "Concatenate the blocks and extract the first dsLen octets to produce the desired data string DS:",
      "ja": "ブロックを連結し、所望のデータ列DSを生成する第dsLenオクテットを抽出します。"
    },
    {
      "indent": 3,
      "text": "DS = B1 || B2 || ... || Bn<0..j-1>",
      "ja": "DS = B1 || B2 || ... || BN <0..j-1>"
    },
    {
      "indent": 3,
      "text": "Output the derived data DS.",
      "ja": "出力派生データDS。"
    },
    {
      "indent": 0,
      "text": "D.2.3. Example",
      "ja": "D.2.3。例"
    },
    {
      "indent": 3,
      "text": "If we assume that dsLen = 16, then:",
      "ja": "我々はdsLen = 16と仮定した場合、その後："
    },
    {
      "indent": 3,
      "text": "n = 16 / 16 = 1",
      "ja": "ん ＝ １６ ／ １６ ＝ １"
    },
    {
      "indent": 3,
      "text": "j = 16 - (1 - 1) * 16 = 16",
      "ja": "J = 16  - （1  -  1）* 16 = 16"
    },
    {
      "indent": 3,
      "text": "DS = B1 = F (k, s, 1) = CMAC-AES (k, INT (1) || s)",
      "ja": "DS = B1 = F（K、S、1）= CMAC-AES（K、INT（1）|| S）"
    },
    {
      "indent": 0,
      "text": "D.3. DSKPP-PRF-SHA256",
      "ja": "D.3。 DSKPP-PRF-SHA256"
    },
    {
      "indent": 0,
      "text": "D.3.1. Identification",
      "ja": "D.3.1。識別"
    },
    {
      "indent": 3,
      "text": "For cryptographic modules supporting this realization of DSKPP-PRF, the following URN MUST be used to identify this algorithm in DSKPP:",
      "ja": "DSKPP-PRFのこの実現をサポートする暗号化モジュールは、次のURNはDSKPPにこのアルゴリズムを識別するために使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256",
      "ja": "URN：IETF：のparams：XML：NS：keyprov：dskpp：PRF-SHA256"
    },
    {
      "indent": 3,
      "text": "When this URN is used to identify the encryption algorithm to use, the method for encryption of R_C values described in Section 4.2.4 MUST be used.",
      "ja": "このURNは、使用する暗号化アルゴリズムを識別するために使用される場合、セクション4.2.4に記載R_C値を暗号化するための方法を使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "D.3.2. Definition",
      "ja": "D.3.2。定義"
    },
    {
      "indent": 3,
      "text": "DSKPP-PRF-SHA256 (k, s, dsLen)",
      "ja": "DSKPP-PRF-SHA256（K、S、dsLen）"
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "k Encryption key to use s Octet string consisting of randomizing material. The length of the string s is sLen. dsLen Desired length of the output",
      "ja": "k個の暗号化キーは、材料をランダムで構成されるsのオクテット文字列を使用します。文字列sの長さはSLENです。出力のdsLen所望の長さ"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "DS A pseudorandom string, dsLen-octets long",
      "ja": "DS擬似乱数列、dsLen-オクテット"
    },
    {
      "indent": 3,
      "text": "Steps:",
      "ja": "ステップ："
    },
    {
      "indent": 3,
      "text": "1. Let bLen be the output size of SHA-256 in octets of [FIPS180-SHA] (no truncation is done on the HMAC output):",
      "ja": "1. BLENは[FIPS180-SHA]（なし切り捨てがHMAC出力で行われていない）のオクテットでSHA-256の出力サイズとします。"
    },
    {
      "indent": 7,
      "text": "bLen = 32\n(normally, bLen = 16)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. If dsLen > (2**32 - 1) * bLen, output \"derived data too long\" and stop",
      "ja": "2. dsLen>（2 ** 32から1）であれば* BLEN、出力は \"データ長すぎ由来する\" と停止"
    },
    {
      "indent": 3,
      "text": "3. Let n be the number of bLen-octet blocks in the output data, rounding up, and let j be the number of octets in the last block:",
      "ja": "3. nは切り上げ、出力データにおけるBLENオクテットブロックの数であり、jが最後のブロックでオクテット数も聞かせてみましょう："
    },
    {
      "indent": 7,
      "text": "n = CEILING( dsLen / bLen)\nj = dsLen - (n - 1) * bLen",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4. For each block of the pseudorandom string DS, apply the function F defined below to the key k, the string s and the block index to compute the block:",
      "ja": "擬似ランダムストリングDSの各ブロックについて4、Fブロックを計算するために鍵k、文字列s及びブロックインデックスに下に定義された関数を適用します。"
    },
    {
      "indent": 7,
      "text": "B1 = F (k, s, 1),\nB2 = F (k, s, 2),\n...\nBn = F (k, s, n)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The function F is defined in terms of the HMAC construction from [RFC2104], using SHA-256 as the digest algorithm:",
      "ja": "関数Fは、ダイジェストアルゴリズムとしてSHA-256を使用して、[RFC2104]からHMAC構造に関して定義されます。"
    },
    {
      "indent": 3,
      "text": "F (k, s, i) = HMAC-SHA256 (k, INT (i) || s)",
      "ja": "F（K、S、I）= HMAC-SHA256（K、INT（I）|| S）"
    },
    {
      "indent": 3,
      "text": "where INT (i) is a four-octet encoding of the integer i, most significant octet first, and the output length of HMAC is set to bLen.",
      "ja": "ここで、INT（i）は、最初の整数I、最も重要なオクテットの4オクテットの符号化であり、HMACの出力長はBLENに設定されています。"
    },
    {
      "indent": 3,
      "text": "Concatenate the blocks and extract the first dsLen octets to produce the desired data string DS:",
      "ja": "ブロックを連結し、所望のデータ列DSを生成する第dsLenオクテットを抽出します。"
    },
    {
      "indent": 3,
      "text": "DS = B1 || B2 || ... || Bn<0..j-1>",
      "ja": "DS = B1 || B2 || ... || BN <0..j-1>"
    },
    {
      "indent": 3,
      "text": "Output the derived data DS.",
      "ja": "出力派生データDS。"
    },
    {
      "indent": 0,
      "text": "D.3.3. Example",
      "ja": "D.3.3。例"
    },
    {
      "indent": 3,
      "text": "If we assume that sLen = 256 (two 128-octet long values) and dsLen = 16, then:",
      "ja": "我々は仮定した場合、そのSLEN = 256（2つの128オクテット長の値）とdsLen = 16、次いで："
    },
    {
      "indent": 3,
      "text": "n = CEILING( 16 / 32 ) = 1",
      "ja": "N = CEILING（/ 32 16）= 1"
    },
    {
      "indent": 3,
      "text": "j = 16 - (1 - 1) * 32 = 16",
      "ja": "J = 16  - （1  -  1）×32 = 16"
    },
    {
      "indent": 3,
      "text": "B1 = F (k, s, 1) = HMAC-SHA256 (k, INT (1) || s)",
      "ja": "B1 = F（K、S、1）= HMAC-SHA256（K、INT（1）|| S）"
    },
    {
      "indent": 3,
      "text": "DS = B1<0 ... 15>",
      "ja": "DS = B1 <0 ... 15>"
    },
    {
      "indent": 3,
      "text": "That is, the result will be the first 16 octets of the HMAC output.",
      "ja": "つまり、結果はHMAC出力の最初の16個のオクテットになります。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Andrea Doherty RSA, The Security Division of EMC 174 Middlesex Turnpike Bedford, MA 01730 USA",
      "ja": "アンドレア・ドハーティRSA、EMC 174ミドルターンパイクベッドフォード、MA 01730 USAのセキュリティ部門"
    },
    {
      "indent": 3,
      "text": "EMail: andrea.doherty@rsa.com",
      "ja": "メールアドレス：andrea.doherty@rsa.com"
    },
    {
      "indent": 3,
      "text": "Mingliang Pei VeriSign, Inc. 487 E. Middlefield Road Mountain View, CA 94043 USA",
      "ja": "Mingliangペイベリサイン社487 E.ミドルロード、マウンテンビュー、CA 94043 USA"
    },
    {
      "indent": 3,
      "text": "EMail: mpei@verisign.com",
      "ja": "メールアドレス：mpei@verisign.com"
    },
    {
      "indent": 3,
      "text": "Salah Machani Diversinet Corp. 2225 Sheppard Avenue East, Suite 1801 Toronto, Ontario M2J 5C2 Canada",
      "ja": "サラMachani Diversinet社2225シェパードアベニューイースト、スイート1801トロント、オンタリオM2J 5C2カナダ"
    },
    {
      "indent": 3,
      "text": "EMail: smachani@diversinet.com",
      "ja": "メールアドレス：smachani@diversinet.com"
    },
    {
      "indent": 3,
      "text": "Magnus Nystrom Microsoft Corp. One Microsoft Way Redmond, WA 98052 USA",
      "ja": "マグナスNystromマイクロソフト社1マイクロソフト道、レッドモンド、ワシントン98052 USA"
    },
    {
      "indent": 3,
      "text": "EMail: mnystrom@microsoft.com",
      "ja": "メールアドレス：mnystrom@microsoft.com"
    }
  ]
}