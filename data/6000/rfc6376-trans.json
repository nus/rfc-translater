{
  "title": {
    "text": "RFC 6376 - DomainKeys Identified Mail (DKIM) Signatures",
    "ja": "RFC 6376 - ドメインキー・アイデンティファイド・メール（DKIM）署名"
  },
  "number": 6376,
  "created_at": "2019-10-31 19:45:59.873525+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                   D. Crocker, Ed.\nRequest for Comments: 6376                   Brandenburg InternetWorking\nObsoletes: 4871, 5672                                     T. Hansen, Ed.\nCategory: Standards Track                              AT&T Laboratories\nISSN: 2070-1721                                        M. Kucherawy, Ed.\n                                                               Cloudmark\n                                                          September 2011",
      "raw": true
    },
    {
      "indent": 14,
      "text": "DomainKeys Identified Mail (DKIM) Signatures",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "DomainKeys Identified Mail (DKIM) permits a person, role, or organization that owns the signing domain to claim some responsibility for a message by associating the domain with the message. This can be an author's organization, an operational relay, or one of their agents. DKIM separates the question of the identity of the Signer of the message from the purported author of the message. Assertion of responsibility is validated through a cryptographic signature and by querying the Signer's domain directly to retrieve the appropriate public key. Message transit from author to recipient is through relays that typically make no substantive change to the message content and thus preserve the DKIM signature.",
      "ja": "ドメインキー・アイデンティファイド・メール（DKIM）はメッセージでドメインを関連付けることによって、メッセージのいくつかの責任を請求する署名ドメインを所有している人、役割、または組織を可能にします。これは、著者の組織、業務リレー、またはその代理人のいずれかになります。 DKIMは、メッセージの主張作者からのメッセージの署名者のアイデンティティの問題を分離します。責任のアサーションは、暗号署名を通じて、適切な公開鍵を取得するために直接署名者のドメインを照会することによって検証されます。レシピエントへの著者からのメッセージ通過は、典型的には、メッセージの内容に実質的な変更を加えていないので、DKIM署名を保存するリレーを介してです。"
    },
    {
      "indent": 3,
      "text": "This memo obsoletes RFC 4871 and RFC 5672.",
      "ja": "このメモはRFC 4871およびRFC 5672を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6376.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6376で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2011 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n  1.1.  DKIM Architecture Documents  . . . . . . . . . . . . . . .  5\n  1.2.  Signing Identity . . . . . . . . . . . . . . . . . . . . .  5\n  1.3.  Scalability  . . . . . . . . . . . . . . . . . . . . . . .  5\n  1.4.  Simple Key Management  . . . . . . . . . . . . . . . . . .  6\n  1.5.  Data Integrity . . . . . . . . . . . . . . . . . . . . . .  6\n2.  Terminology and Definitions  . . . . . . . . . . . . . . . . .  6\n  2.1.  Signers  . . . . . . . . . . . . . . . . . . . . . . . . .  6\n  2.2.  Verifiers  . . . . . . . . . . . . . . . . . . . . . . . .  7\n  2.3.  Identity . . . . . . . . . . . . . . . . . . . . . . . . .  7\n  2.4.  Identifier . . . . . . . . . . . . . . . . . . . . . . . .  7\n  2.5.  Signing Domain Identifier (SDID) . . . . . . . . . . . . .  7\n  2.6.  Agent or User Identifier (AUID)  . . . . . . . . . . . . .  7\n  2.7.  Identity Assessor  . . . . . . . . . . . . . . . . . . . .  7\n  2.8.  Whitespace . . . . . . . . . . . . . . . . . . . . . . . .  8\n  2.9.  Imported ABNF Tokens . . . . . . . . . . . . . . . . . . .  8\n  2.10. Common ABNF Tokens . . . . . . . . . . . . . . . . . . . .  9\n  2.11. DKIM-Quoted-Printable  . . . . . . . . . . . . . . . . . .  9\n3.  Protocol Elements  . . . . . . . . . . . . . . . . . . . . . . 10\n  3.1.  Selectors  . . . . . . . . . . . . . . . . . . . . . . . . 10\n  3.2.  Tag=Value Lists  . . . . . . . . . . . . . . . . . . . . . 12\n  3.3.  Signing and Verification Algorithms  . . . . . . . . . . . 13\n  3.4.  Canonicalization . . . . . . . . . . . . . . . . . . . . . 14\n  3.5.  The DKIM-Signature Header Field  . . . . . . . . . . . . . 18",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  3.6.  Key Management and Representation  . . . . . . . . . . . . 26\n  3.7.  Computing the Message Hashes . . . . . . . . . . . . . . . 29\n  3.8.  Input Requirements . . . . . . . . . . . . . . . . . . . . 32\n  3.9.  Output Requirements  . . . . . . . . . . . . . . . . . . . 32\n  3.10. Signing by Parent Domains  . . . . . . . . . . . . . . . . 33\n  3.11. Relationship between SDID and AUID . . . . . . . . . . . . 33\n4.  Semantics of Multiple Signatures . . . . . . . . . . . . . . . 34\n  4.1.  Example Scenarios  . . . . . . . . . . . . . . . . . . . . 34\n  4.2.  Interpretation . . . . . . . . . . . . . . . . . . . . . . 35\n5.  Signer Actions . . . . . . . . . . . . . . . . . . . . . . . . 36\n  5.1.  Determine Whether the Email Should Be Signed and by\n        Whom . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n  5.2.  Select a Private Key and Corresponding Selector\n        Information  . . . . . . . . . . . . . . . . . . . . . . . 37\n  5.3.  Normalize the Message to Prevent Transport Conversions . . 37\n  5.4.  Determine the Header Fields to Sign  . . . . . . . . . . . 38\n  5.5.  Compute the Message Hash and Signature . . . . . . . . . . 43\n  5.6.  Insert the DKIM-Signature Header Field . . . . . . . . . . 43\n6.  Verifier Actions . . . . . . . . . . . . . . . . . . . . . . . 43\n  6.1.  Extract Signatures from the Message  . . . . . . . . . . . 44\n  6.2.  Communicate Verification Results . . . . . . . . . . . . . 49\n  6.3.  Interpret Results/Apply Local Policy . . . . . . . . . . . 50\n7.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 51\n  7.1.  Email Authentication Methods Registry  . . . . . . . . . . 51\n  7.2.  DKIM-Signature Tag Specifications  . . . . . . . . . . . . 51\n  7.3.  DKIM-Signature Query Method Registry . . . . . . . . . . . 52\n  7.4.  DKIM-Signature Canonicalization Registry . . . . . . . . . 52\n  7.5.  _domainkey DNS TXT Resource Record Tag Specifications  . . 53\n  7.6.  DKIM Key Type Registry . . . . . . . . . . . . . . . . . . 53\n  7.7.  DKIM Hash Algorithms Registry  . . . . . . . . . . . . . . 54\n  7.8.  DKIM Service Types Registry  . . . . . . . . . . . . . . . 54\n  7.9.  DKIM Selector Flags Registry . . . . . . . . . . . . . . . 55\n  7.10. DKIM-Signature Header Field  . . . . . . . . . . . . . . . 55\n8.  Security Considerations  . . . . . . . . . . . . . . . . . . . 55\n  8.1.  ASCII Art Attacks  . . . . . . . . . . . . . . . . . . . . 55\n  8.2.  Misuse of Body Length Limits (\"l=\" Tag)  . . . . . . . . . 55\n  8.3.  Misappropriated Private Key  . . . . . . . . . . . . . . . 56\n  8.4.  Key Server Denial-of-Service Attacks . . . . . . . . . . . 56\n  8.5.  Attacks against the DNS  . . . . . . . . . . . . . . . . . 57\n  8.6.  Replay/Spam Attacks  . . . . . . . . . . . . . . . . . . . 57\n  8.7.  Limits on Revoking Keys  . . . . . . . . . . . . . . . . . 58\n  8.8.  Intentionally Malformed Key Records  . . . . . . . . . . . 58\n  8.9.  Intentionally Malformed DKIM-Signature Header Fields . . . 58\n  8.10. Information Leakage  . . . . . . . . . . . . . . . . . . . 58\n  8.11. Remote Timing Attacks  . . . . . . . . . . . . . . . . . . 59\n  8.12. Reordered Header Fields  . . . . . . . . . . . . . . . . . 59\n  8.13. RSA Attacks  . . . . . . . . . . . . . . . . . . . . . . . 59\n  8.14. Inappropriate Signing by Parent Domains  . . . . . . . . . 59",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  8.15. Attacks Involving Extra Header Fields  . . . . . . . . . . 60\n9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 61\n  9.1.  Normative References . . . . . . . . . . . . . . . . . . . 61\n  9.2.  Informative References . . . . . . . . . . . . . . . . . . 62\nAppendix A.  Example of Use (INFORMATIVE)  . . . . . . . . . . . . 64\n  A.1.  The User Composes an Email . . . . . . . . . . . . . . . . 64\n  A.2.  The Email is Signed  . . . . . . . . . . . . . . . . . . . 65\n  A.3.  The Email Signature is Verified  . . . . . . . . . . . . . 66\nAppendix B.  Usage Examples (INFORMATIVE)  . . . . . . . . . . . . 67\n  B.1.  Alternate Submission Scenarios . . . . . . . . . . . . . . 67\n  B.2.  Alternate Delivery Scenarios . . . . . . . . . . . . . . . 69\nAppendix C.  Creating a Public Key (INFORMATIVE) . . . . . . . . . 71\n  C.1.  Compatibility with DomainKeys Key Records  . . . . . . . . 72\n  C.2.  RFC 4871 Compatibility . . . . . . . . . . . . . . . . . . 73\nAppendix D.  MUA Considerations (INFORMATIVE)  . . . . . . . . . . 73\nAppendix E.  Changes since RFC 4871  . . . . . . . . . . . . . . . 73\nAppendix F.  Acknowledgments . . . . . . . . . . . . . . . . . . . 75",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "DomainKeys Identified Mail (DKIM) permits a person, role, or organization to claim some responsibility for a message by associating a domain name [RFC1034] with the message [RFC5322], which they are authorized to use. This can be an author's organization, an operational relay, or one of their agents. Assertion of responsibility is validated through a cryptographic signature and by querying the Signer's domain directly to retrieve the appropriate public key. Message transit from author to recipient is through relays that typically make no substantive change to the message content and thus preserve the DKIM signature. A message can contain multiple signatures, from the same or different organizations involved with the message.",
      "ja": "ドメインキー・アイデンティファイド・メール（DKIM）は、それらが使用を許可されているメッセージ[RFC5322]、とドメイン名[RFC1034]を関連付けることによって、メッセージのためのいくつかの責任を主張する者、役割、または組織を可能にします。これは、著者の組織、業務リレー、またはその代理人のいずれかになります。責任のアサーションは、暗号署名を通じて、適切な公開鍵を取得するために直接署名者のドメインを照会することによって検証されます。レシピエントへの著者からのメッセージ通過は、典型的には、メッセージの内容に実質的な変更を加えていないので、DKIM署名を保存するリレーを介してです。メッセージは、メッセージに関与同一または異なる組織から、複数の署名を含むことができます。"
    },
    {
      "indent": 3,
      "text": "The approach taken by DKIM differs from previous approaches to message signing (e.g., Secure/Multipurpose Internet Mail Extensions (S/MIME) [RFC5751], OpenPGP [RFC4880]) in that:",
      "ja": "DKIMによって撮影されたアプローチは、署名メッセージに、以前のアプローチとは異なる（例えば、セキュア/多目的インターネットメール拡張（S / MIME）[RFC5751]のOpenPGP [RFC4880]）という。"
    },
    {
      "indent": 3,
      "text": "o the message signature is written as a message header field so that neither human recipients nor existing MUA (Mail User Agent) software is confused by signature-related content appearing in the message body;",
      "ja": "ヒトレシピエントも既存のMUA（メールユーザエージェント）のいずれも、ソフトウェアがメッセージ本体に現れる署名関連コンテンツによって混乱されるように、メッセージの署名は、メッセージのヘッダフィールドとして書き込まれ、O。"
    },
    {
      "indent": 3,
      "text": "o there is no dependency on public- and private-key pairs being issued by well-known, trusted certificate authorities;",
      "ja": "O、よく知られている信頼できる認証局によって発行された公的および秘密鍵のペアには依存関係はありません。"
    },
    {
      "indent": 3,
      "text": "o there is no dependency on the deployment of any new Internet protocols or services for public-key distribution or revocation;",
      "ja": "O公開鍵配布または失効のいずれかの新しいインターネットプロトコルやサービスの展開には依存関係はありません。"
    },
    {
      "indent": 3,
      "text": "o signature verification failure does not force rejection of the message;",
      "ja": "O署名検証の失敗は、メッセージの拒否を強制しません。"
    },
    {
      "indent": 3,
      "text": "o no attempt is made to include encryption as part of the mechanism; and",
      "ja": "O試みは、機構の一部として暗号化が含まれるようになされていません。そして"
    },
    {
      "indent": 3,
      "text": "o message archiving is not a design goal.",
      "ja": "Oメッセージのアーカイブは、設計目標ではありません。"
    },
    {
      "indent": 3,
      "text": "DKIM:",
      "ja": "DKI："
    },
    {
      "indent": 3,
      "text": "o is compatible with the existing email infrastructure and transparent to the fullest extent possible;",
      "ja": "Oは、可能最大限に既存の電子メールインフラストラクチャと互換性が透明です。"
    },
    {
      "indent": 3,
      "text": "o requires minimal new infrastructure;",
      "ja": "oは、最小限の新しいインフラストラクチャが必要です。"
    },
    {
      "indent": 3,
      "text": "o can be implemented independently of clients in order to reduce deployment time;",
      "ja": "oは、展開時間を短縮するために独立したクライアントの実装することができます。"
    },
    {
      "indent": 3,
      "text": "o can be deployed incrementally; and",
      "ja": "oはインクリメンタルに展開することができます。そして"
    },
    {
      "indent": 3,
      "text": "o allows delegation of signing to third parties.",
      "ja": "oは第三者に署名の委任を可能にします。"
    },
    {
      "indent": 0,
      "text": "1.1. DKIM Architecture Documents",
      "section_title": true,
      "ja": "1.1.  DKIアーキテクチャドキュメント"
    },
    {
      "indent": 3,
      "text": "Readers are advised to be familiar with the material in [RFC4686], [RFC5585], and [RFC5863], which provide the background for the development of DKIM, an overview of the service, and deployment and operations guidance and advice, respectively.",
      "ja": "読者はそれぞれ、DKIMの開発の背景、サービスの概要、および展開と運用指導・助言を提供[RFC4686]、[RFC5585]、および[RFC5863]で材料、に精通していることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "1.2. Signing Identity",
      "section_title": true,
      "ja": "1.2. 署名ID"
    },
    {
      "indent": 3,
      "text": "DKIM separates the question of the identity of the Signer of the message from the purported author of the message. In particular, a signature includes the identity of the Signer. Verifiers can use the signing information to decide how they want to process the message. The signing identity is included as part of the signature header field.",
      "ja": "DKIMは、メッセージの主張作者からのメッセージの署名者のアイデンティティの問題を分離します。具体的には、署名は、署名者のアイデンティティを含みます。検証者は、彼らがメッセージを処理する方法を決定するために署名の情報を使用することができます。署名IDは、署名ヘッダフィールドの一部として含まれています。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE RATIONALE: The signing identity specified by a DKIM signature is not required to match an address in any particular header field because of the broad methods of interpretation by recipient mail systems, including MUAs.",
      "ja": "有益な理論的根拠：DKIM署名で指定された署名は、アイデンティティためのMUAを含む受信者のメールシステムによって解釈の広い方法の任意の特定のヘッダフィールド内のアドレスと一致する必要はありません。"
    },
    {
      "indent": 0,
      "text": "1.3. Scalability",
      "section_title": true,
      "ja": "1.3. スケーラビリティ"
    },
    {
      "indent": 3,
      "text": "DKIM is designed to support the extreme scalability requirements that characterize the email identification problem. There are many millions of domains and a much larger number of individual addresses.",
      "ja": "DKIMは、電子メールの識別問題を特徴づける極端なスケーラビリティ要件をサポートするように設計されています。ドメインと個々のアドレスの非常に大きな数の何百万があります。"
    },
    {
      "indent": 3,
      "text": "DKIM seeks to preserve the positive aspects of the current email infrastructure, such as the ability for anyone to communicate with anyone else without introduction.",
      "ja": "DKIMは、このような誰でも導入することなく、他の誰と通信するための機能として、現在の電子メールインフラストラクチャの肯定的な側面を、維持することを目指しています。"
    },
    {
      "indent": 0,
      "text": "1.4. Simple Key Management",
      "section_title": true,
      "ja": "1.4. シンプルなキー管理"
    },
    {
      "indent": 3,
      "text": "DKIM differs from traditional hierarchical public-key systems in that no certificate authority infrastructure is required; the Verifier requests the public key from a repository in the domain of the claimed Signer directly rather than from a third party.",
      "ja": "DKIMが必要であることは証明機関インフラストラクチャにおける従来の階層型公開鍵システムとは異なります。 Verifierは、特許請求署名者のドメインのリポジトリから直接ではなく、第三者からの公開鍵を要求します。"
    },
    {
      "indent": 3,
      "text": "The DNS is proposed as the initial mechanism for the public keys. Thus, DKIM currently depends on DNS administration and the security of the DNS system. DKIM is designed to be extensible to other key fetching services as they become available.",
      "ja": "DNSは、公開鍵の初期メカニズムとして提案されています。したがって、DKIMは、現在、DNSの管理とDNSシステムのセキュリティに依存します。 DKIMは、それらが利用可能になると他のキーフェッチサービスに拡張できるように設計されています。"
    },
    {
      "indent": 0,
      "text": "1.5. Data Integrity",
      "section_title": true,
      "ja": "1.5. データの整合性"
    },
    {
      "indent": 3,
      "text": "A DKIM signature associates the \"d=\" name with the computed hash of some or all of the message (see Section 3.7) in order to prevent the reuse of the signature with different messages. Verifying the signature asserts that the hashed content has not changed since it was signed and asserts nothing else about \"protecting\" the end-to-end integrity of the message.",
      "ja": "DKIM署名は、メッセージの一部またはすべての計算されたハッシュと「D =」名前を関連付け異なるメッセージと署名の再使用を防止するために、（セクション3.7を参照）。署名を検証することは、署名後にハッシュされた内容が変更されていないことを主張すると、メッセージのエンドツーエンドの整合性を「保護」について何もをアサートしません。"
    },
    {
      "indent": 0,
      "text": "2. Terminology and Definitions",
      "section_title": true,
      "ja": "2.用語と定義"
    },
    {
      "indent": 3,
      "text": "This section defines terms used in the rest of the document.",
      "ja": "このセクションでは、ドキュメントの残りの部分で使用される用語を定義します。"
    },
    {
      "indent": 3,
      "text": "DKIM is designed to operate within the Internet Mail service, as defined in [RFC5598]. Basic email terminology is taken from that specification.",
      "ja": "DKIMは、[RFC5598]で定義されるように、インターネットメールサービス内で動作するように設計されています。基本的な電子メールの用語は、その仕様から取られています。"
    },
    {
      "indent": 3,
      "text": "Syntax descriptions use Augmented BNF (ABNF) [RFC5234].",
      "ja": "構文記述は、拡張BNF（ABNF）[RFC5234]を使用します。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119]. These words take their normative meanings only when they are presented in ALL UPPERCASE.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL 「本書では[RFC2119]で説明されるように解釈されるべきです。これらの言葉は、それらがすべて大文字に提示されている場合にのみ、その規範的な意味を取ります。"
    },
    {
      "indent": 0,
      "text": "2.1. Signers",
      "section_title": true,
      "ja": "2.1. 署名者"
    },
    {
      "indent": 3,
      "text": "Elements in the mail system that sign messages on behalf of a domain are referred to as Signers. These may be MUAs (Mail User Agents), MSAs (Mail Submission Agents), MTAs (Mail Transfer Agents), or other agents such as mailing list exploders. In general, any Signer will be involved in the injection of a message into the message system in some way. The key issue is that a message must be signed before it leaves the administrative domain of the Signer.",
      "ja": "ドメインの代わりにメッセージに署名メールシステム内の要素は、署名者と呼ばれています。これらはのMUA（メールユーザーエージェント）のMSA（メール発信エージェント）のMTA（メール転送エージェント）、またはそのようなメーリングリスト発破などの他の薬剤であってもよいです。一般に、任意の署名者は、何らかの方法でメッセージ・システムにメッセージの注入に関与します。重要な問題は、それが署名者の管理ドメインを離れる前に、メッセージが署名しなければならないということです。"
    },
    {
      "indent": 0,
      "text": "2.2. Verifiers",
      "section_title": true,
      "ja": "2.2. 検証者"
    },
    {
      "indent": 3,
      "text": "Elements in the mail system that verify signatures are referred to as Verifiers. These may be MTAs, Mail Delivery Agents (MDAs), or MUAs. In most cases, it is expected that Verifiers will be close to an end user (reader) of the message or some consuming agent such as a mailing list exploder.",
      "ja": "署名を検証するメールシステムの要素は、検証者と呼ばれます。これらは、MTAは、メール配送エージェント（のMDA）、またはのMUAであってもよいです。ほとんどの場合、検証者は、メーリングリスト発破としてメッセージまたはいくつかの消費エージェントのエンドユーザ（リーダ）に近くなることが予想されます。"
    },
    {
      "indent": 0,
      "text": "2.3. Identity",
      "section_title": true,
      "ja": "2.3. 身元"
    },
    {
      "indent": 3,
      "text": "A person, role, or organization. In the context of DKIM, examples include the author, the author's organization, an ISP along the handling path, an independent trust assessment service, and a mailing list operator.",
      "ja": "人、役割、または組織。 DKIMの文脈では、例として、著者、著者の組織、ハンドリング路に沿ってISP、独立した信頼性評価サービス、およびメーリングリストの演算子が含まれます。"
    },
    {
      "indent": 0,
      "text": "2.4. Identifier",
      "section_title": true,
      "ja": "2.4. 識別"
    },
    {
      "indent": 3,
      "text": "A label that refers to an identity.",
      "ja": "同一性をいうラベル。"
    },
    {
      "indent": 0,
      "text": "2.5. Signing Domain Identifier (SDID)",
      "section_title": true,
      "ja": "2.5. 署名ドメイン識別子（SDID）"
    },
    {
      "indent": 3,
      "text": "A single domain name that is the mandatory payload output of DKIM and that refers to the identity claiming some responsibility for the message by signing it. It is specified in Section 3.5.",
      "ja": "DKIMの必須ペイロード出力であり、それはそれに署名することによって、メッセージのいくつかの責任を主張しているアイデンティティーを指し、単一のドメイン名。これは、3.5節で指定されています。"
    },
    {
      "indent": 0,
      "text": "2.6. Agent or User Identifier (AUID)",
      "section_title": true,
      "ja": "2.6.  Agentまたはユーザ識別子（AUID）"
    },
    {
      "indent": 3,
      "text": "A single identifier that refers to the agent or user on behalf of whom the Signing Domain Identifier (SDID) has taken responsibility. The AUID comprises a domain name and an optional <local-part>. The domain name is the same as that used for the SDID or is a subdomain of it. For DKIM processing, the domain name portion of the AUID has only basic domain name semantics; any possible owner-specific semantics are outside the scope of DKIM. It is specified in Section 3.5.",
      "ja": "署名ドメイン識別子（SDID）に代わってエージェントまたはユーザーを指し、単一の識別子は、責任を取りました。 AUIDはドメイン名とオプションの<ローカル部分>を備えます。ドメイン名はSDIDのために使用されたものと同じであるかのサブドメインです。 DKIMの処理については、AUIDのドメイン名の部分は、基本的なドメイン名の意味を持っています。任意の可能な所有者固有のセマンティクスは、DKIMの範囲外です。これは、3.5節で指定されています。"
    },
    {
      "indent": 3,
      "text": "Note that acceptable values for the AUID may be constrained via a flag in the public-key record. (See Section 3.6.1.)",
      "ja": "AUIDの許容値は、公開鍵レコードにフラグを介して拘束されてもよいことに留意されたいです。 （セクション3.6.1を参照してください。）"
    },
    {
      "indent": 0,
      "text": "2.7. Identity Assessor",
      "section_title": true,
      "ja": "2.7. 身元評価"
    },
    {
      "indent": 3,
      "text": "An element in the mail system that consumes DKIM's payload, which is the responsible Signing Domain Identifier (SDID). The Identity Assessor is dedicated to the assessment of the delivered identifier.",
      "ja": "責任署名ドメイン識別子（SDID）であるDKIMのペイロードを、消費メールシステム内の要素。身元評価が配信識別子の評価に取り組んでいます。"
    },
    {
      "indent": 3,
      "text": "Other DKIM (and non-DKIM) values can also be used by the Identity Assessor (if they are available) to provide a more general message evaluation filtering engine. However, this additional activity is outside the scope of this specification.",
      "ja": "（それらが利用可能な場合）、他のDKIM（非DKIM）の値は、より一般的なメッセージ評価フィルタリングエンジンを提供するアイデンティティ評価者によって使用することができます。しかしながら、この追加の活性は、本明細書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "2.8. Whitespace",
      "section_title": true,
      "ja": "2.8. 空白"
    },
    {
      "indent": 3,
      "text": "There are three forms of whitespace:",
      "ja": "空白の3つの形式があります。"
    },
    {
      "indent": 3,
      "text": "o WSP represents simple whitespace, i.e., a space or a tab character (formal definition in [RFC5234]).",
      "ja": "O WSPは、単純な空白、すなわち、スペースまたはタブ文字（[RFC5234]で正式な定義）を表しています。"
    },
    {
      "indent": 3,
      "text": "o LWSP is linear whitespace, defined as WSP plus CRLF (formal definition in [RFC5234]).",
      "ja": "O LWSPはWSPプラスCRLF（[RFC5234]での正式な定義）として定義され、線形空白です。"
    },
    {
      "indent": 3,
      "text": "o FWS is folding whitespace. It allows multiple lines separated by CRLF followed by at least one whitespace, to be joined.",
      "ja": "O FWSは空白を折りたたみています。これは、CRLFで区切られた複数の線が接合される、少なくとも一つの空白に続くことができます。"
    },
    {
      "indent": 3,
      "text": "The formal ABNF for these are (WSP and LWSP are given for information only):",
      "ja": "これらの正式なABNFは（WSPとLWSPは情報だけのために与えられている）、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "WSP = SP / HTAB LWSP = *(WSP / CRLF WSP) FWS = [*WSP CRLF] 1*WSP",
      "ja": "WSP = SP / HTAB LWSP = *（WSP / CRLF WSP）FWS = [WSP CRLF *] 1 * WSP"
    },
    {
      "indent": 3,
      "text": "The definition of FWS is identical to that in [RFC5322] except for the exclusion of obs-FWS.",
      "ja": "FWSの定義は、OBS-FWSの除外を除き、[RFC5322]のものと同じです。"
    },
    {
      "indent": 0,
      "text": "2.9. Imported ABNF Tokens",
      "section_title": true,
      "ja": "2.9. 輸入ABNFトークン"
    },
    {
      "indent": 3,
      "text": "The following tokens are imported from other RFCs as noted. Those RFCs should be considered definitive.",
      "ja": "述べたように、次のトークンは、他のRFCから輸入されています。これらのRFCは決定的と考えるべきです。"
    },
    {
      "indent": 3,
      "text": "The following tokens are imported from [RFC5321]:",
      "ja": "次のトークンは[RFC5321]から輸入されています。"
    },
    {
      "indent": 3,
      "text": "o \"local-part\" (implementation warning: this permits quoted strings)",
      "ja": "O「ローカル部」（実装警告：これは引用符で囲まれた文字列を許可します）"
    },
    {
      "indent": 3,
      "text": "o \"sub-domain\"",
      "ja": "O「サブドメイン」"
    },
    {
      "indent": 3,
      "text": "The following tokens are imported from [RFC5322]:",
      "ja": "次のトークンは[RFC5322]から輸入されています。"
    },
    {
      "indent": 3,
      "text": "o \"field-name\" (name of a header field)",
      "ja": "O「フィールド名」（ヘッダ・フィールドの名前）"
    },
    {
      "indent": 3,
      "text": "o \"dot-atom-text\" (in the local-part of an email address)",
      "ja": "O「ドット原子テキスト」（電子メールアドレスのローカル部分で）"
    },
    {
      "indent": 3,
      "text": "The following tokens are imported from [RFC2045]:",
      "ja": "次のトークンは[RFC2045]から輸入されています。"
    },
    {
      "indent": 3,
      "text": "o \"qp-section\" (a single line of quoted-printable-encoded text) o \"hex-octet\" (a quoted-printable encoded octet)",
      "ja": "O \"QP-セクション\"（quoted-printableのエンコードテキストの単一行）を \"ヘキサオクテット\"（引用符で囲まれた、印刷可能な符号化されたオクテット）"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: Be aware that the ABNF in [RFC2045] does not obey the rules of [RFC5234] and must be interpreted accordingly, particularly as regards case folding.",
      "ja": "有益な注意：[RFC2045]でABNFは、[RFC5234]のルールに従わないと折り畳みケースに関して特にように、それに応じて解釈されなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Other tokens not defined herein are imported from [RFC5234]. These are intuitive primitives such as SP, HTAB, WSP, ALPHA, DIGIT, CRLF, etc.",
      "ja": "本明細書で定義されていない他のトークンは[RFC5234]からインポートされています。これらは、などSP、HTAB、WSP、ALPHA、DIGIT、CRLF、など直感的なプリミティブで"
    },
    {
      "indent": 0,
      "text": "2.10. Common ABNF Tokens",
      "section_title": true,
      "ja": "2.10. 共通のABNFトークン"
    },
    {
      "indent": 3,
      "text": "The following ABNF tokens are used elsewhere in this document:",
      "ja": "以下のABNFトークンは、この文書の他の場所で使用されています。"
    },
    {
      "indent": 3,
      "text": "hyphenated-word = ALPHA [ *(ALPHA / DIGIT / \"-\") (ALPHA / DIGIT) ] ALPHADIGITPS = (ALPHA / DIGIT / \"+\" / \"/\") base64string = ALPHADIGITPS *([FWS] ALPHADIGITPS) [ [FWS] \"=\" [ [FWS] \"=\" ] ] hdr-name = field-name qp-hdr-value = dkim-quoted-printable ; with \"|\" encoded",
      "ja": "ハイフンワード= ALPHA [*（ALPHA / DIGIT / \" - \"）（ALPHA / DIGIT）] ALPHADIGITPS =（ALPHA / DIGIT / \"+\" / \"/\"）base64string = ALPHADIGITPS *（[FWS] ALPHADIGITPS）[FWS ] \"=\" [[FWS] \"=\"]] HDR-名称=フィールド名QP-HDR値= DKIM-印刷可能引用。 「|」とエンコードされました"
    },
    {
      "indent": 0,
      "text": "2.11. DKIM-Quoted-Printable",
      "section_title": true,
      "ja": "2.11.  DKI-quoted-printableの"
    },
    {
      "indent": 3,
      "text": "The DKIM-Quoted-Printable encoding syntax resembles that described in Quoted-Printable [RFC2045], Section 6.7: any character MAY be encoded as an \"=\" followed by two hexadecimal digits from the alphabet \"0123456789ABCDEF\" (no lowercase characters permitted) representing the hexadecimal-encoded integer value of that character. All control characters (those with values < %x20), 8-bit characters (values > %x7F), and the characters DEL (%x7F), SPACE (%x20), and semicolon (\";\", %x3B) MUST be encoded. Note that all whitespace, including SPACE, CR, and LF characters, MUST be encoded. After encoding, FWS MAY be added at arbitrary locations in order to avoid excessively long lines; such whitespace is NOT part of the value, and MUST be removed before decoding. Use of characters not listed as \"mail-safe\" in [RFC2049] is NOT RECOMMENDED.",
      "ja": "任意の文字が「=」アルファベットから2つの16進数字「0123456789ABCDEF」が続くように符号化することができる（非小文字は許されない）を表す：DKIM-quoted-printable形式の符号化構文は、セクション6.7、引用符で囲まれた印刷可能な[RFC2045]に記載されたものに似ていますその文字の16進符号化された整数値。すべての制御文字（値を有するもの<％のX20）、8ビット文字（値>％のx7F）、及び文字DEL（％のx7F）、SPACE（％のX20）、及びセミコロン（ \";\" は、％X3B）がなければなりませんエンコードされました。 SPACE、CR、およびLF文字を含むすべての空白は、符号化されなければならないことに留意されたいです。符号化の後、FWSが過度に長い行を避けるために、任意の場所で添加することができます。そのような空白は、値の一部ではなく、復号化の前に除去しなければなりません。 [RFC2049]に「メールセーフ」として記載されていない文字の使用は推奨されません。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 3,
      "text": "dkim-quoted-printable = *(FWS / hex-octet / dkim-safe-char) ; hex-octet is from RFC2045 dkim-safe-char = %x21-3A / %x3C / %x3E-7E ; '!' - ':', '<', '>' - '~'",
      "ja": "DKIM-quoted-printableの= *（FWS /進オクテット/ DKIM-安全-CHAR）;六角オクテットは、RFC2045のDKIM-安全チャー=％x21-3A /％X3C /％Spark Proの-7Eからです。 '！' -  '：'、 '<'、 '>'  -  '〜'"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: DKIM-Quoted-Printable differs from Quoted-Printable as defined in [RFC2045] in several important ways:",
      "ja": "有益な注意：[RFC2045]で定義されているDKIM-quoted-printableのは、いくつかの重要な点でquoted-printable形式とは異なります。"
    },
    {
      "indent": 6,
      "text": "1. Whitespace in the input text, including CR and LF, must be encoded. [RFC2045] does not require such encoding, and does not permit encoding of CR or LF characters that are part of a CRLF line break.",
      "ja": "CRやLFを含む入力テキストにおける1空白は、符号化されなければなりません。 [RFC2045]は、そのような符号化を必要とせず、CRLFの改行の一部であるCRまたはLF文字の符号化を可能にしません。"
    },
    {
      "indent": 6,
      "text": "2. Whitespace in the encoded text is ignored. This is to allow tags encoded using DKIM-Quoted-Printable to be wrapped as needed. In particular, [RFC2045] requires that line breaks in the input be represented as physical line breaks; that is not the case here.",
      "ja": "エンコードされたテキスト2.空白は無視されます。これは、タグは、必要に応じてラップするようにDKIM-quoted-printable形式を使用してエンコードできるようにすることです。具体的には、[RFC2045]は入力に改行が物理改行として表されることを必要としますそれは、ここではそうではありません。"
    },
    {
      "indent": 6,
      "text": "3. The \"soft line break\" syntax (\"=\" as the last non-whitespace character on the line) does not apply.",
      "ja": "3.「ソフト改行」構文は、（「=」行の最後の非空白文字など）は適用されません。"
    },
    {
      "indent": 6,
      "text": "4. DKIM-Quoted-Printable does not require that encoded lines be no more than 76 characters long (although there may be other requirements depending on the context in which the encoded text is being used).",
      "ja": "（エンコードされたテキストが使用される文脈に応じて他の要件があるかもしれないが）4 DKIM-quoted-printable形式でエンコードされたラインがこれ以上76文字以下の長さである必要はありません。"
    },
    {
      "indent": 0,
      "text": "3. Protocol Elements",
      "section_title": true,
      "ja": "3.プロトコルの要素"
    },
    {
      "indent": 3,
      "text": "Protocol Elements are conceptual parts of the protocol that are not specific to either Signers or Verifiers. The protocol descriptions for Signers and Verifiers are described in later sections (\"Signer Actions\" (Section 5) and \"Verifier Actions\" (Section 6)). NOTE: This section must be read in the context of those sections.",
      "ja": "プロトコル要素は、署名者または検証者のいずれかに対して特異的ではないプロトコルの概念的な部分です。署名者と検証者のためのプロトコルの説明は後のセクション（「署名者アクション」（第5章）および「検証アクション」（第6節））に記載されています。注：このセクションでは、これらのセクションの文脈で読まなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.1. Selectors",
      "section_title": true,
      "ja": "3.1. セレクタ"
    },
    {
      "indent": 3,
      "text": "To support multiple concurrent public keys per signing domain, the key namespace is subdivided using \"selectors\". For example, selectors might indicate the names of office locations (e.g., \"sanfrancisco\", \"coolumbeach\", and \"reykjavik\"), the signing date (e.g., \"january2005\", \"february2005\", etc.), or even an individual user.",
      "ja": "署名ドメインごとに複数の同時公開鍵をサポートするために、キーの名前空間は、「セレクタ」を使用して細分化されています。例えば、セレクタは、オフィスの場所の名前（例えば、「サンフランシスコ北部」、「coolumbeach」、および「レイキャビク」）、署名の日付（例えば、「january2005」、「february2005」など）、あるいは個人を示している可能性がありますユーザー。"
    },
    {
      "indent": 3,
      "text": "Selectors are needed to support some important use cases. For example:",
      "ja": "セレクタは、いくつかの重要なユースケースをサポートするために必要な。例えば："
    },
    {
      "indent": 3,
      "text": "o Domains that want to delegate signing capability for a specific address for a given duration to a partner, such as an advertising provider or other outsourced function.",
      "ja": "このような広告提供者またはその他の外部委託された機能として、パートナーに与えられた期間に特定のアドレスのための署名機能を委任したいOドメイン、。"
    },
    {
      "indent": 3,
      "text": "o Domains that want to allow frequent travelers to send messages locally without the need to connect with a particular MSA.",
      "ja": "頻繁に旅行者は、特定のMSAと接続することなく、ローカルにメッセージを送信できるようにしたいOドメイン。"
    },
    {
      "indent": 3,
      "text": "o \"Affinity\" domains (e.g., college alumni associations) that provide forwarding of incoming mail, but that do not operate a mail submission agent for outgoing mail.",
      "ja": "受信メールの転送を提供O「親和性」ドメイン（例えば、大学の同窓会）が、それは、送信メールのメール送信エージェントを動作させないでください。"
    },
    {
      "indent": 3,
      "text": "Periods are allowed in selectors and are component separators. When keys are retrieved from the DNS, periods in selectors define DNS label boundaries in a manner similar to the conventional use in domain names. Selector components might be used to combine dates with locations, for example, \"march2005.reykjavik\". In a DNS implementation, this can be used to allow delegation of a portion of the selector namespace.",
      "ja": "期間はセレクタで許可されるとコンポーネント区切りされています。キーがDNSから取得された場合、セレクタにおける期間は、ドメイン名に従来の使用と同様にDNSラベルの境界を画定します。セレクタコンポーネントは、「march2005.reykjavik」例えば、場所と日付を組み合わせるために使用される可能性があります。 DNSの実装では、これはセレクタ名前空間の一部の委任を可能にするために使用することができます。"
    },
    {
      "indent": 3,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 3,
      "text": "selector = sub-domain *( \".\" sub-domain )",
      "ja": "セレクタ=サブドメイン*（「」サブドメイン）"
    },
    {
      "indent": 3,
      "text": "The number of public keys and corresponding selectors for each domain is determined by the domain owner. Many domain owners will be satisfied with just one selector, whereas administratively distributed organizations can choose to manage disparate selectors and key pairs in different regions or on different email servers.",
      "ja": "各ドメインのための公開鍵と対応するセレクタの数は、ドメイン所有者によって決定されます。管理上に分散した組織が異なる領域に、異なる電子メールサーバー上で異種のセレクタとキーのペアを管理するために選択することができ、一方、多くのドメイン所有者は、ただ1つのセレクタに満足されます。"
    },
    {
      "indent": 3,
      "text": "Beyond administrative convenience, selectors make it possible to seamlessly replace public keys on a routine basis. If a domain wishes to change from using a public key associated with selector \"january2005\" to a public key associated with selector \"february2005\", it merely makes sure that both public keys are advertised in the public-key repository concurrently for the transition period during which email may be in transit prior to verification. At the start of the transition period, the outbound email servers are configured to sign with the \"february2005\" private key. At the end of the transition period, the \"january2005\" public key is removed from the public-key repository.",
      "ja": "行政利便性を超えて、セレクタがシームレスに定期的に公開鍵を交換することを可能にします。ドメインは、セレクタ「february2005」に関連付けられた公開鍵セレクタ「january2005」に関連付けられた公開鍵を使用してから変更したい場合は、単に両方の公開鍵が中遷移期間に同時に公開鍵リポジトリにアドバタイズされることを確認しますこれは、電子メール輸送中の前に検証することがあります。移行期間の開始時に、送信メールサーバは「february2005」秘密鍵で署名するように構成されています。移行期間の終了時に、「january2005」公開鍵は、公開鍵リポジトリから除去されます。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: A key may also be revoked as described below. The distinction between revoking and removing a key selector record is subtle. When phasing out keys as described above, a signing domain would probably simply remove the key record after the transition period. However, a signing domain could elect to revoke the key (but maintain the key record) for a further period. There is no defined semantic difference between a revoked key and a removed key.",
      "ja": "有益な注意：キーはまた、後述のように取り消すことができます。キーセレクターレコードを無効と除去との間の区別は微妙です。上記のようにキーを段階的に廃止すると、署名ドメインは、おそらく単に移行期間の後にキーレコードを削除します。しかし、署名ドメインキーを取り消す（ただし、鍵レコードを維持する）、さらに期間にすることを選択できます。取り消されたキーと削除キーの間に定義された意味的な違いはありません。"
    },
    {
      "indent": 3,
      "text": "While some domains may wish to make selector values well-known, others will want to take care not to allocate selector names in a way that allows harvesting of data by outside parties. For example, if per-user keys are issued, the domain owner will need to decide whether to associate this selector directly with the name of a registered end user or make it some unassociated random value, such as a fingerprint of the public key.",
      "ja": "いくつかのドメインがセレクタ値は、よく知られているようにしたいかもしれないが、他の人が外部の第三者によるデータの収穫を可能にする方法で、セレクタ名を割り当てないように注意してくださいしたいと思うでしょう。ユーザごとのキーが発行された場合、ドメインの所有者は、登録されたエンド・ユーザーの名前と直接このセレクタを関連付けたり、そのような公開鍵の指紋のようないくつかの関連付けられていないランダムな値、作成するかどうかを決定する必要があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE OPERATIONS NOTE: Reusing a selector with a new key (for example, changing the key associated with a user's name) makes it impossible to tell the difference between a message that didn't verify because the key is no longer valid and a message that is actually forged. For this reason, Signers are ill-advised to reuse selectors for new keys. A better strategy is to assign new keys to new selectors.",
      "ja": "INFORMATIVE OPERATIONS注：新しいキーとセレクタを再利用する（例えば、ユーザ名に関連付けられたキーを変更する）ことは不可能キーが有効でなくなっているので、確認しませんでしたメッセージとメッセージの違いを教えてできるようになり実際に偽造されています。このため、署名者は、新しいキーのセレクタを再利用するために無分別です。より良い戦略は、新しいセレクタに新しいキーを割り当てることです。"
    },
    {
      "indent": 0,
      "text": "3.2. Tag=Value Lists",
      "section_title": true,
      "ja": "3.2. タグ=値リスト"
    },
    {
      "indent": 3,
      "text": "DKIM uses a simple \"tag=value\" syntax in several contexts, including in messages and domain signature records.",
      "ja": "DKIMはメッセージとドメイン署名レコードに含め、いくつかの状況では、単純な「タグ=値」の構文を使用しています。"
    },
    {
      "indent": 3,
      "text": "Values are a series of strings containing either plain text, \"base64\" text (as defined in [RFC2045], Section 6.8), \"qp-section\" (ibid, Section 6.7), or \"dkim-quoted-printable\" (as defined in Section 2.11). The name of the tag will determine the encoding of each value. Unencoded semicolon (\";\") characters MUST NOT occur in the tag value, since that separates tag-specs.",
      "ja": "定義されたような値は、プレーンテキスト、「BASE64」テキスト（[RFC2045]で定義されるように、セクション6.8）、「QP-セクション」（同書、セクション6.7）、または「DKIM引用符で囲まれた印刷可能な」（いずれかを含む一連の文字列であります2.11で）。タグの名前は、各値の符号を決定します。エンコードされていないセミコロン（「;」）は、タグ・スペックを分離するための文字は、タグ値で発生してはいけません。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTATION NOTE: Although the \"plain text\" defined below (as \"tag-value\") only includes 7-bit characters, an implementation that wished to anticipate future standards would be advised not to preclude the use of UTF-8-encoded ([RFC3629]) text in tag=value lists.",
      "ja": "有益な実装上の注意：以下に定義「プレーンテキスト」が、7ビット文字だけを含んでいる（「タグ値」として）、将来の規格を先取りすることを望んだの実装がUTF-8でエンコードされたの使用を排除しないことをお勧めされます（ [RFC3629]）タグ=値リスト内のテキスト。"
    },
    {
      "indent": 3,
      "text": "Formally, the ABNF syntax rules are as follows:",
      "ja": "次のように形式的には、ABNFの構文規則は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "tag-list = tag-spec *( \";\" tag-spec ) [ \";\" ] tag-spec = [FWS] tag-name [FWS] \"=\" [FWS] tag-value [FWS] tag-name = ALPHA *ALNUMPUNC tag-value = [ tval *( 1*(WSP / FWS) tval ) ] ; Prohibits WSP and FWS at beginning and end tval = 1*VALCHAR VALCHAR = %x21-3A / %x3C-7E ; EXCLAMATION to TILDE except SEMICOLON ALNUMPUNC = ALPHA / DIGIT / \"_\"",
      "ja": "タグリスト=タグスペック*（「;」タグ仕様）「」 】タグ・スペック= [FWS]タグ名[FWS] \"=\" [FWS]タグ値[FWS]タグ名= ALPHA * ALNUMPUNCタグ値= [TVAL *（1 *（WSP / FWS）TVAL） ]; WSPとFWSは、最初と最後TVAL = 1 * VALCHAR VALCHAR =％x21-3A /％X3C-7Eに禁止しています。 SEMICOLON ALNUMPUNC = ALPHA / DIGIT / \"_\" を除くTILDEにEXCLAMATION"
    },
    {
      "indent": 3,
      "text": "Note that WSP is allowed anywhere around tags. In particular, any WSP after the \"=\" and any WSP before the terminating \";\" is not part of the value; however, WSP inside the value is significant.",
      "ja": "WSPは、タグの周りのどこに許可されていることに注意してください。具体的には、「=」の後に任意のWSPと終了する前に、任意のWSP「;」値の一部ではありません。しかし、値内のWSPが重要です。"
    },
    {
      "indent": 3,
      "text": "Tags MUST be interpreted in a case-sensitive manner. Values MUST be processed as case sensitive unless the specific tag description of semantics specifies case insensitivity.",
      "ja": "タグは大文字と小文字を区別した方法で解釈されなければなりません。セマンティクスの特定のタグの記述はケース非感受性を指定しない限り、値は大文字と小文字を区別として処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Tags with duplicate names MUST NOT occur within a single tag-list; if a tag name does occur more than once, the entire tag-list is invalid.",
      "ja": "重複した名前を持つタグは、単一のタグリスト内で発生してはなりません。タグ名が複数回発生した場合は、全体のタグリストは無効です。"
    },
    {
      "indent": 3,
      "text": "Whitespace within a value MUST be retained unless explicitly excluded by the specific tag description.",
      "ja": "明示的に特定のタグの記述によって除外されない限り値内の空白は保持されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Tag=value pairs that represent the default value MAY be included to aid legibility.",
      "ja": "タグ=デフォルト値を表す値のペアは、読みやすさを支援するために含まれるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Unrecognized tags MUST be ignored.",
      "ja": "認識できないタグは無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Tags that have an empty value are not the same as omitted tags. An omitted tag is treated as having the default value; a tag with an empty value explicitly designates the empty string as the value.",
      "ja": "空の値を持つタグは省略タグと同じではありません。省略タグは、デフォルト値を有するものとして扱われます。空の値を持つタグが明示的に値として空の文字列を指定します。"
    },
    {
      "indent": 0,
      "text": "3.3. Signing and Verification Algorithms",
      "section_title": true,
      "ja": "3.3. 署名と検証アルゴリズム"
    },
    {
      "indent": 3,
      "text": "DKIM supports multiple digital signature algorithms. Two algorithms are defined by this specification at this time: rsa-sha1 and rsa-sha256. Signers MUST implement and SHOULD sign using rsa-sha256. Verifiers MUST implement both rsa-sha1 and rsa-sha256.",
      "ja": "DKIMは、複数のデジタル署名アルゴリズムをサポートしています。 RSA-SHA1とRSA-SHA256：2つのアルゴリズムは、この時点でこの仕様で定義されています。署名者は、実装しなければならないとRSA-SHA256を使用してサインインする必要があります。検証者は、RSA-SHA1とRSA-SHA256の両方を実装しなければなりません。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: Although rsa-sha256 is strongly encouraged, some senders might prefer to use rsa-sha1 when balancing security strength against performance, complexity, or other needs. In general, however, rsa-sha256 should always be used whenever possible.",
      "ja": "有益な注意：RSA-SHA256が強く推奨されているが、一部の送信者は、性能、複雑さ、または他のニーズに対して、セキュリティ強度のバランスを取る際に、RSA-SHA1を使用することを好むかもしれません。しかし、一般に、RSA-SHA256は常に可能な限り使用すべきです。"
    },
    {
      "indent": 0,
      "text": "3.3.1. The rsa-sha1 Signing Algorithm",
      "section_title": true,
      "ja": "3.3.1.  RSA-SHA1署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The rsa-sha1 Signing Algorithm computes a message hash as described in Section 3.7 using SHA-1 [FIPS-180-3-2008] as the hash-alg. That hash is then signed by the Signer using the RSA algorithm (defined in Public-Key Cryptography Standards (PKCS) #1 version 1.5 [RFC3447]) as the crypt-alg and the Signer's private key. The hash MUST NOT be truncated or converted into any form other than the native binary form before being signed. The signing algorithm SHOULD use a public exponent of 65537.",
      "ja": "SHA-1を使用して、3.7節で説明したように、RSA-SHA1署名アルゴリズムは、ハッシュ-ALGとして[FIPS-180-3-2008]メッセージのハッシュを計算します。そのハッシュはその後、クリプト-ALGと署名者の秘密鍵として（公開鍵暗号規格で定義されている（PKCS）＃1バージョン1.5 [RFC3447]）RSAアルゴリズムを使用して署名者によって署名されています。ハッシュは、切り捨て又は署名される前にネイティブバイナリ形式以外の形式に変換してはいけません。署名アルゴリズムは、65537の公開指数を使用すべきです。"
    },
    {
      "indent": 0,
      "text": "3.3.2. The rsa-sha256 Signing Algorithm",
      "section_title": true,
      "ja": "3.3.2.  RSA-SHA256署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The rsa-sha256 Signing Algorithm computes a message hash as described in Section 3.7 using SHA-256 [FIPS-180-3-2008] as the hash-alg. That hash is then signed by the Signer using the RSA algorithm (defined in",
      "ja": "SHA-256を使用して、3.7節で説明したようにアルゴリズムを署名RSA-SHA256ハッシュ-ALGとして[FIPS-180-3-2008]メッセージのハッシュを計算します。そのハッシュは、次にRSAアルゴリズムを使用して署名者により署名された（で定義されています"
    },
    {
      "indent": 3,
      "text": "PKCS#1 version 1.5 [RFC3447]) as the crypt-alg and the Signer's private key. The hash MUST NOT be truncated or converted into any form other than the native binary form before being signed. The signing algorithm SHOULD use a public exponent of 65537.",
      "ja": "暗号-ALGと署名者の秘密鍵などPKCS＃1バージョン1.5 [RFC3447]）。ハッシュは、切り捨て又は署名される前にネイティブバイナリ形式以外の形式に変換してはいけません。署名アルゴリズムは、65537の公開指数を使用すべきです。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Key Sizes",
      "section_title": true,
      "ja": "3.3.3. 鍵のサイズ"
    },
    {
      "indent": 3,
      "text": "Selecting appropriate key sizes is a trade-off between cost, performance, and risk. Since short RSA keys more easily succumb to off-line attacks, Signers MUST use RSA keys of at least 1024 bits for long-lived keys. Verifiers MUST be able to validate signatures with keys ranging from 512 bits to 2048 bits, and they MAY be able to validate signatures with larger keys. Verifier policies may use the length of the signing key as one metric for determining whether a signature is acceptable.",
      "ja": "適切なキーサイズを選択することは、コスト、性能、およびリスクの間のトレードオフです。短いRSAキーをより容易にオフライン攻撃に屈するので、署名者は、長寿命のキーに対して少なくとも1024ビットのRSAキーを使用しなければなりません。検証者は、512ビットから2048ビットまでの範囲のキーで署名を検証できなければならない、と彼らは、より大きなキーで署名を検証することができるかもしれません。検証ポリシーは、署名が許容可能であるか否かを決定するための1つの指標として、署名鍵の長さを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Factors that should influence the key size choice include the following:",
      "ja": "キーサイズの選択に影響を与える必要がある要因には次のものがあります。"
    },
    {
      "indent": 3,
      "text": "o The practical constraint that large (e.g., 4096-bit) keys might not fit within a 512-byte DNS UDP response packet",
      "ja": "大きい（例えば、4096ビット）のキーは、512バイトのDNS UDP応答パケットに収まらない可能性があることの実用的な制約O"
    },
    {
      "indent": 3,
      "text": "o The security constraint that keys smaller than 1024 bits are subject to off-line attacks",
      "ja": "O 1024ビットより小さいキーがオフライン攻撃の対象となるセキュリティ制約"
    },
    {
      "indent": 3,
      "text": "o Larger keys impose higher CPU costs to verify and sign email",
      "ja": "O大きなキーは、電子メールを確認し、署名する高いCPUコストを課します"
    },
    {
      "indent": 3,
      "text": "o Keys can be replaced on a regular basis; thus, their lifetime can be relatively short",
      "ja": "Oキーは定期的に交換することができます。このように、彼らの寿命が比較的短くすることができ"
    },
    {
      "indent": 3,
      "text": "o The security goals of this specification are modest compared to typical goals of other systems that employ digital signatures",
      "ja": "この仕様のセキュリティ目標Oデジタル署名を使用する他のシステムの典型的な目標に比べて控えめです"
    },
    {
      "indent": 3,
      "text": "See [RFC3766] for further discussion on selecting key sizes.",
      "ja": "キーのサイズを選択する上でさらなる議論のための[RFC3766]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.4. Other Algorithms",
      "section_title": true,
      "ja": "3.3.4. その他のアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Other algorithms MAY be defined in the future. Verifiers MUST ignore any signatures using algorithms that they do not implement.",
      "ja": "他のアルゴリズムは、将来的に定義されるかもしれません。検証者は、彼らが実装していないアルゴリズムを使用して任意の署名を無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.4. Canonicalization",
      "section_title": true,
      "ja": "3.4. 正規化"
    },
    {
      "indent": 3,
      "text": "Some mail systems modify email in transit, potentially invalidating a signature. For most Signers, mild modification of email is immaterial to validation of the DKIM domain name's use. For such Signers, a canonicalization algorithm that survives modest in-transit modification is preferred.",
      "ja": "いくつかのメールシステムは、潜在的に署名を無効、輸送中に電子メールを変更します。ほとんどの署名者のために、電子メールの軽度の変更はDKIMドメイン名の使用の検証に重要ではありません。このような署名者のために、適度にトランジット修飾を存続正規化アルゴリズムが好ましいです。"
    },
    {
      "indent": 3,
      "text": "Other Signers demand that any modification of the email, however minor, result in a signature verification failure. These Signers prefer a canonicalization algorithm that does not tolerate in-transit modification of the signed email.",
      "ja": "他の署名者は、電子メールのいずれかの変更が、しかしマイナー、署名検証の失敗につながることを要求します。これらの署名者は、署名された電子メールの輸送中の変更を許容しない正規化アルゴリズムを好みます。"
    },
    {
      "indent": 3,
      "text": "Some Signers may be willing to accept modifications to header fields that are within the bounds of email standards such as [RFC5322], but are unwilling to accept any modification to the body of messages.",
      "ja": "いくつかの署名者は、[RFC5322]のような電子メール規格の範囲内であるが、メッセージの本体にいかなる変更を受け入れること不本意なフィールドをヘッダに変更を受け入れることができます。"
    },
    {
      "indent": 3,
      "text": "To satisfy all requirements, two canonicalization algorithms are defined for each of the header and the body: a \"simple\" algorithm that tolerates almost no modification and a \"relaxed\" algorithm that tolerates common modifications such as whitespace replacement and header field line rewrapping. A Signer MAY specify either algorithm for header or body when signing an email. If no canonicalization algorithm is specified by the Signer, the \"simple\" algorithm defaults for both header and body. Verifiers MUST implement both canonicalization algorithms. Note that the header and body may use different canonicalization algorithms. Further canonicalization algorithms MAY be defined in the future; Verifiers MUST ignore any signatures that use unrecognized canonicalization algorithms.",
      "ja": "ほとんど変形や、空白交換ヘッダフィールドラインリラップなどの一般的な変形を許容する「リラックス」アルゴリズムを許容する「単純な」アルゴリズム：すべての要件を満たすために、二つの正規化アルゴリズムは、ヘッダとボディの各々のために定義されています。メールに署名するとき、署名者は、ヘッダーまたは本文のためのアルゴリズムのいずれかを指定するかもしれません。いかなる正規化アルゴリズムは、署名者、ヘッダと本体の両方のための「単純な」アルゴリズムのデフォルトで指定されていない場合。検証者は、両方の正規化アルゴリズムを実装しなければなりません。ヘッダとボディが別の正規化アルゴリズムを使用してもよいことに留意されたいです。また、正規化アルゴリズムは、将来定義されるかもしれません。検証者は、認識されていない正規化アルゴリズムを使用するすべての署名を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Canonicalization simply prepares the email for presentation to the signing or verification algorithm. It MUST NOT change the transmitted data in any way. Canonicalization of header fields and body are described below.",
      "ja": "正規化は、単に署名または検証アルゴリズムに提示するための電子メールを準備します。それはどのような方法で送信されるデータを変更してはなりません。ヘッダーフィールドと本体の正規化は、以下に記載されています。"
    },
    {
      "indent": 3,
      "text": "NOTE: This section assumes that the message is already in \"network normal\" format (text is ASCII encoded, lines are separated with CRLF characters, etc.). See also Section 5.3 for information about normalizing the message.",
      "ja": "注：このセクションでは、メッセージは、（テキストをASCII符号化され、線は等、CRLF文字で分離されている）、「ネットワーク正常」形式で既にあることを前提としています。メッセージを正規化については、また、5.3節を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.4.1. The \"simple\" Header Canonicalization Algorithm",
      "section_title": true,
      "ja": "3.4.1.  「シンプル」ヘッダー正規化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The \"simple\" header canonicalization algorithm does not change header fields in any way. Header fields MUST be presented to the signing or verification algorithm exactly as they are in the message being signed or verified. In particular, header field names MUST NOT be case folded and whitespace MUST NOT be changed.",
      "ja": "「シンプル」ヘッダー正規化アルゴリズムは、どのような方法でヘッダフィールドは変更されません。ヘッダーフィールドは、彼らが署名または検証されたメッセージにあるとおりに署名または検証アルゴリズムに提示されなければなりません。具体的には、ヘッダフィールド名は、大文字は折り畳まれてはいけませんと空白は変更してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.4.2. The \"relaxed\" Header Canonicalization Algorithm",
      "section_title": true,
      "ja": "3.4.2.  「リラックス」ヘッダー正規化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The \"relaxed\" header canonicalization algorithm MUST apply the following steps in order:",
      "ja": "「リラックス」ヘッダー正規化アルゴリズムは、順序で次の手順を適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Convert all header field names (not the header field values) to lowercase. For example, convert \"SUBJect: AbC\" to \"subject: AbC\".",
      "ja": "O小文字に全てのヘッダフィールド名（ないヘッダフィールド値）を変換します。 「：ABC対象」に：たとえば、「ABC件名を」変換します。"
    },
    {
      "indent": 3,
      "text": "o Unfold all header field continuation lines as described in [RFC5322]; in particular, lines with terminators embedded in continued header field values (that is, CRLF sequences followed by WSP) MUST be interpreted without the CRLF. Implementations MUST NOT remove the CRLF at the end of the header field value.",
      "ja": "[RFC5322]に記載されているようにOすべてのヘッダーフィールド継続行を広げ。具体的には、継続的なヘッダフィールド値に埋め込まれたターミネーターを有する行（すなわち、WSP続くCRLFシーケンスである）CRLFなしで解釈されなければなりません。実装は、ヘッダフィールド値の末尾にCRLFを削除してはいけません。"
    },
    {
      "indent": 3,
      "text": "o Convert all sequences of one or more WSP characters to a single SP character. WSP characters here include those before and after a line folding boundary.",
      "ja": "OシングルSP文字への1つ以上のWSPキャラクタのすべてのシーケンスを変換します。ここでWSP文字は境界を折りたたみライン前後のものが含まれます。"
    },
    {
      "indent": 3,
      "text": "o Delete all WSP characters at the end of each unfolded header field value.",
      "ja": "Oの各展開ヘッダフィールド値の最後に全てWSP文字を削除します。"
    },
    {
      "indent": 3,
      "text": "o Delete any WSP characters remaining before and after the colon separating the header field name from the header field value. The colon separator MUST be retained.",
      "ja": "Oヘッダフィールド値からヘッダフィールド名を分離コロンの前と後に残る任意のWSP文字を削除します。コロン区切りは保持されなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.4.3. The \"simple\" Body Canonicalization Algorithm",
      "section_title": true,
      "ja": "3.4.3.  「シンプル」ボディ正規化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The \"simple\" body canonicalization algorithm ignores all empty lines at the end of the message body. An empty line is a line of zero length after removal of the line terminator. If there is no body or no trailing CRLF on the message body, a CRLF is added. It makes no other changes to the message body. In more formal terms, the \"simple\" body canonicalization algorithm converts \"*CRLF\" at the end of the body to a single \"CRLF\".",
      "ja": "「シンプル」ボディ正規化アルゴリズムは、メッセージ本文の最後にすべての空行を無視します。空のラインは、ラインターミネータを除去した後の長さゼロのラインです。メッセージ本文には、本体または末尾のCRLFがない場合、CRLFが追加されます。これは、メッセージ本文にその他の変更を行うものではありません。より正式な用語では、「シンプル」のボディ正規化アルゴリズムは、単一の「CRLF」に、本体の末尾に「* CRLF」を変換します。"
    },
    {
      "indent": 3,
      "text": "Note that a completely empty or missing body is canonicalized as a single \"CRLF\"; that is, the canonicalized length will be 2 octets.",
      "ja": "完全に空または欠落体が単一の「CRLF」として正規化されていることに留意されたいです。つまり、正規化された長さは2つのオクテットになります。"
    },
    {
      "indent": 3,
      "text": "The SHA-1 value (in base64) for an empty body (canonicalized to a \"CRLF\") is:",
      "ja": "（「CRLF」に正規化）空のボディ用SHA-1値は、（BASE64で）です。"
    },
    {
      "indent": 3,
      "text": "uoq1oCgLlTqpdDX/iUbLy7J1Wic=",
      "ja": "uoq1oCgLlTqpdDX / iUbLy7J1Wic ="
    },
    {
      "indent": 3,
      "text": "The SHA-256 value is:",
      "ja": "SHA-256の値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN/XKdLCPjaYaY=",
      "ja": "frcCV1k9oG9oKj3dpUqdJg1PxRT2RSN / XKdLCPjaYaY ="
    },
    {
      "indent": 0,
      "text": "3.4.4. The \"relaxed\" Body Canonicalization Algorithm",
      "section_title": true,
      "ja": "3.4.4.  「リラックス」ボディ正規化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The \"relaxed\" body canonicalization algorithm MUST apply the following steps (a) and (b) in order:",
      "ja": "「リラックス」ボディ正規化アルゴリズムは、以下のステップ（a）と（b）の順序で適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "a. Reduce whitespace:",
      "ja": "A。空白を削減："
    },
    {
      "indent": 7,
      "text": "*  Ignore all whitespace at the end of lines.  Implementations\n   MUST NOT remove the CRLF at the end of the line.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* Reduce all sequences of WSP within a line to a single SP character.",
      "ja": "*シングルSP文字にライン内WSPのすべてのシーケンスを削減します。"
    },
    {
      "indent": 3,
      "text": "b. Ignore all empty lines at the end of the message body. \"Empty line\" is defined in Section 3.4.3. If the body is non-empty but does not end with a CRLF, a CRLF is added. (For email, this is only possible when using extensions to SMTP or non-SMTP transport mechanisms.)",
      "ja": "B。メッセージ本文の最後に、すべての空行を無視します。 「空の行は、」3.4.3で定義されています。体が非空であるが、CRLFで終了していない場合は、CRLFが追加されます。 （SMTPまたはSMTP以外の搬送機構への拡張を使用する場合、電子メールの場合、これは可能です。）"
    },
    {
      "indent": 3,
      "text": "The SHA-1 value (in base64) for an empty body (canonicalized to a null input) is:",
      "ja": "（ヌル入力に正規化）空のボディ用SHA-1値は、（BASE64で）です。"
    },
    {
      "indent": 3,
      "text": "2jmj7l5rSw0yVb/vlWAYkK/YBwk=",
      "ja": "2jmj7l5rSw0yVb / vlWAYkK / YBwk ="
    },
    {
      "indent": 3,
      "text": "The SHA-256 value is:",
      "ja": "SHA-256の値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
      "ja": "47DEQpj8HBSa + /私は名誉+ 5JCeuQeRkm5NMpJWZG3hSuFU ="
    },
    {
      "indent": 0,
      "text": "3.4.5. Canonicalization Examples (INFORMATIVE)",
      "section_title": true,
      "ja": "3.4.5. 正規化の例（参考）"
    },
    {
      "indent": 3,
      "text": "In the following examples, actual whitespace is used only for clarity. The actual input and output text is designated using bracketed descriptors: \"<SP>\" for a space character, \"<HTAB>\" for a tab character, and \"<CRLF>\" for a carriage-return/line-feed sequence. For example, \"X <SP> Y\" and \"X<SP>Y\" represent the same three characters.",
      "ja": "以下の実施例では、実際の空白は、明確にするために使用されます。実際の入力と出力のテキストは括弧の記述子を使用して指定されている：「<SP>」空白文字のために、「<HTAB>」タブ文字のため、そして「<CRLF>」復帰/改行シーケンスのために。例えば、 \"X <SP> Y\" と \"X <SP> Y\" は、同じ3つの文字を表します。"
    },
    {
      "indent": 3,
      "text": "Example 1: A message reading:",
      "ja": "実施例1：メッセージの読み取り："
    },
    {
      "indent": 3,
      "text": "A: <SP> X <CRLF> B <SP> : <SP> Y <HTAB><CRLF> <HTAB> Z <SP><SP><CRLF> <CRLF> <SP> C <SP><CRLF> D <SP><HTAB><SP> E <CRLF> <CRLF> <CRLF>",
      "ja": "<SP> X <CRLF> B <SP> <SP> Y <HTAB> <CRLF> <HTAB> Z <SP> <SP> <CRLF> <CRLF> <SP> C <SP> <CRLF> D <SP> <HTAB> <SP> E <CRLF> <CRLF> <CRLF>"
    },
    {
      "indent": 3,
      "text": "when canonicalized using relaxed canonicalization for both header and body results in a header reading:",
      "ja": "ヘッダの読み取りの両方のヘッダとボディな結果を得るために、リラックスした正規化を用いて正規化するとき："
    },
    {
      "indent": 3,
      "text": "a:X <CRLF> b:Y <SP> Z <CRLF>",
      "ja": "A：X <CRLF> B：Y <SP> Z <CRLF>"
    },
    {
      "indent": 3,
      "text": "and a body reading:",
      "ja": "そして体が読んで："
    },
    {
      "indent": 3,
      "text": "<SP> C <CRLF> D <SP> E <CRLF>",
      "ja": "<SP> C <CRLF> D <SP> E <CRLF>"
    },
    {
      "indent": 3,
      "text": "Example 2: The same message canonicalized using simple canonicalization for both header and body results in a header reading:",
      "ja": "実施例2：同じメッセージがヘッダ読み取りの両方のヘッダとボディな結果を得るために、単純な正規化を用いて正規化："
    },
    {
      "indent": 3,
      "text": "A: <SP> X <CRLF> B <SP> : <SP> Y <HTAB><CRLF> <HTAB> Z <SP><SP><CRLF>",
      "ja": "<SP> X <CRLF> B <SP> <SP> Y <HTAB> <CRLF> <HTAB> Z <SP> <SP> <CRLF>"
    },
    {
      "indent": 3,
      "text": "and a body reading:",
      "ja": "そして体が読んで："
    },
    {
      "indent": 3,
      "text": "<SP> C <SP><CRLF> D <SP><HTAB><SP> E <CRLF>",
      "ja": "<SP> C <SP> <CRLF> D <SP> <HTAB> <SP> E <CRLF>"
    },
    {
      "indent": 3,
      "text": "Example 3: When processed using relaxed header canonicalization and simple body canonicalization, the canonicalized version has a header of:",
      "ja": "実施例3：緩和ヘッダ正規化及び単体の正規化を使用して処理する場合、正規化バージョンは、ヘッダを有します。"
    },
    {
      "indent": 3,
      "text": "a:X <CRLF> b:Y <SP> Z <CRLF>",
      "ja": "A：X <CRLF> B：Y <SP> Z <CRLF>"
    },
    {
      "indent": 3,
      "text": "and a body reading:",
      "ja": "そして体が読んで："
    },
    {
      "indent": 3,
      "text": "<SP> C <SP><CRLF> D <SP><HTAB><SP> E <CRLF>",
      "ja": "<SP> C <SP> <CRLF> D <SP> <HTAB> <SP> E <CRLF>"
    },
    {
      "indent": 0,
      "text": "3.5. The DKIM-Signature Header Field",
      "section_title": true,
      "ja": "3.5.  DKIM  - 署名ヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "The signature of the email is stored in the DKIM-Signature header field. This header field contains all of the signature and key-fetching data. The DKIM-Signature value is a tag-list as described in Section 3.2.",
      "ja": "電子メールの署名は、DKIM署名ヘッダフィールドに格納されています。このヘッダーフィールドは、署名と鍵フェッチデータのすべてを含みます。セクション3.2で説明したようにDKIM署名値は、タグリストです。"
    },
    {
      "indent": 3,
      "text": "The DKIM-Signature header field SHOULD be treated as though it were a trace header field as defined in Section 3.6 of [RFC5322] and hence SHOULD NOT be reordered and SHOULD be prepended to the message.",
      "ja": "DKIM-Signatureヘッダーフィールドは、[RFC5322]のセクション3.6で定義されるように、トレースヘッダフィールドであるかのように扱われるべきであり、したがって並べ替えられるべきではなく、メッセージの先頭に付加されるべきです。"
    },
    {
      "indent": 3,
      "text": "The DKIM-Signature header field being created or verified is always included in the signature calculation, after the rest of the header fields being signed; however, when calculating or verifying the signature, the value of the \"b=\" tag (signature value) of that DKIM-Signature header field MUST be treated as though it were an empty string. Unknown tags in the DKIM-Signature header field MUST be included in the signature calculation but MUST be otherwise ignored by Verifiers. Other DKIM-Signature header fields that are included in the signature should be treated as normal header fields; in particular, the \"b=\" tag is not treated specially.",
      "ja": "ヘッダフィールドの残りの部分が署名された後に作成または検証さDKIM署名ヘッダフィールドは常に、署名の計算に含まれています。署名を計算または検証するとき、それは空の文字列であるかのようしかし、そのDKIM-Signatureヘッダーフィールドの「B =」タグ（署名値）の値は、処理されなければなりません。 DKIM署名ヘッダフィールドの未知のタグは、署名計算に含まれなければならないが、そうでなければ検証者によって無視されなければなりません。署名に含まれる他のDKIM-Signatureヘッダーフィールドは、通常のヘッダーフィールドとして扱われるべきです。具体的には、「B =」タグは、特別に処理されていません。"
    },
    {
      "indent": 3,
      "text": "The encodings for each field type are listed below. Tags described as qp-section are encoded as described in Section 6.7 of MIME Part One [RFC2045], with the additional conversion of semicolon characters to \"=3B\"; intuitively, this is one line of quoted-printable encoded text. The dkim-quoted-printable syntax is defined in Section 2.11.",
      "ja": "各フィールドタイプのためのエンコーディングは以下のとおりです。 MIMEパートワン[RFC2045]のセクション6.7に記載されているようにQP-セクションとして説明タグは、セミコロン文字「= 3B」の追加の変換と、符号化されます。直感的に、これはquoted-printableのエンコードされたテキストの1行です。 DKIM-quoted-printableの構文は、セクション2.11で定義されています。"
    },
    {
      "indent": 3,
      "text": "Tags on the DKIM-Signature header field along with their type and requirement status are shown below. Unrecognized tags MUST be ignored.",
      "ja": "それらのタイプおよび要求ステータスと共にDKIM署名ヘッダーフィールドにタグを以下に示します。認識できないタグは無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "v= Version (plain-text; REQUIRED). This tag defines the version of this specification that applies to the signature record. It MUST have the value \"1\" for implementations compliant with this version of DKIM.",
      "ja": "V =バージョン（平文;必須）。このタグは、署名レコードに適用される本明細書のバージョンを定義します。これは、DKIMのこのバージョンに準拠した実装のための値が「1」を持たなければなりません。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-v-tag = %x76 [FWS] \"=\" [FWS] 1*DIGIT",
      "ja": "ミュート解除-B-タグ=％のX76 [FOS] \"=\" [FOS] 1 * DIGIT"
    },
    {
      "indent": 9,
      "text": "INFORMATIVE NOTE: DKIM-Signature version numbers may increase arithmetically as new versions of this specification are released.",
      "ja": "有益な注意：この仕様の新しいバージョンがリリースされているようDKIM署名バージョン番号は算術増加する可能性があります。"
    },
    {
      "indent": 3,
      "text": "a= The algorithm used to generate the signature (plain-text;\n   REQUIRED).  Verifiers MUST support \"rsa-sha1\" and \"rsa-sha256\";\n   Signers SHOULD sign using \"rsa-sha256\".  See Section 3.3 for a\n   description of the algorithms.",
      "raw": true
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-a-tag = %x61 [FWS] \"=\" [FWS] sig-a-tag-alg sig-a-tag-alg = sig-a-tag-k \"-\" sig-a-tag-h sig-a-tag-k = \"rsa\" / x-sig-a-tag-k sig-a-tag-h = \"sha1\" / \"sha256\" / x-sig-a-tag-h x-sig-a-tag-k = ALPHA *(ALPHA / DIGIT) ; for later extension x-sig-a-tag-h = ALPHA *(ALPHA / DIGIT) ; for later extension",
      "ja": "SIG-タグ=％のX61 [FWS] \"=\" [FWS] SIG-TAG-ALG SIG-TAG-ALG = SIG-TAG-K \" - \" SIG-TAG-HのSIG -aタグ-K = \"RSA\" / X-SIG-TAG-K SIG-TAG-H = \"SHA1\" / \"SHA256\" / X-SIG-TAG-H X-SIG-A -tag-K = ALPHA×（ALPHA / DIGIT）。後で拡張X-SIG-TAG-H = ALPHA *（ALPHA / DIGIT）のために、後の拡張のために"
    },
    {
      "indent": 3,
      "text": "b= The signature data (base64; REQUIRED). Whitespace is ignored in this value and MUST be ignored when reassembling the original signature. In particular, the signing process can safely insert FWS in this value in arbitrary places to conform to line-length limits. See \"Signer Actions\" (Section 5) for how the signature is computed.",
      "ja": "B =署名データ（BASE64; REQUIRED）。空白は、この値は無視され、元の署名を再組み立ての際に無視しなければなりません。具体的には、署名プロセスは安全ラインの長さの制限に適合するように任意の場所で、この値にFWSを挿入することができます。署名の計算方法は、「署名者アクション」（第5章）を参照してください。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-b-tag = %x62 [FWS] \"=\" [FWS] sig-b-tag-data sig-b-tag-data = base64string",
      "ja": "ミュート解除-B-タグ=％のX62 [FOS] \"=\" [FOS]ミュート解除-W-タグタタミュート-W-タグタタ= ​​vase64string"
    },
    {
      "indent": 3,
      "text": "bh= The hash of the canonicalized body part of the message as limited by the \"l=\" tag (base64; REQUIRED). Whitespace is ignored in this value and MUST be ignored when reassembling the original signature. In particular, the signing process can safely insert FWS in this value in arbitrary places to conform to line-length limits. See Section 3.7 for how the body hash is computed.",
      "ja": "BH =「L =」タグ（BASE64; REQUIRED）によって制限されるように、メッセージの正規化身体部分のハッシュ。空白は、この値は無視され、元の署名を再組み立ての際に無視しなければなりません。具体的には、署名プロセスは安全ラインの長さの制限に適合するように任意の場所で、この値にFWSを挿入することができます。体のハッシュを計算する方法については、3.7節を参照してください。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-bh-tag = %x62 %x68 [FWS] \"=\" [FWS] sig-bh-tag-data sig-bh-tag-data = base64string",
      "ja": "ミュート解除段階タグ=％X62％X68 [FOS] \"=\" [FOS]ミュートを解除ステップ - タグタタミュート解除ステップ-TATA-タグ= vase64string"
    },
    {
      "indent": 3,
      "text": "c= Message canonicalization (plain-text; OPTIONAL, default is \"simple/simple\"). This tag informs the Verifier of the type of canonicalization used to prepare the message for signing. It consists of two names separated by a \"slash\" (%d47) character, corresponding to the header and body canonicalization algorithms, respectively. These algorithms are described in Section 3.4. If only one algorithm is named, that algorithm is used for the header and \"simple\" is used for the body. For example, \"c=relaxed\" is treated the same as \"c=relaxed/simple\".",
      "ja": "C =メッセージの正規化（平文;オプションで、デフォルトは「シンプル/シンプル」です）。このタグは、署名のためのメッセージを準備するために使用される正規化のタイプの検証を通知します。これは、それぞれ、ヘッダとボディ正規化アルゴリズムに対応する「スラッシュ」率（％D47）文字で区切られた2人の名前、から構成されています。これらのアルゴリズムは、セクション3.4で説明されています。唯一のアルゴリズムが指定されている場合、そのアルゴリズムは、ヘッダと、「シンプル」は、身体のために使用されているために使用されています。例えば、「C =弛緩した」は、「C =リラックス/シンプル」と同じように扱われます。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-c-tag = %x63 [FWS] \"=\" [FWS] sig-c-tag-alg [\"/\" sig-c-tag-alg] sig-c-tag-alg = \"simple\" / \"relaxed\" / x-sig-c-tag-alg x-sig-c-tag-alg = hyphenated-word ; for later extension",
      "ja": "SIG-Cタグ=％のX63 [FWS] \"=\" [FWS] SIG-C-タグ-ALG [ \"/\" SIG-C-タグ-ALG] SIG-C-タグ-ALG = \"単純な\" /「リラックス「/ X-SIG-C-タグ-ALG X-SIG-C-タグ-ALG =ハイフンワード;後の拡張のために"
    },
    {
      "indent": 3,
      "text": "d= The SDID claiming responsibility for an introduction of a message into the mail stream (plain-text; REQUIRED). Hence, the SDID value is used to form the query for the public key. The SDID MUST correspond to a valid DNS name under which the DKIM key record is published. The conventions and semantics used by a Signer to create and use a specific SDID are outside the scope of this specification, as is any use of those conventions and semantics. When presented with a signature that does not meet these requirements, Verifiers MUST consider the signature invalid.",
      "ja": "D =メールストリーム（平文; REQUIRED）にメッセージを導入するための責任を主張SDID。したがって、SDID値は、公開鍵のためのクエリを形成するために使用されます。 SDIDはDKIMキーレコードが公開され、その下に有効なDNS名に対応しなければなりません。これらの規則およびセマンティクスの使用であるとして特定SDIDを作成し、使用するために署名者によって使用される規則およびセマンティクスは、本明細書の範囲外です。これらの要件を満たしていない署名を提示すると、検証者は、署名が無効考慮する必要があります。"
    },
    {
      "indent": 6,
      "text": "Internationalized domain names MUST be encoded as A-labels, as described in Section 2.3 of [RFC5890].",
      "ja": "[RFC5890]のセクション2.3で説明したように国際化ドメイン名は、ラベルとして符号化されなければなりません。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-d-tag = %x64 [FWS] \"=\" [FWS] domain-name domain-name = sub-domain 1*(\".\" sub-domain) ; from [RFC5321] Domain, ; excluding address-literal",
      "ja": "SIG-D-タグ=％x64の[FWS] \"=\" [FWS]ドメイン名のドメイン名=サブドメイン1 *（サブドメイン \"\"）; [RFC5321]ドメインから、。除くアドレスリテラル"
    },
    {
      "indent": 3,
      "text": "h= Signed header fields (plain-text, but see description; REQUIRED). A colon-separated list of header field names that identify the header fields presented to the signing algorithm. The field MUST contain the complete list of header fields in the order presented to the signing algorithm. The field MAY contain names of header fields that do not exist when signed; nonexistent header fields do not contribute to the signature computation (that is, they are treated as the null input, including the header field name, the separating colon, the header field value, and any CRLF terminator). The field MAY contain multiple instances of a header field name, meaning multiple occurrences of the corresponding header field are included in the header hash. The field MUST NOT include the DKIM-Signature header field that is being created or verified but may include others. Folding whitespace (FWS) MAY be included on either side of the colon separator. Header field names MUST be compared against actual header field names in a case-insensitive manner. This list MUST NOT be empty. See Section 5.4 for a discussion of choosing header fields to sign and Section 5.4.2 for requirements when signing multiple instances of a single field.",
      "ja": "H =署名されたヘッダフィールド（平文が、説明を参照して、必須）。署名アルゴリズムに提示されるヘッダフィールドを識別するヘッダフィールド名のコロンで区切られたリスト。フィールドには、署名アルゴリズムに提示ために、ヘッダフィールドの完全なリストを含まなければなりません。フィールドが署名したときには存在しないヘッダフィールドの名前を含む可能性があります。存在しないヘッダフィールド（すなわち、それらは、ヘッダフィールド名、分離結腸、ヘッダフィールド値、および任意CRLFターミネータを含む、ヌル入力として処理される）署名の計算に寄与しません。フィールドは、ヘッダのハッシュに含まれる対応するヘッダフィールドの複数のオカレンスを意味する、ヘッダーフィールド名の複数のインスタンスを含むかもしれません。フィールドが作成または検証他のものを含むことができるされているDKIM署名ヘッダーフィールドを含んではいけません。折りたたみ空白（FWS）はコロン区切りのいずれかの側上に含まれてもよいです。ヘッダフィールド名は、大文字と小文字を区別しない方法で、実際のヘッダフィールド名と比較されなければなりません。このリストは空にすることはできません。単一のフィールドの複数のインスタンスを署名するときに署名し、要件については、セクション5.4.2するヘッダフィールドを選択するの議論については、セクション5.4を参照してください。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-h-tag = %x68 [FWS] \"=\" [FWS] hdr-name *( [FWS] \":\" [FWS] hdr-name )",
      "ja": "ミュート解除-N-タグ=％のX68 [FOS] \"=\" [FOS】HSP-NAME×（[FOS] \"\" [FOS】HSP-NAME）"
    },
    {
      "indent": 9,
      "text": "INFORMATIVE EXPLANATION: By \"signing\" header fields that do not actually exist, a Signer can allow a Verifier to detect insertion of those header fields after signing. However, since a Signer cannot possibly know what header fields might be defined in the future, this mechanism cannot be used to prevent the addition of any possible unknown header fields.",
      "ja": "有益な説明：実際には存在しないヘッダフィールドを「署名」することで、署名者は、検証が署名した後、それらのヘッダフィールドの挿入を検出できるようにすることができます。署名者は、おそらく将来的に定義される可能性がありますどのようなヘッダフィールドを知ることができないので、このメカニズムは、すべての可能な未知のヘッダフィールドの追加を防ぐために使用することはできません。"
    },
    {
      "indent": 9,
      "text": "INFORMATIVE NOTE: \"Signing\" fields that are not present at the time of signing not only prevents fields and values from being added but also prevents adding fields with no values.",
      "ja": "有益な注意：だけでなく、署名時に存在しない「署名」フィールドが追加されるフィールドと値を防ぐだけでなく、値のないフィールドを追加防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "i= The Agent or User Identifier (AUID) on behalf of which the SDID is taking responsibility (dkim-quoted-printable; OPTIONAL, default is an empty local-part followed by an \"@\" followed by the domain from the \"d=\" tag).",
      "ja": "私はSDIDが責任を取っているに代わってエージェントまたはユーザー識別子（AUIDを）=（DKIM-引用符で囲まれた印刷可能な、オプション、デフォルト=「Dからのドメインに続いて「@」に続いて、空のローカル部分です\" 鬼ごっこ）。"
    },
    {
      "indent": 6,
      "text": "The syntax is a standard email address where the local-part MAY be omitted. The domain part of the address MUST be the same as, or a subdomain of, the value of the \"d=\" tag.",
      "ja": "構文は、ローカル部分を省略してもよい標準の電子メールアドレスです。アドレスのドメイン部分は、同じ、または「D =」タグの値、のサブドメインでなければなりません。"
    },
    {
      "indent": 6,
      "text": "Internationalized domain names MUST be encoded as A-labels, as described in Section 2.3 of [RFC5890].",
      "ja": "[RFC5890]のセクション2.3で説明したように国際化ドメイン名は、ラベルとして符号化されなければなりません。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-i-tag = %x69 [FWS] \"=\" [FWS] [ Local-part ] \"@\" domain-name",
      "ja": "ミュート解除-N-タグ=％X69 [FOS] \"=\" [FOS] [Lokal-アネックス] \"@\" ドメイン名"
    },
    {
      "indent": 6,
      "text": "The AUID is specified as having the same syntax as an email address but it need not have the same semantics. Notably, the domain name need not be registered in the DNS -- so it might not resolve in a query -- and the local-part MAY be drawn from a namespace unrelated to any mailbox. The details of the structure and semantics for the namespace are determined by the Signer. Any knowledge or use of those details by Verifiers or Assessors is outside the scope of this specification. The Signer MAY choose to use the same namespace for its AUIDs as its users' email addresses or MAY choose other means of representing its users. However, the Signer SHOULD use the same AUID for each message intended to be evaluated as being within the same sphere of responsibility, if it wishes to offer receivers the option of using the AUID as a stable identifier that is finer grained than the SDID.",
      "ja": "AUIDは、電子メールアドレスと同じ構文を持つものとして指定されているが、それは同じ意味を持つ必要はありません。それはクエリで解決されない場合がありますので -   - 特に、ドメイン名がDNSに登録する必要はなく、ローカル部分は、任意のメールボックスに関係のない名前空間から引き出されます。名前空間の構造とセマンティクスの詳細は、署名者によって決定されます。検証者または評価者によってこれらの詳細の知識又は使用は、本明細書の範囲外です。署名者は、そのユーザーのメールアドレスとしてそのAUIDsに同じ名前空間を使用することを選択したり、そのユーザーを表すの他の手段を選ぶかもしれません。しかし、意図したメッセージごとに同じAUIDを使用すべきである署名者は、それが受信機にSDIDより細かい粒度で安定した識別子としてAUIDを使用するオプションを提供することを希望する場合、責任の同じ球内にあるものとして評価されます。"
    },
    {
      "indent": 9,
      "text": "INFORMATIVE NOTE: The local-part of the \"i=\" tag is optional because in some cases a Signer may not be able to establish a verified individual identity. In such cases, the Signer might wish to assert that although it is willing to go as far as signing for the domain, it is unable or unwilling to commit to an individual user name within the domain. It can do so by including the domain part but not the local-part of the identity.",
      "ja": "有益な注意：いくつかのケースでは署名者が検証個々のアイデンティティを確立することができないかもしれないので、「I =」タグのローカル部分はオプションです。このような場合には、署名者は、それは限り、ドメインのために署名するように行くことをいとわないですが、ドメイン内の個々のユーザー名にコミットすることができないか、不本意であることを主張したいことがあります。これは、ドメインの一部ではなく、アイデンティティのローカル部分を含むことによって行うことができます。"
    },
    {
      "indent": 9,
      "text": "INFORMATIVE DISCUSSION: This specification does not require the value of the \"i=\" tag to match the identity in any message header fields. This is considered to be a Verifier policy issue. Constraints between the value of the \"i=\" tag and other identities in other header fields seek to apply basic authentication into the semantics of trust associated with a role such as content author. Trust is a broad and complex topic, and trust mechanisms are subject to highly creative attacks. The real-world efficacy of any but the most basic bindings between the \"i=\" value and other identities is not well established, nor is its vulnerability to subversion by an attacker. Hence, reliance on the use of these options should be strictly limited. In particular, it is not at all clear to what extent a typical end-user recipient can rely on any assurances that might be made by successful use of the \"i=\" options.",
      "ja": "有益な考察：この仕様は、任意のメッセージヘッダフィールドのアイデンティティと一致するように、「I =」タグの値を必要としません。これは、検証の政策課題であると考えられています。他のヘッダフィールドに「I =」タグの値と他のアイデンティティとの間の制約は、コンテンツ作成者としての役割に関連付けられた信頼の意味論に基本認証を適用しようとします。トラストは、広範かつ複雑なトピックであり、信頼のメカニズムは非常に創造的な攻撃の対象となっています。 「私=」値と他のアイデンティティの間の最も基本的なバインディングが、任意の実世界の有効性は十分に確立されていない、また転覆への脆弱性により、攻撃者によってです。したがって、これらのオプションの使用への依存度は厳しく制限する必要があります。特に、それは、「I =」オプションの使用の成功によってなされる可能性の保証に頼ることができる、全く明確でどの程度一般的なエンドユーザーの受信者にはありません。"
    },
    {
      "indent": 3,
      "text": "l= Body length count (plain-text unsigned decimal integer; OPTIONAL, default is entire body). This tag informs the Verifier of the number of octets in the body of the email after canonicalization included in the cryptographic hash, starting from 0 immediately following the CRLF preceding the body. This value MUST NOT be larger than the actual number of octets in the canonicalized message body. See further discussion in Section 8.2.",
      "ja": "L =ボディー長カウント（平文符号なし10進整数、オプション、デフォルトは全身です）。このタグは、直ちに本体の前CRLF下記0から出発して、暗号化ハッシュに含まれる正規化後の電子メールの本文にオクテットの数の検証を通知します。この値は、正規化されたメッセージ本文のオクテットの実際の数よりも大きくすることはできません。 8.2節でさらに議論を参照してください。"
    },
    {
      "indent": 9,
      "text": "INFORMATIVE NOTE: The value of the \"l=\" tag is constrained to\n76 decimal digits.  This constraint is not intended to predict\nthe size of future messages or to require implementations to\nuse an integer representation large enough to represent the\nmaximum possible value but is intended to remind the\nimplementer to check the length of this and all other tags\nduring verification and to test for integer overflow when\ndecoding the value.  Implementers may need to limit the actual\nvalue expressed to a value smaller than 10^76, e.g., to allow a\nmessage to fit within the available storage space.",
      "raw": true
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-l-tag = %x6c [FWS] \"=\" [FWS] 1*76DIGIT",
      "ja": "ミュート解除-1-タグ=％のx6c [FOS] \"=\" [FOS] 1 * 76DIGIT"
    },
    {
      "indent": 3,
      "text": "q= A colon-separated list of query methods used to retrieve the public key (plain-text; OPTIONAL, default is \"dns/txt\"). Each query method is of the form \"type[/options]\", where the syntax and semantics of the options depend on the type and specified options. If there are multiple query mechanisms listed, the choice of query mechanism MUST NOT change the interpretation of the signature. Implementations MUST use the recognized query mechanisms in the order presented. Unrecognized query mechanisms MUST be ignored.",
      "ja": "Q =公開鍵を取得するために使用されるクエリメソッドのコロンで区切られたリスト（平文;オプションで、デフォルトは「DNS / TXT」です）。各クエリ方法は、オプションの構文と意味論タイプと指定されたオプションに依存する形「タイプ[/オプション]」です。記載されている複数のクエリメカニズムがある場合は、クエリメカニズムの選択は、署名の解釈を変更しないでください。実装は、提示された順序で認識されたクエリメカニズムを使用しなければなりません。認識できないのクエリメカニズムを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Currently, the only valid value is \"dns/txt\", which defines the DNS TXT resource record (RR) lookup algorithm described elsewhere in this document. The only option defined for the \"dns\" query type is \"txt\", which MUST be included. Verifiers and Signers MUST support \"dns/txt\".",
      "ja": "現在、唯一の有効な値は、本書の他の箇所に記載DNS TXTリソースレコード（RR）検索アルゴリズムを定義する「DNS / TXT」、です。 「DNS」クエリタイプに対して定義された唯一のオプションは含まれなければならない「TXT」、です。検証者と署名者は、「DNS / TXT」をサポートしなければなりません。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-q-tag = %x71 [FWS] \"=\" [FWS] sig-q-tag-method *([FWS] \":\" [FWS] sig-q-tag-method)",
      "ja": "SIG-Qタグ=％のX71 [FWS] \"=\" [FWS] SIG-Qタグ法*（[FWS] \"：\" [FWS] SIG-Qタグ法）"
    },
    {
      "indent": 6,
      "text": "sig-q-tag-method = \"dns/txt\" / x-sig-q-tag-type [\"/\" x-sig-q-tag-args] x-sig-q-tag-type = hyphenated-word ; for future extension x-sig-q-tag-args = qp-hdr-value",
      "ja": "SIG-Qタグ法= \"DNS / TXT\" / X-SIG-Qタグ型[ \"/\" X-SIG-Q-タグ引数] X-SIG-Qタグ型=ハイフンワード;将来の拡張のX-SIG-Q-タグ引数= QP-HDR-値に対する"
    },
    {
      "indent": 3,
      "text": "s= The selector subdividing the namespace for the \"d=\" (domain) tag (plain-text; REQUIRED).",
      "ja": "Sは「D =」（ドメイン）タグ（; REQUIRED平文）の名前空間を分割セレクタを=。"
    },
    {
      "indent": 6,
      "text": "Internationalized selector names MUST be encoded as A-labels, as described in Section 2.3 of [RFC5890].",
      "ja": "[RFC5890]のセクション2.3で説明したように国際セレクタ名は、ラベルとして符号化されなければなりません。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-s-tag = %x73 [FWS] \"=\" [FWS] selector",
      "ja": "ミュート解除-P-タグ=％X73 [FOS] \"=\" [FOS] selektor"
    },
    {
      "indent": 3,
      "text": "t= Signature Timestamp (plain-text unsigned decimal integer; RECOMMENDED, default is an unknown creation time). The time that this signature was created. The format is the number of seconds since 00:00:00 on January 1, 1970 in the UTC time zone. The value is expressed as an unsigned integer in decimal ASCII. This value is not constrained to fit into a 31- or 32-bit integer. Implementations SHOULD be prepared to handle values up to at least 10^12 (until approximately AD 200,000; this fits into 40 bits). To avoid denial-of-service attacks, implementations MAY consider any value longer than 12 digits to be infinite. Leap seconds are not counted. Implementations MAY ignore signatures that have a timestamp in the future.",
      "ja": "T =署名タイムスタンプ（平文符号なし10進整数、推奨、デフォルトは未知の作成時間です）。この署名が作成された時刻。フォーマットはUTCタイムゾーンで1970年1月1日00:00:00からの秒数です。値は、小数ASCIIで符号なし整数として表現されます。この値は、31-または32ビット整数に適合するように制約されません。実装は、少なくとも10 ^ 12までの値を処理するために準備されるべき（まで約AD20万、これは40ビットに収まります）。サービス拒否攻撃を回避するために、実装が無限大に長い12桁より任意の値を考慮することができます。うるう秒はカウントされません。実装は将来のタイム・スタンプを持つ署名を無視するかもしれません。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-t-tag = %x74 [FWS] \"=\" [FWS] 1*12DIGIT",
      "ja": "ミュート解除tert-ブチルタグ=％のX74 [FOS] \"=\" [FOS] 1 * 12DIGIT"
    },
    {
      "indent": 3,
      "text": "x= Signature Expiration (plain-text unsigned decimal integer; RECOMMENDED, default is no expiration). The format is the same as in the \"t=\" tag, represented as an absolute date, not as a time delta from the signing timestamp. The value is expressed as an unsigned integer in decimal ASCII, with the same constraints on the value in the \"t=\" tag. Signatures MAY be considered invalid if the verification time at the Verifier is past the expiration date. The verification time should be the time that the message was first received at the administrative domain of the Verifier if that time is reliably available; otherwise, the current time should be used. The value of the \"x=\" tag MUST be greater than the value of the \"t=\" tag if both are present.",
      "ja": "X =署名の有効期限（平文符号なし10進整数、推奨、デフォルトでは有効期限はありません）。形式はない署名タイムスタンプから時間デルタとして、絶対的な日付として表され、「T =」タグと同様です。値が「T =」タグの値に同じ制約を、小数ASCIIで符号なし整数として表現されます。検証の検証時間が有効期限を過ぎている場合、署名は無効とみなすことができます。検証時間は、その時間が確実に利用可能である場合、メッセージが最初の検証の管理ドメインで受信された時間であるべきです。そうでない場合は、現在の時刻を使用する必要があります。両方が存在する場合、「X =」タグの値が「T =」タグの値より大きくなければなりません。"
    },
    {
      "indent": 9,
      "text": "INFORMATIVE NOTE: The \"x=\" tag is not intended as an anti-\nreplay defense.",
      "raw": true
    },
    {
      "indent": 9,
      "text": "INFORMATIVE NOTE: Due to clock drift, the receiver's notion of when to consider the signature expired may not exactly match what the sender is expecting. Receivers MAY add a 'fudge factor' to allow for such possible drift.",
      "ja": "有益な注意：によりクロックドリフトに、署名を検討する際の受信機の概念は、正確に送信者が期待しているものと一致しない場合があります期限切れ。レシーバは、そのような可能なドリフトを可能にする「ファッジファクター」を追加するかもしれません。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-x-tag = %x78 [FWS] \"=\" [FWS] 1*12DIGIT",
      "ja": "ミュート解除-X-タグ=％のx78 [FOS] \"=\" [FOS] 1 * 12DIGIT"
    },
    {
      "indent": 3,
      "text": "z= Copied header fields (dkim-quoted-printable, but see description; OPTIONAL, default is null). A vertical-bar-separated list of selected header fields present when the message was signed, including both the field name and value. It is not required to include all header fields present at the time of signing. This field need not contain the same header fields listed in the \"h=\" tag. The header field text itself must encode the vertical bar (\"|\", %x7C) character (i.e., vertical bars in the \"z=\" text are meta-characters, and any actual vertical bar characters in a copied header field must be encoded). Note that all whitespace must be encoded, including whitespace between the colon and the header field value. After encoding, FWS MAY be added at arbitrary locations in order to avoid excessively long lines; such whitespace is NOT part of the value of the header field and MUST be removed before decoding.",
      "ja": "Z =コピーヘッダフィールド（DKIM-quoted-printableの、しかし説明を参照して、オプション、デフォルトはヌルです）。メッセージをフィールド名と値の両方を含めて、署名された現在選択されたヘッダフィールドの垂直バーで区切られたリスト。署名時に存在する全てのヘッダフィールドを含める必要はありません。このフィールドは、「H =」タグに記載されている同一のヘッダフィールドを含む必要はありません。ヘッダフィールドのテキスト自体は、垂直バー（「|」、％のx7C）をコードしなければならない文字（すなわち、「Z =」テキストの縦バーはメタ文字であり、コピーされたヘッダフィールド内の任意の実際の縦棒の文字が符号化されなければなりません）。すべての空白は、結腸およびヘッダフィールド値との間の空白を含む、符号化されなければならないことに留意されたいです。符号化の後、FWSが過度に長い行を避けるために、任意の場所で添加することができます。そのような空白は、ヘッダフィールドの値の一部ではなく、復号化の前に除去しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The header fields referenced by the \"h=\" tag refer to the fields in the [RFC5322] header of the message, not to any copied fields in the \"z=\" tag. Copied header field values are for diagnostic use.",
      "ja": "「H =」タグによって参照されるヘッダフィールドは、メッセージの[RFC5322]ヘッダー内のフィールドにはなく、「Z =」タグ内の任意のコピーフィールドを参照します。コピーされたヘッダフィールド値は、診断使用のためのものです。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "sig-z-tag = %x7A [FWS] \"=\" [FWS] sig-z-tag-copy *( \"|\" [FWS] sig-z-tag-copy ) sig-z-tag-copy = hdr-name [FWS] \":\" qp-hdr-value",
      "ja": "SIG-Zタグ=％のX7A [FWS] \"=\" [FWS] SIG-Zタグコピー*（ \"|\" [FWS] SIG-Zタグコピー）SIG-Z-タグコピー= hdr- [FWS] NAME \"：\" QP-HDR-値"
    },
    {
      "indent": 9,
      "text": "INFORMATIVE EXAMPLE of a signature header field spread across multiple continuation lines:",
      "ja": "複数の継続行にまたがる署名ヘッダーフィールドの有益な例："
    },
    {
      "indent": 3,
      "text": "DKIM-Signature: v=1; a=rsa-sha256; d=example.net; s=brisbane;\n   c=simple; q=dns/txt; i=@eng.example.net;\n   t=1117574938; x=1118006938;\n   h=from:to:subject:date;\n   z=From:foo@eng.example.net|To:joe@example.com|\n    Subject:demo=20run|Date:July=205,=202005=203:44:08=20PM=20-0700;\n   bh=MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI=;\n   b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZVoG4ZHRNiYzR",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.6. Key Management and Representation",
      "section_title": true,
      "ja": "3.6. キー管理と表現"
    },
    {
      "indent": 3,
      "text": "Signature applications require some level of assurance that the verification public key is associated with the claimed Signer. Many applications achieve this by using public-key certificates issued by a trusted third party. However, DKIM can achieve a sufficient level of security, with significantly enhanced scalability, by simply having the Verifier query the purported Signer's DNS entry (or some security-equivalent) in order to retrieve the public key.",
      "ja": "署名アプリケーションは、検証用公開鍵が記載署名者に関連付けられている保証のいくつかのレベルを必要とします。多くのアプリケーションでは、信頼できる第三者機関によって発行された公開鍵証明書を使用することによって、これを達成します。しかし、DKIMは、単に検証は、公開鍵を取得するために主張された署名者のDNSエントリ（またはいくつかのセキュリティ相当）を照会することによって、大幅に強化拡張性、セキュリティの十分なレベルを達成することができます。"
    },
    {
      "indent": 3,
      "text": "DKIM keys can potentially be stored in multiple types of key servers and in multiple formats. The storage and format of keys are irrelevant to the remainder of the DKIM algorithm.",
      "ja": "DKIMキーは、潜在的に重要なサーバの複数の種類の中で、複数のフォーマットで保存することができます。鍵の保管及び形式は、DKIMアルゴリズムの残りの部分とは無関係です。"
    },
    {
      "indent": 3,
      "text": "Parameters to the key lookup algorithm are the type of the lookup (the \"q=\" tag), the domain of the Signer (the \"d=\" tag of the DKIM-Signature header field), and the selector (the \"s=\" tag).",
      "ja": "キー検索アルゴリズムのパラメータは、署名者のドメイン（「D =」DKIM署名ヘッダフィールドのタグ）、及びセレクタ（（「Q =」タグ）ルックアップの一種である「S = \" 鬼ごっこ）。"
    },
    {
      "indent": 3,
      "text": "public_key = dkim_find_key(q_val, d_val, s_val)",
      "ja": "Pabalikakiya = dakimphaindakiya（kibhala、dabhala、sabhala）"
    },
    {
      "indent": 3,
      "text": "This document defines a single binding, using DNS TXT RRs to distribute the keys. Other bindings may be defined in the future.",
      "ja": "この文書では、キーを配布するDNS TXT RRを使用して、単一の結合を定義します。他のバインディングは、将来的に定義されてもよいです。"
    },
    {
      "indent": 0,
      "text": "3.6.1. Textual Representation",
      "section_title": true,
      "ja": "3.6.1. テキスト表現"
    },
    {
      "indent": 3,
      "text": "It is expected that many key servers will choose to present the keys in an otherwise unstructured text format (for example, an XML form would not be considered to be unstructured text for this purpose). The following definition MUST be used for any DKIM key represented in an otherwise unstructured textual form.",
      "ja": "多くの主要なサーバは（例えば、XML形式は、この目的のために非構造化テキストと見なされないであろう）そうでない場合は、非構造化テキスト形式でキーを提示することを選択することが期待されます。以下の定義は、そうでない場合は、非構造化テキスト形式で表される任意のDKIMキーを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The overall syntax is a tag-list as described in Section 3.2. The current valid tags are described below. Other tags MAY be present and MUST be ignored by any implementation that does not understand them.",
      "ja": "3.2節で説明したように、全体的な構文は、タグリストです。現在有効なタグは、以下に記載されています。その他のタグが存在してもよく、それらを理解していない任意の実装によって無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "v= Version of the DKIM key record (plain-text; RECOMMENDED, default is \"DKIM1\"). If specified, this tag MUST be set to \"DKIM1\" (without the quotes). This tag MUST be the first tag in the record. Records beginning with a \"v=\" tag with any other value MUST be discarded. Note that Verifiers must do a string comparison on this value; for example, \"DKIM1\" is not the same as \"DKIM1.0\".",
      "ja": "V DKIMキーレコードの=バージョン（平文;推奨、デフォルトでは「DKIM1」です）。指定された場合、このタグは、（引用符なし）「DKIM1」に設定しなければなりません。このタグは、レコード内の最初のタグでなければなりません。他の値と「V =」タグで始まるレコードは捨てなければなりません。検証者は、この値に文字列比較を行う必要があることに注意してください。例えば、「DKIM1は」「DKIM1.0」と同じではありません。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "key-v-tag = %x76 [FWS] \"=\" [FWS] %x44.4B.49.4D.31",
      "ja": "テキストB-タグ=％のX76 [FOS] \"=\" [FOS]％のx44.4B.49.4D.x1"
    },
    {
      "indent": 3,
      "text": "h= Acceptable hash algorithms (plain-text; OPTIONAL, defaults to allowing all algorithms). A colon-separated list of hash algorithms that might be used. Unrecognized algorithms MUST be ignored. Refer to Section 3.3 for a discussion of the hash algorithms implemented by Signers and Verifiers. The set of algorithms listed in this tag in each record is an operational choice made by the Signer.",
      "ja": "H =許容可能なハッシュアルゴリズム（平文;すべてのアルゴリズムを可能にするオプション、デフォルト）。使用されるかもしれないハッシュアルゴリズムのコロンで区切ったリスト。未認識のアルゴリズムは無視しなければなりません。署名者と検証者によって実装ハッシュアルゴリズムの議論については、セクション3.3を参照。各レコードには、このタグに記載されているアルゴリズムのセットは、署名者によって行われた操作の選択です。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "key-h-tag = %x68 [FWS] \"=\" [FWS] key-h-tag-alg *( [FWS] \":\" [FWS] key-h-tag-alg ) key-h-tag-alg = \"sha1\" / \"sha256\" / x-key-h-tag-alg x-key-h-tag-alg = hyphenated-word ; for future extension",
      "ja": "キー-H-タグ=％のX68 [FWS] \"=\" [FWS]キー-H-タグ-ALG *（[FWS] \"：\" [FWS]キー-H-タグ-ALG）キー-H-タグALG = \"SHA1\" / \"SHA256\" / Xキー-H-タグ-ALG X鍵-H-タグ-ALG =ハイフンワード;将来の拡張のために"
    },
    {
      "indent": 3,
      "text": "k= Key type (plain-text; OPTIONAL, default is \"rsa\"). Signers and Verifiers MUST support the \"rsa\" key type. The \"rsa\" key type indicates that an ASN.1 DER-encoded [ITU-X660-1997] RSAPublicKey (see [RFC3447], Sections 3.1 and A.1.1) is being used in the \"p=\" tag. (Note: the \"p=\" tag further encodes the value using the base64 algorithm.) Unrecognized key types MUST be ignored.",
      "ja": "K =キーの種類（プレーンテキスト;オプションで、デフォルトは「RSA」です）。署名者と検証者は、「RSA」キータイプをサポートしなければなりません。 \"RSA\" キータイプはASN.1のDER符号化された[ITU-X660-1997]のRSAPublicKeyが \"P =\" タグで使用されている（セクション3.1及びA.1.1は[RFC3447]を参照）ことを示しています。 （注：さらに、「P =」タグは、Base64アルゴリズムを使用して値を符号化する。）未認識のキータイプは無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "key-k-tag = %x76 [FWS] \"=\" [FWS] key-k-tag-type key-k-tag-type = \"rsa\" / x-key-k-tag-type x-key-k-tag-type = hyphenated-word ; for future extension",
      "ja": "キーKタグ=％のX76 [FWS]「=」[FWS]キーKタグ型キーKタグ型=「RSA」/ X鍵Kタグ型X鍵K -tag型=ハイフンワード;将来の拡張のために"
    },
    {
      "indent": 3,
      "text": "n= Notes that might be of interest to a human (qp-section; OPTIONAL, default is empty). No interpretation is made by any program. This tag should be used sparingly in any key server mechanism that has space limitations (notably DNS). This is intended for use by administrators, not end users.",
      "ja": "ヒトへの関心があるかもしれないN =ノート（QP-部と、OPTIONAL、デフォルトは空です）。何解釈は、任意のプログラムによって行われません。このタグは、スペースの制約があり、任意のキーサーバー・メカニズム（特にDNS）で慎重に使用する必要があります。これは、エンドユーザーではない、管理者による使用を意図しています。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "key-n-tag = %x6e [FWS] \"=\" [FWS] qp-section",
      "ja": "テキスト-V-タグ=％のx6e [FOS] \"=\" [FOS] CI-sektion"
    },
    {
      "indent": 3,
      "text": "p= Public-key data (base64; REQUIRED). An empty value means that this public key has been revoked. The syntax and semantics of this tag value before being encoded in base64 are defined by the \"k=\" tag.",
      "ja": "P =公開鍵データ（base64で、必須）。空の値は、この公開鍵が失効していることを意味します。 BASE64でエンコードされる前の構文と、このタグ値の意味は、「K =」タグによって定義されます。"
    },
    {
      "indent": 9,
      "text": "INFORMATIVE RATIONALE: If a private key has been compromised or\notherwise disabled (e.g., an outsourcing contract has been\nterminated), a Signer might want to explicitly state that it\nknows about the selector, but all messages using that selector should fail verification.  Verifiers SHOULD return an error\ncode for any DKIM-Signature header field with a selector\nreferencing a revoked key.  (See Section 6.1.2 for details.)",
      "raw": true
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "key-p-tag = %x70 [FWS] \"=\" [ [FWS] base64string]",
      "ja": "テキスト-P-タグ=％のX70 [FOS] \"=\" [[FOS] vase64string]"
    },
    {
      "indent": 9,
      "text": "INFORMATIVE NOTE: A base64string is permitted to include whitespace (FWS) at arbitrary places; however, any CRLFs must be followed by at least one WSP character. Implementers and administrators are cautioned to ensure that selector TXT RRs conform to this specification.",
      "ja": "有益な注意：base64stringを任意の場所に空白（FWS）を含むように許可されています。しかし、どんなのCRLFは、少なくとも一つのWSP文字が続かなければなりません。実装および管理者は、TXT資源レコードは、この仕様に準拠するセレクタを確実にするために警告されます。"
    },
    {
      "indent": 3,
      "text": "s= Service Type (plain-text; OPTIONAL; default is \"*\"). A colon-separated list of service types to which this record applies. Verifiers for a given service type MUST ignore this record if the appropriate type is not listed. Unrecognized service types MUST be ignored. Currently defined service types are as follows:",
      "ja": "S =サービスタイプ（プレーンテキスト、オプションで、デフォルトは「*」です）。このレコードが適用されるサービスタイプのコロン区切りのリスト。適切なタイプがリストされていない場合は指定されたサービスタイプの検証者は、このレコードを無視しなければなりません。認識されていないサービスタイプを無視しなければなりません。次のように現在定義されたサービスの種類は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "* matches all service types",
      "ja": "*すべてのサービスタイプと一致します"
    },
    {
      "indent": 6,
      "text": "email electronic mail (not necessarily limited to SMTP)",
      "ja": "電子メールを電子メール（SMTP、必ずしもこれらに限定されません）"
    },
    {
      "indent": 6,
      "text": "This tag is intended to constrain the use of keys for other purposes, should use of DKIM be defined by other services in the future.",
      "ja": "このタグは、将来的には他のサービスで定義することがDKIMを使用する必要があり、他の目的のためのキーの使用を制限することを意図しています。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "key-s-tag = %x73 [FWS] \"=\" [FWS] key-s-tag-type *( [FWS] \":\" [FWS] key-s-tag-type ) key-s-tag-type = \"email\" / \"*\" / x-key-s-tag-type x-key-s-tag-type = hyphenated-word ; for future extension",
      "ja": "キーSタグ=％X73 [FWS] \"=\" [FWS]キーS-タグ型*（[FWS] \"：\" [FWS]キーS-タグ型）キーS-タグ型= \"メール\" / \"*\" / X-キー-S-タグ型のXキー-S-タグ型=ハイフネーションされた単語。将来の拡張のために"
    },
    {
      "indent": 3,
      "text": "t= Flags, represented as a colon-separated list of names (plain-text; OPTIONAL, default is no flags set). Unrecognized flags MUST be ignored. The defined flags are as follows:",
      "ja": "（;オプションで、デフォルトなしフラグが設定されていないプレーンテキスト）は、T =フラグは、名前のコロンで区切られたリストとして表されます。認識できないフラグは無視しなければなりません。次のように定義されたフラグは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "y This domain is testing DKIM. Verifiers MUST NOT treat messages from Signers in testing mode differently from unsigned email, even should the signature fail to verify. Verifiers MAY wish to track testing mode results to assist the Signer.",
      "ja": "yがこのドメインはDKIMをテストしています。検証者でも署名が検証するために失敗した場合、符号なしの電子メールとは異なるテストモードでの署名者からのメッセージを処理してはなりません。検証者は、署名者を支援するために、テストモードの結果を追跡することもできます。"
    },
    {
      "indent": 6,
      "text": "s Any DKIM-Signature header fields using the \"i=\" tag MUST have the same domain value on the right-hand side of the \"@\" in the \"i=\" tag and the value of the \"d=\" tag. That is, the \"i=\" domain MUST NOT be a subdomain of \"d=\". Use of this flag is RECOMMENDED unless subdomaining is required.",
      "ja": "S「I =」タグ内の「@」と「D =」タグの値の右側に同一のドメイン値を持たなければならない「I =」タグを使用して、任意のDKIM-Signatureヘッダーフィールド。それは「私=」ドメイン「= D」のサブドメインにすることはできません、です。 subdomainingが必要とされない限り、このフラグの使用を推奨します。"
    },
    {
      "indent": 6,
      "text": "ABNF:",
      "ja": "ABNF："
    },
    {
      "indent": 6,
      "text": "key-t-tag = %x74 [FWS] \"=\" [FWS] key-t-tag-flag *( [FWS] \":\" [FWS] key-t-tag-flag ) key-t-tag-flag = \"y\" / \"s\" / x-key-t-tag-flag x-key-t-tag-flag = hyphenated-word ; for future extension",
      "ja": "キーTタグ=％のX74 [FWS] \"=\" [FWS]キー-Tタグフラグ*（[FWS] \"：\" [FWS]キー-Tタグフラグ）キーT-タグフラグ= \"Y\" / \"S\" / X-キーT-タグフラグX鍵Tタグフラグ=ハイフンワード;将来の拡張のために"
    },
    {
      "indent": 0,
      "text": "3.6.2. DNS Binding",
      "section_title": true,
      "ja": "3.6.2.  DNSバインディング"
    },
    {
      "indent": 3,
      "text": "A binding using DNS TXT RRs as a key service is hereby defined. All implementations MUST support this binding.",
      "ja": "キーサービスがここに定義されているDNS TXT RRを使用して結合。すべての実装は、この結合をサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.6.2.1. Namespace",
      "section_title": true,
      "ja": "3.6.2.1。名前空間"
    },
    {
      "indent": 3,
      "text": "All DKIM keys are stored in a subdomain named \"_domainkey\". Given a DKIM-Signature field with a \"d=\" tag of \"example.com\" and an \"s=\" tag of \"foo.bar\", the DNS query will be for \"foo.bar._domainkey.example.com\".",
      "ja": "すべてのDKIMキーは「_domainkey」という名前のサブドメインに格納されています。 「example.com」の「D =」タグや「foo.bar」の「S =」タグとDKIM署名フィールド所与、DNSクエリが「foo.bar._domainkey.example.com」ためであろう。"
    },
    {
      "indent": 0,
      "text": "3.6.2.2. Resource Record Types for Key Storage",
      "section_title": true,
      "ja": "3.6.2.2。キーストレージのリソースレコードのタイプ"
    },
    {
      "indent": 3,
      "text": "The DNS Resource Record type used is specified by an option to the query-type (\"q=\") tag. The only option defined in this base specification is \"txt\", indicating the use of a TXT RR. A later extension of this standard may define another RR type.",
      "ja": "使用されるDNSリソースレコードタイプは、問合せタイプ（「Q =」）タグにオプションで指定されています。この基本仕様で定義された唯一の選択肢は、TXT RRの使用を示す、「TXT」です。この規格の拡張後は、他のRRタイプを定義することができます。"
    },
    {
      "indent": 3,
      "text": "Strings in a TXT RR MUST be concatenated together before use with no intervening whitespace. TXT RRs MUST be unique for a particular selector name; that is, if there are multiple records in an RRset, the results are undefined.",
      "ja": "TXTのRRの文字列は、間に空白はありませんで使用する前に、一緒に連結されなければなりません。 TXT RRは、特定のセレクタ名に一意でなければなりません。それは、複数のレコードがRRセットに存在する場合、結果は定義されていません、です。"
    },
    {
      "indent": 3,
      "text": "TXT RRs are encoded as described in Section 3.6.1.",
      "ja": "セクション3.6.1に記載したようにTXTのRRは符号化されます。"
    },
    {
      "indent": 0,
      "text": "3.7. Computing the Message Hashes",
      "section_title": true,
      "ja": "3.7. メッセージのハッシュを計算します"
    },
    {
      "indent": 3,
      "text": "Both signing and verifying message signatures start with a step of computing two cryptographic hashes over the message. Signers will choose the parameters of the signature as described in \"Signer Actions\" (Section 5); Verifiers will use the parameters specified in the DKIM-Signature header field being verified. In the following discussion, the names of the tags in the DKIM-Signature header field that either exists (when verifying) or will be created (when signing) are used. Note that canonicalization (Section 3.4) is only used to prepare the email for signing or verifying; it does not affect the transmitted email in any way.",
      "ja": "両方の署名と確認メッセージ署名は、メッセージ上の2つの暗号化ハッシュを計算するステップで始まります。 「署名者アクション」（第5章）に記載されているように署名者は、署名のパラメータを選択します。検証者は、検証さDKIM署名ヘッダフィールドで指定されたパラメータを使用します。以下の説明では、（検証時に）存在するか（ログイン時）に作成されるいずれかのことをDKIM-Signatureヘッダーフィールド内のタグの名前が使用されています。のみ署名または検証するための電子メールを調製するために使用される正規化（セクション3.4）に注意してください。それはどのような方法で送信された電子メールには影響を与えません。"
    },
    {
      "indent": 3,
      "text": "The Signer/Verifier MUST compute two hashes: one over the body of the message and one over the selected header fields of the message.",
      "ja": "メッセージの選択されたヘッダフィールドを介したメッセージのボディ上1および1：署名者/検証は、2つのハッシュを計算しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Signers MUST compute them in the order shown. Verifiers MAY compute them in any order convenient to the Verifier, provided that the result is semantically identical to the semantics that would be the case had they been computed in this order.",
      "ja": "署名者は示した順序でそれらを計算しなければなりません。検証者は、検証者に便利な任意の順序でそれらを計算することができる、結果は彼らがこの順でケースを計算していたことになる意味論と意味的に同じであることを条件とします。"
    },
    {
      "indent": 3,
      "text": "In hash step 1, the Signer/Verifier MUST hash the message body, canonicalized using the body canonicalization algorithm specified in the \"c=\" tag and then truncated to the length specified in the \"l=\" tag. That hash value is then converted to base64 form and inserted into (Signers) or compared to (Verifiers) the \"bh=\" tag of the DKIM-Signature header field.",
      "ja": "ハッシュステップ1において、署名者/検証は、メッセージ本体をハッシュしなければならない、「C =」タグおよび「L =」タグで指定された長さに切り捨てられ、その後に指定された本体の正規化アルゴリズムを使用して正規化。そのハッシュ値は、BASE64形式に変換し、（署名者）に挿入されるか（検証者）DKIM-Signatureヘッダーフィールドの「BH =」タグと比較されます。"
    },
    {
      "indent": 3,
      "text": "In hash step 2, the Signer/Verifier MUST pass the following to the hash algorithm in the indicated order.",
      "ja": "ハッシュステップ2において、署名者/検証は、指示された順にハッシュアルゴリズムを以下に合格しなければなりません。"
    },
    {
      "indent": 3,
      "text": "1. The header fields specified by the \"h=\" tag, in the order specified in that tag, and canonicalized using the header canonicalization algorithm specified in the \"c=\" tag. Each header field MUST be terminated with a single CRLF.",
      "ja": "1.ヘッダフィールドは、そのタグで指定された順序で、「H =」タグで指定し、「C =」タグで指定されたヘッダの正規化アルゴリズムを使用して正規化。各ヘッダフィールドは、単一のCRLFで終了しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. The DKIM-Signature header field that exists (verifying) or will be inserted (signing) in the message, with the value of the \"b=\" tag (including all surrounding whitespace) deleted (i.e., treated as the empty string), canonicalized using the header canonicalization algorithm specified in the \"c=\" tag, and without a trailing CRLF.",
      "ja": "2.削除（全周囲の空白を含む）「B =」タグの値を用いて、メッセージに（検証）または（署名）に挿入される存在DKIM署名ヘッダフィールド（すなわち、空の文字列として扱われます） 、「C =」タグで指定されたヘッダの正規化アルゴリズムを用いて正規化し、末尾のCRLFはありません。"
    },
    {
      "indent": 3,
      "text": "All tags and their values in the DKIM-Signature header field are included in the cryptographic hash with the sole exception of the value portion of the \"b=\" (signature) tag, which MUST be treated as the null string. All tags MUST be included even if they might not be understood by the Verifier. The header field MUST be presented to the hash algorithm after the body of the message rather than with the rest of the header fields and MUST be canonicalized as specified in the \"c=\" (canonicalization) tag. The DKIM-Signature header field MUST NOT be included in its own \"h=\" tag, although other DKIM-Signature header fields MAY be signed (see Section 4).",
      "ja": "すべてのタグとDKIM署名ヘッダーフィールドにおけるそれらの値はNULL文字列として扱われなければならない「B =」（署名）タグの値部分の唯一の例外と暗号化ハッシュに含まれています。すべてのタグは、彼らが検証によって理解されないことがあります場合にも含まれなければなりません。ヘッダフィールドは、メッセージのボディの後ではなく、ヘッダフィールドの残りの部分とハッシュアルゴリズムに提示されなければならないと「C =」（正規化）タグで指定されるように正規化されなければなりません。他のDKIM-Signatureヘッダーフィールドが署名されてもよいがDKIM署名ヘッダーフィールド（セクション4を参照）は、独自の「H =」タグに含まれてはいけません。"
    },
    {
      "indent": 3,
      "text": "When calculating the hash on messages that will be transmitted using base64 or quoted-printable encoding, Signers MUST compute the hash after the encoding. Likewise, the Verifier MUST incorporate the values into the hash before decoding the base64 or quoted-printable text. However, the hash MUST be computed before transport-level encodings such as SMTP \"dot-stuffing\" (the modification of lines beginning with a \".\" to avoid confusion with the SMTP end-of-message marker, as specified in [RFC5321]).",
      "ja": "BASE64またはquoted-printableのエンコーディングを使用して送信されるメッセージのハッシュを計算する場合、署名者は、エンコード後のハッシュを計算しなければなりません。同様に、検証は、base64またはquoted-printableのテキストをデコードする前に、ハッシュに値を組み込まなければなりません。しかし、ハッシュは、（ラインの修正は[RFC5321]で指定されるように、SMTPエンドのメッセージマーカーとの混同を避けるために、「」で始まるようなSMTP「ドットスタッフィング」などのトランスポートレベルの符号化前に計算されなければなりません）。"
    },
    {
      "indent": 3,
      "text": "With the exception of the canonicalization procedure described in Section 3.4, the DKIM signing process treats the body of messages as simply a string of octets. DKIM messages MAY be either in plain-text or in MIME format; no special treatment is afforded to MIME content. Message attachments in MIME format MUST be included in the content that is signed.",
      "ja": "3.4節で説明した正規化の手順を除いて、DKIMの署名プロセスは、オクテットの単純文字列としてメッセージの本文を扱います。 DKIMメッセージは、プレーンテキストまたはMIME形式のいずれであってもよいです。特別な治療は、MIMEコンテンツに与えていません。 MIME形式のメッセージの添付ファイルが署名されたコンテンツに含まれなければなりません。"
    },
    {
      "indent": 3,
      "text": "More formally, pseudo-code for the signature algorithm is:",
      "ja": "より正式に、署名アルゴリズムの擬似コードです。"
    },
    {
      "indent": 3,
      "text": "body-hash = hash-alg (canon-body, l-param) data-hash = hash-alg (h-headers, D-SIG, body-hash) signature = sig-alg (d-domain, selector, data-hash)",
      "ja": "本体ハッシュ=ハッシュ-ALG（キヤノン体、L-PARAM）データハッシュ=ハッシュ-ALG（H-ヘッダ、D-SIG、身体ハッシュ）署名= SIG-ALG（Dドメイン、セレクタ、DATA-ハッシュ）"
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "どこ："
    },
    {
      "indent": 3,
      "text": "body-hash: is the output from hashing the body, using hash-alg.",
      "ja": "本体ハッシュ：ハッシュ-ALGを用いて、身体のハッシュから出力されます。"
    },
    {
      "indent": 3,
      "text": "hash-alg: is the hashing algorithm specified in the \"a\" parameter.",
      "ja": "ハッシュ-ALGは：「」パラメータで指定されたハッシュアルゴリズムです。"
    },
    {
      "indent": 3,
      "text": "canon-body: is a canonicalized representation of the body, produced using the body algorithm specified in the \"c\" parameter, as defined in Section 3.4 and excluding the DKIM-Signature field.",
      "ja": "キヤノン体は：本体の正規化表現であり、3.4節で定義され、DKIM署名フィールドを除くように、「C」パラメータで指定されたボディ・アルゴリズムを使用して製造。"
    },
    {
      "indent": 3,
      "text": "l-param: is the length-of-body value of the \"l\" parameter.",
      "ja": "L-paramが「L」パラメータの長さのボディの値です。"
    },
    {
      "indent": 3,
      "text": "data-hash: is the output from using the hash-alg algorithm, to hash the header including the DKIM-Signature header, and the body hash.",
      "ja": "データハッシュ：DKIM署名ヘッダを含むヘッダとボディハッシュをハッシュするハッシュ-ALGアルゴリズムを使用してから出力されます。"
    },
    {
      "indent": 3,
      "text": "h-headers: is the list of headers to be signed, as specified in the \"h\" parameter.",
      "ja": "H-ヘッダは「H」のパラメータで指定されているヘッダのリストは、署名されるべきです。"
    },
    {
      "indent": 3,
      "text": "D-SIG: is the canonicalized DKIM-Signature field itself without the signature value portion of the parameter, that is, an empty parameter value.",
      "ja": "D-SIGは：つまりパラメータの署名値部のない正規化DKIM署名フィールド自体、空のパラメータ値です。"
    },
    {
      "indent": 3,
      "text": "signature: is the signature value produced by the signing algorithm.",
      "ja": "署名：署名アルゴリズムによって生成された署名の値です。"
    },
    {
      "indent": 3,
      "text": "sig-alg: is the signature algorithm specified by the \"a\" parameter.",
      "ja": "SIG-ALGは：「」パラメータで指定された署名アルゴリズムです。"
    },
    {
      "indent": 3,
      "text": "d-domain: is the domain name specified in the \"d\" parameter.",
      "ja": "D-ドメイン：「D」パラメータで指定したドメイン名です。"
    },
    {
      "indent": 3,
      "text": "selector: is the selector value specified in the \"s\" parameter.",
      "ja": "セレクタ：「S」パラメータで指定されたセレクタ値です。"
    },
    {
      "indent": 6,
      "text": "NOTE: Many digital signature APIs provide both hashing and application of the RSA private key using a single \"sign()\" primitive. When using such an API, the last two steps in the algorithm would probably be combined into a single call that would perform both the \"a-hash-alg\" and the \"sig-alg\".",
      "ja": "注：多くのデジタル署名APIは、シングル「記号（）」プリミティブを使用してRSA秘密鍵のハッシュとアプリケーションの両方を提供しています。そのようなAPIを使用する場合は、アルゴリズムの最後の2つのステップは、おそらく「ハッシュALG」と「SIG-ALG」の両方を実行することになり、単一のコールに結合されるだろう。"
    },
    {
      "indent": 0,
      "text": "3.8. Input Requirements",
      "section_title": true,
      "ja": "3.8. 入力要件"
    },
    {
      "indent": 3,
      "text": "A message that is not compliant with [RFC5322], [RFC2045], and [RFC2047] can be subject to attempts by intermediaries to correct or interpret such content. See Section 8 of [RFC4409] for examples of changes that are commonly made. Such \"corrections\" may invalidate DKIM signatures or have other undesirable effects, including some that involve changes to the way a message is presented to an end user.",
      "ja": "[RFC5322]、[RFC2045]及び[RFC2047]に準拠していないメッセージは、コンテンツを修正または解釈する仲介による試みを受けることができます。一般的に行われた変更の例については、[RFC4409]のセクション8を参照してください。そのような「修正」は、DKIM署名を無効化またはメッセージがエンドユーザに提示される方法の変更を伴うものも含む他の望ましくない影響を有し得ます。"
    },
    {
      "indent": 3,
      "text": "Accordingly, DKIM's design is predicated on valid input. Therefore, Signers and Verifiers SHOULD take reasonable steps to ensure that the messages they are processing are valid according to [RFC5322], [RFC2045], and any other relevant message format standards.",
      "ja": "したがって、DKIMのデザインは、有効な入力を前提としています。したがって、署名者と検証者は、それらが処理されるメッセージは、[RFC5322]、[RFC2045]、およびその他の関連メッセージフォーマット規格に従って有効であることを確実にするために合理的な措置を取るべきです。"
    },
    {
      "indent": 3,
      "text": "See Section 8.15 for additional discussion.",
      "ja": "追加の議論については、セクション8.15を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.9. Output Requirements",
      "section_title": true,
      "ja": "3.9. 出力要件"
    },
    {
      "indent": 3,
      "text": "The evaluation of each signature ends in one of three states, which this document refers to as follows:",
      "ja": "各署名の評価は、この文書は次のようにいう三つの状態、のいずれかで終わります。"
    },
    {
      "indent": 3,
      "text": "SUCCESS: a successful verification",
      "ja": "SUCCESS：成功した検証"
    },
    {
      "indent": 3,
      "text": "PERMFAIL: a permanent, non-recoverable error such as a signature verification failure",
      "ja": "PERMFAIL：署名検証の失敗のような永久的な、回復不能エラー"
    },
    {
      "indent": 3,
      "text": "TEMPFAIL: a temporary, recoverable error such as a DNS query timeout",
      "ja": "TEMPFAIL：DNSクエリータイムアウトなどの一時的な、回復可能なエラー"
    },
    {
      "indent": 3,
      "text": "For each signature that verifies successfully or produces a TEMPFAIL result, output of the DKIM algorithm MUST include the set of:",
      "ja": "正常に検証又はTEMPFAIL結果を生成し、各署名のために、DKIMアルゴリズムの出力は、セットを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o The domain name, taken from the \"d=\" signature tag; and",
      "ja": "「D =」署名タグから採取したドメイン名、O。そして"
    },
    {
      "indent": 3,
      "text": "o The result of the verification attempt for that signature.",
      "ja": "その署名の検証を試みた結果、O。"
    },
    {
      "indent": 3,
      "text": "The output MAY include other signature properties or result meta-data, including PERMFAILed or otherwise ignored signatures, for use by modules that consume those results.",
      "ja": "出力は、他のシグネチャ特性を含むか、それらの結果を消費するモジュールで使用するためPERMFAILedまたはそうでなければ無視署名を含むメタデータを、もたらすことができます。"
    },
    {
      "indent": 3,
      "text": "See Section 6.1 for discussion of signature validation result codes.",
      "ja": "署名検証の結果コードの説明については、6.1節を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.10. Signing by Parent Domains",
      "section_title": true,
      "ja": "3.10. 親ドメインによる署名"
    },
    {
      "indent": 3,
      "text": "In some circumstances, it is desirable for a domain to apply a signature on behalf of any of its subdomains without the need to maintain separate selectors (key records) in each subdomain. By default, private keys corresponding to key records can be used to sign messages for any subdomain of the domain in which they reside; for example, a key record for the domain example.com can be used to verify messages where the AUID (\"i=\" tag of the signature) is sub.example.com, or even sub1.sub2.example.com. In order to limit the capability of such keys when this is not intended, the \"s\" flag MAY be set in the \"t=\" tag of the key record, to constrain the validity of the domain of the AUID. If the referenced key record contains the \"s\" flag as part of the \"t=\" tag, the domain of the AUID (\"i=\" flag) MUST be the same as that of the SDID (d=) domain. If this flag is absent, the domain of the AUID MUST be the same as, or a subdomain of, the SDID.",
      "ja": "ドメインは、各サブドメイン内の別のセレクタ（鍵レコード）を維持する必要なく、そのサブドメインのいずれかに代わって署名を適用するためのいくつかの状況において、それが望ましいです。デフォルトでは、キーレコードに対応する秘密鍵は、それらが存在するドメインのすべてのサブドメインのメッセージに署名するために使用することができます。例えば、ドメインexample.comのキーレコードは、メッセージを検証するために使用することができる場合AUID（署名の「I =」タグ）sub.example.com、あるいはsub1.sub2.example.comあります。これが意図されていない場合、このようなキーの機能を制限するために、「S」フラグがAUIDのドメインの有効性を制約するために、キーレコードの「T =」タグに設定されてもよいです。参照キーレコードは、「S」のフラグの一部として含まれている場合は「Tを=」タグ、AUIDのドメイン（「I =」フラグ）SDID（D =）ドメインと同じでなければなりません。このフラグが存在しない場合、AUIDのドメインは、同じ、またはSDIDのサブドメインでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.11. Relationship between SDID and AUID",
      "section_title": true,
      "ja": "3.11.  SDIDとAUIDの関係"
    },
    {
      "indent": 3,
      "text": "DKIM's primary task is to communicate from the Signer to a recipient-side Identity Assessor a single Signing Domain Identifier (SDID) that refers to a responsible identity. DKIM MAY optionally provide a single responsible Agent or User Identifier (AUID).",
      "ja": "DKIMの主な仕事は、責任の同一性をいう受信者側の身元評価単一署名ドメイン識別子（SDID）への署名者から通信することです。 DKIMは、必要に応じて、単一責任のエージェントまたはユーザー識別子（AUID）を提供することができます。"
    },
    {
      "indent": 3,
      "text": "Hence, DKIM's mandatory output to a receive-side Identity Assessor is a single domain name. Within the scope of its use as DKIM output, the name has only basic domain name semantics; any possible owner-specific semantics are outside the scope of DKIM. That is, within its role as a DKIM identifier, additional semantics cannot be assumed by an Identity Assessor.",
      "ja": "このため、受信側の身元評価にDKIMの必須の出力は、単一のドメイン名です。 DKIM出力としての使用の範囲内で、名前だけで、基本的なドメイン名の意味を持っています。任意の可能な所有者固有のセマンティクスは、DKIMの範囲外です。これは、DKIMの識別子としての役割の中に、追加的な意味は身元評価が想定することはできませんされています。"
    },
    {
      "indent": 3,
      "text": "Upon successfully verifying the signature, a receive-side DKIM Verifier MUST communicate the Signing Domain Identifier (d=) to a consuming Identity Assessor module and MAY communicate the Agent or User Identifier (i=) if present.",
      "ja": "正常署名を検証する際に、受信側のDKIM検証は、かかる身元評価モジュールに署名ドメイン識別子（D =）を通信しなければならないし、存在する場合（I =）エージェント又はユーザ識別子を通信することができます。"
    },
    {
      "indent": 3,
      "text": "To the extent that a receiver attempts to intuit any structured semantics for either of the identifiers, this is a heuristic function that is outside the scope of DKIM's specification and semantics.",
      "ja": "受信機は、識別子のいずれかのための任意の構造化された意味を直感しようとする程度まで、これはDKIMの仕様及びセマンティクスの範囲外であるヒューリスティック関数です。"
    },
    {
      "indent": 3,
      "text": "Hence, it is relegated to a higher-level service, such as a delivery-handling filter that integrates a variety of inputs and performs heuristic analysis of them.",
      "ja": "したがって、そのような入力の多様を統合し、それらのヒューリスティック解析を行う配信ハンドリングフィルタとして、より高いレベルのサービスに追いやられます。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE DISCUSSION: This document does not require the value of the SDID or AUID to match an identifier in any other message header field. This requirement is, instead, an Assessor policy issue. The purpose of such a linkage would be to authenticate the value in that other header field. This, in turn, is the basis for applying a trust assessment based on the identifier value. Trust is a broad and complex topic, and trust mechanisms are subject to highly creative attacks. The real-world efficacy of any but the most basic bindings between the SDID or AUID and other identities is not well established, nor is its vulnerability to subversion by an attacker. Hence, reliance on the use of such bindings should be strictly limited. In particular, it is not at all clear to what extent a typical end-user recipient can rely on any assurances that might be made by successful use of the SDID or AUID.",
      "ja": "有益な考察：この文書は、他のメッセージヘッダフィールドに識別子と一致するようにSDIDまたはAUIDの値を必要としません。この要件は、代わりに、アセッサ政策課題です。そのような結合の目的は、他のヘッダフィールドの値を認証することであろう。これは、順番に、識別子の値に基づいて信頼性評価を適用するための基礎です。トラストは、広範かつ複雑なトピックであり、信頼のメカニズムは非常に創造的な攻撃の対象となっています。いずれかの実世界での有効性が、SDIDまたはAUIDと他のアイデンティティの間の最も基本的なバインディングは十分に確立されていない、また転覆への脆弱性により、攻撃者によってです。したがって、そのようなバインディングの使用への依存度は厳しく制限する必要があります。特に、それがすべてで、一般的なエンドユーザーの受信者がSDIDまたはAUIDの使用の成功によってなされる可能性の保証に頼ることができますどの程度に明確ではありません。"
    },
    {
      "indent": 0,
      "text": "4. Semantics of Multiple Signatures",
      "section_title": true,
      "ja": "複数の署名の4セマンティクス"
    },
    {
      "indent": 0,
      "text": "4.1. Example Scenarios",
      "section_title": true,
      "ja": "4.1. シナリオ例"
    },
    {
      "indent": 3,
      "text": "There are many reasons why a message might have multiple signatures. For example, suppose SHA-256 is in the future found to be insufficiently strong, and DKIM usage transitions to SHA-1024. A Signer might immediately sign using the newer algorithm but also continue to sign using the older algorithm for interoperability with Verifiers that had not yet upgraded. The Signer would do this by adding two DKIM-Signature header fields, one using each algorithm. Older Verifiers that did not recognize SHA-1024 as an acceptable algorithm would skip that signature and use the older algorithm; newer Verifiers could use either signature at their option and, all other things being equal, might not even attempt to verify the other signature.",
      "ja": "メッセージは、複数の署名を持っているかもしれない多くの理由があります。例えば、SHA-256は、将来的にあるSHA-1024に十分に強力であることが判明し、DKIMの利用遷移とします。署名者は、すぐに新しいアルゴリズムを使用して署名するだけでなく、まだアップグレードしていなかった検証者との相互運用性のために古いアルゴリズムを使用して署名を続ける場合があります。署名者は、それぞれのアルゴリズムを使用して、ある2つのDKIM-Signatureヘッダーフィールドを追加することによってこれを行うであろう。許容可能なアルゴリズムとしてSHA-1024を認識しなかった古い検証者は、その署名をスキップして、古いアルゴリズムを使用します。新しい検証者がそのオプションで署名のいずれかを使用することができますし、他のすべてのものが等しい場合、さらには他の署名を確認しようとしない場合があります。"
    },
    {
      "indent": 3,
      "text": "Similarly, a Signer might sign a message including all header fields and no \"l=\" tag (to satisfy strict Verifiers) and a second time with a limited set of header fields and an \"l=\" tag (in anticipation of possible message modifications en route to other Verifiers). Verifiers could then choose which signature they prefer.",
      "ja": "同様に、署名者は、すべてのヘッダフィールドとヘッダフィールドの限られたセットと可能なメッセージの変更を見越して「L =」タグ（とNO「L =」タグ（厳密な検証者を満足させるために）および第2の時間を含むメッセージに署名するかもしれません）他の検証者への途中で。検証者は、彼らが好むどの署名選択することができます。"
    },
    {
      "indent": 3,
      "text": "Of course, a message might also have multiple signatures because it passed through multiple Signers. A common case is expected to be that of a signed message that passes through a mailing list that also signs all messages. Assuming both of those signatures verify, a recipient might choose to accept the message if either of those signatures were known to come from trusted sources.",
      "ja": "それは、複数の署名者を通過したのでもちろん、メッセージも複数の署名を持っているかもしれません。一般的な場合は、すべてのメッセージに署名メーリングリストを通過署名されたメッセージのものであることが期待されます。これらの署名のいずれかが信頼できるソースから来ることが知られていた場合、それらの署名の両方を確認すると仮定すると、受信者はメッセージを受け入れることを選択する場合があります。"
    },
    {
      "indent": 3,
      "text": "In particular, recipients might choose to whitelist mailing lists to which they have subscribed and that have acceptable anti-abuse policies so as to accept messages sent to that list even from unknown authors. They might also subscribe to less trusted mailing lists (e.g., those without anti-abuse protection) and be willing to accept all messages from specific authors but insist on doing additional abuse scanning for other messages.",
      "ja": "具体的には、受信者は、彼らが加入しているとさえ未知の著者からそのリストに送信されたメッセージを受け入れるようにそれが許容できる抗乱用ポリシーを持っているにホワイトリストのメーリングリストに選択することがあります。彼らはまた、信頼性の低いメーリングリスト（例えば、抗乱用保護のないもの）に加入し、特定の著者からのすべてのメッセージを受け入れることをいとわないが、他のメッセージのための追加的な虐待のスキャンを行うことを主張するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Another related example of multiple Signers might be forwarding services, such as those commonly associated with academic alumni sites. For example, a recipient might have an address at members.example.org, a site that has anti-abuse protection that is somewhat less effective than the recipient would prefer. Such a recipient might have specific authors whose messages would be trusted absolutely, but messages from unknown authors that had passed the forwarder's scrutiny would have only medium trust.",
      "ja": "複数の署名者の別の関連する例は、一般的に学術卒業生サイトに関連するものとして、転送サービス、かもしれません。例えば、受信者はmembers.example.orgのアドレス、受信者は希望よりもやや少ない効果がある抗乱用保護を持っているサイトがある場合があります。このような受信者は、そのメッセージを絶対に信頼されることになる特定の著者を持っているかもしれませんが、フォワーダの精査を通過した未知の作者からのメッセージは、培地のみの信頼を持っているでしょう。"
    },
    {
      "indent": 0,
      "text": "4.2. Interpretation",
      "section_title": true,
      "ja": "4.2. 解釈"
    },
    {
      "indent": 3,
      "text": "A Signer that is adding a signature to a message merely creates a new DKIM-Signature header, using the usual semantics of the \"h=\" option. A Signer MAY sign previously existing DKIM-Signature header fields using the method described in Section 5.4 to sign trace header fields.",
      "ja": "メッセージに署名を追加して署名者は単に「H =」オプションの通常のセマンティクスを使用して、新たなDKIM署名ヘッダを作成します。署名者は、トレースヘッダフィールドに署名するために、セクション5.4に記載した方法を用いて、既存のDKIM署名ヘッダーフィールドに署名することができます。"
    },
    {
      "indent": 3,
      "text": "Note that Signers should be cognizant that signing DKIM-Signature header fields may result in signature failures with intermediaries that do not recognize that DKIM-Signature header fields are trace header fields and unwittingly reorder them, thus breaking such signatures. For this reason, signing existing DKIM-Signature header fields is unadvised, albeit legal.",
      "ja": "署名者は、署名DKIM-SignatureヘッダーフィールドはDKIM-Signatureヘッダーフィールドは、トレースヘッダフィールドであることを認識し、無意識のうちにそれらを並べ替え、従ってそのような署名を壊さない仲介者と署名失敗をもたらし得ることを認識しなければならないことに留意されたいです。このため、既存のDKIM署名ヘッダーフィールドに署名することは、法的にもかかわらず、unadvisedあります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: If a header field with multiple instances is signed, those header fields are always signed from the bottom up. Thus, it is not possible to sign only specific DKIM-Signature header fields. For example, if the message being signed already contains three DKIM-Signature header fields A, B, and C, it is possible to sign all of them, B and C only, or C only, but not A only, B only, A and B only, or A and C only.",
      "ja": "有益な注意：複数のインスタンスを持つヘッダフィールドが署名されている場合、それらのヘッダフィールドは常にボトムアップから署名されています。したがって、特定のDKIM-Signatureヘッダーフィールドに署名することは不可能です。例えば、署名されたメッセージは、既に3 DKIM-SignatureヘッダーフィールドA、B、及びCを含む場合、それらのすべてに署名することができ、B及びCのみ、またはCのみ、のみだけでなく、B及びBのみ、又はA及びCのみ。"
    },
    {
      "indent": 3,
      "text": "A Signer MAY add more than one DKIM-Signature header field using different parameters. For example, during a transition period, a Signer might want to produce signatures using two different hash algorithms.",
      "ja": "署名者は、異なるパラメータを使用して複数のDKIM-Signatureヘッダーフィールドを加えるかもしれ。たとえば、移行期間中に、署名者は、二つの異なるハッシュアルゴリズムを使用して署名を生成することができます。"
    },
    {
      "indent": 3,
      "text": "Signers SHOULD NOT remove any DKIM-Signature header fields from messages they are signing, even if they know that the signatures cannot be verified.",
      "ja": "署名者は、彼らが署名が検証できないことを知っている場合でも、彼らは署名されたメッセージから任意のDKIM-Signatureヘッダフィールドを削除しないでください。"
    },
    {
      "indent": 3,
      "text": "When evaluating a message with multiple signatures, a Verifier SHOULD evaluate signatures independently and on their own merits. For example, a Verifier that by policy chooses not to accept signatures with deprecated cryptographic algorithms would consider such signatures invalid. Verifiers MAY process signatures in any order of their choice; for example, some Verifiers might choose to process signatures corresponding to the From field in the message header before other signatures. See Section 6.1 for more information about signature choices.",
      "ja": "複数の署名付きのメッセージを評価する場合、Verifierは独立して、自分の長所に署名を評価する必要があります。たとえば、ポリシーによって推奨されない暗号化アルゴリズムと署名が無効な署名を検討する承諾しないことを選択した検証。検証者は、自分の好きな任意の順序で署名を処理することができます。例えば、いくつかの検証者は、他の署名の前にメッセージヘッダのフィールドから対応する署名を処理することを選択するかもしれません。署名の選択の詳細については、6.1節を参照してください。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTATION NOTE: Verifier attempts to correlate valid signatures with invalid signatures in an attempt to guess why a signature failed are ill-advised. In particular, there is no general way that a Verifier can determine that an invalid signature was ever valid.",
      "ja": "有益な実装上の注意：検証が失敗した署名は無分別である理由を推測しようとする試みに無効な署名に有効な署名を相関しようとします。特に、検証が無効署名がかつて有効であったと判断することができることは一般的な方法はありません。"
    },
    {
      "indent": 3,
      "text": "Verifiers SHOULD continue to check signatures until a signature successfully verifies to the satisfaction of the Verifier. To limit potential denial-of-service attacks, Verifiers MAY limit the total number of signatures they will attempt to verify.",
      "ja": "検証者は、署名が正常に検証の満足度を確認するまで署名をチェックし続けなければなりません。潜在的なサービス拒否攻撃を制限するには、検証者は、彼らが検証しようとする署名の総数を制限するかもしれません。"
    },
    {
      "indent": 3,
      "text": "If a Verifier module reports signatures whose evaluations produced PERMFAIL results, Identity Assessors SHOULD ignore those signatures (see Section 6.1), acting as though they were not present in the message.",
      "ja": "そのPERMFAILの結果が得られた評価検証モジュールレポートの署名は、アイデンティティ査定はそれらの署名を無視する必要がある場合、彼らはメッセージ内に存在していなかったかのように動作する、（セクション6.1を参照してください）。"
    },
    {
      "indent": 0,
      "text": "5. Signer Actions",
      "section_title": true,
      "ja": "5.サイン株式"
    },
    {
      "indent": 3,
      "text": "The following steps are performed in order by Signers.",
      "ja": "次の手順は、署名者によって順序で実行されています。"
    },
    {
      "indent": 0,
      "text": "5.1. Determine Whether the Email Should Be Signed and by Whom",
      "section_title": true,
      "ja": "5.1. メールが署名するかどうかを判断し、誰によって"
    },
    {
      "indent": 3,
      "text": "A Signer can obviously only sign email for domains for which it has a private key and the necessary knowledge of the corresponding public key and selector information. However, there are a number of other reasons beyond the lack of a private key why a Signer could choose not to sign an email.",
      "ja": "署名者は明らかにのみ、それは秘密鍵と対応する公開鍵とセレクタ情報の必要な知識を持っているドメインの電子メールに署名することができます。しかし、署名者は、電子メールに署名しないことを選択した理由の秘密鍵の欠如以外の他の理由がいくつかあります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: A Signer can be implemented as part of any portion of the mail system as deemed appropriate, including an MUA, a SUBMISSION server, or an MTA. Wherever implemented, Signers should beware of signing (and thereby asserting responsibility for) messages that may be problematic. In particular, within a trusted enclave, the signing domain might be derived from the header according to local policy; SUBMISSION servers might only sign messages from users that are properly authenticated and authorized.",
      "ja": "有益な注意：MUA、投稿サーバ、またはMTAを含む、適切と思われるように署名者がメールシステムの任意の部分の一部として実装することができます。実施限り、署名者は、署名（およびそれによってに対する責任アサート）問題となり得るメッセージに注意すべきです。特に、信頼エンクレーブ内、署名ドメインは、ローカルポリシーに従ってヘッダから誘導されるかもしれません。 SUBMISSIONサーバーのみ、適切に認証され、許可されたユーザーからのメッセージに署名することがあります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTER ADVICE: SUBMISSION servers should not sign Received header fields if the outgoing gateway MTA obfuscates Received header fields, for example, to hide the details of internal topology.",
      "ja": "有益な実装のアドバイス：発信ゲートウェイMTAは、内部トポロジーの詳細を隠すために、例えば、受信されたヘッダフィールドを難読化あれば提出サーバが受信したヘッダフィールドに署名するべきではありません。"
    },
    {
      "indent": 3,
      "text": "If an email cannot be signed for some reason, it is a local policy decision as to what to do with that email.",
      "ja": "メールが何らかの理由で署名することができない場合は、そのメールをどうするかのようにローカルの政策決定です。"
    },
    {
      "indent": 0,
      "text": "5.2. Select a Private Key and Corresponding Selector Information",
      "section_title": true,
      "ja": "5.2. 秘密鍵と対応するセレクタ情報を選択"
    },
    {
      "indent": 3,
      "text": "This specification does not define the basis by which a Signer should choose which private key and selector information to use. Currently, all selectors are equal as far as this specification is concerned, so the decision should largely be a matter of administrative convenience. Distribution and management of private keys is also outside the scope of this document.",
      "ja": "この仕様は、署名者が使用する秘密鍵とセレクター情報を選択するべきで基礎を定義していません。現在、すべてのセレクタが限りこの仕様に関しては同じであるので、決定は、主に行政利便性の問題でなければなりません。秘密鍵の配布と管理は、この文書の範囲外でもあります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE OPERATIONS ADVICE: A Signer should not sign with a private key when the selector containing the corresponding public key is expected to be revoked or removed before the Verifier has an opportunity to validate the signature. The Signer should anticipate that Verifiers can choose to defer validation, perhaps until the message is actually read by the final recipient. In particular, when rotating to a new key pair, signing should immediately commence with the new private key, and the old public key should be retained for a reasonable validation interval before being removed from the key server.",
      "ja": "有益な操作情報：対応する公開鍵を含むセレクタは、検証者が署名を検証する機会を有する前に失効または削除されることが予想される場合、署名者が秘密鍵で署名してはなりません。署名者は、検証者は、メッセージが実際に最終受信者によって読み取られ、おそらくまで、検証を延期することを選択できることを期待すべきです。新しい鍵ペアに回転するとき、特に、署名はすぐに新しい秘密鍵で開始しなければならない、と古い公開鍵が鍵サーバから削除される前に、合理的な検証期間のために保持する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Normalize the Message to Prevent Transport Conversions",
      "section_title": true,
      "ja": "5.3. トランスポート変換を防止するためのメッセージを正規化"
    },
    {
      "indent": 3,
      "text": "Some messages, particularly those using 8-bit characters, are subject to modification during transit, notably conversion to 7-bit form. Such conversions will break DKIM signatures. In order to minimize the chances of such breakage, Signers SHOULD convert the message to a suitable MIME content-transfer encoding such as quoted-printable or base64 as described in [RFC2045] before signing. Such conversion is outside the scope of DKIM; the actual message SHOULD be converted to 7-bit MIME by an MUA or MSA prior to presentation to the DKIM algorithm.",
      "ja": "一部のメッセージは、8ビット文字を使用して、特には、7ビット形式に変換特に、輸送中に変形を受けやすいです。このような変換はDKIM署名を中断します。 [RFC2045]に記載されているような破損の可能性を最小限にするために、署名者は、署名する前に、このような引用され、印刷可能な又はBASE64のような適切なMIMEコンテンツ転送エンコードにメッセージを変換する必要があります。このような変換は、DKIMの範囲外です。実際のメッセージは、DKIMアルゴリズムに提示する前に、MUAまたはMSAによって7ビットMIMEに変換する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the message is submitted to the Signer with any local encoding that will be modified before transmission, that modification to canonical [RFC5322] form MUST be done before signing. In particular, bare CR or LF characters (used by some systems as a local line separator convention) MUST be converted to the SMTP-standard CRLF sequence before the message is signed. Any conversion of this sort SHOULD be applied to the message actually sent to the recipient(s), not just to the version presented to the signing algorithm.",
      "ja": "メッセージが送信前に変更されるであろう任意のローカルエンコーディングで署名者に送信された場合、正規[RFC5322]フォームへの変更は、署名する前に行われなければなりません。メッセージが署名される前に、特に、（ローカル行区切り規則のようないくつかのシステムで使用される）、裸のCRまたはLF文字はSMTP標準CRLFシーケンスに変換されなければなりません。この種の任意の変換は、実際に受信者に送信されたメッセージにだけでなく、署名アルゴリズムに提示バージョンに適用されるべきです。"
    },
    {
      "indent": 3,
      "text": "More generally, the Signer MUST sign the message as it is expected to be received by the Verifier rather than in some local or internal form.",
      "ja": "これを検証することによってではなく、いくつかのローカルまたは内部形式で受信されることが期待されるより一般的には、署名者がメッセージに署名しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Body Length Limits",
      "section_title": true,
      "ja": "5.3.1. ボディの長さ制限"
    },
    {
      "indent": 3,
      "text": "A body length count MAY be specified to limit the signature calculation to an initial prefix of the body text, measured in octets. If the body length count is not specified, the entire message body is signed.",
      "ja": "ボディー長カウントは、オクテット単位で測定された本文の最初の接頭辞に署名計算を制限するために指定することができます。ボディー長カウントが指定されていない場合は、メッセージ本文全体が署名されています。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE RATIONALE: This capability is provided because it is very common for mailing lists to add trailers to messages (e.g., instructions on how to get off the list). Until those messages are also signed, the body length count is a useful tool for the Verifier since it can, as a matter of policy, accept messages having valid signatures with extraneous data.",
      "ja": "有益な理論的根拠：メーリングリストのメッセージにトレーラーを追加することが非常に一般的であるため、この機能は提供された（例えば、リストを下車する方法に関する説明）。これらのメッセージも署名されるまでは、それは、政策の問題として、無関係なデータと有効な署名を持つメッセージを受け入れることができるので、体の長さのカウントは、検証のための便利なツールです。"
    },
    {
      "indent": 3,
      "text": "The length actually hashed should be inserted in the \"l=\" tag of the DKIM-Signature header field. (See Section 3.5.)",
      "ja": "実際ハッシュ長さはDKIM-Signatureヘッダーフィールドの「L =」タグに挿入されるべきです。 （3.5節を参照してください。）"
    },
    {
      "indent": 3,
      "text": "The body length count allows the Signer of a message to permit data to be appended to the end of the body of a signed message. The body length count MUST be calculated following the canonicalization algorithm; for example, any whitespace ignored by a canonicalization algorithm is not included as part of the body length count.",
      "ja": "本体長カウントは、データを許可するメッセージの署名者が署名されたメッセージの本文の末尾に追加されることを可能にします。ボディー長カウントは、正規化アルゴリズム、以下の計算しなければなりません。例えば、正規化アルゴリズムによって無視空白は本体長カウントの一部として含まれていません。"
    },
    {
      "indent": 3,
      "text": "A body length count of zero means that the body is completely unsigned.",
      "ja": "ゼロの身体長カウントは、体が完全に未署名であることを意味します。"
    },
    {
      "indent": 3,
      "text": "Signers wishing to ensure that no modification of any sort can occur should specify the \"simple\" canonicalization algorithm for both header and body and omit the body length count.",
      "ja": "どんな種類の修正が発生しないことを保証したい署名者は、ヘッダとボディの両方のための「簡単な」正規化アルゴリズムを指定し、ボディ長カウントを省略すべきです。"
    },
    {
      "indent": 3,
      "text": "See Section 8.2 for further discussion.",
      "ja": "さらなる議論については、セクション8.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.4. Determine the Header Fields to Sign",
      "section_title": true,
      "ja": "5.4. サインインヘッダフィールドを決定します"
    },
    {
      "indent": 3,
      "text": "The From header field MUST be signed (that is, included in the \"h=\" tag of the resulting DKIM-Signature header field). Signers SHOULD NOT sign an existing header field likely to be legitimately modified or removed in transit. In particular, [RFC5321] explicitly permits",
      "ja": "ヘッダフィールドから署名しなければならない（すなわち、得られたDKIM-Signatureヘッダーフィールドの「H =」タグに含まれています）。署名者は、合法的にトランジットで変更または削除される可能性が高い既存のヘッダフィールドに署名するべきではありません。具体的には、[RFC5321]は、明示的に許可します"
    },
    {
      "indent": 3,
      "text": "modification or removal of the Return-Path header field in transit. Signers MAY include any other header fields present at the time of signing at the discretion of the Signer.",
      "ja": "輸送中のリターンパスヘッダフィールドの変更または削除。署名者は、署名者の裁量で署名する時に存在する任意の他のヘッダのフィールドを含んでもよいです。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE OPERATIONS NOTE: The choice of which header fields to sign is non-obvious. One strategy is to sign all existing, non-repeatable header fields. An alternative strategy is to sign only header fields that are likely to be displayed to or otherwise be likely to affect the processing of the message at the receiver. A third strategy is to sign only \"well-known\" headers. Note that Verifiers may treat unsigned header fields with extreme skepticism, including refusing to display them to the end user or even ignoring the signature if it does not cover certain header fields. For this reason, signing fields present in the message such as Date, Subject, Reply-To, Sender, and all MIME header fields are highly advised.",
      "ja": "INFORMATIVE OPERATIONS注：ヘッダフィールドが署名するかの選択は、非自明です。 1つの戦略は、すべての既存の、非反復ヘッダフィールドに署名することです。別の戦略は、受信機で、メッセージの処理に影響を与える可能性が高いそうでない場合に表示されるか、またはされる可能性があるだけヘッダーフィールドに署名することです。第三の戦略は、「既知の」ヘッダに署名することです。検証者は、エンドユーザーにそれらを表示することを拒否するか、特定のヘッダフィールドをカバーしていない場合でも署名を無視するなど、極端な懐疑と符号なしのヘッダーフィールドを扱うことができることに留意されたいです。この理由のため、件名、日付などのメッセージ内に存在するフィールドを、署名、送信者に返信し、すべてのMIMEヘッダフィールドは、高度に助言されます。"
    },
    {
      "indent": 3,
      "text": "The DKIM-Signature header field is always implicitly signed and MUST NOT be included in the \"h=\" tag except to indicate that other preexisting signatures are also signed.",
      "ja": "DKIM-Signatureヘッダーフィールドは常に暗黙的に署名され、他の既存の署名はまた、署名されていることを示すために除いて、「H =」タグに含まれてはいけません。"
    },
    {
      "indent": 3,
      "text": "Signers MAY claim to have signed header fields that do not exist (that is, Signers MAY include the header field name in the \"h=\" tag even if that header field does not exist in the message). When computing the signature, the nonexisting header field MUST be treated as the null string (including the header field name, header field value, all punctuation, and the trailing CRLF).",
      "ja": "署名者（つまり、署名者は、そのヘッダーフィールドがメッセージに存在しない場合でも、「H =」タグのヘッダフィールド名を含んでいてもよい）が存在しないヘッダーフィールドに署名したと主張することができます。署名を計算するとき、存在しないヘッダフィールドは、（ヘッダフィールド名を含む、ヘッダフィールド値、すべての句読点、および末尾のCRLF）ヌル文字列として扱われなければなりません。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE RATIONALE: This allows Signers to explicitly assert the absence of a header field; if that header field is added later, the signature will fail.",
      "ja": "有益な根拠：これは、署名者が明示的にヘッダフィールドが存在しないことを主張することを可能にします。そのヘッダーフィールドが後で追加された場合、署名は失敗します。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: A header field name need only be listed once more than the actual number of that header field in a message at the time of signing in order to prevent any further additions. For example, if there is a single Comments header field at the time of signing, listing Comments twice in the \"h=\" tag is sufficient to prevent any number of Comments header fields from being appended; it is not necessary (but is legal) to list Comments three or more times in the \"h=\" tag.",
      "ja": "有益な注意：ヘッダフィールド名のみ、さらなる追加を防止するために、ログイン時に一度メッセージでそのヘッダフィールドの実際の数よりもリストされる必要があります。で二回コメントリスト、署名時の単一のコメントヘッダフィールドがある場合、例えば、「hは=」タグが添付されてからのコメントヘッダフィールドの任意の数のを防止するのに十分です。それは、「H =」タグにコメントを3回以上をリストアップする必要はありません（ただし、法的です）。"
    },
    {
      "indent": 3,
      "text": "Refer to Section 5.4.2 for a discussion of the procedure to be followed when canonicalizing a header with more than one instance of a particular header field name.",
      "ja": "特定のヘッダフィールド名の複数のインスタンスを有するヘッダをcanonicalizingた場合の処理​​手順の説明については、セクション5.4.2を参照。"
    },
    {
      "indent": 3,
      "text": "Signers need to be careful of signing header fields that might have additional instances added later in the delivery process, since such header fields might be inserted after the signed instance or otherwise reordered. Trace header fields (such as Received) and Resent-* blocks are the only fields prohibited by [RFC5322] from being reordered. In particular, since DKIM-Signature header fields may be reordered by some intermediate MTAs, signing existing DKIM-Signature header fields is error-prone.",
      "ja": "署名者は、このようなヘッダフィールドが署名されたインスタンスの後に挿入または他の方法で再順序付けされるかもしれないので、追加のインスタンスは、配信プロセスの後半で添加したかもしれないヘッダフィールドに署名するのに注意する必要があります。 （例えば、受信された）トレースヘッダフィールドとはResent- *ブロックが並べ替えされること[RFC5322]によって禁止フィールドのみです。具体的には、DKIM-Signatureヘッダーフィールドは、いくつかの中間のMTAによって並べ替えることができるので、既存のDKIM署名ヘッダーフィールドに署名すると、エラーが発生しやすいです。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE ADMONITION: Despite the fact that [RFC5322] does not prohibit the reordering of header fields, reordering of signed header fields with multiple instances by intermediate MTAs will cause DKIM signatures to be broken; such antisocial behavior should be avoided.",
      "ja": "有益な忠告：[RFC5322]は、ヘッダフィールドの並べ替えを禁止していないという事実にもかかわらず、中間のMTAによる複数のインスタンスを符号付きヘッダーフィールドの並べ替えは、DKIM署名が破壊されます。そのような反社会的行動は避けるべきです。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTER'S NOTE: Although not required by this specification, all end-user visible header fields should be signed to avoid possible \"indirect spamming\". For example, if the Subject header field is not signed, a spammer can resend a previously signed mail, replacing the legitimate subject with a one-line spam.",
      "ja": "有益な実装者注：この仕様で必須ではないが、すべてのエンドユーザに見えるヘッダフィールドは、可能な「間接スパム」を回避するために署名しなければなりません。件名ヘッダフィールドが署名されていない場合、例えば、スパマーは、一行のスパムと正当な対象を置き換える、以前に署名されたメールを再送信することができます。"
    },
    {
      "indent": 0,
      "text": "5.4.1. Recommended Signature Content",
      "section_title": true,
      "ja": "5.4.1. 推奨署名の内容"
    },
    {
      "indent": 3,
      "text": "The purpose of the DKIM cryptographic algorithm is to affix an identifier to the message in a way that is both robust against normal transit-related changes and resistant to kinds of replay attacks. An essential aspect of satisfying these requirements is choosing what header fields to include in the hash and what fields to exclude.",
      "ja": "DKIM暗号アルゴリズムの目的は、通常の輸送に関連した変化に対してロバストとリプレイ攻撃の種類に耐性の両方である方法でメッセージに識別子を添付することです。これらの要件を満たすの重要な側面は、ヘッダフィールドは、ハッシュに含めるとどのような分野除外するものを選んでいます。"
    },
    {
      "indent": 3,
      "text": "The basic rule for choosing fields to include is to select those fields that constitute the \"core\" of the message content. Hence, any replay attack will have to include these in order to have the signature succeed; however, with these included, the core of the message is valid, even if sent on to new recipients.",
      "ja": "含めるフィールドを選択するための基本的なルールは、メッセージ内容の「コア」を構成するこれらのフィールドを選択することです。したがって、任意のリプレイ攻撃は、シグネチャが成功させるためにこれらを含める必要があります。しかし、これらの含まれて、メッセージの核心は、新しい受信者に送信されるにしても、有効です。"
    },
    {
      "indent": 3,
      "text": "Common examples of fields with addresses and fields with textual content related to the body are:",
      "ja": "体に関連するテキストコンテンツを持つアドレスとフィールドを持つフィールドの一般的な例は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o From (REQUIRED; see Section 5.4)",
      "ja": "oから（REQUIRED、5.4節を参照してください）"
    },
    {
      "indent": 3,
      "text": "o Reply-To",
      "ja": "O返信先"
    },
    {
      "indent": 3,
      "text": "o Subject",
      "ja": "O件名"
    },
    {
      "indent": 3,
      "text": "o Date",
      "ja": "データ"
    },
    {
      "indent": 3,
      "text": "o To, Cc",
      "ja": "Oに対して、Ccを"
    },
    {
      "indent": 3,
      "text": "o Resent-Date, Resent-From, Resent-To, Resent-Cc o In-Reply-To, References",
      "ja": "Resent-からのResent-に、憤慨し-CCでは、返信先〇〇のResent-日、参考文献"
    },
    {
      "indent": 3,
      "text": "o List-Id, List-Help, List-Unsubscribe, List-Subscribe, List-Post, List-Owner, List-Archive",
      "ja": "Oリスト-ID、リスト・ヘルプ、一覧-脱退、リスト-購読、リスト・ポスト、リスト、所有者、リスト・アーカイブ"
    },
    {
      "indent": 3,
      "text": "If the \"l=\" signature tag is in use (see Section 3.5), the Content-Type field is also a candidate for being included as it could be replaced in a way that causes completely different content to be rendered to the receiving user.",
      "ja": "「L =」署名タグが使用されている場合のContent-Typeフィールドは、また、それは完全に異なるコンテンツが受信側ユーザにレンダリングさせるように置き換えることができるように含まれるの候補である、（セクション3.5を参照）。"
    },
    {
      "indent": 3,
      "text": "There are trade-offs in the decision of what constitutes the \"core\" of the message, which for some fields is a subjective concept. Including fields such as \"Message-ID\", for example, is useful if one considers a mechanism for being able to distinguish separate instances of the same message to be core content. Similarly, \"In-Reply-To\" and \"References\" might be desirable to include if one considers message threading to be a core part of the message.",
      "ja": "いくつかのフィールドの主観的な概念であるメッセージの「コア」を構成するものの意思決定におけるトレードオフがあります。一つは、コアコンテンツであることが、同じメッセージの別々のインスタンスを区別することができるためのメカニズムを考慮した場合、このような「メッセージID」などのフィールドを含む、例えば、有用です。同様に、「イン返信先」と「参照」とは、一つのメッセージスレッドは、メッセージのコア部分であると考える場合に含めることが望ましいかもしれません。"
    },
    {
      "indent": 3,
      "text": "Another class of fields that may be of interest are those that convey security-related information about the message, such as Authentication-Results [RFC5451].",
      "ja": "関心のあるフィールドの別のクラスは、認証、結果としてメッセージ、[RFC5451]に関するセキュリティ関連情報を伝えるものです。"
    },
    {
      "indent": 3,
      "text": "The basic rule for choosing fields to exclude is to select those fields for which there are multiple fields with the same name and fields that are modified in transit. Examples of these are:",
      "ja": "除外するフィールドを選択するための基本的なルールは途中で変更されている同じ名前とフィールドを持つ複数のフィールドがありますそのため、これらのフィールドを選択することです。これらの例は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Return-Path",
      "ja": "Oリターンパス"
    },
    {
      "indent": 3,
      "text": "o Received",
      "ja": "O受信"
    },
    {
      "indent": 3,
      "text": "o Comments, Keywords",
      "ja": "Oコメント、キーワード"
    },
    {
      "indent": 3,
      "text": "Note that the DKIM-Signature field is also excluded from the header hash because its handling is specified separately.",
      "ja": "その処理が別々に指定されているため、DKIM署名フィールドは、ヘッダのハッシュから除外されることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Typically, it is better to exclude other optional fields because of the potential that additional fields of the same name will be legitimately added or reordered prior to verification. There are likely to be legitimate exceptions to this rule because of the wide variety of application-specific header fields that might be applied to a message, some of which are unlikely to be duplicated, modified, or reordered.",
      "ja": "一般的に、あるため、同じ名前の追加フィールドが合法的に検証する前に追加したり、並べ替えることになる可能性の他のオプションのフィールドを除外することをお勧めします。なぜなら、重複変更、または並べ替えされそうにないそのうちのいくつかのメッセージに適用される可能性があります、アプリケーション固有のヘッダフィールド、多種多様なこの規則の合法的な例外である可能性が高いがあります。"
    },
    {
      "indent": 3,
      "text": "Signers SHOULD choose canonicalization algorithms based on the types of messages they process and their aversion to risk. For example, e-commerce sites sending primarily purchase receipts, which are not expected to be processed by mailing lists or other software likely to modify messages, will generally prefer \"simple\" canonicalization.",
      "ja": "署名者は、彼らが処理するメッセージの種類とリスクへの嫌悪感に基づいて正規化アルゴリズムを選択する必要があります。たとえば、メッセージを変更する可能性が高いメーリングリストや他のソフトウェアによって処理されることが予想されていない主に領収書を購入する送信電子商取引サイトは、一般的に「シンプル」正規化を好むでしょう。"
    },
    {
      "indent": 3,
      "text": "Sites sending primarily person-to-person email will likely prefer to be more resilient to modification during transport by using \"relaxed\" canonicalization.",
      "ja": "主に個人対個人の電子メールを送信するサイトは、おそらく「リラックス」正規化を使用することにより、輸送中に修正するより弾力的であることを好むでしょう。"
    },
    {
      "indent": 3,
      "text": "Unless mail is processed through intermediaries, such as mailing lists that might add \"unsubscribe\" instructions to the bottom of the message body, the \"l=\" tag is likely to convey no additional benefit while providing an avenue for unauthorized addition of text to a message. The use of \"l=0\" takes this to the extreme, allowing complete alteration of the text of the message without invalidating the signature. Moreover, a Verifier would be within its rights to consider a partly signed message body as unacceptable. Judicious use is advised.",
      "ja": "メールがメッセージ本体の下部に「配信停止」の指示が追加される場合があります、このようなメーリングリストなどの仲介、通って処理されていない場合にテキストの不正追加のための道を提供しながら、「lは=」タグには、追加の利益を伝えていない可能性がありますメッセージ。 「L = 0」の使用は、署名を無効にせずに、メッセージのテキストの完全な変更を可能にし、極端にこれを取ります。また、Verifierは、部分的に署名されたメッセージ本体は容認できないとして考慮することがその権利範囲内であろう。賢明な使用をお勧めします。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Signatures Involving Multiple Instances of a Field",
      "section_title": true,
      "ja": "5.4.2. フィールドの複数のインスタンスを伴う署名"
    },
    {
      "indent": 3,
      "text": "Signers choosing to sign an existing header field that occurs more than once in the message (such as Received) MUST sign the physically last instance of that header field in the header block. Signers wishing to sign multiple instances of such a header field MUST include the header field name multiple times in the \"h=\" tag of the DKIM-Signature header field and MUST sign such header fields in order from the bottom of the header field block to the top. The Signer MAY include more instances of a header field name in \"h=\" than there are actual corresponding header fields so that the signature will not verify if additional header fields of that name are added.",
      "ja": "署名者は、ヘッダブロックにそのヘッダフィールドの物理的に最後のインスタンスを署名する必要があり、一度メッセージよりも（例えば、受信された）が発生する既存のヘッダフィールドに署名することを選択します。このようなヘッダフィールドの複数のインスタンスを署名することを望む署名者は、ヘッダフィールド名をDKIM-Signatureヘッダーフィールドの「H =」タグに複数回含まなければならないとするヘッダフィールドのブロックの下から順に、そのようなヘッダフィールドに署名しなければなりませんトップ。署名者は、その名前の追加のヘッダフィールドが追加された場合、署名は検証しないように、実際の対応するヘッダフィールドがあるよりも、「= H」のヘッダフィールド名の複数のインスタンスを含むかもしれません。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE EXAMPLE:",
      "ja": "有益な例："
    },
    {
      "indent": 6,
      "text": "If the Signer wishes to sign two existing Received header fields, and the existing header contains:",
      "ja": "署名者は、2つの既存のReceivedヘッダーフィールドに署名することを希望し、かつ既存のヘッダが含まれている場合："
    },
    {
      "indent": 6,
      "text": "Received: <A> Received: <B> Received: <C>",
      "ja": "受信：<A>受付：<B>受信：<C>"
    },
    {
      "indent": 6,
      "text": "then the resulting DKIM-Signature header field should read:",
      "ja": "次いで得られたDKIM-Signatureヘッダーフィールドを読み取る必要があります。"
    },
    {
      "indent": 6,
      "text": "DKIM-Signature: ... h=Received : Received :...",
      "ja": "DKIM-署名：...時間=受付：受信します：..."
    },
    {
      "indent": 6,
      "text": "and Received header fields <C> and <B> will be signed in that order.",
      "ja": "ヘッダフィールド<C>を受信し、<B>はその順序で署名されます。"
    },
    {
      "indent": 0,
      "text": "5.5. Compute the Message Hash and Signature",
      "section_title": true,
      "ja": "5.5. メッセージハッシュと署名を計算"
    },
    {
      "indent": 3,
      "text": "The Signer MUST compute the message hash as described in Section 3.7 and then sign it using the selected public-key algorithm. This will result in a DKIM-Signature header field that will include the body hash and a signature of the header hash, where that header includes the DKIM-Signature header field itself.",
      "ja": "署名者は、セクション3.7で説明したように、メッセージのハッシュを計算し、次いで、選択された公開鍵アルゴリズムを使用して、それに署名しなければなりません。これは、本体ハッシュとそのヘッダはDKIM-Signatureヘッダーフィールド自体を含むヘッダハッシュの署名を含むDKIM-Signatureヘッダーフィールドをもたらすであろう。"
    },
    {
      "indent": 3,
      "text": "Entities such as mailing list managers that implement DKIM and that modify the message or a header field (for example, inserting unsubscribe information) before retransmitting the message SHOULD check any existing signature on input and MUST make such modifications before re-signing the message.",
      "ja": "そのようなDKIMを実装し、その入力上の既存の署名を確認する必要があり、メッセージを再送信する前に（解除情報を挿入など）メッセージまたはヘッダーフィールドを変更し、メッセージを再署名する前に、このような変更を行う必要があり、メーリングリストマネージャなどのエンティティ。"
    },
    {
      "indent": 0,
      "text": "5.6. Insert the DKIM-Signature Header Field",
      "section_title": true,
      "ja": "5.6.  DKIM-署名ヘッダーフィールドを挿入します"
    },
    {
      "indent": 3,
      "text": "Finally, the Signer MUST insert the DKIM-Signature header field created in the previous step prior to transmitting the email. The DKIM-Signature header field MUST be the same as used to compute the hash as described above, except that the value of the \"b=\" tag MUST be the appropriately signed hash computed in the previous step, signed using the algorithm specified in the \"a=\" tag of the DKIM-Signature header field and using the private key corresponding to the selector given in the \"s=\" tag of the DKIM-Signature header field, as chosen above in Section 5.2.",
      "ja": "最後に、署名者は、従来の電子メールを送信する前のステップで作成したDKIM署名ヘッダフィールドを挿入する必要があります。ハッシュを計算するために使用されるの値ことを除いて、上記のようにDKIM-Signatureヘッダーフィールドが同じでなければなりません「B =」タグは、前のステップで計算された適切に署名されたハッシュでなければなりません、で指定されたアルゴリズムを使用して署名「A =」DKIM署名ヘッダフィールドのタグと5.2節において上で選択されたようにDKIM署名ヘッダフィールドの「S =」タグで指定されたセレクタに対応する秘密鍵を使用して。"
    },
    {
      "indent": 3,
      "text": "The DKIM-Signature header field MUST be inserted before any other DKIM-Signature fields in the header block.",
      "ja": "DKIM-Signatureヘッダーフィールドは、ヘッダブロック内の他のDKIM署名フィールドの前に挿入されなければなりません。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTATION NOTE: The easiest way to achieve this is to insert the DKIM-Signature header field at the beginning of the header block. In particular, it may be placed before any existing Received header fields. This is consistent with treating DKIM-Signature as a trace header field.",
      "ja": "有益な実装上の注意：これを実現する最も簡単な方法は、ヘッダブロックの先頭にDKIM-Signatureヘッダフィールドを挿入することです。特に、既存の受信ヘッダーフィールドの前に配置されてもよいです。これは、トレースヘッダフィールドとしてDKIM-署名処理と一致しています。"
    },
    {
      "indent": 0,
      "text": "6. Verifier Actions",
      "section_title": true,
      "ja": "6.検証アクション"
    },
    {
      "indent": 3,
      "text": "Since a Signer MAY remove or revoke a public key at any time, it is advised that verification occur in a timely manner. In many configurations, the most timely place is during acceptance by the border MTA or shortly thereafter. In particular, deferring verification until the message is accessed by the end user is discouraged.",
      "ja": "署名者は、いつでも公開鍵を削除するか、または取り消すことができるので、検証が適時に起こることをお勧めします。多くの構成では、最もタイムリーな場所は、その後まもなく、境界MTAによって受け入れ中にありますか。エンドユーザが推奨されていることにより、特に、検証を延期メッセージがアクセスされるまで。"
    },
    {
      "indent": 3,
      "text": "A border or intermediate MTA MAY verify the message signature(s). An MTA who has performed verification MAY communicate the result of that verification by adding a verification header field to incoming messages. This simplifies things considerably for the user, who can now use an existing mail user agent. Most MUAs have the ability to filter messages based on message header fields or content; these filters would be used to implement whatever policy the user wishes with respect to unsigned mail.",
      "ja": "境界または中間MTAは、メッセージ署名（S）を検証することができます。検証を行ったMTAは、着信メッセージを検証ヘッダフィールドを追加することによって、その検証結果を通信してもよいです。これは現在、既存のメールユーザエージェントを使用することができ、ユーザのために大幅に物事を簡素化します。ほとんどのMUAは、メッセージヘッダーフィールドや内容に基づいてメッセージをフィルタリングする能力を持っています。これらのフィルタは、ユーザーが未署名のメールに関して希望するどんなポリシーを実装するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A verifying MTA MAY implement a policy with respect to unverifiable mail, regardless of whether or not it applies the verification header field to signed messages.",
      "ja": "検証MTAにかかわらず、それが署名されたメッセージを検証ヘッダフィールドを適用するか否かを、検証不可能メールに対してポリシーを実施することができます。"
    },
    {
      "indent": 3,
      "text": "Verifiers MUST produce a result that is semantically equivalent to applying the steps listed in Sections 6.1, 6.1.1, and 6.1.2 in order. In practice, several of these steps can be performed in parallel in order to improve performance.",
      "ja": "検証は、6.1、6.1.1および6.1.2ためにセクションに記載された手順を適用することと意味的に等価である結果を生成しなければなりません。実際には、これらのステップのいくつかは、性能を向上させるために並行して行うことができます。"
    },
    {
      "indent": 0,
      "text": "6.1. Extract Signatures from the Message",
      "section_title": true,
      "ja": "6.1. メッセージから署名を抽出"
    },
    {
      "indent": 3,
      "text": "The order in which Verifiers try DKIM-Signature header fields is not defined; Verifiers MAY try signatures in any order they like. For example, one implementation might try the signatures in textual order, whereas another might try signatures by identities that match the contents of the From header field before trying other signatures. Verifiers MUST NOT attribute ultimate meaning to the order of multiple DKIM-Signature header fields. In particular, there is reason to believe that some relays will reorder the header fields in potentially arbitrary ways.",
      "ja": "検証者はDKIM-Signatureヘッダーフィールドを試みる順序が定義されていません。検証者は、彼らが好きな順序で署名をしようとします。他には、他の署名を試みる前に、Fromヘッダーフィールドの内容を一致させることにより、アイデンティティ署名を試みるかもしれないのに対し、例えば、一つの実施は、テキストの順に署名をしてみてください可能性があります。検証者は、複数のDKIM-Signatureヘッダフィールドの順序に究極の意味属性はなりません。特に、いくつかのリレーが潜在的に任意の方法で、ヘッダフィールドの順序を変更することを信じる理由があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTATION NOTE: Verifiers might use the order as a clue to signing order in the absence of any other information. However, other clues as to the semantics of multiple signatures (such as correlating the signing host with Received header fields) might also be considered.",
      "ja": "有益な実装上の注意：検証者は、他の情報が存在しない場合に順番に署名する手がかりとして順序を使用する場合があります。しかしながら、（例えば、受信されたヘッダフィールドと署名ホストを相関等）複数の署名の意味論についての他の手がかりも考慮されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Survivability of signatures after transit is not guaranteed, and signatures can fail to verify through no fault of the Signer. Therefore, a Verifier SHOULD NOT treat a message that has one or more bad signatures and no good signatures differently from a message with no signature at all.",
      "ja": "輸送後の署名の生存が保証されていない、と署名は、署名者の過失による検証に失敗することがあります。そのため、Verifierはまったく署名付きメッセージとは異なる1人の以上の悪い署名とダメ署名を持つメッセージを処理すべきではありません。"
    },
    {
      "indent": 3,
      "text": "When a signature successfully verifies, a Verifier will either stop processing or attempt to verify any other signatures, at the discretion of the implementation. A Verifier MAY limit the number of signatures it tries, in order to avoid denial-of-service attacks (see Section 8.4 for further discussion).",
      "ja": "署名が正常に検証する場合、検証処理を停止したり、実装の裁量で、他の署名を検証しようとしますか。 Verifierは、サービス拒否攻撃を（さらなる議論については、セクション8.4を参照）を避けるために、それはしようとする署名の数を制限することがあります。"
    },
    {
      "indent": 3,
      "text": "In the following description, text reading \"return status (explanation)\" (where \"status\" is one of \"PERMFAIL\" or \"TEMPFAIL\") means that the Verifier MUST immediately cease processing that signature. The Verifier SHOULD proceed to the next signature, if one is present, and completely ignore the bad signature. If the status is \"PERMFAIL\", the signature failed and should not be reconsidered. If the status is \"TEMPFAIL\", the signature could not be verified at this time but may be tried again later. A Verifier MAY either arrange to defer the message for later processing or try another signature; if no good signature is found and any of the signatures resulted in a TEMPFAIL status, the Verifier MAY arrange to defer the message for later processing. The \"(explanation)\" is not normative text; it is provided solely for clarification.",
      "ja": "以下の説明では、テキスト読み上げ「リターン・ステータス（解説）」は（「ステータス」が「PERMFAIL」または「TEMPFAIL」の一つである）検証者は直ちにその署名を処理中止しなければならないことを意味します。検証は1つが存在する場合、次の署名に進み、そして完全に悪い署名を無視すべきです。ステータスが「PERMFAIL」である場合、署名は失敗し、再検討すべきではありません。ステータスが「TEMPFAIL」である場合、署名は現時点では確認できませんでしたが、後で再試行することができます。検証は、後の処理のためにメッセージを延期するか、別の署名を試して配置してもよいのいずれか;何良い署名が見つからないと署名のいずれかTEMPFAIL状態を生じている場合、検証ツールは、後の処理のためにメッセージを延期するために配置してもよいです。 「（説明）」規範的なテキストではありません。それが明確化のためにのみ提供されます。"
    },
    {
      "indent": 3,
      "text": "Verifiers that are prepared to validate multiple signature header fields SHOULD proceed to the next signature header field, if one exists. However, Verifiers MAY make note of the fact that an invalid signature was present for consideration at a later step.",
      "ja": "が存在する場合、次の署名ヘッダフィールドに進むべき複数の署名ヘッダフィールドを検証するために用意されている検証。しかし、検証者は、無効な署名が、後のステップで検討のために存在していたという事実のノートを作成することができます。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: The rationale of this requirement is to permit messages that have invalid signatures but also a valid signature to work. For example, a mailing list exploder might opt to leave the original submitter signature in place even though the exploder knows that it is modifying the message in some way that will break that signature, and the exploder inserts its own signature. In this case, the message should succeed even in the presence of the known-broken signature.",
      "ja": "有益な注意：この要件の根拠が無効な署名だけでなく、動作するように有効な署名を持つメッセージを可能にすることです。例えば、メーリングリストエクスプローダはエクスプローダは、それがその署名を破るだろう何らかの方法でメッセージを変更している、とエクスプローダはそれ自身の署名を挿入することを知っているにもかかわらず、代わりに、元の提出者の署名を残すことを選ぶかもしれません。この場合、メッセージも知ら破断署名の存在下で成功するべきです。"
    },
    {
      "indent": 3,
      "text": "For each signature to be validated, the following steps should be performed in such a manner as to produce a result that is semantically equivalent to performing them in the indicated order.",
      "ja": "各署名を検証するために示された順序でそれらを実行することに意味的に等価である結果を生成するように、次のステップは、このような方法で実行されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Validate the Signature Header Field",
      "section_title": true,
      "ja": "6.1.1. 署名ヘッダーフィールドを検証します"
    },
    {
      "indent": 3,
      "text": "Implementers MUST meticulously validate the format and values in the DKIM-Signature header field; any inconsistency or unexpected values MUST cause the header field to be completely ignored and the Verifier to return PERMFAIL (signature syntax error). Being \"liberal in what you accept\" is definitely a bad strategy in this security context. Note, however, that this does not include the existence of unknown tags in a DKIM-Signature header field, which are explicitly permitted. Verifiers MUST return PERMFAIL (incompatible version) when presented a DKIM-Signature header field with a \"v=\" tag that is inconsistent with this specification.",
      "ja": "実装は、細心の注意を払っDKIM署名ヘッダフィールドのフォーマットと値を検証しなければなりません。任意の矛盾または予期しない値は、ヘッダフィールドを完全に無視すると、検証者がPERMFAIL（署名構文エラー）を返させなければなりません。 「あなたが受け入れるものにリベラル」であることは間違いなく、このセキュリティコンテキストで悪い戦略です。これは明示的に許可されているDKIM署名ヘッダフィールドに未知のタグの存在が含まれていないこと、しかし、注意してください。本明細書と矛盾する「V =」タグでDKIM署名ヘッダーフィールドを提示したときに検証がPERMFAIL（互換性のないバージョン）を返さなければなりません。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTATION NOTE: An implementation may, of course, choose to also verify signatures generated by older versions of this specification.",
      "ja": "有益な実装上の注意：実装は、もちろん、この仕様の以前のバージョンによって生成された署名を検証することもできます。"
    },
    {
      "indent": 3,
      "text": "If any tag listed as \"required\" in Section 3.5 is omitted from the DKIM-Signature header field, the Verifier MUST ignore the DKIM-Signature header field and return PERMFAIL (signature missing required tag).",
      "ja": "セクション3.5で「必要」としてリストされているタグはDKIM署名ヘッダフィールドから省略されている場合、検証ツールは、（署名が必要なタグが欠落）DKIM-Signatureヘッダーフィールドを無視しPERMFAILを返さなければなりません。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: The tags listed as required in Section 3.5 are \"v=\", \"a=\", \"b=\", \"bh=\", \"d=\", \"h=\", and \"s=\". Should there be a conflict between this note and Section 3.5, Section 3.5 is normative.",
      "ja": "有益な注意：セクション3.5に、必要に応じて記載されているタグである \"V =\"、 \"=\"、 \"B =\"、 \"BH =\"、 \"D =\"、 \"H =\"、および \"S =\"。このノートとセクション3.5との間に矛盾があるはず、3.5節は規範的です。"
    },
    {
      "indent": 3,
      "text": "If the DKIM-Signature header field does not contain the \"i=\" tag, the Verifier MUST behave as though the value of that tag were \"@d\", where \"d\" is the value from the \"d=\" tag.",
      "ja": "DKIM-Signatureヘッダーフィールドは「I =」タグが含まれていない場合、検証ツールは、そのタグの値が「@d」、「d」は「D =」タグの値があったかのように動作しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Verifiers MUST confirm that the domain specified in the \"d=\" tag is the same as or a parent domain of the domain part of the \"i=\" tag. If not, the DKIM-Signature header field MUST be ignored, and the Verifier should return PERMFAIL (domain mismatch).",
      "ja": "検証者は、「D =」タグで指定されたドメインが同じまたは「I =」タグのドメイン部分の親ドメインであることを確認しなければなりません。ない場合は、DKIM-Signatureヘッダフィールドは無視しなければなりません、とVerifierはPERMFAIL（ドメインの不一致）を返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If the \"h=\" tag does not include the From header field, the Verifier MUST ignore the DKIM-Signature header field and return PERMFAIL (From field not signed).",
      "ja": "「H =」タグからヘッダフィールドが含まれていない場合、検証は、DKIM-Signatureヘッダーフィールドを無視しPERMFAILを返す（フィールドから署名されていない）しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Verifiers MAY ignore the DKIM-Signature header field and return PERMFAIL (signature expired) if it contains an \"x=\" tag and the signature has expired.",
      "ja": "検証は、DKIM-Signatureヘッダーフィールドを無視し、それは「X =」タグが含まれており、署名の有効期限が切れている場合（署名が期限切れ）PERMFAILを返すことができます。"
    },
    {
      "indent": 3,
      "text": "Verifiers MAY ignore the DKIM-Signature header field if the domain used by the Signer in the \"d=\" tag is not associated with a valid signing entity. For example, signatures with \"d=\" values such as \"com\" and \"co.uk\" could be ignored. The list of unacceptable domains SHOULD be configurable.",
      "ja": "ドメインは「D =」タグが有効な署名エンティティに関連付けられていない場合に署名者が使用する場合検証は、DKIM-Signatureヘッダーフィールドを無視してもよいです。例えば、そのような「COM」および「co.uk」として「D =」値を有する署名は無視することができます。容認できないドメインのリストは設定可能べきです。"
    },
    {
      "indent": 3,
      "text": "Verifiers MAY ignore the DKIM-Signature header field and return PERMFAIL (unacceptable signature header) for any other reason, for example, if the signature does not sign header fields that the Verifier views to be essential. As a case in point, if MIME header fields are not signed, certain attacks may be possible that the Verifier would prefer to avoid.",
      "ja": "検証は、DKIM-Signatureヘッダーフィールドを無視して、署名が検証ビューが必須であることがヘッダーフィールドに署名していない場合、例えば、他の理由PERMFAIL（許容できない署名ヘッダ）を返すかもしれ。 MIMEヘッダフィールドが署名されていない場合、その一例として、特定の攻撃は、検証者が避けることを好むことが可能であってもよいです。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Get the Public Key",
      "section_title": true,
      "ja": "6.1.2. 公開鍵を取得します"
    },
    {
      "indent": 3,
      "text": "The public key for a signature is needed to complete the verification process. The process of retrieving the public key depends on the query type as defined by the \"q=\" tag in the DKIM-Signature header field. Obviously, a public key need only be retrieved if the process of extracting the signature information is completely successful.",
      "ja": "署名の公開鍵は、検証プロセスを完了するために必要とされます。公開鍵を取得するプロセスは、DKIM-Signatureヘッダーフィールドに「Q =」タグによって定義されたクエリのタイプに依存します。署名情報を抽出する処理が完全に成功した場合明らかに、公開鍵のみが取り出される必要があります。"
    },
    {
      "indent": 3,
      "text": "Details of key management and representation are described in Section 3.6. The Verifier MUST validate the key record and MUST ignore any public-key records that are malformed.",
      "ja": "鍵管理や表現の詳細については、セクション3.6で説明されています。 Verifierは、キーレコードを検証しなければならないし、不正な形式のある任意の公開鍵レコードを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "NOTE: The use of a wildcard TXT RR that covers a queried DKIM domain name will produce a response to a DKIM query that is unlikely to be a valid DKIM key record. This problem is not specific to DKIM and applies to many other types of queries. Client software that processes DNS responses needs to take this problem into account.",
      "ja": "注：有効なDKIMキーレコードになることはほとんどありませんDKIMのクエリに対する応答を生成します照会DKIMドメイン名をカバーワイルドカードTXT RRの使用。この問題は、DKIMに特有のものではなく、クエリの多くの他のタイプに適用されます。 DNS応答を処理するクライアントソフトウェアは、アカウントにこの問題を取る必要があります。"
    },
    {
      "indent": 3,
      "text": "When validating a message, a Verifier MUST perform the following steps in a manner that is semantically the same as performing them in the order indicated; in some cases, the implementation may parallelize or reorder these steps, as long as the semantics remain unchanged:",
      "ja": "メッセージを検証するとき、検証者は、意味的に示された順序でそれらを行うと同じであるように、以下の手順を実行する必要があります。いくつかのケースでは、実装は限り意味が変わらないよう、並列またはこれらの工程の順序を変更することがあります。"
    },
    {
      "indent": 3,
      "text": "1. The Verifier retrieves the public key as described in Section 3.6 using the algorithm in the \"q=\" tag, the domain from the \"d=\" tag, and the selector from the \"s=\" tag.",
      "ja": "1.検証は「D =」タグ、および「S =」タグからセレクタから「Q =」タグ、ドメイン内のアルゴリズムを使用して、セクション3.6で説明したように公開鍵を取り出します。"
    },
    {
      "indent": 3,
      "text": "2. If the query for the public key fails to respond, the Verifier MAY seek a later verification attempt by returning TEMPFAIL (key unavailable).",
      "ja": "2.公開鍵のクエリが応答に失敗した場合は、VerifierはTEMPFAIL（キー使用できません）を返すことによって、後で検証の試行を求めることができます。"
    },
    {
      "indent": 3,
      "text": "3. If the query for the public key fails because the corresponding key record does not exist, the Verifier MUST immediately return PERMFAIL (no key for signature).",
      "ja": "対応するキーレコードが存在しないため、公開鍵のためのクエリが失敗した場合3. VerifierはすぐにPERMFAIL（署名のためノーキー）を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. If the query for the public key returns multiple key records, the Verifier can choose one of the key records or may cycle through the key records, performing the remainder of these steps on each record at the discretion of the implementer. The order of the key records is unspecified. If the Verifier chooses to cycle through the key records, then the \"return ...\" wording in the remainder of this section means \"try the next key record, if any; if none, return to try another signature in the usual way\".",
      "ja": "4.公開鍵戻り複数のキーレコードのクエリは、検証者がキーレコードのいずれかを選択することができ、またはキーレコードを循環、実施者の裁量で各レコードに対してこれらの手順の残りを実行することができる場合。キーレコードの順序は不定です。検証は、キーレコードを順番に選択した場合は、このセクションの残りで「戻る...」の文言は、「;どれも、通常の方法で別の署名をしようと返さない場合があれば、次のキーのレコードを試してみてください」という意味します。"
    },
    {
      "indent": 3,
      "text": "5. If the result returned from the query does not adhere to the format defined in this specification, the Verifier MUST ignore the key record and return PERMFAIL (key syntax error). Verifiers are urged to validate the syntax of key records carefully to avoid attempted attacks. In particular, the Verifier MUST ignore keys with a version code (\"v=\" tag) that they do not implement.",
      "ja": "クエリから返された結果が、この仕様で定義されたフォーマットに準拠していない場合5.は、Verifierは鍵レコードを無視して、PERMFAIL（キー構文エラー）を返さなければなりません。検証者は、慎重にしようとした攻撃を避けるために、キーレコードの構文を検証するために促しています。特に、Verifierは、彼らが実装していないことをバージョンコード（「V =」タグ）を持つキーを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "6. If the \"h=\" tag exists in the public-key record and the hash algorithm implied by the \"a=\" tag in the DKIM-Signature header field is not included in the contents of the \"h=\" tag, the Verifier MUST ignore the key record and return PERMFAIL (inappropriate hash algorithm).",
      "ja": "6.「H =」タグは、公開鍵レコードとDKIM-Signatureヘッダーフィールドに「A =」タグによって暗示ハッシュアルゴリズムに存在する場合「= H」の内容に含まれていないタグVerifierは鍵レコードを無視して、PERMFAIL（不適切なハッシュアルゴリズム）を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "7. If the public-key data (the \"p=\" tag) is empty, then this key has been revoked and the Verifier MUST treat this as a failed signature check and return PERMFAIL (key revoked). There is no defined semantic difference between a key that has been revoked and a key record that has been removed.",
      "ja": "7.公開鍵データ（「P =」タグ）が空である場合、このキーは取り消されたと検証が失敗した署名の確認としてこれを扱い、PERMFAIL（鍵失効）を返さなければなりません。取り消されたキーと削除されたキーレコードの間に定義された意味的な違いはありません。"
    },
    {
      "indent": 3,
      "text": "8. If the public-key data is not suitable for use with the algorithm and key types defined by the \"a=\" and \"k=\" tags in the DKIM-Signature header field, the Verifier MUST immediately return PERMFAIL (inappropriate key algorithm).",
      "ja": "8.公開鍵データがDKIM署名ヘッダフィールドに「A =」と「K =」タグによって定義されたアルゴリズムと鍵のタイプとの使用に適していない場合、検証者は、直ちにPERMFAIL（不適切なキーアルゴリズムを返さなければなりません）。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Compute the Verification",
      "section_title": true,
      "ja": "6.1.3. 検証を計算"
    },
    {
      "indent": 3,
      "text": "Given a Signer and a public key, verifying a signature consists of actions semantically equivalent to the following steps.",
      "ja": "署名者と公開鍵を考えると、署名を検証するには、次の手順と意味的に等価なアクションで構成されています。"
    },
    {
      "indent": 3,
      "text": "1. Based on the algorithm defined in the \"c=\" tag, the body length specified in the \"l=\" tag, and the header field names in the \"h=\" tag, prepare a canonicalized version of the message as is described in Section 3.7 (note that this canonicalized version does not actually replace the original content). When matching header field names in the \"h=\" tag against the actual message header field, comparisons MUST be case-insensitive.",
      "ja": "記載されたように1は、「C =」タグで定義されたアルゴリズムに基づいて、「L =」タグで指定されたボディの長さ、及び「H =」タグ内のヘッダフィールド名は、メッセージの正規化バージョンを調製します3.7節で（この正規化されたバージョンは、実際にオリジナルのコンテンツを置き換えるものではありませんのでご注意）。実際のメッセージヘッダフィールドに対して「H =」タグ内のヘッダフィールド名と一致する場合、比較は大文字と小文字を区別しないでなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. Based on the algorithm indicated in the \"a=\" tag, compute the message hashes from the canonical copy as described in Section 3.7.",
      "ja": "2.「A =」タグで示されたアルゴリズムに基づいて、3.7節で説明したように、メッセージが正規のコピーからハッシュ計算します。"
    },
    {
      "indent": 3,
      "text": "3. Verify that the hash of the canonicalized message body computed in the previous step matches the hash value conveyed in the \"bh=\" tag. If the hash does not match, the Verifier SHOULD ignore the signature and return PERMFAIL (body hash did not verify).",
      "ja": "3.前のステップで計算された正規化メッセージ本体のハッシュは「BH =」タグに搬送されたハッシュ値と一致することを確認します。ハッシュが一致しない場合は、Verifierは署名を無視して（体のハッシュを検証しませんでした）PERMFAILを返すべきです。"
    },
    {
      "indent": 3,
      "text": "4. Using the signature conveyed in the \"b=\" tag, verify the signature against the header hash using the mechanism appropriate for the public-key algorithm described in the \"a=\" tag. If the signature does not validate, the Verifier SHOULD ignore the signature and return PERMFAIL (signature did not verify).",
      "ja": "4.「B =」タグに搬送署名を使用して、「A =」タグに記述公開鍵アルゴリズムのための適切なメカニズムを使用して、ヘッダのハッシュに対する署名を検証します。署名が検証されない場合は、Verifierは署名を無視して、PERMFAILを（署名は検証しませんでした）返すべきです。"
    },
    {
      "indent": 3,
      "text": "5. Otherwise, the signature has correctly verified.",
      "section_title": true,
      "ja": "5.それ以外の場合は、署名が正しく検証しました。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE IMPLEMENTER'S NOTE: Implementations might wish to initiate the public-key query in parallel with calculating the hash as the public key is not needed until the final decryption is calculated. Implementations may also verify the signature on the message header before validating that the message hash listed in the \"bh=\" tag in the DKIM-Signature header field matches that of the actual message body; however, if the body hash does not match, the entire signature must be considered to have failed.",
      "ja": "有益な実装者'S NOTE：実装は、最終的な復号化が計算されるまで、公開鍵が必要とされていないとして、ハッシュを計算することと並行して公開鍵のクエリを開始することを望むかもしれません。実装はまた、DKIM-Signatureヘッダーフィールドに「BH =」タグに記載されているメッセージのハッシュが、その実際のメッセージ本体の一致することを検証する前に、メッセージヘッダの署名を検証することができます。ボディハッシュが一致しない場合には、全体の署名が失敗したとみなされなければなりません。"
    },
    {
      "indent": 3,
      "text": "A body length specified in the \"l=\" tag of the signature limits the number of bytes of the body passed to the verification algorithm. All data beyond that limit is not validated by DKIM. Hence, Verifiers might treat a message that contains bytes beyond the indicated body length with suspicion and can choose to treat the signature as if it were invalid (e.g., by returning PERMFAIL (unsigned content)).",
      "ja": "で指定された本体長さ「Lが=」署名のタグは、検証アルゴリズムに渡された本体のバイトの数を制限します。その限界を超えたすべてのデータは、DKIMによって検証されていません。従って、検証者は、疑いで示さ本体長さを超えるバイトを含み、それは（PERMFAIL（無署名のコンテンツ）を返すことによって、例えば）は無効であるかのように署名を治療するために選択することができ、メッセージを扱うかもしれません。"
    },
    {
      "indent": 3,
      "text": "Should the algorithm reach this point, the verification has succeeded, and DKIM reports SUCCESS for this signature.",
      "ja": "アルゴリズムは、このポイントに到達する必要があり、検証が成功した、とDKIMは、この署名の成功を報告します。"
    },
    {
      "indent": 0,
      "text": "6.2. Communicate Verification Results",
      "section_title": true,
      "ja": "6.2. 検証結果を伝えます"
    },
    {
      "indent": 3,
      "text": "Verifiers wishing to communicate the results of verification to other parts of the mail system may do so in whatever manner they see fit. For example, implementations might choose to add an email header field to the message before passing it on. Any such header field SHOULD be inserted before any existing DKIM-Signature or preexisting authentication status header fields in the header field block. The Authentication-Results: header field ([RFC5451]) MAY be used for this purpose.",
      "ja": "メールシステムの他の部分に、検証の結果を通信することを望む検証者は、彼らが合うどんな方法でそれを行うことがあります。例えば、実装はそれを渡す前に、メッセージに電子メールヘッダフィールドを追加することもできます。任意のこのようなヘッダフィールドは、ヘッダフィールドのブロック内の既存のDKIM-署名または既存の認証ステータスヘッダフィールドの前に挿入されます。認証-結果：ヘッダフィールド（[RFC5451]）はこの目的に使用することができます。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE ADVICE to MUA filter writers: Patterns intended to search for results header fields to visibly mark authenticated mail for end users should verify that such a header field was added by the appropriate verifying domain and that the verified identity matches the author identity that will be displayed by the MUA. In particular, MUA filters should not be influenced by bogus results header fields added by attackers. To circumvent this attack, Verifiers MAY wish to request deletion of existing results header fields after verification and before arranging to add a new header field.",
      "ja": "MUAフィルタ作家にINFORMATIVE ADVICE：目に見えて、エンドユーザーのためのメールを認証されたマークに結果のヘッダフィールドを検索することを目的とパターンは、このようなヘッダフィールドは、適切な検証ドメインによって、検証アイデンティティが表示されます作者のアイデンティティと一致していることを追加されたことを確認する必要がありますMUAによって。具体的には、MUAフィルタは、攻撃者によって追加された偽の結果ヘッダーフィールドによって影響されるべきではありません。この攻撃を回避するために、検証者は、検証した後、新たなヘッダフィールドを追加するために配置する前に、既存の結果のヘッダフィールドの削除を要求することを望むかもしれません。"
    },
    {
      "indent": 0,
      "text": "6.3. Interpret Results/Apply Local Policy",
      "section_title": true,
      "ja": "6.3. 結果の解釈/ローカルポリシーを適用します。"
    },
    {
      "indent": 3,
      "text": "It is beyond the scope of this specification to describe what actions an Identity Assessor can make, but mail carrying a validated SDID presents an opportunity to an Identity Assessor that unauthenticated email does not. Specifically, an authenticated email creates a predictable identifier by which other decisions can reliably be managed, such as trust and reputation. Conversely, unauthenticated email lacks a reliable identifier that can be used to assign trust and reputation. It is reasonable to treat unauthenticated email as lacking any trust and having no positive reputation.",
      "ja": "これは、身元評価を行うことができますどのようなアクションを記述するために、この仕様の範囲を超えていますが、検証SDIDを運ぶメールが認証されていない電子メールがないことを身元評価する機会を提供します。具体的には、認証された電子メールは、他の決定が確実な信頼と評判として、管理することができたことにより、予測可能な識別子を作成します。逆に、認証されていない電子メールは信頼と評判を割り当てるために使用することができ、信頼性の識別子を欠いています。任意の信頼を欠いているし、何のポジティブな評判を持っていないとして認証されていない電子メールを処理するのが妥当です。"
    },
    {
      "indent": 3,
      "text": "In general, modules that consume DKIM verification output SHOULD NOT determine message acceptability based solely on a lack of any signature or on an unverifiable signature; such rejection would cause severe interoperability problems. If an MTA does wish to reject such messages during an SMTP session (for example, when communicating with a peer who, by prior agreement, agrees to only send signed messages), and a signature is missing or does not verify, the handling MTA SHOULD use a 550/5.7.x reply code.",
      "ja": "一般的には、DKIM検証出力を消費するモジュールは、任意の署名または署名検証不可能でないことのみに基づいてメッセージの良否を決定するべきではありません。そのような拒否は深刻な相互運用性の問題を引き起こします。 MTAは、SMTPセッション中にそのようなメッセージを拒否したくない場合（例えば、事前の合意によってのみ署名されたメッセージを送信することに同意し、ピアと通信するとき）、および署名が存在しないかを確認しない、MTA SHOULDを扱います550 / 5.7.xの応答コードを使用します。"
    },
    {
      "indent": 3,
      "text": "Where the Verifier is integrated within the MTA and it is not possible to fetch the public key, perhaps because the key server is not available, a temporary failure message MAY be generated using a 451/4.7.5 reply code, such as:",
      "ja": "Verifierは、MTA内に統合され、公開鍵を取得することができず、鍵サーバが利用できないかもしれないので、一時的な障害メッセージは451 / 4.7.5応答コードを使用して生成することができる、などの場合は："
    },
    {
      "indent": 3,
      "text": "451 4.7.5 Unable to verify signature - key server unavailable",
      "ja": "451 4.7.5署名を検証することができません - キーサーバー利用できません"
    },
    {
      "indent": 3,
      "text": "Temporary failures such as inability to access the key server or other external service are the only conditions that SHOULD use a 4xx SMTP reply code. In particular, cryptographic signature verification failures MUST NOT provoke 4xx SMTP replies.",
      "ja": "そのようなキーサーバや他の外部サービスへのアクセスができないなどの一時的な障害がする4xx SMTP応答コードを使用すべきである唯一の条件です。具体的には、暗号化署名検証の失敗は、4XX SMTP応答を誘発してはなりません。"
    },
    {
      "indent": 3,
      "text": "Once the signature has been verified, that information MUST be conveyed to the Identity Assessor (such as an explicit allow/ whitelist and reputation system) and/or to the end user. If the SDID is not the same as the address in the From: header field, the mail system SHOULD take pains to ensure that the actual SDID is clear to the reader.",
      "ja": "署名が検証されたら、その情報は、（例えば、明示的な許可/ホワイトリストと評判システムのような）及び/又はエンドユーザに身元評価に搬送しなければなりません。 SDIDからのアドレスと同じでない場合は、次のヘッダフィールド、メールシステムは、実際のSDIDが読者には明らかであることを保証するために、痛みを取るべきです。"
    },
    {
      "indent": 3,
      "text": "While the symptoms of a failed verification are obvious -- the signature doesn't verify -- establishing the exact cause can be more difficult. If a selector cannot be found, is that because the selector has been removed, or was the value changed somehow in transit? If the signature line is missing, is that because it was never there, or was it removed by an overzealous filter? For diagnostic purposes, the exact reason why the verification fails SHOULD be made available and possibly recorded in the system logs.",
      "ja": "失敗した検証の症状は明らかですが - 署名が検証されない - 正確な原因を確立することがより困難になることができます。セレクタが見つからない場合は、セレクタが削除されている、または値が転送中に何らかの形で変更されたためということですか？署名欄が欠落している場合、それはそこにはなかったので、またはそれがあまりに熱心なフィルターで除去されたことがありますか？診断目的のために、検証が失敗した正確な理由が利用可能であり、おそらくシステムログに記録されるべきです。"
    },
    {
      "indent": 3,
      "text": "If the email cannot be verified, then it SHOULD be treated the same as all unverified email, regardless of whether or not it looks like it was signed.",
      "ja": "メールが確認できない場合は、それは関係なく、それが署名されたように見えるかどうかの、全て未確認のメールと同じように扱われるべきです。"
    },
    {
      "indent": 3,
      "text": "See Section 8.15 for additional discussion.",
      "ja": "追加の議論については、セクション8.15を参照してください。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "DKIM has registered namespaces with IANA. In all cases, new values are assigned only for values that have been documented in a published RFC that has IETF Consensus [RFC5226].",
      "ja": "DKIMはIANAでの名前空間を登録しています。すべての場合において、新しい値のみがIETFコンセンサス[RFC5226]を持って公表RFCで文書化された値のために割り当てられています。"
    },
    {
      "indent": 3,
      "text": "This memo updates these registries as described below. Of note is the addition of a new \"status\" column. All registrations into these namespaces MUST include the name being registered, the document in which it was registered or updated, and an indication of its current status, which MUST be one of \"active\" (in current use) or \"historic\" (no longer in current use).",
      "ja": "後述のようにこのメモは、これらのレジストリを更新します。注目すべきは、新たな「状態」欄が追加されたことです。名前を含まなければならないこれらの名前空間へのすべての登録は、「アクティブ」（現在使用中）または「歴史的」（もはやの一つでなければならない、それが登録または更新された文書、および現在のステータスの表示を、登録されています現在使用されています）。"
    },
    {
      "indent": 3,
      "text": "No new tags are defined in this specification compared to [RFC4871], but one has been designated as \"historic\".",
      "ja": "新しいタグは、[RFC4871]と比較して、この仕様で定義されていませんが、一つは「歴史的」に指定されています。"
    },
    {
      "indent": 3,
      "text": "Also, the \"Email Authentication Methods\" registry is revised to refer to this update.",
      "ja": "また、「電子メール認証方式」のレジストリは、このアップデートを参照するために改訂されています。"
    },
    {
      "indent": 0,
      "text": "7.1. Email Authentication Methods Registry",
      "section_title": true,
      "ja": "7.1. メール認証方法レジストリ"
    },
    {
      "indent": 3,
      "text": "The \"Email Authentication Methods\" registry is updated to indicate that \"dkim\" is defined in this memo.",
      "ja": "「電子メール認証方式」のレジストリは「DKIM」がこのメモで定義されていることを示すように更新されます。"
    },
    {
      "indent": 0,
      "text": "7.2. DKIM-Signature Tag Specifications",
      "section_title": true,
      "ja": "7.2.  DKIM署名タグの仕様"
    },
    {
      "indent": 3,
      "text": "A DKIM-Signature provides for a list of tag specifications. IANA has established the \"DKIM-Signature Tag Specifications\" registry for tag specifications that can be used in DKIM-Signature fields.",
      "ja": "DKIM-署名タグ仕様のリストを提供します。 IANAはDKIM署名の分野で使用できるタグ仕様については、「DKIM署名タグ仕様」レジストリを確立しています。"
    },
    {
      "indent": 20,
      "text": "+------+-----------------+--------+\n| TYPE | REFERENCE       | STATUS |\n+------+-----------------+--------+\n|   v  | (this document) | active |\n|   a  | (this document) | active |\n|   b  | (this document) | active |\n|  bh  | (this document) | active |\n|   c  | (this document) | active |\n|   d  | (this document) | active |\n|   h  | (this document) | active |\n|   i  | (this document) | active |\n|   l  | (this document) | active |\n|   q  | (this document) | active |\n|   s  | (this document) | active |\n|   t  | (this document) | active |\n|   x  | (this document) | active |\n|   z  | (this document) | active |\n+------+-----------------+--------+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Table 1: DKIM-Signature Tag Specifications Registry Updated Values",
      "ja": "表1：DKIM-署名タグ仕様レジストリ更新された値"
    },
    {
      "indent": 0,
      "text": "7.3. DKIM-Signature Query Method Registry",
      "section_title": true,
      "ja": "7.3.  DKIM-署名クエリメソッドのレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"q=\" tag-spec (specified in Section 3.5) provides for a list of query methods.",
      "ja": "「Q =」タグ仕様（セクション3.5で指定された）は、クエリメソッドのリストを提供します。"
    },
    {
      "indent": 3,
      "text": "IANA has established the \"DKIM-Signature Query Method\" registry for mechanisms that can be used to retrieve the key that will permit validation processing of a message signed using DKIM.",
      "ja": "IANAはDKIMを使用して署名されたメッセージの検証処理を可能にするキーを取得するために使用することができるメカニズムは、「DKIM-署名クエリ方法」レジストリを確立しました。"
    },
    {
      "indent": 15,
      "text": "+------+--------+-----------------+--------+\n| TYPE | OPTION | REFERENCE       | STATUS |\n+------+--------+-----------------+--------+\n|  dns |   txt  | (this document) | active |\n+------+--------+-----------------+--------+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Table 2: DKIM-Signature Query Method Registry Updated Values",
      "ja": "表2：DKIM-署名クエリメソッドレジストリ更新された値"
    },
    {
      "indent": 0,
      "text": "7.4. DKIM-Signature Canonicalization Registry",
      "section_title": true,
      "ja": "7.4.  DKIM署名正規化のレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"c=\" tag-spec (specified in Section 3.5) provides for a specifier for canonicalization algorithms for the header and body of the message.",
      "ja": "（セクション3.5で指定された）「C =」タグ仕様は、メッセージのヘッダとボディ用の正規化アルゴリズムの指定を提供します。"
    },
    {
      "indent": 3,
      "text": "IANA has established the \"DKIM-Signature Canonicalization Header\" Registry for algorithms for converting a message into a canonical form before signing or verifying using DKIM.",
      "ja": "IANAは、署名またはDKIMを使用して検証する前に標準形式にメッセージを変換するためのアルゴリズムは、「DKIM-署名正規化ヘッダ」レジストリを確立しました。"
    },
    {
      "indent": 18,
      "text": "+---------+-----------------+--------+\n|   TYPE  | REFERENCE       | STATUS |\n+---------+-----------------+--------+\n|  simple | (this document) | active |\n| relaxed | (this document) | active |\n+---------+-----------------+--------+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Table 3: DKIM-Signature Canonicalization Header Registry Updated Values",
      "ja": "表3：DKIM-署名正規化ヘッダーレジストリ更新された値"
    },
    {
      "indent": 18,
      "text": "+---------+-----------------+--------+\n|   TYPE  | REFERENCE       | STATUS |\n+---------+-----------------+--------+\n|  simple | (this document) | active |\n| relaxed | (this document) | active |\n+---------+-----------------+--------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Table 4: DKIM-Signature Canonicalization Body Registry Updated Values",
      "ja": "表4：DKIM-署名正規化ボディレジストリ更新された値"
    },
    {
      "indent": 0,
      "text": "7.5. _domainkey DNS TXT Resource Record Tag Specifications",
      "section_title": true,
      "ja": "7.5.  DNS TXTリソースレコードタグ仕様_domainkey"
    },
    {
      "indent": 3,
      "text": "A _domainkey DNS TXT RR provides for a list of tag specifications. IANA has established the DKIM \"_domainkey DNS TXT Record Tag Specifications\" registry for tag specifications that can be used in DNS TXT resource records.",
      "ja": "_domainkey DNS TXT RRは、タグ仕様のリストを提供します。 IANAは、DNS TXTリソースレコードに使用することができ、タグの仕様についてはDKIM「_domainkey DNS TXTレコードのタグ仕様」レジストリを確立しています。"
    },
    {
      "indent": 19,
      "text": "+------+-----------------+----------+\n| TYPE | REFERENCE       | STATUS   |\n+------+-----------------+----------+\n|   v  | (this document) | active   |\n|   g  | [RFC4871]       | historic |\n|   h  | (this document) | active   |\n|   k  | (this document) | active   |\n|   n  | (this document) | active   |\n|   p  | (this document) | active   |\n|   s  | (this document) | active   |\n|   t  | (this document) | active   |\n+------+-----------------+----------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Table 5: _domainkey DNS TXT Record Tag Specifications Registry Updated Values",
      "ja": "表5：_domainkey DNS TXTレコードのタグ仕様レジストリ更新された値"
    },
    {
      "indent": 0,
      "text": "7.6. DKIM Key Type Registry",
      "section_title": true,
      "ja": "7.6.  DKIキータイプレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"k=\" <key-k-tag> (specified in Section 3.6.1) and the \"a=\" <sig-a-tag-k> (specified in Section 3.5) tags provide for a list of mechanisms that can be used to decode a DKIM signature.",
      "ja": "\"K =\" <キーKタグ>（セクション3.6.1で指定された）および \"A =\" <SIG-TAG-K>（セクション3.5で指定された）タグはメカニズムのリストを提供することができDKIM署名を復号するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "IANA has established the \"DKIM Key Type\" registry for such mechanisms.",
      "ja": "IANAはそのようなメカニズムのための「DKIMキータイプ」レジストリを確立しています。"
    },
    {
      "indent": 23,
      "text": "+------+-----------+--------+\n| TYPE | REFERENCE | STATUS |\n+------+-----------+--------+\n|  rsa | [RFC3447] | active |\n+------+-----------+--------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Table 6: DKIM Key Type Registry Updated Values",
      "ja": "表6：DKIMキータイプレジストリの更新された値"
    },
    {
      "indent": 0,
      "text": "7.7. DKIM Hash Algorithms Registry",
      "section_title": true,
      "ja": "7.7.  DKIハッシュアルゴリズムレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"h=\" <key-h-tag> (specified in Section 3.6.1) and the \"a=\" <sig-a-tag-h> (specified in Section 3.5) tags provide for a list of mechanisms that can be used to produce a digest of message data.",
      "ja": "\"H =\" <キーHタグ>（セクション3.6.1で指定された）および \"A =\" <SIG-TAG-H>（セクション3.5で指定された）タグはメカニズムのリストを提供することができメッセージデータのダイジェストを生成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "IANA has established the \"DKIM Hash Algorithms\" registry for such mechanisms.",
      "ja": "IANAはそのようなメカニズムのための「DKIMハッシュアルゴリズム」レジストリを確立しています。"
    },
    {
      "indent": 18,
      "text": "+--------+-------------------+--------+\n|  TYPE  | REFERENCE         | STATUS |\n+--------+-------------------+--------+\n|  sha1  | [FIPS-180-3-2008] | active |\n| sha256 | [FIPS-180-3-2008] | active |\n+--------+-------------------+--------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Table 7: DKIM Hash Algorithms Registry Updated Values",
      "ja": "表7：DKIMハッシュアルゴリズムのレジストリが更新された値"
    },
    {
      "indent": 0,
      "text": "7.8. DKIM Service Types Registry",
      "section_title": true,
      "ja": "7.8.  DKIサービスタイプのレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"s=\" <key-s-tag> tag (specified in Section 3.6.1) provides for a list of service types to which this selector may apply.",
      "ja": "（セクション3.6.1で指定された）「S =」<キーSタグ>タグは、このセレクタが適用される先のサービスタイプのリストを提供します。"
    },
    {
      "indent": 3,
      "text": "IANA has established the \"DKIM Service Types\" registry for service types.",
      "ja": "IANAは、サービスタイプのための「DKIMサービスタイプ」レジストリを確立しています。"
    },
    {
      "indent": 19,
      "text": "+-------+-----------------+--------+\n|  TYPE | REFERENCE       | STATUS |\n+-------+-----------------+--------+\n| email | (this document) | active |\n|   *   | (this document) | active |\n+-------+-----------------+--------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Table 8: DKIM Service Types Registry Updated Values",
      "ja": "表8：DKIMサービスタイプレジストリ更新された値"
    },
    {
      "indent": 0,
      "text": "7.9. DKIM Selector Flags Registry",
      "section_title": true,
      "ja": "7.9.  DKIMセレクターフラグレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"t=\" <key-t-tag> tag (specified in Section 3.6.1) provides for a list of flags to modify interpretation of the selector.",
      "ja": "（セクション3.6.1で指定された）「T =」<キー-Tタグ>タグは、セレクタの解釈を変更するフラグのリストを提供します。"
    },
    {
      "indent": 3,
      "text": "IANA has established the \"DKIM Selector Flags\" registry for additional flags.",
      "ja": "IANAは、追加のフラグは、「DKIMセレクターフラグ」レジストリを確立しています。"
    },
    {
      "indent": 20,
      "text": "+------+-----------------+--------+\n| TYPE | REFERENCE       | STATUS |\n+------+-----------------+--------+\n|   y  | (this document) | active |\n|   s  | (this document) | active |\n+------+-----------------+--------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Table 9: DKIM Selector Flags Registry Updated Values",
      "ja": "表9：DKIMセレクターフラグレジストリ更新された値"
    },
    {
      "indent": 0,
      "text": "7.10. DKIM-Signature Header Field",
      "section_title": true,
      "ja": "7.10.  DKI-署名ヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "IANA has added DKIM-Signature to the \"Permanent Message Header Field Names\" registry (see [RFC3864]) for the \"mail\" protocol, using this document as the reference.",
      "ja": "IANAは、参照としてこの文書を使用して、「メール」プロトコルの「永続的メッセージヘッダーフィールド名」レジストリ（[RFC3864]を参照）DKIM-署名を追加しました。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "It has been observed that any introduced mechanism that attempts to stem the flow of spam is subject to intensive attack. DKIM needs to be carefully scrutinized to identify potential attack vectors and the vulnerability to each. See also [RFC4686].",
      "ja": "スパムの流れを食い止めるためにしようとする任意の導入メカニズムは集中的な攻撃の対象となることが観察されています。 DKIMは、慎重に潜在的な攻撃ベクトルとそれぞれに対する脆弱性を識別するために精査する必要があります。また、[RFC4686]を参照してください。"
    },
    {
      "indent": 0,
      "text": "8.1. ASCII Art Attacks",
      "section_title": true,
      "ja": "8.1.  ASCIIアート攻撃"
    },
    {
      "indent": 3,
      "text": "The relaxed body canonicalization algorithm may enable certain types of extremely crude \"ASCII Art\" attacks where a message may be conveyed by adjusting the spacing between words. If this is a concern, the \"simple\" body canonicalization algorithm should be used instead.",
      "ja": "リラックスボディ正規化アルゴリズムは、メッセージは、単語間の間隔を調整することにより搬送することができる極めて粗「ASCIIアート」攻撃の特定の種類のを可能にすることができます。これが懸念される場合は、「シンプル」のボディ正規化アルゴリズムを代わりに使用してください。"
    },
    {
      "indent": 0,
      "text": "8.2. Misuse of Body Length Limits (\"l=\" Tag)",
      "section_title": true,
      "ja": "8.2. ボディの長さ制限の誤用（「L =」タグ）"
    },
    {
      "indent": 3,
      "text": "Use of the \"l=\" tag might allow display of fraudulent content without appropriate warning to end users. The \"l=\" tag is intended for increasing signature robustness when sending to mailing lists that both modify their content and do not sign their modified messages. However, using the \"l=\" tag enables attacks in which an intermediary with malicious intent can modify a message to include content that solely benefits the attacker. It is possible for the appended content to completely replace the original content in the end recipient's eyes and to defeat duplicate message detection algorithms.",
      "ja": "「L =」タグを使用すると、エンドユーザーに適切な警告なしに不正コンテンツの表示を許可することがあります。両方がその内容を変更し、その変更されたメッセージに署名していないメーリングリストに送信するときに、「L =」タグが増加し、署名の堅牢性を対象としています。しかし、「L =」タグを使用すると、悪意を持った仲介が単独で攻撃者に利益をもたらすコンテンツを含むようにメッセージを修正することが可能な攻撃を可能にします。追加コンテンツが完全に終了受信者の目には元のコンテンツを置き換えるために、重複メッセージ検出アルゴリズムを倒すことが可能です。"
    },
    {
      "indent": 3,
      "text": "An example of such an attack includes altering the MIME structure, exploiting lax HTML parsing in the MUA, and defeating duplicate message detection algorithms.",
      "ja": "そのような攻撃の例は、MIME構造を変えるMUAにLAX HTML構文解析を利用し、重複メッセージ検出アルゴリズムを破り含みます。"
    },
    {
      "indent": 3,
      "text": "To avoid this attack, Signers should be extremely wary of using this tag, and Assessors might wish to ignore signatures that use the tag.",
      "ja": "この攻撃を回避するために、署名者は、このタグを使用しての非常に警戒する必要がある、と査定は、タグを使用して署名を無視したいかもしれません。"
    },
    {
      "indent": 0,
      "text": "8.3. Misappropriated Private Key",
      "section_title": true,
      "ja": "8.3. 流用秘密鍵"
    },
    {
      "indent": 3,
      "text": "As with any other security application that uses private- or public-key pairs, DKIM requires caution around the handling and protection of keys. A compromised private key or access to one means an intruder or malware can send mail signed by the domain that advertises the matching public key.",
      "ja": "民間や公開鍵のペアを使用して、他のセキュリティアプリケーションと同じように、DKIMは、キーの取り扱いと保護の周りには注意が必要です。 1に感染した秘密鍵またはアクセスが侵入者やマルウェアが一致する公開鍵をアドバタイズドメインによって署名されたメールを送信できることを意味します。"
    },
    {
      "indent": 3,
      "text": "Thus, private keys issued to users, rather than one used by an ADministrative Management Domain (ADMD) itself, create the usual problem of securing data stored on personal resources that can affect the ADMD.",
      "ja": "したがって、ユーザーではなく、行政管理ドメイン（ADMD）自体で使用されるものに発行された秘密鍵は、ADMDに影響を与えることができます個人的なリソースに格納されたデータを保護する通常の問題を作成します。"
    },
    {
      "indent": 3,
      "text": "A more secure architecture involves sending messages through an outgoing MTA that can authenticate the submitter using existing techniques (e.g., SMTP Authentication), possibly validate the message itself (e.g., verify that the header is legitimate and that the content passes a spam content check), and sign the message using a key appropriate for the submitter address. Such an MTA can also apply controls on the volume of outgoing mail each user is permitted to originate in order to further limit the ability of malware to generate bulk email.",
      "ja": "より安全なアーキテクチャは、既存の技術を使用して提出者（例えば、SMTP認証）、おそらくはメッセージ自体を検証を認証することができる送信MTAを介してメッセージを送信することを含む（例えば、ヘッダが正当であることを確認し、コンテンツがスパム・コンテンツ・チェックを通過すること） 、および提出者のアドレスのためのキーを使用して適切なメッセージに署名。そのようなMTAは、各ユーザは、さらに大量のメールを生成するマルウェアの能力を制限するために発信することを許可された送信メールのボリューム上のコントロールを適用することができます。"
    },
    {
      "indent": 0,
      "text": "8.4. Key Server Denial-of-Service Attacks",
      "section_title": true,
      "ja": "8.4. 鍵サーバサービス拒否攻撃"
    },
    {
      "indent": 3,
      "text": "Since the key servers are distributed (potentially separate for each domain), the number of servers that would need to be attacked to defeat this mechanism on an Internet-wide basis is very large. Nevertheless, key servers for individual domains could be attacked, impeding the verification of messages from that domain. This is not significantly different from the ability of an attacker to deny service to the mail exchangers for a given domain, although it affects outgoing, not incoming, mail.",
      "ja": "キーサーバが分散しているので、（潜在的にドメインごとに分ける）、インターネット全体でこのメカニズムを倒すために攻撃する必要があるであろうサーバの数は非常に多いです。それにもかかわらず、個々のドメインのための鍵サーバは、そのドメインからのメッセージの検証を妨げ、攻撃される可能性があります。それは、発信、受信していない、メールに影響を与えますが、これは、特定のドメインのメール交換機へのサービスを拒否する攻撃者の能力とは大きく異なるものではありません。"
    },
    {
      "indent": 3,
      "text": "A variation on this attack involves a very large amount of mail being sent using spoofed signatures from a given domain: the key servers for that domain could be overwhelmed with requests in a denial-of- service attack (see [RFC4732]). However, given the low overhead of verification compared with handling of the email message itself, such an attack would be difficult to mount.",
      "ja": "そのドメインのキーサーバーは、サービス拒否攻撃でリクエストを圧倒することができた（[RFC4732]を参照）：この攻撃のバリエーションは、特定のドメインからの偽装された署名を使用して送信されたメールの非常に大規模な量を必要とします。ただし、電子メールメッセージ自体の処理と比較して検証の低いオーバーヘッドを考えると、このような攻撃は、マウントすることは困難であろう。"
    },
    {
      "indent": 0,
      "text": "8.5. Attacks against the DNS",
      "section_title": true,
      "ja": "8.5.  DNSに対する攻撃"
    },
    {
      "indent": 3,
      "text": "Since the DNS is a required binding for key services, specific attacks against the DNS must be considered.",
      "ja": "DNSは、必要なキーのサービスにバインドされているので、DNSに対する特定の攻撃を考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "While the DNS is currently insecure [RFC3833], these security problems are the motivation behind DNS Security (DNSSEC) [RFC4033], and all users of the DNS will reap the benefit of that work.",
      "ja": "DNSは現在、安全でない[RFC3833]ですが、これらのセキュリティ上の問題は、DNSセキュリティ（DNSSEC）[RFC4033]の背後にある動機であり、DNSのすべてのユーザーがその仕事の恩恵を享受します。"
    },
    {
      "indent": 3,
      "text": "DKIM is only intended as a \"sufficient\" method of proving authenticity. It is not intended to provide strong cryptographic proof about authorship or contents. Other technologies such as OpenPGP [RFC4880] and S/MIME [RFC5751] address those requirements.",
      "ja": "DKIMは、唯一の信憑性を証明する「十分な」方法として意図されています。著作者や内容についての強力な暗号証拠を提供するものではありません。このようなのOpenPGP [RFC4880]及びS / MIME [RFC5751]などの他の技術は、これらの要件に対処します。"
    },
    {
      "indent": 3,
      "text": "A second security issue related to the DNS revolves around the increased DNS traffic as a consequence of fetching selector-based data as well as fetching signing domain policy. Widespread deployment of DKIM will result in a significant increase in DNS queries to the claimed signing domain. In the case of forgeries on a large scale, DNS servers could see a substantial increase in queries.",
      "ja": "DNSに関連する第2のセキュリティ問題は、セレクタベースのデータを取得するだけでなく、署名ドメインポリシーをフェッチの結果として増加したDNSトラフィックを中心に展開します。 DKIMの広範な展開が主張署名ドメインにDNSクエリの大幅な増加をもたらすでしょう。大規模な偽造の場合は、DNSサーバはクエリの大幅な増加を見ることができました。"
    },
    {
      "indent": 3,
      "text": "A specific DNS security issue that should be considered by DKIM Verifiers is the name chaining attack described in Section 2.3 of [RFC3833]. A DKIM Verifier, while verifying a DKIM-Signature header field, could be prompted to retrieve a key record of an attacker's choosing. This threat can be minimized by ensuring that name servers, including recursive name servers, used by the Verifier enforce strict checking of \"glue\" and other additional information in DNS responses and are therefore not vulnerable to this attack.",
      "ja": "DKIM検証者によって考慮されるべき特定のDNSセキュリティ問題は[RFC3833]のセクション2.3で説明した名前の連鎖攻撃です。 DKIM検証は、DKIM-Signatureヘッダーフィールドを確認しながら、攻撃者の選択したキーレコードを取得するように指示することができます。この脅威は、検証が使用する再帰ネームサーバなどのネームサーバは、DNS応答の「のり」やその他の付加情報の厳密なチェックを強制するため、この攻撃に対して脆弱ではないことを保証することにより最小限に抑えることができます。"
    },
    {
      "indent": 0,
      "text": "8.6. Replay/Spam Attacks",
      "section_title": true,
      "ja": "8.6. リプレイ/スパム攻撃"
    },
    {
      "indent": 3,
      "text": "In this attack, a spammer sends a piece of spam through an MTA that signs it, banking on the reputation of the signing domain (e.g., a large popular mailbox provider) rather than its own, and then re-sends that message to a large number of intended recipients. The recipients observe the valid signature from the well-known domain, elevating their trust in the message and increasing the likelihood of delivery and presentation to the user.",
      "ja": "この攻撃では、スパマーはむしろ自社以外の署名ドメイン（例えば、大規模な人気のあるメールボックスプロバイダ）の評判で、銀行をそれに署名するMTA経由のスパムの作品を送り、その後、大にそのメッセージを再送信します意図した受信者の数。受信者はメッセージで彼らの信頼を昇降し、ユーザへの配信やプレゼンテーションの可能性が高く、よく知られているドメインから有効な署名を観察します。"
    },
    {
      "indent": 3,
      "text": "Partial solutions to this problem involve the use of reputation services to convey the fact that the specific email address is being used for spam and that messages from that Signer are likely to be spam. This requires a real-time detection mechanism in order to react quickly enough. However, such measures might be prone to abuse, if, for example, an attacker re-sent a large number of messages received from a victim in order to make the victim appear to be a spammer.",
      "ja": "この問題に対する部分的な解決策は、特定のメールアドレスはスパムのために、その署名者からのメッセージがスパムである可能性があることを使用されているという事実を伝えるためにレピュテーションサービスの使用を含みます。これは十分にすぐに反応するために、リアルタイム検出メカニズムが必要です。例えば、攻撃者が被害者を作るために、被害者から受信したメッセージの数が多いを再送信しスパマーのように見える、しかし、もし、そのような措置は、虐待を受けやすいかもしれません。"
    },
    {
      "indent": 3,
      "text": "Large Verifiers might be able to detect unusually large volumes of mails with the same signature in a short time period. Smaller Verifiers can get substantially the same volume of information via existing collaborative systems.",
      "ja": "大規模な検証者は、短時間で同じシグネチャを持つメールの非常に大きな容量を検出することができるかもしれません。小さい検証者は、既存の共同のシステムを経由して、実質的に同じ情報量を得ることができます。"
    },
    {
      "indent": 0,
      "text": "8.7. Limits on Revoking Keys",
      "section_title": true,
      "ja": "8.7. 取り消しキーの制限"
    },
    {
      "indent": 3,
      "text": "When a large domain detects undesirable behavior on the part of one of its users, it might wish to revoke the key used to sign that user's messages in order to disavow responsibility for messages that have not yet been verified or that are the subject of a replay attack. However, the ability of the domain to do so can be limited if the same key, for scalability reasons, is used to sign messages for many other users. Mechanisms for explicitly revoking keys on a per-address basis have been proposed but require further study as to their utility and the DNS load they represent.",
      "ja": "大規模なドメインは、そのユーザーの1の部分に望ましくない動作を検出すると、それはまだ確認されていないか、再生の対象であるというメッセージの責任を否認するために、そのユーザーのメッセージに署名するために使用されるキーを無効にしたいかもしれません攻撃。スケーラビリティ上の理由から、同じキーは、他の多くのユーザーのためのメッセージに署名するために使用されている場合しかし、そうするドメインの能力を制限することができます。明示的にアドレス毎のベースでキーを取り消すためのメカニズムが提案されているが、その有用性とそれが表すDNS負荷に、さらなる研究が必要とされています。"
    },
    {
      "indent": 0,
      "text": "8.8. Intentionally Malformed Key Records",
      "section_title": true,
      "ja": "8.8. 意図的に不正な形式のキーレコード"
    },
    {
      "indent": 3,
      "text": "It is possible for an attacker to publish key records in DNS that are intentionally malformed, with the intent of causing a denial-of-service attack on a non-robust Verifier implementation. The attacker could then cause a Verifier to read the malformed key record by sending a message to one of its users referencing the malformed record in a (not necessarily valid) signature. Verifiers MUST thoroughly verify all key records retrieved from the DNS and be robust against intentionally as well as unintentionally malformed key records.",
      "ja": "攻撃者は非堅固な検証の実装にサービス拒否攻撃の原因となることを意図して、意図的に不正な形式のあるDNSにキーレコードを公開することが可能です。その後、攻撃者は（必ずしも有効ではありません）署名で不正な形式のレコードを参照し、そのユーザの一人にメッセージを送信することにより、不正な形式の鍵レコードを読み取るために検証を引き起こす可能性があります。検証者は徹底的にDNSから取得し、すべてのキーレコードを確認し、意図的にだけでなく、意図せず、不正なキーレコードに対して堅牢でなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.9. Intentionally Malformed DKIM-Signature Header Fields",
      "section_title": true,
      "ja": "8.9. 意図的に不正な形式のDKIM-Signatureヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "Verifiers MUST be prepared to receive messages with malformed DKIM-Signature header fields and thoroughly verify the header field before depending on any of its contents.",
      "ja": "検証者は、不正な形式のDKIM-Signatureヘッダーフィールドを持つメッセージを受信し、徹底的にその内容の任意に応じて前にヘッダーフィールドを検証する準備をしなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.10. Information Leakage",
      "section_title": true,
      "ja": "8.10. 情報漏えい"
    },
    {
      "indent": 3,
      "text": "An attacker could determine when a particular signature was verified by using a per-message selector and then monitoring their DNS traffic for the key lookup. This would act as the equivalent of a \"web bug\" for verification time rather than the time the message was read.",
      "ja": "特定の署名がメッセージごとのセレクタを使用し、キーのルックアップのために彼らのDNSトラフィックを監視することによって確認された場合、攻撃者が決定することができます。これは、検証時間ではなく、メッセージが読まれた時間のための「ウェブバグ」と同等として作用します。"
    },
    {
      "indent": 0,
      "text": "8.11. Remote Timing Attacks",
      "section_title": true,
      "ja": "8.11. リモートタイミング攻撃"
    },
    {
      "indent": 3,
      "text": "In some cases, it may be possible to extract private keys using a remote timing attack [BONEH03]. Implementations should consider obfuscating the timing to prevent such attacks.",
      "ja": "場合によっては、リモートタイミング攻撃[BONEH03]を使用して秘密鍵を抽出することが可能であってもよいです。実装は、このような攻撃を防ぐために、タイミングを難読化を検討すべきです。"
    },
    {
      "indent": 0,
      "text": "8.12. Reordered Header Fields",
      "section_title": true,
      "ja": "8.12. 並べ替えヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "Existing standards allow intermediate MTAs to reorder header fields. If a Signer signs two or more header fields of the same name, this can cause spurious verification errors on otherwise legitimate messages. In particular, Signers that sign any existing DKIM-Signature fields run the risk of having messages incorrectly fail to verify.",
      "ja": "既存の規格は、中間MTAがヘッダーフィールドの順序を変更することを可能にします。署名者は、同じ名前の2つの以上のヘッダーフィールドに署名した場合、これはそうでない場合は正当なメッセージに偽の検証エラーが発生する可能性があります。具体的には、既存のDKIM署名フィールドに署名署名者が正しく検証に失敗したメッセージを持つことのリスクを実行します。"
    },
    {
      "indent": 0,
      "text": "8.13. RSA Attacks",
      "section_title": true,
      "ja": "8.13.  RSA攻撃"
    },
    {
      "indent": 3,
      "text": "An attacker could create a large RSA signing key with a small exponent, thus requiring that the verification key have a large exponent. This will force Verifiers to use considerable computing resources to verify the signature. Verifiers might avoid this attack by refusing to verify signatures that reference selectors with public keys having unreasonable exponents.",
      "ja": "攻撃者は、このように検証鍵が大きな指数を持っていることを必要とし、小さな指数で大きなRSA署名キーを作成することができます。これは、署名を検証するために、かなりのコンピューティングリソースを使用するために検証者に強制します。検証者は、公開鍵が不合理指数を持つセレクタを参照する署名を検証することを拒否することによって、この攻撃を避けるかもしれません。"
    },
    {
      "indent": 3,
      "text": "In general, an attacker might try to overwhelm a Verifier by flooding it with messages requiring verification. This is similar to other MTA denial-of-service attacks and should be dealt with in a similar fashion.",
      "ja": "一般的には、攻撃者が検証を必要とするメッセージとそれをあふれさせることにより、検証を圧倒しようとします。これは、他のMTAサービス拒否攻撃に似ており、同様の方法で対処しなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.14. Inappropriate Signing by Parent Domains",
      "section_title": true,
      "ja": "8.14. 親ドメインによって不適切な署名"
    },
    {
      "indent": 3,
      "text": "The trust relationship described in Section 3.10 could conceivably be used by a parent domain to sign messages with identities in a subdomain not administratively related to the parent. For example, the \".com\" registry could create messages with signatures using an \"i=\" value in the example.com domain. There is no general solution to this problem, since the administrative cut could occur anywhere in the domain name. For example, in the domain \"example.podunk.ca.us\", there are three administrative cuts (podunk.ca.us, ca.us, and us), any of which could create messages with an identity in the full domain.",
      "ja": "3.10節で説明した信頼関係が考えられる管理上の親に関連していないサブドメインでアイデンティティを持つメッセージに署名するために親ドメインで使用することができます。たとえば、「.COM」のレジストリは、example.comドメインで 『私は=』値を使用して署名付きのメッセージを作成することができます。行政カットは、ドメイン名のどこにでも起こる可能性があるので、この問題に対する一般的な解決策はありません。たとえば、ドメイン「example.podunk.ca.us」で、完全なドメインのIDを持つメッセージを作成することができます任意のうち3つの行政カット（podunk.ca.us、ca.us、と私たちは）、があります。"
    },
    {
      "indent": 6,
      "text": "INFORMATIVE NOTE: This is considered an acceptable risk for the same reason that it is acceptable for domain delegation. For example, in the case above, any of the domains could potentially simply delegate \"example.podunk.ca.us\" to a server of their choice and completely replace all DNS-served information. Note that a Verifier MAY ignore signatures that come from an unlikely domain such as \".com\", as discussed in Section 6.1.1.",
      "ja": "有益な注意：これは、ドメイン委任のために許容されているのと同じ理由で許容できるリスクと考えられています。例えば、上記の場合には、ドメインのいずれかは、潜在的に、単純に自分の好きなサーバーに「example.podunk.ca.us」を委任し、完全にすべてのDNS-務め情報を置き換えることができます。 6.1.1項で述べたように検証は、こうした「.COM」としてそうドメインから来た署名を無視するかもしれないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "8.15. Attacks Involving Extra Header Fields",
      "section_title": true,
      "ja": "8.15. 余分なヘッダフィールドを伴う攻撃"
    },
    {
      "indent": 3,
      "text": "Many email components, including MTAs, MSAs, MUAs, and filtering modules, implement message format checks only loosely. This is done out of years of industry pressure to be liberal in what is accepted into the mail stream for the sake of reducing support costs; improperly formed messages are often silently fixed in transit, delivered unrepaired, or displayed inappropriately (e.g., by showing only the first of multiple From: fields).",
      "ja": "MTAは、のMSA、のMUA、およびフィルタリングモジュールを含む多くの電子メール・コンポーネントは、唯一緩くメッセージフォーマットチェックを実施します。これは、サポートコストを削減するために、メールストリームに受け入れられているものでリベラルであることを、業界の圧力の年の外に行われます。不適切に形成されたメッセージは、多くの場合、静かに（：フィールドから複数の最初を示すことによって、例えば）、輸送中に固定された未修復送達、または不適切に表示されています。"
    },
    {
      "indent": 3,
      "text": "Agents that evaluate or apply DKIM output need to be aware that a DKIM Signer can sign messages that are malformed (e.g., violate [RFC5322], such as by having multiple instances of a field that is only permitted once), that become malformed in transit, or that contain header or body content that is not true or valid. Use of DKIM on such messages might constitute an attack against a receiver, especially where additional credence is given to a signed message without adequate evaluation of the Signer.",
      "ja": "評価やDKIMの出力を適用するエージェントは、DKIM署名者は、輸送中の不正な形式になって、（一回のみ許可されているフィールドの複数のインスタンスを持つことなど、例えば、違反[RFC5322]、）不正な形式のあるメッセージに署名できることに注意する必要があります、またはそのヘッダやtrueまたは無効な本文の内容が含まれています。そのようなメッセージにDKIMの使用は、付加的な信用が署名者の十分な評価なしに署名されたメッセージに与えられ、特に受信機に対する攻撃を構成するかもしれません。"
    },
    {
      "indent": 3,
      "text": "These can represent serious attacks, but they have nothing to do with DKIM; they are attacks on the recipient or on the wrongly identified author.",
      "ja": "これらは深刻な攻撃を表すことができますが、彼らはDKIMとは何の関係もありません。彼らは、受信者にまたは誤って識別作者への攻撃です。"
    },
    {
      "indent": 3,
      "text": "Moreover, an agent would be incorrect to infer that all instances of a header field are signed just because one is.",
      "ja": "また、エージェントは、ヘッダフィールドのすべてのインスタンスが1であるという理由だけで署名されていることを推測するために間違ったであろう。"
    },
    {
      "indent": 3,
      "text": "A genuine signature from the domain under attack can be obtained by legitimate means, but extra header fields can then be added, either by interception or by replay. In this scenario, DKIM can aid in detecting addition of specific fields in transit. This is done by having the Signer list the field name(s) in the \"h=\" tag an extra time (e.g., \"h=from:from:...\" for a message with one From field), so that addition of an instance of that field downstream will render the signature unable to be verified. (See Section 3.5 for details.) This, in essence, is an explicit indication that the Signer repudiates responsibility for such a malformed message.",
      "ja": "傍受によって、または再生のいずれかによって、攻撃を受けドメインから本物の署名が正当な手段によって得ることができるが、余分なヘッダフィールドを添加することができます。このシナリオでは、DKIMは、輸送中の特定のフィールドの追加を検出するのに役立つことができます。これは、署名者が「H =」タグの余分な時間にフィールド名（複数可）をリストすることによって行われている（例えば、「H =から：から：...」Fromフィールド1のメッセージのため）、また、そのようそのフィールドのインスタンスの下流に検証することができない署名をレンダリングします。 （詳細はセクション3.5を参照してください。）これは、本質的には、署名者は、このような不正な形式のメッセージに対する責任をrepudiatesことを明示です。"
    },
    {
      "indent": 3,
      "text": "DKIM signs and validates the data it is told to and works correctly. So in this case, DKIM has done its job of delivering a validated domain (the \"d=\" value) and, given the semantics of a DKIM signature, essentially the Signer has taken some responsibility for a problematic message. It is up to the Identity Assessor or some other subsequent agent to act on such messages as needed, such as degrading the trust of the message (or, indeed, of the Signer), warning the recipient, or even refusing delivery.",
      "ja": "DKIMの兆候とは、それが語られたデータを検証し、正常に動作します。したがって、この場合には、DKIMは、DKIM署名の意味論所与検証ドメイン（「D =」値）とを、送達のその仕事をしている、実質的に署名者は、問題のメッセージのためのいくつかの責任を取りました。それは、このような受信者、あるいは拒否配信を警告し、（署名者の実際や、）メッセージの信頼を低下させるよう、必要に応じてこのようなメッセージに作用する身元評価またはいくつかの他の後続薬までです。"
    },
    {
      "indent": 3,
      "text": "All components of the mail system that perform loose enforcement of other mail standards will need to revisit that posture when incorporating DKIM, especially when considering matters of potential attacks such as those described.",
      "ja": "DKIMを組み込む際に、他のメールの標準の緩い執行を行い、メールシステムのすべてのコンポーネントは、記載されたもののような潜在的な攻撃の事項を考慮する場合は特に、その姿勢を再訪する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[FIPS-180-3-2008] U.S. Department of Commerce, \"Secure Hash Standard\", FIPS PUB 180-3, October 2008.",
      "ja": "[FIPS-180-3-2008]米国商務省が、2008年10月、FIPS PUB 180-3の \"ハッシュ標準セキュア\"。"
    },
    {
      "indent": 3,
      "text": "[ITU-X660-1997] \"Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", 1997.",
      "ja": "[ITU-X660-1997 \"情報技術 -  ASN.1符号化ルール：基本符号化規則（BER）、Canonicalの符号化規則（CER）と識別符号化規則（DER）の仕様\"、1997。"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain names - concepts and facilities\", STD 13, RFC 1034, November 1987.",
      "ja": "[RFC1034] Mockapetris、P.、 \"ドメイン名 - 概念と設備\"、STD 13、RFC 1034、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2045] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", RFC 2045, November 1996.",
      "ja": "[RFC2045]解放され、N.とN. Borenstein、 \"マルチパーパスインターネットメールエクステンション（MIME）第一部：インターネットメッセージ本体のフォーマット\"、RFC 2045、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2049] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples\", RFC 2049, November 1996.",
      "ja": "[RFC2049]フリード、N.とN. Borenstein、 \"マルチパーパスインターネットメールエクステンション（MIME）パート5：適合基準と例\"、RFC 2049、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003.",
      "ja": "[RFC3447]ジョンソン、J.とB. Kaliski、 \"公開鍵暗号規格（PKCS）＃1：RSA暗号仕様バージョン2.1\"、RFC 3447、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5321] Klensin, J., \"Simple Mail Transfer Protocol\", RFC 5321, October 2008.",
      "ja": "[RFC5321] Klensin、J.、 \"簡易メール転送プロトコル\"、RFC 5321、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5322] Resnick, P., Ed., \"Internet Message Format\", RFC 5322, October 2008.",
      "ja": "[RFC5322]レズニック、P.、エド。、 \"インターネットメッセージ形式\"、RFC 5322、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5598] Crocker, D., \"Internet Mail Architecture\", RFC 5598, July 2009.",
      "ja": "[RFC5598]クロッカー、D.、 \"インターネットメールのアーキテクチャ\"、RFC 5598、2009年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC5890] Klensin, J., \"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework\", RFC 5890, August 2010.",
      "ja": "[RFC5890] Klensin、J.、 \"アプリケーション（IDNA）のための国際化ドメイン名：定義とドキュメントフレームワーク\"、RFC 5890、2010年8月。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[BONEH03] \"Remote Timing Attacks are Practical\", Proceedings 12th USENIX Security Symposium, 2003.",
      "ja": "[BONEH03]議事録第12回USENIXセキュリティシンポジウム、2003年には、「リモートタイミング攻撃が実用的です」。"
    },
    {
      "indent": 3,
      "text": "[RFC2047] Moore, K., \"MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text\", RFC 2047, November 1996.",
      "ja": "[RFC2047]ムーア、K.、 \"MIME（多目的インターネットメール拡張）パート3：非ASCIIテキストのためのメッセージヘッダの拡張\"、RFC 2047、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3766] Orman, H. and P. Hoffman, \"Determining Strengths For Public Keys Used For Exchanging Symmetric Keys\", BCP 86, RFC 3766, April 2004.",
      "ja": "[RFC3766]オーマン、H.、およびP.ホフマン、 \"対称鍵を交換するために使用公開鍵の強さを測定\"、BCP 86、RFC 3766、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3833] Atkins, D. and R. Austein, \"Threat Analysis of the Domain Name System (DNS)\", RFC 3833, August 2004.",
      "ja": "[RFC3833]アトキンス、D.とR. Austeinと、RFC 3833 \"ドメインネームシステム（DNS）の脅威分析\"、2004年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3864] Klyne, G., Nottingham, M., and J. Mogul, \"Registration Procedures for Message Header Fields\", BCP 90, RFC 3864, September 2004.",
      "ja": "[RFC3864] Klyne、G.、ノッティンガム、M.、およびJ.モーグル、BCP 90、RFC 3864、2004年9月 \"メッセージヘッダフィールドの登録手順\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4033] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"DNS Security Introduction and Requirements\", RFC 4033, March 2005.",
      "ja": "[RFC4033]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 \"DNSセキュリティ序論と要件\"、RFC 4033、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4409] Gellens, R. and J. Klensin, \"Message Submission for Mail\", RFC 4409, April 2006.",
      "ja": "[RFC4409] Gellens、R.とJ. Klensin、 \"メールのメッセージの提出\"、RFC 4409、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4686] Fenton, J., \"Analysis of Threats Motivating DomainKeys Identified Mail (DKIM)\", RFC 4686, September 2006.",
      "ja": "[RFC4686]フェントン、J.、 \"メール（DKIM）を同定DomainKeysのをやる気脅威の分析\"、RFC 4686、2006年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4732] Handley, M., Rescorla, E., and IAB, \"Internet Denial-of-Service Considerations\", RFC 4732, December 2006.",
      "ja": "[RFC4732]ハンドリー、M.、レスコラ、E.、およびIAB、 \"インターネットサービス拒否の注意事項\"、RFC 4732、2006年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4870] Delany, M., \"Domain-Based Email Authentication Using Public Keys Advertised in the DNS (DomainKeys)\", RFC 4870, May 2007.",
      "ja": "[RFC4870]デラニー、M.、 \"DNS（ドメインキー）で公開鍵アドバタイズを使用したドメインベースの電子メール認証\"、RFC 4870、2007年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4871] Allman, E., Callas, J., Delany, M., Libbey, M., Fenton, J., and M. Thomas, \"DomainKeys Identified Mail (DKIM) Signatures\", RFC 4871, May 2007.",
      "ja": "[RFC4871]オールマン、E.、カラス、J.、デラニー、M.、リビー、M.、フェントン、J.、およびM.トーマス、 \"ドメインキーを識別メール（DKIM）署名\"、RFC 4871、2007年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4880] Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, \"OpenPGP Message Format\", RFC 4880, November 2007.",
      "ja": "[RFC4880]カラス、J.、Donnerhacke、L.、フィニー、H.、ショー、D.、およびR.セイヤー、 \"OpenPGPのメッセージフォーマット\"、RFC 4880、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5451] Kucherawy, M., \"Message Header Field for Indicating Message Authentication Status\", RFC 5451, April 2009.",
      "ja": "[RFC5451] Kucherawy、M.、 \"メッセージヘッダーフィールドのメッセージ認証ステータスを示すため\"、RFC 5451、2009年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5585] Hansen, T., Crocker, D., and P. Hallam-Baker, \"DomainKeys Identified Mail (DKIM) Service Overview\", RFC 5585, July 2009.",
      "ja": "[RFC5585]ハンセン、T.、クロッカー、D.、およびP.ハラム - ベイカー、RFC 5585の \"メール（DKIM）サービスの概要を特定されたのDomainKeys\"、2009年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC5672] Crocker, D., \"RFC 4871 DomainKeys Identified Mail (DKIM) Signatures -- Update\", RFC 5672, August 2009.",
      "ja": "[RFC5672]クロッカー、D.、 \"RFC 4871ドメインキー・アイデンティファイド・メール（DKIM）署名 - アップデート\"、RFC 5672、2009年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5751] Ramsdell, B. and S. Turner, \"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification\", RFC 5751, January 2010.",
      "ja": "[RFC5751] Ramsdell、B.、およびS.ターナー、 \"/セキュア多目的インターネットメール拡張（S / MIME）バージョン3.2メッセージ仕様\"、RFC 5751、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5863] Hansen, T., Siegel, E., Hallam-Baker, P., and D. Crocker, \"DomainKeys Identified Mail (DKIM) Development, Deployment, and Operations\", RFC 5863, May 2010.",
      "ja": "[RFC5863]ハンセン、T.、シーゲル、E.、ハラム・ベイカー、P.、およびD.クロッカー、 \"ドメインキー・アイデンティファイド・メール（DKIM）の開発、展開、および運用\"、RFC 5863、2010年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC6377] Kucherawy, M., \"DomainKeys Identified Mail (DKIM) and Mailing Lists\", RFC 6377, September 2011.",
      "ja": "[RFC6377] Kucherawy、M.、 \"ドメインキー・アイデンティファイド・メール（DKIM）とメーリングリスト\"、RFC 6377、2011年9月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Example of Use (INFORMATIVE)",
      "ja": "使用の付録A.例（参考）"
    },
    {
      "indent": 3,
      "text": "This section shows the complete flow of an email from submission to final delivery, demonstrating how the various components fit together. The key used in this example is shown in Appendix C.",
      "ja": "このセクションでは、さまざまなコンポーネントを組み合わせる方法を示す、最終的な配送への提出からの電子メールの完全な流れを示しています。この例で使用されるキーは、付録Cに示されています"
    },
    {
      "indent": 0,
      "text": "A.1. The User Composes an Email",
      "ja": "A.1。ユーザーは、Eメールを作成し"
    },
    {
      "indent": 3,
      "text": "From: Joe SixPack <joe@football.example.com> To: Suzie Q <suzie@shopping.example.net> Subject: Is dinner ready? Date: Fri, 11 Jul 2003 21:00:37 -0700 (PDT) Message-ID: <20030712040037.46341.5F8J@football.example.com>",
      "ja": "投稿者：ジョーアメリカ人男性<joe@football.example.com>宛先：スージーQ <suzie@shopping.example.net>件名：夕食の準備ができていますか？日付：金、2003年7月11日21時00分37秒-0700（PDT）のMessage-ID：<20030712040037.46341.5F8J@football.example.com>"
    },
    {
      "indent": 3,
      "text": "Hi.",
      "ja": "日。"
    },
    {
      "indent": 3,
      "text": "We lost the game. Are you hungry yet?",
      "ja": "私たちは試合に負けました。あなたはまだ飢えていますか？"
    },
    {
      "indent": 3,
      "text": "Joe.",
      "ja": "ジョー。"
    },
    {
      "indent": 19,
      "text": "Figure 1: The User Composes an Email",
      "ja": "図1：ユーザーがEメールを作成し"
    },
    {
      "indent": 0,
      "text": "A.2. The Email is Signed",
      "ja": "A.2。メールが署名され"
    },
    {
      "indent": 3,
      "text": "This email is signed by the example.com outbound email server and now looks like this:",
      "ja": "このメールは、example.comのアウトバウンド電子メールサーバーによって署名され、現在は以下のように見えます。"
    },
    {
      "indent": 3,
      "text": "DKIM-Signature: v=1; a=rsa-sha256; s=brisbane; d=example.com;\n     c=simple/simple; q=dns/txt; i=joe@football.example.com;\n     h=Received : From : To : Subject : Date : Message-ID;\n     bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=;\n     b=AuUoFEfDxTDkHlLXSZEpZj79LICEps6eda7W3deTVFOk4yAUoqOB\n     4nujc7YopdG5dWLSdNg6xNAZpOPr+kHxt1IrE+NahM6L/LbvaHut\n     KVdkLLkpVaVVQPzeRDI009SO2Il5Lu7rDNH6mZckBdrIx0orEtZV\n     4bmp/YzhwvcubU4=;\nReceived: from client1.football.example.com  [192.0.2.1]\n     by submitserver.example.com with SUBMISSION;\n     Fri, 11 Jul 2003 21:01:54 -0700 (PDT)\nFrom: Joe SixPack <joe@football.example.com>\nTo: Suzie Q <suzie@shopping.example.net>\nSubject: Is dinner ready?\nDate: Fri, 11 Jul 2003 21:00:37 -0700 (PDT)\nMessage-ID: <20030712040037.46341.5F8J@football.example.com>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Hi.",
      "ja": "日。"
    },
    {
      "indent": 3,
      "text": "We lost the game. Are you hungry yet?",
      "ja": "私たちは試合に負けました。あなたはまだ飢えていますか？"
    },
    {
      "indent": 3,
      "text": "Joe.",
      "ja": "ジョー。"
    },
    {
      "indent": 23,
      "text": "Figure 2: The Email is Signed",
      "ja": "図2：電子メールが署名されています"
    },
    {
      "indent": 3,
      "text": "The signing email server requires access to the private key associated with the \"brisbane\" selector to generate this signature.",
      "ja": "署名電子メールサーバは、この署名を生成するために、「ブリスベン」セレクタに関連付けられた秘密鍵にアクセスする必要があります。"
    },
    {
      "indent": 0,
      "text": "A.3. The Email Signature is Verified",
      "ja": "A.3。メールの署名が検証されます"
    },
    {
      "indent": 3,
      "text": "The signature is normally verified by an inbound SMTP server or possibly the final delivery agent. However, intervening MTAs can also perform this verification if they choose to do so. The verification process uses the domain \"example.com\" extracted from the \"d=\" tag and the selector \"brisbane\" from the \"s=\" tag in the DKIM-Signature header field to form the DNS DKIM query for: brisbane._domainkey.example.com",
      "ja": "署名は、通常、受信SMTPサーバーまたは恐らく最終的な配信エージェントによって検証されます。彼らがそうすることを選択した場合は、その間のMTAはまた、この検証を行うことができます。検証プロセスは、のDNS DKIMクエリを形成するDKIM署名ヘッダフィールドに「D =」タグとからセレクタ「ブリスベン」から抽出されたドメイン「example.com」「S =」タグを使用する：brisbane._domainkeyを.example.comと"
    },
    {
      "indent": 3,
      "text": "Signature verification starts with the physically last Received header field, the From header field, and so forth, in the order listed in the \"h=\" tag. Verification follows with a single CRLF followed by the body (starting with \"Hi.\"). The email is canonically prepared for verifying with the \"simple\" method. The result of the query and subsequent verification of the signature is stored (in this example) in the X-Authentication-Results header field line. After successful verification, the email looks like this:",
      "ja": "署名検証が「H =」タグに記載されているために、等のヘッダフィールドから、物理的に最後に受信したヘッダフィールドで始まり、そして。検証は（で始まる「こんにちは。」）身体に続いて、単一のCRLFと続きます。電子メールは、「簡単な」方法で検証する正準用意があります。クエリと署名のその後の検証の結果は、X-認証-結果ヘッダーフィールド線に（この例で）格納されます。検証が成功した後、電子メールは次のようになります。"
    },
    {
      "indent": 3,
      "text": "X-Authentication-Results: shopping.example.net\n  header.from=joe@football.example.com; dkim=pass\nReceived: from mout23.football.example.com (192.168.1.1)\n  by shopping.example.net with SMTP;\n  Fri, 11 Jul 2003 21:01:59 -0700 (PDT)\nDKIM-Signature: v=1; a=rsa-sha256; s=brisbane; d=example.com;\n  c=simple/simple; q=dns/txt; i=joe@football.example.com;\n  h=Received : From : To : Subject : Date : Message-ID;\n  bh=2jUSOH9NhtVGCQWNr9BrIAPreKQjO6Sn7XIkfJVOzv8=;\n  b=AuUoFEfDxTDkHlLXSZEpZj79LICEps6eda7W3deTVFOk4yAUoqOB\n    4nujc7YopdG5dWLSdNg6xNAZpOPr+kHxt1IrE+NahM6L/LbvaHut\n    KVdkLLkpVaVVQPzeRDI009SO2Il5Lu7rDNH6mZckBdrIx0orEtZV\n    4bmp/YzhwvcubU4=;\nReceived: from client1.football.example.com  [192.0.2.1]\n  by submitserver.example.com with SUBMISSION;\n  Fri, 11 Jul 2003 21:01:54 -0700 (PDT)\nFrom: Joe SixPack <joe@football.example.com>\nTo: Suzie Q <suzie@shopping.example.net>\nSubject: Is dinner ready?\nDate: Fri, 11 Jul 2003 21:00:37 -0700 (PDT)\nMessage-ID: <20030712040037.46341.5F8J@football.example.com>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Hi.",
      "ja": "日。"
    },
    {
      "indent": 3,
      "text": "We lost the game. Are you hungry yet?",
      "ja": "私たちは試合に負けました。あなたはまだ飢えていますか？"
    },
    {
      "indent": 3,
      "text": "Joe.",
      "ja": "ジョー。"
    },
    {
      "indent": 21,
      "text": "Figure 3: Successful Verification",
      "ja": "図3：成功の検証"
    },
    {
      "indent": 0,
      "text": "Appendix B. Usage Examples (INFORMATIVE)",
      "ja": "付録B.使用例（参考）"
    },
    {
      "indent": 3,
      "text": "DKIM signing and validating can be used in different ways, for different operational scenarios. This Appendix discusses some common examples.",
      "ja": "DKIMの署名と検証は、異なる動作シナリオのために、さまざまな方法で使用することができます。この付録では、いくつかの一般的な例を説明します。"
    },
    {
      "indent": 6,
      "text": "NOTE: Descriptions in this Appendix are for informational purposes only. They describe various ways that DKIM can be used, given particular constraints and needs. In no case are these examples intended to be taken as providing explanation or guidance concerning DKIM specification details when creating an implementation.",
      "ja": "注：この付録の説明は、情報提供のみを目的としています。彼らは、DKIMは、特定の制約やニーズ与え、使用することができますさまざまな方法について説明します。いかなる場合にも実装を作成するときにDKIM仕様の詳細に関する説明やガイダンスを提供するものとして取られることが意図これらの例です。"
    },
    {
      "indent": 0,
      "text": "B.1. Alternate Submission Scenarios",
      "ja": "B.1。代替提出のシナリオ"
    },
    {
      "indent": 3,
      "text": "In the most simple scenario, a user's MUA, MSA, and Internet (boundary) MTA are all within the same administrative environment, using the same domain name. Therefore, all of the components involved in submission and initial transfer are related. However, it is common for two or more of the components to be under independent administrative control. This creates challenges for choosing and administering the domain name to use for signing and for its relationship to common email identity header fields.",
      "ja": "最も単純なシナリオでは、ユーザーのMUA、MSA、およびインターネット（境界）MTAは、同じドメイン名を使用して、すべて同じ管理環境内にあります。そのため、提出と初期転送に関わるすべてのコンポーネントが関連しています。構成要素のうちの2つ以上が、独立行政管理下にあるためにしかし、それが一般的です。これは、署名のための、共通の電子メールのアイデンティティのヘッダフィールドとの関係のために使用するドメイン名を選択し、管理するための課題を作成します。"
    },
    {
      "indent": 0,
      "text": "B.1.1. Delegated Business Functions",
      "ja": "B.1.1。委任ビジネス機能"
    },
    {
      "indent": 3,
      "text": "Some organizations assign specific business functions to discrete groups, inside or outside the organization. The goal, then, is to authorize that group to sign some mail but to constrain what signatures they can generate. DKIM selectors (the \"s=\" signature tag) facilitate this kind of restricted authorization. Examples of these outsourced business functions are legitimate email marketing providers and corporate benefits providers.",
      "ja": "一部の組織では、組織の内部または外部の、個別のグループに特定のビジネス機能を割り当てます。目標は、その後、いくつかのメールに署名するのではなく、彼らが生成することができますどのような署名制限するために、そのグループを認可することです。 DKIMセレクタ（「S =」署名タグ）が制限され、許可この種のを容易にします。これらの外部委託業務機能の例としては、合法的なメールマーケティングプロバイダーや企業のメリット・プロバイダーです。"
    },
    {
      "indent": 3,
      "text": "Here, the delegated group needs to be able to send messages that are signed, using the email domain of the client company. At the same time, the client often is reluctant to register a key for the provider that grants the ability to send messages for arbitrary addresses in the domain.",
      "ja": "ここでは、委任グループは、クライアント企業の電子メールドメインを使用して、署名されたメッセージを送信できるようにする必要があります。同時に、クライアントは、多くの場合、ドメイン内の任意のアドレスのためのメッセージを送信する機能を付与するプロバイダのキーを登録するには消極的です。"
    },
    {
      "indent": 3,
      "text": "There are multiple ways to administer these usage scenarios. In one case, the client organization provides all of the public query service (for example, DNS) administration, and in another, it uses DNS delegation to enable all ongoing administration of the DKIM key record by the delegated group.",
      "ja": "これらの利用シナリオを管理するために複数の方法があります。あるケースでは、クライアント組織は、公共クエリサービス（例えば、DNS）の管理のすべてを提供し、他には、委任グループでDKIMキーレコードのすべての継続的な管理を可能にするために、DNS委任を使用しています。"
    },
    {
      "indent": 3,
      "text": "If the client organization retains responsibility for all of the DNS administration, the outsourcing company can generate a key pair, supplying the public key to the client company, which then registers it in the query service using a unique selector. The client company retains control over the use of the delegated key because it retains the ability to revoke the key at any time.",
      "ja": "クライアント組織がDNS管理のすべての責任を保持している場合、アウトソーシング会社は、独自のセレクタを使用してクエリサービスに登録するクライアント企業への公開鍵を供給、鍵のペアを生成することができます。それはいつでもキーを取り消すする能力を保持するため、クライアント企業は、委譲鍵の使用を制御を保持します。"
    },
    {
      "indent": 3,
      "text": "If the client wants the delegated group to do the DNS administration, it can have the domain name that is specified with the selector point to the provider's DNS server. The provider then creates and maintains all of the DKIM signature information for that selector. Hence, the client cannot provide constraints on the local-part of addresses that get signed, but it can revoke the provider's signing rights by removing the DNS delegation record.",
      "ja": "クライアントは、DNSの管理を行うための委任グループを望んでいるなら、それは、プロバイダのDNSサーバーにセレクタポイントで指定されたドメイン名を持つことができます。プロバイダは、作成し、そのセレクタのDKIM署名情報のすべてを維持します。したがって、クライアントが署名しますアドレスのローカル部分の制約を提供することはできませんが、それはDNS委任レコードを削除することによって、プロバイダの署名権を取り消すことができます。"
    },
    {
      "indent": 0,
      "text": "B.1.2. PDAs and Similar Devices",
      "ja": "B.1.2。 PDAや同様のデバイス"
    },
    {
      "indent": 3,
      "text": "PDAs demonstrate the need for using multiple keys per domain. Suppose that John Doe wants to be able to send messages using his corporate email address, jdoe@example.com, and his email device does not have the ability to make a Virtual Private Network (VPN) connection to the corporate network, either because the device is limited or because there are restrictions enforced by his Internet access provider. If the device is equipped with a private key registered for jdoe@example.com by the administrator of the example.com domain and appropriate software to sign messages, John could sign the message on the device itself before transmission through the outgoing network of the access service provider.",
      "ja": "PDAのは、ドメインごとに複数のキーを使用する必要性を示しています。ジョン・ドウが彼の企業の電子メールアドレス、jdoe@example.comを使用してメッセージを送信できるようにしたいと考えて、彼の電子メール・デバイスが企業ネットワークへの仮想プライベートネットワーク（VPN）接続を作る能力を持っていないと仮定し、どちらかのために彼のインターネットアクセスプロバイダーによって強制制限があるため、デバイスは限られていますか。デバイスはexample.comドメインとメッセージに署名するための適切なソフトウェアの管理者によってjdoe@example.comに登録された秘密鍵が装備されている場合、ジョンはアクセスの発信ネットワークを通じて伝送する前に、デバイス自体にメッセージに署名することができサービスプロバイダ。"
    },
    {
      "indent": 0,
      "text": "B.1.3. Roaming Users",
      "ja": "B.1.3。ローミングユーザー"
    },
    {
      "indent": 3,
      "text": "Roaming users often find themselves in circumstances where it is convenient or necessary to use an SMTP server other than their home server; examples are conferences and many hotels. In such circumstances, a signature that is added by the submission service will use an identity that is different from the user's home system.",
      "ja": "ローミングユーザーは、多くの場合、彼らのホームサーバ以外のSMTPサーバーを使用すると便利か、必要である状況で自分自身を見つけます。例として、会議や多くのホテルがあります。このような状況では、提出サービスによって追加された署名は、ユーザのホームシステムと異なるIDを使用します。"
    },
    {
      "indent": 3,
      "text": "Ideally, roaming users would connect back to their home server using either a VPN or a SUBMISSION server running with SMTP AUTHentication on port 587. If the signing can be performed on the roaming user's laptop, then they can sign before submission, although the risk of further modification is high. If neither of these are possible, these roaming users will not be able to send mail signed using their own domain key.",
      "ja": "理想的には、ローミングユーザーは、署名がローミングユーザーのラップトップで行うことができれば、その後、彼らは提出前に、リスクが署名することができるポート587上でVPNやSMTP認証を実行しているSUBMISSIONサーバーのいずれかを使用して戻って自分のホームサーバーに接続しますさらなる変更が高いです。これらのどちらも可能性がある場合は、これらのローミングユーザーは、自分のドメインキーを使用して署名したメールを送信することができません。"
    },
    {
      "indent": 0,
      "text": "B.1.4. Independent (Kiosk) Message Submission",
      "ja": "B.1.4。インディペンデント（キオスク）メッセージ送信"
    },
    {
      "indent": 3,
      "text": "Stand-alone services, such as walk-up kiosks and web-based information services, have no enduring email service relationship with the user, but users occasionally request that mail be sent on their behalf. For example, a website providing news often allows the reader to forward a copy of the article to a friend. This is typically done using the reader's own email address, to indicate who the author is. This is sometimes referred to as the \"Evite\" problem, named after the website of the same name that allows a user to send invitations to friends.",
      "ja": "このようウォークアップキオスクやウェブベースの情報サービスとして、スタンドアローンのサービスは、ユーザーとの永続的な電子メールサービスの関係を持っていないが、ユーザーは時折メールが自分の代わりに送信することを要求します。たとえば、ウェブサイトの提供のニュースは、多くの場合、読者が友人に記事のコピーを転送することができます。これは通常、著者が誰であるかを示すために、読者自身のメールアドレスを使用して行われます。これは、時々、ユーザーが友達に招待状を送信することを可能にする同名のウェブサイトにちなんで名付けられた「Eviteの」問題、と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "A common way this is handled is to continue to put the reader's email address in the From header field of the message but put an address owned by the email posting site into the Sender header field. The posting site can then sign the message, using the domain that is in the Sender field. This provides useful information to the receiving email site, which is able to correlate the signing domain with the initial submission email role.",
      "ja": "これが処理される一般的な方法は、Senderヘッダフィールドに電子メールの投稿サイトが所有しているアドレスを、メッセージのFromヘッダーフィールドに読者のメールアドレスを入れますがかけ続けることです。投稿サイトは、Senderフィールドにあるドメインを使用して、メッセージに署名することができます。これは、初期の提出電子メールの役割を持つ署名ドメインを関連付けることが可能である、電子メール受信サイトへの有用な情報を提供します。"
    },
    {
      "indent": 3,
      "text": "Receiving sites often wish to provide their end users with information about mail that is mediated in this fashion. Although the real efficacy of different approaches is a subject for human factors usability research, one technique that is used is for the verifying system to rewrite the From header field to indicate the address that was verified, for example: From: John Doe via news@news-site.example <jdoe@example.com>. (Note that such rewriting will break a signature, unless it is done after the verification pass is complete.)",
      "ja": "受信サイトは、多くの場合、この方法で媒介されたメールに関する情報を自分のエンド・ユーザーに提供したいです。ニュースを介してジョン・ドウ@：から：異なるアプローチの実際の効力は、ヒト因子ユーザビリティ研究の主題であるが、使用される一つの技術は、例えば、検証されたアドレスを示すために、ヘッダフィールドからリライトする検証システムのためのものですニュース-site.example <jdoe@example.com>。 （検証パスが完了した後、それが行われない限り、このような書き換えは、署名を壊すことに注意してください。）"
    },
    {
      "indent": 0,
      "text": "B.2. Alternate Delivery Scenarios",
      "ja": "B.2。代替配信シナリオ"
    },
    {
      "indent": 3,
      "text": "Email is often received at a mailbox that has an address different from the one used during initial submission. In these cases, an intermediary mechanism operates at the address originally used, and it then passes the message on to the final destination. This mediation process presents some challenges for DKIM signatures.",
      "ja": "メールは、多くの場合、最初の提出時に使用されるものとは異なるアドレスを持つメールボックスで受信されます。これらのケースでは、仲介機構は、最初に使用したアドレスで動作し、それは最終的な宛先にメッセージを渡します。この調停プロセスは、DKIM署名のためのいくつかの課題を提示しています。"
    },
    {
      "indent": 0,
      "text": "B.2.1. Affinity Addresses",
      "ja": "B.2.1。アフィニティアドレス"
    },
    {
      "indent": 3,
      "text": "\"Affinity addresses\" allow a user to have an email address that remains stable, even as the user moves among different email providers. They are typically associated with college alumni associations, professional organizations, and recreational organizations with which they expect to have a long-term relationship. These domains usually provide forwarding of incoming email, and they often have an associated Web application that authenticates the user and allows the forwarding address to be changed. However, these services usually depend on users sending outgoing messages through their own service provider's MTAs. Hence, mail that is signed with the domain of the affinity address is not signed by an entity that is administered by the organization owning that domain.",
      "ja": "「親和性のアドレスは、」ユーザーが別のメールプロバイダの間で移動したとしても、ユーザーは安定している電子メールアドレスを持つことができます。彼らは通常、彼らは長期的な関係を持つことを期待されて大学の同窓会、専門機関、およびレクリエーションの組織に関連付けられています。これらのドメインは、通常、受信メールの転送を提供し、彼らはしばしば、ユーザーを認証し、転送先アドレスを変更することが可能に関連したWebアプリケーションを持っています。しかし、これらのサービスは、通常、独自のサービスプロバイダのMTAはを通じて送信メッセージを送信するユーザーに依存しています。したがって、アフィニティアドレスのドメインで署名されたメールは、そのドメインを所有している組織によって管理されたエンティティによって署名されていません。"
    },
    {
      "indent": 3,
      "text": "With DKIM, affinity domains could use the Web application to allow users to register per-user keys to be used to sign messages on behalf of their affinity address. The user would take away the secret half of the key pair for signing, and the affinity domain would publish the public half in DNS for access by Verifiers.",
      "ja": "DKIMでは、親和性ドメインは、ユーザーが自分の親和アドレスの代わりにメッセージを署名するために使用されるように、ユーザごとのキーを登録できるようにするために、Webアプリケーションを使用することができます。ユーザーは、署名用の鍵ペアの秘密の半分を奪うだろう、との親和性ドメインは、検証者がアクセスするためのDNSの公共の半分を公開します。"
    },
    {
      "indent": 3,
      "text": "This is another application that takes advantage of user-level keying, and domains used for affinity addresses would typically have a very large number of user-level keys. Alternatively, the affinity domain could handle outgoing mail, operating a mail submission agent that authenticates users before accepting and signing messages for them. This is, of course, dependent on the user's service provider not blocking the relevant TCP ports used for mail submission.",
      "ja": "これは、ユーザーレベルのキーを活用する他のアプリケーションであり、そして親和アドレスに使用ドメインは、典型的には、ユーザーレベルのキーの非常に多くを持っているでしょう。また、親和性ドメインは、それらのメッセージを受け入れ、署名する前にユーザーを認証メール送信エージェントを操作し、送信メールを処理することができます。これは、当然のことながら、メール送信で使用される、関連するTCPポートをブロックしていないユーザのサービスプロバイダに依存しています。"
    },
    {
      "indent": 0,
      "text": "B.2.2. Simple Address Aliasing (.forward)",
      "ja": "B.2.2。シンプルなアドレスエイリアシング（の.forward）"
    },
    {
      "indent": 3,
      "text": "In some cases, a recipient is allowed to configure an email address to cause automatic redirection of email messages from the original address to another, such as through the use of a Unix .forward file. In this case, messages are typically redirected by the mail handling service of the recipient's domain, without modification, except for the addition of a Received header field to the message and a change in the envelope recipient address. In this case, the recipient at the final address' mailbox is likely to be able to verify the original signature since the signed content has not changed, and DKIM is able to validate the message signature.",
      "ja": "いくつかのケースでは、受信者は、そのようなUnixのの.forwardファイルを使用してなどの別の元のアドレスからの電子メールメッセージの自動リダイレクトを引き起こすために、電子メールアドレスを設定することが許可されています。この場合、メッセージは通常、メッセージとエンベロープ受信者アドレスの変更にReceivedヘッダフィールドの追加を除いて、変更することなく、受信者のドメインのメール処理サービスによってリダイレクトされます。この場合、最終アドレスのメールボックスで受信者は、署名されたコンテンツが変更されていないので、元の署名を検証することができる可能性がある、とDKIMはメッセージの署名を検証することが可能です。"
    },
    {
      "indent": 0,
      "text": "B.2.3. Mailing Lists and Re-Posters",
      "ja": "B.2.3。メーリングリストと再ポスター"
    },
    {
      "indent": 3,
      "text": "There is a wide range of behaviors in services that take delivery of a message and then resubmit it. A primary example is with mailing lists (collectively called \"forwarders\" below), ranging from those that make no modification to the message itself, other than to add a Received header field and change the envelope information, to those that add header fields, change the Subject header field, add content to the body (typically at the end), or reformat the body in some manner. The simple ones produce messages that are quite similar to the automated alias services. More elaborate systems essentially create a new message.",
      "ja": "メッセージの配信を取り、それを再送信サービスにおける行動の広い範囲があります。主な例は、メーリングリストReceivedヘッダーフィールドを追加し、エンベロープ情報を変更する以外に、メッセージ自体への変更をしないものに至るまで、（集合的に以下「フォワーダ」と呼ばれる）、ヘッダフィールドを追加するものに変更してあります件名ヘッダフィールド、（典型的には末端で）本体にコンテンツを追加、または何らかの方法で身体を再フォーマットします。簡単なものは自動化されたエイリアスサービスと非常によく似ているメッセージを生成します。より複雑なシステムは、本質的に新しいメッセージを作成します。"
    },
    {
      "indent": 3,
      "text": "A Forwarder that does not modify the body or signed header fields of a message is likely to maintain the validity of the existing signature. It also could choose to add its own signature to the message.",
      "ja": "メッセージの本体又は署名されたヘッダーフィールドを変更しないフォワーダは、既存の署名の有効性を維持する可能性があります。また、メッセージに独自の署名を追加することを選択することができます。"
    },
    {
      "indent": 3,
      "text": "Forwarders that modify a message in a way that could make an existing signature invalid are particularly good candidates for adding their own signatures (e.g., mailing-list-name@example.net). Since (re-)signing is taking responsibility for the content of the message, these signing forwarders are likely to be selective and forward or re-sign a message only if it is received with a valid signature or if they have some other basis for knowing that the message is not spoofed.",
      "ja": "既存の署名が無効に作ることができるようにメッセージを変更フォワーダは、独自の署名（例えば、mailing-list-name@example.net）を追加するための特に良好な候補です。 （再）署名は、メッセージの内容に責任を取っているので、これらの署名フォワーダは、選択的で前方またはそれが有効な署名を受信した場合にのみ、メッセージを再署名したりする可能性がある、彼らは知っているために他のいくつかの根拠を持っている場合メッセージが偽装されていません。"
    },
    {
      "indent": 3,
      "text": "A common practice among systems that are primarily redistributors of mail is to add a Sender header field to the message to identify the address being used to sign the message. This practice will remove any preexisting Sender header field as required by [RFC5322]. The forwarder applies a new DKIM-Signature header field with the signature, public key, and related information of the forwarder.",
      "ja": "主にメールの再頒布されているシステムの間で一般的な方法は、メッセージに署名するために使用されているアドレスを識別するためにメッセージに送信者ヘッダーフィールドを追加することです。 [RFC5322]によって必要とされるこの方法は、任意の既存の送信者ヘッダフィールドを削除します。フォワーダは、署名、公開鍵、およびフォワーダの関連情報を新たなDKIM署名ヘッダフィールドを適用します。"
    },
    {
      "indent": 3,
      "text": "See [RFC6377] for additional related topics and discussion.",
      "ja": "追加の関連トピックや議論のための[RFC6377]を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Creating a Public Key (INFORMATIVE)",
      "ja": "公開鍵の作成付録C.（参考）"
    },
    {
      "indent": 3,
      "text": "The default signature is an RSA-signed SHA-256 digest of the complete email. For ease of explanation, the openssl command is used to describe the mechanism by which keys and signatures are managed. One way to generate a 1024-bit, unencrypted private key suitable for DKIM is to use openssl like this:",
      "ja": "デフォルトの署名は、完全な電子メールのRSA署名SHA-256ダイジェストです。説明を簡単にするため、OpenSSLのコマンドは、鍵と署名が管理されるメカニズムを説明するために使用されます。 DKIMに適した1024ビット、暗号化されていない秘密鍵を生成するための一つの方法は、次のようにOpenSSLを使用することです："
    },
    {
      "indent": 3,
      "text": "$ openssl genrsa -out rsa.private 1024",
      "ja": "$ opensslのgenrsa -out rsa.private 1024"
    },
    {
      "indent": 3,
      "text": "For increased security, the \"-passin\" parameter can also be added to encrypt the private key. Use of this parameter will require entering a password for several of the following steps. Servers may prefer to use hardware cryptographic support.",
      "ja": "セキュリティを強化するため、「-passin」パラメータも、秘密鍵を暗号化するために追加することができます。このパラメータを使用するには、以下のステップのいくつかのためのパスワードを入力する必要があります。サーバは、ハードウェア暗号化のサポートを使用することを好むことがあります。"
    },
    {
      "indent": 3,
      "text": "The \"genrsa\" step results in the file rsa.private containing the key information similar to this:",
      "ja": "「genrsa」これに似たキー情報を含むファイルrsa.privateのステップの結果："
    },
    {
      "indent": 3,
      "text": "-----BEGIN RSA PRIVATE KEY-----\nMIICXwIBAAKBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkMoGeLnQg1fWn7/zYtIxN2SnFC\njxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v/RtdC2UzJ1lWT947qR+Rcac2gb\nto/NMqJ0fzfVjH4OuKhitdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB\nAoGBALmn+XwWk7akvkUlqb+dOxyLB9i5VBVfje89Teolwc9YJT36BGN/l4e0l6QX\n/1//6DWUTB3KI6wFcm7TWJcxbS0tcKZX7FsJvUz1SbQnkS54DJck1EZO/BLa5ckJ\ngAYIaqlA9C0ZwM6i58lLlPadX/rtHb7pWzeNcZHjKrjM461ZAkEA+itss2nRlmyO\nn1/5yDyCluST4dQfO8kAB3toSEVc7DeFeDhnC1mZdjASZNvdHS4gbLIA1hUGEF9m\n3hKsGUMMPwJBAPW5v/U+AWTADFCS22t72NUurgzeAbzb1HWMqO4y4+9Hpjk5wvL/\neVYizyuce3/fGke7aRYw/ADKygMJdW8H/OcCQQDz5OQb4j2QDpPZc0Nc4QlbvMsj\n7p7otWRO5xRa6SzXqqV3+F0VpqvDmshEBkoCydaYwc2o6WQ5EBmExeV8124XAkEA\nqZzGsIxVP+sEVRWZmW6KNFSdVUpk3qzK0Tz/WjQMe5z0UunY9Ax9/4PVhp/j61bf\neAYXunajbBSOLlx4D+TunwJBANkPI5S9iylsbLs6NkaMHV6k5ioHBBmgCak95JGX\nGMot/L2x0IYyMLAz6oLWh2hm7zwtb0CgOrPo1ke44hFYnfc=\n-----END RSA PRIVATE KEY-----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "To extract the public-key component from the private key, use openssl like this:",
      "ja": "このようにOpenSSLを使用して、秘密鍵から公開鍵成分を抽出するには："
    },
    {
      "indent": 3,
      "text": "$ openssl rsa -in rsa.private -out rsa.public -pubout -outform PEM",
      "ja": "$ opensslのRSA -in rsa.private -out rsa.public -pubout -outform PEM"
    },
    {
      "indent": 3,
      "text": "This results in the file rsa.public containing the key information similar to this:",
      "ja": "これは、次のような重要な情報を含むファイルrsa.publicになり："
    },
    {
      "indent": 3,
      "text": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkM\noGeLnQg1fWn7/zYtIxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v/R\ntdC2UzJ1lWT947qR+Rcac2gbto/NMqJ0fzfVjH4OuKhitdY9tf6mcwGjaNBcWToI\nMmPSPDdQPNUYckcQ2QIDAQAB\n-----END PUBLIC KEY-----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This public-key data (without the BEGIN and END tags) is placed in the DNS:",
      "ja": "この公開鍵データ（BEGINとENDタグなし）をDNSに配置されています。"
    },
    {
      "indent": 3,
      "text": "$ORIGIN _domainkey.example.org. brisbane IN TXT (\"v=DKIM1; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQ\" \"KBgQDwIRP/UC3SBsEmGqZ9ZJW3/DkMoGeLnQg1fWn7/zYt\" \"IxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od+v\" \"/RtdC2UzJ1lWT947qR+Rcac2gbto/NMqJ0fzfVjH4OuKhi\" \"tdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB\")",
      "ja": "の$ ORIGIN _domainkey.example.org。 TXTブリスベン（ \"V = DKIM1; P = MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQ\" \"KBgQDwIRP / UC3SBsEmGqZ9ZJW3 / DkMoGeLnQg1fWn7 / ZYT\" \"IxN2SnFCjxOCKG9v3b4jYfcTNh5ijSsq631uBItLa7od + V\" \"/ RtdC2UzJ1lWT947qR + Rcac2gbto / NMqJ0fzfVjH4OuKhi\" \"tdY9tf6mcwGjaNBcWToIMmPSPDdQPNUYckcQ2QIDAQAB\"）"
    },
    {
      "indent": 0,
      "text": "C.1. Compatibility with DomainKeys Key Records",
      "ja": "C.1。 DomainKeysのキーレコードとの互換性"
    },
    {
      "indent": 3,
      "text": "DKIM key records were designed to be backward compatible in many cases with key records used by DomainKeys [RFC4870] (sometimes referred to as \"selector records\" in the DomainKeys context). One area of incompatibility warrants particular attention. The \"g=\" tag value may be used in DomainKeys and [RFC4871] key records to provide",
      "ja": "DKIMキーレコードがドメインキー[RFC4870]で使用されるキーレコードと、多くの場合において後方互換になるように設計した（時にはドメインキーの文脈における「選択レコード」と呼びます）。非互換性の一つの領域は特に注意を保証します。 「G =」タグ値が提供するドメインキー及び[RFC4871]キーレコードに使用することができます"
    },
    {
      "indent": 3,
      "text": "finer granularity of the validity of the key record to a specific local-part. A null \"g=\" value in DomainKeys is valid for all addresses in the domain. This differs from the usage in the original DKIM specification ([RFC4871]), where a null \"g=\" value is not valid for any address. In particular, see the example public-key record in Section 3.2.3 of [RFC4870].",
      "ja": "特定のローカル部分にキーレコードの有効性のより細かい粒度。 DomainKeysの中ヌル「グラム=」値は、ドメイン内のすべてのアドレスに対して有効です。これはヌル「G =」の値は、任意のアドレスに対して有効でない元のDKIM仕様（[RFC4871]）での使用とは異なります。具体的には、[RFC4870]のセクション3.2.3の例公開鍵レコードを参照。"
    },
    {
      "indent": 0,
      "text": "C.2. Compatibility",
      "ja": "C.2。適合"
    },
    {
      "indent": 3,
      "text": "Although the \"g=\" tag has been deprecated in this version of the DKIM specification (and thus MUST now be ignored), Signers are advised not to include the \"g=\" tag in key records because some [RFC4871]- compliant Verifiers will be in use for a considerable period to come.",
      "ja": "準拠した検証者になる - 「グラム=」タグがDKIM仕様のこのバージョンで廃止されました（したがって、今で無視しなければなりません）が、署名者は、いくつかの[RFC4871]ので、キーレコードに「グラム=」タグを含めるしないことをお勧めしますかなりの時間が来るのを使用中です。"
    },
    {
      "indent": 0,
      "text": "Appendix D. MUA Considerations (INFORMATIVE)",
      "ja": "付録D. MUAの考慮事項（参考）"
    },
    {
      "indent": 3,
      "text": "When a DKIM signature is verified, the processing system sometimes makes the result available to the recipient user's MUA. How to present this information to users in a way that helps them is a matter of continuing human factors usability research. The tendency is to have the MUA highlight the SDID, in an attempt to show the user the identity that is claiming responsibility for the message. An MUA might do this with visual cues such as graphics, might include the address in an alternate view, or might even rewrite the original From address using the verified information. Some MUAs might indicate which header fields were protected by the validated DKIM signature. This could be done with a positive indication on the signed header fields, with a negative indication on the unsigned header fields, by visually hiding the unsigned header fields, or some combination of these. If an MUA uses visual indications for signed header fields, the MUA probably needs to be careful not to display unsigned header fields in a way that might be construed by the end user as having been signed. If the message has an \"l=\" tag whose value does not extend to the end of the message, the MUA might also hide or mark the portion of the message body that was not signed.",
      "ja": "DKIM署名が検証された場合、処理システムは、時々受信者ユーザのMUAに結果を利用可能にします。どのように彼らは、人的要因のユーザビリティ研究を続けるの問題であるのに役立ちますように、ユーザーにこの情報を提示します。傾向は、MUAは、ユーザにメッセージの責任を主張している同一性を示すための試みで、SDIDを強調することです。 MUAは、代替ビュー内のアドレスが含まれる場合があり、グラフィックスなどの視覚的な合図でこれを行う可能性があり、あるいは検証情報を用いてアドレスからの元を書き換える可能性があります。一部のMUAは検証DKIM署名によって保護されたヘッダフィールドを示している可能性があります。これは、視覚的に未署名ヘッダフィールド、またはこれらの何らかの組合せを隠すことで、符号なしのヘッダーフィールドに負の指示と、署名されたヘッダフィールドの正の表示で行うことができます。 MUAは、署名されたヘッダフィールドの視覚的な表示を使用している場合、MUAは、おそらく署名されたように、エンドユーザによって解釈されるかもしれないように、符号なしのヘッダーフィールドを表示しないように注意する必要があります。メッセージは、その値がメッセージの終わりまで延びていない「L =」タグを有する場合、MUAはまた、署名されなかったメッセージ本体の一部を非表示にしたり、マークかもしれません。"
    },
    {
      "indent": 3,
      "text": "The aforementioned information is not intended to be exhaustive. The MUA can choose to highlight, accentuate, hide, or otherwise display any other information that may, in the opinion of the MUA author, be deemed important to the end user.",
      "ja": "上記の情報は、網羅的であることを意図したものではありません。 MUAは、ハイライト強調、非表示、またはそれ以外の場合は、MUAの著者の意見では、エンドユーザーに重要とみなすことができる他の情報を表示することができます。"
    },
    {
      "indent": 1,
      "text": "Appendix E. Changes since",
      "ja": "付録E.からの変更点"
    },
    {
      "indent": 3,
      "text": "o Abstract and introduction refined based on accumulated experience.",
      "ja": "O抽象と導入が蓄積された経験をもとに洗練されました。"
    },
    {
      "indent": 3,
      "text": "o Various references updated.",
      "ja": "O様々な参考文献を更新しました。"
    },
    {
      "indent": 3,
      "text": "o Several errata resolved (see http://www.rfc-editor.org/):",
      "ja": "Oいくつかの正誤表は、解決（http://www.rfc-editor.org/を参照してください）："
    },
    {
      "indent": 6,
      "text": "* 1376 applied",
      "ja": "* 1376年には適用しました"
    },
    {
      "indent": 6,
      "text": "* 1377 applied",
      "ja": "* 1377年には適用しました"
    },
    {
      "indent": 6,
      "text": "* 1378 applied",
      "ja": "* 1378年には適用しました"
    },
    {
      "indent": 6,
      "text": "* 1379 applied",
      "ja": "* 1379年には適用しました"
    },
    {
      "indent": 6,
      "text": "* 1380 applied",
      "ja": "* 1380が適用されます"
    },
    {
      "indent": 6,
      "text": "* 1381 applied",
      "ja": "* 1381年には適用しました"
    },
    {
      "indent": 6,
      "text": "* 1382 applied",
      "ja": "* 1382年には適用しました"
    },
    {
      "indent": 6,
      "text": "* 1383 discarded (no longer applies)",
      "ja": "* 1383年には、廃棄された（もはや適用されます）"
    },
    {
      "indent": 6,
      "text": "* 1384 applied",
      "ja": "* 1384年には適用しました"
    },
    {
      "indent": 6,
      "text": "* 1386 applied",
      "ja": "* 1386年には適用しました"
    },
    {
      "indent": 6,
      "text": "* 1461 applied",
      "ja": "* 1461年には適用しました"
    },
    {
      "indent": 6,
      "text": "* 1487 applied",
      "ja": "* 1487年には適用しました"
    },
    {
      "indent": 6,
      "text": "* 1532 applied",
      "ja": "* 1532が適用されます"
    },
    {
      "indent": 6,
      "text": "* 1596 applied",
      "ja": "* 1596年には適用しました"
    },
    {
      "indent": 3,
      "text": "o Introductory section enumerating relevant architectural documents added.",
      "ja": "O関連の建築の文書を列挙入門セクションが追加されました。"
    },
    {
      "indent": 3,
      "text": "o Introductory section briefly discussing the matter of data integrity added.",
      "ja": "O簡単にデータの整合性の問題を議論入門セクションが追加されました。"
    },
    {
      "indent": 3,
      "text": "o Allowed tolerance of some clock drift.",
      "ja": "O一部のクロックドリフトの許容可。"
    },
    {
      "indent": 3,
      "text": "o Dropped \"g=\" tag from key records. The implementation report indicates that it is not in use.",
      "ja": "Oキーレコードから「グラム=」タグを落としました。実施報告書は、それが使用されていないことを示しています。"
    },
    {
      "indent": 3,
      "text": "o Removed errant note about wildcards in the DNS.",
      "ja": "O DNSでのワイルドカードについての誤ったノートを削除しました。"
    },
    {
      "indent": 3,
      "text": "o Removed SMTP-specific advice in most places.",
      "ja": "Oほとんどの場所でSMTP-具体的なアドバイスを削除しました。"
    },
    {
      "indent": 3,
      "text": "o Reduced (non-normative) recommended signature content list, and reworked the text in that section.",
      "ja": "O署名コンテンツリストを推奨し、そのセクションのテキストを再加工（非規範的）減少。"
    },
    {
      "indent": 3,
      "text": "o Clarified signature generation algorithm by rewriting its pseudo-code.",
      "ja": "Oの擬似コードを書き換えることにより、署名生成アルゴリズムを明らかにしました。"
    },
    {
      "indent": 3,
      "text": "o Numerous terminology subsections added, imported from [RFC5672]. Also, began using these terms throughout the document (e.g., SDID, AUID).",
      "ja": "O多数の用語のサブセクションでは、[RFC5672]からインポートし、添加します。また、文書（例えば、SDID、AUID）全体でこれらの用語を使用し始めました。"
    },
    {
      "indent": 3,
      "text": "o Sections added that specify input and output requirements. Input requirements address a security concern raised by the working group (see also new sections in Security Considerations). Output requirements are imported from [RFC5672].",
      "ja": "Oセクションは、入力と出力の要件を指定して加えました。入力要件は、ワーキンググループが提起したセキュリティ上の懸念に対処（セキュリティ上の考慮事項でも、新しいセクションを参照してください）。出力要件は[RFC5672]から輸入されています。"
    },
    {
      "indent": 3,
      "text": "o Appendix subsection added discussing compatibility with DomainKeys ([RFC4870]) records.",
      "ja": "O付録サブセクションは、ドメインキー（[RFC4870]）レコードとの互換性を議論添加しました。"
    },
    {
      "indent": 3,
      "text": "o Referred to [RFC5451] as an example method of communicating the results of DKIM verification.",
      "ja": "O DKIM検証の結果を通信する例示的な方法として、[RFC5451]と呼びます。"
    },
    {
      "indent": 3,
      "text": "o Removed advice about possible uses of the \"l=\" signature tag.",
      "ja": "O署名タグ「= L」の可能な使用についてのアドバイスを削除しました。"
    },
    {
      "indent": 3,
      "text": "o IANA registry updated.",
      "ja": "O IANAレジストリを更新しました。"
    },
    {
      "indent": 3,
      "text": "o Added two new Security Considerations sections talking about malformed message attacks.",
      "ja": "oは不正な形式のメッセージ攻撃の話を二つの新しいセキュリティの考慮事項のセクションを追加しました。"
    },
    {
      "indent": 3,
      "text": "o Various copy editing.",
      "ja": "O様々なコピー編集。"
    },
    {
      "indent": 0,
      "text": "Appendix F. Acknowledgments",
      "ja": "付録F.謝辞"
    },
    {
      "indent": 3,
      "text": "The previous IETF version of DKIM [RFC4871] was edited by Eric Allman, Jon Callas, Mark Delany, Miles Libbey, Jim Fenton, and Michael Thomas.",
      "ja": "DKIM [RFC4871]の以前のIETFバージョンはエリック・オールマン、ジョン・カラス、マーク・ディレイニー、マイルリビー、ジム・フェントン、そしてマイケル・トーマスが編集しました。"
    },
    {
      "indent": 3,
      "text": "That specification was the result of an extended collaborative effort, including participation by Russ Allbery, Edwin Aoki, Claus Assmann, Steve Atkins, Rob Austein, Fred Baker, Mark Baugher, Steve Bellovin, Nathaniel Borenstein, Dave Crocker, Michael Cudahy, Dennis Dayman, Jutta Degener, Frank Ellermann, Patrik Faeltstroem, Mark Fanto, Stephen Farrell, Duncan Findlay, Elliot Gillum, Olafur Gudmundsson, Phillip Hallam-Baker, Tony Hansen, Sam Hartman, Arvel Hathcock, Amir Herzberg, Paul Hoffman, Russ Housley, Craig Hughes, Cullen Jennings, Don Johnsen, Harry Katz, Murray S. Kucherawy, Barry Leiba, John Levine, Charles Lindsey, Simon Longsdale, David Margrave, Justin Mason, David Mayne, Thierry Moreau, Steve Murphy, Russell Nelson, Dave Oran, Doug Otis, Shamim Pirzada, Juan Altmayer Pizzorno, Sanjay Pol, Blake Ramsdell, Christian Renaud, Scott Renfro, Neil",
      "ja": "その仕様は、ラスAllbery、エドウィン・青木、クラウスアスマン、スティーブ・アトキンス、ロブAusteinと、フレッド・ベイカー、マーク・Baugher、スティーブBellovin氏、ナサニエル・ボレンスタイン、デイブ・クロッカー、マイケル・カダヒー、デニスDaymanの参加を含む拡張共同の努力の結果でしたユッタ・デッジナー、フランクEllermann、パトリックFaeltstroem、マーク・Fanto、スティーブン・ファレル、ダンカンフィンドレー、エリオットGillum、オラフルグドムンソン、フィリップハラム - ベイカー、トニーハンセン、サム・ハートマン、Arvel Hathcock、アミール・ハーツバーグ、ポール・ホフマン、ラスHousley、クレイグ・ヒューズ、カレンジェニングス、ドン・ジョンセン、ハリー・カッツ、マレーS. Kucherawy、バリー・レイバ、ジョン・レヴァイン、チャールズリンジー、サイモンLongsdale、デビッド辺境伯、ジャスティン・メイソン、デイビット・メイン、ティエリー・モロー、スティーブ・マーフィー、ラッセル・ネルソン、デイブ・オラン、ダグ・オーティス、 Shamim Pirzada、フアンAltmayer Pizzorno、サンジャイ・ポル、ブレイクRamsdell、クリスチャン・ルノー、スコット・レンフロ、ニール"
    },
    {
      "indent": 3,
      "text": "Rerup, Eric Rescorla, Dave Rossetti, Hector Santos, Jim Schaad, the Spamhaus.org team, Malte S. Stretz, Robert Sanders, Rand Wacker, Sam Weiler, and Dan Wing.",
      "ja": "Rerup、エリックレスコラ、デイブ・ロセッティ、ヘクターサントス、ジムSchaad、Spamhaus.orgチーム、マルテS. Stretz、ロバート・サンダース、ランドワッカー、サム・ワイラー、そしてダンウィング。"
    },
    {
      "indent": 3,
      "text": "The earlier DomainKeys was a primary source from which DKIM was derived. Further information about DomainKeys is at [RFC4870].",
      "ja": "以前のDomainKeysは、DKIMが由来する一次ソースでした。ドメインキーについてのさらなる情報は、[RFC4870]です。"
    },
    {
      "indent": 3,
      "text": "This revision received contributions from Steve Atkins, Mark Delany, J.D. Falk, Jim Fenton, Michael Hammer, Barry Leiba, John Levine, Charles Lindsey, Jeff Macdonald, Franck Martin, Brett McDowell, Doug Otis, Bill Oxley, Hector Santos, Rolf Sonneveld, Michael Thomas, and Alessandro Vesely.",
      "ja": "この改正は、スティーブ・アトキンス、マーク・ディレイニー、JDフォーク、ジム・フェントン、マイケル・ハマー、バリー・レイバ、ジョン・レヴァイン、チャールズリンジー、ジェフ・マクドナルド、フランク・マーティン、ブレット・マクダウェル、ダグ・オーティス、ビル・オクスリー、ヘクターサントス、ロルフSonneveldから寄付を受けましたマイケル・トーマス、そしてアレッサンドロVesely。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Dave Crocker (editor) Brandenburg InternetWorking 675 Spruce Dr. Sunnyvale, CA 94086 USA",
      "ja": "デイブ・クロッカー（エディタ）ブランデンブルクインターネットワーキング675スプルース博士はカリフォルニア州サニーベール94086 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1.408.246.8253 EMail: dcrocker@bbiw.net URI: http://bbiw.net",
      "ja": "電話：+1.408.246.8253電子メール：dcrocker@bbiw.net URI：http://bbiw.net"
    },
    {
      "indent": 3,
      "text": "Tony Hansen (editor) AT&T Laboratories 200 Laurel Ave. South Middletown, NJ 07748 USA",
      "ja": "トニー・ハンセン（エディタ）AT＆T研究所200ローレルアベニュー。南ミドルタウン、NJ 07748 USA"
    },
    {
      "indent": 3,
      "text": "EMail: tony+dkimsig@maillennium.att.com",
      "ja": "メールアドレス：tony+dkimsig@maillennium.att.com"
    },
    {
      "indent": 3,
      "text": "Murray S. Kucherawy (editor) Cloudmark 128 King St., 2nd Floor San Francisco, CA 94107 USA",
      "ja": "マレーS. Kucherawy（エディタ）Cloudmarkの128キングセント、2階サンフランシスコ、CA 94107 USA"
    },
    {
      "indent": 3,
      "text": "EMail: msk@cloudmark.com",
      "ja": "メールアドレス：msk@cloudmark.com"
    }
  ]
}