{
  "title": {
    "text": "RFC 6675 - A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP",
    "ja": "RFC 6675 - TCPのための選択的確認応答（SACK）に基づいて保守的な損失回復アルゴリズム"
  },
  "number": 6675,
  "created_at": "2019-10-29 02:06:08.951374+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        E. Blanton\nRequest for Comments: 6675                             Purdue University\nObsoletes: 3517                                                M. Allman\nCategory: Standards Track                                           ICSI\nISSN: 2070-1721                                                  L. Wang\n                                                        Juniper Networks\n                                                             I. Jarvinen\n                                                                 M. Kojo\n                                                  University of Helsinki\n                                                              Y. Nishida\n                                                            WIDE Project\n                                                             August 2012",
      "raw": true
    },
    {
      "indent": 12,
      "text": "A Conservative Loss Recovery Algorithm Based on\n    Selective Acknowledgment (SACK) for TCP",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document presents a conservative loss recovery algorithm for TCP that is based on the use of the selective acknowledgment (SACK) TCP option. The algorithm presented in this document conforms to the spirit of the current congestion control specification (RFC 5681), but allows TCP senders to recover more effectively when multiple segments are lost from a single flight of data. This document obsoletes RFC 3517 and describes changes from it.",
      "ja": "この文書は、選択的確認応答（SACK）TCPオプションの使用に基づいているTCPのための保守的な損失回復アルゴリズムを提案します。この文書で提示するアルゴリズムは、現在の輻輳制御仕様（RFC 5681）の精神に準拠するが、複数のセグメントがデータの単一フライトから失われている場合に、TCP送信者がより効果的に回復することを可能にします。この文書はRFC 3517を廃止し、それからの変更点について説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6675.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6675で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2012 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document presents a conservative loss recovery algorithm for TCP that is based on the use of the selective acknowledgment (SACK) TCP option. While the TCP SACK option [RFC2018] is being steadily deployed in the Internet [All00], there is evidence that hosts are not using the SACK information when making retransmission and congestion control decisions [PF01]. The goal of this document is to outline one straightforward method for TCP implementations to use SACK information to increase performance.",
      "ja": "この文書は、選択的確認応答（SACK）TCPオプションの使用に基づいているTCPのための保守的な損失回復アルゴリズムを提案します。 TCP SACKオプション[RFC2018]は着実に[All00]インターネットで展開されている間、再送信と輻輳制御の決定[PF01]を行うときにホストがSACK情報を使用していないという証拠があります。このドキュメントの目標は、TCPの実装は、パフォーマンスを向上させるためにSACK情報を使用するための1つの簡単な方法を概説することです。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] allows advanced loss recovery algorithms to be used by TCP [RFC793] provided that they follow the spirit of TCP's congestion control algorithms [RFC5681] [RFC2914]. [RFC6582] outlines one such advanced recovery algorithm called NewReno. This document outlines a loss recovery algorithm that uses the SACK TCP option [RFC2018] to enhance TCP's loss recovery. The algorithm outlined in this document, heavily based on the algorithm detailed in [FF96], is a conservative replacement of the fast recovery algorithm [Jac90] [RFC5681]. The algorithm specified in this document is a straightforward SACK-based loss recovery strategy that follows the guidelines set in [RFC5681] and can safely be used in TCP implementations. Alternate SACK-based loss recovery methods can be used in TCP as implementers see fit (as long as the alternate algorithms follow the guidelines provided in [RFC5681]). Please note, however, that the SACK-based decisions in this document (such as what segments are to be sent at what time) are largely decoupled from the congestion control algorithms, and as such can be treated as separate issues if so desired.",
      "ja": "[RFC5681]は、高度な損失回復アルゴリズムはTCP [RFC793]彼らはTCPの輻輳制御アルゴリズム[RFC5681] [RFC2914]の精神に従うことを提供することで使用することができます。 [RFC6582]はNewRenoのと呼ばれるそのような高度な回復アルゴリズムを概説します。このドキュメントでは、TCPの損失回復を強化するためのSACK TCPオプション[RFC2018]を使用して損失回復アルゴリズムの概要を説明します。本文書で概説アルゴリズムは、高濃度[FF96]に詳述されたアルゴリズムに基づいて、高速回復アルゴリズム[Jac90] [RFC5681]の保存的置換です。この文書で指定されたアルゴリズムは[RFC5681]で設定したガイドラインに従い、安全にTCPの実装に使用することができ、簡単SACKベースの損失回復戦略です。実装が合うように交互のSACKベースの損失回復方法がTCPで使用することができる（代替アルゴリズムは[RFC5681]に提供されたガイドラインに従っている限り）。 （そのようなセグメントが何時送信されるものなど）は、この文書に記載されているSACKベースの決定が大きく輻輳制御アルゴリズムから分離され、そして所望の場合のような別の問題として扱うことができることは、ご注意ください。"
    },
    {
      "indent": 3,
      "text": "This document represents a revision of [RFC3517] to address several situations that are not handled explicitly in that document. A summary of the changes between this document and [RFC3517] can be found in Section 9.",
      "ja": "この文書は、その文書には明示的に処理されていないいくつかの状況に対処するために、[RFC3517]のリビジョンを表します。この文書と[RFC3517]の間の変更の概要は、セクション9に見出すことができます。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2.定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますBCP 14、RFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The reader is expected to be familiar with the definitions given in [RFC5681].",
      "ja": "読者は[RFC5681]で与えられた定義に精通していることが予想されます。"
    },
    {
      "indent": 3,
      "text": "The reader is assumed to be familiar with selective acknowledgments as specified in [RFC2018].",
      "ja": "読者は[RFC2018]で指定されるように選択的確認応答に精通しているものとします。"
    },
    {
      "indent": 3,
      "text": "For the purposes of explaining the SACK-based loss recovery algorithm, we define six variables that a TCP sender stores:",
      "ja": "SACKベースの損失回復アルゴリズムを説明する目的のために、私たちはそのTCP送信店6つの変数を定義します。"
    },
    {
      "indent": 6,
      "text": "\"HighACK\" is the sequence number of the highest byte of data that has been cumulatively ACKed at a given point.",
      "ja": "「HighACKは、」累積的に与えられた時点でACKされたデータの最上位バイトのシーケンス番号です。"
    },
    {
      "indent": 6,
      "text": "\"HighData\" is the highest sequence number transmitted at a given point.",
      "ja": "「HighData」は、所与の時点で送信された最も高いシーケンス番号です。"
    },
    {
      "indent": 6,
      "text": "\"HighRxt\" is the highest sequence number which has been retransmitted during the current loss recovery phase.",
      "ja": "「HighRxtは、」現在の損失回復フェーズ中に再送されたシーケンス番号が最大です。"
    },
    {
      "indent": 6,
      "text": "\"RescueRxt\" is the highest sequence number which has been optimistically retransmitted to prevent stalling of the ACK clock when there is loss at the end of the window and no new data is available for transmission.",
      "ja": "「RescueRxtは」楽観そこ損失は、ウィンドウの端にありかつ新たなデータが伝送のために使用できない場合ACKクロックの失速を防ぐために再送信されたシーケンス番号が最大です。"
    },
    {
      "indent": 6,
      "text": "\"Pipe\" is a sender's estimate of the number of bytes outstanding in the network. This is used during recovery for limiting the sender's sending rate. The pipe variable allows TCP to use fundamentally different congestion control than the algorithm specified in [RFC5681]. The congestion control algorithm using the pipe estimate is often referred to as the \"pipe algorithm\".",
      "ja": "「パイプ」、ネットワーク内の未処理のバイト数の送信者の推定値です。これは、送信者の送信速度を制限するためのリカバリ時に使用されています。パイプ変数は、TCPは、[RFC5681]で指定されたアルゴリズムは基本的に異なる輻輳制御を使用することを可能にします。パイプの推定値を使用して、輻輳制御アルゴリズムは、しばしば「パイプアルゴリズム」と呼ばれます。"
    },
    {
      "indent": 6,
      "text": "\"DupAcks\" is the number of duplicate acknowledgments received since the last cumulative acknowledgment.",
      "ja": "「DupAcksは、」最後の累積承認以降に受信された重複確認応答の数です。"
    },
    {
      "indent": 3,
      "text": "For the purposes of this specification, we define a \"duplicate acknowledgment\" as a segment that arrives carrying a SACK block that identifies previously unacknowledged and un-SACKed octets between HighACK and HighData. Note that an ACK which carries new SACK data is counted as a duplicate acknowledgment under this definition even if it carries new data, changes the advertised window, or moves the cumulative acknowledgment point, which is different from the definition of duplicate acknowledgment in [RFC5681].",
      "ja": "本明細書の目的のために、我々はHighACKとHighDataの間に以前に未確認と非解雇オクテットを識別するSACKブロックを運ぶ到着セグメントとして「重複確認応答」を定義します。新しいSACKデータを運ぶACKは、それが、新たなデータを運ぶ広告ウィンドウを変更し、または、重複確認応答の定義とは異なる累積確認応答ポイントを移動しても、この定義の下で重複確認応答としてカウントされることに注意してください[RFC5681] 。"
    },
    {
      "indent": 3,
      "text": "We define a variable \"DupThresh\" that holds the number of duplicate acknowledgments required to trigger a retransmission. Per [RFC5681], this threshold is defined to be 3 duplicate acknowledgments. However, implementers should consult any updates to [RFC5681] to determine the current value for DupThresh (or method for determining its value).",
      "ja": "私たちは、再送をトリガするために必要な重複確認応答の数を保持する変数「DupThresh」を定義します。 [RFC5681]あたり、この閾値は3つの重複肯定応答であると定義されます。しかし、実装者は現在DupThreshの値（またはその値を決定するための方法）を決定するために、[RFC5681]に更新を相談してください。"
    },
    {
      "indent": 3,
      "text": "Finally, a range of sequence numbers [A,B] is said to \"cover\" sequence number S if A <= S <= B.",
      "ja": "<= S <= Bの場合、最終的に、シーケンス番号[A、B]の範囲は、 \"カバー\" シーケンス番号Sと言われています"
    },
    {
      "indent": 0,
      "text": "3. Keeping Track of SACK Information",
      "section_title": true,
      "ja": "3. SACK情報を追跡します"
    },
    {
      "indent": 3,
      "text": "For a TCP sender to implement the algorithm defined in the next section, it must keep a data structure to store incoming selective acknowledgment information on a per connection basis. Such a data structure is commonly called the \"scoreboard\". The specifics of the scoreboard data structure are out of scope for this document (as long as the implementation can perform all functions required by this specification).",
      "ja": "TCPの送信者は、次のセクションで定義されたアルゴリズムを実装するためには、接続ごとに着信選択送達確認情報を格納するためのデータ構造を維持する必要があります。このようなデータ構造は、一般に「スコアボード」と呼ばれています。 （実装が本明細書に必要なすべての機能を実行することができる限り）スコアボードデータ構造の詳細は、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Note that this document refers to keeping account of (marking) individual octets of data transferred across a TCP connection. A real-world implementation of the scoreboard would likely prefer to manage this data as sequence number ranges. The algorithms presented here allow this, but require the ability to mark arbitrary sequence number ranges as having been selectively acknowledged.",
      "ja": "このドキュメントは、TCP接続を介して転送されるデータの個々のオクテット（マーキング）のアカウントを維持することをいいます。スコアボードの実世界の実装では、おそらく、シーケンス番号範囲として、このデータを管理することを好むだろう。ここで紹介するアルゴリズムは、これを許可しますが、任意のシーケンス番号をマークする能力を必要とし、選択的に認められたものとの範囲です。"
    },
    {
      "indent": 3,
      "text": "Finally, note that the algorithm in this document assumes a sender that is not keeping track of segment boundaries after transmitting a segment. It is possible that there is a more refined and precise algorithm available to a sender that keeps this extra state than the algorithm presented herein; however, we leave this as future work.",
      "ja": "最後に、この文書に記載されているアルゴリズムは、セグメントを送信した後、セグメント境界を追跡されていない送信者を想定していることに注意してください。本明細書で提示するアルゴリズムよりも、この余分な状態を維持し、送信者が利用可能な、より洗練された正確なアルゴリズムが存在することが可能です。しかし、我々は今後の作業として、このままにしておきます。"
    },
    {
      "indent": 0,
      "text": "4. Processing and Acting Upon SACK Information",
      "section_title": true,
      "ja": "4.処理とSACK情報に作用します"
    },
    {
      "indent": 3,
      "text": "This section describes a specific structure and control flow for implementing the TCP behavior described by this standard. The behavior is what is standardized, and this particular collection of functions is the strongly recommended means of implementing that behavior, though other approaches to achieving that behavior are feasible.",
      "ja": "このセクションでは、この規格で説明TCPの挙動を実現するための具体的な構造や制御の流れを説明しています。動作が標準化されたものであり、その行動を達成するための他のアプローチが可能であるにもかかわらず機能のこの特定のコレクションは、その動作を実装することを強く推奨手段です。"
    },
    {
      "indent": 3,
      "text": "The definition of Sender Maximum Segment Size (SMSS) used in this section is provided in [RFC5681].",
      "ja": "このセクションで使用される定義センダの最大セグメントサイズ（SMSS）は[RFC5681]に提供されます。"
    },
    {
      "indent": 3,
      "text": "For the purposes of the algorithm defined in this document, the scoreboard SHOULD implement the following functions:",
      "ja": "この文書で定義されたアルゴリズムの目的で、スコアボードには、以下の機能を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Update ():",
      "ja": "アップデート（）："
    },
    {
      "indent": 6,
      "text": "Given the information provided in an ACK, each octet that is cumulatively ACKed or SACKed should be marked accordingly in the scoreboard data structure, and the total number of octets SACKed should be recorded.",
      "ja": "ACKで提供される情報が与えられると、累積ACKさまたは解雇された各オクテットは、スコアボードデータ構造に応じてマークされるべきであり、解雇オクテットの総数が記録されるべきです。"
    },
    {
      "indent": 6,
      "text": "Note: SACK information is advisory and therefore SACKed data MUST NOT be removed from the TCP's retransmission buffer until the data is cumulatively acknowledged [RFC2018].",
      "ja": "注意：データが累積的に[RFC2018]を確認されるまで解雇ので、SACK情報が助言され、データはTCPの再送バッファから削除されてはなりません。"
    },
    {
      "indent": 3,
      "text": "IsLost (SeqNum):",
      "ja": "IsLost（SEQNUM）："
    },
    {
      "indent": 6,
      "text": "This routine returns whether the given sequence number is considered to be lost. The routine returns true when either DupThresh discontiguous SACKed sequences have arrived above 'SeqNum' or more than (DupThresh - 1) * SMSS bytes with sequence numbers greater than 'SeqNum' have been SACKed. Otherwise, the routine returns false.",
      "ja": "与えられたシーケンス番号が失われると考えられているかどうかをこのルーチン。 *「SEQNUM」より大きいシーケンス番号を持つSMSSバイトが解雇されています - 真のいずれかDupThreshの不連続は、シーケンスを解雇戻り、「SEQNUM」または（1 DupThresh）よりも上に到着しました。そうでなければ、ルーチンはfalseを返します。"
    },
    {
      "indent": 3,
      "text": "SetPipe ():",
      "ja": "SetPipe（）："
    },
    {
      "indent": 6,
      "text": "This routine traverses the sequence space from HighACK to HighData and MUST set the \"pipe\" variable to an estimate of the number of octets that are currently in transit between the TCP sender and the TCP receiver. After initializing pipe to zero, the following steps are taken for each octet 'S1' in the sequence space between HighACK and HighData that has not been SACKed:",
      "ja": "このルーチンは、HighACKからHighDataに配列スペースを横断し、TCPの送信側とTCP受信機の間の輸送に現在あるオクテットの数の推定値に「パイプ」変数を設定しなければなりません。ゼロにパイプを初期化した後、次のステップは解雇されていないHighACKとHighData間の配列空間中の各オクテット「S1」のために採取されます。"
    },
    {
      "indent": 6,
      "text": "(a) If IsLost (S1) returns false:",
      "ja": "（a）はIsLost（S1）がfalseを返した場合："
    },
    {
      "indent": 9,
      "text": "Pipe is incremented by 1 octet.",
      "ja": "パイプは1つのオクテットだけ増分されます。"
    },
    {
      "indent": 9,
      "text": "The effect of this condition is that pipe is incremented for packets that have not been SACKed and have not been determined to have been lost (i.e., those segments that are still assumed to be in the network).",
      "ja": "この条件の効果は、パイプが解雇されていないと（依然としてネットワークであると仮定され、すなわち、それらのセグメントを）失われたと判定されなかったパケットのために増加されることです。"
    },
    {
      "indent": 6,
      "text": "(b) If S1 <= HighRxt:",
      "ja": "（b）は、S1 <= HighRxt場合："
    },
    {
      "indent": 9,
      "text": "Pipe is incremented by 1 octet.",
      "ja": "パイプは1つのオクテットだけ増分されます。"
    },
    {
      "indent": 9,
      "text": "The effect of this condition is that pipe is incremented for the retransmission of the octet.",
      "ja": "この条件の効果は、パイプがオクテットの再送信のために増分されることです。"
    },
    {
      "indent": 6,
      "text": "Note that octets retransmitted without being considered lost are counted twice by the above mechanism.",
      "ja": "紛失したとみなされずに再送信オクテットは、上記のメカニズムによって2回カウントされることに注意してください。"
    },
    {
      "indent": 3,
      "text": "NextSeg ():",
      "ja": "NextSeg（）："
    },
    {
      "indent": 6,
      "text": "This routine uses the scoreboard data structure maintained by the Update() function to determine what to transmit based on the SACK information that has arrived from the data receiver (and hence been marked in the scoreboard). NextSeg () MUST return the sequence number range of the next segment that is to be transmitted, per the following rules:",
      "ja": "このルーチンは、データ受信機から到着している（従って、スコアボードでマークされて）SACK情報に基づいて送信するかを決定するために、更新（）関数によって維持スコアボードデータ構造を使用します。 NextSeg（）は、次のルールごとに、送信されるべき次のセグメントのシーケンス番号範囲を返さなければなりません。"
    },
    {
      "indent": 6,
      "text": "(1) If there exists a smallest unSACKed sequence number 'S2' that meets the following three criteria for determining loss, the sequence range of one segment of up to SMSS octets starting with S2 MUST be returned.",
      "ja": "損失を決定するための以下の3つの基準を満たす最小unSACKedシーケンス番号「S2」が存在する場合（1）、S2で開始SMSSオクテットまでの一つのセグメントのシーケンス範囲を返さなければなりません。"
    },
    {
      "indent": 10,
      "text": "(1.a) S2 is greater than HighRxt.",
      "ja": "（1.A）S2はHighRxtより大きい。"
    },
    {
      "indent": 10,
      "text": "(1.b) S2 is less than the highest octet covered by any received SACK.",
      "ja": "（1.B）S2は、任意の受信されたSACKによって覆わ最高オクテット未満です。"
    },
    {
      "indent": 10,
      "text": "(1.c) IsLost (S2) returns true.",
      "ja": "（1.C）IsLost（S2）がtrueを返します。"
    },
    {
      "indent": 6,
      "text": "(2) If no sequence number 'S2' per rule (1) exists but there exists available unsent data and the receiver's advertised window allows, the sequence range of one segment of up to SMSS octets of previously unsent data starting with sequence number HighData+1 MUST be returned.",
      "ja": "（2）もしシーケンス番号「S2」ルールあたり（1）存在しても存在し利用可能な未送信データが存在し、受信機の広告ウィンドウは、シーケンス番号から始めて、以前に未送信データのSMSSオクテットまでの一つのセグメントのシーケンスの範囲を可能にHighData +図1は、返さなければなりません。"
    },
    {
      "indent": 6,
      "text": "(3) If the conditions for rules (1) and (2) fail, but there exists an unSACKed sequence number 'S3' that meets the criteria for detecting loss given in steps (1.a) and (1.b) above (specifically excluding step (1.c)), then one segment of up to SMSS octets starting with S3 SHOULD be returned.",
      "ja": "（3）ルールの条件（1）及び（2）は失敗するが、工程（1.A）とで与えられた損失を検出するための基準を満たすunSACKedシーケンス番号「S3」が存在する場合（1.B）上記（具体的には、ステップ（1.C））を、次いでS3で開始SMSSオクテットまでのいずれかのセグメントが返されるべき除きます。"
    },
    {
      "indent": 6,
      "text": "(4) If the conditions for (1), (2), and (3) fail, but there exists outstanding unSACKed data, we provide the opportunity for a single \"rescue\" retransmission per entry into loss recovery. If HighACK is greater than RescueRxt (or RescueRxt is undefined), then one segment of up to SMSS octets that MUST include the highest outstanding unSACKed sequence number SHOULD be returned, and RescueRxt set to RecoveryPoint. HighRxt MUST NOT be updated.",
      "ja": "（4）の条件は（1）、（2）、及び（3）失敗した場合は、しかし、優れたunSACKedデータが存在し、我々は損失回復へのエントリごとに単一の「救出」再送信のための機会を提供します。 HighACKがRescueRxt（又はRescueRxtは不定である）よりも大きい場合、最高未処理unSACKedシーケンス番号を含める必要がありSMSSオクテットまでの一つのセグメントが返されるべきであり、RescueRxtはRecoveryPointに設定しました。 HighRxtが更新されてはなりません。"
    },
    {
      "indent": 10,
      "text": "Note that rules (3) and (4) are a sort of retransmission \"last\nresort\".  They allow for retransmission of sequence numbers\neven when the sender has less certainty a segment has been lost than as with rule (1).  Retransmitting segments via rule\n(3) and (4) will help sustain the TCP's ACK clock and\ntherefore can potentially help avoid retransmission timeouts.\nHowever, in sending these segments, the sender has two copies\nof the same data considered to be in the network (and also in\nthe pipe estimate, in the case of (3)).  When an ACK or SACK\narrives covering this retransmitted segment, the sender cannot\nbe sure exactly how much data left the network (one of the two\ntransmissions of the packet or both transmissions of the\npacket).  Therefore, the sender may underestimate pipe by\nconsidering both segments to have left the network when it is\npossible that only one of the two has.",
      "raw": true
    },
    {
      "indent": 6,
      "text": "(5) If the conditions for each of (1), (2), (3), and (4) are not met, then NextSeg () MUST indicate failure, and no segment is returned.",
      "ja": "（5）（1）、（2）、（3）及び（4）が満たされていないのそれぞれの条件は、次にNextSeg（）が失敗したことを示さなければなりません、そしていかなるセグメントが返されない場合。"
    },
    {
      "indent": 3,
      "text": "Note: The SACK-based loss recovery algorithm outlined in this document requires more computational resources than previous TCP loss recovery strategies. However, we believe the scoreboard data structure can be implemented in a reasonably efficient manner (both in terms of computation complexity and memory usage) in most TCP implementations.",
      "ja": "注：このドキュメントで概説SACKベースの損失回復アルゴリズムは、以前のTCPの損失回復戦略よりも多くの計算資源を必要とします。しかし、我々は、スコアボードのデータ構造は、ほとんどのTCPの実装に（両方の計算の複雑さとメモリ使用量の観点で）合理的に効率的な方法で実現することができると信じています。"
    },
    {
      "indent": 0,
      "text": "5. Algorithm Details",
      "section_title": true,
      "ja": "5.アルゴリズム詳細"
    },
    {
      "indent": 3,
      "text": "Upon the receipt of any ACK containing SACK information, the scoreboard MUST be updated via the Update () routine.",
      "ja": "SACK情報を含む任意のACKを受信すると、スコアボードは、更新（）ルーチンを介して更新されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the incoming ACK is a cumulative acknowledgment, the TCP MUST reset DupAcks to zero.",
      "ja": "入ってくるACKは、累積確認された場合、TCPはゼロにDupAcksをリセットする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the incoming ACK is a duplicate acknowledgment per the definition in Section 2 (regardless of its status as a cumulative acknowledgment), and the TCP is not currently in loss recovery, the TCP MUST increase DupAcks by one and take the following steps:",
      "ja": "入ってくるACKが（関係なく、累積確認応答としての地位の）第2節での定義に従って重複確認応答であり、TCPは損失回復中でない場合は、TCPは1でDupAcksを増加させて、次の手順を実行する必要があります"
    },
    {
      "indent": 3,
      "text": "(1) If DupAcks >= DupThresh, go to step (4).",
      "ja": "DupAcks> = DupThresh場合（1）、（4）に進みます。"
    },
    {
      "indent": 7,
      "text": "Note: This check covers the case when a TCP receives SACK\ninformation for multiple segments smaller than SMSS, which can\npotentially prevent IsLost() (next step) from declaring a segment\nas lost.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(2) If DupAcks < DupThresh but IsLost (HighACK + 1) returns true -- indicating at least three segments have arrived above the current cumulative acknowledgment point, which is taken to indicate loss -- go to step (4).",
      "ja": "（2）DupAcks <DupThreshしかしIsLost（HighACK + 1）がtrueを返す場合 - 少なくとも三つのセグメントが損失を示すと解釈される現在の累積確認応答ポイント、上に到着したことを示す - （4）に進みます。"
    },
    {
      "indent": 3,
      "text": "(3) The TCP MAY transmit previously unsent data segments as per Limited Transmit [RFC5681], except that the number of octets which may be sent is governed by pipe and cwnd as follows:",
      "ja": "（3）TCPは、以下のように送信することができるオクテットの数がパイプとCWNDによって支配されることを除いて、限定送信[RFC5681]に従って以前に未送信のデータセグメントを送信することができます。"
    },
    {
      "indent": 7,
      "text": "(3.1) Set HighRxt to HighACK.",
      "ja": "（3.1）HighACKに設定HighRxt。"
    },
    {
      "indent": 7,
      "text": "(3.2) Run SetPipe ().",
      "ja": "（3.2）を実行しSetPipe（）。"
    },
    {
      "indent": 7,
      "text": "(3.3) If (cwnd - pipe) >= 1 SMSS, there exists previously unsent data, and the receiver's advertised window allows, transmit up to 1 SMSS of data starting with the octet HighData+1 and update HighData to reflect this transmission, then return to (3.2).",
      "ja": "（3.3）の場合（CWND  - パイプ）> = 1 SMSSは、以前に未送信データが存在し、受信機の広告ウィンドウは、次いで、オクテットHighData + 1から始まるデータの1 SMSSまで送信し、この送信を反映するためにHighDataを更新可能（3.2）に戻ります。"
    },
    {
      "indent": 7,
      "text": "(3.4) Terminate processing of this ACK.",
      "ja": "（3.4）このACKの処理を終了します。"
    },
    {
      "indent": 3,
      "text": "(4) Invoke fast retransmit and enter loss recovery as follows:",
      "ja": "（4）高速な再送信を起動し、次のように損失回復を入力します。"
    },
    {
      "indent": 7,
      "text": "(4.1) RecoveryPoint = HighData",
      "ja": "（4.1）RecoveryPoint = HighData"
    },
    {
      "indent": 13,
      "text": "When the TCP sender receives a cumulative ACK for this data\noctet, the loss recovery phase is terminated.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "(4.2) ssthresh = cwnd = (FlightSize / 2)",
      "ja": "（4.2）SSTHRESH = CWND =（FlightSize / 2）"
    },
    {
      "indent": 13,
      "text": "The congestion window (cwnd) and slow start threshold\n(ssthresh) are reduced to half of FlightSize per [RFC5681].\nAdditionally, note that [RFC5681] requires that any\nsegments sent as part of the Limited Transmit mechanism not\nbe counted in FlightSize for the purpose of the above\nequation.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "(4.3) Retransmit the first data segment presumed dropped -- the segment starting with sequence number HighACK + 1. To prevent repeated retransmission of the same data or a premature rescue retransmission, set both HighRxt and RescueRxt to the highest sequence number in the retransmitted segment.",
      "ja": "セグメントは、同じデータまたは早期救出再送の繰り返し再送信を防止するために、シーケンス番号HighACK + 1から始まる、再送セグメントで最も高いシーケンス番号にHighRxtとRescueRxt両方を設定 - （4.3）は、推定第1のデータセグメントがドロップ再送します。"
    },
    {
      "indent": 7,
      "text": "(4.4) Run SetPipe ()",
      "ja": "（4.4）を実行しSetPipe（）"
    },
    {
      "indent": 13,
      "text": "Set a \"pipe\" variable to the number of outstanding octets\ncurrently \"in the pipe\"; this is the data which has been\nsent by the TCP sender but for which no cumulative or\nselective acknowledgment has been received and the data has\nnot been determined to have been dropped in the network.\nIt is assumed that the data is still traversing the network\npath.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "(4.5) In order to take advantage of potential additional available cwnd, proceed to step (C) below.",
      "ja": "（4.5）は、潜在的な利用できるCWNDを利用するため、以下の（c）に進みます。"
    },
    {
      "indent": 3,
      "text": "Once a TCP is in the loss recovery phase, the following procedure MUST be used for each arriving ACK:",
      "ja": "TCPは損失回復段階になったら、次の手順では、各到着ACKを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "(A) An incoming cumulative ACK for a sequence number greater than RecoveryPoint signals the end of loss recovery, and the loss recovery phase MUST be terminated. Any information contained in the scoreboard for sequence numbers greater than the new value of HighACK SHOULD NOT be cleared when leaving the loss recovery phase.",
      "ja": "（A）RecoveryPointより大きいシーケンス番号の着信累積ACKが損失回復の終わりを、損失回復フェーズが終了しなければなりません。損失の回復期を出るときHighACKの新しい値よりも大きいシーケンス番号のためのスコアボードに含まれるすべての情報をクリアしないでください。"
    },
    {
      "indent": 3,
      "text": "(B) Upon receipt of an ACK that does not cover RecoveryPoint, the following actions MUST be taken:",
      "ja": "RecoveryPointをカバーしていないACKを受信すると（B）は、以下のアクションを取らなければなりません。"
    },
    {
      "indent": 7,
      "text": "(B.1) Use Update () to record the new SACK information conveyed\n      by the incoming ACK.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "(B.2) Use SetPipe () to re-calculate the number of octets still in the network.",
      "ja": "（B.2）の使用SetPipe（）ネットワークではまだオクテットの数を再計算します。"
    },
    {
      "indent": 3,
      "text": "(C) If cwnd - pipe >= 1 SMSS, the sender SHOULD transmit one or more segments as follows:",
      "ja": "（C）CWND場合 - パイプ> = 1 SMSS次のように、送信者は、1つ以上のセグメントを送信しなければなりません。"
    },
    {
      "indent": 7,
      "text": "(C.1) The scoreboard MUST be queried via NextSeg () for the\n      sequence number range of the next segment to transmit (if\n      any), and the given segment sent.  If NextSeg () returns\n      failure (no data to send), return without sending anything\n      (i.e., terminate steps C.1 -- C.5).",
      "raw": true
    },
    {
      "indent": 7,
      "text": "(C.2) If any of the data octets sent in (C.1) are below HighData, HighRxt MUST be set to the highest sequence number of the retransmitted segment unless NextSeg () rule (4) was invoked for this retransmission.",
      "ja": "（C.1）で送信されたデータオクテットのいずれかHighData未満である場合NextSeg（）の規則（4）は、この再送信のために呼び出された場合を除き（C.2）、HighRxtは再送セグメントの最高のシーケンス番号に設定しなければなりません。"
    },
    {
      "indent": 7,
      "text": "(C.3) If any of the data octets sent in (C.1) are above HighData, HighData must be updated to reflect the transmission of previously unsent data.",
      "ja": "（C.1）で送信されたデータオクテットのいずれかHighDataを超えている場合（C.3）は、HighDataは、以前に未送信データの送信を反映するように更新されなければなりません。"
    },
    {
      "indent": 7,
      "text": "(C.4) The estimate of the amount of data outstanding in the network must be updated by incrementing pipe by the number of octets transmitted in (C.1).",
      "ja": "（C.4）ネットワーク内の未処理データの量の推定値は、（C.1）に送信されたオクテットの数でパイプをインクリメントして更新しなければなりません。"
    },
    {
      "indent": 7,
      "text": "(C.5) If cwnd - pipe >= 1 SMSS, return to (C.1)",
      "ja": "（C.5）CWND場合 - パイプ> = 1 SMSS、（C.1）に戻ります"
    },
    {
      "indent": 3,
      "text": "Note that steps (A) and (C) can potentially send a burst of back-to-back segments into the network if the incoming cumulative acknowledgment is for more than SMSS octets of data, or if incoming SACK blocks indicate that more than SMSS octets of data have been lost in the second half of the window.",
      "ja": "着信累積確認応答を超えるデータSMSSオクテットのためのものである場合、ステップ（A）及び（C）は、潜在的にネットワーク内にバック・ツー・バックセグメントのバーストを送信することができることに注意してください、または着信SACKブロックはそれ以上SMSSオクテットを示す場合データのウィンドウの後半に失われています。"
    },
    {
      "indent": 0,
      "text": "5.1. Retransmission Timeouts",
      "section_title": true,
      "ja": "5.1. 再送信タイムアウト"
    },
    {
      "indent": 3,
      "text": "In order to avoid memory deadlocks, the TCP receiver is allowed to discard data that has already been selectively acknowledged. As a result, [RFC2018] suggests that a TCP sender SHOULD expunge the SACK information gathered from a receiver upon a retransmission timeout (RTO) \"since the timeout might indicate that the data receiver has reneged.\" Additionally, a TCP sender MUST \"ignore prior SACK information in determining which data to retransmit.\" However, since the publication of [RFC2018], this has come to be viewed by some as too strong. It has been suggested that, as long as robust tests for reneging are present, an implementation can retain and use SACK information across a timeout event [Errata1610]. While this document does not change the specification in [RFC2018], we note that implementers should consult any updates to [RFC2018] on this subject. Further, a SACK TCP sender SHOULD utilize all SACK information made available during the loss recovery following an RTO.",
      "ja": "メモリデッドロックを回避するためには、TCP受信機はすでに選択認められているデータを破棄するように許可されています。結果として、[RFC2018]は、TCP送信側が再送タイムアウト（RTO）の際に受信機から収集SACK情報を抹消すべきであることを示唆している「タイムアウトがデータ受信機が破ったことを示すかもしれないからです。」また、TCPの送信者は、「再送信するためにどのデータを決定する際に事前SACK情報を無視します。」しなければなりませんただし、[RFC2018]の出版以来、これが強すぎるとして、一部で見られるようになってきました。実装がタイムアウトイベント[Errata1610]横切っSACK情報を保持し、使用することができ、renegingため限りロバストなテストが存在している、ことが示唆されています。このドキュメントは[RFC2018]で指定を変更しませんが、我々は、実装者は、このテーマに関する[RFC2018]への更新に相談すべきであることに注意してください。さらに、SACKのTCPの送信者は、RTO以下の損失回復の際に利用できるように、すべてのSACK情報を活用すべきです。"
    },
    {
      "indent": 3,
      "text": "If an RTO occurs during loss recovery as specified in this document, RecoveryPoint MUST be set to HighData. Further, the new value of RecoveryPoint MUST be preserved and the loss recovery algorithm outlined in this document MUST be terminated. In addition, a new recovery phase (as described in Section 5) MUST NOT be initiated until HighACK is greater than or equal to the new value of RecoveryPoint.",
      "ja": "この文書で指定されたRTOが損失回復中に発生した場合、RecoveryPointはHighDataに設定しなければなりません。さらに、RecoveryPointの新しい値が保存されなければならないし、この文書で概説損失回復アルゴリズムを終えなければなりません。 HighACKはRecoveryPointの新しい値以上になるまで加えて、新たな回復期（セクション5に記載されているように）を開始してはいけません。"
    },
    {
      "indent": 3,
      "text": "As described in Sections 4 and 5, Update () SHOULD continue to be used appropriately upon receipt of ACKs. This will allow the recovery period after an RTO to benefit from all available information provided by the receiver, even if SACK information was expunged due to the RTO.",
      "ja": "セクション4および5に記載されているように、更新（）ACKの受信時に適切に使用され続けるべきです。これはRTO後の回復期間はSACK情報がRTOのために消去された場合でも、受信機が提供するすべての入手可能な情報から利益を得ることができます。"
    },
    {
      "indent": 3,
      "text": "If there are segments missing from the receiver's buffer following processing of the retransmitted segment, the corresponding ACK will contain SACK information. In this case, a TCP sender SHOULD use this SACK information when determining what data should be sent in each segment following an RTO. The exact algorithm for this selection is not specified in this document (specifically NextSeg () is inappropriate during loss recovery after an RTO). A relatively straightforward approach to \"filling in\" the sequence space reported as missing should be a reasonable approach.",
      "ja": "再送セグメントの処理に続いて受信機のバッファから欠落しているセグメントが存在する場合、対応するACKは、SACK情報を含むことになります。データがRTO以下、各セグメントで送信されるべきか決定する際、この場合には、TCP送信者は、このSACK情報を使用すべきです。この選択のための正確なアルゴリズムは、（具体的NextSeg（）はRTO後に損失回復中に不適切である）、この文書で指定されていません。不足しているとして報告された配列スペース「を埋める」ために、比較的簡単な方法は、合理的なアプローチでなければなりません。"
    },
    {
      "indent": 0,
      "text": "6. Managing the RTO Timer",
      "section_title": true,
      "ja": "6. RTOタイマーを管理します"
    },
    {
      "indent": 3,
      "text": "The standard TCP RTO estimator is defined in [RFC6298]. Due to the fact that the SACK algorithm in this document can have an impact on the behavior of the estimator, implementers may wish to consider how the timer is managed. [RFC6298] calls for the RTO timer to be re-armed each time an ACK arrives that advances the cumulative ACK point. Because the algorithm presented in this document can keep the ACK clock going through a fairly significant loss event (comparatively longer than the algorithm described in [RFC5681]), on some networks the loss event could last longer than the RTO. In this case the RTO timer would expire prematurely and a segment that need not be retransmitted would be resent.",
      "ja": "標準のTCP RTO推定は、[RFC6298]で定義されています。これによって文書のSACKアルゴリズムは、推定の行動に影響を与えることができるという事実のために、実装者はタイマーが管理されている方法を検討することを望むかもしれません。 RTOタイマが累積ACK点を進めるACKが到着するたびに再武装するために[RFC6298]はコール。この文書で提示したアルゴリズムは、かなり大きな損失イベントを通過ACKクロックを保つことができるので（[RFC5681]で説明したアルゴリズムよりも比較的長い）、いくつかのネットワーク上の損失事象は長いRTOよりも続く可能性が。この場合、RTOタイマが早まって期限切れになり、再送信する必要はないセグメントが再送されるだろう。"
    },
    {
      "indent": 3,
      "text": "Therefore, we give implementers the latitude to use the standard [RFC6298]-style RTO management or, optionally, a more careful variant that re-arms the RTO timer on each retransmission that is sent during recovery MAY be used. This provides a more conservative timer than specified in [RFC6298], and so may not always be an attractive alternative. However, in some cases it may prevent needless retransmissions, go-back-N transmission, and further reduction of the congestion window.",
      "ja": "したがって、我々は、実装に必要に応じて、標準的な[RFC6298]スタイルRTO管理や、回復中に送信された各再送で再アームRTOタイマを使用することができるより慎重変異体を使用する自由度を与えます。これは、[RFC6298]で指定されたよりも多くの保守的なタイマーを提供し、そのため常に魅力的な選択肢ではないかもしれません。しかし、いくつかのケースでは、外出先バック-Nの伝送、および輻輳ウィンドウの更なる削減、不必要な再送信を防ぐことができます。"
    },
    {
      "indent": 0,
      "text": "7. Research",
      "section_title": true,
      "ja": "7.研究"
    },
    {
      "indent": 3,
      "text": "The algorithm specified in this document is analyzed in [FF96], which shows that the above algorithm is effective in reducing transfer time over standard TCP Reno [RFC5681] when multiple segments are dropped from a window of data (especially as the number of drops increases). [AHKO97] shows that the algorithm defined in this document can greatly improve throughput in connections traversing satellite channels.",
      "ja": "複数のセグメントは、データのウィンドウから削除されたときに、この文書で指定されたアルゴリズムは、特に小滴の数が増加するように（[FF96]、上記のアルゴリズムは、標準TCPリノ上の転送時間を短縮するのに有効であることを示している[RFC5681]で分析されます）。 【AHKO97]この文書で定義されたアルゴリズムが大きく、衛星放送チャンネルを横断する接続におけるスループットを向上させることができることを示しています。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The algorithm presented in this paper shares security considerations with [RFC5681]. A key difference is that an algorithm based on SACKs is more robust against attackers forging duplicate ACKs to force the TCP sender to reduce cwnd. With SACKs, TCP senders have an additional check on whether or not a particular ACK is legitimate. While not fool-proof, SACK does provide some amount of protection in this area.",
      "ja": "[RFC5681]でこの論文を共有セキュリティの考慮事項に提示したアルゴリズム。主な違いは、袋に基づくアルゴリズムはcwndのを軽減するためにTCPの送信者を強制的に重複ACKを偽造攻撃者に対してより堅牢であるということです。サックスでは、TCPの送信者は、特定のACKが正当であるか否かの追加のチェックを持っています。ばかプルーフされていないが、SACKは、この分野での保護のいくつかの量を提供しません。"
    },
    {
      "indent": 3,
      "text": "Similarly, [CPNI309] sketches a variant of a blind attack [RFC5961] whereby an attacker can spoof out-of-window data to a TCP endpoint, causing it to respond to the legitimate peer with a duplicate cumulative ACK, per [RFC793]. Adding a SACK-based requirement to trigger loss recovery effectively mitigates this attack, as the duplicate ACKs caused by out-of-window segments will not contain SACK information indicating reception of previously un-SACKED in-window data.",
      "ja": "攻撃者は[RFC793]あたりそれは、重複の累積ACKと正規のピアに応答させ、TCPエンドポイントにアウト・オブ・ウィンドウのデータを偽造することができる。同様に、[CPNI309]ブラインド攻撃[RFC5961]のバリアントをスケッチ。重複ACKが以前に未解雇におけるウィンドウのデータの受信を示すSACK情報を含まない外のウィンドウセグメントによって引き起こされるような効果的損失の回復をトリガするSACKベースの要件を追加すると、この攻撃を軽減します。"
    },
    {
      "indent": 1,
      "text": "9. Changes Relative to",
      "section_title": true,
      "ja": "への相対9.変更"
    },
    {
      "indent": 3,
      "text": "The state variable \"DupAcks\" has been added to the list of variables maintained by this algorithm, and its usage specified.",
      "ja": "状態変数「DupAcks」は、このアルゴリズムによって維持された変数のリストに追加された、およびその使用方法は、指定されました。"
    },
    {
      "indent": 3,
      "text": "The function IsLost () has been modified to require that more than (DupThresh - 1) * SMSS octets have been SACKed above a given sequence number as indication that it is lost, which is changed from the minimum requirement of (DupThresh * SMSS) described in [RFC3517]. This retains the requirement that at least three segments following the sequence number in question have been SACKed, while improving detection in the event that the sender has outstanding segments which are smaller than SMSS.",
      "ja": "* SMSSオクテット（DupThresh * SMSS）の最小要件から変更され、それが失われることを示す、として与えられたシーケンス番号上に解雇されている説明 - 機能IsLost（）は、（1 DupThresh）以上にすることを要求するように改変されています[RFC3517]インチこれは、送信者がSMSSよりも小さい優れたセグメントを持っていた場合に検出を改善しながら、問題のシーケンス番号を、以下の少なくとも三つのセグメントは、解雇されている要件を保持します。"
    },
    {
      "indent": 3,
      "text": "The definition of a \"duplicate acknowledgment\" has been modified to utilize the SACK information in detecting loss. Duplicate cumulative acknowledgments can be caused by either loss or reordering in the network. To disambiguate loss and reordering, TCP's fast retransmit algorithm [RFC5681] waits until three duplicate ACKs arrive to trigger loss recovery. This notion was then the basis for the algorithm specified in [RFC3517]. However, with SACK information there is no need to rely blindly on the cumulative acknowledgment field. We can leverage the additional information present in the SACK blocks to understand that three segments lying above a gap in the sequence space have arrived at the receiver, and can use this understanding to trigger loss recovery. This notion was used in [RFC3517] during loss recovery, and the change in this document is that the notion is also used to enter a loss recovery phase.",
      "ja": "「重複確認応答」の定義は、損失を検出するSACK情報を利用するように変更されました。重複の累積確認応答は、ネットワーク内のいずれかの損失または並べ替えによって引き起こされ得ます。 3つの重複ACKが損失回復をトリガするために到着するまでの損失や並べ替えを明確にするには、TCPの高速再送アルゴリズム[RFC5681]は待ちます。この概念は、[RFC3517]で指定されたアルゴリズムのための基礎となりました。しかし、SACK情報を累積確認応答フィールドに盲目的に頼る必要はありません。私たちは、シーケンス空間のギャップの上にある三つのセグメントが受信機に到着した、と損失回復をトリガするために、この理解を使用できることを理解することがSACKブロック内の追加情報の存在を活用することができます。この概念は、損失回復時に[RFC3517]で使用された、そしてこの文書の変更は、概念はまた、損失の回復局面を入力するために使用されていることです。"
    },
    {
      "indent": 3,
      "text": "The state variable \"RescueRxt\" has been added to the list of variables maintained by the algorithm, and its usage specified. This variable is used to allow for one extra retransmission per entry into loss recovery, in order to keep the ACK clock going under certain circumstances involving loss at the end of the window. This mechanism allows for no more than one segment of no larger than 1 SMSS to be optimistically retransmitted per loss recovery.",
      "ja": "状態変数「RescueRxtは、」アルゴリズムによって維持される変数のリストに追加された、およびその使用方法は、指定されました。この変数は、ウィンドウの終了時に損失を伴う特定の状況下で起こってACKクロックを維持するために、損失回復へのエントリごとに1つの余分の再送を可能にするために使用されます。この機構は、楽観的損失回復ごとに再送すべき大きく1以下SMSSのない複数のセグメントを可能にします。"
    },
    {
      "indent": 3,
      "text": "Rule (3) of NextSeg() has been changed from MAY to SHOULD, to appropriately reflect the opinion of the authors and working group that it should be left in, rather than out, if an implementor does not have a compelling reason to do otherwise.",
      "ja": "NextSegのルール（3）は、（）適切に著者の意見や実装がそうでなければ行うには説得力のある理由を持っていない場合、それは、むしろアウトよりも、中に残されるべきワーキンググループを反映するために、SHOULDにMAYから変更されました。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgments",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Sally Floyd for encouraging [RFC3517] and commenting on early drafts. The algorithm described in this document is loosely based on an algorithm outlined by Kevin Fall and Sally Floyd in [FF96], although the authors of this document assume responsibility for any mistakes in the above text.",
      "ja": "著者は、[RFC3517]を奨励し、初期の草稿にコメントがサリーフロイドに感謝したいです。この文書の著者は上記のテキストに間違いの責任を負うが、この文書に記載されたアルゴリズムは緩く、[FF96]でケビン・秋とサリー・フロイドによって概説されたアルゴリズムに基づいています。"
    },
    {
      "indent": 3,
      "text": "[RFC3517] was co-authored by Kevin Fall, who provided crucial input to that document and hence this follow-on work.",
      "ja": "[RFC3517]はそのドキュメントへの重要な入力を提供し、したがって、これは後続の作業ケビン秋、共著しました。"
    },
    {
      "indent": 3,
      "text": "Murali Bashyam, Ken Calvert, Tom Henderson, Reiner Ludwig, Jamshid Mahdavi, Matt Mathis, Shawn Ostermann, Vern Paxson, and Venkat Venkatsubra provided valuable feedback on earlier versions of this document.",
      "ja": "ムラリBashyam、ケン・カルバート、トム・ヘンダーソン、ライナールートヴィヒ、ジャムシードMahdavi、マット・マシス、ショーンOstermann、バーン・パクソン、およびVenkatさんVenkatsubraはこのドキュメントの以前のバージョンの貴重なフィードバックを提供します。"
    },
    {
      "indent": 3,
      "text": "We thank Matt Mathis and Jamshid Mahdavi for implementing the scoreboard in ns and hence guiding our thinking in keeping track of SACK state.",
      "ja": "我々はナノ秒でスコアボードを実装するので、SACK状態を追跡するには、私たちの思考を導くためのマットマシスとジャムシードMahdaviに感謝します。"
    },
    {
      "indent": 3,
      "text": "The first author would like to thank Ohio University and the Ohio University Internetworking Research Group for supporting the bulk of his work on RFC 3517, from which this document is derived.",
      "ja": "最初の著者は、この文書が由来するRFC 3517での彼の仕事の大部分を支持するためのオハイオ大学、オハイオ大学のインターネットワーキング研究グループに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, October 1996.",
      "ja": "[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 \"TCPの選択確認応答オプション\"、RFC 2018、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, September 2009.",
      "ja": "[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 \"TCP輻輳制御\"、RFC 5681、2009年9月。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[AHKO97] Mark Allman, Chris Hayes, Hans Kruse, Shawn Ostermann, \"TCP Performance Over Satellite Links\", Proceedings of the Fifth International Conference on Telecommunications Systems, Nashville, TN, March, 1997.",
      "ja": "[AHKO97]マーク・オールマン、クリス・ヘイズ、ハンス・クルーゼ、ショーンOstermann、「衛星リンク上でTCPの性能」、電気通信システム、ナッシュビル、テネシー州、1997年3月に第5回国際会議の議事録。"
    },
    {
      "indent": 3,
      "text": "[All00] Mark Allman, \"A Web Server's View of the Transport Layer\", ACM Computer Communication Review, 30(5), October 2000.",
      "ja": "[All00]マークオールマン、 \"トランスポート層のWebサーバーの表示\"、ACMコンピュータコミュニケーションレビュー、30（5）、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[CPNI309] Fernando Gont, \"Security Assessment of the Transmission Control Protocol (TCP)\", CPNI Technical Note 3/2009, <http://www.gont.com.ar/papers/ tn-03-09-security-assessment-TCP.pdf>, February 2009.",
      "ja": "[CPNI309]フェルナンドGont、CPNIテクニカルノート2009分の3 \"伝送制御プロトコル（TCP）のセキュリティ評価\"、<http://www.gont.com.ar/papers/ TN-03-09-セキュリティアセスメント-TCP.pdf>、2009年2月。"
    },
    {
      "indent": 3,
      "text": "[Errata1610] RFC Errata, Errata ID 1610, RFC 2018, <http://www.rfc-editor.org>.",
      "ja": "【Errata1610] RFCエラッタ、エラッタのID 1610、RFC 2018、<http://www.rfc-editor.org>。"
    },
    {
      "indent": 3,
      "text": "[FF96] Kevin Fall and Sally Floyd, \"Simulation-based Comparisons of Tahoe, Reno and SACK TCP\", Computer Communication Review, July 1996.",
      "ja": "[FF96]ケビン・秋とサリーフロイド、コンピュータコミュニケーションレビュー、1996年7月「タホ、リノとSACK TCPのシミュレーションベースの比較」。"
    },
    {
      "indent": 3,
      "text": "[Jac90] Van Jacobson, \"Modified TCP Congestion Avoidance Algorithm\", Technical Report, LBL, April 1990.",
      "ja": "[Jac90]バン・ジェイコブソン、 \"修飾TCPの輻輳回避アルゴリズム\"、技術報告書、LBL、1990年4月。"
    },
    {
      "indent": 3,
      "text": "[PF01] Jitendra Padhye, Sally Floyd \"Identifying the TCP Behavior of Web Servers\", ACM SIGCOMM, August 2001.",
      "ja": "[PF01] Jitendra Padhye、サリー・フロイドの \"WebサーバのTCPの動作の識別\"、ACM SIGCOMM、2001年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6582] Henderson, T., Floyd, S., Gurtov, A., and Y. Nishida, \"The NewReno Modification to TCP's Fast Recovery Algorithm\", RFC 6582, April 2012.",
      "ja": "[RFC6582]ヘンダーソン、T.、フロイド、S.、Gurtov、A.、およびY.西田、 \"TCPの速い回復アルゴリズムへのNewRenoの変更\"、RFC 6582、2012年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2914] Floyd, S., \"Congestion Control Principles\", BCP 41, RFC 2914, September 2000.",
      "ja": "[RFC2914]フロイド、S.、 \"輻輳制御の原理\"、BCP 41、RFC 2914、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, June 2011.",
      "ja": "[RFC6298]パクソン、V.、オールマン、M.、チュー、J.、およびM.サージェント、 \"コンピューティングTCPの再送信タイマー\"、RFC 6298、2011年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3517] Blanton, E., Allman, M., Fall, K., and L. Wang, \"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP\", RFC 3517, April 2003.",
      "ja": "[RFC3517]ブラントン、E.、オールマン、M.、秋、K.、およびL.王は、 \"保守的な選択的確認応答（SACK）はTCPのために損失回復アルゴリズムをベース\"、RFC 3517、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5961] Ramaiah, A., Stewart, R., and M. Dalal, \"Improving TCP's Robustness to Blind In-Window Attacks\", RFC 5961, August 2010.",
      "ja": "[RFC5961] Ramaiah、A.、スチュワート、R.、およびM. Dalal、RFC 5961、2010年8月 \"ブラインドウィンドウ攻撃に対してTCPのロバスト性を向上させます\"。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ethan Blanton Purdue University Computer Sciences 305 N. University St. West Lafayette, IN 47907 United States EMail: elb@psg.com",
      "ja": "イーサンブラントンパデュー大学コンピュータサイエンス305 N.大学セントウェストラファイエット、47907米国メールに：elb@psg.com"
    },
    {
      "indent": 3,
      "text": "Mark Allman International Computer Science Institute 1947 Center St. Suite 600 Berkeley, CA 94704 United States EMail: mallman@icir.org http://www.icir.org/mallman",
      "ja": "マーク・オールマン国際コンピュータサイエンス研究所1947センターセントスイート600バークレー、CA 94704米国メールアドレス：mallman@icir.org http://www.icir.org/mallman"
    },
    {
      "indent": 3,
      "text": "Lili Wang Juniper Networks 10 Technology Park Drive Westford, MA 01886 United States EMail: liliw@juniper.net",
      "ja": "リリー王ジュニパーネットワークスの10テクノロジーパークドライブウェストフォード、マサチューセッツ州01886米国メールアドレス：liliw@juniper.net"
    },
    {
      "indent": 3,
      "text": "Ilpo Jarvinen University of Helsinki P.O. Box 68 FI-00014 UNIVERSITY OF HELSINKI Finland EMail: ilpo.jarvinen@helsinki.fi",
      "ja": "ヘルシンキの私書箱のIlpo Jarvinen大学ilpo.jarvinen@helsinki.fi：68 FI-00014ヘルシンキ大学、フィンランドメール箱"
    },
    {
      "indent": 3,
      "text": "Markku Kojo University of Helsinki P.O. Box 68 FI-00014 UNIVERSITY OF HELSINKI Finland EMail: kojo@cs.helsinki.fi",
      "ja": "ヘルシンキの私書箱のマルック古城大学ボックス68 FI-00014ヘルシンキ大学、フィンランドメール：kojo@cs.helsinki.fi"
    },
    {
      "indent": 3,
      "text": "Yoshifumi Nishida WIDE Project Endo 5322 Fujisawa, Kanagawa 252-8520 Japan EMail: nishida@wide.ad.jp",
      "ja": "よしふみ にしだ うぃで Ｐろじぇｃｔ えんど ５３２２ ふじさわ、 かながわ ２５２ー８５２０ じゃぱん えまいｌ： にしだ＠うぃで。あｄ。ｊｐ"
    }
  ]
}