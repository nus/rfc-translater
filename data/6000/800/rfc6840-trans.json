{
  "title": {
    "text": "RFC 6840 - Clarifications and Implementation Notes for DNS Security (DNSSEC)",
    "ja": "RFC 6840 - DNSセキュリティ（DNSSEC）のための明確化と実装の注意事項"
  },
  "number": 6840,
  "created_at": "2019-10-31 16:32:33.194846+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                    S. Weiler, Ed.\nRequest for Comments: 6840                                  SPARTA, Inc.\nUpdates: 4033, 4034, 4035, 5155                           D. Blacka, Ed.\nCategory: Standards Track                                 Verisign, Inc.\nISSN: 2070-1721                                            February 2013",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Clarifications and Implementation Notes for DNS Security (DNSSEC)",
      "ja": "DNSセキュリティ（DNSSEC）のための明確化と実装の注意事項"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document is a collection of technical clarifications to the DNS Security (DNSSEC) document set. It is meant to serve as a resource to implementors as well as a collection of DNSSEC errata that existed at the time of writing.",
      "ja": "この文書はDNSセキュリティ（DNSSEC）ドキュメント・セットへの技術の明確化のコレクションです。実装者へのリソースだけでなく、執筆の時点で存在していたDNSSECの正誤表のコレクションとして機能するように意図されています。"
    },
    {
      "indent": 3,
      "text": "This document updates the core DNSSEC documents (RFC 4033, RFC 4034, and RFC 4035) as well as the NSEC3 specification (RFC 5155). It also defines NSEC3 and SHA-2 (RFC 4509 and RFC 5702) as core parts of the DNSSEC specification.",
      "ja": "この文書では、コアDNSSEC文書（RFC 4033、RFC 4034、およびRFC 4035）と同様にNSEC3仕様（RFC 5155）を更新します。それはまた、NSEC3およびSHA-2（RFC 4509及びRFC 5702）DNSSEC仕様のコア部分として定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6840.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6840で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction and Terminology ....................................4\n   1.1. Structure of This Document .................................4\n   1.2. Terminology ................................................4\n2. Important Additions to DNSSEC ...................................4\n   2.1. NSEC3 Support ..............................................4\n   2.2. SHA-2 Support ..............................................5\n3. Scaling Concerns ................................................5\n   3.1. Implement a BAD Cache ......................................5\n4. Security Concerns ...............................................5\n   4.1. Clarifications on Nonexistence Proofs ......................5\n   4.2. Validating Responses to an ANY Query .......................6\n   4.3. Check for CNAME ............................................6\n   4.4. Insecure Delegation Proofs .................................7\n5. Interoperability Concerns .......................................7\n   5.1. Errors in Canonical Form Type Code List ....................7\n   5.2. Unknown DS Message Digest Algorithms .......................7\n   5.3. Private Algorithms .........................................8\n   5.4. Caution about Local Policy and Multiple RRSIGs .............9\n   5.5. Key Tag Calculation ........................................9\n   5.6. Setting the DO Bit on Replies ..............................9\n   5.7. Setting the AD Bit on Queries .............................10\n   5.8. Setting the AD Bit on Replies .............................10\n   5.9. Always Set the CD Bit on Queries ..........................10\n   5.10. Nested Trust Anchors .....................................11\n   5.11. Mandatory Algorithm Rules ................................11\n   5.12. Ignore Extra Signatures from Unknown Keys ................12\n6. Minor Corrections and Clarifications ...........................12\n   6.1. Finding Zone Cuts .........................................12\n   6.2. Clarifications on DNSKEY Usage ............................12\n   6.3. Errors in Examples ........................................13\n   6.4. Errors in RFC 5155 ........................................13\n7. Security Considerations ........................................13\n8. References .....................................................14\n   8.1. Normative References ......................................14\n   8.2. Informative References ....................................15\nAppendix A. Acknowledgments .......................................16\nAppendix B. Discussion of Setting the CD Bit ......................16\nAppendix C. Discussion of Trust Anchor Preference Options .........19\n   C.1. Closest Encloser ..........................................19\n   C.2. Accept Any Success ........................................20\n   C.3. Preference Based on Source ................................20",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction and Terminology",
      "section_title": true,
      "ja": "1.はじめと用語"
    },
    {
      "indent": 3,
      "text": "This document lists some additions, clarifications, and corrections to the core DNSSEC specification, as originally described in [RFC4033], [RFC4034], and [RFC4035], and later amended by [RFC5155]. (See Section 2 for more recent additions to that core document set.)",
      "ja": "この文書は、もともと[RFC4033]、[RFC4034]及び[RFC4035]に記載されているように、いくつかの追加、明確化、及びコアDNSSEC仕様の修正を一覧表示し、後で[RFC5155]によって修正します。 （そのコアドキュメントセットに、より最近の追加については、セクション2を参照してください。）"
    },
    {
      "indent": 3,
      "text": "It is intended to serve as a resource for implementors and as a repository of items existing at the time of writing that need to be addressed when advancing the DNSSEC documents along the Standards Track.",
      "ja": "実装のためのリソースとしておよび標準化過程に沿ってDNSSEC文書を進める際に対処する必要があり、書き込みの際の既存のアイテムのリポジトリとして機能することを目的としています。"
    },
    {
      "indent": 0,
      "text": "1.1. Structure of This Document",
      "section_title": true,
      "ja": "1.1。このドキュメントの構造"
    },
    {
      "indent": 3,
      "text": "The clarifications and changes to DNSSEC are sorted according to their importance, starting with ones which could, if ignored, lead to security problems and progressing down to clarifications that are expected to have little operational impact.",
      "ja": "DNSSECへの明確化や変更は、無視された場合、セキュリティ上の問題につながる可能性があるものから始めて、少し業務への影響を有することが期待される明確化まで進んで、その重要性に応じてソートされています。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2。用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL 「本書では[RFC2119]で説明されるように解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "2. Important Additions to DNSSEC",
      "section_title": true,
      "ja": "DNSSECへ2.重要な追加"
    },
    {
      "indent": 3,
      "text": "This section lists some documents that are now considered core DNSSEC protocol documents in addition to those originally specified in Section 10 of [RFC4033].",
      "ja": "このセクションでは、今、元々[RFC4033]のセクション10で指定されているものに加えて、コアDNSSECプロト​​コル文書を考えられているいくつかの文書を示しています。"
    },
    {
      "indent": 0,
      "text": "2.1. NSEC3 Support",
      "section_title": true,
      "ja": "2.1。 NSEC3のサポート"
    },
    {
      "indent": 3,
      "text": "[RFC5155] describes the use and behavior of the NSEC3 and NSEC3PARAM records for hashed denial of existence. Validator implementations are strongly encouraged to include support for NSEC3 because a number of highly visible zones use it. Validators that do not support validation of responses using NSEC3 will be hampered in validating large portions of the DNS space.",
      "ja": "[RFC5155]は存在のハッシュ化された拒否のNSEC3とNSEC3PARAMレコードの使用および動作について説明します。視認性の高いゾーンの数がそれを使用しているため、バリデータの実装が強くNSEC3のサポートを含めることをお勧めします。 NSEC3を使用して応答の検証をサポートしていないバリデータは、DNS空間の大部分を有効に阻まれます。"
    },
    {
      "indent": 3,
      "text": "[RFC5155] is now considered part of the DNS Security Document Family as described by Section 10 of [RFC4033].",
      "ja": "[RFC4033]のセクション10で説明したように、[RFC5155]は今DNSセキュリティ文書の家族の一部とみなされます。"
    },
    {
      "indent": 3,
      "text": "Note that the algorithm identifiers defined in [RFC5155] (DSA-NSEC3- SHA1 and RSASHA1-NSEC3-SHA1) and [RFC5702] (RSASHA256 and RSASHA512) signal that a zone might be using NSEC3, rather than NSEC. The zone may be using either, and validators supporting these algorithms MUST support both NSEC3 and NSEC responses.",
      "ja": "アルゴリズム識別子は、[RFC5155]（DSA-NSEC3- SHA1とRSASHA1-NSEC3-SHA1）とゾーンがなくNSECよりNSEC3を使用するかもしれない[RFC5702]（RSASHA256とRSASHA512）信号で定義されることに留意されたいです。ゾーンは、いずれかを使用することができ、これらのアルゴリズムをサポートするバリデータは、両方のNSEC3とNSEC応答をサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2. SHA-2 Support",
      "section_title": true,
      "ja": "2.2。 SHA-2のサポート"
    },
    {
      "indent": 3,
      "text": "[RFC4509] describes the use of SHA-256 as a digest algorithm in Delegation Signer (DS) RRs. [RFC5702] describes the use of the RSASHA256 and RSASHA512 algorithms in DNSKEY and RRSIG RRs. Validator implementations are strongly encouraged to include support for these algorithms for DS, DNSKEY, and RRSIG records.",
      "ja": "[RFC4509]は委任署名者（DS）のRRでダイジェストアルゴリズムとしてSHA-256の使用を記載しています。 [RFC5702]はDNSKEYとRRSIGのRRでRSASHA256とRSASHA512アルゴリズムの使用を記載しています。バリデータの実装が強くDS、DNSKEY、およびRRSIGレコードのこれらのアルゴリズムをサポートするように奨励されています。"
    },
    {
      "indent": 3,
      "text": "Both [RFC4509] and [RFC5702] are now considered part of the DNS Security Document Family as described by Section 10 of [RFC4033].",
      "ja": "[RFC4033]のセクション10で説明したように、両方の[RFC4509]と[RFC5702]は今DNSセキュリティ文書ファミリーの一部であると考えられます。"
    },
    {
      "indent": 0,
      "text": "3. Scaling Concerns",
      "section_title": true,
      "ja": "3.スケーリング懸念"
    },
    {
      "indent": 0,
      "text": "3.1. Implement a BAD Cache",
      "section_title": true,
      "ja": "3.1。 BADキャッシュを実装"
    },
    {
      "indent": 3,
      "text": "Section 4.7 of [RFC4035] permits security-aware resolvers to implement a BAD cache. That guidance has changed: security-aware resolvers SHOULD implement a BAD cache as described in [RFC4035].",
      "ja": "[RFC4035]の4.7節には、BADキャッシュを実装するセキュリティ対応リゾルバが可能になります。その指針が変更されました：[RFC4035]で説明したようにセキュリティ対応リゾルバはBADキャッシュを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "This change in guidance is based on operational experience with DNSSEC administrative errors leading to significant increases in DNS traffic, with an accompanying realization that such events are more likely and more damaging than originally supposed. An example of one such event is documented in \"Rolling Over DNSSEC Keys\" [Huston].",
      "ja": "指導の変化は、このようなイベントは、より多くの可能性が高いと、もともと想定さよりも有害であることを添付実現して、DNSトラフィックの大幅な増加につながるDNSSEC管理エラーが発生した運用経験に基づいています。そのようなイベントの例は、「ローリングオーバーDNSSECキー」[ヒューストン]に記載されています。"
    },
    {
      "indent": 0,
      "text": "4. Security Concerns",
      "section_title": true,
      "ja": "4.セキュリティの懸念"
    },
    {
      "indent": 3,
      "text": "This section provides clarifications that, if overlooked, could lead to security issues.",
      "ja": "このセクションでは、見落としている場合、セキュリティ上の問題につながる可能性の明確化を提供します。"
    },
    {
      "indent": 0,
      "text": "4.1. Clarifications on Nonexistence Proofs",
      "section_title": true,
      "ja": "4.1。不存在証明の明確化"
    },
    {
      "indent": 3,
      "text": "Section 5.4 of [RFC4035] under-specifies the algorithm for checking nonexistence proofs. In particular, the algorithm as presented would allow a validator to interpret an NSEC or NSEC3 RR from an ancestor zone as proving the nonexistence of an RR in a child zone.",
      "ja": "[RFC4035]の5.4節不存在証明をチェックするためのアルゴリズムを下に指定します。具体的には、提示されるアルゴリズムは、バリデータが子ゾーンにおけるRRの非存在を証明として祖先ゾーンからNSECまたはNSEC3 RRを解釈することを可能にします。"
    },
    {
      "indent": 3,
      "text": "An \"ancestor delegation\" NSEC RR (or NSEC3 RR) is one with:",
      "ja": "「先祖の委任」NSEC RR（またはNSEC3 RR）が1であります："
    },
    {
      "indent": 3,
      "text": "o the NS bit set,",
      "ja": "O NSビットがセットされ、"
    },
    {
      "indent": 3,
      "text": "o the Start of Authority (SOA) bit clear, and o a signer field that is shorter than the owner name of the NSEC RR, or the original owner name for the NSEC3 RR.",
      "ja": "権限の開始（SOA）Oクリアビット、およびNSEC RRの所有者名、またはNSEC3 RRのオリジナル所有者名より短い署名フィールドO。"
    },
    {
      "indent": 3,
      "text": "Ancestor delegation NSEC or NSEC3 RRs MUST NOT be used to assume nonexistence of any RRs below that zone cut, which include all RRs at that (original) owner name other than DS RRs, and all RRs below that owner name regardless of type.",
      "ja": "祖先委任NSECまたはNSEC3 RRは関係なく、タイプのDSのRR以外のその（元の）所有者名、およびその所有者名の下にすべてのRRにすべてのRRを含むそのゾーンカット以下任意のRRの非存在を想定するために使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "Similarly, the algorithm would also allow an NSEC RR at the same owner name as a DNAME RR, or an NSEC3 RR at the same original owner name as a DNAME, to prove the nonexistence of names beneath that DNAME. An NSEC or NSEC3 RR with the DNAME bit set MUST NOT be used to assume the nonexistence of any subdomain of that NSEC/NSEC3 RR's (original) owner name.",
      "ja": "同様に、アルゴリズムは、そのDNAME下名の非存在を証明するために、DNAMEと同じ元の所有者の名前でDNAMEのRR、またはNSEC3 RRと同じ所有者名でNSEC RRを可能にするであろう。 DNAMEビットが設定されたNSECまたはNSEC3 RRは、NSEC / NSEC3 RRの（オリジナルの）所有者名のいずれかのサブドメインの非存在を仮定するために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "4.2. Validating Responses to an ANY Query",
      "section_title": true,
      "ja": "4.2。任意のクエリに対する応答を検証"
    },
    {
      "indent": 3,
      "text": "[RFC4035] does not address how to validate responses when QTYPE=*. As described in Section 6.2.2 of [RFC1034], a proper response to QTYPE=* may include a subset of the RRsets at a given name. That is, it is not necessary to include all RRsets at the QNAME in the response.",
      "ja": "[RFC4035]はときQTYPE = *応答を検証する方法は対応していません。 [RFC1034]のセクション6.2.2に記載したように、QTYPEに適切な応答が= *与えられた名前で資源レコード集合のサブセットを含むことができます。つまり、応答QNAMEですべてのRRsetを含める必要はありません。"
    },
    {
      "indent": 3,
      "text": "When validating a response to QTYPE=*, all received RRsets that match QNAME and QCLASS MUST be validated. If any of those RRsets fail validation, the answer is considered Bogus. If there are no RRsets matching QNAME and QCLASS, that fact MUST be validated according to the rules in Section 5.4 of [RFC4035] (as clarified in this document). To be clear, a validator must not expect to receive all records at the QNAME in response to QTYPE=*.",
      "ja": "QTYPEへの応答を検証するとき= *、すべてはQNAMEとQCLASSを検証する必要があります一致するRRセットを受け取りました。これらのRRsetのいずれかが検証に失敗した場合は、その答えは偽と考えられています。 QNAMEとQCLASSに一致する資源レコード集合が存在しない場合は、その事実は、（本書で明らかにされるように）[RFC4035]のセクション5.4の規則に従って検証されなければなりません。明確にするためには、バリデータはQTYPE = *に応じて、QNAMEですべてのレコードを受け取ることを期待してはいけません。"
    },
    {
      "indent": 0,
      "text": "4.3. Check for CNAME",
      "section_title": true,
      "ja": "4.3。 CNAMEをチェック"
    },
    {
      "indent": 3,
      "text": "Section 5 of [RFC4035] says nothing explicit about validating responses based on (or that should be based on) CNAMEs. When validating a NOERROR/NODATA response, validators MUST check the CNAME bit in the matching NSEC or NSEC3 RR's type bitmap in addition to the bit for the query type.",
      "ja": "[RFC4035]のセクション5に基づいて応答を検証しに関する明確な何も言う（またはそのはに基づいている必要があります）のCNAME。 NOERROR / NODATA応答を検証する場合、バリデータは、クエリ・タイプのビットに加えてマッチングNSECまたはNSEC3 RRのタイプビットマップでCNAMEビットをチェックしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Without this check, an attacker could successfully transform a positive CNAME response into a NOERROR/NODATA response by (for example) simply stripping the CNAME RRset from the response. A naive validator would then note that the QTYPE was not present in the matching NSEC/NSEC3 RR, but fail to notice that the CNAME bit was set; thus, the response should have been a positive CNAME response.",
      "ja": "このチェックがなければ、攻撃者は、単に応答からCNAME RRセットを剥離する（例えば）によってNOERROR / NODATA応答に正のCNAME応答を変換することができます。ナイーブなバリデータは、その後、QTYPEが一致NSEC / NSEC3 RRには存在しなかったことに注意が、CNAMEビットがセットされたことに気づくことができないであろう。したがって、応答が肯定CNAME応答されている必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Insecure Delegation Proofs",
      "section_title": true,
      "ja": "4.4。安全でない委任証明"
    },
    {
      "indent": 3,
      "text": "Section 5.2 of [RFC4035] specifies that a validator, when proving a delegation is not secure, needs to check for the absence of the DS and SOA bits in the NSEC (or NSEC3) type bitmap. The validator also MUST check for the presence of the NS bit in the matching NSEC (or NSEC3) RR (proving that there is, indeed, a delegation), or alternately make sure that the delegation is covered by an NSEC3 RR with the Opt-Out flag set.",
      "ja": "[RFC4035]のセクション5.2は、バリ、委任を証明するときに固定されていないが、ビットマップを入力NSEC（またはNSEC3）におけるDSとSOAビットが存在しないことを確認する必要があることを指定します。バリデータはまた、マッチングNSEC（またはNSEC3）におけるNSビットの有無を確認し（実際に存在することを証明、委任）RR、または交互に委任をOpt-とNSEC3 RRによって覆われていることを確認する必要がありますアウトフラグセット。"
    },
    {
      "indent": 3,
      "text": "Without this check, an attacker could reuse an NSEC or NSEC3 RR matching a non-delegation name to spoof an unsigned delegation at that name. This would claim that an existing signed RRset (or set of signed RRsets) is below an unsigned delegation, thus not signed and vulnerable to further attack.",
      "ja": "このチェックがなければ、攻撃者はその名前で署名のない委任を偽装する非委任名と一致するNSECまたはNSEC3 RRを再利用することができます。これにより署名され、さらに攻撃に対して脆弱ではない、符号なしの委任を下回っている既存の署名された資源レコード集合（または署名された資源レコード集合の集合）と主張するだろう。"
    },
    {
      "indent": 0,
      "text": "5. Interoperability Concerns",
      "section_title": true,
      "ja": "5.相互運用性の懸念"
    },
    {
      "indent": 0,
      "text": "5.1. Errors in Canonical Form Type Code List",
      "section_title": true,
      "ja": "5.1。 Canonicalはフォームタイプコード一覧のエラー"
    },
    {
      "indent": 3,
      "text": "When canonicalizing DNS names (for both ordering and signing), DNS names in the RDATA section of NSEC resource records are not converted to lowercase. DNS names in the RDATA section of RRSIG resource records are converted to lowercase.",
      "ja": "（両方の順序と署名のための）DNS名をcanonicalizingとき、NSECリソースレコードのRDATAセクションでのDNS名は小文字に変換されません。 RRSIGリソースレコードのRDATAセクションでのDNS名は小文字に変換されます。"
    },
    {
      "indent": 3,
      "text": "The guidance in the above paragraph differs from what has been published before but is consistent with current common practice. Item 3 of Section 6.2 of [RFC4034] says that names in both of these RR types should be converted to lowercase. The earlier [RFC3755] says that they should not. Current practice follows neither document fully.",
      "ja": "上の段落のガイダンスは、以前に発行されたものとは異なりますが、現在の一般的な慣行と一致しています。 [RFC4034]の6.2節の項目3は、これらのRRタイプの両方での名前は小文字に変換されなければならないと述べています。以前の[RFC3755]は、彼らがいけないと言っています。現在の練習は完全にどちらのドキュメントに従います。"
    },
    {
      "indent": 3,
      "text": "Section 6.2 of [RFC4034] also erroneously lists HINFO as a record that needs conversion to lowercase, and twice at that. Since HINFO records contain no domain names, they are not subject to case conversion.",
      "ja": "[RFC4034]のセクション6.2はまた、誤ってその倍の小文字への変換を必要とし、記録としてHINFOを示しています。 HINFOレコードは何のドメイン名が含まれていないので、ケース変換の対象にはなりません。"
    },
    {
      "indent": 0,
      "text": "5.2. Unknown DS Message Digest Algorithms",
      "section_title": true,
      "ja": "5.2。未知のDSメッセージダイジェストアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Section 5.2 of [RFC4035] includes rules for how to handle delegations to zones that are signed with entirely unsupported public key algorithms, as indicated by the key algorithms shown in those zones' DS RRsets. It does not explicitly address how to handle DS records that use unsupported message digest algorithms. In brief, DS records using unknown or unsupported message digest algorithms MUST be treated the same way as DS records referring to DNSKEY RRs of unknown or unsupported public key algorithms.",
      "ja": "[RFC4035]のセクション5.2は、これらのゾーンのDS資源レコード集合に示す鍵アルゴリズムで示されるように、完全にサポートされていない公開鍵アルゴリズムで署名されたゾーンに委任を処理する方法のための規則を含みます。これは、明示的にサポートされていないメッセージダイジェストアルゴリズムを使用するDSレコードを処理する方法を扱っていません。簡単に言うと、不明またはサポートされていないメッセージダイジェストアルゴリズム使ってDSレコードが不明またはサポートされていない公開鍵アルゴリズムのDNSKEYのRRを参照するDSレコードと同じように扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "The existing text says:",
      "ja": "既存のテキストは言います："
    },
    {
      "indent": 6,
      "text": "If the validator does not support any of the algorithms listed in an authenticated DS RRset, then the resolver has no supported authentication path leading from the parent to the child. The resolver should treat this case as it would the case of an authenticated NSEC RRset proving that no DS RRset exists, as described above.",
      "ja": "バリデータが認証されたDS RRセットに記載されているアルゴリズムのいずれかをサポートしていない場合は、リゾルバは親から子へ有数一切サポートされている認証パスを持っていません。上記のように、それが認証NSEC資源レコード集合の場合は、何のDS RRセットが存在しないことを証明するであろうように、レゾルバは、このケースを扱うべきです。"
    },
    {
      "indent": 3,
      "text": "In other words, when determining the security status of a zone, a validator disregards any authenticated DS records that specify unknown or unsupported DNSKEY algorithms. If none are left, the zone is treated as if it were unsigned.",
      "ja": "ゾーンのセキュリティ状態を決定するときに、他の言葉では、バリデータは、未知またはサポートされていないDNSKEYアルゴリズムを指定する任意の認証済みのDSレコードを無視します。何も残っていない場合は、符号なしであるかのように、ゾーンが処理されます。"
    },
    {
      "indent": 3,
      "text": "This document modifies the above text to additionally disregard authenticated DS records using unknown or unsupported message digest algorithms.",
      "ja": "この文書では、さらにダイジェストアルゴリズム不明またはサポートされていないメッセージを使用して認証DSレコードを無視するために上記のテキストを変更します。"
    },
    {
      "indent": 0,
      "text": "5.3. Private Algorithms",
      "section_title": true,
      "ja": "5.3。プライベートアルゴリズム"
    },
    {
      "indent": 3,
      "text": "As discussed above, Section 5.2 of [RFC4035] requires that validators make decisions about the security status of zones based on the public key algorithms shown in the DS records for those zones. In the case of private algorithms, as described in Appendix A.1.1 of [RFC4034], the eight-bit algorithm field in the DS RR is not conclusive about what algorithm(s) is actually in use.",
      "ja": "上述のように、[RFC4035]の5.2節では、バリデータは、これらのゾーンのDSレコードに示されている公開鍵アルゴリズムに基づいてゾーンのセキュリティ状態についての決定を行うことが必要です。 [RFC4034]の付録A.1.1に記載されているように、プライベートアルゴリズムの場合には、DS RRの8ビットのアルゴリズムフィールドが使用され、実際にどのアルゴリズム（複数可）について決定的ではありません。"
    },
    {
      "indent": 3,
      "text": "If no private algorithms appear in the DS RRset, or if any supported algorithm appears in the DS RRset, no special processing is needed. Furthermore, if the validator implementation does not support any private algorithms, or only supports private algorithms using an algorithm number not present in the DS RRset, no special processing is needed.",
      "ja": "何のプライベートアルゴリズムはDS RRセットに表示されない場合、またはサポートされている任意のアルゴリズムがDS RRセットに表示されている場合、特別な処理は必要ありません。バリデータの実装は任意のプライベートなアルゴリズムをサポートする、または唯一のDS RRセットに存在しないアルゴリズムの番号を使用してプライベートアルゴリズムをサポートしていない場合はさらに、特別な処理は必要ありません。"
    },
    {
      "indent": 3,
      "text": "In the remaining cases, the security status of the zone depends on whether or not the resolver supports any of the private algorithms in use (provided that these DS records use supported message digest algorithms, as discussed in Section 5.2 of this document). In these cases, the resolver MUST retrieve the corresponding DNSKEY for each private algorithm DS record and examine the public key field to determine the algorithm in use. The security-aware resolver MUST ensure that the hash of the DNSKEY RR's owner name and RDATA matches the digest in the DS RR as described in Section 5.2 of [RFC4035], authenticating the DNSKEY. If all of the retrieved and authenticated DNSKEY RRs use unknown or unsupported private algorithms, then the zone is treated as if it were unsigned.",
      "ja": "残りの例では、ゾーンのセキュリティステータスは、（このドキュメントのセクション5.2で説明したように、これらのDSレコードがメッセージダイジェストアルゴリズムサポート使用している場合）リゾルバは、使用中のプライベートなアルゴリズムのいずれかをサポートしているかどうかによって異なります。これらのケースでは、リゾルバは、各プライベートアルゴリズムのDSレコードに対応するDNSKEYを取得し、使用中のアルゴリズムを決定するために、公開キーフィールドを調べる必要があります。セキュリティ対応リゾルバはDNSKEYを認証し、[RFC4035]の5.2節で説明したようにDNSKEYのRRの所有者名とRDATAのハッシュがDS RRでのダイジェストと一致することを確認しなければなりません。取得し、認証されたDNSKEYのRRの全てが不明またはサポートされていないプライベートなアルゴリズムを使用している場合、それは符号なしであるかのように、そのゾーンが処理されます。"
    },
    {
      "indent": 3,
      "text": "Note that if none of the private algorithm DS RRs can be securely matched to DNSKEY RRs and no other DS establishes that the zone is secure, the referral should be considered Bogus data as discussed in [RFC4035].",
      "ja": "プライベートアルゴリズムDS RRのいずれも確実にRRをDNSKEYために一致しないことができ、他のDSは、ゾーンが安全であることを確立していない場合は[RFC4035]で議論するように、照会が偽のデータを考慮すべきであることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "This clarification facilitates the broader use of private algorithms, as suggested by [RFC4955].",
      "ja": "[RFC4955]によって提案されたように、この明確化は、民間のアルゴリズムの広範な使用を容易にします。"
    },
    {
      "indent": 0,
      "text": "5.4. Caution about Local Policy and Multiple RRSIGs",
      "section_title": true,
      "ja": "5.4。ローカルポリシーと複数RRSIGsについての注意事項"
    },
    {
      "indent": 3,
      "text": "When multiple RRSIGs cover a given RRset, Section 5.3.3 of [RFC4035] suggests that \"the local resolver security policy determines whether the resolver also has to test these RRSIG RRs and how to resolve conflicts if these RRSIG RRs lead to differing results\".",
      "ja": "複数RRSIGsが与えられたRRセットをカバーすると、[RFC4035]のセクション5.3.3「ローカルリゾルバのセキュリティポリシーは、リゾルバまたこれらのRRSIG RRは、どのようにこれらのRRSIGのRRは異なる結果になる場合は競合を解決するためにテストするために持っているかどうかを決定する」ことを示唆しています。"
    },
    {
      "indent": 3,
      "text": "This document specifies that a resolver SHOULD accept any valid RRSIG as sufficient, and only determine that an RRset is Bogus if all RRSIGs fail validation.",
      "ja": "この文書では、リゾルバがとして十分な任意の有効なRRSIGを受け入れ、そして唯一のすべてのRRSIGsが検証に失敗した場合RRセットが偽であると判断するように指定します。"
    },
    {
      "indent": 3,
      "text": "If a resolver adopts a more restrictive policy, there's a danger that properly signed data might unnecessarily fail validation due to cache timing issues. Furthermore, certain zone management techniques, like the Double Signature Zone Signing Key Rollover method described in Section 4.2.1.2 of [RFC6781], will not work reliably. Such a resolver is also vulnerable to malicious insertion of gibberish signatures.",
      "ja": "リゾルバがより制限ポリシーを採用した場合、適切に署名されたデータが不必要に起因するキャッシュタイミングの問題のために検証を失敗するかもしれない危険性があります。さらに、[RFC6781]のセクション4.2.1.2で説明したキーロールオーバー法に署名ダブル署名ゾーンのような特定のゾーン管理技術は、確実に動作しません。そのようなリゾルバはまた、意味不明シグネチャの悪意のある挿入に対して脆弱です。"
    },
    {
      "indent": 0,
      "text": "5.5. Key Tag Calculation",
      "section_title": true,
      "ja": "5.5。鍵タグ計算"
    },
    {
      "indent": 3,
      "text": "Appendix B.1 of [RFC4034] incorrectly defines the Key Tag field calculation for algorithm 1. It correctly says that the Key Tag is the most significant 16 of the least significant 24 bits of the public key modulus. However, [RFC4034] then goes on to incorrectly say that this is fourth-to-last and third-to-last octets of the public key modulus. It is, in fact, the third-to-last and second-to-last octets.",
      "ja": "[RFC4034]の付録B.1は間違ってそれを正しく鍵タグは公開鍵係数の最下位24ビットの16個の最上位であることを述べているアルゴリズム1の鍵タグフィールドの計算を定義します。ただし、[RFC4034]は、その後、誤ってこれは第四-最後に公開鍵係数の第三ツー最後のオクテットであると言うことになります。それは、実際には、への最後の三分のと最後から2番目のオクテットです。"
    },
    {
      "indent": 0,
      "text": "5.6. Setting the DO Bit on Replies",
      "section_title": true,
      "ja": "5.6。回答のDOビットを設定します"
    },
    {
      "indent": 3,
      "text": "As stated in Section 3 of [RFC3225], the DNSSEC OK (DO) bit of the query MUST be copied in the response. However, in order to interoperate with implementations that ignore this rule on sending, resolvers MUST ignore the DO bit in responses.",
      "ja": "[RFC3225]のセクション3で述べたように、クエリのDNSSEC OK（DO）ビットは、応答にコピーされなければなりません。しかし、送信時にこのルールを無視する実装と相互運用するためには、リゾルバは応答のDOビットを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.7. Setting the AD Bit on Queries",
      "section_title": true,
      "ja": "5.7。クエリにADビットを設定します"
    },
    {
      "indent": 3,
      "text": "The semantics of the Authentic Data (AD) bit in the query were previously undefined. Section 4.6 of [RFC4035] instructed resolvers to always clear the AD bit when composing queries.",
      "ja": "クエリ内の本物のデータ（AD）ビットのセマンティクスは未定義でした。 [RFC4035]のセクション4.6は、クエリを作成するとき、常にADビットをクリアするためにリゾルバに指示しました。"
    },
    {
      "indent": 3,
      "text": "This document defines setting the AD bit in a query as a signal indicating that the requester understands and is interested in the value of the AD bit in the response. This allows a requester to indicate that it understands the AD bit without also requesting DNSSEC data via the DO bit.",
      "ja": "この文書では、要求者が理解し、応答のADビットの値に関心があることを示す信号としてクエリにADビットを設定する定義します。これは、リクエスタが、それはまた、DOのビットを介しDNSSECデータを要求することなく、ADビットを理解することを示すことを可能にします。"
    },
    {
      "indent": 0,
      "text": "5.8. Setting the AD Bit on Replies",
      "section_title": true,
      "ja": "5.8。回答にADビットを設定します"
    },
    {
      "indent": 3,
      "text": "Section 3.2.3 of [RFC4035] describes under which conditions a validating resolver should set or clear the AD bit in a response. In order to interoperate with legacy stub resolvers and middleboxes that neither understand nor ignore the AD bit, validating resolvers SHOULD only set the AD bit when a response both meets the conditions listed in Section 3.2.3 of [RFC4035], and the request contained either a set DO bit or a set AD bit.",
      "ja": "[RFC4035]のセクション3.2.3検証リゾルバが応答してADビットを設定またはクリアすべき条件の下で記載されています。応答は、[RFC4035]のセクション3.2.3に記載されている条件を満たしているの両方、および要求のいずれかに含まれる場合ADビットを理解することも、無視どちらことレガシースタブリゾルバと中間装置と相互運用するために、検証リゾルバは、ADビットを設定すべきですセットには、ビットまたはセットADのビットを行います。"
    },
    {
      "indent": 0,
      "text": "5.9. Always Set the CD Bit on Queries",
      "section_title": true,
      "ja": "5.9。常にクエリのCDビットを設定"
    },
    {
      "indent": 3,
      "text": "When processing a request with the Checking Disabled (CD) bit set, a resolver SHOULD attempt to return all response data, even data that has failed DNSSEC validation. Section 3.2.2 of [RFC4035] requires a resolver processing a request with the CD bit set to set the CD bit on its upstream queries.",
      "ja": "ビットセットチェック無効（CD）で要求を処理する場合、リゾルバは、すべての応答データを返すためにDNSSEC検証を失敗してもデータを試みるべきです。 [RFC4035]のセクション3.2.2は、CDは、その上流クエリにCDビットを設定するように設定ビットが要求を処理リゾルバを必要とします。"
    },
    {
      "indent": 3,
      "text": "This document further specifies that validating resolvers SHOULD set the CD bit on every upstream query. This is regardless of whether the CD bit was set on the incoming query or whether it has a trust anchor at or above the QNAME.",
      "ja": "この文書では、さらに、検証リゾルバは、すべての上流のクエリにCDビットを設定するように指定します。これは、CDビットが入ってくるクエリに設定されたかどうかにかかわらず、であるか、それはで、またはQNAMEの上トラストアンカーを持っているかどうか。"
    },
    {
      "indent": 3,
      "text": "[RFC4035] is ambiguous about what to do when a cached response was obtained with the CD bit unset, a case that only arises when the resolver chooses not to set the CD bit on all upstream queries, as specified above. In the typical case, no new query is required, nor does the cache need to track the state of the CD bit used to make a given query. The problem arises when the cached response is a server failure (RCODE 2), which may indicate that the requested data failed DNSSEC validation at an upstream validating resolver. ([RFC2308] permits caching of server failures for up to five minutes.) In these cases, a new query with the CD bit set is required.",
      "ja": "[RFC4035]は、キャッシュされた応答が未設定CDビット、上記指定されたレゾルバは、すべてのアップストリームクエリにCDビットを設定しないことを選択した場合にのみ発生する場合が得られた場合に何をすべきかについて曖昧です。典型的なケースでは、新しいクエリが必要とされない、またキャッシュは、特定のクエリを作るために使用されるCDのビットの状態を追跡する必要がありません。キャッシュされた応答は、要求されたデータが上流の検証リゾルバにDNSSEC検証に失敗したことを示すことができるサーバの障害（RCODE 2）、ある場合に問題が生じます。 （[RFC2308]までの5分間のサーバ障害のキャッシングを可能にします。）これらのケースでは、CDビットが設定された新しいクエリが必要です。"
    },
    {
      "indent": 3,
      "text": "Appendix B discusses more of the logic behind the recommendation presented in this section.",
      "ja": "付録Bは、このセクションで提示勧告の背後にあるロジックの多くを説明します。"
    },
    {
      "indent": 0,
      "text": "5.10. Nested Trust Anchors",
      "section_title": true,
      "ja": "5.10。ネストされたトラストアンカー"
    },
    {
      "indent": 3,
      "text": "A DNSSEC validator may be configured such that, for a given response, more than one trust anchor could be used to validate the chain of trust to the response zone. For example, imagine a validator configured with trust anchors for \"example.\" and \"zone.example.\" When the validator is asked to validate a response to \"www.sub.zone.example.\", either trust anchor could apply.",
      "ja": "DNSSECバリデータは、指定された応答のために、複数のトラストアンカーが応答ゾーンに信頼の連鎖を検証するために使用することができる、ように構成されてもよいです。例えば、のためのトラストアンカーで構成されたバリデータ想像「の例を。」そして \"zone.example。\"ときにバリデータは、「www.sub.zone.example」への応答を検証するように要求され、いずれかのトラストアンカーが適用できます。"
    },
    {
      "indent": 3,
      "text": "When presented with this situation, DNSSEC validators have a choice of which trust anchor(s) to use. Which to use is a matter of implementation choice. Appendix C discusses several possible algorithms.",
      "ja": "このような状況を提示すると、DNSSECのバリデータが使用するトラストアンカー（複数可）を選択できます。どちらを使用するには、実装の選択の問題です。付録Cには、いくつかの可能なアルゴリズムについて説明します。"
    },
    {
      "indent": 3,
      "text": "It is possible and advisable to expose the choice of policy as a configuration option. As a default, it is suggested that validators implement the \"Accept Any Success\" policy described in Appendix C.2 while exposing other policies as configuration options.",
      "ja": "設定オプションとして政策の選択肢を露出させることができるとことをお勧めします。デフォルトでは、バリデータが設定オプションなど、他の政策を露出させ、付録C.2に記載されている「任意の成功を受け入れる」政策を実施することが示唆されます。"
    },
    {
      "indent": 3,
      "text": "The \"Accept Any Success\" policy is to try all applicable trust anchors until one gives a validation result of Secure, in which case the final validation result is Secure. If and only if all applicable trust anchors give a result of Insecure, the final validation result is Insecure. If one or more trust anchors lead to a Bogus result and there is no Secure result, then the final validation result is Bogus.",
      "ja": "「どれ成功を受け入れる」ポリシーは1つが、最終的な検証結果がセキュアである場合にはセキュアの検証結果を与えるまでは、該当するすべてのトラストアンカーを試してみることです。そして、該当するすべてのトラストアンカーが安全でない結果が得られた場合にのみ場合は、最終検証結果は、安全でないです。一つ以上のトラストアンカーが偽結果につながると何のセキュアな結果がない場合、最終的な検証結果が偽です。"
    },
    {
      "indent": 0,
      "text": "5.11. Mandatory Algorithm Rules",
      "section_title": true,
      "ja": "5.11。必須アルゴリズムルール"
    },
    {
      "indent": 3,
      "text": "The last paragraph of Section 2.2 of [RFC4035] includes rules describing which algorithms must be used to sign a zone. Since these rules have been confusing, they are restated using different language here:",
      "ja": "[RFC4035]のセクション2.2の最後の段落ゾーンに署名するために使用されなければならないアルゴリズム記述規則を含みます。これらのルールは混乱していたので、彼らはここで別の言語を使用して修正再表示されます。"
    },
    {
      "indent": 6,
      "text": "The DS RRset and DNSKEY RRset are used to signal which algorithms are used to sign a zone. The presence of an algorithm in either a zone's DS or DNSKEY RRset signals that that algorithm is used to sign the entire zone.",
      "ja": "DS RRセットとDNSKEY資源レコード集合は、ゾーンに署名するために使用されるアルゴリズムを知らせるために使用されます。ゾーンのDSまたはDNSKEY RRセットのいずれかにおけるアルゴリズムの存在は、そのアルゴリズムがゾーン全体に署名するために使用されていることを知らせます。"
    },
    {
      "indent": 6,
      "text": "A signed zone MUST include a DNSKEY for each algorithm present in the zone's DS RRset and expected trust anchors for the zone. The zone MUST also be signed with each algorithm (though not each key) present in the DNSKEY RRset. It is possible to add algorithms at the DNSKEY that aren't in the DS record, but not vice versa. If more than one key of the same algorithm is in the DNSKEY RRset, it is sufficient to sign each RRset with any subset of these DNSKEYs. It is acceptable to sign some RRsets with one subset of keys (or key) and other RRsets with a different subset, so long as at least one DNSKEY of each algorithm is used to sign each RRset. Likewise, if there are DS records for multiple keys of the same algorithm, any subset of those may appear in the DNSKEY RRset.",
      "ja": "署名付きゾーンはゾーンの各ゾーンのDS RRセットにおけるアルゴリズムの存在と期待される信頼アンカーのためのDNSKEYを含まなければなりません。ゾーンは、各アルゴリズムDNSKEY RRセットに存在する（ではないが、各キー）で署名しなければなりません。 DSレコードに含まれていないDNSKEYでアルゴリズムを追加することも可能ですが、その逆はありません。同じアルゴリズムの複数のキーがDNSKEY RRセットになっている場合、これらのDNSKEYsの任意のサブセットと各RRセットに署名するのに十分です。限り、各アルゴリズムの少なくとも一方DNSKEYが各RRセットに署名するために使用される、異なるサブセットにいくつかのいずれかのキーのサブセット（またはキー）と資源レコード集合と他の資源レコード集合に署名するために許容可能です。同じアルゴリズムの複数のキーのためのDSレコードがある場合は同様に、これらの任意のサブセットはDNSKEY RRセットに表示される場合があります。"
    },
    {
      "indent": 3,
      "text": "This requirement applies to servers, not validators. Validators SHOULD accept any single valid path. They SHOULD NOT insist that all algorithms signaled in the DS RRset work, and they MUST NOT insist that all algorithms signaled in the DNSKEY RRset work. A validator MAY have a configuration option to perform a signature completeness test to support troubleshooting.",
      "ja": "この要件は、サーバではなく、バリデータに適用されます。バリデータは、任意の単一の有効なパスを受け入れる必要があります。彼らはすべてのアルゴリズムはDS RRセット作業に通知することを主張すべきではない、と彼らはすべてのアルゴリズムはDNSKEY RRセット作業に通知することを主張してはなりません。バリデータは、トラブルシューティングをサポートするための署名完全テストを実行するための設定オプションがあるかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.12. Ignore Extra Signatures from Unknown Keys",
      "section_title": true,
      "ja": "5.12。不明なキーから余分な署名を無視"
    },
    {
      "indent": 3,
      "text": "Validating resolvers MUST disregard RRSIGs in a zone that do not (currently) have a corresponding DNSKEY in the zone. Similarly, a validating resolver MUST disregard RRSIGs with algorithm types that don't exist in the DNSKEY RRset.",
      "ja": "検証リゾルバは、（現在は）ゾーンに対応するDNSKEYを持っていないゾーンでRRSIGsを無視しなければなりません。同様に、検証リゾルバはDNSKEY RRセットには存在しないアルゴリズムの種類とRRSIGsを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Good key rollover and algorithm rollover practices, as discussed in RFC 6781 and its successor documents and as suggested by the rules in the previous section, may require that such RRSIGs be present in a zone.",
      "ja": "キーロールオーバアルゴリズムロールオーバー慣行良い、RFC 6781およびその後継文書および前節で規則によって示唆されるように説明したように、そのようなRRSIGsゾーンに存在することを要求することができます。"
    },
    {
      "indent": 0,
      "text": "6. Minor Corrections and Clarifications",
      "section_title": true,
      "ja": "6.マイナー訂正と明確化"
    },
    {
      "indent": 0,
      "text": "6.1. Finding Zone Cuts",
      "section_title": true,
      "ja": "6.1。ゾーンカットを見つけます"
    },
    {
      "indent": 3,
      "text": "Appendix C.8 of [RFC4035] discusses sending DS queries to the servers for a parent zone but does not state how to find those servers. Specific instructions can be found in Section 4.2 of [RFC4035].",
      "ja": "[RFC4035]の付録C.8は、親ゾーンのサーバにDSクエリを送信して説明したが、それらのサーバーを見つける方法を述べるものではありません。具体的な手順は、[RFC4035]のセクション4.2に見出すことができます。"
    },
    {
      "indent": 0,
      "text": "6.2. Clarifications on DNSKEY Usage",
      "section_title": true,
      "ja": "6.2。 DNSKEYの使用上の明確化"
    },
    {
      "indent": 3,
      "text": "It is possible to use different DNSKEYs to sign different subsets of a zone, constrained only by the rules in Section 5.11. It is even possible to use a different DNSKEY for each RRset in a zone, subject only to practical limits on the size of the DNSKEY RRset and the above rules. However, be aware that there is no way to tell resolvers what a particular DNSKEY is supposed to be used for -- any DNSKEY in the zone's signed DNSKEY RRset may be used to authenticate any RRset in the zone. For example, if a weaker or less trusted DNSKEY is being used to authenticate NSEC RRsets or all dynamically updated records, that same DNSKEY can also be used to sign any other RRsets from the zone.",
      "ja": "セクション5.11で規則によってのみ制約ゾーンの異なるサブセットを署名するために異なるDNSKEYsを使用することが可能です。それだけDNSKEY RRセットと上記ルールのサイズに実用上の制限を受け、ゾーン内の各RRセットに異なるDNSKEYを使用することも可能です。ゾーンの署名DNSKEY RRセット内のすべてのDNSKEYは、ゾーン内の任意のRRセットを認証するために使用することができる - しかし、特定のDNSKEYをするために使用されることになっているものリゾルバを伝える方法がないことに注意してください。弱いまたは信頼性の低いDNSKEYがNSECのRRセットまたはすべての動的に更新されたレコードを認証するために使用されている場合、その同じDNSKEYもゾーンから他のRRセットに署名するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Furthermore, note that the SEP bit setting has no effect on how a DNSKEY may be used -- the validation process is specifically prohibited from using that bit by Section 2.1.2 of [RFC4034]. It is",
      "ja": "検証プロセスは、具体的には、[RFC4034]のセクション2.1.2によってそのビットを使用して、禁止されている - また、9月のビット設定はDNSKEYを使用することができる方法に影響を及ぼさないことに注意してください。それはあります"
    },
    {
      "indent": 3,
      "text": "possible to use a DNSKEY without the SEP bit set as the sole secure entry point to the zone, yet use a DNSKEY with the SEP bit set to sign all RRsets in the zone (other than the DNSKEY RRset). It is also possible to use a single DNSKEY, with or without the SEP bit set, to sign the entire zone, including the DNSKEY RRset itself.",
      "ja": "SEPなしDNSKEYを使用することができるゾーンに唯一の安全なエントリポイントとして設定し、まだSEPとDNSKEYを使用ビット（DNSKEY RRセット以外の）ゾーン内のすべての資源レコード集合に署名するように設定ビット。 DNSKEY RRセット自体を含むゾーン全体を署名するために、9月ビットセットの有無にかかわらず、単一のDNSKEYを使用することも可能です。"
    },
    {
      "indent": 0,
      "text": "6.3. Errors in Examples",
      "section_title": true,
      "ja": "6.3。例でのエラー"
    },
    {
      "indent": 3,
      "text": "The text in Appendix C.1 of [RFC4035] refers to the examples in Appendix B.1 as \"x.w.example.com\" while B.1 uses \"x.w.example\". This is painfully obvious in the second paragraph where it states that the RRSIG labels field value of 3 indicates that the answer was not the result of wildcard expansion. This is true for \"x.w.example\" but not for \"x.w.example.com\", which of course has a label count of 4 (antithetically, a label count of 3 would imply the answer was the result of a wildcard expansion).",
      "ja": "B.1が「x.w.example」を使用しながら、[RFC4035]の付録C.1のテキストは、「x.w.example.com」として付録B.1の例を指します。これは、3のRRSIGラベルフィールドの値は、答えはワイルドカード拡張の結果ではなかったことを示していると述べている第二段落に痛いほど明らかです。これは、「x.w.example」のための真のではなく、もちろん4のラベル数を持っている「x.w.example.com」、のためである（antithetically、答えを暗示する3のラベル数は、ワイルドカード拡張の結果でした）。"
    },
    {
      "indent": 3,
      "text": "The first paragraph of Appendix C.6 of [RFC4035] also has a minor error: the reference to \"a.z.w.w.example\" should instead be \"a.z.w.example\", as in the previous line.",
      "ja": "[RFC4035]の付録C.6の最初の段落はまた、マイナー・エラーを有する：「a.z.w.w.example」への言及は、代わりに前の行のように、「a.z.w.example」でなければなりません。"
    },
    {
      "indent": 1,
      "text": "6.4. Errors in",
      "section_title": true,
      "ja": "6.4。でのエラー"
    },
    {
      "indent": 3,
      "text": "An NSEC3 record that matches an Empty Non-Terminal effectively has no type associated with it. This NSEC3 record has an empty type bit map. Section 3.2.1 of [RFC5155] contains the statement:",
      "ja": "効果的に空非ターミナルに一致するNSEC3レコードは、それに関連付けられた型を持っていません。このNSEC3レコードは空のタイプビットマップを持っています。 [RFC5155]のセクション3.2.1は、ステートメントが含まれています。"
    },
    {
      "indent": 6,
      "text": "Blocks with no types present MUST NOT be included.",
      "ja": "現在無しタイプのブロックを含んではいけません。"
    },
    {
      "indent": 3,
      "text": "However, the same section contains a regular expression:",
      "ja": "しかし、同じセクションでは、正規表現が含まれています。"
    },
    {
      "indent": 6,
      "text": "Type Bit Maps Field = ( Window Block # | Bitmap Length | Bitmap )+",
      "ja": "入力ビットマップのフィールド=（ウィンドウブロック＃|ビットマップの長さ|ビットマップ）+"
    },
    {
      "indent": 3,
      "text": "The plus sign in the regular expression indicates that there is one or more of the preceding element. This means that there must be at least one window block. If this window block has no types, it contradicts with the first statement. Therefore, the correct text in Section 3.2.1 of [RFC5155] should be:",
      "ja": "正規表現中のプラス記号は、先行する要素の1つ以上が存在することを示しています。これは、少なくとも一つのウィンドウブロックが存在しなければならないことを意味しています。このウィンドウブロックが何の種類を持っていない場合は、最初の文と矛盾します。したがって、[RFC5155]のセクション3.2.1に正しいテキストは次のようになります。"
    },
    {
      "indent": 6,
      "text": "Type Bit Maps Field = ( Window Block # | Bitmap Length | Bitmap )*",
      "ja": "タイプビットマップのフィールド=（ウィンドウブロック＃|ビットマップの長さ|ビットマップ）*"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document adds SHA-2 and NSEC3 support to the core DNSSEC protocol. Security considerations for those features are discussed in the documents defining them. Additionally, this document addresses some ambiguities and omissions in the core DNSSEC documents that, if not recognized and addressed in implementations, could lead to security failures. In particular, the validation algorithm clarifications in Section 4 are critical for preserving the security properties DNSSEC offers. Furthermore, failure to address some of the interoperability concerns in Section 5 could limit the ability to later change or expand DNSSEC, including adding new algorithms.",
      "ja": "この文書では、コアDNSSECプロト​​コルにSHA-2とNSEC3のサポートを追加します。これらの機能のためのセキュリティの考慮事項は、それらを定義する文書で説明されています。また、この文書は認識され、実装で対処しなければ、セキュリティの障害につながる可能性が、コアDNSSEC文書のいくつかのあいまいさや脱落に対応しています。特に、第4節で検証アルゴリズムの明確化は、DNSSECが提供するセキュリティプロパティを維持するために重要です。さらに、第5節での相互運用性の問題の一部に対処するための失敗は、新しいアルゴリズムを追加するなど、後からDNSSECを変更したり、拡大する能力を制限することができます。"
    },
    {
      "indent": 3,
      "text": "The recommendation in Section 5.9 to always set the CD bit has security implications. By setting the CD bit, a resolver will not benefit from more stringent validation rules or a more complete set of trust anchors at an upstream validator.",
      "ja": "常にCDビットを設定するために5.9節での勧告は、セキュリティの意味を持っています。 CDビットを設定することにより、リゾルバは、より厳格な検証ルールや上流のバリでのトラストアンカーのより完全なセットの恩恵を受けることはありません。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain names - concepts and facilities\", STD 13, RFC 1034, November 1987.",
      "ja": "[RFC1034] Mockapetris、P.、 \"ドメイン名 - 概念と設備\"、STD 13、RFC 1034、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3225] Conrad, D., \"Indicating Resolver Support of DNSSEC\", RFC 3225, December 2001.",
      "ja": "[RFC3225]コンラッド、D.、 \"DNSSECのレゾルバサポートを示す\"、RFC 3225、2001年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4033] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"DNS Security Introduction and Requirements\", RFC 4033, March 2005.",
      "ja": "[RFC4033]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 \"DNSセキュリティ序論と要件\"、RFC 4033、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4034] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"Resource Records for the DNS Security Extensions\", RFC 4034, March 2005.",
      "ja": "[RFC4034]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 \"DNSセキュリティ拡張機能のためのリソースレコード\"、RFC 4034、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4035] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"Protocol Modifications for the DNS Security Extensions\", RFC 4035, March 2005.",
      "ja": "[RFC4035]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 \"DNSセキュリティ拡張のためのプロトコル変更\"、RFC 4035、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4509] Hardaker, W., \"Use of SHA-256 in DNSSEC Delegation Signer (DS) Resource Records (RRs)\", RFC 4509, May 2006.",
      "ja": "[RFC4509] Hardaker、W.、RFC 4509、2006年5月 \"DNSSEC委任署名者（DS）リソースレコード（RR）でSHA-256の使用\"。"
    },
    {
      "indent": 3,
      "text": "[RFC5155] Laurie, B., Sisson, G., Arends, R., and D. Blacka, \"DNS Security (DNSSEC) Hashed Authenticated Denial of Existence\", RFC 5155, March 2008.",
      "ja": "[RFC5155]ローリー、B.、シッソン、G.、アレンズ、R.、およびD. Blacka、 \"DNSセキュリティ（DNSSEC）存在のハッシュ認証拒否\"、RFC 5155、2008年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5702] Jansen, J., \"Use of SHA-2 Algorithms with RSA in DNSKEY and RRSIG Resource Records for DNSSEC\", RFC 5702, October 2009.",
      "ja": "[RFC5702]ヤンセン、J.、 \"DNSKEYとDNSSECのためのRRSIGリソースレコードでRSAとSHA-2アルゴリズムの使用\"、RFC 5702、2009年10月。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[Huston] Michaelson, G., Wallstrom, P., Arends, R., and G. Huston, \"Rolling Over DNSSEC Keys\", Internet Protocol Journal, Vol. 13, No.1, pp. 2-16, March 2010.",
      "ja": "[ヒューストン]マイケルソン、G.、Wallstrom、P.、アレンズ、R.、およびG.ヒューストン、 \"ローリングオーバーDNSSECキー\"、インターネット・プロトコル・ジャーナル、巻。 13、第1号、頁2-16、2010年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2308] Andrews, M., \"Negative Caching of DNS Queries (DNS NCACHE)\", RFC 2308, March 1998.",
      "ja": "[RFC2308]アンドリュース、M.、 \"DNSクエリのネガティブキャッシュ（DNS NCACHE）\"、RFC 2308、1998年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3755] Weiler, S., \"Legacy Resolver Compatibility for Delegation Signer (DS)\", RFC 3755, May 2004.",
      "ja": "[RFC3755]ワイラー、S.、 \"委任署名者のためのレガシーレゾルバの互換性（DS）\"、RFC 3755、2004年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4955] Blacka, D., \"DNS Security (DNSSEC) Experiments\", RFC 4955, July 2007.",
      "ja": "[RFC4955] Blacka、D.、 \"DNSセキュリティ（DNSSEC）実験\"、RFC 4955、2007年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC5011] StJohns, M., \"Automated Updates of DNS Security (DNSSEC) Trust Anchors\", STD 74, RFC 5011, September 2007.",
      "ja": "[RFC5011] StJohns、M.、 \"DNSセキュリティ（DNSSEC）トラストアンカーの自動更新\"、STD 74、RFC 5011、2007年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5074] Weiler, S., \"DNSSEC Lookaside Validation (DLV)\", RFC 5074, November 2007.",
      "ja": "[RFC5074]ワイラー、S.、 \"DNSSECルックアサイドバリデーション（DLV）\"、RFC 5074、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC6781] Kolkman, O., Mekking, W., and R. Gieben, \"DNSSEC Operational Practices, Version 2\", RFC 6781, December 2012.",
      "ja": "[RFC6781] Kolkman、O.、Mekking、W.、およびR. Gieben、 \"DNSSEC運用・プラクティス、バージョン2\"、RFC 6781、2012年12月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Acknowledgments",
      "ja": "付録A.謝辞"
    },
    {
      "indent": 3,
      "text": "The editors would like the thank Rob Austein for his previous work as an editor of this document.",
      "ja": "編集者は、この文書の編集者として彼の前の仕事に感謝ロブAusteinとしたいと思います。"
    },
    {
      "indent": 3,
      "text": "The editors are extremely grateful to those who, in addition to finding errors and omissions in the DNSSEC document set, have provided text suitable for inclusion in this document.",
      "ja": "編集者は、DNSSECのドキュメントセットに誤りや見落としを見つけることに加えて、この文書に含めるのに適したテキストを提供してきた人たちに非常に感謝しています。"
    },
    {
      "indent": 3,
      "text": "The lack of specificity about handling private algorithms, as described in Section 5.3, and the lack of specificity in handling ANY queries, as described in Section 4.2, were discovered by David Blacka.",
      "ja": "5.3節で説明したように、プライベートアルゴリズムの取り扱いについて特異性の欠如、および4.2節で説明したように、任意のクエリを処理する際の特異性の欠如は、デビッドBlackaによって発見されました。"
    },
    {
      "indent": 3,
      "text": "The error in algorithm 1 key tag calculation, as described in Section 5.5, was found by Abhijit Hayatnagarkar. Donald Eastlake contributed text for Section 5.5.",
      "ja": "アルゴリズム1キータグ計算における誤差は、5.5節で説明したように、Abhijit Hayatnagarkarによって発見されました。ドナルドイーストレイクは、5.5節のテキストを拠出しました。"
    },
    {
      "indent": 3,
      "text": "The bug relating to delegation NSEC RR's in Section 4.1 was found by Roy Badami. Roy Arends found the related problem with DNAME.",
      "ja": "4.1節で委任NSEC RRのに関連するバグがロイBadamiによって発見されました。ロイ・アレンズはDNAMEと、関連する問題を発見しました。"
    },
    {
      "indent": 3,
      "text": "The errors in the [RFC4035] examples were found by Roy Arends, who also contributed text for Section 6.3 of this document.",
      "ja": "[RFC4035]の例ではエラーもこのドキュメントのセクション6.3のテキストを拠出ロイ・アレンズ、によって発見されました。"
    },
    {
      "indent": 3,
      "text": "Text on the mandatory algorithm rules was derived from suggestions by Matthijs Mekking and Ed Lewis.",
      "ja": "必須アルゴリズムルールのテキストはMatthijs Mekkingとエド・ルイスによる提案から派生しました。"
    },
    {
      "indent": 3,
      "text": "The CD bit logic was analyzed in depth by David Blacka, Olafur Gudmundsson, Mike St. Johns, and Andrew Sullivan.",
      "ja": "CDのビット論理はデビッドBlacka、オラフルグドムンソン、マイク・セントジョンズ、そしてアンドリュー・サリバンによって徹底的に分析しました。"
    },
    {
      "indent": 3,
      "text": "The editors would like to thank Alfred Hoenes, Ed Lewis, Danny Mayer, Olafur Gudmundsson, Suzanne Woolf, Rickard Bellgrim, Mike St. Johns, Mark Andrews, Wouter Wijngaards, Matthijs Mekking, Andrew Sullivan, Jeremy Reed, Paul Hoffman, Mohan Parthasarathy, Florian Weimer, Warren Kumari and Scott Rose for their contributions to this document.",
      "ja": "編集者は、アルフレッドHoenes、エド・ルイス、ダニー・メイヤー、オラフルグドムンソン、スザンヌ・ウルフ、リカードBellgrim、マイク・セントジョーンズ、マーク・アンドリュース、はWouter Wijngaards、Matthijs Mekking、アンドリュー・サリバン、ジェレミー・リード、ポール・ホフマン、モハンパルタサラティに感謝したいと思いますこのドキュメントへの貢献のためのフロリアンWeimerさん、ウォーレン・クマリとスコット・ローズ。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Discussion of Setting the CD Bit",
      "ja": "CDビットを設定する付録B.ディスカッション"
    },
    {
      "indent": 3,
      "text": "[RFC4035] may be read as relying on the implicit assumption that there is at most one validating system between the stub resolver and the authoritative server for a given zone. It is entirely possible, however, for more than one validator to exist between a stub resolver and an authoritative server. If these different validators have disjoint trust anchors configured, then it is possible that each would be able to validate some portion of the DNS tree, but neither is able to validate all of it. Accordingly, it might be argued that it is desirable not to set the CD bit on upstream queries, because that allows for maximal validation.",
      "ja": "[RFC4035]は、所与のゾーンのスタブリゾルバと認証サーバとの間の最大で1つの検証するシステムがあることを暗黙の前提に依存するように読み取ることができます。複数のバリデータがスタブリゾルバと認証サーバとの間に存在することが、しかし、完全に可能です。これらの異なるバリデータが設定さ互いに素信頼アンカーを持っている場合、それぞれがDNSツリーの一部を検証することができるだろうことは可能であるが、どちらも、それのすべてを検証することができます。したがって、それが最大の検証が可能になりますので、上流のクエリにCDビットを設定しないことが望ましいと主張される可能性があります。"
    },
    {
      "indent": 3,
      "text": "In Section 5.9 of this document, it is recommended to set the CD bit on an upstream query even when the incoming query arrives with CD=0. This is for two reasons: it encourages a more predictable validation experience as only one validator is always doing the validation, and it ensures that all DNSSEC data that exists may be available from the local cache should a query with CD=1 arrive.",
      "ja": "このドキュメントのセクション5.9で、入ってくるクエリがCD = 0で到着した場合でも、上流のクエリにCDビットを設定することをお勧めします。これは、2つの理由である：それは唯一のバリデータが常に検証を行っているように、より予測可能な検証の経験を奨励し、それが存在するすべてのDNSSECデータはCD = 1とクエリが到着する必要があり、ローカルキャッシュから利用できることを保証します。"
    },
    {
      "indent": 3,
      "text": "As a matter of policy, it is possible to set the CD bit differently than suggested in Section 5.9. A different choice will, of course, not always yield the benefits listed above. It is beyond the scope of this document to outline all of the considerations and counter considerations for all possible policies. Nevertheless, it is possible to describe three approaches and their underlying philosophy of operation. These are laid out in the tables below.",
      "ja": "政策の問題として、5.9節で提案とは異なるCDビットを設定することが可能です。別の選択は、もちろん、常に上記の利点を得られません。これは、すべての可能なポリシーの考慮事項とカウンタの考慮事項のすべてを概説するために、このドキュメントの範囲を超えています。それにもかかわらず、3つのアプローチや操作の基礎となる考え方を記述することが可能です。これらは、下記の表にレイアウトされています。"
    },
    {
      "indent": 3,
      "text": "The table that describes each model has five columns. The first column indicates the value of the CD bit that the resolver receives (for instance, on the name server side in an iterative resolver, or as local policy or from the API in the case of a stub). The second column indicates whether the query needs to be forwarded for resolution (F) or can be satisfied from a local cache (C). The third column is a line number, so that it can be referred to later in the table. The fourth column indicates any relevant conditions at the resolver, for example, whether the resolver has a covering trust anchor, and so on. If there are no parameters here, the column is empty. The fifth and final column indicates what action the resolver takes.",
      "ja": "各モデルを記述したテーブルには、5つの列があります。最初の列は、CDの値は、リゾルバが（例えば、反復リゾルバにおけるネームサーバ側で、またはローカルポリシーとして、またはスタブの場合はAPIから）受信したビットを示しています。第2列は、クエリが分解能（F）のために転送する必要があるか、ローカルキャッシュ（C）から満たすことができるかどうかを示します。それは後でテーブルで参照できるように3列目は、行番号です。第4列は、レゾルバがそうで被覆トラストアンカーを有し、かどうか、例えば、レゾルバに関連するすべての状態を示しています。ここでのパラメータがない場合は、列は空です。 5番目と最後の列は、リゾルバが取るべきアクションを示します。"
    },
    {
      "indent": 3,
      "text": "The tables differentiate between \"cached data\" and \"cached RCODE=2\". This is a shorthand; the point is that one has to treat RCODE=2 (server failure) as special, because it might indicate a validation failure somewhere upstream. The distinction is really between \"cached RCODE=2\" and \"cached everything else\".",
      "ja": "表には、「キャッシュされたデータ」と「キャッシュされたRCODE = 2」を区別します。これは簡略化したものです。ポイントは1つが、それはどこか上流の検証の失敗を示している可能性がありますので、などの特別なRCODE = 2（サーバ障害）の治療にならないことです。区別は、「キャッシュされたRCODE = 2」と「それ以外のキャッシュされたすべてのもの」の間で実際にあります。"
    },
    {
      "indent": 3,
      "text": "The tables are probably easiest to think of in terms of describing what happens when a stub resolver sends a query to an intermediate resolver, but they are perfectly general and can be applied to any validating resolver.",
      "ja": "テーブルはおそらく、スタブリゾルバは、中間リゾルバにクエリを送信したときに何が起こるか記述の観点で考えることが最も簡単ですが、彼らは完全に一般的であり、任意の検証をリゾルバにも適用することができます。"
    },
    {
      "indent": 3,
      "text": "Model 1: \"always set\"",
      "ja": "モデル1：「常にセット」"
    },
    {
      "indent": 3,
      "text": "This model is so named because the validating resolver sets the CD bit on queries it makes regardless of whether it has a covering trust anchor for the query. The general philosophy represented by this table is that only one resolver should be responsible for validation irrespective of the possibility that an upstream resolver may be present with trust anchors that cover different or additional QNAMEs. It is the model recommended in Section 5.9 of this document.",
      "ja": "検証をリゾルバが、それは関係なく、それがクエリの被覆トラストアンカーを持っているかどうかの可能クエリのCDビットが設定されますので、このモデルは、そのように命名されます。この表で示される一般的な原理は、一つだけリゾルバに関わらず、上流リゾルバが異なるまたは追加のQNameを覆うトラストアンカーと存在し得る可能性の検証を担当するべきであるということです。これは、このドキュメントのセクション5.9で推奨モデルです。"
    },
    {
      "indent": 4,
      "text": "CD F/C    line      conditions            action\n====================================================================\n1   F      A1                             Set CD=1 on upstream query\n0   F      A2                             Set CD=1 on upstream query\n1   C      A3                             Return the cache contents\n                                           (data or RCODE=2)\n0   C      A4       no covering TA        Return cache contents\n                                           (data or RCODE=2)\n0   C      A5       covering TA           Validate cached result and\n                                           return it",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Model 2: \"never set when receiving CD=0\"",
      "ja": "モデル2：「CD = 0を受信したときに設定したことがありません」"
    },
    {
      "indent": 3,
      "text": "This model is so named because it sets CD=0 on upstream queries for all received CD=0 queries, even if it has a covering trust anchor. The general philosophy represented by this table is that more than one resolver may take responsibility for validating a QNAME and that a validation failure for a QNAME by any resolver in the chain is a validation failure for the query. Using this model is NOT RECOMMENDED.",
      "ja": "それは、被覆トラストアンカーを持っている場合でも、受信したすべてのCD = 0のクエリのための上流クエリにCD = 0を設定しますので、このモデルは、そのように命名されます。この表によって表される一般的な哲学は、複数のリゾルバがQNAMEを検証するため、チェーン内のすべてのリゾルバによってQNAMEの検証失敗がクエリの検証の失敗であることの責任を取ることです。このモデルを使用することはお勧めできません。"
    },
    {
      "indent": 4,
      "text": "CD F/C    line       conditions           action\n====================================================================\n1  F      N1                              Set CD=1 on upstream query\n0  F      N2                              Set CD=0 on upstream query\n1  C      N3         cached data          Return cached data\n1  C      N4         cached RCODE=2       Treat as line N1\n0  C      N5         no covering TA       Return cache contents\n                                           (data or RCODE=2)\n0  C      N6         covering TA &        Treat as line N2\n                      cached data was\n                      generated with CD=1\n0  C      N7         covering TA &        Validate and return\n                      cached data was\n                      generated with CD=0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Model 3: \"sometimes set\"",
      "ja": "モデル3：「時々設定」"
    },
    {
      "indent": 3,
      "text": "This model is so named because it sets the CD bit on upstream queries triggered by received CD=0 queries, based on whether the validator has a trust anchor configured that covers the query. If there is no covering trust anchor, the resolver clears the CD bit in the upstream query. If there is a covering trust anchor, the resolver sets CD=1 and performs validation itself. The general philosophy represented by this table is that a resolver should try and validate QNAMEs for which it has trust anchors and should not preclude validation by other resolvers for QNAMEs for which it does not have covering trust anchors. Using this model is NOT RECOMMENDED.",
      "ja": "それはバリデータがクエリをカバー構成されたトラストアンカーを持っているかどうかに基づいて、受信したCD = 0クエリによってトリガ上流クエリのCDビットを設定しますので、このモデルは、そのように命名されます。無被覆トラストアンカーが存在しない場合、リゾルバは上流クエリ内のCDビットをクリアします。被覆トラストアンカーが存在する場合、リゾルバはCD = 1を設定し、検証自体を行います。この表によって表される一般的な哲学は、リゾルバがしようとすると、それは信頼アンカーを持っているのQNameを検証し、それをカバーする信頼アンカーを持たないためのQNameのために他のリゾルバによる検証を排除すべきでないということです。このモデルを使用することはお勧めできません。"
    },
    {
      "indent": 4,
      "text": "CD F/C    line       conditions         action\n====================================================================\n1  F      S1                            Set CD=1 on upstream query\n0  F      S2         covering TA        Set CD=1 on upstream query\n0  F      S3         no covering TA     Set CD=0 on upstream query\n1  C      S4         cached data        Return cached data\n1  C      S5         cached RCODE=2     Treat as line S1\n0  C      S6         cached data was    Return cache contents\n                      generated with\n                      CD=0\n0  C      S7         cached data was    Validate & return cache\n                      generated with     contents\n                      CD=1 &\n                      covering TA\n0  C      S8         cached RCODE=2     Return cache contents\n0  C      S9         cached data        Treat as line S3\n                      was generated\n                      with CD=1 &\n                      no covering\n                      TA",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix C. Discussion of Trust Anchor Preference Options",
      "ja": "トラストアンカーの設定オプションの付録C.議論"
    },
    {
      "indent": 3,
      "text": "This section presents several different policies for validating resolvers to use when they have a choice of trust anchors available for validating a given answer.",
      "ja": "このセクションでは、彼らが与えられた答えを検証するために利用できるトラストアンカーの選択肢を持っているときに使用するリゾルバを検証するため、いくつかの異なるポリシーを提示します。"
    },
    {
      "indent": 0,
      "text": "C.1. Closest Encloser",
      "ja": "C.1。最寄のエンクロージャ"
    },
    {
      "indent": 3,
      "text": "One policy is to choose the trust anchor closest to the QNAME of the response. For example, consider a validator configured with trust anchors for \"example.\" and \"zone.example.\" When asked to validate a response for \"www.sub.zone.example.\", a validator using the \"Closest Encloser\" policy would choose the \"zone.example.\" trust anchor.",
      "ja": "一つの政策は、応答のQNAMEに最も近いトラストアンカーを選択することです。例えば、のためのトラストアンカーで構成されたバリデータを検討「の例を。」そして \"zone.example。\"応答を検証するために求められたら、「www.sub.zone.exampleを。」、「最も近いencloser」ポリシーを使用してバリデータは「zone.example」を選ぶだろうトラストアンカー。"
    },
    {
      "indent": 3,
      "text": "This policy has the advantage of allowing the operator to trivially override a parent zone's trust anchor with one that the operator can validate in a stronger way, perhaps because the resolver operator is affiliated with the zone in question. This policy also minimizes the number of public key operations needed, which is of benefit in resource-constrained environments.",
      "ja": "このポリシーは、オペレータは自明オペレータがリゾルバオペレータが問題になっているゾーンと提携しているかもしれないので、より強力な方法で検証することができるもので、親ゾーンのトラストアンカーを上書きすることができるという利点があります。このポリシーは、リソースに制約のある環境でも有益である必要パブリックキー操作の数を、最小限に抑えることができます。"
    },
    {
      "indent": 3,
      "text": "This policy has the disadvantage of giving the user some unexpected and unnecessary validation failures when sub-zone trust anchors are neglected. As a concrete example, consider a validator that configured a trust anchor for \"zone.example.\" in 2009 and one for \"example.\" in 2011. In 2012, \"zone.example.\" rolls its Key Signing Key (KSK) and updates its DS records, but the validator operator doesn't update its trust anchor. With the \"Closest Encloser\" policy, the validator gets validation failures.",
      "ja": "このポリシーは、サブゾーンのトラストアンカーが無視された場合、ユーザーにいくつかの予期しない、不要な検証の失敗を与えるという欠点があります。具体的な例として、のためのトラストアンカーに構成バリ考える「zone.exampleを。」 2009年に1つの「例。」 2012年2011年に、 \"zone.example。\"その鍵署名鍵（KSK）をロールし、そのDSレコードを更新しますが、バリのオペレータは、そのトラストアンカーを更新しません。 「最も近いencloser」ポリシーでは、バリデータは、検証の失敗を取得します。"
    },
    {
      "indent": 0,
      "text": "C.2. Accept Any Success",
      "ja": "C.2。任意の成功を受け入れます"
    },
    {
      "indent": 3,
      "text": "Another policy is to try all applicable trust anchors until one gives a validation result of Secure, in which case the final validation result is Secure. If and only if all applicable trust anchors give a result of Insecure, the final validation result is Insecure. If one or more trust anchors lead to a Bogus result and there is no Secure result, then the final validation result is Bogus.",
      "ja": "別のポリシーは1つが、最終的な検証結果がセキュアである場合には、セキュリティで保護さの検証結果を与えるまで、該当するすべてのトラストアンカーを試してみることです。そして、該当するすべてのトラストアンカーが安全でない結果が得られた場合にのみ場合は、最終検証結果は、安全でないです。一つ以上のトラストアンカーが偽結果につながると何のセキュアな結果がない場合、最終的な検証結果が偽です。"
    },
    {
      "indent": 3,
      "text": "This has the advantage of causing the fewest validation failures, which may deliver a better user experience. If one trust anchor is out of date (as in our above example), the user may still be able to get a Secure validation result (and see DNS responses).",
      "ja": "これは、より優れたユーザー体験を提供することが最も少ないの検証の失敗を引き起こすという利点を有しています。 1つのトラストアンカーは（私たちの上記の例のように）期限が切れている場合、ユーザーはセキュアな検証結果を取得（およびDNS応答を参照）することができるかもしれません。"
    },
    {
      "indent": 3,
      "text": "This policy has the disadvantage of making the validator subject to the compromise of the weakest of these trust anchors, while making it relatively painless to keep old trust anchors configured in perpetuity.",
      "ja": "このポリシーは、永続的に構成された古いトラストアンカーを維持することが比較的簡単ながら、これらのトラストアンカーの最も弱いの妥協にバリの件名を作るという欠点があります。"
    },
    {
      "indent": 0,
      "text": "C.3. Preference Based on Source",
      "ja": "C.3。ソースに基づいて優先"
    },
    {
      "indent": 3,
      "text": "When the trust anchors have come from different sources (e.g., automated updates ([RFC5011]), one or more DNSSEC Lookaside Validation (DLV) registries ([RFC5074]), and manual configuration), a validator may wish to choose between them based on the perceived reliability of those sources. The order of precedence might be exposed as a configuration option.",
      "ja": "トラストアンカーは、異なるソース（例えば、自動更新（[RFC5011]）、一つ以上のDNSSECルックアサイドバリデーション（DLV）レジストリ（[RFC5074]）、および手動設定）から来ている場合は、バリデータは、それらの間でベースを選択することを望むかもしれませんこれらのソースの知覚信頼性に。優先順位は、設定オプションとして公開される可能性があります。"
    },
    {
      "indent": 3,
      "text": "For example, a validator might choose to prefer trust anchors found in a DLV registry over those manually configured on the theory that the manually configured ones will not be as aggressively maintained.",
      "ja": "たとえば、バリデータは手動で手動で構成するものがのように積極的に維持されないことを理論上で設定されたものの上にDLVレジストリで見つかった信頼アンカーを好むことを選択するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Conversely, a validator might choose to prefer manually configured trust anchors over those obtained from a DLV registry on the theory that the manually configured ones have been more carefully authenticated.",
      "ja": "逆に、バリデータは手動で設定したものは、より慎重に認証されているという理論にDLVレジストリから取得したものよりも、手動で設定された信頼アンカーを好むことを選択するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Or the validator might do something more complex: prefer a sub-set of manually configured trust anchors (based on a configuration option), then trust anchors that have been updated using the mechanism in [RFC5011], then trust anchors from one DLV registry, then trust anchors from a different DLV registry, then the rest of the manually configured trust anchors.",
      "ja": "またはバリデータは、より複雑な何かをすることがあります（設定オプションに基づいて）手動で設定されたトラストアンカーのサブセット好むし、[RFC5011]でメカニズムを使用して更新されている信頼アンカーは、その後、1つのDLVレジストリからアンカーを信頼し、その後、別のDLVレジストリ、手動で構成されたトラストアンカーの後、残りの部分からアンカーを信頼しています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Samuel Weiler (editor) SPARTA, Inc. 7110 Samuel Morse Drive Columbia, MD 21046 US",
      "ja": "サミュエル・ワイラー（編集者）SPARTA、Inc.の7110サミュエル・モールスドライブコロンビア、MD 21046米国"
    },
    {
      "indent": 3,
      "text": "EMail: weiler@tislabs.com",
      "ja": "メールアドレス：weiler@tislabs.com"
    },
    {
      "indent": 3,
      "text": "David Blacka (editor) Verisign, Inc. 12061 Bluemont Way Reston, VA 20190 US",
      "ja": "デビッドBlacka（編集者）ベリサイン社12061 Bluemontウェイレストン、バージニア州20190米国"
    },
    {
      "indent": 3,
      "text": "EMail: davidb@verisign.com",
      "ja": "メールアドレス：davidb@verisign.com"
    }
  ]
}