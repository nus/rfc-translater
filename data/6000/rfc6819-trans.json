{
  "title": {
    "text": "RFC 6819 - OAuth 2.0 Threat Model and Security Considerations",
    "ja": "RFC 6819 - OAuth 2.0の脅威モデルおよびセキュリティに関する注意事項"
  },
  "number": 6819,
  "created_at": "2019-10-31 08:09:40.162493+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)               T. Lodderstedt, Ed.\nRequest for Comments: 6819                           Deutsche Telekom AG\nCategory: Informational                                       M. McGloin\nISSN: 2070-1721                                                      IBM\n                                                                 P. Hunt\n                                                      Oracle Corporation\n                                                            January 2013",
      "raw": true
    },
    {
      "indent": 11,
      "text": "OAuth 2.0 Threat Model and Security Considerations",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document gives additional security considerations for OAuth, beyond those in the OAuth 2.0 specification, based on a comprehensive threat model for the OAuth 2.0 protocol.",
      "ja": "この文書では、OAuth 2.0のプロトコルのための包括的な脅威モデルに基づいて、OAuth 2.0の仕様のものを超えて、OAuthのた​​めの追加のセキュリティの考慮事項を示します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6819.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6819で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................6\n2. Overview ........................................................7\n   2.1. Scope ......................................................7\n   2.2. Attack Assumptions .........................................7\n   2.3. Architectural Assumptions ..................................8\n        2.3.1. Authorization Servers ...............................8\n        2.3.2. Resource Server .....................................9\n        2.3.3. Client ..............................................9\n3. Security Features ...............................................9\n   3.1. Tokens ....................................................10\n        3.1.1. Scope ..............................................11\n        3.1.2. Limited Access Token Lifetime ......................11\n   3.2. Access Token ..............................................11\n   3.3. Refresh Token .............................................11\n   3.4. Authorization \"code\" ......................................12\n   3.5. Redirect URI ..............................................13\n   3.6. \"state\" Parameter .........................................13\n   3.7. Client Identifier .........................................13\n4. Threat Model ...................................................15\n   4.1. Clients ...................................................16\n        4.1.1. Threat: Obtaining Client Secrets ...................16\n        4.1.2. Threat: Obtaining Refresh Tokens ...................17\n        4.1.3. Threat: Obtaining Access Tokens ....................19\n        4.1.4. Threat: End-User Credentials Phished Using\n               Compromised or Embedded Browser ....................19\n        4.1.5. Threat: Open Redirectors on Client .................20\n   4.2. Authorization Endpoint ....................................21\n        4.2.1. Threat: Password Phishing by Counterfeit\n               Authorization Server ...............................21\n        4.2.2. Threat: User Unintentionally Grants Too\n               Much Access Scope ..................................21\n        4.2.3. Threat: Malicious Client Obtains Existing\n               Authorization by Fraud .............................22\n        4.2.4. Threat: Open Redirector ............................22\n   4.3. Token Endpoint ............................................23\n        4.3.1. Threat: Eavesdropping Access Tokens ................23\n        4.3.2. Threat: Obtaining Access Tokens from\n               Authorization Server Database ......................23\n        4.3.3. Threat: Disclosure of Client Credentials\n               during Transmission ................................23\n        4.3.4. Threat: Obtaining Client Secret from\n               Authorization Server Database ......................24\n        4.3.5. Threat: Obtaining Client Secret by Online Guessing .24",
      "raw": true
    },
    {
      "indent": 6,
      "text": "4.4. Obtaining Authorization ...................................25\n     4.4.1. Authorization \"code\" ...............................25\n            4.4.1.1. Threat: Eavesdropping or Leaking\n                     Authorization \"codes\" .....................25\n            4.4.1.2. Threat: Obtaining Authorization \"codes\"\n                     from Authorization Server Database ........26\n            4.4.1.3. Threat: Online Guessing of\n                     Authorization \"codes\" .....................27\n            4.4.1.4. Threat: Malicious Client Obtains\n                     Authorization .............................27\n            4.4.1.5. Threat: Authorization \"code\" Phishing .....29\n            4.4.1.6. Threat: User Session Impersonation ........29\n            4.4.1.7. Threat: Authorization \"code\" Leakage\n                     through Counterfeit Client ................30\n            4.4.1.8. Threat: CSRF Attack against redirect-uri ..32\n            4.4.1.9. Threat: Clickjacking Attack against\n                     Authorization .............................33\n            4.4.1.10. Threat: Resource Owner Impersonation .....33\n            4.4.1.11. Threat: DoS Attacks That Exhaust\n                      Resources ................................34\n            4.4.1.12. Threat: DoS Using Manufactured\n                      Authorization \"codes\" ....................35\n            4.4.1.13. Threat: Code Substitution (OAuth Login) ..36\n     4.4.2. Implicit Grant .....................................37\n            4.4.2.1. Threat: Access Token Leak in\n                     Transport/Endpoints .......................37\n            4.4.2.2. Threat: Access Token Leak in\n                     Browser History ...........................38\n            4.4.2.3. Threat: Malicious Client Obtains\n                     Authorization .............................38\n            4.4.2.4. Threat: Manipulation of Scripts ...........38\n            4.4.2.5. Threat: CSRF Attack against redirect-uri ..39\n            4.4.2.6. Threat: Token Substitution (OAuth Login) ..39\n     4.4.3. Resource Owner Password Credentials ................40\n            4.4.3.1. Threat: Accidental Exposure of\n                     Passwords at Client Site ..................41\n            4.4.3.2. Threat: Client Obtains Scopes\n                     without End-User Authorization ............42\n            4.4.3.3. Threat: Client Obtains Refresh\n                     Token through Automatic Authorization .....42\n            4.4.3.4. Threat: Obtaining User Passwords\n                     on Transport ..............................43\n            4.4.3.5. Threat: Obtaining User Passwords\n                     from Authorization Server Database ........43\n            4.4.3.6. Threat: Online Guessing ...................43\n     4.4.4. Client Credentials .................................44",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   4.5. Refreshing an Access Token ................................44\n        4.5.1. Threat: Eavesdropping Refresh Tokens from\n               Authorization Server ...............................44\n        4.5.2. Threat: Obtaining Refresh Token from\n               Authorization Server Database ......................44\n        4.5.3. Threat: Obtaining Refresh Token by Online\n               Guessing ...........................................45\n        4.5.4. Threat: Refresh Token Phishing by\n               Counterfeit Authorization Server ...................45\n   4.6. Accessing Protected Resources .............................46\n        4.6.1. Threat: Eavesdropping Access Tokens on Transport ...46\n        4.6.2. Threat: Replay of Authorized Resource\n               Server Requests ....................................46\n        4.6.3. Threat: Guessing Access Tokens .....................46\n        4.6.4. Threat: Access Token Phishing by\n               Counterfeit Resource Server ........................47\n        4.6.5. Threat: Abuse of Token by Legitimate\n               Resource Server or Client ..........................48\n        4.6.6. Threat: Leak of Confidential Data in HTTP Proxies ..48\n        4.6.7. Threat: Token Leakage via Log Files and\n               HTTP Referrers .....................................48\n5. Security Considerations ........................................49\n   5.1. General ...................................................49\n        5.1.1. Ensure Confidentiality of Requests .................49\n        5.1.2. Utilize Server Authentication ......................50\n        5.1.3. Always Keep the Resource Owner Informed ............50\n        5.1.4. Credentials ........................................51\n               5.1.4.1. Enforce Credential Storage\n                        Protection Best Practices .................51\n               5.1.4.2. Online Attacks on Secrets .................52\n        5.1.5. Tokens (Access, Refresh, Code) .....................53\n               5.1.5.1. Limit Token Scope .........................53\n               5.1.5.2. Determine Expiration Time .................54\n               5.1.5.3. Use Short Expiration Time .................54\n               5.1.5.4. Limit Number of Usages or One-Time Usage ..55\n               5.1.5.5. Bind Tokens to a Particular\n                        Resource Server (Audience) ................55\n               5.1.5.6. Use Endpoint Address as Token Audience ....56\n               5.1.5.7. Use Explicitly Defined Scopes for\n                        Audience and Tokens .......................56\n               5.1.5.8. Bind Token to Client id ...................56\n               5.1.5.9. Sign Self-Contained Tokens ................56\n               5.1.5.10. Encrypt Token Content ....................56\n               5.1.5.11. Adopt a Standard Assertion Format ........57\n        5.1.6. Access Tokens ......................................57",
      "raw": true
    },
    {
      "indent": 6,
      "text": "5.2. Authorization Server ......................................57\n     5.2.1. Authorization \"codes\" ..............................57\n            5.2.1.1. Automatic Revocation of Derived\n                     Tokens If Abuse Is Detected ...............57\n     5.2.2. Refresh Tokens .....................................57\n            5.2.2.1. Restricted Issuance of Refresh Tokens .....57\n            5.2.2.2. Binding of Refresh Token to \"client_id\" ...58\n            5.2.2.3. Refresh Token Rotation ....................58\n            5.2.2.4. Revocation of Refresh Tokens ..............58\n            5.2.2.5. Device Identification .....................59\n            5.2.2.6. X-FRAME-OPTIONS Header ....................59\n     5.2.3. Client Authentication and Authorization ............59\n            5.2.3.1. Don't Issue Secrets to Clients with\n                     Inappropriate Security Policy .............60\n            5.2.3.2. Require User Consent for Public\n                     Clients without Secret ....................60\n            5.2.3.3. Issue a \"client_id\" Only in\n                     Combination with \"redirect_uri\" ...........61\n            5.2.3.4. Issue Installation-Specific Client\n                     Secrets ...................................61\n            5.2.3.5. Validate Pre-Registered \"redirect_uri\" ....62\n            5.2.3.6. Revoke Client Secrets .....................63\n            5.2.3.7. Use Strong Client Authentication\n                     (e.g., client_assertion/client_token) .....63\n     5.2.4. End-User Authorization .............................63\n            5.2.4.1. Automatic Processing of Repeated\n                     Authorizations Requires Client Validation .63\n            5.2.4.2. Informed Decisions Based on Transparency ..63\n            5.2.4.3. Validation of Client Properties by\n                     End User ..................................64\n            5.2.4.4. Binding of Authorization \"code\" to\n                     \"client_id\" ...............................64\n            5.2.4.5. Binding of Authorization \"code\" to\n                     \"redirect_uri\" ............................64\n5.3. Client App Security .......................................65\n     5.3.1. Don't Store Credentials in Code or\n            Resources Bundled with Software Packages ...........65\n     5.3.2. Use Standard Web Server Protection Measures\n            (for Config Files and Databases) ...................65\n     5.3.3. Store Secrets in Secure Storage ....................65\n     5.3.4. Utilize Device Lock to Prevent Unauthorized\n            Device Access ......................................66\n     5.3.5. Link the \"state\" Parameter to User Agent Session ...66\n5.4. Resource Servers ..........................................66\n     5.4.1. Authorization Headers ..............................66\n     5.4.2. Authenticated Requests .............................67\n     5.4.3. Signed Requests ....................................67\n5.5. A Word on User Interaction and User-Installed Apps ........68",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6. Acknowledgements ...............................................69\n7. References .....................................................69\n   7.1. Normative References ......................................69\n   7.2. Informative References ....................................69",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document gives additional security considerations for OAuth, beyond those in the OAuth specification, based on a comprehensive threat model for the OAuth 2.0 protocol [RFC6749]. It contains the following content:",
      "ja": "この文書では、OAuth 2.0のプロトコル[RFC6749]のための包括的な脅威モデルに基づいて、OAuthの仕様のものを超えて、OAuthのた​​めの追加のセキュリティの考慮事項を示します。これは、次の内容が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Documents any assumptions and scope considered when creating the threat model.",
      "ja": "O脅威モデルを作成する際に考慮任意の仮定と範囲について説明します。"
    },
    {
      "indent": 3,
      "text": "o Describes the security features built into the OAuth protocol and how they are intended to thwart attacks.",
      "ja": "oはOAuthプロトコルとそれらがどのように攻撃を阻止することを意図しているに組み込まれたセキュリティ機能について説明します。"
    },
    {
      "indent": 3,
      "text": "o Gives a comprehensive threat model for OAuth and describes the respective countermeasures to thwart those threats.",
      "ja": "oはOAuthのた​​めの包括的な脅威モデルを提供し、それらの脅威を阻止するために、それぞれの対策について説明します。"
    },
    {
      "indent": 3,
      "text": "Threats include any intentional attacks on OAuth tokens and resources protected by OAuth tokens, as well as security risks introduced if the proper security measures are not put in place. Threats are structured along the lines of the protocol structure to help development teams implement each part of the protocol securely, for example, all threats for granting access, or all threats for a particular grant type, or all threats for protecting the resource server.",
      "ja": "脅威は、適切なセキュリティ対策を所定の位置に置かれていない場合導入された意図的なOAuthのトーク​​ンとOAuthのトーク​​ンで保護されたリソースへの攻撃だけでなく、セキュリティ上のリスクが含まれます。脅威は、開発チームが、例えば、確実にアクセスを許可するためのすべての脅威、または特定の許可タイプのすべての脅威、またはリソースサーバを保護するためのすべての脅威をプロトコルの各部分の実装を支援するためのプロトコル構造のラインに沿って構成されています。"
    },
    {
      "indent": 3,
      "text": "Note: This document cannot assess the probability or the risk associated with a particular threat because those aspects strongly depend on the particular application and deployment OAuth is used to protect. Similarly, impacts are given on a rather abstract level. But the information given here may serve as a foundation for deployment-specific threat models. Implementors may refine and detail the abstract threat model in order to account for the specific properties of their deployment and to come up with a risk analysis. As this document is based on the base OAuth 2.0 specification, it does not consider proposed extensions such as client registration or discovery, many of which are still under discussion.",
      "ja": "注：このドキュメントでは、確率や、それらの側面が強く、特定のアプリケーションに依存し、展開のOAuthを保護するために使用されているため、特定の脅威に関連するリスクを評価することはできません。同様に、影響はかなり抽象的なレベルで与えられています。しかし、ここで与えられた情報は、展開固有の脅威モデルの基盤として機能することができます。実装者は、彼らの展開の特定の特性を考慮し、リスク分析を思い付くために、抽象的脅威モデルを改良し、詳細があります。この文書は、ベースのOAuth 2.0の仕様に基づいているとして、それは議論の下にまだその多くが、このようなクライアントの登録や発見などの提案の拡張を、考慮していません。"
    },
    {
      "indent": 0,
      "text": "2. Overview",
      "section_title": true,
      "ja": "2.概要"
    },
    {
      "indent": 0,
      "text": "2.1. Scope",
      "section_title": true,
      "ja": "2.1。範囲"
    },
    {
      "indent": 3,
      "text": "This security considerations document only considers clients bound to a particular deployment as supported by [RFC6749]. Such deployments have the following characteristics:",
      "ja": "[RFC6749]でサポートされているように、このセキュリティ上の考慮事項の文書は、特定の展開にバインドされたクライアントを考慮します。このような展開では、次の特性があります。"
    },
    {
      "indent": 3,
      "text": "o Resource server URLs are static and well-known at development time; authorization server URLs can be static or discovered.",
      "ja": "OリソースサーバのURLは、静的および開発時にはよく知られています。認証サーバのURLは、静的または発見することができます。"
    },
    {
      "indent": 3,
      "text": "o Token scope values (e.g., applicable URLs and methods) are well-known at development time.",
      "ja": "Oトークンスコープ値（例えば、該当するURLおよび方法）が開発時によく知られています。"
    },
    {
      "indent": 3,
      "text": "o Client registration is out of scope of the current core specification. Therefore, this document assumes a broad variety of options, from static registration during development time to dynamic registration at runtime.",
      "ja": "Oクライアントの登録は、現在のコア仕様の範囲外です。したがって、このドキュメントは、実行時に動的登録に開発時間の間、静的登録から、オプションの幅広い多様性を前提としています。"
    },
    {
      "indent": 3,
      "text": "The following are considered out of scope:",
      "ja": "以下は適用範囲外とみなされます。"
    },
    {
      "indent": 3,
      "text": "o Communication between the authorization server and resource server.",
      "ja": "認証サーバーとリソースサーバーの間のO通信。"
    },
    {
      "indent": 3,
      "text": "o Token formats.",
      "ja": "トークン形式O。"
    },
    {
      "indent": 3,
      "text": "o Except for the resource owner password credentials grant type (see [RFC6749], Section 4.3), the mechanism used by authorization servers to authenticate the user.",
      "ja": "リソースの所有者のパスワードの認証情報を除きO、（[RFC6749]、セクション4.3を参照）、ユーザーを認証するための認証サーバが使用するメカニズムをタイプを付与します。"
    },
    {
      "indent": 3,
      "text": "o Mechanism by which a user obtained an assertion and any resulting attacks mounted as a result of the assertion being false.",
      "ja": "O機構は、それによってユーザがアサーションを取得し、任意の得られた攻撃が偽であるアサーションの結果としてマウント。"
    },
    {
      "indent": 3,
      "text": "o Clients not bound to a specific deployment: An example could be a mail client with support for contact list access via the portable contacts API (see [Portable-Contacts]). Such clients cannot be registered upfront with a particular deployment and should dynamically discover the URLs relevant for the OAuth protocol.",
      "ja": "O特定の展開にバインドされていないクライアント：例では、（[ポータブル-コンタクト]参照）ポータブル連絡API経由で連絡先リストへのアクセスをサポートするメールクライアントである可能性があります。このようなクライアントは、特定のデプロイメントでの先行登録することができないとOAuthプロトコルに関連するURLを動的に検出する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2. Attack Assumptions",
      "section_title": true,
      "ja": "2.2。攻撃仮定"
    },
    {
      "indent": 3,
      "text": "The following assumptions relate to an attacker and resources available to an attacker. It is assumed that:",
      "ja": "以下の仮定は、攻撃者が利用できる攻撃者やリソースに関連しています。これは想定されています。"
    },
    {
      "indent": 3,
      "text": "o the attacker has full access to the network between the client and authorization servers and the client and the resource server, respectively. The attacker may eavesdrop on any communications between those parties. He is not assumed to have access to communication between the authorization server and resource server.",
      "ja": "攻撃者oをそれぞれ、クライアントと認証サーバとクライアントとリソースサーバ間のネットワークへのフルアクセス権を持っています。攻撃者は、これらの当事者間の通信を傍受します。彼は、認可サーバーとリソースサーバー間の通信にアクセスすることが想定されていません。"
    },
    {
      "indent": 3,
      "text": "o an attacker has unlimited resources to mount an attack.",
      "ja": "O攻撃者は、攻撃を仕掛けるために無制限のリソースを持っています。"
    },
    {
      "indent": 3,
      "text": "o two of the three parties involved in the OAuth protocol may collude to mount an attack against the 3rd party. For example, the client and authorization server may be under control of an attacker and collude to trick a user to gain access to resources.",
      "ja": "O OAuthプロトコルに関わる三の者の二人は、サードパーティへの攻撃をマウントするために共謀があります。たとえば、クライアントと認証サーバは、攻撃者の制御下にあるとリソースにアクセスするユーザーをだますために共謀があります。"
    },
    {
      "indent": 0,
      "text": "2.3. Architectural Assumptions",
      "section_title": true,
      "ja": "2.3。建築仮定"
    },
    {
      "indent": 3,
      "text": "This section documents assumptions about the features, limitations, and design options of the different entities of an OAuth deployment along with the security-sensitive data elements managed by those entities. These assumptions are the foundation of the threat analysis.",
      "ja": "それらのエンティティによって管理される機密性の高いデータ要素と一緒にOAuthの展開の異なるエンティティの機能、制限事項、および設計オプションについてこのセクションでは、文書の仮定。これらの仮定は、脅威分析の基礎です。"
    },
    {
      "indent": 3,
      "text": "The OAuth protocol leaves deployments with a certain degree of freedom regarding how to implement and apply the standard. The core specification defines the core concepts of an authorization server and a resource server. Both servers can be implemented in the same server entity, or they may also be different entities. The latter is typically the case for multi-service providers with a single authentication and authorization system and is more typical in middleware architectures.",
      "ja": "OAuthプロトコルを実装し、標準を適用する方法に関する自由度と展開を残します。コア仕様は、認証サーバとリソースサーバのコア概念を定義します。両方のサーバーが同じサーバエンティティに実装することができ、またはそれらは、異なる構成要素であってもよいです。後者は、典型的には、単一の認証及び認可システムとマルチサービス・プロバイダのためのケースであり、ミドルウェア・アーキテクチャで、より典型的です。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Authorization Servers",
      "section_title": true,
      "ja": "2.3.1。認可サーバ"
    },
    {
      "indent": 3,
      "text": "The following data elements are stored or accessible on the authorization server:",
      "ja": "次のデータ要素は、認証サーバーに保存されているか、アクセスされています。"
    },
    {
      "indent": 3,
      "text": "o usernames and passwords",
      "ja": "ユーザ名とパスワードO"
    },
    {
      "indent": 3,
      "text": "o client ids and secrets",
      "ja": "クライアントIDと秘密O"
    },
    {
      "indent": 3,
      "text": "o client-specific refresh tokens",
      "ja": "Oクライアント固有のリフレッシュトークン"
    },
    {
      "indent": 3,
      "text": "o client-specific access tokens (in the case of handle-based design; see Section 3.1)",
      "ja": "Oクライアント固有のアクセストークン（ハンドルベース設計の場合は、3.1節を参照してください）"
    },
    {
      "indent": 3,
      "text": "o HTTPS certificate/key",
      "ja": "O HTTPS証明書/キー"
    },
    {
      "indent": 3,
      "text": "o per-authorization process (in the case of handle-based design; Section 3.1): \"redirect_uri\", \"client_id\", authorization \"code\"",
      "ja": "（ハンドルベースの設計の場合には、セクション3.1）当たり承認プロセスO：「REDIRECT_URI」、「CLIENT_ID」、権限「コード」"
    },
    {
      "indent": 0,
      "text": "2.3.2. Resource Server",
      "section_title": true,
      "ja": "2.3.2。リソースサーバ"
    },
    {
      "indent": 3,
      "text": "The following data elements are stored or accessible on the resource server:",
      "ja": "次のデータ要素は、リソースサーバに保存されているか、アクセスされています。"
    },
    {
      "indent": 3,
      "text": "o user data (out of scope)",
      "ja": "Oユーザデータ（範囲外）"
    },
    {
      "indent": 3,
      "text": "o HTTPS certificate/key",
      "ja": "O HTTPS証明書/キー"
    },
    {
      "indent": 3,
      "text": "o either authorization server credentials (handle-based design; see Section 3.1) or authorization server shared secret/public key (assertion-based design; see Section 3.1)",
      "ja": "O認証サーバの認証情報（ハンドルベースの設計; 3.1節を参照）のいずれかまたは認可サーバは、公開/秘密の共有鍵（アサーションベース設計; 3.1節を参照してください）"
    },
    {
      "indent": 3,
      "text": "o access tokens (per request)",
      "ja": "Oアクセストークン（リクエストあたり）"
    },
    {
      "indent": 3,
      "text": "It is assumed that a resource server has no knowledge of refresh tokens, user passwords, or client secrets.",
      "ja": "リソースサーバは、リフレッシュトークン、ユーザパスワード、またはクライアントの秘密の知識を持たないものとします。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Client",
      "section_title": true,
      "ja": "2.3.3。クライアント"
    },
    {
      "indent": 3,
      "text": "In OAuth, a client is an application making protected resource requests on behalf of the resource owner and with its authorization. There are different types of clients with different implementation and security characteristics, such as web, user-agent-based, and native applications. A full definition of the different client types and profiles is given in [RFC6749], Section 2.1.",
      "ja": "OAuthのでは、クライアントはリソースの所有者に代わって、その権限を持つ保護されたリソースの要求を行うアプリケーションです。こうしたウェブ、ユーザーエージェント・ベース、およびネイティブアプリケーションなど、さまざまな実装やセキュリティ特性を持つ顧客のさまざまな種類があります。さまざまなクライアントタイプおよびプロファイルの完全な定義は、[RFC6749]でセクション2.1を与えています。"
    },
    {
      "indent": 3,
      "text": "The following data elements are stored or accessible on the client:",
      "ja": "次のデータ要素は、クライアントに保存されているか、アクセスされています。"
    },
    {
      "indent": 3,
      "text": "o client id (and client secret or corresponding client credential)",
      "ja": "OクライアントID（及びクライアントの秘密や、対応するクライアントの資格情報）"
    },
    {
      "indent": 3,
      "text": "o one or more refresh tokens (persistent) and access tokens (transient) per end user or other security-context or delegation context",
      "ja": "エンドユーザーまたは他のセキュリティ・コンテキストまたは委任コンテキストごとに一つ以上のリフレッシュトークン（永続的な）とアクセストークン（トランジェント）O"
    },
    {
      "indent": 3,
      "text": "o trusted certification authority (CA) certificates (HTTPS)",
      "ja": "O、信頼できる認証局（CA）証明書（HTTPS）"
    },
    {
      "indent": 3,
      "text": "o per-authorization process: \"redirect_uri\", authorization \"code\"",
      "ja": "Oあたりの承認プロセス：「REDIRECT_URI」、承認「コード」"
    },
    {
      "indent": 0,
      "text": "3. Security Features",
      "section_title": true,
      "ja": "3.セキュリティ機能"
    },
    {
      "indent": 3,
      "text": "These are some of the security features that have been built into the OAuth 2.0 protocol to mitigate attacks and security issues.",
      "ja": "これらは攻撃やセキュリティ上の問題を軽減するためにOAuth 2.0のプロトコルに組み込まれているセキュリティ機能の一部です。"
    },
    {
      "indent": 0,
      "text": "3.1. Tokens",
      "section_title": true,
      "ja": "3.1。トークン"
    },
    {
      "indent": 3,
      "text": "OAuth makes extensive use of many kinds of tokens (access tokens, refresh tokens, authorization \"codes\"). The information content of a token can be represented in two ways, as follows:",
      "ja": "OAuthのトーク​​ン（アクセストークン、リフレッシュトークン、認証「コード」）の多くの種類を多用します。次のようにトークンの情報内容は、二つの方法で表すことができます。"
    },
    {
      "indent": 3,
      "text": "Handle (or artifact) A 'handle' is a reference to some internal data structure within the authorization server; the internal data structure contains the attributes of the token, such as user id (UID), scope, etc. Handles enable simple revocation and do not require cryptographic mechanisms to protect token content from being modified. On the other hand, handles require communication between the issuing and consuming entity (e.g., the authorization server and resource server) in order to validate the token and obtain token-bound data. This communication might have a negative impact on performance and scalability if both entities reside on different systems. Handles are therefore typically used if the issuing and consuming entity are the same. A 'handle' token is often referred to as an 'opaque' token because the resource server does not need to be able to interpret the token directly; it simply uses the token.",
      "ja": "ハンドル（またはアーティファクト）A「ハンドル」認証サーバ内のいくつかの内部データ構造への参照です。内部データ構造は、ハンドルは単純な取り消しを有効にして修飾されることから、トークンのコンテンツを保護するために暗号化機構を必要としないユーザID（UID）、範囲、等のトークンの属性を含んでいます。一方、ハンドルは、トークンを検証し、トークン結合データを取得するために発行し、消費エンティティ（例えば、認可サーバーとリソースサーバ）との間の通信を必要とします。両方のエンティティは、異なるシステム上に存在する場合は、この通信は、パフォーマンスとスケーラビリティに悪影響を与える可能性があります。発行と消費エンティティが同じであれば、ハンドルは、したがって、一般的に使用されています。リソースサーバが直接トークンを解釈できるようにする必要がないため、「ハンドル」トークンは、しばしば「不透明」トークンと呼ばれます。それは単にトークンを使用しています。"
    },
    {
      "indent": 3,
      "text": "Assertion (aka self-contained token) An assertion is a parseable token. An assertion typically has a duration, has an audience, and is digitally signed in order to ensure data integrity and origin authentication. It contains information about the user and the client. Examples of assertion formats are Security Assertion Markup Language (SAML) assertions [OASIS.saml-core-2.0-os] and Kerberos tickets [RFC4120]. Assertions can typically be directly validated and used by a resource server without interactions with the authorization server. This results in better performance and scalability in deployments where the issuing and consuming entities reside on different systems. Implementing token revocation is more difficult with assertions than with handles.",
      "ja": "アサーション（自己完結型のトークン別名）アサーションが解析可能なトークンです。アサーションは、通常、持続時間を有する聴衆を持っており、デジタルデータの整合性と発信元認証を確保するために署名されています。これは、ユーザーとクライアントに関する情報が含まれています。アサーション・フォーマットの例は、セキュリティアサーションマークアップ言語（SAML）アサーション[OASIS.samlコア-2.0-OS]およびKerberosチケット[RFC4120]です。アサーションは通常、直接検証および認証サーバとの相互作用せずに、リソースサーバで使用することができます。これは、発行と消費エンティティが異なるシステム上に存在する展開でより優れたパフォーマンスとスケーラビリティになります。トークン失効を実装することは、ハンドルよりも表明してより困難です。"
    },
    {
      "indent": 3,
      "text": "Tokens can be used in two ways to invoke requests on resource servers, as follows:",
      "ja": "次のようにトークンは、リソースサーバ上の要求を起動するために2つの方法で使用することができます。"
    },
    {
      "indent": 3,
      "text": "bearer token A 'bearer token' is a token that can be used by any client who has received the token (e.g., [RFC6750]). Because mere possession is enough to use the token, it is important that communication between endpoints be secured to ensure that only authorized endpoints may capture the token. The bearer token is convenient for client applications, as it does not require them to do anything to use them (such as a proof of identity). Bearer tokens have similar characteristics to web single-sign-on (SSO) cookies used in browsers.",
      "ja": "ベアラ「トークンベアラ」トークントークン（例えば、[RFC6750]）を受信した任意のクライアントで使用することができるトークンです。単なる所持がトークンを使用するのに十分であるので、エンドポイント間の通信のみを許可エンドポイントはトークンを取り込むことができることを確実にするために確保することが重要です。それは（そのようなアイデンティティの証明として）それらを使用するために何かをするためにそれらを必要としないので、ベアラトークンは、クライアントアプリケーションに便利です。ベアラトークンは、ブラウザで使用されるWebシングルサインオン（SSO）クッキーに似た特性を持っています。"
    },
    {
      "indent": 3,
      "text": "proof token A 'proof token' is a token that can only be used by a specific client. Each use of the token requires the client to perform some action that proves that it is the authorized user of the token. Examples of this are MAC-type access tokens, which require the client to digitally sign the resource request with a secret corresponding to the particular token sent with the request (e.g., [OAuth-HTTP-MAC]).",
      "ja": "証明は「証拠トークン」トークンのみ、特定のクライアントで使用できるトークンです。トークンを使用するたびに、それはトークンの正当なユーザであることを証明しているいくつかのアクションを実行するクライアントが必要です。この例は、デジタル要求（例えば、[OAuthの-HTTP-MAC]）で送信された特定のトークンに対応する秘密とリソース要求に署名するためにクライアントが必要MAC型アクセストークンです。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Scope",
      "section_title": true,
      "ja": "3.1.1。範囲"
    },
    {
      "indent": 3,
      "text": "A scope represents the access authorization associated with a particular token with respect to resource servers, resources, and methods on those resources. Scopes are the OAuth way to explicitly manage the power associated with an access token. A scope can be controlled by the authorization server and/or the end user in order to limit access to resources for OAuth clients that these parties deem less secure or trustworthy. Optionally, the client can request the scope to apply to the token but only for a lesser scope than would otherwise be granted, e.g., to reduce the potential impact if this token is sent over non-secure channels. A scope is typically complemented by a restriction on a token's lifetime.",
      "ja": "スコープは、リソースサーバ、リソース、およびこれらのリソース上の方法に関して特定のトークンに関連付けられたアクセス権限を表します。スコープは、明示的にアクセストークンに関連した電力を管理するためのOAuth方法です。範囲はこれらの当事者が安全性の低いまたは信頼できると考えることのOAuthクライアントのリソースへのアクセスを制限するために、認証サーバおよび/またはエンドユーザによって制御することができます。必要に応じて、クライアントは、このトークンが非セキュアチャネルを介して送信された場合に潜在的な影響を低減するために、トークンにだけそうでない場合、例えば、付与されるよりも低い範囲に適用する範囲を要求することができます。範囲は、一般的に、トークンの有効期間の制限によって補完されます。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Limited Access Token Lifetime",
      "section_title": true,
      "ja": "3.1.2。制限付きアクセストークンの有効期間"
    },
    {
      "indent": 3,
      "text": "The protocol parameter \"expires_in\" allows an authorization server (based on its policies or on behalf of the end user) to limit the lifetime of an access token and to pass this information to the client. This mechanism can be used to issue short-lived tokens to OAuth clients that the authorization server deems less secure, or where sending tokens over non-secure channels.",
      "ja": "（そのポリシーにまたはエンドユーザの代わりに基づいて）認証サーバは、アクセストークンの有効期間を制限するために、クライアントにこの情報を渡すことができます「expires_in」プロトコルパラメータ。このメカニズムは、認証サーバは安全性の低い、またはどこ非セキュアチャネル上のトークンを送ると判断するのOAuthクライアントに短命のトークンを発行するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.2. Access Token",
      "section_title": true,
      "ja": "3.2。アクセストークン"
    },
    {
      "indent": 3,
      "text": "An access token is used by a client to access a resource. Access tokens typically have short life spans (minutes or hours) that cover typical session lifetimes. An access token may be refreshed through the use of a refresh token. The short lifespan of an access token, in combination with the usage of refresh tokens, enables the possibility of passive revocation of access authorization on the expiry of the current access token.",
      "ja": "アクセストークンは、リソースにアクセスするためにクライアントによって使用されます。アクセストークンは、一般的に、典型的なセッションの寿命をカバーする短い寿命（分または時間）を持っています。アクセストークンは、リフレッシュトークンを使用してリフレッシュすることがあります。アクセストークンの短い寿命は、リフレッシュトークンの使用と組み合わせて、現在のアクセストークンの有効期限にアクセス許可の受動失効の可能性を可能にします。"
    },
    {
      "indent": 0,
      "text": "3.3. Refresh Token",
      "section_title": true,
      "ja": "3.3。リフレッシュトークン"
    },
    {
      "indent": 3,
      "text": "A refresh token represents a long-lasting authorization of a certain client to access resources on behalf of a resource owner. Such tokens are exchanged between the client and authorization server only. Clients use this kind of token to obtain (\"refresh\") new access tokens used for resource server invocations.",
      "ja": "リフレッシュトークンは、リソースの所有者に代わってアクセスリソースへの特定のクライアントの長期的な承認を表しています。このようなトークンはのみ、クライアントと認証サーバの間で交換されます。クライアントは、リソースサーバーの呼び出しに使用する（「リフレッシュ」）は、新しいアクセストークンを取得するためにトークンのこの種を使用しています。"
    },
    {
      "indent": 3,
      "text": "A refresh token, coupled with a short access token lifetime, can be used to grant longer access to resources without involving end-user authorization. This offers an advantage where resource servers and authorization servers are not the same entity, e.g., in a distributed environment, as the refresh token is always exchanged at the authorization server. The authorization server can revoke the refresh token at any time, causing the granted access to be revoked once the current access token expires. Because of this, a short access token lifetime is important if timely revocation is a high priority.",
      "ja": "短いアクセストークン寿命と相まってリフレッシュトークンは、エンドユーザーの認証を伴うことなく、リソースへの長いのアクセスを許可するために使用することができます。リフレッシュトークンは必ず認証サーバで交換され、これは、分散環境では、例えば、リソースサーバと認証サーバが同一のエンティティではない利点を提供しています。認証サーバは、現在のアクセストークンの有効期限が切れた後に付与されたアクセスを失効させる、任意の時点でリフレッシュトークンを取り消すことができます。タイムリーに失効が高い優先度であればこのため、短いアクセストークン寿命が重要です。"
    },
    {
      "indent": 3,
      "text": "The refresh token is also a secret bound to the client identifier and client instance that originally requested the authorization; the refresh token also represents the original resource owner grant. This is ensured by the authorization process as follows:",
      "ja": "リフレッシュトークンも、元々の許可を要求したクライアント識別子とクライアントのインスタンスにバインドされた秘密です。リフレッシュトークンはまた、元のリソースの所有者の助成金を表しています。これは、次のように承認プロセスによって保証されています。"
    },
    {
      "indent": 3,
      "text": "1. The resource owner and user agent safely deliver the authorization \"code\" to the client instance in the first place.",
      "ja": "1.リソースの所有者とユーザエージェントは安全に最初の場所でのクライアントインスタンスに認証「コード」をお届けします。"
    },
    {
      "indent": 3,
      "text": "2. The client uses it immediately in secure transport-level communications to the authorization server and then securely stores the long-lived refresh token.",
      "ja": "2.クライアントは、認証サーバへのセキュアなトランスポートレベルの通信で、すぐにそれを使用して、しっかりと長寿命のリフレッシュトークンを格納します。"
    },
    {
      "indent": 3,
      "text": "3. The client always uses the refresh token in secure transport-level communications to the authorization server to get an access token (and optionally roll over the refresh token).",
      "ja": "3.クライアントは常に（リフレッシュトークンを超えると、必要に応じてロール）アクセストークンを取得するために認証サーバへのセキュアなトランスポートレベルの通信におけるリフレッシュトークンを使用しています。"
    },
    {
      "indent": 3,
      "text": "So, as long as the confidentiality of the particular token can be ensured by the client, a refresh token can also be used as an alternative means to authenticate the client instance itself.",
      "ja": "だから、特定のトークンの機密性がクライアントによって確保できる限り、リフレッシュトークンは、代替クライアントのインスタンス自体を認証するための手段として使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.4. Authorization \"code\"",
      "section_title": true,
      "ja": "3.4。認可の「コード」"
    },
    {
      "indent": 3,
      "text": "An authorization \"code\" represents the intermediate result of a successful end-user authorization process and is used by the client to obtain access and refresh tokens. Authorization \"codes\" are sent to the client's redirect URI instead of tokens for two purposes:",
      "ja": "承認「のコードでは、」成功したエンドユーザーの承認プロセスの中間結果を表し、アクセスとリフレッシュトークンを取得するために、クライアントによって使用されます。許可は、「コード」は、2つの目的のために代わりにトークンのクライアントのリダイレクトURIに送信されます。"
    },
    {
      "indent": 3,
      "text": "1. Browser-based flows expose protocol parameters to potential attackers via URI query parameters (HTTP referrer), the browser cache, or log file entries, and could be replayed. In order to reduce this threat, short-lived authorization \"codes\" are passed instead of tokens and exchanged for tokens over a more secure direct connection between the client and the authorization server.",
      "ja": "1.ブラウザベースのフローは、URIクエリパラメータ（HTTPリファラ）を介して潜在的な攻撃者にブラウザのキャッシュをプロトコルパラメータを公開する、またはファイルのエントリをログに記録し、再生することができます。この脅威を軽減するために、短命の許可「コードが」渡された代わりのトークンと、クライアントと認証サーバとの間のよりセキュアな直接接続を介してトークンに交換されています。"
    },
    {
      "indent": 3,
      "text": "2. It is much simpler to authenticate clients during the direct request between the client and the authorization server than in the context of the indirect authorization request. The latter would require digital signatures.",
      "ja": "2.間接的な認証要求のコンテキストでよりクライアントと認証サーバとの間に直接的な要求中にクライアントを認証するためにはるかに簡単です。後者は、デジタル署名を必要とするであろう。"
    },
    {
      "indent": 0,
      "text": "3.5. Redirect URI",
      "section_title": true,
      "ja": "3.5。 URIをリダイレクト"
    },
    {
      "indent": 3,
      "text": "A redirect URI helps to detect malicious clients and prevents phishing attacks from clients attempting to trick the user into believing the phisher is the client. The value of the actual redirect URI used in the authorization request has to be presented and is verified when an authorization \"code\" is exchanged for tokens. This helps to prevent attacks where the authorization \"code\" is revealed through redirectors and counterfeit web application clients. The authorization server should require public clients and confidential clients using the implicit grant type to pre-register their redirect URIs and validate against the registered redirect URI in the authorization request.",
      "ja": "リダイレクトURIは、悪意のあるクライアントを検出するのに役立ちますとフィッシャーは、クライアントである信じるように、ユーザーをだまししようとしているクライアントからのフィッシング攻撃を防ぐことができます。実際のリダイレクトURIの値は、認証要求に使用される許可「コード」はトークンと交換されたときに提示されると確認されています。これは、許可「コードが」リダイレクタと偽造のWebアプリケーションクライアントを通じて明らかにされた攻撃を防ぐのに役立ちます。認証サーバは、そのリダイレクトURIを事前登録し、認可要求でURIをリダイレクト登録に対して検証するために、暗黙の許可タイプを使用してパブリッククライアントと機密クライアントを要求すべきです。"
    },
    {
      "indent": 0,
      "text": "3.6. \"state\" Parameter",
      "section_title": true,
      "ja": "3.6。 「状態」のパラメータ"
    },
    {
      "indent": 3,
      "text": "The \"state\" parameter is used to link requests and callbacks to prevent cross-site request forgery attacks (see Section 4.4.1.8) where an attacker authorizes access to his own resources and then tricks a user into following a redirect with the attacker's token. This parameter should bind to the authenticated state in a user agent and, as per the core OAuth spec, the user agent must be capable of keeping it in a location accessible only by the client and user agent, i.e., protected by same-origin policy.",
      "ja": "攻撃者のトークンを使用して、リダイレクトを以下に「状態」パラメータは、クロスサイトリクエストフォージェリ攻撃を防ぐためにリクエストとコールバックをリンクするために使用される（セクション4.4.1.8を参照）、攻撃者は自分のリソースへのアクセスを許可ところ、その後、トリックユーザー。同一生成元ポリシーによって保護され、このパラメータには、ユーザー・エージェントに認証された状態に結合しなければならないと、コアOAuthの仕様に従って、ユーザエージェントは、クライアントとユーザーエージェントがアクセスできる、すなわち場所でそれを維持することが可能でなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.7. Client Identifier",
      "section_title": true,
      "ja": "3.7。クライアント識別子"
    },
    {
      "indent": 3,
      "text": "Authentication protocols have typically not taken into account the identity of the software component acting on behalf of the end user. OAuth does this in order to increase the security level in delegated authorization scenarios and because the client will be able to act without the user being present.",
      "ja": "認証プロトコルは、通常のアカウントにエンドユーザーに代わって動作するソフトウェアコンポーネントのIDを取っていません。 OAuthが委任承認シナリオにおけるセキュリティレベルを高めるために、クライアントは、ユーザが存在せずに行動することができるようになりますので、これを行います。"
    },
    {
      "indent": 3,
      "text": "OAuth uses the client identifier to collate associated requests to the same originator, such as",
      "ja": "OAuthのは、次のような、同じ発信元に関連する要求を照合するためにクライアント識別子を使用しています"
    },
    {
      "indent": 3,
      "text": "o a particular end-user authorization process and the corresponding request on the token's endpoint to exchange the authorization \"code\" for tokens, or",
      "ja": "O特定のエンドユーザ認証処理とトークンの権限「コード」を交換するトークンのエンドポイントに対応する要求、または"
    },
    {
      "indent": 3,
      "text": "o the initial authorization and issuance of a token by an end user to a particular client, and subsequent requests by this client to obtain tokens without user consent (automatic processing of repeated authorizations)",
      "ja": "ユーザーの同意なしトークン（繰り返し権限の自動処理）を得るために、このクライアントによる最初の承認および特定のクライアントへのエンドユーザによるトークンの発行、および後続の要求O"
    },
    {
      "indent": 3,
      "text": "This identifier may also be used by the authorization server to display relevant registration information to a user when requesting consent for a scope requested by a particular client. The client identifier may be used to limit the number of requests for a particular client or to charge the client per request. It may furthermore be useful to differentiate access by different clients, e.g., in server log files.",
      "ja": "この識別子は、特定のクライアントから要求されたスコープの同意を要求するときに、ユーザーに関連する登録情報を表示するには、認証サーバで使用することができます。クライアント識別子は、特定のクライアントの要求の数を制限するか、要求ごとにクライアントを充電するために使用されてもよいです。さらに、サーバーのログファイルには、例えば、異なるクライアントによってアクセスを区別することが有用であり得ます。"
    },
    {
      "indent": 3,
      "text": "OAuth defines two client types, confidential and public, based on their ability to authenticate with the authorization server (i.e., ability to maintain the confidentiality of their client credentials). Confidential clients are capable of maintaining the confidentiality of client credentials (i.e., a client secret associated with the client identifier) or capable of secure client authentication using other means, such as a client assertion (e.g., SAML) or key cryptography. The latter is considered more secure.",
      "ja": "OAuthのは、認証サーバ（そのクライアントの資格情報の機密性を維持するために、すなわち、能力）で認証する能力に基づいて、機密情報や公共、2つのクライアントタイプを定義します。機密クライアント（すなわち、クライアントのクライアント識別子に関連付けられた秘密）またはセキュアクライアント認証することができるが、そのようなクライアントのアサーション（例えば、SAML）又は鍵暗号のような他の手段を使用して、クライアントの資格情報の機密性を維持することができます。後者はより安全と考えられています。"
    },
    {
      "indent": 3,
      "text": "The authorization server should determine whether the client is capable of keeping its secret confidential or using secure authentication. Alternatively, the end user can verify the identity of the client, e.g., by only installing trusted applications. The redirect URI can be used to prevent the delivery of credentials to a counterfeit client after obtaining end-user authorization in some cases but can't be used to verify the client identifier.",
      "ja": "認証サーバは、クライアントがその秘密の機密を保つか、安全な認証を使用することができるか否かを決定する必要があります。代替的に、エンドユーザは、信頼されたアプリケーションをインストールすることによって、例えば、クライアントの身元を確認することができます。リダイレクトURIは、いくつかのケースでは、エンドユーザーの許可を得た後偽造クライアントに資格情報の配信を防止するために使用することができるが、クライアント識別子を検証するために使用することができません。"
    },
    {
      "indent": 3,
      "text": "Clients can be categorized as follows based on the client type, profile (e.g., native vs. web application; see [RFC6749], Section 9), and deployment model:",
      "ja": "クライアントは、クライアントのタイプ、プロファイルに基づいて、以下のように分類することができる;および展開モデル（例えば、ウェブアプリケーション対ネイティブ[RFC6749]、セクション9を参照）。"
    },
    {
      "indent": 3,
      "text": "Deployment-independent \"client_id\" with pre-registered \"redirect_uri\" and without \"client_secret\" Such an identifier is used by multiple installations of the same software package. The identifier of such a client can only be validated with the help of the end-user. This is a viable option for native applications in order to identify the client for the purpose of displaying meta information about the client to the user and to differentiate clients in log files. Revocation of the rights associated with such a client identifier will affect ALL deployments of the respective software.",
      "ja": "予め登録された「REDIRECT_URI」の配備に依存しない「CLIENT_ID」および「client_secret」することなく、そのような識別子は、同じソフトウェアパッケージの複数のインストールで使用されます。そのようなクライアントの識別子は、エンドユーザーの助けを借りて検証することができます。これは、ユーザに、クライアントに関するメタ情報を表示する目的のために、クライアントを識別するために、ログファイル内のクライアントを区別するために、ネイティブアプリケーションのための実行可能な選択肢です。そのようなクライアント識別子に関連付けられた権利の失効は、それぞれのソフトウェアのすべての展開に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "Deployment-independent \"client_id\" with pre-registered \"redirect_uri\" and with \"client_secret\" This is an option for native applications only, since web applications would require different redirect URIs. This category is not advisable because the client secret cannot be protected appropriately (see Section 4.1.1). Due to its security weaknesses, such client identities have the same trust level as deployment-independent clients without secrets. Revocation will affect ALL deployments.",
      "ja": "あらかじめ登録された「REDIRECT_URI」とし、Webアプリケーションが異なるリダイレクトのURIを必要とするので、これは、唯一のネイティブアプリケーションのためのオプションである「client_secret」と展開に依存しない「CLIENT_ID」。クライアントの秘密は（4.1.1項を参照）を適切に保護することができないため、このカテゴリにはお勧めしません。そのため、セキュリティ上の弱点には、そのようなクライアントIDは、秘密のない展開に依存しないクライアントと同じ信頼レベルを持っています。失効は、すべての展開に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "Deployment-specific \"client_id\" with pre-registered \"redirect_uri\" and with \"client_secret\" The client registration process ensures the validation of the client's properties, such as redirect URI, web site URL, web site name, and contacts. Such a client identifier can be utilized for all relevant use cases cited above. This level can be achieved for web applications in combination with a manual or user-bound registration process. Achieving this level for native applications is much more difficult. Either the installation of the application is conducted by an administrator, who validates the client's authenticity, or the process from validating the application to the installation of the application on the device and the creation of the client credentials is controlled end-to-end by a single entity (e.g., application market provider). Revocation will affect a single deployment only.",
      "ja": "あらかじめ登録された「REDIRECT_URI」とし、「client_secret」と展開固有の「CLIENT_ID」クライアントの登録プロセスは、そのようなURI、ウェブサイトのURL、ウェブサイト名、連絡先をリダイレクトするように、クライアントのプロパティの検証を保証します。そのようなクライアント識別子は、上記引用されたすべての関連するユースケースに利用することができます。このレベルは、手動またはユーザー結合登録プロセスと組み合わせてWebアプリケーションのために達成することができます。ネイティブアプリケーションのためのこのレベルを達成することははるかに困難です。どちらのアプリケーションのインストールをすることで、エンド・ツー・エンドの制御されているクライアントの信憑性を検証し、管理者、またはデバイス上のアプリケーションとクライアントの資格情報の作成のインストールにアプリケーションを有効からのプロセスによって行われます。単一のエンティティ（例えば、アプリケーション・マーケット・プロバイダ）。失効は、単一の展開に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "Deployment-specific \"client_id\" with \"client_secret\" without validated properties Such a client can be recognized by the authorization server in transactions with subsequent requests (e.g., authorization and token issuance, refresh token issuance, and access token refreshment). The authorization server cannot assure any property of the client to end users. Automatic processing of re-authorizations could be allowed as well. Such client credentials can be generated automatically without any validation of client properties, which makes it another option, especially for native applications. Revocation will affect a single deployment only.",
      "ja": "展開固有のこのようなクライアントは、後続の要求との取引における認証サーバで認識することができ、検証プロパティのない「client_secret」と「CLIENT_ID」（例えば、承認とトークンの発行は、トークンの発行、およびアクセストークンのリフレッシュをリフレッシュします）。認証サーバは、エンドユーザーへのクライアントの任意のプロパティを保証することはできません。再権限の自動処理も同様に許可することができます。このようなクライアントの資格情報は、特にネイティブアプリケーションのために、それ別のオプションになり、クライアントのプロパティのいずれかの検証、なしで自動的に生成することができます。失効は、単一の展開に影響を与えます。"
    },
    {
      "indent": 0,
      "text": "4. Threat Model",
      "section_title": true,
      "ja": "4.脅威モデル"
    },
    {
      "indent": 3,
      "text": "This section gives a comprehensive threat model of OAuth 2.0. Threats are grouped first by attacks directed against an OAuth component, which are the client, authorization server, and resource server. Subsequently, they are grouped by flow, e.g., obtain token or access protected resources. Every countermeasure description refers to a detailed description in Section 5.",
      "ja": "このセクションでは、OAuth 2.0の包括的な脅威モデルを提供します。脅威は、クライアントのOAuthあるコンポーネントに対して向けられた攻撃は、認証サーバ、及びリソースサーバによって最初にグループ化されています。その後、彼らは流れによってグループ化され、例えば、トークンまたはアクセス保護されたリソースを取得します。すべての対策については、第5節では詳細な説明を参照します。"
    },
    {
      "indent": 0,
      "text": "4.1. Clients",
      "section_title": true,
      "ja": "4.1。クライアント"
    },
    {
      "indent": 3,
      "text": "This section describes possible threats directed to OAuth clients.",
      "ja": "このセクションでは、OAuthのクライアントに向け脅威の可能性を説明しています。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Threat: Obtaining Client Secrets",
      "section_title": true,
      "ja": "4.1.1。脅威：取得クライアントの秘密"
    },
    {
      "indent": 3,
      "text": "The attacker could try to get access to the secret of a particular client in order to:",
      "ja": "攻撃者は、するために、特定のクライアントの秘密へのアクセスを取得しようとすることができます："
    },
    {
      "indent": 3,
      "text": "o replay its refresh tokens and authorization \"codes\", or",
      "ja": "Oそのリフレッシュトークンと認証「コード」を再生、または"
    },
    {
      "indent": 3,
      "text": "o obtain tokens on behalf of the attacked client with the privileges of that \"client_id\" acting as an instance of the client.",
      "ja": "Oクライアントのインスタンスとして働くこと「のclient_id」の権限を持つ攻撃クライアントの代わりにトークンを取得。"
    },
    {
      "indent": 3,
      "text": "The resulting impact would be the following:",
      "ja": "得られた影響は、次のようになります。"
    },
    {
      "indent": 3,
      "text": "o Client authentication of access to the authorization server can be bypassed.",
      "ja": "認証サーバへのアクセスのoクライアント認証をバイパスすることができます。"
    },
    {
      "indent": 3,
      "text": "o Stolen refresh tokens or authorization \"codes\" can be replayed.",
      "ja": "O盗まれたトークンまたは許可「コード」を更新し再生することができます。"
    },
    {
      "indent": 3,
      "text": "Depending on the client category, the following attacks could be utilized to obtain the client secret.",
      "ja": "クライアントのカテゴリに応じて、次の攻撃は、クライアントの秘密を得るために利用することができます。"
    },
    {
      "indent": 3,
      "text": "Attack: Obtain Secret From Source Code or Binary:",
      "ja": "攻撃：ソースコードやバイナリから秘密を取得します。"
    },
    {
      "indent": 3,
      "text": "This applies for all client types. For open source projects, secrets can be extracted directly from source code in their public repositories. Secrets can be extracted from application binaries just as easily when the published source is not available to the attacker. Even if an application takes significant measures to obfuscate secrets in their application distribution, one should consider that the secret can still be reverse-engineered by anyone with access to a complete functioning application bundle or binary.",
      "ja": "これは、すべてのクライアントタイプに適用されます。オープンソースプロジェクトのために、秘密は彼らの公共のリポジトリ内のソースコードから直接抽出することができます。秘密は、同じように簡単に出版されたソースが攻撃者に利用できないときにアプリケーションバイナリから抽出することができます。アプリケーションは、そのアプリケーションの配布で秘密を難読化する重要な措置を講じたとしても、人は秘密がまだ完全に機能するアプリケーションバンドルまたはバイナリへのアクセス権を持つ誰もがリバースエンジニアリングすることができることを考慮すべきです。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Don't issue secrets to public clients or clients with inappropriate security policy (Section 5.2.3.1).",
      "ja": "O不適切なセキュリティポリシー（セクション5.2.3.1）と公共のクライアントまたはクライアントに秘密を発行しないでください。"
    },
    {
      "indent": 3,
      "text": "o Require user consent for public clients (Section 5.2.3.2).",
      "ja": "O公共のクライアント（セクション5.2.3.2）のためにユーザーの同意を必要とします。"
    },
    {
      "indent": 3,
      "text": "o Use deployment-specific client secrets (Section 5.2.3.4).",
      "ja": "O展開固有のクライアント秘密（セクション5.2.3.4）を使用します。"
    },
    {
      "indent": 3,
      "text": "o Revoke client secrets (Section 5.2.3.6).",
      "ja": "Oクライアントの秘密（セクション5.2.3.6）を取り消します。"
    },
    {
      "indent": 3,
      "text": "Attack: Obtain a Deployment-Specific Secret:",
      "ja": "攻撃：配置固有の秘密を取得します。"
    },
    {
      "indent": 3,
      "text": "An attacker may try to obtain the secret from a client installation, either from a web site (web server) or a particular device (native application).",
      "ja": "攻撃者は、いずれかのWebサイト（Webサーバ）、または特定のデバイス（ネイティブアプリケーション）から、クライアントインストールから秘密を取得しようとするかもしれません。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Web server: Apply standard web server protection measures (for config files and databases) (see Section 5.3.2).",
      "ja": "O Webサーバ：（5.3.2項を参照）（設定ファイルやデータベースのための）標準的なWebサーバーの保護対策を適用します。"
    },
    {
      "indent": 3,
      "text": "o Native applications: Store secrets in secure local storage (Section 5.3.3).",
      "ja": "Oネイティブアプリケーション：ストアの秘密安全なローカルストレージに（セクション5.3.3）。"
    },
    {
      "indent": 3,
      "text": "o Revoke client secrets (Section 5.2.3.6).",
      "ja": "Oクライアントの秘密（セクション5.2.3.6）を取り消します。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Threat: Obtaining Refresh Tokens",
      "section_title": true,
      "ja": "4.1.2。脅威：更新トークンを取得"
    },
    {
      "indent": 3,
      "text": "Depending on the client type, there are different ways that refresh tokens may be revealed to an attacker. The following sub-sections give a more detailed description of the different attacks with respect to different client types and further specialized countermeasures. Before detailing those threats, here are some generally applicable countermeasures:",
      "ja": "クライアントの種類に応じて、攻撃者に明らかにすることができるトークンをリフレッシュするさまざまな方法があります。以下のサブセクションでは、異なるクライアントタイプとさらに特殊対策に対して異なる攻撃のより詳細な説明を与えます。これらの脅威を詳述する前に、ここでいくつかの一般的に適用可能な対策は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The authorization server should validate the client id associated with the particular refresh token with every refresh request (Section 5.2.2.2).",
      "ja": "O認証サーバは、すべてのリフレッシュ要求（5.2.2.2項）と、特定のリフレッシュトークンに関連付けられているクライアントIDを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Limit token scope (Section 5.1.5.1).",
      "ja": "Oトークンスコープ（セクション5.1.5.1）を制限します。"
    },
    {
      "indent": 3,
      "text": "o Revoke refresh tokens (Section 5.2.2.4).",
      "ja": "Oリフレッシュトークン（セクション5.2.2.4）を取り消します。"
    },
    {
      "indent": 3,
      "text": "o Revoke client secrets (Section 5.2.3.6).",
      "ja": "Oクライアントの秘密（セクション5.2.3.6）を取り消します。"
    },
    {
      "indent": 3,
      "text": "o Refresh tokens can automatically be replaced in order to detect unauthorized token usage by another party (see \"Refresh Token Rotation\", Section 5.2.2.3).",
      "ja": "Oリフレッシュトークンは自動的に他の当事者による不正トークンの使用を検出するために置き換えることができます（「リフレッシュトークンローテーション」、5.2.2.3項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "Attack: Obtain Refresh Token from Web Application:",
      "ja": "攻撃：Webアプリケーションからのリフレッシュトークンを取得します。"
    },
    {
      "indent": 3,
      "text": "An attacker may obtain the refresh tokens issued to a web application by way of overcoming the web server's security controls.",
      "ja": "攻撃者は、Webサーバーのセキュリティコントロールを克服する方法により、Webアプリケーションに発行されたリフレッシュトークンを得ることができます。"
    },
    {
      "indent": 3,
      "text": "Impact: Since a web application manages the user accounts of a certain site, such an attack would result in an exposure of all refresh tokens on that site to the attacker.",
      "ja": "影響：Webアプリケーションが特定のサイトのユーザーアカウントを管理しているので、このような攻撃は、攻撃者にそのサイト上のすべてのリフレッシュトークンの暴露につながります。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Standard web server protection measures (Section 5.3.2).",
      "ja": "O標準Webサーバの保護措置（5.3.2項）。"
    },
    {
      "indent": 3,
      "text": "o Use strong client authentication (e.g., client_assertion/ client_token) so the attacker cannot obtain the client secret required to exchange the tokens (Section 5.2.3.7).",
      "ja": "O強力なクライアント認証（例えば、client_assertion / client_token）を使用しますので、攻撃者は、トークン（セクション5.2.3.7）を交換するために必要なクライアントシークレットを取得することはできません。"
    },
    {
      "indent": 3,
      "text": "Attack: Obtain Refresh Token from Native Clients:",
      "ja": "攻撃：ネイティブクライアントからのリフレッシュトークンを取得します。"
    },
    {
      "indent": 3,
      "text": "On native clients, leakage of a refresh token typically affects a single user only.",
      "ja": "ネイティブクライアントでは、リフレッシュトークンの漏洩は、一般的に単一のユーザーのみに影響します。"
    },
    {
      "indent": 3,
      "text": "Read from local file system: The attacker could try to get file system access on the device and read the refresh tokens. The attacker could utilize a malicious application for that purpose.",
      "ja": "ローカルファイルシステムから読む：攻撃者は、デバイス上のファイルシステムへのアクセスを取得し、リフレッシュトークンを読み取るために試みることができます。攻撃者は、その目的のための悪意のあるアプリケーションを利用することができます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Store secrets in secure storage (Section 5.3.3).",
      "ja": "安全な保管中のOストアの秘密（セクション5.3.3）。"
    },
    {
      "indent": 3,
      "text": "o Utilize device lock to prevent unauthorized device access (Section 5.3.4).",
      "ja": "O不正なデバイスアクセス（5.3.4）を防止するために、デバイスのロックを利用しています。"
    },
    {
      "indent": 3,
      "text": "Attack: Steal Device:",
      "ja": "攻撃：デバイスを盗みます："
    },
    {
      "indent": 3,
      "text": "The host device (e.g., mobile phone) may be stolen. In that case, the attacker gets access to all applications under the identity of the legitimate user.",
      "ja": "ホスト装置（例えば、携帯電話）が盗まれてもよいです。その場合、攻撃者は、正当なユーザーのIDの下にあるすべてのアプリケーションへのアクセスを取得します。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Utilize device lock to prevent unauthorized device access (Section 5.3.4).",
      "ja": "O不正なデバイスアクセス（5.3.4）を防止するために、デバイスのロックを利用しています。"
    },
    {
      "indent": 3,
      "text": "o Where a user knows the device has been stolen, they can revoke the affected tokens (Section 5.2.2.4).",
      "ja": "ユーザーは、デバイスが盗まれている知っている場合は、O、彼らが影響を受けたトークン（セクション5.2.2.4）を取り消すことができます。"
    },
    {
      "indent": 3,
      "text": "Attack: Clone Device:",
      "ja": "攻撃：クローンデバイス："
    },
    {
      "indent": 3,
      "text": "All device data and applications are copied to another device. Applications are used as-is on the target device.",
      "ja": "すべてのデバイスデータとアプリケーションを別のデバイスにコピーされます。ターゲット・デバイス上にあるとして、アプリケーションが使用されています。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Utilize device lock to prevent unauthorized device access (Section 5.3.4).",
      "ja": "O不正なデバイスアクセス（5.3.4）を防止するために、デバイスのロックを利用しています。"
    },
    {
      "indent": 3,
      "text": "o Combine refresh token request with device identification (Section 5.2.2.5).",
      "ja": "Oデバイス識別（セクション5.2.2.5）とリフレッシュトークン要求を組み合わせます。"
    },
    {
      "indent": 3,
      "text": "o Refresh token rotation (Section 5.2.2.3).",
      "ja": "Oトークン回転（5.2.2.3項）を更新します。"
    },
    {
      "indent": 3,
      "text": "o Where a user knows the device has been cloned, they can use refresh token revocation (Section 5.2.2.4).",
      "ja": "ユーザーはデバイスがクローニングされている知っている場合は、O、彼らは、リフレッシュトークン取消し（セクション5.2.2.4）を使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Threat: Obtaining Access Tokens",
      "section_title": true,
      "ja": "4.1.3。脅威：アクセストークンの取得"
    },
    {
      "indent": 3,
      "text": "Depending on the client type, there are different ways that access tokens may be revealed to an attacker. Access tokens could be stolen from the device if the application stores them in a storage device that is accessible to other applications.",
      "ja": "クライアントの種類に応じて、攻撃者に明らかにすることができるトークンにアクセスするさまざまな方法があります。アプリケーションが他のアプリケーションからアクセス可能なストレージデバイスに格納する場合は、アクセストークンには、デバイスから盗まれる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Impact: Where the token is a bearer token and no additional mechanism is used to identify the client, the attacker can access all resources associated with the token and its scope.",
      "ja": "影響：トークンがベアラトークンで、追加のメカニズムがクライアントを識別するために使用されていない、攻撃者は、トークンとその範囲に関連付けられたすべてのリソースにアクセスすることができます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Keep access tokens in transient memory and limit grants (Section 5.1.6).",
      "ja": "O過渡メモリと制限の助成金（セクション5.1.6）にアクセストークンを保管してください。"
    },
    {
      "indent": 3,
      "text": "o Limit token scope (Section 5.1.5.1).",
      "ja": "Oトークンスコープ（セクション5.1.5.1）を制限します。"
    },
    {
      "indent": 3,
      "text": "o Keep access tokens in private memory or apply same protection means as for refresh tokens (Section 5.2.2).",
      "ja": "Oプライベートメモリにアクセストークンを保持するか、リフレッシュトークン（5.2.2項）と同じ保護手段を適用します。"
    },
    {
      "indent": 3,
      "text": "o Keep access token lifetime short (Section 5.1.5.3).",
      "ja": "Oアクセストークン寿命の短い（セクション5.1.5.3）を保管してください。"
    },
    {
      "indent": 0,
      "text": "4.1.4. Threat: End-User Credentials Phished Using Compromised or Embedded Browser",
      "ja": "4.1.4。脅威：侵入または内蔵ブラウザを使用してフィッシングエンドユーザーの資格情報"
    },
    {
      "indent": 3,
      "text": "A malicious application could attempt to phish end-user passwords by misusing an embedded browser in the end-user authorization process, or by presenting its own user interface instead of allowing a trusted system browser to render the authorization user interface. By doing so, the usual visual trust mechanisms may be bypassed (e.g., Transport Layer Security (TLS) confirmation, web site mechanisms). By using an embedded or internal client application user interface, the client application has access to additional information to which it should not have access (e.g., UID/password).",
      "ja": "悪意のあるアプリケーションがエンドユーザーの承認プロセスに組み込まれたブラウザを悪用することにより、または、独自のユーザーインターフェースを提示する代わりに、許可ユーザー・インターフェースをレンダリングするための信頼できるシステムブラウザを可能にすることにより、フィッシング、エンドユーザのパスワードを試みる可能性があります。そうすることによって、通常の視覚的な信頼メカニズムをバイパスすることができる（例えば、トランスポート層セキュリティ（TLS）の確認、ウェブサイトのメカニズム）。埋め込みまたは内部クライアント・アプリケーションのユーザインターフェイスを使用して、クライアント・アプリケーションは、それがアクセス（例えば、UID /パスワード）を有していなければならないために、追加情報へのアクセスを有します。"
    },
    {
      "indent": 3,
      "text": "Impact: If the client application or the communication is compromised, the user would not be aware of this, and all information in the authorization exchange, such as username and password, could be captured.",
      "ja": "影響：ユーザー名やパスワードなどの認証交換中に、クライアントアプリケーションまたは通信が侵害された場合、ユーザーはこのことを認識ではないでしょう、そしてすべての情報は、キャプチャすることができます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o The OAuth flow is designed so that client applications never need to know user passwords. Client applications should avoid directly asking users for their credentials. In addition, end users could be educated about phishing attacks and best practices, such as only accessing trusted clients, as OAuth does not provide any protection against malicious applications and the end user is solely responsible for the trustworthiness of any native application installed.",
      "ja": "クライアントアプリケーションは、ユーザのパスワードを知っている必要がありませんように、OAuthのフローoを設計されています。クライアントアプリケーションは、資格情報のユーザーを求めて直接避けるべきです。 OAuthのは、悪意のあるアプリケーションに対する任意の保護を提供していないと、エンドユーザーがインストールされているすべてのネイティブアプリケーションの信頼性について責任を負うものとして、また、エンドユーザは、そのような信頼性のあるクライアントにアクセスすると、攻撃やベストプラクティスをフィッシングについて教育することができます。"
    },
    {
      "indent": 3,
      "text": "o Client applications could be validated prior to publication in an application market for users to access. That validation is out of scope for OAuth but could include validating that the client application handles user authentication in an appropriate way.",
      "ja": "oクライアント・アプリケーションは、アクセスするユーザーのためのアプリケーション市場で出版前に検証することができました。その検証はOAuthのた​​めの範囲の外にあるが、クライアントアプリケーションが適切な方法でユーザー認証を処理していることを検証含めることができます。"
    },
    {
      "indent": 3,
      "text": "o Client developers should not write client applications that collect authentication information directly from users and should instead delegate this task to a trusted system component, e.g., the system browser.",
      "ja": "oクライアント開発者は、ユーザーからの直接の認証情報を収集し、代わりに信頼され、システムの構成要素、例えば、システムのブラウザにこのタスクを委任する必要があり、クライアント・アプリケーションを書くべきではありません。"
    },
    {
      "indent": 0,
      "text": "4.1.5. Threat: Open Redirectors on Client",
      "section_title": true,
      "ja": "4.1.5。脅威：クライアント上のオープンリダイレクタ"
    },
    {
      "indent": 3,
      "text": "An open redirector is an endpoint using a parameter to automatically redirect a user agent to the location specified by the parameter value without any validation. If the authorization server allows the client to register only part of the redirect URI, an attacker can use an open redirector operated by the client to construct a redirect URI that will pass the authorization server validation but will send the authorization \"code\" or access token to an endpoint under the control of the attacker.",
      "ja": "オープンリダイレクタは自動的に検証することなく、パラメータ値によって指定された場所にユーザエージェントをリダイレクトするためにパラメータを使用してエンドポイントです。認証サーバは、クライアントがリダイレクトURIの一部のみを登録することができた場合、攻撃者は、認証サーバーの検証に合格するリダイレクトURIを構築するために、クライアントが運営するオープンリダイレクタを使用することができますが、許可「コード」またはアクセストークンを送信します攻撃者の制御下にあるエンドポイントに。"
    },
    {
      "indent": 3,
      "text": "Impact: An attacker could gain access to authorization \"codes\" or access tokens.",
      "ja": "影響：攻撃者が承認「コード」またはアクセストークンへのアクセスを得ることができました。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Require clients to register full redirect URI (Section 5.2.3.5).",
      "ja": "OレジスタフルURI（セクション5.2.3.5）をリダイレクトするようにクライアントを必要としています。"
    },
    {
      "indent": 0,
      "text": "4.2. Authorization Endpoint",
      "section_title": true,
      "ja": "4.2。認可のエンドポイント"
    },
    {
      "indent": 0,
      "text": "4.2.1. Threat: Password Phishing by Counterfeit Authorization Server",
      "section_title": true,
      "ja": "4.2.1。脅威：偽造認証サーバによるパスワードフィッシング"
    },
    {
      "indent": 3,
      "text": "OAuth makes no attempt to verify the authenticity of the authorization server. A hostile party could take advantage of this by intercepting the client's requests and returning misleading or otherwise incorrect responses. This could be achieved using DNS or Address Resolution Protocol (ARP) spoofing. Wide deployment of OAuth and similar protocols may cause users to become inured to the practice of being redirected to web sites where they are asked to enter their passwords. If users are not careful to verify the authenticity of these web sites before entering their credentials, it will be possible for attackers to exploit this practice to steal users' passwords.",
      "ja": "OAuthのは、認証サーバの信頼性を検証を試みません。敵対的な政党は、クライアントの要求を傍受し、誤解を招くか、そうでない場合は、誤った応答を返すことによって、この利点を取ることができます。これは、DNSまたはアドレス解決プロトコル（ARP）スプーフィングを使用して達成することができました。 OAuthのと同様のプロトコルの幅広い展開は、ユーザーが自分のパスワードを入力するように要求されたWebサイトにリダイレクトされているの練習にinuredになる可能性があります。ユーザーが自分の資格情報を入力する前に、これらのウェブサイトの信頼性を確認するように注意していない場合、攻撃者がユーザーのパスワードを盗むためにこの練習を活用することが可能になります。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Authorization servers should consider such attacks when developing services based on OAuth and should require the use of transport-layer security for any requests where the authenticity of the authorization server or of request responses is an issue (see Section 5.1.2).",
      "ja": "O認証サーバは、OAuthのに基づいてサービスを開発するときに、このような攻撃を検討すべきであると（5.1.2項を参照）認証サーバのやリクエストレスポンスの信憑性が問題である任意の要求のためのトランスポート・レイヤ・セキュリティを使用する必要がなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Authorization servers should attempt to educate users about the risks posed by phishing attacks and should provide mechanisms that make it easy for users to confirm the authenticity of their sites.",
      "ja": "Oの認証サーバは、フィッシング攻撃によるリスクについて、ユーザーを教育しようとしなければならないし、それが簡単に、ユーザーが自分のサイトの信頼性を確認できるようにするためのメカニズムを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Threat: User Unintentionally Grants Too Much Access Scope",
      "section_title": true,
      "ja": "4.2.2。脅威：ユーザーが意図せずにあまりにも多くのアクセススコープを付与します"
    },
    {
      "indent": 3,
      "text": "When obtaining end-user authorization, the end user may not understand the scope of the access being granted and to whom, or they may end up providing a client with access to resources that should not be permitted.",
      "ja": "エンドユーザーの認証を取得した場合、エンドユーザーが許可されるアクセスの範囲を理解しない可能性があり、誰に、またはそれらを許可すべきではありませんリソースへのアクセスをクライアントに提供してしまうことがあります。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Explain the scope (resources and the permissions) the user is about to grant in an understandable way (Section 5.2.4.2).",
      "ja": "Oユーザーが理解しやすい方法（セクション5.2.4.2）に付与しようとしている（資源と権限）の範囲を説明します。"
    },
    {
      "indent": 3,
      "text": "o Narrow the scope, based on the client. When obtaining end-user authorization and where the client requests scope, the authorization server may want to consider whether to honor that scope based on the client identifier. That decision is between the client and authorization server and is outside the scope of this spec. The authorization server may also want to consider what scope to grant based on the client type, e.g., providing lower scope to public clients (Section 5.1.5.1).",
      "ja": "Oクライアントに基づいて、スコープの範囲を絞ります。エンドユーザーの認証、どこで、クライアントはスコープを要求を取得する場合、認証サーバは、クライアント識別子に基づいて、その範囲を尊重するかどうかを検討することをお勧めします。その決定は、クライアントと認証サーバの間であり、この仕様の範囲外です。認証サーバは、公開クライアント（セクション5.1.5.1）に下の範囲を提供する、例えば、クライアントのタイプに基づいて付与するかを範囲を検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Threat: Malicious Client Obtains Existing Authorization by Fraud",
      "section_title": true,
      "ja": "4.2.3。脅威：悪意のあるクライアントは詐欺することにより、既存の認証を取得します"
    },
    {
      "indent": 3,
      "text": "Authorization servers may wish to automatically process authorization requests from clients that have been previously authorized by the user. When the user is redirected to the authorization server's end-user authorization endpoint to grant access, the authorization server detects that the user has already granted access to that particular client. Instead of prompting the user for approval, the authorization server automatically redirects the user back to the client.",
      "ja": "認証サーバは、自動的にユーザが以前に認可されているクライアントからの認証要求を処理することを望むかもしれません。ユーザーがアクセスを許可する認証サーバのエンドユーザー認可エンドポイントにリダイレクトされた場合、認証サーバは、ユーザがすでにその特定のクライアントへのアクセスを許可したことを検出します。承認のためにユーザに促すのではなく、認証サーバは自動的にクライアントにユーザーをリダイレクトします。"
    },
    {
      "indent": 3,
      "text": "A malicious client may exploit that feature and try to obtain such an authorization \"code\" instead of the legitimate client.",
      "ja": "悪意のあるクライアントがその機能を利用して、このような認証「コード」の代わりに、合法的なクライアントを取得しようとするかもしれません。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Authorization servers should not automatically process repeat authorizations to public clients unless the client is validated using a pre-registered redirect URI (Section 5.2.3.5).",
      "ja": "Oの認証サーバは、クライアントは、事前に登録されたURIにリダイレクト（セクション5.2.3.5）を使用してパブリッククライアントに自動的にプロセスの繰り返し権限を検証されるべきではない場合を除きます。"
    },
    {
      "indent": 3,
      "text": "o Authorization servers can mitigate the risks associated with automatic processing by limiting the scope of access tokens obtained through automated approvals (Section 5.1.5.1).",
      "ja": "O認可サーバは、自動承認（セクション5.1.5.1）を介して取得したアクセストークンの範囲を制限することによって自動処理に関連するリスクを軽減することができます。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Threat: Open Redirector",
      "section_title": true,
      "ja": "4.2.4。脅威：オープンリダイレクタ"
    },
    {
      "indent": 3,
      "text": "An attacker could use the end-user authorization endpoint and the redirect URI parameter to abuse the authorization server as an open redirector. An open redirector is an endpoint using a parameter to automatically redirect a user agent to the location specified by the parameter value without any validation.",
      "ja": "攻撃者は、オープンリダイレクタとして認証サーバを悪用するために、エンドユーザー認可エンドポイントとリダイレクトURIパラメータを使用することができます。オープンリダイレクタは自動的に検証することなく、パラメータ値によって指定された場所にユーザエージェントをリダイレクトするためにパラメータを使用してエンドポイントです。"
    },
    {
      "indent": 3,
      "text": "Impact: An attacker could utilize a user's trust in an authorization server to launch a phishing attack.",
      "ja": "影響：攻撃者はフィッシング攻撃を起動するために、認証サーバーでユーザーの信頼を利用することができます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Require clients to register any full redirect URIs (Section 5.2.3.5).",
      "ja": "O任意のフルリダイレクトのURI（セクション5.2.3.5）を登録するためのクライアントを必要としています。"
    },
    {
      "indent": 3,
      "text": "o Don't redirect to a redirect URI if the client identifier or redirect URI can't be verified (Section 5.2.3.5).",
      "ja": "O（セクション5.2.3.5）を検証することができないクライアント識別子場合、リダイレクトURIにリダイレクトまたはURIをリダイレクトしないでください。"
    },
    {
      "indent": 0,
      "text": "4.3. Token Endpoint",
      "section_title": true,
      "ja": "4.3。トークンエンドポイント"
    },
    {
      "indent": 0,
      "text": "4.3.1. Threat: Eavesdropping Access Tokens",
      "section_title": true,
      "ja": "4.3.1。脅威：盗聴アクセストークン"
    },
    {
      "indent": 3,
      "text": "Attackers may attempt to eavesdrop access tokens in transit from the authorization server to the client.",
      "ja": "攻撃者は、クライアントに認証サーバからの輸送中にアクセストークンを盗聴しようとすることができます。"
    },
    {
      "indent": 3,
      "text": "Impact: The attacker is able to access all resources with the permissions covered by the scope of the particular access token.",
      "ja": "影響：攻撃者は、特定のアクセストークンの範囲に含まれるアクセス権を持つすべてのリソースにアクセスすることが可能です。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o As per the core OAuth spec, the authorization servers must ensure that these transmissions are protected using transport-layer mechanisms such as TLS (see Section 5.1.1).",
      "ja": "OコアのOAuth仕様に従って、認可サーバは、これらの送信は、例えばTLS（セクション5.1.1を参照）のようなトランスポート層のメカニズムを使用して保護されていることを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If end-to-end confidentiality cannot be guaranteed, reducing scope (see Section 5.1.5.1) and expiry time (Section 5.1.5.3) for access tokens can be used to reduce the damage in case of leaks.",
      "ja": "エンドツーエンドの機密性を保証できない場合は、O、アクセストークンの有効範囲（セクション5.1.5.1を参照）、有効期限（セクション5.1.5.3）を低減漏洩した場合の被害を軽減するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Threat: Obtaining Access Tokens from Authorization Server Database",
      "ja": "4.3.2。脅威：認証サーバのデータベースからのアクセストークンの取得"
    },
    {
      "indent": 3,
      "text": "This threat is applicable if the authorization server stores access tokens as handles in a database. An attacker may obtain access tokens from the authorization server's database by gaining access to the database or launching a SQL injection attack.",
      "ja": "認証サーバーストアは、データベース内のハンドルとしてのトークンにアクセスする場合は、この脅威は適用されます。攻撃者は、データベースにアクセスするか、SQLインジェクション攻撃を起動して認証サーバのデータベースからのアクセストークンを取得することができます。"
    },
    {
      "indent": 3,
      "text": "Impact: Disclosure of all access tokens.",
      "ja": "影響：すべてのアクセストークンの開示。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Enforce system security measures (Section 5.1.4.1.1).",
      "ja": "Oシステムのセキュリティ対策（セクション5.1.4.1.1）を適用します。"
    },
    {
      "indent": 3,
      "text": "o Store access token hashes only (Section 5.1.4.1.3).",
      "ja": "Oストアアクセストークンは（セクション5.1.4.1.3）をハッシュします。"
    },
    {
      "indent": 3,
      "text": "o Enforce standard SQL injection countermeasures (Section 5.1.4.1.2).",
      "ja": "O標準のSQLインジェクション対策（セクション5.1.4.1.2）を適用します。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Threat: Disclosure of Client Credentials during Transmission",
      "section_title": true,
      "ja": "4.3.3。脅威：送信中にクライアントの資格情報の開示"
    },
    {
      "indent": 3,
      "text": "An attacker could attempt to eavesdrop the transmission of client credentials between the client and server during the client authentication process or during OAuth token requests.",
      "ja": "攻撃者は、クライアントの認証プロセス中またはOAuthのトーク​​ンの要求時に、クライアントとサーバの間でクライアントの資格情報の送信を盗聴しようとする可能性があり。"
    },
    {
      "indent": 3,
      "text": "Impact: Revelation of a client credential enabling phishing or impersonation of a client service.",
      "ja": "影響：クライアントサービスのフィッシングやなりすましを有効にするクライアントの資格情報の黙示録。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o The transmission of client credentials must be protected using transport-layer mechanisms such as TLS (see Section 5.1.1).",
      "ja": "クライアントの資格情報の送信は、例えばTLSのようにトランスポート層のメカニズムを使用して保護されなければならないO（セクション5.1.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o Use alternative authentication means that do not require the sending of plaintext credentials over the wire (e.g., Hash-based Message Authentication Code).",
      "ja": "O線（例えば、ハッシュベースメッセージ認証コード）を介して、平文の資格情報の送信を必要としない代替的な認証手段を使用します。"
    },
    {
      "indent": 0,
      "text": "4.3.4. Threat: Obtaining Client Secret from Authorization Server Database",
      "ja": "4.3.4。脅威：認証サーバー・データベースから取得クライアントシークレット"
    },
    {
      "indent": 3,
      "text": "An attacker may obtain valid \"client_id\"/secret combinations from the authorization server's database by gaining access to the database or launching a SQL injection attack.",
      "ja": "攻撃者は、データベースにアクセスするか、SQLインジェクション攻撃を起動して認証サーバのデータベースから有効な「CLIENT_ID」/秘密の組み合わせを得ることができます。"
    },
    {
      "indent": 3,
      "text": "Impact: Disclosure of all \"client_id\"/secret combinations. This allows the attacker to act on behalf of legitimate clients.",
      "ja": "影響：すべての「CLIENT_ID」の公開/秘密の組み合わせ。これにより、攻撃者は正当なクライアントに代わって行動することができます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Enforce system security measures (Section 5.1.4.1.1).",
      "ja": "Oシステムのセキュリティ対策（セクション5.1.4.1.1）を適用します。"
    },
    {
      "indent": 3,
      "text": "o Enforce standard SQL injection countermeasures (Section 5.1.4.1.2).",
      "ja": "O標準のSQLインジェクション対策（セクション5.1.4.1.2）を適用します。"
    },
    {
      "indent": 3,
      "text": "o Ensure proper handling of credentials as per \"Enforce Credential Storage Protection Best Practices\" (Section 5.1.4.1).",
      "ja": "O「強制資格ストレージの保護のベストプラクティス」（セクション5.1.4.1）あたりとしての資格情報の適切な取り扱いを確認してください。"
    },
    {
      "indent": 0,
      "text": "4.3.5. Threat: Obtaining Client Secret by Online Guessing",
      "section_title": true,
      "ja": "4.3.5。脅威：オンライン推測してクライアントシークレットの取得"
    },
    {
      "indent": 3,
      "text": "An attacker may try to guess valid \"client_id\"/secret pairs.",
      "ja": "攻撃者が有効「のclient_id」/秘密のペアを推測しようとするかもしれません。"
    },
    {
      "indent": 3,
      "text": "Impact: Disclosure of a single \"client_id\"/secret pair.",
      "ja": "影響：シングル「CLIENT_ID」/秘密のペアの開示。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Use high entropy for secrets (Section 5.1.4.2.2).",
      "ja": "O秘密（セクション5.1.4.2.2）用の高エントロピーを使用してください。"
    },
    {
      "indent": 3,
      "text": "o Lock accounts (Section 5.1.4.2.3).",
      "ja": "Oロック（セクション5.1.4.2.3）を占めています。"
    },
    {
      "indent": 3,
      "text": "o Use strong client authentication (Section 5.2.3.7).",
      "ja": "O強力なクライアント認証（セクション5.2.3.7）を使用します。"
    },
    {
      "indent": 0,
      "text": "4.4. Obtaining Authorization",
      "section_title": true,
      "ja": "4.4。認証を取得"
    },
    {
      "indent": 3,
      "text": "This section covers threats that are specific to certain flows utilized to obtain access tokens. Each flow is characterized by response types and/or grant types on the end-user authorization and token endpoint, respectively.",
      "ja": "このセクションでは、アクセストークンを取得するために利用特定のフローに固有の脅威をカバーしています。各フローは、それぞれ、応答の種類によって特徴づけおよび/またはエンドユーザの許可およびトークンエンドポイントのタイプを付与されています。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Authorization \"code\"",
      "section_title": true,
      "ja": "4.4.1。認可の「コード」"
    },
    {
      "indent": 0,
      "text": "4.4.1.1. Threat: Eavesdropping or Leaking Authorization \"codes\"",
      "section_title": true,
      "ja": "4.4.1.1。脅威：盗聴や漏洩認可の「コード」"
    },
    {
      "indent": 3,
      "text": "An attacker could try to eavesdrop transmission of the authorization \"code\" between the authorization server and client. Furthermore, authorization \"codes\" are passed via the browser, which may unintentionally leak those codes to untrusted web sites and attackers in different ways:",
      "ja": "攻撃者は、認証サーバーとクライアント間の認証「コード」の送信を盗聴しようとすることができます。さらに、認証「コードは」意図せずに、さまざまな方法で信頼できないWebサイトや攻撃者にこれらのコードがリークする可能性があり、ブラウザを介して渡されます。"
    },
    {
      "indent": 3,
      "text": "o Referrer headers: Browsers frequently pass a \"referer\" header when a web page embeds content, or when a user travels from one web page to another web page. These referrer headers may be sent even when the origin site does not trust the destination site. The referrer header is commonly logged for traffic analysis purposes.",
      "ja": "リファラヘッダO：Webページがコンテンツを埋め込む場合ブラウザはしばしば「リファラー」ヘッダを渡す、またはユーザが別のWebページに1つのウェブページから移動するとき。これらのリファラヘッダは、オリジンサイトは先のサイトを信頼していない場合であっても送信されることがあります。リファラヘッダは、一般的に、トラフィック分析のために記録されます。"
    },
    {
      "indent": 3,
      "text": "o Request logs: Web server request logs commonly include query parameters on requests.",
      "ja": "O要求のログ：Webサーバーの要求ログは、一般的に要求にクエリパラメータが含まれています。"
    },
    {
      "indent": 3,
      "text": "o Open redirectors: Web sites sometimes need to send users to another destination via a redirector. Open redirectors pose a particular risk to web-based delegation protocols because the redirector can leak verification codes to untrusted destination sites.",
      "ja": "Oオープンリダイレクタ：ウェブサイトは時々リダイレクタを経由して別の宛先にユーザーを送信する必要があります。リダイレクタが信頼できない送信先サイトへの検証コードをリークすることができますので、オープンリダイレクタは、Webベースの委任プロトコルに特定のリスクをもたらします。"
    },
    {
      "indent": 3,
      "text": "o Browser history: Web browsers commonly record visited URLs in the browser history. Another user of the same web browser may be able to view URLs that were visited by previous users.",
      "ja": "Oブラウザ履歴：Webブラウザは、一般的にブラウザの履歴に訪問したURLを記録します。同じWebブラウザの別のユーザーは、前のユーザーが訪問したURLを表示することができます。"
    },
    {
      "indent": 3,
      "text": "Note: A description of similar attacks on the SAML protocol can be found at [OASIS.sstc-saml-bindings-1.1], Section 4.1.1.9.1; [Sec-Analysis]; and [OASIS.sstc-sec-analysis-response-01].",
      "ja": "注：SAMLプロトコルに同様の攻撃の説明は[OASIS.sstc-SAMLバインディング-1.1]で見つけることができ、セクション4.1.1.9.1。 [秒]  - 解析]。そして[OASIS.sstc-SEC-分析応答-01]。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o As per the core OAuth spec, the authorization server as well as the client must ensure that these transmissions are protected using transport-layer mechanisms such as TLS (see Section 5.1.1).",
      "ja": "OコアのOAuth仕様に従って、認可サーバ、並びにクライアントはこれらの送信は、例えばTLS（セクション5.1.1を参照）のようなトランスポート層のメカニズムを使用して保護されていることを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The authorization server will require the client to authenticate wherever possible, so the binding of the authorization \"code\" to a certain client can be validated in a reliable way (see Section 5.2.4.4).",
      "ja": "O認証サーバは、可能な限り、特定のクライアントに認証「コード」の結合は、信頼性の高い方法（セクション5.2.4.4を参照）で確認することができるので、認証するためにクライアントが必要になります。"
    },
    {
      "indent": 3,
      "text": "o Use short expiry time for authorization \"codes\" (Section 5.1.5.3).",
      "ja": "O認証「コード」（セクション5.1.5.3）のために、短い有効期限の時間を使用してください。"
    },
    {
      "indent": 3,
      "text": "o The authorization server should enforce a one-time usage restriction (see Section 5.1.5.4).",
      "ja": "認証サーバは、1回の使用制限を強制すべきであるO（セクション5.1.5.4を参照）。"
    },
    {
      "indent": 3,
      "text": "o If an authorization server observes multiple attempts to redeem an authorization \"code\", the authorization server may want to revoke all tokens granted based on the authorization \"code\" (see Section 5.2.1.1).",
      "ja": "認証サーバが認証「コード」を償還する複数の試みを観察する場合は、O、認証サーバは、認証「コード」（セクション5.2.1.1を参照）に基づいて付与されたすべてのトークンを取り消す場合があります。"
    },
    {
      "indent": 3,
      "text": "o In the absence of these countermeasures, reducing scope (Section 5.1.5.1) and expiry time (Section 5.1.5.3) for access tokens can be used to reduce the damage in case of leaks.",
      "ja": "アクセストークンのためにこれらの対策が存在しない場合には、O、スコープ（セクション5.1.5.1）と満了時間を短縮（セクション5.1.5.3）は、漏れの場合の損傷を低減するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "o The client server may reload the target page of the redirect URI in order to automatically clean up the browser cache.",
      "ja": "Oクライアントサーバーは、自動的にブラウザのキャッシュをクリーンアップするために、リダイレクトURIのターゲットページをリロードすることがあります。"
    },
    {
      "indent": 0,
      "text": "4.4.1.2. Threat: Obtaining Authorization \"codes\" from Authorization Server Database",
      "ja": "4.4.1.2。脅威：認証サーバー・データベースからの取得の許可「コード」"
    },
    {
      "indent": 3,
      "text": "This threat is applicable if the authorization server stores authorization \"codes\" as handles in a database. An attacker may obtain authorization \"codes\" from the authorization server's database by gaining access to the database or launching a SQL injection attack.",
      "ja": "この脅威は、データベース内のハンドルなどの認証サーバに格納承認「コード」場合は適用されます。攻撃者は、データベースにアクセスするか、SQLインジェクション攻撃を起動して認証サーバのデータベースからの許可「コード」を得ることができます。"
    },
    {
      "indent": 3,
      "text": "Impact: Disclosure of all authorization \"codes\", most likely along with the respective \"redirect_uri\" and \"client_id\" values.",
      "ja": "影響：それぞれの「REDIRECT_URI」と「client_idの」値と共に、最も可能性の高いすべての許可「コード」の開示、。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Best practices for credential storage protection should be employed (Section 5.1.4.1).",
      "ja": "O資格ストレージ保護のためのベストプラクティス（セクション5.1.4.1）を採用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Enforce system security measures (Section 5.1.4.1.1).",
      "ja": "Oシステムのセキュリティ対策（セクション5.1.4.1.1）を適用します。"
    },
    {
      "indent": 3,
      "text": "o Store access token hashes only (Section 5.1.4.1.3).",
      "ja": "Oストアアクセストークンは（セクション5.1.4.1.3）をハッシュします。"
    },
    {
      "indent": 3,
      "text": "o Enforce standard SQL injection countermeasures (Section 5.1.4.1.2).",
      "ja": "O標準のSQLインジェクション対策（セクション5.1.4.1.2）を適用します。"
    },
    {
      "indent": 0,
      "text": "4.4.1.3. Threat: Online Guessing of Authorization \"codes\"",
      "section_title": true,
      "ja": "4.4.1.3。脅威：認証「コード」のオンライン推測"
    },
    {
      "indent": 3,
      "text": "An attacker may try to guess valid authorization \"code\" values and send the guessed code value using the grant type \"code\" in order to obtain a valid access token.",
      "ja": "攻撃者は、有効なアクセストークンを取得するために、「コード」有効な認証「コード」の値を推測し、助成金型を使用して推測コード値を送信しようとするかもしれません。"
    },
    {
      "indent": 3,
      "text": "Impact: Disclosure of a single access token and probably also an associated refresh token.",
      "ja": "影響：単一のアクセストークンの開示とおそらく関連したリフレッシュトークン。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Handle-based tokens must use high entropy (Section 5.1.4.2.2).",
      "ja": "Oハンドルベースのトークンは、高エントロピー（セクション5.1.4.2.2）を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Assertion-based tokens should be signed (Section 5.1.5.9).",
      "ja": "Oアサーションベースのトークン（セクション5.1.5.9）に署名しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Authenticate the client; this adds another value that the attacker has to guess (Section 5.2.3.4).",
      "ja": "Oクライアントを認証します。これは、攻撃者が推測している別の値（セクション5.2.3.4）を追加します。"
    },
    {
      "indent": 3,
      "text": "o Bind the authorization \"code\" to the redirect URI; this adds another value that the attacker has to guess (Section 5.2.4.5).",
      "ja": "OリダイレクトURIに承認「コード」をバインド。これは、攻撃者が推測している別の値（セクション5.2.4.5）を追加します。"
    },
    {
      "indent": 3,
      "text": "o Use short expiry time for tokens (Section 5.1.5.3).",
      "ja": "Oトークン（セクション5.1.5.3）のための短い有効期限の時間を使用してください。"
    },
    {
      "indent": 0,
      "text": "4.4.1.4. Threat: Malicious Client Obtains Authorization",
      "section_title": true,
      "ja": "4.4.1.4。脅威：悪意のあるクライアントが認証を取得"
    },
    {
      "indent": 3,
      "text": "A malicious client could pretend to be a valid client and obtain an access authorization in this way. The malicious client could even utilize screen-scraping techniques in order to simulate a user's consent in the authorization flow.",
      "ja": "悪意のあるクライアントが有効なクライアントのふりをし、このようにアクセス許可を得ることができました。悪質なクライアントでも承認フローの中で、ユーザーの同意をシミュレートするために、スクリーン・スクレイピング技術を利用することができます。"
    },
    {
      "indent": 3,
      "text": "Assumption: It is not the task of the authorization server to protect the end-user's device from malicious software. This is the responsibility of the platform running on the particular device, probably in cooperation with other components of the respective ecosystem (e.g., an application management infrastructure). The sole responsibility of the authorization server is to control access to the end-user's resources maintained in resource servers and to prevent unauthorized access to them via the OAuth protocol. Based on this assumption, the following countermeasures are available to cope with the threat.",
      "ja": "仮定：悪意のあるソフトウェアから、エンドユーザのデバイスを保護するために、認証サーバの作業ではありません。これはおそらく、それぞれの生態系（例えば、アプリケーション管理インフラストラクチャ）の他の構成要素と協働して、特定のデバイス上で実行されているプラ​​ットフォームの責任です。認証サーバの責任は、リソースサーバで維持エンドユーザーのリソースへのアクセスを制御し、OAuthプロトコルを経由して、それらへの不正アクセスを防ぐためです。この仮定に基づいて、次のような対策は、脅威に対処することが可能です。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o The authorization server should authenticate the client, if possible (see Section 5.2.3.4). Note: The authentication takes place after the end user has authorized the access.",
      "ja": "（セクション5.2.3.4を参照）可能であれば、O、認可サーバーは、クライアントを認証する必要があります。注意：エンドユーザーがアクセスを許可した後に認証が行われます。"
    },
    {
      "indent": 3,
      "text": "o The authorization server should validate the client's redirect URI against the pre-registered redirect URI, if one exists (see Section 5.2.3.5). Note: An invalid redirect URI indicates an invalid client, whereas a valid redirect URI does not necessarily indicate a valid client. The level of confidence depends on the client type. For web applications, the level of confidence is high, since the redirect URI refers to the globally unique network endpoint of this application, whose fully qualified domain name (FQDN) is also validated using HTTPS server authentication by the user agent. In contrast, for native clients, the redirect URI typically refers to device local resources, e.g., a custom scheme. So, a malicious client on a particular device can use the valid redirect URI the legitimate client uses on all other devices.",
      "ja": "O認証サーバは1つが存在する場合（セクション5.2.3.5を参照）、クライアントのリダイレクトあらかじめ登録されたURIに対してURIをリダイレクト検証する必要があります。注：有効なリダイレクトURIは必ずしも有効なクライアントを示すものではありません一方、無効なリダイレクトURIは、不正なクライアントを示します。信頼性のレベルは、クライアントの種類によって異なります。 URIは完全修飾ドメイン名（FQDN）もユーザエージェントによってHTTPSサーバ認証を使用して検証され、このアプリケーションのグローバルに一意のネットワークエンドポイントを指しリダイレクトするため、Webアプリケーションのために、信頼のレベルは、高いです。対照的に、ネイティブ・クライアントに対して、リダイレクトURIは、典型的には、例えば、デバイスのローカルリソースにカスタム方式を指します。だから、特定のデバイス上の悪意のあるクライアントが正当なクライアントは、他のすべてのデバイス上で使用する有効なリダイレクトURIを使用することができます。"
    },
    {
      "indent": 3,
      "text": "o After authenticating the end user, the authorization server should ask him/her for consent. In this context, the authorization server should explain to the end user the purpose, scope, and duration of the authorization the client asked for. Moreover, the authorization server should show the user any identity information it has for that client. It is up to the user to validate the binding of this data to the particular application (e.g., Name) and to approve the authorization request (see Section 5.2.4.3).",
      "ja": "Oエンド・ユーザーを認証した後、認証サーバは、同意を/彼女が彼に尋ねる必要があります。この文脈では、認証サーバは、エンドユーザーに目的、適用範囲、およびクライアントはを求め、許可の期間を説明する必要があります。また、認証サーバは、ユーザーにそれがそのクライアントのために持っている任意のID情報を表示する必要があります。これは、特定のアプリケーション（例えば、名前）に、このデータの結合を検証し、承認要求（セクション5.2.4.3を参照）を承認するユーザの責任です。"
    },
    {
      "indent": 3,
      "text": "o The authorization server should not perform automatic re-authorizations for clients it is unable to reliably authenticate or validate (see Section 5.2.4.1).",
      "ja": "認証サーバは、確実に認証または検証することができないクライアントに対して自動再認証を行うべきではありませんO（セクション5.2.4.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o If the authorization server automatically authenticates the end user, it may nevertheless require some user input in order to prevent screen scraping. Examples are CAPTCHAs (Completely Automated Public Turing tests to tell Computers and Humans Apart) or other multi-factor authentication techniques such as random questions, token code generators, etc.",
      "ja": "認証サーバが自動的にエンドユーザーを認証する場合は、O、それにもかかわらず、スクリーンスクレイピングを防ぐために、いくつかのユーザー入力を必要とするかもしれません。例としては、CAPTCHAの（完全に自動化された公開チューリングはコンピュータを伝えるためにテストし、別に人間）かなどランダム質問、トークンコードジェネレータ、などの他の多要素認証技術であります"
    },
    {
      "indent": 3,
      "text": "o The authorization server may also limit the scope of tokens it issues to clients it cannot reliably authenticate (see Section 5.1.5.1).",
      "ja": "O認証サーバはまた、それが確実に認証できないクライアントに発行したトークンの範囲を制限すること（セクション5.1.5.1を参照）。"
    },
    {
      "indent": 0,
      "text": "4.4.1.5. Threat: Authorization \"code\" Phishing",
      "section_title": true,
      "ja": "4.4.1.5。脅威：認可の「コード」フィッシング"
    },
    {
      "indent": 3,
      "text": "A hostile party could impersonate the client site and get access to the authorization \"code\". This could be achieved using DNS or ARP spoofing. This applies to clients, which are web applications; thus, the redirect URI is not local to the host where the user's browser is running.",
      "ja": "敵対的な政党は、クライアントのサイトを偽装し、承認「コード」へのアクセスを得ることができます。これは、DNSやARPスプーフィングを使用して達成することができました。これは、Webアプリケーションでクライアントに適用されます。このように、リダイレクトURIは、ユーザーのブラウザが動作しているホストにローカルではありません。"
    },
    {
      "indent": 3,
      "text": "Impact: This affects web applications and may lead to a disclosure of authorization \"codes\" and, potentially, the corresponding access and refresh tokens.",
      "ja": "影響：これは、Webアプリケーションに影響を与え、認証「コード」と、潜在的に、対応するアクセスとリフレッシュトークンの開示につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "It is strongly recommended that one of the following countermeasures be utilized in order to prevent this attack:",
      "ja": "強く、次の対策の一つは、この攻撃を防ぐために利用されることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o The redirect URI of the client should point to an HTTPS-protected endpoint, and the browser should be utilized to authenticate this redirect URI using server authentication (see Section 5.1.2).",
      "ja": "リダイレクトoをクライアントのURIはHTTPSで保護されたエンドポイントを指している必要があり、ブラウザは、これはサーバ認証（セクション5.1.2を参照）を使用してURIをリダイレクト認証するために利用されるべきです。"
    },
    {
      "indent": 3,
      "text": "o The authorization server should require that the client be authenticated, i.e., confidential client, so the binding of the authorization \"code\" to a certain client can be validated in a reliable way (see Section 5.2.4.4).",
      "ja": "O認証サーバは、クライアントが特定のクライアントに認証「コード」の結合は、信頼性の高い方法で検証することができるので、すなわち、機密クライアント、（セクション5.2.4.4を参照）、認証されることを要求すべきです。"
    },
    {
      "indent": 0,
      "text": "4.4.1.6. Threat: User Session Impersonation",
      "section_title": true,
      "ja": "4.4.1.6。脅威：ユーザーセッションの偽装"
    },
    {
      "indent": 3,
      "text": "A hostile party could impersonate the client site and impersonate the user's session on this client. This could be achieved using DNS or ARP spoofing. This applies to clients, which are web applications; thus, the redirect URI is not local to the host where the user's browser is running.",
      "ja": "敵対的な政党は、クライアントのサイトを偽装し、このクライアント上のユーザのセッションを偽装できます。これは、DNSやARPスプーフィングを使用して達成することができました。これは、Webアプリケーションでクライアントに適用されます。このように、リダイレクトURIは、ユーザーのブラウザが動作しているホストにローカルではありません。"
    },
    {
      "indent": 3,
      "text": "Impact: An attacker who intercepts the authorization \"code\" as it is sent by the browser to the callback endpoint can gain access to protected resources by submitting the authorization \"code\" to the client. The client will exchange the authorization \"code\" for an access token and use the access token to access protected resources for the benefit of the attacker, delivering protected resources to the attacker, or modifying protected resources as directed by the attacker. If OAuth is used by the client to delegate authentication to a social site (e.g., as in the implementation of a \"Login\" button on a third-party social network site), the attacker can use the intercepted authorization \"code\" to log into the client as the user.",
      "ja": "影響：それはコールバックエンドポイントにブラウザから送信されるよう承認「コード」を傍受し、攻撃者がクライアントに認証「コード」を提出することによって保護されたリソースへのアクセスを得ることができます。クライアントがアクセストークンの承認「コード」を交換し、攻撃者に保護されたリソースを提供する、または攻撃者の指示に従って、保護されたリソースを変更し、攻撃者の利益のために保護されたリソースにアクセスするためのアクセストークンを使用します。 OAuthのは（サードパーティのソーシャルネットワークサイト上の「ログイン」ボタンの実装のように、例えば）社会的なサイトへの認証を委任するために、クライアントによって使用されている場合、攻撃者が傍受承認「コード」にログインするを使用することができますユーザーとしてクライアント。"
    },
    {
      "indent": 3,
      "text": "Note: Authenticating the client during authorization \"code\" exchange will not help to detect such an attack, as it is the legitimate client that obtains the tokens.",
      "ja": "注意：それはトークンを取得し、正当なクライアントであるとして認証時にクライアントを認証する「コード」の交換は、このような攻撃を検出するための助けにはなりません。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o In order to prevent an attacker from impersonating the end-user's session, the redirect URI of the client should point to an HTTPS protected endpoint, and the browser should be utilized to authenticate this redirect URI using server authentication (see Section 5.1.2).",
      "ja": "Oエンドユーザのセッションになりすます攻撃を防ぐために、HTTPS保護されたエンドポイントを指している必要があり、クライアントのURIをリダイレクトして、ブラウザが、これは、サーバー認証を使用してURIをリダイレクト認証するために利用されなければならない（5.1.2項を参照してください） 。"
    },
    {
      "indent": 0,
      "text": "4.4.1.7. Threat: Authorization \"code\" Leakage through Counterfeit Client",
      "ja": "4.4.1.7。脅威：偽造クライアントによる認可の「コード」漏れ"
    },
    {
      "indent": 3,
      "text": "The attacker leverages the authorization \"code\" grant type in an attempt to get another user (victim) to log in, authorize access to his/her resources, and subsequently obtain the authorization \"code\" and inject it into a client application using the attacker's account. The goal is to associate an access authorization for resources of the victim with the user account of the attacker on a client site.",
      "ja": "攻撃者は、ログイン彼/彼女のリソースへのアクセスを許可し、その後認証「コード」を取得し、攻撃者を使用してクライアントアプリケーションにそれを注入する別のユーザ（犠牲者）を取得しようとする試みで承認「コード」許可タイプを活用しますアカウント。目標は、クライアントサイト上の攻撃者のユーザーアカウントで被害者のリソースに対するアクセス許可を関連付けることです。"
    },
    {
      "indent": 3,
      "text": "The attacker abuses an existing client application and combines it with his own counterfeit client web site. The attacker depends on the victim expecting the client application to request access to a certain resource server. The victim, seeing only a normal request from an expected application, approves the request. The attacker then uses the victim's authorization to gain access to the information unknowingly authorized by the victim.",
      "ja": "攻撃者が侵害既存のクライアント・アプリケーションとは、彼自身の偽造クライアントのWebサイトとそれを兼ね備えています。攻撃者は、特定のリソースサーバーへのアクセスを要求するクライアントアプリケーションを期待して、被害者に依存します。予想されるアプリケーションからのみの通常の要求を見て、被害者は、要求を承認します。その後、攻撃者は無意識のうちに被害者が許可した情報へのアクセスを得るために、被害者の許可を使用しています。"
    },
    {
      "indent": 3,
      "text": "The attacker conducts the following flow:",
      "ja": "攻撃者は、次のフローを実施します。"
    },
    {
      "indent": 3,
      "text": "1. The attacker accesses the client web site (or application) and initiates data access to a particular resource server. The client web site in turn initiates an authorization request to the resource server's authorization server. Instead of proceeding with the authorization process, the attacker modifies the authorization server end-user authorization URL as constructed by the client to include a redirect URI parameter referring to a web site under his control (attacker's web site).",
      "ja": "1.攻撃者は、クライアントのWebサイト（またはアプリケーション）にアクセスし、特定のリソースサーバーへのデータアクセスを開始します。順番にクライアントのウェブサイトは、リソースサーバーの認証サーバへの認証要求を開始します。代わりに、承認プロセスを進めるのは、攻撃者が自分のコントロール（攻撃者のWebサイト）の下でのウェブサイトを参照のリダイレクトURIパラメータが含まれるように、クライアントによって構成された認証サーバのエンドユーザの認証URLを変更します。"
    },
    {
      "indent": 3,
      "text": "2. The attacker tricks another user (the victim) into opening that modified end-user authorization URI and authorizing access (e.g., via an email link or blog link). The way the attacker achieves this goal is out of scope.",
      "ja": "2.攻撃者のトリック開口部に別のユーザ（犠牲者）が変更され、エンドユーザーの認証URIと（電子メールのリンクやブログのリンクを介して、例えば、）許可アクセス。攻撃者がこの目標を達成方法は、範囲外です。"
    },
    {
      "indent": 3,
      "text": "3. Having clicked the link, the victim is requested to authenticate and authorize the client site to have access.",
      "ja": "3.リンクをクリックした、被害者がアクセス権を持っているクライアントサイトを認証し、認証するために要求されています。"
    },
    {
      "indent": 3,
      "text": "4. After completion of the authorization process, the authorization server redirects the user agent to the attacker's web site instead of the original client web site.",
      "ja": "4.承認プロセスの完了後、認証サーバではなく、元のクライアントのWebサイトの攻撃者のWebサイトにユーザーエージェントをリダイレクトします。"
    },
    {
      "indent": 3,
      "text": "5. The attacker obtains the authorization \"code\" from his web site by means that are out of scope of this document.",
      "ja": "5.攻撃者はこの文書の範囲外であるによって、彼のウェブサイトからの許可「コード」を取得します。"
    },
    {
      "indent": 3,
      "text": "6. He then constructs a redirect URI to the target web site (or application) based on the original authorization request's redirect URI and the newly obtained authorization \"code\", and directs his user agent to this URL. The authorization \"code\" is injected into the original client site (or application).",
      "ja": "6.彼は、その後のは、URIと新たに取得した認証「のコードを」リダイレクト元の承認要求に基づいて、対象のWebサイト（またはアプリケーション）へのリダイレクトURIを構築し、このURLに自分のユーザエージェントに指示します。承認「コード」は、元のクライアントサイト（またはアプリケーション）に注入されます。"
    },
    {
      "indent": 3,
      "text": "7. The client site uses the authorization \"code\" to fetch a token from the authorization server and associates this token with the attacker's user account on this site.",
      "ja": "7.クライアントサイトは、このサイト上で攻撃者のユーザーアカウントで認証サーバや仲間からこのトークンをトークンを取得するための許可「コード」を使用しています。"
    },
    {
      "indent": 3,
      "text": "8. The attacker may now access the victim's resources using the client site.",
      "ja": "8.攻撃者は現在、クライアントサイトを利用して被害者のリソースにアクセスすることがあります。"
    },
    {
      "indent": 3,
      "text": "Impact: The attacker gains access to the victim's resources as associated with his account on the client site.",
      "ja": "影響：クライアントのサイトで自分のアカウントに関連付けられているとして、攻撃者は被害者のリソースへのアクセス。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o The attacker will need to use another redirect URI for its authorization process rather than the target web site because it needs to intercept the flow. So, if the authorization server associates the authorization \"code\" with the redirect URI of a particular end-user authorization and validates this redirect URI with the redirect URI passed to the token's endpoint, such an attack is detected (see Section 5.2.4.5).",
      "ja": "O、攻撃者は、それが流れを遮断する必要があるため、その承認プロセスではなく、ターゲットのWebサイトのために別のURIをリダイレクト使用する必要があります。認証サーバは、特定のエンドユーザーの認証のリダイレクトURIと認証「コード」を関連付け、これはURIがトークンのエンドポイントに渡さリダイレクトしてURIをリダイレクト検証するのであれば、このような攻撃が検出された（セクション5.2.4.5を参照してください） 。"
    },
    {
      "indent": 3,
      "text": "o The authorization server may also enforce the usage and validation of pre-registered redirect URIs (see Section 5.2.3.5). This will allow for early recognition of authorization \"code\" disclosure to counterfeit clients.",
      "ja": "O認可サーバは、予め登録リダイレクトURIを（セクション5.2.3.5を参照）の使用及び検証を適用してもよいです。これは偽造クライアントに認証「コード」の開示の早期発見が可能になります。"
    },
    {
      "indent": 3,
      "text": "o For native applications, one could also consider using deployment-specific client ids and secrets (see Section 5.2.3.4), along with the binding of authorization \"codes\" to \"client_ids\" (see Section 5.2.4.4) to detect such an attack because the attacker does not have access to the deployment-specific secret. Thus, he will not be able to exchange the authorization \"code\".",
      "ja": "Oネイティブアプリケーションの場合、1はまた、このような攻撃を検出する（セクション5.2.4.4を参照）認証「コード」に「client_ids」の結合と一緒に、（セクション5.2.3.4を参照）、展開固有のクライアントIDと秘密を使用して検討することもでき攻撃者は、デプロイメント固有の秘密へのアクセスを持っていないため。このように、彼は承認「コード」を交換することはできません。"
    },
    {
      "indent": 3,
      "text": "o The client may consider using other flows that are not vulnerable to this kind of attack, such as the implicit grant type (see Section 4.4.2) or resource owner password credentials (see Section 4.4.3).",
      "ja": "oをクライアント（セクション4.4.3を参照）、このような暗黙の許可タイプ（4.4.2項を参照）、またはリソースの所有者のパスワードの認証情報として、この種の攻撃に対して脆弱ではありません他のフローを、使用して検討すること。"
    },
    {
      "indent": 0,
      "text": "4.4.1.8. Threat: CSRF Attack against redirect-uri",
      "section_title": true,
      "ja": "4.4.1.8。脅威：リダイレクトURIに対するCSRF攻撃"
    },
    {
      "indent": 3,
      "text": "Cross-site request forgery (CSRF) is a web-based attack whereby HTTP requests are transmitted from a user that the web site trusts or has authenticated (e.g., via HTTP redirects or HTML forms). CSRF attacks on OAuth approvals can allow an attacker to obtain authorization to OAuth protected resources without the consent of the user.",
      "ja": "クロスサイトリクエストフォージェリ（CSRF）（例えば、HTTPを介してリダイレクトまたはHTMLフォーム）HTTPリクエストがウェブサイトの信頼ことをユーザから送信されるか、または認証されたことにより、Webベースの攻撃です。 OAuthの承認にCSRF攻撃は、攻撃者がユーザーの同意なしにOAuth保護されたリソースへの許可を取得できるようにすることができます。"
    },
    {
      "indent": 3,
      "text": "This attack works against the redirect URI used in the authorization \"code\" flow. An attacker could authorize an authorization \"code\" to their own protected resources on an authorization server. He then aborts the redirect flow back to the client on his device and tricks the victim into executing the redirect back to the client. The client receives the redirect, fetches the token(s) from the authorization server, and associates the victim's client session with the resources accessible using the token.",
      "ja": "この攻撃は、URIが認証「コード」の流れで使用したリダイレクト不利に働きます。攻撃者は、認証サーバ上で、独自の保護されたリソースへの許可「コード」を許可することができます。彼はその後、リダイレクトは、クライアントにリダイレクトを実行するに彼のデバイスやトリック被害者に戻って、クライアントへの流れ中止します。クライアントは、リダイレクトを受け、認証サーバからトークン（複数可）を取得し、トークンを使用してアクセス可能なリソースと被害者のクライアントセッションに関連付けられます。"
    },
    {
      "indent": 3,
      "text": "Impact: The user accesses resources on behalf of the attacker. The effective impact depends on the type of resource accessed. For example, the user may upload private items to an attacker's resources. Or, when using OAuth in 3rd-party login scenarios, the user may associate his client account with the attacker's identity at the external Identity Provider. In this way, the attacker could easily access the victim's data at the client by logging in from another device with his credentials at the external Identity Provider.",
      "ja": "影響：ユーザーが攻撃者に代わってリソースにアクセスします。効果的な影響は、アクセスリソースの種類に依存します。たとえば、ユーザーが攻撃者のリソースへのプライベートアイテムをアップロードすることができます。サードパーティのログインシナリオではOAuthを使用している場合や、ユーザーが外部のIDプロバイダで、攻撃者の身元と彼のクライアントアカウントを関連付けることができます。この方法では、攻撃者が簡単に外部のIDプロバイダで彼の資格情報を使用して別のデバイスからログインすることで、クライアントで、被害者のデータにアクセスすることができます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o The \"state\" parameter should be used to link the authorization request with the redirect URI used to deliver the access token (Section 5.3.5).",
      "ja": "O「状態」パラメータは、URIがアクセストークン（5.3.5）を配信するために使用リダイレクトと認証要求をリンクするために使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Client developers and end users can be educated to not follow untrusted URLs.",
      "ja": "oクライアントの開発者とエンドユーザーは、信頼されていないURLを従わないために教育を受けることができます。"
    },
    {
      "indent": 0,
      "text": "4.4.1.9. Threat: Clickjacking Attack against Authorization",
      "section_title": true,
      "ja": "4.4.1.9。脅威：認証に対するクリックジャッキング攻撃"
    },
    {
      "indent": 3,
      "text": "With clickjacking, a malicious site loads the target site in a transparent iFrame (see [iFrame]) overlaid on top of a set of dummy buttons that are carefully constructed to be placed directly under important buttons on the target site. When a user clicks a visible button, they are actually clicking a button (such as an \"Authorize\" button) on the hidden page.",
      "ja": "クリックジャッキングでは、悪質なサイトは慎重にターゲットサイト上での重要なボタンの下に直接配置されるように構成されたダミーのボタンのセットの上にオーバーレイ（[iFrameの]参照）透明iframe内に標的部位をロードします。ユーザーが目に見えるボタンをクリックすると、彼らは実際に隠されたページ（例えば、「承認」ボタンのような）ボタンをクリックしています。"
    },
    {
      "indent": 3,
      "text": "Impact: An attacker can steal a user's authentication credentials and access their resources.",
      "ja": "影響：攻撃者は、ユーザーの認証情報を盗むとそのリソースにアクセスすることができます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o For newer browsers, avoidance of iFrames during authorization can be enforced on the server side by using the X-FRAME-OPTIONS header (Section 5.2.2.6).",
      "ja": "O新しいブラウザは、認証時のiFrameの回避は、X-FRAME-OPTIONSヘッダ（セクション5.2.2.6）を使用して、サーバ側で実施することができます。"
    },
    {
      "indent": 3,
      "text": "o For older browsers, JavaScript frame-busting (see [Framebusting]) techniques can be used but may not be effective in all browsers.",
      "ja": "O古いブラウザの場合、JavaScriptのフレーム無効化（[Framebusting]参照）技術を使用することができるが、すべてのブラウザに有効ではないかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.4.1.10. Threat: Resource Owner Impersonation",
      "section_title": true,
      "ja": "4.4.1.10。脅威：リソース所有者の偽装"
    },
    {
      "indent": 3,
      "text": "When a client requests access to protected resources, the authorization flow normally involves the resource owner's explicit response to the access request, either granting or denying access to the protected resources. A malicious client can exploit knowledge of the structure of this flow in order to gain authorization without the resource owner's consent, by transmitting the necessary requests programmatically and simulating the flow against the authorization server. That way, the client may gain access to the victim's resources without her approval. An authorization server will be vulnerable to this threat if it uses non-interactive authentication mechanisms or splits the authorization flow across multiple pages.",
      "ja": "クライアントが保護されたリソースへのアクセスを要求すると、承認フローは、通常、アクセス要求に対するリソースの所有者の明示的な応答を含む、いずれかの保護されたリソースへのアクセスを許可または拒否します。悪意のあるクライアントは、プログラムに必要な要求を送信し、認証サーバに対して流れをシミュレートすることで、リソースの所有者の同意を得ずに承認を得るために、この流れの構造の知識を活用することができます。こうすることで、クライアントは、彼女の承認を得ずに被害者のリソースへのアクセスを得ることができます。それは非対話型の認証メカニズムを使用したり、複数のページにわたって承認フローを分割した場合、認証サーバは、この脅威に対して脆弱になります。"
    },
    {
      "indent": 3,
      "text": "The malicious client might embed a hidden HTML user agent, interpret the HTML forms sent by the authorization server, and automatically send the corresponding form HTTP POST requests. As a prerequisite, the attacker must be able to execute the authorization process in the context of an already-authenticated session of the resource owner with the authorization server. There are different ways to achieve this:",
      "ja": "悪意のあるクライアントは、隠されたHTMLのユーザエージェントを埋め込み、認証サーバから送信されたHTMLフォームを解釈し、自動的に対応するフォームHTTPのPOSTリクエストを送信することがあります。前提条件として、攻撃者は、認証サーバとのリソースの所有者の既に認証されたセッションのコンテキストで認証処理を実行することができなければなりません。これを達成するためのさまざまな方法があります。"
    },
    {
      "indent": 3,
      "text": "o The malicious client could abuse an existing session in an external browser or cross-browser cookies on the particular device.",
      "ja": "O悪意のあるクライアントは、特定のデバイス上で外部ブラウザやクロスブラウザのクッキーに既存のセッションを悪用する可能性があります。"
    },
    {
      "indent": 3,
      "text": "o The malicious client could also request authorization for an initial scope acceptable to the user and then silently abuse the resulting session in his browser instance to \"silently\" request another scope.",
      "ja": "悪意のあるクライアントは、ユーザーに受け入れられる最初のスコープのための許可を要求し、静かに「静かに」要求、別のスコープに彼のブラウザインスタンスが得られたセッションを悪用する可能性がありoを。"
    },
    {
      "indent": 3,
      "text": "o Alternatively, the attacker might exploit an authorization server's ability to authenticate the resource owner automatically and without user interactions, e.g., based on certificates.",
      "ja": "Oまた、攻撃者は、証明書に基づいて、例えば、自動的にユーザーとの対話なしでリソースの所有者を認証する認証サーバの能力を悪用する可能性があります。"
    },
    {
      "indent": 3,
      "text": "In all cases, such an attack is limited to clients running on the victim's device, either within the user agent or as a native app.",
      "ja": "すべての場合において、このような攻撃は、ユーザーエージェント内またはネイティブアプリとしてのいずれかで、被害者のデバイス上で実行しているクライアントに限定されています。"
    },
    {
      "indent": 3,
      "text": "Please note: Such attacks cannot be prevented using CSRF countermeasures, since the attacker just \"executes\" the URLs as prepared by the authorization server including any nonce, etc.",
      "ja": "ご注意：任意のナンスを含む認証サーバによって調製した攻撃者は、単になど、URLを「実行」するので、このような攻撃は、CSRF対策を使用して防止することができません"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "Authorization servers should decide, based on an analysis of the risk associated with this threat, whether to detect and prevent this threat.",
      "ja": "認証サーバは、この脅威を検出しないようにするかどうか、この脅威に関連するリスクの分析に基づいて、決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "In order to prevent such an attack, the authorization server may force a user interaction based on non-predictable input values as part of the user consent approval. The authorization server could",
      "ja": "このような攻撃を防ぐために、認証サーバーは、ユーザーの同意の承認の一環として、非予測可能な入力値に基づいて、ユーザとの対話を強制することがあります。認証サーバ可能性"
    },
    {
      "indent": 3,
      "text": "o combine password authentication and user consent in a single form,",
      "ja": "O単一のフォームでパスワード認証で、ユーザーの同意を組み合わせて、"
    },
    {
      "indent": 3,
      "text": "o make use of CAPTCHAs, or",
      "ja": "CAPTCHAのを利用するために、または"
    },
    {
      "indent": 3,
      "text": "o use one-time secrets sent out of band to the resource owner (e.g., via text or instant message).",
      "ja": "Oリソース所有者（例えば、テキストまたはインスタントメッセージを介して）に帯域外送信ワンタイム秘密を使用します。"
    },
    {
      "indent": 3,
      "text": "Alternatively, in order to allow the resource owner to detect abuse, the authorization server could notify the resource owner of any approval by appropriate means, e.g., text or instant message, or email.",
      "ja": "また、リソースの所有者が虐待を検出することを可能にするために、認証サーバは、適切な手段、例えば、テキストやインスタントメッセージ、または電子メールによるいかなる承認のリソースの所有者に通知することもできます。"
    },
    {
      "indent": 0,
      "text": "4.4.1.11. Threat: DoS Attacks That Exhaust Resources",
      "section_title": true,
      "ja": "4.4.1.11。脅威：DoS攻撃は、その排気リソースを攻撃"
    },
    {
      "indent": 3,
      "text": "If an authorization server includes a nontrivial amount of entropy in authorization \"codes\" or access tokens (limiting the number of possible codes/tokens) and automatically grants either without user intervention and has no limit on codes or access tokens per user, an attacker could exhaust the pool of authorization \"codes\" by repeatedly directing the user's browser to request authorization \"codes\" or access tokens.",
      "ja": "認証サーバは、認証「コード」又はアクセストークン（可能なコード/トークンの数を制限する）におけるエントロピーの自明でない量が含まれており、自動的にユーザの介入なしのいずれかを付与し、ユーザごとのコードまたはアクセストークンに制限がない場合、攻撃者は可能性繰り返し認証「コード」またはアクセストークンを要求するユーザーのブラウザを向けることによって、認可「コード」のプールを使い果たします。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o The authorization server should consider limiting the number of access tokens granted per user.",
      "ja": "O認証サーバは、ユーザごとに付与されたアクセストークンの数を制限することを検討してください。"
    },
    {
      "indent": 3,
      "text": "o The authorization server should include a nontrivial amount of entropy in authorization \"codes\".",
      "ja": "O認証サーバは、認証「コード」にエントロピーの自明でない量を含むべきです。"
    },
    {
      "indent": 0,
      "text": "4.4.1.12. Threat: DoS Using Manufactured Authorization \"codes\"",
      "section_title": true,
      "ja": "4.4.1.12。脅威：DoSの製造認可の「コード」を使用"
    },
    {
      "indent": 3,
      "text": "An attacker who owns a botnet can locate the redirect URIs of clients that listen on HTTP, access them with random authorization \"codes\", and cause a large number of HTTPS connections to be concentrated onto the authorization server. This can result in a denial-of-service (DoS) attack on the authorization server.",
      "ja": "ボットネットを所有している攻撃者は、HTTPをリッスンクライアントのリダイレクトURIを見つけランダム認証「コード」でそれらにアクセスし、認証サーバに集中するHTTPS接続の多数を引き起こす可能性があります。これは、認証サーバ上のサービス拒否（DoS）攻撃につながることができます。"
    },
    {
      "indent": 3,
      "text": "This attack can still be effective even when CSRF defense/the \"state\" parameter (see Section 4.4.1.8) is deployed on the client side. With such a defense, the attacker might need to incur an additional HTTP request to obtain a valid CSRF code/\"state\" parameter. This apparently cuts down the effectiveness of the attack by a factor of 2. However, if the HTTPS/HTTP cost ratio is higher than 2 (the cost factor is estimated to be around 3.5x at [SSL-Latency]), the attacker still achieves a magnification of resource utilization at the expense of the authorization server.",
      "ja": "この攻撃は、まだCSRF防衛/「状態」パラメータは（セクション4.4.1.8を参照）、クライアント側に配備された場合にも有効であることができます。こうした防衛では、攻撃者が有効なCSRFコード/「状態」のパラメータを取得するために追加のHTTPリクエストを負担する必要がある場合があります。 HTTPS / HTTPコスト比は依然として、（コスト係数は[SSL-レイテンシ]で3.5倍程度になると推定される）攻撃2以上である場合、これは明らかに、しかし2の因子による攻撃の有効性をダウンカット認証サーバを犠牲にしてリソース使用率の倍率を実現しています。"
    },
    {
      "indent": 3,
      "text": "Impact: There are a few effects that the attacker can accomplish with this OAuth flow that they cannot easily achieve otherwise.",
      "ja": "影響：攻撃者は、彼らが簡単そう達成することはできません。このOAuthのフローを使用して実行できることを、いくつかの効果があります。"
    },
    {
      "indent": 3,
      "text": "1. Connection laundering: With the clients as the relay between the attacker and the authorization server, the authorization server learns little or no information about the identity of the attacker. Defenses such as rate-limiting on the offending attacker machines are less effective because it is difficult to identify the attacking machines. Although an attacker could also launder its connections through an anonymizing system such as Tor, the effectiveness of that approach depends on the capacity of the anonymizing system. On the other hand, a potentially large number of OAuth clients could be utilized for this attack.",
      "ja": "1.接続ロンダリング：攻撃者と認証サーバ間のリレーとしてのクライアントと、認証サーバは、攻撃者の身元についてはほとんどあるいは全く情報を学習します。攻撃機を識別することは困難であるため、このような問題のある攻撃者がマシン上でレートが制限などの防御はあまり効果的です。攻撃者はまた、Torのような匿名化システムを介してその接続を洗濯できるが、そのアプローチの有効性は、匿名化システムの能力に依存します。一方、OAuthのクライアントの潜在的に大きな数は、この攻撃のために利用することができます。"
    },
    {
      "indent": 3,
      "text": "2. Asymmetric resource utilization: The attacker incurs the cost of an HTTP connection and causes an HTTPS connection to be made on the authorization server; the attacker can coordinate the timing of such HTTPS connections across multiple clients relatively easily. Although the attacker could achieve something similar, say, by including an iFrame pointing to the HTTPS URL of the authorization server in an HTTP web page and luring web users to visit that page, timing attacks using such a scheme may be more difficult, as it seems nontrivial to synchronize a large number of users to simultaneously visit a particular site under the attacker's control.",
      "ja": "2.非対称リソース使用率：攻撃者は、HTTP接続のコストが発生し、認証サーバ上で行われるHTTPS接続が発生します。攻撃者は、比較的容易に、複数のクライアント間でそのようなHTTPS接続のタイミングを調整することができます。攻撃者は、このようなスキームはそれとして、より難しいかもしれ使用した攻撃のタイミング、HTTPのWebページでの認証サーバのHTTPS URLを指していると、そのページを訪問するWebユーザを呼び寄せるのiFrame含むことによって、たとえば、類似した何かを達成できるが、同時に、攻撃者の制御下で、特定のサイトを訪問する多数のユーザーを同期するために自明でないようです。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Though not a complete countermeasure by themselves, CSRF defense and the \"state\" parameter created with secure random codes should be deployed on the client side. The client should forward the authorization \"code\" to the authorization server only after both the CSRF token and the \"state\" parameter are validated.",
      "ja": "それだけではない、完全な対策もののO、CSRFの防衛と安全なランダムなコードで作成された「状態」パラメータは、クライアント側に配備する必要があります。クライアントは、CSRFトークンと「状態」パラメータの両方が検証された後にのみ認証サーバへ認証「コード」を転送する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the client authenticates the user, either through a single-sign-on protocol or through local authentication, the client should suspend the access by a user account if the number of invalid authorization \"codes\" submitted by this user exceeds a certain threshold.",
      "ja": "クライアントは、シングルサインオンプロトコルを介して、またはローカル認証のいずれかを介して、ユーザを認証する場合は、このユーザーが提出した無効な認証「コード」の数が一定のしきい値を超えた場合、O、クライアントは、ユーザーアカウントによるアクセスを中断する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The authorization server should send an error response to the client reporting an invalid authorization \"code\" and rate-limit or disallow connections from clients whose number of invalid requests exceeds a threshold.",
      "ja": "O認証サーバが無効認証「コード」とレート制限を報告し、クライアントにエラー応答を送信したり、数無効な要求のしきい値を超えるクライアントからの接続を禁止すべきです。"
    },
    {
      "indent": 0,
      "text": "4.4.1.13. Threat: Code Substitution (OAuth Login)",
      "section_title": true,
      "ja": "4.4.1.13。脅威：コード置換（OAuthのログイン）"
    },
    {
      "indent": 3,
      "text": "An attacker could attempt to log into an application or web site using a victim's identity. Applications relying on identity data provided by an OAuth protected service API to login users are vulnerable to this threat. This pattern can be found in so-called \"social login\" scenarios.",
      "ja": "攻撃者は、被害者の身元を使用して、アプリケーションやWebサイトへのログインを試みる可能性があります。ユーザーのログインにはOAuth保護されたサービスのAPIが提供するアイデンティティデータに依存するアプリケーションは、この脅威に対して脆弱です。このパターンは、いわゆる「ソーシャル・ログイン」のシナリオで見つけることができます。"
    },
    {
      "indent": 3,
      "text": "As a prerequisite, a resource server offers an API to obtain personal information about a user that could be interpreted as having obtained a user identity. In this sense, the client is treating the resource server API as an \"identity\" API. A client utilizes OAuth to obtain an access token for the identity API. It then queries the identity API for an identifier and uses it to look up its internal user account data (login). The client assumes that, because it was able to obtain information about the user, the user has been authenticated.",
      "ja": "前提条件として、リソースサーバーは、ユーザーIDを取得したと解釈することができ、ユーザーの個人情報を取得するAPIを提供しています。この意味では、クライアントは「アイデンティティ」APIなどのリソースサーバーのAPIを扱っています。クライアントは、アイデンティティAPIのアクセストークンを取得するためのOAuthを利用しています。その後、識別子のためのアイデンティティAPIを照会し、その内部のユーザー・アカウント・データ（ログイン）をルックアップするためにそれを使用しています。クライアントは、ユーザーに関する情報を取得することができたので、ユーザーが認証されている、ということを前提としています。"
    },
    {
      "indent": 3,
      "text": "If the client uses the grant type \"code\", the attacker needs to gather a valid authorization \"code\" of the respective victim from the same Identity Provider used by the target client application. The attacker tricks the victim into logging into a malicious app (which may appear to be legitimate to the Identity Provider) using the same Identity Provider as the target application. This results in the Identity Provider's authorization server issuing an authorization",
      "ja": "クライアントが許可タイプ「コード」を使用している場合、攻撃者がターゲットクライアントアプリケーションによって使用されるのと同じIDプロバイダからのそれぞれの被害者の有効な認証「コード」を収集する必要があります。攻撃者のトリックターゲット・アプリケーションと同じアイデンティティプロバイダを使用して（IDプロバイダに、正当なように見える場合があります）悪意のあるアプリにログインするに被害者。これは、許可を発行するIDプロバイダの認証サーバになり"
    },
    {
      "indent": 3,
      "text": "\"code\" for the respective identity API. The malicious app then sends this code to the attacker, which in turn triggers a login process within the target application. The attacker now manipulates the authorization response and substitutes their code (bound to their identity) for the victim's code. This code is then exchanged by the client for an access token, which in turn is accepted by the identity API, since the audience, with respect to the resource server, is correct. But since the identifier returned by the identity API is determined by the identity in the access token (issued based on the victim's code), the attacker is logged into the target application under the victim's identity.",
      "ja": "それぞれのアイデンティティAPIのための「コード」。悪質なアプリは、その後順番にターゲット・アプリケーション内のログイン・プロセスをトリガーする攻撃者にこのコードを送信します。攻撃者は現在、認可応答を操作し、被害者のためのコード（自分のアイデンティティにバインドされた）自分のコードに置き換えます。このコードは、リソースサーバに関して、正確である、聴衆から、今度はアイデンティティAPIによって受け入れられているアクセストークンのためにクライアントによって交換されます。アイデンティティAPIによって返された識別子は、（被害者のコードに基づいて発行される）アクセストークンのIDによって決定されているのでしかし、攻撃者は被害者の身元の下でターゲットアプリケーションにログインしています。"
    },
    {
      "indent": 3,
      "text": "Impact: The attacker gains access to an application and user-specific data within the application.",
      "ja": "影響：アプリケーション内のアプリケーションやユーザー固有のデータに攻撃者がアクセスできます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o All clients must indicate their client ids with every request to exchange an authorization \"code\" for an access token. The authorization server must validate whether the particular authorization \"code\" has been issued to the particular client. If possible, the client shall be authenticated beforehand.",
      "ja": "Oすべてのクライアントがアクセストークンの承認「コード」を交換するすべての要求で自分のクライアントIDを指定する必要があります。認証サーバは、特定の認証「コード」は、特定のクライアントに発行されているかどうかを検証する必要があります。可能な場合、クライアントは事前に認証されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Clients should use an appropriate protocol, such as OpenID (cf. [OPENID]) or SAML (cf. [OASIS.sstc-saml-bindings-1.1]) to implement user login. Both support audience restrictions on clients.",
      "ja": "Oクライアントはユーザのログインを実装するために、このようなOpenIDの（参照[OpenIDの]）またはSAML（参照[OASIS.sstc-SAMLバインディング-1.1]）のような適切なプロトコルを使用すべきです。どちらもサポートするクライアント上の聴衆の制限。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Implicit Grant",
      "section_title": true,
      "ja": "4.4.2。暗黙の助成金"
    },
    {
      "indent": 3,
      "text": "In the implicit grant type flow, the access token is directly returned to the client as a fragment part of the redirect URI. It is assumed that the token is not sent to the redirect URI target, as HTTP user agents do not send the fragment part of URIs to HTTP servers. Thus, an attacker cannot eavesdrop the access token on this communication path, and the token cannot leak through HTTP referrer headers.",
      "ja": "暗黙グラント型フローでは、アクセストークンを直接リダイレクトURIの断片の一部としてクライアントに返されます。 HTTPユーザーエージェントはHTTPサーバへのURIのフラグメント部分を送信しないようトークンは、リダイレクトURIのターゲットに送信されていないものとします。したがって、攻撃者は、この通信路にアクセストークンを傍受することができず、トークンは、HTTPリファラヘッダを通って漏れることができません。"
    },
    {
      "indent": 0,
      "text": "4.4.2.1. Threat: Access Token Leak in Transport/Endpoints",
      "section_title": true,
      "ja": "4.4.2.1。脅威：交通/エンドポイントでのアクセストークンリーク"
    },
    {
      "indent": 3,
      "text": "This token might be eavesdropped by an attacker. The token is sent from the server to the client via a URI fragment of the redirect URI. If the communication is not secured or the endpoint is not secured, the token could be leaked by parsing the returned URI.",
      "ja": "このトークンは攻撃者によって盗聴される可能性があります。トークンは、リダイレクトURIのURIフラグメントを介してサーバからクライアントに送信されます。通信が確保されていないか、またはエンドポイントが確保されていない場合は、トークンが返されたURIを解析することにより、漏洩することができました。"
    },
    {
      "indent": 3,
      "text": "Impact: The attacker would be able to assume the same rights granted by the token.",
      "ja": "影響：攻撃者はトークンによって付与された同じ権利を想定することができるだろう。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o The authorization server should ensure confidentiality (e.g., using TLS) of the response from the authorization server to the client (see Section 5.1.1).",
      "ja": "認証サーバoをクライアントに認証サーバからの応答の機密性を（例えば、TLSを使用）（5.1.1項を参照）を確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4.2.2. Threat: Access Token Leak in Browser History",
      "section_title": true,
      "ja": "4.4.2.2。脅威：ブラウザの履歴にアクセストークンリーク"
    },
    {
      "indent": 3,
      "text": "An attacker could obtain the token from the browser's history. Note that this means the attacker needs access to the particular device.",
      "ja": "攻撃者は、ブラウザの履歴からトークンを得ることができました。これは、攻撃者が特定のデバイスへのアクセスを必要とすることを意味していることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Use short expiry time for tokens (see Section 5.1.5.3). Reduced scope of the token may reduce the impact of that attack (see Section 5.1.5.1).",
      "ja": "O（セクション5.1.5.3を参照）トークンの有効期限の短い時間を使用してください。その攻撃の影響を低減することができるトークンの減少範囲（セクション5.1.5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o Make responses non-cacheable.",
      "ja": "O応答がキャッシュ不可能にします。"
    },
    {
      "indent": 0,
      "text": "4.4.2.3. Threat: Malicious Client Obtains Authorization",
      "section_title": true,
      "ja": "4.4.2.3。脅威：悪意のあるクライアントが認証を取得"
    },
    {
      "indent": 3,
      "text": "A malicious client could attempt to obtain a token by fraud.",
      "ja": "悪意のあるクライアントが詐欺でトークンを取得しようとする可能性があり。"
    },
    {
      "indent": 3,
      "text": "The same countermeasures as for Section 4.4.1.4 are applicable, except client authentication.",
      "ja": "セクション4.4.1.4と同じ対策がクライアント認証を除き、適用されます。"
    },
    {
      "indent": 0,
      "text": "4.4.2.4. Threat: Manipulation of Scripts",
      "section_title": true,
      "ja": "4.4.2.4。脅威：スクリプトの操作"
    },
    {
      "indent": 3,
      "text": "A hostile party could act as the client web server and replace or modify the actual implementation of the client (script). This could be achieved using DNS or ARP spoofing. This applies to clients implemented within the web browser in a scripting language.",
      "ja": "敵対的な政党は、クライアントのWebサーバとして動作し、クライアント（スクリプト）の実際の実装を交換したり、修正することができます。これは、DNSやARPスプーフィングを使用して達成することができました。これは、スクリプト言語で、Webブラウザ内で実現するクライアントに適用されます。"
    },
    {
      "indent": 3,
      "text": "Impact: The attacker could obtain user credential information and assume the full identity of the user.",
      "ja": "影響：攻撃者は、ユーザーの資格情報を取得し、ユーザーの完全なアイデンティティを仮定できます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o The authorization server should authenticate the server from which scripts are obtained (see Section 5.1.2).",
      "ja": "O認証サーバは、スクリプトが（5.1.2項を参照）を取得したサーバを認証する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The client should ensure that scripts obtained have not been altered in transport (see Section 5.1.1).",
      "ja": "クライアントが取得したスクリプトは、輸送に変更されていないことを確認する必要がありますO（5.1.1項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "o Introduce one-time, per-use secrets (e.g., \"client_secret\") values that can only be used by scripts in a small time window once loaded from a server. The intention would be to reduce the effectiveness of copying client-side scripts for re-use in an attacker's modified code.",
      "ja": "O一度サーバからロードされた小さな時間窓にスクリプトのみを使用することができる値は一時間あたりの使用秘密（例えば、「client_secret」）を導入します。その意図は、攻撃者の変更されたコードでの再利用のために、クライアント側のスクリプトをコピーの有効性を減らすことであろう。"
    },
    {
      "indent": 0,
      "text": "4.4.2.5. Threat: CSRF Attack against redirect-uri",
      "section_title": true,
      "ja": "4.4.2.5。脅威：リダイレクトURIに対するCSRF攻撃"
    },
    {
      "indent": 3,
      "text": "CSRF attacks (see Section 4.4.1.8) also work against the redirect URI used in the implicit grant flow. An attacker could acquire an access token to their own protected resources. He could then construct a redirect URI and embed their access token in that URI. If he can trick the user into following the redirect URI and the client does not have protection against this attack, the user may have the attacker's access token authorized within their client.",
      "ja": "CSRF攻撃は（セクション4.4.1.8を参照）もURIが暗黙の補助金の流れで使用されるリダイレクトの防止に取り組みます。攻撃者は、自分自身の保護されたリソースへのアクセストークンを取得することができます。彼はその後、リダイレクトURIを構築し、そのURIにそのアクセストークンを埋め込むことができます。彼は、リダイレクトURIとクライアントを次のようにユーザーをだますことができた場合は、この攻撃に対する保護を持っていない、ユーザーは自分のクライアントの中に認可攻撃者のアクセストークンを有することができます。"
    },
    {
      "indent": 3,
      "text": "Impact: The user accesses resources on behalf of the attacker. The effective impact depends on the type of resource accessed. For example, the user may upload private items to an attacker's resources. Or, when using OAuth in 3rd-party login scenarios, the user may associate his client account with the attacker's identity at the external Identity Provider. In this way, the attacker could easily access the victim's data at the client by logging in from another device with his credentials at the external Identity Provider.",
      "ja": "影響：ユーザーが攻撃者に代わってリソースにアクセスします。効果的な影響は、アクセスリソースの種類に依存します。たとえば、ユーザーが攻撃者のリソースへのプライベートアイテムをアップロードすることができます。サードパーティのログインシナリオではOAuthを使用している場合や、ユーザーが外部のIDプロバイダで、攻撃者の身元と彼のクライアントアカウントを関連付けることができます。この方法では、攻撃者が簡単に外部のIDプロバイダで彼の資格情報を使用して別のデバイスからログインすることで、クライアントで、被害者のデータにアクセスすることができます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o The \"state\" parameter should be used to link the authorization request with the redirect URI used to deliver the access token. This will ensure that the client is not tricked into completing any redirect callback unless it is linked to an authorization request initiated by the client. The \"state\" parameter should not be guessable, and the client should be capable of keeping the \"state\" parameter secret.",
      "ja": "O「状態」パラメータは、URIがアクセストークンを配信するために使用リダイレクトと認証要求をリンクするために使用する必要があります。これにより、クライアントは、それがクライアントによって開始され、認証要求にリンクされていない限り、すべてのリダイレクトのコールバックを完了するようにだまされていないことを確認します。 「状態」パラメータは、推測すべきではない、とクライアントが「状態」パラメータの秘密を保つことが可能であるべきです。"
    },
    {
      "indent": 3,
      "text": "o Client developers and end users can be educated to not follow untrusted URLs.",
      "ja": "oクライアントの開発者とエンドユーザーは、信頼されていないURLを従わないために教育を受けることができます。"
    },
    {
      "indent": 0,
      "text": "4.4.2.6. Threat: Token Substitution (OAuth Login)",
      "section_title": true,
      "ja": "4.4.2.6。脅威：トークンの置換（OAuthのログイン）"
    },
    {
      "indent": 3,
      "text": "An attacker could attempt to log into an application or web site using a victim's identity. Applications relying on identity data provided by an OAuth protected service API to login users are vulnerable to this threat. This pattern can be found in so-called \"social login\" scenarios.",
      "ja": "攻撃者は、被害者の身元を使用して、アプリケーションやWebサイトへのログインを試みる可能性があります。ユーザーのログインにはOAuth保護されたサービスのAPIが提供するアイデンティティデータに依存するアプリケーションは、この脅威に対して脆弱です。このパターンは、いわゆる「ソーシャル・ログイン」のシナリオで見つけることができます。"
    },
    {
      "indent": 3,
      "text": "As a prerequisite, a resource server offers an API to obtain personal information about a user that could be interpreted as having obtained a user identity. In this sense, the client is treating the resource server API as an \"identity\" API. A client utilizes OAuth to obtain an access token for the identity API. It then queries the identity API for an identifier and uses it to look up its internal user account data (login). The client assumes that, because it was able to obtain information about the user, the user has been authenticated.",
      "ja": "前提条件として、リソースサーバーは、ユーザーIDを取得したと解釈することができ、ユーザーの個人情報を取得するAPIを提供しています。この意味では、クライアントは「アイデンティティ」APIなどのリソースサーバーのAPIを扱っています。クライアントは、アイデンティティAPIのアクセストークンを取得するためのOAuthを利用しています。その後、識別子のためのアイデンティティAPIを照会し、その内部のユーザー・アカウント・データ（ログイン）をルックアップするためにそれを使用しています。クライアントは、ユーザーに関する情報を取得することができたので、ユーザーが認証されている、ということを前提としています。"
    },
    {
      "indent": 3,
      "text": "To succeed, the attacker needs to gather a valid access token of the respective victim from the same Identity Provider used by the target client application. The attacker tricks the victim into logging into a malicious app (which may appear to be legitimate to the Identity Provider) using the same Identity Provider as the target application. This results in the Identity Provider's authorization server issuing an access token for the respective identity API. The malicious app then sends this access token to the attacker, which in turn triggers a login process within the target application. The attacker now manipulates the authorization response and substitutes their access token (bound to their identity) for the victim's access token. This token is accepted by the identity API, since the audience, with respect to the resource server, is correct. But since the identifier returned by the identity API is determined by the identity in the access token, the attacker is logged into the target application under the victim's identity.",
      "ja": "成功するためには、攻撃者がターゲットクライアントアプリケーションによって使用されるのと同じIDプロバイダからのそれぞれの被害者の有効なアクセストークンを収集する必要があります。攻撃者のトリックターゲット・アプリケーションと同じアイデンティティプロバイダを使用して（IDプロバイダに、正当なように見える場合があります）悪意のあるアプリにログインするに被害者。これは、それぞれのアイデンティティAPIのアクセストークンを発行するIDプロバイダの認証サーバになります。悪質なアプリは、その後順番にターゲット・アプリケーション内のログイン・プロセスをトリガーする攻撃者にこのアクセストークンを送信します。攻撃者は現在、認可応答を操作し、被害者のアクセストークンのための（自分のアイデンティティに結合している）、そのアクセストークンを置き換えます。観客は、リソースサーバに関して、正確であるので、このトークンは、アイデンティティAPIによって受け入れられています。アイデンティティAPIによって返された識別子は、アクセストークンのIDによって決定されているのでしかし、攻撃者は被害者の身元の下でターゲットアプリケーションにログインしています。"
    },
    {
      "indent": 3,
      "text": "Impact: The attacker gains access to an application and user-specific data within the application.",
      "ja": "影響：アプリケーション内のアプリケーションやユーザー固有のデータに攻撃者がアクセスできます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Clients should use an appropriate protocol, such as OpenID (cf. [OPENID]) or SAML (cf. [OASIS.sstc-saml-bindings-1.1]) to implement user login. Both support audience restrictions on clients.",
      "ja": "Oクライアントはユーザのログインを実装するために、このようなOpenIDの（参照[OpenIDの]）またはSAML（参照[OASIS.sstc-SAMLバインディング-1.1]）のような適切なプロトコルを使用すべきです。どちらもサポートするクライアント上の聴衆の制限。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Resource Owner Password Credentials",
      "section_title": true,
      "ja": "4.4.3。リソース所有者のパスワードの資格情報"
    },
    {
      "indent": 3,
      "text": "The resource owner password credentials grant type (see [RFC6749], Section 4.3), often used for legacy/migration reasons, allows a client to request an access token using an end-user's user id and password along with its own credential. This grant type has higher risk because it maintains the UID/password anti-pattern. Additionally, because the user does not have control over the authorization process, clients using this grant type are not limited by scope but instead have potentially the same capabilities as the user themselves. As there is no authorization step, the ability to offer token revocation is bypassed.",
      "ja": "リソースの所有者のパスワードの認証情報は、多くの場合、レガシー/移行の理由のために使用、（[RFC6749]、セクション4.3を参照）タイプを付与するクライアントは、独自の資格と一緒にエンドユーザーのユーザーIDとパスワードを使ってアクセストークンを要求することができます。それはUID /パスワードアンチパターンを維持しているため、この助成金型は高いリスクを持っています。ユーザーが認証プロセスを制御できませんので、また、この補助金のタイプを使用しているクライアントは、範囲によってのみ限定されるのではなく、ユーザー自身として潜在的に同じ機能を持っています。無許可のステップが存在しないため、トークンの取り消しを提供する機能がバイパスされます。"
    },
    {
      "indent": 3,
      "text": "Because passwords are often used for more than 1 service, this anti-pattern may also put at risk whatever else is accessible with the supplied credential. Additionally, any easily derived equivalent (e.g., joe@example.com and joe@example.net) might easily allow someone to guess that the same password can be used elsewhere.",
      "ja": "パスワードは、多くの場合、1つの以上のサービスのために使用されているので、このアンチパターンも付属資格でアクセス可能である任意の他のリスクに置いてもよいです。さらに、任意の容易に導く同等（例えば、joe@example.comとjoe@example.net）簡単に誰かが同じパスワードを他の場所で使用することができることを推測することが可能かもしれません。"
    },
    {
      "indent": 3,
      "text": "Impact: The resource server can only differentiate scope based on the access token being associated with a particular client. The client could also acquire long-lived tokens and pass them up to an attacker's web service for further abuse. The client, eavesdroppers, or endpoints could eavesdrop the user id and password.",
      "ja": "影響：リソースサーバは、特定のクライアントに関連付けられているアクセストークンに基づいてスコープを区別することができます。クライアントはまた、長寿命のトークンを取得し、さらに乱用の攻撃者のWebサービスにそれらを渡すことができます。クライアント、盗聴者、またはエンドポイントは、ユーザーIDとパスワードを盗聴することができます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Except for migration reasons, minimize use of this grant type.",
      "ja": "移行の理由を除きO、この助成金型の使用を最小限に抑えます。"
    },
    {
      "indent": 3,
      "text": "o The authorization server should validate the client id associated with the particular refresh token with every refresh request (Section 5.2.2.2).",
      "ja": "O認証サーバは、すべてのリフレッシュ要求（5.2.2.2項）と、特定のリフレッシュトークンに関連付けられているクライアントIDを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "o As per the core OAuth specification, the authorization server must ensure that these transmissions are protected using transport-layer mechanisms such as TLS (see Section 5.1.1).",
      "ja": "OコアのOAuth仕様に従って、認証サーバは、これらの送信は、例えばTLS（セクション5.1.1を参照）のようなトランスポート層のメカニズムを使用して保護されていることを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Rather than encouraging users to use a UID and password, service providers should instead encourage users not to use the same password for multiple services.",
      "ja": "OむしろUIDとパスワードを使用するユーザーを奨励するよりも、サービスプロバイダーではなく、複数のサービスに同じパスワードを使用していないユーザーを奨励すべきです。"
    },
    {
      "indent": 3,
      "text": "o Limit use of resource owner password credential grants to scenarios where the client application and the authorizing service are from the same organization.",
      "ja": "Oクライアントアプリケーションおよび認可サービスは、同じ組織からのあるシナリオにリソースオーナーパスワード資格助成金の使用を制限します。"
    },
    {
      "indent": 0,
      "text": "4.4.3.1. Threat: Accidental Exposure of Passwords at Client Site",
      "section_title": true,
      "ja": "4.4.3.1。脅威：クライアントのサイトでパスワードを誤って暴露"
    },
    {
      "indent": 3,
      "text": "If the client does not provide enough protection, an attacker or disgruntled employee could retrieve the passwords for a user.",
      "ja": "クライアントが十分な保護を提供しない場合、攻撃者や不満を抱いた従業員は、ユーザーのパスワードを取得することができます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Use other flows that do not rely on the client's cooperation for secure resource owner credential handling.",
      "ja": "O安全なリソース所有者の資格情報を処理するためのクライアントの協力に依存しない他のフローを使用してください。"
    },
    {
      "indent": 3,
      "text": "o Use digest authentication instead of plaintext credential processing.",
      "ja": "Oの代わりに平文資格処理のダイジェスト認証を使用してください。"
    },
    {
      "indent": 3,
      "text": "o Obfuscate passwords in logs.",
      "ja": "Oログにパスワードを難読化。"
    },
    {
      "indent": 0,
      "text": "4.4.3.2. Threat: Client Obtains Scopes without End-User Authorization",
      "section_title": true,
      "ja": "4.4.3.2。脅威：エンドユーザーの許可なしにクライアントを得ますスコープ"
    },
    {
      "indent": 3,
      "text": "All interaction with the resource owner is performed by the client. Thus it might, intentionally or unintentionally, happen that the client obtains a token with scope unknown for, or unintended by, the resource owner. For example, the resource owner might think the client needs and acquires read-only access to its media storage only but the client tries to acquire an access token with full access permissions.",
      "ja": "リソースの所有者とのすべての対話は、クライアントによって実行されます。したがって、意図的または意図せずに、クライアントはのスコープ不明でトークンを取得し、またはリソースの所有者、意図しないということが起こるかもしれません。たとえば、リソースの所有者は、クライアントが必要とだけそのメディアストレージへの読み取り専用アクセスを取得しますが、クライアントはフルアクセス権限を持つアクセストークンを取得しようと思うかもしれません。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Use other flows that do not rely on the client's cooperation for resource owner interaction.",
      "ja": "Oリソースの所有者との対話のためのクライアントの協力に依存しない他のフローを使用してください。"
    },
    {
      "indent": 3,
      "text": "o The authorization server may generally restrict the scope of access tokens (Section 5.1.5.1) issued by this flow. If the particular client is trustworthy and can be authenticated in a reliable way, the authorization server could relax that restriction. Resource owners may prescribe (e.g., in their preferences) what the maximum scope is for clients using this flow.",
      "ja": "O認証サーバは、一般的に、この流れによって発行されたアクセストークン（セクション5.1.5.1）の範囲を制限することができます。特定のクライアントが信頼できると信頼性の高い方法で認証することができた場合、認証サーバは、その制限を緩和できます。リソースの所有者は、最大範囲はこのフローを使用してクライアントのために何であるか（自分の好みで、例えば）を定めることができます。"
    },
    {
      "indent": 3,
      "text": "o The authorization server could notify the resource owner by an appropriate medium, e.g., email, of the grant issued (see Section 5.1.3).",
      "ja": "O認証サーバは、適切な媒体によってリソースの所有者に通知することができ、例えば、電子メール、発行した助成金の（5.1.3項を参照してください）。"
    },
    {
      "indent": 0,
      "text": "4.4.3.3. Threat: Client Obtains Refresh Token through Automatic Authorization",
      "ja": "4.4.3.3。脅威：クライアントは自動認可を介した更新トークンを取得します"
    },
    {
      "indent": 3,
      "text": "All interaction with the resource owner is performed by the client. Thus it might, intentionally or unintentionally, happen that the client obtains a long-term authorization represented by a refresh token even if the resource owner did not intend so.",
      "ja": "リソースの所有者とのすべての対話は、クライアントによって実行されます。したがって、意図的または意図せずに、クライアントはリソースの所有者がそう意図しなかった場合でも、リフレッシュトークンによって表される長期的な許可を取得していることが起こるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Use other flows that do not rely on the client's cooperation for resource owner interaction.",
      "ja": "Oリソースの所有者との対話のためのクライアントの協力に依存しない他のフローを使用してください。"
    },
    {
      "indent": 3,
      "text": "o The authorization server may generally refuse to issue refresh tokens in this flow (see Section 5.2.2.1). If the particular client is trustworthy and can be authenticated in a reliable way (see client authentication), the authorization server could relax that restriction. Resource owners may allow or deny (e.g., in their preferences) the issuing of refresh tokens using this flow as well.",
      "ja": "O認証サーバは、一般的にこの流れでリフレッシュトークンを発行することを拒否することができる（5.2.2.1項を参照してください）。特定のクライアントが信頼できると（クライアント認証を参照）信頼性の高い方法で認証することができた場合、認証サーバは、その制限を緩和できます。リソースの所有者は、（自分の好みで、例えば）もこのフローを使用してリフレッシュトークンの発行を許可または拒否することができます。"
    },
    {
      "indent": 3,
      "text": "o The authorization server could notify the resource owner by an appropriate medium, e.g., email, of the refresh token issued (see Section 5.1.3).",
      "ja": "O認証サーバは、適切な媒体によってリソースの所有者に通知することができ、例えば、電子メール、発行されたリフレッシュトークンの（5.1.3項を参照してください）。"
    },
    {
      "indent": 0,
      "text": "4.4.3.4. Threat: Obtaining User Passwords on Transport",
      "section_title": true,
      "ja": "4.4.3.4。脅威：輸送上の入手ユーザー・パスワード"
    },
    {
      "indent": 3,
      "text": "An attacker could attempt to eavesdrop the transmission of end-user credentials with the grant type \"password\" between the client and server.",
      "ja": "攻撃者は、クライアントとサーバ間の許可タイプ「パスワード」をエンドユーザーの資格情報の送信を盗聴しようとする可能性があり。"
    },
    {
      "indent": 3,
      "text": "Impact: Disclosure of a single end-user's password.",
      "ja": "影響：シングルエンド・ユーザーのパスワードの開示。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Ensure confidentiality of requests (Section 5.1.1).",
      "ja": "O要求（セクション5.1.1）の機密性を確保。"
    },
    {
      "indent": 3,
      "text": "o Use alternative authentication means that do not require the sending of plaintext credentials over the wire (e.g., Hash-based Message Authentication Code).",
      "ja": "O線（例えば、ハッシュベースメッセージ認証コード）を介して、平文の資格情報の送信を必要としない代替的な認証手段を使用します。"
    },
    {
      "indent": 0,
      "text": "4.4.3.5. Threat: Obtaining User Passwords from Authorization Server Database",
      "ja": "4.4.3.5。脅威：認証サーバー・データベースから取得ユーザーパスワード"
    },
    {
      "indent": 3,
      "text": "An attacker may obtain valid username/password combinations from the authorization server's database by gaining access to the database or launching a SQL injection attack.",
      "ja": "攻撃者は、データベースにアクセスするか、SQLインジェクション攻撃を起動して認証サーバのデータベースから有効なユーザー名/パスワードの組み合わせを得ることができます。"
    },
    {
      "indent": 3,
      "text": "Impact: Disclosure of all username/password combinations. The impact may exceed the domain of the authorization server, since many users tend to use the same credentials on different services.",
      "ja": "影響：すべてのユーザー名/パスワードの組み合わせの開示。多くのユーザーが別のサービスに同じ資格情報を使用する傾向があるため影響は、認証サーバのドメインを超えてもよいです。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Enforce credential storage protection best practices (Section 5.1.4.1).",
      "ja": "O資格ストレージ保護のベストプラクティス（セクション5.1.4.1）を適用します。"
    },
    {
      "indent": 0,
      "text": "4.4.3.6. Threat: Online Guessing",
      "section_title": true,
      "ja": "4.4.3.6。脅威：オンライン推測"
    },
    {
      "indent": 3,
      "text": "An attacker may try to guess valid username/password combinations using the grant type \"password\".",
      "ja": "攻撃者は、補助金の種類「パスワード」を使用して、有効なユーザ名/パスワードの組み合わせを推測しようとするかもしれません。"
    },
    {
      "indent": 3,
      "text": "Impact: Revelation of a single username/password combination.",
      "ja": "影響：単一のユーザー名/パスワードの組み合わせの黙示録。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Utilize secure password policy (Section 5.1.4.2.1).",
      "ja": "O安全なパスワードポリシー（セクション5.1.4.2.1）を利用します。"
    },
    {
      "indent": 3,
      "text": "o Lock accounts (Section 5.1.4.2.3).",
      "ja": "Oロック（セクション5.1.4.2.3）を占めています。"
    },
    {
      "indent": 3,
      "text": "o Use tar pit (Section 5.1.4.2.4).",
      "ja": "Oタールピット（セクション5.1.4.2.4）を使用します。"
    },
    {
      "indent": 3,
      "text": "o Use CAPTCHAs (Section 5.1.4.2.5).",
      "ja": "Oを使用するCAPTCHAの（セクション5.1.4.2.5）。"
    },
    {
      "indent": 3,
      "text": "o Consider not using the grant type \"password\".",
      "ja": "O許可タイプ「パスワード」を使用していないことを検討してください。"
    },
    {
      "indent": 3,
      "text": "o Client authentication (see Section 5.2.3) will provide another authentication factor and thus hinder the attack.",
      "ja": "Oクライアント認証は（5.2.3項を参照）、別の認証要素を提供し、したがって、攻撃を妨げます。"
    },
    {
      "indent": 0,
      "text": "4.4.4. Client Credentials",
      "section_title": true,
      "ja": "4.4.4。クライアントの資格情報"
    },
    {
      "indent": 3,
      "text": "Client credentials (see [RFC6749], Section 3) consist of an identifier (not secret) combined with an additional means (such as a matching client secret) of authenticating a client. The threats to this grant type are similar to those described in Section 4.4.3.",
      "ja": "クライアントの資格情報（[RFC6749]を参照し、セクション3）は、クライアントを認証する（例えば、一致するクライアント秘密のような）追加の手段と組み合わせ識別子（秘密ではない）からなります。この助成金型への脅威は、セクション4.4.3で説明したものと同様です。"
    },
    {
      "indent": 0,
      "text": "4.5. Refreshing an Access Token",
      "section_title": true,
      "ja": "4.5。アクセストークンを更新"
    },
    {
      "indent": 0,
      "text": "4.5.1. Threat: Eavesdropping Refresh Tokens from Authorization Server",
      "section_title": true,
      "ja": "4.5.1。脅威：認証サーバからの盗聴のリフレッシュトークン"
    },
    {
      "indent": 3,
      "text": "An attacker may eavesdrop refresh tokens when they are transmitted from the authorization server to the client.",
      "ja": "彼らはクライアントに認証サーバから送信された場合、攻撃者は、リフレッシュトークンを盗聴することがあります。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o As per the core OAuth spec, the authorization servers must ensure that these transmissions are protected using transport-layer mechanisms such as TLS (see Section 5.1.1).",
      "ja": "OコアのOAuth仕様に従って、認可サーバは、これらの送信は、例えばTLS（セクション5.1.1を参照）のようなトランスポート層のメカニズムを使用して保護されていることを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If end-to-end confidentiality cannot be guaranteed, reducing scope (see Section 5.1.5.1) and expiry time (see Section 5.1.5.3) for issued access tokens can be used to reduce the damage in case of leaks.",
      "ja": "エンドツーエンドの機密性を保証できない場合は、O、スコープ（セクション5.1.5.1を参照）、発行されたアクセストークンの有効期限を（セクション5.1.5.3を参照）を低減することが漏洩した場合の被害を軽減するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Threat: Obtaining Refresh Token from Authorization Server Database",
      "ja": "4.5.2。脅威：認証サーバー・データベースから更新トークンを取得"
    },
    {
      "indent": 3,
      "text": "This threat is applicable if the authorization server stores refresh tokens as handles in a database. An attacker may obtain refresh tokens from the authorization server's database by gaining access to the database or launching a SQL injection attack.",
      "ja": "認証サーバーストアは、データベース内のハンドルとしてのトークンを更新した場合、この脅威は適用されます。攻撃者は、データベースにアクセスするか、SQLインジェクション攻撃を起動して認証サーバのデータベースからリフレッシュトークンを得ることができます。"
    },
    {
      "indent": 3,
      "text": "Impact: Disclosure of all refresh tokens.",
      "ja": "影響：すべてのリフレッシュトークンの開示。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Enforce credential storage protection best practices (Section 5.1.4.1).",
      "ja": "O資格ストレージ保護のベストプラクティス（セクション5.1.4.1）を適用します。"
    },
    {
      "indent": 3,
      "text": "o Bind token to client id, if the attacker cannot obtain the required id and secret (Section 5.1.5.8).",
      "ja": "OバインドトークンクライアントIDに、攻撃者は、必要なIDと秘密（セクション5.1.5.8）を得ることができない場合。"
    },
    {
      "indent": 0,
      "text": "4.5.3. Threat: Obtaining Refresh Token by Online Guessing",
      "section_title": true,
      "ja": "4.5.3。脅威：オンライン推測して更新トークンを取得"
    },
    {
      "indent": 3,
      "text": "An attacker may try to guess valid refresh token values and send it using the grant type \"refresh_token\" in order to obtain a valid access token.",
      "ja": "攻撃者は、有効なアクセストークンを取得するために「refresh_token」有効なリフレッシュトークン値を推測しようと助成金型を使用して、それを送信することができます。"
    },
    {
      "indent": 3,
      "text": "Impact: Exposure of a single refresh token and derivable access tokens.",
      "ja": "影響：単一リフレッシュトークンの暴露とアクセストークン導き出せます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o For handle-based designs (Section 5.1.4.2.2).",
      "ja": "ハンドルベースの設計のためにO（セクション5.1.4.2.2）。"
    },
    {
      "indent": 3,
      "text": "o For assertion-based designs (Section 5.1.5.9).",
      "ja": "アサーションベースの設計のためにO（セクション5.1.5.9）。"
    },
    {
      "indent": 3,
      "text": "o Bind token to client id, because the attacker would guess the matching client id, too (see Section 5.1.5.8).",
      "ja": "OバインドトークンクライアントIDに、攻撃者は（セクション5.1.5.8を参照）も、一致するクライアントIDを推測するので。"
    },
    {
      "indent": 3,
      "text": "o Authenticate the client; this adds another element that the attacker has to guess (see Section 5.2.3.4).",
      "ja": "Oクライアントを認証します。これは、攻撃者が推測している別の要素を追加します（セクション5.2.3.4を参照）。"
    },
    {
      "indent": 0,
      "text": "4.5.4. Threat: Refresh Token Phishing by Counterfeit Authorization Server",
      "ja": "4.5.4。脅威：偽造認証サーバによる更新トークンフィッシング"
    },
    {
      "indent": 3,
      "text": "An attacker could try to obtain valid refresh tokens by proxying requests to the authorization server. Given the assumption that the authorization server URL is well-known at development time or can at least be obtained from a well-known resource server, the attacker must utilize some kind of spoofing in order to succeed.",
      "ja": "攻撃者は、認証サーバへのリクエストをプロキシして、有効なリフレッシュトークンを取得しようとすることができます。認証サーバのURLは、開発時にはよく知られているか、少なくとも、よく知られたリソースサーバから取得することができるという仮定を考えると、攻撃者が成功するために、なりすましのいくつかの種類を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Utilize server authentication (as described in Section 5.1.2).",
      "ja": "（5.1.2項に記載されているように）Oサーバ認証を利用します。"
    },
    {
      "indent": 0,
      "text": "4.6. Accessing Protected Resources",
      "section_title": true,
      "ja": "4.6。保護されたリソースへのアクセス"
    },
    {
      "indent": 0,
      "text": "4.6.1. Threat: Eavesdropping Access Tokens on Transport",
      "section_title": true,
      "ja": "4.6.1。脅威：輸送上の盗聴アクセストークン"
    },
    {
      "indent": 3,
      "text": "An attacker could try to obtain a valid access token on transport between the client and resource server. As access tokens are shared secrets between the authorization server and resource server, they should be treated with the same care as other credentials (e.g., end-user passwords).",
      "ja": "攻撃者は、クライアントとサーバ間の資源輸送に有効なアクセストークンを取得しようとすることができます。アクセストークンは、認証サーバとリソースサーバとの間の秘密を共有しているように、それらは他の認証情報（例えば、エンドユーザパスワード）と同じ注意して扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Access tokens sent as bearer tokens should not be sent in the clear over an insecure channel. As per the core OAuth spec, transmission of access tokens must be protected using transport-layer mechanisms such as TLS (see Section 5.1.1).",
      "ja": "Oベアラトークンとして送信されたアクセストークンは、安全でないチャネルを介して平文で送信されるべきではありません。コアOAuthの仕様に従って、アクセストークンの送信は、TLS（セクション5.1.1を参照）のようなトランスポート層のメカニズムを使用して保護されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A short lifetime reduces impact in case tokens are compromised (see Section 5.1.5.3).",
      "ja": "短い寿命O（セクション5.1.5.3を参照）トークンが損なわれている場合に影響を低減します。"
    },
    {
      "indent": 3,
      "text": "o The access token can be bound to a client's identifier and require the client to prove legitimate ownership of the token to the resource server (see Section 5.4.2).",
      "ja": "アクセストークンは、クライアントの識別子にバインドされ、リソースサーバーへのトークンの正当な所有権を証明するために、クライアントを必要とすることができますO（5.4.2項を参照してください）。"
    },
    {
      "indent": 0,
      "text": "4.6.2. Threat: Replay of Authorized Resource Server Requests",
      "section_title": true,
      "ja": "4.6.2。脅威：認可リソースサーバー要求のリプレイ"
    },
    {
      "indent": 3,
      "text": "An attacker could attempt to replay valid requests in order to obtain or to modify/destroy user data.",
      "ja": "攻撃者は、ユーザーのデータを取得するか、破壊/修正するために有効な要求を再生しようとする可能性があり。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o The resource server should utilize transport security measures (e.g., TLS) in order to prevent such attacks (see Section 5.1.1). This would prevent the attacker from capturing valid requests.",
      "ja": "Oリソースサーバがそのような攻撃を防ぐために、トランスポート・セキュリティ対策（例えば、TLS）を利用しなければならない（5.1.1項を参照してください）。これは有効な要求をキャプチャからの攻撃を防止するであろう。"
    },
    {
      "indent": 3,
      "text": "o Alternatively, the resource server could employ signed requests (see Section 5.4.3) along with nonces and timestamps in order to uniquely identify requests. The resource server should detect and refuse every replayed request.",
      "ja": "Oあるいは、リソースサーバは一意の要求を識別するためにノンスと、タイムスタンプと一緒に署名された要求（セクション5.4.3を参照）を使用することができました。リソースサーバを検出し、すべての再生の要求を拒否しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.6.3. Threat: Guessing Access Tokens",
      "section_title": true,
      "ja": "4.6.3。脅威：推測アクセストークン"
    },
    {
      "indent": 3,
      "text": "Where the token is a handle, the attacker may attempt to guess the access token values based on knowledge they have from other access tokens.",
      "ja": "トークンがハンドルである場合、攻撃者は、他のアクセストークンから、彼らが持っている知識に基づいてアクセストークン値を推測しようとすることができます。"
    },
    {
      "indent": 3,
      "text": "Impact: Access to a single user's data.",
      "ja": "影響：シングルユーザーのデータへのアクセス。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Handle tokens should have a reasonable level of entropy (see Section 5.1.4.2.2) in order to make guessing a valid token value infeasible.",
      "ja": "Oハンドルトークンはエントロピーの合理的なレベルを持っている必要があり実現不可能な有効なトークン値を推測させるためには（セクション5.1.4.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "o Assertion (or self-contained token) token contents should be protected by a digital signature (see Section 5.1.5.9).",
      "ja": "Oアサーション（または自己完結型のトークン）トークン内容（セクション5.1.5.9を参照）は、デジタル署名によって保護されるべきです。"
    },
    {
      "indent": 3,
      "text": "o Security can be further strengthened by using a short access token duration (see Sections 5.1.5.2 and 5.1.5.3).",
      "ja": "Oセキュリティはさらに（セクション5.1.5.2と5.1.5.3を参照）、短いアクセストークンの期間を使用することによって強化することができます。"
    },
    {
      "indent": 0,
      "text": "4.6.4. Threat: Access Token Phishing by Counterfeit Resource Server",
      "section_title": true,
      "ja": "4.6.4。脅威：偽造リソースサーバによるアクセストークンフィッシング"
    },
    {
      "indent": 3,
      "text": "An attacker may pretend to be a particular resource server and to accept tokens from a particular authorization server. If the client sends a valid access token to this counterfeit resource server, the server in turn may use that token to access other services on behalf of the resource owner.",
      "ja": "攻撃者は、特定のリソース・サーバであること、および特定の認証サーバからトークンを受け入れることをふりをします。クライアントは、この偽造リソースサーバーへの有効なアクセストークンを送信した場合、ターン内のサーバーは、リソースの所有者に代わって他のサービスにアクセスするために、そのトークンを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Clients should not make authenticated requests with an access token to unfamiliar resource servers, regardless of the presence of a secure channel. If the resource server URL is well-known to the client, it may authenticate the resource servers (see Section 5.1.2).",
      "ja": "Oクライアントは関係なく、安全なチャネルの存在の、不慣れなリソースサーバーへのアクセストークンで認証要求を行うべきではありません。リソースサーバのURLをクライアントによく知られている場合、それは（5.1.2項を参照）リソースサーバを認証することができます。"
    },
    {
      "indent": 3,
      "text": "o Associate the endpoint URL of the resource server the client talked to with the access token (e.g., in an audience field) and validate the association at a legitimate resource server. The endpoint URL validation policy may be strict (exact match) or more relaxed (e.g., same host). This would require telling the authorization server about the resource server endpoint URL in the authorization process.",
      "ja": "Oクライアントが（観客の分野で、例えば、）アクセストークンを持つに話を聞いたリソースサーバのエンドポイントURLを関連付け、正当なリソースサーバでの関連を検証します。エンドポイントURLの検証ポリシーは、厳密な（正確な一致）または（例えば、同じホスト）より緩和することができます。これは、承認プロセスにおける資源・サーバーのエンドポイントURLについての認証サーバを伝える必要になります。"
    },
    {
      "indent": 3,
      "text": "o Associate an access token with a client and authenticate the client with resource server requests (typically via a signature, in order to not disclose a secret to a potential attacker). This prevents the attack because the counterfeit server is assumed to lack the capability to correctly authenticate on behalf of the legitimate client to the resource server (Section 5.4.2).",
      "ja": "Oクライアントとアクセストークンを関連付け、（潜在的な攻撃者に秘密を開示していないために、通常の署名を経て）リソースサーバ要求にクライアントを認証。偽造サーバーが正しくリソースサーバ（5.4.2）への正当なクライアントの代わりに認証する能力が欠けていると想定されるので、これは攻撃を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "o Restrict the token scope (see Section 5.1.5.1) and/or limit the token to a certain resource server (Section 5.1.5.5).",
      "ja": "Oトークン範囲を制限（セクション5.1.5.1を参照）、および/または特定のリソースサーバ（セクション5.1.5.5）にトークンを制限します。"
    },
    {
      "indent": 0,
      "text": "4.6.5. Threat: Abuse of Token by Legitimate Resource Server or Client",
      "section_title": true,
      "ja": "4.6.5。脅威：正当なリソースのサーバーまたはクライアントによってトークンの乱用"
    },
    {
      "indent": 3,
      "text": "A legitimate resource server could attempt to use an access token to access another resource server. Similarly, a client could try to use a token obtained for one server on another resource server.",
      "ja": "正当なリソースサーバは、他のリソースサーバーにアクセスするためのアクセストークンを使用しようとすることができます。同様に、クライアントは、別のリソースサーバー上の1台のサーバに対して得られたトークンを使用しようとすることができます。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Tokens should be restricted to particular resource servers (see Section 5.1.5.5).",
      "ja": "Oトークンは、特定のリソースサーバ（セクション5.1.5.5を参照）に制限する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.6. Threat: Leak of Confidential Data in HTTP Proxies",
      "section_title": true,
      "ja": "4.6.6。脅威：HTTPプロキシでの機密データの漏洩"
    },
    {
      "indent": 3,
      "text": "An OAuth HTTP authentication scheme as discussed in [RFC6749] is optional. However, [RFC2616] relies on the Authorization and WWW-Authenticate headers to distinguish authenticated content so that it can be protected. Proxies and caches, in particular, may fail to adequately protect requests not using these headers. For example, private authenticated content may be stored in (and thus be retrievable from) publicly accessible caches.",
      "ja": "[RFC6749]で議論するようにOAuthのHTTP認証方式は任意です。しかしながら、[RFC2616]は、それが保護することができるように認証されたコンテンツを区別するために認可およびWWW認証ヘッダに依存しています。プロキシやキャッシュは、具体的には、適切にこれらのヘッダを使用していない要求を保護するために失敗することがあります。例えば、プライベート認証内容はに格納されている（したがってから検索可能）公的にアクセス可能なキャッシュされてもよいです。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Clients and resource servers not using an OAuth HTTP authentication scheme (see Section 5.4.1) should take care to use Cache-Control headers to minimize the risk that authenticated content is not protected. Such clients should send a Cache-Control header containing the \"no-store\" option [RFC2616]. Resource server success (2XX status) responses to these requests should contain a Cache-Control header with the \"private\" option [RFC2616].",
      "ja": "O OAuthのHTTP認証スキームを使用していないクライアントとリソースサーバは、（5.4.1項を参照）、コンテンツが保護されていない認証済みのリスクを最小限に抑えるためのCache-Controlヘッダーを使用するように注意する必要があります。そのようなクライアントは、「非保存」オプション[RFC2616]を含むキャッシュ制御ヘッダを送信する必要があります。リソースサーバーの成功（2XXステータス）これらの要求に対する応答は、「プライベート」オプション[RFC2616]でのCache-Controlヘッダーを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o Reducing scope (see Section 5.1.5.1) and expiry time (Section 5.1.5.3) for access tokens can be used to reduce the damage in case of leaks.",
      "ja": "アクセストークンの範囲（セクション5.1.5.1を参照）、有効期限（セクション5.1.5.3）を低減oを漏れの場合の損傷を低減するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.6.7. Threat: Token Leakage via Log Files and HTTP Referrers",
      "section_title": true,
      "ja": "4.6.7。脅威：ログファイルとHTTPリファラーを介したトークン漏れ"
    },
    {
      "indent": 3,
      "text": "If access tokens are sent via URI query parameters, such tokens may leak to log files and the HTTP \"referer\".",
      "ja": "アクセストークンは、URIクエリパラメータを経由して送信された場合、そのようなトークンは、ファイルやHTTP「リファラ」をログに記録する漏れることがあります。"
    },
    {
      "indent": 3,
      "text": "Countermeasures:",
      "ja": "対策："
    },
    {
      "indent": 3,
      "text": "o Use Authorization headers or POST parameters instead of URI request parameters (see Section 5.4.1).",
      "ja": "使用許可ヘッダーまたはPOSTパラメータの代わりに、URI要求パラメータO（セクション5.4.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o Set logging configuration appropriately.",
      "ja": "O適切ログ構成を設定します。"
    },
    {
      "indent": 3,
      "text": "o Prevent unauthorized persons from access to system log files (see Section 5.1.4.1.1).",
      "ja": "Oを防ぐには、システムログファイルへのアクセス、許可されていない人（セクション5.1.4.1.1を参照します）。"
    },
    {
      "indent": 3,
      "text": "o Abuse of leaked access tokens can be prevented by enforcing authenticated requests (see Section 5.4.2).",
      "ja": "漏洩したアクセストークンのO乱用が認証要求を強制することによって防止することができる（5.4.2項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "o The impact of token leakage may be reduced by limiting scope (see Section 5.1.5.1) and duration (see Section 5.1.5.3) and by enforcing one-time token usage (see Section 5.1.5.4).",
      "ja": "トークン漏れの影響が範囲を制限することによって低減することができるoおよび持続時間（セクション5.1.5.3を参照）、ワンタイムトークンの使用を強制することによって（セクション5.1.5.4を参照）（セクション5.1.5.1を参照）。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This section describes the countermeasures as recommended to mitigate the threats described in Section 4.",
      "ja": "このセクションでは、第4章で説明した脅威を軽減するために推奨されているように対策を説明しています。"
    },
    {
      "indent": 0,
      "text": "5.1. General",
      "section_title": true,
      "ja": "5.1。一般的な"
    },
    {
      "indent": 3,
      "text": "This section covers considerations that apply generally across all OAuth components (client, resource server, token server, and user agents).",
      "ja": "このセクションでは、すべてのOAuthのコンポーネント（クライアント、リソースサーバ、トークンサーバ、およびユーザエージェント）間で一般的に適用する考慮事項をカバーしています。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Ensure Confidentiality of Requests",
      "section_title": true,
      "ja": "5.1.1。要求の機密性を確保"
    },
    {
      "indent": 3,
      "text": "This is applicable to all requests sent from the client to the authorization server or resource server. While OAuth provides a mechanism for verifying the integrity of requests, it provides no guarantee of request confidentiality. Unless further precautions are taken, eavesdroppers will have full access to request content and may be able to mount interception or replay attacks by using the contents of requests, e.g., secrets or tokens.",
      "ja": "これは、認証サーバやリソースクライアントからサーバに送信されるすべての要求に適用されます。 OAuthのは、要求の整合性を検証するためのメカニズムを提供していますが、それはリクエストの機密性の保証を提供していません。さらに予防措置が取られない限り、盗聴者は、要求内容へのフルアクセスを持つことになりますし、要求、例えば、秘密またはトークンの内容を使用することによって傍受またはリプレイ攻撃をマウントすることができるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Attacks can be mitigated by using transport-layer mechanisms such as TLS [RFC5246]. A virtual private network (VPN), e.g., based on IPsec VPNs [RFC4301], may be considered as well.",
      "ja": "攻撃は、TLS [RFC5246]などのトランスポート層のメカニズムを使用することによって軽減することができます。仮想プライベートネットワーク（VPN）は、例えば、のIPsec VPNの[RFC4301]に基づいて、同様に考えることができます。"
    },
    {
      "indent": 3,
      "text": "Note: This document assumes end-to-end TLS protected connections between the respective protocol entities. Deployments deviating from this assumption by offloading TLS in between (e.g., on the data center edge) must refine this threat model in order to account for the additional (mainly insider) threat this may cause.",
      "ja": "注意：この文書は、それぞれのプロトコルエンティティ間のエンドツーエンドのTLS保護された接続を前提としています。 （例えば、データセンターのエッジ上の）との間でTLSをオフロードすることによって、この仮定から逸脱展開は、これが原因となり、追加の（主にインサイダー）脅威を考慮するために、この脅威モデルを改良しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This is a countermeasure against the following threats:",
      "ja": "これは、以下の脅威への対策です。"
    },
    {
      "indent": 3,
      "text": "o Replay of access tokens obtained on the token's endpoint or the resource server's endpoint",
      "ja": "アクセストークンのエンドポイントで得られたトークンまたはリソースサーバーのエンドポイントのリプレイO"
    },
    {
      "indent": 3,
      "text": "o Replay of refresh tokens obtained on the token's endpoint o Replay of authorization \"codes\" obtained on the token's endpoint (redirect?)",
      "ja": "Oトークンのエンドポイントに得承認「コード」のリプレイOトークンのエンドポイントで取得したリフレッシュトークンのリプレイは、（リダイレクト？）"
    },
    {
      "indent": 3,
      "text": "o Replay of user passwords and client secrets",
      "ja": "ユーザパスワードとクライアントの秘密のOリプレイ"
    },
    {
      "indent": 0,
      "text": "5.1.2. Utilize Server Authentication",
      "section_title": true,
      "ja": "5.1.2。サーバ認証を利用"
    },
    {
      "indent": 3,
      "text": "HTTPS server authentication or similar means can be used to authenticate the identity of a server. The goal is to reliably bind the fully qualified domain name of the server to the public key presented by the server during connection establishment (see [RFC2818]).",
      "ja": "HTTPSサーバ認証または類似の手段は、サーバーのIDを認証するために使用することができます。目標は、確実に接続確立（[RFC2818]を参照）中にサーバーによって提示された公開鍵にサーバーの完全修飾ドメイン名をバインドすることです。"
    },
    {
      "indent": 3,
      "text": "The client should validate the binding of the server to its domain name. If the server fails to prove that binding, the communication is considered a man-in-the-middle attack. This security measure depends on the certification authorities the client trusts for that purpose. Clients should carefully select those trusted CAs and protect the storage for trusted CA certificates from modifications.",
      "ja": "クライアントは、そのドメイン名にサーバーの結合を検証する必要があります。サーバが結合することを証明するために失敗した場合、通信はman-in-the-middle攻撃と考えられています。このセキュリティ対策は、その目的のために証明機関のクライアントが信頼に依存します。クライアントは慎重にそれらの信頼できるCAを選択し、変更から信頼されたCA証明書の保管を保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "This is a countermeasure against the following threats:",
      "ja": "これは、以下の脅威への対策です。"
    },
    {
      "indent": 3,
      "text": "o Spoofing",
      "ja": "なりすましO"
    },
    {
      "indent": 3,
      "text": "o Proxying",
      "ja": "プロキシO"
    },
    {
      "indent": 3,
      "text": "o Phishing by counterfeit servers",
      "ja": "偽造・サーバによってフィッシングO"
    },
    {
      "indent": 0,
      "text": "5.1.3. Always Keep the Resource Owner Informed",
      "section_title": true,
      "ja": "5.1.3。常にリソースの所有者に通知してください"
    },
    {
      "indent": 3,
      "text": "Transparency to the resource owner is a key element of the OAuth protocol. The user should always be in control of the authorization processes and get the necessary information to make informed decisions. Moreover, user involvement is a further security countermeasure. The user can probably recognize certain kinds of attacks better than the authorization server. Information can be presented/exchanged during the authorization process, after the authorization process, and every time the user wishes to get informed by using techniques such as:",
      "ja": "リソースの所有者への透明性は、OAuthプロトコルの重要な要素です。ユーザーは常に、認可プロセスの制御になると、情報に基づいた意思決定を行うために必要な情報を取得する必要があります。また、ユーザの関与は、さらにセキュリティ対策です。ユーザーは、おそらく許可サーバよりも優れた攻撃の特定の種類を認識することができます。情報を提示することができます/承認プロセスの後、承認プロセス中に交換し、毎回ユーザーは、次のような技術を使用して通知を取得することを希望します："
    },
    {
      "indent": 3,
      "text": "o User consent forms.",
      "ja": "Oユーザーの同意書。"
    },
    {
      "indent": 3,
      "text": "o Notification messages (e.g., email, SMS, ...). Note that notifications can be a phishing vector. Messages should be such that look-alike phishing messages cannot be derived from them.",
      "ja": "O通知メッセージ（例えば、電子メール、SMS、...）。通知はフィッシングベクターであり得ることに注意してください。メッセージはそっくりフィッシングメッセージがそれらに由来することができないようなものであるべきです。"
    },
    {
      "indent": 3,
      "text": "o Activity/event logs.",
      "ja": "Oアクティビティ/イベントログ。"
    },
    {
      "indent": 3,
      "text": "o User self-care applications or portals.",
      "ja": "Oユーザーセルフケアアプリケーションやポータル。"
    },
    {
      "indent": 0,
      "text": "5.1.4. Credentials",
      "section_title": true,
      "ja": "5.1.4。資格情報"
    },
    {
      "indent": 3,
      "text": "This section describes countermeasures used to protect all kinds of credentials from unauthorized access and abuse. Credentials are long-term secrets, such as client secrets and user passwords as well as all kinds of tokens (refresh and access tokens) or authorization \"codes\".",
      "ja": "このセクションでは、不正なアクセスや虐待からの資格情報のすべての種類を保護するために使用さ対策について説明します。資格情報は、長期的なクライアントの秘密やユーザーパスワードなどの秘密だけでなく、トークン（リフレッシュとアクセストークン）または認可「コード」のすべての種類があります。"
    },
    {
      "indent": 0,
      "text": "5.1.4.1. Enforce Credential Storage Protection Best Practices",
      "section_title": true,
      "ja": "5.1.4.1。資格ストレージの保護のベストプラクティスを適用します"
    },
    {
      "indent": 3,
      "text": "Administrators should undertake industry best practices to protect the storage of credentials (for example, see [OWASP]). Such practices may include but are not limited to the following sub-sections.",
      "ja": "管理者は、（例えば、[OWASP]参照）の資格情報のストレージを保護するために、業界のベストプラクティスを引き受けるべきです。そのような慣行は含むことができるが、以下のサブセクションに限定されません。"
    },
    {
      "indent": 0,
      "text": "5.1.4.1.1. Enforce Standard System Security Means",
      "section_title": true,
      "ja": "5.1.4.1.1。標準システムのセキュリティ手段を強制します"
    },
    {
      "indent": 3,
      "text": "A server system may be locked down so that no attacker may get access to sensitive configuration files and databases.",
      "ja": "何の攻撃者が機密の構成ファイルとデータベースへのアクセスを取得しないことができるように、サーバーシステムがロックダウンすることができます。"
    },
    {
      "indent": 0,
      "text": "5.1.4.1.2. Enforce Standard SQL Injection Countermeasures",
      "section_title": true,
      "ja": "5.1.4.1.2。標準的なSQLインジェクション対策を強制します"
    },
    {
      "indent": 3,
      "text": "If a client identifier or other authentication component is queried or compared against a SQL database, it may become possible for an injection attack to occur if parameters received are not validated before submission to the database.",
      "ja": "クライアント識別子または他の認証コンポーネントは、照会またはSQLデータベースと比較された場合に受信されたパラメータは、データベースへの提出前に検証されていない場合にインジェクション攻撃が発生することが可能になることができます。"
    },
    {
      "indent": 3,
      "text": "o Ensure that server code is using the minimum database privileges possible to reduce the \"surface\" of possible attacks.",
      "ja": "O可能な攻撃の「表面」を低減させることができる最小データベース権限を使用しているサーバーのコードを確認してください。"
    },
    {
      "indent": 3,
      "text": "o Avoid dynamic SQL using concatenated input. If possible, use static SQL.",
      "ja": "O連結入力を使用して動的SQLを避けてください。可能であれば、静的SQLを使用します。"
    },
    {
      "indent": 3,
      "text": "o When using dynamic SQL, parameterize queries using bind arguments. Bind arguments eliminate the possibility of SQL injections.",
      "ja": "動的SQLを使用する場合は、O、バインド引数を使用してクエリをパラメータ化。バインド引数は、SQLインジェクションの可能性を排除します。"
    },
    {
      "indent": 3,
      "text": "o Filter and sanitize the input. For example, if an identifier has a known format, ensure that the supplied value matches the identifier syntax rules.",
      "ja": "Oフィルタや入力をサニタイズ。識別子が既知のフォーマットを有する場合、例えば、供給された値は、識別子の構文規則に一致することを保証します。"
    },
    {
      "indent": 0,
      "text": "5.1.4.1.3. No Cleartext Storage of Credentials",
      "section_title": true,
      "ja": "5.1.4.1.3。資格情報のクリアテキストストレージいいえ"
    },
    {
      "indent": 3,
      "text": "The authorization server should not store credentials in clear text. Typical approaches are to store hashes instead or to encrypt credentials. If the credential lacks a reasonable entropy level (because it is a user password), an additional salt will harden the storage to make offline dictionary attacks more difficult.",
      "ja": "認証サーバは、クリアテキストで資格情報を保存しないでください。典型的なアプローチではなく、ハッシュを格納するか、資格情報を暗号化することです。資格は、（それがユーザーのパスワードであるため）、合理的なエントロピーレベルを欠いている場合、追加の塩は、オフライン辞書攻撃をより困難にするためにストレージを強化します。"
    },
    {
      "indent": 3,
      "text": "Note: Some authentication protocols require the authorization server to have access to the secret in the clear. Those protocols cannot be implemented if the server only has access to hashes. Credentials should be strongly encrypted in those cases.",
      "ja": "注：一部の認証プロトコルが明らかに秘密にアクセスすることが認証サーバが必要です。サーバーが唯一のハッシュへのアクセス権を持っている場合、これらのプロトコルを実装することができません。資格情報は強く、それらの例には、暗号化されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.4.1.4. Encryption of Credentials",
      "section_title": true,
      "ja": "5.1.4.1.4。資格情報の暗号化"
    },
    {
      "indent": 3,
      "text": "For client applications, insecurely persisted client credentials are easy targets for attackers to obtain. Store client credentials using an encrypted persistence mechanism such as a keystore or database. Note that compiling client credentials directly into client code makes client applications vulnerable to scanning as well as difficult to administer should client credentials change over time.",
      "ja": "クライアントアプリケーションでは、安全でないクライアントの資格情報は、攻撃者が取得するための簡単なターゲットである持続しました。このようストアやデータベースなどの暗号化された永続化メカニズムを使用してストアクライアントの資格情報。クライアントの資格情報は、時間の経過とともに変化する必要があり、直接クライアントコードにクライアントの資格情報をコンパイルすると、管理するクライアントアプリケーションがスキャンに弱いだけでなく、困難にしていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.1.4.1.5. Use of Asymmetric Cryptography",
      "section_title": true,
      "ja": "5.1.4.1.5。非対称暗号の使用"
    },
    {
      "indent": 3,
      "text": "Usage of asymmetric cryptography will free the authorization server of the obligation to manage credentials.",
      "ja": "非対称暗号の使用法は、資格情報を管理する義務の認証サーバを解放します。"
    },
    {
      "indent": 0,
      "text": "5.1.4.2. Online Attacks on Secrets",
      "section_title": true,
      "ja": "5.1.4.2。秘密のオンライン攻撃"
    },
    {
      "indent": 0,
      "text": "5.1.4.2.1. Utilize Secure Password Policy",
      "section_title": true,
      "ja": "5.1.4.2.1。セキュリティで保護されたパスワードポリシーを活用"
    },
    {
      "indent": 3,
      "text": "The authorization server may decide to enforce a complex user password policy in order to increase the user passwords' entropy to hinder online password attacks. Note that too much complexity can increase the likelihood that users re-use passwords or write them down, or otherwise store them insecurely.",
      "ja": "認証サーバは、オンラインのパスワード攻撃を妨げるために、ユーザのパスワードエントロピーを増大させるために、複雑なユーザパスワードポリシーを強制することもできます。あまりにも多くの複雑さは、ユーザーがパスワードを再利用可能性を高めるか、それらを書き留め、またはその他のセキュアでないそれらを格納できることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.1.4.2.2. Use High Entropy for Secrets",
      "section_title": true,
      "ja": "5.1.4.2.2。秘密のためのハイエントロピーを使用します"
    },
    {
      "indent": 3,
      "text": "When creating secrets not intended for usage by human users (e.g., client secrets or token handles), the authorization server should include a reasonable level of entropy in order to mitigate the risk of guessing attacks. The token value should be >=128 bits long and constructed from a cryptographically strong random or pseudo-random number sequence (see [RFC4086] for best current practice) generated by the authorization server.",
      "ja": "人間のユーザ（例えば、クライアントの秘密またはトークンハンドル）による使用のために意図されていない秘密を作成する場合、認証サーバは、推測攻撃のリスクを軽減するために、エントロピーの合理的なレベルを含める必要があります。トークン値は> = 128ビット長と暗号強いランダムまたは擬似乱数列から構成されるべきである認証サーバによって生成された（最良の現在の実務のために[RFC4086]を参照）。"
    },
    {
      "indent": 0,
      "text": "5.1.4.2.3. Lock Accounts",
      "section_title": true,
      "ja": "5.1.4.2.3。ロックアカウント"
    },
    {
      "indent": 3,
      "text": "Online attacks on passwords can be mitigated by locking the respective accounts after a certain number of failed attempts.",
      "ja": "パスワードのオンライン攻撃は失敗した特定の数の後に、それぞれのアカウントをロックすることによって軽減することができます。"
    },
    {
      "indent": 3,
      "text": "Note: This measure can be abused to lock down legitimate service users.",
      "ja": "注意：この措置は、正当なサービスのユーザーをロックダウンするために悪用される可能性が。"
    },
    {
      "indent": 0,
      "text": "5.1.4.2.4. Use Tar Pit",
      "section_title": true,
      "ja": "5.1.4.2.4。彼女のワイヤピット"
    },
    {
      "indent": 3,
      "text": "The authorization server may react on failed attempts to authenticate by username/password by temporarily locking the respective account and delaying the response for a certain duration. This duration may increase with the number of failed attempts. The objective is to slow the attacker's attempts on a certain username down.",
      "ja": "認証サーバは、一時的に、それぞれのアカウントをロックし、一定の期間のための応答を遅延させることにより、ユーザ名/パスワードでの認証に失敗した試みに反応することができます。この期間は、失敗した試行回数を増やすことがあります。目的は、特定のユーザ名ダウンに攻撃者の試みを遅くすることです。"
    },
    {
      "indent": 3,
      "text": "Note: This may require a more complex and stateful design of the authorization server.",
      "ja": "注：これは、認証サーバーのより複雑でステートフルな設計が必要な場合があります。"
    },
    {
      "indent": 0,
      "text": "5.1.4.2.5. Use CAPTCHAs",
      "section_title": true,
      "ja": "5.1.4.2.5。使用CAPTCHAの"
    },
    {
      "indent": 3,
      "text": "The idea is to prevent programs from automatically checking a huge number of passwords, by requiring human interaction.",
      "ja": "アイデアは、人間の相互作用を必要とすることによって、自動的にパスワードの膨大な数をチェックからプログラムを防ぐためです。"
    },
    {
      "indent": 3,
      "text": "Note: This has a negative impact on user experience.",
      "ja": "注意：これは、ユーザーエクスペリエンスにマイナスの影響を与えています。"
    },
    {
      "indent": 0,
      "text": "5.1.5. Tokens (Access, Refresh, Code)",
      "section_title": true,
      "ja": "5.1.5。トークン（アクセス、更新、コード）"
    },
    {
      "indent": 0,
      "text": "5.1.5.1. Limit Token Scope",
      "section_title": true,
      "ja": "5.1.5.1。トークンの範囲を限定"
    },
    {
      "indent": 3,
      "text": "The authorization server may decide to reduce or limit the scope associated with a token. The basis of this decision is out of scope; examples are:",
      "ja": "認証サーバは、軽減またはトークンに関連付けられている範囲を限定することもできます。この決定の根拠は、適用範囲外です。例は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o a client-specific policy, e.g., issue only less powerful tokens to public clients,",
      "ja": "Oクライアント固有のポリシー、例えば、公共のクライアントへの問題だけでそれほど強力トークン、"
    },
    {
      "indent": 3,
      "text": "o a service-specific policy, e.g., it is a very sensitive service,",
      "ja": "Oサービス固有のポリシーは、例えば、それは非常に敏感なサービスがあり、"
    },
    {
      "indent": 3,
      "text": "o a resource-owner-specific setting, or",
      "ja": "リソース所有者固有設定O、又は"
    },
    {
      "indent": 3,
      "text": "o combinations of such policies and preferences.",
      "ja": "そのような政策や好みのOの組み合わせ。"
    },
    {
      "indent": 3,
      "text": "The authorization server may allow different scopes dependent on the grant type. For example, end-user authorization via direct interaction with the end user (authorization \"code\") might be considered more reliable than direct authorization via grant type \"username\"/\"password\". This means will reduce the impact of the following threats:",
      "ja": "認証サーバは、許可タイプの異なるスコープに依存できるようにします。例えば、エンドユーザー（認証「コード」）との直接的な相互作用を介したエンドユーザーの許可が許可タイプ「ユーザ名」/「パスワード」を経由して直接認証よりも信頼性が高いと考えられるかもしれません。これは、以下の脅威の影響を減らすことを意味します："
    },
    {
      "indent": 3,
      "text": "o token leakage",
      "ja": "Oトークン漏れ"
    },
    {
      "indent": 3,
      "text": "o token issuance to malicious software",
      "ja": "悪意のあるソフトウェアにOトークンの発行"
    },
    {
      "indent": 3,
      "text": "o unintended issuance of powerful tokens with resource owner credentials flow",
      "ja": "リソースの所有者の資格情報を持つ強力なトークンのO意図しない発行流れ"
    },
    {
      "indent": 0,
      "text": "5.1.5.2. Determine Expiration Time",
      "section_title": true,
      "ja": "5.1.5.2。有効期限を決定します"
    },
    {
      "indent": 3,
      "text": "Tokens should generally expire after a reasonable duration. This complements and strengthens other security measures (such as signatures) and reduces the impact of all kinds of token leaks. Depending on the risk associated with token leakage, tokens may expire after a few minutes (e.g., for payment transactions) or stay valid for hours (e.g., read access to contacts).",
      "ja": "トークンは、一般的に合理的な期間の後に期限切れにする必要があります。これは補完し（例えば、署名のような）他のセキュリティ対策を強化し、トークン漏れのすべての種類の影響を低減します。トークン漏れに関連するリスクに応じて、トークンの有効期限が切れて、数分後に（例えば、支払取引のために）、または（例えば、連絡先へのアクセスを読んで）時間有効のまま。"
    },
    {
      "indent": 3,
      "text": "The expiration time is determined by several factors, including:",
      "ja": "有効期限は、以下を含むいくつかの要因によって決定されます。"
    },
    {
      "indent": 3,
      "text": "o risk associated with token leakage,",
      "ja": "Oリスクは、トークン漏れに関連しました、"
    },
    {
      "indent": 3,
      "text": "o duration of the underlying access grant,",
      "ja": "基礎となるアクセス許可のO期間、"
    },
    {
      "indent": 3,
      "text": "o duration until the modification of an access grant should take effect, and",
      "ja": "Oアクセス許可の変更までの期間が効果を取るべきである、と"
    },
    {
      "indent": 3,
      "text": "o time required for an attacker to guess or produce a valid token.",
      "ja": "O時間は推測するか、有効なトークンを生成するために、攻撃者のために必要。"
    },
    {
      "indent": 0,
      "text": "5.1.5.3. Use Short Expiration Time",
      "section_title": true,
      "ja": "5.1.5.3。短い有効期限を使用します"
    },
    {
      "indent": 3,
      "text": "A short expiration time for tokens is a means of protection against the following threats:",
      "ja": "トークンの短い有効期限は以下の脅威に対する保護の手段です。"
    },
    {
      "indent": 3,
      "text": "o replay",
      "ja": "O再生"
    },
    {
      "indent": 3,
      "text": "o token leak (a short expiration time will reduce impact)",
      "ja": "Oトークンリーク（短い満了時間が影響を減少させます）"
    },
    {
      "indent": 3,
      "text": "o online guessing (a short expiration time will reduce the likelihood of success)",
      "ja": "Oオンライン推測（短い有効期限は、成功の可能性を減らします）"
    },
    {
      "indent": 3,
      "text": "Note: Short token duration requires more precise clock synchronization between the authorization server and resource server. Furthermore, shorter duration may require more token refreshes (access token) or repeated end-user authorization processes (authorization \"code\" and refresh token).",
      "ja": "注意：ショートトークンの期間は、認証サーバーとリソースサーバーの間のより正確なクロック同期を必要とします。さらに、より短い期間はよりトークンリフレッシュ（アクセストークン）または反復エンドユーザ認証プロセスが必要（許可「コード」とトークン更新）してもよいです。"
    },
    {
      "indent": 0,
      "text": "5.1.5.4. Limit Number of Usages or One-Time Usage",
      "section_title": true,
      "ja": "5.1.5.4。用途の制限数やワンタイム使い方"
    },
    {
      "indent": 3,
      "text": "The authorization server may restrict the number of requests or operations that can be performed with a certain token. This mechanism can be used to mitigate the following threats:",
      "ja": "認証サーバは、特定のトークンを用いて行うことができる要求または操作の数を制限することができます。このメカニズムは、以下の脅威を軽減するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "o replay of tokens",
      "ja": "トークンのOリプレイ"
    },
    {
      "indent": 3,
      "text": "o guessing",
      "ja": "O推測"
    },
    {
      "indent": 3,
      "text": "For example, if an authorization server observes more than one attempt to redeem an authorization \"code\", the authorization server may want to revoke all access tokens granted based on the authorization \"code\" as well as reject the current request.",
      "ja": "認証サーバが認証「コード」を償還する複数の試みを観察した場合、認証サーバは、認証「コード」に基づくだけでなく、現在の要求を拒否付与されたすべてのアクセストークンを取り消す場合があります。"
    },
    {
      "indent": 3,
      "text": "As with the authorization \"code\", access tokens may also have a limited number of operations. This either forces client applications to re-authenticate and use a refresh token to obtain a fresh access token, or forces the client to re-authorize the access token by involving the user.",
      "ja": "認証「コード」と同様に、アクセストークンも、限られた数の操作を有することができます。このどちらかの勢力クライアント・アプリケーションは、再認証、新鮮なアクセストークンを取得するためにリフレッシュトークンを使用し、または使用者が関与することにより、アクセストークンを再認証するクライアントを強制します。"
    },
    {
      "indent": 0,
      "text": "5.1.5.5. Bind Tokens to a Particular Resource Server (Audience)",
      "section_title": true,
      "ja": "5.1.5.5。特定のリソースサーバーにバインドトークン（聴衆）"
    },
    {
      "indent": 3,
      "text": "Authorization servers in multi-service environments may consider issuing tokens with different content to different resource servers and to explicitly indicate in the token the target server to which a token is intended to be sent. SAML assertions (see [OASIS.saml-core-2.0-os]) use the Audience element for this purpose. This countermeasure can be used in the following situations:",
      "ja": "マルチサービス環境における認証サーバは、異なるリソースサーバに異なる内容のトークンを発行することを検討して、明示的にトークンにトークンが送信されるように意図されているターゲットサーバを示すために。 SAMLアサーション（[OASIS.samlコア-2.0-OS]を参照）、この目的のためにオーディエンス要素を使用します。この対策は、以下の状況で使用することができます。"
    },
    {
      "indent": 3,
      "text": "o It reduces the impact of a successful replay attempt, since the token is applicable to a single resource server only.",
      "ja": "トークンは、単一のリソースサーバーに適用されるので、Oそれは、成功したリプレイの試みの影響を低減します。"
    },
    {
      "indent": 3,
      "text": "o It prevents abuse of a token by a rogue resource server or client, since the token can only be used on that server. It is rejected by other servers.",
      "ja": "トークンはそのサーバーでのみ使用することができますので、Oこれは、不正なリソースサーバまたはクライアントによってトークンの乱用を防ぐことができます。これは、他のサーバーによって拒否されます。"
    },
    {
      "indent": 3,
      "text": "o It reduces the impact of leakage of a valid token to a counterfeit resource server.",
      "ja": "Oそれは偽造リソースサーバーへの有効なトークンの漏れの影響を低減します。"
    },
    {
      "indent": 0,
      "text": "5.1.5.6. Use Endpoint Address as Token Audience",
      "section_title": true,
      "ja": "5.1.5.6。使用するエンドポイントアドレスとしてトークンの対象読者"
    },
    {
      "indent": 3,
      "text": "This may be used to indicate to a resource server which endpoint URL has been used to obtain the token. This measure will allow the detection of requests from a counterfeit resource server, since such a token will contain the endpoint URL of that server.",
      "ja": "これは、トークンを取得するために使用されているエンドポイントURLリソースサーバーに示すために使用することができます。そのようなトークンは、そのサーバーのエンドポイントURLが含まれていますので、この措置は、偽造リソースサーバからの要求の検出を可能にします。"
    },
    {
      "indent": 0,
      "text": "5.1.5.7. Use Explicitly Defined Scopes for Audience and Tokens",
      "section_title": true,
      "ja": "5.1.5.7。聴衆のために明示的に定義されたスコープを使用してトークン"
    },
    {
      "indent": 3,
      "text": "Deployments may consider only using tokens with explicitly defined scopes, where every scope is associated with a particular resource server. This approach can be used to mitigate attacks where a resource server or client uses a token for a different purpose than the one intended.",
      "ja": "展開は唯一、すべての範囲は、特定のリソース・サーバーに関連付けられている明示的に定義されたスコープを持つトークンを使用して検討することができます。このアプローチは、リソースサーバまたはクライアントが意図したものとは異なる目的のためにトークンを使用して攻撃を軽減するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "5.1.5.8. Bind Token to Client id",
      "section_title": true,
      "ja": "5.1.5.8。クライアントIDにバインドトークン"
    },
    {
      "indent": 3,
      "text": "An authorization server may bind a token to a certain client identifier. This identifier should be validated for every request with that token. This technique can be used to",
      "ja": "認証サーバは、特定のクライアント識別子にトークンを結合することができます。この識別子は、そのトークンとリクエストごとに検証する必要があります。この技術はに使用することができます"
    },
    {
      "indent": 3,
      "text": "o detect token leakage and",
      "ja": "Oトークン漏れを検出し、"
    },
    {
      "indent": 3,
      "text": "o prevent token abuse.",
      "ja": "Oトークン乱用を防ぎます。"
    },
    {
      "indent": 3,
      "text": "Note: Validating the client identifier may require the target server to authenticate the client's identifier. This authentication can be based on secrets managed independently of the token (e.g., pre-registered client id/secret on authorization server) or sent with the token itself (e.g., as part of the encrypted token content).",
      "ja": "注：クライアント識別子を検証することは、クライアントの識別子を認証するために、ターゲット・サーバーが必要な場合があります。この認証は、独立したトークン（認証サーバ上で、例えば、事前に登録されたクライアントID /シークレット）の管理またはトークン自体に送られた秘密に基づくことができる（例えば、暗号化されたトークンのコンテンツの一部として）。"
    },
    {
      "indent": 0,
      "text": "5.1.5.9. Sign Self-Contained Tokens",
      "section_title": true,
      "ja": "5.1.5.9。自己完結型トークンのサイン"
    },
    {
      "indent": 3,
      "text": "Self-contained tokens should be signed in order to detect any attempt to modify or produce faked tokens (e.g., Hash-based Message Authentication Code or digital signatures).",
      "ja": "自己完結型のトークンは変更又は偽造トークン（例えば、ハッシュベースのメッセージ認証コード又はデジタル署名）を生成しようとする試みを検出するために署名しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.5.10. Encrypt Token Content",
      "section_title": true,
      "ja": "5.1.5.10。トークンのコンテンツを暗号化"
    },
    {
      "indent": 3,
      "text": "Self-contained tokens may be encrypted for confidentiality reasons or to protect system internal data. Depending on token format, keys (e.g., symmetric keys) may have to be distributed between server nodes. The method of distribution should be defined by the token and the encryption used.",
      "ja": "自己完結型のトークンは、機密性の理由のために暗号化してもよいし、システム内部のデータを保護します。トークンの形式に応じて、キー（例えば、対称鍵）は、サーバ・ノード間で分散されなければなりません。配布方法は、トークンと使用する暗号化によって定義されるべきです。"
    },
    {
      "indent": 0,
      "text": "5.1.5.11. Adopt a Standard Assertion Format",
      "section_title": true,
      "ja": "5.1.5.11。標準的なアサーションフォーマットを採用"
    },
    {
      "indent": 3,
      "text": "For service providers intending to implement an assertion-based token design, it is highly recommended to adopt a standard assertion format (such as SAML [OASIS.saml-core-2.0-os] or the JavaScript Object Notation Web Token (JWT) [OAuth-JWT]).",
      "ja": "アサーションベーストークン設計を実装するために意図サービスプロバイダのために、非常にそのようなSAML [OASIS.samlコア-2.0-OS]またはJavaScriptオブジェクト表記ウェブトークン（JWT）のような標準的なアサーション・フォーマット（[OAuthのを採用することが推奨されます-JWT]）。"
    },
    {
      "indent": 0,
      "text": "5.1.6. Access Tokens",
      "section_title": true,
      "ja": "5.1.6。アクセストークン"
    },
    {
      "indent": 3,
      "text": "The following measures should be used to protect access tokens:",
      "ja": "次の措置は、アクセストークンを保護するために使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Keep them in transient memory (accessible by the client application only).",
      "ja": "O（クライアントアプリケーションによってのみアクセス可能）過渡メモリに保管してください。"
    },
    {
      "indent": 3,
      "text": "o Pass tokens securely using secure transport (TLS).",
      "ja": "Oパスを確実にセキュアなトランスポート（TLS）を使用してトークン。"
    },
    {
      "indent": 3,
      "text": "o Ensure that client applications do not share tokens with 3rd parties.",
      "ja": "Oクライアントアプリケーションはサードパーティとのトークンを共有していないことを確認してください。"
    },
    {
      "indent": 0,
      "text": "5.2. Authorization Server",
      "section_title": true,
      "ja": "5.2。認証サーバー"
    },
    {
      "indent": 3,
      "text": "This section describes considerations related to the OAuth authorization server endpoint.",
      "ja": "このセクションでは、OAuthの認証サーバのエンドポイントに関連する考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Authorization \"codes\"",
      "section_title": true,
      "ja": "5.2.1。認可の「コード」"
    },
    {
      "indent": 0,
      "text": "5.2.1.1. Automatic Revocation of Derived Tokens If Abuse Is Detected",
      "section_title": true,
      "ja": "5.2.1.1。派生トークンの自動失効乱用が検出された場合"
    },
    {
      "indent": 3,
      "text": "If an authorization server observes multiple attempts to redeem an authorization grant (e.g., such as an authorization \"code\"), the authorization server may want to revoke all tokens granted based on the authorization grant.",
      "ja": "認証サーバが認証許可を償還するために複数の試みを観察する場合（例えば、認可「コード」として）、認証サーバは、認証許可に基づいて付与されたすべてのトークンを取り消す場合があります。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Refresh Tokens",
      "section_title": true,
      "ja": "5.2.2。リフレッシュトークン"
    },
    {
      "indent": 0,
      "text": "5.2.2.1. Restricted Issuance of Refresh Tokens",
      "section_title": true,
      "ja": "5.2.2.1。更新トークンの制限付き発行"
    },
    {
      "indent": 3,
      "text": "The authorization server may decide, based on an appropriate policy, not to issue refresh tokens. Since refresh tokens are long-term credentials, they may be subject to theft. For example, if the authorization server does not trust a client to securely store such tokens, it may refuse to issue such a client a refresh token.",
      "ja": "認証サーバは、リフレッシュトークンを発行しないように、適切なポリシーに基づいて、決めることができます。リフレッシュトークンは、長期的な資格情報があるので、盗難の対象となる場合があります。認証サーバが安全なトークンを保存するために、クライアントを信頼していない場合、それは、そのようなクライアントにリフレッシュトークンを発行することを拒否することができます。"
    },
    {
      "indent": 0,
      "text": "5.2.2.2. Binding of Refresh Token to \"client_id\"",
      "section_title": true,
      "ja": "5.2.2.2。 「CLIENT_ID」に更新トークンの結合"
    },
    {
      "indent": 3,
      "text": "The authorization server should match every refresh token to the identifier of the client to whom it was issued. The authorization server should check that the same \"client_id\" is present for every request to refresh the access token. If possible (e.g., confidential clients), the authorization server should authenticate the respective client.",
      "ja": "認証サーバは、それが発行された人に、クライアントの識別子に全てのリフレッシュトークンと一致する必要があります。認証サーバは、同じ「のclient_id」はアクセストークンをリフレッシュするすべての要求のために存在していることを確認する必要があります。 （例えば、機密クライアント）可能な場合、認証サーバは、各クライアントを認証する必要があります。"
    },
    {
      "indent": 3,
      "text": "This is a countermeasure against refresh token theft or leakage.",
      "ja": "これは、リフレッシュトークンの盗難や漏洩対策です。"
    },
    {
      "indent": 3,
      "text": "Note: This binding should be protected from unauthorized modifications.",
      "ja": "注：この結合は、不正な変更から保護されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.2.3. Refresh Token Rotation",
      "section_title": true,
      "ja": "5.2.2.3。リフレッシュトークンローテーション"
    },
    {
      "indent": 3,
      "text": "Refresh token rotation is intended to automatically detect and prevent attempts to use the same refresh token in parallel from different apps/devices. This happens if a token gets stolen from the client and is subsequently used by both the attacker and the legitimate client. The basic idea is to change the refresh token value with every refresh request in order to detect attempts to obtain access tokens using old refresh tokens. Since the authorization server cannot determine whether the attacker or the legitimate client is trying to access, in case of such an access attempt the valid refresh token and the access authorization associated with it are both revoked.",
      "ja": "リフレッシュトークン回転を自動的に検出し、異なるアプリケーション/装置から並列的に同じリフレッシュトークンを使用しようとする試みを防止することを意図しています。トークンは、クライアントから盗まれ、その後、攻撃者は正当なクライアントの両方で使用されている場合に発生します。基本的な考え方は古いリフレッシュトークンを使用してアクセストークンを取得しようとする試みを検出するために、すべてのリフレッシュ要求とリフレッシュトークン値を変更することです。認証サーバが攻撃者または正当なクライアントは、このようなアクセスの場合には、アクセスしようとしているかどうかを判断することはできませんので、有効なリフレッシュトークンをしようと、それに関連付けられたアクセス許可が両方取り消されます。"
    },
    {
      "indent": 3,
      "text": "The OAuth specification supports this measure in that the token's response allows the authorization server to return a new refresh token even for requests with grant type \"refresh_token\".",
      "ja": "OAuthの仕様は、トークンの応答が認証サーバでも許可タイプ「refresh_token」との要求のためのトークンの新しいリフレッシュを返すことができるという点で、この対策をサポートしています。"
    },
    {
      "indent": 3,
      "text": "Note: This measure may cause problems in clustered environments, since usage of the currently valid refresh token must be ensured. In such an environment, other measures might be more appropriate.",
      "ja": "注意：現在有効なリフレッシュトークンの使用が保証されなければならないので、この尺度は、クラスタ環境で問題が発生することがあります。このような環境では、他の対策がより適切であるかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.2.2.4. Revocation of Refresh Tokens",
      "section_title": true,
      "ja": "5.2.2.4。更新トークンの失効"
    },
    {
      "indent": 3,
      "text": "The authorization server may allow clients or end users to explicitly request the invalidation of refresh tokens. A mechanism to revoke tokens is specified in [OAuth-REVOCATION].",
      "ja": "認証サーバは、クライアントまたはエンドユーザーが明示的にリフレッシュトークンの無効化を要求することを可能にします。トークンを取り消すメカニズムが[OAuthの-取消]で指定されています。"
    },
    {
      "indent": 3,
      "text": "This is a countermeasure against:",
      "ja": "これは対策です。"
    },
    {
      "indent": 3,
      "text": "o device theft,",
      "ja": "Oデバイスの盗難、"
    },
    {
      "indent": 3,
      "text": "o impersonation of a resource owner, or",
      "ja": "Oリソースの所有者のなりすまし、または"
    },
    {
      "indent": 3,
      "text": "o suspected compromised client applications.",
      "ja": "O疑われる感染したクライアントアプリケーション。"
    },
    {
      "indent": 0,
      "text": "5.2.2.5. Device Identification",
      "section_title": true,
      "ja": "5.2.2.5。デバイスの識別"
    },
    {
      "indent": 3,
      "text": "The authorization server may require the binding of authentication credentials to a device identifier. The International Mobile Station Equipment Identity [IMEI] is one example of such an identifier; there are also operating system-specific identifiers. The authorization server could include such an identifier when authenticating user credentials in order to detect token theft from a particular device.",
      "ja": "認証サーバは、デバイス識別子に認証資格情報の結合が必要な場合があります。国際移動局装置識別【IMEIは、このような識別子の一例です。また、オペレーティング・システム固有の識別子があります。特定のデバイスからのトークンの盗難を検出するために、ユーザーの資格情報を認証する際に認証サーバは、このような識別子を含むことができます。"
    },
    {
      "indent": 3,
      "text": "Note: Any implementation should consider potential privacy implications of using device identifiers.",
      "ja": "注意：任意の実装では、デバイス識別子を使用しての潜在的なプライバシーへの影響を考慮すべきです。"
    },
    {
      "indent": 0,
      "text": "5.2.2.6. X-FRAME-OPTIONS Header",
      "section_title": true,
      "ja": "5.2.2.6。 X-FRAME-OPTIONSヘッダー"
    },
    {
      "indent": 3,
      "text": "For newer browsers, avoidance of iFrames can be enforced on the server side by using the X-FRAME-OPTIONS header (see [X-Frame-Options]). This header can have two values, \"DENY\" and \"SAMEORIGIN\", which will block any framing or any framing by sites with a different origin, respectively. The value \"ALLOW-FROM\" specifies a list of trusted origins that iFrames may originate from.",
      "ja": "新しいブラウザのため、のiFrameの回避は、X-FRAME-OPTIONSヘッダーを使用して、サーバ側で実施することができる（[X-フレーム・オプション]を参照）。このヘッダは、それぞれ、異なる起源を持つ部位によって任意フレーミングまたは任意のフレーミングをブロックしている、「拒否」および「SAMEORIGIN」、2つの値を有することができます。値が「許可-FROM」のiFrameが由来してもよい、信頼できる起源のリストを指定します。"
    },
    {
      "indent": 3,
      "text": "This is a countermeasure against the following threat:",
      "ja": "これは、次の脅威への対策です。"
    },
    {
      "indent": 3,
      "text": "o Clickjacking attacks",
      "ja": "Oクリックジャッキング攻撃"
    },
    {
      "indent": 0,
      "text": "5.2.3. Client Authentication and Authorization",
      "section_title": true,
      "ja": "5.2.3。クライアントの認証と認可"
    },
    {
      "indent": 3,
      "text": "As described in Section 3 (Security Features), clients are identified, authenticated, and authorized for several purposes, such as to:",
      "ja": "第3節（セキュリティ機能）で説明したように、クライアントは、識別、認証、およびそのようになど、いくつかの目的のために許可されています。"
    },
    {
      "indent": 3,
      "text": "o Collate requests to the same client,",
      "ja": "Oソートは、同じクライアントに要求します"
    },
    {
      "indent": 3,
      "text": "o Indicate to the user that the client is recognized by the authorization server,",
      "ja": "Oクライアントが認証サーバーによって認識されているユーザに示します、"
    },
    {
      "indent": 3,
      "text": "o Authorize access of clients to certain features on the authorization server or resource server, and",
      "ja": "O認証サーバまたはリソースサーバー上の特定の機能へのクライアントのアクセスを許可し、"
    },
    {
      "indent": 3,
      "text": "o Log a client identifier to log files for analysis or statistics.",
      "ja": "O解析や統計のログファイルへのクライアント識別子を記録します。"
    },
    {
      "indent": 3,
      "text": "Due to the different capabilities and characteristics of the different client types, there are different ways to support these objectives, which will be described in this section. Authorization server providers should be aware of the security policy and deployment of a particular client and adapt its treatment accordingly. For example, one approach could be to treat all clients as less trustworthy and unsecure. On the other extreme, a service provider could activate every client installation individually by an administrator and in that way gain confidence in the identity of the software package and the security of the environment in which the client is installed. There are several approaches in between.",
      "ja": "異なる機能と異なるクライアントタイプの特性に、このセクションで説明されるこれらの目的を、サポートするためのさまざまな方法があります。認証サーバープロバイダは、特定のクライアントのセキュリティポリシーと展開を認識し、それに応じて治療を適応させる必要があります。例えば、1つのアプローチはあまり信頼できるとセキュリティ保護されていないとして、すべてのクライアントを治療することである可能性があります。他の極端では、サービスプロバイダは、管理者が個別にすべてのクライアントのインストールを活性化できるし、そのようにソフトウェアパッケージのアイデンティティとクライアントがインストールされている環境のセキュリティに自信を得ることができます。間にはいくつかのアプローチがあります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.1. Don't Issue Secrets to Clients with Inappropriate Security Policy",
      "ja": "5.2.3.1。不適切なセキュリティポリシーを持つクライアントに秘密を発行しないでください。"
    },
    {
      "indent": 3,
      "text": "Authorization servers should not issue secrets to clients that cannot protect secrets (\"public\" clients). This reduces the probability of the server treating the client as strongly authenticated.",
      "ja": "認証サーバは、秘密（「パブリック」クライアント）を保護することはできませんクライアントに秘密を発行するべきではありません。これは、強力な認証されたクライアントを処理するサーバーの確率を低減します。"
    },
    {
      "indent": 3,
      "text": "For example, it is of limited benefit to create a single client id and secret that are shared by all installations of a native application. Such a scenario requires that this secret must be transmitted from the developer via the respective distribution channel, e.g., an application market, to all installations of the application on end-user devices. A secret, burned into the source code of the application or an associated resource bundle, is not protected from reverse engineering. Secondly, such secrets cannot be revoked, since this would immediately put all installations out of work. Moreover, since the authorization server cannot really trust the client's identifier, it would be dangerous to indicate to end users the trustworthiness of the client.",
      "ja": "例えば、それは、ネイティブアプリケーションのすべてのインストールで共有されている単一のクライアントIDとシークレットを作成するために、限られた有益です。そのようなシナリオでは、この秘密は、エンドユーザデバイス上のアプリケーションのすべてのインストールに、各流通チャネル、例えば、アプリケーションの市場を介して、開発者から送信されなければならないことを要求します。アプリケーションのソース・コードまたは関連するリソースバンドルに焼き付け秘密は、リバースエンジニアリングから保護されていません。これはすぐに作品のうち、すべてのインストールを置くので、第二に、そのような秘密は、取り消すことはできません。認証サーバが本当にクライアントの識別子を信頼することはできませんので、ユーザーにクライアントの信頼を終了する示すために危険です。"
    },
    {
      "indent": 3,
      "text": "There are other ways to achieve a reasonable security level, as described in the following sections.",
      "ja": "次のセクションで説明するように、合理的なセキュリティレベルを達成するための他の方法があります。"
    },
    {
      "indent": 0,
      "text": "5.2.3.2. Require User Consent for Public Clients without Secret",
      "section_title": true,
      "ja": "5.2.3.2。シークレットなしパブリック・クライアントのユーザーの同意を必要とします"
    },
    {
      "indent": 3,
      "text": "Authorization servers should not allow automatic authorization for public clients. The authorization server may issue an individual client id but should require that all authorizations are approved by the end user. For clients without secrets, this is a countermeasure against the following threat:",
      "ja": "認証サーバは、パブリッククライアントの自動承認を許してはなりません。認証サーバは、個々のクライアントIDを発行することができるが、すべての権限は、エンドユーザーによって承認されていることを要求すべきです。秘密のないクライアントの場合、これは以下の脅威に対する対策は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Impersonation of public client applications.",
      "ja": "公共のクライアントアプリケーションのOの偽装。"
    },
    {
      "indent": 0,
      "text": "5.2.3.3. Issue a \"client_id\" Only in Combination with \"redirect_uri\"",
      "section_title": true,
      "ja": "5.2.3.3。のみ「REDIRECT_URI」との組み合わせで、「CLIENT_ID」を発行"
    },
    {
      "indent": 3,
      "text": "The authorization server may issue a \"client_id\" and bind the \"client_id\" to a certain pre-configured \"redirect_uri\". Any authorization request with another redirect URI is refused automatically. Alternatively, the authorization server should not accept any dynamic redirect URI for such a \"client_id\" and instead should always redirect to the well-known pre-configured redirect URI. This is a countermeasure for clients without secrets against the following threats:",
      "ja": "認証サーバは、「CLIENT_ID」を発行し、特定の事前に設定され、「REDIRECT_URI」に「CLIENT_ID」を結合することができます。別のリダイレクトURIを持つ任意の承認要求は自動的に拒否されます。代替的に、認証サーバは、常に、よく知られている事前に設定リダイレクトURIへリダイレクトすべきである代わりに、そのような「CLIENT_ID」のための任意の動的リダイレクトURIを受け入れてはなりません。これは、次の脅威に対する秘密なしのクライアントのための対策です。"
    },
    {
      "indent": 3,
      "text": "o Cross-site scripting attacks",
      "ja": "Oクロスサイトスクリプティング攻撃"
    },
    {
      "indent": 3,
      "text": "o Impersonation of public client applications",
      "ja": "公共のクライアントアプリケーションのOの偽装"
    },
    {
      "indent": 0,
      "text": "5.2.3.4. Issue Installation-Specific Client Secrets",
      "section_title": true,
      "ja": "5.2.3.4。問題のインストールに固有のクライアントの秘密"
    },
    {
      "indent": 3,
      "text": "An authorization server may issue separate client identifiers and corresponding secrets to the different installations of a particular client (i.e., software package). The effect of such an approach would be to turn otherwise \"public\" clients back into \"confidential\" clients.",
      "ja": "認証サーバは、特定のクライアント（すなわち、ソフトウェアパッケージ）の異なるインストールに別のクライアント識別子と対応する秘密を発行することができます。このようなアプローチの効果はバック「機密」のクライアントにそれ以外の場合は「公共」のクライアントを回すことであろう。"
    },
    {
      "indent": 3,
      "text": "For web applications, this could mean creating one \"client_id\" and \"client_secret\" for each web site on which a software package is installed. So, the provider of that particular site could request a client id and secret from the authorization server during the setup of the web site. This would also allow the validation of some of the properties of that web site, such as redirect URI, web site URL, and whatever else proves useful. The web site provider has to ensure the security of the client secret on the site.",
      "ja": "Webアプリケーションの場合、これは、ソフトウェア・パッケージがインストールされている各ウェブサイトのための一つの「CLIENT_ID」と「client_secret」を作成する意味するかもしれません。だから、その特定のサイトの提供者は、ウェブサイトのセットアップ時に、認証サーバからクライアントIDとシークレットを要求することができます。これはまた、そのようなURI、ウェブサイトのURL、および任意の他役立ちリダイレクトとして、そのWebサイトのプロパティのいくつかの検証を可能にします。ウェブサイトプロバイダは、サイト上のクライアントシークレットのセキュリティを確保する必要があります。"
    },
    {
      "indent": 3,
      "text": "For native applications, things are more complicated because every copy of a particular application on any device is a different installation. Installation-specific secrets in this scenario will require obtaining a \"client_id\" and \"client_secret\" either",
      "ja": "任意のデバイス上の特定のアプリケーションのすべてのコピーが別のインストールであるため、ネイティブアプリケーションでは、物事はより複雑です。このシナリオでは、インストール固有の秘密はどちらか「のclient_id」と「client_secret」を得る必要があります"
    },
    {
      "indent": 3,
      "text": "1. during the download process from the application market, or",
      "section_title": true,
      "ja": "アプリケーションマーケットからダウンロードプロセス中に1、または"
    },
    {
      "indent": 3,
      "text": "2. during installation on the device.",
      "section_title": true,
      "ja": "デバイスのインストール中に2。"
    },
    {
      "indent": 3,
      "text": "Either approach will require an automated mechanism for issuing client ids and secrets, which is currently not defined by OAuth.",
      "ja": "どちらのアプローチは、現在のOAuthによって定義されていないクライアントIDと秘密を、発行するための自動化されたメカニズムが必要になります。"
    },
    {
      "indent": 3,
      "text": "The first approach would allow the achievement of a certain level of trust in the authenticity of the application, whereas the second option only allows the authentication of the installation but not the validation of properties of the client. But this would at least help to prevent several replay attacks. Moreover, installation-specific \"client_ids\" and secrets allow the selective revocation of all refresh tokens of a specific installation at once.",
      "ja": "二番目のオプションは、インストールのみの認証ではなく、クライアントのプロパティの検証を可能にするのに対し、第一のアプローチは、アプリケーションの信頼性への信頼のあるレベルの達成を可能にします。しかし、これは、少なくともいくつかのリプレイ攻撃を防ぐために役立つだろう。また、インストール固有の「client_ids」と秘密は、一度に特定のインストールのすべてのリフレッシュトークンを選択的に取り消しが可能。"
    },
    {
      "indent": 0,
      "text": "5.2.3.5. Validate Pre-Registered \"redirect_uri\"",
      "section_title": true,
      "ja": "5.2.3.5。検証あらかじめ登録「REDIRECT_URI」"
    },
    {
      "indent": 3,
      "text": "An authorization server should require all clients to register their \"redirect_uri\", and the \"redirect_uri\" should be the full URI as defined in [RFC6749]. The way that this registration is performed is out of scope of this document. As per the core spec, every actual redirect URI sent with the respective \"client_id\" to the end-user authorization endpoint must match the registered redirect URI. Where it does not match, the authorization server should assume that the inbound GET request has been sent by an attacker and refuse it. Note: The authorization server should not redirect the user agent back to the redirect URI of such an authorization request. Validating the pre-registered \"redirect_uri\" is a countermeasure against the following threats:",
      "ja": "認証サーバは、彼らの「REDIRECT_URI」を登録するには、すべてのクライアントを必要とすべきである、と[RFC6749]で定義されている「REDIRECT_URI」完全なURIでなければなりません。この登録が行われている方法は、この文書の範囲外です。コア仕様に従って、すべての実際のリダイレクトURIは、登録されたリダイレクトURIと一致している必要があり、エンドユーザー認可エンドポイントにそれぞれの「CLIENT_ID」を送りました。それが一致しない場合は、認証サーバは、インバウンドGETリクエストが攻撃者によって送信されたことを想定し、それを拒否すべきです。注意：認証サーバは、認証要求のリダイレクトURIにバックユーザエージェントをリダイレクトするべきではありません。あらかじめ登録された「REDIRECT_URI」を検証すると、次の脅威への対策です。"
    },
    {
      "indent": 3,
      "text": "o Authorization \"code\" leakage through counterfeit web site: allows authorization servers to detect attack attempts after the first redirect to an end-user authorization endpoint (Section 4.4.1.7).",
      "ja": "O認可の「コード」偽造ウェブサイトを通じて漏洩：認証サーバは、エンドユーザー認可エンドポイント（セクション4.4.1.7）への最初のリダイレクト後に攻撃を検出することができます。"
    },
    {
      "indent": 3,
      "text": "o Open redirector attack via a client redirection endpoint (Section 4.1.5).",
      "ja": "クライアントのリダイレクトエンドポイントを経由してOオープンリダイレクタ攻撃（4.1.5項）。"
    },
    {
      "indent": 3,
      "text": "o Open redirector phishing attack via an authorization server redirection endpoint (Section 4.2.4).",
      "ja": "認証サーバのリダイレクトエンドポイントを経由してフィッシング攻撃がOオープンリダイレクタ（4.2.4項）。"
    },
    {
      "indent": 3,
      "text": "The underlying assumption of this measure is that an attacker will need to use another redirect URI in order to get access to the authorization \"code\". Deployments might consider the possibility of an attacker using spoofing attacks to a victim's device to circumvent this security measure.",
      "ja": "この措置の基本的な前提は、攻撃者が承認「コード」へのアクセスを取得するために、別のリダイレクトURIを使用する必要がありますということです。展開では、このセキュリティ対策を回避するために、被害者のデバイスにスプーフィング攻撃を使って攻撃の可能性を検討するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Note: Pre-registering clients might not scale in some deployments (manual process) or require dynamic client registration (not specified yet). With the lack of dynamic client registration, a pre-registered \"redirect_uri\" only works for clients bound to certain deployments at development/configuration time. As soon as dynamic resource server discovery is required, the pre-registered \"redirect_uri\" may no longer be feasible.",
      "ja": "注：事前登録のクライアントは、いくつかの展開（手動プロセス）におけるスケールまたは動的クライアント登録（まだ指定されていない）を必要としない場合があります。ダイナミッククライアント登録の欠如と、あらかじめ登録された「REDIRECT_URIは」のみ開発/コンフィギュレーション時に特定の展開にバインドされたクライアントのために動作します。すぐに動的なリソースサーバの発見が必要とされるように、あらかじめ登録された「REDIRECT_URI」はもはや実現可能でないかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.2.3.6. Revoke Client Secrets",
      "section_title": true,
      "ja": "5.2.3.6。クライアントの秘密を取り消し"
    },
    {
      "indent": 3,
      "text": "An authorization server may revoke a client's secret in order to prevent abuse of a revealed secret.",
      "ja": "認証サーバは、明らかに秘密の乱用を防ぐために、クライアントの秘密を取り消すことができます。"
    },
    {
      "indent": 3,
      "text": "Note: This measure will immediately invalidate any authorization \"code\" or refresh token issued to the respective client. This might unintentionally impact client identifiers and secrets used across multiple deployments of a particular native or web application.",
      "ja": "注意：この措置は直ちに承認「コード」を無効にするか、トークンそれぞれのクライアントに発行された更新されます。これは、意図せずに、特定のネイティブまたはWebアプリケーションの複数の展開全体で使用されるクライアント識別子と秘密に影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "This a countermeasure against:",
      "ja": "この対策："
    },
    {
      "indent": 3,
      "text": "o Abuse of revealed client secrets for private clients",
      "ja": "個人顧客のために明らかにしたクライアントの秘密のO乱用"
    },
    {
      "indent": 0,
      "text": "5.2.3.7. Use Strong Client Authentication (e.g., client_assertion/ client_token)",
      "ja": "5.2.3.7。強力なクライアント認証を使用する（例えば、client_assertion / client_token）"
    },
    {
      "indent": 3,
      "text": "By using an alternative form of authentication such as client assertion [OAuth-ASSERTIONS], the need to distribute a \"client_secret\" is eliminated. This may require the use of a secure private key store or other supplemental authentication system as specified by the client assertion issuer in its authentication process.",
      "ja": "そのようなクライアントのアサーションなどの認証の代替形態[OAuthの-アサーション]を用いて、「client_secret」を配布する必要性が排除されます。その認証プロセスにおけるクライアントのアサーション発行者によって指定されたように、これはセキュアなプライベートキーストアまたは他の補助的な認証システムを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.4. End-User Authorization",
      "section_title": true,
      "ja": "5.2.4。エンドユーザー認証"
    },
    {
      "indent": 3,
      "text": "This section includes considerations for authorization flows involving the end user.",
      "ja": "このセクションでは、エンドユーザーが関与承認フローの考慮事項が含まれています。"
    },
    {
      "indent": 0,
      "text": "5.2.4.1. Automatic Processing of Repeated Authorizations Requires Client Validation",
      "ja": "5.2.4.1。繰り返し認可の自動処理は、クライアント検証が必要"
    },
    {
      "indent": 3,
      "text": "Authorization servers should NOT automatically process repeat authorizations where the client is not authenticated through a client secret or some other authentication mechanism such as a signed authentication assertion certificate (Section 5.2.3.7) or validation of a pre-registered redirect URI (Section 5.2.3.5).",
      "ja": "認証サーバは、クライアントがそのような署名認証アサーション証明書（セクション5.2.3.7）として秘密クライアントまたは他の認証メカニズムを介して、または検証事前登録を認証されていない自動プロセスリピート権限は、URI（セクション5.2.3.5をリダイレクトしないでください）。"
    },
    {
      "indent": 0,
      "text": "5.2.4.2. Informed Decisions Based on Transparency",
      "section_title": true,
      "ja": "5.2.4.2。透明性に基づいて、情報に基づいた意思決定"
    },
    {
      "indent": 3,
      "text": "The authorization server should clearly explain to the end user what happens in the authorization process and what the consequences are. For example, the user should understand what access he is about to grant to which client for what duration. It should also be obvious to the user whether the server is able to reliably certify certain client properties (web site URL, security policy).",
      "ja": "認証サーバは明らかに、認可プロセスとどのような影響がある中で何が起こるかエンドユーザーに説明する必要があります。例えば、ユーザーは、彼がどのような期間どのクライアントに付与しようとしている何かのアクセスを理解する必要があります。また、サーバーが確実に特定のクライアントのプロパティ（ウェブサイトのURL、セキュリティポリシー）を証明できるかどうかをユーザーに明らかにする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.4.3. Validation of Client Properties by End User",
      "section_title": true,
      "ja": "5.2.4.3。エンドユーザーによってクライアントのプロパティの検証"
    },
    {
      "indent": 3,
      "text": "In the authorization process, the user is typically asked to approve a client's request for authorization. This is an important security mechanism by itself because the end user can be involved in the validation of client properties, such as whether the client name known to the authorization server fits the name of the web site or the application the end user is using. This measure is especially helpful in situations where the authorization server is unable to authenticate the client. It is a countermeasure against:",
      "ja": "承認プロセスでは、ユーザーは通常、承認のためのクライアントの要求を承認するよう求めています。エンドユーザーは、このような認証サーバに知られているクライアント名は、ウェブサイトやエンドユーザーが使用しているアプリケーションの名前を適合するかどうかなど、クライアント・プロパティの検証に関与することができますので、これはそれ自体で重要なセキュリティメカニズムです。この措置は、認証サーバがクライアントを認証することができない状況では特に便利です。それは対策です。"
    },
    {
      "indent": 3,
      "text": "o A malicious application",
      "ja": "悪意のあるアプリケーションO"
    },
    {
      "indent": 3,
      "text": "o A client application masquerading as another client",
      "ja": "Oクライアントアプリケーションは、他のクライアントになりすまし"
    },
    {
      "indent": 0,
      "text": "5.2.4.4. Binding of Authorization \"code\" to \"client_id\"",
      "section_title": true,
      "ja": "5.2.4.4。 「CLIENT_ID」に認証「コード」の結合"
    },
    {
      "indent": 3,
      "text": "The authorization server should bind every authorization \"code\" to the id of the respective client that initiated the end-user authorization process. This measure is a countermeasure against:",
      "ja": "認証サーバは、エンドユーザーの認証プロセスを開始し、各クライアントのIDにすべての承認「コード」をバインドする必要があります。この措置は、対策です。"
    },
    {
      "indent": 3,
      "text": "o Replay of authorization \"codes\" with different client credentials, since an attacker cannot use another \"client_id\" to exchange an authorization \"code\" into a token",
      "ja": "O異なるクライアント資格情報を使用して認証「コード」のリプレイ、攻撃者がトークンに認証「コード」を交換するために、別の「CLIENT_ID」を使用することはできませんので、"
    },
    {
      "indent": 3,
      "text": "o Online guessing of authorization \"codes\"",
      "ja": "Oオンライン認証「コード」の推測"
    },
    {
      "indent": 3,
      "text": "Note: This binding should be protected from unauthorized modifications (e.g., using protected memory and/or a secure database).",
      "ja": "注：この結合は、（例えば、保護されたメモリおよび/または安全なデータベースを使用して）不正な変更から保護されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.4.5. Binding of Authorization \"code\" to \"redirect_uri\"",
      "section_title": true,
      "ja": "5.2.4.5。 「REDIRECT_URI」に認可の「コード」の結合"
    },
    {
      "indent": 3,
      "text": "The authorization server should be able to bind every authorization \"code\" to the actual redirect URI used as the redirect target of the client in the end-user authorization process. This binding should be validated when the client attempts to exchange the respective authorization \"code\" for an access token. This measure is a countermeasure against authorization \"code\" leakage through counterfeit web sites, since an attacker cannot use another redirect URI to exchange an authorization \"code\" into a token.",
      "ja": "認証サーバは、URIがエンドユーザーの承認プロセスにおけるクライアントのリダイレクト先として使用される実際のリダイレクトにすべての認証「コード」に結合することができるはずです。クライアントがアクセストークンのためのそれぞれの認可「コード」を交換しようとしたときに、この結合は、検証する必要があります。攻撃者は、別のトークンに認証「コード」を交換するURIをリダイレクト使用することはできませんので、この措置は、偽造ウェブサイトを通じて認証「コード」漏れ対策です。"
    },
    {
      "indent": 0,
      "text": "5.3. Client App Security",
      "section_title": true,
      "ja": "5.3。クライアントアプリケーションのセキュリティ"
    },
    {
      "indent": 3,
      "text": "This section deals with considerations for client applications.",
      "ja": "このセクションでは、クライアントアプリケーションのための考慮事項を扱います。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Don't Store Credentials in Code or Resources Bundled with Software Packages",
      "ja": "5.3.1。ソフトウェアパッケージとのコードやリソースバンドルでの資格情報を格納しないでください"
    },
    {
      "indent": 3,
      "text": "Because of the number of copies of client software, there is limited benefit in creating a single client id and secret that is shared by all installations of an application. Such an application by itself would be considered a \"public\" client, as it cannot be presumed to be able to keep client secrets. A secret, burned into the source code of the application or an associated resource bundle, cannot be protected from reverse engineering. Secondly, such secrets cannot be revoked, since this would immediately put all installations out of work. Moreover, since the authorization server cannot really trust the client's identifier, it would be dangerous to indicate to end users the trustworthiness of the client.",
      "ja": "そのため、クライアントソフトウェアのコピーの数を、アプリケーションのすべてのインストールで共有されている単一のクライアントIDとシークレットを作成するには限られた利点があります。クライアントの秘密を保つことができるように推定することはできないとして、それ自体によって、そのようなアプリケーションでは、「公共」のクライアントと考えられます。アプリケーションのソース・コードまたは関連するリソースバンドルに焼き付け秘密は、リバースエンジニアリングから保護することができません。これはすぐに作品のうち、すべてのインストールを置くので、第二に、そのような秘密は、取り消すことはできません。認証サーバが本当にクライアントの識別子を信頼することはできませんので、ユーザーにクライアントの信頼を終了する示すために危険です。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Use Standard Web Server Protection Measures (for Config Files and Databases)",
      "ja": "5.3.2。 （コンフィグファイルやデータベースのための）標準のWebサーバ保護対策を使用します"
    },
    {
      "indent": 3,
      "text": "Use standard web server protection and configuration measures to protect the integrity of the server, databases, configuration files, and other operational components of the server.",
      "ja": "標準的なWebサーバーの保護と構成のサーバーの完全性を保護するための措置、データベース、コンフィギュレーションファイル、およびサーバーの他の動作コンポーネントを使用してください。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Store Secrets in Secure Storage",
      "section_title": true,
      "ja": "5.3.3。セキュアストレージに保管して秘密"
    },
    {
      "indent": 3,
      "text": "There are different ways to store secrets of all kinds (tokens, client secrets) securely on a device or server.",
      "ja": "セキュアデバイスまたはサーバー上のすべての種類（トークン、クライアントの秘密）の秘密を格納するためのさまざまな方法があります。"
    },
    {
      "indent": 3,
      "text": "Most multi-user operating systems segregate the personal storage of different system users. Moreover, most modern smartphone operating systems even support the storage of application-specific data in separate areas of file systems and protect the data from access by other applications. Additionally, applications can implement confidential data by using a user-supplied secret, such as a PIN or password.",
      "ja": "ほとんどのマルチユーザー・オペレーティング・システムは、異なるシステムユーザーの個人的なストレージを分離します。また、最新のスマートフォンのオペレーティングシステムでも、ファイルシステムの別の領域でのアプリケーション固有のデータの格納をサポートし、他のアプリケーションによるアクセスからデータを保護します。さらに、アプリケーションは、PINやパスワードなど、ユーザー提供の秘密を使用して機密データを実装することができます。"
    },
    {
      "indent": 3,
      "text": "Another option is to swap refresh token storage to a trusted backend server. This option in turn requires a resilient authentication mechanism between the client and backend server. Note: Applications should ensure that confidential data is kept confidential even after reading from secure storage, which typically means keeping this data in the local memory of the application.",
      "ja": "別のオプションは、信頼できるバックエンドサーバにリフレッシュトークンストレージを交換することです。順番にこのオプションは、クライアントとバックエンドサーバーの間の弾力性の認証メカニズムを必要とします。注：アプリケーションは、機密データは、通常、アプリケーションのローカルメモリにこのデータを保つ意味でも、セキュアストレージから読み込んだ後、機密保持されていることを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.4. Utilize Device Lock to Prevent Unauthorized Device Access",
      "section_title": true,
      "ja": "5.3.4。不正なデバイスアクセスを防止するためのデバイスロックを活用"
    },
    {
      "indent": 3,
      "text": "On a typical modern phone, there are many \"device lock\" options that can be utilized to provide additional protection when a device is stolen or misplaced. These include PINs, passwords, and other biometric features such as \"face recognition\". These are not equal in the level of security they provide.",
      "ja": "典型的な近代的な携帯電話では、デバイスが盗まれたり紛失された場合、追加の保護を提供するために利用することができ、多くの「デバイスのロック」オプションがあります。これらは、「顔認識」などのPIN、パスワード、および他の生体認証機能を備えています。これらは、それらが提供するセキュリティのレベルが同じではありません。"
    },
    {
      "indent": 0,
      "text": "5.3.5. Link the \"state\" Parameter to User Agent Session",
      "section_title": true,
      "ja": "5.3.5。ユーザエージェントのセッションに「状態」パラメータのリンク"
    },
    {
      "indent": 3,
      "text": "The \"state\" parameter is used to link client requests and prevent CSRF attacks, for example, attacks against the redirect URI. An attacker could inject their own authorization \"code\" or access token, which can result in the client using an access token associated with the attacker's protected resources rather than the victim's (e.g., save the victim's bank account information to a protected resource controlled by the attacker).",
      "ja": "「状態」パラメータは、例えば、クライアントの要求をリンクし、CSRF攻撃を防ぐために使用され、リダイレクトURIに対する攻撃。攻撃者はではなく、攻撃者の保護されたリソースに関連付けられたアクセストークンを使用して、クライアントになることができ、独自の認証「コード」またはアクセストークンを、注入可能性が被害者（例えば、によって制御される保護されたリソースに被害者の銀行口座情報を保存アタッカー）。"
    },
    {
      "indent": 3,
      "text": "The client should utilize the \"state\" request parameter to send the authorization server a value that binds the request to the user agent's authenticated state (e.g., a hash of the session cookie used to authenticate the user agent) when making an authorization request. Once authorization has been obtained from the end user, the authorization server redirects the end-user's user agent back to the client with the required binding value contained in the \"state\" parameter.",
      "ja": "クライアントは、認証サーバに認証要求を行う際に、ユーザーエージェントの認証された状態（例えば、ユーザエージェントを認証するために使用されるセッションクッキーのハッシュ）に要求をバインドする値を送信するために、「状態」リクエストパラメータを利用すべきです。認証は、エンドユーザから取得された後、認証サーバは、「状態」パラメータに含まれている必要とされる結合値で、クライアントにエンドユーザーのユーザーエージェントをリダイレクトします。"
    },
    {
      "indent": 3,
      "text": "The binding value enables the client to verify the validity of the request by matching the binding value to the user agent's authenticated state.",
      "ja": "結合値はユーザエージェントの認証された状態に結合値を照合することによって、要求の妥当性を検証するために、クライアントを可能にします。"
    },
    {
      "indent": 0,
      "text": "5.4. Resource Servers",
      "section_title": true,
      "ja": "5.4。リソースサーバ"
    },
    {
      "indent": 3,
      "text": "The following section details security considerations for resource servers.",
      "ja": "次のセクションでは、リソース・サーバーのセキュリティー上の考慮事項について詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "5.4.1. Authorization Headers",
      "section_title": true,
      "ja": "5.4.1。認証ヘッダ"
    },
    {
      "indent": 3,
      "text": "Authorization headers are recognized and specially treated by HTTP proxies and servers. Thus, the usage of such headers for sending access tokens to resource servers reduces the likelihood of leakage or unintended storage of authenticated requests in general, and especially Authorization headers.",
      "ja": "認証ヘッダが認識され、特別にHTTPプロキシおよびサーバによって処理されています。このように、サーバーのリソースへのアクセストークンを送信するために、ヘッダの使用は、漏洩や認証された一般的な要求、特に認証ヘッダの意図しない保存の可能性を低減します。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Authenticated Requests",
      "section_title": true,
      "ja": "5.4.2。認証済みのリクエスト"
    },
    {
      "indent": 3,
      "text": "An authorization server may bind tokens to a certain client identifier and enable resource servers to validate that association on resource access. This will require the resource server to authenticate the originator of a request as the legitimate owner of a particular token. There are several options to implement this countermeasure:",
      "ja": "認証サーバは、特定のクライアント識別子にトークンを結合して、リソースへのアクセスにその関連性を検証するために、リソースサーバを有効にすることができます。これは、特定のトークンの正当な所有者として要求の発信元を認証するために、リソースサーバが必要になります。この対策を実装するには、いくつかのオプションがあります。"
    },
    {
      "indent": 3,
      "text": "o The authorization server may associate the client identifier with the token (either internally or in the payload of a self-contained token). The client then uses client certificate-based HTTP authentication on the resource server's endpoint to authenticate its identity, and the resource server validates the name with the name referenced by the token.",
      "ja": "O認証サーバは、トークン（内部または自己完結型のトークンのペイロード内の）を使用してクライアント識別子を関連付けることができます。クライアントは、そのIDを認証するために、リソースサーバーのエンドポイント上のクライアント証明書ベースのHTTP認証を使用し、リソースサーバは、トークンによって参照された名前の名前を検証します。"
    },
    {
      "indent": 3,
      "text": "o Same as the option above, but the client uses his private key to sign the request to the resource server (the public key is either contained in the token or sent along with the request).",
      "ja": "上記のオプションと同じOが、クライアントは（公開鍵がトークンに含まれているか、要求とともに送信されるか）、リソースサーバーへの要求に署名するために彼の秘密鍵を使用しています。"
    },
    {
      "indent": 3,
      "text": "o Alternatively, the authorization server may issue a token-bound key, which the client uses in a Holder-of-Key proof to authenticate the client's use of the token. The resource server obtains the secret directly from the authorization server, or the secret is contained in an encrypted section of the token. In that way, the resource server does not \"know\" the client but is able to validate whether the authorization server issued the token to that client.",
      "ja": "Oまた、認証サーバは、クライアントがトークンのクライアントの使用を認証するためにホルダー-のキー証明に使用するトークン結合キーを、発行することができます。リソースサーバは、認証サーバから直接秘密を取得し、または秘密は、トークンの暗号化されたセクションに含まれています。このように、リソースサーバーは、クライアントを「知っている」が、認証サーバは、そのクライアントにトークンを発行したかどうかを検証することができません。"
    },
    {
      "indent": 3,
      "text": "Authenticated requests are a countermeasure against abuse of tokens by counterfeit resource servers.",
      "ja": "認証された要求は、偽造リソースサーバによってトークンの乱用対策です。"
    },
    {
      "indent": 0,
      "text": "5.4.3. Signed Requests",
      "section_title": true,
      "ja": "5.4.3。署名付きリクエスト"
    },
    {
      "indent": 3,
      "text": "A resource server may decide to accept signed requests only, either to replace transport-level security measures or to complement such measures. Every signed request should be uniquely identifiable and should not be processed twice by the resource server. This countermeasure helps to mitigate:",
      "ja": "リソースサーバーにのみ署名要求を受け入れるように、どちらかのトランスポート・レベルのセキュリティ対策を交換したり、そのような措置を補完するように決定することができます。すべての署名要求を一意に識別する必要がありますし、リソースサーバで2回処理するべきではありません。この対策は軽減するのに役立ちます："
    },
    {
      "indent": 3,
      "text": "o modifications of the message and",
      "ja": "メッセージのO修飾および"
    },
    {
      "indent": 3,
      "text": "o replay attempts",
      "ja": "Oリプレイの試み"
    },
    {
      "indent": 0,
      "text": "5.5. A Word on User Interaction and User-Installed Apps",
      "section_title": true,
      "ja": "5.5。ユーザーの操作とユーザーがインストールしたアプリのことば"
    },
    {
      "indent": 3,
      "text": "OAuth, as a security protocol, is distinctive in that its flow usually involves significant user interaction, making the end user a part of the security model. This creates some important difficulties in defending against some of the threats discussed above. Some of these points have already been made, but it's worth repeating and highlighting them here.",
      "ja": "OAuthのは、セキュリティプロトコルとして、その流れは、通常、エンドユーザセキュリティモデルの一部を作り、重要なユーザインタラクションを必要とするという点で独特です。これは、上述の脅威のいくつかの防御にいくつかの重要な困難を作成します。これらの点のいくつかはすでに行われているが、それは繰り返し、ここではそれらを強調する価値があります。"
    },
    {
      "indent": 3,
      "text": "o End users must understand what they are being asked to approve (see Section 5.2.4.2). Users often do not have the expertise to understand the ramifications of saying \"yes\" to an authorization request and are likely not to be able to see subtle differences in the wording of requests. Malicious software can confuse the user, tricking the user into approving almost anything.",
      "ja": "Oエンドユーザーは、それらが（セクション5.2.4.2を参照）を承認するよう求められているかを理解しなければなりません。ユーザーは、多くの場合、認証要求に「はい」と言っての波及効果を理解するための専門知識を持っており、要求の文言の微妙な違いを見ることができていない可能性がありません。不正なソフトウェアにはほとんど何の承認にユーザーをだまし、ユーザーを混乱させることができます。"
    },
    {
      "indent": 3,
      "text": "o End-user devices are prone to software compromise. This has been a long-standing problem, with frequent attacks on web browsers and other parts of the user's system. But with the increasing popularity of user-installed \"apps\", the threat posed by compromised or malicious end-user software is very strong and is one that is very difficult to mitigate.",
      "ja": "Oエンドユーザデバイスは、ソフトウェア妥協する傾向があります。これは、Webブラウザやユーザのシステムの他の部分に頻繁に攻撃に、長年の課題でした。しかし、ユーザーがインストールした「ア​​プリケーション」の人気の高まりとともに、侵害または悪質なエンドユーザーのソフトウェアの脅威は非常に強力で、軽減することは非常に困難なものです。"
    },
    {
      "indent": 3,
      "text": "o Be aware that users will demand to install and run such apps, and that compromised or malicious ones can steal credentials at many points in the data flow. They can intercept the very user login credentials that OAuth is designed to protect. They can request authorization far beyond what they have led the user to understand and approve. They can automate a response on behalf of the user, hiding the whole process. No solution is offered here, because none is known; this remains in the space between better security and better usability.",
      "ja": "Oユーザーがインストールして、このようなアプリケーションを実行するように要求することに注意してください、そしてその妥協や悪意のあるものは、データフロー内の多くのポイントで認証情報を盗むことができます。彼らは、OAuthのを保護するように設計された非常にユーザーのログイン資格情報を傍受することができます。彼らはこれまで彼らが理解し、承認するユーザーを導いてきたものを超えて許可を要求することができます。彼らは、全体のプロセスを隠し、ユーザーに代わって応答を自動化することができます。何も知られていないので、解決策は、ここに提供されていません。これは、より高いセキュリティと優れた利便性との間の空間に残っています。"
    },
    {
      "indent": 3,
      "text": "o Addressing these issues by restricting the use of user-installed software may be practical in some limited environments and can be used as a countermeasure in those cases. Such restrictions are not practical in the general case, and mechanisms for after-the-fact recovery should be in place.",
      "ja": "ユーザがインストールされたソフトウェアの使用を制限することによって、これらの問題への対処oを、いくつかの限られた環境では実用的であってもよく、その場合に対策として使用することができます。このような制限は、一般的なケースでは実用的ではない、と事後の回復のためのメカニズムが場所にする必要があります。"
    },
    {
      "indent": 3,
      "text": "o While end users are mostly incapable of properly vetting applications they load onto their devices, those who deploy authorization servers might have tools at their disposal to mitigate malicious clients. For example, a well-run authorization server must only assert client properties to the end user it is effectively capable of validating, explicitly point out which properties it cannot validate, and indicate to the end user the risk associated with granting access to the particular client.",
      "ja": "エンドユーザーは、彼らが自分のデバイスにロードし、適切に吟味アプリケーションのほとんどができないまま、o、認証サーバーを展開する人は、悪意のあるクライアントを軽減するために彼らの処分でツールを持っているかもしれません。例えば、よく実行する認証サーバは、明示的にのみ、それが効果的に検証することができ、エンドユーザへのクライアントのプロパティを主張することは検証できない性質を指摘し、エンドユーザーに示す必要があり、特定のクライアントへのアクセスを許可に関連するリスク。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgements",
      "section_title": true,
      "ja": "6.謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Stephen Farrell, Barry Leiba, Hui-Lan Lu, Francisco Corella, Peifung E. Lam, Shane B. Weeden, Skylar Woodward, Niv Steingarten, Tim Bray, and James H. Manger for their comments and contributions.",
      "ja": "我々は彼らのコメントと貢献のためにスティーブン・ファレル、バリー・レイバ、ホイ-LAN呂、サンフランシスコCorella、Peifung E.ラム、シェーンB.ウィーデン、Skylarウッドワード、NIV Steingarten、ティム・ブレイ、そしてジェームズ・H.マネージャに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., \"The OAuth 2.0 Authorization Framework\", RFC 6749, October 2012.",
      "ja": "[RFC6749]ハルト、D.、 \"OAuth 2.0の認証フレームワーク\"、RFC 6749、2012年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC6750] Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization Framework: Bearer Token Usage\", RFC 6750, October 2012.",
      "ja": "[RFC6750]ジョーンズ、M.とD.ハルト、 \"OAuth 2.0の認証フレームワーク：ベアラートークンの使用\"、RFC 6750、2012年10月。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[Framebusting] Rydstedt, G., Bursztein, Boneh, D., and C. Jackson, \"Busting Frame Busting: a Study of Clickjacking Vulnerabilities on Popular Sites\", IEEE 3rd Web 2.0 Security and Privacy Workshop, May 2010, <http://elie.im/ publication/busting-frame-busting-a-study-of-clickjacking-vulnerabilities-on-popular-sites>.",
      "ja": "[Framebusting] Rydstedt、G.、Bursztein、Boneh、D.、およびC.ジャクソン、 \"バスティングバスティングフレーム：人気サイト上のクリックジャッキング脆弱性の研究\"、IEEE第3回Web 2.0のセキュリティとプライバシーのワークショップ、2010年5月、<のhttp： //elie.im/出版/>フレームつぶし-研究・オブ・クリックジャッキング・脆弱性・オン・人気・サイトをつぶし。"
    },
    {
      "indent": 3,
      "text": "[IMEI] 3GPP, \"International Mobile station Equipment Identities (IMEI)\", 3GPP TS 22.016 11.0.0, September 2012, <http://www.3gpp.org/ftp/Specs/html-info/22016.htm>.",
      "ja": "[IMEI] 3GPP、 \"国際モバイルステーション機器アイデンティティ（IMEI）\"、3GPP TS 22.016 11.0.0、2012年9月、<http://www.3gpp.org/ftp/Specs/html-info/22016.htm>。"
    },
    {
      "indent": 3,
      "text": "[OASIS.saml-core-2.0-os] Cantor, S., Ed., Kemp, J., Ed., Philpott, R., Ed., and E. Maler, Ed., \"Assertions and Protocols for the OASIS Security Assertion Markup Language (SAML) V2.0\", OASIS Standard saml-core-2.0-os, March 2005, <http://docs.oasis-open.org/security/saml/ v2.0/saml-core-2.0-os.pdf>.",
      "ja": "[OASIS.samlコア-2.0-OS]カントール、S.編、ケンプ、J.、編、フィルポット、R.、編、及びE. MALER編、「OASISのためのアサーションとプロトコルSAML（Security Assertion Markup Language）V2.0\" 、OASIS標準のSAML-コア-2.0-OS、2005年3月、<http://docs.oasis-open.org/security/saml/ V2.0 / SAML、コア - 2.0-os.pdf>。"
    },
    {
      "indent": 3,
      "text": "[OASIS.sstc-saml-bindings-1.1] Maler, E., Ed., Mishra, P., Ed., and R. Philpott, Ed., \"Bindings and Profiles for the OASIS Security Assertion Markup Language (SAML) V1.1\", September 2003, <http://www.oasis-open.org/committees/download.php/3405/ oasis-sstc-saml-bindings-1.1.pdf>.",
      "ja": "[OASIS.sstc-SAMLバインディング-1.1] OASISセキュリティアサーションマークアップ言語（SAML）V1用MALER、E.、編、ミシュラ、P.編、及びR.フィルポット編、「バインディングおよびプロファイル0.1\" 、2003年9月、<http://www.oasis-open.org/committees/download.php/3405/オアシス-SSTC  -  SAMLバインディング -  1.1.pdf>。"
    },
    {
      "indent": 3,
      "text": "[OASIS.sstc-sec-analysis-response-01] Linn, J., Ed., and P. Mishra, Ed., \"SSTC Response to \"Security Analysis of the SAML Single Sign-on Browser/ Artifact Profile\"\", January 2005, <http://www.oasis-open.org/committees/download.php/ 11191/sstc-gross-sec-analysis-response-01.pdf>.",
      "ja": "[OASIS.sstc-SEC-分析応答-01]リン、J.、エド。、およびP.ミシュラ、エド。、セキュリティ分析SAMLシングルの \"へSSTC応答 \"サインオンのブラウザ/アーティファクトプロファイル\"\"、 2005年1月、<http://www.oasis-open.org/committees/download.php/ 11191 / SSTC-総-SEC-分析応答-01.pdf>。"
    },
    {
      "indent": 3,
      "text": "[OAuth-ASSERTIONS] Campbell, B., Mortimore, C., Jones, M., and Y. Goland, \"Assertion Framework for OAuth 2.0\", Work in Progress, December 2012.",
      "ja": "[OAuthの-アサーション]キャンベル、B.、Mortimore、C.、ジョーンズ、M.、およびY. Goland、 \"OAuth 2.0のためのアサーションフレームワーク\"、進歩、2012年12月に働いています。"
    },
    {
      "indent": 3,
      "text": "[OAuth-HTTP-MAC] Richer, J., Ed., Mills, W., Ed., and H. Tschofenig, Ed., \"OAuth 2.0 Message Authentication Code (MAC) Tokens\", Work in Progress, November 2012.",
      "ja": "[OAuthの-HTTP-MAC]豊かな、J.、編、ミルズ、W.、編、及びH. Tschofenig、編、 \"OAuth 2.0のメッセージ認証コード（MAC）トークン\" を、進歩、2012年11月に働いています。"
    },
    {
      "indent": 3,
      "text": "[OAuth-JWT] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token (JWT)\", Work in Progress, December 2012.",
      "ja": "[OAuthの-JWT]ジョーンズ、M.、ブラッドリー、J。、およびN. Sakimura、 \"JSONウェブトークン（JWT）\"、進歩、2012年12月に働いています。"
    },
    {
      "indent": 3,
      "text": "[OAuth-REVOCATION] Lodderstedt, T., Ed., Dronia, S., and M. Scurtescu, \"Token Revocation\", Work in Progress, November 2012.",
      "ja": "[OAuthの-取消] Lodderstedt、T.、エド。、Dronia、S.、およびM. Scurtescu、 \"トークン失効\"、進歩、2012年11月での作業。"
    },
    {
      "indent": 3,
      "text": "[OPENID] \"OpenID Foundation Home Page\", <http://openid.net/>.",
      "ja": "[OpenIDの] \"のOpenID Foundationのホームページ\"、<http://openid.net/>。"
    },
    {
      "indent": 3,
      "text": "[OWASP] \"Open Web Application Security Project Home Page\", <https://www.owasp.org/>.",
      "ja": "[OWASP] \"オープンWebアプリケーションセキュリティプロジェクトホームページ\"、<https://www.owasp.org/>。"
    },
    {
      "indent": 3,
      "text": "[Portable-Contacts] Smarr, J., \"Portable Contacts 1.0 Draft C\", August 2008, <http://portablecontacts.net/>.",
      "ja": "[ポータブル連絡先] Smarr、J.、 \"ポータブルコンタクト1.0ドラフトC\"、2008年8月、<http://portablecontacts.net/>。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.",
      "ja": "[RFC2818]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4120] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The Kerberos Network Authentication Service (V5)\", RFC 4120, July 2005.",
      "ja": "[RFC4120]ノイマン、C.、ゆう、T.、ハルトマン、S.、およびK.レイバーン、 \"ケルベロスネットワーク認証サービス（V5）\"、RFC 4120、2005年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[RFC4301]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[SSL-Latency] Sissel, J., Ed., \"SSL handshake latency and HTTPS optimizations\", June 2010.",
      "ja": "[SSL-レイテンシ]シセル、J.、エド。、 \"SSLハンドシェークの待ち時間とHTTPSの最適化\"、2010年6月。"
    },
    {
      "indent": 3,
      "text": "[Sec-Analysis] Gross, T., \"Security Analysis of the SAML Single Sign-on Browser/Artifact Profile\", 19th Annual Computer Security Applications Conference, Las Vegas, December 2003.",
      "ja": "[秒-分析]グロス、T.、「SAMLシングルのセキュリティ分析ブラウザ/アーティファクトプロファイルに-SIGN」、第19回コンピュータセキュリティアプリケーションの会議、ラスベガス、2003年12月。"
    },
    {
      "indent": 3,
      "text": "[X-Frame-Options] Ross, D. and T. Gondrom, \"HTTP Header X-Frame-Options\", Work in Progress, October 2012.",
      "ja": "[X-フレーム・オプション]ロス、D.とT. Gondrom、 \"HTTPヘッダX-フレーム・オプション\"、進歩、2012年10月での作業。"
    },
    {
      "indent": 3,
      "text": "[iFrame] World Wide Web Consortium, \"Frames in HTML documents\", W3C HTML 4.01, December 1999, <http://www.w3.org/TR/html4/present/frames.html#h-16.5>.",
      "ja": "[iFrameの]ワールド・ワイド・ウェブ・コンソーシアム、 \"HTMLドキュメントのフレーム\"、W3C HTML 4.01、1999年12月、<http://www.w3.org/TR/html4/present/frames.html#h-16.5>。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Torsten Lodderstedt (editor) Deutsche Telekom AG",
      "ja": "トルステン・Lodderstedt（エディタ）は、ドイツテレコム・アーゲー"
    },
    {
      "indent": 3,
      "text": "EMail: torsten@lodderstedt.net",
      "ja": "メールアドレス：torsten@lodderstedt.net"
    },
    {
      "indent": 3,
      "text": "Mark McGloin IBM",
      "ja": "マークMcGloin IBM"
    },
    {
      "indent": 3,
      "text": "EMail: mark.mcgloin@ie.ibm.com",
      "ja": "メールアドレス：mark.mcgloin@ie.ibm.com"
    },
    {
      "indent": 3,
      "text": "Phil Hunt Oracle Corporation",
      "ja": "フィル・ハントオラクル・コーポレーション"
    },
    {
      "indent": 3,
      "text": "EMail: phil.hunt@yahoo.com",
      "ja": "メールアドレス：phil.hunt@yahoo.com"
    }
  ]
}