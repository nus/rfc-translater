{
  "title": {
    "text": "RFC 6680 - Generic Security Service Application Programming Interface (GSS-API) Naming Extensions",
    "ja": "RFC 6680 - 一般的なセキュリティサービスアプリケーションプログラミングインターフェイス（GSS-API）の命名拡張機能"
  },
  "number": 6680,
  "created_at": "2019-10-29 04:17:02.732491+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       N. Williams\nRequest for Comments: 6680                             Cryptonector, LLC\nCategory: Standards Track                                   L. Johansson\nISSN: 2070-1721                                                    SUNET\n                                                              S. Hartman\n                                                       Painless Security\n                                                            S. Josefsson\n                                                                  SJD AB\n                                                             August 2012",
      "raw": true
    },
    {
      "indent": 2,
      "text": "Generic Security Service Application Programming Interface (GSS-API) Naming Extensions",
      "ja": "一般的なセキュリティサービスアプリケーションプログラミングインターフェイス（GSS-API）の命名拡張機能"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Generic Security Service Application Programming Interface (GSS-API) provides a simple naming architecture that supports name-based authorization. This document introduces new APIs that extend the GSS-API naming model to support name attribute transfer between GSS-API peers.",
      "ja": "一般的なセキュリティサービスアプリケーションプログラミングインターフェイス（GSS-API）は、名前ベースの認証をサポートする単純な命名アーキテクチャを提供します。このドキュメントでは、GSS-APIピア間name属性の転送をサポートするために、GSS-APIの命名モデルを拡張する新しいAPIが導入されました。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6680.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6680で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2012 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。のセクション4.eで説明したように、コードのコンポーネントは、簡素化されたBSDライセンスのテキストを含める必要があり、この文書から抽出されました"
    },
    {
      "indent": 3,
      "text": "the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "トラスト法規定および簡体BSDライセンスで説明したように、保証なしで提供されています。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n2.  Conventions Used in This Document  . . . . . . . . . . . . . .  3\n3.  Name Attribute Authenticity  . . . . . . . . . . . . . . . . .  4\n4.  Name Attributes/Values as ACL Subjects . . . . . . . . . . . .  4\n5.  Naming Contexts  . . . . . . . . . . . . . . . . . . . . . . .  4\n6.  Representation of Attribute Names  . . . . . . . . . . . . . .  6\n7.  API  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  7\n  7.1.  SET OF OCTET STRING  . . . . . . . . . . . . . . . . . . .  7\n  7.2.  Const Types  . . . . . . . . . . . . . . . . . . . . . . .  8\n  7.3.  GSS_Display_name_ext() . . . . . . . . . . . . . . . . . .  8\n    7.3.1.  C-Bindings . . . . . . . . . . . . . . . . . . . . . .  9\n  7.4.  GSS_Inquire_name() . . . . . . . . . . . . . . . . . . . .  9\n    7.4.1.  C-Bindings . . . . . . . . . . . . . . . . . . . . . . 10\n  7.5.  GSS_Get_name_attribute() . . . . . . . . . . . . . . . . . 10\n    7.5.1.  C-Bindings . . . . . . . . . . . . . . . . . . . . . . 11\n  7.6.  GSS_Set_name_attribute() . . . . . . . . . . . . . . . . . 12\n    7.6.1.  C-Bindings . . . . . . . . . . . . . . . . . . . . . . 13\n  7.7.  GSS_Delete_name_attribute()  . . . . . . . . . . . . . . . 14\n    7.7.1.  C-Bindings . . . . . . . . . . . . . . . . . . . . . . 14\n  7.8.  GSS_Export_name_composite()  . . . . . . . . . . . . . . . 14\n    7.8.1.  C-Bindings . . . . . . . . . . . . . . . . . . . . . . 15\n8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 15\n9.  Security Considerations  . . . . . . . . . . . . . . . . . . . 16\n10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n  10.1. Normative References . . . . . . . . . . . . . . . . . . . 17\n  10.2. Informative References . . . . . . . . . . . . . . . . . . 17",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "As described in [RFC4768], the GSS-API's naming architecture suffers from certain limitations. This document attempts to overcome these limitations.",
      "ja": "[RFC4768]に記載されているように、GSS-APIのネーミング・アーキテクチャは、特定の制限を受けます。この文書では、これらの制限を克服しようとします。"
    },
    {
      "indent": 3,
      "text": "A number of extensions to the GSS-API [RFC2743] and its C-bindings [RFC2744] are described herein. The goal is to make information modeled as \"name attributes\" available to applications. Such information MAY, for instance, be used by applications to make authorization decisions. For example, Kerberos V authorization data elements, both in their raw forms as well as mapped to more useful value types, can be made available to GSS-API applications through these interfaces.",
      "ja": "GSS-API [RFC2743]及びそのC-バインディング[RFC2744]の拡張機能の数は、本明細書に記載されています。目標は、アプリケーションで使用できる「名前属性」としてモデル化された情報を作ることです。このような情報は、例えば、許可の決定を行うためのアプリケーションで使用されるかもしれません。例えば、ケルベロスV認証データ要素、それらの生の形態で、ならびにより有用な値型にマップの両方が、これらのインタフェースを介してGSS-APIアプリケーションに利用可能にすることができます。"
    },
    {
      "indent": 3,
      "text": "The model is that GSS names have attributes. The attributes of a name may be authenticated (e.g., an X509 attribute certificate or signed Security Assertion Markup Language (SAML) attribute assertion) or may have been set on a GSS name for the purpose of locally \"asserting\" the attribute during credential acquisition or security context exchange. Name attributes' values are network representations thereof (e.g., the actual value octets of the contents of an X.509 certificate extension, for example) and are intended to be useful for constructing portable access control facilities. Applications may often require language- or platform-specific data types, rather than network representations of name attributes, so a function is provided to obtain objects of such types associated with names and name attributes.",
      "ja": "モデルは、GSS名が属性を持っているということです。名前の属性が認証されてもよい（例えば、X509属性証明書や署名のSAML（Security Assertion Markup Language）アサーション属性）資格の取得または中に属性を「アサート」またはローカルでの目的のためにGSS名に設定されている可能性がありセキュリティコンテキスト交換。名前属性の値は、（例えば、実際の値のX.509証明書拡張の内容のオクテットなど）と、携帯アクセス制御機能を構築するために有用であることが意図されているネットワークの表現です。アプリケーションは、多くの場合、言語またはプラットフォーム固有のデータ型ではなく、名前属性のネットワーク表現を必要とするかもしれないので、関数は、名前属性名と関連付けられたようなタイプのオブジェクトを取得するために設けられています。"
    },
    {
      "indent": 3,
      "text": "Future updates of this specification may involve adding an attribute namespace for attributes that only have application-specific semantics. Note that mechanisms will still need to know how to transport such attributes. The IETF may also wish to add functions by which to inquire whether a mechanism(s) understands a given attribute name or namespace and to list which attributes or attribute namespaces a mechanism understands. Finally, the IETF may want to consider adding a function by which to determine the name of the issuer of a name attribute.",
      "ja": "この仕様の今後の更新は、アプリケーション固有の意味を持つ属性の属性の名前空間を追加することを含むことができます。メカニズムはまだそのような属性を輸送する方法を知っておく必要があることに注意してください。 IETFはまた、メカニズム（s）は、指定された属性名または名前空間を理解しているかどうかを照会すると、属性または属性がメカニズムが理解名前空間どのリストしたことにより、機能を追加したい場合があります。最後に、IETFは、name属性の発行者の名前を決定することで機能を追加することを検討することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "2. Conventions Used in This Document",
      "section_title": true,
      "ja": "この文書で使用される2.表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Name Attribute Authenticity",
      "section_title": true,
      "ja": "3. name属性信憑"
    },
    {
      "indent": 3,
      "text": "An attribute is \"authenticated\" if and only if there is a secure association between the attribute (and its values) and the trusted source of the peer credential. Examples of authenticated attributes are (any part of) the signed portion of an X.509 certificate or AD-KDCIssued authorization data elements (Section 5.2.6.2 of [RFC4120]) in Kerberos V Tickets, provided, of course, that the authenticity of the respective security associations (e.g., signatures) has been verified.",
      "ja": "属性は、属性（およびその値）とピア・クレデンシャルの信頼できるソースとの間の安全な関連がある場合にのみ、「認証」されています。の真偽ことが認証された属性の例には、当然の提供ケルベロスVチケットにX.509証明書またはAD-KDCIssued認可データ要素（[RFC4120]のセクション5.2.6.2）の署名された部分（の一部）でありますそれぞれのセキュリティアソシエーション（例えば、署名が）確認されました。"
    },
    {
      "indent": 3,
      "text": "Note that the fact that an attribute is authenticated does not imply anything about the semantics of the attribute nor that the trusted credential source was authorized to assert the attribute. Such interpretations SHOULD be the result of applying local policy to the attribute.",
      "ja": "属性が認証されているという事実は、属性の意味についても、信頼できる資格ソースは属性を主張する権限を与えられたことは何も意味しないことに注意してください。このような解釈は、属性にローカルポリシーを適用した結果であるべきです。"
    },
    {
      "indent": 3,
      "text": "An unauthenticated attribute is called _asserted_ in what follows. This is not to be confused with other uses of the words \"asserted\" or \"assertion\" such as \"SAML attribute assertion\", the attributes of which may be authenticated in the sense of this document, for instance, if the SAML attribute assertion was signed by a key trusted by the peer.",
      "ja": "認証されていない属性は、以下のものの中に_asserted_と呼ばれています。これは言葉の他の用途と混同しないようにされ、「アサート」または「アサーション」など「SAML属性アサーション」、SAML属性場合の属性は、例えば、この文書の意味で認証することができるよう主張でしたピアが信頼する鍵で署名。"
    },
    {
      "indent": 0,
      "text": "4. Name Attributes/Values as ACL Subjects",
      "section_title": true,
      "ja": "4.名前はACL科目として/属性値"
    },
    {
      "indent": 3,
      "text": "To facilitate the development of portable applications that make use of name attributes to construct and evaluate portable Access Control Lists (ACLs), the GSS-API makes name attribute values available in canonical network encodings thereof.",
      "ja": "名前の使用は、ポータブルアクセス制御リスト（ACL）を構築し、評価するために、属性を作るのポータブルアプリケーションの開発を容易にするために、GSS-APIは、標準的なネットワークのエンコーディングでname属性の値が使用可能になります。"
    },
    {
      "indent": 0,
      "text": "5. Naming Contexts",
      "section_title": true,
      "ja": "5.ネーミング・コンテキスト"
    },
    {
      "indent": 3,
      "text": "Several factors influence the context in which a name attribute is interpreted. One is the trust context.",
      "ja": "いくつかの要因が、name属性が解釈されるコンテキストに影響を与えます。一つは、信頼コンテキストです。"
    },
    {
      "indent": 3,
      "text": "As discussed previously, applications apply local policy to determine whether a particular peer credential issuer is trusted to make a given statement. Different GSS-API mechanisms and deployments have different trust models surrounding attributes they provide about a name.",
      "ja": "前述したように、アプリケーションは、特定のピアクレデンシャル発行者は、特定の文を作るために信頼されているかどうかを判断するためにローカルポリシーを適用します。別のGSS-APIメカニズムと展開は、彼らが名前について提供する属性を取り巻くさまざまな信頼モデルを持っています。"
    },
    {
      "indent": 3,
      "text": "For example, Kerberos deployments in the enterprise typically trust a Key Distribution Center (KDC) to make any statement about principals in a realm. This includes attributes such as group membership.",
      "ja": "例えば、企業内のKerberosの展開は、通常、レルム内のプリンシパルについての声明をするためにキー配布センター（KDC）を信頼しています。これは、グループメンバーシップなどの属性が含まれています。"
    },
    {
      "indent": 3,
      "text": "In contrast, in a federated SAML environment, the identity provider typically exists in a different organization than the acceptor. In this case, the set of group memberships or entitlements that the IDP is permitted to make needs to be filtered by the policy of the acceptor and federation.",
      "ja": "これとは対照的に、フェデレーションSAML環境では、アイデンティティプロバイダは、通常、アクセプターとは別の組織に存在します。この場合、グループメンバーシップ、またはIDPニーズを行うことが許可されている権利のセットは、アクセプタとフェデレーションのポリシーによってフィルタリングされます。"
    },
    {
      "indent": 3,
      "text": "So even an attribute containing the same information, such as email address, would need to be treated differently by the application in the context of an enterprise deployment from the context of a federation.",
      "ja": "そうであっても、同じ情報を含む属性は、電子メールアドレスなど、フェデレーションの文脈からエンタープライズ展開の文脈におけるアプリケーションによって異なる扱いをする必要があります。"
    },
    {
      "indent": 3,
      "text": "Another aspect related to trust is the role of the credential issuer in providing the attribute. Consider Public Key Cryptography for Initial Authentication in Kerberos (PKINIT) [RFC4556]. In this protocol, a public key and associated certificate are used to authenticate to a Kerberos KDC. Consider how attributes related to a PKINIT certificate should be made available in GSS-API authentications based on the Kerberos ticket. In some deployments, the certificate may be fully trusted; by including the certificate information in the ticket, the KDC permits the acceptor to trust the information in the certificate just as if the KDC itself had made these statements. In other deployments, the KDC may have authorized a hash of the certificate without evaluating the content of the certificate or generally trusting the issuing certification authority. In this case, if the certificate were included in the issued ticket, the KDC would only be making the statement that the certificate was used in the authentication. This statement would be authenticated but would not imply that the KDC asserted that particular attributes of the certificate accurately described the initiator.",
      "ja": "信託に関連する別の態様は、属性を提供する資格発行者の役割です。ケルベロスにおける初期認証のための公開鍵暗号（PKINIT）[RFC4556]を考えてみましょう。このプロトコルでは、公開鍵および関連する証明書は、Kerberos KDCへの認証に使用されています。 PKINIT証明書に関連する属性は、Kerberosチケットに基づいてGSS-APIの認証に利用できるようにすべきか考えてみましょう。いくつかの展開では、証明書が完全に信頼することができます。チケット内の証明書情報を含むことによって、KDCは、KDC自体がこれらの文を作った場合と同じように、証明書の情報を信頼するようにアクセプタを許可します。他の配置では、KDCは、証明書の内容を評価するか、一般的に発行する認証局を信頼せずに証明書のハッシュを承認している可能性があります。証明書が発行されたチケットに含まれている場合この場合、KDCは唯一の証明書が認証に使用されたという記述を行うことになります。この文は、認証されますが、KDC証明書の特定の属性が正確にイニシエータを説明したと主張していることを意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "Another aspect of context is encoding of the attribute information. An attribute containing an ASCII [ANSI.X3-4.1986] or UTF-8 [RFC3629] version of an email address could not be interpreted the same as an ASN.1 Distinguished Encoding Rules email address in a certificate.",
      "ja": "コンテキストの別の態様は、属性情報の符号化です。電子メールアドレスの属性を含むASCII [ANSI.X3-4.1986]またはUTF-8 [RFC3629]バージョンは、証明書にASN.1の識別符号化規則の電子メールアドレスと同じに解釈することができませんでした。"
    },
    {
      "indent": 3,
      "text": "All of these contextual aspects of a name attribute affect whether two attributes can be treated the same by an application and thus whether they should be considered the same name attribute. In the GSS-API naming extensions, attributes that have different contexts MUST have different names so they can be distinguished by applications. As an unfortunate consequence of this requirement, multiple attribute names will exist for the same basic information. That is, there is no single attribute name for the email address of an initiator. Other aspects of how mechanisms describe information about subjects would already make this true. For example, some mechanisms use OIDs to name attributes; others use URIs.",
      "ja": "name属性のこれらの文脈側面の全ての2つの属性は、アプリケーションによって同じように扱うことができるかどうか、彼らは同じ名前の属性を考慮しなければならないので、かどうかに影響します。拡張子を命名GSS-APIでは、異なるコンテキストを持つ属性は、彼らがアプリケーションで区別できるように異なる名前を持たなければなりません。この要件の不幸な結果として、複数の属性名は、同じ基本的な情報のために存在します。つまり、イニシエータの電子メールアドレスのための単一の属性名がありません。メカニズムは、被験者に関する情報を記述する方法の他の態様は、すでにこれが真なるだろう。例えば、いくつかのメカニズムは、name属性にOIDを使用します。他の人は、URIを使用しています。"
    },
    {
      "indent": 3,
      "text": "Local implementations or platforms are likely to have sufficient policy and information to know when contexts can be treated as the same. For example, the GSS-API implementation may know that a particular certification authority can be trusted in the context of a PKINIT authentication. The local implementation may have sufficient policy to know that a particular credential issuer is trusted to make a given statement. In order to take advantage of this local knowledge within the GSS-API implementation, naming extensions support the concept of local attributes in addition to standard attributes. For example, an implementation might provide a local attribute for email address. The implementation would specify the encoding and representation of this attribute; mechanism-specific standards attributes would be re-encoded if necessary to meet this representation. Only email addresses in contexts that meet the requirements of local policy would be mapped into this local attribute.",
      "ja": "ローカルの実装やプラットフォームは、コンテキストが同じとして扱うことができたときに知るための十分な政策や情報を持っている可能性があります。たとえば、GSS-APIの実装では、特定の認証局は、PKINIT認証のコンテキストで信頼できることを知っているかもしれません。地元の実装は、特定の資格発行者は、特定の文を作るために信頼されていることを知るための十分な政策を持っていることがあります。 GSS-APIの実装内で、この地域の知識を活用するためには、命名の拡張機能は、標準の属性に加えて、ローカル属性の概念をサポートしています。例えば、実装は、電子メールアドレスのローカル属性を提供するかもしれません。実装は、この属性のエンコードと表現を指定します。この表現を満たすために、必要に応じて機構固有の標準属性は、再エンコードされます。ローカルポリシーの要件を満たしている状況でのみ電子メールアドレスは、この地域の属性にマップされます。"
    },
    {
      "indent": 3,
      "text": "Such local attributes inherently expose a trade-off between interoperability and usability. Using a local attribute in an application requires knowledge of the local implementation. However, using a standardized attribute in an application requires more knowledge of policy and more validation logic in the application. Sharing this logic in the local platform provides more consistency across applications as well as reduces implementation costs. Both options are needed.",
      "ja": "このような局所的な属性は、本質的に、相互運用性と利便性とのトレードオフを公開します。アプリケーション内のローカル属性を使用すると、ローカルの実装の知識が必要です。ただし、アプリケーションで標準化された属性を使用して、ポリシーやアプリケーションでより多くの検証ロジックのより多くの知識が必要です。ローカルプラットフォームでこのロジックを共有するアプリケーション間でより一貫性を提供だけでなく、実装コストを削減します。両方のオプションが必要です。"
    },
    {
      "indent": 0,
      "text": "6. Representation of Attribute Names",
      "section_title": true,
      "ja": "属性名の6表現"
    },
    {
      "indent": 3,
      "text": "Different underlying mechanisms (e.g., SAML or X.509 certificates) provide different representations for the names of their attributes. In X.509 certificates, most objects are named by object identifiers (OIDs). The type of object (certificate extension, name constraint, keyPurposeID, etc.) along with the OID is sufficient to identify the attribute. By contrast, according to Sections 8.2 and 2.7.3.1 of [OASIS.saml-core-2.0-os], the name of an attribute has two parts. The first is a URI describing the format of the name. The second part, whose form depends on the format URI, is the actual name. In other cases, an attribute might represent a certificate that plays some particular role in a GSS-API mechanism; such attributes might have a simple mechanism-defined name.",
      "ja": "異なる機序（例えば、SAMLまたはX.509証明書）は、それらの属性の名前のための異なる表現を提供します。 X.509証明書では、ほとんどのオブジェクトは、オブジェクト識別子（OID）によって命名されています。 OIDとともにオブジェクト（証明書拡張、名前制約、keyPurposeID、等）のタイプは、属性を識別するのに十分です。対照的に、セクション8.2および[OASIS.samlコア-2.0-OS]の2.7.3.1によれば、属性の名前は、2つの部分を有します。最初は、名前のフォーマットを記述URIです。そのフォーム形式URIに依存する第二の部分は、実際の名前です。他の例では、属性は、GSS-APIメカニズムでは、いくつかの特定の役割を果たしている証明書を表すかもしれません。このような属性は、単純なメカニズムに定義された名前を持っているかもしれません。"
    },
    {
      "indent": 3,
      "text": "Attribute names MUST support multiple components. If there is more than one component in an attribute name, the more significant components define the semantics of the less significant components.",
      "ja": "属性名は、複数のコンポーネントをサポートしなければなりません。属性名に2つ以上の成分がある場合は、より多くの重要な構成要素はあまり重要な構成要素の意味を定義します。"
    },
    {
      "indent": 3,
      "text": "Attribute names are represented as OCTET STRING elements in the API described below. These attribute names have syntax and semantics that are understood by the application and by the lower-layer implementations (some of which are described below).",
      "ja": "属性名は、以下のAPIでオクテット文字列要素として表現されています。これらの属性名は、アプリケーションによって、および（以下に記載されるいくつかの）下位レイヤの実装によって理解される構文およびセマンティクスを有します。"
    },
    {
      "indent": 3,
      "text": "If an attribute name contains a space (ASCII 0x20), the first space separates the most significant or primary component of the name from the remainder. We may refer to the primary component of the attribute name as the attribute name's \"prefix\". If there is no space, the primary component is the entire name; otherwise, it defines the interpretation of the remainder of the names.",
      "ja": "属性名は、スペース（アスキーの0x20）が含まれている場合、最初の空間が残りから名前の最も重要なまたは主要成分を分離します。私たちは、属性名の「接頭辞」として属性名の主要な構成要素を参照することができます。スペースがない場合は、主要コンポーネントは、全体の名前です。それ以外の場合は、名前の残りの部分の解釈を定義します。"
    },
    {
      "indent": 3,
      "text": "If the primary component contains a \":\" (ASCII 0x3a), then the primary component is a URI. Otherwise, the attribute is a local attribute and the primary component has meaning to the implementation of GSS-API or to the specific configuration of the application. Local attribute names with an \"at\" sign (\"@\") in them are reserved for future allocation by the IETF.",
      "ja": "「：」主要コンポーネントが含まれている場合（アスキー0x3a）を、そして主要コンポーネントはURIです。そうでない場合、属性はローカル属性であり、主な構成要素は、GSS-APIの実装に、またはアプリケーションの特定の構成に意味があります。その中の記号（「@」）「で、」IETFによって将来の割り当てのために予約されているとローカル属性名。"
    },
    {
      "indent": 3,
      "text": "Since attribute names are split at the first space into prefix and suffix, there is a potential for ambiguity if a mechanism blindly passes through a name attribute whose name it does not understand. In order to prevent such ambiguities, the mechanism MUST always prefix raw name attributes with a prefix that reflects the context of the attribute.",
      "ja": "属性名は、接頭辞と接尾辞の中に最初のスペースで分割されているので、メカニズムは盲目的に名前が、それは理解していない名前の属性を通過する場合は、あいまいさの可能性があります。そのようなあいまいさを防ぐために、常に生の名前の前に付ける必要がありますメカニズムは、属性のコンテキストを反映した接頭辞を持つ属性。"
    },
    {
      "indent": 3,
      "text": "Local attribute names under the control of an administrator or a sufficiently trusted part of the platform need not have a prefix to describe context.",
      "ja": "管理者の管理やプラットフォームの十分に信頼される一部の下のローカル属性名は、コンテキストを記述するための接頭辞を持つ必要はありません。"
    },
    {
      "indent": 0,
      "text": "7. API",
      "section_title": true,
      "ja": "7. API"
    },
    {
      "indent": 0,
      "text": "7.1. SET OF OCTET STRING",
      "section_title": true,
      "ja": "7.1。 OCTET STRINGのセット"
    },
    {
      "indent": 3,
      "text": "The construct \"SET OF OCTET STRING\" occurs once in RFC 2743 [RFC2743], where it is used to represent a set of status strings in the GSS_Display_status call. The Global Grid Forum has defined SET OF OCTET STRING as a buffer set type in GFD.024 [GFD.024], which also provides one API for memory management of these structures. The normative reference to GFD.024 [GFD.024] is for the buffer set functions defined in Section 2.5 and the associated buffer set C types defined in Section 6 (namely gss_buffer_set_desc, gss_buffer_set_t, gss_create_empty_buffer_set, gss_add_buffer_set_member, gss_release_buffer_set). Nothing else from GFD.024 is required to implement this document. In particular, that document specifies changes to the behavior of existing GSS-API functions in Section 3: implementing those changes are not required to implement this document. Any implementation of SET OF OCTET STRING for use by this specification MUST preserve order.",
      "ja": "構築物「OCTET STRINGのセット」はGSS_Display_statusコールのステータス文字列のセットを表すために使用されているRFC 2743 [RFC2743]に一度起こります。グローバル・グリッド・フォーラムはまた、これらの構造のメモリ管理のための1つのAPIを提供GFD.024 [GFD.024]におけるバッファセットタイプとしてオクテット文字列のセットを定義しています。 GFD.024 [GFD.024]に引用規格は、（すなわちgss_buffer_set_desc、gss_buffer_set_t、gss_create_empty_buffer_set、gss_add_buffer_set_member、gss_release_buffer_set）セクション6で定義されたセクション2.5で定義されたバッファセット機能と関連したバッファセットCタイプのためのものです。 GFD.024から他には何も、この文書を実装するために必要とされません。具体的には、その文書には、第3節では、既存のGSS-API関数の動作の変更を指定しています実装は、これらの変更は、この文書を実装する必要はありません。この仕様で使用するためのオクテット文字列のセットのいずれかの実装では、順序を保存しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.2. Const Types",
      "section_title": true,
      "ja": "7.2。 constのタイプ"
    },
    {
      "indent": 3,
      "text": "The C-bindings for the new APIs use some types from [RFC5587] to avoid issues with the use of \"const\". The normative reference to [RFC5587] is for the C types specified in Figure 1 of Section 3.4.6. Nothing else from that document is required to implement this document.",
      "ja": "新しいAPIのためのC-バインディングは「CONST」を使用して問題を回避するために、[RFC5587]からのいくつかのタイプを使用します。 [RFC5587]に引用規格は、セクション3.4.6の図1に指定されたCタイプのためのものです。その文書から他には何も、この文書を実装するために必要とされません。"
    },
    {
      "indent": 0,
      "text": "7.3. GSS_Display_name_ext()",
      "section_title": true,
      "ja": "7.3。 GSS_Display_name_ext（）"
    },
    {
      "indent": 3,
      "text": "Inputs:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "o name INTERNAL NAME",
      "ja": "O内部名に名前を付けます"
    },
    {
      "indent": 3,
      "text": "o display_as_name_type OBJECT IDENTIFIER",
      "ja": "O display_as_name_typeオブジェクト識別子"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "o major_status INTEGER",
      "ja": "O major_status INTEGER"
    },
    {
      "indent": 3,
      "text": "o minor_status INTEGER",
      "ja": "minor_status INTEGER O"
    },
    {
      "indent": 3,
      "text": "o display_name OCTET STRING -- caller must release with GSS_Release_buffer()",
      "ja": "O DISPLAY_NAMEオクテットSTRING  -  GSS_Release_bufferで解放する必要があり、発信者（）"
    },
    {
      "indent": 3,
      "text": "Return major_status codes:",
      "ja": "major_status戻りコード："
    },
    {
      "indent": 3,
      "text": "o GSS_S_COMPLETE indicates no error.",
      "ja": "O GSS_S_COMPLETEエラーがないことを示します。"
    },
    {
      "indent": 3,
      "text": "o GSS_S_UNAVAILABLE indicates that the given name could not be displayed using the syntax of the given name type.",
      "ja": "O GSS_S_UNAVAILABLEは、指定された名前が指定された名前型の構文を使用して表示することができなかったことを示しています。"
    },
    {
      "indent": 3,
      "text": "o GSS_S_FAILURE indicates a general error.",
      "ja": "O GSS_S_FAILUREは、一般的なエラーを示します。"
    },
    {
      "indent": 3,
      "text": "This function displays a given name using the given name syntax, if possible. This operation may require mapping Mechanism Names (MNs) to generic name syntaxes or generic name syntaxes to mechanism-specific name syntaxes. Such mappings may not always be feasible and MAY be inexact or lossy; therefore, this function may fail.",
      "ja": "可能な場合、この関数は、指定された名前の構文を使用して、指定された名前が表示されます。この操作は、機構固有の名前の構文に一般名構文や一般名構文にマッピングするメカニズム名（MNの）を必要とするかもしれません。このようなマッピングは常に可能ではないかもしれないと不正確または非可逆なる場合があります。そのため、この関数は失敗することがあります。"
    },
    {
      "indent": 0,
      "text": "7.3.1. C-Bindings",
      "section_title": true,
      "ja": "7.3.1。 C-バインディング"
    },
    {
      "indent": 3,
      "text": "The display_name buffer is de-allocated by the caller with gss_release_buffer.",
      "ja": "DISPLAY_NAMEバッファはgss_release_buffer呼び出し元によって割り当て解除されています。"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_display_name_ext( OM_uint32 *minor_status, gss_const_name_t name, gss_const_OID display_as_name_type, gss_buffer_t display_name );",
      "ja": "OM_uint32と同じgss_display_name_ext（OM_uint32と同じ* minor_status、gss_const_name_t名、gss_const_OIDのdisplay_as_name_type、gss_buffer_t DISPLAY_NAME）。"
    },
    {
      "indent": 0,
      "text": "7.4. GSS_Inquire_name()",
      "section_title": true,
      "ja": "7.4。 GSS_Inquire_name（）"
    },
    {
      "indent": 3,
      "text": "Inputs:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "o name INTERNAL NAME",
      "ja": "O内部名に名前を付けます"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "o major_status INTEGER",
      "ja": "O major_status INTEGER"
    },
    {
      "indent": 3,
      "text": "o minor_status INTEGER",
      "ja": "minor_status INTEGER O"
    },
    {
      "indent": 3,
      "text": "o name_is_MN BOOLEAN",
      "ja": "name_is_MN BOOLEAN O"
    },
    {
      "indent": 3,
      "text": "o mn_mech OBJECT IDENTIFIER",
      "ja": "O mn_mechオブジェクト識別子"
    },
    {
      "indent": 3,
      "text": "o attrs SET OF OCTET STRING -- the caller is responsible for de-allocating memory using GSS_Release_buffer_set",
      "ja": "オクテットストリングのATTRS O SET  - 発信者がGSS_Release_buffer_setを使用してデ割り当てるメモリの原因であります"
    },
    {
      "indent": 3,
      "text": "Return major_status codes:",
      "ja": "major_status戻りコード："
    },
    {
      "indent": 3,
      "text": "o GSS_S_COMPLETE indicates no error.",
      "ja": "O GSS_S_COMPLETEエラーがないことを示します。"
    },
    {
      "indent": 3,
      "text": "o GSS_S_FAILURE indicates a general error.",
      "ja": "O GSS_S_FAILUREは、一般的なエラーを示します。"
    },
    {
      "indent": 3,
      "text": "This function outputs the set of attributes of a name. It also indicates if a given name is an Mechanism Name (MN) or not and, if it is, the mechanism of which it's an MN.",
      "ja": "この関数は、名前の属性のセットを出力します。それは、それはMNだそのメカニズムであれば指定された名前は、機構名（MN）かそうでないと場合にも示しています。"
    },
    {
      "indent": 0,
      "text": "7.4.1. C-Bindings",
      "section_title": true,
      "ja": "7.4.1。 C-バインディング"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_inquire_name( OM_uint32 *minor_status, gss_const_name_t name, int *name_is_MN, gss_OID *MN_mech, gss_buffer_set_t *attrs );",
      "ja": "OM_uint32と同じgss_inquire_name（OM_uint32と同じ* minor_status、gss_const_name_t名、int型* name_is_MN、次に、gss_OID * MN_mech、gss_buffer_set_t * attrsに）。"
    },
    {
      "indent": 3,
      "text": "The gss_buffer_set_t is used here as the C representation of SET OF OCTET STRING. This type is used to represent a set of attributes and is a NULL-terminated array of gss_buffer_t. The gss_buffer_set_t type and associated API is defined in GFD.024 [GFD.024]. The \"attrs\" buffer set is de-allocated by the caller using gss_release_buffer_set().",
      "ja": "gss_buffer_set_tは、オクテット文字列のセットのC表現としてここで使用されます。このタイプの属性のセットを表すために使用されるとgss_buffer_tのNULLで終了する配列です。 gss_buffer_set_tタイプと関連するAPIは、[GFD.024] GFD.024で定義されています。 「ATTRS」バッファセットが呼び出し元用いgss_release_buffer_setによって割り当て解除されます（）。"
    },
    {
      "indent": 0,
      "text": "7.5. GSS_Get_name_attribute()",
      "section_title": true,
      "ja": "7.5。 GSS_Get_name_attribute（）"
    },
    {
      "indent": 3,
      "text": "Inputs:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "o name INTERNAL NAME",
      "ja": "O内部名に名前を付けます"
    },
    {
      "indent": 3,
      "text": "o attr OCTET STRING",
      "ja": "O ATTRオクテットSTRING"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "o major_status INTEGER",
      "ja": "O major_status INTEGER"
    },
    {
      "indent": 3,
      "text": "o minor_status INTEGER",
      "ja": "minor_status INTEGER O"
    },
    {
      "indent": 3,
      "text": "o authenticated BOOLEAN -- TRUE if and only if authenticated by the trusted peer credential source",
      "ja": "O BOOLEAN認証された - もしTRUEと信頼できるピアクレデンシャルソースによって認証された場合にのみ、"
    },
    {
      "indent": 3,
      "text": "o complete BOOLEAN -- TRUE if and only if this represents a complete set of values for the name",
      "ja": "O完全BOOLEAN  -  trueの場合、これは、名前の値の完全なセットを表す場合にのみ"
    },
    {
      "indent": 3,
      "text": "o values SET OF OCTET STRING -- the caller is responsible for de-allocating memory using GSS_Release_buffer_set",
      "ja": "O値はオクテット文字列のセット - 発信者がGSS_Release_buffer_setを用いて脱割り当てるメモリの原因であります"
    },
    {
      "indent": 3,
      "text": "o display_values SET OF OCTET STRING -- the caller is responsible for de-allocating memory using GSS_Release_buffer_set",
      "ja": "オクテットストリングのO display_valuesセット - 発信者がGSS_Release_buffer_setを使用してデ割り当てるメモリの原因であります"
    },
    {
      "indent": 3,
      "text": "Return major_status codes:",
      "ja": "major_status戻りコード："
    },
    {
      "indent": 3,
      "text": "o GSS_S_COMPLETE indicates no error.",
      "ja": "O GSS_S_COMPLETEエラーがないことを示します。"
    },
    {
      "indent": 3,
      "text": "o GSS_S_UNAVAILABLE indicates that the given attribute OID is not known or set.",
      "ja": "O GSS_S_UNAVAILABLEは、特定の属性のOIDが知られているか、または設定されていないことを示しています。"
    },
    {
      "indent": 3,
      "text": "o GSS_S_FAILURE indicates a general error.",
      "ja": "O GSS_S_FAILUREは、一般的なエラーを示します。"
    },
    {
      "indent": 3,
      "text": "This function outputs the value(s) associated with a given GSS name object for a given name attribute.",
      "ja": "この関数は、指定された名前の属性の指定されたGSS名オブジェクトに関連付けられた値（S）を出力します。"
    },
    {
      "indent": 3,
      "text": "The complete flag denotes that (if TRUE) the set of values represents a complete set of values for this name. The peer being an authoritative source of information for this attribute is a sufficient condition for the complete flag to be set by the peer.",
      "ja": "完了フラグは、（TRUEの場合）値のセットが、この名前の値の完全なセットを表すことを意味します。この属性の情報の信頼できるソースであるピアはピアによって設定する完了フラグのための十分条件です。"
    },
    {
      "indent": 3,
      "text": "In the federated case, when several peers may hold some of the attributes about a name, this flag may be highly dangerous and SHOULD NOT be used.",
      "ja": "フェデレーションの場合、いくつかのピアは名前に関する属性の一部を保持することができるとき、このフラグは非常に危険であるため、使用しないでください。"
    },
    {
      "indent": 3,
      "text": "NOTE: This function relies on the GSS-API notion of \"SET OF\" allowing for order preservation; this has been discussed on the KITTEN WG mailing list, and the consensus seems to be that, indeed, that was always the intention. It should be noted, however, that the order presented does not always reflect an underlying order of the mechanism-specific source of the attribute values.",
      "ja": "注：この機能は、オーダー保存を可能にし、「セット」のGSS-APIの概念に依存しています。これはKITTEN WGメーリングリストで議論されている、との合意は、常に意図したこと、実際に、それをあるように思われます。提示順序は常に属性値のメカニズム固有のソースの基本的な順序を反映していないことに留意すべきです。"
    },
    {
      "indent": 0,
      "text": "7.5.1. C-Bindings",
      "section_title": true,
      "ja": "7.5.1。 C-バインディング"
    },
    {
      "indent": 3,
      "text": "The C-bindings of GSS_Get_name_attribute() require one function call per attribute value for multi-valued name attributes. This is done by using a single gss_buffer_t for each value and an input/output integer parameter to distinguish initial and subsequent calls and to indicate when all values have been obtained.",
      "ja": "GSS_Get_name_attribute（）のC-バインディングは複数値の名前属性の属性値ごとに関数呼び出しが必要です。これは、初期および後続の呼び出しを区別するために、すべての値が得られた場合を示すために各値について単一gss_buffer_t及び入力/出力整数パラメータを使用して行われます。"
    },
    {
      "indent": 3,
      "text": "The \"more\" input/output parameter should point to an integer variable whose value, on first call to gss_get_name_attribute(), MUST be -1 and whose value upon function call return will be non-zero to indicate that additional values remain or zero to indicate that no values remain. The caller should not modify this parameter after the initial call. The status of the complete and authenticated flags MUST NOT change between multiple calls to iterate over values for an attribute.",
      "ja": "その値は、最初の呼び出しに（gss_get_name_attributeする）整数変数を指すべきでなければなら-1とその値が関数呼び出しの戻り時に追加の値が残っていることを示すために、非ゼロであるか、又はゼロに入力/出力パラメータ「詳細」何の値が残っていないことを示しています。呼び出し側は、最初の呼び出しの後に、このパラメータを変更しないでください。完全な認証されたフラグの状態は、属性の値を反復処理するために、複数の呼び出し間で変化してはいけません。"
    },
    {
      "indent": 3,
      "text": "The output buffers \"value\" and \"display_value\" are de-allocated by the caller using gss_release_buffer().",
      "ja": "出力バッファ「値」と「DISPLAY_VALUEが」呼び出し元用いgss_release_bufferによって割り当て解除されます（）。"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_get_name_attribute( OM_uint32 *minor_status, gss_const_name_t name, gss_const_buffer_t attr, int *authenticated, int *complete, gss_buffer_t value, gss_buffer_t display_value, int *more );",
      "ja": "OM_uint32と同じgss_get_name_attribute（OM_uint32と同じ* minor_status、gss_const_name_t名、gss_const_buffer_tのattr、int型*認証され、int型*完全な、gss_buffer_t値、gss_buffer_t DISPLAY_VALUE、int型*より）。"
    },
    {
      "indent": 0,
      "text": "7.6. GSS_Set_name_attribute()",
      "section_title": true,
      "ja": "7.6。 GSS_Set_name_attribute（）"
    },
    {
      "indent": 3,
      "text": "Inputs:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "o name INTERNAL NAME",
      "ja": "O内部名に名前を付けます"
    },
    {
      "indent": 3,
      "text": "o complete BOOLEAN -- TRUE if and only if this represents a complete set of values for the name",
      "ja": "O完全BOOLEAN  -  trueの場合、これは、名前の値の完全なセットを表す場合にのみ"
    },
    {
      "indent": 3,
      "text": "o attr OCTET STRING",
      "ja": "O ATTRオクテットSTRING"
    },
    {
      "indent": 3,
      "text": "o values SET OF OCTET STRING",
      "ja": "O OCTET STRINGのセット値"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "o major_status INTEGER",
      "ja": "O major_status INTEGER"
    },
    {
      "indent": 3,
      "text": "o minor_status INTEGER",
      "ja": "minor_status INTEGER O"
    },
    {
      "indent": 3,
      "text": "Return major_status codes:",
      "ja": "major_status戻りコード："
    },
    {
      "indent": 3,
      "text": "o GSS_S_COMPLETE indicates no error.",
      "ja": "O GSS_S_COMPLETEエラーがないことを示します。"
    },
    {
      "indent": 3,
      "text": "o GSS_S_UNAVAILABLE indicates that the given attribute NAME is not known or could not be set.",
      "ja": "O GSS_S_UNAVAILABLEは、指定された属性名が知られていないか、設定することができなかったことを示しています。"
    },
    {
      "indent": 3,
      "text": "o GSS_S_FAILURE indicates a general error.",
      "ja": "O GSS_S_FAILUREは、一般的なエラーを示します。"
    },
    {
      "indent": 3,
      "text": "When the given NAME object is an MN, this function MUST fail (with GSS_S_FAILURE) if the mechanism for which the name is an MN does not recognize the attribute name or the namespace it belongs to. This is because name attributes generally have some semantics that mechanisms must understand.",
      "ja": "指定された名前のオブジェクトがMNである場合は、この関数は（GSS_S_FAILUREで）失敗しなければなりません名前はMNされたメカニズムは、属性名や、それが属する名前空間を認識しない場合。名前は、一般的に属性のメカニズムを理解しなければならないいくつかの意味を持っているためです。"
    },
    {
      "indent": 3,
      "text": "On the other hand, when the given name is not an MN, this function MAY succeed even if none of the available mechanisms understand the given attribute, in which subsequent credential acquisition attempts (via GSS_Acquire_cred() or GSS_Add_cred()) with the resulting name MUST fail for mechanisms that do not understand any one or more name attributes set with this function. Applications may wish to use a non-MN, then acquire a credential with that name as the desired name. The acquired credentials will have elements only for the mechanisms that can carry the name attributes set on the name.",
      "ja": "一方、指定された名前がMNない場合に利用可能なメカニズムのいずれも指定された属性を理解しない場合、この関数も成功する可能性、の後続資格取得試行（は、gss_acquire_cred（）またはGSS_Add_credを介して（））得られた名前を持ちますこの機能で設定された任意の一つ以上のname属性を理解していないメカニズムのために失敗しなければなりません。アプリケーションは、その後、希望する名前としてその名前で資格を取得し、非MNを使用することができます。取得した資格情報には、名前のみに設定された名前の属性を運ぶことができるメカニズムの要素を持つことになります。"
    },
    {
      "indent": 3,
      "text": "Note that this means that all name attributes are locally critical: the mechanism(s) must understand them. The reason for this is that name attributes must necessarily have some meaning that the mechanism must understand, even in the case of application-specific attributes (in which case the mechanism must know to transport the attribute to any peer). However, there is no provision to ensure that peers understand any given name attribute. Individual name attributes may be critical with respect to peers, and the specification of the attribute will have to indicate whether the mechanism's protocol or the application is expected to enforce criticality.",
      "ja": "メカニズム（s）はそれらを理解する必要があります。これは、すべての名前の属性が局部的に重要であることを意味することに注意してください。この理由は、名前の属性が必ずしもさえ（メカニズムがどのピアに属性を輸送するために知っている必要があり、その場合には）アプリケーション固有の属性の場合には、メカニズムが理解しなければならないことを何らかの意味を持たなければならないということです。しかし、ピアは任意の名前属性を理解していることを確実にする規定はありません。個々の名前は、ピアに関して重要であり、属性、および属性の指定はメカニズムのプロトコルやアプリケーションが重要性を強制するために期待されているかどうかを示す必要があります。"
    },
    {
      "indent": 3,
      "text": "The complete flag denotes that (if TRUE) the set of values represents a complete set of values for this name. The peer being an authoritative source of information for this attribute is a sufficient condition for the complete flag to be set by the peer.",
      "ja": "完了フラグは、（TRUEの場合）値のセットが、この名前の値の完全なセットを表すことを意味します。この属性の情報の信頼できるソースであるピアはピアによって設定する完了フラグのための十分条件です。"
    },
    {
      "indent": 3,
      "text": "In the federated case, when several peers may hold some of the attributes about a name, this flag may be highly dangerous and SHOULD NOT be used.",
      "ja": "フェデレーションの場合、いくつかのピアは名前に関する属性の一部を保持することができるとき、このフラグは非常に危険であるため、使用しないでください。"
    },
    {
      "indent": 3,
      "text": "NOTE: This function relies on the GSS-API notion of \"SET OF\" allowing for order preservation; this has been discussed on the KITTEN WG mailing list, and the consensus seems to be that, indeed, that was always the intention. It should be noted that underlying mechanisms may not respect the given order.",
      "ja": "注：この機能は、オーダー保存を可能にし、「セット」のGSS-APIの概念に依存しています。これはKITTEN WGメーリングリストで議論されている、との合意は、常に意図したこと、実際に、それをあるように思われます。基礎となるメカニズムは、所与の順序を尊重しなくてもよいことに留意すべきです。"
    },
    {
      "indent": 0,
      "text": "7.6.1. C-Bindings",
      "section_title": true,
      "ja": "7.6.1。 C-バインディング"
    },
    {
      "indent": 3,
      "text": "The C-bindings of GSS_Set_name_attribute() requires one function call per attribute value for multi-valued name attributes. Each call adds one value. To replace an attribute's every value, delete the attribute's values first with GSS_Delete_name_attribute().",
      "ja": "GSS_Set_name_attributeのC-バインディング（）複数の値を持つ名前属性の属性値ごとに関数呼び出しが必要です。各呼び出しは、一つの値を追加します。 、属性のすべての値を置き換えるGSS_Delete_name_attributeで最初の属性の値を削除するには（）。"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_set_name_attribute( OM_uint32 *minor_status, gss_const_name_t name, int complete, gss_const_buffer_t attr, gss_const_buffer_t value );",
      "ja": "OM_uint32と同じgss_set_name_attribute（OM_uint32と同じ* minor_status、gss_const_name_t名、int型の完全な、ATTR gss_const_buffer_t、gss_const_buffer_t値）。"
    },
    {
      "indent": 0,
      "text": "7.7. GSS_Delete_name_attribute()",
      "section_title": true,
      "ja": "7.7。 GSS_Delete_name_attribute（）"
    },
    {
      "indent": 3,
      "text": "Inputs:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "o name INTERNAL NAME",
      "ja": "O内部名に名前を付けます"
    },
    {
      "indent": 3,
      "text": "o attr OCTET STRING",
      "ja": "O ATTRオクテットSTRING"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "o major_status INTEGER",
      "ja": "O major_status INTEGER"
    },
    {
      "indent": 3,
      "text": "o minor_status INTEGER",
      "ja": "minor_status INTEGER O"
    },
    {
      "indent": 3,
      "text": "Return major_status codes:",
      "ja": "major_status戻りコード："
    },
    {
      "indent": 3,
      "text": "o GSS_S_COMPLETE indicates no error.",
      "ja": "O GSS_S_COMPLETEエラーがないことを示します。"
    },
    {
      "indent": 3,
      "text": "o GSS_S_UNAVAILABLE indicates that the given attribute NAME is not known.",
      "ja": "O GSS_S_UNAVAILABLEは、指定された属性名が知られていないことを示しています。"
    },
    {
      "indent": 3,
      "text": "o GSS_S_UNAUTHORIZED indicates that a forbidden delete operation was attempted, such as deleting a negative attribute.",
      "ja": "O GSS_S_UNAUTHORIZEDは、このような負の属性を削除すると、禁断の削除操作が試行されたことを示しています。"
    },
    {
      "indent": 3,
      "text": "o GSS_S_FAILURE indicates a general error.",
      "ja": "O GSS_S_FAILUREは、一般的なエラーを示します。"
    },
    {
      "indent": 3,
      "text": "Deletion of negative authenticated attributes from NAME objects MUST NOT be allowed and must result in a GSS_S_UNAUTHORIZED.",
      "ja": "NAMEオブジェクトからの負認証された属性の削除は許されてはならないとGSS_S_UNAUTHORIZEDになる必要があります。"
    },
    {
      "indent": 0,
      "text": "7.7.1. C-Bindings",
      "section_title": true,
      "ja": "7.7.1。 C-バインディング"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_delete_name_attribute( OM_uint32 *minor_status, gss_const_name_t name, gss_const_buffer_t attr );",
      "ja": "OM_uint32と同じgss_delete_name_attribute（OM_uint32と同じ* minor_status、gss_const_name_t名、gss_const_buffer_t attrの）;"
    },
    {
      "indent": 0,
      "text": "7.8. GSS_Export_name_composite()",
      "section_title": true,
      "ja": "7.8。 GSS_Export_name_composite（）"
    },
    {
      "indent": 3,
      "text": "Inputs:",
      "ja": "入力："
    },
    {
      "indent": 3,
      "text": "o name INTERNAL NAME",
      "ja": "O内部名に名前を付けます"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 3,
      "text": "o major_status INTEGER",
      "ja": "O major_status INTEGER"
    },
    {
      "indent": 3,
      "text": "o minor_status INTEGER o exp_composite_name OCTET STRING -- the caller is responsible for de-allocating memory using GSS_Release_buffer",
      "ja": "exp_composite_nameオクテットSTRING O O minor_status INTEGER  - 発信者がGSS_Release_bufferを使用してデ割り当てるメモリの原因であります"
    },
    {
      "indent": 3,
      "text": "Return major_status codes:",
      "ja": "major_status戻りコード："
    },
    {
      "indent": 3,
      "text": "o GSS_S_COMPLETE indicates no error.",
      "ja": "O GSS_S_COMPLETEエラーがないことを示します。"
    },
    {
      "indent": 3,
      "text": "o GSS_S_FAILURE indicates a general error.",
      "ja": "O GSS_S_FAILUREは、一般的なエラーを示します。"
    },
    {
      "indent": 3,
      "text": "This function outputs a token that can be imported with GSS_Import_name(), using GSS_C_NT_COMPOSITE_EXPORT as the name type and that preserves any name attribute information (including the authenticated/complete flags) associated with the input name (which GSS_Export_name() may well not). The token format is not specified here as this facility is intended for inter-process communication only; however, all such tokens MUST start with a two-octet token ID, hex 04 02, in network byte order.",
      "ja": "（十分ではない可能性があるGSS_Export_name（））この関数は、名前型としてGSS_C_NT_COMPOSITE_EXPORTを使用して、）（GSS_Import_nameでインポートすることができるトークンを出力し、それは任意の名前を保存する（認証/完全フラグを含む）の属性情報を入力された名前に関連付けられています。この機能は、プロセス間通信のみのために意図されるトークンの形式は、ここで指定されていません。しかし、そのようなすべてのトークンはネットワークバイト順で、2オクテットのトークンID、六角04 02で開始する必要があります。"
    },
    {
      "indent": 3,
      "text": "The OID for GSS_C_NT_COMPOSITE_EXPORT is 1.3.6.1.5.6.6.",
      "ja": "GSS_C_NT_COMPOSITE_EXPORTのためのOIDは、1.3.6.1.5.6.6あります。"
    },
    {
      "indent": 0,
      "text": "7.8.1. C-Bindings",
      "section_title": true,
      "ja": "7.8.1。 C-バインディング"
    },
    {
      "indent": 3,
      "text": "The \"exp_composite_name\" buffer is de-allocated by the caller with gss_release_buffer.",
      "ja": "「exp_composite_name」バッファはgss_release_buffer呼び出し元によって割り当て解除されています。"
    },
    {
      "indent": 3,
      "text": "OM_uint32 gss_export_name_composite( OM_uint32 *minor_status, gss_const_name_t name, gss_buffer_t exp_composite_name );",
      "ja": "OM_uint32と同じgss_export_name_composite（OM_uint32と同じ* minor_status、gss_const_name_t名、gss_buffer_t exp_composite_name）。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has registered a new name-type OID in \"SMI Security for Name System Designators Codes (nametypes)\":",
      "ja": "IANAは、「ネームシステム指定子コード（nametypes）のためのSMIセキュリティ」に新しい名前型OIDを登録しています："
    },
    {
      "indent": 6,
      "text": "6 gss-composite-export [RFC6680]",
      "ja": "6つのGSS-複合エクスポート[RFC6680]"
    },
    {
      "indent": 3,
      "text": "(The absolute OID is 1.3.6.1.5.6.6.)",
      "ja": "（絶対OIDは1.3.6.1.5.6.6です。）"
    },
    {
      "indent": 3,
      "text": "This document creates a namespace of GSS-API name attributes. Attributes are named by URIs, so no single authority is technically needed for allocation. However, future deployment experience may indicate the need for an IANA registry for URIs used to reference names specified by IETF standards. It is expected that this will be a registry of URNs, but this document provides no further guidance on this registry.",
      "ja": "このドキュメントでは、GSS-API名属性の名前空間を作成します。属性はURIので命名されているので、単一の権限は技術的に配分するために必要ありません。しかし、今後の展開の経験は、IETF標準で指定された名前を参照するために使用されるURIのためのIANAレジストリの必要性を示すことがあります。のURNのレジストリになると予想、しかし、この文書では、このレジストリには更なるガイダンスを提供されていません。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document extends the GSS-API naming model to include support for name attributes. The intention is that name attributes are to be used as a basis for (among other things) authorization decisions or personalization for applications relying on GSS-API security contexts.",
      "ja": "この文書では、name属性をサポートするようにGSS-APIの命名モデルを拡張します。その意図は、名前の属性が（とりわけ）のための基礎として使用されることをGSS-APIのセキュリティコンテキストに依存するアプリケーションのための認可の決定やパーソナライゼーションです。"
    },
    {
      "indent": 3,
      "text": "The security of the application may be critically dependent on the security of the attributes. This document classifies attributes as asserted or authenticated. Asserted (non-authenticated) attributes MUST NOT be used if the attribute has security implications for the application (e.g., authorization decisions) since asserted attributes may easily be controlled by the peer directly.",
      "ja": "アプリケーションのセキュリティは、属性のセキュリティに決定的に依存することができます。この文書では、アサートまたは認証などの属性を分類します。アサートの属性を簡単に直接ピアによって制御することができるので、属性は、アプリケーションのセキュリティへの影響（例えば、許可の決定を）持っている場合にアサートされ（非認証）使用してはいけません属性。"
    },
    {
      "indent": 3,
      "text": "It is important to understand the meaning of \"authenticated\" in this setting. Authenticated does not imply that any semantic of the attribute is claimed to be true. The only implication is that a trusted third party has asserted the attribute as opposed to the attribute being asserted by the peer itself. Any additional semantics are always the result of applying policy. For instance, in a given deployment, the mail attribute of the subject may be authenticated and sourced from an email system where \"authoritative\" values are kept. In another situation, users may be allowed to modify their mail addresses freely. In both cases, the \"mail\" attribute may be authenticated by virtue of being included in signed SAML attribute assertions or by other means authenticated by the underlying mechanism.",
      "ja": "この設定では、「認証済み」の意味を理解することが重要です。認証された属性のいずれかのセマンティックが真であると主張していることを意味するものではありません。唯一の含意は、ピア自体がアサートされている属性とは対照的に、信頼できるサードパーティが属性を主張していることです。任意の追加のセマンティクスは、常にポリシーを適用した結果です。例えば、与えられた展開に、対象のメール属性が認証されてもよいし、「権威」の値が保持されている電子メールシステムから供給します。別の状況では、ユーザーが自由に自分のメールアドレスを変更させることができます。両方の場合において、「メール」属性は、SAMLアサーション属性署名し、または基礎となる機構で認証他の手段によって包含されることによって認証することができます。"
    },
    {
      "indent": 3,
      "text": "When the underlying security mechanism does not provide a permanent unique identity (e.g., anonymous Kerberos), GSS-API naming extensions may be used to provide a permanent unique identity attribute. This may be a globally unique identifier, a value unique within the namespace of the attribute issuer, or a \"directed\" identifier that is unique per peer acceptor identity. SAML, to use one example technology, offers a number of built-in constructs for this purpose, such as a <NameID> with a Format of \"urn:oasis:names:tc:SAML:2.0:nameid-format:persistent\". SAML deployments also typically make use of domain-specific attribute types that can serve as identifiers.",
      "ja": "基本的なセキュリティメカニズムは永久的な一意の識別（例えば、匿名ケルベロス）を提供していない場合は、GSS-APIの命名拡張子は永久的な一意のID属性を提供するために使用することができます。これは、グローバル一意識別子、属性発行者の名前空間、またはピアアクセプターアイデンティティごとに一意である「監督」の識別子内で一意の値であってもよいです。 SAMLは、一例の技術を使用するには、「URN：オアシス：名：TC：SAML：2.0：名前IDフォーマット：永続」の書式で、このような<名前ID>として、この目的のために内蔵されたコンストラクトの数を提供しています。 SAMLの展開はまた、通常の識別子として機能することができ、ドメイン固有の属性タイプを使用しています。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[GFD.024] Meder, S., Welch, V., Tuecke, S., and D. Engert, \"GSS-API Extensions\", Global Grid Forum GFD.024, June 2004, <http://www.ggf.org/documents/GFD.24.pdf>.",
      "ja": "[GFD.024] MEDER、S.、ウェルチ、V.、Tuecke、S.、およびD. Engert、 \"GSS-APIの拡張機能\"、グローバル・グリッド・フォーラムGFD.024、2004年6月、<のhttp：//www.ggf .ORG /文書/ GFD.24.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2743] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, January 2000.",
      "ja": "[RFC2743]リン、J.、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェースバージョン2、アップデート1\"、RFC 2743、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2744] Wray, J., \"Generic Security Service API Version 2 : C-bindings\", RFC 2744, January 2000.",
      "ja": "[RFC2744]レイ、J.、 \"ジェネリックセキュリティサービスAPIバージョン2：C-バインディング\"、RFC 2744、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5587] Williams, N., \"Extended Generic Security Service Mechanism Inquiry APIs\", RFC 5587, July 2009.",
      "ja": "[RFC5587]ウィリアムズ、N.、 \"拡張ジェネリックセキュリティサービスメカニズム問い合わせのAPI\"、RFC 5587、2009年7月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[ANSI.X3-4.1986] American National Standards Institute, \"Coded Character Set - 7-bit American Standard Code for Information Interchange\", ANSI X3.4, 1986.",
      "ja": "「 - 情報交換のための7ビットの米国標準コードコード化文字セット」、ANSI X3.4、1986 [ANSI.X3-4.1986]米国規格協会、。"
    },
    {
      "indent": 3,
      "text": "[OASIS.saml-core-2.0-os] Cantor, S., Kemp, J., Philpott, R., and E. Maler, \"Assertions and Protocol for the OASIS Security Assertion Markup Language (SAML) V2.0\", OASIS Standard saml-core-2.0-os, March 2005.",
      "ja": "[OASIS.samlコア-2.0-OS]カントール、S.、ケンプ、J.、フィルポット、R.、およびE. MALER、 \"OASISセキュリティアサーションマークアップ言語（SAML）V2.0のためのアサーションとプロトコル\"、 OASIS標準のSAML-コア-2.0-OS、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4120] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The Kerberos Network Authentication Service (V5)\", RFC 4120, July 2005.",
      "ja": "[RFC4120]ノイマン、C.、ゆう、T.、ハルトマン、S.、およびK.レイバーン、 \"ケルベロスネットワーク認証サービス（V5）\"、RFC 4120、2005年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4556] Zhu, L. and B. Tung, \"Public Key Cryptography for Initial Authentication in Kerberos (PKINIT)\", RFC 4556, June 2006.",
      "ja": "\"ケルベロス（PKINIT）における初期認証のための公開鍵暗号\" [RFC4556]朱、L.とB.桐、RFC 4556、2006年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4768] Hartman, S., \"Desired Enhancements to Generic Security Services Application Program Interface (GSS-API) Version 3 Naming\", RFC 4768, December 2006.",
      "ja": "[RFC4768]ハートマン、S.、RFC 4768、2006年12月 \"一般的なセキュリティサービスアプリケーションプログラムインタフェース（GSS-API）バージョン3ネーミングに所望の機能強化\"。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Nicolas Williams Cryptonector, LLC",
      "ja": "ニコラス・ウィリアムズCryptonector、LLC"
    },
    {
      "indent": 3,
      "text": "EMail: nico@cryptonector.com",
      "ja": "メールアドレス：nico@cryptonector.com"
    },
    {
      "indent": 3,
      "text": "Leif Johansson Swedish University Network Thulegatan 11 Stockholm Sweden",
      "ja": "レイフ・ヨハンソンスウェーデンの大学ネットワークThulegatan 11ストックホルムスウェーデン"
    },
    {
      "indent": 3,
      "text": "EMail: leifj@sunet.se URI: http://www.sunet.se",
      "ja": "電子メール：URI leifj@sunet.se：http://www.sunet.se"
    },
    {
      "indent": 3,
      "text": "Sam Hartman Painless Security",
      "ja": "サム・ハートマン無痛セキュリティ"
    },
    {
      "indent": 3,
      "text": "EMail: hartmans-ietf@mit.edu",
      "ja": "メールアドレス：hartmans-ietf@mit.edu"
    },
    {
      "indent": 3,
      "text": "Simon Josefsson SJD AB Johan Olof Wallins Vaeg 13 171 64 Solna Sweden",
      "ja": "サイモンJosefsson氏SJD ABヨハン・オロフ・ワーリンVaeg 13 171 64ソルナ（スウェーデン）"
    },
    {
      "indent": 3,
      "text": "EMail: simon@josefsson.org URI: http://josefsson.org/",
      "ja": "電子メール：simon@josefsson.org URI：http://josefsson.org/"
    }
  ]
}