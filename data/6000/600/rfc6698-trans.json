{
  "title": {
    "text": "RFC 6698 - The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA",
    "ja": "RFC 6698 - 名前付きエンティティのDNSベースの認証（DANE）トランスポート層セキュリティ（TLS）プロトコル：TLSA"
  },
  "number": 6698,
  "created_at": "2019-10-29 09:29:58.827705+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        P. Hoffman\nRequest for Comments: 6698                                VPN Consortium\nCategory: Standards Track                                    J. Schlyter\nISSN: 2070-1721                                                 Kirei AB\n                                                             August 2012",
      "raw": true
    },
    {
      "indent": 9,
      "text": "The DNS-Based Authentication of Named Entities (DANE)\n    Transport Layer Security (TLS) Protocol: TLSA",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Encrypted communication on the Internet often uses Transport Layer Security (TLS), which depends on third parties to certify the keys used. This document improves on that situation by enabling the administrators of domain names to specify the keys used in that domain's TLS servers. This requires matching improvements in TLS client software, but no change in TLS server software.",
      "ja": "インターネット上の暗号化通信を頻繁に使用するキーを証明する第三者に依存してトランスポート層セキュリティ（TLS）を使用しています。この文書では、そのドメインのTLSサーバで使用されるキーを指定するには、ドメイン名の管理者を可能にすることによって、そのような状況に改善します。これは、TLSクライアントソフトウェアでのマッチングの改善を必要としませんが、TLSサーバソフトウェアに変更。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6698.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6698で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2012 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Background and Motivation ..................................3\n   1.2. Securing the Association of a Domain Name with a\n        Server's Certificate .......................................4\n   1.3. Method for Securing Certificate Associations ...............5\n   1.4. Terminology ................................................6\n2. The TLSA Resource Record ........................................7\n   2.1. TLSA RDATA Wire Format .....................................7\n        2.1.1. The Certificate Usage Field .........................7\n        2.1.2. The Selector Field ..................................8\n        2.1.3. The Matching Type Field .............................9\n        2.1.4. The Certificate Association Data Field ..............9\n   2.2. TLSA RR Presentation Format ................................9\n   2.3. TLSA RR Examples ..........................................10\n3. Domain Names for TLSA Certificate Associations .................10\n4. Use of TLSA Records in TLS .....................................11\n   4.1. Usable Certificate Associations ...........................11\n5. TLSA and DANE Use Cases and Requirements .......................13\n6. Mandatory-to-Implement Features ................................15\n7. IANA Considerations ............................................15\n   7.1. TLSA RRtype ...............................................15\n   7.2. TLSA Certificate Usages ...................................15\n   7.3. TLSA Selectors ............................................16\n   7.4. TLSA Matching Types .......................................16\n8. Security Considerations ........................................16\n   8.1. Comparing DANE to Public CAs ..............................18\n        8.1.1. Risk of Key Compromise .............................19\n        8.1.2. Impact of Key Compromise ...........................20\n        8.1.3. Detection of Key Compromise ........................20\n        8.1.4. Spoofing Hostnames .................................20\n   8.2. DNS Caching ...............................................21\n   8.3. External DNSSEC Validators ................................21\n9. Acknowledgements ...............................................22\n10. References ....................................................22\n   10.1. Normative References .....................................22\n   10.2. Informative References ...................................23\nAppendix A. Operational Considerations for Deploying TLSA\n            Records ...............................................25\n  A.1. Creating TLSA Records ......................................25\n    A.1.1. Ambiguities and Corner Cases When TLS Clients\n           Build Trust Chains .....................................26\n    A.1.2. Choosing a Selector Type ...............................26\n  A.2. Provisioning TLSA Records in DNS ...........................28\n    A.2.1. Provisioning TLSA Records with Aliases .................28\n  A.3. Securing the Last Hop ......................................30\n  A.4. Handling Certificate Rollover ..............................31",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Appendix B. Pseudocode for Using TLSA .............................32\n  B.1. Helper Functions ...........................................32\n  B.2. Main TLSA Pseudocode .......................................33\nAppendix C. Examples ..............................................35",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. Background and Motivation",
      "section_title": true,
      "ja": "1.1。背景と動機"
    },
    {
      "indent": 3,
      "text": "Applications that communicate over the Internet often need to prevent eavesdropping, tampering, or forgery of their communications. The Transport Layer Security (TLS) protocol provides this kind of communications security over the Internet, using channel encryption.",
      "ja": "インターネットを介して通信するアプリケーションは、多くの場合、その通信の盗聴、改ざん、または偽造を防ぐために必要です。トランスポート層セキュリティ（TLS）プロトコルは、チャネル暗号化を使用して、インターネット上の通信のセキュリティのこの種を提供します。"
    },
    {
      "indent": 3,
      "text": "The security properties of encryption systems depend strongly on the keys that they use. If secret keys are revealed, or if public keys can be replaced by fake keys (that is, a key not corresponding to the entity identified in the certificate), these systems provide little or no security.",
      "ja": "暗号化システムのセキュリティプロパティは、彼らが使用するキーに強く依存しています。秘密鍵を明らかにした、または公開鍵が偽のキーに置き換えることができる場合（つまり、鍵が証明書で特定されたエンティティに対応していない）している場合は、これらのシステムは、ほとんど、あるいはまったくセキュリティを提供します。"
    },
    {
      "indent": 3,
      "text": "TLS uses certificates to bind keys and names. A certificate combines a published key with other information such as the name of the service that uses the key, and this combination is digitally signed by another key. Having a key in a certificate is only helpful if one trusts the other key that signed the certificate. If that other key was itself revealed or substituted, then its signature is worthless in proving anything about the first key.",
      "ja": "TLSは、キーと名前をバインドするために証明書を使用しています。証明書には、このようなキーを使用するサービスの名前など他の情報と、公開キーを組み合わせて、この組み合わせは、デジタル他のキーによって署名されています。 1が証明書に署名した他のキーを信頼している場合、証明書にキーを持つことだけ便利です。そのほかのキーは、それ自体が明らかまたは置換した場合、その署名は、最初のキーについては何も証明して価値のないものです。"
    },
    {
      "indent": 3,
      "text": "On the Internet, this problem has been solved for years by entities called \"Certification Authorities\" (CAs). CAs protect their secret key vigorously, while supplying their public key to the software vendors who build TLS clients. They then sign certificates, and supply those to TLS servers. TLS client software uses a set of these CA keys as \"trust anchors\" to validate the signatures on certificates that the client receives from TLS servers. Client software typically allows any CA to usefully sign any other certificate.",
      "ja": "インターネット上では、この問題は、「認証局」（CAS）と呼ばれるエンティティによって年間は解決されています。 TLSクライアントを構築するソフトウェアベンダーへの公開鍵を供給しながらCAは、積極的に自分の秘密鍵を保護します。そして、彼らは証明書に署名し、TLSサーバにそれらを供給しています。 TLSクライアントソフトウェアは、クライアントがTLSサーバから受信証明書に署名を検証するために、「トラストアンカー」として、これらのCAキーのセットを使用しています。クライアントソフトウェアは、典型的には、任意のCAが有効、他の証明書に署名することができます。"
    },
    {
      "indent": 3,
      "text": "The public CA model upon which TLS has depended is fundamentally vulnerable because it allows any of these CAs to issue a certificate for any domain name. A single trusted CA that betrays its trust, either voluntarily or by providing less-than-vigorous protection for its secrets and capabilities, can undermine the security offered by any certificates employed with TLS. This problem arises because a compromised CA can issue a replacement certificate that contains a fake key. Recent experiences with compromises of CAs or their trusted partners have led to very serious security problems, such as the governments of multiple countries attempting to wiretap and/or subvert major TLS-protected web sites trusted by millions of users.",
      "ja": "それはこれらのCAのいずれかが任意のドメイン名の証明書を発行することができますので、TLSが依存してきた時に、パブリックCAモデルは基本的に脆弱です。いずれか自発的にまたはその秘密と機能のより少なくより積極的な保護を提供することで、その信頼を裏切る単一の信頼できるCAは、TLSで使用される任意の証明書によって提供されるセキュリティを弱体化させることができます。改ざんされたCAが偽のキーが含まれている交換用の証明書を発行することができますので、この問題が発生します。 CASまたはその信頼できるパートナーの妥協との最近の経験は、そのような盗聴および/または何百万ものユーザーから信頼される主要なTLSで保護されたWebサイトを破壊しようとする複数の国の政府として、非常に深刻なセキュリティ上の問題につながっています。"
    },
    {
      "indent": 3,
      "text": "The DNS Security Extensions (DNSSEC) provide a similar model that involves trusted keys signing the information for untrusted keys. However, DNSSEC provides three significant improvements. Keys are tied to names in the Domain Name System (DNS), rather than to arbitrary identifying strings; this is more convenient for Internet protocols. Signed keys for any domain are accessible online through a straightforward query using the standard DNSSEC protocol, so there is no problem distributing the signed keys. Most significantly, the keys associated with a domain name can only be signed by a key associated with the parent of that domain name; for example, the keys for \"example.com\" can only be signed by the keys for \"com\", and the keys for \"com\" can only be signed by the DNS root. This prevents an untrustworthy signer from compromising anyone's keys except those in their own subdomains. Like TLS, DNSSEC relies on public keys that come built into the DNSSEC client software, but these keys come only from a single root domain rather than from a multiplicity of CAs.",
      "ja": "DNSセキュリティ拡張機能（DNSSEC）は信頼できないキーの情報に署名する信頼できるキーを必要とする同様のモデルを提供します。しかし、DNSSECは、3点の重要な改善を提供します。キーは、ドメインネームシステム（DNS）内の名前にではなく、任意の識別ストリングに接続されています。これは、インターネットプロトコルのためのより便利です。任意のドメインのための署名されたキーは、標準のDNSSECプロト​​コルを使用して簡単なクエリを通じてオンラインでアクセス可能ですので、署名鍵の配布は問題ありません。最も重要なのは、ドメイン名に関連付けられたキーのみをそのドメイン名の親に関連付けられた鍵で署名することができます。例えば、「example.com」のキーは、「COM」のキーによって署名することができ、「COM」のキーは、DNSルートによって署名することができます。これは、自分のサブドメインのものを除いて誰の鍵を損なうことから、信頼できない署名者を防ぐことができます。 TLSのように、DNSSECは、DNSSECのクライアントソフトウェアに組み込まれてきた公開鍵に依存しているが、これらのキーは、単一のルートドメインからではなく、CAの多様性からのみ来ます。"
    },
    {
      "indent": 3,
      "text": "DNS-Based Authentication of Named Entities (DANE) offers the option to use the DNSSEC infrastructure to store and sign keys and certificates that are used by TLS. DANE is envisioned as a preferable basis for binding public keys to DNS names, because the entities that vouch for the binding of public key data to DNS names are the same entities responsible for managing the DNS names in question. While the resulting system still has residual security vulnerabilities, it restricts the scope of assertions that can be made by any entity, consistent with the naming scope imposed by the DNS hierarchy. As a result, DANE embodies the security \"principle of least privilege\" that is lacking in the current public CA model.",
      "ja": "名前付きエンティティ（DANE）のDNSベースの認証を保存し、キーおよびTLSで使用される証明書に署名するDNSSECインフラストラクチャを使用するためのオプションを提供しています。 DNS名に公開鍵データのバインディングを保証するエンティティは、問題のDNS名を管理する責任同じエンティティであるためDANEは、DNS名に公開鍵を結合するのに好適基礎として想定されています。得られた系は、依然として残留セキュリティ脆弱性を有するが、それはDNS階層によって課さ命名範囲と一致し、任意のエンティティによって行うことができるアサーションの範囲を制限します。その結果、DANEは、現在パブリックCAモデルに欠けているセキュリティ「最小特権の原則」を体現しています。"
    },
    {
      "indent": 0,
      "text": "1.2. Securing the Association of a Domain Name with a Server's Certificate",
      "ja": "1.2。サーバーの証明書を使用したドメイン名の協会の確保"
    },
    {
      "indent": 3,
      "text": "A TLS client begins a connection by exchanging messages with a TLS server. For many application protocols, it looks up the server's name using the DNS to get an Internet Protocol (IP) address associated with the name. It then begins a connection to a particular port at that address, and sends an initial message there. However, the client does not yet know whether an adversary is intercepting and/or altering its communication before it reaches the TLS server. It does not even know whether the real TLS server associated with that domain name has ever received its initial messages.",
      "ja": "TLSクライアントはTLSサーバとメッセージを交換して接続を開始します。多くのアプリケーションプロトコルの場合は、名前に関連付けられたインターネットプロトコル（IP）アドレスを取得するためにDNSを使用して、サーバーの名前を検索します。その後、そのアドレスの特定のポートへの接続を開始し、そしてそこに最初のメッセージを送信します。ただし、クライアントはまだ敵が傍受および/またはそれがTLSサーバに到達する前にその通信を変えているかどうか分かりません。それも、そのドメイン名に関連付けられた実際のTLSサーバは、これまでその最初のメッセージを受信したかどうか分かりません。"
    },
    {
      "indent": 3,
      "text": "The first response from the server in TLS may contain a certificate. In order for the TLS client to authenticate that it is talking to the expected TLS server, the client must validate that this certificate is associated with the domain name used by the client to get to the server. Currently, the client must extract the domain name from the certificate and must successfully validate the certificate, including chaining to a trust anchor.",
      "ja": "TLSでサーバーからの最初の応答は、証明書が含まれていてもよいです。 TLSクライアントは、それが予想されるTLSサーバーに話していることを認証するためには、クライアントは、この証明書がサーバに到達するためにクライアントが使用するドメイン名に関連付けられていることを検証する必要があります。現在、クライアントが証明書からドメイン名を抽出する必要がありますし、成功したトラストアンカーにチェーン化を含め、証明書を検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "There is a different way to authenticate the association of the server's certificate with the intended domain name without trusting an external CA. Given that the DNS administrator for a domain name is authorized to give identifying information about the zone, it makes sense to allow that administrator to also make an authoritative binding between the domain name and a certificate that might be used by a host at that domain name. The easiest way to do this is to use the DNS, securing the binding with DNSSEC.",
      "ja": "外部CAを信頼することなく、意図したドメイン名を持つサーバーの証明書の関連付けを認証するためのさまざまな方法がありますドメイン名のDNS管理者は、ゾーンに関する識別情報を提供するために許可されていることを考えると、それはその管理者は、ドメイン名とそのドメイン名でホストによって使用される可能性のある証明書間の権威結合させることができるように理にかなっています。これを行う最も簡単な方法は、DNSSECとの結合を確保し、DNSを使用することです。"
    },
    {
      "indent": 3,
      "text": "There are many use cases for such functionality. [RFC6394] lists the ones to which the DNS RRtype in this document apply. [RFC6394] also lists many requirements, most of which this document is believed to meet. Section 5 covers the applicability of this document to the use cases in detail. The protocol in this document can generally be referred to as the \"DANE TLSA\" protocol. (\"TLSA\" does not stand for anything; it is just the name of the RRtype.)",
      "ja": "このような機能のための多くのユースケースがあります。 [RFC6394]は、この文書内のDNS RRtypeが適用されるものを示しています。 [RFC6394]は、この文書が合うように考えられているそのほとんどが多くの要件を、一覧表示されます。第5節では、詳細なユースケースには、この文書の適用可能性をカバーしています。この文書に記載されているプロトコルは、一般に「DANE TLSA」プロトコルと呼ぶことができます。 （「TLSAは、」何のために立っていない、それだけでRRtypeの名前です。）"
    },
    {
      "indent": 3,
      "text": "This document applies to both TLS [RFC5246] and Datagram TLS (DTLS) [RFC6347]. In order to make the document more readable, it mostly only talks about \"TLS\", but in all cases, it means \"TLS or DTLS\". Although the references in this paragraph are to TLS and DTLS version 1.2, the DANE TLSA protocol can also be used with earlier versions of TLS and DTLS.",
      "ja": "この文書では、TLS [RFC5246]及びデータグラムTLS（DTLS）[RFC6347]の両方に適用されます。文書を読みやすくするためには、「TLS」、程度が、すべての場合において、ほとんど唯一の会談は、「TLSまたはDTLS」を意味します。この段落の参照はTLSとDTLSバージョン1.2にしているが、DANE TLSAプロトコルはまた、TLSとDTLSの以前のバージョンで使用することができます。"
    },
    {
      "indent": 3,
      "text": "This document only relates to securely associating certificates for TLS and DTLS with host names; retrieving certificates from DNS for other protocols is handled in other documents. For example, keys for IPsec are covered in [RFC4025], and keys for Secure SHell (SSH) are covered in [RFC4255].",
      "ja": "この文書では、唯一の安全にホスト名とTLSの証明書とDTLSを関連付けるに関する。他のプロトコルのためのDNSからの証明書を取得すると、他の文書で扱われています。例えば、IPsec用のキーは[RFC4025]でカバーされ、セキュアシェル（SSH）のキーは、[RFC4255]で覆われています。"
    },
    {
      "indent": 0,
      "text": "1.3. Method for Securing Certificate Associations",
      "section_title": true,
      "ja": "1.3。セキュアな認証団体のための方法"
    },
    {
      "indent": 3,
      "text": "A certificate association is formed from a piece of information identifying a certificate and the domain name where the server application runs. The combination of a trust anchor and a domain name can also be a certificate association.",
      "ja": "証明書の関連付けは、サーバーアプリケーションが実行された証明書およびドメイン名を特定する情報の一片から形成されます。トラストアンカーとドメイン名の組み合わせはまた、証明書アソシエーションすることができます。"
    },
    {
      "indent": 3,
      "text": "A DNS query can return multiple certificate associations, such as in the case of a server that is changing from one certificate to another (described in more detail in Appendix A.4).",
      "ja": "DNSクエリは、別の証明書から変更されたサーバの場合のように複数の証明書の関連付けは、（付録A.4に詳細に説明する）を返すことができます。"
    },
    {
      "indent": 3,
      "text": "This document only applies to PKIX [RFC5280] certificates, not certificates of other formats.",
      "ja": "この文書では、唯一のPKIX [RFC5280]の証明書ではなく、他の形式の証明書に適用されます。"
    },
    {
      "indent": 3,
      "text": "This document defines a secure method to associate the certificate that is obtained from the TLS server with a domain name using DNS; the DNS information needs to be protected by DNSSEC. Because the certificate association was retrieved based on a DNS query, the domain name in the query is by definition associated with the certificate. Note that this document does not cover how to associate certificates with domain names for application protocols that depend on SRV, NAPTR, and similar DNS resource records. It is expected that future documents will cover methods for making those associations, and those documents may or may not need to update this one.",
      "ja": "この文書では、DNSを使用して、ドメイン名とTLSサーバから取得された証明書を関連付けるために安全な方法を定義します。 DNS情報は、DNSSECで保護する必要があります。証明書の関連付けはDNSクエリに基づいて取得されたため、クエリ内のドメイン名は、証明書に関連付けられた定義です。このドキュメントはSRV、NAPTR、および類似のDNSリソースレコードに依存したアプリケーションプロトコルのドメイン名と証明書を関連付ける方法をカバーしていないことに注意してください。将来の文書は、それらの関連付けを作成するための方法をカバーし、それらの文書は、またはこのいずれかを更新する必要がないかもしれないことが予想されます。"
    },
    {
      "indent": 3,
      "text": "DNSSEC, which is defined in [RFC4033], [RFC4034], and [RFC4035], uses cryptographic keys and digital signatures to provide authentication of DNS data. Information that is retrieved from the DNS and that is validated using DNSSEC is thereby proved to be the authoritative data. The DNSSEC signature needs to be validated on all responses that use DNSSEC in order to assure the proof of origin of the data.",
      "ja": "[RFC4033]、[RFC4034]及び[RFC4035]で定義されているDNSSECは、DNSデータの認証を提供するために、暗号鍵およびデジタル署名を使用します。 DNSから取得され、それはDNSSECを使用して検証された情報は、それにより、正式なデータであることが証明されています。 DNSSECの署名は、データの起源の証拠を確保するためにDNSSECを使用するすべての応答で検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "This document does not specify how DNSSEC validation occurs because there are many different proposals for how a client might get validated DNSSEC results, such as from a DNSSEC-aware resolver that is coded in the application, from a trusted DNSSEC resolver on the machine on which the application is running, or from a trusted DNSSEC resolver with which the application is communicating over an authenticated and integrity-protected channel or network. This is described in more detail in Section 7 of [RFC4033].",
      "ja": "クライアントマシン上で、信頼できるDNSSECリゾルバから、このようなアプリケーションでコーディングされているDNSSEC対応リゾルバからのような検証DNSSECの結果を取得する方法について、さまざまな提案があるので、このドキュメントは、検証がどのように発生するかDNSSEC指定されていません。アプリケーションが実行中、またはアプリケーションが認証され、完全性保護チャネルまたはネットワークを介して通信している信頼できるDNSSECリゾルバからのものです。これは、[RFC4033]のセクション7でより詳細に記載されています。"
    },
    {
      "indent": 3,
      "text": "This document only relates to getting the DNS information for the certificate association securely using DNSSEC; other secure DNS mechanisms are out of scope.",
      "ja": "この文書は、安全DNSSECを使用して証明書の関連付けのためのDNS情報の取得に関する。他のセキュアなDNSの仕組みは適用範囲外です。"
    },
    {
      "indent": 0,
      "text": "1.4. Terminology",
      "section_title": true,
      "ja": "1.4。用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document also makes use of standard PKIX, DNSSEC, TLS, and DNS terminology. See [RFC5280], [RFC4033], [RFC5246], and STD 13 [RFC1034] [RFC1035], respectively, for these terms. In addition, terms related to TLS-protected application services and DNS names are taken from [RFC6125].",
      "ja": "この資料はまた標準PKIX、DNSSEC、TLS、およびDNSの用語を使用します。これらの用語のために、それぞれ、[RFC5280]、[RFC4033]、[RFC5246]、およびSTD 13 [RFC1034]、[RFC1035]を参照されたいです。また、TLSで保護されたアプリケーションサービスとDNS名に関連する用語は[RFC6125]から取られます。"
    },
    {
      "indent": 0,
      "text": "2. The TLSA Resource Record",
      "section_title": true,
      "ja": "2. TLSAリソースレコードに"
    },
    {
      "indent": 3,
      "text": "The TLSA DNS resource record (RR) is used to associate a TLS server certificate or public key with the domain name where the record is found, thus forming a \"TLSA certificate association\". The semantics of how the TLSA RR is interpreted are given later in this document.",
      "ja": "TLSA DNSリソースレコード（RR）は、レコードがこのように「TLSA証明書の関連付け」を形成し、発見されたドメイン名とのTLSサーバ証明書または公開鍵を関連付けるために使用されます。 TLSA RRがどのように解釈されるかのセマンティクスは、このドキュメントの後半で与えられています。"
    },
    {
      "indent": 3,
      "text": "The type value for the TLSA RR type is defined in Section 7.1.",
      "ja": "TLSA RRタイプのタイプ値はセクション7.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "The TLSA RR is class independent.",
      "ja": "TLSA RRはクラスから独立しています。"
    },
    {
      "indent": 3,
      "text": "The TLSA RR has no special Time to Live (TTL) requirements.",
      "ja": "TLSA RRは（TTL）の要件をライブするための特別な時間を持っていません。"
    },
    {
      "indent": 0,
      "text": "2.1. TLSA RDATA Wire Format",
      "section_title": true,
      "ja": "2.1。 TLSA RDATAワイヤーフォーマット"
    },
    {
      "indent": 3,
      "text": "The RDATA for a TLSA RR consists of a one-octet certificate usage field, a one-octet selector field, a one-octet matching type field, and the certificate association data field.",
      "ja": "TLSA RR用RDATAは、1オクテットの証明書の使用フィールド、1オクテット・セレクタ・フィールド、1オクテットのマッチングタイプフィールド、および証明書関連データフィールドから成ります。"
    },
    {
      "indent": 3,
      "text": "                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Cert. Usage  |   Selector    | Matching Type |               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               /\n/                                                               /\n/                 Certificate Association Data                  /\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.1.1. The Certificate Usage Field",
      "section_title": true,
      "ja": "2.1.1。証明書の使用フィールド"
    },
    {
      "indent": 3,
      "text": "A one-octet value, called \"certificate usage\", specifies the provided association that will be used to match the certificate presented in the TLS handshake. This value is defined in a new IANA registry (see Section 7.2) in order to make it easier to add additional certificate usages in the future. The certificate usages defined in this document are:",
      "ja": "「証明書の使用法」と呼ばれる1オクテットの値は、TLSハンドシェイク中に提示された証明書を一致させるために使用される設けられた関連付けを指定します。この値は、それが簡単に将来的に追加の証明書の使用を追加できるようにするために（セクション7.2を参照）新しいIANAレジストリに定義されています。この文書で定義された証明書の使用は、以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "0 -- Certificate usage 0 is used to specify a CA certificate, or the public key of such a certificate, that MUST be found in any of the PKIX certification paths for the end entity certificate given by the server in TLS. This certificate usage is sometimes referred to as \"CA constraint\" because it limits which CA can be used to issue certificates for a given service on a host. The presented certificate MUST pass PKIX certification path validation, and a CA certificate that matches the TLSA record MUST be included as part of a valid certification path. Because this certificate usage allows both trust anchors and CA certificates, the certificate might or might not have the basicConstraints extension present.",
      "ja": "0  - 証明書の使用0は、CA証明書、またはTLSにおけるサーバによって与えられたエンドエンティティ証明書のPKIX認証パスのいずれかに見つけなければならないような証明書の公開鍵を指定するために使用されます。それはCAがホスト上の特定のサービスのための証明書を発行するために使用できる制限するので、この証明書の使用は、時々、「CA制約」と呼ばれています。提示された証明書は、PKIX証明書パスの検証、およびTLSAレコードが有効な証明書パスの一部として含まれなければならない一致したCA証明書を渡す必要があります。この証明書の利用は、トラストアンカーとCA証明書の両方を可能にするので、証明書がまたはbasicConstraintsの拡張存在を持っていない場合があります。"
    },
    {
      "indent": 6,
      "text": "1 -- Certificate usage 1 is used to specify an end entity certificate, or the public key of such a certificate, that MUST be matched with the end entity certificate given by the server in TLS. This certificate usage is sometimes referred to as \"service certificate constraint\" because it limits which end entity certificate can be used by a given service on a host. The target certificate MUST pass PKIX certification path validation and MUST match the TLSA record.",
      "ja": "1  - 証明書の使用法1は、エンドエンティティ証明書、またはTLSにおけるサーバによって与えられたエンドエンティティ証明書と一致しなければならないような証明書の公開鍵を指定するために使用されます。それはホスト上の指定されたサービスが使用可能なエンドエンティティ証明書を制限するので、この証明書の使用は、時には「サービス証明書の制約」と呼ばれます。ターゲット証明書は、PKIX証明書パス検証に合格しなければならないとTLSAのレコードと一致しなければなりません。"
    },
    {
      "indent": 6,
      "text": "2 -- Certificate usage 2 is used to specify a certificate, or the public key of such a certificate, that MUST be used as the trust anchor when validating the end entity certificate given by the server in TLS. This certificate usage is sometimes referred to as \"trust anchor assertion\" and allows a domain name administrator to specify a new trust anchor -- for example, if the domain issues its own certificates under its own CA that is not expected to be in the end users' collection of trust anchors. The target certificate MUST pass PKIX certification path validation, with any certificate matching the TLSA record considered to be a trust anchor for this certification path validation.",
      "ja": "2  - 証明書の使用法2は、証明書、またはTLSにおけるサーバによって与えられたエンドエンティティ証明書を検証するときトラストアンカーとして使用する必要があり、このような証明書の公開鍵を指定するために使用されます。この証明書の利用は時々「トラストアンカーアサーション」と呼ばれ、新しいトラストアンカーを指定するには、ドメイン名の管理者を許可される - たとえば、ドメインが最後になると予想されていない独自のCAの下で、独自の証明書を発行した場合トラストアンカーのユーザーの集まり。ターゲット証明書には、この証明書パス検証のためのトラストアンカーと見なさTLSAレコードに一致する証明書を使用して、PKIX証明書パス検証に合格しなければなりません。"
    },
    {
      "indent": 6,
      "text": "3 -- Certificate usage 3 is used to specify a certificate, or the public key of such a certificate, that MUST match the end entity certificate given by the server in TLS. This certificate usage is sometimes referred to as \"domain-issued certificate\" because it allows for a domain name administrator to issue certificates for a domain without involving a third-party CA. The target certificate MUST match the TLSA record. The difference between certificate usage 1 and certificate usage 3 is that certificate usage 1 requires that the certificate pass PKIX validation, but PKIX validation is not tested for certificate usage 3.",
      "ja": "3  - 証明書の使用法3は、証明書、またはTLSにおけるサーバによって与えられたエンドエンティティ証明書と一致する必要があり、このような証明書の公開鍵を指定するために使用されます。ドメイン名の管理者は、サードパーティのCAを介さずに、ドメインの証明書を発行することができますので、この証明書の利用は、時には「ドメイン発行の証明書」と呼ばれますターゲット証明書はTLSAのレコードと一致しなければなりません。証明書の使用法1及び証明書の使用法3との間の差は、証明書の使用1は、証明書パスPKIX検証が、PKIX検証は、証明書の使用法3について試験されていないことを必要とすることです。"
    },
    {
      "indent": 3,
      "text": "The certificate usages defined in this document explicitly only apply to PKIX-formatted certificates in DER encoding [X.690]. If TLS allows other formats later, or if extensions to this RRtype are made that accept other formats for certificates, those certificates will need their own certificate usage values.",
      "ja": "この文書で定義された証明書の使用は、明示的にのみ、[X.690] DERエンコーディングでPKIXフォーマットの証明書に適用されます。 TLSは、他のフォーマット後に許可している場合、このRRtypeへの拡張は、証明書の他のフォーマットを受け入れることを行われた場合、または、それらの証明書は、独自の証明書の利用値が必要になります。"
    },
    {
      "indent": 0,
      "text": "2.1.2. The Selector Field",
      "section_title": true,
      "ja": "2.1.2。セレクタフィールド"
    },
    {
      "indent": 3,
      "text": "A one-octet value, called \"selector\", specifies which part of the TLS certificate presented by the server will be matched against the association data. This value is defined in a new IANA registry (see Section 7.3). The selectors defined in this document are:",
      "ja": "「セレクタ」と呼ばれる1オクテットの値が、関連データと照合するサーバによって提示TLS証明書のどの部分を指定します。この値は、新しいIANAレジストリに定義されている（7.3節を参照してください）。この文書で定義されたセレクタは、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "0 -- Full certificate: the Certificate binary structure as defined in [RFC5280]",
      "ja": "0  - 完全な証明書：証明書のバイナリ構造[RFC5280]で定義されるように"
    },
    {
      "indent": 6,
      "text": "1 -- SubjectPublicKeyInfo: DER-encoded binary structure as defined in [RFC5280]",
      "ja": "1  -  SubjectPublicKeyInfoで：DER符号化されたバイナリ構造[RFC5280]で定義されるように"
    },
    {
      "indent": 3,
      "text": "(Note that the use of \"selector\" in this document is completely unrelated to the use of \"selector\" in DomainKeys Identified Mail (DKIM) [RFC6376].)",
      "ja": "（本書では「セレクタ」の使用は、メール（DKIM識別ドメインキーで「セレクタ」の使用）[RFC6376]に完全に無関係であることに注意してください。）"
    },
    {
      "indent": 0,
      "text": "2.1.3. The Matching Type Field",
      "section_title": true,
      "ja": "2.1.3。マッチングタイプフィールド"
    },
    {
      "indent": 3,
      "text": "A one-octet value, called \"matching type\", specifies how the certificate association is presented. This value is defined in a new IANA registry (see Section 7.4). The types defined in this document are:",
      "ja": "「マッチタイプ」と呼ばれる1オクテットの値は、証明書の関連付けが提示される方法を指定します。この値は、新しいIANAレジストリに定義されている（7.4節を参照してください）。この文書で定義されたタイプは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "0 -- Exact match on selected content",
      "ja": "0  - 選択したコンテンツの完全一致"
    },
    {
      "indent": 6,
      "text": "1 -- SHA-256 hash of selected content [RFC6234]",
      "ja": "1  - 選択されたコンテンツのSHA-256ハッシュ[RFC6234]"
    },
    {
      "indent": 6,
      "text": "2 -- SHA-512 hash of selected content [RFC6234]",
      "ja": "2  - 選択されたコンテンツのSHA-512ハッシュ[RFC6234]"
    },
    {
      "indent": 3,
      "text": "If the TLSA record's matching type is a hash, having the record use the same hash algorithm that was used in the signature in the certificate (if possible) will assist clients that support a small number of hash algorithms.",
      "ja": "TLSAレコードのマッチングタイプは、レコードがハッシュアルゴリズムの小さな数をサポートするクライアントを支援する証明書に署名（可能な場合）に使用されたのと同じハッシュアルゴリズムを使用有する、ハッシュである場合。"
    },
    {
      "indent": 0,
      "text": "2.1.4. The Certificate Association Data Field",
      "section_title": true,
      "ja": "2.1.4。証明書協会データフィールド"
    },
    {
      "indent": 3,
      "text": "This field specifies the \"certificate association data\" to be matched. These bytes are either raw data (that is, the full certificate or its SubjectPublicKeyInfo, depending on the selector) for matching type 0, or the hash of the raw data for matching types 1 and 2. The data refers to the certificate in the association, not to the TLS ASN.1 Certificate object.",
      "ja": "このフィールドは、「証明書対応データ」に一致することを指定します。これらのバイトは、生データのいずれかである（すなわち、完全な証明書またはセレクタに応じてそのSubjectPublicKeyInfoで、）タイプ0を一致させるため、またはデータが関連して証明書を指し、1型および2を合わせるための生データのハッシュ、ではないTLS ASN.1 Certificateオブジェクトへ。"
    },
    {
      "indent": 0,
      "text": "2.2. TLSA RR Presentation Format",
      "section_title": true,
      "ja": "2.2。 TLSA RRプレゼンテーションフォーマット"
    },
    {
      "indent": 3,
      "text": "The presentation format of the RDATA portion (as defined in [RFC1035]) is as follows:",
      "ja": "次のように（[RFC1035]で定義されるように）RDATA部の提示形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The certificate usage field MUST be represented as an 8-bit unsigned integer.",
      "ja": "証明書の利用分野O 8ビットの符号なし整数として表現されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The selector field MUST be represented as an 8-bit unsigned integer.",
      "ja": "Oセレクタフィールドは、8ビットの符号なし整数として表現されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The matching type field MUST be represented as an 8-bit unsigned integer.",
      "ja": "マッチングタイプフィールドO 8ビットの符号なし整数として表現されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The certificate association data field MUST be represented as a string of hexadecimal characters. Whitespace is allowed within the string of hexadecimal characters, as described in [RFC1035].",
      "ja": "O証明書関連データフィールドは16進文字列として表現されなければなりません。 [RFC1035]に記載されているように空白を16進数の文字列内で許可されています。"
    },
    {
      "indent": 0,
      "text": "2.3. TLSA RR Examples",
      "section_title": true,
      "ja": "2.3。 TLSA RR例"
    },
    {
      "indent": 3,
      "text": "In the following examples, the domain name is formed using the rules in Section 3.",
      "ja": "以下の実施例では、ドメイン名が第3のルールを使用して形成されています。"
    },
    {
      "indent": 3,
      "text": "An example of a hashed (SHA-256) association of a PKIX CA certificate:",
      "ja": "PKIX CA証明書のハッシュ（SHA-256）の関連付けの例："
    },
    {
      "indent": 3,
      "text": "_443._tcp.www.example.com. IN TLSA ( 0 0 1 d2abde240d7cd3ee6b4b28c54df034b9 7983a1d16e8a410e4561cb106618e971 )",
      "ja": "_443._tcp.www.example.com。 TLSA IN（0 0 1 d2abde240d7cd3ee6b4b28c54df034b9 7983a1d16e8a410e4561cb106618e971を）"
    },
    {
      "indent": 3,
      "text": "An example of a hashed (SHA-512) subject public key association of a PKIX end entity certificate:",
      "ja": "PKIXエンドエンティティ証明書のハッシュ（SHA-512）サブジェクト公開鍵アソシエーションの例："
    },
    {
      "indent": 3,
      "text": "_443._tcp.www.example.com. IN TLSA ( 1 1 2 92003ba34942dc74152e2f2c408d29ec a5a520e7f2e06bb944f4dca346baf63c 1b177615d466f6c4b71c216a50292bd5 8c9ebdd2f74e38fe51ffd48c43326cbc )",
      "ja": "_443._tcp.www.example.com。 TLSA IN（1 1 2 92003ba34942dc74152e2f2c408d29ec a5a520e7f2e06bb944f4dca346baf63c 1b177615d466f6c4b71c216a50292bd5 8c9ebdd2f74e38fe51ffd48c43326cbc）"
    },
    {
      "indent": 3,
      "text": "An example of a full certificate association of a PKIX end entity certificate:",
      "ja": "PKIXのエンドエンティティ証明書の完全な証明書アソシエーションの例："
    },
    {
      "indent": 3,
      "text": "_443._tcp.www.example.com. IN TLSA ( 3 0 0 30820307308201efa003020102020... )",
      "ja": "_443._tcp.www.example.com。 TLSA IN（3 0 0 30820307308201efa003020102020 ...）"
    },
    {
      "indent": 0,
      "text": "3. Domain Names for TLSA Certificate Associations",
      "section_title": true,
      "ja": "TLSA証明書アソシエーションの3ドメイン名"
    },
    {
      "indent": 3,
      "text": "Unless there is a protocol-specific specification that is different than this one, TLSA resource records are stored at a prefixed DNS domain name. The prefix is prepared in the following manner:",
      "ja": "これとは異なっているプロトコル固有の仕様がない限り、TLSAリソースレコードは、接頭辞DNSドメイン名で保存されています。接頭辞は次のようにして調製されています。"
    },
    {
      "indent": 3,
      "text": "1. The decimal representation of the port number on which a TLS-based service is assumed to exist is prepended with an underscore character (\"_\") to become the left-most label in the prepared domain name. This number has no leading zeros.",
      "ja": "1. TLSベースのサービスが存在すると想定されているポート番号の10進表現を準備したドメイン名で、一番左のラベルになるために、下線文字（「_」）に付加されます。この数には先行ゼロを持っていません。"
    },
    {
      "indent": 3,
      "text": "2. The protocol name of the transport on which a TLS-based service is assumed to exist is prepended with an underscore character (\"_\") to become the second left-most label in the prepared domain name. The transport names defined for this protocol are \"tcp\", \"udp\", and \"sctp\".",
      "ja": "2. TLSベースのサービスが存在すると仮定されているトランスポートのプロトコル名が準備ドメイン名に第二の最も左側のラベルになるように下線文字（「_」）を用いて付加されます。このプロトコルのために定義されたトランスポート名は「TCP」、「UDP」、および「SCTP」です。"
    },
    {
      "indent": 3,
      "text": "3. The base domain name is appended to the result of step 2 to complete the prepared domain name. The base domain name is the fully qualified DNS domain name [RFC1035] of the TLS server, with the additional restriction that every label MUST meet the rules of [RFC0952]. The latter restriction means that, if the query is for an internationalized domain name, it MUST use the A-label form as defined in [RFC5890].",
      "ja": "3.ベースのドメイン名が準備ドメイン名を完了するためにステップ2の結果に追加されます。ベースのドメイン名は、すべてのラベルは、[RFC0952]の規則を満たす必要があり、追加の制限、TLSサーバの完全修飾DNSドメイン名[RFC1035]です。後者の制限は、クエリが国際化ドメイン名のためのものである場合は、[RFC5890]で定義されるように、それはA-ラベルフォームを使用しなければならない、ということを意味します。"
    },
    {
      "indent": 3,
      "text": "For example, to request a TLSA resource record for an HTTP server running TLS on port 443 at \"www.example.com\", \"_443._tcp.www.example.com\" is used in the request. To request a TLSA resource record for an SMTP server running the STARTTLS protocol on port 25 at \"mail.example.com\", \"_25._tcp.mail.example.com\" is used.",
      "ja": "たとえば、「www.example.com」で、ポート443でTLSを実行しているHTTPサーバのためのTLSAリソースレコードを要求するために、「_443._tcp.www.example.comは」要求に使用されています。 「mail.example.com」でポート25上のSTARTTLSプロトコルを実行しているSMTPサーバーのTLSAリソースレコードを要求するには、「_25._tcp.mail.example.com」に使用されます。"
    },
    {
      "indent": 0,
      "text": "4. Use of TLSA Records in TLS",
      "section_title": true,
      "ja": "TLSでTLSAレコードの4."
    },
    {
      "indent": 3,
      "text": "Section 2.1 of this document defines the mandatory matching rules for the data from the TLSA certificate associations and the certificates received from the TLS server.",
      "ja": "この文書のセクション2.1 TLSA証明書アソシエーションからデータ及びTLSサーバから受信した証明書のために必須のマッチング規則を定義します。"
    },
    {
      "indent": 3,
      "text": "The TLS session that is to be set up MUST be for the specific port number and transport name that was given in the TLSA query.",
      "ja": "設定されるTLSセッションがTLSAクエリで指定された特定のポート番号およびトランスポート名のためでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Some specifications for applications that run over TLS, such as [RFC2818] for HTTP, require that the server's certificate have a domain name that matches the host name expected by the client. Some specifications, such as [RFC6125], detail how to match the identity given in a PKIX certificate with those expected by the user.",
      "ja": "HTTPのために、このような[RFC2818]としてTLS上で動作するアプリケーションのためのいくつかの仕様は、サーバーの証明書がクライアントによって期待されるホスト名と一致するドメイン名を持っている必要があります。このような[RFC6125]などのいくつかの仕様、詳細ユーザが期待するものとPKIX証明書に指定されたIDと一致する方法。"
    },
    {
      "indent": 3,
      "text": "If a TLSA record has certificate usage 2, the corresponding TLS server SHOULD send the certificate that is referenced just like it currently sends intermediate certificates.",
      "ja": "TLSAレコードが証明書の使用方法2を持っている場合は、対応するTLSサーバは、それが現在、中間証明書を送るだけのように参照された証明書を送るべきです。"
    },
    {
      "indent": 0,
      "text": "4.1. Usable Certificate Associations",
      "section_title": true,
      "ja": "4.1。使用可能な証明書の関連付け"
    },
    {
      "indent": 3,
      "text": "An implementation of this protocol makes a DNS query for TLSA records, validates these records using DNSSEC, and uses the resulting TLSA records and validation status to modify its responses to the TLS server.",
      "ja": "このプロトコルの実装は、TLSAレコードのDNSクエリを作るDNSSECを使用してこれらのレコードを検証し、TLSサーバへの応答を変更するために結果TLSAの記録と検証ステータスを使用しています。"
    },
    {
      "indent": 3,
      "text": "Determining whether a TLSA RRSet can be used MUST be based on the DNSSEC validation state (as defined in [RFC4033]).",
      "ja": "TLSA資源レコード集合はDNSSEC検証状態に基づいている必要があります使用することができるかどうかを決定する（[RFC4033]で定義されるように）。"
    },
    {
      "indent": 3,
      "text": "o A TLSA RRSet whose DNSSEC validation state is secure MUST be used as a certificate association for TLS unless a local policy would prohibit the use of the specific certificate association in the secure TLSA RRSet.",
      "ja": "OそのDNSSEC検証状態安全なローカルポリシーは、セキュアTLSA資源レコード集合に特定の証明書の関連付けの使用を禁止しない限りTLSの証明書の関連付けとして使用する必要がありTLSA資源レコード集合。"
    },
    {
      "indent": 3,
      "text": "o If the DNSSEC validation state on the response to the request for the TLSA RRSet is bogus, this MUST cause TLS not to be started or, if the TLS negotiation is already in progress, MUST cause the connection to be aborted.",
      "ja": "O TLSA資源レコード集合のための要求に対する応答にDNSSEC検証状態が偽であれば、これは開始されていないTLSを起こさなければならまたは、TLS交渉が進行中の場合、接続が中断させなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A TLSA RRSet whose DNSSEC validation state is indeterminate or insecure cannot be used for TLS and MUST be considered unusable.",
      "ja": "OそのDNSSEC検証状態不定であるか、または安全でないTLSのために使用することができず、使用不可能とみなされなければならないTLSA資源レコード集合。"
    },
    {
      "indent": 3,
      "text": "Clients that validate the DNSSEC signatures themselves MUST use standard DNSSEC validation procedures. Clients that rely on another entity to perform the DNSSEC signature validation MUST use a secure mechanism between themselves and the validator. Examples of secure transports to other hosts include TSIG [RFC2845], SIG(0) [RFC2931], and IPsec [RFC6071]. Note that it is not sufficient to use secure transport to a DNS resolver that does not do DNSSEC signature validation. See Section 8.3 for more security considerations related to external validators.",
      "ja": "DNSSECの署名を検証するクライアントは、自身が標準のDNSSECの検証手順を使用しなければなりません。 DNSSEC署名の検証を行うために別のエンティティに依存しているクライアントは、自分自身とバリの間に安全なメカニズムを使用しなければなりません。他のホストへの安全なトランスポートの例としては、TSIG [RFC2845]、SIG（0）[RFC2931]、およびIPsec [RFC6071]を含みます。 DNSSEC署名検証を行いませんDNSリゾルバへの安全な輸送を使用するには十分ではないことに注意してください。外部バリデータに関連する複数のセキュリティ上の考慮事項については、セクション8.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "If a certificate association contains a certificate usage, selector, or matching type that is not understood by the TLS client, that certificate association MUST be considered unusable. If the comparison data for a certificate is malformed, the certificate association MUST be considered unusable.",
      "ja": "証明書の関連付けがTLSクライアントによって理解されていない証明書の使用、セレクタ、又はマッチングタイプが含まれている場合は、その証明書の関連付けが使用不可と見なされなければなりません。証明書の比較データが奇形されている場合は、証明書アソシエーションが使用できなく考えなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a certificate association contains a matching type or certificate association data that uses a cryptographic algorithm that is considered too weak for the TLS client's policy, the certificate association MUST be considered unusable.",
      "ja": "証明書アソシエーションは、TLSクライアントのポリシーのためには弱すぎると考えられている暗号アルゴリズムを使用して、一致するタイプまたは証明書関連のデータが含まれている場合は、証明書アソシエーションが使用できなく考えなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an application receives zero usable certificate associations from a DNS request or from its cache, it processes TLS in the normal fashion without any input from the TLSA records. If an application receives one or more usable certificate associations, it attempts to match each certificate association with the TLS server's end entity certificate until a successful match is found. During the TLS handshake, if none of the certificate associations matches the certificate given by the TLS server, the TLS client MUST abort the handshake.",
      "ja": "アプリケーションがDNS要求からまたはキャッシュからゼロ使用可能な証明書の関連付けを受信した場合、それはTLSAレコードからの入力なしに通常の方法でTLSを処理します。アプリケーションは、1つまたは複数の使用可能な証明書の関連付けを受信した場合、それは成功したマッチが見つかるまで、TLSサーバーのエンドエンティティ証明書で各証明書の関連付けと一致することを試みます。証明書アソシエーションのどれもがTLSサーバによって与えられた証明書と一致しない場合は、TLSハンドシェイク中に、TLSクライアントは握手を中止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "An attacker who is able to divert a user to a server under his control is also likely to be able to block DNS requests from the user or DNS responses being sent to the user. Thus, in order to achieve any security benefit from certificate usage 0 or 1, an application that sends a request for TLSA records needs to get either a valid signed response containing TLSA records or verification that the domain is insecure or indeterminate. If a request for a TLSA record does not meet one of those two criteria but the application continues with the TLS handshake anyway, the application has gotten no benefit from TLSA and SHOULD NOT make any internal or external indication that TLSA was applied. If an application has a configuration setting that has turned on TLSA use, or has any indication that TLSA is in use (regardless of whether or not this is configurable), that application either MUST NOT start a TLS connection or it MUST abort a TLS handshake if both of the two criteria above are not met.",
      "ja": "彼の制御下にあるサーバーにユーザーをそらすことが可能である攻撃者は、ユーザーに送信されているユーザまたはDNS応答からのDNS要求をブロックすることができそうです。このように、証明書の利用0または1から任意のセキュリティ上の利点を達成するために、TLSAレコードに対する要求を送信するアプリケーションは、ドメインが安全でないか、不確定であることをTLSAレコードや検証を含む有効な署名応答のいずれかを取得する必要があります。とにかくTLSAレコードに対する要求は、これらの2つの条件のいずれかを満たしていないが、アプリケーションは、TLSハンドシェイクを続行した場合、アプリケーションはTLSAからの利益を得ていないとTLSAが適用されたことを任意の内部または外部の表示を行うべきではありません。アプリケーションがTLSA用途になっている構成設定を有する、またはTLSAは（かかわらず、これは構成可能であるか否かの）使用中であること兆候がある場合、そのアプリケーションは、TLS接続を開始してはいけませんいずれか、またはそれがTLSハンドシェイクを中断しなければなりません上記の二つの基準の両方が満たされていない場合。"
    },
    {
      "indent": 3,
      "text": "The application can perform the TLSA lookup before initiating the TLS handshake, or do it during the TLS handshake: the choice is up to the client.",
      "ja": "アプリケーションは、TLSハンドシェイクを開始する前にTLSAルックアップを実行、またはTLSハンドシェイク中にそれを行うことができます。選択はクライアント次第です。"
    },
    {
      "indent": 0,
      "text": "5. TLSA and DANE Use Cases and Requirements",
      "section_title": true,
      "ja": "5. TLSAとDANE利用事例と要件"
    },
    {
      "indent": 3,
      "text": "The different types of certificate associations defined in TLSA are matched with various sections of [RFC6394]. The use cases from Section 3 of [RFC6394] are covered in this document as follows:",
      "ja": "TLSAで定義された証明書の関連付けの異なるタイプが[RFC6394]の各部と一致しています。次のように[RFC6394]のセクション3のユースケースは、この文書で覆われています。"
    },
    {
      "indent": 3,
      "text": "3.1 CA Constraints -- Implemented using certificate usage 0.",
      "section_title": true,
      "ja": "3.1 CAの制約 - 証明書の使用法0を使用して実装されています。"
    },
    {
      "indent": 3,
      "text": "3.2 Certificate Constraints -- Implemented using certificate usage 1.",
      "section_title": true,
      "ja": "3.2証明書の制約 - 証明書の使用方法1を使用して実装されています。"
    },
    {
      "indent": 3,
      "text": "3.3 Trust Anchor Assertion and Domain-Issued Certificates -- Implemented using certificate usages 2 and 3, respectively.",
      "ja": "3.3トラストアンカーアサーション及びドメイン発行した証明書 - それぞれ、証明書の用途2及び3を使用して実装。"
    },
    {
      "indent": 3,
      "text": "The requirements from Section 4 of [RFC6394] are covered in this document as follows:",
      "ja": "次のように[RFC6394]のセクション4からの要求は、この文書で覆われています。"
    },
    {
      "indent": 3,
      "text": "Multiple Ports -- The TLSA records for different application services running on a single host can be distinguished through the service name and port number prefixed to the host name (see Section 3).",
      "ja": "複数のポート - 単一のホスト上で実行されているさまざまなアプリケーションサービスのためのTLSAレコードは、ホスト名の前に付加サービス名とポート番号によって区別することができます（第3章を参照してください）。"
    },
    {
      "indent": 3,
      "text": "No Downgrade -- Section 4 specifies the conditions under which a client can process and act upon TLSA records. Specifically, if the DNSSEC status for the TLSA resource record set is determined to be bogus, the TLS connection (if started) will fail.",
      "ja": "いいえダウングレード - 第4節では、クライアントがTLSA記録時に処理し、行動することができる条件を指定していません。 TLSAリソースレコードセットのためのDNSSECの状態が偽であると判断された場合には具体的に、（開始された場合）TLS接続が失敗します。"
    },
    {
      "indent": 3,
      "text": "Encapsulation -- Encapsulation is covered in the TLSA response semantics.",
      "ja": "カプセル化 - カプセル化はTLSA応答セマンティクスで覆われています。"
    },
    {
      "indent": 3,
      "text": "Predictability -- The appendices of this specification provide operational considerations and implementation guidance in order to enable application developers to form a consistent interpretation of the recommended client behavior.",
      "ja": "予測可能性 - この仕様の付録には、推奨されるクライアントの動作の一貫性のある解釈を形成するために、アプリケーション開発を可能とするために、運用の考慮事項および実装のガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "Opportunistic Security -- If a client conformant to this specification can reliably determine the presence of a TLSA record, it will attempt to use this information. Conversely, if a client can reliably determine the absence of any TLSA record, it will fall back to processing TLS in the normal fashion. This is discussed in Section 4.",
      "ja": "日和見セキュリティ - この仕様に準拠し、クライアントが確実にTLSAレコードの存在を決定することができれば、それはこの情報を使用しようとします。クライアントが確実に任意のTLSAレコードの有無を判断することができれば逆に、それは通常の方法でTLSの処理にフォールバックします。これは、第4節で議論されます。"
    },
    {
      "indent": 3,
      "text": "Combination -- Multiple TLSA records can be published for a given host name, thus enabling the client to construct multiple TLSA certificate associations that reflect different assertions. No support is provided to combine two TLSA certificate associations in a single operation.",
      "ja": "組み合わせ - 複数のTLSAレコードは、このように異なる主張を反映して、複数のTLSA証明書の関連付けを構築するために、クライアントを有効にする、指定されたホスト名のために公開することができます。何のサポートは、単一の操作で2つのTLSA証明書の関連付けを組み合わせるために提供されていません。"
    },
    {
      "indent": 3,
      "text": "Roll-over -- TLSA records are processed in the normal manner within the scope of the DNS protocol, including the TTL expiration of the records. This ensures that clients will not latch onto assertions made by expired TLSA records, and will be able to transition from using one public key or certificate usage to another.",
      "ja": "ロールオーバ -  TLSAレコードはレコードのTTLの期限切れを含む、DNSプロトコルの範囲内で通常の方法で処理されます。これは、クライアントが期限切れのTLSAレコードによってなされた主張にラッチしないことを保証し、別の公開鍵や証明書の使用方法を使用してから移行することができるようになります。"
    },
    {
      "indent": 3,
      "text": "Simple Key Management -- The SubjectPublicKeyInfo selector in the TLSA record provides a mode that enables a domain holder to only have to maintain a single long-lived public/private key pair without the need to manage certificates. Appendix A outlines the usefulness and the potential downsides to using this mode.",
      "ja": "シンプルなキー管理 -  TLSAレコードでSubjectPublicKeyInfoでセレクタは、証明書のみを管理する必要なしに、単一の長命の公開鍵/秘密鍵のペアを維持するために持っているドメインホルダーを可能モードを提供します。付録Aは、このモードを使用して有用性と潜在的なマイナス面の概要を説明します。"
    },
    {
      "indent": 3,
      "text": "Minimal Dependencies -- This specification relies on DNSSEC to protect the origin authenticity and integrity of the TLSA resource record set. Additionally, if DNSSEC validation is not performed on the system that wishes to use TLSA certificate bindings, this specification requires that the \"last mile\" be over a secure transport. There are no other deployment dependencies for this approach.",
      "ja": "最小限の依存関係 - この仕様はTLSAリソースレコードセットの起源の真正性と完全性を保護するためにDNSSECに依存しています。 DNSSEC検証がTLSA証明書バインディングを使用したいシステム上で実行されていない場合はさらに、この仕様は、「ラストマイル」は、安全な輸送の上にあることが必要です。このアプローチには、他のデプロイメントの依存関係はありません。"
    },
    {
      "indent": 3,
      "text": "Minimal Options -- The operating modes map precisely to the DANE use cases and requirements. DNSSEC use is mandatory in that this specification encourages applications to use only those TLSA records that are shown to be validated.",
      "ja": "最小限のオプション - 動作モードは、DANEのユースケースと要件に正確にマッピングされます。 DNSSECの使用は、この仕様書が検証されることが示されているのみTLSAレコードを使用するようにアプリケーションを奨励することに必須です。"
    },
    {
      "indent": 3,
      "text": "Wildcards -- Wildcards are covered in a limited manner in the TLSA request syntax; see Appendix A.",
      "ja": "ワイルドカード - ワイルドカードはTLSA要求構文で限定的に覆われています。付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "Redirection -- Redirection is covered in the TLSA request syntax; see Appendix A.",
      "ja": "リダイレクト - リダイレクトがTLSA要求構文で覆われています。付録Aを参照してください。"
    },
    {
      "indent": 0,
      "text": "6. Mandatory-to-Implement Features",
      "section_title": true,
      "ja": "6.実装に必須の機能"
    },
    {
      "indent": 3,
      "text": "TLS clients conforming to this specification MUST be able to correctly interpret TLSA records with certificate usages 0, 1, 2, and 3. TLS clients conforming to this specification MUST be able to compare a certificate association with a certificate from the TLS handshake using selector types 0 and 1, and matching type 0 (no hash used) and matching type 1 (SHA-256), and SHOULD be able to make such comparisons with matching type 2 (SHA-512).",
      "ja": "この仕様に準拠したTLSクライアントは、正しく証明書使用0、1、2とTLSAレコードを解釈できなければならないし、この仕様に準拠3. TLSクライアントは、セレクタタイプを使用してTLSハンドシェイクから証明書と証明書の関連付けを比較することができなければなりません0と1とのマッチングタイプ0（使用しないハッシュ）と一致するタイプ1（SHA-256）、及びマッチングタイプ2（SHA-512）を用いてこのような比較を行うことができるべきです。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has made the assignments in this section.",
      "ja": "IANAは、このセクションの割り当てを行っています。"
    },
    {
      "indent": 3,
      "text": "In the following sections, \"RFC Required\" was chosen for TLSA certificate usages and \"Specification Required\" for selectors and matching types because of the amount of detail that is likely to be needed for implementers to correctly implement new certificate usages as compared to new selectors and matching types.",
      "ja": "次のセクションでは、「RFC必要」TLSA証明書使用とセレクタの「仕様が必要」とするため、新しいセレクタと比較して、正しく新しい証明書の使用を実装するための実装のために必要とされる可能性が高いディテールの量のマッチングタイプのために選択しましたそして、タイプに一致します。"
    },
    {
      "indent": 0,
      "text": "7.1. TLSA RRtype",
      "section_title": true,
      "ja": "7.1。 TLSA RRtype"
    },
    {
      "indent": 3,
      "text": "This document uses a new DNS RR type, TLSA, whose value (52) was allocated by IANA from the Resource Record (RR) TYPEs subregistry of the Domain Name System (DNS) Parameters registry.",
      "ja": "この文書では、その値（52）ドメインネームシステム（DNS）パラメータレジストリのリソースレコード（RR）タイプ副登録からIANAによって割り当てられた新しいDNS RRタイプ、TLSAを、使用しています。"
    },
    {
      "indent": 0,
      "text": "7.2. TLSA Certificate Usages",
      "section_title": true,
      "ja": "7.2。 TLSA証明書用途"
    },
    {
      "indent": 3,
      "text": "This document creates a new registry, \"TLSA Certificate Usages\". The registry policy is \"RFC Required\". The initial entries in the registry are:",
      "ja": "この文書は、新しいレジストリ、「TLSA証明書用途」を作成します。レジストリポリシーは、「RFC必要」です。レジストリ内の最初のエントリは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Value    Short description                       Reference\n----------------------------------------------------------\n0        CA constraint                           RFC 6698\n1        Service certificate constraint          RFC 6698\n2        Trust anchor assertion                  RFC 6698\n3        Domain-issued certificate               RFC 6698\n4-254    Unassigned\n255      Private use",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Applications to the registry can request specific values that have yet to be assigned.",
      "ja": "レジストリへの応用が割り当てられていた特定の値を要求することができます。"
    },
    {
      "indent": 0,
      "text": "7.3. TLSA Selectors",
      "section_title": true,
      "ja": "7.3。 TLSAセレクタ"
    },
    {
      "indent": 3,
      "text": "This document creates a new registry, \"TLSA Selectors\". The registry policy is \"Specification Required\". The initial entries in the registry are:",
      "ja": "この文書は、新しいレジストリ、「TLSAセレクタ」を作成します。レジストリポリシーは、「仕様が必要」です。レジストリ内の最初のエントリは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Value    Short description                       Reference\n----------------------------------------------------------\n0        Full certificate                        RFC 6698\n1        SubjectPublicKeyInfo                    RFC 6698\n2-254    Unassigned\n255      Private use",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Applications to the registry can request specific values that have yet to be assigned.",
      "ja": "レジストリへの応用が割り当てられていた特定の値を要求することができます。"
    },
    {
      "indent": 0,
      "text": "7.4. TLSA Matching Types",
      "section_title": true,
      "ja": "7.4。 TLSAマッチングタイプ"
    },
    {
      "indent": 3,
      "text": "This document creates a new registry, \"TLSA Matching Types\". The registry policy is \"Specification Required\". The initial entries in the registry are:",
      "ja": "この文書は、新しいレジストリ、「TLSAマッチングタイプ」を作成します。レジストリポリシーは、「仕様が必要」です。レジストリ内の最初のエントリは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Value    Short description                       Reference\n----------------------------------------------------------\n0        No hash used                            RFC 6698\n1        SHA-256                                 RFC 6234\n2        SHA-512                                 RFC 6234\n3-254    Unassigned\n255      Private use",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Applications to the registry can request specific values that have yet to be assigned.",
      "ja": "レジストリへの応用が割り当てられていた特定の値を要求することができます。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The security of the DNS RRtype described in this document relies on the security of DNSSEC to verify that the TLSA record has not been altered.",
      "ja": "DNS RRtypeのセキュリティは、このドキュメントで説明TLSAレコードが変更されていないことを確認するためにDNSSECのセキュリティに依存します。"
    },
    {
      "indent": 3,
      "text": "A rogue DNS administrator who changes the A, AAAA, and/or TLSA records for a domain name can cause the client to go to an unauthorized server that will appear authorized, unless the client performs PKIX certification path validation and rejects the certificate. That administrator could probably get a certificate issued by some CA anyway, so this is not an additional threat.",
      "ja": "ドメイン名のA、AAAA、および/またはTLSAレコードを変更する不正なDNSの管理者は、クライアントがPKIX証明書パス検証を実行し、証明書を拒否しない限り、クライアントは、許可されて表示されます不正なサーバーに移動することがあります。その管理者はおそらく、とにかく、いくつかのCAによって発行された証明書を得ることができるので、これは追加の脅威ではありません。"
    },
    {
      "indent": 3,
      "text": "If the authentication mechanism for adding or changing TLSA data in a zone is weaker than the authentication mechanism for changing the A and/or AAAA records, a man-in-the-middle who can redirect traffic to his site may be able to impersonate the attacked host in TLS if he can use the weaker authentication mechanism. A better design for authenticating DNS would be to have the same level of authentication used for all DNS additions and changes for a particular domain name.",
      "ja": "ゾーンでTLSAデータを追加または変更するための認証機構は、Aおよび/またはAAAAレコードを変更するための認証機構よりも弱い場合には、のman-in-the-middle自分のサイトにトラフィックをリダイレクトすることができなりすますことができるかもしれ彼は弱い認証メカニズムを使用することができるかどうかTLSでホストを攻撃しました。 DNSを認証するための優れたデザインは、特定のドメイン名のすべてのDNSの追加や変更に使用する認証の同じレベルを持っているだろう。"
    },
    {
      "indent": 3,
      "text": "Secure Socket Layer (SSL) proxies can sometimes act as a man-in-the-middle for TLS clients. In these scenarios, the clients add a new trust anchor whose private key is kept on the SSL proxy; the proxy intercepts TLS requests, creates a new TLS session with the intended host, and sets up a TLS session with the client using a certificate that chains to the trust anchor installed in the client by the proxy. In such environments, using TLSA records will prevent the SSL proxy from functioning as expected because the TLS client will get a certificate association from the DNS that will not match the certificate that the SSL proxy uses with the client. The client, seeing the proxy's new certificate for the supposed destination, will not set up a TLS session.",
      "ja": "セキュア・ソケット・レイヤー（SSL）プロキシは、時々のman-in-the-middle TLSクライアント用として機能することができます。これらのシナリオでは、クライアントは、その秘密鍵SSLプロキシに保たれている新しいトラストアンカーを追加します。プロキシは、TLS要求をインターセプト意図される宿主で新しいTLSセッションを作成し、トラストアンカーの鎖は、プロキシによって、クライアントにインストールされた証明書を使用してクライアントとのTLSセッションを設定します。 TLSクライアントがSSLプロキシがクライアントと使用している証明書と一致しませんDNSからの証明書アソシエーションを取得するので、このような環境では、TLSAレコードを使用すると、期待通りに機能し、SSLプロキシを防ぐことができます。クライアントは、想定さ先のプロキシの新しい証明書を見て、TLSセッションを設定しません。"
    },
    {
      "indent": 3,
      "text": "Client treatment of any information included in the trust anchor is a matter of local policy. This specification does not mandate that such information be inspected or validated by the server's domain name administrator.",
      "ja": "トラストアンカーに含まれるすべての情報のクライアントの治療は、ローカルポリシーの問題です。この仕様は、そのような情報を調べたり、サーバーのドメイン名の管理者によって検証されることを強制しません。"
    },
    {
      "indent": 3,
      "text": "If a server's certificate is revoked, or if an intermediate CA in a chain between the server and a trust anchor has its certificate revoked, a TLSA record with a certificate usage of 2 that matches the revoked certificate would in essence override the revocation because the client would treat that revoked certificate as a trust anchor and thus not check its revocation status. Because of this, domain administrators need to be responsible for being sure that the keys or certificates used in TLSA records with a certificate usage of 2 are in fact able to be used as reliable trust anchors.",
      "ja": "サーバーの証明書が失効した場合、またはサーバーおよびトラストアンカーの間にチェーン内の中間CAがその証明書が失効している場合、失効した証明書と一致2の証明書の利用とTLSAレコードは、本質的には、クライアントので失効をオーバーライドしますトラストアンカーとしてその取り消された証明書を扱うため、その失効状態をチェックしません。このため、ドメイン管理者は、2の証明書の利用をTLSAレコードで使用される鍵や証明書は、実際には信頼性の高い信頼アンカーとして使用されることが可能であることを確認しているの原因であることが必要です。"
    },
    {
      "indent": 3,
      "text": "Certificates that are delivered in TLSA with certificate usage 2 fundamentally change the way the TLS server's end entity certificate is evaluated. For example, the server's certificate might chain to an existing CA through an intermediate CA that has certain policy restrictions, and the certificate would not pass those restrictions and thus normally be rejected. That intermediate CA could issue itself a new certificate without the policy restrictions and tell its customers to use that certificate with certificate usage 2. This in essence allows an intermediate CA to become a trust anchor for certificates that the end user might have expected to chain to an existing trust anchor.",
      "ja": "証明書の利用2とTLSAで配信された証明書は、基本的にはTLSサーバのエンドエンティティ証明書が評価される方法を変更します。例えば、サーバの証明書のかもしれないが、特定のポリシーの制限を持っている中間CAによって既存のCAにチェーン、および証明書が拒否されるので、通常はそれらの制限を通過しないでしょう。その中間CA自体がポリシー制限のない新しい証明書を発行し、証明書の使用方法と、その証明書を使用するように顧客に伝えることができ2.本質的にこれは、中間CAは、エンドユーザーがにチェーンに期待している可能性があることを証明書のトラストアンカーになることができます既存のトラストアンカー。"
    },
    {
      "indent": 3,
      "text": "If an administrator wishes to stop using a TLSA record, the administrator can simply remove it from the DNS. Normal clients will stop using the TLSA record after the TTL has expired. Replay attacks against the TLSA record are not possible after the expiration date on the RRsig of the TLSA record that was removed.",
      "ja": "管理者はTLSAレコードの使用を停止したい場合は、管理者は単にDNSからそれを削除することができます。 TTLの期限が切れた後に、通常のクライアントがTLSAレコードを使用して停止します。 TLSAレコードに対するリプレイ攻撃を除去したTLSAレコードのRRSIGの有効期限後にできません。"
    },
    {
      "indent": 3,
      "text": "Generators of TLSA records should be aware that the client's full trust of a certificate association retrieved from a TLSA record may be a matter of local policy. While such trust is limited to the specific domain name, protocol, and port for which the TLSA query was made, local policy may decline to accept the certificate (for reasons such as weak cryptography), as is also the case with PKIX trust anchors.",
      "ja": "TLSAレコードのジェネレータはTLSAレコードから取得した証明書アソシエーションのクライアントの完全な信頼がローカルポリシーの問題であってもよいことに注意する必要があります。このような信頼がTLSAクエリが行われたため、特定のドメイン名、プロトコル、およびポートに限定されている間も、PKIXトラストアンカーと同様に、ローカルポリシーは、（例えば、弱い暗号化などの理由で）証明書を受け入れることを拒否してもよいです。"
    },
    {
      "indent": 0,
      "text": "8.1. Comparing DANE to Public CAs",
      "section_title": true,
      "ja": "8.1。パブリックCAにDANEを比較"
    },
    {
      "indent": 3,
      "text": "As stated above, the security of the DNS RRtype described in this document relies on the security of DNSSEC to verify that the TLSA record has not been altered. This section describes where the security of public CAs and the security of TLSA are similar and different. This section applies equally to other security-related DNS RRtypes such as keys for IPsec and SSH.",
      "ja": "上述したように、DNS RRtypeのセキュリティは、この文書で説明TLSAレコードが変更されていないことを確認するためにDNSSECのセキュリティに依存します。パブリックCAのセキュリティとTLSAのセキュリティが同様と異なる場合このセクションでは説明しています。このセクションでは、IPsecとSSHのためのキーとして他のセキュリティ関連のDNS RRtypesにも同様に適用されます。"
    },
    {
      "indent": 3,
      "text": "DNSSEC forms certificates (the binding of an identity to a key) by combining a DNSKEY, DS, or DLV resource record with an associated RRSIG record. These records then form a signing chain extending from the client's trust anchors to the RR of interest.",
      "ja": "DNSSECは、関連するRRSIGレコードとDNSKEY、DS、またはDLVリソースレコードを組み合わせることによって証明書を（キーに同一の結合）を形成します。これらの記録はその後、関心のRRに、クライアントのトラストアンカーから延びる署名チェーンを形成します。"
    },
    {
      "indent": 3,
      "text": "Although the DNSSEC protocol does not enforce it, DNSKEYs are often marked with a SEP flag indicating whether the key is a Zone Signing Key (ZSK) or a Key Signing Key (KSK). ZSKs protect records in the zone (including DS and DLV records), and KSKs protect ZSK DNSKEY records. This allows KSKs to be stored offline.",
      "ja": "DNSSECプロト​​コルは、それを強制しませんが、DNSKEYsは、多くの場合、キーがゾーンキー（ZSK）またはキー署名キー（KSK）の署名であるかどうかを示すSEPフラグでマークされています。 ZSKsは（DSとDLVレコードを含む）、ゾーン内のレコードを保護し、KSKsは、ZSKのDNSKEYレコードを保護します。これはKSKsはオフラインで保存することができます。"
    },
    {
      "indent": 3,
      "text": "The TLSA RRtype allows keys from the DNSSEC PKI hierarchy to authenticate keys wrapped in PKIX certificates for a particular host name, protocol, and port.",
      "ja": "TLSA RRtypeはDNSSEC PKI階層からキーが特定のホスト名、プロトコル、およびポートのためのPKIX証明書に包まれたキーを認証することができます。"
    },
    {
      "indent": 3,
      "text": "With the exception of the DLV RRtype, all of these certificates constrain the keys they identify to names that are within the zone signing the certificate. In order for a domain's DLV resource records to be honored, the domain must be configured as a DLV domain, and the domain's DNSKEYs must be configured as trust anchors or be authentic [RFC5074].",
      "ja": "DLV RRtypeを除いて、これらの証明書のすべてのは、彼らが証明書に署名するゾーン内にある名前に特定のキーを制約します。光栄するドメインのDLVリソースレコードためには、ドメインがDLVドメインとして構成する必要があり、ドメインのDNSKEYsは、トラストアンカーとして設定するか、本物の[RFC5074]であることが必要です。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Risk of Key Compromise",
      "section_title": true,
      "ja": "8.1.1。鍵の危殆のリスク"
    },
    {
      "indent": 3,
      "text": "The risk that a given certificate that has a valid signing chain is fake is related to the number of keys that can contribute to the validation of the certificate, the quality of protection each private key receives, the value of each key to an attacker, and the value of falsifying the certificate.",
      "ja": "有効な署名チェーンを持っている与えられた証明書が偽物であることのリスクは、各秘密鍵は、攻撃者に各キーの値を入力し、証明書の検証に貢献することができるキーの数、保護の品質に関連しています証明書を偽造の値。"
    },
    {
      "indent": 3,
      "text": "DNSSEC allows any set of domains to be configured as trust anchors and/or DLVs, but most clients are likely to use the root zone as their only trust anchor. Also, because a given DNSKEY can only sign resource records for that zone, the number of private keys capable of compromising a given TLSA resource record is limited to the number of zones between the TLSA resource record and the nearest trust anchor, plus any configured DLV domains. Typically, this will be six keys, half of which will be KSKs.",
      "ja": "DNSSECは、ドメインのいずれかのセットが信頼アンカーおよび/またはDLVsとして設定することができますが、ほとんどのクライアントは、彼らの唯一のトラストアンカーとしてルートゾーンを使用する可能性があります。与えられたDNSKEYのみ、そのゾーンのリソースレコードに署名することができますので、また、与えられたTLSAリソースレコードを損なうことのできる秘密鍵の数がTLSAリソースレコード、最寄りのトラストアンカー、加えて任意に構成DLV間のゾーンの数に制限されていますドメイン。一般的に、これはKSKsになります半分は6つのキーになります。"
    },
    {
      "indent": 3,
      "text": "PKIX only describes how to validate a certificate based on a client-chosen set of trust anchors, but says nothing about how many trust anchors to use or how they should be constrained. As currently deployed, most PKIX clients use a large number of trust anchors provided with the client or operating system software. These trust anchors are selected carefully, but with a desire for broad interoperability. The trust anchors and CA certificates for public CAs rarely have name constraints applied.",
      "ja": "PKIXは、信頼アンカーのクライアントに選択されたセットに基づいて証明書を検証する方法を説明しますが、それらに制約されなければならない方法を使用するアンカーまたはどのように多くの信頼については何も述べていないだけ。現在展開として、ほとんどのPKIXクライアントは、クライアントまたはオペレーティングシステムソフトウェアに付属しているトラストアンカーを多数使用しています。これらの信頼アンカーはなく、広範な相互運用性のための欲求と、慎重に選択されています。パブリックCAのトラストアンカーとCA証明書はほとんど名前制約が適用されていません。"
    },
    {
      "indent": 3,
      "text": "A combination of technical protections, process controls, and personnel experience contribute to the quality of security that keys receive.",
      "ja": "技術的保護、プロセス制御、および人事経験の組み合わせは、キーが受け取るセキュリティの品質に貢献しています。"
    },
    {
      "indent": 3,
      "text": "o The security surrounding DNSSEC DNSKEYs varies significantly. The KSK/ZSK split allows the KSK to be stored offline and protected more carefully than the ZSK, but not all domains do so. The security applied to a zone's DNSKEYs should be proportional to the value of the domain, but that is difficult to estimate. For example, the root DNSKEY has protections and controls comparable to or exceeding those of public CAs. On the other end of the spectrum, small domains might provide no more protection to their keys than they do to their other data.",
      "ja": "O DNSSEC DNSKEYsを取り巻くセキュリティが大幅に異なります。 KSK / ZSK分割はKSKはオフラインで保存され、ZSKよりも、より慎重に保護されることを可能にする、すべてではないドメインがそう。ゾーンのDNSKEYsに適用されるセキュリティは、ドメインの値に比例する必要がありますが、それは推定することは困難です。例えば、ルートDNSKEYは、と同等またはパブリックCAのものを超える保護およびコントロールを有します。スペクトルのもう一方の端には、小さなドメインは、彼らが他のデータに行うよりも、自分のキーに何もより多くの保護を提供しないかもしれません。"
    },
    {
      "indent": 3,
      "text": "o The security surrounding public CAs also varies. However, due to financial incentives and standards imposed by clients for acceptance into their trust anchor stores, CAs generally employ security experts and protect their keys carefully, though highly public compromises have occurred.",
      "ja": "OパブリックCA周囲のセキュリティも変化します。しかしながら、それらのトラストアンカーの店舗に受け入れのために、クライアントによって課される金銭的なインセンティブや基準に、CAは、一般的に、セキュリティの専門家を採用し、公共性の高い妥協が発生しているものの、慎重にその鍵を保護します。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Impact of Key Compromise",
      "section_title": true,
      "ja": "8.1.2。鍵の危殆の影響"
    },
    {
      "indent": 3,
      "text": "The impact of a key compromise differs significantly between the two models.",
      "ja": "キー妥協の影響は二つのモデル間で大きく異なります。"
    },
    {
      "indent": 3,
      "text": "o DNSKEYs are inherently limited in what they can sign, so a compromise of the DNSKEY for \"example.com\" provides no avenue of attack against \"example.org\". Even the impact of a compromise of .com's DNSKEY, while considerable, would be limited to .com domains. Only the compromise of the root DNSKEY would have the equivalent impact of an unconstrained public CA.",
      "ja": "O DNSKEYsは、本質的に、彼らが署名することができるものに限定されているので、「example.com」のためのDNSKEYの妥協は、「example.org」に対する攻撃のない道を提供していません。 .COMのDNSKEYの妥協のさえ影響は、かなりながら、ドメインを.COMに制限されるだろう。ルートDNSKEYの唯一の妥協案は、制約のないパブリックCAの同等の影響を与えるだろう"
    },
    {
      "indent": 3,
      "text": "o Public CAs are not typically constrained in what names they can sign, and therefore a compromise of even one CA allows the attacker to generate a certificate for any name in the DNS. A domain holder can get a certificate from any willing CA, or even multiple CAs simultaneously, making it impossible for a client to determine whether the certificate it is validating is legitimate or fraudulent.",
      "ja": "O公共のCAは、一般的に、彼らが署名することができるものの名​​前に拘束するため、一つでもCAの妥協点は、攻撃者がDNSに任意の名前の証明書を生成することができます。されていませんドメインの所有者は、それが不可能なクライアントは、それが検証している証明書が正当か不正であるかどうかを判断できるようにすること、同時にあらゆる喜んCA、あるいは複数のCAから証明書を取得することができます。"
    },
    {
      "indent": 3,
      "text": "Because a TLSA certificate association is constrained to its associated name, protocol, and port, the PKIX certificate is similarly constrained, even if its public CAs signing the certificate (if any) are not.",
      "ja": "TLSA証明書の関連付けは、その関連する名前、プロトコル、およびポートに拘束されているので、PKIX証明書が同様に証明書を（もしあれば）署名、パブリックCAがない場合でも、拘束されています。"
    },
    {
      "indent": 0,
      "text": "8.1.3. Detection of Key Compromise",
      "section_title": true,
      "ja": "8.1.3。鍵の危殆の検出"
    },
    {
      "indent": 3,
      "text": "If a key is compromised, rapid and reliable detection is important in order to limit the impact of the compromise. In this regard, neither model prevents an attacker from near-invisibly attacking their victim, provided that the necessary keys are compromised.",
      "ja": "キーが侵害された場合、迅速かつ信頼性の高い検出が妥協の影響を制限するために重要です。この点では、どちらのモデルは、近目に見えない彼らの犠牲者を攻撃から攻撃を防ぎ、必要なキーが危険にさらされていることを提供します。"
    },
    {
      "indent": 3,
      "text": "If a public CA is compromised, only the victim will see the fraudulent certificate, as there is typically no publicly accessible directory of all the certificates issued by a CA that can be inspected. DNS resource records are typically published publicly. However, the attacker could also allow the uncompromised records to be published to the Internet as usual but provide a compromised DNS view to the victim to achieve the same effect.",
      "ja": "パブリックCAが侵害された場合、一般的に検査することができるCAによって発行されたすべての証明書のない公的にアクセス可能なディレクトリが存在しないとして、唯一の被害者は、不正証明書が表示されます。 DNSリソースレコードは、一般的に公に公開されています。しかし、攻撃者は、妥協のない記録がいつものようにインターネットに公開することを可能にするが、同じ効果を達成するために、被害者に妥協DNSのビューを提供することができます。"
    },
    {
      "indent": 0,
      "text": "8.1.4. Spoofing Hostnames",
      "section_title": true,
      "ja": "8.1.4。なりすましのホスト名"
    },
    {
      "indent": 3,
      "text": "Some CAs implement technical controls to ensure that certificates are not issued to domains with names similar to domains that are popular and prone to attack. Of course, an attacker can attempt to circumvent this restriction by finding a CA willing to issue the certificate anyway. However, by using DNSSEC and TLSA, the attacker can circumvent this check completely.",
      "ja": "一部のCAは、証明書は人気があり、攻撃の傾向があるドメインに類似した名前を持つドメインに発行されていないことを確認するために、技術的なコントロールを実装します。もちろん、攻撃者は、とにかく、証明書を発行するために喜んでCAを見つけることによって、この制限を回避しようとすることができます。しかし、DNSSECとTLSAを使用することにより、攻撃者は完全にこのチェックを回避することができます。"
    },
    {
      "indent": 0,
      "text": "8.2. DNS Caching",
      "section_title": true,
      "ja": "8.2。 DNSキャッシュ"
    },
    {
      "indent": 3,
      "text": "Implementations of this protocol rely heavily on the DNS, and are thus prone to security attacks based on the deliberate mis-association of TLSA records and DNS names. Implementations need to be cautious in assuming the continuing validity of an association between a TLSA record and a DNS name.",
      "ja": "このプロトコルの実装は、DNSに大きく依存している、とTLSAレコードとDNS名の故意の誤関連付けに基づいてこのようにセキュリティ攻撃を受けやすいです。実装はTLSAレコードとDNS名との関連性の継続的な妥当性を仮定して慎重にする必要があります。"
    },
    {
      "indent": 3,
      "text": "In particular, implementations SHOULD rely on their DNS resolver for confirmation of an association between a TLSA record and a DNS name, rather than caching the result of previous domain name lookups. Many platforms already can cache domain name lookups locally when appropriate, and they SHOULD be configured to do so. It is proper for these lookups to be cached, however, only when the TTL (Time To Live) information reported by the DNS makes it likely that the cached information will remain useful.",
      "ja": "具体的には、実装がかなり以前ドメイン名ルックアップの結果をキャッシュするよりも、TLSAレコードとDNS名との関連付けの確認のために彼らのDNSリゾルバに頼るべきです。適切な場合、多くのプラットフォームでは、すでにローカルドメイン名のルックアップをキャッシュすることができ、そして彼らがそうするように設定する必要があります。これらの検索がキャッシュされることはDNSによって報告されたTTL（生存時間）の情報が、それはおそらく、キャッシュされた情報が有用残ることになりときにのみ、しかし、適切です。"
    },
    {
      "indent": 3,
      "text": "If implementations cache the results of domain name lookups in order to achieve a performance improvement, they MUST observe the TTL information reported by DNS. Implementations that fail to follow this rule could be spoofed or have access denied when a previously accessed server's TLSA record changes, such as during a certificate rollover.",
      "ja": "実装は、性能向上を達成するために、ドメイン名ルックアップの結果をキャッシュする場合は、DNSによって報告されたTTL情報を守らなければなりません。このルールに従わない実装は詐称やアクセスなどの証明書のロールオーバー時など以前にアクセスし、サーバーのTLSAレコードの変更、拒否さを持っていることができます。"
    },
    {
      "indent": 0,
      "text": "8.3. External DNSSEC Validators",
      "section_title": true,
      "ja": "8.3。外部DNSSECバリ"
    },
    {
      "indent": 3,
      "text": "Due to a lack of DNSSEC support in the most commonly deployed stub resolvers today, some ISPs have begun checking DNSSEC in the recursive resolvers they provide to their customers, setting the Authentic Data (AD) flag as appropriate. DNSSEC-aware clients could use that data, ignoring the fact that the DNSSEC data has been validated externally. Because there is typically no authentication of the recursive resolver or integrity protection of the data and AD flag between the client and the recursive resolver, this can be trivially spoofed by an attacker.",
      "ja": "最も一般的に展開スタブリゾルバでのDNSSECサポートの欠如、今日まで、いくつかのISPは、必要に応じて本物のデータ（AD）フラグを設定し、彼らは彼らの顧客に提供し、再帰リゾルバにDNSSECをチェックし始めています。 DNSSEC対応クライアントは、DNSSECデータが外部に検証されたという事実を無視して、そのデータを使用することができます。クライアントと再帰リゾルバの間には、データの再帰リゾルバまたは完全性保護の認証とADフラグが一般的に存在しないので、これは自明の攻撃者によって偽装させることができます。"
    },
    {
      "indent": 3,
      "text": "However, even with secure communications between a host and the external validating resolver, there is a risk that the external validator could become compromised. Nothing prevents a compromised external DNSSEC validator from claiming that all the records it provides are secure, even if the data is falsified, unless the client checks the DNSSEC data itself (rendering the external validator unnecessary).",
      "ja": "しかし、ホストと外部の検証をリゾルバ間の安全な通信を、外部のバリデータが危険にさらされるようになる可能性が危険性があります。何も、クライアントがDNSSECデータ自体（不要な外部バリデータをレンダリング）をチェックしない限り、データは、改ざんされた場合でも、それが提供するすべてのレコードが固定されていることを主張しているから妥協外部DNSSECバリデータを防ぎません。"
    },
    {
      "indent": 3,
      "text": "For this reason, DNSSEC validation is best performed on-host, even when a secure path to an external validator is available.",
      "ja": "このため、DNSSECの検証は最高の外部バリデータへの安全なパスが利用可能な場合でも、上のホストを行っています。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgements",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "Many of the ideas in this document have been discussed over many years. More recently, the ideas have been discussed by the authors and others in a more focused fashion. In particular, some of the ideas and words here originated with Paul Vixie, Dan Kaminsky, Jeff Hodges, Phillip Hallam-Baker, Simon Josefsson, Warren Kumari, Adam Langley, Ben Laurie, Ilari Liusvaara, Ondrej Mikle, Scott Schmit, Ondrej Sury, Richard Barnes, Jim Schaad, Stephen Farrell, Suresh Krishnaswamy, Peter Palfrader, Pieter Lexis, Wouter Wijngaards, John Gilmore, and Murray Kucherawy.",
      "ja": "この文書のアイデアの多くは、長年にわたり議論されています。最近では、アイデアは、より焦点を絞った形で、著者らが議論されています。具体的には、アイデアや言葉のいくつかは、ここでポール・ヴィクシー、ダン・カミンスキー、ジェフ・ホッジス、フィリップハラム・ベイカー、サイモンJosefsson氏、ウォーレン・クマリ、アダム・ラングレー、ベン・ローリー、Ilari Liusvaara、オンドレイMikle、スコット・シュミット、オンドレイSuryが起源、リチャード・バーンズ、ジムSchaad、スティーブン・ファレル、スレシュKrishnaswamy、ピーターPalfraderさん、ピーターレクシス、はWouter Wijngaards、ジョン・ギルモア、そしてマレーKucherawy。"
    },
    {
      "indent": 3,
      "text": "This document has also been greatly helped by many active participants of the DANE Working Group.",
      "ja": "この文書はまた、大幅にDANEワーキンググループの多くの活発な参加によって助けられています。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain names - concepts and facilities\", STD 13, RFC 1034, November 1987.",
      "ja": "[RFC1034] Mockapetris、P.、 \"ドメイン名 - 概念と設備\"、STD 13、RFC 1034、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, November 1987.",
      "ja": "[RFC1035] Mockapetris、P.、 \"ドメイン名 - 実装及び仕様\"、STD 13、RFC 1035、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4033] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"DNS Security Introduction and Requirements\", RFC 4033, March 2005.",
      "ja": "[RFC4033]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 \"DNSセキュリティ序論と要件\"、RFC 4033、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4034] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"Resource Records for the DNS Security Extensions\", RFC 4034, March 2005.",
      "ja": "[RFC4034]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 \"DNSセキュリティ拡張機能のためのリソースレコード\"、RFC 4034、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4035] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"Protocol Modifications for the DNS Security Extensions\", RFC 4035, March 2005.",
      "ja": "[RFC4035]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 \"DNSセキュリティ拡張のためのプロトコル変更\"、RFC 4035、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, March 2011.",
      "ja": "[RFC6125]サンアンドレ、P.およびJ.ホッジス、「表現およびTransport Layer Security（TLS）の文脈でインターネット公開鍵インフラストラクチャの使用X.509内のドメインベースのアプリケーションサービスのアイデンティティの検証（PKIX）証明書」、 RFC 6125、2011年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, January 2012.",
      "ja": "[RFC6347]レスコラ、E.およびN. Modadugu、 \"データグラムトランスポート層セキュリティバージョン1.2\"、RFC 6347、2012年1月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC0952] Harrenstien, K., Stahl, M., and E. Feinler, \"DoD Internet host table specification\", RFC 952, October 1985.",
      "ja": "[RFC0952] Harrenstien、K.、スタール、M.、およびE. Feinler、 \"DoDのインターネットホストテーブル仕様\"、RFC 952、1985年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, February 2000.",
      "ja": "[RFC2782] Gulbrandsenの、A.、いるVixie、P.、およびL. Esibov、 \"サービスの場所を特定するためのDNS RR（DNSのSRV）\"、RFC 2782、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.",
      "ja": "[RFC2818]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2845] Vixie, P., Gudmundsson, O., Eastlake 3rd, D., and B. Wellington, \"Secret Key Transaction Authentication for DNS (TSIG)\", RFC 2845, May 2000.",
      "ja": "[RFC2845]いるVixie、P.、グドムンソン、O.、イーストレイク3日、D.、およびB.ウェリントン、 \"DNSのための秘密鍵トランザクション認証（TSIG）\"、RFC 2845、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2931] Eastlake 3rd, D., \"DNS Request and Transaction Signatures ( SIG(0)s)\", RFC 2931, September 2000.",
      "ja": "[RFC2931]イーストレイク3日、D.、 \"DNS要求とトランザクション署名（SIG（0）S）\"、RFC 2931、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4025] Richardson, M., \"A Method for Storing IPsec Keying Material in DNS\", RFC 4025, March 2005.",
      "ja": "[RFC4025]リチャードソン、M.、 \"DNSでの保管のIPsec鍵材料のための方法\"、RFC 4025、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4255] Schlyter, J. and W. Griffin, \"Using DNS to Securely Publish Secure Shell (SSH) Key Fingerprints\", RFC 4255, January 2006.",
      "ja": "[RFC4255] Schlyter、J.とW.グリフィン、2006年1月、RFC 4255 \"しっかりセキュアシェル（SSH）キーの指紋を公開するためにDNSを使用します\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4641] Kolkman, O. and R. Gieben, \"DNSSEC Operational Practices\", RFC 4641, September 2006.",
      "ja": "[RFC4641] Kolkman、O.とR. Gieben、 \"DNSSEC運用・プラクティス\"、RFC 4641、2006年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5074] Weiler, S., \"DNSSEC Lookaside Validation (DLV)\", RFC 5074, November 2007.",
      "ja": "[RFC5074]ワイラー、S.、 \"DNSSECルックアサイドバリデーション（DLV）\"、RFC 5074、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5890] Klensin, J., \"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework\", RFC 5890, August 2010.",
      "ja": "[RFC5890] Klensin、J.、 \"アプリケーション（IDNA）のための国際化ドメイン名：定義とドキュメントフレームワーク\"、RFC 5890、2010年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake 3rd, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, January 2011.",
      "ja": "[RFC6066]イーストレイク3日、D.、 \"トランスポート層セキュリティ（TLS）拡張機能：拡張定義\"、RFC 6066、2011年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6071] Frankel, S. and S. Krishnan, \"IP Security (IPsec) and Internet Key Exchange (IKE) Document Roadmap\", RFC 6071, February 2011.",
      "ja": "[RFC6071]フランケル、S.とS.クリシュナン、 \"IPセキュリティ（IPsec）やInternet Key Exchange（IKE）ドキュメントロードマップ\"、RFC 6071、2011年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, May 2011.",
      "ja": "[RFC6234]イーストレーク第3、D.とT.ハンセン、 \"米国のセキュアハッシュアルゴリズム（SHAとSHAベースのHMACとHKDF）\"、RFC 6234、2011年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC6376] Crocker, D., Ed., Hansen, T., Ed., and M. Kucherawy, Ed., \"DomainKeys Identified Mail (DKIM) Signatures\", RFC 6376, September 2011.",
      "ja": "[RFC6376]クロッカー、D.、編、ハンセン、T.編、及びM. Kucherawy、エド。、 \"ドメインキー・アイデンティファイド・メール（DKIM）署名\"、RFC 6376、2011年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC6394] Barnes, R., \"Use Cases and Requirements for DNS-Based Authentication of Named Entities (DANE)\", RFC 6394, October 2011.",
      "ja": "[RFC6394]バーンズ、R.、 \"ユースケースと名前付きエンティティのDNSベースの認証（DANE）の要件\"、RFC 6394、2011年10月。"
    },
    {
      "indent": 3,
      "text": "[X.690] \"Recommendation ITU-T X.690 (2002) | ISO/IEC 8825-1:2002, Information technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", July 2002.",
      "ja": "[X.690]「勧告ITU-T X.690（2002）| ISO / IEC 8825から1：2002、情報技術 -  ASN.1エンコーディング規則：基本符号化規則（BER）の仕様、Canonicalの符号化規則（CER） 、および顕著な符号化規則（DER）」、2002年7月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Operational Considerations for Deploying TLSA Records",
      "ja": "展開TLSAレコードの付録A.運用に関する注意事項"
    },
    {
      "indent": 0,
      "text": "A.1. Creating TLSA Records",
      "ja": "A.1。 TLSAレコードを作成します"
    },
    {
      "indent": 3,
      "text": "When creating TLSA records, care must be taken to avoid misconfigurations. Section 4 of this document states that a TLSA RRSet whose validation state is secure MUST be used. This means that the existence of such a RRSet effectively disables other forms of name and path validation. A misconfigured TLSA RRSet will effectively disable access to the TLS server for all conforming clients, and this document does not provide any means of making a gradual transition to using TLSA.",
      "ja": "TLSAレコードを作成する場合、注意が設定ミスを避けるようにしなければなりません。この文書のセクション4は、その検証状態安全であるTLSA資源レコード集合を使用しなければならないと述べています。これは、このような資源レコード集合の存在が効果的に名前とパス検証の他の形態を無効にすることを意味します。誤って設定TLSA資源レコード集合は、効果的にすべて準拠のクライアントに対してTLSサーバへのアクセスを無効にし、この文書はTLSAを使用するための段階的な移行を行うのいずれかの手段を提供していません。"
    },
    {
      "indent": 3,
      "text": "When creating TLSA records with certificate usage 0 (CA certificate) or usage 2 (trust anchor), one needs to understand the implications when choosing between selector type 0 (Full certificate) and 1 (SubjectPublicKeyInfo). A careful choice is required because different methods for building trust chains are used by different TLS clients. The following outlines the cases that one ought to be aware of and discusses the implications of the choice of selector type.",
      "ja": "証明書の使用0（CA証明書）または用法2（トラストアンカー）とTLSAレコードを作成する場合、一方はセレクタタイプ0（完全な証明書）および1（SubjectPublicKeyInfoで）との間に選択する場合の影響を理解する必要があります。信頼チェーンを構築するためのさまざまな方法が異なるTLSクライアントによって使用されているので、慎重な選択が必要です。以下は、1が知っておくべき例を概説し、セレクタの種類の選択の意味を説明します。"
    },
    {
      "indent": 3,
      "text": "Certificate usage 2 is not affected by the different types of chain building when the end entity certificate is the same as the trust anchor certificate.",
      "ja": "エンドエンティティ証明書が信頼アンカー証明書と同じであるとき、証明書の使用方法2は、チェーン建物の異なる種類に影響されません。"
    },
    {
      "indent": 0,
      "text": "A.1.1. Ambiguities and Corner Cases When TLS Clients Build Trust Chains",
      "ja": "A.1.1。曖昧さとコーナーケースTLSクライアントは、信頼チェーンを構築"
    },
    {
      "indent": 3,
      "text": "TLS clients can implement their own chain-building code rather than rely on the chain presented by the TLS server. This means that, except for the end entity certificate, any certificate presented in the suggested chain might or might not be present in the final chain built by the client.",
      "ja": "TLSクライアントは、独自のチェーン構築のコードを実装するのではなくTLSサーバから提示チェーンに依存することができます。これは、エンドエンティティ証明書を除き、提案チェーンに提示された証明書がまたはクライアントによって建てられ、最終的なチェーンに存在しないかもしれないかもしれない、ということを意味します。"
    },
    {
      "indent": 3,
      "text": "Certificates that the client can use to replace certificates from the original chain include:",
      "ja": "クライアントは、元のチェーンからの証明書を置き換えるために使用できる証明書が含まれます："
    },
    {
      "indent": 3,
      "text": "o Client's trust anchors",
      "ja": "oクライアントのトラストアンカー"
    },
    {
      "indent": 3,
      "text": "o Certificates cached locally",
      "ja": "O証明書は、ローカルにキャッシュされました"
    },
    {
      "indent": 3,
      "text": "o Certificates retrieved from a URI listed in an Authority Information Access X.509v3 extension",
      "ja": "機関情報アクセスのX.509v3拡張に記載されているURIから取得した証明書O"
    },
    {
      "indent": 3,
      "text": "CAs frequently reissue certificates with different validity periods, signature algorithms (such as a different hash algorithm in the signature algorithm), CA key pairs (such as for a cross-certificate), or PKIX extensions where the public key and subject remain the same. These reissued certificates are the certificates that the TLS client can use in place of an original certificate.",
      "ja": "CAは、しばしば、異なる有効期間（例えば、署名アルゴリズムに異なるハッシュアルゴリズムなど）署名アルゴリズム（例えばクロス証明書のような）CA鍵ペア、または公開鍵と対象が同じままPKIX拡張子を持つ証明書を再発行します。これらの再発行の証明書は、TLSクライアントは、元の証明書の代わりに使用することができる証明書です。"
    },
    {
      "indent": 3,
      "text": "Clients are known to exchange or remove certificates that could cause TLSA certificate associations that rely on the full certificate to fail. For example:",
      "ja": "クライアントは失敗する完全な証明書に依存しているTLSA証明書の関連付けを引き起こす可能性の証明書を交換したり、削除することが知られています。例えば："
    },
    {
      "indent": 3,
      "text": "o The client considers the signature algorithm of a certificate to no longer be sufficiently secure.",
      "ja": "Oクライアントは、証明書の署名アルゴリズムは、もはや十分に安全ではないと考えています。"
    },
    {
      "indent": 3,
      "text": "o The client might not have an associated root certificate in its trust store and instead uses a cross-certificate with an identical subject and public key.",
      "ja": "Oクライアントは、その信頼ストア内の関連するルート証明書を持って、その代わりに、同一のサブジェクトと公開鍵とのクロス証明書を使用しない場合があります。"
    },
    {
      "indent": 0,
      "text": "A.1.2. Choosing a Selector Type",
      "ja": "A.1.2。セレクタタイプの選択"
    },
    {
      "indent": 3,
      "text": "In this section, \"false-negative failure\" means that a client will not accept the TLSA certificate association for a certificate designated by the DNS administrator. Also, \"false-positive acceptance\" means that the client accepts a TLSA association for a certificate that is not designated by the DNS administrator.",
      "ja": "このセクションでは、「偽陰性障害は、」クライアントがDNS管理者が指定した証明書のTLSA証明書アソシエーションを受け入れないことを意味します。また、「偽陽性受け入れ」クライアントはDNS管理者が指定されていない証明書のTLSAの関連付けを受け入れることを意味します。"
    },
    {
      "indent": 0,
      "text": "A.1.2.1. Selector Type 0 (Full Certificate)",
      "ja": "A.1.2.1。セレクタタイプ0（完全な証明書）"
    },
    {
      "indent": 3,
      "text": "The \"Full certificate\" selector provides the most precise specification of a TLSA certificate association, capturing all fields of the PKIX certificate. For a DNS administrator, the best course to avoid false-negative failures in the client when using this selector is:",
      "ja": "「完全な証明書」セレクタは、PKIX証明書のすべてのフィールドを捕捉、TLSA証明書関連の最も正確な仕様を提供します。 DNS管理者のために、このセレクタを使用している場合、クライアントでの偽陰性の失敗を回避する最善のコースは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. If a CA issued a replacement certificate, don't associate to CA certificates that have a signature algorithm with a hash that is considered weak by local policy.",
      "ja": "1. CAは、交換用の証明書を発行した場合は、ローカルポリシーによって弱いと考えられているハッシュと署名アルゴリズムを持つCA証明書に関連付けません。"
    },
    {
      "indent": 3,
      "text": "2. Determine how common client applications process the TLSA certificate association using a fresh client installation -- that is, with the local certificate cache empty.",
      "ja": "つまり、空のローカル証明書キャッシュで - 一般的なクライアントアプリケーションは、新鮮なクライアントのインストールを使用してTLSA証明書アソシエーションを処理する方法2.決定します。"
    },
    {
      "indent": 0,
      "text": "A.1.2.2. Selector Type 1 (SubjectPublicKeyInfo)",
      "ja": "A.1.2.2。セレクタタイプ1（SubjectPublicKeyInfoで）"
    },
    {
      "indent": 3,
      "text": "A SubjectPublicKeyInfo selector gives greater flexibility in avoiding some false-negative failures caused by trust-chain-building algorithms used in clients.",
      "ja": "SubjectPublicKeyInfoでセレクタは、クライアントで使用される信頼チェーン構築アルゴリズムによって引き起こされるいくつかの偽陰性の障害を回避する上でより大きな柔軟性を提供します。"
    },
    {
      "indent": 3,
      "text": "One specific use case ought to be noted: creating a TLSA certificate association to CA certificate I1 that directly signed end entity certificate S1 of the server. The case can be illustrated by the following graph:",
      "ja": "一つの特定のユースケースは、注目されるべきである：直接サーバのエンドエンティティ証明書S1に署名したCA証明書I1にTLSA証明書の関連付けを作成します。ケースは、以下のグラフによって示すことができます。"
    },
    {
      "indent": 3,
      "text": "        +----+                      +----+\n        | I1 |                      | I2 |\n        +----+                      +----+\n           |                           |\n           v                           v\n        +----+                      +----+\n        | S1 |                      | S1 |\n        +----+                      +----+\nCertificate chain sent by    A different validation path\nserver in TLS handshake      built by the TLS client",
      "raw": true
    },
    {
      "indent": 3,
      "text": "I2 is a reissued version of CA certificate I1 (that is, it has a different hash in its signature algorithm).",
      "ja": "I2は、CA証明書の再発行I1バージョン（すなわち、それは、その署名アルゴリズムに異なるハッシュを有する）です。"
    },
    {
      "indent": 3,
      "text": "In the above scenario, both certificates I1 and I2 that sign S1 need to have identical SubjectPublicKeyInfo fields because the key used to sign S1 is fixed. An association to SubjectPublicKeyInfo (selector type 1) will always succeed in such a case, but an association with a full certificate (selector type 0) might not work due to a false-negative failure.",
      "ja": "上記のシナリオでは、S1に署名両方の証明書I1及びI2は、S1に署名するために使用されるキーが固定されているため、同一のSubjectPublicKeyInfoでフィールドを有する必要があります。 SubjectPublicKeyInfoで（セレクタタイプ1）への関連は、常にこのような場合に成功しますが、完全な証明書（セレクタタイプ0）との関連付けが原因偽陰性故障に機能しない場合があります。"
    },
    {
      "indent": 3,
      "text": "The attack surface is a bit broader compared to the \"Full certificate\" selector: the DNS administrator might unintentionally specify an association that would lead to false-positive acceptance.",
      "ja": "攻撃面では、「完全な証明書」セレクタに比べて少し広いです：DNS管理者が意図せずに偽陽性の受け入れにつながるの関連付けを指定することができます。"
    },
    {
      "indent": 3,
      "text": "o The administrator must know or trust that the CA does not engage in bad practices, such as not sharing the key of I1 for unrelated CA certificates (which would lead to trust-chain redirection). If possible, the administrator ought to review all CA certificates that have the same SubjectPublicKeyInfo field.",
      "ja": "O管理者が知っているか、またはCAは、このような（信頼チェーンのリダイレクトにつながる）無関係なCA証明書のI1の鍵を共有していないとして、悪い慣行に従事していないことを信頼しなければなりません。可能な場合は、管理者が同じSubjectPublicKeyInfoでフィールドを持っているすべてのCA証明書を見直すべきです。"
    },
    {
      "indent": 3,
      "text": "o The administrator ought to understand whether some PKIX extension may adversely affect security of the association. If possible, administrators ought to review all CA certificates that share the SubjectPublicKeyInfo.",
      "ja": "O管理者は、いくつかのPKIX拡張に悪影響関連のセキュリティに影響を与える可能性があるかどうかを理解するべきです。可能な場合は、管理者がSubjectPublicKeyInfoでを共有するすべてのCA証明書を見直すべきです。"
    },
    {
      "indent": 3,
      "text": "o The administrator ought to understand that any CA could, in the future, issue a certificate that contains the same SubjectPublicKeyInfo. Therefore, new chains can crop up in the future without any warning.",
      "ja": "O管理者は、任意のCAが、将来的には、同じSubjectPublicKeyInfoでが含まれている証明書を発行することができることを理解するべきです。そのため、新しいチェーンは、警告なしに、将来的にアップ切り抜くことができます。"
    },
    {
      "indent": 3,
      "text": "Using the SubjectPublicKeyInfo selector for association with a certificate in a chain above I1 needs to be decided on a case-by-case basis: there are too many possibilities based on the issuing CA's practices. Unless the full implications of such an association are understood by the administrator, using selector type 0 is a better option from a security perspective.",
      "ja": "I1上記連鎖内の証明書との関連付けのためSubjectPublicKeyInfoでセレクタを使用してケースバイケースで決定する必要があります発行するCAのプラクティスに基づいて多すぎる可能性があります。このような関連付けの完全な意味は、管理者によって理解されない限り、セレクタタイプ0を使用して、セキュリティの観点からより良いオプションです。"
    },
    {
      "indent": 0,
      "text": "A.2. Provisioning TLSA Records in DNS",
      "ja": "A.2。 DNSでTLSAレコードのプロビジョニング"
    },
    {
      "indent": 0,
      "text": "A.2.1. Provisioning TLSA Records with Aliases",
      "ja": "A.2.1。別名を持つTLSAレコードのプロビジョニング"
    },
    {
      "indent": 3,
      "text": "The TLSA resource record is not special in the DNS; it acts exactly like any other RRtype where the queried name has one or more labels prefixed to the base name, such as the SRV RRtype [RFC2782]. This affects the way that the TLSA resource record is used when aliasing in the DNS.",
      "ja": "TLSAリソースレコードをDNSで特別なものではありません。それは正確に照会された名前は、SRV RRtypeとして基地名、[RFC2782]に接頭辞1以上の標識を有する任意の他のRRtypeのように作用します。これは、DNSにエイリアシングときTLSAリソースレコードが使用されている方法に影響します。"
    },
    {
      "indent": 3,
      "text": "Note that the IETF sometimes adds new types of aliasing in the DNS. If that happens in the future, those aliases might affect TLSA records, hopefully in a good way.",
      "ja": "IETFは時々DNSにエイリアシングの新しいタイプを追加することに注意してください。それが将来的に発生した場合、これらの別名は、うまくいけば良い方法では、TLSAレコードに影響を与える可能性があります。"
    },
    {
      "indent": 0,
      "text": "A.2.1.1. Provisioning TLSA Records with CNAME Records",
      "ja": "A.2.1.1。 CNAMEレコードでTLSAレコードのプロビジョニング"
    },
    {
      "indent": 3,
      "text": "Using CNAME to alias in DNS only aliases from the exact name given, not any zones below the given name. For example, assume that a zone file has only the following:",
      "ja": "指定された正確な名前からのみのエイリアスが指定された名前、以下のいずれかのゾーンは、DNSにエイリアスにCNAMEを使用していません。たとえば、ゾーンファイルだけを得ていることを前提としています。"
    },
    {
      "indent": 3,
      "text": "sub1.example.com. IN CNAME sub2.example.com.",
      "ja": "sub1.example.com。 CNAMEのsub2.example.com、IN。"
    },
    {
      "indent": 3,
      "text": "In this case, a request for the A record at \"bottom.sub1.example.com\" would not return any records because the CNAME given only aliases the name given. Assume, instead, the zone file has the following:",
      "ja": "CNAMEが唯一の指定された名前のエイリアス与えられたので、この場合は、「bottom.sub1.example.com」でレコードに対する要求は、すべてのレコードを返さないでしょう。想定、代わりに、ゾーンファイルには、以下があります。"
    },
    {
      "indent": 3,
      "text": "sub3.example.com. IN CNAME sub4.example.com. bottom.sub3.example.com. IN CNAME bottom.sub4.example.com.",
      "ja": "sub3.example.com。 CNAMEのsub4.example.com、IN。 bottom.sub3.example.com。 CNAME、IN bottom.sub4.example.com。"
    },
    {
      "indent": 3,
      "text": "In this case, a request for the A record at bottom.sub3.example.com would in fact return whatever value for the A record exists at bottom.sub4.example.com.",
      "ja": "この場合、bottom.sub3.example.comでレコードに対する要求は、実際にはAレコードの戻りどのような値がbottom.sub4.example.comに存在するでしょう。"
    },
    {
      "indent": 3,
      "text": "Application implementations and full-service resolvers request DNS records using libraries that automatically follow CNAME (and DNAME) aliasing. This allows hosts to put TLSA records in their own zones or to use CNAME to do redirection.",
      "ja": "アプリケーションの実装とフルサービスリゾルバは自動的にCNAME（およびDNAME）エイリアシングをたどるライブラリを使用してDNSレコードを要求します。これは、ホストが自分のゾーンにTLSAレコードを配置するか、リダイレクトを行うためにCNAMEを使用することができます。"
    },
    {
      "indent": 3,
      "text": "If the owner of the original domain wants a TLSA record for the same, they simply enter it under the defined prefix:",
      "ja": "元のドメインの所有者が同じためTLSAレコードを望んでいるならば、彼らは単に定義された接頭辞の下でそれを入力します。"
    },
    {
      "indent": 3,
      "text": "; No TLSA record in target domain ; sub5.example.com. IN CNAME sub6.example.com. _443._tcp.sub5.example.com. IN TLSA 1 1 1 308202c5308201ab... sub6.example.com. IN A 192.0.2.1 sub6.example.com. IN AAAA 2001:db8::1",
      "ja": ";ターゲットドメインでNO TLSAレコードません。 sub5.example.com。 CNAMEのsub6.example.com、IN。 _443._tcp.sub5.example.com。 TLSA IN 1 1 1 308202c5308201ab ... sub6.example.com。 192.0.2.1のsub6.example.com、IN。 AAAA 2001年：DB8 :: 1"
    },
    {
      "indent": 3,
      "text": "If the owner of the original domain wants to have the target domain host the TLSA record, the original domain uses a CNAME record:",
      "ja": "元のドメインの所有者が対象のドメインホストにTLSAレコードを持っているしたい場合は、元のドメインはCNAMEレコードを使用しています。"
    },
    {
      "indent": 3,
      "text": "; TLSA record for original domain has CNAME to target domain ; sub5.example.com. IN CNAME sub6.example.com. _443._tcp.sub5.example.com. IN CNAME _443._tcp.sub6.example.com. sub6.example.com. IN A 192.0.2.1 sub6.example.com. IN AAAA 2001:db8::1 _443._tcp.sub6.example.com. IN TLSA 1 1 1 536a570ac49d9ba4...",
      "ja": ";元のドメインのためのTLSAレコードは、ドメインを対象とするCNAMEを持っています。 sub5.example.com。 CNAMEのsub6.example.com、IN。 _443._tcp.sub5.example.com。 CNAME、IN _443._tcp.sub6.example.com。 sub6.example.com。 192.0.2.1のsub6.example.com、IN。 AAAA 2001年：DB8 :: 1 _443._tcp.sub6.example.com。 1 1 536a570ac49d9ba4 TLSA IN 1 ..."
    },
    {
      "indent": 3,
      "text": "Note that it is acceptable for both the original domain and the target domain to have TLSA records, but the two records are unrelated. Consider the following:",
      "ja": "独自ドメインとターゲットドメインの両方がTLSAレコードを持っているため、それが受け入れ可能であることに注意してください、しかし、2つのレコードは無関係です。次のことを考えてみます。"
    },
    {
      "indent": 3,
      "text": "; TLSA record in both the original and target domain ; sub5.example.com. IN CNAME sub6.example.com. _443._tcp.sub5.example.com. IN TLSA 1 1 1 308202c5308201ab... sub6.example.com. IN A 192.0.2.1 sub6.example.com. IN AAAA 2001:db8::1 _443._tcp.sub6.example.com. IN TLSA 1 1 1 ac49d9ba4570ac49...",
      "ja": ";オリジナルとターゲットドメインの両方でTLSAレコード。 sub5.example.com。 CNAMEのsub6.example.com、IN。 _443._tcp.sub5.example.com。 TLSA IN 1 1 1 308202c5308201ab ... sub6.example.com。 192.0.2.1のsub6.example.com、IN。 AAAA 2001年：DB8 :: 1 _443._tcp.sub6.example.com。 TLSA 1 1 1 ac49d9ba4570ac49、IN ..."
    },
    {
      "indent": 3,
      "text": "In this example, someone looking for the TLSA record for sub5.example.com would always get the record whose value starts with \"308202c5308201ab\"; the TLSA record whose value starts with \"ac49d9ba4570ac49\" would only be sought by someone who is looking for the TLSA record for sub6.example.com, and never for sub5.example.com. Note that deploying different certificates for multiple services located at a shared TLS listener often requires the use of TLS SNI (Server Name Indication) [RFC6066].",
      "ja": "この例では、誰かが常に値「308202c5308201ab」で始まるレコードを得るでしょうsub5.example.comためTLSAレコードを探しています。その値が「ac49d9ba4570ac49」で始まるTLSAレコードはsub6.example.comためTLSAレコードを探していない、と決してsub5.example.comためている人が求めていることになります。共有TLSリスナーにある複数のサービスのために異なる証明書を展開することは、多くの場合、TLS SNI（Serverの名前表示）[RFC6066]を使用する必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note that these methods use the normal method for DNS aliasing using CNAME: the DNS client requests the record type that they actually want.",
      "ja": "DNSクライアントは、彼らが実際にしたいレコードタイプを要求します。これらのメソッドは、CNAMEを使用してDNSエイリアスのための通常の方法を使用することに注意してください。"
    },
    {
      "indent": 0,
      "text": "A.2.1.2. Provisioning TLSA Records with DNAME Records",
      "ja": "A.2.1.2。 DNAMEレコードとTLSAレコードのプロビジョニング"
    },
    {
      "indent": 3,
      "text": "Using DNAME records allows a zone owner to alias an entire subtree of names below the name that has the DNAME. This allows the wholesale aliasing of prefixed records such as those used by TLSA, SRV, and so on without aliasing the name itself. However, because DNAME can only be used for subtrees of a base name, it is rarely used to alias individual hosts that might also be running TLS.",
      "ja": "DNAMEレコードを使用すると、ゾーンの所有者がDNAMEを持つ名の下に名前のサブツリー全体をエイリアスすることができます。これは、TLSA、SRVで使用されるものと接頭辞のレコード卸売エイリアシングを可能にする、というように名前自体をエイリアシングなし。 DNAMEのみベース名のサブツリーのために使用することができるので、しかし、それはめったにもTLSを実行している可能性があり、別名個々のホストに使用されていません。"
    },
    {
      "indent": 3,
      "text": "; TLSA record in target domain, visible in original domain via DNAME ; sub5.example.com. IN CNAME sub6.example.com. _tcp.sub5.example.com. IN DNAME _tcp.sub6.example.com. sub6.example.com. IN A 192.0.2.1 sub6.example.com. IN AAAA 2001:db8::1 _443._tcp.sub6.example.com. IN TLSA 1 1 1 536a570ac49d9ba4...",
      "ja": ";対象ドメインのTLSAレコード、DNAMEを介して元のドメインに見えます。 sub5.example.com。 CNAMEのsub6.example.com、IN。 _tcp.sub5.example.com。 DNAMEの_tcp.sub6.example.com、IN。 sub6.example.com。 192.0.2.1のsub6.example.com、IN。 AAAA 2001年：DB8 :: 1 _443._tcp.sub6.example.com。 1 1 536a570ac49d9ba4 TLSA IN 1 ..."
    },
    {
      "indent": 0,
      "text": "A.2.1.3. Provisioning TLSA Records with Wildcards",
      "ja": "A.2.1.3。ワイルドカードでTLSAレコードのプロビジョニング"
    },
    {
      "indent": 3,
      "text": "Wildcards are generally not terribly useful for RRtypes that require prefixing because one can only wildcard at a layer below the host name. For example, if one wants to have the same TLSA record for every TCP port for www.example.com, the result might be:",
      "ja": "1は、ホスト名のみ下の層にワイルドカードすることができますので、ワイルドカードは、一般的に前に置く必要がRRtypesためひどく有用ではありません。 1がwww.example.comのために、すべてのTCPポートに同じTLSAレコードを持っているしたい場合たとえば、結果は次のようになります。"
    },
    {
      "indent": 3,
      "text": "*._tcp.www.example.com. IN TLSA 1 1 1 5c1502a6549c423b...",
      "ja": "* ._ tcp.www.example.com。 TLSA 1 1 1 5c1502a6549c423b、IN ..."
    },
    {
      "indent": 3,
      "text": "This is possibly useful in some scenarios where the same service is offered on many ports or the same certificate and/or key is used for all services on a host. Note that the domain being searched for is not necessarily related to the domain name found in the certificate, so a certificate with a wildcard in it is not searched for using a wildcard in the search request.",
      "ja": "これは、同じサービスが多くのポートまたは同じ証明書で提供され、および/またはキーがホスト上のすべてのサービスのために使用されているいくつかのシナリオでは、おそらく便利です。ドメインは必ずしも証明書で見つかったドメイン名に関連していないために検索されているので、それにワイルドカードを持つ証明書が検索要求でワイルドカードを使用して検索されていないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "A.3. Securing the Last Hop",
      "ja": "A.3。最終ホップのセキュリティ保護"
    },
    {
      "indent": 3,
      "text": "As described in Section 4, an application processing TLSA records must know the DNSSEC validity of those records. There are many ways for the application to determine this securely, and this specification does not mandate any single method.",
      "ja": "第4節で述べたように、アプリケーション処理TLSAレコードは、それらのレコードのDNSSECの有効性を知っている必要があります。そこしっかりとこれを決定するためのアプリケーションのための多くの方法があり、この仕様は、任意の単一の方法を強制しません。"
    },
    {
      "indent": 3,
      "text": "Some common methods for an application to know the DNSSEC validity of TLSA records include:",
      "ja": "TLSAレコードのDNSSECの有効性を知っているアプリケーションのためのいくつかの一般的な方法は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The application can have its own DNS resolver and DNSSEC validation stack.",
      "ja": "Oアプリケーションは、独自のDNSリゾルバとDNSSEC検証スタックを持つことができます。"
    },
    {
      "indent": 3,
      "text": "o The application can communicate through a trusted channel (such as requests to the operating system under which the application is running) to a local DNS resolver that does DNSSEC validation.",
      "ja": "Oアプリケーションは、DNSSEC検証を行うローカルDNSリゾルバへ（例えば、アプリケーションが実行されているオペレーティング・システムへの要求のような）信頼できるチャネルを介して通信することができます。"
    },
    {
      "indent": 3,
      "text": "o The application can communicate through a secured channel (such as requests running over TLS, IPsec, TSIG, or SIG(0)) to a non-local DNS resolver that does DNSSEC validation.",
      "ja": "Oアプリケーションは、DNSSEC検証を行い、非ローカルDNSリゾルバに（例えば（0）TLS、IPsecの、TSIGまたはSIG上で実行されている要求されるように）セキュアなチャネルを介して通信することができます。"
    },
    {
      "indent": 3,
      "text": "o The application can communicate through a secured channel (such as requests running over TLS, IPsec, TSIG, or SIG(0)) to a non-local DNS resolver that does not do DNSSEC validation, but gets responses through a secured channel from a different DNS resolver that does DNSSEC validation.",
      "ja": "Oアプリケーションは、セキュアチャネルを介して通信することができる（例えば、TLS、IPsecの、TSIG上で動作要求として、またはSIG（0））DNSSEC検証を行うが、よりセキュアなチャネルを介して応答を取得しない非ローカルDNSリゾルバへDNSSEC検証を行う別のDNSリゾルバ。"
    },
    {
      "indent": 0,
      "text": "A.4. Handling Certificate Rollover",
      "ja": "A.4。証明書のロールオーバーの取り扱い"
    },
    {
      "indent": 3,
      "text": "Certificate rollover is handled in much the same way as for rolling DNSSEC zone signing keys using the pre-publish key rollover method [RFC4641]. Suppose example.com has a single TLSA record for a TLS service on TCP port 990:",
      "ja": "証明書のロールオーバーは、事前公開キーロールオーバー方式[RFC4641]を使用してDNSSECゾーン署名鍵を圧延するとほとんど同じ方法で処理されます。 example.comは、TCPポート990でTLSサービス用の単一TLSAレコードを持っていると仮定します。"
    },
    {
      "indent": 3,
      "text": "_990._tcp.example.com IN TLSA 1 1 1 1CFC98A706BCF3683015...",
      "ja": "_990._tcp.example.com 1 1 1CFC98A706BCF3683015 TLSA IN 1 ..."
    },
    {
      "indent": 3,
      "text": "To start the rollover process, obtain or generate the new certificate or SubjectPublicKeyInfo to be used after the rollover and generate the new TLSA record. Add that record alongside the old one:",
      "ja": "、ロールオーバープロセスを開始し得るか、または新しい証明書またはSubjectPublicKeyInfoでは、ロールオーバー後に使用されるように生成し、新しいTLSAレコードを生成するには。古いものと一緒に、そのレコードを追加します。"
    },
    {
      "indent": 3,
      "text": "_990._tcp.example.com IN TLSA 1 1 1 1CFC98A706BCF3683015... _990._tcp.example.com IN TLSA 1 1 1 62D5414CD1CC657E3D30...",
      "ja": "_990._tcp.example.com TLSA件1 1 1CFC98A706BCF3683015 ... _990._tcp.example.com 1 1 62D5414CD1CC657E3D30 TLSA IN 1 ..."
    },
    {
      "indent": 3,
      "text": "After the new records have propagated to the authoritative nameservers and the TTL of the old record has expired, switch to the new certificate on the TLS server. Once this has occurred, the old TLSA record can be removed:",
      "ja": "新しいレコードの後TLSサーバー上の新しい証明書に切り替えて、権限ネームサーバに伝播していると、古いレコードのTTLの有効期限が切れています。これが発生すると、古いTLSAレコードを削除することができます。"
    },
    {
      "indent": 3,
      "text": "_990._tcp.example.com IN TLSA 1 1 1 62D5414CD1CC657E3D30...",
      "ja": "_990._tcp.example.com 1 1 62D5414CD1CC657E3D30 TLSA IN 1 ..."
    },
    {
      "indent": 3,
      "text": "This completes the certificate rollover.",
      "ja": "これは、証明書のロールオーバーを完了します。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Pseudocode for Using TLSA",
      "ja": "TLSAを使用するための付録B擬似コード"
    },
    {
      "indent": 3,
      "text": "This appendix describes, in pseudocode format, the interactions given earlier in this specification. If the steps below disagree with the text earlier in the document, the steps earlier in the document ought to be considered correct and this text incorrect.",
      "ja": "この付録では、擬似コード形式で、本明細書において先に与えられた相互作用を記述する。以下の手順は、以前の文書内のテキストと一致しない場合は、以前の文書の手順は正しいと、このテキストが正しくないとみなされるべきです。"
    },
    {
      "indent": 3,
      "text": "Note that this pseudocode is more strict than the normative text. For instance, it forces an order on the evaluation of criteria, which is not mandatory from the normative text.",
      "ja": "この擬似コードは、規範的なテキストよりも厳格であることに注意してください。例えば、それは規範的なテキストから必須ではありません基準の評価、上の順序を強制します。"
    },
    {
      "indent": 0,
      "text": "B.1. Helper Functions",
      "ja": "B.1。ヘルパー関数"
    },
    {
      "indent": 3,
      "text": "// implement the function for exiting function Finish (F) = { if (F == ABORT_TLS) { abort the TLS handshake or prevent TLS from starting exit }",
      "ja": "// {} TLSハンドシェイクを中断または終了を開始からTLSを防ぐ= {（F == ABORT_TLS）場合、関数の完了（F）を出射するための機能を実装"
    },
    {
      "indent": 5,
      "text": "if (F == NO_TLSA) { fall back to non-TLSA certificate validation exit }",
      "ja": "（F == NO_TLSA）は{非TLSA証明書検証出口にフォールバック}場合"
    },
    {
      "indent": 5,
      "text": "if (F == ACCEPT) { accept the TLS connection exit }",
      "ja": "（F ==がACCEPT）場合{TLS接続出口を受け入れます}"
    },
    {
      "indent": 3,
      "text": " // unreachable }",
      "ja": "} //到達不能"
    },
    {
      "indent": 3,
      "text": "// implement the selector function function Select (S, X) = { // Full certificate if (S == 0) { return X in DER encoding }",
      "ja": "DER符号化における（S == 0）{戻りX}場合//（S、X）を選択= {//完全な証明書セレクタ機能機能を実装"
    },
    {
      "indent": 5,
      "text": "// SubjectPublicKeyInfo if (S == 1) { return X.SubjectPublicKeyInfo in DER encoding }",
      "ja": "// SubjectPublicKeyInfoであれば（S == 1）{DERエンコーディングでX.SubjectPublicKeyInfoを返します}"
    },
    {
      "indent": 3,
      "text": " // unreachable }",
      "ja": "} //到達不能"
    },
    {
      "indent": 3,
      "text": "// implement the matching function function Match (M, X, Y) { // Exact match on selected content if (M == 0) { return (X == Y) }",
      "ja": "//マッチング関数関数マッチ（M、X、Y）を実装{//選択されたコンテンツに完全一致する場合（M == 0）{リターン（X == Y）}"
    },
    {
      "indent": 5,
      "text": "// SHA-256 hash of selected content if (M == 1) { return (SHA-256(X) == Y) }",
      "ja": "選択されたコンテンツの// SHA-256ハッシュIF（M == 1）{リターン（SHA-256（X）== Y）}"
    },
    {
      "indent": 5,
      "text": "// SHA-512 hash of selected content if (M == 2) { return (SHA-512(X) == Y) }",
      "ja": "選択されたコンテンツの// SHA-512ハッシュIF（M == 2）{リターン（SHA-512（X）== Y）}"
    },
    {
      "indent": 3,
      "text": " // unreachable }",
      "ja": "} //到達不能"
    },
    {
      "indent": 0,
      "text": "B.2. Main TLSA Pseudocode",
      "ja": "B.2。メインTLSA擬似コード"
    },
    {
      "indent": 3,
      "text": "TLS connect using [transport] to [name] on [port] and receiving end entity cert C for the TLS server:",
      "ja": "TLSは、[ポート]の[名前]に[トランスポート]を使用して接続し、TLSサーバのエンドエンティティ証明書Cを受信します。"
    },
    {
      "indent": 3,
      "text": "(TLSArecords, ValState) = DNSSECValidatedLookup( domainname=_[port]._[transport].[name], RRtype=TLSA)",
      "ja": "（TLSArecords、ValState）= DNSSECValidatedLookup（ドメイン名= _ [ポート] ._ [搬送]。[名前]、RRtype = TLSA）"
    },
    {
      "indent": 3,
      "text": "// check for states that would change processing if (ValState == BOGUS) { Finish(ABORT_TLS) } if ((ValState == INDETERMINATE) or (ValState == INSECURE)) { Finish(NO_TLSA) } // if here, ValState must be SECURE",
      "ja": "//処理を変更するであろう状態を確認する場合（ValState == BOGUS）{完了（ABORT_TLS）} IF（（ValState ==不定）または（ValState == INSECURE））{完了（NO_TLSA）} //ここであれば、ValState安全でなければなりません"
    },
    {
      "indent": 3,
      "text": "for each R in TLSArecords { // unusable records include unknown certUsage, unknown // selectorType, unknown matchingType, erroneous RDATA, and // prohibited by local policy if (R is unusable) { remove R from TLSArecords } } if (length(TLSArecords) == 0) { Finish(NO_TLSA) }",
      "ja": "TLSArecords（長さ（TLSArecords場合{（Rが使用不可能である）{TLSArecordsからR}を削除する場合、ローカルポリシーによって禁止//使用不可レコードが未知certUsageを含む、未知// selectorType、未知matchingType、誤っRDATAと//}中の各R用）== 0）{完了（NO_TLSA）}"
    },
    {
      "indent": 3,
      "text": "// A TLS client might have multiple trust anchors that it might use // when validating the TLS server's end entity (EE) certificate. // Also, there can be multiple PKIX certification paths for the // certificates given by the server in TLS. Thus, there are // possibly many chains that might need to be tested during // PKIX path validation.",
      "ja": "// A TLSクライアントは、複数の信頼がTLSサーバのエンドエンティティ（EE）証明書を検証するときに、//を使用する可能性のあるアンカーている可能性があります。 //また、TLSでサーバーによって与えられた//証明書のために複数のPKIX証明書パスが存在することができます。このように、// PKIXパス検証中にテストする必要があるかもしれません//おそらく多くのチェーンがあります。"
    },
    {
      "indent": 3,
      "text": "for each R in TLSArecords {",
      "ja": "TLSArecords {各R用"
    },
    {
      "indent": 5,
      "text": "// pass PKIX certificate validation and chain through a CA cert // that comes from TLSA if (R.certUsage == 0) { for each PKIX certification path H { if (C passes PKIX certification path validation in H) { for each D in H { if ((D is a CA certificate) and Match(R.matchingType, Select(R.selectorType, D), R.cert)) { Finish(ACCEPT) } } } } }",
      "ja": "// CAの証明書を介してPKIX証明書の検証とチェーンを通過//すなわちTLSAから来る場合は、各Dに対する各PKIX証明経路H {（CがHでPKIX証明書パスの検証に合格した場合）{用（R.certUsage == 0）{ Hにおける{IF（（Dは、CA証明書である）と一致（R.matchingType、セレクト（R.selectorType、D）、R.cert））{完了（ACCEPT）}}}}}"
    },
    {
      "indent": 5,
      "text": "// pass PKIX certificate validation and match EE cert from TLSA if (R.certUsage == 1) { for each PKIX certification path H { if ((C passes PKIX certificate validation in H) and Match(R.matchingType, Select(R.selectorType, C), R.cert)) { Finish(ACCEPT) } } }",
      "ja": "// TLSAからPKIX証明書の検証と一致EE証明書を渡す場合、各PKIX証明経路H {（（CがHでPKIX証明書の検証）と一致（R.matchingType、選択に合格した場合（R用（R.certUsage == 1）{ .selectorType、C）、R.cert））{完了（ACCEPT）}}}"
    },
    {
      "indent": 5,
      "text": "// pass PKIX certification validation using TLSA record as the // trust anchor if (R.certUsage == 2) { // the following assert() is merely a formalization of the // \"trust anchor\" condition for a certificate D matching R assert(Match(R.matchingType, Select(R.selectorType, D), R.cert)) for each PKIX certification path H that has certificate D matching R as the trust anchor { if (C passes PKIX validation in H) { Finish(ACCEPT); } } }",
      "ja": "（R.certUsage == 2）{//次のアサート（）は単に証明書Dマッチングの//「トラストアンカー」条件の定式化である場合//トラストアンカーとしてTLSAレコードを使用して、PKIX証明書の検証に合格（CがHでPKIX検証を通過する）場合トラストアンカー{として証明書D整合Rを有する各PKIX証明経路HのためのRアサート（一致（R.matchingType、セレクト（R.selectorType、D）、R.cert））{仕上げ（ACCEPT）。 }}}"
    },
    {
      "indent": 5,
      "text": "// match the TLSA record and the TLS certificate if (R.certUsage == 3) { if Match(R.matchingType, Select(R.selectorType, C), R.cert) Finish(ACCEPT) } }",
      "ja": "// TLSAレコードとTLS証明書と一致する場合（R.certUsage == 3）{マッチ（R.matchingType、選択（R.selectorType、C）、R.cert）仕上げは、（ACCEPT）場合}}"
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "// if here, then none of the TLSA records ended in \"Finish(ACCEPT)\" // so abort TLS Finish(ABORT_TLS)",
      "ja": "ここであれば、//、その後、TLSAレコードのどれも「完了（ACCEPT）」//そう中止TLSフィニッシュ（ABORT_TLS）で終了していません"
    },
    {
      "indent": 0,
      "text": "Appendix C. Examples",
      "ja": "付録C.例"
    },
    {
      "indent": 3,
      "text": "The following are examples of self-signed certificates that have been generated with various selectors and matching types. They were generated with one piece of software, and validated by an individual using other tools.",
      "ja": "以下の様々なセレクタと一致するタイプで生成された自己署名証明書の一例です。彼らは1つのソフトウェアで生成され、他のツールを使用して、個々によって検証されました。"
    },
    {
      "indent": 3,
      "text": "S = Selector M = Matching Type",
      "ja": "S =セレクタM =マッチングタイプ"
    },
    {
      "indent": 3,
      "text": "S M Association Data 0 0 30820454308202BC020900AB58D24E77AD2AF6300D06092A86 4886F70D0101050500306C310B3009060355040613024E4C31163014 0603550408130D4E6F6F72642D486F6C6C616E643112301006035504 071309416D7374657264616D310C300A060355040A13034F53333123 30210603550403131A64616E652E6B6965762E70726163746963756D 2E6F73332E6E6C301E170D3132303131363136353730335A170D3232 303131333136353730335A306C310B3009060355040613024E4C3116 30140603550408130D4E6F6F72642D486F6C6C616E64311230100603 5504071309416D7374657264616D310C300A060355040A13034F5333 312330210603550403131A64616E652E6B6965762E70726163746963 756D2E6F73332E6E6C308201A2300D06092A864886F70D0101010500 0382018F003082018A0282018100E62C84A5AFE59F0A2A6B250DEE68 7AC8C5C604F57D26CEB2119140FFAC38C4B9CBBE8923082E7F81626B 6AD5DEA0C8771C74E3CAA7F613054AEFA3673E48FFE47B3F7AF987DE 281A68230B24B9DA1A98DCBE51195B60E42FD7517C328D983E26A827 C877AB914EE4C1BFDEAD48BD25BE5F2C473BA9C1CBBDDDA0C374D0D5",
      "ja": "S M協会のデータ0 0 30820454308202BC020900AB58D24E77AD2AF6300D06092A86 4886F70D0101050500306C310B3009060355040613024E4C31163014 0603550408130D4E6F6F72642D486F6C6C616E643112301006035504 071309416D7374657264616D310C300A060355040A13034F53333123 30210603550403131A64616E652E6B6965762E70726163746963756D 2E6F73332E6E6C301E170D3132303131363136353730335A170D3232 303131333136353730335A306C310B3009060355040613024E4C3116 30140603550408130D4E6F6F72642D486F6C6C616E64311230100603 5504071309416D7374657264616D310C300A060355040A13034F5333 312330210603550403131A64616E652E6B6965762E70726163746963 756D2E6F73332E6E6C308201A2300D06092A864886F70D0101010500 0382018F003082018A0282018100E62C84A5AFE59F0A2A6B250DEE68 7AC8C5C604F57D26CEB2119140FFAC38C4B9CBBE8923082E7F81626B 6AD5DEA0C8771C74E3CAA7F613054AEFA3673E48FFE47B3F7AF987DE 281A68230B24B9DA1A98DCBE51195B60E42FD7517C328D983E26A827 C877AB914EE4C1BFDEAD48BD25BE5F2C473BA9C1CBBDDDA0C374D0D5"
    },
    {
      "indent": 7,
      "text": "8C389CC3D6D8C20662E19CF768F32441B7F7D14AEA8966CE7C32A172\n2AB38623D008029A9E4702883F8B977A1A1E5292BF8AD72239D40393\n37B86A3AC60FA001290452177BF1798609A05A130F033457A5212629\nFBDDB8E70E2A9E6556873C4F7CA46AE4A8B178F05FB319005E1C1C7D\n4BD77DFA34035563C126AA2C3328B900E7990AC9787F01DA82F74C3D\n4B6674CCECE1FD4C6EF9E6644F4635EDEDA39D8B0E2F7C8E06DAE775\n6213BD3D60831175BE290442B4AFC5AE6F46B769855A067C1097E617\n962529E166F22AEE10DDB981B8CD6FF17D3D70723169038DBFBC1A44\n9C8D0D31BC683C5F3CE26148E42EC9BBD4D9F261569B25B53C1D7FC2\nDDFF6B4CAC050203010001300D06092A864886F70D01010505000382\n0181002B2ABE063E9C86AC4A1F7835372091079C8276A9C2C5D1EC57\n64DE523FDDABDEAB3FD34E6FE6CBA054580A6785A663595D90132B93\nD473929E81FA0887D2FFF78A81C7D014B97778AB6AC9E5E690F6F5A9\nE92BB5FBAB71B857AE69B6E18BDCCB0BA6FCD9D4B084A34F3635148C\n495D48FE635903B888EC1DEB2610548EDD48D63F86513A4562469831\n48C0D5DB82D73A4C350A42BB661D763430FC6C8E5F9D13EA1B76AA52\nA4C358E5EA04000F794618303AB6CEEA4E9A8E9C74D73C1B0B7BAF16\nDEDE7696B5E2F206F777100F5727E1684D4132F5E692F47AF6756EA8\nB421000BE031B5D8F0220E436B51FB154FE9595333C13A2403F9DE08\nE5DDC5A22FD6182E339593E26374450220BC14F3E40FF33F084526B0\n9C34250702E8A352B332CCCB0F9DE2CF2B338823B92AFC61C0B6B8AB\nDB5AF718ED8DDA97C298E46B82A01B14814868CFA4F2C36268BFFF4A\n591F42658BF75918902D3E426DFE1D5FF0FC6A212071F6DA8BD833FE\n2E560D87775E8EE9333C05B6FB8EB56589D910DB5EA903",
      "raw": true
    },
    {
      "indent": 3,
      "text": "0 1 EFDDF0D915C7BDC5782C0881E1B2A95AD099FBDD06D7B1F779 82D9364338D955",
      "ja": "0 1 EFDDF0D915C7BDC5782C0881E1B2A95AD099FBDD06D7B1F779 82D9364338D955"
    },
    {
      "indent": 3,
      "text": "0 2 81EE7F6C0ECC6B09B7785A9418F54432DE630DD54DC6EE9E3C 49DE547708D236D4C413C3E97E44F969E635958AA410495844127C04 883503E5B024CF7A8F6A94",
      "ja": "0 2 81EE7F6C0ECC6B09B7785A9418F54432DE630DD54DC6EE9E3C 49DE547708D236D4C413C3E97E44F969E635958AA410495844127C04 883503E5B024CF7A8F6A94"
    },
    {
      "indent": 3,
      "text": "1 0 308201A2300D06092A864886F70D01010105000382018F0030 82018A0282018100E62C84A5AFE59F0A2A6B250DEE687AC8C5C604F5 7D26CEB2119140FFAC38C4B9CBBE8923082E7F81626B6AD5DEA0C877 1C74E3CAA7F613054AEFA3673E48FFE47B3F7AF987DE281A68230B24 B9DA1A98DCBE51195B60E42FD7517C328D983E26A827C877AB914EE4 C1BFDEAD48BD25BE5F2C473BA9C1CBBDDDA0C374D0D58C389CC3D6D8 C20662E19CF768F32441B7F7D14AEA8966CE7C32A1722AB38623D008 029A9E4702883F8B977A1A1E5292BF8AD72239D4039337B86A3AC60F A001290452177BF1798609A05A130F033457A5212629FBDDB8E70E2A 9E6556873C4F7CA46AE4A8B178F05FB319005E1C1C7D4BD77DFA3403 5563C126AA2C3328B900E7990AC9787F01DA82F74C3D4B6674CCECE1 FD4C6EF9E6644F4635EDEDA39D8B0E2F7C8E06DAE7756213BD3D6083 1175BE290442B4AFC5AE6F46B769855A067C1097E617962529E166F2 2AEE10DDB981B8CD6FF17D3D70723169038DBFBC1A449C8D0D31BC68 3C5F3CE26148E42EC9BBD4D9F261569B25B53C1D7FC2DDFF6B4CAC05 0203010001",
      "ja": "1 0 308201A2300D06092A864886F70D01010105000382018F0030 82018A0282018100E62C84A5AFE59F0A2A6B250DEE687AC8C5C604F5 7D26CEB2119140FFAC38C4B9CBBE8923082E7F81626B6AD5DEA0C877 1C74E3CAA7F613054AEFA3673E48FFE47B3F7AF987DE281A68230B24 B9DA1A98DCBE51195B60E42FD7517C328D983E26A827C877AB914EE4 C1BFDEAD48BD25BE5F2C473BA9C1CBBDDDA0C374D0D58C389CC3D6D8 C20662E19CF768F32441B7F7D14AEA8966CE7C32A1722AB38623D008 029A9E4702883F8B977A1A1E5292BF8AD72239D4039337B86A3AC60F A001290452177BF1798609A05A130F033457A5212629FBDDB8E70E2A 9E6556873C4F7CA46AE4A8B178F05FB319005E1C1C7D4BD77DFA3403 5563C126AA2C3328B900E7990AC9787F01DA82F74C3D4B6674CCECE1 FD4C6EF9E6644F4635EDEDA39D8B0E2F7C8E06DAE7756213BD3D6083 1175BE290442B4AFC5AE6F46B769855A067C1097E617962529E166F2 2AEE10DDB981B8CD6FF17D3D70723169038DBFBC1A449C8D0D31BC68 3C5F3CE26148E42EC9BBD4D9F261569B25B53C1D7FC2DDFF6B4CAC05 0203010001"
    },
    {
      "indent": 3,
      "text": "1 1 8755CDAA8FE24EF16CC0F2C918063185E433FAAF1415664911 D9E30A924138C4",
      "ja": "1 1 8755CDAA8FE24EF16CC0F2C918063185E433FAAF1415664911 D9E30A924138C4"
    },
    {
      "indent": 3,
      "text": "1 2 D43165B4CDF8F8660AECCCC5344D9D9AE45FFD7E6AAB7AB9EE C169B58E11F227ED90C17330CC17B5CCEF0390066008C720CEC6AAE5 33A934B3A2D7E232C94AB4",
      "ja": "1 2 D43165B4CDF8F8660AECCCC5344D9D9AE45FFD7E6AAB7AB9EE C169B58E11F227ED90C17330CC17B5CCEF0390066008C720CEC6AAE5 33A934B3A2D7E232C94AB4"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Paul Hoffman VPN Consortium",
      "ja": "ポール・ホフマンVPNコンソーシアム"
    },
    {
      "indent": 3,
      "text": "EMail: paul.hoffman@vpnc.org",
      "ja": "メールアドレス：paul.hoffman@vpnc.org"
    },
    {
      "indent": 3,
      "text": "Jakob Schlyter Kirei AB",
      "ja": "ヤコブSchlyterきれいAB"
    },
    {
      "indent": 3,
      "text": "EMail: jakob@kirei.se",
      "ja": "メールアドレス：jakob@kirei.se"
    }
  ]
}