{
  "title": {
    "text": "RFC 6693 - Probabilistic Routing Protocol for Intermittently Connected Networks",
    "ja": "RFC 6693 - 断続的に接続されたネットワークの確率ルーティングプロトコル"
  },
  "number": 6693,
  "created_at": "2019-10-29 06:46:22.220591+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                          A. Lindgren\nRequest for Comments: 6693                                          SICS\nCategory: Experimental                                          A. Doria\nISSN: 2070-1721                                           Technicalities\n                                                               E. Davies\n                                                        Folly Consulting\n                                                               S. Grasic\n                                          Lulea University of Technology\n                                                             August 2012",
      "raw": true
    },
    {
      "indent": 2,
      "text": "Probabilistic Routing Protocol for Intermittently Connected Networks",
      "ja": "断続的に接続されたネットワークの確率ルーティングプロトコル"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Delay Tolerant Networking Research Group and has been reviewed by that group. No objections to its publication as an RFC were raised.",
      "ja": "この文書では、遅延耐性ネットワーク研究グループの製品であり、そのグループによって検討されています。 RFCとしての公表に異議を提起しませんでした。"
    },
    {
      "indent": 3,
      "text": "This document defines PRoPHET, a Probabilistic Routing Protocol using History of Encounters and Transitivity. PRoPHET is a variant of the epidemic routing protocol for intermittently connected networks that operates by pruning the epidemic distribution tree to minimize resource usage while still attempting to achieve the best-case routing capabilities of epidemic routing. It is intended for use in sparse mesh networks where there is no guarantee that a fully connected path between the source and destination exists at any time, rendering traditional routing protocols unable to deliver messages between hosts. These networks are examples of networks where there is a disparity between the latency requirements of applications and the capabilities of the underlying network (networks often referred to as delay and disruption tolerant). The document presents an architectural overview followed by the protocol specification.",
      "ja": "この文書では、出会いと推移性の歴史を使用して預言者、確率ルーティングプロトコルを定義します。預言者は、依然として流行ルーティングのベストケースのルーティング機能を達成しようとしたときにリソースの使用を最小化するために流行分配ツリーを剪定することによって動作する間欠的接続されたネットワークのための流行ルーティングプロトコルの変形です。これは、送信元と宛先との間の完全に接続されたパスは、ホスト間でメッセージを配信することができない従来のルーティングプロトコルをレンダリングする、任意の時点で存在していることを保証はない疎メッシュネットワークで使用するために意図されています。これらのネットワークは、アプリケーションの待ち時間要件および基本的なネットワーク（ネットワークは、多くの場合、遅延および破壊耐性とも呼ばれる）の能力との間に不均衡が存在するネットワークの一例です。文書は、プロトコル仕様に続く建築概要を説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Delay Tolerant Networking Research Group of the Internet Research",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。この文書はインターネットResearch Task Force（IRTF）の製品です。 IRTFはインターネット関連の研究開発活動の成果を公表しています。これらの結果は、展開に適していない可能性があります。このRFCは、インターネットリサーチの遅延耐性ネットワーク研究グループのコンセンサスを表し"
    },
    {
      "indent": 3,
      "text": "Task Force (IRTF). Documents approved for publication by the IRSG are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "タスクフォース（IRTF）。 IRSGによって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6693.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6693で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2012 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Relation to the Delay-Tolerant Networking Architecture  .   7\n  1.2.  Applicability of the Protocol . . . . . . . . . . . . . .   8\n  1.3.  PRoPHET as Compared to Regular Routing Protocols  . . . .  10\n  1.4.  Requirements Notation . . . . . . . . . . . . . . . . . .  11\n2.  Architecture  . . . . . . . . . . . . . . . . . . . . . . . .  11\n  2.1.  PRoPHET . . . . . . . . . . . . . . . . . . . . . . . . .  11\n    2.1.1.  Characteristic Time Interval  . . . . . . . . . . . .  12\n    2.1.2.  Delivery Predictability Calculation . . . . . . . . .  12\n    2.1.3.  Optional Delivery Predictability Optimizations  . . .  17\n    2.1.4.  Forwarding Strategies and Queueing Policies . . . . .  18\n  2.2.  Bundle Protocol Agent to Routing Agent Interface  . . . .  19\n  2.3.  PRoPHET Zone Gateways . . . . . . . . . . . . . . . . . .  20\n  2.4.  Lower-Layer Requirements and Interface  . . . . . . . . .  21\n3.  Protocol Overview . . . . . . . . . . . . . . . . . . . . . .  22\n  3.1.  Neighbor Awareness  . . . . . . . . . . . . . . . . . . .  22\n  3.2.  Information Exchange Phase  . . . . . . . . . . . . . . .  23\n    3.2.1.  Routing Information Base Dictionary . . . . . . . . .  25\n    3.2.2.  Handling Multiple Simultaneous Contacts . . . . . . .  26\n  3.3.  Routing Algorithm . . . . . . . . . . . . . . . . . . . .  28\n  3.4.  Bundle Passing  . . . . . . . . . . . . . . . . . . . . .  32\n    3.4.1.  Custody . . . . . . . . . . . . . . . . . . . . . . .  33\n  3.5.  When a Bundle Reaches Its Destination . . . . . . . . . .  33\n  3.6.  Forwarding Strategies . . . . . . . . . . . . . . . . . .  34\n  3.7.  Queueing Policies . . . . . . . . . . . . . . . . . . . .  36\n4.  Message Formats . . . . . . . . . . . . . . . . . . . . . . .  38\n  4.1.  Header  . . . . . . . . . . . . . . . . . . . . . . . . .  39\n  4.2.  TLV Structure . . . . . . . . . . . . . . . . . . . . . .  44\n  4.3.  TLVs  . . . . . . . . . . . . . . . . . . . . . . . . . .  45\n    4.3.1.  Hello TLV . . . . . . . . . . . . . . . . . . . . . .  45\n    4.3.2.  Error TLV . . . . . . . . . . . . . . . . . . . . . .  47\n    4.3.3.  Routing Information Base Dictionary TLV . . . . . . .  48\n    4.3.4.  Routing Information Base TLV  . . . . . . . . . . . .  50\n    4.3.5.  Bundle Offer and Response TLVs (Version 2)  . . . . .  51\n5.  Detailed Operation  . . . . . . . . . . . . . . . . . . . . .  55\n  5.1.  High-Level State Tables . . . . . . . . . . . . . . . . .  56\n  5.2.  Hello Procedure . . . . . . . . . . . . . . . . . . . . .  59\n    5.2.1.  Hello Procedure State Tables  . . . . . . . . . . . .  61\n  5.3.  Information Exchange Phase  . . . . . . . . . . . . . . .  62\n    5.3.1.  State Definitions for the Initiator Role  . . . . . .  66\n    5.3.2.  State Definitions for the Listener Role . . . . . . .  71\n    5.3.3.  Recommendations for Information Exchange Timer\n            Periods . . . . . . . . . . . . . . . . . . . . . . .  77\n    5.3.4.  State Tables for Information Exchange . . . . . . . .  78\n  5.4.  Interaction with Nodes Using Version 1 of PRoPHET . . . .  92",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6.  Security Considerations . . . . . . . . . . . . . . . . . . .  93\n  6.1.  Attacks on the Operation of the Protocol  . . . . . . . .  94\n    6.1.1.  Black-Hole Attack . . . . . . . . . . . . . . . . . .  94\n    6.1.2.  Limited Black-Hole Attack / Identity Spoofing . . . .  95\n    6.1.3.  Fake PRoPHET ACKs . . . . . . . . . . . . . . . . . .  95\n    6.1.4.  Bundle Store Overflow . . . . . . . . . . . . . . . .  96\n    6.1.5.  Bundle Store Overflow with Delivery Predictability\n            Manipulation  . . . . . . . . . . . . . . . . . . . .  96\n  6.2.  Interactions with External Routing Domains  . . . . . . .  97\n7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  97\n  7.1.  DTN Routing Protocol Number . . . . . . . . . . . . . . .  98\n  7.2.  PRoPHET Protocol Version  . . . . . . . . . . . . . . . .  98\n  7.3.  PRoPHET Header Flags  . . . . . . . . . . . . . . . . . .  99\n  7.4.  PRoPHET Result Field  . . . . . . . . . . . . . . . . . .  99\n  7.5.  PRoPHET Codes for Success and Codes for Failure . . . . .  99\n  7.6.  PRoPHET TLV Type  . . . . . . . . . . . . . . . . . . . . 100\n  7.7.  Hello TLV Flags . . . . . . . . . . . . . . . . . . . . . 101\n  7.8.  Error TLV Flags . . . . . . . . . . . . . . . . . . . . . 101\n  7.9.  RIB Dictionary TLV Flags  . . . . . . . . . . . . . . . . 102\n  7.10. RIB TLV Flags . . . . . . . . . . . . . . . . . . . . . . 102\n  7.11. RIB Flags . . . . . . . . . . . . . . . . . . . . . . . . 103\n  7.12. Bundle Offer and Response TLV Flags . . . . . . . . . . . 103\n  7.13. Bundle Offer and Response B Flags . . . . . . . . . . . . 104\n8.  Implementation Experience . . . . . . . . . . . . . . . . . . 104\n9.  Deployment Experience . . . . . . . . . . . . . . . . . . . . 105\n10. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . 105\n11. References  . . . . . . . . . . . . . . . . . . . . . . . . . 105\n  11.1. Normative References  . . . . . . . . . . . . . . . . . . 105\n  11.2. Informative References  . . . . . . . . . . . . . . . . . 106\nAppendix A.  PRoPHET Example  . . . . . . . . . . . . . . . . . . 108\nAppendix B.  Neighbor Discovery Example . . . . . . . . . . . . . 110\nAppendix C.  PRoPHET Parameter Calculation Example  . . . . . . . 110",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The Probabilistic Routing Protocol using History of Encounters and Transitivity (PRoPHET) algorithm enables communication between participating nodes wishing to communicate in an intermittently connected network where at least some of the nodes are mobile.",
      "ja": "出会いの歴史と推移（預言者）アルゴリズムを使用して確率ルーティングプロトコルは、ノードの少なくともいくつかが移動され、断続的接続されたネットワークで通信することを望む参加ノード間の通信を可能にします。"
    },
    {
      "indent": 3,
      "text": "One of the most basic requirements for \"traditional\" (IP) networking is that there must exist a fully connected path between communication endpoints for the duration of a communication session in order for communication to be possible. There are, however, a number of scenarios where connectivity is intermittent so that this is not the case (thus rendering the end-to-end use of traditional networking protocols impossible), but where it still is desirable to allow communication between nodes.",
      "ja": "「伝統的な」（IP）ネットワークのための最も基本的な要件の1つは可能であるとの通信のためにために、通信セッションの間、通信エンドポイント間の完全に接続パスが存在しなければならないということです。しかしながら、依然としてノード間の通信を可能にすることが望ましい、これは（従って不可能従来のネットワークプロトコルのエンドツーエンドの使用をレンダリングする）場合ではないように接続が断続的であるシナリオの数が、。"
    },
    {
      "indent": 3,
      "text": "Consider a network of mobile nodes using wireless communication with a limited range that is less than the typical excursion distances over which the nodes travel. Communication between a pair of nodes at a particular instant is only possible when the distance between the nodes is less than the range of the wireless communication. This means that, even if messages are forwarded through other nodes acting as intermediate routes, there is no guarantee of finding a viable continuous path when it is needed to transmit a message.",
      "ja": "ノードが移動その上、典型的なエクスカーション距離未満である限られた範囲との無線通信を用いて移動ノードのネットワークを考えます。ノード間の距離が無線通信の範囲よりも小さい場合、特定の瞬間におけるノードの対の間の通信のみ可能です。これは、メッセージが、中間のルートとして機能する他のノードを介して転送されている場合でも、メッセージを送信するために必要な場合に実行可能な連続的な経路を見つけることの保証はない、ということを意味します。"
    },
    {
      "indent": 3,
      "text": "One way to enable communication in such scenarios is by allowing messages to be buffered at intermediate nodes for a longer time than normally occurs in the queues of conventional routers (cf. Delay-Tolerant Networking [RFC4838]). It would then be possible to exploit the mobility of a subset of the nodes to bring messages closer to their destination by transferring them to other nodes as they meet. Figure 1 shows how the mobility of nodes in such a scenario can be used to eventually deliver a message to its destination. In this figure, the four sub-figures (a) - (d) represent the physical positions of four nodes (A, B, C, and D) at four time instants, increasing from (a) to (d). The outline around each letter represents the range of the radio communication used for communication by the nodes: communication is only possible when the ranges overlap. At the start time, node A has a message -- indicated by an asterisk (*) next to that node -- to be delivered to node D, but there does not exist a path between nodes A and D because of the limited range of available wireless connections. As shown in sub-figures (a) - (d), the mobility of the nodes allows the message to first be transferred to node B, then to node C, and when finally node C moves within range of node D, it can deliver the message to its final destination. This technique is known as \"transitive networking\".",
      "ja": "そのようなシナリオで通信を可能にする一つの方法は、メッセージが正常に従来のルータのキュー（参照遅延耐性ネットワーク[RFC4838]）で発生するよりも長い時間のために中間ノードでバッファリングされることを可能にすることです。彼らが会うように、他のノードに転送することにより、近い目的地へのメッセージをもたらすために、ノードのサブセットのモビリティを活用することが可能であろう。図1は、このようなシナリオでは、ノードの移動度は、最終的にその宛先にメッセージを配信するために使用することができる方法を示しています。この図では、4つのサブ数値の（a） - （d）は（a）から（d）までの増加は、4つの時刻における4つのノード（A、B、C、およびD）の物理的な位置を表します。範囲が重複する場合の通信のみ可能である：各文字の周りの輪郭は、ノードが通信に使用される無線通信の範囲を表します。 Dノードに配信される、しかしための限られた範囲のノードAとDの間の経路が存在しない - アスタリスク（*）で示され、次のそのノードに - 開始時に、ノードAは、メッセージを有しています利用可能なワイヤレス接続を。サブ図に示すように、（A） - （d）は、ノードの移動度は、メッセージが最初にノードCに、ノードBに転送することができ、最終的にノードDの範囲Cが移動ノードと、それが提供することができその最終目的地へのメッセージ。この技術は「推移ネットワーキング」として知られています。"
    },
    {
      "indent": 3,
      "text": "Mobility and contact patterns in real application scenarios are likely to be non-random, but rather be predictable, based on the underlying activities of the higher-level application (this could, for example, stem from human mobility having regular traffic patterns based on repeating behavioral patterns (e.g., going to work or the market and returning home) and social interactions, or from any number of other node mobility situations where a proportion of nodes are mobile and move in ways that are not completely random over time but have a degree of predictability over time). This means that if a node has visited a location or been in contact with a certain node several times before, it is likely that it will visit that location or meet that node again.",
      "ja": "実際のアプリケーション・シナリオにおけるモビリティと接触パターンは、非ランダムである可能性が高いのではなく、より高いレベルのアプリケーションの基礎となる活動（これは、例えば、繰り返しに基づく定期的なトラフィックパターンを有するヒトモビリティから生じる可能性に基づいて、予測可能行動パターン（例えば、仕事に行くのか、市場や帰国）と社会的相互作用、またはノードの割合は、モバイルであり、時間をかけて完全にランダムではなく、学位を持っているかの方法で移動し、他のノードの移動状況の任意の数から時間の経過予測の）。これは、ノードが数回前に、特定のノードに接触した場所を訪れたりしていた場合、その場所を訪れたり、再びそのノードを満たす可能性があることを意味しています。"
    },
    {
      "indent": 3,
      "text": "PRoPHET can also be used in some networks where such mobility as described above does not take place. Predictable patterns in node contacts can also occur among static nodes where varying radio conditions or power-saving sleeping schedules cause connection between nodes to be intermittent.",
      "ja": "預言者はまた、このようなモビリティのように行われません上記のいくつかのネットワークで使用することができます。ノードコンタクトにおける予測可能なパターンも変化する無線条件や省電力睡眠スケジュールを断続的にするノード間の接続を引き起こす静的ノード間で発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "In previously discussed mechanisms to enable communication in intermittently connected networks, such as Epidemic Routing [vahdat_00], very general approaches have been taken to the problem at hand. In an environment where buffer space and bandwidth are infinite, epidemic routing will give an optimal solution to the problem of routing in an intermittently connected network with regard to message delivery ratio and latency. However, in most cases, neither bandwidth nor buffer space is infinite, but instead they are rather scarce resources, especially in the case of sensor networks.",
      "ja": "このような【vahdat_00]ルーティング流行として断続的に接続されたネットワーク内の通信を可能にする先に述べたメカニズムでは、非常に一般的なアプローチは、当面の問題に運ばれてきました。バッファ空間及び帯域幅が無限である環境では、流行のルーティングは、メッセージ配信率と待ち時間に関して間欠的に接続されたネットワークにおけるルーティングの問題に対する最適解を与えます。しかし、ほとんどの場合、どちらの帯域幅やバッファ容量は無限であるが、代わりに彼らは、特にセンサネットワークの場合には、かなり希少な資源です。"
    },
    {
      "indent": 3,
      "text": "PRoPHET is fundamentally an epidemic protocol with strict pruning. An epidemic protocol works by transferring its data to each and every node it meets. As data is passed from node to node, it is eventually passed to all nodes, including the target node. One of the advantages of an epidemic protocol is that by trying every path, it is guaranteed to try the best path. One of the disadvantages of an epidemic protocol is the extensive use of resources with every node needing to carry every packet and the associated transmission costs. PRoPHET's goal is to gain the advantages of an epidemic protocol without paying the price in storage and communication resources incurred by the basic epidemic protocol. That is, PRoPHET offers an alternative to basic epidemic routing, with lower demands on buffer space and bandwidth, with equal or better performance in cases where those resources are limited, and without loss of generality in scenarios where it is suitable to use PRoPHET.",
      "ja": "預言者は、基本的に、厳密な刈り込みと流行プロトコルです。流行プロトコルはそれぞれ、それが出会うすべてのノードにそのデータを転送することによって動作します。データがノードからノードへ渡されるように、最終的にターゲットノードを含む、すべてのノードに渡されます。流行プロトコルの利点の1つは、すべてのパスを試みることによって、最善のパスを試すことが保証されていることです。流行プロトコルの欠点の1つは、すべてのノードがすべてのパケットと関連する伝送コストを運ぶために必要と資源の広範な使用です。預言者の目標は、基本的な流行プロトコルによって被ったストレージと通信資源に価格を支払うことなく流行プロトコルの利点を得ることです。すなわち、預言者は、これらのリソースが限られている場合には同等またはより優れた性能と、緩衝空間と帯域幅に低い要求に、基本的な流行ルーティングの代替を提供し、預言者を使用することが適切であるシナリオにおける一般性を失うことなく、あります。"
    },
    {
      "indent": 3,
      "text": "In a situation where PRoPHET is applicable, the patterns are expected to have a characteristic time (such as the expected time between encounters between mobile stations) that is in turn related to the expected time that traffic will take to reach its destination in the part of the network that is using PRoPHET. This characteristic time provides guidance for configuration of the PRoPHET protocol in a network. When appropriately configured, the PRoPHET protocol effectively builds a local model of the expected patterns in the network that can be used to optimize the usage of resources by reducing the amount of traffic sent to nodes that are unlikely to lead to eventual delivery of the traffic to its destination.",
      "ja": "預言者が適用される状況では、パターンは、トラフィックがの一部にその宛先に到達するためにかかることが予想される時間に関連した順番である（例えば、移動局との間の遭遇の間に予想時間など）特性時間を有することが期待されます預言者を使用しているネットワーク。この特性時間は、ネットワーク内の預言者のプロトコルを設定するためのガイダンスを提供します。適切に構成されたときに、預言者のプロトコルを効果的にトラフィックの最終的な送達をもたらしそうにないノードに送信されるトラフィックの量を低減することにより、リソースの使用を最適化するために使用することができるネットワークの予想されるパターンの局所的なモデルを構築しますその先。"
    },
    {
      "indent": 5,
      "text": "+----------------------------+   +----------------------------+\n|                      ___   |   |                      ___   |\n|      ___            /   \\  |   |                     /   \\  |\n|     /   \\          (  D  ) |   |                    (  D  ) |\n|    (  B  )          \\___/  |   |     ___             \\___/  |\n|     \\___/    ___           |   |    /___\\    ___            |\n|___          /   \\          |   |   (/ B*\\)  /   \\           |\n|   \\        (  C  )         |   |   (\\_A_/) (  C  )          |\n| A* )        \\___/          |   |    \\___/   \\___/           |\n|___/                        |   |                            |\n+----------------------------+   +----------------------------+\n         (a) Time t                     (b) Time (t + dt)\n+----------------------------+   +----------------------------+\n|        _____         ___   |   |        ___           ___   |\n|       / / \\ \\       /   \\  |   |       /   \\         /___\\  |\n|      ( (B C* )     (  D  ) |   |      (  B  )       (/ D*\\) |\n|       \\_\\_/_/       \\___/  |   |       \\___/        (\\_C_/) |\n|     ___                    |   |     ___             \\___/  |\n|    /   \\                   |   |    /   \\                   |\n|   (  A  )                  |   |   (  A  )                  |\n|    \\___/                   |   |    \\___/                   |\n|                            |   |                            |\n+----------------------------+   +----------------------------+\n     (c) Time (t + 2*dt)               (d) Time (t + 3*dt)",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 1: Example of transitive communication",
      "ja": "図1：推移通信の例"
    },
    {
      "indent": 3,
      "text": "This document presents a framework for probabilistic routing in intermittently connected networks, using an assumption of non-random mobility of nodes to improve the delivery rate of messages while keeping buffer usage and communication overhead at a low level. First, a probabilistic metric called delivery predictability is defined. The document then goes on to define a probabilistic routing protocol using this metric.",
      "ja": "この文書では、低レベルでバッファ使用および通信オーバーヘッドを維持しながらメッセージの送達速度を改善するために、ノードの非ランダム可動性の仮定を使用して、断続的に接続されたネットワーク内の確率的ルーティングのための枠組みを提示します。まず、確率的メトリックと呼ばれる配信予測が定義されています。文書は、このメトリックを使用した確率的ルーティングプロトコルを定義するために行きます。"
    },
    {
      "indent": 0,
      "text": "1.1. Relation to the Delay-Tolerant Networking Architecture",
      "section_title": true,
      "ja": "1.1。遅延耐性ネットワークアーキテクチャとの関係"
    },
    {
      "indent": 3,
      "text": "The Delay-Tolerant Networking (DTN) architecture [RFC4838] defines an architecture for communication in environments where traditional communication protocols cannot be used due to excessive delays, link outages, and other extreme conditions. The intermittently connected networks considered here are a subset of those covered by the DTN architecture. The DTN architecture defines routes to be computed based on a collection of \"contacts\" indicating the start time, duration, endpoints, forwarding capacity, and latency of a link in the topology graph. These contacts may be deterministic or may be derived from estimates. The architecture defines some different types of intermittent contacts. The ones called \"opportunistic\" and \"predicted\" are the ones addressed by this protocol.",
      "ja": "遅延耐性ネットワーク（DTN）アーキテクチャ[RFC4838]は、伝統的な通信プロトコルは、過度の遅延、リンクの停止、及び他の極端な条件に使用することができない環境での通信のためのアーキテクチャを定義します。ここで考えて断続的に接続されたネットワークは、DTNアーキテクチャによってカバーされたもののサブセットです。 DTNアーキテクチャは、トポロジーグラフのリンクの、持続時間、エンドポイント、転送容量、レイテンシ、開始時刻を示す「連絡先」のコレクションに基づいて計算されるべきルートを定義します。これらの接点は、決定論的であってもよいし、見積りから誘導することができます。アーキテクチャは、断続的な連絡先のいくつかの異なったタイプを定義します。 「日和見」と呼ばれ、「予測」のものは、このプロトコルによって対処するものです。"
    },
    {
      "indent": 3,
      "text": "Opportunistic contacts are those that are not scheduled, but rather present themselves unexpectedly and frequently arise due to node mobility. Predicted contacts are like opportunistic contacts, but, based on some information, it might be possible to draw some statistical conclusion as to whether or not a contact will be present soon.",
      "ja": "日和見接点が予定されていないものであるが、むしろ予想外に自分自身を提示し、頻繁にノードの移動性のために発生します。連絡先はいくつかの情報に基づいて、日和見連絡先に似ていますが、予測され、接触がすぐに存在するか否かのいくつかの統計的な結論を引き出すことも可能かもしれません。"
    },
    {
      "indent": 3,
      "text": "The DTN architecture also introduces the bundle protocol [RFC5050], which provides a way for applications to \"bundle\" an entire session, including both data and metadata, into a single message, or bundle, that can be sent as a unit. The bundle protocol also provides end-to-end addressing and acknowledgments. PRoPHET is specifically intended to provide routing services in a network environment that uses bundles as its data transfer mechanism but could be also be used in other intermittent environments.",
      "ja": "DTNのアーキテクチャは、ユニットとして送信することができる単一のメッセージ、またはバンドルに、データおよびメタデータの両方を含むセッション全体を、「バンドル」するアプリケーションのための方法を提供するバンドルプロトコル[RFC5050]を導入します。バンドルプロトコルは、エンドツーエンドのアドレス指定および確認応答を提供します。預言者は、具体的には、そのデータ転送メカニズムとしてバンドルを使用するだけでなく、他の断続的環境で使用することができるネットワーク環境でのルーティングサービスを提供することを意図しています。"
    },
    {
      "indent": 0,
      "text": "1.2. Applicability of the Protocol",
      "section_title": true,
      "ja": "1.2。議定書の適用性"
    },
    {
      "indent": 3,
      "text": "The PRoPHET routing protocol is mainly targeted at situations where at least some of the nodes are mobile in a way that creates connectivity patterns that are not completely random over time but have a degree of predictability. Such connectivity patterns can also occur in networks where nodes switch off radios to preserve power. Human mobility patterns (often containing daily or weekly periodic activities) provide one such example where PRoPHET is expected to be applicable, but the applicability is not limited to scenarios including humans.",
      "ja": "預言者のルーティングプロトコルは、主ノードの少なくともいくつかは、時間の経過とともに完全にランダムではなく、予測度を有する接続パターンを作成するように移動している状況を対象としています。そのような接続パターンはまた、ノードは、電力を保存するために無線をオフネットワークで起こり得ます。 （しばしば毎日含むまたは毎週定期的活動）ヒト移動パターンは預言者が適用可能であると期待されているような一例を提供するが、適用は、ヒトを含むシナリオに限定されるものではありません。"
    },
    {
      "indent": 3,
      "text": "In order for PRoPHET to benefit from such predictability in the contact patterns between nodes, it is expected that the network exist under similar circumstances over a longer timescale (in terms of node encounters) so that the predictability can be accurately estimated.",
      "ja": "預言者はノード間の接点パターンにおけるそのような予測可能性から利益を得るためには、予測が正確に推定することができるように、ネットワークは、（ノード遭遇の点で）より長い時間スケールで同様の状況下で存在することが予想されます。"
    },
    {
      "indent": 3,
      "text": "The PRoPHET protocol expects nodes to be able to establish a local TCP link in order to exchange the information needed by the PRoPHET protocol. Protocol signaling is done out-of-band over this TCP link, without involving the bundle protocol agent [RFC5050]. However, the PRoPHET protocol is expected to interact with the bundle protocol agent to retrieve information about available bundles as well as to request that a bundle be sent to another node (it is expected that the associated bundle protocol agents are then able to establish a link (probably over the TCP convergence layer [CLAYER]) to perform this bundle transfer).",
      "ja": "預言者プロトコルは、ノードが預言者のプロトコルが必要とする情報を交換するために、ローカルのTCPリンクを確立できることを期待しています。プロトコルシグナリングは、バンドルプロトコルエージェント[RFC5050]を介さずに、このTCPリンクを介してアウト・オブ・バンドで行われます。しかし、預言者のプロトコルが使用可能なバンドルに関する情報を取得するだけでなく、バ​​ンドルは（関連バンドルプロトコルエージェントが、リンクを確立することができることが期待されている別のノードに送信することを要求するために、バンドルプロトコルエージェントと対話することが期待されます（おそらくTCP収束層[CLAYER]上）このバンドルの転送を実行します）。"
    },
    {
      "indent": 3,
      "text": "TCP provides a reliable bidirectional channel between two peers and guarantees in-order delivery of transmitted data. When using TCP, the guarantee of reliable, in-order delivery allows information exchanges of each category of information to be distributed across several messages without requiring the PRoPHET protocol layer to be concerned that all messages have been received before starting the exchange of the next category of information. At most, the last message of the category needs to be marked as such. This allows the receiver to process earlier messages while waiting for additional information and allows implementations to limit the size of messages so that IP fragmentation will be avoided and memory usage can be optimized if necessary. However, implementations MAY choose to build a single message for each category of information that is as large as necessary and rely on TCP to segment the message.",
      "ja": "TCPは、インオーダー送信データの配信つのピアとの間の信頼を保証双方向チャネルを提供します。 TCPを使用する場合、信頼性の保証は、順次配信は、情報の各カテゴリの情報交換は、すべてのメッセージは、次のカテゴリーの交換を開始する前に、受信されたことを心配するPROPHETプロトコル層を必要とせずにいくつかのメッセージに分散されることを可能にします情報の。せいぜい、カテゴリーの最後のメッセージは、そのようにマークする必要があります。これは、追加情報を待っている間に、受信機が以前のメッセージを処理することを可能にし、IP断片化が回避され、必要に応じてメモリ使用量を最適化することができるように実装がメッセージのサイズを制限することを可能にします。しかし、実装が必要なほど大きく、セグメントにTCP上でメッセージを依存している情報のカテゴリごとに単一のメッセージを構築するために選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "While PRoPHET is currently defined to run over TCP, in future versions the information exchange may take place over other transport protocols, and these may not provide message segmentation or reliable, in-order delivery. The simple message division used with TCP MUST NOT be used when the underlying transport does not offer reliable, in-order delivery, as it would be impossible to verify that all the messages had arrived. Hence, the capability is provided to segment protocol messages into submessages directly in the PRoPHET layer. Submessages are provided with sequence numbers, and this, together with a capability for positive acknowledgements, would allow PRoPHET to operate over an unreliable protocol such as UDP or potentially directly over IP.",
      "ja": "預言者は現在、TCP上で実行するために定義されるが、将来のバージョンでの情報交換は、他のトランスポートプロトコルを介して行われてもよいし、これらは、メッセージのセグメント化や信頼性、順序どおりの配信を提供することはできません。すべてのメッセージが到着したことを確認することは不可能なように、基礎となるトランスポートは、信頼性、順序どおりの配信を提供していない場合にTCPで使用される単純なメッセージ分割を使用してはいけません。したがって、機能は預言者層に直接サブメッセージにセグメントプロトコルメッセージに提供されます。サブメッセージは、シーケンス番号が設けられており、これは、一緒に肯定応答するための能力を、預言者はIP上に直接潜在UDPなどの信頼性の低いプロトコル上で動作またはすることを可能にします。"
    },
    {
      "indent": 3,
      "text": "Since TCP offers reliable delivery, it is RECOMMENDED that the positive acknowledgment capability is not used when PRoPHET is run over a TCP transport or similar protocol. When running over TCP, implementations MAY safely ignore positive acknowledgments.",
      "ja": "TCPは信頼性の高い配信を提供していますので、預言者はTCPトランスポートまたは同様のプロトコルを介して実行されたときに肯定応答機能が使用されていないことが推奨されます。 TCP上で実行している場合、実装は安全に肯定応答を無視するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Whatever transport protocol is used, PRoPHET expects to use a bidirectional link for the information exchange; this allows for the information exchange to take place in both directions over the same link avoiding the need to establish a second link for information exchange in the reverse direction.",
      "ja": "どのようなトランスポートプロトコルが使用され、預言者は、情報交換のための双方向リンクを使用することを期待します。これは逆方向に情報交換のための第2のリンクを確立する必要がなくなり、同じリンク上の両方の方向に場所を取るための情報交換が可能になります。"
    },
    {
      "indent": 3,
      "text": "In a large Delay- and Disruption-Tolerant Network (DTN), network conditions may vary widely, and in different parts of the network, different routing protocols may be appropriate. In this specification, we consider routing within a single \"PRoPHET zone\", which is a set of nodes among which messages are routed using PRoPHET. In many cases, a PRoPHET zone will not span the entire DTN, but there will be other parts of the network with other characteristics that run other routing protocols. To handle this, there may be nodes within the zone that act as gateways to other nodes that are the destinations for bundles generated within the zone or that insert bundles into the zone. Thus, PRoPHET is not necessarily used end-to-end, but only within regions of the network where its use is appropriate.",
      "ja": "大きな遅延 - 及び破壊トレラントネットワーク（DTN）において、ネットワーク条件が広範囲に変化し得る、ネットワークの異なる部分において、異なるルーティングプロトコルが適切であり得ます。この仕様では、メッセージは預言者を使用してルーティングされ、その中のノードの集合であるシングル「預言者ゾーン」内にルーティングすることを検討してください。多くの場合、預言者ゾーンは全体DTNにまたがるませんが、他のルーティングプロトコルを実行し、他の特性を持つネットワークの他の部分があるでしょう。これを処理するために、ゾーンまたはゾーンへのその挿入バンドル内で生成バンドルの宛先である他のノードへのゲートウェイとして機能ゾーン内のノードが存在してもよいです。このように、預言者は、必ずしもエンド・ツー・エンドが、唯一その使用は適切であるネットワークの領域内で使用されていません。"
    },
    {
      "indent": 0,
      "text": "1.3. PRoPHET as Compared to Regular Routing Protocols",
      "section_title": true,
      "ja": "1.3。通常のルーティングプロトコルに比べて、預言者"
    },
    {
      "indent": 3,
      "text": "While PRoPHET uses a mechanism for pruning the epidemic forwarding tree that is similar to the mechanism used in metric-based vector routing protocols (where the metric might be distance or cost), it should not be confused with a metric vector protocol.",
      "ja": "預言者（メトリックは距離またはコストかもしれない）メトリックベースのベクタールーティングプロトコルで使用される機構に類似している流行転送ツリーを剪定するためのメカニズムを使用するが、それは、計量​​ベクトルプロトコルと混同してはなりません。"
    },
    {
      "indent": 3,
      "text": "In a traditional metric-based vector routing protocol, the information passed from node to node is used to create a single non-looping path from source to destination that is optimal given the metric used. The path consists of a set of directed edges selected from the complete graph of communications links between the network nodes.",
      "ja": "伝統的なメトリックベースのベクトル・ルーティング・プロトコルでは、ノードからノードへ渡される情報は、使用されるメトリック所与最適である送信元から宛先への単一の非ループ経路を作成するために使用されます。パスは、ネットワークノード間の通信リンクの完全グラフから選択有向エッジのセットからなります。"
    },
    {
      "indent": 3,
      "text": "In PRoPHET, that information is used to prune the epidemic tree of paths by removing paths that look less likely to provide an effective route for delivery of data to its intended destination. One of the effects of this difference is that the regular notions of split horizon, as described in [RFC1058], do not apply to PRoPHET. The purpose of split horizon is to prevent a distance vector protocol from ever passing a packet back to the node that sent it the packet because it is well known that the source does not lie in that direction as determined when the directed path was computed.",
      "ja": "預言者に、その情報は、その意図された宛先へのデータの配信のための効果的な経路を提供しにくく見えるパスを除去することにより、パスの流行ツリーを剪定するために使用されます。この差の効果の一つは、水平分割の定期的な概念は、[RFC1058]で説明したように、預言者には適用されないということです。スプリットホライズンの目的は、これまで戻って、十分に有向パスが計算されたときに決定されるようにソースがその方向に存在しないことが知られているので、それにパケットを送信したノードへパケットを通過する距離ベクトルプロトコルを防止することです。"
    },
    {
      "indent": 3,
      "text": "In an epidemic protocol, where that previous system already has the data, the notion of passing the data back to the node is redundant: the protocol can readily determine that such a transfer is not required. Further, given the mobility and constant churn of encounters possible in a DTN that is dominated by opportunistic encounters, it is quite possible that, on a future encounter, the node might have become a better option for reaching the destination. Such a later encounter may require a re-transfer of the data if resource constraints have resulted in the data being deleted from the original carrier between the encounters.",
      "ja": "それ以前のシステムは、既にデータを有している流行プロトコルでは、バックノードにデータを渡すの概念は冗長である：プロトコルを容易にそのような転送は不要であると判断することができます。さらに、移動性および日和見出会いによって支配されてDTNで可能な出会いの一定の解約を与え、将来の出会いに、ノードが宛先に到達するためのより良い選択肢となったかもしれない、ということは十分に可能です。リソース制約が遭遇間の元のキャリアから削除されたデータが得られている場合、このような後の出会いは、データの再転送を必要とするかもしれません。"
    },
    {
      "indent": 3,
      "text": "The logic of metric routing protocols does not map directly onto the family of epidemic protocols. In particular, it is inappropriate to try to assess such protocols against the criteria used to assess conventional routing protocols such as the metric vector protocols; this is not to say that the family of epidemic protocols do not have weaknesses but they have to be considered independently of traditional protocols.",
      "ja": "メトリックルーティングプロトコルのロジックは、流行のプロトコルファミリに直接マップされません。特に、そのような計量ベクトルプロトコルのような従来のルーティングプロトコルを評価するために使用される基準に対してそのようなプロトコルを評価しようとすることは不適切です。これは流行プロトコルの家族が弱点を持っていないが、それらは独立して、伝統的なプロトコルの考慮しなければならないということではありません。"
    },
    {
      "indent": 0,
      "text": "1.4. Requirements Notation",
      "section_title": true,
      "ja": "1.4。要件表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Architecture",
      "section_title": true,
      "ja": "2.アーキテクチャ"
    },
    {
      "indent": 0,
      "text": "2.1. PRoPHET",
      "section_title": true,
      "ja": "2.1。予言者"
    },
    {
      "indent": 3,
      "text": "This section presents an overview of the main architecture of PRoPHET, a Probabilistic Routing Protocol using History of Encounters and Transitivity. The protocol leverages the observations made on the non-randomness of mobility patterns present in many application scenarios to improve routing performance. Instead of doing blind epidemic replication of bundles through the network as previous protocols have done, it applies \"probabilistic routing\".",
      "ja": "このセクションでは、預言者、出会いや推移の確率ルーティングプロトコル使用の歴史の主要なアーキテクチャの概要を説明します。プロトコルは、ルーティング性能を改善するために多くのアプリケーションシナリオに存在する移動パターンの非ランダムでなされた観察を活用します。代わりに、以前のプロトコルが行ったように、ネットワークを介してバンドルのブラインド流行の複製を行うので、それは「確率的ルーティング」を適用します。"
    },
    {
      "indent": 3,
      "text": "To accomplish this, a metric called \"delivery predictability\", 0 <= P_(A,B) <= 1, is established at every node A for each known destination B. This metric is calculated so that a node with a higher value for a certain destination is estimated to be a better candidate for delivering a bundle to that destination (i.e., if P_(A,B)>P_(C,B), bundles for destination B are preferable to forward to A rather than C). It is later used when making forwarding decisions. As routes in a DTN are likely to be asymmetric, the calculation of the delivery predictability reflects this, and P_(A,B) may be different from P_(B,A).",
      "ja": "これを達成するために、メトリックと呼ばれる「配信予測」、0 <= P_（A、B）<= 1は、このメトリックは、より高い値を有するノードように算出される各既知宛先Bの各ノードAに確立されています特定の宛先（すなわち、P_（A、B）> P_（C、B）場合、宛先BのバンドルではなくCに転送することが好適である）、その宛先へバンドルを送達するためのより良い候補であると推定されます。フォワーディング決定をするときに、後に使用されています。 DTNにおける経路が非対称である可能性が高いように、配信予測の計算はこれを反映し、P_（A、B）は、P_（B、A）と異なっていてもよいです。"
    },
    {
      "indent": 3,
      "text": "The delivery predictability values in each node evolve over time both as a result of decay of the metrics between encounters between nodes and due to changes resulting from encounters when metric information for the encountered node is updated to reflect the encounter and metric information about other nodes is exchanged.",
      "ja": "各ノードでの送達の予測値は、時間の経過と共に進化両方により遭遇ノードのメトリック情報は、他のノードに関する遭遇し、メトリック情報を反映するように更新されたときに遭遇起因する変化にノード間との遭遇の間のメトリックの崩壊の結果であります交換しました。"
    },
    {
      "indent": 3,
      "text": "When two PRoPHET nodes have a communication opportunity, they initially enter a two-part Information Exchange Phase (IEP). In the first part of the exchange, the delivery predictabilities for all destinations known by each node are shared with the encountered node. The exchanged information is used by each node to update the internal delivery predictability vector as described below. After that, the nodes exchange information (including destination and size) about the bundles each node carries, and the information is used in conjunction with the updated delivery predictabilities to decide which bundles to request to be forwarded from the other node based on the forwarding strategy used (as discussed in Section 2.1.4). The forwarding of bundles is carried out in the latter part of the Information Exchange Phase.",
      "ja": "2つの預言者ノードが通信機会を持っている場合、彼らは当初、二部情報交換フェーズ（IEP）を入力します。交換の最初の部分では、各ノードにより知られている全ての目的地のための送達予測精度が発生ノードと共有されています。交換される情報は、以下に説明するように内部送達の予測ベクトルを更新するために、各ノードによって使用されます。その後、ノードは、各ノードが搭載バンドル約（宛先及びサイズを含む）情報交換、情報を転送戦略に基づいて、他のノードから転送することを要求するバンドルかを決定するために、更新の配信予測精度と組み合わせて使用​​されています（セクション2.1.4で説明したように）を使用しました。バンドルの転送は、情報交換フェーズの後半に行われます。"
    },
    {
      "indent": 0,
      "text": "2.1.1. Characteristic Time Interval",
      "section_title": true,
      "ja": "2.1.1。特徴的な時間間隔"
    },
    {
      "indent": 3,
      "text": "When an application scenario makes PRoPHET applicable, the mobility pattern will exhibit a characteristic time interval that reflects the distribution of time intervals between encounters between nodes. The evolution of the delivery predictabilities, which reflects this mobility pattern, should reflect this same characteristic time interval. Accordingly, the parameters used in the equations that specify the evolution of delivery predictability (see Section 2.1.2) need to be configured appropriately so that the evolution reflects a model of the mobility pattern.",
      "ja": "アプリケーションシナリオは預言者を適用させる場合、移動パターンは、ノード間の出会いの時間間隔の分布を反映した特徴的な時間間隔を示すであろう。このモビリティパターンを反映した配信予測精度の進化は、これと同じ特性時間間隔を反映する必要があります。従って、配信予測（セクション2.1.2を参照）の進化を指定式で使用するパラメータは、進化モビリティパターンのモデルを反映するように適切に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.1.2. Delivery Predictability Calculation",
      "section_title": true,
      "ja": "2.1.2。配信予測可能性の計算"
    },
    {
      "indent": 3,
      "text": "As stated above, PRoPHET relies on calculating a metric based on the probability of encountering a certain node, and using that to support the decision of whether or not to forward a bundle to a certain node. This section describes the operations performed on the metrics stored in a node when it encounters another node and a communications opportunity arises. In the operations described by the equations that follow, the updates are being performed by node A, P_(A,B) is the delivery predictability value that node A will have stored for the destination B after the encounter, and P_(A,B)_old is the corresponding value that was stored before the encounter. If no delivery predictability value is stored for a particular destination B, P_(A,B) is considered to be zero.",
      "ja": "上述したように、預言者は、特定のノードに遭遇する確率に基づいてメトリックを計算し、特定のノードへのバンドルを転送するか否かの決定を支援するためにそれを使用に依存しています。このセクションでは、それが別のノードに遭遇し、通信機会が生じた場合、ノードに格納されたメトリックに動作を説明しています。追従式で説明した動作では、更新は、ノードAによって実行される、P_（A、B）が出会いの後に宛先Bのために保存されているであろうノードの送達の予測値であり、P_（A、B ）_oldは、遭遇する前に、格納された対応する値です。配達の予測値は、特定の宛先Bのために格納されていない場合、P_（A、B）はゼロであると考えられます。"
    },
    {
      "indent": 3,
      "text": "As a special case, the metric value for a node itself is always defined to be 1 (i.e., P_(A,A)=1).",
      "ja": "特殊なケースとして、ノード自体のメトリック値は常に1であると定義される（すなわち、P_（A、A）= 1）。"
    },
    {
      "indent": 3,
      "text": "The equations use a number of parameters that can be selected to match the characteristics of the mobility pattern in the PRoPHET zone where the node is located (see Section 2.1.1). Recommended settings for the various parameters are given in Section 3.3. The impact on the evolution of delivery predictabilities if encountering nodes have different parameter setting is discussed in Section 2.1.2.1.",
      "ja": "式は、ノードが配置されている預言者ゾーン内の移動度パターンの特性に合わせて選択することができる多数のパラメータを使用する（セクション2.1.1を参照）。各種パラメータの推奨設定は、3.3節に記載されています。配信予測精度の進化に影響遭遇ノードは異なるパラメータ設定を有する場合は、セクション2.1.2.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "The calculation of the updates to the delivery predictabilities during an encounter has three parts.",
      "ja": "遭遇時の配信予測精度に対する更新の計算は、3つの部分を有しています。"
    },
    {
      "indent": 3,
      "text": "When two nodes meet, the first thing they do is to update the delivery predictability for each other, so that nodes that are often encountered have a high delivery predictability. If node B has not met node A for a long time or has never met node B, such that P_(A,B) < P_first_threshold, then P_(A,B) should be set to P_encounter_first. Because PRoPHET generally has no prior knowledge about whether this is an encounter that will be repeated relatively frequently or one that will be a rare event, P_encounter_first SHOULD be set to 0.5 unless the node has extra information obtained other than through the PRoPHET protocol about the likelihood of future encounters. Otherwise, P_(A,B) should be calculated as shown in Equation 1, where 0 <= P_encounter <= 1 is a scaling factor setting the rate at which the predictability increases on encounters after the first, and delta is a small positive number that effectively sets an upper bound for P_(A,B). The limit is set so that predictabilities between different nodes stay strictly less than 1. The value of delta should normally be very small (e.g., 0.01) so as not to significantly restrict the range of available predictabilities, but it can be chosen to make calculations efficient where this is important.",
      "ja": "2つのノードが会うとき、彼らは最初のものは、しばしば遭遇しているノードが高い配信予測可能性を持っているように、お互いの配信予測を更新することです。ノードBは、長時間ノードAを満たしていないまたはノードBに会ったことがない、そのようなP_（A、B）<P_first_thresholdことがあれば、P_（A、B）はP_encounter_firstに設定されるべきです。預言者は、一般的に、これは比較的頻繁に繰り返される出会い又は稀な事象であろうものであるかどうかについての事前の知識を持たないので、ノードは尤度約PROPHETプロトコルを通じて以外の追加情報を取得していない限り、P_encounter_firstは0.5に設定されてください将来の出会い。式1に示すように、0 <= P_encounter <=第1後遭遇上での予測増加率を設定するスケーリング係数であり、デルタは小さい正の数であり、さもなければ、P_（A、B）は、計算されるべきですそれは効果的P_（A、B）の上限を設定します。異なるノード間の予測精度は、デルタの値が正常でなければならない厳密に1未満とどまるように制限が設定されている非常に小さい（例えば、0.01）有意に利用可能な予測精度の範囲を制限するが、計算を行うように選択することができないように効率的な、これは重要です。"
    },
    {
      "indent": 3,
      "text": "P_(A,B) = P_(A,B)_old + ( 1 - delta - P_(A,B)_old ) * P_encounter (Eq. 1)",
      "ja": "P_（A、B）= P_（A、B）_old +（1  - デルタ -  P_（A、B）_old）* P_encounter（式1）。"
    },
    {
      "indent": 3,
      "text": "There are practical circumstances where an encounter that is logically a single encounter in terms of the proximity of the node hardware and/or from the point of view of the human users of the nodes results in several communication opportunities closely spaced in time. For example, mobile nodes communicating with each other using Wi-Fi ad hoc mode may produce apparent multiple encounters with a short interval between them but these are frequently due to artifacts of the underlying physical network when using wireless connections, where transmission problems or small changes in location may result in repeated reconnections. In this case, it would be inappropriate to increase the delivery predictability by the same amount for each opportunity as it would be increased when encounters occur at longer intervals in the normal mobility pattern.",
      "ja": "論理的に複数の通信機会および/またはノードの結果の人間のユーザの観点からノードハードウェアの近傍の点で単一の出会いで出会いが密接に時間的に離間した実用的な状況が存在します。例えば、モバイルノードは、ここで送信の問題や小さな変化、のWi-Fiアドホックモードは、それらの間の短い間隔で見かけ上複数の出会いを生成することができるが、無線接続を使用する場合、これらが原因基礎をなす物理ネットワークのアーティファクトに頻繁に使用して互いに通信します場所に繰り返し再接続をもたらすことができます。この場合には、遭遇が正常モビリティパターンのより長い間隔で発生した場合、それは増加されるであろうように、各機会のために同じ量だけ送達予測可能性を高めるためには不適切であろう。"
    },
    {
      "indent": 3,
      "text": "In order to reduce the distortion of the delivery predictability in these circumstances, P_encounter is a function of the interval since the last encounter resulted in an update of the delivery predictabilities. The form of the function is as shown in Figure 2.",
      "ja": "このような状況で送達予測の歪みを低減するために、P_encounterは、最後の出会いは、配信予測精度の更新をもたらしたので、間隔の関数です。図2に示すように、関数の形です。"
    },
    {
      "indent": 3,
      "text": "           P_encounter\n                ^\n                |\nP_encounter_max +  -  - .-------------------------------------\n                |      /\n                |     / .\n                |    /\n                |   /   .\n                |  /\n                | /     .\n                |/\n                +-------+-------------------------------------> I\n                       I_typ",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 2: P_encounter as function of time interval, I,\n                    between updates",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The form of the function is chosen so that both the increase of P_(A,B) resulting from Equation 1 and the decrease that results from Equation 2 are related to the interval between updates for short intervals. For intervals longer than the \"typical\" time (I_typ) between encounters, P_encounter is set to a fixed value P_encounter_max. The break point reflects the transition between the \"normal\" communication opportunity regime (where opportunities result from the overall mobility pattern) and the closely spaced opportunities that result from what are effectively local artifacts of the wireless technology used to deliver those opportunities.",
      "ja": "関数の形は、P_（A、B）の増大の両方が式1から得られるように選択され、式（2）から生じる減少は、短い間隔の更新間隔に関連しています。遭遇の間の「典型的な」時間（I_typ）よりも長い間隔で、P_encounterは固定値P_encounter_maxに設定されています。ブレークポイントは、「正常な」通信機会レジーム（機会が全体的な移動度パターンに起因する）と効果的にこれらの機会を提供するために使用される無線技術の局所アーチファクトであるかに起因する狭い間隔の機会との間の移行を反映しています。"
    },
    {
      "indent": 3,
      "text": "P_encounter_max is chosen so that the increment in P_(A,B) provided by Equation 1 significantly exceeds the decay of the delivery predictability over the typical interval between encounters resulting from Equation 2.",
      "ja": "式1によって提供P_（A、B）の増加が著しく、式2から得られた遭遇の間の典型的な間隔で配信予測の減衰を超えるようにP_encounter_maxが選択されます。"
    },
    {
      "indent": 3,
      "text": "Making P_encounter dependent on the interval time also avoids inappropriate extra increments of P_(A,B) in situations where node A is in communication with several other nodes simultaneously. In this case, updates from each of the communicating nodes have to be distributed to the other nodes, possibly leading to several updates being carried out in a short period. This situation is discussed in more detail in Section 3.2.2.",
      "ja": "インターバル時間にP_encounter依存作ることも、ノードAは、同時にいくつかの他のノードと通信している状況でP_（A、B）の不適切な余分増分を回避します。この場合、通信ノードの各々からの更新は、おそらくいくつかの更新が短時間で行われることにつながる、他のノードに配布されなければなりません。この状況は、3.2.2項で詳しく説明されています。"
    },
    {
      "indent": 3,
      "text": "If a pair of nodes do not encounter each other during an interval, they are less likely to be good forwarders of bundles to each other, thus the delivery predictability values must age, being reduced in the process. The second part of the updates of the metric values is application of the aging equation shown in Equation 2, where 0 <= gamma <= 1 is the aging constant, and K is the number of time units that have elapsed since the last time the metric was aged. The time unit used can differ and should be defined based on the application and the expected delays in the targeted network.",
      "ja": "ノードのペアが期間中にお互いに遭遇していない場合、彼らはこのように配信予測値は、プロセスに縮小され、年齢を重ねる必要があり、お互いにバンドルの良いフォワーダになる可能性が低いです。メトリック値のアップデートの第2の部分は、0 <=、γ<= 1エージング定数であり、Kは、最後の時間から経過した時間単位の数である式（2）に示すエージング式のアプリケーションでありますメトリックは、熟成しました。時間単位が異なることが使用され、アプリケーションとターゲットネットワークの予想される遅延に基づいて定義されるべきです。"
    },
    {
      "indent": 3,
      "text": "P_(A,B) = P_(A,B)_old * gamma^K (Eq. 2)",
      "ja": "P_（A、B）= P_（A、B）_old *ガンマ^ K（式2）"
    },
    {
      "indent": 3,
      "text": "The delivery predictabilities are aged according to Equation 2 before being passed to an encountered node so that they reflect the time that has passed since the node had its last encounter with any other node. The results of the aging process are sent to the encountered peer for use in the next stage of the process. The aged results received from node B in node A are referenced as P_(B,x)_recv.",
      "ja": "配信予測精度は、彼らが、ノードが他のノードとの最後の出会いがあったから経過した時間を反映するように遭遇したノードに渡される前に式（2）に従って老化させます。老化プロセスの結果は、プロセスの次の段階で使用するために遭遇したピアに送信されます。ノードA、ノードBから受信した熟成の結果はP_（B、X）_recvとして参照されます。"
    },
    {
      "indent": 3,
      "text": "The delivery predictability also has a transitive property that is based on the observation that if node A frequently encounters node B, and node B frequently encounters node C, then node C probably is a good node to which to forward bundles destined for node A. Equation 3 shows how this transitivity affects the delivery predictability, where 0 <= beta <= 1 is a scaling constant that controls how large an impact the transitivity should have on the delivery predictability.",
      "ja": "送達の予測はまた、おそらく、ノードAの式宛てバンドルを転送するための良いノードであるノードAが頻繁にノードBに遭遇し、ノードBが頻繁にノードCが発生した場合、その後、ノードCという観察に基づいている推移性を有しています図3は、この推移は、配信予測にどのように影響するかを示し、0 <=ベータ<= 1は、推移は、配信予測可能でなければならないどのように大きな影響を制御するスケーリング定数です。"
    },
    {
      "indent": 3,
      "text": "P_(A,C) = MAX( P_(A,C)_old, P_(A,B) * P_(B,C)_recv * beta ) (Eq. 3)",
      "ja": "P_（A、C）= MAX（P_（A、C）_old、P_（A、B）* P_（B、C）_recv *ベータ）（式3）"
    },
    {
      "indent": 3,
      "text": "Node A uses Equation 3 and the metric values received from the encountered node B (e.g., P_(B,C)_recv) in the third part of updating the metric values stored in node A.",
      "ja": "ノードAは、式3を使用し、メトリック値は、ノードAに格納されたメトリック値を更新する第三の部分に（_recv例えば、P_（B、C））に遭遇するノードBから受信しました"
    },
    {
      "indent": 0,
      "text": "2.1.2.1. Impact of Encounters between Nodes with Different Parameter Settings",
      "ja": "2.1.2.1。異なるパラメータ設定を持つノード間の出会いのインパクト"
    },
    {
      "indent": 3,
      "text": "The various parameters used in the three equations described in Section 2.1.2 are set independently in each node, and it is therefore possible that encounters may take place between nodes that have been configured with different values of the parameters. This section considers whether this could be problematic for the operation of PRoPHET in that zone.",
      "ja": "セクション2.1.2で説明した3つの式で使用される各種パラメータは、各ノードに個別に設定され、遭遇は、パラメータの異なる値で設定されたノード間で行われ得ることが可能です。このセクションでは、これは、そのゾーン内の預言者の動作に問題となり得るかどうかを考慮する。"
    },
    {
      "indent": 3,
      "text": "It is desirable that all the nodes operating in a PRoPHET zone should use closely matched values of the parameters and that the parameters should be set to values that are appropriate for the operating zone. More details of how to select appropriate values are given in Section 3.3. Using closely matched values means that delivery predictabilities will evolve in the same way in each node, leading to consistent decision making about the bundles that should be exchanged during encounters.",
      "ja": "預言者ゾーンで動作するすべてのノードがパラメータの密接にマッチした値を使用し、パラメータが動作ゾーンに適した値に設定されるべきであることが望ましいです。適切な値を選択する方法の詳細は、3.3節に記載されています。密接に一致した値を使用して送達予測精度は、遭遇の間に交換されるべきバンドルについて行う一貫した決定につながる、各ノードで同じように進化することを意味します。"
    },
    {
      "indent": 3,
      "text": "Before going on to consider the impact of reasonable but different settings, it should be noted that malicious nodes can use inappropriate settings of the parameters to disrupt delivery of bundles in a PRoPHET zone as described in Section 6.",
      "ja": "合理的なしかし、異なる設定の影響を考慮することに進む前に、悪意のあるノードは第6節で説明したように預言者ゾーンにバンドルの配信を破壊するパラメータの不適切な設定を使用できることに留意すべきです。"
    },
    {
      "indent": 3,
      "text": "Firstly and importantly, use of different, but legitimate, settings in encountering nodes will not cause problems in the protocol itself. Apart from P_encounter_first, the other parameters control the rate of change of the metric values or limit the range of valid values that will be stored in a node. None of the calculations in a node will be invalidated or result in illegal values if the metric values received from another node were calculated using different parameters. Furthermore, the protocol is designed so that it is not possible to carry delivery predictabilities outside the permissible range of 0 to 1.",
      "ja": "まず重要なこと、遭遇したノードで、異なるが、合法的な設定を使用すると、プロトコル自体に問題が発生することはありません。離れP_encounter_firstから、他のパラメータは、メトリック値の変化率を制御またはノードに格納される有効な値の範囲を制限します。ノードでの計算はいずれも無効にしたり、別のノードから受信したメトリック値が異なるパラメータを用いて計算した場合に不正な値をもたらすであろう。 0〜1の許容範囲外で配信予測精度を運ぶことができないように、また、プロトコルが設計されています。"
    },
    {
      "indent": 3,
      "text": "A node MAY consider setting received values greater than (1 - delta) to (1 - delta) if this would simplify operations. However, there are some special situations where it may be appropriate for the delivery predictability for another node to be 1. For example, if a DTN using PRoPHET has multiple gateways to the continuously connected Internet, the delivery predictability seen from PRoPHET in one gateway for the other gateway nodes can be taken as 1 since they are permanently connected through the Internet. This would allow traffic to be forwarded into the DTN through the most advantageous gateway even if it initially arrives at another gateway.",
      "ja": "この操作を簡素化するかどう - （デルタ1）に - ノードが（デルタ1）よりも大きい受信値を設定考慮してもよいです。 DTN使用預言者が連続接続インターネットつのゲートウェイのために預言者から見配信予測に複数のゲートウェイを持っている場合しかし、それは例えば1であるため、別のノードのための送達の予測のために適切であり得るいくつかの特別な状況が存在しますそれらは永久にインターネットを介して接続されているので、他のゲートウェイノードは1とすることができます。これは、トラフィックが、それは最初に別のゲートウェイに到着した場合でも、最も有利なゲートウェイを介してDTNに転送することが可能となります。"
    },
    {
      "indent": 3,
      "text": "Simulation work indicates that the update calculations are quite stable in the face of changes to the rate parameters, so that minor discrepancies will not have a major impact on the performance of the protocol. The protocol is explicitly designed to deal with situations where there are random factors in the opportunistic nature of node encounters, and this randomness dominates over the discrepancies in the parameters.",
      "ja": "マイナーな相違は、プロトコルのパフォーマンスに大きな影響を与えないように、シミュレーション作業は、更新の計算は、レートパラメータに対する変更の顔でかなり安定していることを示しています。プロトコルは、明示的にノード遭遇の日和見本質的にランダムな要因がある状況に対処するように設計されており、このランダム性は、パラメータの不一致を支配されています。"
    },
    {
      "indent": 3,
      "text": "More major discrepancies may lead to suboptimal behavior of the protocol, as certain paths might be more preferred or more deprecated inappropriately. However, since the protocol overall is epidemic in nature, this would not generally lead to non-delivery of bundles, as they would also be passed to other nodes and would still be delivered, though possibly not on the optimal path.",
      "ja": "特定の経路が不適切より好ましい以上の推奨されないかもしれない、より主要な相違は、プロトコルの次善の挙動につながる可能性があります。プロトコルは、全体的な自然の中で流行あるので、それらはまた、他のノードに渡されると、依然として最適経路にかかわらず、おそらく、ない配信されるようしかし、これは一般的に、バンドルの不着をもたらさないであろう。"
    },
    {
      "indent": 0,
      "text": "2.1.3. Optional Delivery Predictability Optimizations",
      "section_title": true,
      "ja": "2.1.3。オプションの配信予測可能性の最適化"
    },
    {
      "indent": 0,
      "text": "2.1.3.1. Smoothing",
      "section_title": true,
      "ja": "2.1.3.1。平滑化"
    },
    {
      "indent": 3,
      "text": "To give the delivery predictability a smoother rate of change, a node MAY apply one of the following methods:",
      "ja": "配信予測可能に変化スムーズな率を与えるために、ノードは、次のいずれかの方法を適用することができます。"
    },
    {
      "indent": 3,
      "text": "1. Keep a list of NUM_P values for each destination instead of only a single value. (The recommended value is 4, which has been shown in simulations to give a good trade-off between smoothness and rate of response to changes.) The list is held in order of acquisition. When a delivery predictability is updated, the value at the \"newest\" position in the list is used as input to the equations in Section 2.1.2. The oldest value in the list is then discarded and the new value is written in the \"newest\" position of the list. When a delivery predictability value is needed (either for sending to a peering PRoPHET node, or for making a forwarding decision), the average of the values in the list is calculated, and that value is then used. If less than NUM_P values have been entered into the list, only the positions that have been filled should be used for the averaging.",
      "ja": "1.代わりに単一の値のみを宛先ごとNUM_P値のリストを保持。リスト取得のために保持されている（推奨値は滑らかと変化に対する応答の速度との間の良好なトレードオフを与えることがシミュレーションで示されている。4、です）。配信予測が更新されると、リスト内の「最新」の位置の値はセクション2.1.2に数式への入力として使用されます。リスト内の最も古い値は破棄され、新しい値は、リストの「最新」の位置に書かれています。配信予測値（ピアリング預言者ノードに送信する、または転送の決定を行うためのいずれか）が必要である場合、リスト内の値の平均値を算出し、その値は、使用されています。 NUM_P値未満がリストに入力された場合は、満たされた唯一の位置が平均化のために使用すべきです。"
    },
    {
      "indent": 3,
      "text": "2. In addition to keeping the delivery predictability as described in Section 2.1.2, a node MAY also keep an exponential weighted moving average (EWMA) of the delivery predictability. The EWMA is then used to make forwarding decisions and to report to peering nodes, but the value calculated according to Section 2.1.2 is still used as input to the calculations of new delivery predictabilities. The EWMA is calculated according to Equation 4, where 0 <= alpha <= 1 is the weight of the most current value.",
      "ja": "2.セクション2.1.2に記載したように、送達予測可能性を維持することに加えて、ノードはまた、送達の予測の指数加重移動平均（EWMA）を維持することができます。 EWMAは、次いで、転送の決定を行うこととピアリングノードに報告するために使用されるが、セクション2.1.2に従って計算された値は、依然として新しい配信予測精度の計算への入力として使用されます。 EWMAは、0 <=アルファ<= 1が最も電流値の重みである式4、に従って計算されます。"
    },
    {
      "indent": 3,
      "text": "P_ewma = P_ewma_old * (1 - alpha) + P * alpha (Eq. 4)",
      "ja": "P_ewma = P_ewma_old *（1  - アルファ）+ P *α（式4）。"
    },
    {
      "indent": 3,
      "text": "The appropriate choice of alpha may vary depending on application scenario circumstances. Unless prior knowledge of the scenario is available, it is suggested that alpha is set to 0.5.",
      "ja": "アルファの適切な選択は、アプリケーションシナリオの状況に応じて変えることができます。シナリオの事前知識が利用可能でない限り、アルファが0.5に設定されていることが示唆されます。"
    },
    {
      "indent": 0,
      "text": "2.1.3.2. Removal of Low Delivery Predictabilities",
      "section_title": true,
      "ja": "2.1.3.2。低配信予測精度の除去"
    },
    {
      "indent": 3,
      "text": "To reduce the data to be transferred between two nodes, a node MAY treat delivery predictabilities smaller than P_first_threshold, where P_first_threshold is a small number, as if they were zero, and thus they do not need to be stored or included in the list sent during the Information Exchange Phase. If this optimization is used, care must be taken to select P_first_threshold to be smaller than delivery predictability values normally present in the network for destinations for which this node is a forwarder. It is possible that",
      "ja": "2つのノード間で転送されるデータを減少させるために、それらがゼロであるかのように、ノードは、P_first_thresholdが少数であるP_first_threshold、より小さい送達予測精度を扱うことができ、従ってそれらは中に送信され、リストに格納されているか、含まれる必要はありません情報交換フェーズ。この最適化を使用する場合、注意は、このノードが混載された宛先のネットワーク中に通常存在送達の予測値よりも小さくなるようにP_first_thresholdを選択するように注意しなければなりません。それは可能性があります"
    },
    {
      "indent": 3,
      "text": "P_first_threshold could be calculated based on delivery predictability ranges and the amount they change historically, but this has not been investigated yet.",
      "ja": "P_first_thresholdは、配信予測範囲と、彼らが歴史的に変化する量に基づいて計算することができるが、これはまだ調査されていません。"
    },
    {
      "indent": 0,
      "text": "2.1.4. Forwarding Strategies and Queueing Policies",
      "section_title": true,
      "ja": "2.1.4。戦略およびキューイングポリシーを転送"
    },
    {
      "indent": 3,
      "text": "In traditional routing protocols, choosing where to forward a message is usually a simple task; the message is sent to the neighbor that has the path to the destination with the lowest cost (often the shortest path). Normally, the message is also sent to only a single node since the reliability of paths is relatively high. However, in the settings we envision here, things are radically different. The first possibility that must be considered when a bundle arrives at a node is that there might not be a path to the destination available, so the node has to buffer the bundle, and upon each encounter with another node, the decision must be made whether or not to transfer a particular bundle. Furthermore, having duplicates of messages (on different nodes, as the bundle offer/request mechanism described in Section 4.3.5 ensures that a node does not receive a bundle it already carries) may also be sensible, as forwarding a bundle to multiple nodes can increase the delivery probability of that bundle.",
      "ja": "伝統的なルーティングプロトコルでは、ここでメッセージを転送することを選択すると、通常の単純な作業です。メッセージは最低コスト（多くの場合、最短経路）と目的地への経路を有している隣人に送られます。パスの信頼度が比較的高いので、通常、メッセージは、単一のノードに送信されます。しかし、我々はここで想定した設定では、物事は根本的に異なっています。バンドルがノードに到着したときに考慮しなければならない第1の可能性は、ノードバンドルをバッファリングしなければならないので、利用可能な宛先への経路が存在しないかもしれないということであり、他のノードとそれぞれの遭遇時に、決定はかどうかの判断がなされなければなりませんまたは特定のバンドルを転送しません。さらに、メッセージの重複を有する、複数のノードにバンドルを転送するように、賢明であり得る（異なるノードには、セクション4.3.5に記載バンドル提供/要請機構は、ノードは、それが既に担持バンドルを受信しないことを保証するようにする）ことができますそのバンドルの配送確率を高めます。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, these decisions are not trivial to make. In some cases, it might be sensible to select a fixed threshold and only give a bundle to nodes that have a delivery predictability over that threshold for the destination of the bundle. On the other hand, when encountering a node with a low delivery predictability, it is not certain that a node with a higher metric will be encountered within a reasonable time. Thus, there can also be situations where we might want to be less strict in deciding who to give bundles to. Furthermore, there is the problem of deciding how many nodes to give a certain bundle to. Distributing a bundle to a large number of nodes will of course increase the probability of delivering that particular bundle to its destination, but this comes at the cost of consuming more system resources for bundle storage and possibly reducing the probability of other bundles being delivered. On the other hand, giving a bundle to only a few nodes (maybe even just a single node) will use less system resources, but the probability of delivering a bundle is lower, and the delay incurred is high.",
      "ja": "残念ながら、これらの決定は、作成が簡単ではないです。いくつかの場合において、固定された閾値を選択してのみバンドルの宛先にその閾値を超える配信予測可能性を持っているノードにバンドルを与える賢明かもしれません。低い配信予測とノードに遭遇したとき一方、より高いメトリックを有するノードは、妥当な時間内で遭遇するであろうことは確かではありません。このように、また、我々はにバンドルを与えるために誰が決めるのにそれほど厳密になりたいかもしれない状況があることができます。さらに、特定のバンドルを与えるためにどのように多くのノードを決定する問題があります。多数のノードへのバンドルを配布することはもちろん、その先にその特定のバンドルを提供する確率を高めるが、これはバンドル・ストレージのためのより多くのシステムリソースを消費し、おそらく配信されている他のバンドルの確率を減らすことを犠牲にしています。一方、ごく少数のノード（多分1つだけのノード）にバンドルを与えることは少ないシステムリソースを使用するが、バンドルを配信する確率が低く、発生する遅延は高いであろう。"
    },
    {
      "indent": 3,
      "text": "When resources are constrained, nodes may suffer from storage shortage, and may have to drop bundles before they have been delivered to their destinations. They may also wish to consider the length of bundles being offered by an encountered node before accepting transfer of the bundle in order to avoid the need to drop the new bundle immediately or to ensure that there is adequate space to hold the bundle offered, which might require other bundles to be dropped. As with the decision as to whether or not to forward a bundle, deciding which bundles to accept and/or drop to still maintain good performance might require different policies in different scenarios.",
      "ja": "リソースに制約がある場合は、ノードがストレージ不足に苦しむこと、そして彼らの宛先に配信されている前にバンドルをドロップする必要があります。彼らはまた、どのかもしれないが、すぐに新しいバンドルを削除するか、提供するバンドルを保持するのに十分なスペースがあることを確認するために必要性を回避するために、バンドルの転送を受け入れる前に遭遇したノードによって提供されているバンドルの長さを考慮することを望むかもしれませんドロップされる他のバンドルが必要です。まだ別のシナリオで異なるポリシーを必要とするかもしれない優れた性能を維持するために、および/またはドロップを受け入れるようにバンドルとしてバンドルを転送するか否かの決定、決定と同じように。"
    },
    {
      "indent": 3,
      "text": "Nodes MAY define their own forwarding strategies and queueing policies that take into account the special conditions applicable to the nodes, and local resource constraints. Some default strategies and policies that should be suitable for most normal operations are defined in Section 3.6 and Section 3.7.",
      "ja": "ノードは自分の転送手法と考慮にノードに適用される特別な条件、およびローカルリソースの制約を取るキューイングポリシーを定義することもできます。ほとんどの通常の操作に適していなければならないいくつかのデフォルトの戦略と政策は、セクション3.6および3.7節で定義されています。"
    },
    {
      "indent": 0,
      "text": "2.2. Bundle Protocol Agent to Routing Agent Interface",
      "section_title": true,
      "ja": "2.2。ルーティングエージェントインターフェイスにプロトコルエージェントをバンドル"
    },
    {
      "indent": 3,
      "text": "The bundle protocol [RFC5050] introduces the concept of a \"bundle protocol agent\" that manages the interface between applications and the \"convergence layers\" that provide the transport of bundles between nodes during communication opportunities. This specification extends the bundle protocol agent with a routing agent that controls the actions of the bundle protocol agent during an (opportunistic) communications opportunity.",
      "ja": "バンドルプロトコル[RFC5050]は、アプリケーションとの通信機会の間のノード間のバンドルの輸送を提供する「収束層」との間のインタフェースを管理する「バンドルプロトコル剤」の概念を導入します。この仕様は、（日和見）通信機会中バンドルプロトコル・エージェントの動作を制御するルーティング剤とバンドルプロトコル剤を延びています。"
    },
    {
      "indent": 3,
      "text": "This specification defines the details of the PRoPHET routing agent, but the interface defines a more general interface that is also applicable to alternative routing protocols.",
      "ja": "この仕様は、預言者のルーティングエージェントの詳細を定義するが、インタフェースはまた、別のルーティングプロトコルにも適用可能であるより一般的なインターフェイスを定義します。"
    },
    {
      "indent": 3,
      "text": "To enable the PRoPHET routing agent to operate properly, it must be aware of the bundles stored at the node, and it must also be able to tell the bundle protocol agent of that node to send a bundle to a peering node. Therefore, the bundle protocol agent needs to provide the following interface/functionality to the routing agent:",
      "ja": "適切に動作するPROPHETルーティングエージェントを有効にするために、それはノードに格納されているバンドルを認識する必要があり、また、ピア・ノードへのバンドルを送信するために、そのノードのバンドルプロトコルエージェントに伝えることができなければなりません。したがって、バンドルプロトコルエージェントは、ルーティングエージェントに次のインターフェース/機能を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Get Bundle List Returns a list of the stored bundles and their attributes to the routing agent.",
      "ja": "バンドルリストは、ルーティングエージェントに保存されたバンドルとその属性のリストを返します。"
    },
    {
      "indent": 3,
      "text": "Send Bundle Makes the bundle protocol agent send a specified bundle.",
      "ja": "送信バンドルは、バンドルプロトコルエージェントは、指定されたバンドルを送信します。"
    },
    {
      "indent": 3,
      "text": "Accept Bundle Gives the bundle protocol agent a new bundle to store.",
      "ja": "受け入れバンドルは、バンドルプロトコルエージェントに格納するための新しいバンドルを与えます。"
    },
    {
      "indent": 3,
      "text": "Bundle Delivered Tells the bundle protocol agent that a bundle was delivered to its destination.",
      "ja": "配信バンドルは、バンドルがその宛先に配信されたバンドル・プロトコルエージェントに指示します。"
    },
    {
      "indent": 3,
      "text": "Drop Bundle Advice Advises the bundle protocol agent that a specified bundle should not be offered for forwarding in future and may be dropped by the bundle protocol agent if appropriate.",
      "ja": "ドロップバンドルアドバイスは、指定したバンドルは、将来的に転送するために提供されるべきではないし、適切な場合には、バンドルプロトコルエージェントによって破棄される可能性があり、バンドルプロトコルエージェントをアドバイスします。"
    },
    {
      "indent": 3,
      "text": "Route Import Can be used by a gateway node in a PRoPHET zone to import reachability information about endpoint IDs (EIDs) that are external to the PRoPHET zone. Translation functions dependent on the external routing protocol will be used to set the appropriate delivery predictabilities for imported destinations as described in Section 2.3.",
      "ja": "ルートインポートは預言者ゾーンの外部にあるエンドポイントのID（のEID）に関する到達可能性情報をインポートするために預言者ゾーン内のゲートウェイノードによって使用され得ます。外部のルーティングプロトコルに依存する翻訳機能は、セクション2.3で説明したようにインポートされた宛先の適切な送達予測精度を設定するために使用されるであろう。"
    },
    {
      "indent": 3,
      "text": "Route Export Can be used by a gateway node in a PRoPHET zone to export reachability information (destination EIDs and corresponding delivery predictabilities) for use by routing protocols in other parts of the DTN.",
      "ja": "ルートエクスポートDTNの他の部分にルーティングプロトコルによって使用するための到達可能性情報（宛先のEIDと対応する配信予測精度）をエクスポートする預言者ゾーン内のゲートウェイノードによって使用され得ます。"
    },
    {
      "indent": 6,
      "text": "Implementation Note: Depending on the distribution of functions in a complete bundle protocol agent supporting PRoPHET, reception and delivery of bundles may not be carried out directly by the PRoPHET module. In this case, PRoPHET can inform the bundle protocol agent about bundles that have been requested from communicating nodes. Then, the Accept Bundle and Bundle Delivered functions can be implemented as notifications of the PRoPHET module when the relevant bundles arrive at the node or are delivered to local applications.",
      "ja": "実装注：預言者を支持する完全バンドルプロトコル・エージェントの関数の分布に応じて、バンドルの受信および配信を直接PROPHETモジュールによって行われなくてもよいです。この場合には、預言者は、通信ノードから要求されたバンドルに関するバンドルプロトコルエージェントに通知することができます。関連するバンドルがノードに到着またはローカルアプリケーションに配信されるときに、受け入れバンドルとバンドル配信機能は預言者モジュールの通知として実装することができます。"
    },
    {
      "indent": 0,
      "text": "2.3. PRoPHET Zone Gateways",
      "section_title": true,
      "ja": "2.3。預言者ゾーンゲートウェイ"
    },
    {
      "indent": 3,
      "text": "PRoPHET is designed to handle routing primarily within a \"PRoPHET zone\", i.e., a set of nodes that all implement the PRoPHET routing scheme. However, since we recognize that a PRoPHET routing zone is unlikely to encompass an entire DTN, there may be nodes within the zone that act as gateways to other nodes that are the destinations for bundles generated within the zone or that insert bundles into the zone.",
      "ja": "預言者は、「預言者ゾーン」、すべてのスキームをルーティング預言者を実装するノードの、すなわち、セット内で主にルーティング処理するように設計されています。我々は預言者ルーティングゾーン全体DTNを包含しにくいことを認識するので、ゾーンまたはゾーンへのその挿入バンドル内で生成バンドルの宛先である他のノードへのゲートウェイとして機能ゾーン内のノードが存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "PRoPHET MAY elect to export and import routes across a bundle protocol agent interface. The delivery predictability to use for routes that are imported depends on the routing protocol used to manage those routes. If a translation function between the external routing protocol and PRoPHET exists, it SHOULD be used to set the delivery predictability. If no such translation function exists, the delivery predictability SHOULD be set to 1. For those routes that are exported, the current delivery predictability will be exported with the route.",
      "ja": "預言者は、バンドルプロトコルエージェントインターフェース全体でのエクスポートとインポートルートに選ぶことができます。インポートされたルートに使用する送達の予測は、それらのルートを管理するために使用されるルーティングプロトコルに依存します。外部のルーティングプロトコルと預言者との間の変換機能が存在する場合、配信予測を設定するために使用されるべきです。このような変換機能が存在しない場合、配信予測がエクスポートされるこれらのルートのために1に設定されるべきであり、現在の配信予測は、ルートにエクスポートされます。"
    },
    {
      "indent": 0,
      "text": "2.4. Lower-Layer Requirements and Interface",
      "section_title": true,
      "ja": "2.4。下層の要件およびインターフェイス"
    },
    {
      "indent": 3,
      "text": "PRoPHET can be run on a large number of underlying networking technologies. To accommodate its operation on all kinds of lower layers, it requires the lower layers to provide the following functionality and interfaces.",
      "ja": "預言者は、基盤となるネットワーク技術の多数で実行することができます。下位層のすべての種類の動作に対応するために、それは次の機能とのインタフェースを提供するために、下層を必要とします。"
    },
    {
      "indent": 3,
      "text": "Neighbor discovery and maintenance A PRoPHET node needs to know the identity of its neighbors and when new neighbors appear and old neighbors disappear. Some wireless networking technologies might already contain mechanisms for detecting neighbors and maintaining this state. To avoid redundancies and inefficiencies, neighbor discovery is thus not included as a part of PRoPHET, but PRoPHET relies on such a mechanism in lower layers. The lower layers MUST provide the two functions listed below. If the underlying networking technology does not support such services, a simple neighbor discovery scheme using local broadcasts of beacon messages could be run in between PRoPHET and the underlying layer. An example of a simple neighbor discovery mechanism that could be used is in Appendix B.",
      "ja": "近隣探索およびメンテナンス預言者ノードは、その隣人の正体を知っている必要があると新しい隣人が表示され、古い隣人が消えたとき。一部のワイヤレスネットワーク技術は、すでにネイバーを検出し、この状態を維持するためのメカニズムが含まれている場合があります。冗長性と非効率性を回避するために、近隣探索は、このように預言者の一部として含まれていないが、預言者は、下位層において、そのような機構に依存しています。下位層は、下記の二つの機能を提供しなければなりません。基盤となるネットワーク技術は、そのようなサービスをサポートしていない場合は、ビーコンメッセージのローカルブロードキャストを使用して簡単な近隣探索方式は、預言者とその下にある層との間で実行することができます。使用することができ、簡単な近隣探索機構の例は、付録Bにあります"
    },
    {
      "indent": 8,
      "text": "New Neighbor\n     Signals to the PRoPHET agent that a new node has become a\n     neighbor.  A neighbor is defined here as another node that\n     is currently within communication range of the wireless\n     networking technology in use.  The PRoPHET agent should now\n     start the Hello procedure as described in Section 5.2.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Neighbor Gone Signals to the PRoPHET agent that one of its neighbors has left.",
      "ja": "隣国の一つが残した預言者エージェントに隣接ゴーンシグナル。"
    },
    {
      "indent": 3,
      "text": "Local Address An address used by the underlying communication layer (e.g., an IP or Media Access Control (MAC) address) that identifies the sender address of the current message. This address must be unique among the nodes that can currently communicate and is only used in conjunction with an Instance Number to identify a communicating pair of nodes as described in Section 4.1. This address and its format is dependent on the communication layer that is being used by the PRoPHET layer.",
      "ja": "現在のメッセージの送信元アドレスを特定する基本的な通信層によって使用されるローカルアドレスのアドレス（例えば、IPまたはMAC（Media Access Control）アドレス）。このアドレスは、現在通信することができるのみセクション4.1に記載したように、ノードの通信ペアを識別するためにインスタンス番号と組み合わせて使用​​されているノードの中で一意でなければなりません。このアドレスは、そのフォーマットは預言者層で使用されている通信層に依存しています。"
    },
    {
      "indent": 0,
      "text": "3. Protocol Overview",
      "section_title": true,
      "ja": "3.プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The PRoPHET protocol involves two principal phases:",
      "ja": "預言者のプロトコルは、2つの主要な段階を含みます："
    },
    {
      "indent": 3,
      "text": "o becoming aware of new neighbors that implement the protocol and establishing a point-to-point connection between each pair of encountering nodes, and",
      "ja": "プロトコルを実装する新しい近隣の認識になってきてノードに遭遇の各対の間のポイントツーポイント接続を確立すること、およびo"
    },
    {
      "indent": 3,
      "text": "o using the connection for information exchange needed to establish PRoPHET routing and to exchange bundles.",
      "ja": "預言者のルーティングを確立するために、およびバンドルを交換するために必要な情報交換のための接続を使用して、O。"
    },
    {
      "indent": 0,
      "text": "3.1. Neighbor Awareness",
      "section_title": true,
      "ja": "3.1。近隣意識"
    },
    {
      "indent": 3,
      "text": "Since the operation of the protocol is dependent on the encounters of nodes running PRoPHET, the nodes must be able to detect when a new neighbor is present. The protocol may be run on several different networking technologies, and as some of them might already have methods available for detecting neighbors, PRoPHET does not include a mechanism for neighbor discovery. Instead, it requires the underlying layer to provide a mechanism to notify the protocol of when neighbors appear and disappear as described in Section 2.4.",
      "ja": "プロトコルの動作は預言者を実行しているノードの遭遇に依存するため、ノードは、新しい隣人が存在するときを検出することができなければなりません。プロトコルは、いくつかの異なるネットワーク技術上で実行することができる、そのうちのいくつかは、すでにネイバーを検出するために利用可能な方法があるかもしれないとして、預言者が近隣探索のためのメカニズムが含まれていません。その代わりに、隣人が表示され、セクション2.4で説明したように消えるときのプロトコルを通知する仕組みを提供するために、下の層を必要とします。"
    },
    {
      "indent": 3,
      "text": "When a new neighbor has been detected, the protocol starts to set up a link with that node through the Hello message exchange as described in Section 5.2. The Hello message exchange allows for negotiation of capabilities between neighbors. At present, the only capability is a request that the offering node should or should not include bundle payload lengths with all offered bundles rather than just for fragments. Once the link has been set up, the protocol may continue to the Information Exchange Phase (see Section 3.2). Once this has been completed, the nodes will normally recalculate the delivery predictabilities using the equations and mechanisms described in Sections 2.1.2 and 2.1.3.",
      "ja": "新しい隣人が検出された場合は、プロトコルは5.2節で説明したようにHelloメッセージ交換により、そのノードとのリンクを設定するために開始します。 Helloメッセージの交換は、ネイバー間の機能の交渉が可能になります。現時点では、唯一の機能は提供ノードがかというだけの断片のためのより提供されるすべてのバンドルとバンドルペイロード長を含むべきではない必要があることを要求されます。リンクが設定されたら、プロトコルは、情報交換フェーズ（3.2節を参照）し続けることができます。これが完了すると、ノードは通常、セクション2.1.2および2.1.3に記載の式およびメカニズムを使用して送達予測精度を再計算します。"
    },
    {
      "indent": 3,
      "text": "As described in Section 2.1.2, there are some circumstances in which a single logical encounter may result in several actual communication opportunities. To avoid the delivery predictability of the encountered node being increased excessively under these circumstances, the value of P_encounter is made dependent on the interval time between delivery predictability updates when the interval is less than the typical interval between encounters, but it is a constant for longer intervals.",
      "ja": "セクション2.1.2で説明したように、単一の論理出会いは、いくつかの実際の通信の機会をもたらす可能性のあるいくつかの状況があります。これらの状況下で過度に増加して遭遇したノードの配信予測可能性を回避するために、P_encounterの値は、間隔が出会いの間の典型的な間隔未満で送達予測の更新の間のインターバル時間に依存して行われるが、それは長く一定であります間隔。"
    },
    {
      "indent": 3,
      "text": "In order to make use of this time dependence, PRoPHET maintains a list of recently encountered nodes identified by the Endpoint Identifier (EID) that the node uses to identify the communication session and containing the start time of the last communication session with that node. The size of this list is controlled because nodes that are not in contact and that started their last connection more than a time I_typ before the present can be dropped from the list. It also maintains a record of the time at which the decay function (Equation 2) was last applied to the delivery predictabilities in the node.",
      "ja": "この時間依存性を利用するために、預言者は、ノードが通信セッションを識別し、そのノードとの最後の通信セッションの開始時間を含むために使用するエンドポイント識別子（EID）によって識別最近遭遇したノードのリストを維持します。このリストのサイズが制御され、接触していないし、それはより多くの存在は、リストから削除することができます前に、時間I_typよりも、彼らの最後の接続を開始したノードのため。また、減衰関数（式2）が最後のノードに配信予測精度に適用された時間の記録を維持します。"
    },
    {
      "indent": 0,
      "text": "3.2. Information Exchange Phase",
      "section_title": true,
      "ja": "3.2。情報交換フェーズ"
    },
    {
      "indent": 3,
      "text": "The Information Exchange Phase involves two parts:",
      "ja": "情報交換フェーズには2つの部分が含まれます。"
    },
    {
      "indent": 3,
      "text": "o establishing the Router Information Base (RIB Exchange Sub-Phase), and",
      "ja": "ルータ情報ベース（RIB交換サブフェーズ）、および確立O"
    },
    {
      "indent": 3,
      "text": "o exchanging bundles using this information (Bundle Passing Sub-Phase).",
      "ja": "この情報を使用してバンドルを交換O（バンドルサブフェーズを渡します）。"
    },
    {
      "indent": 3,
      "text": "Four types of information are exchanged during this process:",
      "ja": "情報の4種類のこのプロセスの間に交換されています。"
    },
    {
      "indent": 3,
      "text": "o Routing Information Base Dictionary (RIB Dictionary or RIBD),",
      "ja": "Oルーティング情報ベース辞書（RIB辞書又はリブ）"
    },
    {
      "indent": 3,
      "text": "o Routing Information Base (RIB),",
      "ja": "ルーティング情報ベース（RIB）O、"
    },
    {
      "indent": 3,
      "text": "o Bundle Offers, and",
      "ja": "Oオファーをバンドルし、"
    },
    {
      "indent": 3,
      "text": "o Bundle Responses.",
      "ja": "O応答をバンドルします。"
    },
    {
      "indent": 3,
      "text": "During a communication opportunity, several sets of each type of information may be transferred in each direction as explained in the rest of this section. Each set can be transferred in one or more messages. When (and only when) using a connection-oriented reliable transport protocol such as TCP as envisaged in this document, a set can be partitioned across messages by the software layer above the PRoPHET protocol engine.",
      "ja": "このセクションの残りの部分で説明したように通信機会中に、情報の各タイプの複数のセットが各方向に転送されてもよいです。各セットは、1つ以上のメッセージに転送することができます。本書において想定ように（及び場合にのみ）、TCPなどのコネクション指向の信頼性の高いトランスポートプロトコルを使用する場合、セットは預言者のプロトコル・エンジン上のソフトウェア層によってメッセージを横切って分割することができます。"
    },
    {
      "indent": 3,
      "text": "In this case, the last message in a set is flagged in the protocol. This allows the higher-level software to minimize the buffer memory requirements by avoiding the need to build very large messages in one go and allows the message size to be controlled outside of PRoPHET. However, this scheme is only usable if the transport protocol provides reliable, in-order delivery of messages, as the messages are not explicitly sequence numbered and the overall size of the set is not passed explicitly.",
      "ja": "この場合、セット内の最後のメッセージは、プロトコルにフラグが立てられます。これは、より高いレベルのソフトウェアは、一度に非常に大きなメッセージを構築する必要性を回避することにより、バッファメモリの要件を最小限に抑えることができますし、メッセージのサイズは、預言者の外に制御することを可能にします。トランスポート・プロトコルは、メッセージの信頼性、順序配信を提供する場合、メッセージがない明示的配列が番号付けされているセットの全体的な大きさが明示的に渡されないようにしかし、この方式は、唯一使用可能です。"
    },
    {
      "indent": 3,
      "text": "The specification of PRoPHET also provides a submessage mechanism and retransmission that allows large messages specified by the higher level to be transmitted in smaller chunks. This mechanism was originally provided to allow PRoPHET to operate over unreliable transport protocols such as UDP, but can also be used with reliable transports if the higher-level software does not want to handle message fragmentation. However, the sequencing and length adds overhead that is redundant if the transport protocol already provides reliable, in-order delivery.",
      "ja": "預言者の仕様では、サブメッセージのメカニズムを提供し、より高いレベルで指定された大きなメッセージを可能にする再送小さなチャンクで送信されます。このメカニズムは、もともとUDPなどの信頼性のないトランスポートプロトコルで動作するように預言者を可能にするために設けられましたが、より高いレベルのソフトウェアは、メッセージの断片化を処理したくない場合にも信頼性の高いトランスポートで使用することができます。しかし、配列決定及び長さは、トランスポートプロトコルが既に信頼性、順序配信を提供する場合に冗長であるオーバーヘッドを付加します。"
    },
    {
      "indent": 3,
      "text": "The first step in the Information Exchange Phase is for the protocol to send one or more messages containing a RIB Dictionary TLV (Type-Length-Value message component) to the node with which it is peering. This set of messages contain a dictionary of the Endpoint Identifiers (EIDs) of the nodes that will be listed in the Routing Information Base (RIB); see Section 3.2.1 for more information about this dictionary. After this, one or more messages containing a Routing Information Base TLV are sent. This TLV contains a list of the EIDs that the node has knowledge of, and the corresponding delivery predictabilities for those nodes, together with flags describing the capabilities of the sending node. Upon reception of a complete set of these messages, the peer node updates its delivery predictability table according to the equations in Section 2.1.2. The peer node then applies its forwarding strategy (see Section 2.1.4) to determine which of its stored bundles it wishes to offer the node that sent the RIB; that node will then be the receiver for any bundles to be transferred.",
      "ja": "情報交換フェーズの最初のステップは、それがピアリングしているノードにRIB辞書TLV（タイプ - 長さ - 値メッセージ成分）を含有する1つまたは複数のメッセージを送信するためのプロトコルのためのものです。メッセージのこのセットは、ルーティング情報ベース（RIB）にリストされるノードのエンドポイント識別子（のEID）の辞書を含みます。この辞書についての詳細は、3.2.1項を参照してください。この後、ルーティング情報ベースTLVを含む1件の以上のメッセージが送信されます。このTLVは、送信ノードの能力を記述するフラグと一緒に、ノードは、の知識を有しているのEID、及びそれらのノードに対応する配信予測精度のリストを含みます。これらのメッセージの完全なセットを受信すると、ピアノードは、セクション2.1.2での式に従ってその送達予測テーブルを更新します。ピア・ノードは、それがRIBを送信したノードを提供することを望む、その記憶されたバンドルのかを決定する（セクション2.1.4を参照）、その転送戦略を適用します。任意のバンドルを転送するために、そのノードは、次に、受信機であろう。"
    },
    {
      "indent": 3,
      "text": "After making this decision, one or more Bundle Offer TLVs are prepared, listing the bundle identifiers and their destinations for all bundles the peer node wishes to offer to the receiver node that sent the RIB. As described in [RFC5050], a bundle identifier consists of up to five component parts. For a complete bundle, the identifier consists of",
      "ja": "この決定を行った後、一つ以上のバンドルオファーのTLVは、すべてのピア・ノードは、RIBを送信し、受信ノードに提供することを希望するバンドルのバンドル識別子とその宛先をリスト、用意されています。 [RFC5050]に記載されているように、バンドル識別子は、最大5つの部品から構成されています。完全バンドルには、識別子は、で構成されてい"
    },
    {
      "indent": 3,
      "text": "o source EID,",
      "ja": "OソースEID"
    },
    {
      "indent": 3,
      "text": "o creation timestamp - time of creation, and",
      "ja": "Oの作成タイムスタンプ - 作成時刻、および"
    },
    {
      "indent": 3,
      "text": "o creation timestamp - sequence number.",
      "ja": "Oの作成タイムスタンプ - シーケンス番号。"
    },
    {
      "indent": 3,
      "text": "Additionally, for a bundle fragment, the identifier also contains",
      "ja": "また、バンドルフラグメントのために、識別子も含まれてい"
    },
    {
      "indent": 3,
      "text": "o offset within the payload at which the fragment payload data starts, and",
      "ja": "O断片ペイロードデータが開始するペイロード内のオフセット、及び"
    },
    {
      "indent": 3,
      "text": "o length of the fragment payload data.",
      "ja": "断片ペイロードデータのO長。"
    },
    {
      "indent": 3,
      "text": "If any of the Bundle Offer TLVs lists a bundle for which the source or destination EID was not included in the previous set of RIBD information sent, one or more new RIBD TLVs are sent next with an incremental update of the dictionary. When the receiver node has a dictionary with all necessary EIDs, the Bundle Offer TLVs are sent to it. The Bundle Offer TLVs also contain a list of PRoPHET ACKs (see Section 3.5). If requested by the receiver node during the Hello phase, the Bundle Offer TLV will also specify the payload length for all bundles rather than for just fragments. This information can be used by the receiving node to assist with the selection of bundles to be accepted from the offered list, especially if the available bundle storage capacity is limited.",
      "ja": "バンドルオファーのTLVのいずれかが送信元または宛先EIDが送らRIBD情報の前のセットには含まれなかったバンドルを一覧表示した場合は、1つまたは複数の新しいRIBDのTLVは、辞書の増分更新で次に送信されます。受信ノードは、必要なすべてのEIDと辞書を持っている場合、バンドルオファーのTLVは、それに送られます。バンドルはまた、預言者のACK（3.5節を参照）のリストが含まれているTLVを提供します。こんにちはフェーズ中に受信ノードによって要求された場合は、バンドルオファーTLVはまた、すべてのバンドルのためだけではなく、断片のためのペイロード長を指定します。この情報は、使用可能なバンドル記憶容量が限られている場合は特に、提供されるリストから受け付けされるバンドルの選択を支援するために、受信ノードによって使用されることができます。"
    },
    {
      "indent": 3,
      "text": "The receiving node then examines the list of offered bundles and selects bundles that it will accept according to its own policies, considering the bundles already present in the node and the current availability of resources in the node. The list is sorted according to the priority that the policies apply to the selected bundles, with the highest priority bundle first in the list. The offering node will forward the selected bundles in this order. The prioritized list is sent to the offering node in one or more Bundle Response TLVs using the same EID dictionary as was used for the Bundle Offer TLV.",
      "ja": "受信ノードは、提供バンドルのリストを調べて、それはノードとノード内のリソースの現在の可用性に存在すでにバンドルを考慮すると、独自のポリシーに従って受け入れるバンドルを選択します。リストは、ポリシーがリスト内の最初の優先順位が最も高いバンドルと、選択したバンドルには適用され、優先度に応じてソートされます。提供ノードがこの順に選択されたバンドルを転送します。優先順位リストは、バンドルオファーTLVのために使用されたのと同じEID辞書を使用して、1つ以上のバンドル応答のTLVで提供ノードに送信されます。"
    },
    {
      "indent": 3,
      "text": "When a new bundle arrives at a node, the node MAY inspect its list of available neighbors, and if one of them is a candidate to forward the bundle, a new Bundle Offer TLV MAY be sent to that node. If two nodes remain connected over a longer period of time, the Information Exchange Phase will be periodically re-initiated to allow new delivery predictability information to be spread through the network and new bundle exchanges to take place.",
      "ja": "新しいバンドルがノードに到着すると、ノードは、利用可能なネイバーのリストを検査することができる、そのうちの一つは、バンドルを転送するための候補である場合には、新しいバンドルオファーTLVは、そのノードに送ってもよいです。 2つのノードが長期間にわたって接続されたままならば、情報交換フェーズは、定期的に新しい配信予測情報は、場所を取るために、ネットワークや新しいバンドルの交換を介して広がることができるように再開始されます。"
    },
    {
      "indent": 3,
      "text": "The Information Exchange Phase of the protocol is described in more detail in Section 5.3.",
      "ja": "プロトコルの情報交換フェーズは、5.3節でより詳細に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Routing Information Base Dictionary",
      "section_title": true,
      "ja": "3.2.1。ルーティング情報ベース辞書"
    },
    {
      "indent": 3,
      "text": "To reduce the overhead of the protocol, the Routing Information Base and Bundle Offer/Response TLVs utilize an EID dictionary. This dictionary maps variable-length EIDs (as defined in [RFC4838]), which may potentially be quite long, to shorter numerical identifiers, coded as Self-Delimiting Numeric Values (SDNVs -- see Section 4.1. of RFC 5050 [RFC5050]), which are used in place of the EIDs in subsequent TLVs.",
      "ja": "プロトコルのオーバーヘッドを減らすために、ルーティング情報ベースとバンドルオファー/レスポンスのTLVは、EID辞書を利用します。この辞書は、自己区切り数値値として符号化された短数値識別子に、潜在的に非常に長くすることができる可変長のEIDを（[RFC4838]で定義されるように）、マップ（SDNVs  - セクション4.1を参照してRFC 5050 [RFC5050]の） 、それに続くのTLV内のEIDの代わりに使用されています。"
    },
    {
      "indent": 3,
      "text": "This dictionary is a shared resource between the two peering nodes. Each can add to the dictionary by sending a RIB Dictionary TLV to its peer. To allow either node to add to the dictionary at any time, the identifiers used by each node are taken from disjoint sets: identifiers originated by the node that started the Hello procedure have the least significant bit set to 0 (i.e., are even numbers) whereas those originated by the other peer have the least significant bit set to 1 (i.e., are odd numbers). This means that the dictionary can be expanded by either node at any point in the Information Exchange Phase and the new identifiers can then be used in subsequent TLVs until the dictionary is re-initialized.",
      "ja": "この辞書は、二つのピアリングノード間の共有リソースです。それぞれがそのピアにRIB辞書TLVを送信することにより、辞書に追加することができます。どちらかのノードがいつでも辞書に追加できるようにするには、各ノードで使用される識別子は、互いに素の集合から取られています。こんにちは手続きを開始したノードによって発信された識別子は、最下位ビットが0に設定されている（すなわち、偶数です）他のピアから発信されるものが1に設定最下位ビットを有しているのに対し（すなわち、奇数です）。これは、辞書は、辞書が再初期化されるまで、後続のTLVで使用することができる情報交換フェーズと新しい識別子の任意の時点でいずれかのノードによって拡張することができることを意味しています。"
    },
    {
      "indent": 3,
      "text": "The dictionary that is established only persists through a single encounter with a node (i.e., while the same link set up by the Hello procedure, with the same instance numbers, remains open).",
      "ja": "（同じインスタンス番号のハロー手順により設定同じリンクが、開いたまま、すなわち、）のみ確立される辞書には、ノードと単一の出会いを通して持続します。"
    },
    {
      "indent": 3,
      "text": "Having more then one identifier for the same EID does not cause any problems. This means that it is possible for the peers to create their dictionary entries independently if required by an implementation, but this may be inefficient as a dictionary entry for an EID might be sent in both directions between the peers. Implementers can choose to inspect entries sent by the node that started the Hello procedure and thereby eliminate any duplicates before sending the dictionary entries from the other peer. Whether postponing sending the other peer's entries is more efficient depends on the nature of the physical link technology and the transport protocol used. With a genuinely full-duplex link, it may be faster to accept possible duplication and send dictionary entries concurrently in both directions. If the link is effectively half-duplex (e.g., Wi-Fi), then it will generally be more efficient to wait and eliminate duplicates.",
      "ja": "同じEIDのためにもっとして1つの識別子を持つことは、問題が発生することはありません。これは、実装によって要求された場合、ピアは、独立して自分の辞書のエントリを作成することが可能であることを意味するが、EIDのための辞書エントリは、ピア間の両方向に送信されるかもしれないので、これは効率的ではありません。実装者はハロー手続きを開始し、それによって他のピアからの辞書のエントリを送信する前にすべての重複を排除するノードによって送信されたエントリを検査することを選択することができます。他のピアのエントリを送る延期することは、より効率的であるかどうかは、物理的なリンク技術と使用されるトランスポートプロトコルの性質に依存します。本当に全二重リンクで、可能な重複を受け入れ、両方向に同時に辞書のエントリを送信するために速いかもしれません。リンクが効果的に半二重である場合（例えば、Wi-Fiが）、一般的に待機し、重複を排除するために、より効率的になります。"
    },
    {
      "indent": 3,
      "text": "If a node receives a RIB Dictionary TLV containing an identifier that is already in use, the node MUST confirm that the EID referred to is identical to the EID in the existing entry. Otherwise, the node must send an error response to the message with the TLV containing the error and ignore the TLV containing the error. If a node receives a RIB, Bundle Offer, or Bundle Response TLV that uses an identifier that is not in its dictionary, the node MUST send an error response and ignore the TLV containing the error.",
      "ja": "ノード辞書TLVが既に使用されている識別子を含むRIBを受信した場合、ノードはEIDが既存のエントリにEIDと同一であると呼ばれることを確認しなければなりません。そうでない場合、ノードはエラーを含むTLVのメッセージにエラー応答を送信し、エラーを含むTLVを無視しなければなりません。ノードは、その辞書にない識別子を使用してRIB、バンドルオファー、またはバンドル応答TLVを受信した場合、ノードはエラー応答を送信し、エラーを含むTLVを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Handling Multiple Simultaneous Contacts",
      "section_title": true,
      "ja": "3.2.2。複数の同時コンタクトを処理"
    },
    {
      "indent": 3,
      "text": "From time to time, a mobile node may, for example, be in wireless range of more than one other mobile node. The PRoPHET neighbor awareness protocol will establish multiple simultaneous contacts with these nodes and commence information exchanges with each of them.",
      "ja": "時々、移動ノードは、例えば、複数の他のモバイルノードの無線範囲内であってもよいです。預言者の隣人意識プロトコルは、これらのノードで複数の同時接触を確立し、それらのそれぞれとの情報交換を開始します。"
    },
    {
      "indent": 3,
      "text": "When updating the delivery predictabilities as described in Section 2.1.2 using the values passed from each of the contacts in turn, some special considerations apply when multiple contacts are in progress:",
      "ja": "順番に各接点から渡された値を使用して、セクション2.1.2で説明したように配信予測精度を更新する場合、複数の接点が進行中であるときには、いくつかの特別な考慮事項が適用されます。"
    },
    {
      "indent": 3,
      "text": "SC1 When aging the delivery predictabilities according to Equation 2, the value of K to be used in each set of calculations is always the amount of time since the last aging was done. For example, if node Z makes contact with node A and then with node B, the value of K used when the delivery predictabilities are aged in node Z for the contact with node B will be the time since the delivery predictabilities were aged for the contact with node A.",
      "ja": "SC1式2に係る配信予測精度をエージングする場合、最後のエージングが行われたので、計算の各セットに使用されるKの値は、常に時間の量です。例えば、ノードZは、ノードAと接触した場合、次にノードBと、Kの値は、配信予測精度が接触熟成したので、配信予測精度は、時間になり、ノードBと接触するノードZで熟成する際に使用されますノードAと"
    },
    {
      "indent": 3,
      "text": "SC2 When a new contact starts, the value of P_encounter used when applying Equation 1 for the newly contacted node is always selected according to the time since the last encounter with that node. Thus, the application of Equation 1 to update P_(Z,A) when the contact of nodes Z and A starts (in the aging example just given) and the updating of P_(Z,B) when the contact of nodes Z and B starts will use the appropriate value of P_encounter according to how long it is since node Z previously encountered node A and node B, respectively.",
      "ja": "新しい連絡先が開始されると常にそのノードと最後の出会いからの時間に応じて選択され、新たに接触ノードについて式1を適用する場合SC2は、P_encounterの値が使用されます。ノードZの接点及びAは、（単に所与のエージング例で）開始し、P_（Z、B）場合、ノードZの接点とBの更新時にこのように、式1のアプリケーションは、P_（Z、A）を更新します開始ノードZは、先に、それぞれ、ノードAとノードBに遭遇したので、それがどのくらいの時間に応じてP_encounterの適切な値を使用します。"
    },
    {
      "indent": 3,
      "text": "SC3 If, as with the contact between nodes Z and B, there is another active contact in progress, such as with node A when the contact with node B starts, Equation 1 should *also* be applied to P_(z,x) for all the nodes \"x\" that have ongoing contacts with node Z (i.e., node A in the example given). However, the value of P_encounter used will be selected according to the time since the previous update of the delivery predictabilities as a result of information received from any other node. In the example given here, P_(Z,A) would also have Equation 1 applied when the delivery predictabilities are received from node B, but the value of P_encounter used would be selected according to the time since the updates done when the encounter between nodes Z and A started rather than the time since the previous encounter between nodes A and Z.",
      "ja": "SC3の場合、ノードBが開始されると、式（1）との接触が*も* P_に適用されるべきである場合、ノードZとBとの間の接触と同様に、進行中の別のアクティブコンタクトは、ノードAと同様に、ある（Z、X）のためにノードZとの継続的な接触を持っているすべてのノードが「X」（すなわち、この例では、ノードAが与えられます）。しかし、使用P_encounterの値は、他のノードから受信した情報の結果として配信予測精度の前回の更新からの時間に応じて選択されます。ここで与えられた例では、P_（Z、A）はまた、式1は、配信予測精度は、ノードBから受信された場合に適用されますが、更新が行わためP_encounterの値は、時間に応じて選択されるであろう使用される場合、ノード間の出会いZ及びAは、ノードAとZの間の以前の遭遇からの時間ではなく、開始しました"
    },
    {
      "indent": 3,
      "text": "If these simultaneous contacts persist for some time, then, as described in Section 3.2, the Information Exchange Phase will be periodically rerun for each contact according to the configured timer interval. When the delivery predictability values are recalculated during each rerun, Equation 1 will be applied as in special consideration SC3 above, but it will be applied to the delivery predictability for each active contact using the P_encounter value selected according to the time since the last set of updates were performed on the delivery predictabilities, irrespective of which nodes triggered either the previous or current updates. This means that, in the example discussed here, P_(Z,A) and P_(Z,B) will be updated using the same value of P_encounter whether node A or node B initiated the update while the three nodes remain connected.",
      "ja": "これらの同時接触はしばらくの間続く場合は、その後、3.2節で説明したように、情報交換フェーズが設定され、タイマーの間隔に応じて、各連絡先に再実行し、定期的になります。配信予測値は各再実行時に再計算される場合、式1は、上記の特別な配慮をSC3のように適用されるが、それは最後のセットからの時間に応じて選択P_encounter値を用いて各アクティブコンタクトの配信予測に適用されます更新は、ノードがいずれかの前または現在の更新をトリガにかかわらず、そのうちの送達予測精度で行いました。これは、ここで説明した例では、P_（Z、A）とP_（Z、B）の3つのノードが接続されたまま、ノードAまたはノードBは、更新を開始したかどうかP_encounterの同じ値を用いて更新される、ことを意味します。"
    },
    {
      "indent": 3,
      "text": "The interval between reruns of the information exchange will generally be set to a small fraction of the expected time between independent encounters of pairs of nodes. This ensures that, for example, the delivery predictability information obtained by node Z from node A will be passed on to node B whether or not nodes A and B can communicate directly during this encounter. This avoids problems that may arise from peculiarities of radio propagation during this sort of encounter, but the scaling of the P_encounter factor according to the time between updates of the delivery predictabilities means that the predictabilities for the nodes that are in contact are not increased excessively as would be the case if each information exchange were treated as a separate encounter with the value of P_encounter_max used each time. When several nodes are in mutual contact, the delivery predictabilities in each node stabilize after a few exchanges due to the scaling of P_encounter as well as the form of Equation 3 where a \"max\" function is used. This has been demonstrated by simulation.",
      "ja": "情報交換の再放送との間の間隔は、一般的に、ノードの対の独立した遭遇の間の予想時間のごく一部に設定されます。これは、例えば、ノードAからノードZによって得られた送達の予測情報は、ノードA及びBは、この出会いの間で直接通信することができるかどうかBのノードに渡されることを保証します。これは出会いのこの種の間の無線伝搬の特殊性から生じ得る問題を回避するが、送達予測精度の更新間の時間に応じP_encounter係数のスケーリングは、接触しているノードのための予測精度を過度に増加されないことを意味します各情報交換をするたびに使用P_encounter_maxの値に別個の出会いのように処理した場合のケースであろう。いくつかのノードが相互に接触している場合、各ノードに配信予測精度が原因P_encounterのスケーリングならびに「最大」関数が使用される式3の形態に少数の交換後に安定化します。これは、シミュレーションによって実証されています。"
    },
    {
      "indent": 3,
      "text": "The effect of the updates of the delivery predictabilities when there are multiple simultaneous contacts is that the information about good routes on which to forward bundles is correctly passed between sets of nodes that are simultaneously in contact through the transitive update of Equation 3 during each information exchange, but the delivery predictabilities for the direct contacts are not exaggerated.",
      "ja": "複数の同時接触が存在する配信予測精度の更新の効果は、正しく各情報交換の際に式（3）の推移更新を介して接触するように同時にあるノードのセットの間を通過するバンドルを転送するために良好なルートに関する情報しかし、直接の連絡先の配信予測精度が誇張されていません。"
    },
    {
      "indent": 0,
      "text": "3.3. Routing Algorithm",
      "section_title": true,
      "ja": "3.3。ルーティングアルゴリズム"
    },
    {
      "indent": 3,
      "text": "The basic routing algorithm of the protocol is described in Section 2.1. The algorithm uses some parameter values in the calculation of the delivery predictability metric. These parameters are configurable depending on the usage scenario, but Figure 3 provides some recommended default values. A brief explanation of the parameters and some advice on setting appropriate values is given below.",
      "ja": "プロトコルの基本的なルーティングアルゴリズムは、セクション2.1に記載されています。このアルゴリズムは、配信予測メトリックの計算にいくつかのパラメータ値を使用しています。これらのパラメータは、使用シナリオに応じて、設定されているが、図3は、いくつかの推奨されるデフォルト値を提供します。パラメータの簡単な説明と適切な値を設定する上でいくつかのアドバイスは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "I_typ I_typ provides a fundamental timescale for the mobility pattern in the PRoPHET scenario where the protocol is being applied. It represents the typical or mean time interval between encounters between a given pair of nodes in the normal course of mobility. The interval should reflect the \"logical\" time between encounters and should not give significant weight to multiple connection events as explained in Section 2.1.2. This time interval informs the settings of many of the other parameters but is not necessarily directly used as a parameter. Consideration needs to be given to the higher statistical moments (e.g., standard deviation) as well as the mean (first moment) of the distribution of intervals between encounters and the nature of that distribution (e.g., how close to a normal distribution it is). There is further discussion of this point later in this section and in Appendix C.",
      "ja": "I_typ I_typは、プロトコルが適用されている預言者のシナリオにおける移動パターンの基本的なタイムスケールを提供します。これは、移動度の通常の過程のノードの所与の対の間の出会いの間の典型的なまたは平均時間間隔を表します。間隔は、出会い間の「論理的」時間を反映すべきであり、2.1.2項で説明したように、複数の接続イベントに大きな重みを与えるべきではありません。この時間間隔は、他のパラメータの多くの設定を通知しますが、必ずしも直接パラメータとして使用されていません。考慮すべきことは出会いの間隔の分布とその分布の性質のより高い統計モーメント（例えば、標準偏差）、ならびに平均（一次モーメント）に付与する必要がある（例えば、それがどのように正規分布に近いです） 。この時点のさらなる議論は、このセクションで後述し、付録Cであり"
    },
    {
      "indent": 3,
      "text": "P_encounter_max P_encounter_max is used as the upper limit of a scaling factor that increases the delivery predictability for a destination when the destination node is encountered. A larger value of P_encounter_max will increase the delivery predictability faster, and fewer encounters will be required for the delivery predictability to reach a certain level. Given that relative rather than absolute delivery predictability values are what is interesting for the forwarding mechanisms defined, the protocol is very robust to different values of P_encounter as long as the same value is chosen for all nodes. The value should be chosen so that the increase in the delivery predictability resulting from using P_encounter_max in Equation 1 more than compensates for the decay of the delivery predictability resulting from Equation 3 with a time interval of I_typ.",
      "ja": "P_encounter_max P_encounter_maxは、宛先ノードに遭遇したときに先の配信予測可能性を増加させるスケーリング係数の上限として使用されます。 P_encounter_maxの大きな値は、より速い送達予測可能性を増加し、より少ない遭遇は、特定のレベルに到達するために配信予測のために必要とされるであろう。相対的ではなく絶対的な送達の予測値は、定義された転送メカニズムの興味深いものであることを考えると、プロトコルであれば同じ値がすべてのノードのために選択されているようにP_encounterの異なる値に対して非常にロバストです。値が選択されなければならないようにI_typの時間間隔で式（3）から得られた送達の予測の減衰を補償するよりも式1にP_encounter_maxを使用することから得られる送達予測の増加。"
    },
    {
      "indent": 3,
      "text": "P_encounter(intvl) As explained in Section 2.1.2, the parameter P_encounter used in Equation 1 is a function of the time interval \"intvl\". The function should be an approximation to",
      "ja": "P_encounter（INTVL）セクション2.1.2で説明したように、式（1）で使用されるパラメータP_encounterは、時間間隔「INTVL」の関数です。関数が近似する必要があります"
    },
    {
      "indent": 13,
      "text": "P_encounter(intvl) =\nP_encounter_max * (intvl / I_typ) for 0<= intvl <= I_typ\nP_encounter_max for intvl > I_typ",
      "raw": true
    },
    {
      "indent": 8,
      "text": "The function can be quantized and adapted to suit the mobility pattern and to make implementation easier. The overall effect should be that be that if Equation 1 is applied a number of times during a long-lived communication opportunity lasting I_typ, the overall increase in the delivery predictability should be approximately the same as if there had been two distinct encounters spaced I_typ apart. This second case would result in one application of Equation 1 using P_encounter_max.",
      "ja": "関数は、量子化とモビリティのパターンに合わせてと実装を容易にするために適合させることができます。全体的な効果は、式1 I_typ持続長寿命通信機会の間に数回適用される場合離れI_typ離間二つの別個の出会いがあったかのように、配信予測の全体的な増加は、ほぼ同じであるべきであるということでなければなりません。この第二の場合には、P_encounter_maxを用いて、式1の1つの適用をもたらします。"
    },
    {
      "indent": 3,
      "text": "P_first_threshold As described in Section 2.1.2, the delivery predictability for a destination is gradually reduced over time unless increased as a result of direct encounters or through the transitive property. If the delivery predictability falls below the value P_first_threshold, then the node MAY discard the delivery predictability information for the destination and treat subsequent encounters as if they had never encountered the node previously. This allows the node to reduce the storage needed for delivery predictabilities and decreases the amount of information that has to be exchanged between nodes; otherwise, the reduction algorithm would result in very small but non-zero predictabilities being maintained for nodes that were last encountered a long time ago.",
      "ja": "P_first_thresholdセクション2.1.2で説明したように直接遭遇の結果として、または、推移プロパティを介して増加しない限り、先の配信予測は、時間の経過とともに徐々に減少します。配信予測値P_first_thresholdを下回った場合、そのノードは、宛先の配信予測情報を捨てるかもしれ、彼らが以前にノードに遭遇したことがなかったかのように、後続の出会いを扱います。これは、ノードは、配信予測精度のために必要なストレージを削減することを可能にし、ノード間で交換されなければならない情報の量を減少させます。それ以外の場合は、縮小アルゴリズムは非常に小さいがゼロで予測精度が最後に長い時間前に発生したノードのために維持されていることになります。"
    },
    {
      "indent": 3,
      "text": "P_encounter_first As described in Section 2.1.2, PRoPHET does not, by default, make any assumptions about the likelihood that an encountered node will be encountered repeatedly in the future or, alternatively, that this is a one-off chance encounter that is unlikely to be repeated. During an encounter where the encountering node has no delivery predictability information for the encountered destination node, either because this is really the first encounter between the nodes or because the previous encounter was so long ago that the predictability had fallen below P_first_threshold and therefore had been discarded, the encountering node sets the delivery predictability for the destination node to P_encounter_first. The suggested value for P_encounter_first is 0.5: this value is RECOMMENDED as appropriate in the usual case where PRoPHET has no extra (e.g., out-of-band) information about whether future encounters with this node will be regular or otherwise.",
      "ja": "P_encounter_first 2.1.2項で説明したように、預言者は、デフォルトでは、遭遇したノードは、これがすることはほとんどありません一回限りの偶然の出会いであること、あるいは、将来的に繰り返し遭遇したりされる可能性についての仮定をしていません繰り返されます。遭遇したノードに遭遇宛先ノードのための送達の予測情報を有していない、いずれかの遭遇時、これは、ノード間または前の出会いは予測がP_first_threshold下回っていた、従って廃棄されたことを少し前だったので、最初の出会いは本当にあるため、遭遇ノードはP_encounter_firstに宛先ノードの配信予測を設定します。 P_encounter_firstの推奨値は0.5である。この値は預言者は、このノードとの将来の遭遇は、規則的または他の方法であろうかどうかについての余分（例えば、アウト・オブ・バンド）の情報を有していない通常の場合に適切として推奨されています。"
    },
    {
      "indent": 3,
      "text": "alpha The alpha parameter is used in the optional smoothing of the delivery predictabilities described in Section 2.1.3.1. It is used to determine the weight of the most current P-value in the calculation of an EWMA.",
      "ja": "アルファアルファパラメータは、セクション2.1.3.1に記載の送達予測精度の任意の平滑化に使用されます。 EWMAの計算の中で最も現在のP値の重みを決定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "beta The beta parameter adjusts the weight of the transitive property of PRoPHET, that is, how much consideration should be given to information about destinations that is received from encountered nodes. If beta is set to zero, the transitive property of PRoPHET will not be active, and only direct encounters will be used in the calculation of the delivery predictability. The higher the value of beta, the more rapidly encounters will increase predictabilities through the transitive rule.",
      "ja": "ベータ版のベータパラメータが発生したノードから受信した目的地の情報に与えられるべきであるどのくらいの配慮、ある預言者の推移財産の重量を調整します。ベータがゼロに設定されている場合は、預言者の推移プロパティがアクティブになりません、とだけ直接遭遇は、配信予測の計算に使用されます。ベータの値が高いほど、より急速に推移ルールによって予測精度が向上します遭遇します。"
    },
    {
      "indent": 3,
      "text": "gamma The gamma parameter determines how quickly delivery predictabilities age. A lower value of gamma will cause the delivery predictability to age faster. The value of gamma should be chosen according to the scenario and environment in which the protocol will be used. If encounters are expected to be very frequent, a lower value should be chosen for gamma than if encounters are expected to be rare.",
      "ja": "ガンマガンマパラメータがどのように迅速に配信予測精度の年齢を決定します。ガンマの低い値は、より速く、年齢に配信予測可能性を引き起こします。ガンマの値は、プロトコルが使用されるシナリオや環境に応じて選択されるべきです。遭遇が非常に頻繁であることが予想される場合、より低い値は、遭遇が稀であると予想される場合よりもガンマのために選択されるべきです。"
    },
    {
      "indent": 3,
      "text": "delta The delta parameter sets the maximum value of the delivery predictability for a destination other than for the node itself (i.e., P_(A,B) for all cases except P_(A,A)) as (1 - delta). Delta should be set to a small value to allow the maximum possible range for predictabilities but can be configured to make the calculation efficient if needed.",
      "ja": "デルタデルタパラメータが（P_（A、A）を除くすべての場合について、すなわち、P_（A、B））ノード自体以外の宛先のための送達予測の最大値を設定する（1  - デルタ）として。デルタは、予測精度の最大の可能な範囲を許可するように小さな値に設定する必要がありますが、必要に応じて計算を効率的にするように構成することができます。"
    },
    {
      "indent": 3,
      "text": "To set an appropriate gamma value, one should consider the \"average expected delivery\" time I_aed in the PRoPHET zone where the protocol is to be used, and the time unit used (the resolution with which the delivery predictability is being updated). The I_aed time interval can be estimated according to the average number of hops that bundles have to pass and the average interval between encounters I_typ. Clearly, if bundles have a Time To Live (TTL), i.e., the time left until the expiry time stored in the bundle occurs, that is less than I_aed, they are unlikely to survive in the network to be delivered to a node in this PRoPHET zone. However, the TTL for bundles created in nodes in this zone should not be chosen solely on this basis because they may pass through other networks.",
      "ja": "適切なガンマ値を設定するためには、プロトコルが使用される預言者ゾーン、および使用される時間単位（配信予測が更新されていると解像度）にI_aed「平均予想配達」時間を考慮すべきです。 I_aed時間間隔は束が通過しなければならないホップの平均数と遭遇I_typの平均間隔に応じて推定することができます。明らかに、バンドルがすなわち（TTL）、バンドルに保存されている有効期限が発生するまでの残り時間を生きて時間を持っている場合、それはI_aed未満である、彼らはこの中のノードに配信されるようにネットワークの中で生き残る可能性は低いです預言者ゾーン。彼らは他のネットワークを通過することができるので、このゾーン内のノードで作成されたバンドルのTTLは、単にこれに基づいて選択されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "After estimating I_aed and selecting how much we want the delivery predictability to age in one I_aed time period (call this A), we can calculate K, the number of time units in one I_aed, using K = (I_aed / time unit). This can then be used to calculate gamma as gamma = K'th-root( A ).",
      "ja": "I_aedを推定し、我々は1つのI_aed期間（このAを呼び出す）で、年齢に配信予測をしたいどのくらい選択した後、我々はK =（I_aed /時間単位）を使用して、K、1 I_aedで時間単位の数を計算することができます。これは次にガンマ= K番目ルート（A）のようにガンマを計算するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "I_typ, I_aed, K, and gamma can then be used to inform the settings of P_encounter_first, P_encounter_max, P_first_threshold, delta, and the detailed form of the function P_encounter(intvl).",
      "ja": "I_typ、I_aed、K、およびガンマは、次いでP_encounter_first、P_encounter_max、P_first_threshold、デルタの設定、および機能P_encounter（INTVL）の詳細な形態を通知するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "First, considering the evolution of the delivery predictability P_(A,B) after a single encounter between nodes A and B, P_(A,B) is initially set to P_encounter_first and will then steadily decay until it reaches P_first_threshold. The ratio between P_encounter_first and P_first_threshold should be set so that P_first_threshold is reached after a small multiple (e.g., 3 to 5) of I_aed has elapsed, making it likely that any subsequent encounter between the nodes would have occurred before P_(A,B) decays below P_first_threshold. If the statistics of the distribution of times between encounters is known, then a small multiple of the standard deviation of the distribution would be a possible period instead of using a multiple of I_aed.",
      "ja": "それはP_first_thresholdに達するまで、第1、ノードAとBとの間の単一の遭遇後に配信予測のP_（A、B）の進化を考慮して、P_（A、B）を最初P_encounter_firstに設定されます、その後着実に減衰。 P_first_thresholdが経過した小さな複数（例えば、3〜5）I_aedの後に到達されるようP_encounter_firstとP_first_threshold間の比は、ノード間のその後の遭遇がP_前に発生したであろう可能性が高いそれを作る、設定されるべきである（A、B） P_first_threshold下に減衰します。遭遇の間の時間の分布の統計が既知である場合、分布の標準偏差の小さい複数代わりI_aedの複数の使用可能期間であろう。"
    },
    {
      "indent": 3,
      "text": "Second, if a second encounter between A and B occurs, the setting of P_encounter_max should be sufficiently high to reverse the decay that would have occurred during I_typ and to increase P_(A,B) above the value of P_encounter_first. After several further encounters,",
      "ja": "AとBとの間の第二の遭遇が発生した場合には、第2、P_encounter_maxの設定がI_typ中に発生したであろう崩壊を逆にし、P_encounter_firstの値以上P_（A、B）を増加させるために十分に高くなければなりません。いくつかの更なる出会いの後、"
    },
    {
      "indent": 3,
      "text": "P_(A,B) will reach (1 - delta), its upper limit. As with setting up P_first_threshold, P_encounter_max should be set so that the upper limit is reached after a small number of encounters spaced apart by I_typ have occurred, but this should generally be more than 2 or 3.",
      "ja": "、 - （デルタ1）の上限をP_（A、B）が到達します。 P_first_thresholdの設定と同様に、P_encounter_maxは上限がI_typによって離間遭遇の少数が発生した後に到達するように設定する必要があり、これは一般的に2つ以上または3であるべきです。"
    },
    {
      "indent": 3,
      "text": "Finally, beta can be chosen to give some smoothing of the influence of transitivity.",
      "ja": "最後に、ベータ版は推移性の影響のいくつかの平滑化を与えるように選択することができます。"
    },
    {
      "indent": 3,
      "text": "These instructions on how to set the parameters are only given as a possible method for selecting appropriate values, but network operators are free to set parameters as they choose. Appendix C goes into some more detail on linking the parameters defined here and the more conventional ways of expressing the mobility model in terms of distributions of times between events of various types.",
      "ja": "パラメータを設定する方法についてこれらの命令は、唯一の適切な値を選択するための可能な方法として与えられたが、ネットワークオペレータは、彼らが選択したようにパラメータを設定するのは自由ですしています。付録Cは、ここで定義されたパラメータと、様々なタイプのイベント間の時間の分布の観点からモビリティモデルを表現するより、従来の方法をリンクにもう少し詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "Recommended starting parameter values when specific network measurements have not been done are below. Note: There are no \"one size fits all\" default values, and the ideal values vary based on network characteristics. It is not inherently necessary for the parameter values to be identical at all nodes, but it is recommended that similar values are used at all nodes within a PRoPHET zone as discussed in Section 2.1.2.1.",
      "ja": "特定のネットワーク測定が行われていない場合、パラメータ値を開始推奨は以下の通りです。注意：デフォルト値「1つのサイズはすべてに適合しない」と、理想的な値は、ネットワークの特性に基づいて異なる場合があります。パラメータ値は全ノードで同一であることが本質的に必要ではないが、それは、セクション2.1.2.1で論じたように同様の値がPROPHETゾーン内のすべてのノードで使用することが推奨されます。"
    },
    {
      "indent": 5,
      "text": "+========================================+\n|      Parameter     | Recommended value |\n+========================================+\n|   P_encounter_max  |       0.7         |\n+----------------------------------------+\n|  P_encounter_first |       0.5         |\n+----------------------------------------+\n|  P_first_threshold |       0.1         |\n+----------------------------------------+\n|        alpha       |       0.5         |\n+----------------------------------------+\n|        beta        |       0.9         |\n+----------------------------------------+\n|        gamma       |       0.999       |\n+----------------------------------------+\n|        delta       |       0.01        |\n+========================================+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 3: Default parameter settings",
      "ja": "図3：デフォルトのパラメータ設定"
    },
    {
      "indent": 0,
      "text": "3.4. Bundle Passing",
      "section_title": true,
      "ja": "3.4。バンドルを渡します"
    },
    {
      "indent": 3,
      "text": "Upon reception of the Bundle Offer TLV, the node inspects the list of bundles and decides which bundles it is willing to store for future forwarding or that it is able to deliver to their destinations. This decision has to be made using local policies and considering parameters such as available buffer space and, if the node requested bundle lengths, the lengths of the offered bundles. For each such acceptable bundle, the node sends a Bundle Response TLV to its peering node, which responds by sending the requested bundle. If a node has some bundles it would prefer to receive ahead of others offered (e.g., bundles that it can deliver to their final destination), it MAY request the bundles in that priority order. This is often desirable as there is no guarantee that the nodes will remain in contact with each other for long enough to transfer all the acceptable bundles. Otherwise, the node SHOULD assume that the bundles are listed in a priority order determined by the peering node's forwarding strategy and request bundles in that order.",
      "ja": "バンドルオファーTLVを受信すると、ノードは、バンドルのリストを検査し、将来の転送のために保管して喜んでいるか、彼らの目的地に届けることが可能であることをバンドルしていることを決定します。この決定は、ノードは、バンドルの長さ、提供するバンドルの長さを要求した場合、ローカルポリシーを使用し、使用可能なバッファ・スペースなどのパラメータを考慮して行われる必要があります。各そのような許容されるバンドルのため、ノードは、要求されたバンドルを送信することによって応答そのピアリングノードにバンドル応答TLVを送信します。ノードが（例えば、それが最終的な宛先に届けることができるバンドル）は、先に提供される他の受け取ることを好むであろういくつかの束を持っている場合、その優先順位にバンドルを要求することができます。ノードはすべて許容バンドルを転送するのに十分な長さのためにお互いに接触したままになる保証はありません、これはしばしば望ましいです。そうでない場合、ノードは、バンドルがその順にピアリングノードの転送戦略と要求束によって決定さ優先順にリストされていると仮定すべきです。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Custody",
      "section_title": true,
      "ja": "3.4.1。親権"
    },
    {
      "indent": 3,
      "text": "To free up local resources, a node may give custody of a bundle to another node that offers custody. This is done to move the retransmission requirement further toward the destination. The concept of custody transfer, and more details on the motivation for its use can be found in [RFC4838]. PRoPHET takes no responsibilities for making custody decisions. Such decisions should be made by a higher layer.",
      "ja": "ローカルリソースを解放するために、ノードは、親権を提供しています別のノードにバンドルの親権を与えることができます。これは、先に向かって、さらに再送要求を移動するために行われます。その使用のために保管転送の概念、そしてモチベーションの詳細については、[RFC4838]で見つけることができます。預言者は、親権の意思決定を行うためにはその責任を負いません。このような決定は、上位層によってなされるべきです。"
    },
    {
      "indent": 0,
      "text": "3.5. When a Bundle Reaches Its Destination",
      "section_title": true,
      "ja": "3.5。バンドルには、宛先に到達すると"
    },
    {
      "indent": 3,
      "text": "A PRoPHET ACK is only a confirmation that a bundle has been delivered to its destination in the PRoPHET zone (within the part of the network where PRoPHET is used for routing, bundles might traverse several different types of networks using different routing protocols; thus, this might not be the final destination of the bundle). When nodes exchange Bundle Offer TLVs, bundles that have been ACKed are also listed, having the \"PRoPHET ACK\" flag set. The node that receives this list updates its own list of ACKed bundles to be the union of its previous list and the received list. To prevent the list of ACKed bundles growing indefinitely, each PRoPHET ACK should have a timeout that MUST NOT be longer than the timeout of the bundle to which the ACK corresponds.",
      "ja": "PROPHET ACKは、バンドルが異なるルーティングプロトコルを使用するネットワークのいくつかの異なるタイプを横切るかもしれ束が預言者をルーティングするために使用されるネットワークの一部内（預言者ゾーンにその宛先に配信されたことのみ確認され、従って、この）バンドルの最終目的地ではないかもしれません。ノードがバンドルオファーTLVを交換する場合、ACKされたバンドルは、「預言者ACK」フラグのセットを有する、記載されています。このリストを受信したノードは、その前のリストの和集合し、受信したリストではACKさバンドルの独自のリストを更新します。無限に成長しているバンドルACKさのリストを防ぐために、それぞれの預言者ACKはACKが対応するバンドルのタイムアウトよりも長くてはならないタイムアウトを持つべきです。"
    },
    {
      "indent": 3,
      "text": "When a node receives a PRoPHET ACK for a bundle it is carrying, it MAY delete that bundle from its storage, unless the node holds custody of that bundle. The PRoPHET ACK only indicates that a bundle has been delivered to its destination within the PRoPHET zone, so the reception of a PRoPHET ACK is not a guarantee that the bundle has been delivered to its final destination.",
      "ja": "ノードは、それが運んでいるバンドルの預言者ACKを受信すると、ノードは、そのバンドルの親権を保持していない限り、それは、そのストレージからそのバンドルを削除する場合があります。 PROPHET ACKのみバンドルがPROPHETゾーン内にその宛先に配信されたことを示すので、預言者ACKの受信は、バンドルがその最終的な宛先に配信されたことを保証するものではありません。"
    },
    {
      "indent": 3,
      "text": "Nodes MAY track to which nodes they have sent PRoPHET ACKs for certain bundles, and MAY in that case refrain from sending multiple PRoPHET ACKs for the same bundle to the same node.",
      "ja": "ノードが同じノードに同一のバンドルに複数PROPHET ACKを送信し、その場合のリフレイン、それらは特定のバンドルのための預言者ACKを送信したノードた追跡、及びてもよいです。"
    },
    {
      "indent": 3,
      "text": "If necessary in order to preserve system resources, nodes MAY drop PRoPHET ACKs prematurely but SHOULD refrain from doing so if possible.",
      "ja": "必要に応じてシステムリソースを維持するためには、ノードが早まっ預言者ACKを落とすかもしれませんが、可能であればそうすることを控えるべきです。"
    },
    {
      "indent": 3,
      "text": "It is important to keep in mind that PRoPHET ACKs and bundle ACKs [RFC5050] are different things. PRoPHET ACKs are only valid within the PRoPHET part of the network, while bundle ACKs are end-to-end acknowledgments that may go outside of the PRoPHET zone.",
      "ja": "預言者ACKおよびバンドルのACK [RFC5050]は異なるものであることを心に留めておくことが重要です。バンドルACKが預言者ゾーンの外に出て、エンドツーエンドの承認されている間、預言者ACKは、ネットワークの預言者の一部内でのみ有効です。"
    },
    {
      "indent": 0,
      "text": "3.6. Forwarding Strategies",
      "section_title": true,
      "ja": "3.6。戦略を転送"
    },
    {
      "indent": 3,
      "text": "During the Information Exchange Phase, nodes need to decide on which bundles they wish to exchange with the peering node. Because of the large number of scenarios and environments that PRoPHET can be used in, and because of the wide range of devices that may be used, it is not certain that this decision will be based on the same strategy in every case. Therefore, each node MUST operate a _forwarding strategy_ to make this decision. Nodes may define their own strategies, but this section defines a few basic forwarding strategies that nodes can use. Note: If the node being encountered is the destination of any of the bundles being carried, those bundles SHOULD be offered to the destination, even if that would violate the forwarding strategy. Some of the forwarding strategies listed here have been evaluated (together with a number of queueing policies) through simulations, and more information about that and recommendations on which strategies to use in different situations can be found in [lindgren_06]. If not chosen differently due to the characteristics of the deployment scenario, nodes SHOULD choose GRTR as the default forwarding strategy.",
      "ja": "情報交換フェーズの間に、ノードは、彼らがピアリングノードと交換したいバンドルを決定する必要があります。預言者で使用することができるシナリオ及び環境の多数のために、及びために使用することができるデバイスの広い範囲は、この決定は、すべての場合において、同じ戦略に基づくであろうことは確かではありません。そのため、各ノードは、この決定を行う_forwardingのstrategy_を操作しなければなりません。ノードは、独自の戦略を定義することができますが、このセクションでは、ノードが使用することができますいくつかの基本的な転送戦略を定義します。注意：遭遇しているノードが搭載されているバンドルのいずれかの目的地である場合には、これらのバンドルはそれが転送戦略に違反する場合でも、先に提供されるべきです。ここに記載されている転送戦略のいくつかはそれと戦略が[lindgren_06]で見つけることができ、さまざまな状況で、使用する上での推奨事項についてシミュレーションにより、多くの情報（一緒にキューイングポリシーの数で）評価されています。展開シナリオの特性とは異なって選択されていない場合は、ノードは、デフォルトの転送戦略としてGRTRを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "The short names applied to the forwarding strategies should be read as mnemonic handles rather than as specific acronyms for any set of words in the specification.",
      "ja": "転送戦略に適用される短い名前は、ニーモニックのハンドルではなく、仕様の単語の任意のセットのためのような特定の頭字語として読まれるべきです。"
    },
    {
      "indent": 3,
      "text": "We use the following notation in our descriptions below. A and B are the nodes that encounter each other, and the strategies are described as they would be applied by node A. The destination node is D. P_(X,Y) denotes the delivery predictability stored at node X for destination Y, and NF is the number of times node A has given the bundle to some other node.",
      "ja": "当社は、下記の私たちの説明に次の表記を使用します。 AとBが互いに遭遇するノードであり、および戦略は、それらがノードAによって適用されるように、宛先ノードは、D. P_（X、Y）で説明した先YのノードXに格納された配信の予測であり、さNFは、ノードAが他のノードにバンドルを与えた回数です。"
    },
    {
      "indent": 3,
      "text": "GRTR Forward the bundle only if P_(B,D) > P_(A,D).",
      "ja": "GRTRフォワード束のみならP_（B、D）> P_（A、D）。"
    },
    {
      "indent": 8,
      "text": "When two nodes meet, a bundle is sent to the other node if the\ndelivery predictability of the destination of the bundle is\nhigher at the other node.  The first node does not delete the\nbundle after sending it as long as there is sufficient buffer\nspace available (since it might encounter a better node, or even\nthe final destination of the bundle in the future).",
      "raw": true
    },
    {
      "indent": 3,
      "text": "GTMX Forward the bundle only if P_(B,D) > P_(A,D) && NF < NF_max.",
      "ja": "GTMXフォワード束のみならP_（B、D）> P_（A、D）&& NF <NF_max。"
    },
    {
      "indent": 8,
      "text": "This strategy is like the previous one, but each bundle is given\nto at most NF_max other nodes in addition to the destination.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "GTHR Forward the bundle only if P_(B,D) > P_(A,D) OR P_(B,D) > FORW_thres, where FORW_thres is a threshold value above which a bundle should always be given to the node unless it is already present at the other node.",
      "ja": "GTHR前方のみFORW_thresは、それが既にない限り束が常にノードに与えられるべき上方閾値であるP_（B、D）> P_（A、D）OR P_（B、D）> FORW_thres、もしバンドル他のノードに存在します。"
    },
    {
      "indent": 8,
      "text": "This strategy is similar to GRTR, but among nodes with very high\ndelivery predictability, bundles for that particular destination\nare spread epidemically.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "GRTR+ Forward the bundle only if Equation 5 holds, where P_max is the largest delivery predictability reported by a node to which the bundle has been sent so far.",
      "ja": "GRTR +フォワードP_MAXは、バンドルがこれまでに送られてきているノードによって報告された最大の配信予測可能である式（5）が成立する場合にのみバンドル、。"
    },
    {
      "indent": 13,
      "text": "P_(B,D) > P_(A,D) && P_(B,D) > P_max (Eq. 5)",
      "ja": "P_（B、D）> P_（A、D）&& P_（B、D）> P_MAX（式5）"
    },
    {
      "indent": 8,
      "text": "This strategy is like GRTR, but each node forwarding a bundle keeps track of the largest delivery predictability of any node it has forwarded this bundle to, and only forwards the bundle again if the currently encountered node has a greater delivery predictability than the maximum previously encountered.",
      "ja": "この戦略はGRTRに似ているが、バンドルを転送する各ノードは、それがこのバンドルを転送した任意のノードの最大の配信予測を追跡し、現在遭遇したノードは、以前に遭遇した最大値よりも大きい配信予測可能性を持っている場合のみ、再バンドルを転送します。"
    },
    {
      "indent": 3,
      "text": "GTMX+ Forward the bundle only if Equation 6 holds.",
      "ja": "GTMX +は、式6が保持している場合にのみバンドルを転送します。"
    },
    {
      "indent": 12,
      "text": "P_(B,D) > P_(A,D) && P_(B,D) > P_max && NF < NF_max (Eq. 6)",
      "ja": "P_（B、D）> P_（A、D）&& P_（B、D）> P_MAX && NF <NF_max（式6）"
    },
    {
      "indent": 8,
      "text": "This strategy is like GTMX, but nodes keep track of P_max as in GRTR+.",
      "ja": "この戦略はGTMX似ていますが、ノードはGRTR +のようにP_MAXを追跡します。"
    },
    {
      "indent": 3,
      "text": "GRTRSort Select bundles in descending order of the value of P_(B,D) - P_(A,D). Forward the bundle only if P_(B,D) > P_(A,D).",
      "ja": "P_（B、D）の値の降順にGRTRSort選択バンドル -  P_（A、D）。バンドルを転送する場合にのみP_（B、D）> P_（A、D）。"
    },
    {
      "indent": 8,
      "text": "This strategy is like GRTR, but instead of just going through\nthe bundle queue linearly, this strategy looks at the difference\nin delivery predictabilities for each bundle between the two\nnodes and forwards the bundles with the largest difference\nfirst.  As bandwidth limitations or disrupted connections may\nresult in not all bundles that would be desirable being\nexchanged, it could be desirable to first send bundles that get\na large improvement in delivery predictability.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "GRTRMax Select bundles in descending order of P_(B,D). Forward the bundle only if P_(B,D) > P_(A,D).",
      "ja": "P_（B、D）の順にGRTRMax選択バンドル。バンドルを転送する場合にのみP_（B、D）> P_（A、D）。"
    },
    {
      "indent": 8,
      "text": "This strategy begins by considering the bundles for which the\nencountered node has the highest delivery predictability.  The\nmotivation for doing this is the same as in GRTRSort, but based\non the idea that it is better to give bundles to nodes with high\nabsolute delivery predictabilities, instead of trying to\nmaximize the improvement.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.7. Queueing Policies",
      "section_title": true,
      "ja": "3.7。キューイングポリシー"
    },
    {
      "indent": 3,
      "text": "Because of limited buffer resources, nodes may need to drop some bundles. As is the case with the forwarding strategies, which bundle to drop is also dependent on the scenario. Therefore, each node MUST also operate a queueing policy that determines how its bundle queue is handled. This section defines a few basic queueing policies, but nodes MAY use other policies if desired. Some of the queueing policies listed here have been evaluated (together with a number of forwarding strategies) through simulations. More information about that and recommendations on which policies to use in different situations can be found in [lindgren_06]. If not chosen differently due to the characteristics of the deployment scenario, nodes SHOULD choose FIFO as the default queueing policy.",
      "ja": "そのため限られたバッファ資源の、ノードは、いくつかのバンドルをドロップする必要があるかもしれません。ドロップするバンドル転送戦略と同様に、また、シナリオに依存しています。したがって、各ノードは、そのバンドルキューが処理される方法を決定するキューイングポリシーを操作しなければなりません。このセクションでは、いくつかの基本的なキューイングポリシーを定義しますが、必要に応じてノードは、他のポリシーを使用するかもしれません。ここに記載されているキューイングポリシーの一部は、シミュレーションを通じて（一緒に転送戦略の数で）評価されています。それと異なる状況で使用する政策に関する提言についての詳しい情報は[lindgren_06]で見つけることができます。展開シナリオの特性とは異なって選択されていない場合は、ノードは、デフォルトのキューイングポリシーとしてFIFOを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "The short names applied to the queueing policies should be read as mnemonic handles rather than as specific acronyms for any set of words in the specification.",
      "ja": "キューイングポリシーに適用される短い名前は、ニーモニックのハンドルではなく、仕様の単語の任意のセットのためのような特定の頭字語として読まれるべきです。"
    },
    {
      "indent": 3,
      "text": "FIFO - First In First Out. The bundle that was first entered into the queue is the first bundle to be dropped.",
      "ja": "先入れ先出し -  FIFO。最初のキューに入力されたバンドルがドロップされた最初のバンドルです。"
    },
    {
      "indent": 3,
      "text": "MOFO - Evict most forwarded first. In an attempt to maximize the delivery rate of bundles, this policy requires that the routing agent keep track of the number of times each bundle has been forwarded to some other node. The bundle that has been forwarded the largest number of times is the first to be dropped.",
      "ja": "MOFO  - 最も最初に転送立ち退かせます。バンドルの送達速度を最大にする試みにおいて、このポリシーは、ルーティングエージェントは、各バンドルが他のノードに転送された回数を追跡することを必要とします。回数の最大数を転送されたバンドルがドロップされる最初です。"
    },
    {
      "indent": 3,
      "text": "MOPR - Evict most favorably forwarded first. Keep a variable FAV for each bundle in the queue, initialized to zero. Each time the bundle is forwarded, update FAV according to Equation 7, where P is the predictability metric that the node the bundle is forwarded to has for its destination.",
      "ja": "MOPR  - 立ち退かせるには、最も好ましく最初に転送されます。ゼロに初期化、キュー内の各バンドルの変数FAVを保管してください。バンドルが転送されるたびに、Pノードはバンドルが転送されることが予測メトリックである式（7）に記載のFAVを更新するために、その宛先のために有しています。"
    },
    {
      "indent": 13,
      "text": "FAV_new = FAV_old + ( 1 - FAV_old ) * P (Eq. 7)",
      "ja": "FAV_new = FAV_old +（1  -  FAV_old）* P（式7）。"
    },
    {
      "indent": 8,
      "text": "The bundle with the highest FAV value is the first to be dropped.",
      "ja": "最高FAV値とのバンドルがドロップされる最初です。"
    },
    {
      "indent": 3,
      "text": "Linear MOPR - Evict most favorably forwarded first; linear increase. Keep a variable FAV for each bundle in the queue, initialized to zero. Each time the bundle is forwarded, update FAV according to Equation 8, where P is the predictability metric that the node the bundle is forwarded to has for its destination.",
      "ja": "リニアMOPR  - 立ち退か最も好意的に最初に転送。直線的に増加。ゼロに初期化、キュー内の各バンドルの変数FAVを保管してください。バンドルが転送されるたびに、Pノードはバンドルが転送されることが予測メトリックである式（8）に記載のFAVを更新するために、その宛先のために有しています。"
    },
    {
      "indent": 13,
      "text": "FAV_new = FAV_old + P (Eq. 8)",
      "ja": "FAV_new = FAV_old + P（式8）"
    },
    {
      "indent": 8,
      "text": "The bundle with the highest FAV value is the first to be dropped.",
      "ja": "最高FAV値とのバンドルがドロップされる最初です。"
    },
    {
      "indent": 3,
      "text": "SHLI - Evict shortest life time first. As described in [RFC5050], each bundle has a timeout value specifying when it no longer is meaningful to its application and should be deleted. Since bundles with short remaining Time To Live will soon be dropped anyway, this policy decides to drop the bundle with the shortest remaining lifetime first. To successfully use a policy like this, there needs to be some form of time synchronization between nodes so that it is possible to know the exact lifetimes of bundles. However, this is not specific to this routing protocol, but a more general DTN problem.",
      "ja": "SHLI  - 最初の最短寿命を立ち退かせます。 [RFC5050]に記載されているように、各バンドルは、それがもはやそのアプリケーションにとって意味のある、削除されるべきであるときを指定しないタイムアウト値を有しています。存続短い残り時間とのバンドルはすぐにとにかく削除されますので、このポリシーは、最初の最短残りの寿命を持つバンドルをドロップすることを決定します。正常にこのようなポリシーを使用するには、バンドルの正確な寿命を知ることができるように、ノード間の時刻同期のいくつかのフォームが必要です。しかし、これは、このルーティングプロトコルに固有ではなく、より一般的なDTNの問題。"
    },
    {
      "indent": 3,
      "text": "LEPR - Evict least probable first. Since the node is least likely to deliver a bundle for which it has a low delivery predictability, drop the bundle for which the node has the lowest delivery predictability, and that has been forwarded at least MF times, where MF is a minimum number of forwards that a bundle must have been forwarded before being dropped (if such a bundle exists).",
      "ja": "LEPR  - 劣勢最初を立ち退かせます。ノードは、ノードが最も低い送達予測可能性を持っているバンドルを落とし、それが低い配信予測可能性を持っているバンドルを送達する最も可能性があり、それはMFが前方の最小数である少なくともMF回、転送されたので（そのようなバンドルが存在する場合）、そのバンドルがドロップされる前に転送されている必要があります。"
    },
    {
      "indent": 3,
      "text": "More than one queueing policy MAY be combined in an ordered set, where the first policy is used primarily, the second only being used if there is a need to tie-break between bundles given the same eviction priority by the primary policy, and so on. As an example, one could select the queueing policy to be {MOFO; SHLI; FIFO}, which would start by dropping the bundle that has been forwarded the largest number of times. If more than one bundle has been forwarded the same number of times, the one with the shortest remaining lifetime will be dropped, and if that also is the same, the FIFO policy will be used to drop the bundle first received.",
      "ja": "複数のキューイングポリシーがそうであり、一次ポリシーによって同じ追い出し優先束間ブレークを結ぶ必要がある場合、および第二にのみ使用され、最初のポリシーが主に使用される順序付けられたセットで組み合わせることができます。一例として、一つは{MOFOことがキューイングポリシーを選択することができます。 SHLI;回数の最大数を転送されたバンドルをドロップすることによって開始するFIFO}、。複数のバンドルが同じ回数だけ転送された場合、最短残り寿命を有するものは廃棄され、それも同じであれば、FIFOポリシーが最初に受信バンドルをドロップするために使用されます。"
    },
    {
      "indent": 3,
      "text": "It is worth noting that a node MUST NOT drop bundles for which it has custody unless the bundle's lifetime expires.",
      "ja": "これは、ノードがバンドルの有効期間が満了した場合を除き、それが親権を持っているの束を落としてはならないことは注目に値します。"
    },
    {
      "indent": 0,
      "text": "4. Message Formats",
      "section_title": true,
      "ja": "4.メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "This section defines the message formats of the PRoPHET routing protocol. In order to allow for variable-length fields, many numeric fields are encoded as Self-Delimiting Numeric Values (SDNVs). The format of SDNVs is defined in [RFC5050]. Since many of the fields are coded as SDNVs, the size and alignment of fields indicated in many of the specification diagrams below are indicative rather than prescriptive. Where SDNVs and/or text strings are used, the octets of the fields will be packed as closely as possible with no intervening padding between fields.",
      "ja": "このセクションでは、預言者のルーティングプロトコルのメッセージ・フォーマットを定義します。可変長フィールドを可能にするために、多くの数値フィールドは、自己区切り数値値（SDNVs）として符号化されます。 SDNVsのフォーマットは、[RFC5050]で定義されています。フィールドの多くはSDNVsとして符号化されるので、以下の明細書の図の多くに示されているフィールドのサイズ及び位置合わせではなく規範より示すものです。 SDNVsおよび/またはテキスト文字列を使用する場合、フィールドのオクテットは、フィールド間の介在しないパディングをできるだけ密接にパックされます。"
    },
    {
      "indent": 3,
      "text": "Explicit-length fields are specified for all variable-length string fields. Accordingly, strings are not null terminated and just contain the exact set of octets in the string.",
      "ja": "明示的な長さのフィールドは、すべての可変長文字列フィールドに指定されています。したがって、文字列はNULL終端ではなく、単なる文字列のオクテットの正確なセットが含まれています。"
    },
    {
      "indent": 3,
      "text": "The basic message format shown in Figure 4 consists of a header (see Section 4.1) followed by a sequence of one or more Type-Length-Value components (TLVs) taken from the specifications in Section 4.2.",
      "ja": "図4に示されている基本的なメッセージフォーマットはセクション4.2で仕様から採取した一つ以上のタイプレングス値コンポーネント（のTLV）のシーケンスが続くヘッダ（セクション4.1を参照）で構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                            Header                             ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                             TLV 1                             ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                .                              |\n~                                .                              ~\n|                                .                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                             TLV n                             ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 4: Basic PRoPHET Message Format",
      "ja": "図4：基本的な預言者メッセージ形式"
    },
    {
      "indent": 0,
      "text": "4.1. Header",
      "section_title": true,
      "ja": "4.1。ヘッダ"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Protocol Number|Version| Flags |     Result    |     Code      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Receiver Instance        |      Sender Instance          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Transaction Identifier                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|S|      SubMessage Number      |         Length (SDNV)         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                          Message Body                         ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 5: PRoPHET Message Header",
      "ja": "図5：PROPHETメッセージヘッダ"
    },
    {
      "indent": 3,
      "text": "Protocol Number The DTN Routing Protocol Number encoded as 8-bit unsigned integer in network bit order. The value of this field is 0. The PRoPHET header is organized in this way so that in principle PRoPHET messages could be sent as the Protocol Data Unit of an IP packet if an IP protocol number was allocated for PRoPHET.",
      "ja": "プロトコル番号DTNルーティングプロトコル番号は、ネットワークビット順に8ビットの符号なし整数として符号化されます。このフィールドの値は、IPプロトコル番号は預言者のために割り当てられた場合、原則として、預言者のメッセージ内のIPパケットのプロトコルデータユニットとして送信することができるように預言者ヘッダがこのように編成されている0です。"
    },
    {
      "indent": 8,
      "text": "At present, PRoPHET is only specified to use a TCP transport for\ncarriage of PRoPHET packets, so that the protocol number serves\nonly to identify the PRoPHET protocol within DTN.  Transmitting\nPRoPHET packets directly as an IP protocol on a public IP\nnetwork such as the Internet would generally not work well\nbecause middleboxes (such as firewalls and NAT boxes) would be\nunlikely to allow the protocol to pass through, and the protocol\ndoes not provide any congestion control.  However, it could be\nso used on private networks for experimentation or in situations\nwhere all communications are between isolated pairs of nodes.\nAlso, in the future, other protocols that require transmission\nof metadata between DTN nodes could potentially use the same\nformat and protocol state machinery but with a different\nProtocol Number.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Version The version of the PRoPHET Protocol. Encoded as a 4-bit unsigned integer in network bit order. This document defines version 2.",
      "ja": "バージョン預言者プロトコルのバージョン。ネットワークビット順に4ビットの符号なし整数として符号化されます。このドキュメントでは、バージョン2を定義します。"
    },
    {
      "indent": 3,
      "text": "Flags Reserved field of 4 bits.",
      "ja": "フラグは4ビットのフィールドを予約済み。"
    },
    {
      "indent": 3,
      "text": "Result Field that is used to indicate whether a response is required to the request message if the outcome is successful. A value of \"NoSuccessAck\" indicates that the request message does not expect a response if the outcome is successful, and a value of \"AckAll\" indicates that a response is expected if the outcome is successful. In both cases, a failure response MUST be generated if the request fails. If running over a TCP transport or similar protocol that offers reliable in order delivery, deployments MAY choose not to send \"Success\" responses when an outcome is successful. To achieve this, the Result field is set to the \"NoSuccessAck\" value in all request messages.",
      "ja": "結果が成功した場合、応答は要求メッセージに必要とされるかどうかを示すために使用された結果フィールド。 「NoSuccessAck」の値は、結果が成功した場合、要求メッセージは、応答を期待していないことを示し、「AckAll」の値は、結果が成功した場合、応答が期待されていることを示しています。要求が失敗した場合どちらの場合も、失敗応答を生成しなければなりません。 TCPトランスポートまたは注文配送に信頼性の高いを提供しています同様のプロトコル上で動作している場合、展開は結果が成功した場合、「成功」応答を送信しないこともできます。これを達成するために、結果フィールドは、すべての要求メッセージで「NoSuccessAck」の値に設定されています。"
    },
    {
      "indent": 8,
      "text": "In a response message, the result field can have two values:\n\"Success\" and \"Failure\".  The \"Success\" result indicates a\nsuccess response.  All messages that belong to the same success\nresponse will have the same Transaction Identifier.  The\n\"Success\" result indicates a success response that may be\ncontained in a single message or the final message of a success\nresponse spanning multiple messages.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "ReturnReceipt is a value of the result field used to indicate that an acknowledgement is required for the message. The default for messages is that the controller will not acknowledge responses. In the case where an acknowledgement is required, it will set the Result Field to ReturnReceipt in the header of the Message.",
      "ja": "RETURNRECEIPTは、肯定応答がメッセージのために必要とされることを示すために使用される結果フィールドの値です。メッセージのデフォルトでは、コントローラが応答を認めないということです。肯定応答が要求される場合には、メッセージのヘッダにRETURNRECEIPTに結果フィールドを設定します。"
    },
    {
      "indent": 8,
      "text": "The result field is encoded as an 8-bit unsigned integer in network bit order. The following values are currently defined:",
      "ja": "結果フィールドは、ネットワークビット順に8ビットの符号なし整数として符号化されます。次の値が現在定義されています："
    },
    {
      "indent": 11,
      "text": "NoSuccessAck: Result = 1 AckAll: Result = 2 Success: Result = 3 Failure: Result = 4 ReturnReceipt Result = 5",
      "ja": "NoSuccessAck：結果= 1 AckAll：結果= 2成功：結果= 3失敗：結果= 4 RETURNRECEIPT結果= 5"
    },
    {
      "indent": 3,
      "text": "Code This field gives further information concerning the result in a response message. It is mostly used to pass an error code in a failure response but can also be used to give further information in a success response message or an event message. In a request message, the code field is not used and is set to zero.",
      "ja": "コードこのフィールドは、応答メッセージで結果に関するさらなる情報を提供します。主に失敗応答のエラーコードを渡すために使用されるが、成功応答メッセージまたはイベントメッセージにさらなる情報を提供するために使用することができます。要求メッセージに、コードフィールドは使用されず、ゼロに設定されています。"
    },
    {
      "indent": 8,
      "text": "If the Code field indicates that the Error TLV is included in\nthe message, further information on the error will be found in\nthe Error TLV, which MUST be the first TLV after the header.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "The Code field is encoded as an 8-bit unsigned integer in network bit order. Separate number code spaces are used for success and failure response messages. In each case, a range of values is reserved for use in specifications and another range for private and experimental use. For success messages, the following values are defined:",
      "ja": "コードフィールドは、ネットワークビット順に8ビットの符号なし整数として符号化されます。個別の番号コードスペースは、成功と失敗応答メッセージに使用されています。それぞれの場合に、値の範囲は、仕様で使用し、プライベートと実験的使用のための別の範囲のために予約されています。成功のメッセージについては、次の値が定義されています。"
    },
    {
      "indent": 18,
      "text": "Generic Success                  0x00\nSubmessage Received              0x01\nUnassigned                   0x02 - 0x7F\nPrivate/Experimental Use     0x80 - 0xFF",
      "raw": true
    },
    {
      "indent": 8,
      "text": "The Submessage Received code is used to acknowledge reception of a message segment. The Generic Success code is used to acknowledge receipt of a complete message and successful processing of the contents.",
      "ja": "サブメッセージ受信されたコードは、メッセージ・セグメントの受信を肯定応答するために使用されます。一般的な成功コードが完全なメッセージと内容が正常に処理の受信を確認するために使用されます。"
    },
    {
      "indent": 8,
      "text": "For failure messages, the following values are defined:",
      "ja": "エラーメッセージについて、以下の値が定義されています。"
    },
    {
      "indent": 18,
      "text": "Reserved                     0x00 - 0x01\nUnspecified Failure              0x02\nUnassigned                   0x03 - 0x7F\nPrivate/Experimental Use     0x80 - 0xFE\nError TLV in message             0xFF",
      "raw": true
    },
    {
      "indent": 8,
      "text": "The Unspecified Failure code can be used to report a failure for which there is no more specific code or Error TLV value defined.",
      "ja": "未指定の障害コードはありません定義され、より具体的なコードやエラーTLV値が存在するために失敗したことを報告するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Sender Instance For messages during the Hello phase with the Hello SYN, Hello SYNACK, and Hello ACK functions (which are explained in Section 5.2), it is the sender's instance number for the link. It is used to detect when the link comes back up after going down or when the identity of the entity at the other end of the link changes. The instance number is a 16-bit number that is guaranteed to be unique within the recent past and to change when the link or node comes back up after going down. Zero is not a valid instance number. For the RSTACK function (also explained in detail in Section 5.2), the Sender Instance field is set to the value of the Receiver Instance field from the incoming message that caused the RSTACK function to be generated. Messages sent after the Hello phase is completed should use the sender's instance number for the link. The Sender Instance is encoded as a 16-bit unsigned integer in network bit order.",
      "ja": "こんにちはSYN、こんにちはSYNACK、および（5.2節で説明します）こんにちはACK機能付きのHelloフェーズの間のメッセージの送信者のインスタンスは、それがリンクの送信者のインスタンス番号です。リンクは、リンクの変更のもう一方の端に下って行くとき、またはエンティティのID後に戻ってくるときを検出するために使用されます。インスタンス番号は、最近の過去内で一意であること、およびリンクまたはノードがダウン後に戻ったときに変更することが保証されて16ビットの数値です。ゼロは有効なインスタンス番号ではありません。 RSTACK関数（また、セクション5.2で詳細に説明する）のために、送信者インスタンスフィールドはRSTACK関数が生成される原因となった着信メッセージから受信インスタンスのフィールドの値に設定されています。こんにちはフェーズが完了した後に送信されたメッセージは、リンクのために、送信者のインスタンス番号を使用する必要があります。 Senderのインスタンスは、ネットワークビット順に16ビットの符号なし整数として符号化されます。"
    },
    {
      "indent": 3,
      "text": "Receiver Instance For messages during the Hello phase with the Hello SYN, Hello SYNACK, and Hello ACK functions, it is what the sender believes is the current instance number for the link, allocated by the entity at the far end of the link. If the sender of the message does not know the current instance number at the far end of the link, this field MUST be set to zero. For the RSTACK message, the Receiver Instance field is set to the value of the Sender Instance field from the incoming message that caused the RSTACK message to be generated. Messages sent after the Hello phase is completed should use what the sender believes is the current instance number for the link, allocated by the entity at the far end of the link. The Sender Instance is encoded as a 16-bit unsigned integer in network bit order.",
      "ja": "こんにちはSYN、こんにちはSYNACK、およびこんにちはACK機能付きのHelloフェーズの間のメッセージのための受信機のインスタンスは、それが送信者がリンクの遠端でのエンティティによって割り当てられたリンクの現在のインスタンス番号、であると考えているものです。メッセージの送信者がリンクの遠端で、現在のインスタンス番号を知らない場合、このフィールドはゼロに設定しなければなりません。 RSTACKメッセージを、受信インスタンスフィールドはRSTACKメッセージが生成される原因となった受信メッセージから送信者インスタンスフィールドの値に設定されています。こんにちはフェーズが完了した後に送信されたメッセージは、送信者がリンクの遠端でのエンティティによって割り当てられたリンクの現在のインスタンス番号、であると考えているものを使用する必要があります。 Senderのインスタンスは、ネットワークビット順に16ビットの符号なし整数として符号化されます。"
    },
    {
      "indent": 3,
      "text": "Transaction Identifier Used to associate a message with its response message. This should be set in request messages to a value that is unique for the sending host within the recent past. Reply messages contain the Transaction Identifier of the request to which they are responding. The Transaction Identifier is a bit pattern of 32 bits.",
      "ja": "トランザクション識別子は、その応答メッセージとメッセージを関連付けるために使用します。これは最近の中、送信側ホストに固有の値に、要求メッセージに設定する必要があります。返信メッセージは、要求のトランザクション識別子は、それらが応答しているために含まれています。トランザクション識別子は、32ビットのビットパターンです。"
    },
    {
      "indent": 3,
      "text": "S-flag If S is set (value 1), then the SubMessage Number field indicates the total number of SubMessage segments that compose the entire message. If it is not set (value 0), then the SubMessage Number field indicates the sequence number of this SubMessage segment within the whole message. The S field will only be set in the first submessage of a sequence.",
      "ja": "SフラグSが（値1）に設定されている場合は、サブメッセージ番号フィールドは、メッセージ全体を構成するサブメッセージ・セグメントの総数を示します。それは（値0）に設定されていない場合は、サブメッセージ番号フィールドは、全体のメッセージ内のこのサブメッセージセグメントのシーケンス番号を示します。 Sフィールドは、配列のみの最初のサブメッセージに設定されます。"
    },
    {
      "indent": 3,
      "text": "SubMessage Number When a message is segmented because it exceeds the MTU of the link layer or otherwise, each segment will include a SubMessage Number to indicate its position. Alternatively, if it is the first submessage in a sequence of submessages, the S-flag will be set, and this field will contain the total count of SubMessage segments. The SubMessage Number is encoded as a 15-bit unsigned integer in network bit order. The SubMessage number is zero-based, i.e., for a message divided into n submessages, they are numbered from 0 to (n - 1). For a message that is not divided into submessages, the single message has the S-flag cleared (value 0), and the SubMessage Number is set to 0 (zero).",
      "ja": "それはリンクレイヤのMTUを超えているか、そうでないため、メッセージがセグメント化されたサブメッセージ番号場合、各セグメントは、その位置を示すためのサブメッセージ番号を含むであろう。それはサブメッセージのシーケンスの最初のサブメッセージである場合あるいは、S-flagが設定され、このフィールドは、サブメッセージ・セグメントの総数を含むであろう。サブメッセージ番号は、ネットワークビット順に15ビットの符号なし整数として符号化されます。サブメッセージ番号は、すなわち、n個のサブメッセージに分割メッセージを、それらが0から番号が付けられて、ゼロベースである（N  -  1）。サブメッセージに分割されていないメッセージのために、単一のメッセージをクリアSフラグ（値0）を有し、サブメッセージ番号は0（ゼロ）に設定されています。"
    },
    {
      "indent": 3,
      "text": "Length Length in octets of this message including headers and message body. If the message is fragmented, this field contains the length of this SubMessage. The Length is encoded as an SDNV.",
      "ja": "ヘッダとメッセージボディを含め、このメッセージのオクテット長の長さ。メッセージが断片化されている場合、このフィールドは、このサブメッセージの長さが含まれています。長さはSDNVとして符号化されます。"
    },
    {
      "indent": 3,
      "text": "Message Body As specified in Section 4, the Message Body consists of a sequence of one or more of the TLVs specified in Section 4.2.",
      "ja": "メッセージボディセクション4で規定されているように、メッセージ本文はセクション4.2で指定のTLVのうちの1つまたは複数の配列からなります。"
    },
    {
      "indent": 3,
      "text": "The protocol also requires extra information about the link that the underlying communication layer MUST provide. This information is used in the Hello procedure described in more detail in Section 5.2. Since this information is available from the underlying layer, there is no need to carry it in PRoPHET messages. The following values are defined to be provided by the underlying layer:",
      "ja": "また、このプロトコルは、基礎となる通信層を提供しなければならないリンクに関する追加情報が必要です。この情報は、5.2節で詳しく説明こんにちは手順で使用されています。この情報は、下地層から提供されていますので、預言者のメッセージにそれを運ぶ必要はありません。以下の値は、下地層によって提供されていると定義されます。"
    },
    {
      "indent": 3,
      "text": "Sender Local Address An address that is used by the underlying communication layer as described in Section 2.4 and identifies the sender address of the current message. This address must be unique among the nodes that can currently communicate, and it is only used in conjunction with the Receiver Local Address, Receiver Instance, and Sender Instance to identify a communicating pair of nodes.",
      "ja": "センダローカルアドレスセクション2.4に記載されており、現在のメッセージの送信元アドレスを特定するように基本的な通信層によって使用されるアドレス。このアドレスは、現在通信可能なノード間で一意である必要があり、唯一のノードの通信ペアを識別するために受信機ローカルアドレス、受信インスタンス、及び送信者インスタンスに関連して使用されます。"
    },
    {
      "indent": 3,
      "text": "Receiver Local Address An address that is used by the underlying communication layer as described in Section 2.4 and identifies the receiver address of the current message. This address must be unique among the nodes that can currently communicate, and is only used in conjunction with the Sender Local Address, Receiver Instance, and Sender Instance to identify a communicating pair of nodes.",
      "ja": "ローカルアドレスをセクション2.4に記載されており、現在のメッセージの受信アドレスを識別として基本的な通信層によって使用されるアドレスを受信機。このアドレスは、現在通信可能なノード間で一意である必要があり、唯一のノードの通信ペアを識別するために、送信者のローカルアドレス、受信インスタンス、及び送信者インスタンスと関連して使用されます。"
    },
    {
      "indent": 3,
      "text": "When PRoPHET is run over TCP, the IP addresses of the communicating nodes are used as Sender and Receiver Local Addresses.",
      "ja": "預言者は、TCP上で実行されると、通信ノードのIPアドレスは、送信者と受信者のローカルアドレスとして使用されています。"
    },
    {
      "indent": 0,
      "text": "4.2. TLV Structure",
      "section_title": true,
      "ja": "4.2。 TLV構造"
    },
    {
      "indent": 3,
      "text": "All TLVs have the following format, and can be nested.",
      "ja": "すべてのTLVは、次の形式を持っており、入れ子にすることができます。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    TLV Type   |   TLV Flags   |       TLV Length (SDNV)       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                           TLV Data                            ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 6: TLV Format",
      "ja": "図6：TLVフォーマット"
    },
    {
      "indent": 3,
      "text": "TLV Type Specific TLVs are defined in Section 4.3. The TLV Type is encoded as an 8-bit unsigned integer in network bit order. Each TLV will have fields defined that are specific to the function of that TLV.",
      "ja": "TLVタイプ固有のTLVは、4.3節で定義されています。 TLVタイプは、ネットワークビット順に8ビットの符号なし整数として符号化されます。各TLVは、TLVの機能に固有の定義されたフィールドを持つことになります。"
    },
    {
      "indent": 3,
      "text": "TLV Flags These are defined per TLV type. Flag n corresponds to bit 15-n in the TLV. Any flags that are specified as reserved in specific TLVs SHOULD be transmitted as 0 and ignored on receipt.",
      "ja": "これらのTLVフラグは、TLVタイプごとに定義されています。フラグNは、TLVのビット15-nに対応します。特定のTLVに予約として指定されているフラグは0として送信され、受信時に無視されるべきです。"
    },
    {
      "indent": 3,
      "text": "TLV Length Length of the TLV in octets, including the TLV header and any nested TLVs. Encoded as an SDNV. Note that TLVs are not padded to any specific alignment unless explicitly required in the description of the TLV. No TLVs in this document specify any padding.",
      "ja": "TLVヘッダ及び任意のネストされたTLVを含むオクテットでTLVのTLVの長さの長さ、。 SDNVとしてエンコード。明示的TLVの説明で必要とされない限りのTLVは、任意の特定の配向に埋め込まれていないことに留意されたいです。このドキュメントのいかなるTLVが任意のパディングを指定していません。"
    },
    {
      "indent": 0,
      "text": "4.3. TLVs",
      "section_title": true,
      "ja": "4.3。 TLV"
    },
    {
      "indent": 3,
      "text": "This section describes the various TLVs that can be used in PRoPHET messages.",
      "ja": "このセクションでは、預言者のメッセージで使用できるさまざまなTLVを説明しています。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Hello TLV",
      "section_title": true,
      "ja": "4.3.1。こんにちはTLV"
    },
    {
      "indent": 3,
      "text": "The Hello TLV is used to set up and maintain a link between two PRoPHET nodes. Hello messages with the SYN function are transmitted periodically as beacons or keep-alives. The Hello TLV is the first TLV exchanged between two PRoPHET nodes when they encounter each other. No other TLVs can be exchanged until the first Hello sequence is completed.",
      "ja": "こんにちはTLVは設定し、2つの預言者のノード間のリンクを維持するために使用されます。こんにちはSYN機能付きメッセージはビーコンまたはキープアライブとして定期的に送信されます。ハローTLVは、それらがお互いに遭遇するとき最初のTLVは、2つの預言者ノード間で交換されます。最初のHelloシーケンスが完了するまで、他のTLVを交換することはできません。"
    },
    {
      "indent": 3,
      "text": "Once a communication link is established between two PRoPHET nodes, the Hello TLV will be sent once for each interval as defined in the interval timer. If a node experiences the lapse of HELLO_DEAD Hello intervals without receiving a Hello TLV on a connection in the INFO_EXCH state (as defined in the state machine in Section 5.1), the connection SHOULD be assumed broken.",
      "ja": "通信リンクは、2つの預言者ノード間で確立されると、インターバルタイマで定義されるように、ハローTLVは、各間隔について一度送られます。ノードが（セクション5.1で、状態マシンに定義されている）INFO_EXCH状態の接続にハローTLVを受信することなくHELLO_DEADハロー間隔の経過が発生した場合、接続が壊れたと想定されるべきです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| TLV Type=0x01 |L|  Resv | HF  |       TLV Length (SDNV)       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Timer (SDNV)  |EID Length,SDNV|  Sender EID (variable length) |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 7: Hello TLV Format",
      "ja": "図7：こんにちはTLVフォーマット"
    },
    {
      "indent": 3,
      "text": "TLV Flags The TLV Flags field contains two 1-bit flags (S and L) and a 3-bit Hello Function (HF) number that specifies one of four functions for the Hello TLV. The remaining 3 bits (Resv) are unused and reserved:",
      "ja": "TLVフラグTLVフラグフィールドは、2つの1ビットフラグ（SおよびL）とハローTLVのための4つの機能のいずれかを指定する3ビットハロー機能（HF）番号を含みます。残りの3ビット（のResv）は、未使用に予約されています。"
    },
    {
      "indent": 8,
      "text": "HF\n     TLV Flags bits 0, 1, and 2 are treated as an unsigned 3-bit\n     integer coded in network bit order.  The value of the\n     integer specifies the Hello Function (HF) of the Hello TLV.\n     Four functions are specified for the Hello TLV.",
      "raw": true
    },
    {
      "indent": 13,
      "text": "The encoding of the Hello Function is:",
      "ja": "こんにちは機能のエンコーディングは以下のとおりです。"
    },
    {
      "indent": 18,
      "text": "SYN:     HF = 1\nSYNACK:  HF = 2\nACK:     HF = 3\nRSTACK:  HF = 4",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The remaining values (0, 5, 6 and 7) are unused and reserved. If a Hello TLV with any of these values is received, the link should be reset.",
      "ja": "残りの値は（0、5、6及び7）未使用に予約されています。これらの値のいずれかとこんにちはTLVを受信した場合、リンクがリセットされなければなりません。"
    },
    {
      "indent": 8,
      "text": "Resv\n     TLV Flags bits 3, 4, 5, and 6 are reserved.  They SHOULD be\n     set to 0 on transmission and ignored on reception.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "L The L bit flag (TLV Flags bit 7) is set (value 1) to request that the Bundle Offer TLV sent during the Information Exchange Phase contains bundle payload lengths for all bundles, rather than only for bundle fragments as when the L flag is cleared (value 0), when carried in a Hello TLV with Hello Function SYN or SYNACK. The flag is ignored for other Hello Function values.",
      "ja": "L Lビットフラグ（TLVフラグがビット7）TLVが情報交換フェーズ中に送信バンドルオファーではなくのみLフラグがある場合などバンドルフラグメントについてよりも、すべてのバンドルのバンドルペイロードの長さが含まれていることを要求する（値1）に設定されていますこんにちは機能のSYNまたはSYNACKとこんにちはTLVで運ばとき、（値0）がクリア。フラグは、他のHello関数の値は無視されます。"
    },
    {
      "indent": 3,
      "text": "TLV Data",
      "ja": "TLVデータ"
    },
    {
      "indent": 8,
      "text": "Timer\n     The Timer field is used to inform the receiver of the timer\n     value used in the Hello processing of the sender.  The\n     timer specifies the nominal time between periodic Hello\n     messages.  It is a constant for the duration of a session.\n     The timer field is specified in units of 100 ms and is\n     encoded as an SDNV.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "EID Length The EID Length field is used to specify the length of the Sender EID field in octets. If the Endpoint Identifier (EID) has already been sent at least once in a message with the current Sender Instance, a node MAY choose to set this field to zero, omitting the Sender EID from the Hello TLV. The EID Length is encoded as an SDNV, and the field is thus of variable length.",
      "ja": "EID長EID長さフィールドは、オクテット単位で送信者EIDフィールドの長さを指定するために使用されます。エンドポイント識別子（EID）が既に少なくとも一回現在の送信者インスタンスにメッセージで送信された場合、ノードは、ハローTLVから送信者EIDを省略し、ゼロにこのフィールドを設定することを選ぶかもしれ。 EID長はSDNVとしてエンコードされ、フィールドは、このように可変長です。"
    },
    {
      "indent": 8,
      "text": "Sender EID The Sender EID field specifies the DTN endpoint identifier (EID) of the sender that is to be used in updating routing information and making forwarding decisions. If a node has multiple EIDs, one should be chosen for PRoPHET routing. This field is of variable length.",
      "ja": "送信元EIDセンダEIDフィールドは、ルーティング情報を更新し、転送の決定を行う際に使用される送信者のDTNエンドポイント識別子（EID）を指定します。ノードが複数のEIDを有する場合、一方は預言者のルーティングのために選択されるべきです。このフィールドは可変長です。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Error TLV",
      "section_title": true,
      "ja": "4.3.2。エラーTLV"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| TLV type=0x02 |   TLV Flags |         TLV Length (SDNV)       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~                          TLV Data                            ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 8: Error TLV Format",
      "ja": "図8：エラーTLVのフォーマット"
    },
    {
      "indent": 3,
      "text": "TLV Flags For Error TLVs, the TLV Flags field carries an identifier for the Error TLV type as an 8-bit unsigned integer encoded in network bit order. A range of values is available for private and experimental use in addition to the values defined here. The following Error TLV types are defined:",
      "ja": "エラーのTLV、TLVフラグフィールドについてTLVフラグは、ネットワークビット順序で符号化された8ビットの符号なし整数としてエラーTLVタイプの識別子を運びます。値の範囲は、ここで定義された値に加えて、プライベートと実験的な使用のために利用可能です。次のエラーTLVタイプが定義されています。"
    },
    {
      "indent": 18,
      "text": "Dictionary Conflict               0x00\nBad String ID                     0x01\nReserved                       0x02 - 0x7F\nPrivate/Experimental Use       0x80 - 0xFF",
      "raw": true
    },
    {
      "indent": 3,
      "text": "TLV Data The contents and interpretation of the TLV Data field are specific to the type of Error TLV. For the Error TLVs defined in this document, the TLV Data is defined as follows:",
      "ja": "TLVデータ内容とTLVデータフィールドの解釈は誤りTLVのタイプに固有のものです。次のようにこの文書で定義されたエラーのTLVの場合は、TLVデータが定義されています。"
    },
    {
      "indent": 8,
      "text": "Dictionary Conflict\n     The TLV Data consists of the String ID that is causing the\n     conflict encoded as an SDNV followed by the EID string that\n     conflicts with the previously installed value.  The\n     Endpoint Identifier is NOT null terminated.  The length of\n     the EID can be determined by subtracting the length of the\n     TLV Header and the length of the SDNV containing the String\n     ID from the TLV Length.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Bad String ID The TLV Data consists of the String ID that is not found in the dictionary encoded as an SDNV.",
      "ja": "悪い文字列IDザ・TLVデータがSDNVとしてエンコードされた辞書で見つからない文字列IDで構成されています。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Routing Information Base Dictionary TLV",
      "section_title": true,
      "ja": "4.3.3。ルーティング情報ベース辞書TLV"
    },
    {
      "indent": 3,
      "text": "The Routing Information Base Dictionary includes the list of endpoint identifiers used in making routing decisions. The referents remain constant for the duration of a session over a link where the instance numbers remain the same and can be used by both the Routing Information Base messages and the bundle offer/response messages. The dictionary is a shared resource (see Section 3.2.1) built in each of the paired peers from the contents of one or more incoming TLVs of this type and from the information used to create outgoing TLVs of this type.",
      "ja": "ルーティング情報ベース辞書は、ルーティング決定を行う際に使用されるエンドポイント識別子のリストを含んでいます。言及は、インスタンス番号は同じままであり、ルーティング情報ベースのメッセージ、バンドルオファー/応答メッセージの両方で使用することができるリンクを介してセッションの期間中一定のままです。辞書は、このタイプの1つの以上の着信のTLVの内容からしてこのタイプの発信TLVを作成するために使用される情報から、一対のピアの各々に内蔵された共有リソース（セクション3.2.1を参照します）。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| TLV type=0xA0 |   TLV Flags   |       TLV Length (SDNV)       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     RIBD Entry Count (SDNV)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                                                               ~\n~           Variable-Length Routing Address Strings             ~\n~                                                               ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "~ Routing Address String 1 ~",
      "ja": "〜ルーティングアドレス文字列1〜"
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        String ID 1 (SDNV)     |         Length (SDNV)         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~            Endpoint Identifier 1 (variable length)            ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               .                               |\n~ Routing Address String n      .                               ~\n|                               .                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        String ID n (SDNV)     |         Length (SDNV)         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n~            Endpoint Identifier n (variable length)            ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 9: Routing Information Base Dictionary TLV Format",
      "ja": "図9：ルーティング情報ベース辞書TLVのフォーマット"
    },
    {
      "indent": 3,
      "text": "TLV Flags The encoding of the Header flag field relates to the capabilities of the source node sending the RIB Dictionary:",
      "ja": "TLVフラグヘッダフラグフィールドの符号化は、RIBの辞書を送信元ノードの能力に関する。"
    },
    {
      "indent": 13,
      "text": "Flag 0: Sent by Listener    0b1\nFlag 1: Reserved            0b1\nFlag 2: Reserved            0b1\nFlag 3: Unassigned          0b1\nFlag 4: Unassigned          0b1\nFlag 5: Unassigned          0b1\nFlag 6: Unassigned          0b1\nFlag 7: Unassigned          0b1",
      "raw": true
    },
    {
      "indent": 8,
      "text": "The \"Sent by Listener\" flag is set to 0 if this TLV was sent by a node in the Initiator role and set to 1 if this TLV was sent by a node in the Listener role (see Section 3.2 for explanations of these roles).",
      "ja": "このTLVは、リスナーの役割（これらの役割の説明については、セクション3.2を参照）内のノードによって送信された場合、このTLVは、イニシエータの役割にノードによって送信され、1に設定されていた場合、「リスナーによって送信」フラグが0に設定されています。"
    },
    {
      "indent": 3,
      "text": "TLV Data",
      "ja": "TLVデータ"
    },
    {
      "indent": 8,
      "text": "RIBD Entry Count\n     Number of entries in the database.  Encoded as SDNV.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "String ID SDNV identifier that is constant for the duration of a session. String ID zero is predefined as the node that initiates the session through sending the Hello SYN message, and String ID one is predefined as the node that responds with the Hello SYNACK message. These entries do not need to be sent explicitly as the EIDs are exchanged during the Hello procedure.",
      "ja": "セッションの持続時間に対して一定である文字列ID SDNV識別子。文字列IDゼロはハローSYNメッセージを送信することを介してセッションを開始ノードとして事前に定義され、文字列IDのいずれかがハローSYNACKメッセージで応答ノードとして事前に定義されています。これらのエントリはのEIDこんにちは手順の間に交換されると明示的に送信する必要はありません。"
    },
    {
      "indent": 13,
      "text": "In order to ensure that the String IDs originated by the\ntwo peers do not conflict, the String IDs generated in the\nnode that sent the Hello SYN message MUST have their least\nsignificant bit set to 0 (i.e., are even numbers), and the\nString IDs generated in the node that responded with the\nHello SYNACK message MUST have their least significant bit\nset to 1 (i.e., they are odd numbers).",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Length Length of Endpoint Identifier in this entry. Encoded as SDNV.",
      "ja": "このエントリ内のエンドポイント識別子の長さの長さ。 SDNVとしてエンコード。"
    },
    {
      "indent": 8,
      "text": "Endpoint Identifier Text string representing the Endpoint Identifier. Note that it is NOT null terminated as the entry contains the length of the identifier.",
      "ja": "エンドポイント識別子を表すエンドポイント識別子テキスト文字列。エントリは、識別子の長さが含まれているとして、それがnullで終了しないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.3.4. Routing Information Base TLV",
      "section_title": true,
      "ja": "4.3.4。ルーティング情報ベースTLV"
    },
    {
      "indent": 3,
      "text": "The Routing Information Base lists the destinations (endpoints) a node knows of and the delivery predictabilities it has associated with them. This information is needed by the PRoPHET algorithm to make decisions on routing and forwarding.",
      "ja": "ルーティング情報ベースは、ノードが知っているのと、それはそれらに関連付けられている配信予測精度の宛先（エンドポイント）を示しています。この情報は、ルーティングおよび転送上の意思決定を行うために預言者のアルゴリズムによって必要とされています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| TLV Type=0xA1 |   TLV Flags   |       TLV Length (SDNV)       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     RIB String Count (SDNV)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     RIBD String ID 1 (SDNV)   |            P-value            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  RIB Flags 1  |               .                               ~\n+-+-+-+-+-+-+-+-+               .                               ~\n~                               .                               ~\n~                               .                               ~\n~                               .                               ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     RIBD String ID n (SDNV)   |            P-value            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  RIB Flags n  |\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 10: Routing Information Base TLV Format",
      "ja": "図10：ルーティング情報ベースTLVフォーマット"
    },
    {
      "indent": 3,
      "text": "TLV Flags The encoding of the Header flag field relates to the capabilities of the Source node sending the RIB:",
      "ja": "TLVフラグヘッダフラグフィールドの符号化は、RIBを送信元ノードの能力に関する。"
    },
    {
      "indent": 13,
      "text": "Flag 0: More RIB TLVs       0b1\nFlag 1: Reserved            0b1\nFlag 2: Reserved            0b1\nFlag 3: Unassigned          0b1\nFlag 4: Unassigned          0b1\nFlag 5: Unassigned          0b1\nFlag 6: Unassigned          0b1\nFlag 7: Unassigned          0b1",
      "raw": true
    },
    {
      "indent": 8,
      "text": "The \"More RIB TLVs\" flag is set to 1 if the RIB requires more TLVs to be sent in order to be fully transferred. This flag is set to 0 if this is the final TLV of this RIB.",
      "ja": "RIBが完全転送するために送信される複数のTLVを必要とする場合、「詳細RIBのTLV」フラグが1に設定されています。これは、このリブの最終TLVである場合、このフラグは0に設定されています。"
    },
    {
      "indent": 3,
      "text": "TLV Data",
      "ja": "TLVデータ"
    },
    {
      "indent": 8,
      "text": "RIB String Count\n     Number of routing entries in the TLV.  Encoded as an SDNV.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "RIBD String ID String ID of the endpoint identifier of the destination for which this entry specifies the delivery predictability as predefined in a dictionary TLV. Encoded as an SDNV.",
      "ja": "辞書TLVに事前定義のようにこのエントリが配信予測を指定するための宛先のエンドポイント識別子のRIBD文字列IDの文字列ID。 SDNVとしてエンコード。"
    },
    {
      "indent": 8,
      "text": "P-value Delivery predictability for the destination of this entry as calculated from previous encounters according to the equations in Section 2.1.2, encoded as a 16-bit unsigned integer. The encoding of this field is a linear mapping from [0,1] to [0, 0xFFFF] (e.g., for a P-value of 0.75, the mapping would be 0.75*65535=49151=0xBFFF; thus, the P-value would be encoded as 0xBFFF).",
      "ja": "16ビットの符号なし整数として符号化2.1.2における式に従って以前出会い、から計算され、このエントリの宛先のP値配信予測。このように、P値;このフィールドの符号化は[0、0xFFFFの（例えば、0.75のP値のために、マッピングは次のようになり0.75 * 65535 = 49151 = 0xBFFFに[0,1]から線形マッピングであります）0xBFFFとしてエンコードされます。"
    },
    {
      "indent": 8,
      "text": "RIB Flag The encoding of the 8-bit RIB Flag field is:",
      "ja": "RIBフラグ8ビットRIBフラグフィールドの符号化です。"
    },
    {
      "indent": 13,
      "text": "Flag 0: Unassigned          0b1\nFlag 1: Unassigned          0b1\nFlag 2: Unassigned          0b1\nFlag 3: Unassigned          0b1\nFlag 4: Unassigned          0b1\nFlag 5: Unassigned          0b1\nFlag 6: Unassigned          0b1\nFlag 7: Unassigned          0b1",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3.5. Bundle Offer and Response TLVs (Version 2)",
      "section_title": true,
      "ja": "4.3.5。バンドルオファーと応答のTLV（バージョン2）"
    },
    {
      "indent": 3,
      "text": "After the routing information has been passed, the node will ask the other node to review available bundles and determine which bundles it will accept for relay. The source relay will determine which bundles to offer based on relative delivery predictabilities as explained in Section 3.6.",
      "ja": "ルーティング情報が渡された後、ノードが使用可能なバンドルを確認し、それがリレーのために受け入れるバンドルを決定するために他のノードを要求します。ソースリレーは、セクション3.6で説明したように相対的な送達予測精度に基づいて提供するバンドルを決定します。"
    },
    {
      "indent": 8,
      "text": "Note: The original versions of these TLVs (TLV Types 0xA2 and\n0xA3) used in version 1 of the PRoPHET protocol have been\ndeprecated, as they did not contain the complete information\nneeded to uniquely identify bundles and could not handle bundle\nfragments.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Depending on the bundles stored in the offering node, the Bundle Offer TLV might contain descriptions of both complete bundles and bundle fragments. In order to correctly identify bundle fragments, a bundle fragment descriptor MUST contain the offset of the payload fragment in the bundle payload and the length of the payload fragment. If requested by the receiving node by setting the L flag in the SYN or SYNACK message during the neighbor awareness phase, the offering node MUST include the length of the payload in the descriptor for complete bundles. The appropriate flags MUST be set in the B_flags for the descriptor to indicate if the descriptor contains the payload length field (set for fragments in all cases and for complete bundles if the L flag was set) and if the descriptor contains a payload offset field (fragments only).",
      "ja": "募集ノードに保存されているバンドルによっては、バンドルオファーTLVは完全なバンドル、バンドルフラグメントの両方の記述が含まれている場合があります。正しくバンドルフラグメントを同定するために、バンドルフラグメント記述子は、バンドルペイロードおよびペイロード断片の長さのペイロードフラグメントのオフセットを含まなければなりません。隣接認識フェーズ中にSYNまたはSYNACKメッセージにおけるLフラグを設定することにより、受信ノードによって要求された場合、提供ノードは、完全なバンドルの記述子内のペイロードの長さを含まなければなりません。記述子は、ペイロードオフセットフィールド（含まれている場合、記述子は（Lフラグが設定された場合、全ての場合において、完全バンドルのためのフラグメントに設定）ペイロード長フィールドを含み、場合適切なフラグが指示するディスクリプタにB_flagsで設定する必要があります断片のみ）。"
    },
    {
      "indent": 3,
      "text": "The Bundle Offer TLV also lists the bundles for which a PRoPHET acknowledgement has been issued. Those bundles have the PRoPHET ACK flag set in their entry in the list. When a node receives a PRoPHET ACK for a bundle, it SHOULD, if possible, signal to the bundle protocol agent that this bundle is no longer required for transmission by PRoPHET. Despite no longer transmitting the bundle, it SHOULD keep an entry for the acknowledged bundle to be able to further propagate the PRoPHET ACK.",
      "ja": "バンドルオファーTLVはまた、預言者の承認が発行されたバンドルを示しています。これらのバンドルは、リスト内のエントリに設定された預言者ACKフラグを持っています。ノードは、バンドルのPROPHET ACKを受信すると、それは、可能な場合、このバンドルはもはや預言者による送信のために必要とされることをバンドルプロトコルエージェントに知らせるべきです。もはやバンドルを送信するにもかかわらず、それはさらに預言者ACKを伝播することができると認めバンドルのエントリを維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Response TLV format is identical to the Offer TLV with the exception of the TLV Type field. Bundles that are being accepted from the corresponding Offer are explicitly marked with a B_flag. Specifications for bundles that are not being accepted MAY either be omitted or left in but not marked as accepted. The payload length field MAY be omitted for complete bundles in the Response message even if it was included in the Offer message. The B_flags payload length flag MUST be set correctly to indicate if the length field is included or not. The Response message MUST include both payload offset and payload length fields for bundle fragments, and the B_flags MUST be set to indicate that both are present.",
      "ja": "レスポンスTLV形式は、TLVタイプフィールドを除き、オファーTLVと同じです。対応するオファーから受け入れられているバンドルは、明示的にB_flagでマークされています。受理されていないバンドルの仕様は、いずれかを省略または左ではなく、受け入れとしてマークされていないかもしれません。ペイロード長フィールドは、それがオファーメッセージに含まれていた場合でも、応答メッセージに完全なバンドルのために省略されるかもしれません。 B_flagsペイロード長フラグは、長さフィールドが含まれているかどうかを示すために正しく設定する必要があります。応答メッセージは、バンドルフラグメントの両方にペイロードオフセット及びペイロード長フィールドを含まなければなりません、そしてB_flagsは、両方が存在することを示すように設定されなければなりません。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    TLV Type   |   TLV Flags   |       TLV Length (SDNV)       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Bundle Offer Count (SDNV)                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    B_flags    |       Bundle Source     |  Bundle Destination |\n|               |     String ID 1 (SDNV)  |  String ID 1 (SDNV) |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Bundle 1 Creation Timestamp Time              |\n|                             (SDNV)                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Bundle 1 Creation Timestamp Sequence Number         |\n|                             (SDNV)                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Bundle 1 Payload Offset - only present if bundle is a fragment|\n|                             (SDNV)                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Bundle 1 Payload Length - only present if bundle is a fragment|\n|         or transmission of length requested (SDNV)            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                               .                               ~\n~                               .                               ~\n~                               .                               ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    B_flags    |       Bundle Source     |  Bundle Destination |\n|               |     String ID n (SDNV)  |  String ID n (SDNV) |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Bundle n Creation Timestamp Time              |\n|                             (SDNV)                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Bundle n Creation Timestamp Sequence Number         |\n|                             (SDNV)                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Bundle n Payload Offset - only present if bundle is a fragment|\n|                             (SDNV)                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Bundle n Payload Length - only present if bundle is a fragment|\n|         or transmission of length requested (SDNV)            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 11: Bundle Offer and Response TLV Format",
      "ja": "図11：バンドルオファーと応答TLVフォーマット"
    },
    {
      "indent": 3,
      "text": "TLV Type The TLV Type for a Bundle Offer is 0xA4. The TLV Type for a Bundle Response is 0xA5.",
      "ja": "バンドルオファーのためのTLVタイプザ・TLVタイプは0xA4のです。バンドル応答のためのTLVタイプは0xA5のです。"
    },
    {
      "indent": 3,
      "text": "TLV Flags The encoding of the Header flag field relates to the capabilities of the source node sending the RIB:",
      "ja": "TLVフラグヘッダフラグフィールドの符号化は、RIBを送信元ノードの能力に関する。"
    },
    {
      "indent": 13,
      "text": "Flag 0: More Offer/Response\n        TLVs Following      0b1\nFlag 1: Unassigned          0b1\nFlag 2: Unassigned          0b1\nFlag 3: Unassigned          0b1\nFlag 4: Unassigned          0b1\nFlag 5: Unassigned          0b1\nFlag 6: Unassigned          0b1\nFlag 7: Unassigned          0b1",
      "raw": true
    },
    {
      "indent": 8,
      "text": "If the Bundle Offers or Bundle Responses are divided between several TLVs, the \"More Offer/Response TLVs Following\" flag MUST be set to 1 in all but the last TLV in the sequence where it MUST be set to 0.",
      "ja": "バンドルオファーまたはバンドル応答は、いくつかのTLVの間で分割されている場合は、「より多くのオファー/レスポンスのTLVに続いて」フラグが全て1に設定されていますが、それは0に設定しなければならないシーケンスの最後のTLVなければなりません。"
    },
    {
      "indent": 3,
      "text": "TLV Data",
      "ja": "TLVデータ"
    },
    {
      "indent": 8,
      "text": "Bundle Offer Count\n     Number of bundle offer/response entries.  Encoded as an\n     SDNV.  Note that 0 is an acceptable value.  In particular,\n     a Bundle Response TLV with 0 entries is used to signal that\n     a cycle of information exchange and bundle passing is\n     completed.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "B Flags The encoding of the B Flags is:",
      "ja": "BフラグBフラグのエンコーディングは以下のとおりです。"
    },
    {
      "indent": 13,
      "text": "Flag 0: Bundle Accepted       0b1\nFlag 1: Bundle is a Fragment  0b1\nFlag 2: Bundle Payload Length\n        included in TLV       0b1\nFlag 3: Unassigned            0b1\nFlag 4: Unassigned            0b1\nFlag 5: Unassigned            0b1\nFlag 6: Unassigned            0b1\nFlag 7: PRoPHET ACK           0b1",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Bundle Source String ID String ID of the source EID of the bundle as predefined in a dictionary TLV. Encoded as an SDNV.",
      "ja": "辞書TLVで事前定義されたように、バンドルのソースEIDのソース文字列IDの文字列IDをバンドル。 SDNVとしてエンコード。"
    },
    {
      "indent": 8,
      "text": "Bundle Destination String ID String ID of the destination EID of the bundle as predefined in a dictionary TLV. Encoded as an SDNV.",
      "ja": "辞書TLVで事前定義されたように、バンドルの宛先EIDの宛先文字列IDの文字列IDをバンドル。 SDNVとしてエンコード。"
    },
    {
      "indent": 8,
      "text": "Bundle Creation Timestamp Time Time component of the Bundle Creation Timestamp for the bundle. Encoded as an SDNV.",
      "ja": "バンドルのバンドルの作成タイムスタンプの作成タイムスタンプ時間時間コンポーネントをバンドルします。 SDNVとしてエンコード。"
    },
    {
      "indent": 8,
      "text": "Bundle Creation Timestamp Sequence Number Sequence Number component of the Bundle Creation Timestamp for the bundle. Encoded as an SDNV.",
      "ja": "バンドルのバンドル作成タイムスタンプの作成タイムスタンプシーケンス番号シーケンス番号コンポーネントをバンドル。 SDNVとしてエンコード。"
    },
    {
      "indent": 8,
      "text": "Bundle Payload Offset Only included if the bundle is a fragment and the fragment bit is set (value 1) in the bundle B Flags. Offset of the start of the fragment payload in the complete bundle payload. Encoded as an SDNV.",
      "ja": "バンドルフラグメントであり、フラグメントビットがバンドルBフラグに（値1）に設定されている場合、バンドルペイロードのみ含まれるオフセット。完全なバンドルペイロードにおけるフラグメントのペイロードの先頭のオフセット。 SDNVとしてエンコード。"
    },
    {
      "indent": 8,
      "text": "Bundle Payload Length Only included if the bundle length included bit is set (value 1) in the bundle B Flags. Length of the payload in the bundle specified. This is either the total payload length if the bundle is a complete bundle or the bundle fragment payload length if the bundle is a fragment. Encoded as an SDNV.",
      "ja": "バンドルの長さが少し含まれている場合にのみ含まれるバンドルペイロード長は、バンドルBフラグに（値1）に設定されています。指定されたバンドル内のペイロードの長さ。バンドルがフラグメントである場合、バンドルは完全バンドルまたはバンドルフラグメントペイロード長である場合、これは総ペイロード長のいずれかです。 SDNVとしてエンコード。"
    },
    {
      "indent": 0,
      "text": "5. Detailed Operation",
      "section_title": true,
      "ja": "5.詳細な操作"
    },
    {
      "indent": 3,
      "text": "In this section, some more details on the operation of PRoPHET are given along with state tables to help in implementing the protocol.",
      "ja": "このセクションでは、預言者の操作に関するいくつかの詳細は、プロトコルを実装する際に支援するために状態テーブルと一緒に与えられています。"
    },
    {
      "indent": 3,
      "text": "As explained in Section 1.2, it is RECOMMENDED that \"Success\" responses should not be requested or sent when operating over a reliable, in-order transport protocol such as TCP. If in the future PRoPHET were operated over an unreliable transport protocol, positive acknowledgements would be necessary to signal successful delivery of (sub)messages. In this section, the phrase \"send a message\" should be read as *successful* sending of a message, signaled by receipt of the appropriate \"Success\" response if running over an unreliable protocol, but guaranteed by TCP or another reliable protocol otherwise. Hence, the state descriptions below do not explicitly mention positive acknowledgements, whether they are being sent or not.",
      "ja": "第1.2節で説明したように、TCPのような信頼性の高い、インオーダーのトランスポートプロトコル上で動作しているときに「成功」​​の応答が要求されたり送信されないことが推奨されます。将来預言者に信頼できないトランスポートプロトコル上で動作させた場合、肯定応答は、（サブ）メッセージの配信の成功を通知する必要があります。このセクションでは、フレーズ「メッセージを送信するには、」*成功したが、*信頼性の低いプロトコル上で実行している場合は、適切な「成功」応答の受信によって合図メッセージの送信、それ以外はTCPまたは別の信頼できるプロトコルによって保証として読まれるべきです。そこで、以下の状態の説明は、明示的に、彼らが送信またはないされているかどうかを、肯定応答を言及していません。"
    },
    {
      "indent": 0,
      "text": "5.1. High-Level State Tables",
      "section_title": true,
      "ja": "5.1。ハイレベル状態テーブル"
    },
    {
      "indent": 3,
      "text": "This section gives high-level state tables for the operation of PRoPHET. The following sections will describe each part of the operation in more detail (including state tables for the internal states of those procedures).",
      "ja": "このセクションでは、預言者の操作のための高レベル状態テーブルを与えます。以下のセクションでは、（これらの手続きの内部状態の状態表を含む）、より詳細に操作の各部分について説明します。"
    },
    {
      "indent": 3,
      "text": "The following main or high-level states are used in the state tables:",
      "ja": "次のメイン又はハイレベルの状態は、状態テーブルで使用されています。"
    },
    {
      "indent": 3,
      "text": "WAIT_NB This is the state all nodes start in. Nodes remain in this state until they are notified that a new neighbor is available. At that point, the Hello procedure should be started with the new neighbor, and the node transitions into the HELLO state. Nodes SHOULD be able to handle multiple neighbors in parallel, maintaining separate state machines for each neighbor. This could be handled by creating a new thread or process during the transition to the HELLO state that then takes care of the communication with the new neighbor while the parent remains in state WAIT_NB waiting for additional neighbors to communicate. In this case, when the neighbor can no longer be communicated with (described as \"Neighbor Gone\" in the tables below), the thread or process created is destroyed and, when a connection-oriented protocol is being used to communicate with the neighbor, the connection is closed. The current version of the protocol is specified to use TCP for neighbor connections so that these will be closed when the neighbor is no longer accessible.",
      "ja": "WAIT_NBこれは、すべてのノードが起動している状態である。彼らは新しい隣人が利用可能であることが通知されるまで、ノードはこの状態のまま。その時点で、こんにちは手順は、新しい隣人で起動する必要があり、ノードは、HELLO状態に遷移します。ノードは、各隣接に別々の状態マシンを維持する、並行して複数のネイバーを扱うことができるべきです。これは、親が通信するために追加の隣人を待っている状態WAIT_NBのまま、新しい隣人とのコミュニケーションの世話をするのHELLO状態への移行時に新しいスレッドやプロセスを作成することによって処理することができます。近隣がもはや（以下の表中の「ゴーンネイバー」と記載）と連通することができない場合この場合、作成されたスレッドまたはプロセスは、コネクション型プロトコルは、ネイバーと通信するために使用されている場合、破棄され接続は閉じられます。プロトコルの現在のバージョンは、隣人にアクセスできなくなったときにこれらがクローズされませんように、近隣の接続にTCPを使用するように指定されています。"
    },
    {
      "indent": 3,
      "text": "HELLO Nodes are in the HELLO state from when a new neighbor is detected until the Hello procedure is completed and a link is established (which happens when the Hello procedure enters the ESTAB state as described in Section 5.2; during this procedure, the states ESTAB, SYNSENT, and SYNRCVD will be used, but these are internal to the Hello procedure and are not listed here). If the node is notified that the neighbor is no longer in range before a link has been established, it returns to the WAIT_NB state, and, if appropriate, any additional process or thread created to handle the neighbor MAY be destroyed.",
      "ja": "ハローノードは、セクション5.2で説明したようにハロー手順がESTAB状態に入るときに起こるた（ハロー手順が完了するまで新しいネイバーが検出され、リンクが確立されてからのHELLO状態にあり、この手順の間、状態ESTAB、 ）SYNSENT、およびSYNRCVDが使用されますが、これらはハロープロシージャーの内部であり、ここに記載されていません。ノードは、リンクが確立される前に隣人が範囲内にもはやであることが通知されていない場合は隣人を処理するために作成し、適切な、任意の追加のプロセスまたはスレッドが破壊される可能性がある場合、それは、WAIT_NB状態に戻り、。"
    },
    {
      "indent": 3,
      "text": "INFO_EXCH After a link has been set up by the Hello procedure, the node transitions to the INFO_EXCH state in which the Information Exchange Phase is done. The node remains in this state as long as Information Exchange Phase TLVs (Routing RIB, Routing RIB Dictionary, Bundle Offer, Bundle Response) are being received. If the node is notified that the neighbor is no longer in range before all information and bundles have been exchanged, any associated connection is closed and the node returns to the WAIT_NB state to await new neighbors. The Timer(keep_alive) is used to ensure that the connection remains active.",
      "ja": "リンク後INFO_EXCHはこんにちは手順、情報交換フェーズが行われたINFO_EXCH状態にノード遷移によって設定されています。ノードは限り情報交換フェーズのTLV（ルーティングRIB、ルーティングRIB辞書、バンドルオファー、バンドル応答）が受信されているとして、この状態のままになります。ノードはすべての情報およびバンドルが交換される前に隣人が範囲内にもはやであることが通知されていない場合は、関連するすべての接続が閉じられ、WAIT_NB状態にノード戻り、新たな隣人を待ちます。タイマ（KEEP_ALIVE）は接続がアクティブのままであることを確実にするために使用されます。"
    },
    {
      "indent": 9,
      "text": "In the INFO_EXCH state, the nodes at both ends of the\nestablished link are able to update their delivery\npredictability information using data from the connected peer\nand then make offers of bundles for exchange which may be\naccepted or not by the peer.  To manage these processes, each\nnode acts both as an Initiator and a Listener for the\nInformation Exchange Phase processes, maintaining subsidiary\nstate machines for the two roles.  The Initiator and Listener\nterms refer to the sending of the Routing RIB information: it\nis perhaps counterintuitive that the Listener becomes the\nbundle offeror and the Initiator the bundle acceptor during the\nbundling passing part.",
      "raw": true
    },
    {
      "indent": 9,
      "text": "The protocol is designed so that the two exchanges MAY be carried out independently but concurrently, with the messages multiplexed onto on a single bidirectional link (such as is provided by the TCP connection). Alternatively, the exchanges MAY be carried out partially or wholly sequentially if appropriate for the implementation. The Information Exchange Phase is explained in more detail in Section 3.2.",
      "ja": "2回の交換は、独立しなく同時に行うことができるように、プロトコルは、（例えば、TCP接続によって提供されるような）単一の双方向リンク上に多重化メッセージと、設計されています。適切であれば別の方法として、交換が実施のため順次に部分的または全体的に行うことができます。情報交換フェーズは、3.2節で詳しく説明されています。"
    },
    {
      "indent": 9,
      "text": "When an empty Bundle Response TLV (i.e., no more bundles to send) is received, the node starts the Timer(next_exchange). When this timer expires, assuming that the neighbor is still connected, the Initiator reruns the Information Exchange Phase. If there is only one neighbor connected at this time, this will have the effect of further increasing the delivery predictability for this node in the neighbor, and changing the delivery predictabilities as a result of the transitive property (Equation 3). If there is more than one neighbor connected or other communication opportunities have happened since the previous information exchange occurred, then the changes resulting from these other encounters will be passed on to the connected neighbor. The next_exchange timer is restarted once the information exchange has completed again.",
      "ja": "空のバンドル応答TLV（送信する、すなわち、これ以上の束）を受信した場合、ノードは、タイマ（next_exchange）を開始します。このタイマーは、隣人がまだ接続されていることを想定し、有効期限が切れると、イニシエータは、情報交換フェーズを再実行します。この時点で接続された唯一の隣人がある場合、これはさらに隣に、このノードの配信予測可能性を増加させる、及び推移プロパティ（式3）の結果、配信予測精度を変化させる効果を有するであろう。以前の情報交換が発生したため、複数のネイバーが接続されているか、他の通信機会が起きているがある場合、これらの他の出会いから生じた変更が接続されている隣人に渡されます。情報交換が再び完了するnext_exchangeタイマーが再起動されます。"
    },
    {
      "indent": 9,
      "text": "If one or more new bundles are received by this node while waiting for the Timer(next_exchange) to expire and the delivery predictabilities indicate that it would be appropriate to forward some or all of the bundles to the connected node, the bundles SHOULD be immediately offered to the connected neighbor and transferred if accepted.",
      "ja": "1つまたは複数の新しいバンドルが期限切れにタイマーため（next_exchangeを）待っている間に、このノードによって受信され、配信予測精度は、接続されたノードへのバンドルの一部または全部を転送するのが適切であろうことを示し、バンドルはすぐに提供する必要がある場合接続された隣人へと受け入れられた場合に移しました。"
    },
    {
      "indent": 4,
      "text": "State: WAIT_NB",
      "ja": "状態：WAIT_NB"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|     Condition    |               Action              | New State |\n+==================+===================================+===========+\n|   New Neighbor   | Start Hello procedure for neighbor|   HELLO   |\n|                  |  Keep waiting for more neighbors  |  WAIT_NB  |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "State: HELLO",
      "ja": "状態：ハロー"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|    Condition     |               Action              | New State |\n+==================+===================================+===========+\n|  Hello TLV rcvd  |                                   |   HELLO   |\n+------------------+-----------------------------------+-----------+\n| Enter ESTAB state|  Start Information Exchange Phase | INFO_EXCH |\n+------------------+-----------------------------------+-----------+\n|  Neighbor Gone   |                                   |  WAIT_NB  |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "State: INFO_EXCH",
      "ja": "状態：INFO_EXCH"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|    Condition     |               Action              | New State |\n+==================+===================================+===========+\n|     On entry     |     Start Timer(keep-alive)       |           |\n|                  |        Uses Hello Timer interval  | INFO_EXCH |\n+------------------+-----------------------------------+-----------+\n|Info Exch TLV rcvd| (processed by subsidiary state    |           |\n|                  |                         machines) | INFO_EXCH |\n+------------------+-----------------------------------+-----------+\n| No more bundles  |     Start Timer(next_exchange)    | INFO_EXCH |\n+------------------+-----------------------------------+-----------+\n| Keep-alive expiry|     Send Hello SYN message        | INFO_EXCH |\n+------------------+-----------------------------------+-----------+\n|  Hello SYN rcvd  |     Record reception              |           |\n|                  |     Restart Timer(keep-alive)     | INFO_EXCH |\n+------------------+-----------------------------------+-----------+\n|  Neighbor Gone   |                                   |  WAIT_NB  |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The keep-alive messages (messages with Hello SYN TLV) are processed by the high-level state machine in the INFO_EXCH state. All other messages are delegated to the subsidiary state machines of the Information Exchange Phase described in Section 5.3. The receipt of keep-alive messages is recorded and may be used by the subsidiary machines to check if the peer is still functioning. The connection will be aborted (as described in Section 4.3.1) if several keep-alive messages are not received.",
      "ja": "キープアライブメッセージ（ハローSYN TLVとのメッセージが）INFO_EXCH状態で高レベルのステートマシンによって処理されています。他のすべてのメッセージは、情報交換フェーズのステートマシンは、5.3節で説明した子会社に委任されています。キープアライブメッセージの受信が記録され、ピアがまだ機能しているかどうかをチェックするために子会社マシンで使用することができます。いくつかのキープアライブメッセージが受信されない場合（4.3.1項で説明したように）接続が中止されます。"
    },
    {
      "indent": 0,
      "text": "5.2. Hello Procedure",
      "section_title": true,
      "ja": "5.2。こんにちは手順"
    },
    {
      "indent": 3,
      "text": "The Hello procedure is described by the following rules and state tables. In this section, the messages sent consist of the PRoPHET header and a single Hello TLV (see Figure 4 and Section 4.3.1) with the HF (Hello Function) field set to the specified value (SYN, SYNACK, ACK or RSTACK).",
      "ja": "こんにちは手順は、次のルールと状態テーブルによって記述されています。このセクションでは、送信されたメッセージは、指定された値（SYN、SYNACK、ACK又はRSTACK）にHF（ハロー機能）フィールドを設定して（図4及びセクション4.3.1を参照）預言者ヘッダと単一ハローTLVから成ります。"
    },
    {
      "indent": 3,
      "text": "The state of the L flag in the latest SYN or SYNACK message is recorded in the node that receives the message. If the L flag is set (value 1), the receiving node MUST send the payload length for each bundle that it offers to the peer during the Information Exchange Phase.",
      "ja": "最新SYNまたはSYNACKメッセージにおけるLフラグの状態は、メッセージを受信するノードに記録されています。 Lフラグ（値1）に設定されている場合、受信ノードは、情報交換フェーズ中にピアに提供し、各バンドルのペイロード長を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "The rules and state tables use the following operations:",
      "ja": "ルールと状態テーブルには、次の操作を使用します。"
    },
    {
      "indent": 3,
      "text": "o The \"Update Peer Verifier\" operation is defined as storing the values of the Sender Instance and Sender Local Address fields from a Hello SYN or Hello SYNACK function message received from the entity at the far end of the link.",
      "ja": "O「更新ピア検証」操作は、リンクの遠端のエンティティから受信したハローSYNまたはハローSYNACK機能メッセージから送信者インスタンスとSenderローカルアドレスフィールドの値を記憶するものとして定義されます。"
    },
    {
      "indent": 3,
      "text": "o The procedure \"Reset the link\" is defined as:",
      "ja": "O手順「のリンクをリセット」を次のように定義されます"
    },
    {
      "indent": 6,
      "text": "When using TCP or other reliable connection-oriented transport: Close the connection and terminate any separate thread or process managing the connection.",
      "ja": "TCPまたは他の信頼性の高い接続指向のトランスポートを使用する場合：接続を閉じ、接続を管理する任意の別のスレッドやプロセスを終了。"
    },
    {
      "indent": 6,
      "text": "Otherwise:",
      "ja": "そうでなければ："
    },
    {
      "indent": 11,
      "text": "1. Generate a new instance number for the link.",
      "section_title": true,
      "ja": "1.リンクの新しいインスタンス番号を生成します。"
    },
    {
      "indent": 11,
      "text": "2. Delete the peer verifier (set to zero the values of Sender Instance and Sender Local Address previously stored by the Update Peer Verifier operation).",
      "ja": "2.ピア検証（以前に更新ピア検証動作によって記憶された送信者のインスタンスの値をゼロに設定し、送信者のローカルアドレス）を削除します。"
    },
    {
      "indent": 11,
      "text": "3. Send a SYN message.",
      "section_title": true,
      "ja": "3. SYNメッセージを送信します。"
    },
    {
      "indent": 11,
      "text": "4. Transition to the SYNSENT state.",
      "section_title": true,
      "ja": "SYNSENT状態に4.遷移。"
    },
    {
      "indent": 3,
      "text": "o The state tables use the following Boolean terms and operators:",
      "ja": "状態テーブルには、次のブール用語と演算子を使用○："
    },
    {
      "indent": 6,
      "text": "A The Sender Instance in the incoming message matches the value stored from a previous message by the \"Update Peer Verifier\" operation.",
      "ja": "着信メッセージに送信者のインスタンスは、「更新ピア検証」操作によって以前のメッセージから格納された値と一致します。"
    },
    {
      "indent": 6,
      "text": "B The Sender Instance and Sender Local Address fields in the incoming message match the values stored from a previous message by the \"Update Peer Verifier\" operation.",
      "ja": "着信メッセージに送信者インスタンスとSenderローカルアドレスフィールドB「更新ピア検証」操作によって以前のメッセージから格納された値と一致します。"
    },
    {
      "indent": 6,
      "text": "C The Receiver Instance and Receiver Local Address fields in the incoming message match the values of the Sender Instance and Sender Local Address used in outgoing Hello SYN, Hello SYNACK, and Hello ACK messages.",
      "ja": "着信メッセージでCザ受信インスタンスとレシーバローカルアドレスフィールドは、発信ハローSYN、ハローSYNACK、およびハローACKメッセージで使用される送信者インスタンスとSenderローカルアドレスの値と一致します。"
    },
    {
      "indent": 6,
      "text": "SYN A Hello SYN message has been received.",
      "ja": "SYN AこんにちはSYNメッセージが受信されています。"
    },
    {
      "indent": 6,
      "text": "SYNACK A Hello SYNACK message has been received.",
      "ja": "SYNACK AこんにちはSYNACKメッセージが受信されています。"
    },
    {
      "indent": 6,
      "text": "ACK A Hello ACK message has been received.",
      "ja": "ACK AこんにちはACKメッセージが受信されています。"
    },
    {
      "indent": 6,
      "text": "&& Represents the logical AND operation",
      "ja": "&&論理AND演算を表します"
    },
    {
      "indent": 6,
      "text": "|| Represents the logical OR operation",
      "ja": "||論理OR演算を表します"
    },
    {
      "indent": 6,
      "text": "! Represents the logical negation (NOT) operation.",
      "ja": "！論理否定（NOT）演算を表します。"
    },
    {
      "indent": 3,
      "text": "o A timer is required for the periodic generation of Hello SYN, Hello SYNACK, and Hello ACK messages. The value of the timer is announced in the Timer field. To avoid synchronization effects, uniformly distributed random jitter of +/-5% of the Timer field SHOULD be added to the actual interval used for the timer.",
      "ja": "OタイマはこんにちはSYN、こんにちはSYNACK、およびこんにちはACKメッセージを定期的に生成するために必要です。タイマーの値は、Timerフィールドで発表されます。同期の影響を回避するために、Timerフィールドの+/- 5％の均一に分布したランダムジッタは、タイマに使用される実際の間隔に加えられるべきです。"
    },
    {
      "indent": 6,
      "text": "There are two independent events: the timer expires, and a packet arrives. The processing rules for these events are:",
      "ja": "タイマーが満了し、かつパケットが到着した：そこ二つの独立したイベントです。これらのイベントの処理ルールは以下のとおりです。"
    },
    {
      "indent": 13,
      "text": "Timer Expires:  Reset Timer\n                If state = SYNSENT Send SYN message\n                If state = SYNRCVD Send SYNACK message\n                If state = ESTAB   Send ACK message",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Packet Arrives: If incoming message is an RSTACK message: If (A && C && !SYNSENT) Reset the link Else discard the message. If incoming message is a SYN, SYNACK, or ACK message: Response defined by the following State Tables. If incoming message is any other PRoPHET TLV and state != ESTAB: Discard incoming message. If state = SYNSENT Send SYN message(Note 1) If state = SYNRCVD Send SYNACK message(Note 1)",
      "ja": "パケットが到着：着信メッセージがRSTACKメッセージである場合：（！&& C && SYNSENT）それ以外のリンクはメッセージを破棄リセットした場合。着信メッセージはSYN、SYNACK、またはACKメッセージである場合は、次の応答は、次の状態テーブルによって定義されます。 ！着信メッセージが、他の預言者TLVと状態= ESTABの場合：受信メッセージを破棄します。状態= SYNSENTにSYNメッセージを送信する場合の状態= SYNRCVDはSYNACKメッセージを（注1）送信する場合（注1）"
    },
    {
      "indent": 12,
      "text": "Note 1: No more than two SYN or SYNACK messages should be sent within any time period of length defined by the timer.",
      "ja": "注1：これ以上の2以上のSYNまたはSYNACKメッセージは、タイマーによって定義された長さの任意の時間内に送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "o A connection across a link is considered to be achieved when the protocol reaches the ESTAB state. All TLVs, other than Hello TLVs, that are received before synchronization is achieved will be discarded.",
      "ja": "Oリンクを介して接続は、プロトコルがESTAB状態に到達したときに達成されると考えられます。同期が達成される前に受信されているこんにちはのTLV以外のすべてのTLVは、破棄されます。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Hello Procedure State Tables",
      "section_title": true,
      "ja": "5.2.1。こんにちは手順状態テーブル"
    },
    {
      "indent": 4,
      "text": "State: SYNSENT",
      "ja": "状態：SYNSENT"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|     Condition    |               Action              | New State |\n+==================+===================================+===========+\n|   SYNACK && C    |       Update Peer Verifier;       |   ESTAB   |\n|                  |       Send ACK message            |           |\n+------------------+-----------------------------------+-----------+\n|   SYNACK && !C   |       Send RSTACK message         |  SYNSENT  |\n+------------------+-----------------------------------+-----------+\n|       SYN        |       Update Peer Verifier;       |  SYNRCVD  |\n|                  |       Send SYNACK message         |           |\n+------------------+-----------------------------------+-----------+\n|       ACK        |       Send RSTACK message         |  SYNSENT  |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "State: SYNRCVD",
      "ja": "状態：SYNRCVD"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|    Condition     |               Action              | New State |\n+==================+===================================+===========+\n|   SYNACK && C    |       Update Peer Verifier;       |   ESTAB   |\n|                  |       Send ACK message            |           |\n+------------------+-----------------------------------+-----------+\n|   SYNACK && !C   |       Send RSTACK message         |  SYNRCVD  |\n+------------------+-----------------------------------+-----------+\n|       SYN        |       Update Peer Verifier;       |  SYNRCVD  |\n|                  |       Send SYNACK message         |           |\n+------------------+-----------------------------------+-----------+\n|  ACK && B && C   |       Send ACK message            |   ESTAB   |\n+------------------+-----------------------------------+-----------+\n| ACK && !(B && C) |       Send RSTACK message         |  SYNRCVD  |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "State: ESTAB",
      "ja": "状態：ESTAB"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|    Condition    |               Action               | New State |\n+=================+====================================+===========+\n|  SYN || SYNACK  | Send ACK message (notes 2 and 3)  |   ESTAB   |\n+-----------------+------------------------------------+-----------+\n|  ACK && B && C  | Send ACK message (note 3)          |   ESTAB   |\n+-----------------+------------------------------------+-----------+\n| ACK && !(B && C)|          Send RSTACK message       |   ESTAB   |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Note 2: No more than two ACK messages should be sent within any time period of length defined by the timer. Thus, one ACK message MUST be sent every time the timer expires. In addition, one further ACK message may be sent between timer expirations if the incoming message is a SYN or SYNACK. This additional ACK allows the Hello functions to reach synchronization more quickly.",
      "ja": "注2：いいえつ以上のACKメッセージは、タイマーによって定義された長さの任意の時間内に送信されるべきではありません。したがって、一つのACKメッセージは、タイマーが切れるたびに送らなければなりません。着信メッセージがSYNまたはSYNACKであればさらに、1つの更なるACKメッセージは、タイマー期限切れの間で送信されても​​よいです。この追加のACKハロー機能をより迅速に、同期に到達することができます。"
    },
    {
      "indent": 6,
      "text": "Note 3: No more than one ACK message should be sent within any time period of length defined by the timer.",
      "ja": "注3：1つのACKメッセージを超えない、タイマーによって定義された長さの任意の期間内に送信されるべきです。"
    },
    {
      "indent": 0,
      "text": "5.3. Information Exchange Phase",
      "section_title": true,
      "ja": "5.3。情報交換フェーズ"
    },
    {
      "indent": 3,
      "text": "After the Hello messages have been exchanged, and the nodes are in the ESTAB state, the Information Exchange Phase, consisting of the RIB Exchange and Bundle Passing Sub-Phases, is initiated. This section describes the procedure and shows the state transitions necessary in these sub-phases; the following sections describe in detail the various TLVs passed in these phases. On reaching the ESTAB state in the high-level HELLO state, there is an automatic transition to the INFO_EXCH high-level state.",
      "ja": "Helloメッセージが交換されており、ノードがESTAB状態になった後、サブフェーズを渡すRIB Exchangeおよびバンドルから成る情報交換フェーズは、開始されます。このセクションでは、手順を説明し、これらのサブフェーズで必要な状態遷移を示す図です。次のセクションでは、詳細にこれらのフェーズに渡された様々なTLVを説明します。ハイレベルのHELLO状態ESTAB状態に達すると、INFO_EXCHハイレベルの状態への自動移行があります。"
    },
    {
      "indent": 3,
      "text": "PRoPHET runs over a bidirectional transport as documented in Section 1.2 so that when a pair of nodes (A and B) have reached the ESTAB state, they are able to perform the Information Exchange Phase processes for both the A-to-B and B-to-A directions over the link that has just been established. In principle, these two processes are independent of each other and can be performed concurrently. However, complete concurrency may not be the most efficient way to implement the complete process. As explained in Section 3.2.1, the Routing Information Base Dictionary is a shared resource assembled from a combination of information generated locally on each node and information passed from the peer node. Overlaps in this information, and hence the amount of information that has to be passed between the nodes, can be minimized by sequential rather than concurrent operation of the dictionary generation and update processes. It may also be possible to reduce the number of bundles that need to be offered by the second offeror by examining the offers received from the first offeror -- there is no need for the second offeror to offer a bundle that is already present in the first offeror's offer list, as it will inevitably be refused.",
      "ja": "ノード（AおよびB）のペアがESTAB状態に達したとき、それらはA-B-およびB-両方に情報交換フェーズの処理を実行することができるように、セクション1.2に記載のように預言者は、双方向トランスポートを介して実行されちょうど確立されたリンク上に-A方向。原理的には、これら2つのプロセスが互いに独立していると同時に実行することができます。しかし、完全な同時性は完全なプロセスを実装するための最も効率的な方法ではないかもしれません。セクション3.2.1で説明したように、ルーティング情報ベース辞書は、ピア・ノードから渡された各ノードと情報をローカルに生成された情報の組み合わせから組み立てられた共有リソースです。この情報に重なり、ノード間で渡さなければならない情報の量は、したがって、辞書の生成及び更新過程の連続ではなく、同時操作によって最小化することができます。また、最初の買付者から受信したオファーを検討することにより、第2の公開買付者によって提供される必要があるバンドルの数を低減することができる - すでに最初に存在するバンドルを提供するために第2の公開買付者のための必要はありません公開買付者の申し出リスト、それは必然的に拒否されますよう。"
    },
    {
      "indent": 3,
      "text": "All implementations MUST be capable of operating in a fully concurrent manner. Each implementation needs to define a policy, which SHOULD be configurable, as to whether it will operate in a concurrent or sequential manner during the Information Exchange Phase. If it is to operate sequentially, then further choices can be made as to whether to interleave dictionary, offer, and response exchange parts, or to complete all parts in one direction before initiating the other direction.",
      "ja": "すべての実装は、完全に同時的に動作させることができなければなりません。各実装は、それが情報交換フェーズ中に、同時または連続的に動作するかどうかについて、設定可能であるべき、ポリシーを定義する必要があります。それは順次動作させる場合には、更なる選択肢は、辞書、提供、および応答の交換パーツをインターリーブする、または他の方向を開始する前に、一方向のすべての部分を完了するか否かを判定することができます。"
    },
    {
      "indent": 3,
      "text": "Sequential operation will generally minimize the amount of data transferred across the PRoPHET link and is especially appropriate if the link is half-duplex. However it is probably not desirable to postpone starting the information exchange in the second direction until the exchange of bundles has completed. If the contact between the nodes ends before all possible bundles have been exchanged, it is possible that postponing the start of bundle exchange in the second direction can lead to bundle exchange being skewed in favor of one direction over the other. It may be preferable to share the available contact time and bandwidth between directions by overlapping the Information Exchange Phases and running the actual bundle exchanges concurrently if possible. Also, if encounters expected in the current PRoPHET zone are expected to be relatively short, it MAY not be appropriate to use sequential operation.",
      "ja": "一連の動作は、一般に、預言者のリンクを介して転送されるデータの量を最小限にし、リンクが半二重である場合に特に適しているであろう。しかしバンドルの交換が完了するまで、第二方向での情報交換を開始延期するだろうことは望ましくありません。すべての可能なバンドルが交換されている前に、ノード間の接触が終了した場合、第2の方向にバンドル交換の開始を延期することは、他の上の1つの方向に有利に偏っされている為替をバンドルにつながることが可能です。情報交換フェーズをオーバーラップし、可能な場合、同時に実際のバンドル交換を実行することにより、方向との間の利用可能な接触時間と帯域幅を共有することが好ましいかもしれません。現在の預言者ゾーンに期待出会いが比較的短いことが予想される場合にも、一連の動作を使用することは適切ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "One possible interleaving strategy is to alternate between sending from the two nodes. For example, if the Hello SYN node sends its initial dictionary entries while the Hello SYNACK node waits until this is complete, the Hello SYNACK node can then prune its proposed dictionary entries before sending in order to avoid duplication. This approach can be repeated for the second tranche of dictionary entries needed for the Bundle Offers and Responses, and also for the Bundle Offers, where any bundles that are offered by the Hello SYN node that are already present in the Hello SYNACK node need not be offered to the Hello SYN node. This approach is well suited to a transport protocol and physical medium that is effectively half-duplex.",
      "ja": "一つの可能​​なインタリーブ戦略は、2つのノードからの送信を交互することです。これが完了するまでのHello SYNACKノードが待機している間、こんにちはSYNノードがその最初の辞書のエントリを送信する場合、例えば、こんにちはSYNACKノードは、重複を避けるために、送信する前にその提案辞書のエントリを剪定することができます。このアプローチは、バンドルオファーと応答のために必要な辞書エントリの第二トランシェについて、またこんにちはSYNACKノードに既に存在しているこんにちはSYNノードによって提供されているすべてのバンドルがある必要はないバンドル提供しています、のために繰り返すことができますこんにちはSYNノードに提供されます。このアプローチは、効果的に半二重であるトランスポートプロトコル及び物理媒体に適しています。"
    },
    {
      "indent": 3,
      "text": "At present, the decision to operate concurrently or sequentially is purely a matter of local policy in each node. If nodes have inconsistent policies, the behavior at each encounter will depend on which node takes the SYN role; this is a matter of chance depending on random timing of the start of communications during the encounter.",
      "ja": "現時点では、同時に又は順次動作する決定は、純粋に各ノードでローカルポリシーの問題です。ノードが一貫性​​のない政策を持っている場合は、それぞれの出会いでの動作がSYNの役割を担っているノードに依存します。これは出会いの間の通信の開始のランダムなタイミングに応じて、チャンスの問題です。"
    },
    {
      "indent": 3,
      "text": "To manage the information transfer, two subsidiary state machines are created in each node to control the stages of the RIB Exchange Sub-Phase and Bundle Passing Sub-Phase processes within the INFO_EXCH high-level state as shown in Figure 12. Each subsidiary state machine consists of two essentially independent components known as the \"Initiator role\" and the \"Listener role\". One of these components is instantiated in each node. The Initiator role starts the Information Exchange Phase in each node and the Listener role responds to the initial messages, but it is not a passive listener as it also originates messages. The transition from the ESTAB state is a \"forking\" transition in that it starts both subsidiary state machines. The two subsidiary state machines operate in parallel for as long as the neighbor remains in range and connected.",
      "ja": "図12.各副状態マシンに示すように、情報転送を管理するために、二つの補助ステートマシンはINFO_EXCHハイレベルの状態内のサブフェーズのプロセスを渡すRIB交換サブフェーズおよびバンドルのステージを制御するために、各ノードに作成され「イニシエータの役割」と「リスナーの役割」として知られている2つの基本的独立したコンポーネントで構成されています。これらの成分の一つは、各ノードでインスタンス化されます。イニシエータの役割は、各ノードに情報交換フェーズを開始し、リスナーの役割は、最初のメッセージに応答しますが、それはまた、メッセージを発信するように、受動的なリスナーではありません。 ESTABの状態からの移行が、それは両方の子会社ステートマシンを起動することで、「フォーク」の移行です。 2台の副状態機械であれば、近隣範囲および接続に留まるようにするために並列に動作します。"
    },
    {
      "indent": 3,
      "text": "+ - - - - - - - - + + - - - - - - - - +",
      "ja": "＋ ー ー ー ー ー ー ー ー ＋ ＋ ー ー ー ー ー ー ー ー ＋"
    },
    {
      "indent": 3,
      "text": "| SYN node | PRoPHET messages with: | SYNACK node |",
      "ja": "| SYNノード|預言者のメッセージ：| SYNACKノード|"
    },
    {
      "indent": 3,
      "text": "| +-------------+ | A. Delivery Predictabilities | +-------------+ |\n  | Subsidiary  |--->---->---->---->---->---->---->| Subsidiary  |\n| |   State     | | C. Bundle Responses          | |   State     | |\n  | Machine 1:  |                                  | Machine 1:  |\n| |  Initiator  | | B. Bundle Offers             | |  Listener   | |\n  |    Role     |<----<----<----<----<----<----<---|    Role     |\n| +-------------+ | D. Requested Bundles         | +-------------+ |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| +-------------+ | A. Delivery Predictabilities | +-------------+ |\n  | Subsidiary  |<----<----<----<----<----<----<---| Subsidiary  |\n| |   State     | | C. Bundle Responses          | |   State     | |\n  | Machine 2:  |                                  | Machine 2:  |\n| |  Listener   | | B. Bundle Offers             | |  Initiator  | |\n  |    Role     |--->---->---->---->---->---->---->|    Role     |\n| +-------------+ | D. Requested Bundles         | +-------------+ |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+ - - - - - - - - + + - - - - - - - - +",
      "ja": "＋ ー ー ー ー ー ー ー ー ＋ ＋ ー ー ー ー ー ー ー ー ＋"
    },
    {
      "indent": 9,
      "text": "The letters (A - D) indicate the sequencing of messages.",
      "ja": "文字（A  -  D）は、メッセージの順序付けを示しています。"
    },
    {
      "indent": 6,
      "text": "Figure 12: Information Exchange Phase Subsidiary State Machines",
      "ja": "図12：情報交換フェーズ子会社ステートマシン"
    },
    {
      "indent": 3,
      "text": "These subsidiary state machines can be thought of as mirror images: for each state machine, one node takes on the Initiator role while the other node takes on the Listener role. TLVs sent by a node from the Initiator role will be processed by the peer node in the Listener role and vice versa. As indicated in Figure 12, the Initiator role handles sending that node's current set of delivery predictabilities for known destinations to the Listener role node. The Listener role node uses the supplied values to update its delivery predictabilities according to the update algorithms described in Section 2.1.2. It then decides which bundles that it has in store should be offered for transfer to the Initiator role node as a result of comparing the local predictabilities and those supplied by the Initiator node. When these offers are delivered to the Initiator role node, it decides which ones to accept and supplies the Listener role node with a prioritized list of bundles that it wishes to accept. The Listener role node then sends the requested bundles.",
      "ja": "これらの子会社ステート・マシンは、鏡像と考えることができます。他のノードは、リスナーの役割を引き受けながら、各ステートマシンのために、1つのノードがイニシエータの役割を引き受けます。イニシエータの役割からノードによって送信されたのTLVは、リスナーの役割およびその逆にピア・ノードによって処理されます。図12に示すように、イニシエータの役割は、リスナーのロールノードに知られている宛先に配信予測精度のそのノードの現在のセットを送信する処理します。リスナーロールノードは、セクション2.1.2に記載した更新アルゴリズムに従ってその送達予測精度を更新するために供給された値を使用します。それは、それがローカル予測精度とイニシエータノードによって供給されるものを比較した結果としてイニシエータロールノードに転送するために提供されるべきである店で持っていることをバンドルかを決定します。これらの申し出がイニシエータの役割のノードに配信されている場合、それはものが受け入れることを決定したし、それが受け入れを希望するバンドルの優先順位リストでのリスナーのロールノードを提供します。リスナーの役割ノードは、要求されたバンドルを送信します。"
    },
    {
      "indent": 3,
      "text": "These exchanges are repeated periodically for as long as the nodes remain in contact. Additionally, if new bundles arrive from other sources, they may be offered, accepted, and sent in between these exchanges.",
      "ja": "これらの交換は限りノードが接触したままとするために周期的に繰り返されます。新しいバンドルが他のソースから到着する場合に加えて、それらは、提供される受け入れ、これらの交換機間で送信されても​​よいです。"
    },
    {
      "indent": 3,
      "text": "The PRoPHET protocol is designed so that in most cases the TLV type determines the role in which it will be processed on reception. The only exception to this is that both roles may send RIB Dictionary TLVs: the Initiator role sends dictionary entries for use in the subsequent RIB TLV(s), and the Listener role may send additional dictionary entries for use in subsequent Bundle Offer TLVs. The two cases are distinguished by a TLV flag to ensure that they are processed in the right role context on reception. If this flag was not provided, there are states where both roles could accept the RIB Dictionary TLV, making it impossible to ensure that the correct role state machine accepts the RIB Dictionary TLV. Note that the correct updates would be made to the dictionary whichever role processed the TLV and that the ambiguity would not arise if the roles are adopted completely sequentially, i.e., if the RIB Exchange Sub-Phase and associated Bundle Passing Sub-Phase run to completion in one direction before the process for the reverse direction is started.",
      "ja": "ほとんどの場合、TLVタイプは、それが受信時に処理される役割を決定するように預言者のプロトコルが設計されています。イニシエータの役割は、その後のRIB TLV（複数可）で使用するための辞書エントリを送信し、リスナーの役割は、後続のバンドルオファーのTLVで使用するための追加の辞書エントリを送ることがあります。これに対する唯一の例外は、両方の役割がRIB辞書TLVを送ることです。 2例は、それらが受信上の右役割コンテキストで処理されることを保証するためにTLVフラグによって区別されます。このフラグが提供されなかった場合は、両方の役割は、それが不可能正しい役割ステートマシンがRIB辞書TLVを受け入れていることを確認すること、RIB辞書TLVを受け入れることができる状態が存在します。 RIB交換サブフェーズと関連バンドルが完了するサブフェーズの実行を渡す場合は、正しい更新は、役割がTLVを処理し、ロールが完全に順次採用されている場合に曖昧さが生じないこと、すなわち、いずれの辞書になされるであろうことに注意してください一つの方向に逆方向のためのプロセスが開始される前に。"
    },
    {
      "indent": 3,
      "text": "If sequential operation is selected, the node that sent the Hello SYN function message MUST be the node that sends the first message in the Information Exchange Phase process. This ensures that there is a well-defined order of events with the Initiator role in the Hello SYN node (i.e., the node identified by String ID 0) starting first. The Hello SYNACK node MAY then postpone sending its first message until the Listener role state machine in the Hello SYNACK node has reached any of a number of points in its state progression according to locally configured policy and the nature of the physical link for the current encounter between the nodes as described above. If concurrent operation is selected, the Hello SYNACK node can start sending messages immediately without waiting to receive messages from the peer.",
      "ja": "一連の動作を選択した場合、こんにちはSYN機能メッセージを送信したノードは、情報交換フェーズプロセスの最初のメッセージを送信したノードでなければなりません。これはハローSYNノードにおけるイニシエータの役割を持つイベントの明確に定義された順序が存在することを確実にする（すなわち、文字列ID 0によって識別されるノード）最初の起動。ハローSYNACKノードのリスナーの役割状態機械がその状態の進行の点の数のいずれかに達するまでハローSYNACKノードは、ローカルに設定されたポリシーと現在の出会いのための物理的なリンクの性質に応じて、その最初のメッセージを送信延期MAY上記のように、ノード間。同時動作が選択されている場合は、こんにちはSYNACKノードは、ピアからのメッセージを受信するために待つことなく、すぐにメッセージの送信を開始することができます。"
    },
    {
      "indent": 3,
      "text": "The original design of the PRoPHET protocol allowed it to operate over unreliable datagram-type transports as well as the reliable, in-order delivery transport of TCP that is currently specified. When running over TCP, protocol errors and repeated timeouts during the Information Exchange Phase SHOULD result in the connection being terminated.",
      "ja": "預言者のプロトコルのオリジナルデザインは、それが現在指定されているTCPの信頼性、インオーダーデリバリー・トランスポートとしてだけでなく、信頼性の低いデータグラム型の上に運ぶ動作させます。 TCP上で実行している場合には、情報交換フェーズ中にプロトコル・エラーを繰り返しタイムアウトが終了され、接続を生じるはずです。"
    },
    {
      "indent": 0,
      "text": "5.3.1. State Definitions for the Initiator Role",
      "section_title": true,
      "ja": "5.3.1。イニシエータの役割のための状態の定義"
    },
    {
      "indent": 3,
      "text": "The state machine component with the Initiator role in each node starts the transfer of information from one node to its peer during the Information Exchange Phase. The process from the Initiator's point of view does the following:",
      "ja": "各ノードにおけるイニシエータの役割を持つ状態機械要素は、情報交換フェーズの間にそのピアへの1つのノードからの情報の転送を開始します。ビューの開始の時点からプロセスは、以下のことを実行します。"
    },
    {
      "indent": 3,
      "text": "o The Initiator role determines the set of delivery predictabilities to be sent to the peer node and sends RIB dictionary entries necessary to interpret the set of RIB predictability values that are sent after the dictionary updates. On second and subsequent executions of this state machine during a single session with the same peer, there may be no RIB Dictionary entries to send. Either an empty TLV can be sent or the TLV can be omitted.",
      "ja": "イニシエータの役割oをピア・ノードに送信される配信予測精度のセットを決定し、辞書の更新後に送信されたRIBの予測値のセットを解釈する必要RIB辞書エントリを送信します。同じピアとの単一のセッションの間にこの状態マシンの第二以降の実行で、送るべきRIB辞書エントリが存在しない場合があります。どちらの空のTLVを送信することができますかTLVを省略することができます。"
    },
    {
      "indent": 3,
      "text": "o The Initiator then waits to receive any RIB Dictionary updates followed by bundle offers from the Listener role on the peer node.",
      "ja": "Oイニシエータは、ピア・ノード上のリスナーロールから提供束続く任意RIB辞書の更新を受信するのを待ちます。"
    },
    {
      "indent": 3,
      "text": "o The Initiator determines which of the bundle offers should be accepted and, if necessary, reorders the offers to suit its own priorities. The possibly reordered list of accepted bundles is sent to the peer node using one or more bundle responses.",
      "ja": "イニシエータは、必要に応じて、受け入れられ、しなければならないバンドルオファーのかを判断O、独自の優先順位に合わせてオファーを並べ替えます。受け入れバンドルの可能性再順序付けリストは、一つ以上のバンドル応答を使用して、ピア・ノードに送信されます。"
    },
    {
      "indent": 3,
      "text": "o The peer then sends the accepted bundles to the Initiator in turn.",
      "ja": "Oピアはその後、順番にイニシエータに受け入れられたバンドルを送信します。"
    },
    {
      "indent": 3,
      "text": "o Assuming that the link remains open during the bundle sending process, the Initiator signals that the Bundle Passing Sub-Phase is complete by sending a message with an empty Bundle Response TLV (i.e, with the Bundle Offer Count set to 0 and no bundle offers following the TLV header).",
      "ja": "リンクバンドルの送信処理中に開いたままと仮定するとoを、バンドルサブフェーズを渡す開始信号が0に設定されたカウントバンドルオファーなしバンドル提供で、すなわち空のバンドル応答TLV（とメッセージを送信することにより完了しています）TLVヘッダに続きます。"
    },
    {
      "indent": 3,
      "text": "o When the bundle transfer is complete, the Initiator starts the Timer(next_exchange). Assuming that the connection to the neighbor remains open, when the timer expires, the Initiator restarts the Information Exchange Phase. During this period, Hello SYN messages are exchanged as keep-alives to check that the neighbor is still present. The keep-alive mechanism is common to the Initiator and Listener machines and is handled in the high-level state machine (see Section 5.1.",
      "ja": "バンドルの転送が完了すると、O、イニシエータは、タイマ（next_exchange）を開始します。タイマーが満了したとき隣人への接続は、開いたままと仮定すると、イニシエータは、情報交換のフェーズを再起動します。この期間中、こんにちはSYNメッセージは、隣人がまだ存在していることを確認するためにキープアライブとして交換されています。キープアライブメカニズムは、イニシエータとリスナーのマシンに共通であり、高レベルのステートマシンで処理されます（5.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "A timer is provided that restarts the Initiator role state machine if Bundle Offers are not received after sending the RIB. If this node receives a Hello ACK message containing an Error TLV indicating there has been a protocol problem, then the connection MUST be terminated.",
      "ja": "タイマーがバンドルオファーがRIBを送信した後に受信されない場合、イニシエータ役割・ステート・マシンを再起動するように提供されます。このノードは、プロトコル問題があった旨のエラーTLVを含むハローACKメッセージを受信した場合、接続は終了されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following states are used:",
      "ja": "以下の状態が使用されます。"
    },
    {
      "indent": 3,
      "text": "CREATE_DR The initial transition to this state from the ESTAB state is immediate and automatic for the node that sent the Hello SYN message. For the peer (Hello SYNACK sender) node, it may be immediate for nodes implementing a fully concurrent process or may be postponed until the corresponding Listener has reached a specified state if a sequential process is configured in the node policy.",
      "ja": "ESTAB状態からこの状態にCREATE_DR初期転移ハローSYNメッセージを送信したノードのための迅速かつ自動的に行われます。ピア（ハローSYNACK送信側）ノードのために、それは完全に並行処理を実装するノードのために即時であってもよいし、逐次処理はノードポリシーで構成されている場合、対応するリスナーが指定された状態に達するまで延期されてもよいです。"
    },
    {
      "indent": 6,
      "text": "The local dictionary is initialized when this state is entered for the first time from the ESTAB state. The initial state of the dictionary contains two entries: the EID of the node that sent the Hello SYN (String ID 0) and the EID of the node that sent the Hello SYNACK (String ID 1). If the peer reports via a Hello ACK message containing an Error TLV reporting a Dictionary Conflict or Bad String ID error, then the connection MUST be terminated.",
      "ja": "この状態がESTAB状態から最初に入力されたときに、ローカル辞書が初期化されます。ハローSYN（文字列ID 0）とハローSYNACK（文字列ID 1）を送信したノードのEIDを送信したノードのEID：辞書の初期状態は、2つのエントリを含んでいます。こんにちはACKメッセージを経由してピアレポートは、辞書紛争や不正文字列IDのエラーを報告するエラーTLVを含む場合、接続は終了されなければなりません。"
    },
    {
      "indent": 6,
      "text": "The CREATE_DR state will be entered in the same way from the REQUEST state when the Timer(next_exchange) expires, signaling the start of a new round of information exchange and bundle passing.",
      "ja": "タイマ（next_exchange）が満了したときCREATE_DR状態が情報交換及び束通過の新ラウンドの開始をシグナリング、REQUEST状態から同様に入力されます。"
    },
    {
      "indent": 6,
      "text": "When in this state:",
      "ja": "この状態で："
    },
    {
      "indent": 6,
      "text": "* Determine the destination EIDs for which delivery predictabilities will be sent to the peer in a RIB TLV, if any. Record the prior state of the local dictionary (assuming that String IDs are numbers allocated sequentially, the state information needed is just the highest ID used before this process started) so that the process can be restarted if necessary. Update the local dictionary if any new EIDS are required; format one or more RIB Dictionary TLVs and one or more RIB TLVs and send them to the peer. If there are no dictionary entries to send, TLVs with zero entries MAY be sent, or the TLV can be omitted, but an empty RIB TLV MUST be sent if there is no data to send. The RIB Dictionary TLVs generated here MUST have the Sent by Listener flag set to 0 to indicate that they were sent by the Initiator.",
      "ja": "*配信予測精度がRIB TLVにピアに送信されるため、宛先のEID（存在する場合）を決定します。必要に応じてプロセスを再起動することができるように（文字列IDが連続して割り当てられた番号であると仮定すると、必要な状態情報は、このプロセスが開始する前に、使用するだけ最高IDである）ローカル辞書の前の状態を記録します。新たなEIDSが必要な場合は、ローカル辞書を更新します。形式一つ以上のRIB辞書のTLVと1つ以上のRIBのTLVとピアに送信します。送るべき辞書エントリが存在しない場合は、ゼロのエントリを持つTLVが送られるかもしれない、またはTLVを省略することができますが、送信するデータがない場合は、空のRIBのTLVを送らなければなりません。ここで生成されたRIB辞書のTLVは、それらは、イニシエータによって送信されたことを示すために0に設定リスナーフラグによって送信されている必要があります。"
    },
    {
      "indent": 6,
      "text": "* If an Error TLV indicating a Dictionary Conflict or Bad String ID is received during or after sending the RIB Dictionary TLVs and/or the RIB TLVs, abort any in-progress Initiator or Listener process, and terminate the connection to the peer.",
      "ja": "*辞書競合又はバッドストリングIDを示すエラーTLV中またはRIB辞書のTLV及び/又はRIBのTLVを送信した後に受信された場合、任意の進行中の開始剤またはリスナープロセスを中止し、ピアとの接続を終了します。"
    },
    {
      "indent": 6,
      "text": "* Start a timer (known as Timer(info)) and transition to the SEND_DR state.",
      "ja": "*（タイマー（情報）として知られている）、タイマーとSEND_DR状態への移行を開始します。"
    },
    {
      "indent": 6,
      "text": "Note that when (and only when) running over a transport protocol such as TCP, both the RIB Dictionary and RIB information MAY be spread across multiple TLVs and messages if required by known constraints of the transport protocol or to reduce the size of memory buffers. Alternatively, the information can be formatted using a single RIB Dictionary TLV and a single RIB TLV. These TLVs may be quite large, so it may be necessary to segment the message either using the PRoPHET submessage capability or, if the transport protocol has appropriate capabilities, using those inherent capabilities. This discussion of segmentation applies to the other states and the bundle offer and bundle response messages and will not be repeated.",
      "ja": "場合（および場合にのみ）、TCPなどのトランスポートプロトコル上で実行RIB辞書、RIB情報の両方をトランスポートプロトコルの既知の制約によって必要またはメモリバッファのサイズを小さくする場合は、複数のTLV及びメッセージに分散されてもよいことに留意されたいです。あるいは、情報は、単一のRIB辞書TLV及び単一RIBのTLVを使用してフォーマットすることができます。トランスポートプロトコルは、それらの固有の機能を使用して、適切な能力を有する場合、それは、いずれかのメッセージセグメントに必要である預言者のサブメッセージ機能を使用するかできるように、これらのTLVは、非常に大きくてもよいです。セグメンテーションのこの議論は他州とのバンドル提供とバンドル応答メッセージに適用され、繰り返されることはありません。"
    },
    {
      "indent": 6,
      "text": "If more than one RIB TLV is to be used, all but the last one have the \"More RIB TLVs\" flag set to 1 in the TLV flags. It is not necessary to distinguish the last RIB Dictionary TLV because the actions taken at the receiver are essentially passive (recording the contents), and the sequence is ended by the sending of the first RIB TLV.",
      "ja": "複数のRIB TLVを使用する場合は、すべてが、最後の一つはTLVフラグが1に設定されている「その他のRIBのTLV」フラグを持っています。受信機で行われる動作は、（コンテンツを記録）本質的に受動的であり、配列は第1リブTLVを送信することによって終了されるので、最後のRIB辞書TLVを区別する必要がありません。"
    },
    {
      "indent": 3,
      "text": "SEND_DR In this state, the Initiator node expects to be receiving Bundle Offers and sending Bundle Responses. The Initiator node builds a list of bundles offered by the peer while in this state:",
      "ja": "この状態でSEND_DR、イニシエータノードは、バンドルオファーを受け取り、バンドル応答を送信することを期待します。イニシエータノードがこの状態にある間にピアによって提供されるバンドルのリストを構築します。"
    },
    {
      "indent": 6,
      "text": "* Clear the set of bundles offered by the peer on entry to the state.",
      "ja": "*クリア状態にエントリのピアによって提供されるバンドルのセット。"
    },
    {
      "indent": 6,
      "text": "* If the Timer(info) expires, re-send the RIB Dictionary and RIB information sent in the previous CREATE_DR state using the stored state to re-create the information. The RIB dictionary update process in the peer is idempotent provided that the mappings between the EID and the String ID in the re-sent RIB Dictionary TLVs are the same as in the original. This means that it does not matter if some of the RIB Dictionary TLVs had already been processed in the peer. Similarly, re-sending RIB TLVs will not cause a problem.",
      "ja": "*タイマ（情報）が満了した場合は、情報を再作成するために、保存された状態を使用して、以前のCREATE_DR状態で送信されたRIBの辞書とRIB情報を再送信します。ピアでRIB辞書更新処理が冪等は、再送信されたRIB辞書のTLVでEIDと文字列IDの間のマッピングは、元と同じであることが提供されます。これは、RIB辞書のTLVの一部は、すでにピアで処理されていた場合、それは問題ではないことを意味します。同様に、再送信RIBのTLVは、問題が発生することはありません。"
    },
    {
      "indent": 6,
      "text": "* If a message with a RIB Dictionary TLV marked as sent by a Listener is received, update the local dictionary based on the received TLV. If any of the entries in the RIB Dictionary TLV conflict with existing entries (i.e., an entry is received that uses the same String ID as some previously received entry but the EID in the entry is different), send a Response message with an Error TLV containing a Dictionary Conflict indicator, abort any in-progress Initiator or Listener process, and terminate the connection to the peer. Note that in some circumstances no dictionary updates are needed, and the first message received in this state will carry a Bundle Offer TLV.",
      "ja": "*辞書TLVは、リスナーによって送られたとしてマークされたRIBとのメッセージを受信した場合、受信TLVに基づいて、ローカル辞書を更新します。既存のエントリを持つRIB辞書TLVの競合のエントリのいずれかの場合は、エラーTLVで応答メッセージを送信する（すなわち、エントリが受信されることは、いくつかの以前に受信したエントリと同じ文字列のIDを使用していますが、エントリ内のEIDは異なります）辞書競合インジケータを含む、任意の進行中の開始剤またはリスナープロセスを中止し、ピアとの接続を終了します。いくつかの状況では何の辞書の更新が必要とされていないことに注意してください、そして、この状態で受信された最初のメッセージはバンドルオファーTLVを運ぶでしょう。"
    },
    {
      "indent": 6,
      "text": "* If a message with a Bundle Offer TLV is received, restart the Timer(info) if the \"More Offer/Response TLVs Following\" flag is set in the TLV; otherwise, stop the Timer(info). Then process any PRoPHET ACKs in the TLV by informing the bundle protocol agent, and add the bundles offered in the TLV to the set of bundles offered. If the \"More Offer/Response TLVs Following\" flag is set in the TLV, wait for further Bundle Offer TLVs. If a Bundle Offer TLV is received with a String ID that is not in the dictionary, send a message with an Error TLV containing a Bad String ID indicator, abort any in-progress Initiator or Listener process, and terminate the connection to the peer.",
      "ja": "*バンドルオファーTLVを含むメッセージを受信した場合、タイマー（情報）を再起動する場合は、「ほかのオファー/レスポンスのTLVは、以下の」フラグがTLVに設定されています。そうでない場合は、タイマー（情報を）止めます。次に、バンドルプロトコルエージェントを通知することによりTLV内の任意の預言者ACKを処理し、提供されるバンドルのセットにTLVで提供されるバンドルを追加します。 「より多くのオファー/レスポンスのTLVに続いて」フラグがTLVに設定されている場合は、さらにバンドルオファーのTLVを待ちます。バンドルオファーTLVが辞書にない文字列IDと受信した場合、任意の進行中の開始剤またはリスナープロセスを中断、バッドストリングIDインジケータを含むエラーTLVでメッセージを送信し、ピアとの接続を終了します。"
    },
    {
      "indent": 6,
      "text": "* If the \"More Offer/Response TLVs Following\" flag is clear in the last Bundle Offer TLV received, inspect the set of bundles offered to determine the set of bundles that are to be accepted using the configured queueing policy. Record the set of bundles accepted so that reception can be checked in the Bundle Passing Sub-Phase. Format one or more Bundle Response TLVs flagging the accepted offers and send them to the peer. If more than one Bundle Response TLV is sent, all but the last one should have the \"More Offer/Response TLVs Following\" flag set to 1. At least one Bundle Response TLV MUST be sent even if the node does not wish to accept any of the offers. In this case, the Bundle Response TLV contains an empty set of acceptances.",
      "ja": "*もしフラグを「もっとオファー/レスポンスのTLVに続いて」構成されたキューイングポリシーを使用して受け入れられるバンドルのセットを決定することを申し出たバンドルのセットを検査し、TLVが受信した最後のバンドルオファーには明らかです。その受信バンドル渡すサブフェーズでチェックできるように受け入れられてバンドルのセットを記録します。フォーマット一つ以上のバンドル応答のTLV受け入れ申し出にフラグを立てると、ピアに送信します。複数のバンドル応答TLVが送信された場合は、最後の一つを除くすべてが、少なくとも1バンドルレスポンスTLV 1に設定し、「ほかのオファー/レスポンスのTLVに続いて」フラグは、ノードがいずれかを受け入れたくない場合であっても送らなければなりません必要がありますオファーの。この場合、バンドル応答TLVは、承諾の空のセットが含まれています。"
    },
    {
      "indent": 6,
      "text": "* If an Error TLV indicating a Bad String ID is received during or after sending the Bundle Response TLVs, abort any in-progress Initiator or Listener process, re-initialize the local dictionary, and terminate the connection to the peer.",
      "ja": "*バッドストリングIDを示すエラーTLV中またはバンドル応答TLVを送信した後に受信された場合、進行中の開始剤またはリスナープロセスは、ローカル辞書を再初期化、およびピアへの接続を終了任意の中止。"
    },
    {
      "indent": 6,
      "text": "* Restart the Timer(info) timer in case the peer does not start sending the requested bundles.",
      "ja": "*ピアが要求されたバンドルの送信を開始しない場合には、タイマ（情報）タイマーを再起動します。"
    },
    {
      "indent": 6,
      "text": "* Transition to state REQUEST.",
      "ja": "*状態要求への移行。"
    },
    {
      "indent": 3,
      "text": "REQUEST In this state, the Initiator node expects to be receiving the bundles accepted in the Bundle Response TLV(s):",
      "ja": "この状態でREQUEST、イニシエータノードは、バンドル応答TLV（S）で受け付けたバンドルを受信することを期待します。"
    },
    {
      "indent": 6,
      "text": "* Keep track of the bundles received and delete them from the set of bundles accepted.",
      "ja": "*受信の束を追跡し、受け入れられたバンドルのセットからそれらを削除します。"
    },
    {
      "indent": 6,
      "text": "* If the Timer(info) expires while waiting for bundles, format and send one or more Bundle Response TLVs listing the bundles previously accepted but not yet received. If more than one Bundle Response TLV is sent, all but the last one should have the \"More Offer/Response TLVs Following\" flag set to 1.",
      "ja": "*バンドル、フォーマットを待っていると、以前に受け入れられたが、まだ受け取っていないバンドルを一覧一つ以上のバンドル応答TLVを送信しながら、タイマ（情報が）有効期限が切れた場合。複数のバンドル応答TLVが送信された場合は、最後の一つを除くすべてが1に設定されている「その他のオファー/レスポンスのTLVに続いて」旗を持っている必要があります。"
    },
    {
      "indent": 6,
      "text": "* If an Error TLV indicating a Bad String ID is received during or after sending the Bundle Response TLVs, abort any in-progress Initiator or Listener process, re-initialize the local dictionary, and terminate the connection to the peer.",
      "ja": "*バッドストリングIDを示すエラーTLV中またはバンドル応答TLVを送信した後に受信された場合、進行中の開始剤またはリスナープロセスは、ローカル辞書を再初期化、およびピアへの接続を終了任意の中止。"
    },
    {
      "indent": 6,
      "text": "* Restart the Timer(info) timer after each bundle is received in case the peer does not continue sending the requested bundles.",
      "ja": "*各バンドルは、ピアが要求されたバンドルの送信を継続しない場合には受信された後にタイマ（情報）タイマーを再起動します。"
    },
    {
      "indent": 6,
      "text": "* When all the requested bundles have been received, format a Bundle Response TLV with the Bundle Offer Count set to zero and with the \"More Offer/Response TLVs Following\" flag cleared to 0 to signal completion to the peer node. Also, signal the Listener in this node that the Initiator has completed. If the peer node is using a sequential policy, the Listener may still be in the initial state, in which case, it needs to start a timer to ensure that it detects if the peer fails to start the Initiator state machine. Thereafter, coordinate with the Listener state machine in the same node: when the Listener has received the completion notification from the peer node and this Initiator has sent its completion notification, start Timer(next_exchange).",
      "ja": "*すべての要求されたバンドルが受信された、バンドルオファーをピア・ノードに信号完了に0にクリアフラグ「は、以下の詳細オファー/応答のTLV」をゼロにし、と設定したカウントとバンドル応答TLVをフォーマットします。また、イニシエータが完了したこのノードでリスナーを知らせます。ピア・ノードは、順次ポリシーを使用している場合、リスナーはまだ、それはピアがイニシエータ・ステート・マシンを起動に失敗した場合、検出していることを確認するためにタイマーを開始する必要があり、その場合には、初期状態であってもよいです。その後、同じノードでリスナー状態機械と座標：リスナーがピア・ノードからの完了通知を受信し、このイニシエータは、その完了通知を送信したときに、タイマ（next_exchange）を起動。"
    },
    {
      "indent": 6,
      "text": "* If the Timer(next_exchange) expires, transition to state CREATE_DR to restart the Information Exchange Phase.",
      "ja": "*タイマ（next_exchange）が満了した場合は、移行が情報交換フェーズを再起動するCREATE_DRを述べます。"
    },
    {
      "indent": 6,
      "text": "Note that if Timer(info) timeout occurs a number of times (configurable, typically 3) without any bundles being received, then this SHOULD generally be interpreted as the problem that the link to the peer is no longer functional and the session should be terminated. However, some bundles may be very large and take a long time to transmit. Before terminating the session, this state machine needs to check if a large bundle is actually being received although no new completed bundles have been received since the last expiry of the timer. In this case the timer should be restarted without sending the Bundle Response TLV. Also, if the bundles are being exchanged over a transport protocol that can detect link failure, then the session MUST be terminated if the bundle exchange link is shut down because it has failed.",
      "ja": "タイマ（情報）タイムアウトが受信されている任意のバンドルなし回数（設定、典型的には3）で発生した場合、これは一般にピアへのリンクがもはや機能し、セッションを終了しなければならないという問題として解釈されるべきであることに注意してください。しかし、いくつかのバンドルは非常に大きくなると、送信に時​​間がかかることがあります。セッションを終了する前に、この状態マシンは新しい完了バンドルは、タイマーの最後の有効期限以降に受信されていないが、大規模なバンドルが実際に受信されているかどうかを確認する必要があります。この場合、タイマーは、バンドル応答TLVを送信せずに再起動する必要があります。バンドルがリンク障害を検出することができ、トランスポートプロトコル上で交換されている場合、それが失敗したため、バンドル交換リンクがシャットダウンされた場合も、その後、セッションは終了しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.2. State Definitions for the Listener Role",
      "section_title": true,
      "ja": "5.3.2。リスナーの役割のための状態の定義"
    },
    {
      "indent": 3,
      "text": "The state machine component with the Listener role in each node initially waits to receive a RIB Dictionary update followed by a set of RIB delivery predictabilities during the Information Exchange Phase. The process from the point of view of the Listener does the following:",
      "ja": "各ノードのリスナーの役割を持つ状態機械要素は、最初に情報交換フェーズ中RIB送達予測精度のセット続いRIB辞書更新を受信するのを待ちます。リスナーの観点から、プロセスは、以下のことを実行します。"
    },
    {
      "indent": 3,
      "text": "o Receive RIB Dictionary updates and RIB values from the peer. Note that in some circumstances no dictionary updates are needed, and the RIBD TLV will contain no entries or may be omitted completely.",
      "ja": "OピアからRIB辞書の更新とRIB値を受信します。いくつかの状況では何の辞書の更新が必要とされていないことに注意してください、とRIBD TLVにはエントリが含まれませんか、完全に省略することができます。"
    },
    {
      "indent": 3,
      "text": "o When all RIB messages have been received, the delivery predictability update algorithms are run (see Section 2.1.2) using the values received from the Initiator node and applying any of the optional optimizations configured for this node (see Section 2.1.3).",
      "ja": "全てRIBメッセージが受信された場合には、O、配信予測更新アルゴリズムはイニシエータノードから受信した値を使用して、このノードのために構成された任意の最適化のいずれかを適用すること（セクション2.1.2を参照）で実行される（セクション2.1.3参照）。"
    },
    {
      "indent": 3,
      "text": "o Using the updated delivery predictabilities and the queueing policy and forwarding strategy configured for this node (see Section 2.1.4) examine the set of bundles currently stored in the Listener node to determine the set of bundles to be offered to the Initiator and order the list according to the forwarding strategy in use. The Bundle Offer TLVs are also used to notify the peer of any PRoPHET ACKs that have been received by the Listener role node.",
      "ja": "更新された配信予測精度とキューイングポリシーを使用して、このノードのために構成された戦略を転送O（セクション2.1.4を参照）イニシエータに提供するバンドルのセットを決定するために、現在リスナーノードに格納されたバンドルのセットを調べて、注文使用中の転送戦略に従ってリスト。バンドルオファーのTLVはまた、リスナーロールノードによって受信されたすべての預言者ACKのピアに通知するために使用されます。"
    },
    {
      "indent": 3,
      "text": "o Send the list of bundles in one or more bundle offers, preceded if necessary by one or more RIB dictionary updates to add any EIDs required for the source or destination EIDs of the offered bundles. These updates MUST be marked as being sent by the Listener role so that they will be processed by the Initiator role in the peer.",
      "ja": "O、必要に応じて提供するバンドルの送信元または宛先のEIDのために必要なのEIDを追加するために、1つ以上のRIB辞書の更新が先行する1つの以上のバンドル提供、バンドルのリストを送信します。これらのアップデートは、彼らがピアでのイニシエータの役割によって処理されるように、リスナーの役割によって送信されたとしてマークされなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Wait for the Initiator to send bundle responses indicating which bundles should be sent and possibly a modified order for the sending. Send the accepted bundles in the specified order. The bundle sending will normally be carried out over a separate connection using a suitable DTN convergence layer.",
      "ja": "Oバンドルはおそらく送信するための修飾された注文を送信しなければならないかを示すバンドル応答を送信するイニシエータを待ちます。指定された順序で受け入れられたバンドルを送信します。バンドルの送信は、通常、適切なDTN収束層を使用して別の接続にわたって行われます。"
    },
    {
      "indent": 3,
      "text": "o On completion of the sending, wait for a message with an empty Bundle Response TLV indicating correct completion of the process.",
      "ja": "O送信が終了すると、プロセスの正しい完了したことを示す空のバンドル応答TLVを持つメッセージを待ちます。"
    },
    {
      "indent": 3,
      "text": "o The Listener process will be notified if any new bundles or PRoPHET ACKs are received by the node after the completion of the bundle sending that results from this information exchange. The forwarding policy and the current delivery predictabilities will then be applied to determine if this information should be sent to the peer. If it is determined that one or more bundles and/or ACKs ought to be forwarded, a new set of bundle offers are sent to the peer. If the peer accepts them by sending bundle responses, the bundles and/or ACKS are transferred as previously.",
      "ja": "束の完了は、その送信した後、新しいバンドルまたはPROPHET ACKがノードによって受信された場合Oリスナープロセスが通知され、この情報交換の結果。転送ポリシー及び現在の配信予測精度は、この情報をピアに送信されるべきかどうかを決定するために適用されます。それは、1つのまたは複数のバンドルおよび/またはACKが転送されるべきであると判断された場合、バンドルオファーの新しいセットがピアに送信されます。ピアがバンドル応答、バンドルおよび/またはACKを送信することによって、それらを受け入れた場合、以前のように転送されます。"
    },
    {
      "indent": 3,
      "text": "o Periodically, the Initiator in the peer will restart the complete information exchange by sending a RIB TLV that may be, optionally, preceded by RIB Dictionary entries if they are required for the updated RIB.",
      "ja": "O定期的に、ピアにイニシエータは、それらが更新されたRIBに必要とされる場合、必要に応じて、RIB辞書エントリが先行してもよいRIB TLVを送信することによって、完全な情報交換を再起動します。"
    },
    {
      "indent": 3,
      "text": "Timers are used to ensure that the Listener does not lock up if messages are not received from the Initiator in a timely fashion. The Listener is restarted if the RIB is not received, and a Hello ACK message is sent to force the Initiator to restart. If bundle response messages are not received in a timely fashion, the Listener re-sends the bundle offers and associated dictionary updates. The following states are used:",
      "ja": "タイマーは、メッセージがタイムリーにイニシエータから受信されていない場合は、リスナーがロックアップしないことを確実にするために使用されています。リスナーは、RIBが受信されない場合は再開され、こんにちはACKメッセージが再起動するイニシエータを強制的に送信されます。バンドル応答メッセージがタイムリーに受信されない場合は、リスナーバンドルの提供と関連した辞書の更新を再送信します。以下の状態が使用されます。"
    },
    {
      "indent": 3,
      "text": "WAIT_DICT The Listener subsidiary state machine transitions to this state automatically and immediately from the state ESTAB in both peers. This state will be entered in the same way if the Timer(next_exchange) expires in the peer, signaling the start of a new round of information exchange and bundle passing. This will result in one or more RIB TLVs being sent to the Listener by the peer node's Initiator.",
      "ja": "WAIT_DICTリスナーの子会社ステートマシン遷移この状態に自動的に、すぐに両方のピアの状態ESTABから。タイマ（next_exchange）が情報交換及び束通過の新ラウンドの開始をシグナリング、ピアに満了した場合、この状態は、同様に入力されます。これは、ピア・ノードのイニシエータによってリスナーに送信される1つの以上のRIBのTLVになります。"
    },
    {
      "indent": 6,
      "text": "* When a RIB Dictionary TLV is received, use the TLV to update the local dictionary, start or (if it is running) restart the Timer(peer) and transition to state WAIT_RIB. If any of the entries in the RIB Dictionary TLV conflict with existing entries (i.e., an entry is received that uses the same String ID as some previously received entry, but the EID in the entry is different), send a Response message with an Error TLV containing a Dictionary Conflict indicator, abort any in-progress Initiator or Listener process, and terminate the connection to the peer.",
      "ja": "*辞書TLVが受信されたRIB、開始、ローカル辞書を更新するTLVを使用するか（それが実行されている場合は）WAIT_RIBを述べるためにタイマ（ピア）と遷移を再起動します。既存のエントリを持つRIB辞書TLVの競合のエントリのいずれかの場合は、エラーで応答メッセージを送信する（すなわち、エントリが受信されることは、いくつかの以前に受信したエントリと同じ文字列のIDを使用しますが、エントリ内のEIDは異なります）辞書競合インジケータを含むTLVは、任意の進行中の開始剤またはリスナープロセスを中止し、ピアとの接続を終了します。"
    },
    {
      "indent": 6,
      "text": "* If a Hello ACK message is received from the peer node, transition to state WAIT_DICT and restart the process.",
      "ja": "ハローACKメッセージがピア・ノードから受信された場合*、遷移がWAIT_DICTを述べると、プロセスを再起動します。"
    },
    {
      "indent": 6,
      "text": "If multiple timeouts occur (configurable, typically 3), assume that the link is broken and terminate the session. Note that the RIB Dictionary and RIB TLVs may be combined into a single message. The RIB TLV should be passed on to be processed in the WAIT_RIB state.",
      "ja": "複数のタイムアウトが（設定、典型的には3）で発生した場合、リンクが壊れていると仮定し、セッションを終了します。 RIB辞書リブのTLVは、単一のメッセージに結合することができることに留意されたいです。 RIB TLVはWAIT_RIB状態で処理するに渡す必要があります。"
    },
    {
      "indent": 3,
      "text": "WAIT_RIB In this state, the Listener expects to be receiving one or more RIB TLVs and possibly additional RIB Dictionary TLVs.",
      "ja": "この状態でWAIT_RIB、リスナーは、一の以上のRIBのTLVおよびおそらく追加のRIB辞書TLVを受信することを期待します。"
    },
    {
      "indent": 6,
      "text": "* On entry to this state, clear the set of received delivery predictabilities.",
      "ja": "*この状態へのエントリでは、受信配信予測精度のセットをクリアします。"
    },
    {
      "indent": 6,
      "text": "* Whenever a new message is received, restart the Timer(peer) timer.",
      "ja": "*新しいメッセージが受信されるたびに、タイマー（ピア）タイマーを再起動します。"
    },
    {
      "indent": 6,
      "text": "* If a RIB dictionary TLV is received, use it to update the local dictionary and remain in this state. If any of the entries in the RIB Dictionary TLV conflict with existing entries (i.e., an entry is received that uses the same String ID as some previously received entry, but the EID in the entry is different), send a message with an Error TLV containing a Dictionary Conflict indicator, abort any in-progress Initiator or Listener process, and terminate the connection to the peer.",
      "ja": "* RIB辞書TLVを受信した場合、ローカル辞書を更新するためにそれを使用して、この状態のまま。既存のエントリとRIB辞書TLV競合のエントリのいずれかの場合には、エラーTLVでメッセージを送信する（すなわち、エントリが受信されることは、いくつかの以前に受信されたエントリと同じ文字列IDを使用するが、エントリ内のEIDは異なります）辞書競合インジケータを含む、任意の進行中の開始剤またはリスナープロセスを中止し、ピアとの接続を終了します。"
    },
    {
      "indent": 6,
      "text": "* If a RIB TLV is received, record the received delivery predictabilities for use in recalculating the local delivery predictabilities. If a delivery predictability value is received for an EID that is already in the set of received delivery predictabilities, overwrite the previously received value with the latest value. If a delivery predictability value is received with a String ID that is not in the dictionary, send a message with an Error TLV containing a Bad String ID indicator, abort any in-progress Initiator or Listener process, and terminate the connection to the peer.",
      "ja": "* RIB TLVが受信された場合、ローカル配信予測精度を再計算に使用するために受信配信予測精度を記録。配信予測値は、受信配信予測精度のセット内にすでにあるEIDのために受信されている場合は、最新の値を持つ以前に受信した値を上書きします。配信予測値が辞書にない文字列IDと受信した場合、任意の進行中の開始剤またはリスナープロセスを中断、バッドストリングIDインジケータを含むエラーTLVでメッセージを送信し、ピアとの接続を終了します。"
    },
    {
      "indent": 6,
      "text": "* When a RIB TLV is received with the \"More RIB TLVs\" flag cleared, initiate the recalculation of delivery predictabilities and stop the Timer(peer). Use the revised delivery predictabilities and the configured queueing and forwarding strategies to create a list of bundles to be offered to the peer node.",
      "ja": "* TLVクリア「よりRIBのTLV」フラグで受信されたRIBは、配信予測精度の再計算を開始し、タイマ（ピア）を停止します。ピア・ノードに提供されるバンドルのリストを作成するために改訂された配信予測精度および設定のキューイングおよび転送戦略を使用してください。"
    },
    {
      "indent": 6,
      "text": "* Record the state of the local dictionary in case the offer procedure has to be restarted. Determine if any new dictionary entries are required for use in the Bundle Offer TLV(s). If so, record them in the local dictionary, then format and send RIB Dictionary entries in zero or more RIB Dictionary TLV messages to update the dictionary in the peer if necessary.",
      "ja": "*募集手続きを再開する必要がある場合に、ローカル辞書の状態を記録します。任意の新しい辞書エントリがバンドルオファーTLV（複数可）で使用するために必要とされるかどうかを判断します。その場合は、ローカル辞書でそれらを記録し、その後、必要に応じてピアに辞書を更新するために、ゼロ以上のRIB辞書TLVメッセージにRIB辞書のエントリをフォーマットし、送信してください。"
    },
    {
      "indent": 6,
      "text": "* Format and send Bundle Offer TLV(s) carrying the identifiers of the bundles to be offered together with any PRoPHET ACKs received or generated by this node. If more than one Bundle Offer TLV is sent, all but the last Bundle Offer TLV sent MUST have the \"More Offer/Response TLVs Following\" flag set to 1.",
      "ja": "*形式及び任意PROPHET ACKが受信されたか、このノードによって生成されると一緒に提供されるバンドルの識別子を運ぶバンドルオファーTLV（複数可）を送ります。複数のバンドルオファーTLVが送信されると、送信された最後のバンドルオファーTLVすべてが1に設定されている「その他のオファー/レスポンスのTLVに続いて」フラグを持たなければなりません。"
    },
    {
      "indent": 6,
      "text": "* When all Bundle Offer TLVs have been sent, start the Timer(info) and transition to state OFFER.",
      "ja": "*すべてのバンドルオファーのTLVが送られてきた、タイマー（情報）と状態オファーへの移行を開始します。"
    },
    {
      "indent": 6,
      "text": "* If the Timer(peer) expires, send a Hello ACK TLV to the peer, restart the timer, and transition to state WAIT_DICT.",
      "ja": "*タイマ（ピア）が満了​​した場合は、タイマーを再起動して、ピアにこんにちはACK TLVを送信し、移行はWAIT_DICTを述べること。"
    },
    {
      "indent": 6,
      "text": "* If an Error TLV indicating a Dictionary Conflict or Bad String ID is received during or after sending the RIB Dictionary TLVs and/or the Bundle Offer TLVs, abort any in-progress Initiator or Listener process, and terminate the connection to the peer.",
      "ja": "*辞書競合又はバッドストリングIDを示すエラーTLV中またはRIB辞書のTLV及び/又はバンドルオファーTLVを送信した後に受信された場合、任意の進行中の開始剤またはリスナープロセスを中止し、ピアとの接続を終了します。"
    },
    {
      "indent": 6,
      "text": "* If a Hello ACK message is received from the peer node, transition to state WAIT_DICT and restart the process.",
      "ja": "ハローACKメッセージがピア・ノードから受信された場合*、遷移がWAIT_DICTを述べると、プロセスを再起動します。"
    },
    {
      "indent": 3,
      "text": "OFFER In this state, the Listener expects to be receiving one or more Bundle Response TLVs detailing the bundles accepted by the Initiator node. The ordered list of accepted bundles is communicated to the bundle protocol agent, which controls sending them to the peer node over a separate connection.",
      "ja": "この状態でOFFERは、リスナーは、イニシエータノードによって受け入れバンドルの詳細を一つ以上のバンドル応答TLVを受信することを期待します。受け入れられたバンドルの順序付きリストは、個別の接続を介してピア・ノードに送信する制御バンドルプロトコル剤に伝達されます。"
    },
    {
      "indent": 6,
      "text": "* When a Bundle Response TLV is received with a non-zero count of Bundle Offers, extract the list of accepted bundles and send the list to the bundle protocol agent so that it can start transmission to the peer node. Ensure that the order of offers from the TLV is maintained. Restart the Timer(info) unless the last Bundle Response TLV received has the \"More Offer/ Response TLVs Following\" flag set to 0. If a Bundle Response TLV is received with a String ID that is not in the dictionary, send a message with an Error TLV containing a Bad String ID indicator, abort any in-progress Initiator or Listener process, and terminate the connection to the peer.",
      "ja": "*バンドル応答TLVをバンドルオファーの非ゼロカウントで受信され、受け入れられたバンドルのリストを抽出し、それがピア・ノードへの送信を開始することができるように、バンドルプロトコルエージェントにリストを送信します。 TLVからの申し出の順序が維持されていることを確認してください。最後のバンドル応答TLVが受信されない限りでメッセージを送信し、バンドル応答TLVが辞書にない文字列IDを受信した場合は0に設定されている「その他のオファー/レスポンスのTLVに続いて」旗を持っているタイマー（情報）を再起動します。エラーバッドストリングIDインジケータを含むTLV、任意の進行中の開始剤またはリスナープロセスを中止し、ピアとの接続を終了します。"
    },
    {
      "indent": 6,
      "text": "* After receiving a Bundle Response TLV with the \"More Offer/ Response TLVs Following\" flag set to 0 stop the Timer(info) and transition to state SND_BUNDLE.",
      "ja": "* 0ストップタイマ（情報）とSND_BUNDLEの状態への遷移に設定されたフラグ「は、以下の詳細オファー/応答のTLV」とバンドル応答TLVを受信した後。"
    },
    {
      "indent": 6,
      "text": "* If the Timer(info) expires, send a Hello ACK TLV to the peer, restart the timer and transition to state WAIT_DICT.",
      "ja": "*タイマ（情報）が満了した場合は、WAIT_DICTを述べるタイマーと遷移を再起動し、ピアにこんにちはACK TLVを送信します。"
    },
    {
      "indent": 6,
      "text": "* If a Hello ACK message is received from the peer node, transition to state WAIT_DICT and restart the process.",
      "ja": "ハローACKメッセージがピア・ノードから受信された場合*、遷移がWAIT_DICTを述べると、プロセスを再起動します。"
    },
    {
      "indent": 3,
      "text": "SND_BUNDLE In this state the Listener monitors the sending of bundles to the Initiator peer node. In the event of disruption in transmission, the Initiator node will, if possible, re-send the list of bundles that were accepted but have not yet been received. The bundle protocol agent has to be informed of any updates to the list of bundles to send (this is likely to involve re-sending one or more bundles). Otherwise, the Listener is quiescent in this state.",
      "ja": "この状態でSND_BUNDLEリスナーは、イニシエータピア・ノードにバンドルの送信を監視します。可能な場合は、送信の中断が発生した場合には、イニシエータノードは、受け入れられたが、まだ受信されていないバンドルのリストを再送信します。バンドルプロトコルエージェントは（これは再送信を一の以上のバンドルが関与する可能性がある）に送信するバンドルのリストにすべての更新について通知する必要があります。そうしないと、リスナーはこの状態で静止しています。"
    },
    {
      "indent": 6,
      "text": "* When a Bundle Response TLV is received with a non-zero count of Bundle Offers, extract the list of accepted bundles and update the list previously passed to the bundle protocol agent so that it can (re)start transmission to the peer node. Ensure that the order of offers from the TLV is maintained so far as is possible. Restart the Timer(info) unless the last Bundle Response TLV received has the \"More Offer/Response TLVs Following\" flag set to 0. If a Bundle Response TLV is received with a String ID that is not in the dictionary, send a message with an Error TLV containing a Bad String ID indicator, abort any in-progress Initiator or Listener process, re-initialize the local dictionary, and restart the Information Exchange Phase as if the ESTAB state had just been reached.",
      "ja": "*バンドル応答TLVをバンドルオファーの非ゼロカウントで受信され、受け入れられたバンドルのリストを抽出し、それを（再）ピア・ノードへの送信を開始することができるように、以前にバンドルプロトコルエージェントに渡されたリストを更新します。 TLVからの申し出の順序は、これまで可能であるとして維持されていることを確認してください。最後のバンドル応答TLVが受信されない限りでメッセージを送信し、バンドル応答TLVが辞書にない文字列IDを受信した場合は0に設定されている「その他のオファー/レスポンスのTLVに続いて」旗を持っているタイマー（情報）を再起動します。悪い文字列IDインジケータを含むエラーTLVは、再初期化するローカル辞書、任意の進行中のイニシエータまたはリスナープロセスを中止し、ESTAB状態がちょうど到達したかのように情報交換フェーズを再起動します。"
    },
    {
      "indent": 6,
      "text": "* After receiving a Bundle Response TLV with the \"More Offer/ Response TLVs Following\" flag set to 0, stop the Timer(info) and wait for completion of bundle sending.",
      "ja": "* 0に設定されたフラグ「に続いてより多くのオファー/レスポンスのTLV」をバンドル応答TLVを受け取った後、タイマー（情報）を停止し、送信バンドルの完了を待ちます。"
    },
    {
      "indent": 6,
      "text": "* If the Timer(info) expires, send a Hello ACK TLV to the peer, restart the timer, and transition to state WAIT_DICT.",
      "ja": "*タイマ（情報）が満了した場合は、タイマーを再起動して、ピアにこんにちはACK TLVを送信し、移行はWAIT_DICTを述べること。"
    },
    {
      "indent": 6,
      "text": "* If a Hello ACK message is received from the peer node, transition to state WAIT_DICT and restart the process.",
      "ja": "ハローACKメッセージがピア・ノードから受信された場合*、遷移がWAIT_DICTを述べると、プロセスを再起動します。"
    },
    {
      "indent": 6,
      "text": "* When a Bundle Response TLV is received with a zero count of Bundle Offers, the Bundle Passing Sub-Phase is complete. Notify the Initiator that the Listener process is complete and transition to state WAIT_MORE.",
      "ja": "バンドル応答TLVは、バンドルのオファーゼロカウントで受信された場合*、バンドルサブフェーズを渡すと、完了です。リスナー・プロセスが完了するとWAIT_MOREを状態への遷移であることをイニシエータに通知します。"
    },
    {
      "indent": 6,
      "text": "As explained in the Initiator state REQUEST description, depending on the transport protocol (convergence layer) used to send the bundles to the peer node, it may be necessary during the bundle sending process to monitor the liveness of the connection to the peer node in the Initiator process using a timer.",
      "ja": "トランスポート・プロトコル（収束層）に応じて、イニシエータ状態要求の記述において説明がピア・ノードへのバンドルを送信するために使用されるように、それがピア・ノードへの接続の生存性を監視するために、バンドル送信処理中に必要であるかもしれませんタイマーを使用してイニシエータプロセス。"
    },
    {
      "indent": 3,
      "text": "WAIT_MORE In this state, the Listener monitors the reception of new bundles that might be received from a number of sources, including",
      "ja": "この状態でWAIT_MORE、リスナーには、多くの供給源から受信されるかもしれない新しいバンドルの受信を監視します"
    },
    {
      "indent": 6,
      "text": "* local applications on the node,",
      "ja": "ノード上の*ローカルアプリケーション、"
    },
    {
      "indent": 6,
      "text": "* other mobile nodes that connect to the node while this connection is open, and",
      "ja": "この接続が開いている間にノードに接続*他のモバイルノード、及び"
    },
    {
      "indent": 6,
      "text": "* permanent connections such as might occur at an Internet gateway.",
      "ja": "*のような恒久的な接続は、インターネットゲートウェイで発生する可能性があります。"
    },
    {
      "indent": 6,
      "text": "When the Listener is notified of received bundles, it determines if they should be offered to the peer. The peer may also re-initiate the Information Exchange Phase periodically.",
      "ja": "リスナーが受信バンドルが通知されると、彼らはピアに提供する必要がある場合は、それが決定されます。ピアはまた、定期的に情報交換フェーズを再開始することができます。"
    },
    {
      "indent": 6,
      "text": "* When the bundle protocol agent notifies the Listener that new bundles and/or new PRoPHET ACKs have been received, the Listener applies the selected forwarding policy and the current delivery predictabilities to determine if any of the items ought to be offered to the connected peer. If so, it carries out the same operations as are described in the WAIT_RIB state to build and send any necessary RIB Dictionary TLVs and RIB TLVs to the Initiator in the peer.",
      "ja": "バンドルプロトコルエージェントは、新しいバンドルおよび/または新しいPROPHET ACKが受信されたリスナに通知する*、リスナーは、アイテムのいずれかが接続されたピアに提供されるべきかどうかを決定するために選択された転送ポリシー及び現在の配信予測精度を適用します。もしそうなら、それはピアでイニシエータに必要なRIB辞書のTLVとRIB TLVを構築し、送信するWAIT_RIB状態に記述されているのと同じ動作を行います。"
    },
    {
      "indent": 6,
      "text": "* When all Bundle Offer TLVs have been sent, start the Timer(info) and transition to state OFFER.",
      "ja": "*すべてのバンドルオファーのTLVが送られてきた、タイマー（情報）と状態オファーへの移行を開始します。"
    },
    {
      "indent": 6,
      "text": "* If a RIB dictionary TLV is received, use it to update the local dictionary and transition to state WAIT_RIB. If any of the entries in the RIB Dictionary TLV conflict with existing entries (i.e., an entry is received that uses the same String ID as some previously received entry, but the EID in the entry is different), send a message with an Error TLV containing a Dictionary Conflict indicator, abort any in-progress Initiator or Listener process, and terminate the connection to the peer.",
      "ja": "* RIB辞書TLVが受信された場合、WAIT_RIBを述べるために、ローカル辞書と遷移を更新するためにそれを使用します。既存のエントリとRIB辞書TLV競合のエントリのいずれかの場合には、エラーTLVでメッセージを送信する（すなわち、エントリが受信されることは、いくつかの以前に受信されたエントリと同じ文字列IDを使用するが、エントリ内のEIDは異なります）辞書競合インジケータを含む、任意の進行中の開始剤またはリスナープロセスを中止し、ピアとの接続を終了します。"
    },
    {
      "indent": 6,
      "text": "Note that the RIB Dictionary and RIB TLVs may be combined into a single message. The RIB TLV should be passed on to be processed in the WAIT_RIB state.",
      "ja": "RIB辞書リブのTLVは、単一のメッセージに結合することができることに留意されたいです。 RIB TLVはWAIT_RIB状態で処理するに渡す必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Recommendations for Information Exchange Timer Periods",
      "section_title": true,
      "ja": "5.3.3。情報交換タイマー期間のための推奨事項"
    },
    {
      "indent": 3,
      "text": "The Information Exchange Phase (IEP) state definitions include a number of timers. This section provides advice and recommendations for the periods that are appropriate for these timers.",
      "ja": "情報交換フェーズ（IEP）状態の定義は、タイマーの数が含まれます。このセクションでは、これらのタイマに適した期間のための助言や提言を提供します。"
    },
    {
      "indent": 3,
      "text": "Both Timer(info) and Timer(peer) are used to ensure that the state machines do not become locked into inappropriate states if the peer node does not apparently respond to messages sent in a timely fashion either because of message loss in the network or unresponsiveness from the peer. The appropriate values are to some extent dependent on the speed of the network connection between the nodes and the capabilities of the nodes executing the PRoPHET implementations. Values in the range 1 to 10 seconds SHOULD be used, with a value of 5 seconds RECOMMENDED as default. The period should not be set to too low a value, as this might lead to inappropriate restarts if the hardware is relatively slow or there are large numbers of pieces of information to process before responding. When using a reliable transport protocol such as TCP, these timers effectively provide a keep-alive mechanism and ensure that a failed connection is detected as rapidly as possible so that remedial action can be taken (if possible) or the connection shut down tidily if the peer node has moved out of range.",
      "ja": "タイマー（情報）とタイマー（ピア）の両方が、状態マシンがピア・ノードが明らかにどちらかのために、ネットワークまたは不応答におけるメッセージの損失をタイムリーに送信されたメッセージに応答しない場合、不適切な状態にロックされていないことを保証するために使用されていますピアから。適切な値は、ある程度ノードと預言者の実装を実行するノードの能力との間のネットワーク接続の速度に依存しています。範囲は1〜10秒の値がデフォルトとして推奨5秒の値が、使用されてください。ハードウェアが比較的遅いか、応答する前に処理するための情報が多数存在する場合、これは不適切な再起動につながる可能性があるとして期間は、あまりにも低い値に設定するべきではありません。 TCPのような信頼性の高いトランスポートプロトコルを使用する場合、これらのタイマーを効果キープアライブ機構を提供し、是正措置をとることができる（可能な場合）場合、または接続が整然とシャットダウンするように失敗した接続が可能な限り迅速に検出されることを保証しますピア・ノードが範囲外に移動しました。"
    },
    {
      "indent": 3,
      "text": "Timer(next_exchange) is used to determine the maximum frequency of (i.e., minimum period between) successive re-executions of the information exchange state machines during a single session between a pair of nodes. Selection of the timer period SHOULD reflect the trade-off between load on the node processor and desire for timely forwarding of bundles received from other nodes. It is RECOMMENDED that the timer periods used should be randomized over a range from 50% to 150% of the base value in order to avoid synchronization between multiple nodes. Consideration SHOULD be given to the expected length of typical encounters and the likelihood of encounters between groups of nodes when setting this period. Base values in the range of 20 to 60 seconds are RECOMMENDED.",
      "ja": "タイマー（next_exchange）は、ノードのペア間の単一のセッションの間に情報交換ステートマシンの（すなわち、間の最小期間）の連続再実行の最大周波数を決定するために使用されます。タイマ期間の選択は、他のノードから受信したバンドルのタイムリーな転送のためのノードプロセッサの負荷と願望との間のトレードオフを反映すべきです。使用されるタイマ期間が複数のノード間の同期を避けるために、50％から基本値の150％までの範囲にわたってランダム化することをお勧めします。この期間を設定する際に考慮すべきことは、典型的な出会いの予想される長さとノードのグループ間の遭遇の可能性を与えられるべきです。 20〜60秒の範囲内の塩基の値が推奨されます。"
    },
    {
      "indent": 0,
      "text": "5.3.4. State Tables for Information Exchange",
      "section_title": true,
      "ja": "5.3.4。情報交換のための状態テーブル"
    },
    {
      "indent": 3,
      "text": "This section shows the state transitions that nodes go through during the Information Exchange Phase. State tables are given for the Initiator role and for the Listener role of the subsidiary state machines. Both nodes will be running machines in each role during the Information Exchange Phase, and this can be done either concurrently or sequentially, depending on the implementation, as explained in Section 5.3. The state tables in this section should be read in conjunction with the state descriptions in Sections 5.3.1 and 5.3.2.",
      "ja": "このセクションでは、情報交換フェーズの間に通過ノード状態遷移を示しています。状態テーブルは、イニシエータの役割のためにと子会社ステートマシンのリスナーの役割のために与えられています。両方のノードは、情報交換フェーズの間、各ロールのマシンを実行され、セクション5.3で説明したように、これは、実装に応じて、同時に又は逐次的に行うことができます。このセクションの状態テーブルは、セクション5.3.1および5.3.2での状態の説明と併せて読まれるべきです。"
    },
    {
      "indent": 0,
      "text": "5.3.4.1. Common Notation, Operations and Events",
      "section_title": true,
      "ja": "5.3.4.1。一般的な表記法、操作とイベント"
    },
    {
      "indent": 3,
      "text": "The following notation is used:",
      "ja": "以下の表記が使用されます。"
    },
    {
      "indent": 3,
      "text": "nS Node that sent the Hello SYN message.",
      "ja": "こんにちはSYNメッセージを送信したNSノード。"
    },
    {
      "indent": 3,
      "text": "nA Node that sent the Hello SYNACK message.",
      "ja": "こんにちはSYNACKメッセージを送信したノードNA。"
    },
    {
      "indent": 3,
      "text": "The following events are common to the Initiator and Listener state tables:",
      "ja": "次のイベントは、イニシエータとリスナーの状態テーブルに共通しています。"
    },
    {
      "indent": 3,
      "text": "ErrDC Dictionary Conflict Error TLV received.",
      "ja": "ErrDC辞書競合エラーTLVを受信しました。"
    },
    {
      "indent": 3,
      "text": "ErrBadSI Bad String ID Error TLV received.",
      "ja": "ErrBadSI悪い文字列IDエラーTLVを受信しました。"
    },
    {
      "indent": 3,
      "text": "HelloAck Hello ACK TLV received. This message is delivered to both Initiator and Listener roles in order to cause a restart of the Information Exchange Phase in the event of message loss or protocol problems.",
      "ja": "HelloAckこんにちはACK TLVを受信しました。このメッセージは、メッセージの損失やプロトコルの問題が発生した場合に情報交換フェーズの再起動を引き起こすために、両方のイニシエータとリスナーの役割に配信されます。"
    },
    {
      "indent": 3,
      "text": "InitStart Sent by Listener role to Initiator role to signal the Initiator role to commence sending messages to peer. If the Listener instance is running in the node that sent the Hello SYN (nS), then InitStart is signaled immediately when the state is entered. For the node that sent the Hello SYNACK (nA), InitStart may be signaled immediately if the operational policy requires concurrent operation of the Initiator and Listener roles or postponed until the Listener role state machine has reached a state defined by the configured policy.",
      "ja": "INITSTARTピアにメッセージを送信開始するイニシエータの役割を知らせるために役割をイニシエータにリスナーの役割によって送信されます。リスナーインスタンスがハローSYN（NS）を送信したノードで実行されている場合の状態が入力されたとき、その後INITSTARTが直ちに通知されます。ハローSYNACK（NA）を送信したノードのために、INITSTARTは、運用ポリシがイニシエータとリスナーの役割の同時操作を必要とする場合、直ちに合図またはリスナー役割状態マシンが設定されたポリシーによって定義された状態に達するまで延期されてもよいです。"
    },
    {
      "indent": 3,
      "text": "RIBnotlast RIB TLV received with \"More RIB TLVs\" flag set to 1.",
      "ja": "RIBnotlast RIB TLVが1に設定された「詳細RIBのTLV」フラグで受信しました。"
    },
    {
      "indent": 3,
      "text": "RIBlast RIB TLV received with \"More RIB TLVs\" flag set to 0.",
      "ja": "RIBlast RIB TLVは0に設定された「詳細RIBのTLV」フラグで受信しました。"
    },
    {
      "indent": 3,
      "text": "REQnotlast Bundle Response TLV received with More Offer/Response TLVs Following flag set to 1.",
      "ja": "REQnotlastバンドル応答TLVは1に設定よりオファー/レスポンスのTLVに続いてフラグを受け取りました。"
    },
    {
      "indent": 3,
      "text": "REQlast Bundle Response TLV received with More Offer/Response TLVs Following flag set to 0.",
      "ja": "REQlastバンドル応答TLVは0に設定よりオファー/レスポンスのTLVに続いてフラグを受け取りました。"
    },
    {
      "indent": 3,
      "text": "RIBDi RIBD TLV received with Sent by Listener flag set to 0 (i.e., it was sent by Initiator role).",
      "ja": "RIBDi RIBD TLV（すなわち、それがイニシエータの役割によって送信された）を0に設定リスナーフラグで送信と受信しました。"
    },
    {
      "indent": 3,
      "text": "RIBDl RIBD TLV received with Sent by Listener flag set to 1 (i.e., it was sent by Listener role).",
      "ja": "RIBDl RIBD TLV（すなわち、それはリスナーの役割によって送信された）を1に設定リスナーフラグで送信と受信しました。"
    },
    {
      "indent": 3,
      "text": "Timeout(info) The Timer(info) has expired.",
      "ja": "タイムアウト（情報）タイマ（情報）有効期限が切れています。"
    },
    {
      "indent": 3,
      "text": "Timeout(peer) The Timer(peer) has expired.",
      "ja": "タイムアウト（ピア）タイマ（ピア）が期限切れになりました。"
    },
    {
      "indent": 3,
      "text": "Both the Initiator and Listener state tables use the following common operations:",
      "ja": "どちらのイニシエータとリスナーの状態テーブルには、以下の一般的な操作を使用します。"
    },
    {
      "indent": 3,
      "text": "o The \"Initialize Dictionary\" operation is defined as emptying any existing local dictionary and inserting the two initial entries: the EID of the node that sent the Hello SYN (String ID 0) and the EID of the node that sent the Hello SYNACK (String ID 1).",
      "ja": "ハローSYN（文字列ID 0）を送信したノードのEIDとハローSYNACKを送信したノードのEID（文字列：「初期化辞書」操作は、既存のローカル辞書を空にし、2つの初期エントリを挿入するように定義されているoをID 1）。"
    },
    {
      "indent": 3,
      "text": "o The \"Send RIB Dictionary Updates\" operation is defined as:",
      "ja": "O「RIB辞書の更新を送信」操作は以下のように定義されています。"
    },
    {
      "indent": 6,
      "text": "1. Determining what dictionary updates will be needed for any extra EIDs in the previously selected RIB entries set that are not already in the dictionary and updating the local dictionary with these EIDs. The set of dictionary updates may be empty if no extra EIDs are needed. The set may be empty even on the first execution if sequential operation has been selected, this is the second node to start and the necessary EIDs were in the set previously sent by the first node to start.",
      "ja": "1.辞書の更新が辞書にまだなっていない以前に選択RIBエントリのセットで余分のEIDのために必要とされるかを決定し、これらのEIDとローカル辞書を更新します。余分のEIDが必要とされていない場合は、辞書更新のセットが空でもよいです。セットも一連の動作が選択された場合、最初の実行時に空であってもよく、これは開始する第2のノードであり、必要なのEIDは、以前に開始する最初のノードによって送信されたセットでした。"
    },
    {
      "indent": 6,
      "text": "2. Formatting zero or more RIBD TLVs for the set of dictionary updates identified in the \"Build RIB Entries\" operation and sends them to the peer. The RIBD TLVs MUST have the \"Sent by Listener\" flag set to 0 if the updates are sent by the Initiator role and to 1 if sent by the Listener role. In the case of the Initiator role, an empty RIBD TLV MUST be sent even if the set of updates is empty in order to trigger the Listener state machine.",
      "ja": "2.「ビルドのRIBエントリー」操作で特定した辞書更新のセットのために、ゼロ以上のRIBD TLVをフォーマットし、ピアに送信します。リスナーの役割によって送信された場合に更新がイニシエータの役割によって、1に送信された場合RIBD TLVが0に設定された「リスナーによって送信された」フラグを持たなければなりません。イニシエータの役割の場合は、空のRIBD TLVは、一連の更新はリスナー・ステート・マシンをトリガーするために、空であっても送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The \"Update Dictionary\" operation uses received RIBD TLV entries to update the local dictionary. The received entries are checked against the existing dictionary. If the String ID in the entry is already in use, the entry is accepted if the EID in the received entry is identical to that stored in the dictionary previously. If it is identical, the entry is unchanged, but if it is not a Response message with an Error TLV indicating Dictionary Conflict is sent to the peer in an Error Response message, the whole received RIBD TLV is ignored, and the Initiator and Listener processes are restarted as if the ESTAB state has just been reached.",
      "ja": "O「更新辞書」の操作は、ローカル辞書を更新するために受信RIBD TLVエントリを使用しています。受信エントリは、既存の辞書と照合されます。エントリに文字列IDが既に使用されている場合、エントリは、受信されたエントリ内のEIDが予め辞書に格納されているものと同一である場合に受け入れられます。それが同一であれば、エントリは変更されませんが、それはエラーTLVで応答メッセージでない場合、辞書競合を示すエラー応答メッセージにピアに送信され、全体がRIBD TLVは無視されて受信し、イニシエータとリスナープロセスESTAB状態がちょうど達しているかのように再起動されます。"
    },
    {
      "indent": 3,
      "text": "o The \"Abort Exchange\" operation is defined as aborting any in-progress information exchange state machines and terminating the connection to the peer.",
      "ja": "O「中止交換」動作は、任意の進行中の情報交換ステートマシンを中止し、ピアとの接続を終了するように定義されます。"
    },
    {
      "indent": 3,
      "text": "o The \"Start TI\" operation is defined as (re)starting the Timer(info) timer.",
      "ja": "O「TIを開始」操作は、タイマー（情報）タイマーを起動（再）として定義されます。"
    },
    {
      "indent": 3,
      "text": "o The \"Start TP\" operation is defined as (re)starting the Timer(peer) timer.",
      "ja": "O「スタートTP」動作は、タイマ（ピア）タイマーを起動（再）として定義されます。"
    },
    {
      "indent": 3,
      "text": "o The \"Cancel TI\" operation is defined as canceling the Timer(info) timer.",
      "ja": "O「TIの取り消し」操作は、タイマー（情報）タイマーをキャンセルするように定義されます。"
    },
    {
      "indent": 3,
      "text": "o The \"Cancel TP\" operation is defined as canceling the Timer(info) timer.",
      "ja": "O「TPをキャンセル」の操作は、タイマー（情報）タイマーをキャンセルするように定義されます。"
    },
    {
      "indent": 0,
      "text": "5.3.4.2. State Tables for the Initiator Role",
      "section_title": true,
      "ja": "5.3.4.2。イニシエータの役割のための状態テーブル"
    },
    {
      "indent": 3,
      "text": "The rules and state tables for the Initiator role use the following operations:",
      "ja": "イニシエータの役割のためのルールと状態テーブルには、次の操作を使用します。"
    },
    {
      "indent": 3,
      "text": "o The \"Build RIB Entries\" operation is defined as:",
      "ja": "O「RIBエントリを構築する」の動作は以下のように定義されています。"
    },
    {
      "indent": 6,
      "text": "1. Recording the state of the local dictionary.",
      "section_title": true,
      "ja": "1.ローカル辞書の状態を記録します。"
    },
    {
      "indent": 6,
      "text": "2. Determining the set of EIDs for which RIB entries should be sent during this execution of the Initiator role state machine component. If this is a second or subsequent run of the state machine in this node during the current session with the connected peer, then the set of EIDs may be empty if no changes have occurred since the previous run of the state machine.",
      "ja": "2. RIBエントリは、イニシエータロールステートマシンコンポーネントのこの実行中に送信すべきためのEIDのセットを決定します。これは、接続されたピアとの現在のセッション中にこのノードの状態機械の第二又はその後の実行である場合には変更は、状態マシンの前回の実行以降に発生していない場合、その後のEIDのセットは空であってもよいです。"
    },
    {
      "indent": 6,
      "text": "3. Determining and extracting the current delivery predictability information for the set of EIDs selected.",
      "ja": "3.決定及び選択のEIDのセットのための現在の送達の予測情報を抽出します。"
    },
    {
      "indent": 3,
      "text": "o The \"Send RIB Entries\" operation formats one or more RIB TLVs with the set of RIB entries identified in the \"Build RIB Entries\" operation and sends them to the peer. If the set is empty, a single RIB TLV with zero entries is sent. If more than one RIB TLV is sent, all but the last one MUST have the \"More RIB TLVs\" flag set to 1; the last or only one MUST have the flag set to 0.",
      "ja": "「RIBエントリを構築する」の操作で識別さRIBエントリのセットで動作フォーマット一つ以上のRIBのTLV「RIBエントリを送る」とピアに送信し、O。セットが空の場合は、ゼロのエントリを持つ単一RIBのTLVが送信されます。複数のRIB TLVが送信された場合は、最後の一つを除くすべてが1に設定されている「その他のRIBのTLV」フラグを持たなければなりません。最後または唯一の1が0に設定されたフラグを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The \"Clear Bundle Lists\" operation is defined as emptying the lists of bundles offered by the peer and bundles requested from the peer.",
      "ja": "O「クリアバンドルリスト」動作は、ピアから要求されたピアとバンドルによって提供バンドルのリストを空として定義されます。"
    },
    {
      "indent": 3,
      "text": "o The \"Notify ACKs\" operation is defined as informing the bundle protocol agent that PRoPHET ACKs has been received for one or more bundles in a Bundle Offer TLV using the Bundle Delivered interface (see Section 2.2).",
      "ja": "O「ACKを通知」操作はバンドルインターフェイスを配信使用TLVを提供PROPHET ACKがバンドル内の1つまたは複数のバンドルのために受信されたバンドルプロトコル剤を知らせるように定義される（セクション2.2参照）。"
    },
    {
      "indent": 3,
      "text": "o The \"Record Offers\" operation is defined as recording all the bundles offered in a Bundle Offer TLV in the list of bundles offers.",
      "ja": "操作はバンドルのオファーのリストにバンドルオファーTLVで提供されるすべてのバンドルを記録するように定義された「レコードのオファー」O。"
    },
    {
      "indent": 3,
      "text": "o The \"Select for Request\" operation prunes and sorts the list of offered bundles held into the list of requested bundles according to policy and the available resources ready for sending to the offering node.",
      "ja": "O操作プルーン「要求のための選択」と政策と提供ノードへ送信するための準備ができて利用可能なリソースに応じて要求されたバンドルのリストに開催された提供バンドルのリストをソートします。"
    },
    {
      "indent": 3,
      "text": "o The \"Send Requests\" operation is defined as formatting one or more non-empty Bundle Response TLVs and sending them to the offering node. If more than one Bundle Offer TLV is sent, all but the last one MUST have the \"More Offer/Response TLVs Following\" flag set to 1; the last or only one MUST have the flag set to 0.",
      "ja": "O「要求を送信」操作は、1以上の非空のバンドル応答TLVをフォーマットし、提供ノードに送信するように定義されます。複数のバンドルオファーTLVが送信される場合は、最後の一つを除くすべてが1に設定されたフラグを「以下のよりオファー/レスポンスのTLV」が必要です。最後または唯一の1が0に設定されたフラグを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The \"Record Bundle Received\" operation deletes a successfully received bundle from the list of requests.",
      "ja": "O「レコードバンドルは、受信した」操作が要求のリストから正常に受信バンドルを削除します。"
    },
    {
      "indent": 3,
      "text": "o The \"All Requests Done\" operation is defined as formatting and sending an empty Bundle Offer TLV, with the \"More Offer/Response TLVs Following\" flag set to 0, to the offering node.",
      "ja": "o「はすべての要求が完了」操作は、フォーマットとして定義され、提供ノードに、0に設定された「よりオファー/応答のTLVに続いて」フラグと、TLV空バンドルオファーを送信しています。"
    },
    {
      "indent": 3,
      "text": "o The \"Check Receiving\" operation is defined as checking with the node bundle protocol agent if bundle reception from the peer node is currently in progress. This is needed in case a timeout occurs while waiting for bundle reception and a very large bundle is being processed.",
      "ja": "O「チェック受信」動作は、ピア・ノードから受信バンドルが現在進行中である場合、ノードバンドルプロトコル剤でチェックとして定義されます。これは、バンドル受信と処理されている非常に大規模なバンドルを待っている間にタイムアウトが発生した場合に必要とされます。"
    },
    {
      "indent": 3,
      "text": "o The \"Start NE\" operation is defined as (re)starting the Timer(next_exchange).",
      "ja": "O「スタートNE」動作は、タイマ（next_exchange）を起動（再）として定義されます。"
    },
    {
      "indent": 3,
      "text": "The following events are specific to the Initiator role state machine:",
      "ja": "次のイベントは、イニシエータロールステートマシンに固有のものです："
    },
    {
      "indent": 3,
      "text": "LastBndlRcvd Bundle received from peer that is the only remaining bundle in Bundle Requests List.",
      "ja": "LastBndlRcvdバンドルは、バンドル内の唯一の残りのバンドルがリストを要求しているピアから受信しました。"
    },
    {
      "indent": 3,
      "text": "NotLastBndlRcvd Bundle received from peer that is not the only remaining bundle in Bundle Requests List.",
      "ja": "NotLastBndlRcvdバンドルは、バンドル内の唯一の残りのバンドルがリストを要求していない相手から受け取りました。"
    },
    {
      "indent": 3,
      "text": "OFRnotlast Bundle Offer TLV received with \"More Offer/Response TLVs Following\" flag set to 1.",
      "ja": "OFRnotlastバンドルオファーTLVは1に設定されたフラグ「に続いてより多くのオファー/レスポンスのTLV」を受け取りました。"
    },
    {
      "indent": 3,
      "text": "OFRlast Bundle Offer TLV received with \"More Offer/Response TLVs Following\" flag set to 0",
      "ja": "TLVは0にフラグセット「を以下のよりオファー/レスポンスのTLV」を受信OFRlastバンドルオファー"
    },
    {
      "indent": 3,
      "text": "Timeout(next_exch) The Timer(next_exchange) has expired",
      "ja": "タイムアウト（next_exch）タイマ（next_exchange）が期限切れになりました"
    },
    {
      "indent": 4,
      "text": "State: CREATE_DR",
      "ja": "状態：CREATE_DR"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|     Condition    |               Action              | New State |\n+==================+===================================+===========+\n|     On Entry     |    If previous state was ESTAB:   |           |\n|                  |         Initialize Dictionary     |           |\n|                  |    Always:                        |           |\n|                  |         Build RIB Entries         |           |\n|                  |         Wait for Init Start       | CREATE_DR |\n+------------------+-----------------------------------+-----------+\n|    InitStart     |    Send RIB Dictionary Updates    |           |\n|                  |    Send RIB Entries               |           |\n|                  |    Start TI                       |  SEND_DR  |\n+------------------+-----------------------------------+-----------+\n|      ErrDC       |           Abort Exchange          |(finished) |\n+------------------+-----------------------------------+-----------+\n|     ErrBadSI     |           Abort Exchange          |(finished) |\n+------------------+-----------------------------------+-----------+\n|     HelloAck     |           Abort Exchange          | CREATE_DR |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "State: SEND_DR",
      "ja": "状態：SEND_DR"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|     Condition    |               Action              | New State |\n+==================+===================================+===========+\n|     On Entry     |         Clear Bundle Lists        |  SEND_DR  |\n+------------------+-----------------------------------+-----------+\n|  Timeout(info)   |   Send RIB Dictionary Updates     |           |\n|                  |   Send RIB Entries (note 1)       |  SEND_DR  |\n+------------------+-----------------------------------+-----------+\n|  RIBDl received  |   Update Dictionary (note 2)      |           |\n|                  |   If Dictionary Conflict found:   |           |\n|                  |           Abort Exchange          | CREATE_DR |\n|                  |   Else:                           |           |\n|                  |           Start TI                |  SEND_DR  |\n+------------------+-----------------------------------+-----------+\n|    OFRnotlast    |           Notify ACKs             |           |\n|                  |           Record Offers           |           |\n|                  |           Start TI                |  SEND_DR  |\n+------------------+-----------------------------------+-----------+\n|     OFRlast      |           Cancel TI               |           |\n|                  |           Notify ACKs             |           |\n|                  |           Record Offers           |           |\n|                  |           Select for Request      |           |\n|                  |           Send Requests           |           |\n|                  |           Start TI                |  REQUEST  |\n+------------------+-----------------------------------+-----------+\n|      ErrDC       |           Abort Exchange          |(finished) |\n+------------------+-----------------------------------+-----------+\n|     ErrBadSI     |           Abort Exchange          |(finished) |\n+------------------+-----------------------------------+-----------+\n|     HelloAck     |           Abort Exchange          | CREATE_DR |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "State: REQUEST",
      "ja": "状態：REQUEST"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|     Condition    |               Action              | New State |\n+==================+===================================+===========+\n|  Timeout(info)   |  Check Receiving                  |           |\n|                  |  If bundle reception in progress: |           |\n|                  |         Start TI                  |  REQUEST  |\n|                  |  Otherwise:                       |           |\n|                  |         Send Requests             |           |\n|                  |         Start TI (note 3)         |  REQUEST  |\n+------------------+-----------------------------------+-----------+\n| NotLastBndlRcvd  |     Record Bundle Received        |           |\n|                  |     Start TI                      |  REQUEST  |\n+------------------+-----------------------------------+-----------+\n|   LastBndlRcvd   |     Cancel TI                     |           |\n|                  |     All Requests Done             |           |\n|                  |     Start NE                      |  REQUEST  |\n+------------------+-----------------------------------+-----------+\n|Timeout(next_exch)|                                   | CREATE_DR |\n+------------------+-----------------------------------+-----------+\n|     HelloAck     |     Abort Exchange                | CREATE_DR |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note 1: No response to the RIB has been received before the timer expired, so we re-send the dictionary and RIB TLVs. If the timeout occurs repeatedly, it is likely that communication has failed and the connection MUST be terminated.",
      "ja": "注1：タイマが満了する前に、RIBへの応答が受信されているので、私たちは辞書とRIB TLVを再送信し。タイムアウトが繰り返し発生する場合は、通信が失敗したとの接続が終了しなければならない可能性が高いです。"
    },
    {
      "indent": 3,
      "text": "Note 2: If a Dictionary Conflict error has to be sent, the state machine will be aborted. If this event occurs repeatedly, it is likely that there is either a serious software problem or a security issue. The connection MUST be terminated.",
      "ja": "注2：辞書競合エラーが送信する必要がある場合は、ステートマシンは中止されます。このイベントが繰り返し発生する場合、重大なソフトウェアの問題やセキュリティ上の問題のいずれかがあることが考えられます。接続が終了しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note 3: Remaining requested bundles have not arrived before the timer expired, so we re-send the list of outstanding requests. If the timeout occurs repeatedly, it is likely that communication has failed and the connection MUST be terminated.",
      "ja": "注3：タイマが満了する前に残りの要求されたバンドルが到着していないので、我々は、未処理の要求のリストを再送信します。タイムアウトが繰り返し発生する場合は、通信が失敗したとの接続が終了しなければならない可能性が高いです。"
    },
    {
      "indent": 0,
      "text": "5.3.4.3. State Tables for the Listener Role",
      "section_title": true,
      "ja": "5.3.4.3。リスナーの役割のための状態テーブル"
    },
    {
      "indent": 3,
      "text": "The rules and state tables for the Listener role use the following operations:",
      "ja": "リスナーの役割のためのルールと状態テーブルには、次の操作を使用します。"
    },
    {
      "indent": 3,
      "text": "o The \"Clear Supplied RIBs\" operation is defined as setting up an empty container to hold the set of RIBs supplied by the peer node.",
      "ja": "O「クリア付属肋骨」操作は、ピア・ノードによって供給されたリブのセットを保持するために空の容器を設定するように定義されます。"
    },
    {
      "indent": 3,
      "text": "o The \"Record RIBs Supplied\" operation is defined as:",
      "ja": "操作は次のように定義される「レコードリブは付属の」o："
    },
    {
      "indent": 6,
      "text": "1. Taking the RIB entries from a received RIB TLV.",
      "section_title": true,
      "ja": "1.受信RIB TLVからRIBエントリをとります。"
    },
    {
      "indent": 6,
      "text": "2. Verifying that the String ID used in each entry is present in the dictionary. If not, an Error TLV containing the offending String ID is sent to the peer, and the Initiator and Listener processes are aborted and restarted as if the ESTAB state had just been reached.",
      "ja": "2.各エントリに使用される文字列IDが辞書に存在することを確認します。ない場合は、問題の文字列IDを含むエラーTLVは、ピアに送信され、ESTAB状態がちょうど到達したかのようにイニシエータとリスナープロセスが中止され、再開されます。"
    },
    {
      "indent": 6,
      "text": "3. If all the String IDs are present in the dictionary, record the delivery predictabilities for each EID in the entries.",
      "ja": "3.すべての文字列IDが辞書に存在している場合は、エントリ内の各EIDの配信予測精度を記録。"
    },
    {
      "indent": 3,
      "text": "o The \"Recalc Dlvy Predictabilities\" operation uses the algorithms defined in Section 2.1.2 to update the local set of delivery predictabilities using the using the set of delivery predictabilities supplied by the peer in RIB TLVs.",
      "ja": "O「再計算Dlvy予測精度」動作はRIBのTLVピアによって供給される配達の予測精度のセットを使用して使用して送達予測精度のローカルセットを更新するために、セクション2.1.2で定義されたアルゴリズムを使用します。"
    },
    {
      "indent": 3,
      "text": "o The \"Determine Offers\" operation determines the set of bundles to be offered to the peer. The local delivery predictabilities and the delivery predictabilities supplied by the peer are compared, and a prioritized choice of the bundles stored in this node to be offered to the peer is made according to the configured queueing policy and forwarding strategy.",
      "ja": "「決定情報」操作oをピアに提供されるバンドルのセットを決定します。局所送達の予測精度およびピアによって供給される配達の予測精度を比較し、このノードに格納されたバンドルの優先選択は、設定キューイングポリシーおよび転送戦略に従って行われるピアに提供します。"
    },
    {
      "indent": 3,
      "text": "o The \"Determine ACKs\" operation is defined as obtaining the set of PRoPHET ACKs recorded by the bundle protocol agent that need to be forwarded to the peer. The list of PRoPHET ACKs is maintained internally by the PRoPHET protocol implementation rather than the main bundle protocol agent (see Section 3.5).",
      "ja": "O「ACKを決定」操作がピアに転送する必要がバンドルプロトコルエージェントによって記録された預言者ACKのセットを取得するように定義されます。預言者ACKのリストは預言者のプロトコルの実装ではなく、主バンドルプロトコルエージェントによって内部的に維持される（セクション3.5参照）。"
    },
    {
      "indent": 3,
      "text": "o The \"Determine Offer Dict Updates\" operation is defined as determining any extra EIDs that are not already in the dictionary, recording the previous state of the local dictionary, and then adding the required extra entries to the dictionary.",
      "ja": "O「オファーdictのアップデートを決定」操作は、辞書に既にない余分のEIDを決定ローカル辞書の前の状態を記録し、その後、辞書に必要な余分なエントリを追加することと定義されます。"
    },
    {
      "indent": 3,
      "text": "o The \"Send Offers\" operation is defined as formatting one or more non-empty Bundle Offer TLVs, incorporating the sets of Offers and PRoPHET ACKs previously determined, and sending them to the peer node. If more than one Bundle Offer TLV is sent, all but the last one MUST have the \"More Offer/Response TLVs Following\" flag set to 1; the last or only one MUST have the flag set to 0.",
      "ja": "O「オファーを送る」動作は、1つ以上の非空バンドルオファーのTLVのフォーマット予め定めオファーと預言者ACKのセットを組み込んだ、とピア・ノードに送信するように定義されます。複数のバンドルオファーTLVが送信される場合は、最後の一つを除くすべてが1に設定されたフラグを「以下のよりオファー/レスポンスのTLV」が必要です。最後または唯一の1が0に設定されたフラグを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The \"Record Requests\" operation is defined as recording all the bundles offered in a Bundle Offer TLV in the list of bundles offers. Duplicates MUST be ignored. The order of requests in the TLVs MUST be maintained so far as is possible (it is possible that a bundle has to be re-sent, and this may result in out-of-order delivery).",
      "ja": "O「レコード・リクエスト」操作は、バンドルの提供のリストでバンドルオファーTLVで提供されるすべてのバンドルを記録として定義されます。重複を無視しなければなりません。 TLVにおけるリクエストの順序は、これまで可能であるように維持しなければならない（バンドルを再送信しなければならないことが可能であり、これはアウトオブオーダーの送達をもたらすことができます）。"
    },
    {
      "indent": 3,
      "text": "o The \"Send Bundles\" operation is defined as sending, in the order requested, the bundles in the requested list. This requires the list to be communicated to the bundle protocol agent (see Section 2.2).",
      "ja": "O「バンドルを送信」操作が要求されたリストには、要求された順序で、バンドルを送信するように定義されます。これは、バンドルプロトコルエージェントに伝達されるリストを必要とする（セクション2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "o The \"Check Initiator Start Point\" operation is defined as checking the configured sequential operation policy to determine if the Listener role has reached the point where the Initiator role should be started. If so, the InitStart notification is sent to the Initiator role in the same node.",
      "ja": "O「イニシエータスタート・ポイントを確認してください」操作は、リスナーの役割は、イニシエータの役割が開始されなければならない点に達したかどうかを決定するために構成された一連の動作の方針を確認するように定義されます。もしそうなら、INITSTART通知は、同じノード内のイニシエータの役割に送信されます。"
    },
    {
      "indent": 3,
      "text": "The following events are specific to the Listener role state machine:",
      "ja": "次のイベントは、リスナーの役割ステートマシンに固有のものです："
    },
    {
      "indent": 3,
      "text": "RIBnotlast RIB TLV received with \"More RIB TLVs\" flag set to 1.",
      "ja": "RIBnotlast RIB TLVが1に設定された「詳細RIBのTLV」フラグで受信しました。"
    },
    {
      "indent": 3,
      "text": "RIBlast RIB TLV received with \"More RIB TLVs\" flag set to 0 and a non-zero count of RIB Entries.",
      "ja": "RIBlast RIB TLV「が詳細RIBのTLV」を0に設定されたフラグとRIBエントリの非ゼロカウントで受信しました。"
    },
    {
      "indent": 3,
      "text": "REQnotlast Bundle Response TLV received with More Offer/Response TLVs Following flag set to 1.",
      "ja": "REQnotlastバンドル応答TLVは1に設定よりオファー/レスポンスのTLVに続いてフラグを受け取りました。"
    },
    {
      "indent": 3,
      "text": "REQlast Bundle Response TLV received with More Offer/Response TLVs Following flag set to 0 and a non-zero count of bundle offers.",
      "ja": "REQlastバンドル応答TLVは0に設定よりオファー/レスポンスのTLVに続いてフラグとバンドルオファーの非ゼロカウントを受け取りました。"
    },
    {
      "indent": 3,
      "text": "REQempty Bundle Response TLV received with More Offer/Response TLVs Following flag set to 0 and a zero count of bundle offers.",
      "ja": "REQemptyバンドル応答TLVは、より多くのオファー/レスポンスのTLVに続いて0に設定されたフラグとバンドルオファーのゼロカウントで受信しました。"
    },
    {
      "indent": 4,
      "text": "State: WAIT_DICT",
      "ja": "状態：WAIT_DICT"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|     Condition    |               Action              | New State |\n+==================+===================================+===========+\n|     On Entry     |     Check Initiator Start Point   | WAIT_DICT |\n+------------------+-----------------------------------+-----------+\n|       RIBDi      |     Update Dictionary (note 1)    |           |\n|                  |     If Dictionary Conflict found: |           |\n|                  |           Abort Exchange          |(finished) |\n|                  |     Else:                         |           |\n|                  |           Start TP                | WAIT_RIB  |\n+------------------+-----------------------------------+-----------+\n|     HelloAck     |     Abort Exchange                | WAIT_DICT |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "State: WAIT_RIB",
      "ja": "状態：WAIT_RIB"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|     Condition    |               Action              | New State |\n+==================+===================================+===========+\n|     On Entry     |   Clear Supplied RIBS             | WAIT_RIB  |\n+------------------+-----------------------------------+-----------+\n|       RIBDi      |   Update Dictionary (note 1)      |           |\n|                  |   If Dictionary Conflict found:   |           |\n|                  |         Abort Exchange            |(finished) |\n|                  |   Else:                           |           |\n|                  |         Start TP                  | WAIT_RIB  |\n+------------------+-----------------------------------+-----------+\n|    RIBnotlast    |   Record RIBS Supplied (note 2)   |           |\n|                  |   If EID missing in dictionary:   |           |\n|                  |         Abort Exchange            |(finished) |\n|                  |   Else:                           |           |\n|                  |         Start TP                  | WAIT_RIB  |\n+------------------+-----------------------------------+-----------\n|     RIBlast      |   Check Initiator Start Point     |           |\n|                  |   Record RIBS Supplied (note 2)   |           |\n|                  |   If EID missing in dictionary:   |           |\n|                  |         Abort Exchange            |(finished) |\n|                  |   Otherwise                       |           |\n|                  |         Recalc Dlvy               |           |\n|                  |               Predictabilities    |           |\n|                  |         Cancel TP                 |           |\n|                  |         Determine Offers          |           |\n|                  |         Determine ACKs            |           |\n|                  |         Determine Offer           |           |\n|                  |               Dict Updates        |           |\n|                  |         Send RIB Dictionary       |           |\n|                  |               Updates             |           |\n|                  |         Send Offers               |           |\n|                  |         Start TI                  |   OFFER   |\n+------------------+-----------------------------------+-----------+\n|     HelloAck     |     Abort Exchange                | WAIT_DICT |\n+------------------+-----------------------------------+-----------+\n|Any Other TLV rcvd|     Abort Exchange                |(finished) |\n+------------------+-----------------------------------+-----------+\n|  Timeout(peer)   |     Send RIB Dictionary Updates   |           |\n|                  |     Send Offers                   |           |\n|                  |     Start TI (note 3)             |   OFFER   |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "State: OFFER",
      "ja": "状態：OFFER"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|     Condition    |               Action              | New State |\n+==================+===================================+===========+\n|    REQnotlast    |      Send Bundles                 |           |\n|                  |      Start TI                     |   OFFER   |\n+------------------+-----------------------------------+-----------+\n|     REQlast      |      Cancel TI                    |           |\n|                  |      Check Initiator Start Point  |           |\n|                  |      Send Bundles                 | SND_BUNDLE|\n+------------------+-----------------------------------+-----------+\n|     REQempty     |      Cancel TI                    |           |\n|                  |      Check Initiator Start Point  | WAIT_MORE|\n+------------------+-----------------------------------+-----------+\n|     HelloAck     |      Abort Exchange               | WAIT_DICT |\n+------------------+-----------------------------------+-----------+\n|  Timeout(info)   |      Send RIB Dictionary Updates  |           |\n|                  |      Send Offers                  |           |\n|                  |      Start TI (note 3)            |   OFFER   |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "State: SND_BUNDLE",
      "ja": "状態：SND_BUNDLE"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|     Condition    |               Action              | New State |\n+==================+===================================+===========+\n|    REQnotlast    |      Send Bundles                 |           |\n|                  |      Start TI                     | SND_BUNDLE|\n+------------------+-----------------------------------+-----------+\n|     REQlast      |      Cancel TI                    |           |\n|                  |      Send Bundles                 | SND_BUNDLE|\n+------------------+-----------------------------------+-----------+\n|     REQempty     |      Cancel TI                    |           |\n|                  |      Check Initiator Start Point  | WAIT_MORE|\n+------------------+-----------------------------------+-----------+\n|     HelloAck     |      Abort Exchange               | WAIT_DICT |\n+------------------+-----------------------------------+-----------+\n|  Timeout(info)   |      Send RIB Dictionary Updates  |           |\n|                  |      Send Offers                  |           |\n|                  |      Start TI (note 3)            |   OFFER   |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "State: WAIT_MORE",
      "ja": "状態：WAIT_MORE"
    },
    {
      "indent": 4,
      "text": "+==================================================================+\n|     Condition    |               Action              | New State |\n+==================+===================================+===========+\n| More Bundles     |         Determine Offers          |           |\n|                  |         Determine ACKs            |           |\n|                  |         Determine Offer           |           |\n|                  |               Dict Updates        |           |\n|                  |         Send RIB Dictionary       |           |\n|                  |               Updates             |           |\n|                  |         Send Offers               |           |\n|                  |         Start TI                  |   OFFER   |\n+------------------+-----------------------------------+-----------+\n|       RIBDi      |   Update Dictionary (note 1)      |           |\n|                  |   If Dictionary Conflict found:   |           |\n|                  |         Abort Exchange            |(finished) |\n|                  |   Else:                           |           |\n|                  |         Start TP                  | WAIT_RIB  |\n+------------------+-----------------------------------+-----------+\n|    REQnotlast    |      Send Bundles                 |           |\n|                  |      Start TI                     | SND_BUNDLE|\n+------------------+-----------------------------------+-----------+\n|     REQlast      |      Cancel TI                    |           |\n|                  |      Send Bundles                 | SND_BUNDLE|\n+------------------+-----------------------------------+-----------+\n|     REQempty     |      Cancel TI                    |           |\n|                  |      Check Initiator Start Point  | SND_BUNDLE|\n+------------------+-----------------------------------+-----------+\n|     HelloAck     |      Abort Exchange               | WAIT_DICT |\n+------------------+-----------------------------------+-----------+\n|  Timeout(info)   |      Send RIB Dictionary Updates  |           |\n|                  |      Send Offers                  |           |\n|                  |      Start TI (note 3)            |   OFFER   |\n+==================================================================+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note 1: Both the dictionary and the RIB TLVs may come in the same PRoPHET message. In that case, the state will change to WAIT_RIB, and the RIB will then immediately be processed.",
      "ja": "注1：辞書とのTLVが同じ預言者メッセージに来るかもしれないRIB両方。その場合、状態はWAIT_RIBに変わり、RIBは直ちに処理されます。"
    },
    {
      "indent": 3,
      "text": "Note 2: Send an ACK if the timer for the peering node expires. Either the link has been broken, and then the link setup will restart, or it will trigger the Information Exchange Phase to restart.",
      "ja": "注2：ピアリングノードのタイマーが満了した場合、ACKを送信します。どちらのリンクが破損している、その後、リンクセットアップが再起動されます、またはそれは、情報交換フェーズを再起動するようにトリガーされます。"
    },
    {
      "indent": 3,
      "text": "Note 3: When the RIB is received, it is possible for the PRoPHET agent to update its delivery predictabilities according to Section 2.1.2. The delivery predictabilities and the RIB is then used together with the forwarding strategy in use to create a bundle offer TLV. This is sent to the peering node.",
      "ja": "注3：RIBを受信した場合PROPHET剤はセクション2.1.2に従ってその配信予測精度を更新することが可能です。配信予測精度とリブは、その後バンドル提供TLVを作成するために使用されている転送戦略と一緒に使用されます。これは、ピアリングのノードに送信されます。"
    },
    {
      "indent": 3,
      "text": "Note 4: No more bundles are requested by the other node; transfer is complete.",
      "ja": "注4：これ以上のバンドルが他のノードによって要求されています。転送が完了しています。"
    },
    {
      "indent": 3,
      "text": "Note 5: No response to the bundle offer has been received before the timer expired, so we re-send the bundle offer.",
      "ja": "注5：タイマが満了する前にバンドル提供に対する応答が受信されているので、我々は、バンドルプランを再送信します。"
    },
    {
      "indent": 0,
      "text": "5.4. Interaction with Nodes Using Version 1 of PRoPHET",
      "section_title": true,
      "ja": "5.4。預言者のバージョン1を使用したノードとの相互作用"
    },
    {
      "indent": 3,
      "text": "There are existing implementations of PRoPHET based on draft versions of this specification that use version 1 of the protocol. There are a number of significant areas of difference between version 1 and version 2 as described in this document:",
      "ja": "プロトコルのバージョン1を使用し、この仕様のドラフトバージョンに基づいて預言者の既存の実装があります。この文書に記載されているように、バージョン1とバージョン2の間の差の有意な領域の数があります。"
    },
    {
      "indent": 3,
      "text": "o In version 1, the delivery predictability update equations were significantly different, and in the case of the transitivity equation (Equation 3) could lead to degraded performance or non-delivery of bundles in some circumstances.",
      "ja": "Oバージョン1では、配信予測更新式は有意に異なっていた、と推移方程式（式3）の場合に性能低下またはいくつかの状況においてバンドルの配信不能になりかねません。"
    },
    {
      "indent": 3,
      "text": "o In the current version , constraints were placed on the String IDs generated by each node to ensure that it was not possible for there to be a conflict if the IDs were generated concurrently and independently in the two nodes.",
      "ja": "O現在のバージョンでは、制約は、IDが二つのノードで同時にかつ独立して生成された場合、それは競合されるのが不可能であったことを確認するために各ノードによって生成された文字列IDに置きました。"
    },
    {
      "indent": 3,
      "text": "o In the current version, a flag has been added to the Routing Information Base Dictionary TLV to distinguish dictionary updates sent by the Initiator role and by the Listener role.",
      "ja": "O現在のバージョンでは、フラグは、イニシエータの役割によって、リスナーの役割によって送信された辞書の更新を区別するために、ルーティング情報ベース辞書TLVに追加されました。"
    },
    {
      "indent": 3,
      "text": "o In the current version, the Bundle Offer and Response TLVs have been significantly revised. The version 2 TLVs have been allocated new TLV Type numbers, and the version 1 TLVs (types 0xA2 and 0xA3) are now deprecated. For each bundle specifier, the source EID is transmitted in addition to the creation timestamp by version 2 to ensure that the bundle is uniquely identified. Version 2 also transmits the fragment payload offset and length when the offered bundle is a bundle fragment. The payload length can optionally be transmitted for each bundle (whether or not it is a fragment) to give the receiver additional information that can be useful when determining which bundle offers to accept.",
      "ja": "O現在のバージョンでは、バンドルのオファーと応答TLVが大幅に改訂されました。バージョン2つのTLVは、新しいTLVタイプ番号が割り当てられている、とバージョン1つのTLV（タイプ0xA2と0xA3の）が廃止されています。各バンドル指定子ため、ソースEIDは、バンドルを一意に識別されることを保証するために、バージョン2により作成タイムスタンプに加えて送信されます。提供されるバンドルは、バンドルフラグメントである場合、バージョン2はまた、フラグメントオフセットペイロードと長さを送信します。ペイロード長は、必要に応じて受信機を受け入れるようにオファーをバンドルするかを決定する際に有用であり得る付加的な情報を与えるために（それがフラグメントであるか否か）を各バンドルに伝送することができます。"
    },
    {
      "indent": 3,
      "text": "o The behavior of the system after the first Information Exchange Phase has been better defined. The state machine has been altered to better describe how the ongoing operations work. This has involved the removal of the high-level state WAIT_INFO and the addition of two states in the Listener role subsidiary state machine (SND_BUNDLE and WAIT_MORE). The protocol on the wire has not been altered by this change to the description of the state machine. However, the specification of the later stages of operation was slightly vague and might have been interpreted differently by various implementers.",
      "ja": "最初の情報交換フェーズが良く定義された後にシステムの振る舞いO。ステートマシンは、より良い継続的な運用がどのように動作するかを説明するように変更されています。これは、高レベル状態WAIT_INFOとリスナーの役割子会社ステートマシン（SND_BUNDLEとWAIT_MORE）における二つの状態の追加の除去を含んでいました。ワイヤ上のプロトコルは、状態マシンの記述にこの変更によって変更されていません。しかし、操作の後の段階の仕様はやや漠然とした、様々な実装によって異なって解釈されている場合があります。"
    },
    {
      "indent": 3,
      "text": "A node implementing version 2 of the PRoPHET protocol as defined in this document MAY ignore a communication opportunity with a node that sends a HELLO message indicating that it uses version 1, or it MAY partially downgrade and respond to messages as if it were a version 1 node. This means that the version field in all message headers MUST contain 1.",
      "ja": "この文書で定義されている預言者プロトコルのバージョン2を実装するノードは、バージョン1を使用することを示すハローメッセージを送信するノードとの通信機会を無視してもよく、またはそれはバージョン1であったかのように、部分的にダウングレードし、メッセージに応答することができますノード。これは、すべてのメッセージのヘッダーにバージョンフィールドが1を含まなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the version 2 node use the metric update equations defined in this document even when communicating with a version 1 node as this will partially inhibit the problems with the transitivity equation in version 1, and that the version 2 node modify any received metrics that are greater than (1 - delta) to be (1 - delta) to avoid becoming a \"sink\" for bundles that are not destined for this node. Also version 1 nodes cannot be explicitly offered bundle fragments, and an exchange with a node supporting version 1 MUST use the, now deprecated, previous versions of the Bundle Offer and Response TLVs.",
      "ja": "部分的にバージョン1で推移方程式の問題を阻害し、バージョン2ノードは、任意の受信されたメトリックを変更することであろうように、バージョン2のノードは、バージョン1つのノードと通信する場合でも、この文書で定義されたメトリックの更新式を使用することをお勧めします（1  - デルタ）よりも大きいことである（1  - デルタ）このノード宛てされていないバンドルの「シンク」になって回避します。また、バージョン1つのノードは、明示的にバンドルの断片を提供することができず、ノードサポートするバージョン1との交換は、バンドルのオファーと応答のTLVの、廃止、以前のバージョンを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Generally, nodes using version 1 should be upgraded if at all possible because of problems that have been identified.",
      "ja": "すべての可能であれば一般的には、バージョン1を使用してノードがあるため特定されてきた問題をアップグレードする必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Currently, PRoPHET does not specify any special security measures. As a routing protocol for intermittently connected networks, PRoPHET is a target for various attacks. The various known possible vulnerabilities are discussed in this section.",
      "ja": "現在、預言者は、特別なセキュリティ対策を指定していません。断続的に接続されたネットワークのためのルーティングプロトコルとして、預言者は、様々な攻撃の標的です。公知の種々の可能な脆弱性は、このセクションで説明されています。"
    },
    {
      "indent": 3,
      "text": "The attacks described here are not problematic if all nodes in the network can be trusted and are working towards a common goal. If there exist such a set of nodes, but there also exist malicious nodes, these security problems can be solved by introducing an authentication mechanism when two nodes meet, for example, using a public key system. Thus, only nodes that are known to be members of the trusted group of nodes are allowed to participate in the routing. This of course introduces the additional problem of key distribution, but that is not addressed here.",
      "ja": "ネットワーク内のすべてのノードが信頼することができ、共通の目標に向かって作業している場合は、ここで説明された攻撃は問題ではありません。ノードのようなセットが存在するだけでなく、悪意のあるノードが存在する場合、これらのセキュリティ問題は、例えば、2つのノードが満たす認証メカニズムを導入する公開鍵システムを使用することによって解決することができます。したがって、ノードの信頼されたグループのメンバーであることが知られている唯一のノードは、ルーティングに参加することを許可されています。もちろんこれは、鍵の配布の追加の問題を紹介し、それはここで扱われていません。"
    },
    {
      "indent": 3,
      "text": "Where suitable, the mechanisms (such as key management and bundle authentication or integrity checks) and terminology specified by the Bundle Security Protocol [RFC6257] are to be used.",
      "ja": "ここで適切な、バンドルセキュリティプロトコル[RFC6257]で指定された用語（例えば鍵管理バンドル認証または整合性チェックなど）の機構が使用されます。"
    },
    {
      "indent": 0,
      "text": "6.1. Attacks on the Operation of the Protocol",
      "section_title": true,
      "ja": "6.1。議定書の運用上の攻撃"
    },
    {
      "indent": 3,
      "text": "There are a number of kinds of attacks on the operation of the protocol that it would be possible to stage on a PRoPHET network. The attacks and possible remedies are listed here.",
      "ja": "預言者ネットワーク上のステージングすることも可能であるプロトコルの動作上の攻撃の種類がいくつかあります。攻撃と可能な救済策は、ここに記載されています。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Black-Hole Attack",
      "section_title": true,
      "ja": "6.1.1。ブラックホール攻撃"
    },
    {
      "indent": 3,
      "text": "A malicious node sets its delivery predictabilities for all destinations to a value close to or exactly equal to 1 and/or requests all bundles from nodes it meets, and does not forward any bundles. This has two effects, both causing messages to be drawn towards the black hole instead of to their correct destinations.",
      "ja": "悪意のあるノードは、に近いか1に正確に等しい値にすべての宛先のためにその送達予測精度を設定し、および/またはそれを満たすノードからのすべてのバンドルを要求し、任意のバンドルを転送しません。これは二つの効果、ブラックホールに向かっ代わりにそれらの正しい宛先に描画する両方の原因メッセージを有しています。"
    },
    {
      "indent": 3,
      "text": "1. A node encountering a malicious node will try to forward all its bundles to the malicious node, creating the belief that the bundle has been very favorably forwarded. Depending on the forwarding strategy and queueing policy in use, this might hamper future forwarding of the bundle and/or lead to premature dropping of the bundle.",
      "ja": "1.悪意のあるノードに遭遇したノードは、バンドルは非常に好意的に転送されたという信念を作成し、悪意のあるノードにそのすべてのバンドルを転送しようとします。転送戦略に応じて使用中政策をキューイング、これはバンドルの将来の転送を妨げるおよび/またはバンドルの早期脱落につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "2. Due to the transitivity, the delivery predictabilities reported by the malicious node will affect the delivery predictabilities of other nodes. This will create a gradient for all destinations with the black hole as the \"center of gravity\" towards which all bundles traverse. This should be particularly severe in connected parts of the network.",
      "ja": "2.により推移し、悪意のあるノードによって報告された配信予測精度は、他のノードの配信予測精度に影響を与えます。これは、すべての束が横断た向かって「重心」としてブラックホールを持つすべての宛先のグラデーションを作成します。これは、ネットワークの接続部分で特に深刻でなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.1.1.1. Attack Detection",
      "section_title": true,
      "ja": "6.1.1.1。攻撃の検出"
    },
    {
      "indent": 3,
      "text": "A node receiving a set of delivery predictabilities that are all at or close to 1 should be suspicious. Similarly, a node that accepts all bundles and offers none might be considered suspicious. However, these conditions are not impossible in normal operation.",
      "ja": "全く又は1に近い送達予測精度のセットを受信するノードは、疑わしいなければなりません。同様に、すべてのバンドルを受け入れ、どれを提供していますノードは、疑わしいと考えられるかもしれません。しかし、これらの条件は、通常の操作では不可能ではありません。"
    },
    {
      "indent": 0,
      "text": "6.1.1.2. Attack Prevention/Solution",
      "section_title": true,
      "ja": "6.1.1.2。攻撃の防止/ソリューション"
    },
    {
      "indent": 3,
      "text": "To prevent this attack, authentication between nodes that meet needs to be present. Nodes can also inspect the received metrics and bundle acceptances/offers for suspicious patterns and terminate communications with nodes that appear suspicious. The natural evolution of delivery predictabilities should mean that a genuine node would not be permanently ostracized even if the values lead to termination of a communication opportunity on one occasion. The epidemic nature of PRoPHET would mean that such a termination rarely leads to non-delivery of bundles.",
      "ja": "この攻撃、存在することのニーズを満たすノード間の認証を防ぐために。ノードはまた、疑わしいパターンを提供/受信メトリックとバンドル承諾を検査し、疑わしい現れるノードとの通信を終了することができます。配信予測精度の自然な進化は、値がある時の通信機会の終了につながる場合でも、本物のノードが永久に追放されないことを意味すべきです。預言者の流行の性質は、そのような終了はめったにバンドルの配信不能につながるないことを意味します。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Limited Black-Hole Attack / Identity Spoofing",
      "section_title": true,
      "ja": "6.1.2。リミテッドブラックホール攻撃/アイデンティティスプーフィング"
    },
    {
      "indent": 3,
      "text": "A malicious node misrepresents itself by claiming to be someone else. The effects of this attack are:",
      "ja": "悪意のあるノードは、他の誰かであると主張することで自分自身を詐称します。この攻撃の影響は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. The effects of the black-hole attack listed above hold for this attack as well, with the exception that only the delivery predictabilities and bundles for one particular destination are affected. This could be used to \"steal\" the data that should be going to a particular node.",
      "ja": "1.一つの特定の宛先に対してのみ配信予測精度とバンドルが影響を受けるを除いて、同様にこの攻撃のために保留上記ブラックホールの攻撃の影響。これは、特定のノードに行くべきであるデータを「盗む」ために使用することができます。"
    },
    {
      "indent": 3,
      "text": "2. In addition to the above problems, PRoPHET ACKs will be issued for the bundles that are delivered to the malicious node. This will cause these bundles to be removed from the network, reducing the chance that they will reach their real destination.",
      "ja": "2.上記の問題に加えて、預言者ACKは、悪意のあるノードに配信されているバンドルのために発行されます。これは、これらのバンドルは、彼らが彼らの本当の目的地に到達する可能性を低減、ネットワークから削除されることになります。"
    },
    {
      "indent": 0,
      "text": "6.1.2.1. Attack Detection",
      "section_title": true,
      "ja": "6.1.2.1。攻撃の検出"
    },
    {
      "indent": 3,
      "text": "The destination can detect that this kind of attack has occurred (but it cannot prevent the attack) when it receives a PRoPHET ACK for a bundle destined to itself but for which it did not receive the corresponding bundle.",
      "ja": "宛先は、この種の攻撃が発生したことを検出することができる（それは攻撃を防ぐことはできません）、それは自分宛バンドルの預言者ACKを受信したときが、そのためには、対応するバンドルを受信しませんでした。"
    },
    {
      "indent": 0,
      "text": "6.1.2.2. Attack Prevention/Solution",
      "section_title": true,
      "ja": "6.1.2.2。攻撃の防止/ソリューション"
    },
    {
      "indent": 3,
      "text": "To prevent this attack, authentication between nodes that meet needs to be present.",
      "ja": "この攻撃、存在することのニーズを満たすノード間の認証を防ぐために。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Fake PRoPHET ACKs",
      "section_title": true,
      "ja": "6.1.3。偽預言者のACK"
    },
    {
      "indent": 3,
      "text": "A malicious node may issue fake PRoPHET ACKs for all bundles (or only bundles for a certain destination if the attack is targeted at a single node) carried by nodes it met. The affected bundles will be deleted from the network, greatly reducing their probability of being delivered to the destination.",
      "ja": "（攻撃が単一のノードを対象とした場合、または特定の宛先に対してのみバンドル）悪意のあるノードは、それが満たさノードによって運ばれるすべてのバンドルのための偽預言者ACKを発行することができます。影響を受けた束は大きく宛先に配信されるそれらの確率を減少させる、ネットワークから削除されます。"
    },
    {
      "indent": 0,
      "text": "6.1.3.1. Attack Prevention/Solution",
      "section_title": true,
      "ja": "6.1.3.1。攻撃の防止/ソリューション"
    },
    {
      "indent": 3,
      "text": "If a public key cryptography system is in place, this attack can be prevented by mandating that all PRoPHET ACKs be signed by the destination. Similarly to other solutions using public key cryptography, this introduces the problem of key distribution.",
      "ja": "公開鍵暗号システムが整備されている場合は、この攻撃は、すべての預言者ACKが先によって署名されていることを義務づけることによって防止することができます。同様に、公開鍵暗号方式を使用して、他のソリューションと、これは鍵の配布の問題を紹介します。"
    },
    {
      "indent": 0,
      "text": "6.1.4. Bundle Store Overflow",
      "section_title": true,
      "ja": "6.1.4。バンドルストアオーバーフロー"
    },
    {
      "indent": 3,
      "text": "After encountering and receiving the delivery predictability information from the victim, a malicious node may generate a large number of fake bundles for the destination for which the victim has the highest delivery predictability. This will cause the victim to most likely accept these bundles, filling up its bundle storage, possibly at the expense of other, legitimate, bundles. This problem is transient as the messages will be removed when the victim meets the destination and delivers the messages.",
      "ja": "遭遇すると、被害者からの配信予測情報を受信した後、悪意のあるノードは、被害者が最高の配信予測可能性を持っている宛先の偽バンドルの多数を生成することができます。これはおそらく他の、合法的な、バンドルを犠牲にし、その束収容を埋める、被害者が最も可能性が高いこれらのバンドルを受け入れるようになります。被害者が目的地を満たし、メッセージを配信する際、メッセージが削除されるように、この問題は一時的なものです。"
    },
    {
      "indent": 0,
      "text": "6.1.4.1. Attack Detection",
      "section_title": true,
      "ja": "6.1.4.1。攻撃の検出"
    },
    {
      "indent": 3,
      "text": "If it is possible for the destination to figure out that the bundles it is receiving are fake, it could report that malicious actions are underway.",
      "ja": "宛先は、それが受信しているバンドルが偽物であることを把握することが可能であるならば、それは悪質なアクションが進行中であることを報告することができます。"
    },
    {
      "indent": 0,
      "text": "6.1.4.2. Attack Prevention/Solution",
      "section_title": true,
      "ja": "6.1.4.2。攻撃の防止/ソリューション"
    },
    {
      "indent": 3,
      "text": "This attack could be prevented by requiring sending nodes to sign all bundles they send. By doing this, intermediate nodes could verify the integrity of the messages before accepting them for forwarding.",
      "ja": "この攻撃は、彼らが送信するすべてのバンドルに署名する送信ノードに要求することによって防ぐことができました。これにより、中間ノードは、転送のためにそれらを受け入れる前に、メッセージの整合性を検証することができます。"
    },
    {
      "indent": 0,
      "text": "6.1.5. Bundle Store Overflow with Delivery Predictability Manipulation",
      "section_title": true,
      "ja": "6.1.5。配信予測可能性の操作にバンドルストアオーバーフロー"
    },
    {
      "indent": 3,
      "text": "A more sophisticated version of the attack in the previous section can be attempted. The effect of the previous attack was lessened since the destination node of the fake bundles existed. This caused fake bundles to be purged from the network when the destination was encountered. The malicious node may now use the transitive property of the protocol to boost the victim's delivery predictabilities for a non-existent destination. After this, it creates a large number of fake bundles for this non-existent destination and offers them to the victim. As before, these bundles will fill up the bundle storage of the victim. The impact of this attack will be greater as there is no probability of the destination being encountered and the bundles being acknowledged. Thus, they will remain in the bundle storage until they time out (the malicious node may set the timeout to a large value) or until they are evicted by the queueing policy.",
      "ja": "前節の攻撃のより洗練されたバージョンを図ることができます。偽のバンドルの宛先ノードが存在していたので、前の攻撃の影響を軽減ました。これは、先に遭遇した時に偽のバンドルがネットワークから削除される原因となりました。悪意のあるノードは現在、存在しない宛先について、被害者の配信予測精度を高めるために、プロトコルの推移プロパティを使用することができます。この後は、この実在しない送信先の偽のバンドルを多数作成し、被害者にそれらを提供しています。前と同じように、これらのバンドルは、被害者のバンドルストレージをいっぱいになります。先に遭遇しているとのバンドルが認識されているのない可能性がないとして、この攻撃の影響は大きくなります。彼らは（悪意のあるノードが大きな値にタイムアウトを設定してもよい）、または、それらがキューイングポリシーによって追い出されるまで、タイムアウトまでしたがって、彼らは、バンドル記憶に残ります。"
    },
    {
      "indent": 3,
      "text": "The delivery predictability for the fake destination may spread in the network due to the transitivity, but this is not a problem, as it will eventually age and fade away.",
      "ja": "それは最終的に年齢と消えていくだろうと、偽の送信先の配信予測が原因推移にネットワークに広がるかもしれないが、これは問題ではありません。"
    },
    {
      "indent": 3,
      "text": "The impact of this attack could be increased if multiple malicious nodes collude, as network resources can be consumed at a greater speed and at many different places in the network simultaneously.",
      "ja": "複数悪意のあるノードが共謀場合、ネットワークリソースをより高速で、同時にネットワーク内のさまざまな場所で消費することができるようにこの攻撃の影響は、増加させることができます。"
    },
    {
      "indent": 0,
      "text": "6.2. Interactions with External Routing Domains",
      "section_title": true,
      "ja": "6.2。外部ルーティングドメインとの相互作用"
    },
    {
      "indent": 3,
      "text": "Users may opt to connect two regions of sparsely connected nodes through a connected network such as the Internet where another routing protocol is running. To this network, PRoPHET traffic would look like any other application-layer data. Extra care must be taken in setting up these gateway nodes and their interconnections to make sure that malicious nodes cannot use them to launch attacks on the infrastructure of the connected network. In particular, the traffic generated should not be significantly more than what a single regular user end host could create on the network.",
      "ja": "ユーザーは、別のルーティングプロトコルが動作しているインターネットのような接続されたネットワークを介してまばらに接続されたノードの2つの領域を接続することを選ぶことができます。このネットワークには、預言者のトラフィックは、他のアプリケーション層のデータのようになります。エクストラケアは、悪意のあるノードが接続されたネットワークのインフラストラクチャに攻撃を開始するためにそれらを使用することはできませんことを確認するために、これらのゲートウェイノードとそれらの相互接続を設定する際に注意する必要があります。具体的には、生成されたトラフィックは、単一の正規ユーザエンドホストがネットワーク上で作成することができるものよりもはるかにすべきではありません。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Following the policies outlined in \"Guidelines for Writing an IANA Considerations Section in RFCs\" (RFC 5226 [RFC5226]), the following name spaces are defined in PRoPHET.",
      "ja": "「RFCでIANA問題部に書くためのガイドライン」（RFC 5226 [RFC5226]）で概説された方針に続いて、次の名前空間が預言者で定義されています。"
    },
    {
      "indent": 3,
      "text": "o For fields in the PRoPHET message header (Section 4.1):",
      "ja": "預言者のメッセージ・ヘッダ（セクション4.1）のフィールドにO："
    },
    {
      "indent": 6,
      "text": "* DTN Routing Protocol Number",
      "ja": "* DTNルーティングプロトコル番号"
    },
    {
      "indent": 6,
      "text": "* PRoPHET Protocol Version",
      "ja": "* PROPHETプロトコルバージョン"
    },
    {
      "indent": 6,
      "text": "* PRoPHET Header Flags",
      "ja": "*預言者ヘッダーのフラグ"
    },
    {
      "indent": 6,
      "text": "* PRoPHET Result Field",
      "ja": "* PROPHET結果フィールド"
    },
    {
      "indent": 6,
      "text": "* PRoPHET Codes for Success and Codes for Failure",
      "ja": "失敗のための*預言者の成功のためのコードとコード"
    },
    {
      "indent": 3,
      "text": "o Identifiers for TLVs carried in PRoPHET messages:",
      "ja": "預言者のメッセージで運ばれたTLVのためのO識別子："
    },
    {
      "indent": 6,
      "text": "* PRoPHET TLV Type (Section 4.2)",
      "ja": "*預言者TLVタイプ（4.2節）"
    },
    {
      "indent": 3,
      "text": "o Definitions of TLV Flags and other flag fields in TLVs:",
      "ja": "TLVフラグとのTLV内の他のフラグフィールドの定義○："
    },
    {
      "indent": 6,
      "text": "* Hello TLV Flags (Section 4.3.1)",
      "ja": "*こんにちはTLVフラグ（4.3.1項）"
    },
    {
      "indent": 6,
      "text": "* Error TLV Flags (Section 4.3.2)",
      "ja": "*エラーTLVフラグ（4.3.2項）"
    },
    {
      "indent": 6,
      "text": "* Routing Information Base (RIB) Dictionary TLV Flags (Section 4.3.3)",
      "ja": "*ルーティング情報ベース（RIB）辞書TLVフラグ（4.3.3）"
    },
    {
      "indent": 6,
      "text": "* Routing Information Base (RIB) TLV Flags (Section 4.3.4)",
      "ja": "*ルーティング情報ベース（RIB）TLVフラグ（4.3.4項）"
    },
    {
      "indent": 6,
      "text": "* Routing Information Base (RIB) Flags per entry (Section 4.3.4)",
      "ja": "*ルーティング情報ベース（RIB）エントリあたりの国旗（4.3.4項）"
    },
    {
      "indent": 6,
      "text": "* Bundle Offer and Response TLV Flags (Section 4.3.5)",
      "ja": "*バンドルオファーと応答TLVフラグ（4.3.5項）"
    },
    {
      "indent": 6,
      "text": "* Bundle Offer and Response B Flags per offer or response (Section 4.3.5)",
      "ja": "*提供や応答あたりのバンドルオファーとレスポンスBフラグ（4.3.5項）"
    },
    {
      "indent": 3,
      "text": "The following subsections list the registries that have been created. Initial values for the registries are given below; future assignments for unassigned values are to be made through the Specification Required policy. Where specific values are defined in the IANA registries according to the specifications in the subsections below, the registry refers to this document as defining the allocation.",
      "ja": "以下のサブセクションでは、作成されたレジストリを一覧表示します。レジストリの初期値は以下の通りです。割り当てられていない値のための将来の割り当ては、仕様が必要でポリシーを介して行われるべきです。具体的な値は、以下のサブセクションで仕様に従ってIANAレジストリに定義されている場合、レジストリは、割り当てを定義するように、このドキュメントを指します。"
    },
    {
      "indent": 0,
      "text": "7.1. DTN Routing Protocol Number",
      "section_title": true,
      "ja": "7.1。 DTNルーティングプロトコル番号"
    },
    {
      "indent": 3,
      "text": "The encoding of the Protocol Number field in the PRoPHET header (Section 4.1) is:",
      "ja": "PROPHETヘッダ内のプロトコル番号フィールドの符号化（セクション4.1）です。"
    },
    {
      "indent": 9,
      "text": "+--------------------------+-----------+---------------+\n|         Protocol         |   Value   |   Reference   |\n+--------------------------+-----------+---------------+\n|     PRoPHET Protocol     |    0x00   | This document |\n|        Unassigned        | 0x01-0xEF |               |\n| Private/Experimental Use | 0xF0-0xFF | This document |\n+--------------------------+-----------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2. PRoPHET Protocol Version",
      "section_title": true,
      "ja": "7.2。 PROPHETプロトコルバージョン"
    },
    {
      "indent": 3,
      "text": "The encoding of the PRoPHET Version field in the PRoPHET header (Section 4.1) is:",
      "ja": "PROPHETヘッダ（4.1節）で預言Versionフィールドの符号化です。"
    },
    {
      "indent": 8,
      "text": "+----------------------------+-----------+---------------+\n|           Version          |   Value   |   Reference   |\n+----------------------------+-----------+---------------+\n| Reserved (do not allocate) |    0x00   | This document |\n|         PRoPHET v1         |    0x01   | This document |\n|         PRoPHET v2         |    0x02   | This document |\n|         Unassigned         | 0x03-0xEF |               |\n|  Private/Experimental Use  | 0xF0-0xFE | This document |\n|          Reserved          |    0xFF   |               |\n+----------------------------+-----------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3. PRoPHET Header Flags",
      "section_title": true,
      "ja": "7.3。預言者ヘッダーフラグ"
    },
    {
      "indent": 3,
      "text": "The following Flags are defined for the PRoPHET Header (Section 4.1):",
      "ja": "以下のフラグは、預言者ヘッダー（セクション4.1）のために定義されています。"
    },
    {
      "indent": 17,
      "text": "+------------+--------------+-----------+\n|   Meaning  | Bit Position | Reference |\n+------------+--------------+-----------+\n| Unassigned |     Bit 0    |           |\n| Unassigned |     Bit 1    |           |\n| Unassigned |     Bit 2    |           |\n| Unassigned |     Bit 3    |           |\n+------------+--------------+-----------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.4. PRoPHET Result Field",
      "section_title": true,
      "ja": "7.4。預言者の結果フィールド"
    },
    {
      "indent": 3,
      "text": "The encoding of the Result field in the PRoPHET header (Section 4.1) is:",
      "ja": "PROPHETヘッダーの結果フィールドの符号化（セクション4.1）です。"
    },
    {
      "indent": 8,
      "text": "+--------------------------+-------------+---------------+\n|       Result Value       |    Value    |   Reference   |\n+--------------------------+-------------+---------------+\n|         Reserved         |     0x00    | This document |\n|       NoSuccessAck       |     0x01    | This document |\n|          AckAll          |     0x02    | This document |\n|          Success         |     0x03    | This document |\n|          Failure         |     0x04    | This document |\n|       ReturnReceipt      |     0x05    | This document |\n|        Unassigned        | 0x06 - 0x7F |               |\n| Private/Experimental Use | 0x80 - 0xFF | This document |\n+--------------------------+-------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.5. PRoPHET Codes for Success and Codes for Failure",
      "section_title": true,
      "ja": "7.5。成功と失敗のためのコードのための預言者コード"
    },
    {
      "indent": 3,
      "text": "The encoding for Code field in the PRoPHET header (Section 4.1) for \"Success\" messages is:",
      "ja": "「成功」メッセージの預言者ヘッダ（セクション4.1）でコードフィールドの符号化です。"
    },
    {
      "indent": 8,
      "text": "+--------------------------+-------------+---------------+\n|         Code Name        |    Values   |   Reference   |\n+--------------------------+-------------+---------------+\n|      Generic Success     |     0x00    | This document |\n|    Submessage Received   |     0x01    | This document |\n|        Unassigned        | 0x02 - 0x7F |               |\n| Private/Experimental Use | 0x80 - 0xFF | This document |\n+--------------------------+-------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The encoding for Code in the PRoPHET header (Section 4.1) for \"Failure\" messages is:",
      "ja": "「失敗」メッセージの預言者ヘッダ（セクション4.1）でコードのエンコードです。"
    },
    {
      "indent": 7,
      "text": "+----------------------------+-------------+---------------+\n|          Code Name         |    Values   |   Reference   |\n+----------------------------+-------------+---------------+\n| Reserved (do not allocate) | 0x00 - 0x01 | This document |\n|     Unspecified Failure    |     0x02    | This document |\n|         Unassigned         | 0x03 - 0x7F |               |\n|  Private/Experimental Use  | 0x80 - 0xFE | This document |\n|    Error TLV in Message    |     0xFF    | This document |\n+----------------------------+-------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.6. PRoPHET TLV Type",
      "section_title": true,
      "ja": "7.6。預言者TLVタイプ"
    },
    {
      "indent": 3,
      "text": "The TLV Types defined for PRoPHET (Section 4.2) are:",
      "ja": "預言者（セクション4.2）のために定義されたTLVの種類は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "+------------------------------+-------------+---------------+\n|             Type             |    Value    |   Reference   |\n+------------------------------+-------------+---------------+\n|  Reserved (do not allocate)  |     0x00    | This document |\n|           Hello TLV          |     0x01    | This document |\n|           Error TLV          |     0x02    | This document |\n|          Unsassigned         | 0x03 - 0x9F |               |\n|      RIB dictionary TLV      |     0xA0    | This document |\n|            RIB TLV           |     0xA1    | This document |\n|   Bundle Offer (deprecated)  |     0xA2    | This document |\n| Bundle Response (deprecated) |     0xA3    | This document |\n|       Bundle Offer (v2)      |     0xA4    | This document |\n|     Bundle Response (v2)     |     0xA5    | This document |\n|          Unassigned          | 0xA6 - 0xCF |               |\n|   Private/Experimental Use   | 0xD0 - 0xFF | This document |\n+------------------------------+-------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.7. Hello TLV Flags",
      "section_title": true,
      "ja": "7.7。こんにちはTLVフラグ"
    },
    {
      "indent": 3,
      "text": "The following TLV Flags are defined for the Hello TLV (Section 4.3.1). Flag numbers 0, 1, and 2 are treated as a 3-bit unsigned integer with 5 of the 8 possible values allocated, and the other 3 reserved. The remaining bits are treated individually:",
      "ja": "以下のTLVフラグは、こんにちはTLV（4.3.1）のために定義されています。フラグ番号0,1、及び2が割り当てられた8つの可能な値の5と3ビットの符号なし整数として扱われ、他の3つが予約されています。残りのビットは個別に処理されます。"
    },
    {
      "indent": 3,
      "text": "+----------------------------+---------------------+---------------+\n|           Meaning          |        Value        |   Reference   |\n+----------------------------+---------------------+---------------+\n|                            | (Flags 0, 1, and 2) |               |\n| Reserved (do not allocate) |        0b000        | This document |\n|             SYN            |        0b001        | This document |\n|           SYNACK           |        0b010        | This document |\n|             ACK            |        0b011        | This document |\n|           RSTACK           |        0b100        | This document |\n|         Unassigned         |    0b101 - 0b111    |               |\n|                            |    (Flags 3 - 7)    |               |\n|         Unassigned         |        Flag 3       |               |\n|         Unassigned         |        Flag 4       |               |\n|         Unassigned         |        Flag 5       |               |\n|         Unassigned         |        Flag 6       |               |\n|           L Flag           |        Flag 7       | This document |\n+----------------------------+---------------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.8. Error TLV Flags",
      "section_title": true,
      "ja": "7.8。エラーTLVフラグ"
    },
    {
      "indent": 3,
      "text": "The TLV Flags field in the Error TLV (Section 4.3.2) is treated as an unsigned 8-bit integer encoding the Error TLV number. The following values are defined:",
      "ja": "エラーTLV（4.3.2）におけるTLVフラグフィールドはエラーTLV番号をコードする符号なし8ビット整数として扱われます。次の値が定義されています。"
    },
    {
      "indent": 6,
      "text": "+--------------------------+------------------+---------------+\n|      Error TLV Name      | Error TLV Number |   Reference   |\n+--------------------------+------------------+---------------+\n|    Dictionary Conflict   |       0x00       | This document |\n|       Bad String ID      |       0x01       | This document |\n|        Unassigned        |    0x02 - 0x7F   |               |\n| Private/Experimental Use |    0x80 - 0xFF   | This document |\n+--------------------------+------------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.9. RIB Dictionary TLV Flags",
      "section_title": true,
      "ja": "7.9。 RIB辞書TLVフラグ"
    },
    {
      "indent": 3,
      "text": "The following TLV Flags are defined for the RIB Base Dictionary TLV (Section 4.3.3):",
      "ja": "次のTLVフラグはRIBベース辞書TLV（セクション4.3.3）のために定義されています。"
    },
    {
      "indent": 7,
      "text": "+----------------------------+--------------+---------------+\n|           Meaning          | Bit Position |   Reference   |\n+----------------------------+--------------+---------------+\n|      Sent by Listener      |    Flag 0    | This document |\n| Reserved (do not allocate) |    Flag 1    | This document |\n| Reserved (do not allocate) |    Flag 2    | This document |\n|         Unassigned         |    Flag 3    |               |\n|         Unassigned         |    Flag 4    |               |\n|         Unassigned         |    Flag 5    |               |\n|         Unassigned         |    Flag 6    |               |\n|         Unassigned         |    Flag 7    |               |\n+----------------------------+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.10. RIB TLV Flags",
      "section_title": true,
      "ja": "7.10。 RIB TLVフラグ"
    },
    {
      "indent": 3,
      "text": "The following TLV Flags are defined for the RIB TLV (Section 4.3.4):",
      "ja": "以下のTLVフラグはRIB TLV（4.3.4項）のために定義されています。"
    },
    {
      "indent": 7,
      "text": "+----------------------------+--------------+---------------+\n|           Meaning          | Bit Position |   Reference   |\n+----------------------------+--------------+---------------+\n|        More RIB TLVs       |    Flag 0    | This document |\n| Reserved (do not allocate) |    Flag 1    | This document |\n| Reserved (do not allocate) |    Flag 2    | This document |\n|         Unassigned         |    Flag 3    |               |\n|         Unassigned         |    Flag 4    |               |\n|         Unassigned         |    Flag 5    |               |\n|         Unassigned         |    Flag 6    |               |\n|         Unassigned         |    Flag 7    |               |\n+----------------------------+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.11. RIB Flags",
      "section_title": true,
      "ja": "7.11。 RIBフラグ"
    },
    {
      "indent": 3,
      "text": "The following RIB Flags are defined for the individual entries in the RIB TLV (Section 4.3.4):",
      "ja": "次RIBフラグはRIB TLV（4.3.4項）内の個々のエントリのために定義されています。"
    },
    {
      "indent": 17,
      "text": "+------------+--------------+-----------+\n|   Meaning  | Bit Position | Reference |\n+------------+--------------+-----------+\n| Unassigned |    Flag 0    |           |\n| Unassigned |    Flag 1    |           |\n| Unassigned |    Flag 2    |           |\n| Unassigned |    Flag 3    |           |\n| Unassigned |    Flag 4    |           |\n| Unassigned |    Flag 5    |           |\n| Unassigned |    Flag 6    |           |\n| Unassigned |    Flag 7    |           |\n+------------+--------------+-----------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.12. Bundle Offer and Response TLV Flags",
      "section_title": true,
      "ja": "7.12。バンドルオファーと応答TLVフラグ"
    },
    {
      "indent": 3,
      "text": "The following TLV Flags are defined for the Bundle Offer and Response TLV (Section 4.3.5):",
      "ja": "以下のTLVフラグは、バンドルのオファーと応答TLV（4.3.5）のために定義されています。"
    },
    {
      "indent": 3,
      "text": "+------------------------------------+--------------+---------------+\n|               Meaning              | Bit Position |   Reference   |\n+------------------------------------+--------------+---------------+\n| More Offer/Response TLVs Following |    Flag 0    | This document |\n|             Unassigned             |    Flag 1    |               |\n|             Unassigned             |    Flag 2    |               |\n|             Unassigned             |    Flag 3    |               |\n|             Unassigned             |    Flag 4    |               |\n|             Unassigned             |    Flag 5    |               |\n|             Unassigned             |    Flag 6    |               |\n|             Unassigned             |    Flag 7    |               |\n+------------------------------------+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.13. Bundle Offer and Response B Flags",
      "section_title": true,
      "ja": "7.13。オファーとレスポンスBフラグをバンドル"
    },
    {
      "indent": 3,
      "text": "The following B Flags are defined for each Bundle Offer in the Bundle Offer and Response TLV (Section 4.3.5):",
      "ja": "以下のBフラグは、バンドルのオファーと応答TLV（4.3.5項）​​の各バンドルオファーのために定義されています。"
    },
    {
      "indent": 3,
      "text": "+------------------------------------+--------------+---------------+\n|               Meaning              | Bit Position |   Reference   |\n+------------------------------------+--------------+---------------+\n|           Bundle Accepted          |    Flag 0    | This document |\n|        Bundle is a Fragment        |    Flag 1    | This document |\n|  Bundle Payload Length Included in |    Flag 2    | This document |\n|                 TLV                |              |               |\n|             Unassigned             |    Flag 3    |               |\n|             Unassigned             |    Flag 4    |               |\n|             Unassigned             |    Flag 5    |               |\n|             Unassigned             |    Flag 6    |               |\n|             PRoPHET ACK            |    Flag 7    | This document |\n+------------------------------------+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8. Implementation Experience",
      "section_title": true,
      "ja": "8.実装経験"
    },
    {
      "indent": 3,
      "text": "Multiple independent implementations of the PRoPHET protocol exist.",
      "ja": "預言者のプロトコルの複数の独立した実装が存在します。"
    },
    {
      "indent": 3,
      "text": "The first implementation is written in Java, and has been optimized to run on the Lego MindStorms platform that has very limited resources. Due to the resource constraints, some parts of the protocol have been simplified or omitted, but the implementation contains all the important mechanisms to ensure proper protocol operation. The implementation is also highly modular and can be run on another system with only minor modifications (it has currently been shown to run on the Lego MindStorms platform and on regular laptops).",
      "ja": "最初の実装はJavaで書かれており、非常に限られた資源を持っているレゴマインドストームプラットフォーム上で動作するように最適化されています。リソースの制約のため、プロトコルの一部が簡略化または省略しますが、実装は、適切なプロトコルの動作を保証するために、すべての重要なメカニズムが含まれています。また、実装は高度にモジュール化され、わずかな修正（現在のレゴマインドストームプラットフォーム上で、通常のラップトップ上で実行することが示されている）と、別のシステム上で実行することができます。"
    },
    {
      "indent": 3,
      "text": "Another implementation is written in C++ and runs in the OmNet++ simulator to enable testing and evaluation of the protocol and new features. Experience and feedback from the implementers on early versions of the protocol have been incorporated into the current version.",
      "ja": "別の実装では、C ++で書かれたプロトコルと新機能のテストと評価を可能にするOmNet ++シミュレータで実行されます。プロトコルの初期バージョンの実装からの経験とフィードバックが現在のバージョンに組み込まれています。"
    },
    {
      "indent": 3,
      "text": "An implementation compliant to an Internet-Draft (which was posted in 2006 and eventually evolved into this RFC) has been written at Baylor University. This implementation has been integrated into the DTN2 reference implementation.",
      "ja": "（2006年に掲載され、最終的にこのRFCに進化した）インターネットドラフトに準拠した実装は、ベイラー大学で書かれています。この実装はDTN2リファレンス実装に統合されています。"
    },
    {
      "indent": 3,
      "text": "An implementation of the protocol in C++ was developed by one of the authors (Samo Grasic) at Lulea University of Technology (LTU) as part of the Saami Networking Connectivity project (see Section 9) and continues to track the development of the protocol. This work is now part of the Networking for Communications Challenged Communities (N4C) project and is used in N4C testbeds.",
      "ja": "C ++でのプロトコルの実装は、サーミネットワーク接続のプロジェクトの一環として、技術のルレオ大学（LTU）の著者の一人（サモGrasic）によって開発された（セクション9を参照）、プロトコルの開発を追跡し続けました。この作品は現在、コミュニケーション障害者のコミュニティ（N4C）プロジェクトのためのネットワークの一部であり、N4Cテストベッドで使用されています。"
    },
    {
      "indent": 0,
      "text": "9. Deployment Experience",
      "section_title": true,
      "ja": "9.展開体験"
    },
    {
      "indent": 3,
      "text": "During a week in August 2006, a proof-of-concept deployment of a DTN system, using the LTU PRoPHET implementation for routing was made in the Swedish mountains -- the target area for the Saami Network Connectivity project [ccnc07] [doria_02]. Four fixed camps with application gateways, one Internet gateway, and seven mobile relays were deployed. The deployment showed PRoPHET to be able to route bundles generated by different applications such as email and web caching.",
      "ja": "[doria_02] [ccnc07]サーミネットワーク接続のプロジェクトの対象地域 -  2006年8月に週の間に、ルーティングのためのLTU預言者の実装を使用したDTNシステムの概念実証の展開は、スウェーデンの山の中で行われました。アプリケーションゲートウェイ、1つのインターネットゲートウェイ、および7つのモバイルリレーと4つの固定キャンプが展開されました。展開は、預言者は、電子メールやWebキャッシングなど、さまざまなアプリケーションによって生成された配線束にできることを示しました。"
    },
    {
      "indent": 3,
      "text": "Within the realms of the SNC and N4C projects, multiple other deployments, both during summer and winter conditions, have been done at various scales during 2007-2010 [winsdr08].",
      "ja": "SNCとN4Cプロジェクトの王国内では、他の複数の展開は、両方の夏と冬の条件の間に、[winsdr08] 2007年から2010年の間に様々なスケールで行われています。"
    },
    {
      "indent": 3,
      "text": "An implementation has been made for Android-based mobile telephones in the Bytewalla project [bytewalla].",
      "ja": "実装は、[bytewalla] BytewallaプロジェクトでAndroidベースの携帯電話のために作られました。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgements",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Olov Schelen and Kaustubh S. Phanse for contributing valuable feedback regarding various aspects of the protocol. We would also like to thank all other reviewers and the DTNRG chairs for the feedback in the process of developing the protocol. The Hello TLV mechanism is loosely based on the Adjacency message developed for RFC 3292. Luka Birsa and Jeff Wilson have provided us with feedback from doing implementations of the protocol based on various preliminary versions of the document. Their feedback has helped us make the document easier to read for an implementer and has improved the protocol.",
      "ja": "著者は、プロトコルのさまざまな側面に関する貴重なフィードバックを貢献するためOlov SchelenとKaustubh S. Phanseに感謝したいと思います。また、プロトコルの開発プロセスにフィードバックするために他のすべてのレビューやDTNRGの椅子に感謝したいと思います。こんにちはTLV機構が緩くRFC 3292.ルカビルサとジェフ・ウィルソンのために開発された隣接のメッセージに基づいて文書のさまざまな暫定版に基づいてプロトコルの実装を行ってからのフィードバックを私たちに提供してきました。彼らのフィードバックは、私たちは実装のために読むためにドキュメントをより簡単に役立っているとプロトコルを改善しました。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5050] Scott, K. and S. Burleigh, \"Bundle Protocol Specification\", RFC 5050, November 2007.",
      "ja": "[RFC5050]スコット、K.およびS.バーリー、 \"バンドルプロトコル仕様\"、RFC 5050、2007年11月。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[CLAYER] Demmer, M., Ott, J., and S. Perreault, \"Delay Tolerant Networking TCP Convergence Layer Protocol\", Work in Progress, August 2012.",
      "ja": "[CLAYER] Demmer、M.、オット、J.、およびS.ペロー、 \"遅延耐性ネットワークTCPコンバージェンスレイヤプロトコル\"、進歩、2012年8月での作業。"
    },
    {
      "indent": 3,
      "text": "[RFC1058] Hedrick, C., \"Routing Information Protocol\", RFC 1058, June 1988.",
      "ja": "[RFC1058]ヘドリック、C.、​​ \"ルーティング情報プロトコル\"、RFC 1058、1988年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4838] Cerf, V., Burleigh, S., Hooke, A., Torgerson, L., Durst, R., Scott, K., Fall, K., and H. Weiss, \"Delay-Tolerant Networking Architecture\", RFC 4838, April 2007.",
      "ja": "[RFC4838]サーフ、V.、バーレイ、S.、フック、A.、Torgerson、L.、ダースト、R.、スコット、K.、秋、K.、およびH.ワイス、 \"遅延耐性ネットワークアーキテクチャ\" 、RFC 4838、2007年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC6257] Symington, S., Farrell, S., Weiss, H., and P. Lovell, \"Bundle Security Protocol Specification\", RFC 6257, May 2011.",
      "ja": "[RFC6257]シミントン、S.、ファレル、S.、ワイス、H.、およびP.ラヴェル、 \"バンドルセキュリティプロトコル仕様\"、RFC 6257、2011年5月。"
    },
    {
      "indent": 3,
      "text": "[bytewalla] Prasad, M., \"Bytewalla 3: Network architecture and PRoPHET implementation\", Bytewalla Project, KTH Royal Institute of Technology, Stockholm, Sweden, October 2010, <http://www.bytewalla.org/sites/bytewalla.org/files/ Bytewalla3_Network_architecture_and_PRoPHET_v1.0.pdf>.",
      "ja": "[bytewalla]プラサド、M.、 \"Bytewalla 3：ネットワークアーキテクチャと預言者の実装\"、Bytewallaプロジェクト、技術、ストックホルム、スウェーデン、2010年10月、<http://www.bytewalla.org/sites/bytewallaのKTH王立研究所。 ORG /ファイル/ Bytewalla3_Network_architecture_and_PRoPHET_v1.0.pdf>。"
    },
    {
      "indent": 3,
      "text": "[ccnc07] Lindgren, A. and A. Doria, \"Experiences from Deploying a Real-life DTN System\", Proceedings of the 4th Annual IEEE Consumer Communications and Networking Conference (CCNC 2007), Las Vegas, Nevada, USA, January 2007.",
      "ja": "[ccnc07]リンドグレーン、A.とA.ドリア、「実生活DTNシステムの導入から経験」、第4回IEEE消費者コミュニケーションとネットワーキング会議（CCNC 2007）、ラスベガス、ネバダ州、アメリカ、2007年1月の議事。"
    },
    {
      "indent": 3,
      "text": "[doria_02] Doria, A., Uden, M., and D. Pandey, \"Providing connectivity to the Saami nomadic community\", Proceedings of the 2nd International Conference on Open Collaborative Design for Sustainable Innovation (dyd 02), Bangalore, India, December 2002.",
      "ja": "[doria_02]ドリア、A.、ウーデン、M.、およびD.パンディ、「サーミ遊牧コミュニティへの接続を提供する」、持続可能なイノベーション（DYD 02）、バンガロール、インド、オープン協調設計に関する第2回国際会議の議事録2002年12月。"
    },
    {
      "indent": 3,
      "text": "[lindgren_06] Lindgren, A. and K. Phanse, \"Evaluation of Queueing Policies and Forwarding Strategies for Routing in Intermittently Connected Networks\", Proceedings of COMSWARE 2006, January 2006.",
      "ja": "[lindgren_06]リンドグレーン、A.およびK. Phanse、「断続的に接続されたネットワークにルーティングのための政策および転送戦略をキューイングの評価」、COMSWARE 2006の議事録、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[vahdat_00] Vahdat, A. and D. Becker, \"Epidemic Routing for Partially Connected Ad Hoc Networks\", Duke University Technical Report CS-200006, April 2000.",
      "ja": "[vahdat_00] Vahdat、A.とD.ベッカー、「部分的に接続アドホックネットワークのための流行ルーティング」、デューク大学の技術レポートCS-200006、2000年4月。"
    },
    {
      "indent": 3,
      "text": "[winsdr08] Lindgren, A., Doria, A., Lindblom, J., and M. Ek, \"Networking in the Land of Northern Lights - Two Years of Experiences from DTN System Deployments\", Proceedings of the ACM Wireless Networks and Systems for Developing Regions Workshop (WiNS-DR), San Francisco, California, USA, September 2008.",
      "ja": "[winsdr08]リンドグレーン、A.、ドリア、A.、リンドブロム、J.、およびM.エック、「オーロラの土地でのネットワーキング -  DTNシステム展開の経験から2年」、ACMワイヤレスネットワークとシステムの議事録地域ワークショップ（WINS-DR）、サンフランシスコ、カリフォルニア州、アメリカ、2008年9月を開発するため。"
    },
    {
      "indent": 0,
      "text": "Appendix A. PRoPHET Example",
      "ja": "付録A.預言者の例"
    },
    {
      "indent": 3,
      "text": "To help grasp the concepts of PRoPHET, an example is provided to give an understanding of the transitive property of the delivery predictability and the basic operation of PRoPHET. In Figure 13, we revisit the scenario where node A has a message it wants to send to node D. In the bottom right corner of subfigures a-c, the delivery predictability tables for the nodes are shown. Assume that nodes C and D encounter each other frequently (Figure 13a), making the delivery predictability values they have for each other high. Now assume that node C also frequently encounters node B (Figure 13b). Nodes B and C will get high delivery predictability values for each other, and the transitive property will also increase the value B has for D to a medium level. Finally, node B meets node A (Figure 13c), which has a message for node D. Figure 13d shows the message exchange between node A and node B. Summary vectors and delivery predictability information is exchanged, delivery predictabilities are updated, and node A then realizes that P_(b,d) > P_(a,d), and thus forwards the message for node D to node B.",
      "ja": "預言者の概念を把握しやすくするために、例では、配信予測の推移財産と預言者の基本的な操作の理解を与えるために提供されます。図13に、我々は、ノードAは、それが副図の右下のコーナーCにDをノードAに送信したいメッセージを有するシナリオを再訪、ノードの配信予測テーブルが示されています。彼らは高いお互いを持っている送達の予測値を作成する、すなわちCノードとしばしば互いに遭遇D仮定する（図13a）。今Cはまた、頻繁に遭遇するノード、ノードB（図13b）を仮定する。ノードB及びCは、互いに高デリバリーの予測値を取得する、及び推移プロパティは、値Bが中レベルにDに対して有する増加します。最後に、ノードBは、ノードAとノードBの概要ベクターおよび送達の予測情報が交換される間、送達予測精度が更新されるメッセージ交換を示し、ノードAノードD.図13Dのメッセージを有し、ノードA（図13c）を満たしています次いで、P_（B、D）> P_（D）、およびこのようにノードBにノードDのメッセージを転送することを実現します"
    },
    {
      "indent": 3,
      "text": "+----------------------------+   +----------------------------+\n|                            |   |                            |\n|                  C         |   |                       D    |\n|                   D        |   |                            |\n|       B                    |   |       B C                  |\n|                            |   |                            |\n|                            |   |                            |\n|                            |   |                            |\n|                            |   |                            |\n| A*                         |   | A*                         |\n+-------------+--------------+   +-------------+--------------+\n|   A  |   B  |   C   |  D   |   |   A  |   B  |   C   |  D   |\n|B:low |A:low |A:low  |A:low |   |B:low |A:low |A:low  |A:low |\n|C:low |C:low |B:low  |B:low |   |C:low |C:high|B:high |B:low |\n|D:low |D:low |D:high |C:high|   |D:low |D:med |D:high |C:high|\n+-------------+--------------+   +-------------+--------------+\n             (a)                              (b)\n+----------------------------+   A                            B\n|                            |   |                            |\n|                       D    |   |Summary vector&delivery pred|\n|                            |   |--------------------------->|\n|         C                  |   |Summary vector&delivery pred|\n|                            |   |<---------------------------|\n|                            |   |                            |\n|   B*                       |  Update delivery predictabilities\n|  A                         |   |                            |\n|                            |  Packet for D not in SV        |\n+-------------+--------------+  P(b,d)>P(a,d)                 |\n|   A  |   B  |   C   |  D   |  Thus, send                    |\n|B:low |A:low |A:low  |A:low |   |                            |\n|C:med |C:high|B:high |B:low |   |      Packet for D          |\n|D:low+|D:med |D:high |C:high|   |--------------------------->|\n+-------------+--------------+   |                            |\n             (c)                              (d)",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 13: PRoPHET example",
      "ja": "図13：PROPHET例"
    },
    {
      "indent": 0,
      "text": "Appendix B. Neighbor Discovery Example",
      "ja": "付録B.近隣探索例"
    },
    {
      "indent": 3,
      "text": "This section outlines an example of a simple neighbor discovery protocol that can be run in-between PRoPHET and the underlying layer in case lower layers do not provide methods for neighbor discovery. It assumes that the underlying layer supports broadcast messages as would be the case if a wireless infrastructure was involved.",
      "ja": "このセクションでは、近隣探索のための方法を提供しない場合、下部層に預言者と下地層との間に、実行することができる単純な近隣探索プロトコルの例を概説します。これは、ワイヤレスインフラストラクチャが関与していた場合のように、下地層は、ブロードキャストメッセージをサポートしていることを前提としています。"
    },
    {
      "indent": 3,
      "text": "Each node needs to maintain a list of its active neighbors. The operation of the protocol is as follows:",
      "ja": "各ノードは、そのアクティブネイバーのリストを維持する必要があります。次のようにプロトコルの動作を説明します。"
    },
    {
      "indent": 3,
      "text": "1. Every BEACON_INTERVAL milliseconds, the node does a local broadcast of a beacon that contains its identity and address, as well as the BEACON_INTERVAL value used by the node.",
      "ja": "1.すべてのBEACON_INTERVALミリ秒、ノードは、そのIDとアドレスが含まれているビーコンのローカル放送と同様に、ノードが使用するBEACON_INTERVAL値を行います。"
    },
    {
      "indent": 3,
      "text": "2. Upon reception of a beacon, the following can happen:",
      "section_title": true,
      "ja": "ビーコンを受信2.以下が起こることができます。"
    },
    {
      "indent": 7,
      "text": "A.  The sending node is already in the list of active neighbors.\n    Update its entry in the list with the current time, and\n    update the node's BEACON_INTERVAL if it has changed.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "B. The sending node is not in the list of active neighbors. Add the node to the list of active neighbors and record the current time and the node's BEACON_INTERVAL. Notify the PRoPHET agent that a new neighbor is available (\"New Neighbor\", as described in Section 2.4).",
      "ja": "B.は、送信ノードは、アクティブな隣人のリストにありません。アクティブな隣人のリストにノードを追加し、現在の時刻とノードのBEACON_INTERVALを記録。 （セクション2.4で説明したように、「新しい隣人」）の新しい隣人が利用可能である預言者エージェントに通知。"
    },
    {
      "indent": 3,
      "text": "3. If a beacon has not been received from a node in the list of active neighbors within a time period of NUM_ACCEPTED_LOSSES * BEACON_INTERVAL (for the BEACON_INTERVAL used by that node), it should be assumed that this node is no longer a neighbor. The entry for this node should be removed from the list of active neighbors, and the PRoPHET agent should be notified that a neighbor has left (\"Neighbor Gone\", as described in Section 2.4).",
      "ja": "前記ビーコンは、（そのノードによって使用BEACON_INTERVALため）NUM_ACCEPTED_LOSSES * BEACON_INTERVALの期間内にアクティブネイバーのリスト内のノードから受信されていない場合は、このノードがもはや隣人であると仮定されるべきではありません。このノードのエントリがアクティブネイバーのリストから削除されるべきであり、預言者剤は（セクション2.4で説明したように、「隣接ゴーン」）ネイバーが残っていることを通知しなければなりません。"
    },
    {
      "indent": 0,
      "text": "Appendix C. PRoPHET Parameter Calculation Example",
      "ja": "付録C.預言者パラメータ計算例"
    },
    {
      "indent": 3,
      "text": "The evolution of the delivery predictabilities in a PRoPHET node is controlled by three main equations defined in Section 2.1.2. These equations use a number of parameters that need to be appropriately configured to ensure that the delivery predictabilities evolve in a way that mirrors the mobility model that applies in the PRoPHET zone where the node is operating.",
      "ja": "預言者ノードにおける配信予測精度の進化は、セクション2.1.2で定義された三つの主要な方程式によって制御されます。これらの方程式は、適切配信予測精度は、ノードが動作している預言者ゾーンに適用される移動性モデルを反映するように進化していることを確認するように構成する必要があるパラメータの数を使用します。"
    },
    {
      "indent": 3,
      "text": "When trying to describe the mobility model, it is more likely that the model will be couched in terms of statistical distribution of times between encounters and times to deliver a bundle in the zone. In this section, one possible way of deriving the PRoPHET parameters from a more usual description of the model is presented. It should be remembered that this may not be the only solution, and its appropriateness will depend both on the overall mobility model and the distribution of the times involved. There is an implicit assumption in this work that these distributions can be characterized by a normal-type distribution with a well-defined first moment (mean). The exact form of the distribution is not considered here, but more detailed models may wish to use more specific knowledge about the distributions to refine the derivation of the parameters.",
      "ja": "モビリティモデルを記述しようとすると、モデルがゾーンにバンドルを提供する出会いと時間の間の時間の統計的分布の観点で表現される可能性が高いです。このセクションでは、モデルのより一般的な記述からPROPHETパラメータを導出する1つの可能な方法が提示されます。これが唯一の解決策ではないかもしれないということを忘れてはならないし、その妥当性は、全体的なモビリティモデルと関わる時間の分布の両方に依存します。これらの分布は明確に定義された一次モーメント（平均値）と、通常の型の分布によって特徴づけることができる。この作業で暗黙の仮定があります。分布の正確な形は、ここでは考慮されていないが、より詳細なモデルは、パラメータの導出を改善するためにディストリビューションについてのより具体的な知識を使用することもできます。"
    },
    {
      "indent": 3,
      "text": "To characterize the model, we consider the following parameters:",
      "ja": "モデルを特徴づけるために、我々は次のパラメータを考慮してください。"
    },
    {
      "indent": 3,
      "text": "P1 The time resolution of the model.",
      "ja": "P1モデルの時間分解能。"
    },
    {
      "indent": 3,
      "text": "P2 The average time between encounters between nodes, I_typ, where the identity of the nodes is not taken into account.",
      "ja": "P2ノードのアイデンティティを考慮していないノード、I_typ間遭遇間の平均時間。"
    },
    {
      "indent": 3,
      "text": "P3 The average number of encounters that a node has between meeting a particular node and meeting the same node again.",
      "ja": "P3ノードが特定のノードに合致し、再度同じノードを満たす間有する遭遇の平均数。"
    },
    {
      "indent": 3,
      "text": "P4 The average number of encounters needed to deliver a bundle in this zone.",
      "ja": "P4このゾーンのバンドルを提供するために必要な出会いの平均数。"
    },
    {
      "indent": 3,
      "text": "P5 The multiple of the average number of encounters needed to deliver a bundle (P4) after which it can be assumed that a node is not going to encounter a particular node again in the foreseeable future so that the delivery predictability ought to be decayed below P_first_threshold.",
      "ja": "P5が配信予測がP_first_threshold下に減衰されるべきであるように、ノードが近い将来に再び特定のノードに遭遇するつもりはないと仮定することができ、その後バンドルを提供するために必要な出会いの平均数（P4）の複数。"
    },
    {
      "indent": 3,
      "text": "P6 The number of encounters between a particular pair of nodes that should result in the delivery predictability of the encountered node getting close to the maximum possible delivery predictability (1 - delta).",
      "ja": "P6可能な最大配信予測（1  - デルタ）に近づく遭遇ノードの配信予測をもたらすべきであるノードの特定のペア間の出会いの数。"
    },
    {
      "indent": 3,
      "text": "We can use these parameters to derive appropriate values for gamma and P_encounter_max, which are the key parameters in the evolution of the delivery predictabilities. The values of the other parameters P_encounter_first (0.5), P_first_threshold (0.1), and delta (0.01), with the default values suggested in Figure 3, generally are not specific to the mobility model, although in special cases P_encounter_first may be different if extra information is available.",
      "ja": "我々は、配信予測精度の進化において重要なパラメータであり、ガンマとP_encounter_maxのための適切な値を導出するためにこれらのパラメータを使用することができます。特別な場合にP_encounter_first余分な異なる場合であってもよいが、図3に提案されたデフォルト値を持つ他のパラメータP_encounter_first（0.5）、P_first_threshold（0.1）、およびデルタ（0.01）の値は、一般に、モビリティ・モデルに固有のものではありません情報が提供されています。"
    },
    {
      "indent": 3,
      "text": "To select a value for gamma: After a single, unrepeated encounter, the delivery predictability of the encountered node should decay from P_encounter_first to P_first_threshold in the expected time for P4 * P5 encounters. Thus:",
      "ja": "ガンマの値を選択するには、次のシングル、中継されない出会いの後、遭遇したノードの配信予測はP4 * P5の出会いのための予想時間にP_first_thresholdするP_encounter_firstから崩壊しなければなりません。副<文>この[前述の事実の]結果として、それ故に、従って、だから◆【同】consequently; therefore <文>このような方法で、このようにして、こんなふうに、上に述べたように◆【同】in this manner <文>そのような程度まで<文> AひいてはB◆【用法】A and thus B <文>例えば◆【同】for example; as an example："
    },
    {
      "indent": 3,
      "text": "P_first_threshold = P_encounter_first * gamma ^ ((P2 * P4 * P5)/P1)",
      "ja": "P_first_threshold = P_encounter_first *ガンマ^（（P2 * P4 * P5）/ P1）"
    },
    {
      "indent": 3,
      "text": "which can be rearranged as",
      "ja": "どのように再配置することができます"
    },
    {
      "indent": 3,
      "text": "gamma = exp(ln(P_first_threshold/P_encounter_first) * P1 / (P2* P4 * P5)).",
      "ja": "ガンマ= EXP（LN（P_first_threshold / P_encounter_first）* P1 /（P2の*のP4の*のP5））。"
    },
    {
      "indent": 3,
      "text": "Typical values of gamma will be less than 1, but very close to 1 (usually greater than 0.99). The value has to be stored to several decimal places of accuracy, but implementations can create a table of values for specific intervals to reduce the amount of on-the-fly calculation required.",
      "ja": "ガンマの典型的な値は、1未満、しかし1（通常より大きい150）に非常に近くなります。値は、精度のいくつかの小数点以下に格納されなければならないが、実装が必要オンザフライ計算量を減らすために、特定の間隔の値の表を作成することができます。"
    },
    {
      "indent": 3,
      "text": "Selecting a value for P_encounter_max: Once gamma has been determined, the decay factor for the average time between encounters between a specific pair of nodes can be calculated: Decay_typ = gamma ^ ((P2 * P3)/P1)",
      "ja": "P_encounter_maxの値を選択する：ガンマが決定されると、ノードの特定の対の間の出会いの間の平均時間の減衰係数を計算することができる。Decay_typ =ガンマ^（（P2 * P3）/ P1）"
    },
    {
      "indent": 3,
      "text": "Starting with P_encounter_first, using Decay_typ and applying Equation 1 from Section 2.1.2 (P6 - 1) times, we can calculate the typical delivery predictability for the encountered node after P6 encounters. The nature of Equation 1 is such that it is not easy to produce a closed form that generates a value of P_encounter_max from the parameter values, but using a spreadsheet to apply the equation repeatedly and tabulate the results will allow a suitable value of P_encounter_max to be chosen very simply. The evolution is not very sensitive to the value of P_encounter_max, and values in the range 0.4 to 0.8 will generally be appropriate. A value of 0.7 is recommended as a default.",
      "ja": "、P_encounter_firstで始まるDecay_typを使用して、セクション2.1.2から式1を適用する（P6  -  1）回、我々は、P6の出会いの後に発生したノードのための典型的な配信予測可能性を計算することができます。式（1）の性質は、パラメータ値からP_encounter_maxの値を生成する閉じた形を製造するのは容易ではないようなものであるが、繰り返し式を適用し、結果を集計するためにスプレッドシートを使用することP_encounter_maxの適切な値があることを可能にします非常に単純に選ばれました。進化はP_encounter_maxの値に非常に敏感でなく、範囲内の値は0.4〜0.8、一般的に適切です。 0.7の値がデフォルトとして推奨されます。"
    },
    {
      "indent": 3,
      "text": "Once a PRoPHET zone has been in operation for some time, the logs of the actual encounters can and should be used to check that the selected parameters were appropriate and to tune them as necessary. In the longer term, it may prove possible to install a learning mode in nodes so that the parameters can be adjusted dynamically to maintain best congruence with the mobility model that may itself change over time.",
      "ja": "預言者ゾーンはいくつかの時間のために運営されていたら、実際の出会いのログは、選択したパラメータが適切であったとチューニングにそれらを必要に応じていることを確認するために使用されなければならないことができます。長期的には、それはパラメータ自体が時間の経過とともに変化することがありモビリティモデルで最高の合同を維持するために動的に調整することができるように、ノードに学習モードをインストールすることが可能になるかもしれません。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Anders F. Lindgren Swedish Institute of Computer Science Box 1263 Kista SE-164 29 SE",
      "ja": "アンダースF.リンドグレン、コンピュータサイエンスボックス1263シスタ、SE-164 29ギガバイトのスウェーデンの研究所"
    },
    {
      "indent": 3,
      "text": "Phone: +46707177269 EMail: andersl@sics.se URI: http://www.sics.se/~andersl",
      "ja": "電話番号：+46707177269 Eメール：andersl@sics.se URI：http://www.sics.se/~andersl"
    },
    {
      "indent": 3,
      "text": "Avri Doria Technicalities Providence RI US",
      "ja": "Avriドリア専門的プロビデンスRI米国"
    },
    {
      "indent": 3,
      "text": "EMail: avri@acm.org URI: http://psg.com/~avri",
      "ja": "電子メール：avri@acm.org URI：http://psg.com/~avri"
    },
    {
      "indent": 3,
      "text": "Elwyn Davies Folly Consulting Soham UK",
      "ja": "エルウィン・デイヴィスフォリーコンサルティングソーハム英国"
    },
    {
      "indent": 3,
      "text": "EMail: elwynd@folly.org.uk",
      "ja": "メールアドレス：elwynd@folly.org.uk"
    },
    {
      "indent": 3,
      "text": "Samo Grasic Lulea University of Technology Lulea SE-971 87 SE",
      "ja": "サモアGrasicルレオ工科大学のルーレオAN-971 87 A"
    },
    {
      "indent": 3,
      "text": "EMail: samo.grasic@ltu.se",
      "ja": "メールアドレス：samo.grasic@ltu.se"
    }
  ]
}