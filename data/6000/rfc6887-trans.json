{
  "title": {
    "text": "RFC 6887 - Port Control Protocol (PCP)",
    "ja": "RFC 6887 - ポート制御プロトコル（PCP）"
  },
  "number": 6887,
  "created_at": "2019-11-01 05:25:29.719042+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                      D. Wing, Ed.\nRequest for Comments: 6887                                         Cisco\nCategory: Standards Track                                    S. Cheshire\nISSN: 2070-1721                                                    Apple\n                                                            M. Boucadair\n                                                          France Telecom\n                                                                R. Penno\n                                                                   Cisco\n                                                              P. Selkirk\n                                                                     ISC\n                                                              April 2013",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Port Control Protocol (PCP)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Port Control Protocol allows an IPv6 or IPv4 host to control how incoming IPv6 or IPv4 packets are translated and forwarded by a Network Address Translator (NAT) or simple firewall, and also allows a host to optimize its outgoing NAT keepalive messages.",
      "ja": "ポート制御プロトコルは、IPv6またはIPv4ホストがIPv6またはIPv4パケットが翻訳され、ネットワークアドレス変換（NAT）または単純なファイアウォールによって転送されているか、着信制御することができ、また、ホストは、発信NATキープアライブメッセージを最適化することができます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6887.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6887で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。のセクション4.eで説明したように、コードのコンポーネントは、簡素化されたBSDライセンスのテキストを含める必要があり、この文書から抽出されました"
    },
    {
      "indent": 3,
      "text": "the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "トラスト法規定および簡体BSDライセンスで説明したように、保証なしで提供されています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n2.  Scope  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5\n  2.1.  Deployment Scenarios . . . . . . . . . . . . . . . . . . .  5\n  2.2.  Supported Protocols  . . . . . . . . . . . . . . . . . . .  5\n  2.3.  Single-Homed Customer Premises Network . . . . . . . . . .  5\n3.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  6\n4.  Relationship between PCP Server and Its PCP-Controlled\n    Device . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n5.  Note on Fixed-Size Addresses . . . . . . . . . . . . . . . . . 10\n6.  Protocol Design Note . . . . . . . . . . . . . . . . . . . . . 11\n7.  Common Request and Response Header Format  . . . . . . . . . . 13\n  7.1.  Request Header . . . . . . . . . . . . . . . . . . . . . . 14\n  7.2.  Response Header  . . . . . . . . . . . . . . . . . . . . . 15\n  7.3.  Options  . . . . . . . . . . . . . . . . . . . . . . . . . 16\n  7.4.  Result Codes . . . . . . . . . . . . . . . . . . . . . . . 19\n8.  General PCP Operation  . . . . . . . . . . . . . . . . . . . . 20\n  8.1.  General PCP Client: Generating a Request . . . . . . . . . 21\n    8.1.1.  PCP Client Retransmission  . . . . . . . . . . . . . . 22\n  8.2.  General PCP Server: Processing a Request . . . . . . . . . 24\n  8.3.  General PCP Client: Processing a Response  . . . . . . . . 25\n  8.4.  Multi-Interface Issues . . . . . . . . . . . . . . . . . . 27\n  8.5.  Epoch  . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n9.  Version Negotiation  . . . . . . . . . . . . . . . . . . . . . 29\n10. Introduction to MAP and PEER Opcodes . . . . . . . . . . . . . 30\n  10.1. For Operating a Server . . . . . . . . . . . . . . . . . . 33\n  10.2. For Operating a Symmetric Client/Server  . . . . . . . . . 35\n  10.3. For Reducing NAT or Firewall Keepalive Messages  . . . . . 37\n  10.4. For Restoring Lost Implicit TCP Dynamic Mapping State  . . 38\n11. MAP Opcode . . . . . . . . . . . . . . . . . . . . . . . . . . 39\n  11.1. MAP Operation Packet Formats . . . . . . . . . . . . . . . 40\n  11.2. Generating a MAP Request . . . . . . . . . . . . . . . . . 43\n    11.2.1. Renewing a Mapping . . . . . . . . . . . . . . . . . . 44\n  11.3. Processing a MAP Request . . . . . . . . . . . . . . . . . 44\n  11.4. Processing a MAP Response  . . . . . . . . . . . . . . . . 48\n  11.5. Address Change Events  . . . . . . . . . . . . . . . . . . 49\n  11.6. Learning the External IP Address Alone . . . . . . . . . . 50\n12. PEER Opcode  . . . . . . . . . . . . . . . . . . . . . . . . . 50\n  12.1. PEER Operation Packet Formats  . . . . . . . . . . . . . . 51\n  12.2. Generating a PEER Request  . . . . . . . . . . . . . . . . 54\n  12.3. Processing a PEER Request  . . . . . . . . . . . . . . . . 55\n  12.4. Processing a PEER Response . . . . . . . . . . . . . . . . 56",
      "raw": true
    },
    {
      "indent": 3,
      "text": "13. Options for MAP and PEER Opcodes . . . . . . . . . . . . . . . 57\n  13.1. THIRD_PARTY Option for MAP and PEER Opcodes  . . . . . . . 57\n  13.2. PREFER_FAILURE Option for MAP Opcode . . . . . . . . . . . 59\n  13.3. FILTER Option for MAP Opcode . . . . . . . . . . . . . . . 61\n14. Rapid Recovery . . . . . . . . . . . . . . . . . . . . . . . . 63\n  14.1. ANNOUNCE Opcode  . . . . . . . . . . . . . . . . . . . . . 64\n    14.1.1. ANNOUNCE Operation . . . . . . . . . . . . . . . . . . 65\n    14.1.2. Generating and Processing a Solicited ANNOUNCE\n            Message  . . . . . . . . . . . . . . . . . . . . . . . 65\n    14.1.3. Generating and Processing an Unsolicited ANNOUNCE\n            Message  . . . . . . . . . . . . . . . . . . . . . . . 66\n  14.2. PCP Mapping Update . . . . . . . . . . . . . . . . . . . . 67\n15. Mapping Lifetime and Deletion  . . . . . . . . . . . . . . . . 69\n  15.1. Lifetime Processing for the MAP Opcode . . . . . . . . . . 71\n16. Implementation Considerations  . . . . . . . . . . . . . . . . 72\n  16.1. Implementing MAP with EDM Port-Mapping NAT . . . . . . . . 72\n  16.2. Lifetime of Explicit and Implicit Dynamic Mappings . . . . 72\n  16.3. PCP Failure Recovery . . . . . . . . . . . . . . . . . . . 72\n    16.3.1. Recreating Mappings  . . . . . . . . . . . . . . . . . 73\n    16.3.2. Maintaining Mappings . . . . . . . . . . . . . . . . . 73\n    16.3.3. SCTP . . . . . . . . . . . . . . . . . . . . . . . . . 74\n  16.4. Source Address Replicated in PCP Header  . . . . . . . . . 75\n  16.5. State Diagram  . . . . . . . . . . . . . . . . . . . . . . 76\n17. Deployment Considerations  . . . . . . . . . . . . . . . . . . 77\n  17.1. Ingress Filtering  . . . . . . . . . . . . . . . . . . . . 77\n  17.2. Mapping Quota  . . . . . . . . . . . . . . . . . . . . . . 77\n18. Security Considerations  . . . . . . . . . . . . . . . . . . . 78\n  18.1. Simple Threat Model  . . . . . . . . . . . . . . . . . . . 78\n    18.1.1. Attacks Considered . . . . . . . . . . . . . . . . . . 79\n    18.1.2. Deployment Examples Supporting the Simple Threat\n            Model  . . . . . . . . . . . . . . . . . . . . . . . . 79\n  18.2. Advanced Threat Model  . . . . . . . . . . . . . . . . . . 80\n  18.3. Residual Threats . . . . . . . . . . . . . . . . . . . . . 80\n    18.3.1. Denial of Service  . . . . . . . . . . . . . . . . . . 80\n    18.3.2. Ingress Filtering  . . . . . . . . . . . . . . . . . . 81\n    18.3.3. Mapping Theft  . . . . . . . . . . . . . . . . . . . . 81\n    18.3.4. Attacks against Server Discovery . . . . . . . . . . . 81\n19. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 82\n  19.1. Port Number  . . . . . . . . . . . . . . . . . . . . . . . 82\n  19.2. Opcodes  . . . . . . . . . . . . . . . . . . . . . . . . . 82\n  19.3. Result Codes . . . . . . . . . . . . . . . . . . . . . . . 82\n  19.4. Options  . . . . . . . . . . . . . . . . . . . . . . . . . 82\n20. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 83\n21. References . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n  21.1. Normative References . . . . . . . . . . . . . . . . . . . 84\n  21.2. Informative References . . . . . . . . . . . . . . . . . . 84\nAppendix A. NAT-PMP Transition . . . . . . . . . . . . . . . . . . 87",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Port Control Protocol (PCP) provides a mechanism to control how incoming packets are forwarded by upstream devices such as Network Address Translator IPv6/IPv4 (NAT64), Network Address Translator IPv4/IPv4 (NAT44), and IPv6 and IPv4 firewall devices, and a mechanism to reduce application keepalive traffic. PCP is designed to be implemented in the context of Carrier-Grade NATs (CGNs) and small NATs (e.g., residential NATs), as well as with dual-stack and IPv6-only Customer Premises Equipment (CPE) routers, and all of the currently known transition scenarios towards IPv6-only CPE routers. PCP allows hosts to operate servers for a long time (e.g., a network-attached home security camera) or a short time (e.g., while playing a game or on a phone call) when behind a NAT device, including when behind a CGN operated by their Internet service provider or an IPv6 firewall integrated in their CPE router.",
      "ja": "ポート制御プロトコル（PCP）は、ネットワークアドレス変換のIPv6 / IPv4の（NAT64）、ネットワークアドレス変換のIPv4 / IPv4の（NAT44）、及びIPv6とIPv4ファイアウォールデバイスとして上流装置によって転送される方法着信パケットを制御するメカニズムを提供し、そしてアプリケーションキープアライブトラフィックを削減するためのメカニズム。 PCPは、キャリアグレードNATの（CGNを）と小型のNAT（例えば、住宅のNAT）の文脈でだけでなく、デュアルスタックとIPv6のみの顧客宅内機器（CPE）ルータで実装されるように設計されており、すべての現在、IPv6のみのCPEルータへの移行シナリオを知られています。 （ゲームをプレイしたり、電話にしながら、例えば）PCPはCGNの後ろに動作する場合を含め、ときNATデバイスの背後にホストが長い時間（例えば、ネットワークに接続されたホームセキュリティカメラ）や短時間のサーバーを操作することができます彼らのインターネットサービスプロバイダまたはそのCPEルータに統合されたIPv6ファイアウォールによって。"
    },
    {
      "indent": 3,
      "text": "PCP allows applications to create mappings from an external IP address, protocol, and port to an internal IP address, protocol, and port. These mappings are required for successful inbound communications destined to machines located behind a NAT or a firewall.",
      "ja": "PCPは、アプリケーションが内部IPアドレス、プロトコル、およびポートに外部IPアドレス、プロトコル、およびポートからのマッピングを作成することができます。これらのマッピングは、NATやファイアウォールの背後にあるマシン宛てに成功し、インバウンド通信に必要とされます。"
    },
    {
      "indent": 3,
      "text": "After creating a mapping for incoming connections, it is necessary to inform remote computers about the IP address, protocol, and port for the incoming connection. This is usually done in an application-specific manner. For example, a computer game might use a rendezvous server specific to that game (or specific to that game developer), a SIP phone would use a SIP proxy, and a client using DNS-Based Service Discovery [RFC6763] would use DNS Update [RFC2136] [RFC3007]. PCP does not provide this rendezvous function. The rendezvous function may support IPv4, IPv6, or both. Depending on that support and the application's support of IPv4 or IPv6, the PCP client may need an IPv4 mapping, an IPv6 mapping, or both.",
      "ja": "着信接続のためのマッピングを作成した後、着信接続用のIPアドレス、プロトコル、およびポートに関するリモートコンピュータに通知する必要があります。これは通常、アプリケーション固有の方法で行われます。例えば、コンピュータゲームは、ランデブー、そのゲームに特定のサーバ（またはそのゲーム開発者に固有）を使用する場合があり、SIP電話機は、SIPプロキシを使用して、DNSベースのサービスディスカバリー[RFC6763]を使用しているクライアントは、DNSアップデートを[使用しますRFC2136] [RFC3007]。 PCPはこのランデブー機能を提供していません。ランデブ機能は、IPv4、IPv6の、または両方をサポートすることができます。そのサポートとIPv4またはIPv6のアプリケーションのサポートに応じ、PCPクライアントは、IPv4マッピング、IPv6のマッピング、またはその両方が必要な場合があります。"
    },
    {
      "indent": 3,
      "text": "Many NAT-friendly applications send frequent application-level messages to ensure that their session will not be timed out by a NAT. These are commonly called \"NAT keepalive\" messages, even though they are not sent to the NAT itself (rather, they are sent 'through' the NAT). These applications can reduce the frequency of such NAT keepalive messages by using PCP to learn (and influence) the NAT mapping lifetime. This helps reduce bandwidth on the subscriber's access network, traffic to the server, and battery consumption on mobile devices.",
      "ja": "多くのNATに優しいアプリケーションは、セッションがNATによってタイムアウトされないことを保証するために、頻繁にアプリケーションレベルのメッセージを送信します。これらは、一般的にそれらは（むしろ、それらはNAT「を介して」送信されます）NAT自体に送信されていないにもかかわらず、「NATキープアライブ」メッセージと呼ばれています。これらのアプリケーションは、NATマッピングの寿命を学ぶためにPCPを使用して（と影響力）によって、このようなNATキープアライブメッセージの頻度を減らすことができます。これは、モバイルデバイス上で加入者のアクセスネットワーク上の帯域幅、サーバへのトラフィック、およびバッテリーの消費を減らすことができます。"
    },
    {
      "indent": 3,
      "text": "Many NATs and firewalls include Application Layer Gateways (ALGs) to create mappings for applications that establish additional streams or accept incoming connections. ALGs incorporated into NATs may also modify the application payload. Industry experience has shown that these ALGs are detrimental to protocol evolution. PCP allows an application to create its own mappings in NATs and firewalls, reducing the incentive to deploy ALGs in NATs and firewalls.",
      "ja": "多くのNATやファイアウォールは、追加のストリームを確立するアプリケーションのマッピングを作成したり、着信接続を受け入れるようにアプリケーションレイヤゲートウェイ（ALG）が含まれます。 NATの中に組み込むのALGは、アプリケーションのペイロードを修正してもよいです。業界での経験は、これらのALGは、プロトコルの進化に有害であることが示されています。 PCPは、NATのファイアウォールでのALGを展開するインセンティブを減らし、アプリケーションはNATのファイアウォールでは、独自のマッピングを作成することができます。"
    },
    {
      "indent": 0,
      "text": "2. Scope",
      "section_title": true,
      "ja": "2.適用範囲"
    },
    {
      "indent": 0,
      "text": "2.1. Deployment Scenarios",
      "section_title": true,
      "ja": "2.1. 導入シナリオ"
    },
    {
      "indent": 3,
      "text": "PCP can be used in various deployment scenarios, including:",
      "ja": "PCPは、さまざまな展開シナリオ、などの中で使用することができます。"
    },
    {
      "indent": 3,
      "text": "o Basic NAT [RFC3022]",
      "ja": "O基本NAT [RFC3022]"
    },
    {
      "indent": 3,
      "text": "o Network Address and Port Translation [RFC3022], such as commonly deployed in residential NAT devices",
      "ja": "一般住宅のNATデバイスに配備などのOネットワークアドレスとポート変換[RFC3022]、"
    },
    {
      "indent": 3,
      "text": "o Carrier-Grade NAT [RFC6888]",
      "ja": "OキャリアグレードNAT [RFC6888]"
    },
    {
      "indent": 3,
      "text": "o Dual-Stack Lite (DS-Lite) [RFC6333]",
      "ja": "Oデュアルスタックライト（DS-Liteの）[RFC6333]"
    },
    {
      "indent": 3,
      "text": "o NAT that is Layer-2 Aware [L2NAT]",
      "ja": "NAT Oであるレイヤ2対応の[L2NAT]"
    },
    {
      "indent": 3,
      "text": "o Dual-Stack Extra Lite [RFC6619]",
      "ja": "Oデュアルスタックエクストラライト[RFC6619]"
    },
    {
      "indent": 3,
      "text": "o NAT64, both Stateless [RFC6145] and Stateful [RFC6146]",
      "ja": "O NAT64、ステートレス[RFC6145]の両方とステートフル[RFC6146]"
    },
    {
      "indent": 3,
      "text": "o IPv4 and IPv6 simple firewall control [RFC6092]",
      "ja": "O IPv4とIPv6の簡単なファイアウォール制御[RFC6092]"
    },
    {
      "indent": 3,
      "text": "o IPv6-to-IPv6 Network Prefix Translation (NPTv6) [RFC6296]",
      "ja": "OのIPv6対IPv6ネットワークプレフィックス変換（NPTv6）[RFC6296]"
    },
    {
      "indent": 0,
      "text": "2.2. Supported Protocols",
      "section_title": true,
      "ja": "2.2. サポートされるプロトコル"
    },
    {
      "indent": 3,
      "text": "The PCP Opcodes defined in this document are designed to support transport-layer protocols that use a 16-bit port number (e.g., TCP, UDP, Stream Control Transmission Protocol (SCTP) [RFC4960], and Datagram Congestion Control Protocol (DCCP) [RFC4340]). Protocols that do not use a port number (e.g., Resource Reservation Protocol (RSVP), IP Encapsulating Security Payload (ESP) [RFC4303], ICMP, and ICMPv6) are supported for IPv4 firewall, IPv6 firewall, and NPTv6 functions, but are out of scope for any NAT functions.",
      "ja": "この文書で定義されたPCPのオペコードは16ビットのポート番号を使用するトランスポート層プロトコルをサポートするように設計されている（例えば、TCP、UDP、ストリーム制御伝送プロトコル（SCTP）[RFC4960]、及びデータグラム輻輳制御プロトコル（DCCP）[ RFC4340]）。ポート番号を使用していないプロトコル（例えば、リソース予約プロトコル（RSVP）、IPカプセル化セキュリティペイロード（ESP）[RFC4303]、ICMP、およびICMPv6のは）IPv4のファイアウォール、IPv6ファイアウォール、およびNPTv6機能でサポートされていますが、出ているされていますすべてのNAT機能のスコープの。"
    },
    {
      "indent": 0,
      "text": "2.3. Single-Homed Customer Premises Network",
      "section_title": true,
      "ja": "2.3. シングルホーム加入者宅内ネットワーク"
    },
    {
      "indent": 3,
      "text": "PCP assumes a single-homed IP address model. That is, for a given IP address of a host, only one default route exists to reach other hosts on the Internet from that source IP address. This is important because after a PCP mapping is created and an inbound packet (e.g., TCP SYN) is rewritten and delivered to a host, the outbound response (e.g., TCP SYNACK) has to go through the same (reverse) path so it passes through the same NAT to have the necessary inverse rewrite performed. This restriction exists because otherwise there would need to be a PCP-enabled NAT for every egress (because the host could not reliably determine which egress path packets would take), and the client would need to be able to reliably make the same internal/ external mapping in every NAT gateway, which in general is not possible (because the other NATs might already have the necessary external port mapped to another host).",
      "ja": "PCPは、シングルホームIPアドレスモデルを想定しています。これは、ホストの特定のIPアドレスのために、唯一のデフォルトルートは、送信元IPアドレスからインターネット上の他のホストに到達するために存在する、です。 PCPのマッピングが作成され、インバウンドパケット（例えば、TCP SYN）をホストに書き換えて配信された後、アウトバウンド応答（例えば、TCP SYNACK）は、それが通過するので、同じ（リバース）経路を通って行かなければならないので、これは重要です同じNATを通じて必要な逆書き換えを行っています。そうでない場合（ホストが確実にパスパケットがかかるだろうどの出口を判断できなかったため）、すべての出力のためのPCP-有効にNATがあることが必要となるため、この制限が存在し、クライアントが確実に同じ内部/外部を作ることができるようにする必要があります（他のNATが既に必要な外部ポートは、別のホストにマッピングした可能性があるため）、一般的には不可能であるすべてのNATゲートウェイにマッピング。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3.用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in \"Key words for use in RFCs to Indicate Requirement Levels\" [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL要求レベルを示すためのRFCsにおける使用のためのキーワード 『[RFC2119]」に記載されているように、この文書で解釈されるべきです』。"
    },
    {
      "indent": 3,
      "text": "Internal Host: A host served by a NAT gateway, or protected by a firewall. This is the host that will receive incoming traffic resulting from a PCP mapping request, or the host that initiated an implicit dynamic outbound mapping (e.g., by sending a TCP SYN) across a firewall or a NAT.",
      "ja": "内部ホスト：ホストはNATゲートウェイによって提供される、またはファイアウォールによって保護されています。これは、受信PCPマッピング要求から生じるトラフィック、またはファイアウォールまたはNATを横切って（例えば、TCP SYNを送信することによって）暗黙的な動的アウトバウンド・マッピングを開始したホストを受信するホストです。"
    },
    {
      "indent": 3,
      "text": "Remote Peer Host: A host with which an internal host is communicating. This can include another internal host (or even the same internal host); if a NAT is involved, the NAT would need to hairpin the traffic [RFC4787].",
      "ja": "リモートピアのホスト：内部ホストが通信しているホスト。これは、別の内部ホスト（または同じ内部ホスト）を含むことができます。 NATが関与している場合、NATはトラフィック[RFC4787]をヘアピンする必要があります。"
    },
    {
      "indent": 3,
      "text": "Internal Address: The address of an internal host served by a NAT gateway or protected by a firewall.",
      "ja": "内部アドレス：NATゲートウェイによって提供されるか、ファイアウォールで保護された内部ホストのアドレス。"
    },
    {
      "indent": 3,
      "text": "External Address: The address of an internal host as seen by other remote peers on the Internet with which the internal host is communicating, after translation by any NAT gateways on the path. An external address is generally a public routable (i.e., non-private) address. In the case of an internal host protected by a pure firewall, with no address translation on the path, its external address is the same as its internal address.",
      "ja": "外部アドレス：内部ホストは、パス上の任意のNATゲートウェイによって翻訳した後、通信しているインターネット上の他のリモートピアによって見られるように内部ホストのアドレス。外部アドレスは、一般に、パブリックにルーティング可能な（すなわち、非プライベート）アドレスです。純粋なファイアウォールで保護された内部ホストの場合には、経路上にないアドレス変換と、その外部アドレスは、内部アドレスと同じです。"
    },
    {
      "indent": 3,
      "text": "Endpoint-Dependent Mapping (EDM): A term applied to NAT operation where an implicit mapping created by outgoing traffic (e.g., TCP SYN) from a single internal address, protocol, and port to different remote peers and ports may be assigned different external ports, and a subsequent PCP mapping request for that internal address, protocol, and port may be assigned yet another different external port. This term encompasses both Address-Dependent Mapping and Address and Port-Dependent Mapping [RFC4787].",
      "ja": "エンドポイント依存マッピング（EDM）：単一の内部アドレス、プロトコル、および異なるリモートピアとポートへのポートからの発信トラフィックによって作成された暗黙的なマッピング（例えば、TCP SYN）が異なる外部ポートを割り当てることができるNAT動作に適用される用語、その内部アドレス、プロトコル、およびポートの後続のPCPマッピング要求は、さらに別の異なる外部ポートを割り当てることができます。この用語は、両方のアドレス依存マッピングアドレスとポート依存マッピング[RFC4787]を包含する。"
    },
    {
      "indent": 3,
      "text": "Endpoint-Independent Mapping (EIM): A term applied to NAT operation where all mappings from a single internal address, protocol, and port to different remote peers and ports are all assigned the same external address and port.",
      "ja": "エンドポイント非依存マッピング（EIM）：異なるリモートピアとポートへの単一の内部アドレス、プロトコル、およびポートからのすべてのマッピングがすべて同じ外部アドレス・ポートが割り当てられているNAT動作に適用される用語。"
    },
    {
      "indent": 3,
      "text": "Remote Peer Address: The address of a remote peer, as seen by the internal host. A remote address is generally a publicly routable address. In the case of a remote peer that is itself served by a NAT gateway, the remote address may in fact be the remote peer's external address, but since this remote translation is generally invisible to software running on the internal host, the distinction can safely be ignored for the purposes of this document.",
      "ja": "リモートピアアドレス：リモートピアのアドレス、内部ホストから見ました。リモートアドレスは、一般的にパブリックにルーティング可能なアドレスです。自身がNATゲートウェイによって提供されるリモートピアの場合は、リモートアドレスは、実際には、リモートピアの外部アドレスとすることができるが、このリモート翻訳は内部ホスト上で実行されているソフトウェアに一般的に見えないことから、区別が安全にすることができこのドキュメントの目的のために無視されます。"
    },
    {
      "indent": 3,
      "text": "Third Party: In the common case, an internal host manages its own mappings using PCP requests, and the internal address of those mappings is the same as the source IP address of the PCP request packet.",
      "ja": "第三者は：一般的なケースでは、内部ホストは、PCPの要求を使用して、独自のマッピングを管理し、それらのマッピングの内部アドレスは、PCP要求パケットの送信元IPアドレスと同じです。"
    },
    {
      "indent": 6,
      "text": "In the case where one device is managing mappings on behalf of some other device that does not implement PCP, the presence of the THIRD_PARTY option in the MAP request signifies that the specified address, rather than the source IP address of the PCP request packet, should be used as the internal address for the mapping.",
      "ja": "1つのデバイスがPCPを実装していないいくつかの他のデバイスに代わって管理マッピングがある場合には、MAP要求でTHIRD_PARTYオプションの存在は意味その指定されたアドレスではなく、PCP要求パケットの送信元IPアドレス、すべきマッピングのための内部アドレスとして使用されます。"
    },
    {
      "indent": 3,
      "text": "Mapping, Port Mapping, Port Forwarding: A NAT mapping creates a relationship between an internal IP address, protocol, and port, and an external IP address, protocol, and port. More specifically, it creates a translation rule where packets destined *to* the external IP address, protocol, and port have their destination address and port translated to the internal address and port, and conversely, packets *from* the internal IP address, protocol, and port have their source address and port translated to the external address and port. In the case of a pure firewall, the \"mapping\" is the identity function, translating an internal IP address, protocol, and port number to the same external IP address, protocol, and port number. Firewall filtering, applied in addition to that identity mapping function, is separate from the mapping itself.",
      "ja": "マッピングは、ポートマッピング、ポートフォワーディング：NATマッピングは、内部IPアドレス、プロトコル、ポート、および外部IPアドレス、プロトコル、およびポートとの間の関係を作成します。具体的には、宛先とするパケットは、* *外部IPアドレス、プロトコル、およびポート彼らの宛先アドレスとポートは、内部アドレスとポートに変換しているための変換規則を作成し、逆に、パケット* *から内部IPアドレス、プロトコル、およびポートは、その送信元アドレスとポートが外部アドレスとポートに変換できます。純粋なファイアウォールの場合には、「マッピング」は、同一の外部IPアドレス、プロトコル、およびポート番号に内部IPアドレス、プロトコル、およびポート番号を変換、恒等関数です。そのIDマッピング機能に加えて適用されるファイアウォールフィルタリングは、マッピング自体から分離されています。"
    },
    {
      "indent": 3,
      "text": "Mapping Types: There are three dimensions to classifying mapping types: how they are created (implicitly/explicitly), their primary purpose (outbound/inbound), and how they are deleted (dynamic/static). Implicit mappings are created as a side effect of some other operation; explicit mappings are created by a mechanism explicitly dealing with mappings. Outbound mappings exist primarily to facilitate outbound communication; inbound mappings exist primarily to facilitate inbound communication. Dynamic mappings are deleted when their lifetime expires, or through other protocol action; static mappings are permanent until the user chooses to delete them.",
      "ja": "マッピングのタイプ：それらが作成されている方法（暗黙的/明示）、その主な目的（アウトバウンド/インバウンド）、およびそれらがどのように削除されます（動的/静的）：3つのマッピングの種類を分類する寸法があります。暗黙のマッピングは、他のいくつかの操作の副作用として作成されます。明示的なマッピングは、明示的なマッピングを扱うメカニズムによって作成されます。アウトバウンドマッピングは、アウトバウンド通信を容易にするために主に存在します。インバウンドマッピングは、インバウンド通信を容易にするために主に存在します。彼らの寿命が満了し、または他のプロトコルの作用を介したときに、動的マッピングは削除されます。ユーザーがそれらを削除することを選択するまで、静的マッピングは永続的です。"
    },
    {
      "indent": 6,
      "text": "* Implicit dynamic mappings are created implicitly as a side effect of traffic such as an outgoing TCP SYN or outgoing UDP packet. Such packets were not originally designed explicitly for creating NAT (or firewall) state, but they can have that effect when they pass through a NAT (or firewall) device. Implicit dynamic mappings usually have a finite lifetime, though this lifetime is generally not known to the client using them.",
      "ja": "*暗黙の動的なマッピングは、このような発信TCP SYNまたは発信UDPパケットとしてトラフィックの副作用として暗黙的に作成されます。このようなパケットは、もともと、明示的にNAT（またはファイアウォール）の状態を作成するために設計されていないが、彼らはNAT（またはファイアウォール）デバイスを通過するとき、彼らはその効果を持つことができます。この寿命は一般的にそれらを使用して、クライアントに知られていないが、暗黙の動的なマッピングは、通常、有限の寿命を持っています。"
    },
    {
      "indent": 6,
      "text": "* Explicit dynamic mappings are created as a result of explicit PCP MAP and PEER requests. Like a DHCP address lease, explicit dynamic mappings have a finite lifetime, and this lifetime is communicated to the client. As with a DHCP address lease, if the client wants a mapping to persist the client must prove that it is still present by periodically renewing the mapping to prevent it from expiring. If a PCP client goes away, then any mappings it created will be automatically cleaned up when they expire.",
      "ja": "*明示的な動的なマッピングは、明示的なPCPのMAPとPEERリクエストの結果として作成されます。 DHCPアドレスのリースのように、明示的な動的なマッピングは、有限の寿命を有しており、この寿命がクライアントに通知されます。クライアントが持続するマッピングを望んでいる場合は、DHCPアドレスのリースと同じように、クライアントは、それはまだ定期的に有効期限が切れてからそれを防ぐためのマッピングを更新することによって存在することを証明しなければなりません。 PCPクライアントが消える場合は期限が切れるとき、それが作成した任意のマッピングは自動的にクリーンアップされます。"
    },
    {
      "indent": 6,
      "text": "* Explicit static mappings are created by manual configuration (e.g., via command-line interface or other user interface) and persist until the user changes that manual configuration.",
      "ja": "*明示的な静的マッピングは、（コマンドラインインターフェイスまたは他のユーザインタフェースを介して、例えば）手動設定によって作成され、ユーザが手動で設定することを変更するまで持続されます。"
    },
    {
      "indent": 6,
      "text": "Both implicit and explicit dynamic mappings are dynamic in the sense that they are created on demand, as requested (implicitly or explicitly) by the internal host, and have a lifetime. After the lifetime, the mapping is deleted unless the lifetime is extended by action by the internal host (e.g., sending more traffic or sending another PCP request).",
      "ja": "どちらも暗黙的および明示的な動的なマッピングは、内部ホストによって（暗黙的または明示的に）要求されたとして、彼らはオンデマンドで作成されているという意味で動的であり、かつ寿命を持っています。寿命は、内部ホスト（例えば、より多くのトラフィックを送信または別のPCP要求を送信する）ことによって作用することによって拡張されていない限り寿命後、マッピングが削除されます。"
    },
    {
      "indent": 6,
      "text": "Static mappings are, by their nature, always explicit. Static mappings differ from explicit dynamic mappings in that their lifetime is effectively infinite (they exist until manually removed), but otherwise they behave exactly the same as explicit MAP mappings.",
      "ja": "静的マッピングは常に、その性質上、明示されています。静的マッピングは、（手動で削除されるまで、彼らが存在する）、それらの寿命を効果的に無限であることを明示的に動的なマッピングから異なるが、それ以外の場合は、明示的なMAPマッピングとまったく同じように動作します。"
    },
    {
      "indent": 6,
      "text": "While all mappings are, by necessity, bidirectional (most Internet communication requires information to flow in both directions for successful operation), when talking about mappings, it can be helpful to identify them loosely according to their 'primary' purpose.",
      "ja": "すべてのマッピングであるが、必然的に、双方向（ほとんどのインターネット通信が正常に動作させるために両方の方向に流れるように情報を必要とする）のマッピングについて話すとき、緩く彼らの「主」目的に応じてそれらを識別するのに役立ちます。"
    },
    {
      "indent": 6,
      "text": "* Outbound mappings exist primarily to enable outbound communication. For example, when a host calls connect() to make an outbound connection, a NAT gateway will create an implicit dynamic outbound mapping to facilitate that outbound communication.",
      "ja": "*アウトバウンドマッピングは、アウトバウンド通信を可能にするために主に存在します。ホストコールが接続したとき、例えば、（）アウトバウンド接続を確立するために、暗黙的な動的アウトバウンド・マッピングを作成するNATゲートウェイは、アウトバウンド通信を容易にします。"
    },
    {
      "indent": 6,
      "text": "* Inbound mappings exist primarily to enable listening servers to receive inbound connections. Generally, when a client calls listen() to listen for inbound connections, a NAT gateway will not implicitly create any mapping to facilitate that inbound communication. A PCP MAP request can be used explicitly to create a dynamic inbound mapping to enable the desired inbound communication.",
      "ja": "*インバウンドマッピングは、インバウンド接続を受信するリスニング・サーバを有効にするために主に存在します。一般的に、ときに、クライアント・コールが着信接続をリッスンする）（聞く、NATゲートウェイは、暗黙のうちにそのインバウンド通信を容易にするための任意のマッピングを作成しません。 PCPマップ要求は、所望のインバウンド通信を可能にするために動的インバウンドマッピングを作成するために、明示的に使用することができます。"
    },
    {
      "indent": 6,
      "text": "Explicit static (manual) mappings and explicit dynamic (MAP) mappings both allow internal hosts to receive inbound traffic that is not in direct response to any immediately preceding outbound communication (i.e., to allow internal hosts to operate a \"server\" that is accessible to other hosts on the Internet).",
      "ja": "明示的な静的（手動）マッピングと明示的な動的（MAP）マッピング内部ホストが内部ホストがにアクセス可能な「サーバ」を動作させるために、任意の直前のアウトバウンド通信（すなわち、に直接対応していない着信トラフィックを受信することができ、両方のインターネット上の他のホスト）。"
    },
    {
      "indent": 3,
      "text": "PCP Client: A PCP software instance responsible for issuing PCP requests to a PCP server. Several independent PCP clients can exist on the same host. Several PCP clients can be located in the same local network. A PCP client can issue PCP requests on behalf of a third-party device for which it is authorized to do so. An interworking function from Universal Plug and Play Internet Gateway Device (UPnP IGDv1 [IGDv1]) to PCP is another example of a PCP client. A PCP server in a NAT gateway that is itself a client of another NAT gateway (nested NAT) may itself act as a PCP client to the upstream NAT.",
      "ja": "PCPクライアント：PCPサーバにPCP要求を発行する責任PCPソフトウェアインスタンス。いくつかの独立したPCPクライアントが同じホスト上に存在することができます。いくつかのPCPクライアントは、同じローカルネットワーク内に配置することができます。 PCPクライアントは、そうすることを認可されているサードパーティのデバイスの代わりにPCP要求を発行することができます。ユニバーサルプラグからのインターワーキング機能とPCPにインターネットゲートウェイデバイス（UPnPのIGDv1 [IGDv1]）を再生PCPクライアントの別の例です。別のNATゲートウェイ（ネストされたNAT）のクライアント自体が上流のNATにPCPクライアントとして働くことができる、それ自体でNATゲートウェイにおけるPCPサーバ。"
    },
    {
      "indent": 3,
      "text": "PCP-Controlled Device: A NAT or firewall that controls or rewrites packet flows between internal hosts and remote peer hosts. PCP manages the mappings on this device.",
      "ja": "PCP制御デバイス：内部ホストとリモートピアホスト間のパケットフローを制御または書き換えNATまたはファイアウォール。 PCPは、このデバイスのマッピングを管理します。"
    },
    {
      "indent": 3,
      "text": "PCP Server: A PCP software instance that resides on the PCP-Controlled Device that receives PCP requests from the PCP client and creates appropriate state in response to that request.",
      "ja": "PCPサーバ：PCPクライアントからPCP要求を受信し、その要求に応じて、適切な状態を作成し、PCP-制御されるデバイス上に存在するPCPのソフトウェアインスタンス。"
    },
    {
      "indent": 3,
      "text": "Subscriber: The unit of billing for a commercial ISP. A subscriber may have a single IP address from the commercial ISP (which can be shared among multiple hosts using a NAT gateway, thereby making them appear to be a single host to the ISP) or may have multiple IP addresses provided by the commercial ISP. In either case, the IP address or addresses provided by the ISP may themselves be further translated by a Carrier-Grade NAT (CGN) operated by the ISP.",
      "ja": "加入者：商用ISPの課金の単位。加入者が（それによってそれらがISPに単一のホストであるように見える作り、NATゲートウェイを使用して、複数のホスト間で共有することができる）は、市販のISPから単一のIPアドレスを有していてもよく、または商業的ISPによって提供される複数のIPアドレスを有していてもよいです。いずれの場合においても、ISPによって提供されるIPアドレスまたはアドレス自体は、さらにISPによって操作キャリアグレードNAT（CGN）によって変換されてもよいです。"
    },
    {
      "indent": 0,
      "text": "4. Relationship between PCP Server and Its PCP-Controlled Device",
      "section_title": true,
      "ja": "PCPサーバとそのPCP-制御されるデバイス間の4の関係"
    },
    {
      "indent": 3,
      "text": "The PCP server receives and responds to PCP requests. The PCP server functionality is typically a capability of a NAT or firewall device, as shown in Figure 1. It is also possible for the PCP functionality to be provided by some other device, which communicates with the actual NAT(s) or firewall(s) via some other proprietary mechanism, as long as from the PCP client's perspective such split operation is indistinguishable from the integrated case.",
      "ja": "PCPサーバが受信して、PCP要求に応答します。 PCPの機能は、実際のNAT（S）またはファイアウォール（Sと通信いくつかの他のデバイスによって提供されてすることも可能である。図1に示すようPCPサーバ機能は、典型的には、NATまたはファイアウォールデバイスの能力であります）いくつかの他の独自の機構を介して、限りPCPクライアントの視点など、分割操作から統合された場合と区別がつきません。"
    },
    {
      "indent": 9,
      "text": "                         +-----------------+\n+------------+           | NAT or firewall |\n| PCP client |-<network>-+      with       +---<Internet>\n+------------+           |    PCP server   |\n                         +-----------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 1: PCP-Enabled NAT or Firewall",
      "ja": "図1：PCP-有効NATやファイアウォール"
    },
    {
      "indent": 3,
      "text": "A NAT or firewall device, between the PCP client and the Internet, might implement simple or advanced firewall functionality. This may be a side effect of the technology implemented by the device (e.g., a network address and port translator, by virtue of its port rewriting, normally requires connections to be initiated from an inside host towards the Internet), or this might be an explicit firewall policy to deny unsolicited traffic from the Internet. Some firewall devices deny certain unsolicited traffic from the Internet (e.g., TCP, UDP to most ports) but allow certain other unsolicited traffic from the Internet (e.g., UDP port 500 and IP ESP) [RFC6092]. Such default filtering (or lack thereof) is out of scope of PCP itself. If a client device wants to receive traffic and supports PCP, and does not possess prior knowledge of such default filtering policy, it SHOULD use PCP to request the necessary mappings to receive the desired traffic.",
      "ja": "NATやファイアウォールデバイスは、PCPのクライアントとインターネットの間に、単純または高度なファイアウォール機能を実装することがあります。これは、デバイスによって実装技術の副作用であってもよい（例えば、ネットワークアドレスとポートトランスレータは、書き換えそのポートのおかげで、通常はインターネットへの内部ホストから開始される接続が必要）、またはこれがあるかもしれません明示的なファイアウォールポリシーは、インターネットからの迷惑トラフィックを拒否します。一部のファイアウォールデバイスは、インターネット（例えば、TCP、ほとんどのポートにUDP）から一定の迷惑トラフィックを拒否が、インターネット（例えば、UDPポート500およびIP ESP）[RFC6092]から特定の他の未承諾のトラフィックを許可します。このようなデフォルトのフィルタリング（またはその欠如）は、PCP自体の範囲外です。クライアントデバイスがトラフィックを受信したいとPCPをサポートし、かつ、そのようなデフォルトのフィルタリングポリシーの事前知識を持っていない場合は、それが必要なトラフィックを受信するために必要なマッピングを要求するためにPCPを使用すべきです。"
    },
    {
      "indent": 0,
      "text": "5. Note on Fixed-Size Addresses",
      "section_title": true,
      "ja": "固定サイズのアドレス5.注意事項"
    },
    {
      "indent": 3,
      "text": "For simplicity in building and parsing request and response packets, PCP always uses fixed-size 128-bit IP address fields for both IPv6 addresses and IPv4 addresses.",
      "ja": "建物の中にシンプルさと、要求と応答パケットを解析するために、PCPは、常にIPv6アドレスとIPv4アドレスの両方のための固定サイズ128ビットのIPアドレスフィールドを使用しています。"
    },
    {
      "indent": 3,
      "text": "When the address field holds an IPv6 address, the fixed-size 128-bit IP address field holds the IPv6 address stored as is.",
      "ja": "アドレスフィールドは、IPv6アドレスを保持している場合、固定サイズの128ビットのIPアドレスのフィールドであるとして格納されたIPv6アドレスを保持します。"
    },
    {
      "indent": 3,
      "text": "When the address field holds an IPv4 address, an IPv4-mapped IPv6 address [RFC4291] is used (::ffff:0:0/96). This has the first 80 bits set to zero and the next 16 set to one, while its last 32 bits are filled with the IPv4 address. This is unambiguously distinguishable from a native IPv6 address, because an IPv4-mapped IPv6 address [RFC4291] would not be valid for a mapping.",
      "ja": "アドレスフィールドは、IPv4アドレスを保持している場合、IPv4射影IPv6アドレス[RFC4291]は使用されている（:: FFFF：0：0/96）。その最後の32ビットがIPv4アドレスで満たされているが、これは、一つにはゼロに設定された第1の80ビットと次の16のセットを有します。 IPv4マップIPv6アドレス[RFC4291]は、マッピングのために有効ではないので、これは、ネイティブIPv6アドレスから明確に区別されます。"
    },
    {
      "indent": 3,
      "text": "When checking for an IPv4-mapped IPv6 address, all of the first 96 bits MUST be checked for the pattern -- it is not sufficient to check for ones in bits 81-96.",
      "ja": "IPv4マップIPv6アドレスをチェックするとき、最初の96ビットの全ては、パターンをチェックしなければならない - ビット81-96におけるものをチェックするために十分ではありません。"
    },
    {
      "indent": 3,
      "text": "The all-zeros IPv6 address MUST be expressed by filling the fixed-size 128-bit IP address field with all zeros (::).",
      "ja": ":)：すべてゼロIPv6アドレスはすべてゼロ（と固定サイズの128ビットのIPアドレスフィールドを埋めることによって表現されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The all-zeros IPv4 address MUST be expressed by 80 bits of zeros, 16 bits of ones, and 32 bits of zeros (::ffff:0:0).",
      "ja": "すべてゼロのIPv4アドレスがゼロの80ビットのものの16ビットと0の32ビットで表現されなければならない（:: FFFF：0：0）。"
    },
    {
      "indent": 0,
      "text": "6. Protocol Design Note",
      "section_title": true,
      "ja": "6.プロトコルデザインノート"
    },
    {
      "indent": 3,
      "text": "PCP can be viewed as a request/response protocol, much like many other UDP-based request/response protocols, and can be implemented perfectly well as such. It can also be viewed as what might be called a hint/notification protocol, and this observation can help simplify implementations.",
      "ja": "PCPは、多くの他の多くのUDPベースの要求/応答プロトコルのように、要求/応答プロトコルとみなすことができ、そのように完璧に実装することができます。またヒント/通知プロトコルと呼ばれるかもしれないものとみなすことができ、そしてこの観察は、実装を簡素化することができます。"
    },
    {
      "indent": 3,
      "text": "Rather than viewing the message streams between PCP client and PCP server as following a strict request/response pattern, where every response is associated with exactly one request, the message flows can be viewed as two somewhat independent streams carrying information in opposite directions:",
      "ja": "すべての応答は、正確に一つの要求に関連付けられている厳密な要求/応答パターンを、次のようなメッセージを表示するPCPクライアントとPCPサーバとの間のストリームではなく、メッセージは逆方向に情報を搬送する2つの幾分独立したストリームとして見ることができるフロー："
    },
    {
      "indent": 3,
      "text": "o A stream of hints flowing from PCP client to PCP server, where the client indicates to the server what it would like the state of its mappings to be, and",
      "ja": "クライアントは、それがために、そのマッピングの状態をご希望のものをサーバーに示しPCPサーバにPCPクライアントから流れるヒントの流れO、および"
    },
    {
      "indent": 3,
      "text": "o A stream of notifications flowing from PCP server to PCP client, where the server informs the clients what the state of its mappings actually is.",
      "ja": "O PCPサーバからサーバはそのマッピングの状態が実際にどのようなクライアントに通知PCPクライアントに流れるの通知の流れ。"
    },
    {
      "indent": 3,
      "text": "To an extent, some of this approach is required anyway in a UDP-based request/response protocol, since UDP packets can be lost, duplicated, or reordered.",
      "ja": "UDPパケットは、失われた複製、または並べ替えることができるので程度に、このアプローチのいくつかは、UDPベースの要求/応答プロトコルでとにかく必要とされます。"
    },
    {
      "indent": 3,
      "text": "In this view of the protocol, the client transmits hints to the server at various intervals signaling its desires, and the server transmits notifications to the client signaling the actual state of its mappings. These two message flows are loosely correlated in that a client request (hint) usually elicits a server response (notification), but only loosely, in that a client request may result in no server response (in the case of packet loss), and a server response may be generated gratuitously without an immediately preceding client request (in the case where server configuration change, e.g., change of external IP address on a NAT gateway, results in a change of mapping state).",
      "ja": "プロトコルのこのビューで、クライアントは、その欲望シグナリング様々な間隔でサーバにヒントを送信し、サーバは、そのマッピングの実際の状態を知らせるクライアントに通知を送信します。これら2つのメッセージ・フローは緩くクライアント要求（ヒント）は、通常、サーバ応答（通知）を誘発することに相関しているが、唯一の緩く、そのクライアントの要求は、（パケット損失の場合）ないサーバ応答をもたらすことができる、及びサーバ応答が直前のクライアントの要求なしに無償で生成されてもよい（例えば、サーバの構成変更の場合にNATゲートウェイの外部IPアドレスの変更を、マッピング状態の変化をもたらします）。"
    },
    {
      "indent": 3,
      "text": "The exact times that client requests are sent are influenced by a client timing state machine taking into account whether (i) the client has not yet received a response from the server for a prior request (retransmission), or (ii) the client has previously received a response from the server saying how long the indicated mapping would remain active (renewal). This design philosophy is the reason why PCP's retransmissions and renewals are exactly the same packet on the wire. Typically, retransmissions are sent with exponentially increasing intervals as the client waits for the server to respond, whereas renewals are sent with exponentially decreasing intervals as the expiry time approaches, but, from the server's point of view, both packets are identical, and both signal the client's desire that the stated mapping exist or continue to exist.",
      "ja": "クライアントの要求が送られていることを正確な時間は、（i）は、クライアントがまだ前の要求（再送）のために、サーバからの応答を受信して​​いないかどうかを考慮して、ステートマシンのタイミングクライアントの影響を受け、又は、（ii）クライアントは、以前持っています示されたマッピングがアクティブ（リニューアル）残るどのくらい言って、サーバからの応答を受信しました。この設計思想は、PCPの再送信と更新が正確にワイヤ上の同じパケットいる理由です。典型的には、再送信は、クライアントがビューのサーバーの観点から、サーバが応答するための更新は有効期限が近づくとして指数関数的に減少する間隔で送信され、一方、待機、しかしように指数関数的に増加する間隔で送信され、両方のパケットが同一であり、両方の信号述べたマッピングが存在するか、存在し続け、クライアントの要望。"
    },
    {
      "indent": 3,
      "text": "A PCP server usually sends responses as a direct result of client requests, but not always. For example, if a server is too overloaded to respond, it is allowed to silently ignore a request message and let the client retransmit. Also, if external factors cause a NAT gateway or firewall's configuration to change, then the PCP server can send unsolicited responses to clients informing them of the new state of their mappings. Such reconfigurations are expected to be rare, because of the disruption they can cause to clients, but should they happen, PCP provides a way for servers to communicate the new state to clients promptly, without having to wait for the next periodic renewal request.",
      "ja": "PCPサーバは通常、常にではないが、クライアント要求の直接の結果としての応答を送信します。サーバーがあまりにも対応するためにオーバーロードされている場合、静かに要求メッセージを無視し、クライアントの再送信を聞かせすることが許可されています。外部要因が変化するNATゲートウェイまたはファイアウォールの設定を引き起こす場合も、その後、PCPサーバは、そのマッピングの新しい状態を知らせる顧客に迷惑応答を送信することができます。このような再構成があるため、彼らはクライアントに発生する可能性がありますが、彼らは起こるべき、PCPは、サーバは次の定期的な更新要求を待つことなく、速やかにクライアントに新しい状態を通信するための方法を提供して混乱のため、稀であると予想されます。"
    },
    {
      "indent": 3,
      "text": "This design goal helps explain why PCP request and response messages have no transaction ID, because such a transaction ID is unnecessary, and would unnecessarily limit the protocol and unnecessarily complicate implementations. A PCP server response (i.e., notification) is self-describing and complete. It communicates the internal and external addresses, protocol, and ports for a mapping, and its remaining lifetime. If the client does in fact currently want such a mapping to exist, then it can identify the mapping in question from the internal address, protocol, and port, and update its state to reflect the current external address and port, and remaining lifetime. If a client does not currently want such a mapping to exist, then it can safely ignore the message. No client action is required for unexpected mapping notifications. In today's world, a NAT gateway can have a static mapping, and the client device has no explicit knowledge of this, and no way to change the fact. Also, in today's world, a client device can be connected directly to the public Internet, with a globally routable IP address, and, in this case, it effectively has \"mappings\" for all of its listening ports. Such a device has to be responsible for its own security and cannot rely on assuming that some other network device will be blocking all incoming packets.",
      "ja": "この設計目標は、このようなトランザクションIDは不要であり、不必要にプロトコルを制限し、不必要な実装が複雑になるため、PCP要求および応答メッセージは、何のトランザクションIDを持っていない理由を説明するのに役立ちます。 PCPサーバ応答（すなわち、通知）が自己記述かつ完全です。これは、マッピング、およびその残りの寿命のための内部および外部のアドレス、プロトコル、およびポートを通信します。クライアントは、実際には現在、このようなマッピングが存在したいならば、それは内部アドレス、プロトコル、およびポートから問題のマッピングを特定し、現在の外部アドレスとポート、および残りの寿命を反映するために、その状態を更新することができます。クライアントは現在、このようなマッピングが存在することを望まない場合は、それは安全にメッセージを無視することができます。いいえ、クライアントの動作が予期しないマッピングの通知のために必要とされません。今日の世界では、NATゲートウェイは、静的マッピングを持つことができ、クライアントデバイスは、このの明示的な知識、および事実を変更する方法はありません。また、今日の世界では、クライアントデバイスは、グローバルにルーティング可能なIPアドレスを使用して、公共のインターネットに直接接続することができ、かつ、この場合には、それが効果的にリスニングポートのすべてのための「マッピング」を持っています。このようなデバイスは、独自のセキュリティを担うことがあり、いくつかの他のネットワークデバイスは、すべての着信パケットをブロックされることを想定に頼ることはできません。"
    },
    {
      "indent": 0,
      "text": "7. Common Request and Response Header Format",
      "section_title": true,
      "ja": "7.一般的なリクエストとレスポンスヘッダー形式"
    },
    {
      "indent": 3,
      "text": "All PCP messages are sent over UDP, with a maximum UDP payload length of 1100 octets. The PCP messages contain a request or response header containing an Opcode, any relevant Opcode-specific information, and zero or more options. All numeric quantities larger than a single octet (e.g., result codes, lifetimes, Epoch times, etc.) are represented in conventional IETF network order, i.e., most significant octet first. Non-numeric quantities are represented as is on all platforms, with no byte swapping (e.g., IP addresses and ports are placed in PCP messages using the same representation as when placed in IP or TCP headers).",
      "ja": "すべてのPCPのメッセージは1100オクテットの最大UDPペイロード長と、UDPを介して送信されます。 PCPメッセージはオペコード、任意の関連するオペコード固有の情報、及びゼロ以上のオプションを含む要求または応答ヘッダを含みます。単一オクテットよりも大きい全ての数値量（例えば、結果コード、寿命、エポック時間、等）は、最初、すなわち、最も重要なオクテット、従来IETFネットワーク順に示されています。非数値量がないバイトスワッピングと、すべてのプラットフォーム上にあるように表されている（例えば、IPアドレスとポートはIPまたはTCPヘッダー内に配置されたときと同様の表現を用いてPCPメッセージに配置されます）。"
    },
    {
      "indent": 3,
      "text": "The packet layout for the common header, and operation of the PCP client and PCP server, are described in the following sections. The information in this section applies to all Opcodes. Behavior of the Opcodes defined in this document is described in Sections 10, 11, and 12.",
      "ja": "PCPクライアントとPCPサーバのパケットの共通ヘッダのレイアウト、および動作は、以下のセクションに記載されています。このセクションの情報は、すべてのオペコードに適用されます。この文書で定義されたオペコードの動作は、セクション10、11、及び12に記載されています。"
    },
    {
      "indent": 0,
      "text": "7.1. Request Header",
      "section_title": true,
      "ja": "7.1. 要求ヘッダー"
    },
    {
      "indent": 3,
      "text": "All requests have the following format:",
      "ja": "すべての要求の形式は次のとおりです。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Version = 2  |R|   Opcode    |         Reserved              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Requested Lifetime (32 bits)                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|            PCP Client's IP Address (128 bits)                 |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n:                                                               :\n:             (optional) Opcode-specific information            :\n:                                                               :\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n:                                                               :\n:             (optional) PCP Options                            :\n:                                                               :\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 2: Common Request Packet Format",
      "ja": "図2：一般的な要求パケットのフォーマット"
    },
    {
      "indent": 3,
      "text": "These fields are described below:",
      "ja": "これらのフィールドは以下の通りであります："
    },
    {
      "indent": 3,
      "text": "Version: This document specifies protocol version 2. PCP clients and servers compliant with this document use the value 2. This field is used for version negotiation as described in Section 9.",
      "ja": "バージョン：この文書は、本文書に準拠2. PCPクライアントとサーバは、セクション9で説明したように、このフィールドはバージョン交渉のために使用されている値2を使用するプロトコルのバージョンを指定します。"
    },
    {
      "indent": 3,
      "text": "R: Indicates Request (0) or Response (1).",
      "ja": "R：リクエスト（0）または応答（1）を示します。"
    },
    {
      "indent": 3,
      "text": "Opcode: A 7-bit value specifying the operation to be performed. MAP and PEER Opcodes are defined in Sections 11 and 12.",
      "ja": "オペコード：実行されるべき操作を指定する7ビットの値。 MAPピアオペコードは、セクション11および12に定義されています。"
    },
    {
      "indent": 3,
      "text": "Reserved: 16 reserved bits. MUST be zero on transmission and MUST be ignored on reception.",
      "ja": "予約：16予約ビット。送信にゼロでなければならないし、受信時には無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Requested Lifetime: An unsigned 32-bit integer, in seconds, ranging from 0 to 2^32-1 seconds. This is used by the MAP and PEER Opcodes defined in this document for their requested lifetime.",
      "ja": "要求された寿命：0から2 ^ 32-1秒の範囲秒の符号なし32ビット整数。これは、その要求された寿命のため、この文書で定義されたMAPとPEERオペコードで使用されています。"
    },
    {
      "indent": 3,
      "text": "PCP Client's IP Address: The source IPv4 or IPv6 address in the IP header used by the PCP client when sending this PCP request. An IPv4 address is represented using an IPv4-mapped IPv6 address. The PCP Client IP Address in the PCP message header is used to detect an unexpected NAT on the path between the PCP client and the PCP-controlled NAT or firewall device. See Section 8.1.",
      "ja": "PCPクライアントのIPアドレス：このPCP要求を送信する際にPCPクライアントによって使用されるIPヘッダの送信元IPv4またはIPv6アドレス。 IPv4アドレスは、IPv4マップIPv6アドレスを使用して表されています。 PCPメッセージヘッダにPCPのクライアントIPアドレスがPCPクライアントとPCP制御NATまたはファイアウォールデバイスとの間の経路上の予期しないNATを検出するために使用されます。 8.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "Opcode-specific information: Payload data for this Opcode. The length of this data is determined by the Opcode definition.",
      "ja": "オペコード固有情報：このオペコードのためのペイロードデータ。このデータの長さは、オペコード定義によって決定されます。"
    },
    {
      "indent": 3,
      "text": "PCP Options: Zero, one, or more options that are legal for both a PCP request and for this Opcode. See Section 7.3.",
      "ja": "PCPオプション：PCP要求の両方のためにと、このオペコードのための合法的なゼロ、1、または複数のオプション。 7.3節を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.2. Response Header",
      "section_title": true,
      "ja": "7.2. レスポンスヘッダー"
    },
    {
      "indent": 3,
      "text": "All responses have the following format:",
      "ja": "すべての応答の形式は次のとおりです。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Version = 2  |R|   Opcode    |   Reserved    |  Result Code  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Lifetime (32 bits)                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     Epoch Time (32 bits)                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                      Reserved (96 bits)                       |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n:                                                               :\n:             (optional) Opcode-specific response data          :\n:                                                               :\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n:             (optional) Options                                :\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 3: Common Response Packet Format",
      "ja": "図3：一般的な応答パケットのフォーマット"
    },
    {
      "indent": 3,
      "text": "These fields are described below:",
      "ja": "これらのフィールドは以下の通りであります："
    },
    {
      "indent": 3,
      "text": "Version: Responses from servers compliant with this specification MUST use version 2. This is set by the server.",
      "ja": "バージョン：この仕様に準拠したサーバからの応答は、これは、サーバーで設定されているバージョン2を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "R: Indicates Request (0) or Response (1). All Responses MUST use 1. This is set by the server.",
      "ja": "R：リクエスト（0）または応答（1）を示します。すべての応答はこれがサーバによって設定された1を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Opcode: The 7-bit Opcode value. The server copies this value from the request.",
      "ja": "オペコード：7ビットのオペコード値。要求からサーバーをコピーし、この値。"
    },
    {
      "indent": 3,
      "text": "Reserved: 8 reserved bits, MUST be sent as 0, MUST be ignored when received. This is set by the server.",
      "ja": "予約：8個の予約ビットを受信したときに無視されなければならない、0として送らなければなりません。これは、サーバーで設定されています。"
    },
    {
      "indent": 3,
      "text": "Result Code: The result code for this response. See Section 7.4 for values. This is set by the server.",
      "ja": "結果コード：このレスポンスの結果コード。値については、セクション7.4を参照してください。これは、サーバーで設定されています。"
    },
    {
      "indent": 3,
      "text": "Lifetime: An unsigned 32-bit integer, in seconds, ranging from 0 to 2^32-1 seconds. On an error response, this indicates how long clients should assume they'll get the same error response from that PCP server if they repeat the same request. On a success response for the PCP Opcodes that create a mapping (MAP and PEER), the Lifetime field indicates the lifetime for this mapping. This is set by the server.",
      "ja": "寿命：0から2 ^ 32-1秒の範囲秒の符号なし32ビット整数。エラー応答では、これは長い間、クライアントは、彼らが同じ要求を繰り返す場合、彼らはそのPCPサーバから同じエラーレスポンスを得るでしょう仮定するべきかを示します。マッピング（MAPおよびPEER）を作成PCPのオペコードのための成功応答で、Lifetimeフィールドは、このマッピングの寿命を示しています。これは、サーバーで設定されています。"
    },
    {
      "indent": 3,
      "text": "Epoch Time: The server's Epoch Time value. See Section 8.5 for discussion. This value is set by the server, in both success and error responses.",
      "ja": "エポック時間：サーバーのエポック時間値。議論のためのセクション8.5を参照してください。この値は、成功とエラー応答の両方で、サーバーによって設定されています。"
    },
    {
      "indent": 3,
      "text": "Reserved: 96 reserved bits. For requests that were successfully parsed, this MUST be sent as 0, MUST be ignored when received. This is set by the server. For requests that were not successfully parsed, the server copies the last 96 bits of the PCP Client's IP Address field from the request message into this corresponding 96-bit field of the response.",
      "ja": "予約：96予約ビット。受信時に正常に解析された要求の場合、これは0として送らなければなりません、無視しなければなりません。これは、サーバーで設定されています。サーバーに正常にコピー要求メッセージからPCPクライアントのIPアドレス]フィールドの最後の96ビット対応のこの対応する96ビットのフィールドに、解析されていなかった要求の場合。"
    },
    {
      "indent": 3,
      "text": "Opcode-specific information: Payload data for this Opcode. The length of this data is determined by the Opcode definition.",
      "ja": "オペコード固有情報：このオペコードのためのペイロードデータ。このデータの長さは、オペコード定義によって決定されます。"
    },
    {
      "indent": 3,
      "text": "PCP Options: Zero, one, or more options that are legal for both a PCP response and for this Opcode. See Section 7.3.",
      "ja": "PCPオプション：PCP応答の両方のためにと、このオペコードのための合法的なゼロ、1、または複数のオプション。 7.3節を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.3. Options",
      "section_title": true,
      "ja": "7.3. オプション"
    },
    {
      "indent": 3,
      "text": "A PCP Opcode can be extended with one or more options. Options can be used in requests and responses. The design decisions in this specification about whether to include a given piece of information in the base Opcode format or in an option were an engineering trade-off between packet size and code complexity. For information that is usually (or always) required, placing it in the fixed Opcode data results in simpler code to generate and parse the packet, because the information is a fixed location in the Opcode data, but wastes space in the packet in the event that field is all zeros because the information is not needed or not relevant. For information that is required less often, placing it in an option results in slightly more complicated code to generate and parse packets containing that option, but saves space in the packet when that information is not needed. Placing information in an option also means that an implementation that never uses that information doesn't even need to implement code to generate and parse it. For example, a client that never requests mappings on behalf of some other device doesn't need to implement code to generate the THIRD_PARTY option, and a PCP server that doesn't implement the necessary security measures to create third-party mappings safely doesn't need to implement code to parse the THIRD_PARTY option.",
      "ja": "PCPオペコードは、1つまたは複数のオプションで拡張することができます。オプションは、要求と応答で使用することができます。ベースオペコードフォーマットまたはオプションの情報の所定の部分を含めるかどうかについては、この明細書における設計上の決定は、パケットサイズとコードの複雑さとの間のエンジニアリングトレードオフでした。情報はオペコードデータ内の固定位置であるので、パケットを生成及び解析する単純なコードで固定オペコードデータ結果に置く必要通常（または常に）である情報のために、しかし場合にパケット内の廃棄物空間そのフィールドはすべてゼロの情報が必要とされていないためかは関係ありません。そのオプションを含むパケットを生成し、解析するためにやや複雑なコード内のオプション結果に置く、あまり頻繁に必要ですが、その情報が必要とされていない場合、パケット内のスペースを節約している情報について。オプションに情報を配置すると、その情報を利用したことがない実装もそれを生成して解析するコードを実装する必要がないことを意味します。例えば、いくつかの他のデバイスに代わって、マッピングを要求したことがないクライアントは、「doesnの安全にサードパーティのマッピングを作成するために必要なセキュリティ対策を実装していないTHIRD_PARTYオプション、およびPCPサーバを生成するコードを実装する必要はありません。トンTHIRD_PARTYオプションを解析するコードを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Options use the following Type-Length-Value format:",
      "ja": "オプションには、以下のタイプの長さと値の形式を使用します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Option Code  |  Reserved     |       Option Length           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n:                       (optional) Data                         :\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 4: Options Header",
      "ja": "図4：オプションヘッダー"
    },
    {
      "indent": 3,
      "text": "The description of the fields is as follows:",
      "ja": "次のように各フィールドの説明は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Option Code: 8 bits. Its most significant bit indicates if this option is mandatory (0) or optional (1) to process.",
      "ja": "オプションコード：8ビット。このオプションは（0）またはオプション（1）を処理することは必須である場合、その最上位ビットを示します。"
    },
    {
      "indent": 3,
      "text": "Reserved: 8 bits. MUST be set to 0 on transmission and MUST be ignored on reception.",
      "ja": "予約：8ビット。送信時に0に設定しなければならなくて、レセプションで無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Option Length: 16 bits. Indicates the length of the enclosed data, in octets. Options with length of 0 are allowed. Options that are not a multiple of 4 octets long are followed by one, two, or three 0 octets to pad their effective length in the packet to be a multiple of 4 octets. The Option Length reflects the semantic length of the option, not including any padding octets.",
      "ja": "オプションの長さ：16ビット。オクテットで、囲まれたデータの長さを示します。長さ0のオプションが許可されています。 4つのオクテットの倍数ではないオプションは、長いパケットにおけるそれらの有効長さが4つのオクテットの倍数になるようにパッド1つ、2つ、または3つの0オクテットが続きます。オプションの長さは、任意のパディングオクテットを含まないオプションの意味的な長さを反映しています。"
    },
    {
      "indent": 3,
      "text": "Data: Option data.",
      "ja": "データ：オプションデータ。"
    },
    {
      "indent": 3,
      "text": "If several options are included in a PCP request, they MAY be encoded in any order by the PCP client, but MUST be processed by the PCP server in the order in which they appear. It is the responsibility of the PCP client to ensure that the server has sufficient room to reply without exceeding the 1100-octet size limit; if its reply would exceed that size, the server generates an error.",
      "ja": "いくつかのオプションがPCP要求に含まれている場合、それらは、PCPクライアントによって、任意の順序で符号化されてもよいが、それらが表示される順序でPCPサーバによって処理しなければなりません。サーバーが1100オクテットのサイズ制限を超えずに返信するのに十分な余裕を持っていることを確認するために、PCPクライアントの責任です。その応答がそのサイズを超える場合、サーバーはエラーを生成します。"
    },
    {
      "indent": 3,
      "text": "If, while processing a PCP request, including its options, an error is encountered that causes a PCP error response to be generated, the PCP request MUST cause no state change in the PCP server or the PCP-controlled device (i.e., it rolls back any tentative changes it might have made while processing the request). Such an error response MUST consist of a complete copy of the request packet with the error code and other appropriate fields set in the header.",
      "ja": "そのオプションを含むPCP要求を、処理中に、エラーがPCPエラー応答が生成され、その検出された場合は、PCP要求が（すなわち、それはロールバックPCPサーバまたはPCP-制御機器における状態変化を起こしてはなりませんリクエストを処理している間、それが作られたかもしれない任意の仮の変更）。そのようなエラー応答は、エラーコードとヘッダに設定された他の適切なフィールドを有する要求パケットの完全なコピーで構成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "An option MAY appear more than once in a request or in a response, if permitted by the definition of the option. If the option's definition allows the option to appear only once but it appears more than once in a request, and the option is understood by the PCP server, the PCP server MUST respond with the MALFORMED_OPTION result code. If the PCP server encounters an invalid option (e.g., PCP option length is longer than the UDP packet length), the error MALFORMED_OPTION SHOULD be returned (rather than MALFORMED_REQUEST), as that helps the client better understand how the packet was malformed. If a PCP response would have exceeded the maximum PCP message size, the PCP server SHOULD respond with MALFORMED_REQUEST.",
      "ja": "オプションの定義によって許可されている場合のオプションは、要求または応答で複数回表示されることがあります。オプションの定義オプションは1度だけ表示することができますが、それは、要求内で複数回表示され、オプションはPCPサーバによって理解されている場合は、PCPサーバはMALFORMED_OPTION結果コードで応じなければなりません。 PCPサーバは無効なオプションに遭遇した場合（例えば、PCPオプション長がUDPパケット長よりも）それは、クライアントがより良いパケットが不正だったか理解するのに役立つよう、エラーMALFORMED_OPTIONは、（むしろMALFORMED_REQUESTより）返されるべきです。 PCP応答が最大PCPのメッセージサイズを超えていた場合は、PCPサーバはMALFORMED_REQUESTで応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the overall option structure of a request cannot successfully be parsed (e.g., a nonsensical option length), the PCP server MUST generate an error response with code MALFORMED_OPTION.",
      "ja": "要求の全体的なオプションの構造が正常に（例えば、無意味なオプションの長さ）解析できない場合、PCPサーバは、コードMALFORMED_OPTIONとエラー応答を生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the overall option structure of a request is valid, then how each individual option is handled is determined by the most significant bit in the option code. If the most significant bit is set, handling this option is optional, and a PCP server MAY process or ignore this option, entirely at its discretion. If the most significant bit is clear, handling this option is mandatory, and a PCP server MUST return the error MALFORMED_OPTION if the option contents are malformed, or UNSUPP_OPTION if the option is unrecognized, unimplemented, or disabled, or if the client is not authorized to use the option. In error responses, all options are returned. In success responses, all processed options are included and unprocessed options are not included.",
      "ja": "要求の全体的なオプション構成が有効である場合には、個々のオプションの処理方法オプションコード内の最上位ビットによって決定されます。最上位ビットがセットされている場合、このオプションを処理することはオプションであり、PCPサーバが処理したり、完全にその裁量で、このオプションを無視してもよい（MAY）。最上位ビットがクリアされている場合、このオプションを処理することは必須であり、そしてオプションは、認識されていない未実装、または無効になっている場合、またはクライアントが許可されていない場合はオプションの内容が不正であるか、あるいはUNSUPP_OPTION場合PCPサーバがエラーMALFORMED_OPTIONを返さなければなりませんオプションを使用します。エラーレスポンスでは、すべてのオプションが返されます。成功レスポンスでは、すべての処理されたオプションが含まれており、未処理のオプションが含まれていません。"
    },
    {
      "indent": 3,
      "text": "Because the PCP client cannot reject a response containing an Option, PCP clients MUST ignore Options that they do not understand that appear in responses, including Options in the mandatory-to-process range. Naturally, if a client explicitly requests an Option where correct execution of that Option requires processing the Option data in the response, that client SHOULD implement code to do that.",
      "ja": "PCPクライアントがオプションを含む応答を拒否することはできませんので、PCPのクライアントは、彼らが必須ツープロセスの範囲のオプションを含めて、レスポンスに表示されている理解していないオプションを無視しなければなりません。クライアントが明示的にそのオプションの正しい実行が応答したオプションデータの処理を必要とするオプションを要求した場合当然のことながら、そのクライアントはそれを行うためのコードを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Different options are valid for different Opcodes. For example:",
      "ja": "異なるオプションが異なるオペコードのために有効です。例えば："
    },
    {
      "indent": 3,
      "text": "o The THIRD_PARTY option is valid for both MAP and PEER Opcodes.",
      "ja": "O THIRD_PARTYオプションは、両方のMAPとPEERオペコードのために有効です。"
    },
    {
      "indent": 3,
      "text": "o The FILTER option is valid only for the MAP Opcode (for the PEER Opcode it would have no meaning).",
      "ja": "FILTERオプションO（PEERのオペコードのために、それは意味を持たないだろう）のみのMAPオペコードのために有効です。"
    },
    {
      "indent": 3,
      "text": "o The PREFER_FAILURE option is valid only for the MAP Opcode (for the PEER Opcode, similar semantics are automatically implied).",
      "ja": "PREFER_FAILUREオプションO（PEERのオペコードのために、同じような意味が自動的に暗示されている）だけMAPオペコードのために有効です。"
    },
    {
      "indent": 0,
      "text": "7.4. Result Codes",
      "section_title": true,
      "ja": "7.4. 結果コード"
    },
    {
      "indent": 3,
      "text": "The following result codes may be returned as a result of any Opcode received by the PCP server. The only success result code is 0; other values indicate an error. If a PCP server encounters multiple errors during processing of a request, it SHOULD use the most specific error message. Each error code below is classified as either a 'long lifetime' error or a 'short lifetime' error, which provides guidance to PCP server developers for the value of the Lifetime field for these errors. It is RECOMMENDED that short lifetime errors use a 30-second lifetime and long lifetime errors use a 30-minute lifetime.",
      "ja": "次の結果コードは、PCPサーバによって受信された任意のオペコードの結果として返されてもよいです。唯一の成功の結果コードは0です。その他の値はエラーを示しています。 PCPサーバは、要求の処理中に複数のエラーが発生した場合、それは最も具体的なエラーメッセージを使用すべきです。下記の各エラー・コードは、「長寿命」というエラーまたはこれらのエラーのために生涯フィールドの値のためのPCPサーバの開発者へのガイダンスを提供し「短い寿命」のエラー、のいずれかに分類されます。短い寿命の誤差が30秒の寿命を使用し、長寿命のエラーが30分の寿命を使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "0 SUCCESS: Success.",
      "ja": "0 SUCCESS：成功。"
    },
    {
      "indent": 3,
      "text": "1 UNSUPP_VERSION: The version number at the start of the PCP Request header is not recognized by this PCP server. This is a long lifetime error. This document describes PCP version 2.",
      "ja": "1 UNSUPP_VERSION：PCP要求ヘッダーの開始時にバージョン番号は、このPCPサーバによって認識されません。これは、長寿命・エラーです。このドキュメントでは、PCPのバージョン2を説明します。"
    },
    {
      "indent": 3,
      "text": "2 NOT_AUTHORIZED: The requested operation is disabled for this PCP client, or the PCP client requested an operation that cannot be fulfilled by the PCP server's security policy. This is a long lifetime error.",
      "ja": "2 NOT_AUTHORIZED：要求された操作は、このPCPクライアントのために無効、またはPCPクライアントは、PCPサーバのセキュリティポリシーによって満たすことができない操作を要求しています。これは、長寿命・エラーです。"
    },
    {
      "indent": 3,
      "text": "3 MALFORMED_REQUEST: The request could not be successfully parsed. This is a long lifetime error.",
      "ja": "3 MALFORMED_REQUEST：要求が正常に解析することができませんでした。これは、長寿命・エラーです。"
    },
    {
      "indent": 3,
      "text": "4 UNSUPP_OPCODE: Unsupported Opcode. This is a long lifetime error.",
      "ja": "4 UNSUPP_OPCODE：サポートされていないオペコード。これは、長寿命・エラーです。"
    },
    {
      "indent": 3,
      "text": "5 UNSUPP_OPTION: Unsupported option. This error only occurs if the option is in the mandatory-to-process range. This is a long lifetime error.",
      "ja": "5 UNSUPP_OPTION：サポートされていないオプション。オプションは必須ツープロセスの範囲内にある場合、このエラーが発生します。これは、長寿命・エラーです。"
    },
    {
      "indent": 3,
      "text": "6 MALFORMED_OPTION: Malformed option (e.g., appears too many times, invalid length). This is a long lifetime error.",
      "ja": "6 MALFORMED_OPTION：不正なオプションが（例えば、あまりにも多くの回数、無効な長さを表示されます）。これは、長寿命・エラーです。"
    },
    {
      "indent": 3,
      "text": "7 NETWORK_FAILURE: The PCP server or the device it controls is experiencing a network failure of some sort (e.g., has not yet obtained an external IP address). This is a short lifetime error.",
      "ja": "7 NETWORK_FAILURE：PCPサーバまたはそれがある種のネットワーク障害が発生している制御装置（例えば、まだ外部IPアドレスを取得していません）。これは、短い生涯のエラーです。"
    },
    {
      "indent": 3,
      "text": "8 NO_RESOURCES: Request is well-formed and valid, but the server has insufficient resources to complete the requested operation at this time. For example, the NAT device cannot create more mappings at this time, is short of CPU cycles or memory, or is unable to handle the request due to some other temporary condition. The same request may succeed in the future. This is a system-wide error, different from USER_EX_QUOTA. This can be used as a catch-all error, should no other error message be suitable. This is a short lifetime error.",
      "ja": "8つのNO_RESOURCES：リクエストが整形式と有効ですが、サーバーがこの時点で要求された操作を完了するのに十分なリソースを持っています。例えば、NATデバイスは、この時点でより多くのマッピングを作成することはできません、CPUサイクルまたはメモリが不足している、または何らかの他の一時的な状態へのリクエストを処理することができません。同じ要求は、将来的に成功する可能性があります。これはUSER_EX_QUOTAは異なる、システム全体のエラーです。これは、キャッチオール誤差として使用することができ、他のエラーメッセージは適していないはずです。これは、短い生涯のエラーです。"
    },
    {
      "indent": 3,
      "text": "9 UNSUPP_PROTOCOL: Unsupported transport protocol, e.g., SCTP in a NAT that handles only UDP and TCP. This is a long lifetime error.",
      "ja": "9 UNSUPP_PROTOCOL：サポートされていないトランスポートプロトコル、例えば、唯一のUDP及びTCPを処理するNATにSCTP。これは、長寿命・エラーです。"
    },
    {
      "indent": 3,
      "text": "10 USER_EX_QUOTA: This attempt to create a new mapping would exceed this subscriber's port quota. This is a short lifetime error.",
      "ja": "10 USER_EX_QUOTA：新しいマッピングを作成するには、この試みは、この加入者のポートクォータを超えます。これは、短い生涯のエラーです。"
    },
    {
      "indent": 3,
      "text": "11 CANNOT_PROVIDE_EXTERNAL: The suggested external port and/or external address cannot be provided. This error MUST only be returned for: * MAP requests that included the PREFER_FAILURE option (normal MAP requests will return an available external port) * MAP requests for the SCTP protocol (PREFER_FAILURE is implied) * PEER requests",
      "ja": "11 CANNOT_PROVIDE_EXTERNAL：提案外部ポートおよび/または外部アドレスを提供することができません。このエラーはのみのために返さなければなりません：PREFER_FAILUREオプション（通常MAP要求が利用可能な外部ポートを返します）*を付属* MAP要求SCTPプロトコルのMAP要求（PREFER_FAILUREが暗示される）* PEERリクエスト"
    },
    {
      "indent": 6,
      "text": "See Section 13.2 for details of the PREFER_FAILURE Option. The error lifetime depends on the reason for the failure.",
      "ja": "PREFER_FAILUREオプションの詳細については、セクション13.2を参照してください。エラー寿命は、失敗の理由に依存します。"
    },
    {
      "indent": 3,
      "text": "12 ADDRESS_MISMATCH: The source IP address of the request packet does not match the contents of the PCP Client's IP Address field, due to an unexpected NAT on the path between the PCP client and the PCP-controlled NAT or firewall. This is a long lifetime error.",
      "ja": "12 ADDRESS_MISMATCH：要求パケットの送信元IPアドレスが原因PCPクライアントとPCP-制御NATやファイアウォールとの間のパス上の予期しないNATに、PCPクライアントのIPアドレスフィールドの内容と一致していません。これは、長寿命・エラーです。"
    },
    {
      "indent": 3,
      "text": "13 EXCESSIVE_REMOTE_PEERS: The PCP server was not able to create the filters in this request. This result code MUST only be returned if the MAP request contained the FILTER option. See Section 13.3 for details of the FILTER Option. This is a long lifetime error.",
      "ja": "13 EXCESSIVE_REMOTE_PEERS：PCPサーバは、この要求にフィルタを作成することができませんでした。 MAP要求がFILTERオプションが含まれている場合、この結果コードのみが返されなければなりません。フィルタオプションの詳細については、13.3節を参照してください。これは、長寿命・エラーです。"
    },
    {
      "indent": 0,
      "text": "8. General PCP Operation",
      "section_title": true,
      "ja": "8.一般的なPCP操作"
    },
    {
      "indent": 3,
      "text": "PCP messages MUST be sent over UDP [RFC0768]. Every PCP request generates at least one response, so PCP does not need to run over a reliable transport protocol.",
      "ja": "PCPメッセージはUDP [RFC0768]の上に送らなければなりません。すべてのPCP要求は、少なくとも1つの応答を生成し、そのPCPは、信頼性の高いトランスポートプロトコルの上で実行する必要はありません。"
    },
    {
      "indent": 3,
      "text": "When receiving multiple identical requests, the PCP server will generally generate identical responses -- barring cases where the PCP server's state changes between those requests due to other activity. As an example of how such a state change could happen, a request could be received while the PCP-controlled device has no mappings available, and the PCP server will generate an error response. If mappings become available and then another copy of that same request arrives (perhaps duplicated in transit in the network), the PCP server will allocate a mapping and generate a non-error response. A PCP client MUST handle such updated responses for any request it sends, most notably to support rapid recovery (Section 14). Also see the Protocol Design Note (Section 6).",
      "ja": "複数の同一の要求を受信すると、PCPサーバは、一般的に、同一の応答を生成します - 他の活動に起因するこれらの要求の間でPCPサーバの状態が変化する例を除けば。 PCP制御装置が利用可能なマッピングを持っていない、及びPCPサーバはエラー応答を生成する一方、そのような状態変化が起こることができる方法の一例として、要求を受信することができます。マッピングが利用可能になると、その同じ要求の別のコピーが、（おそらく、ネットワーク内のトランジットで重複）到着し、PCPサーバは、マッピングを割り当て、非エラー応答を生成します。場合PCPクライアントは、それが最も顕著なの急速な回復（第14条）をサポートするために、送信するすべての要求のため、このような更新応答を処理しなければなりません。また、プロトコルデザインノート（第6節）を参照してください。"
    },
    {
      "indent": 0,
      "text": "8.1. General PCP Client: Generating a Request",
      "section_title": true,
      "ja": "8.1. 一般PCPクライアント：要求の生成"
    },
    {
      "indent": 3,
      "text": "This section details operation specific to a PCP client, for any Opcode. Procedures specific to the MAP Opcode are described in Section 11, and procedures specific to the PEER Opcode are described in Section 12.",
      "ja": "任意のオペコードのためのPCPクライアントに固有のこのセクションの詳細操作、。 MAPオペコードに固有の手順は、セクション11に記載されており、ピアオペコードに固有の手順は、第12章に記載されています。"
    },
    {
      "indent": 3,
      "text": "Prior to sending its first PCP message, the PCP client determines which server to use. The PCP client performs the following steps to determine its PCP server:",
      "ja": "その最初のPCPメッセージを送信する前に、PCPクライアントが使用するサーバーを決定します。 PCPクライアントは、そのPCPサーバを決定するには、次の手順を実行します。"
    },
    {
      "indent": 3,
      "text": "1. if a PCP server is configured (e.g., in a configuration file or via DHCP), that single configuration source is used as the list of PCP server(s), else",
      "ja": "1. PCPサーバは、（例えば、コンフィギュレーションファイルまたはDHCPを介して）、その単一の構成ソースをPCPサーバ（複数可）のリストとして使用されて構成されている場合、他の"
    },
    {
      "indent": 3,
      "text": "2. the default router list (for IPv4 and IPv6) is used as the list of PCP server(s). Thus, if a PCP client has both an IPv4 and IPv6 address, it will have an IPv4 PCP server (its IPv4 default router) for its IPv4 mappings, and an IPv6 PCP server (its IPv6 default router) for its IPv6 mappings.",
      "ja": "2.（IPv4とIPv6のための）デフォルトルータのリストは、PCPサーバ（複数可）のリストとして使用されています。 PCPクライアントはIPv4とIPv6アドレスの両方を持っている場合このように、それはそのIPv4のマッピングのためのIPv4 PCPサーバ（そのIPv4のデフォルトルータ）、およびそのIPv6のマッピングのためのIPv6 PCPサーバ（そのIPv6デフォルトルータ）を持っています。"
    },
    {
      "indent": 3,
      "text": "For the purposes of this document, only a single PCP server address is supported. Should future specifications define configuration methods that provide a longer list of PCP server addresses, those specifications will define how clients select one or more addresses from that list.",
      "ja": "このドキュメントの目的のために、単一のPCPサーバアドレスがサポートされています。将来の仕様は、PCPサーバアドレスの長いリストを提供し、設定方法を定義する必要があり、これらの仕様は、クライアントがそのリストから1つ以上のアドレスを選択する方法を定義します。"
    },
    {
      "indent": 3,
      "text": "With that PCP server address, the PCP client formulates its PCP request. The PCP request contains a PCP common header, PCP Opcode and payload, and (possibly) options. As with all UDP client software on any operating system, when several independent PCP clients exist on the same host, each uses a distinct source port number to disambiguate their requests and replies. The PCP client's source port SHOULD be randomly generated [RFC6056].",
      "ja": "そのPCPサーバのアドレスを使用すると、PCPのクライアントは、そのPCP要求を定式化します。 PCP要求をPCP共通ヘッダ、PCPオペコードとペイロード、および（おそらく）オプションを含んでいます。任意のオペレーティングシステム上のすべてのUDPクライアントソフトウェアと同じように、いくつかの独立したPCPのクライアントが同じホスト上に存在する場合、それぞれが自分の要求と応答を明確にするために個別の送信元ポート番号を使用しています。 PCPクライアントのソースポートがランダムに[RFC6056]を生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "The PCP client MUST include the source IP address of the PCP message in the PCP request. This is typically its own IP address; see Section 16.4 for how this can be coded. This is used to detect an unexpected NAT on the path between the PCP client and the PCP-controlled NAT or firewall device, to avoid wasting resources on the PCP-controlled NAT creating pointless non-functional mappings. When such an intervening non-PCP-aware inner NAT is detected, mappings must first be created by some other means in the inner NAT, before mappings can be usefully created in the outer PCP-controlled NAT. Having created mappings in the inner NAT by some other means, the PCP client should then use the inner NAT's external address as the client IP address, to signal to the outer PCP-controlled NAT that the client is aware of the inner NAT, and has taken steps to create mappings in it by some other means, so that mappings created in the outer NAT will not be a pointless waste of resources.",
      "ja": "PCPクライアントは、PCP要求におけるPCPメッセージの送信元のIPアドレスを含まなければなりません。これは、一般的に、自身のIPアドレスです。これをコード化することができるかについては、セクション16.4を参照してください。これは無意味な非機能マッピングを作成PCP-制御NAT上のリソースの浪費を避けるために、PCPクライアントとPCP-制御NATやファイアウォールデバイス間のパス上の予期しないNATを検出するために使用されます。ような介在非PCP-意識インナーNATが検出されると、マッピングが有効に外側PCP-制御NATで作成することができます前に、マッピングはまず、内部NATでいくつかの他の手段で作成する必要があります。いくつかの他の手段によって、内部NATでマッピングを作成した、PCPクライアントは、クライアントが内部NATを認識している、と持っていることを外PCP-制御NATに知らせるために、クライアントのIPアドレスとして内部NATの外部アドレスを使用する必要があります外側のNATで作成されたマッピングが資源の無意味な浪費されないように、いくつかの他の手段でそれにマッピングを作成する手順を取ら。"
    },
    {
      "indent": 0,
      "text": "8.1.1. PCP Client Retransmission",
      "section_title": true,
      "ja": "8.1.1.  PCPクライアントの再送信"
    },
    {
      "indent": 3,
      "text": "PCP clients are responsible for reliable delivery of PCP request messages. If a PCP client fails to receive an expected response from a server, the client must retransmit its message. The retransmissions MUST use the same Mapping Nonce value (see Sections 11.1 and 12.1). The client begins the message exchange by transmitting a message to the server. The message exchange continues for as long as the client wishes to maintain the mapping, and terminates when the PCP client is no longer interested in the PCP transaction (e.g., the application that requested the mapping is no longer interested in the mapping) or (optionally) when the message exchange is considered to have failed according to the retransmission mechanism described below.",
      "ja": "PCPクライアントは、PCP要求メッセージの信頼性の高い配信を担当しています。 PCPクライアントがサーバから期待される応答を受信できなかった場合、クライアントはそのメッセージを再送信する必要があります。再送信は、（セクション11.1と12.1を参照）と同じマッピングNonceの値を使用しなければなりません。クライアントがサーバーにメッセージを送信することによって、メッセージ交換を開始します。メッセージ交換がいる限り、クライアントがマッピングを維持したい、とPCPクライアントはもはやPCP取引に興味があるときに終了しないよう継続（例えば、マッピングを要求されたアプリケーションは、もはやマッピングに興味がありません）、または（必要に応じて）と、メッセージ交換は、後述する再送メカニズムに従って失敗したと考えられます。"
    },
    {
      "indent": 3,
      "text": "The client retransmission behavior is controlled and described by the following variables:",
      "ja": "クライアントの再送信動作は、以下の変数によって制御され、説明されています。"
    },
    {
      "indent": 5,
      "text": "RT: Retransmission timeout, calculated as described below",
      "ja": "RT：下記のように計算再送タイムアウト、"
    },
    {
      "indent": 4,
      "text": "IRT: Initial retransmission time, SHOULD be 3 seconds",
      "ja": "IRT：初期再送時間は、3秒であるべきです"
    },
    {
      "indent": 4,
      "text": "MRC: Maximum retransmission count, SHOULD be 0 (0 indicates no maximum)",
      "ja": "MRC：最大再送回数、0にしてください（0は最大値を示していません）"
    },
    {
      "indent": 4,
      "text": "MRT: Maximum retransmission time, SHOULD be 1024 seconds",
      "ja": "MRT：最大再送時間は、1024秒であるべきです"
    },
    {
      "indent": 4,
      "text": "MRD: Maximum retransmission duration, SHOULD be 0 (0 indicates no maximum)",
      "ja": "MRD：最大再送時間でなければならない0（0は最大値を示していません）"
    },
    {
      "indent": 3,
      "text": "RAND: Randomization factor, calculated as described below",
      "ja": "RAND：ランダム化因子、後述のように計算"
    },
    {
      "indent": 3,
      "text": "With each message transmission or retransmission, the client sets RT according to the rules given below. If RT expires before a response is received, the client retransmits the request and computes a new RT.",
      "ja": "各メッセージの送信または再送信して、クライアントは、下記の規則に従ってRTを設定します。応答が受信される前に、RTの有効期限が切れた場合、クライアントは要求を再送信し、新しいRTを計算します。"
    },
    {
      "indent": 3,
      "text": "Each of the computations of a new RT include a new randomization factor (RAND), which is a random number chosen with a uniform distribution between -0.1 and +0.1. The randomization factor is included to minimize synchronization of messages transmitted by PCP clients. The algorithm for choosing a random number does not need to be cryptographically sound. The algorithm SHOULD produce a different sequence of random numbers from each invocation of the PCP client.",
      "ja": "新しいRTの計算のそれぞれは、-0.1と+0.1の間に均一に分布して選択された乱数である新しいランダム化因子（RAND）を含みます。ランダム係数はPCPクライアントによって送信されたメッセージの同期化を最小限にするために含まれています。乱数を選択するためのアルゴリズムは、暗号音である必要はありません。アルゴリズムはPCPクライアントの各呼び出しから乱数の異なる配列を生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The RT value is initialized based on IRT:",
      "ja": "RT値は、IRTに基づいて初期化されます。"
    },
    {
      "indent": 6,
      "text": "RT = (1 + RAND) * IRT",
      "ja": "RT =（1 + RAND）* IRT"
    },
    {
      "indent": 3,
      "text": "RT for each subsequent message transmission is based on the previous value of RT, subject to the upper bound on the value of RT specified by MRT. If MRT has a value of 0, there is no upper limit on the value of RT, and MRT is treated as \"infinity\". The new value of RT is calculated as shown below, where RTprev is the current value of RT:",
      "ja": "各後続メッセージの送信のためのRTは、MRTによって指定されたRTの値の上限の対象とRTの以前の値に基づいています。 MRTは、0の値を有する場合、そこRTの値に上限はなく、MRTは「無限」として扱われます。 RTprevはRTの現在値であり、以下に示すようにRTの新しい値が計算されます。"
    },
    {
      "indent": 6,
      "text": "RT = (1 + RAND) * MIN (2 * RTprev, MRT)",
      "ja": "RT =（1 +ランド）* MIN（2 * RTprev、MRT）"
    },
    {
      "indent": 3,
      "text": "MRC specifies an upper bound on the number of times a client may retransmit a message. Unless MRC is zero, the message exchange fails once the client has transmitted the message MRC times.",
      "ja": "MRCは、クライアントがメッセージを再送することができる回数の上限を指定します。 MRCがゼロでない限り、クライアントはメッセージMRC回送信した後は、メッセージ交換が失敗します。"
    },
    {
      "indent": 3,
      "text": "MRD specifies an upper bound on the length of time a client may retransmit a message. Unless MRD is zero, the message exchange fails once MRD seconds have elapsed since the client first transmitted the message.",
      "ja": "MRDは、クライアントがメッセージを再送することができる時間の長さの上限を指定します。 MRDがゼロでない限り、クライアントは最初のメッセージを送信するのでMRD秒経過した後は、メッセージ交換が失敗します。"
    },
    {
      "indent": 3,
      "text": "If both MRC and MRD are non-zero, the message exchange fails whenever either of the conditions specified in the previous two paragraphs are met. If both MRC and MRD are zero, the client continues to transmit the message until it receives a response or the client no longer wants a mapping.",
      "ja": "MRCとMRD両方が非ゼロであれば前の二つの段落で指定された条件のいずれかが満たされるたびに、メッセージ交換が失敗します。 MRCとMRD両方がゼロの場合、クライアントは応答を受信して​​いないか、クライアントがもはやマッピングを望んでいるまで、メッセージを送信し続けます。"
    },
    {
      "indent": 3,
      "text": "Once a PCP client has successfully received a response from a PCP server on that interface, it resets RT to a value randomly selected in the range 1/2 to 5/8 of the mapping lifetime, as described in Section 11.2.1, \"Renewing a Mapping\", and sends subsequent PCP requests for that mapping to that same server.",
      "ja": "PCPクライアントがそのインターフェイス上のPCPサーバからの応答を正常に受信した後、セクション11.2.1に記載されているように、それがリニューアル」、ランダムマッピング寿命の5/8の範囲1/2で選択した値にRTをリセットマッピング」、およびその同じサーバーにそのマッピングのために、後続のPCP要求を送信します。"
    },
    {
      "indent": 6,
      "text": "Note: If the server's state changes between retransmissions and the server's response is delayed or lost, the state in the PCP client and server may not be synchronized. This is not unique to PCP, but also occurs with other network protocols (e.g., TCP). In the unlikely event that such de-synchronization occurs, PCP heals itself after lifetime seconds.",
      "ja": "注意：再送信し、サーバの応答の間に、サーバの状態変化が遅れたり、失われた場合、PCPクライアントとサーバ内の状態が同期されない場合があります。これは、PCPに固有のものではなく、また、他のネットワークプロトコル（例えば、TCP）で発生します。こうしたデ同期が発生するとは考えにくい場合には、PCPは、生涯秒後に自分自身を癒してくれる。"
    },
    {
      "indent": 0,
      "text": "8.2. General PCP Server: Processing a Request",
      "section_title": true,
      "ja": "8.2. 一般PCPサーバ：要求の処理"
    },
    {
      "indent": 3,
      "text": "This section details operation specific to a PCP server. Processing SHOULD be performed in the order of the following paragraphs.",
      "ja": "PCPサーバに固有のこのセクションの詳細操作。処理は、以下の段落の順序で実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "A PCP server MUST only accept normal (non-THIRD_PARTY) PCP requests from a client on the same interface from which it would normally receive packets from that client, and it MUST silently ignore PCP requests arriving on any other interface. For example, a residential NAT gateway accepts PCP requests only when they arrive on its (LAN) interface connecting to the internal network, and silently ignores any PCP requests arriving on its external (WAN) interface. A PCP server that supports THIRD_PARTY requests MAY be configured to accept THIRD_PARTY requests on other configured interfaces (see Section 13.1 for details on the THIRD_PARTY Option).",
      "ja": "PCPサーバは、それが正常にそのクライアントからのパケットを受信することになるから、同じインターフェイス上のクライアントからの正常（非THIRD_PARTY）PCPの要求を受け入れなければならない、そしてそれは静かに他のインターフェイスに到着PCP要求を無視しなければなりません。例えば、住宅のNATゲートウェイは、それらが内部ネットワークに接続し、その（LAN）インターフェイスに到達したときにのみPCP要求を受け入れ、そして静かにその外部（WAN）インターフェースに到着任意PCP要求を無視します。 THIRD_PARTY要求をサポートPCPサーバは、他の設定されたインターフェイス（THIRD_PARTYオプションの詳細については、13.1節を参照）にTHIRD_PARTY要求を受け入れるように構成することができます。"
    },
    {
      "indent": 3,
      "text": "Upon receiving a request, the PCP server parses and validates it. A valid request contains a valid PCP common header, one valid PCP Opcode, and zero or more options (which the server might or might not comprehend). If an error is encountered during processing, the server generates an error response that is sent back to the PCP client. Processing of an Opcode and its options is specific to each Opcode.",
      "ja": "要求を受信すると、PCPサーバは、解析し、それを検証します。有効な要求は、有効なPCP共通ヘッダ、つの有効なPCPのオペコード、および（サーバーがか理解していない場合があります）、ゼロまたは複数のオプションが含まれています。エラーが処理中に遭遇した場合、サーバは、PCPクライアントに返送されるエラー応答を生成します。オペコードとそのオプションの処理は、各オペコードに固有のものです。"
    },
    {
      "indent": 3,
      "text": "Error responses have the same packet layout as success responses, with certain fields from the request copied into the response, and other fields assigned by the PCP server set as indicated in Figure 3.",
      "ja": "エラー応答が成功応答にコピー要求から特定のフィールドを有する応答、および図3に示すように設定さPCPサーバによって割り当てられた他のフィールドと同じパケットレイアウトを有します。"
    },
    {
      "indent": 3,
      "text": "Copying request fields into the response is important because this is what enables a client to identify to which request a given response pertains. For Opcodes that are understood by the PCP server, it follows the requirements of that Opcode to copy the appropriate fields. For Opcodes that are not understood by the PCP server, it simply generates the UNSUPP_OPCODE response and copies fields from the PCP header and copies the rest of the PCP payload as is (without attempting to interpret it).",
      "ja": "これは与えられた応答が関係を要求するかを識別するためにクライアントを可能にするものであるため、応答にコピーリクエストフィールドが重要です。 PCPサーバによって理解されているオペコードの場合は、適切なフィールドをコピーすることオペコードの要件に従います。 PCPサーバによって理解されていないオペコードのために、それは単に（それを解釈しようとせずに）PCPヘッダコピーであるとしてPCPペイロードの残りの部分からUNSUPP_OPCODE応答コピーフィールドを生成します。"
    },
    {
      "indent": 3,
      "text": "All responses (both error and success) contain the same Opcode as the request, but with the \"R\" bit set.",
      "ja": "すべての応答（エラーと成功の両方）は、要求と同じオペコードを含んでいますが、「R」ビットがセットされました。"
    },
    {
      "indent": 3,
      "text": "Any error response has a non-zero result code, and is created by:",
      "ja": "エラー応答が非ゼロの結果コードを有し、によって作成されます。"
    },
    {
      "indent": 3,
      "text": "o Copying the entire UDP payload, or 1100 octets, whichever is less, and zero-padding the response to a multiple of 4 octets if necessary o Setting the R bit o Setting the result code o Setting the Lifetime, Epoch Time, and Reserved fields o Updating other fields in the response, as indicated by 'set by the server' in the PCP response field description",
      "ja": "O小さい方全体UDPペイロード、または1100個のオクテットを、コピー、および必要に応じて寿命、エポック時刻の設定oを結果コードを設定oをRビットの設定O 4つのオクテットの倍数に対応するゼロパディング、および予約フィールドPCP応答フィールドの説明において「サーバによって設定された」によって示されるように、応答の他のフィールドを更新するO"
    },
    {
      "indent": 3,
      "text": "A success response has a zero result code, and is created by:",
      "ja": "成功応答はゼロ結果コードを持っている、とによって作成されます。"
    },
    {
      "indent": 3,
      "text": "o Copying the first 4 octets of request packet header o Setting the R bit o Setting the result code to zero o Setting the Lifetime, Epoch Time, and Reserved fields o Possibly setting Opcode-specific response data if appropriate o Adding any processed options to the response message",
      "ja": "有効期間を設定oをゼロに結果コードを設定oをRビットの設定oを要求パケットヘッダの最初の4つのオクテットのコピーO、エポック時間、及び適切であればおそらくに任意の処理オプションを追加oをオペコード固有の応答データを設定O予約フィールド応答メッセージ"
    },
    {
      "indent": 3,
      "text": "If the received PCP request message is less than 2 octets long, it is silently dropped.",
      "ja": "受信PCP要求メッセージは、以下の2つのオクテット長である場合、それは黙って落とされます。"
    },
    {
      "indent": 3,
      "text": "If the R bit is set, the message is silently dropped.",
      "ja": "Rビットがセットされている場合、メッセージは静かに滴下します。"
    },
    {
      "indent": 3,
      "text": "If the first octet (version) is a version that is not supported, a response is generated with the UNSUPP_VERSION result code, and the Version Negotiation steps detailed in Section 9 are followed.",
      "ja": "最初のオクテット（バージョン）がサポートされていないバージョンである場合、応答はUNSUPP_VERSION結果コードで生成され、第9の詳細なバージョンネゴシエーションステップが続きます。"
    },
    {
      "indent": 3,
      "text": "Otherwise, if the version is supported but the received message is shorter than 24 octets, the message is silently dropped.",
      "ja": "バージョンがサポートされているが、受信したメッセージがより短い24オクテットであればそうでない場合、メッセージは静かに落とされます。"
    },
    {
      "indent": 3,
      "text": "If the server is overloaded by requests (from a particular client or from all clients), it MAY simply silently discard requests, as the requests will be retried by PCP clients, or it MAY generate the NO_RESOURCES error response.",
      "ja": "サーバは（特定のクライアントから、またはすべてのクライアントからの）要求によってオーバーロードされている場合、要求はPCPクライアントによって再試行されるように、それは単に静かに、要求を破棄したり、それがNO_RESOURCESエラー応答を生成することがあります。"
    },
    {
      "indent": 3,
      "text": "If the length of the message exceeds 1100 octets, is not a multiple of 4 octets, or is too short for the Opcode in question, it is invalid and a MALFORMED_REQUEST response is generated, and the response message is truncated to 1100 octets.",
      "ja": "メッセージの長さが1100個のオクテットを超える場合は、4つのオクテットの倍数でない場合、または問題のオペコードのための短すぎる、それが無効であるとMALFORMED_REQUEST応答が生成され、応答メッセージは1100個のオクテットに切り捨てられます。"
    },
    {
      "indent": 3,
      "text": "The PCP server compares the source IP address (from the received IP header) with the field PCP Client IP Address. If they do not match, the error ADDRESS_MISMATCH MUST be returned. This is done to detect and prevent accidental use of PCP where a non-PCP-aware NAT exists between the PCP client and PCP server. If the PCP client wants such a mapping, it needs to ensure that the PCP field matches its apparent IP address from the perspective of the PCP server.",
      "ja": "PCPサーバは、PCPフィールドクライアントIPアドレスを使用して（受信したIPヘッダから）送信元IPアドレスとを比較します。それらが一致しない場合は、エラーADDRESS_MISMATCHを返さなければなりません。これは、検出し、非PCP-意識NATは、PCPクライアントとPCPサーバの間に存在するPCPの偶然の使用を防止するために行われます。 PCPクライアントは、このようなマッピングを望んでいるなら、それはPCPフィールドはPCPサーバの観点から、その見かけのIPアドレスと一致することを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.3. General PCP Client: Processing a Response",
      "section_title": true,
      "ja": "8.3. 一般PCPクライアント：応答の処理"
    },
    {
      "indent": 3,
      "text": "The PCP client receives the response and verifies that the source IP address and port belong to the PCP server of a previously sent PCP request. If not, the response is silently dropped.",
      "ja": "PCPクライアントが応答を受信し、送信元IPアドレスとポートが以前PCP要求を送信したのPCPサーバに属していることを確認します。そうでない場合、応答は黙って落とされます。"
    },
    {
      "indent": 3,
      "text": "If the received PCP response message is less than 4 octets long, it is silently dropped.",
      "ja": "受信PCP応答メッセージは以下の4つのオクテット長である場合、それは黙って落とされます。"
    },
    {
      "indent": 3,
      "text": "If the R bit is clear, the message is silently dropped.",
      "ja": "Rビットがクリアされている場合、メッセージは黙って落とされます。"
    },
    {
      "indent": 3,
      "text": "If the error code is UNSUPP_VERSION, Version Negotiation processing continues as described in Section 9.",
      "ja": "エラーコードがUNSUPP_VERSIONある場合、セクション9に記載されているように、バージョンネゴシエーション処理が継続されます。"
    },
    {
      "indent": 3,
      "text": "Responses shorter than 24 octets, longer than 1100 octets, or not a multiple of 4 octets are invalid and ignored.",
      "ja": "24オクテットより短い応答、より長い1100オクテット、あるいはません4つのオクテットの倍数は無効であり、無視されています。"
    },
    {
      "indent": 3,
      "text": "The PCP client then validates that the Opcode matches a previous PCP request. If the response does not match a previous PCP request, the response is ignored. The response is further matched by comparing fields in the response Opcode-specific data to fields in the request Opcode-specific data, as described by the processing for that Opcode. If that fails, the response is ignored.",
      "ja": "PCPクライアントは、オペコードが前のPCPの要求と一致していることを検証します。応答が前のPCPの要求と一致しない場合、応答は無視されます。そのオペコードの処理によって記載されたように応答はさらに、要求オペコード固有のデータのフィールドに応答オペコード固有のデータのフィールドを比較することで一致しています。それが失敗した場合、応答は無視されます。"
    },
    {
      "indent": 3,
      "text": "After these matches are successful, the PCP client checks the Epoch Time field (see Section 8.5) to determine if it needs to restore its state to the PCP server. A PCP client SHOULD be prepared to receive multiple responses from the PCP server at any time after a single request is sent. This allows the PCP server to inform the client of mapping changes such as an update or deletion. For example, a PCP server might send a SUCCESS response and, after a configuration change on the PCP server, later send a NOT_AUTHORIZED response. A PCP client MUST be prepared to receive responses for requests it never sent (which could have been sent by a previous PCP instance on this same host, or by a previous host that used the same client IP address, or by a malicious attacker) by simply ignoring those unexpected messages.",
      "ja": "これらのマッチが成功した後、PCPクライアントは、PCPサーバにその状態を復元する必要があるかどうかを判断する（セクション8.5を参照）エポック時刻フィールドをチェックします。 PCPクライアントは、単一のリクエストが送信された後、任意の時点でPCPサーバから複数の応答を受け取るために準備する必要があります。これは、PCPサーバは、更新や削除などのマッピングの変更をクライアントに通知することができます。例えば、PCPサーバは、SUCCESS応答を送信して、PCPサーバ上の設定を変更した後、後でNOT_AUTHORIZED応答を送信することがあります。 PCPクライアントがで（これと同じホスト上、または同じクライアントのIPアドレスを使用し、以前のホストによって、または悪意のある攻撃者によって以前PCPインスタンスによって送信された可能性がある）、それが送信されることはありません要求に対して応答を受け取るために準備しなければなりません単にこれらの予期しないメッセージを無視します。"
    },
    {
      "indent": 3,
      "text": "If the error ADDRESS_MISMATCH is received, it indicates the presence of a NAT between the PCP client and PCP server. Procedures to resolve this problem are beyond the scope of this document.",
      "ja": "エラーADDRESS_MISMATCHを受信した場合、それはPCPクライアントとPCPサーバ間のNATが存在することを示しています。この問題を解決するための手順は、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "For both success and error responses, a Lifetime value is returned. The lifetime indicates how long this response should be considered valid by the client (i.e for success results, how long the mapping will last, and for failure results how long the same failure condition should be expected to persist). The PCP client SHOULD impose an upper limit on this returned value (to protect against absurdly large values, e.g., 5 years), detailed in Section 15, \"Mapping Lifetime and Deletion\".",
      "ja": "両方の成功とエラー応答では、ライフタイム値が返されます。寿命は、この応答は、クライアント（同じ障害状態が持続すると予想されなければならないどのくらい成功した結果について、マッピングがいつまで続く、と失敗結果のすなわち）によって有効とみなされる期間を示します。 PCPクライアントはこれに上限を課すべきセクション15、「マッピング寿命および削除」の詳細（例えば、とてつもなく大きい値から保護するために、5年）の値を、返さ。"
    },
    {
      "indent": 3,
      "text": "If the result code is 0 (SUCCESS), the request succeeded.",
      "ja": "結果コードが0（SUCCESS）である場合、要求は成功しました。"
    },
    {
      "indent": 3,
      "text": "If the result code is not 0, the request failed, and the PCP client SHOULD NOT resend the same request for the indicated lifetime of the error (as limited by the sanity checking detailed in Section 15).",
      "ja": "結果コードが0でない場合は、要求が失敗した、と（セクション15で詳述チェック正気によって制限される）PCPクライアントは、エラーの指示寿命のために同じ要求を再送信すべきではありません。"
    },
    {
      "indent": 3,
      "text": "If the PCP client has discovered a new PCP server (e.g., connected to a new network), the PCP client MAY immediately begin communicating with this PCP server, without regard to hold times from communicating with a previous PCP server.",
      "ja": "PCPクライアントが（例えば、新しいネットワークに接続された）新しいPCPサーバを発見した場合は、PCPクライアントは直前のPCPサーバと通信時間を保持するために関係なく、このPCPサーバとの通信を開始するかもしれません。"
    },
    {
      "indent": 0,
      "text": "8.4. Multi-Interface Issues",
      "section_title": true,
      "ja": "8.4. マルチインターフェイスの問題"
    },
    {
      "indent": 3,
      "text": "Hosts that desire a PCP mapping might be multi-interfaced (i.e., own several logical/physical interfaces). Indeed, a host can be configured with several IPv4 addresses (e.g., WiFi and Ethernet) or dual-stacked. These IP addresses may have distinct reachability scopes (e.g., if IPv6, they might have global reachability scope as is the case for a Global Unicast Address (GUA) [RFC3587] or limited scope as is the case for a Unique Local Address (ULA) [RFC4193]).",
      "ja": "PCPマッピングを望むホスト（すなわち、複数の論理/物理インターフェイスを所有）マルチインターフェースであるかもしれません。実際に、ホストは、いくつかのIPv4アドレス（例えば、Wi-Fiとイーサネット）またはデュアル積層して構成することができます。これらのIPアドレスは、（グローバルユニキャストアドレス（GUA）[RFC3587]または限定された範囲の場合のようにユニークローカルアドレスの場合のように例えば、IPv6の場合、彼らはグローバルな到達可能範囲を持っているかもしれません（明確な到達可能性のスコープを持っているかもしれULA） [RFC4193]）。"
    },
    {
      "indent": 3,
      "text": "IPv6 addresses with global reachability (e.g., GUAs) SHOULD be used as the source address when generating a PCP request. IPv6 addresses without global reachability (e.g., ULAs) SHOULD NOT be used as the source interface when generating a PCP request. If IPv6 privacy addresses [RFC4941] are used for PCP mappings, a new PCP request will need to be issued whenever the IPv6 privacy address is changed. This PCP request SHOULD be sent from the IPv6 privacy address itself. It is RECOMMENDED that the client delete its mappings to the previous privacy address after it no longer needs those old mappings.",
      "ja": "IPv6は、グローバル到達可能PCP要求を生成するとき（例えば、総研大）は、送信元アドレスとして使用されるべきで対処します。 IPv6は、PCP要求を生成するとき（例えば、ULAs）は、ソースインタフェースとして使用することはできませんグローバル到達可能性なしに対処します。 IPv6のプライバシーアドレス[RFC4941]はPCPのマッピングのために使用されている場合のIPv6プライバシーアドレスが変更されるたびに、新しいPCP要求を発行する必要があります。このPCP要求は、IPv6プライバシーアドレス自体から送信されます。もはやそれらの古いマッピングを必要とした後、クライアントは、以前のプライバシーアドレスへのマッピングを削除しないことが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Due to the ubiquity of IPv4 NAT, IPv4 addresses with limited scope (e.g., private addresses [RFC1918]) MAY be used as the source interface when generating a PCP request.",
      "ja": "IPv4のNATの普及に、IPv4がPCP要求を生成するとき（例えば、プライベートアドレス[RFC1918]）は、ソースインタフェースとして使用されるかもしれ限られた範囲で対処します。"
    },
    {
      "indent": 0,
      "text": "8.5. Epoch",
      "section_title": true,
      "ja": "8.5. 時代"
    },
    {
      "indent": 3,
      "text": "Every PCP response sent by the PCP server includes an Epoch Time field. This time field increments by one every second. Anomalies in the received Epoch Time value provide a hint to PCP clients that a PCP server state loss may have occurred. Clients respond to such state loss hints by promptly renewing their mappings, so as to quickly restore any lost state at the PCP server.",
      "ja": "PCPサーバによって送信されたすべてのPCP応答がエポックタイムフィールドを含みます。 1秒ごとによるこの時間は、フィールドの値が増加します。受信エポックタイム値の異常は、PCPサーバの状態の損失が発生した可能性があるPCPクライアントへのヒントを提供します。迅速PCPサーバで失われた状態を復元するようにクライアントは、速やかにそのマッピングを更新することにより、このような状態の損失のヒントに応答します。"
    },
    {
      "indent": 3,
      "text": "If the PCP server resets or loses the state of its explicit dynamic mappings (that is, those mappings created by PCP requests), due to reboot, power failure, or any other reason, it MUST reset its Epoch time to its initial starting value (usually zero) to provide this hint to PCP clients. After resetting its Epoch time, the PCP server resumes incrementing the Epoch Time value by one every second.",
      "ja": "PCPサーバのリセットまたは再起動、電源障害、またはその他の理由のためにその明示的なダイナミックなマッピング（つまりは、PCPの要求によって作成されたもののマッピングである）、の状態を失った場合、それは（その最初の開始値にそのエポックの時間をリセットする必要があります通常はゼロ）PCPクライアントにこのヒントを提供します。そのエポックの時間をリセットした後、PCPサーバは、1秒ごとによるエポックタイム値をインクリメントを再開します。"
    },
    {
      "indent": 3,
      "text": "Similarly, if the external IP address(es) of the NAT (controlled by the PCP server) changes, the Epoch time MUST be reset. A PCP server MAY maintain one Epoch Time value for all PCP clients or MAY maintain distinct Epoch Time values (per PCP client, per interface, or based on other criteria); this choice is implementation-dependent.",
      "ja": "同様に、（PCPサーバによって制御される）NAT変化の外部IPアドレス（複数可）と、エポック時間をリセットする必要があります。 PCPサーバは、すべてのPCPクライアントに対して1エポックタイム値を維持することができるか、明確なエポック時刻値を維持することができる（インターフェイスごとに、PCPクライアントごと、または他の基準に基づいて）。この選択は実装依存です。"
    },
    {
      "indent": 3,
      "text": "Whenever a client receives a PCP response, the client validates the received Epoch Time value according to the procedure below, using integer arithmetic:",
      "ja": "クライアントは、PCPの応答を受信するたびに、クライアントは、整数演算を使用して、以下の手順に従って、受信されたエポック時刻値を検証します。"
    },
    {
      "indent": 3,
      "text": "o If this is the first PCP response the client has received from this PCP server, the Epoch Time value is treated as necessarily valid, otherwise",
      "ja": "これは、クライアントがこのPCPサーバから受信した最初のPCP応答である場合には、O、エポック時間値がそれ以外の場合は、必ずしも有効なものとして扱われます"
    },
    {
      "indent": 6,
      "text": "* If the current PCP server Epoch time (curr_server_time) is less than the previously received PCP server Epoch time (prev_server_time) by more than one second, then the client treats the Epoch time as obviously invalid (time should not go backwards). The server Epoch time apparently going backwards by *up to* one second is not deemed invalid, so that minor packet reordering on the path from PCP server to PCP client does not trigger a cascade of unnecessary mapping renewals. If the server Epoch time passes this check, then further validation checks are performed:",
      "ja": "現在のPCPサーバのエポック時間（curr_server_time）が1秒以上により、以前に受信したPCPサーバのエポック時間（prev_server_time）未満の場合*、その後、クライアントは、として、明らかに無効なエポックの時間を（時間が逆方向に行くべきではありません）扱います。 PCPクライアントへのPCPサーバからのパスに並べ替えマイナーなパケットが不必要なマッピングの更新のカスケードをトリガしないように、サーバーのエポック時間は明らかに、1秒が無効とされていません*まで*によって後方に行きます。サーバーのエポック時間は、このチェックに合格した場合は、さらに検証チェックが実行されます。"
    },
    {
      "indent": 9,
      "text": "+ The client computes the difference between its current local time (curr_client_time) and the time the previous PCP response was received from this PCP server (prev_client_time): client_delta = curr_client_time - prev_client_time;",
      "ja": "+クライアントは、その現在のローカル時刻（curr_client_time）と前PCP応答がこのPCPサーバ（prev_client_time）から受信した時刻との差算出：client_delta = curr_client_time  -  prev_client_timeします。"
    },
    {
      "indent": 9,
      "text": "+ The client computes the difference between the current PCP server Epoch time (curr_server_time) and the previously received Epoch time (prev_server_time): server_delta = curr_server_time - prev_server_time;",
      "ja": "+クライアントは、現在のPCPサーバエポック時間（curr_server_time）と以前に受信されたエポック時間（prev_server_time）との差分計算：server_delta = curr_server_time  -  prev_server_timeします。"
    },
    {
      "indent": 9,
      "text": "+ If client_delta+2 < server_delta - server_delta/16 or server_delta+2 < client_delta - client_delta/16, then the client treats the Epoch Time value as invalid, else the client treats the Epoch Time value as valid.",
      "ja": "+もしclient_delta + 2 <server_delta  -  server_delta / 16またはserver_delta + 2 <client_delta  -  client_delta / 16、そしてクライアントは、エポックタイム値は無効として扱い、他のクライアントが有効なエポックタイム値を扱います。"
    },
    {
      "indent": 3,
      "text": "o The client records the current time values for use in its next comparison: prev_client_time = curr_client_time prev_server_time = curr_server_time",
      "ja": "Oクライアントはその次の比較で使用するために現在の時間値を記録しますprev_client_time = curr_client_time prev_server_time = curr_server_time"
    },
    {
      "indent": 3,
      "text": "If the PCP client determined that the Epoch Time value it received was invalid, then it concludes that the PCP server may have lost state, and promptly renews all its active port mapping leases following the mapping recreation procedure described in Section 16.3.1.",
      "ja": "PCPクライアントは、それが受け取ったエポック時刻の値が無効であると判断した場合、それはPCPサーバが状態を失ったかもしれないと結論し、速やか16.3.1項で説明したマッピングレクリエーション手順を、以下のすべてのアクティブポートマッピングのリースを更新します。"
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 3,
      "text": "o The client clock MUST never go backwards. If curr_client_time is found to be less than prev_client_time, then this is a client bug, and how the client deals with this client bug is implementation specific.",
      "ja": "Oクライアントクロックは後方に行くことはありませんしなければなりません。 curr_client_timeがprev_client_time未満であることが判明した場合、これはクライアントのバグであり、このクライアントのバグとクライアントのお得な情報は、実装固有のものですか。"
    },
    {
      "indent": 3,
      "text": "o The calculations above are constructed to allow client_delta and server_delta to be computed as unsigned integer values.",
      "ja": "上記の計算oをclient_deltaとserver_deltaが符号なし整数値として計算することができるように構成されています。"
    },
    {
      "indent": 3,
      "text": "o The \"+2\" in the calculations above is to accommodate quantization errors in client and server clocks (up to one-second quantization error each in server and client time intervals).",
      "ja": "上記の計算における「+2」は、（サーバとクライアントの時間間隔で各1秒の量子化誤差まで）クライアントとサーバのクロックの量子化誤差を収容することであるO。"
    },
    {
      "indent": 3,
      "text": "o The \"/16\" in the calculations above is to accommodate inaccurate clocks in low-cost devices. This allows for a total discrepancy of up to 1/16 (6.25%) to be considered benign; e.g., if one clock were to run too fast by 3% while the other clock ran too slow by 3%, then the client would not consider this difference to be anomalous or indicative of a restart having occurred. This tolerance is strict enough to be effective at detecting reboots, while not being so strict as to generate false alarms.",
      "ja": "上記の計算で、「/ 16」oは​​、低コストの装置で不正確なクロックを収容することです。これは良性の考慮すべき最大1/16（6.25％）の総不一致を可能にします。 1つのクロックは、他のクロックは3％遅すぎる走っながら3％の速すぎて実行した場合、例えば、クライアントは異常または再起動が発生したことを示すように、この違いを考慮していないでしょう。誤警報を発生するように厳密ではないが、この許容値は、検出、再起動するのに有効であることが十分に厳格です。"
    },
    {
      "indent": 0,
      "text": "9. Version Negotiation",
      "section_title": true,
      "ja": "9.バージョンのネゴシエーション"
    },
    {
      "indent": 3,
      "text": "A PCP client sends its requests using PCP version number 2. Should later updates to this document specify different message formats with a version number greater than 2, it is expected that PCP servers will still support version 2 in addition to the newer version(s). However, in the event that a server returns a response with result code UNSUPP_VERSION, the client MAY log an error message to inform the user that it is too old to work with this server.",
      "ja": "PCPクライアントは、PCPのバージョン番号2を使用して、その要求は後でこのドキュメントの更新は、2よりも大きいバージョン番号と異なるメッセージ形式を指定する必要があります送信し、それがPCPサーバは、まだ新しいバージョンに加えて、バージョン2をサポートすることが期待される（S） 。ただし、サーバは結果コードUNSUPP_VERSIONとレスポンスを返したときに、クライアントは、このサーバーで動作するようにあまりにも古いであることをユーザに通知するエラーメッセージを記録することがあります。"
    },
    {
      "indent": 3,
      "text": "Should later updates to this document specify different message formats with a version number greater than 2, and backwards compatibility be desired, this first octet can be used for forward and backward compatibility.",
      "ja": "このドキュメントへの以降の更新は2より大きいバージョン番号と異なるメッセージ形式を指定する必要があり、および下位互換性が所望され、この最初のオクテットは、前方および後方互換性のために使用することができます。"
    },
    {
      "indent": 3,
      "text": "If future PCP versions greater than 2 are specified, version negotiation proceeds as follows:",
      "ja": "2より大きく、将来のPCPのバージョンが指定されている場合は、バージョン交渉を進め、次のように："
    },
    {
      "indent": 3,
      "text": "1. The client sends its first request using the highest (i.e., presumably 'best') version number it supports.",
      "ja": "1.クライアントは、それがサポートする最高の（すなわち、おそらく「最良」）バージョン番号を使用して、その最初の要求を送信します。"
    },
    {
      "indent": 3,
      "text": "2. If the server supports that version, it responds normally.",
      "section_title": true,
      "ja": "2.サーバーがそのバージョンをサポートしている場合、それが正常に応答します。"
    },
    {
      "indent": 3,
      "text": "3. If the server does not support that version, it replies giving a result containing the result code UNSUPP_VERSION, and the closest version number it does support (if the server supports a range of versions higher than the client's requested version, the server returns the lowest of that supported range; if the server supports a range of versions lower than the client's requested version, the server returns the highest of that supported range).",
      "ja": "サーバーがクライアントの要求したバージョンより高いバージョンの範囲をサポートしている場合、サーバーはそのバージョンをサポートしていない場合3.、（それが結果コードUNSUPP_VERSIONを含む結果を与えて返信し、最も近いバージョン番号は、それがサポートしています、サーバーが返しますそのサポートされている範囲の最低;サーバーがクライアントの要求されたバージョンより低いバージョンの範囲をサポートしている場合、サーバーは）そのサポートされる範囲の最高返します。"
    },
    {
      "indent": 3,
      "text": "4. If the client receives an UNSUPP_VERSION result containing a version it does support, it records this fact and proceeds to use this message version for subsequent communication with this PCP server (until a possible future UNSUPP_VERSION response if the server is later updated, at which point the version negotiation process repeats). If the version number in the UNSUPP_VERSION response is zero then that means this is a NAT-PMP server [RFC6886], and a client MAY choose to communicate with it using the older NAT-PMP protocol, as described in Appendix A.",
      "ja": "4.クライアントがサポートしていますバージョンを含むUNSUPP_VERSION結果を受信した場合、それはこの事実を記録し、サーバーが後で更新された場合に可能な将来UNSUPP_VERSION応答するまで、このPCPサーバ（とその後の通信のために、このメッセージのバージョンを使用するように進み、その時）バージョンネゴシエーションプロセスの繰り返しを指します。 UNSUPP_VERSION応答のバージョン番号がゼロである場合、それは、これはNAT-PMPサーバ[RFC6886]であることを意味し、および付録Aで説明したように、クライアントは、それが古いNAT-PMPプロトコルを使用して通信することを選ぶかもしれ"
    },
    {
      "indent": 3,
      "text": "5. If the client receives an UNSUPP_VERSION result containing a version it does not support, then the client SHOULD try the next-lower version supported by the client. The attempt to use the next-lower version repeats until the client has tried version 2. If using version 2 fails, the client MAY log an error message to inform the user that it is too old to work with this server, and the client SHOULD set a timer to retry its request in 30 minutes or the returned Lifetime value, whichever is smaller. By automatically retrying in 30 minutes, the protocol accommodates an upgrade of the PCP server.",
      "ja": "5.クライアントがサポートされていないバージョンを含むUNSUPP_VERSION結果を受信した場合、クライアントは、クライアントでサポートされている次の下位バージョンを試してみてください。バージョン2を使用して失敗した場合、クライアントはバージョン2を試してみましたまでは次の下位バージョンを使用しようとする試みが繰り返され、クライアントは、このサーバーで動作するようにあまりにも古いであることをユーザに通知するエラーメッセージをログに記録することができ、クライアントはSHOULD 30分以下である方返さ生涯価値、その要求を再試行するようにタイマーを設定します。 30分で自動的に再試行することにより、プロトコルは、PCPサーバのアップグレードに対応します。"
    },
    {
      "indent": 0,
      "text": "10. Introduction to MAP and PEER Opcodes",
      "section_title": true,
      "ja": "10.はじめには、マップやピア・オペコード"
    },
    {
      "indent": 3,
      "text": "There are four uses for the MAP and PEER Opcodes defined in this document:",
      "ja": "この文書で定義されたMAPとPEERオペコードのための4つの用途があります。"
    },
    {
      "indent": 3,
      "text": "o a host operating a server and wanting an incoming connection (Section 10.1);",
      "ja": "Oホストサーバーを操作して、着信接続（セクション10.1）たいです。"
    },
    {
      "indent": 3,
      "text": "o a host operating a client and server on the same port (Section 10.2);",
      "ja": "同じポート（10.2節）上のクライアントとサーバを動作させるホストO;"
    },
    {
      "indent": 3,
      "text": "o a host operating a client and wanting to optimize the application keepalive traffic (Section 10.3); and",
      "ja": "Oホストは、クライアントを操作し、アプリケーションキープアライブトラフィック（10.3）を最適化したいです。そして"
    },
    {
      "indent": 3,
      "text": "o a host operating a client and wanting to restore lost state in its NAT (Section 10.4).",
      "ja": "Oホストは、クライアントを操作し、そのNAT（10.4）で失われた状態を復元したいです。"
    },
    {
      "indent": 3,
      "text": "These are discussed in the following sections, and a (non-normative) state diagram is provided in Section 16.5.",
      "ja": "これらは、次のセクションで説明されており、（非規範的）状態図は、セクション16.5に設けられています。"
    },
    {
      "indent": 3,
      "text": "When operating a server (see Sections 10.1 and 10.2), the PCP client knows if it wants an IPv4 listener, IPv6 listener, or both on the Internet. The PCP client also knows if it has an IPv4 address or IPv6 address configured on one of its interfaces. It takes the union of this knowledge to decide to which of its PCP servers to send the request (e.g., an IPv4 address or an IPv6 address), and whether to send one or two MAP requests for each of its interfaces (e.g., if the PCP client has only an IPv4 address but wants both IPv6 and IPv4 listeners, it sends a MAP request containing the all-zeros IPv6 address in the Suggested External Address field, and sends a second MAP request containing the all-zeros IPv4 address in the Suggested External Address field). If the PCP client has both an IPv4 and IPv6 address, and only wants an IPv4 listener, it sends one MAP request from its IPv4 address (if the PCP server supports NAT44 or IPv4 firewall) or one MAP request from its IPv6 address (if the PCP server supports NAT64). The PCP client can simply request the desired mapping to determine if the PCP server supports the desired mapping. Applications that embed IP addresses in payloads (e.g., FTP, SIP) will find it beneficial to avoid address family translation, if possible.",
      "ja": "サーバーを動作させる場合、それは、インターネット上でのIPv4リスナー、IPv6のリスナー、またはその両方を望んでいる場合は、PCPクライアントが知っている（セクション10.1と10.2を参照）。それはそのインターフェイスのいずれかに設定されたIPv4アドレスまたはIPv6アドレスを持っている場合PCPクライアントも知っています。それは、そのPCPサーバのどの要求を送信することを決定するために、この知識の和集合をとる（例えば、IPv4アドレスまたはIPv6アドレス）場合、例えばそのインターフェイス（のそれぞれのための1つまたは2つのMAPリクエストを送信する、とするかどうかPCPクライアントはIPv4アドレスのみを持っていますが、IPv6とIPv4の両方のリスナーを望んでいる、それが推奨外部アドレスフィールドにすべてゼロのIPv6アドレスを含むMAPリクエストを送信し、推奨ですべてゼロのIPv4アドレスを含む第二のMAPリクエストを送信します外部アドレスフィールド）。 PCPクライアントはIPv4とIPv6の両方のアドレスを持っている、とIPv4のみのリスナーを望んでいる場合（またはそのIPv6アドレスから1つのMAP要求（PCPサーバは、NAT44またはIPv4ファイアウォールをサポートしている場合）、それは、そのIPv4アドレスから1つのMAPリクエストを送信しますPCPサーバは）NAT64をサポートしています。 PCPクライアントは単にPCPサーバが必要なマッピングをサポートしているかどうかを判断するために必要なマッピングを要求することができます。可能であれば、ペイロードにIPアドレスを埋め込むアプリケーション（例えば、FTP、SIP）は、アドレスファミリの翻訳を回避することが有益でしょう。"
    },
    {
      "indent": 3,
      "text": "The MAP and PEER requests include a Suggested External IP Address field. Some PCP-controlled devices, especially CGN but also multi-homed NPTv6 networks, have a pool of public-facing IP addresses. PCP allows the client to indicate if it wants a mapping assigned on a specific address of that pool or any address of that pool. Some applications will break if mappings are created on different IP addresses (e.g., active mode FTP), so applications should carefully consider the implications of using this capability. Static mappings for that internal address (e.g., those created by a command-line interface on the PCP server or PCP-controlled device) may exist to a certain external address, and if the suggested external IP address is the IPv4 or IPv6 all-zeros address, PCP SHOULD assign its mappings to the same external address, as this can also help applications using a mix of both static mappings and PCP-created mappings. If, on the other hand, the suggested external IP address contains a non-zero IP address the PCP server SHOULD create a mapping to that external address, even if there are other mappings from that same internal address to a different external address. Once an internal address has no implicit dynamic mappings and no explicit dynamic mappings in the PCP-controlled device, a subsequent implicit or explicit mapping for that internal address MAY be assigned to a different External address. Generally, this reassignment would occur when a CGN device is load balancing newly seen internal addresses to its public pool of external addresses.",
      "ja": "MAPとPEERリクエストは推奨外部IPアドレスフィールドを含みます。いくつかのPCP制御デバイス、特にCGNだけでなく、マルチホームNPTv6ネットワークは、公衆向けのIPアドレスのプールを持っています。 PCPは、それがそのプールの特定のアドレスまたはそのプールの任意のアドレスに割り当てられたマッピングを望んでいる場合、クライアントは示すことができます。マッピングが異なるIPアドレス（例えば、アクティブモードFTP）上で作成されている場合、一部のアプリケーションが中断しますので、アプリケーションは慎重にこの機能を使用することの影響を考慮すべきです。全ゼロその内部アドレス（例えば、PCPサーバ又はPCP制御デバイス上のコマンドラインインタフェースによって作成されたもの）のための静的マッピングは、特定の外部アドレスに存在することができる、と示唆した外部IPアドレスは、IPv4またはIPv6である場合これはまた、静的マッピングとPCP-作成したマッピングの両方のミックスを使用してアプリケーションを助けることができるように、アドレス、PCPは、同じ外部アドレスへのマッピングを割り当てる必要があります。一方、提案された外部IPアドレスが非ゼロのIPアドレスが含まれている場合はPCPサーバは、異なる外部アドレスに、同じ内部アドレスから他のマッピングがあっても、その外部アドレスへのマッピングを作成する必要があります。内部アドレスがPCP-制御装置には、暗黙的な動的マッピングと明示的な動的なマッピングを持っていないと、その内部アドレスに対する後続の暗黙的または明示的なマッピングは、異なる外部アドレスに割り当てられてもよいです。 CGNデバイスは、外部アドレスのその公共プールに新しく見える内部アドレスをロードバランシングする場合、一般的に、この再割り当てが発生します。"
    },
    {
      "indent": 3,
      "text": "The following table summarizes how various common PCP deployments use IPv6 and IPv4 addresses.",
      "ja": "様々な一般的なPCPの展開は、IPv6とIPv4アドレスを使用する方法を次の表に、まとめたものです。"
    },
    {
      "indent": 3,
      "text": "The 'internal' address is implicitly the same as the source IP address of the PCP request, except when the THIRD_PARTY option is used.",
      "ja": "「内部」アドレスはTHIRD_PARTYオプションが使用されている場合を除き、暗黙的にPCP要求の送信元IPアドレスと同じです。"
    },
    {
      "indent": 3,
      "text": "The 'external' address is the Suggested External Address field of the MAP or PEER request, and its address family is usually the same as the 'internal' address family, except when technologies like NAT64 are used.",
      "ja": "「外部」アドレスはMAPまたはPEERリクエストの推奨外部アドレスフィールドであり、そのアドレスファミリはNAT64などの技術が使用されている場合を除き、通常は「内部」アドレスファミリと同じです。"
    },
    {
      "indent": 3,
      "text": "The 'remote peer' address is the remote peer IP address of the PEER request or the FILTER option of the MAP request, and is always the same address family as the 'internal' address, even when NAT64 is used. In NAT64, the IPv6 PCP client is not necessarily aware of the NAT64 or aware of the actual IPv4 address of the remote peer, so it expresses the IPv6 address from its perspective, as shown in Figure 5.",
      "ja": "「リモートピアのアドレスは、NAT64を使用した場合であっても、PEER要求またはMAP要求のFILTERオプションのリモートピアのIPアドレスであり、常に「内部」アドレスと同じアドレスファミリです。 NAT64では、IPv6のPCPクライアントは必ずしもNAT64の認識またはリモートピアの実際のIPv4アドレスを認識していないので、図5に示すような、その観点からIPv6アドレスを表します。"
    },
    {
      "indent": 3,
      "text": "              internal  external  PCP remote peer  actual remote peer\n              --------  -------   ---------------  ------------------\nIPv4 firewall   IPv4      IPv4         IPv4              IPv4\nIPv6 firewall   IPv6      IPv6         IPv6              IPv6\n        NAT44   IPv4      IPv4         IPv4              IPv4\n        NAT46   IPv4      IPv6         IPv4              IPv6\n        NAT64   IPv6      IPv4         IPv6              IPv4\n        NPTv6   IPv6      IPv6         IPv6              IPv6",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 5: Address Families with MAP and PEER",
      "ja": "図5：MAPとピアとのアドレスファミリー"
    },
    {
      "indent": 3,
      "text": "Note that the internal address and the remote peer address are always the same address family, and the external address and the actual remote peer address are always the same address family.",
      "ja": "内部アドレスとリモートピアアドレスは常に同じアドレスファミリであり、外部アドレスと実際のリモートピアアドレスは常に同じアドレスファミリであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "10.1. For Operating a Server",
      "section_title": true,
      "ja": "10.1. サーバーを動作させるために"
    },
    {
      "indent": 3,
      "text": "A host operating a server (e.g., a web server) listens for traffic on a port, but the server never initiates traffic from that port. For this to work across a NAT or a firewall, the host needs to (a) create a mapping from a public IP address, protocol, and port to itself using the MAP Opcode, as described in Section 11; (b) publish that public IP address, protocol, and port via some sort of rendezvous server (e.g., DNS, a SIP message, or a proprietary protocol); and (c) ensure that any other non-PCP-speaking packet filtering middleboxes on the path (e.g., host-based firewall, network-based firewall, or other NATs) will also allow the incoming traffic. Publishing the public IP address and port is out of scope of this specification. To accomplish (a), the host follows the procedures described in this section.",
      "ja": "サーバーを動作させるホストが（例えば、Webサーバ）ポート上のトラフィックをリッスンしますが、サーバーは、そのポートからのトラフィックを開始することはありません。これはNATまたはファイアウォールを越えて機能するために、ホストはセクション11で説明したように（A）、MAPオペコードを使用して自身のパブリックIPアドレス、プロトコル、およびポートのマッピングを作成する必要があります。 （b）は、ランデブーサーバ（例えば、DNS、SIPメッセージ、または独自のプロトコル）のいくつかの並べ替えを介して、そのパブリックIPアドレス、プロトコル、およびポートを公開します。および（c）パス上の任意の他の非PCP圏パケットフィルタリング中間装置（例えば、ホストベースのファイアウォール、ネットワークベースのファイアウォール、または他のNAT）は、着信トラフィックを許可することを保証します。パブリックIPアドレスとポートを公開することは、この仕様書の範囲外です。 （A）を達成するために、ホストは、このセクションで説明する手順に従います。"
    },
    {
      "indent": 3,
      "text": "As normal, the application needs to begin listening on a port. Then, the application constructs a PCP message with the MAP Opcode, with the external address set to the appropriate all-zeros address, depending on whether it wants a public IPv4 or IPv6 address.",
      "ja": "通常のように、アプリケーションでは、ポートでリスニングを開始する必要があります。次いで、アプリケーションは、それがパブリックIPv4またはIPv6アドレスを望んでいるかどうかに応じて、適切なすべてゼロのアドレスに設定外部アドレスと、MAPオペコードとPCPメッセージを構築します。"
    },
    {
      "indent": 3,
      "text": "The following pseudocode shows how PCP can be reliably used to operate a server:",
      "ja": "次の擬似コードは、PCPが確実にサーバーを動作させるために使用することができる方法を示しています。"
    },
    {
      "indent": 4,
      "text": "/* start listening on the local server port */\nint s = socket(...);\nbind(s, ...);\nlisten(s, ...);",
      "raw": true
    },
    {
      "indent": 4,
      "text": "getsockname(s, &internal_sockaddr, ...);\nbzero(&external_sockaddr, sizeof(external_sockaddr));",
      "raw": true
    },
    {
      "indent": 4,
      "text": "while (1)\n    {\n    /* Note: The \"time_to_send_pcp_request()\" check below includes:\n     * 1. Sending the first request\n     * 2. Retransmitting requests due to packet loss\n     * 3. Resending a request due to impending lease expiration\n     * 4. Resending a request due to server state loss\n     * The PCP packet sent is identical in all four cases; from\n     * the PCP server's point of view they are the same operation.\n     * The suggested external address and port may be updated\n     * repeatedly during the lifetime of the mapping.\n     * Other fields in the packet generally remain unchanged.\n     */\n    if (time_to_send_pcp_request())\n        pcp_send_map_request(internal_sockaddr.sin_port,\n            internal_sockaddr.sin_addr,\n            &external_sockaddr, /* will be zero the first time */\n            requested_lifetime, &assigned_lifetime);",
      "raw": true
    },
    {
      "indent": 8,
      "text": "if (pcp_response_received())\n    update_rendezvous_server(\"Client Ident\", external_sockaddr);",
      "raw": true
    },
    {
      "indent": 8,
      "text": "if (received_incoming_connection_or_packet()) process_it(s);",
      "ja": "IF（received_incoming_connection_or_packet（））process_it（S）;"
    },
    {
      "indent": 8,
      "text": "if (other_work_to_do()) do_it();",
      "ja": "IF（other_work_to_do（））do_it（）;"
    },
    {
      "indent": 8,
      "text": "/* ... */",
      "raw": true
    },
    {
      "indent": 8,
      "text": "block_until_we_need_to_do_something_else(); }",
      "ja": "block_until_we_need_to_do_something_else（）; }"
    },
    {
      "indent": 10,
      "text": "Figure 6: Pseudocode for Using PCP to Operate a Server",
      "ja": "図6：サーバを動作させるためにPCPを使用するための擬似コード"
    },
    {
      "indent": 0,
      "text": "10.2. For Operating a Symmetric Client/Server",
      "section_title": true,
      "ja": "10.2. 対称型クライアント/サーバを動作させるために"
    },
    {
      "indent": 3,
      "text": "A host operating a client and server on the same port (e.g., Symmetric RTP [RFC4961] or SIP Symmetric Response Routing (rport) [RFC3581]) first establishes a local listener, (usually) sends the local and public IP addresses, protocol, and ports to a rendezvous service (which is out of scope of this document), and initiates an outbound connection from that same source address and same port. To accomplish this, the application uses the procedure described in this section.",
      "ja": "同じポート（例えば、対称RTP [RFC4961]またはSIP対称応答ルーティング（RPORT）[RFC3581]）が最初にローカルリスナーを確立し、（通常は）上のクライアントとサーバを動作させるホストは、プロトコル、ローカルおよびパブリックIPアドレスを送信し、 （この文書の範囲外である）ランデブサービスのポート、およびその同一の送信元アドレスと同一のポートからの発信接続を開始します。これを実現するために、アプリケーションは、この項で説明する手順を使用しています。"
    },
    {
      "indent": 3,
      "text": "An application that is using the same port for outgoing connections as well as incoming connections MUST first signal its operation of a server using the PCP MAP Opcode, as described in Section 11, and receive a positive PCP response before it sends any packets from that port.",
      "ja": "そのポートから任意のパケットを送信する前に、最初のセクション11で説明したように、PCP MAPオペコードを使用して、サーバーの動作を信号および肯定PCP応答を受信しなければならない送信接続ならびに着信接続のために同じポートを使用しているアプリケーション。"
    },
    {
      "indent": 6,
      "text": "Discussion: In general, a PCP client doesn't know in advance if it is behind a NAT or firewall. On detecting that the host has connected to a new network, the PCP client can attempt to request a mapping using PCP; if that succeeds, then the client knows it has successfully created a mapping. If, after multiple retries, it has received no PCP response, then either the client is *not* behind a NAT or firewall and has unfettered connectivity or the client *is* behind a NAT or firewall that doesn't support PCP (and the client may still have working connectivity by virtue of static mappings previously created manually by the user). Retransmitting PCP requests multiple times before giving up and assuming unfettered connectivity adds delay in that case. Initiating outbound TCP connections immediately without waiting for PCP avoids this delay, and will work if the NAT has endpoint-independent mapping (EIM) behavior, but may fail if the NAT has endpoint-dependent mapping (EDM) behavior. Waiting enough time to allow an explicit PCP MAP mapping to be created (if possible) first ensures that the same external port will then be used for all subsequent implicit dynamic mappings (e.g., TCP SYNs) sent from the specified internal address, protocol, and port. PCP supports both EIM and EDM NATs, so clients need to assume they may be dealing with an EDM NAT. In this case, the client will experience more reliable connectivity if it attempts explicit PCP MAP requests first, before initiating any outbound TCP connections from that internal address and port. For further information on using PCP with EDM NATs, see Section 16.1.",
      "ja": "ディスカッション：それはNATやファイアウォールの背後にある場合、一般的には、PCPクライアントが事前に分かっていません。ホストが新しいネットワークに接続されたことを検出すると、PCPクライアントは、PCPを使用してマッピングを要求することを試みることができます。それが成功した場合、クライアントはそれがマッピングの作成に成功したことを知ります。 、複数の再試行の後に、それは、何のPCP応答を受信しなかった場合は、クライアントのいずれかである*ない* NATやファイアウォールと後ろの自由な接続やクライアントを持っている*（およびPCPをサポートしていないNATやファイアウォールの背後にあります*クライアントは、以前にユーザーが手動で作成された静的マッピング）のおかげで、作業の接続を有することができます。 PCPはあきらめと自由な接続を想定して前に複数回を要求再送信すると、その場合の遅延が追加されます。 PCPを待たずに、すぐにアウトバウンドTCP接続を開始すると、この遅延を回避し、NATがエンドポイント非依存のマッピング（EIM）の挙動を持っている場合は動作しますが、NATがエンドポイントに依存マッピング（EDM）の挙動を持っている場合は失敗することがあります。指定された内部アドレス、プロトコルから送信された（可能な場合）最初の同一の外部ポートは、その後、後続のすべての暗黙のダイナミックマッピング（例えば、TCP SYNの）ために使用されることを保証する明示的なPCPのMAPマッピングが作成できるようにするのに十分な時間を待っていると、港。クライアントは、彼らがEDM NATに対処することができると想定する必要があるので、PCPは、EIMとEDM NATの両方をサポートしています。それはその内部アドレスとポートから任意の発信TCP接続を開始する前に、最初の明示的なPCPのMAP要求をしようとした場合この場合、クライアントは、より信頼性の高い接続を経験します。 EDM NATを持つPCPを使用しての詳細については、16.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "The following pseudocode shows how PCP can be used to operate a symmetric client and server:",
      "ja": "次の擬似コードは、PCPが対称クライアントとサーバを動作させるために使用することができる方法を示しています。"
    },
    {
      "indent": 4,
      "text": "/* start listening on the local server port */\nint s = socket(...);\nbind(s, ...);\nlisten(s, ...);",
      "raw": true
    },
    {
      "indent": 4,
      "text": "getsockname(s, &internal_sockaddr, ...);\nbzero(&external_sockaddr, sizeof(external_sockaddr));",
      "raw": true
    },
    {
      "indent": 4,
      "text": "while (1)\n    {\n    /* Note: The \"time_to_send_pcp_request()\" check below includes:\n     * 1. Sending the first request\n     * 2. Retransmitting requests due to packet loss\n     * 3. Resending a request due to impending lease expiration\n     * 4. Resending a request due to server state loss\n     */\n    if (time_to_send_pcp_request())\n        pcp_send_map_request(internal_sockaddr.sin_port,\n            internal_sockaddr.sin_addr,\n            &external_sockaddr, /* will be zero the first time */\n            requested_lifetime, &assigned_lifetime);",
      "raw": true
    },
    {
      "indent": 8,
      "text": "if (pcp_response_received())\n    update_rendezvous_server(\"Client Ident\", external_sockaddr);",
      "raw": true
    },
    {
      "indent": 8,
      "text": "if (received_incoming_connection_or_packet()) process_it(s);",
      "ja": "IF（received_incoming_connection_or_packet（））process_it（S）;"
    },
    {
      "indent": 8,
      "text": "if (need_to_make_outgoing_connection()) make_outgoing_connection(s, ...);",
      "ja": "もし（need_to_make_outgoing_connection（））make_outgoing_connection（S、...）;"
    },
    {
      "indent": 8,
      "text": "if (data_to_send()) send_it(s);",
      "ja": "IF（data_to_send（））send_it（S）;"
    },
    {
      "indent": 8,
      "text": "if (other_work_to_do()) do_it();",
      "ja": "IF（other_work_to_do（））do_it（）;"
    },
    {
      "indent": 8,
      "text": "/* ... */",
      "raw": true
    },
    {
      "indent": 8,
      "text": "block_until_we_need_to_do_something_else(); }",
      "ja": "block_until_we_need_to_do_something_else（）; }"
    },
    {
      "indent": 14,
      "text": "Figure 7: Pseudocode for Using PCP to Operate a\n            Symmetric Client/Server",
      "raw": true
    },
    {
      "indent": 0,
      "text": "10.3. For Reducing NAT or Firewall Keepalive Messages",
      "section_title": true,
      "ja": "10.3.  NATやファイアウォールのキープアライブメッセージを減少させるための"
    },
    {
      "indent": 3,
      "text": "A host operating a client (e.g., XMPP client, SIP client) sends from a port, and may receive responses, but never accepts incoming connections from other remote peers on this port. It wants to ensure that the flow to its remote peer is not terminated (due to inactivity) by an on-path NAT or firewall. To accomplish this, the application uses the procedure described in this section.",
      "ja": "クライアント（例えば、XMPPクライアント、SIPクライアント）を動作させるホストがポートから送信し、応答を受け取ることができるが、このポート上の他のリモートピアからの着信接続を受け入れることはありません。それは、そのリモートピアへの流れは、オンパスNATやファイアウォールで（非アクティブのために）終了されていないことを確認したいです。これを実現するために、アプリケーションは、この項で説明する手順を使用しています。"
    },
    {
      "indent": 3,
      "text": "Middleboxes, such as NATs or firewalls, generally need to see occasional traffic or they will terminate their session state, causing application failures. To avoid this, many applications routinely generate keepalive traffic for the primary (or sole) purpose of maintaining state with such middleboxes. Applications can reduce such application keepalive traffic by using PCP.",
      "ja": "そのようなNATのやファイアウォールなどのMiddleboxesは、一般的に時折トラフィックを確認する必要があるか、彼らがアプリケーションの障害を引き起こし、そのセッション状態を終了します。これを避けるために、多くのアプリケーションは、日常的なミドルボックスで状態を維持する主要な（または唯一の）目的のためにキープアライブトラフィックを生成します。アプリケーションは、PCPを使用して、アプリケーションキープアライブトラフィックを削減することができます。"
    },
    {
      "indent": 6,
      "text": "Note: For reasons beyond NAT, an application may find it useful to perform application-level keepalives, such as to detect a broken path between the client and server, keep state alive on the remote peer, or detect a powered-down client. These keepalives are not related to maintaining middlebox state, and PCP cannot do anything useful to reduce those keepalives.",
      "ja": "注：NAT越えた理由により、アプリケーションは、それが有用例えば、クライアントとサーバとの間壊れたパスを検出し、リモートピアにアライブ状態を維持し、またはパワーダウンのクライアントを検出するアプリケーションレベルのキープアライブを実行するかもしれません。これらのキープアライブは、ミドル状態を維持することに関連していない、とPCPは、これらのキープアライブを軽減するのに有益な何かを行うことはできません。"
    },
    {
      "indent": 3,
      "text": "To use PCP for this function, the application first connects to its server, as normal. Afterwards, it issues a PCP request with the PEER Opcode as described in Section 12 to learn and/or extend the lifetime of its mapping.",
      "ja": "この機能のためにPCPを使用するには、アプリケーションが最初に通常通り、そのサーバーに接続します。学ぶおよび/またはそのマッピングの寿命を延ばすために、セクション12で説明したようにその後、それはPEERのオペコードとPCP要求を発行します。"
    },
    {
      "indent": 3,
      "text": "The following pseudocode shows how PCP can be reliably used with a dynamic socket, for the purposes of reducing application keepalive messages:",
      "ja": "次の擬似コードは、PCPが確実にアプリケーションキープアライブメッセージを削減する目的で、ダイナミックなソケットで使用することができる方法を示しています。"
    },
    {
      "indent": 4,
      "text": "/* make outgoing connection to server */\nint s = socket(...);\nconnect(s, &remote_peer, ...);",
      "raw": true
    },
    {
      "indent": 4,
      "text": "getsockname(s, &internal_sockaddr, ...);\nbzero(&external_sockaddr, sizeof(external_sockaddr));",
      "raw": true
    },
    {
      "indent": 4,
      "text": "while (1)\n    {\n    /* Note: The \"time_to_send_pcp_request()\" check below includes:\n     * 1. Sending the first request\n     * 2. Retransmitting requests due to packet loss\n     * 3. Resending a request due to impending lease expiration\n     * 4. Resending a request due to server state loss\n     */\n    if (time_to_send_pcp_request())\n        pcp_send_peer_request(internal_sockaddr.sin_port,\n            internal_sockaddr.sin_addr,\n            &external_sockaddr, /* will be zero the first time */\n            remote_peer, requested_lifetime, &assigned_lifetime);",
      "raw": true
    },
    {
      "indent": 8,
      "text": "if (data_to_send())\n    send_it(s);",
      "raw": true
    },
    {
      "indent": 8,
      "text": "if (received_incoming_data()) process_it(s);",
      "ja": "IF（received_incoming_data（））process_it（S）;"
    },
    {
      "indent": 8,
      "text": "if (other_work_to_do()) do_it();",
      "ja": "IF（other_work_to_do（））do_it（）;"
    },
    {
      "indent": 8,
      "text": "/* ... */",
      "raw": true
    },
    {
      "indent": 8,
      "text": "block_until_we_need_to_do_something_else(); }",
      "ja": "block_until_we_need_to_do_something_else（）; }"
    },
    {
      "indent": 11,
      "text": "Figure 8: Pseudocode Using PCP with a Dynamic Socket",
      "ja": "図8：動的ソケットとの擬似コードの使用PCP"
    },
    {
      "indent": 0,
      "text": "10.4. For Restoring Lost Implicit TCP Dynamic Mapping State",
      "section_title": true,
      "ja": "10.4. 失われた暗黙のTCP動的マッピングの状態を復元します"
    },
    {
      "indent": 3,
      "text": "After a NAT loses state (e.g., because of a crash or power failure), it is useful for clients to re-establish TCP mappings on the NAT. This allows servers on the Internet to see traffic from the same IP address and port, so that sessions can be resumed exactly where they were left off. This can be useful for long-lived connections (e.g., instant messaging) or for connections transferring a lot of data (e.g., FTP). This can be accomplished by first establishing a TCP connection normally and then sending a PEER request/response and remembering the external address and external port. Later, when the NAT has lost state, the client can send a PEER request with the suggested external port and suggested external address remembered from the previous session, which will create a mapping in the NAT that functions exactly as an implicit dynamic mapping. The client then resumes sending TCP data to the server.",
      "ja": "NATは、（理由はクラッシュや停電の、例えば）状態を失った後、クライアントがNATにTCPマッピングを再確立するために、それは便利です。これは、セッションは、彼らがオフに残っていた場所を正確に再開することができるように、インターネット上のサーバは、同じIPアドレスとポートからのトラフィックを確認することができます。これは、長寿命の接続（例えば、インスタントメッセージング）、または大量のデータ（例えば、FTP）を転送接続するのに便利です。これは、最初の通常のTCPコネクションを確立して、PEER要求/応答を送信し、外部アドレスと外部ポートを覚えることによって達成することができます。 NATは、状態を失ったとき、後で、クライアントが提案され、外部ポートでPEERリクエストを送信し、正確に暗黙の動的マッピングとして機能NATにマッピングを作成する前のセッションから覚えて外部アドレスを、提案することができます。次に、クライアントは、サーバーへのTCPデータの送信を再開します。"
    },
    {
      "indent": 6,
      "text": "Note: This procedure works well for TCP, provided:",
      "ja": "注意：この手順では、TCPのためにも提供作品："
    },
    {
      "indent": 9,
      "text": "(i) the NAT creates a new implicit dynamic outbound mapping only for outbound TCP segments with the SYN bit set (i.e., the newly booted NAT silently drops outbound data segments from the client when the NAT does not have an active mapping for those segments), and",
      "ja": "（I）NATは、（NATは、これらのセグメントのためのアクティブ・マッピングを持たない場合、すなわち、新たに起動されNATは静かに、クライアントからのアウトバウンドデータセグメントをドロップ）のみSYNビットがセットされたアウトバウンドTCPセグメントのための新たな暗黙の動的なアウトバウンドマッピングを作成します、および"
    },
    {
      "indent": 9,
      "text": "(ii) the newly booted NAT does not send a TCP RST in response to receiving unexpected inbound TCP segments.",
      "ja": "（ⅱ）新たに起動されNATは、予想外のインバウンドTCPセグメントを受信することに応答してTCP RSTを送信しません。"
    },
    {
      "indent": 6,
      "text": "This procedure works less well for UDP, because as soon as outbound UDP traffic is seen by the NAT, a new UDP implicit dynamic outbound mapping will be created (probably on a different port).",
      "ja": "すぐにアウトバウンドUDPトラフィックがNATで見られるように、新しいUDP暗黙の動的なアウトバウンド・マッピングが（おそらく別のポートに）作成されるため、この手順では、UDPのためにあまり適しています。"
    },
    {
      "indent": 0,
      "text": "11. MAP Opcode",
      "section_title": true,
      "ja": "11. MAPオペコード"
    },
    {
      "indent": 3,
      "text": "This section defines an Opcode that controls inbound forwarding from a NAT (or firewall) to an internal host.",
      "ja": "このセクションでは、内部ホストにNAT（またはファイアウォール）からの着信転送を制御するオペコードを定義します。"
    },
    {
      "indent": 3,
      "text": "MAP: Create an explicit dynamic mapping between an Internal Address + Port and an External Address + Port.",
      "ja": "MAP：内部アドレス+ポートと外部アドレス+ポート間の明示的な動的マッピングを作成します。"
    },
    {
      "indent": 3,
      "text": "PCP servers SHOULD provide a configuration option to allow administrators to disable MAP support if they wish.",
      "ja": "PCPサーバは、彼らが希望する場合、管理者はMAPのサポートを無効にすることを可能にする設定オプションを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Mappings created by PCP MAP requests are, by definition, endpoint-independent mappings (EIMs) with endpoint-independent filtering (EIF) (unless the FILTER option is used), even on a NAT that usually creates endpoint-dependent mapping (EDM) or endpoint-dependent filtering (EDF) for outgoing connections, since the purpose of an (unfiltered) MAP mapping is to receive inbound traffic from any remote endpoint, not from only one specific remote endpoint.",
      "ja": "でも、通常はエンドポイントに依存マッピングを作成するNAT（EDM）上（FILTERオプションが使用されていない場合）エンドポイントから独立したフィルタリング（EIF）とPCPのMAP要求され、定義によって、エンドポイント非依存のマッピング（EIMS）によって作成されたマッピング、または発信接続のエンドポイントに依存するフィルタ（EDF）、（フィルタリングされていない）MAPマッピングの目的は、リモートエンドポイントからだけでなく、ある特定のリモートエンドポイントからのインバウンドトラフィックを受信するからです。"
    },
    {
      "indent": 3,
      "text": "Note also that all NAT mappings (created by PCP or otherwise) are by necessity bidirectional and symmetric. For any packet going in one direction (in or out) that is translated by the NAT, a reply going in the opposite direction needs to have the corresponding opposite translation done so that the reply arrives at the right endpoint. This means that if a client creates a MAP mapping, and then later sends an outgoing packet using the mapping's internal address, protocol, and port, the NAT should translate that packet's internal address and port to the mapping's external address and port, so that replies addressed to the external address and port are correctly translated back to the mapping's internal address and port.",
      "ja": "注また、（PCPによって、あるいは作成された）すべてのNATマッピングが必要双方向対称であること。 NATで変換される、1つの方向（inまたはout）に行くすべてのパケットについて、反対方向に行くの回答が返信は右の終点に到着するように、対応する逆の翻訳が行われている必要があります。回答ように、これは、クライアントがMAPのマッピングを作成し、後でマッピングの内部アドレス、プロトコル、およびポートを使用して発信パケットを送信する場合、NATは、マッピングの外部アドレスとポートへのパケットの内部アドレスとポートを変換する必要があることを意味し外部アドレスとポート宛が正しくマッピングの内部アドレスとポートに戻って変換されます。"
    },
    {
      "indent": 3,
      "text": "On operating systems that allow multiple listening servers to bind to the same internal address, protocol, and port, servers MUST ensure that they have exclusive use of that internal address, protocol, and port (e.g., by binding the port using INADDR_ANY, or using SO_EXCLUSIVEADDRUSE or similar) before sending their PCP MAP request, to ensure that no other PCP clients on the same machine are also listening on the same internal protocol and internal port.",
      "ja": "複数のリスニングサーバが同一の内部アドレス、プロトコル、およびポートに結合することを可能にするオペレーティングシステムでは、サーバは、INADDR_ANYを使用してポートをバインド、または使用することによって、彼らは、例えばその内部アドレス、プロトコル、およびポート（の排他的使用を持っていることを保証しなければなりません同じマシン上の他のPCPのクライアントも同じ内部プロトコルと内部ポートでリッスンしていないことを確認するために彼らのPCPのMAP要求を、送信する前にSO_EXCLUSIVEADDRUSEまたは類似）。"
    },
    {
      "indent": 3,
      "text": "As a side effect of creating a mapping, ICMP messages associated with the mapping MUST be forwarded (and also translated, if appropriate) for the duration of the mapping's lifetime. This is done to ensure that ICMP messages can still be used by hosts, without application programmers or PCP client implementations needing to use PCP separately to create ICMP mappings for those flows.",
      "ja": "マッピングの生涯の期間のマッピングを作成する副作用として、マッピングに関連付けられたICMPメッセージが転送されなければならない（また、適切であれば、翻訳されます）。これは、ICMPメッセージはまだアプリケーションプログラマまたはこれらのフローのためのICMPのマッピングを作成するには、別途PCPを使用する必要PCPクライアント実装せずに、ホストが使用できることを保証するために行われます。"
    },
    {
      "indent": 3,
      "text": "The operation of the MAP Opcode is described in this section.",
      "ja": "MAPオペコードの操作は、このセクションに記載されています。"
    },
    {
      "indent": 0,
      "text": "11.1. MAP Operation Packet Formats",
      "section_title": true,
      "ja": "11.1.  MAP操作パケット形式"
    },
    {
      "indent": 3,
      "text": "The MAP Opcode has a similar packet layout for both requests and responses. If the assigned external IP address and port in the PCP response always match the internal IP address and port from the PCP request, then the functionality is purely a firewall; otherwise, the functionality is a Network Address Translator that might also perform firewall-like functions.",
      "ja": "MAPオペコードは、要求と応答の両方で同様のパケットレイアウトを持っています。 PCP応答で割り当てられた外部IPアドレスとポートは常にPCP要求から内部IPアドレスとポートと一致した場合、機能が純粋にファイアウォールです。そうでない場合、機能は、ファイアウォールのような機能を実行する可能性があるネットワークアドレス変換です。"
    },
    {
      "indent": 3,
      "text": "The following diagram shows the format of the Opcode-specific information in a request for the MAP Opcode.",
      "ja": "次の図は、MAPオペコードの要求にオペコード固有情報のフォーマットを示します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                 Mapping Nonce (96 bits)                       |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Protocol    |          Reserved (24 bits)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Internal Port          |    Suggested External Port    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|           Suggested External IP Address (128 bits)            |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 9: MAP Opcode Request",
      "ja": "図9：MAPオペコードリクエスト"
    },
    {
      "indent": 3,
      "text": "These fields are described below:",
      "ja": "これらのフィールドは以下の通りであります："
    },
    {
      "indent": 3,
      "text": "Requested lifetime (in common header): Requested lifetime of this mapping, in seconds. The value 0 indicates \"delete\".",
      "ja": "（共通ヘッダにおいて）要求された寿命は：秒で、このマッピングの寿命を要求されました。値0は、「削除」を示しています。"
    },
    {
      "indent": 3,
      "text": "Mapping Nonce: Random value chosen by the PCP client. See Section 11.2, \"Generating a MAP Request\". Zero is a legal value (but unlikely, occurring in roughly one in 2^96 requests).",
      "ja": "マッピングナンス：PCPクライアントによって選ばれたランダムな値。 11.2は、「MAP要求の生成」を参照してください。ゼロ（約1 96 ^ 2内の要求で発生するが、そうもない）有効な値です。"
    },
    {
      "indent": 3,
      "text": "Protocol: Upper-layer protocol associated with this Opcode. Values are taken from the IANA protocol registry [proto_numbers]. For example, this field contains 6 (TCP) if the Opcode is intended to create a TCP mapping. This field contains 17 (UDP) if the Opcode is intended to create a UDP mapping. The value 0 has a special meaning for 'all protocols'.",
      "ja": "プロトコル：このオペコードに関連付けられている上位層プロトコル。値はIANAプロトコルレジストリ[proto_numbers]から取得されます。オペコードは、TCPのマッピングを作成するために意図されている場合たとえば、このフィールドには、6（TCP）が含まれています。オペコードは、UDPマッピングを作成するために意図されている場合、このフィールドは、17（UDP）が含まれています。値0は、「すべてのプロトコル」の特別な意味を持っています。"
    },
    {
      "indent": 3,
      "text": "Reserved: 24 reserved bits, MUST be sent as 0 and MUST be ignored when received.",
      "ja": "予約：24個の予約ビットを0として送らなければならなくて、受信時に無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Internal Port: Internal port for the mapping. The value 0 indicates 'all ports', and is legal when the lifetime is zero (a delete request), if the protocol does not use 16-bit port numbers, or the client is requesting 'all ports'. If the protocol is zero (meaning 'all protocols'), then internal port MUST be zero on transmission and MUST be ignored on reception.",
      "ja": "内部ポート：マッピングのための内部ポート。値0は「すべてのポート」を示し、寿命がゼロ（削除要求）である場合、プロトコルは、16ビットのポート番号を使用しない場合、合法であるか、またはクライアントが「すべてのポート」を要求しています。プロトコルはゼロ（「すべてのプロトコル」を意味する）である場合、内部ポートは、送信にゼロでなければならないし、受信時には無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Suggested External Port: Suggested external port for the mapping. This is useful for refreshing a mapping, especially after the PCP server loses state. If the PCP client does not know the external port, or does not have a preference, it MUST use 0.",
      "ja": "マッピングのための推奨外部ポート：外部ポートが示唆されました。これは、PCPサーバが状態を失い、特に後に、マッピングをリフレッシュするのに便利です。 PCPクライアントが外部ポートを知らない、または好みを持っていない場合は、0を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Suggested External IP Address: Suggested external IPv4 or IPv6 address. This is useful for refreshing a mapping, especially after the PCP server loses state. If the PCP client does not know the external address, or does not have a preference, it MUST use the address-family-specific all-zeros address (see Section 5).",
      "ja": "推奨外部IPアドレス：推奨外部のIPv4またはIPv6アドレス。これは、PCPサーバが状態を失い、特に後に、マッピングをリフレッシュするのに便利です。 PCPクライアントが外部アドレスを知らない、または好みを持っていない場合は、アドレスファミリ固有のすべてゼロのアドレスを使用しなければならない（第5節参照）。"
    },
    {
      "indent": 3,
      "text": "The internal address for the request is the source IP address of the PCP request message itself, unless the THIRD_PARTY option is used.",
      "ja": "THIRD_PARTYオプションを使用しない限り、要求のための内部アドレスは、PCP要求メッセージ自体のソースIPアドレスです。"
    },
    {
      "indent": 3,
      "text": "The following diagram shows the format of Opcode-specific information in a response packet for the MAP Opcode:",
      "ja": "次の図は、MAPオペコードの応答パケットにおけるオペコード固有情報のフォーマットを示します。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                 Mapping Nonce (96 bits)                       |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Protocol    |          Reserved (24 bits)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Internal Port          |    Assigned External Port     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|            Assigned External IP Address (128 bits)            |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 10: MAP Opcode Response",
      "ja": "図10：MAPオペコードレスポンス"
    },
    {
      "indent": 3,
      "text": "These fields are described below:",
      "ja": "これらのフィールドは以下の通りであります："
    },
    {
      "indent": 3,
      "text": "Lifetime (in common header): On an error response, this indicates how long clients should assume they'll get the same error response from the PCP server if they repeat the same request. On a success response, this indicates the lifetime for this mapping, in seconds.",
      "ja": "（共通ヘッダー内の）寿命は：エラー応答では、これは長い間、クライアントは、彼らが同じ要求を繰り返す場合、彼らはPCPサーバから同じエラーレスポンスを得るでしょう仮定するべきかを示します。成功応答では、これは秒単位で、このマッピングの寿命を示しています。"
    },
    {
      "indent": 3,
      "text": "Mapping Nonce: Copied from the request.",
      "ja": "マッピングナンス：リクエストからコピーされます。"
    },
    {
      "indent": 3,
      "text": "Protocol: Copied from the request.",
      "ja": "プロトコル：リクエストからコピーされます。"
    },
    {
      "indent": 3,
      "text": "Reserved: 24 reserved bits, MUST be sent as 0 and MUST be ignored when received.",
      "ja": "予約：24個の予約ビットを0として送らなければならなくて、受信時に無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Internal Port: Copied from the request.",
      "ja": "内部ポート：リクエストからコピーされます。"
    },
    {
      "indent": 3,
      "text": "Assigned External Port: On a success response, this is the assigned external port for the mapping. On an error response, the suggested external port is copied from the request.",
      "ja": "割り当てられた外部ポート：成功応答で、これは、マッピングのために割り当てられた外部ポートです。エラー応答では、提案された外部ポートは、リクエストからコピーされます。"
    },
    {
      "indent": 3,
      "text": "Assigned External IP Address: On a success response, this is the assigned external IPv4 or IPv6 address for the mapping. An IPv4 address is encoded using IPv4-mapped IPv6 address. On an error response, the suggested external IP address is copied from the request.",
      "ja": "外部IPアドレスを割り当て：成功応答で、これは、マッピングのために割り当てられた外部IPv4またはIPv6アドレスです。 IPv4アドレスは、IPv4射影IPv6アドレスを使用して符号化されます。エラー応答では、提案された外部IPアドレスが要求からコピーされます。"
    },
    {
      "indent": 0,
      "text": "11.2. Generating a MAP Request",
      "section_title": true,
      "ja": "11.2.  MAP要求の作成"
    },
    {
      "indent": 3,
      "text": "This section describes the operation of a PCP client when sending requests with the MAP Opcode.",
      "ja": "MAPのオペコードとのリクエストを送信する際にこのセクションでは、PCPクライアントの動作を説明します。"
    },
    {
      "indent": 3,
      "text": "The request MAY contain values in the Suggested External Port and Suggested External IP Address fields. This allows the PCP client to attempt to rebuild lost state on the PCP server, which improves the chances of existing connections surviving, and helps the PCP client avoid having to change information maintained at its rendezvous server. Of course, due to other activity on the network (e.g., by other users or network renumbering), the PCP server may not be able to grant the suggested external IP address, protocol, and port, and in that case it will assign a different external IP address and port.",
      "ja": "リクエストは推奨外部ポートの値と推奨の外部IPアドレスフィールドを含むかもしれません。これは、PCPクライアントを存続既存の接続の可能性を向上させPCPサーバ上で失われた状態を再構築しようとすることを可能にし、そのランデブーサーバで維持した情報を変更することPCPクライアントの回避に役立ちます。もちろん、原因ネットワーク上の他のアクティビティに（例えば、他のユーザーまたはリナンバリングネットワークにより）、PCPサーバは、提案された外部IPアドレス、プロトコル、およびポートを付与することができない場合があり、その場合には異なるが割り当てられます外部IPアドレスとポート。"
    },
    {
      "indent": 3,
      "text": "A PCP client MUST be written assuming that it may *never* be assigned the external port it suggests. In the case of recreating state after a NAT gateway crash, the suggested external port, being one that was previously allocated to this client, is likely to be available for this client to continue using. In all other cases, the client MUST assume that it is unlikely that its suggested external port will be granted. For example, when many subscribers are sharing a Carrier-Grade NAT, popular ports such as 80, 443, and 8080 are likely to be in high demand. At most one client can have each of those popular ports for each external IP address, and all the other clients will be assigned other, dynamically allocated, external ports. Indeed, some ISPs may, by policy, choose not to grant those external ports to *anyone*, so that none of their clients are *ever* assigned external ports 80, 443, or 8080.",
      "ja": "PCPクライアントは、* *それが示唆する外部ポートを割り当てることがないことを仮定して書かなければなりません。 NATゲートウェイがクラッシュした後の状態を再現した場合には、提案された外部ポートは、以前にこのクライアントに割り当てられた一つである、使用を継続するには、このクライアントのために利用可能である可能性が高いです。他のすべての例では、クライアントは、その提案、外部ポートが許可されることはありそうにないと仮定しなければなりません。例えば、多くの加入者は、キャリアグレードNATを共有している際に、人気のあるポートは、次のような80、443、および8080は、高い需要がある可能性が高いです。ほとんどの1つのクライアントは、それぞれの外部IPアドレスのため、これらの人気のポートのそれぞれを持つことができ、他のすべてのクライアントは、他の、動的に割り当てられ、外部ポートが割り当てられます。実際、いくつかのISPは、ポリシーによって、彼らのクライアントのいずれも、これまで* *外部ポート80、443、または8080が割り当てられていないように、*誰*にこれらの外部ポートを許可しないこともできます。"
    },
    {
      "indent": 3,
      "text": "If the protocol does not use 16-bit port numbers (e.g., RSVP, IP protocol number 46), the port number MUST be zero. This will cause all traffic matching that protocol to be mapped.",
      "ja": "プロトコルは、16ビットのポート番号（例えば、RSVP、IPプロトコル番号46）を使用していない場合、ポート番号はゼロでなければなりません。これは、そのプロトコルに一致するすべてのトラフィックがマッピングされることになります。"
    },
    {
      "indent": 3,
      "text": "If the client wants all protocols mapped, it uses protocol 0 (zero) and internal port 0 (zero).",
      "ja": "クライアントは、すべてのプロトコルがマッピングされたい場合は、プロトコル0（ゼロ）と内部ポート0（ゼロ）を使用しています。"
    },
    {
      "indent": 3,
      "text": "The Mapping Nonce value is randomly chosen by the PCP client, following accepted practices for generating unguessable random numbers [RFC4086], and is used as part of the validation of PCP responses (see below) by the PCP client, and validation for mapping refreshes by the PCP server. The client MUST use a different mapping nonce for each PCP server it communicates with, and it is RECOMMENDED to choose a new random mapping nonce whenever the PCP client is initialized. The client MAY use a different mapping nonce for every mapping.",
      "ja": "マッピングノンス値をランダムに推測できない乱数を生成するための受け入れられた実践[RFC4086]以下、PCPクライアントによって選択され、PCPの応答の検証の一部として使用されている（下記参照）PCPクライアントによって、及びマッピングの検証は、によってリフレッシュPCPサーバ。クライアントは、それが通信する各PCPサーバ用に異なるマッピングnonceを使用しなければならない、そしてPCPクライアントが初期化されるたびに新しいランダムなマッピングnonceを選択することをお勧めします。クライアントは、すべてのマッピングのために異なるマッピングナンスを使用するかもしれません。"
    },
    {
      "indent": 0,
      "text": "11.2.1. Renewing a Mapping",
      "section_title": true,
      "ja": "11.2.1. マッピングの更新"
    },
    {
      "indent": 3,
      "text": "An existing mapping SHOULD have its lifetime extended by the PCP client for as long as the client wishes to have that mapping continue to exist. To do this, the PCP client sends a new MAP request indicating the internal port. The PCP MAP request SHOULD also include the currently assigned external IP address and port in the Suggested External IP Address and Suggested External Port fields, so if the PCP server has lost state it can recreate the lost mapping with the same parameters.",
      "ja": "既存のマッピングは、その寿命がある限り、クライアントはマッピングが存在し続けることを持っているしたいとのためにPCPクライアントによって拡張持つべきである（SHOULD）。これを行うには、PCPクライアントは、内部ポートを示す新たなMAPリクエストを送信します。 PCPのMAP要求も推奨外部IPアドレスに現在割り当てられている外部IPアドレスとポートを含めると、外部ポートフィールドを推奨するので、PCPサーバは状態を失った場合には、同じパラメータで失われたマッピングを再作成することができすべきです。"
    },
    {
      "indent": 3,
      "text": "The PCP client SHOULD renew the mapping before its expiry time; otherwise, it will be removed by the PCP server (see Section 15, \"Mapping Lifetime and Deletion\"). To reduce the risk of inadvertent synchronization of renewal requests, a random jitter component should be included. It is RECOMMENDED that PCP clients send a single renewal request packet at a time chosen with uniform random distribution in the range 1/2 to 5/8 of expiration time. If no SUCCESS response is received, then the next renewal request should be sent 3/4 to 3/4 + 1/16 to expiration, and then another 7/8 to 7/8 + 1/32 to expiration, and so on, subject to the constraint that renewal requests MUST NOT be sent less than four seconds apart (a PCP client MUST NOT send a flood of ever-closer-together requests in the last few seconds before a mapping expires).",
      "ja": "PCPクライアントは、その有効期限前にマッピングを更新すべきです。それ以外の場合は、PCPサーバによって削除されます（第15、「マッピングの生涯と削除」を参照）。更新要求の不注意同期のリスクを軽減するために、ランダムジッタ成分が含まれなければなりません。 PCPクライアントが有効期限の5/8の範囲の1/2に一様ランダムに分布して選ばれた時に、単一の更新要求パケットを送信することをお勧めします。何SUCCESS応答が受信されない場合は、次の更新要求は、その後、別の7/8満了1/32 + 7/8まで、というように3/4 1/16 + 3/4に期限切れに送られ、そしてべきです更新要求は、（マッピングの有効期限が切れる前にPCPクライアントは、最後の数秒で刻々と近づく-一緒要求の洪水を送ってはいけません）未満4秒間隔で送信しないように制約を受けます。"
    },
    {
      "indent": 0,
      "text": "11.3. Processing a MAP Request",
      "section_title": true,
      "ja": "11.3.  MAP要求の処理"
    },
    {
      "indent": 3,
      "text": "This section describes the operation of a PCP server when processing a request with the MAP Opcode. Processing SHOULD be performed in the order of the following paragraphs.",
      "ja": "MAPのオペコードで要求を処理するときにこのセクションでは、PCPサーバの動作を説明します。処理は、以下の段落の順序で実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Protocol, Internal Port, and Mapping Nonce fields from the MAP request are copied into the MAP response. The THIRD_PARTY option, if present, and processed by the PCP server, is also copied into the MAP response.",
      "ja": "MAP要求からプロトコル、内部ポート、およびマッピングNonceのフィールドは、MAP応答にコピーされます。 THIRD_PARTYオプションは、現在、およびPCPサーバが処理した場合、また、MAP応答にコピーされます。"
    },
    {
      "indent": 3,
      "text": "If the requested lifetime is non-zero, then:",
      "ja": "要求された寿命は、その後、ゼロでない場合："
    },
    {
      "indent": 3,
      "text": "o If both the protocol and internal port are non-zero, it indicates a request to create a mapping or extend the lifetime of an existing mapping. If the PCP server or PCP-controlled device does not support the protocol, the UNSUPP_PROTOCOL error MUST be returned.",
      "ja": "プロトコルおよび内部ポートの両方が非ゼロである場合、Oは、マッピングを作成したり、既存のマッピングの寿命を延長する要求を示します。 PCPサーバまたはPCP-制御機器は、プロトコルをサポートしていない場合は、UNSUPP_PROTOCOLエラーが返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the protocol is non-zero and the internal port is zero, it indicates a request to create or extend a mapping for all incoming traffic for that entire protocol -- a 'wildcard' (all-ports) mapping for that protocol. If this request cannot be fulfilled in its entirety, the UNSUPP_PROTOCOL error MUST be returned.",
      "ja": "プロトコルが非ゼロであり、内部ポートがゼロである場合、Oは、その全体のプロトコルのすべての着信トラフィックのためのマッピングを作成または拡張するための要求を示している - （全ポート）「ワイルドカード」をそのプロトコルのマッピング。この要求は、その全体を満たすことができない場合は、UNSUPP_PROTOCOLエラーが返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If both the protocol and internal port are zero, it indicates a request to create or extend a mapping for all incoming traffic for all protocols (commonly called a 'DMZ host'). If this request cannot be fulfilled in its entirety, the UNSUPP_PROTOCOL error MUST be returned.",
      "ja": "プロトコルおよび内部ポートの両方がゼロである場合、O、それは（一般に「DMZホスト」と呼ばれる）は、すべてのプロトコルのすべての着信トラフィックのためのマッピングを作成または拡張するための要求を示しています。この要求は、その全体を満たすことができない場合は、UNSUPP_PROTOCOLエラーが返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the protocol is zero and the internal port is non-zero, then the request is invalid and the PCP server MUST return a MALFORMED_REQUEST error to the client.",
      "ja": "プロトコルはゼロで、内部ポートが非ゼロの場合、O、リクエストは無効であり、PCPサーバは、クライアントにMALFORMED_REQUESTエラーを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the requested lifetime is zero, it indicates a request to delete an existing mapping.",
      "ja": "要求された寿命がゼロであれば、それは既存のマッピングを削除する要求を示します。"
    },
    {
      "indent": 3,
      "text": "Further processing of the lifetime is described in Section 15, \"Mapping Lifetime and Deletion\".",
      "ja": "寿命の更なる処理部15、「マッピング寿命および削除」に記載されています。"
    },
    {
      "indent": 3,
      "text": "If operating in the Simple Threat Model (Section 18.1), and the internal port, protocol, and internal address match an existing explicit dynamic mapping, but the mapping nonce does not match, the request MUST be rejected with a NOT_AUTHORIZED error with the lifetime of the error indicating duration of that existing mapping. The PCP server only needs to remember one Mapping Nonce value for each explicit dynamic mapping. This specification makes no statement about mapping nonce with the Advanced Threat Model.",
      "ja": "シンプルな脅威モデル（18.1節）で動作し、内部ポート、プロトコル、および内部アドレスが既存の明示的な動的マッピングと一致しますが、マッピングナンスが一致しない場合、要求はの寿命とNOT_AUTHORIZEDエラーで拒否されなければなりませんその既存のマッピングの持続時間を示すエラー。 PCPサーバは、各明示的な動的マッピングのための1つのマッピングNonceの値を覚えておく必要があります。この仕様は、高度な脅威モデルとナンスのマッピングについての声明を行うものではありません。"
    },
    {
      "indent": 3,
      "text": "If the internal port, protocol, and internal address match an existing static mapping (which will have no nonce), then a PCP reply is sent giving the external address and port of that static mapping, using the nonce from the PCP request. The server does not record the nonce.",
      "ja": "内部ポート、プロトコル、及び内部アドレス（何nonceを持たないであろう）は、既存の静的マッピングと一致する場合、PCP応答はPCP要求からナンスを使用して、その静的マッピングの外部アドレス・ポートを与えて送信されます。サーバは、nonceを記録しません。"
    },
    {
      "indent": 3,
      "text": "If an option with value less than 128 exists (i.e., mandatory to process) but that option does not make sense (e.g., the PREFER_FAILURE option is included in a request with lifetime=0), the request is invalid and generates a MALFORMED_OPTION error.",
      "ja": "128未満の値を持つオプションは、（処理する、すなわち必須）が存在するが、そのオプション（例えば、PREFER_FAILUREオプションが寿命= 0の要求に含まれる）意味がない、要求は無効であるとMALFORMED_OPTIONエラーを生成する。場合"
    },
    {
      "indent": 3,
      "text": "If the PCP-controlled device is stateless (that is, it does not establish any per-flow state, and simply rewrites the address and/or port in a purely algorithmic fashion, including no rewriting), the PCP server simply returns an answer indicating the external IP address and port yielded by this stateless algorithmic translation. This allows the PCP client to learn its external IP address and port as seen by remote peers. Examples of stateless translators include stateless NAT64, 1:1 NAT44, and NPTv6 [RFC6296], all of which modify addresses but not port numbers, and pure firewalls, which modify neither the address nor the port.",
      "ja": "PCP制御装置はステートレスである場合、PCPサーバは単に示す回答を返す（つまり、それは任意のフローごとの状態を確立しておらず、単に一切書き換えを含まない、純粋なアルゴリズム方式でアドレスおよび/またはポートを書き換えます）このステートレスなアルゴリズムの翻訳によって得られた外部IPアドレスとポート。これは、リモートピアによって見られるように、PCPのクライアントが外部IPアドレスとポートを学ぶことができます。アドレスではなく、アドレスやポートでもないを変更するポート番号、および純粋なファイアウォールを変更すべてが1 NAT44、およびNPTv6 [RFC6296]、：ステートレス翻訳者の例としては、ステートレスNAT64、1が含まれます。"
    },
    {
      "indent": 3,
      "text": "It is possible that a mapping might already exist for a requested internal address, protocol, and port. If so, the PCP server takes the following actions:",
      "ja": "マッピングは、すでに要求された内部アドレス、プロトコル、およびポートのために存在するかもしれないということも可能です。その場合は、PCPサーバは次の動作を行います。"
    },
    {
      "indent": 3,
      "text": "1. If the MAP request contains the PREFER_FAILURE option, but the suggested external address and port do not match the external address and port of the existing mapping, the PCP server MUST return CANNOT_PROVIDE_EXTERNAL.",
      "ja": "1. MAP要求がPREFER_FAILUREオプションが含まれていますが、提案された外部アドレスとポートは、既存のマッピングの外部アドレスとポートと一致しない場合は、PCPサーバはCANNOT_PROVIDE_EXTERNALを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If the existing mapping is static (created outside of PCP), the PCP server MUST return the external address and port of the existing mapping in its response and SHOULD indicate a lifetime of 2^32-1 seconds, regardless of the suggested external address and port in the request.",
      "ja": "既存のマッピングは、（PCPの外部で作成）静的な場合は、PCPサーバは、その応答で既存のマッピングの外部アドレスとポートを返さなければならないとにかかわらず、提案された外部の、2 ^ 32-1秒の寿命を示すべきである2。要求のアドレスとポート。"
    },
    {
      "indent": 3,
      "text": "3. If the existing mapping is explicit dynamic inbound (created by a previous MAP request), the PCP server MUST return the existing external address and port in its response, regardless of the suggested external address and port in the request. Additionally, the PCP server MUST update the lifetime of the existing mapping, in accordance with Section 15, \"Mapping Lifetime and Deletion\".",
      "ja": "3.既存のマッピングは、（以前のMAP要求によって作成された）明示的な動的なインバウンドの場合は、PCPサーバに関係なく、要求で推奨外部アドレスとポートの、その応答で既存の外部アドレスとポートを返さなければなりません。また、PCPサーバは、セクション15、「マッピングの生涯と削除」に合わせて、既存のマッピングの寿命を更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "4. If the existing mapping is dynamic outbound (created by outgoing traffic or a previous PEER request), the PCP server SHOULD create a new explicit inbound mapping, replicating the ports and addresses from the outbound mapping (but the outbound mapping continues to exist, and remains in effect if the explicit inbound mapping is later deleted).",
      "ja": "4.既存のマッピングは、（送信トラフィックまたは前PEERリクエストによって作成された）動的なアウトバウンドの場合は、PCPサーバはアウトバウンドマッピング（からポートとアドレスを複製し、新しい明示的なインバウンドマッピングを作成する必要がありますが、アウトバウンドマッピングは存在し続け、明示的なインバウンドマッピングが、後に削除された場合と）有効なまま。"
    },
    {
      "indent": 3,
      "text": "If no mapping exists for the internal address, protocol, and port, and the PCP server is able to create a mapping using the suggested external address and port, it SHOULD do so. This is beneficial for re-establishing state lost in the PCP server (e.g., due to a reboot). There are, however, cases where the PCP server is not able to create a new mapping using the suggested external address and port:",
      "ja": "マッピングが内部アドレス、プロトコル、およびポートのために存在しない、とPCPサーバが示唆された外部アドレスとポートを使用してマッピングを作成することが可能である場合、それはそうすべきです。これは（これは再起動するなど、）PCPサーバで失わ再確立状態に有益です。 PCPサーバが示唆された外部アドレスとポートを使用して、新しいマッピングを作成することができない場合は、しかし、があります。"
    },
    {
      "indent": 3,
      "text": "o The suggested external address, protocol, and port is already assigned to another existing explicit or implicit mapping (i.e., is already forwarding traffic to some other internal address and port).",
      "ja": "O提案外部アドレス、プロトコル、およびポートが既に別の既存の明示的または暗黙的なマッピングに割り当てられている（すなわち、既にいくつかの他の内部アドレスおよびポートにトラフィックを転送されます）。"
    },
    {
      "indent": 3,
      "text": "o The suggested external address, protocol, and port is already used by the NAT gateway for one of its own services, for example, TCP port 80 for the NAT gateway's own configuration web pages, or UDP ports 5350 and 5351, used by PCP itself. A PCP server MUST NOT create client mappings for external UDP ports 5350 or 5351.",
      "ja": "提案された外部アドレス、プロトコル、およびPCP単独で使用するNATゲートウェイ自身の設定Webページ、またはUDPポート5350と5351のポートはすでに、独自のサービスのいずれかのためにNATゲートウェイで使用され、例えば、TCPポート80、O 。 PCPサーバは、外部のUDPポート5350または5351のクライアントのマッピングを作成してはいけません。"
    },
    {
      "indent": 3,
      "text": "o The suggested external address, protocol, and port is otherwise prohibited by the PCP server's policy.",
      "ja": "O示唆した外部アドレス、プロトコル、およびポートは、そうでない場合は、PCPサーバのポリシーによって禁止されています。"
    },
    {
      "indent": 3,
      "text": "o The suggested external IP address, protocol, or suggested port are invalid or invalid combinations (e.g., external address 127.0.0.1, ::1, a multicast address, or the suggested port is not valid for the protocol).",
      "ja": "示唆された外部IPアドレス、プロトコル、O、またはポートを提案が無効であるか、無効な組み合わせである（例えば、外部アドレス127.0.0.1、:: 1、マルチキャストアドレス、または推奨ポートプロトコルのために有効ではありません）。"
    },
    {
      "indent": 3,
      "text": "o The suggested external address does not belong to the NAT gateway.",
      "ja": "O示唆した外部アドレスがNATゲートウェイに属していません。"
    },
    {
      "indent": 3,
      "text": "o The suggested external address is not configured to be used as an external address of the firewall or NAT gateway.",
      "ja": "O提案外部アドレスがファイアウォールまたはNATゲートウェイの外部アドレスとして使用するように構成されていません。"
    },
    {
      "indent": 3,
      "text": "If the PCP server cannot assign the suggested external address, protocol, and port, then:",
      "ja": "PCPサーバは、提案された外部アドレス、プロトコル、およびポートを割り当てることができない場合："
    },
    {
      "indent": 3,
      "text": "o If the request contained the PREFER_FAILURE option, then the PCP server MUST return CANNOT_PROVIDE_EXTERNAL.",
      "ja": "リクエストがPREFER_FAILUREオプションが含まれていた場合、O、その後、PCPサーバはCANNOT_PROVIDE_EXTERNALを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the request did not contain the PREFER_FAILURE option, and the PCP server can assign some other external address and port for that protocol, then the PCP server MUST do so and return the newly assigned external address and port in the response. In no case is the client penalized for a 'poor' choice of suggested external address and port. The suggested external address and port may be used by the server to guide its choice of what external address and port to assign, but in no case do they cause the server to fail to allocate an external address and port where otherwise it would have succeeded. The presence of a non-zero suggested external address or port is merely a hint; it never does any harm.",
      "ja": "O要求がPREFER_FAILUREオプションが含まれていなかった場合、およびPCPサーバは、PCPサーバがそうし、それに応じて新たに割り当てられた外部アドレスとポートを返さなければならない、そのプロトコルのためにいくつかの他の外部アドレスとポートを割り当てることができます。いかなる場合で示唆外部アドレスとポートの「貧しいチョイスを蹴るクライアントです。提案された外部アドレスとポートは、外部アドレスとポートを割り当てるかのその選択を導くために、サーバによって使用されてもよいが、いかなる場合にも、彼らはそれ以外の場合は成功しただろう、外部アドレスとポートを割り当てるために、サーバーが失敗する原因です。非ゼロの存在は、外部アドレスまたはポートが単にヒントで示唆しました。それが害を行うことはありません。"
    },
    {
      "indent": 3,
      "text": "A PCP-controlled device MUST NOT create mappings for a protocol not indicated in the request. For example, if the request was for a TCP mapping, an additional corresponding UDP mapping MUST NOT be automatically created.",
      "ja": "PCP-制御デバイスは、要求の中で示されていないプロトコルのマッピングを作成してはいけません。要求はTCPマッピングのためだった場合、追加の対応するUDPマッピングが自動的に作成されてはなりません。"
    },
    {
      "indent": 3,
      "text": "Mappings typically consume state on the PCP-controlled device, and it is RECOMMENDED that a per-host and/or per-subscriber limit be enforced by the PCP server to prevent exhausting the mapping state. If this limit is exceeded, the result code USER_EX_QUOTA is returned.",
      "ja": "マッピングは、典型的には、PCP-制御装置に状態を消費し、ホストごとの及び/又は毎加入者制限がマッピング状態を排気防止するPCPサーバによって実施されることが推奨されます。この制限を超えた場合、結果コードUSER_EX_QUOTAが返されます。"
    },
    {
      "indent": 3,
      "text": "If all of the preceding operations were successful (did not generate an error response), then the requested mapping is created or refreshed as described in the request and a SUCCESS response is built.",
      "ja": "上記の操作の全てが成功した場合（エラー応答を生成しなかった）、次いで、要求されたマッピングが作成またはリフレッシュ要求に記載されているように、成功応答が構築されています。"
    },
    {
      "indent": 0,
      "text": "11.4. Processing a MAP Response",
      "section_title": true,
      "ja": "11.4.  MAP応答を処理"
    },
    {
      "indent": 3,
      "text": "This section describes the operation of the PCP client when it receives a PCP response for the MAP Opcode.",
      "ja": "このセクションでは、MAPのオペコードのためのPCP応答を受信PCPクライアントの動作を説明します。"
    },
    {
      "indent": 3,
      "text": "After performing common PCP response processing, the response is further matched with a previously sent MAP request by comparing the internal IP address (the destination IP address of the PCP response, or other IP address specified via the THIRD_PARTY option), the protocol, the internal port, and the mapping nonce. Other fields are not compared, because the PCP server sets those fields. The PCP server will send a Mapping Update (Section 14.2) if the mapping changes (e.g., due to IP renumbering).",
      "ja": "共通PCP応答処理を行った後、応答はさらに、内部IPアドレス（PCP応答の宛先IPアドレス、またはTHIRD_PARTYオプションを介して指定された他のIPアドレス）、プロトコル、内部を比較することによって、以前に送信されたMAP要求と一致しますポート、およびマッピングナンス。 PCPサーバは、これらのフィールドを設定しますので、他のフィールドは、比較されません。マッピングの変更（例えば、原因のIP再ナンバリングへの）場合PCPサーバは、マッピング更新（14.2）を送信します。"
    },
    {
      "indent": 3,
      "text": "If the result code is NO_RESOURCES and the request was for the creation or renewal of a mapping, then the PCP client SHOULD NOT send further requests for any new mappings to that PCP server for the (limited) value of the lifetime. If the result code is NO_RESOURCES and the request was for the deletion of a mapping, then the PCP client SHOULD NOT send further requests of *any kind* to that PCP server for the (limited) value of the lifetime.",
      "ja": "結果コードがNO_RESOURCESで、リクエストがマッピングの作成や更新のためだった場合は、PCPクライアントは、寿命の（制限）値のためにそのPCPサーバへの新しいマッピングのための更なるリクエストを送るべきではありません。結果コードがNO_RESOURCESとリクエストがマッピングの削除のためだったされている場合は、PCPクライアントは、寿命の（制限）値のためにそのPCPサーバに*あらゆる種類*の更なるリクエストを送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "On a success response, the PCP client can use the external IP address and port as needed. Typically, the PCP client will communicate the external IP address and port to another host on the Internet using an application-specific rendezvous mechanism such as DNS SRV records.",
      "ja": "必要に応じて成功応答で、PCPクライアントは、外部IPアドレスとポートを使用することができます。一般的に、PCPクライアントは、DNS SRVレコードとして、アプリケーション固有のランデブーメカニズムを使用して、インターネット上の別のホストに外部IPアドレスとポートを通信します。"
    },
    {
      "indent": 3,
      "text": "After a success response, for as long as renewal is desired, the PCP client MUST set a timer or otherwise schedule an event to renew the mapping before its lifetime expires. Renewing a mapping is performed by sending another MAP request, exactly as described in Section 11.2, except that the suggested external address and port SHOULD be set to the values received in the response. From the PCP server's point of view a MAP request to renew a mapping is identical to a MAP request to create a new mapping, and is handled identically. Indeed, in the event of PCP server state loss, a renewal request from a PCP client will appear to the server to be a request to create a new mapping, with a particular suggested external address and port, which happen to be what the PCP server previously assigned. See also Section 16.3.1, \"Recreating Mappings\".",
      "ja": "成功応答の後、限り更新を希望されるため、PCPクライアントは、タイマーを設定するか、そうでなければその寿命が切れる前にマッピングを更新するイベントをスケジュールする必要があります。提案外部アドレス・ポートが応答して受信された値に設定されるべきであることを除いて、セクション11.2で説明したように、マッピングを更新することは、正確に、他のMAPリクエストを送信することによって行われます。ビューのPCPサーバの観点からマッピングを更新するMAP要求は、新しいマッピングを作成するためのMAP要求と同一であり、同一に扱われます。確かに、PCPサーバの状態が失われた場合には、PCPクライアントからの更新要求は、どのようなPCPサーバに起こる特定の提案外部アドレスとポートを持つ新しいマッピングを作成するための要求であるとサーバーに表示されます以前に割り当てられました。 、セクション16.3.1また、「再作成マッピング」を参照してください。"
    },
    {
      "indent": 3,
      "text": "On an error response, the client SHOULD NOT repeat the same request to the same PCP server within the lifetime returned in the response.",
      "ja": "エラー応答では、クライアントは応答で返さ寿命内の同じPCPサーバに同じ要求を繰り返すべきではありません。"
    },
    {
      "indent": 0,
      "text": "11.5. Address Change Events",
      "section_title": true,
      "ja": "11.5. アドレス変更イベント"
    },
    {
      "indent": 3,
      "text": "A customer premises router might obtain a new external IP address, for a variety of reasons including a reboot, power outage, DHCP lease expiry, or other action by the ISP. If this occurs, traffic forwarded to a host's previous address might be delivered to another host that now has that address. This affects all mapping types, whether implicit or explicit. This same problem already occurs today when a host's IP address is reassigned, without PCP and without an ISP-operated CGN. The solution is the same as today: the problems associated with host renumbering are caused by host renumbering, and are eliminated if host renumbering is avoided. PCP defined in this document does not provide machinery to reduce the host renumbering problem.",
      "ja": "宅内ルータは、ISPによってリブート、停電、DHCPリースの有効期限、または他のアクションを含む、様々な理由のために、新しい外部IPアドレスを取得することがあります。この問題が発生した場合、ホストの前のアドレスに転送されるトラフィックは今、そのアドレスを持つ別のホストに配信されることがあります。これは、暗黙的または明示的かどうか、すべてのマッピングタイプに影響を与えます。ホストのIPアドレスが再割り当てされたときに、この同じ問題は、すでにPCPなしとISP-運営CGNなしで、今日起こります。ソリューションは、今日と同じである：ホストリナンバリングに関連する問題は、ホスト・リナンバリングによって引き起こされ、そしてホストリナンバリングが回避されている場合に排除されています。この文書で定義されたPCPは、ホストリナンバリングの問題を軽減するための機械を提供していません。"
    },
    {
      "indent": 3,
      "text": "When an internal host changes its internal IP address (e.g., by having a different address assigned by the DHCP server), the NAT (or firewall) will continue to send traffic to the old IP address. Typically, the internal host will no longer receive traffic sent to that old IP address. Assuming the internal host wants to continue receiving traffic, it needs to install new mappings for its new IP address. The Suggested External Port field will not be fulfilled by the PCP server, in all likelihood, because it is still being forwarded to the old IP address. Thus, a mapping is likely to be assigned a new external port number and/or external IP address. Note that such host renumbering is not expected to happen routinely on a regular basis for most hosts, since most hosts renew their DHCP leases before they expire (or re-request the same address after reboot) and most DHCP servers honor such requests and grant the host the same address it was previously using before the reboot.",
      "ja": "内部ホストが内部IPアドレスを変更した場合（例えば、DHCPサーバによって割り当てられた別のアドレスを持つことで）、NAT（またはファイアウォール）は、古いIPアドレスにトラフィックを送信し続けます。一般的に、内部ホストは、もはやその古いIPアドレスに送信されたトラフィックを受信しません。内部ホストがトラフィックを受信し続けたいと仮定すると、それは新しいIPアドレスの新しいマッピングをインストールする必要があります。それはまだ古いIPアドレスに転送されているので、推奨外部ポートフィールドは、すべての可能性では、PCPサーバによって満たされることはありません。このように、マッピングは、新しい外部ポート番号および/または外部IPアドレスを割り当てられる可能性があります。ほとんどのホストは、期限が切れる前にDHCPリースを更新（または再起動後に同じアドレスを再要求）と、ほとんどのDHCPサーバは、このような要求を尊重し、付与するので、このような宿主のリナンバリングはほとんどのホストのために、定期的に、日常的に発生することが予想されていないことに注意してくださいそれは以前に、再起動する前に使用していた同じアドレスをホストします。"
    },
    {
      "indent": 3,
      "text": "A host might gain or lose interfaces while existing mappings are active (e.g., Ethernet cable plugged in or removed, joining/leaving a WiFi network). Because of this, if the PCP client is sending a PCP request to maintain state in the PCP server, it SHOULD ensure that those PCP requests continue to use the same interface (e.g., when refreshing mappings). If the PCP client is sending a PCP request to create new state in the PCP server, it MAY use a different source interface or different source address.",
      "ja": "ホストが（WiFiネットワークを離れる/接合、例えば、イーサネットケーブルが接続または削除）利得又は既存のマッピングがアクティブである間のインタフェースを失うかもしれません。 PCPクライアントは、PCPサーバで状態を維持するために、PCPリクエストを送信している場合は、こののなので、それはそれらのPCP要求が同じインターフェイスを使用し続けることを確実にすべきである（例えば、マッピングを更新する場合）。 PCPクライアントは、PCPサーバに新しい状態を作成するために、PCPリクエストを送信している場合、それは別の送信元インターフェイスまたは異なる送信元アドレスを使用するかもしれません。"
    },
    {
      "indent": 0,
      "text": "11.6. Learning the External IP Address Alone",
      "section_title": true,
      "ja": "11.6. アローンの外部IPアドレスを学習"
    },
    {
      "indent": 3,
      "text": "NAT-PMP [RFC6886] includes a mechanism to allow clients to learn the external IP address alone, without also requesting a port mapping. NAT-PMP was designed for residential NAT gateways, where such an operation makes sense because a typical residential NAT gateway has only one external IP address. PCP has broader scope, and also supports Carrier-Grade NATs (CGNs) that may have a pool of external IP addresses, not just one. A client may not be assigned any particular external IP address from that pool until it has at least one implicit, explicit, or static port mapping, and even then only for as long as that mapping remains valid. Client software that just wishes to display the user's external IP address for cosmetic purposes can achieve that by requesting a short-lived mapping (e.g., to the Discard service (TCP/9 or UDP/9) or some other port) and then displaying the resulting external IP address. However, once that mapping expires a subsequent implicit or explicit dynamic mapping might be mapped to a different external IP address.",
      "ja": "NAT-PMP [RFC6886]はクライアントもポートマッピングを要求せず、単独の外部IPアドレスを学習できるようにする機構を備えています。 NAT-PMPは、典型的な住宅のNATゲートウェイは唯一の外部IPアドレスを持っているので、このような操作は理にかなっている住宅のNATゲートウェイのために設計されました。 PCPは、より広い範囲を持っており、また、外部のIPアドレスのプールだけではなく、1を有することができるキャリアグレードNATの（CGNを）をサポートしています。クライアントは、暗黙的、明示的、または静的ポートマッピング少なくとも一つを持ってまで、そのプールからの任意の特定の外部IPアドレスを割り当てられ、その場合でも、唯一の限りそのマッピングが有効なままで用することはできません。ちょうど化粧品の目的のために、ユーザの外部IPアドレスを表示したいクライアントソフトウェアは、（廃棄サービス（TCP / 9またはUDP / 9）、またはいくつかの他のポートへの例えば、）短命マッピングを要求して、表示していることを達成することができます外部IPアドレスを結果。そのマッピングの有効期限が切れた後しかし、その後の暗黙的または明示的な動的なマッピングが異なる外部IPアドレスにマップされる可能性があります。"
    },
    {
      "indent": 0,
      "text": "12. PEER Opcode",
      "section_title": true,
      "ja": "12. PEERオペコード"
    },
    {
      "indent": 3,
      "text": "This section defines an Opcode for controlling dynamic outbound mappings.",
      "ja": "このセクションでは、動的なアウトバウンド・マッピングを制御するためのオペコードを定義します。"
    },
    {
      "indent": 3,
      "text": "PEER: Create a new dynamic outbound mapping to a remote peer's IP address and port, or extend the lifetime of an existing outbound mapping.",
      "ja": "PEER：リモートピアのIPアドレスとポートに新しい動的アウトバウンドのマッピングを作成するか、既存のアウトバウンドマッピングの寿命を延ばします。"
    },
    {
      "indent": 3,
      "text": "The use of this Opcodes is described in this section.",
      "ja": "このオペコードの使用は、このセクションで説明されています。"
    },
    {
      "indent": 3,
      "text": "PCP servers SHOULD provide a configuration option to allow administrators to disable PEER support if they wish.",
      "ja": "PCPサーバは、彼らが希望する場合、管理者はピアサポートを無効にすることを可能にする設定オプションを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Because a mapping created or managed by PEER behaves almost exactly like an implicit dynamic outbound mapping created as a side effect of a packet (e.g., TCP SYN) sent by the host, mappings created or managed using PCP PEER requests may be endpoint-independent mapping (EIM) or endpoint-dependent mapping (EDM), with endpoint-independent filtering (EIF) or endpoint-dependent filtering (EDF), consistent with the existing behavior of the NAT gateway or firewall in question for implicit outbound mappings it creates automatically as a result of observing outgoing traffic from internal hosts.",
      "ja": "ほぼ正確にホストによって送信されたパケット（例えば、TCP SYN）の副作用として作成された暗黙の動的なアウトバウンドマッピングのように振る舞うマッピングが作成またはピアによって管理されるので、PCPのPEERリクエストを使用して作成または管理のマッピングは、エンドポイントに依存しないことがありマッピング（EIM）またはエンドポイント非依存フィルタリング（EIF）と終点依存マッピング（EDM）、またはエンドポイントに依存するフィルタ（EDF）、暗黙的なアウトバウンドマッピングの問題のNATゲートウェイまたはファイアウォールの既存の挙動と一致し、それはのように自動的に作成内部ホストからの発信トラフィックを観察した結果。"
    },
    {
      "indent": 0,
      "text": "12.1. PEER Operation Packet Formats",
      "section_title": true,
      "ja": "12.1. 操作パケット形式をPEER"
    },
    {
      "indent": 3,
      "text": "The PEER Opcode allows a PCP client to create a new explicit dynamic outbound mapping (which functions similarly to an outbound mapping created implicitly when a host sends an outbound TCP SYN) or to extend the lifetime of an existing outbound mapping.",
      "ja": "PEERのオペコードは、PCPクライアントは（ホストがアウトバウンドTCP SYNを送信するときに、暗黙的に作成されたアウトバウンドマッピングと同様の機能）新しい明示的な動的なアウトバウンドマッピングを作成したり、既存のアウトバウンドマッピングの寿命を延長することができます。"
    },
    {
      "indent": 3,
      "text": "The following diagram shows the Opcode layout for the PEER Opcode. The formats for the PEER request and response packets are aligned so that related fields fall at the same offsets in the packet.",
      "ja": "次の図は、ピアオペコードのオペコードレイアウトを示します。関連分野は、パケット内の同じオフセットで収まるようにPEER要求と応答パケットのためのフォーマットが並んでいます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                 Mapping Nonce (96 bits)                       |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Protocol    |          Reserved (24 bits)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Internal Port          |    Suggested External Port    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|           Suggested External IP Address (128 bits)            |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Remote Peer Port        |     Reserved (16 bits)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|               Remote Peer IP Address (128 bits)               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 11: PEER Opcode Request",
      "ja": "図11：PEERのオペコードリクエスト"
    },
    {
      "indent": 3,
      "text": "These fields are described below:",
      "ja": "これらのフィールドは以下の通りであります："
    },
    {
      "indent": 3,
      "text": "Requested Lifetime (in common header): Requested lifetime of this mapping, in seconds. Note that it is not possible to reduce the lifetime of a mapping (or delete it, with requested lifetime=0) using PEER.",
      "ja": "（共通ヘッダにおいて）要求された寿命は：秒で、このマッピングの寿命を要求されました。マッピングの寿命を減少させることができないことに注意してください（またはそれを削除し、要求された寿命を持つ= 0）ピアを使用。"
    },
    {
      "indent": 3,
      "text": "Mapping Nonce: Random value chosen by the PCP client. See Section 12.2, \"Generating a PEER Request\". Zero is a legal value (but unlikely, occurring in roughly one in 2^96 requests).",
      "ja": "マッピングナンス：PCPクライアントによって選ばれたランダムな値。 「PEER要求の作成」、12.2節を参照してください。ゼロ（約1 96 ^ 2内の要求で発生するが、そうもない）有効な値です。"
    },
    {
      "indent": 3,
      "text": "Protocol: Upper-layer protocol associated with this Opcode. Values are taken from the IANA protocol registry [proto_numbers]. For example, this field contains 6 (TCP) if the Opcode is describing a TCP mapping. This field contains 17 (UDP) if the Opcode is describing a UDP mapping. Protocol MUST NOT be zero.",
      "ja": "プロトコル：このオペコードに関連付けられている上位層プロトコル。値はIANAプロトコルレジストリ[proto_numbers]から取得されます。オペコードがTCPマッピングを記述されている場合、例えば、このフィールドは6（TCP）を含みます。オペコードはUDPマッピングを記述している場合、このフィールドは17（UDP）が含まれています。プロトコルはゼロであるはずがありません。"
    },
    {
      "indent": 3,
      "text": "Reserved: 24 reserved bits, MUST be set to 0 on transmission and MUST be ignored on reception.",
      "ja": "予約：24の予約済みビットは、送信時に0に設定しなければならなくて、受信時に無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Internal Port: Internal port for the mapping. Internal port MUST NOT be zero.",
      "ja": "内部ポート：マッピングのための内部ポート。内部ポートはゼロであるはずがありません。"
    },
    {
      "indent": 3,
      "text": "Suggested External Port: Suggested external port for the mapping. If the PCP client does not know the external port, or does not have a preference, it MUST use 0.",
      "ja": "マッピングのための推奨外部ポート：外部ポートが示唆されました。 PCPクライアントが外部ポートを知らない、または好みを持っていない場合は、0を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Suggested External IP Address: Suggested external IP address for the mapping. If the PCP client does not know the external address, or does not have a preference, it MUST use the address-family-specific all-zeros address (see Section 5).",
      "ja": "推奨外部IPアドレス：マッピングのための推奨外部IPアドレス。 PCPクライアントが外部アドレスを知らない、または好みを持っていない場合は、アドレスファミリ固有のすべてゼロのアドレスを使用しなければならない（第5節参照）。"
    },
    {
      "indent": 3,
      "text": "Remote Peer Port: Remote peer's port for the mapping. Remote peer port MUST NOT be zero.",
      "ja": "リモートピアポート：マッピング用のリモートピアのポート。リモートピアポートはゼロであるはずがありません。"
    },
    {
      "indent": 3,
      "text": "Reserved: 16 reserved bits, MUST be set to 0 on transmission and MUST be ignored on reception.",
      "ja": "予約：16の予約済みビットは、送信時に0に設定しなければならなくて、受信時に無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Remote Peer IP Address: Remote peer's IP address. This is from the perspective of the PCP client, so that the PCP client does not need to concern itself with NAT64 or NAT46 (which both cause the client's idea of the remote peer's IP address to differ from the remote peer's actual IP address). This field allows the PCP client and PCP server to disambiguate multiple connections from the same port on the internal host to different servers. An IPv6 address is represented directly, and an IPv4 address is represented using the IPv4-mapped address syntax (Section 5).",
      "ja": "リモートピアのIPアドレス：リモートピアのIPアドレス。 PCPクライアントがNAT64か（両方がリモートピアの実際のIPアドレスと異なるリモートピアのIPアドレスのクライアントのアイデアを起こす）NAT46に関与する必要はありませんように、これは、PCPクライアントの観点からです。このフィールドには、PCPクライアントとPCPサーバが異なるサーバへの内部ホスト上の同じポートからの複数の接続を明確にすることができます。 IPv6アドレスは直接表され、IPv4アドレスは、IPv4マップアドレス構文（セクション5）を用いて表されます。"
    },
    {
      "indent": 3,
      "text": "When attempting to re-create a lost mapping, the suggested external IP address and port are set to the External IP Address and Port fields received in a previous PEER response from the PCP server. On an initial PEER request, the external IP address and port are set to zero.",
      "ja": "失われたマッピングを再作成しようとすると、提案された外部IPアドレスとポートを外部IPアドレスに設定し、ポートフィールドはPCPサーバから前のPEER応答で受信されています。初期PEERリクエストでは、外部IPアドレスとポートがゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "Note that semantics similar to the PREFER_FAILURE option are automatically implied by PEER requests. If the Suggested External IP Address or Suggested External Port fields are non-zero, and the PCP server is unable to honor the suggested external IP address, protocol, or port, then the PCP server MUST return a",
      "ja": "PREFER_FAILUREオプションと同じような意味が自動的にPEERリクエストによって暗示されていることに注意してください。推奨外部IPアドレスまたは推奨外部ポートフィールドが非ゼロであり、PCPサーバが提案外部IPアドレス、プロトコル、またはポートを尊重することができない場合には、PCPサーバは返さなければなりません"
    },
    {
      "indent": 3,
      "text": "CANNOT_PROVIDE_EXTERNAL error response. The PREFER_FAILURE option is neither required nor allowed in PEER requests, and if a PCP server receives a PEER request containing the PREFER_FAILURE option it MUST return a MALFORMED_REQUEST error response.",
      "ja": "CANNOT_PROVIDE_EXTERNALエラー応答。 PREFER_FAILUREオプションは必要ありませんもPEERリクエストで許可され、PCPサーバは、それがMALFORMED_REQUESTエラー応答を返さなければなりませんPREFER_FAILUREオプションを含むPEERリクエストを受信した場合にもされていません。"
    },
    {
      "indent": 3,
      "text": "The following diagram shows the Opcode response for the PEER Opcode:",
      "ja": "次の図は、ピア・オペコードのオペコードの応答を示しています。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                 Mapping Nonce (96 bits)                       |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Protocol    |          Reserved (24 bits)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Internal Port          |    Assigned External Port     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|            Assigned External IP Address (128 bits)            |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Remote Peer Port        |     Reserved (16 bits)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|               Remote Peer IP Address (128 bits)               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 12: PEER Opcode Response",
      "ja": "図12：PEERのオペコード応答"
    },
    {
      "indent": 3,
      "text": "Lifetime (in common header): On a success response, this indicates the lifetime for this mapping, in seconds. On an error response, this indicates how long clients should assume they'll get the same error response from the PCP server if they repeat the same request.",
      "ja": "（共通ヘッダ内の）寿命は：成功の応答には、これは秒単位で、このマッピングの寿命を示しています。エラー応答では、これは長い間、クライアントは、彼らが同じ要求を繰り返す場合、彼らはPCPサーバから同じエラーレスポンスを得るでしょう仮定するべきかを示します。"
    },
    {
      "indent": 3,
      "text": "Mapping Nonce: Copied from the request.",
      "ja": "マッピングナンス：リクエストからコピーされます。"
    },
    {
      "indent": 3,
      "text": "Protocol: Copied from the request.",
      "ja": "プロトコル：リクエストからコピーされます。"
    },
    {
      "indent": 3,
      "text": "Reserved: 24 reserved bits, MUST be set to 0 on transmission, MUST be ignored on reception.",
      "ja": "予約：24の予約済みビットは、送信時に0に設定しなければなりません、受信時に無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Internal Port: Copied from request.",
      "ja": "内部ポート：リクエストからコピーされます。"
    },
    {
      "indent": 3,
      "text": "Assigned External Port: On a success response, this is the assigned external port for the mapping. On an error response, the suggested external port is copied from the request.",
      "ja": "割り当てられた外部ポート：成功応答で、これは、マッピングのために割り当てられた外部ポートです。エラー応答では、提案された外部ポートは、リクエストからコピーされます。"
    },
    {
      "indent": 3,
      "text": "Assigned External IP Address: On a success response, this is the assigned external IPv4 or IPv6 address for the mapping. On an error response, the suggested external IP address is copied from the request.",
      "ja": "外部IPアドレスを割り当て：成功応答で、これは、マッピングのために割り当てられた外部IPv4またはIPv6アドレスです。エラー応答では、提案された外部IPアドレスが要求からコピーされます。"
    },
    {
      "indent": 3,
      "text": "Remote Peer Port: Copied from request.",
      "ja": "リモートピアポート：リクエストからコピーされます。"
    },
    {
      "indent": 3,
      "text": "Reserved: 16 reserved bits, MUST be set to 0 on transmission, MUST be ignored on reception.",
      "ja": "予約：16の予約済みビットは、送信時に0に設定しなければなりません、受信時に無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Remote Peer IP Address: Copied from the request.",
      "ja": "リモートピアのIPアドレス：リクエストからコピーされます。"
    },
    {
      "indent": 0,
      "text": "12.2. Generating a PEER Request",
      "section_title": true,
      "ja": "12.2.  PEER要求の作成"
    },
    {
      "indent": 3,
      "text": "This section describes the operation of a client when generating a message with the PEER Opcode.",
      "ja": "PEERのオペコードとのメッセージを生成するときに、このセクションでは、クライアントの動作を説明します。"
    },
    {
      "indent": 3,
      "text": "The PEER Opcode MAY be sent before or after establishing bidirectional communication with the remote peer.",
      "ja": "PEERオペコード前またはリモートピアとの双方向通信を確立した後に送信されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "If sent before, this is considered a PEER-created mapping that creates a new dynamic outbound mapping in the PCP-controlled device.",
      "ja": "前に送信した場合、これはPCP-制御機器における新しい動的アウトバウンドマッピングを作成しますPEER-作成されたマッピングと考えられています。"
    },
    {
      "indent": 3,
      "text": "If sent after, this allows the PCP client to learn the IP address, port, and lifetime of the assigned external address and port for the existing implicit dynamic outbound mapping, and potentially to extend this lifetime (for reducing NAT or firewall keepalive messages, as described in Section 10.3).",
      "ja": "後に送信した場合、これはPCPクライアントは、IPアドレス、ポート、および既存の暗黙の動的なアウトバウンドマッピングに割り当てられた外部アドレスとポートの生涯を学ぶことができ、そして潜在的として、NATやファイアウォールのキープアライブメッセージを低減するため（この寿命を延長します10.3節で説明）。"
    },
    {
      "indent": 3,
      "text": "PEER requests are also useful for restoring mappings after a NAT has lost its mapping state (e.g., due to a crash).",
      "ja": "NATは、（原因クラッシュに、例えば）そのマッピング状態を失った後PEERリクエストもマッピングを復元するために有用です。"
    },
    {
      "indent": 3,
      "text": "The Mapping Nonce value is randomly chosen by the PCP client, following accepted practices for generating unguessable random numbers [RFC4086], and is used as part of the validation of PCP responses (see below) by the PCP client, and validation for mapping refreshes by the PCP server. The client MUST use a different mapping nonce for each PCP server it communicates with, and it is RECOMMENDED to choose a new random mapping nonce whenever the PCP client is initialized. The client MAY use a different mapping nonce for every mapping.",
      "ja": "マッピングノンス値をランダムに推測できない乱数を生成するための受け入れられた実践[RFC4086]以下、PCPクライアントによって選択され、PCPの応答の検証の一部として使用されている（下記参照）PCPクライアントによって、及びマッピングの検証は、によってリフレッシュPCPサーバ。クライアントは、それが通信する各PCPサーバ用に異なるマッピングnonceを使用しなければならない、そしてPCPクライアントが初期化されるたびに新しいランダムなマッピングnonceを選択することをお勧めします。クライアントは、すべてのマッピングのために異なるマッピングナンスを使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "The PEER Opcode contains a Remote Peer Address field, which is always from the perspective of the PCP client. Note that when the PCP-controlled device is performing address family translation (NAT46 or NAT64), the remote peer address from the perspective of the PCP client is different from the remote peer address on the other side of the address family translation device.",
      "ja": "PEERのオペコードは、PCPクライアントの観点から常にリモートピアアドレスフィールドが含まれています。 PCP制御デバイスは、アドレスファミリ変換（NAT46又はNAT64）を行う場合には、PCPクライアントの観点からリモートピアのアドレスは、アドレスファミリ変換素子の他方側のリモートピアのアドレスとは異なることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "12.3. Processing a PEER Request",
      "section_title": true,
      "ja": "12.3.  PEERリクエストの処理"
    },
    {
      "indent": 3,
      "text": "This section describes the operation of a server when receiving a request with the PEER Opcode. Processing SHOULD be performed in the order of the following paragraphs.",
      "ja": "このセクションでは、ピアオペコードと要求を受信するサーバの動作について説明します。処理は、以下の段落の順序で実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following fields from a PEER request are copied into the response: Protocol, Internal Port, Remote Peer IP Address, Remote Peer Port, and Mapping Nonce.",
      "ja": "プロトコル、内部ポート、リモートピアのIPアドレス、リモートピアポート、およびマッピングナンス：PEERリクエストから次のフィールドは、応答にコピーされます。"
    },
    {
      "indent": 3,
      "text": "When an implicit dynamic mapping is created, some NATs and firewalls validate destination addresses and will not create an implicit dynamic mapping if the destination address is invalid (e.g., 127.0.0.1). If a PCP-controlled device does such validation for implicit dynamic mappings, it SHOULD also do a similar validation of the remote peer IP address, protocol, and port for PEER-created explicit dynamic mappings. If the validation determines the remote peer IP address of a PEER request is invalid, then no mapping is created, and a MALFORMED_REQUEST error result is returned.",
      "ja": "暗黙的な動的マッピングが作成されると、いくつかのNAT及びファイアウォールは宛先アドレスを検証し、宛先アドレスが無効である場合、暗黙的な動的マッピングを作成しません（例えば、127.0.0.1）。 PCP-制御デバイスは、暗黙のダイナミックなマッピングのために、このような検証を行う場合、それはまた、PEER-作成した明示的なダイナミックなマッピングのためのリモートピアのIPアドレス、プロトコル、およびポートの同様の検証を行う必要があります。検証がPEERリクエストのリモートピアのIPアドレスが無効であると判断した場合、その後、何のマッピングは作成されず、MALFORMED_REQUESTのエラー結果が返されます。"
    },
    {
      "indent": 3,
      "text": "On receiving the PEER Opcode, the PCP server examines the mapping table for a matching five-tuple { Protocol, Internal Address, Internal Port, Remote Peer Address, Remote Peer Port }.",
      "ja": "PEERオペコードを受信すると、PCPサーバは、一致5タプル{プロトコル、内部アドレス、内部ポート、リモートピアアドレス、リモートピアポート}のマッピングテーブルを調べます。"
    },
    {
      "indent": 3,
      "text": "If no matching mapping is found, and the suggested external address and port are either zero or can be honored for the specified Protocol, a new mapping is created. By having the PEER create such a mapping, we avoid a race condition between the PEER request and the initial outgoing packet arriving at the NAT or firewall device first, and allow PEER to be used to recreate a lost outbound dynamic mapping (see Section 16.3.1, \"Recreating Mappings\"). Thereafter, this PEER-created mapping is treated as if it was an implicit dynamic outbound mapping (e.g., as if the PCP client sent a TCP SYN) and a lifetime appropriate to such a mapping is returned (note: on many NATs and firewalls, such mapping lifetimes are very short until bidirectional traffic is seen by the NAT or firewall).",
      "ja": "一致するマッピングが見つからない場合、および提案外部アドレスとポートのいずれかがゼロであるか、指定されたプロトコルのために表彰することができ、新しいマッピングが作成されます。このようなマッピングを作成するPEERを有することにより、我々は、PEERリクエストと最初のNATやファイアウォールデバイスに到着する最初の発信パケット間の競合状態を回避し、PEERは、セクション16.3を参照してください（失われたアウトバウンド動的マッピングを再作成するために使用することができます。 1、 \"再作成マッピング\"）。それは暗黙の動的なアウトバウンド・マッピングがいたかのように、その後、このピアが作成したマッピングが扱われている（例えば、PCPクライアントは、TCP SYN送信された場合など）、ノート（およびそのようなマッピングに適切な寿命が返されます。多くのNATやファイアウォール上で、双方向のトラフィックがNATまたはファイアウォール）で見られるまで、このようなマッピングの寿命は非常に短いです。"
    },
    {
      "indent": 3,
      "text": "If no matching mapping is found, and the suggested external address and port cannot be honored, then no new state is created, and the error CANNOT_PROVIDE_EXTERNAL is returned.",
      "ja": "一致するマッピングが見つからない、と示唆した外部アドレスとポートを光栄にすることができない場合は、新しい状態が作成されず、エラーCANNOT_PROVIDE_EXTERNALが返されます。"
    },
    {
      "indent": 3,
      "text": "If a matching mapping is found, and no previous PEER Opcode was successfully processed for this mapping, then the Suggested External Address and Port values in the request are ignored, the lifetime of that mapping is adjusted as described below, and information about the existing mapping is returned. This allows a client to explicitly extend the lifetime of an existing mapping and/or to learn an existing mapping's external address, port, and lifetime. The mapping nonce is remembered for this mapping.",
      "ja": "マッチングのマッピングが発見され、そして以前のPEERのオペコードが正常にこのマッピングのために処理されなかった場合は、その要求で提案されている外部アドレスとポートの値が無視され、そのマッピングの寿命は、以下に記載するように調整され、既存のマッピングに関する情報であり、返されます。これは、クライアントが明示的に既存のマッピングの寿命を延ばすために、および/または既存のマッピングの外部アドレス、ポート、および寿命を学ぶことができます。マッピングナンスは、このマッピングのために覚えています。"
    },
    {
      "indent": 3,
      "text": "If operating in the Simple Threat Model (Section 18.1), and the internal port, protocol, and internal address match a mapping that already exists, but the mapping nonce does not match (that is, a previous PEER request was processed), the request MUST be rejected with a NOT_AUTHORIZED error with the lifetime of the error indicating duration of that existing mapping. The PCP server only needs to remember one Mapping Nonce value for each mapping. This specification makes no statement about mapping nonce with the Advanced Threat Model.",
      "ja": "（つまり、以前のPEERリクエストが処理された、ある）単純な脅威モデルで動作している（18.1節）、および内部ポート、プロトコル、および内部アドレスが既に存在するマッピングが一致しますが、マッピングナンスが一致しない場合は、要求その既存のマッピングの持続時間を示すエラーの寿命とNOT_AUTHORIZEDエラーで拒否されなければなりません。 PCPサーバは、各マッピングのための1つのマッピングNonceの値を覚えておく必要があります。この仕様は、高度な脅威モデルとナンスのマッピングについての声明を行うものではありません。"
    },
    {
      "indent": 3,
      "text": "Processing the Lifetime value of the PEER Opcode is described in Section 15, \"Mapping Lifetime and Deletion\". Sending a PEER request with a very short requested lifetime can be used to query the lifetime of an existing mapping. So that PCP clients can reduce the frequency of their NAT and firewall keepalive messages, it is RECOMMENDED that lifetimes of mappings created or lengthened with PEER be longer than the lifetimes of implicitly created mappings.",
      "ja": "PEERオペコードのライフタイム値を処理する第15、「マッピング寿命および削除」に記載されています。非常に短い要求寿命とPEERリクエストを送信すると、既存のマッピングの寿命を照会するために使用することができます。だから、PCPのクライアントがNATやファイアウォールのキープアライブメッセージの頻度を減らすことができ、PEERで作成または長くマッピングの寿命が暗黙的に作成されたマッピングの寿命よりも長くすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "If all of the preceding operations were successful (did not generate an error response), then a SUCCESS response is generated, with the Lifetime field containing the lifetime of the mapping.",
      "ja": "上記の操作のすべてが（エラー応答を生成しなかった）成功した​​場合、SUCCESS応答がマッピングの寿命を含有する寿命フィールドと、生成されます。"
    },
    {
      "indent": 3,
      "text": "If a PEER-created or PEER-managed mapping is not renewed using PEER, then it reverts to the NAT's usual behavior for implicit mappings. For example, continued outbound traffic keeps the mapping alive, as per the NAT or firewall device's existing policy. A PEER-created or PEER-managed mapping may be terminated at any time by action of the TCP client or server (e.g., due to TCP FIN or TCP RST), as per the NAT or firewall device's existing policy.",
      "ja": "PEER-作成またはPEER管理のマッピングはPEERを使用して更新されていない場合、それは暗黙的なマッピングのためのNATの通常の動作に戻ります。例えば、アウトバウンドトラフィックがNATやファイアウォールデバイスの既存のポリシーに従って、生きているマッピングを保持し続けました。 PEER-作成またはPEER管理のマッピングがNATやファイアウォールデバイスの既存のポリシーに従って、（原因TCP FINまたはTCP RSTに、例えば）TCPクライアントまたはサーバの作用により、いつでも終了させることができます。"
    },
    {
      "indent": 0,
      "text": "12.4. Processing a PEER Response",
      "section_title": true,
      "ja": "12.4. ピア・レスポンスの処理"
    },
    {
      "indent": 3,
      "text": "This section describes the operation of a client when processing a response with the PEER Opcode.",
      "ja": "PEERのオペコードとの応答を処理するときにこのセクションでは、クライアントの動作を説明します。"
    },
    {
      "indent": 3,
      "text": "After performing common PCP response processing, the response is further matched with an outstanding PEER request by comparing the internal IP address (the destination IP address of the PCP response, or other IP address specified via the THIRD_PARTY option), the protocol, the internal port, the remote peer address, the remote peer port, and the mapping nonce. Other fields are not compared, because the PCP server sets those fields to provide information about the mapping created by the Opcode. The PCP server will send a Mapping Update (Section 14.2) if the mapping changes (e.g., due to IP renumbering).",
      "ja": "共通PCP応答処理を行った後、応答はさらに、内部IPアドレス（PCP応答の宛先IPアドレス、またはTHIRD_PARTYオプションを介して指定された他のIPアドレス）、プロトコル、内部ポートを比較することにより、未処理のPEER要求と一致します、リモートピアのアドレス、リモートピアポート、およびマッピングナンス。 PCPサーバは、オペコードにより作成されたマッピングに関する情報を提供するために、これらのフィールドを設定しますので、他のフィールドは、比較されません。マッピングの変更（例えば、原因のIP再ナンバリングへの）場合PCPサーバは、マッピング更新（14.2）を送信します。"
    },
    {
      "indent": 3,
      "text": "If the result code is NO_RESOURCES and the request was for the creation or renewal of a mapping, then the PCP client SHOULD NOT send further requests for any new mappings to that PCP server for the (limited) value of the lifetime.",
      "ja": "結果コードがNO_RESOURCESで、リクエストがマッピングの作成や更新のためだった場合は、PCPクライアントは、寿命の（制限）値のためにそのPCPサーバへの新しいマッピングのための更なるリクエストを送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "On a successful response, the application can use the assigned Lifetime value to reduce its frequency of application keepalives for that particular NAT mapping. Of course, there may be other reasons, specific to the application, to use more frequent application keepalives. For example, the PCP assigned lifetime could be one hour but the application may want to maintain state on its server (e.g., \"busy\" / \"away\") more frequently than once an hour. If the response indicates an unexpected IP address or port (e.g., due to IP renumbering), the PCP client will want to re-establish its connection to its remote server.",
      "ja": "成功した応答に、アプリケーションは、その特定のNATマッピング用アプリケーションキープアライブのその頻度を減少させるために割り当てられたライフタイム値を使用することができます。もちろん、より頻繁なアプリケーションキープアライブを使用して、アプリケーションに固有の他の理由があってもよいです。例えば、PCP割り当てられた寿命は一時間かもしれないが、アプリケーションは一時間に一度よりも頻繁に（例えば、「忙しい」/「離れ」）そのサーバー上の状態を維持することをお勧めします。応答が（によるIPリナンバリングに、例えば）IPアドレスやポート予期しないことを示す場合は、PCPクライアントは、リモートサーバーへの接続を再確立することになるでしょう。"
    },
    {
      "indent": 3,
      "text": "If the PCP client wishes to keep this mapping alive beyond the indicated lifetime, it MAY rely on continued inside-to-outside traffic to ensure that the mapping will continue to exist, or it MAY issue a new PCP request prior to the expiration. The recommended timings for renewing PEER mappings are the same as for MAP mappings, as described in Section 11.2.1.",
      "ja": "PCPクライアントが指定された期間を超えて生きてこのマッピングを維持したい場合は、マッピングが存在し続ける、またはそれが有効期限前に新しいPCP要求を発行することができることを保証するために、継続的な内部ツー外のトラフィックに依存してもよいです。 11.2.1項で説明したようにPEERマッピングを更新するための推奨タイミングは、MAPのマッピングと同じです。"
    },
    {
      "indent": 6,
      "text": "Note: Implementations need to expect the PEER response may contain an external IP address with a different family than the remote peer IP address, e.g., when NAT64 or NAT46 are being used.",
      "ja": "注：実装はNAT64又はNAT46が使用されている場合PEER応答は、例えば、リモートピアのIPアドレスとは異なる家族と外部IPアドレスを含むことができる期待する必要があります。"
    },
    {
      "indent": 0,
      "text": "13. Options for MAP and PEER Opcodes",
      "section_title": true,
      "ja": "MAPおよびPEERオペコードのための13のオプション"
    },
    {
      "indent": 3,
      "text": "This section describes options for the MAP and PEER Opcodes. These options MUST NOT appear with other Opcodes, unless permitted by those other Opcodes.",
      "ja": "このセクションでは、MAPとPEERオペコードのためのオプションについて説明します。それらの他のオペコードによって許可されない限り、これらのオプションは、他のオペコードと現れてはなりません。"
    },
    {
      "indent": 0,
      "text": "13.1. THIRD_PARTY Option for MAP and PEER Opcodes",
      "section_title": true,
      "ja": "13.1.  MAPおよびPEERオペコードのためTHIRD_PARTYオプション"
    },
    {
      "indent": 3,
      "text": "This option is used when a PCP client wants to control a mapping to an internal host other than itself. This is used with both MAP and PEER Opcodes.",
      "ja": "PCPクライアントが自分以外の内部ホストへのマッピングを制御したい場合は、このオプションは使用されています。これは、MAPとPEERのオペコードの両方で使用されています。"
    },
    {
      "indent": 3,
      "text": "Due to security concerns with the THIRD_PARTY option, this option MUST NOT be implemented or used unless the network on which the PCP messages are to be sent is fully trusted. For example, if access control lists (ACLs) are installed on the PCP client, PCP server, and the network between them, so those ACLs allow only communications from a trusted PCP client to the PCP server.",
      "ja": "THIRD_PARTYオプションとセキュリティの問題に、このオプションが実装されたりPCPメッセージが送信されるようにされているネットワークが完全に信頼されていない限り、使用してはいけません。例えば、アクセス制御リスト（ACL）場合PCPクライアント、PCPサーバ、およびそれらの間のネットワーク上にインストールされているので、これらのACLは、PCPサーバへの信頼されたPCPクライアントからの通信のみを許可します。"
    },
    {
      "indent": 3,
      "text": "A management device would use this option to control a PCP server on behalf of users. For example, a management device located in a network operations center, which presents a user interface to end users or to network operations staff, and issues PCP requests with the THIRD_PARTY option to the appropriate PCP server.",
      "ja": "管理デバイスは、ユーザーに代わってPCPサーバを制御するには、このオプションを使用します。例えば、適切なPCPサーバへTHIRD_PARTYオプションで、ユーザーやネットワーク運用スタッフに、そして問題のPCP要求を終了するには、ユーザー・インターフェースを提供するネットワークオペレーションセンターに位置管理装置。"
    },
    {
      "indent": 3,
      "text": "The THIRD_PARTY option is formatted as follows:",
      "ja": "次のようにTHIRD_PARTYオプションがフォーマットされます："
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Option Code=1 |  Reserved     |   Option Length=16            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                Internal IP Address (128 bits)                 |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 13: THIRD_PARTY Option",
      "ja": "図13：THIRD_PARTYオプション"
    },
    {
      "indent": 3,
      "text": "The fields are described below:",
      "ja": "フィールドは以下の通りであります："
    },
    {
      "indent": 3,
      "text": "Internal IP Address: Internal IP address for this mapping.",
      "ja": "内部IPアドレス：このマッピングのための内部IPアドレス。"
    },
    {
      "indent": 6,
      "text": "Option Name: THIRD_PARTY Number: 1 Purpose: Indicates the MAP or PEER request is for a host other than the host sending the PCP option. Valid for Opcodes: MAP, PEER Length: 16 octets May appear in: request. May appear in response only if it appeared in the associated request. Maximum occurrences: 1",
      "ja": "オプション名：THIRD_PARTY数：1目的：MAPまたはPEERリクエストがPCPオプションを送信するホスト以外のホストのためであることを示します。オペコードの有効：MAP、PEER長さ：要求：16個のオクテットで表示されることがあります。それが関連する要求に登場した場合にのみ対応して表示されることがあります。最大出現：1"
    },
    {
      "indent": 3,
      "text": "A THIRD_PARTY option MUST NOT contain the same address as the source address of the packet. This is because many PCP servers may not implement the THIRD_PARTY option at all, and with those servers a client redundantly using the THIRD_PARTY option to specify its own IP address would cause such mapping requests to fail where they would otherwise have succeeded. A PCP server receiving a THIRD_PARTY option specifying the same address as the source address of the packet MUST return a MALFORMED_REQUEST result code.",
      "ja": "THIRD_PARTYオプションは、パケットの送信元アドレスと同じアドレスを含めることはできません。多くのPCPサーバは全くTHIRD_PARTYオプションを実装していない可能性があるからです、そして、それらのサーバーで重複して独自のIPアドレスを指定するTHIRD_PARTYオプションを使用しているクライアントは、彼らがそうでなければ成功しただろうどこに失敗するようなマッピング要求を引き起こします。パケットの送信元アドレスと同じアドレスを指定するTHIRD_PARTYオプションを受信PCPサーバはMALFORMED_REQUEST結果コードを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "A PCP server MAY be configured to permit or to prohibit the use of the THIRD_PARTY option. If this option is permitted, properly authorized clients may perform these operations on behalf of other hosts. If this option is prohibited, and a PCP server receives a PCP MAP request with a THIRD_PARTY option, it MUST generate a UNSUPP_OPTION response.",
      "ja": "PCPサーバは、許可するかTHIRD_PARTYオプションの使用を禁止するように構成することができます。このオプションが許可されている場合は、適切に承認クライアントは他のホストに代わってこれらの操作を行うことができます。このオプションが禁止され、PCPサーバはTHIRD_PARTYオプションでPCPのMAP要求を受信した場合、それはUNSUPP_OPTIONレスポンスを生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that customer premises equipment implementing a PCP server be configured to prohibit third-party mappings by default. With this default, if a user wants to create a third-party mapping, the user needs to interact out-of-band with their customer premises router (e.g., using its HTTP administrative interface).",
      "ja": "PCPサーバを実装する顧客宅内機器は、デフォルトでは、サードパーティのマッピングを禁止するように構成することが推奨されます。ユーザーは、サードパーティのマッピングを作成したい場合は、このデフォルトでは、ユーザーが自分の顧客宅内ルータとアウトオブバンド対話する必要がある（例えば、そのHTTP管理インターフェースを使用して）。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that service provider NAT and firewall devices implementing a PCP server be configured to permit the THIRD_PARTY option, when sent by a properly authorized host. If the packet arrives from an unauthorized host, the PCP server MUST generate an UNSUPP_OPTION error.",
      "ja": "適切に承認ホストによって送信されたときに、サービスプロバイダNATとPCPサーバを実装するファイアウォールデバイスは、THIRD_PARTYオプションを許可するように設定することが推奨されます。パケットが不正なホストから到着した場合、PCPサーバはUNSUPP_OPTIONエラーを発生させなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the THIRD_PARTY option is not needed for today's common scenario of an ISP offering a single IP address to a customer who is using NAT to share that address locally, since in this scenario all the customer's hosts appear, from the point of view of the ISP, to be a single host.",
      "ja": "このシナリオでは、すべての顧客のホストがの観点から、表示されているので、THIRD_PARTYオプションはローカルでそのアドレスを共有するためにNATを使用している顧客に、単一のIPアドレスを提供するISPの、今日の一般的なシナリオのために必要されていないことに注意してくださいISPは、単一のホストであることを。"
    },
    {
      "indent": 3,
      "text": "When a PCP client is using the THIRD_PARTY option to make and maintain mappings on behalf of some other device, it may be beneficial if, where possible, the PCP client verifies that the other device is actually present and active on the network. Otherwise, the PCP client risks maintaining those mappings forever, long after the device that required them has gone. This would defeat the purpose of PCP mappings having a finite lifetime so that they can be automatically deleted after they are no longer needed.",
      "ja": "PCPクライアントが作るといくつかの他のデバイスに代わってマッピングを維持するためにTHIRD_PARTYオプションを使用している場合は、可能な場合は、PCPのクライアントは、他のデバイスがネットワーク上に実際に存在し、アクティブであることを確認し、あれば、それは有益であろう。それ以外の場合は、PCPクライアントがそれらを必要なデバイスが去ったずっと後に、永遠にそれらのマッピングを維持する恐れがあります。これは、彼らはもはや必要とされた後、彼らは自動的に削除できないように、有限の寿命を持つPCPマッピングの目的を台無しにしてしまいます。"
    },
    {
      "indent": 0,
      "text": "13.2. PREFER_FAILURE Option for MAP Opcode",
      "section_title": true,
      "ja": "13.2.  MAPオペコードのためPREFER_FAILUREオプション"
    },
    {
      "indent": 3,
      "text": "This option is only used with the MAP Opcode.",
      "ja": "このオプションは、MAPのオペコードで使用されています。"
    },
    {
      "indent": 3,
      "text": "This option indicates that if the PCP server is unable to map both the suggested external port and suggested external address, the PCP server should not create a mapping. This differs from the behavior without this option, which is to create a mapping.",
      "ja": "このオプションでは、PCPサーバが示唆された外部ポートと示唆した外部アドレスの両方をマッピングすることができない場合は、PCPサーバは、マッピングを作成するべきではないことを示しています。これは、マッピングを作成することです、このオプションなしで動作とは異なります。"
    },
    {
      "indent": 3,
      "text": "PREFER_FAILURE is never necessary for a PCP client to manage mappings for itself, and its use causes additional work in the PCP client and in the PCP server. This option exists for interworking with non-PCP mapping protocols that have different semantics than PCP (e.g., UPnP IGDv1 interworking [PNP-IGD-PCP], where the semantics of UPnP IGDv1",
      "ja": "PREFER_FAILUREは、自身のマッピングを管理するために、PCPのクライアントのために必要なことはありませんし、その使用はPCPクライアントにとPCPサーバに追加作業が発生します。このオプションは、PCPは異なるセマンティクス（例えば、UPnPのIGDv1は[PNP-IGD-PCP]をインターワーキングを有する非PCPマッピングプロトコル、UPnPのIGDv1のセマンティクスとのインターワーキングのために存在します"
    },
    {
      "indent": 3,
      "text": "only allow the UPnP IGDv1 client to dictate mapping a specific port), or separate port allocation systems that allocate ports to a subscriber (e.g., a subscriber-accessed web portal operated by the same ISP that operates the PCP server). A PCP server MAY support this option, if its designers wish to support such downstream devices or separate port allocation systems. PCP servers that are not intended to interface with such systems are not required to support this option. PCP clients other than UPnP IGDv1 interworking clients or other than a separate port allocation system SHOULD NOT use this option because it results in inefficient operation, and they cannot safely assume that all PCP servers will implement it. It is anticipated that this option will be deprecated in the future as more clients adopt PCP natively and the need for this option declines.",
      "ja": "のみ）のUPnP IGDv1クライアントが特定のポートをマッピング決定することを可能にする、または加入者（PCPサーバを操作同じISPによって作動例えば、加入者アクセスウェブポータル）にポートを割り当てる別個ポート割り当てシステム。その設計者は、このような下流のデバイスまたは別のポート割り当てシステムをサポートしたい場合は、PCPサーバは、このオプションをサポートするかもしれません。そのようなシステムとのインタフェースすることを意図していないPCPサーバは、このオプションをサポートする必要はありません。それは非効率的な運転につながるため、クライアントのインターワーキングのUPnP IGDv1以外のまたは別のポート割り当てシステム以外のPCPクライアントは、このオプションを使用しないでください、そして、彼らは安全にすべてのPCPサーバがそれを実装すると仮定することはできません。より多くのクライアントがネイティブにPCPを採用し、このオプションの必要性が低下し、このオプションは、将来的に廃止されることが予想されます。"
    },
    {
      "indent": 3,
      "text": "The PREFER_FAILURE option is formatted as follows:",
      "ja": "次のようにPREFER_FAILUREオプションがフォーマットされます："
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Option Code=2 |  Reserved     |   Option Length=0             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 14: PREFER_FAILURE Option",
      "ja": "図14：PREFER_FAILUREオプション"
    },
    {
      "indent": 6,
      "text": "Option Name: PREFER_FAILURE Number: 2 Purpose: indicates that the PCP server should not create an alternative mapping if the suggested external port and address cannot be mapped. Valid for Opcodes: MAP Length: 0 May appear in: request. May appear in response only if it appeared in the associated request. Maximum occurrences: 1",
      "ja": "オプション名：PREFER_FAILURE数：2目的：提案の外部ポートとアドレスをマッピングすることができない場合はPCPサーバは、代替マッピングを作成するべきではないことを示しています。 MAPの長さ：：オペコードのための有効な要求：0で表示されることがあります。それが関連する要求に登場した場合にのみ対応して表示されることがあります。最大出現：1"
    },
    {
      "indent": 3,
      "text": "The result code CANNOT_PROVIDE_EXTERNAL is returned if the suggested external address, protocol, and port cannot be mapped. This can occur because the external port is already mapped to another host's outbound dynamic mapping, an inbound dynamic mapping, a static mapping, or the same internal address, protocol, and port already have an outbound dynamic mapping that is mapped to a different external port than suggested. This can also occur because the external address is no longer available (e.g., due to renumbering). The server MAY set the lifetime in the response to the remaining lifetime of the conflicting mapping + TIME_WAIT [RFC0793], rounded up to the next larger integer number of seconds.",
      "ja": "提案外部アドレス、プロトコル、およびポートをマッピングすることができない場合、結果コードCANNOT_PROVIDE_EXTERNALが返されます。外部ポートがすでに他のホストのアウトバウンド動的マッピング、インバウンド動的マッピング、静的マッピング、または同一の内部アドレス、プロトコルにマッピングされ、ポートが既に別の外部ポートにマッピングされるアウトバウンド動的マッピングを持っているために発生する可能性があります提案より。外部アドレスが（リナンバリングのために、例えば）は、もはや利用可能であるので、これも発生しないことができます。サーバは競合マッピング+ TIME_WAIT [RFC0793]の残りの寿命に応じて寿命を設定してもよい、秒の次に大きい整数に切り上げ。"
    },
    {
      "indent": 3,
      "text": "If a PCP request contains the PREFER_FAILURE option and has zero in the Suggested External Port field, then it is invalid. The PCP server MUST reject such a message with the MALFORMED_OPTION error code.",
      "ja": "PCP要求がPREFER_FAILUREオプションが含まれており、推奨外部ポート]フィールドにゼロを持っている場合、それは無効です。 PCPサーバはMALFORMED_OPTIONエラーコードとそのようなメッセージを拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "PCP servers MAY choose to rate-limit their handling of PREFER_FAILURE requests, to protect themselves from a rapid flurry of 65535 consecutive PREFER_FAILURE requests from clients probing to discover which external ports are available.",
      "ja": "PCPサーバは、利用可能な外部のどのポートを発見するために、プロービングクライアントから65535個の連続PREFER_FAILURE要求の急激な突風から身を守るために、レート制限にPREFER_FAILURE要求の彼らの取り扱いを選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "There can exist a race condition between the MAP Opcode using the PREFER_FAILURE option and Mapping Update (Section 14.2). For example, a previous host on the local network could have previously had the same internal address, with a mapping for the same internal port. At about the same moment that the current host sends a MAP Request using the PREFER_FAILURE option, the PCP server could send a spontaneous Mapping Update for the old mapping due to an external configuration change, which could appear to be a reply to the new mapping request. Because of this, the PCP client MUST validate that the external IP address, protocol, port, and nonce in a success response match the associated suggested values from the request. If they do not match, it is because the Mapping Update was sent before the MAP request was processed.",
      "ja": "PREFER_FAILUREオプションおよびマッピングの更新（セクション14.2）を使用して、MAPのオペコード間の競合状態が存在することができます。たとえば、ローカルネットワーク上の前のホストは、以前に同じ内部ポートのマッピングと、同じ内部アドレスを持っていた可能性があります。現在のホストがPREFER_FAILUREオプションを使用してMAPリクエストを送信していることについて、同じ瞬間に、PCPサーバが原因新しいマッピング要求への応答のように見える可能性があり、外部の構成変更、古いマッピングのための自発的なマッピングの更新を送ることができます。このので、PCPクライアントは、成功応答で外部IPアドレス、プロトコル、ポート、およびナンスはリクエストから関連する推奨値と一致していることを検証する必要があります。それらが一致しない場合は、MAP要求が処理される前にマッピングの更新が送信されたので、それがあります。"
    },
    {
      "indent": 0,
      "text": "13.3. FILTER Option for MAP Opcode",
      "section_title": true,
      "ja": "13.3.  MAPオペコードのためのフィルタオプション"
    },
    {
      "indent": 3,
      "text": "This option is only used with the MAP Opcode.",
      "ja": "このオプションは、MAPのオペコードで使用されています。"
    },
    {
      "indent": 3,
      "text": "This option indicates that filtering incoming packets is desired. The protocol being filtered is indicated by the Protocol field in the MAP Request, and the remote peer IP address and remote peer port of the FILTER option indicate the permitted remote peer's source IP address and source port for packets from the Internet; other traffic from other addresses is blocked. The remote peer prefix length indicates the length of the remote peer's IP address that is significant; this allows a single option to permit an entire subnet. After processing this MAP request containing the FILTER option and generating a successful response, the PCP-controlled device will drop packets received on its public-facing interface that don't match the filter fields. After dropping the packet, if its security policy allows, the PCP-controlled device MAY also generate an ICMP error in response to the dropped packet.",
      "ja": "このオプションは、着信パケットをフィルタリングすることが望まれていることを示しています。濾過されるプロトコルは、MAPリクエストにプロトコルフィールドによって示され、リモートピアのIPアドレスとフィルタオプションのリモートピアポートは、インターネットからのパケットに許可リモートピアの送信元IPアドレスと送信元ポートを示しています。他のアドレスからの他のトラフィックはブロックされます。リモートピアのプレフィックスの長さは重要であるリモートピアのIPアドレスの長さを示します。これは、サブネット全体を可能にするために、1つのオプションを可能にします。このMAP要求FILTERオプションを含む、成功した応答を生成を処理した後、PCP-制御デバイスは、フィルタフィールドに一致しないその公開に面したインターフェイス上で受信したパケットをドロップします。そのセキュリティポリシーで許可されている場合は、パケットをドロップした後、PCP-制御デバイスはまた、ドロップされたパケットに応じて、ICMPエラーを生成することがあります。"
    },
    {
      "indent": 3,
      "text": "The use of the FILTER option can be seen as a performance optimization. Since all software using PCP to receive incoming connections also has to deal with the case where it may be directly connected to the Internet and receive unrestricted incoming TCP connections and UDP packets, if it wishes to restrict incoming traffic to a specific source address or group of source addresses, such software already needs to check the source address of incoming traffic and reject unwanted traffic. However, the FILTER option is a particularly useful performance optimization for battery powered wireless devices, because it can enable them to conserve battery power by not having to wake up just to reject unwanted traffic.",
      "ja": "FILTERオプションを使用すると、パフォーマンスの最適化として見ることができます。それは、特定の送信元アドレスまたはグループに入ってくるトラフィックを制限したい場合は、着信接続を受信するためにPCPを使用しているすべてのソフトウェアは、それがインターネットに直接接続することができる場合に対処し、無制限の着信TCP接続とUDPパケットを受信することがあるので、送信元アドレスは、このようなソフトウェアは、すでに着信トラフィックの送信元アドレスをチェックして、不要なトラフィックを拒否する必要があります。それは、不要なトラフィックを拒否するだけで目を覚ますする必要がないため、バッテリ電力を節約するためにそれらを有効にすることができますので、しかし、FILTERオプションは、バッテリ駆動のワイヤレスデバイスのために特に有用でパフォーマンスの最適化です。"
    },
    {
      "indent": 3,
      "text": "The FILTER option is formatted as follows:",
      "ja": "次のようにFILTERオプションがフォーマットされます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Option Code=3 |  Reserved     |   Option Length=20            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Reserved   | Prefix Length |      Remote Peer Port         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|               Remote Peer IP address (128 bits)               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 15: FILTER Option Layout",
      "ja": "図15：フィルタオプションのレイアウト"
    },
    {
      "indent": 3,
      "text": "These fields are described below:",
      "ja": "これらのフィールドは以下の通りであります："
    },
    {
      "indent": 3,
      "text": "Reserved: 8 reserved bits, MUST be sent as 0 and MUST be ignored when received.",
      "ja": "予約：8つの予約ビットを0として送らなければならなくて、受信時に無視されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Prefix Length: indicates how many bits of the IPv4 or IPv6 address are relevant for this filter. The value 0 indicates \"no filter\", and will remove all previous filters. See below for detail.",
      "ja": "プレフィックス長は：IPv4またはIPv6アドレスのビット数は、このフィルタに関連しているかを示します。値0は「何のフィルタ」を示していない、と以前のすべてのフィルタを削除します。詳細については、以下を参照してください。"
    },
    {
      "indent": 3,
      "text": "Remote Peer Port: the port number of the remote peer. The value 0 indicates \"all ports\".",
      "ja": "リモートピアポート：リモートピアのポート番号。値0は、「すべてのポート」を示しています。"
    },
    {
      "indent": 3,
      "text": "Remote Peer IP address: The IP address of the remote peer.",
      "ja": "リモートピアのIPアドレス：リモートピアのIPアドレス。"
    },
    {
      "indent": 6,
      "text": "Option Name: FILTER Number: 3 Purpose: specifies a filter for incoming packets Valid for Opcodes: MAP Length: 20 octets May appear in: request. May appear in response only if it appeared in the associated request. Maximum occurrences: as many as fit within maximum PCP message size",
      "ja": "オプション名：FILTER番号：3目的：オペコードの有効な着信パケットのためのフィルタを指定します：MAPの長さ：要求：20個のオクテットが表示されることがあります。それが関連する要求に登場した場合にのみ対応して表示されることがあります。最大出現：最大PCPのメッセージサイズに収まる限り多くの"
    },
    {
      "indent": 3,
      "text": "The Prefix Length indicates how many bits of the address are used for the filter. For IPv4 addresses (which are encoded using the IPv4-mapped address format (::FFFF:0:0/96)), this means valid prefix lengths are between 96 and 128 bits, inclusive. That is, add 96 to the IPv4 prefix length. For IPv6 addresses, valid prefix lengths are between 0 and 128 bits, inclusive. Values outside those ranges cause the PCP server to return the MALFORMED_OPTION result code.",
      "ja": "プレフィックス長はアドレスのビット数は、フィルタに使用されているかを示します。 IPv4アドレスのための（IPv4射影アドレス形式を使用して符号化される（:: FFFF：0：0/96））、これは、有効なプレフィクス長を含め96ないし128ビットであることを意味します。つまり、IPv4のプレフィックス長に96を加えます。 IPv6アドレスの場合は、有効なプレフィックス長は、0〜128のビットは、含まれています。これらの範囲外の値はMALFORMED_OPTION結果コードを返すために、PCPサーバを引き起こします。"
    },
    {
      "indent": 3,
      "text": "If multiple occurrences of the FILTER option exist in the same MAP request, they are processed in the order received (as per normal PCP option processing), and they MAY overlap the filtering requested. If there is an existing mapping (with or without a filter) and the server receives a MAP request with FILTER, the filters indicated in the new request are added to any existing filters. If a MAP request has a lifetime of 0 and contains the FILTER option, the error MALFORMED_OPTION is returned.",
      "ja": "FILTERオプションの複数のオカレンスが、同じMAP要求に存在する場合、それらは、（通常のPCPオプション処理ごとに）受信した順序で処理され、それらは要求されたフィルタリングを重複してもよいです。そこに既存のマッピングは、（フィルタの有無にかかわらず）は、サーバがフィルタを有するMAPリクエストを受信した場合、新たな要求に示されるフィルタは、既存のフィルタに追加されます。 MAP要求が0の寿命を持ち、FILTERオプションが含まれている場合は、エラーMALFORMED_OPTIONが返されます。"
    },
    {
      "indent": 3,
      "text": "If any occurrences of the FILTER option in a request packet are not successfully processed then an error is returned (e.g., MALFORMED_OPTION if one of the options was malformed) and as with other PCP errors, returning an error causes no state to be changed in the PCP server or in the PCP-controlled device.",
      "ja": "要求パケットにおけるFILTERオプションのいずれかの発生に成功、その後に処理されていない場合（オプションのいずれかが不正だった場合など、MALFORMED_OPTION）エラーが返され、他のPCPのエラーと同様に、エラーを返すことは何も状態は変更しないことになりPCPサーバまたはPCP-制御機器インチ"
    },
    {
      "indent": 3,
      "text": "To remove all existing filters, the Prefix Length 0 is used. There is no mechanism to remove a specific filter.",
      "ja": "すべての既存のフィルタを削除するには、プレフィックス長0が使用されています。特定のフィルタを削除するメカニズムはありません。"
    },
    {
      "indent": 3,
      "text": "To change an existing filter, the PCP client sends a MAP request containing two FILTER options, the first option containing a prefix length of 0 (to delete all existing filters) and the second containing the new remote peer's IP address, protocol, and port. Other FILTER options in that PCP request, if any, add more allowed remote peers.",
      "ja": "既存のフィルタを変更するには、PCPクライアントは、2つのフィルタオプション、（既存のすべてのフィルタを削除するには）0のプレフィックス長を含む第一の選択肢と新しいリモートピアのIPアドレス、プロトコル、およびポートを含む第二を含むMAP要求を送信します。そのPCP要求における他のフィルタオプションは、もしあれば、より多くの許可リモートピアを追加します。"
    },
    {
      "indent": 3,
      "text": "The PCP server or the PCP-controlled device is expected to have a limit on the number of remote peers it can support. This limit might be as small as one. If a MAP request would exceed this limit, the entire MAP request is rejected with the result code EXCESSIVE_REMOTE_PEERS, and the state on the PCP server is unchanged.",
      "ja": "PCPサーバまたはPCP-制御デバイスは、それがサポートできるリモートピアの数に制限を持つことが期待されています。この制限は、1と小さいかもしれません。 MAP要求がこの制限を超えてしまう場合は、全体MAP要求は結果コードEXCESSIVE_REMOTE_PEERSで拒否し、PCPサーバ上の状態が変更されません。"
    },
    {
      "indent": 3,
      "text": "All PCP servers MUST support at least one filter per MAP mapping.",
      "ja": "すべてのPCPサーバは、MAPマッピングごとに少なくとも1つのフィルタをサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "14. Rapid Recovery",
      "section_title": true,
      "ja": "14.急速な回復"
    },
    {
      "indent": 3,
      "text": "PCP includes a rapid recovery feature, which allows PCP clients to repair failed mappings within seconds, rather than the minutes or hours it might take if they relied solely on waiting for the next routine renewal of the mapping. Mapping failures may occur when a NAT gateway is rebooted and loses its mapping state, or when a NAT gateway has its external IP address changed so that its current mapping state becomes invalid.",
      "ja": "PCPは、PCPのクライアントではなく、彼らがマッピングの次のルーチン更新を待っているだけに依存していた場合、それがかかることがあります数分または数時間よりも、数秒以内に失敗したマッピングを修復することができ、迅速なリカバリ機能を、含まれています。マッピング障害はNATゲートウェイが再起動されたときに発生し、そのマッピング状態を失い、またはNATゲートウェイがある場合、現在のマッピング状態が無効になるように、その外部IPアドレスが変更されてもよいです。"
    },
    {
      "indent": 3,
      "text": "The PCP rapid recovery feature enables users to, for example, connect to remote machines using ssh, and then reboot their NAT or firewall device (or even replace it with completely new hardware) without losing their established ssh connections.",
      "ja": "PCPの迅速なリカバリ機能は、彼らの確立ssh接続を失うことなく、例えば、SSHを使ってリモートマシンに接続し、そのNATやファイアウォールデバイスを再起動する（あるいは完全に新しいハードウェアと交換）することができます。"
    },
    {
      "indent": 3,
      "text": "Use of PCP rapid recovery is a performance optimization to PCP's routine self-healing. Without rapid recovery, PCP clients will still recreate their correct state when they next renew their mappings, but this routine self-healing process may take hours rather than seconds, and will probably not happen fast enough to prevent active TCP connections from timing out.",
      "ja": "PCPの迅速な回復の使用は、PCPのルーチンの自己回復にパフォーマンスの最適化です。彼らは次の自分のマッピングを更新したときに急速な回復がなければ、PCPクライアントはまだ彼らの正しい状態を再作成しますが、このルーチン自己治癒過程ではなく秒よりも時間がかかることがあり、おそらくタイムアウトからアクティブなTCP接続を防止するのに十分なほど高速では発生しません。"
    },
    {
      "indent": 3,
      "text": "There are two mechanisms to perform rapid recovery, described below. Failing to implement and deploy a rapid recovery mechanism will encourage application developers to feel the need to refresh their PCP state more frequently than necessary, causing more network traffic. Therefore, a PCP server that can lose state (e.g., due to reboot) or might have a mapping change (e.g., due to IP renumbering) MUST implement either the Announce Opcode or the Mapping Update mechanism and SHOULD implement both mechanisms.",
      "ja": "下記の迅速なリカバリを実行するには、2つのメカニズムがあります。急速な回復メカニズムを実装して展開しないと、より多くのネットワークトラフィックを引き起こして、より頻繁に必要以上に自分のPCPの状態をリフレッシュする必要性を感じるようにアプリケーション開発を奨励します。したがって、（例えば、再起動による）状態を失うことができるか、マッピングの変更があるかもしれないPCPサーバ（例えば、原因IPの再ナンバリングには）のいずれかを実装オペコードやマッピングの更新メカニズムを発表し、両方のメカニズムを実装する必要がありますしなければなりません。"
    },
    {
      "indent": 0,
      "text": "14.1. ANNOUNCE Opcode",
      "section_title": true,
      "ja": "14.1. オペコードを発表"
    },
    {
      "indent": 3,
      "text": "This rapid recovery mechanism uses the ANNOUNCE Opcode. When the PCP server loses its state (e.g., it lost its state when rebooted), it resets its Epoch time to its initial starting value (usually zero) and sends the ANNOUNCE response to the link-scoped multicast address (specific address explained below) if a multicast network exists on its local interface, or, if configured with the IP address(es) and port(s) of PCP client(s), it sends unicast ANNOUNCE responses to those address(es) and port(s). This means ANNOUNCE may not be available on all networks (such as networks without a multicast link between the PCP server and its PCP clients). Additionally, an ANNOUNCE request can be sent (unicast) by a PCP client that elicits a unicast ANNOUNCE response like any other Opcode.",
      "ja": "この急速な回復メカニズムは、オペコードを発表使用しています。 PCPサーバはその状態を失ったとき（再起動時に例えば、それはその状態を失った）、それは（特定のアドレスは、以下に説明する）その最初の開始値（通常はゼロ）にそのエポックの時間をリセットし、リンクスコープのマルチキャストアドレスにANNOUNCE応答を送信しますマルチキャストネットワークは、そのローカルインターフェイス上に存在する場合、またはPCPクライアント（複数可）のIPアドレス（複数可）とポート（複数可）で構成されている場合、それはユニキャストは、それらのアドレス（複数可）とポート（複数可）への対応を発表送信します。これは、（PCPサーバとそのPCPクライアント間のマルチキャストリンクせずに、このようなネットワークなど）すべてのネットワーク上で使用できない場合がありANNOUNCEを意味します。また、ANNOUNCE要求をユニキャストが他のオペコードのような応答を誘発するANNOUNCE PCPクライアントによって（ユニキャスト）を送信することができます。"
    },
    {
      "indent": 3,
      "text": "Upon receiving PCP response packets with an anomalous Epoch time, clients deduce that the PCP server lost state and recreate their lost mappings.",
      "ja": "異常エポック時間でPCPの応答パケットを受信すると、クライアントは、PCPサーバが状態を失い、その失われたマッピングを再作成することを推測します。"
    },
    {
      "indent": 0,
      "text": "14.1.1. ANNOUNCE Operation",
      "section_title": true,
      "ja": "14.1.1. 操作を発表"
    },
    {
      "indent": 3,
      "text": "The PCP ANNOUNCE Opcode requests and responses have no Opcode-specific payload (that is, the length of the Opcode-specific data is zero). The Requested Lifetime field of requests and Lifetime field of responses are both set to 0 on transmission and ignored on reception.",
      "ja": "PCPは、オペコード要求と応答をANNOUNCEないオペコード固有のペイロード（すなわち、オペコード固有のデータの長さがゼロである）を有していません。要求と応答の生涯分野の要求寿命フィールドは、両方の送信時に0に設定されて、レセプションで無視されます。"
    },
    {
      "indent": 3,
      "text": "If a PCP server receives an ANNOUNCE request, it first parses it and generates a SUCCESS if parsing and processing of ANNOUNCE is successful. An error is generated if the client's IP Address field does not match the packet source address, or the request packet is otherwise malformed, such as packet length less than 24 octets. Note that, in the future, options MAY be sent with the PCP ANNOUNCE Opcode; PCP clients and servers need to be prepared to receive options with the ANNOUNCE Opcode.",
      "ja": "PCPサーバはANNOUNCE要求を受信した場合、それは最初にそれを解析し、解析およびANNOUNCEの処理が成功した場合にSUCCESSを生成します。クライアントのIPアドレスフィールドは、パケットの送信元アドレスと一致しない場合は、エラーが生成され、または要求パケットは、24オクテット未満のパケット長として、それ以外の場合は不正な形式です。なお、将来的には、オプションは、オペコードを発表PCPを用いて送信することができます。 PCPのクライアントとサーバはANNOUNCEオペコードとオプションを受け取るために準備する必要があります。"
    },
    {
      "indent": 6,
      "text": "Discussion: Client-to-server request messages are sent, from any client source port, to listening UDP port 5351 on the server; server-to-client multicast notifications are sent from the server's UDP port (5351) to listening UDP port 5350 on the client. The reason the same listening UDP port is not used for both purposes is that a single device may have multiple roles. For example, a multi-function home gateway that provides NAT service (PCP server) may also provide printer sharing (which wants a PCP client), or a home computer (PCP client) may also provide \"Internet Sharing\" (NAT) functionality (which needs to offer PCP service). Such devices need to act as both a PCP server and a PCP client at the same time, and the software that implements the PCP server on the device may not be the same software component that implements the PCP client. The software that implements the PCP server needs to listen for unicast client requests, whereas the software that implements the PCP client needs to listen for multicast restart announcements. In many networking APIs it is difficult or impossible to have two independent clients listening for both unicasts and multicasts on the same port at the same time. For this reason, two ports are used.",
      "ja": "ディスカッション：クライアントからサーバーへのリクエストメッセージは、サーバー上のUDPポート5351をリスニングし、任意のクライアントの送信元ポートから、送信されます。サーバーからクライアントへのマルチキャスト通知は、クライアント上でUDPポート5350をリスニングし、サーバーのUDPポート（5351）から送信されます。同じリスニングUDPポートが両方の目的のために使用されていない理由は、単一のデバイスが複数の役割を持っているかもしれないということです。たとえば、NATサービスを提供して多機能ホームゲートウェイ（PCPサーバ）も（PCPクライアントを望んでいる）プリンタの共有を提供することができる、または自宅のコンピュータ（PCPクライアント）も（「インターネット共有」（NAT）機能を提供することができます。これは）PCPサービスを提供する必要があります。このようなデバイスは、PCPサーバと同時にPCPクライアント、およびPCPクライアントを実装し、同じソフトウェアコンポーネントではないかもしれない、デバイス上のPCPサーバを実装するソフトウェアの両方として機能する必要があります。 PCPクライアントを実装するソフトウェアは、マルチキャスト再起動の発表を聞く必要があるのに対し、PCPサーバを実装するソフトウェアは、ユニキャストクライアントの要求をリッスンする必要があります。多くのネットワークAPIには、同時に同じポートで両方のユニキャストとマルチキャストをリッスン二つの独立したクライアントを持たせることが困難または不可能です。このため、2つのポートが使用されています。"
    },
    {
      "indent": 0,
      "text": "14.1.2. Generating and Processing a Solicited ANNOUNCE Message",
      "section_title": true,
      "ja": "14.1.2. 生成と要請アナウンスメッセージを処理"
    },
    {
      "indent": 3,
      "text": "The PCP ANNOUNCE Opcode MAY be sent (unicast) by a PCP client. The Requested Lifetime value MUST be set to zero.",
      "ja": "PCPは、オペコードは、PCPクライアントで（ユニキャスト）を送るかもしれ発表しました。要求されたライフタイム値をゼロに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the PCP server receives the ANNOUNCE Opcode and successfully parses and processes it, it generates SUCCESS response with an assigned lifetime of zero.",
      "ja": "PCPサーバはANNOUNCEオペコードを受信し、正常に解析し、それを処理するとき、それはゼロの割り当てられた寿命の成功の応答を生成します。"
    },
    {
      "indent": 3,
      "text": "This functionality allows a PCP client to determine a server's Epoch, or to determine if a PCP server is running, without changing the server's state.",
      "ja": "この機能は、PCPのクライアントがサーバーのエポックを決定するために、またはPCPサーバは、サーバの状態を変更せずに、実行されているかどうかを決定することができます。"
    },
    {
      "indent": 0,
      "text": "14.1.3. Generating and Processing an Unsolicited ANNOUNCE Message",
      "section_title": true,
      "ja": "14.1.3. 迷惑アナウンスメッセージを生成処理"
    },
    {
      "indent": 3,
      "text": "When sending unsolicited responses, the ANNOUNCE Opcode MUST have result code equal to zero (SUCCESS), and the packet MUST be sent from the unicast IP address and UDP port number on which PCP requests are received (so that the PCP response processing described in Section 8.3 will accept the message). This message is most typically multicast, but can also be unicast. Multicast PCP restart announcements are sent to 224.0.0.1:5350 and/or [ff02::1]:5350, as described below. Sending PCP restart announcements via unicast requires that the PCP server know the IP address(es) and port(s) of its listening clients, which means that sending PCP restart announcements via unicast is only applicable to PCP servers that retain knowledge of the IP address(es) and port(s) of their clients even after they otherwise lose the rest of their state.",
      "ja": "未承諾の応答を送信するとき、オペコードがゼロに等しい結果コード（成功）が必要ANNOUNCE、及びPCP応答処理のセクションで説明するように、パケットは、ユニキャストIPアドレスとPCP要求が受信されたUDPポート番号（から送らなければなりません8.3）は、メッセージを受け付けます。このメッセージは、最も典型的には、マルチキャストではなく、ユニキャストすることができます。以下に説明するように、5350：マルチキャストPCP再始動アナウンスは224.0.0.1:5350及び/又は[FF02 :: 1]に送信されます。ユニキャストPCP再開のアナウンスを送信すると、ユニキャストPCP再開のアナウンスを送信すると、IPアドレスの知識を保持PCPサーバにのみ適用可能であることを意味し、PCPサーバは、そのリスニングクライアントのIPアドレス（複数可）とポート（複数可）を知っている必要が（複数可）と、彼らはそれ以外の場合はそれらの状態の残りの部分を失った後も、彼らのクライアントのポート（複数可）。"
    },
    {
      "indent": 3,
      "text": "When a PCP server device that implements this functionality reboots, restarts its NAT engine, or otherwise enters a state where it may have lost some or all of its previous mapping state (or enters a state where it doesn't even know whether it may have had prior state that it lost), it MUST inform PCP clients of this fact by unicasting or multicasting a gratuitous PCP ANNOUNCE Opcode response packet, as shown below, via paths over which it accepts PCP requests. If sending a multicast ANNOUNCE message, a PCP server device that accepts PCP requests over IPv4 sends the Restart Announcement to the IPv4 multicast address 224.0.0.1:5350 (224.0.0.1 is the All Hosts multicast group address), and a PCP server device that accepts PCP requests over IPv6 sends the Restart Announcement to the IPv6 multicast address [ff02::1]:5350 (ff02::1 is for all nodes on the local segment). A PCP server device that accepts PCP requests over both IPv4 and IPv6 sends a pair of Restart Announcements, one to each multicast address. If sending a unicast ANNOUNCE messages, it sends ANNOUNCE response message to the IP address(es) and port(s) of its PCP clients. To accommodate packet loss, the PCP server device MAY transmit such packets (or packet pairs) up to ten times (with an appropriate Epoch Time value in each to reflect the passage of time between transmissions) provided that the interval between the first two notifications is at least 250 ms, and the interval between subsequent notification at least doubles.",
      "ja": "この機能のリブートを実装PCPサーバ装置は、そのNATエンジンを再起動する、またはそれ以外の場合は、それも、それが持っているかどうかわからない状態をその前のマッピング状態の一部またはすべてを失った（または入力した可能性状態になるとそれが失われたことを以前の状態）は、以下に示すように、それはそれはPCPの要求を受け入れた上で経路を介して、ユニキャストまたは無償PCPは、オペコード応答パケットを発表マルチキャストによってこの事実のPCPクライアントに通知する必要がありました。マルチキャストを送信するメッセージを発表した場合、IPv4の上PCPの要求を受け入れPCPサーバ装置は、IPv4に再起動のお知らせを送る224.0.0.1:5350（224.0.0.1は、すべてのマルチキャストグループアドレスをホストである）、およびPCPサーバ装置マルチキャストアドレスIPv6は[FF02 :: 1]マルチキャストアドレスIPv6への再起動のお知らせを送る上PCP要求を受け入れ：5350を（FF02 :: 1は、ローカルセグメント上のすべてのノードのためのものです）。 IPv4とIPv6の両方の上にPCPの要求を受け入れPCPサーバ装置は、再起動のお知らせ、各マルチキャストアドレスへの1つのペアを送信します。ユニキャストAnnounceメッセージを送信した場合、それはそのPCPクライアントのIPアドレス（複数可）とポート（複数可）に応答メッセージを発表送信します。パケット損失に対応するために、PCPサーバ装置は、（送信間の時間の経過を反映するためにそれぞれに適切なエポック時間値を持つ）に10回までのようなパケット（またはパケットペア）を送信することができる最初の2つの通知の間隔であることを条件とします少なくとも250秒、及び少なくとも倍に後続の通知の間隔。"
    },
    {
      "indent": 3,
      "text": "A PCP client that sends PCP requests to a PCP server via a multicast-capable path, and implements the Restart Announcement feature, and wishes to receive these announcements, MUST listen to receive these PCP Restart Announcements (gratuitous PCP ANNOUNCE Opcode response packets) on the appropriate multicast-capable interfaces on which it sends PCP requests, and MAY also listen for unicast announcements from the server too, (using the UDP port it already uses to issue unicast PCP requests to, and receive unicast PCP responses from, that server). A PCP client device that sends PCP requests using IPv4 listens for packets sent to the IPv4 multicast address 224.0.0.1:5350. A PCP client device that sends PCP requests using IPv6 listens for packets sent to the IPv6 multicast address [ff02::1]:5350. A PCP client device that sends PCP requests using both IPv4 and IPv6 listens for both types of Restart Announcement. The SO_REUSEPORT socket option or equivalent should be used for the multicast UDP port, if required by the host OS to permit multiple independent listeners on the same multicast UDP port.",
      "ja": "マルチキャスト可能な経路を介して、PCPサーバにPCP要求を送信し、再起動のお知らせ機能を実装し、これらのアナウンスを受信したいPCPクライアントは、これらのPCPの再起動のお知らせを受け取るに耳を傾ける必要があります（無償PCPは、オペコードの応答パケットを発表）にそれはPCP要求を送信し、また、（それが既ににユニキャストPCP要求を発行するために使用するUDPポートを使用して、そのサーバーからユニキャストPCP応答を受け取る）、あまりにもサーバからユニキャストの発表を聞くことがある上、適切なマルチキャスト対応のインターフェイス。 IPv4を使用してPCP要求を送信PCPクライアントデバイスは、IPv4マルチキャストアドレス224.0.0.1:5350に送信されるパケットをリッスンします。 5350：IPv6を使用してPCP要求を送信PCPクライアントデバイスは、[FF02 :: 1] IPv6のマルチキャストアドレスに送信されたパケットをリッスンします。 IPv4とIPv6の両方を使用してPCP要求を送信PCPクライアントデバイスは、再起動の発表の両方のタイプを待ち受けます。ホストOSで必要な場合SO_REUSEPORTソケットオプションまたは同等のは、同じマルチキャストUDPポート上で複数の独立したリスナーを可能にするために、マルチキャストUDPポートを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon receiving a unicasted or multicasted PCP ANNOUNCE Opcode response packet, a PCP client MUST (as it does with all received PCP response packets) inspect the announcement's source IP address, and if the Epoch Time value is outside the expected range for that server, it MUST wait a random amount of time between 0 and 5 seconds (to prevent synchronization of all PCP clients), then for all PCP mappings it made at that server address the client issues new PCP requests to recreate any lost mapping state. The use of the Suggested External IP Address and Suggested External Port fields in the client's renewal requests allows the client to remind the restarted PCP server device of what mappings the client had previously been given, so that in many cases the prior state can be recreated. For PCP server devices that reboot relatively quickly it is usually possible to reconstruct lost mapping state fast enough that existing TCP connections and UDP communications do not time out, and continue without failure. As for all PCP response messages, if the Epoch Time value is within the expected range for that server, the PCP client does not recreate its mappings. As for all PCP response messages, after receiving and validating the ANNOUNCE message, the client updates its own Epoch time for that server, as described in Section 8.5.",
      "ja": "ユニキャストまたはマルチキャストPCPを受信するとオペコード応答パケット、PCPクライアントMUSTを発表（それはすべてのPCPの応答パケットを受信して​​いたように）発表の送信元IPアドレスを検査し、エポック時間値がそのサーバーの予想範囲外にある場合は、それそれはそのサーバのアドレスに任意の失われたマッピング状態を再現する新しいPCP要求クライアントの問題を作ったすべてのPCPのマッピングのために、その後、（すべてのPCPクライアントの同期化を防ぐために）0と5秒の間のランダムな時間を待たなければなりません。クライアントの更新要求で提案されている外部IPアドレスおよび推奨外部ポートフィールドの使用は、クライアントが、多くの場合、以前の状態を再現することができるように、クライアントは以前に、与えられていたマッピングが何の再起動PCPサーバ装置を思い出させることができます。比較的速やかに再起動PCPサーバ装置の場合には、既存のTCP接続とUDP通信がタイムアウトし、失敗せずに続行していないことを十分に速く失われたマッピング状態を再構築することが通常可能です。エポック時間の値は、そのサーバの予想範囲内であれば、すべてのPCPの応答メッセージについては、PCPのクライアントは、そのマッピングを再作成しません。 8.5節で説明したように、すべてのPCPの応答メッセージについては、アナウンスメッセージを受信して​​検証した後、クライアントは、そのサーバーの独自のエポックタイムを更新します。"
    },
    {
      "indent": 0,
      "text": "14.2. PCP Mapping Update",
      "section_title": true,
      "ja": "14.2.  PCPのマッピングを更新"
    },
    {
      "indent": 3,
      "text": "This rapid recovery mechanism is used when the PCP server remembers its state and determines its existing mappings are invalid (e.g., IP renumbering changes the external IP address of a PCP-controlled NAT).",
      "ja": "PCPサーバはその状態を記憶し、その既存のマッピングは、（例えば、IPの再ナンバリングがPCP-制御NATの外部IPアドレスを変更する）無効である判断した場合、この急速な回復メカニズムが使用されています。"
    },
    {
      "indent": 3,
      "text": "It is anticipated that servers that are routinely reconfigured by an administrator or have their WAN address changed frequently will implement this feature (e.g., residential CPE routers). It is anticipated that servers that are not routinely reconfigured will not implement this feature (e.g., service provider-operated CGN).",
      "ja": "日常の管理者によって再構成されているか、彼らのWANアドレスが頻繁に変更されているサーバーは、この機能（例えば、住宅用CPEルータ）を実装することが予想されます。日常的に再構成されていないサーバーでは、この機能を実装していないことが予想される（例えば、サービスプロバイダCGN-運営します）。"
    },
    {
      "indent": 3,
      "text": "If a PCP server device has not forgotten its mapping state, but for some other reason has determined that some or all of its mappings have become unusable (e.g., when a home gateway is assigned a different external IPv4 address by the upstream DHCP server), then the PCP server device automatically repairs its mappings and notifies its clients by following the procedure described below.",
      "ja": "PCPサーバ装置は、そのマッピング状態を忘れていない場合は、他のいくつかの理由でそのマッピングの一部または全部が使用できなくなったと判断している（例えば、ホームゲートウェイは、上流のDHCPサーバによって異なる外部IPv4アドレスを割り当てられている場合）、その後、PCPサーバ装置自動的に修復そのマッピングとは、以下の手順に従うことによって、クライアントに通知します。"
    },
    {
      "indent": 3,
      "text": "For PCP-managed mappings, for each one the PCP server device should update the external IP address and external port to appropriate available values, and then send unicast PCP MAP or PEER responses (as appropriate for the mapping) to inform the PCP client of the new external IP address and external port. Such unsolicited responses are identical to the MAP or PEER responses normally returned in response to client MAP or PEER requests, containing newly updated External IP Address and External Port values, and are sent to the same client IP address and port that the PCP server used to send the prior response for that mapping. If the earlier associated request contained the THIRD_PARTY option, the THIRD_PARTY option MUST also appear in the Mapping Update as it is necessary for the PCP client to disambiguate the response. If the earlier associated request contained the PREFER_FAILURE option, and the same external IP address, protocol, and port cannot be provided, the error CANNOT_PROVIDE_EXTERNAL SHOULD be sent. If the earlier associated request contained the FILTER option, the filters are moved to the new mapping and the FILTER option is sent in the Mapping Update response. Non-mandatory options SHOULD NOT be sent in the Mapping Update response.",
      "ja": "PCP-管理マッピングの場合、それぞれに対してPCPサーバ装置は、利用可能な値を適切な外部IPアドレスおよび外部ポートを更新する必要があり、その後のPCPクライアントに通知する（マッピングのために必要に応じて）ユニキャストPCPのMAPやPEER応答を送信します新しい外部IPアドレスおよび外部ポート。このような迷惑応答が新たに更新された外部IPアドレスおよび外部ポート値を含む通常のクライアントMAPまたはピアの要求に応答して返さMAPまたはPEER応答と同一であり、PCPサーバはに使用したのと同じクライアントのIPアドレスとポートに送信されますそのマッピングの前に応答を送信します。以前の関連する要求がTHIRD_PARTYオプションが含まれている場合PCPクライアントが応答を明確にすることが必要であるとして、THIRD_PARTYオプションもマッピング更新に現れなければなりません。以前の関連する要求がPREFER_FAILUREオプションが含まれていた場合、および同一の外部IPアドレス、プロトコル、およびポートを提供することができない、エラーCANNOT_PROVIDE_EXTERNALを送ってください。以前の関連する要求がFILTERオプションが含まれていた場合、フィルタは、新しいマッピングに移動され、フィルタオプションがマッピング更新応答で送信されます。非必須オプションは、マッピング更新応答で送るべきではありません。"
    },
    {
      "indent": 6,
      "text": "Discussion: It could have been possible to design this so that the PCP server (1) sent an ANNOUNCE Opcode to the PCP client, the PCP client reacted by (2) sending a new MAP request and (3) receiving a MAP response. Instead, the server can create a shortcut for that design by simply sending the message it would have sent in (3).",
      "ja": "ディスカッション：PCPサーバ（1）PCPクライアント、（2）新しいMAPリクエストを送信し、（3）MAP応答を受信することにより、反応PCPクライアントにANNOUNCEオペコードを送ったように、これを設計することが可能だったかもしれません。代わりに、サーバは、単にそれが（3）に送信されていたメッセージを送信することにより、その設計のためのショートカットを作成することができます。"
    },
    {
      "indent": 3,
      "text": "To accommodate packet loss, the PCP server device SHOULD transmit such packets three times, with an appropriate Epoch Time value in each to reflect the passage of time between transmissions. The interval between the first two notifications MUST be at least 250 ms, and the third packet after a 500-ms interval. Once the PCP server has received a refreshed state for that mapping, the PCP server SHOULD cease those retransmissions for that mapping, as it serves no further purpose to continue sending messages regarding that mapping.",
      "ja": "パケット損失に対応するために、PCPサーバ装置は、送信間の時間の経過を反映するためにそれぞれに適切なエポック時刻値と、そのようなパケットを3回送信しなければなりません。最初の2つの通知の間隔は、少なくとも250ミリ秒、500ミリ秒間隔の後の第3のパケットでなければなりません。 PCPサーバは、そのマッピングのためのリフレッシュ状態を受信したら、それはそのマッピングに関するメッセージを送り続けるためにそれ以上の目的を果たしていないとして、PCPサーバは、そのマッピングのために、これらの再送信を中止すべきです。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of such an updated MAP or PEER response, a PCP client uses the information in the response to adjust rendezvous servers or reconnect to servers, respectively. For MAP, this would mean updating the DNS entries or other address and port information recorded with some kind of application-specific rendezvous server. For PEER responses giving a CANNOT_PROVIDE_EXTERNAL error, this would typically mean establishing new connections to servers. Anytime the external address or port changes, existing TCP and UDP connections will be lost; PCP can't avoid that, but does provide immediate notification of the event to lessen the impact.",
      "ja": "このように更新MAPやピア・レスポンスを受信すると、PCPのクライアントは、それぞれ、ランデブーサーバを調整したり、サーバーへの再接続に応じて情報を使用しています。 MAPの場合、これはアプリケーション固有のランデブーサーバのいくつかの種類を記録したDNSエントリまたは他のアドレスとポートの情報を更新することを意味します。 PEER応答がCANNOT_PROVIDE_EXTERNALエラーを与えるために、これは通常、サーバーへの新しい接続を確立する意味します。いつでも外部のアドレスやポートの変更は、既存のTCPとUDPの接続が失われます。 PCPはそれを避けることはできませんが、影響を軽減するために、イベントの即時通知を提供しません。"
    },
    {
      "indent": 0,
      "text": "15. Mapping Lifetime and Deletion",
      "section_title": true,
      "ja": "15.マッピング寿命と削除"
    },
    {
      "indent": 3,
      "text": "The PCP client requests a certain lifetime, and the PCP server responds with the assigned lifetime. The PCP server MAY grant a lifetime smaller or larger than the requested lifetime. The PCP server SHOULD be configurable for permitted minimum and maximum lifetime, and the minimum value SHOULD be 120 seconds. The maximum value SHOULD be the remaining lifetime of the IP address assigned to the PCP client if that information is available (e.g., from the DHCP server), or half the lifetime of IP address assignments on that network if the remaining lifetime is not available, or 24 hours. Excessively long lifetimes can cause consumption of ports even if the internal host is no longer interested in receiving the traffic or is no longer connected to the network. These recommendations are not strict, and deployments should evaluate the trade-offs to determine their own minimum and maximum Lifetime values.",
      "ja": "PCPクライアントは、特定の寿命を要求し、PCPサーバは、割り当てられた寿命で応答します。 PCPサーバは、要求寿命より小さくても大きく寿命を付与することができます。 PCPサーバは、許容される最小および最大寿命のために設定されるべきであり、最小値は120秒であるべきです。残りの寿命が利用できない場合、その情報は、（例えば、DHCPサーバから）が利用可能であるか、そのネットワーク上のIPアドレスの割り当ての半生場合の最大値は、PCPクライアントに割り当てられたIPアドレスの残りの寿命であるべきですまたは24時間。過度に長い寿命は、内部ホストは、もはやトラフィックを受信することに興味はありませんか、もはやネットワークに接続されている場合でも、ポートの消費を引き起こすことはできません。これらの推奨事項は、厳密なものではなく、展開は、独自の最小値と最大寿命の値を決定するためにトレードオフを評価する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once a PCP server has responded positively to a MAP request for a certain lifetime, the port mapping is active for the duration of the lifetime unless the lifetime is reduced by the PCP client (to a shorter lifetime or to zero) or until the PCP server loses its state (e.g., crashes). Mappings created by PCP MAP requests are not special or different from mappings created in other ways. In particular, it is implementation-dependent if outgoing traffic extends the lifetime of such mappings beyond the PCP-assigned lifetime. PCP clients MUST NOT depend on this behavior to keep mappings active, and MUST explicitly renew their mappings as required by the Lifetime field in PCP response messages.",
      "ja": "PCPサーバは、特定の生涯のMAP要求に肯定応答した後に寿命が（短い寿命またはゼロ）又はPCPサーバまでPCPクライアントによって低減されない限り、ポートマッピングは、寿命の期間アクティブでありますその状態（例えば、クラッシュを）失います。 PCPのMAP要求によって作成されたマッピングは、特別な、または他の方法で作成したマッピングは異なるではありません。発信トラフィックは、PCP-割り当てられた寿命を超えたようなマッピングの寿命を延長する場合は特に、それは実装依存です。 PCPクライアントは、アクティブなマッピングを維持するために、この動作に依存してはなりませんし、PCPの応答メッセージにLifetimeフィールドで必要とされる明示的なマッピングを更新しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a PCP response with an absurdly long assigned lifetime, the PCP client SHOULD behave as if it received a more sane value (e.g., 24 hours), and renew the mapping accordingly, to ensure that if the static mapping is removed, the client will continue to maintain the mapping it desires.",
      "ja": "途方も長い割り当て寿命のPCP応答を受信すると、それは、より健全な値（例えば、24時間）を受けたかのように、PCPクライアントが動作する必要があり、その静的マッピングが削除された場合、確実にするために、それに応じてマッピングを更新しますクライアントは、それが望んでマッピングを維持していきます。"
    },
    {
      "indent": 3,
      "text": "An application that forgets its PCP-assigned mappings (e.g., the application or OS crashes) will request new PCP mappings. This may consume port mappings, if the application binds to a different internal port every time it runs. The application will also likely initiate new outbound TCP connections, which create implicit dynamic outbound mappings without using PCP, which will also consume port mappings. If there is a port mapping quota for the internal host, frequent restarts such as this may exhaust the quota.",
      "ja": "そのPCP-割り当てマッピング（例えば、アプリケーションやOSのクラッシュを）忘れたアプリケーションが新しいPCPマッピングを要求します。アプリケーションが異なる内部ポートにそれが実行されるたびにバインドする場合、これは、ポートマッピングを消費することがあります。また、アプリケーションは、おそらくまた、ポートマッピングを消費しますPCPを使用せずに、暗黙的な動的なアウトバウンドマッピングを作成する新しいアウトバウンドTCP接続を、開始します。内部ホストのポートマッピングクォータがある場合、このような頻繁な再起動は、クォータを排出することができます。"
    },
    {
      "indent": 3,
      "text": "To help clean PCP state, when the PCP-controlled device is collocated with the address assignment (DHCP) server, such as in a typical residential CPE, it is RECOMMENDED that when an IP address becomes invalid (e.g., the DHCP lease expires, or the DHCP client sends an explicit DHCP RELEASE) the PCP-controlled device SHOULD also discard any dynamic mapping state relating to that expired IP address.",
      "ja": "PCP-制御デバイスは、このような典型的な住宅CPEのようにアドレスの割り当て（DHCP）サーバーと併置されている場合クリーンPCP状態を支援するために、IPアドレスが例えば（無効になった場合、DHCPリースの期限が切れることが推奨され、またはDHCPクライアントは、PCP-制御デバイスはまた、期限切れのIPアドレスに関連する動的なマッピング状態を破棄すべきである）明示的なDHCPリリースを送信します。"
    },
    {
      "indent": 3,
      "text": "When using NAT, the same external port may be assigned for use by different internal hosts at different times. For example, if an internal host using an external port ceases sending traffic using that port, then its mapping may expire, and then later the same external port may be assigned to a new internal host. The new internal host could then receive incoming traffic that was intended for the previous internal host. This generally happens inadvertently, and this reassignment of the external port only happens after the current holder of the external port has ceased using it for some period of time. It would be unacceptable if an attacker could use PCP to intentionally speed up this reassignment of the external port in order to deliberately steal traffic intended for the current holder, by (i) spoofing PCP requests using the current holder's source IP address and mapping nonce to fraudulently delete the mapping or shorten its lifetime, and then (ii) subsequently claiming the external port for itself.",
      "ja": "NATを使用する場合、同一の外部ポートは、異なる時間に異なる内部ホストによる使用のために割り当てられてもよいです。外部ポートを使用して、内部ホストがそのポートを使用してトラフィックを送信しなくなると、例えば、そのマッピングが期限切れになることができ、その後、同一の外部ポートは、新しい内部ホストに割り当てることができます。新しい内部ホストは、以前の内部ホストのために意図された受信トラフィックを受け取ることができます。これは、一般的に、誤って発生し、外部ポートの現在の所有者が一定の期間のためにそれを使用して停止した後、外部ポートのこの再割り当てにのみ発生します。故意に現在の所有者を対象としたトラフィックを盗むために、攻撃者は、現在の所有者の送信元IPアドレスとマッピングnonceを使用して（I）なりすましPCP要求によって、意図的に外部ポートのこの再割り当てをスピードアップするためにPCPを使用することができればそれは受け入れられないだろう不正のマッピングを削除したり、その寿命を短くして、（II）、その後自身のために外部ポートを主張します。"
    },
    {
      "indent": 3,
      "text": "Therefore, in the simple security model, to protect against this attack, PCP MUST NOT allow a PCP request (even a PCP request that appears to come from the current holder of the mapping) to cause a mapping to expire sooner than it would naturally have expired otherwise by virtue of outbound traffic keeping the mapping active. A PCP server MUST set the lifetime of a mapping to no less than the remaining time before the mapping would expire if no further outbound traffic is seen for that mapping. This means a MAP or PEER request with lifetime of 0 will only set the assigned lifetime to 0 (i.e., delete the mapping) if the internal host had not sent a packet using that mapping for the idle-timeout time, otherwise the assigned lifetime will be the remaining idle-timeout time.",
      "ja": "したがって、簡単なセキュリティモデルでは、この攻撃から保護するために、PCPは、マッピングはすぐにそれが自然に持っているであろうよりも期限切れになる場合があります（マッピングの現在の所有者から来るように見えてもPCP要求）PCP要求を許してはなりませんアクティブ・マッピングを維持するアウトバウンドトラフィックのおかげでそれ以外の場合は有効期限が切れています。 PCPサーバは、それ以上のアウトバウンドトラフィックはそのマッピングのために見られない場合は、マッピングの有効期限が切れるでしょうまでの残り時間を下回らないにマッピングの寿命を設定しなければなりません。これは、内部ホストがアイドルタイムアウト時間のためにそのマッピングを使用してパケットを送信していなかった場合は0の生涯とMAPまたはPEERリクエストのみ、（すなわち、マッピングを削除）を0にそれ以外の場合は割り当てられた寿命を割り当てられた寿命を設定しますことを意味します残りのアイドルタイムアウト時間も。"
    },
    {
      "indent": 3,
      "text": "Finally, to reduce unwanted traffic and data corruption for both TCP and UDP, the assigned external port created by the MAP Opcode or PEER Opcode SHOULD NOT be reused for an interval equal to the reuse time limit enforced by the NAT for its implicit dynamic mappings (typically, the maximum TCP segment lifetime of 2 minutes [RFC0793]). Furthermore, to reduce port stealing attacks, the assigned external port also SHOULD NOT be reused for an interval equal to the time the PCP- controlled device would normally maintain an idle (no traffic) implicit dynamic mapping (e.g., 2 minutes for UDP [RFC4787] and 124 minutes for TCP [RFC5382]). However, within these time windows, the PCP server SHOULD allow an external port to be reclaimed by the same client, where \"same client\" means \"same internal IP address, internal port, and mapping nonce\".",
      "ja": "最後に、TCPとUDPの両方のために不要なトラフィックやデータの破損を軽減するために、MAPのオペコードまたはピアオペコードによって作成された割り当てられた外部ポートは、その暗黙のダイナミックマッピングのNAT（によって強制再使用時間の制限に等しい間隔のために再利用されるべきではありません典型的には、2分の最大TCPセグメント寿命[RFC0793]）。また、ポート窃盗攻撃を減らすために、割り当てられた外部ポートは、PCP-制御装置が正常にアイドル（トラフィックなし）暗黙的な動的マッピングを維持する時間（例えば、UDPのための2分[RFC4787に等間隔に再利用されるべきではありません]とTCP [RFC5382]のための124分）。しかし、これらの時間ウィンドウ内、PCPサーバは、「同じクライアントが」「同じ内部IPアドレス、内部ポート、およびマッピングナンス」を意味し、外部ポートは、同じクライアントによって再利用できるようにするべきです。"
    },
    {
      "indent": 0,
      "text": "15.1. Lifetime Processing for the MAP Opcode",
      "section_title": true,
      "ja": "15.1.  MAPオペコードのための生涯処理"
    },
    {
      "indent": 3,
      "text": "If the requested lifetime is zero then:",
      "ja": "要求された寿命がゼロである場合："
    },
    {
      "indent": 3,
      "text": "o If both the protocol and internal port are non-zero, it indicates a request to delete the indicated mapping immediately.",
      "ja": "プロトコルおよび内部ポートの両方が非ゼロである場合、O、それはすぐに示されるマッピングを削除するための要求を示します。"
    },
    {
      "indent": 3,
      "text": "o If the protocol is non-zero and the internal port is zero, it indicates a request to delete a previous 'wildcard' (all-ports) mapping for that protocol. The nonce MUST match the nonce used to create the 'wildcard' mapping.",
      "ja": "プロトコルが非ゼロであり、内部ポートがゼロである場合、Oは、そのプロトコルの以前の「ワイルドカード」（全ポート）のマッピングを削除するための要求を示します。ナンスは、「ワイルドカード」のマッピングを作成するために使用されるナンスと一致しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If both the protocol and internal port are zero, it indicates a request to delete a previous 'DMZ host' (all incoming traffic for all protocols) mapping. The nonce MUST match the nonce used to create the 'DMZ host' mapping.",
      "ja": "プロトコルおよび内部ポートの両方がゼロである場合、O、それは以前「DMZホスト」（すべてのプロトコルのすべての着信トラフィック）マッピングを削除するための要求を示します。ナンスは、nonceが「DMZホストのマッピングを作成するために使用されると一致しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the protocol is zero and the internal port is non-zero, then the request is invalid and the PCP server MUST return a MALFORMED_REQUEST error to the client.",
      "ja": "プロトコルはゼロで、内部ポートが非ゼロの場合、O、リクエストは無効であり、PCPサーバは、クライアントにMALFORMED_REQUESTエラーを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "In requests where the requested Lifetime is 0, the Suggested External Address and Suggested External Port fields MUST be set to zero on transmission and MUST be ignored on reception, and these fields MUST be copied into the assigned external IP address and assigned external port of the response.",
      "ja": "要求された寿命は、提案された外部アドレス0での要求と外部ポートフィールドは送信時にゼロに設定しなければならなくて、レセプションで無視しなければなりません、そして、これらのフィールドは、割り当てられた外部IPアドレスとの割り当てられた外部ポートにコピーする必要があります推奨応答。"
    },
    {
      "indent": 3,
      "text": "PCP MAP requests can only delete or shorten lifetimes of MAP-created mappings. If the PCP client attempts to delete a static mapping (i.e., a mapping created outside of PCP itself), or an outbound (implicit or PEER-created) mapping, the PCP server MUST return NOT_AUTHORIZED. If the PCP client attempts to delete a mapping that does not exist, the SUCCESS result code is returned (this is necessary for PCP to return the same response for retransmissions or duplications of the same request). If the deletion request was properly formatted and successfully processed, a SUCCESS response is generated with the protocol and internal port number copied from the request, and the response lifetime set to zero. An inbound mapping (i.e., static mapping or MAP-created dynamic mapping) MUST NOT have its lifetime reduced by transport protocol messages (e.g., TCP RST, TCP FIN). Note the THIRD_PARTY option (Section 13.1), if authorized, can also delete PCP-created MAP mappings.",
      "ja": "PCPのMAP要求は削除またはMAP-作成したマッピングの寿命を短くすることができます。 PCPクライアントは静的マッピングを削除しようとすると（即ち、PCP自体の外に作成されたマッピング）、または発信（暗黙またはピア作成）マッピングは、PCPサーバはNOT_AUTHORIZEDを返さなければなりません。 PCPのクライアントが存在しないマッピングを削除しようとすると、SUCCESS結果コードは（PCPが同じ要求の再送信または重複のために同じ応答を返すようにするために、これは必要である）が返されます。削除要求が正しくフォーマットされ、正常に処理された場合には、SUCCESS応答がゼロに設定されたプロトコル及び内部要求からコピーされたポート番号、および応答寿命で生成されます。インバウンド・マッピング（すなわち、静的マッピングまたはMAP-作成動的マッピング）は、その寿命は、トランスポートプロトコルメッセージ（例えば、TCP RST、TCP FIN）減少てはなりません。 THIRD_PARTYオプション（13.1節）を注意し、許可した場合、また、PCP-作成したMAPのマッピングを削除することができます。"
    },
    {
      "indent": 0,
      "text": "16. Implementation Considerations",
      "section_title": true,
      "ja": "16.実装に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Section 16 provides non-normative guidance that may be useful to implementers.",
      "ja": "第16節は、実装者に有用である可能性がある非規範的なガイダンスを提供します。"
    },
    {
      "indent": 0,
      "text": "16.1. Implementing MAP with EDM Port-Mapping NAT",
      "section_title": true,
      "ja": "16.1.  EDMポートマッピングNATとMAPの実装"
    },
    {
      "indent": 3,
      "text": "For implicit dynamic outbound mappings, some existing NAT devices have endpoint-independent mapping (EIM) behavior while other NAT devices have endpoint-dependent mapping (EDM) behavior. NATs that have EIM behavior do not suffer from the problem described in this section. The IETF strongly encourages EIM behavior [RFC4787][RFC5382].",
      "ja": "他のNATデバイスがエンドポイント依存性マッピング（EDM）挙動を有するが、暗黙の動的アウトバウンドマッピングのために、いくつかの既存のNATデバイスは、エンドポイント非依存マッピング（EIM）挙動を有します。 EIM挙動を有するNATは、このセクションで説明する問題に悩まされません。 IETFは強くEIMの挙動[RFC4787] [RFC5382]を奨励しています。"
    },
    {
      "indent": 3,
      "text": "In EDM NAT devices, the same external port may be used by an outbound dynamic mapping and an inbound dynamic mapping (from the same internal host or from a different internal host). This complicates the interaction with the MAP Opcode. With such NAT devices, there are two ways envisioned to implement the MAP Opcode:",
      "ja": "EDM NAT装置では、同一の外部ポートは、アウトバウンド動的マッピングとのインバウンド動的マッピング（同じ内部ホストから又は異なる内部ホストから）によって使用されてもよいです。これは、MAPのオペコードとの相互作用が複雑になります。このようNATデバイスでは、MAPのオペコードを実装するために想定される2つの方法があります。"
    },
    {
      "indent": 3,
      "text": "1. Have outbound mappings use a different set of external ports than inbound mappings (e.g., those created with MAP), thus reducing the interaction problem between them; or",
      "ja": "1.アウトバウンドマッピングは、このように、それらの間の相互作用の問題を低減する、インバウンドマッピング（例えば、MAPで作成されたもの）よりも外部ポートの異なるセットを使用してきました。または"
    },
    {
      "indent": 3,
      "text": "2. On arrival of a packet (inbound from the Internet or outbound from an internal host), first attempt to use a dynamic outbound mapping to process that packet. If none match, attempt to use an inbound mapping to process that packet. This effectively 'prioritizes' outbound mappings above inbound mappings.",
      "ja": "パケット（内部ホストからインターネットまたはアウトバウンドからのインバウンド）、そのパケットを処理するために動的なアウトバウンド・マッピングを使用する最初の試みの到着2.。どれもが一致する場合、そのパケットを処理するために、インバウンドマッピングを使用しようとします。これは、効果的にインバウンドマッピング上記のアウトバウンドのマッピング「を優先する」。"
    },
    {
      "indent": 0,
      "text": "16.2. Lifetime of Explicit and Implicit Dynamic Mappings",
      "section_title": true,
      "ja": "16.2. 明示的および暗黙のダイナミックマッピングの生涯"
    },
    {
      "indent": 3,
      "text": "No matter if a NAT is EIM or EDM, it is possible that one (or more) outbound mappings, using the same internal port on the internal host, might be created before or after a MAP request. When this occurs, it is important that the NAT honor the lifetime returned in the MAP response. Specifically, if an inbound mapping was created with the MAP Opcode, the implementation needs to ensure that termination of an outbound mapping (e.g., via a TCP FIN handshake) does not prematurely destroy the MAP-created inbound mapping.",
      "ja": "内部ホスト上の同じ内部ポートを使用してNATがEIMまたはEDMであれば、それは1つ（またはそれ以上）の可能性があるどんなにアウトバウンドマッピングは、MAP要求の前または後に作成されることがあります。これが発生すると、NATがMAP応答で返された寿命を尊重することが重要です。インバウンドマッピングはMAPオペコードを用いて作成された場合、具体的には、実装が（TCP FINハンドシェークを介して、例えば）アウトバウンドマッピングの終了を確保する必要が早期にMAP-作成インバウンドマッピングを破壊しません。"
    },
    {
      "indent": 0,
      "text": "16.3. PCP Failure Recovery",
      "section_title": true,
      "ja": "16.3.  PCPの障害回復"
    },
    {
      "indent": 3,
      "text": "If an event occurs that causes the PCP server to lose dynamic mapping state (such as a crash or power outage), the mappings created by PCP are lost. Occasional loss of state may be unavoidable in a residential NAT device that does not write transient information to non-volatile memory. Loss of state is expected to be rare in a service provider environment (due to redundant power, disk drives for storage, etc.). Of course, due to outright failure of service provider equipment (e.g., software malfunction), state may still be lost.",
      "ja": "イベントは、PCPサーバは（例えばクラッシュや停電など）の動的マッピング状態を失う原因となることが発生した場合、PCPによって作成されたマッピングが失われます。状態の臨時の損失は、不揮発性メモリへの過渡的な情報を書き込みません住宅NATデバイスでは避けられないかもしれません。状態の損失（これは冗長電源、記憶のためのディスクドライブ、等）にサービスプロバイダ環境では稀であると予想されます。もちろん、原因サービスプロバイダーの機器（例えば、ソフトウェアの誤動作）の完全故障に、状態はまだ失われることがあります。"
    },
    {
      "indent": 3,
      "text": "The Epoch time allows a client to deduce when a PCP server may have lost its state. When the Epoch Time value is observed to be outside the expected range, the PCP client can attempt to recreate the mappings following the procedures described in this section.",
      "ja": "エポック時間は、PCPサーバはその状態を失ったかもしれないときに、クライアントが推測することができます。エポック時間値が予想範囲外であることが観察された場合、PCPのクライアントは、このセクションで説明する手順を以下のマッピングを再作成しようとすることができます。"
    },
    {
      "indent": 3,
      "text": "Further analysis of PCP failure scenarios is planned for a future document [PCP-FAIL].",
      "ja": "PCPの障害シナリオのさらなる分析は、将来のドキュメント[PCP-FAIL]のために計画されています。"
    },
    {
      "indent": 0,
      "text": "16.3.1. Recreating Mappings",
      "section_title": true,
      "ja": "16.3.1. マッピングの再作成"
    },
    {
      "indent": 3,
      "text": "A mapping renewal packet is formatted identically to an original mapping request; from the point of view of the client, it is a renewal of an existing mapping; however, from the point of view of a newly rebooted PCP server, it appears as a new mapping request. In the normal process of routinely renewing its mappings before they expire, a PCP client will automatically recreate all its lost mappings.",
      "ja": "マッピング更新パケットは、元のマッピング要求と同一フォーマットさ。クライアントの観点から、それは既存のマッピングの更新です。しかし、新しく再起動PCPサーバの観点から、それは新しいマッピング要求として表示されます。有効期限が切れる前に定期的にそのマッピングを更新する通常のプロセスでは、PCPクライアントは、自動的にすべての失われたマッピングを再作成します。"
    },
    {
      "indent": 3,
      "text": "When the PCP server loses state and begins processing new PCP messages, its Epoch time is reset and begins counting again. As the result of receiving a packet where the Epoch Time field is outside the expected range (Section 8.5), indicating that a reboot or similar loss of state has occurred, the client can renew its port mappings sooner, without waiting for the normal routine renewal time.",
      "ja": "PCPサーバが状態を失い、新しいPCPメッセージの処理を開始すると、そのエポック時間がリセットされ、再びカウントを開始します。エポック時刻フィールドは状態のリブートまたは同様の損失が発生したことを示す、予想される範囲（セクション8.5）の外側にあるパケットを受信した結果として、クライアントは、通常の日常更新を待たずに、すぐにそのポートマッピングを更新することができます時間。"
    },
    {
      "indent": 0,
      "text": "16.3.2. Maintaining Mappings",
      "section_title": true,
      "ja": "16.3.2. マッピングを維持します"
    },
    {
      "indent": 3,
      "text": "A PCP client refreshes a mapping by sending a new PCP request containing information learned from the earlier PCP response. The PCP server will respond indicating the new lifetime. It is possible, due to reconfiguration or failure of the PCP server, that the external IP address and/or external port, or the PCP server itself, has changed (due to a new route to a different PCP server). Such events are rare, but not an error. The PCP server will simply return a new external address and/or external port to the client, and the client should record this new external address and port with its rendezvous service. To detect such events more quickly, a server that requires extremely high availability may find it beneficial to use shorter lifetimes in its PCP mappings requests, so that it communicates with the PCP server more often. This is an engineering trade-off based on (i) the acceptable downtime for the service in question, (ii) the expected likelihood of NAT or firewall state loss, and (iii) the amount of PCP maintenance traffic that is acceptable.",
      "ja": "PCPクライアントは、以前のPCP応答から学習した情報を含む新しいPCPリクエストを送信することにより、マッピングを更新します。 PCPサーバは、新たな寿命を示す応答します。これは、外部IPアドレスおよび/または外部ポート、またはPCPサーバ自体は、（原因異なるPCPサーバへの新しいルートに）変更されたことに起因PCPサーバの再設定や障害のために、可能です。このようなイベントはまれではなく、エラーが発生しました。 PCPサーバは、単にクライアントに新しい外部アドレスおよび/または外部ポートを返し、クライアントはそのランデブーサービスでこの新しい外部アドレスとポートを記録しなければなりません。より迅速に、このようなイベントを検出するには、非常に高い可用性を必要とするサーバーは、それがより頻繁にPCPサーバと通信するように、そのPCPマッピング要求に短い寿命を使用することが有益かもしれません。これは、（i）当該サービスのための許容可能なダウンタイム、（ⅱ）予想されるNATの可能性またはファイアウォールの状態の損失、および許容可能であるPCPの保守トラフィックの（III）量に基づいて、エンジニアリングのトレードオフです。"
    },
    {
      "indent": 3,
      "text": "If the PCP client has several mappings, the Epoch Time value only needs to be retrieved for one of them to determine whether or not it appears the PCP server may have suffered a catastrophic loss of state. If the client wishes to check the PCP server's Epoch time, it sends a PCP request for any one of the client's mappings. This will return the current Epoch Time value. In that request, the PCP client could extend the mapping lifetime (by asking for more time) or maintain the current lifetime (by asking for the same number of seconds that it knows are remaining of the lifetime).",
      "ja": "PCPクライアントが複数のマッピングを持っている場合は、エポックタイム値は、PCPサーバは状態の壊滅的な損失を被っている可能性が表示されますかどうかを判断するためにそれらの1のために取得する必要があります。クライアントは、PCPサーバのエポックの時間を確認したい場合は、それは、クライアントのマッピングのいずれかのためにPCP要求を送信します。これは、現在のエポックタイム値を返します。その要求には、（それは一生に一度の残っている知っている秒数が同じのために尋ねることによって）、現在の有効期間を（多くの時間を求めることで）マッピング寿命を延長するか、維持することができPCPクライアント。"
    },
    {
      "indent": 3,
      "text": "If a PCP client changes its internal IP address (e.g., because the internal host has moved to a new network), and the PCP client wishes to still receive incoming traffic, it needs create new mappings on that new network. New mappings will typically also require an update to the application-specific rendezvous server if the external address or port is different from the previous values (see Sections 10.1 and 11.5).",
      "ja": "PCPクライアントが内部IPアドレスを変更した場合（内部ホストが新しいネットワークに移動したので、例えば、）、およびPCPクライアントはまだ着信トラフィックを受信したい、それはその新しいネットワーク上の新しいマッピングを作成する必要があります。外部アドレスやポートは、以前の値と異なる場合、新しいマッピングはまた、典型的には、（セクション10.1と11.5を参照）、アプリケーション固有のランデブーサーバへのアップデートが必要になります。"
    },
    {
      "indent": 0,
      "text": "16.3.3. SCTP",
      "section_title": true,
      "ja": "16.3.3.  SCTP"
    },
    {
      "indent": 3,
      "text": "Although SCTP has port numbers like TCP and UDP, SCTP works differently when behind an address-sharing NAT, in that SCTP port numbers are not changed [SCTPNAT]. Outbound dynamic SCTP mappings use the verification tag of the association instead of the local and remote peer port numbers. As with TCP, explicit outbound mappings can be made to reduce keepalive intervals, and explicit inbound mappings can be made by passive listeners expecting to receive new associations at the external port.",
      "ja": "SCTPは、TCPやUDPなどのポート番号を持っていますが、SCTPは時にアドレス共有NATの背後に異なる働き、そのSCTPポート番号に[SCTPNAT]に変更されていません。アウトバウンド動的SCTPマッピングではなく、ローカルおよびリモートピアのポート番号の関連の検証タグを使用します。 TCPと同じように、明示的なアウトバウンドマッピングは、キープアライブ間隔を短縮させることができ、かつ明示的なインバウンドマッピングは、外部ポートで新しい関連付けを受けることを期待パッシブリスナーによって行うことができます。"
    },
    {
      "indent": 3,
      "text": "Because an SCTP-aware NAT does not (currently) rewrite SCTP port numbers, it will not be able to assign an external port that is different from the client's internal port. A PCP client making a MAP request for SCTP should be aware of this restriction. The PCP client SHOULD make its SCTP MAP request just as it would for a TCP MAP request: in its initial PCP MAP request it SHOULD specify zero for the external address and port, and then in subsequent renewals it SHOULD echo the assigned external address and port. However, since a current SCTP-aware NAT can only assign an external port that is the same as the internal port, it may not be able to do that if the external port is already assigned to a different PCP client. This is likely if there is more than one instance of a given SCTP service on the local network, since both instances are likely to listen on the same well-known SCTP port for that service on their respective hosts, but they can't both have the same external port on the NAT gateway's external address. A particular external port may not be assignable for other reasons, such as when it is already in use by the NAT device itself, or otherwise prohibited by policy, as described in Section 11.3, \"Processing a MAP Request\". In the event that the",
      "ja": "SCTP対応のNATは、（現在は）SCTPポート番号を書き換えていないので、クライアントの内部ポートと異なる外部ポートを割り当てることはできません。 SCTPのためのMAP要求を行うPCPクライアントは、この制限に注意する必要があります。その初期PCPのMAP要求で、それが外部アドレスとポートのためにゼロを指定する必要があり、そして、その後の更新でそれが割り当てられた外部アドレスとポートをエコーする必要があります。それはTCPのMAP要求のためにするのと同じように、PCPクライアントはそのSCTPのMAPリクエストを行う必要があります。しかし、唯一の内部ポートと同じ外部ポートを割り当てることができ、現在のSCTP対応のNATので、外部ポートがすでに別のPCPクライアントに割り当てられている場合があることを行うことができない場合があります。ローカルネットワーク上の特定のSCTPサービスの複数のインスタンスがある場合、両方のインスタンスがそれぞれのホスト上で、そのサービスの同じよく知られているSCTPポートをリッスンする可能性があるが、彼らは両方持つことができないので、これは可能性がありますNATゲートウェイの外部アドレスで同じ外部ポート。特定の外部ポートは、セクション11.3に記載されているように、またはそうでなければ「MAP要求を処理する」、ポリシーによって禁止され、そのようなことはNATデバイス自体によってすでに使用されている場合など、他の理由のために割り当て可能ではないかもしれません。その場合には"
    },
    {
      "indent": 3,
      "text": "external port matching the internal port cannot be assigned (and the SCTP-aware NAT does not perform SCTP port rewriting), the SCTP-aware NAT MUST return a CANNOT_PROVIDE_EXTERNAL error to the requesting PCP client. Note that this restriction places an extra burden on the SCTP server whose MAP request failed, because it then has to tear down its exiting listening socket and try again with a different internal port, repeatedly until it is successful in finding an external port it can use.",
      "ja": "内部ポートに一致する外部ポートを割り当てることはできません（とSCTP対応のNATは、SCTPポートの書き換えを行っていない）、SCTP対応のNATは、要求PCPクライアントにCANNOT_PROVIDE_EXTERNALエラーを返さなければなりません。それはそれはそれは使用することができ、外部ポートを見つけることに成功するまで繰り返し、その出リスニングソケットを切断し、別の内部ポートでもう一度お試しする必要があるため、この制限は、MAP要求失敗したSCTPサーバーに余分な負担を課すことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The SCTP complications described above occur because of address sharing. The SCTP complications are avoided when address sharing is avoided (e.g., 1:1 NAT, firewall).",
      "ja": "上記のSCTPの合併症があるためアドレス共有の発生します。 （：1 NAT、ファイアウォール例えば、1）アドレス共有が回避されたときにSCTPの合併症が回避されます。"
    },
    {
      "indent": 0,
      "text": "16.4. Source Address Replicated in PCP Header",
      "section_title": true,
      "ja": "16.4.  PCPヘッダに複製された送信元アドレス"
    },
    {
      "indent": 3,
      "text": "All PCP requests include the PCP client's IP address replicated in the PCP header. This is used to detect unexpected address rewriting (NAT) on the path between the PCP client and its PCP server. On operating systems that support the sockets API, the following steps are RECOMMENDED for a PCP client to insert the correct source address in the PCP header:",
      "ja": "すべてのPCP要求はPCPヘッダに複製されたPCPクライアントのIPアドレスが含まれます。これは、PCPクライアントとそのPCPサーバ間のパスに書き換え予想外のアドレス（NAT）を検出するために使用されます。ソケットAPIをサポートするオペレーティングシステムでは、次の手順では、PCPヘッダ内の正しい送信元アドレスを挿入するPCPのクライアントのために推奨されています："
    },
    {
      "indent": 3,
      "text": "1. Create a UDP socket. 2. Call \"connect\" on this UDP socket using the address and port of the desired PCP server. 3. Call the getsockname() function to retrieve a sockaddr containing the source address the kernel will use for UDP packets sent through this socket. 4. If the IP address is an IPv4 address, encode the address into an IPv4-mapped IPv6 address. Place the IPv4-mapped IPv6 address or the native IPv6 address into the PCP Client's IP Address field in the PCP header. 5. Send PCP requests using this connected UDP socket.",
      "ja": "1. UDPソケットを作成します。 2.コールが希望PCPサーバのアドレスとポートを使用して、このUDPソケット上で「接続します」。 3.のsockaddrカーネルはこのソケットを介して送信されるUDPパケットに使用する送信元アドレスを含むを取得するためのgetsockname（）関数を呼び出します。 4. IPアドレスがIPv4アドレスである場合、IPv4射影IPv6アドレスにアドレスを符号化します。 PCPヘッダにPCPクライアントのIPアドレスフィールドにIPv4射影IPv6アドレスまたはネイティブIPv6アドレスを置きます。 5.この接続UDPソケットを使用してPCP要求を送信します。"
    },
    {
      "indent": 0,
      "text": "16.5. State Diagram",
      "section_title": true,
      "ja": "16.5. 状態図"
    },
    {
      "indent": 3,
      "text": "Each mapping entry of the PCP-controlled device would go through the state machine shown below. This state diagram is non-normative.",
      "ja": "PCP-制御機器の各マッピングエントリは、以下に示すステートマシンを通過するでしょう。この状態図は非規範的です。"
    },
    {
      "indent": 5,
      "text": "  CLOSE_MSG or\n (NO_TRAFFIC and EXPIRY)   +---------+  NO_TRAFFIC and EXPIRY\n           +-------------->|         |<------------+\n           |               |NO_ENTRY |             |\n           |   +-----------|         |---------+   |\n           |   |           +---------+         |   |\n           |   |              ^  |             |   |\n           |   |   NO_TRAFFIC |  |             |   |\n           |   |           or |  |             |   |\n           |   |   CLOSE_MSGS |  |             |   |\n           |   |              |  |             |   |\n           |   |PEER request  |  |  MAP request|   |\n           |   V              |  |             V   |\n        +---------+           |  |         +---------+\n    +-->|  \"P\",   |           |  |    M-R  |  \"M\",   |<--+\nP-R |   | PEER    |-----------|--|-------->| MAP     |   | M-R or\n    +---|  mapping|           |  |         |  mapping|---+ P-R or\n        +---------+           |  |         +---------+  CLOSE_MSGS\n           |   ^              |  |             ^   |\n           |   |PEER request  |  |  MAP request|   |\n           |   |              |  |             |   |\n           |   |              |  |             |   |\n           |   |              |  |             |   |\n           |   |              |  | outbound    |   |\n           |   |              |  | TRAFFIC     |   |\n           |   |              |  V             |   |\n           |   |           +---------+         |   |\n           |   +-----------| \"I\",    |---------+   |\n           |               | implicit|             |\n           +-------------->| mapping |<------------+\n       TRAFFIC and EXPIRY  +---------+  TRAFFIC and EXPIRY",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 16: PCP State Diagram",
      "ja": "図16：PCP状態図"
    },
    {
      "indent": 3,
      "text": "The meanings of the states and events are:",
      "ja": "状態とイベントの意味は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "NO_ENTRY: Invalid state represents Entry does not exist. This is the only possible start state.",
      "ja": "NO_ENTRY：無効な状態ではエントリが存在しません表します。これが唯一の可能な開始状態です。"
    },
    {
      "indent": 6,
      "text": "M-R: MAP request",
      "ja": "M-R：MAP要求"
    },
    {
      "indent": 6,
      "text": "P-R: PEER request",
      "ja": "P-R：PEER要求"
    },
    {
      "indent": 6,
      "text": "M: Mapping entry when created by MAP request",
      "ja": "M：MAP要求によって作成されたマッピングエントリ"
    },
    {
      "indent": 6,
      "text": "P: Mapping entry when created/managed by PEER request",
      "ja": "P：作成したときのマッピングエントリ/ PEERリクエストによって管理"
    },
    {
      "indent": 6,
      "text": "I: Implicit mapping created by an outgoing packet from the client (e.g., TCP SYN), and also the state when a PCP-created mapping's lifetime expires while there is still active traffic.",
      "ja": "I：暗黙クライアント（例えば、TCP SYN）からの発信パケットによって作成されたマッピング、および状態もアクティブなトラフィックがまだある間、PCP-作成されたマッピングの有効期間が満了しました。"
    },
    {
      "indent": 6,
      "text": "EXPIRY: PEER or MAP lifetime expired",
      "ja": "EXPIRY：PEERまたはMAPの寿命が期限切れ"
    },
    {
      "indent": 6,
      "text": "TRAFFIC: Traffic seen by PCP-controlled device using this entry within the expiry time for that entry. This traffic may be inbound or outbound.",
      "ja": "TRAFFIC：そのエントリの有効期限内にこのエントリを使用してPCP-制御機器から見たトラフィック。このトラフィックは、インバウンドまたはアウトバウンドのかもしれません。"
    },
    {
      "indent": 6,
      "text": "NO_TRAFFIC: Indicates that there is no TRAFFIC.",
      "ja": "NO_TRAFFICは：トラフィックがないことを示します。"
    },
    {
      "indent": 6,
      "text": "CLOSE_MSG: Protocol messages from the client or server to close the session (e.g., TCP FIN or TCP RST), as per the NAT or firewall device's handling of such protocol messages.",
      "ja": "CLOSE_MSG：クライアントまたはサーバからのプロトコルメッセージセッションを終了する（例えば、TCP FINまたはTCP RST）、そのようなプロトコルメッセージのNATまたはファイアウォールデバイスの取り扱いにつきとして。"
    },
    {
      "indent": 3,
      "text": "Notes on the diagram:",
      "ja": "ダイアグラム上の注意："
    },
    {
      "indent": 3,
      "text": "1. The 'and' clause indicates the events on either side of 'and' are required for the state-transition. The 'or' clause indicates either one of the events are enough for the state-transition.",
      "ja": "1「と」句は、いずれかの側にイベントを示して「と」状態遷移のために必要とされます。 「または」句のいずれかを示しているイベントの一つは、状態遷移のために十分です。"
    },
    {
      "indent": 3,
      "text": "2. Transition from state M to state I is implementation dependent.",
      "section_title": true,
      "ja": "Iの状態にMから2の遷移は実装依存です。"
    },
    {
      "indent": 0,
      "text": "17. Deployment Considerations",
      "section_title": true,
      "ja": "17.展開の考慮事項"
    },
    {
      "indent": 0,
      "text": "17.1. Ingress Filtering",
      "section_title": true,
      "ja": "17.1. 入力フィルタリング"
    },
    {
      "indent": 3,
      "text": "As with implicit dynamic mappings created by outgoing TCP SYN packets, explicit dynamic mappings created via PCP use the source IP address of the packet as the internal address for the mappings. Therefore, ingress filtering [RFC2827] SHOULD be used on the path between the internal host and the PCP server to prevent the injection of spoofed packets onto that path.",
      "ja": "発信TCP SYNパケットによって作成された暗黙のダイナミックマッピングと同じように、PCPを経て作成された明示的な動的なマッピングは、マッピングのための内部アドレスとしてパケットの送信元IPアドレスを使用します。したがって、侵入フィルタ[RFC2827]は、その経路上に偽装されたパケットの注入を防止するために、内部ホストとPCPサーバとの間の経路上で使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "17.2. Mapping Quota",
      "section_title": true,
      "ja": "17.2. マッピングクォータ"
    },
    {
      "indent": 3,
      "text": "On PCP-controlled devices that create state when a mapping is created (e.g., NAT), the PCP server SHOULD maintain per-host and/or per-subscriber quotas for mappings. It is implementation specific whether the PCP server uses a separate quotas for implicit, explicit, and static mappings, a combined quota for all of them, or some other policy.",
      "ja": "マッピングが（例えば、NAT）が作成されたときの状態を作成PCP制御装置に、PCPサーバは、マッピングごとのホストおよび/または単位の加入者クォータを維持しなければなりません。これは、PCPサーバは、暗黙の明示、および静的マッピングのための独立したクォータ、それらのすべてを合わせたクォータ、または他のいくつかのポリシーを使用するかどうかを具体的な実装です。"
    },
    {
      "indent": 0,
      "text": "18. Security Considerations",
      "section_title": true,
      "ja": "18.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The goal of the PCP protocol is to improve the ability of end nodes to control their associated NAT state, and to improve the efficiency and error handling of NAT mappings when compared to existing implicit mapping mechanisms in NAT boxes and stateful firewalls. It is the security goal of the PCP protocol to limit any new denial-of-service opportunities, and to avoid introducing new attacks that can result in unauthorized changes to mapping state. One of the most serious consequences of unauthorized changes in mapping state is traffic theft. All mappings that could be created by a specific host using implicit mapping mechanisms are inherently considered to be authorized. Confidentiality of mappings is not a requirement, even in cases where the PCP messages may transit paths that would not be traveled by the mapped traffic.",
      "ja": "PCPプロトコルの目標は、それらに関連するNATの状態を制御するため、及びNATボックスとステートフル・ファイアウォールの既存の暗黙的なマッピングメカニズムと比較した場合、NATマッピングの効率およびエラーハンドリングを改善するために、エンド・ノードの能力を改善することです。これは、任意の新しいサービス拒否の機会を制限し、及びマッピング状態への不正な変化をもたらすことができ、新たな攻撃を導入することを避けるためにPCPプロトコルのセキュリティ目標です。マッピング状態での不正な変更の最も深刻な結果の一つは、トラフィックの盗難です。暗黙的なマッピング・メカニズムを使用して、特定のホストで作成することができたすべてのマッピングは、本質的に認可されていると考えられます。マッピングの機密性にもPCPメッセージがマッピングされたトラフィックによってトランジットパス旅をすることはないかもしれ例では、必須ではありません。"
    },
    {
      "indent": 0,
      "text": "18.1. Simple Threat Model",
      "section_title": true,
      "ja": "18.1. シンプルな脅威モデル"
    },
    {
      "indent": 3,
      "text": "PCP servers are secure against off-path attackers who cannot spoof a packet that the PCP server will view as a packet received from the internal network. PCP clients are secure against off-path attackers who can spoof the PCP server's IP address.",
      "ja": "PCPサーバは、PCPサーバは、内部ネットワークから受信したパケットとして表示されますパケットを偽造することはできませんオフパスの攻撃に対して安全です。 PCPクライアントは、PCPサーバのIPアドレスを偽装することができ、オフパスの攻撃に対して安全です。"
    },
    {
      "indent": 3,
      "text": "Defending against attackers who can modify or drop packets between the internal network and the PCP server, or who can inject spoofed packets that appear to come from the internal network is out of scope. Such an attacker can redirect traffic to a host of their choosing.",
      "ja": "内部ネットワークから来るように見える偽装されたパケットを注入することができ、変更や内部ネットワークとPCPサーバ、または人の間でパケットをドロップすることができ、攻撃者に対して防衛することは範囲外です。このような攻撃者は、自分の選択したホストへのトラフィックをリダイレクトすることができます。"
    },
    {
      "indent": 3,
      "text": "A PCP server is secure under this threat model if the PCP server is constrained so that it does not configure any explicit mapping that it would not configure implicitly. In most cases, this means that PCP servers running on NAT boxes or stateful firewalls that support the PEER and MAP Opcodes can be secure under this threat model if (1) all of their hosts are within a single administrative domain (or if the internal hosts can be securely partitioned into separate administrative domains, as in the DS-Lite B4 case), (2) explicit mappings are created with the same lifetime as implicit mappings, and (3) the THIRD_PARTY option is not supported. PCP servers can also securely support the MAP Opcode under this threat model if the security policy on the device running the PCP server would permit endpoint-independent filtering of implicit mappings.",
      "ja": "それは暗黙的に設定しないであろうと明示的なマッピングを設定しないように、PCPサーバが制約されている場合はPCPサーバは、この脅威モデルの下で安全です。ほとんどの場合、これは、（1）自分のすべてのホストを単一の管理ドメイン（または場合、内部ホスト内にある場合、NATボックスやPEERとMAPオペコードをサポートするステートフルファイアウォールで実行されているPCPサーバは、この脅威モデルの下で安全であることを意味し安全）DS-ライトB4の場合のように、別の管理ドメインに分割することができる、（2）明示的なマッピングを暗黙的なマッピングと同じ寿命で作成され、そして（3）THIRD_PARTYオプションがサポートされていません。 PCPサーバを実行しているデバイスのセキュリティポリシーは、暗黙的なマッピングのエンドポイント非依存のフィルタリングを可能にする場合はPCPサーバもしっかりと、この脅威モデルの下でMAPオペコードをサポートすることができます。"
    },
    {
      "indent": 3,
      "text": "PCP servers that comply with the Simple Threat Model and do not implement a PCP security mechanism described in Section 18.2 MUST enforce the constraints described in the paragraph above.",
      "ja": "シンプルな脅威モデルに準拠し、18.2節で説明したPCPのセキュリティメカニズムを実装していないPCPサーバは、上の段落で説明した制約を強制しなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.1.1. Attacks Considered",
      "section_title": true,
      "ja": "18.1.1. 攻撃考慮"
    },
    {
      "indent": 3,
      "text": "o If you allow multiple administrative domains to send PCP requests to a single PCP server that does not enforce a boundary between the domains, it is possible for a node in one domain to perform a denial-of-service attack on other domains or to capture traffic that is intended for a node in another domain.",
      "ja": "あなたが複数の管理ドメインは、ドメイン間の境界を強制しません単一PCPサーバにPCP要求を送信できるようにする場合は、O、他のドメイン上またはキャプチャするサービス拒否攻撃を実行するために、1つのドメイン内のノードのために可能です別のドメイン内のノードを対象としたトラフィック。"
    },
    {
      "indent": 3,
      "text": "o If explicit mappings have longer lifetimes than implicit mappings, it makes it easier to perpetrate a denial-of-service attack than it would be if the PCP server was not present.",
      "ja": "明示的なマッピングが暗黙的なマッピングよりも長い寿命を持っている場合は、O、それは、PCPサーバが存在しない場合よりも、それが簡単にサービス拒否攻撃を犯すすることができます。"
    },
    {
      "indent": 3,
      "text": "o If the PCP server supports deleting or reducing the lifetime of existing mappings, this allows an attacking node to steal an existing mapping and receive traffic that was intended for another node.",
      "ja": "PCPサーバは、既存のマッピングの寿命を削除または還元サポートしている場合は、O、これは攻撃ノードが既存のマッピングを盗み、別のノードのために意図されたトラフィックを受信することができます。"
    },
    {
      "indent": 3,
      "text": "o If the THIRD_PARTY option is supported, this also allows an attacker to open a window for an external node to attack an internal node, allows an attacker to steal traffic that was intended for another node, or may facilitate a denial-of-service attack. One example of how the THIRD_PARTY option could grant an attacker more capability than a spoofed implicit mapping is that the PCP server (especially if it is running in a service provider's network) may not be aware of internal filtering that would prevent spoofing an equivalent implicit mapping, such as filtering between a guest and corporate network.",
      "ja": "THIRD_PARTYオプションがサポートされている場合は、O、これはまた、攻撃者が内部ノードを攻撃する外部ノードのためにウィンドウを開くことができ、攻撃者が別のノードのために意図されたトラフィックを盗むために、またはサービス拒否攻撃を容易にすることができることができます。 THIRD_PARTYオプションは、攻撃者が偽装された暗黙的なマッピングよりも多くの機能を付与することができる方法の一例は、PCPサーバは、（それがサービスプロバイダのネットワークで動作している場合は特に）同等の暗黙的なマッピングを偽装妨げる内部フィルタリングを認識していないことです、ゲストと企業ネットワーク間のフィルタリングなど。"
    },
    {
      "indent": 3,
      "text": "o If the MAP Opcode is supported by the PCP server in cases where the security policy would not support endpoint-independent filtering of implicit mappings, then the MAP Opcode changes the security properties of the device running the PCP server by allowing explicit mappings that violate the security policy.",
      "ja": "MAPオペコードは、セキュリティポリシーが暗黙のマッピングのエンドポイントに依存しないフィルタリングをサポートしません例にPCPサーバによってサポートされている場合は、O、その後、MAPオペコードは違反明示的なマッピングを可能にすることにより、PCPサーバを実行しているデバイスのセキュリティプロパティを変更しますセキュリティポリシー。"
    },
    {
      "indent": 0,
      "text": "18.1.2. Deployment Examples Supporting the Simple Threat Model",
      "section_title": true,
      "ja": "18.1.2. シンプルな脅威モデルをサポートする展開例"
    },
    {
      "indent": 3,
      "text": "This section offers two examples of how the Simple Threat Model can be supported in real-world deployment scenarios.",
      "ja": "このセクションでは、単純な脅威モデルは、実世界の展開シナリオでサポートすることができる方法の2つの例を提供しています。"
    },
    {
      "indent": 0,
      "text": "18.1.2.1. Residential Gateway Deployment",
      "section_title": true,
      "ja": "18.1.2.1。レジデンシャルゲートウェイの展開"
    },
    {
      "indent": 3,
      "text": "Parity with many currently deployed residential gateways can be achieved using a PCP server that is constrained as described in Section 18.1 above.",
      "ja": "多くの現在展開レジデンシャルゲートウェイとのパリティは、上記の18.1節で説明したように制約されているPCPサーバを使用して達成することができます。"
    },
    {
      "indent": 0,
      "text": "18.2. Advanced Threat Model",
      "section_title": true,
      "ja": "18.2. 高度な脅威モデル"
    },
    {
      "indent": 3,
      "text": "In the Advanced Threat Model, the PCP protocol ensures that attackers (on- or off-path) cannot create unauthorized mappings or make unauthorized changes to existing mappings. The protocol must also limit the opportunity for on- or off-path attackers to perpetrate denial-of-service attacks.",
      "ja": "高度な脅威モデルでは、PCPプロトコルが攻撃者（オンまたはオフパス）は、不正のマッピングを作成したり、既存のマッピングへの不正な変更を加えることができないことを保証します。また、プロトコルは、オンの機会を制限しなければならないか、オフパス攻撃者がサービス拒否攻撃を犯すします。"
    },
    {
      "indent": 3,
      "text": "The Advanced Threat Model security model will be needed in the following cases:",
      "ja": "高度な脅威モデルセキュリティモデルは、次の場合に必要になります。"
    },
    {
      "indent": 3,
      "text": "o Security infrastructure equipment, such as corporate firewalls, that does not create implicit mappings.",
      "ja": "暗黙のマッピングを作成しないように、企業のファイアウォールなどのセキュリティOインフラ機器、。"
    },
    {
      "indent": 3,
      "text": "o Equipment (such as CGNs or service provider firewalls) that serves multiple administrative domains and does not have a mechanism to securely partition traffic from those domains.",
      "ja": "O機器（例えばCGNをまたはサービスプロバイダのファイアウォールなど）は、複数の管理ドメインを提供し、確実にそれらのドメインからのトラフィックを分割するためのメカニズムを有していません。"
    },
    {
      "indent": 3,
      "text": "o Any implementation that wants to be more permissive in authorizing explicit mappings than it is in authorizing implicit mappings.",
      "ja": "それは暗黙のマッピングを許可しているよりも、明示的なマッピングを許可でより寛大になりたい任意の実装、O。"
    },
    {
      "indent": 3,
      "text": "o Implementations that wish to support any deployment scenario that does not meet the constraints described in Section 18.1.",
      "ja": "18.1節で説明した制約を満たしていない任意の展開シナリオをサポートしたいOの実装。"
    },
    {
      "indent": 3,
      "text": "To protect against attacks under this threat model, a PCP security mechanism that provides an authenticated, integrity-protected signaling channel would need to be specified.",
      "ja": "この脅威モデルの下で攻撃から保護するために、認証され、完全性保護されたシグナリングチャネルを提供PCPのセキュリティ・メカニズムを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "PCP servers that implement a PCP security mechanism MAY accept unauthenticated requests. In their default configuration, PCP servers implementing the PCP security mechanism MUST still enforce the constraints described in Section 18.1 when processing unauthenticated requests.",
      "ja": "PCPのセキュリティ・メカニズムを実装するPCPサーバは、認証されていない要求を受け入れることができます。デフォルトの設定では、PCPのセキュリティ・メカニズムを実装するPCPサーバは、まだ認証されていない要求を処理するとき、セクション18.1で説明した制約を強制しなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.3. Residual Threats",
      "section_title": true,
      "ja": "18.3. 残留脅威"
    },
    {
      "indent": 3,
      "text": "This section describes some threats that are not addressed in either of the above threat models and recommends appropriate mitigation strategies.",
      "ja": "このセクションでは、上記の脅威モデルのいずれかで対処されていないいくつかの脅威を説明し、適切な緩和策を推奨しています。"
    },
    {
      "indent": 0,
      "text": "18.3.1. Denial of Service",
      "section_title": true,
      "ja": "18.3.1. サービス拒否"
    },
    {
      "indent": 3,
      "text": "Because of the state created in a NAT or firewall, a per-host and/or per-subscriber quota will likely exist for both implicit dynamic mappings and explicit dynamic mappings. A host might make an excessive number of implicit or explicit dynamic mappings, consuming an inordinate number of ports, causing a denial of service to other hosts. Thus, Section 17.2 recommends that hosts be limited to a reasonable number of explicit dynamic mappings.",
      "ja": "そのため、NATやファイアウォールで作成された状態で、ホストごとのおよび/または加入者単位のクォータは、暗黙のダイナミックマッピングと明示的なダイナミックなマッピングの両方の可能性が存在します。ホストは他のホストにサービス拒否を引き起こすポートの過度の数を消費し、暗黙的または明示的なダイナミックマッピングの過剰な数を作るかもしれません。したがって、セクション17.2は、ホストは、明示的な動的マッピングの合理的な数に限定されることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "An attacker, on the path between the PCP client and PCP server, can drop PCP requests, drop PCP responses, or spoof a PCP error, all of which will effectively deny service. Through such actions, the PCP client might not be aware the PCP server might have actually processed the PCP request. An attacker sending a NO_RESOURCES error can cause the PCP client to not send messages to that server for a while. There is no mitigation to this on-path attacker.",
      "ja": "攻撃者は、PCPクライアントとPCPサーバ間のパスに、PCP要求をドロップPCP応答をドロップ、または効果的にサービスを拒否しますすべてがPCPエラーを偽装することができます。そのような行動を通じ、PCPクライアントは、PCPサーバは、実際にPCPリクエストを処理している場合があります認識していない可能性があります。 NO_RESOURCESエラーを送信する攻撃者は、PCPクライアントはしばらくの間、そのサーバーにメッセージを送信しないことがあります。このパス上の攻撃者への緩和策はありません。"
    },
    {
      "indent": 0,
      "text": "18.3.2. Ingress Filtering",
      "section_title": true,
      "ja": "18.3.2. 入力フィルタリング"
    },
    {
      "indent": 3,
      "text": "It is important to prevent a host from fraudulently creating, deleting, or refreshing a mapping (or filtering) for another host, because this can expose the other host to unwanted traffic, prevent it from receiving wanted traffic, or consume the other host's mapping quota. Both implicit and explicit dynamic mappings are created based on the source IP address in the packet, and hence depend on ingress filtering to guard against spoof source IP addresses.",
      "ja": "これは、不要なトラフィックに他のホストを公開するトラフィックを望んでいた受信することを防ぐ、または他のホストのマッピングクォータを消費することができるので、不正に作成、削除、または別のホストのマッピング（またはフィルタリング）をリフレッシュからホストを防止することが重要です。どちらも暗黙的および明示的な動的なマッピングは、パケットの送信元IPアドレスに基づいて作成され、ひいてはスプーフィングの送信元IPアドレスを防ぐために入力フィルタリングに依存しています。"
    },
    {
      "indent": 0,
      "text": "18.3.3. Mapping Theft",
      "section_title": true,
      "ja": "18.3.3. マッピング盗難"
    },
    {
      "indent": 3,
      "text": "In the time between when a PCP server loses state and the PCP client notices the lower-than-expected Epoch Time value, it is possible that the PCP client's mapping will be acquired by another host (via an explicit dynamic mapping or implicit dynamic mapping). This means incoming traffic will be sent to a different host (\"theft\"). Rapid recovery reduces this interval, but does not completely eliminate this threat. The PCP client can reduce this interval by using a relatively short lifetime; however, this increases the amount of PCP chatter. This threat is reduced by using persistent storage of explicit dynamic mappings in the PCP server (so it does not lose explicit dynamic mapping state), or by ensuring that the previous external IP address, protocol, and port cannot be used by another host (e.g., by using a different IP address pool).",
      "ja": "PCPサーバが状態を失い、PCPクライアントが低いより期待エポック時刻値を通知するときの間の時間では、PCPクライアントのマッピングが（明示的、動的マッピングまたは暗黙的な動的マッピングを介して）他のホストによって取得されることが可能です。これは、着信トラフィックが別のホスト（「窃盗」）に送信されることを意味します。急速な回復は、この間隔は減少しますが、完全にこの脅威を排除するものではありません。 PCPクライアントは、比較的短い寿命を使用することで、この間隔を短くすることができます。しかし、これはPCPのチャタリングの量が増加します。この脅威は、（それが明示的な動的なマッピング状態を失うことはありません）PCPサーバに明示的なダイナミックマッピングの永続ストレージを使用することによって低減され、または前の外部IPアドレス、プロトコル、およびポートが別のホストで使用することはできないようにすることで（例えば、異なるIPアドレスプールを使用して）。"
    },
    {
      "indent": 0,
      "text": "18.3.4. Attacks against Server Discovery",
      "section_title": true,
      "ja": "18.3.4. サーバーの検出に対する攻撃"
    },
    {
      "indent": 3,
      "text": "This document does not specify server discovery, beyond contacting the default gateway.",
      "ja": "このドキュメントでは、デフォルトゲートウェイに連絡を超えて、サーバーの検出を指定していません。"
    },
    {
      "indent": 0,
      "text": "19. IANA Considerations",
      "section_title": true,
      "ja": "19. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has performed the following actions.",
      "ja": "IANAは、次の操作を行っています。"
    },
    {
      "indent": 0,
      "text": "19.1. Port Number",
      "section_title": true,
      "ja": "19.1. ポート番号"
    },
    {
      "indent": 3,
      "text": "PCP uses ports 5350 and 5351, previously assigned by IANA to NAT-PMP [RFC6886]. IANA has reassigned those ports to PCP.",
      "ja": "PCPは、前にNAT-PMP [RFC6886]にIANAによって割り当てられ、ポート5350および5351を使用します。 IANAは、PCPにこれらのポートを再割り当てしています。"
    },
    {
      "indent": 0,
      "text": "19.2. Opcodes",
      "section_title": true,
      "ja": "19.2. オペコード"
    },
    {
      "indent": 3,
      "text": "IANA has created a new protocol registry for PCP Opcodes, numbered 0-127, initially populated with the values:",
      "ja": "IANAは、最初に値が移入0〜127の番号が付けられPCPオペコードのための新しいプロトコルのレジストリを作成しました："
    },
    {
      "indent": 11,
      "text": "Value            Opcode\n-----            -------------------------\n0                ANNOUNCE\n1                MAP\n2                PEER\n3-31             Standards Action [RFC5226]\n32-63            Specification Required [RFC5226]\n96-126           Reserved for Private Use [RFC5226]\n127              Reserved, Standards Action [RFC5226]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value 127 is Reserved and may be assigned via Standards Action [RFC5226]. The values in the range 3-31 can be assigned via Standards Action [RFC5226], 32-63 via Specification Required [RFC5226], and the range 96-126 is for Private Use [RFC5226].",
      "ja": "値127は予約されており、標準アクション[RFC5226]を介して割り当てられてもよいです。範囲3-31の値は、標準アクション[RFC5226]を経由して仕様が必要である[RFC5226]を経由して32から63を割り当てることができ、かつ範囲96から126には、私用[RFC5226]のためです。"
    },
    {
      "indent": 0,
      "text": "19.3. Result Codes",
      "section_title": true,
      "ja": "19.3. 結果コード"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry for PCP result codes, numbered 0-255, initially populated with the result codes from Section 7.4. The value 255 is Reserved and may be assigned via Standards Action [RFC5226].",
      "ja": "IANAは、最初は7.4節からの結果コードが読み込ま0-255番PCP結果コードのための新しいレジストリを作成しました。値255が予約されており、標準アクション[RFC5226]を経由して割り当てることもできます。"
    },
    {
      "indent": 3,
      "text": "The values in the range 14-127 can be assigned via Standards Action [RFC5226], 128-191 via Specification Required [RFC5226], and the range 191-254 is for Private Use [RFC5226].",
      "ja": "範囲14から127の値が標準化アクション[RFC5226]を経由して割り当てることができ、仕様が必要である[RFC5226]、および範囲191から254を経由して128から191には、私用[RFC5226]のためです。"
    },
    {
      "indent": 0,
      "text": "19.4. Options",
      "section_title": true,
      "ja": "19.4. オプション"
    },
    {
      "indent": 3,
      "text": "IANA has created a new registry for PCP options, numbered 0-255, each with an associated mnemonic. The values 0-127 are mandatory to process, and 128-255 are optional to process. The initial registry contains the options described in Section 13. The option values 0, 127, and 255 are Reserved and may be assigned via Standards Action [RFC5226].",
      "ja": "IANAは、関連するニーモニックと0-255、それぞれに番号が付けPCPオプション、のための新しいレジストリを作成しました。値0〜127を処理することが必須であり、そして128〜255は、プロセスへのオプションです。初期レジストリセクションオプションが0値13、127に記載されたオプションが含まれており、255は予約されており、標準アクション[RFC5226]を介して割り当てられてもよいです。"
    },
    {
      "indent": 3,
      "text": "Additional PCP option codes in the ranges 4-63 and 128-191 can be created via Standards Action [RFC5226], the ranges 64-95 and 192-223 are for Specification Required [RFC5226], and the ranges 96-126 and 224-254 are for Private Use [RFC5226].",
      "ja": "範囲4-63と128から191で追加のPCPオプションコードは標準アクション[RFC5226]、範囲64から95および192から223は、仕様が必要である[RFC5226]のためのものであり、範囲は96から126と224-を介して作成することができます254は私用[RFC5226]のためのものです。"
    },
    {
      "indent": 3,
      "text": "Documents describing an option should describe the processing for both the PCP client and server, and the information below:",
      "ja": "オプションを記述した文書は、PCPクライアントとサーバ、および以下の情報の両方のための処理を記述する必要があります。"
    },
    {
      "indent": 6,
      "text": "Option Name: <mnemonic> Number: <value> Purpose: <textual description> Valid for Opcodes: <list of Opcodes> Length: <rules for length> May appear in: <requests/responses/both> Maximum occurrences: <count>",
      "ja": "オプション名：<ニーモニック>数：<値>目的：オペコードのための有効な<原文の記述>：<オペコードのリスト>長さ：<リクエスト/レスポンス/両方>最大出現：<回数> <長さのためのルール>はで表示されることがあります"
    },
    {
      "indent": 0,
      "text": "20. Acknowledgments",
      "section_title": true,
      "ja": "20.謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Xiaohong Deng, Alain Durand, Christian Jacquenet, Jacni Qin, Simon Perreault, James Yu, Tina TSOU (Ting ZOU), Felipe Miranda Costa, James Woodyatt, Dave Thaler, Masataka Ohta, Vijay K. Gurbani, Loa Andersson, Richard Barnes, Russ Housley, Adrian Farrel, Pete Resnick, Pasi Sarolahti, Robert Sparks, Wesley Eddy, Dan Harkins, Peter Saint-Andre, Stephen Farrell, Ralph Droms, Felipe Miranda Costa, Amit Jain, and Wim Henderickx for their comments and review.",
      "ja": "Xiaohongトウのおかげで、アラン・デュラン、クリスチャンJacquenet、Jacni秦、サイモン・ペロー、ジェームズ・ゆう、ティナツオウ（ティンZOU）、フェリペミランダ・コスタ、ジェームズWoodyatt、デーブターラー、正隆太田、ビジェイK. Gurbani、ロア・アンダーソン、リチャード・バーンズ、彼らのコメントやレビューのためのラスHousley、エードリアンファレル、ピート・レズニック、パシSarolahti、ロバート・スパークス、ウェズリーエディ、ダンハーキンズ、ピーター・サン・アンドレ、スティーブン・ファレル、ラルフDroms、フェリペミランダ・コスタ、アミットジャイナ教、そしてヴィム・ヘンデリック。"
    },
    {
      "indent": 3,
      "text": "Thanks to Simon Perreault for highlighting the interaction of dynamic connections with PCP-created mappings and for many other review comments.",
      "ja": "PCP-作成したマッピングを持つ動的な接続の相互作用を強調するために、他の多くのレビューコメントのためのサイモン・ペローに感謝します。"
    },
    {
      "indent": 3,
      "text": "Thanks to Francis Dupont for his several thorough reviews of the specification, which improved the protocol significantly.",
      "ja": "大幅プロトコルを改善仕様、彼のいくつかの徹底的なレビューのためのフランシスデュポンに感謝します。"
    },
    {
      "indent": 3,
      "text": "Thanks to T. S. Ranganathan for the state diagram.",
      "ja": "状態図のためのT. S. Ranganathan氏に感謝します。"
    },
    {
      "indent": 3,
      "text": "Thanks to Peter Lothberg for clock skew information, which guided the choice of tolerance levels for deciding when an Epoch time should be considered to be anomalous.",
      "ja": "エポック時間が異常であると考えるべきであるときを判定するための許容レベルの選択を導いたクロックスキュー情報、についてピーター・ロスバーグに感謝します。"
    },
    {
      "indent": 3,
      "text": "Thanks to Margaret Wasserman and Sam Hartman for writing the Security Considerations section.",
      "ja": "セキュリティの考慮事項のセクションを書くためのマーガレットワッサーマンとサム・ハートマンに感謝します。"
    },
    {
      "indent": 3,
      "text": "Thanks to authors of DHCPv6 for retransmission text.",
      "ja": "再送テキストのためのDHCPv6の作者に感謝します。"
    },
    {
      "indent": 0,
      "text": "21. References",
      "section_title": true,
      "ja": "21.参考文献"
    },
    {
      "indent": 0,
      "text": "21.1. Normative References",
      "section_title": true,
      "ja": "21.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "ja": "[RFC0768]ポステル、J.、 \"ユーザ・データグラム・プロトコル\"、STD 6、RFC 768、1980年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2827] Ferguson, P. and D. Senie, \"Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing\", BCP 38, RFC 2827, May 2000.",
      "ja": "[RFC2827]ファーガソン、P.およびD. Senie、 \"ネットワーク入力フィルタリング：IP Source Address Spoofingを使うサービス攻撃の敗北拒否\"、BCP 38、RFC 2827、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4193] Hinden, R. and B. Haberman, \"Unique Local IPv6 Unicast Addresses\", RFC 4193, October 2005.",
      "ja": "[RFC4193] HindenとR.とB.ハーバーマン、 \"ユニークローカルIPv6ユニキャストアドレス\"、RFC 4193、2005年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC4291] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 4291, February 2006.",
      "ja": "[RFC4291] HindenとR.とS.デアリング、 \"IPバージョン6アドレッシング体系\"、RFC 4291、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC6056] Larsen, M. and F. Gont, \"Recommendations for Transport-Protocol Port Randomization\", BCP 156, RFC 6056, January 2011.",
      "ja": "[RFC6056]ラーセン、M.とF. Gont、BCP 156、RFC 6056、2011年1月 \"トランスポート・プロトコルポートランダム化のための提言\"。"
    },
    {
      "indent": 3,
      "text": "[proto_numbers] IANA, \"Protocol Numbers\", 2011, <http://www.iana.org/assignments/protocol-numbers>.",
      "ja": "[proto_numbers] IANA、 \"プロトコル番号\"、2011年、<http://www.iana.org/assignments/protocol-numbers>。"
    },
    {
      "indent": 0,
      "text": "21.2. Informative References",
      "section_title": true,
      "ja": "21.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[IGDv1] UPnP Gateway Committee, \"WANIPConnection:1\", November 2001, <http://upnp.org/specs/gw/ UPnP-gw-WANIPConnection-v1-Service.pdf>.",
      "ja": "[IGDv1]のUPnPゲートウェイ委員会、 \"WANIPConnection：1\"、2001年11月、<http://upnp.org/specs/gw/のUPnP-GW-WANIPConnection-V1-Service.pdf>。"
    },
    {
      "indent": 3,
      "text": "[L2NAT] Miles, D. and M. Townsley, \"Layer2-Aware NAT\", Work in Progress, March 2009.",
      "ja": "[L2NAT]マイル、D.とM. Townsley、 \"レイヤ2-AwareのNAT\"、進歩、2009年3月での作業。"
    },
    {
      "indent": 3,
      "text": "[PCP-FAIL] Boucadair, M., Dupont, F., and R. Penno, \"Port Control Protocol (PCP) Failure Scenarios\", Work in Progress, August 2012.",
      "ja": "[PCP-FAIL] Boucadair、M.、デュポン、F.、およびR. Penno、 \"ポート制御プロトコル（PCP）障害シナリオ\"、進歩、2012年8月での作業。"
    },
    {
      "indent": 3,
      "text": "[PNP-IGD-PCP] Boucadair, M., Penno, R., and D. Wing, \"Universal Plug and Play (UPnP) Internet Gateway Device (IGD)- Port Control Protocol (PCP) Interworking Function\", Work in Progress, December 2012.",
      "ja": "[PNP-IGD-PCPは] Boucadair、M.、Penno、R.、およびD.翼、 \"ユニバーサルプラグアンドプレイ（UPnP）インターネットゲートウェイデバイス（IGD） - ポート制御プロトコル（PCP）インターワーキング機能\" 進行中、作業、2012年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC0793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1918] Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and E. Lear, \"Address Allocation for Private Internets\", BCP 5, RFC 1918, February 1996.",
      "ja": "[RFC1918] Rekhter、Y.、モスコウィッツ、R.、Karrenberg、D.、グルート、G.、およびE.リア、 \"個人的なインターネットのための配分\"、BCP 5、RFC 1918、1996年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2136] Vixie, P., Thomson, S., Rekhter, Y., and J. Bound, \"Dynamic Updates in the Domain Name System (DNS UPDATE)\", RFC 2136, April 1997.",
      "ja": "[RFC2136]いるVixie、P.、トムソン、S.、Rekhter、Y.、およびJ.バウンド、 \"ドメインネームシステムにおける動的更新（DNS更新）\"、RFC 2136、1997年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3007] Wellington, B., \"Secure Domain Name System (DNS) Dynamic Update\", RFC 3007, November 2000.",
      "ja": "[RFC3007]ウェリントン、B.、RFC 3007、2000年11月 \"ドメインネームシステム（DNS）動的更新をセキュア\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3022] Srisuresh, P. and K. Egevang, \"Traditional IP Network Address Translator (Traditional NAT)\", RFC 3022, January 2001.",
      "ja": "[RFC3022] Srisuresh、P.とK. Egevang、 \"伝統的なIPネットワークアドレス変換（NAT繁体字）\"、RFC 3022、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3581] Rosenberg, J. and H. Schulzrinne, \"An Extension to the Session Initiation Protocol (SIP) for Symmetric Response Routing\", RFC 3581, August 2003.",
      "ja": "[RFC3581]ローゼンバーグ、J.、およびH. Schulzrinneと、 \"対称応答ルーティングのためのセッション開始プロトコル（SIP）への拡張\"、RFC 3581、2003年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3587] Hinden, R., Deering, S., and E. Nordmark, \"IPv6 Global Unicast Address Format\", RFC 3587, August 2003.",
      "ja": "[RFC3587] HindenとR.、デアリング、S.、およびE. Nordmarkと、 \"IPv6のグローバルユニキャストアドレス形式\"、RFC 3587、2003年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "ja": "[RFC4303]ケント、S.、 \"IPカプセル化セキュリティペイロード（ESP）\"、RFC 4303、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4340] Kohler, E., Handley, M., and S. Floyd, \"Datagram Congestion Control Protocol (DCCP)\", RFC 4340, March 2006.",
      "ja": "[RFC4340]コーラー、E.、ハンドリー、M.、およびS.フロイド、 \"データグラム輻輳制御プロトコル（DCCP）\"、RFC 4340、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4787] Audet, F. and C. Jennings, \"Network Address Translation (NAT) Behavioral Requirements for Unicast UDP\", BCP 127, RFC 4787, January 2007.",
      "ja": "[RFC4787] Audet、F.とC.ジェニングス、 \"ネットワークアドレス変換（NAT）ユニキャストUDPのための行動の要件\"、BCP 127、RFC 4787、2007年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4941] Narten, T., Draves, R., and S. Krishnan, \"Privacy Extensions for Stateless Address Autoconfiguration in IPv6\", RFC 4941, September 2007.",
      "ja": "[RFC4941] Narten氏、T.、Draves、R.、およびS.クリシュナン、 \"IPv6におけるステートレスアドレス自動設定のための個人情報保護の拡張\"、RFC 4941、2007年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., \"Stream Control Transmission Protocol\", RFC 4960, September 2007.",
      "ja": "[RFC4960]スチュワート、R.、 \"ストリーム制御伝送プロトコル\"、RFC 4960、2007年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4961] Wing, D., \"Symmetric RTP / RTP Control Protocol (RTCP)\", BCP 131, RFC 4961, July 2007.",
      "ja": "[RFC4961]ウイング、D.、 \"対称RTP / RTP制御プロトコル（RTCP）\"、BCP 131、RFC 4961、2007年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC5382] Guha, S., Biswas, K., Ford, B., Sivakumar, S., and P. Srisuresh, \"NAT Behavioral Requirements for TCP\", BCP 142, RFC 5382, October 2008.",
      "ja": "[RFC5382]グハ、S.、ビスワス、K.、フォード、B.、シバクマー、S.、およびP. Srisuresh、 \"TCPのためのNAT行動要件\"、BCP 142、RFC 5382、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC6092] Woodyatt, J., \"Recommended Simple Security Capabilities in Customer Premises Equipment (CPE) for Providing Residential IPv6 Internet Service\", RFC 6092, January 2011.",
      "ja": "[RFC6092] Woodyatt、J.は、RFC 6092、2011年1月 \"住宅IPv6インターネットサービスを提供するための顧客宅内機器（CPE）での簡単なセキュリティ機能を推奨します\"。"
    },
    {
      "indent": 3,
      "text": "[RFC6145] Li, X., Bao, C., and F. Baker, \"IP/ICMP Translation Algorithm\", RFC 6145, April 2011.",
      "ja": "[RFC6145]のLi、X.、バオ、C.、およびF.ベイカー、 \"IP / ICMP翻訳アルゴリズム\"、RFC 6145、2011年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC6146] Bagnulo, M., Matthews, P., and I. van Beijnum, \"Stateful NAT64: Network Address and Protocol Translation from IPv6 Clients to IPv4 Servers\", RFC 6146, April 2011.",
      "ja": "[RFC6146] Bagnulo、M.、マシューズ、P.、およびI.バンBeijnum、 \"ステートフルNAT64：IPv4のサーバーへのIPv6クライアントからのネットワークアドレスとプロトコル変換\"、RFC 6146、2011年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC6296] Wasserman, M. and F. Baker, \"IPv6-to-IPv6 Network Prefix Translation\", RFC 6296, June 2011.",
      "ja": "[RFC6296]ワッサーマン、M.およびF.ベイカー、 \"IPv6の対IPv6ネットワークプレフィックス翻訳\"、RFC 6296、2011年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC6333] Durand, A., Droms, R., Woodyatt, J., and Y. Lee, \"Dual-Stack Lite Broadband Deployments Following IPv4 Exhaustion\", RFC 6333, August 2011.",
      "ja": "[RFC6333]デュラン、A.、Droms、R.、Woodyatt、J.、およびY.リー、 \"IPv4の枯渇後デュアルスタックLiteのブロードバンドの展開\"、RFC 6333、2011年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6619] Arkko, J., Eggert, L., and M. Townsley, \"Scalable Operation of Address Translators with Per-Interface Bindings\", RFC 6619, June 2012.",
      "ja": "[RFC6619] Arkko、J.、Eggertの、L.、及びM. Townsley、 \"単位のインタフェースバインディングとアドレス変換のスケーラブル運用\"、RFC 6619、2012年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC6763] Cheshire, S. and M. Krochmal, \"DNS-Based Service Discovery\", RFC 6763, February 2013.",
      "ja": "[RFC6763]チェシャー、S.及びM. Krochmal、 \"DNSベースのサービス発見\"、RFC 6763、2013年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6886] Cheshire, S. and M. Krochmal, \"NAT Port Mapping Protocol (NAT-PMP)\", RFC 6886, April 2013.",
      "ja": "[RFC6886]チェシャー、S.及びM. Krochmal、 \"NATポート・マッピング・プロトコル（NAT-PMP）\"、RFC 6886、2013年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC6888] Perreault, S., Ed., Yamagata, I., Miyakawa, S., Nakagawa, A., and H. Ashida, \"Common Requirements for Carrier-Grade NATs (CGNs)\", BCP 127, RFC 6888, April 2013.",
      "ja": "[RFC6888]ペロー、S.編、山形、I.、宮川、S.、中川、A.、およびH.芦田、 \"キャリアグレードNATのための共通要件（CGNを）\"、BCP 127、RFC 6888、 2013年4月。"
    },
    {
      "indent": 3,
      "text": "[SCTPNAT] Stewart, R., Tuexen, M., and I. Ruengeler, \"Stream Control Transmission Protocol (SCTP) Network Address Translation\", Work in Progress, February 2013.",
      "ja": "【SCTPNAT]スチュワート、R.、Tuexen、M.、およびI. Ruengeler、 \"ストリーム制御伝送プロトコル（SCTP）ネットワークアドレス変換\"、進歩、2013年2月に働いています。"
    },
    {
      "indent": 0,
      "text": "Appendix A. NAT-PMP Transition",
      "ja": "付録A. NAT-PMPの変遷"
    },
    {
      "indent": 3,
      "text": "The Port Control Protocol (PCP) is a successor to the NAT Port Mapping Protocol, NAT-PMP [RFC6886], and shares similar semantics, concepts, and packet formats. Because of this, NAT-PMP and PCP both use the same port and use NAT-PMP and PCP's version negotiation capabilities to determine which version to use. This section describes how an orderly transition from NAT-PMP to PCP may be achieved.",
      "ja": "ポート制御プロトコル（PCP）は、NATポートマッピングプロトコル、NAT-PMP [RFC6886]、および株式と同様の意味論、概念、およびパケットフォーマットの後継です。このため、NAT-PMPとPCPの両方が同じポートを使用し、使用するバージョンを判断するためにNAT-PMPとPCPのバージョンネゴシエーション機能を使用しています。このセクションでは、PCPにNAT-PMPから秩序転移を達成することができる方法を記載しています。"
    },
    {
      "indent": 3,
      "text": "A client supporting both NAT-PMP and PCP SHOULD send its request using the PCP packet format. This will be received by a NAT-PMP server or a PCP server. If received by a NAT-PMP server, the response will be UNSUPP_VERSION, as indicated by the NAT-PMP specification [RFC6886], which will cause the client to downgrade to NAT-PMP and resend its request in NAT-PMP format. If received by a PCP server, the response will be as described by this document and processing continues as expected.",
      "ja": "NAT-PMPとPCPの両方をサポートするクライアントは、PCPのパケットフォーマットを使用して、その要求を送信すべきです。これは、NAT-PMPサーバーまたはPCPサーバによって受信されます。 NAT-PMPサーバによって受信された場合にはNAT-PMP仕様によって示されるように、応答は、クライアントがNAT-PMPにダウングレードし、NAT-PMP形式でその要求を再送信させるであろう、[RFC6886]、UNSUPP_VERSIONあろう。 PCPサーバによって受信された場合、応答は、この文書によって説明されると予想されるように処理が続行されます。"
    },
    {
      "indent": 3,
      "text": "A PCP server supporting both NAT-PMP and PCP can handle requests in either format. The first octet of the packet indicates if it is NAT-PMP (first octet zero) or PCP (first octet non-zero).",
      "ja": "NAT-PMPとPCPの両方をサポートするPCPサーバは、いずれかの形式で要求を処理することができます。それは、NAT-PMP（最初のオクテットゼロ）またはPCP（非ゼロの最初のオクテット）である場合、パケットの最初のオクテットを示します。"
    },
    {
      "indent": 3,
      "text": "A PCP-only gateway receiving a NAT-PMP request (identified by the first octet being zero) will interpret the request as a version mismatch. Normal PCP processing will emit a PCP response that is compatible with NAT-PMP, without any special handling by the PCP server.",
      "ja": "（ゼロである最初のオクテットで識別される）NAT-PMP要求を受信PCPのみのゲートウェイは、バージョンの不一致などの要求を解釈します。通常のPCP処理は、PCPサーバによって任意の特別な処理なしに、NAT-PMPと互換性のあるPCP応答を放出します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Dan Wing (editor) Cisco Systems, Inc. 170 West Tasman Drive San Jose, California 95134 USA",
      "ja": "ダン・ウィング（エディタ）は、シスコシステムズ、株式会社170西タスマン・ドライブサンノゼ、カリフォルニア95134 USA"
    },
    {
      "indent": 3,
      "text": "EMail: dwing@cisco.com",
      "ja": "メールアドレス：dwing@cisco.com"
    },
    {
      "indent": 3,
      "text": "Stuart Cheshire Apple Inc. 1 Infinite Loop Cupertino, California 95014 USA",
      "ja": "スチュアートチェシャーれたApple Inc. 1無限ループクパチーノ、カリフォルニア95014 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 974 3207 EMail: cheshire@apple.com",
      "ja": "電話：+1 408 974 3207 Eメール：cheshire@apple.com"
    },
    {
      "indent": 3,
      "text": "Mohamed Boucadair France Telecom Rennes 35000 France",
      "ja": "モハメド・Boucadairフランステレコム35000レンヌフランス"
    },
    {
      "indent": 3,
      "text": "EMail: mohamed.boucadair@orange.com",
      "ja": "メールアドレス：mohamed.boucadair@orange.com"
    },
    {
      "indent": 3,
      "text": "Reinaldo Penno Cisco Systems, Inc. 170 West Tasman Drive San Jose, California 95134 USA",
      "ja": "レイナルドPennoシスコシステムズ、株式会社170西タスマン・ドライブサンノゼ、カリフォルニア95134 USA"
    },
    {
      "indent": 3,
      "text": "EMail: repenno@cisco.com",
      "ja": "メールアドレス：repenno@cisco.com"
    },
    {
      "indent": 3,
      "text": "Paul Selkirk Internet Systems Consortium 950 Charter Street Redwood City, California 94063 USA",
      "ja": "ポール・セルカークインターネットシステムコンソーシアム950憲章ストリートレッドウッドシティ、カリフォルニア94063 USA"
    },
    {
      "indent": 3,
      "text": "EMail: pselkirk@isc.org",
      "ja": "メールアドレス：pselkirk@isc.org"
    }
  ]
}