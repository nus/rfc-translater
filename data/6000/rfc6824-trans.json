{
  "title": {
    "text": "RFC 6824 - TCP Extensions for Multipath Operation with Multiple Addresses",
    "ja": "RFC 6824 - 複数アドレスを持つマルチパス操作のためのTCP拡張機能"
  },
  "number": 6824,
  "created_at": "2019-10-31 10:07:48.920121+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           A. Ford\nRequest for Comments: 6824                                         Cisco\nCategory: Experimental                                         C. Raiciu\nISSN: 2070-1721                             U. Politechnica of Bucharest\n                                                              M. Handley\n                                                       U. College London\n                                                          O. Bonaventure\n                                                U. catholique de Louvain\n                                                            January 2013",
      "raw": true
    },
    {
      "indent": 5,
      "text": "TCP Extensions for Multipath Operation with Multiple Addresses",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "TCP/IP communication is currently restricted to a single path per connection, yet multiple paths often exist between peers. The simultaneous use of these multiple paths for a TCP/IP session would improve resource usage within the network and, thus, improve user experience through higher throughput and improved resilience to network failure.",
      "ja": "TCP / IP通信が現在接続ごとに単一経路に制限、まだ複数の経路は、多くの場合、ピア間に存在しています。 TCP / IPセッションのために、これらの複数の経路を同時に使用することは、ネットワーク内のリソース使用率を改善し、従って、ネットワーク障害へのより高いスループットおよび改善されたレジリエンスを介してユーザ・エクスペリエンスを改善します。"
    },
    {
      "indent": 3,
      "text": "Multipath TCP provides the ability to simultaneously use multiple paths between peers. This document presents a set of extensions to traditional TCP to support multipath operation. The protocol offers the same type of service to applications as TCP (i.e., reliable bytestream), and it provides the components necessary to establish and use multiple TCP flows across potentially disjoint paths.",
      "ja": "マルチTCP同時にピア間で複数のパスを使用する能力を提供します。この文書では、マルチパス操作をサポートするために、従来のTCPの拡張セットを提供します。プロトコルは、TCP（すなわち、信頼性の高いバイトストリーム）などのアプリケーションにサービスの同じ種類を提供し、それは潜在的にばらばらの経路を横切って複数のTCPフローを確立し、使用するために必要なコンポーネントを提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6824.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6824で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Design Assumptions .........................................4\n   1.2. Multipath TCP in the Networking Stack ......................5\n   1.3. Terminology ................................................6\n   1.4. MPTCP Concept ..............................................7\n   1.5. Requirements Language ......................................8\n2. Operation Overview ..............................................8\n   2.1. Initiating an MPTCP Connection .............................9\n   2.2. Associating a New Subflow with an Existing MPTCP\n        Connection .................................................9\n   2.3. Informing the Other Host about Another Potential Address ..10\n   2.4. Data Transfer Using MPTCP .................................11\n   2.5. Requesting a Change in a Path's Priority ..................11\n   2.6. Closing an MPTCP Connection ...............................12\n   2.7. Notable Features ..........................................12\n3. MPTCP Protocol .................................................12\n   3.1. Connection Initiation .....................................14\n   3.2. Starting a New Subflow ....................................18\n   3.3. General MPTCP Operation ...................................23\n        3.3.1. Data Sequence Mapping ..............................25\n        3.3.2. Data Acknowledgments ...............................28\n        3.3.3. Closing a Connection ...............................29\n        3.3.4. Receiver Considerations ............................30\n        3.3.5. Sender Considerations ..............................31\n        3.3.6. Reliability and Retransmissions ....................32\n        3.3.7. Congestion Control Considerations ..................33\n        3.3.8. Subflow Policy .....................................34\n   3.4. Address Knowledge Exchange (Path Management) ..............35\n        3.4.1. Address Advertisement ..............................36\n        3.4.2. Remove Address .....................................39\n   3.5. Fast Close ................................................40",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   3.6. Fallback ..................................................41\n   3.7. Error Handling ............................................45\n   3.8. Heuristics ................................................45\n        3.8.1. Port Usage .........................................46\n        3.8.2. Delayed Subflow Start ..............................46\n        3.8.3. Failure Handling ...................................47\n4. Semantic Issues ................................................48\n5. Security Considerations ........................................49\n6. Interactions with Middleboxes ..................................51\n7. Acknowledgments ................................................55\n8. IANA Considerations ............................................55\n9. References .....................................................57\n   9.1. Normative References ......................................57\n   9.2. Informative References ....................................57\nAppendix A. Notes on Use of TCP Options ...........................59\nAppendix B. Control Blocks ........................................60\n   B.1. MPTCP Control Block .......................................60\n        B.1.1. Authentication and Metadata ........................60\n        B.1.2. Sending Side .......................................61\n        B.1.3. Receiving Side .....................................61\n   B.2. TCP Control Blocks ........................................62\n        B.2.1. Sending Side .......................................62\n        B.2.2. Receiving Side .....................................62\nAppendix C. Finite State Machine ..................................63",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Multipath TCP (MPTCP) is a set of extensions to regular TCP [1] to provide a Multipath TCP [2] service, which enables a transport connection to operate across multiple paths simultaneously. This document presents the protocol changes required to add multipath capability to TCP; specifically, those for signaling and setting up multiple paths (\"subflows\"), managing these subflows, reassembly of data, and termination of sessions. This is not the only information required to create a Multipath TCP implementation, however. This document is complemented by three others:",
      "ja": "マルチTCP（MPTCP）は、同時に複数のパス間で動作するトランスポート接続を可能にするマルチTCP [2]サービスを提供するために、定期的なTCP [1]の拡張セットです。このドキュメントでは、TCPへのマルチパス機能を追加するために必要なプロトコルの変更を提示し、具体的には、シグナリングおよび（「サブフロー」）を複数のパスを設定する、これらのサブフロー、データの再組み立て、およびセッションの終了を管理するためのものです。しかしこれは、マルチパスTCPの実装を作成するために必要な情報だけではありません。この文書は、他の3人によって補完されます。"
    },
    {
      "indent": 3,
      "text": "o Architecture [2], which explains the motivations behind Multipath TCP, contains a discussion of high-level design decisions on which this design is based, and an explanation of a functional separation through which an extensible MPTCP implementation can be developed.",
      "ja": "OマルチパスTCP動機を説明アーキテクチャ[2]は、この設計が基づくハイレベル設計の決定の議論、および拡張可能MPTCP実装を開発することができ、それを通して機能分離の説明を含んでいます。"
    },
    {
      "indent": 3,
      "text": "o Congestion control [5] presents a safe congestion control algorithm for coupling the behavior of the multiple paths in order to \"do no harm\" to other network users.",
      "ja": "O輻輳制御[5]他のネットワークのユーザーに「害のない」ために、複数のパスの動作を結合するための安全な輻輳制御アルゴリズムを提示します。"
    },
    {
      "indent": 3,
      "text": "o Application considerations [6] discusses what impact MPTCP will have on applications, what applications will want to do with MPTCP, and as a consequence of these factors, what API extensions an MPTCP implementation should present.",
      "ja": "Oアプリケーションの考慮事項[6] MPTCPはMPTCPでやりたいだろうし、これらの要因の結果として、どのようなAPIの拡張機能MPTCP実装が提示すべきかのアプリケーション、アプリケーションになりますどのような影響について説明します。"
    },
    {
      "indent": 0,
      "text": "1.1. Design Assumptions",
      "section_title": true,
      "ja": "1.1. デザイン仮定"
    },
    {
      "indent": 3,
      "text": "In order to limit the potentially huge design space, the working group imposed two key constraints on the Multipath TCP design presented in this document:",
      "ja": "潜在的に巨大な設計空間を制限するために、ワーキンググループはこの文書のマルチTCPの設計上の2つのキー制約を課しました。"
    },
    {
      "indent": 3,
      "text": "o It must be backwards-compatible with current, regular TCP, to increase its chances of deployment.",
      "ja": "Oそれは、展開のその可能性を高めるために、現在、通常のTCPとの下位互換性がなければなりません。"
    },
    {
      "indent": 3,
      "text": "o It can be assumed that one or both hosts are multihomed and multiaddressed.",
      "ja": "O一方または両方のホストがマルチホームおよび同報されると仮定することができます。"
    },
    {
      "indent": 3,
      "text": "To simplify the design, we assume that the presence of multiple addresses at a host is sufficient to indicate the existence of multiple paths. These paths need not be entirely disjoint: they may share one or many routers between them. Even in such a situation, making use of multiple paths is beneficial, improving resource utilization and resilience to a subset of node failures. The congestion control algorithms defined in [5] ensure this does not act detrimentally. Furthermore, there may be some scenarios where different TCP ports on a single host can provide disjoint paths (such as through certain Equal-Cost Multipath (ECMP) implementations [7]), and so the MPTCP design also supports the use of ports in path identifiers.",
      "ja": "設計を簡素化するために、我々は、ホストで複数のアドレスが存在するが、複数の経路の存在を示すのに十分であることを前提としています。彼らは彼らの間に1つまたは多数のルータを共有することがあります。これらのパスは、完全に互いに素である必要はありません。でもこのような状況で、複数の経路を利用すると、ノード障害のサブセットにリソース使用率と回復力を向上させる、有益です。 [5]で定義された輻輳制御アルゴリズムこれは有害作用しないことを確認します。さらに、単一のホスト上の異なるTCPポートは、（例えば、特定の等価コストマルチパス（ECMP）の実装を介しとして[7]）互いに素な経路を提供することができ、そのためMPTCP設計はまた、パスのポートの使用をサポートするいくつかのシナリオがあってもよいです識別子。"
    },
    {
      "indent": 3,
      "text": "There are three aspects to the backwards-compatibility listed above (discussed in more detail in [2]):",
      "ja": "（[2]でより詳細に説明）上記の下位互換性には3つの側面があります。"
    },
    {
      "indent": 3,
      "text": "External Constraints: The protocol must function through the vast majority of existing middleboxes such as NATs, firewalls, and proxies, and as such must resemble existing TCP as far as possible on the wire. Furthermore, the protocol must not assume the segments it sends on the wire arrive unmodified at the destination: they may be split or coalesced; TCP options may be removed or duplicated.",
      "ja": "外部制約：プロトコルは、このようなNATの、ファイアウォール、プロキシなどの既存ミドルボックスの大半を介して機能しなければならない、そのように、可能な限りワイヤ上のTCPを既存似ている必要があります。さらに、プロトコルは、ワイヤ上で送信セグメントが目的地に到着する非修飾仮定してはならない：それらは分割または合体されてもよいです。 TCPオプションを削除または複製することができます。"
    },
    {
      "indent": 3,
      "text": "Application Constraints: The protocol must be usable with no change to existing applications that use the common TCP API (although it is reasonable that not all features would be available to such legacy applications). Furthermore, the protocol must provide the same service model as regular TCP to the application.",
      "ja": "アプリケーションの制約：プロトコルは、（ないすべての機能は、このようなレガシーアプリケーションに利用できるようになることが合理的であるが）一般的なTCPのAPIを使用する既存のアプリケーションを変更せずに使用可能でなければなりません。さらに、プロトコルは、アプリケーションへの定期的なTCPと同じサービスモデルを提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Fallback: The protocol should be able to fall back to standard TCP with no interference from the user, to be able to communicate with legacy hosts.",
      "ja": "フォールバック：プロトコルは、従来のホストと通信することができるように、ユーザからの干渉とバック標準TCPに落下することができなければなりません。"
    },
    {
      "indent": 3,
      "text": "The complementary application considerations document [6] discusses the necessary features of an API to provide backwards-compatibility, as well as API extensions to convey the behavior of MPTCP at a level of control and information equivalent to that available with regular, single-path TCP.",
      "ja": "相補的なアプリケーションの考慮事項文書[6]レギュラー、シングルパスTCPとその利用可能に制御情報同等のレベルでMPTCPの挙動を伝達するために必要な下位互換性を提供するAPIの機能、ならびにAPIの拡張を説明し。"
    },
    {
      "indent": 3,
      "text": "Further discussion of the design constraints and associated design decisions are given in the MPTCP Architecture document [2] and in [8].",
      "ja": "また、設計上の制約の議論と関連した設計上の決定はMPTCPアーキテクチャ文書に記載されている[2]、[8]インチ"
    },
    {
      "indent": 0,
      "text": "1.2. Multipath TCP in the Networking Stack",
      "section_title": true,
      "ja": "1.2. ネットワーキングスタック内のマルチパスTCP"
    },
    {
      "indent": 3,
      "text": "MPTCP operates at the transport layer and aims to be transparent to both higher and lower layers. It is a set of additional features on top of standard TCP; Figure 1 illustrates this layering. MPTCP is designed to be usable by legacy applications with no changes; detailed discussion of its interactions with applications is given in [6].",
      "ja": "MPTCPは、トランスポート層で動作し、両方とも高く、下層に透明であることを目的とします。これは、標準のTCPの上の追加機能のセットです。図1は、この階層化を示す図です。 MPTCPは何も変更せずに、レガシーアプリケーションで使用できるように設計されています。アプリケーションとの相互作用の詳細な説明は、[6]に記載されています。"
    },
    {
      "indent": 6,
      "text": "                             +-------------------------------+\n                             |           Application         |\n+---------------+            +-------------------------------+\n|  Application  |            |             MPTCP             |\n+---------------+            + - - - - - - - + - - - - - - - +\n|      TCP      |            | Subflow (TCP) | Subflow (TCP) |\n+---------------+            +-------------------------------+\n|      IP       |            |       IP      |      IP       |\n+---------------+            +-------------------------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 1: Comparison of Standard TCP and MPTCP Protocol Stacks",
      "ja": "図1：標準TCPとMPTCPプロトコルスタックの比較"
    },
    {
      "indent": 0,
      "text": "1.3. Terminology",
      "section_title": true,
      "ja": "1.3. 用語"
    },
    {
      "indent": 3,
      "text": "This document makes use of a number of terms that are either MPTCP-specific or have defined meaning in the context of MPTCP, as follows:",
      "ja": "次のようにこの文書では、MPTCP固有またはMPTCPのコンテキストで意味を定義しているのどちらかである項の数を使用します："
    },
    {
      "indent": 3,
      "text": "Path: A sequence of links between a sender and a receiver, defined in this context by a 4-tuple of source and destination address/ port pairs.",
      "ja": "パス：送信元と宛先アドレス/ポートのペアの4タプルによって、この文脈で定義される送信者と受信者との間のリンクの配列。"
    },
    {
      "indent": 3,
      "text": "Subflow: A flow of TCP segments operating over an individual path, which forms part of a larger MPTCP connection. A subflow is started and terminated similar to a regular TCP connection.",
      "ja": "サブフロー：大きなMPTCP接続の一部を形成する個々の経路上で動作するTCPセグメントの流れ。サブフローが開始され、通常のTCPコネクションに似て終了します。"
    },
    {
      "indent": 3,
      "text": "(MPTCP) Connection: A set of one or more subflows, over which an application can communicate between two hosts. There is a one-to-one mapping between a connection and an application socket.",
      "ja": "（MPTCP）接続：アプリケーションが2つのホスト間で通信することができる上に一つ以上のサブフローのセット。接続とアプリケーションのソケットの間に1対1のマッピングがあります。"
    },
    {
      "indent": 3,
      "text": "Data-level: The payload data is nominally transferred over a connection, which in turn is transported over subflows. Thus, the term \"data-level\" is synonymous with \"connection level\", in contrast to \"subflow-level\", which refers to properties of an individual subflow.",
      "ja": "データレベル：ペイロードデータが名目順でサブフローを介して転送される接続を介して転送されます。したがって、用語「データレベル」は対照的に、個々のサブフローの特性を意味する「サブフローレベル」、「接続レベル」と同義です。"
    },
    {
      "indent": 3,
      "text": "Token: A locally unique identifier given to a multipath connection by a host. May also be referred to as a \"Connection ID\".",
      "ja": "トークン：ホストによってマルチパス接続に与えられたローカルで一意の識別子。また、「接続ID」と呼ばれることもあります。"
    },
    {
      "indent": 3,
      "text": "Host: An end host operating an MPTCP implementation, and either initiating or accepting an MPTCP connection.",
      "ja": "ホスト：エンドホストMPTCPの実装を動作させる、のいずれかMPTCP接続を開始するか、受け入れること。"
    },
    {
      "indent": 3,
      "text": "In addition to these terms, note that MPTCP's interpretation of, and effect on, regular single-path TCP semantics are discussed in Section 4.",
      "ja": "これらの用語に加えて、MPTCPの解釈、および、通常のシングルパスTCPのセマンティクスへの影響は第4節で議論されていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "1.4. MPTCP Concept",
      "section_title": true,
      "ja": "1.4.  MPTCPコンセプト"
    },
    {
      "indent": 3,
      "text": "This section provides a high-level summary of normal operation of MPTCP, and is illustrated by the scenario shown in Figure 2. A detailed description of operation is given in Section 3.",
      "ja": "このセクションでは、MPTCPの通常の動作の高レベルの概要を提供し、操作の詳細な説明は、セクション3に記載されている図2に示されているシナリオによって示されています。"
    },
    {
      "indent": 3,
      "text": "o To a non-MPTCP-aware application, MPTCP will behave the same as normal TCP. Extended APIs could provide additional control to MPTCP-aware applications [6]. An application begins by opening a TCP socket in the normal way. MPTCP signaling and operation are handled by the MPTCP implementation.",
      "ja": "非MPTCP対応のアプリケーションにO、MPTCPは通常のTCPと同じように動作します。拡張APIはMPTCP対応アプリケーション[6]に追加の制御を提供することができます。アプリケーションは、通常の方法でTCPソケットを開くことによって開始されます。 MPTCPシグナリング及び動作はMPTCP実装によって処理されます。"
    },
    {
      "indent": 3,
      "text": "o An MPTCP connection begins similarly to a regular TCP connection. This is illustrated in Figure 2 where an MPTCP connection is established between addresses A1 and B1 on Hosts A and B, respectively.",
      "ja": "O MPTCP接続は、通常のTCP接続と同様に始まります。これはMPTCP接続がそれぞれ、ホストA及びBにアドレスA1とB1との間に確立されている図2に示されています。"
    },
    {
      "indent": 3,
      "text": "o If extra paths are available, additional TCP sessions (termed MPTCP \"subflows\") are created on these paths, and are combined with the existing session, which continues to appear as a single connection to the applications at both ends. The creation of the additional TCP session is illustrated between Address A2 on Host A and Address B1 on Host B.",
      "ja": "余分なパスが利用可能な場合は、O、追加のTCPセッションが（と呼ばれるMPTCP「サブフロー」）は、これらのパスに作成され、両端のアプリケーションへの単一の接続として引き続き表示される既存のセッションと組み合わせています。追加のTCPセッションの作成は、ホストB上のホストAとアドレスB1上のアドレスA2の間で示されています"
    },
    {
      "indent": 3,
      "text": "o MPTCP identifies multiple paths by the presence of multiple addresses at hosts. Combinations of these multiple addresses equate to the additional paths. In the example, other potential paths that could be set up are A1<->B2 and A2<->B2. Although this additional session is shown as being initiated from A2, it could equally have been initiated from B1.",
      "ja": "O MPTCPは、ホストに複数のアドレスが存在することによって複数のパスを識別する。これらの複数のアドレスの組み合わせは、追加のパスに等しいです。 < - > B2とA2 < - > B2の例では、設定することができる他の潜在的なパスがA1です。この追加のセッションがA2から開始されるように示されているが、それは同様にB1から開始されている可能性があります。"
    },
    {
      "indent": 3,
      "text": "o The discovery and setup of additional subflows will be achieved through a path management method; this document describes a mechanism by which a host can initiate new subflows by using its own additional addresses, or by signaling its available addresses to the other host.",
      "ja": "発見及びパス管理方法によって達成されるであろう追加のサブフローの設定O。このドキュメントは、または他のホストへの利用可能なアドレスを知らせることにより、ホストは独自の追加アドレスを使用して、新しいサブフローを開始できるメカニズムを説明します。"
    },
    {
      "indent": 3,
      "text": "o MPTCP adds connection-level sequence numbers to allow the reassembly of segments arriving on multiple subflows with differing network delays.",
      "ja": "O MPTCPは、ネットワークの遅延が異なる複数のサブフローに到着したセグメントの再構築を可能にするために、接続レベルのシーケンス番号を追加します。"
    },
    {
      "indent": 3,
      "text": "o Subflows are terminated as regular TCP connections, with a four-way FIN handshake. The MPTCP connection is terminated by a connection-level FIN.",
      "ja": "Oサブフローは、4ウェイハンドシェイクFINで、通常のTCPコネクションとして終了されます。 MPTCP接続は、接続レベルのFINで終了します。"
    },
    {
      "indent": 6,
      "text": "         Host A                               Host B\n------------------------             ------------------------\nAddress A1    Address A2             Address B1    Address B2\n----------    ----------             ----------    ----------\n    |             |                      |             |\n    |     (initial connection setup)     |             |\n    |----------------------------------->|             |\n    |<-----------------------------------|             |\n    |             |                      |             |\n    |            (additional subflow setup)            |\n    |             |--------------------->|             |\n    |             |<---------------------|             |\n    |             |                      |             |\n    |             |                      |             |",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 2: Example MPTCP Usage Scenario",
      "ja": "図2：例MPTCPの使用シナリオ"
    },
    {
      "indent": 0,
      "text": "1.5. Requirements Language",
      "section_title": true,
      "ja": "1.5. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [3].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119に記載されるように解釈される[3]。"
    },
    {
      "indent": 0,
      "text": "2. Operation Overview",
      "section_title": true,
      "ja": "2.動作概要"
    },
    {
      "indent": 3,
      "text": "This section presents a single description of common MPTCP operation, with reference to the protocol operation. This is a high-level overview of the key functions; the full specification follows in Section 3. Extensibility and negotiated features are not discussed here. Considerable reference is made to symbolic names of MPTCP options throughout this section -- these are subtypes of the IANA-assigned MPTCP option (see Section 8), and their formats are defined in the detailed protocol specification that follows in Section 3.",
      "ja": "このセクションでは、プロトコルの動作を参照して、共通MPTCP動作の単一の説明を提示します。これは、キーの機能の高レベルの概要です。完全な仕様は、第3節拡張性に追従し、交渉さの特徴は、ここで議論されていません。かなりの参照は、このセクション全体MPTCPオプションのシンボル名に言及する - これらは、IANAによって割り当てられMPTCPオプションのサブタイプ（セクション8を参照）であり、そのフォーマットはセクション3に、以下の詳細なプロトコル仕様で定義されています。"
    },
    {
      "indent": 3,
      "text": "A Multipath TCP connection provides a bidirectional bytestream between two hosts communicating like normal TCP and, thus, does not require any change to the applications. However, Multipath TCP enables the hosts to use different paths with different IP addresses to exchange packets belonging to the MPTCP connection. A Multipath TCP connection appears like a normal TCP connection to an application. However, to the network layer, each MPTCP subflow looks like a regular TCP flow whose segments carry a new TCP option type. Multipath TCP manages the creation, removal, and utilization of these subflows to send data. The number of subflows that are managed within a Multipath TCP connection is not fixed and it can fluctuate during the lifetime of the Multipath TCP connection.",
      "ja": "マルチパスTCP接続が正常TCPのような通信し、したがって、アプリケーションに変更を必要としない2つのホスト間の双方向バイトストリームを提供します。しかし、マルチパスTCPはMPTCP接続に属するパケットを交換するために、異なるIPアドレスを持つ別のパスを使用するホストを可能にします。マルチTCPコネクションは、アプリケーションへの通常のTCP接続のように表示されます。しかし、ネットワーク層に、各MPTCPのサブフローは、そのセグメントの新しいTCPオプションの種類を運ぶ通常のTCPフローのように見えます。マルチパスTCPは、データを送信するためにこれらのサブフローの作成、削除、および利用を管理します。マルチTCPコネクション内で管理されているサブフローの数は固定されておらず、それがマルチTCPコネクションの存続期間中に変動することができます。"
    },
    {
      "indent": 3,
      "text": "All MPTCP operations are signaled with a TCP option -- a single numerical type for MPTCP, with \"sub-types\" for each MPTCP message. What follows is a summary of the purpose and rationale of these messages.",
      "ja": "MPTCPのための単一の数値タイプ、各MPTCPメッセージの「サブタイプ」と - すべてMPTCP操作は、TCPオプションでシグナリングされます。以下は、これらのメッセージの目的や根拠の要約です。"
    },
    {
      "indent": 0,
      "text": "2.1. Initiating an MPTCP Connection",
      "section_title": true,
      "ja": "2.1.  MPTCP接続を開始"
    },
    {
      "indent": 3,
      "text": "This is the same signaling as for initiating a normal TCP connection, but the SYN, SYN/ACK, and ACK packets also carry the MP_CAPABLE option. This is variable length and serves multiple purposes. Firstly, it verifies whether the remote host supports Multipath TCP; secondly, this option allows the hosts to exchange some information to authenticate the establishment of additional subflows. Further details are given in Section 3.1.",
      "ja": "これは、通常のTCP接続を開始すると同じシグナルですが、SYN、SYN / ACK、およびACKパケットもMP_CAPABLEオプションを運びます。これは可変長であり、複数の目的を果たします。第一に、それは、リモートホストがマルチパスTCPをサポートしているかどうかを検証します。第二に、このオプションは、ホストが追加のサブフローの設立を認証するために、いくつかの情報を交換することができます。更なる詳細は、3.1節に記載されています。"
    },
    {
      "indent": 6,
      "text": "Host A                                  Host B\n------                                  ------\nMP_CAPABLE            ->\n[A's key, flags]\n                      <-                MP_CAPABLE\n                                        [B's key, flags]\nACK + MP_CAPABLE      ->\n[A's key, B's key, flags]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.2. Associating a New Subflow with an Existing MPTCP Connection",
      "section_title": true,
      "ja": "2.2. 既存MPTCP接続で新しいサブフローの関連付け"
    },
    {
      "indent": 3,
      "text": "The exchange of keys in the MP_CAPABLE handshake provides material that can be used to authenticate the endpoints when new subflows will be set up. Additional subflows begin in the same way as initiating a normal TCP connection, but the SYN, SYN/ACK, and ACK packets also carry the MP_JOIN option.",
      "ja": "MP_CAPABLE握手で鍵の交換は、新たなサブフローが設定されたときに、エンドポイントを認証するために使用することができます材料を提供します。追加のサブフローは、通常のTCP接続を開始すると同じように始まるが、SYN、SYN / ACK、およびACKパケットもMP_JOINオプションを運びます。"
    },
    {
      "indent": 3,
      "text": "Host A initiates a new subflow between one of its addresses and one of Host B's addresses. The token -- generated from the key -- is used to identify which MPTCP connection it is joining, and the HMAC is used for authentication. The Hash-based Message Authentication Code (HMAC) uses the keys exchanged in the MP_CAPABLE handshake, and the random numbers (nonces) exchanged in these MP_JOIN options. MP_JOIN also contains flags and an Address ID that can be used to refer to the source address without the sender needing to know if it has been changed by a NAT. Further details are in Section 3.2.",
      "ja": "ホストAは、そのアドレスのいずれかとホストBのアドレスのいずれかの間に新しいサブフローを開始します。トークン - キーから生成されたが - それが接合されMPTCP接続識別するために使用され、そしてHMAC認証のために使用されます。ハッシュベースのメッセージ認証コード（HMAC）は、キーがMP_CAPABLEハンドシェイクで交換し、乱数（ナンス）はこれらのMP_JOINオプションに交換し使用しています。 MP_JOINもフラグと、それはNATによって変更されているかどうかを知る必要が送信者なしで送信元アドレスを参照するために使用することができ、アドレスIDが含まれています。更なる詳細は、3.2節です。"
    },
    {
      "indent": 6,
      "text": "Host A                                  Host B\n------                                  ------\nMP_JOIN               ->\n[B's token, A's nonce,\n A's Address ID, flags]\n                      <-                MP_JOIN\n                                        [B's HMAC, B's nonce,\n                                         B's Address ID, flags]\nACK + MP_JOIN         ->\n[A's HMAC]",
      "raw": true
    },
    {
      "indent": 28,
      "text": "<- ACK",
      "ja": "< -  ACK"
    },
    {
      "indent": 0,
      "text": "2.3. Informing the Other Host about Another Potential Address",
      "section_title": true,
      "ja": "2.3. 別の潜在アドレスについての他のホストへの通知"
    },
    {
      "indent": 3,
      "text": "The set of IP addresses associated to a multihomed host may change during the lifetime of an MPTCP connection. MPTCP supports the addition and removal of addresses on a host both implicitly and explicitly. If Host A has established a subflow starting at address IP#-A1 and wants to open a second subflow starting at address IP#-A2, it simply initiates the establishment of the subflow as explained above. The remote host will then be implicitly informed about the new address.",
      "ja": "マルチホームホストに関連付けられたIPアドレスのセットはMPTCP接続の寿命の間に変化してもよいです。 MPTCPは両方の暗黙的および明示的ホスト上の追加やアドレスの削除をサポートしています。ホストAは、アドレスIP＃-A1でサブフローの開始を確立し、アドレスIP＃-A2から始まる第二サブフローを開きたいた場合は上記で説明したように、それは単にサブフローの確立を開始します。リモートホストは、暗黙のうちに新しいアドレスについて通知されます。"
    },
    {
      "indent": 3,
      "text": "In some circumstances, a host may want to advertise to the remote host the availability of an address without establishing a new subflow, for example, when a NAT prevents setup in one direction. In the example below, Host A informs Host B about its alternative IP address (IP#-A2). Host B may later send an MP_JOIN to this new address. Due to the presence of middleboxes that may translate IP addresses, this option uses an address identifier to unambiguously identify an address on a host. Further details are in Section 3.4.1.",
      "ja": "いくつかの状況では、ホストは、NATが一方向にセットアップを防止する場合、例えば、新しいサブフローを確立することなく、リモートホストへのアドレスの可用性を宣伝することもできます。以下の例では、ホストAは、その別のIPアドレス（IP＃-A2）約ホストBに通知します。ホストBは、後に、この新しいアドレスにMP_JOINを送信することができます。 IPアドレスを変換することがミドルボックスの存在のために、このオプションは明確ホスト上のアドレスを識別するためのアドレス識別子を使用しています。更なる詳細は、3.4.1項です。"
    },
    {
      "indent": 6,
      "text": "Host A                                 Host B\n------                                 ------\nADD_ADDR                  ->\n[IP#-A2,\n IP#-A2's Address ID]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "There is a corresponding signal for address removal, making use of the Address ID that is signaled in the add address handshake. Further details in Section 3.4.2.",
      "ja": "追加アドレスハンドシェイクで通知されている住所のIDを利用したアドレスを除去するための対応する信号は、あります。 3.4.2項のさらなる詳細が表示されます。"
    },
    {
      "indent": 6,
      "text": "Host A                                 Host B\n------                                 ------\nREMOVE_ADDR               ->\n[IP#-A2's Address ID]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.4. Data Transfer Using MPTCP",
      "section_title": true,
      "ja": "2.4.  MPTCPを使用したデータ転送"
    },
    {
      "indent": 3,
      "text": "To ensure reliable, in-order delivery of data over subflows that may appear and disappear at any time, MPTCP uses a 64-bit data sequence number (DSN) to number all data sent over the MPTCP connection. Each subflow has its own 32-bit sequence number space and an MPTCP option maps the subflow sequence space to the data sequence space. In this way, data can be retransmitted on different subflows (mapped to the same DSN) in the event of failure.",
      "ja": "任意の時点で現れ、消えることがサブフローを介してデータの信頼性、順序配信を保証するために、MPTCPはMPTCP接続を介して送信されるすべてのデータに番号を付けるために、64ビットのデータシーケンス番号（DSN）を使用します。各サブフローは、独自の32ビットのシーケンス番号空間とMPTCPオプションは、データ・シーケンス空間にサブフロー配列スペースをマッピングしています。このように、データは、障害が発生した場合に（同じDSNにマッピングされた）別のサブフローに再送信することができます。"
    },
    {
      "indent": 3,
      "text": "The \"Data Sequence Signal\" carries the \"Data Sequence Mapping\". The data sequence mapping consists of the subflow sequence number, data sequence number, and length for which this mapping is valid. This option can also carry a connection-level acknowledgment (the \"Data ACK\") for the received DSN.",
      "ja": "「データシーケンス信号は、」「データシーケンスマッピング」を運びます。データ列マッピングは、このマッピングが有効であるサブフローシーケンス番号、データシーケンス番号、及び長さから成ります。このオプションは、受信したDSNの接続レベルの確認（「データACK」）を運ぶことができます。"
    },
    {
      "indent": 3,
      "text": "With MPTCP, all subflows share the same receive buffer and advertise the same receive window. There are two levels of acknowledgment in MPTCP. Regular TCP acknowledgments are used on each subflow to acknowledge the reception of the segments sent over the subflow independently of their DSN. In addition, there are connection-level acknowledgments for the data sequence space. These acknowledgments track the advancement of the bytestream and slide the receiving window.",
      "ja": "MPTCPでは、すべてのサブフローが同じで、同じ受信ウィンドウをバッファリングし、宣伝受け取る共有しています。 MPTCPでの承認の2つのレベルがあります。定期的なTCP確認応答を独立して自分のDSNのサブフローを介して送信されたセグメントの受信を確認するために、各サブフローに使用されています。また、データのシーケンス空間のための接続レベルの確認応答があります。これらの確認応答は、バイトストリームの進歩を追跡し、受信ウィンドウをスライドさせます。"
    },
    {
      "indent": 3,
      "text": "Further details are in Section 3.3.",
      "ja": "更なる詳細は、3.3節です。"
    },
    {
      "indent": 6,
      "text": "Host A                                 Host B\n------                                 ------\nDATA_SEQUENCE_SIGNAL      ->\n[Data Sequence Mapping]\n[Data ACK]\n[Checksum]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.5. Requesting a Change in a Path's Priority",
      "section_title": true,
      "ja": "2.5. パスの優先順位の変更を要求します"
    },
    {
      "indent": 3,
      "text": "Hosts can indicate at initial subflow setup whether they wish the subflow to be used as a regular or backup path -- a backup path only being used if there are no regular paths available. During a connection, Host A can request a change in the priority of a subflow through the MP_PRIO signal to Host B. Further details are in Section 3.3.8.",
      "ja": "利用可能な定期的なパスが存在しない場合にのみ使用されているバックアップパス - ホストは、彼らが定期的またはバックアップパスとして使用するサブフローを希望するかどうかの初期設定サブフローで示すことができます。接続時に、ホストAは、Bのさらなる詳細は、セクション3.3.8にあるホストするMP_PRIO信号を通じてサブフローの優先順位の変更を要求することができます。"
    },
    {
      "indent": 6,
      "text": "Host A                                 Host B\n------                                 ------\nMP_PRIO                   ->",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.6. Closing an MPTCP Connection",
      "section_title": true,
      "ja": "2.6.  MPTCP接続を閉じます"
    },
    {
      "indent": 3,
      "text": "When Host A wants to inform Host B that it has no more data to send, it signals this \"Data FIN\" as part of the Data Sequence Signal (see above). It has the same semantics and behavior as a regular TCP FIN, but at the connection level. Once all the data on the MPTCP connection has been successfully received, then this message is acknowledged at the connection level with a DATA_ACK. Further details are in Section 3.3.3.",
      "ja": "ホストAは、それが送信するデータがなくなるホストBに通知したい場合は、データシーケンス信号の一部として、この「データFINを」（上記参照）信号。これは、通常のTCP FINと同じセマンティクスと動作を持っていますが、接続レベルで。 MPTCP接続上のすべてのデータが正常に受信されると、その後、このメッセージはDATA_ACKとの接続レベルで認められています。更なる詳細は、3.3.3項です。"
    },
    {
      "indent": 6,
      "text": "Host A                                 Host B\n------                                 ------\nDATA_SEQUENCE_SIGNAL      ->\n[Data FIN]",
      "raw": true
    },
    {
      "indent": 32,
      "text": "<- (MPTCP DATA_ACK)",
      "ja": "< - （MPTCP DATA_ACK）"
    },
    {
      "indent": 0,
      "text": "2.7. Notable Features",
      "section_title": true,
      "ja": "2.7. 注目すべき機能"
    },
    {
      "indent": 3,
      "text": "It is worth highlighting that MPTCP's signaling has been designed with several key requirements in mind:",
      "ja": "MPTCPのシグナリングが心の中でいくつかの重要な要件で設計されていることを強調し価値があります："
    },
    {
      "indent": 3,
      "text": "o To cope with NATs on the path, addresses are referred to by Address IDs, in case the IP packet's source address gets changed by a NAT. Setting up a new TCP flow is not possible if the passive opener is behind a NAT; to allow subflows to be created when either end is behind a NAT, MPTCP uses the ADD_ADDR message.",
      "ja": "IPパケットの送信元アドレスがNATによって変更されます場合には、パス上のNATに対応するため、Oは、アドレスは、アドレスのIDによって参照されています。パッシブオープナーがNATの背後にある場合、新しいTCPフローを設定することはできません。サブフローがNATの背後にあるとき、どちらかの端に作成できるようにするために、MPTCPはADD_ADDRメッセージを使用しています。"
    },
    {
      "indent": 3,
      "text": "o MPTCP falls back to ordinary TCP if MPTCP operation is not possible, for example, if one host is not MPTCP capable or if a middlebox alters the payload.",
      "ja": "一つのホストが可能MPTCPされていない場合、またはミドルはペイロードを変更する場合MPTCP操作は、例えば、可能でない場合、O MPTCPバック通常のTCPに落ちます。"
    },
    {
      "indent": 3,
      "text": "o To meet the threats identified in [9], the following steps are taken: keys are sent in the clear in the MP_CAPABLE messages; MP_JOIN messages are secured with HMAC-SHA1 ([10], [4]) using those keys; and standard TCP validity checks are made on the other messages (ensuring sequence numbers are in-window).",
      "ja": "[9]で識別された脅威を満たすために、Oは、以下のステップがとられています。キーはMP_CAPABLEメッセージに平文で送信されます。 MP_JOINメッセージがHMAC-SHA1で固定されている（[10]、[4]）これらのキーを使用して、標準TCPの妥当性チェックは他のメッセージ（確実にシーケンス番号がインウインドウある）で作られています。"
    },
    {
      "indent": 0,
      "text": "3. MPTCP Protocol",
      "section_title": true,
      "ja": "3. MPTCPプロトコル"
    },
    {
      "indent": 3,
      "text": "This section describes the operation of the MPTCP protocol, and is subdivided into sections for each key part of the protocol operation.",
      "ja": "このセクションでは、MPTCPプロトコルの動作を説明、およびプロトコル動作の各キー部分のセクションに細分されます。"
    },
    {
      "indent": 3,
      "text": "All MPTCP operations are signaled using optional TCP header fields. A single TCP option number (\"Kind\") has been assigned by IANA for MPTCP (see Section 8), and then individual messages will be determined by a \"subtype\", the values of which are also stored in an IANA registry (and are also listed in Section 8).",
      "ja": "全てMPTCP操作は、任意のTCPヘッダフィールドを使用してシグナリングされます。単一のTCPオプション番号（「種類」）は（セクション8を参照）MPTCPためのIANAによって割り当てられており、個々のメッセージは、「サブタイプ」によって決定される、の値は、IANAレジストリに格納されている（とされていますまた）、セクション8に記載されています。"
    },
    {
      "indent": 3,
      "text": "Throughout this document, when reference is made to an MPTCP option by symbolic name, such as \"MP_CAPABLE\", this refers to a TCP option with the single MPTCP option type, and with the subtype value of the symbolic name as defined in Section 8. This subtype is a 4-bit field -- the first 4 bits of the option payload, as shown in Figure 3. The MPTCP messages are defined in the following sections.",
      "ja": "基準は、例えば、「MP_CAPABLE」として、シンボル名によってMPTCPオプションに行われ、この文書全体を通して、これは単一MPTCPオプションタイプのTCPオプションを参照して、シンボル名のサブタイプ値とセクション8で定義した通りです。 MPTCPメッセージは、次のセクションで定義され、図3に示すように、オプションのペイロードの最初の4ビット - このサブタイプは、4ビットのフィールドです。"
    },
    {
      "indent": 6,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------+-----------------------+\n|     Kind      |    Length     |Subtype|                       |\n+---------------+---------------+-------+                       |\n|                     Subtype-specific data                     |\n|                       (variable length)                       |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 3: MPTCP Option Format",
      "ja": "図3：MPTCPオプションフォーマット"
    },
    {
      "indent": 3,
      "text": "Those MPTCP options associated with subflow initiation are used on packets with the SYN flag set. Additionally, there is one MPTCP option for signaling metadata to ensure segmented data can be recombined for delivery to the application.",
      "ja": "サブフロー開始に関連するものMPTCPオプションは、SYNフラグが設定されたパケットで使用されます。また、セグメント化されたデータを確実にするために、メタデータを知らせるための1つのMPTCPオプションは、アプリケーションへの配信のために再結合することができますがあります。"
    },
    {
      "indent": 3,
      "text": "The remaining options, however, are signals that do not need to be on a specific packet, such as those for signaling additional addresses. Whilst an implementation may desire to send MPTCP options as soon as possible, it may not be possible to combine all desired options (both those for MPTCP and for regular TCP, such as SACK (selective acknowledgment) [11]) on a single packet. Therefore, an implementation may choose to send duplicate ACKs containing the additional signaling information. This changes the semantics of a duplicate ACK; these are usually only sent as a signal of a lost segment [12] in regular TCP. Therefore, an MPTCP implementation receiving a duplicate ACK that contains an MPTCP option MUST NOT treat it as a signal of congestion. Additionally, an MPTCP implementation SHOULD NOT send more than two duplicate ACKs in a row for the purposes of sending MPTCP options alone, in order to ensure no middleboxes misinterpret this as a sign of congestion.",
      "ja": "残りのオプションは、しかし、このような追加のアドレスを知らせるためのものと特定のパケットにする必要はありません信号です。実装はできるだけ早くMPTCPオプションを送信することを望むかもしれない一方で、単一のパケットのすべての必要なオプション（例えば、SACK（選択的確認応答）としてMPTCPおよび定期的なTCPのもの、[11]の両方）を組み合わせることが可能ではないかもしれません。そのため、実装が追加のシグナリング情報を含む重複ACKを送信することもできます。これは、重複ACKの意味を変更します。これらは、通常は定期的なTCPで失われたセグメント[12]の信号として送信されます。したがって、MPTCPオプションが含まれている重複ACKを受信MPTCPの実装では、混雑の信号として扱うてはなりません。また、MPTCPの実装にはミドルボックスは、輻輳の兆候としてこれを誤解しない確実にするために、一人でMPTCPオプションを送信する目的のために列に二つ以上の重複ACKを送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "Furthermore, standard TCP validity checks (such as ensuring the sequence number and acknowledgment number are within window) MUST be undertaken before processing any MPTCP signals, as described in [13].",
      "ja": "さらに、標準的なTCPの妥当性をチェックする[13]に記載されているように、任意MPTCP信号を処理する前に行わなければならない（例えば、シーケンス番号および確認応答番号を確保するよう、ウィンドウ内にあります）。"
    },
    {
      "indent": 0,
      "text": "3.1. Connection Initiation",
      "section_title": true,
      "ja": "3.1. 接続開始"
    },
    {
      "indent": 3,
      "text": "Connection initiation begins with a SYN, SYN/ACK, ACK exchange on a single path. Each packet contains the Multipath Capable (MP_CAPABLE) TCP option (Figure 4). This option declares its sender is capable of performing Multipath TCP and wishes to do so on this particular connection.",
      "ja": "接続開始は、単一のパス上のSYN、SYN / ACK、ACKの交換から始まります。各パケットは、マルチパス対応（MP_CAPABLE）TCPオプション（図4）が含まれています。このオプションは、その送信者がマルチTCPを実行することが可能であり、この特定の接続にそうすることを望んで宣言します。"
    },
    {
      "indent": 3,
      "text": "This option is used to declare the 64-bit key that the sender has generated for this MPTCP connection. This key is used to authenticate the addition of future subflows to this connection. This is the only time the key will be sent in clear on the wire (unless \"fast close\", Section 3.5, is used); all future subflows will identify the connection using a 32-bit \"token\". This token is a cryptographic hash of this key. The algorithm for this process is dependent on the authentication algorithm selected; the method of selection is defined later in this section.",
      "ja": "このオプションは、送信者がこのMPTCP接続のために生成した64ビットの鍵を宣言するために使用されます。このキーは、この接続に将来のサブフローの追加を認証するために使用されます。これは、キーはワイヤーに平文で送信される唯一の時間である（3.5節、「高速クローズ」しない限り、使用されています）。将来のすべてのサブフローは、32ビットの「トークン」を使用して接続を識別します。このトークンは、このキーの暗号化ハッシュです。この処理のアルゴリズムは、選択された認証アルゴリズムに依存しています。選択の方法は、この節の後半で定義されています。"
    },
    {
      "indent": 3,
      "text": "This key is generated by its sender, and its method of generation is implementation specific. The key MUST be hard to guess, and it MUST be unique for the sending host at any one time. Recommendations for generating random numbers for use in keys are given in [14]. Connections will be indexed at each host by the token (a one-way hash of the key). Therefore, an implementation will require a mapping from each token to the corresponding connection, and in turn to the keys for the connection.",
      "ja": "このキーは、その送信者によって生成され、その生成方法は、実装固有のものです。キーは推測するのは難しいでなければならない、そしてそれは、いずれかの時点で送信ホストに対して一意でなければなりません。キーで使用するために乱数を生成するための推奨事項は、[14]に記載されています。接続は、トークン（キーの一方向ハッシュ）によって各ホストにインデックス付けされます。したがって、実装は、対応する接続​​に、ひいては接続するためのキーに各トークンからのマッピングを必要とするであろう。"
    },
    {
      "indent": 3,
      "text": "There is a risk that two different keys will hash to the same token. The risk of hash collisions is usually small, unless the host is handling many tens of thousands of connections. Therefore, an implementation SHOULD check its list of connection tokens to ensure there is not a collision before sending its key in the SYN/ACK. This would, however, be costly for a server with thousands of connections. The subflow handshake mechanism (Section 3.2) will ensure that new subflows only join the correct connection, however, through the cryptographic handshake, as well as checking the connection tokens in both directions, and ensuring sequence numbers are in-window. So in the worst case if there was a token collision, the new subflow would not succeed, but the MPTCP connection would continue to provide a regular TCP service.",
      "ja": "二つの異なるキーが同じトークンにハッシュするリスクがあります。ホストは数千の接続の数十を処理している場合を除き、ハッシュ衝突の危険性は、通常は小さいです。そのため、実装は、SYN / ACKでそのキーを送信する前に衝突がないことを確認するために、接続トークンのリストを確認してください。これは、しかし、数千の接続とサーバーのコストがかかります。サブフローハンドシェーク機構（セクション3.2）暗号化ハンドシェイクを介して、しかし、新しいサブフローのみ正しい接続に参加することを確認し、ならびに両方向に接続トークンをチェックし、シーケンス番号を確保しますでウィンドウです。トークンの衝突があったのであれば、最悪の場合には、新しいサブフローは成功しないだろうが、MPTCP接続は、通常のTCPサービスを提供してまいります。"
    },
    {
      "indent": 3,
      "text": "The MP_CAPABLE option is carried on the SYN, SYN/ACK, and ACK packets that start the first subflow of an MPTCP connection. The data carried by each packet is as follows, where A = initiator and B = listener.",
      "ja": "MP_CAPABLEオプションはMPTCP接続の最初のサブフローを開始SYN、SYN / ACK、及びACKパケットに担持されています。各パケットによって運ばれるデータは、以下の通りであるここで、A =開始およびB =リスナー。"
    },
    {
      "indent": 3,
      "text": "o SYN (A->B): A's Key for this connection.",
      "ja": "O SYN（A-> B）：この接続のためのAのキー。"
    },
    {
      "indent": 3,
      "text": "o SYN/ACK (B->A): B's Key for this connection.",
      "ja": "O SYN / ACK（B-> A）：この接続のためのBのキー。"
    },
    {
      "indent": 3,
      "text": "o ACK (A->B): A's Key followed by B's Key.",
      "ja": "O ACK（A-> B）：AのキーBのキーが続きます。"
    },
    {
      "indent": 3,
      "text": "The contents of the option is determined by the SYN and ACK flags of the packet, verified by the option's length field. For the diagram shown in Figure 4, \"sender\" and \"receiver\" refer to the sender or receiver of the TCP packet (which can be either host). If the SYN flag is set, a single key is included; if only an ACK flag is set, both keys are present.",
      "ja": "オプションの内容は、オプションの長さフィールドによって検証パケットのSYNとACKフラグによって決定されます。図4に示されている図は、「送信者」及び「受信機」は、（いずれかのホストであってもよい）、TCPパケットの送信側または受信側を指します。 SYNフラグが設定されている場合、単一のキーが含まれています。唯一のACKフラグが設定されている場合、両方のキーが存在します。"
    },
    {
      "indent": 3,
      "text": "B's Key is echoed in the ACK in order to allow the listener (Host B) to act statelessly until the TCP connection reaches the ESTABLISHED state. If the listener acts in this way, however, it MUST generate its key in a way that would allow it to verify that it generated the key when it is echoed in the ACK.",
      "ja": "Bのキーは、TCP接続がESTABLISHED状態に到達するまで、リスナー（ホストB）はステートレスに行動することを可能にするためにACKにエコーされます。リスナーはこのように作用する場合は、しかし、それはそれはそれはACKにエコーされ、キーを生成していることを確認することができるようになる方法で、その鍵を生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This exchange allows the safe passage of MPTCP options on SYN packets to be determined. If any of these options are dropped, MPTCP will gracefully fall back to regular single-path TCP, as documented in Section 3.6. Note that new subflows MUST NOT be established (using the process documented in Section 3.2) until a Digital Signature Standard (DSS) option has been successfully received across the path (as documented in Section 3.3).",
      "ja": "この交換は、SYNパケットのMPTCPオプションの安全な通行を決定することができます。これらのオプションのいずれかがドロップされる場合は、セクション3.6に記載されているように、MPTCPは優雅に、バック通常のシングルパスTCPに分類されます。 （第3.3節に記載されるように）デジタル署名標準（DSS）オプションが正常経路を横切って受信されるまで新しいサブフローは（セクション3.2で文書化されたプロセスを使用して）確立されてはならないことに注意してください。"
    },
    {
      "indent": 6,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------+-------+---------------+\n|     Kind      |    Length     |Subtype|Version|A|B|C|D|E|F|G|H|\n+---------------+---------------+-------+-------+---------------+\n|                   Option Sender's Key (64 bits)               |\n|                                                               |\n|                                                               |\n+---------------------------------------------------------------+\n|                  Option Receiver's Key (64 bits)              |\n|                     (if option Length == 20)                  |\n|                                                               |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 4: Multipath Capable (MP_CAPABLE) Option",
      "ja": "図4：マルチできる（MP_CAPABLE）オプション"
    },
    {
      "indent": 3,
      "text": "The first 4 bits of the first octet in the MP_CAPABLE option (Figure 4) define the MPTCP option subtype (see Section 8; for MP_CAPABLE, this is 0), and the remaining 4 bits of this octet specify the MPTCP version in use (for this specification, this is 0).",
      "ja": "MP_CAPABLEオプションの最初のオクテットの最初の4ビット（図4）（セクション8を参照; MP_CAPABLEため、これは0）MPTCPオプションサブタイプを定義し、このオクテットの残りの4ビット使用中MPTCPバージョンを指定する（ためこの仕様は、これは）0です。"
    },
    {
      "indent": 3,
      "text": "The second octet is reserved for flags, allocated as follows:",
      "ja": "第2オクテットは、以下のように割り当てられ、フラグのために予約されています。"
    },
    {
      "indent": 3,
      "text": "A: The leftmost bit, labeled \"A\", SHOULD be set to 1 to indicate \"Checksum Required\", unless the system administrator has decided that checksums are not required (for example, if the environment is controlled and no middleboxes exist that might adjust the payload).",
      "ja": "：環境が制御されている場合、システム管理者は、チェックサムが必要とされていないと判断した場合を除き、左端のビットは、ラベルされた「A」は、「チェックサムが必要」を示すために1に設定されるべきである（例えば、何のミドルボックスは、それが調整可能性が存在しませんペイロード）。"
    },
    {
      "indent": 3,
      "text": "B: The second bit, labeled \"B\", is an extensibility flag, and MUST be set to 0 for current implementations. This will be used for an extensibility mechanism in a future specification, and the impact of this flag will be defined at a later date. If receiving a message with the 'B' flag set to 1, and this is not understood, then this SYN MUST be silently ignored; the sender is expected to retry with a format compatible with this legacy specification. Note that the length of the MP_CAPABLE option, and the meanings of bits \"C\" through \"H\", may be altered by setting B=1.",
      "ja": "B：第2ビット、標識された「B」は、拡張フラグであり、現在の実装のために0に設定しなければなりません。これは、将来の仕様に拡張メカニズムのために使用され、このフラグの影響は後日定義します。 1に設定「B」フラグを有するメッセージを受信し、これは理解されていない場合、このSYNは無視されなければなりません。送信者は、このレガシー規格と互換性のある形式に再試行することが期待されます。 MP_CAPABLEオプションの長さ、及び「H」からビット「C」の意味は、B = 1を設定することによって変更されてもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "C through H: The remaining bits, labeled \"C\" through \"H\", are used for crypto algorithm negotiation. Currently only the rightmost bit, labeled \"H\", is assigned. Bit \"H\" indicates the use of HMAC-SHA1 (as defined in Section 3.2). An implementation that only supports this method MUST set bit \"H\" to 1, and bits \"C\" through \"G\" to 0.",
      "ja": "Hを介してC：「H」から「C」とラベル付けされた残りのビットは、暗号アルゴリズムのネゴシエーションに使用されます。現在、「H」ラベルのみ右端のビットは、割り当てられています。ビット「H」は、HMAC-SHA1（セクション3.2で定義されるような）の使用を示しています。 1つだけにビット「H」に設定しなければならない。この方法をサポートし実現し、ビット0に「G」から「C」。"
    },
    {
      "indent": 3,
      "text": "A crypto algorithm MUST be specified. If flag bits C through H are all 0, the MP_CAPABLE option MUST be treated as invalid and ignored (that is, it must be treated as a regular TCP handshake).",
      "ja": "暗号化アルゴリズムを指定する必要があります。フラグビットC Hを介して、すべて0である場合、MP_CAPABLEオプションは無効として扱われ、無視されなければならない（すなわち、それは、通常のTCPハンドシェークとして扱われなければなりません）。"
    },
    {
      "indent": 3,
      "text": "The selection of the authentication algorithm also impacts the algorithm used to generate the token and the initial data sequence number (IDSN). In this specification, with only the SHA-1 algorithm (bit \"H\") specified and selected, the token MUST be a truncated (most significant 32 bits) SHA-1 hash ([4], [15]) of the key. A different, 64-bit truncation (the least significant 64 bits) of the SHA-1 hash of the key MUST be used as the initial data sequence number. Note that the key MUST be hashed in network byte order. Also note that the \"least significant\" bits MUST be the rightmost bits of the SHA-1 digest, as per [4]. Future specifications of the use of the crypto bits may choose to specify different algorithms for token and IDSN generation.",
      "ja": "認証アルゴリズムの選択も影響トークンと初期データシーケンス番号（IDSN）を生成するために使用されるアルゴリズム。本明細書では、唯一のSHA-1アルゴリズムを指定し、選択（ビット「H」）と、トークンが鍵のSHA-1ハッシュ（[4]、[15]）トランケート（上位32ビット）でなければなりません。鍵のSHA-1ハッシュの異なる64ビットの切り捨て（最下位64ビット）が初期データシーケンス番号として使用されなければなりません。鍵はネットワークバイト順でハッシュ化されなければならないことに注意してください。また、「最下位」ビット[4]に従って、SHA-1ダイジェストの右端のビットである必要があります。暗号ビットの使用の将来の仕様は、トークンとIDSN生成のための異なるアルゴリズムを指定することを選択することができます。"
    },
    {
      "indent": 3,
      "text": "Both the crypto and checksum bits negotiate capabilities in similar ways. For the Checksum Required bit (labeled \"A\"), if either host requires the use of checksums, checksums MUST be used. In other words, the only way for checksums not to be used is if both hosts in their SYNs set A=0. This decision is confirmed by the setting of the \"A\" bit in the third packet (the ACK) of the handshake. For example, if the initiator sets A=0 in the SYN, but the responder sets A=1 in the SYN/ACK, checksums MUST be used in both directions, and the initiator will set A=1 in the ACK. The decision whether to use checksums will be stored by an implementation in a per-connection binary state variable.",
      "ja": "両方の暗号化とチェックサムビットは、同様の方法で機能を交渉します。いずれかのホストは、チェックサムを使用する必要がある場合（「A」と表示）チェックサムが必要ビットの場合は、チェックサムを使用しなければなりません。それらのSYNの両方のホストがA = 0を設定した場合、換言すれば、使用しないチェックサムのための唯一の方法です。この決定は、ハンドシェイクの3番目のパケット（ACK）の「A」ビットの設定によって確認されました。例えば、開始剤は、SYNでA = 0を設定した場合が、SYN / ACKで応答セットA = 1、チェックサムは双方向で使用する必要があり、かつイニシエータがACKでA = 1を設定します。チェックサムを使用するかどうかの決定は、接続ごとのバイナリ状態変数に実装することによって格納されます。"
    },
    {
      "indent": 3,
      "text": "For crypto negotiation, the responder has the choice. The initiator creates a proposal setting a bit for each algorithm it supports to 1 (in this version of the specification, there is only one proposal, so bit \"H\" will be always set to 1). The responder responds with only 1 bit set -- this is the chosen algorithm. The rationale for this behavior is that the responder will typically be a server with potentially many thousands of connections, so it may wish to choose an algorithm with minimal computational complexity, depending on the load. If a responder does not support (or does not want to support) any of the initiator's proposals, it can respond without an MP_CAPABLE option, thus forcing a fallback to regular TCP.",
      "ja": "暗号交渉のために、応答者は選択肢があります。イニシエータは1に、それがサポートする各アルゴリズムのビットを設定する提案（仕様のこのバージョンでは、唯一の提案があるので、「H」は常に1に設定されるビット）を生成します。応答者はわずか1ビットのセットで応答 - これが選択されたアルゴリズムです。この動作のための理論的根拠は、応答者は、一般的な接続の潜在的に何千とサーバーになるということですので、負荷に応じて、最小限の計算の複雑さとアルゴリズムを選択することもできます。レスポンダは、イニシエータの提案のいずれかをサポートしていません（またはサポートしたくない）場合、それはこのように、通常のTCPへのフォールバックを強制的に、MP_CAPABLEオプションを指定せずに応答することができます。"
    },
    {
      "indent": 3,
      "text": "The MP_CAPABLE option is only used in the first subflow of a connection, in order to identify the connection; all following subflows will use the \"Join\" option (see Section 3.2) to join the existing connection.",
      "ja": "MP_CAPABLEオプションは、接続を識別するために、接続の最初のサブフローで使用されています。以下のすべてのサブフローは、既存の接続に参加する「参加」オプション（3.2節を参照）を使用します。"
    },
    {
      "indent": 3,
      "text": "If a SYN contains an MP_CAPABLE option but the SYN/ACK does not, it is assumed that the passive opener is not multipath capable; thus, the MPTCP session MUST operate as a regular, single-path TCP. If a SYN does not contain a MP_CAPABLE option, the SYN/ACK MUST NOT contain one in response. If the third packet (the ACK) does not contain the MP_CAPABLE option, then the session MUST fall back to operating as a regular, single-path TCP. This is to maintain compatibility with middleboxes on the path that drop some or all TCP options. Note that an implementation MAY choose to attempt sending MPTCP options more than one time before making this decision to operate as regular TCP (see Section 3.8).",
      "ja": "SYNがMP_CAPABLEオプションが含まれていますが、SYN / ACKがない場合は、パッシブオープナーができるマルチパスされていないものとします。このように、MPTCPセッションは、通常、シングルパスTCPとして動作する必要があります。 SYNがMP_CAPABLEオプションが含まれていない場合は、SYN / ACKは応答して1つを含めることはできません。 3番目のパケット（ACK）がMP_CAPABLEオプションが含まれていない場合、セッションは、通常、シングルパスTCPとして動作にフォールバックしなければなりません。これは、一部またはすべてのTCPオプションをドロップパス上のミドルボックスとの互換性を維持することです。実装は、通常のTCP（3.8節を参照）として動作するように、この決定を下す前にMPTCPオプションに複数回の送信を試みることを選択するかもしれないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the SYN packets are unacknowledged, it is up to local policy to decide how to respond. It is expected that a sender will eventually fall back to single-path TCP (i.e., without the MP_CAPABLE option) in order to work around middleboxes that may drop packets with unknown options; however, the number of multipath-capable attempts that are made first will be up to local policy. It is possible that MPTCP and non-MPTCP SYNs could get reordered in the network. Therefore, the final state is inferred from the presence or absence of the MP_CAPABLE option in the third packet of the TCP handshake. If this option is not present, the connection SHOULD fall back to regular TCP, as documented in Section 3.6.",
      "ja": "SYNパケットが未確認であれば、それが応答する方法を決定するために、ローカルポリシー次第です。送信者が最終的には、未知のオプションを持つパケットをドロップすることがミドルボックスを回避するために、バックシングルパスTCP（すなわち、MP_CAPABLEオプションなし）に入ると予想されます。しかし、最初にローカルポリシーになり行われるマルチパス対応試行回数。 MPTCPと非MPTCPのSYNは、ネットワーク内の並べ替えを取得する可能性があります。したがって、最終的な状態は、TCPハンドシェークの第3のパケットでMP_CAPABLEオプションの存在または非存在から推測されます。このオプションが存在しない場合は、セクション3.6に記載されているように、接続は、戻って通常のTCPに落ちるべきです。"
    },
    {
      "indent": 3,
      "text": "The initial data sequence number on an MPTCP connection is generated from the key. The algorithm for IDSN generation is also determined from the negotiated authentication algorithm. In this specification, with only the SHA-1 algorithm specified and selected, the IDSN of a host MUST be the least significant 64 bits of the SHA-1 hash of its key, i.e., IDSN-A = Hash(Key-A) and IDSN-B = Hash(Key-B). This deterministic generation of the IDSN allows a receiver to ensure that there are no gaps in sequence space at the start of the connection. The SYN with MP_CAPABLE occupies the first octet of data sequence space, although this does not need to be acknowledged at the connection level until the first data is sent (see Section 3.3).",
      "ja": "MPTCP接続の初期データ・シーケンス番号は、キーから生成されます。 IDSN生成のためのアルゴリズムは、ネゴシエートされた認証アルゴリズムから決定されます。本明細書では、指定された、選択された唯一のSHA-1アルゴリズムを使用して、ホストのIDSNは、そのキー、すなわち、IDSN-A =ハッシュ（キーA）のSHA-1ハッシュの最下位64ビットでなければなりませんとIDSN-B =ハッシュ（キーB）。 IDSNのこの決定論的生成は、受信機は、配列空間にはギャップが接続の開始時に存在しないことを保証することを可能にします。最初のデータが送信されるまで、これは（セクション3.3を参照）接続レベルで肯定応答する必要はないがMP_CAPABLEとのSYNは、データ・シーケンス・スペースの最初のオクテットを占有します。"
    },
    {
      "indent": 0,
      "text": "3.2. Starting a New Subflow",
      "section_title": true,
      "ja": "3.2. 新しいサブフローを起動します"
    },
    {
      "indent": 3,
      "text": "Once an MPTCP connection has begun with the MP_CAPABLE exchange, further subflows can be added to the connection. Hosts have knowledge of their own address(es), and can become aware of the other host's addresses through signaling exchanges as described in Section 3.4. Using this knowledge, a host can initiate a new subflow over a currently unused pair of addresses. It is permitted for either host in a connection to initiate the creation of a new subflow, but it is expected that this will normally be the original connection initiator (see Section 3.8 for heuristics).",
      "ja": "MPTCP接続がMP_CAPABLE交換して始まった後は、さらにサブフローは、接続に追加することができます。ホストは、自分のアドレス（複数可）の知識を持ち、3.4節で説明したように、シグナリング交流を通じて他のホストのアドレスを知ることができます。この知識を使用して、ホストがアドレスの現在未使用のペアの上に新しいサブフローを開始することができます。 （ヒューリスティックについては、セクション3.8を参照）新規サブフローの作成を開始するために、接続のいずれかでホストに許可されていますが、これは通常、元の接続の開始剤であることが期待されます。"
    },
    {
      "indent": 3,
      "text": "A new subflow is started as a normal TCP SYN/ACK exchange. The Join Connection (MP_JOIN) TCP option is used to identify the connection to be joined by the new subflow. It uses keying material that was exchanged in the initial MP_CAPABLE handshake (Section 3.1), and that handshake also negotiates the crypto algorithm in use for the MP_JOIN handshake.",
      "ja": "新しいサブフローは、通常のTCP SYN / ACK交換として開始されます。参加コネクション（MP_JOIN）TCPオプションは、新しいサブフローで参加する接続を識別するために使用されます。これは、初期MP_CAPABLEハンドシェイク（3.1節）に交換した鍵材料を使用し、その握手もMP_JOINハンドシェイクのために使用されている暗号アルゴリズムを交渉します。"
    },
    {
      "indent": 3,
      "text": "This section specifies the behavior of MP_JOIN using the HMAC-SHA1 algorithm. An MP_JOIN option is present in the SYN, SYN/ACK, and ACK of the three-way handshake, although in each case with a different format.",
      "ja": "このセクションでは、HMAC-SHA1アルゴリズムを使用してMP_JOINの動作を指定します。 MP_JOINオプションは、異なる形式のそれぞれの場合においても、スリーウェイハンドシェイクのSYN、SYN / ACK、及びACK中に存在します。"
    },
    {
      "indent": 3,
      "text": "In the first MP_JOIN on the SYN packet, illustrated in Figure 5, the initiator sends a token, random number, and address ID.",
      "ja": "図5に示されているSYNパケットの最初MP_JOINにおいて、イニシエータは、トークン、乱数、およびアドレスIDを送信します。"
    },
    {
      "indent": 3,
      "text": "The token is used to identify the MPTCP connection and is a cryptographic hash of the receiver's key, as exchanged in the initial MP_CAPABLE handshake (Section 3.1). In this specification, the tokens presented in this option are generated by the SHA-1 ([4], [15]) algorithm, truncated to the most significant 32 bits. The token included in the MP_JOIN option is the token that the receiver of the packet uses to identify this connection; i.e., Host A will send Token-B (which is generated from Key-B). Note that the hash generation algorithm can be overridden by the choice of cryptographic handshake algorithm, as defined in Section 3.1.",
      "ja": "トークンはMPTCP接続を識別するために使用され、初期MP_CAPABLEハンドシェーク（セクション3.1）に交換したように、受信者の鍵の暗号ハッシュです。本明細書では、このオプションに提示トークンは（[4]、[15]）アルゴリズムは、最上位の32ビットに切り捨てSHA-1によって生成されます。 MP_JOINオプションに含まれるトークンは、パケットの受信機は、この接続を識別するために使用するトークンです。すなわち、ホストAは、（キーBから生成される）トークンBを送信します。 3.1節で定義されているハッシュ生成アルゴリズムは、暗号ハンドシェイクアルゴリズムの選択によって上書きされることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The MP_JOIN SYN sends not only the token (which is static for a connection) but also random numbers (nonces) that are used to prevent replay attacks on the authentication method. Recommendations for the generation of random numbers for this purpose are given in [14].",
      "ja": "MP_JOIN SYN認証方式にリプレイ攻撃を防止するために使用されるトークン（接続のために静的である）も乱数（ノンス）だけでなく、送信します。この目的のために乱数を生成するための推奨事項は、[14]に記載されています。"
    },
    {
      "indent": 3,
      "text": "The MP_JOIN option includes an \"Address ID\". This is an identifier that only has significance within a single connection, where it identifies the source address of this packet, even if the IP header has been changed in transit by a middlebox. The Address ID allows address removal (Section 3.4.2) without needing to know what the source address at the receiver is, thus allowing address removal through NATs. The Address ID also allows correlation between new subflow setup attempts and address signaling (Section 3.4.1), to prevent setting up duplicate subflows on the same path, if an MP_JOIN and ADD_ADDR are sent at the same time.",
      "ja": "MP_JOINオプションは、「アドレスID」が含まれます。これは、それがIPヘッダはミドルによって輸送中に変更された場合でも、このパケットの送信元アドレスを識別する単一接続内で意味を有する識別子です。アドレスIDは、このようにNATを経由アドレス除去を可能に、受信機での送信元アドレスが何であるかを知らなくても、アドレスの削除（3.4.2項）を可能にします。 MP_JOINとADD_ADDRが同時に送信される場合、アドレスIDはまた、同じパス上の重複サブフローを設定防ぐために、新しいサブフローセットアップの試みとアドレス信号（セクション3.4.1）との間の相関を可能にします。"
    },
    {
      "indent": 3,
      "text": "The Address IDs of the subflow used in the initial SYN exchange of the first subflow in the connection are implicit, and have the value zero. A host MUST store the mappings between Address IDs and addresses both for itself and the remote host. An implementation will also need to know which local and remote Address IDs are associated with which established subflows, for when addresses are removed from a local or remote host.",
      "ja": "接続の最初のサブフローの初期SYN交換に使用されるサブフローのアドレスIDが暗黙的であり、値ゼロを有します。ホストは自分自身とリモートホストの両方のアドレスIDとアドレスの間のマッピングを保存しなければなりません。実装は、ローカルとリモートのアドレスIDがどのアドレスがローカルまたはリモートホストから削除されたときのために、サブフローを確立に関連付けられている知っている必要があります。"
    },
    {
      "indent": 3,
      "text": "The MP_JOIN option on packets with the SYN flag set also includes 4 bits of flags, 3 of which are currently reserved and MUST be set to zero by the sender. The final bit, labeled \"B\", indicates whether the sender of this option wishes this subflow to be used as a backup path (B=1) in the event of failure of other paths, or whether it wants it to be used as part of the connection immediately. By setting B=1, the sender of the option is requesting the other host to only send data on this subflow if there are no available subflows where B=0. Subflow policy is discussed in more detail in Section 3.3.8.",
      "ja": "SYNフラグが設定されたパケットにMP_JOINオプションは、現在予約されており、送信者によってゼロに設定しなければならない3れたフラグの4ビットを含みます。 「B」と表示された最後のビットは、このオプションの送信者が他のパスに障害が発生した場合に予備パス（B = 1）として使用されるこのサブフローを望むかどうか、またはそれが一部として使用することを望むかどうかを示しますすぐに接続。 B = 1を設定することにより、オプションの送信者は、使用可能なサブフローB = 0が存在しない場合は、このサブフローにデータを送るだけに他のホストを要求しています。サブフローポリシーは、第3.3.8項で詳しく説明されています。"
    },
    {
      "indent": 6,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------+-----+-+---------------+\n|     Kind      |  Length = 12  |Subtype|     |B|   Address ID  |\n+---------------+---------------+-------+-----+-+---------------+\n|                   Receiver's Token (32 bits)                  |\n+---------------------------------------------------------------+\n|                Sender's Random Number (32 bits)               |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 5: Join Connection (MP_JOIN) Option (for Initial SYN)",
      "ja": "図5：（初期SYN用）接続（MP_JOIN）オプションに参加"
    },
    {
      "indent": 3,
      "text": "When receiving a SYN with an MP_JOIN option that contains a valid token for an existing MPTCP connection, the recipient SHOULD respond with a SYN/ACK also containing an MP_JOIN option containing a random number and a truncated (leftmost 64 bits) Hash-based Message Authentication Code (HMAC). This version of the option is shown in Figure 6. If the token is unknown, or the host wants to refuse subflow establishment (for example, due to a limit on the number of subflows it will permit), the receiver will send back a reset (RST) signal, analogous to an unknown port in TCP. Although calculating an HMAC requires cryptographic operations, it is believed that the 32- bit token in the MP_JOIN SYN gives sufficient protection against blind state exhaustion attacks; therefore, there is no need to provide mechanisms to allow a responder to operate statelessly at the MP_JOIN stage.",
      "ja": "既存のMPTCP接続用の有効なトークンが含まMP_JOINオプションでSYNを受信した場合、受信者はまた、乱数及び（64ビット左端）切断型ハッシュベースのメッセージ認証を含むMP_JOINオプションを含むSYN / ACKで応答する必要がありコード（HMAC）。オプションのこのバージョンは、トークンが不明である、またはホストが（原因、それは許容するサブフローの数の制限に、例えば）サブフロー確立を拒否したい場合、受信機はリセットを返送します。図6に示します。 TCPにおける未知のポートに類似する（RST）信号、。 HMACを計算すると、暗号化操作を必要としますが、MP_JOIN SYNで32ビットトークンが盲目状態枯渇攻撃に対する十分な保護を与えると考えられています。したがって、レスポンダはMP_JOIN段階でステートレス動作できるようにするメカニズムを提供する必要はありません。"
    },
    {
      "indent": 3,
      "text": "An HMAC is sent by both hosts -- by the initiator (Host A) in the third packet (the ACK) and by the responder (Host B) in the second packet (the SYN/ACK). Doing the HMAC exchange at this stage allows both hosts to have first exchanged random data (in the first two SYN packets) that is used as the \"message\". This specification defines that HMAC as defined in [10] is used, along with the SHA-1 hash algorithm [4] (potentially implemented as in [15]), thus generating a 160-bit / 20-octet HMAC. Due to option space limitations, the HMAC included in the SYN/ACK is truncated to the leftmost 64 bits, but this is acceptable since random numbers are used; thus, an attacker only has one chance to guess the HMAC correctly (if the HMAC is incorrect, the TCP connection is closed, so a new MP_JOIN negotiation with a new random number is required).",
      "ja": "HMACは、両方のホストによって送信される - イニシエータ（ホストA）第3のパケット（ACK）及び第2パケット（SYN / ACK）で応答（ホストB）によって。この段階でHMAC交換を行うと、両方のホストは、最初の「メッセージ」として使用される（最初の二つのSYNパケットで）ランダムなデータを交換していることを可能にします。この仕様は、[10] HMACは、で定義されるようにすることを定義するSHA-1ハッシュアルゴリズム[4]（潜在的に[15]のように実装されている）、このように160ビット/ 20オクテットHMACを生成するとともに、使用されています。オプション空間の制限のため、HMACは、SYN / ACKに含まれる左端の64ビットに切り捨てられるが、乱数を用いているため、これは許容可能です。したがって、攻撃者は（HMACが正しくない場合、TCP接続が閉じられているので、新しい乱数を使用して新しいMP_JOIN交渉が必要です）正しくHMACを推測する一つのチャンスを持っています。"
    },
    {
      "indent": 3,
      "text": "The initiator's authentication information is sent in its first ACK (the third packet of the handshake), as shown in Figure 7. This data needs to be sent reliably, since it is the only time this HMAC is sent; therefore, receipt of this packet MUST trigger a regular TCP ACK in response, and the packet MUST be retransmitted if this ACK is not received. In other words, sending the ACK/MP_JOIN packet places the subflow in the PRE_ESTABLISHED state, and it moves to the",
      "ja": "それは、このHMACが送信される唯一の時間であるので、このデータは、確実に送信する必要が図7に示すように、イニシエータの認証情報は、その最初のACK（ハンドシェークの3番目のパケット）で送信されます。そのため、このパケットの受信は対応して定期的にTCP ACKを起動する必要があり、このACKが受信されない場合、パケットが再送されなければなりません。言い換えれば、ACK / MP_JOINパケットを送信するPRE_ESTABLISHED状態でサブフローを置き、それがへ移動します"
    },
    {
      "indent": 3,
      "text": "ESTABLISHED state only on receipt of an ACK from the receiver. It is not permitted to send data while in the PRE_ESTABLISHED state. The reserved bits in this option MUST be set to zero by the sender.",
      "ja": "唯一の受信機からのACKの受信時に状態を確立しました。 PRE_ESTABLISHED状態にしながら、データを送信することが許可されていません。このオプションで予約ビットは送信者によってゼロに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The key for the HMAC algorithm, in the case of the message transmitted by Host A, will be Key-A followed by Key-B, and in the case of Host B, Key-B followed by Key-A. These are the keys that were exchanged in the original MP_CAPABLE handshake. The \"message\" for the HMAC algorithm in each case is the concatenations of random number for each host (denoted by R): for Host A, R-A followed by R-B; and for Host B, R-B followed by R-A.",
      "ja": "HMACアルゴリズムの鍵は、ホストAによって送信されたメッセージの場合には、キーキーBが続く、およびホストBの場合には、キーBは、キーAが続きます。これらは、元MP_CAPABLEハンドシェイクで交換されたキーです。各場合においてHMACアルゴリズムの「メッセージ」（Rで示される）各ホストのための乱数の連結である：ホストAのために、R-R-Bに続きます。およびホストBのために、R-Bは、R-Aが続きます。"
    },
    {
      "indent": 6,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------+-----+-+---------------+\n|     Kind      |  Length = 16  |Subtype|     |B|   Address ID  |\n+---------------+---------------+-------+-----+-+---------------+\n|                                                               |\n|                Sender's Truncated HMAC (64 bits)              |\n|                                                               |\n+---------------------------------------------------------------+\n|                Sender's Random Number (32 bits)               |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 6: Join Connection (MP_JOIN) Option (for Responding SYN/ACK)",
      "ja": "図6：（SYN / ACKを応答するための）接続（MP_JOIN）オプションに参加"
    },
    {
      "indent": 6,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------+-----------------------+\n|     Kind      |  Length = 24  |Subtype|      (reserved)       |\n+---------------+---------------+-------+-----------------------+\n|                                                               |\n|                                                               |\n|                   Sender's HMAC (160 bits)                    |\n|                                                               |\n|                                                               |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 7: Join Connection (MP_JOIN) Option (for Third ACK)",
      "ja": "図7：（第3 ACK用）接続（MP_JOIN）オプションに参加"
    },
    {
      "indent": 3,
      "text": "These various TCP options fit together to enable authenticated subflow setup as illustrated in Figure 8.",
      "ja": "これらの様々なTCPオプションは、図8に示すように、認証されたサブフローの設定を有効にするために一緒に収まります。"
    },
    {
      "indent": 5,
      "text": "         Host A                                  Host B\n------------------------                       ----------\nAddress A1    Address A2                       Address B1\n----------    ----------                       ----------\n    |             |                                |\n    |            SYN + MP_CAPABLE(Key-A)           |\n    |--------------------------------------------->|\n    |<---------------------------------------------|\n    |          SYN/ACK + MP_CAPABLE(Key-B)         |\n    |             |                                |\n    |        ACK + MP_CAPABLE(Key-A, Key-B)        |\n    |--------------------------------------------->|\n    |             |                                |\n    |             |   SYN + MP_JOIN(Token-B, R-A)  |\n    |             |------------------------------->|\n    |             |<-------------------------------|\n    |             | SYN/ACK + MP_JOIN(HMAC-B, R-B) |\n    |             |                                |\n    |             |     ACK + MP_JOIN(HMAC-A)      |\n    |             |------------------------------->|\n    |             |<-------------------------------|\n    |             |             ACK                |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "HMAC-A = HMAC(Key=(Key-A+Key-B), Msg=(R-A+R-B)) HMAC-B = HMAC(Key=(Key-B+Key-A), Msg=(R-B+R-A))",
      "ja": "HMAC-A = HMAC（（キーA +キーB）=キーメッセージ=（R-A + RB））HMAC-B = HMAC（キー=（キーB +キーA）、メッセージ=（R -B + RA））"
    },
    {
      "indent": 15,
      "text": "Figure 8: Example Use of MPTCP Authentication",
      "ja": "図8：MPTCP認証の使用例"
    },
    {
      "indent": 3,
      "text": "If the token received at Host B is unknown or local policy prohibits the acceptance of the new subflow, the recipient MUST respond with a TCP RST for the subflow.",
      "ja": "ホストBで受信したトークンが不明またはローカルポリシーが新しいサブフローの受諾を禁止されている場合は、受信者は、サブフローのためのTCP RSTで応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the token is accepted at Host B, but the HMAC returned to Host A does not match the one expected, Host A MUST close the subflow with a TCP RST.",
      "ja": "トークンは、ホストBで受け入れますが、HMACは、Aが期待されるものと一致しないホストに返された場合、ホストAは、TCPのRSTとサブフローを閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "If Host B does not receive the expected HMAC, or the MP_JOIN option is missing from the ACK, it MUST close the subflow with a TCP RST.",
      "ja": "ホストBが期待されるHMACを受信しない、またはMP_JOINオプションは、ACKから欠落している場合、それはTCP RSTでサブフローを閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "If the HMACs are verified as correct, then both hosts have authenticated each other as being the same peers as existed at the start of the connection, and they have agreed of which connection this subflow will become a part.",
      "ja": "HMACsが正しいと確認された場合は、両方のホストは、接続の開始時に存在していたのと同じ仲間として互いを認証している、と彼らはこのサブフローが一部になるだろうどの接続で合意しました。"
    },
    {
      "indent": 3,
      "text": "If the SYN/ACK as received at Host A does not have an MP_JOIN option, Host A MUST close the subflow with a RST.",
      "ja": "ホストAで受信したSYN / ACKがMP_JOINオプションを持っていない場合、ホストAは、RSTとサブフローを閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "This covers all cases of the loss of an MP_JOIN. In more detail, if MP_JOIN is stripped from the SYN on the path from A to B, and Host B does not have a passive opener on the relevant port, it will respond with a RST in the normal way. If in response to a SYN with an MP_JOIN option, a SYN/ACK is received without the MP_JOIN option (either since it was stripped on the return path, or it was stripped on the outgoing path but the passive opener on Host B responded as if it were a new regular TCP session), then the subflow is unusable and Host A MUST close it with a RST.",
      "ja": "これはMP_JOINの損失のすべてのケースをカバーしています。 MP_JOINは、AからBへのパス上のSYNから剥ぎ取られ、ホストBが関連ポートに受動的なオープナーを持っていない場合は、より具体的には、それは通常の方法でRSTで応答します。 MP_JOINオプションを指定してSYNに応答して、SYN / ACKはMP_JOINオプションなしで受信された場合（これは、復路に剥離し、又はそれが往路でストリッピングが、ホストB上の受動オープナーがあるかのように応答したいずれかのためそれは新しい正規TCPセッション）だった場合、サブフローは使用不可能となり、ホストAはRSTでそれを閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that additional subflows can be created between any pair of ports (but see Section 3.8 for heuristics); no explicit application-level accept calls or bind calls are required to open additional subflows. To associate a new subflow with an existing connection, the token supplied in the subflow's SYN exchange is used for demultiplexing. This then binds the 5-tuple of the TCP subflow to the local token of the connection. A consequence is that it is possible to allow any port pairs to be used for a connection.",
      "ja": "追加のサブフローは、ポートの任意の対の間に作成することができることに留意されたい（ただし、ヒューリスティックについてはセクション3.8を参照）。明示的なアプリケーションレベルのない呼び出しやバインド・コールを受け入れる追加のサブフローを開くために必要とされます。既存の接続を使用して新しいサブフローを関連付けるには、サブフローのSYN交換で供給されたトークンを分離するために使用されています。これは、接続のローカルトークンへのTCPサブフローの5タプルをバインドします。その結果は、任意のポートのペアが接続に使用できるようにすることが可能であるということです。"
    },
    {
      "indent": 3,
      "text": "Demultiplexing subflow SYNs MUST be done using the token; this is unlike traditional TCP, where the destination port is used for demultiplexing SYN packets. Once a subflow is set up, demultiplexing packets is done using the 5-tuple, as in traditional TCP. The 5-tuples will be mapped to the local connection identifier (token). Note that Host A will know its local token for the subflow even though it is not sent on the wire -- only the responder's token is sent.",
      "ja": "サブフローのSYNを逆多重化することは、トークンを使用して行う必要があります。これは、宛先ポートがSYNパケットを多重分離するために使用されている伝統的なTCPとは異なります。サブフローが設定されると、逆多重化パケットは、従来のTCPのように、5つのタプルを使用して行われます。 5タプルは、ローカル接続識別子（トークン）にマッピングされます。唯一の応答者のトークンが送信されます -  Aは、それが有線で送信されていない場合でも、サブフローのためにそのローカルトークンを知っていることをホストに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.3. General MPTCP Operation",
      "section_title": true,
      "ja": "3.3. 一般MPTCP操作"
    },
    {
      "indent": 3,
      "text": "This section discusses operation of MPTCP for data transfer. At a high level, an MPTCP implementation will take one input data stream from an application, and split it into one or more subflows, with sufficient control information to allow it to be reassembled and delivered reliably and in order to the recipient application. The following subsections define this behavior in detail.",
      "ja": "このセクションでは、データ転送にMPTCPの動作について説明します。それは再構成し、確実かつレシピエントアプリケーションに順番に配信されることを可能にするのに十分な制御情報と、ハイレベルで、MPTCP実装は、アプリケーションからの1つの入力データストリームを取る、および1つ以上のサブフローに分割しました。以下のサブセクションでは、詳細にこの動作を定義します。"
    },
    {
      "indent": 3,
      "text": "The data sequence mapping and the Data ACK are signaled in the Data Sequence Signal (DSS) option (Figure 9). Either or both can be signaled in one DSS, dependent on the flags set. The data sequence mapping defines how the sequence space on the subflow maps to the connection level, and the Data ACK acknowledges receipt of data at the connection level. These functions are described in more detail in the following two subsections.",
      "ja": "データシーケンスマッピング及びデータACKは、データシーケンス信号（DSS）オプション（図9）にシグナリングされます。いずれかまたは両方が設定されたフラグに応じて、1 DSSにシグナリングすることができます。データ系列のマッピングは、接続レベルにサブフローマップ上のどのシーケンス空間を定義し、データACKは、接続レベルでデータの受信を確認します。これらの機能は、次の2つのサブセクションでより詳細に記載されています。"
    },
    {
      "indent": 3,
      "text": "Either or both the data sequence mapping and the Data ACK can be signaled in the DSS option, dependent on the flags set.",
      "ja": "いずれかまたはデータ系列のマッピングとデータACKの両方が設定されたフラグに依存して、DSSオプションでシグナリングすることができます。"
    },
    {
      "indent": 5,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------+----------------------+\n|     Kind      |    Length     |Subtype| (reserved) |F|m|M|a|A|\n+---------------+---------------+-------+----------------------+\n|           Data ACK (4 or 8 octets, depending on flags)       |\n+--------------------------------------------------------------+\n|   Data sequence number (4 or 8 octets, depending on flags)   |\n+--------------------------------------------------------------+\n|              Subflow Sequence Number (4 octets)              |\n+-------------------------------+------------------------------+\n|  Data-Level Length (2 octets) |      Checksum (2 octets)     |\n+-------------------------------+------------------------------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 9: Data Sequence Signal (DSS) Option",
      "ja": "図9：データシーケンス信号（DSS）オプション"
    },
    {
      "indent": 3,
      "text": "The flags, when set, define the contents of this option, as follows:",
      "ja": "次のようにフラグは、設定されたときに、このオプションの内容を定義します。"
    },
    {
      "indent": 3,
      "text": "o A = Data ACK present",
      "ja": "O A =データACK存在"
    },
    {
      "indent": 3,
      "text": "o a = Data ACK is 8 octets (if not set, Data ACK is 4 octets)",
      "ja": "0 =データACKは8つのオクテットである（設定されていない場合、データACKは4つのオクテットです）"
    },
    {
      "indent": 3,
      "text": "o M = Data Sequence Number (DSN), Subflow Sequence Number (SSN), Data-Level Length, and Checksum present",
      "ja": "O M =データシーケンス番号（DSN）、サブフローシーケンス番号（SSN）、データレベルの長さ、及びチェックサム本"
    },
    {
      "indent": 3,
      "text": "o m = Data sequence number is 8 octets (if not set, DSN is 4 octets)",
      "ja": "O M =データシーケンス番号は8つのオクテット（設定されていない場合、DSNは4つのオクテットである）であります"
    },
    {
      "indent": 3,
      "text": "The flags 'a' and 'm' only have meaning if the corresponding 'A' or 'M' flags are set; otherwise, they will be ignored. The maximum length of this option, with all flags set, is 28 octets.",
      "ja": "対応する「A」または「M」フラグが設定されている場合、フラグ「」と「m」は唯一の意味を有します。そうでない場合、それらは無視されます。このオプションの最大の長さは、設定されたすべてのフラグと、28オクテットです。"
    },
    {
      "indent": 3,
      "text": "The 'F' flag indicates \"DATA_FIN\". If present, this means that this mapping covers the final data from the sender. This is the connection-level equivalent to the FIN flag in single-path TCP. A connection is not closed unless there has been a DATA_FIN exchange or a timeout. The purpose of the DATA_FIN and the interactions between this flag, the subflow-level FIN flag, and the data sequence mapping are described in Section 3.3.3. The remaining reserved bits MUST be set to zero by an implementation of this specification.",
      "ja": "「F」フラグは「DATA_FIN」を示しています。存在する場合、これは、このマッピングは、送信者からの最終データをカバーすることを意味します。これは、単一パスTCPにFINフラグに相当する接続レベルです。 DATA_FIN交換又はタイムアウトがあった場合を除き、接続は閉じられません。 DATA_FINこのフラグとの間の相互作用の目的、サブフローレベルFINフラグ、及びデータ列マッピングは、セクション3.3.3に記載されています。残りの予約ビットは、この仕様の実装によってゼロに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the checksum is only present in this option if the use of MPTCP checksumming has been negotiated at the MP_CAPABLE handshake (see Section 3.1). The presence of the checksum can be inferred from the length of the option. If a checksum is present, but its use had not been negotiated in the MP_CAPABLE handshake, the checksum field MUST be ignored. If a checksum is not present when its use has been negotiated, the receiver MUST close the subflow with a RST as it is considered broken.",
      "ja": "チェックサムがMPTCPチェックサムの使用はMP_CAPABLE握手で交渉​​されている場合は、このオプションでは唯一の存在であることに注意してください（3.1節を参照してください）。チェックサムの存在は、オプションの長さから推測することができます。チェックサムが存在するが、その使用はMP_CAPABLEハンドシェイクで交渉されていなかった場合は、チェックサムフィールドは無視しなければなりません。その使用が交渉されたときにチェックサムが存在しない場合、それが壊れたと考えられているように、受信機は、RSTとサブフローを閉じる必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Data Sequence Mapping",
      "section_title": true,
      "ja": "3.3.1. データ系列のマッピング"
    },
    {
      "indent": 3,
      "text": "The data stream as a whole can be reassembled through the use of the data sequence mapping components of the DSS option (Figure 9), which define the mapping from the subflow sequence number to the data sequence number. This is used by the receiver to ensure in-order delivery to the application layer. Meanwhile, the subflow-level sequence numbers (i.e., the regular sequence numbers in the TCP header) have subflow-only relevance. It is expected (but not mandated) that SACK [11] is used at the subflow level to improve efficiency.",
      "ja": "全体として、データストリームは、データのシーケンス番号にサブフローシーケンス番号からマッピングを定義DSSオプション（図9）のデータ列マッピングコンポーネントの使用を介して再組み立てすることができます。これは、アプリケーション層への順序配信を確実にするために受信機によって使用されます。一方、サブフローレベルのシーケンス番号（TCPヘッダ内すなわち、レギュラーシーケンス番号）がサブフローのみ関連性を有します。 SACK [11]は、効率を改善するためにサブフローレベルで使用されることが期待（しかし義務ではない）されています。"
    },
    {
      "indent": 3,
      "text": "The data sequence mapping specifies a mapping from subflow sequence space to data sequence space. This is expressed in terms of starting sequence numbers for the subflow and the data level, and a length of bytes for which this mapping is valid. This explicit mapping for a range of data was chosen rather than per-packet signaling to assist with compatibility with situations where TCP/IP segmentation or coalescing is undertaken separately from the stack that is generating the data flow (e.g., through the use of TCP segmentation offloading on network interface cards, or by middleboxes such as performance enhancing proxies). It also allows a single mapping to cover many packets, which may be useful in bulk transfer situations.",
      "ja": "データ系列のマッピングは、データ・シーケンス空間にサブフローシーケンス空間からのマッピングを指定します。これは、サブフローとデータレベル、及びこのマッピングが有効であるバイトの長さのシーケンス番号の開始点で表現されます。データの範囲については、この明示的なマッピングではなく、パケットごとのTCPセグメンテーションを使用することによって、TCP / IPセグメンテーション又は合体は、例えば、データフローを（生成されたスタックとは別に行われる状況との互換性を支援するためのシグナリングより選択されましたネットワーク・インターフェース・カードにオフロードする、又は）そのような性能向上プロキシとして中間装置によって。それはまた、バルク転送状況において有用であり得る、多くのパケットをカバーする単一のマッピングを可能にします。"
    },
    {
      "indent": 3,
      "text": "A mapping is fixed, in that the subflow sequence number is bound to the data sequence number after the mapping has been processed. A sender MUST NOT change this mapping after it has been declared; however, the same data sequence number can be mapped to by different subflows for retransmission purposes (see Section 3.3.6). This would also permit the same data to be sent simultaneously on multiple subflows for resilience or efficiency purposes, especially in the case of lossy links. Although the detailed specification of such operation is outside the scope of this document, an implementation SHOULD treat the first data that is received at a subflow for the data sequence space as that which should be delivered to the application, and any later data for that sequence space ignored.",
      "ja": "マッピングが処理された後サブフローシーケンス番号はデータのシーケンス番号にバインドされているという点でマッピングは、固定されています。それが宣言された後、送信者は、このマッピングを変更してはいけません。しかし、同一のデータシーケンス番号（セクション3.3.6を参照）、再送の目的で異なるサブフローをによってマッピングすることができます。また、これは、特に損失の多いリンクの場合には、回復力や効率化を目的として、複数のサブフローに同時に送信されるように、同じデータを可能にします。このような動作の詳細な仕様は、この文書の範囲外であるが、実装は、アプリケーションに配信されるべきこととして、データ配列空間のサブフローで受信された最初のデータ、およびその配列についてそれ以降のデータを扱うべきですスペースは無視します。"
    },
    {
      "indent": 3,
      "text": "The data sequence number is specified as an absolute value, whereas the subflow sequence numbering is relative (the SYN at the start of the subflow has relative subflow sequence number 0). This is to allow middleboxes to change the initial sequence number of a subflow, such as firewalls that undertake ISN randomization.",
      "ja": "サブフローシーケンス番号は相対的であるのに対し、データシーケンス番号は、絶対値として指定されている（サブフローの開始時SYN相対サブフローシーケンス番号0を有します）。これは、ミドルボックスは、このようなISNのランダム化を行うファイアウォールなどのサブフローの初期シーケンス番号を、変更することができるようにすることです。"
    },
    {
      "indent": 3,
      "text": "The data sequence mapping also contains a checksum of the data that this mapping covers, if use of checksums has been negotiated at the MP_CAPABLE exchange. Checksums are used to detect if the payload has been adjusted in any way by a non-MPTCP-aware middlebox. If this checksum fails, it will trigger a failure of the subflow, or a fallback to regular TCP, as documented in Section 3.6, since MPTCP can no longer reliably know the subflow sequence space at the receiver to build data sequence mappings.",
      "ja": "チェックサムの使用はMP_CAPABLE交換で交渉されている場合、データ系列のマッピングも、このマッピングがカバーするデータのチェックサムが含まれています。チェックサムは、ペイロードが非MPTCP認識ミドルによって任意の方法で調整されたかどうかを検出するために使用されます。このチェックサムが失敗した場合は、セクション3.6に記載されているようMPTCPは、もはや確実にデータ系列のマッピングを構築するための受信機でのサブフローシーケンス空間を知らないことができるので、それは、サブフローの故障、または定期的なTCPへのフォールバックをトリガします。"
    },
    {
      "indent": 3,
      "text": "The checksum algorithm used is the standard TCP checksum [1], operating over the data covered by this mapping, along with a pseudo-header as shown in Figure 10.",
      "ja": "使用されるチェックサムアルゴリズムは、図10に示すように、疑似ヘッダと一緒に、このマッピングによって覆われたデータ上で動作する、標準のTCPチェックサム[1]です。"
    },
    {
      "indent": 5,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+--------------------------------------------------------------+\n|                                                              |\n|                Data Sequence Number (8 octets)               |\n|                                                              |\n+--------------------------------------------------------------+\n|              Subflow Sequence Number (4 octets)              |\n+-------------------------------+------------------------------+\n|  Data-Level Length (2 octets) |        Zeros (2 octets)      |\n+-------------------------------+------------------------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 10: Pseudo-Header for DSS Checksum",
      "ja": "図10：DSSチェックサムのための疑似ヘッダー"
    },
    {
      "indent": 3,
      "text": "Note that the data sequence number used in the pseudo-header is always the 64-bit value, irrespective of what length is used in the DSS option itself. The standard TCP checksum algorithm has been chosen since it will be calculated anyway for the TCP subflow, and if calculated first over the data before adding the pseudo-headers, it only needs to be calculated once. Furthermore, since the TCP checksum is additive, the checksum for a DSN_MAP can be constructed by simply adding together the checksums for the data of each constituent TCP segment, and adding the checksum for the DSS pseudo-header.",
      "ja": "かかわらず、DSSオプション自体に使用されるものの長さの、疑似ヘッダで使用されるデータシーケンス番号は常に64ビットの値であることに留意されたいです。それはTCPのサブフローのためにとにかく計算されますので、標準のTCPチェックサムアルゴリズムが選択されている、と擬似ヘッダを追加する前に、データ上で最初に計算すれば、それは一度だけ計算する必要があります。 TCPチェックサムは、添加剤であるので、DSN_MAPのチェックサムは、単に各構成TCPセグメントのデータのために一緒にチェックサムを追加すること、およびDSS疑似ヘッダのチェックサムを追加することによって構築することができます。"
    },
    {
      "indent": 3,
      "text": "Note that checksumming relies on the TCP subflow containing contiguous data; therefore, a TCP subflow MUST NOT use the Urgent Pointer to interrupt an existing mapping. Further note, however, that if Urgent data is received on a subflow, it SHOULD be mapped to the data sequence space and delivered to the application analogous to Urgent data in regular TCP.",
      "ja": "そのチェックサムは、連続したデータを含むTCPのサブフローに依存しています注意してください。そのため、TCPのサブフローは、既存のマッピングを中断して緊急ポインタを使用してはなりません。さらにただし、緊急データがサブフローで受信された場合、それはデータ・シーケンス・スペースにマッピングされ、定期的なTCPで緊急データに類似するアプリケーションに配信されるべきであること。"
    },
    {
      "indent": 3,
      "text": "To avoid possible deadlock scenarios, subflow-level processing should be undertaken separately from that at connection level. Therefore, even if a mapping does not exist from the subflow space to the data-level space, the data SHOULD still be ACKed at the subflow (if it is in-window). This data cannot, however, be acknowledged at the data level (Section 3.3.2) because its data sequence numbers are unknown. Implementations MAY hold onto such unmapped data for a short while in the expectation that a mapping will arrive shortly. Such unmapped data cannot be counted as being within the connection level receive window because this is relative to the data sequence numbers, so if the receiver runs out of memory to hold this data, it will have to be discarded. If a mapping for that subflow-level sequence space does not arrive within a receive window of data, that subflow SHOULD be treated as broken, closed with a RST, and any unmapped data silently discarded.",
      "ja": "可能なデッドロック・シナリオを回避するために、サブフローレベルの処理は、接続レベルでそれとは別に行われるべきです。 （それは、インウィンドウの場合）したがって、マッピングはデータレベルの空間にサブフロー空間から存在していない場合であっても、データは引き続き、サブフローにACKされるべきです。このデータは、しかし、そのデータのシーケンス番号が不明であるため、データレベル（3.3.2）で確認することはできません。実装は、マッピングがまもなく到着することを期待してしばらくの間、そのようなマップされていないデータに保持してもよいです。これは、データシーケンス番号に対して相対的であるので、受信機は、このデータを保持するメモリを使い果たした場合、それは廃棄されなければならないため、このようなマッピングされていないデータは、受信ウィンドウ接続レベル内にあるものとしてカウントすることができません。そのサブフローレベルの配列空間のマッピングは、データの受信ウィンドウ内に到着しない場合、そのサブフローは破損、処理されたRSTで閉じ、そして任意のマップされていないデータを静かに捨てられるべきです。"
    },
    {
      "indent": 3,
      "text": "Data sequence numbers are always 64-bit quantities, and MUST be maintained as such in implementations. If a connection is progressing at a slow rate, so protection against wrapped sequence numbers is not required, then it is permissible to include just the lower 32 bits of the data sequence number in the data sequence mapping and/or Data ACK as an optimization, and an implementation can make this choice independently for each packet.",
      "ja": "データシーケンス番号は常に64ビット量であり、実装にそのまま維持されなければなりません。接続が遅い速度で進んでいるので、ラップされたシーケンス番号に対する保護が必要とされない、最適化などのデータ配列マッピングおよび/またはデータACKのデータシーケンス番号だけ下位32ビットを含むことが許容される場合および実装はパケットごとに独立して、この選択を行うことができます。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST send the full 64-bit data sequence number if it is transmitting at a sufficiently high rate that the 32-bit value could wrap within the Maximum Segment Lifetime (MSL) [16]. The lengths of the DSNs used in these values (which may be different) are declared with flags in the DSS option. Implementations MUST accept a 32-bit DSN and implicitly promote it to a 64-bit quantity by incrementing the upper 32 bits of sequence number each time the lower 32 bits wrap. A sanity check MUST be implemented to ensure that a wrap occurs at an expected time (e.g., the sequence number jumps from a very high number to a very low number) and is not triggered by out-of-order packets.",
      "ja": "それは32ビットの値が最大セグメント寿命（MSL）[16]内に包むことができ、十分に高いレートで送信された場合、実装は、完全な64ビットデータシーケンス番号を送信しなければなりません。 （異なっていてもよい）、これらの値に使用されるのDSNの長さは、DSSオプションのフラグを使用して宣言されます。実装は、32ビットのDSNを受け入れ、暗黙のシーケンス番号の上位32ビット下位32ビットがラップするたびに増分することによって、64ビット量にそれを促進しなければなりません。健全性チェックはラップが期待時間で起こることを確実にするために実施されなければならない（例えば、シーケンス番号が非常に低い数値に非常に高い数からジャンプ）とアウトオブオーダーパケットによってトリガされません。"
    },
    {
      "indent": 3,
      "text": "As with the standard TCP sequence number, the data sequence number should not start at zero, but at a random value to make blind session hijacking harder. This specification requires setting the initial data sequence number (IDSN) of each host to the least significant 64 bits of the SHA-1 hash of the host's key, as described in Section 3.1.",
      "ja": "標準のTCPシーケンス番号と同じように、データのシーケンス番号は0から始まりべきではなく、ランダムな値で難しいブラインドセッションハイジャックを作ること。この仕様は、セクション3.1で説明したように、ホストの鍵のSHA-1ハッシュの最下位64ビットに各ホストの初期データシーケンス番号（IDSN）を設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "A data sequence mapping does not need to be included in every MPTCP packet, as long as the subflow sequence space in that packet is covered by a mapping known at the receiver. This can be used to reduce overhead in cases where the mapping is known in advance; one such case is when there is a single subflow between the hosts, another is when segments of data are scheduled in larger than packet-sized chunks.",
      "ja": "データ系列のマッピングがある限り、そのパケット内のサブフロー配列スペースが受信機で知られているマッピングによって覆われているように、すべてのMPTCPパケットに含まれている必要はありません。このマッピングが予め分かっている場合にはオーバーヘッドを減少させるために使用することができます。そのような場合は、ホストとの間の単一のサブフローがある場合、データのセグメントをパケットサイズのチャンクより大きいにスケジュールされる場合、別のです。"
    },
    {
      "indent": 3,
      "text": "An \"infinite\" mapping can be used to fall back to regular TCP by mapping the subflow-level data to the connection-level data for the remainder of the connection (see Section 3.6). This is achieved by setting the Data-Level Length field of the DSS option to the reserved value of 0. The checksum, in such a case, will also be set to zero.",
      "ja": "「無限」マッピングは、接続の残りの接続レベルのデータへのサブフローレベルのデータをマッピングすることにより、定期的なTCPにフォールバックするために使用することができる（セクション3.6を参照）。このような場合には、0の予約値をチェックサムをDSSオプションのデータレベルのLengthフィールドを設定することによって達成され、ゼロに設定されます。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Data Acknowledgments",
      "section_title": true,
      "ja": "3.3.2. データ謝辞"
    },
    {
      "indent": 3,
      "text": "To provide full end-to-end resilience, MPTCP provides a connection-level acknowledgment, to act as a cumulative ACK for the connection as a whole. This is the \"Data ACK\" field of the DSS option (Figure 9). The Data ACK is analogous to the behavior of the standard TCP cumulative ACK -- indicating how much data has been successfully received (with no holes). This is in comparison to the subflow-level ACK, which acts analogous to TCP SACK, given that there may still be holes in the data stream at the connection level. The Data ACK specifies the next data sequence number it expects to receive.",
      "ja": "完全なエンドツーエンドの回復力を提供するために、MPTCPは、全体として、接続の累積ACKとして機能するように、接続レベルの肯定応答を提供します。これは、DSSオプション（図9）の「データACK」フィールドです。データACKは、標準的なTCP累積ACKの挙動と類似している - 正常（無孔で）受信されたデータ量を示します。これはまだ接続レベルでデータストリームの穴があるかもしれないことを考えると、TCP SACKと類似の作用サブフローレベルのACK、と比較してあります。データACKは、それが受信することを期待し、次のデータのシーケンス番号を指定します。"
    },
    {
      "indent": 3,
      "text": "The Data ACK, as for the DSN, can be sent as the full 64-bit value, or as the lower 32 bits. If data is received with a 64-bit DSN, it MUST be acknowledged with a 64-bit Data ACK. If the DSN received is 32 bits, it is valid for the implementation to choose whether to send a 32-bit or 64-bit Data ACK.",
      "ja": "データACKは、DSNと同様に、完全な64ビット値として、または下位32ビットとして送信することができます。データは64ビットのDSNを受信した場合は、64ビットのデータACKを確認する必要があります。受信されたDSNが32ビットである場合、それは32ビットまたは64ビットのデータACKを送信するかどうかを選択するための実装のために有効です。"
    },
    {
      "indent": 3,
      "text": "The Data ACK proves that the data, and all required MPTCP signaling, has been received and accepted by the remote end. One key use of the Data ACK signal is that it is used to indicate the left edge of the advertised receive window. As explained in Section 3.3.4, the receive window is shared by all subflows and is relative to the Data ACK. Because of this, an implementation MUST NOT use the RCV.WND field of a TCP segment at the connection level if it does not also carry a DSS option with a Data ACK field. Furthermore, separating the connection-level acknowledgments from the subflow level allows processing to be done separately, and a receiver has the freedom to drop segments after acknowledgment at the subflow level, for example, due to memory constraints when many segments arrive out of order.",
      "ja": "データACKは、データ、および必要なすべてのMPTCPシグナリングは、リモート側によって受信され、受け入れられていることを証明しています。データACK信号の1つのキーの使用は、受け取る広告ウィンドウの左端を示すために使用されることです。セクション3.3.4で説明したように、受信ウィンドウは、すべてのサブフローで共有およびデータACKを基準としています。それはまた、データACKフィールドでのDSSのオプションを有していない場合このため、実装は、接続レベルでTCPセグメントのRCV.WNDフィールドを使用してはなりません。また、サブフローレベルから接続レベルの肯定応答を分離する処理を別々に行うことができ、受信機は、多くのセグメントが順序を外れて到着したときによりメモリ制約のため、例えば、サブフローレベルで肯定応答した後にセグメントをドロップする自由を有します。"
    },
    {
      "indent": 3,
      "text": "An MPTCP sender MUST NOT free data from the send buffer until it has been acknowledged by both a Data ACK received on any subflow and at the subflow level by all subflows on which the data was sent. The former condition ensures liveness of the connection and the latter condition ensures liveness and self-consistence of a subflow when data needs to be retransmitted. Note, however, that if some data needs to be retransmitted multiple times over a subflow, there is a risk of blocking the sending window. In this case, the MPTCP sender can decide to terminate the subflow that is behaving badly by sending a RST.",
      "ja": "MPTCPの送信者は送信バッファから無料のデータてはならないことは、データACKの両方によって承認されるまでデータが送信されたすべてのサブフローことにより、任意のサブフローにし、サブフローレベルで受信。前者の条件は、接続と後者の条件の生存性を確実にデータを再送する必要がある場合ライブネス及びサブフローの自己一貫性を保証します。一部のデータは、サブフローを介して複数回再送信する必要がある場合、送信ウィンドウをブロックする危険性があること、しかし、注意してください。この場合、MPTCPの送信者は、RSTを送信することでひどく動作してサブフローを終了することを決定することができます。"
    },
    {
      "indent": 3,
      "text": "The Data ACK MAY be included in all segments; however, optimizations SHOULD be considered in more advanced implementations, where the Data ACK is present in segments only when the Data ACK value advances, and this behavior MUST be treated as valid. This behavior ensures the sender buffer is freed, while reducing overhead when the data transfer is unidirectional.",
      "ja": "データACKはすべてのセグメントに含まれるかもしれ。しかし、最適化は、データACKは、データACK値進み、この動作を有効として扱わなければならない場合にのみ、セグメント内に存在する、より高度な実装において考慮されるべきです。データ転送が一方向であるときにオーバーヘッドを低減しながら、この現象は、バッファが解放され、送信者が保証されます。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Closing a Connection",
      "section_title": true,
      "ja": "3.3.3. 接続を閉じます"
    },
    {
      "indent": 3,
      "text": "In regular TCP, a FIN announces the receiver that the sender has no more data to send. In order to allow subflows to operate independently and to keep the appearance of TCP over the wire, a FIN in MPTCP only affects the subflow on which it is sent. This allows nodes to exercise considerable freedom over which paths are in use at any one time. The semantics of a FIN remain as for regular TCP; i.e., it is not until both sides have ACKed each other's FINs that the subflow is fully closed.",
      "ja": "通常のTCPでは、FINは、送信者が送信するためにこれ以上のデータを持っている受信機を発表しました。サブフローは独立して動作し、ワイヤ上でTCPの外観を維持することを可能にするために、MPTCPフィンは、それが送信されたサブフローに影響を与えます。これは、ノードがパスが一度に使用されている上、かなりの自由を行使することができます。 FINのセマンティクスは通常のTCP用として残ります。双方が互いのフィンACKされるまで、すなわち、それは、サブフローが完全に閉じていることはありません。"
    },
    {
      "indent": 3,
      "text": "When an application calls close() on a socket, this indicates that it has no more data to send; for regular TCP, this would result in a FIN on the connection. For MPTCP, an equivalent mechanism is needed, and this is referred to as the DATA_FIN.",
      "ja": "アプリケーションがクローズ（）ソケットに呼び出すと、これは、それが送信すべきより多くのデータを有していないことを示しています。通常のTCPのために、これは、接続でFINことになります。 MPTCPため、同等の機構が必要とされ、これはDATA_FINと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "A DATA_FIN is an indication that the sender has no more data to send, and as such can be used to verify that all data has been successfully received. A DATA_FIN, as with the FIN on a regular TCP connection, is a unidirectional signal.",
      "ja": "DATA_FINは、送信者が送信するためにこれ以上データを有し、そのようなものとして、すべてのデータが正常に受信されたことを確認するために使用することができることを示しています。 DATA_FINは、通常のTCPコネクションのFINと同様に、単方向の信号です。"
    },
    {
      "indent": 3,
      "text": "The DATA_FIN is signaled by setting the 'F' flag in the Data Sequence Signal option (Figure 9) to 1. A DATA_FIN occupies 1 octet (the final octet) of the connection-level sequence space. Note that the DATA_FIN is included in the Data-Level Length, but not at the subflow level: for example, a segment with DSN 80, and Data-Level Length 11, with DATA_FIN set, would map 10 octets from the subflow into data sequence space 80-89, the DATA_FIN is DSN 90; therefore, this segment including DATA_FIN would be acknowledged with a DATA_ACK of 91.",
      "ja": "DATA_FIN 1. A DATA_FINへのデータシーケンス信号オプション（図9）に「F」フラグを設定することによって通知され、接続レベルの配列空間の1つのオクテット（最終オクテット）を占めています。 DATA_FINはデータレベルの長さが含まれていることに留意されたいが、サブフローレベルではない：例えば、DATA_FINセットとDSN 80、及びデータレベルの長さ11を有するセグメントは、データ・シーケンスにサブフローから10個のオクテットをマップしますスペース80から89、DATA_FINはDSN 90です。従って、DATA_FIN含むこのセグメントは、91のDATA_ACKと認められるであろう。"
    },
    {
      "indent": 3,
      "text": "Note that when the DATA_FIN is not attached to a TCP segment containing data, the Data Sequence Signal MUST have a subflow sequence number of 0, a Data-Level Length of 1, and the data sequence number that corresponds with the DATA_FIN itself. The checksum in this case will only cover the pseudo-header.",
      "ja": "DATA_FINは、データを含むTCPセグメントに取り付けられていない場合、データシーケンス信号が0のサブフロー配列番号1のデータレベルの長さ、及びDATA_FIN自体に対応するデータシーケンス番号を持たなければならないことに留意されたいです。この場合、チェックサムは、疑似ヘッダをカバーします。"
    },
    {
      "indent": 3,
      "text": "A DATA_FIN has the semantics and behavior as a regular TCP FIN, but at the connection level. Notably, it is only DATA_ACKed once all data has been successfully received at the connection level. Note, therefore, that a DATA_FIN is decoupled from a subflow FIN. It is only permissible to combine these signals on one subflow if there is no data outstanding on other subflows. Otherwise, it may be necessary to retransmit data on different subflows. Essentially, a host MUST NOT close all functioning subflows unless it is safe to do so, i.e., until all outstanding data has been DATA_ACKed, or until the segment with the DATA_FIN flag set is the only outstanding segment.",
      "ja": "DATA_FINは、通常のTCP FINなどのセマンティクスと動作を持っていますが、接続レベルで。特に、それは一度だけ、すべてのデータが正常に接続レベルで受信されたDATA_ACKedです。 DATA_FINはサブフローFINから切り離されていること、そのため、注意してください。他のサブフローに優れたデータがない場合は1つのサブフローにこれらの信号を組み合わせることのみ許容されます。それ以外の場合は、別のサブフローにデータを再送信する必要があるかもしれません。つまり、そうしても安全でない限り、基本的に、ホストは、すべての未処理データがDATA_ACKedされるまで、またはDATA_FINフラグが設定されたセグメントまで唯一の優秀なセグメントである、すべての機能サブフローを閉じてはなりません。"
    },
    {
      "indent": 3,
      "text": "Once a DATA_FIN has been acknowledged, all remaining subflows MUST be closed with standard FIN exchanges. Both hosts SHOULD send FINs on all subflows, as a courtesy to allow middleboxes to clean up state even if an individual subflow has failed. It is also encouraged to reduce the timeouts (Maximum Segment Life) on subflows at end hosts. In particular, any subflows where there is still outstanding data queued (which has been retransmitted on other subflows in order to get the DATA_FIN acknowledged) MAY be closed with a RST.",
      "ja": "DATA_FINが確認された後、残りのすべてのサブフローは、標準FIN交換で閉じなければなりません。両方のホストは、個々のサブフローが失敗した場合でも、ミドルボックスは、状態をクリーンアップできるように礼儀として、すべてのサブフローにフィン送るべきです。また、エンドホストでサブフローのタイムアウト（最大セグメントライフ）を低減することが推奨されます。具体的には、まだ未解決のデータがある任意のサブフローはRSTで閉鎖することができる（DATA_FINが認め得るために他のサブフローで再送信された）キューに入れられました。"
    },
    {
      "indent": 3,
      "text": "A connection is considered closed once both hosts' DATA_FINs have been acknowledged by DATA_ACKs.",
      "ja": "両方のホストのDATA_FINsがDATA_ACKsによって承認された後に接続が閉じられたと考えられています。"
    },
    {
      "indent": 3,
      "text": "As specified above, a standard TCP FIN on an individual subflow only shuts down the subflow on which it was sent. If all subflows have been closed with a FIN exchange, but no DATA_FIN has been received and acknowledged, the MPTCP connection is treated as closed only after a timeout. This implies that an implementation will have TIME_WAIT states at both the subflow and connection levels (see Appendix C). This permits \"break-before-make\" scenarios where connectivity is lost on all subflows before a new one can be re-established.",
      "ja": "上記のように、個々のサブフロー上の標準のTCP FINは、それが送信されたサブフローをシャットダウンします。すべてのサブフローがFIN為替で閉鎖されているが、何のDATA_FINを受信して​​いないと認識されている場合のみ、タイムアウト後に閉じて、MPTCP接続が処理されます。これにより、実装が両方のサブフローと接続レベル（付録Cを参照されたい）にTIME_WAIT状態を有するであろうことを意味します。これは、新しいものを再確立する前に接続がすべてのサブフローに失われた「ブレーク・ビフォア・メーク」のシナリオが可能になります。"
    },
    {
      "indent": 0,
      "text": "3.3.4. Receiver Considerations",
      "section_title": true,
      "ja": "3.3.4. レシーバの考慮事項"
    },
    {
      "indent": 3,
      "text": "Regular TCP advertises a receive window in each packet, telling the sender how much data the receiver is willing to accept past the cumulative ack. The receive window is used to implement flow control, throttling down fast senders when receivers cannot keep up.",
      "ja": "定期的なTCPは、受信機は、累積ACKを過ぎて受け入れることを望んでどのくらいのデータを送信者に伝える、各パケット内の受信ウィンドウをアドバタイズします。受信ウィンドウは、受信機が追いつくことができないときに高速の送信者をダウンスロットル、フロー制御を実装するために使用されます。"
    },
    {
      "indent": 3,
      "text": "MPTCP also uses a unique receive window, shared between the subflows. The idea is to allow any subflow to send data as long as the receiver is willing to accept it. The alternative, maintaining per subflow receive windows, could end up stalling some subflows while others would not use up their window.",
      "ja": "MPTCPもサブフロー間で共有、独自の受信ウィンドウを使用しています。アイデアは、受信機がそれを受け入れて喜んでである限り、データを送信するための任意のサブフローを可能にすることです。代替は、サブフローごとの維持は、窓を受け、他の人が自分のウィンドウを使用していないだろうが、いくつかのサブフローをストールてしまう可能性があります。"
    },
    {
      "indent": 3,
      "text": "The receive window is relative to the DATA_ACK. As in TCP, a receiver MUST NOT shrink the right edge of the receive window (i.e., DATA_ACK + receive window). The receiver will use the data sequence number to tell if a packet should be accepted at the connection level.",
      "ja": "受信ウィンドウDATA_ACKに相対的です。 TCPのように、受信機は、受信ウィンドウ（すなわち、DATA_ACK +受信ウィンドウ）の右端を縮小してはいけません。受信機は、パケットが接続レベルで受け入れられるかどうかを伝えるために、データのシーケンス番号を使用します。"
    },
    {
      "indent": 3,
      "text": "When deciding to accept packets at subflow level, regular TCP checks the sequence number in the packet against the allowed receive window. With multipath, such a check is done using only the connection-level window. A sanity check SHOULD be performed at subflow level to ensure that the subflow and mapped sequence numbers meet the following test: SSN - SUBFLOW_ACK <= DSN - DATA_ACK, where SSN is the subflow sequence number of the received packet and SUBFLOW_ACK is the RCV.NXT (next expected sequence number) of the subflow (with the equivalent connection-level definitions for DSN and DATA_ACK).",
      "ja": "サブフローレベルでパケットを受け入れるように決定する際には、通常のTCPは、受信ウィンドウを許可に対するパケット内のシーケンス番号をチェックします。マルチパスでは、そのようなチェックは、接続レベルのウィンドウを使用して行われます。健全性チェックは、サブフローとマッピングされたシーケンス番号は、以下の試験を満たすことを保証するために、サブフローレベルで行われるべきである：SSN  -  SUBFLOW_ACK <= DSN  -  SSNは、受信したパケットのサブフローシーケンス番号であり、SUBFLOW_ACKがRCV.NXTあるDATA_ACK、 （DSNとDATA_ACK等価接続レベルの定義を有する）サブフローの（次の予想されるシーケンス番号）。"
    },
    {
      "indent": 3,
      "text": "In regular TCP, once a segment is deemed in-window, it is put either in the in-order receive queue or in the out-of-order queue. In Multipath TCP, the same happens but at the connection level: a segment is placed in the connection level in-order or out-of-order queue if it is in-window at both connection and subflow levels. The stack still has to remember, for each subflow, which segments were received successfully so that it can ACK them at subflow level appropriately. Typically, this will be implemented by keeping per subflow out-of-order queues (containing only message headers, not the payloads) and remembering the value of the cumulative ACK.",
      "ja": "セグメントはインウィンドウたと判断すると、通常のTCPでは、それはインオーダーキューを受信したり、アウトオブオーダーキューの中のいずれかで入れています。マルチパスTCPでは、同じことが、接続レベルで起こる：それは接続とサブフローレベルの両方でイン・ウィンドウである場合にセグメントがイン・オーダーまたはアウトオブオーダーキュー接続レベルに配置されます。スタックはまだそれが適切にサブフローレベルでそれらをACKできるように、セグメントが正常に受信された各サブフローのために、覚えておく必要があります。典型的には、これは、（メッセージヘッダーだけではなく、ペイロードを含む）アウト・オブ・オーダーキューサブフローごとに保持し、累積ACKの値を記憶することにより実現されます。"
    },
    {
      "indent": 3,
      "text": "It is important for implementers to understand how large a receiver buffer is appropriate. The lower bound for full network utilization is the maximum bandwidth-delay product of any one of the paths. However, this might be insufficient when a packet is lost on a slower subflow and needs to be retransmitted (see Section 3.3.6). A tight upper bound would be the maximum round-trip time (RTT) of any path multiplied by the total bandwidth available across all paths. This permits all subflows to continue at full speed while a packet is fast-retransmitted on the maximum RTT path. Even this might be insufficient to maintain full performance in the event of a retransmit timeout on the maximum RTT path. It is for future study to determine the relationship between retransmission strategies and receive buffer sizing.",
      "ja": "実装者は、受信バッファが適切であるか、大きな理解することが重要です。完全なネットワーク使用率の下限は、パスのいずれかの最大帯域幅遅延積です。パケットが遅くサブフローに失われたと（第3.3.6項を参照）を再送信する必要があるときしかし、これでは不十分かもしれません。タイトな上限は、すべてのパス間で利用可能な総帯域幅を乗じた任意のパスの最大ラウンドトリップ時間（RTT）であろう。これは、パケットが最大RTTパスに高速再送されながら全速力で継続するために、すべてのサブフローを可能にします。でも、これは最大RTTパス上の再送タイムアウトが発生した場合に完全な性能を維持するには不十分かもしれません。これは、再送信戦略との関係を決定し、バッファサイズを受信するための今後の検討課題です。"
    },
    {
      "indent": 0,
      "text": "3.3.5. Sender Considerations",
      "section_title": true,
      "ja": "3.3.5. 送信者の考慮事項"
    },
    {
      "indent": 3,
      "text": "The sender remembers receiver window advertisements from the receiver. It should only update its local receive window values when the largest sequence number allowed (i.e., DATA_ACK + receive window) increases, on the receipt of a DATA_ACK. This is important to allow using paths with different RTTs, and thus different feedback loops.",
      "ja": "送信者は、受信機から受信ウィンドウの広告を覚えています。許容される最大のシーケンス番号（即ち、DATA_ACK +受信ウィンドウ）はDATA_ACKの受信時に、増加するときにのみ、そのローカル受信ウィンドウ値を更新すべきです。これは、異なるのRTTとのパスを使用可能にするために重要であるため、異なるフィードバックループ。"
    },
    {
      "indent": 3,
      "text": "MPTCP uses a single receive window across all subflows, and if the receive window was guaranteed to be unchanged end-to-end, a host could always read the most recent receive window value. However, some classes of middleboxes may alter the TCP-level receive window. Typically, these will shrink the offered window, although for short periods of time it may be possible for the window to be larger (however, note that this would not continue for long periods since ultimately the middlebox must keep up with delivering data to the receiver). Therefore, if receive window sizes differ on multiple subflows, when sending data MPTCP SHOULD take the largest of the most recent window sizes as the one to use in calculations. This rule is implicit in the requirement not to reduce the right edge of the window.",
      "ja": "MPTCPは、すべてのサブフロー間で、単一の受信ウィンドウを使用して、受信ウィンドウはそのままエンド・ツー・エンドであることが保証された場合、ホストは、常に最新の受信ウィンドウ値を読むことができました。しかし、TCPレベルを変更することができるミドルボックスのいくつかのクラスは、ウィンドウを受け取ります。ウィンドウを大きくするために時間の短い期間のためにそれが可能であってもよいが、典型的には、これらは（但し、最終的ミドルボックスは、受信機にデータを配信するに追いつくなければならないので、これは長期間継続しないであろうことに注意し、提供されるウィンドウを縮小します）。そのため、受信した場合、ウィンドウサイズは、複数のサブフローに異なり、計算に使用する1つとして、最新のウィンドウサイズの最大を取るべきデータMPTCPを送信するとき。このルールは、ウィンドウの右端を低下させない要件で暗黙的です。"
    },
    {
      "indent": 3,
      "text": "The sender MUST also remember the receive windows advertised by each subflow. The allowed window for subflow i is (ack_i, ack_i + rcv_wnd_i), where ack_i is the subflow-level cumulative ACK of subflow i. This ensures data will not be sent to a middlebox unless there is enough buffering for the data.",
      "ja": "送信者はまた、インクルードが各サブフローによって広告窓を受け取る覚えておく必要があります。 ack_iがサブフローIのサブフローレベル累積ACKでiはサブフローの許容ウィンドウ（ack_i、ack_i + rcv_wnd_i）。これは、データのための十分なバッファリングがない限り、データがミドルに送信されないことが保証されます。"
    },
    {
      "indent": 3,
      "text": "Putting the two rules together, we get the following: a sender is allowed to send data segments with data-level sequence numbers between (DATA_ACK, DATA_ACK + receive_window). Each of these segments will be mapped onto subflows, as long as subflow sequence numbers are in the allowed windows for those subflows. Note that subflow sequence numbers do not generally affect flow control if the same receive window is advertised across all subflows. They will perform flow control for those subflows with a smaller advertised receive window.",
      "ja": "一緒に2つのルールを置く、我々は次を得る：送信者は（DATA_ACK、DATA_ACK + receive_window）との間でデータレベルのシーケンス番号とデータセグメントを送信することが許可されています。これらのセグメントの各々は限りサブフローシーケンス番号は、それらのサブフローのための許容ウィンドウ内にあるように、サブフローにマッピングされます。同じことが、窓がすべてのサブフロー間で宣伝されて受信した場合、サブフローシーケンス番号は、一般的フロー制御に影響を与えないことに注意してください。彼らは、受信ウィンドウを宣伝小さいとのそれらのサブフローのフロー制御を行います。"
    },
    {
      "indent": 3,
      "text": "The send buffer MUST, at a minimum, be as big as the receive buffer, to enable the sender to reach maximum throughput.",
      "ja": "送信バッファは、最低でも、最大スループットに到達するために、送信者を有効にするために、受信バッファと同じ大きさでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3.6. Reliability and Retransmissions",
      "section_title": true,
      "ja": "3.3.6. 信頼性および再送信"
    },
    {
      "indent": 3,
      "text": "The data sequence mapping allows senders to resend data with the same data sequence number on a different subflow. When doing this, a host MUST still retransmit the original data on the original subflow, in order to preserve the subflow integrity (middleboxes could replay old data, and/or could reject holes in subflows), and a receiver will ignore these retransmissions. While this is clearly suboptimal, for compatibility reasons this is sensible behavior. Optimizations could be negotiated in future versions of this protocol.",
      "ja": "データシーケンスマッピングは送信者が異なるサブフローに同一のデータシーケンス番号とデータを再送信することを可能にします。これを実行すると、ホストはまだ（ミドルボックスは、古いデータを再生することができ、および/またはサブフローに穴を拒否することができ）、サブフロー整合性を維持するためには、オリジナルのサブフローに元のデータを再送信しなければならない、と受信機は、これらの再送信を無視します。これは明らかに次善のですが、互換性の理由から、これは賢明な行動です。最適化は、このプロトコルの将来のバージョンで交渉することができます。"
    },
    {
      "indent": 3,
      "text": "This protocol specification does not mandate any mechanisms for handling retransmissions, and much will be dependent upon local policy (as discussed in Section 3.3.8). One can imagine aggressive connection-level retransmissions policies where every packet lost at subflow level is retransmitted on a different subflow (hence, wasting bandwidth but possibly reducing application-to-application delays), or conservative retransmission policies where connection-level retransmits are only used after a few subflow-level retransmission timeouts occur.",
      "ja": "このプロトコル仕様は、再送信を処理するための任意のメカニズムを強制しない、と多くは（セクション3.3.8で説明したように）ローカルポリシーに依存するであろう。一つは、接続レベルの再送のみを使用しているサブフローレベルで失われたすべてのパケットが異なるサブフローに再送され、積極的な接続レベルの再送信ポリシー（したがって、帯域幅を無駄にするが、おそらくアプリケーション間の遅延を減らす）、または保守的再送ポリシーを想像することができますいくつかのサブフローレベルの再送タイムアウトが発生した後。"
    },
    {
      "indent": 3,
      "text": "It is envisaged that a standard connection-level retransmission mechanism would be implemented around a connection-level data queue: all segments that haven't been DATA_ACKed are stored. A timer is set when the head of the connection-level is ACKed at subflow level but its corresponding data is not ACKed at data level. This timer will guard against failures in retransmission by middleboxes that proactively ACK data.",
      "ja": "DATA_ACKedされていないすべてのセグメントが格納されている：標準的な接続レベルの再送信機構が接続レベルのデータキューの周囲に実装されることが想定されます。接続レベルのヘッドがサブフローレベルでACKされているが、その対応するデータがデータレベルでACKされていない場合、タイマがセットされます。このタイマーは、ミドルボックス積極的にACKデータによって再送信の障害から保護します。"
    },
    {
      "indent": 3,
      "text": "The sender MUST keep data in its send buffer as long as the data has not been acknowledged at both connection level and on all subflows on which it has been sent. In this way, the sender can always retransmit the data if needed, on the same subflow or on a different one. A special case is when a subflow fails: the sender will typically resend the data on other working subflows after a timeout, and will keep trying to retransmit the data on the failed subflow too. The sender will declare the subflow failed after a predefined upper bound on retransmissions is reached (which MAY be lower than the usual TCP limits of the Maximum Segment Life), or on the receipt of an ICMP error, and only then delete the outstanding data segments.",
      "ja": "送信者がいる限り、データが両方の接続レベルで、それが送られてきているすべてのサブフローに確認されていないように、その送信バッファ内のデータを保持しなければなりません。必要であれば、この方法では、送信者は、常に同じサブフローまたは異なる1に、データを再送信することができます。サブフローが失敗したときに、特殊なケースです：送信者は通常、タイムアウト後に他の作業のサブフローにデータを再送信すると、あまりにも失敗したサブフロー上のデータを再送信しようとし続けます。送信者は、（最大セグメント生活の通常のTCP限度よりも低くてもよい）に到達する再送信の事前に定義された上限の後に失敗したサブフローを宣言するか、ICMPエラーの受信時に、とだけにして、優れたデータ・セグメントを削除します。"
    },
    {
      "indent": 3,
      "text": "Multiple retransmissions are triggers that will indicate that a subflow performs badly and could lead to a host resetting the subflow with a RST. However, additional research is required to understand the heuristics of how and when to reset underperforming subflows. For example, a highly asymmetric path may be misdiagnosed as underperforming.",
      "ja": "複数の再送信は、サブフローがひどく実行すると表示され、RSTとサブフローをリセットするホストにつながる可能性がトリガされています。しかし、追加的な研究が不採算サブフローをリセットする方法と時期の経験則を理解することが必要です。例えば、高度に非対称の経路が不採算と誤診されてもよいです。"
    },
    {
      "indent": 0,
      "text": "3.3.7. Congestion Control Considerations",
      "section_title": true,
      "ja": "3.3.7. 輻輳制御に関する注意事項"
    },
    {
      "indent": 3,
      "text": "Different subflows in an MPTCP connection have different congestion windows. To achieve fairness at bottlenecks and resource pooling, it is necessary to couple the congestion windows in use on each subflow, in order to push most traffic to uncongested links. One algorithm for achieving this is presented in [5]; the algorithm does not achieve perfect resource pooling but is \"safe\" in that it is readily deployable in the current Internet. By this, we mean that it does not take up more capacity on any one path than if it was a single path flow using only that route, so this ensures fair coexistence with single-path TCP at shared bottlenecks.",
      "ja": "MPTCP接続で異なるサブフローは異なる輻輳ウィンドウを持っています。ボトルネックやリソースプールでの公平性を実現するためには、非輻輳リンクに最もトラフィックをプッシュするために、各サブフローに使用されている輻輳ウィンドウ結合させることが必要です。これを達成するための1つのアルゴリズムは、[5]に提示されています。このアルゴリズムは、完全なリソースプールを達成したが、それは現在のインターネットで容易に展開可能であるという点で、「安全」ではありません。これにより、我々は、それが唯一のそのルートを使用して、単一パスの流れだった場合よりも、いずれかのパスでより多くの容量を占有しないことを意味し、これは共有のボトルネックでシングルパスのTCPとの公平な共存を保証します。"
    },
    {
      "indent": 3,
      "text": "It is foreseeable that different congestion controllers will be implemented for MPTCP, each aiming to achieve different properties in the resource pooling/fairness/stability design space, as well as those for achieving different properties in quality of service, reliability, and resilience.",
      "ja": "別の輻輳制御器は、それぞれのリソースプール/公正性/安定性の設計空間だけでなく、サービス、信頼性、および回復力の質の異なる特性を達成するために、これらの異なる特性を達成することを目指し、MPTCPのために実装されることが予想されます。"
    },
    {
      "indent": 3,
      "text": "Regardless of the algorithm used, the design of the MPTCP protocol aims to provide the congestion control implementations sufficient information to take the right decisions; this information includes, for each subflow, which packets were lost and when.",
      "ja": "関係なく使用されるアルゴリズムの、MPTCPプロトコルの設計は、適切な意思決定を取るために輻輳制御の実装に十分な情報を提供することを目指し、この情報は、パケットが失われた各サブフローのために、含まれています。"
    },
    {
      "indent": 0,
      "text": "3.3.8. Subflow Policy",
      "section_title": true,
      "ja": "3.3.8. サブフローポリシー"
    },
    {
      "indent": 3,
      "text": "Within a local MPTCP implementation, a host may use any local policy it wishes to decide how to share the traffic to be sent over the available paths.",
      "ja": "ローカルMPTCP実装内では、ホストは、それが利用可能なパスを介して送信されるトラフィックを共有する方法を決定することを希望する任意のローカルポリシーを使用することができます。"
    },
    {
      "indent": 3,
      "text": "In the typical use case, where the goal is to maximize throughput, all available paths will be used simultaneously for data transfer, using coupled congestion control as described in [5]. It is expected, however, that other use cases will appear.",
      "ja": "目的は、スループットを最大にするために、典型的なユースケースでは、利用可能なすべてのパスが[5]で説明されるように結合された輻輳制御を使用して、データ転送のために同時に使用されます。他の使用例が表示されること、しかし、期待されています。"
    },
    {
      "indent": 3,
      "text": "For instance, a possibility is an 'all-or-nothing' approach, i.e., have a second path ready for use in the event of failure of the first path, but alternatives could include entirely saturating one path before using an additional path (the 'overflow' case). Such choices would be most likely based on the monetary cost of links, but may also be based on properties such as the delay or jitter of links, where stability (of delay or bandwidth) is more important than throughput. Application requirements such as these are discussed in detail in [6].",
      "ja": "たとえば、可能性は「オール・オア・ナッシング」アプローチである、（すなわち、最初のパスの障害が発生した場合に使用するための準備ができて第二の経路を持っていますが、選択肢は完全に追加パスを使用する前に、一つのパスが飽和含めることができます「オーバーフロー」の場合）。そのような選択は、最も可能性の高いリンクの金銭的コストに基づいているだろうが、また、（遅延や帯域幅の）安定性、スループットよりも重要であるリンクの遅延やジッタなどの特性に基づいてもよいです。このようなアプリケーションの要件は、[6]に詳細に記載されています。"
    },
    {
      "indent": 3,
      "text": "The ability to make effective choices at the sender requires full knowledge of the path \"cost\", which is unlikely to be the case. It would be desirable for a receiver to be able to signal their own preferences for paths, since they will often be the multihomed party, and may have to pay for metered incoming bandwidth.",
      "ja": "送信者に効果的な選択をする能力がケースになることはほとんどありませんパス「コスト」、の完全な知識が必要です。受信機はパスのために自分の好みを通知できるようにするために、彼らはしばしば、マルチホームパーティになり、計量された着信帯域幅のために支払わなければならないかもしれないのでそれは、望ましいであろう。"
    },
    {
      "indent": 3,
      "text": "Whilst fine-grained control may be the most powerful solution, that would require some mechanism such as overloading the Explicit Congestion Notification (ECN) signal [17], which is undesirable, and it is felt that there would not be sufficient benefit to justify an entirely new signal. Therefore, the MP_JOIN option (see Section 3.2) contains the 'B' bit, which allows a host to indicate to its peer that this path should be treated as a backup path to use only in the event of failure of other working subflows (i.e., a subflow where the receiver has indicated B=1 SHOULD NOT be used to send data unless there are no usable subflows where B=0).",
      "ja": "きめ細かな制御は、このような望ましくない明示的輻輳通知（ECN）信号[17]、過負荷などのいくつかの機構が必要となる最も強力な溶液であってもよく、正当化するのに十分な利益がないだろうと感じている間全く新しい信号。したがって、MP_JOINオプションは（セクション3.2を参照）ホストは、このパスは他の作業サブフローの故障の場合にのみ使用するバックアップパスとして扱われるべきであることをピアに知らせることを可能にする「B」ビットを含み（すなわち、 、受信機は、B = 1を示しているサブフローは全く使用可能なサブフローが存在しない場合を除き、データを送信するために使用すべきではない場合B = 0）。"
    },
    {
      "indent": 3,
      "text": "In the event that the available set of paths changes, a host may wish to signal a change in priority of subflows to the peer (e.g., a subflow that was previously set as backup should now take priority over all remaining subflows). Therefore, the MP_PRIO option, shown in Figure 11, can be used to change the 'B' flag of the subflow on which it is sent.",
      "ja": "経路変更の利用可能なセットは、ホストがピアにサブフローの優先順位の変更をシグナリングすることを望むかもしれた場合に（例えば、以前にバックアップとして設定されたサブフローは、すべての残りのサブフローよりも優先すべきです）。したがって、図11に示すMP_PRIOオプションは、それが送信されたサブフローの「B」フラグを変更するために使用することができます。"
    },
    {
      "indent": 6,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------+-----+-+--------------+\n|     Kind      |     Length    |Subtype|     |B| AddrID (opt) |\n+---------------+---------------+-------+-----+-+--------------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 11: Change Subflow Priority (MP_PRIO) Option",
      "ja": "図11：サブフロー優先順位を変更（MP_PRIO）オプション"
    },
    {
      "indent": 3,
      "text": "It should be noted that the backup flag is a request from a data receiver to a data sender only, and the data sender SHOULD adhere to these requests. A host cannot assume that the data sender will do so, however, since local policies -- or technical difficulties -- may override MP_PRIO requests. Note also that this signal applies to a single direction, and so the sender of this option could choose to continue using the subflow to send data even if it has signaled B=1 to the other host.",
      "ja": "バックアップフラグは、データ受信機からのデータのみを送信者に要求され、かつデータの送信者がこれらの要求を遵守すべきことに留意すべきです。または技術的な問題 -   - ホストがデータの送信者がローカルポリシー以来、しかし、そうするだろうと仮定することはできませんMP_PRIO要求を無効にすることができます。この信号は、単一の方向に適用されるので、このオプションの送信者は、それが他のホストにB = 1を合図している場合でも、データを送信するためにサブフローを引き続き使用することを選択することができることにも注意してください。"
    },
    {
      "indent": 3,
      "text": "This option can also be applied to other subflows than the one on which it is sent, by setting the optional Address ID field. This applies the given setting of B to all subflows in this connection that use the address identified by the given Address ID. The presence of this field is determined by the option length; if Length==4 then it is present. If Length==3, then it applies to the current subflow only. The use case of this is that a host can signal to its peer that an address is temporarily unavailable (for example, if it has radio coverage issues) and the peer should therefore drop to backup state on all subflows using that Address ID.",
      "ja": "このオプションは、オプションのアドレスIDフィールドを設定することによって、それが送信されているもの以外のサブフローに適用することができます。これは、指定したアドレスIDで識別されるアドレスを使用して、この接続中のすべてのサブフローにBの与えられた設定を適用します。このフィールドの存在はオプションの長さによって決定されます。長さ== 4は、それが存在する場合。長さ== 3なら、それは現在のサブフローに適用されます。このユースケースは、ホストが（それは無線カバレッジの問題を有する場合、例えば）アドレスが一時的に利用できないピアに信号を送ることができ、ピアは、従って、そのアドレスのIDを使用して、すべてのサブフローにバックアップ状態に落とす必要があることです。"
    },
    {
      "indent": 0,
      "text": "3.4. Address Knowledge Exchange (Path Management)",
      "section_title": true,
      "ja": "3.4. サポート技術情報交換（パス管理）に対処"
    },
    {
      "indent": 3,
      "text": "We use the term \"path management\" to refer to the exchange of information about additional paths between hosts, which in this design is managed by multiple addresses at hosts. For more detail of the architectural thinking behind this design, see the MPTCP Architecture document [2].",
      "ja": "私たちは、この設計では、ホストで複数のアドレスで管理されているホストとの間の追加パスに関する情報の交換を参照するために用語「パス管理」を使用しています。この設計の背後にある建築の考え方の詳細については、[2] MPTCPアーキテクチャ文書を参照してください。"
    },
    {
      "indent": 3,
      "text": "This design makes use of two methods of sharing such information, and both can be used on a connection. The first is the direct setup of new subflows, already described in Section 3.2, where the initiator has an additional address. The second method, described in the following subsections, signals addresses explicitly to the other host to allow it to initiate new subflows. The two mechanisms are complementary: the first is implicit and simple, while the explicit is more complex but is more robust. Together, the mechanisms allow addresses to change in flight (and thus support operation through NATs, since the source address need not be known), and also allow the signaling of previously unknown addresses, and of addresses belonging to other address families (e.g., both IPv4 and IPv6).",
      "ja": "この設計は、そのような情報を共有する二つの方法を利用して、両方の接続に使用することができます。最初は、すでにイニシエータが追加アドレスを持っている3.2項で説明した新しいサブフローの直接的な設定です。以下のサブセクションで説明した第2の方法は、それが新しいサブフローを開始することを可能にする他のホストに明示的にアドレスを知らせます。 2つのメカニズムが相補的である：明示的には、より複雑であるが、より堅牢である一方、最初は、暗黙的で簡単です。両方とも、例えば（一緒に、メカニズムはアドレスが飛行中に変更することができます（したがって、NATを通過操作をサポートする、送信元アドレスが知られていない必要があるため）、そしてまた、以前に未知のアドレスのシグナリングを可能にし、他のアドレスファミリーに属するアドレスのIPv4とIPv6）。"
    },
    {
      "indent": 3,
      "text": "Here is an example of typical operation of the protocol:",
      "ja": "ここでプロトコルの典型的な動作の一例です。"
    },
    {
      "indent": 3,
      "text": "o An MPTCP connection is initially set up between address/port A1 of Host A and address/port B1 of Host B. If Host A is multihomed and multiaddressed, it can start an additional subflow from its address A2 to B1, by sending a SYN with a Join option from A2 to B1, using B's previously declared token for this connection. Alternatively, if B is multihomed, it can try to set up a new subflow from B2 to A1, using A's previously declared token. In either case, the SYN will be sent to the port already in use for the original subflow on the receiving host.",
      "ja": "MPTCP接続は最初にホストAがマルチホームおよび同報されている場合は、SYNを送信することによって、B1にそのアドレスA2から追加のサブフローを起動することができ、ホストAのアドレス/ポートA1との間に設定し、ホストBのアドレス/ポートB1はOこの接続のためにBの前に宣言されたトークンを使用して、B1にA2からオプションに参加しています。 Bがマルチホームである場合あるいは、それはAさんが以前のトークンに宣言使用して、B2からA1に新しいサブフローを設定しようとすることができます。いずれの場合においても、SYNは受信ホスト上の元のサブフローのためにすでに使用中のポートに送信されます。"
    },
    {
      "indent": 3,
      "text": "o Simultaneously (or after a timeout), an ADD_ADDR option (Section 3.4.1) is sent on an existing subflow, informing the receiver of the sender's alternative address(es). The recipient can use this information to open a new subflow to the sender's additional address. In our example, A will send ADD_ADDR option informing B of address/port A2. The mix of using the SYN-based option and the ADD_ADDR option, including timeouts, is implementation specific and can be tailored to agree with local policy.",
      "ja": "同時に（またはタイムアウト後に）O、ADD_ADDRオプション（3.4.1）は、送信者の代替アドレス（複数可）の受信を知らせる、既存のサブフローに送信されます。受信者は送信者の追加アドレスに新しいサブフローを開くには、この情報を使用することができます。この例では、Aは、アドレス/ポートA2のBを知らせるADD_ADDRオプションを送信します。タイムアウトを含むSYNベースのオプションとADD_ADDRオプションを使用してのミックスは、実装固有のものであり、ローカルポリシーに同意するように調整することができます。"
    },
    {
      "indent": 3,
      "text": "o If subflow A2-B1 is successfully set up, Host B can use the Address ID in the Join option to correlate this with the ADD_ADDR option that will also arrive on an existing subflow; now B knows not to open A2-B1, ignoring the ADD_ADDR. Otherwise, if B has not received the A2-B1 MP_JOIN SYN but received the ADD_ADDR, it can try to initiate a new subflow from one or more of its addresses to address A2. This permits new sessions to be opened if one host is behind a NAT.",
      "ja": "サブフローA2-B1が正常に設定されている場合は、O、ホストBは、既存のサブフローに到着しますADD_ADDRオプションでこれを相関させるために参加オプションのアドレスIDを使用することができます。今BはADD_ADDRを無視して、A2-B1を開くことがない知っています。 BはADD_ADDR A2-B1 MP_JOIN SYNを受けたが、受信していない場合はそれ以外の場合、それはA2に対応するためにそのアドレスの一つ以上から新しいサブフローを開始しようとすることができます。これは、1つのホストがNATの背後にある場合は、新しいセッションが開かれることを可能にします。"
    },
    {
      "indent": 3,
      "text": "Other ways of using the two signaling mechanisms are possible; for instance, signaling addresses in other address families can only be done explicitly using the Add Address option.",
      "ja": "2つのシグナリングメカニズムを使用する他の方法も可能です。例えば、他のアドレスファミリ内のシグナリングアドレスはアドレスの追加オプションを使用して明示的に行うことができます。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Address Advertisement",
      "section_title": true,
      "ja": "3.4.1. 住所広告"
    },
    {
      "indent": 3,
      "text": "The Add Address (ADD_ADDR) TCP option announces additional addresses (and optionally, ports) on which a host can be reached (Figure 12). Multiple instances of this TCP option can be added in a single message if there is sufficient TCP option space; otherwise, multiple TCP messages containing this option will be sent. This option can be used at any time during a connection, depending on when the sender wishes to enable multiple paths and/or when paths become available. As with all MPTCP signals, the receiver MUST undertake standard TCP validity checks before acting upon it.",
      "ja": "アドレスの追加（ADD_ADDR）TCPオプションが追加アドレス（および必要に応じて、ポート）ホストに到達可能な（図12）を発表しました。十分なTCPオプションのスペースがある場合は、このTCPオプションの複数のインスタンスを単一のメッセージに追加することができます。そうでない場合は、このオプションを含む複数のTCPメッセージが送信されます。このオプションは、送信者が複数のパスおよび/またはパスが利用可能になったときを有効にしたい場合に応じて、接続中の任意の時点で使用することができます。すべてMPTCP信号と同様に、受信機は、それに作用する前に、標準TCPの有効性チェックを実施しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Every address has an Address ID that can be used for uniquely identifying the address within a connection for address removal. This is also used to identify MP_JOIN options (see Section 3.2) relating to the same address, even when address translators are in use. The Address ID MUST uniquely identify the address to the sender (within the scope of the connection), but the mechanism for allocating such IDs is implementation specific.",
      "ja": "すべてのアドレスは、一意のアドレスを除去するための接続内のアドレスを識別するために使用することができるアドレスのIDを有しています。これは、アドレス変換が使用されている場合でも、同じアドレスに関連する（3.2節を参照）MP_JOINオプションを識別するために使用されます。アドレスIDは一意に（接続の範囲内で）送信者にアドレスを識別しなければならないが、そのようなIDを割り当てるためのメカニズムは、実装固有です。"
    },
    {
      "indent": 3,
      "text": "All address IDs learned via either MP_JOIN or ADD_ADDR SHOULD be stored by the receiver in a data structure that gathers all the Address ID to address mappings for a connection (identified by a token pair). In this way, there is a stored mapping between Address ID, observed source address, and token pair for future processing of control information for a connection. Note that an implementation MAY discard incoming address advertisements at will, for example, for avoiding the required mapping state, or because advertised addresses are of no use to it (for example, IPv6 addresses when it has IPv4 only). Therefore, a host MUST treat address advertisements as soft state, and it MAY choose to refresh advertisements periodically.",
      "ja": "MP_JOIN又はADD_ADDRのいずれかを介して学習されたすべてのアドレスIDが（トークンペアによって識別される）接続のためのマッピングに対処するために、すべてのアドレスIDを収集するデータ構造内の受信機によって保存されるべきです。このようにして、接続のための制御情報の将来の処理のためにアドレスID、観察された送信元アドレス、及びトークンペア間の格納されたマッピングがあります。 （それはIPv4のみを有する場合、例えば、IPv6アドレス）の実装は、例えば、必要なマッピング状態を回避するために、随意に着信アドレス広告を捨てることに注意してください、またはアドバタイズアドレスはそれに役に立たないからです。したがって、ホストはソフト状態としてアドレス広告を扱わなければならない、そしてそれは、定期的に広告をリフレッシュするために選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "This option is shown in Figure 12. The illustration is sized for IPv4 addresses (IPVer = 4). For IPv6, the IPVer field will read 6, and the length of the address will be 16 octets (instead of 4).",
      "ja": "このオプションは、図示はIPv4アドレス（IPVer = 4）のために寸法決めされている図12に示されています。 IPv6の場合、IPVerフィールドが6を読み取り、アドレスの長さは16個のオクテット（代わりの4）となります。"
    },
    {
      "indent": 3,
      "text": "The presence of the final 2 octets, specifying the TCP port number to use, are optional and can be inferred from the length of the option. Although it is expected that the majority of use cases will use the same port pairs as used for the initial subflow (e.g., port 80 remains port 80 on all subflows, as does the ephemeral port at the client), there may be cases (such as port-based load balancing) where the explicit specification of a different port is required. If no port is specified, MPTCP SHOULD attempt to connect to the specified address on the same port as is already in use by the subflow on which the ADD_ADDR signal was sent; this is discussed in more detail in Section 3.8.",
      "ja": "最終2つのオクテットの存在下、使用するTCPポート番号を指定することは、オプションであり、オプションの長さから推測することができます。それは最初のサブフローのために使用されるようなユースケースの大半が同じポートのペアを使用することが期待されるが（そのような場合があるかもしれない、（クライアント側で一時的なポートがそうであるように例えば、ポート80は、すべてのサブフローのポート80のまま）異なるポートの明示的な指定が必要とされるポートベースのロード・バランシング）など。ポートが指定されていない場合、MPTCPはADD_ADDR信号が送信されたサブフローによってすでに使用されているのと同じポート上の指定されたアドレスへの接続を試みます。これは、3.8節で詳しく説明されています。"
    },
    {
      "indent": 6,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------+-------+---------------+\n|     Kind      |     Length    |Subtype| IPVer |  Address ID   |\n+---------------+---------------+-------+-------+---------------+\n|          Address (IPv4 - 4 octets / IPv6 - 16 octets)         |\n+-------------------------------+-------------------------------+\n|   Port (2 octets, optional)   |\n+-------------------------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 12: Add Address (ADD_ADDR) Option",
      "ja": "図12：追加アドレス（ADD_ADDR）オプション"
    },
    {
      "indent": 3,
      "text": "Due to the proliferation of NATs, it is reasonably likely that one host may attempt to advertise private addresses [18]. It is not desirable to prohibit this, since there may be cases where both hosts have additional interfaces on the same private network, and a host MAY want to advertise such addresses. The MP_JOIN handshake to create a new subflow (Section 3.2) provides mechanisms to minimize security risks. The MP_JOIN message contains a 32-bit token that uniquely identifies the connection to the receiving host. If the token is unknown, the host will return with a RST. In the unlikely event that the token is known, subflow setup will continue, but the HMAC exchange must occur for authentication. This will fail, and will provide sufficient protection against two unconnected hosts accidentally setting up a new subflow upon the signal of a private address. Further security considerations around the issue of ADD_ADDR messages that accidentally misdirect, or maliciously direct, new MP_JOIN attempts are discussed in Section 5.",
      "ja": "原因のNATの増殖のために、一つのホストがプライベートアドレス[18]を宣伝しようとすることが合理的な可能性です。両方のホストが同じプライベートネットワーク上の追加のインタフェースを持っているケースがあるかもしれないので、これを禁止することは望ましくない、とホストは、そのようなアドレスを宣伝することもできます。新しいサブフロー（3.2節）を作成するためにMP_JOINハンドシェイクは、セキュリティ上のリスクを最小限にするためのメカニズムを提供します。 MP_JOINメッセージを一意に受信ホストへの接続を識別する32ビットのトークンを含みます。トークンが不明な場合は、ホストがRSTに戻ります。トークンが知られていること万一、サブフローセットアップは続行されますが、HMAC交換は認証のために行われなければなりません。これは失敗し、2つの未接続のホストが誤ってプライベートアドレスの信号に新しいサブフローを設定に対して十分な保護を提供します。誤っmisdirect、または悪意を持って直接ADD_ADDRメッセージの問題の周りにさらなるセキュリティの考慮事項は、新しいMP_JOINの試みは第5節で議論されています。"
    },
    {
      "indent": 3,
      "text": "Ideally, ADD_ADDR and REMOVE_ADDR options would be sent reliably, and in order, to the other end. This would ensure that this address management does not unnecessarily cause an outage in the connection when remove/add addresses are processed in reverse order, and also to ensure that all possible paths are used. Note, however, that losing reliability and ordering will not break the multipath connections, it will just reduce the opportunity to open multipath paths and to survive different patterns of path failures.",
      "ja": "理想的には、ADD_ADDRとREMOVE_ADDRオプションは、順番に、もう一方の端に、確実に送信されます。これは、削除は/アドレスを追加する場合、このアドレス管理が不必要に逆の順序で処理され、また、可能なすべてのパスが使用されていることを確認するために、接続に障害が生じないことを確実にするでしょう。マルチパス接続が中断されません信頼性と秩序を失って、それだけでマルチパスを開くための機会を減らすことになり、パス障害の異なるパターンを生き残るためにいること、しかし、注意してください。"
    },
    {
      "indent": 3,
      "text": "Therefore, implementing reliability signals for these TCP options is not necessary. In order to minimize the impact of the loss of these options, however, it is RECOMMENDED that a sender should send these options on all available subflows. If these options need to be received in order, an implementation SHOULD only send one ADD_ADDR/ REMOVE_ADDR option per RTT, to minimize the risk of misordering.",
      "ja": "したがって、これらのTCPオプションのための信頼性の信号を実装する必要はありません。これらのオプションの損失の影響を最小限にするために、しかし、送信者が使用可能なすべてのサブフローでこれらのオプションを送信することをお勧めします。これらのオプションは、順序で受信する必要がある場合、実装は唯一の誤った順序のリスクを最小限に抑えるために、RTTごとに1 ADD_ADDR / REMOVE_ADDRオプションを送るべきです。"
    },
    {
      "indent": 3,
      "text": "A host can send an ADD_ADDR message with an already assigned Address ID, but the Address MUST be the same as previously assigned to this Address ID, and the Port MUST be different from one already in use for this Address ID. If these conditions are not met, the receiver SHOULD silently ignore the ADD_ADDR. A host wishing to replace an existing Address ID MUST first remove the existing one (Section 3.4.2).",
      "ja": "ホストは、すでに割り当てられたアドレスIDを持つADD_ADDRメッセージを送ることができますが、住所は、以前にこのアドレスIDに割り当てられ、ポートはすでにこのアドレスIDで使用されているものとは異なるでなければならないと同じでなければなりません。これらの条件が満たされない場合、受信機は静かにADD_ADDRを無視する必要があります。既存のアドレスIDを交換したいホストは、まず既存の1（3.4.2）を削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "A host that receives an ADD_ADDR but finds a connection set up to that IP address and port number is unsuccessful SHOULD NOT perform further connection attempts to this address/port combination for this connection. A sender that wants to trigger a new incoming connection attempt on a previously advertised address/port combination can therefore refresh ADD_ADDR information by sending the option again.",
      "ja": "ADD_ADDRを受けたが、そのIPアドレスとポート番号に設定し、接続が失敗した見つけたホストは、この接続のために、このアドレス/ポートの組み合わせに、さらに接続試行を行うべきではありません。以前に広告を出したアドレス/ポートの組み合わせで新しい着信接続試行をトリガーしたい送信者は、したがって、再びオプションを送信することにより、ADD_ADDR情報を更新することができます。"
    },
    {
      "indent": 3,
      "text": "During normal MPTCP operation, it is unlikely that there will be sufficient TCP option space for ADD_ADDR to be included along with those for data sequence numbering (Section 3.3.1). Therefore, it is expected that an MPTCP implementation will send the ADD_ADDR option on separate ACKs. As discussed earlier, however, an MPTCP implementation MUST NOT treat duplicate ACKs with any MPTCP option, with the exception of the DSS option, as indications of congestion [12], and an MPTCP implementation SHOULD NOT send more than two duplicate ACKs in a row for signaling purposes.",
      "ja": "通常MPTCP動作の中には、データシーケンス番号（3.3.1）のものと一緒に含まれるADD_ADDRに十分なTCPオプションのスペースがあるだろうということはほとんどありません。したがって、MPTCPの実装は、別のACKのADD_ADDRオプションを送信することが期待されます。前述したように、しかし、MPTCP実装は混雑[12]の指標として、DSSオプションを除いて、任意MPTCPオプションで重複ACKを治療してはいけません、そしてMPTCP実装が一列に二つ以上の重複ACKを送るべきではありません目的に信号を送るため。"
    },
    {
      "indent": 0,
      "text": "3.4.2. Remove Address",
      "section_title": true,
      "ja": "3.4.2. 住所を削除します"
    },
    {
      "indent": 3,
      "text": "If, during the lifetime of an MPTCP connection, a previously announced address becomes invalid (e.g., if the interface disappears), the affected host SHOULD announce this so that the peer can remove subflows related to this address.",
      "ja": "、MPTCP接続の存続期間中に、以前に発表されたアドレスが無効（例えば、インターフェースが消えている場合）になった場合、ピアは、このアドレスに関連するサブフローを除去することができるように、影響を受けたホストはこれを公表すべきです。"
    },
    {
      "indent": 3,
      "text": "This is achieved through the Remove Address (REMOVE_ADDR) option (Figure 13), which will remove a previously added address (or list of addresses) from a connection and terminate any subflows currently using that address.",
      "ja": "これは、接続から以前に追加されたアドレス（またはアドレスのリスト）を削除し、現在そのアドレスを使用して任意のサブフローを終了します削除アドレス（REMOVE_ADDR）オプション（図13）を介して達成されます。"
    },
    {
      "indent": 3,
      "text": "For security purposes, if a host receives a REMOVE_ADDR option, it must ensure the affected path(s) are no longer in use before it instigates closure. The receipt of REMOVE_ADDR SHOULD first trigger the sending of a TCP keepalive [19] on the path, and if a response is received the path SHOULD NOT be removed. Typical TCP validity tests on the subflow (e.g., ensuring sequence and ACK numbers are correct) MUST also be undertaken. An implementation can use indications of these test failures as part of intrusion detection or error logging.",
      "ja": "ホストがREMOVE_ADDRオプションを受信した場合、セキュリティ上の理由から、それが影響を受けたパス（複数可）を確認する必要があり、それはクロージャを扇動する前に使用されなくなっていません。 REMOVE_ADDRの領収書は、最初のパス上のTCPキープアライブ[19]の送信をトリガする必要があり、応答が受信された場合にパスが除去されるべきではありません。サブフロー（例えば、確保シーケンス及びACK番号が正しい）上の典型的なTCPの有効性試験も実施しなければなりません。実装は、侵入検知やエラーログの一部として、これらのテストの失敗の兆候を使用することができます。"
    },
    {
      "indent": 3,
      "text": "The sending and receipt (if no keepalive response was received) of this message SHOULD trigger the sending of RSTs by both hosts on the affected subflow(s) (if possible), as a courtesy to cleaning up middlebox state, before cleaning up any local state.",
      "ja": "（キープアライブ応答を受信しなかった場合）、このメッセージの送信及び受信は、任意のローカルをクリーンアップする前に、ミドル状態をクリーンアップするサービスの一環として、影響を受けたサブフロー（S）上の両方のホスト（可能な場合）でのRSTの送信をトリガーします状態。"
    },
    {
      "indent": 3,
      "text": "Address removal is undertaken by ID, so as to permit the use of NATs and other middleboxes that rewrite source addresses. If there is no address at the requested ID, the receiver will silently ignore the request.",
      "ja": "NATのソースアドレスを書き換える他のミドルボックスの使用を可能にするように、アドレスの除去は、IDによって行われます。要求されたIDで、何のアドレスが存在しない場合、受信機は静かに要求を無視します。"
    },
    {
      "indent": 3,
      "text": "A subflow that is still functioning MUST be closed with a FIN exchange as in regular TCP, rather than using this option. For more information, see Section 3.3.3.",
      "ja": "まだ機能しているサブフローではなく、このオプションを使用するよりも、通常のTCPのようFIN為替で閉じる必要があります。詳細については、3.3.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------+-------+---------------+\n|     Kind      |  Length = 3+n |Subtype|(resvd)|   Address ID  | ...\n+---------------+---------------+-------+-------+---------------+\n                           (followed by n-1 Address IDs, if required)",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 13: Remove Address (REMOVE_ADDR) Option",
      "ja": "図13：削除住所（REMOVE_ADDR）オプション"
    },
    {
      "indent": 0,
      "text": "3.5. Fast Close",
      "section_title": true,
      "ja": "3.5. 高速閉じます"
    },
    {
      "indent": 3,
      "text": "Regular TCP has the means of sending a reset (RST) signal to abruptly close a connection. With MPTCP, the RST only has the scope of the subflow and will only close the concerned subflow but not affect the remaining subflows. MPTCP's connection will stay alive at the data level, in order to permit break-before-make handover between subflows. It is therefore necessary to provide an MPTCP-level \"reset\" to allow the abrupt closure of the whole MPTCP connection, and this is the MP_FASTCLOSE option.",
      "ja": "定期的なTCPは突然接続を閉じるようにリセット（RST）信号を送信する手段を有しています。 MPTCPで、RSTは、サブフローの範囲を持っており、唯一の懸念サブフローを閉じますが、残りのサブフローには影響しません。 MPTCPの接続は、サブフロー間のブレーク・ビフォア・メークのハンドオーバを可能にするために、データレベルで生き続けるでしょう。全体MPTCP接続の突然の閉鎖を可能にするために「リセット」MPTCPレベルを提供することが必要であり、これはMP_FASTCLOSEオプションです。"
    },
    {
      "indent": 3,
      "text": "MP_FASTCLOSE is used to indicate to the peer that the connection will be abruptly closed and no data will be accepted anymore. The reasons for triggering an MP_FASTCLOSE are implementation specific. Regular TCP does not allow sending a RST while the connection is in a synchronized state [1]. Nevertheless, implementations allow the sending of a RST in this state, if, for example, the operating system is running out of resources. In these cases, MPTCP should send the MP_FASTCLOSE. This option is illustrated in Figure 14.",
      "ja": "MP_FASTCLOSE接続が突然閉鎖されたピアに示すために使用され、データはもはや受け入れられないであろう。 MP_FASTCLOSEをトリガするための理由は、実装固有のものです。定期的なTCP接続が同期状態[1]にあるときにRSTを送信することはできません。それにもかかわらず、実装は例えば、オペレーティングシステムのリソースが不足している場合など、この状態でRSTの送信を許可します。これらのケースでは、MPTCPはMP_FASTCLOSEを送信する必要があります。このオプションは、図14に例示されています。"
    },
    {
      "indent": 7,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------+-----------------------+\n|     Kind      |    Length     |Subtype|      (reserved)       |\n+---------------+---------------+-------+-----------------------+\n|                      Option Receiver's Key                    |\n|                            (64 bits)                          |\n|                                                               |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 14: Fast Close (MP_FASTCLOSE) Option",
      "ja": "図14：高速クローズ（MP_FASTCLOSE）オプション"
    },
    {
      "indent": 3,
      "text": "If Host A wants to force the closure of an MPTCP connection, the MPTCP Fast Close procedure is as follows:",
      "ja": "ホストAがMPTCP接続の閉鎖を強制したい場合は、次のようにMPTCPファスト閉じる手順は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Host A sends an ACK containing the MP_FASTCLOSE option on one subflow, containing the key of Host B as declared in the initial connection handshake. On all the other subflows, Host A sends a regular TCP RST to close these subflows, and tears them down. Host A now enters FASTCLOSE_WAIT state.",
      "ja": "OホストAは、最初の接続ハンドシェイクで宣言され、ホストBのキーを含む、1つのサブフローにMP_FASTCLOSEオプションを含むACKを送信します。他のすべてのサブフローでは、ホストAは、これらのサブフローを閉じるために、通常のTCPのRSTを送信し、それらを切断します。今FASTCLOSE_WAIT状態に入るホスト。"
    },
    {
      "indent": 3,
      "text": "o Upon receipt of an MP_FASTCLOSE, containing the valid key, Host B answers on the same subflow with a TCP RST and tears down all subflows. Host B can now close the whole MPTCP connection (it transitions directly to CLOSED state).",
      "ja": "TCP RSTと同じサブフローに有効なキー、ホストBの答えを含む、すべてのサブフローを切断し、MP_FASTCLOSEを受信すると、O。ホストBは現在、（それがCLOSED状態に直接遷移）全体MPTCP接続を閉じることができます。"
    },
    {
      "indent": 3,
      "text": "o As soon as Host A has received the TCP RST on the remaining subflow, it can close this subflow and tear down the whole connection (transition from FASTCLOSE_WAIT to CLOSED states). If Host A receives an MP_FASTCLOSE instead of a TCP RST, both hosts attempted fast closure simultaneously. Host A should reply with a TCP RST and tear down the connection.",
      "ja": "OとすぐにホストAは、残りのサブフローにTCP RSTを受信したとして、このサブフローを閉じて（CLOSED状態へFASTCLOSE_WAITからの遷移）全接続を切断することができます。ホストAの代わりにTCP RSTのMP_FASTCLOSEを受信した場合、両方のホストが同時に速い閉鎖を試みました。 TCP RSTで応答し、接続を切断する必要がありAをホストします。"
    },
    {
      "indent": 3,
      "text": "o If Host A does not receive a TCP RST in reply to its MP_FASTCLOSE after one retransmission timeout (RTO) (the RTO of the subflow where the MPTCP_RST has been sent), it SHOULD retransmit the MP_FASTCLOSE. The number of retransmissions SHOULD be limited to avoid this connection from being retained for a long time, but this limit is implementation specific. A RECOMMENDED number is 3.",
      "ja": "ホストAが1つの再送タイムアウト（RTO）（MPTCP_RSTが送信されたサブフローのRTO）の後にそのMP_FASTCLOSEへの返信にTCP RSTを受信しない場合は、O、それはMP_FASTCLOSEを再送すべきです。再送回数が長時間保持されることから、この接続を回避するために限定されるべきであるが、この制限は、実装固有のものです。推奨数は3です。"
    },
    {
      "indent": 0,
      "text": "3.6. Fallback",
      "section_title": true,
      "ja": "3.6. 後退する"
    },
    {
      "indent": 3,
      "text": "Sometimes, middleboxes will exist on a path that could prevent the operation of MPTCP. MPTCP has been designed in order to cope with many middlebox modifications (see Section 6), but there are still some cases where a subflow could fail to operate within the MPTCP requirements. These cases are notably the following: the loss of TCP options on a path and the modification of payload data. If such an event occurs, it is necessary to \"fall back\" to the previous, safe operation. This may be either falling back to regular TCP or removing a problematic subflow.",
      "ja": "時には、ミドルボックスはMPTCPの動作を妨げる可能性がパス上に存在します。 MPTCPは、多くのミドルの変更（セクション6を参照）に対応するために設計されていますが、サブフローはMPTCP要件内で動作するように失敗する可能性がありますいくつかのケースが残っています。パス上のTCPオプションの損失とペイロードデータの変更：これらの例は、特に以下のとおりです。このようなイベントが発生した場合、以前、安全な運転に「フォールバック」する必要があります。これは戻って、通常のTCPへの落下や問題のサブフローを取り除くのいずれであってもよいです。"
    },
    {
      "indent": 3,
      "text": "At the start of an MPTCP connection (i.e., the first subflow), it is important to ensure that the path is fully MPTCP capable and the necessary TCP options can reach each host. The handshake as described in Section 3.1 SHOULD fall back to regular TCP if either of the SYN messages do not have the MPTCP options: this is the same, and desired, behavior in the case where a host is not MPTCP capable, or the path does not support the MPTCP options. When attempting to join an existing MPTCP connection (Section 3.2), if a path is not MPTCP capable and the TCP options do not get through on the SYNs, the subflow will be closed according to the MP_JOIN logic.",
      "ja": "MPTCP接続（すなわち、最初のサブフロー）の開始時に、パスが完全MPTCP可能であり、必要なTCPオプションが各ホストに到達できることを確実にするために重要です。 3.1節で説明したようにハンドシェイクがSYNメッセージのいずれかがMPTCPのオプションを持っていない場合は、通常のTCPにフォールバックする必要があります。これは同じであり、希望、行動をする場合には、ホストが可能MPTCPない場合、またはパスがありませんMPTCPオプションをサポートしていません。パスが可能MPTCPされていないと、TCPオプションは、SYNの上を介して取得していない場合は、既存のMPTCP接続（3.2節）に参加しようとすると、サブフローはMP_JOINロジックに従って閉じられます。"
    },
    {
      "indent": 3,
      "text": "There is, however, another corner case that should be addressed. That is one of MPTCP options getting through on the SYN, but not on regular packets. This can be resolved if the subflow is the first subflow, and thus all data in flight is contiguous, using the following rules.",
      "ja": "対処すべき別のコーナーケースは、しかし、があります。それは、SYNのではなく、通常のパケットに通り抜けるMPTCPの選択肢の一つです。サブフローが最初にサブフローであり、したがって、飛行中のすべてのデータは次のルールを使用して、連続している場合、これを解消することができます。"
    },
    {
      "indent": 3,
      "text": "A sender MUST include a DSS option with data sequence mapping in every segment until one of the sent segments has been acknowledged with a DSS option containing a Data ACK. Upon reception of the acknowledgment, the sender has the confirmation that the DSS option passes in both directions and may choose to send fewer DSS options than once per segment.",
      "ja": "送信されたセグメントのいずれかがデータACKを含むDSSオプションで確認応答されるまで、送信者は、各セグメント内のデータの配列マッピングを有するDSSオプションを含まなければなりません。確認応答を受信すると、送信者はDSSオプションが両方向に渡すことの確認を持っており、1セグメントに1よりも少ないDSSのオプションを送信することもできます。"
    },
    {
      "indent": 3,
      "text": "If, however, an ACK is received for data (not just for the SYN) without a DSS option containing a Data ACK, the sender determines the path is not MPTCP capable. In the case of this occurring on an additional subflow (i.e., one started with MP_JOIN), the host MUST close the subflow with a RST. In the case of the first subflow (i.e., that started with MP_CAPABLE), it MUST drop out of an MPTCP mode back to regular TCP. The sender will send one final data sequence mapping, with the Data-Level Length value of 0 indicating an infinite mapping (in case the path drops options in one direction only), and then revert to sending data on the single subflow without any MPTCP options.",
      "ja": "しかし、ACKは、データACKを含むDSSオプションなし（だけでなく、SYNため）データのための受信された場合、送信者は、経路を決定することができるMPTCPされません。この追加のサブフローに発生した場合に（すなわち、一方はMP_JOINで開始）、ホストはRSTとサブフローを閉じる必要があります。 （MP_CAPABLEで開始すなわち、）最初のサブフローの場合には、バック正規TCPにMPTCPモードから脱落しなければなりません。送信者は0のデータレベルの長さ値が無限マッピング（場合パスは一方向のみのオプションをドロップ）を示すと、1つの最終データ列マッピングを送信し、その後、任意MPTCPオプションなしで単一サブフローにデータを送信するに戻ります。"
    },
    {
      "indent": 3,
      "text": "Note that this rule essentially prohibits the sending of data on the third packet of an MP_CAPABLE or MP_JOIN handshake, since both that option and a DSS cannot fit in TCP option space. If the initiator is to send first, another segment must be sent that contains the data and DSS. Note also that an additional subflow cannot be used until the initial path has been verified as MPTCP capable.",
      "ja": "そのオプションとDSSの両方がTCPオプションのスペースに収まることができないため、このルールは基本的にMP_CAPABLEまたはMP_JOINハンドシェイクの3番目のパケットにデータの送信を禁止していることに注意してください。イニシエータが最初に送信する場合、他のセグメントは、データおよびDSSを含有する送られなければなりません。最初のパスが可能MPTCPと確認されるまで、追加のサブフローを使用することができないことにも留意されたいです。"
    },
    {
      "indent": 3,
      "text": "These rules should cover all cases where such a failure could happen: whether it's on the forward or reverse path and whether the server or the client first sends data. If lost options on data packets occur on any other subflow apart from the initial subflow, it should be treated as a standard path failure. The data would not be DATA_ACKed (since there is no mapping for the data), and the subflow can be closed with a RST.",
      "ja": "それは前方にだかどうか、パスを逆にして、サーバーまたはクライアントが最初にデータを送信するかどうか：これらのルールは、このような障害が起こることができるすべてのケースをカバーする必要があります。データパケットの失われたオプションは、最初のサブフローから離れて、他のサブフローに発生した場合、それは標準的なパス障害として扱われるべきです。 （データのマッピングが存在しないため）データがDATA_ACKedされないであろう、及びサブフローはRSTで閉じることができます。"
    },
    {
      "indent": 3,
      "text": "The case described above is a specialized case of fallback, for when the lack of MPTCP support is detected before any data is acknowledged at the connection level on a subflow. More generally, fallback (either closing a subflow, or to regular TCP) can become necessary at any point during a connection if a non-MPTCP-aware middlebox changes the data stream.",
      "ja": "上記の場合は、任意のデータがサブフローに接続レベルで肯定応答される前MPTCPサポートの欠如が検出されたときのために、フォールバックの特殊な場合です。非MPTCP認識ミドルボックスは、データストリームを変更した場合、より一般的には、フォールバックは、（いずれかのサブフローを閉じる、または通常のTCPへの）接続中の任意の時点で必要になることができます。"
    },
    {
      "indent": 3,
      "text": "As described in Section 3.3, each portion of data for which there is a mapping is protected by a checksum. This mechanism is used to detect if middleboxes have made any adjustments to the payload (added, removed, or changed data). A checksum will fail if the data has been changed in any way. This will also detect if the length of data on the subflow is increased or decreased, and this means the data sequence mapping is no longer valid. The sender no longer knows what subflow-level sequence number the receiver is genuinely operating at (the middlebox will be faking ACKs in return), and it cannot signal any further mappings. Furthermore, in addition to the possibility of payload modifications that are valid at the application layer, there is the possibility that false positives could be hit across MPTCP segment boundaries, corrupting the data. Therefore, all data from the start of the segment that failed the checksum onwards is not trustworthy.",
      "ja": "セクション3.3で説明したように、マッピングがされているデータの各部分はチェックサムによって保護されています。この機構は、ミドルボックスは、ペイロード（追加、削除、または変更されたデータ）に任意の調整を行っているかどうかを検出するために使用されます。データが何らかの方法で変更された場合、チェックサムが失敗します。サブフロー上のデータの長さが増減し、これは、データ系列のマッピングがもはや有効でないことを意味している場合にも検出されます。送信者は、もはや何のサブフローレベルのシーケンス番号を知っている受信機は、本当に（ミドルリターンでACKを偽造されます）で動作していない、それはそれ以上のマッピングを通知することはできません。また、アプリケーション層での有効なペイロード・変更の可能性に加えて、偽陽性は、データを破損、MPTCPセグメント境界を越えて打つことができる可能性があります。したがって、以降のチェックサムが失敗したセグメントの開始からのすべてのデータが信頼できないです。"
    },
    {
      "indent": 3,
      "text": "When multiple subflows are in use, the data in flight on a subflow will likely involve data that is not contiguously part of the connection-level stream, since segments will be spread across the multiple subflows. Due to the problems identified above, it is not possible to determine what the adjustment has done to the data (notably, any changes to the subflow sequence numbering). Therefore, it is not possible to recover the subflow, and the affected subflow must be immediately closed with a RST, featuring an MP_FAIL option (Figure 15), which defines the data sequence number at the start of the segment (defined by the data sequence mapping) that had the checksum failure. Note that the MP_FAIL option requires the use of the full 64-bit sequence number, even if 32-bit sequence numbers are normally in use in the DSS signals on the path.",
      "ja": "複数のサブフローが使用されているときにセグメントが複数のサブフローに分散されるので、サブフローに飛行中のデータは、おそらく、連続接続レベルのストリームの一部ではないデータを含むであろう。上記特定された問題のために、調整データに行っているかを決定することは不可能である（特に、サブフロー配列番号への変更）。したがって、サブフローを回復することは不可能であり、影響を受けたサブフローが直ちにセグメントの開始時にデータのシーケンス番号を定義MP_FAILオプション（図15）、特徴、RSTで閉じなければならない（データ配列によって定義されますマッピング）チェックサム障害を持っていました。 MP_FAILオプションは、32ビットのシーケンス番号は、経路上のDSS信号に使用で正常であっても、完全な64ビットのシーケンス番号の使用を必要とすることに留意されたいです。"
    },
    {
      "indent": 6,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+-------+----------------------+\n|     Kind      |   Length=12   |Subtype|      (reserved)      |\n+---------------+---------------+-------+----------------------+\n|                                                              |\n|                 Data Sequence Number (8 octets)              |\n|                                                              |\n+--------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 15: Fallback (MP_FAIL) Option",
      "ja": "図15：フォールバック（MP_FAIL）オプション"
    },
    {
      "indent": 3,
      "text": "The receiver MUST discard all data following the data sequence number specified. Failed data MUST NOT be DATA_ACKed and so will be retransmitted on other subflows (Section 3.3.6).",
      "ja": "受信機は、指定されたデータのシーケンス番号以下のすべてのデータを捨てなければなりません。失敗したデータはDATA_ACKedてはならないので、他のサブフロー（3.3.6）で再送信されます。"
    },
    {
      "indent": 3,
      "text": "A special case is when there is a single subflow and it fails with a checksum error. If it is known that all unacknowledged data in flight is contiguous (which will usually be the case with a single subflow), an infinite mapping can be applied to the subflow without the need to close it first, and essentially turn off all further MPTCP signaling. In this case, if a receiver identifies a checksum failure when there is only one path, it will send back an MP_FAIL option on the subflow-level ACK, referring to the data-level sequence number of the start of the segment on which the checksum error was detected. The sender will receive this, and if all unacknowledged data in flight is contiguous, will signal an infinite mapping. This infinite mapping will be a DSS option (Section 3.3) on the first new packet, containing a data sequence mapping that acts retroactively, referring to the start of the subflow sequence number of the last segment that was known to be delivered intact. From that point onwards, data can be altered by a middlebox without affecting MPTCP, as the data stream is equivalent to a regular, legacy TCP session.",
      "ja": "そこ単一サブフローであり、それはチェックサムエラーで失敗した場合、特殊なケースです。 （これは通常、単一のサブフローの場合であろう）飛行中の全ての未確認のデータが連続していることが知られている場合には、無限のマッピングは最初にそれを閉じ、そして本質的にすべてのさらなるMPTCPシグナリングをオフにする必要なく、サブフローに適用することができます。唯一のパスが存在する場合、受信機は、チェックサムエラーを識別する場合、この場合、それは上のチェックサムセグメントの先頭のデータレベルのシーケンス番号を参照し、サブフローレベルACKでMP_FAILオプションを送り返しますエラーが検出されました。送信者は、これを受信すると、飛行中のすべての未確認のデータが連続している場合には、無限のマッピングを通知します。この無限のマッピングはそのまま配信することが知られていた最後のセグメントのサブフローシーケンス番号の開始を参照して、遡及的に作用するデータシーケンスのマッピングを含む、最初の新しいパケットにDSSオプション（セクション3.3）であろう。データ・ストリームは、通常、従来のTCPセッションと同等であるとして、その時点からは、データは、MPTCPに影響を与えることなく、ミドルによって変更することができます。"
    },
    {
      "indent": 3,
      "text": "In the rare case that the data is not contiguous (which could happen when there is only one subflow but it is retransmitting data from a subflow that has recently been uncleanly closed), the receiver MUST close the subflow with a RST with MP_FAIL. The receiver MUST discard all data that follows the data sequence number specified. The sender MAY attempt to create a new subflow belonging to the same connection, and, if it chooses to do so, SHOULD place the single subflow immediately in single-path mode by setting an infinite data sequence mapping. This mapping will begin from the data-level sequence number that was declared in the MP_FAIL.",
      "ja": "データは（そこだけサブフローであるが、それは最近uncleanly閉じられたサブフローからデータを再送信されたときに起こる可能性がある）、連続していない稀な場合には、受信機はMP_FAILとRSTとサブフローを閉じる必要があります。受信機は、指定されたデータのシーケンス番号を、以下のすべてのデータを捨てなければなりません。送信者は、同じ接続に属する新しいサブフローを作成しようとするかもしれない、と、それがそうすることを選択した場合、無限のデータ系列のマッピングを設定することにより、単一パス・モードでは、すぐに単一サブフローを配置する必要があります。このマッピングはMP_FAILで宣言されたデータレベルのシーケンス番号から開始します。"
    },
    {
      "indent": 3,
      "text": "After a sender signals an infinite mapping, it MUST only use subflow ACKs to clear its send buffer. This is because Data ACKs may become misaligned with the subflow ACKs when middleboxes insert or delete data. The receive SHOULD stop generating Data ACKs after it receives an infinite mapping.",
      "ja": "送信者が無限のマッピングを通知した後、それだけでその送信バッファをクリアするサブフローACKを使用しなければなりません。ミドルボックスは、データを挿入または削除すると、データACKがサブフローのACKとのずれになる可能性があるためです。それは無限のマッピングを受けた後、受信データのACKの生成を停止すべきです。"
    },
    {
      "indent": 3,
      "text": "When a connection has fallen back, only one subflow can send data; otherwise, the receiver would not know how to reorder the data. In practice, this means that all MPTCP subflows will have to be terminated except one. Once MPTCP falls back to regular TCP, it MUST NOT revert to MPTCP later in the connection.",
      "ja": "接続が戻って低下した場合には、一つだけサブフローは、データを送信することができます。そうでない場合、受信機は、データを並べ替える方法を知ることはできません。実際には、これはすべてのMPTCPのサブフローが1以外に終了されなければならないことを意味します。 MPTCPが戻って通常のTCPに落ちたら、それが関連して、後でMPTCPに戻りてはなりません。"
    },
    {
      "indent": 3,
      "text": "It should be emphasized that we are not attempting to prevent the use of middleboxes that want to adjust the payload. An MPTCP-aware middlebox could provide such functionality by also rewriting checksums.",
      "ja": "我々がペイロードを調整するミドルボックスの使用を防止しようとしていないことを強調すべきです。 MPTCP対応のミドルもチェックサムを書き換えることにより、このような機能を提供することができます。"
    },
    {
      "indent": 0,
      "text": "3.7. Error Handling",
      "section_title": true,
      "ja": "3.7. エラー処理"
    },
    {
      "indent": 3,
      "text": "In addition to the fallback mechanism as described above, the standard classes of TCP errors may need to be handled in an MPTCP-specific way. Note that changing semantics -- such as the relevance of a RST -- are covered in Section 4. Where possible, we do not want to deviate from regular TCP behavior.",
      "ja": "上述したように、フォールバック機構に加えて、TCP誤差の標準クラスはMPTCP固有の方法で処理する必要があるかもしれません。このようRSTの関連性など -   - セクション4で覆われている可能な限り、我々は通常のTCPの挙動から逸脱しないように変更する意味があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The following list covers possible errors and the appropriate MPTCP behavior:",
      "ja": "以下のリストは、エラーの可能性と適切なMPTCPの動作を説明します。"
    },
    {
      "indent": 3,
      "text": "o Unknown token in MP_JOIN (or HMAC failure in MP_JOIN ACK, or missing MP_JOIN in SYN/ACK response): send RST (analogous to TCP's behavior on an unknown port)",
      "ja": "O不明MP_JOINトークン（またはMP_JOIN ACKでHMACの故障、またはSYN / ACK応答で行方不明MP_JOIN）：（不明なポート上のTCPの挙動に類似）RSTを送信"
    },
    {
      "indent": 3,
      "text": "o DSN out of window (during normal operation): drop the data, do not send Data ACKs",
      "ja": "（通常動作時）窓の外DSN O：データACKを送信しない、データをドロップ"
    },
    {
      "indent": 3,
      "text": "o Remove request for unknown address ID: silently ignore",
      "ja": "O未知のアドレスIDの要求を削除します。黙って無視"
    },
    {
      "indent": 0,
      "text": "3.8. Heuristics",
      "section_title": true,
      "ja": "3.8. ヒューリスティック"
    },
    {
      "indent": 3,
      "text": "There are a number of heuristics that are needed for performance or deployment but that are not required for protocol correctness. In this section, we detail such heuristics. Note that discussion of buffering and certain sender and receiver window behaviors are presented in Sections 3.3.4 and 3.3.5, as well as retransmission in Section 3.3.6.",
      "ja": "パフォーマンスや展開のためではなく、プロトコルの正しさのために必要とされていないことを必要としている経験則がいくつかあります。このセクションでは、詳細なヒューリスティックを我々。バッファリングと、特定の送信者と受信者のウィンドウの動作の議論は3.3.6で、セクション3.3.4と3.3.5で提示だけでなく、再送信されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.8.1. Port Usage",
      "section_title": true,
      "ja": "3.8.1. ポートの使用"
    },
    {
      "indent": 3,
      "text": "Under typical operation, an MPTCP implementation SHOULD use the same ports as already in use. In other words, the destination port of a SYN containing an MP_JOIN option SHOULD be the same as the remote port of the first subflow in the connection. The local port for such SYNs SHOULD also be the same as for the first subflow (and as such, an implementation SHOULD reserve ephemeral ports across all local IP addresses), although there may be cases where this is infeasible. This strategy is intended to maximize the probability of the SYN being permitted by a firewall or NAT at the recipient and to avoid confusing any network monitoring software.",
      "ja": "典型的な動作では、MPTCP実装がすでに使用中と同じポートを使用すべきです。換言すれば、MP_JOINオプションを含むSYNの宛先ポートは、接続の最初のサブフローのリモートポートと同じでなければなりません。これが不可能である場合もあるが、このようなSYNのためのローカルポートはまた、最初のサブフローの場合と同じであるべきである（そのようなものとして、実装がすべてのローカルIPアドレスを横切っエフェメラルポートを予約する必要があります）。この戦略は、受信者にファイアウォールやNATによって許可されていると、任意のネットワーク監視ソフトウェアを混乱を避けるためにSYNの確率を最大化することを意図しています。"
    },
    {
      "indent": 3,
      "text": "There may also be cases, however, where the passive opener wishes to signal to the other host that a specific port should be used, and this facility is provided in the Add Address option as documented in Section 3.4.1. It is therefore feasible to allow multiple subflows between the same two addresses but using different port pairs, and such a facility could be used to allow load balancing within the network based on 5-tuples (e.g., some ECMP implementations [7]).",
      "ja": "パッシブオープナーは、特定のポートを使用する必要があり、他のホストに合図したい、と3.4.1項に記述されているように、この施設がアドレスの追加オプションで提供される場合にも、しかし、ケースがあるかもしれません。これは、同じ2つのアドレスが異なるポートのペアを使用して、間に複数のサブフローを許可することが可能であり、そのような施設は、5タプルに基づいて、ネットワーク内の負荷分散を可能にするために使用することができる（例えば、いくつかのECMP実装[7]）。"
    },
    {
      "indent": 0,
      "text": "3.8.2. Delayed Subflow Start",
      "section_title": true,
      "ja": "3.8.2. 遅延サブフロースタート"
    },
    {
      "indent": 3,
      "text": "Many TCP connections are short-lived and consist only of a few segments, and so the overheads of using MPTCP outweigh any benefits. A heuristic is required, therefore, to decide when to start using additional subflows in an MPTCP connection. We expect that experience gathered from deployments will provide further guidance on this, and will be affected by particular application characteristics (which are likely to change over time). However, a suggested general-purpose heuristic that an implementation MAY choose to employ is as follows. Results from experimental deployments are needed in order to verify the correctness of this proposal.",
      "ja": "多くのTCP接続は短命であり、わずか数のセグメントから構成され、そのためMPTCPを使用してのオーバーヘッドが任意の利益を上回ります。ヒューリスティックはMPTCP接続で追加のサブフローの使用を開始するタイミングを決定し、そのため、必要になります。私たちは経験が展開から集められたが、これについての更なるガイダンスを提供し、（時間とともに変化する可能性がある）、特定のアプリケーションの特性によって影響されることを期待しています。ただし、次のように実装が使用することを選ぶかもしれ示唆した汎用ヒューリスティックがあります。実験的な展開の結果は、この提案の正しさを検証するために必要とされています。"
    },
    {
      "indent": 3,
      "text": "If a host has data buffered for its peer (which implies that the application has received a request for data), the host opens one subflow for each initial window's worth of data that is buffered.",
      "ja": "ホストが（アプリケーションがデータの要求を受信したことを意味する）、そのピアのバッファされたデータがある場合、ホストは、バッファされたデータの各初期ウィンドウの価値のための1つのサブフローを開きます。"
    },
    {
      "indent": 3,
      "text": "Consideration should also be given to limiting the rate of adding new subflows, as well as limiting the total number of subflows open for a particular connection. A host may choose to vary these values based on its load or knowledge of traffic and path characteristics.",
      "ja": "考慮すべきことは、新しいサブフローを追加するだけでなく、特定の接続のためのオープンサブフローの総数を制限する速度を制限するに与えられるべきです。ホストは、トラフィック及び経路特性のその負荷や知識に基づいて、これらの値を変更することを選択することができます。"
    },
    {
      "indent": 3,
      "text": "Note that this heuristic alone is probably insufficient. Traffic for many common applications, such as downloads, is highly asymmetric and the host that is multihomed may well be the client that will never fill its buffers, and thus never use MPTCP. Advanced APIs that allow an application to signal its traffic requirements would aid in these decisions.",
      "ja": "これだけでヒューリスティックはおそらく不十分であることに注意してください。トラフィックは、このようなダウンロードなど、多くの一般的な用途のために、非常に非対称で、マルチホームホストはよくそのバッファを埋めることはありませんので、MPTCPを使用することはありませんクライアントかもしれません。そのトラフィック要件を通知するためのアプリケーションがこれらの決定に役立つでしょう許可高度なAPIを。"
    },
    {
      "indent": 3,
      "text": "An additional time-based heuristic could be applied, opening additional subflows after a given period of time has passed. This would alleviate the above issue, and also provide resilience for low-bandwidth but long-lived applications.",
      "ja": "追加の時間ベースのヒューリスティックは、一定時間が経過した後に追加のサブフローを開く、適用することができます。これは、上記の問題を軽減し、また、低帯域幅が、長寿命アプリケーションに弾力性を提供します。"
    },
    {
      "indent": 3,
      "text": "This section has shown some of the considerations that an implementer should give when developing MPTCP heuristics, but is not intended to be prescriptive.",
      "ja": "このセクションでは、MPTCPのヒューリスティックを開発する際、実装は与えるべき検討事項のいくつかを示しているが、規範的であることを意図したものではありません。"
    },
    {
      "indent": 0,
      "text": "3.8.3. Failure Handling",
      "section_title": true,
      "ja": "3.8.3. 障害処理"
    },
    {
      "indent": 3,
      "text": "Requirements for MPTCP's handling of unexpected signals have been given in Section 3.7. There are other failure cases, however, where a hosts can choose appropriate behavior.",
      "ja": "予想外の信号のMPTCPの取り扱いに関する要件は、セクション3.7で与えられています。ホストが適切な行動を選択することができる場所、他の障害の場合は、しかし、があります。"
    },
    {
      "indent": 3,
      "text": "For example, Section 3.1 suggests that a host SHOULD fall back to trying regular TCP SYNs after one or more failures of MPTCP SYNs for a connection. A host may keep a system-wide cache of such information, so that it can back off from using MPTCP, firstly for that particular destination host, and eventually on a whole interface, if MPTCP connections continue failing.",
      "ja": "たとえば、3.1節では、ホストが接続するためのMPTCP SYNの1つの以上の障害後に通常のTCPのSYNのを試しにフォールバックすべきであることを示唆しています。それはMPTCPを使用してから後退することができるようにMPTCP接続が失敗し続ける場合、ホストは、まずその特定の宛先ホストのために、最終的に全体のインターフェイス上で、このような情報のシステム全体のキャッシュを維持することができます。"
    },
    {
      "indent": 3,
      "text": "Another failure could occur when the MP_JOIN handshake fails. Section 3.7 specifies that an incorrect handshake MUST lead to the subflow being closed with a RST. A host operating an active intrusion detection system may choose to start blocking MP_JOIN packets from the source host if multiple failed MP_JOIN attempts are seen. From the connection initiator's point of view, if an MP_JOIN fails, it SHOULD NOT attempt to connect to the same IP address and port during the lifetime of the connection, unless the other host refreshes the information with another ADD_ADDR option. Note that the ADD_ADDR option is informational only, and does not guarantee the other host will attempt a connection.",
      "ja": "MP_JOINハンドシェイクが失敗したときに別の障害が発生する可能性があります。 3.7節では、誤った握手がRSTで閉鎖されているサブフローにつながる必要があることを指定します。アクティブ侵入検知システムを動作させるホストが複数のMP_JOINの試みが見られなかった場合、ソースホストからMP_JOINパケットをブロック開始することを選択することができます。 MP_JOINが失敗した場合、他のホストが別ADD_ADDRオプションを指定して情報を更新しない限り、ビューの接続イニシエータの観点から、それは、接続の存続期間中に同じIPアドレスとポートに接続するように試みるべきではありません。 ADD_ADDRオプションは情報のみであり、他のホストが接続を試みます保証するものではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "In addition, an implementation may learn, over a number of connections, that certain interfaces or destination addresses consistently fail and may default to not trying to use MPTCP for these. Behavior could also be learned for particularly badly performing subflows or subflows that regularly fail during use, in order to temporarily choose not to use these paths.",
      "ja": "また、実装は、特定のインターフェイスまたは宛先アドレスが一貫して失敗すると、これらのためMPTCPを使用しようとしないようにデフォルトことを、接続数にわたって、学習することができます。行動は、特にひどく、一時的にこれらのパスを使用しないことを選択するために、定期的に使用中に失敗サブフローまたはサブフローを実行するために学ぶことができました。"
    },
    {
      "indent": 0,
      "text": "4. Semantic Issues",
      "section_title": true,
      "ja": "4.セマンティック問題"
    },
    {
      "indent": 3,
      "text": "In order to support multipath operation, the semantics of some TCP components have changed. To aid clarity, this section collects these semantic changes as a reference.",
      "ja": "マルチパス操作をサポートするために、いくつかのTCPコンポーネントのセマンティクスが変更されました。明瞭性を支援するために、このセクションでは、参照としてこれらのセマンティックの変更を収集します。"
    },
    {
      "indent": 3,
      "text": "Sequence number: The (in-header) TCP sequence number is specific to the subflow. To allow the receiver to reorder application data, an additional data-level sequence space is used. In this data-level sequence space, the initial SYN and the final DATA_FIN occupy 1 octet of sequence space. There is an explicit mapping of data sequence space to subflow sequence space, which is signaled through TCP options in data packets.",
      "ja": "配列番号：（インヘッダ）TCPシーケンス番号がサブフローに特異的です。受信機は、アプリケーションデータを並べ替えることができるように、追加のデータ・レベル・シーケンス・スペースが使用されています。このデータレベルの配列空間において、初期SYNおよび最終DATA_FINは、配列空間の1つのオクテットを占めます。データパケット内のTCPオプションを通知されサブフローシーケンス空間にデータ系列スペースの明示的なマッピングがあります。"
    },
    {
      "indent": 3,
      "text": "ACK: The ACK field in the TCP header acknowledges only the subflow sequence number, not the data-level sequence space. Implementations SHOULD NOT attempt to infer a data-level acknowledgment from the subflow ACKs. This separates subflow- and connection-level processing at an end host.",
      "ja": "ACK：TCPヘッダ内のACKフィールドは、サブフローシーケンス番号ではなく、データレベルの配列空間を認めます。実装は、サブフローのACKからデータレベルの確認応答を推測するために試みるべきではありません。これは、エンドホストでsubflow-と接続レベルの処理を分離します。"
    },
    {
      "indent": 3,
      "text": "Duplicate ACK: A duplicate ACK that includes any MPTCP signaling (with the exception of the DSS option) MUST NOT be treated as a signal of congestion. To limit the chances of non-MPTCP-aware entities mistakenly interpreting duplicate ACKs as a signal of congestion, MPTCP SHOULD NOT send more than two duplicate ACKs containing (non-DSS) MPTCP signals in a row.",
      "ja": "（DSSオプションを除く）任意MPTCPシグナリングを含む輻輳信号として扱われてはいけません重複ACK：ACKが重複。誤っ輻輳の信号として重複ACKを解釈非MPTCP対応エンティティの可能性を制限するために、MPTCPは、行の（非DSS）MPTCP信号を含む二つ以上の重複ACKを送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "Receive Window: The receive window in the TCP header indicates the amount of free buffer space for the whole data-level connection (as opposed to for this subflow) that is available at the receiver. This is the same semantics as regular TCP, but to maintain these semantics the receive window must be interpreted at the sender as relative to the sequence number given in the DATA_ACK rather than the subflow ACK in the TCP header. In this way, the original flow control role is preserved. Note that some middleboxes may change the receive window, and so a host SHOULD use the maximum value of those recently seen on the constituent subflows for the connection-level receive window, and also needs to maintain a subflow-level window for subflow-level processing.",
      "ja": "受信ウィンドウ：TCPヘッダ内のウィンドウを受信する受信機で利用可能である（このサブフローのためではなく）全データレベルの接続のためのフリーバッファスペースの量を示します。これは、通常のTCPと同じ意味であるが、受信ウィンドウがDATA_ACKなくTCPヘッダ内のサブフローACKで示される配列の数に対するとして送信側で解釈されなければならないこれらのセマンティクスを維持します。このように、元のフロー制御の役割は維持されます。いくつかの中間装置は、受信ウィンドウを変更してもよいことに留意されたい、などホストが接続レベルの構成サブフローで最近見られるの最大値を使用する必要があり、ウィンドウを受信し、またサブフローレベルの処理のためのサブフローレベルウィンドウを維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "FIN: The FIN flag in the TCP header applies only to the subflow it is sent on, not to the whole connection. For connection-level FIN semantics, the DATA_FIN option is used.",
      "ja": "FIN：TCPヘッダ内のFINフラグは、それだけではなく全体の接続に、上で送信されるサブフローに適用されます。接続レベルFINセマンティクスについては、DATA_FINオプションが使用されています。"
    },
    {
      "indent": 3,
      "text": "RST: The RST flag in the TCP header applies only to the subflow it is sent on, not to the whole connection. The MP_FASTCLOSE option provides the fast close functionality of a RST at the MPTCP connection level.",
      "ja": "RST：TCPヘッダーのRSTフラグは、それが全体ではなく、接続に、上で送信されるサブフローに適用されます。 MP_FASTCLOSEオプションはMPTCP接続レベルでのRSTの速い近い機能を提供します。"
    },
    {
      "indent": 3,
      "text": "Address List: Address list management (i.e., knowledge of the local and remote hosts' lists of available IP addresses) is handled on a per-connection basis (as opposed to per subflow, per host, or per pair of communicating hosts). This permits the application of per-connection local policy. Adding an address to one connection (either explicitly through an Add Address message, or implicitly through a Join) has no implication for other connections between the same pair of hosts.",
      "ja": "アドレスリスト（ホストごと、またはホスト通信のペアごと、サブフローごとではなく）アドレスリスト管理（すなわち、利用可能なIPアドレスのローカルおよびリモートホストのリストの知識）を接続ごとに処理されます。これは、接続ごとのローカルポリシーの適用が可能となります。 （明示的に追加アドレス・メッセージを介して、または暗黙的に参加を介して）一つの接続にアドレスを追加すると、ホストの同一の対の間の他の接続のための含意を有していません。"
    },
    {
      "indent": 3,
      "text": "5-tuple: The 5-tuple (protocol, local address, local port, remote address, remote port) presented by kernel APIs to the application layer in a non-multipath-aware application is that of the first subflow, even if the subflow has since been closed and removed from the connection. This decision, and other related API issues, are discussed in more detail in [6].",
      "ja": "5タプル：非マルチパスに対応するアプリケーションのアプリケーション層にカーネルAPIによって提示される5タプル（プロトコル、ローカルアドレス、ローカルポート、リモートアドレス、リモートポート）サブフローとしても、最初のサブフローのものです以来、接続から閉じられ、削除されました。この決定、およびその他の関連するAPIの問題は、[6]で詳しく説明されています。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "As identified in [9], the addition of multipath capability to TCP will bring with it a number of new classes of threat. In order to prevent these, [2] presents a set of requirements for a security solution for MPTCP. The fundamental goal is for the security of MPTCP to be \"no worse\" than regular TCP today, and the key security requirements are:",
      "ja": "[9]で識別される、TCPへのマルチパス機能の追加は、それを脅威の新しいクラスの数をもたらすでしょう。これらを防ぐために、[2] MPTCPのためのセキュリティソリューションのための要件のセットを提示します。基本的な目標は、今日、通常のTCPよりも「悪くない」ことがないようにMPTCPの安全のためであり、主要なセキュリティ要件は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Provide a mechanism to confirm that the parties in a subflow handshake are the same as in the original connection setup.",
      "ja": "Oサブフロー握手で当事者が、元の接続設定と同じであることを確認するためのメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "o Provide verification that the peer can receive traffic at a new address before using it as part of a connection.",
      "ja": "Oピアが接続の一部としてそれを使用する前に、新しいアドレスでトラフィックを受信することができ、検証を提供します。"
    },
    {
      "indent": 3,
      "text": "o Provide replay protection, i.e., ensure that a request to add/ remove a subflow is 'fresh'.",
      "ja": "Oすなわち、サブフローを追加/削除する要求は、「新鮮な」であることを確認し、再生保護を提供します。"
    },
    {
      "indent": 3,
      "text": "In order to achieve these goals, MPTCP includes a hash-based handshake algorithm documented in Sections 3.1 and 3.2.",
      "ja": "これらの目標を達成するために、MPTCPは、セクション3.1および3.2に記載ハッシュベースのハンドシェイクアルゴリズムを含みます。"
    },
    {
      "indent": 3,
      "text": "The security of the MPTCP connection hangs on the use of keys that are shared once at the start of the first subflow, and are never sent again over the network (unless used in the fast close mechanism, Section 3.5). To ease demultiplexing while not giving away any cryptographic material, future subflows use a truncated cryptographic hash of this key as the connection identification \"token\". The keys are concatenated and used as keys for creating Hash-based Message Authentication Codes (HMACs) used on subflow setup, in order to verify that the parties in the handshake are the same as in the original connection setup. It also provides verification that the peer can receive traffic at this new address. Replay attacks would still be possible when only keys are used; therefore, the handshakes use single-use random numbers (nonces) at both ends -- this ensures the HMAC will never be the same on two handshakes. Guidance on generating random numbers suitable for use as keys is given in [14] and discussed in Section 3.1.",
      "ja": "MPTCP接続のセキュリティは、最初のサブフローの開始時に一度に共有されるキーの使用にハングアップ、および（高速開閉機構、3.5節で使用していない限り）、ネットワークを介して再び送信されることはありません。任意の暗号化材料を配っていない間分離を容易にするために、将来のサブフローは、接続識別「トークン」としてこのキーの短縮暗号化ハッシュを使用します。キーは（HMACs）ハッシュベースのメッセージ認証コードを作成するためのキーとして連結して使用されるハンドシェークにおける当事者が、元の接続設定と同じであることを確認するために、サブフロー設定に使用されます。また、ピアがこの新しいアドレスでトラフィックを受信できることを確認します。キーのみが使用されるときにリプレイ攻撃はまだ可能です。そのため、ハンドシェイクは、両端に使い捨ての乱数（ナンス）を使用する - これはHMACは、2つのハンドシェイクで同じになることはありません保証します。キーとして使用するのに適した乱数を生成ガイダンスは、[14]で与えられ、セクション3.1で議論されています。"
    },
    {
      "indent": 3,
      "text": "The use of crypto capability bits in the initial connection handshake to negotiate use of a particular algorithm allows the deployment of additional crypto mechanisms in the future. Note that this would be susceptible to bid-down attacks only if the attacker was on-path (and thus would be able to modify the data anyway). The security mechanism presented in this document should therefore protect against all forms of flooding and hijacking attacks discussed in [9].",
      "ja": "特定のアルゴリズムの使用を交渉するための最初の接続ハンドシェイクにおける暗号能力ビットを使用することは、将来の追加の暗号メカニズムの展開を可能にします。これは、攻撃者が（したがって、とにかくデータを変更することができるだろう）にパスした場合にのみ、入札ダウンする攻撃を受けやすくなることに注意してください。この文書のセキュリティメカニズムは、したがって、[9]で議論洪水やハイジャック攻撃のすべてのフォームから保護すべきです。"
    },
    {
      "indent": 3,
      "text": "During normal operation, regular TCP protection mechanisms (such as ensuring sequence numbers are in-window) will provide the same level of protection against attacks on individual TCP subflows as exists for regular TCP today. Implementations will introduce additional buffers compared to regular TCP, to reassemble data at the connection level. The application of window sizing will minimize the risk of denial-of-service attacks consuming resources.",
      "ja": "通常動作時には、通常のTCPの保護メカニズム（例えばシーケンス番号を確保するようにして、窓あり）は本日、通常のTCPのために存在するように、個々のTCPのサブフローへの攻撃に対して同じレベルの保護を提供します。実装は、接続レベルでデータを再構築するために、通常のTCPに比べて、追加のバッファをご紹介します。ウィンドウのサイズ変更の適用は、リソースを消費するサービス拒否攻撃のリスクを最小限に抑えることができます。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 3.4.1, a host may advertise its private addresses, but these might point to different hosts in the receiver's network. The MP_JOIN handshake (Section 3.2) will ensure that this does not succeed in setting up a subflow to the incorrect host. However, it could still create unwanted TCP handshake traffic. This feature of MPTCP could be a target for denial-of-service exploits, with malicious participants in MPTCP connections encouraging the recipient to target other hosts in the network. Therefore, implementations should consider heuristics (Section 3.8) at both the sender and receiver to reduce the impact of this.",
      "ja": "3.4.1項で述べたように、ホストは、そのプライベートアドレスを広告するが、これらは、受信者のネットワーク内の別のホストに指している可能性があります。 MP_JOINハンドシェイク（3.2節）が、これは間違ったホストにサブフローを設定することに成功していないことを保証します。しかし、それはまだ不要なTCPハンドシェイクのトラフィックを作成することができます。 MPTCPのこの機能は、MPTCP接続で悪質な参加者がネットワーク内の他のホストを対象とする受信者を奨励し、サービス拒否の攻撃のターゲットである可能性があります。したがって、実装は、この影響を低減するために送信側と受信側の両方でヒューリスティックス（セクション3.8）を考慮すべきです。"
    },
    {
      "indent": 3,
      "text": "A small security risk could theoretically exist with key reuse, but in order to accomplish a replay attack, both the sender and receiver keys, and the sender and receiver random numbers, in the MP_JOIN handshake (Section 3.2) would have to match.",
      "ja": "小さなセキュリティリスクは、理論的に一致しなければならないMP_JOINハンドシェイク（3.2節）には、送信者と受信者のキー、および送信者と受信者のランダムな数字の両方をキー再利用して存在するが、リプレイ攻撃を達成するために可能性があります。"
    },
    {
      "indent": 3,
      "text": "Whilst this specification defines a \"medium\" security solution, meeting the criteria specified at the start of this section and the threat analysis ([9]), since attacks only ever get worse, it is likely that a future Standards Track version of MPTCP would need to be able to support stronger security. There are several ways the security of MPTCP could potentially be improved; some of these would be compatible with MPTCP as defined in this document, whilst others may not be. For now, the best approach is to get experience with the current approach, establish what might work, and check that the threat analysis is still accurate.",
      "ja": "この仕様は、このセクションの開始時に指定した基準と脅威分析を満たす「中」セキュリティソリューションを、定義しながら、攻撃は唯一これまで悪化するので（[9]）、それはMPTCPの将来の標準化過程のバージョン可能性があるだろう強力なセキュリティをサポートできるようにする必要があります。 MPTCPのセキュリティは、潜在的に改善することができるいくつかの方法があります。この文書で定義されている他の人ができない場合がありながら、これらのいくつかは、MPTCPと互換性があるでしょう。今のところ、最良のアプローチは、現在のアプローチと経験を得る働くかもしれないものの確立、および脅威分析がまだ正確であることを確認することです。"
    },
    {
      "indent": 3,
      "text": "Possible ways of improving MPTCP security could include:",
      "ja": "MPTCPのセキュリティを向上させることの可能な方法は含めることができます："
    },
    {
      "indent": 3,
      "text": "o defining a new MPCTP cryptographic algorithm, as negotiated in MP_CAPABLE. A sub-case could be to include an additional deployment assumption, such as stateful servers, in order to allow a more powerful algorithm to be used.",
      "ja": "MP_CAPABLEで交渉としてO、新しいMPCTP暗号アルゴリズムを定義します。サブケースは、より強力なアルゴリズムが使用されることを可能にするために、ステートフルサーバなどの追加的な展開を前提に、含めることである可能性があります。"
    },
    {
      "indent": 3,
      "text": "o defining how to secure data transfer with MPTCP, whilst not changing the signaling part of the protocol.",
      "ja": "Oプロトコルのシグナリング部分を変更しない一方、MPTCPとの間のデータ転送を確保する方法を定義します。"
    },
    {
      "indent": 3,
      "text": "o defining security that requires more option space, perhaps in conjunction with a \"long options\" proposal for extending the TCP options space (such as those surveyed in [20]), or perhaps building on the current approach with a second stage of MPTCP-option-based security.",
      "ja": "おそらく（例えば、[20]に回答者のような）TCPオプションのスペースを拡張するための「長いオプション」の提案に関連して、より多くのオプションのスペースを必要とするセキュリティを定義する、または恐らくMPTCP-の第二段階で、現在のアプローチに構築Oオプションベースのセキュリティ。"
    },
    {
      "indent": 3,
      "text": "o revisiting the working group's decision to exclusively use TCP options for MPTCP signaling, and instead look at also making use of the TCP payloads.",
      "ja": "専用のMPTCPシグナリングのためにTCPオプションを使用するには、ワーキンググループの決定を再検討し、代わりにもTCPペイロードを利用することを見て、O。"
    },
    {
      "indent": 3,
      "text": "MPTCP has been designed with several methods available to indicate a new security mechanism, including:",
      "ja": "MPTCPには、新しいセキュリティ・メカニズムを示すために利用できるいくつかの方法で設計されています："
    },
    {
      "indent": 3,
      "text": "o available flags in MP_CAPABLE (Figure 4);",
      "ja": "MP_CAPABLEでO利用可能なフラグ（図4）。"
    },
    {
      "indent": 3,
      "text": "o available subtypes in the MPTCP option (Figure 3);",
      "ja": "MPTCPオプションで使用可能なサブタイプO（図3）。"
    },
    {
      "indent": 3,
      "text": "o the version field in MP_CAPABLE (Figure 4);",
      "ja": "O MP_CAPABLE（図4）内のバージョンフィールドと"
    },
    {
      "indent": 0,
      "text": "6. Interactions with Middleboxes",
      "section_title": true,
      "ja": "Middleboxes 6.相互作用"
    },
    {
      "indent": 3,
      "text": "Multipath TCP was designed to be deployable in the present world. Its design takes into account \"reasonable\" existing middlebox behavior. In this section, we outline a few representative middlebox-related failure scenarios and show how Multipath TCP handles them. Next, we list the design decisions multipath has made to accommodate the different middleboxes.",
      "ja": "マルチパスTCPは現在、世界で展開可能なように設計されました。そのデザインは、アカウントに「合理的」既存のミドル行動を取ります。このセクションでは、我々はいくつかの代表的なミドル関連の障害シナリオを概説し、マルチパスTCPはそれらを処理する方法を示しています。次に、我々は、マルチパスが異なるミドルボックスに対応するために作られた設計上の決定を一覧表示します。"
    },
    {
      "indent": 3,
      "text": "A primary concern is our use of a new TCP option. Middleboxes should forward packets with unknown options unchanged, yet there are some that don't. These we expect will either strip options and pass the data, drop packets with new options, copy the same option into multiple segments (e.g., when doing segmentation), or drop options during segment coalescing.",
      "ja": "主な関心事は、新しいTCPオプションの私達の使用です。 Middleboxesは変わらず、未知のオプションを使用してパケットを転送する必要があり、まだそうでないいくつかがあります。これらは、我々は、ストリップのオプションのいずれかは、データを渡す新しいオプションを持つパケットをドロップし、セグメント合体中に同じ複数のセグメントにオプション（例えば、セグメンテーションを行う）、またはドロップオプションをコピーすることを期待しています。"
    },
    {
      "indent": 3,
      "text": "MPTCP uses a single new TCP option \"Kind\", and all message types are defined by \"subtype\" values (see Section 8). This should reduce the chances of only some types of MPTCP options being passed, and instead the key differing characteristics are different paths, and the presence of the SYN flag.",
      "ja": "MPTCPは、単一の新しいTCPオプション「種類」を使用し、すべてのメッセージタイプは、「サブタイプ」の値（セクション8を参照）によって定義されています。これは、いくつか渡されるMPTCPオプションの種類、その代わりにキー異なる特性が異なる経路で、SYNフラグの存在の可能性を減らすべきです。"
    },
    {
      "indent": 3,
      "text": "MPTCP SYN packets on the first subflow of a connection contain the MP_CAPABLE option (Section 3.1). If this is dropped, MPTCP SHOULD fall back to regular TCP. If packets with the MP_JOIN option (Section 3.2) are dropped, the paths will simply not be used.",
      "ja": "接続の最初のサブフローにMPTCP SYNパケットがMP_CAPABLEオプション（3.1節）を含有します。これがドロップされた場合、MPTCPは戻って、通常のTCPに落ちるべきです。 MP_JOINオプション（3.2節）を持つパケットが廃棄されている場合、パスは単純に使用されることはありません。"
    },
    {
      "indent": 3,
      "text": "If a middlebox strips options but otherwise passes the packets unchanged, MPTCP will behave safely. If an MP_CAPABLE option is dropped on either the outgoing or the return path, the initiating host can fall back to regular TCP, as illustrated in Figure 16 and discussed in Section 3.1.",
      "ja": "ミドルは、オプションを取り除き、それ以外変わらないパケットを通過させる場合は、MPTCPは安全に動作します。 MP_CAPABLEオプションは、発信またはリターンパスのいずれかにドロップされた場合は、図16に示し、3.1節で述べたように、開始ホストは、通常のTCPにフォールバックすることができます。"
    },
    {
      "indent": 3,
      "text": "Subflow SYNs contain the MP_JOIN option. If this option is stripped on the outgoing path, the SYN will appear to be a regular SYN to Host B. Depending on whether there is a listening socket on the target port, Host B will reply either with SYN/ACK or RST (subflow connection fails). When Host A receives the SYN/ACK it sends a RST because the SYN/ACK does not contain the MP_JOIN option and its token. Either way, the subflow setup fails, but otherwise does not affect the MPTCP connection as a whole.",
      "ja": "サブフローのSYNはMP_JOINオプションが含まれています。このオプションは往路に取り除かれている場合、SYNは、ターゲット・ポート上のリスニングソケットがあるかどうか、ホストBは、いずれかのSYN / ACKまたはRSTで応答するに応じて、ホストB正規SYNように表示されます（サブフロー接続）失敗しました。ホストAがSYNを受信した場合/ SYN / ACKがMP_JOINオプションとそのトークンが含まれていないので、それはRSTを送信しACK。いずれかの方法で、サブフローセットアップが失敗したが、それ以外は全体としてMPTCP接続には影響を与えません。"
    },
    {
      "indent": 5,
      "text": "   Host A                             Host B\n    |              Middlebox M            |\n    |                   |                 |\n    |  SYN(MP_CAPABLE)  |        SYN      |\n    |-------------------|---------------->|\n    |                SYN/ACK              |\n    |<------------------------------------|\na) MP_CAPABLE option stripped on outgoing path",
      "raw": true
    },
    {
      "indent": 5,
      "text": "  Host A                               Host B\n    |            SYN(MP_CAPABLE)          |\n    |------------------------------------>|\n    |             Middlebox M             |\n    |                 |                   |\n    |    SYN/ACK      |SYN/ACK(MP_CAPABLE)|\n    |<----------------|-------------------|\nb) MP_CAPABLE option stripped on return path",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 16: Connection Setup with Middleboxes that Strip Options from Packets",
      "ja": "図16：パケットからそのストリップオプションのMiddleboxesとの接続のセットアップ"
    },
    {
      "indent": 3,
      "text": "We now examine data flow with MPTCP, assuming the flow is correctly set up, which implies the options in the SYN packets were allowed through by the relevant middleboxes. If options are allowed through and there is no resegmentation or coalescing to TCP segments, Multipath TCP flows can proceed without problems.",
      "ja": "現在、関連するミドルボックスによって通過を許可されたSYNパケットのオプションを意味し、正しく設定されている流れを、と仮定すると、MPTCPとのデータの流れを調べます。オプションが通過を許可されており、何の再セグメンテーションやTCPセグメントに合体がない場合は、マルチパスTCPフローは問題なく進めることができます。"
    },
    {
      "indent": 3,
      "text": "The case when options get stripped on data packets has been discussed in the Fallback section. If a fraction of options are stripped, behavior is not deterministic. If some data sequence mappings are lost, the connection can continue so long as mappings exist for the subflow-level data (e.g., if multiple maps have been sent that reinforce each other). If some subflow-level space is left unmapped, however, the subflow is treated as broken and is closed, through the process described in Section 3.6. MPTCP should survive with a loss of some Data ACKs, but performance will degrade as the fraction of stripped options increases. We do not expect such cases to appear in practice, though: most middleboxes will either strip all options or let them all through.",
      "ja": "オプションは、データパケットストリッピングを取得する場合は、フォールバックのセクションで説明されています。オプションの一部が取り除かれている場合、動作は確定的ではありません。いくつかのデータ・シーケンスのマッピングが失われた場合、接続があればマッピングがサブフローレベルのデータのために存在するように継続することができる（例えば、複数のマップが互いに補強その送信された場合）。いくつかのサブフローレベルの空間がマッピングされていないままの場合に破損、しかし、サブフローを処理し、3.6節で説明したプロセスを介して、閉じられています。 MPTCPは、いくつかのデータACKの損失で生き残る必要がありますが、パフォーマンスが取り除かオプションが増加の割合として低下します。我々は、しかし、そのような場合は、実際に表示されるように期待していない：ほとんどのミドルボックスは、すべてのオプションを削除したり、すべてが通過できるようになるのいずれか。"
    },
    {
      "indent": 3,
      "text": "We end this section with a list of middlebox classes, their behavior, and the elements in the MPTCP design that allow operation through such middleboxes. Issues surrounding dropping packets with options or stripping options were discussed above, and are not included here:",
      "ja": "私たちは、ミドルクラス、彼らの行動、および、そのようなミドルボックスによって動作を可能MPTCPデザインの要素のリストを、このセクションを終了します。オプションでパケットをドロップするか、ストリッピングオプションを取り巻く課題は、上述し、ここに含まれていません。"
    },
    {
      "indent": 3,
      "text": "o NATs [21] (Network Address (and Port) Translators) change the source address (and often source port) of packets. This means that a host will not know its public-facing address for signaling in MPTCP. Therefore, MPTCP permits implicit address addition via the MP_JOIN option, and the handshake mechanism ensures that connection attempts to private addresses [18] do not cause problems. Explicit address removal is undertaken by an Address ID to allow no knowledge of the source address.",
      "ja": "O NATは、[21]（ネットワークアドレス（およびポート）翻訳者）パケットの送信元アドレス（および多くの場合、送信元ポート）を変更します。これは、ホストがMPTCPに信号を送るための一般向けのアドレスを知らないことを意味します。したがって、MPTCPはMP_JOINオプションによって暗黙のアドレス加算を許可し、握手メカニズムは、プライベートアドレス[18]への接続の試みが問題を引き起こさないことを保証します。明示的なアドレス除去は、送信元アドレスの知識を許可しないようにアドレスIDによって行われます。"
    },
    {
      "indent": 3,
      "text": "o Performance Enhancing Proxies (PEPs) [22] might proactively ACK data to increase performance. MPTCP, however, relies on accurate congestion control signals from the end host, and non-MPTCP-aware PEPs will not be able to provide such signals. MPTCP will, therefore, fall back to single-path TCP, or close the problematic subflow (see Section 3.6).",
      "ja": "Oパフォーマンス強化プロキシ（PEPには）[22]積極的にACKデータは、パフォーマンスを向上させるかもしれません。 MPTCPは、しかし、エンドホストから正確な輻輳制御信号に依存し、非MPTCP認識PEPには、このような信号を提供することができません。 MPTCP、従って、バックシングルパスTCPに落ちる、または問題のサブフローを閉じる（セクション3.6を参照）。"
    },
    {
      "indent": 3,
      "text": "o Traffic Normalizers [23] may not allow holes in sequence numbers, and may cache packets and retransmit the same data. MPTCP looks like standard TCP on the wire, and will not retransmit different data on the same subflow sequence number. In the event of a retransmission, the same data will be retransmitted on the original TCP subflow even if it is additionally retransmitted at the connection level on a different subflow.",
      "ja": "Oトラフィック正規化[23]は、シーケンス番号の穴を許可しないかもしれない、そして、パケットをキャッシュし、同じデータを再送信することができます。 MPTCPは、ワイヤ上の標準TCPのように見える、と同じサブフローシーケンス番号に異なるデータを再送信しません。再送の場合には、同一のデータは、それがさらに異なるサブフローに接続レベルで再送信された場合でも、元のTCPサブフローに再送されます。"
    },
    {
      "indent": 3,
      "text": "o Firewalls [24] might perform initial sequence number randomization on TCP connections. MPTCP uses relative sequence numbers in data sequence mapping to cope with this. Like NATs, firewalls will not permit many incoming connections, so MPTCP supports address signaling (ADD_ADDR) so that a multiaddressed host can invite its peer behind the firewall/NAT to connect out to its additional interface.",
      "ja": "Oファイアウォール[24]は、TCP接続に初期シーケンス番号のランダム化を実行する場合があります。 MPTCPは、これに対処するために、データ系列のマッピングで相対シーケンス番号を使用しています。同報ホストがファイアウォールの背後にあるピアを招待できるようにMPTCPアドレスシグナリング（ADD_ADDR）をサポートしていますので、NATのと同じように、ファイアウォールは、多くの着信接続を許可しません/ NATは、その追加のインタフェースに出て接続します。"
    },
    {
      "indent": 3,
      "text": "o Intrusion Detection Systems look out for traffic patterns and content that could threaten a network. Multipath will mean that such data is potentially spread, so it is more difficult for an IDS to analyze the whole traffic, and potentially increases the risk of false positives. However, for an MPTCP-aware IDS, tokens can be read by such systems to correlate multiple subflows and reassemble for analysis.",
      "ja": "O侵入検知システムは、ネットワークを脅かすトラフィックパターンとコンテンツを探してください。マルチパスは、このようなデータが潜在的に広がっていることを意味しますので、IDSは、全体のトラフィックを分析し、潜在的に偽陽性のリスクを増大させることがより困難です。しかしながら、MPTCP認識IDSため、トークンは複数のサブフローを相関し、分析のために再構築するためにこのようなシステムによって読み取ることができます。"
    },
    {
      "indent": 3,
      "text": "o Application-level middleboxes such as content-aware firewalls may alter the payload within a subflow, such as rewriting URIs in HTTP traffic. MPTCP will detect these using the checksum and close the affected subflow(s), if there are other subflows that can be used. If all subflows are affected, multipath will fall back to TCP, allowing such middleboxes to change the payload. MPTCP-aware middleboxes should be able to adjust the payload and MPTCP metadata in order not to break the connection.",
      "ja": "O、コンテンツアウェアファイアウォールなどのアプリケーションレベルの中間装置は、HTTPトラフィックのURIを書き換えるように、サブフロー内のペイロードを変更することができます。使用することができる他のサブフローがある場合MPTCPは、チェックサムを使用して、これらを検出し、影響を受けたサブフロー（単数または複数）を閉じます。すべてのサブフローが影響を受けている場合は、マルチパスは、このようなミドルボックスは、ペイロードを変更することができ、バックTCPに分類されます。 MPTCP対応のミドルボックスは、接続を切断しないようにするために、ペイロードとMPTCPメタデータを調整することができるはずです。"
    },
    {
      "indent": 3,
      "text": "In addition, all classes of middleboxes may affect TCP traffic in the following ways:",
      "ja": "また、ミドルボックスのすべてのクラスは、次の方法でTCPトラフィックに影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "o TCP options may be removed, or packets with unknown options dropped, by many classes of middleboxes. It is intended that the initial SYN exchange, with a TCP option, will be sufficient to identify the path capabilities. If such a packet does not get through, MPTCP will end up falling back to regular TCP.",
      "ja": "O TCPオプションを除去することができる、または未知のオプションを持つパケットは、ミドルボックスの多くのクラスによって、低下しました。最初のSYN交換は、TCPオプションを使用して、パス能力を識別するのに十分であろうことを意図しています。このようなパケットを介して取得していない場合、MPTCPは、通常のTCPに戻って落ちてしまいます。"
    },
    {
      "indent": 3,
      "text": "o Segmentation/Coalescing (e.g., TCP segmentation offloading) might copy options between packets and might strip some options. MPTCP's data sequence mapping includes the relative subflow sequence number instead of using the sequence number in the segment. In this way, the mapping is independent of the packets that carry it.",
      "ja": "Oセグメンテーション/合体（例えば、TCPセグメンテーションオフロード）パケット間のオプションをコピーする可能性があり、いくつかのオプションを削除することがあります。 MPTCPのデータ列マッピングではなく、セグメントのシーケンス番号を使用しての相対的サブフローシーケンス番号を含みます。このように、マッピングは、それを運ぶパケットとは無関係です。"
    },
    {
      "indent": 3,
      "text": "o The receive window may be shrunk by some middleboxes at the subflow level. MPTCP will use the maximum window at data level, but will also obey subflow-specific windows.",
      "ja": "O受信ウィンドウはサブフローレベルでいくつかの中間装置によって縮小されてもよいです。 MPTCPは、データレベルでの最大ウィンドウを使用しますが、またサブフロー固有の窓に従います。"
    },
    {
      "indent": 0,
      "text": "7. Acknowledgments",
      "section_title": true,
      "ja": "7.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors were originally supported by Trilogy (http://www.trilogy-project.org), a research project (ICT-216372) partially funded by the European Community under its Seventh Framework Program.",
      "ja": "著者はもともとトリロジー（http://www.trilogy-project.org）、部分的にその第七次フレームワーク・プログラムの下で欧州共同体資金による研究プロジェクト（ICT-216372）によってサポートされていました。"
    },
    {
      "indent": 3,
      "text": "Alan Ford was originally supported by Roke Manor Research.",
      "ja": "アランフォードはもともとRoke Manorの研究によってサポートされていました。"
    },
    {
      "indent": 3,
      "text": "The authors gratefully acknowledge significant input into this document from Sebastien Barre, Christoph Paasch, and Andrew McDonald.",
      "ja": "作者は感謝セバスチャン・バレ、クリストフPaasch、そしてアンドリュー・マクドナルドからこの文書に重要な入力を認めます。"
    },
    {
      "indent": 3,
      "text": "The authors also wish to acknowledge reviews and contributions from Iljitsch van Beijnum, Lars Eggert, Marcelo Bagnulo, Robert Hancock, Pasi Sarolahti, Toby Moncaster, Philip Eardley, Sergio Lembo, Lawrence Conroy, Yoshifumi Nishida, Bob Briscoe, Stein Gjessing, Andrew McGregor, Georg Hampel, Anumita Biswas, Wes Eddy, Alexey Melnikov, Francis Dupont, Adrian Farrel, Barry Leiba, Robert Sparks, Sean Turner, Stephen Farrell, and Martin Stiemerling.",
      "ja": "著者らはまた、IljitschバンBeijnum、ラースEggertの、マルセロBagnulo、ロバート・ハンコック、パシSarolahti、トビーMoncaster、フィリップEardley、セルジオLembo、ローレンスコンロイ、西田佳史、ボブ・ブリスコー、スタインGjessing、アンドリュー・マクレガーからのレビューや貢献を認めることを望みますゲオルク・ハンペル、Anumitaビスワス、ウェス・エディ、アレクセイ・メルニコフ、フランシスデュポン、エードリアンファレル、バリー・レイバ、ロバート・スパークス、ショーン・ターナー、スティーブン・ファレル、とマーティンStiemerling。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document defines a new TCP option for MPTCP, assigned a value of 30 (decimal) from the TCP option space. This value is the value of \"Kind\" as seen in all MPTCP options in this document. This value is defined as:",
      "ja": "このドキュメントでは、TCPオプション空間から30（10進数）の値が割り当てられMPTCPための新しいTCPオプションを定義します。このドキュメント内のすべてのMPTCPオプションで見られるように、この値は、「種類」の値です。この値は、次のように定義されます"
    },
    {
      "indent": 11,
      "text": "+------+--------+-----------------------+-----------+\n| Kind | Length |        Meaning        | Reference |\n+------+--------+-----------------------+-----------+\n|  30  |    N   | Multipath TCP (MPTCP) |  RFC 6824 |\n+------+--------+-----------------------+-----------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Table 1: TCP Option Kind Numbers",
      "ja": "表1：TCPオプション種類番号"
    },
    {
      "indent": 3,
      "text": "This document also defines a 4-bit subtype field, for which IANA has created and will maintain a new sub-registry entitled \"MPTCP Option Subtypes\" under the \"Transmission Control Protocol (TCP) Parameters\" registry. Initial values for the MPTCP option subtype registry are given below; future assignments are to be defined by Standards Action as defined by [25]. Assignments consist of the MPTCP subtype's symbolic name and its associated value, as per the following table.",
      "ja": "また、このドキュメントでは、IANAが作成しているため、4ビットのサブタイプフィールドを定義し、「伝送制御プロトコル（TCP）パラメータ」レジストリの下に「MPTCPオプションのサブタイプ」と題する新しいサブレジストリを維持します。 MPTCPオプションサブタイプレジストリの初期値は以下の通りです。将来の割り当ては、[25]で定義された標準化アクションによって定義されることになっています。割り当ては、次の表のとおり、MPTCPサブタイプのシンボル名とその値で構成されています。"
    },
    {
      "indent": 3,
      "text": "+-------+--------------+----------------------------+---------------+\n| Value |    Symbol    |            Name            |   Reference   |\n+-------+--------------+----------------------------+---------------+\n|  0x0  |  MP_CAPABLE  |      Multipath Capable     |  Section 3.1  |\n|  0x1  |    MP_JOIN   |       Join Connection      |  Section 3.2  |\n|  0x2  |      DSS     | Data Sequence Signal (Data |  Section 3.3  |\n|       |              |    ACK and data sequence   |               |\n|       |              |          mapping)          |               |\n|  0x3  |   ADD_ADDR   |         Add Address        | Section 3.4.1 |\n|  0x4  |  REMOVE_ADDR |       Remove Address       | Section 3.4.2 |\n|  0x5  |    MP_PRIO   |   Change Subflow Priority  | Section 3.3.8 |\n|  0x6  |    MP_FAIL   |          Fallback          |  Section 3.6  |\n|  0x7  | MP_FASTCLOSE |         Fast Close         |  Section 3.5  |\n+-------+--------------+----------------------------+---------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Table 2: MPTCP Option Subtypes",
      "ja": "表2：MPTCPオプションサブタイプ"
    },
    {
      "indent": 3,
      "text": "Values 0x8 through 0xe are currently unassigned. The value 0xf is reserved for Private Use within controlled testbeds.",
      "ja": "0xEまでの値を0x8には、現在割り当てられていません。値0xFのは、制御されたテストベッド内の私的使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "IANA has created another sub-registry, \"MPTCP Handshake Algorithms\" under the \"Transmission Control Protocol (TCP) Parameters\" registry, based on the flags in MP_CAPABLE (Section 3.1). The flags consist of 8 bits, labeled \"A\" through \"H\", and this document assigns the bits as follows:",
      "ja": "IANAはMP_CAPABLE内のフラグに基づいて、「伝送制御プロトコル（TCP）パラメータ」レジストリ、（3.1節）の下に別のサブレジストリ、「MPTCPハンドシェイクアルゴリズム」を作成しました。フラグが「H」から「A」と表示された8ビットから成り、以下のように、このドキュメントは、ビットを割り当てます。"
    },
    {
      "indent": 9,
      "text": "+----------+-------------------+-----------------------+\n| Flag Bit |      Meaning      |       Reference       |\n+----------+-------------------+-----------------------+\n|     A    | Checksum required | RFC 6824, Section 3.1 |\n|     B    |   Extensibility   | RFC 6824, Section 3.1 |\n|    C-G   |     Unassigned    |                       |\n|     H    |     HMAC-SHA1     | RFC 6824, Section 3.2 |\n+----------+-------------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Table 3: MPTCP Handshake Algorithms",
      "ja": "表3：MPTCPハンドシェイクアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Note that the meanings of bits C through H can be dependent upon bit B, depending on how Extensibility is defined in future specifications; see Section 3.1 for more information.",
      "ja": "H介してビットCの意味は、拡張が将来の仕様で定義されている方法に応じて、ビットBに依存することに留意されたいです。詳細については、セクション3.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Future assignments in this registry are also to be defined by Standards Action as defined by [25]. Assignments consist of the value of the flags, a symbolic name for the algorithm, and a reference to its specification.",
      "ja": "このレジストリ内の今後の割り当ては、[25]で定義された標準化アクションによって定義されることもあります。割り当ては、フラグの値は、アルゴリズムの記号名は、その明細書を参照から成ります。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[1] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[1]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[2] Ford, A., Raiciu, C., Handley, M., Barre, S., and J. Iyengar, \"Architectural Guidelines for Multipath TCP Development\", RFC 6182, March 2011.",
      "ja": "[2]フォード、A.、Raiciu、C.、ハンドレー、M.、バール、S.、およびJ.アイアンガー、 \"マルチパスTCP開発のための建築ガイドライン\"、RFC 6182、2011年3月。"
    },
    {
      "indent": 3,
      "text": "[3] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[3]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[4] National Institute of Science and Technology, \"Secure Hash Standard\", Federal Information Processing Standard (FIPS) 180-3, October 2008, <http://csrc.nist.gov/publications/ fips/fips180-3/fips180-3_final.pdf>.",
      "ja": "[4]科学技術、 \"セキュアハッシュ標準\" の国立研究所、連邦情報処理標準（FIPS）180-3、2008年10月、<http://csrc.nist.gov/publications/ FIPS / fips180-3 / fips180 -3_final.pdf>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[5] Raiciu, C., Handley, M., and D. Wischik, \"Coupled Congestion Control for Multipath Transport Protocols\", RFC 6356, October 2011.",
      "ja": "[5] Raiciu、C.、ハンドレー、M.、およびD. Wischik、 \"マルチパストランスポートプロトコルのための結合輻輳制御\"、RFC 6356、2011年10月。"
    },
    {
      "indent": 3,
      "text": "[6] Scharf, M. and A. Ford, \"MPTCP Application Interface Considerations\", Work in Progress, October 2012.",
      "ja": "[6]シャーフ、M.とA.フォード、 \"MPTCPアプリケーションインターフェイスに関する注意事項\"、進歩、2012年10月での作業。"
    },
    {
      "indent": 3,
      "text": "[7] Hopps, C., \"Analysis of an Equal-Cost Multi-Path Algorithm\", RFC 2992, November 2000.",
      "ja": "[7] Hoppsが、C.、 \"等価コストマルチパスアルゴリズムの分析\"、RFC 2992、2000年11月に。"
    },
    {
      "indent": 3,
      "text": "[8] Raiciu, C., Paasch, C., Barre, S., Ford, A., Honda, M., Duchene, F., Bonaventure, O., and M. Handley, \"How Hard Can It Be? Designing and Implementing a Deployable Multipath TCP\", Usenix Symposium on Networked Systems Design and Implementation 012, 2012, <https://www.usenix.org/conference/ nsdi12/how-hard-can-it-be-designing-and-implementing-deployable-multipath-tcp>.",
      "ja": "[8] Raiciu、C.、Paasch、C.、バレ、S.、フォード、A.、ホンダ、M.、デュシェンヌ型、F.、ボナベンチャー、O.、およびM. Handleyのを、「ハードはそれができる方法は？設計と展開可能マルチTCPの実装」、ネットワークシステムの設計と実装012上のUsenixシンポジウム、2012年、<https://www.usenix.org/conference/ nsdi12 /ハウツーハード缶それ被設計・アンド・実装・展開可能なマルチパス-TCP>。"
    },
    {
      "indent": 3,
      "text": "[9] Bagnulo, M., \"Threat Analysis for TCP Extensions for Multipath Operation with Multiple Addresses\", RFC 6181, March 2011.",
      "ja": "[9] Bagnulo、M.、 \"複数のアドレスを持つマルチパス操作のためのTCP拡張のための脅威分析\"、RFC 6181、2011年3月。"
    },
    {
      "indent": 3,
      "text": "[10] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[10] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[11] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, October 1996.",
      "ja": "[11]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 \"TCPの選択確認応答オプション\"、RFC 2018、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[12] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, September 2009.",
      "ja": "[12]オールマン、M.、パクソン、V.、およびE.ブラントン、 \"TCP輻輳制御\"、RFC 5681、2009年9月。"
    },
    {
      "indent": 3,
      "text": "[13] Gont, F., \"Survey of Security Hardening Methods for Transmission Control Protocol (TCP) Implementations\", Work in Progress, March 2012.",
      "ja": "[13] Gont、F.、「伝送制御プロトコル（TCP）の実装のためのセキュリティ強化方法の調査」、進歩、2012年3月での作業。"
    },
    {
      "indent": 3,
      "text": "[14] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[14]イーストレーク、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[15] Eastlake, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, May 2011.",
      "ja": "[15]イーストレイク、D.とT.ハンセン、 \"米国のセキュアハッシュアルゴリズム（SHAとSHAベースのHMACとHKDF）\"、RFC 6234、2011年5月。"
    },
    {
      "indent": 3,
      "text": "[16] Jacobson, V., Braden, B., and D. Borman, \"TCP Extensions for High Performance\", RFC 1323, May 1992.",
      "ja": "[16]ジェーコブソン、V.、ブレーデン、B.、およびD.ボーマン、 \"ハイパフォーマンスのためのTCP拡張\"、RFC 1323、1992年5月。"
    },
    {
      "indent": 3,
      "text": "[17] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, September 2001.",
      "ja": "[17] \"IPに明示的輻輳通知の添加（ECN）\" ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[18] Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and E. Lear, \"Address Allocation for Private Internets\", BCP 5, RFC 1918, February 1996.",
      "ja": "[18] Rekhter、Y.、モスコウィッツ、R.、Karrenberg、D.、グルート、G.、およびE.リア、 \"個人的なインターネットのための配分\"、BCP 5、RFC 1918、1996年2月。"
    },
    {
      "indent": 3,
      "text": "[19] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[19]ブレーデン、R.、 \"インターネットホストのための要件 - 通信層\"、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[20] Ramaiah, A., \"TCP option space extension\", Work in Progress, March 2012.",
      "ja": "[20] Ramaiah、A.、 \"TCPオプションのスペース拡張\"、進歩、2012年3月での作業。"
    },
    {
      "indent": 3,
      "text": "[21] Srisuresh, P. and K. Egevang, \"Traditional IP Network Address Translator (Traditional NAT)\", RFC 3022, January 2001.",
      "ja": "[21] Srisuresh、P.とK. Egevang、 \"伝統的なIPネットワークアドレス変換（NAT繁体字）\"、RFC 3022、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[22] Border, J., Kojo, M., Griner, J., Montenegro, G., and Z. Shelby, \"Performance Enhancing Proxies Intended to Mitigate Link-Related Degradations\", RFC 3135, June 2001.",
      "ja": "[22]ボーダー、J.、古城、M.、Griner、J.、モンテネグロ、G.、およびZ.シェルビー、 \"パフォーマンスプロキシは、リンク関連の劣化を緩和することを意図するもので強化\"、RFC 3135、2001年6月。"
    },
    {
      "indent": 3,
      "text": "[23] Handley, M., Paxson, V., and C. Kreibich, \"Network Intrusion Detection: Evasion, Traffic Normalization, and End-to-End Protocol Semantics\", Usenix Security 2001, 2001, <http://www.usenix.org/events/sec01/full_papers/ handley/handley.pdf>.",
      "ja": "[23]ハンドリー、M.、パクソン、V.、およびC. Kreibich、 \"ネットワーク侵入検知：回避、トラフィック正規化、およびエンドツーエンドのプロトコルセマンティクス\"、のUsenixセキュリティ2001、2001、<のhttp：// WWW .usenix.org /イベント/ SEC01 / full_papers /ハンドリー/ handley.pdf>。"
    },
    {
      "indent": 3,
      "text": "[24] Freed, N., \"Behavior of and Requirements for Internet Firewalls\", RFC 2979, October 2000.",
      "ja": "\"インターネットファイアウォールのための行動と要件\" [24]フリード、N.、RFC 2979、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[25] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[25] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Notes on Use of TCP Options",
      "ja": "付録A.は、TCPオプションの使用上のご注意します"
    },
    {
      "indent": 3,
      "text": "The TCP option space is limited due to the length of the Data Offset field in the TCP header (4 bits), which defines the TCP header length in 32-bit words. With the standard TCP header being 20 bytes, this leaves a maximum of 40 bytes for options, and many of these may already be used by options such as timestamp and SACK.",
      "ja": "TCPオプション空間が原因32ビットワードにTCPヘッダの長さを規定するTCPヘッダ（4ビット）、フィールドオフセットデータの長さに制限されます。標準のTCPヘッダは20バイトであると、これはオプションの40バイトの最大値を残し、そしてこれらの多くは、すでにそのようなタイムスタンプとSACKオプションなどによって使用されてもよいです。"
    },
    {
      "indent": 3,
      "text": "We have performed a brief study on the commonly used TCP options in SYN, data, and pure ACK packets, and found that there is enough room to fit all the options we propose using in this document.",
      "ja": "私たちは、一般的に使用されるTCP SYNのオプション、データ、および純粋なACKパケットの簡単な調査を行い、私たちは、このドキュメントで使用して提案しているすべてのオプションをフィットするのに十分な余地があることを発見しました。"
    },
    {
      "indent": 3,
      "text": "SYN packets typically include Maximum Segment Size (MSS) (4 bytes), window scale (3 bytes), SACK permitted (2 bytes), and timestamp (10 bytes) options. Together these sum to 19 bytes. Some operating systems appear to pad each option up to a word boundary, thus using 24 bytes (a brief survey suggests Windows XP and Mac OS X do this, whereas Linux does not). Optimistically, therefore, we have 21 bytes spare, or 16 if it has to be word-aligned. In either case, however, the SYN versions of Multipath Capable (12 bytes) and Join (12 or 16 bytes) options will fit in this remaining space.",
      "ja": "SYNパケットは、典型的には、最大セグメントサイズ（MSS）（4バイト）、ウィンドウスケール（3バイト）、SACK許可（2バイト）、およびタイムスタンプ（10バイト）のオプションを含みます。 19バイトに一緒にこれらの合計。一部のオペレーティングシステムは、このように（簡単なアンケートは、Linuxにはないのに対し、WindowsのXPとMac OS Xには、これを行う示唆して）24バイトを使用して、ワード境界までの各オプションパッドに表示されます。それはワード境界で整列する必要がある場合は楽観的、したがって、我々は、21バイトのスペア、または16を持っています。いずれの場合に可能なマルチパスの、しかし、SYNバージョン（12バイト）及び（12または16バイト）参加オプションがこの残りのスペースに収まります。"
    },
    {
      "indent": 3,
      "text": "TCP data packets typically carry timestamp options in every packet, taking 10 bytes (or 12 with padding). That leaves 30 bytes (or 28, if word-aligned). The Data Sequence Signal (DSS) option varies in length depending on whether the data sequence mapping and DATA_ACK are included, and whether the sequence numbers in use are 4 or 8 octets. The maximum size of the DSS option is 28 bytes, so even that will fit in the available space. But unless a connection is both bidirectional and high-bandwidth, it is unlikely that all that option space will be required on each DSS option.",
      "ja": "TCPデータパケットは、典型的には10バイト（またはパディング12）を取って、各パケットにタイムスタンプオプションを運びます。 （ワード整列場合、または28）すなわち、30のバイトを残します。データシーケンス信号（DSS）オプションは、データ系列のマッピングとDATA_ACKが含まれているかどうか、および使用中のシーケンス番号が4または8オクテットであるかどうかに応じて長さが変化します。 DSSオプションの最大サイズは28バイトなので、それさえもが利用可能なスペースに収まります。接続は双方向かつ高帯域幅の両方でない限りしかし、すべてのそのオプションのスペースは、各DSSオプションに必要とされることはほとんどありません。"
    },
    {
      "indent": 3,
      "text": "Within the DSS option, it is not necessary to include the data sequence mapping and DATA_ACK in each packet, and in many cases it may be possible to alternate their presence (so long as the mapping covers the data being sent in the following packet). It would also be possible to alternate between 4- and 8-byte sequence numbers in each option.",
      "ja": "DSSオプション内では、各パケット内のデータ列のマッピングとDATA_ACKを含める必要はなく、多くの場合、（あればマッピングは、データが次のパケットで送信されるカバーされるように）その存在を交互することも可能です。また、各オプションで、4- 8バイトのシーケンス番号との間で交互することが可能です。"
    },
    {
      "indent": 3,
      "text": "On subflow and connection setup, an MPTCP option is also set on the third packet (an ACK). These are 20 bytes (for Multipath Capable) and 24 bytes (for Join), both of which will fit in the available option space.",
      "ja": "サブフローと接続設定に、MPTCPオプションはまた、第3のパケット（ACK）に設定されています。これらは、（対応マルチパス用）、20のバイトと利用可能なオプションのスペースに収まるどちらも24バイト（参加のために）、です。"
    },
    {
      "indent": 3,
      "text": "Pure ACKs in TCP typically contain only timestamps (10 bytes). Here, Multipath TCP typically needs to encode only the DATA_ACK (maximum of 12 bytes). Occasionally, ACKs will contain SACK information. Depending on the number of lost packets, SACK may utilize the entire option space. If a DATA_ACK had to be included, then it is probably necessary to reduce the number of SACK blocks to accommodate the DATA_ACK. However, the presence of the DATA_ACK is unlikely to be necessary in a case where SACK is in use, since until at least some of the SACK blocks have been retransmitted, the cumulative data-level ACK will not be moving forward (or if it does, due to retransmissions on another path, then that path can also be used to transmit the new DATA_ACK).",
      "ja": "TCPでの純粋なACKは一般的にのみ、タイムスタンプ（10バイト）が含まれています。ここで、マルチパスTCPは、典型的にのみDATA_ACK（12バイトの最大値）を符号化する必要があります。時折、ACKはSACK情報が含まれています。失われたパケットの数に応じて、SACKは、オプション全体のスペースを利用することができます。 DATA_ACKが含まれていた場合、DATA_ACKに対応するためにSACKブロックの数を減らすために、おそらく必要があります。しかしながら、DATA_ACKの存在は、SACKブロックの少なくとも一部が再送されるまで、累積データレベルACKが前進（またはそれがない場合はされないので、SACKが使用中である場合に必要であることがにくいです、別の経路で再送信に起因して、その経路も）新しいDATA_ACKを送信するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "The ADD_ADDR option can be between 8 and 22 bytes, depending on whether IPv4 or IPv6 is used, and whether or not the port number is present. It is unlikely that such signaling would fit in a data packet (although if there is space, it is fine to include it). It is recommended to use duplicate ACKs with no other payload or options in order to transmit these rare signals. Note this is the reason for mandating that duplicate ACKs with MPTCP options are not taken as a signal of congestion.",
      "ja": "ADD_ADDRオプションは、IPv4またはIPv6が使用されているかどうかに応じて、8と22バイトの間であり、ポート番号が存在するか否かを判断することができます。 （スペースがある場合は、それを含めて結構ですが）、このようなシグナリングは、データパケットに収まるとは考えにくいです。これらの希少な信号を送信するために他のペイロードまたはオプションで重複ACKを使用することをお勧めします。これはMPTCPオプションを持つ重複ACKが輻輳の信号として取られていないことを義務づけるための理由であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Finally, there are issues with reliable delivery of options. As options can also be sent on pure ACKs, these are not reliably sent. This is not an issue for DATA_ACK due to their cumulative nature, but may be an issue for ADD_ADDR/REMOVE_ADDR options. Here, it is recommended to send these options redundantly (whether on multiple paths or on the same path on a number of ACKs -- but interspersed with data in order to avoid interpretation as congestion). The cases where options are stripped by middleboxes are discussed in Section 6.",
      "ja": "最後に、オプションの信頼性の高い配信に問題があります。オプションは、純粋なACKの上で送信することができますように、これらのは確実に送信されません。これは、その累積自然にDATA_ACKの問題ではありませんが、ADD_ADDR / REMOVE_ADDRオプションに問題がある可能性があります。ここでは、（ - しかし、混雑のような解釈を避けるためにデータが散在するか、複数のパスまたはACKの数に同じパスに）冗長これらのオプションを送信することが推奨されます。オプションはミドルボックスによって削除されている場合は、第6節で議論されています。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Control Blocks",
      "ja": "付録B.制御ブロック"
    },
    {
      "indent": 3,
      "text": "Conceptually, an MPTCP connection can be represented as an MPTCP control block that contains several variables that track the progress and the state of the MPTCP connection and a set of linked TCP control blocks that correspond to the subflows that have been established.",
      "ja": "概念的に、MPTCP接続が進行とMPTCP接続の状態と確立されているサブフローに対応する連結TCP制御ブロックのセットを追跡するいくつかの変数を含むMPTCP制御ブロックとして表すことができます。"
    },
    {
      "indent": 3,
      "text": "RFC 793 [1] specifies several state variables. Whenever possible, we reuse the same terminology as RFC 793 to describe the state variables that are maintained by MPTCP.",
      "ja": "RFC 793 [1]は、いくつかの状態変数を指定します。可能な限り、我々はMPTCPによって維持されている状態変数を記述するためにRFC 793と同じ用語を再利用します。"
    },
    {
      "indent": 0,
      "text": "B.1. MPTCP Control Block",
      "ja": "B.1。 MPTCP制御ブロック"
    },
    {
      "indent": 3,
      "text": "The MPTCP control block contains the following variable per connection.",
      "ja": "MPTCP制御ブロックは、接続ごとに次の変数が含まれています。"
    },
    {
      "indent": 0,
      "text": "B.1.1. Authentication and Metadata",
      "ja": "B.1.1。認証とメタデータ"
    },
    {
      "indent": 3,
      "text": "Local.Token (32 bits): This is the token chosen by the local host on this MPTCP connection. The token MUST be unique among all established MPTCP connections, generated from the local key.",
      "ja": "Local.Token（32ビット）：これは、このMPTCP接続上のローカルホストによって選択されたトークンです。トークンは、ローカルキーから生成されたすべての確立MPTCP接続、一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "Local.Key (64 bits): This is the key sent by the local host on this MPTCP connection.",
      "ja": "Local.Key（64ビット）：これは、このMPTCP接続でローカルホストによって送信された鍵です。"
    },
    {
      "indent": 3,
      "text": "Remote.Token (32 bits): This is the token chosen by the remote host on this MPTCP connection, generated from the remote key.",
      "ja": "Remote.Token（32ビット）：これは、リモートキーから生成されたこのMPTCP接続、リモートホストによって選択されたトークンです。"
    },
    {
      "indent": 3,
      "text": "Remote.Key (64 bits): This is the key chosen by the remote host on this MPTCP connection",
      "ja": "Remote.Key（64ビット）：これは、このMPTCP接続でリモートホストによって選択されたキーであります"
    },
    {
      "indent": 3,
      "text": "MPTCP.Checksum (flag): This flag is set to true if at least one of the hosts has set the C bit in the MP_CAPABLE options exchanged during connection establishment, and is set to false otherwise. If this flag is set, the checksum must be computed in all DSS options.",
      "ja": "MPTCP.Checksum（フラグ）：ホストの少なくとも一方がMP_CAPABLEオプションのCビットは、接続確立中に交換し、そうでない場合はfalseに設定されている設定している場合、このフラグがtrueに設定されています。このフラグが設定されている場合は、チェックサムはすべてのDSSオプションで計算しなければなりません。"
    },
    {
      "indent": 0,
      "text": "B.1.2. Sending Side",
      "ja": "B.1.2。送信側"
    },
    {
      "indent": 3,
      "text": "SND.UNA (64 bits): This is the data sequence number of the next byte to be acknowledged, at the MPTCP connection level. This variable is updated upon reception of a DSS option containing a DATA_ACK.",
      "ja": "SND.UNA（64ビット）：これはMPTCP接続レベルで、肯定応答すべき次のバイトのデータシーケンス番号です。この変数は、DATA_ACKを含むDSSオプションの受信時に更新されます。"
    },
    {
      "indent": 3,
      "text": "SND.NXT (64 bits): This is the data sequence number of the next byte to be sent. SND.NXT is used to determine the value of the DSN in the DSS option.",
      "ja": "SND.NXT（64ビット）：これは、送信されるべき次のバイトのデータシーケンス番号です。 SND.NXTは、DSSオプションでDSNの値を決定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "SND.WND (32 bits with RFC 1323, 16 bits otherwise): This is the sending window. MPTCP maintains the sending window at the MPTCP connection level and the same window is shared by all subflows. All subflows use the MPTCP connection level SND.WND to compute the SEQ.WND value that is sent in each transmitted segment.",
      "ja": "SND.WND（RFC 1323と32ビット、16ビットその他）：これは送信ウインドウです。 MPTCPはMPTCP接続レベルでの送信ウインドウを維持し、同じウィンドウは、すべてのサブフローによって共有されます。すべてのサブフローは、各送信セグメントで送信さSEQ.WND値を計算するMPTCP接続レベルSND.WNDを使用します。"
    },
    {
      "indent": 0,
      "text": "B.1.3. Receiving Side",
      "ja": "B.1.3。受信側"
    },
    {
      "indent": 3,
      "text": "RCV.NXT (64 bits): This is the data sequence number of the next byte that is expected on the MPTCP connection. This state variable is modified upon reception of in-order data. The value of RCV.NXT is used to specify the DATA_ACK that is sent in the DSS option on all subflows.",
      "ja": "RCV.NXT（64ビット）：これはMPTCP接続上で予想される次のバイトのデータシーケンス番号です。この状態変数は、順序データの受信時に変更されます。 RCV.NXTの値は、すべてのサブフローのDSSオプションで送信されDATA_ACKを指定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "RCV.WND (32 bits with RFC 1323, 16 bits otherwise): This is the connection-level receive window, which is the maximum of the RCV.WND on all the subflows.",
      "ja": "RCV.WND（RFC 1323と32ビット、16ビットその他）：これは、接続レベルでは、すべてのサブフローにRCV.WNDの最大値であるウィンドウを受け取ります。"
    },
    {
      "indent": 0,
      "text": "B.2. TCP Control Blocks",
      "ja": "B.2。 TCP制御ブロック"
    },
    {
      "indent": 3,
      "text": "The MPTCP control block also contains a list of the TCP control blocks that are associated to the MPTCP connection.",
      "ja": "MPTCP制御ブロックもMPTCP接続に関連付けられているTCP制御ブロックのリストが含まれています。"
    },
    {
      "indent": 3,
      "text": "Note that the TCP control block on the TCP subflows does not contain the RCV.WND and SND.WND state variables as these are maintained at the MPTCP connection level and not at the subflow level.",
      "ja": "これらはMPTCP接続レベルではなく、サブフローレベルに維持されるようにTCPのサブフローにTCP制御ブロックはRCV.WNDとSND.WND状態変数が含まれていないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Inside each TCP control block, the following state variables are defined.",
      "ja": "各TCP制御ブロックの内部では、以下の状態変数が定義されています。"
    },
    {
      "indent": 0,
      "text": "B.2.1. Sending Side",
      "ja": "B.2.1。送信側"
    },
    {
      "indent": 3,
      "text": "SND.UNA (32 bits): This is the sequence number of the next byte to be acknowledged on the subflow. This variable is updated upon reception of each TCP acknowledgment on the subflow.",
      "ja": "SND.UNA（32ビット）：これは、サブフローに肯定応答すべき次のバイトのシーケンス番号です。この変数は、サブフローの各TCP確認応答の受信時に更新されます。"
    },
    {
      "indent": 3,
      "text": "SND.NXT (32 bits): This is the sequence number of the next byte to be sent on the subflow. SND.NXT is used to set the value of SEG.SEQ upon transmission of the next segment.",
      "ja": "SND.NXT（32ビット）：これは、サブフローに送られるべき次のバイトのシーケンス番号です。 SND.NXTは、次のセグメントの送信時にSEG.SEQの値を設定するために使用されています。"
    },
    {
      "indent": 0,
      "text": "B.2.2. Receiving Side",
      "ja": "B.2.2。受信側"
    },
    {
      "indent": 3,
      "text": "RCV.NXT (32 bits): This is the sequence number of the next byte that is expected on the subflow. This state variable is modified upon reception of in-order segments. The value of RCV.NXT is copied to the SEG.ACK field of the next segments transmitted on the subflow.",
      "ja": "RCV.NXT（32ビット）：これは、サブフローに予想される次のバイトのシーケンス番号です。この状態変数は、順序セグメントの受信時に変更されます。 RCV.NXTの値は、サブフローに送信される次のセグメントのSEG.ACKフィールドにコピーされます。"
    },
    {
      "indent": 3,
      "text": "RCV.WND (32 bits with RFC 1323, 16 bits otherwise): This is the subflow-level receive window that is updated with the window field from the segments received on this subflow.",
      "ja": "RCV.WND（RFC 1323と32ビット、16ビットその他）：これは、サブフローレベルでは、セグメントからウィンドウフィールドで更新されるウィンドウは、このサブフローで受信受け取ります。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Finite State Machine",
      "ja": "付録C.有限ステートマシン"
    },
    {
      "indent": 3,
      "text": "The diagram in Figure 17 shows the Finite State Machine for connection-level closure. This illustrates how the DATA_FIN connection-level signal (indicated as the DFIN flag on a DATA_ACK) interacts with subflow-level FINs, and permits \"break-before-make\" handover between subflows.",
      "ja": "図17の図は、接続レベルの閉鎖のための有限状態機械を示しています。これは、（DATA_ACKにDFINフラグとして示される）DATA_FIN接続レベルの信号がサブフローレベルフィンと相互作用し、サブフロー間の「ブレーク・ビフォア・メーク」ハンドオーバを可能にする方法を示します。"
    },
    {
      "indent": 1,
      "text": "                             +---------+\n                             | M_ESTAB |\n                             +---------+\n                    M_CLOSE    |     |    rcv DATA_FIN\n                     -------   |     |    -------\n+---------+       snd DATA_FIN /       \\ snd DATA_ACK[DFIN] +---------+\n|  M_FIN  |<-----------------           ------------------->| M_CLOSE |\n| WAIT-1  |---------------------------                      |   WAIT  |\n+---------+               rcv DATA_FIN \\                    +---------+\n  | rcv DATA_ACK[DFIN]         ------- |                   M_CLOSE |\n  | --------------        snd DATA_ACK |                   ------- |\n  | CLOSE all subflows                 |              snd DATA_FIN |\n  V                                    V                           V\n+-----------+              +-----------+                  +-----------+\n|M_FINWAIT-2|              | M_CLOSING |                  | M_LAST-ACK|\n+-----------+              +-----------+                  +-----------+\n  |              rcv DATA_ACK[DFIN] |           rcv DATA_ACK[DFIN] |\n  | rcv DATA_FIN     -------------- |               -------------- |\n  |  -------     CLOSE all subflows |           CLOSE all subflows |\n  | snd DATA_ACK[DFIN]              V            delete MPTCP PCB  V\n  \\                          +-----------+                  +---------+\n    ------------------------>|M_TIME WAIT|----------------->| M_CLOSED|\n                             +-----------+                  +---------+\n                                        All subflows in CLOSED\n                                            ------------\n                                        delete MPTCP PCB",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 17: Finite State Machine for Connection Closure",
      "ja": "図17：接続の閉鎖のための有限状態マシン"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Alan Ford Cisco Ruscombe Business Park Ruscombe, Berkshire RG10 9NN UK",
      "ja": "アラン・フォードシスコRuscombeビジネスパークRuscombe、バークシャーRG10 9NN英国"
    },
    {
      "indent": 3,
      "text": "EMail: alanford@cisco.com",
      "ja": "メールアドレス：alanford@cisco.com"
    },
    {
      "indent": 3,
      "text": "Costin Raiciu University Politehnica of Bucharest Splaiul Independentei 313 Bucharest Romania",
      "ja": "ブカレストSplaiul Independentei 313ブカレストルーマニアのコスティンRaiciu工科大学"
    },
    {
      "indent": 3,
      "text": "EMail: costin.raiciu@cs.pub.ro",
      "ja": "メールアドレス：costin.raiciu@cs.pub.ro"
    },
    {
      "indent": 3,
      "text": "Mark Handley University College London Gower Street London WC1E 6BT UK",
      "ja": "マーク・ハンドリーロンドン大学ガウアーストリートロンドンWC1E 6BT英国"
    },
    {
      "indent": 3,
      "text": "EMail: m.handley@cs.ucl.ac.uk",
      "ja": "メールアドレス：m.handley@cs.ucl.ac.uk"
    },
    {
      "indent": 3,
      "text": "Olivier Bonaventure Universite catholique de Louvain Pl. Ste Barbe, 2 Louvain-la-Neuve 1348 Belgium",
      "ja": "オリヴィエ・ボナベンチャールーヴァン・カトリック大学P1の。サントバーベ、1348年ベルギー2ルーバン・ラ・ヌーヴ"
    },
    {
      "indent": 3,
      "text": "EMail: olivier.bonaventure@uclouvain.be",
      "ja": "メールアドレス：olivier.bonaventure@uclouvain.be"
    }
  ]
}