{
  "title": {
    "text": "RFC 6731 - Improved Recursive DNS Server Selection for Multi-Interfaced Nodes",
    "ja": "RFC 6731 - マルチ式インタフェースノードの改善された再帰的なDNSサーバの選択"
  },
  "number": 6731,
  "created_at": "2019-10-29 23:57:17.026856+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     T. Savolainen\nRequest for Comments: 6731                                         Nokia\nCategory: Standards Track                                        J. Kato\nISSN: 2070-1721                                                      NTT\n                                                                T. Lemon\n                                                           Nominum, Inc.\n                                                           December 2012",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Improved Recursive DNS Server Selection for Multi-Interfaced Nodes",
      "ja": "マルチ式インタフェースノードの改善された再帰的なDNSサーバの選択"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "A multi-interfaced node is connected to multiple networks, some of which might be utilizing private DNS namespaces. A node commonly receives recursive DNS server configuration information from all connected networks. Some of the recursive DNS servers might have information about namespaces other servers do not have. When a multi-interfaced node needs to utilize DNS, the node has to choose which of the recursive DNS servers to use. This document describes DHCPv4 and DHCPv6 options that can be used to configure nodes with information required to perform informed recursive DNS server selection decisions.",
      "ja": "マルチ式インタフェースノードは、プライベートDNS名前空間を利用するかもしれないいくつかは複数のネットワークに接続されています。ノードは、一般的に、すべての接続されたネットワークからの再帰的DNSサーバの設定情報を受信します。再帰的なDNSサーバの中には、他のサーバが持っていない名前空間に関する情報を持っているかもしれません。マルチインターフェース接続ノードがDNSを利用する必要がある場合、ノードが使用する再帰的なDNSサーバのかを選択する必要があります。この文書は、情報に再帰的なDNSサーバーの選択決定を行うために必要な情報を持つノードを構成するために使用することができDHCPv4とDHCPv6のオプションについて説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6731.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6731で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2012 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n  1.1.  Requirements Language  . . . . . . . . . . . . . . . . . .  4\n2.  Private Namespaces and Problems for Multi-Interfaced Nodes . .  4\n  2.1.  Fully Qualified Domain Names with Limited Scopes . . . . .  4\n  2.2.  Network-Interface-Specific IP Addresses  . . . . . . . . .  5\n  2.3.  A Problem Not Fully Solved by the Described Solution . . .  6\n3.  Deployment Scenarios . . . . . . . . . . . . . . . . . . . . .  7\n  3.1.  CPE Deployment Scenario  . . . . . . . . . . . . . . . . .  7\n  3.2.  Cellular Network Scenario  . . . . . . . . . . . . . . . .  7\n  3.3.  VPN Scenario . . . . . . . . . . . . . . . . . . . . . . .  8\n  3.4.  Dual-Stack Accesses  . . . . . . . . . . . . . . . . . . .  8\n4.  Improved RDNSS Selection . . . . . . . . . . . . . . . . . . .  8\n  4.1.  Procedure for Prioritizing RDNSSes and Handling\n        Responses  . . . . . . . . . . . . . . . . . . . . . . . .  9\n  4.2.  RDNSS Selection DHCPv6 Option  . . . . . . . . . . . . . . 11\n  4.3.  RDNSS Selection DHCPv4 Option  . . . . . . . . . . . . . . 13\n  4.4.  Scalability Considerations . . . . . . . . . . . . . . . . 15\n  4.5.  Limitations on Use . . . . . . . . . . . . . . . . . . . . 15\n  4.6.  Coexistence of Various RDNSS Configuration Tools . . . . . 16\n  4.7.  Considerations on Follow-Up Queries  . . . . . . . . . . . 17\n  4.8.  Closing Network Interfaces and Local Caches  . . . . . . . 17\n5.  Example of a Node Behavior . . . . . . . . . . . . . . . . . . 17\n6.  Considerations for Network Administrators  . . . . . . . . . . 19\n7.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 20\n8.  Security Considerations  . . . . . . . . . . . . . . . . . . . 20\n  8.1.  Attack Vectors . . . . . . . . . . . . . . . . . . . . . . 20\n  8.2.  Trust Levels of Network Interfaces . . . . . . . . . . . . 21\n  8.3.  Importance of Following the Algorithm  . . . . . . . . . . 21\n9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n  9.1.  Normative References . . . . . . . . . . . . . . . . . . . 21\n  9.2.  Informative References . . . . . . . . . . . . . . . . . . 22\nAppendix A.  Possible Alternative Practices for RDNSS Selection  . 23\n  A.1.  Sending Queries Out on Multiple Interfaces in Parallel . . 23\n  A.2.  Search List Option for DNS Forward Lookup Decisions  . . . 23\n  A.3.  More-Specific Routes for Reverse Lookup Decisions  . . . . 24\n  A.4.  Longest Matching Prefix for Reverse Lookup Decisions . . . 24\nAppendix B.  DNSSEC and Multiple Answers Validating with\n             Different Trust Anchors . . . . . . . . . . . . . . . 24\nAppendix C.  Pseudocode for RDNSS Selection  . . . . . . . . . . . 24\nAppendix D.  Acknowledgements  . . . . . . . . . . . . . . . . . . 29",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A multi-interfaced node (MIF node) faces several problems a single-homed node does not encounter, as is described in [RFC6418]. This document studies in detail the problems private namespaces might cause for multi-interfaced nodes and provides a solution. The node might be implemented as a host or as a router.",
      "ja": "マルチインターフェースノード（MIFノード）[RFC6418]に記載されているように、単一のホームノードは遭遇しないいくつかの問題に直面しています。詳細にこの文書の研究では、問題のプライベート名前空間は、マルチインターフェース接続ノードに対して原因と解決策を提供することがあります。ノードは、ホストとして、あるいはルータとして実装される可能性があります。"
    },
    {
      "indent": 3,
      "text": "We start from the premise that network operators sometimes include private, but still globally unique, namespaces in the answers they provide from Recursive DNS Servers (RDNSSes) and that those private namespaces are at least as useful to nodes as the answers from the public DNS. When private namespaces are visible for a node, some RDNSSes have information other RDNSSes do not have. The node ought to be able to query the RDNSS that can resolve the query regardless of whether the answer comes from the public DNS or a private namespace.",
      "ja": "私たちは、ネットワークオペレータは時々プライベート、まだ世界的にユニークな、再帰的なDNSサーバー（RDNSSes）から、それらが提供する答えで名前空間と、それらのプライベート名前空間は、パブリックDNSからの回答としてノードに、少なくともとして有用であることが含まれていることを前提からスタート。プライベート名前空間は、ノードのために表示されている場合は、いくつかのRDNSSesはありません情報その他RDNSSesを持っています。ノードは関係なく、答えは、パブリックDNSまたはプライベートの名前空間から来ているかどうかのクエリを解決できるRDNSSを照会することができるはずです。"
    },
    {
      "indent": 3,
      "text": "An example of an application that benefits from multi-interfacing is a web browser that commonly accesses many different destinations, each of which is available on only one network. The browser therefore needs to be able to communicate over different network interfaces, depending on the destination it is trying to reach.",
      "ja": "マルチインタフェースの恩恵を受けるアプリケーションの一例は、一般的に1つのネットワークのみで提供されて、それぞれが多くの異なった目的地を、アクセスするWebブラウザです。ブラウザは、したがって、到達しようとしている宛先に応じて、異なるネットワークインタフェースを介して通信できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Selection of the correct interface and source address is often crucial in the networks using private namespaces. In such deployments, the destination's IP addresses might only be reachable on the network interface over which the destination's name was resolved. Henceforth, the solution described in this document is assumed to be commonly used in combination with tools for delivering additional routing and source and destination address selection policies (e.g., [RFC4191] and [RFC3442].",
      "ja": "正しいインタフェースとソースアドレスの選択は、プライベート名前空間を使用してネットワークにしばしば非常に重要です。このような展開では、送信先のIPアドレスは、宛先の名前が解決された先のネットワークインターフェイス上で到達可能であるかもしれません。今後、この文書に記載された溶液は、一般的に追加のルーティングおよび送信元と宛先アドレス選択ポリシー（例えば、[RFC4191]及び[RFC3442]を送達するためのツールと組み合わせて使用​​することを想定しています。"
    },
    {
      "indent": 3,
      "text": "This document is organized in the following manner. Background information about problem descriptions and example deployment scenarios are included in Sections 2 and 3. Section 4 contains all normative descriptions for DHCP options and node behavior. Informative Section 5 illustrates behavior of a node implementing functionality described in Section 4. Section 6 contains normative guidelines related to creation of private namespaces. The IANA considerations are in Section 7. Informational Section 8 summarizes identified security considerations.",
      "ja": "この文書は、次のように構成されています。問題の説明と例の展開シナリオについての背景情報は、セクション2に含まれており、3節4は、DHCPオプションおよびノー​​ドの振る舞いのためのすべての規範的な記述が含まれています。参考第5節では、プライベート名前空間の創造に関連する規範的なガイドラインが含まれている第4項第6節で説明したノードの実装機能の動作を示しています。 IANAの考慮事項は、第7節情報セクション8は、識別されたセキュリティ上の考慮事項をまとめたものです。"
    },
    {
      "indent": 3,
      "text": "Appendix A describes best current practices that are possible with tools preceding this document and that are possibilities on networks not supporting the solution described in this document. Appendix B discusses a scenario where multiple answers are possible to validate, but with different trust anchors. Appendix C illustrates with pseudocode the functionality described in Section 4.",
      "ja": "付録Aには、ツールは、この文書の前やネットワーク上の可能性は、この文書で説明するソリューションをサポートしていないことで可能であり、現在のベストプラクティスについて説明します。付録Bは、異なるトラストアンカーと、複数回答が検証可能なシナリオについて説明します。付録Cは、擬似コードのセクション4で説明した機能を示します。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Private Namespaces and Problems for Multi-Interfaced Nodes",
      "section_title": true,
      "ja": "マルチ式インタフェースノード2.プライベート名前空間と問題点"
    },
    {
      "indent": 3,
      "text": "This section describes two private namespace scenarios related to node multi-interfacing for which the procedure described in Section 4 provides a solution. Additionally, Section 2.3 describes a problem for which this document provides only a partial solution.",
      "ja": "このセクションはセクション4に記載された手順は、解決策を提供するためのマルチインタフェースノードに関連する2つのプライベート名前空間のシナリオを説明しています。また、2.3節では、この文書は部分的にしか解決策を提供している問題について説明します。"
    },
    {
      "indent": 0,
      "text": "2.1. Fully Qualified Domain Names with Limited Scopes",
      "section_title": true,
      "ja": "2.1. 限定スコープとの完全修飾ドメイン名"
    },
    {
      "indent": 3,
      "text": "A multi-interfaced node can be connected to one or more networks that are using private namespaces. As an example, the node can simultaneously open a Wireless LAN (WLAN) connection to the public Internet, a cellular connection to an operator network, and a Virtual Private Network (VPN) connection to an enterprise network. When an application initiates a connection establishment to a Fully Qualified Domain Name (FQDN), the node needs to be able to choose the right RDNSS for making a successful DNS query. This is illustrated in Figure 1. An FQDN for a public name can be resolved with any RDNSS, but for an FQDN of the private name of an enterprise's or operator's service, the node needs to be able to correctly select the right RDNSS for the DNS resolution, i.e., do also network interface selection already before destination's IP address is known.",
      "ja": "マルチインターフェースノードは、プライベート名前空間を使用して一つ以上のネットワークに接続することができます。一例として、ノードが同時に公衆インターネットへのワイヤレスLAN（WLAN）接続、オペレータネットワークへのセルラ接続、および企業ネットワークへの仮想プライベートネットワーク（VPN）接続を開くことができます。アプリケーションが完全修飾ドメイン名（FQDN）への接続の確立を開始すると、ノードが成功したDNSクエリを作成するための権利RDNSSを選択できるようにする必要があります。これは、公共の名前については、図1】FQDNに例示されている任意のRDNSSで解決することができますが、企業のやオペレータのサービスのプライベート名のFQDNのために、ノードが正しくDNSのための右のRDNSSを選択できるようにする必要があります解像度、すなわち、送信先のIPアドレスが知られる前にも、既にインタフェースの選択をネットワーク行います。"
    },
    {
      "indent": 3,
      "text": "                         +---------------+\n                         | RDNSS with    |    |   Enterprise\n+------+                 | public +      |----|   Intranet\n|      |                 | enterprise's  |    |\n|      |===== VPN =======| private names |    |\n|      |                 +---------------+  +----+\n| MIF  |                                    | FW |\n| node |                                    +----+\n|      |                 +---------------+    |\n|      |----- WLAN ------| RDNSS with    |----|   Public\n|      |                 | public names  |    |   Internet\n|      |                 +---------------+  +----+\n|      |                                    | FW |\n|      |                 +---------------+  +----+\n|      |---- cellular ---| RDNSS with    |    |\n+------+                 | public +      |    |   Operator\n                         | operator's    |----|   Intranet\n                         | private names |    |\n                         +---------------+",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 1: Private DNS Namespaces Illustrated",
      "ja": "図1：プライベートDNS名前空間は、イラスト"
    },
    {
      "indent": 0,
      "text": "2.2. Network-Interface-Specific IP Addresses",
      "section_title": true,
      "ja": "2.2. ネットワークインターフェイス固有のIPアドレス"
    },
    {
      "indent": 3,
      "text": "In the second problem, an FQDN is valid and resolvable via different network interfaces, but to different and not necessarily globally reachable IP addresses, as is illustrated in Figure 2. The node's routing, source, and destination address selection mechanism has to ensure the destination's IP address is only used in combination with source IP addresses of the network interface on which the name was resolved.",
      "ja": "、ノードのルーティング2.図に示されているソース、宛先アドレス選択メカニズムは、先のを確実にするために有しているように、第2の問題では、FQDNは、異なるネットワークインタフェースを介して、異なる必ずしもグローバルに到達可能なIPアドレスに有効で解決可能ですIPアドレスは、名前だけが解決されたネットワークインタフェースの送信元IPアドレスとの組み合わせで使用されています。"
    },
    {
      "indent": 3,
      "text": "                         +--------------------|      |\n+------+   IPv6          | RDNSS A            |------| IPv6\n|      |-- interface 1 --| saying Peer is     |      |\n|      |                 | at: 2001:0db8:0::1 |      |\n| MIF  |                 +--------------------+   +------+\n| node |                                          | Peer |\n|      |                 +--------------------+   +------+\n|      |   IPv6          | RDNSS B            |      |\n|      |-- interface 2 --| saying Peer is     |      |\n+------+                 | at: 2001:0db8:1::1 |------| IPv6\n                         +--------------------+      |",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 2: Private DNS Namespaces and Different IP Addresses for an FQDN on Interfaces 1 and 2",
      "ja": "図2：プライベートDNS名前空間とインタフェース1及び2のFQDNのための異なるIPアドレス"
    },
    {
      "indent": 3,
      "text": "A similar situation can happen with IPv6 protocol translation and AAAA record synthesis [RFC6147]. A synthetic AAAA record is guaranteed to be valid only on the network on which it was synthesized. Figure 3 illustrates a scenario where the peer's IPv4 address is synthesized into different IPv6 addresses by RDNSSes A and B.",
      "ja": "同様の状況は、IPv6プロトコル変換およびAAAAレコード合成[RFC6147]で発生することができます。合成AAAAレコードは唯一それが合成されたネットワーク上で有効であることが保証されます。図3は、RDNSSes A及びBによってピアのIPv4アドレスは、異なるIPv6アドレスに合成されたシナリオを示し"
    },
    {
      "indent": 3,
      "text": "                         +-------------------|    +-------+\n+------+   IPv6          | RDNSS A           |----| NAT64 |\n|      |-- interface 1 --| saying Peer is    |    +-------+\n|      |                 | at: A_Pref96:IPv4 |       |\n| MIF  |                 +-------------------+       |   +------+\n| node |                                        IPv4 +---| Peer |\n|      |                 +-------------------+       |   +------+\n|      |   IPv6          | RDNSS B           |       |\n|      |-- interface 2 --| saying Peer is    |    +-------+\n+------+                 | at: B_Pref96:IPv4 |----| NAT64 |\n                         +-------------------+    +-------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "   Figure 3: AAAA Synthesis Results in\nNetwork-Interface-Specific IPv6 Addresses",
      "raw": true
    },
    {
      "indent": 3,
      "text": "It is worth noting that network-specific IP addresses can also cause problems for a single-homed node, if the node retains DNS cache during movement from one network to another. After the network change, a node can have entries in its DNS cache that are no longer correct or appropriate for its new network position.",
      "ja": "これは、ノード1つのネットワークから別の移動中にDNSキャッシュを保持している場合、ネットワーク固有のIPアドレスでも、シングルホームノードのための問題を引き起こす可能性があることは注目に値します。ネットワークの変更後、ノードはもはや正しいか、その新しいネットワーク位置に適したそのDNSキャッシュのエントリを持つことができます。"
    },
    {
      "indent": 0,
      "text": "2.3. A Problem Not Fully Solved by the Described Solution",
      "section_title": true,
      "ja": "2.3. 完全に記載された解決策で解決しない問題"
    },
    {
      "indent": 3,
      "text": "A more complex scenario is an FQDN, which in addition to possibly resolving into network-interface-specific IP addresses, identifies on different network interfaces completely different peer entities with potentially different sets of service offerings. In an even more complex scenario, an FQDN identifies a unique peer entity, but one that provides different services on its different network interfaces. The solution described in this document is not able to tackle these higher-layer issues. In fact, these problems might be solvable only by manual user intervention.",
      "ja": "より複雑なシナリオでは、おそらくネットワークインターフェース固有のIPアドレスに解決するに加えて、サービス提供の潜在的に異なるセットを異なるネットワークインターフェイス完全に異なるピアエンティティに識別するFQDNです。さらに複雑なシナリオでは、FQDNは、一意のピアエンティティを識別し、その別のネットワークインターフェイス上で異なるサービスを提供するもの。この文書で説明するソリューションは、これらの上位層の問題に取り組むことができません。実際には、これらの問題は、マニュアル、ユーザの介入によって解けるかもしれません。"
    },
    {
      "indent": 3,
      "text": "However, when DNS Security (DNSSEC) is used, the DNSSEC validation procedure can provide assistance for selecting correct responses for some, but not all, use cases. A node might prefer to use the DNS answer that validates with the preferred trust anchor.",
      "ja": "DNSセキュリティ（DNSSEC）を使用する場合ただし、DNSSECの検証手順は、いくつかの正しい応答を選択するための支援を提供することができ、すべてではないが、例を使用します。ノードが優先トラストアンカーを検証DNS応答を使用することを好むかもしれません。"
    },
    {
      "indent": 0,
      "text": "3. Deployment Scenarios",
      "section_title": true,
      "ja": "3.展開シナリオ"
    },
    {
      "indent": 3,
      "text": "This document has been written with three particular deployment scenarios in mind. The first is a Customer Premises Equipment (CPE) with two or more uplink Virtual Local Area Network (VLAN) connections. The second scenario involves a cellular device with two uplink Internet connections: WLAN and cellular. The third scenario is for VPNs, where use of a local RDNSS might be preferred for latency reasons, but the enterprise's RDNSS has to be used to resolve private names used by the enterprise.",
      "ja": "この文書では、心の中で特定の3つの展開シナリオで書かれています。最初は、二つ以上のアップリンク仮想ローカルエリアネットワーク（VLAN）接続で顧客宅内機器（CPE）です。 WLANおよびセルラ：第2のシナリオは、2つのアップリンクインターネット接続を有する携帯デバイスを含みます。第三のシナリオは、ローカルRDNSSの使用は、待ち時間の理由から好ましいかもしれないのVPNのためですが、企業のRDNSSは、企業で使用されるプライベート名を解決するために使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "In this section, we are referring to the RDNSS preference values defined in Section 4. The purpose of that is to illustrate when administrators might choose to utilize the different preference values.",
      "ja": "このセクションでは、我々は第4節で定義されたRDNSSのプリファレンス値を参照していることの目的は、管理者が別のプリファレンス値を利用することを選択する可能性がある場合説明することです。"
    },
    {
      "indent": 0,
      "text": "3.1. CPE Deployment Scenario",
      "section_title": true,
      "ja": "3.1.  CPEの展開シナリオ"
    },
    {
      "indent": 3,
      "text": "A home gateway can have two uplink connections leading to different networks, as described in [WITHOUT-IPV6NAT]. In the two-uplink scenario, only one uplink connection leads to the Internet, while the other uplink connection leads to a private network utilizing private namespaces.",
      "ja": "[無しIPV6NAT]に記載されているように、ホームゲートウェイは、異なるネットワークにつながる2つのアップリンク接続を有することができます。他のアップリンク接続は、プライベート名前空間を利用し、プライベートネットワークにつながりながら、二アップリンクのシナリオでは、唯一のアップリンク接続には、インターネットにつながります。"
    },
    {
      "indent": 3,
      "text": "It is desirable that the CPE does not have to send DNS queries over both uplink connections, but instead, CPE need only send default queries to the RDNSS of the interface leading to the Internet and queries related to the private namespace to the RDNSS of the private network. This can be configured by setting the RDNSS of the private network to know about listed domains and networks, but not to be a default RDNSS.",
      "ja": "CPEは、両方のアップリンク接続を介してDNSクエリを送信する必要がないことが望ましいが、代わりに、CPEは、イン​​ターネットにつながるインターフェースのRDNSSとプライベートのRDNSSにプライベート名前空間に関連するクエリにデフォルトのクエリを送信する必要が通信網。これは、リストされたドメインやネットワークについて知っているプラ​​イベートネットワークのRDNSSを設定することで設定できますが、デフォルトのRDNSSではありません。"
    },
    {
      "indent": 3,
      "text": "In this scenario, the legacy hosts can be supported by deploying DNS proxy on the CPE and configuring hosts in the LAN to talk to the DNS proxy. However, updated hosts would be able to talk directly to the correct RDNSS of each uplink ISP's RDNSS. It is a deployment decision whether the updated hosts would be pointed to a DNS proxy or to actual RDNSSes.",
      "ja": "このシナリオでは、レガシーホストはCPEにDNSプロキシを展開し、DNSプロキシに話をするLAN内のホストを設定することによってサポートすることができます。しかし、更新されたホストは、各アップリンクISPのRDNSSの正しいRDNSSに直接話をすることができるだろう。更新されたホストがDNSプロキシまたは実際のRDNSSesに指摘されるかどうか展開決定です。"
    },
    {
      "indent": 3,
      "text": "Depending on actual deployments, all VLAN connections might be considered trusted.",
      "ja": "実際の展開によっては、すべてのVLAN接続は、信頼できると考えられるかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.2. Cellular Network Scenario",
      "section_title": true,
      "ja": "3.2. セルラーネットワークのシナリオ"
    },
    {
      "indent": 3,
      "text": "A cellular device can have both WLAN and cellular network interfaces up. In such a case, it is often desirable to use WLAN by default, except for the connections that the cellular network operator wants to go over the cellular interface. The use of WLAN for DNS queries likely improves the power consumption of cellular devices and often provides lower latency. The cellular network might utilize private names; hence, the cellular device needs to ask for those through the cellular interface. This can be configured by setting the RDNSS of the cellular network to be of low preference and listing the domains and networks related to the cellular network's private namespaces as being available via the cellular network's RDNSS. This will cause a node to send DNS queries by default to the RDNSS of the WLAN interface (that is, by default, considered to be of medium preference) and queries related to private namespaces to the RDNSS of the cellular interface.",
      "ja": "携帯デバイスは、WLANとセルラーネットワークの両方のインターフェースを有することができます。このような場合には、セルラーネットワークオペレータは、セルラーインターフェイスを介して行きたいの接続を除いて、デフォルトでWLANを使用することが望ましいことが多いです。 DNSクエリのためのWLANを使用することは、おそらく、携帯機器の消費電力を改善し、多くの場合、低レイテンシーを提供します。セルラーネットワークは、プライベートの名前を利用かもしれません。したがって、携帯デバイスは、セルラーインターフェイスを介してそれらのために依頼する必要があります。これは、低い優先順位のものであるとセルラーネットワークのRDNSSを設定し、セルラーネットワークのRDNSS経由で利用可能であるとして、セルラーネットワークのプライベート名前空間に関連するドメインとネットワークをリストすることによって設定することができます。これは、WLANインタフェースのRDNSS（つまり、デフォルトでは、メディアの好みであると考えられる）とセルラインタフェースのRDNSSにプライベート名前空間に関連するクエリにデフォルトでDNSクエリを送信するノードが発生します。"
    },
    {
      "indent": 3,
      "text": "In this scenario, the cellular interface can be considered trusted and WLAN oftentimes untrusted.",
      "ja": "このシナリオでは、セルラーインターフェイスは、信頼できるとWLANしばしば信頼できないと考えることができます。"
    },
    {
      "indent": 0,
      "text": "3.3. VPN Scenario",
      "section_title": true,
      "ja": "3.3.  VPNシナリオ"
    },
    {
      "indent": 3,
      "text": "Depending on a deployment, there might be interest in using VPN only for the traffic destined to a enterprise network. The enterprise might be using private namespaces; hence, related DNS queries need to be sent over VPN to the enterprise's RDNSS, while by default, the RDNSS of a local access network might be used for all other traffic. This can be configured by setting the RDNSS of the VPN interface to be of low preference and listing the domains and networks related to an enterprise network's private namespaces being available via the RDNSS of the VPN interface. This will cause a node to send DNS queries by default directly to the RDNSS of the WLAN interface (that is, by default, considered to be of medium preference) and queries related to private namespaces to the RDNSS of the VPN interface.",
      "ja": "展開によっては、唯一の企業ネットワーク宛てのトラフィックのためにVPNを使用することに関心があるかもしれません。企業は、プライベート名前空間を使用している場合があります。したがって、関連するDNSクエリは、デフォルトでは、ローカルアクセスネットワークのRDNSSが他のすべてのトラフィックのために使用されるかもしれないが、企業のRDNSSにVPN経由で送信される必要があります。これは、低優先であるとVPNインターフェースのRDNSSを設定し、VPNインターフェースのRDNSSを介して利用可能であるエンタープライズネットワークのプライベート名前空間に関連するドメインとネットワークをリストすることによって構成することができます。これは、VPNインターフェイスのRDNSSにプライベート名前空間に関連するWLANインターフェイス（つまり、デフォルトでは、メディアの好みであると考えられる）とクエリのRDNSSに直接、デフォルトでDNSクエリを送信するノードが発生します。"
    },
    {
      "indent": 3,
      "text": "In this scenario, the VPN interface can be considered trusted and the local access network untrusted.",
      "ja": "このシナリオでは、VPNインターフェイスは、信頼できるとローカルアクセスネットワークが信頼できないと考えることができます。"
    },
    {
      "indent": 0,
      "text": "3.4. Dual-Stack Accesses",
      "section_title": true,
      "ja": "3.4. デュアルスタックアクセス数"
    },
    {
      "indent": 3,
      "text": "In all three scenarios, one or more of the connected networks can support both IPv4 and IPv6. In such a case, both or either of DHCPv4 and DHCPv6 can be used to learn RDNSS selection information.",
      "ja": "すべての3つのシナリオでは、接続されたネットワークのうちの1つ以上は、IPv4とIPv6の両方をサポートすることができます。このような場合には、DHCPv4とDHCPv6の両方またはいずれかがRDNSS選択情報を学習するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "4. Improved RDNSS Selection",
      "section_title": true,
      "ja": "4.改善さRDNSSの選択"
    },
    {
      "indent": 3,
      "text": "This section describes DHCP options and a procedure that a (stub/ proxy) resolver can utilize for improved RDNSS selection in the face of private namespaces and multiple simultaneously active network interfaces. The procedure is subject to limitations of use as described in Section 4.5. The pseudocode in Appendix C illustrates how the improved RDNSS selection works.",
      "ja": "このセクションでは、DHCPオプションと（スタブ/プロキシ）リゾルバは、プライベート名前空間と、複数の同時にアクティブなネットワークインターフェースの面で改善されたRDNSS選択のために利用することができる手順が記載されています。 4.5節で説明したように手順は、使用の制限を受けています。付録Cでの擬似コードは改善RDNSSの選択がどのように機能するかを示しています。"
    },
    {
      "indent": 0,
      "text": "4.1. Procedure for Prioritizing RDNSSes and Handling Responses",
      "section_title": true,
      "ja": "4.1.  RDNSSesを優先順位付けし、応答を処理するための手順"
    },
    {
      "indent": 3,
      "text": "A resolver SHALL build a preference list of RDNSSes it will contact depending on the query. To build the list in an optimal way, a node SHALL request for RDNSS selection information with the DHCP options defined in Sections 4.2 and 4.3 before any DNS queries need to be made. With help of the received RDNSS selection information, the node can determine if any of the available RDNSSes have special knowledge about specific domains needed for forward DNS lookups or network addresses (later referred as \"network\") needed for reverse DNS lookups.",
      "ja": "リゾルバは、クエリに応じてご連絡いたしますRDNSSesの優先リストを構築するものとします。すべてのDNSクエリがなされる必要がある前に、最適な方法でリストを作成するには、ノードは、セクション4.2と4.3で定義されたDHCPオプションとRDNSS選択情報を要求しないものとします。利用可能なRDNSSesのいずれかが（後に「ネットワーク」と呼ばれる）順方向DNSルックアップまたはネットワーク・アドレスのために必要な特定のドメインについての特別な知識を持っている場合、受信しRDNSS選択情報の助けを借りて、ノードが決定することができ、逆DNSルックアップのために必要。"
    },
    {
      "indent": 3,
      "text": "A resolver lacking more specific information can assume that all information is available from any RDNSS of any network interface. The RDNSSes learned by other RDNSS address configuration methods can be considered as default RDNSSes, but preference-wise, they MUST be handled as medium preference RDNSSes (see also Section 4.6).",
      "ja": "より具体的な情報を欠いているリゾルバは、すべての情報は、任意のネットワークインターフェースの任意RDNSSから入手可能であると仮定することができます。他のRDNSSアドレスの設定方法は、デフォルトのRDNSSesとして考えられているが、好みワイズすることができ、彼らはメディア優先RDNSSesとして扱われなければならないことで学んだRDNSSes（また、4.6節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "When a DNS query needs to be made, the resolver MUST give highest preference to the RDNSSes explicitly known to serve a matching domain or network. The resolver MUST take into account differences in trust levels (see Section 8.2) of pieces of received RDNSS selection information. The resolver MUST prefer RDNSSes of trusted interfaces. The RDNSSes of untrusted interfaces can be of highest preference only if the trusted interfaces specifically configures low preference RDNSSes. The non-exhaustive list of cases in Figure 4 illustrates how the different trust levels of received RDNSS selection information influence the RDNSS selection logic. In Figure 4, \"Medium\", \"High\", and \"Low\" indicate the explicitly configured RDNSS's preference over other RDNSSes. The \"Medium\" preference is also used with RDNSSes for which no explicit preference configuration information is available. The \"Specific domains\" in Figure 4 indicate the explicitly configured \"Domains and networks\" private namespace information that a particular RDNSS has.",
      "ja": "DNSクエリが行われる必要がある場合は、リゾルバは明示的に一致するドメインやネットワークサービスを提供することが知られているRDNSSesを最優先しなければなりません。リゾルバは、信頼レベルの違いを考慮に入れなければなら受信RDNSS選択情報の（8.2節を参照してください）。リゾルバは、信頼できるインターフェイスのRDNSSesを好むしなければなりません。信頼できないインターフェイスのRDNSSesは、信頼できるインターフェイスは、具体的には、低優先RDNSSesを構成する場合にのみ、最高優先とすることができます。図4のケースの非網羅的なリストは、受信したRDNSS選択情報の異なる信頼レベルがRDNSS選択ロジックに影響を与える方法を示します。図4では、「中」、「高」、「低」は、他のRDNSSesオーバー明示的に設定RDNSSの好みを示します。 「中」優先も明示的なプリファレンス設定情報が利用できないためRDNSSesと共に使用されます。図4中の「特定のドメイン」は、特定のRDNSSが有するプライベート名前空間情報を明示的に設定「ドメインとネットワーク」を示します。"
    },
    {
      "indent": 3,
      "text": "A resolver MUST prioritize between equally trusted RDNSSes with the help of the DHCP option preference field. The resolver MUST NOT prioritize less trusted RDNSSes higher than trusted, even in the case when a less trusted RDNSS would apparently have additional information. In the case of all other things being equal, the resolver can make the prioritization decision based on its internal preferences.",
      "ja": "リゾルバは、DHCPオプションの優先分野の助けを借りて、同じように、信頼できるRDNSSesの間で優先順位を付けなければなりません。信頼性の低いRDNSSが明らかに付加的な情報を持っているだろうというとき、リゾルバは、場合であっても、信頼されるよりも高い信頼性の低いRDNSSesに優先順位を付けてはなりません。他のすべてのものが等しい場合には、リゾルバは、その内部の設定に基づいて優先順位付けの決定を行うことができます。"
    },
    {
      "indent": 3,
      "text": "   Information from       | Information from       | Resulting RDNSS\n   more trusted           | less trusted           | preference\n   interface A            | interface B            | selection\n--------------------------+------------------------+-----------------\n1. Medium preference      | Medium preference      | Default:\n   default                | default                | A, then B\n--------------------------+------------------------+-----------------\n2. Medium preference      | High preference default| Default:\n   default                |                        | A, then B\n                          | Specific domains       | Specific:\n                          |                        | A, then B\n--------------------------+------------------------+-----------------\n3. Low preference default | Medium preference      | Default:\n                          | default                | B, then A\n--------------------------+------------------------+-----------------\n4. Low preference default | Medium preference      | Default:\n                          | default                | B, then A\n   Specific domains       |                        | Specific:\n                          |                        | A, then B\n--------------------------+------------------------+-----------------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 4: RDNSS Selection in the Case of Different Trust Levels",
      "ja": "図4：異なる信頼レベルのケースでRDNSSセレクション"
    },
    {
      "indent": 3,
      "text": "Because DNSSEC provides cryptographic assurance of the integrity of DNS data, it is necessary to prefer data that can be validated under DNSSEC over data that cannot. There are two ways that a node can determine that data is valid under DNSSEC. The first is to perform DNSSEC validation itself. The second is to have a secure connection to an authenticated RDNSS and to rely on that RDNSS to perform DNSSEC validation (signaling that it has done so using the AD bit). DNSSEC is necessary to detect forged responses, and without it any DNS response could be forged or altered. Unless the DNS responses have been validated with DNSSEC, a node cannot make a decision to prefer data from any interface with any great assurance.",
      "ja": "DNSSECは、DNSデータの整合性の暗号保証を提供するので、できないデータ上でDNSSECの下で検証することができるデータを好むことが必要です。ノードは、データがDNSSECの下に有効であると判断することができる2つの方法があります。最初は、DNSSEC検証自体を実行することです。第二は、認証RDNSSへの安全な接続を有し、（それがADのビットを使用して、そうしたことをシグナリング）DNSSEC検証を実行するために、そのRDNSSに依存することです。 DNSSECは、偽造応答を検出する必要がある、そしてそれなしDNS応答は、偽造又は変更することができます。 DNS応答がDNSSECで検証されていない限り、ノードは、すべての偉大な保証を持つ任意のインタフェースからデータを好むために決定を下すことはできません。"
    },
    {
      "indent": 3,
      "text": "A node SHALL send requests to RDNSSes in the order defined by the preference list until an acceptable reply is received, all replies are received, or a timeout occurs. In the case of a requested name matching to a specific domain or network rule accepted from any interface, a DNSSEC-aware resolver MUST NOT proceed with a reply that cannot be validated using DNSSEC until all RDNSSes on the preference list have been contacted or timed out. This protects against possible redirection attacks. In the case of the requested name not matching to any specific domain or network, the first received response from any RDNSS can be considered acceptable. A DNSSEC-aware node MAY always contact all RDNSSes in an attempt to receive a response that can be validated, but contacting all RDNSSes is not mandated for the default case as that would consume excess resources in some deployments.",
      "ja": "許容される応答が受信されるまで、優先リストによって定義された順序でRDNSSesに要求を送信しなければならないノードは、すべての応答が受信され、またはタイムアウトが発生します。優先リスト上のすべてのRDNSSesが連絡またはタイムアウトになってきたまで、任意のインターフェイスから受け入れられた特定のドメインまたはネットワークルールに一致する要求された名前の場合は、DNSSEC対応リゾルバは、DNSSECを使用して検証することはできません返信を進めてはなりません。これは、可能なリダイレクション攻撃から保護します。要求された名前は、任意の特定のドメインまたはネットワークに一致しない場合には、任意のRDNSSから最初に受信応答が許容されると考えることができます。 DNSSEC対応ノードは、常に検証することができます応答を受信するための試みで、すべてのRDNSSesに連絡することができ、それは、いくつかの展開で過剰なリソースを消費することになるように、すべてのRDNSSesを接触させて、デフォルトの場合のために義務付けられていません。"
    },
    {
      "indent": 3,
      "text": "In the case of a validated NXDOMAIN response being received from an RDNSS that can provide answers for the queried name, a node MUST NOT accept non-validated replies from other RDNSSes (see Appendix B for considerations related to multiple trust anchors).",
      "ja": "照会名の回答を提供することができるRDNSSから受信され検証さNXDOMAIN応答の場合に、ノードは、（複数のトラストアンカーに関連する考慮事項については、付録Bを参照）、他のRDNSSesから非検証応答を受け入れてはいけません。"
    },
    {
      "indent": 0,
      "text": "4.2. RDNSS Selection DHCPv6 Option",
      "section_title": true,
      "ja": "4.2.  RDNSS選択DHCPv6のオプション"
    },
    {
      "indent": 3,
      "text": "DHCPv6 option described below can be used to inform resolvers what RDNSS can be contacted when initiating forward or reverse DNS lookup procedures. This option is DNS record type agnostic and applies, for example, equally to both A and AAAA queries.",
      "ja": "下記のDHCPv6のオプションは、前方の開始時に接触させることができるものをRDNSSリゾルバを知らせるか、DNSルックアップ手順を逆に使用することができます。このオプションは、DNSレコードの種類にとらわれないで、同じように両方のAとAAAAクエリに、例えば、適用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    OPTION_RDNSS_SELECTION     |         option-len            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|            DNS-recursive-name-server (IPv6 address)           |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Reserved  |prf|                                               |\n+-+-+-+-+-+-+-+-+          Domains and networks                 |\n|                          (variable length)                    |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 5: DHCPv6 Option for Explicit Domain Configuration",
      "ja": "図5：明示的なドメイン構成のためのDHCPv6オプション"
    },
    {
      "indent": 3,
      "text": "option-code: OPTION_RDNSS_SELECTION (74)",
      "ja": "オプションコード：OPTION_RDNSS_SELECTION（74）"
    },
    {
      "indent": 3,
      "text": "option-len: Length of the option in octets",
      "ja": "オプション-LEN：オクテット内のオプションの長さ"
    },
    {
      "indent": 3,
      "text": "DNS-recursive-name-server: An IPv6 address of RDNSS",
      "ja": "DNS再帰名サーバ：RDNSSのIPv6アドレス"
    },
    {
      "indent": 3,
      "text": "Reserved: Field reserved for the future. MUST be set to zero and MUST be ignored on receipt.",
      "ja": "予約：フィールドは、将来のために予約。ゼロに設定しなければならなくて、領収書の上で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "prf: RDNSS preference:",
      "ja": "PRF：RDNSS好み："
    },
    {
      "indent": 9,
      "text": "01 High\n00 Medium\n11 Low\n10 Reserved",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Reserved preference value (10) MUST NOT be sent. On receipt, the Reserved value MUST be treated as Medium preference (00).",
      "ja": "予約優先値（10）を送ってはいけません。受信時に、予約値は、中優先（00）のように扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "Domains and networks: The list of domains for forward DNS lookup and networks for reverse DNS lookup about which the RDNSS has special knowledge. Field MUST be encoded as specified in Section 8 of [RFC3315]. A special domain of \".\" is used to indicate capability to resolve global names and act as a default RDNSS. Lack of a \".\" domain on the list indicates that the RDNSS only has information related to listed domains and networks. Networks for reverse mapping are encoded as defined for IP6.ARPA [RFC3596] or IN-ADDR.ARPA [RFC2317].",
      "ja": "ドメインとネットワーク：RDNSSは特別な知識を持っているかについてDNSの逆引き参照のための前方DNSルックアップのためのドメインおよびネットワークのリスト。 [RFC3315]のセクション8で指定されるようにフィールドが符号化されなければなりません。の特別なドメイン「」デフォルトのRDNSSとしてグローバル名と行為を解決するための能力を示すために使用されます。の欠如「」リスト上のドメインはRDNSSのみ記載されているドメインやネットワークに関連する情報を持っていることを示しています。 IP6.ARPA [RFC3596]またはIN-ADDR.ARPA [RFC2317]について定義された通り逆マッピングするためのネットワークが符号化されます。"
    },
    {
      "indent": 3,
      "text": "A node SHOULD include the Option Request Option (OPTION_ORO [RFC3315]) in a DHCPv6 request with the OPTION_RDNSS_SELECTION option code to inform the DHCPv6 server about the support for the improved RDNSS selection logic. The DHCPv6 server receiving this information can then choose to provision RDNSS addresses only with OPTION_RDNSS_SELECTION.",
      "ja": "ノードは、改善されたRDNSS選択ロジックのサポートについてDHCPv6サーバに通知するOPTION_RDNSS_SELECTIONオプションコードでDHCPv6の要求にオプション要求オプション（OPTION_ORO [RFC3315]）を含むべきです。この情報を受信するDHCPv6サーバは、その後だけOPTION_RDNSS_SELECTIONで提供RDNSSアドレスを選択することができます。"
    },
    {
      "indent": 3,
      "text": "OPTION_RDNSS_SELECTION contains one or more domains of which the related RDNSS has particular knowledge. The option can occur multiple times in a single DHCPv6 message, if multiple RDNSSes are to be configured. This can be the case, for example, if a network link has multiple RDNSSes for reliability purposes.",
      "ja": "OPTION_RDNSS_SELECTION関連RDNSSが特定の知識を持っている1つの以上のドメインを含みます。複数RDNSSesが設定される場合、このオプションは、単一のDHCPv6メッセージに複数回発生する可能性があります。ネットワークリンクは、信頼性の目的のために複数RDNSSesを有している場合、これは、例えば、ケースとすることができます。"
    },
    {
      "indent": 3,
      "text": "The list of networks MUST cover all the domains configured in this option. The length of the included networks SHOULD be as long as possible to avoid potential collision with information received on other option instances or with options received from DHCP servers of other network interfaces. Overlapping networks are interpreted so that the resolver can use any of the RDNSSes for queries matching the networks.",
      "ja": "ネットワークのリストは、このオプションに設定されているすべてのドメインをカバーしなければなりません。含まれるネットワークの長さは、他のOptionインスタンスまたは他のネットワークインターフェイスのDHCPサーバから受信したオプションが受信された情報との潜在的な衝突を回避するためにできるだけ長くあるべきです。リゾルバがネットワークに一致クエリのRDNSSesのいずれかを使用することができるように、重複ネットワークが解釈されます。"
    },
    {
      "indent": 3,
      "text": "If OPTION_RDNSS_SELECTION contains an RDNSS address already learned from other DHCPv6 servers of the same network and contains new domains or networks, the node SHOULD append the information to the information received earlier. The node MUST NOT remove previously obtained information. However, the node SHOULD NOT extend the lifetime of earlier information either. When a conflicting RDNSS address is learned from a less trusted interface, the node MUST ignore the option.",
      "ja": "OPTION_RDNSS_SELECTIONがすでに同じネットワークの他のDHCPv6サーバから学んだRDNSSアドレスが含まれていて、新しいドメインやネットワークが含まれている場合、ノードは情報に情報を追加すべきである以前に受けました。ノードは、以前に取得した情報を削除してはなりません。しかし、ノードは、いずれか早い情報の寿命を延長すべきではありません。競合RDNSSアドレスが信頼性の低いインターフェイスから学習された場合、ノードは、オプションを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Like the RDNSS options of [RFC3646], OPTION_RDNSS_SELECTION MUST NOT appear in any other than the following DHCPv6 messages: Solicit, Advertise, Request, Renew, Rebind, Information-Request, and Reply.",
      "ja": "[RFC3646]のRDNSSオプションと同様に、OPTION_RDNSS_SELECTIONは以下のDHCPv6メッセージ以外にも現れてはなりません：、勧誘広告、リクエスト、更新、再バインド、情報リクエスト、および返信。"
    },
    {
      "indent": 3,
      "text": "The client SHALL periodically refresh information learned with OPTION_RDNSS_SELECTION. The information SHALL be refreshed on link-state changes, such as those caused by node mobility, and when renewing lifetimes of IPv6 addresses configured with DHCPv6. Additionally, the DHCPv6 Information Refresh Time Option, as specified in [RFC4242], can be used to control the update frequency.",
      "ja": "クライアントは、定期的にOPTION_RDNSS_SELECTIONで学習した情報を更新するものとします。情報は、ノードの移動によって引き起こされるもののようなリンク状態の変化、にリフレッシュ、とDHCPv6で構成IPv6アドレスの寿命を更新するときことSHALL。また、[RFC4242]で指定されたDHCPv6情報リフレッシュ時間オプションは、更新頻度を制御するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.3. RDNSS Selection DHCPv4 Option",
      "section_title": true,
      "ja": "4.3.  RDNSS選択のDHCPv4オプション"
    },
    {
      "indent": 3,
      "text": "The DHCPv4 option described below can be used to inform resolvers which RDNSS can be contacted when initiating forward or reverse DNS lookup procedures. This option is DNS record type agnostic and applies, for example, equally to both A and AAAA queries.",
      "ja": "以下で説明するのDHCPv4オプションが前進開始時RDNSSを接触させることができるリゾルバを知らせるか、DNSルックアップ手順を逆に使用することができます。このオプションは、DNSレコードの種類にとらわれないで、同じように両方のAとAAAAクエリに、例えば、適用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     CODE      |     Len       | Reserved  |prf|    Primary .. |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| .. DNS-recursive-name-server's IPv4 address   |  Secondary .. |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| .. DNS-recursive-name-server's IPv4 address   |               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |\n|                                                               |\n+                          Domains and networks                 |\n|                          (variable length)                    |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 6: DHCPv4 Option for Explicit Domain Configuration",
      "ja": "図6：明示的なドメイン構成のためのDHCPv4オプション"
    },
    {
      "indent": 3,
      "text": "option-code: RDNSS Selection (146)",
      "ja": "オプションコード：RDNSSセレクション（146）"
    },
    {
      "indent": 3,
      "text": "option-len: Length of the option in octets",
      "ja": "オプション-LEN：オクテット内のオプションの長さ"
    },
    {
      "indent": 3,
      "text": "Reserved: Field reserved for the future. MUST be set to zero and MUST be ignored on receipt.",
      "ja": "予約：フィールドは、将来のために予約。ゼロに設定しなければならなくて、領収書の上で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "prf: RDNSS preference:",
      "ja": "PRF：RDNSS好み："
    },
    {
      "indent": 9,
      "text": "01 High\n00 Medium\n11 Low\n10 Reserved",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Reserved preference value (10) MUST NOT be sent. On receipt, the Reserved value MUST be treated as Medium preference (00).",
      "ja": "予約優先値（10）を送ってはいけません。受信時に、予約値は、中優先（00）のように扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "Primary DNS-recursive-name-server's IPv4 address: Address of a primary RDNSS",
      "ja": "プライマリDNS再帰名サーバのIPv4アドレス：主要RDNSSの住所"
    },
    {
      "indent": 3,
      "text": "Secondary DNS-recursive-name-server's IPv4 address: Address of a secondary RDNSS or 0.0.0.0 if not configured",
      "ja": "セカンダリDNS再帰名サーバのIPv4アドレス：二次RDNSSまたは0.0.0.0のアドレスが設定されていない場合"
    },
    {
      "indent": 3,
      "text": "Domains and networks: The list of domains for forward DNS lookup and networks for reverse DNS lookup about which the RDNSSes have special knowledge. Field MUST be encoded as specified in Section 8 of [RFC3315]. A special domain of \".\" is used to indicate capability to resolve global names and act as the default RDNSS. Lack of a \".\" domain on the list indicates that RDNSSes only have information related to listed domains and networks. Networks for reverse mapping are encoded as defined for IP6.ARPA [RFC3596] or IN-ADDR.ARPA [RFC2317].",
      "ja": "ドメインとネットワーク：RDNSSesは特別な知識を持っているかについてDNSの逆引き参照のための前方DNSルックアップのためのドメインおよびネットワークのリスト。 [RFC3315]のセクション8で指定されるようにフィールドが符号化されなければなりません。の特別なドメイン「」グローバル名を解決し、デフォルトのRDNSSとして機能する能力を示すために使用されます。の欠如「」リスト上のドメインはRDNSSesのみ記載されているドメインやネットワークに関連する情報を持っていることを示しています。 IP6.ARPA [RFC3596]またはIN-ADDR.ARPA [RFC2317]について定義された通り逆マッピングするためのネットワークが符号化されます。"
    },
    {
      "indent": 3,
      "text": "The RDNSS Selection option contains one or more domains of which the primary and secondary RDNSSes have particular knowledge. If the length of the domains and networks field causes option length to exceed the maximum permissible for a single option (255 octets), then multiple options MAY be used, as described in \"Encoding Long Options in the Dynamic Host Configuration Protocol (DHCPv4)\" [RFC3396]. When multiple options are present, the data portions of all option instances are concatenated together.",
      "ja": "RDNSS選択オプションは、プライマリとセカンダリRDNSSesは、特定の知識を持っているの1つ以上のドメインが含まれています。ドメインとネットワークフィールドの長さは、オプションの長さは1つのオプション（255オクテット）の許容最大値を超えて発生した場合、「動的ホスト構成プロトコル（DHCPv4の）でエンコーディングロングオプション」で説明したように、その後、複数のオプションを使用することができます[RFC3396]。複数のオプションが存在する場合、すべてのオプションインスタンスのデータ部分が一緒に連結されています。"
    },
    {
      "indent": 3,
      "text": "The list of networks MUST cover all the domains configured in this option. The length of the included networks SHOULD be as long as possible to avoid potential collision with information received on other option instances or with options received from DHCP servers of other network interfaces. Overlapping networks are interpreted so that the resolver can use any of the RDNSSes for queries matching the networks.",
      "ja": "ネットワークのリストは、このオプションに設定されているすべてのドメインをカバーしなければなりません。含まれるネットワークの長さは、他のOptionインスタンスまたは他のネットワークインターフェイスのDHCPサーバから受信したオプションが受信された情報との潜在的な衝突を回避するためにできるだけ長くあるべきです。リゾルバがネットワークに一致クエリのRDNSSesのいずれかを使用することができるように、重複ネットワークが解釈されます。"
    },
    {
      "indent": 3,
      "text": "If the RDNSS Selection option contains an RDNSS address already learned from other DHCPv4 servers of the same network and contains new domains or networks, the node SHOULD append the information to the information received earlier. The node MUST NOT remove previously obtained information. However, the node SHOULD NOT extend the lifetime of earlier information either. When a conflicting RDNSS address is learned from a less trusted interface, the node MUST ignore the option.",
      "ja": "RDNSS選択オプションが既に同じネットワークの他のDHCPv4サーバから学んだRDNSSアドレスが含まれていて、新しいドメインやネットワークが含まれている場合、ノードは情報に情報を追加すべきである以前に受けました。ノードは、以前に取得した情報を削除してはなりません。しかし、ノードは、いずれか早い情報の寿命を延長すべきではありません。競合RDNSSアドレスが信頼性の低いインターフェイスから学習された場合、ノードは、オプションを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client SHALL periodically refresh information learned with the RDNSS Selection option. The information SHALL be refreshed on link-state changes, such as those caused by node mobility, and when extending the lease of IPv4 addresses configured with DHCPv4.",
      "ja": "クライアントは、定期的にRDNSS選択オプションで学習した情報を更新するものとします。情報は、ノードの移動によって引き起こされるもののようなリンク状態の変化、にリフレッシュし、DHCPv4ので構成IPv4アドレスのリースを延長するときことSHALL。"
    },
    {
      "indent": 0,
      "text": "4.4. Scalability Considerations",
      "section_title": true,
      "ja": "4.4. スケーラビリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The general size limitations of the DHCP messages limit the number of domains and networks that can be carried inside of these RDNSS selection options. The DHCP options for RDNSS selection are best suited for those deployments where relatively few and carefully selected domains and networks are enough.",
      "ja": "DHCPメッセージの一般的なサイズの制限は、これらのRDNSS選択オプションの内部で実施することができるドメインおよびネットワークの数を制限します。 RDNSS選択のためのDHCPオプションは比較的少ないと厳選されたドメインとのネットワークが十分にあるそれらの展開に最適です。"
    },
    {
      "indent": 0,
      "text": "4.5. Limitations on Use",
      "section_title": true,
      "ja": "4.5. 使用上の制限事項"
    },
    {
      "indent": 3,
      "text": "The RDNSS selection option SHOULD NOT be enabled by default. (In this section, \"RDNSS selection option\" refers to the DHCPv4 RDNSS Selection option and the DHCPv6 OPTION_RDNSS_SELECTION.) The option can be used in the following environments:",
      "ja": "RDNSS選択オプションはデフォルトで有効にしないでください。 （このセクションでは、「RDNSS選択オプションは」DHCPv4のRDNSS選択オプションとDHCPv6のOPTION_RDNSS_SELECTIONを指す。）オプションは、以下の環境で使用することができます。"
    },
    {
      "indent": 3,
      "text": "1. The RDNSS selection option is delivered across a secure, trusted channel.",
      "ja": "1. RDNSS選択オプションは、安全で信頼できるチャネルを介して配信されます。"
    },
    {
      "indent": 3,
      "text": "2. The RDNSS selection option is not secured, but the client on a node does DNSSEC validation.",
      "ja": "2. RDNSS選択オプションが確保されていないが、ノード上のクライアントは、DNSSEC検証を行います。"
    },
    {
      "indent": 3,
      "text": "3. The RDNSS selection option is not secured, the resolver does DNSSEC validation, and the client communicates with the resolver configured with the RDNSS selection option over a secure, trusted channel.",
      "ja": "3. RDNSS選択オプションが確保されていない、リゾルバはDNSSEC検証を行い、クライアントは、安全な、信頼できるチャネルを介しRDNSS選択オプションで構成リゾルバと通信します。"
    },
    {
      "indent": 3,
      "text": "4. The IP address of the RDNSS that is being recommended in the RDNSS selection option is known and trusted by the client; that is, the RDNSS selection option serves not to introduce the client to a new RDNSS, but rather to inform it that the RDNSS it has already been configured to trust is available to it for resolving certain domains.",
      "ja": "4. RDNSS選択オプションで推奨されているRDNSSのIPアドレスが知られており、クライアントに信頼されています。つまり、RDNSS選択オプションは、新しいRDNSSにクライアントを導入しないものであり、むしろ、既に信頼するように設定されているRDNSSが特定のドメインを解決するため、それに利用可能であることを知らせるために。"
    },
    {
      "indent": 3,
      "text": "As the DHCP by itself cannot tell whether it is using a secure, trusted channel, or whether the client on a node is performing DNSSEC validation, this option cannot be used without being explicitly enabled. The functionality can be enabled for an interface via administrative means, such as by provisioning tools or manual configuration. Furthermore, the functionality can be automatically enabled by a client on a node that knows it is performing DNSSEC validation or by a node that is configured or hard-coded to trust certain interfaces (see Section 8.2).",
      "ja": "それ自体でDHCPは、それが安全、高信頼チャネルを使用しているかどうか、またはノード上のクライアントが、DNSSEC検証を実行しているかどうかを伝えることができないように、このオプションが明示的に有効にされずに使用することはできません。機能は、ツールまたは手動構成をプロビジョニングするなどの管理手段を介してインターフェイスのために有効にすることができます。また、機能が自動的にDNSSEC検証を行うか、特定のインタフェース（セクション8.2を参照）を信頼するように構成された、またはハードコーディングされているノードがあることを知っているノード上のクライアントで有効にすることができます。"
    },
    {
      "indent": 0,
      "text": "4.6. Coexistence of Various RDNSS Configuration Tools",
      "section_title": true,
      "ja": "4.6. 様々なRDNSS設定ツールの共存"
    },
    {
      "indent": 3,
      "text": "The DHCPv4 RDNSS Selection option and the DHCPv6 OPTION_RDNSS_SELECTION are designed to coexist with each other and with other tools used for RDNSS address configuration.",
      "ja": "DHCPv4のRDNSS選択オプションとDHCPv6のOPTION_RDNSS_SELECTIONは、互いにとRDNSSアドレス構成のために使用される他のツールと共存するように設計されています。"
    },
    {
      "indent": 3,
      "text": "For RDNSS selection purposes, information received from all tools MUST be combined together into a single list, as discussed in Section 4.1.",
      "ja": "セクション4.1で議論するようにRDNSS選択のために、すべてのツールから受信した情報は、1つのリストに一緒に結合されなければなりません。"
    },
    {
      "indent": 3,
      "text": "It can happen that DHCPv4 and DHCPv6 are providing conflicting RDNSS selection information on the same or on equally trusted interfaces. In such a case, DHCPv6 MUST be preferred unless DHCPv4 is utilizing additional security frameworks for protecting the messages.",
      "ja": "DHCPv4とDHCPv6のは同じで又は等しく信頼できるインターフェイス上の競合RDNSS選択情報を提供していることが起こり得ます。 DHCPv4のメッセージを保護するための追加のセキュリティフレームワークを利用されていない限り、このような場合には、DHCPv6のが好適でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The RDNSSes learned via tools other than the DHCPv4 RDNSS Selection option and the DHCPv6 OPTION_RDNSS_SELECTION MUST be handled as default RDNSSes, with medium preference, when building a list of RDNSSes to talk to (see Section 4.1).",
      "ja": "RDNSSesは（セクション4.1を参照）に話をRDNSSesのリストを構築するときに、メディアの好みで、デフォルトのRDNSSesとして扱われなければならないのDHCPv4 RDNSS選択オプションとDHCPv6 OPTION_RDNSS_SELECTION以外のツールを介して学習しました。"
    },
    {
      "indent": 3,
      "text": "The non-exhaustive list of possible other sources for RDNSS address configuration are:",
      "ja": "RDNSSアドレスの設定のための可能な他のソースの非網羅的なリストは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "(1) DHCPv6 OPTION_DNS_SERVERS defined in [RFC3646].",
      "ja": "（1）[RFC3646]で定義されたDHCPv6 OPTION_DNS_SERVERS。"
    },
    {
      "indent": 3,
      "text": "(2) DHCPv4 Domain Server option defined in [RFC2132].",
      "ja": "[RFC2132]で定義された（2）のDHCPv4ドメインサーバオプション。"
    },
    {
      "indent": 3,
      "text": "(3) IPv6 Router Advertisement RDNSS Option defined in [RFC6106].",
      "ja": "[RFC6106]で定義された（3）のIPv6ルータ広告RDNSSオプション。"
    },
    {
      "indent": 3,
      "text": "When the RDNSS selection option contains a default RDNSS address and other sources are providing RNDSS addresses, the resolver MUST make the decision about which one to prefer based on the RDNSS preference field value. If the RDNSS selection option defines medium preference, then the RDNSS from the RDNSS selection option SHALL be selected.",
      "ja": "RDNSS選択オプションがデフォルトのRDNSSアドレスやその他のソースがRNDSSアドレスを提供している含まれている場合、リゾルバはRDNSS優先フィールドの値に基づいて好む1についての決定をしなければなりません。 RDNSS選択オプションは、メディア嗜好を定義する場合、RDNSS選択オプションからRDNSSが選択されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If multiple sources are providing same RDNSS(es) IP address(es), each address MUST be added to the RDNSS list only once.",
      "ja": "複数のソースが同じRDNSS（ES）IPアドレスを提供している場合、各アドレスは一度だけRDNSSリストに追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a node had indicated support for OPTION_RDNSS_SELECTION in a DHCPv6 request, the DHCPv6 server MAY omit sending of OPTION_DNS_SERVERS. This enables offloading use case where the network administrator wishes to only advertise low preference default RDNSSes.",
      "ja": "ノードは、DHCPv6の要求にOPTION_RDNSS_SELECTIONのサポートを示していた場合は、DHCPv6サーバはOPTION_DNS_SERVERSの送信を省略することができます。これは、ネットワーク管理者のみが低優先デフォルトRDNSSesを宣伝したいユースケースの負荷を軽減できます。"
    },
    {
      "indent": 0,
      "text": "4.7. Considerations on Follow-Up Queries",
      "section_title": true,
      "ja": "4.7. フォローアップクエリに関する考察"
    },
    {
      "indent": 3,
      "text": "Any follow-up queries that are performed on the basis of an answer received on an interface MUST continue to use the same interface, irrespective of the RDNSS selection settings on any other interface. For example, if a node receives a reply with a canonical name (CNAME) or delegation name (DNAME), the follow-up queries MUST be sent to RDNSS(es) of the same interface, or to the same RDNSS, irrespectively of the FQDN received. Otherwise, referrals can fail.",
      "ja": "インターフェイス上で受信された回答に基づいて行われている任意のフォローアップクエリは、任意の他のインターフェイスにかかわらずRDNSS選択設定、同じインタフェースを使用し続けなければなりません。例えばノードは正規名（CNAME）または委任名（DNAME）との応答を受信した場合、フォローアップクエリが同じインタフェース（ES）RDNSSに送信する必要があり、または同じRDNSSに、無関係のFQDNを受信しました。それ以外の場合は、紹介は失敗する可能性があります。"
    },
    {
      "indent": 0,
      "text": "4.8. Closing Network Interfaces and Local Caches",
      "section_title": true,
      "ja": "4.8. ネットワークインタフェースおよびローカル・キャッシュを閉じます"
    },
    {
      "indent": 3,
      "text": "Cached information related to private namespaces can become obsolete after the network interface over which the information was learned is closed (Section 2.2) or a new parallel network interface is opened that alters RDNSS selection preferences. An implementation SHOULD ensure obsolete information is not retained in these events. One implementation approach to avoid unwanted/obsolete responses from the local cache is to manage per-interface DNS caches or have interface information stored in the DNS cache. An alternative approach is to perform, possibly selective, DNS cache flushing on interface change events.",
      "ja": "プライベート名前空間に関連するキャッシュされた情報は、学習された情報を閉じた上で、ネットワークインターフェース（2.2節）またはRDNSS選択の優先順位を変更開かれ、新たなパラレルネットワークインタフェースの後に時代遅れになることができます。廃止された情報を確認する必要があります実装は、これらのイベントには保持されません。ローカルキャッシュから不要な/時代遅れの応答を回避する1つの実装アプローチは、インターフェースごとのDNSキャッシュを管理したり、DNSキャッシュに保存されているインタフェース情報を持っていることです。別のアプローチは、インターフェースの変更イベントに、おそらく選択、DNSキャッシュのフラッシュを実行することです。"
    },
    {
      "indent": 0,
      "text": "5. Example of a Node Behavior",
      "section_title": true,
      "ja": "ノードの動作の5例"
    },
    {
      "indent": 3,
      "text": "Figure 7 illustrates node behavior when it initializes two network interfaces for parallel usage and learns domain and network information from DHCPv6 servers.",
      "ja": "それは、並列使用のために2つのネットワークインタフェースを初期化とDHCPv6サーバからのドメインとネットワーク情報を学習すると、図7は、ノードの動作を示す図です。"
    },
    {
      "indent": 3,
      "text": " Application    Node      DHCPv6 server   DHCPv6 server\n                          on interface 1  on interface 2\n     |             |                |\n     |         +-----------+        |\n(1)  |         | open      |        |\n     |         | interface |        |\n     |         +-----------+        |\n     |             |                |\n(2)  |             |---option REQ-->|\n     |             |<--option RESP--|\n     |             |                |\n     |         +-----------+        |\n(3)  |         | store     |        |\n     |         | domains   |        |\n     |         +-----------+        |\n     |             |                |\n     |         +-----------+        |\n(4)  |         | open      |        |\n     |         | interface |        |\n     |         +-----------+        |\n     |             |                |                |\n(5)  |             |---option REQ------------------->|\n     |             |<--option RESP-------------------|\n     |             |                |                |\n     |         +----------+         |                |\n(6)  |         | store    |         |                |\n     |         | domains  |         |                |\n     |         +----------+         |                |\n     |             |                |                |",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 7: Illustration of Learning Domains",
      "ja": "図7：学習ドメインのイラスト"
    },
    {
      "indent": 3,
      "text": "Flow explanations:",
      "ja": "流れの説明："
    },
    {
      "indent": 3,
      "text": "1. A node opens its first network interface.",
      "section_title": true,
      "ja": "1.ノードは、その第一のネットワークインタフェースを開きます。"
    },
    {
      "indent": 3,
      "text": "2. The node obtains domain 'domain1.example.com' and IPv6 network '0.8.b.d.0.1.0.0.2.ip6.arpa' for the new interface 1 from the DHCPv6 server.",
      "ja": "2.ノードがドメイン「domain1.example.com」とDHCPv6サーバから新しいインタフェース1のIPv6ネットワーク「0.8.b.d.0.1.0.0.2.ip6.arpa」を得ます。"
    },
    {
      "indent": 3,
      "text": "3. The node stores the learned domains and IPv6 networks for later use.",
      "ja": "3.ノードは、後で使用するために学習したドメインとIPv6ネットワークを記憶します。"
    },
    {
      "indent": 3,
      "text": "4. The node opens its second network interface 2.",
      "section_title": true,
      "ja": "4.ノードは、その第2のネットワークインタフェース2を開きます。"
    },
    {
      "indent": 3,
      "text": "5. The node obtains domain 'domain2.example.com' and IPv6 network information, say '1.8.b.d.0.1.0.0.2.ip6.arpa' for the new interface 2 from the DHCPv6 server.",
      "ja": "5.ノードがドメイン「domain2.example.com」とIPv6ネットワーク情報を取得し、DHCPv6サーバから新しいインターフェース2のための「1.8.b.d.0.1.0.0.2.ip6.arpa」を言います。"
    },
    {
      "indent": 3,
      "text": "6. The node stores the learned domains and networks for later use.",
      "section_title": true,
      "ja": "前記ノードは、後で使用するために学習したドメインとネットワークを記憶します。"
    },
    {
      "indent": 3,
      "text": "Figure 8 illustrates how a resolver uses the learned domain information. Network information use for reverse lookups is not illustrated, but that would be similar to the example in Figure 8.",
      "ja": "図8は、リゾルバが学んだドメイン情報をどのように使用するかを示しています。逆ルックアップのためのネットワーク情報の使用は、図示されていないが、それは、図8の例と同様です。"
    },
    {
      "indent": 3,
      "text": " Application     Node     RDNSS             RDNSS\n                          on interface 1    on interface 2\n     |             |                |                |\n(1)  |--Name REQ-->|                |                |\n     |             |                |                |\n     |      +----------------+      |                |\n(2)  |      | RDNSS          |      |                |\n     |      | prioritization |      |                |\n     |      +----------------+      |                |\n     |             |                |                |\n(3)  |             |------------DNS resolution------>|\n     |             |<--------------------------------|\n     |             |                |                |\n(4)  |<--Name resp-|                |                |\n     |             |                |                |",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 8: Example on Choosing Interface Based on Domain",
      "ja": "図8：ドメインに基づいて、インターフェイスを選択する上での例"
    },
    {
      "indent": 3,
      "text": "Flow explanations:",
      "ja": "流れの説明："
    },
    {
      "indent": 3,
      "text": "1. An application makes a request for resolving an FQDN, e.g., 'private.domain2.example.com'.",
      "ja": "1.アプリケーションは、FQDN、例えば、「private.domain2.example.com」を解決するための要求を行います。"
    },
    {
      "indent": 3,
      "text": "2. A node creates list of RDNSSes to contact and uses configured RDNSS selection information and stored domain information on prioritization decisions.",
      "ja": "2.ノードが接触するRDNSSesのリストを作成し、優先順位の決定に構成RDNSS選択情報と、記憶されているドメイン情報を使用します。"
    },
    {
      "indent": 3,
      "text": "3. The node has chosen interface 2, as it was learned earlier from DHCPv6 that the interface 2 has domain 'domain2.example.com'. The node then resolves the requested name using interface 2's RDNSS to an IPv6 address.",
      "ja": "それはインタフェース2は、ドメイン「domain2.example.com」を有することが以前のDHCPv6から学習されたように3ノードは、インターフェース2を選択しました。ノードは、IPv6アドレスにインタフェース2のRDNSSを使用して要求された名前を解決します。"
    },
    {
      "indent": 3,
      "text": "4. The node replies to the application with the resolved IPv6 address.",
      "ja": "4.ノードは、解決のIPv6アドレスを使用してアプリケーションに返信します。"
    },
    {
      "indent": 0,
      "text": "6. Considerations for Network Administrators",
      "section_title": true,
      "ja": "ネットワーク管理者のための考慮事項6。"
    },
    {
      "indent": 3,
      "text": "Network administrators deploying private namespaces can assist advanced nodes in their RDNSS selection process by providing the information described within this document.",
      "ja": "プライベート名前空間を展開し、ネットワーク管理者は、この文書の中に記述された情報を提供することで、彼らのRDNSS選択プロセスの高度なノードを支援することができます。"
    },
    {
      "indent": 3,
      "text": "Private namespaces MUST be globally unique in order to keep DNS unambiguous and henceforth avoid caching-related issues and destination selection problems (see Section 2.3). Exceptions to this rule are domains utilized for local name resolution (such as .local).",
      "ja": "プライベート名前空間は明確なDNSを維持し、今後のキャッシュ関連の問題と先選択の問題を回避するために、グローバルに一意でなければならない（2.3節を参照してください）。この規則の例外は、（例えば.LOCALなど）は、ローカルの名前解決のために利用されるドメインです。"
    },
    {
      "indent": 3,
      "text": "Private namespaces MUST only consist of subdomains of domains for which the relevant operator provides authoritative name service. Thus, subdomains of example.com are permitted in the private namespace served by an operator's RDNSSes only if the same operator provides a SOA record for example.com.",
      "ja": "プライベート名前空間は、関連するオペレータが権威ネームサービスを提供するためのドメインのサブドメインで構成されなければなりません。このように、example.comのサブドメインは、同じオペレータがexample.comのSOAレコードを提供する場合にのみオペレータのRDNSSesによって提供されるプライベートな名前空間で許可されています。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED for administrators utilizing this tool to deploy DNSSEC for their zone in order to counter attacks against private namespaces.",
      "ja": "これは、プライベート名前空間に対する攻撃に対抗するために、そのゾーンのDNSSECを導入するには、このツールを利用し、管理者にお勧めです。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Per this memo, IANA has assigned two new option codes.",
      "ja": "このメモごとに、IANAは、2つの新しいオプションコードが割り当てられています。"
    },
    {
      "indent": 3,
      "text": "The first option code has been assigned for the DHCPv4 RDNSS Selection option (146) from the \"BOOTP Vendor Extensions and DHCP Options\" registry in the group \"Dynamic Host Configuration Protocol (DHCP) and Bootstrap Protocol (BOOTP) Parameters\".",
      "ja": "最初のオプションコードは、グループ「動的ホスト構成プロトコル（DHCP）およびブートストラッププロトコル（BOOTP）パラメータ」の「BOOTPベンダー拡張機能とDHCPオプションの」レジストリからのDHCPv4 RDNSS選択オプション（146）のために割り当てられています。"
    },
    {
      "indent": 3,
      "text": "The second option code is requested to be assigned for the DHCPv6 OPTION_RDNSS_SELECTION (74) from the \"DHCP Option Codes\" registry in the group \"Dynamic Host Configuration Protocol for IPv6 (DHCPv6)\".",
      "ja": "二番目のオプションコードはグループ「IPv6の動的ホスト構成プロトコル（DHCPv6）」の「DHCPオプションコード」レジストリからDHCPv6のOPTION_RDNSS_SELECTION（74）のために割り当てられることを要求されます。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. Attack Vectors",
      "section_title": true,
      "ja": "8.1. 攻撃ベクトル"
    },
    {
      "indent": 3,
      "text": "It is possible that attackers might try to utilize the DHCPv4 RDNSS Selection option or the DHCPv6 OPTION_RDNSS_SELECTION option to redirect some or all DNS queries sent by a resolver to undesired destinations. The purpose of an attack might be denial of service, preparation for man-in-the-middle attack, or something akin.",
      "ja": "攻撃者は望ましくない宛先にリゾルバによって送信される一部またはすべてのDNSクエリをリダイレクトするためのDHCPv4 RDNSS選択オプションまたはDHCPv6のOPTION_RDNSS_SELECTIONオプションを利用しようとする可能性があります。攻撃の目的は、サービス拒否、man-in-the-middle攻撃、または似た何かのための準備であるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Attackers might try to lure specific traffic by advertising domains and networks from very small to very large scope or simply by trying to place the attacker's RDNSS as the highest preference default RDNSS.",
      "ja": "攻撃者は、非常に大きいと非常に小さい範囲からの広告ドメインおよびネットワークで特定のトラフィックを誘惑しようとしたり、単純に最高の優先デフォルトRDNSSとして攻撃者のRDNSSを配置しようとしていることであります。"
    },
    {
      "indent": 3,
      "text": "The best countermeasure for nodes is to implement validating DNSSEC-aware resolvers. Trusting validation done by an RDNSS is a possibility only if a node trusts the RDNSS and can use a secure channel for DNS messages.",
      "ja": "ノードのための最善の対策は、DNSSEC対応リゾルバを検証し実装することです。 RDNSSによって行わ検証を信頼するノードがRDNSSを信頼し、DNSメッセージのセキュアなチャネルを使用することができた場合にのみ可能です。"
    },
    {
      "indent": 0,
      "text": "8.2. Trust Levels of Network Interfaces",
      "section_title": true,
      "ja": "8.2. ネットワークインターフェイスの信頼レベル"
    },
    {
      "indent": 3,
      "text": "Trustworthiness of an interface and configuration information received over the interface is implementation and/or node deployment dependent, and the details of determining that trust are beyond the scope of this specification. Trust might, for example, be based on the nature of the interface: an authenticated and encrypted VPN, or a layer 2 connection to a trusted home network or to a trusted cellular network, might be considered trusted, while an unauthenticated and unencrypted connection to an unknown visited network would likely be considered untrusted.",
      "ja": "インターフェースを介して受信インターフェース及び構成情報の信頼性、実装および/またはノード配備依存し、その信頼の決定の詳細は、本明細書の範囲外です。トラストは、例えば、インタフェースの性質に基づいてされる可能性があります：認証され、VPNの暗号化、または信頼できるホームネットワークまたは信頼できる携帯電話ネットワークへのレイヤ2接続、信頼できると考えられるかもしれない、と認証されていないと、暗号化されていない接続中未知の訪問先ネットワークは、おそらく信頼できないと考えられます。"
    },
    {
      "indent": 3,
      "text": "In many cases, an implementation might not be able to determine trust levels without explicit configuration provided by the user or the node's administrator. Therefore, for example, an implementation might not by default trust configuration received even over VPN interfaces. In some occasions, standards defining organizations that are specific to access network technology might be able to define trust levels as part of the system design work.",
      "ja": "多くの場合、実装は、ユーザーまたはノードの管理者から提供された明示的な設定なしで信頼レベルを決定することができない場合があります。したがって、例えば、実装ではなく、デフォルトの信頼構成であってもVPNインターフェースを介して受信可能性があります。いくつかの場面では、アクセスネットワーク技術に固有の組織を定義する規格では、システムの設計作業の一環として、信頼レベルを定義することができるかもしれません。"
    },
    {
      "indent": 0,
      "text": "8.3. Importance of Following the Algorithm",
      "section_title": true,
      "ja": "8.3. アルゴリズムに続いての重要性"
    },
    {
      "indent": 3,
      "text": "Section 4 uses normative language for describing a node's internal behavior in order to ensure that nodes will not open up new attack vectors by accidental use of RDNSS selection options. During the standards work, consensus was that it is safer to not always enable this option by default, but only when deemed useful and safe.",
      "ja": "第4節では、ノードがRDNSS選択オプションを誤って使用することにより、新しい攻撃ベクトルを開かないことを確実にするために、ノードの内部動作を記述するための規範的な言語を使用しています。標準化作業中、コンセンサスは常にデフォルトでこのオプションを有効にしない方が安全であるということでしたが、唯一の有用かつ安全であると見なさとき。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2132] Alexander, S. and R. Droms, \"DHCP Options and BOOTP Vendor Extensions\", RFC 2132, March 1997.",
      "ja": "[RFC2132]アレクサンダー、S.とR. Droms、 \"DHCPオプションとBOOTPベンダー拡張機能\"、RFC 2132、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2317] Eidnes, H., de Groot, G., and P. Vixie, \"Classless IN-ADDR.ARPA delegation\", BCP 20, RFC 2317, March 1998.",
      "ja": "[RFC2317] Eidnes、H.、デ・グルート、G.、およびP.いるVixie、 \"クラスレスIN-ADDR.ARPA委任\"、BCP 20、RFC 2317、1998年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3315] Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C., and M. Carney, \"Dynamic Host Configuration Protocol for IPv6 (DHCPv6)\", RFC 3315, July 2003.",
      "ja": "[RFC3315] Droms、R.、バウンド、J.、フォルツ、B.、レモン、T.、パーキンス、C.、およびM.カーニー、 \"IPv6のための動的ホスト構成プロトコル（DHCPv6）\"、RFC 3315、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3396] Lemon, T. and S. Cheshire, \"Encoding Long Options in the Dynamic Host Configuration Protocol (DHCPv4)\", RFC 3396, November 2002.",
      "ja": "[RFC3396]レモン、T.とS.チェシャー、 \"動的ホスト構成プロトコル（DHCPv4の）でエンコーディング長いオプション\"、RFC 3396、2002年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3596] Thomson, S., Huitema, C., Ksinant, V., and M. Souissi, \"DNS Extensions to Support IP Version 6\", RFC 3596, October 2003.",
      "ja": "[RFC3596]トムソン、S.、のHuitema、C.、Ksinant、V.、およびM. Souissi、RFC 3596、2003年10月 \"DNSの拡張機能は、IPバージョン6をサポートします\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4242] Venaas, S., Chown, T., and B. Volz, \"Information Refresh Time Option for Dynamic Host Configuration Protocol for IPv6 (DHCPv6)\", RFC 4242, November 2005.",
      "ja": "[RFC4242] Venaas、S.、chownコマンド、T.、およびB.フォルツ、RFC 4242、2005年11月の \"IPv6のための動的ホスト構成プロトコル（DHCPv6の）のための情報更新時間オプション\"。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC3397] Aboba, B. and S. Cheshire, \"Dynamic Host Configuration Protocol (DHCP) Domain Search Option\", RFC 3397, November 2002.",
      "ja": "[RFC3397] Aboba、B.とS.チェシャー、 \"動的ホスト構成プロトコル（DHCP）ドメイン検索オプション\"、RFC 3397、2002年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3442] Lemon, T., Cheshire, S., and B. Volz, \"The Classless Static Route Option for Dynamic Host Configuration Protocol (DHCP) version 4\", RFC 3442, December 2002.",
      "ja": "[RFC3442]レモン、T.、チェシャー、S.、およびB.フォルツ、RFC 3442 \"動的ホスト構成プロトコル（DHCP）バージョン4のためのクラスレス静的ルートオプション\"、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3646] Droms, R., \"DNS Configuration options for Dynamic Host Configuration Protocol for IPv6 (DHCPv6)\", RFC 3646, December 2003.",
      "ja": "[RFC3646] Droms、R.、RFC 3646、2003年12月の \"IPv6のための動的ホスト構成プロトコル（DHCPv6）のためのDNSの設定オプション\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4191] Draves, R. and D. Thaler, \"Default Router Preferences and More-Specific Routes\", RFC 4191, November 2005.",
      "ja": "[RFC4191] Draves、R.とD.ターラー、 \"デフォルトルータの設定と、より詳細なルート\"、RFC 4191、2005年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4193] Hinden, R. and B. Haberman, \"Unique Local IPv6 Unicast Addresses\", RFC 4193, October 2005.",
      "ja": "[RFC4193] HindenとR.とB.ハーバーマン、 \"ユニークローカルIPv6ユニキャストアドレス\"、RFC 4193、2005年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC6106] Jeong, J., Park, S., Beloeil, L., and S. Madanapalli, \"IPv6 Router Advertisement Options for DNS Configuration\", RFC 6106, November 2010.",
      "ja": "[RFC6106]チョン、J.、公園、S.、Beloeilの、L.、およびS. Madanapalli、 \"DNS設定のためのIPv6ルータアドバタイズメントのオプション\"、RFC 6106、2010年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC6147] Bagnulo, M., Sullivan, A., Matthews, P., and I. van Beijnum, \"DNS64: DNS Extensions for Network Address Translation from IPv6 Clients to IPv4 Servers\", RFC 6147, April 2011.",
      "ja": "[RFC6147] Bagnulo、M.、サリバン、A.、マシューズ、P.、およびI.バンBeijnum、 \"DNS64：IPv4のサーバーへのIPv6クライアントからのネットワークアドレス変換のためのDNS拡張機能\"、RFC 6147、2011年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC6418] Blanchet, M. and P. Seite, \"Multiple Interfaces and Provisioning Domains Problem Statement\", RFC 6418, November 2011.",
      "ja": "[RFC6418]ブランシェ、M.とP. Seite、 \"複数のインタフェースおよびプロビジョニングドメインの問題に関する声明\"、RFC 6418、2011年11月。"
    },
    {
      "indent": 3,
      "text": "[WITHOUT-IPV6NAT] Troan, O., Miles, D., Matsushima, S., Okimoto, T., and D. Wing, \"IPv6 Multihoming without Network Address Translation\", Work in Progress, February 2012.",
      "ja": "\"ネットワークアドレス変換なしでIPv6のマルチホーミング\" Troan、O.、マイル、D.、松島、S.、沖本、T.、およびD.ウィング、[-IPV6NATなし]、進歩、2012年2月での作業。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Possible Alternative Practices for RDNSS Selection",
      "ja": "RDNSS選択の付録A.可能な代替プラクティス"
    },
    {
      "indent": 3,
      "text": "On some private namespace deployments, explicit policies for RDNSS selection are not available. This section describes ways for nodes to mitigate the problem by sending wide-spread queries and by utilizing possibly existing indirect information elements as hints.",
      "ja": "いくつかのプライベート名前空間の展開で、RDNSS選択のための明示的なポリシーが使用できません。このセクションでは、ノードが広範囲にクエリを送信することにより、おそらくヒントなど、既存の間接的な情報要素を利用することによって、問題を軽減するための方法について説明します。"
    },
    {
      "indent": 0,
      "text": "A.1. Sending Queries Out on Multiple Interfaces in Parallel",
      "ja": "A.1。並行して複数のインターフェイス上でクエリを送信します"
    },
    {
      "indent": 3,
      "text": "A possible current practice is to send DNS queries out of multiple interfaces and pick up the best out of the received responses. A node can implement DNSSEC in order to be able to reject responses that cannot be validated. Selection between legitimate answers is implementation specific, but replies from trusted RDNSSes are preferred.",
      "ja": "可能な現在の慣行は、複数のインターフェイスのうち、DNSクエリを送信し、受信した応答のうち、最高を拾うことです。ノードを検証することはできません応答を拒否することができるようにするためにDNSSECを実装することができます。合法的な答えの間の選択は、実装固有のものですが、信頼できるRDNSSesからの返信が好ましいです。"
    },
    {
      "indent": 3,
      "text": "A downside of this approach is increased consumption of resources, namely, power consumption if an interface, e.g., wireless, has to be brought up just for the DNS query that could have been resolved via a cheaper interface. Also, load on RDNSSes is increased. However, local caching of results mitigates these problems, and a node might also learn interfaces that seem to be able to provide 'better' responses than others and prefer those, without forgetting that fallback is required for cases when the node is connected to more than one network using private namespaces.",
      "ja": "このアプローチの欠点は、リソースの消費を増加させ、インターフェースは、例えば、無線は、単に安いインタフェースを介して解決されている可能性がDNSクエリのために育てなければならない場合、すなわち、消費電力。また、RDNSSesの負荷が増加しています。しかし、結果のローカルキャッシュ機能は、これらの問題を軽減し、ノードは、ノードが複数に接続されているときに他の人よりも「より良いの回答を提供し、そのフォールバックを忘れることなく、それらを好むことができるように思われるインタフェースは例のために必要とされる学習する可能性がありますプライベート名前空間を使用して一つのネットワーク。"
    },
    {
      "indent": 0,
      "text": "A.2. Search List Option for DNS Forward Lookup Decisions",
      "ja": "A.2。 DNS前方参照の決定のための検索リストオプション"
    },
    {
      "indent": 3,
      "text": "A node can learn the special domains of attached network interfaces from IPv6 Router Advertisement DNS Search List Option [RFC6106] or DHCP search list options -- DHCPv4 Domain Search Option number 119 [RFC3397] and DHCPv6 Domain Search List Option number 24 [RFC3646]. The node behavior is very similar to that illustrated in the example in Section 5. While these options are not intended to be used in RDNSS selection, they can be used by the nodes as hints for smarter RDNSS prioritization purposes in order to increase likelihood of fast and successful DNS queries.",
      "ja": "DHCPv4のドメイン検索オプション番号119 [RFC3397]とDHCPv6ドメイン検索一覧オプション番号24 [RFC3646]  - ノードは、IPv6ルータアドバタイズメントDNS検索一覧オプション[RFC6106]またはDHCP検索リストのオプションから接続されたネットワーク・インタフェースの特別なドメインを学ぶことができます。ノードの動作は、これらのオプションは、高速の可能性を高めるために、それらは賢くRDNSSの優先順位付けの目的のためのヒントとしてノードによって使用することができるRDNSS選択に使用されることが意図されていないが第5の例に示したものと非常に類似していますそして成功したDNSクエリ。"
    },
    {
      "indent": 3,
      "text": "Overloading of existing DNS search list options is not without problems: resolvers would obviously use the domains learned from search lists for name resolution purposes. This might not be a problem in deployments where DNS search list options contain few domains like 'example.com, private.example.com' but can become a problem if many domains are configured.",
      "ja": "既存のDNS検索リストオプションのオーバーロードは、問題がないわけではない：リゾルバは明らかに名前解決のために、検索リストから学んだのドメインを使用します。これは、DNS検索リストのオプションは、「example.com、private.example.com」のようないくつかのドメインが含まれているが、多くのドメインが設定されている場合、問題になることができるの展開で問題ではないかもしれません。"
    },
    {
      "indent": 0,
      "text": "A.3. More-Specific Routes for Reverse Lookup Decisions",
      "ja": "A.3。逆引き参照の決定のためのより具体的なルート"
    },
    {
      "indent": 3,
      "text": "[RFC4191] defines how more-specific routes can be provisioned for nodes. This information is not intended to be used in RDNSS selection, but nevertheless, a node can use this information as a hint about which interface would be best to try first for reverse lookup procedures. An RDNSS configured via the same interface as more-specific routes is more likely capable to answer reverse lookup questions correctly than an RDNSS of another interface. The likelihood of success is possibly higher if an RDNSS address is received in the same RA [RFC6106] as the more-specific route information.",
      "ja": "[RFC4191]は、より固有のルートノードをプロビジョニングすることができる方法を定義します。この情報はRDNSSの選択に使用されるものではなく、それにもかかわらず、ノードは、インターフェースが逆引き参照の手続きのために最初に試すのがベストだろうかについてのヒントとして、この情報を使用することができます。より具体的なルートと同じインタフェースを介して設定RDNSSは正しく別のインターフェイスのRDNSSよりも逆引きの質問に答えることができる可能性が高いです。 RDNSSアドレスがより具体的なルート情報と同じRA [RFC6106]で受信された場合に成功の可能性は、おそらく高いです。"
    },
    {
      "indent": 0,
      "text": "A.4. Longest Matching Prefix for Reverse Lookup Decisions",
      "ja": "A.4。逆引き参照の決定のための最長一致プレフィックス"
    },
    {
      "indent": 3,
      "text": "A node can utilize the longest matching prefix approach when deciding which RDNSS to contact for reverse lookup purposes. Namely, the node can send a DNS query to an RDNSS learned over an interface having a longest matching prefix to the address being queried. This approach can help in cases where Unique Local Addressing (ULA) [RFC4193] addresses are used and when the queried address belongs to a node or server within the same network (for example, intranet).",
      "ja": "逆引きのために連絡するRDNSSかを決定するとき、ノードは、最長一致接頭アプローチを利用することができます。すなわち、ノードRDNSSにDNSクエリを送信することができますが照会されているアドレスに最長一致プレフィックスを持つインタフェース上で学びました。このアプローチは、一意のローカルに（ULA）のアドレス指定の場合に、[RFC4193]のアドレスが使用されることができ及び照会アドレスは同じネットワーク（例えば、イントラネット）内のノードまたはサーバに属している場合。"
    },
    {
      "indent": 0,
      "text": "Appendix B. DNSSEC and Multiple Answers Validating with Different Trust Anchors",
      "ja": "付録B. DNSSECと異なるトラストアンカーを検証複数回答"
    },
    {
      "indent": 3,
      "text": "When validating DNS answers with DNSSEC, a validator might order the list of trust anchors it uses to start validation chains, in the order of the node's preferences for those trust anchors. A node could use this ability in order to select among alternative DNS results from different interfaces. Suppose that a node has a trust anchor for the public DNS root and also has a special-purpose trust anchor for example.com. An answer is received on interface i1 for www.example.com, and the validation for that succeeds by using the public trust anchor. Also, an answer is received on interface i2 for www.example.com, and the validation for that succeeds by using the trust anchor for example.com. In this case, the node has evidence for relying on i2 for answers in the example.com zone.",
      "ja": "DNSSECとDNSの答えを検証する際、バリデータはそれがそれらの信頼アンカーのためのノードの好みの順番で、検証チェーンを開始するために使用するトラストアンカーのリストを注文することがあります。ノードは、異なるインターフェースから別のDNS結果の中から選択するためにこの能力を使用することができます。ノードは、パブリックDNSルートのトラストアンカーを持っており、またexample.comの専用のトラストアンカーを持っていると仮定します。答えはwww.example.comのインターフェースI1上で受信され、そのための検証はパブリックトラストアンカーを使用して成功しました。また、答えはwww.example.comのインターフェースI2上で受信され、そのための検証がexample.comのトラストアンカーを使用して成功しました。この場合、ノードはexample.comゾーンで答えをI2に頼るのための証拠を持っています。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Pseudocode for RDNSS Selection",
      "ja": "RDNSS選択のための付録C.擬似コード"
    },
    {
      "indent": 3,
      "text": "This section illustrates the RDNSS selection logic in C-style pseudocode. The code is not intended to be usable as such; it is only here for illustration purposes.",
      "ja": "このセクションでは、Cスタイルの擬似コードでRDNSS選択ロジックを示しています。コードは、次のような利用可能であることを意図するものではありません。それは説明のためにここだけです。"
    },
    {
      "indent": 3,
      "text": "The beginning of the whole procedure is a call to \"dns_query\" function with a query and list of RDNSSes given as parameters.",
      "ja": "全体の手順の初めには、パラメータとして与えられたRDNSSesのクエリとリストと「dns_query」関数の呼び出しです。"
    },
    {
      "indent": 0,
      "text": "/* This is a structure that holds all information related to an RDNSS.*/\n/* Here we include only the information related for this illustration.*/\nstruct rdnss\n{\n  int prf;        /* Preference of an RDNSS.                          */\n  int interface;  /* Type of an interface RDNSS was learned over.     */\n  struct d_and_n; /* Domains and networks information for this RDNSS. */\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "int has_special_knowledge( const struct rdnss *rdnss,\n                           const char *query)\n{\n/* This function matches the query to the domains and networks\n   information of the given RDNSS.  The function returns TRUE\n   if the query matches the domains and networks; otherwise, FALSE.   */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* The implementation of this matching function\n   is left for reader, or rather writer.                              */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* return TRUE if query matches rdnss->d_and_n, otherwise FALSE.      */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "const struct rdnss* compare_rdnss_prf( const struct rdnss *rdnss_1,\n                                       const struct rdnss *rdnss_2 )\n{\n/* This function compares preference values of two RDNSSes and\n   returns the more preferred RDNSS.  The function prefers rdnss_1\n   in the case of equal preference values.                            */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "  if (rdnss_1->prf == HIGH_PRF) return rdnss_1;\n  if (rdnss_2->prf == HIGH_PRF) return rdnss_2;\n  if (rdnss_1->prf == MED_PRF) return rdnss_1;\n  if (rdnss_2->prf == MED_PRF) return rdnss_2;\n  return rdnss_1;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "const struct rdnss* compare_rdnss_trust( const struct rdnss *rdnss_1,\n                                         const struct rdnss *rdnss_2 )\n{\n/* This function compares trust of the two given RDNSSes.  The trust\n   is based on the trust on the interface RDNSS was learned on.       */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* If the interface is the same, the trust is also the same,\n   and hence, function will return NULL to indicate lack of\n   difference in trust.                                               */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "if (rdnss_1->interface == rdnss_2->interface) return NULL;",
      "ja": "IF（rdnss_1->インターフェイス== rdnss_2->インターフェイス）戻りNULL。"
    },
    {
      "indent": 0,
      "text": "/* Otherwise, implementation-specific rules define which interface\n   is considered more secure than the other.  The rules shown here\n   are only for illustrative purposes and must be overwritten by\n   real implementations.                                              */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "if (rdnss_1->interface == IF_VPN) return rdnss_1;\nif (rdnss_2->interface == IF_VPN) return rdnss_2;\nif (rdnss_1->interface == IF_CELLULAR) return rdnss_1;\nif (rdnss_2->interface == IF_CELLULAR) return rdnss_2;\nif (rdnss_1->interface == IF_WLAN) return rdnss_1;\nif (rdnss_2->interface == IF_WLAN) return rdnss_2;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Both RDNSSes are from unknown interfaces, so return NULL as\n   trust-based comparison is impossible.                              */\n  return NULL;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "int compare_rdnsses ( const struct rdnss *rdnss_1,\n                      const struct rdnss *rdnss_2,\n                      const char *query)\n{\n/* This function compares two RDNSSes and decides which one is more\n   preferred for resolving the query.  If the rdnss_1 is more\n   preferred, the function returns TRUE; otherwise, FALSE.            */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "const struct rdnss *more_trusted_rdnss = NULL;\nconst struct rdnss *less_trusted_rdnss = NULL;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Find out if either RDNSS is more trusted.                          */\n  more_trusted_rdnss = compare_rdnss_trust( rdnss_1, rdnss_2 );",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Check if either was more trusted.                                  */\n  if (more_trusted_rdnss)\n    {",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Check which RDNSS was less trusted.                                */\n      less_trusted_rdnss =\n          more_trusted_rdnss == rdnss_1 ? rdnss_2 : rdnss_1;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* If the more trusted interface is not of low preference\n   or has special knowledge about the query, or the more\n   trusted is more preferred and the less trusted has no special\n   information, prefer more trusted.  Otherwise, prefer less trusted. */\n      if (more_trusted_rdnss->prf != LOW_PRF ||\n          has_special_knowledge( more_trusted_rdnss, query ) ||\n          (compare_rdnss_prf( more_trusted_rdnss, less_trusted_rdnss)\n               == more_trusted_rdnss &&\n           !has_special_knowledge( less_trusted_rdnss, query)))",
      "raw": true
    },
    {
      "indent": 0,
      "text": "        {\n/* If the more_trusted_rdnss was rdnss_1, return TRUE.                */\n          return more_trusted_rdnss == rdnss_1 ? TRUE : FALSE;\n        }\n      else\n        {\n/* If the more_trusted_rdnss was rdnss_1, return TRUE.                */\n          return less_trusted_rdnss == rdnss_1 ? TRUE : FALSE;\n        }\n    }\n  else\n    {\n/* There is no trust difference between RDNSSes; therefore, prefer the\n   RDNSS that has special knowledge.  If both have specific knowledge,\n   then prefer the rdnss_1.                                           */\n      if (has_special_knowledge( rdnss_1, query )) return TRUE;\n      if (has_special_knowledge( rdnss_2, query )) return FALSE;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Neither had special knowledge.  Therefore, return TRUE if\n   rdnss_1 is more preferred; otherwise, return FALSE                 */\n      return compare_rdnss_prf( rdnss_1 , rdnss_2 )\n          == rdnss_1 ? TRUE : FALSE;\n    }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "void bubble_sort_rdnsses( struct rdnss rdnss_list[],\n                          const int rdnsses,\n                          const char* query)\n{\n/* This function implements a bubble sort to arrange\n   RDNSSes in rdnss_list into preference order.                       */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "int i;\nint swapped = 0;\nstruct rdnss rdnss_swap;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "  do\n    {\n/* Clear swapped-indicator.                                           */\n      swapped = FALSE;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Go through the RDNSS list.                                         */\n      for (i = 0; i < rdnsses-1; i++)\n        {\n/* Check if the next two items are in the right order, i.e.,\n   more preferred before less preferred.                              */\n          if (compare_rdnsses( &rdnss_list[i],\n                               &rdnss_list[i+1], query) == FALSE)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "            {\n/* The order between two was not right, so swap these two RDNSSes.    */\n              rdnss_swap = rdnss_list[i];\n              rdnss_list[i] = rdnss_list[i+1];\n              rdnss_list[i+1] = rdnss_swap;\n              swapped = TRUE;\n            }\n        }\n    } while (swapped);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* No more swaps, which means the rdnss_list is now sorted\n   into preference order.                                             */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct hostent *dns_query( struct rdnss rdnss_list[],\n                           const int rdnsses,\n                           const char* query )\n{\n/* Perform address resolution for the query.                          */\n  int i;\n  struct hostent response;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Sort the RDNSSes into preference order.                            */\n/* This is the function with which this pseudocode starts.            */\n  bubble_sort_rdnsses( &rdnss_list[0], rdnsses, query );",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Go thourgh all RDNSSes or until valid response is found.           */\n  for (i = 0; i < rdnsses; i++)\n    {",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Use the highest preference RDNSS first.                            */\n      response = send_and_validate_dns_query( rndss_list[i], query);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Check if DNSSEC validation is in use, and if so, validate the\n   received response.                                                 */\n      if (dnssec_in_use)\n        {\n          response = dnssec_validate(response);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* If response is validated, use that.  Otherwise, proceed to next\n   RDNSS.                                                             */\n          if (response) return response;\n          else continue;\n        }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* If acceptable response has been found, return it.                  */\n      if (response) return response;\n    }",
      "raw": true
    },
    {
      "indent": 0,
      "text": " return NULL; }",
      "ja": "NULLを返します。 }"
    },
    {
      "indent": 0,
      "text": "Appendix D. Acknowledgements",
      "ja": "付録D.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank the following people for their valuable feedback and improvement ideas: Mark Andrews, Jari Arkko, Marcelo Bagnulo, Brian Carpenter, Stuart Cheshire, Lars Eggert, Stephan Farrell, Tomohiro Fujisaki, Brian Haberman, Peter Koch, Suresh Krishnan, Murray Kucherawy, Barry Leiba, Edward Lewis, Kurtis Lindqvist, Arifumi Matsumoto, Erik Nordmark, Steve Padgett, Fabien Rapin, Matthew Ryan, Robert Sparks, Dave Thaler, Sean Turner, Margaret Wasserman, Dan Wing, and Dec Wojciech. Ted Lemon and Julien Laganier receive special thanks for their contributions to security considerations.",
      "ja": "著者は、彼らの貴重なフィードバックや改善のアイデアを以下の人々に感謝したいと思います：マーク・アンドリュース、ヤリArkko、マルセロBagnulo、ブライアン・カーペンター、スチュアートチェシャー、ラースEggertの、ステファン・ファレル、藤崎智宏、ブライアンハーバーマン、ピーター・コッホ、スレシュクリシュナン、マレーKucherawy、バリー・レイバ、エドワード・ルイス、カーティスLindqvist、Arifumi松本、エリックNordmarkと、スティーブ・パジェット、ファビアンRapin、マシュー・ライアン、ロバート・スパークス、デーブターラー、ショーン・ターナー、マーガレットワッサーマン、ダン・ウィング、及び12月ヴォイチェフ。テッド・レモンとジュリアンLaganierはセキュリティ上の配慮への貢献のために特別な感謝を受けます。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Teemu Savolainen Nokia Hermiankatu 12 D Tampere FI-33720 Finland",
      "ja": "テームSavolainenのノキアHermiankatu 12 DタンペレFI-33720フィンランド"
    },
    {
      "indent": 3,
      "text": "EMail: teemu.savolainen@nokia.com",
      "ja": "メールアドレス：teemu.savolainen@nokia.com"
    },
    {
      "indent": 3,
      "text": "Jun-ya Kato NTT 9-11, Midori-Cho 3-Chome Musashino-Shi Tokyo 180-8585 Japan",
      "ja": "じゅんーや かと んっｔ ９ー１１、 みどりーちょ ３ーちょめ むさしのーし ときょ １８０ー８５８５ じゃぱん"
    },
    {
      "indent": 3,
      "text": "EMail: kato@syce.net",
      "ja": "メールアドレス：kato@syce.net"
    },
    {
      "indent": 3,
      "text": "Ted Lemon Nominum, Inc. 2000 Seaport Boulevard Redwood City, CA 94063 USA",
      "ja": "テッド・レモンノミナム社2000シーポート大通りレッドウッドシティ、CA 94063 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 381 6000 EMail: Ted.Lemon@nominum.com",
      "ja": "電話：+1 650 381 6000 Eメール：Ted.Lemon@nominum.com"
    }
  ]
}