{
  "title": {
    "text": "RFC 6617 - Secure Pre-Shared Key (PSK) Authentication for the Internet Key Exchange Protocol (IKE)",
    "ja": "RFC 6617 - インターネット鍵交換プロトコル（IKE）のための事前共有キー（PSK）の認証をセキュア"
  },
  "number": 6617,
  "created_at": "2019-10-28 09:00:44.229275+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        D. Harkins\nRequest for Comments: 6617                                Aruba Networks\nCategory: Experimental                                         June 2012\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 14,
      "text": " Secure Pre-Shared Key (PSK) Authentication\nfor the Internet Key Exchange Protocol (IKE)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo describes a secure pre-shared key (PSK) authentication method for the Internet Key Exchange Protocol (IKE). It is resistant to dictionary attack and retains security even when used with weak pre-shared keys.",
      "ja": "このメモは、インターネット鍵交換プロトコル（IKE）のための安全な事前共有鍵（PSK）認証方法を説明します。これは、辞書攻撃に耐性があると弱い事前共有キーを使用する場合でも、セキュリティを保持します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6617.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6617で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2012 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Keyword Definitions ........................................3\n2. Usage Scenarios .................................................3\n3. Terms and Notation ..............................................4\n4. Discrete Logarithm Cryptography .................................5\n   4.1. Elliptic Curve Cryptography (ECP) Groups ...................5\n   4.2. Finite Field Cryptography (MODP) Groups ....................7\n5. Random Numbers ..................................................8\n6. Using Passwords and Raw Keys For Authentication .................8\n7. Assumptions .....................................................9\n8. Secure PSK Authentication Message Exchange ......................9\n   8.1. Negotiation of Secure PSK Authentication ..................10\n   8.2. Fixing the Secret Element, SKE ............................11\n        8.2.1. ECP Operation to Select SKE ........................12\n        8.2.2. MODP Operation to Select SKE .......................13\n   8.3. Encoding and Decoding of Group Elements and Scalars .......14\n        8.3.1. Encoding and Decoding of Scalars ...................14\n        8.3.2. Encoding and Decoding of ECP Elements ..............15\n        8.3.3. Encoding and Decoding of MODP Elements .............15\n   8.4. Message Generation and Processing .........................16\n        8.4.1. Generation of a Commit .............................16\n        8.4.2. Processing of a Commit .............................16\n               8.4.2.1. Validation of an ECP Element ..............16\n               8.4.2.2. Validation of a MODP Element ..............16\n               8.4.2.3. Commit Processing Steps ...................17\n        8.4.3. Authentication of the Exchange .....................17\n   8.5. Payload Format ............................................18\n        8.5.1. Commit Payload .....................................18\n   8.6. IKEv2 Messaging ...........................................19\n9. IANA Considerations ............................................20\n10. Security Considerations .......................................20\n11. Acknowledgements ..............................................22\n12. References ....................................................22\n   12.1. Normative References .....................................22\n   12.2. Informative References ...................................23",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "[RFC5996] allows for authentication of the IKE peers using a pre-shared key. This exchange, though, is susceptible to dictionary attack and is therefore insecure when used with weak pre-shared keys, such as human-memorizable passwords. To address the security issue, [RFC5996] recommends that the pre-shared key used for authentication \"contain as much unpredictability as the strongest key being negotiated\". That means any non-hexadecimal key would require over 100 characters to provide enough strength to generate a 128-bit key suitable for AES. This is an unrealistic requirement because humans have a hard time entering a string over 20 characters without error. Consequently, pre-shared key authentication in [RFC5996] is used insecurely today.",
      "ja": "[RFC5996]は事前共有キーを使用して、IKEピアの認証を可能にします。この交換は、しかし、辞書攻撃に感受性であり、そのような人間記憶可能パスワードなど弱い事前共有キーと共に使用される場合、したがって安全ではありません。セキュリティ上の問題に対処するには、[RFC5996]は認証に使用する事前共有キーは「最強のキーは交渉中な限り予測不可能性が含まれている」ことをお勧めします。すなわち、任意の非進キーは、AESに適した128ビットの鍵を生成するのに十分な強度を提供するために100以上の文字を必要とするであろうことを意味します。人間はエラーなしで20文字以上の文字列を入力する苦労を持っているので、これは非現実的な要件です。その結果、[RFC5996]で事前共有鍵認証は、今日安全でない使用されています。"
    },
    {
      "indent": 3,
      "text": "A pre-shared key authentication method built on top of a zero-knowledge proof will provide resistance to dictionary attack and still allow for security when used with weak pre-shared keys, such as user-chosen passwords. Such an authentication method is described in this memo.",
      "ja": "ゼロ知識証明の上に構築された事前共有鍵認証方式は、辞書攻撃に対する耐性を提供し、ユーザが選択したパスワードなどの弱い事前共有キーと共に使用される場合、依然としてセキュリティを可能にします。そのような認証方法は、このメモに記載されています。"
    },
    {
      "indent": 3,
      "text": "Resistance to dictionary attack is achieved when an adversary gets one, and only one, guess at the secret per active attack (see, for example, [BM92], [BMP00], and [BPR00]). Another way of putting this is that any advantage the adversary can realize is through interaction and not through computation. This is demonstrably different than the technique from [RFC5996] of using a large, random number as the pre-shared key. That can only make a dictionary attack less likely to succeed; it does not prevent a dictionary attack. Furthermore, as [RFC5996] notes, it is completely insecure when used with weak keys like user-generated passwords.",
      "ja": "辞書攻撃に対する耐性は、敵対者がいずれかを取得したときに達成し、一方のみが、（[BPR00]と、[BMP00]、[BM92]、例えば、参照）を活性な攻撃当たり秘密に推測されます。これを置くことのもう一つの方法は、敵が実現できる任意の利点は、相互作用を介してではなく、計算を通じてであるということです。これは、事前共有鍵として大きい、乱数を用いての[RFC5996]の手法より明らかに異なっています。それだけで成功する可能性が低い辞書攻撃を行うことができます。それは、辞書攻撃を防ぐことはできません。ユーザが生成したパスワードのような弱いキーで使用される場合、さらに、[RFC5996]のノートとして、それは完全に安全ではありません。"
    },
    {
      "indent": 0,
      "text": "1.1. Keyword Definitions",
      "section_title": true,
      "ja": "1.1。キーワードの定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Usage Scenarios",
      "section_title": true,
      "ja": "2.使用シナリオ"
    },
    {
      "indent": 3,
      "text": "[RFC5996] describes usage scenarios for IKEv2. These are:",
      "ja": "[RFC5996]はIKEv2のための使用シナリオを説明しています。これらは："
    },
    {
      "indent": 3,
      "text": "1. \"Security Gateway to Security Gateway Tunnel\": The endpoints of the IKE (and IPsec) communication are network nodes that protect traffic on behalf of connected networks. Protected traffic is between devices on the respective protected networks.",
      "ja": "1.「セキュリティゲートウェイトンネルへのセキュリティゲートウェイ」：IKE（およびIPSec）のエンドポイント通信接続されたネットワークに代わってトラフィックを保護するネットワーク・ノードです。保護されたトラフィックは、それぞれの保護されたネットワーク上のデバイスとの間にあります。"
    },
    {
      "indent": 3,
      "text": "2. \"Endpoint-to-Endpoint Transport\": The endpoints of the IKE (and IPsec) communication are hosts according to [RFC4301]. Protected traffic is between the two endpoints.",
      "ja": "2.「エンドポイント・ツー・エンドポイントのトランスポート」：IKE（およびIPsec）通信のエンドポイントは、[RFC4301]に記載の宿主です。保護されたトラフィックは、2つのエンドポイント間にあります。"
    },
    {
      "indent": 3,
      "text": "3. \"Endpoint to Security Gateway Tunnel\": One endpoint connects to a protected network through a network node. The endpoints of the IKE (and IPsec) communication are the endpoint and network node, but the protected traffic is between the endpoint and another device on the protected network behind the node.",
      "ja": "3.「セキュリティゲートウェイトンネルのエンドポイント」：一方のエンドポイントがネットワーク・ノードを介して保護されたネットワークに接続します。 IKE（およびIPsec）通信のエンドポイントは、エンドポイントとネットワークノードであるが、保護されたトラフィックは、ノードの後ろに保護されたネットワーク上のエンドポイントと他の装置との間です。"
    },
    {
      "indent": 3,
      "text": "The authentication and key exchange process described in this memo is suitable for all the usage scenarios described in [RFC5996]. In the \"Security Gateway to Security Gateway Tunnel\" scenario and the \"Endpoint-to-Endpoint Transport\" scenario, it provides a secure method of authentication without requiring a certificate. For the \"Endpoint to Security Gateway Tunnel\" scenario, it provides for secure username+password authentication that is popular in remote-access VPN situations.",
      "ja": "このメモに記載された認証及び鍵交換処理は、[RFC5996]に記載されているすべての使用シナリオに適しています。 「セキュリティゲートウェイセキュリティゲートウェイトンネルへの」シナリオと「エンドポイント間の交通」のシナリオでは、証明書を必要とせずに、認証の安全な方法を提供します。 「エンドポイントセキュリティゲートウェイへのトンネル」のシナリオの場合は、リモートアクセスVPNの状況で人気のある安全なユーザ名+パスワード認証を提供します。"
    },
    {
      "indent": 0,
      "text": "3. Terms and Notation",
      "section_title": true,
      "ja": "3.用語と表記"
    },
    {
      "indent": 3,
      "text": "The following terms and notations are used in this memo:",
      "ja": "以下の用語および表記法はこのメモで使用されています。"
    },
    {
      "indent": 3,
      "text": "PSK A shared, secret, and potentially low-entropy word, phrase, code, or key used as a credential to mutually authenticate the peers.",
      "ja": "PSK Aは、共有秘密、および潜在的に低エントロピー単語、フレーズ、コード、またはキーは、互いにピアを認証する証明書として使用されます。"
    },
    {
      "indent": 3,
      "text": "a = prf(b, c) The string \"b\" and \"c\" are given to a pseudo-random function (prf) to produce a fixed-length output \"a\".",
      "ja": "= PRF（B、C）は、文字列 \"B\" および \"C\" は、固定長の出力 \"A\" を生成する擬似ランダム関数（PRF）に与えられます。"
    },
    {
      "indent": 3,
      "text": "a | b denotes concatenation of string \"a\" with string \"b\".",
      "ja": "| b「は」文字列と「b」を、文字列の連結を示しています。"
    },
    {
      "indent": 3,
      "text": "[a]b indicates a string consisting of the single bit \"a\" repeated \"b\" times.",
      "ja": "[A] Bは、単一ビット「」繰り返し「B」の時間からなる文字列を示しています。"
    },
    {
      "indent": 3,
      "text": "len(a) indicates the length in bits of the string \"a\".",
      "ja": "LEN（a）は、文字列「A」のビットの長さを示しています。"
    },
    {
      "indent": 3,
      "text": "LSB(a) returns the least-significant bit of the bitstring \"a\".",
      "ja": "LSB（a）は、ビット列「A」の最下位ビットを返します。"
    },
    {
      "indent": 3,
      "text": "element one member of a finite cyclic group.",
      "ja": "要素の有限巡回群の一員。"
    },
    {
      "indent": 3,
      "text": "scalar a quantity that can multiply an element.",
      "ja": "要素を乗算することができる量をスカラー。"
    },
    {
      "indent": 3,
      "text": "The convention for this memo to represent an element in a finite cyclic group is to use an upper-case letter or acronym, while a scalar is indicated with a lowercase letter or acronym.",
      "ja": "スカラーは、小文字または頭字語で示されている間、有限巡回群の要素を表すために、このメモのための規則は、大文字または頭字語を使用することです。"
    },
    {
      "indent": 0,
      "text": "4. Discrete Logarithm Cryptography",
      "section_title": true,
      "ja": "4.離散対数暗号"
    },
    {
      "indent": 3,
      "text": "This protocol uses Discrete Logarithm Cryptography to achieve authentication. Each party to the exchange derives ephemeral public and private keys with respect to a particular set of domain parameters (referred to here as a \"group\"). Groups can be either based on finite field cryptography (modular exponentiation (MODP) groups) or elliptic curve cryptography (ECP groups).",
      "ja": "このプロトコルは、認証を達成するために離散対数暗号を使用しています。為替への各当事者は、（「グループ」としてここに呼ばれる）ドメインパラメータの特定のセットに関してはかない公開鍵と秘密鍵を導出します。基は、いずれかの有限体暗号（べき乗剰余（MODP）基）や楕円曲線暗号（ECP基）に基づくことができます。"
    },
    {
      "indent": 3,
      "text": "This protocol uses the same group as the IKE exchange in which it is being used for authentication, with the exception of characteristic-two elliptic curve groups (EC2N). Use of such groups is undefined for this authentication method, and an IKE exchange that negotiates one of these groups MUST NOT use this method of authentication.",
      "ja": "このプロトコルは、それが特徴個の楕円曲線群（EC2N）を除いて、認証のために使用されているIKE交換の同じグループを使用します。このような基の使用は、この認証方法、およびこの認証方法を使用してはならないこれらのグループのいずれかを交渉するIKE交換のために定義されていません。"
    },
    {
      "indent": 3,
      "text": "For each group, the following operations are defined:",
      "ja": "各グループについて、以下の動作が定義されています。"
    },
    {
      "indent": 3,
      "text": "o \"scalar operation\" -- takes a scalar and an element in the group to produce another element -- Z = scalar-op(x, Y).",
      "ja": "O「スカラー演算は、」 -  Z =スカラーOP（X、Y） - スカラーと別の要素を生成するために、グループ内の要素をとります。"
    },
    {
      "indent": 3,
      "text": "o \"element operation\" -- takes two elements in the group to produce a third -- Z = element-op(X, Y).",
      "ja": "O「要素動作は、」 -  Z =要素-OP（X、Y） - 三分の一を生成するために、グループ内の2つの要素をとります。"
    },
    {
      "indent": 3,
      "text": "o \"inverse operation\" -- takes an element and returns another element such that the element operation on the two produces the identity element of the group -- Y = inverse(X).",
      "ja": "O「逆動作」 - 要素を取り、2つのオン素子動作は、グループの識別要素生成するように別の要素を返し -  Y =インバース（X）を。"
    },
    {
      "indent": 0,
      "text": "4.1. Elliptic Curve Cryptography (ECP) Groups",
      "section_title": true,
      "ja": "4.1。楕円曲線暗号（ECP）グループ"
    },
    {
      "indent": 3,
      "text": "The key exchange defined in this memo uses fundamental algorithms of ECP groups as described in [RFC6090].",
      "ja": "[RFC6090]に記載されているように、このメモで定義された鍵交換は、ECPグループの基本的なアルゴリズムを使用します。"
    },
    {
      "indent": 3,
      "text": "Domain parameters for ECP elliptic curves used for Secure PSK Authentication include:",
      "ja": "セキュアPSK認証に使用ECP楕円曲線のドメインパラメータが含まれます："
    },
    {
      "indent": 3,
      "text": "o A prime, p, determining a prime field GF(p). The cryptographic group will be a subgroup of the full elliptic curve group that consists of points on an elliptic curve -- elements from GF(p) that satisfy the curve's equation -- together with the \"point at infinity\" (denoted here as \"0\") that serves as the identity element.",
      "ja": "素体GF（p）を決定素数、P、O。曲線の式を満たすGF（P）からの要素 -   - 一緒に「無限遠点」（0」としてここで示される暗号群は、楕円曲線上の点で構成され、完全な楕円曲線群のサブグループであろう「）同一の要素として機能します。"
    },
    {
      "indent": 3,
      "text": "o Elements a and b from GF(p) that define the curve's equation. The point (x,y) is on the elliptic curve if and only if y^2 = x^3 + a*x + b.",
      "ja": "曲線の方程式を定義GF（P）からO要素AおよびB。点（x、y）は、楕円曲線上にある場合のみ、Y ^ 2 = X ^ 3 + A * X + bの場合。"
    },
    {
      "indent": 3,
      "text": "o A prime, r, which is the order of, or number of elements in, a subgroup generated by an element G.",
      "ja": "Oプライム、の順で、R、または内の要素の数、要素Gによって生成されたサブグループ"
    },
    {
      "indent": 3,
      "text": "The scalar operation is multiplication of a point on the curve by itself a number of times. The point Y is multiplied x-times to produce another point Z:",
      "ja": "スカラー演算は、それ自体により回数曲線上の点の乗算です。点Yは、別の点Zを生成するために、X回乗算されます。"
    },
    {
      "indent": 7,
      "text": "Z = scalar-op(x, Y) = x*Y",
      "ja": "Z =スカラー-OP（X、Y）= X * Y"
    },
    {
      "indent": 3,
      "text": "The element operation is addition of two points on the curve. Points X and Y are summed to produce another point Z:",
      "ja": "素子動作は、曲線上の2点の追加です。点XとYは、別の点Zを生成するために合計されます。"
    },
    {
      "indent": 7,
      "text": "Z = element-op(X, Y) = X + Y",
      "ja": "Z =エレメント-OP（X、Y）= X + Y"
    },
    {
      "indent": 3,
      "text": "The inverse function is defined such that the sum of an element and its inverse is \"0\", the point-at-infinity of an elliptic curve group:",
      "ja": "逆関数は、要素の和とその逆数が「0」点で無限大の楕円曲線群であるように定義されます。"
    },
    {
      "indent": 7,
      "text": "Q + inverse(Q) = \"0\"",
      "ja": "Q +逆（Q）= \"0\""
    },
    {
      "indent": 3,
      "text": "Elliptic curve groups require a mapping function, q = F(Q), to convert a group element to an integer. The mapping function used in this memo returns the x-coordinate of the point it is passed.",
      "ja": "楕円曲線グループは、整数にグループ要素を変換するために、Q = F（Q）、マッピング機能を必要とします。このメモで使用されるマッピング関数は、渡された点のx座標を返します。"
    },
    {
      "indent": 3,
      "text": "scalar-op(x, Y) can be viewed as x iterations of element-op() by defining:",
      "ja": "スカラー-OP（X、Y）を定義することにより、素子-OP（）のx反復とみなすことができます。"
    },
    {
      "indent": 7,
      "text": "Y = scalar-op(1, Y)",
      "ja": "Y =スカラー-OP（1、Y）"
    },
    {
      "indent": 7,
      "text": "Y = scalar-op(x, Y) = element-op(Y, scalar-op(x-1, Y)), for x > 1",
      "ja": "Y =スカラー-OP（X、Y）=  - オン元素（Y、スカラーの（X-1、Y））、X> 1"
    },
    {
      "indent": 3,
      "text": "A definition of how to add two points on an elliptic curve (i.e., element-op(X, Y)) can be found in [RFC6090].",
      "ja": "楕円曲線（すなわち、要素-OP（X、Y））上の2点を追加する方法の定義は、[RFC6090]に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "Note: There is another ECP domain parameter, a cofactor, h, that is defined by the requirement that the size of the full elliptic curve group (including \"0\") be the product of h and r. ECP groups used for Secure PSK Authentication MUST have a cofactor of one (1). At the time of publication of this memo, all ECP groups in [IKEV2-IANA] had a cofactor of one (1).",
      "ja": "注：別のECPドメインパラメーター、補因子、hはそのは、完全楕円曲線群の大きさはHであり、Rの積である（「0」を含む）の要件によって定義され、あります。セキュアPSK認証に使用ECP基は、1つ（1）の補因子がなければなりません。このメモの公開時に、[IKEv2の-IANA]内のすべてのECP基は、1つ（1）の補因子でした。"
    },
    {
      "indent": 0,
      "text": "4.2. Finite Field Cryptography (MODP) Groups",
      "section_title": true,
      "ja": "4.2。有限フィールド暗号化（MODP）グループ"
    },
    {
      "indent": 3,
      "text": "Domain parameters for MODP groups used for Secure PSK Authentication include:",
      "ja": "セキュアPSK認証に使用MODPグループのドメインパラメータが含まれます："
    },
    {
      "indent": 3,
      "text": "o A prime, p, determining a prime field GF(p), the integers modulo p.",
      "ja": "素数、P O、素体GF（p）を決定し、整数Pを法。"
    },
    {
      "indent": 3,
      "text": "o A prime, r, which is the multiplicative order, and thus also the size, of the cryptographic subgroup of GF(p)* that is generated by an element G.",
      "ja": "また、このようにサイズ乗法オーダーであり、プライム、R、O、GFの暗号サブグループ（P）の*ことは、要素Gによって生成されます"
    },
    {
      "indent": 3,
      "text": "The scalar operation is exponentiation of a generator modulo a prime. An element Y is taken to the x-th power modulo the prime, thereby returning another element, Z:",
      "ja": "スカラ演算は、プライム剰余発電機の累乗です。 Yは、x乗するものと解釈される要素は、それによって別の要素、Zを返す、素数を法。"
    },
    {
      "indent": 7,
      "text": "Z = scalar-op(x, Y) = Y^x mod p",
      "ja": "Z =スカラー-OP（X、Y）= Y ^ X MOD P"
    },
    {
      "indent": 3,
      "text": "The element operation is modular multiplication. Two elements, X and Y, are multiplied modulo the prime, thereby returning another element, Z:",
      "ja": "素子動作は、剰余乗算です。二つの要素、X及びYは、それによって別の要素を返す、素数を法として乗算され、Z。"
    },
    {
      "indent": 7,
      "text": "Z = element-op(X, Y) = (X * Y) mod p",
      "ja": "Z =エレメント-OP（X、Y）=（X * Y）MOD P"
    },
    {
      "indent": 3,
      "text": "The inverse function for a MODP group is defined such that the product of an element and its inverse modulo the group prime equals one (1). In other words,",
      "ja": "MODPグループの逆関数は、要素とグループプライムモジュロその逆数の積が1に等しいように定義されている（1）。言い換えると、"
    },
    {
      "indent": 7,
      "text": "(Q * inverse(Q)) mod p = 1",
      "ja": "（Q *逆数（Q））MOD p = 1"
    },
    {
      "indent": 3,
      "text": "Unlike ECP groups, MODP groups do not require a mapping function to convert an element into an integer. However, for the purposes of notation in protocol definition, the function F, when used below, shall just return the value that was passed to it, i.e., F(i) = i.",
      "ja": "ECPのグループとは異なり、MODPグループが整数に要素を変換するために、マッピング機能を必要としません。以下で使用される場合しかし、プロトコル定義、関数Fで表記の目的のために、それに渡された値を返す、すなわち、F（I）= I。"
    },
    {
      "indent": 3,
      "text": "Some MODP groups in [IKEV2-IANA] are based on safe primes, and the order is not included in the group's domain parameter set. In this case only, the order, r, MUST be computed as the prime minus one divided by two -- (p-1)/2. If an order is included in the group's domain parameter set, that value MUST be used in this exchange when an order is called for. If a MODP group does not include an order in its domain parameter set and is not based on a safe prime, it MUST NOT be used with this exchange.",
      "ja": "[IKEv2の-IANA]の一部のMODPグループは、安全素数に基づいており、順序がグループのドメインパラメータセットに含まれていません。 （P-1）/ 2  - のみこの場合、順序は、R、2で割ったプライムマイナス1として計算されなければなりません。注文がグループのドメインパラメータセットに含まれている場合、その値は順序が要求されるこの交換で使用しなければなりません。 MODPグループは、そのドメインパラメータセットの順番が含まれていない場合は、安全プライムに基づいていない、それはこの交換で使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "5. Random Numbers",
      "section_title": true,
      "ja": "5.乱数"
    },
    {
      "indent": 3,
      "text": "As with IKE itself, the security of the Secure PSK Authentication method relies upon each participant in the protocol producing quality secret random numbers. A poor random number chosen by either side in a single exchange can compromise the shared secret from that exchange and open up the possibility of a dictionary attack.",
      "ja": "IKE自体と同様に、セキュアPSK認証方式のセキュリティは、品質の秘密の乱数を生成するプロトコルの各参加者に依存しています。単一交換でどちらかの側が選択した貧しい乱数がその交換機から共有秘密を侵害し、辞書攻撃の可能性を開くことができます。"
    },
    {
      "indent": 3,
      "text": "Producing quality random numbers without specialized hardware entails using a cryptographic mixing function (like a strong hash function) to mix entropy from multiple, uncorrelated sources of information and events. A very good discussion of this can be found in [RFC4086].",
      "ja": "特殊なハードウェアなし品質の乱数を生成する情報およびイベントの複数の無相関のソースからエントロピーを混合する（強いハッシュ関数のような）暗号混合関数を使用することを伴います。これは非常に良い議論は[RFC4086]で見つけることができます。"
    },
    {
      "indent": 0,
      "text": "6. Using Passwords and Raw Keys For Authentication",
      "section_title": true,
      "ja": "6.認証用パスワードと生のキーの使用"
    },
    {
      "indent": 3,
      "text": "The PSK used as an authentication credential with this protocol can be either a character-based password or passphrase, or it could be a binary or hexadecimal string. Regardless, however, this protocol requires both the Initiator and Responder to have identical binary representations of the shared credential.",
      "ja": "このプロトコルで認証証明書として使用されるPSKは、文字ベースのパスワードまたはパスフレーズのいずれかであり得る、またはそれは、2進数または16進数の文字列であってもよいです。かかわらず、しかし、このプロトコルは、イニシエータとレスポンダの双方が共有資格の同じバイナリ表現を有することが必要となります。"
    },
    {
      "indent": 3,
      "text": "If the PSK is a character-based password or passphrase, there are two types of pre-processing that SHALL be employed to convert the password or passphrase into a hexadecimal string suitable for use with Secure PSK Authentication. If a PSK is already a hexadecimal or binary string, it SHALL be used directly as the shared credential without any pre-processing.",
      "ja": "PSKは、文字ベースのパスワードまたはパスフレーズである場合、セキュアPSK認証で使用するのに適した16進数の文字列にパスワードまたはパスフレーズを変換するために使用することがSHALL前処理の2種類があります。 PSKは既に16進数またはバイナリストリングである場合、それは任意の事前処理なしに共有資格情報として直接使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The first step of pre-processing is to remove ambiguities that may arise due to internationalization. Each character-based password or passphrase MUST be pre-processed to remove that ambiguity by processing the character-based password or passphrase according to the rules of the SASLprep [RFC4013] profile of [RFC3454]. The password or passphrase SHALL be considered a \"stored string\" per [RFC3454], and unassigned code points are therefore prohibited. The output SHALL be the binary representation of the processed UTF-8 character string. Prohibited output and unassigned codepoints encountered in SASLprep pre-processing SHALL cause a failure of pre-processing, and the output SHALL NOT be used with Secure PSK Authentication.",
      "ja": "前処理の最初のステップは、国際化のために生じ得る曖昧さを除去することです。各文字ベースのパスワードまたはパスフレーズは、[RFC3454]のSASLprep [RFC4013]プロフィールのルールに従って文字ベースのパスワードまたはパスフレーズを処理することによって、その曖昧さを除去するために前処理されなければなりません。パスワードまたはパスフレーズは、[RFC3454]あたりの「保存された文字列」とみなされるものとし、未割り当てコードポイントは、したがって、禁止されています。出力は、処理されたUTF-8文字列のバイナリ表現されなければなりません。 SASLprep前処理で遭遇出力禁止と未割り当てコードポイントは、前処理の失敗を引き起こすものとし、出力は、Secure PSK認証で使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "The next pre-processing step for character-based passwords or passphrases is to effectively obfuscate the string. This is done in an attempt to reduce exposure of stored passwords in the event of server compromise, or compromise of a server's database of stored passwords. The step involves taking the output of the SASLprep [RFC4013] profile of [RFC3454] and passing it, as the key, with the",
      "ja": "文字ベースのパスワードまたはパスフレーズのための次の前処理ステップは、効果的に文字列を難読化することです。これは、サーバーの妥協、または保存されたパスワードのサーバのデータベースの侵害が発生した場合に保存されたパスワードの露出を減らすための試みで行われます。ステップはで、キーとして、[RFC3454]のSASLprep [RFC4013]プロフィールの出力を取り、それを通過させることを含みます"
    },
    {
      "indent": 3,
      "text": "ASCII string \"IKE Secure PSK Authentication\", as the data, to HMAC-SHA256(). The output of this obfuscation step SHALL become the shared credential used with Secure PSK Authentication.",
      "ja": "ASCII文字列HMAC-SHA256（）に、データとして、 \"IKEはPSK認証セキュア\"。この難読化ステップの出力は、Secure PSK認証で使用する共有秘密鍵証明書になるもの。"
    },
    {
      "indent": 3,
      "text": "Note: Passwords tend to be shared for multiple purposes, and compromise of a server or database of stored plaintext passwords can be used, in that event, to mount multiple attacks. The obfuscation step is merely to hide the password in the event of server compromise or compromise of the database of stored passwords. Advances in distributed computing power have diminished the effectiveness of performing multiple prf iterations as a technique to prevent dictionary attacks, so no such behavior is proscribed here. Mutually consenting implementations can agree to use a different password obfuscation method; the one described here is for interoperability purposes only.",
      "ja": "注意：パスワードは、複数の目的のために共有される傾向があり、保存された平文パスワードのサーバーやデータベースの妥協点は、複数の攻撃をマウントし、そのイベントに、使用することができます。難読化ステップは、単にサーバーの妥協や保存されたパスワードのデータベースの侵害が発生した場合にパスワードを非表示にすることです。分散コンピューティングパワーの進歩は、辞書攻撃を防ぐための技術として、複数のPRFの反復を行うの有効性を減少しているので、そのような挙動は、ここで禁止されていません。互いに同意の実装は異なるパスワードの難読化方法を使用することに同意することができます。ここで説明したものは、相互運用性のみを目的としています。"
    },
    {
      "indent": 3,
      "text": "If a device stores passwords for use at a later time, it SHOULD pre-process the password prior to storage. If a user enters a password into a device at authentication time, it MUST be pre-processed upon entry and prior to use with Secure PSK Authentication.",
      "ja": "後で使用するためにパスワードをデバイスに保存する場合は、保存前にパスワードを事前処理すべきです。ユーザは、認証時にデバイスにパスワードを入力した場合、それはエントリ時に前処理とセキュアPSK認証で使用する前にしなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Assumptions",
      "section_title": true,
      "ja": "7.仮定"
    },
    {
      "indent": 3,
      "text": "The security of the protocol relies on certain assumptions. They are:",
      "ja": "プロトコルのセキュリティは、特定の仮定に依存しています。彼らです："
    },
    {
      "indent": 3,
      "text": "1. The pseudo-random function, prf, defined in [RFC5996], acts as an \"extractor\" (see [RFC5869]) by distilling the entropy from a secret input into a short, fixed string. The output of prf is indistinguishable from a random source.",
      "ja": "1. [RFC5996]で定義された擬似ランダム関数、PRFは、短い、固定された文字列に秘密の入力からエントロピーを蒸留することによって（[RFC5869]を参照）、「抽出」として作用します。 PRFの出力は、ランダムソースと区別がつきません。"
    },
    {
      "indent": 3,
      "text": "2. The discrete logarithm problem for the chosen finite cyclic group is hard. That is, given G, p and Y = G^x mod p, it is computationally infeasible to determine x. Similarly, for an elliptic curve group given the curve definition, a generator G, and Y = x * G, it is computationally infeasible to determine x.",
      "ja": "2.選択された有限巡回群のための離散対数問題が困難です。すなわち、与えられたG、P及びY = G ^ X MOD pは、Xを決定する計算上実行不可能です。同様に、楕円曲線群についての曲線の定義、ジェネレータGを与え、そしてY = X * Gは、それがXを決定する計算上実行不可能です。"
    },
    {
      "indent": 3,
      "text": "3. The pre-shared key is drawn from a finite pool of potential keys. Each possible key in the pool has equal probability of being the shared key. All potential adversaries have access to this pool of keys.",
      "ja": "3.事前共有キーは、潜在的なキーの有限プールから引き出されます。プール内の各可能なキーは、共有鍵であることの等しい確率を有します。すべての潜在的な敵は、このキーのプールへのアクセス権を持っています。"
    },
    {
      "indent": 0,
      "text": "8. Secure PSK Authentication Message Exchange",
      "section_title": true,
      "ja": "8. PSK認証メッセージ交換をセキュア"
    },
    {
      "indent": 3,
      "text": "The key exchange described in this memo is based on the \"Dragonfly\" key exchange, which has also been defined for use in 802.11 wireless networks (see [SAE]) and as an Extensible Authentication Protocol (EAP) method (see [RFC5931]). \"Dragonfly\" is patent-free and",
      "ja": "このメモに記載の鍵交換も802.11無線ネットワーク（参照[SAE]）および拡張認証プロトコル（EAP）メソッドとして使用するために定義されている「トンボ」鍵交換に基づいている（参照[RFC5931]） 。 「トンボ」はパテントフリーで、"
    },
    {
      "indent": 3,
      "text": "royalty-free. It SHALL use the same pseudo-random function (prf) and the same Diffie-Hellman group that are negotiated for use in the IKE exchange that \"Dragonfly\" is authenticating.",
      "ja": "ロイヤリティフリー。これは、「トンボ」が認証されるのと同じ擬似ランダム関数（PRF）とIKE交換に使用するために交渉される同じのDiffie-Hellmanグループを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A pseudo-random function that uses a block cipher is NOT RECOMMENDED for use with Secure PSK Authentication due to its poor job operating as an \"extractor\" (see Section 7). Pseudo-random functions based on hash functions using the HMAC construct from [RFC2104] SHOULD be used.",
      "ja": "ブロック暗号を使用して擬似ランダム関数は、（セクション7参照）により、「抽出」として動作し、その乏しいジョブへの安全なPSK認証で使用するために推奨されません。 [RFC2104]からHMAC構築物を使用して、ハッシュ関数に基づいて擬似ランダム関数を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "To perform Secure PSK Authentication, each side must generate a shared and secret element in the chosen group based on the pre-shared key. This element, called the Secret Key Element, or SKE, is then used in the \"Dragonfly\" authentication and key exchange protocol. \"Dragonfly\" consists of each side exchanging a Commit payload and then proving knowledge of the resulting shared secret.",
      "ja": "セキュアPSK認証を実行するために、それぞれの側は、事前共有鍵に基づいて選択されたグループ内の共有秘密要素を生成しなければなりません。秘密鍵となる要素、またはSKEと呼ばれるこの要素は、その後、「トンボ」の認証と鍵交換プロトコルで使用されています。 「トンボ」はコミットペイロードを交換した後、得られた共有の秘密の知識を証明する各辺から成ります。"
    },
    {
      "indent": 3,
      "text": "The Commit payload contributes ephemeral information to the exchange and binds the sender to a single value of the pre-shared key from the pool of potential pre-shared keys. An authentication payload (AUTH) proves that the pre-shared key is known and completes the zero-knowledge proof.",
      "ja": "コミットペイロードは交換機に短命情報を寄与し、潜在的な事前共有鍵のプールから事前共有鍵の単一の値を送信側に結合します。認証ペイロード（AUTH）は、事前共有鍵が知られていることを証明するゼロ知識証明を完了する。"
    },
    {
      "indent": 0,
      "text": "8.1. Negotiation of Secure PSK Authentication",
      "section_title": true,
      "ja": "8.1。セキュアPSK認証のネゴシエーション"
    },
    {
      "indent": 3,
      "text": "The Initiator indicates its desire to use Secure PSK Authentication by adding a Notify payload of type SECURE_PASSWORD_METHODS (see [RFC6467]) to the first message of the IKE_SA_INIT exchange and by including 3 in the notification data field of the Notify payload, indicating Secure PSK Authentication.",
      "ja": "イニシエータは、セキュアPSK認証を示すIKE_SA_INIT交換の最初のメッセージ及び通知ペイロードの通知データフィールドに3を含むことにより（[RFC6467]を参照）型SECURE_PASSWORD_METHODSの通知ペイロードを追加することにより、セキュアなPSK認証を使用するように、その要望を示します。"
    },
    {
      "indent": 3,
      "text": "The Responder indicates its acceptance to perform Secure PSK Authentication by adding a Notify payload of type SECURE_PASSWORD_METHODS to its response in the IKE_SA_INIT exchange and by adding the sole value of 3 to the notification data field of the Notify payload.",
      "ja": "レスポンダは、IKE_SA_INIT交換においてその応答に型SECURE_PASSWORD_METHODSの通知ペイロードを追加することによって、及び通知ペイロードの通知データフィールドに3の唯一の値を加算することによりセキュアPSK認証を行うために、その受諾を示します。"
    },
    {
      "indent": 3,
      "text": "If the Responder does not include a Notify payload of type SECURE_PASSWORD_METHODS in its IKE_SA_INIT response, the Initiator MUST terminate the exchange, and it MUST NOT fall back to the PSK authentication method of [RFC5996]. If the Initiator only indicated its support for Secure PSK Authentication (i.e., if the Notify data field only contained 3) and the Responder replies with a Notify payload of type SECURE_PASSWORD_METHODS and a different value in the Notify data field, the Initiator MUST terminate the exchange.",
      "ja": "レスポンダがIKE_SA_INIT応答に型SECURE_PASSWORD_METHODSの通知ペイロードを含まない場合、イニシエータは、交換を終了しなければならない、そしてそれは[RFC5996]のPSK認証方式にフォールバックしてはいけません。 （通知データフィールドは、わずか3が含まれている場合、IE）開始剤のみセキュアPSK認証のためのサポートを示すとレスポンダが型SECURE_PASSWORD_METHODSの通知ペイロードと通知データフィールドの異なる値で応答し、イニシエータは、交換を終了する必要がある場合。"
    },
    {
      "indent": 0,
      "text": "8.2. Fixing the Secret Element, SKE",
      "section_title": true,
      "ja": "8.2。シークレット要素、SKEを修正"
    },
    {
      "indent": 3,
      "text": "The method of fixing SKE depends on the type of group, either MODP or ECP. The function \"prf+\" from [RFC5996] is used as a key derivation function.",
      "ja": "SKEの固定方法は、グループの種類に依存MODPまたはECPのいずれか。関数[RFC5996]から「PRF +」は鍵導出関数として使用されます。"
    },
    {
      "indent": 3,
      "text": "Fixing SKE involves an iterative hunting-and-pecking technique using the prime from the negotiated group's domain parameter set and an ECP- or MODP-specific operation depending on the negotiated group. This technique requires the pre-shared key to be a binary string; therefore, any pre-processing transformation (see Section 6) MUST be performed on the pre-shared key prior to fixing SKE.",
      "ja": "固定SKEは交渉し、グループのドメインパラメータセットからのプライムと交渉しグループに応じて、ECP-またはMODP-特定の操作を使用して、反復探求およびつつき技術を必要とします。この手法は、バイナリ文字列であることを事前共有キーが必要です。従って、任意の前処理変換（セクション6を参照）SKEを固定する前に、事前共有鍵で実行されなければなりません。"
    },
    {
      "indent": 3,
      "text": "To thwart side-channel attacks that attempt to determine the number of iterations of the hunting-and-pecking loop that are used to find SKE for a given password, a security parameter, k, is used to ensure that at least k iterations are always performed.",
      "ja": "与えられたパスワードのSKEを見つけるために使用されている狩猟と-つつきループの反復回数、セキュリティパラメータを決定しようとサイドチャネル攻撃を阻止するために、kが、少なくともk個の反復が常にあることを保証するために使用されます行きました。"
    },
    {
      "indent": 3,
      "text": "Prior to beginning the hunting-and-pecking loop, an 8-bit counter is set to the value one (1). Then the loop begins. First, the pseudo-random function is used to generate a secret seed using the counter, the pre-shared key, and two nonces (without the fixed headers) exchanged by the Initiator and the Responder (see Section 8.6):",
      "ja": "狩猟アンドつつきループを開始する前に、8ビットカウンタが値1に設定されている（1）。その後、ループが開始されます。まず、擬似ランダム関数は、イニシエータとレスポンダ（8.6節を参照）によって交換カウンタ、事前共有鍵、及び（固定ヘッダ無し）は、2つのナンスを使用して、秘密シードを生成するために使用されます。"
    },
    {
      "indent": 6,
      "text": "ske-seed = prf(Ni | Nr, psk | counter)",
      "ja": "SKE-シード= PRF（ニッケル|いいえ、PSK |カウンタ）"
    },
    {
      "indent": 3,
      "text": "Then, the ske-seed is expanded using prf+ to create an ske-value:",
      "ja": "次いで、SKE-シードはSKE値を作成するPRF +を使用して拡張されます。"
    },
    {
      "indent": 6,
      "text": "ske-value = prf+(ske-seed, \"IKE SKE Hunting And Pecking\")",
      "ja": "SKE値= PRF +（SKE-種子、 \"IKE SKE狩猟と盗み\"）"
    },
    {
      "indent": 3,
      "text": "where len(ske-value) is the same as len(p), the length of the prime from the domain parameter set of the negotiated group.",
      "ja": "LEN（SKE値）LEN（P）、ネゴシエートグループのドメインパラメータセットからの素数の長さと同じです。"
    },
    {
      "indent": 3,
      "text": "If the ske-seed is greater than or equal to the prime, p, the counter is incremented, a new ske-seed is generated, and the hunting-and-pecking continues. If ske-seed is less than the prime, p, it is passed to the group-specific operation to select the SKE or fail. If the group-specific operation fails, the counter is incremented, a new ske-seed is generated, and the hunting-and-pecking continues. This process continues until the group-specific operation returns the password element. After the password element has been chosen, a random number is used in place of the password in the ske-seed calculation, and the hunting-and-pecking continues until the counter is greater than the security parameter, k.",
      "ja": "SKE-シードはP、以上の素数に等しい場合、カウンタは、インクリメントされる新しいSKE、シードが生成され、ハンチングアンドつつきは継続します。 SKE-種子が素数、p以下であれば、SKEを選択するか、または失敗するグループ固有の操作に渡されます。グループ固有の操作が失敗した場合、カウンタは、新たなSKE-シードが生成され、インクリメントされ、狩猟と-つつきは継続します。グループ固有の操作は、パスワード要素を返すまで、このプロセスは継続します。パスワード要素が選択された後、乱数をSKEシード計算にパスワードの代わりに使用され、カウンタは、セキュリティパラメータ、kよりも大きくなるまでハンチングアンドつつきは継続します。"
    },
    {
      "indent": 0,
      "text": "8.2.1. ECP Operation to Select SKE",
      "section_title": true,
      "ja": "8.2.1。 SKEを選択するECP操作"
    },
    {
      "indent": 3,
      "text": "The group-specific operation for ECP groups uses ske-value, ske-seed, and the equation of the curve to produce SKE. First, ske-value is used directly as the x-coordinate, x, with the equation of the elliptic curve, with parameters a and b from the domain parameter set of the curve, to solve for a y-coordinate, y.",
      "ja": "ECPグループのグループ固有の操作はSKE値、SKE-種子、およびSKEを生成する曲線の方程式を使用します。まず、SKE値は、y座標yについて解くために、曲線のドメインパラメータセットからパラメータa及びbと、楕円曲線の方程式を用いて、x座標、Xとして直接使用されます。"
    },
    {
      "indent": 3,
      "text": "Note: A method of checking whether a solution to the equation of the elliptic curve is to see whether the Legendre symbol of (x^3 + ax + b) equals one (1). If it does, then a solution exists; if it does not, then there is no solution.",
      "ja": "注：楕円曲線の方程式の解は、のルジャンドル記号（X ^ 3 + AXは、B +）1に等しいかどうかを確認することであるかどうかをチェックする方法（1）。それがない場合は、解決策が存在します。そうでない場合は、解決策はありません。"
    },
    {
      "indent": 3,
      "text": "If there is no solution to the equation of the elliptic curve, then the operation fails, the counter is incremented, a new ske-value and ske-seed are selected, and the hunting-and-pecking continues. If there is a solution then, y is calculated as the square root of (x^3 + ax + b) using the equation of the elliptic curve. In this case, an ambiguity exists as there are technically two solutions to the equation, and ske-seed is used to unambiguously select one of them. If the low-order bit of ske-seed is equal to the low-order bit of y, then a candidate SKE is defined as the point (x,y); if the low-order bit of ske-seed differs from the low-order bit of y then a candidate SKE is defined as the point (x, p-y) where p is the prime from the negotiated group's domain parameter set. The candidate SKE becomes the SKE, and the ECP-specific operation completes successfully.",
      "ja": "楕円曲線の方程式の解が存在しない場合、操作は失敗し、カウンタがインクリメントされ、新たなSKE値とSKEシードが選択され、狩猟アンドつつきが継続されます。溶液はそこである場合、Yはの平方根として計算（X ^ 3 + AX + B）楕円曲線の方程式を使用しています。この場合、曖昧さは、方程式には2つの解決策が技術的に存在するように存在し、SKE-種は明確にそれらのいずれかを選択するために使用されます。 SKE種子の下位ビットは、Yの下位ビットに等しい場合、候補SKEは、点（x、y）として定義されます。 SKE種子の下位ビットは、次にYの下位ビットからの候補を異なる場合SKEは、pがネゴシエートグループのドメインパラメータセットから素数である点（x、P y）と定義されます。候補SKEはSKEになり、ECP-特定の操作が正常に完了します。"
    },
    {
      "indent": 3,
      "text": "Algorithmically, the process looks like this:",
      "ja": "アルゴリズム的に、プロセスは次のようになります。"
    },
    {
      "indent": 9,
      "text": "found = 0\ncounter = 1\nv = psk\ndo {\n  ske-seed = prf(Ni | Nr, v | counter)\n  ske-value = prf+(ske-seed, \"IKE SKE Hunting And Pecking\")\n  if (ske-value < p)\n  then\n    x = ske-value\n    if ( (y = sqrt(x^3 + ax + b)) != FAIL)\n    then\n      if (found == 0)\n      then\n        if (LSB(y) == LSB(ske-seed))\n        then\n          SKE = (x,y)\n        else\n          SKE = (x, p-y)\n        fi\n        found = 1\n        v = random()\n      fi\n    fi\n  fi\n  counter = counter + 1\n} while ((found == 0) || (counter <= k))",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where FAIL indicates that there is no solution to sqrt(x^3 + ax + b).",
      "ja": "FAILにはSQRTの溶液（X ^ 3 + AX + B）が存在しないことを示します。"
    },
    {
      "indent": 20,
      "text": "Figure 1: Fixing SKE for ECP Groups",
      "ja": "図1：ECPグループのためのSKEを修正"
    },
    {
      "indent": 3,
      "text": "Note: For ECP groups, the probability that more than \"n\" iterations of the hunting-and-pecking loop are required to find SKE is roughly (1-(r/2p))^n, which rapidly approaches zero (0) as \"n\" increases.",
      "ja": "注：ECPグループについて、迅速にゼロに近づく狩猟アンドつつきループ以上の「n」は反復がSKEはおおよそ（1-（R / 2P））で見つけることが必要であること確率^ nは、（0）と\"n\" が増加します。"
    },
    {
      "indent": 0,
      "text": "8.2.2. MODP Operation to Select SKE",
      "section_title": true,
      "ja": "8.2.2。 SKEを選択するMODP操作"
    },
    {
      "indent": 3,
      "text": "The group-specific operation for MODP groups takes ske-value, the prime, p, and order, r, from the group's domain parameter set to directly produce a candidate SKE by exponentiating the ske-value to the value ((p-1)/r) modulo the prime. If the candidate SKE is greater than one (1), the candidate SKE becomes the SKE, and the MODP-specific operation completes successfully. Otherwise, the MODP-specific operation fails (and the hunting-and-pecking continues).",
      "ja": "MODPグループのグループ固有の動作）を直接値（（P-1にSKE値を累乗することによって候補SKEを生成するように設定されたグループのドメインパラメータから、R、SKE値、素数、p及び順序を取り/ R）の素数を法。候補SKE（1）が1より大きい場合、候補SKEはSKEなり、MODP固有の動作が正常に完了しました。それ以外の場合は、MODP固有の操作が失敗した（と狩猟-と-つつきは継続します）。"
    },
    {
      "indent": 3,
      "text": "Algorithmically, the process looks like this:",
      "ja": "アルゴリズム的に、プロセスは次のようになります。"
    },
    {
      "indent": 9,
      "text": "found = 0\ncounter = 1\nv = psk\ndo {\n  ske-seed = prf(Ni | Nr, v | counter)\n  ske-value = prf+(ske-seed, \"IKE SKE Hunting And Pecking\")\n  if (ske-value < p)\n  then\n    ELE = ske-value ^ ((p-1)/r) mod p\n    if (ELE > 1)\n    then\n      if (found == 0)\n        SKE = ELE\n        found = 1\n        v = random()\n      fi\n    fi\n  fi\n  counter = counter + 1\n} while ((found == 0) || (counter <= k))",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 2: Fixing SKE for MODP Groups",
      "ja": "図2：MODPグループのためのSKEを修正"
    },
    {
      "indent": 3,
      "text": "Note: For MODP groups, the probability that more than \"n\" iterations of the hunting-and-pecking loop are required to find SKE is roughly ((m-p)/p)^n, where m is the largest unsigned number that can be expressed in len(p) bits, which rapidly approaches zero (0) as \"n\" increases.",
      "ja": "注：MODPグループについて、狩猟アンドつつきループ以上の「n」は反復がSKEを見つけるために必要とされる確率は、おおよそ（（MP）/ P）である^ nは、mは、とすることができる最大の符号なし数であります急速にゼロ（0）のような「N」増加に近づくLEN（P）ビットで表現。"
    },
    {
      "indent": 0,
      "text": "8.3. Encoding and Decoding of Group Elements and Scalars",
      "section_title": true,
      "ja": "8.3。グループ要素とスカラーのエンコードとデコード"
    },
    {
      "indent": 3,
      "text": "The payloads used in the Secure PSK Authentication method contain elements from the negotiated group and scalar values. To ensure interoperability, scalars and field elements MUST be represented in payloads in accordance with the requirements in this section.",
      "ja": "セキュアPSK認証方式に使用されるペイロードは、ネゴシエート群とスカラー値の要素を含みます。相互運用性を確保するために、スカラとフィールド要素は、このセクションの要件に従ってペイロードに表現されなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.3.1. Encoding and Decoding of Scalars",
      "section_title": true,
      "ja": "8.3.1。エンコードとデコードのスカラー"
    },
    {
      "indent": 3,
      "text": "Scalars MUST be represented (in binary form) as unsigned integers that are strictly less than r, the order of the generator of the agreed-upon cryptographic group. The binary representation of each scalar MUST have a bit length equal to the bit length of the binary representation of r. This requirement is enforced, if necessary, by prepending the binary representation of the integer with zeros until the required length is achieved.",
      "ja": "スカラrより厳密に小さい符号なし整数、合意された暗号群の発生の順序として（バイナリ形式で）表現されなければなりません。各スカラーのバイナリ表現は、rのバイナリ表現のビット長に等しいビット長を持たなければなりません。必要であれば、この要件は、必要な長さが達成されるまで、ゼロで整数のバイナリ表現を付加することによって、実施されます。"
    },
    {
      "indent": 3,
      "text": "Scalars in the form of unsigned integers are converted into octet strings and back again using the technique described in [RFC6090].",
      "ja": "符号なし整数の形のスカラーは、[RFC6090]に記載された技術を用いて、再びオクテットストリングに変換されます。"
    },
    {
      "indent": 0,
      "text": "8.3.2. Encoding and Decoding of ECP Elements",
      "section_title": true,
      "ja": "8.3.2。 ECP要素の符号化と復号化"
    },
    {
      "indent": 3,
      "text": "Elements in ECP groups are points on the negotiated elliptic curve. Each such element MUST be represented by the concatenation of two components, an x-coordinate and a y-coordinate.",
      "ja": "ECPグループ内の要素は、ネゴシエートされた楕円曲線上の点です。このような各要素は、二つの成分の連結によって表されるx座標とy座標なければなりません。"
    },
    {
      "indent": 3,
      "text": "Each of the two components, the x-coordinate and the y-coordinate, MUST be represented (in binary form) as an unsigned integer that is strictly less than the prime, p, from the group's domain parameter set. The binary representation of each component MUST have a bit length equal to the bit length of the binary representation of p. This length requirement is enforced, if necessary, by prepending the binary representation of the integer with zeros until the required length is achieved.",
      "ja": "二つの成分のそれぞれは、x座標とy座標、グループのドメインパラメータセットから、素数、pより厳密に小さい符号なし整数として（バイナリ形式で）表現されなければなりません。各成分のバイナリ表現は、pのバイナリ表現のビット長に等しいビット長を持たなければなりません。必要であれば、この長さの要件は、必要な長さが達成されるまで、ゼロで整数のバイナリ表現を付加することによって、実施されます。"
    },
    {
      "indent": 3,
      "text": "The unsigned integers that represent the coordinates of the point are converted into octet strings and back again using the technique described in [RFC6090].",
      "ja": "点の座標を表す符号なし整数は、オクテットストリングに変換され、再び、[RFC6090]に記載された技術を使用しています。"
    },
    {
      "indent": 3,
      "text": "Since the field element is represented in a payload by the x-coordinate followed by the y-coordinate, it follows, then, that the length of the element in the payload MUST be twice the bit length of p.",
      "ja": "フィールド要素は、x座標、y座標、続いによってペイロードに表されているので、ペイロード内の要素の長さは、pの二倍のビット長である必要があること、次に、続きます。"
    },
    {
      "indent": 0,
      "text": "8.3.3. Encoding and Decoding of MODP Elements",
      "section_title": true,
      "ja": "8.3.3。 MODP要素の符号化と復号化"
    },
    {
      "indent": 3,
      "text": "Elements in MODP groups MUST be represented (in binary form) as unsigned integers that are strictly less than the prime, p, from the group's domain parameter set. The binary representation of each group element MUST have a bit length equal to the bit length of the binary representation of p. This length requirement is enforced, if necessary, by prepending the binary representation of the integer with zeros until the required length is achieved.",
      "ja": "MODPグループ内の要素は、グループのドメインパラメータセットから、P、プライムよりも厳密に小さい符号なし整数として（バイナリ形式で）表現されなければなりません。各グループの要素のバイナリ表現は、pのバイナリ表現のビット長に等しいビット長を持たなければなりません。必要であれば、この長さの要件は、必要な長さが達成されるまで、ゼロで整数のバイナリ表現を付加することによって、実施されます。"
    },
    {
      "indent": 3,
      "text": "The unsigned integer that represents a MODP element is converted into an octet string and back using the technique described in [RFC6090].",
      "ja": "MODP要素を表す符号なし整数は[RFC6090]に記載された技術を用いて、バックオクテットストリングに変換されます。"
    },
    {
      "indent": 0,
      "text": "8.4. Message Generation and Processing",
      "section_title": true,
      "ja": "8.4。メッセージの生成および処理"
    },
    {
      "indent": 0,
      "text": "8.4.1. Generation of a Commit",
      "section_title": true,
      "ja": "8.4.1。コミットの世代"
    },
    {
      "indent": 3,
      "text": "Before a Commit payload can be generated, the SKE must be fixed using the process described in Section 8.2.",
      "ja": "コミットペイロードを生成することができる前に、SKEは、セクション8.2に記載された方法を用いて固定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "A Commit payload has two components, a scalar and an element. To generate a Commit payload, two random numbers, a \"private\" value and a \"mask\" value, are generated (see Section 5). Their sum modulo the order of the group, r, becomes the scalar component:",
      "ja": "コミットペイロードは、2つの成分、スカラー要素を有しています。コミットペイロードを生成するには、2つの乱数、「プライベート」値と「マスク」の値は、（セクション5を参照）が生成されます。それらの和のグループの順番を法、R、スカラー成分となります："
    },
    {
      "indent": 7,
      "text": "scalar = (private + mask) mod r",
      "ja": "スカラー=（プライベート+マスク）MOD R"
    },
    {
      "indent": 3,
      "text": "If the scalar is not greater than one (1), the private and mask values MUST be thrown away, and new values randomly generated. If the scalar is greater than one (1), the inverse of the scalar operation with the mask and SKE becomes the element component.",
      "ja": "スカラは、（1）よりも大きくない場合、民間およびマスクの値は捨てなければならない、と新しい値はランダムに生成されました。スカラー（1）が1より大きい場合、マスクとSKEとスカラー演算の逆変換要素成分となります。"
    },
    {
      "indent": 7,
      "text": "Element = inverse(scalar-op(mask, SKE))",
      "ja": "=インバース要素（スカラーアップ（マッシュ、SKE））"
    },
    {
      "indent": 3,
      "text": "The Commit payload consists of the scalar followed by the element, and the scalar and element are encoded in the Commit payload according to Section 8.3.",
      "ja": "コミットペイロード要素に続くスカラーで構成され、スカラー要素はセクション8.3に従ってコミットペイロードに符号化されます。"
    },
    {
      "indent": 0,
      "text": "8.4.2. Processing of a Commit",
      "section_title": true,
      "ja": "8.4.2。コミットの処理"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a peer's Commit payload, the scalar and element MUST be validated. The processing of an element depends on the type, either an ECP element or a MODP element.",
      "ja": "ピアのコミットペイロードを受信すると、スカラー要素が検証されなければなりません。要素の処理は、ECP要素またはMODP要素のいずれかで、タイプに依存します。"
    },
    {
      "indent": 0,
      "text": "8.4.2.1. Validation of an ECP Element",
      "section_title": true,
      "ja": "8.4.2.1。 ECP要素の検証"
    },
    {
      "indent": 3,
      "text": "Validating a received ECP element involves: 1) checking whether the two coordinates, x and y, are both greater than zero (0) and less than the prime defining the underlying field; and 2) checking whether the x- and y-coordinates satisfy the equation of the curve (that is, that they produce a valid point on the curve that is not \"0\"). If either of these conditions are not met, the received element is invalid; otherwise, the received element is valid.",
      "ja": "受信ECP要素を検証することを含む：1）は、2点の座標、x及びyは、（0）がゼロより大きく、基本フィールドを定義する素数未満両方であるかどうかをチェックします。 2）X方向及びY座標が曲線（すなわち、それらは「0」でない曲線上有効なポイントを生成すること、である）の式を満たしているかどうかをチェックします。これらの条件のいずれかが満たされていない場合、受信要素が無効です。そうでない場合は、受信要素が有効です。"
    },
    {
      "indent": 0,
      "text": "8.4.2.2. Validation of a MODP Element",
      "section_title": true,
      "ja": "8.4.2.2。 MODP要素の検証"
    },
    {
      "indent": 3,
      "text": "A received MODP element is valid if: 1) it is between one (1) and the prime, p, exclusive; and 2) if modular exponentiation of the element by the group order, r, equals one (1). If either of these conditions are not true, the received element is invalid; otherwise, the received element is valid.",
      "ja": "1）それが1（1）と素数、P、排他的との間にある、次の場合、受信しMODP要素が有効です2）グループの順序によって要素のべき乗剰余演算は、R、1に等しい場合には（1）。これらの条件のいずれかが満たされていない場合、受信要素が無効です。そうでない場合は、受信要素が有効です。"
    },
    {
      "indent": 0,
      "text": "8.4.2.3. Commit Processing Steps",
      "section_title": true,
      "ja": "8.4.2.3。処理ステップをコミット"
    },
    {
      "indent": 3,
      "text": "Commit payload validation is accomplished by the following steps:",
      "ja": "コミットペイロードの検証は、以下の手順によって達成されます。"
    },
    {
      "indent": 3,
      "text": "1. The length of the Commit payload is checked against its anticipated length (the anticipated length of the scalar plus the anticipated length of the element, for the negotiated group). If it is incorrect, the Commit payload is invalidated; otherwise, processing continues.",
      "ja": "1コミットペイロードの長さ（ネゴシエートグループに対するスカラーの予想される長さを加えた素子の予想される長さ）は、その予想される長さに対してチェックされます。それが間違っている場合は、コミットペイロードが無効化されます。そうでない場合、処理は続行されます。"
    },
    {
      "indent": 3,
      "text": "2. The peer's scalar is extracted from the Commit payload according to Section 8.3.1 and checked to ensure it is between one (1) and r, the order of the negotiated group, exclusive. If it is not, the Commit payload is invalidated; otherwise, processing continues.",
      "ja": "2.ピアのスカラーはセクション8.3.1に従ってコミットペイロードから抽出され、それが1（1）およびr、排他的ネゴシエートグループの順序の間であることを確認するためにチェックされます。そうでない場合は、コミットペイロードが無効化されます。そうでない場合、処理は続行されます。"
    },
    {
      "indent": 3,
      "text": "3. The peer's element is extracted from the Commit payload according to Section 8.3.2 and checked in a manner that depends on the type of group negotiated. If the group is ECP, the element is validated according to Section 8.4.2.1. If the group is MODP, the element is validated according to Section 8.4.2.2. If the element is not valid, then the Commit payload is invalidated; otherwise, the Commit payload is validated.",
      "ja": "3.ピアの要素は、セクション8.3.2に従ってコミットペイロードから抽出され、ネゴシエート基の種類に応じた方法でチェックされます。グループがECPの場合、要素は節8.4.2.1に従って検証されます。グループはMODPの場合、要素は節8.4.2.2に従って検証されます。要素が有効でない場合、コミットペイロードが無効化されます。それ以外の場合は、コミットペイロードが検証されます。"
    },
    {
      "indent": 3,
      "text": "4. The Initiator of the IKE exchange has an added requirement to verify that the received element and scalar from the Commit payload differ from the element and scalar sent to the Responder. If they are identical, it signifies a reflection attack, and the Commit payload is invalidated.",
      "ja": "4. IKE交換の開始は、コミットペイロードから受信要素とスカラーレスポンダに送信要素とスカラーとは異なることを確認するために追加の要件を有しています。それらが同一である場合には、反射攻撃を意味し、コミットペイロードは無効化されます。"
    },
    {
      "indent": 3,
      "text": "If the Commit payload is invalidated, the payload MUST be discarded and the IKE exchange aborted.",
      "ja": "コミットペイロードが無効とされている場合は、ペイロードは捨てなければなりませんし、IKE交換が中止されました。"
    },
    {
      "indent": 0,
      "text": "8.4.3. Authentication of the Exchange",
      "section_title": true,
      "ja": "8.4.3。取引所の認証"
    },
    {
      "indent": 3,
      "text": "After a Commit payload has been generated and a peer's Commit payload has been processed, a shared secret used to authenticate the peer is derived. Using SKE, the \"private\" value generated as part of Commit payload generation, and the peer's scalar and element from the peer's Commit payload, named here peer-scalar and Peer-Element, respectively, a preliminary shared secret, skey, is generated as:",
      "ja": "コミットペイロードが生成されていて、ピアのコミットペイロードが処理された後、ピアを認証するために使用される共有秘密が導出されます。 SKE、ピアのコミット、それぞれピア・スカラーおよびピア・エレメント、ここでは名前のペイロード、予備共有秘密、SKEYから「プライベート」ペイロードの生成をコミットの一部として生成された値、およびピアのスカラーと要素を使用して、として生成されます："
    },
    {
      "indent": 8,
      "text": "skey = F(scalar-op(private,\n                   element-op(Peer-Element,\n                              scalar-op(peer-scalar, SKE))))",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For the purposes of subsequent computation, the bit length of skey SHALL be equal to the bit length of the prime, p, used in either a MODP or ECP group. This bit length SHALL be enforced, if necessary, by prepending zeros to the value until the required length is achieved.",
      "ja": "その後の計算の目的のために、SKEYのビット長はMODPまたはECP基のいずれかで使用される素数、Pのビット長に等しくなければなりません。必要であれば、このビット長は、必要な長さが達成されるまでの値にゼロを付加することによって、施行します。"
    },
    {
      "indent": 3,
      "text": "A shared secret, ss, is then computed from skey and the nonces exchanged by the Initiator (Ni) and Responder (Nr) (without the fixed headers) using prf():",
      "ja": "共有秘密、SSは、その後、PRF（）を使用して（固定ヘッダなし）SKEYおよび開始剤ニッケル（Ni）とレスポンダ（NR）によって交換ナンスから計算されます。"
    },
    {
      "indent": 8,
      "text": "ss = prf(Ni | Nr, skey | \"Secure PSK Authentication in IKE\")",
      "ja": "SS = PRF（ニッケル| Nrと、SKEY | \"IKEにおけるセキュアPSK認証\"）"
    },
    {
      "indent": 3,
      "text": "The shared secret, ss, is used in an AUTH authentication payload to prove possession of the shared secret and therefore knowledge of the pre-shared key.",
      "ja": "共有秘密、SSは、事前共有鍵の共有秘密ので、知識の所有を証明するためにAUTH認証ペイロードに使用されています。"
    },
    {
      "indent": 0,
      "text": "8.5. Payload Format",
      "section_title": true,
      "ja": "8.5。ペイロードフォーマット"
    },
    {
      "indent": 0,
      "text": "8.5.1. Commit Payload",
      "section_title": true,
      "ja": "8.5.1。ペイロードをコミット"
    },
    {
      "indent": 3,
      "text": "[RFC6467] defines a Generic Secure Password Method (GSPM) payload that is used to convey information that is specific to a particular secure password method. This memo uses the GSPM payload as a Commit payload to contain the scalar and element used in the Secure PSK Authentication exchange:",
      "ja": "[RFC6467]は、特定の安全なパスワード方式に固有の情報を伝えるために使用される一般的なセキュリティで保護されたパスワード方式（GSPM）ペイロードを定義します。このメモは、Secure PSK認証交換に使用されるスカラ要素を含むことがコミットペイロードとしてGSPMペイロードを使用します。"
    },
    {
      "indent": 3,
      "text": "The Commit payload is defined as follows:",
      "ja": "次のようにコミットペイロードは定義されています。"
    },
    {
      "indent": 7,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n! Next Payload  !C!  RESERVED   !         Payload Length        !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                            scalar                             ~\n|                                                               |\n~                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               ~\n|                                                               |\n~                           Element                             ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The scalar and element SHALL be encoded in the Commit payload according to Section 8.3.",
      "ja": "スカラー要素はセクション8.3に従ってコミットペイロードに符号化されます。"
    },
    {
      "indent": 0,
      "text": "8.6. IKEv2 Messaging",
      "section_title": true,
      "ja": "8.6。 IKEv2のメッセージ"
    },
    {
      "indent": 3,
      "text": "Secure PSK Authentication modifies the IKE_AUTH exchange by adding one additional round trip to exchange Commit payloads to perform the Secure PSK Authentication exchange and by changing the calculation of the AUTH payload data to bind the IKEv2 exchange to the outcome of the Secure PSK Authentication exchange (see Figure 3).",
      "ja": "安全なPSK認証は安全なPSK認証交換を実行するためのペイロードをコミット交換するために、1件の追加のラウンドトリップを追加することによって、および安全なPSK認証交換の結果へのIKEv2交換を結合するAUTHペイロードデータの計算を変更することにより、IKE_AUTH交換を修正し（参照図3）。"
    },
    {
      "indent": 3,
      "text": " Initiator                               Responder\n-----------                             -----------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "IKE_SA_INIT:",
      "ja": "IKE_SA_INIT："
    },
    {
      "indent": 4,
      "text": "HDR, SAi1, KEi, Ni, N(SPM-SPSK) -->",
      "ja": "HDR、SAI1、圭、ニッケル、N（SPM SPSK） - >"
    },
    {
      "indent": 34,
      "text": "<--    HDR, SAr1, KEr, Nr,\n            N(SPM-SPSK)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "IKE_AUTH:",
      "ja": "IKE_AUTH："
    },
    {
      "indent": 4,
      "text": "HDR, SK {IDi, COMi, [IDr,] SAi2, TSi, TSr} --> <-- HDR, SK {IDr, COMr} HDR, SK {AUTHi} --> <-- HDR, SK {AUTHr, SAr2, TSi, TSr}",
      "ja": "HDR、SK {IDI、COMI、[IDR、】SAI2、をTSi、TSrを}  - > < -  HDR、SK {IDR、COMR} HDR、SK {AUTHi}  - > < -  HDR、SK {AUTHR、 SAR2、をTSi、TSrを}"
    },
    {
      "indent": 3,
      "text": "where N(SPM-SPSK) indicates the Secure Password Methods Notify payloads used to negotiate the use of Secure PSK Authentication (see Section 8.1), COMi and AUTHi are the Commit payload and AUTH payload, respectively, sent by the Initiator, and COMr and AUTHr are the Commit payload and AUTH payload, respectively, sent by the Responder.",
      "ja": "N（SPM-SPSK）は、セキュリティで保護されたパスワードの方法は、セキュアPSK認証（8.1節を参照）、COMIとAUTHiの使用を交渉するために使用されるペイロードを通知示す場合、イニシエータによって送信され、それぞれ、ペイロードとAUTHペイロードをコミットしている、とCOMR及びAUTHRは、それぞれ、レスポンダによって送信されたコミットペイロードとAUTHペイロードです。"
    },
    {
      "indent": 23,
      "text": "Figure 3: Secure PSK in IKEv2",
      "ja": "図3のIKEv2でセキュアPSK"
    },
    {
      "indent": 3,
      "text": "When doing Secure PSK Authentication, the AUTH payloads SHALL be computed as",
      "ja": "セキュアPSK認証を行う場合、AUTHペイロードは次のように計算されるものとする（SHALL）"
    },
    {
      "indent": 7,
      "text": "AUTHi = prf(ss, <InitiatorSignedOctets> | COMi | COMr)",
      "ja": "ほとんど= prapha（彼、<initiyatarasiganedostetasa> |する|ください）"
    },
    {
      "indent": 7,
      "text": "AUTHr = prf(ss, <ResponderSignedOctets> | COMr | COMi)",
      "ja": "著者= prapha（彼、<respanderasiganedostetasa> |税金|何）"
    },
    {
      "indent": 3,
      "text": "where \"ss\" is the shared secret derived in Section 8.4.3, COMi and COMr are the entire Commit payloads (including the fixed headers) sent by the Initiator and Responder, respectively, and <InitiatorSignedOctets> and <ResponderSignedOctets> are defined in",
      "ja": "「SS」は、セクション8.4.3に由来する共有される秘密であり、COMI及びCOMRイニシエータとレスポンダによって送信された（固定されたヘッダを含む）全体コミットペイロードであり、それぞれ、及び<InitiatorSignedOctets>と<ResponderSignedOctets>で定義されています"
    },
    {
      "indent": 3,
      "text": "[RFC5996]. The Authentication Method indicated in both AUTH payloads SHALL be \"Generic Secure Password Authentication Method\", value 12, from [IKEV2-IANA].",
      "ja": "[RFC5996]。認証方式は、[のIKEv2-IANA]から、「一般的なセキュリティで保護されたパスワード認証方式」、値12でなければならない両方のAUTHペイロードに示します。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has assigned the value 3 for \"Secure PSK Authentication\" from the Secure Password Authentication Method registry in [IKEV2-IANA].",
      "ja": "IANAは、[のIKEv2-IANA]でセキュリティで保護されたパスワード認証方式レジストリから「安全なPSK認証」の値3が割り当てられています。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Both the Initiator and Responder obtain a shared secret, \"ss\" (see Section 8.4.3), based on a secret group element and their own private values contributed to the exchange. If they do not share the same pre-shared key, they will be unable to derive the same secret group element, and if they do not share the same secret group element, they will be unable to derive the same shared secret.",
      "ja": "イニシエータとレスポンダの両方が共有秘密を得る、秘密のグループ要素に基づいて、「SS」（8.4.3項を参照）、および自分のプライベートの値は交流に貢献しました。彼らは同じ事前共有キーを共有していない場合、それらは同じ秘密のグループ要素を導出することはできません、そして、彼らは同じ秘密グループ要素を共有していない場合、それらは同じ共有秘密を導出することができません。"
    },
    {
      "indent": 3,
      "text": "Resistance to dictionary attack means that the adversary must launch an active attack to make a single guess at the pre-shared key. If the size of the pool from which the key was extracted was d and each key in the pool has an equal probability of being chosen, then the probability of success after a single guess is 1/d. After x guesses, and removal of failed guesses from the pool of possible keys, the probability becomes 1/(d-x). As x grows, so does the probability of success. Therefore, it is possible for an adversary to determine the pre-shared key through repeated brute-force, active, guessing attacks. This authentication method does not presume to be secure against this, and implementations SHOULD ensure the value of d is sufficiently large to prevent this attack. Implementations SHOULD also take countermeasures, for instance, refusing authentication attempts for a certain amount of time after the number of failed authentication attempts reaches a certain threshold. No such threshold or amount of time is recommended in this memo.",
      "ja": "辞書攻撃に対する耐性は、敵対者が事前共有キーで、単一の推測を行うためにアクティブな攻撃を開始しなければならないことを意味します。キーが抽出されたプールの大きさをdとし、プール内の各キーが選択される等しい確率を有する場合、単一の推測後の成功の確率は1 / Dです。 Xの推測、および可能なキーのプールから失敗した推測を除去した後、確率は1 /（D-X）となります。 xが大きくなるにつれて、その成功の確率はありません。敵対者が繰り返しブルートフォース、アクティブ、推測攻撃を介して事前共有キーを決定するため、それが可能です。この認証方法は、このに対して安全であると想定されていない、との実装は、dの値は、この攻撃を防ぐのに十分な大きさであることを確認すべきです。実装はまた、失敗した認証試行回数が一定の閾値に達した後、一定時間の認証の試行を拒否し、例えば、対策を取る必要があります。時間のそのようなしきい値または量は、このメモで推奨されていません。"
    },
    {
      "indent": 3,
      "text": "An active attacker can impersonate the Responder of the exchange and send a forged Commit payload after receiving the Initiator's Commit payload. The attacker then waits until it receives the authentication payload from the Responder. Now the attacker can attempt to run through all possible values of the pre-shared key, computing SKE (see Section 8.2), computing \"ss\" (see Section 8.4.3), and attempting to recreate the Confirm payload from the Responder.",
      "ja": "活発な攻撃者は、為替のレスポンダを偽装し、イニシエータのコミットペイロードを受信した後、鍛造コミットペイロードを送信することができます。それはレスポンダから認証ペイロードを受信するまで、攻撃者は、その後、待機します。今、攻撃者は、（8.4.3項を参照）、「SS」を計算し、（8.2節を参照）SKEを計算し、事前共有キーのすべての可能な値を介して実行しようとすると、レスポンダから確認ペイロードを再作成しようとすることができます。"
    },
    {
      "indent": 3,
      "text": "But, by sending a forged Commit payload the attacker commits to a single guess of the pre-shared key. That value was used by the Responder in his computation of \"ss\", which was used in the authentication payload. Any guess of the pre-shared key that differs from the one used in the forged Commit payload would result in each side using a different secret element in the computation of \"ss\" and therefore the authentication payload could not be verified as correct, even if a subsequent guess, while running through all possible values, was correct. The attacker gets one guess, and one guess only, per active attack.",
      "ja": "しかし、偽造コミットペイロードを送信することにより、攻撃者は、事前共有キーの単一の推測にコミットします。この値は、認証ペイロードに使用された「SS」、の彼の計算にレスポンダで使用されました。偽造に使用されるものとは異なる事前共有鍵のいずれかの推測があっても、ペイロードは「SS」の計算に異なる秘密の要素を使用してそれぞれの側に生じる、したがって、認証ペイロードが正しいと確認できませんでしたコミットその後の推測では、すべての可能な値を走るながら、正しかったです。攻撃者は、アクティブな攻撃ごとに、1つの推測、そして唯一の推測を取得します。"
    },
    {
      "indent": 3,
      "text": "An attacker, acting as either the Initiator or Responder, can take the element from the Commit payload received from the other party, reconstruct the random \"mask\" value used in its construction, and then recover the other party's \"private\" value from the scalar in the Commit payload. But this requires the attacker to solve the discrete logarithm problem, which we assumed was intractable (Section 7).",
      "ja": "攻撃者は、イニシエータまたはレスポンダのどちらかとして作用する、他の当事者から受信したコミットペイロードから要素を取るその構築に使用されるランダムな「マスク」の値を再構築して、スカラーから相手の「プライベート」の値を回復することができますコミットペイロードインチしかし、これは我々が（第7節）難治た仮定の離散対数問題を、解決するために、攻撃者が必要です。"
    },
    {
      "indent": 3,
      "text": "Instead of attempting to guess at pre-shared keys, an attacker can attempt to determine SKE and then launch an attack, but SKE is determined by the output of the pseudo-random function, prf, which is assumed to be indistinguishable from a random source (Section 7). Therefore, each element of the finite cyclic group will have an equal probability of being the SKE. The probability of guessing SKE will be 1/r, where r is the order of the group. This is the same probability of guessing the solution to the discrete logarithm, which is assumed to be intractable (Section 7). The attacker would have a better chance of success at guessing the input to prf, i.e., the pre-shared key, since the order of the group will be many orders of magnitude greater than the size of the pool of pre-shared keys.",
      "ja": "代わりに事前共有キーを推測しようとする攻撃者は、SKEを決定した後、攻撃を開始しようと試みることができるが、SKEは、ランダムソースと区別できないことが想定される擬似ランダム関数の出力、PRF、によって決定されます（第7章）。したがって、有限巡回群の各要素は、SKEという等しい確率を有するであろう。推測SKEの確率は、rは、グループの順序である1 / R、あろう。これは難治性であると仮定される離散対数、（セクション7）の解を推測するのと同じ確率です。グループの順序は、事前共有キーのプールのサイズよりも大きい数桁になりますので、攻撃者は、すなわち、事前共有キーをPRFする入力を推測するに、成功のよりよいチャンスを持っているでしょう。"
    },
    {
      "indent": 3,
      "text": "The implications of resistance to dictionary attack are significant. An implementation can provision a pre-shared key in a practical and realistic manner -- i.e., it MAY be a character string, and it MAY be relatively short -- and still maintain security. The nature of the pre-shared key determines the size of the pool, D, and countermeasures can prevent an adversary from determining the secret in the only possible way: repeated, active, guessing attacks. For example, a simple four-character string using lowercase English characters, and assuming random selection of those characters, will result in D of over four hundred thousand. An adversary would need to mount over one hundred thousand active, guessing attacks (which will easily be detected) before gaining any significant advantage in determining the pre-shared key.",
      "ja": "辞書攻撃への耐性の影響が重要です。実装は規定、実用的かつ現実的な方法で事前共有キーすることができます - すなわち、それは文字列であってもよく、それが比較的短くてもよい - とまだセキュリティを維持します。攻撃を推測、繰り返し、活性：事前共有鍵の性質は、プール、Dの大きさを決定し、対策が唯一可能な方法で秘密を決定するから敵を防止することができます。たとえば、小文字の英文字を使用して、それらの文字のランダムな選択を想定し、簡単な4文字の文字列は、千百4以上のDになります。敵は事前共有キーを決定する際に任意の重要な利点を得る前に、（容易に検出されます）千100以上のアクティブな、推測攻撃をマウントする必要があります。"
    },
    {
      "indent": 3,
      "text": "If an attacker knows the number of hunting-and-pecking loops that were required to determine SKE, it is possible to eliminate passwords from the pool of potential passwords and increase the probability of successfully guessing the real password. MODP groups will require more than \"n\" loops with a probability based on the value of the prime -- if m is the largest unsigned number that can be expressed in len(p) bits, then the probability is ((m-p)/p)^n -- which will typically be very small for the groups defined in [IKEV2-IANA]. ECP",
      "ja": "攻撃者がSKEを決定するために必要とされた狩猟 - と - つつきループの数を知っている場合、潜在的なパスワードのプールからパスワードを排除し、成功した実際のパスワードを推測する確率を高めることができます。 MODP基は「N」が素数の値に基づく確率でループよりも多くを必要とする -  mは、LEN（P）ビットで表現できる最大の符号なし数である場合、確率は（（MP）である/ P ）^ N  - 典型的には、[のIKEv2-IANA]で定義されたグループのために非常に小さいされます。 ECP"
    },
    {
      "indent": 3,
      "text": "groups will require more than one \"n\" loop with a probability of roughly (1-(r/2p))^n. Therefore, a security parameter, k, is defined that will ensure that at least k loops will always be executed regardless of whether SKE is found in less than k loops. There is still a probability that a password would require more than k loops, and a side-channel attacker could use that information to his advantage, so selection of the value of k should be based on a trade-off between the additional workload to always perform k iterations and the potential of providing information to a side-channel attacker. It is important to note that the possibility of a successful side-channel attack is greater against ECP groups than MODP groups, and it might be appropriate to have separate values of k for the two.",
      "ja": "グループは、おおよそ（1-（R / 2P））^ Nの確率で複数の「n」個のループを必要とするであろう。したがって、セキュリティパラメータ、Kは、少なくともk個のループは関係なく、常にSKEをkループ未満に見出されるかどうかに実行されることを確実にするように定義されています。そこパスワードがk個のループよりも多くを必要とする確率はまだで、サイドチャネル攻撃者は、彼の利点にその情報を使用することができ、そのkの値の選択は、トレードオフの追加のワークロードの間で常にに基づいている必要がありますk個の反復とサイドチャネル攻撃者に情報を提供する可能性を行います。成功したサイドチャネル攻撃の可能性がMODPグループよりもECPグループに対して大きく、2のためのkの別々の値を持つことが適切であるかもしれないことに注意することが重要です。"
    },
    {
      "indent": 3,
      "text": "For a more detailed discussion of the security of the key exchange underlying this authentication method, see [SAE] and [RFC5931].",
      "ja": "この認証方法の基礎となる鍵交換のセキュリティのより詳細な議論については、[SAE]と[RFC5931]を参照してください。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgements",
      "section_title": true,
      "ja": "11.謝辞"
    },
    {
      "indent": 3,
      "text": "The author would like to thank Scott Fluhrer and Hideyuki Suzuki for their insight in discovering flaws in earlier versions of the key exchange that underlies this authentication method and for their helpful suggestions in improving it. Thanks to Lily Chen for useful advice on the hunting-and-pecking technique to \"hash into\" an element in a group and to Jin-Meng Ho for a discussion on countering a small sub-group attack. Rich Davis suggested several checks on received messages that greatly increase the security of the underlying key exchange. Hugo Krawczyk suggested using the prf as an extractor.",
      "ja": "著者は、この認証方法の基礎となる鍵交換の以前のバージョンの欠陥を発見して、それを改善するのに役立つ提案彼らのために彼らの洞察力のためのスコットFluhrerと英之鈴木に感謝したいと思います。小さなサブグループの攻撃に対抗上の議論のため、グループ内やジン孟ホーへの要素「にハッシュ」への探求およびつつき技術に関する有用な助言のためのリリー・チェンに感謝します。リッチ・デイビスが大幅に基本的なキー交換のセキュリティを向上させる受信したメッセージのいくつかのチェックを示唆しました。ヒューゴKrawczykは抽出としてPRFを使用して提案しました。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12.参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[IKEV2-IANA] IANA, \"IKEv2 Parameters\", <http://www.iana.org/assignments/ikev2-parameters>.",
      "ja": "[IKEv2の-IANA] IANA、 \"IKEv2のパラメータ\"、<http://www.iana.org/assignments/ikev2-parameters>。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3454] Hoffman, P. and M. Blanchet, \"Preparation of Internationalized Strings (\"stringprep\")\", RFC 3454, December 2002.",
      "ja": "[RFC3454]ホフマン、P.及びM.ブランシェ、 \"国際化された文字列の調製（\" 文字列準備 \"）\"、RFC 3454、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4013] Zeilenga, K., \"SASLprep: Stringprep Profile for User Names and Passwords\", RFC 4013, February 2005.",
      "ja": "[RFC4013] Zeilenga、K.、 \"SASLprep：ユーザ名とパスワードのためのstringprepプロフィール\"、RFC 4013、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC5996] Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", RFC 5996, September 2010.",
      "ja": "[RFC5996]カウフマン、C.、ホフマン、P.、ニール、Y.、およびP. Eronen、 \"インターネット鍵交換プロトコルバージョン2（IKEv2の）\"、RFC 5996、2010年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic Curve Cryptography Algorithms\", RFC 6090, February 2011.",
      "ja": "[RFC6090]マグリュー、D.、Igoe、K.、およびM.ソルター、 \"基礎楕円曲線暗号アルゴリズム\"、RFC 6090、2011年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6467] Kivinen, T., \"Secure Password Framework for Internet Key Exchange Version 2 (IKEv2)\", RFC 6467, December 2011.",
      "ja": "[RFC6467] Kivinen、T.、RFC 6467 \"インターネット鍵交換バージョン2（IKEv2の）のためのセキュリティで保護されたパスワードのフレームワーク\"、2011年12月。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[BM92] Bellovin, S. and M. Merritt, \"Encrypted Key Exchange: Password-Based Protocols Secure Against Dictionary Attacks\", Proceedings of the IEEE Symposium on Security and Privacy, Oakland, 1992.",
      "ja": "[BM92] Bellovin氏、S.とM.メリット、「暗号化鍵交換：辞書攻撃に対するセキュリティで保護されたパスワードベースのプロトコル」、セキュリティとプライバシー、オークランド、1992年IEEEシンポジウム。"
    },
    {
      "indent": 3,
      "text": "[BMP00] Boyko, V., MacKenzie, P., and S. Patel, \"Provably Secure Password-Authenticated Key Exchange Using Diffie-Hellman\", Proceedings of Eurocrypt 2000, LNCS 1807 Springer-Verlag, 2000.",
      "ja": "[BMP00] Boyko、V.、マッケンジー、P.、およびS.パテル、 \"証明可能セキュアなパスワード認証鍵交換のDiffie-Hellmanのを使用する\"、EUROCRYPT 2000、LNCS 1807シュプリンガー・フェアラーク、2000年の議事。"
    },
    {
      "indent": 3,
      "text": "[BPR00] Bellare, M., Pointcheval, D., and P. Rogaway, \"Authenticated Key Exchange Secure Against Dictionary Attacks\", Advances in Cryptology -- Eurocrypt '00, Lecture Notes in Computer Science Springer-Verlag, 2000.",
      "ja": "コンピュータサイエンスシュプリンガー・フェアラーク、2000年にEUROCRYPT '00、講義ノート -  [BPR00]ベラー、M.、Pointcheval、D.、およびP. Rogaway、 \"認証鍵交換は、辞書攻撃から守るには\"、暗号学の進歩します。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[RFC4301]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5869] Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\", RFC 5869, May 2010.",
      "ja": "[RFC5869] Krawczyk、H.、およびP. Eronen、 \"HMACベースの抽出物と、拡大鍵導出関数（HKDF）\"、RFC 5869、2010年5月を。"
    },
    {
      "indent": 3,
      "text": "[RFC5931] Harkins, D. and G. Zorn, \"Extensible Authentication Protocol (EAP) Authentication Using Only a Password\", RFC 5931, August 2010.",
      "ja": "[RFC5931]ハーキンとD.とG.ツォルン、 \"唯一のパスワードを使用して拡張認証プロトコル（EAP）認証\"、RFC 5931、2010年8月。"
    },
    {
      "indent": 3,
      "text": "[SAE] Harkins, D., \"Simultaneous Authentication of Equals: A Secure, Password-Based Key Exchange for Mesh Networks\", Proceedings of the 2008 Second International Conference on Sensor Technologies and Applications Volume 00, 2008.",
      "ja": "[SAE]ハーキンズ、D.、「対等の同時認証：メッシュネットワークのためのセキュリティで保護され、パスワードベース鍵交換」、センサ技術2008第二に、国際会議の議事録およびアプリケーションボリューム00、2008。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Dan Harkins Aruba Networks 1322 Crossman Avenue Sunnyvale, CA 94089-1113 United States of America",
      "ja": "ダンハーキンズアルバネットワークス1322クロスマンアベニューサニーベール、CAアメリカの94089から1113米国"
    },
    {
      "indent": 3,
      "text": "EMail: dharkins@arubanetworks.com",
      "ja": "メールアドレス：dharkins@arubanetworks.com"
    }
  ]
}