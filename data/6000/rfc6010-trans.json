{
  "title": {
    "text": "RFC 6010 - Cryptographic Message Syntax (CMS) Content Constraints Extension",
    "ja": "RFC 6010 - 暗号メッセージ構文（CMS）コンテンツ制約拡張"
  },
  "number": 6010,
  "created_at": "2019-10-26 21:38:00.704528+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        R. Housley\nRequest for Comments: 6010                           Vigil Security, LLC\nCategory: Standards Track                                     S. Ashmore\nISSN: 2070-1721                                 National Security Agency\n                                                              C. Wallace\n                                                      Cygnacom Solutions\n                                                          September 2010",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Cryptographic Message Syntax (CMS) Content Constraints Extension",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies the syntax and semantics for the Cryptographic Message Syntax (CMS) content constraints extension. This extension is used to determine whether a public key is appropriate to use in the processing of a protected content. In particular, the CMS content constraints extension is one part of the authorization decision; it is used when validating a digital signature on a CMS SignedData content or validating a message authentication code (MAC) on a CMS AuthenticatedData content or CMS AuthEnvelopedData content. The signed or authenticated content type is identified by an ASN.1 object identifier, and this extension indicates the content types that the public key is authorized to validate. If the authorization check is successful, the CMS content constraints extension also provides default values for absent attributes.",
      "ja": "この文書は、暗号メッセージ構文（CMS）コンテンツ制約拡張のための構文とセマンティクスを指定します。この拡張は、公開鍵が保護されたコンテンツの処理に使用することが適切であるかどうかを決定するために使用されます。具体的には、CMSコンテンツ制約拡張は、認可判断の一部です。 CMSのSignedDataコンテンツのデジタル署名を検証するか、CMS AuthenticatedDataコンテンツまたはCMS AuthEnvelopedDataコンテンツ上のメッセージ認証コード（MAC）を検証するときに使用されます。署名または認証されたコンテンツタイプはASN.1オブジェクト識別子によって識別され、この拡張は、公開鍵を検証するために許可されているコンテンツの種類を示しています。認証チェックが成功した場合は、CMSコンテンツ制約拡張も欠席属性のデフォルト値を提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6010.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6010で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2010 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n  1.1.  CMS Data Structures  . . . . . . . . . . . . . . . . . . .  5\n  1.2.  CMS Content Constraints Model  . . . . . . . . . . . . . . 10\n  1.3.  Attribute Processing . . . . . . . . . . . . . . . . . . . 11\n  1.4.  Abstract Syntax Notation . . . . . . . . . . . . . . . . . 13\n  1.5.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . 13\n2.  CMS Content Constraints Extension  . . . . . . . . . . . . . . 13\n3.  Certification Path Processing  . . . . . . . . . . . . . . . . 16\n  3.1.  Inputs . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n  3.2.  Initialization . . . . . . . . . . . . . . . . . . . . . . 18\n  3.3.  Basic Certificate Processing . . . . . . . . . . . . . . . 19\n  3.4.  Preparation for Certificate i+1  . . . . . . . . . . . . . 20\n  3.5.  Wrap-Up Procedure  . . . . . . . . . . . . . . . . . . . . 20\n  3.6.  Outputs  . . . . . . . . . . . . . . . . . . . . . . . . . 21\n4.  CMS Content Constraints Processing . . . . . . . . . . . . . . 21\n  4.1.  CMS Processing and CCC Information Collection  . . . . . . 22\n    4.1.1.  Collection of Signer or Originator Information . . . . 24\n    4.1.2.  Collection of Attributes . . . . . . . . . . . . . . . 25\n    4.1.3.  Leaf Node Classification . . . . . . . . . . . . . . . 25\n  4.2.  Content Type and Constraint Checking . . . . . . . . . . . 26\n    4.2.1.  Inputs . . . . . . . . . . . . . . . . . . . . . . . . 27\n    4.2.2.  Processing . . . . . . . . . . . . . . . . . . . . . . 27\n    4.2.3.  Outputs  . . . . . . . . . . . . . . . . . . . . . . . 27\n5.  Subordination Processing in TAMP . . . . . . . . . . . . . . . 28\n6.  Security Considerations  . . . . . . . . . . . . . . . . . . . 29\n7.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 32\n8.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n  8.1.  Normative References . . . . . . . . . . . . . . . . . . . 33\n  8.2.  Informative References . . . . . . . . . . . . . . . . . . 34\nAppendix A.  ASN.1 Modules . . . . . . . . . . . . . . . . . . . . 35\n  A.1.  ASN.1 Module Using 1993 Syntax . . . . . . . . . . . . . . 35\n  A.2.  ASN.1 Module Using 1988 Syntax . . . . . . . . . . . . . . 37",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The Cryptographic Message Syntax (CMS) SignedData [RFC5652] construct is used to sign many things, including cryptographic module firmware packages [RFC4108] and certificate management messages [RFC5272]. Similarly, the CMS AuthenticatedData and CMS AuthEnvelopedData constructs provide authentication, which can be affiliated with an originator's static public key. CMS Content Constraints (CCC) information is conveyed via an extension in a certificate or trust anchor object that contains the originator's or signer's public key.",
      "ja": "暗号メッセージ構文（CMS）のSignedData [RFC5652]コンストラクトは、[RFC4108]と証明書管理メッセージ[RFC5272]暗号モジュールのファームウェアパッケージを含む多くのことを、署名するために使用されます。同様に、CMS AuthenticatedDataとCMS AuthEnvelopedData構築物は、発信者の静的な公開鍵と提携することができ、認証を提供します。 CMSコンテンツ制約（CCC）の情報は、発信者または署名者の公開鍵を含む証明書またはトラストアンカーオブジェクト内の拡張を介して伝達されます。"
    },
    {
      "indent": 3,
      "text": "This document assumes a particular authorization model, where each originator is associated with one or more authorized content types. A CMS SignedData, AuthenticatedData, or AuthEnvelopedData will be considered valid only if the signature or message authentication code (MAC) verification process is successful and the originator is authorized for the encapsulated content type. For example, one originator might be acceptable for verifying signatures on firmware packages, but that same originator may be unacceptable for verifying signatures on certificate management messages.",
      "ja": "この文書では、各発信者は、1つ以上の許可されたコンテンツタイプに関連付けられている特定の認可モデルを前提としています。 CMSのSignedData、AuthenticatedData、またはAuthEnvelopedDataは、署名又はメッセージ認証コード（MAC）検証処理が成功し、発信者がカプセル化されたコンテンツタイプでは許可されている場合にのみ有効と見なされるであろう。例えば、1人の発信者は、ファームウェアパッケージの署名を検証するために許容できるかもしれませんが、同じ発信者は、証明書管理メッセージに署名を検証するために許容できないことがあります。"
    },
    {
      "indent": 3,
      "text": "An originator's constraints are derived from the certification path used to validate the originator's public key. Constraints are associated with trust anchors [RFC5914], and constraints are optionally included in public key certificates [RFC5280]. Using the CMS Content Constraints (CCC) extension, a trust anchor lists the content types for which it may be used. A trust anchor may also include further constraints associated with each of the content types. Certificates in a certification path may contain a CCC extension that further constrains the authorization for subordinate certificates in the certification path.",
      "ja": "発信者の制約は、発信者の公開鍵を検証するために使用する証明書パスに由来しています。制約は信頼アンカー[RFC5914]に関連している、と制約は、必要に応じて、公開鍵証明書[RFC5280]に含まれています。 CMSコンテンツ制約（CCC）拡張子を使用して、トラストアンカーは、それが使用されるため、コンテンツの種類を示しています。トラストアンカーは、コンテンツタイプのそれぞれに関連するさらなる制約を含むことができます。証明書パス内の証明書は、さらに証明書パスに下位証明書の承認を制約CCC拡張が含まれていてもよいです。"
    },
    {
      "indent": 3,
      "text": "Delegation of authorizations is accomplished using the CCC certificate extension. An entity may delegate none, some, or all of its authorizations to another entity by issuing it a certificate with an appropriate CCC extension. Absence of a CCC certificate extension in a certificate means that the subject is not authorized for any content type. If the entity is an end entity, it may perform CCC delegation, i.e., through the use of proxy certificates. However, usage of proxy certificates is not described in this specification.",
      "ja": "権限の委任は、CCCの証明書拡張を使用して達成されます。エンティティは、それを適切なCCC拡張子を持つ証明書を発行することによってなし、一部、またはその権限のすべての他のエンティティへの委任することができます。証明書CCC証明書拡張の欠如は被験体が任意のコンテンツ・タイプのために認可されていないことを意味します。エンティティがエンドエンティティである場合、それはすなわち、プロキシ証明書の使用を通じて、CCCの委任を実行することができます。しかし、プロキシ証明書の使用は、本明細書で説明されていません。"
    },
    {
      "indent": 3,
      "text": "While processing the certification path, relying parties MUST ensure that authorizations of a subject of a certificate are constrained by the authorizations of the issuer of that certificate. In other words, when a content signature or MAC is validated, checks MUST be performed to ensure that the encapsulated content type is within the permitted set for the trust anchor (TA) and each certificate in the path and that the constraints associated with the specific content type, if any, are satisfied by the TA and each certificate in the path.",
      "ja": "認証パスを処理している間に、依拠当事者は、証明書のサブジェクトの権限は、その証明書の発行者の権限によって制約されていることを確認しなければなりません。コンテンツ署名またはMACが検証されたとき換言すれば、チェックがカプセル化されたコンテンツタイプは、トラストアンカー（TA）とパス内の各証明書のために許可されたセット内とすることであることを確認するために行わなければならない特定に関連付けられた制約コンテンツタイプは、もしあれば、TAおよびパス内の各証明書によって満たされます。"
    },
    {
      "indent": 3,
      "text": "Additionally, this document provides subordination rules for processing CCC extensions within the Trust Anchor Management Protocol (TAMP) and relies on vocabulary from that document [RFC5934].",
      "ja": "また、この文書では、トラストアンカー管理プロトコル（TAMP）内のCCCの拡張機能を処理するために劣後ルールを提供し、そのドキュメント[RFC5934]からの語彙に依存しています。"
    },
    {
      "indent": 0,
      "text": "1.1. CMS Data Structures",
      "section_title": true,
      "ja": "1.1。 CMSデータ構造"
    },
    {
      "indent": 3,
      "text": "CMS encapsulation can be used to compose structures of arbitrary breadth and depth. This is achieved using a variety of content types that achieve different compositional goals. A content type is an arbitrary structure that is identified using an object identifier. This document defines two categories of content types: intermediate content types and leaf content types. Intermediate content types are those designed specifically to encapsulate one or more additional content types with the addition of some service (such as a signature). Leaf content types are those designed to carry specific information. (Leaf content types may contain other content types.) CCC is not used to constrain MIME encapsulated data, i.e., CCC processing stops when a MIME encapsulation layer is encountered. SignedData [RFC5652] and ContentCollection [RFC4073] are examples of intermediate content types. FirmwarePkgData [RFC4108] and TSTInfo [RFC3161] are examples of leaf content types. Protocol designers may provide an indication regarding the classification of content types within the protocol. Four documents define the primary intermediate content types:",
      "ja": "CMSカプセル化は、任意の幅と深さの構造を構成するために使用することができます。これは、異なる組成の目標を達成するコンテンツの種類の様々な方法を用いて達成されます。コンテンツタイプは、オブジェクト識別子を用いて識別される任意の構造です。中間コンテンツタイプと葉のコンテンツタイプ：この文書では、コンテンツタイプの二つのカテゴリを定義します。中間コンテンツタイプは、（署名など）いくつかのサービスを添加して1つのまたは複数の追加のコンテンツタイプをカプセル化するために特別に設計されたものです。葉のコンテンツタイプは、特定の情報を運ぶために設計されたものです。 （リーフ・コンテンツ・タイプは、他のコンテンツタイプを含んでいてもよい。）CCCは、MIMEカプセル化層に遭遇した場合すなわち、CCC処理が停止し、データをカプセル化されたMIMEを制約するために使用されていません。 SignedData [RFC5652]とContentCollection [RFC4073]は、中間コンテンツタイプの例です。 FirmwarePkgData [RFC4108]とTSTInfo [RFC3161]はリーフ・コンテンツ・タイプの例です。プロトコル設計者は、プロトコル内のコンテンツタイプの分類に関する表示を提供することができます。四つの文書は一次中間コンテンツタイプを定義します。"
    },
    {
      "indent": 3,
      "text": "RFC 5652 [RFC5652]: Cryptographic Message Syntax (CMS)",
      "ja": "RFC 5652 [RFC5652]：暗号メッセージ構文（CMS）"
    },
    {
      "indent": 6,
      "text": "- SignedData",
      "ja": " - のSignedData"
    },
    {
      "indent": 6,
      "text": "- EnvelopedData",
      "ja": " -  EnvelopedDataの"
    },
    {
      "indent": 6,
      "text": "- EncryptedData",
      "ja": " - はEncryptedData"
    },
    {
      "indent": 6,
      "text": "- DigestedData",
      "ja": " -  DigestedData"
    },
    {
      "indent": 6,
      "text": "- AuthenticatedData",
      "ja": " - 認証されたデータ"
    },
    {
      "indent": 3,
      "text": "RFC 5083 [RFC5083]: The Cryptographic Message Syntax (CMS) AuthEnvelopedData Content Type",
      "ja": "RFC 5083 [RFC5083]：暗号メッセージ構文（CMS）AuthEnvelopedDataコンテンツタイプ"
    },
    {
      "indent": 6,
      "text": "- AuthEnvelopedData",
      "ja": " -  AuthEnvelopedData"
    },
    {
      "indent": 3,
      "text": "RFC 4073 [RFC4073]: Protecting Multiple Contents with the Cryptographic Message Syntax (CMS)",
      "ja": "RFC 4073 [RFC4073]：暗号メッセージ構文（CMS）で複数のコンテンツを保護します"
    },
    {
      "indent": 6,
      "text": "- ContentCollection",
      "ja": " -  ContentCollection"
    },
    {
      "indent": 6,
      "text": "- ContentWithAttributes",
      "ja": " -  ContentWithAttributes"
    },
    {
      "indent": 3,
      "text": "RFC 3274 [RFC3274]: Compressed Data Content Type for Cryptographic Message Syntax (CMS)",
      "ja": "RFC 3274 [RFC3274]：暗号メッセージ構文（CMS）のための圧縮されたデータcontent type"
    },
    {
      "indent": 6,
      "text": "- CompressedData",
      "ja": " -  CompressedData"
    },
    {
      "indent": 3,
      "text": "Some intermediate nodes can also function as leaf nodes in some situations. EncryptedData, EnvelopedData, and AuthEnvelopedData nodes will function as intermediate nodes for recipients that can decrypt the content and as encrypted leaf nodes for recipients who cannot decrypt the content.",
      "ja": "いくつかの中間ノードは、いくつかの状況ではリーフ・ノードとして機能することができます。 EncryptedData、EnvelopedDataの、そしてAuthEnvelopedDataノードがコンテンツを復号化できる受信者のための中間ノードとして、およびコンテンツを復号化することができない受信者に対して暗号化されたリーフ・ノードとして機能します。"
    },
    {
      "indent": 3,
      "text": "When using CMS, the outermost structure is always ContentInfo. ContentInfo consists of an object identifier and an associated content. The object identifier describes the structure of the content. Object identifiers are used throughout the CMS family of specifications to identify structures.",
      "ja": "CMSを使用する場合は、最も外側の構造は常にContentInfoです。 ContentInfoは、オブジェクト識別子と関連付けられたコンテンツから成ります。オブジェクト識別子は、コンテンツの構成について説明します。オブジェクト識別子は、構造体を識別するために、仕様のCMSファミリ全体で使用されています。"
    },
    {
      "indent": 3,
      "text": "Using the content types listed above, ignoring for the moment ContentCollection, encapsulation can be used to create structures of arbitrary depth. Two examples based on [RFC4108] are shown in Figure 1 and Figure 2.",
      "ja": "モーメントContentCollectionため無視し、上記コンテンツタイプを使用して、カプセル化は、任意の深さの構造を作成するために使用することができます。 [RFC4108]に基づいて、2つの例は、図1および図2に示されています。"
    },
    {
      "indent": 3,
      "text": "When ContentCollection is used in conjunction with the other content types, tree-like structures can be defined, as shown in Figure 3.",
      "ja": "ContentCollectionは、他のコンテンツタイプに関連して使用される場合、図3に示すように、ツリー状の構造は、定義することができます。"
    },
    {
      "indent": 3,
      "text": "The examples in Figures 1, 2, and 3 can each be represented as a tree: the root node is the outermost ContentInfo, and the leaf nodes are the encapsulated contents. The trees are shown in Figure 4.",
      "ja": "ルートノードは、最も外側のContentInfoであり、リーフノードは、カプセル化されたコンテンツである：図1、図2、および図3の例では、各ツリーとして表すことができます。木は、図4に示されています。"
    },
    {
      "indent": 9,
      "text": "+---------------------------------------------------------+\n| ContentInfo                                             |\n|                                                         |\n| +-----------------------------------------------------+ |\n| | SignedData                                          | |\n| |                                                     | |\n| | +-------------------------------------------------+ | |\n| | | FirmwarePackage                                 | | |\n| | |                                                 | | |\n| | |                                                 | | |\n| | +-------------------------------------------------+ | |\n| +-----------------------------------------------------+ |\n+---------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 1. Example of a Signed Firmware Package",
      "ja": "署名されたファームウェアパッケージの図1の例"
    },
    {
      "indent": 9,
      "text": "+---------------------------------------------------------+\n| ContentInfo                                             |\n|                                                         |\n| +-----------------------------------------------------+ |\n| | SignedData                                          | |\n| |                                                     | |\n| | +-------------------------------------------------+ | |\n| | | EncryptedData                                   | | |\n| | |                                                 | | |\n| | | +---------------------------------------------+ | | |\n| | | | FirmwarePackage                             | | | |\n| | | |                                             | | | |\n| | | |                                             | | | |\n| | | +---------------------------------------------+ | | |\n| | +-------------------------------------------------+ | |\n| +-----------------------------------------------------+ |\n+---------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 2. Example of a Signed and Encrypted Firmware Package",
      "ja": "署名および暗号化されたファームウェアパッケージの図2の例"
    },
    {
      "indent": 9,
      "text": "+---------------------------------------------------------+\n| ContentInfo                                             |\n|                                                         |\n| +-----------------------------------------------------+ |\n| | SignedData                                          | |\n| |                                                     | |\n| | +-------------------------------------------------+ | |\n| | | ContentCollection                               | | |\n| | |                                                 | | |\n| | | +----------------------+ +--------------------+ | | |\n| | | | SignedData           | | SignedData         | | | |\n| | | |                      | |                    | | | |\n| | | | +------------------+ | | +----------------+ | | | |\n| | | | | EncryptedData    | | | | Firmware       | | | | |\n| | | | |                  | | | | Package        | | | | |\n| | | | | +--------------+ | | | |                | | | | |\n| | | | | | Firmware     | | | | +----------------+ | | | |\n| | | | | | Package      | | | +--------------------+ | | |\n| | | | | |              | | |                        | | |\n| | | | | +--------------+ | |                        | | |\n| | | | +------------------+ |                        | | |\n| | | +----------------------+                        | | |\n| | +-------------------------------------------------+ | |\n| +-----------------------------------------------------+ |\n+---------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 3. Example of Two Firmware Packages in a Collection",
      "ja": "コレクションでの2つのファームウェアパッケージの図3の例"
    },
    {
      "indent": 9,
      "text": "+---------------------------------------------------------+\n|                                                         |\n|     CMS PATH RESULTING            CMS PATH RESULTING    |\n|       FROM FIGURE 1.                FROM FIGURE 2.      |\n|                                                         |\n|       ContentInfo                   ContentInfo         |\n|           |                             |               |\n|           V                             V               |\n|       SignedData                    SignedData          |\n|           |                             |               |\n|           V                             V               |\n|       FirmwarePackage               EncryptedData       |\n|                                         |               |\n|                                         V               |\n|                                     FirmwarePackage     |\n|                                                         |\n|                                                         |\n|            CMS PATHS RESULTING FROM FIGURE 3.           |\n|                                                         |\n|                       ContentInfo                       |\n|                           |                             |\n|                           V                             |\n|                       SignedData                        |\n|                           |                             |\n|                           V                             |\n|                       ContentCollection                 |\n|                           |                             |\n|                +----------+--------------+              |\n|                |                         |              |\n|                V                         V              |\n|            SignedData                SignedData         |\n|                |                         |              |\n|                V                         V              |\n|            EncryptedData             FirmwarePackage    |\n|                |                                        |\n|                V                                        |\n|            FirmwarePackage                              |\n|                                                         |\n+---------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 4. Example CMS Path Structures",
      "ja": "4.例CMSパス構造を図"
    },
    {
      "indent": 3,
      "text": "These examples do not illustrate all of the details of CMS structures; most CMS protecting content types, and some leaf-node content types, contain attributes. Attributes from intermediate nodes can influence processing and handling of the CMS protecting content type or the encapsulated content type. Attributes from leaf nodes may be checked independent of the CCC processing, but such processing is not addressed in this document. Throughout this document, paths through the tree structure from a root node to a leaf node in a CMS-protected message are referred to as CMS paths.",
      "ja": "これらの例は、CMS構造の細部のすべてを説明していません。ほとんどのコンテンツタイプを保護するCMS、およびいくつかのリーフノードのコンテンツタイプは、属性が含まれています。中間ノードからの属性がCMSは、コンテンツタイプ、またはカプセル化されたコンテンツのタイプを保護する処理と取り扱いに影響を与えることができます。リーフノードからの属性は、CCCの処理とは独立して確認することができるが、そのような処理は、本書で扱われていません。本明細書を通して、CMSで保護されたメッセージ内のリーフ・ノードにルートノードからツリー構造を通るパスは、CMSパスと呼ばれます。"
    },
    {
      "indent": 0,
      "text": "1.2. CMS Content Constraints Model",
      "section_title": true,
      "ja": "1.2。 CMSコンテンツ制約モデル"
    },
    {
      "indent": 3,
      "text": "The CCC extension is used to restrict the types of content for which a particular public key can be used to verify a signature or MAC. Trust in a public key is established by building and validating a certification path from a trust anchor to the subject public key. Section 6 of [RFC5280] describes the algorithm for certification path validation, and the basic path validation algorithm is augmented, as described in Section 3 of this document, to include processing required to determine the CMS content constraints that have been delegated to the subject public key. If the subject public key is explicitly trusted (the public key belongs to a trust anchor), then any CMS content constraints associated with the trust anchor are used directly. If the subject public key is not explicitly trusted, then the CMS content constraints are determined by calculating the intersection of the CMS content constraints included in all the certificates in a valid certification path from the trust anchor to the subject public key, including those associated with the trust anchor.",
      "ja": "CCCの拡張は、特定の公開鍵署名またはMACを検証するために使用することができるため、コンテンツのタイプを制限するために使用されます。公開鍵の信頼を構築し、サブジェクトの公開鍵をトラストアンカーからの証明書パスを検証することによって確立されています。 [RFC5280]のセクション6は、認証パスの検証のためのアルゴリズムを説明し、このドキュメントのセクション3に記載されているように基本的なパス検証アルゴリズムは、対象の公開に委任されているCMSコンテンツ制約を決定するのに必要な処理を含むように、拡張されキー。サブジェクトの公開鍵が明示的に（公開鍵は、トラストアンカーに所属）信頼されている場合は、トラストアンカーに関連付けられている任意のCMSのコンテンツの制約が直接使用されています。サブジェクトの公開鍵が明示的に信頼されていない場合は、CMSのコンテンツの制約は、関連するものを含む、対象の公開鍵にトラストアンカーからの有効な証明のパスにあるすべての証明書に含まCMSのコンテンツの制約の交点を計算することによって決定されていますトラストアンカー。"
    },
    {
      "indent": 3,
      "text": "CMS enables the use of multiple nested signatures or MACs. Each signature or MAC can protect and associate attributes with an encapsulated data object. The CMS content constraints extension is associated with a public key, and that public key is used to verify a signature or a MAC.",
      "ja": "CMSは、複数のネストされた署名またはMACの使用を可能にします。各署名またはMACを保護することができると会合してカプセル化されたデータオブジェクトに属性。 CMSコンテンツ制約拡張は、公開鍵に関連付けられ、その公開鍵は署名またはMACを検証するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The CMS content constraints mechanism can be used to place limits on the use of the subject public key used for authentication or signature verification for one or more specific content types. Furthermore, within each permitted content type, a permitted set of values can be expressed for one or more specific attribute types.",
      "ja": "CMSコンテンツ制約機構は、一つ以上の特定のコンテンツタイプの認証または署名検証に使用対象の公開鍵の使用に制限を配置するために使用することができます。また、各許可コンテンツタイプ内で、値の許容セットは、1つのまたは複数の特定の属性タイプに発現させることができます。"
    },
    {
      "indent": 3,
      "text": "When a leaf content type is encapsulated by multiple intermediate authentication layers, the signer or originator closest to a leaf node must be authorized to serve as a source for the leaf content type; outer signers or originators need not be authorized to serve as a source, but must be authorized for the leaf content type. All signers or originators must be authorized for the attributes that appear in a CMS path.",
      "ja": "リーフ・コンテンツ・タイプは、複数の認証中間層によってカプセル化されたときに、リーフノードに最も近い署名者又は発信者はリーフ・コンテンツ・タイプのソースとして機能することが許可されなければなりません。外側の署名者やオリジネーターは、ソースとして機能することを許可する必要はなく、葉のコンテンツタイプを許可する必要があります。すべての署名者やオリジネーターは、CMSのパスに表示された属性を許可しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A signer or originator may be constrained to use a specific set of attribute values for some attribute types when producing a particular content type. If a signer or originator is constrained for a particular attribute that does not appear in a protected content of the type for which the constraint is defined, the constraint serves as a default attribute, i.e., the payload should be processed as if an attribute equal to the constraint appeared in the protected content. However, in some cases, the processing rules for a particular content type may disallow the usage of default values for some attribute types and require a signer to explicitly assert the attribute to satisfy the constraint. Signer constraints are output for use in leaf node processing or other processing not addressed by this specification.",
      "ja": "署名者又は発信者は、特定のコンテンツタイプを製造する際に、いくつかの属性タイプの属性値の特定のセットを使用するように制約されてもよいです。署名者または発信者が、制約が定義されているタイプの保護されたコンテンツに表示されない、制約、すなわち、デフォルトの属性としての特定の属性のために拘束されている場合、ペイロードに等しい属性かのように処理されるべき制約は、保護されたコンテンツに登場しました。しかし、いくつかのケースでは、特定のコンテンツタイプに対する処理ルールは、いくつかの属性タイプのデフォルト値の使用を許可しないと明示的制約を満足する属性をアサートする署名者を必要とし得ます。署名者の制約がない、本明細書によって対処リーフノード処理または他の処理で使用するために出力されます。"
    },
    {
      "indent": 3,
      "text": "Three models for processing attributes were considered:",
      "ja": "処理属性のための3つのモデルが考えられました。"
    },
    {
      "indent": 3,
      "text": "o Each signer or originator must be authorized for attributes it asserts.",
      "ja": "O各署名者または発信者は、それがアサートされた属性を許可しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Each signer or originator must be authorized for attributes it asserts and attributes contained in the content it authenticates.",
      "ja": "O各署名者または発信者は、それが認証したコンテンツに含まれることがアサート属性と属性のために承認されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Each signer or originator must be authorized for attributes it asserts, attributes contained in the content it authenticates, and attributes contained in content that authenticates it, i.e., all signers or originators must be authorized for all attributes appearing in the CMS path.",
      "ja": "O各署名者または発信者がそれを認証し、コンテンツに含まれることがアサート属性、それは認証コンテンツに含まれる属性、および属性のために許可されなければならない、すなわち、すべての署名者または発信者がCMSパスに現れるすべての属性のために許可されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The third model is used in this specification.",
      "ja": "第3のモデルは、本明細書で使用されます。"
    },
    {
      "indent": 0,
      "text": "1.3. Attribute Processing",
      "section_title": true,
      "ja": "1.3。属性の処理"
    },
    {
      "indent": 3,
      "text": "This specification defines a mechanism for enforcing constraints on content types and attributes. Where content types are straightforward to process because there is precisely one content type of interest for a given CMS path, attributes are more challenging. Attributes can be asserted at many different points in a CMS path. Some attributes may, by their nature, be applicable to a specific node of a CMS path; for example, ContentType and MessageDigest attributes apply to a specific SignerInfo object. Other attributes may apply to a less well-defined target; for example, a ContentCollection may appear as the payload within a ContentWithAttributes object.",
      "ja": "この仕様は、コンテンツタイプと属性の制約を強制するためのメカニズムを定義します。コンテンツの種類が処理するのは簡単である場合与えられたCMSパスの関心の正確に1つのコンテンツタイプがあるので、属性がより困難です。属性は、CMSのパスで多くの異なる時点でアサートすることができます。一部の属性は、その性質上、CMSパスの特定のノードにも適用することができます。例えば、ContentTypeをとのMessageDigest属性は、特定のSignerInfoオブジェクトに適用されます。他の属性はあまり明確に定義されたターゲットに適用される場合があります。例えば、ContentCollectionはContentWithAttributesオブジェクト内のペイロードとして現れ得ます。"
    },
    {
      "indent": 3,
      "text": "Since there is no automated means of determining what an arbitrary attribute applies to or how the attribute should be used, CCC processing simply collects attributes and makes them available for applications to use during leaf node processing. Implementations SHOULD refrain from collecting attributes that are known to be inapplicable to leaf node processing, for example, ContentType and MessageDigest attributes.",
      "ja": "任意の属性が適用される何か属性が使用されるべきかを決定するのない自動化された手段がないため、CCCの処理は、単純な属性を収集し、リーフノードの処理中に使用するアプリケーションに利用できるようになります。実装は、リーフノードの処理、例えば、のContentTypeとするMessageDigest属性に適用できないことが知られている属性を収集を控えるべきです。"
    },
    {
      "indent": 3,
      "text": "Some attributes contain multiple values. Attribute constraints expressed in a CCC extension may contain multiple values. Attributes expressed in a constraint that do not appear in a CMS path are returned as default attributes. Default attributes may have multiple values. Attributes are returned to an application via two output variables: cms_effective_attributes and cms_default_attributes. An attribute may be absent, present with one value, or present with multiple values in a CMS path and/or in CMS content constraints. A summary of the resulting nine possible combinations is below.",
      "ja": "一部の属性は複数の値を含みます。 CCC拡張で発現制約が複数の値を含むことができる属性。 CMSのパスに表示されていない制約で表現属性は、デフォルトの属性として返されます。デフォルト属性は複数の値を持つことができます。 cms_effective_attributesとcms_default_attributes：属性は、2つの出力変数を介してアプリケーションに戻されます。属性は、一つの値を持つ存在、不在、またはCMS経路及び/又はCMSコンテンツ制約内で複数の値を持つ存在してもよいです。得られた9つの可能な組合せの概要は以下です。"
    },
    {
      "indent": 6,
      "text": "Attribute absent in CMS path; absent in cms_constraints: no action.",
      "ja": "CMSパスに不在属性。 cms_constraintsには存在しない：アクションなし。"
    },
    {
      "indent": 6,
      "text": "Attribute absent in CMS path; single value in cms_constraints: the value from cms_constraints is added to cms_default_attributes.",
      "ja": "CMSパスに不在属性。 cms_constraintsにおける単一の値は：cms_constraintsからの値がcms_default_attributesに追加されます。"
    },
    {
      "indent": 6,
      "text": "Attribute absent in CMS path; multiple values in cms_constraints: the values from cms_constraints are added to cms_default_attributes.",
      "ja": "CMSパスに不在属性。 cms_constraintsで複数の値：cms_constraintsからの値がcms_default_attributesに追加されます。"
    },
    {
      "indent": 6,
      "text": "Attribute is present with a single value in CMS path; absent in cms_constraints: the value from CMS path is returned in cms_effective_attributes.",
      "ja": "属性には、CMSのパスに単一の値を持つ存在です。 cms_constraintsには存在しない：CMSパスからの値がcms_effective_attributesに返されます。"
    },
    {
      "indent": 6,
      "text": "Attribute is present with a single value in CMS path; single value in cms_constraints: the value from CMS path must match the value from cms_constraints. If successful match, the value is returned in cms_effective_attribute. If no match, constraints processing fails.",
      "ja": "属性には、CMSのパスに単一の値を持つ存在です。 cms_constraintsでの単一の値：CMSパスから値がcms_constraintsからの値と一致する必要があります。マッチが成功した場合、値がcms_effective_attributeに返されます。マッチしない場合には、制約の処理は失敗します。"
    },
    {
      "indent": 6,
      "text": "Attribute is present with a single value in CMS path; multiple values in cms_constraints: the value from CMS path must match a value from cms_constraints. If successful match, the value from the CMS path is returned in cms_effective_attribute. If no match, constraints processing fails.",
      "ja": "属性には、CMSのパスに単一の値を持つ存在です。 cms_constraintsで複数の値：CMSパスから値がcms_constraintsから値と一致する必要があります。マッチが成功した場合は、CMSのパスから値がcms_effective_attributeに返されます。マッチしない場合には、制約の処理は失敗します。"
    },
    {
      "indent": 6,
      "text": "Attribute is present with multiple values in CMS path; absent in cms_constraints: the values from CMS path are returned in cms_effective_attributes.",
      "ja": "属性には、CMSのパスに複数の値を持つ存在です。 cms_constraintsには存在しない：CMSパスからの値がcms_effective_attributesで返されます。"
    },
    {
      "indent": 6,
      "text": "Attribute is present with multiple values; single value in cms_constraints: the values from CMS path must match the value from cms_constraints (i.e., all values must be identical). If successful match, the values from the CMS path are returned in cms_effective_attribute. If no match, constraints processing fails.",
      "ja": "属性は複数の値を持つ存在です。 cms_constraintsにおける単一値：CMS経路からの値（すなわち、すべての値が同じでなければならない）cms_constraintsからの値と一致しなければなりません。マッチが成功した場合は、CMSのパスから値がcms_effective_attributeに返されます。マッチしない場合には、制約の処理は失敗します。"
    },
    {
      "indent": 6,
      "text": "Attribute is present with multiple values; multiple values in cms_constraints: each value from CMS path must match a value from cms_constraints. If each comparison is successful, the values from the CMS path are returned in cms_effective_attribute. If a comparison fails, constraints processing fails.",
      "ja": "属性は複数の値を持つ存在です。 cms_constraintsにおける複数の値：CMSパスからの各値がcms_constraintsからの値と一致しなければなりません。それぞれの比較が成功した場合は、CMSのパスから値がcms_effective_attributeに返されます。比較が失敗した場合、制約の処理は失敗します。"
    },
    {
      "indent": 0,
      "text": "1.4. Abstract Syntax Notation",
      "section_title": true,
      "ja": "1.4。抽象構文記法"
    },
    {
      "indent": 3,
      "text": "All X.509 certificate [RFC5280] extensions are defined using ASN.1 [X.680][X.690].",
      "ja": "すべてのX.509証明書[RFC5280]の拡張機能は、ASN.1 [X.680] [X.690]を使用して定義されています。"
    },
    {
      "indent": 3,
      "text": "CMS content types [RFC5652] are also defined using ASN.1.",
      "ja": "CMSコンテンツタイプ[RFC5652]はまた、ASN.1を使用して定義されています。"
    },
    {
      "indent": 3,
      "text": "CMS uses the Attribute type. The syntax of Attribute is compatible with X.501 [X.501].",
      "ja": "CMSは、属性タイプを使用しています。属性の構文は、X.501 [X.501]と互換性があります。"
    },
    {
      "indent": 0,
      "text": "1.5. Terminology",
      "section_title": true,
      "ja": "1.5。用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. CMS Content Constraints Extension",
      "section_title": true,
      "ja": "2. CMSコンテンツ制約拡張"
    },
    {
      "indent": 3,
      "text": "The CMS content constraints extension provides a mechanism to constrain authorization during delegation. If the CMS content constraints extension is not present, then the subject of the trust anchor or certificate is not authorized for any content type, with an exception for apex trust anchors, which are implicitly authorized for all content types. A certificate issuer may use the CMS content constraints extension for one or more of the following purposes:",
      "ja": "CMSコンテンツ制約拡張は、委任時の認証を制限するためのメカニズムを提供します。 CMSコンテンツ制約拡張が存在しない場合、トラストアンカーまたは証明書のサブジェクトは、暗黙的にすべてのコンテンツタイプが認可されている頂点トラストアンカーのための例外を除いて、すべてのコンテンツタイプのために許可されていません。証明書発行者は、以下の目的のうちの1つまたは複数のCMSコンテンツ制約拡張を使用することがあります。"
    },
    {
      "indent": 3,
      "text": "o Limit the certificate subject to a subset of the content types for which the certificate issuer is authorized.",
      "ja": "O証明書発行者が許可されているコンテンツタイプのサブセットに証明書のサブジェクトを制限します。"
    },
    {
      "indent": 3,
      "text": "o Add constraints to a previously unconstrained content type.",
      "ja": "O以前に拘束されていないコンテンツの種類に制約を追加します。"
    },
    {
      "indent": 3,
      "text": "o Add additional constraints to a previously constrained content type.",
      "ja": "O以前に制約コンテンツタイプに追加の制約を追加します。"
    },
    {
      "indent": 3,
      "text": "The CMS content constraints extension MAY be critical, and it MUST appear at most one time in a trust anchor or certificate. The CMS content constraints extension is identified by the id-pe-cmsContentConstraints object identifier:",
      "ja": "CMSコンテンツ制約拡張は重要であり、それがトラストアンカーまたは証明書内で最も1時間に現れなければなりません。 CMSコンテンツ制約拡張は、ID-PE-cmsContentConstraintsオブジェクト識別子によって識別されます。"
    },
    {
      "indent": 9,
      "text": "id-pe-cmsContentConstraints OBJECT IDENTIFIER ::=\n    { iso(1) identified-organization(3) dod(6) internet(1)\n      security(5) mechanisms(5) pkix(7) pe(1) 18 }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The syntax for the CMS content constraints extension is:",
      "ja": "CMSコンテンツ制約拡張のための構文は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "CMSContentConstraints ::= SEQUENCE SIZE (1..MAX) OF\n  ContentTypeConstraint",
      "raw": true
    },
    {
      "indent": 5,
      "text": "ContentTypeGeneration ::= ENUMERATED {\n    canSource(0),\n    cannotSource(1)}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "ContentTypeConstraint ::= SEQUENCE {\n  contentType           OBJECT IDENTIFIER,\n  canSource             ContentTypeGeneration DEFAULT canSource,\n  attrConstraints       AttrConstraintList OPTIONAL }",
      "raw": true
    },
    {
      "indent": 5,
      "text": "AttrConstraintList ::= SEQUENCE SIZE (1..MAX) OF AttrConstraint",
      "raw": true
    },
    {
      "indent": 5,
      "text": "AttrConstraint ::= SEQUENCE {\n  attrType               AttributeType,\n  attrValues             SET SIZE (1..MAX) OF AttributeValue }",
      "raw": true
    },
    {
      "indent": 5,
      "text": "id-ct-anyContentType OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n       us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16)\n       ct(1) 0 }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The CMSContentConstraints is a list of permitted content types and associated constraints. A particular content type MUST NOT appear more than once in a CMSContentConstraints. When the extension is present, the certificate subject is being authorized by the certificate issuer to sign or authenticate the content types in the permitted list as long as the provided constraints, if any, are met. The relying party MUST ensure that the certificate issuer is authorized to delegate the privileges. When the extension is absent, the certificate subject is not authorized for any content type.",
      "ja": "CMSContentConstraintsは許可されたコンテンツの種類とそれに関連する制約のリストです。特定のコンテンツタイプはCMSContentConstraintsに一度より多く見えてはいけません。拡張が存在する場合、証明書のサブジェクトは署名または、満たされている場合、提供制約限り許可リスト内のコンテンツタイプを認証する証明書発行者によって許可されています。証明書利用者は、証明書発行者が権限を委譲する権限を与えられていることを保証しなければなりません。拡張が存在しない場合、証明書の対象は、任意のコンテンツタイプに許可されていません。"
    },
    {
      "indent": 3,
      "text": "The special id-ct-anyContentType value indicates the certificate subject is being authorized for any content type without any constraints. Where id-ct-anyContentType appears alongside a specific content type, the specific content type is authoritative. The id-ct-anyContentType object identifier can be used in trust anchors when the trust anchor is unconstrained. Where id-ct-anyContentType is asserted in the contentType field, the canSource field MUST be equal to the canSource enumerated value and attrConstraints MUST be absent, indicating that the trust anchor can serve as a source for any content type without any constraints.",
      "ja": "特別なID-CT-anyContentType値は、証明書のサブジェクトが制約なしに任意のコンテンツ・タイプのために認可されていることを示し。 ID-CT-anyContentTypeは、特定のコンテンツタイプと一緒に表示される場合は、特定のコンテンツタイプが権威です。 ID-CT-anyContentTypeオブジェクト識別子は、トラストアンカーは拘束されない場合に信頼アンカーに使用することができます。 ID-CT-anyContentTypeはcontentTypeのフィールドにアサートされる場合、canSourceフィールドがcanSource列挙値とattrConstraintsに等しくなければならないトラストアンカーを制約することなく、任意のコンテンツ・タイプのソースとして機能することができることを示す、存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "The fields of the ContentTypeConstraint type have the following meanings:",
      "ja": "ContentTypeConstraintタイプのフィールドは以下の意味があります。"
    },
    {
      "indent": 3,
      "text": "contentType is an object identifier that specifies a permitted content type. When the extension appears in an end entity certificate, it indicates that a content of this type can be verified using the public key in the certificate. When the extension appears in a certification authority (CA) certificate, it indicates that a content of this type can be verified using the public key in the CA certificate or the public key in an appropriately authorized subordinate certificate. For example, this field contains id-ct-firmwarePackage when the public key can be used to verify digital signatures on firmware packages defined in [RFC4108]. A particular content type MUST NOT appear more than once in the list. Intermediate content types MUST NOT be included in the list of permitted content types. Since the content type of intermediate nodes is not subject to CMS Constraint Processing, originators need not be authorized for intermediate node content types. The intermediate content types are:",
      "ja": "contentTypeが許可コンテンツタイプを指定するオブジェクト識別子です。拡張子は、エンドエンティティ証明書に表示されたら、それはこのタイプのコンテンツは、証明書の公開鍵を用いて検証することができることを示しています。拡張子が認証局（CA）証明書に表示されたら、それはこのタイプのコンテンツは、CAの証明書の公開鍵または適切な権限が下位証明書の公開鍵を用いて検証することができることを示しています。公開鍵は[RFC4108]で定義されたファームウェアパッケージのデジタル署名を検証するために使用することができる場合、例えば、このフィールドは、ID-CT-firmwarePackageを含有します。特定のコンテンツタイプは、一度、リスト内のより多く見えてはいけません。中級コンテンツタイプが許可されたコンテンツタイプのリストに含まれてはいけません。中間ノードのコンテンツタイプがCMS制約処理対象ではないので、発信者は、中間ノードのコンテンツタイプに対して許可する必要はありません。中間コンテンツの種類は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "id-signedData,",
      "ja": "ID-たsignedData、"
    },
    {
      "indent": 9,
      "text": "id-envelopedData,",
      "ja": "ID-EnvelopedDataの、"
    },
    {
      "indent": 9,
      "text": "id-digestedData,",
      "ja": "ID-digestedData、"
    },
    {
      "indent": 9,
      "text": "id-encryptedData,",
      "ja": "ID-はEncryptedData、"
    },
    {
      "indent": 9,
      "text": "id-ct-authEnvelopedData,",
      "ja": "ID-CT-authEnvelopedData、"
    },
    {
      "indent": 9,
      "text": "id-ct-authData,",
      "ja": "ID-CT-authData、"
    },
    {
      "indent": 9,
      "text": "id-ct-compressedData,",
      "ja": "ID-CT-compressedData、"
    },
    {
      "indent": 9,
      "text": "id-ct-contentCollection, and",
      "ja": "ID-CT-contentCollection、および"
    },
    {
      "indent": 9,
      "text": "id-ct-contentWithAttrs.",
      "ja": "ID-CT-contentWithAttrs。"
    },
    {
      "indent": 3,
      "text": "canSource is an enumerated value. If the canSource field is equal to canSource, then the subject can be the innermost authenticator of the specified content type. For a subject to be authorized to source a content type, the issuer of the subject certificate MUST also be authorized to source the content type. Regardless of the flag value, a subject can sign or authenticate a content that is already authenticated (when SignedData, AuthenticatedData, or AuthEnvelopedData is already present).",
      "ja": "canSourceは、列挙された値です。 canSourceフィールドがcanSourceに等しい場合、対象は、指定されたコンテンツ・タイプの最も内側のオーセンティケータであることができます。コンテンツタイプを供給することを許可される対象、対象の証明書の発行者は、コンテンツタイプを供給することを許可されなければなりません。かかわらず、フラグ値、被験者の（のSignedData、AuthenticatedData、またはAuthEnvelopedDataが既に存在する場合）が既に認証されているコンテンツを署名または認証することができます。"
    },
    {
      "indent": 3,
      "text": "attrConstraints is an optional field that contains constraints that are specific to the content type. If the attrConstraints field is absent, the public key can be used to verify the specified content type without further checking. If the attrConstraints field is present, then the public key can only be used to verify the specified content type if all of the constraints are satisfied. A particular constraint type, i.e., attrValues structure for a particular attribute type, MUST NOT appear more than once in the attrConstraints for a specified content type. Constraints are checked by matching the values in the constraint against the corresponding attribute value(s) in the CMS path. Constraints processing fails if the attribute is present and the value is not one of the values provided in the constraint. Constraint checking is described fully in Section 4.",
      "ja": "attrConstraintsは、コンテンツタイプに固有の制約が含まれているオプションのフィールドです。 attrConstraintsフィールドが存在しない場合は、公開鍵は、さらにチェックを行わずに指定されたコンテンツの種類を確認するために使用することができます。 attrConstraintsフィールドが存在する場合、公開鍵は、唯一の制約の全てが満たされた場合に指定されたコンテンツの種類を確認するために使用することができます。特定の制約タイプ、すなわち、特定の属性タイプのattrValues構造は、特定のコンテンツタイプに一度attrConstraintsよりも現れてはなりません。制約は、CMS路内の対応する属性値（複数可）に対する制約の値を照合することによってチェックされます。属性が存在し、値が制約に提供される値のいずれでもない場合、制約処理が失敗します。制約チェックはセクション4で完全に記述されています。"
    },
    {
      "indent": 6,
      "text": "The fields of the AttrConstraint type have the following meanings:",
      "ja": "AttrConstraintタイプのフィールドは以下の意味があります。"
    },
    {
      "indent": 6,
      "text": "attrType is an AttributeType, which is an object identifier that names an attribute. For a content encapsulated in a CMS SignedData, AuthenticatedData, or AuthEnvelopedData to satisfy the constraint, if the attributes that are covered by the signature or MAC include an attribute of the same type, then the attribute value MUST be equal to one of the values supplied in the attrValues field. Attributes that are not covered by the signature or MAC are not checked against constraints. Attribute types that do not appear as an AttrConstraint are unconstrained, i.e., the signer or originator is free to assert any value.",
      "ja": "ATTRTYPEは、その名前の属性をオブジェクト識別子であるAttributeTypeで、です。署名またはMACで覆われている属性が同じタイプの属性が含まれている場合、制約を満たすためにCMSのSignedData、AuthenticatedData、又はAuthEnvelopedData中にカプセル化コンテンツの場合、この属性値は、供給された値のいずれかに等しくなければなりませんattrValuesフィールドに入力します。署名やMACでカバーされていない属性は、制約に対してチェックされていません。 AttrConstraintが拘束されていないされているように表示されていない種類の属性、すなわち、署名者または発信者が任意の値を主張して自由です。"
    },
    {
      "indent": 6,
      "text": "attrValues is a set of AttributeValue. The structure of each of the values in attrValues is determined by attrType. Constraint checking is described fully in Section 4.",
      "ja": "attrValuesはAttributeValueのセットです。 attrValuesの値のそれぞれの構造はATTRTYPEによって決定されます。制約チェックはセクション4で完全に記述されています。"
    },
    {
      "indent": 0,
      "text": "3. Certification Path Processing",
      "section_title": true,
      "ja": "3.証明書パス処理"
    },
    {
      "indent": 3,
      "text": "When CMS content constraints are used for authorization, the processing described in this section SHOULD be included in the certification path validation. The processing is presented as an augmentation to the certification path validation algorithm described in Section 6 of [RFC5280], as shown in the figure below. Alternative implementations are allowed but MUST yield the same results as described below.",
      "ja": "CMSコンテンツ制約を許可するために使用される場合、このセクションで説明する処理は、認証パスの検証に含まれるべきです。以下の図に示すような処理は、[RFC5280]のセクション6に記載認証パス検証アルゴリズムの増強として提示されます。代替的な実装が許可されているが、以下に記載したのと同じ結果が得られなければなりません。"
    },
    {
      "indent": 3,
      "text": "CCC-related inputs\n+ inhibitAnyContentType flag\n+ absenceEqualsUnconstrained flag\n+ Trust anchor CCC extension\n+ Content type of interest (cms_content_type)\n+ Attributes of interest (cms_effective_attributes)\n                  |\n                  |\n   _______________V________________________\n  |                                        |\n  | CCC-aware Certification Path Processor |\n  |________________________________________|\n                  |\n                  |\n                  V\nCCC-related outputs upon success\n+ Applicable content type constraints (subject_constraints)\n+ Constrained attributes not present in cms_effective_attributes\n   (subject_default_attributes)\n+ Content types not propagated to end entity (excluded_content_types)",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 5. Certification Path Processing Inputs and Outputs",
      "ja": "図5.証明書のパス処理の入力と出力"
    },
    {
      "indent": 3,
      "text": "Certification path processing validates the binding between the subject and subject public key. If a valid certification path cannot be found, then the corresponding CMS path MUST be rejected.",
      "ja": "証明書パス処理はサブジェクトとサブジェクト公開鍵の間の結合を検証します。有効な証明書パスが見つからない場合は、対応するCMSのパスを拒絶しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.1. Inputs",
      "section_title": true,
      "ja": "3.1。入力"
    },
    {
      "indent": 3,
      "text": "Two boolean values are provided as input: inhibitAnyContentType and absenceEqualsUnconstrained.",
      "ja": "inhibitAnyContentTypeとabsenceEqualsUnconstrained：2つのブール値が入力として提供されています。"
    },
    {
      "indent": 3,
      "text": "The inhibitAnyContentType flag is used to govern processing of the special id-ct-anyContentType value. When inhibitAnyContentType is true, id-ct-anyContentType is not considered to match a content type. When inhibitAnyContentType is false, id-ct-anyContentType is considered to match any content type.",
      "ja": "inhibitAnyContentTypeフラグが特別なID-CT-anyContentType値の処理を管理するために使用されます。 inhibitAnyContentTypeが真である場合、ID-CT-anyContentTypeは、コンテンツタイプに一致するように考慮されていません。 inhibitAnyContentTypeがfalseの場合、ID-CT-anyContentTypeは、任意のコンテンツタイプに一致するように考えられています。"
    },
    {
      "indent": 3,
      "text": "The absenceEqualsUnconstrained flag is used to govern the meaning of CCC absence. When absenceEqualsUnconstrained is true, a trust anchor without a CCC extension is considered to be unconstrained and a certificate without a CCC extension is considered to have the same CCC privileges as its issuer. When absenceEqualsUnconstrained is false, a trust anchor or certificate without a CCC extension is not authorized for any content types.",
      "ja": "absenceEqualsUnconstrainedフラグは、CCCの不在の意味を支配するために使用されます。 absenceEqualsUnconstrainedがtrueの場合、CCC拡張子なしトラストアンカーが拘束されていないとみなされ、CCC拡張子なしの証明書は、その発行者と同じCCC権限を持っていると考えられています。 absenceEqualsUnconstrainedがfalseの場合、CCCの拡張子を除いたトラストアンカーまたは証明書は、任意のコンテンツタイプに対して許可されていません。"
    },
    {
      "indent": 3,
      "text": "Neither of these flags has any bearing on an apex trust anchor, which is always unconstrained by definition.",
      "ja": "これらのフラグのどちらも常に定義によって拘束されない頂点トラストアンカー、上の任意のベアリングを持っています。"
    },
    {
      "indent": 3,
      "text": "If a trust anchor used for path validation is authorized, then the trust anchor MAY include a CCC extension. A trust anchor may be constrained or unconstrained. If unconstrained, the trust anchor MUST either include a CMS Content Constraints extension containing the special id-ct-anyContentType value and inhibitAnyContentType is false or the trust anchor MUST have no CCC extension and absenceEqualsUnconstrained is true. If the trust anchor does not contain a CMS Content Constraints structure and absenceEqualsUnconstrained is false, the CMS content constraints processing fails. If the trust anchor contains a CCC extension with a single entry containing id-ct-anyContentType and inhibitAnyContentType is true, the CMS content constraints processing fails.",
      "ja": "パスの検証に使用トラストアンカーが許可されている場合は、トラストアンカーは、CCCの拡張子を含むかもしれません。トラストアンカーは、制約のある、あるいは制約のないことがあります。拘束されていない場合は、トラストアンカーは、いずれかの特別なID-CT-anyContentType値を含むCMSコンテンツ制約拡張を含まなければならないとinhibitAnyContentTypeは偽であるか、トラストアンカーが全くCCCの拡張子を持っていてはいけないとabsenceEqualsUnconstrainedが真です。トラストアンカーがCMSコンテンツ制約構造が含まれていないとabsenceEqualsUnconstrainedがfalseの場合、CMSコンテンツの制約処理は失敗します。トラストアンカーがID-CT-anyContentTypeとinhibitAnyContentTypeを含む単一のエントリとCCCの拡張が含まれている場合はtrueで、CMSコンテンツの制約処理は失敗します。"
    },
    {
      "indent": 3,
      "text": "The content type of the protected content being verified can be provided as input along with the set of attributes collected from the CMS path in order to determine if the certification path is valid for a given context. Alternatively, the id-ct-anyContentType value can be provided as the content type input, along with an empty set of attributes, to determine the full set of constraints associated with a public key in the end entity certificate in the certification path being validated.",
      "ja": "検証され保護されたコンテンツのコンテンツ・タイプは、認証パスが指定されたコンテキストに対して有効であるかどうかを決定するためにCMS路から集めた属性のセットとともに入力として提供することができます。あるいは、ID-CT-anyContentType値が検証される証明書パス内のエンドエンティティ証明書の公開鍵に関連付けられた制約の完全なセットを決定するために、属性の空のセットと共に、コンテンツタイプの入力として提供することができます。"
    },
    {
      "indent": 3,
      "text": "Trust anchors may produce CMS-protected contents. When validating messages originated by a trust anchor, certification path validation as described in Section 6 of [RFC5280] is not necessary, but constraints processing MUST still be performed for the trust anchor. In such cases, the initialization and wrap-up steps described below can be performed to determine if the public key in the trust anchor is appropriate to use in the processing of a protected content.",
      "ja": "トラストアンカーは、CMSで保護されたコンテンツを生成することができます。トラストアンカーによって発信メッセージを検証するとき、[RFC5280]のセクション6で説明したように認証パスの検証は必要ではなく、制約処理は、依然として信頼アンカーのために実行しなければなりません。そのような場合、初期化及び以下に説明ラップアップステップは、トラストアンカーの公開鍵が保護されたコンテンツの処理に使用することが適切であるかどうかを決定するために行うことができます。"
    },
    {
      "indent": 0,
      "text": "3.2. Initialization",
      "section_title": true,
      "ja": "3.2。初期化"
    },
    {
      "indent": 3,
      "text": "Create an input variable named cms_content_type and set it equal to the content type provided as input.",
      "ja": "cms_content_typeという名前の入力変数を作成し、入力として提供されるコンテンツのタイプに等しく設定します。"
    },
    {
      "indent": 3,
      "text": "Create an input variable named cms_effective_attributes and set it equal to the set of attributes provided as input.",
      "ja": "cms_effective_attributesという名前の入力変数を作成し、入力として提供する一連の属性と同じに設定します。"
    },
    {
      "indent": 3,
      "text": "Create a state variable named working_permitted_content_types. The initial value of working_permitted_content_types is the permitted content type list from the trust anchor, including any associated constraints.",
      "ja": "working_permitted_content_typesという名前の状態変数を作成します。 working_permitted_content_typesの初期値は、任意の関連する制約を含むトラストアンカー、から許可コンテンツタイプの一覧です。"
    },
    {
      "indent": 3,
      "text": "Create a state variable named excluded_content_types. The initial value of excluded_content_types is empty.",
      "ja": "excluded_content_typesという名前の状態変数を作成します。 excluded_content_typesの初期値は空です。"
    },
    {
      "indent": 3,
      "text": "Create a state variable of type SEQUENCE OF AttrConstraint named subject_default_attributes and initialize it to empty.",
      "ja": "AttrConstraintという名前subject_default_attributes OF型配列の状態変数を作成し、空にそれを初期化します。"
    },
    {
      "indent": 3,
      "text": "Create a state variable of type SEQUENCE OF ContentTypeConstraint named subject_constraints and initialize it to empty.",
      "ja": "ContentTypeConstraintという名前subject_constraints OF型配列の状態変数を作成し、空にそれを初期化します。"
    },
    {
      "indent": 0,
      "text": "3.3. Basic Certificate Processing",
      "section_title": true,
      "ja": "3.3。基本証明書処理"
    },
    {
      "indent": 3,
      "text": "If the CCC extension is not present in the certificate, check the value of absenceEqualsUnconstrained. If false, set working_permitted_content_types to empty. If true, working_permitted_content_types is unchanged. In either case, no further CCC processing is required for the certificate.",
      "ja": "CCCの拡張子が証明書に存在しない場合、absenceEqualsUnconstrainedの値を確認してください。 falseの場合、空にworking_permitted_content_typesを設定します。 trueの場合、working_permitted_content_typesは変更されません。いずれの場合においても、更なるCCC処理は、証明書のために必要とされません。"
    },
    {
      "indent": 3,
      "text": "If inhibitAnyContenType is true, discard any entries in the CCC extension with a content type value equal to id-ct-anyContentType.",
      "ja": "inhibitAnyContenTypeが真である場合、ID-CT-anyContentTypeに等しいコンテンツタイプ値とCCC拡張のすべてのエントリを破棄する。"
    },
    {
      "indent": 3,
      "text": "For each entry in the permitted content type list sequence in the CMS content constraints extension, the following steps are performed:",
      "ja": "CMSコンテンツ制約拡張で許可されたコンテンツタイプリスト列の各エントリについて、以下のステップが実行されます。"
    },
    {
      "indent": 3,
      "text": "- If the entry contains the special id-ct-anyContentType value, skip to the next entry.",
      "ja": " - エントリは特別なID-CT-anyContentType値が含まれている場合は、次のエントリに進みます。"
    },
    {
      "indent": 3,
      "text": "- If the entry contains a content type that is present in excluded_content_types, skip to the next entry.",
      "ja": " - エントリがexcluded_content_typesに存在しているコンテンツタイプが含まれている場合は、次のエントリに進みます。"
    },
    {
      "indent": 3,
      "text": "- If the entry includes a content type that is not present in working_permitted_content_types, determine if working_permitted_content_types contains an entry equal to the special id-ct-anyContentType value. If no, no action is taken and working_permitted_content_types is unchanged. If yes, add the entry to working_permitted_content_types.",
      "ja": " - エントリがworking_permitted_content_typesに存在しないコンテンツタイプが含まれている場合working_permitted_content_types特別なID-CT-anyContentType値に等しいエントリが含まれている場合、決定します。ノーならば、何もアクションは取られていないとworking_permitted_content_typesが変更されません。そうならば、working_permitted_content_typesにエントリを追加します。"
    },
    {
      "indent": 3,
      "text": "- If the entry includes a content type that is already present in working_permitted_content_types, then the constraints in the entry can further reduce the authorization by adding constraints to previously unconstrained attributes or by removing attribute values from the attrValues set of a constrained attribute. The canSource flag is set to cannotSource unless it is canSource in the working_permitted_content_types entry and in the entry. The processing actions to be performed for each constraint in the AttrConstraintList follow:",
      "ja": " - エントリが既にworking_permitted_content_typesに存在するコンテンツタイプが含まれている場合、エントリ内の制約がさらに先に制約されていない属性に制約を加えることによって、または拘束属性のセットattrValuesから属性値を除去することにより、承認を低減することができます。それはworking_permitted_content_typesエントリおよびエントリにcanSourceない限りcanSourceフラグがcannotSourceに設定されています。 AttrConstraintListフォローに制約ごとに実行される処理アクション："
    },
    {
      "indent": 6,
      "text": "-- If the constraint includes an attribute type that is not present in the corresponding working_permitted_content_types entry, add the attribute type and the associated set of attribute values to working_permitted_content_types entry.",
      "ja": " - 制約は、対応するworking_permitted_content_typesエントリに存在しない属性タイプが含まれている場合、エントリをworking_permitted_content_typesする属性タイプと属性値の関連セットを追加。"
    },
    {
      "indent": 6,
      "text": "-- If the constraint includes an attribute type that is already present in the corresponding working_permitted_content_types entry, then compute the intersection of the set of attribute values from the working_permitted_content_types entry and the constraint. If the intersection contains at least one attribute value, then the set of attribute values in working_permitted_content_types entry is assigned the intersection. If the intersection is empty, then the entry is removed from working_permitted_content_types and the content type from the entry is added to excluded_content_types.",
      "ja": " - 制約が既に対応working_permitted_content_typesエントリに存在する属性タイプが含まれている場合、次いでworking_permitted_content_typesエントリおよび制約からの属性値のセットの共通部分を計算します。交差点は、少なくとも1つの属性値が含まれている場合、working_permitted_content_typesエントリの属性値のセットは、交差点を割り当てられています。交差が空である場合、エントリはworking_permitted_content_typesから削除され、エントリのコンテンツタイプがexcluded_content_typesに添加されます。"
    },
    {
      "indent": 3,
      "text": "Remove each entry in working_permitted_content_types that includes a content type that is not present in the CMS content constraints extension. For values other than id-ct-anyContentType, add the removed content type to excluded_content_types.",
      "ja": "CMSコンテンツ制約拡張に存在しないコンテンツタイプが含まれてworking_permitted_content_typesの各エントリを削除します。 ID-CT-anyContentType以外の値について、excluded_content_typesに削除されたコンテンツタイプを追加します。"
    },
    {
      "indent": 0,
      "text": "3.4. Preparation for Certificate i+1",
      "section_title": true,
      "ja": "3.4。証明書の準備、私は1を+"
    },
    {
      "indent": 3,
      "text": "No additional action associated with the CMS content constraints extension is taken during this phase of certification path validation as described in Section 6 of [RFC5280].",
      "ja": "[RFC5280]のセクション6で説明したようにCMSコンテンツ制約拡張に関連付けられた追加のアクションは、認証パス検証のこの段階の間に行われません。"
    },
    {
      "indent": 0,
      "text": "3.5. Wrap-Up Procedure",
      "section_title": true,
      "ja": "3.5。ラップアップの手順"
    },
    {
      "indent": 3,
      "text": "If cms_content_type equals the special value anyContentType, the CCC processing portion of path validation succeeds. Set subject_constraints equal to working_permitted_content_types. If cms_content_type is not equal to the special value anyContentType, perform the following steps:",
      "ja": "cms_content_typeが特別な値anyContentTypeに等しい場合、パス検証のCCC処理部は成功します。 working_permitted_content_typesに等しいsubject_constraintsを設定します。 cms_content_typeが特別な値anyContentTypeと等しくない場合は、次の手順を実行します。"
    },
    {
      "indent": 3,
      "text": "- If cms_content_type is present in excluded_content_types, the CCC processing portion of path validation fails.",
      "ja": " -  cms_content_typeはexcluded_content_typesに存在する場合、パス検証のCCC処理部は失敗します。"
    },
    {
      "indent": 3,
      "text": "- If working_permitted_content_types is equal to the special value anyContentType, set subject_constraints equal to working_permitted_content_types; the CCC processing portion of path validation succeeds.",
      "ja": " -  working_permitted_content_typesは特別な値anyContentTypeに等しい場合、working_permitted_content_typesに等しいsubject_constraintsを設定し、パス検証のCCC処理部は成功します。"
    },
    {
      "indent": 3,
      "text": "- If cms_content_type does not equal the content type of an entry in working_permitted_content_types, constraints processing fails and path validation fails.",
      "ja": " -  cms_content_typeはworking_permitted_content_typesのエントリのコンテンツタイプに等しくない場合、制約の処理が失敗し、パスの検証に失敗しました。"
    },
    {
      "indent": 3,
      "text": "- If cms_content_type equals the content type of an entry in working_permitted_content_types, add the entry from working_permitted_content_types to subject_constraints. If the corresponding entry in working_permitted_content_types contains the special value anyContentType, set subject_constraints equal to cms_content_type; the CCC processing portion of path validation succeeds.",
      "ja": " -  cms_content_typeはworking_permitted_content_typesのエントリのコンテンツタイプに等しい場合は、working_permitted_content_typesからsubject_constraintsにエントリを追加します。 working_permitted_content_typesの対応するエントリは、特別な値anyContentTypeが含まれている場合、cms_content_typeに等しくsubject_constraintsを設定します。パス検証のCCC処理部は成功します。"
    },
    {
      "indent": 3,
      "text": "- If the attrConstraints field of the corresponding entry in working_permitted_content_types is absent; the CCC processing portion of path validation succeeds.",
      "ja": " -  working_permitted_content_typesの対応するエントリのattrConstraintsフィールドが存在しない場合。パス検証のCCC処理部は成功します。"
    },
    {
      "indent": 3,
      "text": "- If the attrConstraints field of the corresponding entry in working_permitted_content_types is present, then the constraints MUST be checked. For each attrType in the attrConstraints, the constraint is satisfied if either the attribute type is absent from cms_effective_attributes or each attribute value in the attrValues field of the corresponding entry in cms_effective_attributes is equal to one of the values for this attribute type in the attrConstraints field. If cms_effective_attributes does not contain an attribute of that type, then the entry from attrConstraints is added to the subject_default_attributes for use in processing the payload.",
      "ja": " -  working_permitted_content_typesの対応するエントリのattrConstraintsフィールドが存在する場合には、制約がチェックしなければなりません。属性タイプのいずれかがcms_effective_attributesから存在しないか、またはcms_effective_attributesの対応するエントリのattrValuesフィールドの各属性値がattrConstraintsフィールドに、この属性タイプの値の1に等しい。場合attrConstraints各ATTRTYPEため、制約が満たされますcms_effective_attributesがそのタイプの属性が含まれていない場合は、attrConstraintsからのエントリーは、ペイロードの処理に使用するためsubject_default_attributesに追加されます。"
    },
    {
      "indent": 0,
      "text": "3.6. Outputs",
      "section_title": true,
      "ja": "3.6。アウトプット"
    },
    {
      "indent": 3,
      "text": "If certification path validation processing succeeds, return the value of the subject_constraints, subject_default_attributes, and excluded_content_types variables.",
      "ja": "認証パス検証処理が成功した場合、subject_constraints、subject_default_attributes、およびexcluded_content_types変数の値を返します。"
    },
    {
      "indent": 0,
      "text": "4. CMS Content Constraints Processing",
      "section_title": true,
      "ja": "処理4. CMSのコンテンツの制約"
    },
    {
      "indent": 3,
      "text": "CMS contents constraints processing is performed on a per-CMS-path basis. The processing consists of traditional CMS processing augmented by collection of information required to perform content type and constraint checking. Content type and constraint checking uses the collected information to build and validate a certification path to each public key used to authenticate nodes in the CMS path per the certification path processing steps described above.",
      "ja": "CMSコンテンツ制約処理があたり-CMS-パスに基づいて行われます。処理は、コンテンツタイプと制約チェックを実行するために必要な情報の収集によって増大伝統的なCMSの処理で構成されています。コンテンツタイプおよび制約チェックは、上記認証パス処理工程ごとにCMSパス内のノードを認証するために使用される各公開鍵に認証パスを構築し、検証するために収集された情報を使用します。"
    },
    {
      "indent": 0,
      "text": "4.1. CMS Processing and CCC Information Collection",
      "section_title": true,
      "ja": "4.1。 CMS処理とCCC情報収集"
    },
    {
      "indent": 3,
      "text": "Traditional CMS content processing is augmented by the following three steps to support enforcement of CMS content constraints:",
      "ja": "伝統的なCMSのコンテンツ処理は、CMSのコンテンツの制約の施行をサポートするために、次の3つのステップによって拡張されます。"
    },
    {
      "indent": 6,
      "text": "Collection of signer or originator keys",
      "ja": "署名者または発信元のキーのコレクション"
    },
    {
      "indent": 6,
      "text": "Collection of attributes",
      "ja": "属性のコレクション"
    },
    {
      "indent": 6,
      "text": "Leaf node classification",
      "ja": "葉ノードの分類"
    },
    {
      "indent": 3,
      "text": "CMS processing and CCC information collection takes a CMS path as input and returns a collection of public keys used to authenticate protected content, a collection of authenticated attributes, and the leaf node, as shown in the figure below.",
      "ja": "CMS処理とCCC情報収集は、入力としてCMS経路をとり、以下の図に示すように、保護されたコンテンツ、認証された属性の集合を認証するために使用される公開鍵の集合、及びリーフノードを返します。"
    },
    {
      "indent": 3,
      "text": "Inputs\n+ CMS path\n          |\n          |\n _________V___________________\n|                             |\n| CMS processing and CCC      |\n|  information collection     |\n|_____________________________|\n          |\n          |\n          V\nOutputs upon success\n+ Leaf node\n+ Public keys used to authenticate content (cms_public_keys)\n+ Authenticated attributes (cms_effective_attributes)",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 6. CMS Processing and CCC Information Collection",
      "ja": "図6. CMS処理とCCC情報収集"
    },
    {
      "indent": 3,
      "text": "Processing is performed for each CMS path from the root node of a CMS-protected content to a leaf node, proceeding from the root node to the leaf node. Each path is processed independently of the other paths. Thus, it is possible that some leaf nodes in a content collection may be acceptable while other nodes are not acceptable. The processing described in this section applies to CMS paths that contain at least one SignedData, AuthEnvelopedData, or AuthenticatedData node. Since countersignatures are defined as not having a content, CMS content constraints are not used with countersignatures.",
      "ja": "処理は、リーフノードにルートノードから出発し、リーフノードにCMSで保護されたコンテンツのルート・ノードから各CMSパスに対して実行されます。各パスは、独立して他の経路で処理されます。したがって、他のノードが許容されないながら、コンテンツコレクション内のいくつかのリーフノードが許容可能であり得ることが可能です。このセクションで説明する処理は、少なくとも一つのSignedData、AuthEnvelopedData、又はAuthenticatedDataノードを含むCMSパスに適用されます。 countersignaturesがコンテンツを持っていないとして定義されているので、CMSコンテンツ制約はcountersignaturesと一緒に使用されていません。"
    },
    {
      "indent": 3,
      "text": "Signer or originator public keys are collected when verifying signatures or message authentication codes (MACs). These keys will be used to determine the constraints of each signer or originator by building and validating a certification path to the public key. Public key values, public key certificates, or public key identifiers are accumulated in a state variable named cms_public_keys, which is either initialized to empty or to an application-provided set of keys when processing begins. The variable will be updated each time a SignedData, AuthEnvelopedData, or AuthenticatedData node is encountered in the CMS path.",
      "ja": "署名又はメッセージ認証コード（MAC）を検証する際、署名者又は発信者の公開鍵を収集します。これらのキーは、公開鍵に証明書パスを構築し、検証することにより、各署名者や発信者の制約条件を決定するために使用されます。公開キーの値、公開鍵証明書、または公開鍵識別子は空に初期化や処理が始まるキーのアプリケーションが提供する組のどちらかであるcms_public_keysという名前の状態変数に蓄積されています。変数はSignedDataの、AuthEnvelopedData、またはAuthenticatedDataノードがCMSのパスで遭遇するたびに更新されます。"
    },
    {
      "indent": 3,
      "text": "All authenticated attributes appearing in a CMS path are collected, beginning with the attributes protected by the outermost SignedData, AuthEnvelopedData, or AuthenticatedData and proceeding to the leaf node. During processing, attributes collected from the nodes in the CMS path are maintained in a state variable named cms_effective_attributes, and default attributes derived from message originator authorizations are collected in a state variable named cms_default_attributes. A default attribute value comes from a constraint that does not correspond to an attribute contained in the CMS path and may be used during payload processing in lieu of an explicitly included attribute. This prevents an originator from avoiding a constraint through omission. When processing begins, cms_effective_attributes and cms_default_attributes are initialized to empty. Alternatively, cms_effective_attributes may be initialized to an application-provided sequence of attributes. The cms_effective_attributes value will be updated each time an attribute set is encountered in a SignedData, AuthEnvelopedData, AuthenticatedData, or (authenticated) ContentWithAttributes node while processing a CMS path.",
      "ja": "CMSパスに登場するすべての認証された属性は、最も外側のSignedData、AuthEnvelopedData、またはAuthenticatedDataによって保護され、リーフノードに進む属性で始まる、収集されています。処理中に、CMSパスのノードから収集された属性は、状態変数命名cms_effective_attributesに維持され、メッセージ発信権限に由来するデフォルト属性は、状態変数命名cms_default_attributesに収集されます。デフォルトの属性値は、CMSの経路に含まれる属性に対応しないと明示的に含まれる属性の代わりに、ペイロードの処理中に使用され得る制約から来ます。これは省略による制約を回避からの発信元を防ぎます。処理が開始されると、cms_effective_attributesとcms_default_attributesは空に初期化されます。あるいは、cms_effective_attributesは、属性のアプリケーションが提供する配列に初期化されてもよいです。 cms_effective_attributes値は、CMSパスの処理中に設定された属性がのSignedData、AuthEnvelopedData、AuthenticatedData、または（認証済み）ContentWithAttributesノードに遭遇するたびに更新されます。"
    },
    {
      "indent": 3,
      "text": "The output of content type and constraint checking always includes a set of attributes collected from the various nodes in a CMS path. When processing terminates at an encrypted node, the set of signer or originator public keys is also returned. When processing terminates at a leaf node, a set of default attribute values is also returned along with a set of constraints that apply to the CMS-protected content.",
      "ja": "常にチェックコンテンツタイプおよび制約の出力は、CMS経路における様々なノードから収集した属性のセットを含みます。処理は暗号化されたノードで終了すると、署名者または創始者の公開鍵のセットも返されます。処理はリーフノードで終了すると、デフォルトの属性値のセットは、CMSで保護されたコンテンツに適用される制約のセットと一緒に返されます。"
    },
    {
      "indent": 3,
      "text": "The output from CMS Content Constraints processing will depend on the type of the leaf node that terminates the CMS path. Four different output variables are possible. The conditions under which each is returned is described in the following sections. The variables are: cms_public_keys is a list of public key values, public key certificates, or public key identifiers. Information maintained in cms_public_keys will be used to perform the certification path operations required to determine if a particular signer or originator is authorized to produce a specific object.",
      "ja": "CMSコンテンツ制約処理からの出力は、CMSパスを終端リーフノードの種類によって異なります。四つの異なる出力変数が可能です。それぞれが返される条件は、以下のセクションに記載されています。変数は次のとおりです。cms_public_keys公開鍵値、公開鍵証明書、または公開鍵識別子のリストです。 cms_public_keysに維持される情報は、特定の署名者または発信者が特定のオブジェクトを生成することを許可されているかどうかを決定するために必要な証明書パス動作を実行するために使用されます。"
    },
    {
      "indent": 3,
      "text": "cms_effective_attributes contains the attributes collected from the nodes in a CMS path. cms_effective_attributes is a SEQUENCE OF Attribute, which is the same as the AttrConstraintList structure except that it may have zero entries in the sequence. An attribute can occur multiple times in the cms_effective_attribute set, potentially with different values.",
      "ja": "cms_effective_attributesは、CMSのパス内のノードから収集された属性が含まれています。 cms_effective_attributesそれが配列にゼロエントリを有することができることを除いAttrConstraintList構造と同じである、属性の配列です。属性には、潜在的に異なる値で、cms_effective_attributeセットに複数回発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "cms_default_attributes contains default attributes derived from message signer or originator authorizations. A default attribute value is taken from a constraint that does not correspond to an attribute contained in the CMS path. cms_default_attributes is a SEQUENCE OF Attribute, which is the same as the AttrConstraintList structure except that it may have zero entries in the sequence.",
      "ja": "cms_default_attributesは、メッセージの署名者または発信者の権限に由来し、デフォルトの属性が含まれています。デフォルト属性値がCMS経路に含まれる属性に対応していない制約から取られます。 cms_default_attributesそれが配列にゼロエントリを有することができることを除いAttrConstraintList構造と同じである、属性の配列です。"
    },
    {
      "indent": 3,
      "text": "cms_constraints contains the constraints associated with the message signer or originator for the content type of the leaf node. cms_constraints is a SEQUENCE OF Attribute, which is the same as the AttrConstraintList structure except that it may have zero entries in the sequence.",
      "ja": "cms_constraintsは、リーフノードのコンテンツタイプのメッセージ署名者又は発信者に関連付けられた制約条件を含んでいます。 cms_constraintsそれが配列にゼロエントリを有することができることを除いAttrConstraintList構造と同じである、属性の配列です。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Collection of Signer or Originator Information",
      "section_title": true,
      "ja": "4.1.1。署名者または発信情報の収集"
    },
    {
      "indent": 3,
      "text": "Signer or originator constraints are identified using the public keys to verify each SignedData, AuthEnvelopedData, or AuthenticatedData layer encountered in a CMS path. The public key value, public key certificate, or public key identifier of each signer or originator are collected in a state variable named cms_public_keys. Constraints are determined by building and validating a certification path for each public key after the content type and attributes of the CMS-protected object have been identified. If the CMS path has no SignedData, AuthEnvelopedData, or AuthenticatedData nodes, CCC processing succeeds and all output variables are set to empty.",
      "ja": "署名者または創始制約はCMSのパスで遭遇それぞれのSignedData、AuthEnvelopedData、またはAuthenticatedData層を検証する公開鍵を使用して識別されます。公開鍵の値、公開鍵証明書、又は各署名者又は発信者の公開鍵識別子が状態変数命名cms_public_keysに収集されます。制約は、コンテンツタイプとCMSで保護されたオブジェクトの属性が識別された後、各公開鍵の証明書パスを構築し、検証することによって決定されます。 CMSのパスが何のSignedData、AuthEnvelopedData、またはAuthenticatedDataノードを持っていない場合は、CCCの処理が成功し、すべての出力変数が空に設定されています。"
    },
    {
      "indent": 3,
      "text": "The signature or MAC generated by the originator MUST be verified. If signature or MAC verification fails, then the CMS path containing the signature or MAC MUST be rejected. Signature and MAC verification procedures are defined in [RFC5652] [RFC5083]. The public key or public key certificate used to verify each signature or MAC in a CMS path is added to the cms_public_keys state variable for use in content type and constraint checking. Additional checks may be performed during this step, such as timestamp verification [RFC3161] and ESSCertId [RFC5035] processing.",
      "ja": "発信元によって生成された署名またはMACが検証されなければなりません。署名やMACの検証が失敗した場合、署名またはMACを含むCMSパスを拒絶しなければなりません。署名及びMAC検証手順は[RFC5652]、[RFC5083]で定義されています。 CMSパス内の各署名またはMACを検証するために使用される公開鍵又は公開鍵証明書は、コンテンツタイプおよび制約チェックで使用するためのcms_public_keys状態変数に追加されます。追加のチェックは、タイムスタンプの検証として、このステップの間に[RFC3161]とESSCertId [RFC5035]の処理を実行することができます。"
    },
    {
      "indent": 0,
      "text": "4.1.1.1. Handling Multiple SignerInfo Elements",
      "section_title": true,
      "ja": "4.1.1.1。複数のSignerInfo要素の処理"
    },
    {
      "indent": 3,
      "text": "CMS content constraints MAY be applied to CMS-protected contents featuring multiple parallel signers, i.e., SignedData contents containing more than one SignerInfo. When multiple SignerInfo elements are present, each may represent a distinct entity or each may represent the same entity via different keys or certificates, e.g., in the event of key rollover or when the entity has been issued certificates from multiple organizations. For simplicity, signers represented by multiple SignerInfos within a single SignedData are not considered to be collaborating with regard to a particular content, unlike signers represented in distinct SignedData contents. Thus, for the purposes of CCC processing, each SignerInfo is treated as if it were the only SignerInfo. A content is considered valid if there is at least one valid CMS path employing one SignerInfo within each SignedData content. Where collaboration is desired, usage of multiple SignedData contents is RECOMMENDED.",
      "ja": "CMSコンテンツ制約は、すなわち、のSignedData内容が複数のSignerInfoを含む複数の並列署名者を、特徴CMS-保護コンテンツに適用することができます。複数のSignerInfo要素が存在する場合、各々が別個のエンティティを表すことができ、またはそれぞれがキーロールオーバまたは複数の組織からのエンティティが発行された証明書の場合には、例えば、異なる鍵または証明書を介して同一のエンティティを表すことができます。簡略化のため、単一のSignedData内の複数SignerInfosで表される署名者は、別個のSignedDataコンテンツで表現署名者とは異なり、特定のコンテンツに関して共同であるとは考えられません。それが唯一のSignerInfoであるかのようにこのように、CCC処理の目的のために、それぞれのSignerInfoが治療されます。それぞれのSignedDataコンテンツ内の1のSignerInfoを採用した少なくとも1つの有効なCMSのパスがある場合、コンテンツが有効であると考えられます。コラボレーションが所望される場合、複数のSignedDataコンテンツの利用が推奨されます。"
    },
    {
      "indent": 3,
      "text": "Though not required by this specification, some applications may require successful processing of all or multiple SignerInfo elements within a single SignedData content. There are a number of potential ways of treating the evaluation process, including the following two possibilities:",
      "ja": "この仕様によって必要とされていないが、一部のアプリケーションは、単一のSignedDataコンテンツ内のすべて、または複数のSignerInfo要素の成功した処理が必要な場合があります。以下の二つの可能性を含め、評価プロセスの治療の潜在的ないくつかの方法があります："
    },
    {
      "indent": 3,
      "text": "- All signatures are meant to be collaborative: In this case, the public keys associated with each SignerInfo are added to the cms_public_keys variable, the attributes from each SignerInfo are added to the cms_effective_attributes variable, and normal processing is performed.",
      "ja": " - すべての署名が共同であることを意味している。この場合、それぞれのSignerInfoに関連付けられた公開鍵はcms_public_keys変数に追加され、それぞれのSignerInfoの属性は、可変cms_effective_attributesに添加し、通常の処理が行われます。"
    },
    {
      "indent": 3,
      "text": "- All signatures are meant to be completely independent: In this case, each of the SignerInfos is processed as if it were a fork in the CMS path construction process. The application may require more than one CMS path to be valid in order to accept a content.",
      "ja": " - すべてのシグネチャは完全に独立であることを意味している：それはCMSパス構築プロセスにおいてフォークであるかのようにこの場合、SignerInfosの各々が処理されます。アプリケーションは、コンテンツを受け入れるために有効であることが、複数のCMSパスが必要な場合があります。"
    },
    {
      "indent": 3,
      "text": "The exact processing will be a matter of application and local policy. See [RFC5752] for an example of an attribute that requires processing multiple SignerInfo elements within a SignedData content.",
      "ja": "正確な処理は、アプリケーションとローカルポリシーの問題になります。 SignedDataコンテンツ内の複数のSignerInfo要素を処理する必要属性の例については[RFC5752]を参照。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Collection of Attributes",
      "section_title": true,
      "ja": "4.1.2。属性のコレクション"
    },
    {
      "indent": 3,
      "text": "Attributes are collected from all authenticated nodes in a CMS path. That is, attributes are not collected from content types that are unauthenticated, i.e., those that are not covered by a SignedData, AuthEnvelopedData, or AuthenticatedData layer. Additionally, an application MAY specify a set of attributes that it has authenticated, perhaps from processing one or more content types that encapsulate a CMS-protected content. Leaf node attributes MAY be checked independent of the CCC processing, but such processing is not addressed in this document. Applications are free to perform further processing using all or some of the attributes returned from CCC processing.",
      "ja": "属性は、CMSのパス内のすべての認証済みのノードから収集されます。つまり、属性が未認証であるコンテンツタイプ、即ち、のSignedData、AuthEnvelopedData、又はAuthenticatedData層によって覆われていないものから収集されていない、です。さらに、アプリケーションは、おそらくCMSで保護されたコンテンツをカプセル化する1つまたは複数のコンテンツタイプを処理することから、それが認証したことを一連の属性を指定するかもしれません。リーフノード属性は、CCCの処理とは独立して確認することもできるが、そのような処理は、本書で扱われていません。アプリケーションはすべて、またはCCCの処理から返された属性の一部を使用して、さらに処理を行うことは自由です。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Leaf Node Classification",
      "section_title": true,
      "ja": "4.1.3。リーフノードの分類"
    },
    {
      "indent": 3,
      "text": "The type of leaf node that terminates a CMS path determines the types of information that are returned and the type of processing that is performed. There are two types of leaf nodes: encrypted leaf nodes and payload leaf nodes.",
      "ja": "CMSパスを終端リーフノードのタイプが返される情報の種類と実行される処理のタイプを決定します。暗号化されたリーフノードとペイロードリーフノード：リーフノードの2種類があります。"
    },
    {
      "indent": 3,
      "text": "A node in a CMS path is a leaf node if the content type of the node is not one of the following content types:",
      "ja": "ノードのコンテンツタイプは、以下の内容のいずれかのタイプではない場合CMSパスのノードがリーフノードであります："
    },
    {
      "indent": 6,
      "text": "id-signedData (SignedData),",
      "ja": "ID-たsignedData（のSignedData）"
    },
    {
      "indent": 6,
      "text": "id-digestedData (DigestedData),",
      "ja": "データ（消化データ）で消化され、"
    },
    {
      "indent": 6,
      "text": "id-ct-authData (AuthenticatedData),",
      "ja": "ID-CT-authData（AuthenticatedData）"
    },
    {
      "indent": 6,
      "text": "id-ct-compressedData (CompressedData),",
      "ja": "ID-CT-compressedData（CompressedData）"
    },
    {
      "indent": 6,
      "text": "id-ct-contentCollection (ContentCollection), or",
      "ja": "ID-CT-contentCollection（ContentCollection）、又は"
    },
    {
      "indent": 6,
      "text": "id-ct-contentWithAttrs (ContentWithAttributes).",
      "ja": "ID-CT-contentWithAttrs（ContentWithAttributes）。"
    },
    {
      "indent": 3,
      "text": "A leaf node is an encrypted leaf node if the content type of the node is one of the following content types:",
      "ja": "ノードのコンテンツタイプは、以下のコンテンツタイプのいずれかである場合にはリーフノードは、暗号化されたリーフノードであります："
    },
    {
      "indent": 6,
      "text": "id-encryptedData (EncryptedData),",
      "ja": "ID-はEncryptedData（はEncryptedData）"
    },
    {
      "indent": 6,
      "text": "id-envelopedData (EnvelopedData), or",
      "ja": "ID-EnvelopedDataの（EnvelopedDataの）、または"
    },
    {
      "indent": 6,
      "text": "id-ct-authEnvelopedData (AuthEnvelopedData).",
      "ja": "ID-CT-authEnvelopedData（AuthEnvelopedData）。"
    },
    {
      "indent": 3,
      "text": "All other leaf nodes are payload leaf nodes, since no further CMS encapsulation can occur beyond that node. However, specifications may define content types that provide protection similar to the CMS content types, may augment the lists of possible leaf and encrypted leaf nodes, or may define some encrypted types as payload leaf nodes.",
      "ja": "それ以上のCMSカプセル化は、そのノードを超えて発生することはできませんので、他のすべてのリーフノードは、ペイロードのリーフノードです。しかし、仕様が可能な葉のリストと暗号化されたリーフノードを増やすことが、CMSのコンテンツタイプに似た保護を提供するコンテンツタイプを定義することができ、またはペイロードリーフノードとして、いくつかの暗号化タイプを定義することができます。"
    },
    {
      "indent": 3,
      "text": "When an encrypted leaf node is encountered, processing terminates and returns information that may be used as input when processing the decrypted contents. Content type and constraints checking are only performed for payload leaf nodes. When an encrypted leaf node terminates a CMS path, the attributes collected in cms_effective_attributes are returned along with the public key information collected in cms_public_keys. When a payload leaf node terminates a CMS path, content type and constraint checking MUST be performed, as described in the next section.",
      "ja": "暗号化された葉ノードに遭遇した場合、処理は終了し、復号されたコンテンツを処理する際の入力として使用することができる情報を返します。コンテンツの種類とチェック制約は、ペイロードのみのリーフノードに対して実行されています。暗号化されたリーフノードは、CMSのパスを終了すると、cms_effective_attributesに収集属性がcms_public_keysに収集した公開鍵情報と一緒に返されます。ペイロードリーフノードがCMSパスを終了すると、次のセクションで説明したように、コンテンツの種類と制約チェックが、実行されなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.2. Content Type and Constraint Checking",
      "section_title": true,
      "ja": "4.2。コンテンツタイプと制約チェック"
    },
    {
      "indent": 3,
      "text": "Content type and constraint checking is performed when a payload leaf node is encountered. This section does not apply to CMS paths that are terminated by an encrypted leaf node nor to CMS paths that have no SignedData, AuthEnvelopedData, or AuthenticatedData nodes.",
      "ja": "ペイロードリーフノードに遭遇した場合、コンテンツタイプと制約チェックが行われます。このセクションでは、暗号化されたリーフノードでも何のSignedData、AuthEnvelopedData、またはAuthenticatedDataノードを持たないCMSパスに終端されているCMSのパスには適用されません。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Inputs",
      "section_title": true,
      "ja": "4.2.1。入力"
    },
    {
      "indent": 3,
      "text": "The inputs to content type and constraint checking are the values collected in cms_public_keys and cms_effective_attributes from a CMS path, along with the payload leaf node that terminates the CMS path, as shown in the figure below.",
      "ja": "コンテンツタイプおよび制約チェックへの入力は以下の図に示すように、CMS経路を終端ペイロードリーフノードとともに、CMS経路からcms_public_keysとcms_effective_attributesに収集された値です。"
    },
    {
      "indent": 3,
      "text": "Inputs\n+ leaf node\n+ cms_public_keys\n+ cms_effective_attributes\n                 |\n                 |\n ________________V_________________________________________\n|                                                          |\n| Content type and constraint checking                     |\n|  (uses CCC-aware Certification Path Processor internally)|\n|__________________________________________________________|\n                 |\n                 |\n                 V\nOutputs upon success\n+ cms_constraints\n+ cms_default_attributes\n+ cms_effective_attributes",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 7. Content Type and Constraint Checking",
      "ja": "図7.コンテンツタイプと制約チェック"
    },
    {
      "indent": 0,
      "text": "4.2.2. Processing",
      "section_title": true,
      "ja": "4.2.2。処理"
    },
    {
      "indent": 3,
      "text": "When a payload leaf node is encountered in a CMS path and a signed or authenticated content type is present in the CMS path, content type and constraint checking MUST be performed. Content type and constraint checking need not be performed for CMS paths that do not contain at least one SignedData, AuthEnvelopedData, or AuthenticatedData content type. The cms_effective_attributes and cms_public_keys variables are used to perform constraint checking.",
      "ja": "ペイロードリーフノードがCMSパスに遭遇し、署名または認証されたコンテンツタイプがCMS経路中に存在する場合、コンテンツタイプおよび制約チェックが実行されなければなりません。コンテンツの種類と制約チェックが少なくとも一つのSignedData、AuthEnvelopedData、またはAuthenticatedDataコンテンツタイプが含まれていないCMSパスに対して実行する必要はありません。 cms_effective_attributesとcms_public_keys変数は、制約のチェックを実行するために使用されています。"
    },
    {
      "indent": 3,
      "text": "Two additional state variables are used during the processing: cms_constraints and cms_default_attributes, both of which are initialized to empty. The steps required to perform content type and constraint checking are below.",
      "ja": "空に初期化され、どちらもcms_constraintsとcms_default_attributes、さらに2つの状態変数は、処理中に使用されています。コンテンツタイプと制約チェックを実行するために必要な手順は以下の通りです。"
    },
    {
      "indent": 3,
      "text": "For each public key in cms_public_keys, build and validate a certification path from a trust anchor to the public key, providing the content type of the payload leaf node and cms_effective_attributes as input. Observe any limitations imposed by intermediate layers. For example, if the SigningCertificateV2 [RFC5035] attribute is used, the certificate identified by the attribute is required to serve as the target certificate.",
      "ja": "cms_public_keysの各公開鍵のために、入力としてペイロードリーフノードとcms_effective_attributesのコンテンツタイプを提供し、公開鍵をトラストアンカーから認証パスを構築し検証します。中間層によって課される制限事項を遵守。 SigningCertificateV2 [RFC5035]属性が使用される場合、例えば、属性によって識別される証明書は、対象証明書として機能するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "o If path validation is successful, add the contents of subject_default_attributes to cms_default_attributes. The subject_constraints variable returned from certification path validation will contain a single entry. If the subject_constraints entry is equal to the special value anyContentType, content type and constraints checking succeeds. If the subject_constraints entry is not equal to the special value anyContentType, for each entry in the attrConstraints field of the entry in subject_constraints,",
      "ja": "パス検証が成功した場合は、O、cms_default_attributesにsubject_default_attributesの内容を追加します。認証パス検証から返される変数subject_constraintsは、単一のエントリが含まれます。 subject_constraintsエントリは特別な値anyContentTypeに等しい場合、コンテンツの種類や制約チェックが成功します。 subject_constraintsエントリがsubject_constraintsのエントリのattrConstraintsフィールドの各エントリのために、特別な値anyContentTypeに等しくない場合、"
    },
    {
      "indent": 6,
      "text": "* If there is an entry in cms_constraints with the same attrType value, add the value from the attrValues entry to the entry in cms_constraints if that value does not already appear.",
      "ja": "*同じATTRTYPE値とcms_constraintsにエントリがある場合は、その値が既に表示されない場合、attrValuesエントリからcms_constraintsのエントリに値を追加します。"
    },
    {
      "indent": 6,
      "text": "* If there is no entry in cms_constraints with the same attrType value, add a new entry to cms_constraints equal to the entry from the attrConstraints field.",
      "ja": "*同じATTRTYPE値とcms_constraintsにエントリがない場合は、attrConstraintsフィールドからエントリに等しいcms_constraintsに新しいエントリを追加します。"
    },
    {
      "indent": 3,
      "text": "o If the value of the canSource field of the entry in the subject_constraints variable for the public key used to verify the signature or MAC closest to the payload leaf node is set to cannotSource, constraints checking fails and the CMS path MUST be rejected.",
      "ja": "署名やMACペイロードのリーフノードに最も近いを検証するために使用される公開鍵のsubject_constraints変数のエントリのcanSourceフィールドの値がcannotSourceに設定されている場合は、O、制約チェックが失敗し、CMSのパスを拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If no valid certification path can be found, constraints checking fails and the CMS path MUST be rejected.",
      "ja": "有効な証明書パスが見つからない場合は、チェック制約が失敗し、CMSのパスを拒絶しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Outputs",
      "section_title": true,
      "ja": "4.2.3。アウトプット"
    },
    {
      "indent": 3,
      "text": "When a payload leaf node is encountered and content type and constraint checking succeeds, return cms_constraints, cms_default_attributes, and cms_effective_attributes for use in leaf node payload processing.",
      "ja": "ペイロードリーフノードに遭遇し、コンテンツタイプと制約チェックが成功した場合、リーフノードペイロード処理で使用するためにcms_constraints、cms_default_attributes、およびcms_effective_attributesを返します。"
    },
    {
      "indent": 3,
      "text": "When an encrypted leaf node is encountered and constraint checking is not performed, return cms_public_keys and cms_effective_attributes for use in continued processing (as described in Section 4.2.1).",
      "ja": "暗号化された葉ノードに遭遇すると、制約のチェックを行わない場合（セクション4.2.1で説明したように）、継続処理に用いるcms_public_keysとcms_effective_attributesを返します。"
    },
    {
      "indent": 3,
      "text": "The cms_effective_attributes list may contain multiple instances of the same attribute type. An instance of an attribute may contain multiple values. Leaf node processing, which might take advantage of these effective attributes, needs to describe the proper handling of this situation. Leaf node processing is described in other documents, and it is expected to be specific to a particular content type.",
      "ja": "cms_effective_attributesリストには、同じ属性タイプの複数のインスタンスが含まれていてもよいです。属性のインスタンスは、複数の値を含めることができます。これらの効果的な属性を利用する可能性があるリーフノードの処理は、このような状況を適切に処理を記述する必要があります。リーフノードの処理は、他の文献に記載され、特定のコンテンツタイプに特異的であることが期待されます。"
    },
    {
      "indent": 3,
      "text": "The cms_default_attributes list may contain attributes with multiple values. Payload processing, which might take advantage of these default attributes, needs to describe the proper handling of this situation. Payload processing is described in other documents, and it is expected to be specific to a particular content type.",
      "ja": "cms_default_attributesリストは、複数の値を持つ属性が含まれていてもよいです。これらのデフォルトの属性を利用する可能性があるペイロード処理は、このような状況を適切に処理を記述する必要があります。ペイロード処理は、他の文献に記載され、特定のコンテンツタイプに特異的であることが期待されます。"
    },
    {
      "indent": 0,
      "text": "5. Subordination Processing in TAMP",
      "section_title": true,
      "ja": "タンパの5劣後処理"
    },
    {
      "indent": 3,
      "text": "TAMP [RFC5934] does not define an authorization mechanism. CCC can be used to authorize TAMP message signers and to delegate TAMP message-signing authority. TAMP requires trust anchors managed by a TAMP message signer to be subordinate to the signer. This section describes subordination processing for CCC extensions of trust anchors contained in a TrustAnchorUpdate message where CCC is used to authorize TAMP messages.",
      "ja": "[RFC5934]を突き固めることは、認可メカニズムを定義していません。 CCCは、TAMPメッセージの署名者を認可するとTAMPメッセージ署名権限を委任するために使用することができます。 TAMPは、署名者に従属するTAMPメッセージ署名者によって管理されるトラストアンカーが必要です。このセクションでは、CCCがTAMPメッセージを認証するために使用されているTrustAnchorUpdateメッセージに含まれるトラストアンカーのCCCの拡張のために劣後処理を記述します。"
    },
    {
      "indent": 3,
      "text": "For a Trust Anchor Update message that is not signed with the apex trust anchor operational public key to be valid, the digital signature MUST be validated using a management trust anchor associated with the id-ct-TAMP-update content type, either directly or via an X.509 certification path originating with an authorized trust anchor. The following subordination checks MUST also be performed as part of validation.",
      "ja": "有効である頂点トラストアンカー動作公開鍵で署名されていないトラストアンカーUpdateメッセージのために、デジタル署名は、直接または経由して、ID-CT-TAMP更新コンテンツタイプに関連付けられた管理トラストアンカーを使用して検証する必要があります認可トラストアンカーに由来X.509証明書パス。次の従属性チェックは、検証の一部として実行されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each Trust Anchor Update message contains one or more individual updates, each of which is used to add, modify, or remove a trust anchor. For each individual update, the constraints of the TAMP message signer MUST be greater than or equal to the constraints of the trust anchor in the update. The constraints of the TAMP message signer and the to-be-updated trust anchor are determined based on the applicable CMS Content Constraints. Specifically, the constraints of the TAMP message signer are determined as described in Section 3, passing the special value id-ct-anyContentType and an empty set of attributes as input; the constraints of the to-be-updated trust anchor are determined as described below. If the constraints of a trust anchor in an update exceed the constraints of the signer, that update MUST be rejected. Each update is considered and accepted or rejected individually without regard to other updates in the TAMP message. The constraints of the to-be-updated trust anchors are determined as follows:",
      "ja": "各トラストアンカーUpdateメッセージは、追加、変更、またはトラストアンカーを削除するために使用され、それぞれが1つの以上の個別の更新プログラムが含まれています。各個々の更新のために、TAMPメッセージ署名者の制約がより大きくまたは更新の信頼アンカーの制約に等しくなければなりません。 TAMPメッセージ署名者との-更新されるトラストアンカーの制約が適用されるCMSのコンテンツの制約に基づいて決定されます。具体的には、TAMPメッセージ署名者の制約は、特別な値Id-CT-anyContentType及び入力などの属性の空のセットを通過する、第3節で説明したように決定されます。後述のように、更新されるトラストアンカーの制約が決定されます。更新中トラストアンカーの制約は署名者の制約を超えた場合は、その更新を拒絶しなければなりません。各アップデートはみなされ、承認またはTAMPメッセージ内の他の更新に関係なく個別に拒否されます。以下のように、更新されトラストアンカーの制約が決定されます。"
    },
    {
      "indent": 3,
      "text": "o If the to-be-updated trust anchor is the subject of an add operation, the constraints are read from the CMSContentConstraints extension of the corresponding trust anchor in the update.",
      "ja": "-更新されるトラストアンカーは、追加操作の対象である場合には、O、制約はアップデートで対応するトラストアンカーのCMSContentConstraints拡張子から読み込まれます。"
    },
    {
      "indent": 3,
      "text": "o If the to-be-updated trust anchor is the subject of a remove operation, the trust anchor is located in the message recipient's trust anchor store using the public key included in the update.",
      "ja": "O-更新するトラストアンカー場合は、トラストアンカーが更新に含まれる公開鍵を使用して、メッセージ受信者のトラストアンカーストアに配置され、削除操作の対象です。"
    },
    {
      "indent": 3,
      "text": "o If the to-be-updated trust anchor is the subject of a change operation, the trust anchor has two distinct sets of constraints that MUST be checked. The trust anchor's pre-change constraints are determined by locating the trust anchor in the message recipient's trust anchor store using the public key included in the update and reading the constraints from the CMSContentConstraints extension in the trust anchor. The trust anchor's post-change constraints are read from the CMSContentConstraints extension of the corresponding TBSCertificateChangeInfo or the TrustAnchorChangeInfo in the update. If the CMSContentConstraints extension is not present, then the trust anchor's post-change constraints are equivalent to the trust anchor's pre-change constraints.",
      "ja": "-更新されるトラストアンカーが変更操作の対象である場合には、O、トラストアンカーをチェックしなければなりません制約の二つの異なるセットがあります。トラストアンカーの変更前の制約がアップデートに含まれる公開鍵を使用して、メッセージ受信者のトラストアンカーストアのトラストアンカーを探し、トラストアンカーでCMSContentConstraints拡張子から制約を読むことによって決定されます。トラストアンカーの変更後の制約はアップデートで対応するTBSCertificateChangeInfoまたはTrustAnchorChangeInfoのCMSContentConstraints拡張子から読み込まれます。 CMSContentConstraints拡張子が存在しない場合、トラストアンカーの変更後の制約は、トラストアンカーの変更前の制約と同等です。"
    },
    {
      "indent": 3,
      "text": "The following steps can be used to determine if a Trust Anchor Update message signer is authorized to manage each to-be-updated trust anchor contained in a Trust Anchor Update message.",
      "ja": "次の手順は、トラストアンカーUpdateメッセージの署名者がトラストアンカーUpdateメッセージに含まれる各-更新するトラストアンカーを管理する権限があるかどうかを判断するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "o The TAMP message signer's CMS Content Constraints are determined as described in Section 3, passing the special value id-ct-anyContentType and an empty set of attributes as input. The message signer MUST be authorized for the Trust Anchor Update message. This can be confirmed using the steps described in Section 4.",
      "ja": "第3節で説明したように、O TAMPメッセージ署名者のCMSコンテンツ制約は特別な値Id-CT-anyContentType及び入力などの属性の空のセットを渡し、決定されます。メッセージの署名者は、トラストアンカーUpdateメッセージを許可しなければなりません。これは、第4節で説明する手順を用いて確認することができます。"
    },
    {
      "indent": 3,
      "text": "o The constraints of each to-be-updated trust anchor in the TAMP message MUST be checked against the message signer's constraints (represented in the message signer's subject_constraints computed above) using the following steps. For change operations, the following steps MUST be performed for the trust anchor's pre-change constraints and the trust anchor's post-change constraints.",
      "ja": "oをTAMPメッセージ内の各へ-更新されるトラストアンカーの制約は、次の手順を使用して（上記の計算されたメッセージの署名者のsubject_constraintsで表される）メッセージの署名者の制約に対してチェックしなければなりません。変更操作の場合は、次の手順では、トラストアンカーの変更前の制約とトラストアンカーの変更後の制約のために実行しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the to-be-updated trust anchor is unconstrained, the message signer MUST also be unconstrained, i.e., the message signer's subject_constraints MUST be set to the special value anyContentType. If the to-be-updated trust anchor is unconstrained and the message signer is not, then the message signer is not authorized to manage the trust anchor and the update MUST be rejected.",
      "ja": "*  - であることを更新トラストアンカーが拘束された場合は、メッセージの署名者も拘束されないでなければならない、すなわち、メッセージの署名者のsubject_constraintsは特別な値anyContentTypeに設定しなければなりません。 -更新されるトラストアンカーが拘束され、メッセージの署名者がない場合は、メッセージの署名者は、トラストアンカーを管理するために許可されていないと更新が拒絶しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* The message signer's authorization for each permitted content type MUST be checked using the state variables and procedures similar to those described in Sections 3.2 and 3.3. For each permitted content type in the to-be-updated trust anchor's constraints,",
      "ja": "*各許可コンテンツタイプのメッセージの署名者の許可は、セクション3.2および3.3に記載のものと同様の状態変数および手順を使用してチェックしなければなりません。それぞれについて、TO--更新されるトラストアンカーの制約にコンテンツタイプを許可"
    },
    {
      "indent": 9,
      "text": "+ Set cms_effective_attributes equal to the value of the attrConstraints field from the permitted content type.",
      "ja": "+許可コンテンツタイプからattrConstraintsフィールドの値に等しいcms_effective_attributesを設定します。"
    },
    {
      "indent": 9,
      "text": "+ If the content type does not match an entry in the message signer's subject_constraints, the message signer is not authorized to manage the trust anchor and the update MUST be rejected. Note, the special value id-ct-anyContentType produces a match for all content types that have the resulting matching entry containing the content type, canSource set to canSource, and attrConstraints absent.",
      "ja": "+コンテンツタイプは、メッセージの署名者のsubject_constraints内のエントリと一致しない場合は、メッセージの署名者は、トラストアンカーを管理するために許可されていないと更新が拒絶しなければなりません。音符、特殊値ID-CT-anyContentTypeは、コンテンツタイプを含む得られた一致するエントリを持つすべてのコンテンツタイプの一致を生成し、canSourceはcanSourceに設定され、attrConstraints存在しません。"
    },
    {
      "indent": 9,
      "text": "+ If the content type matches an entry in the message signer's subject_constraints, the canSource field of the entry is cannotSource, and the canSource field in the to-be-updated trust anchor's privilege is canSource, the message signer is not authorized to manage the trust anchor and the update MUST be rejected.",
      "ja": "コンテンツタイプは、メッセージの署名者のsubject_constraintsのエントリと一致する+場合は、エントリのcanSourceフィールドがcannotSourceある、とに-更新されるトラストアンカーの特権でcanSourceフィールドがcanSourceで、メッセージの署名者は信頼を管理するために許可されていませんアンカーと更新が拒絶しなければなりません。"
    },
    {
      "indent": 9,
      "text": "+ If the content type matches an entry in the message signer's subject_constraints and the entry's attrConstraints field is present, then constraints MUST be checked. For each attrType in the entry's attrConstraints, a corresponding attribute MUST be present in cms_effective_attributes containing values from the entry's attrConstraints. If values appear in the corresponding attribute that are not in the entry's attrConstraints or if there is no corresponding attribute, the message signer is not authorized to manage the trust anchor and the update MUST be rejected.",
      "ja": "+コンテンツタイプは、メッセージの署名者のsubject_constraintsのエントリと一致し、エントリのattrConstraintsフィールドが存在し、その後、制約がチェックされなければならない場合。エントリのattrConstraints各ATTRTYPEために、対応する属性は、エントリのattrConstraintsから値を含むcms_effective_attributes中に存在していなければなりません。値は、エントリのattrConstraintsではないか、または該当する属性が存在しない場合、メッセージの署名者がトラストアンカーを管理するために許可されていないと更新が拒絶しなければなりません、対応する属性に表示された場合。"
    },
    {
      "indent": 3,
      "text": "Once these steps are completed, if the update has not been rejected, then the message signer is authorized to manage the to-be-updated trust anchor.",
      "ja": "これらのステップが完了すると、更新が拒否されていない場合、そのメッセージの署名者は、更新されるトラストアンカーを管理するために許可されています。"
    },
    {
      "indent": 3,
      "text": "Note that a management trust anchor that has only the id-ct-TAMP-update permitted content type is useful only for managing identity trust anchors. It can sign a Trust Anchor Update message, but it cannot impact a management trust anchor that is associated with any other content type.",
      "ja": "唯一のid-CT-TAMP更新は、コンテンツの種類が唯一のアイデンティティトラストアンカーを管理するのに便利です許可した管理トラストアンカーことに注意してください。これは、トラストアンカーUpdateメッセージに署名することができますが、それは他のコンテンツタイプに関連付けられている管理トラストアンカーに影響を与えることはできません。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "For any given certificate, multiple certification paths may exist, and each one can yield different results for CMS content constraints processing. For example, default attributes can change when multiple certification paths exist, as each path can potentially have different attribute requirements or default values.",
      "ja": "任意の所与の証明書のために、複数の証明書パスが存在してもよく、それぞれがCMSコンテンツ制約処理のために異なる結果をもたらすことができます。各パスは、潜在的に異なる属性要件またはデフォルト値を持つことができるように、複数の認証パスが、存在する場合、例えば、デフォルト属性を変更することができます。"
    },
    {
      "indent": 3,
      "text": "Compromise of a trust anchor private key permits unauthorized parties to generate signed messages that will be acceptable to all applications that use a trust anchor store containing the corresponding management trust anchor. For example, if the trust anchor is authorized to sign firmware packages, then the unauthorized private key holder can generate firmware that may be successfully installed and used by applications that trust the management trust anchor.",
      "ja": "信頼の妥協点は、対応する管理トラストアンカーを含むトラストアンカーストアを使用するすべてのアプリケーションには許容されるもので署名されたメッセージを生成するために、秘密鍵の許可に権限のない者をアンカー。トラストアンカーがファームウェアパッケージに署名する権限がある場合たとえば、その後、無許可の秘密鍵ホルダーが正常にインストールおよび管理トラストアンカーを信頼するアプリケーションによって使用されるファームウェアを生成することができます。"
    },
    {
      "indent": 3,
      "text": "For implementations that support validation of TAMP messages using X.509 certificates, it is possible for the TAMP message signer to have more than one possible certification path that will authorize it to sign Trust Anchor Update messages, with each certification path resulting in different CMS Content Constraints. The update is authorized if the processing below succeeds for any one certification path of the TAMP message signer. The resulting subject_constraints variable is used to check each to-be-updated trust anchor contained in the update message.",
      "ja": "TAMPメッセージの署名者が異​​なるCMSのコンテンツが得られた各証明書パスで、トラストアンカー更新メッセージに署名することを認可する複数の可能な証明書パスを持っているため、X.509証明書を使用してTAMPメッセージの検証をサポートする実装のために、それが可能です制約。処理は以下TAMPメッセージ署名者のいずれかの証明書パスのために成功した場合、更新は許可されています。得subject_constraints変数は更新メッセージに含まれる各TO-更新するトラストアンカーを確認するために使用されます。"
    },
    {
      "indent": 3,
      "text": "CMS does not provide a mechanism for indicating that an attribute applies to a particular content within a ContentCollection or a set CMS layers. For the sake of simplicity, this specification collects all attributes that appear in a CMS path. These attributes are processed as part of CCC processing and are made available for use in processing leaf node contents. This can result in a collection of attributes that have no relationship with the leaf node contents.",
      "ja": "CMSは、属性がContentCollection又はセットCMS層内の特定のコンテンツに適用されることを示すためのメカニズムを提供しません。簡略化のために、この仕様はCMSのパスに表示されるすべての属性を収集します。これらの属性は、CCC処理の一部として処理され、リーフノードの内容を処理する際に使用するために利用可能にされます。これは、リーフノードの内容とは関係を持たない属性のコレクションをもたらす可能性があります。"
    },
    {
      "indent": 3,
      "text": "CMS does not provide a means for indicating what element within a CMS message an attribute applies to. For example, a MessageDigest attribute included in a SignedData signedAttributes collection applies to a specific signature, but a Firmware Package Identifier attribute appearing in the same list of attributes describes the encapsulated content. As such, CCC treats all attributes as applying to the encapsulated content type. Care should be taken to avoid provisioning trust anchors or certificates that include constraints on attribute types that are never used to describe a leaf content type, such as a MessageDigest attribute.",
      "ja": "CMSは、属性が適用されるCMSメッセージの中にどのような要素を示すための手段を提供していません。たとえば、するMessageDigest属性は、特定のシグネチャに適用されますが、属性の同じリストに表示されてファームウェアパッケージ識別子属性がカプセル化されたコンテンツを記述SignedDataのsignedAttributesのコレクションに含まれています。このように、CCCは、カプセル化されたコンテンツタイプに適用するようにすべての属性を扱います。ケアは、このようなのMessageDigest属性として葉のコンテンツタイプを記述するために使用されることはありません属性タイプの制約を含み、トラストアンカーまたは証明書をプロビジョニングしないように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "The CMS Constraint Processing algorithm is designed to collect signer information for processing when all information for a CMS path is available. In cases where the certification path discovered during SignedData layer processing is not acceptable, an alternative certification path may be discovered that is acceptable. These alternatives may include an alternative signer certificate. When the ESSCertId attribute is used, alternative signer certificates are not permitted. The certificate referenced by ESSCertId must be used, possibly resulting in failure where alternative certificates would yield success.",
      "ja": "CMS制約処理アルゴリズムは、CMSのパスのすべての情報が利用可能になったときの処理のために、署名者の情報を収集するように設計されています。 SignedData層処理中に発見された証明書パスが許容できない場合には、別の証明書パスは、許容可能であることを発見することができます。これらの選択肢は、代替署名者の証明書を含むことができます。 ESSCertId属性を使用する場合は、代替署名者証明書が許可されていません。 ESSCertIdで参照される証明書は、おそらく、代替の証明書が成功をもたらすであろう不具合が生じ、使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Acknowledgments",
      "section_title": true,
      "ja": "7.謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Jim Schaad for thorough review and many suggestions.",
      "ja": "徹底的な見直しと、多くの提案のためのJim Schaadのおかげ。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3274] Gutmann, P., \"Compressed Data Content Type for Cryptographic Message Syntax (CMS)\", RFC 3274, June 2002.",
      "ja": "[RFC3274] Gutmann氏、P.、 \"暗号メッセージ構文（CMS）のための圧縮されたデータcontent type\"、RFC 3274、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4073] Housley, R., \"Protecting Multiple Contents with the Cryptographic Message Syntax (CMS)\", RFC 4073, May 2005.",
      "ja": "[RFC4073] Housley氏、R.、 \"暗号メッセージ構文（CMS）で複数のコンテンツを保護する\"、RFC 4073、2005年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5083] Housley, R., \"Cryptographic Message Syntax (CMS) Authenticated-Enveloped-Data Content Type\", RFC 5083, November 2007.",
      "ja": "[RFC5083] Housley氏、R.、 \"暗号メッセージ構文（CMS）認証エンベロープ・データコンテンツの種類\"、RFC 5083、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5652] Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70, RFC 5652, September 2009.",
      "ja": "[RFC5652] Housley氏、R.、 \"暗号メッセージ構文（CMS）\"、STD 70、RFC 5652、2009年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5911] Hoffman, P. and J. Schaad, \"New ASN.1 Modules for Cryptographic Message Syntax (CMS) and S/MIME\", RFC 5911, June 2010.",
      "ja": "[RFC5911]ホフマン、P.及びJ. Schaad、 \"暗号メッセージ構文（CMS）とS / MIMEのための新しいASN.1モジュール\"、RFC 5911、2010年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5912] Hoffman, P. and J. Schaad, \"New ASN.1 Modules for the Public Key Infrastructure Using X.509 (PKIX)\", RFC 5912, June 2010.",
      "ja": "[RFC5912]ホフマン、P.およびJ. Schaad、RFC 5912、2010年6月 \"公開鍵インフラストラクチャの使用X.509（PKIX）のための新しいASN.1モジュール\"。"
    },
    {
      "indent": 3,
      "text": "[X.208] \"ITU-T Recommendation X.208 - Specification of Abstract Syntax Notation One (ASN.1)\", 1988.",
      "ja": "[X.208] \"ITU-T勧告X.208  - 抽象構文記法1（ASN.1）の仕様\"、1988。"
    },
    {
      "indent": 3,
      "text": "[X.501] ITU-T Recommendation X.501, \"Information technology - Open Systems Interconnection - The Directory: Models\", ISO/ IEC 9594-2:2005, 2005.",
      "ja": "[X.501] ITU-T勧告X.501、 \"情報技術 - 開放型システム間相互接続 - ディレクトリ：モデル\"、ISO / IEC 9594から2：2005、2005。"
    },
    {
      "indent": 3,
      "text": "[X.680] \"ITU-T Recommendation X.680: Information Technology - Abstract Syntax Notation One\", 2002.",
      "ja": "[X.680] \"ITU-T勧告X.680：情報技術 - 抽象構文記法1\"、2002年。"
    },
    {
      "indent": 3,
      "text": "[X.690] \"ITU-T Recommendation X.690 Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", 2002.",
      "ja": "[X.690] \"ITU-T勧告X.690情報技術 -  ASN.1エンコーディング規則：基本符号化規則（BER）の仕様、Canonicalの符号化規則（CER）、および顕著な符号化規則（DER）\"、2002年。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC3161] Adams, C., Cain, P., Pinkas, D., and R. Zuccherato, \"Internet X.509 Public Key Infrastructure Time-Stamp Protocol (TSP)\", RFC 3161, August 2001.",
      "ja": "[RFC3161]アダムス、C.、カイン、P.、ピンカス、D.、およびR. Zuccherato、 \"インターネットX.509公開鍵インフラストラクチャのタイムスタンププロトコル（TSP）\"、RFC 3161、2001年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4108] Housley, R., \"Using Cryptographic Message Syntax (CMS) to Protect Firmware Packages\", RFC 4108, August 2005.",
      "ja": "[RFC4108] Housley氏、R.、 \"ファームウェアパッケージを保護するために暗号メッセージ構文（CMS）の使用\"、RFC 4108、2005年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5035] Schaad, J., \"Enhanced Security Services (ESS) Update: Adding CertID Algorithm Agility\", RFC 5035, August 2007.",
      "ja": "[RFC5035] Schaad、J.、 \"拡張セキュリティサービス（ESS）更新：CertIDアルゴリズムアジリティを追加\"、RFC 5035、2007年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5272] Schaad, J. and M. Myers, \"Certificate Management over CMS (CMC)\", RFC 5272, June 2008.",
      "ja": "[RFC5272] Schaad、J.とM.マイヤーズ、 \"CMSオーバー証明書の管理（CMC）\"、RFC 5272、2008年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5752] Schaad, J. and S. Turner, \"Multiple Signatures in Cryptographic Message Syntax (CMS)\", December 2009.",
      "ja": "[RFC5752] Schaad、J.及びS.ターナー、2009年12月 \"暗号メッセージ構文（CMS）で複数の署名\"。"
    },
    {
      "indent": 3,
      "text": "[RFC5914] Housley, R., Ashmore, S., and C. Wallace, \"Trust Anchor Format\", RFC 5914, June 2010.",
      "ja": "[RFC5914] Housley氏、R.、アシュモア、S.、およびC.ウォレス、 \"トラストアンカーフォーマット\"、RFC 5914、2010年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5934] Housley, R., Ashmore, S., and C. Wallace, \"Trust Anchor Management Protocol (TAMP)\", RFC 5934, August 2010.",
      "ja": "[RFC5934] Housley氏、R.、アシュモア、S.、およびC.ウォレス、 \"トラストアンカー管理プロトコル（TAMP）\"、RFC 5934、2010年8月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. ASN.1 Modules",
      "ja": "付録A. ASN.1モジュール"
    },
    {
      "indent": 3,
      "text": "Appendix A.1 provides the normative ASN.1 definitions for the structures described in this specification using ASN.1 as defined in [X.680]. Appendix A.2 provides a module using ASN.1 as defined in [X.208]. The module in A.2 removes usage of newer ASN.1 features that provide support for limiting the types of elements that may appear in certain SEQUENCE and SET constructions. Otherwise, the modules are compatible in terms of encoded representation, i.e., the modules are bits-on-the-wire compatible aside from the limitations on SEQUENCE and SET constituents. A.2 is included as a courtesy to developers using ASN.1 compilers that do not support current ASN.1. A.1 references an ASN.1 module from [RFC5912] and [RFC5911].",
      "ja": "付録A.1は[X.680]で定義されるようにASN.1を使用して本明細書に記載した構成のための規範的なASN.1定義を提供します。付録A.2は[X.208]で定義されるようにASN.1を使用してモジュールを提供します。 A.2におけるモジュールは、特定の配列および舞台機構に現れる要素のタイプを制限するためのサポートを提供する新しいASN.1機能の使用を除去します。そうでなければ、モジュール、すなわち、モジュールがビット・オン・ザ・ワイヤSEQUENCEとSET成分の制限は別に互換性がある、符号化された表現の点で互換性があります。 A.2は、現在のASN.1をサポートしていないASN.1コンパイラを使用する開発者への礼儀として含まれています。 A.1は、[RFC5912]及び[RFC5911]からASN.1モジュールを参照します。"
    },
    {
      "indent": 0,
      "text": "A.1. ASN.1 Module Using 1993 Syntax",
      "ja": "A.1。 1993構文を使用したASN.1モジュール"
    },
    {
      "indent": 3,
      "text": "CMSContentConstraintsCertExtn { iso(1) identified-organization(3) dod(6) internet(1) security(5) mechanisms(5) pkix(7) id-mod(0) cmsContentConstr-93(42) }",
      "ja": "CMSContentConstraintsCertExtn {ISO（1）同定された組織（3）DOD（6）インターネット（1）セキュリティ（5）メカニズム（5）PKIX（7）ID-MOD（0）cmsContentConstr-93（42）}"
    },
    {
      "indent": 3,
      "text": "DEFINITIONS IMPLICIT TAGS ::= BEGIN",
      "raw": true
    },
    {
      "indent": 3,
      "text": "IMPORTS EXTENSION, ATTRIBUTE FROM -- from [RFC5912] PKIX-CommonTypes-2009 {iso(1) identified-organization(3) dod(6) internet(1) security(5) mechanisms(5) pkix(7) id-mod(0) id-mod-pkixCommon-02(57)}",
      "ja": "輸入EXTENSION、から属性 -  [RFC5912] PKIX-CommonTypes-2009 {ISO（1）同定された組織（3）DOD（6）インターネット（1）セキュリティ（5）メカニズム（5）PKIX（7）ID-MODから（0）ID-MOD-pkixCommon-02（57）}"
    },
    {
      "indent": 7,
      "text": "CONTENT-TYPE, ContentSet, SignedAttributesSet, ContentType\nFROM  -- from [RFC5911]\n    CryptographicMessageSyntax-2009\n        { iso(1) member-body(2) us(840) rsadsi(113549)\n        pkcs(1) pkcs-9(9) smime(16) modules(0)\n        id-mod-cms-2004-02(41) }\n;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "id-ct-anyContentType ContentType ::=\n    { iso(1) member-body(2)\n      us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16)\n      ct(1) 0 }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ct-Any CONTENT-TYPE ::= {NULL IDENTIFIED BY id-ct-anyContentType }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- -- Add this to CertExtensions in PKIX1Implicit-2009 --",
      "ja": " -   -  PKIX1Implicit-2009でCertExtensionsにこれを追加 - "
    },
    {
      "indent": 3,
      "text": "ext-cmsContentConstraints EXTENSION ::= {\n    SYNTAX         CMSContentConstraints\n    IDENTIFIED BY  id-pe-cmsContentConstraints }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "id-pe-cmsContentConstraints OBJECT IDENTIFIER ::=\n    { iso(1) identified-organization(3) dod(6) internet(1)\n      security(5) mechanisms(5) pkix(7) pe(1) 18 }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "CMSContentConstraints ::= SEQUENCE SIZE (1..MAX) OF\n                          ContentTypeConstraint",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ContentTypeGeneration ::= ENUMERATED  {\n    canSource(0),\n    cannotSource(1)}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ContentTypeConstraint ::= SEQUENCE {\n    contentType           CONTENT-TYPE.&id ({ContentSet|ct-Any,...}),\n    canSource             ContentTypeGeneration DEFAULT canSource,\n    attrConstraints       AttrConstraintList OPTIONAL }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Constraint { ATTRIBUTE:ConstraintList } ::= SEQUENCE {\n    attrType           ATTRIBUTE.\n            &id({ConstraintList}),\n    attrValues         SET SIZE (1..MAX) OF ATTRIBUTE.\n            &Type({ConstraintList}{@attrType})  }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SupportedConstraints ATTRIBUTE ::= {SignedAttributesSet, ... }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "AttrConstraintList ::=\n    SEQUENCE SIZE (1..MAX) OF Constraint {{ SupportedConstraints }}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "END",
      "ja": "終わり"
    },
    {
      "indent": 0,
      "text": "A.2. ASN.1 Module Using 1988 Syntax",
      "ja": "A.2。 1988構文を使用したASN.1モジュール"
    },
    {
      "indent": 3,
      "text": "CMSContentConstraintsCertExtn-88 { iso(1) identified-organization(3) dod(6) internet(1) security(5) mechanisms(5) pkix(7) id-mod(0) cmsContentConstr-88(41) }",
      "ja": "CMSContentConstraintsCertExtn-88 {ISO（1）同定された組織（3）DOD（6）インターネット（1）セキュリティ（5）メカニズム（5）PKIX（7）ID-MOD（0）cmsContentConstr-88（41）}"
    },
    {
      "indent": 3,
      "text": "DEFINITIONS IMPLICIT TAGS ::=\nBEGIN",
      "raw": true
    },
    {
      "indent": 3,
      "text": "IMPORTS AttributeType, AttributeValue FROM PKIX1Explicit88 -- from [RFC5280] { iso(1) identified-organization(3) dod(6) internet(1) security(5) mechanisms(5) pkix(7) id-mod(0) id-pkix1-explicit(18) } ;",
      "ja": "PKIX1Explicit88からの輸入AttributeTypeで、AttributeValueの -  [RFC5280] {ISO（1）同定された組織（3）DOD（6）インターネット（1）セキュリティ（5）メカニズム（5）PKIX（7）ID-MOD（0）IDから-pkix1、明示的な（18）}。"
    },
    {
      "indent": 3,
      "text": "id-ct-anyContentType OBJECT IDENTIFIER ::=\n    { iso(1) member-body(2)\n      us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16)\n      ct(1) 0}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- Extension object identifier",
      "ja": " - 拡張オブジェクト識別子"
    },
    {
      "indent": 3,
      "text": "id-pe-cmsContentConstraints OBJECT IDENTIFIER ::=\n    { iso(1) identified-organization(3) dod(6) internet(1)\n      security(5) mechanisms(5) pkix(7) pe(1) 18 }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- CMS Content Constraints Extension",
      "ja": " -  CMSコンテンツ制約拡張"
    },
    {
      "indent": 3,
      "text": "CMSContentConstraints ::= SEQUENCE SIZE (1..MAX) OF\n                          ContentTypeConstraint",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ContentTypeGeneration ::= ENUMERATED  {\n    canSource(0),\n    cannotSource(1)}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ContentTypeConstraint ::= SEQUENCE {\n    contentType           OBJECT IDENTIFIER,\n    canSource             ContentTypeGeneration DEFAULT canSource,\n    attrConstraints       AttrConstraintList OPTIONAL }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "AttrConstraintList ::= SEQUENCE SIZE (1..MAX) OF AttrConstraint",
      "raw": true
    },
    {
      "indent": 3,
      "text": "AttrConstraint ::= SEQUENCE {\n    attrType               AttributeType,\n    attrValues             SET SIZE (1..MAX) OF AttributeValue }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "END",
      "ja": "終わり"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Russ Housley Vigil Security, LLC 918 Spring Knoll Drive Herndon, VA 20170",
      "ja": "ラスHousleyビジルセキュリティ、LLC 918春小山Driveハーンドン、VA 20170"
    },
    {
      "indent": 3,
      "text": "EMail: housley@vigilsec.com",
      "ja": "メールアドレス：housley@vigilsec.com"
    },
    {
      "indent": 3,
      "text": "Sam Ashmore National Security Agency Suite 6751 9800 Savage Road Fort Meade, MD 20755",
      "ja": "サム・アシュモア国家安全保障局（NSA）のスイート6751 9800サベージ道路フォートミード、MD 20755"
    },
    {
      "indent": 3,
      "text": "EMail: srashmo@radium.ncsc.mil",
      "ja": "メールアドレス：srashmo@radium.ncsc.mil"
    },
    {
      "indent": 3,
      "text": "Carl Wallace Cygnacom Solutions Suite 5400 7925 Jones Branch Drive McLean, VA 22102",
      "ja": "カール・ウォレスCygnacomソリューションスイート5400 7925ジョーンズ支店ドライブマクリーン、VA 22102"
    },
    {
      "indent": 3,
      "text": "EMail: cwallace@cygnacom.com",
      "ja": "メールアドレス：cwallace@cygnacom.com"
    }
  ]
}