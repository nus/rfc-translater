{
  "title": {
    "text": "RFC 6709 - Design Considerations for Protocol Extensions",
    "ja": "RFC 6709 - プロトコル拡張のための設計上の考慮事項"
  },
  "number": 6709,
  "created_at": "2019-10-29 12:36:07.619165+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Architecture Board (IAB)                           B. Carpenter\nRequest for Comments: 6709                                 B. Aboba, Ed.\nCategory: Informational                                      S. Cheshire\nISSN: 2070-1721                                           September 2012",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Design Considerations for Protocol Extensions",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document discusses architectural issues related to the extensibility of Internet protocols, with a focus on design considerations. It is intended to assist designers of both base protocols and extensions. Case studies are included. A companion document, RFC 4775 (BCP 125), discusses procedures relating to the extensibility of IETF protocols.",
      "ja": "この文書では、設計上の考慮事項に焦点を当てた、インターネット・プロトコルの拡張性に関連したアーキテクチャの問題について説明します。基本プロトコルと拡張の両方の設計者を支援するためのものです。ケーススタディが含まれています。仲間ドキュメント、RFC 4775（BCP 125）は、IETFプロトコルの拡張に関連する手順を説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Architecture Board (IAB) and represents information that the IAB has deemed valuable to provide for permanent record. It represents the consensus of the Internet Architecture Board (IAB). Documents approved for publication by the IAB are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットアーキテクチャ委員会（IAB）の製品であり、IABは、永久的な記録を提供するために貴重なものとみなされたことの情報を表します。これは、インターネットアーキテクチャ委員会（IAB）のコンセンサスを表しています。 IABによって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6709.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6709で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2012 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Requirements Language ......................................4\n2. Routine and Major Extensions ....................................4\n   2.1. What Constitutes a Major Extension? ........................4\n   2.2. When is an Extension Routine? ..............................6\n3. Architectural Principles ........................................7\n   3.1. Limited Extensibility ......................................7\n   3.2. Design for Global Interoperability .........................8\n   3.3. Architectural Compatibility ...............................12\n   3.4. Protocol Variations .......................................13\n   3.5. Testability ...............................................16\n   3.6. Protocol Parameter Registration ...........................16\n   3.7. Extensions to Critical Protocols ..........................17\n4. Considerations for the Base Protocol ...........................18\n   4.1. Version Numbers ...........................................19\n   4.2. Reserved Fields ...........................................22\n   4.3. Encoding Formats ..........................................23\n   4.4. Parameter Space Design ....................................23\n   4.5. Cryptographic Agility .....................................26\n   4.6. Transport .................................................27\n   4.7. Handling of Unknown Extensions ............................28\n5. Security Considerations ........................................29\n6. References .....................................................30\n   6.1. Normative References ......................................30\n   6.2. Informative References ....................................30\n7. Acknowledgments ................................................35\n8. IAB Members at the Time of Approval ............................35\nAppendix A.  Examples .............................................36\n   A.1. Already-Documented Cases ..................................36\n   A.2. RADIUS Extensions .........................................36\n   A.3. TLS Extensions ............................................39\n   A.4. L2TP Extensions ...........................................41",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "When developing protocols, IETF Working Groups (WGs) often include mechanisms whereby these protocols can be extended in the future. It is often a good principle to design extensibility into protocols; as described in \"What Makes for a Successful Protocol\" [RFC5218], a \"wildly successful\" protocol is one that becomes widely used in ways not originally anticipated. Well-designed extensibility mechanisms facilitate the evolution of protocols and help make it easier to roll out incremental changes in an interoperable fashion. However, at the same time, experience has shown that extensions carry the risk of unintended consequences, such as interoperability issues, operational problems, or security vulnerabilities.",
      "ja": "プロトコルを開発する際に、IETFワーキンググループ（のWG）は、多くの場合、これらのプロトコルは、将来的に拡張することができるメカニズムを含みます。多くの場合、プロトコルへの拡張を設計するための良い原則です。 [RFC5218]「成功プロトコルのために作るもの」で説明したように、「乱暴に成功した」プロトコルが広く当初の予想ではない方法で使用される状態になるものです。うまく設計された拡張メカニズムは、プロトコルの進化を促進し、それが簡単に相互運用可能な方法で増分変更をロールアウトするのに役立ちます。しかし、同時に、経験は拡張子は、このような相互運用性の問題、操作上の問題、またはセキュリティ上の脆弱性などの意図しない結果のリスクを運ぶことが示されています。"
    },
    {
      "indent": 3,
      "text": "The proliferation of extensions, even well-designed ones, can be costly. As noted in \"Simple Mail Transfer Protocol\" [RFC5321] Section 2.2.1:",
      "ja": "拡張子の増殖、でもうまく設計されたものは、コストがかかります。 「簡易メール転送プロトコル」で述べたように、[RFC5321]セクション2.2.1："
    },
    {
      "indent": 6,
      "text": "Experience with many protocols has shown that protocols with few options tend towards ubiquity, whereas protocols with many options tend towards obscurity.",
      "ja": "多くのプロトコルでの経験は、多くのオプションを持つプロトコルが曖昧に向かう傾向があるのに対し、いくつかのオプションを持つプロトコルは、ユビキタスに向けて傾向があることを示しています。"
    },
    {
      "indent": 6,
      "text": "Each and every extension, regardless of its benefits, must be carefully scrutinized with respect to its implementation, deployment, and interoperability costs.",
      "ja": "一人ひとりの拡張は、関係なく、その利点を、慎重にその実装、展開、および相互運用コストに関して精査する必要があります。"
    },
    {
      "indent": 3,
      "text": "This is hardly a recent concern. \"TCP Extensions Considered Harmful\" [RFC1263] was published in 1991. \"Extend\" or \"extension\" occurs in the title of more than 400 existing Request for Comments (RFC) documents. Yet, generic extension considerations have not been documented previously.",
      "ja": "これはほとんどの最近の関心事ではありません。 [RFC1263]「有害と考えられTCP拡張」は、「拡張」または「拡張」1991年に出版されたコメント（RFC）文書のための400以上の既存のリクエストのタイトルに起こります。しかし、一般的な拡張の考慮事項は、以前に文書化されていません。"
    },
    {
      "indent": 3,
      "text": "The purpose of this document is to describe the architectural principles of sound extensibility design, in order to minimize such risks. Formal procedures for extending IETF protocols are discussed in \"Procedures for Protocol Extensions and Variations\" BCP 125 [RFC4775].",
      "ja": "このドキュメントの目的は、そのようなリスクを最小限に抑えるために、音の拡張設計の建築原則を記述することです。 IETFプロトコルを拡張するための正式な手順は、「プロトコルの拡張のための手順およびバリエーション」BCP 125 [RFC4775]に記載されています。"
    },
    {
      "indent": 3,
      "text": "The rest of this document is organized as follows: Section 2 discusses routine and major extensions. Section 3 describes architectural principles for protocol extensibility. Section 4 explains how designers of base protocols can take steps to anticipate and facilitate the creation of such subsequent extensions in a safe and reliable manner. Section 5 discusses security considerations. Appendix A provides case studies.",
      "ja": "このドキュメントの残りは以下の通り構成されています。第2章では、日常と主要な機能拡張について説明します。第3節では、プロトコルの拡張のためのアーキテクチャの原則を説明しています。第4節では、基本プロトコルの設計者は予測し、安全で信頼性の高い方法でそのようなその後の拡張の作成を容易にするための措置をとることができます方法について説明します。第5節では、セキュリティ上の考慮事項について説明します。付録Aは、ケーススタディを提供します。"
    },
    {
      "indent": 3,
      "text": "Readers are advised to study the whole document, since the considerations are closely linked.",
      "ja": "配慮が密接にリンクされているので、読者は、文書全体を検討することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in \"Key words for use in RFCs to Indicate Requirement Levels\" BCP 14 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります「要求レベルを示すためのRFCsにおける使用のためのキーワード」BCP 14 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Routine and Major Extensions",
      "section_title": true,
      "ja": "2.ルーチンとの主な拡張機能"
    },
    {
      "indent": 3,
      "text": "The risk of unintended consequences from an extension is especially high if the extension is performed by a different team than the original designers, who may stray outside implicit design constraints or assumptions. As a result, it is highly desirable for the original designers to articulate the design constraints and assumptions, so as to enable extensions to be done carefully and with a full understanding of the base protocol, existing implementations, and current operational practice.",
      "ja": "拡張子は暗黙の設計上の制約や仮定の外に外れることがあり、元デザイナー、より異なるチームによって行われた場合に延長からの意図しない結果の危険性が特に高いです。オリジナルの設計者が設計上の制約と仮定を明確にするために慎重かつ基本プロトコル、既存の実装、および現在の動作の練習を完全に理解した上で行うことへの拡張を可能にするようにその結果、それは、非常に望ましいです。"
    },
    {
      "indent": 3,
      "text": "To assist extension designers and reviewers, protocol documents should provide guidelines explaining how extensions should be performed, and guidance on how protocol extension mechanisms should be used.",
      "ja": "延長デザイナーや査読を支援するために、プロトコルドキュメントは、プロトコル拡張メカニズムを使用すべきかの拡張が行われるべきかを説明するガイドライン、およびガイダンスを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Protocol components that are designed with the specific intention of allowing extensibility should be clearly identified, with specific and complete instructions on how to extend them. This includes the process for adequate review of extension proposals: do they need community review, and if so, how much and by whom?",
      "ja": "拡張性を可能にする特定の意図を持って設計されたプロトコルコンポーネントは、明らかにそれらを拡張する方法について具体的かつ詳細な手順で、特定されるべきです。これは、拡張の提案を十分に検討するためのプロセスが含まれています。彼らはコミュニティの見直しが必要で、そうであれば、どのくらい、誰でいますか？"
    },
    {
      "indent": 3,
      "text": "The level of review required for protocol extensions will typically vary based on the nature of the extension. Routine extensions may require minimal review, while major extensions may require wide review. Guidance on which extensions may be considered 'routine' and which ones are 'major' is provided in the sections that follow.",
      "ja": "プロトコル拡張のために必要な審査のレベルは、典型的には、延長の性質に基づいて変化します。主要な機能拡張が広い見直しが必要になる場合がありながら、日常の拡張機能は、最小限の見直しが必要な場合があります。拡張子が「日常」とみなされると、どれが「主要な」が、以下のセクションで提供された上で指導。"
    },
    {
      "indent": 0,
      "text": "2.1. What Constitutes a Major Extension?",
      "section_title": true,
      "ja": "2.1。何が主な拡張を構成していますか？"
    },
    {
      "indent": 3,
      "text": "Major extensions may have characteristics leading to a risk of interoperability failures, security vulnerabilities, or operational problems. Where these characteristics are present, it is necessary to pay close attention to backward compatibility with implementations and deployments of the unextended protocol and to the potential for inadvertent introduction of security or operational exposures.",
      "ja": "主な機能拡張は、相互運用性の障害、セキュリティの脆弱性、または運用上の問題のリスクにつながる特性を有していてもよいです。これらの特性が存在する場合、伸長していないプロトコルの実装と展開をし、セキュリティや運用エクスポージャーの不注意な導入のための潜在的に、下位互換性に細心の注意を払う必要があります。"
    },
    {
      "indent": 3,
      "text": "Extension designers should examine their design for the following issues:",
      "ja": "拡張設計者は、次の問題のための設計を検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Modifications or extensions to the underlying protocol. An extension document should be considered to update the underlying protocol specification if an implementation of the underlying protocol would need to be updated to accommodate the extension. This should not be necessary if the underlying protocol was designed with a modular interface. Examples of extensions modifying the underlying protocol include specification of additional transports (see Section 4.6), changing protocol semantics, or defining new message types that may require implementation changes in existing and deployed implementations of the protocol, even if they do not want to make use of the new functions. A base protocol that does not uniformly permit \"silent discard\" of unknown extensions may automatically enter this category, even for apparently minor extensions. Handling of \"unknown\" extensions is discussed in more detail in Section 4.7.",
      "ja": "基礎となるプロトコル1.変更または拡張。拡張ドキュメントは、基本的なプロトコルの実装が拡張に対応するために更新する必要があるならば、基礎となるプロトコル仕様を更新するために考慮されるべきです。基本的なプロトコルは、モジュール式のインタフェースを使用して設計された場合、これは必要ありません。基本的なプロトコルを変更する機能拡張の例としては、彼らが使用することを望んでいない場合でも、プロトコルのセマンティクスを変更、またはプロトコルの既存および展開の実装における実装の変更を必要とするかもしれない新しいメッセージタイプを定義する、（4.6節を参照）、追加のトランスポートの仕様を含みます新機能の。未知の拡張子の均一許可証「サイレント破棄」は自動的にさえ明らかにマイナーな拡張のために、このカテゴリーに入ることはありません基本プロトコル。 「不明」の拡張子の取り扱いは、4.7節で詳しく説明されています。"
    },
    {
      "indent": 3,
      "text": "2. Changes to the basic architectural assumptions. This may include architectural assumptions that are explicitly stated or those that have been assumed by implementers. For example, this would include adding a requirement for session state to a previously stateless protocol.",
      "ja": "基本的なアーキテクチャの仮定2.変更。これは、建築明示的に記述されている仮定や実装が想定されたものを含むことができます。例えば、これは以前にステートレスプロトコルにセッション状態の要件を追加することが挙げられるであろう。"
    },
    {
      "indent": 3,
      "text": "3. New usage scenarios not originally intended or investigated. This can potentially lead to operational difficulties when deployed, even in cases where the \"on-the-wire\" format has not changed. For example, the level of traffic carried by the protocol may increase substantially, packet sizes may increase, and implementation algorithms that are widely deployed may not scale sufficiently or otherwise be up to the new task at hand. For example, a new DNS Resource Record (RR) type that is too big to fit into a single UDP packet could cause interoperability problems with existing DNS clients and servers. Similarly, the additional traffic that results from an extension to a routing protocol could have a detrimental impact on the performance or stability of implementations that do not implement the extension.",
      "ja": "3.新しい利用シナリオは、本来意図か検討していません。展開されたときにこれが潜在的にも、「オン・ザ・ワイヤー」形式が変更されていない場合には、操作が困難になることができます。例えば、プロトコルによって運ばれるトラフィックのレベルは、パケットサイズが増加し得る、広く展開されている実装アルゴリズムは十分にスケールまたはそうでなければ手で新たなタスクまでではないかもしれないが、実質的に増加させることができます。たとえば、新しいDNSリソースレコード（RR）は、それが既存のDNSクライアントとサーバとの相互運用性の問題を引き起こす可能性があり、単一のUDPパケットに収まるには大きすぎると入力します。同様に、ルーティングプロトコルの拡張から生じる追加のトラフィックは、拡張機能を実装しない実装の性能や安定性に有害な影響を有することができます。"
    },
    {
      "indent": 3,
      "text": "4. Changes to the extension model. Adverse impacts are very likely if the base protocol contains an extension mechanism and the proposed extension does not fit into the model used to create and define that mechanism. Extensions that have the same properties as those that were anticipated when an extension mechanism was devised are much less likely to be disruptive than extensions that don't fit the model. Also, changes to the extension model itself (including changes limiting further extensibility) can create interoperability problems.",
      "ja": "拡張モデルへの変更4。基本プロトコルは、拡張メカニズムが含まれており、提案拡張子が作成し、そのメカニズムを定義するために使用されるモデルに適合しない場合は有害な影響は非常に可能性があります。拡張機構が考案された際に予想されたものと同じ性質を持っている拡張機能は、はるかに少ないモデルに適合していない拡張子より破壊的である可能性が高いです。また、相互運用性の問題を作成することができます（さらに拡張性を制限する変更を含む）拡張モデル自体に変わります。"
    },
    {
      "indent": 3,
      "text": "5. Changes to protocol syntax. Changes to protocol syntax bring with them the potential for backward-compatibility issues. If at all possible, extensions should be designed for compatibility with existing syntax, so as to avoid interoperability failures.",
      "ja": "プロトコル構文5.変更。プロトコル構文への変更は、彼らとの下位互換性の問題の可能性をもたらします。可能であれば、相互運用性の障害を避けるために、拡張は、既存の構文との互換性のために設計されなければなりません。"
    },
    {
      "indent": 3,
      "text": "6. Interrelated extensions to multiple protocols. A set of interrelated extensions to multiple protocols typically carries a greater danger of interoperability issues or incompatibilities than a simple extension. Consequently, it is important that such proposals receive earlier and more in-depth review than unitary extensions.",
      "ja": "複数のプロトコルへ6.相互関連の拡張機能。複数のプロトコルを相互に拡張セットは、通常、単純な拡張よりも相互運用性の問題や非互換性のより大きな危険を運びます。したがって、そのような提案は、単一の拡張よりレビューの深い早く、より受け取ることが重要です。"
    },
    {
      "indent": 3,
      "text": "7. Changes to the security model. Changes to the protocol security model (or even addition of new security mechanisms within an existing framework) can introduce security vulnerabilities or adversely impact operations. Consequently, it is important that such proposals undergo security as well as operational review. Security considerations are discussed in Section 5.",
      "ja": "セキュリティモデル7.変更。プロトコルセキュリティモデル（または既存の枠組みの中で、新たなセキュリティメカニズムのも添加）への変更は、セキュリティの脆弱性や悪衝撃操作を導入することができます。したがって、そのような提案は、セキュリティだけでなく、運用審査を受けることが重要です。セキュリティの考慮事項は、第5節で議論されています。"
    },
    {
      "indent": 3,
      "text": "8. Performance impact. An extension that impacts performance can have adverse consequences, particularly if the performance of existing deployments is affected.",
      "ja": "8.パフォーマンスへの影響。延長に影響を与えるのパフォーマンスは、既存の展開のパフォーマンスが影響を受けている場合は特に、不利な結果をもたらすことができます。"
    },
    {
      "indent": 0,
      "text": "2.2. When is an Extension Routine?",
      "section_title": true,
      "ja": "2.2。ときに拡張ルーチンがありますか？"
    },
    {
      "indent": 3,
      "text": "An extension may be considered 'routine' if it does not meet the criteria for being considered a 'major' extension and if its handling is opaque to the protocol itself (e.g., does not substantially change the pattern of messages and responses). For this to apply, no changes to the base protocol can be required, nor can changes be required to existing and currently deployed implementations, unless they make use of the extension. Furthermore, existing implementations should not be impacted. This typically requires that implementations be able to ignore 'routine' extensions without ill effects.",
      "ja": "それは主要な」拡張検討され、その取り扱いがプロトコル自体に不透明である場合（例えば、実質的にメッセージと応答のパターンを変更しない）の基準を満たしていない場合は拡張子は「ルーチン」と考えることができます。これを適用するためには、基本プロトコルに変更は必要ありませんすることができ、また彼らは、拡張を利用する場合を除き、缶の変更は、既存および現在配備の実装に必要なこと。さらに、既存の実装に影響してはなりません。これは通常、実装は悪影響なしに「日常」の拡張子を無視することができることが必要です。"
    },
    {
      "indent": 3,
      "text": "Examples of routine extensions include the Dynamic Host Configuration Protocol (DHCP) vendor-specific option [RFC2132], Remote Authentication Dial In User Service (RADIUS) Vendor-Specific Attributes [RFC2865], the enterprise Object IDentifier (OID) tree for Management Information Base (MIB) modules, and vendor Multipurpose Internet Mail Extension (MIME) types. Such extensions can safely be made with minimal discussion.",
      "ja": "ルーチンの拡張機能の例としては、管理情報ベースの動的ホスト構成プロトコル（DHCP）ベンダー固有のオプション[RFC2132]、ユーザサービスにおけるリモート認証ダイヤル（RADIUS）ベンダー固有の属性[RFC2865]、エンタープライズオブジェクト識別子（OID）ツリーを含めます（MIB）モジュール、およびベンダー多目的インターネットメール拡張（MIME）タイプ。このような拡張は安全に最小限の議論を行うことができます。"
    },
    {
      "indent": 3,
      "text": "Processes that allow routine extensions with minimal or no review (such as \"First Come First Served\" (FCFS) allocation [RFC5226]) should be used sparingly. In particular, they should be limited to cases that are unlikely to result in interoperability problems or in security or operational exposures.",
      "ja": "最小限または全く口コミをルーチンの拡張が可能プロセス（例えば、「まず第一に役立っ是非」としては、（FCFS）の割り当ては、[RFC5226]）を慎重に使用する必要があります。特に、それらは相互運用性の問題やセキュリティや運用エクスポージャーになりそうにない場合に限定すべきです。"
    },
    {
      "indent": 3,
      "text": "Experience has shown that even routine extensions may benefit from review by experts. For example, even though DHCP carries opaque data, defining a new option using completely unstructured data may lead to an option that is unnecessarily hard for clients and servers to process.",
      "ja": "経験も、ルーチンの拡張機能は、専門家による検討から利益を得ることができることを示しています。たとえば、DHCPが不透明なデータを運ぶにもかかわらず、完全に非構造化データを使用して、新しいオプションを定義するクライアントおよび処理するためのサーバーのために懸命に不必要である選択肢につながる可能性があります。"
    },
    {
      "indent": 0,
      "text": "3. Architectural Principles",
      "section_title": true,
      "ja": "3.建築の原則"
    },
    {
      "indent": 3,
      "text": "This section describes basic principles of protocol extensibility:",
      "ja": "このセクションでは、プロトコル拡張性の基本原則を説明します。"
    },
    {
      "indent": 3,
      "text": "1. Extensibility features should be limited to what is reasonably anticipated when the protocol is developed.",
      "ja": "1.拡張機能は、プロトコルが開発されると合理的に予想されるものに限定されるべきです。"
    },
    {
      "indent": 3,
      "text": "2. Protocol extensions should be designed for global interoperability.",
      "ja": "2.プロトコル拡張は、グローバルな相互運用性のために設計されなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. Protocol extensions should be architecturally compatible with the base protocol.",
      "ja": "3.プロトコルの拡張は、ベースプロトコルアーキテクチャ適合性であるべきです。"
    },
    {
      "indent": 3,
      "text": "4. Protocol extension mechanisms should not be used to create incompatible protocol variations.",
      "ja": "4.プロトコル拡張メカニズムは、互換性のないプロトコルのバリエーションを作成するために使用すべきではありません。"
    },
    {
      "indent": 3,
      "text": "5. Extension mechanisms need to be testable.",
      "section_title": true,
      "ja": "5.拡張メカニズムがテスト可能にする必要があります。"
    },
    {
      "indent": 3,
      "text": "6. Protocol parameter assignments need to be coordinated to avoid potential conflicts.",
      "ja": "6.プロトコルパラメータの割り当ては、潜在的な競合を避けるために協調する必要があります。"
    },
    {
      "indent": 3,
      "text": "7. Extensions to critical components require special care. A critical component is one whose failure can lead to Internet-wide reliability and security issues or performance degradation.",
      "ja": "重要なコンポーネントへ7.拡張は、特別な注意が必要です。重要なコンポーネントは、その失敗、インターネット全体の信頼性とセキュリティの問題やパフォーマンスの低下につながることができるものです。"
    },
    {
      "indent": 0,
      "text": "3.1. Limited Extensibility",
      "section_title": true,
      "ja": "3.1。リミテッド拡張"
    },
    {
      "indent": 3,
      "text": "Protocols should not be made more extensible than clearly necessary at inception, in order to enable optimization along dimensions (e.g., bandwidth, state, memory requirements, deployment time, latency, etc.) important to the most common use cases.",
      "ja": "プロトコルは、最も一般的なユースケースに重要な寸法（例えば、帯域幅、状態、メモリ要件、展開時間、待ち時間、等）に沿って最適化を可能にするために、開始時に明らかに必要以上に拡張可能で行われるべきではありません。"
    },
    {
      "indent": 3,
      "text": "The process for defining new extensibility mechanisms should ensure that adequate review of proposed extensions will take place before widespread adoption.",
      "ja": "新しい拡張メカニズムを定義するためのプロセスが提案されている拡張子の十分な検討が広く採用前に行われることを確保すべきです。"
    },
    {
      "indent": 3,
      "text": "As noted in \"What Makes for a Successful Protocol\" [RFC5218], \"wildly successful\" protocols far exceed their original goals, in terms of scale, purpose (being used in scenarios far beyond the initial design), or both. This implies that all potential uses may not be known at inception. As a result, extensibility mechanisms may need to be revisited as additional use cases reveal themselves. However, this does not imply that an initial design needs to take all potential needs into account at inception.",
      "ja": "指摘したように[RFC5218]「何が成功したプロトコルのために作り」で、「乱暴に成功した」プロトコルがはるか（はるか初期設計を越えたシナリオで使用されている）、規模の面で、目的を元の目標を超え、またはその両方。これは、すべての潜在的な用途は、開始時に知られていない可能性があることを意味します。追加のユースケース自体を明らかにする結果として、拡張メカニズムを再考する必要があるかもしれません。しかし、これは初期のデザインは取引開始時のアカウントにすべての潜在的なニーズを行う必要があることを意味するものではありません。"
    },
    {
      "indent": 0,
      "text": "3.2. Design for Global Interoperability",
      "section_title": true,
      "ja": "3.2。グローバル相互運用性のためのデザイン"
    },
    {
      "indent": 3,
      "text": "Section 3.1 of \"Procedures for Protocol Extensions and Variations\" BCP 125 [RFC4775] notes:",
      "ja": "BCP 125 [RFC4775]ノート「プロトコル拡張やバリエーションのための手順」のセクション3.1："
    },
    {
      "indent": 6,
      "text": "According to its Mission Statement [RFC3935], the IETF produces high quality, relevant technical and engineering documents, including protocol standards. The mission statement goes on to say that the benefit of these standards to the Internet \"is in interoperability - that multiple products implementing a standard are able to work together in order to deliver valuable functions to the Internet's users\".",
      "ja": "そのミッションステートメント[RFC3935]によると、IETFは、プロトコル標準を含む高品質、関連する技術とエンジニアリングのドキュメントを生成します。ミッションステートメントは、インターネットへのこれらの規格の利点は、「 - 標準を実装する複数の製品は、インターネットのユーザーに貴重な機能を提供するために一緒に働くことができていること、相互運用性である」と言うことになります。"
    },
    {
      "indent": 6,
      "text": "One consequence of this mission is that the IETF designs protocols for the single Internet. The IETF expects its protocols to work the same everywhere. Protocol extensions designed for limited environments may be reasonable provided that products with these extensions interoperate with products without the extensions. Extensions that break interoperability are unacceptable when products with and without the extension are mixed. It is the IETF's experience that this tends to happen on the Internet even when the original designers of the extension did not expect this to happen.",
      "ja": "このミッションの1つの結果は、IETFは、単一のインターネットのためのプロトコルを設計していることです。 IETFは、そのプロトコルがどこでも同じように動作するように期待しています。限られた環境のために設計されたプロトコル拡張は、これらの拡張子を持つ製品は、拡張なしの製品と相互運用することを合理的に提供することができます。拡張子を持つとなしの製品が混在している場合は、相互運用性を破る拡張が許容されません。拡張の元デザイナーがこれが起こることを期待していなかった場合でも、インターネット上で発生する傾向があることIETFの経験です。"
    },
    {
      "indent": 6,
      "text": "Another consequence of this definition of interoperability is that the IETF values the ability to exchange one product implementing a protocol with another. The IETF often specifies mandatory-to-implement functionality as part of its protocols so that there is a core set of functionality sufficient for interoperability that all products implement. The IETF tries to avoid situations where protocols need to be profiled to specify which optional features are required for a given environment, because doing so harms interoperability on the Internet as a whole.",
      "ja": "この相互運用性の定義の他の結果は、IETFが他とのプロトコルを実装する一つの製品を交換する能力値ということです。すべての製品は、実装の相互運用性のための十分な機能のコアセットがあるように、IETFは、多くの場合、そのプロトコルの一部として実装に必須の機能を指定します。 IETFは、プロトコルがそうすることが、全体として、インターネット上での相互運用性を損なうので、オプション機能は、与えられた環境のために必要とされるかを指定するためにプロファイルされる必要がある状況を回避しようとします。"
    },
    {
      "indent": 3,
      "text": "Since the global Internet is more than a collection of incompatible protocols (or \"profiles\") for use in separate private networks, implementers supporting extensions in shipping products or multi-site experimental usage must assume that systems will need to interoperate on the global Internet.",
      "ja": "グローバルなインターネットは別のプライベートネットワークで使用するために互換性のないプロトコル（または「プロファイル」）の集まり以上のものですので、商品発送やマルチサイト実験使用量の拡張をサポートする実装は、システムがグローバルなインターネット上で相互運用する必要があることを前提としなければなりません。"
    },
    {
      "indent": 3,
      "text": "A key requirement for interoperable extension design is that the base protocol must be well designed for interoperability and that extensions must have unambiguous semantics. Ideally, the protocol mechanisms for extension and versioning should be sufficiently well described that compatibility can be assessed on paper. Otherwise, when two \"private\" or \"experimental\" extensions encounter each other on a public network, unexpected interoperability problems may occur. However, as noted in the Transport Layer Security (TLS) case study (Appendix A.3), it is not sufficient to design extensibility carefully; it also must be implemented carefully.",
      "ja": "相互運用性の拡張設計のための重要な要件は、基本プロトコルがうまく相互運用性のために設計され、拡張子が明確な意味を持たなければならないことをしなければならないということです。理想的には、伸長およびバージョニングのためのプロトコルメカニズムは十分に互換性が紙に評価することができることを説明すべきです。 2「プライベート」または「実験」の拡張機能は、パブリックネットワーク上で相互に遭遇したときにそれ以外の場合は、予想外の相互運用性の問題が発生することがあります。トランスポート層セキュリティ（TLS）ケーススタディ（付録A.3）で述べたようにしかし、慎重に拡張性を設計するのに十分ではありません。それはまた、慎重に実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Private Extensions",
      "section_title": true,
      "ja": "3.2.1。プライベート拡張"
    },
    {
      "indent": 3,
      "text": "Experience shows that separate private networks often end up having portable equipment like laptop computers move between them, and networks that were originally envisaged as being separate can end up being connected later.",
      "ja": "経験は、独立したプライベートネットワークは、多くの場合、ラップトップコンピュータは、それらの間を移動するように携帯機器を持ってしまうことを示しており、元々は終わることができ別個のものとして想定されたネットワークは、後に接続されています。"
    },
    {
      "indent": 3,
      "text": "Consider a \"private\" extension installed on a work computer that, being portable, is sometimes connected to networks other than the work network, like a home network or a hotel network. If the \"private\" extension is incompatible with an unextended version of the same protocol, problems will occur.",
      "ja": "ポータブルであること、仕事用のコンピュータにインストールされている「プライベート」の拡張子を考えてみましょう、時々、ホームネットワークやホテルのネットワークのような作業のネットワーク以外のネットワークに接続されています。 「プライベート」の拡張子が同じプロトコルの拡張されていないバージョンと互換性がない場合、問題が発生します。"
    },
    {
      "indent": 3,
      "text": "Similarly, problems can occur if \"private\" extensions conflict with each other. For example, imagine the situation where one site chose to use DHCP [RFC2132] option code 62 for one meaning and a different site chose to use DHCP option code 62 for a completely different, incompatible, meaning. It may be impossible for a vendor of portable computing devices to make a device that works correctly in both environments.",
      "ja": "同様に、問題がお互いにあれば、「プライベート」の拡張機能の競合を発生することがあります。例えば、1つのサイトは完全に異なる、互換性のない、意味については、DHCPオプションコード62を使用することを選択した1つの意味と異なるサイトのDHCP [RFC2132]オプションコード62を使用することを選択した状況を想像してみてください。ポータブルコンピューティングデバイスのベンダーは、両方の環境で正しく動作するデバイスを作ることは不可能かもしれません。"
    },
    {
      "indent": 3,
      "text": "One approach to solving this problem has been to reserve parts of an identifier namespace for \"limited applicability\" or \"site-specific\" use, such as \"X-\" headers in email messages [RFC822] or \"P-\" headers in SIP [RFC3427]. However, as noted in \"Deprecating the \"X-\" Prefix and Similar Constructs in Application Protocols\" [RFC6648], Appendix B:",
      "ja": "この問題を解決する1つの方法は、[電子メールメッセージの[RFC822]またはSIPにおける「P-」ヘッダに「X-」ヘッダとして、「限定された適用性」または「サイト固有の」使用のための識別子の名前空間の一部を予約してきましたRFC3427]。しかし、X-「接頭辞とアプリケーションプロトコルで類似の構築物 『[RFC6648]』廃止」に記載されているように、付録B："
    },
    {
      "indent": 6,
      "text": "The primary problem with the \"X-\" convention is that unstandardized parameters have a tendency to leak into the protected space of standardized parameters, thus introducing the need for migration from the \"X-\" name to a standardized name. Migration, in turn, introduces interoperability issues (and sometimes security issues) because older implementations will support only the \"X-\" name and newer implementations might support only the standardized name. To preserve interoperability, newer implementations simply support the \"X-\" name forever, which means that the unstandardized name has become a de facto standard (thus obviating the need for segregation of the name space into standardized and unstandardized areas in the first place).",
      "ja": "「X-」大会で主要な問題は、標準化されていないパラメータは、このように標準化された名前に「X-」名からの移行の必要性を導入し、標準化されたパラメータの保護された空間に漏れる傾向を持っているということです。古い実装は唯一の「X-」名前と新しい実装をサポートするための移行は、今度は、相互運用性の問題（そして時にはセキュリティ問題を）紹介のみ標準化された名前をサポートする場合があります。相互運用性を維持するには、新しい実装では、単純に標準化されていない名前がデファクトスタンダード（したがって、最初の場所での標準化と標準化されていない領域に名前空間の分離の必要性をなくす）となっていることを意味し、永遠に「X-」名前をサポートしています。"
    },
    {
      "indent": 3,
      "text": "As a result, the notion of \"X-\" headers from the 1982 Internet Message Format standard [RFC822] was removed when the specification was updated in 2001 [RFC2822]. Within SIP, the guidance published in 2002 regarding \"P-\" headers [RFC3427] was deprecated eight years later in Section 4 of the 2010 update [RFC5727]. More generally, as noted in Section 1 of the \"X-\" prefix deprecation document [RFC6648]:",
      "ja": "仕様は2001 [RFC2822]に更新された結果、1982年のインターネットメッセージ形式の標準[RFC822]から「X-」ヘッダの概念を除去しました。 SIPの中で、「P-」ヘッダ[RFC3427]について、2002年に出版さガイダンスは、2010年の更新[RFC5727]のセクション4で8年後に廃止されました。より一般的には、「X-」プレフィックス廃止ドキュメント[RFC6648]のセクション1で述べたように："
    },
    {
      "indent": 6,
      "text": "This document generalizes from the experience of the email and SIP communities by doing the following:",
      "ja": "このドキュメントでは、次の操作を行って、電子メールやSIPコミュニティの経験から一般化："
    },
    {
      "indent": 6,
      "text": "1. Deprecates the \"X-\" convention for newly defined parameters in application protocols, including new parameters for established protocols. This change applies even where the \"X-\" convention was only implicit, and not explicitly provided, such as was done for email in [RFC822].",
      "ja": "1.は確立されたプロトコルのための新たなパラメータを含むアプリケーションプロトコルでは、新たに定義されたパラメータのための「X-」規約を廃止します。この変更は、「X-」大会が唯一の暗黙的だった、と明示的な[RFC822]で、電子メールのために行ったように、提供されない場合であっても適用されます。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Local Use",
      "section_title": true,
      "ja": "3.2.2。ローカルでの使用"
    },
    {
      "indent": 3,
      "text": "Values designated as \"experimental\" or \"local use\" are only appropriate in limited circumstances such as in early implementations of an extension restricted to a single site.",
      "ja": "「実験的」または「ローカル使用」として指定された値は、単一のサイトに限定延長の初期の実装のように限られた状況でのみ適切です。"
    },
    {
      "indent": 3,
      "text": "For example, \"Experimental Values in IPv4, IPv6, ICMPv4, ICMPv6, UDP, and TCP Headers\" [RFC4727] discusses experimental values for IP and transport headers, and \"Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers\" [RFC2474] defines experimental/local use ranges for differentiated services code points.",
      "ja": "[RFC4727]はIPと輸送ヘッダーのための実験値を説明します。例えば、「IPv4の、IPv6の、ICMPv4の、ICMPv6の、UDP、およびTCPヘッダーで実験値」、および「IPv4とIPv6の差別化されたサービス分野（DS分野）の定義ヘッダ」[RFC2474]差別化サービスコードポイントの実験/ローカル用途の範囲を定義します。"
    },
    {
      "indent": 3,
      "text": "Such values should be used with care and only for their stated purpose: experiments and local use. They are unsuitable for Internet-wide use, since they may be used for conflicting purposes and thereby cause interoperability failures. Packets containing experimental or local use values must not be allowed out of the domain in which they are meaningful.",
      "ja": "実験や地元の使用：このような値は注意して、唯一自分の述べられた目的のために使用すべきです。彼らは矛盾する目的で使用することができるため、インターネット全体での使用には適していないことにより、相互運用性の障害を引き起こします。実験的またはローカル使用値を含むパケットは、彼らが意味されたドメインの外に許してはなりません。"
    },
    {
      "indent": 3,
      "text": "Section 1 of \"Assigning Experimental and Testing Numbers Considered Useful\" BCP 82 [RFC3692] provides guidance on the use of experimental code points:",
      "ja": "「役に立つと考えられ割り当て実験とテスト番号」BCP 82 [RFC3692]のセクション1は、実験的なコードポイントの使用に関するガイダンスを提供します。"
    },
    {
      "indent": 6,
      "text": "Numbers in the experimentation range ... are not intended to be used in general deployments or be enabled by default in products or other general releases. In those cases where a product or release makes use of an experimental number, the end user must be required to explicitly enable the experimental feature and likewise have the ability to chose and assign which number from the experimental range will be used for a specific purpose (i.e., so the end user can ensure that use of a particular number doesn't conflict with other on-going uses). Shipping a product with a specific value pre-enabled would be inappropriate and can lead to interoperability problems when the chosen value collides with a different usage, as it someday surely will.",
      "ja": "実験の範囲内の数字は...一般的な展開で使用されることを意図されていないか、または製品や他の一般的なリリースではデフォルトで有効にすること。製品または放出は、実験番号を利用するような場合では、エンドユーザが明示的に実験的な機能を有効にし、同様に実験的範囲からの番号を選択し、割り当てる機能が（特定の目的のために使用されることが要求されなければなりませんつまり、エンドユーザーに）その他の進行中の使用と競合していない特定の番号の利用を確保することができます。特定の値プリ有効にして製品を出荷することは不適切であると、それはいつかきっとれるように選択された値は、異なる用法と衝突したときの相互運用性の問題につながることができます。"
    },
    {
      "indent": 6,
      "text": "From the above, it follows that it would be inappropriate for a group of vendors, a consortia, or another Standards Development Organization to agree among themselves to use a particular value for a specific purpose and then agree to deploy devices using those values. By definition, experimental numbers are not guaranteed to be unique in any environment other than one where the local system administrator has chosen to use a particular number for a particular purpose and can ensure that a particular value is not already in use for some other purpose.",
      "ja": "以上のことから、ベンダーのグループ、コンソーシアム、または別の規格開発機構は、特定の目的のために特定の値を使用して、それらの値を使用してデバイスを展開することに同意して自分たちの中で同意することは不適切であるということになります。定義によると、実験的な数字は、ローカルシステム管理者が特定の目的のために特定の番号を使用することを選択したと特定の値が他の目的のために使用されていないことを確認することができるもの以外の環境で一意であることが保証されていません。"
    },
    {
      "indent": 6,
      "text": "Once an extension has been tested and shown to be useful, a permanent number could be obtained through the normal assignment procedures.",
      "ja": "拡張がテストされ、有用であることが示された後、永久的な数は、通常の割り当て手順によって得ることができます。"
    },
    {
      "indent": 3,
      "text": "However, as noted in Appendix B of the \"X-\" prefix deprecation document [RFC6648], assigning a parameter block for experimental use is only necessary when the parameter pool is limited:",
      "ja": "「X-」プレフィックス廃止ドキュメント[RFC6648]の付録Bで述べたように、パラメータプールが限られている場合しかし、実験用のパラメータ・ブロックを割り当てることが必要なだけです。"
    },
    {
      "indent": 6,
      "text": "\"Assigning Experimental and Testing Numbers Considered Useful\" ... implies that the \"X-\" prefix is also useful for experimental parameters. However, BCP 82 addresses the need for protocol numbers when the pool of such numbers is strictly limited (e.g., DHCP options) or when a number is absolutely required even for purely experimental purposes (e.g., the Protocol field of the IP header). In almost all application protocols that make use of protocol parameters (including email headers, media types, HTTP headers, vCard parameters and properties, URNs, and LDAP field names), the name space is not limited or constrained in any way, so there is no need to assign a block of names for private use or experimental purposes....",
      "ja": "「実験を割り当てると役に立つと考え番号をテストする」...「X-」接頭語はまた、実験パラメータのために有用であることを意味します。しかしながら、プロトコル番号のBCP 82アドレス必要そのような番号のプールは厳密に制限されている（例えば、DHCPオプション）、または数が絶対的にも純粋に実験的な目的のために必要とされる場合（例えば、IPヘッダのプロトコルフィールド）。 （電子メールのヘッダ、メディアタイプ、HTTPヘッダ、vCardのパラメータとプロパティ、URNの、およびLDAPフィールド名を含む）プロトコルパラメータを利用するほぼすべてのアプリケーションプロトコルでは、名前空間が限定されるものではないか、どのような方法で制約、そうあり私的使用や実験目的のために名前のブロックを割り当てる必要はありません...."
    },
    {
      "indent": 6,
      "text": "Therefore, it appears that segregating the parameter space into a standardized area and a unstandardized area has few, if any, benefits and has at least one significant cost in terms of interoperability.",
      "ja": "したがって、標準化された領域にパラメータ空間を分離し、標準化されていない領域があれば、いくつかを持っている利点と相互運用性の面で少なくとも一つの大きなコストを持っていることが表示されます。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Multi-Site Experiments",
      "section_title": true,
      "ja": "3.2.3。マルチサイト実験"
    },
    {
      "indent": 3,
      "text": "Where an experiment is undertaken among a diverse set of experimental sites connected via the global Internet, the use of \"experimental\" or \"local use\" code points is inadvisable. This might include, for example, sites that take a prototype implementation of some protocol and use that both within their site but, importantly, among the full set of other sites interested in that protocol. In such a situation, it is impractical and probably impossible to coordinate the de-confliction of \"experimental\" code points. Section 4.1 of the IANA Considerations guidelines document [RFC5226] notes:",
      "ja": "実験は、世界的なインターネットを介して接続された実験サイトの多様なセットの間で行われる場合、「実験的」または「局所使用」のコードポイントを使用することは得策ではありません。これは、例えば、そのプロトコルに興味を持って他のサイトのフルセットの中で、自分のサイト内ではなく、重要なのはその両方のいくつかのプロトコルのプロトタイプ実装を取り、使用し、サイトが含まれる場合があります。そのような状況では、「実験的」コードポイントのデ競合を調整するために非実用的で、おそらく不可能です。 IANAの考慮事項のガイドラインドキュメント[RFC5226]ノートのセクション4.1："
    },
    {
      "indent": 6,
      "text": "For private or local use ... No attempt is made to prevent multiple sites from using the same value in different (and incompatible) ways.... assignments are not generally useful for broad interoperability. It is the responsibility of the sites making use of the Private Use range to ensure that no conflicts occur (within the intended scope of use).",
      "ja": "プライベートまたはローカルで使用するために...試みは異なる（と互換性のない）方法で同じ値を使用することから、複数のサイトを防ぐために行われていない....割り当ては、一般的に広範な相互運用性のために有用ではありません。それは何の競合が（使用の意図した範囲内で）発生しないことを保証するためにプライベート使用範囲を利用してサイトの責任です。"
    },
    {
      "indent": 3,
      "text": "The Host Identity Protocol (HIP) [RFC5201] and the Locator/ID Separation Protocol [LISP] are examples where a set of experimental sites are collaborating among themselves, but not necessarily in a tightly coordinated way. Both HIP and LISP have dealt with this by having unique non-experimental code points allocated to HIP and LISP, respectively, at the time of publication of their respective Experimental RFCs.",
      "ja": "ホストアイデンティティプロトコル（HIP）[RFC5201]及びロケータ/ ID分離プロトコル[LISP]は実験サイトのセットは必ずしも必要ではないがしっかり協調して、それらの間で協力している例です。 HIPとLISPの両方は、それぞれの実験RFCの出版時に、それぞれ、HIPとLISPに割り当てられた固有の非実験コードポイントを有することによって、これに対処しています。"
    },
    {
      "indent": 0,
      "text": "3.3. Architectural Compatibility",
      "section_title": true,
      "ja": "3.3。建築の互換性"
    },
    {
      "indent": 3,
      "text": "Since protocol extension mechanisms may impact interoperability, it is important that they be architecturally compatible with the base protocol.",
      "ja": "プロトコル拡張メカニズムは相互運用性に影響を与える可能性があるので、それらは、ベースプロトコルアーキテクチャ互換性があることが重要です。"
    },
    {
      "indent": 3,
      "text": "This includes understanding what current implementations do and how a proposed extension will interact with deployed systems. Is it clear when a proposed extension (or its proposed usage), if widely deployed, will operationally stress existing implementations or the underlying protocol itself? If this is not explained in the base protocol specification, is this covered in an extension design guidelines document?",
      "ja": "これは、現在の実装では何をすべきかを理解し、どのように提案した拡張子が展開システムと相互作用するが含まれています。それを明確にされたときに提案拡張子（またはその提案用法）、広く展開されている場合は、ストレス既存の実装を運用しますか基本的なプロトコル自体？これは基本プロトコル仕様で説明されていない場合、これは、拡張設計ガイドライン文書に覆われていますか？"
    },
    {
      "indent": 3,
      "text": "As part of the definition of a new extension, it is important to address whether the extension makes use of features as envisaged by the original protocol designers, or whether a new extension mechanism is being invented. If a new extension mechanism is being invented, then architectural compatibility issues need to be addressed.",
      "ja": "新しい拡張機能の定義の一部として、拡張は、元のプロトコル設計者によって想定されるような機能を使用するか、新しい拡張機構が考案されているかどうかかどうかに対処することが重要です。新しい拡張機構が考案されている場合は、建築互換性の問題に対処する必要があります。"
    },
    {
      "indent": 3,
      "text": "To assist in the assessment of architectural compatibility, protocol documents should provide guidelines explaining how extensions should be performed, and guidance on how protocol extension mechanisms should be used.",
      "ja": "建築互換性の評価を支援するために、プロトコルドキュメントは、プロトコル拡張メカニズムを使用すべきかの拡張が行われるべきかを説明するガイドライン、およびガイダンスを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Protocol components that are designed with the specific intention of allowing extensibility should be clearly identified, with specific and complete instructions on how to extend them. This includes the process for adequate review of extension proposals: do they need community review, and if so, how much and by whom?",
      "ja": "拡張性を可能にする特定の意図を持って設計されたプロトコルコンポーネントは、明らかにそれらを拡張する方法について具体的かつ詳細な手順で、特定されるべきです。これは、拡張の提案を十分に検討するためのプロセスが含まれています。彼らはコミュニティの見直しが必要で、そうであれば、どのくらい、誰でいますか？"
    },
    {
      "indent": 3,
      "text": "Documents relying on extension mechanisms need to explicitly identify the mechanisms being relied upon. For example, a document defining new data elements should not implicitly define new data types or protocol operations without explicitly describing those dependencies and discussing their impact. Where extension guidelines are available, mechanisms need to indicate whether they are compliant with those guidelines and offer an explanation if they are not.",
      "ja": "拡張メカニズムに依存する文書は、明示的に依拠しているメカニズムを特定する必要があります。例えば、新たなデータ要素を定義文書は、暗黙的、明示的にそれらの依存関係を記述し、それらの影響を議論することなく、新たなデータ・タイプまたはプロトコルの操作を定義するべきではありません。延長ガイドラインが利用可能な場合、メカニズムは、彼らがこれらのガイドラインに準拠しているかどうかを示し、そうでない場合の説明を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Examples of documents describing extension guidelines include:",
      "ja": "拡張のガイドラインを記載した文書の例は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. \"Guidelines for Extending the Extensible Provisioning Protocol (EPP)\" [RFC3735], which provides guidelines for use of EPP's extension mechanisms to define new features and object management capabilities.",
      "ja": "1.新しい機能とオブジェクト管理機能を定義するEPPの拡張メカニズムの使用のためのガイドラインを提供する[RFC3735]、「拡張プロビジョニングプロトコル（EPP）を拡張するためのガイドライン」。"
    },
    {
      "indent": 3,
      "text": "2. \"Guidelines for Authors and Reviewers of MIB Documents\" BCP 111 [RFC4181], which provides guidance to protocol designers creating new MIB modules.",
      "ja": "2.新しいMIBモジュールを作成するプロトコル設計者にガイダンスを提供する「MIBドキュメントの著者と査読のためのガイドライン」BCP 111 [RFC4181]を、。"
    },
    {
      "indent": 3,
      "text": "3. \"Guidelines for Authors of Extensions to the Session Initiation Protocol (SIP)\" [RFC4485], which outlines guidelines for authors of SIP extensions.",
      "ja": "3. SIPの拡張機能の作者のためのガイドラインを概説[RFC4485]、「セッション開始プロトコル（SIP）への拡張の著者のためのガイドライン」。"
    },
    {
      "indent": 3,
      "text": "4. \"Considerations for Lightweight Directory Access Protocol (LDAP) Extensions\" BCP 118 [RFC4521], which discusses considerations for designers of LDAP extensions.",
      "ja": "4. LDAP拡張の設計者のための考慮事項について説明BCP 118 [RFC4521]、 \"LDAP（Lightweight Directory Access Protocol）の拡張機能のための考慮事項\"。"
    },
    {
      "indent": 3,
      "text": "5. \"RADIUS Design Guidelines\" BCP 158 [RFC6158], which provides guidelines for the design of attributes used by the Remote Authentication Dial In User Service (RADIUS) protocol.",
      "ja": "5.ユーザーサービス（RADIUS）プロトコルでリモート認証ダイヤルインによって使用される属性の設計のためのガイドラインを提供し、「RADIUS設計ガイドライン」BCP 158 [RFC6158]、。"
    },
    {
      "indent": 0,
      "text": "3.4. Protocol Variations",
      "section_title": true,
      "ja": "3.4。プロトコルのバリエーション"
    },
    {
      "indent": 3,
      "text": "Protocol variations -- specifications that look very similar to the original but don't interoperate with each other or with the original -- are even more harmful to interoperability than extensions. In general, such variations should be avoided. Causes of protocol variations include incompatible protocol extensions, uncoordinated protocol development, and poorly designed \"profiles\".",
      "ja": "プロトコルのバリエーション - 仕様オリジナルに非常によく似ていますが、相互に、または元との相互運用性はありません - さらに有害な拡張よりも相互運用性にあります。一般に、このような変動は避けるべきです。プロトコルの変化の原因は、互換性のないプロトコル拡張、非協調プロトコル開発、および設計が不十分な「プロファイル」が含まれます。"
    },
    {
      "indent": 3,
      "text": "Designing a protocol for extensibility may have the perverse side effect of making it easy to construct incompatible variations. Protocol extension mechanisms should not be used to create incompatible forks in development. An extension may lead to interoperability failures unless the extended protocol correctly supports all mandatory and optional features of the unextended base protocol, and implementations of the base protocol operate correctly in the presence of the extensions. In addition, it is necessary for an extension to interoperate with other extensions.",
      "ja": "拡張性のためのプロトコルを設計することは、互換性のない変化を構築することを容易にするの歪んだ副作用を有することができます。プロトコル拡張メカニズムは、開発中に互換性のないフォークを作成するために使用すべきではありません。拡張プロトコルが正しく伸長していない基本プロトコルのすべての必須およびオプション機能をサポートしており、基本プロトコルの実装は拡張子の存在下で正常に動作しない限り、延長は相互運用性の障害につながる可能性があります。また、他の拡張機能と相互運用するための拡張のために必要です。"
    },
    {
      "indent": 3,
      "text": "As noted in Section 1 of \"Uncoordinated Protocol Development Considered Harmful\" [RFC5704], incompatible forks in development can result from the uncoordinated adaptation of a protocol, parameter, or code point:",
      "ja": "「非協調型プロトコルの開発を考慮した有害」[RFC5704]のセクション1で述べたように、開発中の互換性のないフォークは、プロトコル、パラメータ、またはコードポイントの非協調的適応に起因し得ます。"
    },
    {
      "indent": 6,
      "text": "In particular, the IAB considers it an essential principle of the protocol development process that only one SDO maintains design authority for a given protocol, with that SDO having ultimate authority over the allocation of protocol parameter code-points and over defining the intended semantics, interpretation, and actions associated with those code-points.",
      "ja": "特に、IABは解釈、それだけSDOそのSDOプロトコルパラメータコードポイントの割り当てに対する最終的な権限を有すると意図される意味論を定義する上で、特定のプロトコルのために設計権限を維持するプロトコル開発プロセスの本質的な原理と見なし、それらのコードポイントに関連付けられたアクション。"
    },
    {
      "indent": 3,
      "text": "Note that problems can occur even when one Standards Development Organization (SDO) maintains design authority, if protocol parameter code points are reused. As an example, EAP-FAST [RFC5421][RFC5422] reused previously assigned Extensible Authentication Protocol (EAP) type codes. As described in the IESG note in the EAP-FAST document [RFC5421]:",
      "ja": "プロトコルパラメータのコードポイントが再利用されている場合は、1つの標準開発機構（SDO）は、デザインの権威を維持しても、問題が発生する可能性があることに注意してください。一例として、EAP-FAST [RFC5421]、[RFC5422]に再利用以前に割り当てられた拡張認証プロトコル（EAP）コードを入力します。 EAP-FAST文書[RFC5421]でIESGノートに記載されているように。"
    },
    {
      "indent": 6,
      "text": "The reuse of previously assigned EAP Type Codes is incompatible with EAP method negotiation as defined in RFC 3748.",
      "ja": "RFC 3748で定義されるように以前に割り当てられたEAPタイプコードの再利用はEAPメソッドのネゴシエーションと互換性がありません。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Profiles",
      "section_title": true,
      "ja": "3.4.1。プロファイル"
    },
    {
      "indent": 3,
      "text": "Profiling is a common technique for improving interoperability within a target environment or set of scenarios. Generally speaking, there are two approaches to profiling:",
      "ja": "プロファイリングは、ターゲット環境やシナリオのセット内の相互運用性を向上させるための一般的な技術です。一般的に言って、プロファイリングするには2つの方法があります。"
    },
    {
      "indent": 3,
      "text": "a) Removal or downgrading of normative requirements (thereby creating potential interoperability problems).",
      "ja": "a）は規範的要件（それによって、潜在的な相互運用性の問題を作成する）の除去またはダウングレードを。"
    },
    {
      "indent": 3,
      "text": "b) Elevation of normative requirement levels (such as from a MAY/SHOULD to a MUST). This can be done in order to improve interoperability by narrowing potential implementation choices (such as when the underlying protocol is ill-defined enough to permit non-interoperable yet compliant implementations) or to meet specific operational requirements (such as enabling use of stronger cryptographic mechanisms than those mandated in the specification).",
      "ja": "そのようなMAY / SHOULDからMUSTにとして規定要件レベル（）のb）に昇格。これは、より強力な暗号メカニズムの使用を可能として、または特定の動作要件を満たすように（例えば、基礎となるプロトコルが不明確な非相互運用まだ準拠の実装を可能にするのに十分である場合など）の潜在的な実装の選択肢を（狭くして相互運用性を向上させるために行うことができます仕様で義務付けられたものより）。"
    },
    {
      "indent": 3,
      "text": "While approach a) is potentially harmful, approach b) may be beneficial.",
      "ja": "アプローチA）は潜在的に有害であるが、アプローチb）は有益であり得ます。"
    },
    {
      "indent": 3,
      "text": "In order to avoid interoperability problems when profiled implementations interact with others over the global Internet, profilers need to remain cognizant of the implications of removing normative requirements. As noted in Section 6 of \"Key words for use in RFCs to Indicate Requirement Levels\" [RFC2119], imperatives are to be used with care, and as a result, their removal within a profile is likely to result in serious consequences:",
      "ja": "プロファイルの実装は、グローバルなインターネット上で他の人とやり取りする場合は、相互運用性の問題を回避するために、プロファイラは、規範的要件を取り除くの意味合いを認識したままにする必要があります。 「要件レベルを示すためにRFCsにおける使用のためのキーワード」[RFC2119]のセクション6で述べたように、要請は注意して使用することがあり、その結果、プロファイル内のそれらの除去は、重大な結果につながる可能性があります。"
    },
    {
      "indent": 6,
      "text": "Imperatives of the type defined in this memo must be used with care and sparingly. In particular, they MUST only be used where it is actually required for interoperation or to limit behavior which has potential for causing harm (e.g., limiting retransmissions) For example, they must not be used to try to impose a particular method on implementors where the method is not required for interoperability.",
      "ja": "このメモで定義されたタイプの命令法は注意してと控えめに使用する必要があります。特に、それらは、（例えば、再送信を制限する）例えば、彼らは実装上の特定のメソッドを課すことを試みるために使用されてはならない、それが実際に相互運用のために必要とされる場合にのみ使用しなければならないか、害を及ぼす可能性を持って行動を制限しますこの方法は、相互運用性のために必要とされていません。"
    },
    {
      "indent": 3,
      "text": "As noted in Sections 3 and 4 of the Key Words document [RFC2119], recommendations cannot be removed from profiles without serious consideration:",
      "ja": "キーワードドキュメント[RFC2119]のセクション3と4で述べたように、推奨は重視せずにプロファイルから除去することができません。"
    },
    {
      "indent": 6,
      "text": "[T]here may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.",
      "ja": "[T]ここでは、特定の項目を無視する特定の状況では正当な理由が存在するかもしれないが、完全な含意は異なるコースを選択する前に理解し、慎重に検討しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Even the removal of optional features and requirements can have consequences. As noted in Section 5 of the Key Words document [RFC2119], implementations that do not support optional features still retain the obligation to ensure interoperation with implementations that do:",
      "ja": "オプション機能と要件のさえ除去は結果をもたらすことができます。キーワードドキュメント[RFC2119]のセクション5で述べたように、オプション機能をサポートしない実装はまだやるの実装との相互運用性を確保する義務を保持します。"
    },
    {
      "indent": 6,
      "text": "An implementation which does not include a particular option MUST be prepared to interoperate with another implementation which does include the option, though perhaps with reduced functionality. In the same vein an implementation which does include a particular option MUST be prepared to interoperate with another implementation which does not include the option (except, of course, for the feature the option provides.)",
      "ja": "特定のオプションを含まない実装を低減機能をけれども、おそらく、オプションが含まれています別の実装と相互運用するために準備されなければなりません。同じ静脈内の特定のオプションを含んでい実装オプションが含まれていない別の実装と相互運用するために準備されなければならない（もちろん、オプションが提供する機能のために、除いて）。"
    },
    {
      "indent": 0,
      "text": "3.5. Testability",
      "section_title": true,
      "ja": "3.5。テスト容易性"
    },
    {
      "indent": 3,
      "text": "Experience has shown that it is insufficient merely to specify extensibility and backward compatibility correctly in an RFC. It is also important that implementations respect the compatibility mechanisms; if not, non-interoperable pairs of implementations may arise. The TLS case study (Appendix A.3) shows how important this can be.",
      "ja": "経験は、それがRFCに正しく拡張性と下位互換性を指定するだけでは不十分であることが示されています。実装が互換性メカニズムを尊重することも重要です。ない場合は、実装の非相互運用可能ペアが生じる可能性があります。 TLSのケーススタディ（付録A.3）は、このがいかに重要示しています。"
    },
    {
      "indent": 3,
      "text": "In order to determine whether protocol extension mechanisms have been properly implemented, testing is required. However, for this to be possible, test cases need to be developed. If a base protocol document specifies extension mechanisms but does not utilize them or provide examples, it may not be possible to develop effective test cases based on the base protocol specification alone. As a result, base protocol implementations may not be properly tested, and non-compliant extension behavior may not be detected until these implementations are widely deployed.",
      "ja": "プロトコル拡張メカニズムが適切に実施されているかどうかを決定するために、テストが必要です。しかし、これを可能にするために、テストケースを開発する必要があります。ベースプロトコル文書は、拡張メカニズムを指定するが、それらを利用するか、例を提供していない場合、単独でベースプロトコル仕様に基づいて有効なテストケースを開発することが可能ではないかもしれません。結果として、ベースプロトコル実装が適切に試験されないこと、及びこれらの実装が広く展開されるまで非準拠拡張挙動が検出されない可能性があります。"
    },
    {
      "indent": 3,
      "text": "To encourage correct implementation of extension mechanisms, base protocol specifications should clearly articulate the expected behavior of extension mechanisms and should include examples of correct extension behavior.",
      "ja": "拡張メカニズムの正しい実装を促進するために、基本プロトコル仕様は明らかに拡張メカニズムの正常な動作を明確にする必要があり、正しい拡張挙動の例を含むべきです。"
    },
    {
      "indent": 0,
      "text": "3.6. Protocol Parameter Registration",
      "section_title": true,
      "ja": "3.6。プロトコル・パラメータの登録"
    },
    {
      "indent": 3,
      "text": "As noted in Section 3.2 of \"Procedures for Protocol Extensions and Variations\" BCP 125 [RFC4775]:",
      "ja": "「プロトコル拡張のための手順およびバリエーション」BCP 125 [RFC4775]のセクション3.2で述べたように："
    },
    {
      "indent": 6,
      "text": "An extension is often likely to make use of additional values added to an existing IANA registry.... It is essential that such new values are properly registered by the applicable procedures, including expert review where applicable.... Extensions may even need to create new IANA registries in some cases.",
      "ja": "拡張子が....このような新しい値が正しく適用....エクステンションもする必要があるかもしれません専門家レビューを含め、該当する手順によって登録されていることが不可欠である既存のIANAレジストリに追加された追加の値を利用することが多いそうですいくつかのケースでは、新たなIANAレジストリを作成します。"
    },
    {
      "indent": 6,
      "text": "Experience shows that the importance of this is often underestimated during extension design; designers sometimes assume that a new codepoint is theirs for the asking, or even simply for the taking.",
      "ja": "経験は、このことの重要性は、多くの場合、拡張設計時に過小評価されていることを示しています。設計者は、時には新しいコードポイントを尋ねる彼らである、あるいは単に撮影のためにあることを前提としています。"
    },
    {
      "indent": 3,
      "text": "Before creating a new protocol parameter registry, existing registries should be examined to determine whether one of them can be used instead (see http://www.iana.org/protocols/).",
      "ja": "新しいプロトコルパラメータのレジストリを作成する前に、既存のレジストリは、そのうちの一つは、（http://www.iana.org/protocols/を参照）の代わりに使用することができるかどうかを決定するために検査する必要があります。"
    },
    {
      "indent": 3,
      "text": "To avoid conflicting usage of the same registry value, as well as to prevent potential difficulties in determining and transferring parameter ownership, it is essential that all new values are registered. If this is not done, there is nothing to prevent two different extensions picking the same value. When these two extensions \"meet\" each other on the Internet, failure is inevitable.",
      "ja": "同じレジストリ値の使用が競合しないようにするには、同様に決定し、パラメータの所有権を転送する際に潜在的な困難を防ぐために、すべての新しい値が登録されていることが不可欠です。これを行わない場合は、同じ値を選ぶ二つの異なる拡張を防ぐためには何もありません。これら2つの拡張は、インターネット上でお互いを「満たす」場合には、失敗は避けられません。"
    },
    {
      "indent": 3,
      "text": "A surprisingly common case of this is misappropriation of assigned Transmission Control Protocol (TCP) (or User Datagram Protocol (UDP)) registered port numbers. This can lead to a client for one service attempting to communicate with a server for another service. Another common case is the use of unregistered URI schemes. Numerous cases could be cited, but not without embarrassing specific implementers. For general rules, see the IANA Considerations guidelines document [RFC5226], and for specific rules and registries, see the individual protocol specification RFCs and the IANA web site.",
      "ja": "この驚くほど一般的なケースは、割り当てられた伝送制御プロトコル（TCP）（またはUDP（User Datagram Protocol））の不正流用であるポート番号を登録。これは、他のサービスのためにサーバーと通信しようとする一つのサービスのためにクライアントにつながることができます。他の一般的な場合には、未登録のURIスキームを使用することです。多くの場合は引用ではなく、具体的な実装を恥ずかしいことなく、することができます。一般的な規則については、IANAの考慮事項のガイドラインドキュメント[RFC5226]を参照し、特定のルールやレジストリのために、個々のプロトコル仕様のRFCとIANAのWebサイトを参照してください。"
    },
    {
      "indent": 3,
      "text": "While in theory a \"Standards Track\" or \"IETF Consensus\" parameter allocation policy may be instituted to encourage protocol parameter registration or to improve interoperability, in practice, problems can arise if the procedures result in so much delay that requesters give up and \"self-allocate\" by picking presumably unused code points. Where self-allocation is prevalent, the information contained within registries may become inaccurate, particularly when third parties are prohibited from updating entries so as to improve accuracy. In these situations, it is important to consider whether registration processes need to be changed to support the role of a registry as \"documentation of how the Internet is operating\".",
      "ja": "理論的には「標準化過程」または「IETFコンセンサス」パラメータの割り当てポリシーは、プロトコルパラメータ登録を奨励したり、相互運用性を改善するために制定されてもよいが手順はそんなにリクエスタはあきらめ遅延や「自己につながる場合、実際には、問題が発生する可能性がおそらく未使用のコードポイントを選ぶことによって「-allocate。自己割り当てが優勢である場合、レジストリ内に含まれる情報は、第三者が、精度を向上させるためにエントリを更新することが禁止されている場合は特に、不正確になることができます。これらの状況では、登録プロセスは、「インターネットが動作しているかのドキュメント」としてレジストリの役割をサポートするように変更する必要があるかどうかを検討することが重要です。"
    },
    {
      "indent": 0,
      "text": "3.7. Extensions to Critical Protocols",
      "section_title": true,
      "ja": "3.7。重要なプロトコルの拡張"
    },
    {
      "indent": 3,
      "text": "Some protocols (such as the Domain Name System (DNS), the Border Gateway Protocol (BGP), and the Hypertext Transfer Protocol (HTTP)) or algorithms (such as congestion control) have become critical components of the Internet infrastructure. A critical component is one whose failure can lead to Internet-wide reliability and security issues or performance degradation. When such protocols or algorithms are extended, the potential exists for negatively impacting the reliability and security of the global Internet.",
      "ja": "または（例えば輻輳制御など）のアルゴリズム（ドメインネームシステム（DNS）、ボーダーゲートウェイプロトコル（BGP）、およびハイパーテキスト転送プロトコル（HTTP）のような）一部のプロトコルは、インターネットインフラの重要な構成要素となっています。重要なコンポーネントは、その失敗、インターネット全体の信頼性とセキュリティの問題やパフォーマンスの低下につながることができるものです。そのようなプロトコルやアルゴリズムが拡張されている場合は、可能性は否定グローバルなインターネットの信頼性とセキュリティに影響を与えるために存在します。"
    },
    {
      "indent": 3,
      "text": "As a result, special care needs to be taken with these extensions, such as taking explicit steps to isolate existing uses from new ones. For example, this can be accomplished by requiring the extension to utilize a different port or multicast address or by implementing the extension within a separate process, without access to the data and control structures of the base protocol.",
      "ja": "その結果、特別なケアは、このような新しいものから既存の用途を隔離するために、明示的な手段を講じて、これらの拡張機能で撮影する必要があります。例えば、これは別のポートまたはマルチキャストアドレスを利用する拡張機能を要求することによって、またはベース・プロトコルのデータおよび制御構造にアクセスすることなく、別のプロセス内の拡張機能を実装することによって達成することができます。"
    },
    {
      "indent": 3,
      "text": "Experience has shown that even when a mechanism has proven benign in other uses, unforeseen issues may result when adding it to a critical protocol. For example, both IS-IS and OSPF support opaque Link State Advertisements (LSAs), which are propagated by intermediate nodes that don't understand the LSA. Within Interior Gateway Protocols (IGPs), support for opaque LSAs has proven useful without introducing instability.",
      "ja": "経験機構は他の用途に良性であることが判明した場合でも、重要なプロトコルに追加するときに、予期しない問題が生じ得ることを示しました。たとえば、両方のIS-IS LSAを理解していない中間ノードによって伝播され、OSPFをサポート不透明なリンクステートアドバタイズメント（LSA）、。インテリアゲートウェイプロトコル（のIGP）内で、不透明のLSAのサポートは不安定性を導入せずに有用であることが証明されました。"
    },
    {
      "indent": 3,
      "text": "However, within BGP, \"attribute tunneling\" has resulted in large-scale routing instabilities, since remote nodes may reset the LOCAL session if the tunneled attributes are malformed or aren't understood. This has required modification to BGP error handling, as noted in \"Revised Error Handling for BGP UPDATE Messages\" [ERROR-HANDLING].",
      "ja": "トンネリング属性が不正であるか、または理解されていない場合、リモート・ノードがローカルセッションをリセットすることができるので、BGP内で、「属性トンネリング」は、大規模なルーティングの不安定性をもたらしました。 [エラー処理]「BGPのUPDATEメッセージのための処理改訂エラー」で述べたように、これは、BGPのエラー処理への変更を必要としています。"
    },
    {
      "indent": 3,
      "text": "In general, when extending protocols with local failure conditions, tunneling of attributes that may trigger failures in non-adjacent nodes should be avoided. This is particularly problematic when the originating node receives no indicators of remote failures it may have triggered.",
      "ja": "ローカル障害状態とプロトコルを拡張する場合、一般的に、非隣接ノードの障害をトリガすることができる属性のトンネリングは避けるべきです。発信元ノードは、それがトリガしている場合があり、リモート障害のない指標を受信しないとき、これは特に問題です。"
    },
    {
      "indent": 0,
      "text": "4. Considerations for the Base Protocol",
      "section_title": true,
      "ja": "基本プロトコル4.考慮事項"
    },
    {
      "indent": 3,
      "text": "Good extension design depends on a well-designed base protocol. To promote interoperability, designers should:",
      "ja": "グッド拡張の設計はうまく設計されたベースのプロトコルに依存します。相互運用性を促進するために、設計者がすべき："
    },
    {
      "indent": 3,
      "text": "1. Ensure a well-written base protocol specification. Does the base protocol specification make clear what an implementer needs to support, and does it define the impact that individual operations (e.g., a message sent to a peer) will have when invoked?",
      "ja": "1.よく書かれた基本プロトコルの仕様を確認してください。ベースプロトコル仕様は、実装がサポートする必要があり、それが呼び出されたときに個々の操作（例えば、ピアに送信されたメッセージ）を持っていることの影響を定義しないものを明確にしていますか？"
    },
    {
      "indent": 3,
      "text": "2. Design for backward compatibility. Does the base protocol specification describe how to determine the capabilities of a peer and negotiate the use of extensions? Does it indicate how implementations handle extensions that they do not understand? Is it possible for an extended implementation to negotiate with an unextended (or differently-extended) peer to find a common subset of useful functions?",
      "ja": "下位互換性のため2.デザイン。基本プロトコル仕様は、ピアの能力を決定し、拡張の使用を交渉する方法を説明していますか？それは、実装は、彼らが理解していない拡張子を処理する方法を示していますか？それは便利な機能の共通サブセットを見つけるために伸長していない（または、異なる拡張）ピアと交渉する拡張の実装は可能ですか？"
    },
    {
      "indent": 3,
      "text": "3. Respect underlying architectural or security assumptions. Is there a document describing the underlying architectural assumptions, as well as considerations that have arisen in operational experience? Or are there undocumented considerations that have arisen as the result of operational experience, after the original protocol was published?",
      "ja": "3.基本的な建築やセキュリティの前提を尊重。根本的な建築の前提条件だけでなく、運用経験に生じている注意事項を記載した文書はありますか？オリジナルのプロトコルが公開された後、または、運用経験の結果として生じた検討事項が文書化されていませんか？"
    },
    {
      "indent": 7,
      "text": "For example, will backward-compatibility issues arise if\nextensions reverse the flow of data, allow formerly static\nparameters to be changed on the fly, or change assumptions\nrelating to the frequency of reads/writes?",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4. Minimize impact on critical infrastructure. For a protocol that represents a critical element of Internet infrastructure, it is important to explain when it is appropriate to isolate new uses of the protocol from existing ones.",
      "ja": "4.重要なインフラストラクチャへの影響を最小限に抑えます。インターネットインフラストラクチャの重要な要素を表しているプロトコルの場合、既存のものからプロトコルの新たな用途を隔離することが適切であるとき、説明することが重要です。"
    },
    {
      "indent": 7,
      "text": "For example, is it explained when a proposed extension (or usage)\nhas the potential for negatively impacting critical\ninfrastructure to the point where explicit steps would be\nappropriate to isolate existing uses from new ones?",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5. Provide guidance on data model extensions. Is there a document that explains when a protocol extension is routine and when it represents a major change?",
      "ja": "5.データモデルの拡張に関するガイダンスを提供します。プロトコル拡張が日常的であるとするとき、それは大きな変化を表す場合について説明した文書はありますか？"
    },
    {
      "indent": 7,
      "text": "For example, is it clear when a data model extension represents a\nmajor versus a routine change?  Are there guidelines describing\nwhen an extension (such as a new data type) is likely to require\na code change within existing implementations?",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.1. Version Numbers",
      "section_title": true,
      "ja": "4.1。バージョン番号"
    },
    {
      "indent": 3,
      "text": "Any mechanism for extension by versioning must include provisions to ensure interoperability, or at least clean failure modes. Imagine someone creating a protocol and using a \"version\" field and populating it with a value (1, let's say), but giving no information about what would happen when a new version number appears in it. This would be a bad protocol design and description; it should be clear what the expectation is and how it can be tested. For example, stating that 1.X must be compatible with any version 1 code, but version 2 or greater is not expected to be compatible, has different implications than stating that version 1 must be a proper subset of version 2.",
      "ja": "バージョニングによる伸長のための任意のメカニズムは、相互運用性、または少なくともきれいな故障モードを確保するための規定を含まなければなりません。誰かがプロトコルを作成し、「バージョン」フィールドを使用し、値とそれを埋める（1、のは言わせ）が、新しいバージョン番号が出たときに何が起こるかについての情報を与えていない想像してみてください。これは悪いプロトコル設計および記述になります。期待があり、それがどのようにテストすることができるものを明確にする必要があります。例えば、その1.Xを記載するいずれかのバージョン1のコードと互換性がなければならないが、バージョン2以上の互換性がないと予想される、バージョン1は、バージョン2の真部分集合でなければならないことを示すとは異なる意味を有しています。"
    },
    {
      "indent": 3,
      "text": "An example of an under-specified versioning mechanism is provided by the MIME-Version header, originally defined in \"MIME (Multipurpose Internet Mail Extensions)\" [RFC1341]. As noted in Section 1 of the MIME specification [RFC1341]:",
      "ja": "下の指定バージョン管理機構の一例は、もともと「MIME（多目的インターネットメール拡張）」[RFC1341]で定義され、MIMEバージョンのヘッダによって提供されます。 MIME仕様[RFC1341]のセクション1で述べたように："
    },
    {
      "indent": 6,
      "text": "A MIME-Version header field ... uses a version number to declare a message to be conformant with this specification and allows mail processing agents to distinguish between such messages and those generated by older or non-conformant software, which is presumed to lack such a field.",
      "ja": "MIMEバージョンのヘッダフィールドは...この仕様に準拠するメッセージを宣言するために、バージョン番号を使用してそのようなメッセージおよび古い又は非準拠ソフトウェアによって生成されたものを区別するために、メール処理剤を可能にする、そのような欠如と推定されていますフィールド。"
    },
    {
      "indent": 3,
      "text": "Beyond this, the 1992 MIME specification [RFC1341] provided little guidance on versioning behavior, or even the format of the MIME-Version header, which was specified to contain \"text\". The 1993 update [RFC1521] better defined the format of the version field but still did not clarify the versioning behavior:",
      "ja": "これを超えて、1992 MIME仕様[RFC1341]はバージョニング行動、または「テキスト」を含むように指定されたMIMEバージョンのヘッダのフォーマットにも少しのガイダンスを提供しました。 1993更新[RFC1521]は、より良いバージョンフィールドのフォーマットを定義したが、まだバージョン管理の振る舞いを明らかにしませんでした。"
    },
    {
      "indent": 6,
      "text": "Thus, future format specifiers, which might replace or extend \"1.0\", are constrained to be two integer fields, separated by a period. If a message is received with a MIME-version value other than \"1.0\", it cannot be assumed to conform with this specification....",
      "ja": "したがって、交換または拡張可能性があり、将来のフォーマット指定、「1.0」は、ピリオドで区切られた2つの整数フィールドに制限されています。メッセージが「1.0」以外のMIMEバージョン値と受信された場合、この仕様に準拠すると仮定することができない...."
    },
    {
      "indent": 6,
      "text": "It is not possible to fully specify how a mail reader that conforms with MIME as defined in this document should treat a message that might arrive in the future with some value of MIME-Version other than \"1.0\". However, conformant software is encouraged to check the version number and at least warn the user if an unrecognized MIME-version is encountered.",
      "ja": "完全にこの文書で定義されているMIME準拠のメールリーダーが「1.0」以外のMIME-バージョンのいくつかの値と将来に到着可能性があるメッセージを処理する方法を指定することはできません。しかし、準拠のソフトウェアはバージョン番号を確認し、認識できないMIME-バージョンが発生した場合、少なくともユーザーに警告することが奨励されます。"
    },
    {
      "indent": 3,
      "text": "Thus, even though the 1993 update [RFC1521] defined a MIME-Version header with a syntax suggestive of a \"Major/Minor\" versioning scheme, in practice the MIME-Version header was little more than a decoration.",
      "ja": "したがって、1993アップデート[RFC1521]はスキームバージョン「メジャー/マイナー」の示唆構文でMIMEバージョンのヘッダを定義してもかかわらず、実際にMIMEバージョンのヘッダは、装飾よりも少しありました。"
    },
    {
      "indent": 3,
      "text": "An example of a protocol with a better versioning scheme is ROHC (Robust Header Compression). ROHCv1 [RFC3095] supports a certain set of profiles for compression algorithms. But experience had shown that these profiles had limitations, so the ROHC WG developed ROHCv2 [RFC5225]. A ROHCv1 implementation does not contain code for the ROHCv2 profiles. As the ROHC WG charter said during the development of ROHCv2:",
      "ja": "より良好なバージョン管理スキームプロトコルの例は、ROHC（ロバストヘッダ圧縮）です。 ROHCv1 [RFC3095]は圧縮アルゴリズムのプロファイルの特定のセットをサポートします。しかし、経験は、これらのプロファイルには限界があったことを示していたので、ROHC WGはROHCv2 [RFC5225]を開発しました。 ROHCv1の実装はROHCv2プロファイル用のコードが含まれていません。 ROHC WG憲章はROHCv2の開発中に言ったように："
    },
    {
      "indent": 6,
      "text": "It should be noted that the v2 profiles will thus not be compatible with the original (ROHCv1) profiles, which means less complex ROHC implementations can be realized by not providing support for ROHCv1 (over links not yet supporting ROHC, or by shifting out support for ROHCv1 in the long run). Profile support is agreed through the ROHC channel negotiation, which is part of the ROHC framework and thus not changed by ROHCv2.",
      "ja": "より複雑ROHC実装を意味する元の（ROHCv1）プロファイルは、（まだROHCをサポートしていないリンクを介して、またはのためのサポートをシフトすることによってROHCv1ためのサポートを提供しないことによって実現することが可能とV2プロファイルは、このように互換性がないことに留意すべきです長期的にはROHCv1）。プロファイルのサポートは、ROHCフレームワークの一部であるROHCチャネル交渉を通じて合意したがってROHCv2によって変更されません。"
    },
    {
      "indent": 3,
      "text": "Thus, in this case, both backward-compatible and backward-incompatible deployments are possible. The important point is to have a clearly thought out approach to the question of operational compatibility.",
      "ja": "したがって、この場合には、両方の下位互換性と後方互換性のない展開が可能です。重要な点は、動作の互換性の問題を明確に考え抜かれたアプローチを持つことです。"
    },
    {
      "indent": 3,
      "text": "In the past, protocols have utilized a variety of strategies for versioning, each with its own benefits and drawbacks in terms of capability and complexity of implementation:",
      "ja": "過去には、プロトコルは独自の利点と欠点を持つ各実装の能力と複雑さの点では、バージョン管理のための様々な戦略を利用してきました。"
    },
    {
      "indent": 3,
      "text": "1. No versioning support. This approach is exemplified by the Extensible Authentication Protocol (EAP) [RFC3748] as well as the Remote Authentication Dial In User Service (RADIUS) protocol [RFC2865], both of which provide no support for versioning. While lack of versioning support protects against the proliferation of incompatible dialects, the need for extensibility is likely to assert itself in other ways, so that ignoring versioning entirely may not be the most forward thinking approach.",
      "ja": "1.バージョン管理のサポートに。このアプローチは、バージョニングのためのサポートを提供しないどちらも拡張認証プロトコル（EAP）[RFC3748]と同様に、リモート認証ダイヤルインユーザサービス（RADIUS）プロトコル[RFC2865]、が挙げられます。サポートはバージョン管理の欠如は、互換性のない方言の増殖から保護しながら、拡張性の必要性は無視して、完全にバージョン管理が最も前向きなアプローチではないかもしれないように、他の方法で自分自身を主張する可能性があります。"
    },
    {
      "indent": 3,
      "text": "2. Highest mutually supported version (HMSV). In this approach, implementations exchange the version numbers of the highest version each supports, with the negotiation agreeing on the highest mutually supported protocol version. This approach implicitly assumes that later versions provide improved functionality and that advertisement of a particular version number implies support for all lower version numbers. Where these assumptions are invalid, this approach breaks down, potentially resulting in interoperability problems. An example of this issue occurs in the Protected Extensible Authentication Protocol [PEAP] where implementations of higher versions may not necessarily provide support for lower versions.",
      "ja": "2.最高互いにサポートしているバージョン（HMSV）。このアプローチでは、実装は交渉が最高の相互サポートされているプロトコルのバージョンに同意して、最高のバージョンの各サポートをバージョン番号を交換します。このアプローチは、暗黙的にそれ以降のバージョンは、すべての下位バージョン番号のサポートを意味改善された機能と特定のバージョン番号の広告を提供することを想定しています。これらの仮定が無効である場合には、このアプローチは、潜在的相互運用性の問題が生じ、分解します。この問題の例は、より高いバージョンの実装は必ずしも低いバージョンのサポートを提供しないかもしれない保護された拡張認証プロトコル[PEAP]で起こります。"
    },
    {
      "indent": 3,
      "text": "3. Assumed backward compatibility. In this approach, implementations may send packets with higher version numbers to legacy implementations supporting lower versions, but with the assumption that the legacy implementations will interpret packets with higher version numbers using the semantics and syntax defined for lower versions. This is the approach taken by \"Port-Based Network Access Control\" [IEEE-802.1X]. For this approach to work, legacy implementations need to be able to accept packets of known types with higher protocol versions without discarding them; protocol enhancements need to permit silent discard of unsupported extensions; and implementations supporting higher versions need to refrain from mandating new features when encountering legacy implementations.",
      "ja": "3.下位互換性を想定しました。このアプローチでは、実装は、下のバージョンをサポートする従来の実装に高いバージョン番号を持つパケットを送信しますが、従来の実装は下のバージョンで定義された意味と構文を使用して、高いバージョン番号を持つパケットを解釈することを前提とします。これは、「ポートベースのネットワークアクセス制御」[IEEE-802.1X]で撮影したアプローチです。この手法が機能するために、従来の実装では、それらを廃棄することなく、より高いプロトコル・バージョンの既知のタイプのパケットを受け入れることができるようにする必要があります。プロトコルの拡張機能はサポートされていない拡張子のサイレント破棄を許可する必要があります。以上のバージョンをサポートする実装は、従来の実装に遭遇したときの新機能を義務づけるをお控えください。"
    },
    {
      "indent": 3,
      "text": "4. Major/minor versioning. In this approach, implementations with the same major version but a different minor version are assumed to be backward compatible, but implementations are required to negotiate a mutually supported major version number. This approach assumes that implementations with a lower minor version number but the same major version can safely ignore unsupported protocol messages.",
      "ja": "4.メジャー/マイナーバージョン管理。このアプローチでは、同じメジャーバージョンが異なるマイナーバージョンの実装は下位互換性であると仮定されているが、実装は、相互に支持メジャーバージョン番号をネゴシエートする必要があります。このアプローチは、下のマイナーバージョン番号が、同じメジャーバージョンでの実装が安全にサポートされていないプロトコルメッセージを無視することができることを前提としています。"
    },
    {
      "indent": 3,
      "text": "5. Min/max versioning. This approach is similar to HMSV, but without the implied obligation for clients and servers to support all versions back to version 1, in perpetuity. It allows clients and servers to cleanly drop support for early versions when those versions become so old that they are no longer relevant and no longer required. In this approach, the client initiating the connection reports the highest and lowest protocol versions it understands. The server reports back the chosen protocol version:",
      "ja": "5.最小/最大バージョニング。このアプローチは、HMSVに似ていますが、暗黙の義務なしクライアントとサーバは永久に、バックバージョン1のすべてのバージョンをサポートします。これは、これらのバージョンは、彼らがもはや関連していると、不要になっほど古くなったときに、クライアントとサーバーが正常に初期バージョンのサポートをドロップすることができます。このアプローチでは、接続を開始するクライアントは、それが理解し、最高と最低のプロトコルバージョンを報告します。サーバは、選択したプロトコルバージョンをバック報告します。"
    },
    {
      "indent": 7,
      "text": "a.  If the server understands one or more versions in the\n    client's range, it reports back the highest mutually\n    understood version.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "b. If there is no mutual version, then the server reports back some version that it does understand (selected as described below). The connection is then typically dropped by client or server, but reporting this version number first helps facilitate useful error messages at the client end:",
      "ja": "B。バック何相互バージョンが存在しない場合、サーバーのレポート、それは理解していることをいくつかのバージョン（後述のように選択）。接続は、その後、一般的に、クライアントまたはサーバによって低下したが、最初にこのバージョン番号を報告すると、クライアント側で便利なエラーメッセージを促進することができますされています。"
    },
    {
      "indent": 11,
      "text": "*  If there is no mutual version, and the server speaks any\n   version higher than client max, it reports the lowest\n   version it speaks that is greater than the client max.\n   The client can then report to the user, \"You need to\n   upgrade to at least version <xx>\".",
      "raw": true
    },
    {
      "indent": 11,
      "text": "* Else, the server reports the highest version it speaks. The client can then report to the user, \"You need to request the server operator to upgrade to at least version <min>\".",
      "ja": "*それ以外の場合、サーバーは、それが話す最も高いバージョンを報告します。次に、クライアントは、「あなたは、少なくともバージョン<分>にアップグレードするサーバーのオペレータを要求する必要が」、利用者に報告することができます。"
    },
    {
      "indent": 3,
      "text": "Protocols generally do not need any version-negotiation mechanism more complicated than the mechanisms described here. The nature of protocol version-negotiation mechanisms is that, by definition, they don't get widespread real-world testing until *after* the base protocol has been deployed for a while, and its deficiencies have become evident. This means that, to be useful, a protocol version-negotiation mechanism should be simple enough that it can reasonably be assumed that all the implementers of the first protocol version at least managed to implement the version-negotiation mechanism correctly.",
      "ja": "プロトコルは、一般的に、ここで説明したメカニズムよりも複雑任意のバージョン交渉メカニズムを必要としません。プロトコルバージョン交渉メカニズムの性質は、*後*ベースのプロトコルはしばらくの間に配備されるまで定義によって、彼らは広範な現実世界のテストを取得しない、ということであり、その欠陥が明らかになってきました。これは、有用であることが、プロトコルバージョン交渉メカニズムは、合理的に最初のプロトコル・バージョンのすべての実装は、少なくとも正しくバージョン交渉メカニズムを実装するために管理することを想定することができることを十分に単純でなければならないことを意味します。"
    },
    {
      "indent": 0,
      "text": "4.2. Reserved Fields",
      "section_title": true,
      "ja": "4.2。予約フィールド"
    },
    {
      "indent": 3,
      "text": "Protocols commonly include one or more \"reserved\" fields, clearly intended for future extensions. It is good practice to specify the value to be inserted in such a field by the sender (typically zero) and the action to be taken by the receiver when seeing some other value (typically no action). In packet format diagrams, such fields are typically labeled \"MBZ\", to be read as, \"Must Be Zero on transmission, Must Be Ignored on reception\".",
      "ja": "プロトコルは、一般的に明確に将来の拡張のために意図した1つ以上の「予約済み」のフィールドを、含まれています。いくつかの他の値（典型的にはアクション）を見たときに受信機によって解釈されるべき送信者（典型的にはゼロ）と作用することによって、そのようなフィールドに挿入する値を指定することをお勧めします。パケットフォーマットの図では、そのようなフィールドは、典型的には、「MBZ」とラベル付けされている「受信時に無視しなければなりません送信にゼロでなければならない」として読み取られます。"
    },
    {
      "indent": 3,
      "text": "A common mistake of inexperienced protocol implementers is to think that \"MBZ\" means that it's their software's job to verify that the value of the field is zero on reception and reject the packet if not. This is a mistake, and such software will fail when it encounters future versions of the protocol where these previously reserved fields are given new defined meanings. Similarly, protocols should carefully specify how receivers should react to unknown extensions (headers, TLVs, etc.), such that failures occur only when that is truly the intended outcome.",
      "ja": "経験の浅いプロトコル実装のよくある間違いは、「MBZは」それはフィールドの値は、受信時にゼロであることを確認していない場合にパケットを拒否するように彼らのソフトウェアの仕事だということを意味することを考えることです。これは間違いであり、それは、これらの以前に予約済みのフィールドが新たに定義された意味を与えられているプロトコルの将来のバージョンに遭遇したとき、そのようなソフトウェアが失敗します。同様に、プロトコルは、注意深く受信機が失敗がそれが真に意図する結果である場合にのみ起こるように、未知のエクステンション（ヘッダのTLV等）に反応する方法を指定すべきです。"
    },
    {
      "indent": 0,
      "text": "4.3. Encoding Formats",
      "section_title": true,
      "ja": "4.3。エンコーディング形式"
    },
    {
      "indent": 3,
      "text": "Using widely supported encoding formats leads to better interoperability and easier extensibility.",
      "ja": "広くサポートされているエンコーディング形式を使用することで、より良い相互運用性と容易な拡張性につながります。"
    },
    {
      "indent": 3,
      "text": "As described in \"IAB Thoughts on Encodings for Internationalized Domain Names\" [RFC6055], the number of encodings should be minimized, and complex encodings are generally a bad idea. As soon as one moves outside the ASCII repertoire, issues arise relating to collation, valid code points, encoding, normalization, and comparison, which extensions must handle with care [ID-COMPARISON][PRECIS-STATEMENT][PRECIS-FRAMEWORK].",
      "ja": "「国際化ドメイン名のエンコーディングのIAB思考」[RFC6055]で説明したように、エンコーディングの数は最小化されるべきである、と複雑なエンコーディングは、一般的に悪い考えです。できるだけ早くASCIIレパートリー外1移動するにつれて、問題が拡張機能は注意して取り扱う必要があり、照合に関連して、有効なコードポイント、符号化、正規化、および比較、[ID-比較] [PRECIS文]生じる[PRECIS-FRAMEWORK]。"
    },
    {
      "indent": 3,
      "text": "An example is the Simple Network Management Protocol (SNMP) Structure of Managed Information (SMI). Guidelines exist for defining the Management Information Base (MIB) objects that SNMP carries [RFC4181]. Also, multiple textual conventions have been published, so that MIB designers do not have to \"reinvent the wheel\" when they need a commonly encountered construct. For example, \"Textual Conventions for Internet Network Addresses\" [RFC4001] can be used by any MIB designer needing to define objects containing IP addresses, thus ensuring consistency as the body of MIBs is extended.",
      "ja": "例では、管理された情報（SMI）の簡易ネットワーク管理プロトコル（SNMP）の構造です。ガイドラインは、管理情報ベース（MIB）は、SNMPは[RFC4181]を運ぶことがオブジェクト定義するために存在します。 MIBの設計者は、彼らが一般的に遭遇する構造を必要とするとき、「車輪の再発明」する必要がないように。また、複数のテキストの表記法は、公表されています。例えば、[RFC4001]のMIBの本体が拡張されるようにこのように一貫性を確保する、IPアドレスを含むオブジェクトを定義する必要が任意のMIBデザイナーによって使用することができる「インターネットネットワークアドレスのための原文のコンベンション」。"
    },
    {
      "indent": 0,
      "text": "4.4. Parameter Space Design",
      "section_title": true,
      "ja": "4.4。パラメータスペースデザイン"
    },
    {
      "indent": 3,
      "text": "In some protocols, the parameter space either has no specified limit (e.g., Header field names) or is sufficiently large that it is unlikely to be exhausted. In other protocols, the parameter space is limited and, in some cases, has proven inadequate to accommodate demand. Common mistakes include:",
      "ja": "いくつかのプロトコル、パラメータ空間内のいずれか全く指定された制限（例えば、ヘッダーフィールド名）を有していない、または排出されにくいことが十分に大きいです。他のプロトコルでは、パラメータ空間は限られており、いくつかのケースでは、需要に対応するためには不十分であることが判明しました。よくある間違いは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "a. A version field that is too small (e.g., two bits or less). When designing a version field, existing as well as potential versions of a protocol need to be taken into account. For example, if a protocol is being standardized for which there are existing implementations with known interoperability issues, more than one version for \"pre-standard\" implementations may be required. If two \"pre-standard\" versions are required in addition to a version for an IETF Standard, then a two-bit version field would only leave one additional version code point for a future update, which could be insufficient. This problem was encountered during the development of the PEAPv2 protocol [PEAP].",
      "ja": "A。 （例えば、2ビット以下）が小さすぎるバージョンフィールド。バージョンフィールドを設計する場合、既存のと同様に、プロトコルの潜在的なバージョンを考慮する必要があります。例えば、プロトコルは「プレ標準」の実装のための複数のバージョンが必要とされ得る、既知の相互運用性の問題を有する既存の実装が存在しているために標準化されている場合。二つの「プレ標準」バージョンはIETF標準のバージョンに加えて、必要とされる場合には、2ビットのバージョンフィールドは、不十分かもしれない将来の更新のための1つの追加のバージョンのコードポイントを残すであろう。この問題はPEAPv2プロトコル[PEAP]の開発中に発生しました。"
    },
    {
      "indent": 3,
      "text": "b. A small parameter space (e.g., 8 bits or less) along with a First Come, First Served (FCFS) allocation policy [RFC5226]. In general, an FCFS allocation policy is only appropriate in situations where parameter exhaustion is highly unlikely. In situations where substantial demand is anticipated within a parameter space, the space should either be designed to be sufficient to handle that demand, or vendor extensibility should be provided to enable vendors to self-allocate. The combination of a small parameter space, an FCFS allocation policy, and no support for vendor extensibility is particularly likely to prove ill-advised. An example of such a combination was the design of the original 8-bit EAP Type space [RFC2284].",
      "ja": "B。小さなパラメータ空間（例えば、8ビット以下）最初に来ると一緒には、最初に配信（FCFS）割り当てポリシー[RFC5226]。一般に、FCFS割り当てポリシーは、パラメータ消耗が非常に低い状況でのみ適切です。かなりの需要がパラメータ空間内の予想される状況では、スペースは、いずれかのその要求を処理するために十分であるように設計されなければならない、またはベンダの拡張は、自己割り当てのベンダーを可能にするために提供されるべきです。小さなパラメータ空間、FCFSの割り当てポリシー、およびベンダー拡張のサポートはありませんの組み合わせは、無分別を証明することは特にそうです。そのような組み合わせの例は、元の8ビットのEAPタイプスペース[RFC2284]のデザインでした。"
    },
    {
      "indent": 3,
      "text": "Once the potential for parameter exhaustion becomes apparent, it is important that it be addressed as quickly as possible. Protocol changes can take years to appear in implementations and by then the exhaustion problem could become acute.",
      "ja": "パラメータの枯渇の可能性が明らかになったら、可能な限り迅速に対処することが重要です。プロトコルの変更が実装で表示されるように年をとることができ、その後で枯渇の問題が深刻になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Options for addressing a protocol parameter exhaustion problem include:",
      "ja": "プロトコルパラメータの枯渇問題に対処するためのオプションがあります。"
    },
    {
      "indent": 3,
      "text": "Rethinking the allocation regime Where it becomes apparent that the size of a parameter space is insufficient to meet demand, it may be necessary to rethink the allocation mechanism, in order to prevent or delay parameter space exhaustion. In revising parameter allocation mechanisms, it is important to consider both supply and demand aspects so as to avoid unintended consequences such as self-allocation or the development of black markets for the resale of protocol parameters.",
      "ja": "それはパラメータ空間のサイズは、需要を満たすには不十分であることが明らかになっ割当計画を見直し、予防またはパラメータ空間の枯渇を遅らせるために、割り当てメカニズムを再考する必要があるかもしれません。パラメータの割り当てメカニズムの見直しでは、そのような自己割り当てやプロトコルパラメータの転売のために闇市場の開発など、意図しない結果を避けるために、供給と需要の両面を考慮することが重要です。"
    },
    {
      "indent": 6,
      "text": "For example, a few years after publication of PPP EAP [RFC2284] in 1998, it became clear that the combination of an FCFS allocation policy [RFC5226] and lack of support for vendor-extensions had created the potential for exhaustion of the EAP Method Type space within a few years. To address the issue, Section 6.2 of the 2004 update [RFC3748] changed the allocation policy for EAP Method Types from FCFS to Expert Review, with Specification Required. Since this allocation policy revision did not change the demand for EAP Method Types, it would have been likely to result in self-allocation within the standards space had mechanisms not been provided to expand the Method Type space (including support for vendor-specific method types).",
      "ja": "例えば、数年後、1998年にPPP EAP [RFC2284]の発行後、それはFCFS割り当てポリシー[RFC5226]とベンダー拡張のサポートの欠如の組み合わせは、EAPメソッド型の枯渇の可能性を作成していたことが明らかになりました数年内の空間。問題を解決するために、2004更新[RFC3748]の6.2節では仕様が必要で、専門家レビューにFCFSからEAPメソッドタイプの割り当てポリシーを変更しました。この割り当てポリシーの改訂は、EAPメソッドタイプの需要を変更していないので、メカニズムは、ベンダー固有のメソッドタイプのサポートを含む（メソッド型スペースを拡張するために提供されていなかった、標準化空間内に自己割り当てになりそうだっただろう）。"
    },
    {
      "indent": 3,
      "text": "Support for vendor-specific parameters If the demand that cannot be accommodated is being generated by vendors, merely making allocation harder could make things worse if this encourages vendors to self-allocate, creating interoperability problems. In such a situation, support for vendor-specific parameters should be considered, allowing each vendor to self-allocate within their own vendor-specific space based on a vendor's Private Enterprise Code (PEC). For example, in the case of the EAP Method Type space, Section 6.2 of the 2004 EAP specification [RFC3748] also provided for an Expanded Type space for \"functions specific only to one vendor's implementation\".",
      "ja": "ベンダー固有のパラメータのサポートは対応できない需要は、相互運用性の問題を作成し、単にこれは自己割り当てにベンダーを奨励していた場合、物事を悪化させる可能性が難しく割り当てを行う、ベンダーによって生成されている場合。このような状況では、ベンダー固有のパラメータのサポートは、各ベンダーベンダーの民間企業コード（PEC）をもとに、独自のベンダー固有空間内で自己割り当てできるように、考慮されるべきです。例えば、EAPメソッドタイプ空間2004 EAP仕様のセクション6.2 [RFC3748]の場合にも、「唯一のベンダーの実装に固有の機能」の拡張型空間に設けられ。"
    },
    {
      "indent": 3,
      "text": "Extensions to the parameter space If the goal is to stave off exhaustion in the face of high demand, a larger parameter space may be helpful; this may require a new version of the protocol (such as was required for IPv6). Where vendor-specific parameter support is available, this may be achieved by allocating a PEC for IETF use. Otherwise, it may be necessary to try to extend the size of the parameter fields, which could require a new protocol version or other substantial protocol changes.",
      "ja": "目標は、より大きなパラメータ空間が役に立つかもしれ需要が高いの顔に疲労を食い止めるのであれば、パラメータ空間への拡張。 （IPv6のために必要とされたような）は、このプロトコルの新しいバージョンを必要とするかもしれません。ベンダー固有のパラメータのサポートが利用可能である場合、これはIETFの使用のためにPECを割り当てることによって達成することができます。それ以外の場合は、新しいプロトコルのバージョンや他の実質プロトコルの変更が必要になる可能性がパラメータフィールドのサイズを拡張しようとする必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Parameter reclamation In order to gain time, it may be necessary to reclaim unused parameters. However, it may not be easy to determine whether a parameter that has been allocated is in use or not, particularly if the entity that obtained the allocation no longer exists or has been acquired (possibly multiple times).",
      "ja": "時間を得るために、パラメータの再利用は、未使用のパラメータを再利用する必要があるかもしれません。しかしながら、割り当てを得たエンティティがもう存在しないか、（おそらく複数回）取得されている場合は特に、割り当てられたパラメータが使用中であるか否かを判断することは容易でないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Parameter transfer When all the above mechanisms have proved infeasible and parameter exhaustion looms in the near future, enabling the transfer of ownership of protocol parameters can be considered as a means for improving allocation efficiency. However, enabling transfer of parameter ownership can be far from simple if the parameter allocation process was not originally designed to enable title searches and ownership transfers.",
      "ja": "上記のすべてのメカニズムが実行不可能とパラメータ消耗を証明したパラメータ転送はプロトコルパラメータの所有権の移転は、割当効率を向上させるための手段と考えることができる可能に、近い将来に織機。パラメータの割り当てプロセスは、元々のタイトルを検索し、所有権の移転を可能にするために設計されていない場合は、パラメータの所有権の移転を有効にすると、はるかに単純なものからすることができます。"
    },
    {
      "indent": 6,
      "text": "A parameter allocation process designed to uniquely allocate code points is fundamentally different from one designed to enable title search and transfer. If the only goal is to ensure that a parameter is not allocated more than once, the parameter registry will only need to record the initial allocation. On the other hand, if the goal is to enable transfer of ownership of a protocol parameter, then it is important not only to record the initial allocation, but also to track subsequent ownership changes, so as to make it possible to determine and transfer the title. Given the difficulty of converting from a unique allocation regime to one requiring support for title search and ownership transfer, it is best for the desired capabilities to be carefully thought through at the time of registry establishment.",
      "ja": "一意のコードポイントを割り当てるように設計されたパラメータ割り当て処理は、タイトル検索転送を可能にするために設計されたものとは根本的に異なります。唯一の目標は、パラメータが複数回割り当てられていないことを確実にするためであれば、パラメータレジストリは、最初の割り当てを記録する必要があります。目標はプロトコルパラメータの所有権の移転を可能にするためである一方、決定して転送することが可能となるように、初期割り当てを記録するために、だけでなく、その後の所有権の変更を追跡するだけでなく、重要ですタイトル。タイトル検索と所有権の移転のためのサポートを必要とするものに独自の割り当て政権からの変換の難しさを考えると、それは慎重にレジストリの設立時に考え抜かされるべき所望の機能に最適です。"
    },
    {
      "indent": 0,
      "text": "4.5. Cryptographic Agility",
      "section_title": true,
      "ja": "4.5。暗号アジリティ"
    },
    {
      "indent": 3,
      "text": "Extensibility with respect to cryptographic algorithms is desirable in order to provide resilience against the compromise of any particular algorithm. Section 3 of \"Guidance for Authentication, Authorization, and Accounting (AAA) Key Management\" BCP 132 [RFC4962] provides some basic advice:",
      "ja": "暗号アルゴリズムに対する拡張は、任意の特定のアルゴリズムの妥協に対する耐性を提供するために望ましいです。 「認証、認可、アカウンティング（AAA）キー管理のための指針」BCP 132 [RFC4962]のセクション3は、いくつかの基本的なアドバイスを提供します。"
    },
    {
      "indent": 6,
      "text": "The ability to negotiate the use of a particular cryptographic algorithm provides resilience against compromise of a particular cryptographic algorithm.... This is usually accomplished by including an algorithm identifier and parameters in the protocol, and by specifying the algorithm requirements in the protocol specification. While highly desirable, the ability to negotiate key derivation functions (KDFs) is not required. For interoperability, at least one suite of mandatory-to-implement algorithms MUST be selected....",
      "ja": "特定の暗号アルゴリズムの使用を交渉する能力は、これは、通常、プロトコルにアルゴリズム識別子およびパラメータを含むことによって達成さ、およびプロトコル仕様のアルゴリズムの要件を指定することによってれる....特定の暗号アルゴリズムの危殆に対する回復力を提供します。非常に望ましいが、鍵導出関数（KDFs）を交渉する能力が必要とされません。相互運用性のために、強制的に実装アルゴリズムの少なくとも一方のスイートを選択しなければならない...."
    },
    {
      "indent": 6,
      "text": "This requirement does not mean that a protocol must support both public-key and symmetric-key cryptographic algorithms. It means that the protocol needs to be structured in such a way that multiple public-key algorithms can be used whenever a public-key algorithm is employed. Likewise, it means that the protocol needs to be structured in such a way that multiple symmetric-key algorithms can be used whenever a symmetric-key algorithm is employed.",
      "ja": "この要件は、プロトコルは、公開鍵と対称鍵暗号アルゴリズムの両方をサポートしなければならないという意味ではありません。これは、プロトコルは、公開鍵アルゴリズムが使用されるたびに、複数の公開鍵アルゴリズムを使用することができるように構成する必要があることを意味します。同様に、プロトコルは共通鍵暗号が使用されるたびに複数の対称鍵アルゴリズムを使用することができるように構成する必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "In practice, the most difficult challenge in providing cryptographic agility is providing for a smooth transition in the event that a mandatory-to-implement algorithm is compromised. Since it may take significant time to provide for widespread implementation of a previously undeployed alternative, it is often advisable to recommend implementation of alternative algorithms of distinct lineage in addition to those made mandatory-to-implement, so that an alternative algorithm is readily available. If such a recommended alternative is not in place, then it would be wise to issue such a recommendation as soon as indications of a potential weakness surface. This is particularly important in the case of potential weakness in algorithms used to authenticate and integrity-protect the cryptographic negotiation itself, such as KDFs or message integrity checks (MICs). Without secure alternatives to compromised KDF or MIC algorithms, it may not be possible to secure the cryptographic negotiation while retaining backward compatibility.",
      "ja": "実際には、暗号俊敏性を提供する上で最も困難な課題は、実装に必須のアルゴリズムが侵害された場合に円滑な移行のために提供されます。それは以前にアンデプロイ代替の広範な実施のために提供するために、かなりの時間がかかることがありますので、代替アルゴリズムが容易に利用可能であるように、実装に必須の作られたものに加えて、明確な系統の代替アルゴリズムの実装をお勧めすることが多いことをお勧めします。このよう推奨代替がないと、潜在的な弱点表面の兆候とすぐに、このような勧告を発行するのが賢明だろう。これは、KDFsまたはメッセージ完全性チェック（MIC値）として暗号化交渉自体を認証し、完全性を保護するために使用されるアルゴリズムの潜在的な弱点の場合に特に重要です。妥協KDFまたはMICアルゴリズムへの安全な代替手段がなければ、後方互換性を維持しながら、暗号化交渉を確保できない場合があります。"
    },
    {
      "indent": 0,
      "text": "4.6. Transport",
      "section_title": true,
      "ja": "4.6。輸送"
    },
    {
      "indent": 3,
      "text": "In the past, IETF protocols have been specified to operate over multiple transports. Often the protocol was originally specified to utilize a single transport, but limitations were discovered in subsequent deployment, so that additional transports were subsequently specified.",
      "ja": "過去には、IETFプロトコルは、複数のトランスポートを介して動作するために指定されています。多くの場合、プロトコルは当初、単一のトランスポートを利用するように指定されましたが、追加のトランスポートがその後に指定されていたような制限は、その後の展開で発見されました。"
    },
    {
      "indent": 3,
      "text": "In a number of cases, the protocol was originally specified to operate over UDP, but subsequent operation disclosed one or more of the following issues, leading to the specification of alternative transports:",
      "ja": "多くの場合、プロトコルは元々UDP上で動作するように指定されましたが、その後の動作は、別のトランスポートの仕様につながる、次の問題の一つ以上に開示されています。"
    },
    {
      "indent": 3,
      "text": "a. Payload fragmentation (often due to the introduction of extensions or additional usage scenarios);",
      "ja": "A。 （拡張や追加の使用シナリオの導入に起因することが多い）ペイロードの断片化。"
    },
    {
      "indent": 3,
      "text": "b. Problems with congestion control, transport reliability, or efficiency; and",
      "ja": "B。輻輳制御、輸送の信頼性、または効率の問題。そして"
    },
    {
      "indent": 3,
      "text": "c. Lack of deployment in multicast scenarios, which had been a motivator for UDP transport.",
      "ja": "C。 UDP輸送のための動機であったマルチキャストシナリオでの展開の欠如。"
    },
    {
      "indent": 3,
      "text": "On the other hand, there are also protocols that were originally specified to operate over reliable transport that have subsequently defined transport over UDP, due to one or more of the following issues:",
      "ja": "一方、もともとその後起因する以下の問題の1つ以上に、UDP上での輸送を定義した信頼性の高いトランスポートを介して動作するよう指定されたプロトコルもあります。"
    },
    {
      "indent": 3,
      "text": "a. NAT traversal concerns that were more easily addressed with UDP transport;",
      "ja": "A。より簡単にUDP輸送に対処されたNATトラバーサルの問題。"
    },
    {
      "indent": 3,
      "text": "b. Scalability problems, which could be improved by UDP transport.",
      "ja": "B。 UDPトランスポートによって改善することができるスケーラビリティの問題、。"
    },
    {
      "indent": 3,
      "text": "Since specification of a single transport offers the highest potential for interoperability, protocol designers should carefully consider not only initial but potential future requirements in the selection of a transport protocol. Where UDP transport is selected, the guidance provided in \"Unicast UDP Usage Guidelines for Application Designers\" [RFC5405] should be taken into account.",
      "ja": "単一のトランスポートの仕様は、相互運用性のための最高の可能性を提供していますので、プロトコル設計者は慎重にするだけでなく、トランスポートプロトコルの選択で初期しかし、潜在的な将来の要件を考慮すべきです。 UDPトランスポートが選択されている場合は、「アプリケーションデザイナーのためのユニキャストUDPの使用上の注意事項」[RFC5405]のガイダンスを考慮すべきです。"
    },
    {
      "indent": 3,
      "text": "After significant deployment has occurred, there are few satisfactory options for addressing problems with the originally selected transport protocol. While specification of additional transport protocols is possible, removal of a widely used transport protocol is likely to result in interoperability problems and should be avoided.",
      "ja": "重要な展開が行われた後、最初に選択されたトランスポートプロトコルの問題に対処するためのいくつかの十分な選択肢があります。追加のトランスポートプロトコルの仕様が可能ですが、広く使われているトランスポートプロトコルの除去は、相互運用性の問題が発生する可能性があり、避けるべきです。"
    },
    {
      "indent": 3,
      "text": "Mandating support for the initially selected transport protocol while designating additional transport protocols as optional may have limitations. Since optional transport protocols are typically introduced due to the advantages they afford in certain scenarios, in those situations, implementations not supporting optional transport protocols may exhibit degraded performance or may even fail.",
      "ja": "制限を有することができるような任意の追加のトランスポートプロトコルを指定して、最初に選択されたトランスポート・プロトコルのサポートを義務付けます。オプションのトランスポート・プロトコルは、典型的には、それらが特定のシナリオに与える効果に導入されているので、これらの状況では、オプションのトランスポート・プロトコルをサポートしない実装が劣化した性能を示すことができる、あるいは失敗してもよいです。"
    },
    {
      "indent": 3,
      "text": "While mandating support for multiple transport protocols may appear attractive, designers need to realistically evaluate the likelihood that implementers will conform to the requirements. For example, where resources are limited (such as in embedded systems), implementers may choose to only support a subset of the mandated transport protocols, resulting in non-interoperable protocol variants.",
      "ja": "複数のトランスポートプロトコルのサポートを義務化することは、魅力見えるかもしれないが、設計者は現実的に実装が要件に合致する可能性を評価する必要があります。リソースが（例えば、組み込みシステムのように）制限されている場合、例えば、実装は、非相互運用可能なプロトコルの変異体で、その結果、義務付けられたトランスポートプロトコルのサブセットをサポートするように選択することができます。"
    },
    {
      "indent": 0,
      "text": "4.7. Handling of Unknown Extensions",
      "section_title": true,
      "ja": "4.7。不明な拡張機能の取り扱い"
    },
    {
      "indent": 3,
      "text": "IETF protocols have utilized several techniques for the handling of unknown extensions. One technique (often used for vendor-specific extensions) is to specify that unknown extensions be \"silently discarded\".",
      "ja": "IETFプロトコルは、未知の拡張子の取り扱いのためのいくつかの技術を利用しています。 （多くの場合、ベンダー固有の拡張機能を使用）一つの技術は、未知の拡張子が「黙って破棄」するように指定することです。"
    },
    {
      "indent": 3,
      "text": "While this approach can deliver a high level of interoperability, there are situations in which it is problematic. For example, where security functionality is involved, \"silent discard\" may not be satisfactory, particularly if the recipient does not provide feedback as to whether or not it supports the extension. This can lead to operational security issues that are difficult to detect and correct, as noted in Appendix A.2 and in Section 2.5 of \"Common Remote Authentication Dial In User Service (RADIUS) Implementation Issues and Suggested Fixes\" [RFC5080].",
      "ja": "このアプローチは、相互運用性の高いレベルを実現することができるが、それは問題である状況があります。セキュリティ機能が関与している例については、「サイレント破棄」の受信者は、それが拡張をサポートしているか否かのフィードバックを提供していない場合は特に、満足できない場合があります。これは、[RFC5080]「ユーザーサービス（RADIUS）の実装の問題と推奨修正では一般的なリモート認証ダイヤル」付録A.2でのセクション2.5で述べたように、検出が困難と正しい運用上のセキュリティ問題につながることができます。"
    },
    {
      "indent": 3,
      "text": "In order to ensure that a recipient supports an extension, a recipient encountering an unknown extension may be required to explicitly reject it and to return an error, rather than ignoring the unknown extension and proceeding with the remainder of the message. This can be accomplished via a \"Mandatory\" bit in a TLV-based protocol such as the Layer 2 Tunneling Protocol (L2TP) [RFC2661], or a \"Require\" or \"Proxy-Require\" header in a text-based protocol such as SIP [RFC3261] or HTTP [RFC2616].",
      "ja": "受信者が拡張をサポートしていることを確実にするために、未知の拡張に遭遇する受信者が明示的に拒否すると、むしろ未知の拡張を無視し、メッセージの残りの部分に進むよりも、エラーを返すために必要とされ得ます。これは、レイヤ2トンネリングプロトコル（L2TP）[RFC2661]、または例えば、テキストベースのプロトコルで「必須」または「プロキシ要求」ヘッダとしてTLVベースのプロトコルで「必須」ビットを介して達成することができますSIP [RFC3261]またはHTTP [RFC2616]。"
    },
    {
      "indent": 3,
      "text": "Since a mandatory extension can result in an interoperability failure when communicating with a party that does not support the extension, this designation may not be permitted for vendor-specific extensions and may only be allowed for Standards Track extensions. To enable fallback operation with degraded functionality, it is good practice for the recipient to indicate the reason for the failure, including a list of unsupported extensions. The initiator can then retry without the offending extensions.",
      "ja": "拡張機能をサポートしていない相手と通信するときに必須の拡張は、相互運用性の障害が発生することができますので、この指定は、ベンダー固有の拡張のために許可されず、唯一の標準化過程の拡張のために許可することができます。劣化した機能を持つフォールバック操作を可能にするために、それはサポートされていない拡張機能のリストを含む、失敗の理由を、示すために、受信者のための良い方法です。イニシエータは、その後、問題の拡張子なしで再試行することができます。"
    },
    {
      "indent": 3,
      "text": "Typically, only the recipient will find itself in the position of rejecting a mandatory extension, since the initiator can explicitly indicate which extensions are supported, with the recipient choosing from among the supported extensions. This can be accomplished via an exchange of TLVs, such as in the Internet Key Exchange Protocol Version 2 (IKEv2) [RFC5996] or Diameter [RFC3588], or via use of \"Accept\", \"Accept-Encoding\", \"Accept-Language\", \"Allow\", and \"Supported\" headers in a text-based protocol such as SIP [RFC3261] or HTTP [RFC2616].",
      "ja": "イニシエータが明示的にサポートの拡張機能の中から選択する受信者に、サポートされている拡張子を示すことができますので、一般的に、受信者だけが、必須の拡張を拒否する立場に自分自身を見つけるでしょう。これは[RFC5996]または直径[RFC3588]、または「同意」の使用を介して、「符号化を受け入れ」、「受け入れ言語、インターネット鍵交換プロトコルバージョン2（IKEv2の）のように、のTLVの交換を介して達成することができます」、 『許可』、および 『そのようなSIP [RFC3261]やHTTPなどのテキストベースのプロトコルでサポートされている』ヘッダー[RFC2616]。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "An extension must not introduce new security risks without also providing adequate countermeasures; in particular, it must not inadvertently defeat security measures in the unextended protocol. Thus, the security analysis for an extension needs to be as thorough as for the original protocol -- effectively, it needs to be a regression analysis to check that the extension doesn't inadvertently invalidate the original security model.",
      "ja": "拡張子はまた、適切な対策を提供することなく、新たなセキュリティリスクを導入してはなりません。特に、それは不注意に伸長していないプロトコルでセキュリティ対策を無効にしないでなければなりません。したがって、拡張のためのセキュリティ分析は、元のプロトコルほど完全である必要がある - 効果は、拡張子が誤って元のセキュリティモデルを無効にしないことを確認するために回帰分析する必要があります。"
    },
    {
      "indent": 3,
      "text": "This analysis may be simple (e.g., adding an extra opaque data element is unlikely to create a new risk) or quite complex (e.g., adding a handshake to a previously stateless protocol may create a completely new opportunity for an attacker).",
      "ja": "この分析は簡単である（例えば、以前にステートレスなプロトコルに握手を追加すると、攻撃者のための完全に新しい機会を作成することができます）、または非常に複雑（例えば、余分な不透明なデータ要素を追加すると、新たなリスクを作成することはほとんどありません）。"
    },
    {
      "indent": 3,
      "text": "When the extensibility of a design includes allowing for new and presumably more powerful cryptographic algorithms to be added, particular care is needed to ensure that the result is, in fact, increased security. For example, it may be undesirable from a security viewpoint to allow negotiation down to an older, less secure algorithm.",
      "ja": "設計の拡張性は、新たなそしておそらくより強力な暗号化アルゴリズムを追加するためにできるように含まれている場合、特に注意が結果があることを保証するために必要とされ、実際には、セキュリティを増加させました。例えば、ダウン古い、安全性の低いアルゴリズムに交渉を可能にし、セキュリティの観点から望ましくないかもしれません。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4775] Bradner, S., Carpenter, B., Ed., and T. Narten, \"Procedures for Protocol Extensions and Variations\", BCP 125, RFC 4775, December 2006.",
      "ja": "[RFC4775]ブラドナーの、S.、大工、B.、エド。、およびT. Narten氏、 \"プロトコル拡張機能やバリエーションのための手順\"、BCP 125、RFC 4775、2006年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[ERROR-HANDLING] Scudder, J., Chen, E., Mohapatra, P., and K. Patel, \"Revised Error Handling for BGP UPDATE Messages\", Work in Progress, June 2012.",
      "ja": "[エラー処理]スカダー、J.、チェン、E.、Mohapatra、P.、およびK.パテル、 \"BGPのUPDATEメッセージのための処理改訂エラー\"、進歩、2012年6月に作業。"
    },
    {
      "indent": 3,
      "text": "[ID-COMPARISON] Thaler, D., \"Issues in Identifier Comparison for Security Purposes\", Work in Progress, August 2012.",
      "ja": "[ID-比較]ターラー、D.、「セキュリティの目的のための識別子の比較では問題」、進歩、2012年8月での作業。"
    },
    {
      "indent": 3,
      "text": "[IEEE-802.1X] Institute of Electrical and Electronics Engineers, \"Local and Metropolitan Area Networks: Port-Based Network Access Control\", IEEE Standard 802.1X-2004, December 2004.",
      "ja": "電気電子学会、「地方とメトロポリタンエリアネットワーク：ポートベースのネットワークアクセスコントロール」の[IEEE-802.1X]研究所、IEEE標準802.1X-2004、2004年12月。"
    },
    {
      "indent": 3,
      "text": "[LISP] Farinacci, D., Fuller, V., Meyer, D., and D. Lewis, \"Locator/ID Separation Protocol (LISP)\", Work in Progress, May 2012.",
      "ja": "[LISP]ファリナッチ、D.、フラー、V.、マイヤー、D.、およびD.ルイス、 \"ロケータ/ ID分離プロトコル（LISP）\"、進歩、2012年5月に働いています。"
    },
    {
      "indent": 3,
      "text": "[PEAP] Palekar, A., Simon, D., Salowey, J., Zhou, H., Zorn, G., and S. Josefsson, \"Protected EAP Protocol (PEAP) Version 2\", Work in Progress, October 2004.",
      "ja": "[PEAP] Palekar、A.、サイモン、D.、Salowey、J.、周、H.、ゾルン、G.、およびS. Josefsson氏、 \"保護されたEAPプロトコル（PEAP）バージョン2\"、進行中で働いて、2004年10月。"
    },
    {
      "indent": 3,
      "text": "[PRECIS-FRAMEWORK] Saint-Andre, P. and M. Blanchet, \"PRECIS Framework: Preparation and Comparison of Internationalized Strings in Application Protocols\", Work in Progress, August 2012.",
      "ja": "[PRECIS-FRAMEWORK]サンアンドレ、P.とM.ブランシェ、「PRECISフレームワーク：アプリケーションプロトコルにおける国際化された文字列の作成と比較」、進歩、2012年8月での作業。"
    },
    {
      "indent": 3,
      "text": "[PRECIS-STATEMENT] Blanchet, M. and A. Sullivan, \"Stringprep Revision and PRECIS Problem Statement\", Work in Progress, August 2012.",
      "ja": "[PRECIS-STATEMENT]ブランシェ、M.とA.サリバン、 \"文字列準備リビジョンとPRECIS問題に関する声明\"、進歩、2012年8月での作業。"
    },
    {
      "indent": 3,
      "text": "[RFC822] Crocker, D., \"STANDARD FOR THE FORMAT OF ARPA INTERNET TEXT MESSAGES\", STD 11, RFC 822, August 1982.",
      "ja": "[RFC822]クロッカー、D.、 \"ARPAインターネットテキストメッセージの形式の規格\"、STD 11、RFC 822、1982年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1263] O'Malley, S. and L. Peterson, \"TCP Extensions Considered Harmful\", RFC 1263, October 1991.",
      "ja": "[RFC1263]オマリー、S.とL.ピーターソン、 \"有害と考えられTCP拡張\"、RFC 1263、1991年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1341] Borenstein, N. and N. Freed, \"MIME (Multipurpose Internet Mail Extensions): Mechanisms for Specifying and Describing the Format of Internet Message Bodies\", RFC 1341, June 1992.",
      "ja": "[RFC1341] Borenstein、N.とN.フリード、「MIME（多目的インターネットメール拡張）：インターネットメッセージ本体の形式を指定し、説明するためのメカニズム」、RFC 1341、1992年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC1521] Borenstein, N. and N. Freed, \"MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies\", RFC 1521, September 1993.",
      "ja": "[RFC1521] Borenstein、N.とN.フリード、「MIME（多目的インターネットメール拡張）第一部：インターネットメッセージ本体の形式を指定し、説明するためのメカニズム」、RFC 1521、1993年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2058] Rigney, C., Rubens, A., Simpson, W., and S. Willens, \"Remote Authentication Dial In User Service (RADIUS)\", RFC 2058, January 1997.",
      "ja": "[RFC2058] Rigney、C.、ルーベンス、A.、シンプソン、W.、およびS. Willens、RFC 2058 \"ユーザーサービス（RADIUS）においてリモート認証ダイヤル\"、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2132] Alexander, S. and R. Droms, \"DHCP Options and BOOTP Vendor Extensions\", RFC 2132, March 1997.",
      "ja": "[RFC2132]アレクサンダー、S.とR. Droms、 \"DHCPオプションとBOOTPベンダー拡張機能\"、RFC 2132、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2246] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[RFC2246]ダークス、T.とC.アレン、 \"TLSプロトコルバージョン1.0\"、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2284] Blunk, L. and J. Vollbrecht, \"PPP Extensible Authentication Protocol (EAP)\", RFC 2284, March 1998.",
      "ja": "[RFC2284]ブルンク、L.及びJ. Vollbrecht、 \"PPP拡張認証プロトコル（EAP）\"、RFC 2284、1998年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2474] Nichols, K., Blake, S., Baker, F., and D. Black, \"Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers\", RFC 2474, December 1998.",
      "ja": "[RFC2474]ニコルズ、K.、ブレイク、S.、ベイカー、F.、およびD.黒、 \"IPv4とIPv6ヘッダーとの差別化されたサービス分野（DS分野）の定義\"、RFC 2474、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2661] Townsley, W., Valencia, A., Rubens, A., Pall, G., Zorn, G., and B. Palter, \"Layer Two Tunneling Protocol \"L2TP\"\", RFC 2661, August 1999.",
      "ja": "[RFC2661] Townsley、W.、バレンシア、A.、ルーベンス、A.、ポール、G.、ツォルン、G.、およびB. Palter、 \"レイヤ2トンネリングプロトコル \"L2TP\"\"、RFC 2661、1999年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2671] Vixie, P., \"Extension Mechanisms for DNS (EDNS0)\", RFC 2671, August 1999.",
      "ja": "[RFC2671]いるVixie、P.、 \"DNS用拡張メカニズム（EDNS0）\"、RFC 2671、1999年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2822] Resnick, P., Ed., \"Internet Message Format\", RFC 2822, April 2001.",
      "ja": "[RFC2822]レズニック、P.、エド。、 \"インターネットメッセージ形式\"、RFC 2822、2001年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2865] Rigney, C., Willens, S., Rubens, A., and W. Simpson, \"Remote Authentication Dial In User Service (RADIUS)\", RFC 2865, June 2000.",
      "ja": "[RFC2865] Rigney、C.、ウィレンス、S.、ルーベン、A.、およびW.シンプソン、RFC 2865、2000年6月 \"ユーザーサービス（RADIUS）でリモート認証ダイヤル\"。"
    },
    {
      "indent": 3,
      "text": "[RFC2882] Mitton, D., \"Network Access Servers Requirements: Extended RADIUS Practices\", RFC 2882, July 2000.",
      "ja": "[RFC2882]ミトン、D.、 \"ネットワークアクセスサーバーの要件：拡張RADIUSプラクティス\"、RFC 2882、2000年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3095] Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, \"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed\", RFC 3095, July 2001.",
      "ja": "[RFC3095]ボルマン、C.、Burmeister、C.、Degermark、M.、福島、H.、ハンヌ、H.、ジョンソン、LE。、Hakenberg、R.、コレン、T.、ル、K.、劉、 Z.、Martenssonから、A.、宮崎、A.、Svanbro、K.、Wiebke、T.、吉村、T.、およびH.鄭、「ロバストヘッダ圧縮（ROHC）：フレームワークおよび4つのプロファイル：RTP、UDP、 ESP、および非圧縮」、RFC 3095、2001年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[RFC3261]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 \"SIP：セッション開始プロトコル\" 、RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3427] Mankin, A., Bradner, S., Mahy, R., Willis, D., Ott, J., and B. Rosen, \"Change Process for the Session Initiation Protocol (SIP)\", RFC 3427, December 2002.",
      "ja": "[RFC3427]マンキン、A.、ブラドナー、S.、マーイ、R.、ウィリス、D.、オット、J.、およびB.ローゼン、 \"セッション開始プロトコル（SIP）のための変更処理\"、RFC 3427年12月2002。"
    },
    {
      "indent": 3,
      "text": "[RFC3575] Aboba, B., \"IANA Considerations for RADIUS (Remote Authentication Dial In User Service)\", RFC 3575, July 2003.",
      "ja": "[RFC3575] Aboba、B.、 \"RADIUSのためのIANAの考慮事項（ユーザサービスにおけるリモート認証ダイヤル）\"、RFC 3575、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3588] Calhoun, P., Loughney, J., Guttman, E., Zorn, G., and J. Arkko, \"Diameter Base Protocol\", RFC 3588, September 2003.",
      "ja": "[RFC3588]カルフーン、P.、Loughney、J.、ガットマン、E.、ゾルン、G.、およびJ. Arkko、 \"直径ベースプロトコル\"、RFC 3588、2003年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3597] Gustafsson, A., \"Handling of Unknown DNS Resource Record (RR) Types\", RFC 3597, September 2003.",
      "ja": "[RFC3597]グスタフソン、A.、 \"未知のDNSリソースレコード（RR）の取扱いタイプ\"、RFC 3597、2003年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3692] Narten, T., \"Assigning Experimental and Testing Numbers Considered Useful\", BCP 82, RFC 3692, January 2004.",
      "ja": "[RFC3692] Narten氏、T.、 \"役に立つと考えられ割り当て実験とテスト番号\"、BCP 82、RFC 3692、2004年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3735] Hollenbeck, S., \"Guidelines for Extending the Extensible Provisioning Protocol (EPP)\", RFC 3735, March 2004.",
      "ja": "[RFC3735]ホレンベック、S.、2004年3月、RFC 3735、 \"拡張プロビジョニングプロトコル（EPP）を拡張するためのガイドライン\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3748] Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H. Levkowetz, Ed., \"Extensible Authentication Protocol (EAP)\", RFC 3748, June 2004.",
      "ja": "[RFC3748] Aboba、B.、ブルンク、L.、Vollbrecht、J.、カールソン、J.、およびH. Levkowetz、編、 \"拡張認証プロトコル（EAP）\"、RFC 3748、2004年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3935] Alvestrand, H., \"A Mission Statement for the IETF\", BCP 95, RFC 3935, October 2004.",
      "ja": "[RFC3935] Alvestrand、H.、 \"IETFのためのミッション・ステートメント\"、BCP 95、RFC 3935、2004年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC4001] Daniele, M., Haberman, B., Routhier, S., and J. Schoenwaelder, \"Textual Conventions for Internet Network Addresses\", RFC 4001, February 2005.",
      "ja": "[RFC4001]ダニエル、M.、ハーバーマン、B.、Routhier、S.、およびJ. Schoenwaelder、 \"インターネットネットワークアドレスのためのテキストの表記法\"、RFC 4001、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4181] Heard, C., Ed., \"Guidelines for Authors and Reviewers of MIB Documents\", BCP 111, RFC 4181, September 2005.",
      "ja": "[RFC4181]聞いた、C.、エド。、 \"MIBドキュメントの著者と査読のためのガイドライン\"、BCP 111、RFC 4181、2005年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4366] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, \"Transport Layer Security (TLS) Extensions\", RFC 4366, April 2006.",
      "ja": "[RFC4366]ブレイク・ウィルソン、S.、Nystrom、M.、ホップウッド、D.、ミケルセン、J.、およびT.ライト、 \"トランスポート層セキュリティ（TLS）拡張機能\"、RFC 4366、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4485] Rosenberg, J. and H. Schulzrinne, \"Guidelines for Authors of Extensions to the Session Initiation Protocol (SIP)\", RFC 4485, May 2006.",
      "ja": "[RFC4485]ローゼンバーグ、J.とH. Schulzrinneと、RFC 4485、2006年5月 \"セッション開始プロトコル（SIP）への拡張の作者のためのガイドライン\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4521] Zeilenga, K., \"Considerations for Lightweight Directory Access Protocol (LDAP) Extensions\", BCP 118, RFC 4521, June 2006.",
      "ja": "[RFC4521] Zeilenga、K.、BCP 118、RFC 4521、2006年6月 \"LDAP（Lightweight Directory Access Protocol）の拡張機能のための考慮事項\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4727] Fenner, B., \"Experimental Values In IPv4, IPv6, ICMPv4, ICMPv6, UDP, and TCP Headers\", RFC 4727, November 2006.",
      "ja": "[RFC4727]フェナー、B.、RFC 4727、2006年11月 \"のIPv4、IPv6の、ICMPv4の、ICMPv6の、UDP、およびTCPヘッダには実験値\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4929] Andersson, L., Ed., and A. Farrel, Ed., \"Change Process for Multiprotocol Label Switching (MPLS) and Generalized MPLS (GMPLS) Protocols and Procedures\", BCP 129, RFC 4929, June 2007.",
      "ja": "[RFC4929]アンデション、L.、エド。、およびA.ファレル、エド。、 \"（MPLS）をマルチプロトコルラベルスイッチングのための変更処理と一般化MPLS（GMPLS）プロトコルおよび手順\"、BCP 129、RFC 4929、2007年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4962] Housley, R. and B. Aboba, \"Guidance for Authentication, Authorization, and Accounting (AAA) Key Management\", BCP 132, RFC 4962, July 2007.",
      "ja": "[RFC4962] Housley氏、R。およびB. Aboba、 \"認証、許可、アカウンティング（AAA）キー管理のための指針\"、BCP 132、RFC 4962、2007年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC5080] Nelson, D. and A. DeKok, \"Common Remote Authentication Dial In User Service (RADIUS) Implementation Issues and Suggested Fixes\", RFC 5080, December 2007.",
      "ja": "[RFC5080]ネルソン、D.とA. DeKok、RFC 5080、2007年12月 \"ユーザーサービス（RADIUS）の実装の問題と推奨修正に共通のリモート認証ダイヤル\"。"
    },
    {
      "indent": 3,
      "text": "[RFC5201] Moskowitz, R., Nikander, P., Jokela, P., Ed., and T. Henderson, \"Host Identity Protocol\", RFC 5201, April 2008.",
      "ja": "[RFC5201]モスコウィッツ、R.、Nikander、P.、Jokela、P.、エド。、およびT.ヘンダーソン、 \"ホストアイデンティティプロトコル\"、RFC 5201、2008年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5218] Thaler, D. and B. Aboba, \"What Makes For a Successful Protocol?\", RFC 5218, July 2008.",
      "ja": "[RFC5218]ターラー、D.とB. Aboba、 \"何が成功したプロトコルになり？\"、RFC 5218、2008年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC5225] Pelletier, G. and K. Sandlund, \"RObust Header Compression Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP and UDP-Lite\", RFC 5225, April 2008.",
      "ja": "[RFC5225]ペルティエ、G.およびK. Sandlund、 \"ロバストヘッダ圧縮バージョン2（ROHCv2）：RTP、UDP、IP、ESPとUDP-Liteのプロファイル\"、RFC 5225、2008年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5321] Klensin, J., \"Simple Mail Transfer Protocol\", RFC 5321, October 2008.",
      "ja": "[RFC5321] Klensin、J.、 \"簡易メール転送プロトコル\"、RFC 5321、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5405] Eggert, L. and G. Fairhurst, \"Unicast UDP Usage Guidelines for Application Designers\", BCP 145, RFC 5405, November 2008.",
      "ja": "[RFC5405]エッゲルト、L.とG. Fairhurst、 \"アプリケーションデザイナーのためのユニキャストUDPの使用上の注意事項\"、BCP 145、RFC 5405、2008年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5421] Cam-Winget, N. and H. Zhou, \"Basic Password Exchange within the Flexible Authentication via Secure Tunneling Extensible Authentication Protocol (EAP-FAST)\", RFC 5421, March 2009.",
      "ja": "[RFC5421]カム・ウィンゲット、N.およびH.周、RFC 5421、2009月 \"セキュアなトンネリング拡張認証プロトコル（EAP-FAST）を介して柔軟な認証内の基本的なパスワードの交換\"。"
    },
    {
      "indent": 3,
      "text": "[RFC5422] Cam-Winget, N., McGrew, D., Salowey, J., and H. Zhou, \"Dynamic Provisioning Using Flexible Authentication via Secure Tunneling Extensible Authentication Protocol (EAP-FAST)\", RFC 5422, March 2009.",
      "ja": "[RFC5422]、RFC 5422、2009年3月 \"（EAP-FAST）セキュアなトンネリング拡張認証プロトコルを介して柔軟な認証の使用動的プロビジョニング\" CAM-ウィンゲット、N.、マグリュー、D.、Salowey、J.、およびH.周。"
    },
    {
      "indent": 3,
      "text": "[RFC5704] Bryant, S., Ed., Morrow, M., Ed., and IAB, \"Uncoordinated Protocol Development Considered Harmful\", RFC 5704, November 2009.",
      "ja": "[RFC5704]ブライアント、S.、エド。、モロー、M.、エド。、およびIAB、2009年11月、RFC 5704、 \"非協調プロトコルの開発は、有害と考えられ\"。"
    },
    {
      "indent": 3,
      "text": "[RFC5727] Peterson, J., Jennings, C., and R. Sparks, \"Change Process for the Session Initiation Protocol (SIP) and the Real-time Applications and Infrastructure Area\", BCP 67, RFC 5727, March 2010.",
      "ja": "[RFC5727]ピーターソン、J.、ジェニングス、C.、およびR.スパークス、BCP 67、RFC 5727、2010年3月 \"セッション開始プロトコル（SIP）とリアルタイムアプリケーションとインフラストラクチャ領域の変更処理\"。"
    },
    {
      "indent": 3,
      "text": "[RFC5996] Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", RFC 5996, September 2010.",
      "ja": "[RFC5996]カウフマン、C.、ホフマン、P.、ニール、Y.、およびP. Eronen、 \"インターネット鍵交換プロトコルバージョン2（IKEv2の）\"、RFC 5996、2010年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC6055] Thaler, D., Klensin, J., and S. Cheshire, \"IAB Thoughts on Encodings for Internationalized Domain Names\", RFC 6055, February 2011.",
      "ja": "[RFC6055]ターラー、D.、Klensin、J.、およびS.チェシャー、 \"国際化ドメイン名のエンコーディングのIAB思考\"、RFC 6055、2011年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6158] DeKok, A., Ed., and G. Weber, \"RADIUS Design Guidelines\", BCP 158, RFC 6158, March 2011.",
      "ja": "[RFC6158] DeKok、A.編、およびG.ウェーバー、 \"RADIUS設計ガイドライン\"、BCP 158、RFC 6158、2011年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC6648] Saint-Andre, P., Crocker, D., and M. Nottingham, \"Deprecating the \"X-\" Prefix and Similar Constructs in Application Protocols\", BCP 178, RFC 6648, June 2012.",
      "ja": "[RFC6648]サンアンドレ、P.、クロッカー、D.、およびM.ノッティンガム、X- \"アプリケーションプロトコルでのプレフィックスと同様の構築 \"\" 卑下\"、BCP 178、RFC 6648、2012年6月。"
    },
    {
      "indent": 0,
      "text": "7. Acknowledgments",
      "section_title": true,
      "ja": "7.謝辞"
    },
    {
      "indent": 3,
      "text": "This document is heavily based on an earlier draft by Scott Bradner and Thomas Narten, other parts of which were eventually published as RFC 4775.",
      "ja": "この文書は重く、他の部分は最終的にRFC 4775として発行されたスコット・ブラッドナーとトーマスNarten氏による初期のドラフトに基づいています。"
    },
    {
      "indent": 3,
      "text": "That draft stated: \"The initial version of this document was put together by the IESG in 2002. Since then, it has been reworked in response to feedback from John Loughney, Henrik Levkowetz, Mark Townsley, Randy Bush and others.\"",
      "ja": "その草案は、次のように述べた。「この文書の最初のバージョンは、それ以来、2002年にIESGによってまとめられた、それはジョンLoughney、ヘンリクLevkowetz、マークTownsley、ランディブッシュと他者からのフィードバックに応じて改訂されました。」"
    },
    {
      "indent": 3,
      "text": "Valuable comments and suggestions on the current form of the document were made by Loa Andersson, Ran Atkinson, Stewart Bryant, Leslie Daigle, Alan DeKok, Roy Fielding, Phillip Hallam-Baker, Ted Hardie, Alfred Hoenes, John Klensin, Barry Leiba, Eric Rescorla, Adam Roach, and Pekka Savola. The text on TLS experience was contributed by Yngve Pettersen.",
      "ja": "文書の現在のフォーム上の貴重な意見や提案がロア・アンダーソンによって作られた、アトキンソン、スチュワートブライアント、レスリーDaigle氏、アラン・DeKok、ロイ・フィールディング、フィリップハラム - ベイカー、テッドハーディー、アルフレッドHoenes、ジョン・クレンシン、バリー・レイバ、エリック・蘭レスコラ、アダムローチ、およびペッカSavola。 TLSの経験上のテキストは、Yngveペターによって寄贈されました。"
    },
    {
      "indent": 0,
      "text": "8. IAB Members at the Time of Approval",
      "section_title": true,
      "ja": "承認時の8 IABメンバー"
    },
    {
      "indent": 3,
      "text": "Bernard Aboba Jari Arkko Marc Blanchet Ross Callon Alissa Cooper Spencer Dawkins Joel Halpern Russ Housley David Kessens Danny McPherson Jon Peterson Dave Thaler Hannes Tschofenig",
      "ja": "バーナードAbobaヤリArkkoマルク・ブランシェロスCallonアリッサ・クーパースペンサーダウキンズジョエル・ハルパーンラスHousleyデビッドKessensダニー・マクファーソンジョン・ピーターソンデーブターラーハンネスTschofenig"
    },
    {
      "indent": 0,
      "text": "Appendix A. Examples",
      "ja": "付録A.例"
    },
    {
      "indent": 3,
      "text": "This section discusses some specific examples as case studies.",
      "ja": "このセクションでは、ケーススタディとして、いくつかの具体例を説明します。"
    },
    {
      "indent": 0,
      "text": "A.1. Already-Documented Cases",
      "ja": "A.1。既に文書化事例"
    },
    {
      "indent": 3,
      "text": "There are certain documents that specify a change process or describe extension considerations for specific IETF protocols:",
      "ja": "変更プロセスを指定するか、または特定のIETFプロトコルの拡張考慮事項について説明し、特定の文書があります。"
    },
    {
      "indent": 6,
      "text": "The SIP change process [RFC3427], [RFC4485], [RFC5727] The (G)MPLS change process (mainly procedural) [RFC4929] LDAP extensions [RFC4521] EPP extensions [RFC3735] DNS extensions [RFC2671][RFC3597] SMTP extensions [RFC5321]",
      "ja": "SIP変更処理[RFC3427]、[RFC4485]、[RFC5727]（主に手続き）（G）MPLS変更処理[RFC4929] LDAP拡張[RFC4521] EPP拡張[RFC3735] DNS拡張[RFC2671]、[RFC3597] SMTP拡張[ RFC5321]"
    },
    {
      "indent": 3,
      "text": "It is relatively common for MIBs, which are all in effect extensions of the SMI data model, to be defined or extended outside the IETF. BCP 111 [RFC4181] offers detailed guidance for authors and reviewers.",
      "ja": "これはIETFの外に定義または拡張するためのSMIデータモデルの効果の拡張にあるそれらのMIB、比較的一般的です。 BCP 111 [RFC4181]は、著者と査読のための詳細なガイダンスを提供しています。"
    },
    {
      "indent": 0,
      "text": "A.2. RADIUS Extensions",
      "ja": "A.2。 RADIUS拡張機能"
    },
    {
      "indent": 3,
      "text": "The RADIUS [RFC2865] protocol was designed to be extensible via addition of Attributes. This extensibility model assumed that Attributes would conform to a limited set of data types and that vendor extensions would be limited to use by vendors in situations in which interoperability was not required. Subsequent developments have stretched those assumptions.",
      "ja": "RADIUS [RFC2865]プロトコルは、属性の付加を介して拡張できるように設計されました。この拡張性モデルは、属性がデータ型の制限されたセットに準拠すると仮定し、そのベンダー拡張機能は、相互運用性が必要とされなかった状況でのベンダーが使用するように制限されます。その後の開発は、これらの仮定を伸ばしてきました。"
    },
    {
      "indent": 3,
      "text": "From the beginning, uses of the RADIUS protocol extended beyond the scope of the original protocol definition (and beyond the scope of the RADIUS Working Group charter). In addition to rampant self-allocation within the limited RADIUS standard attribute space, vendors defined their own RADIUS commands. This led to the rapid proliferation of vendor-specific protocol variants. To this day, many common implementation practices have not been documented. For example, authentication server implementations are often typically based on a Data Dictionary, enabling addition of Attributes without requiring code changes. Yet, the concept of a Data Dictionary is not mentioned in the RADIUS specification [RFC2865].",
      "ja": "当初から、オリジナルのプロトコル定義（およびRADIUSワーキンググループ憲章の範囲を超えて）の範囲を超えて拡張RADIUSプロトコルを使用しています。限られたRADIUS標準属性空間内で横行自己割り当てに加えて、ベンダーは、独自のRADIUSコマンドを定義しました。これは、ベンダー固有のプロトコルの変種の急速な普及につながりました。この日に、多くの一般的な実装プラクティスは文書化されていません。例えば、認証サーバの実装は、しばしば、典型的には、コードの変更を必要とせずに、属性の付加を可能にする、データ辞書に基づいています。しかし、データ・ディクショナリの概念は、RADIUS仕様[RFC2865]に記載されていません。"
    },
    {
      "indent": 3,
      "text": "As noted in \"Extended RADIUS Practices\" [RFC2882], Section 1:",
      "ja": "\"拡張RADIUSプラクティス\" で述べたように、[RFC2882]、セクション1："
    },
    {
      "indent": 6,
      "text": "The RADIUS Working Group was formed in 1995 to document the protocol of the same name, and was chartered to stay within a set of bounds for dial-in terminal servers. Unfortunately the real world of Network Access Servers (NASes) hasn't stayed that small and simple, and continues to evolve at an amazing rate.",
      "ja": "RADIUSワーキンググループは、同じ名前のプロトコルを文書化するために1995年に結成された、およびダイヤルインターミナルサーバーの境界のセット内に収まるようにチャーターされました。残念ながら、ネットワークアクセスサーバー（NASの）の現実の世界は、小型でシンプルな滞在、と驚くほどの速度で進化し続けていません。"
    },
    {
      "indent": 6,
      "text": "This document shows some of the current implementations on the market have already outstripped the capabilities of the RADIUS protocol. A quite a few features have been developed completely outside the protocol. These features use the RADIUS protocol structure and format, but employ operations and semantics well beyond the RFC documents.",
      "ja": "この文書では、市場での現在の実装のいくつかは、すでにRADIUSプロトコルの能力を凌駕している示しています。かなりの数の機能は、プロトコルの外に完全に開発されています。これらの機能は、RADIUSプロトコルの構造と形式を使用しますが、うまくRFC文書を超えて操作とセマンティクスを採用しています。"
    },
    {
      "indent": 3,
      "text": "The limited set of data types defined in the RADIUS specification [RFC2865] led to subsequent documents defining new data types. Since new data types are typically defined implicitly as part of defining a new attribute and because RADIUS client and server implementations differ in their support of these additional specifications, there is no definitive registry of RADIUS data types, and data type support has been inconsistent. To catalog commonly implemented data types as well as to provide guidance for implementers and attribute designers, Section 2.1 of \"RADIUS Design Guidelines\" [RFC6158] includes advice on basic and complex data types. Unfortunately, these guidelines [RFC6158] were published in 2011, 14 years after the RADIUS protocol was first documented [RFC2058] in 1997.",
      "ja": "RADIUS仕様[RFC2865]で定義されたデータ型の制限されたセットは、新しいデータ型を定義し、後続の文書につながりました。新しいデータ型は、一般的に新しい属性を定義すると、RADIUSクライアントとサーバの実装は、これらの追加仕様の彼らのサポートが異なるため一部として暗黙的に定義されているので、そこにRADIUSのデータ型の決定的な、レジストリではなく、データ型のサポートは、矛盾してきました。一般的に実装されているデータの種類をカタログするだけでなく、実装および属性デザイナーのためのガイダンスを提供するために、「RADIUS設計ガイドライン」のセクション2.1 [RFC6158]は、基本的で複雑なデータ型のアドバイスが含まれています。残念ながら、これらのガイドライン[RFC6158]はRADIUSプロトコルは最初に1997年に[RFC2058]を文書化した14年後、2011年に出版されました。"
    },
    {
      "indent": 3,
      "text": "Section 6.2 of the RADIUS specification [RFC2865] defines a mechanism for Vendor-Specific extensions (Attribute 26) and states that use of Vendor-Specific extensions:",
      "ja": "RADIUS仕様のセクション6.2 [RFC2865]はベンダー固有の拡張子（項目26）ためのメカニズムを定義し、ベンダー固有の拡張子の使用を述べて。"
    },
    {
      "indent": 6,
      "text": "should be encouraged instead of allocation of global attribute types, for functions specific only to one vendor's implementation of RADIUS, where no interoperability is deemed useful.",
      "ja": "唯一何の相互運用性が有用であると考えていないRADIUS、のいずれかのベンダーの実装に特定の機能のために、代わりにグローバル属性タイプの割り当てを奨励されるべきです。"
    },
    {
      "indent": 3,
      "text": "However, in practice, usage of Vendor-Specific Attributes (VSAs) has been considerably broader than this. In particular, VSAs have been used by Standards Development Organizations (SDOs) to define their own extensions to the RADIUS protocol. This has caused a number of problems.",
      "ja": "しかし、実際には、ベンダー固有アトリビュート（VSA）の使用量はこれよりもかなり広いとなっています。具体的には、VSAがRADIUSプロトコルに、独自の拡張を定義するための標準開発機関（SDOの）で使用されています。これは多くの問題を引き起こしています。"
    },
    {
      "indent": 3,
      "text": "One issue concerns the data model for VSAs. Since it was not envisaged that multi-vendor VSA implementations would need to interoperate, the RADIUS specification [RFC2865] does not define the data model for VSAs and allows multiple sub-attributes to be included within a single Attribute of type 26. Since this enables VSAs to be defined that would not be supportable by current implementations if placed within the standard RADIUS attribute space, this has caused problems in standardizing widely deployed VSAs, as discussed in Section 2.4 of \"RADIUS Design Guidelines\" BCP 158 [RFC6158]:",
      "ja": "1つの問題は、VSAのためのデータモデルに関するものです。それは、マルチベンダーVSA実装が相互運用する必要があることが想定されていなかったので、RADIUS仕様[RFC2865]はVSAのためのデータモデルを定義し、複数のできない、これはできるのでタイプ26の単一の属性内に含まれるサブアトリビュート「RADIUS設計ガイドライン」BCP 158 [RFC6158]のセクション2.4で説明したように、標準のRADIUS属性空間内に配置した場合、現在の実装でサポート可能ではないであろうように定義されるVSAが、これは、広く展開されているVSAを標準化する際に問題が発生しています："
    },
    {
      "indent": 6,
      "text": "RADIUS attributes can often be developed within the vendor space without loss (and possibly even with gain) in functionality. As a result, translation of RADIUS attributes developed within the vendor space into the standard space may provide only modest benefits, while accelerating the exhaustion of the standard space. We do not expect that all RADIUS attribute specifications requiring interoperability will be developed within the IETF, and allocated from the standard space. A more scalable approach is to recognize the flexibility of the vendor space, while working toward improvements in the quality and availability of RADIUS attribute specifications, regardless of where they are developed.",
      "ja": "RADIUS属性は、多くの場合、機能的に（そしておそらくさえゲインを持つ）を失うことなく、ベンダーのスペース内で開発することができます。標準空間の枯渇を加速しながらその結果、標準の空間に、ベンダーのスペース内で開発RADIUS属性の翻訳は、わずかな利点を提供することができます。私たちは、相互運用性を必要とするすべてのRADIUS属性の仕様は、IETF内で開発、および標準の空間から割り当てされることを期待していません。よりスケーラブルなアプローチは関係なく、それらが開発されている場合の、RADIUS属性の仕様の品質と可用性の改善に向かって仕事をしながら、ベンダースペースの柔軟性を認識することです。"
    },
    {
      "indent": 6,
      "text": "It is therefore NOT RECOMMENDED that specifications intended solely for use by a vendor or SDO be translated into the standard space.",
      "ja": "したがって、単にベンダーやSDOが使用するためのものな仕様は、標準的なスペースに翻訳することはお勧めしません。"
    },
    {
      "indent": 3,
      "text": "Another issue is how implementations should handle unknown VSAs. Section 5.26 of the RADIUS specification [RFC2865] states:",
      "ja": "もう一つの問題は、実装は、未知のVSAを処理する方法です。 RADIUS仕様[RFC2865]のセクション5.26状態："
    },
    {
      "indent": 6,
      "text": "Servers not equipped to interpret the vendor-specific information sent by a client MUST ignore it (although it may be reported). Clients which do not receive desired vendor-specific information SHOULD make an attempt to operate without it, although they may do so (and report they are doing so) in a degraded mode.",
      "ja": "（それは報告されてもよいが）クライアントから送信されたベンダー固有の情報を解釈するために装備されていないサーバはそれを無視しなければなりません。希望ベンダー固有の情報を受信して​​いないクライアントは、彼らがそうする（と彼らがそうしているレポート）かもしれないが劣化モードで、それなしで動作を試みます。"
    },
    {
      "indent": 3,
      "text": "However, since VSAs do not contain a \"mandatory\" bit, RADIUS clients and servers may not know whether it is safe to ignore unknown VSAs. For example, in the case where VSAs pertain to security (e.g., Filters), it may not be safe to ignore them. As a result, Section 2.5 of \"Common Remote Authentication Dial In User Service (RADIUS) Implementation Issues and Suggested Fixes\" [RFC5080] includes the following caution:",
      "ja": "VSAのは「必須」ビットを含んでいないので、RADIUSクライアントとサーバは、未知のVSAを無視しても安全であるかどうか知らないかもしれません。例えば、VSAのセキュリティ（例えば、フィルター）に関連する場合には、それらを無視することは安全ではないかもしれません。その結果、「ユーザーサービス（RADIUS）の実装の問題と推奨修正に共通のリモート認証ダイヤルイン」のセクション2.5 [RFC5080]は、以下の注意が含まれています。"
    },
    {
      "indent": 6,
      "text": "To avoid misinterpretation of service requests encoded within VSAs, RADIUS servers SHOULD NOT send VSAs containing service requests to RADIUS clients that are not known to understand them. For example, a RADIUS server should not send a VSA encoding a filter without knowledge that the RADIUS client supports the VSA.",
      "ja": "VSAの中にエンコードされたサービス要求の誤解を避けるために、RADIUSサーバは、それらを理解することが知られていないRADIUSクライアントへのサービス要求を含むVSAを送るべきではありません。たとえば、RADIUSサーバは、RADIUSクライアントはVSAをサポートしていることを知ることなくフィルタをコードするVSAを送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "In addition to extending RADIUS by use of VSAs, SDOs have also defined new values of the Service-Type attribute in order to create new RADIUS commands. Since the RADIUS specification [RFC2865] defined Service-Type values as being allocated First Come, First Served (FCFS) [RFC5226], this permitted new RADIUS commands to be allocated without IETF review. This oversight has since been fixed in \"IANA Considerations for RADIUS\" [RFC3575].",
      "ja": "VSAを使用してRADIUSを拡張することに加えて、SDOのは、新しいRADIUSコマンドを作成するために、service-type属性の新しい値を定義しています。 RADIUS仕様[RFC2865]が最初に来て割り当てられるようにサービスタイプ値を定義以来（FCFS）[RFC5226]を務め、これは新しいRADIUSは、IETFレビューなしで割り当てられるコマンドを許可しました。この監視は、以降、「RADIUSのIANAの考慮事項」[RFC3575]に固定されています。"
    },
    {
      "indent": 0,
      "text": "A.3. TLS Extensions",
      "ja": "A.3。 TLS拡張機能"
    },
    {
      "indent": 3,
      "text": "The Secure Sockets Layer (SSL) Version 2 Protocol was developed by Netscape to be used to secure online transactions on the Internet. It was later replaced by SSLv3, also developed by Netscape. SSLv3 was then further developed by the IETF as the Transport Layer Security (TLS) 1.0 [RFC2246].",
      "ja": "インターネット上のオンライン取引を確保するために使用されるのSecure Sockets Layer（SSL）バージョン2プロトコルは、Netscapeが開発されました。それは、後にも、Netscapeが開発した、のSSLv3に置き換えられました。 SSLv3はその後、さらにトランスポート層セキュリティ（TLS）1.0 [RFC2246]としてIETFによって開発されました。"
    },
    {
      "indent": 3,
      "text": "The SSLv3 protocol was not explicitly specified to be extended. Even TLS 1.0 did not define an extension mechanism explicitly. However, extension \"loopholes\" were available. Extension mechanisms were finally defined in \"Transport Layer Security (TLS) Extensions\" [RFC4366]:",
      "ja": "SSLv3プロトコルを明示的に拡張することが指定されていませんでした。でも、TLS 1.0が明示的に拡張メカニズムを定義していませんでした。しかし、拡張子「抜け穴」は利用可能でした。拡張メカニズムは、最終的には、「トランスポート層セキュリティ（TLS）拡張機能」[RFC4366]で定義されていました。"
    },
    {
      "indent": 6,
      "text": "o New versions o New cipher suites o Compression o Expanded handshake messages o New record types o New handshake messages",
      "ja": "新しいハンドシェイクメッセージOの新しいレコードタイプO拡張ハンドシェイクメッセージO圧縮の新しい暗号スイートの新バージョンO"
    },
    {
      "indent": 3,
      "text": "The protocol also defines how implementations should handle unknown extensions.",
      "ja": "また、このプロトコルは、実装が未知の拡張を処理する方法を定義します。"
    },
    {
      "indent": 3,
      "text": "Of the above extension methods, new versions and expanded handshake messages have caused the most interoperability problems. Implementations are supposed to ignore unknown record types but to reject unknown handshake messages.",
      "ja": "上記の拡張方法のうち、新しいバージョンと拡張ハンドシェイクメッセージは、ほとんどの相互運用性の問題を引き起こしています。実装は、未知のレコードタイプを無視するのではなく、未知のハンドシェイクメッセージを拒否するようになっています。"
    },
    {
      "indent": 3,
      "text": "The new version support in SSL/TLS includes a capability to define new versions of the protocol, while allowing newer implementations to communicate with older implementations. As part of this functionality, some Key Exchange methods include functionality to prevent version rollback attacks.",
      "ja": "新しい実装が古い実装と通信することを可能にしながら、SSL / TLSに新しいバージョンのサポートは、プロトコルの新しいバージョンを定義する能力を含みます。この機能の一部として、いくつかの鍵交換方法は、バージョンロールバック攻撃を防ぐための機能が含まれています。"
    },
    {
      "indent": 3,
      "text": "The experience with this upgrade functionality in SSL and TLS is decidedly mixed:",
      "ja": "SSLやTLSでこのアップグレード機能を搭載した経験が明らかに混合されます。"
    },
    {
      "indent": 6,
      "text": "o SSLv2 and SSLv3/TLS are not compatible. It is possible to use SSLv2 protocol messages to initiate an SSLv3/TLS connection, but it is not possible to communicate with an SSLv2 implementation using SSLv3/TLS protocol messages. o There are implementations that refuse to accept handshakes using newer versions of the protocol than they support. o There are other implementations that accept newer versions but have implemented the version rollback protection clumsily.",
      "ja": "OのSSLv2とのSSLv3 / TLSは互換性がありません。のSSLv3 / TLS接続を開始するためのSSLv2プロトコルメッセージを使用することが可能であるが、のSSLv3 / TLSプロトコルメッセージを使用して、SSLv2の実装と通信することができません。 Oがサポートするよりも、プロトコルの新しいバージョンを使用して握手を受け入れることを拒否実装があります。 O新しいバージョンを受け入れるが、不器用バージョンのロールバック保護を実施している他の実装があります。"
    },
    {
      "indent": 3,
      "text": "The SSLv2 problem has forced SSLv3 and TLS clients to continue to use SSLv2 Client Hellos for their initial handshake with almost all servers until 2006, much longer than would have been desirable, in order to interoperate with old servers.",
      "ja": "SSLv2の問題は、古いサーバとの相互運用するためには、はるかに長いことが望まれているであろうよりも、2006年まで、ほぼすべてのサーバーとの最初のハンドシェイクのためのSSLv2クライアントhelloを引き続き使用するのSSLv3およびTLSクライアントを余儀なくされました。"
    },
    {
      "indent": 3,
      "text": "The problem with incorrect handling of newer versions has also forced many clients to actually disable the newer protocol versions, either by default or by automatically disabling the functionality, to be able to connect to such servers. Effectively, this means that the version rollback protection in SSL and TLS is non-existent if talking to a fatally compromised older version.",
      "ja": "新しいバージョンの間違ったハンドリングの問題は、実際に、このようなサーバーに接続できるようにするには、デフォルトで、または自動的に機能を無効にすることで、どちらか、より新しいプロトコルバージョンを無効にするには、多くのクライアントを余儀なくされました。事実上、これは致命的に損なわ古いバージョンに話している場合、SSLおよびTLSにおけるバージョン・ロールバックの保護が存在しないことを意味しています。"
    },
    {
      "indent": 3,
      "text": "SSLv3 and TLS also permitted extension of the Client Hello and Server Hello handshake messages. This functionality was fully defined by the introduction of TLS extensions, which make it possible to add new functionality to the handshake, such as the name of the server the client is connecting to, request certificate status information, and indicate Certificate Authority support, maximum record length, etc. Several of these extensions also introduce new handshake messages.",
      "ja": "SSLv3およびTLSは、クライアントこんにちは、サーバーのHelloハンドシェイクメッセージの拡張を可能にしました。この機能は完全には、そのようなクライアントが接続しているサーバーの名前として、握手に新しい機能を追加することを可能にするTLS拡張の導入によって定義された証明書ステータス情報を要求し、認証局のサポートを示す、最大レコードましたこれらの拡張機能のいくつかの長さなども、新しいハンドシェイクメッセージをご紹介します。"
    },
    {
      "indent": 3,
      "text": "It has turned out that many SSLv3 and TLS implementations that do not support TLS extensions did not ignore the unknown extensions, as required by the protocol specifications, but instead failed to establish connections. Since several of the implementations behaving in this manner are used by high-profile Internet sites, such as online banking sites, this has caused a significant delay in the deployment of clients supporting TLS extensions, and several of the clients that have enabled support are using heuristics that allow them to disable the functionality when they detect a problem.",
      "ja": "これは、プロトコル仕様で要求されるTLS拡張をサポートしていない多くのSSLv3とTLSの実装は、未知の拡張子を無視していなかったことが判明し、代わりに接続を確立するために失敗しました。このように振る舞うの実装のいくつかは、オンラインバンキングサイトなど知名度の高いインターネットサイトで使用されているので、これはTLS拡張をサポートするクライアントの展開で大幅な遅延が発生している、とサポートを有効にしているクライアントのいくつかは、使用しています彼らは問題を検出したときにそれらが機能を無効にすることができヒューリスティック。"
    },
    {
      "indent": 3,
      "text": "Looking forward, the protocol version problem, in particular, can cause future security problems for the TLS protocol. The strength of the digest algorithms (MD5 and SHA-1) used by SSL and TLS is weakening. If MD5 and SHA-1 weaken to the point where it is feasible to mount successful attacks against older SSL and TLS versions, the current error recovery used by clients would become a security vulnerability (among many other serious problems for the Internet).",
      "ja": "楽しみにして、プロトコルバージョンの問題は、特に、TLSプロトコルの将来のセキュリティ上の問題を引き起こす可能性があります。 SSLおよびTLSで使用されるダイジェストアルゴリズム（MD5とSHA-1）の強度を弱めています。 MD5とSHA-1は、古いSSLとTLSのバージョンに対する攻撃が成功をマウントすることが可能である点まで弱めている場合、クライアントが使用する現在のエラー回復は、（インターネットのための他の多くの深刻な問題の中で）セキュリティ上の脆弱性となります。"
    },
    {
      "indent": 3,
      "text": "To address this issue, TLS 1.2 [RFC5246] makes use of a newer cryptographic hash algorithm (SHA-256) during the TLS handshake by default. Legacy ciphersuites can still be used to protect application data, but new ciphersuites are specified for data protection as well as for authentication within the TLS handshake. The hashing method can also be negotiated via a Hello extension. Implementations are encouraged to implement new ciphersuites and to enable the negotiation of the ciphersuite used during a TLS session to be governed by policy, thus enabling a more rapid transition away from weakened ciphersuites.",
      "ja": "この問題に対処するために、TLS 1.2 [RFC5246]は、デフォルトでTLSハンドシェイク中に、新しい暗号学的ハッシュアルゴリズム（SHA-256）を使用しています。レガシー暗号スイートは、まだアプリケーションデータを保護するために使用することができますが、新しい暗号スイートは、データ保護のためだけでなく、TLSハンドシェイク内での認証のために指定されています。ハッシュ方式は、また、ハロー拡張子を経由して交渉することができます。実装は、新しい暗号スイートを実装するので、離れて弱体化暗号スイートから、より迅速な移行を可能にするポリシーによって管理されるTLSセッション中に使用暗号スイートのネゴシエーションを有効にすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The lesson to be drawn from this experience is that it isn't sufficient to design extensibility carefully; it must also be implemented carefully by every implementer, without exception. Test suites and certification programs can help provide incentives for implementers to pay attention to implementing extensibility mechanisms correctly.",
      "ja": "この経験から引き出される教訓は、慎重に拡張性を設計するのに十分ではないということです。それはまた、例外なく、すべての実装によって慎重に実装する必要があります。テストスイートと認定プログラムが正常に拡張メカニズムを実装するに注意を払うために実装のためのインセンティブを提供することができます。"
    },
    {
      "indent": 0,
      "text": "A.4. L2TP Extensions",
      "ja": "A.4。 L2TP拡張機能"
    },
    {
      "indent": 3,
      "text": "The Layer Two Tunneling Protocol (L2TP) [RFC2661] carries Attribute-Value Pairs (AVPs), with most AVPs having no semantics to the L2TP protocol itself. However, it should be noted that L2TP message types are identified by a Message Type AVP (Attribute Type 0) with specific AVP values indicating the actual message type. Thus, extensions relating to Message Type AVPs would likely be considered major extensions.",
      "ja": "レイヤ2トンネリングプロトコル（L2TP）[RFC2661]ほとんどのAVPは、L2TPプロトコル自体に全く意味を持たないと属性値ペア（AVPを）、運びます。しかし、L2TPメッセージタイプは、実際のメッセージ・タイプを示す特定のAVP値を持つメッセージタイプAVP（属性タイプ0）によって識別されることに留意すべきです。このように、メッセージタイプのAVPに関連する拡張は、おそらく主要な拡張と考えられます。"
    },
    {
      "indent": 3,
      "text": "L2TP also provides for vendor-specific AVPs. Because everything in L2TP is encoded using AVPs, it would be easy to define vendor-specific AVPs that would be considered major extensions.",
      "ja": "L2TPはまた、ベンダー固有のAVPのために用意されています。 L2TPですべてがAVPを使用してエンコードされているので、主要な拡張と考えられるベンダー固有AVPを定義するのは簡単だろう。"
    },
    {
      "indent": 3,
      "text": "L2TP also provides for a \"mandatory\" bit in AVPs. Recipients of L2TP messages containing AVPs that they do not understand but that have the mandatory bit set, are expected to reject the message and terminate the tunnel or session the message refers to. This leads to interesting interoperability issues, because a sender can include a vendor-specific AVP with the M-bit set, which then causes the recipient to not interoperate with the sender. This sort of behavior is counter to the IETF ideals, as implementations of the IETF standard should interoperate successfully with other implementations and not require the implementation of non-IETF extensions in order to interoperate successfully. Section 4.2 of the L2TP specification [RFC2661] includes specific wording on this point, though there was significant debate at the time as to whether such language was by itself sufficient.",
      "ja": "L2TPはまた、AVPの中に「必須」ビットのために用意されています。彼らは理解していないが、それは必須のビットセットを有するAVPを含むL2TPメッセージの受信者は、メッセージを拒否し、メッセージが参照するトンネルまたはセッションを終了することが期待されます。送信者は送信者と相互運用しないように受信者の原因となるMビットのセット、とベンダー固有AVPを含めることができますので、これは、興味深い相互運用性の問題につながります。 IETF標準の実装が正常に相互運用するために、非IETFの拡張機能の実装を必要とする他の実装と正常に相互運用してはならないとして、行動のこの種は、IETFの理想に反するです。そのような言語は、それ自体で十分であったかどうかの時点で有意な議論があったもののL2TP仕様[RFC2661]のセクション4.2は、この点について具体的な文言を含んでいます。"
    },
    {
      "indent": 3,
      "text": "Fortunately, it does not appear that the potential problems described above have yet become a problem in practice. At the time of this writing, the authors are not aware of the existence of any vendor-specific AVPs that also set the M-bit.",
      "ja": "幸いなことに、上記の潜在的な問題は、まだ実際に問題になっていることが表示されません。この記事の執筆時点では、著者らはまた、Mビットをセットベンダー固有のAVPの存在に気づいていません。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Brian Carpenter Department of Computer Science University of Auckland PB 92019 Auckland, 1142 New Zealand",
      "ja": "オークランドPB 92019オークランド、1142年ニュージーランドのコンピュータサイエンス大学のブライアン・カーペンター部門"
    },
    {
      "indent": 3,
      "text": "EMail: brian.e.carpenter@gmail.com",
      "ja": "メールアドレス：brian.e.carpenter@gmail.com"
    },
    {
      "indent": 3,
      "text": "Bernard Aboba (editor) PMB 606 15600 NE 8th Street, Suite B1 Bellevue, WA 98008 USA",
      "ja": "バーナードAboba（エディタ）PMB 606、15600 NE 8thストリート、スイートB1ベルビュー、WA 98008 USA"
    },
    {
      "indent": 3,
      "text": "EMail: bernard_aboba@hotmail.com",
      "ja": "メールアドレス：bernard_aboba@hotmail.com"
    },
    {
      "indent": 3,
      "text": "Stuart Cheshire Apple Inc. 1 Infinite Loop Cupertino, CA 95014 USA",
      "ja": "スチュアートチェシャーれたApple Inc. 1無限ループクパチーノ、CA 95014 USA"
    },
    {
      "indent": 3,
      "text": "EMail: cheshire@apple.com",
      "ja": "メールアドレス：cheshire@apple.com"
    }
  ]
}