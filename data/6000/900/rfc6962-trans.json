{
  "title": {
    "text": "RFC 6962 - Certificate Transparency",
    "ja": "RFC 6962 - 証明書の透明性"
  },
  "number": 6962,
  "created_at": "2019-11-02 05:48:12.187136+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         B. Laurie\nRequest for Comments: 6962                                    A. Langley\nCategory: Experimental                                         E. Kasper\nISSN: 2070-1721                                                   Google\n                                                               June 2013",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Certificate Transparency",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes an experimental protocol for publicly logging the existence of Transport Layer Security (TLS) certificates as they are issued or observed, in a manner that allows anyone to audit certificate authority (CA) activity and notice the issuance of suspect certificates as well as to audit the certificate logs themselves. The intent is that eventually clients would refuse to honor certificates that do not appear in a log, effectively forcing CAs to add all issued certificates to the logs.",
      "ja": "この文書では、彼らはだけでなく、誰もが容疑者証明書の発行を認証局（CA）の活動を監査し、気づくことを可能にする方法で、発行または観察されるような公にトランスポート層セキュリティ（TLS）証明書の存在を記録するための実験プロトコルを記述します証明書のログそのものを監査します。その意図は、最終的にはクライアントが効果的にログにすべて発行された証明書を追加するCAを強制的に、ログに表示されていない証明書を尊重することを拒否だろうということです。"
    },
    {
      "indent": 3,
      "text": "Logs are network services that implement the protocol operations for submissions and queries that are defined in this document.",
      "ja": "ログは、この文書で定義されている提出し、クエリのためのプロトコル動作を実現するネットワークサービスです。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6962.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6962で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Informal Introduction ...........................................3\n   1.1. Requirements Language ......................................4\n   1.2. Data Structures ............................................4\n2. Cryptographic Components ........................................4\n   2.1. Merkle Hash Trees ..........................................4\n        2.1.1. Merkle Audit Paths ..................................5\n        2.1.2. Merkle Consistency Proofs ...........................6\n        2.1.3. Example .............................................7\n        2.1.4. Signatures ..........................................8\n3. Log Format and Operation ........................................9\n   3.1. Log Entries ................................................9\n   3.2. Structure of the Signed Certificate Timestamp .............12\n   3.3. Including the Signed Certificate Timestamp in the\n        TLS Handshake .............................................13\n        3.3.1. TLS Extension ......................................15\n   3.4. Merkle Tree ...............................................15\n   3.5. Signed Tree Head ..........................................16\n4. Log Client Messages ............................................17\n   4.1. Add Chain to Log ..........................................17\n   4.2. Add PreCertChain to Log ...................................18\n   4.3. Retrieve Latest Signed Tree Head ..........................18\n   4.4. Retrieve Merkle Consistency Proof between Two\n        Signed Tree Heads .........................................19\n   4.5. Retrieve Merkle Audit Proof from Log by Leaf Hash .........19\n   4.6. Retrieve Entries from Log .................................20\n   4.7. Retrieve Accepted Root Certificates .......................21\n   4.8. Retrieve Entry+Merkle Audit Proof from Log ................21\n5. Clients ........................................................21\n   5.1. Submitters ................................................22\n   5.2. TLS Client ................................................22\n   5.3. Monitor ...................................................22",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   5.4. Auditor ...................................................23\n6. IANA Considerations ............................................23\n7. Security Considerations ........................................23\n   7.1. Misissued Certificates ....................................24\n   7.2. Detection of Misissue .....................................24\n   7.3. Misbehaving Logs ..........................................24\n8. Efficiency Considerations ......................................25\n9. Future Changes .................................................25\n10. Acknowledgements ..............................................25\n11. References ....................................................25\n   11.1. Normative Reference ......................................25\n   11.2. Informative References ...................................26",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Informal Introduction",
      "section_title": true,
      "ja": "1.非公式はじめに"
    },
    {
      "indent": 3,
      "text": "Certificate transparency aims to mitigate the problem of misissued certificates by providing publicly auditable, append-only, untrusted logs of all issued certificates. The logs are publicly auditable so that it is possible for anyone to verify the correctness of each log and to monitor when new certificates are added to it. The logs do not themselves prevent misissue, but they ensure that interested parties (particularly those named in certificates) can detect such misissuance. Note that this is a general mechanism, but in this document, we only describe its use for public TLS server certificates issued by public certificate authorities (CAs).",
      "ja": "証明書の透明性は、公的監査提供することで、すべての発行された証明書の追加のみ、信頼されていないログをmisissued証明書の問題を軽減することを目指しています。誰もがそれぞれのログの正しさを検証するために、新たな証明書がそれに追加されたときに監視することが可能であるようにログが公に監査可能です。ログ自体はmisissueを防ぐことはできませんが、利害関係者（証明書で指定された特に）は、このようなmisissuanceを検出することができることを確認してください。これは一般的なメカニズムですが、この文書では、我々は唯一の公共証明機関（CA）が発行した公開TLSサーバ証明書のためのその使用を記載していることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Each log consists of certificate chains, which can be submitted by anyone. It is expected that public CAs will contribute all their newly issued certificates to one or more logs; it is also expected that certificate holders will contribute their own certificate chains. In order to avoid logs being spammed into uselessness, it is required that each chain is rooted in a known CA certificate. When a chain is submitted to a log, a signed timestamp is returned, which can later be used to provide evidence to clients that the chain has been submitted. TLS clients can thus require that all certificates they see have been logged.",
      "ja": "各ログは誰でも提出することができる証明書チェーン、から構成されています。パブリックCAが1つ以上のログにすべての彼らの新たに発行された証明書を貢献することが期待されます。また、証明書の所有者が自分自身の証明書チェーンに貢献することが期待されます。無駄にスパムされているログを回避するために、それぞれの鎖は、既知のCA証明書に根ざしていることが必要です。チェーンがログに提出された場合、署名のタイムスタンプは、後にチェーンが送信されたクライアントに証拠を提供するために使用することができ、返されます。 TLSクライアントは、このように、彼らが見たすべての証明書が記録されていることを要求することができます。"
    },
    {
      "indent": 3,
      "text": "Those who are concerned about misissue can monitor the logs, asking them regularly for all new entries, and can thus check whether domains they are responsible for have had certificates issued that they did not expect. What they do with this information, particularly when they find that a misissuance has happened, is beyond the scope of this document, but broadly speaking, they can invoke existing business mechanisms for dealing with misissued certificates. Of course, anyone who wants can monitor the logs and, if they believe a certificate is incorrectly issued, take action as they see fit.",
      "ja": "misissue心配している人は、すべての新しいエントリのために定期的にそれらを求めて、ログを監視することができ、したがって、彼らは、彼らが期待していなかったことに発行された証明書を持っていたために責任があるドメインかどうかを確認することができます。彼らはmisissuanceが起こっていることを見つける場合は特に、彼らは、この情報をどう、このドキュメントの範囲を超えていますが、大まかに言えば、彼らはmisissued証明書に対処するための既存のビジネスの仕組みを呼び出すことができます。彼らは、彼らが合うように行動を取る、証明書が不正に発行されたと考えている場合はもちろん、したい人には、ログを監視することができます。"
    },
    {
      "indent": 3,
      "text": "Similarly, those who have seen signed timestamps from a particular log can later demand a proof of inclusion from that log. If the log is unable to provide this (or, indeed, if the corresponding certificate is absent from monitors' copies of that log), that is evidence of the incorrect operation of the log. The checking operation is asynchronous to allow TLS connections to proceed without delay, despite network connectivity issues and the vagaries of firewalls.",
      "ja": "同様に、特定のログから署名されたタイムスタンプを見た人は、後にそのログから介在物の証拠を要求することができます。ログは、（対応する証明書は、そのログのモニターのコピーに存在しない場合に、実際に、または）これを提供できない場合、そのログの誤操作の証拠です。動作確認は、ネットワーク接続の問題やファイアウォールの気まぐれにもかかわらず、TLS接続が遅延なく進行させるために非同期です。"
    },
    {
      "indent": 3,
      "text": "The append-only property of each log is technically achieved using Merkle Trees, which can be used to show that any particular version of the log is a superset of any particular previous version. Likewise, Merkle Trees avoid the need to blindly trust logs: if a log attempts to show different things to different people, this can be efficiently detected by comparing tree roots and consistency proofs. Similarly, other misbehaviors of any log (e.g., issuing signed timestamps for certificates they then don't log) can be efficiently detected and proved to the world at large.",
      "ja": "各ログの追加のみプロパティは、技術ログの任意の特定のバージョンは、任意の特定の旧バージョンのスーパーセットであることを示すために使用することができるハッシュ木を用いて達成されます。同様に、ハッシュ木は盲目的に信頼ログへの必要性を回避：ログが、これは効率的に樹木の根と一貫性の証明を比較することによって検出することができ、さまざまな人々に異なった事を示してしようとした場合。同様に、任意のログの他の誤作動（例えば、それらは次にログインしない証明書の署名されたタイムスタンプを発行する）を効率的に検出し、広く世界に証明することができます。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Data Structures",
      "section_title": true,
      "ja": "1.2。データ構造"
    },
    {
      "indent": 3,
      "text": "Data structures are defined according to the conventions laid out in Section 4 of [RFC5246].",
      "ja": "データ構造は[RFC5246]のセクション4にレイアウト規則に従って定義されます。"
    },
    {
      "indent": 0,
      "text": "2. Cryptographic Components",
      "section_title": true,
      "ja": "2.暗号化コンポーネント"
    },
    {
      "indent": 0,
      "text": "2.1. Merkle Hash Trees",
      "section_title": true,
      "ja": "2.1。マークル・ハッシュ木"
    },
    {
      "indent": 3,
      "text": "Logs use a binary Merkle Hash Tree for efficient auditing. The hashing algorithm is SHA-256 [FIPS.180-4] (note that this is fixed for this experiment, but it is anticipated that each log would be able to specify a hash algorithm). The input to the Merkle Tree Hash is a list of data entries; these entries will be hashed to form the leaves of the Merkle Hash Tree. The output is a single 32-byte Merkle Tree Hash. Given an ordered list of n inputs, D[n] = {d(0), d(1), ..., d(n-1)}, the Merkle Tree Hash (MTH) is thus defined as follows:",
      "ja": "ログは、効率的な監査のためのバイナリマークル・ハッシュ木を使用しています。ハッシュアルゴリズムは、SHA-256 [FIPS.180-4]（これは、この実験のために固定されているが、各ログは、ハッシュアルゴリズムを指定することができるであろうことが予想されることに留意されたい）です。マークル木ハッシュへの入力は、データエントリのリストです。これらのエントリは、マークルハッシュツリーの葉を形成するためにハッシュされます。出力は、単一の32バイトのマークル木のハッシュです。 N個の入力の順序付けられたリストが与えられると、D [N] = {D（0）、D（1）、...、D（N-1）}次のように、マークル木ハッシュ（MTH）がこのように定義されます："
    },
    {
      "indent": 3,
      "text": "The hash of an empty list is the hash of an empty string:",
      "ja": "空のリストのハッシュは、空の文字列のハッシュです。"
    },
    {
      "indent": 3,
      "text": "MTH({}) = SHA-256().",
      "ja": "MTH（{}））SHA-256（="
    },
    {
      "indent": 3,
      "text": "The hash of a list with one entry (also known as a leaf hash) is:",
      "ja": "（また、リーフハッシュとして知られている）一つのエントリを有するリストのハッシュです。"
    },
    {
      "indent": 3,
      "text": "MTH({d(0)}) = SHA-256(0x00 || d(0)).",
      "ja": "MTH（{D（0）}）SHA-256（0x00の|| D（0））=。"
    },
    {
      "indent": 3,
      "text": "For n > 1, let k be the largest power of two smaller than n (i.e., k < n <= 2k). The Merkle Tree Hash of an n-element list D[n] is then defined recursively as",
      "ja": "N> 1の場合、kはnよりも小さい2の最大電力であるものとする（すなわち、K <N <=は2K）。 n要素のリストD [N]のマークル木ハッシュは次のように再帰的に定義されています"
    },
    {
      "indent": 3,
      "text": "MTH(D[n]) = SHA-256(0x01 || MTH(D[0:k]) || MTH(D[k:n])),",
      "ja": "MTH（D [N]）がSHA-256 =（0×01を|| MTH（D [0：K]）|| MTH（D [K：N]））、"
    },
    {
      "indent": 3,
      "text": "where || is concatenation and D[k1:k2] denotes the list {d(k1), d(k1+1),..., d(k2-1)} of length (k2 - k1). (Note that the hash calculations for leaves and nodes differ. This domain separation is required to give second preimage resistance.)",
      "ja": "どこ||連結およびD [K1：K2]はリスト{D（K1）、D（K1 + 1）、...、D（K2-1）}長さの（ -  K1、K2）です。 （このドメイン分離が第二プレイメージ抵抗を与えるために必要とされる。リーフノードのハッシュ計算が異なることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "Note that we do not require the length of the input list to be a power of two. The resulting Merkle Tree may thus not be balanced; however, its shape is uniquely determined by the number of leaves. (Note: This Merkle Tree is essentially the same as the history tree [CrosbyWallach] proposal, except our definition handles non-full trees differently.)",
      "ja": "我々は2の累乗であることを入力リストの長さを必要としないことに注意してください。得マークル木は、このようにバランスされなくてもよいです。しかし、その形状は、一意の葉の数によって決定されます。 （注：このマークル木は、基本的に歴史の木[CrosbyWallach]の提案と同じであり、私たちの定義が異なっ非フルの木を扱う点が異なります。）"
    },
    {
      "indent": 0,
      "text": "2.1.1. Merkle Audit Paths",
      "section_title": true,
      "ja": "2.1.1。マークル監査パス"
    },
    {
      "indent": 3,
      "text": "A Merkle audit path for a leaf in a Merkle Hash Tree is the shortest list of additional nodes in the Merkle Tree required to compute the Merkle Tree Hash for that tree. Each node in the tree is either a leaf node or is computed from the two nodes immediately below it (i.e., towards the leaves). At each step up the tree (towards the root), a node from the audit path is combined with the node computed so far. In other words, the audit path consists of the list of missing nodes required to compute the nodes leading from a leaf to the root of the tree. If the root computed from the audit path matches the true root, then the audit path is proof that the leaf exists in the tree.",
      "ja": "マークル・ハッシュツリー内のリーフのためのマークル監査経路は、そのツリーのためマークル木ハッシュを計算するために必要なマークル木における追加ノードの最短のリストです。ツリー内の各ノードはリーフノードであるか、またはすぐに（即ち、葉に向かって）下の2つのノードから計算されます。各（ルートに向かって）ツリーをステップアップで、監査の経路からのノードは、これまで計算ノードと結合されます。換言すれば、監査の経路は、ツリーのルートにリーフから先頭ノードを計算するのに必要な欠けているノードのリストから成ります。監査パスから計算ルートが真のルートと一致した場合、監査パスは葉が木に存在することを証明しています。"
    },
    {
      "indent": 3,
      "text": "Given an ordered list of n inputs to the tree, D[n] = {d(0), ..., d(n-1)}, the Merkle audit path PATH(m, D[n]) for the (m+1)th input d(m), 0 <= m < n, is defined as follows:",
      "ja": "ツリーにn個の入力の順序付きリストを与え、D [N] = {D（0）、...、D（N-1）}、マークル監査パスPATH（M、D [N]）のための（次のように入力d（m）を第m + 1）は、0 <= M <N、定義されます。"
    },
    {
      "indent": 3,
      "text": "The path for the single leaf in a tree with a one-element input list D[1] = {d(0)} is empty:",
      "ja": "1要素の入力リストDとツリー内の単一のリーフのための経路[1] = {D（0）}空です。"
    },
    {
      "indent": 3,
      "text": "PATH(0, {d(0)}) = {}",
      "ja": "PATH（0、{D（0）}）= {}"
    },
    {
      "indent": 3,
      "text": "For n > 1, let k be the largest power of two smaller than n. The path for the (m+1)th element d(m) in a list of n > m elements is then defined recursively as",
      "ja": "N> 1の場合、kはnよりも小さい2の最大電力とします。 n個のリストに（M + 1）番目の要素d（M）> M元素のパスは次のように再帰的に定義されています"
    },
    {
      "indent": 3,
      "text": "PATH(m, D[n]) = PATH(m, D[0:k]) : MTH(D[k:n]) for m < k; and",
      "ja": "PATH（M、D [N]）= PATH（M、D [0：K]）：MTH（D [K：N]）M <Kのため、そして"
    },
    {
      "indent": 3,
      "text": "PATH(m, D[n]) = PATH(m - k, D[k:n]) : MTH(D[0:k]) for m >= k,",
      "ja": "PATH（M、D [N]）= PATH（M  -  K、D [K：N]）：MTH（D [0：K]）M> = kについて、"
    },
    {
      "indent": 3,
      "text": "where : is concatenation of lists and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.",
      "ja": "{D（K1）、D（K1 + 1）、...、D（K2-1）}リストとして前 -  [K2、K1]長さ（K1、K2）である：ここでリストとDの連結です。"
    },
    {
      "indent": 0,
      "text": "2.1.2. Merkle Consistency Proofs",
      "section_title": true,
      "ja": "2.1.2。マークル一貫性証明"
    },
    {
      "indent": 3,
      "text": "Merkle consistency proofs prove the append-only property of the tree. A Merkle consistency proof for a Merkle Tree Hash MTH(D[n]) and a previously advertised hash MTH(D[0:m]) of the first m leaves, m <= n, is the list of nodes in the Merkle Tree required to verify that the first m inputs D[0:m] are equal in both trees. Thus, a consistency proof must contain a set of intermediate nodes (i.e., commitments to inputs) sufficient to verify MTH(D[n]), such that (a subset of) the same nodes can be used to verify MTH(D[0:m]). We define an algorithm that outputs the (unique) minimal consistency proof.",
      "ja": "マークル一貫性の証明は、ツリーの追加専用プロパティを証明します。マークル木ハッシュMTH（D [N]）のためのマークル一貫証明以前アドバタイズハッシュMTH（D [0：M]）最初のm個の葉、M <= Nは、マークル木におけるノードのリストであります最初のMがD [0：M]を入力することを確認するために必要な両方のツリーに等しいです。したがって、一貫性の証明は、MTHを確認するのに十分な中間ノード（すなわち、コミットメントの入力に）（D [N]）のセットを含んでいなければならない（のサブセット）は、同じノードがMTH（D [0を検証するために使用することができるよう：M]）。我々は（ユニーク）最小限の一貫性の証明を出力するアルゴリズムを定義します。"
    },
    {
      "indent": 3,
      "text": "Given an ordered list of n inputs to the tree, D[n] = {d(0), ..., d(n-1)}, the Merkle consistency proof PROOF(m, D[n]) for a previous Merkle Tree Hash MTH(D[0:m]), 0 < m < n, is defined as:",
      "ja": "前のツリー、D [N] = {D（0）、...、D（N-1）}、マークル一貫プルーフPROOF（M、D [N]）にN個の入力の順序付きリストを与えマークル木ハッシュMTH（D [0：M]）は、0 <M <N、次のように定義されます。"
    },
    {
      "indent": 3,
      "text": "PROOF(m, D[n]) = SUBPROOF(m, D[n], true)",
      "ja": "PROOF（M、D [N]）= SUBPROOF（M、D [n]は、TRUE）"
    },
    {
      "indent": 3,
      "text": "The subproof for m = n is empty if m is the value for which PROOF was originally requested (meaning that the subtree Merkle Tree Hash MTH(D[0:m]) is known):",
      "ja": "mに対するsubproof = N mは最初に要求された証明のための値である場合（：）が知られているサブツリーマークル木ハッシュMTH（D [M 0]ことを意味する）空です。"
    },
    {
      "indent": 3,
      "text": "SUBPROOF(m, D[m], true) = {}",
      "ja": "SUBPROOF（M、D [M]、TRUE）= {}"
    },
    {
      "indent": 3,
      "text": "The subproof for m = n is the Merkle Tree Hash committing inputs D[0:m]; otherwise:",
      "ja": "mに対するsubproof = nがマークル木ハッシュコミット入力D [0：M]です。そうでなければ："
    },
    {
      "indent": 3,
      "text": "SUBPROOF(m, D[m], false) = {MTH(D[m])}",
      "ja": "SUBPROOF（M、D [M]、偽）= {MTH（D [M]）}"
    },
    {
      "indent": 3,
      "text": "For m < n, let k be the largest power of two smaller than n. The subproof is then defined recursively.",
      "ja": "mについて<N、kはnよりも小さい2の最大電力とします。 subproofは、その後再帰的に定義されています。"
    },
    {
      "indent": 3,
      "text": "If m <= k, the right subtree entries D[k:n] only exist in the current tree. We prove that the left subtree entries D[0:k] are consistent and add a commitment to D[k:n]:",
      "ja": "M <= kの場合、右サブツリーエントリD [K：n]は、現在のツリーに存在します。一貫性があり、D [K：n]はへのコミットメントを追加します。私たちは、左のサブツリーのエントリD [K 0]があることを証明します："
    },
    {
      "indent": 3,
      "text": "SUBPROOF(m, D[n], b) = SUBPROOF(m, D[0:k], b) : MTH(D[k:n])",
      "ja": "SUBPROOF（M、D [n]は、B）= SUBPROOF（M、D [0：K]、B）：MTH（D [K：N]）"
    },
    {
      "indent": 3,
      "text": "If m > k, the left subtree entries D[0:k] are identical in both trees. We prove that the right subtree entries D[k:n] are consistent and add a commitment to D[0:k].",
      "ja": "もしM> K、左サブツリー項目D [0：k]は、両方の木において同一です。一貫性があり、D [0：K]へのコミットメントを追加します。私たちは、右のサブツリーのエントリD [N k]があることを証明します。"
    },
    {
      "indent": 3,
      "text": "SUBPROOF(m, D[n], b) = SUBPROOF(m - k, D[k:n], false) : MTH(D[0:k])",
      "ja": "SUBPROOF（M、D [n]は、B）= SUBPROOF（M  -  K、D [K：n]は、偽）：MTH（D [0：K]）"
    },
    {
      "indent": 3,
      "text": "Here, : is a concatenation of lists, and D[k1:k2] denotes the length (k2 - k1) list {d(k1), d(k1+1),..., d(k2-1)} as before.",
      "ja": "ここで、：リストの連結であり、D [K1：K2]は長さ（K2  -  K1）を示すリスト{D（K1）を、D（K1 + 1）、...、D（K2-1）}として前。"
    },
    {
      "indent": 3,
      "text": "The number of nodes in the resulting proof is bounded above by ceil(log2(n)) + 1.",
      "ja": "得られた証拠内のノードの数は、CEIL（LOG2（N））+ 1によって上記制限されます。"
    },
    {
      "indent": 0,
      "text": "2.1.3. Example",
      "section_title": true,
      "ja": "2.1.3。例"
    },
    {
      "indent": 3,
      "text": "The binary Merkle Tree with 7 leaves:",
      "ja": "7葉バイナリマークルツリー："
    },
    {
      "indent": 3,
      "text": " hash / \\ / \\ / \\ / \\ / \\ k l / \\ / \\ / \\ / \\ / \\ / \\ g h i j / \\ / \\ / \\ | a b c d e f d6 | | | | | | d0 d1 d2 d3 d4 d5",
      "ja": "ハッシュ/ \\ / \\ / \\ / \\ / \\ K 1 / \\ / \\ / \\ / \\ / \\ / \\ G、H、I、J / \\ / \\ / \\ | BのC D EがFのD6 | | | | | | D0 D1 D2 D3 D4 D5"
    },
    {
      "indent": 3,
      "text": "The audit path for d0 is [b, h, l].",
      "ja": "D0の監査経路は[B、H、L]です。"
    },
    {
      "indent": 3,
      "text": "The audit path for d3 is [c, g, l].",
      "ja": "D3の監査経路は[C、G、L]です。"
    },
    {
      "indent": 3,
      "text": "The audit path for d4 is [f, j, k].",
      "ja": "D4の監査経路は[F、J、K]です。"
    },
    {
      "indent": 3,
      "text": "The audit path for d6 is [i, k].",
      "ja": "D6の監査経路は[I、K]です。"
    },
    {
      "indent": 3,
      "text": "The same tree, built incrementally in four steps:",
      "ja": "4つのステップで漸増的に構築された同じツリー、："
    },
    {
      "indent": 3,
      "text": " hash0 hash1=k / \\ / \\ / \\ / \\ / \\ / \\ g c g h / \\ | / \\ / \\ a b d2 a b c d | | | | | | d0 d1 d0 d1 d2 d3",
      "ja": "hash0 HASH1 = K / \\ / \\ / \\ / \\ / \\ / \\ G C GはH / \\ | / \\ / \\ BはD = D2 B | | | | | | D0 D1 D0 D1 D2 D3"
    },
    {
      "indent": 3,
      "text": " hash2 hash / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ k i k l / \\ / \\ / \\ / \\ / \\ e f / \\ / \\ / \\ | | / \\ / \\ g h d4 d5 g h i j / \\ / \\ / \\ / \\ / \\ | a b c d a b c d e f d6 | | | | | | | | | | d0 d1 d2 d3 d0 d1 d2 d3 d4 d5",
      "ja": "HASH2ハッシュ/ \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ K Iのk個のL / \\ / \\ / \\ / \\ / \\ EのF / \\ / \\ / \\ | | / \\ / \\グラム時間のD4 D5 gはH I J / \\ / \\ / \\ / \\ / \\ | BはD = BのC D EがFのD6 | | | | | | | | | | D0、D1、D2、D3 D0 D1 D2 D3 D4 D5"
    },
    {
      "indent": 3,
      "text": "The consistency proof between hash0 and hash is PROOF(3, D[7]) = [c, d, g, l]. c, g are used to verify hash0, and d, l are additionally used to show hash is consistent with hash0.",
      "ja": "hash0とハッシュとの整合性の証明は、プルーフ（3、D [7]）= [C、D、G、L]です。 C、Gはhash0を検証するために使用され、そしてD、Lがさらにハッシュがhash0と一致して表示するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The consistency proof between hash1 and hash is PROOF(4, D[7]) = [l]. hash can be verified using hash1=k and l.",
      "ja": "HASH1とハッシュとの整合性の証明は、プルーフ（4、D [7]）= [L]です。ハッシュは、HASH1 = KおよびLを用いて検証することができます。"
    },
    {
      "indent": 3,
      "text": "The consistency proof between hash2 and hash is PROOF(6, D[7]) = [i, j, k]. k, i are used to verify hash2, and j is additionally used to show hash is consistent with hash2.",
      "ja": "HASH2とハッシュとの整合性の証明は、プルーフ（6、D [7]）= [I、J、K]です。 Kは、iがHASH2を検証するために使用され、そしてjがさらにハッシュがHASH2と一致して表示するために使用されます。"
    },
    {
      "indent": 0,
      "text": "2.1.4. Signatures",
      "section_title": true,
      "ja": "2.1.4。署名"
    },
    {
      "indent": 3,
      "text": "Various data structures are signed. A log MUST use either elliptic curve signatures using the NIST P-256 curve (Section D.1.2.3 of the Digital Signature Standard [DSS]) or RSA signatures (RSASSA-PKCS1- V1_5 with SHA-256, Section 8.2 of [RFC3447]) using a key of at least 2048 bits.",
      "ja": "様々なデータ構造が署名されています。ログまたはRSA署名（SHA-256とRSASSA-PKCS1- v1_5の、[RFC3447のセクション8.2 NIST P-256曲線（デジタル署名標準[DSS]のセクションD.1.2.3）を使用して楕円曲線署名のいずれかを使用しなければなりません]）は、少なくとも2048ビットのキーを使用して。"
    },
    {
      "indent": 0,
      "text": "3. Log Format and Operation",
      "section_title": true,
      "ja": "3.ログの形式と操作"
    },
    {
      "indent": 3,
      "text": "Anyone can submit certificates to certificate logs for public auditing; however, since certificates will not be accepted by TLS clients unless logged, it is expected that certificate owners or their CAs will usually submit them. A log is a single, ever-growing, append-only Merkle Tree of such certificates.",
      "ja": "誰もが公共の監査のための証明書のログに証明書を提出することができます。ログインしていない限り、証明書は、TLSクライアントによって受け付けられませんので、しかし、証明書の所有者またはそのCAは通常、それらを提出することが期待されます。ログには、証明書のシングル、成長を続ける、追加のみのマークル木です。"
    },
    {
      "indent": 3,
      "text": "When a valid certificate is submitted to a log, the log MUST immediately return a Signed Certificate Timestamp (SCT). The SCT is the log's promise to incorporate the certificate in the Merkle Tree within a fixed amount of time known as the Maximum Merge Delay (MMD). If the log has previously seen the certificate, it MAY return the same SCT as it returned before. TLS servers MUST present an SCT from one or more logs to the TLS client together with the certificate. TLS clients MUST reject certificates that do not have a valid SCT for the end-entity certificate.",
      "ja": "有効な証明書がログに送信されると、ログがすぐに署名証明書のタイムスタンプ（SCT）を返さなければなりません。 SCTは、最大マージ遅延（MMD）として知られている一定時間内マークルツリーで証明書を組み込むために、ログの約束です。ログは、以前に証明書を見ている場合、それは前に戻ったように、それは同じSCTを返す場合があります。 TLSサーバは、証明書と一緒にTLSクライアントへの1つ以上のログからSCTを提示しなければなりません。 TLSクライアントは、エンドエンティティ証明書の有効なSCTを持っていない証明書を拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Periodically, each log appends all its new entries to the Merkle Tree and signs the root of the tree. Auditors can thus verify that each certificate for which an SCT has been issued indeed appears in the log. The log MUST incorporate a certificate in its Merkle Tree within the Maximum Merge Delay period after the issuance of the SCT.",
      "ja": "定期的に、各ログは、マークル木にそのすべての新しいエントリを追加し、ツリーのルートに署名します。監査人は、このようにSCTが実際に発行された各証明書がログに表示されていることを確認することができます。ログには、SCTの発行後最大マージ遅延期間内にそのマークルツリーで証明書を組み込まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Log operators MUST NOT impose any conditions on retrieving or sharing data from the log.",
      "ja": "事業者は、ログからデータを取得するか、共有上の任意の条件を課してはならないログインしてください。"
    },
    {
      "indent": 0,
      "text": "3.1. Log Entries",
      "section_title": true,
      "ja": "3.1。ログエントリ"
    },
    {
      "indent": 3,
      "text": "Anyone can submit a certificate to any log. In order to enable attribution of each logged certificate to its issuer, the log SHALL publish a list of acceptable root certificates (this list might usefully be the union of root certificates trusted by major browser vendors). Each submitted certificate MUST be accompanied by all additional certificates required to verify the certificate chain up to an accepted root certificate. The root certificate itself MAY be omitted from the chain submitted to the log server.",
      "ja": "誰もが任意のログに証明書を提出することができます。その発行者に証明書を記録し、それぞれの帰属を可能にするために、ログが許容できるルート証明書（このリストは有効主要ブラウザベンダーによって信頼されたルート証明書の労働組合であるかもしれない）のリストを公表しなければなりません。各提出した証明書は受け入れられたルート証明書までの証明書チェーンを検証するために必要なすべての追加の証明書を添付しなければなりません。ルート証明書自体は、ログサーバに送信チェーンから省略されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Alternatively, (root as well as intermediate) certificate authorities may submit a certificate to logs prior to issuance. To do so, the CA submits a Precertificate that the log can use to create an entry that will be valid against the issued certificate. The Precertificate is constructed from the certificate to be issued by adding a special critical poison extension (OID 1.3.6.1.4.1.11129.2.4.3, whose extnValue OCTET STRING contains ASN.1 NULL data (0x05 0x00)) to the end-entity TBSCertificate (this extension is to ensure that the Precertificate cannot be validated by a standard X.509v3 client) and signing the resulting TBSCertificate [RFC5280] with either",
      "ja": "代替的に、（根ならびに中間体）認証局が発行する前に、ログへの証明書を提出することができます。そうするために、CAは、ログが発行された証明書に対して有効になりますエントリを作成するために使用できることをPrecertificate提出します。 PrecertificateはエンドエンティティたtbsCertificateに（そのextnValue OCTET STRING ASN.1のNULLデータを含む（0x05を0x00で）OID 1.3.6.1.4.1.11129.2.4.3）特別な臨界毒拡張を追加することにより発行される証明書から構成されています（この拡張はPrecertificateは、標準のX.509v3クライアントによって検証できないことを保証することである）のいずれかを用いて得られたtbsCertificate [RFC5280]を署名します"
    },
    {
      "indent": 3,
      "text": "o a special-purpose (CA:true, Extended Key Usage: Certificate Transparency, OID 1.3.6.1.4.1.11129.2.4.4) Precertificate Signing Certificate. The Precertificate Signing Certificate MUST be directly certified by the (root or intermediate) CA certificate that will ultimately sign the end-entity TBSCertificate yielding the end-entity certificate (note that the log may relax standard validation rules to allow this, so long as the issued certificate will be valid),",
      "ja": "O特殊用途（CA：真、拡張キー使用法：証明書の透明性、OID 1.3.6.1.4.1.11129.2.4.4）Precertificate署名証明書。署名証明書Precertificateが直接最終たtbsCertificateは、エンドエンティティ証明書を得たエンドエンティティに署名する（ルートまたは中間）CA証明書によって認証されなければならない（ログ限り、これを可能にする標準的な検証ルールを緩和することができることに注意してください発行された証明書）が有効になり、"
    },
    {
      "indent": 3,
      "text": "o or, the CA certificate that will sign the final certificate.",
      "ja": "Oや、最後の証明書に署名するCA証明書。"
    },
    {
      "indent": 3,
      "text": "As above, the Precertificate submission MUST be accompanied by the Precertificate Signing Certificate, if used, and all additional certificates required to verify the chain up to an accepted root certificate. The signature on the TBSCertificate indicates the certificate authority's intent to issue a certificate. This intent is considered binding (i.e., misissuance of the Precertificate is considered equal to misissuance of the final certificate). Each log verifies the Precertificate signature chain and issues a Signed Certificate Timestamp on the corresponding TBSCertificate.",
      "ja": "上記のように、Precertificateの提出はPrecertificateが使用されている場合、署名証明書、および受け入れられたルート証明書にチェーンを検証するために必要なすべての追加の証明書を添付しなければなりません。たtbsCertificateの署名は、証明書を発行する認証局の意図を示しています。このインテント（すなわち、Precertificateのmisissuance最終証明書のmisissuanceに等しいと考えられる）結合であると考えられます。各ログはPrecertificate署名チェーンを検証し、対応するたtbsCertificateに署名証明書のタイムスタンプを発行します。"
    },
    {
      "indent": 3,
      "text": "Logs MUST verify that the submitted end-entity certificate or Precertificate has a valid signature chain leading back to a trusted root CA certificate, using the chain of intermediate CA certificates provided by the submitter. Logs MAY accept certificates that have expired, are not yet valid, have been revoked, or are otherwise not fully valid according to X.509 verification rules in order to accommodate quirks of CA certificate-issuing software. However, logs MUST refuse to publish certificates without a valid chain to a known root CA. If a certificate is accepted and an SCT issued, the accepting log MUST store the entire chain used for verification, including the certificate or Precertificate itself and including the root certificate used to verify the chain (even if it was omitted from the submission), and MUST present this chain for auditing upon request. This chain is required to prevent a CA from avoiding blame by logging a partial or empty chain. (Note: This effectively excludes self-signed and DANE-based certificates until some mechanism to control spam for those certificates is found. The authors welcome suggestions.)",
      "ja": "ログは提出者によって設けられた中間CA証明書のチェーンを使用して、送信したエンドエンティティ証明書またはPrecertificateが戻って信頼されたルートCA証明書につながる有効な署名チェーンを持っていることを確かめなければなりません。ログは、有効期限が切れた証明書を受け入れ、まだ有効でないかもしれない、取り消され、またはCA証明書発行ソフトウェアの癖に対応するために、X.509検証ルールに従って、そうでない場合は完全には有効ではありませんされています。しかし、ログが知られているルートCAへの有効なチェーンのない証明書を発行することを拒否しなければなりません証明書が受け入れられ、SCTが発行された場合、受付ログは、証明書またはPrecertificate自体とチェーンを検証するために使用されるルート証明書などを含む検証に使用チェーン全体を、記憶しなければならない（それが提出から省略された場合でも）、および要求に応じて、監査のためにこのチェーンを提示しなければなりません。このチェーンは、部分的または空のチェーンをログインすることで、責任を回避からCAを防止するために必要とされます。 （注：これらの証明書のスパムを制御するために、いくつかのメカニズムが発見されるまで、これが効果的に自己署名とDANEベースの証明書を除く著者歓迎の提案。。）"
    },
    {
      "indent": 3,
      "text": "Each certificate entry in a log MUST include the following components:",
      "ja": "ログ内の各証明書のエントリは、次のコンポーネントを含める必要があります。"
    },
    {
      "indent": 7,
      "text": "enum { x509_entry(0), precert_entry(1), (65535) } LogEntryType;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "struct {\n    LogEntryType entry_type;\n    select (entry_type) {\n        case x509_entry: X509ChainEntry;\n        case precert_entry: PrecertChainEntry;\n    } entry;\n} LogEntry;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "opaque ASN.1Cert<1..2^24-1>;",
      "ja": "不透明ASN.1Cert <1..2 ^ 24-1>;"
    },
    {
      "indent": 7,
      "text": "struct {\n    ASN.1Cert leaf_certificate;\n    ASN.1Cert certificate_chain<0..2^24-1>;\n} X509ChainEntry;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "struct {\n    ASN.1Cert pre_certificate;\n    ASN.1Cert precertificate_chain<0..2^24-1>;\n} PrecertChainEntry;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Logs MAY limit the length of chain they will accept.",
      "ja": "ログは、彼らが受け入れるの鎖の長さを制限する場合があります。"
    },
    {
      "indent": 3,
      "text": "\"entry_type\" is the type of this entry. Future revisions of this protocol version may add new LogEntryType values. Section 4 explains how clients should handle unknown entry types.",
      "ja": "「entry_typeは」このエントリのタイプです。このプロトコルバージョンの将来の改訂は、新しいLogEntryType値を追加することができます。第4節では、クライアントが未知のエントリ・タイプを処理する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "\"leaf_certificate\" is the end-entity certificate submitted for auditing.",
      "ja": "「leaf_certificateは、」監査のために提出エンドエンティティ証明書です。"
    },
    {
      "indent": 3,
      "text": "\"certificate_chain\" is a chain of additional certificates required to verify the end-entity certificate. The first certificate MUST certify the end-entity certificate. Each following certificate MUST directly certify the one preceding it. The final certificate MUST be a root certificate accepted by the log.",
      "ja": "「certificate_chainは」エンドエンティティ証明書を検証するために必要な追加の証明書のチェーンです。最初の証明書は、エンドエンティティ証明書を証明しなければなりません。それぞれの次の証明書は直接それに先行するものを証明する必要があります。最後の証明書は、ログに受け入れられたルート証明書でなければなりません。"
    },
    {
      "indent": 3,
      "text": "\"pre_certificate\" is the Precertificate submitted for auditing.",
      "ja": "「pre_certificateは」Precertificateは、監査のために提出されます。"
    },
    {
      "indent": 3,
      "text": "\"precertificate_chain\" is a chain of additional certificates required to verify the Precertificate submission. The first certificate MAY be a valid Precertificate Signing Certificate and MUST certify the first certificate. Each following certificate MUST directly certify the one preceding it. The final certificate MUST be a root certificate accepted by the log.",
      "ja": "「precertificate_chainは」Precertificateの提出を検証するために必要な追加の証明書のチェーンです。最初の証明書は、有効なPrecertificate署名証明書とすることができ、最初の証明書を証明しなければなりません。それぞれの次の証明書は直接それに先行するものを証明する必要があります。最後の証明書は、ログに受け入れられたルート証明書でなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2. Structure of the Signed Certificate Timestamp",
      "section_title": true,
      "ja": "3.2。署名証明書のタイムスタンプの構造"
    },
    {
      "indent": 7,
      "text": "enum { certificate_timestamp(0), tree_hash(1), (255) }\n  SignatureType;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "enum { v1(0), (255) }\n  Version;",
      "raw": true
    },
    {
      "indent": 9,
      "text": "struct {\n    opaque key_id[32];\n} LogID;",
      "raw": true
    },
    {
      "indent": 9,
      "text": "opaque TBSCertificate<1..2^24-1>;",
      "ja": "不透明たtbsCertificate <1..2 ^ 24-1>;"
    },
    {
      "indent": 9,
      "text": "struct {\n  opaque issuer_key_hash[32];\n  TBSCertificate tbs_certificate;\n} PreCert;",
      "raw": true
    },
    {
      "indent": 9,
      "text": "opaque CtExtensions<0..2^16-1>;",
      "ja": "不透明CtExtensions <0..2 ^ 16-1>;"
    },
    {
      "indent": 3,
      "text": "\"key_id\" is the SHA-256 hash of the log's public key, calculated over the DER encoding of the key represented as SubjectPublicKeyInfo.",
      "ja": "「のkey_idは」SubjectPublicKeyInfoでのように表さキーのDERエンコーディングに渡って計算ログの公開鍵のSHA-256ハッシュです。"
    },
    {
      "indent": 3,
      "text": "\"issuer_key_hash\" is the SHA-256 hash of the certificate issuer's public key, calculated over the DER encoding of the key represented as SubjectPublicKeyInfo. This is needed to bind the issuer to the final certificate.",
      "ja": "「issuer_key_hashは」SubjectPublicKeyInfoでのように表さキーのDERエンコーディングに渡って計算証明書発行者の公開鍵のSHA-256ハッシュです。これは、最後の証明書を発行者をバインドするために必要とされます。"
    },
    {
      "indent": 3,
      "text": "\"tbs_certificate\" is the DER-encoded TBSCertificate (see [RFC5280]) component of the Precertificate -- that is, without the signature and the poison extension. If the Precertificate is not signed with the CA certificate that will issue the final certificate, then the TBSCertificate also has its issuer changed to that of the CA that will issue the final certificate. Note that it is also possible to reconstruct this TBSCertificate from the final certificate by extracting the TBSCertificate from it and deleting the SCT extension. Also note that since the TBSCertificate contains an AlgorithmIdentifier that must match both the Precertificate signature algorithm and final certificate signature algorithm, they must be signed with the same algorithm and parameters. If the Precertificate is issued using a Precertificate Signing Certificate and an Authority Key Identifier extension is present in the TBSCertificate, the corresponding extension must also be present in the Precertificate Signing Certificate -- in this case, the TBSCertificate also has its Authority Key Identifier changed to match the final issuer.",
      "ja": "署名及び毒拡張することなく、ある - 「tbs_certificate」はPrecertificateのDER符号化されたtbsCertificate（[RFC5280]を参照のこと）の成分です。 Precertificateが、最終的な証明書を発行するCA証明書で署名されていない場合は、たtbsCertificateはまた、発行者は、最終的な証明書を発行するCAのものに変更されました。それからたtbsCertificateを抽出し、SCT拡張子を削除することによって、最終的な証明書から本たtbsCertificateを再構成することも可能であることに留意されたいです。又たtbsCertificateはPrecertificate署名アルゴリズムおよび最終証明書の署名アルゴリズムの両方に一致しなければならないのAlgorithmIdentifierが含まれているので、それらは同じアルゴリズムおよびパラメータを使用して署名されなければならないことに注意してください。 Precertificateを使用して発行された場合Precertificate署名証明書と認証局キー識別子の拡張子がたtbsCertificateに存在する、対応する拡張機能もPrecertificate署名証明書に存在している必要があります - この場合には、たtbsCertificateもその権限キー識別子は、に変更されました最終発行者と一致します。"
    },
    {
      "indent": 7,
      "text": "struct {\n    Version sct_version;\n    LogID id;\n    uint64 timestamp;\n    CtExtensions extensions;\n    digitally-signed struct {\n        Version sct_version;\n        SignatureType signature_type = certificate_timestamp;\n        uint64 timestamp;\n        LogEntryType entry_type;\n        select(entry_type) {\n            case x509_entry: ASN.1Cert;\n            case precert_entry: PreCert;\n        } signed_entry;\n       CtExtensions extensions;\n    };\n} SignedCertificateTimestamp;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The encoding of the digitally-signed element is defined in [RFC5246].",
      "ja": "デジタル署名された要素の符号化は[RFC5246]で定義されています。"
    },
    {
      "indent": 3,
      "text": "\"sct_version\" is the version of the protocol to which the SCT conforms. This version is v1.",
      "ja": "「sct_version」はSCTが準拠れるプロトコルのバージョンです。このバージョンはv1のです。"
    },
    {
      "indent": 3,
      "text": "\"timestamp\" is the current NTP Time [RFC5905], measured since the epoch (January 1, 1970, 00:00), ignoring leap seconds, in milliseconds.",
      "ja": "「タイムスタンプ」は、ミリ秒単位で、うるう秒を無視して、エポック（1970年1月1日00:00）以来、測定された現在のNTPタイム[RFC5905]、です。"
    },
    {
      "indent": 3,
      "text": "\"entry_type\" may be implicit from the context in which the SCT is presented.",
      "ja": "「entry_typeは、」SCTが提示される文脈から暗黙的であってもよいです。"
    },
    {
      "indent": 3,
      "text": "\"signed_entry\" is the \"leaf_certificate\" (in the case of an X509ChainEntry) or is the PreCert (in the case of a PrecertChainEntry), as described above.",
      "ja": "上記のように「signed_entry」は、（X509ChainEntryの場合）「leaf_certificate」であるか、または（PrecertChainEntryの場合）PreCertあります。"
    },
    {
      "indent": 3,
      "text": "\"extensions\" are future extensions to this protocol version (v1). Currently, no extensions are specified.",
      "ja": "「拡張子が」このプロトコルバージョン（V1）への将来の拡張です。現在、拡張子が指定されていません。"
    },
    {
      "indent": 0,
      "text": "3.3. Including the Signed Certificate Timestamp in the TLS Handshake",
      "section_title": true,
      "ja": "3.3。 TLSハンドシェイクでの署名付き証明書のタイムスタンプを含みます"
    },
    {
      "indent": 3,
      "text": "The SCT data corresponding to the end-entity certificate from at least one log must be included in the TLS handshake, either by using an X509v3 certificate extension as described below, by using a TLS extension (Section 7.4.1.4 of [RFC5246]) with type \"signed_certificate_timestamp\", or by using Online Certificate Status Protocol (OCSP) Stapling (also known as the \"Certificate Status",
      "ja": "少なくとも一つのログからエンドエンティティ証明書に対応するSCTデータを用いてTLS拡張子（[RFC5246]のセクション7.4.1.4）を用いて、以下に説明するように書X509v3証明書拡張を使用することによってのいずれかで、TLSハンドシェイク中に含まれなければなりませんタイプ「signed_certificate_timestamp」、あるいはまた、「証明書ステータスとして知られているオンライン証明書状態プロトコル（OCSP）ステープルを（使用して"
    },
    {
      "indent": 3,
      "text": "Request\" TLS extension; see [RFC6066]), where the response includes an OCSP extension with OID 1.3.6.1.4.1.11129.2.4.5 (see [RFC2560]) and body:",
      "ja": "要求」TLS拡張子、応答がOID 1.3.6.1.4.1.11129.2.4.5（[RFC2560]を参照）と本体とOCSP拡張を含む場合、[RFC6066]）を参照してください。"
    },
    {
      "indent": 7,
      "text": "SignedCertificateTimestampList ::= OCTET STRING",
      "raw": true
    },
    {
      "indent": 3,
      "text": "At least one SCT MUST be included. Server operators MAY include more than one SCT.",
      "ja": "少なくとも一つのSCTを含まなければなりません。サーバーオペレータは、複数のSCTを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "Similarly, a certificate authority MAY submit a Precertificate to more than one log, and all obtained SCTs can be directly embedded in the final certificate, by encoding the SignedCertificateTimestampList structure as an ASN.1 OCTET STRING and inserting the resulting data in the TBSCertificate as an X.509v3 certificate extension (OID 1.3.6.1.4.1.11129.2.4.2). Upon receiving the certificate, clients can reconstruct the original TBSCertificate to verify the SCT signature.",
      "ja": "同様に、認証局は、複数のログにPrecertificateを提出することができる、すべての得られたSCTが直接ASN.1のOCTET STRINGとしてSignedCertificateTimestampList構造をコードとしてたtbsCertificateで得られたデータを挿入することにより、最終的な証明書に埋め込むことができますX.509v3証明書の拡張機能（OID 1.3.6.1.4.1.11129.2.4.2）。証明書を受信すると、クライアントは、SCT署名を検証するために、元たtbsCertificateを再構成することができます。"
    },
    {
      "indent": 3,
      "text": "The contents of the ASN.1 OCTET STRING embedded in an OCSP extension or X509v3 certificate extension are as follows:",
      "ja": "次のようにOCSP拡張または書X509v3証明書拡張に埋め込まれたASN.1オクテット文字列の内容は次のとおりです。"
    },
    {
      "indent": 8,
      "text": "opaque SerializedSCT<1..2^16-1>;",
      "ja": "不透明SerializedSCT <1..2 ^ 16-1>;"
    },
    {
      "indent": 8,
      "text": "struct {\n    SerializedSCT sct_list <1..2^16-1>;\n} SignedCertificateTimestampList;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here, \"SerializedSCT\" is an opaque byte string that contains the serialized TLS structure. This encoding ensures that TLS clients can decode each SCT individually (i.e., if there is a version upgrade, out-of-date clients can still parse old SCTs while skipping over new SCTs whose versions they don't understand).",
      "ja": "ここで、「SerializedSCTは、」シリアル化されたTLSの構造を含む不透明なバイト列です。このエンコーディングは、TLSクライアントが個別に各SCTをデコードすることができます（バージョンアップがある場合は、そのバージョン、彼らは理解していない新しいのSCTを飛ばしながら、すなわち、期限切れのクライアントがまだ古いのSCTを解析できる）ことを保証します。"
    },
    {
      "indent": 3,
      "text": "Likewise, SCTs can be embedded in a TLS extension. See below for details.",
      "ja": "同様に、SCTがTLS拡張に埋め込むことができます。詳細については、以下を参照してください。"
    },
    {
      "indent": 3,
      "text": "TLS clients MUST implement all three mechanisms. Servers MUST implement at least one of the three mechanisms. Note that existing TLS servers can generally use the certificate extension mechanism without modification.",
      "ja": "TLSクライアントは、すべての3つのメカニズムを実装しなければなりません。サーバーは、次の3つのメカニズムのうちの少なくとも一つを実装しなければなりません。既存のTLSサーバは、一般的に変更せずに、証明書の拡張メカニズムを使用できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "TLS servers should send SCTs from multiple logs in case one or more logs are not acceptable to the client (for example, if a log has been struck off for misbehavior or has had a key compromise).",
      "ja": "TLSサーバは、一件の以上のログがクライアントに受け入れられない場合には、複数のログからのSCTを送信する必要があります（例えば、ログが不正行為のためにオフに打たれたかのキー妥協があった場合）。"
    },
    {
      "indent": 0,
      "text": "3.3.1. TLS Extension",
      "section_title": true,
      "ja": "3.3.1。 TLS拡張"
    },
    {
      "indent": 3,
      "text": "The SCT can be sent during the TLS handshake using a TLS extension with type \"signed_certificate_timestamp\".",
      "ja": "SCTは、タイプ「signed_certificate_timestamp」とTLSの拡張機能を使用して、TLSハンドシェイク中に送信することができます。"
    },
    {
      "indent": 3,
      "text": "Clients that support the extension SHOULD send a ClientHello extension with the appropriate type and empty \"extension_data\".",
      "ja": "拡張をサポートするクライアントは、適切な型と空の「拡大」とのClientHello拡張を送るべきです。"
    },
    {
      "indent": 3,
      "text": "Servers MUST only send SCTs to clients who have indicated support for the extension in the ClientHello, in which case the SCTs are sent by setting the \"extension_data\" to a \"SignedCertificateTimestampList\".",
      "ja": "サーバーのみのSCTが「SignedCertificateTimestampList」を「拡大」に設定することで送信される場合にはのClientHelloでの拡張のための支持を表明しているクライアントへのSCTを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Session resumption uses the original session information: clients SHOULD include the extension type in the ClientHello, but if the session is resumed, the server is not expected to process it or include the extension in the ServerHello.",
      "ja": "クライアントはのClientHelloでの拡張タイプを含める必要がありますが、セッションが再開された場合、サーバーはそれを処理するかのServerHelloで拡張子を含めることが予想されていない：セッションの再開は、元のセッション情報を使用しています。"
    },
    {
      "indent": 0,
      "text": "3.4. Merkle Tree",
      "section_title": true,
      "ja": "3.4。マークル木"
    },
    {
      "indent": 3,
      "text": "The hashing algorithm for the Merkle Tree Hash is SHA-256.",
      "ja": "マークル木ハッシュのためのハッシュアルゴリズムはSHA-256です。"
    },
    {
      "indent": 3,
      "text": "Structure of the Merkle Tree input:",
      "ja": "マークル木入力の構造："
    },
    {
      "indent": 7,
      "text": "enum { timestamped_entry(0), (255) }\n  MerkleLeafType;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "struct {\n    uint64 timestamp;\n    LogEntryType entry_type;\n    select(entry_type) {\n        case x509_entry: ASN.1Cert;\n        case precert_entry: PreCert;\n    } signed_entry;\n    CtExtensions extensions;\n} TimestampedEntry;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "struct {\n    Version version;\n    MerkleLeafType leaf_type;\n    select (leaf_type) {\n        case timestamped_entry: TimestampedEntry;\n    }\n} MerkleTreeLeaf;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here, \"version\" is the version of the protocol to which the MerkleTreeLeaf corresponds. This version is v1.",
      "ja": "ここで、「バージョン」はMerkleTreeLeafが対応するプロトコルのバージョンです。このバージョンはv1のです。"
    },
    {
      "indent": 3,
      "text": "\"leaf_type\" is the type of the leaf input. Currently, only \"timestamped_entry\" (corresponding to an SCT) is defined. Future revisions of this protocol version may add new MerkleLeafType types. Section 4 explains how clients should handle unknown leaf types.",
      "ja": "「leaf_typeは」葉入力のタイプです。現在、唯一の「timestamped_entry」（SCTに相当）が定義されます。このプロトコルバージョンの将来の改訂は、新しいMerkleLeafTypeタイプを追加することがあります。第4節では、クライアントが不明な葉の種類を処理する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "\"timestamp\" is the timestamp of the corresponding SCT issued for this certificate.",
      "ja": "「タイムスタンプ」は、この証明書を発行し、対応するSCTのタイムスタンプです。"
    },
    {
      "indent": 3,
      "text": "\"signed_entry\" is the \"signed_entry\" of the corresponding SCT.",
      "ja": "「signed_entry」は、対応するSCTの「signed_entry」です。"
    },
    {
      "indent": 3,
      "text": "\"extensions\" are \"extensions\" of the corresponding SCT.",
      "ja": "「拡張子」は、対応するSCTの「拡張」です。"
    },
    {
      "indent": 3,
      "text": "The leaves of the Merkle Tree are the leaf hashes of the corresponding \"MerkleTreeLeaf\" structures.",
      "ja": "マークル木の葉が対応する「MerkleTreeLeaf」構造の葉のハッシュです。"
    },
    {
      "indent": 0,
      "text": "3.5. Signed Tree Head",
      "section_title": true,
      "ja": "3.5。署名されたツリーの頭"
    },
    {
      "indent": 3,
      "text": "Every time a log appends new entries to the tree, the log SHOULD sign the corresponding tree hash and tree information (see the corresponding Signed Tree Head client message in Section 4.3). The signature for that data is structured as follows:",
      "ja": "ログがツリーに新しいエントリを追加するたびに、ログには、対応するツリーハッシュやツリー情報を（セクション4.3で、対応する署名ツリー頭クライアントメッセージを参照）に署名すべきです。次のようにそのデータの署名が構成されています。"
    },
    {
      "indent": 7,
      "text": "digitally-signed struct {\n    Version version;\n    SignatureType signature_type = tree_hash;\n    uint64 timestamp;\n    uint64 tree_size;\n    opaque sha256_root_hash[32];\n} TreeHeadSignature;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "\"version\" is the version of the protocol to which the TreeHeadSignature conforms. This version is v1.",
      "ja": "「バージョン」はTreeHeadSignatureが準拠れるプロトコルのバージョンです。このバージョンはv1のです。"
    },
    {
      "indent": 3,
      "text": "\"timestamp\" is the current time. The timestamp MUST be at least as recent as the most recent SCT timestamp in the tree. Each subsequent timestamp MUST be more recent than the timestamp of the previous update.",
      "ja": "「タイムスタンプは、」現在の時刻です。タイムスタンプは、少なくとも、ツリー内の最新のSCTのタイムスタンプとして、最近のようでなければなりません。後続の各タイムスタンプは、前回の更新のタイムスタンプより新しいなければなりません。"
    },
    {
      "indent": 3,
      "text": "\"tree_size\" equals the number of entries in the new tree.",
      "ja": "「tree_sizeは、」新しいツリー内のエントリの数に等しいです。"
    },
    {
      "indent": 3,
      "text": "\"sha256_root_hash\" is the root of the Merkle Hash Tree.",
      "ja": "「sha256_root_hashは」マークルハッシュツリーのルートです。"
    },
    {
      "indent": 3,
      "text": "Each log MUST produce on demand a Signed Tree Head that is no older than the Maximum Merge Delay. In the unlikely event that it receives no new submissions during an MMD period, the log SHALL sign the same Merkle Tree Hash with a fresh timestamp.",
      "ja": "各ログには、要求に応じて、最大マージ遅延よりも古くない署名ツリーヘッドを生産しなければなりません。それはMMD期間中に新たな提出物を受信しない万一、ログは、新鮮なタイムスタンプと同じマークル木ハッシュに署名しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4. Log Client Messages",
      "section_title": true,
      "ja": "4.ログクライアントメッセージ"
    },
    {
      "indent": 3,
      "text": "Messages are sent as HTTPS GET or POST requests. Parameters for POSTs and all responses are encoded as JavaScript Object Notation (JSON) objects [RFC4627]. Parameters for GETs are encoded as order-independent key/value URL parameters, using the \"application/ x-www-form-urlencoded\" format described in the \"HTML 4.01 Specification\" [HTML401]. Binary data is base64 encoded [RFC4648] as specified in the individual messages.",
      "ja": "メッセージはHTTPS GETやPOSTリクエストとして送信されます。ポストおよびすべての応答のパラメータは、JavaScript Object Notation（JSON）オブジェクト[RFC4627]として符号化されます。パラメータは、[HTML401]「HTML 4.01仕様書」に記載された「アプリケーション/ x-www-form-urlencodedで」形式を使用して、順序非依存のキー/値のURLパラメータとして符号化される取得します。バイナリデータは、個々のメッセージで指定されるようにbase64で符号化された[RFC4648]です。"
    },
    {
      "indent": 3,
      "text": "Note that JSON objects and URL parameters may contain fields not specified here. These extra fields should be ignored.",
      "ja": "JSONオブジェクトとURLのパラメータは、ここで指定されていないフィールドが含まれていてもよいことに注意してください。これらの追加のフィールドは無視されるべきです。"
    },
    {
      "indent": 3,
      "text": "The <log server> prefix can include a path as well as a server name and a port.",
      "ja": "<ログサーバー>プレフィックスは、パスだけでなく、サーバー名とポートを含めることができます。"
    },
    {
      "indent": 3,
      "text": "In general, where needed, the \"version\" is v1 and the \"id\" is the log id for the log server queried.",
      "ja": "必要な場合、一般的には、「バージョンは」V1で、「idが」照会ログサーバのログIDです。"
    },
    {
      "indent": 3,
      "text": "Any errors will be returned as HTTP 4xx or 5xx responses, with human-readable error messages.",
      "ja": "すべてのエラーは、人間が読めるエラーメッセージで、HTTPの4xxまたは5xxの応答として返されます。"
    },
    {
      "indent": 0,
      "text": "4.1. Add Chain to Log",
      "section_title": true,
      "ja": "4.1。ログにチェーンを追加します。"
    },
    {
      "indent": 3,
      "text": "POST https://<log server>/ct/v1/add-chain",
      "ja": "POSTのhttps：//では/ CT / V1 /アドオンチェーン<サーバーログ>を"
    },
    {
      "indent": 3,
      "text": "Inputs:",
      "ja": "入力："
    },
    {
      "indent": 6,
      "text": "chain: An array of base64-encoded certificates. The first element is the end-entity certificate; the second chains to the first and so on to the last, which is either the root certificate or a certificate that chains to a known root certificate.",
      "ja": "鎖：base64エンコード証明書の配列。最初の要素は、エンドエンティティ証明書です。ルート証明書または既知のルート証明書にチェーン証明書のいずれかである、最後のように第一および第二のチェーン。"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 6,
      "text": "sct_version: The version of the SignedCertificateTimestamp structure, in decimal. A compliant v1 implementation MUST NOT expect this to be 0 (i.e., v1).",
      "ja": "sct_version：SignedCertificateTimestamp構造のバージョン、小数インチコンプライアントV1の実装では、これは0（即ち、V1）であることを期待してはいけません。"
    },
    {
      "indent": 6,
      "text": "id: The log ID, base64 encoded. Since log clients who request an SCT for inclusion in TLS handshakes are not required to verify it, we do not assume they know the ID of the log.",
      "ja": "ID：ログID、BASE64でエンコードされました。 TLSハンドシェイクに含めるためSCTを要求ログクライアントは、それを検証するために必要とされていないので、我々は、彼らが、ログのIDを知っていると仮定しないでください。"
    },
    {
      "indent": 6,
      "text": "timestamp: The SCT timestamp, in decimal.",
      "ja": "タイムスタンプ：SCTのタイムスタンプ、小数インチ"
    },
    {
      "indent": 6,
      "text": "extensions: An opaque type for future expansion. It is likely that not all participants will need to understand data in this field. Logs should set this to the empty string. Clients should decode the base64-encoded data and include it in the SCT.",
      "ja": "拡張子：将来の拡張のために不透明タイプ。すべての参加者は、このフィールド内のデータを理解する必要がありますない可能性が高いです。ログは空の文字列に設定する必要があります。クライアントは、base64でエンコードされたデータをデコードし、SCTでそれを含める必要があります。"
    },
    {
      "indent": 6,
      "text": "signature: The SCT signature, base64 encoded.",
      "ja": "署名：SCT署名、BASE64でエンコードされました。"
    },
    {
      "indent": 3,
      "text": "If the \"sct_version\" is not v1, then a v1 client may be unable to verify the signature. It MUST NOT construe this as an error. (Note: Log clients don't need to be able to verify this structure; only TLS clients do. If we were to serve the structure as a binary blob, then we could completely change it without requiring an upgrade to v1 clients.)",
      "ja": "「sct_versionは」V1されていない場合、v1のクライアントは、署名を検証できないことがあります。それはこれをエラーとして解釈してはなりません。 （注：クライアントは、この構造を確認することができるようにする必要はありませんログインし、クライアントのみが行うTLS我々はバイナリブロブのような構造を提供することであったならば、我々は完全にv1のクライアントへのアップグレードを必要とせずに、それを変更することができます。）"
    },
    {
      "indent": 0,
      "text": "4.2. Add PreCertChain to Log",
      "section_title": true,
      "ja": "4.2。ログにPreCertChainを追加"
    },
    {
      "indent": 3,
      "text": "POST https://<log server>/ct/v1/add-pre-chain",
      "ja": "POSTします。https：// <ログオンサーバー> / CT / V1 /アドオン事前チェーン"
    },
    {
      "indent": 3,
      "text": "Inputs:",
      "ja": "入力："
    },
    {
      "indent": 6,
      "text": "chain: An array of base64-encoded Precertificates. The first element is the end-entity certificate; the second chains to the first and so on to the last, which is either the root certificate or a certificate that chains to a known root certificate.",
      "ja": "鎖：base64エンコードPrecertificatesのアレイ。最初の要素は、エンドエンティティ証明書です。ルート証明書または既知のルート証明書にチェーン証明書のいずれかである、最後のように第一および第二のチェーン。"
    },
    {
      "indent": 3,
      "text": "Outputs are the same as in Section 4.1.",
      "ja": "出力は4.1節と同じです。"
    },
    {
      "indent": 0,
      "text": "4.3. Retrieve Latest Signed Tree Head",
      "section_title": true,
      "ja": "4.3。最新の署名ツリー頭を取得"
    },
    {
      "indent": 3,
      "text": "GET https://<log server>/ct/v1/get-sth",
      "ja": "GETのhttps：// / CT / V1 /取得-STH <サーバーログ>を"
    },
    {
      "indent": 3,
      "text": "No inputs.",
      "ja": "入力なしません。"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 6,
      "text": "tree_size: The size of the tree, in entries, in decimal.",
      "ja": "tree_size：小数のエントリのツリーのサイズ、。"
    },
    {
      "indent": 6,
      "text": "timestamp: The timestamp, in decimal.",
      "ja": "タイムスタンプ：タイムスタンプ、小数インチ"
    },
    {
      "indent": 6,
      "text": "sha256_root_hash: The Merkle Tree Hash of the tree, in base64.",
      "ja": "sha256_root_hash：木のマークル木ハッシュ、BASE64インチ"
    },
    {
      "indent": 6,
      "text": "tree_head_signature: A TreeHeadSignature for the above data.",
      "ja": "tree_head_signature：上記データのTreeHeadSignature。"
    },
    {
      "indent": 0,
      "text": "4.4. Retrieve Merkle Consistency Proof between Two Signed Tree Heads",
      "section_title": true,
      "ja": "4.4。二つの署名ツリーヘッド間マークル整合性証明を取得"
    },
    {
      "indent": 3,
      "text": "GET https://<log server>/ct/v1/get-sth-consistency",
      "ja": "GETのhttps：// <ログオンサーバー> / CT / V1 /取得-STH-一貫性"
    },
    {
      "indent": 3,
      "text": "Inputs:",
      "ja": "入力："
    },
    {
      "indent": 6,
      "text": "first: The tree_size of the first tree, in decimal.",
      "ja": "最初の10進の最初の木のtree_size、。"
    },
    {
      "indent": 6,
      "text": "second: The tree_size of the second tree, in decimal.",
      "ja": "第二：小数第二の木、のtree_size。"
    },
    {
      "indent": 3,
      "text": "Both tree sizes must be from existing v1 STHs (Signed Tree Heads).",
      "ja": "どちらの木の大きさは、既存のV1 STHS（署名ツリーヘッド）からでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 6,
      "text": "consistency: An array of Merkle Tree nodes, base64 encoded.",
      "ja": "一貫性：マークル木ノードのアレイ、BASE64でエンコードされました。"
    },
    {
      "indent": 3,
      "text": "Note that no signature is required on this data, as it is used to verify an STH, which is signed.",
      "ja": "署名されてSTHを検証するために使用されるいかなる署名は、このデータに必要とされないことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "4.5. Retrieve Merkle Audit Proof from Log by Leaf Hash",
      "section_title": true,
      "ja": "4.5。リーフハッシュによってログからマークル監査証明を取得"
    },
    {
      "indent": 3,
      "text": "GET https://<log server>/ct/v1/get-proof-by-hash",
      "ja": "GETのhttps：// <ログオンサーバー> / CT / V1 /取得プルーフ・バイ・ハッシュ"
    },
    {
      "indent": 3,
      "text": "Inputs:",
      "ja": "入力："
    },
    {
      "indent": 6,
      "text": "hash: A base64-encoded v1 leaf hash.",
      "ja": "ハッシュ：base64エンコードv1のリーフハッシュ。"
    },
    {
      "indent": 6,
      "text": "tree_size: The tree_size of the tree on which to base the proof, in decimal.",
      "ja": "tree_size：小数で、証拠の基に木のtree_size。"
    },
    {
      "indent": 3,
      "text": "The \"hash\" must be calculated as defined in Section 3.4. The \"tree_size\" must designate an existing v1 STH.",
      "ja": "3.4節で定義された「ハッシュ」を計算しなければなりません。 「tree_sizeは、」既存のV1 STHを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 6,
      "text": "leaf_index: The 0-based index of the end entity corresponding to the \"hash\" parameter.",
      "ja": "leaf_index：「ハッシュ」パラメータに対応するエンドエンティティの0から始まるインデックス。"
    },
    {
      "indent": 6,
      "text": "audit_path: An array of base64-encoded Merkle Tree nodes proving the inclusion of the chosen certificate.",
      "ja": "audit_path：選択した証明書を含めることを証明base64エンコードマークル木ノードのアレイ。"
    },
    {
      "indent": 0,
      "text": "4.6. Retrieve Entries from Log",
      "section_title": true,
      "ja": "4.6。ログからエントリを取得"
    },
    {
      "indent": 3,
      "text": "GET https://<log server>/ct/v1/get-entries",
      "ja": "GETのhttps：// <サーバーをログ> / CT / V1 / GET-エントリ"
    },
    {
      "indent": 3,
      "text": "Inputs:",
      "ja": "入力："
    },
    {
      "indent": 6,
      "text": "start: 0-based index of first entry to retrieve, in decimal.",
      "ja": "開始：取得するための最初のエントリの0から始まるインデックスを10進数で。"
    },
    {
      "indent": 6,
      "text": "end: 0-based index of last entry to retrieve, in decimal.",
      "ja": "最後：小数で、取得するための最後のエントリの0から始まるインデックス。"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 6,
      "text": "entries: An array of objects, each consisting of",
      "ja": "エントリ：オブジェクトの配列、それぞれから成ります"
    },
    {
      "indent": 9,
      "text": "leaf_input: The base64-encoded MerkleTreeLeaf structure.",
      "ja": "leaf_input：base64エンコードMerkleTreeLeaf構造。"
    },
    {
      "indent": 9,
      "text": "extra_data: The base64-encoded unsigned data pertaining to the log entry. In the case of an X509ChainEntry, this is the \"certificate_chain\". In the case of a PrecertChainEntry, this is the whole \"PrecertChainEntry\".",
      "ja": "extra_data：ログエントリに関連するbase64エンコード符号なしデータ。 X509ChainEntryの場合、これは「certificate_chain」です。 PrecertChainEntryの場合、これは全体の「PrecertChainEntry」です。"
    },
    {
      "indent": 3,
      "text": "Note that this message is not signed -- the retrieved data can be verified by constructing the Merkle Tree Hash corresponding to a retrieved STH. All leaves MUST be v1. However, a compliant v1 client MUST NOT construe an unrecognized MerkleLeafType or LogEntryType value as an error. This means it may be unable to parse some entries, but note that each client can inspect the entries it does recognize as well as verify the integrity of the data by treating unrecognized leaves as opaque input to the tree.",
      "ja": "このメッセージが署名されていないことに注意してください - 検索されたデータが検索STHに対応マークル木ハッシュを構築することによって確認することができます。すべての葉がV1でなければなりません。しかし、対応V1クライアントはエラーとして認識されていないMerkleLeafTypeまたはLogEntryType値を解釈してはなりません。いくつかのエントリを解析することができないが、各クライアントは、それが認識しないエントリを検査だけでなく、木に不透明な入力として認識されていない葉を処理することにより、データの整合性を検証することに注意して意味します。"
    },
    {
      "indent": 3,
      "text": "The \"start\" and \"end\" parameters SHOULD be within the range 0 <= x < \"tree_size\" as returned by \"get-sth\" in Section 4.3.",
      "ja": "「開始」および「終了」パラメータが範囲0 <= xで<4.3節には、「get-STHを」によって返される「tree_size」内にあるべきです。"
    },
    {
      "indent": 3,
      "text": "Logs MAY honor requests where 0 <= \"start\" < \"tree_size\" and \"end\" >= \"tree_size\" by returning a partial response covering only the valid entries in the specified range. Note that the following restriction may also apply:",
      "ja": "ログは、0 <=指定された範囲でのみ有効なエントリをカバーする部分的な応答を返すことで、<「tree_size」と「終わり」> =「tree_size」を「開始」の要求を尊重するかもしれません。以下の制限が適用される場合もありことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Logs MAY restrict the number of entries that can be retrieved per \"get-entries\" request. If a client requests more than the permitted number of entries, the log SHALL return the maximum number of entries permissible. These entries SHALL be sequential beginning with the entry specified by \"start\".",
      "ja": "ログは、「-エントリを取得する」リクエストごとに取得できるエントリの数を制限することができます。クライアントは、エントリの許容数よりも多くを要求した場合、ログは許容最大エントリ数を返します。これらのエントリは、「スタート」で指定されたエントリで、シーケンシャル初めものでなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.7. Retrieve Accepted Root Certificates",
      "section_title": true,
      "ja": "4.7。承認済みルート証明書を取得します。"
    },
    {
      "indent": 3,
      "text": "GET https://<log server>/ct/v1/get-roots",
      "ja": "GETのhttps：// <サーバーをログ> / CT / V1 / GET-ルーツ"
    },
    {
      "indent": 3,
      "text": "No inputs.",
      "ja": "入力なしません。"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 6,
      "text": "certificates: An array of base64-encoded root certificates that are acceptable to the log.",
      "ja": "証明：ログに許容されるbase64エンコードされたルート証明書の配列。"
    },
    {
      "indent": 0,
      "text": "4.8. Retrieve Entry+Merkle Audit Proof from Log",
      "section_title": true,
      "ja": "4.8。ログからのエントリ+マークル監査証明を取得"
    },
    {
      "indent": 3,
      "text": "GET https://<log server>/ct/v1/get-entry-and-proof",
      "ja": "GETのhttps：// <ログオンサーバー> / CT / V1 /取得-エントリーとプルーフ"
    },
    {
      "indent": 3,
      "text": "Inputs:",
      "ja": "入力："
    },
    {
      "indent": 6,
      "text": "leaf_index: The index of the desired entry.",
      "ja": "leaf_index：目的のエントリのインデックス。"
    },
    {
      "indent": 6,
      "text": "tree_size: The tree_size of the tree for which the proof is desired.",
      "ja": "tree_size：証拠が望まれる木のtree_size。"
    },
    {
      "indent": 3,
      "text": "The tree size must designate an existing STH.",
      "ja": "木の大きさは、既存のSTHを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Outputs:",
      "ja": "出力："
    },
    {
      "indent": 6,
      "text": "leaf_input: The base64-encoded MerkleTreeLeaf structure.",
      "ja": "leaf_input：base64エンコードMerkleTreeLeaf構造。"
    },
    {
      "indent": 6,
      "text": "extra_data: The base64-encoded unsigned data, same as in Section 4.6.",
      "ja": "extra_data：4.6節と同様のBase64でエンコードされた符号なしデータ、。"
    },
    {
      "indent": 6,
      "text": "audit_path: An array of base64-encoded Merkle Tree nodes proving the inclusion of the chosen certificate.",
      "ja": "audit_path：選択した証明書を含めることを証明base64エンコードマークル木ノードのアレイ。"
    },
    {
      "indent": 3,
      "text": "This API is probably only useful for debugging.",
      "ja": "このAPIは、おそらく、デバッグのためにのみ有効です。"
    },
    {
      "indent": 0,
      "text": "5. Clients",
      "section_title": true,
      "ja": "5.クライアント"
    },
    {
      "indent": 3,
      "text": "There are various different functions clients of logs might perform. We describe here some typical clients and how they could function. Any inconsistency may be used as evidence that a log has not behaved correctly, and the signatures on the data structures prevent the log from denying that misbehavior.",
      "ja": "ログのクライアントが実行する可能性のあるさまざまな異なる機能があります。ここではいくつかの典型的なクライアントを記述し、それらがどのように機能することができます。任意の矛盾は、ログが正しく振る舞っていないことの証拠として使用することができ、データ構造上の署名は、その不正行為を否定するからログを防ぎます。"
    },
    {
      "indent": 3,
      "text": "All clients should gossip with each other, exchanging STHs at least; this is all that is required to ensure that they all have a consistent view. The exact mechanism for gossip will be described in a separate document, but it is expected there will be a variety.",
      "ja": "すべてのクライアントは、少なくともSTHSを交換し、お互いにゴシップ必要があります。これは、彼らはすべての一貫したビューを持っていることを保証するために必要とされるすべてです。ゴシップのための正確な機構は、別の文書に記載され、種々が存在するであろうと予想されます。"
    },
    {
      "indent": 0,
      "text": "5.1. Submitters",
      "section_title": true,
      "ja": "5.1。提出者"
    },
    {
      "indent": 3,
      "text": "Submitters submit certificates or Precertificates to the log as described above. They may go on to use the returned SCT to construct a certificate or use it directly in a TLS handshake.",
      "ja": "上記のように提出者は、ログに証明書やPrecertificatesを提出します。彼らは、証明書を作成するか、TLSハンドシェイクで直接それを使用するために返されたSCTを使用するために行くことがあります。"
    },
    {
      "indent": 0,
      "text": "5.2. TLS Client",
      "section_title": true,
      "ja": "5.2。 TLSクライアント"
    },
    {
      "indent": 3,
      "text": "TLS clients are not directly clients of the log, but they receive SCTs alongside or in server certificates. In addition to normal validation of the certificate and its chain, they should validate the SCT by computing the signature input from the SCT data as well as the certificate and verifying the signature, using the corresponding log's public key. Note that this document does not describe how clients obtain the logs' public keys.",
      "ja": "TLSクライアントは直接ログのクライアントではありませんが、サーバ証明書と一緒やでのSCTを受けます。証明書とそのチェーンの通常の検証に加えて、それらは、対応するログの公開鍵を使用して、SCTデータから署名入力ならびに証明書を計算し、署名を検証することによってSCTを検証しなければなりません。この文書は、クライアントがログの公開鍵を取得する方法について説明していないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "TLS clients MUST reject SCTs whose timestamp is in the future.",
      "ja": "TLSクライアントは、そのタイムスタンプが未来にあるのSCTを拒絶しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3. Monitor",
      "section_title": true,
      "ja": "5.3。モニター"
    },
    {
      "indent": 3,
      "text": "Monitors watch logs and check that they behave correctly. They also watch for certificates of interest.",
      "ja": "モニターは、ログを見て、彼らが正しく動作することを確認してください。彼らはまた、目的の証明書を監視します。"
    },
    {
      "indent": 3,
      "text": "A monitor needs to, at least, inspect every new entry in each log it watches. It may also want to keep copies of entire logs. In order to do this, it should follow these steps for each log:",
      "ja": "モニターは、少なくとも、各それは時計ログ内のすべての新しいエントリを検査する必要があります。また、全体のログのコピーを保存することができます。これを実行するためには、各ログの手順に従ってください："
    },
    {
      "indent": 3,
      "text": "1. Fetch the current STH (Section 4.3).",
      "section_title": true,
      "ja": "1.現在のSTH（4.3節）を取得します。"
    },
    {
      "indent": 3,
      "text": "2. Verify the STH signature.",
      "section_title": true,
      "ja": "2. STH署名を確認します。"
    },
    {
      "indent": 3,
      "text": "3. Fetch all the entries in the tree corresponding to the STH (Section 4.6).",
      "ja": "3. STH（セクション4.6）に対応するツリー内のすべてのエントリをフェッチ。"
    },
    {
      "indent": 3,
      "text": "4. Confirm that the tree made from the fetched entries produces the same hash as that in the STH.",
      "ja": "前記フェッチされたエントリから作られたツリーは、STHと同様のハッシュを生成することを確認します。"
    },
    {
      "indent": 3,
      "text": "5. Fetch the current STH (Section 4.3). Repeat until the STH changes.",
      "ja": "5.現在のSTH（4.3節）を取得します。 STH変化するまで繰り返します。"
    },
    {
      "indent": 3,
      "text": "6. Verify the STH signature.",
      "section_title": true,
      "ja": "6. STH署名を確認します。"
    },
    {
      "indent": 3,
      "text": "7. Fetch all the new entries in the tree corresponding to the STH (Section 4.6). If they remain unavailable for an extended period, then this should be viewed as misbehavior on the part of the log.",
      "ja": "7. STH（4.6節）に対応するツリー内のすべての新しいエントリを取得します。彼らは長期間使用できなく残っている場合、これは、ログの一部に不正行為としてみなされるべきです。"
    },
    {
      "indent": 3,
      "text": "8. Either:",
      "section_title": true,
      "ja": "8.次のいずれか"
    },
    {
      "indent": 7,
      "text": "1.  Verify that the updated list of all entries generates a tree\n    with the same hash as the new STH.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Or, if it is not keeping all log entries:",
      "ja": "それとも、それはすべてのログエントリを保持していない場合："
    },
    {
      "indent": 7,
      "text": "2. Fetch a consistency proof for the new STH with the previous STH (Section 4.4).",
      "ja": "2.前STH（セクション4.4）を使用して新しいSTHのための一貫性の証明を取得。"
    },
    {
      "indent": 7,
      "text": "3. Verify the consistency proof.",
      "section_title": true,
      "ja": "3.一貫性の証明を確認してください。"
    },
    {
      "indent": 7,
      "text": "4. Verify that the new entries generate the corresponding elements in the consistency proof.",
      "ja": "4.新しいエントリは、一貫性の証明の対応する要素を生成していることを確認します。"
    },
    {
      "indent": 3,
      "text": "9. Go to Step 5.",
      "section_title": true,
      "ja": "9.ゴーステップ5に。"
    },
    {
      "indent": 0,
      "text": "5.4. Auditor",
      "section_title": true,
      "ja": "5.4。監査役"
    },
    {
      "indent": 3,
      "text": "Auditors take partial information about a log as input and verify that this information is consistent with other partial information they have. An auditor might be an integral component of a TLS client; it might be a standalone service; or it might be a secondary function of a monitor.",
      "ja": "監査役は、入力として、ログに関する部分的な情報を取得し、この情報は、彼らが持っている他の部分的な情報と一致していることを確認してください。監査人は、TLSクライアントの不可欠な構成要素であるかもしれません。それは、スタンドアロンのサービスかもしれません。またはそれは、モニターの二次関数であるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Any pair of STHs from the same log can be verified by requesting a consistency proof (Section 4.4).",
      "ja": "同じログからSTHSの任意の対は、一貫性証明（セクション4.4）を要求することによって検証することができます。"
    },
    {
      "indent": 3,
      "text": "A certificate accompanied by an SCT can be verified against any STH dated after the SCT timestamp + the Maximum Merge Delay by requesting a Merkle audit proof (Section 4.5).",
      "ja": "SCTを伴う証明書は、SCTのタイムスタンプ+マークル監査証拠（4.5節）を要求することによって最大マージ遅延の後付けの任意のSTHと照合することができます。"
    },
    {
      "indent": 3,
      "text": "Auditors can fetch STHs from time to time of their own accord, of course (Section 4.3).",
      "ja": "監査役は、自分のアコード、もちろん（4.3節）の時からSTHSを取得することができます。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has allocated an RFC 5246 ExtensionType value (18) for the SCT TLS extension. The extension name is \"signed_certificate_timestamp\".",
      "ja": "IANAは、SCT TLS拡張のためにRFC 5246 ExtensionType値（18）を割り当てています。拡張子名は「signed_certificate_timestamp」です。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "With CAs, logs, and servers performing the actions described here, TLS clients can use logs and signed timestamps to reduce the likelihood that they will accept misissued certificates. If a server presents a valid signed timestamp for a certificate, then the client knows that the certificate has been published in a log. From this, the client knows that the subject of the certificate has had some time to notice the misissue and take some action, such as asking a CA to revoke a misissued certificate. A signed timestamp is not a guarantee that the certificate is not misissued, since the subject of the certificate might not have checked the logs or the CA might have refused to revoke the certificate.",
      "ja": "CAは、ログ、ここで説明するアクションを実行するサーバーでは、TLSクライアントは、彼らがmisissued証明書を受け入れる可能性を減らすために、ログおよび署名タイムスタンプを使用することができます。サーバー証明書の有効な署名タイムスタンプを提示した場合、クライアントは、証明書がログに掲載されていることを知っています。このことから、クライアントは、証明書のサブジェクトは、このようなmisissued証明書を失効させるCAを尋ねると、misissueに気づくと、いくつかの行動を取るためにいくつかの時間があったことを知っています。署名タイムスタンプは、証明書のサブジェクトは、ログをチェックしていない可能性がありますか、CAが証明書を失効することを拒否している場合がありますので、証明書は、misissuedされていないことを保証するものではありません。"
    },
    {
      "indent": 3,
      "text": "In addition, if TLS clients will not accept unlogged certificates, then site owners will have a greater incentive to submit certificates to logs, possibly with the assistance of their CA, increasing the overall transparency of the system.",
      "ja": "TLSクライアントがログに記録されない証明書を受け入れない場合は加えて、そのサイトの所有者は、システムの全体的な透明性を高め、おそらく彼らのCAの支援を受けて、ログに証明書を提出する大きなインセンティブを持つことになります。"
    },
    {
      "indent": 0,
      "text": "7.1. Misissued Certificates",
      "section_title": true,
      "ja": "7.1。 Misissued証明書"
    },
    {
      "indent": 3,
      "text": "Misissued certificates that have not been publicly logged, and thus do not have a valid SCT, will be rejected by TLS clients. Misissued certificates that do have an SCT from a log will appear in that public log within the Maximum Merge Delay, assuming the log is operating correctly. Thus, the maximum period of time during which a misissued certificate can be used without being available for audit is the MMD.",
      "ja": "公に記録されていないため、有効なSCTを持っていないMisissued証明書は、TLSクライアントによって拒否されます。ログからSCTを持っていますMisissued証明書は、ログが正常に動作していると仮定すると、遅延をマージ最大以内にその公共のログに表示されます。したがって、misissued証明書は、監査のために利用可能でなく使用することができる時間の最大期間は、MMDです。"
    },
    {
      "indent": 0,
      "text": "7.2. Detection of Misissue",
      "section_title": true,
      "ja": "7.2。 Misissueの検出"
    },
    {
      "indent": 3,
      "text": "The logs do not themselves detect misissued certificates; they rely instead on interested parties, such as domain owners, to monitor them and take corrective action when a misissue is detected.",
      "ja": "ログ自体はmisissued証明書を検出しません。彼らはそれらを監視し、misissueが検出されたときに是正措置をとるために、そのようなドメインの所有者などの利害関係者、上の代わりに頼っています。"
    },
    {
      "indent": 0,
      "text": "7.3. Misbehaving Logs",
      "section_title": true,
      "ja": "7.3。ふらちなログ"
    },
    {
      "indent": 3,
      "text": "A log can misbehave in two ways: (1) by failing to incorporate a certificate with an SCT in the Merkle Tree within the MMD and (2) by violating its append-only property by presenting two different, conflicting views of the Merkle Tree at different times and/or to different parties. Both forms of violation will be promptly and publicly detectable.",
      "ja": "でマークル木の二つの異なる、相反する見解を提示することによって、その追加専用プロパティに違反することによりMMD及び（2）内のマークル木におけるSCTと証明書を組み込むために失敗することにより（1）：ログは、2つの方法で誤動作することができ異なる時間および/または異なる政党へ。違反の両方の形式は、迅速かつ公に検出可能となります。"
    },
    {
      "indent": 3,
      "text": "Violation of the MMD contract is detected by log clients requesting a Merkle audit proof for each observed SCT. These checks can be asynchronous and need only be done once per each certificate. In order to protect the clients' privacy, these checks need not reveal the exact certificate to the log. Clients can instead request the proof from a trusted auditor (since anyone can compute the audit proofs from the log) or request Merkle proofs for a batch of certificates around the SCT timestamp.",
      "ja": "MMD契約の違反は、各観測SCT用マークル監査の証拠を要求するログクライアントによって検出されます。これらのチェックは非同期にすることができ、唯一の各証明書ごとに一度行われる必要があります。お客様のプライバシーを保護するためには、これらのチェックは、ログへの正確な証明書を明らかにする必要はありません。 （誰でもログから監査証明を計算することができるので）、またはSCTタイムスタンプの周りの証明書のバッチのマークル証明を要求するクライアントは、代わりに信頼され、監査人からの証明を要求することができます。"
    },
    {
      "indent": 3,
      "text": "Violation of the append-only property is detected by global gossiping, i.e., everyone auditing logs comparing their versions of the latest Signed Tree Heads. As soon as two conflicting Signed Tree",
      "ja": "追加専用プロパティの違反は、グローバル噂、最新の署名ツリーヘッドの彼らのバージョンを比較する、すなわち、誰も監査ログによって検出されます。すぐに2としては、ツリー署名相反する"
    },
    {
      "indent": 3,
      "text": "Heads for the same log are detected, this is cryptographic proof of that log's misbehavior.",
      "ja": "同じログのヘッドが検出され、これはそのログの不正行為の暗号化証明です。"
    },
    {
      "indent": 0,
      "text": "8. Efficiency Considerations",
      "section_title": true,
      "ja": "8.効率の検討"
    },
    {
      "indent": 3,
      "text": "The Merkle Tree design serves the purpose of keeping communication overhead low.",
      "ja": "マークル木のデザインは、オーバーヘッドの低い通信を維持する目的を果たします。"
    },
    {
      "indent": 3,
      "text": "Auditing logs for integrity does not require third parties to maintain a copy of each entire log. The Signed Tree Heads can be updated as new entries become available, without recomputing entire trees. Third-party auditors need only fetch the Merkle consistency proofs against a log's existing STH to efficiently verify the append-only property of updates to their Merkle Trees, without auditing the entire tree.",
      "ja": "整合性のための監査ログは、各ログ全体のコピーを維持するために第三者を必要としません。新しいエントリが利用可能になったとして署名ツリーヘッドは、ツリー全体を再計算せずに、更新することができます。サードパーティの監査役は、効率的にツリー全体を監査することなく、彼らのハッシュ木への更新の追加専用プロパティを検証するために、ログの既存のSTHに対してマークル一貫性の証明を取得するだけです。"
    },
    {
      "indent": 0,
      "text": "9. Future Changes",
      "section_title": true,
      "ja": "9.将来の変更"
    },
    {
      "indent": 3,
      "text": "This section lists things we might address in a Standards Track version of this document.",
      "ja": "このセクションでは、我々は、この文書の標準化過程のバージョンに対処する可能性がある事を示しています。"
    },
    {
      "indent": 3,
      "text": "o Rather than forcing a log operator to create a new log in order to change the log signing key, we may allow some key roll mechanism.",
      "ja": "Oむしろログ署名キーを変更するために新しいログを作成するには、ログ演算子を強制するよりも、我々はいくつかのキーロールメカニズムを可能にすることができます。"
    },
    {
      "indent": 3,
      "text": "o We may add hash and signing algorithm agility.",
      "ja": "O私たちは、ハッシュと署名アルゴリズムの俊敏性を追加することができます。"
    },
    {
      "indent": 3,
      "text": "o We may describe some gossip protocols.",
      "ja": "O我々はいくつかのゴシッププロトコルを記述することができます。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgements",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Erwann Abelea, Robin Alden, Al Cutter, Francis Dupont, Stephen Farrell, Brad Hill, Jeff Hodges, Paul Hoffman, Jeffrey Hutzelman, SM, Alexey Melnikov, Chris Palmer, Trevor Perrin, Ryan Sleevi, Rob Stradling, and Carl Wallace for their valuable contributions.",
      "ja": "著者は、Erwann Abelea、ロビン・オールデン、アルカッター、フランシスデュポン、スティーブン・ファレル、ブラッド・ヒル、ジェフ・ホッジス、ポール・ホフマン、ジェフリーHutzelman、SM、アレクセイ・メルニコフ、クリス・パーマー、トレバー・ペラン、ライアンSleevi、ロブStradlingに感謝したいと思いますそして彼らの貴重な貢献のためのカール・ウォレス。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative Reference",
      "section_title": true,
      "ja": "11.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[CrosbyWallach] Crosby, S. and D. Wallach, \"Efficient Data Structures for Tamper-Evident Logging\", Proceedings of the 18th USENIX Security Symposium, Montreal, August 2009, <http://static.usenix.org/event/sec09/ tech/full_papers/crosby.pdf>.",
      "ja": "[CrosbyWallach]はクロスビー、S.およびD.ウォラック、「改ざん防止用のロギングのための効率的なデータ構造」、第18回USENIXセキュリティシンポジウム、モントリオール、2009年8月の議事録、<http://static.usenix.org/event/sec09 /ハイテク/ full_papers / crosby.pdf>。"
    },
    {
      "indent": 3,
      "text": "[DSS] National Institute of Standards and Technology, \"Digital Signature Standard (DSS)\", FIPS 186-3, June 2009, <http://csrc.nist.gov/publications/fips/ fips186-3/fips_186-3.pdf>.",
      "ja": "[DSS]米国国立標準技術研究所は、 \"デジタル署名標準（DSS）\"、186-3、2009年6月、<http://csrc.nist.gov/publications/fips/ FIPS186-3 / fips_186-3 FIPS。 PDF>。"
    },
    {
      "indent": 3,
      "text": "[FIPS.180-4] National Institute of Standards and Technology, \"Secure Hash Standard\", FIPS PUB 180-4, March 2012, <http://csrc.nist.gov/publications/fips/fips180-4/ fips-180-4.pdf>.",
      "ja": "[FIPS.180-4]アメリカ国立標準技術研究所、 \"セキュアハッシュ標準\"、FIPS PUB 180-4の、2012年3月、<http://csrc.nist.gov/publications/fips/fips180-4/ fips- 180-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[HTML401] Raggett, D., Le Hors, A., and I. Jacobs, \"HTML 4.01 Specification\", World Wide Web Consortium Recommendation REC-html401-19991224, December 1999, <http://www.w3.org/TR/1999/REC-html401-19991224>.",
      "ja": "[HTML401] Raggett、D.、ル・オードブル、A.、およびI.ジェイコブス、 \"HTML 4.01仕様書\"、World Wide Web Consortium（W3C）の勧告REC-html401-19991224、1999年12月、<http://www.w3.org/ TR / 1999 / REC-html401-19991224>。"
    },
    {
      "indent": 3,
      "text": "[RFC2560] Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, \"X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP\", RFC 2560, June 1999.",
      "ja": "[RFC2560]マイヤーズ、M.、Ankney、R.、Malpani、A.、Galperin、S.、およびC.アダムス、 \"X.509のインターネット公開鍵暗号基盤のオンライン証明書状態プロトコル -  OCSP\"、RFC 2560、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003.",
      "ja": "[RFC3447]ジョンソン、J.とB. Kaliski、 \"公開鍵暗号規格（PKCS）＃1：RSA暗号仕様バージョン2.1\"、RFC 3447、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4627] Crockford, D., \"The application/json Media Type for JavaScript Object Notation (JSON)\", RFC 4627, July 2006.",
      "ja": "[RFC4627]クロックフォード、D.、RFC 4627、2006年7月 \"JavaScriptのObject Notation（JSON）形式のためのアプリケーション/ JSONのメディアタイプ\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、2006年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5905] Mills, D., Martin, J., Burbank, J., and W. Kasch, \"Network Time Protocol Version 4: Protocol and Algorithms Specification\", RFC 5905, June 2010.",
      "ja": "[RFC5905]ミルズ、D.、マーティン、J.、バーバンク、J.、およびW. Kasch、 \"ネットワークタイムプロトコルバージョン4：プロトコルとアルゴリズムの仕様\"、RFC 5905、2010年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, January 2011.",
      "ja": "[RFC6066]イーストレイク、D.、 \"トランスポート層セキュリティ（TLS）拡張機能：拡張定義\"、RFC 6066、2011年1月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ben Laurie Google UK Ltd.",
      "ja": "ベン・ローリーグーグルUK社"
    },
    {
      "indent": 3,
      "text": "EMail: benl@google.com",
      "ja": "メールアドレス：benl@google.com"
    },
    {
      "indent": 3,
      "text": "Adam Langley Google Inc.",
      "ja": "アダム・ラングレーグーグル株式会社"
    },
    {
      "indent": 3,
      "text": "EMail: agl@google.com",
      "ja": "メールアドレス：agl@google.com"
    },
    {
      "indent": 3,
      "text": "Emilia Kasper Google Switzerland GmbH",
      "ja": "エミリア・カスパーGoogleのスイス社"
    },
    {
      "indent": 3,
      "text": "EMail: ekasper@google.com",
      "ja": "メールアドレス：ekasper@google.com"
    }
  ]
}