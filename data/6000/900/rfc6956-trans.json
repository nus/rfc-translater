{
  "title": {
    "text": "RFC 6956 - Forwarding and Control Element Separation (ForCES) Logical Function Block (LFB) Library",
    "ja": "RFC 6956 - 転送と制御素子分離（のForCES）論理機能ブロック（LFB）ライブラリ"
  },
  "number": 6956,
  "created_at": "2019-11-02 03:08:53.616609+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           W. Wang\nRequest for Comments: 6956                 Zhejiang Gongshang University\nCategory: Standards Track                                  E. Haleplidis\nISSN: 2070-1721                                     University of Patras\n                                                                K. Ogawa\n                                                         NTT Corporation\n                                                                   C. Li\n                                                         Hangzhou DPtech\n                                                              J. Halpern\n                                                                Ericsson\n                                                               June 2013",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Forwarding and Control Element Separation (ForCES)\n       Logical Function Block (LFB) Library",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document defines basic classes of Logical Function Blocks (LFBs) used in Forwarding and Control Element Separation (ForCES). The basic LFB classes are defined according to the ForCES Forwarding Element (FE) model and ForCES protocol specifications; they are scoped to meet requirements of typical router functions and are considered the basic LFB library for ForCES. The library includes the descriptions of the LFBs and the XML definitions.",
      "ja": "この文書では、転送と制御要素の分離（のForCES）で使用される論理機能ブロック（LFBs）の基本クラスを定義します。基本的なLFBクラスはのForCES転送要素（FE）モデル、強制的プロトコル仕様に従って定義されます。彼らは、一般的なルータ機能の要件を満たすためにスコープされ、強制的にするための基本的なLFBライブラリを考えられています。ライブラリはLFBsの説明とXML定義が含まれています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6956.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6956で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Terminology and Conventions .....................................4\n   2.1. Requirements Language ......................................4\n   2.2. Definitions ................................................4\n3. Overview ........................................................6\n   3.1. Scope of the Library .......................................6\n   3.2. Overview of LFB Classes in the Library .....................8\n        3.2.1. LFB Design Choices ..................................8\n        3.2.2. LFB Class Groupings .................................9\n        3.2.3. Sample LFB Class Application .......................10\n   3.3. Document Structure ........................................11\n4. Base Types .....................................................11\n   4.1. Data Types ................................................13\n        4.1.1. Atomic .............................................13\n        4.1.2. Compound Struct ....................................13\n        4.1.3. Compound Array .....................................14\n   4.2. Frame Types ...............................................14\n   4.3. Metadata Types ............................................15\n   4.4. XML for Base Type Library .................................16\n5. LFB Class Descriptions .........................................41\n   5.1. Ethernet-Processing LFBs ..................................42\n        5.1.1. EtherPHYCop ........................................42\n        5.1.2. EtherMACIn .........................................44\n        5.1.3. EtherClassifier ....................................46\n        5.1.4. EtherEncap .........................................48\n        5.1.5. EtherMACOut ........................................50\n   5.2. IP Packet Validation LFBs .................................52\n        5.2.1. IPv4Validator ......................................52\n        5.2.2. IPv6Validator ......................................54",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   5.3. IP Forwarding LFBs ........................................55\n        5.3.1. IPv4UcastLPM .......................................56\n        5.3.2. IPv4NextHop ........................................58\n        5.3.3. IPv6UcastLPM .......................................60\n        5.3.4. IPv6NextHop ........................................62\n   5.4. Redirect LFBs .............................................64\n        5.4.1. RedirectIn .........................................64\n        5.4.2. RedirectOut ........................................65\n   5.5. General Purpose LFBs ......................................66\n        5.5.1. BasicMetadataDispatch ..............................66\n        5.5.2. GenericScheduler ...................................68\n6. XML for LFB Library ............................................69\n7. LFB Class Use Cases ............................................97\n   7.1. IPv4 Forwarding ...........................................98\n   7.2. ARP Processing ...........................................101\n8. IANA Considerations ...........................................102\n   8.1. LFB Class Names and LFB Class Identifiers ................103\n   8.2. Metadata ID ..............................................105\n   8.3. Exception ID .............................................106\n   8.4. Validate Error ID ........................................107\n9. Security Considerations .......................................108\n10. References ...................................................108\n   10.1. Normative References ....................................108\n   10.2. Informative References ..................................108\nAppendix A.  Acknowledgements ....................................110\nAppendix B.  Contributors ........................................110",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "[RFC3746] specifies the Forwarding and Control Element Separation (ForCES) framework. In the framework, Control Elements (CEs) configure and manage one or more separate Forwarding Elements (FEs) within a Network Element (NE) by use of a ForCES protocol. [RFC5810] specifies the ForCES protocol. [RFC5812] specifies the Forwarding Element (FE) model. In the model, resources in FEs are described by classes of Logical Function Blocks (LFBs). The FE model defines the structure and abstract semantics of LFBs and provides XML schema for the definitions of LFBs.",
      "ja": "[RFC3746]は転送と制御素子分離（のForCES）フレームワークを指定します。フレームワークでは、制御要素（CES）の設定、強制的プロトコルを用いてネットワーク要素（NE）内の1つの以上の別個の転送要素（FE）を管理します。 [RFC5810]はのForCESプロトコルを指定します。 [RFC5812]は転送要素（FE）モデルを指定します。モデルでは、フェスにリソースを論理機能ブロック（LFBs）のクラスによって記述されています。 FEモデルはLFBsの構造と抽象的意味を定義し、LFBsの定義のためのXMLスキーマを提供します。"
    },
    {
      "indent": 3,
      "text": "This document conforms to the specifications of the FE model [RFC5812] and specifies detailed definitions of classes of LFBs, including detailed XML definitions of LFBs. These LFBs form a base LFB library for ForCES. LFBs in the base library are expected to be combined to form an LFB topology for a typical router to implement IP forwarding. It should be emphasized that an LFB is an abstraction of functions rather than implementation details. The purpose of the LFB definitions is to represent functions so as to provide interoperability between separate CEs and FEs.",
      "ja": "この文書では、FEモデル[RFC5812]の仕様に準拠し、LFBsの詳細なXML定義を含むLFBsのクラスの詳細な定義を指定します。これらのLFBsは力をベースLFBライブラリーを形成します。ベースライブラリのLFBsは、IP転送を実現するための典型的なルータのLFBトポロジーを形成するために結合されることが期待されます。 LFBは機能ではなく、実装の詳細を抽象化したものであることを強調しなければなりません。 LFB定義の目的は、別個のCEとFEとの間の相互運用性を提供するように機能を表すことです。"
    },
    {
      "indent": 3,
      "text": "More LFB classes with more functions may be developed in the future and documented by the IETF. Vendors may also develop proprietary LFB classes as described in the FE model [RFC5812].",
      "ja": "より多くの機能を持つほかのLFBクラスは、将来的に開発され、IETFによって文書化することができます。 FEモデル[RFC5812]に記載されているように、ベンダーは、また、独自のLFBクラスを開発することができます。"
    },
    {
      "indent": 0,
      "text": "2. Terminology and Conventions",
      "section_title": true,
      "ja": "2.用語と表記"
    },
    {
      "indent": 0,
      "text": "2.1. Requirements Language",
      "section_title": true,
      "ja": "2.1。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Definitions",
      "section_title": true,
      "ja": "2.2。定義"
    },
    {
      "indent": 3,
      "text": "This document follows the terminology defined by the ForCES protocol in [RFC5810] and by the ForCES FE model in [RFC5812]. The definitions below are repeated for clarity.",
      "ja": "このドキュメントは[RFC5810]及び[RFC5812]の力FEモデルでのForCESプロトコルによって定義された用語を以下。以下の定義は明確にするために繰り返されます。"
    },
    {
      "indent": 6,
      "text": "Control Element (CE) - A logical entity that implements the ForCES protocol and uses it to instruct one or more FEs on how to process packets. CEs handle functionality such as the execution of control and signaling protocols.",
      "ja": "制御要素（CE） - のForCESプロトコルを実装し、パケットを処理する方法の一の以上のFEを指示するためにそれを使用する論理エンティティ。 CEは、このような制御およびシグナリングプロトコルの実行などの機能を扱います。"
    },
    {
      "indent": 6,
      "text": "Forwarding Element (FE) - A logical entity that implements the ForCES protocol. FEs use the underlying hardware to provide per-packet processing and handling as directed/controlled by one or more CEs via the ForCES protocol.",
      "ja": "転送要素（FE） - のForCESプロトコルを実装する論理エンティティ。 FEは、のForCESプロトコルを介して1つのまたは複数のCEによって制御/指示されるように、パケット単位の処理および取り扱いを提供するために、基礎となるハードウェアを使用します。"
    },
    {
      "indent": 6,
      "text": "ForCES Network Element (NE) - An entity composed of one or more CEs and one or more FEs. To entities outside an NE, the NE represents a single point of management. Similarly, an NE usually hides its internal organization from external entities.",
      "ja": "ForCESネットワーク要素（NE） - 一の以上のCEと1つの以上のFEで構成するエンティティ。 NE外のエンティティに、NEは、単一の管理ポイントを表します。同様に、NEは、通常、外部エンティティからその内部組織を隠します。"
    },
    {
      "indent": 6,
      "text": "Logical Function Block (LFB) - The basic building block that is operated on by the ForCES protocol. The LFB is a well-defined, logically separable functional block that resides in an FE and is controlled by the CE via the ForCES protocol. The LFB may reside at the FE's data path and process packets or may be purely an FE control or configuration entity that is operated on by the CE. Note that the LFB is a functionally accurate abstraction of the FE's processing capabilities but not a hardware-accurate representation of the FE implementation.",
      "ja": "論理機能ブロック（LFB） - のForCESプロトコルによって操作された基本的なビルディングブロック。 LFBはFEに存在する、強制的プロトコルを介してCEによって制御され、明確に定義され、論理的に分離可能な機能ブロックです。 LFBはFEのデータパスおよびプロセスパケットに存在し得るか、または純粋にCEによって操作されたFE制御または構成エンティティであってもよいです。 LFBは、機能的に正確なFEの処理能力の抽象化ではなく、FE実装のハードウェア、正確な表現であることに注意してください。"
    },
    {
      "indent": 6,
      "text": "FE Model - The FE model is designed to model the logical processing functions of an FE, which is defined by the ForCES FE model document [RFC5812]. The FE model proposed in this document includes three components: the LFB modeling of individual Logical Functional Blocks (LFB model), the logical interconnection between",
      "ja": "FEモデル -  FEモデルは、のForCES FEモデル文書[RFC5812]で定義されるFEの論理処理機能をモデル化するために設計されています。個々の論理機能ブロック（LFBモデル）のLFBモデリング、間の論理的な相互接続：この文書で提案されたFEモデルは、3つのコンポーネントが含まれ"
    },
    {
      "indent": 6,
      "text": "LFBs (LFB topology), and the FE-level attributes, including FE capabilities. The FE model provides the basis to define the information elements exchanged between the CE and the FE in the ForCES protocol [RFC5810].",
      "ja": "FE機能を含むLFBs（LFBトポロジー）、及びFEレベル属性。 FEモデルは、のForCESプロトコル[RFC5810]でCEとFEとの間で交換される情報要素を定義するための基礎を提供します。"
    },
    {
      "indent": 6,
      "text": "FE Topology - A representation of how the multiple FEs within a single NE are interconnected. Sometimes this is called inter-FE topology, to be distinguished from intra-FE topology (i.e., LFB topology).",
      "ja": "FEトポロジ - 単一NE内の複数のFEが相互接続されているかを表現。時にはこれは、イントラFEトポロジ（すなわち、LFBトポロジー）と区別するために、インターFEトポロジと呼ばれています。"
    },
    {
      "indent": 6,
      "text": "LFB Class and LFB Instance - LFBs are categorized by LFB classes. An LFB instance represents an LFB class (or type) existence. There may be multiple instances of the same LFB class (or type) in an FE. An LFB class is represented by an LFB class ID, and an LFB instance is represented by an LFB instance ID. As a result, an LFB class ID associated with an LFB instance ID uniquely specifies an LFB existence.",
      "ja": "LFBクラスとインスタンスLFB  -  LFBsはLFBクラスによって分類されています。 LFBインスタンスは、LFBのクラス（またはタイプ）が存在することを表します。 FEに同じLFBクラス（またはタイプ）の複数のインスタンスが存在してもよいです。 LFBクラスはLFBクラスIDによって表され、LFBインスタンスはLFBインスタンスIDによって表されます。結果として、LFBインスタンスIDに関連付けられたLFBクラスIDは一意にLFBの存在を特定します。"
    },
    {
      "indent": 6,
      "text": "LFB Metadata - Metadata is used to communicate per-packet state from one LFB to another but is not sent across the network. The FE model defines how such metadata is identified, produced, and consumed by the LFBs. It defines the functionality but not how metadata is encoded within an implementation.",
      "ja": "LFBメタ - メタデータは、別のLFBからパケット単位の状態を通信するために使用されるが、ネットワークを介して送信されていません。 FEモデルは、メタデータが、識別された生成、及びLFBsによって消費される方法を定義します。これは、機能を定義しますが、メタデータは、実装内でエンコードされていませんか。"
    },
    {
      "indent": 6,
      "text": "LFB Component - Operational parameters of the LFBs that must be visible to the CEs are conceptualized in the FE model as the LFB components. The LFB components include, for example, flags, single parameter arguments, complex arguments, and tables that the CE can read and/or write via the ForCES protocol (see below).",
      "ja": "LFBコンポーネント -  CEに見えなければならないLFBsの動作パラメータは、LFB成分としてFEモデルで概念化されます。 LFB成分（下記参照）、例えば、フラグ、単一のパラメータ、引数、複雑な引数、及びCEは、読み取り及び/又はのForCESプロトコルを介して書き込むことができるテーブルを含みます。"
    },
    {
      "indent": 6,
      "text": "LFB Topology - Representation of how the LFB instances are logically interconnected and placed along the data path within one FE. Sometimes it is also called intra-FE topology, to be distinguished from inter-FE topology.",
      "ja": "LFBトポロジ -  LFBインスタンスが論理的に相互接続し、1 FE内のデータ・パスに沿って配置されているかの表現。時にはまた、インター-FEトポロジと区別するために、内-FEトポロジと呼ばれています。"
    },
    {
      "indent": 6,
      "text": "Data Path - A conceptual path taken by packets within the forwarding plane inside an FE. Note that more than one data path can exist within an FE.",
      "ja": "データパス -  FE内部転送プレーン内のパケットによって取ら概念パス。複数のデータパスは、FE内に存在することができることに留意されたいです。"
    },
    {
      "indent": 6,
      "text": "ForCES Protocol - While there may be multiple protocols used within the overall ForCES architecture, the term \"ForCES protocol\" and \"protocol\" refer to the Fp reference points in the ForCES framework in [RFC3746]. This protocol does not apply to CE-to-CE communication, FE-to-FE communication, or to communication between FE and CE managers. Basically, the ForCES protocol works in a master-slave mode in which FEs are slaves and CEs are masters.",
      "ja": "ForCESプロトコルは - 全体のForCESアーキテクチャ内で使用される複数のプロトコルが存在してもよいが、用語「のForCESプロトコル」および「プロトコル」は、[RFC3746]の力の枠組みの中のFP基準点を指します。このプロトコルは、CE-に-CE通信、FE-に-FE通信、またはFEとCEマネージャ間の通信には適用されません。基本的に、複数のFEは、スレーブおよびCEされたマスタ・スレーブモードの力プロトコル作品はマスターです。"
    },
    {
      "indent": 6,
      "text": "Physical Port - A port refers to a physical media input port or output port of an FE. A physical port is usually assigned with a physical port ID, abbreviated with a PHYPortID. This document mainly deals with physical ports with Ethernet media.",
      "ja": "物理ポート - ポートはFEの物理メディア入力ポートまたは出力ポートを指します。物理ポートは、通常PHYPortIDと略記する物理ポートID、割り当てられています。この文書では、主にイーサネットメディアとの物理ポートを扱います。"
    },
    {
      "indent": 6,
      "text": "Logical Port - A conceptually virtual port at the data link layer (L2) or network layer (L3). A logical port is usually assigned with a logical port ID, abbreviated with a LogicalPortID. The logical ports can be further categorized with an L2 logical port or an L3 logical port. An L2 logical port can be assigned with an L2 logical port ID, abbreviated with an L2PortID. An L3 logical port can be assigned with an L3 logical port ID, abbreviated with an L3PortID. MAC-layer VLAN ports belong to logical ports, and they belong to L2 logical ports.",
      "ja": "論理ポート - データリンクレイヤ（L2）またはネットワーク層（L3）に概念的に仮想ポート。論理ポートは、通常LogicalPortIDと略記する論理ポートIDとが割り当てられます。論理ポートはさらに、L2論理ポートまたはL3論理ポートと分類することができます。 L2論理ポートはL2PortIDと略記L2論理ポートIDで割り当てることができます。 L3論理ポートはL3PortIDと略記L3論理ポートIDで割り当てることができます。 MACレイヤVLANポートは、論理ポートに属し、彼らはL2論理ポートに属しています。"
    },
    {
      "indent": 6,
      "text": "LFB Port - The connection points where one LFB can be connected to another within an FE. As described in [RFC5812], the CE can connect LFBs together by establishing connections between an output port of one LFB instance and an input port of another LFB instance. Also see Section 3.2 of [RFC5812] for more details.",
      "ja": "LFBポート - オンLFBは、FE内で相互に接続することができる接続ポイント。 [RFC5812]に記載されているように、CEは、一つLFBインスタンスと別のLFBインスタンスの入力ポートの出力ポート間の接続を確立することによって一緒にLFBsを接続することができます。また、詳細については[RFC5812]の3.2節を参照してください。"
    },
    {
      "indent": 6,
      "text": "Singleton Port - A named input or output port of an LFB. This port is referred to by a name. When the context is clear, the term \"singleton\" by itself is used to refer to a singleton port.",
      "ja": "シングルトン港 -  LFBの名前の入力または出力ポート。このポートは名前で呼ばれています。文脈が明確である場合は、それ自体で用語「シングルトンは、」シングルトンポートを参照するために使用されます。"
    },
    {
      "indent": 6,
      "text": "Group Port - A named collection of input or output ports of an LFB. A group port is referred to by a name. A group port consists of a number of port instances, which are referred to by a combination of a name and an index.",
      "ja": "グループ港 -  LFBの入力または出力ポートの名前付きコレクション。グループのポートは名前で呼ばれています。グループポートは、名前とインデックスとの組み合わせによって参照されたポートインスタンスの数から成ります。"
    },
    {
      "indent": 6,
      "text": "LFB Class Library - The LFB class library is a set of LFB classes that has been identified as the most common functions found in most FEs and hence should be defined first by the ForCES Working Group. The LFB class library is defined by this document.",
      "ja": "LFBクラスライブラリ -  LFBクラスライブラリは、ほとんどのフェスに見られる最も一般的な機能として同定されており、したがってのForCESワーキンググループで最初に定義されるべきであるLFBクラスのセットです。 LFBクラスライブラリは、このドキュメントで定義されています。"
    },
    {
      "indent": 0,
      "text": "3. Overview",
      "section_title": true,
      "ja": "3.概要"
    },
    {
      "indent": 0,
      "text": "3.1. Scope of the Library",
      "section_title": true,
      "ja": "3.1。図書館のスコープ"
    },
    {
      "indent": 3,
      "text": "It is intended that the LFB classes described in this document are designed to provide the functions of a typical router. [RFC1812] specifies that a typical router is expected to provide functions to: (1) Interface to packet networks and implement the functions required by that network. These functions typically include:",
      "ja": "この文書で説明LFBクラスは、一般的なルータの機能を提供するように設計されていることが意図されています。パケット・ネットワークに（1）インタフェースとそのネットワークによって必要とされる機能を実現する：[RFC1812]は、一般的なルータの機能を提供することが期待されることを指定します。これらの機能は通常、次のとおりです。"
    },
    {
      "indent": 8,
      "text": "*  Encapsulating and decapsulating the IP datagrams with the\n   connected network framing (e.g., an Ethernet header and\n   checksum),",
      "raw": true
    },
    {
      "indent": 8,
      "text": "* Sending and receiving IP datagrams up to the maximum size supported by that network (this size is the network's Maximum Transmission Unit or MTU),",
      "ja": "*送信と（このサイズは、ネットワークの最大転送単位であるか、MTU）IPは、そのネットワークがサポートする最大サイズまでデータグラムの受信、"
    },
    {
      "indent": 8,
      "text": "* Translating the IP destination address into an appropriate network-level address for the connected network (e.g., an Ethernet hardware address), if needed, and",
      "ja": "*必要に応じて、接続されたネットワークのための適切なネットワーク・レベルのアドレス（例えば、イーサネット（登録商標）ハードウェアアドレス）にIP宛先アドレスを変換、および"
    },
    {
      "indent": 8,
      "text": "* Responding to network flow control and error indications, if any.",
      "ja": "*いずれかの場合には、フロー制御とエラー表示をネットワークに応答します。"
    },
    {
      "indent": 3,
      "text": "(2) Conform to specific Internet protocols including the Internet Protocol (IPv4 and/or IPv6), Internet Control Message Protocol (ICMP), and others as necessary.",
      "ja": "（2）必要に応じてインターネットプロトコル（IPv4および/またはIPv6）、インターネット制御メッセージプロトコル（ICMP）、およびその他を含む特定のインターネットプロトコルに準拠。"
    },
    {
      "indent": 3,
      "text": "(3) Receive and forward Internet datagrams. Important issues in this process are buffer management, congestion control, and fairness.",
      "ja": "（3）インターネットデータグラムを受信し、前方に。このプロセスの重要な問題は、バッファ管理、輻輳制御、および公正されています。"
    },
    {
      "indent": 8,
      "text": "*  Recognize error conditions and generate ICMP error and\n   information messages as required.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "* Drop datagrams whose time-to-live fields have reached zero.",
      "ja": "*その生存時間フィールドがゼロに達したドロップデータグラム。"
    },
    {
      "indent": 8,
      "text": "* Fragment datagrams when necessary to fit into the MTU of the next link or interface.",
      "ja": "*フラグメントデータグラムは、必要なときに、次のリンクまたはインターフェイスのMTUに収まるように。"
    },
    {
      "indent": 3,
      "text": "(4) Choose a next-hop destination for each IP datagram, based on the information in its routing database.",
      "ja": "（4）そのルーティングデータベース内の情報に基づいて、各IPデータグラムのための次のホップ先を選択。"
    },
    {
      "indent": 3,
      "text": "(5) Usually support an interior gateway protocol (IGP) to carry out distributed routing and reachability algorithms with the other routers in the same autonomous system. In addition, some routers will need to support an exterior gateway protocol (EGP) to exchange topological information with other autonomous systems. For all routers, it is essential to provide the ability to manage static routing items.",
      "ja": "（5）通常、同じ自律システム内の他のルータと分散ルーティングおよび到達可能性アルゴリズムを実行するために内部ゲートウェイプロトコル（IGP）をサポートします。加えて、いくつかのルータは、他の自律システムとトポロジ情報を交換する外部ゲートウェイプロトコル（EGP）をサポートする必要があります。すべてのルータの場合は、スタティックルーティング項目を管理する機能を提供することが不可欠です。"
    },
    {
      "indent": 3,
      "text": "(6) Provide network management and system support facilities, including loading, debugging, status reporting, statistics query, exception reporting, and control.",
      "ja": "（6）ロード、デバッグ、状況報告、統計クエリ、例外報告、および制御を含むネットワーク管理とシステム支援施設を、提供します。"
    },
    {
      "indent": 3,
      "text": "The classical IP router utilizing the ForCES framework constitutes a CE running some controlling IGP and/or EGP function or static route setup and FEs implemented by use of Logical Function Blocks (LFBs) conforming to the FE model [RFC5812] specification. The CE, in conformance to the ForCES protocol [RFC5810] and the FE model [RFC5812] specifications, instructs the LFBs on the FE how to treat received/sent packets.",
      "ja": "ForCESフレームワークを利用した古典的なIPルータは、いくつかの制御IGPおよび/またはEGP機能または静的経路設定とFEモデル[RFC5812]仕様に準拠した論理機能ブロック（LFBs）を使用することによって実現さのFEを実行CEを構成します。 CEは、のForCESプロトコル[RFC5810]とFEモデル[RFC5812]の仕様に準拠して、送信/受信パケットを処理する方法FEにLFBsに指示します。"
    },
    {
      "indent": 3,
      "text": "Packets in an IP router are received and transmitted on physical media typically referred to as \"ports\". Different physical media will have different ways for encapsulating outgoing frames and decapsulating incoming frames. The different physical media will also have different attributes that influence its behavior and how frames get encapsulated or decapsulated. This document will only deal with Ethernet physical media. Future documents may deal with other types of media. This document will also interchangeably refer to a port as an abstraction that constitutes a physical layer (PHY) and a Media Access Control (MAC) layer, as described by LFBs like EtherPHYCop, EtherMACIn, and EtherMACOut.",
      "ja": "IPルータにパケットが受信され、典型的には「ポート」と呼ばれる物理メディア上で送信されます。異なる物理メディアが発信フレームをカプセル化し、着信フレームをカプセル開放のためのさまざまな方法があります。異なる物理メディアはまた、フレームがカプセル化またはカプセル化解除取得する方法、その動作に影響を与え、異なる属性を持つことになります。この文書では、唯一のイーサネット物理メディアに対処します。将来の文書は、他のタイプのメディアを扱うことがあります。この文書はまた、交換可能にEtherPHYCop、EtherMACIn、及びEtherMACOut等LFBsによって記載されているように、物理層（PHY）及びメディアアクセス制御（MAC）層を構成する抽象としてポートを参照します。"
    },
    {
      "indent": 3,
      "text": "IP packets emanating from port LFBs are then processed by a validation LFB before being further forwarded to the next LFB. After the validation process, the packet is passed to an LFB where an IP forwarding decision is made. In the IP Forwarding LFBs, a Longest Prefix Match LFB is used to look up the destination information in a packet and select a next-hop index for sending the packet onward. A next-hop LFB uses the next-hop index metadata to apply the proper headers to the IP packets and direct them to the proper egress. Note that in the process of IP packet processing, in this document, we are adhering to the weak-host model [RFC1122] since that is the most usable model for a packet processing a Network Element.",
      "ja": "ポートLFBsから発せられるIPパケットは、さらに次のLFBに転送される前に検証LFBによって処理されています。検証プロセスの後、パケットがIPフォワーディング決定がなされLFBに渡されます。 IPフォワーディングLFBsでは、最長プレフィックスマッチLFBは、パケットの宛先情報を検索し、以降のパケットを送信するためのネクストホップインデックスを選択するために使用されます。ネクストホップLFBは、IPパケットに適切なヘッダを適用し、適切な出口にそれらを指示するためにネクストホップインデックス・メタデータを使用しています。 IPパケット処理の過程において、この文書では、我々はそれがネットワーク要素を処理するパケットのために最も使用可能なモデルであるため、弱いホストモデル[RFC1122]に付着していることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "3.2. Overview of LFB Classes in the Library",
      "section_title": true,
      "ja": "3.2。ライブラリのLFBクラスの概要"
    },
    {
      "indent": 3,
      "text": "It is critical to classify functional requirements into various classes of LFBs and construct a typical but also flexible enough base LFB library for various IP forwarding equipments.",
      "ja": "LFBsの様々なクラスに機能要件を分類し、さまざまなIP転送機器の一般的なだけでなく、十分な柔軟性をベースLFBライブラリーを構築することが重要です。"
    },
    {
      "indent": 0,
      "text": "3.2.1. LFB Design Choices",
      "section_title": true,
      "ja": "3.2.1。 LFBデザインの選択"
    },
    {
      "indent": 3,
      "text": "A few design principles were factored into choosing what the base LFBs look like:",
      "ja": "いくつかの設計原理は、ベースLFBsがどのように見えるかを選ぶことに織り込まれました："
    },
    {
      "indent": 3,
      "text": "o If a function can be designed by either one LFB or two or more LFBs with the same cost, the choice is to go with two or more LFBs so as to provide more flexibility for implementers.",
      "ja": "関数が1つのLFBまたは同じコストを持つ2つ以上のLFBsのいずれかによって設計することができた場合は、O、選択は実装者のためのより多くの柔軟性を提供するように、二つ以上のLFBsに行くことです。"
    },
    {
      "indent": 3,
      "text": "o An LFB should take advantage of its independence as much as possible and have minimal coupling with other LFBs. The coupling may be from LFB attributes definitions as well as physical implementations.",
      "ja": "O LFBは、可能な限りその独立性を活用し、他のLFBsと最小限のカップリングを持っている必要があります。カップリングは、LFBの定義と同様の物理的実装を属性からのものであってもよいです。"
    },
    {
      "indent": 3,
      "text": "o Unless there is a clear difference in functionality, similar packet processing in the base LFB library should not be represented simultaneously as two or more LFBs. For instance, it should not be simultaneously defined with two different LFBs for the same next-hop processing. Otherwise, it may add extra burden on implementation to achieve interoperability.",
      "ja": "機能的に明確な差がある場合を除き、O、基地LFBライブラリにおける同様のパケット処理は、2つ以上のLFBsとして同時に表されるべきではありません。例えば、それは同時に、同じネクストホップ処理のための2つの異なるLFBsで定義されるべきではありません。それ以外の場合は、相互運用性を実現するために実装に余計な負担を加えることができます。"
    },
    {
      "indent": 0,
      "text": "3.2.2. LFB Class Groupings",
      "section_title": true,
      "ja": "3.2.2。 LFBクラスのグループ化"
    },
    {
      "indent": 3,
      "text": "This document defines groups of LFBs for typical router function requirements:",
      "ja": "この文書では、一般的なルータ機能要件についてLFBsのグループを定義します。"
    },
    {
      "indent": 3,
      "text": "(1) A group of Ethernet-processing LFBs are defined to abstract the packet processing for Ethernet as the port media type. As Ethernet is the most popular media type with rich processing features, Ethernet media processing LFBs were a natural choice. Definitions for processing of other port media types like Packet over SONET (POS) or Asynchronous Transfer Mode (ATM) may be incorporated in the library in future versions of this document or in a separate document. The following LFBs are defined for Ethernet processing:",
      "ja": "（1）イーサネット処理LFBsのグループは、ポートメディアタイプとしてイーサネットの抽象パケット処理に定義されています。イーサネットが豊富な処理機能を備えた最も一般的なメディアタイプであるため、イーサネットメディア処理LFBsは自然な選択でした。 SONET上パケット（POS）または非同期転送モード（ATM）のような他のポートのメディアタイプを処理するための定義は、この文書の将来のバージョンまたは別の文書にライブラリに組み込むことができます。以下LFBsは、イーサネット処理のために定義されています。"
    },
    {
      "indent": 8,
      "text": "* EtherPHYCop (Section 5.1.1)",
      "ja": "* EtherPHYCop（5.1.1項）"
    },
    {
      "indent": 8,
      "text": "* EtherMACIn (Section 5.1.2)",
      "ja": "* EtherMASIn（Sektion 5.1.2）"
    },
    {
      "indent": 8,
      "text": "* EtherClassifier (Section 5.1.3)",
      "ja": "* EtherClassifier（5.1.3項）"
    },
    {
      "indent": 8,
      "text": "* EtherEncap (Section 5.1.4)",
      "ja": "* EtherEncap（セクション5.1.4）"
    },
    {
      "indent": 8,
      "text": "* EtherMACOut (Section 5.1.5)",
      "ja": "* EtherMAKOut（Sektion 5.1.5）"
    },
    {
      "indent": 3,
      "text": "(2) A group of LFBs are defined for IP packet validation process. The following LFBs are defined for IP validation processing:",
      "ja": "（2）LFBsのグループがIPパケット検証プロセスのために定義されています。以下LFBsは、IP検証処理のために定義されています。"
    },
    {
      "indent": 8,
      "text": "* IPv4Validator (Section 5.2.1)",
      "ja": "* IPv4Validator（5.2.1項）"
    },
    {
      "indent": 8,
      "text": "* IPv6Validator (Section 5.2.2)",
      "ja": "* IPv6Validator（5.2.2項）"
    },
    {
      "indent": 3,
      "text": "(3) A group of LFBs are defined to abstract IP forwarding process. The following LFBs are defined for IP forwarding processing:",
      "ja": "（3）LFBsのグループは、抽象IPフォワーディングプロセスに定義されています。以下LFBsは、IPフォワーディング処理のために定義されています。"
    },
    {
      "indent": 8,
      "text": "* IPv4UcastLPM (Section 5.3.1)",
      "ja": "* IPv4UcastLPM（5.3.1項）"
    },
    {
      "indent": 8,
      "text": "* IPv4NextHop (Section 5.3.2)",
      "ja": "* IPv4NextHop（5.3.2項）"
    },
    {
      "indent": 8,
      "text": "* IPv6UcastLPM (Section 5.3.3)",
      "ja": "* IPv6UcastLPM（5.3.3）"
    },
    {
      "indent": 8,
      "text": "* IPv6NextHop (Section 5.3.4)",
      "ja": "* IPv6NextHop（5.3.4項）"
    },
    {
      "indent": 3,
      "text": "(4) A group of LFBs are defined to abstract the process for redirect operation, i.e., data packet transmission between CE and FEs. The following LFBs are defined for redirect processing:",
      "ja": "（4）LFBsのグループがリダイレクト動作、すなわち、CEとのFEとの間のデータパケット伝送のための抽象化のプロセスに定義されています。以下LFBsは、リダイレクト処理のために定義されています。"
    },
    {
      "indent": 8,
      "text": "* RedirectIn (Section 5.4.1)",
      "ja": "* RedirectIn（5.4.1項）"
    },
    {
      "indent": 8,
      "text": "* RedirectOut (Section 5.4.2)",
      "ja": "* RedirectOut（5.4.2項）"
    },
    {
      "indent": 3,
      "text": "(5) A group of LFBs are defined for abstracting some general purpose packet processing. These processing processes are usually general to many processing locations in an FE LFB topology. The following LFBs are defined for redirect processing:",
      "ja": "（5）LFBsのグループは、いくつかの汎用パケット処理を抽象化のために定義されています。これらの処理プロセスは、通常、FE LFBトポロジで多くの処理場所への一般的なものです。以下LFBsは、リダイレクト処理のために定義されています。"
    },
    {
      "indent": 8,
      "text": "* BasicMetadataDispatch (Section 5.5.1)",
      "ja": "* BasicMetadataDispatch（5.5.1項）"
    },
    {
      "indent": 8,
      "text": "* GenericScheduler (Section 5.5.2)",
      "ja": "* GenericScheduler（5.5.2項）"
    },
    {
      "indent": 0,
      "text": "3.2.3. Sample LFB Class Application",
      "section_title": true,
      "ja": "3.2.3。 LFBクラスのサンプル・アプリケーション"
    },
    {
      "indent": 3,
      "text": "Although Section 7 will present use cases for the LFBs defined in this document, this section shows a simple sample LFB class application in advance so that readers can get a quick overlook of the LFB classes with the usage.",
      "ja": "第7節は、この文書で定義されたLFBsためのユースケースを提示しますが、読者は、使用してLFBクラスの迅速な見落としを得ることができるように、このセクションでは、事前に簡単なサンプルLFBクラスのアプリケーションを示しています。"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows a simple LFB processing path for Ethernet packets entered from Ethernet physical ports.",
      "ja": "図1は、イーサネット（登録商標）物理ポートから入力されたイーサネットパケットのための単純なLFB処理経路を示しています。"
    },
    {
      "indent": 3,
      "text": "+-----+                +------+\n|     |EtherPHYIn      |      |            from some LFB(s) that\n|     |<---------------|Ether |<---------- generate Ethernet\n|     |                |MACOut|            packets\n|     |                | LFB  |\n|Ether|                +------+\n|PHY  |                +------+\n|Cop  |                |      |\n|LFB  |EtherPHYOut     | Ether|            to some LFB(s) that\n|     |--------------->| MACIn|----------> may classify Ethernet\n|     |                |  LFB |            packets and do IP-layer\n|     |                |      |            processing\n+-----+                +------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 1: A Simple Sample LFB Use Case",
      "ja": "図1：簡単なサンプルLFBユースケース"
    },
    {
      "indent": 3,
      "text": "In the figure, Ethernet packets from outer networks enter via the EtherPHYCop LFB (Section 5.1.1), which describes Ethernet copper interface properties (like the link speed) at the physical layer. After physical-layer processing, Ethernet packets are delivered to the EtherMACIn LFB (Section 5.1.2) to describe its MAC-layer processing functions (like locality check). The packets after the EtherMACIn LFB may require further processing to implement various functions (like IP-layer forwarding); therefore, some LFBs may follow the EtherMACIn LFB in topology to describe followed processing functions.",
      "ja": "図では、外側のネットワークからイーサネットパケットは、物理層で（リンク速度など）イーサネット銅界面特性を記述するEtherPHYCop LFB（5.1.1項）を介して入力します。物理層処理の後、イーサネットパケットは、（局所性チェック等）、そのMACレイヤ処理機能を説明するためにEtherMACIn LFB（セクション5.1.2）に送出されます。 EtherMACIn LFB後のパケットは（IP層転送等）は、様々な機能を実現するために更なる処理を必要とするかもしれません。従って、いくつかのLFBsはその後の処理機能を説明するために、トポロジにEtherMACIn LFBに従うことができます。"
    },
    {
      "indent": 3,
      "text": "Meanwhile, packets generated by some LFB(s) may need to be submitted to outer physical networks. The process is described in the figure by an EtherMACOut LFB (Section 5.1.5) at the MAC layer and the EtherPHYCop LFB at the physical layer.",
      "ja": "一方、いくつかのLFB（複数可）によって生成されたパケットは、外側の物理ネットワークに提出する必要があるかもしれません。プロセスは、物理層でMACレイヤでEtherMACOut LFB（セクション5.1.5）とEtherPHYCop LFBによって図中に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.3. Document Structure",
      "section_title": true,
      "ja": "3.3。文書構造"
    },
    {
      "indent": 3,
      "text": "Base type definitions, including data types, packet frame types, and metadata types, are presented in advance for definitions of various LFB classes. Section 4 (\"Base Types\") provides a description on the base types used by this LFB library. To enable extensive use of these base types by other LFB class definitions, the base type definitions are provided as a separate library.",
      "ja": "データ・タイプ、パケットのフレームタイプ、およびメタデータ・タイプを含むベース型定義は、様々なLFBクラスの定義については、事前に提示されています。セクション4（「基本タイプ」）がこのLFBライブラリによって使用される基本型の説明を提供します。他のLFBクラス定義によって、これらの基本型の広範な使用を可能にするために、ベース・タイプの定義は、個別のライブラリとして提供されます。"
    },
    {
      "indent": 3,
      "text": "Within every group of LFB classes, a set of LFBs are defined for individual function purposes. Section 5 (\"LFB Class Descriptions\") provides text descriptions on the individual LFBs. Note that for a complete definition of an LFB, a text description and an XML definition are required.",
      "ja": "LFBクラスのすべてのグループの中で、LFBsのセットは、個々の機能のために定義されています。第5節（「LFBクラスの説明」）は、個々のLFBs上のテキストの説明を提供します。 LFBの完全な定義については、テキスト記述やXML定義が必要であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "LFB classes are finally defined by XML with specifications and schema defined in the ForCES FE model [RFC5812]. Section 6 (\"XML for LFB Library\") provides the complete XML definitions of the base LFB classes library.",
      "ja": "LFBクラスは最終的のForCES FEモデル[RFC5812]で定義された仕様とスキーマとXMLで定義されています。第6節は、（「LFBライブラリのためのXML」）ベースのLFBクラスライブラリの完全なXML定義を提供します。"
    },
    {
      "indent": 3,
      "text": "Section 7 provides several use cases on how some typical router functions can be implemented using the base LFB library defined in this document.",
      "ja": "第7節では、いくつかの一般的なルータ機能は、この文書で定義された基本LFBライブラリを使用して実装することができる方法についていくつかのユースケースを提供します。"
    },
    {
      "indent": 0,
      "text": "4. Base Types",
      "section_title": true,
      "ja": "4.基本型"
    },
    {
      "indent": 3,
      "text": "The FE model [RFC5812] has specified predefined (built-in) atomic data types: char, uchar, int16, uint16, int32, uint32, int64, uint64, string[N], string, byte[N], boolean, octetstring[N], float16, float32, and float64.",
      "ja": "FEモデル[RFC5812]は予め定義された（内蔵）アトミックなデータ型を指定している：チャーは、UCHAR、INT16、uint16の、INT32、UINT32、Int64の、UINT64、文字列[N]、文字列、バイト[N]、ブール、OCTETSTRING [ N]、float16、float32型、およびのfloat64。"
    },
    {
      "indent": 3,
      "text": "Note that, unlike the Simple Network Management Protocol (SNMP) information model, called the Structure of Management Information (SMI) [RFC2578], the FE model has not defined specific atomic data types for counting purposes. This document also does not define specific counter types. To describe LFB elements for packet statistics, which actually requires counters on packets, an unsigned integer, like an uint32 or an uint64, is adopted. This document states that any LFB element defined for counting purposes is specified to monotonically increase until it reaches a maximum value, when it wraps around and starts increasing again from zero. This document also states that how the unsigned integer element might be maintained to cope with issues like counter discontinuities when a counter wraps or is reset for any reason is an implementation's issue. If a CE is expected to understand more meanings of the counter element than stated above, a private definition on the element between the CE and FE may be required.",
      "ja": "簡易ネットワーク管理プロトコル（SNMP）情報モデルとは異なり、[RFC2578]の管理情報（SMI）の構造と呼ばれる、FEモデルは、カウントのために特定の原子データ型を定義していない、ということに注意してください。この文書は、特定のカウンタータイプを定義していません。実際UINT32またはuint64型のようなパケットのカウンタ、符号なし整数を、必要とするパケットの統計のためのLFB要素を記述するために、採用されています。この文書では、計数のために定義された任意のLFB要素は、それがラップアラウンドし、ゼロから再び増加し始める最大値に達するまで単調に増加するように指定されていることを述べています。また、このドキュメントでは、どのようにカウンターがラップまたは何らかの理由でリセットされたときに、符号なし整数要素はカウンター不連続のような問題に対処するために維持される可能性がありますが、実装の問題であると述べています。 CEは、上記よりもカウンター要素のより多くの意味を理解することが期待されている場合は、CEとFE間の素子のプライベート定義が必要になることがあります。"
    },
    {
      "indent": 3,
      "text": "Based on the atomic data types and with the use of type definition elements in the FE model XML schema, new data types, packet frame types, and metadata types can be defined.",
      "ja": "アトミックなデータ型にとFEモデルのXMLスキーマの型定義の要素を使用してベース、新しいデータ・タイプ、パケットのフレームタイプ、およびメタデータのタイプを定義することができます。"
    },
    {
      "indent": 3,
      "text": "To define a base LFB library for typical router functions, a set of base data types, frame types, and metadata types should be defined. This section provides a brief description of the base types and a full XML definition of them as well.",
      "ja": "典型的なルータ機能のための基本LFBライブラリを定義するには、基本データ・タイプ、フレームタイプ、およびメタデータ・タイプのセットが定義されるべきです。このセクションでは、基本タイプの簡単な説明と同様にそれらの完全なXML定義を提供します。"
    },
    {
      "indent": 3,
      "text": "The base type XML definitions are provided with a separate XML library file named \"BaseTypeLibrary\". Users can refer to this library by the statement:",
      "ja": "基本タイプのXML定義は、「BaseTypeLibrary」という別のXMLライブラリファイルが設けられています。ユーザーは声明で、このライブラリを参照することができます。"
    },
    {
      "indent": 3,
      "text": "<load library=\"BaseTypeLibrary\" location=\"...\"/>",
      "ja": "<ロードライブラリ= \"BaseTypeLibrary\" 場所= \"...\" />"
    },
    {
      "indent": 0,
      "text": "4.1. Data Types",
      "section_title": true,
      "ja": "4.1。データの種類"
    },
    {
      "indent": 3,
      "text": "Data types defined in the base type library are categorized by the following types: atomic, compound struct, and compound array.",
      "ja": "原子、複合構造体、及び化合物のアレイベースのタイプライブラリで定義されたデータ型は、以下のタイプによって分類されます。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Atomic",
      "section_title": true,
      "ja": "4.1.1。アトミック"
    },
    {
      "indent": 3,
      "text": "The following data types are defined as atomic data types and put in the base type library:",
      "ja": "次のデータ型は、原子データ型として定義され、ベースタイプライブラリに置かれています。"
    },
    {
      "indent": 4,
      "text": "Data Type Name      Brief Description\n--------------      -----------------\nIPv4Addr            IPv4 address\nIPv6Addr            IPv6 address\nIEEEMAC             IEEE MAC address\nLANSpeedType        LAN speed by value types\nDuplexType          Duplex types\nPortStatusType      The possible types of port status, used for\n                     both administrative and operative status\nVlanIDType          The type of VLAN ID\nVlanPriorityType    The type of VLAN priority\nSchdDisciplineType  Scheduling discipline type",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.1.2. Compound Struct",
      "section_title": true,
      "ja": "4.1.2。化合物構造体"
    },
    {
      "indent": 3,
      "text": "The following compound struct types are defined in the base type library:",
      "ja": "以下の化合物の構造体のタイプは、基本タイプライブラリで定義されています。"
    },
    {
      "indent": 4,
      "text": "Data Type Name           Brief Description\n--------------           -----------------\nEtherDispatchEntryType   Entry type for Ethernet dispatch table\nVlanInputTableEntryType  Entry type for VLAN input table\nEncapTableEntryType      Entry type for Ethernet encapsulation table\nMACInStatsType           Statistics type for EtherMACIn LFB\nMACOutStatsType          Statistics type for EtherMACOut LFB\nEtherClassifyStatsType   Entry type for statistics table in\n                          EtherClassifier LFB\nIPv4PrefixInfoType       Entry type for IPv4 prefix table\nIPv6PrefixInfoType       Entry type for IPv6 prefix table\nIPv4NextHopInfoType      Entry type for IPv4 next-hop table\nIPv6NextHopInfoType      Entry type for IPv6 next-hop table\nIPv4ValidatorStatsType   Statistics type in IPv4validator LFB\nIPv6ValidatorStatsType   Statistics type in IPv6validator LFB\nIPv4UcastLPMStatsType    Statistics type in IPv4UcastLPM LFB\nIPv6UcastLPMStatsType    Statistics type in IPv6UcastLPM LFB\nQueueStatsType           Entry type for queue depth table\nMetadataDispatchType     Entry type for metadata dispatch table",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.1.3. Compound Array",
      "section_title": true,
      "ja": "4.1.3。化合物アレイ"
    },
    {
      "indent": 3,
      "text": "Compound array types are mostly created based on compound struct types for LFB table components. The following compound array types are defined in this base type library:",
      "ja": "化合物の配列型は、主にLFBテーブルコンポーネントの複合構造体の種類に基づいて作成されています。以下の化合物アレイタイプは、この基本タイプライブラリで定義されています。"
    },
    {
      "indent": 4,
      "text": "Data Type Name               Brief Description\n--------------               -----------------\nEtherClassifyStatsTableType  Type for Ethernet classifier statistics\n                              information table\nEtherDispatchTableType       Type for Ethernet dispatch table\nVlanInputTableType           Type for VLAN input table\nEncapTableType               Type for Ethernet encapsulation table\nIPv4PrefixTableType          Type for IPv4 prefix table\nIPv6PrefixTableType          Type for IPv6 prefix table\nIPv4NextHopTableType         Type for IPv4 next-hop table\nIPv6NextHopTableType         Type for IPv6 next-hop table\nMetadataDispatchTableType    Type for Metadata dispatch table\nQueueStatsTableType          Type for Queue depth table",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.2. Frame Types",
      "section_title": true,
      "ja": "4.2。フレームタイプ"
    },
    {
      "indent": 3,
      "text": "According to the FE model [RFC5812], frame types are used in LFB definitions to define packet frame types that an LFB expects at its input port and that the LFB emits at its output port. The <frameDef> element in the FE model is used to define a new frame type.",
      "ja": "FEモデル[RFC5812]によれば、フレームタイプは、LFBは、その入力ポートでとLFBは、その出力ポートに発光することを期待するパケットのフレームタイプを定義するLFBの定義に使用されています。 FEモデルにおいて<frameDef>要素は、新たなフレームタイプを定義するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The following frame types are defined in the base type library:",
      "ja": "次のフレームタイプは、基本タイプライブラリで定義されています。"
    },
    {
      "indent": 4,
      "text": "Frame Name           Brief Description\n--------------       -----------------\nEthernetII           An Ethernet II frame\nARP                  An ARP packet frame\nIPv4                 An IPv4 packet frame\nIPv6                 An IPv6 packet frame\nIPv4Unicast          An IPv4 unicast packet frame\nIPv4Multicast        An IPv4 multicast packet frame\nIPv6Unicast          An IPv6 unicast packet frame\nIPv6Multicast        An IPv6 multicast packet frame\nArbitrary            Any type of packet frames",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3. Metadata Types",
      "section_title": true,
      "ja": "4.3。メタデータの種類"
    },
    {
      "indent": 3,
      "text": "LFB metadata is used to communicate per-packet state from one LFB to another. The <metadataDef> element in the FE model is used to define a new metadata type.",
      "ja": "LFBメタデータは、別のLFBからパケット単位の状態を通信するために使用されます。 FEモデルの<metadataDef>要素は、新しいメタデータ型を定義するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The following metadata types are currently defined in the base type library.",
      "ja": "次のメタデータの種類は、現在、基本タイプライブラリで定義されています。"
    },
    {
      "indent": 3,
      "text": "Metadata Name  Metadata ID  Brief Description\n------------   -----------  -----------------\nPHYPortID          1        Metadata indicating a physical port ID\nSrcMAC             2        Metadata indicating a source MAC address\nDstMAC             3        Metadata indicating a destination MAC\n                             address\nLogicalPortID      4        Metadata of a logical port ID\nEtherType          5        Metadata indicating an Ethernet type\nVlanID             6        Metadata of a VLAN ID\nVlanPriority       7        Metadata of a VLAN priority\nNextHopIPv4Addr    8        Metadata representing a next-hop IPv4\n                             address\nNextHopIPv6Addr    9        Metadata representing a next-hop IPv6\n                             address\nHopSelector        10       Metadata indicating a hop selector\nExceptionID        11       Metadata indicating exception types for\n                             exceptional cases during LFB processing\nValidateErrorID    12       Metadata indicating error types when a\n                             packet passes validation process\nL3PortID           13       Metadata indicating ID of an L3 logical\n                             port\nRedirectIndex      14       Metadata that CE sends to RedirectIn LFB,\n                             indicating an associated packet a group\n                             output port index of the LFB\nMediaEncapInfoIndex 15      A search key a packet uses to look up a\n                             table in related LFBs to select an\n                             encapsulation media",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.4. XML for Base Type Library",
      "section_title": true,
      "ja": "4.4。ベースタイプライブラリのためのXML"
    },
    {
      "indent": 0,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <LFBLibrary xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" provides=\"BaseTypeLibrary\"> <frameDefs> <frameDef> <name>EthernetAll</name> <synopsis>Packet with any Ethernet type</synopsis> </frameDef> <frameDef> <name>EthernetII</name> <synopsis>Packet with Ethernet II type</synopsis> </frameDef> <frameDef> <name>ARP</name> <synopsis>ARP packet</synopsis> </frameDef> <frameDef> <name>IPv4</name> <synopsis>IPv4 packet</synopsis> </frameDef> <frameDef> <name>IPv6</name> <synopsis>IPv6 packet</synopsis> </frameDef> <frameDef> <name>IPv4Unicast</name> <synopsis>IPv4 unicast packet</synopsis> </frameDef> <frameDef> <name>IPv4Multicast</name> <synopsis>IPv4 multicast packet</synopsis> </frameDef> <frameDef> <name>IPv6Unicast</name> <synopsis>IPv6 unicast packet</synopsis> </frameDef> <frameDef> <name>IPv6Multicast</name> <synopsis>IPv6 multicast packet</synopsis> </frameDef> <frameDef> <name>Arbitrary</name> <synopsis>Any type of packet</synopsis> </frameDef> </frameDefs>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <LFBLibrary =のxmlns \"壷：IETF：のparams：XML：NS：力：lfbmodel：1.0\" のxmlns：XSI = \"のhttp：//www.w3 .ORG / 2001 / XMLスキーマ・インスタンス任意のイーサネットタイプBaseTypeLibrary \"> <frameDefs> <frameDef> <名前> EthernetAll </名前> <概要>パケット</概要> </ frameDef> <frameDef> <名前」=を提供します\" > EthernetII </名前> <概要>イーサネットII型</概要> </ frameDef> <frameDef> <名前> ARP </名前> <概要> ARPパケット</概要> </ frameDef> <frameDef> <有するパケット名前>はIPv4 </名前> <概要> IPv4パケット</概要> </ frameDef> <frameDef> <名前>のIPv6 </名前> <概要> IPv6パケット</概要> </ frameDef> <frameDef> <名前> IPv4Unicast </名前> <概要> IPv4ユニキャストパケット</概要> </ frameDef> <frameDef> <名前> IPv4Multicast </名前> <概要> IPv4マルチキャストパケット</概要> </ frameDef> <frameDef> <名前> IPv6Unicast </名前> <概要> IPv6ユニキャストパケット</概要> </ frameDef> <frameDef> <名前> IPv6Multicast </名前> <概要> IPv6マルチキャストパケット</概要> </ frameDef> <frameDef> <名前> Arbitra RY </名前> <概要>パケットの任意のタイプ</概要> </ frameDef> </ frameDefs>"
    },
    {
      "indent": 3,
      "text": "<dataTypeDefs> <dataTypeDef> <name>IPv4Addr</name> <synopsis>IPv4 address</synopsis> <typeRef>byte[4]</typeRef> </dataTypeDef> <dataTypeDef> <name>IPv6Addr</name> <synopsis>IPv6 address</synopsis> <typeRef>byte[16]</typeRef> </dataTypeDef> <dataTypeDef> <name>IEEEMAC</name> <synopsis>IEEE MAC address</synopsis> <typeRef>byte[6]</typeRef> </dataTypeDef> <dataTypeDef> <name>LANSpeedType</name> <synopsis>LAN speed type</synopsis> <atomic> <baseType>uint32</baseType> <specialValues> <specialValue value=\"0x00000000\"> <name>LAN_SPEED_NONE</name> <synopsis>Nothing connected</synopsis> </specialValue> <specialValue value=\"0x00000001\"> <name>LAN_SPEED_10M</name> <synopsis>10M Ethernet</synopsis> </specialValue> <specialValue value=\"0x00000002\"> <name>LAN_SPEED_100M</name> <synopsis>100M Ethernet</synopsis> </specialValue> <specialValue value=\"0x00000003\"> <name>LAN_SPEED_1G</name> <synopsis>1G Ethernet</synopsis> </specialValue> <specialValue value=\"0x00000004\"> <name>LAN_SPEED_10G</name> <synopsis>10G Ethernet</synopsis> </specialValue> <specialValue value=\"0x00000005\"> <name>LAN_SPEED_40G</name> <synopsis>40G Ethernet</synopsis> </specialValue> <specialValue value=\"0x00000006\"> <name>LAN_SPEED_100G</name>",
      "ja": "<dataTypeDefs> <dataTypeDef> <名前> IPv4Addr </名前> <概要> IPv4アドレス</シノプシス> <typeRef>バイト[4] </ typeRef> </ dataTypeDef> <dataTypeDef> <名前> IPv6Addr </名前> <概要> IPv6アドレス</シノプシス> <typeRef>バイト[16] </ typeRef> </ dataTypeDef> <dataTypeDef> <名前> IEEEMACが</名前> <概要> IEEE MACアドレス</シノプシス> <typeRef>バイト[6 ] </ typeRef> </ dataTypeDef> <dataTypeDef> <名前> LANSpeedType </名前> <概要> LAN速度タイプ</シノプシス> <原子> <baseType> UINT32 </ baseType> <specialValues> <specialValue値= \"0x00000000の\"> <名前> LAN_SPEED_NONE </名前> <概要>何も接続されていない</概要> </ specialValue> <specialValue値=\" 0x00000001\" の> <名前> LAN_SPEED_10M </名前> <概要> 10Mイーサネット</概要> </ specialValue> <specialValue値= \"0x00000002\"> <名前> LAN_SPEED_100M </名前> <概要> 100Mイーサネット</概要> </ specialValue> <specialValue値= \"0x00000003\"> <名前> LAN_SPEED_1G </名前> <概要> 1Gイーサネット</概要> </ specialValue> <specialValue値= \"0x00000004\"> <名前> LAN_SPEED_10G </名前> <SYNO PSIS> 10Gイーサネット</概要> </ specialValue> <specialValue値= \"0x00000005\"> <名前> LAN_SPEED_40G </名前> <概要> 40Gイーサネット</概要> </ specialValue> <specialValue値= \"0x00000006\"> <名前> LAN_SPEED_100G </名前>"
    },
    {
      "indent": 6,
      "text": " <synopsis>100G Ethernet</synopsis> </specialValue> <specialValue value=\"0x00000007\"> <name>LAN_SPEED_400G</name> <synopsis>400G Ethernet</synopsis> </specialValue> <specialValue value=\"0x00000008\"> <name>LAN_SPEED_1T</name> <synopsis>1T Ethernet</synopsis> </specialValue> <specialValue value=\"0x00000009\"> <name>LAN_SPEED_OTHER</name> <synopsis>Other LAN speed type</synopsis> </specialValue> <specialValue value=\"0x0000000A\"> <name>LAN_SPEED_AUTO</name> <synopsis>LAN speed by auto negotiation</synopsis> </specialValue> </specialValues> </atomic> </dataTypeDef> <dataTypeDef> <name>DuplexType</name> <synopsis>Duplex mode type</synopsis> <atomic> <baseType>uint32</baseType> <specialValues> <specialValue value=\"0x00000001\"> <name>Auto</name> <synopsis>Auto negotiation</synopsis> </specialValue> <specialValue value=\"0x00000002\"> <name>HalfDuplex</name> <synopsis>Half duplex</synopsis> </specialValue> <specialValue value=\"0x00000003\"> <name>FullDuplex</name> <synopsis>Full duplex</synopsis> </specialValue> </specialValues> </atomic> </dataTypeDef> <dataTypeDef> <name>PortStatusType</name> <synopsis> Type for port status, used for both administrative and operative status. </synopsis>",
      "ja": "<概要> 100Gイーサネット</概要> </ specialValue> <specialValue値= \"0x00000007\"> <名前> LAN_SPEED_400G </名前> <概要> 400Gイーサネット</概要> </ specialValue> <specialValue値= \"0x00000008\"> <名前> LAN_SPEED_1T </名前> <概要> 1Tイーサネット</概要> </ specialValue> <specialValue値= \"0x00000009\"> <名前> LAN_SPEED_OTHER </名前> <概要>他のLAN速度のタイプ</概要> </ specialValue> <specialValue値= \"0x0000000Aを\"> <名前> LAN_SPEED_AUTO </名前> <概要>オートネゴシエーションにより、LANスピード</概要> </ specialValue> </ specialValues> </アトミック> </ dataTypeDef> <dataTypeDef> < NAME> DuplexType </名前> <概要>二重モード型</シノプシス> <原子> <baseType> UINT32 </ baseType> <specialValues> <specialValue値= \"0x00000001の\"> <名前>自動車</名前> <概要>オートネゴシエーション</概要> </ specialValue> <specialValue値= \"0x00000002\"> <名前>半二重</名前> <概要>半二重</概要> </ specialValue> <specialValue値= \"0x00000003\"> <名前>全二重</名前> <概要>全二重</概要> </ specialValue> </ specialValues> </原子> </ dataTypeDef> <dataTypeDef> <名前> PortStatusType </名前> <概要>両方の管理および動作ステータスに使用されるポートの状態、の型。 </概要>"
    },
    {
      "indent": 6,
      "text": " <atomic> <baseType>uchar</baseType> <specialValues> <specialValue value=\"0\"> <name>Disabled</name> <synopsis>Port disabled</synopsis> </specialValue> <specialValue value=\"1\"> <name>Up</name> <synopsis>Port up</synopsis> </specialValue> <specialValue value=\"2\"> <name>Down</name> <synopsis>Port down</synopsis> </specialValue> </specialValues> </atomic> </dataTypeDef> <dataTypeDef> <name>MACInStatsType</name> <synopsis> Data type defined for statistics in EtherMACIn LFB. </synopsis> <struct> <component componentID=\"1\"> <name>NumPacketsReceived</name> <synopsis>Number of packets received</synopsis> <typeRef>uint64</typeRef> </component> <component componentID=\"2\"> <name>NumPacketsDropped</name> <synopsis>Number of packets dropped</synopsis> <typeRef>uint64</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>MACOutStatsType</name> <synopsis> Data type defined for statistics in EtherMACOut LFB. </synopsis> <struct> <component componentID=\"1\"> <name>NumPacketsTransmitted</name> <synopsis>Number of packets transmitted</synopsis> <typeRef>uint64</typeRef> </component> <component componentID=\"2\">",
      "ja": "<原子> <baseType> UCHAR </ baseType> <specialValues> <specialValue値= \"0\"> <名前>無効</名前> <概要>ポート無効化</概要> </ specialValue> <specialValue値= \"1\" > <名前>アップ</名前> <概要>ポートアップ</概要> </ specialValue> <specialValue値= \"2\"> <名前>ダウン</名前> <概要>ポートダウン</概要> </ specialValue > </ specialValues> </アトミック> </ dataTypeDef> <dataTypeDef> <名前> MACInStatsType </名前> <概要> EtherMACIn LFB内の統計のために定義されたデータ型。 </シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前> NumPacketsReceived </名前> <概要>パケットの数は、受信</シノプシス> <typeRef> UINT64 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> NumPacketsDropped </名前> <概要>パケットの数がドロップ</シノプシス> <typeRef> UINT64 </ typeRef> </成分> </構造体> </ dataTypeDef> <dataTypeDef> <名前> MACOutStatsType </名前> <概要> EtherMACOut LFB内の統計のために定義されたデータ型。 </シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前> NumPacketsTransmitted </名前> <概要>パケットの数送信</シノプシス> <typeRef> UINT64 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\">"
    },
    {
      "indent": 6,
      "text": " <name>NumPacketsDropped</name> <synopsis>Number of packets dropped</synopsis> <typeRef>uint64</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>EtherDispatchEntryType</name> <synopsis> Data type defined for entry of Ethernet dispatch table in EtherClassifier LFB. </synopsis> <struct> <component componentID=\"1\"> <name>LogicalPortID</name> <synopsis>Logical port ID</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"2\"> <name>EtherType</name> <synopsis> The Ethernet type of the Ethernet packet. </synopsis> <typeRef>uint16</typeRef> </component> <component componentID=\"3\"> <name>Reserved</name> <synopsis> A reserved bit space mainly for purpose of padding and packing efficiency. </synopsis> <typeRef>uint16</typeRef> </component> <component componentID=\"4\"> <name>LFBOutputSelectIndex</name> <synopsis> Index for a packet to select an instance in the group output port of EtherClassifier LFB to output. </synopsis> <typeRef>uint32</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef>",
      "ja": "<名前> NumPacketsDropped </名前> <概要>パケットの数がドロップ</シノプシス> <typeRef> UINT64 </ typeRef> </成分> </構造体> </ dataTypeDef> <dataTypeDef> <名前> EtherDispatchEntryType </名前> <概要> EtherClassifier LFBのイーサネット・ディスパッチ・テーブルのエントリに対して定義されたデータ型。 </シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前> LogicalPortID </名前> <概要>論理ポートID </シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID =」 2\" > <名前>のEtherType </名前> <概要>イーサネットパケットのイーサネットタイプ。 </シノプシス> <typeRef> uint16の</ typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\"> <名前>予約</名前> <概要>主にパディングすることを目的と充填効率のために予約されたビット空間。 </シノプシス> <typeRef> uint16の</ typeRef> </コンポーネント> <コンポーネントのComponentID = \"4\"> <名前> LFBOutputSelectIndex </名前> <概要>索引EtherClassifierのグループの出力ポートでインスタンスを選択するパケットの出力にLFB。 </シノプシス> <typeRef> UINT32 </ typeRef> </成分> </構造体> </ dataTypeDef> <dataTypeDef>"
    },
    {
      "indent": 6,
      "text": " <name>EtherDispatchTableType</name> <synopsis> Data type defined for Ethernet dispatch table in EtherClassifier LFB. The table is composed of an array of entries with EtherDispatchEntryType data type. </synopsis> <array type=\"variable-size\"> <typeRef>EtherDispatchEntryType</typeRef> </array> </dataTypeDef> <dataTypeDef> <name>VlanIDType</name> <synopsis>Data type for VLAN ID</synopsis> <atomic> <baseType>uint16</baseType> <rangeRestriction> <allowedRange min=\"0\" max=\"4095\"/> </rangeRestriction> </atomic> </dataTypeDef> <dataTypeDef> <name>VlanPriorityType</name> <synopsis>Data type for VLAN priority</synopsis> <atomic> <baseType>uchar</baseType> <rangeRestriction> <allowedRange min=\"0\" max=\"7\"/> </rangeRestriction> </atomic> </dataTypeDef> <dataTypeDef> <name>VlanInputTableEntryType</name> <synopsis> Data type for entry of VLAN input table in EtherClassifier LFB. Each entry of the table contains an incoming port ID, a VLAN ID and a logical port ID. Every input packet is assigned with a new logical port ID according to the packet incoming port ID and the VLAN ID. </synopsis> <struct> <component componentID=\"1\"> <name>IncomingPortID</name> <synopsis>The incoming port ID</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"2\"> <name>VlanID</name> <synopsis>The VLAN ID</synopsis>",
      "ja": "<名前> EtherDispatchTableType </名前> <概要> EtherClassifier LFBにイーサネットディスパッチテーブル用に定義されたデータ型。テーブルはEtherDispatchEntryTypeデータ型のエントリのアレイから構成されています。 </シノプシス> <配列型= \"可変サイズ\"> <typeRef> EtherDispatchEntryType </ typeRef> </アレイ> </ dataTypeDef> <dataTypeDef> <名前> VlanIDType </名前> <概要> VLAN IDのデータ型< /シノプシス> <原子> <baseType> uint16の</ baseType> <rangeRestriction> <allowedRange分= \"0\" 最大= \"4095\" /> </ rangeRestriction> </原子> </ dataTypeDef> <dataTypeDef> <名前> VlanPriorityType </名前> <概要> VLAN優先順位のデータ型</シノプシス> <原子> <baseType> UCHAR </ baseType> <rangeRestriction> <allowedRange分= \"0\" 最大= \"7\" /> </ rangeRestriction> </原子> </ dataTypeDef> <dataTypeDef> <名前> VlanInputTableEntryType </名前> <概要> EtherClassifier LFBにおけるVLAN入力テーブルのエントリのデータ型。テーブルの各エントリは、受信ポートID、VLAN ID、および論理ポートIDを含んでいます。すべての入力パケットは、パケット着信ポートIDとVLAN IDに基づいて、新たな論理ポートIDが割り当てられています。 </シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前> IncomingPortID </名前> <概要>着信ポートID </シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> VLANID </名前> <概要> VLAN ID </概要>"
    },
    {
      "indent": 6,
      "text": " <typeRef>VlanIDType</typeRef> </component> <component componentID=\"3\"> <name>Reserved</name> <synopsis> A reserved bit space mainly for purpose of padding and packing efficiency. </synopsis> <typeRef>uint16</typeRef> </component> <component componentID=\"4\"> <name>LogicalPortID</name> <synopsis>The logical port ID</synopsis> <typeRef>uint32</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>VlanInputTableType</name> <synopsis> Data type for the VLAN input table in EtherClassifier LFB. The table is composed of an array of entries with VlanInputTableEntryType. </synopsis> <array type=\"variable-size\"> <typeRef>VlanInputTableEntryType</typeRef> </array> </dataTypeDef> <dataTypeDef> <name>EtherClassifyStatsType</name> <synopsis> Data type for entry of statistics table in EtherClassifier LFB. </synopsis> <struct> <component componentID=\"1\"> <name>EtherType</name> <synopsis> The Ethernet type of the Ethernet packet. </synopsis> <typeRef>uint16</typeRef> </component> <component componentID=\"2\"> <name>Reserved</name> <synopsis> A reserved bit space mainly for purpose of padding and packing efficiency. </synopsis>",
      "ja": "<typeRef> VlanIDType </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\"> <名前>予約</名前> <概要>主にパディングすることを目的と充填効率のために予約されたビット空間。 </シノプシス> <typeRef> uint16の</ typeRef> </コンポーネント> <コンポーネントのComponentID = \"4\"> <名前> LogicalPortID </名前> <概要>論理ポートID </シノプシス> <typeRef> UINT32 </ typeRef > </成分> </構造体> </ dataTypeDef> <dataTypeDef> <名前> VlanInputTableType </名前> <概要> EtherClassifier LFBにおけるVLAN入力テーブルのデータ型。テーブルはVlanInputTableEntryTypeのエントリのアレイから構成されています。 </シノプシス> <配列型= \"可変サイズ\"> <typeRef> VlanInputTableEntryType </ typeRef> </アレイ> </ dataTypeDef> <dataTypeDef> <名前> EtherClassifyStatsType </名前> <概要>統計情報を入力するためのデータ型EtherClassifier LFB内のテーブル。 </シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前>のEtherType </名前> <概要>イーサネットパケットのイーサネットタイプ。 </シノプシス> <typeRef> uint16の</ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前>予約</名前> <概要>主にパディングすることを目的と充填効率のために予約されたビット空間。 </概要>"
    },
    {
      "indent": 6,
      "text": " <typeRef>uint16</typeRef> </component> <component componentID=\"3\"> <name>PacketsNum</name> <synopsis>Packets number</synopsis> <typeRef>uint64</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>EtherClassifyStatsTableType</name> <synopsis> Data type for statistics table in EtherClassifier LFB. </synopsis> <array type=\"variable-size\"> <typeRef>EtherClassifyStatsType</typeRef> </array> </dataTypeDef> <dataTypeDef> <name>IPv4ValidatorStatsType</name> <synopsis> Data type for statistics in IPv4validator LFB. </synopsis> <struct> <component componentID=\"1\"> <name>badHeaderPkts</name> <synopsis>Number of packets with bad header</synopsis> <typeRef>uint64</typeRef> </component> <component componentID=\"2\"> <name>badTotalLengthPkts</name> <synopsis> Number of packets with bad total length </synopsis> <typeRef>uint64</typeRef> </component> <component componentID=\"3\"> <name>badTTLPkts</name> <synopsis>Number of packets with bad TTL</synopsis> <typeRef>uint64</typeRef> </component> <component componentID=\"4\"> <name>badChecksumPkts</name> <synopsis>Number of packets with bad checksum</synopsis> <typeRef>uint64</typeRef> </component> </struct> </dataTypeDef>",
      "ja": "<typeRef> uint16の</ typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\"> <名前> PacketsNum </名前> <概要>パケット数</概要> <typeRef> UINT64 </ typeRef> </成分> < /構造体> </ dataTypeDef> <dataTypeDef> <名前> EtherClassifyStatsTableType </名前> <概要> EtherClassifier LFBにおける統計テーブルのデータ型。 IPv4validatorにおける統計</シノプシス> <配列タイプ= \"可変サイズ\"> <typeRef> EtherClassifyStatsType </ typeRef> </アレイ> </ dataTypeDef> <dataTypeDef> <名前> IPv4ValidatorStatsType </名前> <概要>データ型LFB。悪いヘッダを持つパケットの</概要> <構造体> <コンポーネントのComponentID = \"1\"> <名前> badHeaderPkts </名前> <概要>番号</シノプシス> <typeRef> UINT64 </ typeRef> </コンポーネント> <成分COMPONENTID = \"2\"> <名前> badTotalLengthPkts </名前> <概要>悪い全長を持つパケットの数</シノプシス> <typeRef> UINT64 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\"> <名前> badTTLPkts </名前> <概要>悪いTTLを持つパケットの数</シノプシス> <typeRef> UINT64 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"4\"> <名前> badChecksumPkts </名前> <概要>不正なチェックサムを持つパケットの数</シノプシス> <typeRef> UINT64 </ typeRef> </成分> </構造体> </ dataTypeDef>"
    },
    {
      "indent": 6,
      "text": "<dataTypeDef> <name>IPv6ValidatorStatsType</name> <synopsis> Data type for statistics in IPv6validator LFB. </synopsis> <struct> <component componentID=\"1\"> <name>badHeaderPkts</name> <synopsis>Number of packets with bad header</synopsis> <typeRef>uint64</typeRef> </component> <component componentID=\"2\"> <name>badTotalLengthPkts</name> <synopsis> Number of packets with bad total length. </synopsis> <typeRef>uint64</typeRef> </component> <component componentID=\"3\"> <name>badHopLimitPkts</name> <synopsis> Number of packets with bad hop limit. </synopsis> <typeRef>uint64</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>IPv4PrefixInfoType</name> <synopsis>Data type for entry of IPv4 longest prefix match table in IPv4UcastLPM LFB. The destination IPv4 address of every input packet is used as a search key to look up the table to find out a next-hop selector.</synopsis> <struct> <component componentID=\"1\"> <name>IPv4Address</name> <synopsis>The destination IPv4 address</synopsis> <typeRef>IPv4Addr</typeRef> </component> <component componentID=\"2\"> <name>Prefixlen</name> <synopsis>The prefix length</synopsis> <atomic> <baseType>uchar</baseType> <rangeRestriction> <allowedRange min=\"0\" max=\"32\"/> </rangeRestriction> </atomic>",
      "ja": "<dataTypeDef> <名前> IPv6ValidatorStatsType </名前> <概要> IPv6validator LFB内の統計のためのデータ型。悪いヘッダを持つパケットの</概要> <構造体> <コンポーネントのComponentID = \"1\"> <名前> badHeaderPkts </名前> <概要>番号</シノプシス> <typeRef> UINT64 </ typeRef> </コンポーネント> <成分COMPONENTID = \"2\"> <名前> badTotalLengthPkts </名前> <概要>悪い全長を持つパケットの数。 </シノプシス> <typeRef> UINT64 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\"> <名前> badHopLimitPkts </名前> <概要>悪いホップリミットを持つパケットの数。 </シノプシス> <typeRef> UINT64 </ typeRef> </成分> </構造体> </ dataTypeDef> <dataTypeDef> <名前> IPv4PrefixInfoType </名前> <概要> IPv4UcastLPMでIPv4の最長プレフィックスマッチテーブルのエントリのデータ型LFB。すべての入力パケットの宛先IPv4アドレスは、次ホップ選択を見つけるためにテーブルをルックアップするために、検索キーとして使用されている。</概要> <構造体> <コンポーネントのComponentID =「1」> <名前> IPv4Addressを</名前> <概要>宛先IPv4アドレス</シノプシス> <typeRef> IPv4Addr </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前>のprefixlen </名前> <概要>プレフィックス長</概要> <原子> <baseType> UCHAR </ baseType> <rangeRestriction> <allowedRange分= \"0\" 最大= \"32\" /> </ rangeRestriction> </原子>"
    },
    {
      "indent": 12,
      "text": "</component>\n<component componentID=\"3\">\n   <name>ECMPFlag</name>\n   <synopsis>The ECMP flag</synopsis>\n   <atomic>\n      <baseType>boolean</baseType>\n      <specialValues>\n         <specialValue value=\"false\">\n            <name>False</name>\n            <synopsis>\n             ECMP false, indicating the route\n             does not have multiple next hops.\n            </synopsis>\n         </specialValue>\n         <specialValue value=\"true\">\n            <name>True</name>\n            <synopsis>\n              ECMP true, indicating the route\n              has multiple next hops.\n            </synopsis>\n         </specialValue>\n      </specialValues>\n   </atomic>\n</component>\n<component componentID=\"4\">\n   <name>DefaultRouteFlag</name>\n   <synopsis>Default route flag</synopsis>\n   <atomic>\n      <baseType>boolean</baseType>\n      <specialValues>\n         <specialValue value=\"false\">\n            <name>False</name>\n            <synopsis>\n              Default route false, indicating the\n              route is not a default route.\n            </synopsis>\n         </specialValue>\n         <specialValue value=\"true\">\n            <name>True</name>\n            <synopsis>\n              Default route true, indicating the\n              route is a default route.\n            </synopsis>\n         </specialValue>\n      </specialValues>\n   </atomic>\n</component>\n<component componentID=\"5\">",
      "raw": true
    },
    {
      "indent": 6,
      "text": " <name>Reserved</name> <synopsis> A reserved bit space mainly for purpose of padding and packing efficiency. </synopsis> <typeRef>uchar</typeRef> </component> <component componentID=\"6\"> <name>HopSelector</name> <synopsis> The HopSelector produced by the prefix matching LFB, which will be output to downstream LFB to find next-hop information. </synopsis> <typeRef>uint32</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>IPv4PrefixTableType</name> <synopsis> Data type for IPv4 longest prefix match table in IPv4UcastLPM LFB. Entry of the table is of IPv4PrefixInfoType data type. </synopsis> <array type=\"variable-size\"> <typeRef>IPv4PrefixInfoType</typeRef> </array> </dataTypeDef> <dataTypeDef> <name>IPv4UcastLPMStatsType</name> <synopsis> Data type for statistics in IPv4UcastLPM LFB. </synopsis> <struct> <component componentID=\"1\"> <name>InRcvdPkts</name> <synopsis>Number of received input packets.</synopsis> <typeRef>uint64</typeRef> </component> <component componentID=\"2\"> <name>FwdPkts</name> <synopsis>Number of forwarded packets.</synopsis> <typeRef>uint64</typeRef> </component> <component componentID=\"3\">",
      "ja": "<名前>予約</名前> <概要>主にパディングすることを目的と充填効率のために予約されたビット空間。 </シノプシス> <typeRef> UCHAR </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"6\"> <名前> HopSelector </名前> <概要>下流に出力されるLFBを一致接頭辞によって生成HopSelector、 LFBネクストホップ情報を検索します。 </シノプシス> <typeRef> UINT32 </ typeRef> </成分> </構造体> </ dataTypeDef> <dataTypeDef> <名前> IPv4PrefixTableType </名前> <概要> IPv4UcastLPM LFBでIPv4の最長プレフィックスマッチテーブルのデータ型。テーブルのエントリはIPv4PrefixInfoTypeデータ型です。 IPv4UcastLPMにおける統計</シノプシス> <配列タイプ= \"可変サイズ\"> <typeRef> IPv4PrefixInfoType </ typeRef> </アレイ> </ dataTypeDef> <dataTypeDef> <名前> IPv4UcastLPMStatsType </名前> <概要>データ型LFB。 </シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前> InRcvdPkts </名前> <概要>受信した入力パケット数</概要> <typeRef> UINT64 </ typeRef> </コンポーネント> <成分COMPONENTID = \"2\"> <名前> FwdPkts </名前> <概要>転送されたパケットの数</概要> <typeRef> UINT64 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\">"
    },
    {
      "indent": 6,
      "text": " <name>NoRoutePkts</name> <synopsis> Number of packets with no route found. </synopsis> <typeRef>uint64</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>IPv6PrefixInfoType</name> <synopsis>Data type for entry of IPv6 longest prefix match table in IPv6UcastLPM LFB. The destination IPv6 address of every input packet is used as a search key to look up the table to find out a next-hop selector.</synopsis> <struct> <component componentID=\"1\"> <name>IPv6Address</name> <synopsis>The destination IPv6 address</synopsis> <typeRef>IPv6Addr</typeRef> </component> <component componentID=\"2\"> <name>Prefixlen</name> <synopsis>The prefix length</synopsis> <atomic> <baseType>uchar</baseType> <rangeRestriction> <allowedRange min=\"0\" max=\"128\"/> </rangeRestriction> </atomic> </component> <component componentID=\"3\"> <name>ECMPFlag</name> <synopsis>ECMP flag</synopsis> <atomic> <baseType>boolean</baseType> <specialValues> <specialValue value=\"false\"> <name>False</name> <synopsis>ECMP false</synopsis> </specialValue> <specialValue value=\"true\"> <name>True</name> <synopsis>ECMP true</synopsis> </specialValue> </specialValues> </atomic> </component> <component componentID=\"4\">",
      "ja": "<名前> NoRoutePkts </名前> <概要>見つかりませルートを持つパケットの数。 </シノプシス> <typeRef> UINT64 </ typeRef> </成分> </構造体> </ dataTypeDef> <dataTypeDef> <名前> IPv6PrefixInfoType </名前> <概要> IPv6UcastLPMにおけるIPv6の最長プレフィックスマッチテーブルのエントリのデータ型LFB。すべての入力パケットの宛先IPv6アドレスは、次ホップの選択を見つけるためにテーブルをルックアップするための検索キーとして使用されている。</概要> <構造体> <コンポーネントのComponentID =「1」> <名前> IPv6Address </名前> <概要>宛先IPv6アドレス</シノプシス> <typeRef> IPv6Addr </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前>のprefixlen </名前> <概要>プレフィックス長</概要> <原子> <baseType> UCHAR </ baseType> <rangeRestriction> <allowedRange分= \"0\" 最大= \"128\" /> </ rangeRestriction> </原子> </コンポーネント> <コンポーネントのComponentID = \"3\"> <名前> ECMPFlag </名前> <概要> ECMPフラグ</シノプシス> <原子> <baseType>ブール</ baseType> <specialValues> <specialValue値= \"偽\"> <名前>偽</名前> <概要> ECMP偽</概要> </ specialValue> <specialValue値= \"TRUE\"> <名前>真</名前> <概要> ECMP真</概要> </ specialValue> </ specialValues> </原子> </成分> <コンポーネントのComponentID = \"4\">"
    },
    {
      "indent": 6,
      "text": " <name>DefaultRouteFlag</name> <synopsis>Default route flag</synopsis> <atomic> <baseType>boolean</baseType> <specialValues> <specialValue value=\"false\"> <name>False</name> <synopsis>Default false</synopsis> </specialValue> <specialValue value=\"true\"> <name>True</name> <synopsis>Default route true</synopsis> </specialValue> </specialValues> </atomic> </component> <component componentID=\"5\"> <name>Reserved</name> <synopsis> A reserved bit space mainly for purpose of padding and packing efficiency. </synopsis> <typeRef>uchar</typeRef> </component> <component componentID=\"6\"> <name>HopSelector</name> <synopsis> The HopSelector produced by the prefix matching LFB, which will be output to downstream LFB to find next-hop information. </synopsis> <typeRef>uint32</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>IPv6PrefixTableType</name> <synopsis> Data type for IPv6 longest prefix match table in IPv6UcastLPM LFB. Entry of the table is of IPv6PrefixInfoType data type. </synopsis> <array type=\"variable-size\"> <typeRef>IPv6PrefixInfoType</typeRef> </array> </dataTypeDef> <dataTypeDef>",
      "ja": "<名前> DefaultRouteFlag </名前> <概要>デフォルトルートフラグ</シノプシス> <原子> <baseType>ブール</ baseType> <specialValues> <specialValue値= \"偽\"> <名前>偽</名前> <概要>デフォルトはfalse </概要> </ specialValue> <specialValue値= \"真の\"> <名前>真</名前> <概要>デフォルトルートの真</概要> </ specialValue> </ specialValues> </アトミック> < /コンポーネント> <コンポーネントのComponentID =「5」> <名前>予約</名前> <概要>主にパディングすることを目的と充填効率のために予約されたビット空間。 </シノプシス> <typeRef> UCHAR </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"6\"> <名前> HopSelector </名前> <概要>下流に出力されるLFBを一致接頭辞によって生成HopSelector、 LFBネクストホップ情報を検索します。 </シノプシス> <typeRef> UINT32 </ typeRef> </成分> </構造体> </ dataTypeDef> <dataTypeDef> <名前> IPv6PrefixTableType </名前> <概要> IPv6UcastLPM LFBにおけるIPv6の最長プレフィックスマッチテーブルのデータ型。テーブルのエントリはIPv6PrefixInfoTypeデータ型です。 </シノプシス> <配列型= \"可変サイズ\"> <typeRef> IPv6PrefixInfoType </ typeRef> </アレイ> </ dataTypeDef> <dataTypeDef>"
    },
    {
      "indent": 6,
      "text": " <name>IPv6UcastLPMStatsType</name> <synopsis>Data type for statistics in IPv6UcastLPM LFB </synopsis> <struct> <component componentID=\"1\"> <name>InRcvdPkts</name> <synopsis>Number of received input packets</synopsis> <typeRef>uint64</typeRef> </component> <component componentID=\"2\"> <name>FwdPkts</name> <synopsis>Number of forwarded packets</synopsis> <typeRef>uint64</typeRef> </component> <component componentID=\"3\"> <name>NoRoutePkts</name> <synopsis> Number of packets with no route found. </synopsis> <typeRef>uint64</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>IPv4NextHopInfoType</name> <synopsis> Data type for entry of IPv4 next-hop information table in IPv4NextHop LFB. The table uses a hop selector received from upstream LFB as a search key to look up index of the table to find the next-hop information. </synopsis> <struct> <component componentID=\"1\"> <name>L3PortID</name> <synopsis> The ID of the logical output port that is to pass onto downstream LFB, indicating what port to the neighbor is as defined by L3. </synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"2\"> <name>MTU</name> <synopsis> Maximum Transmission Unit for outgoing port </synopsis> <typeRef>uint32</typeRef> </component>",
      "ja": "<名前> IPv6UcastLPMStatsType </名前> <概要> IPv6UcastLPM LFBにおける統計のデータ型</シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前> InRcvdPkts </名前> <概要>受信した入力パケットの数< /シノプシス> <typeRef> UINT64 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> FwdPkts </名前> <概要>転送されたパケットの数</シノプシス> <typeRef> UINT64 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\"> <名前> NoRoutePkts </名前> <概要>見つかりませんでした経路とパケットの数。 </シノプシス> <typeRef> UINT64 </ typeRef> </成分> </構造体> </ dataTypeDef> <dataTypeDef> <名前> IPv4NextHopInfoType </名前> <概要>のIPv4ネクストホップ情報テーブルのエントリ内のデータ型IPv4NextHop LFB。テーブルは、ホップセレクタが次のホップ情報を見つけるためにテーブルのインデックスを検索するための検索キーとして上流LFBから受信した使用します。 </シノプシス> <構造体> <コンポーネントのComponentID =「1」> <名前> L3PortID </名前> <概要>下流LFBに通過する論理出力ポートのID、定義された通りであり、隣接するポートを示しますL3によります。 </シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> MTU </名前> <概要>発信ポートの最大伝送ユニット</シノプシス> <typeRef> UINT32 < / typeRef> </成分>"
    },
    {
      "indent": 6,
      "text": " <component componentID=\"3\"> <name>NextHopIPAddr</name> <synopsis>The next-hop IPv4 address</synopsis> <typeRef>IPv4Addr</typeRef> </component> <component componentID=\"4\"> <name>MediaEncapInfoIndex</name> <synopsis> The index passed onto a downstream encapsulation LFB, used there as a search key to lookup further encapsulation information. </synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"5\"> <name>LFBOutputSelectIndex</name> <synopsis> The index for the IPv4NextHop LFB to choose an instance in the group output port of the LFB to output. </synopsis> <typeRef>uint32</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>IPv4NextHopTableType</name> <synopsis> Data type for IPv4 next-hop table in IPv4NextHop LFB. Entry of the table is of IPv4NextHopInfoType data type. </synopsis> <array type=\"variable-size\"> <typeRef>IPv4NextHopInfoType</typeRef> </array> </dataTypeDef> <dataTypeDef> <name>IPv6NextHopInfoType</name> <synopsis> Data type for entry of IPv6 next-hop information table in IPv6NextHop LFB. The table uses a hop selector received from upstream LFB as a search key to look up index of the table to find the next-hop information. </synopsis> <struct> <component componentID=\"1\">",
      "ja": "<成分COMPONENTID = \"3\"> <名前> NextHopIPAddr </名前> <概要>ネクストホップIPv4アドレス</シノプシス> <typeRef> IPv4Addr </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"4\"> <名前> MediaEncapInfoIndex </名前> <概要>さらにカプセル化情報を検索するための検索キーとして用い、下流のカプセル化LFB上に渡されたインデックス、。 </シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"5\"> <名前> LFBOutputSelectIndex </名前> <概要>グループの出力ポートでインスタンスを選択するIPv4NextHop LFBの指標出力へのLFBの。 </シノプシス> <typeRef> UINT32 </ typeRef> </成分> </構造体> </ dataTypeDef> <dataTypeDef> <名前> IPv4NextHopTableType </名前> <概要> IPv4NextHop LFBでのIPv4ネクストホップテーブルのデータ型。テーブルのエントリはIPv4NextHopInfoTypeデータ型です。 </シノプシス> <配列型= \"可変サイズ\"> <typeRef> IPv4NextHopInfoType </ typeRef> </アレイ> </ dataTypeDef> <dataTypeDef> <名前> IPv6NextHopInfoType </名前> <概要>のIPv6のエントリのデータ型IPv6NextHop LFBでネクストホップ情報テーブル。テーブルは、ホップセレクタが次のホップ情報を見つけるためにテーブルのインデックスを検索するための検索キーとして上流LFBから受信した使用します。 </シノプシス> <構造体> <コンポーネントのComponentID = \"1\">"
    },
    {
      "indent": 6,
      "text": " <name>L3PortID</name> <synopsis> The ID of the logical output port that is to pass onto downstream LFB, indicating what port to the neighbor is as defined by L3. </synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"2\"> <name>MTU</name> <synopsis> Maximum Transmission Unit for outgoing port </synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"3\"> <name>NextHopIPAddr</name> <synopsis>The next-hop IPv6 address</synopsis> <typeRef>IPv6Addr</typeRef> </component> <component componentID=\"4\"> <name>MediaEncapInfoIndex</name> <synopsis> The index passed onto a downstream encapsulation LFB, used there as a search key to lookup further encapsulation information. </synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"5\"> <name>LFBOutputSelectIndex</name> <synopsis> The index for the IPv6NextHop LFB to choose an instance in the group output port of the LFB to output. </synopsis> <typeRef>uint32</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>IPv6NextHopTableType</name> <synopsis> Data type for IPv6 next-hop table in IPv6NextHop LFB. Entry of the table is of IPv6NextHopInfoType data type. </synopsis> <array type=\"variable-size\"> <typeRef>IPv6NextHopInfoType</typeRef> </array>",
      "ja": "<名前> L3PortID </名前> <概要> L3で定義した通りであり、隣接するポートを示す、下流LFBに通過する論理出力ポートのID。 </シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> MTU </名前> <概要>発信ポートの最大伝送ユニット</シノプシス> <typeRef> UINT32 < / typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\"> <名前> NextHopIPAddr </名前> <概要>ネクストホップIPv6アドレス</シノプシス> <typeRef> IPv6Addr </ typeRef> </コンポーネント> <成分COMPONENTID =「4」> <名前> MediaEncapInfoIndex </名前> <概要>さらにカプセル化情報を検索するための検索キーとして用い下流封入LFBに渡されたインデックス、。 </シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"5\"> <名前> LFBOutputSelectIndex </名前> <概要>グループの出力ポートでインスタンスを選択するIPv6NextHop LFBの指標出力へのLFBの。 </シノプシス> <typeRef> UINT32 </ typeRef> </成分> </構造体> </ dataTypeDef> <dataTypeDef> <名前> IPv6NextHopTableType </名前> <概要> IPv6NextHop LFBでのIPv6ネクストホップテーブルのデータ型。テーブルのエントリはIPv6NextHopInfoTypeデータ型です。 </シノプシス> <配列型= \"可変サイズ\"> <typeRef> IPv6NextHopInfoType </ typeRef> </アレイ>"
    },
    {
      "indent": 6,
      "text": "</dataTypeDef> <dataTypeDef> <name>EncapTableEntryType</name> <synopsis> Data type for entry of Ethernet encapsulation table in EtherEncap LFB. The LFB uses the MediaEncapInfoIndex received from upstream LFB as index of the table to find encapsulation information of every packet. </synopsis> <struct> <component componentID=\"1\"> <name>DstMac</name> <synopsis> Destination MAC address for Ethernet encapsulation of the packet. </synopsis> <typeRef>IEEEMAC</typeRef> </component> <component componentID=\"2\"> <name>SrcMac</name> <synopsis> Source MAC address for Ethernet encapsulation of the packet. </synopsis> <typeRef>IEEEMAC</typeRef> </component> <component componentID=\"3\"> <name>VlanID</name> <synopsis>The VLAN ID assigned to the packet</synopsis> <typeRef>VlanIDType</typeRef> </component> <component componentID=\"4\"> <name>Reserved</name> <synopsis> A reserved bit space mainly for purpose of padding and packing efficiency. </synopsis> <typeRef>uint16</typeRef> </component> <component componentID=\"5\"> <name>L2PortID</name> <synopsis> The L2 logical output port ID for the packet. </synopsis> <typeRef>uint32</typeRef> </component> </struct> </dataTypeDef>",
      "ja": "</ dataTypeDef> <dataTypeDef> <名前> EncapTableEntryType </名前> <概要> EtherEncap LFBでイーサネットカプセル化テーブルのエントリのデータ型。 LFBはMediaEncapInfoIndexは、すべてのパケットのカプセル化情報を見つけるためにテーブルのインデックスとして上流LFBから受信した使用します。 </シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前> DstMacパケットのイーサネットカプセル化</名前> <概要>宛先MACアドレス。 </シノプシス> <typeRef> IEEEMAC </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> SrcMac </名前> <概要>パケットのイーサネットカプセル化の送信元MACアドレス。 </シノプシス> <typeRef> IEEEMAC </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\"> <名前> VLANID </名前> <概要>パケットに割り当てられたVLAN ID </シノプシス> <typeRef> VlanIDType </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"4\"> <名前>予約</名前> <概要>主にパディングすることを目的と充填効率のために予約されたビット空間。 </シノプシス> <typeRef> uint16の</ typeRef> </コンポーネント> <コンポーネントのComponentID = \"5\"> <名前> L2PortID </名前> <概要>パケットのL2論理出力ポートID。 </シノプシス> <typeRef> UINT32 </ typeRef> </成分> </構造体> </ dataTypeDef>"
    },
    {
      "indent": 6,
      "text": "<dataTypeDef> <name>EncapTableType</name> <synopsis> Data type for Ethernet encapsulation table in EtherEncap LFB. Entry of the table is of EncapTableEntryType data type. </synopsis> <array type=\"variable-size\"> <typeRef>EncapTableEntryType</typeRef> </array> </dataTypeDef> <dataTypeDef> <name>MetadataDispatchType</name> <synopsis> Data type for entry of metadata dispatch table used in BasicMetadataDispatch LFB. The LFB uses a metadata value as a search key to look up the table to find an index of the LFB group output port to output the packet. </synopsis> <struct> <component componentID=\"1\"> <name>MetadataValue</name> <synopsis>The value of the dispatch metadata</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"2\"> <name>OutputIndex</name> <synopsis> Index of a group output port for outgoing packets. </synopsis> <typeRef>uint32</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>MetadataDispatchTableType</name> <synopsis> Data type for metadata dispatch table used in BasicMetadataDispatch LFB. Metadata value of the table is also defined as a content key field. </synopsis> <array type=\"variable-size\"> <typeRef>MetadataDispatchType</typeRef> <contentKey contentKeyID=\"1\"> <contentKeyField>MetadataValue</contentKeyField> </contentKey> </array> </dataTypeDef>",
      "ja": "<dataTypeDef> <名前> EncapTableType </名前> <概要> EtherEncap LFBでイーサネットカプセル化テーブルのデータ型。テーブルのエントリはEncapTableEntryTypeデータ型です。 </シノプシス> <配列型= \"可変サイズ\"> <typeRef> EncapTableEntryType </ typeRef> </アレイ> </ dataTypeDef> <dataTypeDef> <名前> MetadataDispatchType </名前> <概要>メタデータを入力するためのデータ型BasicMetadataDispatch LFBで使用されるディスパッチテーブル。 LFBは、出力にパケットをLFBグループ出力ポートのインデックスを見つけるために、テーブルを検索し、検索キーとしてメタデータ値を使用しています。 </シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前> MetadataValue </名前> <概要>ディスパッチ・メタデータの値</シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <成分COMPONENTID = \"2\"> <名前> OutputIndex </名前> <概要>発信パケットのグループの出力ポートのインデックス。 </シノプシス> <typeRef> UINT32 </ typeRef> </成分> </構造体> </ dataTypeDef> <dataTypeDef> <名前> MetadataDispatchTableType </名前> <概要> BasicMetadataDispatch LFBに使用されるメタデータ・ディスパッチ・テーブルのデータ型。テーブルのメタデータ値も、コンテンツキーフィールドとして定義されています。 </シノプシス> <配列型= \"可変サイズ\"> <typeRef> MetadataDispatchType </ typeRef> <コンテンツ鍵contentKeyID = \"1\"> <contentKeyField> MetadataValue </ contentKeyField> </コンテンツ鍵> </アレイ> </ dataTypeDef>"
    },
    {
      "indent": 6,
      "text": "<dataTypeDef> <name>SchdDisciplineType</name> <synopsis>Scheduling discipline type</synopsis> <atomic> <baseType>uint32</baseType> <specialValues> <specialValue value=\"1\"> <name>RR</name> <synopsis> Round Robin scheduling discipline </synopsis> </specialValue> </specialValues> </atomic> </dataTypeDef> <dataTypeDef> <name>QueueStatsType</name> <synopsis> Data type for entry of queue statistics table in GenericScheduler LFB. </synopsis> <struct> <component componentID=\"1\"> <name>QueueID</name> <synopsis>The input queue ID</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"2\"> <name>QueueDepthInPackets</name> <synopsis>Current queue depth in packets</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"3\"> <name>QueueDepthInBytes</name> <synopsis>Current queue depth in bytes</synopsis> <typeRef>uint32</typeRef> </component> </struct> </dataTypeDef> <dataTypeDef> <name>QueueStatsTableType</name> <synopsis> Data type for queue statistics table in GenericScheduler LFB. Entry of the table is of QueueStatsType data type. </synopsis> <array type=\"variable-size\"> <typeRef>QueueStatsType</typeRef> </array>",
      "ja": "<dataTypeDef> <名前> SchdDisciplineType </名前> <概要>スケジューリング規律型</シノプシス> <原子> <baseType> UINT32 </ baseType> <specialValues> <specialValue値= \"1\"> <名前> RR </名前> <概要>ラウンドロビンスケジューリングの規律</概要> </ specialValue> </ specialValues> </アトミック> </ dataTypeDef> <dataTypeDef> <名前> QueueStatsType </名前> <概要>キュー統計テーブルのエントリのデータ型GenericScheduler LFBインチ</シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前>キューID </名前> <概要>入力キューID </シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> QueueDepthInPackets </パケット内の名前> <概要>現在のキューの深さ</シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\"> <名前> QueueDepthInBytes </バイト単位> <概要>現在のキューの深さ</概要> <typeRef> UINT32 </ typeRef> </部品> </構造体> </ dataTypeDef> <dataTypeDef> <名前> QueueStatsTableType </名前> <概要>データ型に名前を付けますGenericScheduler LFBでのキュー統計表について。テーブルのエントリはQueueStatsTypeデータ型です。 </シノプシス> <配列型= \"可変サイズ\"> <typeRef> QueueStatsType </ typeRef> </アレイ>"
    },
    {
      "indent": 3,
      "text": " </dataTypeDef> </dataTypeDefs> <metadataDefs> <metadataDef> <name>PHYPortID</name> <synopsis>Metadata indicating physical port ID</synopsis> <metadataID>1</metadataID> <typeRef>uint32</typeRef> </metadataDef> <metadataDef> <name>SrcMAC</name> <synopsis>Metadata indicating source MAC address</synopsis> <metadataID>2</metadataID> <typeRef>IEEEMAC</typeRef> </metadataDef> <metadataDef> <name>DstMAC</name> <synopsis> Metadata indicating destination MAC address. </synopsis> <metadataID>3</metadataID> <typeRef>IEEEMAC</typeRef> </metadataDef> <metadataDef> <name>LogicalPortID</name> <synopsis>Metadata of logical port ID</synopsis> <metadataID>4</metadataID> <typeRef>uint32</typeRef> </metadataDef> <metadataDef> <name>EtherType</name> <synopsis>Metadata indicating Ethernet type</synopsis> <metadataID>5</metadataID> <typeRef>uint16</typeRef> </metadataDef> <metadataDef> <name>VlanID</name> <synopsis>Metadata of VLAN ID</synopsis> <metadataID>6</metadataID> <typeRef>VlanIDType</typeRef> </metadataDef> <metadataDef> <name>VlanPriority</name> <synopsis>Metadata of VLAN priority</synopsis> <metadataID>7</metadataID> <typeRef>VlanPriorityType</typeRef> </metadataDef> <metadataDef>",
      "ja": "</ dataTypeDef> </ dataTypeDefs> <metadataDefs> <metadataDef> <名前> PHYPortID </名前> <概要>メタデータを示す物理ポートID </シノプシス> <metadataID> 1 </ metadataID> <typeRef> UINT32 </ typeRef> </ metadataDef> <metadataDef> <名前> SrcMAC </名前> <概要>メタデータを示す送信元MACアドレス</シノプシス> <metadataID> 2 </ metadataID> <typeRef> IEEEMAC </ typeRef> </ metadataDef> <metadataDef> <名前> DstMAC宛先MACアドレスを示す</名前> <概要>メタデータ。 </シノプシス> <metadataID> 3 </ metadataID> <typeRef> IEEEMAC </ typeRef> </ metadataDef> <metadataDef> <名前> LogicalPortID </名前> <概要>論理ポートIDのメタデータ</シノプシス> <metadataID> 4 </ metadataID> <typeRef> UINT32 </ typeRef> </ metadataDef> <metadataDef> <名前>のEtherType </名前> <概要>メタデータを示すイーサネットタイプ</シノプシス> <metadataID> 5 </ metadataID> <typeRef> uint16の</ typeRef> </ metadataDef> <metadataDef> <名前> VLANID </名前> <概要> VLAN IDのメタデータ</シノプシス> <metadataID> 6 </ metadataID> <typeRef> VlanIDType </ typeRef> </ metadataDef > <metadataDef> <名前> VlanPriority </名前> <概要> VLAN優先度のメタデータ</シノプシス> <metadataID> 7 </ metadataID> <typeRef> VlanPriorityType </ typeRef> </ metadataDef> <metadataDef>"
    },
    {
      "indent": 6,
      "text": " <name>NextHopIPv4Addr</name> <synopsis> Metadata representing a next-hop IPv4 address </synopsis> <metadataID>8</metadataID> <typeRef>IPv4Addr</typeRef> </metadataDef> <metadataDef> <name>NextHopIPv6Addr</name> <synopsis> Metadata representing a next-hop IPv6 address </synopsis> <metadataID>9</metadataID> <typeRef>IPv6Addr</typeRef> </metadataDef> <metadataDef> <name>HopSelector</name> <synopsis>Metadata indicating a hop selector</synopsis> <metadataID>10</metadataID> <typeRef>uint32</typeRef> </metadataDef> <metadataDef> <name>ExceptionID</name> <synopsis> Metadata indicating exception types for exceptional cases during packet processing. </synopsis> <metadataID>11</metadataID> <atomic> <baseType>uint32</baseType> <specialValues> <specialValue value=\"0\"> <name>AnyUnrecognizedExceptionCase</name> <synopsis>Any unrecognized exception case</synopsis> </specialValue> <specialValue value=\"1\"> <name>ClassifyNoMatching</name> <synopsis> Exception case: no matching of tables in EtherClassifier LFB. </synopsis> </specialValue> <specialValue value=\"2\"> <name>MediaEncapInfoIndexInvalid</name> <synopsis> Exception case: the MediaEncapInfoIndex value of the packet is invalid and cannot be allocated in the EncapTable in EtherEncap LFB.",
      "ja": "<名前> NextHopIPv4Addr </名前> <概要>メタデータは、次ホップのIPv4アドレスを表す</シノプシス> <metadataID> 8 </ metadataID> <typeRef> IPv4Addr </ typeRef> </ metadataDef> <metadataDef> <名前> NextHopIPv6Addr </名前> <概要>メタデータは、ネクストホップのIPv6アドレスを表す</シノプシス> <metadataID> 9 </ metadataID> <typeRef> IPv6Addr </ typeRef> </ metadataDef> <metadataDef> <名前> HopSelector </名前>例外の種類を示す<概要>メタホップセレクタを示す</シノプシス> <metadataID> 10 </ metadataID> <typeRef> UINT32 </ typeRef> </ metadataDef> <metadataDef> <名前> ExceptionID </名前> <概要>メタデータパケット処理中に例外的な場合のために。 </シノプシス> <metadataID> 11 </ metadataID> <原子> <baseType> UINT32 </ baseType> <specialValues> <specialValue値= \"0\"> <名前> AnyUnrecognizedExceptionCase </名前> <概要>任意の認識されていない例外ケース< /概要> </ specialValue> <specialValue値= \"1\"> <名前> ClassifyNoMatching </名前> <概要>例外ケース：EtherClassifier LFB内のテーブルのないマッチング。 </概要> </ specialValue> <specialValue値= \"2\"> <名前> MediaEncapInfoIndexInvalid </名前> <概要>例外ケース：パケットのMediaEncapInfoIndex値が無効であるとEtherEncap LFBでEncapTableに割り当てることができません。"
    },
    {
      "indent": 16,
      "text": "  </synopsis>\n</specialValue>\n<specialValue value=\"3\">\n  <name>EncapTableLookupFailed</name>\n  <synopsis>\n   Exception case: the packet fails lookup of the\n   EncapTable table in EtherEncap LFB even though the\n   MediaEncapInfoIndex is valid.\n  </synopsis>\n</specialValue>\n<specialValue value=\"4\">\n  <name>BadTTL</name>\n  <synopsis>\n   Exception case: packet with expired TTL\n  </synopsis>\n</specialValue>\n<specialValue value=\"5\">\n  <name>IPv4HeaderLengthMismatch</name>\n  <synopsis>\n   Exception case: packet with header length more\n   than 5 words.\n  </synopsis>\n</specialValue>\n<specialValue value=\"6\">\n   <name>RouterAlertOptions</name>\n   <synopsis>\n    Exception case: packet IP head includes router\n    alert options.\n   </synopsis>\n</specialValue>\n<specialValue value=\"7\">\n   <name>IPv6HopLimitZero</name>\n   <synopsis>\n    Exception case: packet with the hop limit to zero.\n   </synopsis>\n</specialValue>\n<specialValue value=\"8\">\n   <name>IPv6NextHeaderHBH</name>\n   <synopsis>\n    Exception case: packet with next header set to\n    Hop-by-Hop.\n   </synopsis>\n</specialValue>\n<specialValue value=\"9\">\n   <name>SrcAddressException</name>\n   <synopsis>\n    Exception case: packet with exceptional source\n    address.",
      "raw": true
    },
    {
      "indent": 6,
      "text": " </synopsis> </specialValue> <specialValue value=\"10\"> <name>DstAddressException</name> <synopsis> Exception case: packet with exceptional destination address. </synopsis> </specialValue> <specialValue value=\"11\"> <name>LPMLookupFailed</name> <synopsis> Exception case: packet failed the LPM table lookup in a prefix match LFB. </synopsis> </specialValue> <specialValue value=\"12\"> <name>HopSelectorInvalid</name> <synopsis> Exception case: HopSelector for the packet is invalid. </synopsis> </specialValue> <specialValue value=\"13\"> <name>NextHopLookupFailed</name> <synopsis> Exception case: packet failed lookup of a next-hop table even though HopSelector is valid. </synopsis> </specialValue> <specialValue value=\"14\"> <name>FragRequired</name> <synopsis> Exception case: packet fragmentation is required </synopsis> </specialValue> <specialValue value=\"15\"> <name>MetadataNoMatching</name> <synopsis> Exception case: there is no matching when looking up the metadata dispatch table in BasicMetadataDispatch LFB. </synopsis> </specialValue> </specialValues> </atomic> </metadataDef> <metadataDef>",
      "ja": "</概要> </ specialValue> <specialValue値= \"10\"> <名前> DstAddressException </名前> <概要>例外ケース：例外宛先アドレスを持つパケット。 </概要> </ specialValue> <specialValue値= \"11\"> <名前> LPMLookupFailed </名前> <概要>例外ケース：パケットはプレフィックス一致LFBにLPMテーブルルックアップに失敗しました。 </概要> </ specialValue> <specialValue値= \"12\"> <名前> HopSelectorInvalid </名前> <概要>例外ケース：パケットのHopSelectorは無効です。 </概要> </ specialValue> <specialValue値= \"13\"> <名前> NextHopLookupFailed </名前> <概要>例外ケース：パケットがHopSelectorが有効であるにもかかわらず、ネクストホップテーブルの検索に失敗しました。 </概要> </ specialValue> <specialValue値= \"14\"> <名前> FragRequired </名前> <概要>例外ケース：パケットの断片化が必要とされる</概要> </ specialValue> <specialValue値= \"15\"> <名前> MetadataNoMatching </名前> <概要>例外ケース：BasicMetadataDispatch LFBのメタデータのディスパッチテーブルを参照して、一致はありません。 </概要> </ specialValue> </ specialValues> </原子> </ metadataDef> <metadataDef>"
    },
    {
      "indent": 10,
      "text": "<name>ValidateErrorID</name>\n<synopsis>\n  Metadata indicating error types when a packet passes\n  validation process.\n</synopsis>\n<metadataID>12</metadataID>\n<atomic>\n   <baseType>uint32</baseType>\n   <specialValues>\n      <specialValue value=\"0\">\n         <name>AnyUnrecognizedValidateErrorCase</name>\n         <synopsis>\n           Any unrecognized validate error case.\n         </synopsis>\n      </specialValue>\n      <specialValue value=\"1\">\n         <name>InvalidIPv4PacketSize</name>\n         <synopsis>\n          Error case: packet length reported by the link\n          layer is less than 20 bytes.\n         </synopsis>\n      </specialValue>\n      <specialValue value=\"2\">\n         <name>NotIPv4Packet</name>\n         <synopsis>\n          Error case: packet is not IP version 4</synopsis>\n      </specialValue>\n      <specialValue value=\"3\">\n         <name>InvalidIPv4HeaderLengthSize</name>\n         <synopsis>\n          Error case: packet with header length field in\n          the header less than 5 words.\n         </synopsis>\n      </specialValue>\n      <specialValue value=\"4\">\n         <name>InvalidIPv4LengthFieldSize</name>\n         <synopsis>\n          Error case: packet with total length field in the\n          header less than 20 bytes.\n         </synopsis>\n      </specialValue>\n      <specialValue value=\"5\">\n         <name>InvalidIPv4Checksum</name>\n         <synopsis>\n          Error case: packet with invalid checksum.\n          </synopsis>\n      </specialValue>\n      <specialValue value=\"6\">",
      "raw": true
    },
    {
      "indent": 6,
      "text": " <name>InvalidIPv4SrcAddr</name> <synopsis> Error case: packet with invalid IPv4 source address. </synopsis> </specialValue> <specialValue value=\"7\"> <name>InvalidIPv4DstAddr</name> <synopsis> Error case: packet with invalid IPv4 destination address. </synopsis> </specialValue> <specialValue value=\"8\"> <name>InvalidIPv6PacketSize</name> <synopsis> Error case: packet size is less than 40 bytes. </synopsis> </specialValue> <specialValue value=\"9\"> <name>NotIPv6Packet</name> <synopsis> Error case: packet is not IP version 6 </synopsis> </specialValue> <specialValue value=\"10\"> <name>InvalidIPv6SrcAddr</name> <synopsis> Error case: packet with invalid IPv6 source address. </synopsis> </specialValue> <specialValue value=\"11\"> <name>InvalidIPv6DstAddr</name> <synopsis> Error case: packet with invalid IPv6 destination address. </synopsis> </specialValue> </specialValues> </atomic> </metadataDef> <metadataDef> <name>L3PortID</name> <synopsis> Metadata indicating ID of an L3 logical port </synopsis> <metadataID>13</metadataID> <typeRef>uint32</typeRef>",
      "ja": "<名前> InvalidIPv4SrcAddr </名前> <概要>エラーの場合：無効なIPv4ソースアドレスを持つパケット。 </概要> </ specialValue> <specialValue値= \"7\"> <名前> InvalidIPv4DstAddr </名前> <概要>エラーの場合：無効なIPv4宛先アドレスを持つパケット。 </概要> </ specialValue> <specialValue値= \"8\"> <名前> InvalidIPv6PacketSize </名前> <概要>エラーの場合：パケットサイズが40バイト未満です。 </概要> </ specialValue> <specialValue値= \"9\"> <名前> NotIPv6Packet </名前> <概要>エラーの場合：パケットがIPバージョン6ない</概要> </ specialValue> <specialValue値= \"10 「> <名前> InvalidIPv6SrcAddr </名前> <概要>エラーの場合：無効なIPv6ソースアドレスを持つパケット。 </概要> </ specialValue> <specialValue値= \"11\"> <名前> InvalidIPv6DstAddr </名前> <概要>エラーの場合：無効なIPv6宛先アドレスを持つパケット。 </概要> </ specialValue> </ specialValues> </原子> </ metadataDef> <metadataDef> <名前> L3PortID </名前> <概要> L3論理ポートのメタデータを示すID </シノプシス> <metadataID> 13 </ metadataID> <typeRef> UINT32 </ typeRef>"
    },
    {
      "indent": 0,
      "text": " </metadataDef> <metadataDef> <name>RedirectIndex</name> <synopsis> Metadata that CE sends to RedirectIn LFB, indicating the index of the LFB group output port. </synopsis> <metadataID>14</metadataID> <typeRef>uint32</typeRef> </metadataDef> <metadataDef> <name>MediaEncapInfoIndex</name> <synopsis> A search key a packet uses to look up a table to select an encapsulation media. </synopsis> <metadataID>15</metadataID> <typeRef>uint32</typeRef> </metadataDef> </metadataDefs> </LFBLibrary>",
      "ja": "CEは、LFBグループの出力ポートのインデックスを示す、RedirectIn LFBに送信</ metadataDef> <metadataDef> <名前> RedirectIndex </名前> <概要>メタデータ。パケットがにテーブルを検索するために使用します。</概要> <metadataID> 14 </ metadataID> <typeRef> UINT32 </ typeRef> </ metadataDef> <metadataDef> <名前> MediaEncapInfoIndex </名前> <概要>検索キーカプセル化メディアを選択します。 </シノプシス> <metadataID> 15 </ metadataID> <typeRef> UINT32 </ typeRef> </ metadataDef> </ metadataDefs> </ LFBLibrary>"
    },
    {
      "indent": 0,
      "text": "5. LFB Class Descriptions",
      "section_title": true,
      "ja": "5. LFBクラスの説明"
    },
    {
      "indent": 3,
      "text": "According to ForCES specifications, an LFB (Logical Function Block) is a well-defined, logically separable functional block that resides in an FE and is a functionally accurate abstraction of the FE's processing capabilities. An LFB class (or type) is a template that represents a fine-grained, logically separable aspect of FE processing. Most LFBs are related to packet processing in the data path. LFB classes are the basic building blocks of the FE model. Note that [RFC5810] has already defined an 'FE Protocol LFB', which is a logical entity in each FE to control the ForCES protocol. [RFC5812] has already defined an 'FE Object LFB'. Information like the FE Name, FE ID, FE State, and LFB Topology in the FE are represented in this LFB.",
      "ja": "ForCES仕様に従って、LFB（論理機能ブロック）FEに存在し、FEの処理能力の機能的に正確な抽象化であり、明確に定義され、論理的に分離可能な機能ブロックです。 LFBクラス（またはタイプ）FE処理のきめ細かい、論理的に分離可能な態様を表すテンプレートです。ほとんどのLFBsは、データパス内のパケット処理に関連しています。 LFBクラスは、FEモデルの基本的なビルディングブロックです。 [RFC5810]は既にのForCESプロトコルを制御するために、各FE内の論理エンティティである「FEプロトコルLFB」を定義していることに留意されたいです。 [RFC5812]は既に 'FEオブジェクトLFB' を定義しています。 FEの名前、FE ID、FE州、およびFEでLFBトポロジなどの情報は、このLFBで表現されています。"
    },
    {
      "indent": 3,
      "text": "As specified in Section 3.1, this document focuses on the base LFB library for implementing typical router functions, especially for IP forwarding functions. As a result, LFB classes in the library are all base LFBs to implement router forwarding.",
      "ja": "3.1節で規定されているように、この文書は、特にIP転送機能のために、一般的なルータ機能を実現するための基本LFBライブラリに焦点を当てています。その結果、ライブラリ内のLFBクラスは、ルータの転送を実現するために、すべてのベースLFBsです。"
    },
    {
      "indent": 3,
      "text": "In this section, the terms \"upstream LFB\" and \"downstream LFB\" are used. These are used relative to the LFB that is being described. An \"upstream LFB\" is one whose output ports are connected to input ports of the LFB under consideration such that output (typically packets with metadata) can be sent from the \"upstream LFB\" to the LFB under consideration. Similarly, a \"downstream LFB\" whose input ports are connected to output ports of the LFB under consideration such that the LFB under consideration can send information to the \"downstream LFB\". Note that in some rare topologies, an LFB may be both upstream and downstream relative to another LFB.",
      "ja": "このセクションでは、用語「上流LFB」および「下流LFB」が使用されています。これらは、説明されているLFBに対して使用されます。 「上流LFB」は、その出力ポートの出力が（典型的にはメタデータとパケット）検討中の「上流LFB」からLFBに送信することができるように検討中のLFBの入力ポートに接続されているものです。その入力ポートは、検討中のLFBは「下流LFB」に情報を送ることができるように検討中LFBの出力ポートに接続されている。同様に、「下流LFB」。いくつかのまれなトポロジで、LFBは別のLFBの上流及び下流側の両方であってもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Also note that, as a default provision of [RFC5812], in the FE model, all metadata produced by upstream LFBs will pass through all downstream LFBs by default without being specified by input port or output port. Only those metadata that will be used (consumed) by an LFB will be explicitly marked in the input of the LFB as expected metadata. For instance, in downstream LFBs of a physical-layer LFB, even if there is no specific metadata expected, metadata like PHYPortID produced by the physical-layer LFB will always pass through all downstream LFBs regardless of whether or not the metadata has been expected by the LFBs.",
      "ja": "また、[RFC5812]のデフォルトの規定として、FEモデルでは、上流LFBsによって生成されたすべてのメタデータは、入力ポートまたは出力ポートで指定されずに、デフォルトですべての下流LFBsを通過することに留意されたいです。 LFBによって（消費）が使用されますのみがメタデータには、明示的に期待されるメタデータとしてLFBの入力にマークされます。例えば、物理層LFBの下流LFBsに、予想されるいかなる特定のメタデータが存在しない場合であっても、物理層LFBによって生成PHYPortIDようなメタデータは、常に関係なく、メタデータにより期待されているか否かの全て下流LFBs通過しますLFBs。"
    },
    {
      "indent": 0,
      "text": "5.1. Ethernet-Processing LFBs",
      "section_title": true,
      "ja": "5.1。イーサネット処理LFBs"
    },
    {
      "indent": 3,
      "text": "As the most popular physical- and data-link-layer protocol, Ethernet is widely deployed. It becomes a basic requirement for a router to be able to process various Ethernet data packets.",
      "ja": "最も人気のあるphysical-とデータリンク層プロトコルとして、イーサネットが広く展開されています。これは、ルータは、さまざまなイーサネットデータパケットを処理できるようにするための基本的な要件となります。"
    },
    {
      "indent": 3,
      "text": "Note that different versions of Ethernet formats exist, like Ethernet V2, 802.3 RAW, IEEE 802.3/802.2, and IEEE 802.3/802.2 SNAP. Varieties of LAN techniques based on Ethernet also exist, like various VLANs, MACinMAC, etc. Ethernet-processing LFBs defined here are intended to be able to cope with all these variations of Ethernet technology.",
      "ja": "イーサネット形式の異なるバージョンは、イーサネットV2、802.3 RAW、IEEE 802.3 / 802.2、およびIEEE 802.3 / 802.2 SNAPように、存在することに留意されたいです。イーサネットに基づくLAN技術の品種もここで定義されたイーサネット・処理LFBsは、イーサネット技術のすべてのこれらの変化に対応することができるように意図されているなど、さまざまなVLANのように、MACinMAC存在します。"
    },
    {
      "indent": 3,
      "text": "There are also various types of Ethernet physical interface media. Among them, copper and fiber media may be the most popular ones. As a base LFB definition and a starting point, this document only defines an Ethernet physical LFB with copper media. For other media interfaces, specific LFBs may be defined in future versions of the library.",
      "ja": "イーサネット物理インターフェイスのメディアの様々なタイプもあります。その中でも、銅およびファイバーメディアは、最も人気のあるものかもしれません。ベースLFB定義と出発点として、この文書は、銅媒体とイーサネット物理LFBを定義します。他のメディアインターフェースのため、特定LFBsは、ライブラリの将来のバージョンで定義されてもよいです。"
    },
    {
      "indent": 0,
      "text": "5.1.1. EtherPHYCop",
      "section_title": true,
      "ja": "5.1.1。 EtherPHYCop"
    },
    {
      "indent": 3,
      "text": "EtherPHYCop LFB abstracts an Ethernet interface physical layer with media limited to copper.",
      "ja": "EtherPHYCop LFBは、銅に限ら媒体とイーサネットインタフェースの物理層を抽象化。"
    },
    {
      "indent": 0,
      "text": "5.1.1.1. Data Handling",
      "section_title": true,
      "ja": "5.1.1.1。データ処理"
    },
    {
      "indent": 3,
      "text": "This LFB is the interface to the Ethernet physical media. The LFB handles Ethernet frames coming in from or going out of the FE. Ethernet frames sent and received cover all packets encapsulated with different versions of Ethernet protocols, like Ethernet V2, 802.3 RAW, IEEE 802.3/802.2, and IEEE 802.3/802.2 SNAP, including packets encapsulated with varieties of LAN techniques based on Ethernet, like various VLANs, MACinMAC, etc. Therefore, in the XML, an EthernetAll frame type has been introduced.",
      "ja": "このLFBは、イーサネット物理メディアへのインタフェースです。 LFBは、イーサネットから入ってくるか、FEの出入りフレーム処理します。イーサネットフレームは、種々のVLANのようなイーサネットに基づくLAN技術の品種でカプセル化されたパケットを含むイーサネットV2、802.3 RAW、IEEE 802.3 / 802.2、およびIEEE 802.3 / 802.2 SNAPようなイーサネットプロトコルの異なるバージョンでカプセル化すべてのパケットを、送信されたカバーを受信しました、MACinMAC、等したがって、XMLで、EthernetAllフレームタイプが導入されています。"
    },
    {
      "indent": 3,
      "text": "Ethernet frames are received from the physical media port and passed downstream to LFBs, such as EtherMACIn LFBs, via a singleton output known as \"EtherPHYOut\". A PHYPortID metadata, which indicates the physical port from which the frame came in from the external world, is passed along with the frame.",
      "ja": "イーサネットフレームは、物理メディアポートから受信した「EtherPHYOut」として知られているシングルトン出力を介して、例えばEtherMACIn LFBsとしてLFBs、下流に渡されます。フレームは、外部の世界から来た物理ポートを示しPHYPortIDメタデータは、フレームと一緒に渡されます。"
    },
    {
      "indent": 3,
      "text": "Ethernet packets are received by this LFB from upstream LFBs, such as EtherMacOut LFBs, via the singleton input known as \"EtherPHYIn\" before being sent out to the external world.",
      "ja": "イーサネットパケットは、外界に送出される前に「EtherPHYIn」として知られているシングルトン入力を介して、例えばEtherMacOut LFBsとして上流LFBs、からこのLFBによって受信されます。"
    },
    {
      "indent": 0,
      "text": "5.1.1.2. Components",
      "section_title": true,
      "ja": "5.1.1.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "The AdminStatus component is defined for the CE to administratively manage the status of the LFB. The CE may administratively start up or shut down the LFB by changing the value of AdminStatus. The default value is set to 'Down'.",
      "ja": "AdminStatus成分が管理LFBのステータスを管理するためのCEのために定義されています。 CEは、管理起動またはのAdminStatusの値を変更することにより、LFBをシャットダウンすることができます。デフォルト値は「ダウン」に設定されています。"
    },
    {
      "indent": 3,
      "text": "An OperStatus component captures the physical port operational status. A PHYPortStatusChanged event is defined so the LFB can report to the CE whenever there is an operational status change of the physical port.",
      "ja": "OperStatusコンポーネントは、物理ポート動作ステータスをキャプチャします。 PHYPortStatusChangedイベントは、物理ポートの動作ステータスの変更があったときはいつでもLFBがCEに報告することができるように定義されています。"
    },
    {
      "indent": 3,
      "text": "The PHYPortID component is a unique identification for a physical port. It is defined as 'read-only' by the CE. Its value is enumerated by FE. The component will be used to produce a PHYPortID metadata at the LFB output and to associate it to every Ethernet packet this LFB receives. The metadata will be handed to downstream LFBs for them to use the PHYPortID.",
      "ja": "PHYPortIDコンポーネントは、物理ポートの一意の識別子です。それは、「読み取り専用」CEであると定義されます。その値は、FEによって列挙されます。コンポーネントは、LFB出力でPHYPortIDメタデータを生成し、このLFBが受け取るすべてのイーサネットパケットにそれを関連付けるために使用されるであろう。彼らはPHYPortIDを使用するためのメタデータは、下流LFBsに渡されます。"
    },
    {
      "indent": 3,
      "text": "A group of components are defined for link speed management. The AdminLinkSpeed is for the CE to configure link speed for the port, and the OperLinkSpeed is for the CE to query the actual link speed in operation. The default value for the AdminLinkSpeed is set to auto-negotiation mode.",
      "ja": "コンポーネントのグループは、リンク速度管理のために定義されています。 AdminLinkSpeed、ポートのリンク速度を設定するには、CEのためである、とCEが動作して、実際のリンク速度を照会するためOperLinkSpeedです。 AdminLinkSpeedのデフォルト値は、オートネゴシエーションモードに設定されています。"
    },
    {
      "indent": 3,
      "text": "A group of components are defined for duplex mode management. The AdminDuplexMode is for the CE to configure proper duplex mode for the port, and the OperDuplexMode is for CE to query the actual duplex mode in operation. The default value for the AdminDuplexMode is set to auto-negotiation mode.",
      "ja": "コンポーネントのグループは、二重モードの管理のために定義されています。 AdminDuplexModeは、ポートのための適切な二重モードを設定するには、CEのためである、とOperDuplexModeは、動作中の実際の二重モードを照会するCE用です。 AdminDuplexModeのデフォルト値は、オートネゴシエーションモードに設定されています。"
    },
    {
      "indent": 3,
      "text": "A CarrierStatus component captures the status of the carrier and specifies whether the port link is operationally up. The default value for the CarrierStatus is 'false'.",
      "ja": "CarrierStatusコンポーネントは、キャリアの状態をキャプチャし、ポートのリンクが運用アップしているかどうかを指定します。 CarrierStatusのデフォルト値は「false」です。"
    },
    {
      "indent": 0,
      "text": "5.1.1.3. Capabilities",
      "section_title": true,
      "ja": "5.1.1.3。機能"
    },
    {
      "indent": 3,
      "text": "The capability information for this LFB includes the link speeds that are supported by the FE (SupportedLinkSpeed) as well as the supported duplex modes (SupportedDuplexMode).",
      "ja": "このLFB用能力情報は、FE（SupportedLinkSpeed）ならびにサポートデュプレックスモード（SupportedDuplexMode）によってサポートされているリンク速度を含みます。"
    },
    {
      "indent": 0,
      "text": "5.1.1.4. Events",
      "section_title": true,
      "ja": "5.1.1.4。イベント"
    },
    {
      "indent": 3,
      "text": "Several events are generated. There is an event for changes in the status of the physical port (PhyPortStatusChanged). Such an event will notify that the physical port status has been changed, and the report will include the new status of the physical port.",
      "ja": "いくつかのイベントが生成されます。物理ポート（PhyPortStatusChanged）の状態の変化のためのイベントがあります。このようなイベントは、物理ポートのステータスが変更されたことを通知します、と報告書は、物理ポートの新しいステータスが含まれます。"
    },
    {
      "indent": 3,
      "text": "Another event captures changes in the operational link speed (LinkSpeedChanged). Such an event will notify the CE that the operational speed has been changed, and the report will include the new negotiated operational speed.",
      "ja": "もう一つのイベントは、動作リンク速度（LinkSpeedChanged）の変化を捉えます。このようなイベントは、動作速度が変更されたCEを通知します、と報告書は、新たな交渉し、動作速度が含まれます。"
    },
    {
      "indent": 3,
      "text": "A final event captures changes in the duplex mode (DuplexModeChanged). Such an event will notify the CE that the duplex mode has been changed and the report will include the new negotiated duplex mode.",
      "ja": "最後のイベントは、二重モード（DuplexModeChanged）の変化を捕捉します。このようなイベントは、二重モードが変更されたCEを通知し、報告書は、新たな交渉し、デュプレックスモードが含まれます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. EtherMACIn",
      "section_title": true,
      "ja": "5.1.2。 EtherMASIn"
    },
    {
      "indent": 3,
      "text": "EtherMACIn LFB abstracts an Ethernet port at the MAC data link layer. This LFB describes Ethernet processing functions like checking MAC address locality, deciding if the Ethernet packets should be bridged, providing Ethernet-layer flow control, etc.",
      "ja": "EtherMACIn LFBは、MAC、データリンク層でのイーサネットポートを抽象化します。このLFBはなど、MACアドレスの局所性をチェックするイーサネットパケットをブリッジングする必要があるかどうかの決定、イーサネットレイヤのフロー制御を提供するように、イーサネット処理機能を説明します"
    },
    {
      "indent": 0,
      "text": "5.1.2.1. Data Handling",
      "section_title": true,
      "ja": "5.1.2.1。データ処理"
    },
    {
      "indent": 3,
      "text": "The LFB is expected to receive all types of Ethernet packets (via a singleton input known as \"EtherPktsIn\"), which are usually output from some Ethernet physical-layer LFB, like an EtherPHYCop LFB, along with a metadata indicating the physical port ID of the port on which the packet arrived.",
      "ja": "LFBは、物理ポートIDを示すメタデータと一緒に、EtherPHYCop LFBなど通常いくつかのイーサネット物理層LFBから出力され、（「EtherPktsIn」として知られているシングルトン入力を介して）イーサネットパケットのすべてのタイプを受信するように期待されていますパケットが到着したポート。"
    },
    {
      "indent": 3,
      "text": "The LFB is defined with two separate singleton outputs. All output packets are emitted in the original Ethernet format received at the physical port, unchanged, and cover all Ethernet types.",
      "ja": "LFBは、2つの別個のシングルトン出力で定義されます。すべての出力パケットは不変、物理ポートで受信された元のイーサネット形式で放出された、そしてすべてのイーサネットタイプをカバーしています。"
    },
    {
      "indent": 3,
      "text": "The first singleton output is known as \"NormalPathOut\". It usually outputs Ethernet packets to some LFB, like an EtherClassifier LFB, for further L3 forwarding process along with a PHYPortID metadata indicating the physical port from which the packet came.",
      "ja": "最初のシングルトンの出力は「NormalPathOut」として知られています。これは通常、パケットが来た物理ポートを示すPHYPortIDメタデータと共にさらにL3転送処理のために、EtherClassifier LFBように、いくつかのLFBにイーサネットパケットを出力します。"
    },
    {
      "indent": 3,
      "text": "The second singleton output is known as \"L2BridgingPathOut\". Although the LFB library this document defines is basically to meet typical router functions, it will attempt to be forward compatible with future router functions. The L2BridgingPathOut is defined to meet the requirement that L2 bridging functions may be optionally supported simultaneously with L3 processing and some L2 bridging LFBs that may be defined in the future. If the FE supports L2 bridging, the CE can enable or disable it by means of a \"L2BridgingPathEnable\" component in the FE. If it is enabled, by also instantiating some L2 bridging LFB instances following the L2BridgingPathOut, FEs are expected to fulfill L2 bridging functions. L2BridgingPathOut will output packets exactly the same as in the NormalPathOut output.",
      "ja": "二シングルトンの出力は「L2BridgingPathOut」として知られています。このドキュメントは、定義LFBライブラリは、一般的なルータ機能を満たすために、基本的ですが、それは将来のルータ機能と前方互換性を持つようにしようとします。 L2BridgingPathOutは、L2ブリッジング機能は、必要に応じてL3処理及び将来に定義されてもよいLFBsを埋めるいくつかのL2と同時にサポートすることができる要件を満たすように定義されています。 FEは、L2ブリッジングをサポートしている場合は、CEは、FEの「L2BridgingPathEnable」コンポーネントによって、それを有効または無効にすることができます。それが有効になっている場合、またL2BridgingPathOutを以下LFBインスタンスをブリッジするいくつかのL2をインスタンス化することによって、のFEは、L2ブリッジング機能を果たすことが期待されています。 L2BridgingPathOutはNormalPathOut出力のように出力パケットとまったく同じになります。"
    },
    {
      "indent": 3,
      "text": "This LFB can be set to work in a promiscuous mode, allowing all packets to pass through the LFB without being dropped. Otherwise, a locality check will be performed based on the local MAC addresses. All packets that do not pass through the locality check will be dropped.",
      "ja": "このLFBは、すべてのパケットが廃棄されずにLFBを通過させる、プロミスキャスモードで動作するように設定することができます。それ以外の場合は、局所性チェックは、ローカルMACアドレスに基づいて実行されます。ローカリティ検証を通過しないすべてのパケットはドロップされます。"
    },
    {
      "indent": 3,
      "text": "This LFB can optionally participate in Ethernet flow control in cooperation with EtherMACOut LFB. This document does not go into the details of how this is implemented. This document also does not describe how the buffers that induce the flow control messages behave -- it is assumed that such artifacts exist, and describing them is out of scope in this document.",
      "ja": "このLFBは、必要に応じてEtherMACOut LFBと協力して、イーサネットフロー制御に参加することができます。この文書では、これが実装されている方法の詳細には触れません。また、このドキュメントでは、フロー制御メッセージを誘発するバッファがどのように動作するかを説明していない - そのような人工物が存在すると仮定し、それらを説明することはこの文書の対象範囲外です。"
    },
    {
      "indent": 0,
      "text": "5.1.2.2. Components",
      "section_title": true,
      "ja": "5.1.2.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "The AdminStatus component is defined for the CE to administratively manage the status of the LFB. The CE may administratively start up or shut down the LFB by changing the value of AdminStatus. The default value is set to 'Down'.",
      "ja": "AdminStatus成分が管理LFBのステータスを管理するためのCEのために定義されています。 CEは、管理起動またはのAdminStatusの値を変更することにより、LFBをシャットダウンすることができます。デフォルト値は「ダウン」に設定されています。"
    },
    {
      "indent": 3,
      "text": "The LocalMACAddresses component specifies the local MAC addresses based on which locality checks will be made. This component is an array of MAC addresses and of 'read-write' access permission.",
      "ja": "LocalMACAddressesコンポーネントがチェックが行われますどの地域に基づいて、ローカルMACアドレスを指定します。このコンポーネントは、MACアドレスのと「読み取り書き込み」アクセス許可の配列です。"
    },
    {
      "indent": 3,
      "text": "An L2BridgingPathEnable component captures whether the LFB is set to work as an L2 bridge. An FE that does not support bridging will internally set this flag to false and additionally set the flag property as read-only. The default value for the component is 'false'.",
      "ja": "L2BridgingPathEnable成分は、LFBがL2ブリッジとして動作するように設定されているかどうかを捕捉します。ブリッジングをサポートしていないFEは内部でこのフラグをfalseに設定し、さらに読み取り専用としてフラグプロパティを設定します。コンポーネントのデフォルト値は「false」です。"
    },
    {
      "indent": 3,
      "text": "The PromiscuousMode component specifies whether the LFB is set to work in a promiscuous mode. The default value for the component is 'false'.",
      "ja": "プロミスキャス・モード・コンポーネントは、LFBが無差別モードで動作するように設定されているかどうかを指定します。コンポーネントのデフォルト値は「false」です。"
    },
    {
      "indent": 3,
      "text": "The TxFlowControl component defines whether the LFB is performing flow control on sending packets. The default value is 'false'. Note that the component is defined as \"optional\". If an FE does not implement the component while a CE tries to configure the component to that FE, an error from the FE may be responded to the CE with an error code like 0x09 (E_COMPONENT_DOES_NOT_EXIST) or 0x15 (E_NOT_SUPPORTED), depending on the FE processing. See [RFC5810] for details.",
      "ja": "TxFlowControl成分は、LFBがパケットを送信する上でフロー制御を行っているかどうかを定義します。デフォルト値は「false」です。コンポーネントは、「オプション」として定義されていることに留意されたいです。 CEは、そのFEにコンポーネントを構成しようとしながら、FEコンポーネントを実装していない場合は、FEからの誤差がFEに応じて、0x09の（E_COMPONENT_DOES_NOT_EXIST）または0x15の（E_NOT_SUPPORTED）のようなエラーコードをCEに応答してもよいです処理。詳細については、[RFC5810]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The RxFlowControl component defines whether the LFB is performing flow control on receiving packets. The default value is 'false'. The component is defined as \"optional\".",
      "ja": "RxFlowControl成分は、LFBがパケットを受信するとフロー制御を行っているかどうかを定義します。デフォルト値は「false」です。コンポーネントは、「オプション」として定義されます。"
    },
    {
      "indent": 3,
      "text": "A struct component, MACInStats, defines a set of statistics for this LFB, including the number of received packets and the number of dropped packets. Note that this statistics component is optional to implementers. If a CE tries to query the component while it is not implemented in an FE, an error code will be responded to the CE indicating the error type like 0x09 (E_COMPONENT_DOES_NOT_EXIST) or 0x15 (E_NOT_SUPPORTED), depending on the FE implementation.",
      "ja": "構造体構成要素は、MACInStatsは、受信したパケットの数とドロップされたパケットの数を含む、このLFBの統計のセットを定義します。この統計コンポーネントが実装にオプションであることに注意してください。 CEは、それがFEに実装されていない間コンポーネントを照会しようとすると、エラーコードは、FEの実装に依存して、0x09の（E_COMPONENT_DOES_NOT_EXIST）または0x15の（E_NOT_SUPPORTED）のようなエラー・タイプを示すCEに応答します。"
    },
    {
      "indent": 0,
      "text": "5.1.2.3. Capabilities",
      "section_title": true,
      "ja": "5.1.2.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities.",
      "ja": "このLFBは、機能のリストを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.1.2.4. Events",
      "section_title": true,
      "ja": "5.1.2.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.1.3. EtherClassifier",
      "section_title": true,
      "ja": "5.1.3。 EtherClassifier"
    },
    {
      "indent": 3,
      "text": "The EtherClassifier LFB abstracts the process to decapsulate Ethernet packets and then classify them.",
      "ja": "EtherClassifier LFBは、イーサネットパケットをデカプセル化し、それらを分類するためのプロセスを抽象化します。"
    },
    {
      "indent": 0,
      "text": "5.1.3.1. Data Handling",
      "section_title": true,
      "ja": "5.1.3.1。データ処理"
    },
    {
      "indent": 3,
      "text": "This LFB describes the process of decapsulating Ethernet packets and classifying them into various network-layer data packets according to information included in the Ethernet packets headers.",
      "ja": "このLFBは、イーサネットパケットをデカプセル化し、イーサネットパケットヘッダに含まれる情報に応じて、様々なネットワーク層データパケットにそれらを分類する方法が記載されています。"
    },
    {
      "indent": 3,
      "text": "The LFB is expected to receive all types of Ethernet packets (via a singleton input known as \"EtherPktsIn\"), which are usually output from an upstream LFB like EtherMACIn LFB. This input is also capable of multiplexing to allow for multiple upstream LFBs to be connected. For instance, when an L2 bridging function is enabled in the EtherMACIn LFB, some L2 bridging LFBs may be applied. In this case, after L2 processing, some Ethernet packets may have to be input to the EtherClassifier LFB for classification, while simultaneously, packets directly output from EtherMACIn may also need to input to this LFB. This input is capable of handling such a case. Usually, all expected Ethernet packets will be associated with a PHYPortID metadata, indicating the physical port from which the packet comes. In some cases, for instance, in a MACinMAC case, a LogicalPortID metadata may be expected to associate with the Ethernet packet to further indicate the logical port to which the Ethernet packet belongs. Note that PHYPortID metadata is always expected while LogicalPortID metadata is optionally expected.",
      "ja": "LFBは通常EtherMACIn LFBなど上流LFBから出力され、（「EtherPktsIn」として知られているシングルトン入力を介して）イーサネットパケットのすべてのタイプを受信するように期待されています。この入力は、複数の上流LFBsを接続することを可能にするためにも多重化することが可能です。 L2ブリッジング機能はEtherMACIn LFBで有効になっている場合、例えば、LFBsブリッジング一部L2が適用されてもよいです。この場合、L2処理の後に、いくつかのイーサネットパケットを分類するためのEtherClassifier LFBに入力する必要がある可能性があり、同時にしながら、EtherMACInからのパケットを直接出力もこのLFBに入力する必要があるかもしれません。この入力は、このようなケースを扱うことが可能です。通常、予想されるすべてのイーサネットパケットは、パケットが来るから物理ポートを示す、PHYPortIDメタデータに関連付けられます。いくつかの場合において、例えば、MACinMACケースにおいて、LogicalPortIDメタデータは、さらに、イーサネットパケットが属する論理ポートを示すために、イーサネットパケットに関連付けることが期待できます。 LogicalPortIDのメタデータは、必要に応じて期待されている間PHYPortIDメタデータが常に期待されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Two output LFB ports are defined.",
      "ja": "二つの出力LFBポートが定義されています。"
    },
    {
      "indent": 3,
      "text": "The first output is a group output port known as \"ClassifyOut\". Types of network-layer protocol packets are output to instances of the port group. Because there may be various types of protocol packets at the output ports, the produced output frame is defined as arbitrary for the purpose of wide extensibility in the future. Metadata to be carried along with the packet data is produced at this LFB for consumption by downstream LFBs. The metadata passed downstream includes PHYPortID, as well as information on Ethernet type, source MAC address, destination MAC address, and the logical port ID. If the original packet is a VLAN packet and contains a VLAN ID and a VLAN priority value, then the VLAN ID and the VLAN priority value are also carried downstream as metadata. As a result, the VLAN ID and priority metadata are defined with the availability of \"conditional\".",
      "ja": "第1の出力は「ClassifyOut」として知られているグループの出力ポートです。ネットワーク層プロトコルパケットのタイプは、ポートグループのインスタンスに出力されます。出力ポートにおけるプロトコルパケットの様々な種類があるため、生成された出力フレームは、将来における広い拡張の目的のために任意として定義されます。メタデータは、データが下流LFBsによる消費のために、このLFBで生成されるパケットと共に運ばれます。下流渡されたメタデータは、イーサネット（登録商標）タイプ、送信元MACアドレス、宛先MACアドレス、および論理ポートIDにPHYPortID、同様の情報を含みます。元のパケットは、VLANパケットであるとVLAN IDとVLAN優先順位値が含まれている場合、VLAN IDとVLAN優先順位値は、メタデータとして下流に搬送されます。結果として、VLAN IDと優先メタデータは、「条件」の利用可能性と定義されます。"
    },
    {
      "indent": 3,
      "text": "The second output is a singleton output port known as \"ExceptionOut\", which will output packets for which the data processing failed, along with an additional ExceptionID metadata to indicate what caused the exception. Currently defined exception types include:",
      "ja": "第2の出力は、出力パケットがそのためのデータ処理は、例外の原因を示すために、追加のExceptionIDメタデータと一緒に、失敗します「ExceptionOut」として知られているシングルトン出力ポートです。現在、定義された例外タイプは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o There is no matching when classifying the packet.",
      "ja": "パケットを分類する際にO一致はありません。"
    },
    {
      "indent": 3,
      "text": "Usually, the ExceptionOut port may point to nowhere, indicating packets with exceptions are dropped, while in some cases, the output may be pointed to the path to the CE for further processing, depending on individual implementations.",
      "ja": "ExceptionOutポートがどこを指していくつかのケースでは、出力は、個々の実装に依存して、更なる処理のためにCEへのパスを指摘することができるが、通常は、例外を除いて示すパケットは、廃棄されます。"
    },
    {
      "indent": 0,
      "text": "5.1.3.2. Components",
      "section_title": true,
      "ja": "5.1.3.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "An EtherDispatchTable array component is defined in the LFB to dispatch every Ethernet packet to the output group according to the logical port ID assigned by the VlanInputTable to the packet and the Ethernet type in the Ethernet packet header. Each row of the array is a struct containing a logical port ID, an EtherType and an output index. With the CE configuring the dispatch table, the LFB can be expected to classify various network-layer protocol type packets and output them at different output ports. It is expected that the LFB classify packets according to protocols like IPv4, IPv6, MPLS, Address Resolution Protocol (ARP), Neighbor Discovery (ND), etc.",
      "ja": "EtherDispatchTableアレイコンポーネントは、パケットとイーサネットパケットヘッダのイーサネットタイプにVlanInputTableによって割り当てられた論理ポートIDに応じた出力グループにすべてのイーサネットパケットをディスパッチするLFBに定義されています。アレイの各行は論理ポートID、イーサタイプと出力指標を含む構造体です。 CEは、ディスパッチテーブルを設定して、LFBは、様々なネットワーク層プロトコルタイプのパケットと異なる出力ポートに出力それらを分類することが期待できます。 LFBがIPv4、IPv6の、MPLS、アドレス解決プロトコル（ARP）、近隣探索（ND）、などのようなプロトコルに従ってパケットを分類することが期待されます"
    },
    {
      "indent": 3,
      "text": "A VlanInputTable array component is defined in the LFB to classify VLAN Ethernet packets. Each row of the array is a struct containing an incoming port ID, a VLAN ID, and a logical port ID. According to IEEE VLAN specifications, all Ethernet packets can be recognized as VLAN types by defining that if there is no VLAN encapsulation in a packet, a case with VLAN tag 0 is considered. Every input packet is assigned with a new LogicalPortID according to the packet's incoming port ID and the VLAN ID. A packet's incoming port ID is defined as a logical port ID if a logical port ID is associated with the packet or a physical port ID if no logical port ID is associated. The VLAN ID is exactly the VLAN ID in the packet if it is a VLAN packet, or 0 if it is not. Note that a logical port ID of a packet may be rewritten with a new one by the VlanInputTable processing.",
      "ja": "VlanInputTableアレイ成分はVLANイーサネットパケットを分類するLFBに定義されています。配列の各行は、受信ポートID、VLAN ID、および論理ポートIDを含む構造体です。 IEEE VLAN仕様によれば、すべてのイーサネットパケットは、パケットにはVLANカプセル化、VLANタグ0の場合が存在しない場合であると考えられることを定義することによって、VLANタイプとして認識することができます。すべての入力パケットは、パケットの着信ポートIDとVLAN IDに基づいて新しいLogicalPortIDが割り当てられています。論理ポートIDは、パケット又は全く論理ポートIDが関連付けられていない場合、物理ポートIDに関連付けられている場合、パケットの受信ポートIDは、論理ポートIDとして定義されます。そうでない場合、それはVLANパケット、または0の場合はVLAN IDは、パケットに正確にVLAN IDです。パケットの論理ポートIDがVlanInputTable処理によって新しいものに書き換えてもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Note that the logical port ID and physical port ID mentioned above are all originally configured by the CE, and are globally effective within a ForCES NE (Network Element). To distinguish a physical port ID from a logical port ID in the incoming port ID field of the VlanInputTable, physical port ID and logical port ID must be assigned with separate number spaces.",
      "ja": "論理ポートID及び上記物理ポートIDが全て元々CEによって構成されていることに注意してください、、強制的にNE（ネットワーク要素）内でグローバルに有効です。 VlanInputTableの着信ポートIDフィールドの論理ポートIDから物理ポートIDを区別するために、物理ポートID、および論理ポートIDは、別個の番号空間を割り当てなければなりません。"
    },
    {
      "indent": 3,
      "text": "An array component, EtherClassifyStats, defines a set of statistics for this LFB, measuring the number of packets per EtherType. Each row of the array is a struct containing an EtherType and a packet number. Note that this statistics component is optional to implementers.",
      "ja": "アレイコンポーネント、EtherClassifyStatsは、イーサタイプ当たりのパケット数を測定し、このLFBの統計のセットを定義します。アレイの各行は、イーサタイプとパケット番号を含む構造体です。この統計コンポーネントが実装にオプションであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.1.3.3. Capabilities",
      "section_title": true,
      "ja": "5.1.3.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities.",
      "ja": "このLFBは、機能のリストを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.1.3.4. Events",
      "section_title": true,
      "ja": "5.1.3.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB has no events specified.",
      "ja": "このLFBは、指定したイベントがありません。"
    },
    {
      "indent": 0,
      "text": "5.1.4. EtherEncap",
      "section_title": true,
      "ja": "5.1.4。 EtherEncap"
    },
    {
      "indent": 3,
      "text": "The EtherEncap LFB abstracts the process to replace or attach appropriate Ethernet headers to the packet.",
      "ja": "EtherEncap LFBは、交換またはパケットに適切なイーサネットヘッダをアタッチするプロセスを抽象化します。"
    },
    {
      "indent": 0,
      "text": "5.1.4.1. Data Handling",
      "section_title": true,
      "ja": "5.1.4.1。データ処理"
    },
    {
      "indent": 3,
      "text": "This LFB abstracts the process of encapsulating Ethernet headers onto received packets. The encapsulation is based on passed metadata.",
      "ja": "このLFBは、受信したパケットにイーサネットヘッダをカプセル化するプロセスを抽象化します。カプセル化は、渡されたメタデータに基づいています。"
    },
    {
      "indent": 3,
      "text": "The LFB is expected to receive IPv4 and IPv6 packets (via a singleton input port known as \"EncapIn\"), which may be connected to an upstream LFB like IPv4NextHop, IPv6NextHop, BasicMetadataDispatch, or any LFB that requires output packets for Ethernet encapsulation. The LFB always expects from upstream LFBs the MediaEncapInfoIndex metadata, which is used as a search key to look up the encapsulation table EncapTable by the search key matching the table index. An input packet may also optionally receive a VLAN priority metadata, indicating that the packet originally had a priority value. The priority value will be loaded back to the packet when encapsulating. The optional VLAN priority metadata is defined with a default value of 0.",
      "ja": "LFBはIPv4NextHop、IPv6NextHop、BasicMetadataDispatch、またはイーサネットカプセル化のための出力パケットを必要とする任意のLFBのような上流のLFBに接続されてもよい、（「EncapIn」として知られているシングルトン入力ポートを介して）IPv4およびIPv6パケットを受信することが期待されます。 LFBは常に上流LFBsからテーブルインデックスに一致する検索キーによってカプセル化テーブルEncapTableを探すために、検索キーとして使用されているMediaEncapInfoIndexメタデータを、期待しています。入力パケットは、任意のパケットが最初の優先順位値を持っていたことを示し、VLAN優先メタデータを受信することができます。カプセル化する際に優先順位の値は、パケットに戻ってロードされます。オプションのVLAN優先メタデータが0のデフォルト値で定義されます。"
    },
    {
      "indent": 3,
      "text": "Two singleton output LFB ports are defined.",
      "ja": "二つのシングルトン出力LFBポートが定義されています。"
    },
    {
      "indent": 3,
      "text": "The first singleton output is known as \"SuccessOut\". Upon a successful table lookup, the destination and source MAC addresses and the logical media port (L2PortID) are found in the matching table entry. The CE may set the VlanID in case VLANs are used. By default, the table entry for VlanID of 0 is used as per IEEE rules [IEEE.802-1Q]. Whatever the value of VlanID, if the input metadata VlanPriority is non-zero, the packet will have a VLAN tag. If the VlanPriority and the VlanID are all zero, there is no VLAN tag for this packet. After replacing or attaching the appropriate Ethernet headers to the packet is complete, the packet is passed out on the \"SuccessOut\" LFB port to a downstream LFB instance along with the L2PortID.",
      "ja": "最初のシングルトンの出力は「SuccessOut」として知られています。成功したテーブルルックアップの際に、宛先と送信元MACアドレスと論理メディアポート（L2PortID）が一致するテーブルエントリに見出されます。 CEは、VLANが使用されている場合にはVLANIDを設定することがあります。デフォルトでは、0のVLANIDのテーブルエントリは、IEEE規則[IEEE.802-1Q]に従って使用されます。どのようなVLANIDの値、入力メタデータVlanPriorityがゼロでない場合、パケットは、VLANタグを持つことになります。 VlanPriorityとVLANIDがすべてゼロである場合は、このパケットにはVLANタグはありません。完了パケットに適切なイーサネットヘッダを交換または取り付けた後、パケットはL2PortIDと共に下流LFBインスタンスに「SuccessOut」LFBポート上で送られます。"
    },
    {
      "indent": 3,
      "text": "The second singleton output is known as \"ExceptionOut\" and will output packets for which the table lookup fails, along with an additional ExceptionID metadata. Currently defined exception types only include the following cases:",
      "ja": "二シングルトン出力が追加ExceptionIDメタデータと一緒にテーブルルックアップが失敗したため、「ExceptionOut」と意志の出力パケット、として知られています。現在定義された例外の種類は次の場合のみが含まれます。"
    },
    {
      "indent": 3,
      "text": "o The MediaEncapInfoIndex value of the packet is invalid and can not be allocated in the EncapTable.",
      "ja": "OパケットのMediaEncapInfoIndex値は無効であり、EncapTableに割り当てることができません。"
    },
    {
      "indent": 3,
      "text": "o The packet failed lookup of the EncapTable table even though the MediaEncapInfoIndex is valid.",
      "ja": "OパケットがMediaEncapInfoIndexが有効であるにもかかわらずEncapTableテーブルの検索に失敗しました。"
    },
    {
      "indent": 3,
      "text": "The upstream LFB may be programmed by the CE to pass along a MediaEncapInfoIndex that does not exist in the EncapTable. This allows for resolution of the L2 headers, if needed, to be made at the L2 encapsulation level, in this case, Ethernet via ARP or ND (or other methods depending on the link-layer technology), when a table miss occurs.",
      "ja": "上流LFBはEncapTableに存在しないMediaEncapInfoIndexに沿って通過するようにCEによってプログラムすることができます。表ミスが発生した場合、これは、必要であれば、この場合には、イーサネットARPまたはNDを介して（または他の方法のリンク層技術に応じて）、L2カプセル化レベルで行われるべきL2ヘッダの分解能を可能にします。"
    },
    {
      "indent": 3,
      "text": "For neighbor L2 header resolution (table miss exception), the processing LFB may pass this packet to the CE via the redirect LFB or",
      "ja": "隣接L2ヘッダ解像度（表ミス例外）、処理LFBはリダイレクトLFBを介してCEにこのパケットを渡すこと、または"
    },
    {
      "indent": 3,
      "text": "FE software or another LFB instance for further resolution. In such a case, the metadata NextHopIPv4Addr or NextHopIPv6Addr generated by the next-hop LFB is also passed to the exception handling. Such an IP address could be used to do activities such as ARP or ND by the handler to which it is passed.",
      "ja": "さらに解像度のためのFEソフトウェアまたは別のLFBインスタンス。このような場合には、ネクストホップLFBによって生成されたメタデータNextHopIPv4AddrまたはNextHopIPv6Addrはまた、例外処理に渡されます。このようなIPアドレスは、ARPなどの活動を行うために使用されるか、またはそれが渡されたハンドラによってNDのことができます。"
    },
    {
      "indent": 3,
      "text": "The result of the L2 resolution is to update the EncapTable as well as the next-hop LFB so subsequent packets do not fail EncapTable lookup. The EtherEncap LFB does not make any assumptions of how the EncapTable is updated by the CE (or whether ARP/ND is used dynamically or static maps exist).",
      "ja": "L2解像度の結果はEncapTableならびにので、後続のパケットがEncapTableルックアップを失敗しないネクストホップLFBを更新することです。 EtherEncap LFBはEncapTableは、CE（またはARP / NDを動的に使用されているか、静的なマップが存在するかどうか）によって更新されたかのいずれかの仮定をしていません。"
    },
    {
      "indent": 3,
      "text": "Downstream LFB instances could be either an EtherMACOut type or a BasicMetadataDispatch type. If the final packet L2 processing is on a per-media-port basis, resides on a different FE, or needs L2 header resolution, then it makes sense for the model to use a BasicMetadataDispatch LFB to fan out to different LFB instances. If there is a direct egress port point, then it makes sense for the model to have a downstream LFB instance be an EtherMACOut.",
      "ja": "下流LFBインスタンスはEtherMACOut型やBasicMetadataDispatchタイプのどちらかである可能性があります。最終パケットL2処理ごとのメディアポートベースである場合、それは異なるLFBインスタンスへのファンアウトにBasicMetadataDispatch LFBを使用するモデルの意味が、異なるFEに存在する、又はL2ヘッダ解像度を必要とします。ダイレクト出力ポートポイントがある場合、モデルが下流LFBインスタンスがEtherMACOutも持っているため、それは理にかなっています。"
    },
    {
      "indent": 0,
      "text": "5.1.4.2. Components",
      "section_title": true,
      "ja": "5.1.4.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "This LFB has only one component named EncapTable, which is defined as an array. Each row of the array is a struct containing the destination MAC address, the source MAC address, the VLAN ID with a default value of zero, and the output logical L2 port ID.",
      "ja": "このLFBは配列として定義されるEncapTable名前だけつの成分を有しています。アレイの各行はゼロのデフォルト値、および出力論理L2ポートIDと宛先MACアドレス、送信元MACアドレス、VLAN IDを含む構造体です。"
    },
    {
      "indent": 0,
      "text": "5.1.4.3. Capabilities",
      "section_title": true,
      "ja": "5.1.4.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities.",
      "ja": "このLFBは、機能のリストを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.1.4.4. Events",
      "section_title": true,
      "ja": "5.1.4.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.1.5. EtherMACOut",
      "section_title": true,
      "ja": "5.1.5。 EtherMAKOut"
    },
    {
      "indent": 3,
      "text": "The EtherMACOut LFB abstracts an Ethernet port at the MAC data link layer. This LFB describes Ethernet packet output process. Ethernet output functions are closely related to Ethernet input functions; therefore, many components defined in this LFB are aliases of EtherMACIn LFB components.",
      "ja": "EtherMACOut LFBは、MAC、データリンク層でのイーサネットポートを抽象化します。このLFBは、イーサネットパケット出力処理を説明します。イーサネット・出力機能は、イーサネット入力機能に密接に関連しています。そのため、このLFBで定義された多くのコンポーネントは、EtherMACIn LFBコンポーネントの別名です。"
    },
    {
      "indent": 0,
      "text": "5.1.5.1. Data Handling",
      "section_title": true,
      "ja": "5.1.5.1。データ処理"
    },
    {
      "indent": 3,
      "text": "The LFB is expected to receive all types of Ethernet packets (via a singleton input known as \"EtherPktsIn\"), which are usually output from an Ethernet encapsulation LFB along with a metadata indicating the ID of the physical port that the packet will go through.",
      "ja": "LFBは、通常、パケットが通過します物理ポートのIDを示すメタデータと共に、イーサネットカプセル化LFBから出力され、（「EtherPktsIn」として知られているシングルトン入力を介して）イーサネットパケットのすべてのタイプを受信するように期待されています。"
    },
    {
      "indent": 3,
      "text": "The LFB is defined with a singleton output port known as \"EtherPktsOut\". All output packets are in Ethernet format, possibly with various Ethernet types, along with a metadata indicating the ID of the physical port that the packet is to go through. This output links to a downstream LFB that is usually an Ethernet physical LFB like the EtherPHYCop LFB.",
      "ja": "LFBは「EtherPktsOut」として知られているシングルトン出力ポートで定義されています。すべての出力パケットは、パケットが通過する物理ポートのIDを示すメタデータと一緒に、おそらく様々なイーサネット（登録商標）タイプで、イーサネット（登録商標）フォーマットです。通常EtherPHYCop LFBのように、イーサネット物理LFBある下流LFBこの出力リンク。"
    },
    {
      "indent": 3,
      "text": "This LFB can optionally participate in Ethernet flow control in cooperation with the EtherMACIn LFB. This document does not go into the details of how this is implemented. This document also does not describe how the buffers that induce the flow control messages behave -- it is assumed that such artifacts exist, but describing them is out of the scope of this document.",
      "ja": "このLFBは、必要に応じてEtherMACIn LFBと協力して、イーサネットフロー制御に参加することができます。この文書では、これが実装されている方法の詳細には触れません。また、このドキュメントでは、フロー制御メッセージを誘発するバッファがどのように動作するかを説明していない - そのような人工物が存在すると仮定し、それらを説明することは、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Note that as a base definition, functions like multiple virtual MAC layers are not supported in this LFB version. It may be supported in the future by defining a subclass or a new version of this LFB.",
      "ja": "ベース定義として、複数の仮想MAC層のような機能が、このLFBバージョンでサポートされていないことに留意されたいです。それは、サブクラスまたはこのLFBの新しいバージョンを定義することによって、将来的にサポートすることができます。"
    },
    {
      "indent": 0,
      "text": "5.1.5.2. Components",
      "section_title": true,
      "ja": "5.1.5.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "The AdminStatus component is defined for the CE to administratively manage the status of the LFB. The CE may administratively start up or shut down the LFB by changing the value of AdminStatus. The default value is set to 'Down'. Note that this component is defined as an alias of the AdminStatus component in the EtherMACIn LFB. This infers that an EtherMACOut LFB usually coexists with an EtherMACIn LFB, both of which share the same administrative status management by the CE. Alias properties, as defined in the ForCES FE model [RFC5812], will be used by the CE to declare the target component to which the alias refers, which includes the target LFB class and instance IDs as well as the path to the target component.",
      "ja": "AdminStatus成分が管理LFBのステータスを管理するためのCEのために定義されています。 CEは、管理起動またはのAdminStatusの値を変更することにより、LFBをシャットダウンすることができます。デフォルト値は「ダウン」に設定されています。この成分はEtherMACIn LFBでのAdminStatus成分の別名として定義されていることに留意されたいです。これはEtherMACOut LFBは通常CEで同じ管理ステータス管理を共有し、どちらも、EtherMACIn LFBと共存することを推測します。エイリアスプロパティは、のForCES FEモデル[RFC5812]で定義されるように、エイリアスが目標LFBクラス及びインスタンスIDならびにターゲット・コンポーネントへのパスを含む、参照するターゲット・コンポーネントを宣言するためにCEによって使用されるであろう。"
    },
    {
      "indent": 3,
      "text": "The MTU component defines the maximum transmission unit.",
      "ja": "MTU成分が最大伝送単位を定義します。"
    },
    {
      "indent": 3,
      "text": "The optional TxFlowControl component defines whether or not the LFB is performing flow control on sending packets. The default value is 'false'. Note that this component is defined as an alias of the TxFlowControl component in the EtherMACIn LFB.",
      "ja": "任意TxFlowControl成分は、LFBがパケットを送信する上でフロー制御を行っているか否かを定義します。デフォルト値は「false」です。この成分はEtherMACIn LFBでTxFlowControl成分の別名として定義されていることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The optional RxFlowControl component defines whether or not the LFB is performing flow control on receiving packets. The default value is 'false'. Note that this component is defined as an alias of the RxFlowControl component in the EtherMACIn LFB.",
      "ja": "任意RxFlowControl成分は、LFBがパケットを受信するとフロー制御を行っているか否かを定義します。デフォルト値は「false」です。この成分はEtherMACIn LFBでRxFlowControl成分の別名として定義されていることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "A struct component, MACOutStats, defines a set of statistics for this LFB, including the number of transmitted packets and the number of dropped packets. This statistics component is optional to implementers.",
      "ja": "構造体構成要素は、MACOutStatsは、送信されたパケットの数とドロップされたパケットの数を含む、このLFBの統計のセットを定義します。この統計コンポーネントは、実装者へのオプションです。"
    },
    {
      "indent": 0,
      "text": "5.1.5.3. Capabilities",
      "section_title": true,
      "ja": "5.1.5.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities.",
      "ja": "このLFBは、機能のリストを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.1.5.4. Events",
      "section_title": true,
      "ja": "5.1.5.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.2. IP Packet Validation LFBs",
      "section_title": true,
      "ja": "5.2。 IPパケットの検証LFBs"
    },
    {
      "indent": 3,
      "text": "The LFBs are defined to abstract the IP packet validation process. An IPv4Validator LFB is specifically for IPv4 protocol validation, and an IPv6Validator LFB is specifically for IPv6.",
      "ja": "LFBsは、抽象IPパケットの検証プロセスに定義されています。 IPv4Validator LFBは、IPv4プロトコルの検証のために特別であり、そしてIPv6Validator LFBは、IPv6のために特別です。"
    },
    {
      "indent": 0,
      "text": "5.2.1. IPv4Validator",
      "section_title": true,
      "ja": "5.2.1。 IPv4Validator"
    },
    {
      "indent": 3,
      "text": "The IPv4Validator LFB performs IPv4 packet validation.",
      "ja": "IPv4Validator LFBは、IPv4パケットの検証を行います。"
    },
    {
      "indent": 0,
      "text": "5.2.1.1. Data Handling",
      "section_title": true,
      "ja": "5.2.1.1。データ処理"
    },
    {
      "indent": 3,
      "text": "This LFB performs IPv4 validation according to [RFC1812] and its updates. The IPv4 packet will be output to the corresponding LFB port, indicating whether the packet is unicast or multicast or whether an exception has occurred or the validation failed.",
      "ja": "このLFBは[RFC1812]およびその更新に係るIPv4の検証を行います。 IPv4パケットは、パケットがユニキャストまたはマルチキャストまたは例外が発生したか、検証が失敗したかどうかを示す、対応するLFBポートに出力されます。"
    },
    {
      "indent": 3,
      "text": "This LFB always expects, as input, packets that have been indicated as IPv4 packets by an upstream LFB, like an EtherClassifier LFB. There is no specific metadata expected by the input of the LFB.",
      "ja": "このLFBは常に入力、EtherClassifier LFBように、上流LFBによって、IPv4パケットとして示されてきたパケットとして、期待します。 LFBの入力により期待される具体的なメタデータがありません。"
    },
    {
      "indent": 3,
      "text": "Four output LFB ports are defined.",
      "ja": "4つの出力LFBポートが定義されています。"
    },
    {
      "indent": 3,
      "text": "All validated IPv4 unicast packets will be output at the singleton port known as \"IPv4UnicastOut\". All validated IPv4 multicast packets will be output at the singleton port known as \"IPv4MulticastOut\" port.",
      "ja": "すべての検証済みのIPv4ユニキャストパケットは、「IPv4UnicastOut」として知られているシングルトンポートに出力されます。すべての検証済みのIPv4マルチキャストパケットは、「IPv4MulticastOut」ポートとして知られているシングルトンポートに出力されます。"
    },
    {
      "indent": 3,
      "text": "A singleton port known as \"ExceptionOut\" is defined to output packets that have been validated as exception packets. An exception ID metadata is produced to indicate what has caused the exception. An exception case is the case when a packet needs further processing before being normally forwarded. Currently defined exception types include:",
      "ja": "「ExceptionOut」として知られているシングルトンポートは例外パケットとして検証されている出力パケットに定義されています。例外IDメタデータは、例外を発生させたものを示すために作成されます。例外の場合は、パケットが正常に転送される前に、さらなる処理を必要とする場合です。現在、定義された例外タイプは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Packet with expired TTL",
      "ja": "期限切れのTTLを持つパケットO"
    },
    {
      "indent": 3,
      "text": "o Packet with header length more than 5 words",
      "ja": "ヘッダ長より5つのワードとOパケット"
    },
    {
      "indent": 3,
      "text": "o Packet IP head including router alert options",
      "ja": "Oルータアラートオプションを含むパケットのIPヘッド"
    },
    {
      "indent": 3,
      "text": "o Packet with exceptional source address",
      "ja": "例外的な送信元アドレスを持つOパケット"
    },
    {
      "indent": 3,
      "text": "o Packet with exceptional destination address",
      "ja": "例外宛先アドレスを持つOパケット"
    },
    {
      "indent": 3,
      "text": "Note that although Time to Live (TTL) is checked in this LFB for validity, operations like TTL decrement are made by the downstream forwarding LFB.",
      "ja": "時間は有効性のために、このLFBにチェックされている（TTL）をライブするものの、TTLの減少などの操作は、下流転送LFBによって行われていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The final singleton port known as \"FailOut\" is defined for all packets that have errors and failed the validation process. An error case is when a packet is unable to be further processed or forwarded without being dropped. An error ID is associated with a packet to indicate the failure reason. Currently defined failure reasons include:",
      "ja": "「FailOut」として知られ、最終的なシングルトンポートがエラーを持っているし、検証プロセスに失敗したすべてのパケットのために定義されています。パケットはさらに、ドロップされることなく処理または転送することができない場合にエラーケースです。エラーIDは失敗理由を示すために、パケットに関連付けられています。現在、定義された失敗の理由は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Packet with size reported less than 20 bytes",
      "ja": "Oサイズのパケットは、20バイト未満を報告しました"
    },
    {
      "indent": 3,
      "text": "o Packet with version not IPv4",
      "ja": "OバージョンとのパケットではないのIPv4"
    },
    {
      "indent": 3,
      "text": "o Packet with header length less than 5 words",
      "ja": "ヘッダー長が5つの未満の単語との入出力パケット"
    },
    {
      "indent": 3,
      "text": "o Packet with total length field less than 20 bytes",
      "ja": "O全長フィールドを有するパケット未満の20のバイト"
    },
    {
      "indent": 3,
      "text": "o Packet with invalid checksum",
      "ja": "無効なチェックサムを持つOパケット"
    },
    {
      "indent": 3,
      "text": "o Packet with invalid source address",
      "ja": "無効な送信元アドレスを持つOパケット"
    },
    {
      "indent": 3,
      "text": "o Packet with invalid destination address",
      "ja": "無効な宛先アドレスを持つOパケット"
    },
    {
      "indent": 0,
      "text": "5.2.1.2. Components",
      "section_title": true,
      "ja": "5.2.1.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "This LFB has only one struct component, the IPv4ValidatorStatisticsType, which defines a set of statistics for validation process, including the number of bad header packets, the number of bad total length packets, the number of bad TTL packets, and the number of bad checksum packets. This statistics component is optional to implementers.",
      "ja": "このLFB不良ヘッダーパケットの数、不良全長パケットの数、不良TTLパケットの数、および不正なチェックサムの数を含む検証プロセスの統計のセットを定義する唯一の構造体成分、IPv4ValidatorStatisticsTypeを有していますパケット。この統計コンポーネントは、実装者へのオプションです。"
    },
    {
      "indent": 0,
      "text": "5.2.1.3. Capabilities",
      "section_title": true,
      "ja": "5.2.1.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities",
      "ja": "このLFBは、機能のリストを持っていません"
    },
    {
      "indent": 0,
      "text": "5.2.1.4. Events",
      "section_title": true,
      "ja": "5.2.1.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.2.2. IPv6Validator",
      "section_title": true,
      "ja": "5.2.2。 IPv6の検証"
    },
    {
      "indent": 3,
      "text": "The IPv6Validator LFB performs IPv6 packet validation.",
      "ja": "IPv6Validator LFBは、IPv6パケットの検証を実行します。"
    },
    {
      "indent": 0,
      "text": "5.2.2.1. Data Handling",
      "section_title": true,
      "ja": "5.2.2.1。データ処理"
    },
    {
      "indent": 3,
      "text": "This LFB performs IPv6 validation according to [RFC2460] and its updates. Then the IPv6 packet will be output to the corresponding port regarding of the validation result, indicating whether the packet is a unicast or a multicast one, an exception has occurred or the validation failed.",
      "ja": "このLFBは[RFC2460]およびその更新に係るIPv6の検証を行います。次に、IPv6パケットは、パケットがユニキャストまたはマルチキャストのいずれか例外が発生したか検証が失敗したかどうかを示す、検証結果について、対応するポートに出力されます。"
    },
    {
      "indent": 3,
      "text": "This LFB always expects, as input, packets that have been indicated as IPv6 packets by an upstream LFB, like an EtherClassifier LFB. There is no specific metadata expected by the input of the LFB.",
      "ja": "このLFBは常に入力、EtherClassifier LFBように、上流LFBによってIPv6パケットとして示されてきたパケットとして、期待します。 LFBの入力により期待される具体的なメタデータがありません。"
    },
    {
      "indent": 3,
      "text": "Similar to the IPv4validator LFB, the IPv6Validator LFB has also defined four output ports to emit packets with various validation results.",
      "ja": "IPv4validator LFBと同様、IPv6Validator LFBはまた、様々な検証結果を持つパケットを放出するように4つの出力ポートを定義しています。"
    },
    {
      "indent": 3,
      "text": "All validated IPv6 unicast packets will be output at the singleton port known as \"IPv6UnicastOut\". All validated IPv6 multicast packets will be output at the singleton port known as \"IPv6MulticastOut\". There is no metadata produced at this LFB.",
      "ja": "すべての検証済みのIPv6ユニキャストパケットは、「IPv6UnicastOut」として知られているシングルトンポートに出力されます。すべての検証済みのIPv6マルチキャストパケットは、「IPv6MulticastOut」として知られているシングルトンポートに出力されます。このLFBで生産何らメタデータがありません。"
    },
    {
      "indent": 3,
      "text": "A singleton port known as \"ExceptionOut\" is defined to output packets that have been validated as exception packets. An exception case is when a packet needs further processing before being normally forwarded. An exception ID metadata is produced to indicate what caused the exception. Currently defined exception types include:",
      "ja": "「ExceptionOut」として知られているシングルトンポートは例外パケットとして検証されている出力パケットに定義されています。パケットが正常に転送される前に、さらなる処理を必要とするとき、例外ケースがあります。例外IDメタデータは、例外の原因を示すために作成されます。現在、定義された例外タイプは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Packet with hop limit to zero",
      "ja": "ゼロのホップ制限付きOパケット"
    },
    {
      "indent": 3,
      "text": "o Packet with next header set to hop-by-hop",
      "ja": "O次のヘッダを持つパケットは、ホップバイホップに設定します"
    },
    {
      "indent": 3,
      "text": "o Packet with exceptional source address",
      "ja": "例外的な送信元アドレスを持つOパケット"
    },
    {
      "indent": 3,
      "text": "o Packet with exceptional destination address",
      "ja": "例外宛先アドレスを持つOパケット"
    },
    {
      "indent": 3,
      "text": "The final singleton port known as \"FailOut\" is defined for all packets that have errors and failed the validation process. An error case when a packet is unable to be further processed or forwarded without being dropped. A validate error ID is associated to every failed packet to indicate the reason. Currently defined reasons include:",
      "ja": "「FailOut」として知られ、最終的なシングルトンポートがエラーを持っているし、検証プロセスに失敗したすべてのパケットのために定義されています。パケットができないエラーの場合は、さらに処理または削除されることなく転送されます。検証エラーIDは、その理由を示すために、すべて失敗したパケットに関連付けられています。現在、定義された理由は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Packet with size reported less than 40 bytes",
      "ja": "Oサイズのパケットは、40未満のバイトを報告し"
    },
    {
      "indent": 3,
      "text": "o Packet with version not IPv6",
      "ja": "OバージョンとのパケットではないのIPv6"
    },
    {
      "indent": 3,
      "text": "o Packet with invalid source address",
      "ja": "無効な送信元アドレスを持つOパケット"
    },
    {
      "indent": 3,
      "text": "o Packet with invalid destination address",
      "ja": "無効な宛先アドレスを持つOパケット"
    },
    {
      "indent": 3,
      "text": "Note that in the base type library, definitions for exception ID and validate error ID metadata are applied to both IPv4Validator and IPv6Validator LFBs, i.e., the two LFBs share the same metadata definition, with different ID assignment inside.",
      "ja": "IPv4ValidatorとIPv6Validator LFBsの両方に適用されているに、塩基型ライブラリ内なお例外IDの定義およびエラーIDメタデータを検証する、すなわち2つLFBs内部異なるIDの割り当てと、同じメタデータ定義を共有します。"
    },
    {
      "indent": 0,
      "text": "5.2.2.2. Components",
      "section_title": true,
      "ja": "5.2.2.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "This LFB has only one struct component, the IPv6ValidatorStatisticsType, which defines a set of statistics for the validation process, including the number of bad header packets, the number of bad total length packets, and the number of bad hop limit packets. Note that this component is optional to implementers.",
      "ja": "このLFBは、唯一の構造体成分、不良ヘッダーパケットの数、不良全長パケットの数、および不良ホップリミットパケットの数を含め、検証プロセスの統計のセットを定義IPv6ValidatorStatisticsTypeを有しています。このコンポーネントが実装にオプションであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.2.2.3. Capabilities",
      "section_title": true,
      "ja": "5.2.2.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities.",
      "ja": "このLFBは、機能のリストを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.2.2.4. Events",
      "section_title": true,
      "ja": "5.2.2.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.3. IP Forwarding LFBs",
      "section_title": true,
      "ja": "5.3。 IPフォワーディングLFBs"
    },
    {
      "indent": 3,
      "text": "IP Forwarding LFBs are specifically defined to abstract the IP forwarding processes. As definitions for a base LFB library, this document restricts its LFB definition scope only to IP unicast forwarding. IP multicast may be defined in future documents.",
      "ja": "IPフォワーディングLFBsは、特にIPフォワーディングプロセス抽象的に定義されています。ベースLFBライブラリの定義としては、このドキュメントでは、IPユニキャスト転送にそのLFB定義スコープを制限します。 IPマルチキャストは、将来の文書で定義されてもよいです。"
    },
    {
      "indent": 3,
      "text": "The two fundamental tasks performed in IP unicast forwarding constitute looking up the forwarding information table to find next-hop information and then using the resulting next-hop details to forward packets out on specific physical output ports. This document models the forwarding processes by abstracting out the described two steps. Whereas this document describes functional LFB models that are modular, there may be multiple ways to implement the abstracted models. It is not intended or expected that the provided LFB models constrain implementations.",
      "ja": "IPユニキャスト転送で行う二つの基本的なタスクは、次ホップの情報を見つけるために、転送情報テーブルを検索し、次に特定の物理出力ポートにパケットを転送するために、得られたネクストホップの詳細を使用して構成します。この文書モデル説明した2つの段階を抽象化することにより、転送プロセス。この文書はモジュール化された機能LFBモデルを記述に対し、抽象化モデルを実装するための複数の方法があるかもしれません。これは、意図または提供LFBモデルが実装を制約することが期待されていません。"
    },
    {
      "indent": 3,
      "text": "Based on the IP forwarding abstraction, two kinds of typical IP unicast forwarding LFBs are defined: unicast LPM lookup LFB and next-hop application LFB. They are further distinguished by IPv4 and IPv6 protocols.",
      "ja": "IPフォワーディング抽象化に基づいて、一般的なIPユニキャスト転送LFBsの二種類が定義されているユニキャストLPMルックアップLFBとネクストホップアプリケーションLFB。彼らはさらに、IPv4とIPv6のプロトコルによって区別されます。"
    },
    {
      "indent": 0,
      "text": "5.3.1. IPv4UcastLPM",
      "section_title": true,
      "ja": "5.3.1。 IPv4UcastLPM"
    },
    {
      "indent": 3,
      "text": "The IPv4UcastLPM LFB abstracts the IPv4 unicast Longest Prefix Match (LPM) process.",
      "ja": "IPv4UcastLPM LFBは、IPv4ユニキャスト最長プレフィックスマッチ（LPM）プロセスを抽象化します。"
    },
    {
      "indent": 3,
      "text": "This LFB also provides facilities to support users to implement equal-cost multipath (ECMP) routing or reverse path forwarding (RPF). However, this LFB itself does not provide ECMP or RPF. To fully implement ECMP or RPF, additional specific LFBs, like a specific ECMP LFB or an RPF LFB, will have to be defined.",
      "ja": "このLFBはまた、等コストマルチパス（ECMP）ルーティングまたは逆方向パス転送（RPF）を実装するユーザをサポートする機能を提供します。しかし、このLFB自体はECMPまたはRPFを提供していません。完全ECMPまたはRPFを実装するには、特定のECMP LFBまたはRPF LFBのような追加の具体的なLFBsは、定義する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.1.1. Data Handling",
      "section_title": true,
      "ja": "5.3.1.1。データ処理"
    },
    {
      "indent": 3,
      "text": "This LFB performs the IPv4 unicast LPM table lookup. It always expects as input IPv4 unicast packets from one singleton input known as \"PktsIn\". Then, the LFB uses the destination IPv4 address of every packet as a search key to look up the IPv4 prefix table and generate a hop selector as the matching result. The hop selector is passed as packet metadata to downstream LFBs and will usually be used there as a search index to find more next-hop information.",
      "ja": "このLFBは、IPv4ユニキャストLPMテーブルルックアップを行います。それは常に「PktsIn」として知られている1つのシングルトン入力から入力IPv4ユニキャストパケットとして期待します。次に、LFBは、IPv4プリフィックス・テーブルを検索し、マッチング結果としてホップセレクタを生成する検索キーとしてすべてのパケットの宛先IPv4アドレスを使用します。ホップのセレクタは、下流LFBsへのパケットメタデータとして渡され、通常より多くのネクストホップ情報を見つけるための検索インデックスとしても使用されます。"
    },
    {
      "indent": 3,
      "text": "Three singleton output LFB ports are defined.",
      "ja": "三個のシングルトン出力LFBポートが定義されています。"
    },
    {
      "indent": 3,
      "text": "The first singleton output is known as \"NormalOut\" and outputs IPv4 unicast packets that succeed the LPM lookup (and got a hop selector). The hop selector is associated with the packet as a metadata. Downstream from the LPM LFB is usually a next-hop application LFB, like an IPv4NextHop LFB.",
      "ja": "最初シングルトン出力は「NormalOut」として知られており、LPMルックアップを成功（及びホップセレクタを持って）IPv4ユニキャストパケットを出力します。ホップセレクタは、メタデータとしてパケットに関連付けられています。 LPM LFBから下流は、通常IPv4NextHop LFB等ネクストホップアプリケーションLFB、です。"
    },
    {
      "indent": 3,
      "text": "The second singleton output is known as \"ECMPOut\" and is defined to provide support for users wishing to implement ECMP.",
      "ja": "二シングルトンの出力は、「ECMPOut」として知られており、ECMPを実施したいユーザーのためのサポートを提供するために定義されています。"
    },
    {
      "indent": 3,
      "text": "An ECMP flag is defined in the LPM table to enable the LFB to support ECMP. When a table entry is created with the flag set to true, it indicates this table entry is for ECMP only. A packet that has passed through this prefix lookup will always output from the \"ECMPOut\" output port, with the hop selector being its lookup result. The output will usually go directly to a downstream ECMP processing",
      "ja": "ECMPフラグがECMPをサポートするために、LFBを可能にするために、LPMテーブルで定義されています。テーブルエントリがtrueに設定されたフラグを使用して作成された場合は、このテーブルのエントリが唯一のECMPのためであることを示します。このプレフィックス検索を通過したパケット意志ホップセレクタは、その検索結果であると「ECMPOut」出力ポートから常に出力、。出力は通常、下流のECMP処理に直接移動します"
    },
    {
      "indent": 3,
      "text": "LFB, where the hop selector can usually further generate optimized one or multiple next-hop routes by use of ECMP algorithms.",
      "ja": "ホップセレクタは通常さらにECMPアルゴリズムを使用することによって一つまたは複数のネクストホップルートを最適化された生成することができるLFB、。"
    },
    {
      "indent": 3,
      "text": "A default route flag is defined in the LPM table to enable the LFB to support a default route as well as loose RPF. When this flag is set to true, the table entry is identified as a default route, which also implies that the route is forbidden for RPF. If a user wants to implement RPF on FE, a specific RPF LFB will have to be defined. In such an RPF LFB, a component can be defined as an alias of the prefix table component of this LFB, as described below.",
      "ja": "デフォルトルートフラグはデフォルトルート、並びにルーズRPFをサポートするためのLFBを可能にするために、LPMテーブルで定義されています。このフラグがtrueに設定されている場合、テーブルエントリはまた、ルートがRPFのために禁止されていることを意味するデフォルトルートとして識別されます。ユーザーはFEにRPFを実装したい場合は、特定のRPF LFBを定義する必要があります。以下のようなRPF LFBで、コンポーネントは、このLFBのプリフィックス・テーブル・コンポーネントのエイリアスとして定義することができます。"
    },
    {
      "indent": 3,
      "text": "The final singleton output is known as \"ExceptionOut\" of the IPv4UcastLPM LFB and is defined to output exception packets after the LFB processing, along with an ExceptionID metadata to indicate what caused the exception. Currently defined exception types include:",
      "ja": "最終的なシングルトン出力はIPv4UcastLPM LFBの「ExceptionOut」として知られており、例外の原因を示すためExceptionIDメタデータとともに、LFB処理後の出力例外パケットに定義されています。現在、定義された例外タイプは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The packet failed the LPM lookup of the prefix table.",
      "ja": "Oパケットは、プリフィックステーブルのLPMのルックアップに失敗しました。"
    },
    {
      "indent": 3,
      "text": "The upstream LFB of this LFB is usually an IPv4Validator LFB. If RPF is to be adopted, the upstream can be an RPF LFB, when defined.",
      "ja": "このLFBの上流LFBは通常IPv4Validator LFBです。 RPFを採用する場合に定義したとき、上流側は、RPF LFBすることができます。"
    },
    {
      "indent": 3,
      "text": "The downstream LFB is usually an IPv4NextHop LFB. If ECMP is adopted, the downstream can be an ECMP LFB, when defined.",
      "ja": "下流LFBは通常IPv4NextHop LFBです。 ECMPを採用した場合定義したとき、下流は、ECMP LFBすることができます。"
    },
    {
      "indent": 0,
      "text": "5.3.1.2. Components",
      "section_title": true,
      "ja": "5.3.1.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "This LFB has two components.",
      "ja": "このLFBは、2つのコンポーネントがあります。"
    },
    {
      "indent": 3,
      "text": "The IPv4PrefixTable component is defined as an array component of the LFB. Each row of the array contains an IPv4 address, a prefix length, a hop selector, an ECMP flag and a default route flag. The LFB uses the destination IPv4 address of every input packet as a search key to look up this table in order extract a next-hop selector. The ECMP flag is for the LFB to support ECMP. The default route flag is for the LFB to support a default route and for loose RPF.",
      "ja": "IPv4PrefixTable成分は、LFBの配列要素として定義されます。配列の各行は、IPv4アドレス、プレフィックス長、ホップセレクタ、ECMPフラグとデフォルトルートフラグを含んでいます。 LFBは、ネクストホップセレクタを取り出すためにこのテーブルを検索するための検索キーとしてすべての入力パケットの宛先IPv4アドレスを使用します。 LFBはECMPをサポートするためECMPフラグがあります。 LFBは、デフォルトルートと緩いRPFのためをサポートするためにデフォルトルートのフラグがあります。"
    },
    {
      "indent": 3,
      "text": "The IPv4UcastLPMStats component is a struct component that collects statistics information, including the total number of input packets received, the IPv4 packets forwarded by this LFB, and the number of IP datagrams discarded due to no route found. Note that this component is defined as optional to implementers.",
      "ja": "IPv4UcastLPMStats成分は、受信した入力パケットの合計数、このLFBによって転送IPv4パケット、及び見つかりませ経路が原因で廃棄されたIPデータグラムの数などの統計情報を、収集構造体の構成要素です。このコンポーネントは、実装にオプションとして定義されていることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "5.3.1.3. Capabilities",
      "section_title": true,
      "ja": "5.3.1.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities.",
      "ja": "このLFBは、機能のリストを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.3.1.4. Events",
      "section_title": true,
      "ja": "5.3.1.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.3.2. IPv4NextHop",
      "section_title": true,
      "ja": "5.3.2。 IPv4NextHop"
    },
    {
      "indent": 3,
      "text": "This LFB abstracts the process of selecting IPv4 next-hop action.",
      "ja": "このLFBは、IPv4ネクストホップアクションを選択するプロセスを抽象化します。"
    },
    {
      "indent": 0,
      "text": "5.3.2.1. Data Handling",
      "section_title": true,
      "ja": "5.3.2.1。データ処理"
    },
    {
      "indent": 3,
      "text": "The LFB abstracts the process of next-hop information application to IPv4 packets. It receives an IPv4 packet with an associated next-hop identifier (HopSelector) and uses the identifier as a table index to look up a next-hop table to find an appropriate LFB output port.",
      "ja": "LFBは、IPv4パケットの次のホップ情報アプリケーションのプロセスを抽象化。これは、関連する次ホップ識別子（HopSelector）でIPv4パケットを受信し、適切なLFB出力ポートを見つけるために次ホップテーブルをルックアップテーブルのインデックスとして識別子を使用します。"
    },
    {
      "indent": 3,
      "text": "The LFB is expected to receive unicast IPv4 packets, via a singleton input known as \"PktsIn\", along with a HopSelector metadata, which is used as a table index to look up the NextHop table. The data processing involves the forwarding TTL decrement and IP checksum recalculation.",
      "ja": "LFBは、ネクストホップテーブルをルックアップテーブルのインデックスとして使用されるHopSelectorメタデータと共に、「PktsIn」として知られているシングルトン入力を介して、ユニキャストIPv4パケットを受信することが期待されます。データ処理は、転送TTLの減少とIPチェックサムの再計算を必要とします。"
    },
    {
      "indent": 3,
      "text": "Two output LFB ports are defined.",
      "ja": "二つの出力LFBポートが定義されています。"
    },
    {
      "indent": 3,
      "text": "The first output is a group output port known as \"SuccessOut\". On successful data processing, the packet is sent out from an LFB port from within the LFB port group as selected by the LFBOutputSelectIndex value of the matched table entry. The packet is sent to a downstream LFB along with the L3PortID and MediaEncapInfoIndex metadata.",
      "ja": "第1の出力は「SuccessOut」として知られているグループの出力ポートです。成功したデータの処理に、パケットが一致したテーブルエントリのLFBOutputSelectIndex値によって選択さLFBポートグループからLFBポートから送出されます。パケットはL3PortIDとMediaEncapInfoIndexメタデータとともに下流LFBに送信されます。"
    },
    {
      "indent": 3,
      "text": "The second output is a singleton output port known as \"ExceptionOut\", which will output packets for which the data processing failed, along with an additional ExceptionID metadata to indicate what caused the exception. Currently defined exception types include:",
      "ja": "第2の出力は、出力パケットがそのためのデータ処理は、例外の原因を示すために、追加のExceptionIDメタデータと一緒に、失敗します「ExceptionOut」として知られているシングルトン出力ポートです。現在、定義された例外タイプは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The HopSelector for the packet is invalid.",
      "ja": "OパケットのHopSelectorが無効です。"
    },
    {
      "indent": 3,
      "text": "o The packet failed lookup of the next-hop table even though the HopSelector is valid.",
      "ja": "OパケットがHopSelectorが有効であるにもかかわらず、ネクストホップテーブルの検索に失敗しました。"
    },
    {
      "indent": 3,
      "text": "o The MTU for outgoing interface is less than the packet size.",
      "ja": "O発信インターフェースのMTUは、パケットサイズよりも小さいです。"
    },
    {
      "indent": 3,
      "text": "Downstream LFB instances could be either a BasicMetadataDispatch type (Section 5.5.1), used to fan out to different LFB instances or a media-encapsulation-related type, such as an EtherEncap type or a RedirectOut type (Section 5.4.2). For example, if there are Ethernet and other tunnel encapsulation, then a BasicMetadataDispatch LFB can use the L3PortID metadata (Section 5.3.2.2) to dispatch packets to a different encapsulator.",
      "ja": "下流LFBインスタンスは、EtherEncap型又はRedirectOutタイプ（セクション5.4.2）のような異なるLFBインスタンスまたはメディアカプセル関連型、にファンアウトするために使用されるBasicMetadataDispatchタイプ（セクション5.5.1）のいずれかとすることができます。イーサネット（登録商標）及び他のトンネルカプセル化がある場合、例えば、次にBasicMetadataDispatch LFBは異なるカプセル化にパケットをディスパッチするL3PortIDメタデータ（セクション5.3.2.2）を使用することができます。"
    },
    {
      "indent": 0,
      "text": "5.3.2.2. Components",
      "section_title": true,
      "ja": "5.3.2.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "This LFB has only one component, IPv4NextHopTable, which is defined as an array. The HopSelector received is used to match the array index of IPv4NextHopTable to find out a row of the table as the next-hop information result. Each row of the array is a struct containing:",
      "ja": "このLFBは配列として定義されている唯一の成分、IPv4NextHopTableを有しています。受信HopSelectorは、ネクストホップ情報の結果として、テーブルの行を見つけるためにIPv4NextHopTableの配列インデックスを一致させるために使用されます。アレイの各行が含む構造体です。"
    },
    {
      "indent": 3,
      "text": "o The L3PortID, which is the ID of the logical output port that is passed on to the downstream LFB instance. This ID indicates what kind of encapsulating port the neighbor is to use. This is L3- derived information that affects L2 processing and so needs to be based from one LFB to another as metadata. Usually, this ID is used for the next-hop LFB to distinguish packets that need different L2 encapsulating. For instance, some packets may require general Ethernet encapsulation while others may require various types of tunnel encapsulations. In such a case, different L3PortIDs are assigned to the packets and are passed as metadata to a downstream LFB. A BasicMetadataDispatch LFB (Section 5.5.1) may have to be applied as the downstream LFB so as to dispatch packets to different encapsulation LFB instances according to the L3PortIDs.",
      "ja": "下流LFBインスタンスに渡され、論理出力ポートのIDであるL3PortID、O。このIDは、ネイバーが使用するポートをカプセル化の種類を示します。これは、L2処理に影響を与えるので、メタデータとして別のLFBに基づいする必要L3-導き出された情報です。通常、このIDは異なるL2の封入を必要とするパケットを区別するために、次ホップLFBのために使用されます。他のものは、トンネルカプセル化の様々なタイプを必要とするかもしれないが、例えば、いくつかのパケットは、一般的なイーサネットカプセル化を必要とするかもしれません。このような場合には、異なるL3PortIDsは、パケットに割り当てられ、下流LFBにメタデータとして渡されます。 BasicMetadataDispatch LFB（セクション5.5.1）L3PortIDsに応じて異なる封入LFBインスタンスにパケットをディスパッチするように下流LFBとして適用しなければならないかもしれません。"
    },
    {
      "indent": 3,
      "text": "o MTU, the Maximum Transmission Unit for the outgoing port.",
      "ja": "O MTU、発信ポートの最大伝送ユニット。"
    },
    {
      "indent": 3,
      "text": "o NextHopIPAddr, the IPv4 next-hop address.",
      "ja": "O NextHopIPAddr、IPv4のネクストホップアドレス。"
    },
    {
      "indent": 3,
      "text": "o MediaEncapInfoIndex, the index that passes on to the downstream encapsulation LFB instance and that is used there as a search key to look up a table (typically media-encapsulation-related) for further encapsulation information. The search key looks up the table by matching the table index. Note that the encapsulation LFB instance that uses this metadata may not be the LFB instance that immediately follows this LFB instance in the processing. The MediaEncapInfoIndex metadata is attached here and is passed through intermediate LFBs until it is used by the encapsulation LFB instance. In some cases, depending on implementation, the CE may set the MediaEncapInfoIndex passed downstream to a value that will fail lookup when it gets to a target encapsulation LFB; such a lookup failure at that point is an indication that further resolution is needed. For an example of this approach, refer to Section 7.2, which discusses ARP and mentions this approach.",
      "ja": "O MediaEncapInfoIndex、下流カプセルLFBインスタンスに渡し、それをさらにカプセル化については、（典型的には、メディアカプセル化関連）テーブルを検索する検索キーとして用いているインデックス。検索キーは、テーブルインデックスを照合することによって、テーブルを検索します。このメタデータを使用してカプセル化LFBインスタンスは直ちに処理のこのLFBインスタンスを以下LFBインスタンスでなくてもよいことに留意されたいです。 MediaEncapInfoIndexメタデータはここに添付され、それがカプセル化LFBインスタンスによって使用されるまで、中間LFBs通過させます。いくつかのケースでは、実装によっては、CEはMediaEncapInfoIndexは、それが目的のカプセル化LFBになったときに、ルックアップに失敗する値に下流渡さ設定することもできます。その時点でそのようなルックアップ失敗がさらに解像度が必要であることを示しています。このアプローチの例は、ARPを説明し、このアプローチを言及セクション7.2を参照。"
    },
    {
      "indent": 3,
      "text": "o LFBOutputSelectIndex, the LFB group output port index to select the downstream LFB port. This value identifies the specific port within the SuccessOut port group out of which packets that successfully use this next-hop entry are to be sent.",
      "ja": "O LFBOutputSelectIndex、下流LFBポートを選択するためのLFBグループ出力ポートインデックス。この値は、正常にこのネクストホップエントリを使用してパケットが送信されるべき外SuccessOutポートグループ内の特定のポートを識別する。"
    },
    {
      "indent": 0,
      "text": "5.3.2.3. Capabilities",
      "section_title": true,
      "ja": "5.3.2.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities.",
      "ja": "このLFBは、機能のリストを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.3.2.4. Events",
      "section_title": true,
      "ja": "5.3.2.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.3.3. IPv6UcastLPM",
      "section_title": true,
      "ja": "5.3.3。 IPv6UcastLPM"
    },
    {
      "indent": 3,
      "text": "The IPv6UcastLPM LFB abstracts the IPv6 unicast Longest Prefix Match (LPM) process. The definition of this LFB is similar to the IPv4UcastLPM LFB except that all IP addresses refer to IPv6 addresses.",
      "ja": "IPv6UcastLPM LFBは、IPv6ユニキャスト最長プレフィックスマッチ（LPM）プロセスを抽象化します。このLFBの定義は、すべてのIPアドレスは、IPv6アドレスを参照することを除いてIPv4UcastLPM LFBに似ています。"
    },
    {
      "indent": 3,
      "text": "This LFB also provides facilities to support users to implement equal-cost multipath (ECMP) routing or reverse path forwarding (RPF). However, this LFB itself does not provide ECMP or RPF. To fully implement ECMP or RPF, additional specific LFBs, like a specific ECMP LFB or an RPF LFB, will have to be defined. This work may be done in future versions of this document.",
      "ja": "このLFBはまた、等コストマルチパス（ECMP）ルーティングまたは逆方向パス転送（RPF）を実装するユーザをサポートする機能を提供します。しかし、このLFB自体はECMPまたはRPFを提供していません。完全ECMPまたはRPFを実装するには、特定のECMP LFBまたはRPF LFBのような追加の具体的なLFBsは、定義する必要があります。この作品は、このドキュメントの将来のバージョンで行うことができます。"
    },
    {
      "indent": 0,
      "text": "5.3.3.1. Data Handling",
      "section_title": true,
      "ja": "5.3.3.1。データ処理"
    },
    {
      "indent": 3,
      "text": "This LFB performs the IPv6 unicast LPM table lookup. It always expects as input IPv6 unicast packets from one singleton input known as \"PktsIn\". The destination IPv6 address of an incoming packet is used as a search key to look up the IPv6 prefix table and generate a hop selector. This hop selector result is associated to the packet as a metadata and sent to downstream LFBs; it will usually be used in downstream LFBs as a search key to find more next-hop information.",
      "ja": "このLFBは、IPv6ユニキャストLPMテーブルの検索を実行します。それは、常に「PktsIn」として知られている1つのシングルトンの入力から入力IPv6ユニキャストパケットとして期待しています。着信パケットの宛先IPv6アドレスは、IPv6プレフィックステーブルを検索し、ホップのセレクタを生成するための検索キーとして使用されています。このホップセレクタ結果は、メタデータとしてパケットに関連付けられ、下流LFBsに送られます。通常より多くのネクストホップ情報を見つけるための検索キーとして、下流LFBsに使用されます。"
    },
    {
      "indent": 3,
      "text": "Three singleton output LFB ports are defined.",
      "ja": "三個のシングルトン出力LFBポートが定義されています。"
    },
    {
      "indent": 3,
      "text": "The first singleton output is known as \"NormalOut\" and outputs IPv6 unicast packets that succeed the LPM lookup (and got a hop selector). The hop selector is associated with the packet as a metadata. Downstream from the LPM LFB is usually a next-hop application LFB, like an IPv6NextHop LFB.",
      "ja": "最初シングルトン出力は「NormalOut」として知られており、LPMルックアップを成功（及びホップセレクタを持って）IPv6ユニキャストパケットを出力します。ホップセレクタは、メタデータとしてパケットに関連付けられています。 LPM LFBから下流は、通常IPv6NextHop LFB等ネクストホップアプリケーションLFB、です。"
    },
    {
      "indent": 3,
      "text": "The second singleton output is known as \"ECMPOut\" and is defined to provide support for users wishing to implement ECMP.",
      "ja": "二シングルトンの出力は、「ECMPOut」として知られており、ECMPを実施したいユーザーのためのサポートを提供するために定義されています。"
    },
    {
      "indent": 3,
      "text": "An ECMP flag is defined in the LPM table to enable the LFB to support ECMP. When a table entry is created with the flag set to true, it indicates this table entry is for ECMP only. A packet that has passed through this prefix lookup will always output from the \"ECMPOut\" output port, with the hop selector being its lookup result. The output will usually go directly to a downstream ECMP processing LFB, where the hop selector can usually further generate optimized one or multiple next-hop routes by use of ECMP algorithms.",
      "ja": "ECMPフラグがECMPをサポートするために、LFBを可能にするために、LPMテーブルで定義されています。テーブルエントリがtrueに設定されたフラグを使用して作成された場合は、このテーブルのエントリが唯一のECMPのためであることを示します。このプレフィックス検索を通過したパケット意志ホップセレクタは、その検索結果であると「ECMPOut」出力ポートから常に出力、。出力は、通常、ホップセレクタは通常さらにECMPアルゴリズムの使用により、一又は複数のネクストホップルートを最適化された生成することができ、下流ECMP処理LFBに直接行きます。"
    },
    {
      "indent": 3,
      "text": "A default route flag is defined in the LPM table to enable the LFB to support a default route as well as loose RPF. When this flag is set to true, the table entry is identified as a default route, which also implies that the route is forbidden for RPF.",
      "ja": "デフォルトルートフラグはデフォルトルート、並びにルーズRPFをサポートするためのLFBを可能にするために、LPMテーブルで定義されています。このフラグがtrueに設定されている場合、テーブルエントリはまた、ルートがRPFのために禁止されていることを意味するデフォルトルートとして識別されます。"
    },
    {
      "indent": 3,
      "text": "If a user wants to implement RPF on FE, a specific RPF LFB will have to be defined. In such an RPF LFB, a component can be defined as an alias of the prefix table component of this LFB, as described below.",
      "ja": "ユーザーはFEにRPFを実装したい場合は、特定のRPF LFBを定義する必要があります。以下のようなRPF LFBで、コンポーネントは、このLFBのプリフィックス・テーブル・コンポーネントのエイリアスとして定義することができます。"
    },
    {
      "indent": 3,
      "text": "The final singleton output is known as \"ExceptionOut\" of the IPv6UcastLPM LFB and is defined to output exception packets after the LFB processing, along with an ExceptionID metadata to indicate what caused the exception. Currently defined exception types include:",
      "ja": "最終的なシングルトン出力はIPv6UcastLPM LFBの「ExceptionOut」として知られており、例外の原因を示すためExceptionIDメタデータとともに、LFB処理後の出力例外パケットに定義されています。現在、定義された例外タイプは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The packet failed the LPM lookup of the prefix table.",
      "ja": "Oパケットは、プリフィックステーブルのLPMのルックアップに失敗しました。"
    },
    {
      "indent": 3,
      "text": "The upstream LFB of this LFB is usually an IPv6Validator LFB. If RPF is to be adopted, the upstream can be an RPF LFB, when defined.",
      "ja": "このLFBの上流LFBは通常IPv6Validator LFBです。 RPFを採用する場合に定義したとき、上流側は、RPF LFBすることができます。"
    },
    {
      "indent": 3,
      "text": "The downstream LFB is usually an IPv6NextHop LFB. If ECMP is adopted, the downstream can be an ECMP LFB, when defined.",
      "ja": "下流LFBは通常IPv6NextHop LFBです。 ECMPを採用した場合定義したとき、下流は、ECMP LFBすることができます。"
    },
    {
      "indent": 0,
      "text": "5.3.3.2. Components",
      "section_title": true,
      "ja": "5.3.3.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "This LFB has two components.",
      "ja": "このLFBは、2つのコンポーネントがあります。"
    },
    {
      "indent": 3,
      "text": "The IPv6PrefixTable component is defined as an array component of the LFB. Each row of the array contains an IPv6 address, a prefix length, a hop selector, an ECMP flag, and a default route flag. The ECMP flag is so the LFB can support ECMP. The default route flag is for the LFB to support a default route and for loose RPF, as described earlier.",
      "ja": "IPv6PrefixTable成分は、LFBの配列要素として定義されます。配列の各行は、IPv6アドレス、プレフィックス長、ホップセレクタ、ECMPフラグ、およびデフォルトルートのフラグが含ま。 ECMPフラグは、LFBがECMPをサポートすることができそうです。前述したようにLFBは、デフォルトルートと緩いRPFのためをサポートするためのデフォルトルートフラグです。"
    },
    {
      "indent": 3,
      "text": "The IPv6UcastLPMStats component is a struct component that collects statistics information, including the total number of input packets received, the IPv6 packets forwarded by this LFB and the number of IP datagrams discarded due to no route found. Note that the component is defined as optional to implementers.",
      "ja": "IPv6UcastLPMStats成分は、受信した入力パケットの合計数、このLFBと見つかりませんでした経路が原因で廃棄されたIPデータグラムの数で転送されたIPv6パケットを含む統計情報を、収集構造体の構成要素です。コンポーネントが実装するオプションとして定義されていることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "5.3.3.3. Capabilities",
      "section_title": true,
      "ja": "5.3.3.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities.",
      "ja": "このLFBは、機能のリストを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.3.3.4. Events",
      "section_title": true,
      "ja": "5.3.3.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.3.4. IPv6NextHop",
      "section_title": true,
      "ja": "5.3.4。 IPv6NextHop"
    },
    {
      "indent": 3,
      "text": "This LFB abstracts the process of selecting IPv6 next-hop action.",
      "ja": "このLFBは、IPv6ネクストホップアクションを選択するプロセスを抽象化します。"
    },
    {
      "indent": 0,
      "text": "5.3.4.1. Data Handling",
      "section_title": true,
      "ja": "5.3.4.1。データ処理"
    },
    {
      "indent": 3,
      "text": "The LFB abstracts the process of next-hop information application to IPv6 packets. It receives an IPv6 packet with an associated next-hop identifier (HopSelector) and uses the identifier to look up a next-hop table to find an appropriate output port from the LFB.",
      "ja": "LFBは、IPv6パケットを次ホップの情報アプリケーションのプロセスを抽象化。これは、関連する次ホップ識別子（HopSelector）とIPv6パケットを受信し、LFBから適切な出力ポートを見つけるために次ホップテーブルをルックアップするために識別子を使用します。"
    },
    {
      "indent": 3,
      "text": "The LFB is expected to receive unicast IPv6 packets, via a singleton input known as \"PktsIn\", along with a HopSelector metadata, which is used as a table index to look up the next-hop table.",
      "ja": "LFBは、ネクストホップテーブルをルックアップテーブルのインデックスとして使用されるHopSelectorメタデータと共に、「PktsIn」として知られているシングルトン入力を介して、ユニキャストIPv6パケットを受信することが期待されます。"
    },
    {
      "indent": 3,
      "text": "Two output LFB ports are defined.",
      "ja": "二つの出力LFBポートが定義されています。"
    },
    {
      "indent": 3,
      "text": "The first output is a group output port known as \"SuccessOut\". On successful data processing, the packet is sent out from an LFB port from within the LFB port group as selected by the LFBOutputSelectIndex value of the matched table entry. The packet is sent to a downstream LFB along with the L3PortID and MediaEncapInfoIndex metadata.",
      "ja": "第1の出力は「SuccessOut」として知られているグループの出力ポートです。成功したデータの処理に、パケットが一致したテーブルエントリのLFBOutputSelectIndex値によって選択さLFBポートグループからLFBポートから送出されます。パケットはL3PortIDとMediaEncapInfoIndexメタデータとともに下流LFBに送信されます。"
    },
    {
      "indent": 3,
      "text": "The second output is a singleton output port known as \"ExceptionOut\", which will output packets for which the data processing failed, along with an additional ExceptionID metadata to indicate what caused the exception. Currently defined exception types include:",
      "ja": "第2の出力は、出力パケットがそのためのデータ処理は、例外の原因を示すために、追加のExceptionIDメタデータと一緒に、失敗します「ExceptionOut」として知られているシングルトン出力ポートです。現在、定義された例外タイプは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The HopSelector for the packet is invalid.",
      "ja": "OパケットのHopSelectorが無効です。"
    },
    {
      "indent": 3,
      "text": "o The packet failed lookup of the next-hop table even though the HopSelector is valid.",
      "ja": "OパケットがHopSelectorが有効であるにもかかわらず、ネクストホップテーブルの検索に失敗しました。"
    },
    {
      "indent": 3,
      "text": "o The MTU for outgoing interface is less than the packet size.",
      "ja": "O発信インターフェースのMTUは、パケットサイズよりも小さいです。"
    },
    {
      "indent": 3,
      "text": "Downstream LFB instances could be either a BasicMetadataDispatch type, used to fan out to different LFB instances, or a media encapsulation related type, such as an EtherEncap type or a RedirectOut type. For example, when the downstream LFB is",
      "ja": "下流LFBインスタンスは、EtherEncap型又はRedirectOut型として、異なるLFBインスタンスへファンアウトするために使用されるBasicMetadataDispatch型、またはメディアのカプセル化に関連する型のいずれであってもよいです。例えば、下流LFBであります"
    },
    {
      "indent": 3,
      "text": "BasicMetadataDispatch and Ethernet and other tunnel encapsulation exist downstream from BasicMetadataDispatch, then the BasicMetadataDispatch LFB can use the L3PortID metadata (see section below) to dispatch packets to the different encapsulator LFBs.",
      "ja": "BasicMetadataDispatchイーサネット及び他のトンネルカプセル化がBasicMetadataDispatchから下流に存在し、その後BasicMetadataDispatch LFBは異なるカプセル化のLFBsにパケットをディスパッチする（下記を参照）L3PortIDメタデータを使用することができます。"
    },
    {
      "indent": 0,
      "text": "5.3.4.2. Components",
      "section_title": true,
      "ja": "5.3.4.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "This LFB has only one component named IPv6NextHopTable, which is defined as an array. The array index of IPv6NextHopTable is used for a HopSelector to find out a row of the table as the next-hop information. Each row of the array is a struct containing:",
      "ja": "このLFBは配列として定義されるIPv6NextHopTable名前だけつの成分を有しています。 IPv6NextHopTableの配列インデックスは、次ホップ情報としてテーブルの行を見つけるためにHopSelectorために使用されます。アレイの各行が含む構造体です。"
    },
    {
      "indent": 3,
      "text": "o The L3PortID, which is the ID of the logical output port that is passed onto the downstream LFB instance. This ID indicates what kind of encapsulating port the neighbor is to use. This is L3- derived information that affects L2 processing and so needs to be based from one LFB to another as metadata. Usually, this ID is used for the next-hop LFB to distinguish packets that need different L2 encapsulating. For instance, some packets may require general Ethernet encapsulation while others may require various types of tunnel encapsulations. In such a case, different L3PortIDs are assigned to the packets and are passed as metadata to a downstream LFB. A BasicMetadataDispatch LFB (Section 5.5.1) may have to be applied as the downstream LFB so as to dispatch packets to different encapsulation LFB instances according to the L3PortIDs.",
      "ja": "下流LFBインスタンスに渡される論理出力ポートのIDであるL3PortID、O。このIDは、ネイバーが使用するポートをカプセル化の種類を示します。これは、L2処理に影響を与えるので、メタデータとして別のLFBに基づいする必要L3-導き出された情報です。通常、このIDは異なるL2の封入を必要とするパケットを区別するために、次ホップLFBのために使用されます。他のものは、トンネルカプセル化の様々なタイプを必要とするかもしれないが、例えば、いくつかのパケットは、一般的なイーサネットカプセル化を必要とするかもしれません。このような場合には、異なるL3PortIDsは、パケットに割り当てられ、下流LFBにメタデータとして渡されます。 BasicMetadataDispatch LFB（セクション5.5.1）L3PortIDsに応じて異なる封入LFBインスタンスにパケットをディスパッチするように下流LFBとして適用しなければならないかもしれません。"
    },
    {
      "indent": 3,
      "text": "o MTU, the Maximum Transmission Unit for the outgoing port.",
      "ja": "O MTU、発信ポートの最大伝送ユニット。"
    },
    {
      "indent": 3,
      "text": "o NextHopIPAddr, the IPv6 next-hop address.",
      "ja": "O NextHopIPAddr、IPv6のネクストホップアドレス。"
    },
    {
      "indent": 3,
      "text": "o MediaEncapInfoIndex, the index that is passed on to the downstream encapsulation LFB instance and that is used there as a search key to look up a table (typically media-encapsulation-related) for further encapsulation information. The search key looks up the table by matching the table index. Note that the encapsulation LFB instance that uses this metadata may not be the LFB instance that immediately follows this LFB instance in the processing. The MediaEncapInfoIndex metadata is attached here and is passed through intermediate LFBs until it is used by the encapsulation LFB instance. In some cases, depending on implementation, the CE may set the MediaEncapInfoIndex passed downstream to a value that will fail lookup when it gets to a target encapsulation LFB; such a lookup failure at that point is an indication that further resolution is needed. For an example of this approach, refer to Section 7.2, which discusses ARP and mentions this approach.",
      "ja": "O MediaEncapInfoIndex、下流封入LFBインスタンスに渡され、それがさらにカプセル化については、表（典型的には、メディアカプセル化関連）を検索するための検索キーとして用いているインデックス。検索キーは、テーブルインデックスを照合することによって、テーブルを検索します。このメタデータを使用してカプセル化LFBインスタンスは直ちに処理のこのLFBインスタンスを以下LFBインスタンスでなくてもよいことに留意されたいです。 MediaEncapInfoIndexメタデータはここに添付され、それがカプセル化LFBインスタンスによって使用されるまで、中間LFBs通過させます。いくつかのケースでは、実装によっては、CEはMediaEncapInfoIndexは、それが目的のカプセル化LFBになったときに、ルックアップに失敗する値に下流渡さ設定することもできます。その時点でそのようなルックアップ失敗がさらに解像度が必要であることを示しています。このアプローチの例は、ARPを説明し、このアプローチを言及セクション7.2を参照。"
    },
    {
      "indent": 3,
      "text": "o LFBOutputSelectIndex, the LFB group output port index to select the downstream LFB port. This value identifies the specific port within the SuccessOut port group out of which packets that successfully use this next-hop entry are to be sent.",
      "ja": "O LFBOutputSelectIndex、下流LFBポートを選択するためのLFBグループ出力ポートインデックス。この値は、正常にこのネクストホップエントリを使用してパケットが送信されるべき外SuccessOutポートグループ内の特定のポートを識別する。"
    },
    {
      "indent": 0,
      "text": "5.3.4.3. Capabilities",
      "section_title": true,
      "ja": "5.3.4.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities.",
      "ja": "このLFBは、機能のリストを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.3.4.4. Events",
      "section_title": true,
      "ja": "5.3.4.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.4. Redirect LFBs",
      "section_title": true,
      "ja": "5.4。 LFBsリダイレクト"
    },
    {
      "indent": 3,
      "text": "Redirect LFBs abstract the data packet transportation process between the CE and FE. Some packets output from some LFBs may have to be delivered to the CE for further processing, and some packets generated by the CE may have to be delivered to the FE and further to some specific LFBs for data path processing. According to [RFC5810], data packets and their associated metadata are encapsulated in a ForCES redirect message for transportation between CE and FE. We define two LFBs to abstract the process: a RedirectIn LFB and a RedirectOut LFB. Usually, in an LFB topology of an FE, only one RedirectIn LFB instance and one RedirectOut LFB instance exist.",
      "ja": "抽象LFBs CEとFEとの間でデータパケットの輸送プロセスをリダイレクトします。一部LFBsからいくつかのパケットの出力は、さらなる処理のためにCEに送達しなければならないかもしれない、およびCEによって生成されたいくつかのパケットは、データパス処理のためにいくつかの特定のLFBsにFE、さらにに送達されなければなりません。 [RFC5810]によれば、データ・パケットおよびそれに関連するメタデータは、力が封入されているCEとFEとの間の輸送のためのメッセージをリダイレクトします。 RedirectIn LFBとRedirectOut LFB：私たちは、抽象プロセスに2 LFBsを定義します。通常、FEのLFBトポロジでは、一つだけRedirectIn LFBインスタンスと1つのRedirectOut LFBインスタンスが存在します。"
    },
    {
      "indent": 0,
      "text": "5.4.1. RedirectIn",
      "section_title": true,
      "ja": "5.4.1。リダイレクション"
    },
    {
      "indent": 3,
      "text": "The RedirectIn LFB abstracts the process for the CE to inject data packets into the FE data path.",
      "ja": "RedirectIn LFBは、CEは、FEデータパスにデータ・パケットを注入するためのプロセスを抽象化します。"
    },
    {
      "indent": 0,
      "text": "5.4.1.1. Data Handling",
      "section_title": true,
      "ja": "5.4.1.1。データ処理"
    },
    {
      "indent": 3,
      "text": "A RedirectIn LFB abstracts the process for the CE to inject data packets into the FE LFB topology so as to input data packets into FE data paths. From the LFB topology's point of view, the RedirectIn LFB acts as a source point for data packets coming from the CE; therefore, the RedirectIn LFB is defined with a single output LFB port (and no input LFB port).",
      "ja": "RedirectIn LFBは、FEデータパスに入力されたデータ・パケットようにFE LFBトポロジにデータ・パケットを注入するCEのためのプロセスを抽象化します。ビューのLFBトポロジの観点から、RedirectIn LFBは、CEからのデータ・パケットのソース・ポイントとして機能します。従って、RedirectIn LFBは、単一出力LFBポート（無入力LFBポート）で定義されています。"
    },
    {
      "indent": 3,
      "text": "The single output port of RedirectIn LFB is defined as a group output type with the name of \"PktsOut\". Packets produced by this output will have arbitrary frame types decided by the CE that generated the packets. Possible frames may include IPv4, IPv6, or ARP protocol packets. The CE may associate some metadata to indicate the frame types and may also associate other metadata to indicate various information on the packets. Among them, there MUST exist a RedirectIndex metadata, which is an integer acting as an index. When the CE transmits the metadata along with the packet to a RedirectIn LFB, the LFB will read the RedirectIndex metadata and output the packet to one of its group output port instances, whose port index is indicated by this metadata. Any other metadata, in addition to RedirectIndex, will be passed untouched along the packet delivered by the CE to the downstream LFB. This means the RedirectIndex metadata from CE will be \"consumed\" by the RedirectIn LFB and will not be passed to downstream LFB. Note that a packet from the CE without a RedirectIndex metadata associated will be dropped by the LFB. Note that all metadata visible to the LFB need to be global and IANA controlled. See Section 8 (\"IANA Considerations\") of this document for more details about a metadata ID space that can be used by vendors and is \"Reserved for Private Use\".",
      "ja": "RedirectIn LFBの単一の出力ポートを「PktsOut」の名前のグループの出力タイプとして定義されています。この出力によって生成されたパケットは、パケットを生成し、CEにより決定された任意のフレームタイプを有することになります。可能なフレームは、IPv4、IPv6の、又はARPプロトコルパケットを含むことができます。 CEは、フレームタイプを示すために、いくつかのメタデータを関連付けることができ、また、パケットに関する様々な情報を示すために、他のメタデータを関連付けることができます。その中でも、インデックスとして機能する整数ですRedirectIndexメタデータを、そこに存在しなければなりません。 CEはRedirectIn LFBにパケットとともにメタデータを送信する場合、LFBは、ポートインデックス、このメタデータによって示され、そのグループの出力ポートインスタンス、のいずれかにRedirectIndexメタデータ及び出力にパケットを読み取ります。その他のメタデータは、RedirectIndexに加えて、下流LFBにCEが提供するパケットに沿ってそのまま渡されます。これは、CEからRedirectIndexメタデータがRedirectIn LFBによって「消費」され、下流のLFBに渡されないことを意味します。関連するRedirectIndexメタデータなしCEからのパケットは、LFBによってドロップされることに注意してください。 LFBに見えるすべてのメタデータは、グローバルとIANA制御する必要があることに注意してください。ベンダーが使用することができ、「私的使用のために予約」されたメタデータのID空間の詳細については、本書の第8章（「IANAの考慮事項」）を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.4.1.2. Components",
      "section_title": true,
      "ja": "5.4.1.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "An optional statistics component is defined to collect the number of packets received by the LFB from the CE. There are no other components defined for the current version of the LFB.",
      "ja": "任意統計コンポーネントは、CEからLFBによって受信されたパケットの数を収集するために定義されています。 LFBの現在のバージョンに定義された他のコンポーネントはありません。"
    },
    {
      "indent": 0,
      "text": "5.4.1.3. Capabilities",
      "section_title": true,
      "ja": "5.4.1.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities.",
      "ja": "このLFBは、機能のリストを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.4.1.4. Events",
      "section_title": true,
      "ja": "5.4.1.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.4.2. RedirectOut",
      "section_title": true,
      "ja": "5.4.2。 RedirectOut"
    },
    {
      "indent": 3,
      "text": "RedirectOut LFB abstracts the process for LFBs in the FE to deliver data packets to the CE.",
      "ja": "RedirectOut LFBは、CEにデータパケットを渡すのにFEでLFBsするためのプロセスを抽象化します。"
    },
    {
      "indent": 0,
      "text": "5.4.2.1. Data Handling",
      "section_title": true,
      "ja": "5.4.2.1。データ処理"
    },
    {
      "indent": 3,
      "text": "A RedirectOut LFB abstracts the process for LFBs in the FE to deliver data packets to the CE. From the LFB topology's point of view, the RedirectOut LFB acts as a sink point for data packets going to the CE; therefore, the RedirectOut LFB is defined with a single input LFB port (and no output LFB port).",
      "ja": "RedirectOut LFBは、CEにデータパケットを配信するためにFEにLFBsするためのプロセスを抽象化します。ビューのLFBトポロジの観点から、RedirectOut LFBはCEに行くデータパケットのためのシンク・ポイントとして機能します。従って、RedirectOut LFBは、単一入力LFBポート（なし出力LFBポート）で定義されています。"
    },
    {
      "indent": 3,
      "text": "The RedirectOut LFB has only one singleton input, known as \"PktsIn\", but is capable of receiving packets from multiple LFBs by multiplexing this input. The input expects any kind of frame type; therefore, the frame type has been specified as arbitrary, and also all types of metadata are expected. All associated metadata produced (but not consumed) by previous processed LFBs should be delivered to the CE via the ForCES protocol redirect message [RFC5810]. The CE",
      "ja": "RedirectOut LFB「はPktsIn」として知られている唯一のシングルトンの入力を有しているが、多重化することによって、この入力を複数LFBsからのパケットを受信することが可能です。入力は、フレームタイプの任意の種類を期待します。したがって、フレームタイプは任意として指定されており、また、メタデータのすべてのタイプが期待されます。関連するすべてのメタデータは、のForCESプロトコルリダイレクトメッセージ[RFC5810]を介してCEに送達されなければならない前処理LFBsによって産生さ（ただし消費されません）。 CE"
    },
    {
      "indent": 3,
      "text": "can decide how to process the redirected packet by referencing the associated metadata. As an example, a packet could be redirected by the FE to the CE because the EtherEncap LFB is not able to resolve L2 information. The metadata \"ExceptionID\" created by the EtherEncap LFB is passed along with the packet and should be sufficient for the CE to do the necessary processing and resolve the L2 entry required. Note that all metadata visible to the LFB need to be global and IANA controlled. See Section 8 (\"IANA Considerations\") of this document for more details about a metadata ID space that can be used by vendors and is \"Reserved for Private Use\".",
      "ja": "関連するメタデータを参照することによってリダイレクトされたパケットをどのように処理するかを決めることができます。 EtherEncap LFBはL2情報を解決できないので、一例として、パケットはCEにFEによってリダイレクトすることができます。 EtherEncap LFBによって作成されたメタデータ「ExceptionIDは、」パケットとともに渡され、必要な処理を行い、必要なL2エントリを解決するためのCEのために十分なものでなければなりません。 LFBに見えるすべてのメタデータは、グローバルとIANA制御する必要があることに注意してください。ベンダーが使用することができ、「私的使用のために予約」されたメタデータのID空間の詳細については、本書の第8章（「IANAの考慮事項」）を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.4.2.2. Components",
      "section_title": true,
      "ja": "5.4.2.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "An optional statistics component is defined to collect the number of packets sent by the LFB to the CE. There are no other components defined for the current version of the LFB.",
      "ja": "任意統計コンポーネントはCEにLFBによって送信されたパケットの数を収集するために定義されています。 LFBの現在のバージョンに定義された他のコンポーネントはありません。"
    },
    {
      "indent": 0,
      "text": "5.4.2.3. Capabilities",
      "section_title": true,
      "ja": "5.4.2.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities.",
      "ja": "このLFBは、機能のリストを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.4.2.4. Events",
      "section_title": true,
      "ja": "5.4.2.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.5. General Purpose LFBs",
      "section_title": true,
      "ja": "5.5。汎用LFBs"
    },
    {
      "indent": 0,
      "text": "5.5.1. BasicMetadataDispatch",
      "section_title": true,
      "ja": "5.5.1。基本的なメタデータの派遣"
    },
    {
      "indent": 3,
      "text": "The BasicMetadataDispatch LFB is defined to abstract the process in which a packet is dispatched to some output path based on its associated metadata value.",
      "ja": "BasicMetadataDispatch LFBは、パケットがその関連するメタデータ値に基づいて、いくつかの出力経路にディスパッチされた抽象プロセスに定義されています。"
    },
    {
      "indent": 0,
      "text": "5.5.1.1. Data Handling",
      "section_title": true,
      "ja": "5.5.1.1。データ処理"
    },
    {
      "indent": 3,
      "text": "The BasicMetadataDispatch LFB has only one singleton input known as \"PktsIn\". Every input packet should be associated with a metadata that will be used by the LFB to do the dispatch. This LFB contains a metadata ID and a dispatch table named MetadataDispatchTable, all configured by the CE. The metadata ID specifies which metadata is to be used for dispatching packets. The MetadataDispatchTable contains entries of a metadata value and an OutputIndex, specifying that the packet with the metadata value must go out from the LFB group output port instance with the OutputIndex.",
      "ja": "BasicMetadataDispatch LFBは「PktsIn」として知られている唯一のシングルトンの入力を持っています。すべての入力パケットは、派遣を行うためにLFBによって使用されるメタデータに関連付けられている必要があります。このLFBは、すべてのCEによって構成され、メタデータIDとMetadataDispatchTableという名前のディスパッチテーブルが含まれています。メタデータIDは、パケットをディスパッチするために使用されるべきメタデータを指定します。 MetadataDispatchTableは、メタデータ値を持つパケットはOutputIndexとLFBグループ出力ポートインスタンスから出て行かなければならないことを指定して、メタデータの値とOutputIndexのエントリが含まれています。"
    },
    {
      "indent": 3,
      "text": "Two output LFB ports are defined.",
      "ja": "二つの出力LFBポートが定義されています。"
    },
    {
      "indent": 3,
      "text": "The first output is a group output port known as \"PktsOut\". A packet with its associated metadata having found an OutputIndex by successfully looking up the dispatch table will be output to the group port instance with the corresponding index.",
      "ja": "第1の出力は「PktsOut」として知られているグループの出力ポートです。その関連するメタデータを有するパケットが正常に対応するインデックスとグループポートインスタンスに出力されるディスパッチ・テーブルを調べることによってOutputIndexを発見しました。"
    },
    {
      "indent": 3,
      "text": "The second output is a singleton output port known as \"ExceptionOut\", which will output packets for which the data processing failed, along with an additional ExceptionID metadata to indicate what caused the exception. Currently defined exception types only include one case:",
      "ja": "第2の出力は、出力パケットがそのためのデータ処理は、例外の原因を示すために、追加のExceptionIDメタデータと一緒に、失敗します「ExceptionOut」として知られているシングルトン出力ポートです。現在、定義された例外タイプは、唯一のケースが含まれています。"
    },
    {
      "indent": 3,
      "text": "o There is no matching when looking up the metadata dispatch table.",
      "ja": "Oメタデータのディスパッチテーブルを参照して、一致はありません。"
    },
    {
      "indent": 3,
      "text": "As an example, if the CE decides to dispatch packets according to a physical port ID (PHYPortID), the CE may set the ID of PHYPortID metadata to the LFB first. Moreover, the CE also sets the PHYPortID actual values (the metadata values) and assigned OutputIndex for the values to the dispatch table in the LFB. When a packet arrives, a PHYPortID metadata is found associated with the packet, and the metadata value is further used as a key to look up the dispatch table to find out an output port instance for the packet.",
      "ja": "CEは、物理ポートID（PHYPortID）に従ってパケットを送出することを決定した場合、一例として、CEは、第LFBにPHYPortIDメタデータのIDを設定してもよいです。また、CEはまたPHYPortID実際の値（メタデータ値）を設定し、LFBにおけるディスパッチテーブルの値についてOutputIndex割り当てられます。パケットが到着すると、PHYPortIDメタデータは、パケットに関連付けられて発見され、およびメタデータの値は、さらにパケットの出力ポートインスタンスを見つけるためにディスパッチテーブルを検索するためのキーとして使用されています。"
    },
    {
      "indent": 3,
      "text": "Currently, the BasicMetadataDispatch LFB only allows the metadata value of the dispatch table entry to be a 32-bit integer. A metadata with other value types is not supported in this version. A more complex metadata dispatch LFB may be defined in future versions of the library. In that LFB, multiple tuples of metadata with more value types supported may be used to dispatch packets.",
      "ja": "現在、BasicMetadataDispatch LFBは、ディスパッチテーブルエントリーのメタデータの値は32ビット整数にすることができます。他の値の型を持つメタデータは、このバージョンではサポートされていません。より複雑なメタデータのディスパッチLFBは、ライブラリの将来のバージョンで定義されてもよいです。そのLFBでは、サポートされているより多くの価値のタイプのメタデータの複数のタプルがパケットをディスパッチするのに使用することができます。"
    },
    {
      "indent": 0,
      "text": "5.5.1.2. Components",
      "section_title": true,
      "ja": "5.5.1.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "This LFB has two components. One component is MetadataID and the other is MetadataDispatchTable. Each row entry of the dispatch table is a struct containing the metadata value and the OutputIndex. Note that currently, the metadata value is only allowed to be a 32-bit integer. The metadata value is also defined as a content key for the table. The concept of content key is a searching key for tables, which is defined in the ForCES FE model [RFC5812]. With the content key, the CE can manipulate the table by means of a specific metadata value rather than by the table index only. See the ForCES FE model [RFC5812] and also the ForCES protocol [RFC5810] for more details on the definition and use of a content key.",
      "ja": "このLFBは、2つのコンポーネントがあります。一の成分はMetadataIDあり、他方はMetadataDispatchTableです。ディスパッチテーブルの各行エントリは、メタデータ値とOutputIndexを含む構造体です。現在、メタデータの値は、32ビットの整数であることが許されることに留意されたいです。メタデータの値は、テーブルのコンテンツキーとして定義されます。コンテンツ鍵の概念のForCES FEモデル[RFC5812]で定義されているテーブルの検索キーです。コンテンツキーを使用すると、CEは、特定のメタデータ値によってだけではなく、テーブルのインデックスでテーブルを操作することができます。コンテンツキーの定義と使用の詳細については、またのForCES FEモデル[RFC5812]、強制的にプロトコル[RFC5810]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.5.1.3. Capabilities",
      "section_title": true,
      "ja": "5.5.1.3。機能"
    },
    {
      "indent": 3,
      "text": "This LFB does not have a list of capabilities.",
      "ja": "このLFBは、機能のリストを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.5.1.4. Events",
      "section_title": true,
      "ja": "5.5.1.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "5.5.2. GenericScheduler",
      "section_title": true,
      "ja": "5.5.2。 GenericScheduler"
    },
    {
      "indent": 3,
      "text": "This is a preliminary generic scheduler LFB for abstracting a simple scheduling process.",
      "ja": "これは、単純なスケジューリングプロセスを抽象化するための予備の汎用スケジューラLFBです。"
    },
    {
      "indent": 0,
      "text": "5.5.2.1. Data Handling",
      "section_title": true,
      "ja": "5.5.2.1。データ処理"
    },
    {
      "indent": 3,
      "text": "There exist various kinds of scheduling strategies with various implementations. As a base LFB library, this document only defines a preliminary generic scheduler LFB for abstracting a simple scheduling process. Users may use this LFB as a basic LFB to further construct more complex scheduler LFBs by means of \"inheritance\", as described in [RFC5812].",
      "ja": "様々な実装とスケジューリング戦略の様々な種類が存在します。ベースLFBライブラリとして、この文書では、単純なスケジューリングプロセスを抽象化するための予備の汎用スケジューラLFBを定義します。 [RFC5812]に記載されているように、ユーザーは、さらに「継承」によってより複雑なスケジューラLFBsを構築するための基本的なLFBとしてLFBを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Packets of any arbitrary frame type are received via a group input known as \"PktsIn\" with no additional metadata expected. This group input is capable of multiple input port instances. Each port instance may be connected to a different upstream LFB output. Inside the LFB, it is abstracted that each input port instance is connected to a queue, and the queue is marked with a queue ID whose value is exactly the same as the index of corresponding group input port instance. Scheduling disciplines are applied to all queues and also all packets in the queues. The group input port property PortGroupLimits in ObjectLFB, as defined by the ForCES FE model [RFC5810], provides means for the CE to query the capability of total queue numbers the scheduler supports. The CE can then decide how many queues it may use for a scheduling application.",
      "ja": "任意のフレームタイプのパケットは、予想なし追加のメタデータを「PktsIn」として知られているグループ入力を介して受信されます。このグループの入力は、複数の入力ポートのインスタンスが可能です。各ポートインスタンスは、異なる上流LFB出力に接続されてもよいです。 LFBの内部には、各入力ポートインスタンスがキューに接続されていることを抽象化して、キューはその値がグループ入力ポートインスタンスの対応する指標と全く同じであるキューIDでマークされています。スケジューリング規律は、すべてのキューともキュー内のすべてのパケットに適用されます。 ForCES FEモデル[RFC5810]で定義した群ObjectLFB入力ポートプロパティPortGroupLimitsは、合計キュー番号スケジューラ支持体の能力を照会するCEための手段を提供します。 CEは、それはスケジューリングアプリケーション用に使用することができますどのように多くのキューを決定することができます。"
    },
    {
      "indent": 3,
      "text": "Scheduled packets are output from a singleton output port of the LFB knows as \"PktsOut\" with no corresponding metadata.",
      "ja": "スケジュールのパケットは、LFBのシングルトン出力ポートから出力されていない対応するメタデータを持つ「PktsOut」として知っています。"
    },
    {
      "indent": 3,
      "text": "More complex scheduler LFBs may be defined with more complex scheduling disciplines by succeeding this LFB. For instance, a priority scheduler LFB may be defined by inheriting this LFB and defining a component to indicate priorities for all input queues.",
      "ja": "より複雑なスケジューラLFBsはこのLFBに続くことによって、より複雑なスケジューリング規律で定義することができます。例えば、優先スケジューラLFBこのLFBを継承し、すべての入力キューの優先度を示すために、コンポーネントを定義することによって定義することができます。"
    },
    {
      "indent": 0,
      "text": "5.5.2.2. Components",
      "section_title": true,
      "ja": "5.5.2.2。コンポーネント"
    },
    {
      "indent": 3,
      "text": "The SchedulingDiscipline component is for the CE to specify a scheduling discipline to the LFB. Currently defined scheduling disciplines only include Round Robin (RR) strategy. The default scheduling discipline is thus RR.",
      "ja": "SchedulingDisciplineコンポーネントは、LFBにスケジューリング規律を指定するCE用です。現在、定義されたスケジューリング規律はラウンドロビン（RR）の戦略が含まれます。デフォルトのスケジューリング規律は、このようにRRです。"
    },
    {
      "indent": 3,
      "text": "The QueueStats component is defined to allow the CE to query every queue status of the scheduler. It is an array component, and each row of the array is a struct containing a queue ID. Currently defined queue status includes the queue depth in packets and the queue depth in bytes. Using the queue ID as the index, the CE can query every queue for its used length in unit of packets or bytes. Note that the QueueStats component is defined as optional to implementers.",
      "ja": "QueueStatsコンポーネントは、CEは、スケジューラのすべてのキューの状態を照会できるようにするために定義されています。これは、アレイ成分であり、アレイの各行は、キューIDを含む構造体です。現在、定義されたキューの状態は、パケット内のキューの深さとバイト単位のキューの深さを含んでいます。指標としてキューIDを使用して、CEは、パケットまたはバイト単位でのその使用長さ毎のキューを照会することができます。 QueueStatsコンポーネントが実装するオプションとして定義されていることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "5.5.2.3. Capabilities",
      "section_title": true,
      "ja": "5.5.2.3。機能"
    },
    {
      "indent": 3,
      "text": "The following capability is currently defined for the GenericScheduler.",
      "ja": "以下の機能は、現在GenericSchedulerのために定義されています。"
    },
    {
      "indent": 3,
      "text": "o The queue length limit providing the storage ability for every queue.",
      "ja": "Oキューの長さの制限は、すべてのキューのストレージ機能を提供します。"
    },
    {
      "indent": 0,
      "text": "5.5.2.4. Events",
      "section_title": true,
      "ja": "5.5.2.4。イベント"
    },
    {
      "indent": 3,
      "text": "This LFB does not have any events specified.",
      "ja": "このLFBは、指定されたすべてのイベントを持っていません。"
    },
    {
      "indent": 0,
      "text": "6. XML for LFB Library",
      "section_title": true,
      "ja": "LFBライブラリ6. XML"
    },
    {
      "indent": 0,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <LFBLibrary xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" provides=\"BaseLFBLibrary\"> <load library=\"BaseTypeLibrary\"/> <LFBClassDefs> <LFBClassDef LFBClassID=\"3\"> <name>EtherPHYCop</name> <synopsis> The EtherPHYCop LFB describes an Ethernet interface that limits the physical media to copper. </synopsis> <version>1.0</version> <inputPorts> <inputPort> <name>EtherPHYIn</name> <synopsis> The input port of the EtherPHYCop LFB. It expects any type of Ethernet frame. </synopsis> <expectation> <frameExpected> <ref>EthernetAll</ref> </frameExpected> </expectation>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <LFBLibrary =のxmlns \"壷：IETF：のparams：XML：NS：力：lfbmodel：1.0\" のxmlns：XSI = \"のhttp：//www.w3 / 2001 / XMLスキーマ・インスタンス.ORG」が提供= \"BaseLFBLibrary\"> <ロードライブラリ= \"BaseTypeLibrary\" /> <LFBClassDefs> <LFBClassDef LFBClassID = \"3\"> <名前> EtherPHYCop </名前> <概要> EtherPHYCop LFBは説明銅に物理メディアを制限イーサネットインターフェイス。 </シノプシス>の<version> 1.0 </バージョン> <inputPorts> <inputPort> <名前> EtherPHYIn </名前> <概要> EtherPHYCop LFBの入力ポート。これは、イーサネットフレームのいずれかのタイプを期待しています。 </シノプシス> <期待> <frameExpected> <参考文献> EthernetAll </ ref>を</ frameExpected> </期待>"
    },
    {
      "indent": 9,
      "text": "   </inputPort>\n</inputPorts>\n<outputPorts>\n   <outputPort>\n      <name>EtherPHYOut</name>\n      <synopsis>\n        The output port of the EtherPHYCop LFB.  The output\n        packet has the same Ethernet frame type as the\n        input packet, associated with a metadata indicating\n        the ID of the physical port.\n      </synopsis>\n      <product>\n         <frameProduced>\n            <ref>EthernetAll</ref>\n         </frameProduced>\n         <metadataProduced>\n            <ref>PHYPortID</ref>\n         </metadataProduced>\n      </product>\n   </outputPort>\n</outputPorts>\n<components>\n   <component componentID=\"1\" access=\"read-only\">\n      <name>PHYPortID</name>\n      <synopsis>\n        The identification of the physical port\n      </synopsis>\n      <typeRef>uint32</typeRef>\n   </component>\n   <component componentID=\"2\" access=\"read-write\">\n      <name>AdminStatus</name>\n      <synopsis>\n        The port status administratively requested\n      </synopsis>\n      <typeRef>PortStatusType</typeRef>\n      <defaultValue>2</defaultValue>\n   </component>\n   <component componentID=\"3\" access=\"read-only\">\n      <name>OperStatus</name>\n      <synopsis>\n        The port actual operational status\n      </synopsis>\n      <typeRef>PortStatusType</typeRef>\n   </component>\n   <component componentID=\"4\" access=\"read-write\">\n      <name>AdminLinkSpeed</name>\n      <synopsis>\n        The port link speed administratively requested",
      "raw": true
    },
    {
      "indent": 9,
      "text": " </synopsis> <typeRef>LANSpeedType</typeRef> <defaultValue>LAN_SPEED_AUTO</defaultValue> </component> <component componentID=\"5\" access=\"read-only\"> <name>OperLinkSpeed</name> <synopsis> The port actual operational link speed </synopsis> <typeRef>LANSpeedType</typeRef> </component> <component componentID=\"6\" access=\"read-write\"> <name>AdminDuplexMode</name> <synopsis> The port duplex mode administratively requested </synopsis> <typeRef>DuplexType</typeRef> <defaultValue>Auto</defaultValue> </component> <component componentID=\"7\" access=\"read-only\"> <name>OperDuplexMode</name> <synopsis> The port actual operational duplex mode </synopsis> <typeRef>DuplexType</typeRef> </component> <component componentID=\"8\" access=\"read-only\"> <name>CarrierStatus</name> <synopsis>The carrier status of the port </synopsis> <typeRef>boolean</typeRef> <defaultValue>false</defaultValue> </component> </components> <capabilities> <capability componentID=\"30\"> <name>SupportedLinkSpeed</name> <synopsis> A list of link speeds the port supports </synopsis> <array> <typeRef>LANSpeedType</typeRef> </array> </capability> <capability componentID=\"31\"> <name>SupportedDuplexMode</name> <synopsis> A list of duplex modes the port supports </synopsis>",
      "ja": "</シノプシス> <typeRef> LANSpeedType </ typeRef> <はdefaultValue> LAN_SPEED_AUTO </はdefaultValue> </コンポーネント> <コンポーネントのComponentID = \"5\" アクセス= \"読み取り専用\"> <名前> OperLinkSpeed </名前> <概要>ポート実際の動作リンク速度</シノプシス> <typeRef> LANSpeedType </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"6\" アクセス= \"読み書き\"> <名前> AdminDuplexMode </名前> <概要>ポート二重モード管理要求</シノプシス> <typeRef> DuplexType </ typeRef> <はdefaultValue>自動車</はdefaultValue> </コンポーネント> <コンポーネントのComponentID = \"7\" アクセス= \"読み取り専用\"> <名前> OperDuplexMode </名前> <概要>ポート実際の動作デュプレックスモード</シノプシス> <typeRef> DuplexType </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"8\" アクセス= \"読み取り専用\"> <名前> CarrierStatus </名前> <概要>ポートのキャリア状態</シノプシス> <typeRef>ブール</ typeRef> <はdefaultValue>偽</はdefaultValue> </成分> </部品> <機能> <能力COMPONENTID = \"30\"> <名前> SupportedLinkSpeed </名前> <概要>リスト0 Fリンクはポートがサポートする速度</概要> <配列> <typeRef> LANSpeedType </ typeRef> </配列> </機能> <機能COMPONENTID = \"31\"> <名前> SupportedDuplexMode </名前> <概要>リスト二重ポートがサポートするモードの</概要>"
    },
    {
      "indent": 9,
      "text": " <array> <typeRef>DuplexType</typeRef> </array> </capability> </capabilities> <events baseID=\"60\"> <event eventID=\"1\"> <name>PHYPortStatusChanged</name> <synopsis> An event reporting change on operational status of the physical port. </synopsis> <eventTarget> <eventField>OperStatus</eventField> </eventTarget> <eventChanged/> <eventReports> <eventReport> <eventField>OperStatus</eventField> </eventReport> </eventReports> </event> <event eventID=\"2\"> <name>LinkSpeedChanged</name> <synopsis> An event reporting change on operational link speed of the physical port. </synopsis> <eventTarget> <eventField>OperLinkSpeed</eventField> </eventTarget> <eventChanged/> <eventReports> <eventReport> <eventField>OperLinkSpeed</eventField> </eventReport> </eventReports> </event> <event eventID=\"3\"> <name>DuplexModeChanged</name> <synopsis> An event reporting change on operational duplex mode of the physical port. </synopsis> <eventTarget> <eventField>OperDuplexMode</eventField> </eventTarget> <eventChanged/>",
      "ja": "<配列> <typeRef> DuplexType </ typeRef> </アレイ> </機能> </機能> <イベントbaseID = \"60\"> <イベントのeventID = \"1\"> <名前> PHYPortStatusChanged </名前> <概要>物理ポートの動作ステータスの変更を報告するイベント。 </シノプシス> <のEventTarget> <eventField> OperStatus </ eventField> </のEventTarget> <eventChanged /> <eventReports> <eventReport> <eventField> OperStatus </ eventField> </ eventReport> </ eventReports> </イベント> <イベントのeventID =「2」> <名前> LinkSpeedChanged </名前> <概要>物理ポートの動作リンク速度に変更を報告するイベント。 </シノプシス> <のEventTarget> <eventField> OperLinkSpeed </ eventField> </のEventTarget> <eventChanged /> <eventReports> <eventReport> <eventField> OperLinkSpeed </ eventField> </ eventReport> </ eventReports> </イベント> <イベントのeventID =「3」> <名前> DuplexModeChanged </名前> <概要>物理ポートの動作のデュプレックスモードの変更を報告するイベント。 </シノプシス> <のEventTarget> <eventField> OperDuplexMode </ eventField> </のEventTarget> <eventChanged />"
    },
    {
      "indent": 6,
      "text": " <eventReports> <eventReport> <eventField>OperDuplexMode</eventField> </eventReport> </eventReports> </event> </events> </LFBClassDef> <LFBClassDef LFBClassID=\"4\"> <name>EtherMACIn</name> <synopsis> EtherMACIn LFB describes an Ethernet port at MAC data link layer. The LFB describes Ethernet processing functions of MAC address locality check, deciding if the Ethernet packets should be bridged, providing Ethernet-layer flow control, etc. </synopsis> <version>1.0</version> <inputPorts> <inputPort group=\"false\"> <name>EtherPktsIn</name> <synopsis> The input port of the EtherMACIn LFB. It expects any type of Ethernet frame. </synopsis> <expectation> <frameExpected> <ref>EthernetAll</ref> </frameExpected> <metadataExpected> <ref>PHYPortID</ref> </metadataExpected> </expectation> </inputPort> </inputPorts> <outputPorts> <outputPort group=\"false\"> <name>NormalPathOut</name> <synopsis> An output port in the EtherMACIn LFB. It outputs Ethernet packets to downstream LFBs for normal processing like Ethernet packet classification and other L3 IP-layer processing. </synopsis> <product> <frameProduced> <ref>EthernetAll</ref> </frameProduced>",
      "ja": "<eventReports> <eventReport> <eventField> OperDuplexMode </ eventField> </ eventReport> </ eventReports> </イベント> </イベント> </ LFBClassDef> <LFBClassDef LFBClassID = \"4\"> <名前> EtherMACIn </名前> <概要> EtherMACIn LFBは、MAC、データリンク層でのイーサネットポートを説明します。 LFB「は=イーサネットパケットがブリッジされるべきである場合、イーサネット・レイヤ・フロー制御、等</シノプシス>の<version> 1.0 </バージョン> <inputPorts> <inputPort基を提供する、決定する、MACアドレス局所性チェックのイーサネット処理機能を説明します偽 \"> <名前> EtherPktsIn </名前> <概要> EtherMACIn LFBの入力ポート。これは、イーサネットフレームのいずれかのタイプを期待しています。 </シノプシス> <期待> <frameExpected> <参考文献> EthernetAll </ ref>を</ frameExpected> <metadataExpected> <参考文献> PHYPortID </ ref>を</ metadataExpected> </期待> </ inputPort> </ inputPorts> < outputPorts> <出力ポートグループ= \"偽\"> <名前> NormalPathOut </名前> <概要> EtherMACIn LFBで出力ポート。これは、イーサネットパケットの分類及び他のL3 IPレイヤ処理など通常の処理のために下流LFBsにイーサネットパケットを出力します。 </概要> </ frameProduced> <REF /> <製品> <frameProduced> <参考文献> EthernetAll"
    },
    {
      "indent": 9,
      "text": " <metadataProduced> <ref>PHYPortID</ref> </metadataProduced> </product> </outputPort> <outputPort> <name>L2BridgingPathOut</name> <synopsis> An output port in the EtherMACIn LFB. It outputs Ethernet packets to downstream LFBs for layer 2 bridging processing. The port is switched on or off by the L2BridgingPathEnable flag in the LFB. </synopsis> <product> <frameProduced> <ref>EthernetAll</ref> </frameProduced> <metadataProduced> <ref>PHYPortID</ref> </metadataProduced> </product> </outputPort> </outputPorts> <components> <component componentID=\"1\" access=\"read-write\"> <name>AdminStatus</name> <synopsis> The LFB status administratively requested, which has the same data type with a port status. Default is in 'Down' status. </synopsis> <typeRef>PortStatusType</typeRef> <defaultValue>2</defaultValue> </component> <component componentID=\"2\" access=\"read-write\"> <name>LocalMACAddresses</name> <synopsis> Local MAC address(es) of the Ethernet port the LFB represents. </synopsis> <array> <typeRef>IEEEMAC</typeRef> </array> </component> <component componentID=\"3\" access=\"read-write\"> <name>L2BridgingPathEnable</name> <synopsis>",
      "ja": "<metadataProduced> <参考文献> PHYPortID </ ref>を</ metadataProduced> </製品> </出力ポート> <出力ポート> <名前> L2BridgingPathOut </名前> <概要> EtherMACIn LFBにおける出力ポート。これは、レイヤ2ブリッジング処理のために下流LFBsにイーサネットパケットを出力します。ポートは、LFBでL2BridgingPathEnableフラグでオンまたはオフに切り替えられます。 </シノプシス> <製品> <frameProduced> <参考文献> EthernetAll </ ref>を</ frameProduced> <metadataProduced> <参考文献> PHYPortID </ ref>を</ metadataProduced> </製品> </出力ポート> </ outputPorts> <ポートステータスと同じデータ型を持つ管理要求の成分> <コンポーネントのComponentID =「1」アクセス=「読み書き」> <名前>のAdminStatus </名前> <概要> LFBステータス、。デフォルトは「ダウン」状態です。 </シノプシス> <typeRef> PortStatusType </ typeRef> <はdefaultValue> 2 </はdefaultValue> </コンポーネント> <コンポーネントのComponentID = \"2\" アクセス= \"読み書き\"> <名前> LocalMACAddresses </名前> <概要> LFBが表すイーサネットポートのローカルMACアドレス（複数可）。 </シノプシス> <配列> <typeRef> IEEEMAC </ typeRef> </アレイ> </コンポーネント> <コンポーネントのComponentID = \"3\" アクセス= \"読み書き\"> <名前> L2BridgingPathEnable </名前> <概要>"
    },
    {
      "indent": 6,
      "text": " A flag indicating if the LFB L2 BridgingPath output port is enabled or not. Default is not enabled. </synopsis> <typeRef>boolean</typeRef> <defaultValue>false</defaultValue> </component> <component componentID=\"4\" access=\"read-write\"> <name>PromiscuousMode</name> <synopsis> A flag indicating whether the LFB is in promiscuous mode or not. Default is not. </synopsis> <typeRef>boolean</typeRef> <defaultValue>false</defaultValue> </component> <component componentID=\"5\" access=\"read-write\"> <name>TxFlowControl</name> <synopsis> A flag indicating whether transmit flow control is applied or not. Default is not. </synopsis> <optional/> <typeRef>boolean</typeRef> <defaultValue>false</defaultValue> </component> <component componentID=\"6\" access=\"read-write\"> <name>RxFlowControl</name> <synopsis> A flag indicating whether receive flow control is applied or not. Default is not. </synopsis> <optional/> <typeRef>boolean</typeRef> <defaultValue>false</defaultValue> </component> <component componentID=\"7\" access=\"read-reset\"> <name>MACInStats</name> <synopsis> The statistics of the EtherMACIn LFB </synopsis> <optional/> <typeRef>MACInStatsType</typeRef> </component> </components> </LFBClassDef> <LFBClassDef LFBClassID=\"5\"> <name>EtherClassifier</name> <synopsis>",
      "ja": "LFB L2 BridgingPath出力ポートがイネーブルされているかどうかを示すフラグ。デフォルトでは有効になっていません。 </シノプシス> <typeRef>ブール</ typeRef> <はdefaultValue>偽</はdefaultValue> </コンポーネント> <コンポーネントのComponentID = \"4\" のアクセス= \"読み書き\"> <名前>プロミスキャス・モード</名前> <概要> LFBがプロミスキャスモードであるか否かを示すフラグ。デフォルトではありません。 </シノプシス> <typeRef>ブール</ typeRef> <はdefaultValue>偽</はdefaultValue> </コンポーネント> <コンポーネントのComponentID = \"5\" アクセス= \"読み書き\"> <名前> TxFlowControl </名前> <概要>送信フロー制御が適用されているか否かを示すフラグ。デフォルトではありません。 </シノプシス> <オプション/> <typeRef>ブール</ typeRef> <はdefaultValue>偽</はdefaultValue> </コンポーネント> <コンポーネントのComponentID = \"6\" アクセス= \"読み取りと書き込み\"> <名前> RxFlowControl </名前> <概要>フロー制御を受けるかどうかを示すフラグを適用するかしません。デフォルトではありません。 </シノプシス> <オプション/> <typeRef>ブール</ typeRef> <はdefaultValue>偽</はdefaultValue> </コンポーネント> <コンポーネントのComponentID = \"7\" アクセス= \"読み取りリセット\"> <名前> MACInStats </名前EtherMACIn LFB </シノプシス> <オプション/> <typeRef> MACInStatsType </ typeRef> </成分> </部品> </ LFBClassDef> <LFBClassDef LFBClassID = \"5\"> <名前> EtherClassifierの> <概要>統計</名前> <概要>"
    },
    {
      "indent": 9,
      "text": " EtherClassifier LFB describes the process to decapsulate Ethernet packets and then classify them into various network-layer packets according to information in the Ethernet headers. It is expected the LFB classifies packets by packet types like IPv4, IPv6, MPLS, ARP, ND, etc. </synopsis> <version>1.0</version> <inputPorts> <inputPort> <name>EtherPktsIn</name> <synopsis> Input port of Ethernet packets. PHYPortID metadata is always expected while LogicalPortID metadata is optionally expected to associate with every input Ethernet packet. </synopsis> <expectation> <frameExpected> <ref>EthernetAll</ref> </frameExpected> <metadataExpected> <ref>PHYPortID</ref> <ref dependency=\"optional\" defaultValue=\"0\"> LogicalPortID</ref> </metadataExpected> </expectation> </inputPort> </inputPorts> <outputPorts> <outputPort group=\"true\"> <name>ClassifyOut</name> <synopsis> A group port for output of Ethernet classifying results. </synopsis> <product> <frameProduced> <ref>Arbitrary</ref> </frameProduced> <metadataProduced> <ref>PHYPortID</ref> <ref>SrcMAC</ref> <ref>DstMAC</ref> <ref>EtherType</ref> <ref availability=\"conditional\">VlanID</ref> <ref availability=\"conditional\">VlanPriority</ref> </metadataProduced> </product>",
      "ja": "EtherClassifier LFBは、イーサネットパケットをデカプセル化し、次いで、イーサネットヘッダ内の情報に応じて、様々なネットワーク層パケットにそれらを分類する方法が記載されています。 LFB等</概要> <バージョン> 1.0 </ version>の<inputPorts> <inputPort> <名前> EtherPktsIn </名前> <はIPv4、IPv6の、MPLS、ARP、ND、のようなパケットの種類によってパケットを分類期待されていますイーサネットパケットの概要>入力ポート。 LogicalPortIDメタデータは、必要に応じて、すべての入力イーサネットパケットに関連付けることが予想されている間PHYPortIDメタデータが常に期待されています。 </シノプシス> <期待> <frameExpected> <参考文献> EthernetAll </ ref>を</ frameExpected> <metadataExpected> <参考文献> PHYPortID </ REF> <REF依存= \"オプション\" はdefaultValue = \"0\"> LogicalPortID </ REF > </ metadataExpected> </期待> </ inputPort> </ inputPorts> <outputPorts> <出力ポートグループ= \"真\"> <名前> ClassifyOut </名前> <概要>イーサネット分類結果の出力のグループポート。 </シノプシス> <製品> <frameProduced> <参考文献>任意</ ref>を</ frameProduced> <metadataProduced> <参考文献> PHYPortID </ REF> <参考文献> SrcMAC </ REF> <参考文献> DstMAC </ REF> < REF>のEtherType </ REF> <REF可用性= \"条件\"> VLANID </ REF> <REF可用性= \"条件\"> VlanPriority </ ref>を</ metadataProduced> </製品>"
    },
    {
      "indent": 9,
      "text": " </outputPort> <outputPort group=\"false\"> <name>ExceptionOut</name> <synopsis> A singleton port for output of all Ethernet packets that fail the classifying process. An ExceptionID metadata indicates the failure reason. </synopsis> <product> <frameProduced> <ref>Arbitrary</ref> </frameProduced> <metadataProduced> <ref>ExceptionID</ref> </metadataProduced> </product> </outputPort> </outputPorts> <components> <component access=\"read-write\" componentID=\"1\"> <name>EtherDispatchTable</name> <synopsis> An EtherDispatchTable array component that is defined in the LFB to dispatch every Ethernet packet to output ports according to logical port ID assigned by the VlanInputTable in the LFB and Ethernet type in the Ethernet packet header. </synopsis> <typeRef>EtherDispatchTableType</typeRef> </component> <component access=\"read-write\" componentID=\"2\"> <name>VlanInputTable</name> <synopsis> A VlanInputTable array component that is defined in the LFB to classify VLAN Ethernet packets. Every input packet is assigned with a new LogicalPortID according to the packet's incoming port ID and VLAN ID. </synopsis> <typeRef>VlanInputTableType</typeRef> </component> <component access=\"read-reset\" componentID=\"3\"> <name>EtherClassifyStats</name> <synopsis> A table recording statistics on the Ethernet classifying process in the LFB. </synopsis> <optional/> <typeRef>EtherClassifyStatsTableType</typeRef>",
      "ja": "</出力ポート> <出力ポートグループ=「偽」> <名前> ExceptionOut </名前> <概要>分類処理に失敗し、すべてのイーサネットパケットを出力するためのシングルトンポート。 ExceptionIDメタデータは、失敗の理由を示しています。 </シノプシス> <製品> <frameProduced> <参考文献>任意</ ref>を</ frameProduced> <metadataProduced> <参考文献> ExceptionID </ ref>を</ metadataProduced> </製品> </出力ポート> </ outputPorts> <成分> <成分アクセス=「読み書き」COMPONENTID =「1」> <名前> EtherDispatchTable </名前> <概要>論理ポートに係る出力ポートにすべてのイーサネットパケットをディスパッチするLFBで定義されているEtherDispatchTableアレイコンポーネントイーサネットパケットヘッダにLFBとイーサネット型にVlanInputTableによって割り当てられたID。 </シノプシス> <typeRef> EtherDispatchTableType </ typeRef> </コンポーネント> <成分アクセス= \"読み書き\" COMPONENTID = \"2\"> <名前> VlanInputTable </名前> <概要>で定義されVlanInputTableアレイ成分LFBは、VLAN、イーサネットパケットを分類します。すべての入力パケットは、パケットの着信ポートIDとVLAN IDに基づいて新しいLogicalPortIDが割り当てられています。 </シノプシス> <typeRef> VlanInputTableType </ typeRef> </コンポーネント> <成分アクセス= \"読み取りリセット\" COMPONENTID = \"3\"> <名前> EtherClassifyStats </名前> <概要>イーサネット分類表記録統計LFBでの処理。 </概要> <オプション/> <typeRef> EtherClassifyStatsTableType </ typeRef>"
    },
    {
      "indent": 6,
      "text": " </component> </components> </LFBClassDef> <LFBClassDef LFBClassID=\"6\"> <name>EtherEncap</name> <synopsis> The EtherEncap LFB abstracts the process of encapsulating Ethernet headers onto received packets. The encapsulation is based on passed metadata. </synopsis> <version>1.0</version> <inputPorts> <inputPort group=\"false\"> <name>EncapIn</name> <synopsis> An input port receiving IPv4 and/or IPv6 packets for encapsulation. A MediaEncapInfoIndex metadata is expected, and a VLAN priority metadata is optionally expected with every input packet. </synopsis> <expectation> <frameExpected> <ref>IPv4</ref> <ref>IPv6</ref> </frameExpected> <metadataExpected> <ref>MediaEncapInfoIndex</ref> <ref dependency=\"optional\" defaultValue=\"0\"> VlanPriority</ref> </metadataExpected> </expectation> </inputPort> </inputPorts> <outputPorts> <outputPort group=\"false\"> <name>SuccessOut</name> <synopsis> An output port for packets that have found Ethernet L2 information and have been successfully encapsulated into an Ethernet packet. An L2PortID metadata is produced for every output packet. </synopsis> <product> <frameProduced> <ref>IPv4</ref> <ref>IPv6</ref> </frameProduced> <metadataProduced>",
      "ja": "</成分> </部品> </ LFBClassDef> <LFBClassDef LFBClassID = \"6\"> <名前> EtherEncap </名前> <概要> EtherEncap LFBは、受信したパケットにイーサネットヘッダをカプセル化するプロセスを抽象化します。カプセル化は、渡されたメタデータに基づいています。 </シノプシス>の<version> 1.0 </バージョン> <inputPorts> <inputPort基= \"偽\"> <名前> EncapIn </名前> <概要>カプセル化のためのIPv4および/またはIPv6パケットを受け取る入力ポート。 MediaEncapInfoIndexメタデータが期待され、およびVLAN優先メタデータは、必要に応じて、すべての入力パケットと期待されています。 </シノプシス> <期待> <frameExpected> <参考文献>のIPv4 </ REF> <参考文献> IPv6の</ ref>を</ frameExpected> <metadataExpected> <参考文献> MediaEncapInfoIndex </ REF> <REF依存= \"オプション\" はdefaultValue = \"0\"> VlanPriority </ ref>を</ metadataExpected> </期待> </ inputPort> </ inputPorts> <outputPorts> <出力ポートグループ= \"偽\"> <名前> SuccessOut </名前> <概要>出力ポートイーサネットL2情報を発見したと、正常イーサネットパケットにカプセル化されたパケットのために。 L2PortIDメタデータは、すべての出力パケットのために作られています。 </シノプシス> <製品> <frameProduced> <参考文献>のIPv4 </ REF> <参考文献> IPv6の</ ref>を</ frameProduced> <metadataProduced>"
    },
    {
      "indent": 6,
      "text": " <ref>L2PortID</ref> </metadataProduced> </product> </outputPort> <outputPort group=\"false\"> <name>ExceptionOut</name> <synopsis> An output port for packets that fail encapsulation in the LFB. An ExceptionID metadata indicates failure reason. </synopsis> <product> <frameProduced> <ref>IPv4</ref> <ref>IPv6</ref> </frameProduced> <metadataProduced> <ref>ExceptionID</ref> <ref>MediaEncapInfoIndex</ref> <ref availability=\"conditional\">VlanPriority</ref> </metadataProduced> </product> </outputPort> </outputPorts> <components> <component componentID=\"1\" access=\"read-write\"> <name>EncapTable</name> <synopsis> An array table for Ethernet encapsulation information lookup. Each row of the array contains destination MAC address, source MAC address, VLAN ID, and output logical L2 port ID. </synopsis> <typeRef>EncapTableType</typeRef> </component> </components> </LFBClassDef> <LFBClassDef LFBClassID=\"7\"> <name>EtherMACOut</name> <synopsis> EtherMACOut LFB abstracts an Ethernet port at MAC data link layer. It specifically describes Ethernet packet process for output to physical port. A downstream LFB is usually an Ethernet physical LFB like EtherPHYCop LFB. Note that Ethernet output functions are closely related to Ethernet input functions; therefore, some components defined in this LFB are aliases of EtherMACIn LFB components. </synopsis>",
      "ja": "<参照> L2PortID </ ref>を</ metadataProduced> </製品> </出力ポート> <出力ポートグループ= \"偽\"> <名前> ExceptionOut </名前> <概要> LFBでのカプセル化に失敗したパケットの出力ポート。 ExceptionIDメタデータは、失敗の理由を示しています。 </シノプシス> <製品> <frameProduced> <参考文献>のIPv4 </ REF> <参考文献> IPv6の</ ref>を</ frameProduced> <metadataProduced> <参考文献> ExceptionID </ REF> <参考文献> MediaEncapInfoIndex </ REF> < REF可用性= \"条件\"> VlanPriority </ ref>を</ metadataProduced> </製品> </出力ポート> </ outputPorts> <成分> <コンポーネントのComponentID = \"1\" アクセス= \"読み書き\"> <名前> EncapTable </名前> <概要>イーサネットカプセル化情報検索用の配列テーブル。アレイの各行は、宛先MACアドレス、送信元MACアドレス、VLAN ID、および出力論理L2ポートIDを含んでいます。 </シノプシス> <typeRef> EncapTableType </ typeRef> </成分> </部品> </ LFBClassDef> <LFBClassDef LFBClassID = \"7\"> <名前> EtherMACOut </名前> <概要> EtherMACOut LFBは、イーサネットポートでの抽象化MACデータリンク層。これは、特に物理ポートへの出力のためのイーサネットパケット処理を記述しています。下流LFBは通常EtherPHYCop LFBのように、イーサネット物理LFBです。イーサネット・出力機能は密接イーサネット入力機能に関連していることに注意してください。従って、このLFBで定義されたいくつかのコンポーネントはEtherMACIn LFB成分の別名です。 </概要>"
    },
    {
      "indent": 9,
      "text": "<version>1.0</version> <inputPorts> <inputPort group=\"false\"> <name>EtherPktsIn</name> <synopsis> The input port of the EtherMACOut LFB. It expects any type of Ethernet frame. </synopsis> <expectation> <frameExpected> <ref>EthernetAll</ref> </frameExpected> <metadataExpected> <ref>PHYPortID</ref> </metadataExpected> </expectation> </inputPort> </inputPorts> <outputPorts> <outputPort group=\"false\"> <name>EtherPktsOut</name> <synopsis> A port to output all Ethernet packets, each with a metadata indicating the ID of the physical port that the packet is to go through. </synopsis> <product> <frameProduced> <ref>EthernetAll</ref> </frameProduced> <metadataProduced> <ref>PHYPortID</ref> </metadataProduced> </product> </outputPort> </outputPorts> <components> <component componentID=\"1\" access=\"read-write\"> <name>AdminStatus</name> <synopsis> The LFB status administratively requested, which has the same data type with a port status. The component is defined as an alias of AdminStatus component in EtherMACIn LFB. </synopsis> <alias>PortStatusType</alias> </component> <component componentID=\"2\" access=\"read-write\">",
      "ja": "<バージョン> 1.0 </バージョン> <inputPorts> <inputPort基= \"偽\"> <名前> EtherPktsIn </名前> <概要> EtherMACOut LFBの入力ポート。これは、イーサネットフレームのいずれかのタイプを期待しています。 </シノプシス> <期待> <frameExpected> <参考文献> EthernetAll </ ref>を</ frameExpected> <metadataExpected> <参考文献> PHYPortID </ ref>を</ metadataExpected> </期待> </ inputPort> </ inputPorts> < outputPorts> <出力ポートグループ=「偽」> <名前> EtherPktsOut </名前> <概要>を出力するポートすべてのイーサネットパケット、パケットが通過する物理ポートのIDを示すメタデータとのそれぞれ。 </シノプシス> <製品> <frameProduced> <参考文献> EthernetAll </ ref>を</ frameProduced> <metadataProduced> <参考文献> PHYPortID </ ref>を</ metadataProduced> </製品> </出力ポート> </ outputPorts> <ポートステータスと同じデータ型を持つ管理要求の成分> <コンポーネントのComponentID =「1」アクセス=「読み書き」> <名前>のAdminStatus </名前> <概要> LFBステータス、。成分はEtherMACIn LFBでのAdminStatus成分のエイリアスとして定義されます。 </シノプシス> <エイリアス> PortStatusType </エイリアス> </コンポーネント> <コンポーネントのComponentID = \"2\" アクセス= \"読み書き\">"
    },
    {
      "indent": 6,
      "text": " <name>MTU</name> <synopsis>Maximum transmission unit (MTU) </synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"3\" access=\"read-write\"> <name>TxFlowControl</name> <synopsis> A flag indicating whether transmit flow control is applied, defined as an alias of TxFlowControl component in EtherMACIn LFB. </synopsis> <optional/> <alias>boolean</alias> </component> <component componentID=\"4\" access=\"read-write\"> <name>RxFlowControl</name> <synopsis> A flag indicating whether receive flow control is applied, defined as an alias of RxFlowControl component in EtherMACIn LFB. </synopsis> <optional/> <alias>boolean</alias> </component> <component componentID=\"5\" access=\"read-reset\"> <name>MACOutStats</name> <synopsis> The statistics of the EtherMACOut LFB </synopsis> <optional/> <typeRef>MACOutStatsType</typeRef> </component> </components> </LFBClassDef> <LFBClassDef LFBClassID=\"8\"> <name>IPv4Validator</name> <synopsis> This LFB performs IPv4 validation according to RFC 1812 and its updates. The IPv4 packet will be output to the corresponding LFB port, indicating whether the packet is unicast or multicast or whether an exception has occurred or the validation failed. </synopsis> <version>1.0</version> <inputPorts> <inputPort> <name>ValidatePktsIn</name> <synopsis>",
      "ja": "<名前> MTU </名前> <概要>最大伝送単位（MTU）</シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\" アクセス= \"読み書き\"> <名前> TxFlowControl </名前> <概要>送信フロー制御がEtherMACIn LFBでTxFlowControl成分の別名として定義され、適用されるかどうかを示すフラグ。 </シノプシス> <オプション/> <エイリアス>ブール</エイリアス> </コンポーネント> <コンポーネントのComponentID = \"4\" のアクセス= \"読み書き\"> <名前> RxFlowControl </名前> <概要>かどうかを示すフラグフロー制御を受信すると、適用EtherMACIn LFBでRxFlowControl成分のエイリアスとして定義されます。 </シノプシス> <オプション/> <エイリアス>ブール</エイリアス> </コンポーネント> <コンポーネントのComponentID = \"5\" アクセス= \"読み取りリセット\"> <名前> MACOutStats </名前> <概要>の統計EtherMACOut LFB </シノプシス> <オプション/> <typeRef> MACOutStatsType </ typeRef> </成分> </部品> </ LFBClassDef> <LFBClassDef LFBClassID = \"8\"> <名前> IPv4Validator </名前> <概要>このLFBは、RFC 1812およびその更新に係るIPv4の検証を行います。 IPv4パケットは、パケットがユニキャストまたはマルチキャストまたは例外が発生したか、検証が失敗したかどうかを示す、対応するLFBポートに出力されます。 </概要> <バージョン> 1.0 </ version>の<inputPorts> <inputPort> <名前> ValidatePktsIn </名前> <概要>"
    },
    {
      "indent": 9,
      "text": " Input port for data packets to be validated </synopsis> <expectation> <frameExpected> <ref>Arbitrary</ref> </frameExpected> </expectation> </inputPort> </inputPorts> <outputPorts> <outputPort> <name>IPv4UnicastOut</name> <synopsis> Output port for validated IPv4 unicast packets </synopsis> <product> <frameProduced> <ref>IPv4Unicast</ref> </frameProduced> </product> </outputPort> <outputPort> <name>IPv4MulticastOut</name> <synopsis> Output port for validated IPv4 multicast packets </synopsis> <product> <frameProduced> <ref>IPv4Multicast</ref> </frameProduced> </product> </outputPort> <outputPort> <name>ExceptionOut</name> <synopsis> Output port for all packets with exceptional cases when validating. An ExceptionID metadata indicates the exception case type. </synopsis> <product> <frameProduced> <ref>IPv4</ref> </frameProduced> <metadataProduced> <ref>ExceptionID</ref> </metadataProduced> </product> </outputPort>",
      "ja": "データパケットの入力ポートを検証する</シノプシス> <期待> <frameExpected> <参考文献>任意</ ref>を</ frameExpected> </期待> </ inputPort> </ inputPorts> <outputPorts> <出力ポート> <名前> IPv4UnicastOut検証IPv4ユニキャストパケットの</名前> <概要>出力ポート</シノプシス> <製品> <frameProduced> <参考文献> IPv4Unicast </ ref>を</ frameProduced> </製品> </出力ポート> <出力ポート> <検証済みのIPv4マルチキャストパケットの名前> IPv4MulticastOut </名前> <概要>出力ポート</概要> <製品> <frameProduced> <ref>をIPv4Multicast </ ref>を</ frameProduced> </製品> </出力ポート> <出力ポート> <名前> ExceptionOut </名前> <概要>検証し、例外的なケースを持つすべてのパケットのための出力ポート。 ExceptionIDメタデータは、例外ケースの種類を示します。 </シノプシス> <製品> <frameProduced> <参考文献>のIPv4 </ ref>を</ frameProduced> <metadataProduced> <参考文献> ExceptionID </ ref>を</ metadataProduced> </製品> </出力ポート>"
    },
    {
      "indent": 6,
      "text": " <outputPort> <name>FailOut</name> <synopsis> Output port for packets that failed validating process. A ValidateErrorID metadata indicates the error type or failure reason. </synopsis> <product> <frameProduced> <ref>IPv4</ref> </frameProduced> <metadataProduced> <ref>ValidateErrorID</ref> </metadataProduced> </product> </outputPort> </outputPorts> <components> <component access=\"read-write\" componentID=\"1\"> <name>IPv4ValidatorStats</name> <synopsis> The statistics information for validating process in the LFB. </synopsis> <optional/> <typeRef>IPv4ValidatorStatsType</typeRef> </component> </components> </LFBClassDef> <LFBClassDef LFBClassID=\"9\"> <name>IPv6Validator</name> <synopsis> This LFB performs IPv6 validation according to RFC 2460 and its updates. Then, the IPv6 packet will be output to the corresponding port, indicating whether the packet is unicast or multicast or whether an exception has occurred or the validation failed. </synopsis> <version>1.0</version> <inputPorts> <inputPort> <name>ValidatePktsIn</name> <synopsis> Input port for data packets to be validated </synopsis> <expectation> <frameExpected> <ref>Arbitrary</ref>",
      "ja": "<出力ポート> <名前> FailOut </名前> <概要>プロセスを有効に失敗したパケットのための出力ポート。 ValidateErrorIDメタデータは、エラーのタイプや失敗の理由を示しています。 </シノプシス> <製品> <frameProduced> <参考文献>のIPv4 </ ref>を</ frameProduced> <metadataProduced> <参考文献> ValidateErrorID </ ref>を</ metadataProduced> </製品> </出力ポート> </ outputPorts> <成分> <成分アクセス=「読み書き」COMPONENTID =「1」> <名前> IPv4ValidatorStats </名前> <概要> LFBプロセスを検証するための統計情報。 </シノプシス> <オプション/> <typeRef> IPv4ValidatorStatsType </ typeRef> </成分> </部品> </ LFBClassDef> <LFBClassDef LFBClassID = \"9\"> <名前> IPv6Validator </名前> <概要>このLFBが実行RFC 2460およびその更新情報に基づいてIPv6の検証。次に、IPv6パケットは、パケットがユニキャストまたはマルチキャストまたは例外が発生したか、検証が失敗したかどうかを示す、対応するポートに出力されます。 </シノプシス>の<version> 1.0 </バージョン> <inputPorts> <inputPort> <名前> ValidatePktsIn </名前> <概要>データパケットの入力ポートが検証される</シノプシス> <期待> <frameExpected> <参考文献>任意の</ ref>を"
    },
    {
      "indent": 6,
      "text": " </frameExpected> </expectation> </inputPort> </inputPorts> <outputPorts> <outputPort> <name>IPv6UnicastOut</name> <synopsis> Output port for validated IPv6 unicast packets </synopsis> <product> <frameProduced> <ref>IPv6Unicast</ref> </frameProduced> </product> </outputPort> <outputPort> <name>IPv6MulticastOut</name> <synopsis> Output port for validated IPv6 multicast packets </synopsis> <product> <frameProduced> <ref>IPv6Multicast</ref> </frameProduced> </product> </outputPort> <outputPort> <name>ExceptionOut</name> <synopsis> Output port for packets with exceptional cases when validating. An ExceptionID metadata indicates the exception case type. </synopsis> <product> <frameProduced> <ref>IPv6</ref> </frameProduced> <metadataProduced> <ref>ExceptionID</ref> </metadataProduced> </product> </outputPort> <outputPort> <name>FailOut</name> <synopsis> Output port for packets failed validating process. A ValidateErrorID metadata indicates the error type or failure reason. </synopsis> <product> <frameProduced> <ref>IPv6</ref> </frameProduced> <metadataProduced> <ref>ValidateErrorID</ref> </metadataProduced> </product> </outputPort> </outputPorts> <components> <component access=\"read-write\" componentID=\"1\"> <name>IPv6ValidatorStats</name> <synopsis> The statistics information for validating process in the LFB. </synopsis> <optional/> <typeRef>IPv6ValidatorStatsType</typeRef> </component> </components> </LFBClassDef> <LFBClassDef LFBClassID=\"10\"> <name>IPv4UcastLPM</name> <synopsis> The IPv4UcastLPM LFB abstracts the IPv4 unicast Longest Prefix Match (LPM) process. This LFB supports implementing equal-cost multipath (ECMP) routing and reverse path forwarding (RPF). </synopsis> <version>1.0</version> <inputPorts> <inputPort group=\"false\"> <name>PktsIn</name> <synopsis> A port for input of packets to be processed. IPv4 unicast packets are expected. </synopsis> <expectation> <frameExpected> <ref>IPv4Unicast</ref> </frameExpected> </expectation> </inputPort> </inputPorts> <outputPorts>",
      "ja": "</ frameExpected> </期待> </ inputPort> </ inputPorts> <outputPorts> <出力ポート> <名前> IPv6UnicastOut </名前> <概要>検証IPv6ユニキャストパケットの出力ポート</シノプシス> <製品> <frameProduced> <参照> IPv6Unicast </ ref>を</ frameProduced> </製品> </出力ポート> <出力ポート> <名前> IPv6MulticastOut </概要> <製品> <frameProduced検証IPv6マルチキャストパケットのための</名前> <概要>出力ポート> <ref>をIPv6Multicast </ ref>を</ frameProduced> </製品> </出力ポート> <出力ポート> <名前> ExceptionOut </名前> <概要>検証し、例外的なケースでのパケットのための出力ポート。 ExceptionIDメタデータは、例外ケースの種類を示します。 </シノプシス> <製品> <frameProduced> <参考文献> IPv6の</ ref>を</ frameProduced> <metadataProduced> <参考文献> ExceptionID </ ref>を</ metadataProduced> </製品> </出力ポート> <出力ポート> <名前> FailOut </名前> <概要>パケットのための出力ポートは、プロセスの検証に失敗しました。 ValidateErrorIDメタデータは、エラーのタイプや失敗の理由を示しています。 </シノプシス> <製品> <frameProduced> <参考文献> IPv6の</ ref>を</ frameProduced> <metadataProduced> <参考文献> ValidateErrorID </ ref>を</ metadataProduced> </製品> </出力ポート> </ outputPorts> <成分> <成分アクセス=「読み書き」COMPONENTID =「1」> <名前> IPv6ValidatorStats </名前> <概要> LFBプロセスを検証するための統計情報。 </シノプシス> <オプション/> <typeRef> IPv6ValidatorStatsType </ typeRef> </成分> </部品> </ LFBClassDef> <LFBClassDef LFBClassID = \"10\"> <名前> IPv4UcastLPM </名前> <概要> IPv4UcastLPM LFB IPv4ユニキャスト最長プレフィックスマッチ（LPM）プロセスを抽象化します。このLFBは、等コストマルチパス（ECMP）ルーティングを実装し、転送（RPF）の経路を逆にサポートしています。 </シノプシス>の<version> 1.0 </バージョン> <inputPorts> <inputPort基= \"偽\"> <名前> PktsIn </名前> <概要>パケットの入力のためのポートを処理します。 IPv4ユニキャストパケットが期待されています。 </シノプシス> <期待> <frameExpected> <参考文献> IPv4Unicast </ ref>を</ frameExpected> </期待> </ inputPort> </ inputPorts> <outputPorts>"
    },
    {
      "indent": 12,
      "text": "<outputPort group=\"false\">\n   <name>NormalOut</name>\n   <synopsis>\n     An output port to output IPv4 unicast packets that\n     successfully passed the LPM lookup.  A HopSelector\n     metadata is produced to associate every output packet\n     for downstream LFB to do next-hop action.\n   </synopsis>\n   <product>\n      <frameProduced>\n         <ref>IPv4Unicast</ref>\n      </frameProduced>\n      <metadataProduced>\n         <ref>HopSelector</ref>\n      </metadataProduced>\n   </product>\n</outputPort>\n<outputPort group=\"false\">\n   <name>ECMPOut</name>\n   <synopsis>\n     The port to output packets needing further ECMP\n     processing.  A downstream ECMP processing LFB is\n     usually followed to the port.  If ECMP is not\n     required, no downstream LFB may be connected to\n     the port.\n   </synopsis>\n   <product>\n      <frameProduced>\n         <ref>IPv4Unicast</ref>\n      </frameProduced>\n      <metadataProduced>\n         <ref>HopSelector</ref>\n      </metadataProduced>\n   </product>\n</outputPort>\n<outputPort group=\"false\">\n   <name>ExceptionOut</name>\n   <synopsis>\n     The port to output all packets with exceptional cases\n     happened during LPM process.  An ExceptionID metadata\n     is associated to indicate what caused the exception.\n   </synopsis>\n   <product>\n      <frameProduced>\n         <ref>IPv4Unicast</ref>\n      </frameProduced>\n      <metadataProduced>\n         <ref>ExceptionID</ref>",
      "raw": true
    },
    {
      "indent": 6,
      "text": " </metadataProduced> </product> </outputPort> </outputPorts> <components> <component componentID=\"1\" access=\"read-write\"> <name>IPv4PrefixTable</name> <synopsis> A table for IPv4 Longest Prefix Match(LPM). The destination IPv4 address of every input packet is used as a search key to look up the table to find out a next-hop selector. </synopsis> <typeRef>IPv4PrefixTableType</typeRef> </component> <component componentID=\"2\" access=\"read-reset\"> <name>IPv4UcastLPMStats</name> <synopsis> The statistics information for the IPv4 unicast LPM process in the LFB. </synopsis> <optional/> <typeRef>IPv4UcastLPMStatsType</typeRef> </component> </components> </LFBClassDef> <LFBClassDef LFBClassID=\"11\"> <name>IPv6UcastLPM</name> <synopsis> The IPv6UcastLPM LFB abstracts the IPv6 unicast Longest Prefix Match (LPM) process. This LFB supports implementing equal-cost multipath (ECMP) routing and reverse path forwarding (RPF). </synopsis> <version>1.0</version> <inputPorts> <inputPort group=\"false\"> <name>PktsIn</name> <synopsis> A port for input of packets to be processed. IPv6 unicast packets are expected. </synopsis> <expectation> <frameExpected> <ref>IPv6Unicast</ref> </frameExpected> </expectation> </inputPort>",
      "ja": "IPv4の最長のための</ metadataProduced> </製品> </出力ポート> </ outputPorts> <成分> <コンポーネントのComponentID = \"1\" アクセス= \"読み書き\"> <名前> IPv4PrefixTable </名前> <概要>表プレフィックスマッチ（LPM）。すべての入力パケットの宛先IPv4アドレスは、ネクストホップセレクタを見つけるためにテーブルを検索し、検索キーとして使用されています。 </シノプシス> <typeRef> IPv4PrefixTableType </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\" アクセス= \"読み取りリセット\"> <名前> IPv4UcastLPMStats </名前> <概要> IPv4ユニキャストLPMの統計情報LFBでの処理。 </シノプシス> <オプション/> <typeRef> IPv4UcastLPMStatsType </ typeRef> </成分> </部品> </ LFBClassDef> <LFBClassDef LFBClassID = \"11\"> <名前> IPv6UcastLPM </名前> <概要> IPv6UcastLPM LFB IPv6ユニキャスト最長プレフィックスマッチ（LPM）プロセスを抽象化します。このLFBは、等コストマルチパス（ECMP）ルーティングを実装し、転送（RPF）の経路を逆にサポートしています。 </シノプシス>の<version> 1.0 </バージョン> <inputPorts> <inputPort基= \"偽\"> <名前> PktsIn </名前> <概要>パケットの入力のためのポートを処理します。 IPv6ユニキャストパケットが期待されています。 </シノプシス> <期待> <frameExpected> <参考文献> IPv6Unicast </ ref>を</ frameExpected> </期待> </ inputPort>"
    },
    {
      "indent": 9,
      "text": "</inputPorts> <outputPorts> <outputPort group=\"false\"> <name>NormalOut</name> <synopsis> An output port to output IPv6 unicast packets that successfully passed the LPM lookup. A HopSelector metadata is produced to associate every output packet for downstream LFB to do next-hop action. </synopsis> <product> <frameProduced> <ref>IPv6Unicast</ref> </frameProduced> <metadataProduced> <ref>HopSelector</ref> </metadataProduced> </product> </outputPort> <outputPort group=\"false\"> <name>ECMPOut</name> <synopsis> The port to output packets needing further ECMP processing. A downstream ECMP processing LFB is usually followed to the port. If ECMP is not required, no downstream LFB may be connected to the port. </synopsis> <product> <frameProduced> <ref>IPv6Unicast</ref> </frameProduced> <metadataProduced> <ref>HopSelector</ref> </metadataProduced> </product> </outputPort> <outputPort group=\"false\"> <name>ExceptionOut</name> <synopsis> The port to output all packets with exceptional cases happened during LPM process. An ExceptionID metadata is associated to indicate what caused the exception. </synopsis> <product> <frameProduced> <ref>IPv6Unicast</ref> </frameProduced>",
      "ja": "</ inputPorts> <outputPorts> <出力ポートグループ= \"偽\"> <名前> NormalOut </名前> <概要>出力ポートに成功LPM検索を通過した出力IPv6ユニキャストパケットに。 HopSelectorメタデータは、ネクストホップのアクションを行うために、下流LFBごとに出力パケットを関連付けるために作成されます。 </シノプシス> <製品> <frameProduced> <参考文献> IPv6Unicast </ ref>を</ frameProduced> <metadataProduced> <参考文献> HopSelector </ ref>を</ metadataProduced> </製品> </出力ポート> <出力ポートグループ=」偽 \"> <名前> ECMPOut </名前> <概要>さらにECMP処理を必要とする出力パケットのポート。下流ECMP処理LFBは、通常のポートに続きます。 ECMPが必要とされていない場合、下流LFBは、ポートに接続することはできません。 </シノプシス> <製品> <frameProduced> <参考文献> IPv6Unicast </ ref>を</ frameProduced> <metadataProduced> <参考文献> HopSelector </ ref>を</ metadataProduced> </製品> </出力ポート> <出力ポートグループ=」偽 \"> <名前> ExceptionOut </名前> <概要>を出力するポート例外的なケースを持つすべてのパケットがLPM処理中に起こりました。 ExceptionIDメタデータは、例外の原因を示すために関連付けられています。 </概要> </ frameProduced> <REF /> <製品> <frameProduced> <参考文献> IPv6Unicast"
    },
    {
      "indent": 6,
      "text": " <metadataProduced> <ref>ExceptionID</ref> </metadataProduced> </product> </outputPort> </outputPorts> <components> <component componentID=\"1\" access=\"read-write\"> <name>IPv6PrefixTable</name> <synopsis> A table for IPv6 Longest Prefix Match (LPM). The destination IPv6 address of every input packet is used as a search key to look up the table to find out a next-hop selector. </synopsis> <typeRef>IPv6PrefixTableType</typeRef> </component> <component componentID=\"2\" access=\"read-reset\"> <name>IPv6UcastLPMStats</name> <synopsis> The statistics information for the IPv6 unicast LPM process in the LFB. </synopsis> <optional/> <typeRef>IPv6UcastLPMStatsType</typeRef> </component> </components> </LFBClassDef> <LFBClassDef LFBClassID=\"12\"> <name>IPv4NextHop</name> <synopsis> The IPv4NextHop LFB abstracts the process of next-hop information application to IPv4 packets. It receives an IPv4 packet with an associated next-hop identifier (HopSelector) and uses the identifier as a table index to look up a next-hop table to find an appropriate output port. The data processing also involves the forwarding TTL decrement and IP checksum recalculation. </synopsis> <version>1.0</version> <inputPorts> <inputPort group=\"false\"> <name>PktsIn</name> <synopsis> A port for input of unicast IPv4 packets, along with a HopSelector metadata. </synopsis> <expectation>",
      "ja": "<metadataProduced> <参考文献> ExceptionID </ ref>を</ metadataProduced> </製品> </出力ポート> </ outputPorts> <成分> <コンポーネントのComponentID = \"1\" アクセス= \"読み書き\"> <名前> IPv6PrefixTable < / IPv6の最長プレフィックスマッチ（LPM）の名前> <概要>表。すべての入力パケットの宛先IPv6アドレスは、ネクストホップセレクタを見つけるためにテーブルを検索し、検索キーとして使用されています。 </シノプシス> <typeRef> IPv6PrefixTableType </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\" アクセス= \"読み取りリセット\"> <名前> IPv6UcastLPMStats </名前> <概要> IPv6ユニキャストLPMの統計情報LFBでの処理。 </シノプシス> <オプション/> <typeRef> IPv6UcastLPMStatsType </ typeRef> </成分> </部品> </ LFBClassDef> <LFBClassDef LFBClassID = \"12\"> <名前> IPv4NextHop </名前> <概要> IPv4NextHop LFB IPv4パケットの次のホップ情報アプリケーションのプロセスを抽象化。これは、関連する次ホップ識別子（HopSelector）でIPv4パケットを受信し、適切な出力ポートを見つけるために次ホップテーブルをルックアップテーブルのインデックスとして識別子を使用します。データ処理も転送TTLの減少とIPチェックサムの再計算を必要とします。 </シノプシス>の<version> 1.0 </バージョン> <inputPorts> <inputPort基= \"偽\"> <名前> HopSelectorメタデータと共にPktsIn </名前> <概要>ユニキャストIPv4パケットの入力用ポート、。 </概要> <期待>"
    },
    {
      "indent": 9,
      "text": " <frameExpected> <ref>IPv4Unicast</ref> </frameExpected> <metadataExpected> <ref>HopSelector</ref> </metadataExpected> </expectation> </inputPort> </inputPorts> <outputPorts> <outputPort group=\"true\"> <name>SuccessOut</name> <synopsis> The group port for output of packets that successfully found next-hop information. Some metadata are associated with every packet. </synopsis> <product> <frameProduced> <ref>IPv4Unicast</ref> </frameProduced> <metadataProduced> <ref>L3PortID</ref> <ref>NextHopIPv4Addr</ref> <ref availability=\"conditional\"> MediaEncapInfoIndex</ref> </metadataProduced> </product> </outputPort> <outputPort group=\"false\"> <name>ExceptionOut</name> <synopsis> The output port for packets with exceptional or failure cases. An ExceptionID metadata indicates what caused the case. </synopsis> <product> <frameProduced> <ref>IPv4Unicast</ref> </frameProduced> <metadataProduced> <ref>ExceptionID</ref> </metadataProduced> </product> </outputPort> </outputPorts> <components> <component componentID=\"1\">",
      "ja": "<frameExpected> <参考文献> IPv4Unicast </ ref>を</ frameExpected> <metadataExpected> <参考文献> HopSelector </ ref>を</ metadataExpected> </期待> </ inputPort> </ inputPorts> <outputPorts> <出力ポートグループ=」成功したネクストホップ情報を発見したパケットの出力のための真の \"> <名前> SuccessOut </名前> <概要>グループポート。いくつかのメタデータは、すべてのパケットに関連付けられています。 </シノプシス> <製品> <frameProduced> <参考文献> IPv4Unicast </ ref>を</ frameProduced> <metadataProduced> <参考文献> L3PortID </ REF> <参考文献> NextHopIPv4Addr </ REF> <REF可用性= \"条件\"> MediaEncapInfoIndex </ ref>を</ metadataProduced> </製品> </出力ポート> <出力ポートグループ= \"偽\"> <名前> ExceptionOut </名前> <概要>例外的または故障の場合のパケットのための出力ポート。 ExceptionIDメタデータには、ケースを引き起こしたかを示します。 </シノプシス> <製品> <frameProduced> <参考文献> IPv4Unicast </ ref>を</ frameProduced> <metadataProduced> <参考文献> ExceptionID </ ref>を</ metadataProduced> </製品> </出力ポート> </ outputPorts> <成分> <コンポーネントのComponentID = \"1\">"
    },
    {
      "indent": 6,
      "text": " <name>IPv4NextHopTable</name> <synopsis> The IPv4NextHopTable component. A HopSelector is used to match the table index to find out a row that contains the next-hop information result. </synopsis> <typeRef>IPv4NextHopTableType</typeRef> </component> </components> </LFBClassDef> <LFBClassDef LFBClassID=\"13\"> <name>IPv6NextHop</name> <synopsis> The LFB abstracts the process of next-hop information application to IPv6 packets. It receives an IPv6 packet with an associated next-hop identifier (HopSelector) and uses the identifier as a table index to look up a next-hop table to find an appropriate output port. </synopsis> <version>1.0</version> <inputPorts> <inputPort group=\"false\"> <name>PktsIn</name> <synopsis> A port for input of unicast IPv6 packets, along with a HopSelector metadata. </synopsis> <expectation> <frameExpected> <ref>IPv6Unicast</ref> </frameExpected> <metadataExpected> <ref>HopSelector</ref> </metadataExpected> </expectation> </inputPort> </inputPorts> <outputPorts> <outputPort group=\"true\"> <name>SuccessOut</name> <synopsis> The group port for output of packets that successfully found next-hop information. Some metadata are associated with every packet. </synopsis> <product> <frameProduced>",
      "ja": "<名前> IPv4NextHopTable </名前> <概要> IPv4NextHopTableコンポーネント。 HopSelectorは、ネクストホップ情報の結果を含む行を見つけるためにテーブルインデックスを一致させるために使用されます。 </シノプシス> <typeRef> IPv4NextHopTableType </ typeRef> </成分> </部品> </ LFBClassDef> <LFBClassDef LFBClassID = \"13\"> <名前> IPv6NextHop </名前> <概要> LFBは、次のプロセスを抽象化IPv6パケットに情報アプリケーションを-hop。これは、関連する次ホップ識別子（HopSelector）とIPv6パケットを受信し、適切な出力ポートを見つけるために次ホップテーブルをルックアップテーブルのインデックスとして識別子を使用します。 </シノプシス>の<version> 1.0 </バージョン> <inputPorts> <inputPort基= \"偽\"> <名前> HopSelectorメタデータと共にPktsIn </名前> <概要>ユニキャストIPv6パケットの入力用ポート、。 </シノプシス> <期待> <frameExpected> <参考文献> IPv6Unicast </ ref>を</ frameExpected> <metadataExpected> <参考文献> HopSelector </ ref>を</ metadataExpected> </期待> </ inputPort> </ inputPorts> <成功したネクストホップ情報を発見したパケットを出力するためのoutputPorts> <出力ポートグループ=「真」> <名前> SuccessOut </名前> <概要>グループポート。いくつかのメタデータは、すべてのパケットに関連付けられています。 </概要> <製品> <frameProduced>"
    },
    {
      "indent": 6,
      "text": " <ref>IPv6Unicast</ref> </frameProduced> <metadataProduced> <ref>L3PortID</ref> <ref>NextHopIPv6Addr</ref> <ref availability=\"conditional\"> MediaEncapInfoIndex</ref> </metadataProduced> </product> </outputPort> <outputPort group=\"false\"> <name>ExceptionOut</name> <synopsis> The output port for packets with exceptional or failure cases. An ExceptionID metadata indicates what caused the case. </synopsis> <product> <frameProduced> <ref>IPv6Unicast</ref> </frameProduced> <metadataProduced> <ref>ExceptionID</ref> </metadataProduced> </product> </outputPort> </outputPorts> <components> <component componentID=\"1\"> <name>IPv6NextHopTable</name> <synopsis> The IPv6NextHopTable component. A HopSelector is used to match the table index to find out a row that contains the next-hop information result. </synopsis> <typeRef>IPv6NextHopTableType</typeRef> </component> </components> </LFBClassDef> <LFBClassDef LFBClassID=\"14\"> <name>RedirectIn</name> <synopsis> The RedirectIn LFB abstracts the process for the ForCES CE to inject data packets into the ForCES FE LFBs. </synopsis> <version>1.0</version> <outputPorts> <outputPort group=\"true\">",
      "ja": "<参考文献> IPv6Unicast </ ref>を</ frameProduced> <metadataProduced> <参考文献> L3PortID </ REF> <参考文献> NextHopIPv6Addr </ REF> <REF可用性= \"条件\"> MediaEncapInfoIndex </ ref>を</ metadataProduced> </製品> </出力ポート> <出力ポートグループ=「偽」> <名前> ExceptionOut </名前> <概要>例外や失敗例とパケットのための出力ポート。 ExceptionIDメタデータには、ケースを引き起こしたかを示します。 </シノプシス> <製品> <frameProduced> <参考文献> IPv6Unicast </ ref>を</ frameProduced> <metadataProduced> <参考文献> ExceptionID </ ref>を</ metadataProduced> </製品> </出力ポート> </ outputPorts> <成分> <コンポーネントのComponentID = \"1\"> <名前> IPv6NextHopTable </名前> <概要> IPv6NextHopTableコンポーネント。 HopSelectorは、ネクストホップ情報の結果を含む行を見つけるためにテーブルインデックスを一致させるために使用されます。 </シノプシス> <typeRef> IPv6NextHopTableType </ typeRef> </成分> </部品> </ LFBClassDef> <LFBClassDef LFBClassID = \"14\"> <名前> RedirectIn </名前> <概要> RedirectIn LFBのためのプロセスを抽象化ForCES FE LFBsにデータパケットを注入するのForCES CE。 </概要> <バージョン> 1.0 </ version>の<outputPorts> <出力ポートグループ= \"真\">"
    },
    {
      "indent": 6,
      "text": " <name>PktsOut</name> <synopsis> The output port of RedirectIn LFB, which is defined as a group port type. From the LFB topology's point of view, the RedirectIn LFB acts as a source point for data packets coming from CE; therefore, the LFB is defined with a singleton output port (and no input port). </synopsis> <product> <frameProduced> <ref>Arbitrary</ref> </frameProduced> </product> </outputPort> </outputPorts> <components> <component componentID=\"1\"> <name>NumPacketsReceived</name> <synopsis> Number of packets received from CE. </synopsis> <optional/> <typeRef>uint64</typeRef> </component> </components> </LFBClassDef> <LFBClassDef LFBClassID=\"15\"> <name>RedirectOut</name> <synopsis> The RedirectOut LFB abstracts the process for LFBs in a ForCES FE to deliver data packets to the ForCES CE. </synopsis> <version>1.0</version> <inputPorts> <inputPort group=\"false\"> <name>PktsIn</name> <synopsis> The input port for the RedirectOut LFB. From the LFB topology's point of view, the RedirectOut LFB acts as a sink point for data packets going to the CE; therefore, RedirectOut LFB is defined with a singleton input port (and no output port). </synopsis> <expectation> <frameExpected> <ref>Arbitrary</ref> </frameExpected>",
      "ja": "<名前> PktsOut </名前> <概要>グループのポートタイプとして定義されRedirectIn LFBの出力ポート。ビューのLFBトポロジの観点から、RedirectIn LFBは、CEからのデータ・パケットのソース・ポイントとして機能します。従って、LFBはシングルトン出力ポート（無入力ポート）で定義されています。 </シノプシス> <製品> <frameProduced> <参考文献>任意</ ref>を</ frameProduced> </製品> </出力ポート> </ outputPorts> <成分> <コンポーネントのComponentID = \"1\"> <名前> NumPacketsReceived < /名前> <概要>パケットの数は、CEから受信しました。 </シノプシス> <オプション/> <typeRef> UINT64 </ typeRef> </成分> </部品> </ LFBClassDef> <LFBClassDef LFBClassID = \"15\"> <名前> RedirectOut </名前> <概要> RedirectOut LFB ForCES CEへのデータパケットを配信に力FEでLFBsするためのプロセスを抽象化します。 </概要> <バージョン> 1.0 </ version>の<inputPorts> <inputPortグループ= \"偽\"> <名前> PktsIn </名前> <概要> RedirectOut LFBの入力ポート。ビューのLFBトポロジの観点から、RedirectOut LFBはCEに行くデータパケットのためのシンク・ポイントとして機能します。従って、RedirectOut LFBはシングルトン入力ポート（なし出力ポート）で定義されています。 </シノプシス> <期待> <frameExpected> <参考文献>任意</ ref>を</ frameExpected>"
    },
    {
      "indent": 6,
      "text": " </expectation> </inputPort> </inputPorts> <components> <component componentID=\"1\"> <name>NumPacketsSent</name> <synopsis> Number of packets sent to CE. </synopsis> <optional/> <typeRef>uint64</typeRef> </component> </components> </LFBClassDef> <LFBClassDef LFBClassID=\"16\"> <name>BasicMetadataDispatch</name> <synopsis> The BasicMetadataDispatch LFB is defined to abstract the process by which packets are dispatched to various output paths based on associated metadata value. Current version of the LFB only allows the metadata value to be a 32-bit integer. </synopsis> <version>1.0</version> <inputPorts> <inputPort> <name>PktsIn</name> <synopsis> The packet input port for dispatching. Every input packet should be associated with a metadata that will be used by the LFB to do the dispatch. </synopsis> <expectation> <frameExpected> <ref>Arbitrary</ref> </frameExpected> <metadataExpected> <ref>Arbitrary</ref> </metadataExpected> </expectation> </inputPort> </inputPorts> <outputPorts> <outputPort group=\"true\"> <name>PktsOut</name> <synopsis> The group output port that outputs dispatching results. A packet with its associated metadata having found an OutputIndex by successfully looking up the dispatch table will be output to the group port instance with the corresponding index. </synopsis> <product> <frameProduced> <ref>Arbitrary</ref> </frameProduced> </product> </outputPort> <outputPort group=\"false\"> <name>ExceptionOut</name> <synopsis> The output port that outputs packets that failed to process. An ExceptionID metadata indicates what caused the exception. </synopsis> <product> <frameProduced> <ref>Arbitrary</ref> </frameProduced> <metadataProduced> <ref>ExceptionID</ref> </metadataProduced> </product> </outputPort> </outputPorts> <components> <component access=\"read-write\" componentID=\"1\"> <name>MetadataID</name> <synopsis> The ID of the metadata to be used for dispatching packets. </synopsis> <typeRef>uint32</typeRef> </component> <component access=\"read-write\" componentID=\"2\"> <name>MetadataDispatchTable</name> <synopsis> The MetadataDispatchTable component, which contains entries of a metadata value and an output index, specifying that a packet with the metadata value must go out from the instance with the output index of the LFB group output port. </synopsis> <typeRef>MetadataDispatchTableType</typeRef> </component> </components>",
      "ja": "</期待> </ inputPort> </ inputPorts> <成分> <コンポーネントのComponentID = \"1\"> <名前> NumPacketsSent </名前> <概要> CEに送信されたパケットの数。 </シノプシス> <オプション/> <typeRef> UINT64 </ typeRef> </成分> </部品> </ LFBClassDef> <LFBClassDef LFBClassID = \"16\"> <名前> BasicMetadataDispatch </名前> <概要> BasicMetadataDispatch LFBパケットが関連付けられているメタデータ値に基づいて、様々な出力パスにディスパッチされる抽象プロセスに定義されています。 LFBの現在のバージョンは、メタデータの値は32ビット整数にすることができます。 </概要> <バージョン> 1.0 </ version>の<inputPorts> <inputPort> <名前> PktsIn </名前> <概要>派遣のためのパケット入力ポート。すべての入力パケットは、派遣を行うためにLFBによって使用されるメタデータに関連付けられている必要があります。 </シノプシス> <期待> <frameExpected> <参考文献>任意</ ref>を</ frameExpected> <metadataExpected> <参考文献>任意</ ref>を</ metadataExpected> </期待> </ inputPort> </ inputPorts> <派遣の結果を出力outputPorts> <出力ポートグループ=「真」> <名前> PktsOut </名前> <概要>グループ出力ポート。その関連するメタデータを有するパケットが正常に対応するインデックスとグループポートインスタンスに出力されるディスパッチ・テーブルを調べることによってOutputIndexを発見しました。 </概要> <製品> <frameProduced> <ref>を任意の</ ref>を</ frameProduced> </製品> </出力ポート> <出力ポートグループ= \"偽\"> <名前> ExceptionOut </名前> <概要>処理に失敗したパケットを出力する出力ポート。 ExceptionIDメタデータは、例外を発生させたかを示します。 </シノプシス> <製品> <frameProduced> <参考文献>任意</ ref>を</ frameProduced> <metadataProduced> <参考文献> ExceptionID </ ref>を</ metadataProduced> </製品> </出力ポート> </ outputPorts> <成分> <成分アクセス=「読み書き」COMPONENTID =「1」> <名前> MetadataID </名前> <概要>メタデータのIDパケットをディスパッチするために使用されます。 </シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <成分アクセス= \"読み書き\" COMPONENTID = \"2\"> <名前> MetadataDispatchTable </名前> <概要>のエントリが含まMetadataDispatchTable成分、メタデータの値と出力インデックス、メタデータ値を持つパケットはLFBグループ出力ポートの出力インデックスにインスタンスから出て行かなければならないことを指定します。 </シノプシス> <typeRef> MetadataDispatchTableType </ typeRef> </成分> </部品>"
    },
    {
      "indent": 6,
      "text": " </LFBClassDef> <LFBClassDef LFBClassID=\"17\"> <name>GenericScheduler</name> <synopsis> This is a preliminary generic scheduler LFB abstracting a simple scheduling process, which may be used as a basic LFB to construct a more complex scheduler LFB. </synopsis> <version>1.0</version> <inputPorts> <inputPort group=\"true\"> <name>PktsIn</name> <synopsis> The group input port of the LFB. Inside the LFB, each instance of the group port is connected to a queue marked with a queue ID, whose value is index of the port instance. </synopsis> <expectation> <frameExpected> <ref>Arbitrary</ref> </frameExpected> </expectation> </inputPort> </inputPorts> <outputPorts> <outputPort> <name>PktsOut</name> <synopsis> The output port of the LFB. Scheduled packets are output from the port. </synopsis> <product> <frameProduced> <ref>Arbitrary</ref> </frameProduced> </product> </outputPort> </outputPorts> <components> <component access=\"read-write\" componentID=\"1\"> <name>SchedulingDiscipline</name> <synopsis> The SchedulingDiscipline component, which is for the CE to specify a scheduling discipline to the LFB. </synopsis> <typeRef>SchdDisciplineType</typeRef> <defaultValue>1</defaultValue>",
      "ja": "</ LFBClassDef> <LFBClassDef LFBClassID =「17」> <名前> GenericScheduler </名前> <概要>これは、より複雑なスケジューラを構築するための基本的なLFBとして使用することができるシンプルなスケジューリングプロセスを抽象化予備ジェネリックスケジューラLFB、ありますLFB。 </シノプシス>の<version> 1.0 </バージョン> <inputPorts> <inputPort基= \"真\"> <名前> PktsIn </名前> <概要> LFBのグループ入力ポート。 LFBの内部では、グループのポートの各インスタンスは、その値がポートインスタンスのインデックスであるキューIDでマークキューに接続されています。 </シノプシス> <期待> <frameExpected> <参考文献>任意</ ref>を</ frameExpected> </期待> </ inputPort> </ inputPorts> <outputPorts> <出力ポート> <名前> PktsOut </名前> <概要> LFBの出力ポート。スケジュールパケットがポートから出力されます。 </シノプシス> <製品> <frameProduced> <参考文献>任意</ ref>を</ frameProduced> </製品> </出力ポート> </ outputPorts> <成分> <成分アクセス= \"読み書き\" COMPONENTID = \"1 LFBにスケジューリング規律を指定するCE用です「> <名前> SchedulingDiscipline </名前> <概要> SchedulingDisciplineコンポーネント、。 </シノプシス> <typeRef> SchdDisciplineType </ typeRef> <はdefaultValue> 1 </はdefaultValue>"
    },
    {
      "indent": 0,
      "text": " </component> <component access=\"read-only\" componentID=\"2\"> <name>QueueStats</name> <synopsis> The QueueStats component, which is defined to allow the CE to query every queue statistics in the scheduler. </synopsis> <optional/> <typeRef>QueueStatsTableType</typeRef> </component> </components> <capabilities> <capability componentID=\"30\"> <name>QueueLenLimit</name> <synopsis> The QueueLenLimit capability, which specifies maximum length of each queue. The length unit is in bytes. </synopsis> <typeRef>uint32</typeRef> </capability> </capabilities> </LFBClassDef> </LFBClassDefs> </LFBLibrary>",
      "ja": "</コンポーネント> <コンポーネントアクセス=「読み取り専用」COMPONENTID =「2」> <名前> QueueStats </名前> <概要> CEは、スケジューラ内のすべてのキューの統計情報を照会できるようにするために定義されてQueueStatsコンポーネント、。 </シノプシス> <オプション/> <typeRef> QueueStatsTableType </ typeRef> </成分> </部品> <機能> <能力COMPONENTID = \"30\"> <名前> QueueLenLimit </名前> <概要> QueueLenLimit能力、これは各キューの最大長を指定します。長さの単位はバイトです。 </概要> <typeRef> UINT32 </ typeRef> </機能> </機能> </ LFBClassDef> </ LFBClassDefs> </ LFBLibrary>"
    },
    {
      "indent": 0,
      "text": "7. LFB Class Use Cases",
      "section_title": true,
      "ja": "7. LFBクラスのユースケース"
    },
    {
      "indent": 3,
      "text": "This section demonstrates examples on how the LFB classes defined by the base LFB library in Section 6 can be applied to achieve some typical router functions. The functions demonstrated are:",
      "ja": "このセクションでは、第6節でベースLFBライブラリで定義されたLFBクラスは、いくつかの一般的なルータ機能を達成するために適用することができます方法の例を示しています。示された機能は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o IPv4 forwarding",
      "ja": "OのIPv4フォワーディング"
    },
    {
      "indent": 3,
      "text": "o ARP processing",
      "ja": "O ARP処理"
    },
    {
      "indent": 3,
      "text": "It is assumed the LFB topology on the FE described has already been established by the CE and maps to the use cases illustrated in this section.",
      "ja": "FEのLFBトポロジー記述は既にこのセクションに示されているユースケースにCEやマップによって確立されたと想定されます。"
    },
    {
      "indent": 3,
      "text": "The use cases demonstrated in this section are mere examples and by no means should be treated as the only way one would construct router functionality from LFBs; based on the capability of the FE(s), a CE should be able to express different NE applications.",
      "ja": "この節において明らかにユースケースは、単なる例であり、決して一つLFBsからルータ機能を構築することになる唯一の方法として扱われるべきです。 FE（S）の能力に基づいて、CEは、異なるNEのアプリケーションを表現することができなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.1. IPv4 Forwarding",
      "section_title": true,
      "ja": "7.1。 IPv4の転送"
    },
    {
      "indent": 3,
      "text": "Figure 2 shows the typical LFB processing path for an IPv4 unicast forwarding case with Ethernet media interfaces by use of the base LFB classes. Note that in the figure, to focus on the IP forwarding function, some inputs or outputs of LFBs that are not related to the IPv4 forwarding function are not shown. For example, an EtherClassifier LFB normally has two output ports: a \"ClassifyOut\" group output port and an \"ExceptionOut\" singleton output port, with the group port containing various port instances according to various classified packet types (Section 5.1.3). In this figure, only the IPv4 and IPv6 packet output port instances are shown for displaying the mere IPv4 forwarding processing function.",
      "ja": "図2は、基地LFBクラスを使用することによって、イーサネット・メディア・インタフェースを備えたIPv4ユニキャスト転送の場合の典型的なLFB処理経路を示しています。 IPフォワーディング機能に焦点を当てるために、図中なお、IPv4の転送機能に関連していないLFBsのいくつかの入力または出力は示されていません。様々な分類のパケットタイプ（セクション5.1.3）に応じて様々なポートのインスタンスを含むグループのポートと、「ClassifyOut」基出力ポートと「ExceptionOut」シングルトン出力ポート：例えば、EtherClassifier LFBは、通常、二つの出力ポートを有しています。この図では、のみ、IPv4とIPv6パケット出力ポートインスタンスは単なるIPv4転送処理機能を表示するために示されています。"
    },
    {
      "indent": 3,
      "text": "+-----+                +------+\n|     |                |      |\n|     |<---------------|Ether |<----------------------------+\n|     |                |MACOut|                             |\n|     |                |      |                             |\n|Ether|                +------+                             |\n|PHY  |                                                     |\n|Cop  |            +---+                                    |\n|#1   |  +-----+   |   |----->IPv6 Packets                  |\n|     |  |     |   |   |                                    |\n|     |  |Ether|   |   | IPv4 Packets                       |\n|     |->|MACIn|-->|   |-+  +----+                          |\n+-----+  |     |   |   | |  |    |---> Multicast Packets    |\n         +-----+   +---+ |  |    |        +-----+  +---+    |\n                   Ether +->|    |------->|     |  |   |    |\n   .           Classifier|  |    |Unicast |IPv4 |  |   |    |\n   .                     |  |    |Packets |Ucast|->|   |--+ |\n   .                     |  +----+        |LPM  |  |   |  | |\n                   +---+ |   IPv4         +-----+  +---+  | |\n         +-----+   |   | |   Validator              IPv4  | |\n         |     |   |   | |                         NextHop| |\n+-----+  |Ether|   |   |-+ IPv4 Packets                   | |\n|     |->|MACIn|-->|   |                                  | |\n|     |  |     |   |   |----->IPv6 Packets                | |\n|Ether|  +-----+   +---+                                  | |\n|PHY  |           Ether               +----+              | |\n|Cop  |           Classifier          |    |   +-------+  | |\n|#n   |                +------+       |    |   |Ether  |  | |\n|     |                |      |       |    |<--|Encap  |<-+ |\n|     |                |      |<------|    |   |       |    |\n|     |<---------------|Ether |    ...|    |   +-------+    |\n|     |                |MACOut|   +---|    |                |\n|     |                |      |   |   +----+                |\n+-----+                +------+   | BasicMetadataDispatch   |\n                                  +----------->-------------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 2: LFB Use Case for IPv4 Forwarding",
      "ja": "図2：IPv4の転送のためのLFBユースケース"
    },
    {
      "indent": 3,
      "text": "In the LFB use case, a number of EtherPHYCop LFB (Section 5.1.1) instances are used to describe physical-layer functions of the ports. PHYPortID metadata is generated by the EtherPHYCop LFB and is used by all the subsequent downstream LFBs. An EtherMACIn LFB (Section 5.1.2), which describes the MAC-layer processing, follows every EtherPHYCop LFB. The EtherMACIn LFB may do a locality check of MAC addresses if the CE configures the appropriate EtherMACIn LFB component.",
      "ja": "LFBユースケースでは、EtherPHYCop LFB（セクション5.1.1）インスタンスの数は、ポートの物理層の機能を記述するために使用されます。 PHYPortIDメタデータはEtherPHYCop LFBによって生成され、それ以降のすべての下流LFBsによって使用されます。 MAC層処理を説明EtherMACIn LFB（セクション5.1.2）は、すべてのEtherPHYCop LFBに従います。 CEは、適切なEtherMACIn LFBコンポーネントを構成した場合EtherMACIn LFBは、MACアドレスの局所性チェックを行うことができます。"
    },
    {
      "indent": 3,
      "text": "Ethernet packets out of the EtherMACIn LFB are sent to an EtherClassifier LFB (Section 5.1.3) to be decapsulated and classified into network-layer types like IPv4, IPv6, ARP, etc. In the example use case, every physical Ethernet interface is associated with one Classifier instance; although not illustrated, it is also feasible that all physical interfaces are associated with only one Ethernet Classifier instance.",
      "ja": "EtherMACIn LFBのうちイーサネットパケットはデカプセル化等使用事例ではIPv4、IPv6の、ARP、のようなネットワーク層のタイプに分類されるEtherClassifier LFB（セクション5.1.3）に送信され、すべての物理イーサネットインターフェイスは、関連付けられています1つの分類子インスタンスを持ちます。図示しないが、すべての物理インターフェイスが一つだけのイーサネット分類子インスタンスに関連付けられていることも可能です。"
    },
    {
      "indent": 3,
      "text": "EtherClassifier uses the PHYPortID metadata, the Ethernet type of the input packet, and VlanID (if present in the input Ethernet packets) to decide the packet network-layer type and the LFB output port to the downstream LFB. The EtherClassifier LFB also assigns a new logical port ID metadata to the packet for later use. The EtherClassifier may also generate some new metadata for every packet, like EtherType, SrcMAC, DstMAC, LogicPortID, etc., for consumption by downstream LFBs.",
      "ja": "EtherClassifier下流LFBにパケットネットワーク層型とLFB出力ポートを決定するPHYPortIDメタデータ、入力パケットのイーサネット（登録商標）タイプ、及びVLANID（入力イーサネットパケット中に存在する場合）を使用します。 EtherClassifier LFBはまた後で使用するためのパケットに新しい論理ポートIDメタデータを割り当てます。 EtherClassifierも下流LFBsによる消費のために、などのEtherType、SrcMAC、DstMAC、LogicPortID、のように、すべてのパケットのためのいくつかの新しいメタデータを生成してもよいです。"
    },
    {
      "indent": 3,
      "text": "If a packet is classified as an IPv4 packet, it is sent downstream to an IPv4Validator LFB (Section 5.2.1) to validate the IPv4 packet. In the validator LFB, IPv4 packets are validated and are additionally classified into either IPv4 unicast packets or multicast packets. IPv4 unicast packets are sent to downstream to the IPv4UcastLPM LFB (Section 5.3.1).",
      "ja": "パケットは、IPv4パケットとして分類されている場合は、IPv4パケットを検証するIPv4Validator LFB（5.2.1）の下流に送られます。バリデータLFBにおいて、IPv4パケットが検証され、さらにIPv4ユニキャストパケット又はマルチキャストパケットのいずれかに分類されます。 IPv4ユニキャストパケットはIPv4UcastLPM LFB（セクション5.3.1）に下流に送られます。"
    },
    {
      "indent": 3,
      "text": "The IPv4UcastLPM LFB is where the longest prefix match decision is made, and a next-hop selection is selected. The next-hop ID metadata is generated by the IPv4UcastLPM LFB to be consumed downstream by the IPv4NextHop LFB (Section 5.3.2).",
      "ja": "IPv4UcastLPM LFBは、最長プレフィックス一致の決定がなされ、次ホップ選択が選択されているところです。 IPv4UcastLPM LFBによって生成されたネクストホップIDメタデータはIPv4NextHop LFB（セクション5.3.2）によって下流消費されます。"
    },
    {
      "indent": 3,
      "text": "The IPv4NextHop LFB uses the next-hop ID metadata to derive where the packet is to go next and the media encapsulation type for the port, etc. The IPv4NextHop LFB generates the L3PortID metadata used to identify a next-hop output physical/logical port. In the example use case, the next-hop output port is an Ethernet type; as a result, the packet and its L3 port ID metadata are sent downstream to an EtherEncap LFB (Section 5.1.4).",
      "ja": "IPv4NextHop LFBはIPv4NextHop LFBは、ネクストホップ出力論理/物理ポートを識別するために使用L3PortIDメタデータを生成するなど、パケットが次に行くとポートのメディアカプセル化タイプである場合に導出するネクストホップIDメタデータを使用します。例えばユースケースでは、次ホップの出力ポートは、イーサネット（登録商標）タイプです。結果として、パケットとL3ポートIDメタデータはEtherEncap LFB（セクション5.1.4）の下流に送られます。"
    },
    {
      "indent": 3,
      "text": "The EtherEncap LFB encapsulates the incoming packet into an Ethernet frame. A BasicMetadataDispatch LFB (Section 5.5.1) follows the EtherEncap LFB. The BasicMetadataDispatch LFB is where packets are finally dispatched to different output physical/logical ports based on the L3PortID metadata sent to the LFB.",
      "ja": "EtherEncap LFBは、イーサネットフレームに入ってくるパケットをカプセル化します。 BasicMetadataDispatch LFB（セクション5.5.1）EtherEncap LFBに従います。パケットが最終的にLFBに送信L3PortIDメタデータに基づいて、異なる出力論理/物理ポートにディスパッチされるBasicMetadataDispatch LFBです。"
    },
    {
      "indent": 0,
      "text": "7.2. ARP Processing",
      "section_title": true,
      "ja": "7.2。 ARP処理"
    },
    {
      "indent": 3,
      "text": "Figure 3 shows the processing path for the Address Resolution Protocol (ARP) in the case the CE implements the ARP processing function. By no means is this the only way ARP processing could be achieved; as an example, ARP processing could happen at the FE, but that discussion is out of the scope of this use case.",
      "ja": "図3は、CEは、ARP処理機能を実現する場合のアドレス解決プロトコル（ARP）の処理経路を示します。決してこれはARP処理を実現することができる唯一の方法です。一例として、ARP処理は、FEで起こり得るが、その説明は、このユースケースの範囲外です。"
    },
    {
      "indent": 3,
      "text": "       +---+                             +---+\n       |   | ARP packets                 |   |\n       |   |-------------->---------+--->|   | To CE\n ...-->|   | .                      |    |   |\n       |   | .                      |    +---+\n       |   | .                      |   RedirectOut\n       +---+                        ^\n       Ether     EtherEncap         | IPv4 packets lack\n     Classifier   +---+             | address resolution information\n                  |   |             |\n    Packets need  |   |--------->---+\n     ...--------->|   |\n  L2 Encapsulation|   |\n       +---+      |   |                     +------+\n       |   |  +-->|   |--+   +---+          |Ether |\n       |   |  |   +---+  |   |   |--------->|MACOut|-->...\nFrom CE|   |--+          +-->|   | .        +------+\n       |   |ARP Packets      |   | .\n       |   |from CE          |   | .        +------+\n       |   |                 |   |--------> |Ether |-->...\n       +---+                 +---+          |MACOut|\n    RedirectIn            BasicMetadata     +------+\n                          Dispatch",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 3: LFB Use Case for ARP",
      "ja": "図3：ARPのためのLFBユースケース"
    },
    {
      "indent": 3,
      "text": "There are two ways ARP processing could be triggered in the CE as illustrated in Figure 3:",
      "ja": "図3に示すように、ARP処理がCEにトリガすることができる2つの方法があります。"
    },
    {
      "indent": 3,
      "text": "o ARP packets arriving from outside of the NE.",
      "ja": "O ARPは、NEの外部から到着するパケット。"
    },
    {
      "indent": 3,
      "text": "o IPV4 packets failing to resolve within the FE.",
      "ja": "O IPV4は、FE内解決に失敗したパケット。"
    },
    {
      "indent": 3,
      "text": "ARP packets from network interfaces are filtered out by EtherClassifier LFB. The classified ARP packets and associated metadata are then sent downstream to the RedirectOut LFB (Section 5.4.2) to be transported to CE.",
      "ja": "ネットワークインタフェースからARPパケットはEtherClassifier LFBによってフィルタリングされます。分類されたARPパケットと関連付けられたメタデータは、その後、CEに搬送するRedirectOut LFB（セクション5.4.2）の下流に送られます。"
    },
    {
      "indent": 3,
      "text": "The EtherEncap LFB, as described in Section 5.1.4, receives packets that need Ethernet L2 encapsulating. When the EtherEncap LFB fails to find the necessary L2 Ethernet information with which to encapsulate the packet, it outputs the packet to its ExceptionOut LFB port. Downstream to EtherEncap LFB's ExceptionOut LFB port is the RedirectOut LFB, which transports the packet to the CE (see Section 5.1.4 on EtherEncap LFB for details).",
      "ja": "EtherEncap LFBは、セクション5.1.4に記載されているように、イーサネットL2封止を必要とするパケットを受信します。 EtherEncap LFBがパケットをカプセル化すると、必要なL2イーサネット情報を見つけるために失敗した場合、それはそのExceptionOut LFBポートにパケットを出力します。 EtherEncap LFBのExceptionOut LFBポートへのダウンストリームCE（詳細はEtherEncap LFBのセクション5.1.4を参照）にパケットを転送するRedirectOut LFBは、あります。"
    },
    {
      "indent": 3,
      "text": "To achieve its goal, the CE needs to generate ARP request and response packets and send them to external (to the NE) networks. ARP request and response packets from the CE are redirected to an FE via a RedirectIn LFB (Section 5.4.1).",
      "ja": "その目標を達成するために、CEは、ARP要求と応答パケットを生成し、（NE）は、外部ネットワークに送信する必要があります。 CEからのARP要求および応答パケットがRedirectIn LFB（5.4.1項）を介してFEにリダイレクトされます。"
    },
    {
      "indent": 3,
      "text": "As was the case with forwarded IPv4 packets, outgoing ARP packets are also encapsulated to Ethernet format by the EtherEncap LFB, and then dispatched to different interfaces via a BasicMetadataDispatch LFB. The BasicMetadataDispatch LFB dispatches the packets according to the L3PortID metadata included in every ARP packet sent from CE.",
      "ja": "転送されたIPv4パケットの場合と同様に、発信ARPパケットもEtherEncap LFBによってイーサネット形式にカプセル化され、次いでBasicMetadataDispatch LFBを介して、異なるインターフェースにディスパッチされます。 BasicMetadataDispatch LFBは、CEから送信されたすべてのARPパケットに含まL3PortIDメタデータに基づいてパケットを送出します。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry of ForCES LFB class names and the corresponding ForCES LFB class identifiers, with the location of the definition of the ForCES LFB class, in accordance with the rules to use the namespace.",
      "ja": "IANAは、名前空間を使用するためのルールに従って強制しLFBクラスの定義の場所に強制しLFBクラス名とそれに対応するのForCES LFBクラス識別子のレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "This document registers the unique class names and numeric class identifiers for the LFBs listed in Section 8.1. Besides, this document defines the following namespaces:",
      "ja": "この文書では、8.1節に記載されているLFBsのためのユニークなクラス名と数値クラス識別子を登録します。また、この文書は、次の名前空間を定義します。"
    },
    {
      "indent": 3,
      "text": "o Metadata ID, defined in Sections 4.3 and 4.4",
      "ja": "セクション4.3および4.4で定義されたメタデータID、O"
    },
    {
      "indent": 3,
      "text": "o Exception ID, defined in Section 4.4",
      "ja": "セクション4.4で定義されたO例外ID、"
    },
    {
      "indent": 3,
      "text": "o Validate Error ID, defined in Section 4.4",
      "ja": "セクション4.4で定義されたO検証エラーID、"
    },
    {
      "indent": 0,
      "text": "8.1. LFB Class Names and LFB Class Identifiers",
      "section_title": true,
      "ja": "8.1。 LFBクラス名とLFBクラス識別子"
    },
    {
      "indent": 3,
      "text": "LFB classes defined by this document belong to LFBs defined by Standards Track RFCs. According to IANA, the registration procedure is Standards Action for the range 0 to 65535 and First Come First Served with any publicly available specification for over 65535.",
      "ja": "このドキュメントで定義されたLFBクラスは、標準化トラックのRFCで定義されたLFBsに属します。 IANAによると、登録手続きは、65535の範囲0の基準行動であり、第一には、65535以上のための任意の公に利用可能な仕様書を添えて最初に来ます。"
    },
    {
      "indent": 3,
      "text": "The assignment of LFB class names and LFB class identifiers is as in the following table.",
      "ja": "LFBのクラス名とLFBのクラス識別子の割り当ては以下の表の通りです。"
    },
    {
      "indent": 3,
      "text": "+----------+--------------- +------------------------+--------------+\n|LFB Class | LFB Class Name |     Description        |  Reference   |\n|Identifier|                |                        |              |\n+----------+--------------- +------------------------+--------------+\n|    3     |  EtherPHYCop   | Define an Ethernet port|   RFC 6956,  |\n|          |                | abstracted at physical | Section 5.1.1|\n|          |                | layer.                 |              |\n|          |                |                        |              |\n|    4     |  EtherMACIn    | Define an Ethernet     |   RFC 6956,  |\n|          |                | input port at MAC data | Section 5.1.2|\n|          |                | link layer.            |              |\n|          |                |                        |              |\n|    5     |EtherClassifier | Define the process to  |   RFC 6956,  |\n|          |                | decapsulate Ethernet   | Section 5.1.3|\n|          |                | packets and classify   |              |\n|          |                | the packets.           |              |\n|          |                |                        |              |\n|    6     |  EtherEncap    | Define the process to  |   RFC 6956,  |\n|          |                | encapsulate IP packets | Section 5.1.4|\n|          |                | to Ethernet packets.   |              |\n|          |                |                        |              |\n|    7     |  EtherMACOut   | Define an Ethernet     |   RFC 6956   |\n|          |                | output port at MAC     | Section 5.1.5|\n|          |                | data link layer.       |              |\n|          |                |                        |              |\n|    8     | IPv4Validator  | Perform IPv4 packets   |   RFC 6956,  |\n|          |                | validation.            | Section 5.2.1|\n|          |                |                        |              |\n|    9     | IPv6Validator  | Perform IPv6 packets   |   RFC 6956,  |\n|          |                | validation.            | Section 5.2.2|\n|          |                |                        |              |\n|    10    | IPv4UcastLPM   | Perform IPv4 Longest   |   RFC 6956,  |\n|          |                | Prefix Match Lookup.   | Section 5.3.1|\n|          |                |                        |              |\n|    11    | IPv6UcastLPM   | Perform IPv6 Longest   |   RFC 6956,  |\n|          |                | Prefix Match Lookup.   | Section 5.3.3|\n|          |                |                        |              |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "|    12    |  IPv4NextHop   | Define the process of  |   RFC 6956,  |\n|          |                | selecting IPv4 next-hop| Section 5.3.2|\n|          |                | action.                |              |\n|          |                |                        |              |\n|    13    |  IPv6NextHop   | Define the process of  |   RFC 6956,  |\n|          |                | selecting IPv6 next-hop| Section 5.3.4|\n|          |                | action.                |              |\n|          |                |                        |              |\n|    14    |  RedirectIn    | Define the process for |   RFC 6956,  |\n|          |                | CE to inject data      | Section 5.4.1|\n|          |                | packets into FE LFB    |              |\n|          |                | topology.              |              |\n|          |                |                        |              |\n|    15    |  RedirectOut   | Define the process for |   RFC 6956,  |\n|          |                | LFBs in FE to deliver  | Section 5.4.2|\n|          |                | data packets to CE.    |              |\n|          |                |                        |              |\n|    16    | BasicMetadata  | Dispatch input packets |   RFC 6956,  |\n|          |    Dispatch    | to a group output      | Section 5.5.1|\n|          |                | according to a metadata|              |\n|          |                |                        |              |\n|    17    |GenericScheduler| Define a preliminary   |   RFC 6956,  |\n|          |                | generic scheduling     | Section 5.5.2|\n|          |                | process.               |              |\n+----------+--------------- +------------------------+--------------+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Table 1",
      "ja": "表1"
    },
    {
      "indent": 0,
      "text": "8.2. Metadata ID",
      "section_title": true,
      "ja": "8.2。メタデータのID"
    },
    {
      "indent": 3,
      "text": "The Metadata ID namespace is 32 bits long. Below are the guidelines for managing the namespace.",
      "ja": "メタデータID名前空間は32ビット長です。以下は、名前空間を管理するためのガイドラインです。"
    },
    {
      "indent": 3,
      "text": "Metadata IDs in the range of 0x00000001-0x7FFFFFFF are Specification Required [RFC5226]. A metadata ID using this range MUST be documented in an RFC or other permanent and readily available reference.",
      "ja": "0x00000001-0x7FFFFFFFの範囲内のメタデータIDは、仕様が必要である[RFC5226]です。この範囲を使用して、メタデータIDは、RFCまたは他の永久的かつ容易に入手可能な文献に文書化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Values assigned by this specification:",
      "ja": "この仕様によって割り当てられた値。"
    },
    {
      "indent": 3,
      "text": "+--------------+-------------------------+--------------------------+\n|   Value      |           Name          |        Definition        |\n+--------------+-------------------------+--------------------------+\n|  0x00000000  |         Reserved        |   RFC 6956               |\n|  0x00000001  |       PHYPortID         |   RFC 6956, Section 4.4  |\n|  0x00000002  |         SrcMAC          |   RFC 6956, Section 4.4  |\n|  0x00000003  |         DstMAC          |   RFC 6956, Section 4.4  |\n|  0x00000004  |       LogicalPortID     |   RFC 6956, Section 4.4  |\n|  0x00000005  |         EtherType       |   RFC 6956, Section 4.4  |\n|  0x00000006  |          VlanID         |   RFC 6956, Section 4.4  |\n|  0x00000007  |       VlanPriority      |   RFC 6956, Section 4.4  |\n|  0x00000008  |       NextHopIPv4Addr   |   RFC 6956, Section 4.4  |\n|  0x00000009  |       NextHopIPv6Addr   |   RFC 6956, Section 4.4  |\n|  0x0000000A  |       HopSelector       |   RFC 6956, Section 4.4  |\n|  0x0000000B  |       ExceptionID       |   RFC 6956, Section 4.4  |\n|  0x0000000C  |      ValidateErrorID    |   RFC 6956, Section 4.4  |\n|  0x0000000D  |         L3PortID        |   RFC 6956, Section 4.4  |\n|  0x0000000E  |       RedirectIndex     |   RFC 6956, Section 4.4  |\n|  0x0000000F  |    MediaEncapInfoIndex  |   RFC 6956, Section 4.4  |\n|  0x80000000- |      Reserved for       |   RFC 6956               |\n|  0xFFFFFFFF  |      Private Use        |                          |\n+--------------+-------------------------+--------------------------+",
      "raw": true
    },
    {
      "indent": 35,
      "text": "Table 2",
      "ja": "表2"
    },
    {
      "indent": 0,
      "text": "8.3. Exception ID",
      "section_title": true,
      "ja": "8.3。例外ID"
    },
    {
      "indent": 3,
      "text": "The Exception ID namespace is 32 bits long. Below are the guidelines for managing the namespace.",
      "ja": "例外ID名前空間は32ビット長です。以下は、名前空間を管理するためのガイドラインです。"
    },
    {
      "indent": 3,
      "text": "Exception IDs in the range of 0x00000000-0x7FFFFFFF are Specification Required [RFC5226]. An exception ID using this range MUST be documented in an RFC or other permanent and readily available reference.",
      "ja": "0x00000000-0x7FFFFFFFの範囲の例外IDは、仕様が必要である[RFC5226]です。この範囲を使用して、例外IDはRFCまたは他の永久的かつ容易に入手可能な文献に文書化しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Values assigned by this specification:",
      "ja": "この仕様によって割り当てられた値。"
    },
    {
      "indent": 3,
      "text": "+--------------+---------------------------------+------------------+\n|   Value      |           Name                  |   Definition     |\n+--------------+---------------------------------+------------------+\n|  0x00000000  |  AnyUnrecognizedExceptionCase   | See Section 4.4  |\n|  0x00000001  |        ClassifyNoMatching       | See Section 4.4  |\n|  0x00000002  |   MediaEncapInfoIndexInvalid    | See Section 4.4  |\n|  0x00000003  |       EncapTableLookupFailed    | See Section 4.4  |\n|  0x00000004  |             BadTTL              | See Section 4.4  |\n|  0x00000005  |     IPv4HeaderLengthMismatch    | See Section 4.4  |\n|  0x00000006  |        RouterAlertOptions       | See Section 4.4  |\n|  0x00000007  |         IPv6HopLimitZero        | See Section 4.4  |\n|  0x00000008  |       IPv6NextHeaderHBH         | See Section 4.4  |\n|  0x00000009  |      SrcAddressException        | See Section 4.4  |\n|  0x0000000A  |      DstAddressException        | See Section 4.4  |\n|  0x0000000B  |        LPMLookupFailed          | See Section 4.4  |\n|  0x0000000C  |       HopSelectorInvalid        | See Section 4.4  |\n|  0x0000000D  |      NextHopLookupFailed        | See Section 4.4  |\n|  0x0000000E  |          FragRequired           | See Section 4.4  |\n|  0x0000000F  |       MetadataNoMatching        | See Section 4.4  |\n|  0x80000000- |         Reserved for            | RFC 6956         |\n|  0xFFFFFFFF  |         Private Use             |                  |\n+--------------+---------------------------------+------------------+",
      "raw": true
    },
    {
      "indent": 34,
      "text": "Table 3",
      "ja": "表3"
    },
    {
      "indent": 0,
      "text": "8.4. Validate Error ID",
      "section_title": true,
      "ja": "8.4。エラーIDを検証します"
    },
    {
      "indent": 3,
      "text": "The Validate Error ID namespace is 32 bits long. Below are the guidelines for managing the namespace.",
      "ja": "検証エラーIDの名前空間は32ビットの長さです。以下は、名前空間を管理するためのガイドラインです。"
    },
    {
      "indent": 3,
      "text": "Validate Error IDs in the range of 0x00000000-0x7FFFFFFF are Specification Required [RFC5226]. A Validate Error ID using this range MUST be documented in an RFC or other permanent and readily available reference.",
      "ja": "0x00000000-0x7FFFFFFFの範囲内のエラーIDを検証する仕様が必要である[RFC5226]です。この範囲を使用して検証エラーIDは、RFCまたは他の永久的かつ容易に入手可能な文献に文書化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Values assigned by this specification:",
      "ja": "この仕様によって割り当てられた値。"
    },
    {
      "indent": 3,
      "text": "+--------------+---------------------------------+------------------+\n|   Value      |           Name                  |   Definition     |\n+--------------+---------------------------------+------------------+\n|  0x00000000  | AnyUnrecognizedValidateErrorCase| See Section 4.4  |\n|  0x00000001  |        InvalidIPv4PacketSize    | See Section 4.4  |\n|  0x00000002  |           NotIPv4Packet         | See Section 4.4  |\n|  0x00000003  |    InvalidIPv4HeaderLengthSize  | See Section 4.4  |\n|  0x00000004  |    InvalidIPv4LengthFieldSize   | See Section 4.4  |\n|  0x00000005  |         InvalidIPv4Checksum     | See Section 4.4  |\n|  0x00000006  |      InvalidIPv4SrcAddr         | See Section 4.4  |\n|  0x00000007  |      InvalidIPv4DstAddr         | See Section 4.4  |\n|  0x00000008  |      InvalidIPv6PacketSize      | See Section 4.4  |\n|  0x00000009  |          NotIPv6Packet          | See Section 4.4  |\n|  0x0000000A  |      InvalidIPv6SrcAddr         | See Section 4.4  |\n|  0x0000000B  |      InvalidIPv6DstAddr         | See Section 4.4  |\n|  0x80000000- |        Reserved for             | RFC 6956         |\n|  0xFFFFFFFF  |        Private Use              |                  |\n+--------------+---------------------------------+------------------+",
      "raw": true
    },
    {
      "indent": 35,
      "text": "Table 4",
      "ja": "表4"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The ForCES framework document [RFC3746] provides a description of the security needs for the overall ForCES architecture. For example, the ForCES protocol entities must be authenticated per the ForCES requirements before they can access the information elements described in this document via ForCES. The ForCES protocol document [RFC5810] includes a comprehensive set of security mechanisms that implementations are required to support to meet these needs. SCTP-based Transport Mapping Layer (TML) for the ForCES protocol [RFC5811] specifies security mechanisms for transport mapping for the ForCES protocol. The LFBs defined in this document are similar to other LFBs modeled by the FE model [RFC5812]. In particular, they have the same security properties. Thus, the security mechanisms and considerations from the ForCES protocol document [RFC5810] apply to this document.",
      "ja": "ForCESフレームワークドキュメント[RFC3746]は全体のForCESアーキテクチャのセキュリティニーズの説明を提供します。彼らは力により、この文書に記載された情報要素にアクセスする前に、例えば、のForCESプロトコルエンティティはのForCESの要件ごとに認証される必要があります。 ForCESプロトコルドキュメント[RFC5810]は実装は、これらのニーズを満たすためにサポートするために必要とされるセキュリティメカニズムの包括的なセットを含みます。 ForCESプロトコルのSCTPベースのトランスポート・マッピング・レイヤー（TML）[RFC5811]はのForCESプロトコルのためのトランスポート・マッピングのセキュリティ・メカニズムを指定します。この文書で定義されたLFBsは、FEモデル[RFC5812]によってモデル化された他のLFBsに類似しています。特に、それらは、同じセキュリティ特性を有しています。したがって、のForCESプロトコルドキュメント[RFC5810]からのセキュリティメカニズムと考慮事項は、この文書に適用されます。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5810] Doria, A., Hadi Salim, J., Haas, R., Khosravi, H., Wang, W., Dong, L., Gopal, R., and J. Halpern, \"Forwarding and Control Element Separation (ForCES) Protocol Specification\", RFC 5810, March 2010.",
      "ja": "[RFC5810]ドリア、A.、ハディサリム、J.、ハース、R.、Khosravi、H.、王、W.、ドン、L.、ゴパル、R.、およびJ.アルペルン、「転送および制御素子分離（のForCES）プロトコル仕様」、RFC 5810、2010年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5811] Hadi Salim, J. and K. Ogawa, \"SCTP-Based Transport Mapping Layer (TML) for the Forwarding and Control Element Separation (ForCES) Protocol\", RFC 5811, March 2010.",
      "ja": "[RFC5811]ハディサリム、J.及びK.小川、 \"転送および制御素子分離用SCTPベースのトランスポート・マッピング・レイヤ（TML）（のForCES）プロトコル\"、RFC 5811、2010年月。"
    },
    {
      "indent": 3,
      "text": "[RFC5812] Halpern, J. and J. Hadi Salim, \"Forwarding and Control Element Separation (ForCES) Forwarding Element Model\", RFC 5812, March 2010.",
      "ja": "[RFC5812]アルペルン、J.およびJ.ハディサリム、 \"転送および制御素子分離（のForCES）転送要素モデル\"、RFC 5812、2010年3月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[IEEE.802-1Q] IEEE, \"IEEE Standard for Local and metropolitan area networks -- Media Access Control (MAC) Bridges and Virtual Bridged Local Area Networks\", IEEE Standard 802.1Q, 2011.",
      "ja": "[IEEE.802-1Q] IEEE、「地方とメトロポリタンエリアネットワークのためのIEEE規格 - メディアアクセス制御（MAC）ブリッジと仮想ブリッジローカルエリアネットワーク」、IEEE 802.1Q規格、2011。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122]ブレーデン、R.、 \"インターネットホストのための要件 - 通信層\"、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1812] Baker, F., \"Requirements for IP Version 4 Routers\", RFC 1812, June 1995.",
      "ja": "[RFC1812]ベイカー、F.、RFC 1812、1995年6月 \"IPバージョン4つのルータのための要件\"。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC2460]デアリング、S.とR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の仕様\"、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2578] McCloghrie, K., Ed., Perkins, D., Ed., and J. Schoenwaelder, Ed., \"Structure of Management Information Version 2 (SMIv2)\", STD 58, RFC 2578, April 1999.",
      "ja": "[RFC2578] McCloghrie、K.、エド。、パーキンス、D.、編、及びJ. Schoenwaelder、編、STD 58、RFC 2578、1999年4月、 \"管理情報バージョン2（SMIv2）の構造\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3746] Yang, L., Dantu, R., Anderson, T., and R. Gopal, \"Forwarding and Control Element Separation (ForCES) Framework\", RFC 3746, April 2004.",
      "ja": "[RFC3746]ヤン、L.、Dantu、R.、アンダーソン、T.、およびR.ゴパル、 \"転送および制御素子分離（のForCES）フレームワーク\"、RFC 3746、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Acknowledgements",
      "ja": "付録A.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to acknowledge the following people, whose input was particularly helpful during development of this document:",
      "ja": "著者は、その入力が、この文書の開発中に特に役立ちました以下の方々に、承認したいと思います："
    },
    {
      "indent": 6,
      "text": "Edward Crabbe Adrian Farrel Rong Jin Bin Zhuge Ming Gao Jingjing Zhou Xiaochun Wu Derek Atkins Stephen Farrell Meral Shirazipour Jari Arkko Martin Stiemerling Stewart Bryant Richard Barnes",
      "ja": "エドワード・クラッブエードリアンファレル栄ジンビン諸葛明ガオ晶晶周Xiaochun呉デレク・アトキンスステファン・ファレルMeral ShirazipourヤリArkkoマーティンStiemerlingスチュワートブライアントリチャード・バーンズ"
    },
    {
      "indent": 0,
      "text": "Appendix B. Contributors",
      "ja": "付録B.協力者"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Jamal Hadi Salim, Ligang Dong, and Fenggen Jia, all of whom made major contributions to the development of this document. Ligang Dong and Fenggen Jia were also two of the authors of earlier documents from which this document evolved.",
      "ja": "著者は、この文書の発展に大きな貢献をしたすべての人のジャマル・ハディサリム、Ligangドン、およびFenggen甲を、感謝したいと思います。 LigangドンとFenggen嘉また、この文書は進化しているから、それ以前の文書の著者の2でした。"
    },
    {
      "indent": 3,
      "text": "Jamal Hadi Salim Mojatatu Networks Ottawa, Ontario Canada EMail: hadi@mojatatu.com",
      "ja": "ジャマル・ハディサリムMojatatuネットワークオタワ、オンタリオ州カナダEメール：hadi@mojatatu.com"
    },
    {
      "indent": 3,
      "text": "Ligang Dong Zhejiang Gongshang University 18 Xuezheng Str., Xiasha University Town Hangzhou 310018 P.R. China EMail: donglg@zjsu.edu.cn",
      "ja": "L Iシリンダー洞Z Hejiangは、アグリビジネス大学18 X UE正STR、ξアシャ大学町杭州310018中華人民共和国のメールに行く：...江蘇省キャビネットを制限する力を@"
    },
    {
      "indent": 3,
      "text": "Fenggen Jia National Digital Switching Center (NDSC) Jianxue Road Zhengzhou 452000 P.R. China EMail: jfg@mail.ndsc.com.cn",
      "ja": "RMS @ .COM前に、市場で買った：J IA国家デジタルスイッチングセンターとF工は（NDS C）Jイアンは道路鄭州452000中華人民共和国の電子メールを学びました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Weiming Wang Zhejiang Gongshang University 18 Xuezheng Str., Xiasha University Town Hangzhou 310018 P.R. China",
      "ja": "魏王Z名Hejiangアグリビジネス大学18 X UE正STRを行く。、Ξアシャ大学町杭州310018中華人民共和国"
    },
    {
      "indent": 3,
      "text": "Phone: +86 571 28877751 EMail: wmwang@zjsu.edu.cn",
      "ja": "電話：+86 571 28877751 Eメール：wmwang@zjsu.edu.cn"
    },
    {
      "indent": 3,
      "text": "Evangelos Haleplidis University of Patras Department of Electrical & Computer Engineering Patras 26500 Greece",
      "ja": "電気・コンピュータ工学パトラス26500ギリシャのパトラス部門のEvangelos Haleplidis大学"
    },
    {
      "indent": 3,
      "text": "EMail: ehalep@ece.upatras.gr",
      "ja": "メールアドレス：ehalep@ece.upatras.gr"
    },
    {
      "indent": 3,
      "text": "Kentaro Ogawa NTT Corporation Tokyo Japan",
      "ja": "けんたろ おがわ んっｔ こｒぽらちおん ときょ じゃぱん"
    },
    {
      "indent": 3,
      "text": "EMail: ogawa.kentaro@lab.ntt.co.jp",
      "ja": "メールアドレス：ogawa.kentaro@lab.ntt.co.jp"
    },
    {
      "indent": 3,
      "text": "Chuanhuang Li Hangzhou DPtech 6th Floor, Zhongcai Group, 68 Tonghe Road, Binjiang District Hangzhou 310051 P.R. China",
      "ja": "ゆっくりと私杭州DPハイテク6階、ZハングCAIグループ、68トン、道路、ビン地区杭州310051中華人民共和国のGL C"
    },
    {
      "indent": 3,
      "text": "EMail: chuanhuang_li@zjsu.edu.cn",
      "ja": "メールアドレス：chuanhuang_li@zjsu.edu.cn"
    },
    {
      "indent": 3,
      "text": "Joel Halpern Ericsson P.O. Box 6049 Leesburg, VA 20178 USA",
      "ja": "ジョエルハルパーンエリクソン私書箱ボックス6049リーズバーグ、VA 20178 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 703 371 3043 EMail: joel.halpern@ericsson.com",
      "ja": "電話：+1 703 371 3043 Eメール：joel.halpern@ericsson.com"
    }
  ]
}