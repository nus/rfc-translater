{
  "title": {
    "text": "RFC 6943 - Issues in Identifier Comparison for Security Purposes",
    "ja": "RFC 6943 - セキュリティ目的のための識別子の比較での問題"
  },
  "number": 6943,
  "created_at": "2019-11-01 23:46:58.155325+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Architecture Board (IAB)                         D. Thaler, Ed.\nRequest for Comments: 6943                                     Microsoft\nCategory: Informational                                         May 2013\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Issues in Identifier Comparison for Security Purposes",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Identifiers such as hostnames, URIs, IP addresses, and email addresses are often used in security contexts to identify security principals and resources. In such contexts, an identifier presented via some protocol is often compared using some policy to make security decisions such as whether the security principal may access the resource, what level of authentication or encryption is required, etc. If the parties involved in a security decision use different algorithms to compare identifiers, then failure scenarios ranging from denial of service to elevation of privilege can result. This document provides a discussion of these issues that designers should consider when defining identifiers and protocols, and when constructing architectures that use multiple protocols.",
      "ja": "こうしたホスト名、URIを、IPアドレス、および電子メールアドレスなどの識別子は、多くの場合、セキュリティプリンシパルとリソースを識別するためのセキュリティコンテキストで使用されています。当事者は、セキュリティの決定に関与している場合、このような状況では、いくつかのプロトコルを介して提示された識別子は、多くの場合、このようなセキュリティプリンシパルがリソースにアクセスすることが可能かどうかなど、セキュリティ上の意思決定を行うために、いくつかのポリシーを使用して比較され、認証や暗号化のレベルがなど、必要とされますその後、サービス拒否の特権の昇格までの障害シナリオが発生することができ、識別子を比較するために、異なるアルゴリズムを使用します。この文書では、設計者は、識別子とプロトコルを定義し、複数のプロトコルを使用するアーキテクチャを構築するときにするときに考慮する必要があり、これらの問題の議論を提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Architecture Board (IAB) and represents information that the IAB has deemed valuable to provide for permanent record. It represents the consensus of the Internet Architecture Board (IAB). Documents approved for publication by the IAB are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットアーキテクチャ委員会（IAB）の製品であり、IABは、永久的な記録を提供するために貴重なものとみなされたことの情報を表します。これは、インターネットアーキテクチャ委員会（IAB）のコンセンサスを表しています。 IABによって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6943.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6943で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Classes of Identifiers .....................................5\n   1.2. Canonicalization ...........................................5\n2. Identifier Use in Security Policies and Decisions ...............6\n   2.1. False Positives and Negatives ..............................7\n   2.2. Hypothetical Example .......................................8\n3. Comparison Issues with Common Identifiers .......................9\n   3.1. Hostnames ..................................................9\n        3.1.1. IPv4 Literals ......................................11\n        3.1.2. IPv6 Literals ......................................12\n        3.1.3. Internationalization ...............................13\n        3.1.4. Resolution for Comparison ..........................14\n   3.2. Port Numbers and Service Names ............................14\n   3.3. URIs ......................................................15\n        3.3.1. Scheme Component ...................................16\n        3.3.2. Authority Component ................................16\n        3.3.3. Path Component .....................................17\n        3.3.4. Query Component ....................................17\n        3.3.5. Fragment Component .................................17\n        3.3.6. Resolution for Comparison ..........................18\n   3.4. Email Address-Like Identifiers ............................18\n4. General Issues .................................................19\n   4.1. Conflation ................................................19\n   4.2. Internationalization ......................................20\n   4.3. Scope .....................................................21\n   4.4. Temporality ...............................................21\n5. Security Considerations ........................................22\n6. Acknowledgements ...............................................22\n7. IAB Members at the Time of Approval ............................23\n8. Informative References .........................................23",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "In computing and the Internet, various types of \"identifiers\" are used to identify humans, devices, content, etc. This document provides a discussion of some security issues that designers should consider when defining identifiers and protocols, and when constructing architectures that use multiple protocols. Before discussing these security issues, we first give some background on some typical processes involving identifiers. Terms such as \"identifier\", \"identity\", and \"principal\" are used as defined in [RFC4949].",
      "ja": "コンピューティングおよびインターネットでは、「識別子」は、ヒトを識別するために使用され、デバイス、コンテンツ、などの様々なタイプのこの文書は、識別子とプロトコルを定義する際に、設計者が考慮すべきいくつかのセキュリティ問題の議論を提供し、複数の使用のアーキテクチャを構築するときプロトコル。これらのセキュリティ上の問題を議論する前に、まず識別子を含むいくつかの典型的なプロセスのいくつかの背景を与えます。 [RFC4949]で定義されるような「識別子」、「同一性」、及び「主」などの用語が使用されます。"
    },
    {
      "indent": 3,
      "text": "As depicted in Figure 1, there are multiple processes relevant to our discussion.",
      "ja": "図1に示すように、我々の議論に関連する複数のプロセスがあります。"
    },
    {
      "indent": 3,
      "text": "1. An identifier is first generated. If the identifier is intended to be unique, the generation process must include some mechanism, such as allocation by a central authority or verification among the members of a distributed authority, to help ensure uniqueness. However, the notion of \"unique\" involves determining whether a putative identifier matches any other identifier that has already been allocated. As we will see, for many types of identifiers, this is not simply an exact binary match.",
      "ja": "1.識別子が最初に生成されます。識別子が一意であることが意図されている場合、生成プロセスは、一意性を確保するために、分散権限のメンバー間の中央機関または検証することによって、そのような割り当てのようないくつかの機構を含んでいなければなりません。しかし、「ユニーク」の概念は、推定上の識別子が既に割り当てられている任意の他の識別子と一致するかどうかを決定することを含みます。私たちが見るように、識別子の多くの種類のために、これは単に正確なバイナリ一致ではありません。"
    },
    {
      "indent": 7,
      "text": "After generating the identifier, it is often stored in two\nlocations: with the requester or \"holder\" of the identifier, and\nwith some repository of identifiers (e.g., DNS).  For example, if\nthe identifier was allocated by a central authority, the\nrepository might be that authority.  If the identifier identifies\na device or content on a device, the repository might be that\ndevice.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. The identifier is distributed, either by the holder of the identifier or by a repository of identifiers, to others who could use the identifier. This distribution might be electronic, but sometimes it is via other channels such as voice, business card, billboard, or other form of advertisement. The identifier itself might be distributed directly, or it might be used to generate a portion of another type of identifier that is then distributed. For example, a URI or email address might include a server name, and hence distributing the URI or email address also inherently distributes the server name.",
      "ja": "前記識別子は、識別子を使用することができる他の識別子の保持者によって、または識別子のリポジトリのいずれかによって、配布されます。この分布は、電子かもしれませんが、時にはそれは、音声、名刺、看板、あるいは広告の他の形態として他のチャネルを経由しています。識別子自体を直接分散されるかもしれない、または分散された識別子の別のタイプの部分を生成するために使用されるかもしれません。例えば、URIまたは電子メールアドレスも、本質的にサーバー名を配信するサーバ名、ひいてはURIを配布または電子メールアドレスが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "3. The identifier is used by some party. Generally, the user supplies the identifier, which is (directly or indirectly) sent to the repository of identifiers. The repository of identifiers must then attempt to match the user-supplied identifier with an identifier in its repository.",
      "ja": "3.識別子は、いくつかの当事者によって使用されます。一般的に、ユーザは、識別子のリポジトリに送信された識別子を、（直接または間接的に）供給する。識別子のリポジトリは、そのリポジトリ内の識別子とユーザ提供の識別子と一致するように試みなければなりません。"
    },
    {
      "indent": 7,
      "text": "For example, using an email address to send email to the holder\nof an identifier may result in the email arriving at the holder's\nemail server, which has access to the mail stores.",
      "raw": true
    },
    {
      "indent": 15,
      "text": "           +------------+\n           |  Holder of |     1. Generation\n           | identifier +<---------+\n           +----+-------+          |\n                |                  | Match\n                |                  v/\n                |          +-------+-------+\n                +----------+ Repository of |\n                |          |  identifiers  |\n                |          +-------+-------+\n2. Distribution |                  ^\\\n                |                  | Match\n                v                  |\n      +---------+-------+          |\n      |      User of    |          |\n      |    identifier   +----------+\n      +-----------------+    3. Use",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 1: Typical Identifier Processes",
      "ja": "図1：一般的な識別子プロセス"
    },
    {
      "indent": 3,
      "text": "Another variation is where a user is given the identifier of a resource (e.g., a web site) to access securely, sometimes known as a \"reference identifier\" [RFC6125], and the server hosting the resource then presents its identity at the time of use. In this case, the user application attempts to match the presented identity against the reference identifier.",
      "ja": "別の変形は、ユーザは時々、安全にアクセスするためのリソース（例えば、ウェブサイト）の識別子を与えられた「参照識別子」[RFC6125]として知られており、リソースをホストしているサーバーは、その後の時点でその識別情報を提示しているところでありますつかいます。この場合、ユーザアプリケーションが参照識別子に対して提示されたIDと一致することを試みます。"
    },
    {
      "indent": 3,
      "text": "One key aspect is that the identifier values passed in generation, distribution, and use may all be in different forms. For example, an identifier might be exchanged in printed form at generation time, distributed to a user via voice, and then used electronically. As such, the match process can be complicated.",
      "ja": "一つの重要な側面は、生成、配布、および使用時に渡された識別子の値は、全ての異なる形態であってもよいということです。例えば、識別子は、生成時に印刷された形で交換されるかもしれない音声を介してユーザに配布し、その後、電子的使用します。そのため、試合のプロセスが複雑になることがあります。"
    },
    {
      "indent": 3,
      "text": "Furthermore, in many cases, the relationship between holder, repositories, and users may be more involved. For example, when a hierarchy of web caches exists, each cache is itself a repository of a sort, and the match process is usually intended to be the same as on the origin server.",
      "ja": "さらに、多くの場合、ホルダー、リポジトリ、およびユーザーとの関係はより複雑であってもよいです。 Webキャッシュの階層が存在する場合、例えば、各キャッシュ自体が一種のリポジトリであり、一致プロセスは、通常、オリジンサーバ上で同じであることが意図されています。"
    },
    {
      "indent": 3,
      "text": "Another aspect to keep in mind is that there can be multiple identifiers that refer to the same object (i.e., resource, human, device, etc.). For example, a human might have a passport number and a drivers license number, and an RFC might be available at multiple locations (rfc-editor.org and ietf.org). In this document, we focus on comparing two identifiers to see whether they are the same identifier, rather than comparing two different identifiers to see whether they refer to the same entity (although a few issues with the latter are touched on in several places, such as Sections 3.1.4 and 3.3.6).",
      "ja": "心に留めておくべき別の態様は、同じオブジェクトを参照複数の識別子（すなわち、リソース、ヒト、装置、等）が存在し得るということです。例えば、ヒトは、パスポート番号、運転免許証番号を持っているかもしれない、そしてRFCは（rfc-editor.orgとietf.org）複数の場所で利用可能であるかもしれません。この文書では、我々は、彼らが同じ識別子であるかどうかを見るために2つの識別子を比較するのではなく、後者はいくつかの問題がいくつかの場所で触れているが、彼らは（同じ実体を参照するかどうかを確認するために、2つの異なる識別子を比較することに焦点を当て、そのようセクション3.1.4および3.3.6）など。"
    },
    {
      "indent": 0,
      "text": "1.1. Classes of Identifiers",
      "section_title": true,
      "ja": "1.1。識別子のクラス"
    },
    {
      "indent": 3,
      "text": "In this document, we will refer to the following classes of identifiers:",
      "ja": "この文書では、我々は、識別子の次のクラスを参照します。"
    },
    {
      "indent": 3,
      "text": "o Absolute: identifiers that can be compared byte-by-byte for equality. Two identifiers that have different bytes are defined to be different. For example, binary IP addresses are in this class.",
      "ja": "絶対O：バイト単位の平等のために比較することができ識別子。別のバイトを持つ2つの識別子が異なるように定義されています。例えば、バイナリIPアドレスは、このクラスです。"
    },
    {
      "indent": 3,
      "text": "o Definite: identifiers that have a single well-defined comparison algorithm. For example, URI scheme names are required to be US-ASCII [USASCII] and are defined to match in a case-insensitive way; the comparison is thus definite, since there is a well-specified algorithm (Section 9.2.1 of [RFC4790]) on how to do a case-insensitive match among ASCII strings.",
      "ja": "明確O：シングル明確に定義された比較アルゴリズムを持っている識別子。例えば、URIスキーム名はUSASCII [USASCII]であることが必要であり、大文字と小文字を区別しないように一致するように定義されています。比較は、ASCII文字列の中で、大文字と小文字を区別しないマッチングを行う方法についても、指定されたアルゴリズム（[RFC4790]のセクション9.2.1）があるので、このように明確です。"
    },
    {
      "indent": 3,
      "text": "o Indefinite: identifiers that have no single well-defined comparison algorithm. For example, human names are in this class. Everyone might want the comparison to be tailored for their locale, for some definition of \"locale\". In some cases, there may be limited subsets of parties that might be able to agree (e.g., ASCII users might all agree on a common comparison algorithm, whereas users of other Roman-derived scripts, such as Turkish, may not), but identifiers often tend to leak out of such limited environments.",
      "ja": "O不定：単一の明確に定義された比較アルゴリズムを持っていない識別子。例えば、人間の名前は、このクラスです。誰もが「ロケール」のいくつかの定義については、比較が彼らのロケールに合わせて調整することにしたいかもしれません。いくつかのケースでは、（例えば、ASCIIのユーザーがすべてではないが、トルコ語など他のローマ由来のスクリプトの利用者に対し、一般的な比較アルゴリズムに同意するかもしれない）が、識別子を合意することができるかもしれない当事者のサブセットが制限される場合があり多くの場合、このような限られた環境の外に漏出する傾向があります。"
    },
    {
      "indent": 0,
      "text": "1.2. Canonicalization",
      "section_title": true,
      "ja": "1.2。正規化"
    },
    {
      "indent": 3,
      "text": "Perhaps the most common algorithm for comparison involves first converting each identifier to a canonical form (a process known as \"canonicalization\" or \"normalization\") and then testing the resulting canonical representations for bitwise equality. In so doing, it is thus critical that all entities involved agree on the same canonical form and use the same canonicalization algorithm so that the overall comparison process is also the same.",
      "ja": "おそらく、比較のための最も一般的なアルゴリズムは、最初に標準形（「正規化」または「正規化」として知られるプロセス）を各識別子に変換した後、ビット単位の等価のため、得られた正規表現をテストすることを含みます。そうすることで、関係するすべてのエンティティが同じ標準的な形式に同意し、全体的な比較プロセスも同じになるように、同じ正規化アルゴリズムを使用することをこれが重要です。"
    },
    {
      "indent": 3,
      "text": "Note that in some contexts, such as in internationalization, the terms \"canonicalization\" and \"normalization\" have a precise meaning. In this document, however, we use these terms synonymously in their more generic form, to mean conversion to some standard form.",
      "ja": "こうした国際化のようないくつかの文脈で、用語「正規化」と「正規化」は正確な意味を持っていることに注意してください。この文書では、しかし、我々はいくつかの標準形式への変換を意味するように、彼らのより一般的な形で同義にこれらの用語を使用します。"
    },
    {
      "indent": 3,
      "text": "While the most common method of comparison includes canonicalization, comparison can also be done by defining an equivalence algorithm, where no single form is canonical. However, in most cases, a canonical form is useful for other purposes, such as output, and so in such cases defining a canonical form suffices to define a comparison method.",
      "ja": "比較の最も一般的な方法は、正規化を含むが、比較はまた、単一のフォームが正規ではない等価アルゴリズムを定義することによって行うことができます。しかし、ほとんどの場合、標準形は、出力のような他の目的のために有用であり、したがってそのような場合には標準形式を定義する比較メソッドを定義すればよいです。"
    },
    {
      "indent": 0,
      "text": "2. Identifier Use in Security Policies and Decisions",
      "section_title": true,
      "ja": "セキュリティポリシーと決定2.識別子の使用"
    },
    {
      "indent": 3,
      "text": "Identifiers such as hostnames, URIs, and email addresses are used in security contexts to identify security principals (i.e., entities that can be authenticated) and resources as well as other security parameters such as types and values of claims. Those identifiers are then used to make security decisions based on an identifier presented via some protocol. For example:",
      "ja": "そのようなホスト名、URIは、電子メールアドレス等の識別子は、セキュリティプリンシパルを識別するために、セキュリティコンテキストで使用される（すなわち、認証可能エンティティ）とリソース、ならびにそのような種類および特許請求の範囲の値などの他のセキュリティパラメータ。これらの識別子は、その後、いくつかのプロトコルを介して提示された識別子に基づいてセキュリティの決定を行うために使用されています。例えば："
    },
    {
      "indent": 3,
      "text": "o Authentication: a protocol might match a security principal's identifier to look up expected keying material and then match keying material.",
      "ja": "O認証：ルックアップするために、セキュリティプリンシパルの識別子と一致するかもしれないプロトコルが鍵材料を期待して、鍵材料を一致させます。"
    },
    {
      "indent": 3,
      "text": "o Authorization: a protocol might match a resource name against some policy. For example, it might look up an access control list (ACL) and then look up the security principal's identifier (or a surrogate for it) in that ACL.",
      "ja": "O許可：プロトコルは、いくつかの政策に対するリソース名と一致する可能性があります。例えば、それは、アクセス制御リスト（ACL）をアップに見えるかもしれませんし、そのACL内のセキュリティプリンシパルの識別子（またはそれの代用）を調べます。"
    },
    {
      "indent": 3,
      "text": "o Accounting: a system might create an accounting record for a security principal's identifier or resource name, and then might later need to match a presented identifier to (for example) add new filtering rules based on the records in order to stop an attack.",
      "ja": "O会計：システムがセキュリティプリンシパルの識別子またはリソース名のアカウンティング・レコードを作成することができますし、後で（たとえば）に提示された識別子と一致する必要があるかもしれませんが、攻撃を停止するために記録に基づいて、新たなフィルタリングルールを追加します。"
    },
    {
      "indent": 3,
      "text": "If the parties involved in a security decision use different matching algorithms for the same identifiers, then failure scenarios ranging from denial of service to elevation of privilege can result, as we will see.",
      "ja": "セキュリティの決定に関わる当事者が同じ識別子に対して異なるマッチングアルゴリズムを使用する場合は、サービス拒否の特権の昇格までの障害シナリオは、私たちが見るように、なります。"
    },
    {
      "indent": 3,
      "text": "This is especially complicated in cases involving multiple parties and multiple protocols. For example, there are many scenarios where some form of \"security token service\" is used to grant to a requester permission to access a resource, where the resource is held by a third party that relies on the security token service (see Figure 2). The protocol used to request permission (e.g., Kerberos or OAuth) may be different from the protocol used to access the resource (e.g., HTTP). Opportunities for security problems arise when two protocols define different comparison algorithms for the same type of identifier, or when a protocol is ambiguously specified and two endpoints (e.g., a security token service and a resource holder) implement different algorithms within the same protocol.",
      "ja": "これは、複数の当事者と複数のプロトコルを含む場合には特に複雑です。たとえば、「セキュリティトークンサービス」のいくつかのフォームは、リソースがセキュリティトークンサービスに依存している第三者が保持されているリソースにアクセスするために依頼者の許可を付与するために使用される多くのシナリオがあります（図2を参照） 。プロトコル（例えば、HTTP）リソースにアクセスするために使用されるから（例えば、KerberosまたはOAuthの）許可を要求するために使用されるプロトコルは異なっていてもよいです。 2つのプロトコルは、識別子の同じタイプのための異なる比較アルゴリズムを定義する場合、またはプロトコルが曖昧指定と2つのエンドポイント（例えば、セキュリティトークンサービスとリソースホルダー）は同じプロトコル内の異なるアルゴリズムを実装したときのセキュリティ問題のための機会が生じます。"
    },
    {
      "indent": 9,
      "text": "+----------+\n| security |\n|  token   |\n| service  |\n+----------+\n     ^\n     | 1. supply credentials and\n     |    get token for resource\n     |                                             +--------+\n+----------+  2. supply token and access resource  |resource|\n|requester |=------------------------------------->| holder |\n+----------+                                       +--------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 2: Simple Security Exchange",
      "ja": "図2：簡単なセキュリティの交換"
    },
    {
      "indent": 3,
      "text": "In many cases, the situation is more complex. With X.509 Public Key Infrastructure (PKIX) certificates [RFC6125], for example, the name in a certificate gets compared against names in ACLs or other things. In the case of web site security, the name in the certificate gets compared to a portion of the URI that a user may have typed into a browser. The fact that many different people are doing the typing, on many different types of systems, complicates the problem.",
      "ja": "多くの場合、状況はより複雑です。 X.509公開鍵インフラストラクチャ（PKIX）証明書[RFC6125]を使用すると、たとえば、証明書の名前は、ACLの中の名前または他のものと比較します。ウェブサイトのセキュリティの場合は、証明書の名前は、ユーザーがブラウザに入力している可能性があることをURIの部分に比べて取得します。多くの異なる人々が、システムの多くの異なる種類で、タイピングを行っているという事実は、問題を複雑にしています。"
    },
    {
      "indent": 3,
      "text": "Add to this the certificate enrollment step, and the certificate issuance step, and two more parties have an opportunity to adjust the encoding, or worse, the software that supports them might make changes that the parties are unaware are happening.",
      "ja": "これに証明書登録ステップ、および証明書発行ステップを追加し、さらに2人の当事者がエンコーディングを調整する機会を持っている、または悪化し、それらをサポートするソフトウェアは、当事者が気づいていない変化が起こっているになるかもしれません。"
    },
    {
      "indent": 0,
      "text": "2.1. False Positives and Negatives",
      "section_title": true,
      "ja": "2.1。偽陽性とネガ"
    },
    {
      "indent": 3,
      "text": "It is first worth discussing in more detail the effects of errors in the comparison algorithm. A \"false positive\" results when two identifiers compare as if they were equal but in reality refer to two different objects (e.g., security principals or resources). When privilege is granted on a match, a false positive thus results in an elevation of privilege -- for example, allowing execution of an operation that should not have been permitted otherwise. When privilege is denied on a match (e.g., matching an entry in a block/deny list or a revocation list), a permissible operation is denied. At best, this can cause worse performance (e.g., a cache miss or forcing redundant authentication) and at worst can result in a denial of service.",
      "ja": "これは、比較アルゴリズムにおける誤差の影響をより詳細に議論する最初の価値があります。 「偽陽性」結果ときに、2つの識別子は、それらが同じであるかのように比較実際には2つの異なるオブジェクト（例えば、セキュリティプリンシパルまたはリソース）を指します。権限が一致に付与されたときに、偽陽性は、このように特権の昇格をもたらす - 例えば、そうでなければ許可されていてはならない操作の実行を可能にします。権限が（例えば、ブロック内のエントリと一致/リストまたは失効リストを拒否）一致で拒否された場合に、許容操作は拒否されます。せいぜい、これは悪化し、性能（例えば、キャッシュミスや冗長な認証を強制）を引き起こすことがあり、最悪の場合、サービス拒否が発生することができます。"
    },
    {
      "indent": 3,
      "text": "A \"false negative\" results when two identifiers that in reality refer to the same thing compare as if they were different, and the effects are the reverse of those for false positives. That is, when privilege is granted on a match, the result is at best worse performance and at worst a denial of service; when privilege is denied on a match, elevation of privilege results.",
      "ja": "彼らは異なっていたかのように「偽陰性」の結果は、現実には同じものを参照する2つの識別子が比較するとき、および効果は偽陽性のものとは逆です。それは権限が一致に付与されたときに、結果は最高の状態で悪化し、性能やサービスの最悪の否定である、です。権限が一致に拒否された場合、特権の昇格が結果。"
    },
    {
      "indent": 3,
      "text": "Figure 3 summarizes these effects.",
      "ja": "図3は、これらの効果をまとめたもの。"
    },
    {
      "indent": 7,
      "text": "               | \"Grant on match\"       | \"Deny on match\"\n---------------+------------------------+-----------------------\nFalse positive | Elevation of privilege | Denial of service\n---------------+------------------------+-----------------------\nFalse negative | Denial of service      | Elevation of privilege\n---------------+------------------------+-----------------------",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 3: Worst Effects of False Positives/Negatives",
      "ja": "図3：偽陽性/陰性の最悪の影響"
    },
    {
      "indent": 3,
      "text": "When designing a comparison algorithm, one can typically modify it to increase the likelihood of false positives and decrease the likelihood of false negatives, or vice versa. Which outcome is better depends on the context.",
      "ja": "比較アルゴリズムを設計するとき、人は通常、偽陽性の可能性を高め、偽陰性、またはその逆の可能性を減少させるためにそれを変更することができます。どちら成果優れている文脈に依存します。"
    },
    {
      "indent": 3,
      "text": "Elevation of privilege is almost always seen as far worse than denial of service. Hence, for URIs, for example, Section 6.1 of [RFC3986] states that \"comparison methods are designed to minimize false negatives while strictly avoiding false positives\".",
      "ja": "特権の昇格は、ほとんど常にサービス拒否よりもはるかに悪いと見られています。したがって、URIのために、例えば、[RFC3986]の6.1節には、「比較方法を厳密に偽陽性を回避しながら、偽陰性を最小化するように設計されている」と述べています。"
    },
    {
      "indent": 3,
      "text": "Thus, URIs were defined with a \"grant privilege on match\" paradigm in mind, where it is critical to prevent elevation of privilege while minimizing denial of service. Using URIs in a \"deny privilege on match\" system can thus be problematic.",
      "ja": "したがって、URIは、サービス拒否を最小限に抑えながら、特権の昇格を防ぐことが重要である心の中でパラダイム「のマッチに付与特権」、と定義されていました。 「試合に権限を拒否する」システムでURIを使用すると、このように問題がある可能性があります。"
    },
    {
      "indent": 0,
      "text": "2.2. Hypothetical Example",
      "section_title": true,
      "ja": "2.2。仮定の例"
    },
    {
      "indent": 3,
      "text": "In this example, both security principals and resources are identified using URIs. Foo Corp has paid example.com for access to the Stuff service. Foo Corp allows its employees to create accounts on the Stuff service. Alice gets the account \"http://example.com/Stuff/FooCorp/alice\" and Bob gets \"http://example.com/Stuff/FooCorp/bob\". It turns out, however, that Foo Corp's URI canonicalizer includes URI fragment components in comparisons whereas example.com's does not, and Foo Corp does not disallow the # character in the account name. So Chuck, who is a malicious employee of Foo Corp, asks to create an account at example.com with the name alice#stuff. Foo Corp's URI logic checks its records for accounts it has created with stuff and sees that there is no account with the name alice#stuff. Hence, in its records, it associates the account alice#stuff with Chuck and will only issue tokens good for use with \"http://example.com/Stuff/FooCorp/alice#stuff\" to Chuck.",
      "ja": "この例では、両方のセキュリティプリンシパルおよびリソースはURIを使用して識別されます。フー社はスタッフのサービスにアクセスするためにexample.comを支払いました。フー社は、従業員が、スタッフのサービスにアカウントを作成することができます。アリスは、アカウントを取得し、「http://example.com/Stuff/FooCorp/alice」とボブは「http://example.com/Stuff/FooCorp/bob」を取得します。これは、example.comのがないのに対し、フーCorpのURIのcanonicalizerは比較でURIのフラグメントコンポーネントが含まれていること、しかし、結局のところ、およびFooのCorpがアカウント名に＃文字を禁止しません。だから、フー社の悪質な従業員であるチャックは、名前アリス＃ものでexample.comでアカウントを作成するように求められます。 FooのCorpのURIロジックは、それがものを使用して作成し、名前アリス＃のものとはアカウントが存在しないことを認識していたアカウントのためにその記録をチェックします。したがって、そのレコードに、それはチャック付きアカウントアリス＃のものを関連付け、唯一の問題は、チャックに「http://example.com/Stuff/FooCorp/alice#stuff」で使用するための良好なトークンます。"
    },
    {
      "indent": 3,
      "text": "Chuck, the attacker, goes to a security token service at Foo Corp and asks for a security token good for \"http://example.com/Stuff/FooCorp/alice#stuff\". Foo Corp issues the token, since Chuck is the legitimate owner (in Foo Corp's view) of the alice#stuff account. Chuck then submits the security token in a request to \"http://example.com/Stuff/FooCorp/alice\".",
      "ja": "チャック、攻撃者は、Fooの社でセキュリティトークンサービスに行くと「http://example.com/Stuff/FooCorp/alice#stuff」のために良いセキュリティトークンを要求します。チャックは、アリス＃スタッフアカウントの（フーCorpの観点で）正当な所有者であるため、FooのCorpが、トークンを発行します。チャックは、その後、「http://example.com/Stuff/FooCorp/alice」への要求にセキュリティトークンを送信します。"
    },
    {
      "indent": 3,
      "text": "But example.com uses a URI canonicalizer that, for the purposes of checking equality, ignores fragments. So when example.com looks in the security token to see if the requester has permission from Foo Corp to access the given account, it successfully matches the URI in the security token, \"http://example.com/Stuff/FooCorp/alice#stuff\", with the requested resource name \"http://example.com/Stuff/FooCorp/alice\".",
      "ja": "しかし、example.comが平等を確認する目的で、フラグメントを無視し、URIのcanonicalizerを使用しています。 example.comは、依頼者が指定したアカウントにアクセスするためにはFoo社の許可を持っているかどうかを確認するために、セキュリティトークンに見えるときに、それが成功しhttp://example.com/Stuff/FooCorp/alice」、セキュリティトークンにURIと一致します「要求されたリソース名で、 『#stuff http://example.com/Stuff/FooCorp/alice』。"
    },
    {
      "indent": 3,
      "text": "Leveraging the inconsistencies in the canonicalizers used by Foo Corp and example.com, Chuck is able to successfully launch an elevation-of-privilege attack and access Alice's resource.",
      "ja": "フー社とexample.comが使用するcanonicalizersの不整合を活用し、チャックは成功し、特権の昇格攻撃を開始し、アリスのリソースにアクセスすることが可能です。"
    },
    {
      "indent": 3,
      "text": "Furthermore, consider an attacker using a similar corporation, such as \"foocorp\" (or any variation containing a non-ASCII character that some humans might expect to represent the same corporation). If the resource holder treats them as different but the security token service treats them as the same, then elevation of privilege can occur in this scenario as well.",
      "ja": "また、このような「foocorp」（または一部の人間が同じ会社を表現するために期待するかもしれない非ASCII文字を含む任意のバリエーション）と同様の企業を、使用して攻撃を検討してください。リソースの所有者が異なるとして扱いますが、セキュリティトークンサービスは、同じようにそれらを扱う場合は、権限の昇格は、同様に、このシナリオで発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "3. Comparison Issues with Common Identifiers",
      "section_title": true,
      "ja": "共通の識別子と3の比較の問題"
    },
    {
      "indent": 3,
      "text": "In this section, we walk through a number of common types of identifiers and discuss various issues related to comparison that may affect security whenever they are used to identify security principals or resources. These examples illustrate common patterns that may arise with other types of identifiers.",
      "ja": "この節では、識別子の一般的な種類の数を歩くと、彼らがセキュリティプリンシパルやリソースを識別するために使用されるたびに、セキュリティに影響を与える可能性が比較に関連する様々な問題を議論します。これらの実施例は、識別子の他のタイプで生じる可能性のある一般的なパターンを示します。"
    },
    {
      "indent": 0,
      "text": "3.1. Hostnames",
      "section_title": true,
      "ja": "3.1。ホスト名"
    },
    {
      "indent": 3,
      "text": "Hostnames (composed of dot-separated labels) are commonly used either directly as identifiers, or as components in identifiers such as in URIs and email addresses. Another example is in Sections 7.2 and 7.3 of [RFC5280] (and updated in Section 3 of [RFC6818]), which specify use in PKIX certificates.",
      "ja": "ホスト名は、（ドットで区切られたラベルからなる）一般的に使用される直接識別子として、またはそのようなURIと電子メールアドレスのような識別子のコンポーネントとして。別の例は、PKIX証明書に使用するように指定セクション7.2と[RFC5280]（および[RFC6818]のセクション3で更新）7.3、です。"
    },
    {
      "indent": 3,
      "text": "In this section, we discuss a number of issues in comparing strings that appear to be some form of hostname.",
      "ja": "このセクションでは、ホスト名のいくつかのフォームのように見える文字列を比較する際に多くの問題を議論します。"
    },
    {
      "indent": 3,
      "text": "It is first worth pointing out that the term \"hostname\" itself is often ambiguous, and hence it is important that any use clarify which definition is intended. Some examples of definitions include:",
      "ja": "これは、用語「ホスト名」自体はしばしば曖昧であるため、任意の使用が意図されている定義を明確することが重要であることを指摘する価値最初です。定義のいくつかの例は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "a. A Fully Qualified Domain Name (FQDN),",
      "ja": "A。完全修飾ドメイン名（FQDN）、"
    },
    {
      "indent": 3,
      "text": "b. An FQDN that is associated with address records in the DNS,",
      "ja": "B。 DNSにアドレスレコードに関連付けられているFQDN、"
    },
    {
      "indent": 3,
      "text": "c. The leftmost label in an FQDN, or",
      "ja": "C。 FQDNの左端のラベル、または"
    },
    {
      "indent": 3,
      "text": "d. The leftmost label in an FQDN that is associated with address records.",
      "ja": "D。アドレスレコードに関連付けられているFQDNの左端のラベル。"
    },
    {
      "indent": 3,
      "text": "The use of different definitions in different places results in questions such as whether \"example\" and \"example.com\" are considered equal or not, and hence it is important when writing new specifications to be clear about which definition is meant.",
      "ja": "異なる場所で異なる定義の使用は、「例」と「example.com」と同じかないと考えられているかどうかなどの質問になり、かつ意図された定義を明確にすることが、新たな仕様を書くときに、したがって、それは重要です。"
    },
    {
      "indent": 3,
      "text": "Section 3 of [RFC6055] discusses the differences between a \"hostname\" and a \"DNS name\", where the former is a subset of the latter by using a restricted set of characters (letters, digits, and hyphens). If one canonicalizer uses the \"DNS name\" definition whereas another uses a \"hostname\" definition, a name might be valid in the former but invalid in the latter. As long as invalid identifiers are denied privilege, this difference will not result in elevation of privilege.",
      "ja": "[RFC6055]のセクション3は、「ホスト名」と前者は文字（文字、数字、およびハイフン）の制限されたセットを使用して、後者のサブセットである「DNS名」、の違いについて説明します。他には、「ホスト名」の定義を使用し、一方、1 canonicalizerは、「DNS名」の定義を使用している場合、名前は後者では、前者が、無効では有効かもしれません。限り、無効な識別子が権限を拒否されたとして、この差は、特権の昇格にはなりません。"
    },
    {
      "indent": 3,
      "text": "Section 3.1 of [RFC1034] discusses the difference between a \"complete\" domain name, which ends with a dot (such as \"example.com.\"), and a multi-label relative name such as \"example.com\" that assumes the root (\".\") is in the suffix search list. In most contexts, these are considered equal, but there may be issues if different entities in a security architecture have different interpretations of a relative domain name.",
      "ja": "想定しているような「example.com」として[RFC1034]のセクション3.1ドットで終わる「完全な」ドメイン名との間の差について説明（例えば、「example.com」を）、およびマルチラベル相対名ルートは（「」）サフィックス検索一覧です。ほとんどのコンテキストでは、これらは等しいと見なされますが、セキュリティアーキテクチャの異なるエンティティは、相対的なドメイン名の異なる解釈を持っている場合は問題があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "[IAB1123] briefly discusses issues with the ambiguity around whether a label will be \"alphabetic\" -- including, among other issues, how \"alphabetic\" should be interpreted in an internationalized environment -- and whether a hostname can be interpreted as an IP address. We explore this last issue in more detail below.",
      "ja": "[IAB1123]簡単にラベルは「アルファベット」になるかどうかの周りの曖昧さの問題を議論 - 「アルファベット」は国際環境の中でどのように解釈されるべきか、他の問題の中で、含む - とホスト名がIPアドレスとして解釈することができるかどうか。私たちは、以下でより詳細に、この最後の問題を探ります。"
    },
    {
      "indent": 0,
      "text": "3.1.1. IPv4 Literals",
      "section_title": true,
      "ja": "3.1.1。 IPv4のリテラル"
    },
    {
      "indent": 3,
      "text": "Section 2.1 of [RFC1123] states:",
      "ja": "[RFC1123]のセクション2.1で述べています："
    },
    {
      "indent": 6,
      "text": "Whenever a user inputs the identity of an Internet host, it SHOULD be possible to enter either (1) a host domain name or (2) an IP address in dotted-decimal (\"#.#.#.#\") form. The host SHOULD check the string syntactically for a dotted-decimal number before looking it up in the Domain Name System.",
      "ja": "ユーザーがインターネットホストのIDを入力するたびに、ドット区切り（「＃。＃。＃。＃」）の形で（1）ホストのドメイン名または（2）IPアドレスのいずれかを入力することが可能です。ホストは、ドメインネームシステムでそれを見て前に、ドット付き十進数のための構文上の文字列をチェックする必要があります。"
    },
    {
      "indent": 3,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 6,
      "text": "This last requirement is not intended to specify the complete syntactic form for entering a dotted-decimal host number; that is considered to be a user-interface issue.",
      "ja": "この最後の要件は、ドット区切りのホスト番号を入力するための完全な構文形式を指定するものではありません。それは、ユーザー・インタフェースの問題であると考えられています。"
    },
    {
      "indent": 3,
      "text": "In specifying the inet_addr() API, the Portable Operating System Interface (POSIX) standard [IEEE-1003.1] defines \"IPv4 dotted decimal notation\" as allowing not only strings of the form \"10.0.1.2\" but also allowing octal and hexadecimal, and addresses with less than four parts. For example, \"10.0.258\", \"0xA000102\", and \"012.0x102\" all represent the same IPv4 address in standard \"IPv4 dotted decimal\" notation. We will refer to this as the \"loose\" syntax of an IPv4 address literal.",
      "ja": "inet_addr（）APIを指定において、ポータブルオペレーティングシステムインタフェース（POSIX）標準[IEEE-1003.1]、フォーム「10.0.1.2」だけでなく、文字列を可能にも進および16進数を可能にする「IPv4の、小数点表記を点在」定義と以下の四つの部分とアドレス。例えば、「10.0.258」、「0xA000102」、および「012.0x102」全ては標準における同じIPv4アドレスを表す表記「IPv4が小数を点在」。私たちは、文字通りのIPv4アドレスの「ゆるい」構文としてこれを参照します。"
    },
    {
      "indent": 3,
      "text": "In Section 6.1 of [RFC3493], getaddrinfo() is defined to support the same (loose) syntax as inet_addr():",
      "ja": "[RFC3493]のgetaddrinfo（）のセクション6.1に）（のinet_addrと同じ（緩い）構文をサポートするために定義されます。"
    },
    {
      "indent": 6,
      "text": "If the specified address family is AF_INET or AF_UNSPEC, address strings using Internet standard dot notation as specified in inet_addr() are valid.",
      "ja": "指定されたアドレスファミリはAF_INETかAF_UNSPECであるならば、アドレス文字列のinet_addrで指定されているインターネット標準ドット表記を使用して（）有効です。"
    },
    {
      "indent": 3,
      "text": "In contrast, Section 6.3 of the same RFC states, specifying inet_pton():",
      "ja": "対照的に、同じRFC状態の6.3節は、（）はinet_ptonを指定します："
    },
    {
      "indent": 6,
      "text": "If the af argument of inet_pton() is AF_INET, the src string shall be in the standard IPv4 dotted-decimal form:",
      "ja": "inet_ptonのAF引数は（）AF_INETであるならば、SRC文字列は、標準IPv4のドット-進形式でなければなりません。"
    },
    {
      "indent": 12,
      "text": "ddd.ddd.ddd.ddd",
      "ja": "ddd.ddd.ddd.ddd"
    },
    {
      "indent": 6,
      "text": "where \"ddd\" is a one to three digit decimal number between 0 and 255. The inet_pton() function does not accept other formats (such as the octal numbers, hexadecimal numbers, and fewer than four numbers that inet_addr() accepts).",
      "ja": "「DDD」は（）は、のinet_addr 8進数、16進数、およびより少ない4つの数字として（受け入れる）1〜3個の桁の10進数はinet_pton 0と255の間（）関数は、他の形式を受け入れていないです。"
    },
    {
      "indent": 3,
      "text": "As shown above, inet_pton() uses what we will refer to as the \"strict\" form of an IPv4 address literal. Some platforms also use the strict form with getaddrinfo() when the AI_NUMERICHOST flag is passed to it.",
      "ja": "上記のように、はinet_pton（）は、IPv4の「厳格な」形態はリテラルアドレスとして我々が言及するものを使用します。 AI_NUMERICHOSTフラグは、それに渡されたときに、いくつかのプラットフォームでは、（）のgetaddrinfoに厳密形式を使用します。"
    },
    {
      "indent": 3,
      "text": "Both the strict and loose forms are standard forms, and hence a protocol specification is still ambiguous if it simply defines a string to be in the \"standard IPv4 dotted decimal form\". And, as a result of these differences, names such as \"10.11.12\" are ambiguous as to whether they are an IP address or a hostname, and even \"10.11.12.13\" can be ambiguous because of the \"SHOULD\" in the above text from RFC 1123, making it optional whether to treat it as an address or a DNS name.",
      "ja": "両方厳密緩い形態は、標準的な形態である、そしてそれは単に「標準のIPv4は、小数点形式を点在」にする文字列を定義している場合、したがって、プロトコル仕様はまだ曖昧です。そして、これらの違いの結果として、そのような「10.11.12」のような名前は、彼らはIPアドレスまたはホスト名かどうかの曖昧され、さらには「10.11.12.13は」理由「すべきである」以上でのあいまいなことができますRFC 1123からのテキスト、それはオプションのアドレスまたはDNS名としてそれを治療するかどうかを作ります。"
    },
    {
      "indent": 3,
      "text": "Protocols and data formats that can use addresses in string form for security purposes need to resolve these ambiguities. For example, for the host component of URIs, Section 3.2.2 of [RFC3986] resolves the first ambiguity by only allowing the strict form and resolves the second ambiguity by specifying that it is considered an IPv4 address literal. New protocols and data formats should similarly consider using the strict form rather than the loose form in order to better match user expectations.",
      "ja": "セキュリティ目的のために文字列形式でアドレスを使用することができますプロトコルとデータ形式は、これらのあいまいさを解決する必要があります。例えば、URIのホストコンポーネントのために、[RFC3986]のセクション3.2.2は、厳密な形式を可能にすることによって、最初の曖昧さを解決し、それがIPv4アドレスがリテラルであると考えられることを指定することによって、第二の曖昧さを解決します。新しいプロトコルやデータフォーマットも同様に良くマッチユーザーの期待するために厳格な形ではなく、緩やかなフォームを使用して検討すべきです。"
    },
    {
      "indent": 3,
      "text": "A string might be valid under the \"loose\" definition but invalid under the \"strict\" definition. As long as invalid identifiers are denied privilege, this difference will not result in elevation of privilege. Some protocols, however, use strings that can be either an IP address literal or a hostname. Such strings are at best Definite identifiers, and often turn out to be Indefinite identifiers. (See Section 4.1 for more discussion.)",
      "ja": "文字列は「厳しい」の定義の下に「緩い」の定義の下で有効ですが、無効である可能性があります。限り、無効な識別子が権限を拒否されたとして、この差は、特権の昇格にはなりません。一部のプロトコルは、しかし、文字通りのIPアドレスまたはホスト名のいずれかになります文字列を使用しています。このような文字列は、最高の状態で明確な識別子であり、そして多くの場合、無期限の識別子であることが判明します。 （より多くの議論については、セクション4.1を参照してください。）"
    },
    {
      "indent": 0,
      "text": "3.1.2. IPv6 Literals",
      "section_title": true,
      "ja": "3.1.2。 IPv6のリテラル"
    },
    {
      "indent": 3,
      "text": "IPv6 addresses similarly have a wide variety of alternate but semantically identical string representations, as defined in Section 2.2 of [RFC4291] and Section 2 of [RFC6874]. As discussed in Section 3.2.5 of [RFC5952], this fact causes problems in security contexts if comparison (such as in PKIX certificates) is done between strings rather than between the binary representations of addresses.",
      "ja": "[RFC4291]及び[RFC6874]のセクション2のセクション2.2で定義されたIPv6は、同様に、代替なく意味的に同一の文字列表現の多種多様を持って対処します。 [RFC5952]のセクション3.2.5で論じたように（例えばPKIX証明書のように）比較が文字列の間ではなく、アドレスのバイナリ表現との間で行われる場合、このことは、セキュリティコンテキストで問題を引き起こします"
    },
    {
      "indent": 3,
      "text": "[RFC5952] specified a recommended canonical string format as an attempt to solve this problem, but it may not be ubiquitously supported at present. And, when strings can contain non-ASCII characters, the same issues (and more, since hexadecimal and colons are allowed) arise as with IPv4 literals.",
      "ja": "[RFC5952]は、この問題を解決する試みとして推奨正規の文字列形式を指定し、それは遍在現時点でサポートされない可能性があります。 （16進数とコロンが許可されているので、より、）と、文字列は、同じ問題を非ASCII文字を含めることができたときにIPv4のリテラルと同様に発生します。"
    },
    {
      "indent": 3,
      "text": "Whereas (binary) IPv6 addresses are Absolute identifiers, IPv6 address literals are Definite identifiers, since string-to-address conversion for IPv6 address literals is unambiguous.",
      "ja": "（バイナリ）のIPv6アドレスは絶対的識別子であるのに対し、IPv6アドレスのリテラル文字列とアドレス変換が明白であるので、IPv6アドレスのリテラルは、明確な識別子です。"
    },
    {
      "indent": 0,
      "text": "3.1.3. Internationalization",
      "section_title": true,
      "ja": "3.1.3。国際化"
    },
    {
      "indent": 3,
      "text": "The IETF policy on character sets and languages [RFC2277] requires support for UTF-8 in protocols, and as a result many protocols now do support non-ASCII characters. When a hostname is sent in a UTF-8 field, there are a number of ways it may be encoded. For example, hostname labels might be encoded directly in UTF-8, or they might first be Punycode-encoded [RFC3492] or even percent-encoded from UTF-8.",
      "ja": "文字セットと言語[RFC2277]のIETF方針は、UTF-8のプロトコルでのサポートを必要とし、結果として多くのプロトコルは現在、非ASCII文字をサポートしています。ホスト名がUTF-8フィールドで送信されたとき、それは符号化することができる多くの方法があります。例えば、ホスト名のラベルがUTF-8で直接符号化されるかもしれない、またはそれらが最初ピュニコードエンコード[RFC3492]あるいはパーセントエンコードされたUTF-8からかもしれません。"
    },
    {
      "indent": 3,
      "text": "For example, in URIs, Section 3.2.2 of [RFC3986] specifically allows for the use of percent-encoded UTF-8 characters in the hostname as well as the use of Internationalized Domain Names in Applications (IDNA) encoding [RFC3490] using the Punycode algorithm.",
      "ja": "例えば、URIの中に、[RFC3986]のセクション3.2.2は、具体的にはパーセントエンコードUTF-8の使用を可能にするホスト名の文字だけでなく、アプリケーション（IDNA）で国際化ドメイン名の使用は、使用して、[RFC3490]をコードしますピュニコードアルゴリズム。"
    },
    {
      "indent": 3,
      "text": "Percent-encoding is unambiguous for hostnames, since the percent character cannot appear in the strict definition of a \"hostname\", though it can appear in a DNS name.",
      "ja": "パーセントエンコーディングそれがDNS名に表示できるもののパーセント文字は、「ホスト名」の厳​​密な定義に現れることができないため、ホスト名のあいまいでありません。"
    },
    {
      "indent": 3,
      "text": "Punycode-encoded labels (or \"A-labels\"), on the other hand, can be ambiguous if hosts are actually allowed to be named with a name starting with \"xn--\", and false positives can result. While this may be extremely unlikely for normal scenarios, it nevertheless provides a possible vector for an attacker.",
      "ja": "ピュニコード符号化されたラベル（または「A-ラベル」）ホストが実際に「xn--」で始まる名前と名前を付けることを許可され、偽陽性が生じる可能性があれば、一方、曖昧であってもよいです。これは、通常のシナリオの可能性は極めて低いかもしれないが、それにもかかわらず、攻撃者のための可能なベクターを提供します。"
    },
    {
      "indent": 3,
      "text": "A hostname comparator thus needs to decide whether a Punycode-encoded label should or should not be considered a valid hostname label, and if so, then whether it should match a label encoded in some other form such as a percent-encoded Unicode label (U-label).",
      "ja": "ホスト名の比較は、このようピュニコードエンコードラベルまたは有効なホスト名のラベルと考えるべきではないかどうかを決定する必要があり、そうであれば、それはそのようなパーセントエンコードされたUnicodeラベルのようないくつかの他の形式でエンコードされたラベルと一致するかどうかを（U -ラベル）。"
    },
    {
      "indent": 3,
      "text": "For example, Section 3 of \"Transport Layer Security (TLS) Extensions: Extension Definitions\" [RFC6066] states:",
      "ja": "例えば、の3章「トランスポート層セキュリティ（TLS）拡張機能：拡張定義」[RFC6066]は述べています："
    },
    {
      "indent": 6,
      "text": "\"HostName\" contains the fully qualified DNS hostname of the server, as understood by the client. The hostname is represented as a byte string using ASCII encoding without a trailing dot. This allows the support of internationalized domain names through the use of A-labels defined in [RFC5890]. DNS hostnames are case-insensitive. The algorithm to compare hostnames is described in [RFC5890], Section 2.3.2.4.",
      "ja": "「ホスト名は」クライアントによって理解されるよう、サーバーの完全修飾DNSホスト名が含まれています。ホスト名は末尾のドットなしASCIIエンコーディングを使用して、バイト文字列として表現されます。これは、[RFC5890]で定義され、ラベルを使用して国際化ドメイン名のサポートを可能にします。 DNSホスト名は大文字と小文字を区別しません。ホスト名を比較するためのアルゴリズムは[RFC5890]、セクション2.3.2.4に記載されています。"
    },
    {
      "indent": 3,
      "text": "For some additional discussion of security issues that arise with internationalization, see Section 4.2 and [TR36].",
      "ja": "国際化で発生するセキュリティ問題のいくつかの追加の議論については、4.2節および[TR36]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1.4. Resolution for Comparison",
      "section_title": true,
      "ja": "3.1.4。比較のための決議"
    },
    {
      "indent": 3,
      "text": "Some systems (specifically Java URLs [JAVAURL]) use the rule that if two hostnames resolve to the same IP address(es) then the hostnames are considered equal. That is, the canonicalization algorithm involves name resolution with an IP address being the canonical form.",
      "ja": "いくつかのシステム（具体的にはJavaのURLを[JAVAURL]）は、2つのホスト名が同じIPアドレス（ES）に解決されるならば、ホスト名が等しいと見なされることルールを使用します。つまり、正規化アルゴリズムは、標準的な形態であるIPアドレスと名前解決を必要とします。"
    },
    {
      "indent": 3,
      "text": "For example, if resolution was done via DNS, and DNS contained:",
      "ja": "例えば、解像度がDNSを介して行われた場合、およびDNSが含まれています："
    },
    {
      "indent": 23,
      "text": "example.com.  IN A 10.0.0.6\nexample.net.  CNAME example.com.\nexample.org.  IN A 10.0.0.6",
      "raw": true
    },
    {
      "indent": 3,
      "text": "then the algorithm might treat all three names as equal, even though the third name might refer to a different entity.",
      "ja": "その後、アルゴリズムは、三名が異なるエンティティを参照する場合でも、同じように、すべての3人の名前を扱うかもしれません。"
    },
    {
      "indent": 3,
      "text": "With the introduction of dynamic IP addresses; private IP addresses; multiple IP addresses per name; multiple address families (e.g., IPv4 vs. IPv6); devices that roam to new locations; commonly deployed DNS tricks that result in the answer depending on factors such as the requester's location and the load on the server whose address is returned; etc., this method of comparison cannot be relied upon. There is no guarantee that two names for the same host will resolve the name to the same IP addresses; nor that the addresses resolved refer to the same entity, such as when the names resolve to private IP addresses; nor even that the system has connectivity (and the willingness to wait for the delay) to resolve names at the time the answer is needed. The lifetime of the identifier, and of any cached state from a previous resolution, also affects security (see Section 4.4).",
      "ja": "動的IPアドレスの導入に伴い、プライベートIPアドレス。名前ごとに複数のIPアドレス。複数のアドレスファミリー（IPv6の対例えば、IPv4の）;新しい場所にローミングデバイス。そのような依頼者の位置とアドレスが返され、サーバーへの負荷などの要因に応じて、答えになり、一般的に展開されたDNSトリック。など、比較のこの方法は、依拠することはできません。同じホスト用の2つの名前が同じIPアドレスに名前を解決するという保証はありません。解決のアドレスは、このような名前がプライベートIPアドレスに解決するときと、同じエンティティを参照すること。システムが接続性（および遅延を待つ意欲）の回答が必要な時に名前を解決するために持っていてもこと。以前の解像度から識別子、およびキャッシュされた状態の寿命は、また、（セクション4.4を参照）セキュリティに影響を与えます。"
    },
    {
      "indent": 3,
      "text": "In addition, a comparison mechanism that relies on the ability to resolve identifiers such as hostnames to other identifiers such as IP addresses leaks information about security decisions to outsiders if these queries are publicly observable. (See [PRIVACY-CONS] for a deeper discussion of information disclosure.)",
      "ja": "これらのクエリは、公的に観察されている場合また、IPアドレスなどの他の識別子に、そのようなホスト名などの識別子を解決する能力に依存している比較メカニズムは、部外者には、セキュリティ上の決定に関する情報をリークします。 （情報開示のより深い議論について[PRIVACY-CONS]を参照）。"
    },
    {
      "indent": 3,
      "text": "Finally, it is worth noting that resolving two identifiers to determine if they refer to the same entity can be thought of as a use of such identifiers, as opposed to actually comparing the identifiers themselves, which is the focus of this document.",
      "ja": "最後に、それは実際には、この文書の焦点である識別子そのものを、比較とは対照的に、彼らは同じエンティティを参照するかどうかを判断するために、2つの識別子を解決することは、そのような識別子を使用すると考えることができることは注目に値します。"
    },
    {
      "indent": 0,
      "text": "3.2. Port Numbers and Service Names",
      "section_title": true,
      "ja": "3.2。ポート番号とサービス名"
    },
    {
      "indent": 3,
      "text": "Port numbers and service names are discussed in depth in [RFC6335]. Historically, there were port numbers, service names used in SRV records, and mnemonic identifiers for assigned port numbers (known as port \"keywords\" at [IANA-PORT]). The latter two are now unified, and",
      "ja": "ポート番号とサービス名は、[RFC6335]で詳しく説明されています。歴史的に、ポート番号、SRVレコードで使用されるサービス名、および（[IANA-PORT]でポート「キーワード」として知られている）に割り当てられたポート番号のニーモニック識別子がありました。後者の二つは、現在統一されており、"
    },
    {
      "indent": 3,
      "text": "various protocols use one or more of these types in strings. For example, the common syntax used by many URI schemes allows port numbers but not service names. Some implementations of the getaddrinfo() API support strings that can be either port numbers or port keywords (but not service names).",
      "ja": "さまざまなプロトコルは、文字列内のこれらのタイプの1つ以上を使用します。例えば、多くのURIスキームで使用される一般的な構文は、ポート番号ではなく、サービス名を可能にします。ポート番号またはポートキーワード（ただし、サービス名）のいずれかになりますのgetaddrinfo（）APIのサポート文字列の一部の実装。"
    },
    {
      "indent": 3,
      "text": "For protocols that use service names that must be resolved, the issues are the same as those for resolution of addresses in Section 3.1.4. In addition, Section 5.1 of [RFC6335] clarifies that service names/port keywords must contain at least one letter. This prevents confusion with port numbers in strings where both are allowed.",
      "ja": "解決しなければならないサービス名を使用するプロトコルの場合、問題は3.1.4項のアドレスの解決のためのものと同じです。また、[RFC6335]のセクション5.1は、サービス名/ポートのキーワードが少なくとも1つの文字を含まなければならないことを明確にしています。これは、両方が許可されている文字列内のポート番号との混同を防ぐことができます。"
    },
    {
      "indent": 0,
      "text": "3.3. URIs",
      "section_title": true,
      "ja": "3.3。 URI"
    },
    {
      "indent": 3,
      "text": "This section looks at issues related to using URIs for security purposes. For example, Section 7.4 of [RFC5280] specifies comparison of URIs in certificates. Examples of URIs in security-token-based access control systems include WS-*, SAML 2.0 [OASIS-SAMLv2-CORE], and OAuth Web Resource Authorization Profiles (WRAP) [OAuth-WRAP]. In such systems, a variety of participants in the security infrastructure are identified by URIs. For example, requesters of security tokens are sometimes identified with URIs. The issuers of security tokens and the relying parties who are intended to consume security tokens are frequently identified by URIs. Claims in security tokens often have their types defined using URIs, and the values of the claims can also be URIs.",
      "ja": "このセクションでは、セキュリティのためのURIを使用してに関連する問題を調べます。例えば、[RFC5280]のセクション7.4は、証明書内のURIの比較を指定します。セキュリティトークンベースのアクセス制御システムにおけるURIの例は、WS- *、SAML 2.0 [OASIS-SAMLv2-CORE]、およびOAuthのウェブリソース認可プロファイル（WRAP）のOAuth-WRAP]を含みます。このようなシステムでは、セキュリティインフラストラクチャの参加者の多様性は、URIので識別されます。例えば、セキュリティトークンの要求者は時々のURIで識別されています。セキュリティトークンを消費することが意図されているセキュリティトークンの発行者と信頼者は、頻繁なURIによって識別されます。セキュリティトークンでクレームは、多くの場合、その種類は、URIを使用して定義されている、と主張の値もURIをすることができます。"
    },
    {
      "indent": 3,
      "text": "URIs are defined with multiple components, each of which has its own rules. We cover each in turn below. However, it is also important to note that there exist multiple comparison algorithms. Section 6.2 of [RFC3986] states:",
      "ja": "URIは、独自のルールをそれぞれ有する複数のコンポーネント、と定義されます。私たちは、以下の順番でそれぞれカバーしています。しかし、複数の比較アルゴリズムが存在することに注意することも重要です。 [RFC3986]の6.2節は述べています："
    },
    {
      "indent": 6,
      "text": "A variety of methods are used in practice to test URI equivalence. These methods fall into a range, distinguished by the amount of processing required and the degree to which the probability of false negatives is reduced. As noted above, false negatives cannot be eliminated. In practice, their probability can be reduced, but this reduction requires more processing and is not cost-effective for all applications.",
      "ja": "様々な方法は、URIの等価性をテストするために実際に使用されています。これらの方法は、必要な処理の量および偽陰性の確率が低減される程度によって区別範囲に入ります。上述したように、偽陰性を排除することはできません。実際には、その確率を低減することができますが、この減少は、より多くの処理を必要とし、費用対効果のすべてのアプリケーションではありません。"
    },
    {
      "indent": 6,
      "text": "If this range of comparison practices is considered as a ladder, the following discussion will climb the ladder, starting with practices that are cheap but have a relatively higher chance of producing false negatives, and proceeding to those that have higher computational cost and lower risk of false negatives.",
      "ja": "比較の実践のこの範囲は、ラダーとみなされた場合は、以下の議論は安いですが、偽陰性を生産する比較的高い可能性を持っている慣行で始まる、はしごを登ると、高い計算コストとのリスクが低いものに進めます偽陰性。"
    },
    {
      "indent": 3,
      "text": "The ladder approach has both pros and cons. On the pro side, it allows some uses to optimize for security, and other uses to optimize for cost, thus allowing URIs to be applicable to a wide range of uses. A disadvantage is that when different approaches are taken by different components in the same system using the same identifiers, the inconsistencies can result in security issues.",
      "ja": "ラダーアプローチは、長所と短所の両方があります。プロ側では、いくつかの用途では、セキュリティのために最適化することができ、他方はコストを最適化するために使用し、こうしてURIは用途の広い範囲に適用されることを可能にします。欠点は、異なるアプローチが同一の識別子を使用して、同じシステム内の異なる構成要素によって取得されたときに、不整合がセキュリティ上の問題をもたらすことができることです。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Scheme Component",
      "section_title": true,
      "ja": "3.3.1。スキームコンポーネント"
    },
    {
      "indent": 3,
      "text": "[RFC3986] defines URI schemes as being case-insensitive US-ASCII and in Section 6.2.2.1 specifies that scheme names should be normalized to lowercase characters.",
      "ja": "[RFC3986]大文字と小文字を区別しないUS-ASCIIとセクション6.2.2.1にあるものとしてURIスキームを定義するには、スキーム名は小文字に正規化されなければならないことを指定します。"
    },
    {
      "indent": 3,
      "text": "New schemes can be defined over time. In general, however, two URIs with an unrecognized scheme cannot be safely compared. This is because the canonicalization and comparison rules for the other components may vary by scheme. For example, a new URI scheme might have a default port of X, and without that knowledge, a comparison algorithm cannot know whether \"example.com\" and \"example.com:X\" should be considered to match in the authority component. Hence, for security purposes, it is safest for unrecognized schemes to be treated as invalid identifiers. However, if the URIs are only used with a \"grant access on match\" paradigm, then unrecognized schemes can be supported by doing a generic case-sensitive comparison, at the expense of some false negatives.",
      "ja": "新制度は、​​時間をかけて定義することができます。しかし、一般に、認識されていないスキームを持つ2つのURIが安全に比較することはできません。他のコンポーネントのための正規化と比較ルールはスキームによって異なる可能性があるためです。たとえば、新しいURIスキームはXのデフォルトポートを持っているかもしれないし、その知識がなくても、比較アルゴリズムは、「example.com」と「example.com:Xは」権限コンポーネントに一致するように考慮されるべきかどうかを知ることはできません。そのため、セキュリティ目的のために、それは無効な識別子として処理されるべき認識できないスキームの最も安全です。 URIは唯一の「助成アクセスマッチの」パラダイムで使用している場合は、その後、認識できないスキームは、いくつかの偽陰性を犠牲にして、一般的な大文字と小文字を区別して比較を行うことによりサポートすることができます。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Authority Component",
      "section_title": true,
      "ja": "3.3.2。権限コンポーネント"
    },
    {
      "indent": 3,
      "text": "The authority component is scheme-specific, but many schemes follow a common syntax that allows for userinfo, host, and port.",
      "ja": "権限コンポーネントは、スキーム固有のものですが、多くのスキームはuserinfoを、ホスト、およびポートを可能にし、共通の構文に従ってください。"
    },
    {
      "indent": 0,
      "text": "3.3.2.1. Host",
      "section_title": true,
      "ja": "3.3.2.1。ホスト"
    },
    {
      "indent": 3,
      "text": "Section 3.1 discusses issues with hostnames in general. In addition, Section 3.2.2 of [RFC3986] allows future changes using the IPvFuture production. As with IPv4 and IPv6 literals, IPvFuture formats may have issues with multiple semantically identical string representations and may also be semantically identical to an IPv4 or IPv6 address. As such, false negatives may be common if IPvFuture is used.",
      "ja": "3.1節では、一般的にホスト名の問題について説明します。また、[RFC3986]のセクション3.2.2 IPvFuture生産を使用して、将来の変更を可能にします。 IPv4とIPv6のリテラルと同様に、IPvFutureフォーマットは、複数の意味的に同一の文字列表現の問題を有していてもよく、また、IPv4またはIPv6アドレスと意味的に同一であってもよいです。 IPvFutureが使用されている場合はそのように、偽陰性は共通していてもよいです。"
    },
    {
      "indent": 0,
      "text": "3.3.2.2. Port",
      "section_title": true,
      "ja": "3.3.2.2。港"
    },
    {
      "indent": 3,
      "text": "See discussion in Section 3.2.",
      "ja": "3.2節での議論を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.3.2.3. Userinfo",
      "section_title": true,
      "ja": "3.3.2.3。ユーザー情報"
    },
    {
      "indent": 3,
      "text": "[RFC3986] defines the userinfo production that allows arbitrary data about the user of the URI to be placed before '@' signs in URIs. For example, \"ftp://alice:bob@example.com/bar\" has the value \"alice:bob\" as its userinfo. When comparing URIs in a security context, one must decide whether to treat the userinfo as being significant or not. Some URI comparison services, for example, treat \"ftp://alice:ick@example.com\" and \"ftp://example.com\" as being equal.",
      "ja": "[RFC3986]はURIのユーザに関する任意のデータのURIに「@」記号の前に配置されることを可能にするユーザー情報の生産を規定します。たとえば、「FTP：//アリス：bob@example.com/bar」：そののuserinfoとして「ボブとアリス」の値を持ちます。セキュリティコンテキストでURIを比較すると、1は重要かないものとしてのuserinfoを扱うかどうかを決定する必要があります。等しいとし、「ftp://example.com」いくつかのURI比較サービスは、例えば、「ick@example.com：//アリスのftp」を扱います。"
    },
    {
      "indent": 3,
      "text": "When the userinfo is treated as being significant, it has additional considerations (e.g., whether or not it is case sensitive), which we cover in Section 3.4.",
      "ja": "ユーザー情報が重要であるとして処理する場合、それは我々が、セクション3.4で覆う追加の考慮事項（例えば、それは大文字と小文字が区別されるかどうかにかかわらず）を有します。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Path Component",
      "section_title": true,
      "ja": "3.3.3。パスコンポーネント"
    },
    {
      "indent": 3,
      "text": "[RFC3986] supports the use of path segment values such as \"./\" or \"../\" for relative URIs. As discussed in Section 6.2.2.3 of [RFC3986], they are intended only for use within a reference relative to some other base URI, but Section 5.2.4 of [RFC3986] nevertheless defines an algorithm to remove them as part of URI normalization.",
      "ja": "[RFC3986]は、そのような相対URIの「./」や「../」としてパスセグメント値の使用をサポートします。 [RFC3986]のセクション6.2.2.3で論じたように、それらは唯一のいくつかの他の基底URIに対する基準内で使用するためのものではなく、[RFC3986]のセクション5.2.4には、それにもかかわらず、URI正規化の一部としてそれらを除去するためのアルゴリズムを定義しています。"
    },
    {
      "indent": 3,
      "text": "Unless a scheme states otherwise, the path component is defined to be case sensitive. However, if the resource is stored and accessed using a filesystem using case-insensitive paths, there will be many paths that refer to the same resource. As such, false negatives can be common in this case.",
      "ja": "スキームは、別段述べない限り、パスコンポーネントは大文字と小文字を区別することと定義されます。リソースが格納され、大文字と小文字を区別しないパスを使用してファイルシステムを使用してアクセスされる場合は、同一のリソースを参照して多くのパスが存在することになります。そのため、偽陰性は、この場合には一般的なことができます。"
    },
    {
      "indent": 0,
      "text": "3.3.4. Query Component",
      "section_title": true,
      "ja": "3.3.4。クエリコンポーネント"
    },
    {
      "indent": 3,
      "text": "There is the question as to whether \"http://example.com/foo\", \"http://example.com/foo?\", and \"http://example.com/foo?bar\" are each considered equal or different.",
      "ja": "そこの質問は、「？http://example.com/foo」、か「http://example.com/foo」のようで、「http://example.com/foo?bar」それぞれ等しいと考えられていますまたは異なります。"
    },
    {
      "indent": 3,
      "text": "Similarly, it is unspecified whether the order of values matters. For example, should \"http://example.com/blah?ick=bick&foo=bar\" be considered equal to \"http://example.com/blah?foo=bar&ick=bick\"? And if a domain name is permitted to appear in a query component (e.g., in a reference to another URI), the same issues in Section 3.1 apply.",
      "ja": "同様に、値の順序が重要かどうかを指定されていません。たとえば、「http://example.com/blah?ick=bick&foo=bar」「http://example.com/blah?foo=bar&ick=bick」に等しいと考えるべきか？ドメイン名が（例えば、別のURIを参照して）クエリコンポーネントに表示されるように許可されている場合と、3.1節でも同じ問題が適用されます。"
    },
    {
      "indent": 0,
      "text": "3.3.5. Fragment Component",
      "section_title": true,
      "ja": "3.3.5。フラグメントコンポーネント"
    },
    {
      "indent": 3,
      "text": "Some URI formats include fragment identifiers. These are typically handles to locations within a resource and are used for local reference. A classic example is the use of fragments in HTTP URIs where a URI of the form \"http://example.com/blah.html#ick\" means retrieve the resource \"http://example.com/blah.html\" and, once it has arrived locally, find the HTML anchor named \"ick\" and display that.",
      "ja": "いくつかのURIフォーマットは、フラグメント識別子を含みます。これらは、典型的には、リソース内の位置に処理し、ローカル参照のために使用されています。古典的な例では、フォームのURI「http://example.com/blah.html#ick」HTTPのURIで断片の使用であるリソースを取得意味「http://example.com/blah.html」とそれがローカルに到着した後、「嫌」という名前のHTMLアンカーを見つけて、それを表示します。"
    },
    {
      "indent": 3,
      "text": "So, for example, when a user clicks on the link \"http://example.com/blah.html#baz\", a browser will check its cache by doing a URI comparison for \"http://example.com/blah.html\" and, if the resource is present in the cache, a match is declared.",
      "ja": "ユーザーがリンク「http://example.com/blah.html#baz」をクリックしたときに、例えば、ブラウザがhttp://example.com/blah」のURIの比較を行うことによって、そのキャッシュをチェックしますリソースがキャッシュに存在する場合の.html」と、一致が宣言されます。"
    },
    {
      "indent": 3,
      "text": "Hence, comparisons for security purposes typically ignore the fragment component and treat all fragments as equal to the full resource. However, if one were actually trying to compare the piece of a resource that was identified by the fragment identifier, ignoring it would result in potential false positives.",
      "ja": "したがって、セキュリティ目的のために比較は、典型的には、フラグメントコンポーネントを無視して、完全なリソースに等しいように、すべてのフラグメントを扱います。しかし、場合は、1つは実際にそれが潜在的な偽陽性につながる無視して、フラグメント識別子によって識別されたリソースの一部を比較しようとしていました。"
    },
    {
      "indent": 0,
      "text": "3.3.6. Resolution for Comparison",
      "section_title": true,
      "ja": "3.3.6。比較のための決議"
    },
    {
      "indent": 3,
      "text": "It may be tempting to define a URI comparison algorithm based on whether URIs resolve to the same content, along the lines of resolving hostnames as described in Section 3.1.4. However, such an algorithm would result in similar problems, including content that dynamically changes over time or that is based on factors such as the requester's location, potential lack of external connectivity at the time or place that comparison is done, introduction of potentially undesirable delay, etc.",
      "ja": "URIは、セクション3.1.4に記載したようにホスト名を解決する線に沿って、同一のコンテンツに解決するかどうかに基づいてURI比較アルゴリズムを定義したくてもよいです。しかしながら、このようなアルゴリズムは、動的に経時的に変化するか、またはこのような要求者の位置、比較が行われること電位時の外部接続性の欠如や場所、潜在的に望ましくない遅延の導入などの要因に基づいてコンテンツを含む、同様の問題を生じますなど"
    },
    {
      "indent": 3,
      "text": "In addition, as noted in Section 3.1.4, resolution leaks information about security decisions to outsiders if the queries are publicly observable.",
      "ja": "3.1.4で述べたようにクエリが公に観測可能である場合に加えて、解像度が部外者にセキュリティ上の決定に関する情報をリークします。"
    },
    {
      "indent": 0,
      "text": "3.4. Email Address-Like Identifiers",
      "section_title": true,
      "ja": "3.4。メールアドレス様識別子"
    },
    {
      "indent": 3,
      "text": "Section 3.4.1 of [RFC5322] defines the syntax of an email address-like identifier, and Section 3.2 of [RFC6532] updates it to support internationalization. Section 7.5 of [RFC5280] further discusses the use of internationalized email addresses in certificates.",
      "ja": "[RFC5322]のセクション3.4.1は、電子メールアドレスのような識別子の構文を定義し、[RFC6532]の3.2節には、国際化をサポートするためにそれを更新します。 [RFC5280]のセクション7.5はさらに、証明書における国際化電子メールアドレスの使用について説明します。"
    },
    {
      "indent": 3,
      "text": "Regarding the security impact of internationalized email headers, [RFC6532] points to Section 14 of [RFC6530], which contains a discussion of many issues resulting from internationalization.",
      "ja": "国際電子メールヘッダのセキュリティへの影響については、[RFC6532]は国際化に起因する多くの問題の議論を含んでいる[RFC6530]のセクション14、を指します。"
    },
    {
      "indent": 3,
      "text": "Email address-like identifiers have a local part and a domain part. The issues with the domain part are essentially the same as with hostnames, as covered earlier in Section 3.1.",
      "ja": "メールアドレスのような識別子は、ローカル部分とドメイン部分を持っています。以前のセクション3.1でカバーされてドメイン部分の問題は、基本的にホスト名と同じです。"
    },
    {
      "indent": 3,
      "text": "The local part is left for each domain to define. People quite commonly use email addresses as usernames with web sites such as banks or shopping sites, but the site doesn't know whether foo@example.com is the same person as FOO@example.com. Thus, email address-like identifiers are typically Indefinite identifiers.",
      "ja": "ローカル部分を定義するために、各ドメインのために残されています。人々は非常に一般的な銀行やショッピングサイトなどのウェブサイトとユーザ名とメールアドレスを使用しますが、サイトはfoo@example.comがFOO@example.comと同一人物であるかどうか分かりません。このように、電子メールアドレスのような識別子は、一般的に無期限の識別子です。"
    },
    {
      "indent": 3,
      "text": "To avoid false positives, some security mechanisms (such as those described in [RFC5280]) compare the local part using an exact match. Hence, like URIs, email address-like identifiers are designed for use in grant-on-match security schemes, not in deny-on-match schemes.",
      "ja": "偽陽性を回避するために、（例えば、[RFC5280]に記載されているような）いくつかのセキュリティメカニズムは、完全一致を使用してローカル部分を比較します。したがって、URIのように、電子メールアドレスのような識別子が付与オン試合セキュリティ方式での使用のために設計されている、いないで拒否-にマッチスキーム。"
    },
    {
      "indent": 3,
      "text": "Furthermore, when such identifiers are actually used as email addresses, Section 2.4 of [RFC5321] states that the local part of a mailbox must be treated as case sensitive, but if a mailbox is stored and accessed using a filesystem using case-insensitive paths, there may be many paths that refer to the same mailbox. As such, false negatives can be common in this case.",
      "ja": "そのような識別子は、実際の電子メールアドレスとして使用される場合、さらに、[RFC5321]のセクション2.4は、メールボックスのローカル部分は、大文字と小文字が区別として扱われなければならないが、メールボックスが格納されている場合と、大文字と小文字を区別しないパスを使用してファイルシステムを使用してアクセスすることを述べて、同じメールボックスを参照してください多くのパスがあるかもしれません。そのため、偽陰性は、この場合には一般的なことができます。"
    },
    {
      "indent": 0,
      "text": "4. General Issues",
      "section_title": true,
      "ja": "4.一般的な問題"
    },
    {
      "indent": 0,
      "text": "4.1. Conflation",
      "section_title": true,
      "ja": "4.1。混同"
    },
    {
      "indent": 3,
      "text": "There are a number of examples (some in the preceding sections) of strings that conflate two types of identifiers, using some heuristic to try to determine which type of identifier is given. Similarly, two ways of encoding the same type of identifier might be conflated within the same string.",
      "ja": "識別子のタイプが与えられているかを決定しようとするいくつかのヒューリスティックを使用して、識別子の二種類をconflate文字列の例の数（前のセクションの一部）があります。同様に、識別子の同じタイプをコードする2つの方法が同じ文字列内に融合されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Some examples include:",
      "ja": "いくつかの例は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. A string that might be an IPv4 address literal or an IPv6 address literal",
      "ja": "1. IPv4のリテラルまたはIPv6アドレスをリテラルに対処するかもしれない文字列"
    },
    {
      "indent": 3,
      "text": "2. A string that might be an IP address literal or a hostname",
      "section_title": true,
      "ja": "2.リテラルIPアドレスまたはホスト名であるかもしれない文字列"
    },
    {
      "indent": 3,
      "text": "3. A string that might be a port number or a service name",
      "section_title": true,
      "ja": "3.ポート番号またはサービス名であるかもしれない文字列"
    },
    {
      "indent": 3,
      "text": "4. A DNS label that might be literal or be Punycode-encoded",
      "section_title": true,
      "ja": "4.リテラルであるか、またはピュニコード、エンコードされたかもしれないDNSラベル"
    },
    {
      "indent": 3,
      "text": "Strings that allow such conflation can only be considered Definite if there exists a well-defined rule to determine which identifier type is meant. One way to do so is to ensure that the valid syntax for the two is disjoint (e.g., distinguishing IPv4 vs. IPv6 address literals by the use of colons in the latter). A second way to do so is to define a precedence rule that results in some identifiers being inaccessible via a conflated string (e.g., a host literally named \"xn--de-jg4avhby1noc0d\" may be inaccessible due to the \"xn--\" prefix denoting the use of Punycode encoding). In some cases, such inaccessible space may be reserved so that the actual set of identifiers in use is unambiguous. For example, Section 2.5.5.2 of [RFC4291] defines a range of the IPv6 address space for representing IPv4 addresses.",
      "ja": "意図された識別子のタイプを決定するために明確に定義されたルールが存在する場合、このような混同を許可ストリングのみ明確と考えることができます。そうするための1つの方法は、2つの有効な構文（例えば、後者にコロンを使用することにより、IPv6アドレスリテラル対のIPv4を区別）互いに素であることを保証することです。そうするための第二の方法は、融合した文字列（例えば、文字通りという名前のホストを経由してアクセス不能にされ、いくつかの識別子になり優先ルールを定義することで、「XNを - デjg4avhby1noc0d」原因「xn--」プレフィックスにアクセスできません）ピュニコード符号化の使用を示します。使用中の識別子の実際のセットは明白であるようにいくつかのケースでは、そのようなアクセス不能な空間が確保されてもよいです。例えば、[RFC4291]のセクション2.5.5.2は、IPv4アドレスを表すためのIPv6アドレス空間の範囲を規定しています。"
    },
    {
      "indent": 0,
      "text": "4.2. Internationalization",
      "section_title": true,
      "ja": "4.2。国際化"
    },
    {
      "indent": 3,
      "text": "In addition to the issues with hostnames discussed in Section 3.1.3, there are a number of internationalization issues that apply to many types of Definite and Indefinite identifiers.",
      "ja": "3.1.3項で述べたホスト名との問題に加えて、明確かつ不定の識別子の多くの種類に適用される国際化の問題がいくつかあります。"
    },
    {
      "indent": 3,
      "text": "First, there is no DNS mechanism for identifying whether non-identical strings would be seen by a human as being equivalent. There are problematic examples even with US-ASCII (Basic Latin) strings, including regional spelling variations such as \"color\" and \"colour\", and with many non-English cases, including partially numeric strings in Arabic script contexts, Chinese strings in Simplified and Traditional forms, and so on. Attempts to produce such alternate forms algorithmically could produce false positives and hence have an adverse effect on security.",
      "ja": "まず、非同一の文字列が同等であると人間が見られるかどうかを識別するためのDNSメカニズムは存在しません。でも、このような「色」と「色」として地域の綴りの変化など、US-ASCII（基本ラテン）文字列、と、とアラビア語のスクリプトコンテキストで部分的に数値文字列を含む多くの非英語の場合、との問題の例、簡体字の中国の文字列があります。そして伝統的な形式、およびように。そのような代替形態を製造するための試みは、アルゴリズム偽陽性を作るので、セキュリティに悪影響を与える可能性があります。"
    },
    {
      "indent": 3,
      "text": "Second, some strings are visually confusable with others, and hence if a security decision is made by a user based on visual inspection, many opportunities for false positives exist. As such, using visual inspection for security is unreliable. In addition to the security issues, visual confusability also adversely affects the usability of identifiers distributed via visual media. Similar issues can arise with audible confusability when using audio (e.g., for radio distribution, accessibility to the blind, etc.) in place of a visual medium. Furthermore, when strings conflate two types of identifiers as discussed in Section 4.1, allowing non-ASCII characters can cause one type of identifier to appear to a human as another type of identifier. For example, characters that may look like digits and dots may appear to be an IPv4 literal to a human (especially to one who might expect digits to appear in his or her native script). Hence, conflation often increases the chance of confusability.",
      "ja": "第二に、いくつかの文字列が他の人と視覚的に紛らわしい、ひいてはセキュリティの決定は、目視検査に基づいて、ユーザーによって行われた場合には、偽陽性のための多くの機会が存在します。そのため、セキュリティのために目視検査を使用すると、信頼できないです。セキュリティ上の問題に加えて、視覚的な混同も悪影響映像メディアを介して配信識別子の使いやすさに影響を与えます。オーディオを使用する場合に同様の問題は、視覚媒体の代わりに（など、無線配布のために、例えばブラインドへのアクセス）を可聴混同して生じ得ます。さらに、許可、セクション4.1で説明したように文字列が識別子の2種類をconflate時に非ASCII文字は、識別子の別のタイプとして、人間に表示されるように、識別子の1種類を引き起こす可能性があります。例えば、数字とドットのように見えるかもしれ文字は、（特に数字が彼または彼女のネイティブスクリプトで表示されることを期待するかもしれないものに）人間にはIPv4リテラルのように見えることがあります。そのため、混同はしばしば混同の可能性が高くなります。"
    },
    {
      "indent": 3,
      "text": "Determining whether a string is a valid identifier should typically be done after, or as part of, canonicalization. Otherwise, an attacker might use the canonicalization algorithm to inject (e.g., via percent encoding, Normalization Form KC (NFKC), or non-shortest-form UTF-8) delimiters such as '@' in an email address-like identifier, or a '.' in a hostname.",
      "ja": "文字列が有効な識別子であるかどうかを決定することは、通常の後に行われ、または正規化の一環としてしなければなりません。そうでなければ、攻撃者は、電子メールアドレスのような識別子に「@」、又はデリミタ（パーセントエンコーディング、正規化形式KC（NFKC）、または非最短形式のUTF-8を介して、例えば）注入する正規化アルゴリズムを使用するかもしれません「」ホスト名インチ"
    },
    {
      "indent": 3,
      "text": "Any case-insensitive comparisons need to define how comparison is done, since such comparisons may vary by the locale of the endpoint. As such, using case-insensitive comparisons in general often results in identifiers being either Indefinite or, if the legal character set is restricted (e.g., to US-ASCII), Definite.",
      "ja": "任意の大文字と小文字を区別しない比較は、このような比較は、エンドポイントのロケールによって異なる可能性があるので比較が、行われる方法を定義する必要があります。そのため、多くの場合、一般的には大文字と小文字を区別しない比較を使用すると、無期限や、法的な文字セットは、（例えば、US-ASCIIに）制限されている場合、明確いずれかであることの識別子になります。"
    },
    {
      "indent": 3,
      "text": "See also [WEBER] for a more visual discussion of many of these issues.",
      "ja": "これらの問題の多くは、より視覚的な議論については[WEBER]も参照してください。"
    },
    {
      "indent": 3,
      "text": "Finally, the set of permitted characters and the canonical form of the characters (and hence the canonicalization algorithm) sometimes vary by protocol today, even when the intent is to use the same identifier, such as when one protocol passes identifiers to the other. See [RFC6885] for further discussion.",
      "ja": "最後に、許可された文字の集合と文字の標準形（したがって、正規化アルゴリズム）が時々意図は、1つのプロトコルは、他に識別子を通過するときのように、同一の識別子を使用する場合であっても、今日のプロトコルによって異なります。さらなる議論のための[RFC6885]を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.3. Scope",
      "section_title": true,
      "ja": "4.3。範囲"
    },
    {
      "indent": 3,
      "text": "Another issue arises when an identifier (e.g., \"localhost\", \"10.11.12.13\", etc.) is not globally unique. Section 1.1 of [RFC3986] states:",
      "ja": "識別子（例えば、「localhost」を、「10.11.12.13」など）は、グローバルに一意でない場合、別の問題が生じます。 [RFC3986]のセクション1.1で述べています："
    },
    {
      "indent": 6,
      "text": "URIs have a global scope and are interpreted consistently regardless of context, though the result of that interpretation may be in relation to the end-user's context. For example, \"http://localhost/\" has the same interpretation for every user of that reference, even though the network interface corresponding to \"localhost\" may be different for each end-user: interpretation is independent of access.",
      "ja": "URIはグローバルスコープを持ち、その解釈の結果は、エンドユーザのコンテキストに関連してもよいが、一貫して関係なく、コンテキストの解釈されます。例えば、「HTTP：//は、ローカルホスト/」は、ネットワークインタフェースが「ローカルホスト」に対応していても、その基準のすべてのユーザに対して同じ解釈を有し、各エンドユーザーのために異なっていてもよい：解釈は、アクセスとは無関係です。"
    },
    {
      "indent": 3,
      "text": "Whenever an identifier that is not globally unique is passed to another entity outside of the scope of uniqueness, it will refer to a different resource and can result in a false positive. This problem is often addressed by using the identifier together with some other unique identifier of the context. For example, \"alice\" may uniquely identify a user within a system but must be used with \"example.com\" (as in \"alice@example.com\") to uniquely identify the context outside of that system.",
      "ja": "グローバルに一意でない識別子が一意の範囲の外で別のエンティティに渡されるたびに、それは別のリソースを参照し、偽陽性をもたらす可能性があります。この問題は、多くの場合、コンテキストのいくつかの他の一意の識別子と一緒に識別子を使用することによって対処されます。例えば、「アリス」が一意にシステム内でユーザを識別してもよいが、一意にそのシステムの外部コンテキストを識別するために（「alice@example.com」のように）「example.com」で使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "It is also worth noting that IPv6 addresses that are not globally scoped can be written with, or otherwise associated with, a \"zone ID\" to identify the context (see [RFC4007] for more information). However, zone IDs are only unique within a host, so they typically narrow, rather than expand, the scope of uniqueness of the resulting identifier.",
      "ja": "（詳細については[RFC4007]を参照）も、グローバルスコープされていないIPv6アドレスを用いて書かれた、またはそうでなければ、「ゾーンID」がコンテキストを識別するために関連付けることができることは注目に値します。ただし、ゾーンIDがホスト内でのみ一意であるので、彼らは一般的に狭い、というよりも、結果の識別子の一意性の範囲を拡大します。"
    },
    {
      "indent": 0,
      "text": "4.4. Temporality",
      "section_title": true,
      "ja": "4.4。一時性"
    },
    {
      "indent": 3,
      "text": "Often, identifiers are not unique across all time but have some lifetime associated with them after which they may be reassigned to another entity. For example, bob@example.com might be assigned to an employee of the Example company, but if he leaves and another Bob is later hired, the same identifier might be reused. As another example, IP address 203.0.113.1 might be assigned to one subscriber and then later reassigned to another subscriber. Security issues can arise if updates are not made in all entities that store the identifier (e.g., in an access control list as discussed in Section 2, or in a resolution cache as discussed in Section 3.1.4).",
      "ja": "多くの場合、識別子は、すべての時間にわたって一意ではないが、彼らは別のエンティティに再割り当てされることができる後にそれらに関連したいくつかの寿命を持っています。例えば、bob@example.comは例の会社の従業員に割り当てられるかもしれないが、彼は離れて、別のボブが後に雇われている場合、同じ識別子が再利用される可能性があります。別の例として、IPアドレス203.0.113.1は、1人の加入者に割り当てられることがありますし、後で別の加入者に再割り当て。更新が識別子を格納するすべての事業体で作られていない場合（第2節、または解像度キャッシュ内で説明したように、アクセス制御リストでは、例えば、セクション3.1.4で説明したように）、セキュリティ上の問題が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "This issue is similar to the issue of scope discussed in Section 4.3, except that the scope of uniqueness is temporal rather than topological.",
      "ja": "この問題は、一意のスコープが一時的ではなく、位相的であることを除いて、4.3節で述べた範囲の問題に似ています。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This entire document is about security considerations.",
      "ja": "この全体のドキュメントは、セキュリティ上の考慮事項についてです。"
    },
    {
      "indent": 3,
      "text": "To minimize issues related to elevation of privilege, any system that requires the ability to use both deny and allow operations within the same identifier space should avoid the use of Indefinite identifiers in security comparisons.",
      "ja": "特権の昇格、否定と同じ識別子空間内の操作は、セキュリティの比較における不定識別子の使用を避けるべき許可の両方を使用する能力を必要とするあらゆるシステムに関連する問題を最小限に抑えるために。"
    },
    {
      "indent": 3,
      "text": "To minimize future security risks, any new identifiers being designed should specify an Absolute or Definite comparison algorithm, and if extensibility is allowed (e.g., as new schemes in URIs allow), then the comparison algorithm should remain invariant so that unrecognized extensions can be compared. That is, security risks can be reduced by specifying the comparison algorithm, making sure to resolve any ambiguities pointed out in this document (e.g., \"standard dotted decimal\").",
      "ja": "将来のセキュリティリスクを最小限に抑えるために、設計されているすべての新しい識別子は、絶対的または明確な比較アルゴリズムを指定する必要があり、かつ拡張性が許可されている場合（URIの中に新しいスキームが許す限り、例えば）認識されていない拡張子を比較することができるように、そして比較アルゴリズムは不変のままにしてください。これは、セキュリティ上のリスクが任意のあいまいさを解決することを確認して、比較アルゴリズムを指定することによって減少させることができる。この文書（例えば、「標準ドット十進」）で指摘。"
    },
    {
      "indent": 3,
      "text": "Some issues (such as unrecognized extensions) can be mitigated by treating such identifiers as invalid. Validity checking of identifiers is further discussed in [RFC3696].",
      "ja": "（例えば認識されていない拡張機能として）いくつかの問題が無効のような識別子を処理することによって緩和することができます。識別子の妥当性チェックがさらに[RFC3696]に記載されています。"
    },
    {
      "indent": 3,
      "text": "Perhaps the hardest issues arise when multiple protocols are used together, such as in Figure 2, where the two protocols are defined or implemented using different comparison algorithms. When constructing an architecture that uses multiple such protocols, designers should pay attention to any differences in comparison algorithms among the protocols in order to fully understand the security risks. How to deal with such security risks in current systems is an area for future work.",
      "ja": "おそらく最も困難な問題は、複数のプロトコルは、2つのプロトコルが異なる比較アルゴリズムを使用して定義または実装されている図2のように、一緒に使用されるときに生じます。複数のそのようなプロトコルを使用してアーキテクチャを構築する場合、設計者は、完全にセキュリティ上のリスクを理解するために、プロトコル間比較アルゴリズムの違いに注意を払う必要があります。どのように現在のシステムでは、このようなセキュリティ上のリスクに対処することは、将来の仕事のためのエリアです。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgements",
      "section_title": true,
      "ja": "6.謝辞"
    },
    {
      "indent": 3,
      "text": "Yaron Goland contributed to the discussion on URIs. Patrik Faltstrom contributed to the background on identifiers. John Klensin contributed text in a number of different sections. Additional helpful feedback and suggestions came from Bernard Aboba, Fred Baker, Leslie Daigle, Mark Davis, Jeff Hodges, Bjoern Hoehrmann, Russ Housley, Christian Huitema, Magnus Nystrom, Tom Petch, and Chris Weber.",
      "ja": "ヤロンGolandは、URIの上の議論に貢献しました。パトリックFaltstromは、識別子の背景に貢献しました。ジョン・クレンシンは異なるセクションの数のテキストを寄付しました。追加の有用なフィードバックや提案はバーナードAboba、フレッド・ベイカー、レスリーDaigle氏、マーク・デイビス、ジェフ・ホッジス、ビョルンHoehrmann、ラスHousley、クリスチャンのHuitema、マグナスNystrom、トム・ペッチ、そしてクリス・ウェバーから来ました。"
    },
    {
      "indent": 0,
      "text": "7. IAB Members at the Time of Approval",
      "section_title": true,
      "ja": "承認時の7 IABメンバー"
    },
    {
      "indent": 3,
      "text": "Bernard Aboba Jari Arkko Marc Blanchet Ross Callon Alissa Cooper Spencer Dawkins Joel Halpern Russ Housley David Kessens Danny McPherson Jon Peterson Dave Thaler Hannes Tschofenig",
      "ja": "バーナードAbobaヤリArkkoマルク・ブランシェロスCallonアリッサ・クーパースペンサーダウキンズジョエル・ハルパーンラスHousleyデビッドKessensダニー・マクファーソンジョン・ピーターソンデーブターラーハンネスTschofenig"
    },
    {
      "indent": 0,
      "text": "8. Informative References",
      "section_title": true,
      "ja": "8.参考文献"
    },
    {
      "indent": 3,
      "text": "[IAB1123] Internet Architecture Board, \"IAB Statement: 'The interpretation of rules in the ICANN gTLD Applicant Guidebook'\", February 2012, <http://www.iab.org/documents/ correspondence-reports-documents/2012-2/iab-statement-the-interpretation-of-rules-in-the-icann-gtld-applicant-guidebook>.",
      "ja": "[IAB1123]インターネットアーキテクチャ委員会、「IAB声明： 『ICANNのgTLD申請ガイドブックのルールの解釈』」、2012年2月、<http://www.iab.org/documents/対応-レポート・ドキュメント/ 2012から2 / IAB-文解釈・オブ・ルール・イン・ザ・ICANNのgTLD--申請ガイドブック>。"
    },
    {
      "indent": 3,
      "text": "[IANA-PORT] IANA, \"Service Name and Transport Protocol Port Number Registry\", March 2013, <http://www.iana.org/assignments/service-names-port-numbers/>.",
      "ja": "[IANA-PORT] IANA、 \"サービス名とトランスポートプロトコルポート番号レジストリ\"、2013年3月、<http://www.iana.org/assignments/service-names-port-numbers/>。"
    },
    {
      "indent": 3,
      "text": "[IEEE-1003.1] IEEE and The Open Group, \"The Open Group Base Specifications, Issue 6, IEEE Std 1003.1, 2004 Edition\", IEEE Std 1003.1, 2004.",
      "ja": "[IEEE-1003.1] IEEEおよびオープン・グループ、 \"Open Groupの基本仕様、6号、IEEE STD 1003.1、2004年版\"、IEEE STD 1003.1、2004。"
    },
    {
      "indent": 3,
      "text": "[JAVAURL] Oracle, \"Class URL\", Java(TM) Platform Standard Ed. 7, 2013, <http://docs.oracle.com/javase/7/docs/api/java/net/ URL.html>.",
      "ja": "[JAVAURL]オラクル、 \"クラスURL\"、ジャワ（TM）2 Platform Standard Ed。5.0前の7、2013、<http://docs.oracle.com/javase/7/docs/api/java/net/ URL.html>。"
    },
    {
      "indent": 3,
      "text": "[OASIS-SAMLv2-CORE] Cantor, S., Ed., Kemp, J., Ed., Philpott, R., Ed., and E. Maler, Ed., \"Assertions and Protocols for the OASIS Security Assertion Markup Language (SAML) V2.0\", OASIS Standard saml-core-2.0-os, March 2005, <http://docs.oasis-open.org/security/saml/v2.0/ saml-core-2.0-os.pdf>.",
      "ja": "[OASIS-SAMLv2-CORE]カントール、S.編、ケンプ、J.、編、フィルポット、R.、編、及びE. MALER編、「OASISセキュリティアサーションマークアップ言語のためのアサーションとプロトコル（SAML）V2.0\" 、OASIS標準SAMLコア-2.0-OS、2005年3月<http://docs.oasis-open.org/security/saml/v2.0/ SAMLコア-2.0-OS。 PDF>。"
    },
    {
      "indent": 3,
      "text": "[OAuth-WRAP] Hardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, \"OAuth Web Resource Authorization Profiles\", Work in Progress, January 2010.",
      "ja": "[OAuthの-WRAP]ハルト、D.、エド。、トム、A.、イートン、B.、およびY. Goland、 \"OAuthのウェブリソース承認プロファイル\"、進歩、2010年1月の作業。"
    },
    {
      "indent": 3,
      "text": "[PRIVACY-CONS] Cooper, A., Tschofenig, H., Aboba, B., Peterson, J., Morris, J., Hansen, M., and R. Smith, \"Privacy Considerations for Internet Protocols\", Work in Progress, April 2013.",
      "ja": "[プライバシー-CONS]クーパー、A.、Tschofenig、H.、Aboba、B.、ピーターソン、J.、モリス、J.、ハンセン、M.、およびR.スミス、 \"インターネットプロトコルのためのプライバシーの考慮事項\"、仕事に進捗状況、2013年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain names - concepts and facilities\", STD 13, RFC 1034, November 1987.",
      "ja": "[RFC1034] Mockapetris、P.、 \"ドメイン名 - 概念と設備\"、STD 13、RFC 1034、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1123] Braden, R., \"Requirements for Internet Hosts - Application and Support\", STD 3, RFC 1123, October 1989.",
      "ja": "[RFC1123]ブレーデン、R.、 \"インターネットホストのための要件 - 、アプリケーションとサポート\"、STD 3、RFC 1123、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2277] Alvestrand, H.T., \"IETF Policy on Character Sets and Languages\", BCP 18, RFC 2277, January 1998.",
      "ja": "[RFC2277] Alvestrand、H.T.、 \"文字セットと言語のIETF方針\"、BCP 18、RFC 2277、1998年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3490] Faltstrom, P., Hoffman, P., and A. Costello, \"Internationalizing Domain Names in Applications (IDNA)\", RFC 3490, March 2003.",
      "ja": "[RFC3490] Faltstrom、P.、ホフマン、P.、およびA.コステロ、 \"アプリケーションにおける国際化ドメイン名（IDNA）\"、RFC 3490、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3492] Costello, A., \"Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)\", RFC 3492, March 2003.",
      "ja": "[RFC3492]コステロ、A.、 \"ピュニコード：アプリケーションにおける国際化ドメイン名のUnicodeのブートストリングのエンコード（IDNA）\"、RFC 3492、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 3493, February 2003.",
      "ja": "[RFC3493]ギリガン、R.、トムソン、S.、バウンド、J.、マッキャン、J.、およびW.スティーブンス、 \"IPv6の基本的なソケットインタフェース拡張\"、RFC 3493、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3696] Klensin, J., \"Application Techniques for Checking and Transformation of Names\", RFC 3696, February 2004.",
      "ja": "[RFC3696] Klensin、J.、 \"確認と名の形質転換のためのアプリケーションテクニック\"、RFC 3696、2004年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4007] Deering, S., Haberman, B., Jinmei, T., Nordmark, E., and B. Zill, \"IPv6 Scoped Address Architecture\", RFC 4007, March 2005.",
      "ja": "[RFC4007]デアリング、S.、ハーバーマン、B.、神明、T.、Nordmarkと、E.、およびB. Zill、 \"IPv6のスコープアドレスアーキテクチャ\"、RFC 4007、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4291] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 4291, February 2006.",
      "ja": "[RFC4291] HindenとR.とS.デアリング、 \"IPバージョン6アドレッシング体系\"、RFC 4291、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4790] Newman, C., Duerst, M., and A. Gulbrandsen, \"Internet Application Protocol Collation Registry\", RFC 4790, March 2007.",
      "ja": "[RFC4790]ニューマン、C.、Duerst、M.、およびA. Gulbrandsenの、 \"インターネットアプリケーションプロトコル照合レジストリ\"、RFC 4790、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4949] Shirey, R., \"Internet Security Glossary, Version 2\", RFC 4949, August 2007.",
      "ja": "[RFC4949] Shirey、R.、 \"インターネットセキュリティ用語集、バージョン2\"、RFC 4949、2007年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5321] Klensin, J., \"Simple Mail Transfer Protocol\", RFC 5321, October 2008.",
      "ja": "[RFC5321] Klensin、J.、 \"簡易メール転送プロトコル\"、RFC 5321、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5322] Resnick, P., Ed., \"Internet Message Format\", RFC 5322, October 2008.",
      "ja": "[RFC5322]レズニック、P.、エド。、 \"インターネットメッセージ形式\"、RFC 5322、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5952] Kawamura, S. and M. Kawashima, \"A Recommendation for IPv6 Address Text Representation\", RFC 5952, August 2010.",
      "ja": "[RFC5952]川村、S.とM.川島、RFC 5952、2010年8月、 \"IPv6アドレスのテキスト表現のための勧告\"。"
    },
    {
      "indent": 3,
      "text": "[RFC6055] Thaler, D., Klensin, J., and S. Cheshire, \"IAB Thoughts on Encodings for Internationalized Domain Names\", RFC 6055, February 2011.",
      "ja": "[RFC6055]ターラー、D.、Klensin、J.、およびS.チェシャー、 \"国際化ドメイン名のエンコーディングのIAB思考\"、RFC 6055、2011年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, January 2011.",
      "ja": "[RFC6066]イーストレイク、D.、 \"トランスポート層セキュリティ（TLS）拡張機能：拡張定義\"、RFC 6066、2011年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, March 2011.",
      "ja": "[RFC6125]サンアンドレ、P.およびJ.ホッジス、「表現およびTransport Layer Security（TLS）の文脈でインターネット公開鍵インフラストラクチャの使用X.509内のドメインベースのアプリケーションサービスのアイデンティティの検証（PKIX）証明書」、 RFC 6125、2011年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC6335] Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S. Cheshire, \"Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry\", BCP 165, RFC 6335, August 2011.",
      "ja": "[RFC6335]コットン、M.、エッゲルト、L.、タッチ、J.、ウェスター、M.、およびS.チェシャー、「IANA（Internet Assigned Numbers Authority）のサービス名とトランスポートプロトコルポート番号レジストリの管理のための手順」、BCP 165、RFC 6335、2011年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6530] Klensin, J. and Y. Ko, \"Overview and Framework for Internationalized Email\", RFC 6530, February 2012.",
      "ja": "[RFC6530] Klensin、J.とY.コ、 \"国際電子メールのための概要とフレームワーク\"、RFC 6530、2012年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6532] Yang, A., Steele, S., and N. Freed, \"Internationalized Email Headers\", RFC 6532, February 2012.",
      "ja": "[RFC6532]ヤン、A.、スティール、S.、およびN.フリード、 \"国際電子メールヘッダ\"、RFC 6532、2012年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6818] Yee, P., \"Updates to the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 6818, January 2013.",
      "ja": "[RFC6818]イー、P.、RFC 6818、2013年1月 \"インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）プロフィールの更新\"。"
    },
    {
      "indent": 3,
      "text": "[RFC6874] Carpenter, B., Cheshire, S., and R. Hinden, \"Representing IPv6 Zone Identifiers in Address Literals and Uniform Resource Identifiers\", RFC 6874, February 2013.",
      "ja": "[RFC6874]大工、B.、チェシャー、S.、およびR. Hindenと、 \"アドレスリテラルと統一資源識別子にIPv6のゾーン識別子を表現\"、RFC 6874、2013年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6885] Blanchet, M. and A. Sullivan, \"Stringprep Revision and Problem Statement for the Preparation and Comparison of Internationalized Strings (PRECIS)\", RFC 6885, March 2013.",
      "ja": "[RFC6885]ブランシェ、M.及びA.サリバン、RFC 6885、2013年3月 \"の調製および国際化された文字列（PRECIS）の比較のためのstringprepリビジョンと問題文\"。"
    },
    {
      "indent": 3,
      "text": "[TR36] Unicode Consortium, \"Unicode Security Considerations\", Unicode Technical Report #36, Revision 11, July 2012, <http://www.unicode.org/reports/tr36/>.",
      "ja": "[TR36]はUnicodeコンソーシアム、 \"Unicodeのセキュリティに関する考慮事項\"、Unicodeのテクニカルレポート＃36、リビジョン11、2012年7月、<http://www.unicode.org/reports/tr36/>。"
    },
    {
      "indent": 3,
      "text": "[USASCII] American National Standards Institute, \"Coded Character Sets -- 7-bit American Standard Code for Information Interchange (7-bit ASCII)\", ANSI X3.4, 1986.",
      "ja": "[USASCII]米国規格協会は、「コード化文字セット - 情報交換（7ビットASCII）のための7ビットの米国標準コード」、ANSI X3.4、1986。"
    },
    {
      "indent": 3,
      "text": "[WEBER] Weber, C., \"Attacking Software Globalization\", March 2010, <http://www.lookout.net/files/ Chris_Weber_Character%20Transformations%20v1.7_IUC33.pdf>.",
      "ja": "[WEBER]ウェーバー、C.、 \"ソフトウェアのグローバル化への攻撃\"、2010年3月、<http://www.lookout.net/files/ Chris_Weber_Character％20Transformations％20v1.7_IUC33.pdf>。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Dave Thaler (editor) Microsoft Corporation One Microsoft Way Redmond, WA 98052 USA",
      "ja": "デーブターラー（編集者）マイクロソフト社1マイクロソフト道、レッドモンド、ワシントン98052 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 425 703 8835 EMail: dthaler@microsoft.com",
      "ja": "電話：+1 425 703 8835 Eメール：dthaler@microsoft.com"
    }
  ]
}