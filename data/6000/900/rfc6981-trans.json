{
  "title": {
    "text": "RFC 6981 - A Framework for IP and MPLS Fast Reroute Using Not-Via Addresses",
    "ja": "RFC 6981 - 未-VIAのアドレスを使用したIPおよびMPLS高速リルートのためのフレームワーク"
  },
  "number": 6981,
  "created_at": "2019-11-02 11:47:24.212757+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         S. Bryant\nRequest for Comments: 6981                                    S. Previdi\nCategory: Informational                                    Cisco Systems\nISSN: 2070-1721                                                 M. Shand\n                                                  Individual Contributor\n                                                             August 2013",
      "raw": true
    },
    {
      "indent": 4,
      "text": "A Framework for IP and MPLS Fast Reroute Using Not-Via Addresses",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document presents an illustrative framework for providing fast reroute in an IP or MPLS network through encapsulation and forwarding to \"not-via\" addresses. The general approach described here uses a single level of encapsulation and could be used to protect unicast, multicast, and LDP traffic against link, router, and shared risk group failure, regardless of network topology and metrics.",
      "ja": "この文書では、高速でカプセル化して「いないビア」のアドレスへの転送を介してIPまたはMPLSネットワークに再ルーティングを提供するための例示的なフレームワークを提供します。ここで説明する一般的なアプローチは、カプセル化の単一レベルを使用して関係なく、ネットワークトポロジ及びメトリックのリンク、ルータ、および共有リスク群障害、に対するユニキャスト、マルチキャスト、およびLDPトラフィックを保護するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "The mechanisms presented in this document are purely illustrative of the general approach and do not constitute a protocol specification. The document represents a snapshot of the work of the Routing Area Working Group at the time of publication and is published as a document of record. Further work is needed before implementation or deployment.",
      "ja": "この文書で提示メカニズムは、一般的な手法の純粋に例示であり、プロトコルの仕様を構成するものではありません。文書は、発行時点でルーティング・エリアワーキンググループの作業のスナップショットを表し、レコードの文書として公開されています。さらに、仕事が実装または配備する前に必要とされています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6981.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6981で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. The Purpose of This Document ...............................4\n   1.2. Overview ...................................................4\n2. Requirements Language ...........................................5\n3. Overview of Not-Via Repairs .....................................5\n   3.1. Use of Equal-Cost Multi-Path ...............................6\n   3.2. Use of LFA Repairs .........................................6\n4. Not-Via Repair Path Computation .................................7\n   4.1. Computing Not-Via Repairs in Distance and Path\n        Vector Routing Protocols ...................................8\n5. Operation of Repairs ............................................8\n   5.1. Node Failure ...............................................8\n   5.2. Link Failure ...............................................9\n        5.2.1. Loop Prevention under Node Failure ..................9\n   5.3. Multi-Homed Prefixes .......................................9\n   5.4. Installation of Repair Paths ..............................11\n6. Compound Failures ..............................................12\n   6.1. Shared Risk Link Groups ...................................12\n   6.2. Local Area Networks .......................................17\n        6.2.1. Simple LAN Repair ..................................18\n        6.2.2. LAN Component Repair ...............................19\n        6.2.3. LAN Repair Using Diagnostics .......................19\n   6.3. Multiple Independent Failures .............................20\n        6.3.1. Looping Repairs ....................................20\n        6.3.2. Outline Solution ...................................21\n        6.3.3. Mutually Looping Repairs ...........................22\n               6.3.3.1. Dropping Looping Packets ..................23\n               6.3.3.2. Computing Non-looping Repairs of Repairs ..23\n        6.3.4. Mixing LFAs and Not-Via ............................25\n7. Optimizing Not-Via Computations Using LFAs .....................26\n8. Multicast ......................................................27\n9. Fast Reroute in an MPLS LDP Network ............................27\n10. Encapsulation .................................................28\n11. Routing Extensions ............................................28\n12. Incremental Deployment ........................................28\n13. Manageability Considerations ..................................29\n   13.1. Pre-failure Configuration ................................29\n   13.2. Pre-failure Monitoring and Operational Support ...........29\n   13.3. Failure Action Monitoring ................................30\n14. Security Considerations .......................................30\n15. Acknowledgements ..............................................31\n16. References ....................................................31\n   16.1. Normative References .....................................31\n   16.2. Informative References ...................................31\nAppendix A. Q-Space ...............................................33",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. The Purpose of This Document",
      "section_title": true,
      "ja": "1.1。このドキュメントの目的"
    },
    {
      "indent": 3,
      "text": "This document presents an illustrative framework for providing fast reroute around a failure in an IP or MPLS network based on the concept of tunneling or encapsulating packets via an IP address that is known to avoid the failure. The general approach described here uses a single level of encapsulation and could be used to protect unicast, multicast, and LDP traffic against link, router, and shared risk group failure, regardless of network topology and metrics.",
      "ja": "この文書は、高速のトンネルの概念に基づいて、IPまたはMPLSネットワークまたは失敗を回避することが知られているIPアドレスを経由してパケットをカプセル化し、障害の周りにリルート提供するための例示的な枠組みを提示しています。ここで説明する一般的なアプローチは、カプセル化の単一レベルを使用して関係なく、ネットワークトポロジ及びメトリックのリンク、ルータ、および共有リスク群障害、に対するユニキャスト、マルチキャスト、およびLDPトラフィックを保護するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "At the time of publication, there is no demand to deploy this technology; however, in view of the subtleties involved in the design of routing protocol extensions to provide IP Fast Reroute (IPFRR) [RFC5714], the Routing Area Working Group considered it desirable to publish this document to place on record the design considerations of the not-via address approach.",
      "ja": "公開時点で、この技術を展開する一切の需要はありません。しかし、IP高速リルート（IPFRR）[RFC5714]を提供するために、ルーティングプロトコル拡張の設計にかかわる微妙な違いを考慮して、ルーティングエリアワーキンググループは、それが望ましい記録にnot-の設計上の考慮事項を配置するために、この文書を公開すると考えられアドレスアプローチを経由して。"
    },
    {
      "indent": 3,
      "text": "The mechanisms presented in this document are purely illustrative of the general approach and do not constitute a protocol specification. The document represents a snapshot of the work of the working group at the time of publication and is published as a document of record. Additional work is needed to specify the necessary routing protocol extensions necessary to support this IPFRR method before implementation or deployment.",
      "ja": "この文書で提示メカニズムは、一般的な手法の純粋に例示であり、プロトコルの仕様を構成するものではありません。文書は、発行時点でワーキンググループの作業のスナップショットを表し、レコードの文書として公開されています。追加の作業が実装または配備する前にこのIPFRR方法をサポートするために必要な必要なルーティングプロトコルの拡張機能を指定するために必要とされます。"
    },
    {
      "indent": 0,
      "text": "1.2. Overview",
      "section_title": true,
      "ja": "1.2。概要"
    },
    {
      "indent": 3,
      "text": "When a link or a router fails, only the neighbors of the failure are initially aware that the failure has occurred. In a network operating IPFRR [RFC5714], the routers that are the neighbors of the failure repair the failure. These repairing routers have to steer packets to their destinations despite the fact that most other routers in the network are unaware of the nature and location of the failure.",
      "ja": "リンクまたはルータに障害が発生した場合、故障の唯一の隣人は、障害が発生したことを最初に認識しています。 IPFRR [RFC5714]を動作するネットワークでは、故障の隣接しているルータは、障害を修復します。これらの修復ルーターは、ネットワーク内の他のほとんどのルータは、障害の性質や場所を知らないという事実にもかかわらず、彼らの宛先にパケットを操縦する必要があります。"
    },
    {
      "indent": 3,
      "text": "A common limitation in most IPFRR mechanisms is an inability to indicate the identity of the failure and explicitly steer the repaired packet around the failure. The extent to which this limitation affects the repair coverage is topology dependent. The mechanism proposed here is to encapsulate the packet to an address that explicitly identifies the network component that the repair must avoid. This produces a repair mechanism that, provided the network is not partitioned by the failure, will always achieve a repair.",
      "ja": "最もIPFRRメカニズムに共通の制限は、障害のアイデンティティを示し、明示的に失敗周りの修理パケットを操縦することができないことです。この制限は、修理保証に影響する程度は、トポロジに依存します。ここで提案されたメカニズムは、明示的に修理は避けなければならないネットワークコンポーネントを識別するアドレスにパケットをカプセル化することです。これは、ネットワークが故障で仕切られていない提供、修復機構を生成し、常に修復を実現します。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Language",
      "section_title": true,
      "ja": "2.必要な言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Overview of Not-Via Repairs",
      "section_title": true,
      "ja": "未-VIA修理の3概要"
    },
    {
      "indent": 3,
      "text": "This section provides a brief overview of the not-via method of IPFRR. Consider the network fragment shown in Figure 1 below, in which S has a packet for some destination D that it would normally send via P and B, and that S suspects that P has failed.",
      "ja": "このセクションでは、IPFRRのないビア方法の概要を説明します。 Sは、それが正常にP及びBを介して送信するであろういくつかの宛先Dのためのパケットを有する、以下の図1に示すネットワークの断片を、検討、及びそのSはPが失敗したことを疑います。"
    },
    {
      "indent": 10,
      "text": "           A\n           |                Bp is the address to use to get\n           |                  a packet to B not via P\n           |\nS----------P----------B. . . . . . . . . .D\n \\         |        Bp^\n  \\        |          |\n   \\       |          |\n    \\      C          |\n     \\                |\n      X-------Y-------Z\n        Repair to Bp",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 1: Not-Via Repair of Router Failure",
      "ja": "図1：ルータ障害のないビアの修復"
    },
    {
      "indent": 3,
      "text": "In the not-via IPFRR method, S encapsulates the packet to Bp, where Bp is an address on node B that has the property of not being reachable from node P, i.e., the notation Bp means \"an address of node B that is only reachable not via node P\". We later show how to install the path from S to Bp such that it is the shortest path from S to B not going via P. If the network contains a path from S to B that does not transit router P, i.e., the network is not partitioned by the failure of P and the path from S to Bp has been installed, then the packet will be successfully delivered to B. In the example in Figure 1, this is the path S-X-Y-Z-B. When the packet addressed to Bp arrives at B, B removes the encapsulation and forwards the repaired packet towards its final destination.",
      "ja": "ないビアIPFRR方法において、Sは、BPは、ノードP、すなわちから到達可能ではない性質を有するノードB上のアドレスであるBpと、にパケットをカプセル化し、表記BPは、ノードBのアドレスのみである」という意味します「ノードP経由で到達可能ではありません。私たちは、後でそれがSからの最短経路は、ネットワークは、すなわち、ネットワークはトランジットルータPではありませんBにSからのパスが含まれている場合はP.経由つもりはないBにあるように、BPにSからのパスをインストールする方法を示していますパケットが正常に、図1の例ではBに配信されるPの故障によって区画とBPにSからパスがインストールされていない、そして、これはパスSXYZBあります。パケットは、BPに対処するとBに到着し、Bは、カプセル化を解除し、その最終的な目的地への修理パケットを転送します。"
    },
    {
      "indent": 3,
      "text": "Note that if the path from B to the final destination includes one or more nodes that are included in the repair path, a packet may backtrack after the encapsulation is removed. However, because the decapsulating router is always closer to the packet destination than the encapsulating router, the packet will not loop.",
      "ja": "Bから最終目的地までの経路を修復経路に含まれる1つまたは複数のノードを含む場合、カプセル化が除去された後、パケットはバックトラックしてもよいことに留意されたいです。カプセル化解除ルータは常にカプセル化ルータよりもパケットの宛先に近いしかし、パケットがループしません。"
    },
    {
      "indent": 3,
      "text": "For complete protection, all of P's neighbors will require a not-via address that allows traffic to be directed to them without traversing P. This is shown in Figure 2. Similarly, P will require a set of not-via addresses (one for each neighbor) allowing traffic to be directed to P without traversing each of those neighbors.",
      "ja": "完全な保護のために、Pの隣人のすべてではなく、経由アドレスのトラフィックはこれは同様に、図2に示されているP.を横断することなく、それらに向けられることを可能にすることが必要になります、Pはないビアアドレス（それぞれに1つのセットが必要になりますトラフィックは、これらの隣人のそれぞれを横断せずにPに向けることができるように隣人）。"
    },
    {
      "indent": 3,
      "text": "The not-via addresses are advertised in the routing protocol in a way that clearly identifies them as not-via addresses and not 'ordinary' addresses.",
      "ja": "ない-経由アドレスは明確アドレスではなく「普通」のアドレスではないビアとしてそれらを特定する方法で、ルーティングプロトコルで広告されています。"
    },
    {
      "indent": 28,
      "text": "           A\n           |Ap\n           |\n Sp      Pa|Pb\nS----------P----------B\n         Ps|Pc      Bp\n           |\n         Cp|\n           C",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 2: The Set of Not-Via P Addresses",
      "ja": "図2：未ビアPアドレスのセット"
    },
    {
      "indent": 0,
      "text": "3.1. Use of Equal-Cost Multi-Path",
      "section_title": true,
      "ja": "3.1。等価コストマルチパスの使用"
    },
    {
      "indent": 3,
      "text": "A router can use an Equal-Cost Multi-Path (ECMP) repair in place of a not-via repair.",
      "ja": "ルータがないビア修理の代わりに等価コストマルチパス（ECMP）の修復を使用することができます。"
    },
    {
      "indent": 3,
      "text": "A router computing a not-via repair path MAY subject the repair to ECMP.",
      "ja": "修理ではない - を経由してパスを計算するルータは、ECMPの修復を施してもよい（MAY）。"
    },
    {
      "indent": 0,
      "text": "3.2. Use of LFA Repairs",
      "section_title": true,
      "ja": "3.2。 LFA修理の使用"
    },
    {
      "indent": 3,
      "text": "The not-via approach provides complete repair coverage and therefore may be used as the sole repair mechanism. There are, however, advantages in using not-via in combination with Loop-Free Alternates (LFAs) and/or downstream paths as documented in [RFC5286]. In particular, LFAs do not require the assignment and management of additional IP addresses to nodes, they do not require nodes in the network to be upgraded in order to calculate not-via repair paths, and they do not require the use of encapsulation.",
      "ja": "ないビアアプローチは、完全な修理保証を提供し、従って、唯一修復機構として使用することができます。 [RFC5286]に記載されているようにループフリーのAlternates（LFAs）および/または下流経路との組み合わせではないビアを使用する際の利点は、しかし、そこです。ネットワーク内の特定において、LFAsノードに追加IPアドレスの割り当てと管理を必要としない、彼らが必要としないノードは、修復パスしないビア算出するためにアップグレードすると、それらはカプセル化の使用を必要としません。"
    },
    {
      "indent": 3,
      "text": "LFAs are computed on a per-destination basis, and in general only a subset of the destinations requiring repair will have a suitable LFA repair. In this case, those destinations that are repairable by LFAs are so repaired, and the remainder of the destinations are repaired using the not-via encapsulation. On the other hand, the path taken by an LFA repair may be less optimal than that of the equivalent not-via repair for traffic destined to nodes close to the far end of the failure, but it may be more optimal for some other traffic. This document assumes that LFAs will be used where available, but the distribution of repairs between the two mechanisms is a local implementation choice.",
      "ja": "LFAsごとの宛先に基づいて計算され、そして一般的にのみ修復を必要とする宛先のサブセットは、適切なLFA修復を有するであろう。この場合、LFAsによって修復可能であるそれらの宛先はそう修復され、そして目的地の残りの部分は、カプセル化しないビアを使用して修復されます。一方、LFA修復によって取られる経路は、障害の遠端に近いノード宛てのトラフィックのための修復を介していない等価のより少ない最適であり得るが、それはいくつかの他のトラフィックのためのより最適であり得ます。この文書では、LFAsが利用可能な場合に使用されることを前提としていますが、二つのメカニズムの間に修理の分布は局所的な実装の選択肢です。"
    },
    {
      "indent": 0,
      "text": "4. Not-Via Repair Path Computation",
      "section_title": true,
      "ja": "4.未-VIA修復経路計算"
    },
    {
      "indent": 3,
      "text": "The not-via repair mechanism requires that all routers on the path from S to B (Figure 1) have a route to Bp. They can calculate this by failing node P, running a Shortest Path First (SPF) algorithm, and finding the shortest route to B.",
      "ja": "ないビア修復機構は、BのSからの経路上の全てのルータ（図1）は、BPにルートを有することを必要とします。これらは、ノードPを失敗最短パス優先（SPF）アルゴリズムを実行し、そしてBへの最短経路を見つけることによってこれを計算することができます。"
    },
    {
      "indent": 3,
      "text": "A router has no simple way of knowing whether it is on the shortest path for any particular repair. It is therefore necessary for every router to calculate the path it would use in the event of any possible router failure. Each router therefore \"fails\" every router in the network, one at a time, and calculates its own best route to each of the neighbors of that router. In other words, with reference to Figure 1, routers A, B, C, X, Y, Z, and P will consider each router in turn, assume that the router has failed, and then calculate its own route to each of the not-via addresses advertised by the neighbors of that router. In other words, in the case of a presumed failure of P, ALL routers (S, A, B, C, X, Y, and Z in this case) calculate their routes to Sp, Ap, Bp, and Cp -- in each case, not via P.",
      "ja": "ルータは、特定の修理のための最短経路上にあるかどうかを知る簡単な方法がありません。すべてのルータが、それはすべての可能なルータに障害が発生した場合に使用するパスを計算することが必要があります。各ルータは、したがって、ネットワーク内のすべてのルータを1つずつ「失敗した」と、そのルータの隣人のそれぞれに独自の最適なルートを計算します。換言すれば、図1を参照して、B、C、X、Y、Zのルータ、およびPは、順番に各ルータを検討ルータが故障していると仮定し、次にないのそれぞれに独自のルートを計算しますそのルータのネイバーによってアドバタイズアドレス-via。換言すれば、Pの推定故障の場合に、すべてのルータ（S、A、B、C、X、Y、この場合のZ）はSpのは、AP、BP、及びCpへのルートを計算 - でいずれの場合も、ないP.経由"
    },
    {
      "indent": 3,
      "text": "To calculate the repair paths, a router has to calculate n-1 SPFs where n is the number of routers in the network. This is expensive to compute. However, the problem is amenable to a solution in which each router (X) proceeds as follows. X first calculates the base topology with all routers functional and determines its normal path to all not-via addresses. This can be performed as part of the normal SPF computation. For each router P in the topology, X then performs the following actions:",
      "ja": "修復経路を計算するために、ルータは、nは、ネットワーク内のルータの数はn-1 SPF値を計算しなければなりません。これは、計算が高価です。しかし、問題は、次のように各ルータ（X）は、進行した溶液に適しています。 Xは、第一の機能のすべてのルータを有するベース・トポロジーを計算し、すべてのアドレスではないビアへのその通常の経路を決定します。これは通常のSPF計算の一部として実行することができます。トポロジ内の各ルータPは、Xは、次のアクションを実行します。"
    },
    {
      "indent": 3,
      "text": "1. Removes router P from the topology.",
      "section_title": true,
      "ja": "1.トポロジからルータのPを削除します。"
    },
    {
      "indent": 3,
      "text": "2. Performs an incremental SPF (iSPF) [ISPF] on the modified topology. The iSPF process involves detaching the sub-tree affected by the removal of router P and then reattaching the detached nodes. However, it is not necessary to run the iSPF to completion. It is sufficient to run the iSPF up to the point where all of the nodes advertising not-via P addresses have been reattached to the Shortest Path Tree (SPT), and then terminate it.",
      "ja": "2.改変トポロジー上のインクリメンタルSPF（ISPF）ISPF]を実行します。 ISPFプロセスは、ルータPの除去によって影響を受けるサブツリーを分離した後、剥離ノードを再接続することを含みます。しかし、完了するまでISPFを実行する必要はありません。ノードの広告のすべてのPアドレスが最短パスツリー（SPT）に再接続されていない-経由地点までのISPFを実行し、それを終了するのに十分です。"
    },
    {
      "indent": 3,
      "text": "3. Reverts to the base topology.",
      "section_title": true,
      "ja": "3.基本トポロジに戻します。"
    },
    {
      "indent": 3,
      "text": "This algorithm is significantly less expensive than a set of full SPFs. Thus, although a router has to calculate the repair paths for n-1 failures, the computational effort is much less than n-1 SPFs.",
      "ja": "このアルゴリズムは、フルSPF値のセットよりも大幅に安価です。ルータは、n-1の障害の修復経路を計算する必要があるもののしたがって、計算量はn-1個のSPF値よりはるかに小さいです。"
    },
    {
      "indent": 3,
      "text": "Experiments on a selection of real-world network topologies with between 40 and 400 nodes suggest that the worst-case computational complexity using the above optimizations is equivalent to performing between 5 and 13 full SPFs. Further optimizations are described in Section 6.",
      "ja": "40〜400ノードと実世界のネットワークトポロジの選択に関する実験は、上記の最適化を使用して、最悪の場合、計算の複雑さは5と13フルSPF値の間で実行することと等価であることを示唆しています。さらなる最適化は、セクション6に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.1. Computing Not-Via Repairs in Distance and Path Vector Routing Protocols",
      "ja": "4.1。距離とパスベクトルルーティングプロトコルで計算されない-経由の修理"
    },
    {
      "indent": 3,
      "text": "While this document focuses on link-state routing protocols, it is equally possible to compute not-via repairs in distance vector (e.g., RIP) or path vector (e.g., BGP) routing protocols. This can be achieved with very little protocol modification by advertising the not-via address in the normal way but ensuring that the information about a not-via address Ps is not propagated through the node S. In the case of link protection, this simply means that the advertisement from P to S is suppressed, with the result that S and all other nodes compute a route to Ps that doesn't traverse S, as required.",
      "ja": "この文書は、リンクステートルーティングプロトコルに焦点を当てているが、距離ベクトル（例えば、RIP）またはパスベクトル修理しないビア（例えば、BGP）ルーティングプロトコルを算出しても良いです。これは、通常の方法ではない-経由でアドレスを広告するが、PSはリンク保護の場合、ノードSを介して伝播されていないではない、経由アドレスに関する情報が、これは単に意味していることを保証することにより、非常に少ないプロトコルの変更で達成することができますPからSへの広告は、必要に応じて、S、他のすべてのノードが、Sを通過しないPSにルートを計算し、その結果、抑制されます。"
    },
    {
      "indent": 3,
      "text": "In the case of node protection, where P is the protected node and N is some neighbor, the advertisement of Np needs to be suppressed not only across the link N-P but also across any link to P. The simplest way of achieving this is for P itself to perform the suppression of any address of the form Xp.",
      "ja": "Pは保護ノードであり、Nは、いくつかの隣人であるノード保護の場合には、Np個の広告がリンクNPを横切ってもP.へのリンク経由だけでなく、抑制される必要があり、これを達成する最も簡単な方法は、Pのためのものですそれ自体は、フォームのXPのの任意のアドレスの抑制を実行します。"
    },
    {
      "indent": 0,
      "text": "5. Operation of Repairs",
      "section_title": true,
      "ja": "修理の5.操作"
    },
    {
      "indent": 3,
      "text": "This section explains the basic operation of the not-via repair of node and link failure.",
      "ja": "このセクションでは、ノードとリンク障害のないビア修理の基本的な操作を説明しています。"
    },
    {
      "indent": 0,
      "text": "5.1. Node Failure",
      "section_title": true,
      "ja": "5.1。ノード障害"
    },
    {
      "indent": 3,
      "text": "When router P fails (Figure 2), S encapsulates any packet that it would send to B via P to Bp and then sends the encapsulated packet on the shortest path to Bp. S follows the same procedure for routers A and C in Figure 2. The packet is decapsulated at the repair target (A, B, or C) and then forwarded normally to its destination. The repair target can be determined as part of the normal SPF by recording the \"next-next hop\" for each destination in addition to the normal next hop. The next-next hop is the router that the next-hop router regards as its own next hop to the destination. In Figure 1, B is S's next-next hop to D.",
      "ja": "ルータPは（図2）が失敗した場合、Sは、BPにPを介してBに送信するであろう任意のパケットをカプセル化した後、BPに最短経路でカプセル化されたパケットを送信します。 Sは、パケットが修復対象（A、B、又はC）でデカプセル化し、その宛先に正常に転送され、図2にルータAおよびCのために同じ手順に従います。修復対象は、通常、次のホップに加えて、各宛先は、「次の次のホップ」を記録することにより、正常なSPFの一部として決定することができます。次の次のホップがネクストホップルータは、宛先への独自のネクストホップとしてみなしルータです。図1において、BはDにSの次の次ホップであります"
    },
    {
      "indent": 3,
      "text": "Notice that with this technique only one level of encapsulation is needed, and that it is possible to repair ANY failure regardless of link metrics and any asymmetry that may be present in the network. The only exception to this is where the failure was a single point of failure that partitioned the network, in which case ANY repair is clearly impossible.",
      "ja": "この技術を用いてカプセル化の唯一のレベルが必要とされていることに注意してください、そして、関係なく、リンクメトリックのいずれかの障害が発生し、ネットワーク内に存在する可能性の非対称性を修復することも可能です。障害がANY修理は明らかに不可能であり、その場合には、ネットワークを分割単一障害点としたところ、この唯一の例外はあります。"
    },
    {
      "indent": 0,
      "text": "5.2. Link Failure",
      "section_title": true,
      "ja": "5.2。リンク障害"
    },
    {
      "indent": 3,
      "text": "The normal mode of operation of the network would be to assume router failure. However, where some destinations are only reachable through the failed router, it is desirable that an attempt be made to repair to those destinations by assuming that only a link failure has occurred.",
      "ja": "ネットワークの通常の動作モードでは、ルータの故障を想定することです。いくつかの都市が失敗したルータを介してのみ到達可能な場所しかし、試みが唯一のリンクに障害が発生したことを想定して、それらの宛先に修復させることが望ましいです。"
    },
    {
      "indent": 3,
      "text": "To perform a link repair, S encapsulates to Ps (i.e., it instructs the network to deliver the packet to P not via S). All of the neighbors of S will have calculated a path to Ps in case S itself had failed. S could therefore give the packet to any of its neighbors (except, of course, P). However, S SHOULD send the encapsulated packet on the shortest available path to P. This path is calculated by running an SPF with the link S-P removed. Note that this may again be an incremental calculation, which can terminate when address Ps has been reattached.",
      "ja": "リンクの修復を行うために、Sは、PS（すなわち、それではないSを介してPにパケットを配信するためにネットワークに指示する）にカプセル化します。 S自体が失敗した場合にはSの隣人のすべては、PSへのパスを計算しています。 Sは、したがって、（P、もちろん、除いて）その隣人のいずれかにパケットを与えることができます。ただし、Sは、このパスが除去リンクS-PとのSPFを実行することによって計算されるPに最短利用可能なパスにカプセル化されたパケットを送信すべきです。これは再びアドレスPsが再接続されたときに終了することができる増分計算であってもよいことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Loop Prevention under Node Failure",
      "section_title": true,
      "ja": "5.2.1。ノード障害の下でループ防止"
    },
    {
      "indent": 3,
      "text": "It is necessary to consider the behavior of IPFRR solutions when a link repair is attempted in the presence of node failure. In its simplest form, the not-via IPFRR solution prevents the formation of loops as a result of mutual repair, by never providing a repair path for a not-via address. The repair of packets with not-via addresses is considered in more detail in Section 6.3. Referring to Figure 2, if A was the neighbor of P that was on the link repair path from S to P, and P itself had failed, the repaired packet from S would arrive at A encapsulated to Ps. A would have detected that the A-P link had failed and would normally attempt to repair the packet. However, no repair path is provided for any not-via address, and so A would be forced to drop the packet, thus preventing the formation of a loop.",
      "ja": "リンクの修復がノード障害の存在にしようとした場合IPFRRソリューションの動作を考慮する必要があります。その最も単純な形態ではなく、ビアIPFRR溶液はないビアアドレスの修復経路を提供することがないことにより、相互修復の結果として、ループの形成を防止します。ないビアアドレスを持つパケットの修理は、6.3節でより詳細に検討されます。 AはPへSからリンク修復経路にあったPの隣人であり、P自体が失敗した場合に図2を参照すると、Sから修復パケットがPSにカプセル化に到着します。 A-Pのリンクが失敗したと正常にパケットを修復しようとすることを検出しているだろう。しかし、修復経路は任意ではないビアアドレスのために提供されず、これによりループの形成を防止し、パケットをドロップすることを余儀なくされるであろう。"
    },
    {
      "indent": 0,
      "text": "5.3. Multi-Homed Prefixes",
      "section_title": true,
      "ja": "5.3。マルチホームプレフィックス"
    },
    {
      "indent": 3,
      "text": "A Multi-Homed Prefix (MHP) is a prefix that is reachable via more than one router in the network. Some of these may be repairable using LFAs as described in [RFC5286]. Only those without such a repair need be considered here.",
      "ja": "マルチホームプレフィックス（MHP）は、ネットワーク内の複数のルータを介して到達可能プレフィクスです。 [RFC5286]に記載されているように、これらのいくつかはLFAsを使用して修理することができます。のみが、このような修理せずには、ここでは考慮される必要があります。"
    },
    {
      "indent": 3,
      "text": "When IPFRR router S (Figure 3) discovers that P has failed, it needs to send packets addressed to the MHP X, which is normally reachable through P, to an alternate router that is still able to reach X.",
      "ja": "IPFRRルータS（図3）Pが失敗したことを検出すると、そのパケットを送信する必要が依然としてX.に到達することができる代替のルータに、Pを介して通常到達可能であるMHP X、宛て"
    },
    {
      "indent": 12,
      "text": "X                          X                          X\n|                          |                          |\n|                          |                          |\n|                Sp        |Pb                        |\nZ...............S----------P----------B...............Y\n                         Ps|Pc      Bp\n                           |\n                         Cp|\n                           C",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 3: Multi-Homed Prefixes",
      "ja": "図3：マルチホームプレフィックス"
    },
    {
      "indent": 3,
      "text": "S SHOULD choose the closest router that can reach X during the failure as the alternate router. S determines which router to use as the alternate while running the SPF with P removed. This is accomplished by the normal process of reattaching a leaf node to the core topology (this is sometimes known as a \"partial SPF\").",
      "ja": "Sは、代替ルータとして障害時にXに到達することができ、最も近いルータを選択する必要があります。 Sを除去PとのSPFを実行している間、代替として使用するルータを判定する。これは（これは時には「部分SPF」として知られている）コアトポロジにリーフノードを再接続する通常のプロセスによって達成されます。"
    },
    {
      "indent": 3,
      "text": "First, consider the case where the shortest alternate path to X is via Z. S can reach Z without using the removed router P. However, S cannot just send the packet towards Z, because the other routers in the network will not be aware of the failure of P and may loop the packet back to S. S therefore encapsulates the packet to Z (using a normal address for Z). When Z receives the encapsulated packet, it removes the encapsulation and forwards the packet to X.",
      "ja": "ネットワーク上の他のルータが認識されませんので、まず、Xへの最短の代替パスがしかし取り外しルータP.を使用せずにZに到達することができZ. Sを経由している場合を考える、Sはちょうど、Zに向けてパケットを送信することはできません。 Pの故障と背面S. Sにループパケットはしたがって（Zための通常のアドレスを使用して）Zにパケットをカプセル化してもよいです。 Zは、カプセル化されたパケットを受信すると、カプセル化を除去してXにパケットを転送します"
    },
    {
      "indent": 3,
      "text": "Now consider the case where the shortest alternate path to X is via Y, which S reaches via P and B. To reach Y, S must first repair the packet to B using the normal not-via repair mechanism. To do this, S encapsulates the packet for X to Bp. When B receives the packet, it removes the encapsulation and discovers that the packet is intended for MHP X. The situation now reverts to the previous case, in which the shortest alternate path does not require traversal of the failure. B therefore follows the algorithm above and encapsulates the packet to Y (using a normal address for Y). Y removes the encapsulation and forwards the packet to X.",
      "ja": "今Xへの最短の代替経路SがYに到達するためにP及びBを介して到達Yを介してであり、Sは、まず正常でないビア修復機構を使用してBにパケットを修復しなければならない場合を考えます。これを行うには、Sは、BPにXのためのパケットをカプセル化します。 Bはパケットを受信すると、カプセル化を取り除き、パケットは状況が今最短代替パスが障害のトラバースを必要としないで、前の場合、に戻りMHP Xのために意図されていることを発見します。 Bは、したがって、上記のアルゴリズムに従い、Y（Yの通常のアドレスを使用して）にパケットをカプセル化します。 Yは、カプセル化を解除し、Xにパケットを転送します"
    },
    {
      "indent": 3,
      "text": "It may be that the cost of reaching X using local delivery from the alternate router (i.e., Z or Y) is greater than the cost of reaching X via P. Under those circumstances, the alternate router would normally forward to X via P, which would cause the IPFRR repair to loop. To prevent the repair from looping, the alternate router MUST locally deliver a packet received via a repair encapsulation. This may be specified by using a special address with the above semantics.",
      "ja": "これは、Pを介してであろう通常の順方向Xに、代替ルータ（すなわち、ZまたはY）からの局所送達を用いてXに到達するコストは、これらの状況下でP.を介してXに到達するコストよりも大きいことをその代替ルータであってもよいですループにIPFRR修復を引き起こします。ループからの修復を防止するために、代替的なルータは、ローカル修復カプセル化を介して受信したパケットを供給しなければなりません。これは、上記の意味を持つ特別なアドレスを使用して指定することができます。"
    },
    {
      "indent": 3,
      "text": "Note that only one such address is required per node. Notice that using the not-via approach, only one level of encapsulation was needed to repair MHPs to the alternate router.",
      "ja": "一つだけ、そのようなアドレスはノードごとに必要とされることに注意してください。アプローチではない - を経由して、カプセル化の唯一のレベルが代替ルータへのMHPを修復するために必要とされた使用していることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.4. Installation of Repair Paths",
      "section_title": true,
      "ja": "5.4。修復パスのインストール"
    },
    {
      "indent": 3,
      "text": "The following algorithm is used by node S (Figure 3) to pre-calculate and install repair paths in the Forwarding Information Base (FIB), ready for immediate use in the event of a failure. It is assumed that the not-via repair paths have already been calculated as described above.",
      "ja": "以下のアルゴリズムは、計算を事前と障害が発生した場合にすぐに使用でき転送情報ベース（FIB）で修復経路をインストールするノードS（図3）で使用されます。なお、上記のように修理しないビア経路が既に計算されているものとします。"
    },
    {
      "indent": 3,
      "text": "For each neighbor P, consider all destinations that are reachable via P in the current topology:",
      "ja": "各隣接Pについて、現在のトポロジにPを経由して到達可能な全ての目的地を考慮してください。"
    },
    {
      "indent": 3,
      "text": "1. For all destinations with an ECMP or LFA repair (as described in [RFC5286]), install that repair.",
      "ja": "ECMPまたはLFA修復を持つすべての宛先に対して1（[RFC5286]に記載されているように）、その修復をインストールします。"
    },
    {
      "indent": 3,
      "text": "2. For each destination (DR) that remains, identify in the current topology the next-next hop (H) (i.e., the neighbor of P that P will use to send the packet to DR). This can be determined during the normal SPF run by recording the additional information. If S has a path to the not-via address Hp (H not via P), install a not-via repair to Hp for the destination DR.",
      "ja": "現在のトポロジで識別し、残っている各宛先（DR）2.次の次のホップ（H）（即ち、Pは、DRにパケットを送信するために使用するPの隣）。これは、追加情報を記録することにより、通常のSPFの実行中に決定することができます。 Sはないビアアドレス馬力（P経由Hではない）へのパスを持っている場合、インストールしないビア先DR用のHPに修理。"
    },
    {
      "indent": 3,
      "text": "3. Identify all remaining destinations (M) that can still be reached when node P fails. These will be multi-homed prefixes that are not repairable by LFA, and for which the normal attachment node is P (or a router for which P is a single point of failure), and that have an alternative attachment point that is reachable after P has failed. One way of determining these destinations would be to run an SPF rooted at S with node P removed, but an implementation may record alternative attachment points during the normal SPF run. In either case, the next-best point of attachment can also be determined for use in step (4) below.",
      "ja": "3.ノードPが失敗したときに依然として到達可能なすべての残りの宛先（M）を特定します。これらは、LFAによって修復されないマルチホームプレフィックスとなり、そのため通常のアタッチメントノードは、P（又はPが単一障害点となるため、ルータ）であり、かつ、P後に到達可能な代替接続ポイントを有します失敗した。これらの送信先を決定する1つの方法は、除去ノードPとSをルートSPFを実行することであろうが、実装は、通常のSPFの実行中に別の接続点を記録してもよいです。いずれの場合においても、添付の次善のポイントは、以下のステップ（4）で使用するために決定することができます。"
    },
    {
      "indent": 3,
      "text": "4. For each multi-homed prefix (M) identified in step (3):",
      "section_title": true,
      "ja": "ステップ（3）で識別された各マルチホームプレフィックス（M）4.。"
    },
    {
      "indent": 7,
      "text": "A.  Identify the new attachment node (as shown in Figure 3).\n    This may be:",
      "raw": true
    },
    {
      "indent": 11,
      "text": "o Y, where the next hop towards Y is P, or",
      "ja": "O Yに向かう次のホップをP Y、または"
    },
    {
      "indent": 11,
      "text": "o Z, where the next hop towards Z is not P.",
      "ja": "Zに向かって次のホップがP.ないZ、O"
    },
    {
      "indent": 11,
      "text": "If the attachment node is Z, install the repair for M as a tunnel to Z' (where Z' is the address of Z that is used to force local forwarding).",
      "ja": "アタッチメントノードがZである場合、「（ローカル転送を強制するために使用されるZのアドレスであり、Z Z」は）へのトンネルのようにM用の修復をインストール。"
    },
    {
      "indent": 7,
      "text": "B. For the subset of prefixes (M) that remain (having attachment point Y), install the repair path previously installed for destination Y.",
      "ja": "（アタッチメントポイントYを有する）のままプレフィックスのサブセット（M）の場合B.、以前に宛先Y.ためにインストール修復経路をインストール"
    },
    {
      "indent": 7,
      "text": "For each destination (DS) that remains, install a not-via repair to Ps (P not via S). Note that these are destinations for which node P is a single point of failure, and they can only be repaired by assuming that the apparent failure of node P was simply a failure of the S-P link. Note that, if available, a downstream path to P MAY be used for such a repair. This cannot generate a persistent loop in the event of the failure of node P, but if one neighbor of P uses a not-via repair and another uses a downstream path, it is possible for a packet sent on the downstream path to be returned to the sending node inside a not-via encapsulation. Since packets destined to not-via addresses are not repaired, the packet will be dropped after executing a single turn of the loop.",
      "ja": "残っている各宛先（DS）のために、PS（S介しPず）にないビア修復をインストールします。これらは、ノードPは、単一障害点であり、それらは唯一のノードPの見かけ上の障害は、単にS-Pリンクの失敗だったと仮定することによって修復することができるの宛先であることに留意されたいです。利用可能な場合、Pの下流経路は、修復のために使用してもよいし、ことに留意されたいです。これは、ノードPの障害が発生した場合に持続的なループを生成することができないが、Pのいずれかのネイバーが修復しないビア使用し、別のダウンストリームパスを使用する場合、それに返される下流経路上で​​送信されたパケットのために可能ですないビアカプセル内部の送信ノード。ないビアアドレス宛てのパケットが修復されていないので、パケットはループの単一ターンを実行した後に削除されます。"
    },
    {
      "indent": 3,
      "text": "Note that where multiple next-next hops are available to reach DR, any or several of them may be chosen from a routing correctness point of view. Unless other factors require consideration, the closest next-next hop to the repairing router would be the normal choice.",
      "ja": "複数の次の次のホップがDRに到達するために利用可能である場合、それらのいずれか、またはいくつかのビューのルーティング正確点から選択することができることに留意されたいです。他の要因が考慮を必要としない限り、修理ルータに最も近い次の次のホップは、通常の選択です。"
    },
    {
      "indent": 0,
      "text": "6. Compound Failures",
      "section_title": true,
      "ja": "6.化合物の失敗"
    },
    {
      "indent": 3,
      "text": "The following types of failures involve more than one component:",
      "ja": "障害の種類は次の複数のコンポーネントを必要とします："
    },
    {
      "indent": 3,
      "text": "1. Shared Risk Link Groups",
      "section_title": true,
      "ja": "1.共有リスクリンクグループ"
    },
    {
      "indent": 3,
      "text": "2. Local Area Networks",
      "section_title": true,
      "ja": "2.ローカル・エリア・ネットワーク"
    },
    {
      "indent": 3,
      "text": "3. Multiple Independent Failures",
      "section_title": true,
      "ja": "3.複数の独立した障害"
    },
    {
      "indent": 3,
      "text": "The considerations that apply in each of the above situations are described in the following sections.",
      "ja": "上記の状況の各々に適用する考慮事項は、以下のセクションに記載されています。"
    },
    {
      "indent": 0,
      "text": "6.1. Shared Risk Link Groups",
      "section_title": true,
      "ja": "6.1。共有リスクリンクグループ"
    },
    {
      "indent": 3,
      "text": "A Shared Risk Link Group (SRLG) is a set of links whose failure can be caused by a single action such as a conduit cut or line card failure. When repairing the failure of a link that is a member of an SRLG, it MUST be assumed that all the other links that are also members of the SRLG have also failed. Consequently, any repair path needs to be computed to avoid not only the adjacent link but also all the links that are members of the same SRLG.",
      "ja": "共有リスクリンクグループ（SRLG）は、障害などコンジット・カットまたはラインカードの故障などの単一の作用によることができるリンクのセットです。 SRLGのメンバーであるリンクの障害を修復するとき、また、SRLGのメンバーであるすべての他のリンクも失敗していることを前提としなければなりません。その結果、いずれの修理・パスは、隣接するリンクも同じSRLGのメンバーであるすべてのリンクだけでなく、を避けるために計算する必要があります。"
    },
    {
      "indent": 3,
      "text": "In Figure 4 below, the links S-P and A-B are both members of SRLG \"a\". The semantics of the not-via address Ps changes from simply \"P not via the link S-P\" to be \"P not via the link S-P or any other link with which S-P shares an SRLG\". In Figure 4, these are the links that are members of SRLG \"a\", i.e., links S-P and A-B. Since the information about SRLG membership of all links is available in the link-state database, all nodes computing routes to the not-via address Ps can infer these semantics and perform the computation by failing all the links in the SRLG when running the iSPF.",
      "ja": "以下、図4において、リンクS-PおよびBは両方SRLG \"A\" のメンバーです。ないビアアドレスPsの変化「リンクS-Pを介してPない」単にからのセマンティクスがあることを「PはないリンクS-Pまたは任意の他のリンクを介していると共有SRLG-P S」。図4では、これらはSRLG「A」のメンバーであるリンクである、すなわち、S-Pと-Bをリンクします。以降のすべてのリンクのSRLGメンバーシップに関する情報は、Psはこれらのセマンティクスを推測し、ISPFを実行するときSRLG内のすべてのリンクが失敗することによって計算を実行することができないビアアドレスへのすべてのノードの計算ルートリンクステートデータベースで利用可能です。"
    },
    {
      "indent": 3,
      "text": "Note that it is not necessary for S to consider repairs to any other nodes attached to members of the SRLG (such as B). It is sufficient for S to repair to the other end of the adjacent link (P in this case).",
      "ja": "Sは、（例えばBなど）SRLGのメンバーに接続されているすべての他のノードに修理を考慮することは必要ではないことに留意されたいです。 Sは、隣接するリンク（ここではP）の他端に修復することで十分です。"
    },
    {
      "indent": 29,
      "text": "     a   Ps\nS----------P---------D\n|          |\n|    a     |\nA----------B\n|          |\n|          |\nC----------E",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 4: Shared Risk Link Group",
      "ja": "図4：共有リスクリンクグループ"
    },
    {
      "indent": 3,
      "text": "In some cases, it may be that the links comprising the SRLG occur in series on the path from S to the destination D, as shown in Figure 5. In this case, multiple consecutive repairs may be necessary. S will first repair to Ps, then P will repair to Dp. In both cases, because the links concerned are members of SRLG \"a\", the paths are computed to avoid all members of SRLG \"a\".",
      "ja": "いくつかの場合において、それはこの場合、図5に示すように、SRLGを含むリンクは、宛先DへのSからの経路上に直列に発生することがあってもよく、複数の連続した修理が必要かもしれません。 Sは、まずPはDpのに修復され、PSに修復されます。関係するリンクがSRLG「A」のメンバーであるため、どちらの場合も、パスがSRLG「A」のすべてのメンバーを避けるために計算されます。"
    },
    {
      "indent": 28,
      "text": "     a   Ps    a   Dp\nS----------P---------D\n|          |         |\n|    a     |         |\nA----------B         |\n|          |         |\n|          |         |\nC----------E---------F",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 5: Shared Risk Link Group Members in Series - Decapsulation and Re-encapsulation by One Node",
      "ja": "図5：シリーズで共有リスクリンクグループメンバー - 一つのノードによって脱カプセル化と再カプセル化"
    },
    {
      "indent": 3,
      "text": "While the use of multiple repairs in series introduces some additional overhead, these semantics avoid the potential combinatorial explosion of not-via addresses that could otherwise occur.",
      "ja": "シリーズで複数の修理の使用はいくつかの追加のオーバーヘッドが発生しますが、これらの意味は、それ以外の場合は発生する可能性があるアドレスを経由していない - の潜在的な組み合わせ爆発を避けます。"
    },
    {
      "indent": 3,
      "text": "Note that although multiple repairs are used, only a single level of encapsulation is required. This is because the first repair packet is decapsulated before the packet is re-encapsulated using the not-via address corresponding to the far side of the next link that is a member of the same SRLG. In some cases, the decapsulation and re-encapsulation take place (at least notionally) at a single node, while in other cases, these functions may be performed by different nodes. This scenario is illustrated in Figure 6 below.",
      "ja": "複数修理が使用されるが、カプセルの単一レベルが必要であることに留意されたいです。パケットが同じSRLGのメンバーである次のリンクの奥側に対応しないビアアドレスを使用して再カプセル化される前に、最初の修復パケットをデカプセル化されるからです。他の場合には、これらの機能は、異なるノードによって実行されてもよいいくつかのケースでは、デカプセル化及び再カプセル化は、単一のノードで（少なくとも概念的に）行われます。このシナリオは、以下の図6に示されています。"
    },
    {
      "indent": 24,
      "text": "     a   Ps              a  Dg\nS----------P---------G--------D\n|          |         |        |\n|    a     |         |        |\nA----------B         |        |\n|          |         |        |\n|          |         |        |\nC----------E---------F--------H",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 6: Shared Risk Link Group Members in Series - Decapsulation and Re-encapsulation by Different Nodes",
      "ja": "異なるノードによって脱カプセル化と再カプセル化 - シリーズで共有リスクリンクグループメンバー：図6"
    },
    {
      "indent": 3,
      "text": "In this case, S first encapsulates to Ps, and node P decapsulates the packet and forwards it \"native\" to G using its normal FIB entry for destination D. G then repairs the packet to Dg.",
      "ja": "この場合、Sは、最初のPSにカプセル化し、そしてノードPは、パケットをデカプセル化し、次いで修理さDgにパケットを宛先D. Gのための通常のFIBエントリを使用してGに「ネイティブ」を転送します。"
    },
    {
      "indent": 3,
      "text": "It can be shown that such multiple repairs can never form a loop, because each repair causes the packet to move closer to its destination.",
      "ja": "各修復がその目的地に近づくために、パケットが発生するため、このような複数の修理は、ループを形成することはできないことを示すことができます。"
    },
    {
      "indent": 3,
      "text": "It is often the case that a single link may be a member of multiple SRLGs, and those SRLGs may not be isomorphic. This is illustrated in Figure 7 below.",
      "ja": "それは、多くの場合、単一のリンクが複数SRLGsの部材であってもよい場合であり、それらのSRLGsは同形ではないかもしれません。これは、以下の図7に示されています。"
    },
    {
      "indent": 26,
      "text": "     ab  Ps              a  Dg\nS----------P---------G--------D\n|          |         |        |\n|    a     |         |        |\nA----------B         |        |\n|          |         |        |\n|    b     |         |   b    |\nC----------E---------F--------H\n|          |\n|          |\nJ----------K",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 7: Multiple Shared Risk Link Groups",
      "ja": "図7：複数の共有リスクリンクグループ"
    },
    {
      "indent": 3,
      "text": "The link S-P is a member of SRLGs \"a\" and \"b\". When a failure of the link S-P is detected, it MUST be assumed that BOTH SRLGs have failed. Therefore, the not-via path to Ps needs to be computed by failing all links that are members of SRLG \"a\" or SRLG \"b\", i.e., the semantics of Ps is now \"P not via any links that are members of any of the SRLGs of which link S-P is a member\". This is illustrated in Figure 8 below.",
      "ja": "リンクS-PはSRLGs \"a\" および \"b\" のメンバーです。リンクS-Pの故障が検出された場合、両方のSRLGsが失敗したことを想定しなければなりません。したがって、未介してPSにパス、すなわち、Psとのセマンティクスが「今、「a」またはSRLG「B」SRLGのメンバーであるすべてのリンクが失敗することによって計算される必要がPではない任意のメンバーである任意のリンクを介してSPは「メンバーでリンクしているのSRLGsの。これは、以下の図8に示されています。"
    },
    {
      "indent": 25,
      "text": "     ab  Ps              a  Dg\nS----/-----P---------G---/----D\n|          |         |        |\n|    a     |         |        |\nA----/-----B         |        |\n|          |         |        |\n|    b     |         |   b    |\nC----/-----E---------F---/----H\n|          |\n|          |\nJ----------K",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 8: Topology Used for Repair Computation for Link S-P",
      "ja": "図8：トポロジリンクS-P修理計算に使用"
    },
    {
      "indent": 3,
      "text": "In this case, the repair path to Ps will be S-A-C-J-K-E-B-P. It may appear that there is no path to D because G-D is a member of SRLG \"a\" and F-H is a member of SRLG \"b\". This is true if BOTH SRLGs \"a\" and \"b\" have in fact failed, which would be an instance of multiple independent failures. In practice, it is likely that there is only a single failure, i.e., either SRLG \"a\" or SRLG \"b\" has failed but not both. These two possibilities are indistinguishable from the point of view of the repairing router S, and so it needs to repair on the assumption that both are unavailable. However, each link repair is considered independently. The repair to Ps delivers the packet to P, which then forwards the packet to G. When the packet arrives at G, if SRLG \"a\" has failed, it will be repaired around the path G-F-H-D. This is illustrated in Figure 9 below. If, on the other hand, SRLG \"b\" has failed, link G-D will still be available. In this case, the packet will be delivered as normal across the link G-D.",
      "ja": "この場合には、PSに修復経路は、S-A-C-J-K-E-B-Pであろう。 G-Dは、SRLGのメンバーであるため、「a」およびF-Hは、SRLG「B」のメンバーであるDへのパスがないことを表示されてもよいです。 BOTH SRLGs「a」および「b」は、実際に複数の独立した障害のインスタンスであると思われる、失敗した場合、これは本当です。実際には、それだけで単一の障害がある可能性が高い、すなわち、SRLG「」またはSRLG「B」のいずれかが両方失敗しましたがされていません。これらの二つの可能性が修理ルータSの観点から区別できない、ので、それは両方が使用できないことを前提に修復する必要があります。しかし、各リンクの修復が独立して考えられています。 PSに修復はSRLG場合、パケットは「」それは経路G-F-H-D周りに修復され、失敗した、Gに到達すると、次いでGにパケットを転送Pにパケットを配信します。これは、以下の図9に示されています。一方、SRLG「b」は失敗した、場合、リンクG-Dは、まだ使用可能になります。この場合、パケットは、リンクG-Dを横切って通常どおり配信されます。"
    },
    {
      "indent": 25,
      "text": "     ab  Ps              a  Dg\nS----/-----P---------G---/----D\n|          |         |        |\n|    a     |         |        |\nA----/-----B         |        |\n|          |         |        |\n|    b     |         |   b    |\nC----------E---------F--------H\n|          |\n|          |\nJ----------K",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 9: Topology Used for Repair Computation for Link G-D",
      "ja": "図9：トポロジリンクG-D修理計算に使用"
    },
    {
      "indent": 3,
      "text": "If both SRLG \"a\" and SRLG \"b\" had failed, the packet would be repaired as far as P by S and would be forwarded by P to G. G would encapsulate the packet to D using the not-via address Dg and forward it to F. F would recognize that its next hop to Dg (H) was unreachable due to the failure of link F-H (part of SRLG \"b\") and would drop the packet, because packets addressed to a not-via address are not repaired in basic not-via IPFRR.",
      "ja": "両方のSRLG「」とSRLG「b」が失敗した場合、パケットはSによってP限り修復されるとしないビアアドレスさDgを用いてDにパケットをカプセル化して転送することになるG. GにPによって転送されますパケットがないビアアドレス宛のでF. Fに、DGへのネクストホップ（H）が原因リンクFH（SRLG「B」の部分）の故障に到達不能であり、パケットをドロップするであろうことを認識するであろうありません基本的ではないビアIPFRRで修復。"
    },
    {
      "indent": 3,
      "text": "The repair of multiple independent failures is not provided by the basic not-via IPFRR method described so far in this memo.",
      "ja": "複数の独立した障害の修復は、このメモでこれまで説明した基本ないビアIPFRR方法によって提供されていません。"
    },
    {
      "indent": 3,
      "text": "A repair strategy that assumes the worst-case failure for each link can often result in longer repair paths than necessary. In cases where only a single link fails rather than the full SRLG, this strategy may occasionally fail to identify a repair even though a viable repair path exists in the network. The use of suboptimal repair paths is an inevitable consequence of this compromise approach. The failure to identify any repair is a serious deficiency but is a rare occurrence in a robustly designed network. This problem can be addressed by:",
      "ja": "各リンクのための最悪の場合の故障を想定して、修復戦略は、多くの場合、必要以上に長く修理パスにつながることができます。シングルリンクのみがフルSRLGのではなく、失敗した場合には、この戦略は時折実行可能な修理パスがネットワーク内に存在するにもかかわらず、修理を識別するために失敗することがあります。次善の修理パスの使用は、この妥協のアプローチの必然的な結果です。任意の修復を識別するための障害は深刻な不足ですが、確実に設計されたネットワークではまれです。この問題は、によって対処することができます。"
    },
    {
      "indent": 3,
      "text": "1. Reporting that the link in question is irreparable, so that the network designer can take appropriate action.",
      "ja": "ネットワーク設計者が適切な行動をとることができるように、問題のリンクは、取り返しのつかないです1.報告。"
    },
    {
      "indent": 3,
      "text": "2. Modifying the design of the network to avoid this possibility.",
      "section_title": true,
      "ja": "2.この可能性を回避するために、ネットワークの設計を変更します。"
    },
    {
      "indent": 3,
      "text": "3. Using some form of SRLG diagnostic (for example, by running Bidirectional Forwarding Detection (BFD) [RFC5880] over alternate repair paths) to determine which SRLG member(s) have actually failed and using this information to select an appropriate pre-computed repair path. However, aside from the complexity of performing the diagnostics, this requires multiple not-via addresses per interface, which has poor scaling properties.",
      "ja": "3.適切な事前計算を選択するために実際に失敗しているSRLG部材（単数または複数）を決定する（例えば、代替修復経路を介して双方向フォワーディング検出（BFD）[RFC5880]を実行することによって）SRLG診断のいくつかのフォームを使用して、この情報を使用して修理パス。しかし、脇に診断を実行する複雑さから、これは複数の必要がないビア貧弱なスケーリング特性を持っているインタフェース、あたりのアドレス。"
    },
    {
      "indent": 3,
      "text": "4. Using the mechanism described in Section 6.3.",
      "section_title": true,
      "ja": "4.セクション6.3で説明されたメカニズムを使用します。"
    },
    {
      "indent": 0,
      "text": "6.2. Local Area Networks",
      "section_title": true,
      "ja": "6.2。ローカル・エリア・ネットワーク"
    },
    {
      "indent": 3,
      "text": "LANs are a special type of SRLG and are solved using the SRLG mechanisms outlined above. With all SRLGs, there is a trade-off between the sophistication of the fault detection and the size of the SRLG. Protecting against link failure of the LAN link(s) is relatively straightforward, but as with all fast-reroute mechanisms, the problem becomes more complex when it is desired to protect against the possibility of failure of the nodes attached to the LAN, as well as the LAN itself.",
      "ja": "LANはSRLGの特殊な種類であり、上記で概説したSRLGメカニズムを使用して解決されます。すべてSRLGsでは、障害検出の高度化とSRLGの大きさとの間にトレードオフがあります。 LANリンク（単数または複数）のリンク障害から保護するだけでなく、比較的簡単であるが、LANに接続されたノードの故障の可能性から保護することが望まれるときに、すべての高速再ルーティングメカニズムと同様に、問題はより複雑になりますLAN自体として。"
    },
    {
      "indent": 19,
      "text": "                  +--------------Q------C\n                  |\n                  |\n                  |\nA--------S-------(N)-------------P------B\n                  |\n                  |\n                  |\n                  +--------------R------D",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 10: Local Area Networks",
      "ja": "図10：ローカル・エリア・ネットワーク"
    },
    {
      "indent": 3,
      "text": "Consider the LAN shown in Figure 10. For connectivity purposes, we consider that the LAN is represented by the pseudonode (N). To provide IPFRR protection, S needs to run a connectivity check to each of its protected LAN adjacencies P, Q, and R, using, for example, BFD [RFC5880].",
      "ja": "接続のために、図10に示すLANは、我々はLANが疑似ノード（N）で表されると考えて考えてみましょう。 IPFRR保護を提供するために、Sはその保護されたLANのそれぞれに接続性チェックを実行する必要があり、例えば、BFD [RFC5880]を使用して、P、Q、およびRに隣接関係。"
    },
    {
      "indent": 3,
      "text": "When S discovers that it has lost connectivity to P, it is unsure whether the failure is:",
      "ja": "Sは、それがPへの接続が切断されたことを検出すると、障害があるかどうか不明です。"
    },
    {
      "indent": 3,
      "text": "o its own interface to the LAN",
      "ja": "LANへの独自のインターフェースO"
    },
    {
      "indent": 3,
      "text": "o the LAN itself",
      "ja": "LAN自体はO"
    },
    {
      "indent": 3,
      "text": "o the LAN interface of P",
      "ja": "PのLANインタフェースO"
    },
    {
      "indent": 3,
      "text": "o the node P",
      "ja": "ノードP O"
    },
    {
      "indent": 0,
      "text": "6.2.1. Simple LAN Repair",
      "section_title": true,
      "ja": "6.2.1。シンプルなLAN修理"
    },
    {
      "indent": 3,
      "text": "A simple approach to LAN repair is to consider the LAN and all of its connected routers as a single SRLG. Thus, the address P not via the LAN (Pl) would require P to be reached not via any router connected to the LAN. This is shown in Figure 11.",
      "ja": "LAN修理への単純なアプローチは、単一SRLGとしてLANと接続されたルータのすべてを考慮することです。このように、Pを必要とするアドレスではないLAN（PL）を介して、Pは、LANに接続されている任意のルータを介して到達しないことができます。これは図11に示されています。"
    },
    {
      "indent": 19,
      "text": "                              Ql       Cl\n                  +-------------Q--------C\n                  |              Qc\n                  |\n As       Sl      |           Pl       Bl\nA--------S-------(N)------------P--------B\n       Sa         |              Pb\n                  |\n                  |           Rl       Dl\n                  +-------------R--------D\n                                 Rd",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 11: Local Area Networks - LAN SRLG",
      "ja": "図11：ローカル・エリア・ネットワーク -  LAN SRLG"
    },
    {
      "indent": 3,
      "text": "In this case, if S detected that P had failed, it would send traffic reached via P and B to B not via the LAN or any router attached to the LAN (i.e., to Bl). Any destination only reachable through P would be addressed to P not via the LAN or any router attached to the LAN (except, of course, P).",
      "ja": "Sは、Pが失敗したことを検出した場合には、この場合には、それは、LAN又は（即ち、BLに）LANに接続されているすべてのルータを経由していないBにP及びBを介して到達したトラフィックを送信することになります。 P介してのみ到達可能な任意の宛先はないLANまたはLANに接続されているすべてのルータ（もちろん除いて、P）を介してPにアドレス指定されることになります。"
    },
    {
      "indent": 3,
      "text": "While this approach is simple, it assumes that a large portion of the network adjacent to the failure has also failed. This will result in the use of suboptimal repair paths and, in some cases, the inability to identify a viable repair.",
      "ja": "このアプローチは単純であるが、それは失敗に隣接するネットワークの大部分はまた、失敗したと仮定しています。これは、次善の修理パスの使用になりますと、いくつかのケースでは、できないことは、実行可能な修復を識別します。"
    },
    {
      "indent": 0,
      "text": "6.2.2. LAN Component Repair",
      "section_title": true,
      "ja": "6.2.2。 LANコンポーネントの修復"
    },
    {
      "indent": 3,
      "text": "In this approach, possible failures are considered at a finer granularity but without the use of diagnostics to identify the specific component that has failed. Because S is unable to diagnose the failure, it needs to repair traffic sent through P and B, to an address Bpn (B not-via P,N, i.e., B not via P and not via N), on the conservative assumption that both the entire LAN and P have failed. Destinations for which P is a single point of failure MUST, as usual, be sent to P using an address that avoids the interface by which P is reached from S, i.e., to P not via N. A similar process would also apply for routers Q and R.",
      "ja": "このアプローチでは、障害の可能性はより細かい粒度ではなく失敗した特定のコンポーネントを識別するための診断を使用せずに考えられています。 Sが障害を診断することができないので、それは保守的な仮定して、アドレスBPN（BないビアP、N、即ち、BではないPを介してではなくNを介して）、P及びBを介して送信されるトラフィックを修復する必要があること全体LANとPの両方が失敗しています。 N. A同様のプロセスを介してPにPが、いつものように、PがSから到達されるインタフェースを回避するアドレスを使用してPに単一障害点を送らなければなりませんされた宛先、すなわち、ないにもルータに適用されますQとR."
    },
    {
      "indent": 3,
      "text": "Notice that each router that is connected to a LAN MUST, as usual, advertise one not-via address for each neighbor. In addition, each router on the LAN MUST advertise an extra address not via the pseudonode (P).",
      "ja": "LANに接続された各ルータは、いつものように、各隣接のアドレスではない - を介しての広告をしなければならないことに注意してください。また、LAN上の各ルータがない疑似ノード（P）を経由して、余分なアドレスをアドバタイズする必要があります。"
    },
    {
      "indent": 3,
      "text": "Notice also that each neighbor of a router connected to a LAN needs to advertise two not-via addresses: the usual one not via the neighbor, and an additional one not via either the neighbor or the pseudonode. The required set of LAN address assignments is shown in Figure 12 below. Each router on the LAN, and each of its neighbors, are advertising exactly one address more than they would otherwise have advertised if this degree of connectivity had been achieved using point-to-point links.",
      "ja": "隣人を介した通常のものではない、と隣人または擬似ノードのいずれかを経由して、追加の一つではない：LANに接続されたルータの各ネイバーが2ない-経由でアドレスをアドバタイズする必要があることにも注意してください。 LANアドレスの割り当ての必要なセットは、以下の図12に示されています。各LAN上のルータ、およびその隣人のそれぞれは、接続性のこの程度はポイントツーポイントリンクを使用して達成されていた場合、彼らはそれ以外の広告を出していたよりも、正確に一つのアドレスより多くの広告を出しています。"
    },
    {
      "indent": 20,
      "text": "                            Qs Qp Qc    Cqn\n                  +--------------Q---------C\n                  |         Qr Qn        Cq\n                  |\n Asn   Sa Sp Sq   |         Ps Pq Pb    Bpn\nA--------S-------(N)-------------P---------B\n As       Sr Sn   |         Pr Pn        Bp\n                  |\n                  |         Rs Rp Pd    Drn\n                  +--------------R---------D\n                            Rq Rn        Dr",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 12: Local Area Networks - Component Repair",
      "ja": "図12：ローカル・エリア・ネットワーク - コンポーネントの修理"
    },
    {
      "indent": 0,
      "text": "6.2.3. LAN Repair Using Diagnostics",
      "section_title": true,
      "ja": "6.2.3。診断の使用LAN修理"
    },
    {
      "indent": 3,
      "text": "A more specific LAN repair can be undertaken by using diagnostics. In order to explicitly diagnose the failed network component, S correlates the connectivity reports from P and one or more of the other routers on the LAN, in this case Q and R. If it lost connectivity to P alone, it could deduce that the LAN was still functioning and that the fault lay with either P or the interface connecting P to the LAN. It would then repair to B not-via P (and P not-via N for destinations for which P is a single point of failure) in the usual way. If S lost connectivity to more than one router on the LAN, it could conclude that the fault lay only with the LAN and could repair to P, Q, and R not-via N, again in the usual way.",
      "ja": "より具体的なLANの修理は診断を使用することによって行うことができます。それだけではPへの接続を失った場合は、明示的に失敗したネットワーク・コンポーネントを診断するためには、Sは、それがLANと推論でき、この場合、QとRに、PおよびLAN上の他のルータの1つまたは複数からの接続レポートを関連付けますまだ機能と障害がPまたはLANにPを接続するインタフェースのいずれかで横たわっていたということでした。その後、通常の方法で（Pは単一障害点であるため宛先およびPないビアN）ないビアPをBに修復することになります。 Sは、LAN上の複数のルーターへの接続を失った場合、それは障害が唯一のLANに置き、通常の方法で、再び、P、Q、およびRない-経由Nに修復できると結論できました。"
    },
    {
      "indent": 0,
      "text": "6.3. Multiple Independent Failures",
      "section_title": true,
      "ja": "6.3。複数の独立した障害"
    },
    {
      "indent": 3,
      "text": "IPFRR repair of multiple simultaneous failures that are not members of a known SRLG is complicated by the problem that the use of multiple concurrent repairs may result in looping repair paths. As described in Section 5.2.1, the simplest method of preventing such loops is to ensure that packets addressed to a not-via address are not repaired but instead are dropped. It is possible that a network may experience multiple simultaneous failures. This may be due to simple statistical effects, but the more likely cause is unanticipated SRLGs. When multiple failures that are not part of an anticipated group are detected, repairs are abandoned, and the network reverts to normal convergence. Although safe, this approach is somewhat draconian, since there are many circumstances where multiple repairs do not induce loops.",
      "ja": "知られているSRLGのメンバーではない複数の同時故障のIPFRRの修理は、複数の同時修理の使用は、修復パスをループになることがあり、問題によって複雑になります。 5.2.1項で説明したように、このようなループを防止する最も簡単な方法は、パケットが修復されず、代わりに廃棄されていないビアアドレス宛てことを保証することです。ネットワークが複数の同時障害が発生する可能性があります。これは、単純な統計の影響によるものかもしれないが、より多くの可能性の高い原因は、予期せぬSRLGsです。予想されるグループの一部ではない複数の障害が検出された場合、修理が放棄され、ネットワークが正常収束に戻ります。安全が複数の修理がループを誘発しない多くの状況があるので、このアプローチは、やや厳しいです。"
    },
    {
      "indent": 3,
      "text": "This section describes the properties of multiple unrelated failures and proposes some methods that may be used to address this problem.",
      "ja": "このセクションでは、複数の無関係の障害の性質を説明し、この問題に対処するために使用できるいくつかの方法が提案されています。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Looping Repairs",
      "section_title": true,
      "ja": "6.3.1。ループ修理"
    },
    {
      "indent": 3,
      "text": "Let us assume that the repair mechanism is based solely on not-via repairs. LFA or downstream routes MAY be incorporated and will be dealt with later.",
      "ja": "私たちは、修復機構がない-経由の修理のみに基づいていると仮定しましょう。 LFAまたは下流ルートが組み込まれていてもよい以降で配られます。"
    },
    {
      "indent": 24,
      "text": "   A------//------B------------D\n  /                \\\n /                  \\\nF                    G\n \\                  /\n  \\                /\n   X------//------Y",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 13: The General Case of Multiple Failures",
      "ja": "図13：複数の故障の一般的なケース"
    },
    {
      "indent": 3,
      "text": "The essential case is as illustrated in Figure 13. Note that, depending on the repair case under consideration, there may be other paths present in Figure 13, in addition to those shown in the figure. For example, there may be paths between A and B, and/or between X and Y. These paths are omitted for graphical clarity.",
      "ja": "図13（注）に示すように、必須の場合は、検討中の修復ケースに応じて、図に示すものに加えて、図13中に存在する他の経路が存在してもよい、ということです。例えば、これらのパスは、グラフィカル明確にするために省略されているAとBとの間、及び/又はXとYの間に経路が存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "There are three cases to consider:",
      "ja": "考慮すべき3つのケースがあります。"
    },
    {
      "indent": 3,
      "text": "1. Consider the general case of a pair of protected links A-B and X-Y, as shown in the network fragment shown in Figure 13. If the repair path for A-B does not traverse X-Y and the repair path for X-Y does not traverse A-B, this case is completely safe and will not cause looping or packet loss.",
      "ja": "XYはABを通過しないためABの修復経路はXYおよび修復経路を横断しない場合は、図13に示すネットワーク断片、この場合1に示すよう、保護リンクABおよびXYのペアの一般的な場合を考えます完全に安全であり、ループやパケットロスが発生することはありません。"
    },
    {
      "indent": 6,
      "text": "A more common variation of this case is shown in Figure 14, which shows two failures in different parts of the network in which a packet from A to D traverses two concatenated repairs.",
      "ja": "この場合のより一般的な変化は、Dへのパケットは、2つの連結された修理を横断するネットワークの異なる部分に2つの障害を示す、図14に示されています。"
    },
    {
      "indent": 17,
      "text": "A------//------B------------X------//------Y------D\n|              |            |              |\n|              |            |              |\nM--------------+            N--------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 14: Concatenated Repairs",
      "ja": "図14：連結された修理"
    },
    {
      "indent": 3,
      "text": "2. In Figure 13, the repair for A-B traverses X-Y, but the repair for X-Y does not traverse A-B. This case occurs when the not-via path from A to B traverses link X-Y but the not-via path from X to Y traverses some path not shown in Figure 13. Without the multi-failure mechanism described in this section, the repaired packet for A-B would be dropped when it reached X-Y, since the repair of repaired packets would be forbidden. However, if this packet were allowed to be repaired, the path to D would be complete and no harm would be done, although two levels of encapsulation would be required.",
      "ja": "2.図13は、-Bのための修復はX-Yを横断するが、X-Y用修復は-Bを通過しません。未経由パスからBへのリンクXYを横断なくビア経路をXからYに、このセクションで説明する多重障害機構なし図13には示されていないいくつかのパスのために修復パケットを通過すると、この場合に発生します修復されたパケットの修理が禁止されることになるので、それは、XY達したとき、ABはドロップされます。しかし、このパケットが修復させた場合は、Dへのパスは完全であろうとカプセル2つのレベルが必要とされるであろうが害は、行われないことになります。"
    },
    {
      "indent": 3,
      "text": "3. The repair for A-B traverses X-Y AND the repair for X-Y traverses A-B. In this case, unrestricted repair would result in looping packets and increasing levels of encapsulation.",
      "ja": "3-Bのための修復は、X-Y横断し、X-Y用修復は-Bを横断します。この場合において、無制限修復パケットをループおよびカプセル化のレベルを増加させることになります。"
    },
    {
      "indent": 3,
      "text": "The challenge in applying IPFRR to a network that is undergoing multiple failures is, therefore, to identify which of these cases exist in the network and react accordingly.",
      "ja": "複数の障害を受けているネットワークにIPFRRを適用する際の課題は、ネットワーク内に存在し、それに応じて反応するこれらのケースのどちらを識別することです。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Outline Solution",
      "section_title": true,
      "ja": "6.3.2。概要ソリューション"
    },
    {
      "indent": 3,
      "text": "When A is computing the not-via repair path for A-B (i.e., the path for packets addressed to Ba, read as \"B not via A\"), it is aware of the list of nodes that this path traverses. This can be recorded by a simple addition to the SPF process, and the not-via addresses associated with each forward link can be determined. If the path were A, F, X, Y, G, B, (Figure 13), the list of not-via addresses would be Fa, Xf, Yx, Gy, Bg. Under standard not-via operation, A would populate its FIB such that all normal addresses normally reachable via A-B would be encapsulated to Ba when A-B fails, but traffic addressed to any not-via address arriving at A would be dropped. The new procedure modifies this such that any traffic for a not-via address normally reachable over A-B is also encapsulated to Ba, unless the not-via address is one of those previously identified as being on the path to Ba -- for example, Yx, in which case the packet is dropped.",
      "ja": "Aは、Bの修復パスが経由しない（すなわち、パケットの経路は、Ba宛、「しないAを介してB」として読み取ら）を計算する場合には、この経路が横断するノードのリストを知っています。これは、SPF処理に単純な加算によって記録することができ、かつないビア各フォワードリンクに関連付けられたアドレスを決定することができます。パスは、A、F、X、Y、G、B、（図13）であった場合、アドレスないビアのリストは、Faを、Xfの、のYx、グレイ、Bgとなるであろう。基準ではない - を介した操作、Aは、Bが失敗したとき、Bを経由して正常に到達可能なすべての通常のアドレスは、Baにカプセル化されるであろうようにそのFIBを移入しますが、トラフィックがどの宛落とされることになるではない - を経由してAに到着アドレス。新しい手順は、AB上、通常到達しないビアアドレスに対するすべてのトラフィックはまた、Baのに封入されていることは、このような変更ではない - を介してアドレスは、以前のBaへのパス上にあるものとして同定されたものの一つでない限り - 例えば、のYxその場合、パケットはドロップされます。"
    },
    {
      "indent": 3,
      "text": "The above procedure allows cases 1 and 2 above to be repaired while preventing the loop that would result from case 3.",
      "ja": "上記の手順は、ケース3から生じるループを防止しながら、ケース1及び上記2が修復されることを可能にします。"
    },
    {
      "indent": 3,
      "text": "Note that this is accomplished by pre-computing the required FIB entries and does not require any detailed packet inspection. The same result could be achieved by checking for multiple levels of encapsulation and dropping any attempt to triple encapsulate. However, this would require more detailed inspection of the packet and causes difficulties when more than 2 \"simultaneous\" failures are contemplated.",
      "ja": "この事前計算に必要なFIBエントリによって達成され、任意の詳細なパケット検査を必要としないことに留意されたいです。同じ結果は、カプセル化の複数のレベルをチェック、トリプルカプセル化する試みをドロップすることによって達成することができます。しかし、これは、パケットのより詳細な検査を必要とし、2つ以上の「同時」障害が意図されているときの困難の原因となるでしょう。"
    },
    {
      "indent": 3,
      "text": "So far, we have permitted benign repairs to coexist, albeit sometimes requiring multiple encapsulation. Note that in many cases there will be no performance impact, since unless both failures are on the same node the two encapsulations or two decapsulations will be performed at different nodes. There is, however, the issue of the maximum transmission unit (MTU) impact of multiple encapsulations.",
      "ja": "これまでのところ、我々は時々、複数のカプセル化を必要とはいえ、共存する良性の修理を可能にしました。両方の障害が同じノード上にない限り、2つのカプセル化又は二decapsulationsは異なるノードで実行されるので、多くの場合、何のパフォーマンスへの影響がないことに注意してください。複数のカプセル化の最大伝送単位（MTU）の影響の問題は、しかし、そこです。"
    },
    {
      "indent": 3,
      "text": "In the following sub-section we consider the various strategies that may be applied to case 3 -- mutual repairs that would loop.",
      "ja": "希望ループ相互の修理 - 以下のサブセクションでは、ケース3にも適用することができる様々な戦略を検討します。"
    },
    {
      "indent": 0,
      "text": "6.3.3. Mutually Looping Repairs",
      "section_title": true,
      "ja": "6.3.3。相互ルーピング修理"
    },
    {
      "indent": 3,
      "text": "In case 3, the simplest approach is to simply not install repairs for repair paths that might loop. In this case, although the potentially looping traffic is dropped, the traffic is not repaired. If we assume that a hold-down is applied before reconvergence in case the link failure was just a short glitch, and if a loop-free convergence mechanism further delays convergence, then the traffic will be dropped for an extended period. In these circumstances, it would be better to apply the \"Abandoning All Hope\" (AAH) mechanism ([RFC6976], Appendix A) and immediately invoke normal reconvergence.",
      "ja": "ケース3においては、最も単純なアプローチは、単にループかもしれ修復経路のための修理をインストールしないことです。潜在的にループするトラフィックが廃棄されるが、この場合、トラフィックは修復されません。我々は、ホールドダウンをケースに再コンバージェンス前に適用されていることを前提とした場合はリンク障害はわずかグリッチだった、とループフリーコンバージェンスメカニズムをさらに遅延収束場合は、トラフィックが長期間破棄されます。このような状況では、「すべての希望を放棄」（AAH）機構（[RFC6976]、付録A）を適用し、直ちに通常の再収束を呼び出すために良いだろう。"
    },
    {
      "indent": 3,
      "text": "Note that it is not sufficient to expedite the issuance of a Link State Packet (LSP) reporting the failure, since this may be treated as a permitted simultaneous failure by the ordered FIB (oFIB) algorithm [RFC6976]. It is therefore necessary to explicitly trigger an oFIB AAH.",
      "ja": "この注文FIB（oFIB）アルゴリズム[RFC6976]で許可される同時故障として処理することができるので、失敗を報告リンク状態パケット（LSP）の発行を促進するのに十分ではないことに留意されたいです。明示的にoFIB AAHをトリガする必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.3.1. Dropping Looping Packets",
      "section_title": true,
      "ja": "6.3.3.1。ドロップルーピングパケット"
    },
    {
      "indent": 3,
      "text": "One approach to case 3 is to allow the repair, and to experimentally discover the incompatibility of the repairs if and when they occur. With this method, we permit the repair in case 3 and trigger AAH when a packet drop count on the not-via address has been incremented. Alternatively, it is possible to wait until the LSP describing the change is issued normally (i.e., when X announces the failure of X-Y). When the repairing node A, which has precomputed that X-Y failures are mutually incompatible with its own repairs, receives this LSP, it can then issue the AAH. This has the disadvantage that it does not overcome the hold-down delay, but it requires no \"data-driven\" operation, and it still has the required effect of abandoning the oFIB, which is probably the longer of the delays (although with signaled oFIB this should be sub-second).",
      "ja": "ケース3への一つのアプローチは、修復を可能にし、それらが発生したときにあれば、実験的に修理の非互換性を発見することです。ないビアアドレスのパケットドロップ数がインクリメントされたときに、この方法では、我々は、ケース3とトリガAAHで修理が可能。あるいは、LSPは変更が正常に発行された記述になるまで待機することが可能である（すなわち、Xは、X-Yの失敗を発表したとき）。 X-Y障害が自身の修理と相互に互換性がないことを事前に計算している修復ノードAは、このLSPを受信すると、次いで、AAHを発行することができます。これは、ホールドダウン遅延を克服していないという欠点を有しているが、それには、「データ駆動型」の操作を必要とせず、合図とともにものの、それはまだ遅れの、おそらく長いoFIBを、（放棄の必要な効果を持っていますoFIBこのサブ秒であるべきです）。"
    },
    {
      "indent": 3,
      "text": "While both of the experimental approaches described above are feasible, they tend to induce AAH in the presence of otherwise feasible repairs, and they are contrary to the philosophy of repair predetermination that has been applied to existing IPFRR solutions.",
      "ja": "上記の実験的アプローチの両方が可能であるが、それらはそうでない可能修理の存在下で、AAHを誘発する傾向があり、彼らは既存のIPFRRソリューションに適用されている修理先決の理念に反しています。"
    },
    {
      "indent": 0,
      "text": "6.3.3.2. Computing Non-looping Repairs of Repairs",
      "section_title": true,
      "ja": "6.3.3.2。コンピューティング修理の修理を非ループ"
    },
    {
      "indent": 3,
      "text": "An alternative approach to simply dropping the looping packets, or to detecting the loop after it has occurred, is to use secondary SRLGs. With a link-state routing protocol, it is possible to pre-compute the incompatibility of the repairs in advance and to compute an alternative SRLG repair path. Although this does considerably increase the computational complexity, it may be possible to compute repair paths that avoid the need to simply drop the offending packets.",
      "ja": "別のアプローチは、単にループパケットをドロップするか、またはそれが発生した後のループを検出し、二次SRLGsを使用することです。リンクステートルーティングプロトコルでは、事前に修理の非互換性を事前に計算すると、代替SRLG修復経路を計算することが可能です。これはかなりの計算の複雑さを増すんが、単に問題のパケットを廃棄する必要性を避けるため、修復パスを計算することも可能です。"
    },
    {
      "indent": 3,
      "text": "This approach requires us to identify the mutually incompatible failures and advertise them as \"secondary SRLGs\". When computing the repair paths for the affected not-via addresses, these links are simultaneously removed. Note that the assumed simultaneous failure and resulting repair path only apply to the repair path computed for the conflicting not-via addresses and are not used for normal addresses. This implies that although there will be a longer repair path when there is more than one failure, if there is a single failure the repair path length will be \"normal\".",
      "ja": "このアプローチは、相互に互換性のない障害を特定し、「二次SRLGs」としてそれらを宣伝するために私たちを必要とします。影響を受けていないビアアドレスの修復経路を計算するとき、これらのリンクが同時に除去されます。想定同時故障し、得られた修復経路はアドレスのみではないビア矛盾について計算修復経路に適用され、通常のアドレスに使用されていないことに留意されたいです。これは、複数の故障がある場合に修復経路長が「正常」になり、単一の故障があった場合、より長い修復経路が存在することになるものの、ことを意味します。"
    },
    {
      "indent": 3,
      "text": "Ideally, we would wish to only invoke secondary SRLG computation when we are sure that the repair paths are mutually incompatible. Consider the case of node A in Figure 13. Node A first identifies that the repair path for A-B is via F-X-Y-G-B. It then explores this path, determining the repair path for each link in the path. Thus, for example, it performs a check at X by running an SPF rooted at X with the X-Y link removed to determine whether A-B is indeed on X's repair path for packets addressed to Yx.",
      "ja": "理想的には、我々は、修復パスが相互に互換性がないことが確実な場合にのみ、二次SRLG計算を起動したいでしょう。第-Bの修復経路はF-X-Y-G-Bを介してであることを識別し、図13のノードAにおけるノードAの場合を考えます。これは、パス内の各リンクの修復パスを決定し、このパスを探ります。従って、例えば、それは、パケットがのYx宛てため-BはXの修復経路に実際にあるかどうかを決定するために除去X-YリンクにXをルートSPFを実行して、Xのチェックを行います。"
    },
    {
      "indent": 3,
      "text": "Some optimizations are possible in this calculation, which appears at first sight to be order hk (where h is the average hop length of repair paths and k is the average number of neighbors of a router). When A is computing its set of repair paths, it does so for all its k neighbors. In each case, it identifies a list of node pairs traversed by each repair. These lists may often have one or more node pairs in common, so the actual number of link failures that require investigation is the union of these sets. It is then necessary to run an SPF rooted at the first node of each pair (the first node, because the pairings are ordered representing the direction of the path), with the link to the second node removed. This SPF, while not an incremental, can be terminated as soon as the not-via address is reached. For example, when running the SPF rooted at X, with the link X-Y removed, the SPF can be terminated when Yx is reached. Once the path has been found, the path is checked to determine if it traverses any of A's links in the direction away from A. Note that because the node pair X-Y may exist in the list for more than one of A's links (i.e., it lies on more than one repair path), it is necessary to identify the correct list, and hence link, that has a mutually looping repair path. That link of A is then advertised by A as a secondary SRLG paired with the link X-Y. Also note that X will be running this algorithm as well, and will identify that X-Y is paired with A-B and so advertise it. This could perhaps be used as a further check.",
      "ja": "いくつかの最適化は、（H修復経路の平均ホップ長であり、kはルータのネイバーの平均数である）ためHKであることが一目で表示され、この計算可能です。 A修復経路のセットを計算する場合には、すべてのk個の近隣のためにそうします。各場合において、各修復が横断するノード対のリストを識別する。これらのリストは、多くの場合、共通の内の1つまたは複数のノード対を有することができるので、調査が必要なリンク障害の実際の数は、これらのセットの和集合です。除去し第2のノードへのリンクと、（ペアリングは、パスの方向を表す順序付けられているので、最初のノード）は、各対の最初のノードをルートSPFを実行することが必要です。このSPF、増分されていないが、できるだけ早く-を経由していないアドレスに到達するように終了することができます。リンクX-Y削除して、XをルートとSPFを実行しているときのYxに達したときに、例えば、SPFを終了させることができます。パスが発見された後、パスは、それがノード対XYはAのリンクの複数の（すなわち、それをリストに存在することができるのでこと離れA.ノートから方向Aのリンクのいずれかを通過するかどうかを決定するためにチェックされます）複数修復経路上にある、正しいリストを識別するために必要であり、したがってリンク、相互ループ修復経路を有します。 Aのそのリンクは、リンクX-Yと対をなす二次SRLGとしてAによって通知されます。また、Xは、同様にこのアルゴリズムを実行され、そのX-Yは、Bと対になっている識別し、それをアドバタイズすることに注意してください。これはおそらく、さらにチェックとして使用することができます。"
    },
    {
      "indent": 3,
      "text": "The ordering of the pairs in the lists is important, i.e., X-Y and Y-X are dealt with separately. If and only if the repairs are mutually incompatible, we need to advertise the pair of links as a secondary SRLG, and then ALL nodes compute repair paths around both failures using an additional not-via address with the semantics not-via A-B AND not-via X-Y.",
      "ja": "リストのペアの順序は、すなわち、X-YおよびY-Xが別々に扱われ、重要です。修理が相互に互換性がない場合にのみ、そして、私たちは二SRLGとして一対のリンクを宣伝する必要があり、その後、すべてのノードが追加的ではないビアセマンティクスを持つアドレスではない-経由ABとnot-を使用して、両方の障害を回避修理パスを計算する場合XY経由。"
    },
    {
      "indent": 3,
      "text": "A further possibility is that because we are going to the trouble of advertising these SRLG sets, we could also advertise the new repair path and only get the nodes on that path to perform the necessary computation. Note also that once we have reached Q-space (Appendix A) with respect to the two failures, we need no longer continue the computation, so we only need to notify the nodes on the path that are not in Q-space.",
      "ja": "更なる可能性は、我々はこれらのSRLGセットを広告するのトラブルしようとしているので、我々はまた、新しい修理パスを宣伝だけそのパス上のノードは、必要な計算を実行するために得ることができるということです。注意はまた、我々は2つの障害に対するQ-スペース（付録A）に達していることと、私たちは、計算を続ける必要がなくなったので、我々は唯一のQ-スペースになっていないパス上のノードに通知する必要があります。"
    },
    {
      "indent": 3,
      "text": "One cause of mutually looping repair paths is the existence of nodes with only two links, or sections of the network that are only bi-connected. In these cases, repair is clearly impossible -- the failure of both links partitions the network. It would be advantageous to be able to identify these cases and inhibit the fruitless advertisement of the secondary SRLG information. This could be achieved by the node detecting the requirement for a secondary SRLG, first running the not-via computation with both links removed. If this does not result in a path, it is clear that the network would be partitioned by such a failure, and so no advertisement is required.",
      "ja": "相互ループ修復経路のうちの1つの原因は、双方向接続されているネットワークの2つだけのリンク、またはセクションを有するノードの存在です。これらのケースでは、修理は明らかに不可能である - 両方のリンクの障害はネットワークを分割します。これらのケースを識別し、二次SRLG情報の無駄な広告を阻害することができることが有利であろう。これは、最初に除去両方のリンクでないビア計算を実行して、二次SRLGの必要性を検出するノードによって達成することができます。これは、パスにならない場合は、ネットワークは、このような障害によって仕切られるだろう、とそう何の広告が必要とされないことは明らかです。"
    },
    {
      "indent": 0,
      "text": "6.3.4. Mixing LFAs and Not-Via",
      "section_title": true,
      "ja": "6.3.4。ミキシングLFAsおよびNot-経由"
    },
    {
      "indent": 3,
      "text": "So far in this section, we have assumed that all repairs use not-via tunnels. However, in practice we may wish to use LFAs or downstream routes where available. This complicates the issue, because their use results in packets that are being repaired but NOT addressed to not-via addresses. If BOTH links are using downstream routes, there is no possibility of looping, since it is impossible to have a pair of nodes that are both downstream of each other [RFC5286].",
      "ja": "これまでのところ、このセクションでは、我々はすべての修理はトンネルではない - を経由して使用することを前提としています。しかし、実際には、我々は利用可能な場合LFAsまたは下流のルートを使用することもできます。これは、修理ではなく、経由アドレス宛ではないされているパケットでのそれらの使用の結果から、問題を複雑にしています。両方のリンクがダウンストリーム経路を使用している場合、両者[RFC5286]の下流にある一対のノードを持つことは不可能であるので、ループの可能性は、存在しません。"
    },
    {
      "indent": 3,
      "text": "Loops can, however, occur when LFAs are used. An obvious example is the well-known node repair problem with LFAs [RFC5286]. If one link is using a downstream route while the other is using a not-via tunnel, the potential mechanism described above would work, provided it were possible to determine the nodes on the path of the downstream route. Some methods of computing downstream routes do not provide this path information. However, if the path information is available, the link using a downstream route will have a discard FIB entry for the not-via address of the other link. The consequence is that potentially looping packets will be discarded when they attempt to cross this link.",
      "ja": "LFAsが使用された場合のループは、しかし、発生する可能性があります。明らかな例はLFAs [RFC5286]とよく知られているノードの修復の問題です。他のではなくビアトンネルを使用している間に1つのリンクがダウンストリーム経路を使用している場合、上述の潜在的なメカニズムが働くだろう、それは下流経路の経路上のノードを決定することが可能でした。下流の経路を計算するいくつかの方法は、このパス情報を提供していません。パス情報が利用可能な場合は、下流の経路を使用してリンクは他のリンクのアドレスではないビアのための廃棄FIBエントリを持つことになります。結果として、彼らは、このリンクを横断しようとすると、潜在的にループパケットが破棄されるということです。"
    },
    {
      "indent": 3,
      "text": "In the case where the mutual repairs are both using not-via repairs, the loop will be broken when the packet arrives at the second failure. However, packets are unconditionally repaired by means of a downstream routes, and thus when the mutual pair consists of a downstream route and a not-via repair, the looping packet will only be dropped when it gets back to the first failure, i.e., it will execute a single turn of the loop before being dropped.",
      "ja": "パケットが第二の故障に到達したとき相互修理の両方しないビアを使用している修理の場合に、ループが破壊されるであろう。しかし、パケットは無条件に下流経路によって修復され、したがって相互対下流経路で構成され、それは最初の失敗に戻るを取得したときに、を介していない修理、ループパケットのみが、ドロップされたとき、すなわち、それをドロップされる前に、ループの1ターンを実行します。"
    },
    {
      "indent": 3,
      "text": "There is a further complication with downstream routes, since although the path may be computed to the far side of the failure, the packet may \"peel off\" to its destination before reaching the far side of the failure. In this case, it may traverse some other link that has failed and was not accounted for on the computed path. If the A-B repair (Figure 13) is a downstream route and the X-Y repair is a not-via repair, we can have the situation where the X-Y repair packets encapsulated to Yx follow a path that attempts to traverse A-B. If the A-B repair path for \"normal\" addresses is a downstream route, it cannot be assumed that the repair path for packets addressed to Yx can be sent to the same neighbor. This is because the validity of a downstream route MUST be ascertained in the topology represented by Yx, i.e., that with the link X-Y removed. This is not the same topology that was used for the normal downstream calculation, and use of the normal downstream route for the encapsulated packets may result in an undetected loop. If it is computationally feasible to check the downstream route in this topology (i.e., for any not-via address Qp that traverses A-B, we must perform the downstream calculation for that not-via address in the topology with link Q-P removed), then the downstream repair for Yx can safely be used. These packets cannot revisit X-Y, since by definition they will avoid that link. Alternatively, the packet could be always repaired in a not-via tunnel, i.e., even though the normal repair for traffic traversing A-B would be to use a downstream route, we could insist that such traffic addressed to a not-via address must use a tunnel to Ba. Such a tunnel would only be installed for an address Qp if it were established that it did not traverse Q-P (using the rules described above).",
      "ja": "パスが障害の向こう側に計算することができるが、パケットが障害の反対側に到達する前にその宛先に「剥離」することができるので、下流経路を有するさらに複雑があります。この場合には、失敗したと計算された経路上を占めていなかったいくつかの他のリンクを横断することができます。 A-B修復（図13）下流経路であり、X-Y修復がないビア修理であれば、我々はのYxにカプセル化されたX-Y修復パケット状況を持つことができ、Bを横断しようとする経路をたどります。 「正常な」アドレスのA-B修復経路は、下流経路である場合には、パケットの修復パスは同じネイバーに送信することができるのYx宛と仮定することはできません。下流経路の有効性は、リンクX-Yで除去していること、すなわち、のYxによって表されるトポロジーに確認しなければならないからです。これは、通常の下流計算に使用した同じトポロジではなく、カプセル化されたパケットの正常下流経路の使用が検出されないループをもたらすことができます。それは、このトポロジでは、下流の経路を確認するために、計算可能である場合には、（ABを横断任意のないビアアドレスQpのために、つまり、我々は削除リンクQPとトポロジーのものではない、経由アドレスに対して下流の計算を実行する必要があります） Yxのための下流の修理が安全に使用することができます。定義によって、彼らはそのリンクを避けることができますので、これらのパケットは、X-Yを再訪することはできません。また、パケットは常にで修復することができABを通過するトラフィックのための正常な修復は、下流の経路を用いることであろうにもかかわらずない-経由のトンネル、すなわち、私たちは、このようなトラフィックがない-経由でアドレスを使用する必要があり宛と主張できましたBaのにトンネル。それは、それがQ-P（上記の規則を使用して）横断しなかったことを確立した場合、このようなトンネルは、アドレスQpのためにインストールされることになります。"
    },
    {
      "indent": 0,
      "text": "7. Optimizing Not-Via Computations Using LFAs",
      "section_title": true,
      "ja": "7. LFAsを使用しない-経由計算の最適化"
    },
    {
      "indent": 3,
      "text": "If repairing node S has an LFA to the repair endpoint, it is not necessary for any router to perform the incremental SPF with the link S-P removed in order to compute the route to the not-via address Ps. This is because the correct routes will already have been computed as a result of the SPF on the base topology. Node S can signal this condition to all other routers by including a bit in its LSP or Link State Advertisement (LSA) associated with each link protected by an LFA. Routers computing not-via routes can then omit the running of the iSPF for links with this bit set.",
      "ja": "修復ノードSは修復エンドポイントにLFAがある場合、任意のルータがリンクS-PとインクリメンタルSPFを実行することは必要ではないではないビアアドレスPSにルートを計算するために除去しました。正しいルートがすでに基本トポロジのSPFの結果として計算されているためです。ノードSは、LFAによって保護される各リンクに関連付けられ、そのLSPまたはリンクステートアドバタイズメント（LSA）のビットを含めることによって、他のすべてのルータにこの状態を通知することができます。未介してコンピューティング経路ルータは、このビットがセットされたリンクについてISPFの実行を省略することができます。"
    },
    {
      "indent": 3,
      "text": "When running the iSPF for a particular link A-B, the calculating router first checks whether the link A-B is present in the existing SPT. If the link is not present in the SPT, no further work is required. This check is a normal part of the iSPF computation.",
      "ja": "特定のリンクのA-BのためのISPF、リンクA-Bは、既存のSPTに存在するかどうかを計算するルータ最初のチェックを実行するとき。リンクはSPTに存在しない場合、それ以上の作業は必要ありません。このチェックは、ISPF計算の正常な部分です。"
    },
    {
      "indent": 3,
      "text": "If the link is present in the SPT, this optimization introduces a further check to determine whether the link is marked as protected by an LFA in the direction in which the link appears in the SPT. If so, the iSPF need not be performed. For example, if the link appears in the SPT in the direction A->B and A has indicated that the link A-B is protected by an LFA, no further action is required for this link.",
      "ja": "リンクはSPTに存在している場合は、この最適化は、リンクがSPTに表示される方向にLFAにより保護としてリンクがマークされているかどうかを判断するために、さらに検査が導入されました。その場合、ISPFは行う必要はありません。リンク方向にSPTに表示された場合A-> BとAは、リンクA-Bは、LFAによって保護されていることを示している、例えば、さらなるアクションは、このリンクのために必要とされません。"
    },
    {
      "indent": 3,
      "text": "If the receipt of this information is delayed, the correct operation of the protocol is not compromised, provided that the necessity to perform a not-via computation is re-evaluated whenever new information arrives.",
      "ja": "この情報の受信が遅れた場合、プロトコルの正しい動作が損なわれていない、新たな情報が到着するたびに必要性が再評価されていないビア計算を実行することを条件とします。"
    },
    {
      "indent": 3,
      "text": "This optimization is not particularly beneficial to nodes close to the repair, since (as has been observed above) the computation for nodes on the LFA path is trivial. However, for nodes upstream of the link S-P for which S-P is in the path to P, there is a significant reduction in the computation required.",
      "ja": "LFA経路上のノードのための計算が簡単です（上記観察されているように）ので、この最適化は、修理に近いノードに特に有益ではありません。しかし、S-PはPへのパスであるため、リンクS-Pの上流のノードに対して、必要な計算の有意な減少があります。"
    },
    {
      "indent": 0,
      "text": "8. Multicast",
      "section_title": true,
      "ja": "8.マルチキャスト"
    },
    {
      "indent": 3,
      "text": "Multicast traffic can be repaired in a way similar to unicast. The multicast forwarder is able to use the not-via address to which the multicast packet was addressed as an indication of the expected receive interface and hence to correctly run the required Reverse Path Forwarding (RPF) check.",
      "ja": "マルチキャストトラフィックは、ユニキャストと同様の方法で修復することができます。マルチキャストフォワーダはないビアアドレスたマルチキャストパケットが期待さの指標としてアドレス指定されたToはインタフェースを受け取り、したがって正しく必要リバースパス転送（RPF）チェックを実行するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "In some cases, all the destinations, including the repair endpoint, are repairable by an LFA. In this case, all unicast traffic may be repaired without encapsulation. Multicast traffic still requires encapsulation, but for the nodes on the LFA repair path, the computation of the not-via forwarding entry is unnecessary: by definition, their normal path to the repair endpoint is not via the failure.",
      "ja": "いくつかのケースでは、修理のエンドポイントを含む、すべての宛先は、LFAによって修理可能です。この場合、すべてのユニキャストトラフィックをカプセル化せずに修復することができます。マルチキャストトラフィックは、カプセル化が必要ですが、LFA修復パス上のノードのために、フォワーディングないビアエントリの計算は不要である：定義により、修理のエンドポイントへの通常のパスが失敗経由ではありません。"
    },
    {
      "indent": 3,
      "text": "A more complete description of multicast operation is left for further study.",
      "ja": "マルチキャスト動作のより完全な説明は、さらなる研究のために残されています。"
    },
    {
      "indent": 0,
      "text": "9. Fast Reroute in an MPLS LDP Network",
      "section_title": true,
      "ja": "MPLS LDPネットワークにおける9.高速リルート"
    },
    {
      "indent": 3,
      "text": "Not-via addresses are IP addresses, and LDP [RFC5036] will distribute labels for them in the usual way. The not-via repair mechanism may therefore be used to provide fast reroute in an MPLS network by first pushing the label that the repair endpoint uses to forward the packet and then pushing the label corresponding to the not-via address needed to effect the repair. Referring once again to Figure 1, if S has a packet destined for D that it must reach via P and B, S first pushes B's label for D. S then pushes the label that its next hop to Bp needs to reach Bp.",
      "ja": "ないビアアドレスはIPアドレスであり、LDP [RFC5036]は通常の方法で彼らのためにラベルを配布します。ないビア修復機構は、従って、高速最初修復エンドポイントがパケットを転送するために使用するラベルをプッシュし、次いで未介して修復を行うために必要なアドレスに対応するラベルを押すことにより、MPLSネットワークに再ルーティングを提供するために使用することができます。 SはそれがP及びBを介して到達しなければならないD宛のパケットを有する場合、図1を再び参照すると、Sは第一D. SのためのBのラベルは、次にBPにその次ホップが塩基対に到達する必要があるラベルをプッシュプッシュします。"
    },
    {
      "indent": 3,
      "text": "Note that in an MPLS LDP network, it is necessary for S to have the repair endpoint's label for the destination. When S is effecting a link repair, it already has this. In the case of a node repair, S either needs to set up a directed LDP session with each of its neighbor's neighbors or it needs to use a method similar to the next-next-hop label distribution mechanism proposed in [NNHL].",
      "ja": "Sは、先の修復エンドポイントのラベルを持っているMPLS LDPネットワークでは、それが必要であることに注意してください。 Sは、リンクの修復を行うされている場合、それはすでにこれを持っています。ノード修復の場合、Sは、その近隣の近隣のそれぞれに向けLDPセッションを設定する必要があるのいずれかまたはそれが[NNHL]で提案されている次のネクストホップラベル分配機構と同様の方法を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "10. Encapsulation",
      "section_title": true,
      "ja": "10.カプセル化"
    },
    {
      "indent": 3,
      "text": "Any IETF-specified IP-in-IP encapsulation may be used to carry a not-via repair. IP in IP [RFC2003], Generic Routing Encapsulation (GRE) [RFC1701], and the Layer 2 Tunneling Protocol (L2TPv3) [RFC3931] all have the necessary and sufficient properties. The requirement is that both the encapsulating router and the router to which the encapsulated packet is addressed have a common ability to process the chosen encapsulation type. When an MPLS LDP network is being protected, the encapsulation would normally be an additional MPLS label. In an MPLS-enabled IP network, an MPLS label may be used in place of an IP-in-IP encapsulation in the case above.",
      "ja": "どれIETF指定のIP-in-IPカプセル化はないビア修理を運ぶために使用することができます。 IPにおけるIP [RFC2003]、総称ルーティングカプセル化（GRE）[RFC1701]、およびレイヤ2トンネリングプロトコル（L2TPv3の）[RFC3931]はすべて、必要十分な特性を有します。要件は、カプセル化ルータとカプセル化されたパケットがアドレス指定されたルータの両方が選択されたカプセル化タイプを処理する一般的能力を有することです。 MPLS LDPネットワークが保護されていた場合、カプセル化は、通常、追加のMPLSラベルになります。 MPLS対応のIPネットワークでは、MPLSラベルは、この場合のIP-in-IPカプセル化の代わりに使用してもよいです。"
    },
    {
      "indent": 3,
      "text": "Care needs to be taken to ensure that the encapsulation used to provide a repair tunnel does not result in the packet exceeding the MTU of the links traversed by that repair.",
      "ja": "ケア修復トンネルを提供するために使用されるカプセルは、その修復が横断するリンクのMTUを超えるパケットをもたらさないように注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "11. Routing Extensions",
      "section_title": true,
      "ja": "11.ルーティング拡張機能"
    },
    {
      "indent": 3,
      "text": "IPFRR requires routing protocol extensions. Each IPFRR router that is directly connected to a protected network component must advertise a not-via address for that component. This must be advertised in such a way that the association between the protected component (link, router, or SRLG) and the not-via address can be determined by the other routers in the network.",
      "ja": "IPFRRは、ルーティングプロトコルの拡張が必要です。直接保護されたネットワーク構成要素に接続された各IPFRRルータは、そのコンポーネントのない-経由でアドレスをアドバタイズする必要があります。これは、アドレスを介していない保護成分（リンク、ルータ、またはSRLG）との間の関連は、ネットワーク内の他のルータによって決定することができるような方法で広告されなければなりません。"
    },
    {
      "indent": 3,
      "text": "It is necessary that routers capable of supporting not-via routes advertise in the IGP that they will calculate not-via routes.",
      "ja": "ない-経由のルートをサポートできるルータは、彼らがいない-経由のルートを計算することをIGPに広告を出すことが必要です。"
    },
    {
      "indent": 3,
      "text": "It is necessary for routers to advertise the type of encapsulation that they support (MPLS, GRE, L2TPv3, etc.). However, the deployment of mixed IP encapsulation types within a network is discouraged.",
      "ja": "ルータは、彼らが（などMPLS、GRE、L2TPv3の、）をサポートするカプセル化のタイプを宣伝することが必要です。ただし、ネットワーク内の混合IPカプセル化タイプの展開はお勧めしません。"
    },
    {
      "indent": 3,
      "text": "If the optimization proposed in Section 7 is to be used, then the use of the LFA in place of the not-via repair MUST also be signaled in the routing protocol.",
      "ja": "第7節で提案最適化が使用される場合、次いでないビア修復の代わりにLFAの使用はまた、ルーティングプロトコルでシグナリングされなければなりません。"
    },
    {
      "indent": 0,
      "text": "12. Incremental Deployment",
      "section_title": true,
      "ja": "12.インクリメンタル展開"
    },
    {
      "indent": 3,
      "text": "Incremental deployment is supported by excluding routers that are not calculating not-via routes (as indicated by their capability information flooded with their link-state information) from the base topology used for the computation of repair paths. In that way, repairs may be steered around islands of routers that are not IPFRR capable. Routers that are protecting a network component need to have the capability to encapsulate and decapsulate packets. However, routers that are on the repair path only need to be capable of calculating not-via paths and including the not-via addresses in their FIB, i.e., these routers do not need any changes to their forwarding mechanism.",
      "ja": "増分展開が計算されていないルータを排除することによってサポートされていないビア修復経路の計算に使用されるベース・トポロジーから（それらのリンクステート情報が殺到し、その能力情報によって示されるように）経路。そのようにして、修理は可能IPFRRされていないルータの島々の周りに操縦することができます。ネットワークコンポーネントを保護しているルータは、カプセル化する機能とデカプセル化パケットを有する必要があります。しかし、修復経路上にあるルータが唯一ではないビア経路を計算していないビアそれらのFIB内のアドレスを含むことができることが必要、すなわち、これらのルータは、その転送メカニズムへの変更を必要としません。"
    },
    {
      "indent": 0,
      "text": "13. Manageability Considerations",
      "section_title": true,
      "ja": "13.管理性の考慮事項"
    },
    {
      "indent": 3,
      "text": "[RFC5714] outlines the general set of manageability considerations that apply to the general case of IPFRR. We slightly expand this and add details that are not-via specific. There are three classes of manageability considerations:",
      "ja": "[RFC5714]はIPFRRの一般的な場合に適用される管理上の考慮事項の一般的なセットを概説します。私たちは、少しこれを拡張していない - を経由している具体的な詳細を追加します。管理上の考慮事項の3つのクラスがあります。"
    },
    {
      "indent": 3,
      "text": "1. Pre-failure configuration",
      "section_title": true,
      "ja": "1.事前故障構成"
    },
    {
      "indent": 3,
      "text": "2. Pre-failure monitoring and operational support",
      "section_title": true,
      "ja": "2.事前障害監視と運用サポート"
    },
    {
      "indent": 3,
      "text": "3. Failure action monitoring",
      "section_title": true,
      "ja": "3.障害の操作監視"
    },
    {
      "indent": 0,
      "text": "13.1. Pre-failure Configuration",
      "section_title": true,
      "ja": "13.1。事前障害設定"
    },
    {
      "indent": 3,
      "text": "Pre-failure configuration for not-via includes:",
      "ja": "ないビアに対する事前予防設定が含まれています："
    },
    {
      "indent": 3,
      "text": "o Enabling/disabling not-via IPFRR support.",
      "ja": "ないビアIPFRRのサポートを有効/無効O。"
    },
    {
      "indent": 3,
      "text": "o Enabling/disabling protection on a per-link or per-node basis.",
      "ja": "Oリンク単位またはノードごとに保護を無効/有効にします。"
    },
    {
      "indent": 3,
      "text": "o Expressing preferences regarding the links/nodes used for repair paths.",
      "ja": "修復経路のために使用されるリンク/ノードに関する嗜好を表現O。"
    },
    {
      "indent": 3,
      "text": "o Configuration of failure detection mechanisms.",
      "ja": "障害検出メカニズムのO構成。"
    },
    {
      "indent": 3,
      "text": "o Setting a preference concerning the use of LFAs.",
      "ja": "LFAsの使用に関する優先順位を設定し、O。"
    },
    {
      "indent": 3,
      "text": "o Configuring a not-via address (per interface) or not-via address set (per node).",
      "ja": "O（ノードあたり）ではないビアアドレス（インタフェースごとに）か否ビアアドレスセットを設定します。"
    },
    {
      "indent": 3,
      "text": "o Configuring any SRLG rules or preferences.",
      "ja": "すべてのSRLGルールや好みの設定O。"
    },
    {
      "indent": 3,
      "text": "Any standard configuration method may be used. The selection of the method to be used is outside the scope of this document.",
      "ja": "任意の標準的な設定方法を用いることができます。使用する方法の選択は、この文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "13.2. Pre-failure Monitoring and Operational Support",
      "section_title": true,
      "ja": "13.2。事前障害監視と運用サポート"
    },
    {
      "indent": 3,
      "text": "Pre-failure monitoring and operational support for not-via include:",
      "ja": "ないビアの事前障害監視と運用サポートが含まれます："
    },
    {
      "indent": 3,
      "text": "o Notification of links/nodes/destinations that cannot be protected.",
      "ja": "保護することができない、リンク/ノード/目的地のO通知。"
    },
    {
      "indent": 3,
      "text": "o Notification of pre-computed repair paths.",
      "ja": "事前計算修復経路のO通知。"
    },
    {
      "indent": 3,
      "text": "o Notification of repair type to be used (LFA or not-via).",
      "ja": "使用する修復タイプのO通知（LFAか-を介して）。"
    },
    {
      "indent": 3,
      "text": "o Notification of not-via address assignment.",
      "ja": "アドレスの割り当てを経由していない - のO通知。"
    },
    {
      "indent": 3,
      "text": "o Notification of path or address optimizations used.",
      "ja": "使用されるパスまたはアドレスの最適化のO通知。"
    },
    {
      "indent": 3,
      "text": "o Testing repair paths. Note that not-via addresses look identical to \"ordinary\" addresses as far as tools such as traceroute and ping are concerned, and thus it is anticipated that these will be used to verify the established repair path.",
      "ja": "テストの修理パスO。ない-経由アドレスは限りなのtracerouteとpingなどのツールが懸念しているので、これらが確立し、修復パスを検証するために使用されることが予想されるとして、同一の「普通」のアドレスを見ていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Any standard IETF method may be used for the above. The selection of the method to be used is outside the scope of this document.",
      "ja": "任意の標準IETF方法は、上記のために使用することができます。使用する方法の選択は、この文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "13.3. Failure Action Monitoring",
      "section_title": true,
      "ja": "13.3。失敗アクションの監視"
    },
    {
      "indent": 3,
      "text": "Failure action monitoring for not-via includes:",
      "ja": "ないビアのための障害の操作監視が含まれています："
    },
    {
      "indent": 3,
      "text": "o Counts of failure detections, protection invocations, and packets forwarded over repair paths.",
      "ja": "O障害検出、保護の呼び出し、およびパケットのカウントは、修理・パスを介して転送。"
    },
    {
      "indent": 3,
      "text": "o Logging of the events, using a sufficiently accurate and precise timestamp.",
      "ja": "十分に正確かつ精密なタイムスタンプを使用してイベントのOロギング。"
    },
    {
      "indent": 3,
      "text": "o Validation that the packet loss was within specification, using a suitable loss verification tool.",
      "ja": "パケット損失は、適切な損失検証ツールを使用して、仕様の範囲内であったことを検証O。"
    },
    {
      "indent": 3,
      "text": "o Capture of the in-flight repair packet flows, using a tool such as IP Flow Information Export (IPFIX) [RFC5101].",
      "ja": "飛行中の修復パケットのOキャプチャは、IPフロー情報エクスポート（IPFIX）[RFC5101]などのツールを使用して、流れます。"
    },
    {
      "indent": 3,
      "text": "Note that monitoring the repair in action requires the capture of the signatures of a short, possibly sub-second network transient; this technique is not a well-developed IETF technology.",
      "ja": "アクションで修復を監視する短い、おそらくサブ第二ネットワーク過渡の署名の捕捉を必要とすることに注意してください。この技術は、よく発達したIETFの技術ではありません。"
    },
    {
      "indent": 0,
      "text": "14. Security Considerations",
      "section_title": true,
      "ja": "14.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The repair endpoints present vulnerability in that they might be used as a method of disguising the delivery of a packet to a point in the network [RFC6169]. The primary method of protection SHOULD be through the use of a private address space for the not-via addresses [RFC1918] [RFC4193]. Repair endpoint addresses MUST NOT be advertised outside the routing domain over which not-via is deployed and MUST be filtered at the network entry points. In addition, a mechanism might be developed that allows the use of the mild security available through the use of a key [RFC1701] [RFC3931]. With the deployment of such mechanisms, the repair endpoints would not increase the security risk beyond that of existing IP tunnel mechanisms. An attacker may attempt to overload a router by addressing an excessive traffic load to the decapsulation endpoint. Typically, routers take a 50% performance penalty in decapsulating a packet. The attacker could not be certain that the router would be impacted, and the extremely high volume of traffic needed would easily be detected as an anomaly. If an attacker were able to influence the availability of a link, they could cause the network to invoke the not-via repair mechanism. A network protected by not-via IPFRR is less vulnerable to such an attack than a network that undertook a full convergence in response to a link up/down event.",
      "ja": "それらはネットワーク[RFC6169]にポイントへのパケットの配信を偽装する方法として使用されるかもしれないことで修復エンドポイントに存在する脆弱性。保護の主な方法はない - を経由してアドレス[RFC1918] [RFC4193]のためのプライベートアドレス空間を使用してあるべきです。リペア・エンドポイント・アドレスがないビアが展開され、ネットワークエントリポイントでフィルタリングされなければならない上にルーティングドメインの外側に広告されてはいけません。また、機構は、キー[RFC1701]を使用する[RFC3931]を介して利用可能な軽度のセキュリティの使用を可能にするように開発されるかもしれません。そのようなメカニズムの導入によって、修理エンドポイントは、既存のIPトンネルの仕組みのことを超えて、セキュリティ上のリスクを増加させないでしょう。攻撃者は、デカプセル化エンドポイントに過剰なトラフィック負荷に対処して、ルータを過負荷状態にしようとすることがあります。典型的には、ルータはパケットをデカプセル化中の50％の性能ペナルティを取ります。攻撃者は、ルータが影響を受けることになる、と必要なトラフィックの非常に高い音量を簡単に異常として検出されることを確信することができませんでした。攻撃者は、リンクの可用性に影響を与えることができたならば、彼らはネットワークが起動しない - を経由して修復機構引き起こす可能性があります。ないビアIPFRRによって保護されたネットワークは、リンクアップ/ダウンイベントに応答して、完全な収束を行ったネットワークよりも、そのような攻撃に対してより脆弱です。"
    },
    {
      "indent": 0,
      "text": "15. Acknowledgements",
      "section_title": true,
      "ja": "15.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to acknowledge contributions made by Alia Atlas and John Harper.",
      "ja": "著者は、アリアアトラスとジョン・ハーパーの貢献を認めたいと思います。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16.参考文献"
    },
    {
      "indent": 0,
      "text": "16.1. Normative References",
      "section_title": true,
      "ja": "16.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "16.2. Informative References",
      "section_title": true,
      "ja": "16.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[ISPF] McQuillan, J., Richer, I., and E. Rosen, \"ARPANET Routing Algorithm Improvements\", BBN Technical Report 3803, 1978.",
      "ja": "【ISPF] McQuillan氏の説明による、J.、豊かな、I.、およびE.ローゼン、 \"ARPANETルーティングアルゴリズムの改良\"、BBN技術レポート3803、1978。"
    },
    {
      "indent": 3,
      "text": "[NNHL] Shen, N., Chen, E., and A. Tian, \"Discovering LDP Next-Nexthop Labels\", Work in Progress, May 2005.",
      "ja": "[NNHL]シェン、N.、チェン、E.、およびA.天、 \"発見LDP次-ネクストホップラベル\"、進歩、2005年5月での作業。"
    },
    {
      "indent": 3,
      "text": "[REMOTE-LFA] Bryant, S., Filsfils, C., Previdi, S., Shand, M., and N. So, \"Remote LFA FRR\", Work in Progress, May 2013.",
      "ja": "[REMOTE-LFA]ブライアント、S.、Filsfils、C.、Previdi、S.、シャンド、M.、およびN.ので、 \"リモートLFA FRR\"、進歩、2013年5月での作業。"
    },
    {
      "indent": 3,
      "text": "[RFC1701] Hanks, S., Li, T., Farinacci, D., and P. Traina, \"Generic Routing Encapsulation (GRE)\", RFC 1701, October 1994.",
      "ja": "[RFC1701]ハンクス、S.、李、T.、ファリナッチ、D.、およびP. Trainaの、 \"総称ルーティングカプセル化（GRE）\"、RFC 1701、1994年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1918] Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and E. Lear, \"Address Allocation for Private Internets\", BCP 5, RFC 1918, February 1996.",
      "ja": "[RFC1918] Rekhter、Y.、モスコウィッツ、R.、Karrenberg、D.、グルート、G.、およびE.リア、 \"個人的なインターネットのための配分\"、BCP 5、RFC 1918、1996年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2003] Perkins, C., \"IP Encapsulation within IP\", RFC 2003, October 1996.",
      "ja": "[RFC2003]パーキンス、C.、 \"IP内IPカプセル化\"、RFC 2003、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC3931] Lau, J., Townsley, M., and I. Goyret, \"Layer Two Tunneling Protocol - Version 3 (L2TPv3)\", RFC 3931, March 2005.",
      "ja": "[RFC3931]ラウ、J.、Townsley、M.、およびI. Goyret、 \"レイヤ2トンネリングプロトコル - バージョン3（L2TPv3の）\"、RFC 3931、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4193] Hinden, R. and B. Haberman, \"Unique Local IPv6 Unicast Addresses\", RFC 4193, October 2005.",
      "ja": "[RFC4193] HindenとR.とB.ハーバーマン、 \"ユニークローカルIPv6ユニキャストアドレス\"、RFC 4193、2005年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5036] Andersson, L., Minei, I., and B. Thomas, \"LDP Specification\", RFC 5036, October 2007.",
      "ja": "[RFC5036]アンデション、L.、Minei、I.、およびB.トーマス、 \"LDP仕様\"、RFC 5036、2007年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5101] Claise, B., \"Specification of the IP Flow Information Export (IPFIX) Protocol for the Exchange of IP Traffic Flow Information\", RFC 5101, January 2008.",
      "ja": "[RFC5101] Claise、B.、 \"IPトラフィックフロー情報を交換するためのIPフロー情報のエクスポート（IPFIX）プロトコルの仕様\"、RFC 5101、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5286] Atlas, A. and A. Zinin, \"Basic Specification for IP Fast Reroute: Loop-Free Alternates\", RFC 5286, September 2008.",
      "ja": "[RFC5286]アトラス、A.とA.ジニン、 \"IP高速リルートのための基本仕様：ループフリーのAlternates\"、RFC 5286、2008年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5714] Shand, M. and S. Bryant, \"IP Fast Reroute Framework\", RFC 5714, January 2010.",
      "ja": "[RFC5714]シャンド、M.とS.ブライアント、 \"IP高速リルートフレームワーク\"、RFC 5714、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5880] Katz, D. and D. Ward, \"Bidirectional Forwarding Detection (BFD)\", RFC 5880, June 2010.",
      "ja": "[RFC5880]カッツ、D.およびD.区、 \"双方向フォワーディング検出（BFD）\"、RFC 5880、2010年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC6169] Krishnan, S., Thaler, D., and J. Hoagland, \"Security Concerns with IP Tunneling\", RFC 6169, April 2011.",
      "ja": "[RFC6169]クリシュナン、S.、ターラー、D.、およびJ.ホーグランド、 \"IPトンネリングとセキュリティの懸念\"、RFC 6169、2011年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC6976] Shand, M., Bryant, S., Previdi, S., Filsfils, C., Francois, P., and O. Bonaventure, \"Framework for Loop-Free Convergence Using the Ordered Forwarding Information Base (oFIB) Approach\", RFC 6976, July 2013.",
      "ja": "[RFC6976]シャンド、M.、ブライアント、S.、Previdi、S.、Filsfils、C.、フランソワ、P.、およびO.ボナヴェントゥラ、「順序付き転送情報ベースを使用してループフリーコンバージェンスのためのフレームワーク（oFIB）アプローチ」、RFC 6976、2013年7月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Q-Space",
      "ja": "付録A. Q-スペース"
    },
    {
      "indent": 3,
      "text": "Q-space is the set of routers from which a specific router can be reached without any path (including equal-cost path splits) transiting the protected link (or node). It is described fully in [REMOTE-LFA].",
      "ja": "Q-スペースは、特定のルータが（等コスト・パス分割を含む）保護リンク（またはノード）を通過する任意のパスなしで到達可能なルータの集合です。これは、[REMOTE-LFA]で完全に記述されています。"
    },
    {
      "indent": 33,
      "text": "  S---Eq\n /     \\\nA       Dq\n \\     /\n  B---Cq",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 15: The Q Space of E with Respect to the Link S-E",
      "ja": "図15：リンクS-Eに対するEのQスペース"
    },
    {
      "indent": 3,
      "text": "Consider a repair of link S-E (Figure 15). The set of routers from which the node E can be reached, by normal forwarding, without traversing the link S-E is termed the Q-space of E with respect to the link S-E. The Q-space can be obtained by computing a reverse Shortest Path Tree (rSPT) rooted at E, with the sub-tree that traverses the failed link excised (including those that are members of an ECMP). The rSPT uses the cost towards the root rather than from it and yields the best paths towards the root from other nodes in the network. In the case of Figure 15, the Q-space comprises nodes E, D, and C only.",
      "ja": "リンクS-E（図15）の修復を考えてみましょう。ノードEは、リンクS-Eを横断せずに、通常の転送によって、到達可能なルータの集合は、リンクS-Eに対してEのQ-空間と呼ばれます。 Q-空間は（ECMPのメンバーであるものを含む）切除不良リンクを横断するサブツリーと、Eをルートと逆最短経路ツリー（RSPT）を計算することにより得ることができます。 RSPTはそれからではなく、ルートへのコストを使用し、ネットワーク内の他のノードからルートに向けた最善のパスを生成します。図15の場合には、Q-空間ノードのみE、D、およびCを含みます。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Stewart Bryant Cisco Systems 10 New Square, Bedfont Lakes Feltham, Middlesex TW18 8HA UK",
      "ja": "スチュワートブライアントシスコシステムズ10新スクエア、Bedfont湖フェルサム、ミドルTW18 8HA英国"
    },
    {
      "indent": 3,
      "text": "EMail: stbryant@cisco.com",
      "ja": "メールアドレス：stbryant@cisco.com"
    },
    {
      "indent": 3,
      "text": "Stefano Previdi Cisco Systems Via Del Serafico, 200 00142 Rome Italy",
      "ja": "スティーブンは、シスコシステムズヴィアデルセラフィック、200 00142ローマイタリアを予見しました"
    },
    {
      "indent": 3,
      "text": "EMail: sprevidi@cisco.com",
      "ja": "メールアドレス：sprevidi@cisco.com"
    },
    {
      "indent": 3,
      "text": "Mike Shand Individual Contributor",
      "ja": "マイク・シャンド投稿者"
    },
    {
      "indent": 3,
      "text": "EMail: imc.shand@googlemail.com",
      "ja": "メールアドレス：imc.shand@googlemail.com"
    }
  ]
}