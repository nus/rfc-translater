{
  "title": {
    "text": "RFC 6570 - URI Template",
    "ja": "RFC 6570 - URIテンプレート"
  },
  "number": 6570,
  "created_at": "2019-10-27 21:37:43.582646+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       J. Gregorio\nRequest for Comments: 6570                                        Google\nCategory: Standards Track                                    R. Fielding\nISSN: 2070-1721                                                    Adobe\n                                                               M. Hadley\n                                                                   MITRE\n                                                           M. Nottingham\n                                                               Rackspace\n                                                              D. Orchard\n                                                          Salesforce.com\n                                                              March 2012",
      "raw": true
    },
    {
      "indent": 30,
      "text": "URI Template",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "A URI Template is a compact sequence of characters for describing a range of Uniform Resource Identifiers through variable expansion. This specification defines the URI Template syntax and the process for expanding a URI Template into a URI reference, along with guidelines for the use of URI Templates on the Internet.",
      "ja": "URIテンプレートは、可変膨張を通じてユニフォームリソース識別子の範囲を説明するための文字のコンパクトな配列です。この仕様は、インターネット上のURIテンプレートを使用するためのガイドラインとともに、URIテンプレートの構文とURI参照にURIテンプレートを拡張するためのプロセスを定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6570.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6570で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2012 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Overview ...................................................3\n   1.2. Levels and Expression Types ................................5\n   1.3. Design Considerations ......................................9\n   1.4. Limitations ...............................................10\n   1.5. Notational Conventions ....................................11\n   1.6. Character Encoding and Unicode Normalization ..............12\n2. Syntax .........................................................13\n   2.1. Literals ..................................................13\n   2.2. Expressions ...............................................13\n   2.3. Variables .................................................14\n   2.4. Value Modifiers ...........................................15\n        2.4.1. Prefix Values ......................................15\n        2.4.2. Composite Values ...................................16\n3. Expansion ......................................................18\n   3.1. Literal Expansion .........................................18\n   3.2. Expression Expansion ......................................18\n        3.2.1. Variable Expansion .................................19\n        3.2.2. Simple String Expansion: {var} .....................21\n        3.2.3. Reserved Expansion: {+var} .........................22\n        3.2.4. Fragment Expansion: {#var} .........................23\n        3.2.5. Label Expansion with Dot-Prefix: {.var} ............24\n        3.2.6. Path Segment Expansion: {/var} .....................24\n        3.2.7. Path-Style Parameter Expansion: {;var} .............25\n        3.2.8. Form-Style Query Expansion: {?var} .................26\n        3.2.9. Form-Style Query Continuation: {&var} ..............27\n4. Security Considerations ........................................27\n5. Acknowledgments ................................................28\n6. References .....................................................28\n   6.1. Normative References ......................................28\n   6.2. Informative References ....................................29\nAppendix A. Implementation Hints ..................................30",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. Overview",
      "section_title": true,
      "ja": "1.1. 概要"
    },
    {
      "indent": 3,
      "text": "A Uniform Resource Identifier (URI) [RFC3986] is often used to identify a specific resource within a common space of similar resources (informally, a \"URI space\"). For example, personal web spaces are often delegated using a common pattern, such as",
      "ja": "ユニフォームリソース識別子（URI）[RFC3986]は、多くの場合、同様のリソースの共通の空間（非公式に「URI空間」）内の特定のリソースを識別するために使用されます。例えば、個人のWebスペースは、多くの場合のような、一般的なパターンを使用して委任されています"
    },
    {
      "indent": 5,
      "text": "http://example.com/~fred/ http://example.com/~mark/",
      "ja": "ｈっｔｐ：／／えぁｍｐぇ。こｍ／〜ｆれｄ／ ｈっｔｐ：／／えぁｍｐぇ。こｍ／〜まｒｋ／"
    },
    {
      "indent": 3,
      "text": "or a set of dictionary entries might be grouped in a hierarchy by the first letter of the term, as in",
      "ja": "または辞書エントリのセットはのように、用語の最初の文字によって階層にグループ化される可能性があります"
    },
    {
      "indent": 5,
      "text": "http://example.com/dictionary/c/cat http://example.com/dictionary/d/dog",
      "ja": "ｈっｔｐ：／／えぁｍｐぇ。こｍ／ぢｃちおなｒｙ／ｃ／かｔ ｈっｔｐ：／／えぁｍｐぇ。こｍ／ぢｃちおなｒｙ／ｄ／どｇ"
    },
    {
      "indent": 3,
      "text": "or a service interface might be invoked with various user input in a common pattern, as in",
      "ja": "またはサービス・インタフェースは、同様に、共通のパターンで様々なユーザ入力で呼び出されるかもしれません"
    },
    {
      "indent": 5,
      "text": "http://example.com/search?q=cat&lang=en http://example.com/search?q=chien&lang=fr",
      "ja": "ｈっｔｐ：／／えぁｍｐぇ。こｍ／せあｒｃｈ？ｑ＝かｔ＆ぁんｇ＝えん ｈっｔｐ：／／えぁｍｐぇ。こｍ／せあｒｃｈ？ｑ＝ちえん＆ぁんｇ＝ｆｒ"
    },
    {
      "indent": 3,
      "text": "A URI Template is a compact sequence of characters for describing a range of Uniform Resource Identifiers through variable expansion.",
      "ja": "URIテンプレートは、可変膨張を通じてユニフォームリソース識別子の範囲を説明するための文字のコンパクトな配列です。"
    },
    {
      "indent": 3,
      "text": "URI Templates provide a mechanism for abstracting a space of resource identifiers such that the variable parts can be easily identified and described. URI Templates can have many uses, including the discovery of available services, configuring resource mappings, defining computed links, specifying interfaces, and other forms of programmatic interaction with resources. For example, the above resources could be described by the following URI Templates:",
      "ja": "URIテンプレートは、可変部分を容易に識別し、説明することができるように、リソース識別子の空間を抽象化するためのメカニズムを提供します。 URIテンプレートは、計算されたリンクを定義し、リソースのマッピングを設定し、利用可能なサービスの発見など、指定のインターフェイス、およびリソースと、プログラムの相互作用、他の形態の多くの用途を持つことができます。例えば、上記のリソースは、次のURIテンプレートによって記述することができます。"
    },
    {
      "indent": 5,
      "text": "http://example.com/~{username}/ http://example.com/dictionary/{term:1}/{term} http://example.com/search{?q,lang}",
      "ja": "ｈっｔｐ：／／えぁｍｐぇ。こｍ／〜｛うせｒなめ｝／ ｈっｔｐ：／／えぁｍｐぇ。こｍ／ぢｃちおなｒｙ／｛てｒｍ：１｝／｛てｒｍ｝ ｈっｔｐ：／／えぁｍｐぇ。こｍ／せあｒｃｈ｛？ｑ、ぁんｇ｝"
    },
    {
      "indent": 3,
      "text": "We define the following terms:",
      "ja": "私たちは、次の用語を定義します。"
    },
    {
      "indent": 3,
      "text": "expression: The text between '{' and '}', including the enclosing braces, as defined in Section 2.",
      "ja": "式：の間のテキスト「{」と「}」、セクション2で定義されるように囲む括弧を含みます。"
    },
    {
      "indent": 3,
      "text": "expansion: The string result obtained from a template expression after processing it according to its expression type, list of variable names, and value modifiers, as defined in Section 3.",
      "ja": "膨張：セクション3で定義されるように、その表現型、変数名のリスト、および値修飾子に従ってそれを処理した後、テンプレート発現から得られた文字列結果。"
    },
    {
      "indent": 3,
      "text": "template processor: A program or library that, given a URI Template and a set of variables with values, transforms the template string into a URI reference by parsing the template for expressions and substituting each one with its corresponding expansion.",
      "ja": "テンプレートエンジン：URIテンプレートと値を持つ変数の集合が与えられると、プログラムやライブラリは、式のテンプレートを解析し、それに対応する拡大にそれぞれを置換することによってURI参照にテンプレート文字列を変換します。"
    },
    {
      "indent": 3,
      "text": "A URI Template provides both a structural description of a URI space and, when variable values are provided, machine-readable instructions on how to construct a URI corresponding to those values. A URI Template is transformed into a URI reference by replacing each delimited expression with its value as defined by the expression type and the values of variables named within the expression. The expression types range from simple string expansion to multiple name=value lists. The expansions are based on the URI generic syntax, allowing an implementation to process any URI Template without knowing the scheme-specific requirements of every possible resulting URI.",
      "ja": "URIテンプレートは、変数の値はこれらの値に対応するURIを構築する方法について、機械可読命令を提供しているURIの空間と、の構造記述の両方を提供します。 URIテンプレートは、発現型と表現内の名前付き変数の値によって定義されるように、その値を用いて、各区切りの式を置き換えることによって、URI参照に変換されます。表現型には、単純な文字列展開から複数の名前=値のリストに及びます。拡張は、実装が可能なすべての結果のURIのスキーム固有の要件を知らなくても、任意のURIテンプレートを処理することができ、URIの一般的な構文に基づいています。"
    },
    {
      "indent": 3,
      "text": "For example, the following URI Template includes a form-style parameter expression, as indicated by the \"?\" operator appearing before the variable names.",
      "ja": "たとえば、次のURIテンプレートは、「？」によって示されるように、フォームスタイルパラメータ表現を含みます変数名の前に現れる演算子。"
    },
    {
      "indent": 5,
      "text": "http://www.example.com/foo{?query,number}",
      "ja": "ｈっｔｐ：／／ｗっｗ。えぁｍｐぇ。こｍ／ふぉお｛？くえｒｙ、ぬｍべｒ｝"
    },
    {
      "indent": 3,
      "text": "The expansion process for expressions beginning with the question-mark (\"?\") operator follows the same pattern as form-style interfaces on the World Wide Web:",
      "ja": "疑問符で始まる式の展開プロセス（「？」）演算子は、World Wide Web上のフォーム形式のインターフェースと同じパターンに従います。"
    },
    {
      "indent": 5,
      "text": "http://www.example.com/foo{?query,number}\n                          \\_____________/\n                             |\n                             |\n        For each defined variable in [ 'query', 'number' ],\n        substitute \"?\" if it is the first substitution or \"&\"\n        thereafter, followed by the variable name, '=', and the\n        variable's value.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the variables have the values",
      "ja": "変数が値を持っている場合"
    },
    {
      "indent": 5,
      "text": "query := \"mycelium\" number := 100",
      "ja": "クエリ：= \"菌糸体\" 数= 100"
    },
    {
      "indent": 3,
      "text": "then the expansion of the above URI Template is",
      "ja": "次いで、上記URIテンプレートの拡張であります"
    },
    {
      "indent": 5,
      "text": "http://www.example.com/foo?query=mycelium&number=100",
      "ja": "ｈっｔｐ：／／ｗっｗ。えぁｍｐぇ。こｍ／ふぉお？くえｒｙ＝ｍｙせぃうｍ＆ぬｍべｒ＝１００"
    },
    {
      "indent": 3,
      "text": "Alternatively, if 'query' is undefined, then the expansion would be",
      "ja": "「クエリ」が定義されていない場合あるいは、その後の拡張は次のようになります"
    },
    {
      "indent": 5,
      "text": "http://www.example.com/foo?number=100",
      "ja": "ｈっｔｐ：／／ｗっｗ。えぁｍｐぇ。こｍ／ふぉお？ぬｍべｒ＝１００"
    },
    {
      "indent": 3,
      "text": "or if both variables are undefined, then it would be",
      "ja": "両方の変数が定義されていない場合は、それは次のようになります"
    },
    {
      "indent": 5,
      "text": "http://www.example.com/foo",
      "ja": "ｈっｔｐ：／／ｗっｗ。えぁｍｐぇ。こｍ／ふぉお"
    },
    {
      "indent": 3,
      "text": "A URI Template may be provided in absolute form, as in the examples above, or in relative form. A template is expanded before the resulting reference is resolved from relative to absolute form.",
      "ja": "URIテンプレートは、上記の例のように、または相対形で、絶対的な形で提供することができます。得られた参照が絶対形式に対してから分離される前に、テンプレートが展開されます。"
    },
    {
      "indent": 3,
      "text": "Although the URI syntax is used for the result, the template string is allowed to contain the broader set of characters that can be found in Internationalized Resource Identifier (IRI) references [RFC3987]. Therefore, a URI Template is also an IRI template, and the result of template processing can be transformed to an IRI by following the process defined in Section 3.2 of [RFC3987].",
      "ja": "URIの構文は、結果のために使用されているが、テンプレート文字列は国際化リソース識別子（IRI）の参考文献[RFC3987]に見出すことができる文字の広いセットを含有させることができます。したがって、URIテンプレートは、IRIのテンプレートであり、テンプレート処理の結果は、[RFC3987]のセクション3.2で定義されたプロセスに従うことによりIRIに変換することができます。"
    },
    {
      "indent": 0,
      "text": "1.2. Levels and Expression Types",
      "section_title": true,
      "ja": "1.2. レベルと式のタイプ"
    },
    {
      "indent": 3,
      "text": "URI Templates are similar to a macro language with a fixed set of macro definitions: the expression type determines the expansion process. The default expression type is simple string expansion, wherein a single named variable is replaced by its value as a string after pct-encoding any characters not in the set of unreserved URI characters (Section 1.5).",
      "ja": "URIテンプレートは、マクロ定義の固定セットとマクロ言語に類似している：式タイプは、拡張プロセスを決定します。既定の表現型は、単一の名前付き変数は、PCTコード予約されていないURI文字のセットにない任意の文字（セクション1.5）の後に文字列としてその値で置き換えられている、単純な文字列の拡張です。"
    },
    {
      "indent": 3,
      "text": "Since most template processors implemented prior to this specification have only implemented the default expression type, we refer to these as Level 1 templates.",
      "ja": "ほとんどのテンプレートプロセッサは、デフォルトの式の型を実装しているこの仕様に先立って実施しているので、我々はレベル1のテンプレートとしてこれらを参照してください。"
    },
    {
      "indent": 3,
      "text": ".-----------------------------------------------------------------.\n| Level 1 examples, with variables having values of               |\n|                                                                 |\n|             var   := \"value\"                                    |\n|             hello := \"Hello World!\"                             |\n|                                                                 |\n|-----------------------------------------------------------------|\n| Op       Expression            Expansion                        |\n|-----------------------------------------------------------------|\n|     | Simple string expansion                       (Sec 3.2.2) |\n|     |                                                           |\n|     |    {var}                 value                            |\n|     |    {hello}               Hello%20World%21                 |\n`-----------------------------------------------------------------'",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Level 2 templates add the plus (\"+\") operator, for expansion of values that are allowed to include reserved URI characters (Section 1.5), and the crosshatch (\"#\") operator for expansion of fragment identifiers.",
      "ja": "レベル2のテンプレートを禁じURI文字（セクション1.5）、およびフラグメント識別子の拡大のためのクロスハッチ（「＃」）演算子を含めることが許可されている値の拡張のためのプラス（「+」）オペレータを追加します。"
    },
    {
      "indent": 3,
      "text": ".-----------------------------------------------------------------.\n| Level 2 examples, with variables having values of               |\n|                                                                 |\n|             var   := \"value\"                                    |\n|             hello := \"Hello World!\"                             |\n|             path  := \"/foo/bar\"                                 |\n|                                                                 |\n|-----------------------------------------------------------------|\n| Op       Expression            Expansion                        |\n|-----------------------------------------------------------------|\n|  +  | Reserved string expansion                     (Sec 3.2.3) |\n|     |                                                           |\n|     |    {+var}                value                            |\n|     |    {+hello}              Hello%20World!                   |\n|     |    {+path}/here          /foo/bar/here                    |\n|     |    here?ref={+path}      here?ref=/foo/bar                |\n|-----+-----------------------------------------------------------|\n|  #  | Fragment expansion, crosshatch-prefixed       (Sec 3.2.4) |\n|     |                                                           |\n|     |    X{#var}               X#value                          |\n|     |    X{#hello}             X#Hello%20World!                 |\n`-----------------------------------------------------------------'",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Level 3 templates allow multiple variables per expression, each separated by a comma, and add more complex operators for dot-prefixed labels, slash-prefixed path segments, semicolon-prefixed path parameters, and the form-style construction of a query syntax consisting of name=value pairs that are separated by an ampersand character.",
      "ja": "レベル3のテンプレートはそれぞれカンマで区切られた、発現ごとに複数の変数を可能にし、ドット接頭辞ラベル、スラッシュ接頭経路セグメント、セミコロンで接頭辞パスパラメータ、およびからなるクエリ構文のフォーム形式の構築のために、より複雑な演算子を追加アンパサンド文字で区切られた名前=値のペア。"
    },
    {
      "indent": 3,
      "text": ".-----------------------------------------------------------------.\n| Level 3 examples, with variables having values of               |\n|                                                                 |\n|             var   := \"value\"                                    |\n|             hello := \"Hello World!\"                             |\n|             empty := \"\"                                         |\n|             path  := \"/foo/bar\"                                 |\n|             x     := \"1024\"                                     |\n|             y     := \"768\"                                      |\n|                                                                 |\n|-----------------------------------------------------------------|\n| Op       Expression            Expansion                        |\n|-----------------------------------------------------------------|\n|     | String expansion with multiple variables      (Sec 3.2.2) |\n|     |                                                           |\n|     |    map?{x,y}             map?1024,768                     |\n|     |    {x,hello,y}           1024,Hello%20World%21,768        |\n|     |                                                           |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "|-----+-----------------------------------------------------------|\n|  +  | Reserved expansion with multiple variables    (Sec 3.2.3) |\n|     |                                                           |\n|     |    {+x,hello,y}          1024,Hello%20World!,768          |\n|     |    {+path,x}/here        /foo/bar,1024/here               |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  #  | Fragment expansion with multiple variables    (Sec 3.2.4) |\n|     |                                                           |\n|     |    {#x,hello,y}          #1024,Hello%20World!,768         |\n|     |    {#path,x}/here        #/foo/bar,1024/here              |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  .  | Label expansion, dot-prefixed                 (Sec 3.2.5) |\n|     |                                                           |\n|     |    X{.var}               X.value                          |\n|     |    X{.x,y}               X.1024.768                       |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  /  | Path segments, slash-prefixed                 (Sec 3.2.6) |\n|     |                                                           |\n|     |    {/var}                /value                           |\n|     |    {/var,x}/here         /value/1024/here                 |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  ;  | Path-style parameters, semicolon-prefixed     (Sec 3.2.7) |\n|     |                                                           |\n|     |    {;x,y}                ;x=1024;y=768                    |\n|     |    {;x,y,empty}          ;x=1024;y=768;empty              |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  ?  | Form-style query, ampersand-separated         (Sec 3.2.8) |\n|     |                                                           |\n|     |    {?x,y}                ?x=1024&y=768                    |\n|     |    {?x,y,empty}          ?x=1024&y=768&empty=             |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  &  | Form-style query continuation                 (Sec 3.2.9) |\n|     |                                                           |\n|     |    ?fixed=yes{&x}        ?fixed=yes&x=1024                |\n|     |    {&x,y,empty}          &x=1024&y=768&empty=             |\n|     |                                                           |\n`-----------------------------------------------------------------'",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Finally, Level 4 templates add value modifiers as an optional suffix to each variable name. A prefix modifier (\":\") indicates that only a limited number of characters from the beginning of the value are used by the expansion (Section 2.4.1). An explode (\"*\") modifier",
      "ja": "最後に、レベル4のテンプレートは各変数名にオプションの接尾辞として値修飾子を追加します。接頭修飾子は、（「：」）値の先頭からの文字数の限られた数の拡張（2.4.1）で使用されていることを示しています。爆発（「*」）修飾子"
    },
    {
      "indent": 3,
      "text": "indicates that the variable is to be treated as a composite value, consisting of either a list of names or an associative array of (name, value) pairs, that is expanded as if each member were a separate variable (Section 2.4.2).",
      "ja": "名前のリストまたは各メンバーが別々の変数（2.4.2項）であるかのように展開される（名前、値）ペアの連想配列のいずれかからなる、変数が複合値として扱われるべきであることを示しています。"
    },
    {
      "indent": 3,
      "text": ".-----------------------------------------------------------------.\n| Level 4 examples, with variables having values of               |\n|                                                                 |\n|             var   := \"value\"                                    |\n|             hello := \"Hello World!\"                             |\n|             path  := \"/foo/bar\"                                 |\n|             list  := (\"red\", \"green\", \"blue\")                   |\n|             keys  := [(\"semi\",\";\"),(\"dot\",\".\"),(\"comma\",\",\")]   |\n|                                                                 |\n| Op       Expression            Expansion                        |\n|-----------------------------------------------------------------|\n|     | String expansion with value modifiers         (Sec 3.2.2) |\n|     |                                                           |\n|     |    {var:3}               val                              |\n|     |    {var:30}              value                            |\n|     |    {list}                red,green,blue                   |\n|     |    {list*}               red,green,blue                   |\n|     |    {keys}                semi,%3B,dot,.,comma,%2C         |\n|     |    {keys*}               semi=%3B,dot=.,comma=%2C         |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  +  | Reserved expansion with value modifiers       (Sec 3.2.3) |\n|     |                                                           |\n|     |    {+path:6}/here        /foo/b/here                      |\n|     |    {+list}               red,green,blue                   |\n|     |    {+list*}              red,green,blue                   |\n|     |    {+keys}               semi,;,dot,.,comma,,             |\n|     |    {+keys*}              semi=;,dot=.,comma=,             |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  #  | Fragment expansion with value modifiers       (Sec 3.2.4) |\n|     |                                                           |\n|     |    {#path:6}/here        #/foo/b/here                     |\n|     |    {#list}               #red,green,blue                  |\n|     |    {#list*}              #red,green,blue                  |\n|     |    {#keys}               #semi,;,dot,.,comma,,            |\n|     |    {#keys*}              #semi=;,dot=.,comma=,            |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  .  | Label expansion, dot-prefixed                 (Sec 3.2.5) |\n|     |                                                           |\n|     |    X{.var:3}             X.val                            |\n|     |    X{.list}              X.red,green,blue                 |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "|     |    X{.list*}             X.red.green.blue                 |\n|     |    X{.keys}              X.semi,%3B,dot,.,comma,%2C       |\n|     |    X{.keys*}             X.semi=%3B.dot=..comma=%2C       |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  /  | Path segments, slash-prefixed                 (Sec 3.2.6) |\n|     |                                                           |\n|     |    {/var:1,var}          /v/value                         |\n|     |    {/list}               /red,green,blue                  |\n|     |    {/list*}              /red/green/blue                  |\n|     |    {/list*,path:4}       /red/green/blue/%2Ffoo           |\n|     |    {/keys}               /semi,%3B,dot,.,comma,%2C        |\n|     |    {/keys*}              /semi=%3B/dot=./comma=%2C        |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  ;  | Path-style parameters, semicolon-prefixed     (Sec 3.2.7) |\n|     |                                                           |\n|     |    {;hello:5}            ;hello=Hello                     |\n|     |    {;list}               ;list=red,green,blue             |\n|     |    {;list*}              ;list=red;list=green;list=blue   |\n|     |    {;keys}               ;keys=semi,%3B,dot,.,comma,%2C   |\n|     |    {;keys*}              ;semi=%3B;dot=.;comma=%2C        |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  ?  | Form-style query, ampersand-separated         (Sec 3.2.8) |\n|     |                                                           |\n|     |    {?var:3}              ?var=val                         |\n|     |    {?list}               ?list=red,green,blue             |\n|     |    {?list*}              ?list=red&list=green&list=blue   |\n|     |    {?keys}               ?keys=semi,%3B,dot,.,comma,%2C   |\n|     |    {?keys*}              ?semi=%3B&dot=.&comma=%2C        |\n|     |                                                           |\n|-----+-----------------------------------------------------------|\n|  &  | Form-style query continuation                 (Sec 3.2.9) |\n|     |                                                           |\n|     |    {&var:3}              &var=val                         |\n|     |    {&list}               &list=red,green,blue             |\n|     |    {&list*}              &list=red&list=green&list=blue   |\n|     |    {&keys}               &keys=semi,%3B,dot,.,comma,%2C   |\n|     |    {&keys*}              &semi=%3B&dot=.&comma=%2C        |\n|     |                                                           |\n`-----------------------------------------------------------------'",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1.3. Design Considerations",
      "section_title": true,
      "ja": "1.3. 設計上の考慮事項"
    },
    {
      "indent": 3,
      "text": "Mechanisms similar to URI Templates have been defined within several specifications, including WSDL [WSDL], WADL [WADL], and OpenSearch [OpenSearch]. This specification extends and formally defines the",
      "ja": "URIテンプレートと同様のメカニズムがWSDL [WSDL]、WADL [WADL]、およびOpenSearchの【のOpenSearch]を含む、いくつかの仕様の範囲内で定義されています。この仕様は、拡張し、正式に定義されて"
    },
    {
      "indent": 3,
      "text": "syntax so that URI Templates can be used consistently across multiple Internet applications and within Internet message fields, while at the same time retaining compatibility with those earlier definitions.",
      "ja": "構文同時に、それらの以前の定義との互換性を維持しながら、URIテンプレートは、複数のインターネットアプリケーション間およびインターネットメッセージフィールド内で一貫して使用することができます。"
    },
    {
      "indent": 3,
      "text": "The URI Template syntax has been designed to carefully balance the need for a powerful expansion mechanism with the need for ease of implementation. The syntax is designed to be trivial to parse while at the same time providing enough flexibility to express many common template scenarios. Implementations are able to parse the template and perform the expansions in a single pass.",
      "ja": "URIテンプレートの構文は慎重に実装を容易にするために必要と強力な膨張機構の必要性のバランスをとるように設計されています。構文は、同時に多くの一般的なテンプレートのシナリオを表現するのに十分な柔軟性を提供しながら解析するのは簡単になるように設計されています。実装は、テンプレートを解析し、シングルパスで展開を行うことができます。"
    },
    {
      "indent": 3,
      "text": "Templates are simple and readable when used with common examples because the single-character operators match the URI generic syntax delimiters. The operator's associated delimiter (\".\", \";\", \"/\", \"?\", \"&\", and \"#\") is omitted when none of the listed variables are defined. Likewise, the expansion process for \";\" (path-style parameters) will omit the \"=\" when the variable value is empty, whereas the process for \"?\" (form-style parameters) will not omit the \"=\" when the value is empty. Multiple variables and list values have their values joined with \",\" if there is no predefined joining mechanism for the operator. The \"+\" and \"#\" operators will substitute unencoded reserved characters found inside the variable values; the other operators will pct-encode reserved characters found in the variable values prior to expansion.",
      "ja": "単一文字の演算子がURI汎用構文区切り文字に一致するので、一般的な例で使用した場合、テンプレートはシンプルで読みやすいです。オペレータの関連デリミタ（「」、 『』、 『？』、 『/』、 『＆』、及び 『＃』）が記載されている変数のどれが定義されていない場合には省略されています。 「;」について同様に、拡張プロセス変数値のためのプロセスに対し、空である場合（パススタイルパラメータ）「=」を省略する「？」値が空である場合（フォームスタイルパラメータ）「=」を省略しないであろう。オペレータのための事前に定義された接合機構が存在しない場合には、複数の変数やリストの値が「」その値はで参加しています。 「+」や「＃」演算子は、変数の値の中に発見エンコードされていない予約文字を代用します。他の演算子は、拡張前の変数の値に見られるPCTエンコード予約文字であろう。"
    },
    {
      "indent": 3,
      "text": "The most common cases for URI spaces can be described with Level 1 template expressions. If we were only concerned with URI generation, then the template syntax could be limited to just simple variable expansion, since more complex forms could be generated by changing the variable values. However, URI Templates have the additional goal of describing the layout of identifiers in terms of preexisting data values. Therefore, the template syntax includes operators that reflect how resource identifiers are commonly allocated. Likewise, since prefix substrings are often used to partition large spaces of resources, modifiers on variable values provide a way to specify both the substring and the full value string with a single variable name.",
      "ja": "URIのスペースのための最も一般的な例は、レベル1のテンプレート式を記述することができます。我々は唯一のURI生成に関与していた場合、より複雑な形式は、変数の値を変更することで生成される可能性があるので、その後、テンプレートの構文は、単純な変数の展開に限定することができます。しかし、URIテンプレートは、データ値を既存の面で識別子のレイアウトを記述する追加の目標を持っています。そのため、テンプレートの構文は、リソース識別子は、一般的に割り当てられているかを反映演算子を含んでいます。接頭サブストリングは、多くの場合、リソースの大空間を分割するために使用されているので、同様に、変数値の修飾子は、サブストリングや単一の変数名を持つ完全な値文字列の両方を指定する方法を提供します。"
    },
    {
      "indent": 0,
      "text": "1.4. Limitations",
      "section_title": true,
      "ja": "1.4. 制限事項"
    },
    {
      "indent": 3,
      "text": "Since a URI Template describes a superset of the identifiers, there is no implication that every possible expansion for each delimited variable expression corresponds to a URI of an existing resource. Our expectation is that an application constructing URIs according to the template will be provided with an appropriate set of values for the variables being substituted, or at least a means of validating user data-entry for those values.",
      "ja": "URIテンプレート識別子のスーパーセットを記述しているので、各区切り変数発現のためのすべての可能な拡張は、既存のリソースのURIに対応することは意味がありません。我々の期待はテンプレートに従ってURIを構築するアプリケーションは置換されている変数の値の適切なセット、またはそれらの値のためのユーザデータエントリを検証する少なくとも手段が提供されることです。"
    },
    {
      "indent": 3,
      "text": "URI Templates are not URIs: they do not identify an abstract or physical resource, they are not parsed as URIs, and they should not be used in places where a URI would be expected unless the template expressions will be expanded by a template processor prior to use. Distinct field, element, or attribute names should be used to differentiate protocol elements that carry a URI Template from those that expect a URI reference.",
      "ja": "URIテンプレートはURIのではありません。彼らは、彼らがするURIとして解析されていない、抽象的または物理的リソースを識別していない、とテンプレート式の前にテンプレートエンジンによって展開されますしない限り、彼らはURIが予想される場所で使用すべきではありませんつかいます。異なるフィールド、要素、または属性名は、URI参照を期待するものからURIテンプレートを運ぶプロトコル要素を区別するために使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Some URI Templates can be used in reverse for the purpose of variable matching: comparing the template to a fully formed URI in order to extract the variable parts from that URI and assign them to the named variables. Variable matching only works well if the template expressions are delimited by the beginning or end of the URI or by characters that cannot be part of the expansion, such as reserved characters surrounding a simple string expression. In general, regular expression languages are better suited for variable matching.",
      "ja": "いくつかのURIテンプレートは、可変整合の目的のために逆に使用することができる：そのURIから可変部を抽出し、名前付き変数に割り当てるために、完全に形成されたURIにテンプレートとを比較します。テンプレート式は、URIの先頭や末尾、あるいは、そのような単純な文字列表現を取り巻く予約文字などの拡張の一部にすることはできません文字で区切られている場合、変数のマッチングにのみ適しています。一般的には、正規表現言語は、可変整合のために適しています。"
    },
    {
      "indent": 0,
      "text": "1.5. Notational Conventions",
      "section_title": true,
      "ja": "1.5. 表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234]. The following ABNF rules are imported from the normative references [RFC5234], [RFC3986], and [RFC3987].",
      "ja": "この仕様は、[RFC5234]の増補バッカス - ナウアフォーム（ABNF）の表記を使用します。以下のABNF規則は、引用規格[RFC5234]、[RFC3986]及び[RFC3987]からインポートされています。"
    },
    {
      "indent": 5,
      "text": "ALPHA = %x41-5A / %x61-7A ; A-Z / a-z DIGIT = %x30-39 ; 0-9 HEXDIG = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\" ; case-insensitive",
      "ja": "ALPHA =％x41-5A /％x61-7A。 -Z / Z-DIGIT =％x30-39。 0-9 HEXDIG = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"。大文字小文字を区別しません"
    },
    {
      "indent": 5,
      "text": "pct-encoded = \"%\" HEXDIG HEXDIG unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\" reserved = gen-delims / sub-delims gen-delims = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\" sub-delims = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"",
      "ja": "PCTエンコード= \"％\" HEXDIG HEXDIG無遠慮= ALPHA / DIGIT / \" - \" / \"\" / \"_\" / \"〜\" = GEN-delims /サブdelims GEN-delims予約= \"：\" / \"/\" / \"？\" / \"＃\" / \"[\" / \"]\" /サブdelims = \"@\" \"！\" / \"$\" / \"＆\" / \"'\" / \"（\" / \"）\" / \"*\" / \"+\" / \"、\" / \";\" / \"=\""
    },
    {
      "indent": 5,
      "text": "ucschar = %xA0-D7FF / %xF900-FDCF / %xFDF0-FFEF / %x10000-1FFFD / %x20000-2FFFD / %x30000-3FFFD / %x40000-4FFFD / %x50000-5FFFD / %x60000-6FFFD / %x70000-7FFFD / %x80000-8FFFD / %x90000-9FFFD / %xA0000-AFFFD / %xB0000-BFFFD / %xC0000-CFFFD / %xD0000-DFFFD / %xE1000-EFFFD",
      "ja": "ucschar =％XA0-D7FF /％xF900-FDCF /％xFDF0-FFEF /％x10000-1FFFD /％x20000-2FFFD /％x30000-3FFFD /％x40000-4FFFD /％x50000-5FFFD /％x60000-6FFFD /％x70000- 7FFFD /％x80000-8FFFD /％x90000-9FFFD /％xA0000-AFFFD /％xB0000-BFFFD /％xC0000-CFFFD /％xD0000-DFFFD /％xE1000-EFFFD"
    },
    {
      "indent": 5,
      "text": "iprivate = %xE000-F8FF / %xF0000-FFFFD / %x100000-10FFFD",
      "ja": "iprivate =％xE000-F8FF /％xF0000-FFFFD /％x100000-10FFFD"
    },
    {
      "indent": 0,
      "text": "1.6. Character Encoding and Unicode Normalization",
      "section_title": true,
      "ja": "1.6. 文字エンコーディングとUnicode正規化"
    },
    {
      "indent": 3,
      "text": "This specification uses the terms \"character\", \"character encoding scheme\", \"code point\", \"coded character set\", \"glyph\", \"non-ASCII\", \"normalization\", \"protocol element\", and \"regular expression\" as they are defined in [RFC6365].",
      "ja": "本明細書では、用語「文字」「文字符号化方式」、「符号点」、「コード化文字セット」、「グリフ」、「非ASCII」、「正規化」、「プロトコル要素」、および「正規表現」を使用しますそれらは[RFC6365]で定義された通りです。"
    },
    {
      "indent": 3,
      "text": "The ABNF notation defines its terminal values to be non-negative integers (code points) that are a superset of the US-ASCII coded character set [ASCII]. This specification defines terminal values as code points within the Unicode coded character set [UNIV6].",
      "ja": "ABNF表記は[ASCII]セットUS-ASCII符号化文字のスーパーセットである非負整数（コードポイント）とその端子の値を定義します。この仕様は[UNIV6]セットユニコード符号化された文字内のコードポイントとして端末値を定義します。"
    },
    {
      "indent": 3,
      "text": "In spite of the syntax and template expansion process being defined in terms of Unicode code points, it should be understood that templates occur in practice as a sequence of characters in whatever form or encoding is suitable for the context in which they occur, whether that be octets embedded in a network protocol element or glyphs painted on the side of a bus. This specification does not mandate any particular character encoding scheme for mapping between URI Template characters and the octets used to store or transmit those characters. When a URI Template appears in a protocol element, the character encoding scheme is defined by that protocol; without such a definition, a URI Template is assumed to be in the same character encoding scheme as the surrounding text. It is only during the process of template expansion that a string of characters in a URI Template is REQUIRED to be processed as a sequence of Unicode code points.",
      "ja": "Unicodeコードポイントによって定義される構文およびテンプレート伸長処理にもかかわらず、どのような形式または符号化における文字の配列はそれがあるかどうか、彼らが発生したコンテキストに適しているようにテンプレートが実際に起こることを理解すべきですバスの側面に描かれたネットワークプロトコル要素またはグリフに埋め込まれたオクテット。この仕様は、URIテンプレートの文字とその文字を格納または送信するために使用オクテットとの間のマッピングのための任意の特定の文字符号化方式を強制しません。 URIテンプレートは、プロトコル要素に表示されたら、文字符号化方式は、そのプロトコルによって定義されます。このような定義なしに、URIテンプレートは、周囲のテキストと同じ文字コード体系であると仮定されます。それだけURIテンプレートの文字列がUnicodeコードポイントのシーケンスとして処理する必要があるテンプレート膨張する過程です。"
    },
    {
      "indent": 3,
      "text": "The Unicode Standard [UNIV6] defines various equivalences between sequences of characters for various purposes. Unicode Standard Annex #15 [UTR15] defines various Normalization Forms for these equivalences. The normalization form determines how to consistently encode equivalent strings. In theory, all URI processing implementations, including template processors, should use the same normalization form for generating a URI reference. In practice, they do not. If a value has been provided by the same server as the resource, then it can be assumed that the string is already in the form expected by that server. If a value is provided by a user, such as via a data-entry dialog, then the string SHOULD be normalized as Normalization Form C (NFC: Canonical Decomposition, followed by Canonical Composition) prior to being used in expansions by a template processor.",
      "ja": "Unicode標準[UNIV6]は、様々な目的のために文字の配列の間の様々な等価性を定義します。 Unicode標準の附属書＃15 [UTR15]は、これらの等価のための様々な正規化形態を定義します。正規化形式は、一貫して同等の文字列を符号化する方法を決定します。理論的には、テンプレートプロセッサを含むすべてのURI処理の実装は、URI参照を生成するために同一の正規化形式を使用しなければなりません。実際には、そうではありません。値はリソースと同じサーバによって提供されている場合、文字列は、そのサーバによって期待される形態で既にあると仮定することができます。前テンプレートエンジンによって展開に使用されることに：値は、そのようなデータ入力ダイアログを介してのように、ユーザによって提供されている場合、文字列が正規化形式C（正規組成続い正規分解、NFC）のように正規化されるべきです。"
    },
    {
      "indent": 3,
      "text": "Likewise, when non-ASCII data that represents readable strings is pct-encoded for use in a URI reference, a template processor MUST first encode the string as UTF-8 [RFC3629] and then pct-encode any octets that are not allowed in a URI reference.",
      "ja": "読み取り可能な文字列を表す非ASCIIデータはPCTエンコードURI参照に使用するためのものである場合、同様に、テンプレートエンジンは、最初のUTF-8 [RFC3629]、次いでPCTエンコードすることはできません任意のオクテットとして文字列を符号化しなければなりませんURI参照。"
    },
    {
      "indent": 0,
      "text": "2. Syntax",
      "section_title": true,
      "ja": "2.構文"
    },
    {
      "indent": 3,
      "text": "A URI Template is a string of printable Unicode characters that contains zero or more embedded variable expressions, each expression being delimited by a matching pair of braces ('{', '}').",
      "ja": "URIテンプレートは、ゼロ個以上の埋込み変数式を含む印刷可能なUnicode文字の文字列、中括弧（「{」、「}」）のマッチングペアで区切られている各式です。"
    },
    {
      "indent": 5,
      "text": "URI-Template = *( literals / expression )",
      "ja": "URIテンプレート= *（リテラル/式）"
    },
    {
      "indent": 3,
      "text": "Although templates (and template processor implementations) are described above in terms of four gradual levels, we define the URI-Template syntax in terms of the ABNF for Level 4. A template processor limited to lower-level templates MAY exclude the ABNF rules applicable only to higher levels. However, it is RECOMMENDED that all parsers implement the full syntax such that unsupported levels can be properly identified as such to the end user.",
      "ja": "テンプレート（テンプレートプロセッサ実装は）は、4つの緩やかなレベルに関して上述されているが、我々は、レベル4のABNFの点で低レベルのテンプレートに限定されるものでテンプレートエンジンをURIテンプレート構文を定義ABNFのみ適用可能なルール除外することができますより高いレベルへ。しかし、すべてのパーサーがサポートされていないレベルが適切にエンドユーザーにそのように識別することができるように、完全な構文を実装することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "2.1. Literals",
      "section_title": true,
      "ja": "2.1. リテラル"
    },
    {
      "indent": 3,
      "text": "The characters outside of expressions in a URI Template string are intended to be copied literally to the URI reference if the character is allowed in a URI (reserved / unreserved / pct-encoded) or, if not allowed, copied to the URI reference as the sequence of pct-encoded triplets corresponding to that character's encoding in UTF-8 [RFC3629].",
      "ja": "文字はURIで許可された場合に外部URIテンプレート文字列内の式の文字はURI参照を文字通りコピーされることが意図されている（予約/予約されていない/ PCT-コードされる）、または許可されていない場合に、、としてURI参照にコピーUTF-8でその文字の符号化に対応するPCTエンコードトリプレットの配列[RFC3629]。"
    },
    {
      "indent": 5,
      "text": "literals = %x21 / %x23-24 / %x26 / %x28-3B / %x3D / %x3F-5B / %x5D / %x5F / %x61-7A / %x7E / ucschar / iprivate / pct-encoded ; any Unicode character except: CTL, SP, ; DQUOTE, \"'\", \"%\" (aside from pct-encoded), ; \"<\", \">\", \"\\\", \"^\", \"`\", \"{\", \"|\", \"}\"",
      "ja": "リテラル=％X21 /％x23-24 /％X26 /％x28-3B /％X3D /％からx3F-5B /％x5D /％x5F /％x61-7A /％x7E / ucschar / iprivate / PCTエンコード。除く任意のUnicode文字：CTL、SP、。 DQUOTE、 \"'\"、 \"％\"（脇PCTエンコードから）。 \"<\"、 \">\"、 \"\\\"、 \"^\"、 \"`\"、 \"{\"、 \"|\"、 \"}\""
    },
    {
      "indent": 0,
      "text": "2.2. Expressions",
      "section_title": true,
      "ja": "2.2. 式"
    },
    {
      "indent": 3,
      "text": "Template expressions are the parameterized parts of a URI Template. Each expression contains an optional operator, which defines the expression type and its corresponding expansion process, followed by a comma-separated list of variable specifiers (variable names and optional value modifiers). If no operator is provided, the expression defaults to simple variable expansion of unreserved values.",
      "ja": "テンプレート式はURIテンプレートのパラメータ化の部分です。各式は、変数指定子（変数名と任意の値改質剤）のカンマ区切りリストが続く表現型とそれに対応する展開処理を定義する任意のオペレーターを含んでいます。いかなるオペレータは、予約されていない値の単純な可変膨張式のデフォルト値を提供されない場合。"
    },
    {
      "indent": 5,
      "text": "expression = \"{\" [ operator ] variable-list \"}\" operator = op-level2 / op-level3 / op-reserve op-level2 = \"+\" / \"#\" op-level3 = \".\" / \"/\" / \";\" / \"?\" / \"&\" op-reserve = \"=\" / \",\" / \"!\" / \"@\" / \"|\"",
      "ja": "式= \"{\" [オペレータ]可変リスト \"}\" 演算子=オンLEVEL2 / LEVEL3オン/オンリザーブオンLEVEL2 = \"+\" / \"＃\" オンLEVEL3 = \"\" / \"/\" / \";\" / \"？\" / \"＆\" オンリザーブ= \"=\" / \"\" / \"！\" / \"@\" / \"|\""
    },
    {
      "indent": 3,
      "text": "The operator characters have been chosen to reflect each of their roles as reserved characters in the URI generic syntax. The operators defined in Section 3 of this specification include:",
      "ja": "オペレータの文字は、URI一般的な構文での予約文字としての役割のそれぞれを反映するように選択されています。この仕様のセクション3で定義された事業者は、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "+ Reserved character strings;",
      "ja": "+予約済みの文字列。"
    },
    {
      "indent": 6,
      "text": "# Fragment identifiers prefixed by \"#\";",
      "ja": "＃フラグメント識別子は「＃」で始まります。"
    },
    {
      "indent": 6,
      "text": ". Name labels or extensions prefixed by \".\";",
      "ja": "。前置ラベルや拡張子に名前を付けて「」;"
    },
    {
      "indent": 6,
      "text": "/ Path segments prefixed by \"/\";",
      "ja": "「/」で始まる/パスセグメント。"
    },
    {
      "indent": 6,
      "text": "; Path parameter name or name=value pairs prefixed by \";\";",
      "ja": "; Pathパラメータの名前または名前=値のペアは、接頭辞「;」;"
    },
    {
      "indent": 6,
      "text": "? Query component beginning with \"?\" and consisting of name=value pairs separated by \"&\"; and,",
      "ja": "？で始まるクエリコンポーネント「？」及び「＆」で区切られた名前=値のペアからなります。そして、"
    },
    {
      "indent": 6,
      "text": "& Continuation of query-style &name=value pairs within a literal query component.",
      "ja": "リテラルのクエリコンポーネント内のクエリスタイル＆名前=値のペアの＆継続。"
    },
    {
      "indent": 3,
      "text": "The operator characters equals (\"=\"), comma (\",\"), exclamation (\"!\"), at sign (\"@\"), and pipe (\"|\") are reserved for future extensions.",
      "ja": "オペレータの文字、（ \"=\"）、カンマ（ \" \"）に等しい感嘆符（\"！ \"）、記号（\" @ \"）で、パイプ（\" |\"）は、将来の拡張のために予約されています。"
    },
    {
      "indent": 3,
      "text": "The expression syntax specifically excludes use of the dollar (\"$\") and parentheses [\"(\" and \")\"] characters so that they remain available for use outside the scope of this specification. For example, a macro language might use these characters to apply macro substitution to a string prior to that string being processed as a URI Template.",
      "ja": "彼らはこの仕様の範囲外での使用のために利用できる残るように表現の構文は、特にドル（「$」）と括弧[「（」と「）」]文字の使用を排除します。例えば、マクロ言語は、その文字列の前には、URIテンプレートとして処理されている文字列にマクロ置換を適用するためにこれらの文字を使用する場合があります。"
    },
    {
      "indent": 0,
      "text": "2.3. Variables",
      "section_title": true,
      "ja": "2.3. 変数"
    },
    {
      "indent": 3,
      "text": "After the operator (if any), each expression contains a list of one or more comma-separated variable specifiers (varspec). The variable names serve multiple purposes: documentation for what kinds of values are expected, identifiers for associating values within a template processor, and the literal string to use for the name in name=value expansions (aside from when exploding an associative array). Variable names are case-sensitive because the name might be expanded within a case-sensitive URI component.",
      "ja": "オペレータ（もしあれば）の後、各表現は、一つ以上のカンマ区切り変数指定子（varspec）のリストを含みます。 （脇連想配列を爆発してから）の値のどんな種類のを期待されている文書、テンプレートエンジン内の値を関連付けるための識別子、名前内の名前に使用するリテラル文字列=値の拡張：変数名は複数の目的を果たします。名前は大文字と小文字を区別URIコンポーネント内で拡張される可能性がありますので、変数名は大文字と小文字が区別されます。"
    },
    {
      "indent": 5,
      "text": "variable-list = varspec *( \",\" varspec ) varspec = varname [ modifier-level4 ] varname = varchar *( [\".\"] varchar ) varchar = ALPHA / DIGIT / \"_\" / pct-encoded",
      "ja": "可変リスト= varspec *（ \"\" varspec）varspec = VARNAME [修飾子-LEVEL4] VARNAME = VARCHAR×（[ \"\"] VARCHAR）VARCHAR = ALPHA / DIGIT / \"_\" / PCT-符号化"
    },
    {
      "indent": 3,
      "text": "A varname MAY contain one or more pct-encoded triplets. These triplets are considered an essential part of the variable name and are not decoded during processing. A varname containing pct-encoded characters is not the same variable as a varname with those same characters decoded. Applications that provide URI Templates are expected to be consistent in their use of pct-encoding within variable names.",
      "ja": "VARNAMEは、一つ以上のpctでエンコードされたトリプレットを含むかもしれません。これらのトリプレットは、変数名の不可欠な一部とみなされ、処理中にデコードされていません。 PCT-エンコードされた文字を含むVARNAMEは、復号、同じ文字でVARNAME同じ変数ではありません。 URIテンプレートを提供するアプリケーションは、変数名内のPCT-エンコーディングの利用で一貫性があると予想されます。"
    },
    {
      "indent": 3,
      "text": "An expression MAY reference variables that are unknown to the template processor or whose value is set to a special \"undefined\" value, such as undef or null. Such undefined variables are given special treatment by the expansion process (Section 3.2.1).",
      "ja": "式は、その値などはundefまたはnullとして、特別な「未定義」の値に設定されているテンプレートエンジンまたはに知られていない変数を参照することがあります。そのような未定義の変数は、拡張プロセス（3.2.1節）によって特別な処理が与えられます。"
    },
    {
      "indent": 3,
      "text": "A variable value that is a string of length zero is not considered undefined; it has the defined value of an empty string.",
      "ja": "長さゼロの文字列である変数値が不定とは見なされません。それは、空の文字列の定義された値を持っています。"
    },
    {
      "indent": 3,
      "text": "In Level 4 templates, a variable may have a composite value in the form of a list of values or an associative array of (name, value) pairs. Such value types are not directly indicated by the template syntax, but they do have an impact on the expansion process (Section 3.2.1).",
      "ja": "レベル4テンプレートで、変数は、値のリストまたは（名前、値）ペアの連想配列の形で合成値を有していてもよいです。このような値の型は、直接テンプレート構文で示されていないが、彼らは拡張プロセス（3.2.1）に影響を与えません。"
    },
    {
      "indent": 3,
      "text": "A variable defined as a list value is considered undefined if the list contains zero members. A variable defined as an associative array of (name, value) pairs is considered undefined if the array contains zero members or if all member names in the array are associated with undefined values.",
      "ja": "リストはゼロメンバーが含まれている場合、リストの値として定義された変数が未定義であると考えられます。アレイはゼロメンバーが含まれている場合、またはアレイ内のすべてのメンバ名が未定義の値に関連付けられている場合（名前、値）ペアの連想配列として定義された変数が未定義であると考えられます。"
    },
    {
      "indent": 0,
      "text": "2.4. Value Modifiers",
      "section_title": true,
      "ja": "2.4. バリュー修飾子"
    },
    {
      "indent": 3,
      "text": "Each of the variables in a Level 4 template expression can have a modifier indicating either that its expansion is limited to a prefix of the variable's value string or that its expansion is exploded as a composite value in the form of a value list or an associative array of (name, value) pairs.",
      "ja": "レベル4テンプレート式の変数のそれぞれが示す修飾子を持つことができるいずれかの膨張は、変数の値文字列のプレフィックスに又はその膨張は値リストの形で複合値または連想配列のように分解されることを制限されること（名前、値）のペアの。"
    },
    {
      "indent": 5,
      "text": "modifier-level4 = prefix / explode",
      "ja": "修飾子-LEVEL4 =接頭辞/爆発"
    },
    {
      "indent": 0,
      "text": "2.4.1. Prefix Values",
      "section_title": true,
      "ja": "2.4.1. プレフィックス値"
    },
    {
      "indent": 3,
      "text": "A prefix modifier indicates that the variable expansion is limited to a prefix of the variable's value string. Prefix modifiers are often used to partition an identifier space hierarchically, as is common in reference indices and hash-based storage. It also serves to limit the expanded value to a maximum number of characters. Prefix modifiers are not applicable to variables that have composite values.",
      "ja": "接頭修飾子は変数展開は、変数の値の文字列の接頭辞に限定されていることを示しています。参照インデックスとハッシュベースのストレージでは一般的であるように接頭改質剤は、しばしば、階層識別子空間を分割するために使用されます。また、文字の最大数まで拡張値を制限するように働きます。プレフィックス修飾子は、複合値を持つ変数には適用されません。"
    },
    {
      "indent": 5,
      "text": "prefix = \":\" max-length max-length = %x31-39 0*3DIGIT ; positive integer < 10000",
      "ja": "接頭辞=「：」最大長の最大長=％x31-39 0 * 3DIGIT。正の整数<10000"
    },
    {
      "indent": 3,
      "text": "The max-length is a positive integer that refers to a maximum number of characters from the beginning of the variable's value as a Unicode string. Note that this numbering is in characters, not octets, in order to avoid splitting between the octets of a multi-octet-encoded character or within a pct-encoded triplet. If the max-length is greater than the length of the variable's value, then the entire value string is used.",
      "ja": "最大長は、Unicode文字列として変数の値の先頭から文字の最大数を意味する正の整数です。この番号は、マルチオクテット符号化された文字のオク​​テット間又はPCTエンコードトリプレット内の分割を回避するために、文字ではなくオクテットであることに留意されたいです。最大長は、変数の値の長さよりも大きい場合には、全体値の文字列が使用されています。"
    },
    {
      "indent": 3,
      "text": "For example,",
      "ja": "例えば、"
    },
    {
      "indent": 5,
      "text": "Given the variable assignments",
      "ja": "変数の割り当てを考えます"
    },
    {
      "indent": 7,
      "text": "var := \"value\" semi := \";\"",
      "ja": "であった：= \"値\" 半：= \";\""
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "例テンプレート展開"
    },
    {
      "indent": 7,
      "text": "{var} value {var:20} value {var:3} val {semi} %3B {semi:2} %3B",
      "ja": "{} Varの値{あった：20}の値{た：3}ヴァル{半}％3B {半2}％3B"
    },
    {
      "indent": 0,
      "text": "2.4.2. Composite Values",
      "section_title": true,
      "ja": "2.4.2. コンポジット値"
    },
    {
      "indent": 3,
      "text": "An explode (\"*\") modifier indicates that the variable is to be treated as a composite value consisting of either a list of values or an associative array of (name, value) pairs. Hence, the expansion process is applied to each member of the composite as if it were listed as a separate variable. This kind of variable specification is significantly less self-documenting than non-exploded variables, since there is less correspondence between the variable name and how the URI reference appears after expansion.",
      "ja": "爆発（「*」）修飾子は、変数が値のリストまたは（名前、値）ペアの連想配列のいずれかからなる複合値として扱われるべきであることを示しています。それは別の変数としてリストされていたかのようしたがって、拡張プロセスは、複合体の各メンバーに適用されます。変数名とどのようにURI参照が拡張後に表示されるとの少ない対応があるので、変数指定のこの種は、非爆発変数よりも大幅に少ない自己文書です。"
    },
    {
      "indent": 5,
      "text": "explode = \"*\"",
      "ja": "爆発= \"*\""
    },
    {
      "indent": 3,
      "text": "Since URI Templates do not contain an indication of type or schema, the type for an exploded variable is assumed to be determined by context. For example, the processor might be supplied values in a form that differentiates values as strings, lists, or associative arrays. Likewise, the context in which the template is used (script, mark-up language, Interface Definition Language, etc.) might define rules for associating variable names with types, structures, or schema.",
      "ja": "URIテンプレートタイプまたはスキーマの表示を含んでいないため、分解変数の型は文脈によって決定されるものとします。例えば、プロセッサは、文字列、リスト、または連想配列のような値を微分形式で値を供給するかもしれません。同様に、テンプレートが使用される文脈は（スクリプトは、マークアップ言語、インタフェース定義言語など）の種類、構造、またはスキーマで変数名を関連付けるためのルールを定義することができます。"
    },
    {
      "indent": 3,
      "text": "Explode modifiers improve brevity in the URI Template syntax. For example, a resource that provides a geographic map for a given street address might accept a hundred permutations on fields for address input, including partial addresses (e.g., just the city or postal code). Such a resource could be described as a template with each and every address component listed in order, or with a far more simple template that makes use of an explode modifier, as in",
      "ja": "修飾子は、URIテンプレート構文で簡潔性を向上爆発。例えば、所与の住所のための地理的マップを提供するリソースは、部分アドレスを含むアドレス入力用フィールドの百置換、（例えば、単に都市または郵便番号）を受け入れるかもしれません。そのようなリソースは、同様に、順番に、または爆発改質を利用するはるかに簡単なテンプレートにリストされた各およびすべてのアドレス成分とテンプレートとして記述することができ"
    },
    {
      "indent": 6,
      "text": "/mapper{?address*}",
      "ja": "/マッパー{？アドレス*}"
    },
    {
      "indent": 3,
      "text": "along with some context that defines what the variable named \"address\" can include, such as by reference to some other standard for addressing (e.g., [UPU-S42]). A recipient aware of the schema can then provide appropriate expansions, such as:",
      "ja": "「アドレス」という名前の変数は、（例えば、[UPU-S42]）をアドレス指定するためのいくつかの他の標準を参照することによってように、含むことができるかを定義し、いくつかのコンテキストと一緒。スキーマの認識受取人は、その後のような適切な拡張を提供することができます。"
    },
    {
      "indent": 6,
      "text": "/mapper?city=Newport%20Beach&state=CA",
      "ja": "/マッパー？市=のニューポート％20Beach＆状態= CA"
    },
    {
      "indent": 3,
      "text": "The expansion process for exploded variables is dependent on both the operator being used and whether the composite value is to be treated as a list of values or as an associative array of (name, value) pairs. Structures are processed as if they are an associative array with names corresponding to the fields in the structure definition and \".\" separators used to indicate name hierarchy in substructures.",
      "ja": "分解変数の拡張プロセスが使用されているオペレータの両方に複合値は、値のリストとして、または（名前、値）ペアの連想配列として扱われるべきであるかどうかに依存します。彼らは構造体定義内のフィールドに対応する名前を持つ連想配列であるかのような構造が処理され、「」セパレータは、基礎構造で名前の階層を示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "If a variable has a composite structure and only some of the fields in that structure have defined values, then only the defined pairs are present in the expansion. This can be useful for templates that consist of a large number of potential query terms.",
      "ja": "変数は、複合構造体のみ、その構造内のフィールドのいくつかが定義された値を有する場合、唯一定義ペアは、膨張中に存在します。これは、潜在的なクエリ用語の多数で構成されたテンプレートに役立ちます。"
    },
    {
      "indent": 3,
      "text": "An explode modifier applied to a list variable causes the expansion to iterate over the list's member values. For path and query parameter expansions, each member value is paired with the variable's name as a (varname, value) pair. This allows path and query parameters to be repeated for multiple values, as in",
      "ja": "リスト変数に適用される爆発修飾子は、リストのメンバー値を反復するために膨張します。パスおよびクエリーパラメータ展開のために、各メンバーの値が（VARNAME、値）ペアとして変数名と対になっています。これは同様に、パスおよびクエリーパラメータが複数の値に対して繰り返されることを可能にします"
    },
    {
      "indent": 5,
      "text": "Given the variable assignments",
      "ja": "変数の割り当てを考えます"
    },
    {
      "indent": 7,
      "text": "year := (\"1965\", \"2000\", \"2012\") dom := (\"example\", \"com\")",
      "ja": "年：=（ \"1965\"、 \"2000\"、 \"2012\"）の贈り物：=（ \"例\"、 \"と\"）"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "例テンプレート展開"
    },
    {
      "indent": 7,
      "text": "find{?year*} find?year=1965&year=2000&year=2012 www{.dom*} www.example.com",
      "ja": "見つける{*年？}見つける？年= 1965＆年= 2000＆年= 2012 WWW {.dom *} www.example.com"
    },
    {
      "indent": 0,
      "text": "3. Expansion",
      "section_title": true,
      "ja": "3.拡張"
    },
    {
      "indent": 3,
      "text": "The process of URI Template expansion is to scan the template string from beginning to end, copying literal characters and replacing each expression with the result of applying the expression's operator to the value of each variable named in the expression. Each variable's value MUST be formed prior to template expansion.",
      "ja": "URIテンプレートの展開のプロセスは、最後に始まるリテラル文字をコピーし、式の中で指定された各変数の値に式の演算子を適用した結果と各式を置き換えるからテンプレート文字列をスキャンすることです。各変数の値は、前にテンプレート展開に形成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The requirements on expansion for each aspect of the URI Template grammar are defined in this section. A non-normative algorithm for the expansion process as a whole is provided in Appendix A.",
      "ja": "URIテンプレート文法の各局面の展開上の要件は、このセクションで定義されています。全体として膨張処理用非規範的アルゴリズムは、付録Aに設けられています"
    },
    {
      "indent": 3,
      "text": "If a template processor encounters a character sequence outside an expression that does not match the <URI-Template> grammar, then processing of the template SHOULD cease, the URI reference result SHOULD contain the expanded part of the template followed by the remainder unexpanded, and the location and type of error SHOULD be indicated to the invoking application.",
      "ja": "テンプレートエンジンは、<URIテンプレート>文法に一致しない表現外の文字列を検出した場合、テンプレートの処理は中止すべきである、URI参照結果は余り続いてテンプレートの拡大部分は未膨張含み、SHOULDエラーの位置と種類は、呼び出し側アプリケーションに通知されるべきです。"
    },
    {
      "indent": 3,
      "text": "If an error is encountered in an expression, such as an operator or value modifier that the template processor does not recognize or does not yet support, or a character is found that is not allowed by the <expression> grammar, then the unprocessed parts of the expression SHOULD be copied to the result unexpanded, processing of the remainder of the template SHOULD continue, and the location and type of error SHOULD be indicated to the invoking application.",
      "ja": "エラーは、テンプレートエンジンが認識しない、またはサポート、または文字まだはそれが<式>によって許可されていない発見されないオペレータまたは値改質剤として、式に遭遇した場合、文法は、未処理の部品の発現は、テンプレートの残りの処理を継続すべき、結果非拡張にコピーする必要があり、位置及びエラーの種類は、呼び出し側アプリケーションに通知されるべきです。"
    },
    {
      "indent": 3,
      "text": "If an error occurs, the result returned might not be a valid URI reference; it will be an incompletely expanded template string that is only intended for diagnostic use.",
      "ja": "エラーが発生した場合は、返される結果は、有効なURI参照ではないかもしれません。それだけで、診断の使用を意図している不完全拡大テンプレート文字列になります。"
    },
    {
      "indent": 0,
      "text": "3.1. Literal Expansion",
      "section_title": true,
      "ja": "3.1. リテラル拡大"
    },
    {
      "indent": 3,
      "text": "If the literal character is allowed anywhere in the URI syntax (unreserved / reserved / pct-encoded ), then it is copied directly to the result string. Otherwise, the pct-encoded equivalent of the literal character is copied to the result string by first encoding the character as its sequence of octets in UTF-8 and then encoding each such octet as a pct-encoded triplet.",
      "ja": "リテラル文字はURI構文（予約されていない/予約/ PCT-エンコード）のどこにでも許可されている場合、それは結果文字列に直接コピーされます。そうでなければ、リテラル文字のPCTエンコード等価まずUTF-8のオクテットのその配列として文字をコードし、次いでPCTエンコードトリプレットとして、このような各オクテットを符号化して結果の文字列にコピーされます。"
    },
    {
      "indent": 0,
      "text": "3.2. Expression Expansion",
      "section_title": true,
      "ja": "3.2. 式の展開"
    },
    {
      "indent": 3,
      "text": "Each expression is indicated by an opening brace (\"{\") character and continues until the next closing brace (\"}\"). Expressions cannot be nested.",
      "ja": "各式は、開口ブレース（「{」）文字と次の閉じ括弧（まで続く「}」）で示されています。式は入れ子にすることはできません。"
    },
    {
      "indent": 3,
      "text": "An expression is expanded by determining its expression type and then following that type's expansion process for each comma-separated varspec in the expression. Level 1 templates are limited to the default operator (simple string value expansion) and a single variable per expression. Level 2 templates are limited to a single varspec per expression.",
      "ja": "表現は、その表現型を決定した後、式中の各コンマ区切りvarspecため、そのタイプの拡張プロセスに従うことによって拡張されます。レベル1のテンプレートは、デフォルトの演算子（単純な文字列値の拡張）と表現ごとに単一の変数に限定されています。レベル2のテンプレートは、式ごとに単一のvarspecに限定されています。"
    },
    {
      "indent": 3,
      "text": "The expression type is determined by looking at the first character after the opening brace. If the character is an operator, then remember the expression type associated with that operator for later expansion decisions and skip to the next character for the variable-list. If the first character is not an operator, then the expression type is simple string expansion and the first character is the beginning of the variable-list.",
      "ja": "表現型は、開口部ブレースの後の最初の文字を見ることによって決定されます。文字が演算子であれば、その後の拡張の意思決定のためにそのオペレータに関連した表現型を覚えて、変数リストのための次の文字に進みます。最初の文字が演算子でない場合は、式の型は、単純な文字列の拡張であり、最初の文字は、変数リストの始まりです。"
    },
    {
      "indent": 3,
      "text": "The examples in the subsections below use the following definitions for variable values:",
      "ja": "以下のサブセクションの例では、変数の値のために以下の定義を使用します。"
    },
    {
      "indent": 9,
      "text": "count := (\"one\", \"two\", \"three\")\ndom   := (\"example\", \"com\")\ndub   := \"me/too\"\nhello := \"Hello World!\"\nhalf  := \"50%\"\nvar   := \"value\"\nwho   := \"fred\"\nbase  := \"http://example.com/home/\"\npath  := \"/foo/bar\"\nlist  := (\"red\", \"green\", \"blue\")\nkeys  := [(\"semi\",\";\"),(\"dot\",\".\"),(\"comma\",\",\")]\nv     := \"6\"\nx     := \"1024\"\ny     := \"768\"\nempty := \"\"\nempty_keys  := []\nundef := null",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.1. Variable Expansion",
      "section_title": true,
      "ja": "3.2.1. 変数の展開"
    },
    {
      "indent": 3,
      "text": "A variable that is undefined (Section 2.3) has no value and is ignored by the expansion process. If all of the variables in an expression are undefined, then the expression's expansion is the empty string.",
      "ja": "（セクション2.3）定義されていない変数は値を持たない、拡張プロセスによって無視されます。式の中のすべての変数が定義されていない場合、式の展開は、空の文字列です。"
    },
    {
      "indent": 3,
      "text": "Variable expansion of a defined, non-empty value results in a substring of allowed URI characters. As described in Section 1.6, the expansion process is defined in terms of Unicode code points in order to ensure that non-ASCII characters are consistently pct-encoded in the resulting URI reference. One way for a template processor to obtain a consistent expansion is to transcode the value string to UTF-8 (if it is not already in UTF-8) and then transform each octet that is not in the allowed set into the corresponding pct-encoded triplet. Another is to map directly from the value's native character encoding to the set of allowed URI characters, with any remaining disallowed characters mapping to the sequence of pct-encoded triplets that correspond to the octet(s) of that character when encoded as UTF-8 [RFC3629].",
      "ja": "許容URI文字のストリングで定義され、空でない値の結果の可変膨張。 1.6節で説明したように、膨張処理は、非ASCII文字が得られたURIリファレンスに一貫PCTエンコードされることを保証するために、Unicodeコードポイントに関して定義されます。一貫性のある拡張を取得するテンプレートエンジンのための一つの方法は、（それがUTF-8になっていない場合）、UTF-8に値列をトランスコードした後、対応するPCT-符号化に許可セットにない各オクテットを変換することですトリプレット。別のは、UTF-8でエンコードされたときにその文字のオク​​テット（S）に対応するPCTエンコードトリプレットの配列に任意の残りの禁止文字のマッピングと、許可されたURI文字のセットに値のネイティブ文字エンコーディングから直接マッピングすることです[RFC3629]。"
    },
    {
      "indent": 3,
      "text": "The allowed set for a given expansion depends on the expression type: reserved (\"+\") and fragment (\"#\") expansions allow the set of characters in the union of ( unreserved / reserved / pct-encoded ) to be passed through without pct-encoding, whereas all other expression types allow only unreserved characters to be passed through without pct-encoding. Note that the percent character (\"%\") is only allowed as part of a pct-encoded triplet and only for reserved/fragment expansion: in all other cases, a value character of \"%\" MUST be pct-encoded as \"%25\" by variable expansion.",
      "ja": "所与の拡張の許可セットは、発現のタイプに依存：予約済み（「+」）および断片（「＃」）拡張は、組合内の文字の集合を可能にする（未予約/予約/ PCTエンコード）することなく通過しますPCT-符号化、他のすべての表現型は、非予約文字はPCT-符号化することなく通過することを可能にする一方。パーセント文字（「％」）が唯一PCTエンコードトリプレットの一部としてのみ予約/断片拡張のために許可されていることに注意してください。他の全ての場合において、「％」の数値文字は25％」と、PCT-符号化されなければなりません「変数の展開によって。"
    },
    {
      "indent": 3,
      "text": "If a variable appears more than once in an expression or within multiple expressions of a URI Template, the value of that variable MUST remain static throughout the expansion process (i.e., the variable must have the same value for the purpose of calculating each expansion). However, if reserved characters or pct-encoded triplets occur in the value, they will be pct-encoded by some expression types and not by others.",
      "ja": "変数は式またはURIテンプレートの複数の式の中で複数回表示された場合、その変数の値は、拡張プロセス（すなわち、変数がそれぞれ膨張を計算する目的のために同じ値を有していなければならない）を通して静的のままでなければなりません。予約文字またはPCT-エンコードされたトリプレットの価値が発生した場合しかし、彼らはいくつかの式の種類によってではなく他者による-PCTエンコードされます。"
    },
    {
      "indent": 3,
      "text": "For a variable that is a simple string value, expansion consists of appending the encoded value to the result string. An explode modifier has no effect. A prefix modifier limits the expansion to the first max-length characters of the decoded value. If the value contains multi-octet or pct-encoded characters, care must be taken to avoid splitting the value in mid-character: count each Unicode code point as one character.",
      "ja": "単純な文字列値である変数の場合、拡張は、結果文字列に符号化された値を追加で構成されています。爆発修飾子は効果がありません。接頭改質剤は、復号値の最初の最大長さの文字に拡張を制限します。値は、マルチオクテットまたはPCT-エンコードされた文字が含まれている場合は、注意が半ば文字で値を分割しないように注意する必要があります：1つの文字として各Unicodeコードポイントをカウントします。"
    },
    {
      "indent": 3,
      "text": "For a variable that is an associative array, expansion depends on both the expression type and the presence of an explode modifier. If there is no explode modifier, expansion consists of appending a comma-separated concatenation of each (name, value) pair that has a defined value. If there is an explode modifier, expansion consists of appending each pair that has a defined value as either \"name=value\" or, if the value is the empty string and the expression type does not indicate form-style parameters (i.e., not a \"?\" or \"&\" type), simply \"name\". Both name and value strings are encoded in the same way as simple string values. A separator string is appended between defined pairs according to the expression type, as defined by the following table:",
      "ja": "連想配列である変数の場合、膨張式のタイプと爆発改質剤の存在下の両方に依存します。何剤を爆発がない場合、拡張は、定義された値を持つ各（名前、値）ペアのカンマで区切られた連結を付加から成ります。爆発修飾子が存在する場合、膨張は、「名前=値」または、値が空の文字列である場合、フォーム形式のパラメータを（示していない表現型のいずれかとして定義された値を有する各対を追加で構成され、すなわち、ではありません\"？\" や \"＆\" タイプ）、単に \"名前\"。どちらの名前と値の文字列は、単純な文字列の値と同じ方法でエンコードされています。次の表によって定義されるように、セパレータ文字列は、式の型に応じて定義された対の間に追加されます。"
    },
    {
      "indent": 6,
      "text": "Type Separator \",\" (default) + \",\" # \",\" . \".\" / \"/\" ; \";\" ? \"&\" & \"&\"",
      "ja": "セパレータ \"\"（デフォルト）+ \"\" ＃ \"を、\" 入力してください。 \"\" / \"/\"; \";\" ？ \"＆\" ＆ \"＆\""
    },
    {
      "indent": 3,
      "text": "For a variable that is a list of values, expansion depends on both the expression type and the presence of an explode modifier. If there is no explode modifier, the expansion consists of a comma-separated concatenation of the defined member string values. If there is an explode modifier and the expression type expands named parameters (\";\", \"?\", or \"&\"), then the list is expanded as if it were an associative array in which each member value is paired with the list's varname. Otherwise, the value will be expanded as if it were a list of separate variable values, each value separated by the expression type's associated separator as defined by the table above.",
      "ja": "値のリストである変数の場合、膨張式のタイプと爆発改質剤の存在下の両方に依存します。いかなる爆発修飾子が存在しない場合、拡張は、定義されたメンバー文字列値のカンマで区切られた連結から成ります。 （;「？」「」、または「＆」）は、各メンバーの値がリストのとペアにされた連想配列であるかのように、リストが展開されているパラメータの名前剤を爆発と表現型が膨張がある場合VARNAME。上記の表によって定義されるように、それは、表現型の関連セパレータで分離された各値を別々の変数の値のリストであるかのようにそれ以外の場合、値が拡大されます。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "例テンプレート展開"
    },
    {
      "indent": 7,
      "text": "{count} one,two,three {count*} one,two,three {/count} /one,two,three {/count*} /one/two/three {;count} ;count=one,two,three {;count*} ;count=one;count=two;count=three {?count} ?count=one,two,three {?count*} ?count=one&count=two&count=three {&count*} &count=one&count=two&count=three",
      "ja": "{;カウント}; / 3一つ、二つ、三つ{/カウント} /一つ、二つ、三つ{/ *カウント} {*カウント}、2個、一対一/ 2/3個{カウント}カウント=一、二、三{; *カウント}; = 1をカウントし、カウント= 2;カウント= 3カウント=一、二、三= = 1をカウント＆カウント= 2＆カウント= 3 {＆*カウント}＆カウント= 1＆カウント{カウント？}？{カウント*}？？ 2＆カウント= 3"
    },
    {
      "indent": 0,
      "text": "3.2.2. Simple String Expansion: {var}",
      "section_title": true,
      "ja": "3.2.2. 単純な文字列の拡張：{VAR}"
    },
    {
      "indent": 3,
      "text": "Simple string expansion is the default expression type when no operator is given.",
      "ja": "何のオペレータが指定されていないとき、単純な文字列の拡張は、デフォルト式タイプです。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list, perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the unreserved set. If more than one variable has a defined value, append a comma (\",\") to the result string as a separator between variable expansions.",
      "ja": "許容文字が予約されていない集合のものであると、3.2.1節で定義されるように、変数リスト内のそれぞれの定義された変数については、変数の展開を行います。複数の変数が定義された値を有する場合、変数展開の間のセパレータとして結果の文字列にカンマ（「」）追加。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "例テンプレート展開"
    },
    {
      "indent": 7,
      "text": "{var} value {hello} Hello%20World%21 {half} 50%25 O{empty}X OX O{undef}X OX {x,y} 1024,768 {x,hello,y} 1024,Hello%20World%21,768 ?{x,empty} ?1024, ?{x,undef} ?1024 ?{undef,y} ?768 {var:3} val {var:30} value {list} red,green,blue {list*} red,green,blue {keys} semi,%3B,dot,.,comma,%2C {keys*} semi=%3B,dot=.,comma=%2C",
      "ja": "{VAR}の値{こんにちは}ハロー％の20World％21 {半分} 50％25 O {空} X OX O {undefを} X OX {X、Y} 1024,768 {X、ハロー、Y} 1024ハロー％20World ％21768 {X、空} 1024 {X、undefを} 1024 {undefを、Y} 768 {VAR：3}？？？？？？ヴァル{VAR：30}の値{リスト} {赤、緑、青のリスト*半}赤、緑、青{キー}、％3Bと、ドット、。、カンマは、％2C {キー*}セミ=％3Bと、ドット=。、カンマ=％2C"
    },
    {
      "indent": 0,
      "text": "3.2.3. Reserved Expansion: {+var}",
      "section_title": true,
      "ja": "3.2.3. 予約済み拡張：+ {ました}"
    },
    {
      "indent": 3,
      "text": "Reserved expansion, as indicated by the plus (\"+\") operator for Level 2 and above templates, is identical to simple string expansion except that the substituted values may also contain pct-encoded triplets and characters in the reserved set.",
      "ja": "予約膨張は、プラスで示されるように（「+」）レベル2と上記テンプレートのオペレータは、置換された値も、予約セットにPCTエンコードトリプレットおよび文字を含んでいてもよいことを除いて、単純な文字列展開と同じです。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list, perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the set (unreserved / reserved / pct-encoded). If more than one variable has a defined value, append a comma (\",\") to the result string as a separator between variable expansions.",
      "ja": "セクション3.2.1で定義されるように、変数リスト内のそれぞれの定義された変数のために、許容文字セット（未予約/予約/ PCT-コードされる）のものであると共に、変数展開を行います。複数の変数が定義された値を有する場合、変数展開の間のセパレータとして結果の文字列にカンマ（「」）追加。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "例テンプレート展開"
    },
    {
      "indent": 7,
      "text": "{+var} value {+hello} Hello%20World! {+half} 50%25",
      "ja": "{+ VAR} {値+ハロー}こんにちは％20World！ {+}半分50％25"
    },
    {
      "indent": 7,
      "text": "{base}index http%3A%2F%2Fexample.com%2Fhome%2Findex {+base}index http://example.com/home/index O{+empty}X OX O{+undef}X OX",
      "ja": "{ベース}指数HTTP％3A％2F％2Fexample.com％2Fhome％2Findex {+}基部インデックスhttp://example.com/home/indexのO {+}空X OX O {+ undefを} X OX"
    },
    {
      "indent": 7,
      "text": "{+path}/here /foo/bar/here here?ref={+path} here?ref=/foo/bar up{+path}{var}/here up/foo/barvalue/here {+x,hello,y} 1024,Hello%20World!,768 {+path,x}/here /foo/bar,1024/here",
      "ja": "ここで、ここで、{+パス} /ここで/ fooの/バー/？REF = {+パス}ここで？ここでREF = / FOO /バーアップ{+パス} {VAR} / / FOO /ここでbarvalue / {+ Xまで、ハロー、Y} 1024ハロー％20World！、768 {+パス、X} /ここで/ fooの/バー1024 /ここで"
    },
    {
      "indent": 7,
      "text": "{+path:6}/here /foo/b/here {+list} red,green,blue {+list*} red,green,blue {+keys} semi,;,dot,.,comma,, {+keys*} semi=;,dot=.,comma=,",
      "ja": "{+パス：6} /ここで/ fooの/ B /ここで、{+リスト}赤、緑、青{+リスト*}赤、緑、青{+キー}半;、ドット、コンマ,, {+。キー*}半= ;,ドット=。、コンマ="
    },
    {
      "indent": 0,
      "text": "3.2.4. Fragment Expansion: {#var}",
      "section_title": true,
      "ja": "3.2.4. 断片拡張：{} #var"
    },
    {
      "indent": 3,
      "text": "Fragment expansion, as indicated by the crosshatch (\"#\") operator for Level 2 and above templates, is identical to reserved expansion except that a crosshatch character (fragment delimiter) is appended first to the result string if any of the variables are defined.",
      "ja": "フラグメント拡張は、クロスハッチ（「＃」）レベル2のための演算子と上記テンプレートによって示されるように、変数のいずれかが定義されている場合、クロスハッチ文字（断片デリミタ）は、結果文字列に最初に添付されていることを除いて予約膨張と同一です。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "例テンプレート展開"
    },
    {
      "indent": 7,
      "text": "{#var} #value {#hello} #Hello%20World! {#half} #50%25 foo{#empty} foo# foo{#undef} foo {#x,hello,y} #1024,Hello%20World!,768 {#path,x}/here #/foo/bar,1024/here {#path:6}/here #/foo/b/here {#list} #red,green,blue {#list*} #red,green,blue {#keys} #semi,;,dot,.,comma,, {#keys*} #semi=;,dot=.,comma=,",
      "ja": "{} #var #VALUE {#hello}＃こんにちは％20World！ {#half}＃50％25 FOO {#empty} FOO＃fooの{の#undef} FOO {＃1、X、ハロー、Y}＃1024ハロー％20World！、768 {＃パス、X} /ここで＃/ FOO /バー1024 /ここで{#path：6} /ここで＃/ FOO / B /ここで{#list}＃赤、緑、青{＃リスト*}＃赤、緑、青{#keys} #semi、;、ドット、。、コンマ,, {＃キー*} #semi = ;,ドット=。、コンマ="
    },
    {
      "indent": 0,
      "text": "3.2.5. Label Expansion with Dot-Prefix: {.var}",
      "section_title": true,
      "ja": "3.2.5. ドットプレフィックスとラベル拡張：{} .var"
    },
    {
      "indent": 3,
      "text": "Label expansion, as indicated by the dot (\".\") operator for Level 3 and above templates, is useful for describing URI spaces with varying domain names or path selectors (e.g., filename extensions).",
      "ja": "レベル3と上記テンプレートのドットによって示されるように、ラベルの拡大、（「」）オペレータ、ドメイン名またはパスセレクタ（例えば、ファイル拡張子）を変化させてURI空間を説明するために有用です。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list, append \".\" to the result string and then perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the unreserved set.",
      "ja": "変数リスト内のそれぞれの定義された変数について、追加「」結果の文字列にした後、セクション3.2.1で定義されるように、変数展開を行う、許容文字が予約されていない集合のものであると。"
    },
    {
      "indent": 3,
      "text": "Since \".\" is in the unreserved set, a value that contains a \".\" has the effect of adding multiple labels.",
      "ja": "以来、「」 Aが含まれている値は、予約されていないセットです「」複数のラベルを追加する効果があります。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "例テンプレート展開"
    },
    {
      "indent": 7,
      "text": "{.who} .fred {.who,who} .fred.fred {.half,who} .50%25.fred www{.dom*} www.example.com X{.var} X.value X{.empty} X. X{.undef} X X{.var:3} X.val X{.list} X.red,green,blue X{.list*} X.red.green.blue X{.keys} X.semi,%3B,dot,.,comma,%2C X{.keys*} X.semi=%3B.dot=..comma=%2C X{.empty_keys} X X{.empty_keys*} X",
      "ja": "{.half、誰} 0.50パーセント25.fred WWW {.dom *} www.example.com X {.var} X.value Xを{.fred.fred .fred {.who} {.who、}。空} X.のX {.undef} XX {.var：3} X.val X {.LIST} X.red、緑、青のX {.LIST *} X.red.green.blue X {.keys} X .semi、％3Bと、ドット、。、カンマ、％2C X {.keys *} X.semi =％3B.dot = ..カンマ=％2C X {.empty_keys} XX {.empty_keys *} X"
    },
    {
      "indent": 0,
      "text": "3.2.6. Path Segment Expansion: {/var}",
      "section_title": true,
      "ja": "3.2.6. 経路セグメントの拡張：{/ VAR}"
    },
    {
      "indent": 3,
      "text": "Path segment expansion, as indicated by the slash (\"/\") operator in Level 3 and above templates, is useful for describing URI path hierarchies.",
      "ja": "経路セグメントの拡張は、レベル3およびテンプレート上記スラッシュ（「/」）オペレータにより示されるように、URIパス階層を説明するために有用です。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list, append \"/\" to the result string and then perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the unreserved set.",
      "ja": "変数リスト内のそれぞれの定義された変数のために、結果の文字列に「/」を追加し、許可される文字が予約されていない集合のものであると、3.2.1節で定義されるように、次に、変数展開を行います。"
    },
    {
      "indent": 3,
      "text": "Note that the expansion process for path segment expansion is identical to that of label expansion aside from the substitution of \"/\" instead of \".\". However, unlike \".\", a \"/\" is a reserved character and will be pct-encoded if found in a value.",
      "ja": "経路セグメントの拡張のための拡張プロセスは、「/」の代わりの置換別にラベル膨張のものと同一であることに注意してください「」。しかし、とは違って「」、 『/』予約文字で、値で見つかった場合、PCT-エンコードされます。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "例テンプレート展開"
    },
    {
      "indent": 7,
      "text": "{/who} /fred {/who,who} /fred/fred {/half,who} /50%25/fred {/who,dub} /fred/me%2Ftoo {/var} /value {/var,empty} /value/ {/var,undef} /value {/var,x}/here /value/1024/here {/var:1,var} /v/value {/list} /red,green,blue {/list*} /red/green/blue {/list*,path:4} /red/green/blue/%2Ffoo {/keys} /semi,%3B,dot,.,comma,%2C {/keys*} /semi=%3B/dot=./comma=%2C",
      "ja": "{/} / {フレッド/} /フレッド/フレッド{/半} / 50％25 /フレッド{/、ダブ} /フレッド/ ME％2Ftoo {/ VAR} /値{/ VAR、空} /値/ {/ VAR、undefを} /値{/ VAR、X} /ここで/値/ 1024 /ここで{/ VAR：1、VAR} / V /値{{/リスト} /赤、緑、青/リスト*} /赤/緑/青{/ *リスト、パス：4} /赤/緑/青/％2Ffoo {/キー} /semi,%3B,dot,.,comma,%2C {/ *キー} /semi=%3B/dot=./comma=%2C"
    },
    {
      "indent": 0,
      "text": "3.2.7. Path-Style Parameter Expansion: {;var}",
      "section_title": true,
      "ja": "3.2.7. パススタイルパラメータ拡張：{;} VAR"
    },
    {
      "indent": 3,
      "text": "Path-style parameter expansion, as indicated by the semicolon (\";\") operator in Level 3 and above templates, is useful for describing URI path parameters, such as \"path;property\" or \"path;name=value\".",
      "ja": "パススタイルのパラメータ展開は、セミコロン（「;」）によって示されるように「;プロパティパス」または「パス、名前=値」レベル3と上記テンプレートにおけるオペレータのようなURIパスパラメータを記述するために有用です。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list:",
      "ja": "変数リスト内のそれぞれの定義された変数の場合："
    },
    {
      "indent": 3,
      "text": "o append \";\" to the result string;",
      "ja": "O追加 \";\"結果の文字列へ。"
    },
    {
      "indent": 3,
      "text": "o if the variable has a simple string value or no explode modifier is given, then:",
      "ja": "O変数は、単純な文字列値を有するか、または全く爆発修飾子は、次に、指定されていない場合。"
    },
    {
      "indent": 6,
      "text": "* append the variable name (encoded as if it were a literal string) to the result string;",
      "ja": "*結果の文字列に（それがリテラル文字列であるかのようにエンコードされた）変数名を追加します。"
    },
    {
      "indent": 6,
      "text": "* if the variable's value is not empty, append \"=\" to the result string;",
      "ja": "*変数の値が空でない場合、結果文字列に「=」を追加。"
    },
    {
      "indent": 3,
      "text": "o perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the unreserved set.",
      "ja": "許容文字が予約されていない集合のものであると、3.2.1節で定義されるように、O、変数展開を行います。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "例テンプレート展開"
    },
    {
      "indent": 7,
      "text": "{;who} ;who=fred {;half} ;half=50%25 {;empty} ;empty {;v,empty,who} ;v=6;empty;who=fred {;v,bar,who} ;v=6;who=fred {;x,y} ;x=1024;y=768 {;x,y,empty} ;x=1024;y=768;empty {;x,y,undef} ;x=1024;y=768 {;hello:5} ;hello=Hello {;list} ;list=red,green,blue {;list*} ;list=red;list=green;list=blue {;keys} ;keys=semi,%3B,dot,.,comma,%2C {;keys*} ;semi=%3B;dot=.;comma=%2C",
      "ja": "{;};フレッド= {;半};半= 50％25 {;空};空{; V、空、人}; V = 6;空;フレッド=誰{; V、バー、誰} ; V = 6;誰がフレッド= {; X、Y}、X = 1024; yは768 = {; X、Y、空}、X = 1024、yは768 =、空{あり、x、yは、undefを}; Xハロー=こんにちは{;リスト};リスト=赤、緑、青{;リスト*};リスト=赤色;リスト=緑色; =青リスト{;キー};：= 1024; {5ハロー} yは768 =キー=半、％3Bと、ドット、カンマ、％2C。{;キー*};半=％3B;ドット= .;カンマ=％2C"
    },
    {
      "indent": 0,
      "text": "3.2.8. Form-Style Query Expansion: {?var}",
      "section_title": true,
      "ja": "3.2.8. フォームスタイルのクエリ拡張：{？VAR}"
    },
    {
      "indent": 3,
      "text": "Form-style query expansion, as indicated by the question-mark (\"?\") operator in Level 3 and above templates, is useful for describing an entire optional query component.",
      "ja": "フォーム形式のクエリ拡張は、レベル3と上記テンプレートで疑問符（「？」）オペレータにより示されるように、全体任意クエリコンポーネントを説明するのに有用です。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list:",
      "ja": "変数リスト内のそれぞれの定義された変数の場合："
    },
    {
      "indent": 3,
      "text": "o append \"?\" to the result string if this is the first defined value or append \"&\" thereafter;",
      "ja": "O追加 \"？\"その後、これが最初に定義された値であるか、または追加する場合、結果の文字列に「＆」。"
    },
    {
      "indent": 3,
      "text": "o if the variable has a simple string value or no explode modifier is given, append the variable name (encoded as if it were a literal string) and an equals character (\"=\") to the result string; and,",
      "ja": "変数は、単純な文字列値を有するか、または全く爆発修飾子が指定されていない場合、O、変数名を追加（それはリテラル文字列であるかのように符号化され）、その結果の文字列に文字（「=」）に等しいです。そして、"
    },
    {
      "indent": 3,
      "text": "o perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the unreserved set.",
      "ja": "許容文字が予約されていない集合のものであると、3.2.1節で定義されるように、O、変数展開を行います。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "例テンプレート展開"
    },
    {
      "indent": 7,
      "text": "{?who} ?who=fred {?half} ?half=50%25 {?x,y} ?x=1024&y=768 {?x,y,empty} ?x=1024&y=768&empty= {?x,y,undef} ?x=1024&y=768 {?var:3} ?var=val {?list} ?list=red,green,blue {?list*} ?list=red&list=green&list=blue {?keys} ?keys=semi,%3B,dot,.,comma,%2C {?keys*} ?semi=%3B&dot=.&comma=%2C",
      "ja": "フレッド{？半分}？半分= 50％25 {？X、Y}？X = 1024＆Y = 768 {？X、Y、空}？X = 1024＆Y = 768＆空= {？X、Yが= {？誰}？ 、undefを}、X = 1024＆Y = 768 {VAR：？？？？？？？？{赤＆リスト=グリーン＆リスト青= 3} VAR =ヴァル{リスト}リスト=赤、緑、青{リスト*}リスト=キー}キー？ =半、％3Bと、ドット、。、カンマ、％2C {？キー*}？半=％3B＆ドット=＆カンマ=％2C"
    },
    {
      "indent": 0,
      "text": "3.2.9. Form-Style Query Continuation: {&var}",
      "section_title": true,
      "ja": "3.2.9. フォームスタイルのクエリの継続：{＆VAR}"
    },
    {
      "indent": 3,
      "text": "Form-style query continuation, as indicated by the ampersand (\"&\") operator in Level 3 and above templates, is useful for describing optional &name=value pairs in a template that already contains a literal query component with fixed parameters.",
      "ja": "フォーム形式のクエリ継続は、レベル3と上記テンプレートにアンパサンドによって示されるように（「＆」）オペレータが、既に固定されたパラメータを有するリテラルクエリコンポーネントを含むテンプレートに任意＆名前=値のペアを記述するために有用です。"
    },
    {
      "indent": 3,
      "text": "For each defined variable in the variable-list:",
      "ja": "変数リスト内のそれぞれの定義された変数の場合："
    },
    {
      "indent": 3,
      "text": "o append \"&\" to the result string;",
      "ja": "O結果文字列に「＆」を追加。"
    },
    {
      "indent": 3,
      "text": "o if the variable has a simple string value or no explode modifier is given, append the variable name (encoded as if it were a literal string) and an equals character (\"=\") to the result string; and,",
      "ja": "変数は、単純な文字列値を有するか、または全く爆発修飾子が指定されていない場合、O、変数名を追加（それはリテラル文字列であるかのように符号化され）、その結果の文字列に文字（「=」）に等しいです。そして、"
    },
    {
      "indent": 3,
      "text": "o perform variable expansion, as defined in Section 3.2.1, with the allowed characters being those in the unreserved set.",
      "ja": "許容文字が予約されていない集合のものであると、3.2.1節で定義されるように、O、変数展開を行います。"
    },
    {
      "indent": 5,
      "text": "Example Template Expansion",
      "ja": "例テンプレート展開"
    },
    {
      "indent": 7,
      "text": "{&who} &who=fred {&half} &half=50%25 ?fixed=yes{&x} ?fixed=yes&x=1024 {&x,y,empty} &x=1024&y=768&empty= {&x,y,undef} &x=1024&y=768",
      "ja": "{＆誰}＆誰フレッド{＆半分}＆半分= 50％25？固定=はい{＆X}？固定=はい＆X = 1024 {＆X、Y、空}＆X = 1024＆Y = 768＆空= {＆X、Y、undefを}＆X = 1024＆Yが= = 768"
    },
    {
      "indent": 7,
      "text": "{&var:3} &var=val {&list} &list=red,green,blue {&list*} &list=red&list=green&list=blue {&keys} &keys=semi,%3B,dot,.,comma,%2C {&keys*} &semi=%3B&dot=.&comma=%2C",
      "ja": "{＆VAR：3}＆VAR =ヴァル{＆リスト}＆リスト=赤、緑、青{＆リスト*}＆リスト=赤＆リスト=グリーン＆リスト=青{＆キー}＆キー=半、％3Bと、ドット、カンマ、％2C {＆キー*。 }＆半=％3B＆ドット=＆カンマ=％2C"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "A URI Template does not contain active or executable content. However, it might be possible to craft unanticipated URIs if an attacker is given control over the template or over the variable values within an expression that allows reserved characters in the expansion. In either case, the security considerations are largely determined by who provides the template, who provides the values to use for variables within the template, in what execution context the expansion occurs (client or server), and where the resulting URIs are used.",
      "ja": "URIテンプレートは、アクティブまたは実行可能なコンテンツが含まれていません。しかし、攻撃者がテンプレート上または拡張に予約文字を可能に式内の変数値に対する制御を与えられた場合、予期しないURIを作ることが可能であるかもしれません。いずれの場合においても、セキュリティ問題は、主にテンプレート内の変数に使用する値を提供するテンプレートを、提供者によって決定され、どのような実行コンテキストの拡大は、（クライアントまたはサーバ）が発生し、ここで得られたURIが使用されています。"
    },
    {
      "indent": 3,
      "text": "This specification does not limit where URI Templates might be used. Current implementations exist within server-side development frameworks and within client-side javascript for computed links or forms.",
      "ja": "URIテンプレートが使用される可能性がありますどここの仕様は制限しません。現在の実装では、計算されたリンクやフォームのサーバー側の開発フレームワーク内およびクライアント側のJavaScript内に存在します。"
    },
    {
      "indent": 3,
      "text": "Within frameworks, templates usually act as guides for where data might occur within later (request-time) URIs in client requests. Hence, the security concerns are not in the templates themselves, but rather in how the server extracts and processes the user-provided data within a normal Web request.",
      "ja": "フレームワーク内では、テンプレートは、通常、データがクライアント要求の後の（要求時）内のURIを発生する可能性のある場所のためのガイドとして機能します。そのため、セキュリティ上の懸念は、テンプレートそのものではなく、むしろどのようにサーバを抽出し、通常のWebリクエストの中にユーザー提供のデータを処理していません。"
    },
    {
      "indent": 3,
      "text": "Within client-side implementations, a URI Template has many of the same properties as HTML forms, except limited to URI characters and possibly included in HTTP header field values instead of just message body content. Care ought to be taken to ensure that potentially dangerous URI reference strings, such as those beginning with \"javascript:\", do not appear in the expansion unless both the template and the values are provided by a trusted source.",
      "ja": "URI文字に限定されるものではなく、おそらくHTTPヘッダフィールド値の代わりにだけメッセージ本文の内容に含まれる以外は、クライアント側の実装内で、URIテンプレートは、HTMLフォームと同じ特性の多くを有します。 「javascript：」形式、テンプレートと値の両方が信頼できるソースから提供されていない限り、拡張には表示されませんケアは、で始まるものとその潜在的に危険なURI参照文字列を、確実にするために取られるべきです。"
    },
    {
      "indent": 3,
      "text": "Other security considerations are the same as those for URIs, as described in Section 7 of [RFC3986].",
      "ja": "[RFC3986]のセクション7で説明したように他のセキュリティ上の考慮事項は、URIのものと同じです。"
    },
    {
      "indent": 0,
      "text": "5. Acknowledgments",
      "section_title": true,
      "ja": "5.謝辞"
    },
    {
      "indent": 3,
      "text": "The following people made contributions to this specification: Mike Burrows, Michaeljohn Clement, DeWitt Clinton, John Cowan, Stephen Farrell, Robbie Gates, Vijay K. Gurbani, Peter Johanson, Murray S. Kucherawy, James H. Manger, Tom Petch, Marc Portier, Pete Resnick, James Snell, and Jiankang Yao.",
      "ja": "マイク・バロウズ、Michaeljohnクレメント、デウィットクリントン、ジョン・コーワン、スティーブン・ファレル、ロビー・ゲイツ、ビジェイK. Gurbani、ピーター・ヨハンソン、マレーS. Kucherawy、ジェームズ・H.マネージャ、トム・ペッチ、マルク・Portier：次の人は、この仕様に貢献をしました、ピート・レズニック、ジェームズ・スネル、およびJiankang八尾。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[ASCII] American National Standards Institute, \"Coded Character Set - 7-bit American Standard Code for Information Interchange\", ANSI X3.4, 1986.",
      "ja": "「 - 情報交換のための7ビットの米国標準コードコード化文字セット」、ANSI X3.4、1986 [ASCII]米国規格協会、。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3987] Duerst, M. and M. Suignard, \"Internationalized Resource Identifiers (IRIs)\", RFC 3987, January 2005.",
      "ja": "[RFC3987] Duerst、M.およびM. Suignard、 \"国際化リソース識別Fiers（IRI）\"、RFC 3987、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6365] Hoffman, P. and J. Klensin, \"Terminology Used in Internationalization in the IETF\", BCP 166, RFC 6365, September 2011.",
      "ja": "[RFC6365]ホフマン、P.およびJ. Klensin、 \"IETFでの国際化に使用される用語\"、BCP 166、RFC 6365、2011年9月。"
    },
    {
      "indent": 3,
      "text": "[UNIV6] The Unicode Consortium, \"The Unicode Standard, Version 6.0.0\", (Mountain View, CA: The Unicode Consortium, 2011. ISBN 978-1-936213-01-6), <http://www.unicode.org/versions/Unicode6.0.0/>.",
      "ja": "[UNIV6]はUnicodeコンソーシアム、 \"Unicode標準、バージョン6.0.0\"、（カリフォルニア州マウンテンビュー：ユニコードコンソーシアム、2011年ISBN 978-1-936213-01-6）、<のhttp：//www.unicode .ORG /バージョン/ Unicode6.0.0 />。"
    },
    {
      "indent": 3,
      "text": "[UTR15] Davis, M. and M. Duerst, \"Unicode Normalization Forms\", Unicode Standard Annex # 15, April 2003, <http://www.unicode.org/unicode/reports/tr15/ tr15-23.html>.",
      "ja": "【UTR15]デイビス、M.およびM. Duerst、 \"Unicode正規化フォームの\" Unicode標準附属書＃15、2003年4月<http://www.unicode.org/unicode/reports/tr15/ tr15-23.html> 、"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[OpenSearch] Clinton, D., \"OpenSearch 1.1\", Draft 5, December 2011, <http://www.opensearch.org/Specifications/OpenSearch>.",
      "ja": "[OpenSearchの]クリントン、D.、 \"OpenSearchの1.1\"、ドラフト5、2011年12月、<http://www.opensearch.org/Specifications/OpenSearch>。"
    },
    {
      "indent": 3,
      "text": "[UPU-S42] Universal Postal Union, \"International Postal Address Components and Templates\", UPU S42-1, November 2002, <http://www.upu.int/en/activities/addressing/ standards.html>.",
      "ja": "[UPU-S42]万国郵便連合、 \"国際郵便住所コンポーネントやテンプレート\"、UPU S42-1、2002年11月、<http://www.upu.int/en/activities/addressing/ standards.html>。"
    },
    {
      "indent": 3,
      "text": "[WADL] Hadley, M., \"Web Application Description Language\", World Wide Web Consortium Member Submission SUBM-wadl-20090831, August 2009, <http://www.w3.org/Submission/2009/ SUBM-wadl-20090831/>.",
      "ja": "2009年8月には、ハドレー、M.、 \"Webアプリケーション記述言語\" は、ワールド・ワイド・ウェブ・コンソーシアムメンバー提出SUBMが消費-20090831を[消費]、<http://www.w3.org/Submission/2009/ SUBM消費-20090831を/>。"
    },
    {
      "indent": 3,
      "text": "[WSDL] Weerawarana, S., Moreau, J., Ryman, A., and R. Chinnici, \"Web Services Description Language (WSDL) Version 2.0 Part 1: Core Language\", World Wide Web Consortium Recommendation REC-wsdl20-20070626, June 2007, <http://www.w3.org/TR/2007/ REC-wsdl20-20070626>.",
      "ja": "[WSDL] Weerawarana氏、S.、モロー、J.、ライマン、A.、およびR. Chinnici氏、 \"Webサービス記述言語（WSDL）バージョン2.0パート1：コア言語\"、ワールドワイドウェブコンソーシアム推薦REC-wsdl20-20070626 、2007年6月、<http://www.w3.org/TR/2007/ REC-wsdl20-20070626>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Implementation Hints",
      "ja": "付録A.実装のヒント"
    },
    {
      "indent": 3,
      "text": "The normative sections on expansion describe each operator with a separate expansion process for the sake of descriptive clarity. In actual implementations, we expect the expressions to be processed left-to-right using a common algorithm that has only minor variations in process per operator. This non-normative appendix describes one such algorithm.",
      "ja": "膨張に規範のセクションでは、説明の明確化のために別個の膨張プロセスと各オペレータが記載されています。実際の実装では、我々は、式は左から右にオペレータごとのプロセスで唯一のマイナーなバリエーションを持っている一般的なアルゴリズムを使用して処理することを期待しています。この非規範的な付録では、そのようなアルゴリズムを記述しています。"
    },
    {
      "indent": 3,
      "text": "Initialize an empty result string and its non-error state.",
      "ja": "空の結果の文字列とその非エラー状態を初期化します。"
    },
    {
      "indent": 3,
      "text": "Scan the template and copy literals to the result string (as in Section 3.1) until an expression is indicated by a \"{\", an error is indicated by the presence of a non-literals character other than \"{\", or the template ends. When it ends, return the result string and its current error or non-error state.",
      "ja": "テンプレートをスキャンし、発現は、「{」、エラーが以外の非リテラル文字「{」、または鋳型末端の存在によって示されていることによって示されるまで（3.1節のように）結果文字列にリテラルをコピー。それが終了すると、結果の文字列とその現在のエラーまたは非エラー状態を返します。"
    },
    {
      "indent": 3,
      "text": "o If an expression is found, scan the template to the next \"}\" and extract the characters in between the braces.",
      "ja": "発現が見つかった場合、O、「}」次のテンプレートをスキャンし、カッコの間に文字を抽出します。"
    },
    {
      "indent": 3,
      "text": "o If the template ends before a \"}\", then append the \"{\" and extracted characters to the result string and return with an error status indicating the expression is malformed.",
      "ja": "次いで、「{」とは、結果文字列に文字を抽出して発現が不正であることを示すエラー状態で戻りを追加、テンプレートは「}」の前に終了した場合、O。"
    },
    {
      "indent": 3,
      "text": "Examine the first character of the extracted expression for an operator.",
      "ja": "オペレータのための抽出された表現の最初の文字を調べます。"
    },
    {
      "indent": 3,
      "text": "o If the expression ended (i.e., is \"{}\"), an operator is found that is unknown or unimplemented, or the character is not in the varchar set (Section 2.3), then append \"{\", the extracted expression, and \"}\" to the result string, remember that the result is in an error state, and then go back to scan the remainder of the template.",
      "ja": "O式が終了した場合（すなわち、「{}」である）、オペレータは「{」未知又は未実装であることを見出し、または文字がVARCHARセット（セクション2.3）にない場合、追加され、抽出された発現、および「}」結果の文字列に、テンプレートの残りの部分をスキャンするために戻って、結果がエラー状態であることを覚えておいてください、と。"
    },
    {
      "indent": 3,
      "text": "o If a known and implemented operator is found, store the operator and skip to the next character to begin the varspec-list.",
      "ja": "知られており、実装作業が見つかった場合、O、オペレータを格納しvarspecリストを開始するために次の文字に進みます。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, store the operator as NUL (simple string expansion).",
      "ja": "Oそうでない場合、NUL（単純な文字列拡張）としてオペレータを格納します。"
    },
    {
      "indent": 3,
      "text": "Use the following value table to determine the processing behavior by expression type operator. The entry for \"first\" is the string to append to the result first if any of the expression's variables are defined. The entry for \"sep\" is the separator to append to the result before any second (or subsequent) defined variable expansion. The entry for \"named\" is a boolean for whether or not the expansion includes the variable or key name when no explode modifier is given. The entry for \"ifemp\" is a string to append to the name if its corresponding value is empty. The entry for \"allow\" indicates what characters to allow unencoded within the value expansion: (U) means any character not in the unreserved set will be encoded; (U+R) means any character not in the union of (unreserved / reserved / pct-encoding) will be encoded; and, for both cases, each disallowed character is first encoded as its sequence of octets in UTF-8 and then each such octet is encoded as a pct-encoded triplet.",
      "ja": "表現型オペレータによる処理の動作を決定するために、以下の値テーブルを使用。 「最初」のエントリは、式の変数のいずれかが定義されている場合は、最初の結果に追加する文字列です。 「9月」のエントリは、任意の定義される第2の（又は後続の）可変膨張前の結果に追加するためのセパレータです。拡張が何も爆発修飾子が指定されていない変数またはキーの名前が含まれているか否かのブールである「という名前」のエントリ。 「ifemp」のエントリは、それに対応する値が空の場合、名前に追加する文字列です。 「許可」のエントリが値の拡張内のエンコードされていない可能にするためにどのような文字を示します（U）がないエンコードされます予約されていないセット内の任意の文字を意味します。 （U + R）は、エンコードされていない（未予約/予約/ PCT-符号化）の組合に任意の文字を意味します。そして、両方の場合のために、各禁止文字は最初UTF-8オクテットのシーケンスとしてエンコードされ、次いで、このような各オクテットは、PCTエンコードトリプレットとして符号化されます。"
    },
    {
      "indent": 3,
      "text": ".------------------------------------------------------------------.\n|          NUL     +      .       /       ;      ?      &      #   |\n|------------------------------------------------------------------|\n| first |  \"\"     \"\"     \".\"     \"/\"     \";\"    \"?\"    \"&\"    \"#\"  |\n| sep   |  \",\"    \",\"    \".\"     \"/\"     \";\"    \"&\"    \"&\"    \",\"  |\n| named | false  false  false   false   true   true   true   false |\n| ifemp |  \"\"     \"\"     \"\"      \"\"      \"\"     \"=\"    \"=\"    \"\"   |\n| allow |   U     U+R     U       U       U      U      U     U+R  |\n`------------------------------------------------------------------'",
      "raw": true
    },
    {
      "indent": 3,
      "text": "With the above table in mind, process the variable-list as follows:",
      "ja": "次のように心の中で、上記の表では、変数リストを処理します："
    },
    {
      "indent": 3,
      "text": "For each varspec, extract a variable name and optional modifier from the expression by scanning the variable-list until a character not in the varname set is found or the end of the expression is reached.",
      "ja": "各varspecため、VARNAMEセット内の文字はないが発見されたまたは発現の終わりに達するまで、可変リストをスキャンすることによって式から変数名とオプション修飾子を抽出します。"
    },
    {
      "indent": 3,
      "text": "o If it is the end of the expression and the varname is empty, go back to scan the remainder of the template.",
      "ja": "それは式の終わりであるとVARNAMEが空の場合、O、テンプレートの残りの部分をスキャンするために戻って行きます。"
    },
    {
      "indent": 3,
      "text": "o If it is not the end of the expression and the last character found indicates a modifier (\"*\" or \":\"), remember that modifier. If it is an explode (\"*\"), scan the next character. If it is a prefix (\":\"), continue scanning the next one to four characters for the max-length represented as a decimal integer and then, if it is still not the end of the expression, scan the next character.",
      "ja": "その修飾子を覚えて、：それは式の終わりではなく、最後の文字が見つかった場合、O修飾子（「」「*」か）を示します。それは（「*」）爆発されている場合は、次の文字をスキャンします。 （「：」）それは接頭辞である場合は、10進整数として表さ最大長については、次の1〜4つの文字をスキャンし続け、その後、それはまだ、式の終わりではない場合は、次の文字をスキャンします。"
    },
    {
      "indent": 3,
      "text": "o If it is not the end of the expression and the last character found is not a comma (\",\"), append \"{\", the stored operator (if any), the scanned varname and modifier, the remaining expression, and \"}\" to the result string, remember that the result is in an error state, and then go back to scan the remainder of the template.",
      "ja": "それは式の終わりではなく、見つかった最後の文字（」、 『）』、 『{』が格納さ演算子（もしあれば）、スキャンVARNAME及び改質剤、残りの式を追加し、コンマでない場合はO }」結果の文字列に、テンプレートの残りの部分をスキャンするために戻って、結果がエラー状態であることを覚えておいてください、と。"
    },
    {
      "indent": 3,
      "text": "Lookup the value for the scanned variable name, and then",
      "ja": "次いで、スキャン変数名の値をルックアップ、および"
    },
    {
      "indent": 3,
      "text": "o If the varname is unknown or corresponds to a variable with an undefined value (Section 2.3), then skip to the next varspec.",
      "ja": "O VARNAMEは未知である場合、または次varspecに進み、その後、不定値（セクション2.3）を用いて変数に対応します。"
    },
    {
      "indent": 3,
      "text": "o If this is the first defined variable for this expression, append the first string for this expression type to the result string and remember that it has been done. Otherwise, append the sep string to the result string.",
      "ja": "これがこの式の最初の定義された変数である場合には、O、結果の文字列にこの式タイプのための最初の文字列を追加し、それが行われたことを覚えておいてください。それ以外の場合は、結果の文字列に9月の文字列を追加します。"
    },
    {
      "indent": 3,
      "text": "o If this variable's value is a string, then",
      "ja": "この変数の値は、その後、文字列の場合O"
    },
    {
      "indent": 6,
      "text": "* if named is true, append the varname to the result string using the same encoding process as for literals, and",
      "ja": "*真実であるという名前の、リテラルの場合と同じ符号化プロセスを使用した結果文字列にVARNAMEを追加した場合、および"
    },
    {
      "indent": 9,
      "text": "+ if the value is empty, append the ifemp string to the result string and skip to the next varspec;",
      "ja": "値が空の場合+、結果文字列にifemp文字列を追加し、次varspecにスキップ。"
    },
    {
      "indent": 9,
      "text": "+ otherwise, append \"=\" to the result string.",
      "ja": "+それ以外の場合は、結果文字列に「=」を追加します。"
    },
    {
      "indent": 6,
      "text": "* if a prefix modifier is present and the prefix length is less than the value string length in number of Unicode characters, append that number of characters from the beginning of the value string to the result string, after pct-encoding any characters that are not in the allow set, while taking care not to split multi-octet or pct-encoded triplet characters that represent a single Unicode code point;",
      "ja": "*プレフィックス修飾子が存在し、プレフィックス長は、Unicode文字の数値文字列の長さ未満である場合、ないPCT-コードする任意の文字の後、結果の文字列に値文字列の先頭から文字の数を追加許可セットで、マルチオクテット又は単一のUnicodeコードポイントを表すPCTエンコード三重文字を分割しないように注意しながら。"
    },
    {
      "indent": 6,
      "text": "* otherwise, append the value to the result string after pct-encoding any characters that are not in the allow set.",
      "ja": "*それ以外の場合は、許可セットにないPCT-コードする任意の文字の後に結果文字列に値を追加します。"
    },
    {
      "indent": 3,
      "text": "o else if no explode modifier is given, then",
      "ja": "O誰爆発修飾子は、その後、指定されていない場合"
    },
    {
      "indent": 6,
      "text": "* if named is true, append the varname to the result string using the same encoding process as for literals, and",
      "ja": "*真実であるという名前の、リテラルの場合と同じ符号化プロセスを使用した結果文字列にVARNAMEを追加した場合、および"
    },
    {
      "indent": 9,
      "text": "+ if the value is empty, append the ifemp string to the result string and skip to the next varspec;",
      "ja": "値が空の場合+、結果文字列にifemp文字列を追加し、次varspecにスキップ。"
    },
    {
      "indent": 9,
      "text": "+ otherwise, append \"=\" to the result string; and",
      "ja": "+そうでなければ、結果の文字列に「=」付加;そして"
    },
    {
      "indent": 6,
      "text": "* if this variable's value is a list, append each defined list member to the result string, after pct-encoding any characters that are not in the allow set, with a comma (\",\") appended to the result between each defined list member;",
      "ja": "*この変数の値がリストである場合、各定義されたリスト部材との間に結果に付加カンマ（「」）と、許可セットに含まれていないPCT-コードする任意の文字の後、結果の文字列に定義された各リスト部材を追加;"
    },
    {
      "indent": 6,
      "text": "* if this variable's value is an associative array or any other form of paired (name, value) structure, append each pair with a defined value to the result string as \"name,value\", after pct-encoding any characters that are not in the allow set, with a comma (\",\") appended to the result between each defined pair.",
      "ja": "*この変数の値はしていないPCT-コードする任意の文字の後に、「名前、値」と結果の文字列に定義された値との各ペアを追加し、連想配列またはペア（名前、値）の構造の任意の他の形態である場合定義された各対の間の結果に付加カンマ（「」）と、設定可能にします。"
    },
    {
      "indent": 3,
      "text": "o else if an explode modifier is given, then",
      "ja": "O他の爆発修飾子は、指定された場合"
    },
    {
      "indent": 6,
      "text": "* if named is true, then for each defined list member or array (name, value) pair with a defined value, do:",
      "ja": "定義された値を持つ*という名前がtrueの場合は、各定義されたリストのためのメンバーまたは配列（名前、値）ペア、実行します。"
    },
    {
      "indent": 9,
      "text": "+ if this is not the first defined member/value, append the sep string to the result string;",
      "ja": "+これは、最初に定義されたメンバー/値でない場合、結果文字列へのSEP文字列を追加。"
    },
    {
      "indent": 9,
      "text": "+ if this is a list, append the varname to the result string using the same encoding process as for literals;",
      "ja": "+このリストであれば、リテラルの場合と同じ符号化処理を使用して、結果の文字列にVARNAMEを追加します。"
    },
    {
      "indent": 9,
      "text": "+ if this is a pair, append the name to the result string using the same encoding process as for literals;",
      "ja": "+これはペアであれば、リテラルと同じ符号化処理を使用して、結果文字列に名前を追加します。"
    },
    {
      "indent": 9,
      "text": "+ if the member/value is empty, append the ifemp string to the result string; otherwise, append \"=\" and the member/value to the result string, after pct-encoding any member/value characters that are not in the allow set.",
      "ja": "メンバー/値が空の場合+、結果文字列にifemp文字列を追加。そうでない場合は、「=」追加し、結果の文字列にメンバ/値、許可セットに含まれていないPCT-コードする任意のメンバー/値の文字の後に。"
    },
    {
      "indent": 6,
      "text": "* else if named is false, then",
      "ja": "*他の名前の場合は、その後、偽であります"
    },
    {
      "indent": 9,
      "text": "+ if this is a list, append each defined list member to the result string, after pct-encoding any characters that are not in the allow set, with the sep string appended to the result between each defined list member.",
      "ja": "+このリストである場合、各定義されたリストのメンバーとの間の結果に追加9月列と、許可セットに含まれない任意の文字を、PCTは、符号化した後、結果の文字列に定義された各リストのメンバを追加します。"
    },
    {
      "indent": 9,
      "text": "+ if this is an array of (name, value) pairs, append each pair with a defined value to the result string as \"name=value\", after pct-encoding any characters that are not in the allow set, with the sep string appended to the result between each defined pair.",
      "ja": "+これは（名前、値）ペアの配列である場合、9月列と、許可セットに含まれていないPCT-コードする任意の文字の後に、「名前=値」として結果の文字列に定義された値との各ペアを追加定義された各対の間の結果に付加。"
    },
    {
      "indent": 3,
      "text": "When the variable-list for this expression is exhausted, go back to scan the remainder of the template.",
      "ja": "この表現のための変数リストが使い尽くされた場合、テンプレートの残りの部分をスキャンするために戻って行きます。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Joe Gregorio Google",
      "ja": "ジョー・グレゴリオグーグル"
    },
    {
      "indent": 3,
      "text": "EMail: joe@bitworking.org URI: http://bitworking.org/",
      "ja": "電子メール：joe@bitworking.org URI：http://bitworking.org/"
    },
    {
      "indent": 3,
      "text": "Roy T. Fielding Adobe Systems Incorporated",
      "ja": "ロイT.フィールディングAdobe Systems Incorporated（アドビシステムズ社）"
    },
    {
      "indent": 3,
      "text": "EMail: fielding@gbiv.com URI: http://roy.gbiv.com/",
      "ja": "電子メール：fielding@gbiv.com URI：http://roy.gbiv.com/"
    },
    {
      "indent": 3,
      "text": "Marc Hadley The MITRE Corporation",
      "ja": "マルク・ハドレーザ・MITRE社"
    },
    {
      "indent": 3,
      "text": "EMail: mhadley@mitre.org URI: http://mitre.org/",
      "ja": "電子メール：mhadley@mitre.org URI：http://mitre.org/"
    },
    {
      "indent": 3,
      "text": "Mark Nottingham Rackspace",
      "ja": "マーク・ノッティンガムRackspaceの"
    },
    {
      "indent": 3,
      "text": "EMail: mnot@mnot.net URI: http://www.mnot.net/",
      "ja": "電子メール：mnot@mnot.net URI：http://www.mnot.net/"
    },
    {
      "indent": 3,
      "text": "David Orchard Salesforce.com",
      "ja": "デビッド・オーチャードSalesforce.com"
    },
    {
      "indent": 3,
      "text": "EMail: orchard@pacificspirit.com URI: http://www.pacificspirit.com/",
      "ja": "電子メール：orchard@pacificspirit.com URI：http://www.pacificspirit.com/"
    }
  ]
}