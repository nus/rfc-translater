{
  "title": {
    "text": "RFC 6143 - The Remote Framebuffer Protocol",
    "ja": "RFC 6143 - リモートフレームバッファプロトコル"
  },
  "number": 6143,
  "created_at": "2019-10-29 01:37:41.077749+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     T. Richardson\nRequest for Comments: 6143                                     J. Levine\nCategory: Informational                                     RealVNC Ltd.\nISSN: 2070-1721                                               March 2011",
      "raw": true
    },
    {
      "indent": 20,
      "text": "The Remote Framebuffer Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "RFB (\"remote framebuffer\") is a simple protocol for remote access to graphical user interfaces that allows a client to view and control a window system on another computer. Because it works at the framebuffer level, RFB is applicable to all windowing systems and applications. This document describes the protocol used to communicate between an RFB client and RFB server. RFB is the protocol used in VNC.",
      "ja": "RFB（「リモートフレームバッファ」）は、クライアントが別のコンピュータ上でウィンドウシステムを表示および制御することを可能にするグラフィカル・ユーザ・インターフェースへのリモートアクセスのための単純なプロトコルです。それはフレームバッファレベルで動作するため、RFBは、すべてのウィンドウシステムやアプリケーションに適用されます。この文書では、RFBクライアントとRFBサーバー間の通信に使用されるプロトコルについて説明します。 RFBは、VNCで使用されるプロトコルです。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6143.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6143で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2011 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n2.  Initial Connection . . . . . . . . . . . . . . . . . . . . . .  4\n3.  Display Protocol . . . . . . . . . . . . . . . . . . . . . . .  4\n4.  Input Protocol . . . . . . . . . . . . . . . . . . . . . . . .  5\n5.  Representation of Pixel Data . . . . . . . . . . . . . . . . .  5\n6.  Protocol Versions and Extensions . . . . . . . . . . . . . . .  6\n7.  Protocol Messages  . . . . . . . . . . . . . . . . . . . . . .  7\n  7.1.  Handshake Messages . . . . . . . . . . . . . . . . . . . .  8\n    7.1.1.  ProtocolVersion Handshake  . . . . . . . . . . . . . .  8\n    7.1.2.  Security Handshake . . . . . . . . . . . . . . . . . .  8\n    7.1.3.  SecurityResult Handshake . . . . . . . . . . . . . . . 10\n  7.2.  Security Types . . . . . . . . . . . . . . . . . . . . . . 10\n    7.2.1.  None . . . . . . . . . . . . . . . . . . . . . . . . . 10\n    7.2.2.  VNC Authentication . . . . . . . . . . . . . . . . . . 10\n  7.3.  Initialization Messages  . . . . . . . . . . . . . . . . . 11\n    7.3.1.  ClientInit . . . . . . . . . . . . . . . . . . . . . . 11\n    7.3.2.  ServerInit . . . . . . . . . . . . . . . . . . . . . . 11\n  7.4.  Pixel Format Data Structure  . . . . . . . . . . . . . . . 12\n  7.5.  Client-to-Server Messages  . . . . . . . . . . . . . . . . 13\n    7.5.1.  SetPixelFormat . . . . . . . . . . . . . . . . . . . . 13\n    7.5.2.  SetEncodings . . . . . . . . . . . . . . . . . . . . . 14\n    7.5.3.  FramebufferUpdateRequest . . . . . . . . . . . . . . . 15\n    7.5.4.  KeyEvent . . . . . . . . . . . . . . . . . . . . . . . 16\n    7.5.5.  PointerEvent . . . . . . . . . . . . . . . . . . . . . 19\n    7.5.6.  ClientCutText  . . . . . . . . . . . . . . . . . . . . 19\n  7.6.  Server-to-Client Messages  . . . . . . . . . . . . . . . . 20\n    7.6.1.  FramebufferUpdate  . . . . . . . . . . . . . . . . . . 20\n    7.6.2.  SetColorMapEntries . . . . . . . . . . . . . . . . . . 21\n    7.6.3.  Bell . . . . . . . . . . . . . . . . . . . . . . . . . 22\n    7.6.4.  ServerCutText  . . . . . . . . . . . . . . . . . . . . 22\n  7.7.  Encodings  . . . . . . . . . . . . . . . . . . . . . . . . 22\n    7.7.1.  Raw Encoding . . . . . . . . . . . . . . . . . . . . . 23\n    7.7.2.  CopyRect Encoding  . . . . . . . . . . . . . . . . . . 23\n    7.7.3.  RRE Encoding . . . . . . . . . . . . . . . . . . . . . 23\n    7.7.4.  Hextile Encoding . . . . . . . . . . . . . . . . . . . 24\n    7.7.5.  TRLE . . . . . . . . . . . . . . . . . . . . . . . . . 27\n    7.7.6.  ZRLE . . . . . . . . . . . . . . . . . . . . . . . . . 30\n  7.8.  Pseudo-Encodings . . . . . . . . . . . . . . . . . . . . . 30\n    7.8.1.  Cursor Pseudo-Encoding . . . . . . . . . . . . . . . . 30\n    7.8.2.  DesktopSize Pseudo-Encoding  . . . . . . . . . . . . . 31\n8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 31\n  8.1.  RFB Security Types . . . . . . . . . . . . . . . . . . . . 32\n    8.1.1.  Registry Name  . . . . . . . . . . . . . . . . . . . . 32\n    8.1.2.  Registry Contents  . . . . . . . . . . . . . . . . . . 32\n  8.2.  Client-to-Server Message Types . . . . . . . . . . . . . . 32\n    8.2.1.  Registry Name  . . . . . . . . . . . . . . . . . . . . 32",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    8.2.2.  Registry Contents  . . . . . . . . . . . . . . . . . . 32\n  8.3.  Server-to-Client Message Types . . . . . . . . . . . . . . 33\n    8.3.1.  Registry Name  . . . . . . . . . . . . . . . . . . . . 33\n    8.3.2.  Registry Contents  . . . . . . . . . . . . . . . . . . 33\n  8.4.  RFB Encoding Types . . . . . . . . . . . . . . . . . . . . 34\n    8.4.1.  Registry Name  . . . . . . . . . . . . . . . . . . . . 34\n    8.4.2.  Registry Contents  . . . . . . . . . . . . . . . . . . 34\n9.  Security . . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n10. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 36\n11. References . . . . . . . . . . . . . . . . . . . . . . . . . . 36\n  11.1. Normative References . . . . . . . . . . . . . . . . . . . 36\n  11.2. Informative References . . . . . . . . . . . . . . . . . . 36\nAppendix A.  Differences in Earlier Protocol Versions  . . . . . . 38\n  A.1.  Differences in the Version 3.3 Protocol  . . . . . . . . . 38\n  A.2.  Differences in the Version 3.7 Protocol  . . . . . . . . . 38",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "RFB (\"remote framebuffer\") is a simple protocol for remote access to graphical user interfaces. Because it works at the framebuffer level, it is applicable to all windowing systems and applications, including X11, Windows, and Macintosh. RFB is the protocol used in VNC. The protocol is widely implemented and has had fairly good interoperability.",
      "ja": "RFB（「リモートフレームバッファ」）は、グラフィカル・ユーザ・インターフェースへのリモートアクセスのための単純なプロトコルです。それはフレームバッファレベルで動作するので、X11、Windows、およびMacintosh版を含むすべてのウィンドウシステムやアプリケーションに適用可能です。 RFBは、VNCで使用されるプロトコルです。プロトコルが広く実装されており、かなり良い相互運用性を持っていました。"
    },
    {
      "indent": 3,
      "text": "The remote endpoint where the user sits (typically with a display, keyboard, and pointer) is called the RFB client or viewer. The endpoint where changes to the framebuffer originate (i.e., the windowing system and applications) is known as the RFB server.",
      "ja": "ユーザが（典型的には、ディスプレイ、キーボード、ポインタで）座ってリモートエンドポイントは、RFBクライアントまたはビューアと呼ばれています。フレームバッファへの変更は、発信エンドポイント（すなわち、ウィンドウシステムおよびアプリケーション）はRFBサーバとして知られています。"
    },
    {
      "indent": 3,
      "text": "RFB is a \"thin client\" protocol. The emphasis in the design of the RFB protocol is to make very few requirements of the client. In this way, clients can run on the widest range of hardware, and the task of implementing a client is made as simple as possible.",
      "ja": "RFBは、「シンクライアント」プロトコルです。 RFBプロトコルの設計の重点は、クライアントの非常にいくつかの要件を作ることです。このように、クライアントは、ハードウェアの広い範囲で実行することができ、およびクライアントを実装する作業は、できるだけ簡単に行うことができます。"
    },
    {
      "indent": 3,
      "text": "The protocol also makes the client stateless. If a client disconnects from a given server and subsequently reconnects to that same server, the state of the user interface is preserved. Furthermore, a different client endpoint can be used to connect to the same RFB server. At the new endpoint, the user will see exactly the same graphical user interface as at the original endpoint. In effect, the interface to the user's applications becomes completely mobile. Wherever suitable network connectivity exists, the user can access their own personal applications, and the state of these applications is preserved between accesses from different locations. This provides the user with a familiar, uniform view of the computing infrastructure wherever they go.",
      "ja": "このプロトコルは、クライアントがステートレスになります。クライアントが特定のサーバーから切断され、その後、同じサーバーに再接続する場合は、ユーザーインターフェースの状態が保存されています。さらに、別のクライアントエンドポイントは、同じRFBサーバーに接続するために使用することができます。新しいエンドポイントで、ユーザは、元のエンドポイントとまったく同じグラフィカル・ユーザー・インターフェースが表示されます。実際には、ユーザーのアプリケーションへのインタフェースは完全にモバイルになります。適切なネットワーク接続が存在する場合はいつでも、ユーザーは自分の個人的なアプリケーションにアクセスすることができ、これらのアプリケーションの状態が異なる場所からのアクセスの間で保存されています。これは、彼らがどこへ行ってコンピューティング・インフラストラクチャのおなじみの、均一な表示をユーザに提供します。"
    },
    {
      "indent": 3,
      "text": "The RFB protocol has evolved over the past decade, and has been implemented several times, including at least one open source version. This document describes the RFB protocol as actually implemented, so that future implementers can interoperate with existing clients and servers.",
      "ja": "RFBプロトコルは、過去10年間進化してきました、そして少なくとも1つのオープンソース版を含め、数回実施されています。この文書では、将来の実装者は、既存のクライアントとサーバとの相互運用できるように、など実際に、実装RFBプロトコルを記述します。"
    },
    {
      "indent": 0,
      "text": "2. Initial Connection",
      "section_title": true,
      "ja": "2.初期接続"
    },
    {
      "indent": 3,
      "text": "An RFB server is typically a long-lived process that maintains the state of a framebuffer. RFB clients typically connect, communicate with the server for a period of time to use and manipulate the framebuffer, then disconnect. A subsequent RFB session will then pick up where a prior session left off, with the state of the framebuffer intact.",
      "ja": "RFBサーバは、一般的にフレームバッファの状態を維持長寿命プロセスです。 RFBクライアントは一般的に外して、フレームバッファを使用して操作するための一定の期間のためにサーバーと通信し、接続します。前のセッションはそのままフレームバッファの状態と、中断したところ、後続RFBセッションは、その後、ピックアップします。"
    },
    {
      "indent": 3,
      "text": "An RFB client contacts the server on TCP port 5900. On systems with multiple RFB servers, server N typically listens on port 5900+N, analogous to the way that X Window servers listen on port 6000+N.",
      "ja": "RFBクライアントの連絡先の複数のRFBサーバーとのシステムではTCPポート5900上のサーバー、サーバーN通常のX Windowサーバはポート6000 + Nでリッスンする方法に類似して、ポート5900 + Nで待機します。"
    },
    {
      "indent": 3,
      "text": "Some browser-based clients use a Java application to run the RFB protocol. RFB servers sometimes provide a simple HTTP server on port 5800 that provides the requisite Java applet.",
      "ja": "いくつかのブラウザベースのクライアントは、RFBプロトコルを実行するためにJavaアプリケーションを使用します。 RFBサーバは、時々、必要なJavaアプレットを提供し、ポート5800上の単純なHTTPサーバーを提供しています。"
    },
    {
      "indent": 3,
      "text": "In some cases, the initial roles of the client and server are reversed, with the RFB client listening on port 5500, and the RFB server contacting the RFB client. Once the connection is established, the two sides take their normal roles, with the RFB server sending the first handshake message.",
      "ja": "いくつかのケースでは、クライアントとサーバの初期役割は、ポート5500でリッスンRFBクライアント、およびRFBクライアントとの接触RFBサーバで、逆になっています。接続が確立されると、双方はRFBサーバが最初のハンドシェイクメッセージを送信すると、その正常な役割を取ります。"
    },
    {
      "indent": 3,
      "text": "Note that the only port number assigned by IANA for RFB is port 5900, so RFB clients and servers should avoid using other port numbers unless they are communicating with servers or clients known to use the non-standard ports.",
      "ja": "彼らは非標準ポートを使用することが知られているサーバーまたはクライアントと通信している場合を除きRFBクライアントとサーバーは、他のポート番号を使用して避ける必要がありますので、RFBのためにIANAによって割り当てられたポート番号だけがポート5900であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3. Display Protocol",
      "section_title": true,
      "ja": "3.ディスプレイプロトコル"
    },
    {
      "indent": 3,
      "text": "The display side of the protocol is based around a single graphics primitive: \"put a rectangle of pixel data at a given x,y position\". This might seem an inefficient way of drawing many user interface components. However, allowing various different encodings for the pixel data gives us a large degree of flexibility in how to trade off various parameters such as network bandwidth, client drawing speed, and server processing speed.",
      "ja": "プロトコルの表示側が単一の図形要素の周りに基づいています「とは、所与のX、Y位置の画素データの矩形を入れます」。これは、多くのユーザインタフェースコンポーネントを描くのは非効率的な方法に思えるかもしれません。しかし、ピクセルデータのための様々な異なるエンコーディングを可能することは私たちに、このようなネットワークの帯域幅、クライアントの描画速度、およびサーバーの処理速度など様々なパラメータをトレードオフする方法の自由度を与える大規模な。"
    },
    {
      "indent": 3,
      "text": "A sequence of these rectangles makes a framebuffer update (simply referred to here as \"update\"). An update represents a change from one valid framebuffer state to another, so in some ways is similar to a frame of video. The rectangles in an update are usually but not always disjoint.",
      "ja": "これらの長方形のシーケンスは、（単に、「更新」とここで呼ばれる）フレームバッファの更新を行います。更新は、別の有効なフレームバッファの状態からの変化を表しているので、いくつかの方法で、ビデオのフレームに似ています。更新中の長方形は通常、常にではないが互いに素です。"
    },
    {
      "indent": 3,
      "text": "The update protocol is demand-driven by the client. That is, an update is only sent from the server to the client in response to an explicit request from the client. This gives the protocol an adaptive quality. The slower the client and the network are, the lower the rate of updates. With typical applications, changes to the same area of the framebuffer tend to happen soon after one another. With a slow client or network, transient states of the framebuffer can be ignored, resulting in less network traffic and less drawing for the client.",
      "ja": "更新プロトコルは、需要主導型のクライアントです。これは、更新が唯一のクライアントからの明示的な要求に応じてサーバからクライアントに送信される、です。これは、プロトコルに適応品質を提供します。クライアントとネットワーク遅くは、アップデートの低いレートです。典型的なアプリケーションでは、フレームバッファの同じ領域への変更は、互いに直後に発生する傾向があります。低速なクライアントまたはネットワークでは、フレームバッファの過渡状態が少なく、ネットワークトラフィックおよびクライアントの少ない描画が得られ、無視することができます。"
    },
    {
      "indent": 3,
      "text": "After the initial handshake sequence, the protocol is asynchronous, with each side sending messages as needed. The server must not send unsolicited updates. An update must only be sent in response to a request from the client. When several requests from the client are outstanding, a single update from the server may satisfy all of them.",
      "ja": "最初のハンドシェイクシーケンスの後、プロトコルは、必要に応じてメッセージを送信する各辺と、非同期です。サーバが迷惑更新を送信してはなりません。更新は、クライアントからの要求に応じて送信する必要があります。クライアントから複数の要求が傑出している場合は、サーバからの単一の更新は、それらのすべてを満たすようにしてもよいです。"
    },
    {
      "indent": 0,
      "text": "4. Input Protocol",
      "section_title": true,
      "ja": "4.入力プロトコル"
    },
    {
      "indent": 3,
      "text": "The input side of the protocol is based on a standard workstation model of a keyboard and multi-button pointing device. Input events are simply sent to the server by the client whenever the user presses a key or pointer button, or whenever the pointing device is moved. These input events can also be synthesized from other non-standard I/O devices. For example, a pen-based handwriting recognition engine might generate keyboard events.",
      "ja": "プロトコルの入力側は、キーボードとマルチボタンポインティングデバイスの標準的なワークステーションモデルに基づいています。ユーザーがキーまたはポインタボタンを押すたび、またはポインティングデバイスを移動したときに入力イベントは、単純に、クライアントからサーバーに送信されます。これらの入力イベントは、他の非標準のI / Oデバイスから合成することができます。例えば、ペンベース手書き文字認識エンジンは、キーボードイベントを生成することがあります。"
    },
    {
      "indent": 0,
      "text": "5. Representation of Pixel Data",
      "section_title": true,
      "ja": "画素データの5表現"
    },
    {
      "indent": 3,
      "text": "Initial interaction between the RFB client and server involves a negotiation of the format and encoding of the pixel data that will be sent. This negotiation has been designed to make the job of the client as easy as possible. The server must always be able to supply pixel data in the form the client wants. However, if the client is able to cope equally with several different formats or encodings, it may choose one that is easier for the server to produce.",
      "ja": "RFBクライアントとサーバの間の初期の相互作用が送られるピクセルデータのフォーマットとエンコーディングの交渉を必要とします。この交渉は、可能な限り、クライアントの仕事は同じくらい簡単にするために設計されています。サーバは常にクライアントが望む形でピクセルデータを供給することができなければなりません。クライアントは、いくつかの異なるフォーマットやエンコーディングと同じように対処することができますしかし、もし、それがサーバが生成しやすいものを選択することがあります。"
    },
    {
      "indent": 3,
      "text": "Pixel format refers to the representation of individual colors by pixel values. The most common pixel formats are 24-bit or 16-bit \"true color\", where bit-fields within the pixel value translate directly to red, green, and blue intensities, and 8-bit \"color map\" (palette) where the pixel values are indices into a 256-entry table that contains the actual RGB intensities.",
      "ja": "ピクセルフォーマットは、ピクセル値によって各色の表現を意味します。最も一般的なピクセルフォーマットは、ピクセル値内のビット・フィールドは、赤、緑、青の強度に直接変換する24ビットまたは16ビットの「真の色」、および8ビットの「カラーマップ」（パレット）である場合ピクセル値は、実際のRGB強度が含ま256エントリテーブルへのインデックスです。"
    },
    {
      "indent": 3,
      "text": "Encoding refers to the way that a rectangle of pixel data will be sent to the client. Every rectangle of pixel data is prefixed by a header giving the X,Y position of the rectangle on the screen, the width and height of the rectangle, and an encoding type which specifies the encoding of the pixel data. The data itself then follows using the specified encoding.",
      "ja": "符号化は、ピクセルデータの矩形がクライアントに送信される方法を指します。ピクセル・データのすべての矩形は、画面上の長方形のX、Y位置、矩形の幅と高さ、及び画素データの符号化を指定する符号化タイプを与えるヘッダが前置されます。データ自体は、その後、指定されたエンコーディングを使用して以下。"
    },
    {
      "indent": 3,
      "text": "The encoding types defined at present are: Raw, CopyRect, RRE, TRLE, Hextile, and ZRLE. In practice, current servers use the ZRLE, TRLE, and CopyRect encodings since they provide the best compression for typical desktops. Clients generally also support Hextile, which was often used by older RFB servers that didn't support TRLE. See Section 7.7 for a description of each of the encodings.",
      "ja": "現時点で定義された符号化タイプがある：生、CopyRect、RRE、TRLE、Hextile、及びZRLE。彼らは典型的なデスクトップのための最良の圧縮を提供するので実際には、現在のサーバーがZRLE、TRLE、およびCopyRectエンコーディングを使用します。クライアントは一般的にも、多くの場合、TRLEをサポートしていませんでした古いRFBサーバによって使用されたHextileを、サポートしています。エンコーディングのそれぞれの説明については、セクション7.7を参照してください。"
    },
    {
      "indent": 0,
      "text": "6. Protocol Versions and Extensions",
      "section_title": true,
      "ja": "6.プロトコルのバージョンと拡張機能"
    },
    {
      "indent": 3,
      "text": "The RFB protocol has evolved through three published versions: 3.3, 3.7, and 3.8. This document primarily documents the final version 3.8; differences from the earlier versions, which are minor, are described in Appendix A. Under no circumstances should an implementation use a protocol version number other than one defined in this document. Over the years, different implementations of RFB have attempted to use different version numbers to add undocumented extensions, with the result being that to interoperate, any unknown 3.x version must be treated as 3.3, so it is not possible to add a 3.9 or higher version in a backward-compatible fashion. Future evolution of RFB will use 4.x version numbers.",
      "ja": "3.3、3.7、および3.8：RFBプロトコルは、三の公開バージョンを通じて発展してきました。このドキュメントでは、主に最終バージョン3.8を記録し、実装は、本文書で定義されたもの以外のプロトコルバージョン番号を使用する必要がマイナーである以前のバージョンの相違点は、いかなる状況においても、付録Aに記載されています。長年にわたり、RFBの異なる実装が文書化されていない拡張子を追加するために、異なるバージョン番号を使用しようとしました、結果はそれを相互運用することで、未知の3.xバージョンは3.3として扱われなければならないので、3.9またはを追加することはできません下位互換性の方法で上位バージョン。 RFBの今後の進化は、4.xのバージョン番号を使用します。"
    },
    {
      "indent": 3,
      "text": "It is not necessary to change the protocol version number to extend the protocol. The protocol can be extended within an existing version by:",
      "ja": "プロトコルを拡張したプロトコルのバージョン番号を変更する必要はありません。プロトコルにより、既存のバージョンの中に拡張することができます。"
    },
    {
      "indent": 3,
      "text": "New encodings A new encoding type can be added to the protocol relatively easily while maintaining compatibility with existing clients and servers. Existing servers will simply ignore requests for a new encoding that they don't support. Existing clients will never request the new encoding so will never see rectangles encoded that way.",
      "ja": "新しいエンコーディングは新しいエンコーディングタイプは、既存のクライアントとサーバとの互換性を維持しながら、比較的容易にプロトコルに追加することができます。既存のサーバーは、単に彼らがサポートしていない新しいエンコーディングのための要求を無視します。既存のクライアントはその長方形はそのようにエンコードされ見ることはありません新しいエンコードを要求することはありません。"
    },
    {
      "indent": 3,
      "text": "Pseudo-encodings In addition to genuine encodings, a client can request a \"pseudo-encoding\" to declare to the server that it supports a certain extension to the protocol. A server that does not support the extension will simply ignore the pseudo-encoding. Note that this means the client must assume that the server does not support the extension until it gets some extension-specific confirmation from the server. See Section 7.8 for a description of current pseudo-encodings.",
      "ja": "本物のエンコーディングに加えて擬似エンコーディング、クライアントは、プロトコルに特定の拡張子をサポートするサーバーに宣言する「擬似エンコーディング」を要求することができます。拡張機能をサポートしていないサーバーは、単に擬似エンコーディングを無視します。これは、クライアントがサーバーからいくつかの拡張固有の確認を取得するまで、サーバが拡張をサポートしていないと仮定しなければならないことを意味することに注意してください。現在の擬似エンコーディングの説明については、7.8項を参照してください。"
    },
    {
      "indent": 3,
      "text": "New security types Adding a new security type gives full flexibility in modifying the behavior of the protocol without sacrificing compatibility with existing clients and servers. A client and server that agree on a new security type can effectively talk whatever protocol they like after that -- it doesn't necessarily have to be anything like the RFB protocol.",
      "ja": "新しいセキュリティタイプの新しいセキュリティタイプを追加し、既存のクライアントとサーバとの互換性を犠牲にすることなく、プロトコルの動作を変更するに完全な柔軟性を提供します。新しいセキュリティの種類に同意し、クライアントとサーバは、効果的に、その後、彼らは好きなプロトコル話をすることができます - それは必ずしもRFBプロトコルのようなものである必要はありません。"
    },
    {
      "indent": 3,
      "text": "See Section 8 for information on obtaining an ID for a new encoding or security type.",
      "ja": "新しいエンコーディングまたはセキュリティタイプのIDの取得については、セクション8を参照してください。"
    },
    {
      "indent": 0,
      "text": "7. Protocol Messages",
      "section_title": true,
      "ja": "7.プロトコルメッセージ"
    },
    {
      "indent": 3,
      "text": "The RFB protocol can operate over any reliable transport, either byte-stream or message based. It usually operates over a TCP/IP connection. There are three stages to the protocol. First is the handshaking phase, the purpose of which is to agree upon the protocol version and the type of security to be used. The second stage is an initialization phase where the client and server exchange ClientInit and ServerInit messages. The final stage is the normal protocol interaction. The client can send whichever messages it wants, and may receive messages from the server as a result. All these messages begin with a message-type byte, followed by message-specific data.",
      "ja": "RFBプロトコルは、バイトストリームまたはメッセージベースのいずれかを任意の信頼性の高いトランスポートを介して動作することができます。これは通常、TCP / IP接続上で動作します。プロトコルへの3つの段階があります。最初のプロトコルバージョンとセキュリティの種類に使用されることに同意することでその目的は、ハンドシェイクフェーズは、あります。第二段階は、クライアントとサーバーの交換ClientInitとのServerInitメッセージ初期化フェーズです。最終段階は、通常のプロトコル相互作用です。クライアントは、それが望んでいる方のメッセージを送信することができ、結果として、サーバーからメッセージを受け取ることができます。すべてのこれらのメッセージは、メッセージ固有のデータに続くメッセージ型バイト、で始まります。"
    },
    {
      "indent": 3,
      "text": "The following descriptions of protocol messages use the basic types U8, U16, U32, S8, S16, and S32. These represent, respectively, 8-, 16-, and 32-bit unsigned integers and 8-, 16-, and 32-bit signed integers. All multiple-byte integers (other than pixel values themselves) are in big endian order (most significant byte first). Some messages use arrays of the basic types, with the number of entries in the array determined from fields preceding the array.",
      "ja": "プロトコルメッセージの以下の説明は、基本的なタイプU8、U16、U32、S8、S16、およびS32を使用しています。これらは、それぞれ、8ビット、16ビット、および32ビット符号なし整数と8ビット、16ビット、および32ビットの符号付き整数を表します。 （ピクセル値自体以外の）すべての複数バイトの整数は、ビッグエンディアン（最上位バイト）です。一部のメッセージは、アレイの前のフィールドから決定アレイ内のエントリの数と、基本的な型の配列を使用します。"
    },
    {
      "indent": 3,
      "text": "The type PIXEL means a pixel value of bytesPerPixel bytes, where bytesPerPixel is the number of bits-per-pixel divided by 8. The bits-per-pixel is agreed by the client and server, either in the ServerInit message (Section 7.3.2) or a SetPixelFormat message (Section 7.5.1). See Section 7.4 for the detailed description of the pixel format.",
      "ja": "型画素はbytesPerPixelのいずれかのServerInitメッセージ（セクション7.3.2で、クライアントとサーバによってビットあたりの画素8ビット・パー・ピクセルで割った数合意されているbytesPerPixelバイトの画素値を、手段）またはSetPixelFormatメッセージ（セクション7.5.1）。ピクセルフォーマットの詳細については、セクション7.4を参照。"
    },
    {
      "indent": 3,
      "text": "Several message formats include padding bits or bytes. For maximum compatibility, messages should be generated with padding set to zero, but message recipients should not assume padding has any particular value.",
      "ja": "いくつかのメッセージフォーマットは、パディングビット又はバイトを含みます。最大の互換性のために、メッセージがゼロパディングセットを用いて生成されなければならないが、メッセージの受信者は、パディングは、任意の特定の値を持っていると仮定してはなりません。"
    },
    {
      "indent": 0,
      "text": "7.1. Handshake Messages",
      "section_title": true,
      "ja": "7.1. ハンドシェイクメッセージ"
    },
    {
      "indent": 3,
      "text": "When an RFB client and server first connect, they exchange a sequence of handshake messages that determine the protocol version, what type of connection security (if any) to use, a password check if the security type requires it, and some initialization information.",
      "ja": "RFBクライアントとサーバは、最初に接続すると、彼らはセキュリティの種類がそれを必要とする場合、パスワードのチェックを使用するように接続セキュリティ（もしあれば）の種類、プロトコルのバージョンを確認握手メッセージのシーケンスを交換し、いくつかの初期化情報。"
    },
    {
      "indent": 0,
      "text": "7.1.1. ProtocolVersion Handshake",
      "section_title": true,
      "ja": "7.1.1.  protocolVersion握手"
    },
    {
      "indent": 3,
      "text": "Handshaking begins by the server sending the client a ProtocolVersion message. This lets the client know which is the highest RFB protocol version number supported by the server. The client then replies with a similar message giving the version number of the protocol that should actually be used (which may be different to that quoted by the server). A client should never request a protocol version higher than that offered by the server. It is intended that both clients and servers may provide some level of backwards compatibility by this mechanism.",
      "ja": "ハンドシェイクは、クライアントはprotocolVersionメッセージを送信するサーバによって開始されます。これは、サーバーでサポートされている最高RFBプロトコルのバージョン番号であるクライアントのノウハウをすることができます。クライアントは次に、（サーバによって引用ものと異なっていてもよい）、実際に使用されるべきプロトコルのバージョン番号を与えるようなメッセージで応答します。クライアントは、サーバによって提供されるよりも高いプロトコルバージョンを要求してはいけません。クライアントとサーバの両方が、この機構により、後方互換性のいくつかのレベルを提供することができることが意図されています。"
    },
    {
      "indent": 3,
      "text": "The only published protocol versions at this time are 3.3, 3.7, and 3.8. Other version numbers are reported by some servers and clients, but should be interpreted as 3.3 since they do not implement the different handshake in 3.7 or 3.8. Addition of a new encoding or pseudo-encoding type does not require a change in protocol version, since a server can simply ignore encodings it does not understand.",
      "ja": "この時点でのみ公表されたプロトコルのバージョンは3.3、3.7、および3.8です。その他のバージョン番号は、一部のサーバーとクライアントによって報告されているが、それらは、3.7または3.8で異なるハンドシェークを実装していないので、3.3として解釈されるべきです。サーバは単にそれが理解していないエンコーディングを無視することができますので、新しいエンコーディングまたは擬似エンコードの種類の添加は、プロトコルバージョンの変更を必要としません。"
    },
    {
      "indent": 3,
      "text": "The ProtocolVersion message consists of 12 bytes interpreted as a string of ASCII characters in the format \"RFB xxx.yyy\\n\" where xxx and yyy are the major and minor version numbers, left-padded with zeros:",
      "ja": "protocolVersionメッセージはXXXとYYYはメジャーバージョン番号とマイナーバージョン番号、左パディングゼロではある形式「RFB xxx.yyyする\\ n」でのASCII文字の文字列として解釈さ12バイトで構成される。"
    },
    {
      "indent": 7,
      "text": "RFB 003.008\\n (hex 52 46 42 20 30 30 33 2e 30 30 38 0a)",
      "ja": "RFB 003.008 \\ N（16進数52 46 42 20 30 30 33 2E 30 30 38 0A）"
    },
    {
      "indent": 0,
      "text": "7.1.2. Security Handshake",
      "section_title": true,
      "ja": "7.1.2. セキュリティのハンドシェイク"
    },
    {
      "indent": 3,
      "text": "Once the protocol version has been decided, the server and client must agree on the type of security to be used on the connection. The server lists the security types that it supports:",
      "ja": "プロトコルバージョンが決定された後、サーバーとクライアントが接続で使用するセキュリティの種類に同意しなければなりません。サーバはそれがサポートするセキュリティタイプを示しています。"
    },
    {
      "indent": 3,
      "text": "+--------------------------+-------------+--------------------------+\n| No. of bytes             | Type        | Description              |\n|                          | [Value]     |                          |\n+--------------------------+-------------+--------------------------+\n| 1                        | U8          | number-of-security-types |\n| number-of-security-types | U8 array    | security-types           |\n+--------------------------+-------------+--------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the server listed at least one valid security type supported by the client, the client sends back a single byte indicating which security type is to be used on the connection:",
      "ja": "サーバがクライアントによってサポートされる少なくとも1つの有効なセキュリティの種類を記載されている場合、クライアントは、セキュリティタイプは、接続に使用するかを示す単一のバイトを送り返します："
    },
    {
      "indent": 14,
      "text": "+--------------+--------------+---------------+\n| No. of bytes | Type [Value] | Description   |\n+--------------+--------------+---------------+\n| 1            | U8           | security-type |\n+--------------+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If number-of-security-types is zero, then for some reason the connection failed (e.g., the server cannot support the desired protocol version). This is followed by a string describing the reason (where a string is specified as a length followed by that many ASCII characters):",
      "ja": "数のセキュリティ・タイプがゼロである場合、接続が失敗した何らかの理由（例えば、サーバは、所望のプロトコルバージョンをサポートすることができません）。これは、（文字列は多くのASCII文字が続く長さとして指定されている）理由を説明する文字列が続きます。"
    },
    {
      "indent": 13,
      "text": "+---------------+--------------+---------------+\n| No. of bytes  | Type [Value] | Description   |\n+---------------+--------------+---------------+\n| 4             | U32          | reason-length |\n| reason-length | U8 array     | reason-string |\n+---------------+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The server closes the connection after sending the reason-string.",
      "ja": "サーバは、理由文字列を送信した後、接続を閉じます。"
    },
    {
      "indent": 13,
      "text": "The security types defined in this document are:",
      "ja": "この文書で定義されたセキュリティの種類は次のとおりです。"
    },
    {
      "indent": 22,
      "text": "+--------+--------------------+\n| Number | Name               |\n+--------+--------------------+\n| 0      | Invalid            |\n| 1      | None               |\n| 2      | VNC Authentication |\n+--------+--------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Other security types exist but are not publicly documented.",
      "ja": "他のセキュリティタイプが存在するが、一般に公開されていません。"
    },
    {
      "indent": 3,
      "text": "Once the security-type has been decided, data specific to that security-type follows (see Section 7.2 for details). At the end of the security handshaking phase, the protocol normally continues with the SecurityResult message.",
      "ja": "セキュリティ型が決定されたら、そのセキュリティ・タイプに固有のデータ（詳細は7.2節を参照）に従います。セキュリティのハンドシェイクフェーズの終了時に、プロトコルは通常SecurityResultメッセージを継続します。"
    },
    {
      "indent": 3,
      "text": "Note that after the security handshaking phase, it is possible that further communication is over an encrypted or otherwise altered channel if the two ends agree on an extended security type beyond the ones described here.",
      "ja": "セキュリティハンドシェイクフェーズの後、二つの端部は、ここで説明されたものを超えて延長されたセキュリティタイプに同意する場合は更なる通信は、暗号化または他の方法で改変されたチャネル上にあることが可能であることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "7.1.3. SecurityResult Handshake",
      "section_title": true,
      "ja": "7.1.3.  SecurityResult握手"
    },
    {
      "indent": 3,
      "text": "The server sends a word to inform the client whether the security handshaking was successful.",
      "ja": "サーバは、セキュリティハンドシェイクが成功したかどうかをクライアントに通知するために言葉を送ります。"
    },
    {
      "indent": 15,
      "text": "+--------------+--------------+-------------+\n| No. of bytes | Type [Value] | Description |\n+--------------+--------------+-------------+\n| 4            | U32          | status:     |\n|              | 0            | OK          |\n|              | 1            | failed      |\n+--------------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If successful, the protocol passes to the initialization phase (Section 7.3).",
      "ja": "成功した場合、プロトコルが初期化フェーズ（7.3節）に渡します。"
    },
    {
      "indent": 3,
      "text": "If unsuccessful, the server sends a string describing the reason for the failure, and then closes the connection:",
      "ja": "失敗した場合、サーバーは失敗の理由を説明する文字列を送信し、接続を閉じます。"
    },
    {
      "indent": 13,
      "text": "+---------------+--------------+---------------+\n| No. of bytes  | Type [Value] | Description   |\n+---------------+--------------+---------------+\n| 4             | U32          | reason-length |\n| reason-length | U8 array     | reason-string |\n+---------------+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2. Security Types",
      "section_title": true,
      "ja": "7.2. セキュリティの種類"
    },
    {
      "indent": 3,
      "text": "Two security types are defined here.",
      "ja": "2つのセキュリティタイプは、ここで定義されています。"
    },
    {
      "indent": 0,
      "text": "7.2.1. None",
      "section_title": true,
      "ja": "7.2.1. 無し"
    },
    {
      "indent": 3,
      "text": "No authentication is needed. The protocol continues with the SecurityResult message.",
      "ja": "認証は必要ありません。プロトコルはSecurityResultメッセージに続きます。"
    },
    {
      "indent": 0,
      "text": "7.2.2. VNC Authentication",
      "section_title": true,
      "ja": "7.2.2.  VNC認証"
    },
    {
      "indent": 3,
      "text": "VNC authentication is to be used. The server sends a random 16-byte challenge:",
      "ja": "VNC認証が使用されるべきです。サーバーは、ランダムな16バイトのチャレンジを送信します。"
    },
    {
      "indent": 15,
      "text": "+--------------+--------------+-------------+\n| No. of bytes | Type [Value] | Description |\n+--------------+--------------+-------------+\n| 16           | U8           | challenge   |\n+--------------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The client encrypts the challenge with DES, using a password supplied by the user as the key. To form the key, the password is truncated to eight characters, or padded with null bytes on the right. The client then sends the resulting 16-byte response:",
      "ja": "クライアントは、キーとして、ユーザが入力したパスワードを使用して、DESでのチャレンジを暗号化します。キーを形成するために、パスワードは8つの文字に切り捨てられ、または右にはnullバイトで埋められています。クライアントは、その結果の16バイトの応答を送信します。"
    },
    {
      "indent": 15,
      "text": "+--------------+--------------+-------------+\n| No. of bytes | Type [Value] | Description |\n+--------------+--------------+-------------+\n| 16           | U8           | response    |\n+--------------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The protocol continues with the SecurityResult message.",
      "ja": "プロトコルはSecurityResultメッセージに続きます。"
    },
    {
      "indent": 3,
      "text": "This type of authentication is known to be cryptographically weak and is not intended for use on untrusted networks. Many implementations will want to use stronger security, such as running the session over an encrypted channel provided by IPsec [RFC4301] or SSH [RFC4254].",
      "ja": "このタイプの認証は、暗号弱いことが知られており、信頼できないネットワークで使用するためのものではありません。多くの実装では、このようなIPsecの[RFC4301]またはSSH [RFC4254]が提供する暗号化されたチャネルを介してセッションを実行しているとして、より強力なセキュリティを使用したいと思うでしょう。"
    },
    {
      "indent": 0,
      "text": "7.3. Initialization Messages",
      "section_title": true,
      "ja": "7.3. 初期化メッセージ"
    },
    {
      "indent": 3,
      "text": "Once the client and server agree on and perhaps validate a security type, the protocol passes to the initialization stage. The client sends a ClientInit message. Then, the server sends a ServerInit message.",
      "ja": "クライアントとサーバーが同意し、おそらくセキュリティの種類を確認したら、プロトコルは初期段階に渡します。クライアントはClientInitメッセージを送信します。その後、サーバーはのServerInitメッセージを送信します。"
    },
    {
      "indent": 0,
      "text": "7.3.1. ClientInit",
      "section_title": true,
      "ja": "7.3.1.  ClientInit"
    },
    {
      "indent": 15,
      "text": "+--------------+--------------+-------------+\n| No. of bytes | Type [Value] | Description |\n+--------------+--------------+-------------+\n| 1            | U8           | shared-flag |\n+--------------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Shared-flag is non-zero (true) if the server should try to share the desktop by leaving other clients connected, and zero (false) if it should give exclusive access to this client by disconnecting all other clients.",
      "ja": "それは他のすべてのクライアントを切断することにより、このクライアントへの排他的アクセス権を与える必要がある場合は、サーバーが接続されている他のクライアントを残すことによって、デスクトップを共有しようとすると、0（偽）必要がある場合は、共有フラグが非ゼロ（真）です。"
    },
    {
      "indent": 0,
      "text": "7.3.2. ServerInit",
      "section_title": true,
      "ja": "7.3.2.  ServerInit"
    },
    {
      "indent": 3,
      "text": "After receiving the ClientInit message, the server sends a ServerInit message. This tells the client the width and height of the server's framebuffer, its pixel format, and the name associated with the desktop:",
      "ja": "ClientInitメッセージを受信した後、サーバーはのServerInitメッセージを送信します。これは、クライアントに幅とサーバのフレームバッファの高さは、そのピクセルフォーマット、およびデスクトップに関連付けられている名前を伝えます："
    },
    {
      "indent": 6,
      "text": "+--------------+--------------+------------------------------+\n| No. of bytes | Type [Value] | Description                  |\n+--------------+--------------+------------------------------+\n| 2            | U16          | framebuffer-width in pixels  |\n| 2            | U16          | framebuffer-height in pixels |\n| 16           | PIXEL_FORMAT | server-pixel-format          |\n| 4            | U32          | name-length                  |\n| name-length  | U8 array     | name-string                  |\n+--------------+--------------+------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Server-pixel-format specifies the server's natural pixel format. This pixel format will be used unless the client requests a different format using the SetPixelFormat message (Section 7.5.1).",
      "ja": "サーバー・ピクセル・フォーマットは、サーバの自然のピクセル形式を指定します。クライアントがSetPixelFormatメッセージ（7.5.1）を使用して、異なるフォーマットを要求しない限り、このピクセルのフォーマットが使用されます。"
    },
    {
      "indent": 0,
      "text": "7.4. Pixel Format Data Structure",
      "section_title": true,
      "ja": "7.4. ピクセルフォーマットのデータ構造"
    },
    {
      "indent": 3,
      "text": "Several server-to-client messages include a PIXEL_FORMAT, a 16-byte structure that describes the way a pixel is transmitted.",
      "ja": "いくつかのサーバーからクライアントへのメッセージはPIXEL_FORMAT、ピクセルが送信される方法を説明し、16バイトの構造体が含まれます。"
    },
    {
      "indent": 13,
      "text": "+--------------+--------------+-----------------+\n| No. of bytes | Type [Value] | Description     |\n+--------------+--------------+-----------------+\n| 1            | U8           | bits-per-pixel  |\n| 1            | U8           | depth           |\n| 1            | U8           | big-endian-flag |\n| 1            | U8           | true-color-flag |\n| 2            | U16          | red-max         |\n| 2            | U16          | green-max       |\n| 2            | U16          | blue-max        |\n| 1            | U8           | red-shift       |\n| 1            | U8           | green-shift     |\n| 1            | U8           | blue-shift      |\n| 3            |              | padding         |\n+--------------+--------------+-----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Bits-per-pixel is the number of bits used for each pixel value on the wire. This must be greater than or equal to the depth, which is the number of useful bits in the pixel value. Currently bits-per-pixel must be 8, 16, or 32. Big-endian-flag is non-zero (true) if multi-byte pixels are interpreted as big endian. Although the depth should be consistent with the bits-per-pixel and the various -max values, clients do not use it when interpreting pixel data.",
      "ja": "ピクセルあたりのビット数は、ワイヤ上の各画素値に対して使用されるビットの数です。これは、画素値の有用ビットの数である深さ以上でなければなりません。現在ピクセルあたりのビット数は、8、16、又は32のビッグエンディアンフラグがマルチバイトピクセルはビッグエンディアンとして解釈される場合には（真の）ゼロでなければなりません。深さは、ピクセル単位のビット、および種々の-max値と一致すべきであるピクセルデータを解釈する際、クライアントはそれを使用しません。"
    },
    {
      "indent": 3,
      "text": "If true-color-flag is non-zero (true), then the last six items specify how to extract the red, green, and blue intensities from the pixel value. Red-max is the maximum red value and must be 2^N - 1, where N is the number of bits used for red. Note the -max values are always in big endian order. Red-shift is the number of shifts needed to get the red value in a pixel to the least significant bit. Green-max, green-shift, blue-max, and blue-shift are similar for green and blue. For example, to find the red value (between 0 and red-max) from a given pixel, do the following:",
      "ja": "トゥルーカラーフラグが非ゼロ（真）である場合、最後の6つの項目は、画素値から、赤、緑、及び青の強度を抽出する方法を指定します。赤-maxは最大赤色値であり、2 ^ Nでなければならない -  1、Nは赤に使用されるビットの数です。 -max値はビッグエンディアン順に常に注意してください。赤方偏移は、最下位ビットへピクセルにおける赤色値を取得するために必要なシフトの数です。グリーンマックス、グリーンシフト、青-MAX、およびブルーシフトは、緑と青についても同様です。例えば、所定の画素から（0、赤-MAXの間の）赤色値を見つけるために、次の操作を行います。"
    },
    {
      "indent": 3,
      "text": "o Swap the pixel value according to big-endian-flag, e.g., if big-endian-flag is zero (false) and host byte order is big endian, then swap.",
      "ja": "ビッグエンディアンフラグがゼロ（偽）であり、ホスト・バイト順序がビッグエンディアンである場合、Oビッグエンディアンフラグに係る画素値を入れ替え、例えば、次にスワップ。"
    },
    {
      "indent": 3,
      "text": "o Shift right by red-shift.",
      "ja": "Oレッドシフトにより右シフト。"
    },
    {
      "indent": 3,
      "text": "o AND with red-max (in host byte order).",
      "ja": "O、および赤-MAXと（ホストバイト順）。"
    },
    {
      "indent": 3,
      "text": "If true-color-flag is zero (false), then the server uses pixel values that are not directly composed from the red, green, and blue intensities, but serve as indices into a color map. Entries in the color map are set by the server using the SetColorMapEntries message (See Section 7.6.2).",
      "ja": "トゥルーカラーフラグがゼロ（偽）である場合、サーバは直接、赤、緑、青の強度から構成されていないピクセル値を使用するが、カラーマップへのインデックスとして働きます。カラーマップ内のエントリをSetColorMapEntriesメッセージを使用してサーバによって設定される（セクション7.6.2参照）。"
    },
    {
      "indent": 0,
      "text": "7.5. Client-to-Server Messages",
      "section_title": true,
      "ja": "7.5. クライアントとサーバーのメッセージ"
    },
    {
      "indent": 3,
      "text": "The client-to-server message types defined in this document are:",
      "ja": "この文書で定義されたクライアントからサーバーへのメッセージの種類は次のとおりです。"
    },
    {
      "indent": 19,
      "text": "+--------+--------------------------+\n| Number | Name                     |\n+--------+--------------------------+\n| 0      | SetPixelFormat           |\n| 2      | SetEncodings             |\n| 3      | FramebufferUpdateRequest |\n| 4      | KeyEvent                 |\n| 5      | PointerEvent             |\n| 6      | ClientCutText            |\n+--------+--------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Other message types exist but are not publicly documented. Before sending a message other than those described in this document, a client must have determined that the server supports the relevant extension by receiving an appropriate extension-specific confirmation from the server.",
      "ja": "他のメッセージタイプが存在するが、一般に公開されていません。この文書に記載されているもの以外のメッセージを送信する前に、クライアントは、サーバがサーバから適切な拡張子固有の確認を受信することにより、関連する拡張機能をサポートすることを決定している必要があります。"
    },
    {
      "indent": 0,
      "text": "7.5.1. SetPixelFormat",
      "section_title": true,
      "ja": "7.5.1.  SetPixelFormat"
    },
    {
      "indent": 3,
      "text": "A SetPixelFormat message sets the format in which pixel values should be sent in FramebufferUpdate messages. If the client does not send a SetPixelFormat message, then the server sends pixel values in its natural format as specified in the ServerInit message (Section 7.3.2).",
      "ja": "SetPixelFormatメッセージは、画素値がFramebufferUpdateメッセージで送信されるべきフォーマットを設定します。クライアントがSetPixelFormatメッセージを送信しない場合のServerInitメッセージ（7.3.2）に指定されているように、サーバはその自然な形式でピクセル値を送信します。"
    },
    {
      "indent": 3,
      "text": "If true-color-flag is zero (false), then this indicates that a \"color map\" is to be used. The server can set any of the entries in the color map using the SetColorMapEntries message (Section 7.6.2). Immediately after the client has sent this message, the contents of the color map are undefined, even if entries had previously been set by the server.",
      "ja": "トゥルーカラーフラグがゼロ（偽）である場合、これは、「カラーマップ」を使用すべきであることを示しています。サーバはSetColorMapEntriesメッセージ（セクション7.6.2）を使用してカラーマップのエントリのいずれかを設定することができます。クライアントはこのメッセージを送信した直後に、カラーマップの内容は、エントリは事前にサーバによって設定されていた場合でも、未定義です。"
    },
    {
      "indent": 14,
      "text": "+--------------+--------------+--------------+\n| No. of bytes | Type [Value] | Description  |\n+--------------+--------------+--------------+\n| 1            | U8 [0]       | message-type |\n| 3            |              | padding      |\n| 16           | PIXEL_FORMAT | pixel-format |\n+--------------+--------------+--------------+",
      "raw": true
    },
    {
      "indent": 15,
      "text": "PIXEL_FORMAT is as described in Section 7.4.",
      "ja": "7.4節で説明したようにPIXEL_FORMATです。"
    },
    {
      "indent": 0,
      "text": "7.5.2. SetEncodings",
      "section_title": true,
      "ja": "7.5.2.  SetEncodings"
    },
    {
      "indent": 3,
      "text": "A SetEncodings message sets the encoding types in which pixel data can be sent by the server. The order of the encoding types given in this message is a hint by the client as to its preference (the first encoding specified being most preferred). The server may or may not choose to make use of this hint. Pixel data may always be sent in raw encoding even if not specified explicitly here.",
      "ja": "SetEncodingsメッセージは、ピクセルデータがサーバによって送信することが可能な符号化タイプを設定します。このメッセージに指定された符号化タイプの順序は、優先（最も好ましい指定された最初の符号化）のように、クライアントがヒントです。サーバーは、またはこのヒントを利用することを選択しない場合があります。ピクセルデータは常にここで明示的に指定されていない場合でも、生のエンコーディングで送信することができます。"
    },
    {
      "indent": 3,
      "text": "In addition to genuine encodings, a client can request \"pseudo-encodings\" to declare to the server that it supports certain extensions to the protocol. A server that does not support the extension will simply ignore the pseudo-encoding. Note that this means the client must assume that the server does not support the extension until it gets some extension-specific confirmation from the server.",
      "ja": "本物のエンコーディングに加えて、クライアントは、プロトコルに特定の拡張子をサポートするサーバーに宣言するための「擬似エンコーディング」を要求することができます。拡張機能をサポートしていないサーバーは、単に擬似エンコーディングを無視します。これは、クライアントがサーバーからいくつかの拡張固有の確認を取得するまで、サーバが拡張をサポートしていないと仮定しなければならないことを意味することに注意してください。"
    },
    {
      "indent": 3,
      "text": "See Section 7.7 for a description of each encoding and Section 7.8 for the meaning of pseudo-encodings.",
      "ja": "擬似エンコーディングの意味については、各符号の説明については、7.7節および7.8節を参照してください。"
    },
    {
      "indent": 11,
      "text": "+--------------+--------------+---------------------+\n| No. of bytes | Type [Value] | Description         |\n+--------------+--------------+---------------------+\n| 1            | U8 [2]       | message-type        |\n| 1            |              | padding             |\n| 2            | U16          | number-of-encodings |\n+--------------+--------------+---------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This is followed by number-of-encodings repetitions of the following:",
      "ja": "これは、次の数の-エンコーディング繰り返しが続いています。"
    },
    {
      "indent": 14,
      "text": "+--------------+--------------+---------------+\n| No. of bytes | Type [Value] | Description   |\n+--------------+--------------+---------------+\n| 4            | S32          | encoding-type |\n+--------------+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.5.3. FramebufferUpdateRequest",
      "section_title": true,
      "ja": "7.5.3.  FramebufferUpdateRequest"
    },
    {
      "indent": 3,
      "text": "A FramebufferUpdateRequest message notifies the server that the client is interested in the area of the framebuffer specified by x-position, y-position, width, and height. The server usually responds to a FramebufferUpdateRequest by sending a FramebufferUpdate. A single FramebufferUpdate may be sent in reply to several FramebufferUpdateRequests.",
      "ja": "FramebufferUpdateRequestメッセージは、クライアントがx位置、y位置、幅、および高さで指定されたフレームバッファの領域に興味を持っているサーバに通知します。サーバは通常FramebufferUpdateを送信することによりFramebufferUpdateRequestに応答します。単一FramebufferUpdateは、いくつかのFramebufferUpdateRequestsへの応答で送信することができます。"
    },
    {
      "indent": 3,
      "text": "The server assumes that the client keeps a copy of all parts of the framebuffer in which it is interested. This means that normally the server only needs to send incremental updates to the client.",
      "ja": "サーバーは、クライアントが、それが興味のあるフレームバッファのすべての部分のコピーを保持していることを前提としています。これは通常、サーバーはクライアントだけに増分更新を送信する必要があることを意味します。"
    },
    {
      "indent": 3,
      "text": "If the client has lost the contents of a particular area that it needs, then the client sends a FramebufferUpdateRequest with incremental set to zero (false). This requests that the server send the entire contents of the specified area as soon as possible. The area will not be updated using the CopyRect encoding.",
      "ja": "クライアントは必要な特定の領域の内容を失った場合、クライアントはゼロ（偽）に増分セットでFramebufferUpdateRequestを送信します。これは、サーバーができるだけ早く指定された領域の全体の内容を送信することを要求します。面積はCopyRectエンコーディングを使用して更新されることはありません。"
    },
    {
      "indent": 3,
      "text": "If the client has not lost any contents of the area in which it is interested, then it sends a FramebufferUpdateRequest with incremental set to non-zero (true). If and when there are changes to the specified area of the framebuffer, the server will send a FramebufferUpdate. Note that there may be an indefinite period between the FramebufferUpdateRequest and the FramebufferUpdate.",
      "ja": "クライアントは、それが興味のある分野のいずれかの内容を失っていない場合、それは非ゼロ（真）への増分セットでFramebufferUpdateRequestを送信します。フレームバッファの指定されたエリアへの変更がある場合とするとき、サーバはFramebufferUpdateを送信します。 FramebufferUpdateRequestとFramebufferUpdate間の不定の期間があってもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "In the case of a fast client, the client may want to regulate the rate at which it sends incremental FramebufferUpdateRequests to avoid excessive network traffic.",
      "ja": "高速なクライアントの場合、クライアントは、それが過剰なネットワークトラフィックを避けるために、増分FramebufferUpdateRequestsを送信する速度を調整することもできます。"
    },
    {
      "indent": 14,
      "text": "+--------------+--------------+--------------+\n| No. of bytes | Type [Value] | Description  |\n+--------------+--------------+--------------+\n| 1            | U8 [3]       | message-type |\n| 1            | U8           | incremental  |\n| 2            | U16          | x-position   |\n| 2            | U16          | y-position   |\n| 2            | U16          | width        |\n| 2            | U16          | height       |\n+--------------+--------------+--------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.5.4. KeyEvent",
      "section_title": true,
      "ja": "7.5.4.  KeyEvent"
    },
    {
      "indent": 3,
      "text": "A KeyEvent message indicates a key press or release. Down-flag is non-zero (true) if the key is now pressed, and zero (false) if it is now released. The key itself is specified using the \"keysym\" values defined by the X Window System, even if the client or server is not running the X Window System.",
      "ja": "KeyEventのメッセージは、キープレスまたはリリースを示します。ダウンフラグそれが今解放されている場合、キーが現在押されている場合は非ゼロ（真）、ゼロ（偽）です。キー自体は、クライアントまたはサーバは、X Window Systemを実行していない場合でも、X Windowシステムで定義された「キーシンボル」の値を使用して指定されています。"
    },
    {
      "indent": 14,
      "text": "+--------------+--------------+--------------+\n| No. of bytes | Type [Value] | Description  |\n+--------------+--------------+--------------+\n| 1            | U8 [4]       | message-type |\n| 1            | U8           | down-flag    |\n| 2            |              | padding      |\n| 4            | U32          | key          |\n+--------------+--------------+--------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For most ordinary keys, the keysym is the same as the corresponding ASCII value. For full details, see [XLIBREF] or see the header file <X11/keysymdef.h> in the X Window System distribution. Some other common keys are:",
      "ja": "最も一般的なキーの場合、キーシムは、対応するASCII値と同じです。完全な詳細については、[XLIBREF]参照またはX Window Systemの分布のヘッダファイル<X11 / keysymdef.h>を参照してください。他のいくつかの一般的なキーは以下のとおりです。"
    },
    {
      "indent": 17,
      "text": "+-----------------+--------------------+\n| Key name        | Keysym value (hex) |\n+-----------------+--------------------+\n| BackSpace       | 0xff08             |\n| Tab             | 0xff09             |\n| Return or Enter | 0xff0d             |\n| Escape          | 0xff1b             |\n| Insert          | 0xff63             |\n| Delete          | 0xffff             |\n| Home            | 0xff50             |\n| End             | 0xff57             |\n| Page Up         | 0xff55             |\n| Page Down       | 0xff56             |\n| Left            | 0xff51             |\n| Up              | 0xff52             |\n| Right           | 0xff53             |\n| Down            | 0xff54             |\n| F1              | 0xffbe             |\n| F2              | 0xffbf             |\n| F3              | 0xffc0             |\n| F4              | 0xffc1             |\n| ...             | ...                |\n| F12             | 0xffc9             |\n| Shift (left)    | 0xffe1             |\n| Shift (right)   | 0xffe2             |\n| Control (left)  | 0xffe3             |\n| Control (right) | 0xffe4             |\n| Meta (left)     | 0xffe7             |\n| Meta (right)    | 0xffe8             |\n| Alt (left)      | 0xffe9             |\n| Alt (right)     | 0xffea             |\n+-----------------+--------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The interpretation of keysyms is a complex area. In order to be as widely interoperable as possible, the following guidelines should be followed:",
      "ja": "キーシムの解釈は複雑な領域です。できるだけ広く相互運用可能であるためには、以下のガイドラインに従ってください。"
    },
    {
      "indent": 3,
      "text": "o The \"shift state\" (i.e., whether either of the Shift keysyms is down) should only be used as a hint when interpreting a keysym. For example, on a US keyboard the '#' character is shifted, but on a UK keyboard it is not. A server with a US keyboard receiving a '#' character from a client with a UK keyboard will not have been sent any shift presses. In this case, it is likely that the server will internally need to simulate a shift press on its local system in order to get a '#' character and not a '3'.",
      "ja": "○「状態をシフト」（すなわち、シフトキーシンボルのいずれかがダウンしているかどうか）キーシンボルを解釈する場合にのみヒントとして使用されるべきです。例えば、USキーボードの上に「＃」文字がシフトしているが、英国のキーボードの上にそうではありません。英国のキーボードを使ってクライアントからの「＃」文字を受信USキーボードを持つサーバーは、任意のシフト機を送ってきたことはありません。この場合、サーバは、内部で「＃」文字ではなく「3」を取得するために、そのローカルシステム上のシフトプレスをシミュレートする必要があると思われます。"
    },
    {
      "indent": 3,
      "text": "o The difference between upper and lower case keysyms is significant. This is unlike some of the keyboard processing in the X Window System that treats them as the same. For example, a server receiving an upper case 'A' keysym without any shift presses should interpret it as an upper case 'A'. Again this may involve an internal simulated shift press.",
      "ja": "O上部及び下部ケースキーシム間の差は有意です。これは、同じようにそれらを扱うX Windowシステムでのキーボード処理の一部とは違っています。例えば、任意の変速機なし大文字「」キーシンボルを受信したサーバは、大文字「A」と解釈すべきです。これも内部のシミュレートされたシフトプレスを含むことができます。"
    },
    {
      "indent": 3,
      "text": "o Servers should ignore \"lock\" keysyms such as CapsLock and NumLock where possible. Instead, they should interpret each character-based keysym according to its case.",
      "ja": "サーバーoは、CapsLockキーやNumLockキーできるだけキーシンボルを「ロック」を無視すべきです。代わりに、彼らはそのケースに応じて各文字ベースのキーシンボルを解釈すべきです。"
    },
    {
      "indent": 3,
      "text": "o Unlike Shift, the state of modifier keys such as Control and Alt should be taken as modifying the interpretation of other keysyms. Note that there are no keysyms for ASCII control characters such as Ctrl-A -- these should be generated by clients sending a Control press followed by an 'a' press.",
      "ja": "Oシフトとは異なり、このような制御やAltキーなどの修飾キーの状態は、他のキーシンボルの解釈を変更するように解釈されるべきです。たとえば、Ctrl-AなどのASCII制御文字のためのキーシンボルが存在しないことに注意してください - これらは「」プレス続いコントロールプレスを送信するクライアントによって生成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o On a client where modifiers like Control and Alt can also be used to generate character-based keysyms, the client may need to send extra \"release\" events in order that the keysym is interpreted correctly. For example, on a German PC keyboard, Ctrl-Alt-Q generates the '@' character. In this case, the client needs to send simulated release events for Control and Alt in order that the '@' character is interpreted correctly, since Ctrl-Alt-@ may mean something completely different to the server.",
      "ja": "O ControlとAltキーなどの修飾子も、文字ベースのキーシンボルを生成するために使用することができるクライアントでは、クライアントは、キーシンボルが正しく解釈されるようにするために、余分な「リリース」イベントを送信する必要があるかもしれません。例えば、ドイツのPCのキーボード上で、Ctrl + Alt + Qは、「@」文字を生成します。この場合、クライアントは、Ctrlキーを押しながらのAlt- @以来、「@」の文字が正しく解釈されるようにするために、ControlとAltキーのためのシミュレートされたリリースイベントを送信する必要があるサーバーへの完全に異なる何かを意味するかもしれません。"
    },
    {
      "indent": 3,
      "text": "o There is no universal standard for \"backward tab\" in the X Window System. On some systems shift+tab gives the keysym \"ISO_Left_Tab\", on others it gives a private \"BackTab\" keysym, and on others it gives \"Tab\" and applications tell from the shift state that it means backward-tab rather than forward-tab. In the RFB protocol, the latter approach is preferred. Clients should generate a shifted Tab rather than ISO_Left_Tab. However, to be backwards-compatible with existing clients, servers should also recognize ISO_Left_Tab as meaning a shifted Tab.",
      "ja": "O Xウィンドウシステムでは、「後方タブ」のための普遍的な標準はありません。いくつかのシステムでシフト+タブのキーシンボル「ISO_Left_Tab」を与え、他人にそれはプライベート「バックタブ」キーシンボルを与え、他人にそれが「タブ」を与え、アプリケーションは、それが下位のタブではなく、将来のタブを意味することをシフト状態から伝えます。 RFBプロトコルでは、後者の方法が好ましいです。クライアントは、むしろISO_Left_Tabよりシフトタブを生成する必要があります。しかし、既存のクライアントとの下位互換性があるように、サーバは、シフトタブを意味するものとしてISO_Left_Tabを認識すべきです。"
    },
    {
      "indent": 3,
      "text": "o Modern versions of the X Window System handle keysyms for Unicode characters, consisting of the Unicode character with the hex 1000000 bit set. For maximum compatibility, if a key has both a Unicode and a legacy encoding, clients should send the legacy encoding.",
      "ja": "O Xウィンドウシステムの最近のバージョンは、六角1000000ビットが設定されたUnicode文字から成る、Unicode文字のためのキーシンボルを処理します。キーはUnicodeとレガシエンコーディングの両方を持っている場合、最大の互換性のために、クライアントはレガシーエンコーディングを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Some systems give a special interpretation to key combinations such as Ctrl-Alt-Delete. RFB clients typically provide a menu or toolbar function to send such key combinations. The RFB protocol does not treat them specially; to send Ctrl-Alt-Delete, the client sends the key presses for left or right Control, left or right",
      "ja": "O一部のシステムでは、このようなCtrl-Alt-Deleteをなどのキーの組み合わせに特別な解釈を与えます。 RFBクライアントは、通常、このようなキーの組み合わせを送信するには、メニューやツールバーの機能を提供します。 RFBプロトコルは、特別にそれらを扱うことはありません。 Ctrl-Alt-Deleteを送信するために、クライアントは、左または右、左または右のコントロールのためのキーの押下を送信します"
    },
    {
      "indent": 6,
      "text": "Alt, and Delete, followed by the key releases. Many RFB servers accept Shift-Ctrl-Alt-Delete as a synonym for Ctrl-Alt-Delete that can be entered directly from the keyboard.",
      "ja": "Altキー、および削除、キーのリリースが続きます。多くのRFBサーバは、キーボードから直接入力することができますCtrl + Alt + Deleteを同義語としてShiftキーを押しながらCtrl + Alt +-Deleteを受け入れます。"
    },
    {
      "indent": 0,
      "text": "7.5.5. PointerEvent",
      "section_title": true,
      "ja": "7.5.5.  PointerEvent"
    },
    {
      "indent": 3,
      "text": "A PointerEvent message indicates either pointer movement or a pointer button press or release. The pointer is now at (x-position, y-position), and the current state of buttons 1 to 8 are represented by bits 0 to 7 of button-mask, respectively; 0 means up, 1 means down (pressed).",
      "ja": "PointerEventメッセージは、ポインタの移動またはポインタボタンプレスまたはリリースのいずれかを示しています。ポインタは、（x位置、y位置）、及び1〜8は、それぞれボタンマスクの7ビット0で表されるボタンの現在の状態になりました。 0は、アップ手段1（押下）ダウンを意味します。"
    },
    {
      "indent": 3,
      "text": "On a conventional mouse, buttons 1, 2, and 3 correspond to the left, middle, and right buttons on the mouse. On a wheel mouse, each step of the wheel upwards is represented by a press and release of button 4, and each step downwards is represented by a press and release of button 5.",
      "ja": "従来のマウス、ボタン1、2、左、中央、およびマウスの右ボタンに対応3に。ホイールマウスに、ホイールの各ステップは、上方ボタン4の押下と解放によって表され、各ステップは下向きボタン5を押すと解除によって表されます。"
    },
    {
      "indent": 14,
      "text": "+--------------+--------------+--------------+\n| No. of bytes | Type [Value] | Description  |\n+--------------+--------------+--------------+\n| 1            | U8 [5]       | message-type |\n| 1            | U8           | button-mask  |\n| 2            | U16          | x-position   |\n| 2            | U16          | y-position   |\n+--------------+--------------+--------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.5.6. ClientCutText",
      "section_title": true,
      "ja": "7.5.6.  ClientCutText"
    },
    {
      "indent": 3,
      "text": "RFB provides limited support for synchronizing the \"cut buffer\" of selected text between client and server. This message tells the server that the client has new ISO 8859-1 (Latin-1) text in its cut buffer. Ends of lines are represented by the newline character (hex 0a) alone. No carriage-return (hex 0d) is used. There is no way to transfer text outside the Latin-1 character set.",
      "ja": "RFBは、クライアントとサーバーの間で選択したテキストの「カットバッファを」同期するための限定的なサポートを提供します。このメッセージは、クライアントがそのカットバッファ内の新しいISO 8859-1（Latin-1の）テキストを持つサーバーに指示します。線の端部は、改行文字（16進の0A）のみで表現されています。いいえキャリッジリターン（六角0D）が使用されません。 Latin-1文字セット以外のテキストを転送する方法はありません。"
    },
    {
      "indent": 14,
      "text": "+--------------+--------------+--------------+\n| No. of bytes | Type [Value] | Description  |\n+--------------+--------------+--------------+\n| 1            | U8 [6]       | message-type |\n| 3            |              | padding      |\n| 4            | U32          | length       |\n| length       | U8 array     | text         |\n+--------------+--------------+--------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.6. Server-to-Client Messages",
      "section_title": true,
      "ja": "7.6. サーバーからクライアントへのメッセージ"
    },
    {
      "indent": 3,
      "text": "The server-to-client message types defined in this document are:",
      "ja": "この文書で定義されたサーバーからクライアントへのメッセージの種類は次のとおりです。"
    },
    {
      "indent": 22,
      "text": "+--------+--------------------+\n| Number | Name               |\n+--------+--------------------+\n| 0      | FramebufferUpdate  |\n| 1      | SetColorMapEntries |\n| 2      | Bell               |\n| 3      | ServerCutText      |\n+--------+--------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Other private message types exist but are not publicly documented. Before sending a message other than those described in this document a server must have determined that the client supports the relevant extension by receiving some extension-specific confirmation from the client -- usually a request for a given pseudo-encoding.",
      "ja": "その他プライベートメッセージタイプが存在するが、一般に公開されていません。与えられた擬似コード化のための通常の要求 - クライアントは、クライアントからのいくつかの拡張機能固有の確認を受けて、関連する拡張機能をサポートしていることを、この文書に記載されているもの以外のメッセージを送信する前にサーバが決定している必要があります。"
    },
    {
      "indent": 0,
      "text": "7.6.1. FramebufferUpdate",
      "section_title": true,
      "ja": "7.6.1.  FramebufferUpdate"
    },
    {
      "indent": 3,
      "text": "A framebuffer update consists of a sequence of rectangles of pixel data that the client should put into its framebuffer. It is sent in response to a FramebufferUpdateRequest from the client. Note that there may be an indefinite period between the FramebufferUpdateRequest and the FramebufferUpdate.",
      "ja": "フレームバッファの更新は、クライアントがそのフレームバッファに入れなければならないピクセルデータの長方形の配列からなります。これは、クライアントからのFramebufferUpdateRequestに応答して送信されます。 FramebufferUpdateRequestとFramebufferUpdate間の不定の期間があってもよいことに留意されたいです。"
    },
    {
      "indent": 10,
      "text": "+--------------+--------------+----------------------+\n| No. of bytes | Type [Value] | Description          |\n+--------------+--------------+----------------------+\n| 1            | U8 [0]       | message-type         |\n| 1            |              | padding              |\n| 2            | U16          | number-of-rectangles |\n+--------------+--------------+----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This header is followed by number-of-rectangles rectangles of pixel data. Each rectangle starts with a rectangle header:",
      "ja": "このヘッダは、画素データの数の、長方形の矩形が続きます。各矩形は矩形ヘッダで始まります。"
    },
    {
      "indent": 14,
      "text": "+--------------+--------------+---------------+\n| No. of bytes | Type [Value] | Description   |\n+--------------+--------------+---------------+\n| 2            | U16          | x-position    |\n| 2            | U16          | y-position    |\n| 2            | U16          | width         |\n| 2            | U16          | height        |\n| 4            | S32          | encoding-type |\n+--------------+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The rectangle header is followed by the pixel data in the specified encoding. See Section 7.7 for the format of the data for each encoding and Section 7.8 for the meaning of pseudo-encodings.",
      "ja": "矩形ヘッダが指定されたエンコーディングの画素データが続きます。擬似符号化の意味のために各符号化及び7.8節のためのデータのフォーマットについては、セクション7.7を参照。"
    },
    {
      "indent": 0,
      "text": "7.6.2. SetColorMapEntries",
      "section_title": true,
      "ja": "7.6.2.  SetColorMapEntries"
    },
    {
      "indent": 3,
      "text": "When the pixel format uses a \"color map\", this message tells the client that the specified pixel values should be mapped to the given RGB values. Note that this message may only update part of the color map. This message should not be sent by the server until after the client has sent at least one FramebufferUpdateRequest, and only when the agreed pixel format uses a color map.",
      "ja": "ピクセルフォーマットは、「カラーマップ」を使用する場合、このメッセージは、指定されたピクセル値が与えられたRGB値にマッピングする必要があることをクライアントに通知します。このメッセージのみカラーマップの一部を更新してもよいことに留意されたいです。このメッセージは、クライアントが少なくとも一つのFramebufferUpdateRequestを送信した、と合意されたピクセルフォーマットは、カラーマップを使用している場合にのみ後までサーバによって送信すべきではありません。"
    },
    {
      "indent": 3,
      "text": "Color map values are always 16 bits, with the range of values running from 0 to 65535, regardless of the display hardware in use. The color map value for white, for example, is 65535,65535,65535.",
      "ja": "カラーマップ値にかかわらず、使用中のディスプレイハードウェアの、0から65535まで実行値の範囲は、常に16ビットです。白用カラーマップ値は、例えば、65535,65535,65535です。"
    },
    {
      "indent": 3,
      "text": "The message starts with a header describing the range of colormap entries to be updated.",
      "ja": "メッセージを更新するカラーマップエントリの範囲を記述するヘッダから始まります。"
    },
    {
      "indent": 12,
      "text": "+--------------+--------------+------------------+\n| No. of bytes | Type [Value] | Description      |\n+--------------+--------------+------------------+\n| 1            | U8 [1]       | message-type     |\n| 1            |              | padding          |\n| 2            | U16          | first-color      |\n| 2            | U16          | number-of-colors |\n+--------------+--------------+------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This header is followed by number-of-colors RGB values, each of which is in this format:",
      "ja": "このヘッダは、この形式になって各々が数の、色のRGB値が続きます。"
    },
    {
      "indent": 15,
      "text": "+--------------+--------------+-------------+\n| No. of bytes | Type [Value] | Description |\n+--------------+--------------+-------------+\n| 2            | U16          | red         |\n| 2            | U16          | green       |\n| 2            | U16          | blue        |\n+--------------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.6.3. Bell",
      "section_title": true,
      "ja": "7.6.3. ベル"
    },
    {
      "indent": 3,
      "text": "A Bell message makes an audible signal on the client if it provides one.",
      "ja": "それは1を提供する場合ベルメッセージは、クライアント上の可聴信号を作ります。"
    },
    {
      "indent": 14,
      "text": "+--------------+--------------+--------------+\n| No. of bytes | Type [Value] | Description  |\n+--------------+--------------+--------------+\n| 1            | U8 [2]       | message-type |\n+--------------+--------------+--------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.6.4. ServerCutText",
      "section_title": true,
      "ja": "7.6.4.  ServerCutText"
    },
    {
      "indent": 3,
      "text": "The server has new ISO 8859-1 (Latin-1) text in its cut buffer. Ends of lines are represented by the newline character (hex 0a) alone. No carriage-return (hex 0d) is used. There is no way to transfer text outside the Latin-1 character set.",
      "ja": "サーバーは、そのカットバッファ内の新しいISO 8859-1（Latin-1の）テキストを持っています。線の端部は、改行文字（16進の0A）のみで表現されています。いいえキャリッジリターン（六角0D）が使用されません。 Latin-1文字セット以外のテキストを転送する方法はありません。"
    },
    {
      "indent": 14,
      "text": "+--------------+--------------+--------------+\n| No. of bytes | Type [Value] | Description  |\n+--------------+--------------+--------------+\n| 1            | U8 [3]       | message-type |\n| 3            |              | padding      |\n| 4            | U32          | length       |\n| length       | U8 array     | text         |\n+--------------+--------------+--------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.7. Encodings",
      "section_title": true,
      "ja": "7.7. エンコーディング"
    },
    {
      "indent": 3,
      "text": "The encodings defined in this document are:",
      "ja": "この文書で定義されたエンコーディングは以下のとおりです。"
    },
    {
      "indent": 17,
      "text": "+--------+-----------------------------+\n| Number | Name                        |\n+--------+-----------------------------+\n| 0      | Raw                         |\n| 1      | CopyRect                    |\n| 2      | RRE                         |\n| 5      | Hextile                     |\n| 15     | TRLE                        |\n| 16     | ZRLE                        |\n| -239   | Cursor pseudo-encoding      |\n| -223   | DesktopSize pseudo-encoding |\n+--------+-----------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Other encoding types exist but are not publicly documented.",
      "ja": "他のエンコードタイプが存在するが、一般に公開されていません。"
    },
    {
      "indent": 0,
      "text": "7.7.1. Raw Encoding",
      "section_title": true,
      "ja": "7.7.1. 生のエンコーディング"
    },
    {
      "indent": 3,
      "text": "The simplest encoding type is raw pixel data. In this case, the data consists of width*height pixel values (where width and height are the width and height of the rectangle). The values simply represent each pixel in left-to-right scan line order. All RFB clients must be able to handle pixel data in this raw encoding, and RFB servers should only produce raw encoding unless the client specifically asks for some other encoding type.",
      "ja": "最も単純な符号化タイプは、生の画素データです。この場合、データは、（幅と高さは矩形の幅と高さ）幅*高さ画素値から成ります。値は、単に左から右への走査線のために、各画素を表します。すべてのRFBクライアントは、この生のエンコーディングでピクセルデータを扱うことができなければならない、そしてクライアントは、特にいくつかの他の符号化タイプを要求しない限り、RFBサーバーのみ生のエンコーディングを生成する必要があります。"
    },
    {
      "indent": 8,
      "text": "+----------------------------+--------------+-------------+\n| No. of bytes               | Type [Value] | Description |\n+----------------------------+--------------+-------------+\n| width*height*bytesPerPixel | PIXEL array  | pixels      |\n+----------------------------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.7.2. CopyRect Encoding",
      "section_title": true,
      "ja": "7.7.2.  CopyRectエンコーディング"
    },
    {
      "indent": 3,
      "text": "The CopyRect (copy rectangle) encoding is a very simple and efficient encoding that can be used when the client already has the same pixel data elsewhere in its framebuffer. The encoding on the wire simply consists of an X,Y coordinate. This gives a position in the framebuffer from which the client can copy the rectangle of pixel data. This can be used in a variety of situations, the most common of which are when the user moves a window across the screen, and when the contents of a window are scrolled.",
      "ja": "CopyRect（コピー矩形）符号化クライアントは、既に他の場所で、そのフレームバッファにおける同じ画素データを有する場合に使用することができ、非常にシンプルかつ効率的な符号化です。ワイヤ上の符号は、単にY座標、Xから成ります。これは、クライアントがピクセルデータの長方形をコピーすることができ、そこからフレームバッファ内の位置を与えます。これにより、ユーザは画面上のウィンドウを移動したときに、ウィンドウの内容がスクロールされたときであり、最も一般的なその状況、種々のに使用することができます。"
    },
    {
      "indent": 13,
      "text": "+--------------+--------------+----------------+\n| No. of bytes | Type [Value] | Description    |\n+--------------+--------------+----------------+\n| 2            | U16          | src-x-position |\n| 2            | U16          | src-y-position |\n+--------------+--------------+----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For maximum compatibility, the source rectangle of a CopyRect should not include pixels updated by previous entries in the same FramebufferUpdate message.",
      "ja": "最大の互換性のために、CopyRectのソース矩形は同じFramebufferUpdateメッセージに以前のエントリによって更新された画素を含むべきではありません。"
    },
    {
      "indent": 0,
      "text": "7.7.3. RRE Encoding",
      "section_title": true,
      "ja": "7.7.3.  RREエンコーディング"
    },
    {
      "indent": 3,
      "text": "Note: RRE encoding is obsolescent. In general, ZRLE and TRLE encodings are more compact.",
      "ja": "注意：RREエンコーディングは旧式です。一般的には、ZRLEとTRLEエンコーディングは、よりコンパクトです。"
    },
    {
      "indent": 3,
      "text": "RRE stands for rise-and-run-length encoding. As its name implies, it is essentially a two-dimensional analogue of run-length encoding. RRE-encoded rectangles arrive at the client in a form that can be rendered immediately by the simplest of graphics engines. RRE is not appropriate for complex desktops, but can be useful in some situations.",
      "ja": "RREは、立ち上がりと-ランレングス符号化の略です。その名前が示すように、それは本質的にランレングス符号化の二次元の類似体です。 RREエンコードされた長方形は、グラフィックスエンジンの最も単純によって即座にレンダリングすることができる形でクライアントに到着します。 RREは複雑なデスクトップには適していませんが、いくつかの状況において有用であることができます。"
    },
    {
      "indent": 3,
      "text": "The basic idea behind RRE is the partitioning of a rectangle of pixel data into rectangular subregions (subrectangles) each of which consists of pixels of a single value, and the union of which comprises the original rectangular region. The near-optimal partition of a given rectangle into such subrectangles is relatively easy to compute.",
      "ja": "RREの背後にある基本的な考え方は、単一の値の画素から成りそれぞれが長方形の小領域（副矩形）に画素データの長方形の区分であり、の組合は、元の長方形の領域を含みます。そのような副矩形に与えられた矩形のほぼ最適なパーティションを計算することは比較的容易です。"
    },
    {
      "indent": 3,
      "text": "The encoding consists of a background pixel value, Vb (typically the most prevalent pixel value in the rectangle) and a count N, followed by a list of N subrectangles, each of which consists of a tuple <v,x,y,w,h> where v (which should be different from Vb) is the pixel value, (x,y) are the coordinates of the subrectangle relative to the top-left corner of the rectangle, and (w,h) are the width and height of the subrectangle. The client can render the original rectangle by drawing a filled rectangle of the background pixel value and then drawing a filled rectangle corresponding to each subrectangle.",
      "ja": "符号化は、背景画素値で構成され、wは、タプル<V、X、Yから成る各々が（矩形典型的に最も普及している画素値）VBと、N個の副矩形のリストが続く数N、、、 H>（VB異なるなければならない）vは、画素値であり、（x、y）は矩形の左上隅にsubrectangle相対座標であり、（H、W）の幅と高さsubrectangleの。クライアントは、背景画素値の塗りつぶされた矩形を描画し、各subrectangleに対応する充填矩形を描画することによって、元の四角形をレンダリングすることができます。"
    },
    {
      "indent": 3,
      "text": "On the wire, the data begins with the header:",
      "ja": "ワイヤ上の、データは、ヘッダで始まります。"
    },
    {
      "indent": 8,
      "text": "+---------------+--------------+-------------------------+\n| No. of bytes  | Type [Value] | Description             |\n+---------------+--------------+-------------------------+\n| 4             | U32          | number-of-subrectangles |\n| bytesPerPixel | PIXEL        | background-pixel-value  |\n+---------------+--------------+-------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This is followed by number-of-subrectangles instances of the following structure:",
      "ja": "これは、次のような構造の数の-副矩形のインスタンスが続きます。"
    },
    {
      "indent": 10,
      "text": "+---------------+--------------+---------------------+\n| No. of bytes  | Type [Value] | Description         |\n+---------------+--------------+---------------------+\n| bytesPerPixel | PIXEL        | subrect-pixel-value |\n| 2             | U16          | x-position          |\n| 2             | U16          | y-position          |\n| 2             | U16          | width               |\n| 2             | U16          | height              |\n+---------------+--------------+---------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.7.4. Hextile Encoding",
      "section_title": true,
      "ja": "7.7.4.  Hextileエンコーディング"
    },
    {
      "indent": 3,
      "text": "Note: Hextile encoding is obsolescent. In general, ZRLE and TRLE encodings are more compact.",
      "ja": "注意：Hextileエンコーディングは廃れています。一般的には、ZRLEとTRLEエンコーディングは、よりコンパクトです。"
    },
    {
      "indent": 3,
      "text": "Hextile is a variation on RRE. Rectangles are split up into 16x16 tiles, allowing the dimensions of the subrectangles to be specified in 4 bits each, 16 bits in total. The rectangle is split into tiles starting at the top left going in left-to-right, top-to-bottom order. The encoded contents of the tiles simply follow one another in the predetermined order. If the width of the whole rectangle is not an exact multiple of 16, then the width of the last tile in each row will be correspondingly smaller. Similarly, if the height of the whole rectangle is not an exact multiple of 16, then the height of each tile in the final row will also be smaller.",
      "ja": "HextileはRREのバリエーションです。矩形は、副矩形の寸法は4ビットずつ、合計16ビットで指定できるように、16×16のタイルに分割されています。矩形は左から右、上から下の順に行く左上から始まるタイルに分割されます。タイルのエンコードされた内容は、単純に所定の順序で互いに続きます。全体として矩形の幅は16の倍数でない場合、各行の最後のタイルの幅は相応小さくなります。全体として矩形の高さが16の倍数でない場合は同様に、最終的な行の各タイルの高さも小さくなります。"
    },
    {
      "indent": 3,
      "text": "Each tile is either encoded as raw pixel data, or as a variation on RRE. Each tile has a background pixel value, as before. The background pixel value does not need to be explicitly specified for a given tile if it is the same as the background of the previous tile. However, the background pixel value may not be carried over if the previous tile was raw. If all of the subrectangles of a tile have the same pixel value, this can be specified once as a foreground pixel value for the whole tile. As with the background, the foreground pixel value can be left unspecified, meaning it is carried over from the previous tile. The foreground pixel value may not be carried over if the previous tile was raw or had the SubrectsColored bit set. It may, however, be carried over from a previous tile with the AnySubrects bit clear, as long as that tile itself carried over a valid foreground from its previous tile.",
      "ja": "各タイルは、符号化された生の画素データとして、又はRREのバリエーションとしてのいずれかです。各タイルは以前のように、背景画素値を持っています。それは、前のタイルの背景と同じであれば背景画素値が明示的に与えられたタイルのために指定する必要はありません。以前のタイルが生であった場合は、背景画素値が引き継がれなくてもよいです。タイルの副矩形のすべてが同一の画素値を持っている場合、これは全体のタイルのための前景画素値と、一度に指定することができます。背景と同じように、フォアグラウンドのピクセル値は、それが前のタイルから引き継がれている意味、未指定のままにすることができます。以前のタイルが生た又はSubrectsColoredビットセットを有する場合、前景画素値が引き継がれなくてもよいです。 AnySubrectsはクリアビットとそれは、しかし、それ自体がその前のタイルからの有効なフォアグラウンド上で実施し、そのタイル限り、以前のタイルから引き継がれます。"
    },
    {
      "indent": 3,
      "text": "The data consists of each tile encoded in order. Each tile begins with a subencoding type byte, which is a mask made up of a number of bits:",
      "ja": "データが順番に符号化された各タイルから成ります。各タイルは、ビット数で構成されたマスクであるsubencoding型バイトから始まります。"
    },
    {
      "indent": 11,
      "text": "+--------------+--------------+---------------------+\n| No. of bytes | Type [Value] | Description         |\n+--------------+--------------+---------------------+\n| 1            | U8           | subencoding-mask:   |\n|              | [1]          | Raw                 |\n|              | [2]          | BackgroundSpecified |\n|              | [4]          | ForegroundSpecified |\n|              | [8]          | AnySubrects         |\n|              | [16]         | SubrectsColored     |\n+--------------+--------------+---------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the Raw bit is set, then the other bits are irrelevant; width*height pixel values follow (where width and height are the width and height of the tile). Otherwise, the other bits in the mask are as follows:",
      "ja": "生ビットが設定されている場合、他のビットは無関係です。幅*高さ画素値（幅と高さはタイルの幅と高さである）に従います。次のようにそうでなければ、マスクの他のビットは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "BackgroundSpecified If set, a pixel value of bytesPerPixel bytes follows and specifies the background color for this tile. The first non-raw tile in a rectangle must have this bit set. If this bit isn't set, then the background is the same as the last tile.",
      "ja": "設定された場合、bytesPerPixelの画素値は、次のバイト、このタイルの背景色を指定しBackgroundSpecified。長方形内の最初の非生タイルは、このビットがセットされていなければなりません。このビットがセットされていない場合は、背景が最後のタイルと同じです。"
    },
    {
      "indent": 3,
      "text": "ForegroundSpecified If set, a pixel value of bytesPerPixel bytes follows and specifies the foreground color to be used for all subrectangles in this tile.",
      "ja": "設定した場合ForegroundSpecified、bytesPerPixelバイトのピクセル値は、このタイル内のすべての副矩形に使用するフォアグラウンドカラーを以下と指定します。"
    },
    {
      "indent": 6,
      "text": "If this bit is set, then the SubrectsColored bit must be zero.",
      "ja": "このビットがセットされている場合は、SubrectsColoredビットはゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "AnySubrects If set, a single byte follows and gives the number of subrectangles following. If not set, there are no subrectangles (i.e., the whole tile is just solid background color).",
      "ja": "設定した場合AnySubrects、単一バイトが続き、以下の副矩形の数を示します。設定されていない場合、（すなわち、全体のタイルがちょうど固体背景色である）は、副矩形が存在しません。"
    },
    {
      "indent": 3,
      "text": "SubrectsColored If set, then each subrectangle is preceded by a pixel value giving the color of that subrectangle, so a subrectangle is:",
      "ja": "設定した場合、各subrectangleそのsubrectangleの色を与える画素値が先行するので、subrectangleはSubrectsColored。"
    },
    {
      "indent": 10,
      "text": "+---------------+--------------+---------------------+\n| No. of bytes  | Type [Value] | Description         |\n+---------------+--------------+---------------------+\n| bytesPerPixel | PIXEL        | subrect-pixel-value |\n| 1             | U8           | x-and-y-position    |\n| 1             | U8           | width-and-height    |\n+---------------+--------------+---------------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "If not set, all subrectangles are the same color -- the foreground color; if the ForegroundSpecified bit wasn't set, then the foreground is the same as the last tile. A subrectangle is:",
      "ja": "設定されていない場合は、すべてのサブ長方形は同じ色で - フォアグラウンドカラー。前景指定されたが、設定されていなかったのは、フォアグラウンドは最後のタイルと同じです。 subrectangleは以下のとおりです。"
    },
    {
      "indent": 12,
      "text": "+--------------+--------------+------------------+\n| No. of bytes | Type [Value] | Description      |\n+--------------+--------------+------------------+\n| 1            | U8           | x-and-y-position |\n| 1            | U8           | width-and-height |\n+--------------+--------------+------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The position and size of each subrectangle is specified in two bytes, x-and-y-position and width-and-height. The most significant 4 bits of x-and-y-position specify the X position, the least significant specify the Y position. The most significant 4 bits of width-and-height specify the width minus 1, the least significant specify the height minus 1.",
      "ja": "各subrectangleの位置と大きさは、幅、及び高さ・アンド・y位置をX、2つのバイトで指定されています。 X-と-y位置の上位4ビットは、最下位のY位置を指定し、Xの位置を指定します。幅と高さの上位4ビット幅マイナス1を指定し、最下位の高さマイナス1を指定します。"
    },
    {
      "indent": 0,
      "text": "7.7.5. TRLE",
      "section_title": true,
      "ja": "7.7.5.  TRLE"
    },
    {
      "indent": 3,
      "text": "TRLE stands for Tiled Run-Length Encoding, and combines tiling, palettization, and run-length encoding. The rectangle is divided into tiles of 16x16 pixels in left-to-right, top-to-bottom order, similar to Hextile. If the width of the rectangle is not an exact multiple of 16, then the width of the last tile in each row is smaller, and if the height of the rectangle is not an exact multiple of 16, then the height of each tile in the final row is smaller.",
      "ja": "TRLEはタイル張りのランレングス符号化の略で、タイリングを組み合わせ、palettization、およびランレングス符号化を。矩形はHextileと同様左から右、上から下へ順に16×16画素のタイルに分割されます。矩形の幅は16の倍数でない場合、各行の最後のタイルの幅が小さく、矩形の高さが16の倍数でない場合、各タイルの高さ次いで最終行が小さくなっています。"
    },
    {
      "indent": 3,
      "text": "TRLE makes use of a new type CPIXEL (compressed pixel). This is the same as a PIXEL for the agreed pixel format, except as a special case, it uses a more compact format if true-color-flag is non-zero, bits-per-pixel is 32, depth is 24 or less, and all of the bits making up the red, green, and blue intensities fit in either the least significant 3 bytes or the most significant 3 bytes. If all of these are the case, a CPIXEL is only 3 bytes long, and contains the least significant or the most significant 3 bytes as appropriate. bytesPerCPixel is the number of bytes in a CPIXEL.",
      "ja": "TRLEは、新しいタイプのCPIXEL（圧縮された画素）を利用します。これは、特殊なケースとして、トゥルーカラーフラグが非ゼロの場合、それは、よりコンパクトなフォーマットを使用して、ピクセルあたりのビット数が32である以外は、深さが24以下である、合意されたピクセルフォーマットの画素と同じですそして、赤、緑、及び青の強度を構成する全てのビットは最下位3バイト又は上位3バイトのどちらかに収まります。これらのすべては場合であれば、CPIXELはわずか3バイトの長さ、および必要に応じて最下位または上位3つのバイトが含まれています。 bytesPerCPixelはCPIXELのバイト数です。"
    },
    {
      "indent": 3,
      "text": "Each tile begins with a subencoding type byte. The top bit of this byte is set if the tile has been run-length encoded, clear otherwise. The bottom 7 bits indicate the size of the palette used: zero means no palette, 1 means that the tile is of a single color, and 2 to 127 indicate a palette of that size. The special subencoding values 129 and 127 indicate that the palette is to be reused from the last tile that had a palette, with and without RLE, respectively.",
      "ja": "各タイルはsubencodingタイプバイトで始まります。タイルは、ランレングスが明らかにそうでない場合は、符号化されている場合は、このバイトの最上位ビットが設定されています。底7ビットが使用されるパレットのサイズを示す：ゼロにはパレットを意味し、1は、タイルは、単一色のものであり、127から2は、その大きさのパレットを示すことを意味します。特別subencoding 129及び127は、パレットは、それぞれ、RLEととせずに、パレットを持っていた最後のタイルから再利用されることを示す値。"
    },
    {
      "indent": 3,
      "text": "Note: in this discussion, the div(a,b) function means the result of dividing a/b truncated to an integer.",
      "ja": "注：この説明では、DIV（B）関数は整数に/ B切断型を分割した結果を意味します。"
    },
    {
      "indent": 3,
      "text": "The possible values of subencoding are:",
      "ja": "subencodingの可能な値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0: Raw pixel data. width*height pixel values follow (where width and height are the width and height of the tile):",
      "ja": "0：生のピクセルデータ。幅*高さ画素値（幅と高さはタイルの幅と高さである）は、次のとおりです。"
    },
    {
      "indent": 7,
      "text": "+-----------------------------+--------------+-------------+\n| No. of bytes                | Type [Value] | Description |\n+-----------------------------+--------------+-------------+\n| width*height*BytesPerCPixel | CPIXEL array | pixels      |\n+-----------------------------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "1: A solid tile consisting of a single color. The pixel value follows:",
      "ja": "1：単一色からなる固体タイル。画素値は、次のとおり"
    },
    {
      "indent": 14,
      "text": "+----------------+--------------+-------------+\n| No. of bytes   | Type [Value] | Description |\n+----------------+--------------+-------------+\n| bytesPerCPixel | CPIXEL       | pixelValue  |\n+----------------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2 to 16: Packed palette types. The paletteSize is the value of the subencoding, which is followed by the palette, consisting of paletteSize pixel values. The packed pixels follow, with each pixel represented as a bit field yielding a zero-based index into the palette. For paletteSize 2, a 1-bit field is used; for paletteSize 3 or 4, a 2-bit field is used; and for paletteSize from 5 to 16, a 4-bit field is used. The bit fields are packed into bytes, with the most significant bits representing the leftmost pixel (i.e., big endian). For tiles not a multiple of 8, 4, or 2 pixels wide (as appropriate), padding bits are used to align each row to an exact number of bytes.",
      "ja": "2〜16：パックされたパレットタイプ。 paletteSizeはpaletteSize画素値から成るパレットが続きsubencoding、の値です。パックされたピクセルは、パレットにゼロベースのインデックスを得たビットフィールドとして表される各画素に、従います。 paletteSize 2ために、1ビットのフィールドが使用されます。 paletteSize 3または4の場合、2ビットのフィールドが使用されます。 5〜16 paletteSizeため、4ビットのフィールドが使用されます。ビット・フィールドは、最も左側の画素（すなわち、ビッグエンディアン）を表す最上位ビットと、バイトにパックされています。タイルのために（適切な）広い8,4、または2ピクセルの倍数は、パディングビットがバイトの正確な数に各行を整列させるために使用されるわけではありません。"
    },
    {
      "indent": 7,
      "text": "+----------------------------+--------------+--------------+\n| No. of bytes               | Type [Value] | Description  |\n+----------------------------+--------------+--------------+\n| paletteSize*bytesPerCPixel | CPIXEL array | palette      |\n| m                          | U8 array     | packedPixels |\n+----------------------------+--------------+--------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "where m is the number of bytes representing the packed pixels. For paletteSize of 2, this is div(width+7,8)*height; for paletteSize of 3 or 4, this is div(width+3,4)*height; or for paletteSize of 5 to 16, this is div(width+1,2)*height.",
      "ja": "ここで、mは、パックされたピクセルを表すバイト数です。 2のpaletteSizeため、これは、DIV（幅+ 7,8）*高さです。 3または4のpaletteSizeため、これはDIV（幅+ 3,4）*高さです。または5〜16のpaletteSizeため、これはDIV（幅+ 1,2）*高さです。"
    },
    {
      "indent": 3,
      "text": "17 to 126: Unused. (Packed palettes of these sizes would offer no advantage over palette RLE).",
      "ja": "17から126：未使用。 （これらのサイズのパックされたパレットは、パレットRLEに対して何ら利点を提供しないでしょう）。"
    },
    {
      "indent": 3,
      "text": "127: Packed palette with the palette reused from the previous tile. The subencoding byte is followed by the packed pixels as described above for packed palette types.",
      "ja": "127：前のタイルから再利用パレットとパレットを満載。パックされたパレットタイプについて上記のようにsubencodingバイトは、パックされたピクセルが続きます。"
    },
    {
      "indent": 3,
      "text": "128: Plain RLE. The data consists of a number of runs, repeated until the tile is done. Runs may continue from the end of one row to the beginning of the next. Each run is represented by a single pixel value followed by the length of the run. The length is represented as one or more bytes. The length is calculated as one more than the sum of all the bytes representing the length. Any byte value other than 255 indicates the final byte. So for example, length 1 is represented as [0], 255 as [254], 256 as [255,0], 257 as [255,1], 510 as [255,254], 511 as [255,255,0], and so on.",
      "ja": "128：平野RLE。データは、タイルが完了するまで繰り返し実行の数、構成されています。実験は、次の先頭に一列の端部から継続してもよいです。各ランは、ランの長さ続いて単一の画素値で表されます。長さは、1バイト以上のように表されます。長さは、長さを表すすべてのバイトの合計より1として算出されます。 255以外のバイト値は最終バイトを示します。だから、例えば、長さ1 [255,255,0]と[0]、[254]として255 [255,0] 256、[255,1]として257 [255254]として510、511として表され、そして上のようにします。"
    },
    {
      "indent": 4,
      "text": "+-------------------------+--------------+-----------------------+\n| No. of bytes            | Type [Value] | Description           |\n+-------------------------+--------------+-----------------------+\n| bytesPerCPixel          | CPIXEL       | pixelValue            |\n| div(runLength - 1, 255) | U8 array     | 255                   |\n| 1                       | U8           | (runLength-1) mod 255 |\n+-------------------------+--------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "129: Palette RLE with the palette reused from the previous tile. Followed by a number of runs, repeated until the tile is done, as described below for 130 to 255.",
      "ja": "129：前のタイルから再利用パレットとパレットRLE。タイルが完了するまで255まで130については、以下に記載されるようランの数、続いて、繰り返します。"
    },
    {
      "indent": 3,
      "text": "130 to 255: Palette RLE. Followed by the palette, consisting of paletteSize = (subencoding - 128) pixel values:",
      "ja": "255から130：パレットRLE。 paletteSize =（subencoding  -  128）からなる、パレットに続くピクセル値："
    },
    {
      "indent": 8,
      "text": "+----------------------------+--------------+-------------+\n| No. of bytes               | Type [Value] | Description |\n+----------------------------+--------------+-------------+\n| paletteSize*bytesPerCPixel | CPIXEL array | palette     |\n+----------------------------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Following the palette is, as with plain RLE, a number of runs, repeated until the tile is done. A run of length one is represented simply by a palette index:",
      "ja": "パレットに続いて、タイルが完了するまで、プレーンRLE、ランの数と同様に、繰り返し、です。長さ1のランは単にパレットインデックスで表されます。"
    },
    {
      "indent": 14,
      "text": "+--------------+--------------+--------------+\n| No. of bytes | Type [Value] | Description  |\n+--------------+--------------+--------------+\n| 1            | U8           | paletteIndex |\n+--------------+--------------+--------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "A run of length more than one is represented by a palette index with the top bit set, followed by the length of the run as for plain RLE.",
      "ja": "長さ複数のランは、プレーンRLEのようなランの長さに続く先頭ビットがセットされたパレットインデックス、によって表されます。"
    },
    {
      "indent": 4,
      "text": "+-------------------------+--------------+-----------------------+\n| No. of bytes            | Type [Value] | Description           |\n+-------------------------+--------------+-----------------------+\n| 1                       | U8           | paletteIndex + 128    |\n| div(runLength - 1, 255) | U8 array     | 255                   |\n| 1                       | U8           | (runLength-1) mod 255 |\n+-------------------------+--------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.7.6. ZRLE",
      "section_title": true,
      "ja": "7.7.6.  RLE"
    },
    {
      "indent": 3,
      "text": "ZRLE stands for Zlib (see [RFC1950] and [RFC1951]) Run-Length Encoding, and combines an encoding similar to TRLE with zlib compression. On the wire, the rectangle begins with a 4-byte length field, and is followed by that many bytes of zlib-compressed data. A single zlib \"stream\" object is used for a given RFB protocol connection, so that ZRLE rectangles must be encoded and decoded strictly in order.",
      "ja": "ZRLEは、ランレングス符号化（[RFC1950]及び[RFC1951]を参照）はZlibを表し、ZLIB圧縮とTRLEと同様の符号化を組み合わせます。ワイヤ上の、長方形は4バイトの長さフィールドから始まり、ZLIB圧縮データのバイト数が続きます。 ZRLE矩形が符号化され、順番に厳密に復号化しなければならないように、単一のzlib「ストリーム」オブジェクトは、所与RFBプロトコル接続のために使用されます。"
    },
    {
      "indent": 15,
      "text": "+--------------+--------------+-------------+\n| No. of bytes | Type [Value] | Description |\n+--------------+--------------+-------------+\n| 4            | U32          | length      |\n| length       | U8 array     | zlibData    |\n+--------------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The zlibData when uncompressed represents tiles in left-to-right, top-to-bottom order, similar to TRLE, but with a tile size of 64x64 pixels. If the width of the rectangle is not an exact multiple of 64, then the width of the last tile in each row is smaller, and if the height of the rectangle is not an exact multiple of 64, then the height of each tile in the final row is smaller.",
      "ja": "zlibDataときに圧縮されていないが、右への左上から下への順序、TRLEに類似するが、64×64画素のタイルサイズでタイルを表します。矩形の幅は64の倍数でない場合、各行の最後のタイルの幅が小さく、矩形の高さが64の倍数でない場合、各タイルの高さ次いで最終行が小さくなっています。"
    },
    {
      "indent": 3,
      "text": "The tiles are encoded in exactly the same way as TRLE, except that subencoding may not take the values 127 or 129, i.e., palettes cannot be reused between tiles.",
      "ja": "タイルはTRLEとまったく同じ方法で符号化されるsubencoding、値127又は129、即ちなわけではない以外は、パレットはタイル間で再利用することはできません。"
    },
    {
      "indent": 3,
      "text": "The server flushes the zlib stream to a byte boundary at the end of each ZRLE-encoded rectangle. It need not flush the stream between tiles within a rectangle. Since the zlibData for a single rectangle can potentially be quite large, clients can incrementally decode and interpret the zlibData but must not assume that encoded tile data is byte aligned.",
      "ja": "サーバは、各ZRLEエンコード矩形の末尾バイト境界にZLIBストリームをフラッシュします。これは、長方形内のタイルの間でストリームをフラッシュする必要はありません。 1つの四角形のためzlibDataが潜在的に非常に大きくなる可能性があるので、クライアントはインクリメンタルデコードしzlibDataを解釈が、エンコードされたタイルデータは、バイトが整列されていると仮定してはならないことができます。"
    },
    {
      "indent": 0,
      "text": "7.8. Pseudo-Encodings",
      "section_title": true,
      "ja": "7.8. 擬似エンコーディング"
    },
    {
      "indent": 3,
      "text": "An update rectangle with a \"pseudo-encoding\" does not directly represent pixel data but instead allows the server to send arbitrary data to the client. How this data is interpreted depends on the pseudo-encoding.",
      "ja": "「擬似符号化」と更新矩形を直接画素データを表す代わりに、サーバがクライアントに任意のデータを送信することができません。このデータをどのように解釈されるか擬似エンコーディングに依存します。"
    },
    {
      "indent": 0,
      "text": "7.8.1. Cursor Pseudo-Encoding",
      "section_title": true,
      "ja": "7.8.1. 擬似エンコードカーソル"
    },
    {
      "indent": 3,
      "text": "A client that requests the Cursor pseudo-encoding is declaring that it is capable of drawing a pointer cursor locally. This can significantly improve perceived performance over slow links. The server sets the cursor shape by sending a rectangle with the Cursor pseudo-encoding as part of an update. The rectangle's x-position and y-position indicate the hotspot of the cursor, and width and height indicate the width and height of the cursor in pixels. The data consists of width*height raw pixel values followed by a shape bitmask, with one bit corresponding to each pixel in the cursor rectangle. The bitmask consists of left-to-right, top-to-bottom scan lines, where each scan line is padded to a whole number of bytes, the number being div(width+7,8). Within each byte, the most significant bit represents the leftmost pixel; a bit set to 1 means the corresponding pixel in the cursor is valid.",
      "ja": "カーソル擬似エンコードを要求するクライアントは、ローカルポインタカーソルを描画することが可能であることを宣言されています。これはかなり低速リンク経由体感的なパフォーマンスを向上させることができます。サーバは、アップデートの一部としてカーソル擬似符号で矩形を送信することにより、カーソルの形状を設定します。矩形のx位置およびy位置は、カーソルのホットスポットを示し、幅と高さはピクセル単位でカーソルの幅と高さを示しています。データは、1ビットのカーソル矩形内の各画素に対応して、形状のビットマスク続い幅*高さ生のピクセル値から成ります。ビットマスクは、各走査線がバイトの整数、数あるDIV（幅+ 7,8）に埋め込まれ、左から右、上から下への走査線からなります。各バイト内、最上位ビットは最も左のピクセルを表します。 1に設定されたビットは、カーソル内の対応するピクセルが有効であることを意味します。"
    },
    {
      "indent": 7,
      "text": "+----------------------------+--------------+---------------+\n| No. of bytes               | Type [Value] | Description   |\n+----------------------------+--------------+---------------+\n| width*height*bytesPerPixel | PIXEL array  | cursor-pixels |\n| div(width+7,8)*height      | U8 array     | bitmask       |\n+----------------------------+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.8.2. DesktopSize Pseudo-Encoding",
      "section_title": true,
      "ja": "7.8.2.  DesktopSize擬似エンコーディング"
    },
    {
      "indent": 3,
      "text": "A client that requests the DesktopSize pseudo-encoding is declaring that it is capable of coping with a change in the framebuffer width and height. The server changes the desktop size by sending a rectangle with the DesktopSize pseudo-encoding as the last rectangle in an update. The rectangle's x-position and y-position are ignored, and width and height indicate the new width and height of the framebuffer.",
      "ja": "DesktopSize擬似符号化を要求するクライアントはフレームバッファの幅と高さの変化に対応することが可能であることを宣言されています。サーバは、更新の最後の矩形としてDesktopSize擬似符号で長方形を送信することによって、デスクトップサイズを変更します。矩形のx位置およびy位置は無視され、幅と高さは、フレームバッファの新しい幅と高さを示しています。"
    },
    {
      "indent": 3,
      "text": "There is no further data associated with the rectangle. After changing the desktop size, the server must assume that the client no longer has the previous framebuffer contents. This will usually result in a complete update of the framebuffer at the next update. However, for maximum interoperability with existing servers the client should preserve the top-left portion of the framebuffer between the old and new sizes.",
      "ja": "長方形に関連した更なるデータがありません。デスクトップのサイズを変更した後、サーバーは、クライアントがもはや以前のフレームバッファの内容を持っていると仮定してはなりません。これは通常、次の更新時にフレームバッファの完全な更新になります。しかし、最大の相互運用性を確保するため、既存のサーバとクライアントは、古いものと新しいサイズ間のフレームバッファの左上部分を保存する必要があります。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has allocated port 5900 to the RFB protocol. The other port numbers mentioned in Section 2 are called out for historical context and do not match IANA allocations.",
      "ja": "IANAは、RFBプロトコルにポート5900を割り当てています。第2節で述べた他のポート番号は、歴史的な文脈のために呼ばれ、IANAの割り当てと一致しません。"
    },
    {
      "indent": 3,
      "text": "Future assignments to the IANA registries created by this specification are to be made through either \"Expert Review\" or \"IESG Approval\" (if there is no currently appointed expert) as defined in [RFC5226].",
      "ja": "この仕様で作成されたIANAレジストリへの今後の割り当ては、「エキスパートレビュー」または「IESG承認」（現在任命専門家がいないがある場合）[RFC5226]で定義されているいずれかを介して行われるべきです。"
    },
    {
      "indent": 0,
      "text": "8.1. RFB Security Types",
      "section_title": true,
      "ja": "8.1.  RFBセキュリティの種類"
    },
    {
      "indent": 0,
      "text": "8.1.1. Registry Name",
      "section_title": true,
      "ja": "8.1.1. レジストリ名"
    },
    {
      "indent": 3,
      "text": "The name of this registry is \"Remote Framebuffer Security Types\".",
      "ja": "このレジストリの名前は、「リモートフレームバッファセキュリティの種類」です。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Registry Contents",
      "section_title": true,
      "ja": "8.1.2. レジストリの内容"
    },
    {
      "indent": 3,
      "text": "IANA established a registry for security types that are used with the RFB protocol.",
      "ja": "IANAは、RFBプロトコルで使用されているセキュリティの種類のレジストリを設立しました。"
    },
    {
      "indent": 3,
      "text": "The initial entries in the registry are:",
      "ja": "レジストリ内の最初のエントリは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "+------------+-------------------------+-----------------------+\n| Number     | Name                    | References            |\n+------------+-------------------------+-----------------------+\n| 0          | Invalid                 | (this document)       |\n| 1          | None                    | (this document)       |\n| 2          | VNC Authentication      | (this document)       |\n| 3 to 15    | RealVNC                 | (historic assignment) |\n| 16         | Tight                   | (historic assignment) |\n| 17         | Ultra                   | (historic assignment) |\n| 18         | TLS                     | (historic assignment) |\n| 19         | VeNCrypt                | (historic assignment) |\n| 20         | GTK-VNC SASL            | (historic assignment) |\n| 21         | MD5 hash authentication | (historic assignment) |\n| 22         | Colin Dean xvp          | (historic assignment) |\n| 128 to 255 | RealVNC                 | (historic assignment) |\n+------------+-------------------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8.2. Client-to-Server Message Types",
      "section_title": true,
      "ja": "8.2. クライアントからサーバへのメッセージの種類"
    },
    {
      "indent": 0,
      "text": "8.2.1. Registry Name",
      "section_title": true,
      "ja": "8.2.1. レジストリ名"
    },
    {
      "indent": 3,
      "text": "The name of this registry is \"Remote Framebuffer Client-to-Server Message Types\".",
      "ja": "このレジストリの名前は、「リモートフレームバッファクライアントからサーバへのメッセージタイプ」です。"
    },
    {
      "indent": 0,
      "text": "8.2.2. Registry Contents",
      "section_title": true,
      "ja": "8.2.2. レジストリの内容"
    },
    {
      "indent": 3,
      "text": "IANA established a registry for client-to-server message types that are used with the RFB protocol.",
      "ja": "IANAは、RFBプロトコルで使用されているクライアントからサーバーへのメッセージタイプのレジストリを設立しました。"
    },
    {
      "indent": 3,
      "text": "The initial entries in the registry are:",
      "ja": "レジストリ内の最初のエントリは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "+--------+------------------------------+-----------------------+\n| Number | Name                         | References            |\n+--------+------------------------------+-----------------------+\n| 0      | SetPixelFormat               | (this document)       |\n| 2      | SetEncodings                 | (this document)       |\n| 3      | FramebufferUpdateRequest     | (this document)       |\n| 4      | KeyEvent                     | (this document)       |\n| 5      | PointerEvent                 | (this document)       |\n| 6      | ClientCutText                | (this document)       |\n| 127    | VMWare                       | (historic assignment) |\n| 128    | Nokia Terminal Mode Spec     | (historic assignment) |\n| 249    | OLIVE Call Control           | (historic assignment) |\n| 250    | Colin Dean xvp               | (historic assignment) |\n| 251    | Pierre Ossman SetDesktopSize | (historic assignment) |\n| 252    | tight                        | (historic assignment) |\n| 253    | gii                          | (historic assignment) |\n| 254    | VMWare                       | (historic assignment) |\n| 255    | Anthony Liguori              | (historic assignment) |\n+--------+------------------------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8.3. Server-to-Client Message Types",
      "section_title": true,
      "ja": "8.3. サーバーからクライアントへのメッセージの種類"
    },
    {
      "indent": 0,
      "text": "8.3.1. Registry Name",
      "section_title": true,
      "ja": "8.3.1. レジストリ名"
    },
    {
      "indent": 3,
      "text": "The name of this registry is \"Remote Framebuffer Server-to-Client Message Types\".",
      "ja": "このレジストリの名前は、「リモートフレームバッファサーバーからクライアントへのメッセージタイプ」です。"
    },
    {
      "indent": 0,
      "text": "8.3.2. Registry Contents",
      "section_title": true,
      "ja": "8.3.2. レジストリの内容"
    },
    {
      "indent": 3,
      "text": "IANA established a registry for server-to-client message types that are used with the RFB protocol.",
      "ja": "IANAは、RFBプロトコルで使用されているサーバーからクライアントへのメッセージタイプのレジストリを設立しました。"
    },
    {
      "indent": 3,
      "text": "The initial entries in the registry are:",
      "ja": "レジストリ内の最初のエントリは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "+--------+--------------------------+-----------------------+\n| Number | Name                     | References            |\n+--------+--------------------------+-----------------------+\n| 0      | FramebufferUpdate        | (this document)       |\n| 1      | SetColourMapEntries      | (this document)       |\n| 2      | Bell                     | (this document)       |\n| 3      | ServerCutText            | (this document)       |\n| 127    | VMWare                   | (historic assignment) |\n| 128    | Nokia Terminal Mode Spec | (historic assignment) |\n| 249    | OLIVE Call Control       | (historic assignment) |\n| 250    | Colin Dean xvp           | (historic assignment) |\n| 252    | tight                    | (historic assignment) |\n| 253    | gii                      | (historic assignment) |\n| 254    | VMWare                   | (historic assignment) |\n| 255    | Anthony Liguori          | (historic assignment) |\n+--------+--------------------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8.4. RFB Encoding Types",
      "section_title": true,
      "ja": "8.4.  RFBエンコーディング型"
    },
    {
      "indent": 0,
      "text": "8.4.1. Registry Name",
      "section_title": true,
      "ja": "8.4.1. レジストリ名"
    },
    {
      "indent": 3,
      "text": "The name of this registry is \"Remote Framebuffer Encoding Types\".",
      "ja": "このレジストリの名前は、「リモートフレームバッファのエンコーディングタイプ」です。"
    },
    {
      "indent": 0,
      "text": "8.4.2. Registry Contents",
      "section_title": true,
      "ja": "8.4.2. レジストリの内容"
    },
    {
      "indent": 3,
      "text": "IANA established a registry for encoding types that are used with the RFB protocol.",
      "ja": "IANAは、RFBプロトコルで使用されるタイプを符号化するためにレジストリを確立しました。"
    },
    {
      "indent": 3,
      "text": "The initial entries in the registry are:",
      "ja": "レジストリ内の最初のエントリは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "+-------------------+----------------------------+------------------+\n| Number            | Name                       | References       |\n+-------------------+----------------------------+------------------+\n| 0                 | Raw                        | (this document)  |\n| 1                 | CopyRect                   | (this document)  |\n| 2                 | RRE                        | (this document)  |\n| 5                 | Hextile                    | (this document)  |\n| 16                | ZRLE                       | (this document)  |\n| -239              | Cursor pseudo-encoding     | (this document)  |\n| -223              | DesktopSize                | (this document)  |\n|                   | pseudo-encoding            |                  |\n| 4                 | CoRRE                      | (historic        |\n|                   |                            | assignment)      |\n| 6                 | zlib                       | (historic        |\n|                   |                            | assignment)      |\n| 7                 | tight                      | (historic        |\n|                   |                            | assignment)      |\n| 8                 | zlibhex                    | (historic        |\n|                   |                            | assignment)      |\n| 15                | TRLE                       | (this document)  |\n| 17                | Hitachi ZYWRLE             | (historic        |\n|                   |                            | assignment)      |\n| 1024 to 1099      | RealVNC                    | (historic        |\n|                   |                            | assignment)      |\n| -1 to -222        | tight options              | (historic        |\n|                   |                            | assignment)      |\n| -224 to -238      | tight options              | (historic        |\n|                   |                            | assignment)      |\n| -240 to -256      | tight options              | (historic        |\n|                   |                            | assignment)      |\n| -257 to -272      | Anthony Liguori            | (historic        |\n|                   |                            | assignment)      |\n| -273 to -304      | VMWare                     | (historic        |\n|                   |                            | assignment)      |\n| -305              | gii                        | (historic        |\n|                   |                            | assignment)      |\n| -306              | popa                       | (historic        |\n|                   |                            | assignment)      |\n| -307              | Peter Astrand DesktopName  | (historic        |\n|                   |                            | assignment)      |\n| -308              | Pierre Ossman              | (historic        |\n|                   | ExtendedDesktopSize        | assignment)      |\n| -309              | Colin Dean xvp             | (historic        |\n|                   |                            | assignment)      |\n| -310              | OLIVE Call Control         | (historic        |\n|                   |                            | assignment)      |\n| -412 to -512      | TurboVNC fine-grained      | (historic        |\n|                   | quality level              | assignment)      |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| -523 to -524      | Nokia Terminal Mode Spec   | (historic        |\n|                   |                            | assignment)      |\n| -763 to -768      | TurboVNC subsampling level | (historic        |\n|                   |                            | assignment)      |\n| 0x574d5600 to     | VMWare                     | (historic        |\n| 0x574d56ff        |                            | assignment)      |\n+-------------------+----------------------------+------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9. Security",
      "section_title": true,
      "ja": "9.セキュリティ"
    },
    {
      "indent": 3,
      "text": "The RFB protocol as defined here provides no security beyond the optional and cryptographically weak password check described in Section 7.2.2. In particular, it provides no protection against observation of or tampering with the data stream. It has typically been used on secure physical or virtual networks.",
      "ja": "ここで定義されているRFBプロトコルは、7.2.2項で説明したオプションと暗号的に弱いパスワードのチェックを超えて何のセキュリティを提供しません。特に、観察またはデータストリームの改ざんに対する保護を提供しません。それは、典型的には、安全な物理または仮想ネットワーク上で使用されてきました。"
    },
    {
      "indent": 3,
      "text": "Security methods beyond those described here may be used to protect the integrity of the data. The client and server might agree to use an extended security type to encrypt the session, or the session might be transmitted over a secure channel such as IPsec [RFC4301] or SSH [RFC4254].",
      "ja": "ここで説明されている以外のセキュリティ方式は、データの整合性を保護するために使用することができます。クライアントとサーバーは、セッションを暗号化するために拡張されたセキュリティタイプを使用することに同意するかもしれない、またはセッションは、IPsecの[RFC4301]またはSSH [RFC4254]などの安全なチャネルを介して送信される可能性があります。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgements",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "James Weatherall, Andy Harter, and Ken Wood also contributed to the design of the RFB protocol.",
      "ja": "ジェームズ・ウェザー、アンディー・ハーター、とケンウッドもRFBプロトコルの設計に貢献しました。"
    },
    {
      "indent": 3,
      "text": "RFB and VNC are registered trademarks of RealVNC Ltd. in the U.S. and in other countries.",
      "ja": "RFBとVNCは、米国およびその他の国におけるRealVNCの株式会社の登録商標です。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1950] Deutsch, L. and J-L. Gailly, \"ZLIB Compressed Data Format Specification version 3.3\", RFC 1950, May 1996.",
      "ja": "[RFC1950]ドイツ、L.及びJ-L。 Gailly氏、 \"ZLIB圧縮データフォーマット仕様バージョン3.3\"、RFC 1950、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC1951] Deutsch, P., \"DEFLATE Compressed Data Format Specification version 1.3\", RFC 1951, May 1996.",
      "ja": "[RFC1951]ドイツ、P.、 \"DEFLATE圧縮データフォーマット仕様バージョン1.3\"、RFC 1951、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[XLIBREF] Nye, A., \"XLIB Reference Manual R5\", June 1994.",
      "ja": "[XLIBREF]ナイ、A.、 \"XLIBリファレンスマニュアルR5\"、1994年6月。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC4254] Ylonen, T. and C. Lonvick, \"The Secure Shell (SSH) Connection Protocol\", RFC 4254, January 2006.",
      "ja": "[RFC4254] Ylonenと、T.とC. Lonvick、 \"セキュアシェル（SSH）接続プロトコル\"、RFC 4254、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[RFC4301]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Differences in Earlier Protocol Versions",
      "ja": "以前のプロトコルのバージョンの付録A.の違い"
    },
    {
      "indent": 3,
      "text": "For maximum interoperability, clients and servers should be prepared to fall back to the earlier 3.3 and 3.7 versions of the RFB protocol. Any version reported other than 3.7 or 3.8 should be treated as 3.3.",
      "ja": "最大の相互運用性のため、クライアントとサーバは、RFBプロトコルの以前の3.3と3.7のバージョンにフォールバックするために準備する必要があります。任意のバージョン3.7または3.8 3.3として扱われるべきである以外の報告しました。"
    },
    {
      "indent": 3,
      "text": "All of the differences occur in the initial handshake phase. Once the session reaches the ClientInit and ServerInit messages, all three protocol versions are identical. Even within a protocol version, clients and servers may support different subsets of the encoding and pseudo-encoding types.",
      "ja": "違いはすべて、初期ハンドシェークフェーズで発生します。セッションがClientInitとのServerInitメッセージに到達すると、3つのすべてのプロトコルのバージョンは同じです。偶数プロトコルバージョン内に、クライアントとサーバは、異なるエンコーディングのサブセットと擬似符号化タイプをサポートすることができます。"
    },
    {
      "indent": 0,
      "text": "A.1. Differences in the Version 3.3 Protocol",
      "ja": "A.1。バージョン3.3プロトコルの違い"
    },
    {
      "indent": 3,
      "text": "The ProtocolVersion message is:",
      "ja": "protocolVersionメッセージは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "RFB 003.003\\n (hex 52 46 42 20 30 30 33 2e 30 30 33 0a)",
      "ja": "RFB 003.003 \\ N（16進数52 46 42 20 30 30 33 2E 30 30 33 0A）"
    },
    {
      "indent": 3,
      "text": "In the security handshake (Section 7.1.2), rather than a two-way negotiation, the server decides the security type and sends a single word:",
      "ja": "セキュリティハンドシェイク（7.1.2項）のではなく、双方向の交渉では、サーバーは、セキュリティの種類を決定し、単一の単語を送信します。"
    },
    {
      "indent": 14,
      "text": "+--------------+--------------+---------------+\n| No. of bytes | Type [Value] | Description   |\n+--------------+--------------+---------------+\n| 4            | U32          | security-type |\n+--------------+--------------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The security-type may only take the value 0, 1, or 2. A value of 0 means that the connection has failed and is followed by a string giving the reason, as described in Section 7.1.2.",
      "ja": "セキュリティ型は、0の値は、セクション7.1.2で説明したように、接続が失敗したとの理由を表す文字列が続いていることを意味する値0、1、または2を取ることができます。"
    },
    {
      "indent": 3,
      "text": "If the security-type is 1, for no authentication, the server does not send the SecurityResult message but proceeds directly to the initialization messages (Section 7.3).",
      "ja": "セキュリティタイプが1の場合、認証なしのため、サーバーはSecurityResultメッセージを送信しませんが、初期化メッセージ（7.3節）に直接移行します。"
    },
    {
      "indent": 3,
      "text": "In VNC Authentication (Section 7.2.2), if the authentication fails, the server sends the SecurityResult message, but does not send an error message before closing the connection.",
      "ja": "認証が失敗した場合にVNC認証（7.2.2）では、サーバーはSecurityResultメッセージを送信しますが、接続を閉じる前に、エラーメッセージを送信しません。"
    },
    {
      "indent": 0,
      "text": "A.2. Differences in the Version 3.7 Protocol",
      "ja": "A.2。バージョン3.7プロトコルの違い"
    },
    {
      "indent": 3,
      "text": "The ProtocolVersion message is:",
      "ja": "protocolVersionメッセージは次のとおりです。"
    },
    {
      "indent": 7,
      "text": "RFB 003.007\\n (hex 52 46 42 20 30 30 33 2e 30 30 37 0a)",
      "ja": "RFB 003.007 \\ N（16進数52 46 42 20 30 30 33 2E 30 30 37 0A）"
    },
    {
      "indent": 3,
      "text": "After the security handshake, if the security-type is 1, for no authentication, the server does not send the SecurityResult message but proceeds directly to the initialization messages (Section 7.3).",
      "ja": "セキュリティタイプが1である場合、セキュリティ握手した後、無認証のために、サーバはSecurityResultメッセージを送信しませんが、初期化メッセージ（7.3節）に直接移行します。"
    },
    {
      "indent": 3,
      "text": "In VNC Authentication (Section 7.2.2), if the authentication fails, the server sends the SecurityResult message, but does not send an error message before closing the connection.",
      "ja": "認証が失敗した場合にVNC認証（7.2.2）では、サーバーはSecurityResultメッセージを送信しますが、接続を閉じる前に、エラーメッセージを送信しません。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Tristan Richardson RealVNC Ltd. Betjeman House, 104 Hills Road Cambridge CB2 1LQ UK",
      "ja": "トリスタン・リチャードソンRealVNCの株式会社Betjemanハウス、104ヒルズの道ケンブリッジCB2 1LQ英国"
    },
    {
      "indent": 3,
      "text": "Phone: +44 1223 310400 EMail: standards@realvnc.com URI: http://www.realvnc.com",
      "ja": "電話：+44 1223 310400 Eメール：standards@realvnc.com URI：http://www.realvnc.com"
    },
    {
      "indent": 3,
      "text": "John Levine RealVNC Ltd.",
      "ja": "ジョン・レヴィンRealVNCの株式会社"
    },
    {
      "indent": 3,
      "text": "Phone: +44 1223 790005 EMail: standards@taugh.com URI: http://jl.ly",
      "ja": "電話：+44 1223 790005 Eメール：standards@taugh.com URI：http://jl.ly"
    }
  ]
}