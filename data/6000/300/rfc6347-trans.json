{
  "title": {
    "text": "RFC 6347 - Datagram Transport Layer Security Version 1.2",
    "ja": "RFC 6347 - データグラムトランスポート層セキュリティバージョン1.2"
  },
  "number": 6347,
  "created_at": "2019-10-31 08:21:56.300278+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       E. Rescorla\nRequest for Comments: 6347                                    RTFM, Inc.\nObsoletes: 4347                                              N. Modadugu\nCategory: Standards Track                                   Google, Inc.\nISSN: 2070-1721                                             January 2012",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Datagram Transport Layer Security Version 1.2",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies version 1.2 of the Datagram Transport Layer Security (DTLS) protocol. The DTLS protocol provides communications privacy for datagram protocols. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery. The DTLS protocol is based on the Transport Layer Security (TLS) protocol and provides equivalent security guarantees. Datagram semantics of the underlying transport are preserved by the DTLS protocol. This document updates DTLS 1.0 to work with TLS version 1.2.",
      "ja": "この文書では、データグラムトランスポート層セキュリティ（DTLS）プロトコルのバージョン1.2を指定します。 DTLSプロトコルは、データグラムプロトコルの通信プライバシーを提供します。プロトコルは、クライアント/サーバアプリケーションは、盗聴、改ざん、またはメッセージ偽造を防ぐために設計された方法で通信することができます。 DTLSプロトコルは、トランスポート層セキュリティ（TLS）プロトコルに基づいており、同等のセキュリティ保証を提供しています。基礎となるトランスポートのデータグラムのセマンティクスは、DTLSプロトコルによって保存されています。このドキュメントの更新DTLS 1.0は、TLSバージョン1.2で動作します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6347.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6347で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2012 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Requirements Terminology ...................................5\n2. Usage Model .....................................................5\n3. Overview of DTLS ................................................5\n   3.1. Loss-Insensitive Messaging .................................6\n   3.2. Providing Reliability for Handshake ........................6\n        3.2.1. Packet Loss .........................................6\n        3.2.2. Reordering ..........................................7\n        3.2.3. Message Size ........................................7\n   3.3. Replay Detection ...........................................7\n4. Differences from TLS ............................................7\n   4.1. Record Layer ...............................................8\n        4.1.1. Transport Layer Mapping ............................10\n               4.1.1.1. PMTU Issues ...............................10\n        4.1.2. Record Payload Protection ..........................12\n               4.1.2.1. MAC .......................................12\n               4.1.2.2. Null or Standard Stream Cipher ............13\n               4.1.2.3. Block Cipher ..............................13\n               4.1.2.4. AEAD Ciphers ..............................13\n               4.1.2.5. New Cipher Suites .........................13\n               4.1.2.6. Anti-Replay ...............................13\n               4.1.2.7. Handling Invalid Records ..................14\n   4.2. The DTLS Handshake Protocol ...............................14\n        4.2.1. Denial-of-Service Countermeasures ..................15\n        4.2.2. Handshake Message Format ...........................18\n        4.2.3. Handshake Message Fragmentation and Reassembly .....19\n        4.2.4. Timeout and Retransmission .........................20\n               4.2.4.1. Timer Values ..............................24\n        4.2.5. ChangeCipherSpec ...................................25\n        4.2.6. CertificateVerify and Finished Messages ............25\n        4.2.7. Alert Messages .....................................25\n        4.2.8. Establishing New Associations with Existing\n               Parameters .........................................25\n   4.3. Summary of New Syntax .....................................26\n        4.3.1. Record Layer .......................................26\n        4.3.2. Handshake Protocol .................................27\n5. Security Considerations ........................................27\n6. Acknowledgments ................................................28\n7. IANA Considerations ............................................28\n8. Changes since DTLS 1.0 .........................................29\n9. References .....................................................30\n   9.1. Normative References ......................................30\n   9.2. Informative References ....................................31",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "TLS [TLS] is the most widely deployed protocol for securing network traffic. It is widely used for protecting Web traffic and for e-mail protocols such as IMAP [IMAP] and POP [POP]. The primary advantage of TLS is that it provides a transparent connection-oriented channel. Thus, it is easy to secure an application protocol by inserting TLS between the application layer and the transport layer. However, TLS must run over a reliable transport channel -- typically TCP [TCP]. Therefore, it cannot be used to secure unreliable datagram traffic.",
      "ja": "TLS [TLS]は、ネットワークトラフィックを保護するための最も普及しているプロトコルです。これは、広くWebトラフィックを保護するためや、IMAP [IMAP]とPOP [POP]などの電子メールプロトコルのために使用されています。 TLSの主な利点は、透過的な接続指向のチャネルを提供することです。したがって、アプリケーション層とトランスポート層との間にTLSを挿入することによって、アプリケーションプロトコルを確保することが容易です。通常、TCP [TCP]  - しかし、TLSは、信頼性の高いトランスポート・チャネル上で実行する必要があります。そのため、信頼性のないデータグラムトラフィックを保護するために使用することはできません。"
    },
    {
      "indent": 3,
      "text": "An increasing number of application layer protocols have been designed that use UDP transport. In particular, protocols such as the Session Initiation Protocol (SIP) [SIP] and electronic gaming protocols are increasingly popular. (Note that SIP can run over both TCP and UDP, but that there are situations in which UDP is preferable.) Currently, designers of these applications are faced with a number of unsatisfactory choices. First, they can use IPsec [RFC4301]. However, for a number of reasons detailed in [WHYIPSEC], this is only suitable for some applications. Second, they can design a custom application layer security protocol. Unfortunately, although application layer security protocols generally provide superior security properties (e.g., end-to-end security in the case of S/MIME), they typically require a large amount of effort to design -- in contrast to the relatively small amount of effort required to run the protocol over TLS.",
      "ja": "アプリケーション層プロトコルの増加数は、UDPトランスポートを使用するように設計されています。特に、このようなセッション開始プロトコル（SIP）[SIP]および電子ゲームプロトコルなどのプロトコルは、ますます普及しています。 （SIPは、TCPとUDPの両方で実行することもできますが、UDPが好適である状況があること。）現在、これらのアプリケーションの設計者は、不十分な選択肢の数に直面しています。まず、彼らは、IPsec [RFC4301]を使用することができます。しかし、[WHYIPSEC]に詳述さいくつかの理由で、これはいくつかの用途にのみ適しています。第二に、彼らはカスタムアプリケーション層のセキュリティプロトコルを設計することができます。アプリケーション層セキュリティプロトコルは、一般に、優れたセキュリティ特性（S / MIMEの場合には、例えば、エンドツーエンドのセキュリティ）を提供するが、残念ながら、それらは典型的に設計するための努力を大量に必要とする - の比較的少量とは対照的にTLSを超えるプロトコルを実行するのに必要な作業。"
    },
    {
      "indent": 3,
      "text": "In many cases, the most desirable way to secure client/server applications would be to use TLS; however, the requirement for datagram semantics automatically prohibits use of TLS. This memo describes a protocol for this purpose: Datagram Transport Layer Security (DTLS). DTLS is deliberately designed to be as similar to TLS as possible, both to minimize new security invention and to maximize the amount of code and infrastructure reuse.",
      "ja": "多くの場合、クライアント/サーバーアプリケーションを保護するための最も望ましい方法は、TLSを使用することです。しかし、データグラムのセマンティクスのための要件は自動的にTLSの使用を禁止しています。このメモは、この目的のためのプロトコルについて説明します。データグラムトランスポート層セキュリティ（DTLS）。 DTLSは、意図的に新しいセキュリティ発明を最小限にするために、コードとインフラストラクチャの再利用の量を最大にするために、両方の、可能な限りTLSと同様であるように設計されています。"
    },
    {
      "indent": 3,
      "text": "DTLS 1.0 [DTLS1] was originally defined as a delta from [TLS11]. This document introduces a new version of DTLS, DTLS 1.2, which is defined as a series of deltas to TLS 1.2 [TLS12]. There is no DTLS 1.1; that version number was skipped in order to harmonize version numbers with TLS. This version also clarifies some confusing points in the DTLS 1.0 specification.",
      "ja": "DTLS 1.0 [DTLS1]は、もともと[TLS11]からのデルタとして定義しました。この文書では、[TLS12] TLS 1.2デルタの一連のように定義されるDTLS、DTLS 1.2の新しいバージョンを導入します。何DTLS 1.1はありません。そのバージョン番号は、TLSでバージョン番号を調和させるためにスキップされました。このバージョンはまた、DTLS 1.0仕様では、いくつかの混乱のポイントを明確にしています。"
    },
    {
      "indent": 3,
      "text": "Implementations that speak both DTLS 1.2 and DTLS 1.0 can interoperate with those that speak only DTLS 1.0 (using DTLS 1.0 of course), just as TLS 1.2 implementations can interoperate with previous versions of TLS (see Appendix E.1 of [TLS12] for details), with the exception that there is no DTLS version of SSLv2 or SSLv3, so backward compatibility issues for those protocols do not apply.",
      "ja": "1.2及びDTLS 1.0のみ（もちろんDTLS 1.0を使用して）1.0 DTLS話すものと相互運用することができ、両方のDTLSを話す実装、TLS 1.2実装はTLSの以前のバージョンと相互運用することができるだけのように（詳細については[TLS12]の付録E.1参照）、SSLv2のかのSSLv3のないDTLSバージョンが存在しないことを除いて、これらのプロトコルのためにその下位互換性の問題は適用されません。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Terminology",
      "section_title": true,
      "ja": "1.1。要件の用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [REQ].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119 [REQ]で説明されるように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Usage Model",
      "section_title": true,
      "ja": "2.使用モデル"
    },
    {
      "indent": 3,
      "text": "The DTLS protocol is designed to secure data between communicating applications. It is designed to run in application space, without requiring any kernel modifications.",
      "ja": "DTLSプロトコルは、通信アプリケーション間でデータを保護するように設計されています。任意のカーネルの変更を必要とせずに、アプリケーション空間で実行するように設計されています。"
    },
    {
      "indent": 3,
      "text": "Datagram transport does not require or provide reliable or in-order delivery of data. The DTLS protocol preserves this property for payload data. Applications such as media streaming, Internet telephony, and online gaming use datagram transport for communication due to the delay-sensitive nature of transported data. The behavior of such applications is unchanged when the DTLS protocol is used to secure communication, since the DTLS protocol does not compensate for lost or re-ordered data traffic.",
      "ja": "データグラムトランスポートは、データの信頼性や順序どおりの配信を必要とするか、または提供しません。 DTLSプロトコルは、ペイロードデータのために、このプロパティを保持します。転送されるデータの遅延に敏感な性質のために、このようなメディアストリーミング、インターネット電話、および通信のためのオンラインゲームの利用データグラムの輸送などのアプリケーション。 DTLSプロトコルが失われたり、再注文データトラフィックを補償しないので、DTLSプロトコルは、通信を保護するために使用されている場合、このようなアプリケーションの動作は変わりません。"
    },
    {
      "indent": 0,
      "text": "3. Overview of DTLS",
      "section_title": true,
      "ja": "DTLSの3.概要"
    },
    {
      "indent": 3,
      "text": "The basic design philosophy of DTLS is to construct \"TLS over datagram transport\". The reason that TLS cannot be used directly in datagram environments is simply that packets may be lost or reordered. TLS has no internal facilities to handle this kind of unreliability; therefore, TLS implementations break when rehosted on datagram transport. The purpose of DTLS is to make only the minimal changes to TLS required to fix this problem. To the greatest extent possible, DTLS is identical to TLS. Whenever we need to invent new mechanisms, we attempt to do so in such a way that preserves the style of TLS.",
      "ja": "DTLSの基本的な設計思想は、「データグラムトランスポート上でTLS」を構築することです。 TLSは、データグラム環境で直接使用することができないという理由は、パケットが失われたり、並べ替えすることができるということだけです。 TLSは、信頼性の欠如のこの種を扱うためには内部の設備を持っていません。そのため、TLSの実装はデータグラムの輸送にリホストとき壊れます。 DTLSの目的は、この問題を解決するために必要なTLSにの​​み最小限の変更を行うことです。可能な限り、DTLSは、TLSと同じです。私たちは新しいメカニズムを考案する必要があるたびに、私たちは、TLSのスタイルを維持するような方法でそうしようとします。"
    },
    {
      "indent": 3,
      "text": "Unreliability creates problems for TLS at two levels:",
      "ja": "信頼性の欠如は、二つのレベルでTLSのための問題を作成します。"
    },
    {
      "indent": 6,
      "text": "1. TLS does not allow independent decryption of individual records. Because the integrity check depends on the sequence number, if record N is not received, then the integrity check on record N+1 will be based on the wrong sequence number and thus will fail. (Note that prior to TLS 1.1, there was no explicit IV and so decryption would also fail.)",
      "ja": "1. TLSは、個々のレコードの独立した復号化を許可していません。レコードのNが受信されない場合は、整合性チェックは、シーケンス番号に依存するため、レコードN + 1の整合性チェックは、間違ったシーケンス番号に基づいて行われますので、失敗します。 （TLS 1.1に先立って、そこには明示的なIVなかったので解読も失敗することに注意してください。）"
    },
    {
      "indent": 6,
      "text": "2. The TLS handshake layer assumes that handshake messages are delivered reliably and breaks if those messages are lost.",
      "ja": "2. TLSハンドシェイク層は、それらのメッセージが失われた場合のハンドシェイクメッセージが確実と休憩配信されることを前提としています。"
    },
    {
      "indent": 3,
      "text": "The rest of this section describes the approach that DTLS uses to solve these problems.",
      "ja": "このセクションの残りの部分は、DTLSは、これらの問題を解決するために使用する方法が記載されています。"
    },
    {
      "indent": 0,
      "text": "3.1. Loss-Insensitive Messaging",
      "section_title": true,
      "ja": "3.1。ロス・小文字を区別しないメッセージング"
    },
    {
      "indent": 3,
      "text": "In TLS's traffic encryption layer (called the TLS Record Layer), records are not independent. There are two kinds of inter-record dependency:",
      "ja": "（TLSレコード層と呼ばれる）TLSのトラフィック暗号化層では、レコードは独立していません。レコード間の依存関係の2種類があります。"
    },
    {
      "indent": 6,
      "text": "1. Cryptographic context (stream cipher key stream) is retained between records.",
      "ja": "1.暗号コンテキスト（鍵ストリーム暗号ストリーム）は、レコードの間に保持されています。"
    },
    {
      "indent": 6,
      "text": "2. Anti-replay and message reordering protection are provided by a MAC that includes a sequence number, but the sequence numbers are implicit in the records.",
      "ja": "2.アンチリプレイとメッセージの並べ替え保護は、シーケンス番号が含まれているMACが提供するが、シーケンス番号は、レコード内の暗黙的なされています。"
    },
    {
      "indent": 3,
      "text": "DTLS solves the first problem by banning stream ciphers. DTLS solves the second problem by adding explicit sequence numbers.",
      "ja": "DTLSは、ストリーム暗号を禁止することにより、最初の問題を解決します。 DTLSは、明示的なシーケンス番号を追加することにより、第二の問題を解決します。"
    },
    {
      "indent": 0,
      "text": "3.2. Providing Reliability for Handshake",
      "section_title": true,
      "ja": "3.2。ハンドシェイクのための信頼性を提供"
    },
    {
      "indent": 3,
      "text": "The TLS handshake is a lockstep cryptographic handshake. Messages must be transmitted and received in a defined order; any other order is an error. Clearly, this is incompatible with reordering and message loss. In addition, TLS handshake messages are potentially larger than any given datagram, thus creating the problem of IP fragmentation. DTLS must provide fixes for both of these problems.",
      "ja": "TLSハンドシェイクは、ロックステップ方式の暗号ハンドシェイクです。メッセージが送信され、定義された順序で受信されなければなりません。他の順序はエラーです。明らかに、これは、並べ替えやメッセージの損失と互換性がありません。また、TLSハンドシェイクメッセージは、従って、IPフラグメンテーションの問題を作成し、任意のデータグラムよりも潜在的に大きいです。 DTLSは、これらの問題の両方のためのフィックスを提供しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Packet Loss",
      "section_title": true,
      "ja": "3.2.1。パケットロス"
    },
    {
      "indent": 3,
      "text": "DTLS uses a simple retransmission timer to handle packet loss. The following figure demonstrates the basic concept, using the first phase of the DTLS handshake:",
      "ja": "DTLSは、パケット損失を処理するための簡単な再送タイマーを使用しています。次の図は、DTLSハンドシェイクの最初のフェーズを使用して、基本的な考え方を示しています。"
    },
    {
      "indent": 9,
      "text": "Client                                   Server\n------                                   ------\nClientHello           ------>",
      "raw": true
    },
    {
      "indent": 33,
      "text": "X<-- HelloVerifyRequest\n                 (lost)",
      "raw": true
    },
    {
      "indent": 9,
      "text": "[Timer Expires]",
      "ja": "【タイマが終了します】"
    },
    {
      "indent": 9,
      "text": "ClientHello           ------>\n(retransmit)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Once the client has transmitted the ClientHello message, it expects to see a HelloVerifyRequest from the server. However, if the server's message is lost, the client knows that either the ClientHello or the HelloVerifyRequest has been lost and retransmits. When the server receives the retransmission, it knows to retransmit.",
      "ja": "クライアントはClientHelloメッセージを送信した後は、サーバーからHelloVerifyRequestを見ることを期待します。サーバーのメッセージが失われた場合は、クライアントはのClientHelloまたはHelloVerifyRequestいずれかが失われ、再送信されたことを知ります。サーバが再送信を受信すると、再送信することを知っています。"
    },
    {
      "indent": 3,
      "text": "The server also maintains a retransmission timer and retransmits when that timer expires.",
      "ja": "また、サーバは、再送タイマーを維持し、そのタイマーが満了したときに再送信します。"
    },
    {
      "indent": 3,
      "text": "Note that timeout and retransmission do not apply to the HelloVerifyRequest, because this would require creating state on the server. The HelloVerifyRequest is designed to be small enough that it will not itself be fragmented, thus avoiding concerns about interleaving multiple HelloVerifyRequests.",
      "ja": "これは、サーバー上の状態を作り出す必要になるので、そのタイムアウトと再送がHelloVerifyRequestには適用されません。 HelloVerifyRequestは、このように複数のHelloVerifyRequestsをインターリーブの懸念を回避、それ自体が断片化されないことを十分に小さくなるように設計されています。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Reordering",
      "section_title": true,
      "ja": "3.2.2。並べ替え"
    },
    {
      "indent": 3,
      "text": "In DTLS, each handshake message is assigned a specific sequence number within that handshake. When a peer receives a handshake message, it can quickly determine whether that message is the next message it expects. If it is, then it processes it. If not, it queues it for future handling once all previous messages have been received.",
      "ja": "DTLSでは、各ハンドシェイクメッセージは、ハンドシェーク内の特定のシーケンス番号が割り当てられます。ピアがハンドシェイクメッセージを受信すると、それはすぐにそのメッセージは、それが期待次のメッセージであるか否かを判断することができます。もしそうであれば、それはそれを処理します。そうでない場合には、一度、すべての前のメッセージが受信された将来の取り扱いのためにそれをキューに入れます。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Message Size",
      "section_title": true,
      "ja": "3.2.3。メッセージサイズ"
    },
    {
      "indent": 3,
      "text": "TLS and DTLS handshake messages can be quite large (in theory up to 2^24-1 bytes, in practice many kilobytes). By contrast, UDP datagrams are often limited to <1500 bytes if IP fragmentation is not desired. In order to compensate for this limitation, each DTLS handshake message may be fragmented over several DTLS records, each of which is intended to fit in a single IP datagram. Each DTLS handshake message contains both a fragment offset and a fragment length. Thus, a recipient in possession of all bytes of a handshake message can reassemble the original unfragmented message.",
      "ja": "TLSとDTLSは（実際、多くのキロバイト単位で、最大2 ^ 24-1バイトまで理論的には）メッセージが非常に大きくなる可能性がハンドシェイク。 IPフラグメンテーションを希望されていない場合はこれとは対照的に、UDPデータグラムは、多くの場合、<1500バイトに制限されています。この制限を補償するために、各DTLSハンドシェイクメッセージは、単一のIPデータグラムに収まるように意図されてそれぞれがいくつかのDTLSレコード、上に断片化されてもよいです。各DTLSハンドシェイクメッセージは、フラグメントオフセットとフラグメント長さの両方を含みます。したがって、ハンドシェイクメッセージのすべてのバイトの所有における受信者は、元の断片化されていないメッセージを再構成することができます。"
    },
    {
      "indent": 0,
      "text": "3.3. Replay Detection",
      "section_title": true,
      "ja": "3.3。リプレイの検出"
    },
    {
      "indent": 3,
      "text": "DTLS optionally supports record replay detection. The technique used is the same as in IPsec AH/ESP, by maintaining a bitmap window of received records. Records that are too old to fit in the window and records that have previously been received are silently discarded. The replay detection feature is optional, since packet duplication is not always malicious, but can also occur due to routing errors. Applications may conceivably detect duplicate packets and accordingly modify their data transmission strategy.",
      "ja": "DTLSは、必要に応じて、レコードリプレイ検出をサポートしています。使用される技術は、受信されたレコードのビットマップ・ウィンドウを維持することにより、IPsecのAH / ESPと同じです。以前に受信されているウィンドウやレコードに収まるように古すぎるレコードは黙って破棄されます。パケットの重複が常に悪意のではなく、また、ルーティングエラーが原因で発生する可能性がありますので、リプレイ検出機能は、オプションです。アプリケーションは、おそらく重複したパケットを検出し、それに応じてデータ伝送戦略を変更することがあります。"
    },
    {
      "indent": 0,
      "text": "4. Differences from TLS",
      "section_title": true,
      "ja": "TLSから4の違い"
    },
    {
      "indent": 3,
      "text": "As mentioned in Section 3, DTLS is intentionally very similar to TLS. Therefore, instead of presenting DTLS as a new protocol, we present it as a series of deltas from TLS 1.2 [TLS12]. Where we do not explicitly call out differences, DTLS is the same as in [TLS12].",
      "ja": "第3節で述べたように、DTLSは意図的にTLSと非常によく似ています。そのため、代わりに新しいプロトコルとしてDTLSを提示する、我々は[TLS12] TLS 1.2からデルタのシリーズとしてそれを提示します。私たちは、明示的に違いを呼び出さない場合は、DTLSは[TLS12]と同じです。"
    },
    {
      "indent": 0,
      "text": "4.1. Record Layer",
      "section_title": true,
      "ja": "4.1。レコード層"
    },
    {
      "indent": 3,
      "text": "The DTLS record layer is extremely similar to that of TLS 1.2. The only change is the inclusion of an explicit sequence number in the record. This sequence number allows the recipient to correctly verify the TLS MAC. The DTLS record format is shown below:",
      "ja": "DTLSの記録層は、TLS 1.2のものと非常に類似しています。唯一の変化は、レコード内の明示的なシーケンス番号が含まれていることです。このシーケンス番号は、受信者が正しくTLS MACを確認することができます。 DTLSレコード形式を以下に示します。"
    },
    {
      "indent": 6,
      "text": "struct {\n     ContentType type;\n     ProtocolVersion version;\n     uint16 epoch;                                    // New field\n     uint48 sequence_number;                          // New field\n     uint16 length;\n     opaque fragment[DTLSPlaintext.length];\n   } DTLSPlaintext;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "type Equivalent to the type field in a TLS 1.2 record.",
      "ja": "TLS 1.2レコード内のタイプフィールドに相当タイプ。"
    },
    {
      "indent": 3,
      "text": "version The version of the protocol being employed. This document describes DTLS version 1.2, which uses the version { 254, 253 }. The version value of 254.253 is the 1's complement of DTLS version 1.2. This maximal spacing between TLS and DTLS version numbers ensures that records from the two protocols can be easily distinguished. It should be noted that future on-the-wire version numbers of DTLS are decreasing in value (while the true version number is increasing in value.)",
      "ja": "バージョン使用されているプロトコルのバージョン。このドキュメントでは、バージョン{254、253}を使用DTLSバージョン1.2を、記載されています。 254.253のバージョン値は、DTLSバージョン1.2の1の補数です。 TLSとDTLSバージョン番号の間のこの最大の間隔は、2つのプロトコルからのレコードが容易に区別できることを保証します。なお、将来のオンワイヤDTLSのバージョン番号が値が減少している（真のバージョン番号は値が増加されています。）"
    },
    {
      "indent": 3,
      "text": "epoch A counter value that is incremented on every cipher state change.",
      "ja": "すべての暗号状態の変化にインクリメントされるカウンタ値をエポック。"
    },
    {
      "indent": 3,
      "text": "sequence_number The sequence number for this record.",
      "ja": "このレコードのシーケンス番号をSEQUENCE_NUMBER。"
    },
    {
      "indent": 3,
      "text": "length Identical to the length field in a TLS 1.2 record. As in TLS 1.2, the length should not exceed 2^14.",
      "ja": "TLS 1.2レコード内の長さフィールドに同じ長さ。 TLS 1.2のように、長さが2 ^ 14を超えてはなりません。"
    },
    {
      "indent": 3,
      "text": "fragment Identical to the fragment field of a TLS 1.2 record.",
      "ja": "TLS 1.2レコードのフラグメントフィールドに同一の断片。"
    },
    {
      "indent": 3,
      "text": "DTLS uses an explicit sequence number, rather than an implicit one, carried in the sequence_number field of the record. Sequence numbers are maintained separately for each epoch, with each sequence_number initially being 0 for each epoch. For instance, if a handshake message from epoch 0 is retransmitted, it might have a sequence number after a message from epoch 1, even if the message from epoch 1 was transmitted first. Note that some care needs to be taken during the handshake to ensure that retransmitted messages use the right epoch and keying material.",
      "ja": "DTLSは、明示的なシーケンス番号ではなく、レコードのSEQUENCE_NUMBERフィールドで運ば暗黙の1を、使用しています。シーケンス番号は各SEQUENCE_NUMBERが最初に各エポックのために0であると、各エポックについて別々に維持されます。エポック0からハンドシェークメッセージが再送される場合、例えば、それがエポック1からのメッセージが最初に送信された場合でも、エポック1からのメッセージの後にシーケンス番号を有しているかもしれません。いくつかのケアが再送メッセージが右エポックとキーを使用することを確実にするためのハンドシェイク中に撮影する必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If several handshakes are performed in close succession, there might be multiple records on the wire with the same sequence number but from different cipher states. The epoch field allows recipients to distinguish such packets. The epoch number is initially zero and is incremented each time a ChangeCipherSpec message is sent. In order to ensure that any given sequence/epoch pair is unique, implementations MUST NOT allow the same epoch value to be reused within two times the TCP maximum segment lifetime. In practice, TLS implementations rarely rehandshake; therefore, we do not expect this to be a problem.",
      "ja": "いくつかの握手が近い連続して行われている場合は、同じシーケンス番号を持つ線ではなく、異なる暗号状態から複数のレコードがある可能性があります。エポックフィールドは、受信者が、そのようなパケットを区別することができます。エポック番号は、最初はゼロであり、ChangeCipherSpecをメッセージが送信されるたびにインクリメントされます。任意の所与の配列/エポックペアが一意であることを確実にするために、実装は、同じエポック値の2倍のTCP最大セグメント寿命内で再利用することを可能にしてはいけません。実際には、TLSの実装はめったに再ハンドシェイクません。そのため、私たちは、これが問題になることを期待しないでください。"
    },
    {
      "indent": 3,
      "text": "Note that because DTLS records may be reordered, a record from epoch 1 may be received after epoch 2 has begun. In general, implementations SHOULD discard packets from earlier epochs, but if packet loss causes noticeable problems they MAY choose to retain keying material from previous epochs for up to the default MSL specified for TCP [TCP] to allow for packet reordering. (Note that the intention here is that implementors use the current guidance from the IETF for MSL, not that they attempt to interrogate the MSL that the system TCP stack is using.) Until the handshake has completed, implementations MUST accept packets from the old epoch.",
      "ja": "DTLSレコードが並べ替えられる可能性があるため、エポック2が始まった後、エポック1からレコードを受信することができることに注意してください。一般的には、実装は、以前のエポックからのパケットを破棄すべきであるが、パケットロスが目立つ問題が発生した場合、彼らは、TCP [TCP]に指定したデフォルトのMSLまでのパケット並べ替えを可能にするために、以前のエポックから材料をキーイング保持することを選択するかもしれません。 （ここでの意図は実装者が、彼らは、システムのTCPスタックが使用しているMSLに質問しようとしないこと、MSLのためにIETFから現在のガイダンスを使用することであることに注意してください。）ハンドシェイクが完了するまでは、実装が古いエポックからのパケットを受け入れなければなりません。"
    },
    {
      "indent": 3,
      "text": "Conversely, it is possible for records that are protected by the newly negotiated context to be received prior to the completion of a handshake. For instance, the server may send its Finished message and then start transmitting data. Implementations MAY either buffer or discard such packets, though when DTLS is used over reliable transports (e.g., SCTP), they SHOULD be buffered and processed once the handshake completes. Note that TLS's restrictions on when packets may be sent still apply, and the receiver treats the packets as if they were sent in the right order. In particular, it is still impermissible to send data prior to completion of the first handshake.",
      "ja": "新たにネゴシエートコンテキストによって保護されたレコードは、ハンドシェイクが完了する前に受信するために逆に、それが可能です。たとえば、サーバーはそのFinishedメッセージを送信し、データの送信を開始します。 DTLSは、（例えば、SCTP）信頼できるトランスポート上で使用される場合、ハンドシェイクが完了すると、それらはバッファリングされ、処理されるべきであるけれども実装は、そのようなパケットをバッファまたは破棄いずれでもよいです。パケットが適用され、まだ送信され、それらが正しい順序で送信されたかのように、受信機がパケットを扱うときにTLSの制限があることに注意してください。特に、前最初のハンドシェイクの完了にデータを送信することが許されません。"
    },
    {
      "indent": 3,
      "text": "Note that in the special case of a rehandshake on an existing association, it is safe to process a data packet immediately, even if the ChangeCipherSpec or Finished messages have not yet been received provided that either the rehandshake resumes the existing session or that it uses exactly the same security parameters as the existing association. In any other case, the implementation MUST wait for the receipt of the Finished message to prevent downgrade attack.",
      "ja": "ChangeCipherSpecをまたはFinishedメッセージがまだ受信されていない場合でも、既存の関連に再ハンドシェイクの特別な場合には、すぐにデータパケットを処理しても安全であることに注意してくださいいずれかの再ハンドシェイクは、既存のセッションを再開するか、それが正確に使用することを提供既存の関連付けと同じセキュリティパラメータ。それ以外の場合は、実装は、ダウングレード攻撃を防ぐために、Finishedメッセージの受信を待たなければなりません。"
    },
    {
      "indent": 3,
      "text": "As in TLS, implementations MUST either abandon an association or rehandshake prior to allowing the sequence number to wrap.",
      "ja": "TLSのように、実装は、前のシーケンス番号をラップすることを可能に関連または再ハンドシェイクを放棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "Similarly, implementations MUST NOT allow the epoch to wrap, but instead MUST establish a new association, terminating the old association as described in Section 4.2.8. In practice, implementations rarely rehandshake repeatedly on the same channel, so this is not likely to be an issue.",
      "ja": "同様に、実装はエポックがラップするために許してはなりませんが、その代わりに、セクション4.2.8で説明したように、古い関連付けを終了し、新しいアソシエーションを確立しなければなりません。実際には、実装はめったに同じチャネル上で繰り返し再ハンドシェイクませんので、これは問題になりそうではありません。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Transport Layer Mapping",
      "section_title": true,
      "ja": "4.1.1。トランスポート層のマッピング"
    },
    {
      "indent": 3,
      "text": "Each DTLS record MUST fit within a single datagram. In order to avoid IP fragmentation, clients of the DTLS record layer SHOULD attempt to size records so that they fit within any PMTU estimates obtained from the record layer.",
      "ja": "各DTLSレコードは、単一のデータグラム内に適合しなければなりません。彼らは、記録層から得たすべてのPMTU推定値内に収まるように、IP断片化を避けるために、DTLS記録層のクライアントは、大きさの記録を試みる必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that unlike IPsec, DTLS records do not contain any association identifiers. Applications must arrange to multiplex between associations. With UDP, this is presumably done with the host/port number.",
      "ja": "IPsecのとは異なり、DTLSレコードが任意の関連識別子が含まれていないことに注意してください。アプリケーションは、団体の間で多重化する手配しなければなりません。 UDPでは、これはおそらくホスト/ポート番号で行われます。"
    },
    {
      "indent": 3,
      "text": "Multiple DTLS records may be placed in a single datagram. They are simply encoded consecutively. The DTLS record framing is sufficient to determine the boundaries. Note, however, that the first byte of the datagram payload must be the beginning of a record. Records may not span datagrams.",
      "ja": "複数DTLSレコードが単一のデータグラムに配置することができます。彼らは単に連続してエンコードされます。 DTLSレコードフレーミングは、境界を決定するのに十分です。データグラムのペイロードの最初のバイトは、レコードの先頭でなければならないこと、しかし、注意してください。レコードは、データグラムをまたがることはできません。"
    },
    {
      "indent": 3,
      "text": "Some transports, such as DCCP [DCCP] provide their own sequence numbers. When carried over those transports, both the DTLS and the transport sequence numbers will be present. Although this introduces a small amount of inefficiency, the transport layer and DTLS sequence numbers serve different purposes; therefore, for conceptual simplicity, it is superior to use both sequence numbers. In the future, extensions to DTLS may be specified that allow the use of only one set of sequence numbers for deployment in constrained environments.",
      "ja": "このようDCCP [DCCP]などの一部のトランスポートは、自分自身のシーケンス番号を提供します。これらのトランスポートを介して搬送される場合、DTLSトランスポートシーケンス番号の両方が存在することになります。これは非効率の少量を導入しているが、トランスポート層及びDTLSシーケンス番号は、異なる目的を果たします。従って、概念の単純化のために、両方のシーケンス番号を使用するよりも優れています。将来的には、DTLSへの拡張は、制約された環境での展開のためのシーケンス番号の一組のみの使用を許可するように指定することができます。"
    },
    {
      "indent": 3,
      "text": "Some transports, such as DCCP, provide congestion control for traffic carried over them. If the congestion window is sufficiently narrow, DTLS handshake retransmissions may be held rather than transmitted immediately, potentially leading to timeouts and spurious retransmission. When DTLS is used over such transports, care should be taken not to overrun the likely congestion window. [DCCPDTLS] defines a mapping of DTLS to DCCP that takes these issues into account.",
      "ja": "このようDCCPなどの一部のトランスポートは、それらの上に伝送されるトラフィックのための輻輳制御を提供します。輻輳ウィンドウが十分に狭い場合、DTLSハンドシェイクの再送信は、潜在的にタイムアウトとスプリアス再送信につながる、すぐに開催されたのではなく伝送することができます。 DTLSは、このようなトランスポート上で使用する場合は、注意がおそらく輻輳ウィンドウをオーバーランしないように注意してください。 【DCCPDTLS]アカウントにこれらの問題を取るDCCPにDTLSのマッピングを定義します。"
    },
    {
      "indent": 0,
      "text": "4.1.1.1. PMTU Issues",
      "section_title": true,
      "ja": "4.1.1.1。 PMTUの問題"
    },
    {
      "indent": 3,
      "text": "In general, DTLS's philosophy is to leave PMTU discovery to the application. However, DTLS cannot completely ignore PMTU for three reasons:",
      "ja": "一般的には、DTLSの哲学は、アプリケーションにPMTU検出を残すことです。しかし、DTLSは完全に三つの理由のためにPMTUを無視することはできません。"
    },
    {
      "indent": 3,
      "text": "- The DTLS record framing expands the datagram size, thus lowering the effective PMTU from the application's perspective.",
      "ja": " -  DTLSレコードフレーミングは、このように、アプリケーションの観点から効果的なPMTUを下げ、データグラムのサイズを拡張します。"
    },
    {
      "indent": 3,
      "text": "- In some implementations, the application may not directly talk to the network, in which case the DTLS stack may absorb ICMP [RFC1191] \"Datagram Too Big\" indications or ICMPv6 [RFC4443] \"Packet Too Big\" indications.",
      "ja": " - いくつかの実装形態では、アプリケーションは直接DTLSスタックがICMP [RFC1191]「データグラム過大」の適応症またはICMPv6の[RFC4443]「パケット過大」指示を吸収することができる場合にはネットワークに話をしないでもよいです。"
    },
    {
      "indent": 3,
      "text": "- The DTLS handshake messages can exceed the PMTU.",
      "ja": " -  DTLS握手メッセージはPMTUを超過することができます。"
    },
    {
      "indent": 3,
      "text": "In order to deal with the first two issues, the DTLS record layer SHOULD behave as described below.",
      "ja": "後述のように最初の二つの問題に対処するためには、DTLS記録層が振る舞うべき。"
    },
    {
      "indent": 3,
      "text": "If PMTU estimates are available from the underlying transport protocol, they should be made available to upper layer protocols. In particular:",
      "ja": "PMTU推定値が基礎となるトランスポートプロトコルから利用されている場合は、上位層プロトコルが利用できるようにする必要があります。特に："
    },
    {
      "indent": 3,
      "text": "- For DTLS over UDP, the upper layer protocol SHOULD be allowed to obtain the PMTU estimate maintained in the IP layer.",
      "ja": " -  UDP上DTLSの場合、上位層プロトコルは、IP層において維持PMTU推定値を得るために許容されるべきです。"
    },
    {
      "indent": 3,
      "text": "- For DTLS over DCCP, the upper layer protocol SHOULD be allowed to obtain the current estimate of the PMTU.",
      "ja": " -  DCCP上DTLSの場合、上位層プロトコルは、PMTUの現在の推定値を得るために許容されるべきです。"
    },
    {
      "indent": 3,
      "text": "- For DTLS over TCP or SCTP, which automatically fragment and reassemble datagrams, there is no PMTU limitation. However, the upper layer protocol MUST NOT write any record that exceeds the maximum record size of 2^14 bytes.",
      "ja": " - 自動的に断片化データグラムを再構築TCP又はSCTP上DTLSについては、何らPMTUの制限はありません。しかし、上位層プロトコルは、2 ^ 14バイトの最大レコード・サイズを超えたすべてのレコードを記述してはいけません。"
    },
    {
      "indent": 3,
      "text": "The DTLS record layer SHOULD allow the upper layer protocol to discover the amount of record expansion expected by the DTLS processing. Note that this number is only an estimate because of block padding and the potential use of DTLS compression.",
      "ja": "DTLS記録層は、上位層プロトコルがDTLS処理によって予想レコードの拡張の量を検出することを可能にするべきです。この数があるため、ブロックパディング及びDTLS圧縮の潜在的な使用の唯一の推定値であることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "If there is a transport protocol indication (either via ICMP or via a refusal to send the datagram as in Section 14 of [DCCP]), then the DTLS record layer MUST inform the upper layer protocol of the error.",
      "ja": "転送プロトコル指示が（ICMP経由または[DCCP]のセクション14のようにデータグラムを送信するために拒否を介してのいずれか）がある場合、DTLS記録層は、エラーの上位層プロトコルを通知しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The DTLS record layer SHOULD NOT interfere with upper layer protocols performing PMTU discovery, whether via [RFC1191] or [RFC4821] mechanisms. In particular:",
      "ja": "DTLS記録層は、[RFC1191]または[RFC4821]の機構を介しているかどうか、PMTU検出を行う上位層プロトコルを妨害してはなりません。特に："
    },
    {
      "indent": 3,
      "text": "- Where allowed by the underlying transport protocol, the upper layer protocol SHOULD be allowed to set the state of the DF bit (in IPv4) or prohibit local fragmentation (in IPv6).",
      "ja": " - 基礎となるトランスポートプロトコルによって許容される場合、上位層プロトコル（IPv4の）DFビットの状態を設定するか、または（IPv6での）局所的な断片化を禁止させるべきです。"
    },
    {
      "indent": 3,
      "text": "- If the underlying transport protocol allows the application to request PMTU probing (e.g., DCCP), the DTLS record layer should honor this request.",
      "ja": " - 基礎となるトランスポートプロトコルは、アプリケーションがPMTU（例えば、DCCP）をプローブ要求を許可する場合、DTLS記録層は、この要求を尊重すべきです。"
    },
    {
      "indent": 3,
      "text": "The final issue is the DTLS handshake protocol. From the perspective of the DTLS record layer, this is merely another upper layer protocol. However, DTLS handshakes occur infrequently and involve only a few round trips; therefore, the handshake protocol PMTU handling places a premium on rapid completion over accurate PMTU discovery. In order to allow connections under these circumstances, DTLS implementations SHOULD follow the following rules:",
      "ja": "最後の問題は、DTLSハンドシェイクプロトコルです。 DTLS記録層の観点から、これは、単に別の上位層プロトコルです。しかし、DTLSハンドシェイクがまれに発生し、わずか数回のラウンドトリップを必要とします。そのため、ハンドシェイクプロトコルPMTU処理は、正確なPMTUディスカバリを超える急速な完成に重点が置かれています。このような状況下での接続を可能にするために、DTLS実装は、以下の規則に従うべきです。"
    },
    {
      "indent": 3,
      "text": "- If the DTLS record layer informs the DTLS handshake layer that a message is too big, it SHOULD immediately attempt to fragment it, using any existing information about the PMTU.",
      "ja": " -  DTLS記録層は、メッセージが大きすぎることDTLSハンドシェイク層に通知した場合、それはすぐにPMTUに関する既存の情報を使用して、それを断片化しようとすべきです。"
    },
    {
      "indent": 3,
      "text": "- If repeated retransmissions do not result in a response, and the PMTU is unknown, subsequent retransmissions SHOULD back off to a smaller record size, fragmenting the handshake message as appropriate. This standard does not specify an exact number of retransmits to attempt before backing off, but 2-3 seems appropriate.",
      "ja": " - 繰り返し再送信が応答をもたらさない、とPMTUが不明な場合は、その後の再送信は、必要に応じて握手メッセージを断片化する、小さなレコードサイズにバックオフすべきです。この規格は、バックオフの前に試行する再送の正確な数を指定しませんが、2-3は適切と思われます。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Record Payload Protection",
      "section_title": true,
      "ja": "4.1.2。レコードのペイロードの保護"
    },
    {
      "indent": 3,
      "text": "Like TLS, DTLS transmits data as a series of protected records. The rest of this section describes the details of that format.",
      "ja": "TLSのように、DTLSは、保護された一連のレコードとしてデータを送信します。このセクションの残りの部分は、そのフォーマットの詳細について説明します。"
    },
    {
      "indent": 0,
      "text": "4.1.2.1. MAC",
      "section_title": true,
      "ja": "4.1.2.1。マック"
    },
    {
      "indent": 3,
      "text": "The DTLS MAC is the same as that of TLS 1.2. However, rather than using TLS's implicit sequence number, the sequence number used to compute the MAC is the 64-bit value formed by concatenating the epoch and the sequence number in the order they appear on the wire. Note that the DTLS epoch + sequence number is the same length as the TLS sequence number.",
      "ja": "DTLS MACは、TLS 1.2のものと同じです。しかし、むしろTLSの暗黙のシーケンス番号を使用するよりも、MACを計算するために使用されるシーケンス番号は、それらがワイヤ上に現れるためにエポックとシーケンス番号を連結することによって形成される64ビット値です。 DTLSエポック+シーケンス番号がTLSのシーケンス番号と同じ長さであることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "TLS MAC calculation is parameterized on the protocol version number, which, in the case of DTLS, is the on-the-wire version, i.e., {254, 253} for DTLS 1.2.",
      "ja": "TLS MAC計算は、すなわち、{254、253} DTLS 1.2、DTLSの場合には、オン・ザ・ワイヤバージョンであり、プロトコルのバージョン番号にパラメータ化されます。"
    },
    {
      "indent": 3,
      "text": "Note that one important difference between DTLS and TLS MAC handling is that in TLS, MAC errors must result in connection termination. In DTLS, the receiving implementation MAY simply discard the offending record and continue with the connection. This change is possible because DTLS records are not dependent on each other in the way that TLS records are.",
      "ja": "DTLSとTLS MAC処理の間に1つの重要な違いは、TLSで、MACエラーが接続終了につながるなければならないことであることに注意してください。 DTLSでは、受信実装は、単純に問題のあるレコードを捨てるかもしれとの接続を継続します。 DTLSレコードがTLSレコードがある方法で、お互いに依存しないため、この変更が可能です。"
    },
    {
      "indent": 3,
      "text": "In general, DTLS implementations SHOULD silently discard records with bad MACs or that are otherwise invalid. They MAY log an error. If a DTLS implementation chooses to generate an alert when it receives a message with an invalid MAC, it MUST generate a bad_record_mac alert with level fatal and terminate its connection state. Note that because errors do not cause connection termination, DTLS stacks are more efficient error type oracles than TLS stacks. Thus, it is especially important that the advice in Section 6.2.3.2 of [TLS12] be followed.",
      "ja": "一般的に、DTLS実装は静かに悪いのMACを持つレコードを破棄すべきであるか、それは、そうでない場合は無効です。彼らは、エラーを記録することがあります。 DTLS実装は、それが無効なMACでメッセージを受信したアラートを生成することを選択した場合、それは致命的なレベルにbad_record_macアラートを生成し、その接続状態を終了しなければなりません。エラーが接続終了を起こさないため、TLSはスタックよりも、DTLSスタックは、より効率的なエラータイプの神託であることに注意してください。したがって、[TLS12]のセクション6.2.3.2でのアドバイスに従うことが特に重要です。"
    },
    {
      "indent": 0,
      "text": "4.1.2.2. Null or Standard Stream Cipher",
      "section_title": true,
      "ja": "4.1.2.2。 NULLまたは標準ストリーム暗号"
    },
    {
      "indent": 3,
      "text": "The DTLS NULL cipher is performed exactly as the TLS 1.2 NULL cipher.",
      "ja": "DTLS NULL暗号はTLS 1.2 NULL暗号と全く同様に行われます。"
    },
    {
      "indent": 3,
      "text": "The only stream cipher described in TLS 1.2 is RC4, which cannot be randomly accessed. RC4 MUST NOT be used with DTLS.",
      "ja": "TLS 1.2に記載のみストリーム暗号は、ランダムにアクセスすることができないRC4、です。 RC4は、DTLSを使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "4.1.2.3. Block Cipher",
      "section_title": true,
      "ja": "4.1.2.3。ブロック暗号"
    },
    {
      "indent": 3,
      "text": "DTLS block cipher encryption and decryption are performed exactly as with TLS 1.2.",
      "ja": "DTLSブロック暗号の暗号化と復号化にはTLS 1.2のように正確に実行されます。"
    },
    {
      "indent": 0,
      "text": "4.1.2.4. AEAD Ciphers",
      "section_title": true,
      "ja": "4.1.2.4。 AEAD暗号"
    },
    {
      "indent": 3,
      "text": "TLS 1.2 introduced authenticated encryption with additional data (AEAD) cipher suites. The existing AEAD cipher suites, defined in [ECCGCM] and [RSAGCM], can be used with DTLS exactly as with TLS 1.2.",
      "ja": "TLS 1.2は、追加データ（AEAD）の暗号スイートと認証された暗号化を導入しました。 【ECCGCM]で定義された既存のAEAD暗号スイート、および[RSAGCM]、正確TLS 1.2と同様にDTLSと共に使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.1.2.5. New Cipher Suites",
      "section_title": true,
      "ja": "4.1.2.5。新しい暗号スイート"
    },
    {
      "indent": 3,
      "text": "Upon registration, new TLS cipher suites MUST indicate whether they are suitable for DTLS usage and what, if any, adaptations must be made (see Section 7 for IANA considerations).",
      "ja": "登録時には、新しいTLS暗号スイートは、（IANAの考慮事項については、セクション7を参照）は、DTLSの使用に適しており、何があれば、適応がなされなければならないかどうかを指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.2.6. Anti-Replay",
      "section_title": true,
      "ja": "4.1.2.6。アンチリプレイ"
    },
    {
      "indent": 3,
      "text": "DTLS records contain a sequence number to provide replay protection. Sequence number verification SHOULD be performed using the following sliding window procedure, borrowed from Section 3.4.3 of [ESP].",
      "ja": "DTLSレコードは再生保護を提供するために、シーケンス番号が含まれています。シーケンス番号検証は、[ESP]のセクション3.4.3から借用以下スライディングウィンドウプロシージャを使用して行われるべきです。"
    },
    {
      "indent": 3,
      "text": "The receiver packet counter for this session MUST be initialized to zero when the session is established. For each received record, the receiver MUST verify that the record contains a sequence number that does not duplicate the sequence number of any other record received during the life of this session. This SHOULD be the first check applied to a packet after it has been matched to a session, to speed rejection of duplicate records.",
      "ja": "セッションが確立されるとき、このセッションの受信パケットカウンタをゼロに初期化する必要があります。各レコードを受信するために、受信機は、レコードがこのセッションの存続期間中に受けた他のレコードのシーケンス番号を重複しないシーケンス番号が含まれていることを確かめなければなりません。これは、セッションにマッチされた後、最初のチェックは、重複レコードの拒絶反応を高速化するために、パケットに適用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Duplicates are rejected through the use of a sliding receive window. (How the window is implemented is a local matter, but the following text describes the functionality that the implementation must exhibit.) A minimum window size of 32 MUST be supported, but a window size of 64 is preferred and SHOULD be employed as the default. Another window size (larger than the minimum) MAY be chosen by the receiver. (The receiver does not notify the sender of the window size.)",
      "ja": "重複は、受信スライディングウィンドウを使用して拒否されます。 （ウィンドウの実装方法はローカルの問題ですが、次のテキストは、実装が示さなければならない機能について説明します。）32の最小ウィンドウサイズをサポートしなければならないが、64のウィンドウサイズが好まれ、デフォルトとして使用されるべきである（SHOULD） 。別のウィンドウサイズ（最小値よりも大きい）は、受信機によって選択されてもよいです。 （受信ウィンドウサイズの送信者に通知しません。）"
    },
    {
      "indent": 3,
      "text": "The \"right\" edge of the window represents the highest validated sequence number value received on this session. Records that contain sequence numbers lower than the \"left\" edge of the window are rejected. Packets falling within the window are checked against a list of received packets within the window. An efficient means for performing this check, based on the use of a bit mask, is described in Section 3.4.3 of [ESP].",
      "ja": "ウィンドウの「右側」縁がこのセッションで受信した最高検証シーケンス番号値を表します。ウィンドウの「左」端より小さいシーケンス番号を含むレコードは拒否されます。ウィンドウ内に入るパケットは、ウィンドウ内で受信したパケットのリストと照合されます。ビットマスクの使用に基づいて、このチェックを実行するための効率的な手段は、[ESP]のセクション3.4.3に記載されています。"
    },
    {
      "indent": 3,
      "text": "If the received record falls within the window and is new, or if the packet is to the right of the window, then the receiver proceeds to MAC verification. If the MAC validation fails, the receiver MUST discard the received record as invalid. The receive window is updated only if the MAC verification succeeds.",
      "ja": "受信したレコードは、ウィンドウ内に収まると新しいもの、またはパケットは、ウィンドウの右側にある場合、受信機はMACの検証に進む。場合MACの検証に失敗した場合、受信機は無効として受信したレコードを捨てなければなりません。受信ウィンドウは、MAC検証が成功した場合のみ更新されます。"
    },
    {
      "indent": 0,
      "text": "4.1.2.7. Handling Invalid Records",
      "section_title": true,
      "ja": "4.1.2.7。無効なレコードの処理"
    },
    {
      "indent": 3,
      "text": "Unlike TLS, DTLS is resilient in the face of invalid records (e.g., invalid formatting, length, MAC, etc.). In general, invalid records SHOULD be silently discarded, thus preserving the association; however, an error MAY be logged for diagnostic purposes. Implementations which choose to generate an alert instead, MUST generate fatal level alerts to avoid attacks where the attacker repeatedly probes the implementation to see how it responds to various types of error. Note that if DTLS is run over UDP, then any implementation which does this will be extremely susceptible to denial-of-service (DoS) attacks because UDP forgery is so easy. Thus, this practice is NOT RECOMMENDED for such transports.",
      "ja": "TLSとは異なり、DTLSは無効なレコード（例えば、無効なフォーマット、長さ、MAC、等）の面に弾性です。一般的には、無効なレコードは黙っので、関連付けを保存、破棄されるべきです。ただし、エラーは診断目的のために記録してもよいです。代わりにアラートを生成することを選択した実装は、攻撃者が繰り返し、それがエラーの様々なタイプにどのように応答するかを確認するために、実装をプローブ攻撃を回避するために、致命的なレベルのアラートを発生させなければなりません。 DTLSはUDP上で実行された場合、UDPの偽造は非常に簡単ですので、これを行う任意の実装は、サービス拒否（DoS）攻撃を非常に受けやすくなることに注意してください。したがって、このような行為は、そのようなトランスポートにはお勧めしません。"
    },
    {
      "indent": 3,
      "text": "If DTLS is being carried over a transport that is resistant to forgery (e.g., SCTP with SCTP-AUTH), then it is safer to send alerts because an attacker will have difficulty forging a datagram that will not be rejected by the transport layer.",
      "ja": "DTLSは偽造（SCTP-AUTHと、例えば、SCTP）に耐性があるトランスポート上で実行されている場合、攻撃者は難易トランスポート層によって拒否されることはありませんデータグラムを鍛造を持っていますので、アラートを送信する方が安全です。"
    },
    {
      "indent": 0,
      "text": "4.2. The DTLS Handshake Protocol",
      "section_title": true,
      "ja": "4.2。 DTLSハンドシェイクプロトコル"
    },
    {
      "indent": 3,
      "text": "DTLS uses all of the same handshake messages and flows as TLS, with three principal changes:",
      "ja": "DTLSは同じハンドシェークメッセージのすべてを使用して、三つの主要変化と、TLSのように流れます。"
    },
    {
      "indent": 6,
      "text": "1. A stateless cookie exchange has been added to prevent denial-of-service attacks.",
      "ja": "1.ステートレスクッキー交換は、サービス拒否攻撃を防ぐために追加されました。"
    },
    {
      "indent": 6,
      "text": "2. Modifications to the handshake header to handle message loss, reordering, and DTLS message fragmentation (in order to avoid IP fragmentation).",
      "ja": "メッセージの損失、並び替え、および（IP断片化を避けるために）DTLSメッセージの断片化を処理するためのハンドシェイク・ヘッダ2.変更。"
    },
    {
      "indent": 6,
      "text": "3. Retransmission timers to handle message loss.",
      "section_title": true,
      "ja": "3.再送信タイマーは、メッセージの損失を処理します。"
    },
    {
      "indent": 3,
      "text": "With these exceptions, the DTLS message formats, flows, and logic are the same as those of TLS 1.2.",
      "ja": "これらの例外を除いて、DTLSメッセージ形式、流れ、及びロジックは、TLS 1.2のものと同じです。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Denial-of-Service Countermeasures",
      "section_title": true,
      "ja": "4.2.1。サービス拒否対策"
    },
    {
      "indent": 3,
      "text": "Datagram security protocols are extremely susceptible to a variety of DoS attacks. Two attacks are of particular concern:",
      "ja": "データグラムのセキュリティプロトコルは、DoS攻撃の様々な非常に敏感です。二つの攻撃が特に懸念されています。"
    },
    {
      "indent": 6,
      "text": "1. An attacker can consume excessive resources on the server by transmitting a series of handshake initiation requests, causing the server to allocate state and potentially to perform expensive cryptographic operations.",
      "ja": "1.攻撃者は、サーバが状態を割り当てるために、潜在的に高価な暗号化操作を実行させる、ハンドシェイクの開始要求のシリーズを送信することにより、サーバに過度のリソースを消費することができます。"
    },
    {
      "indent": 6,
      "text": "2. An attacker can use the server as an amplifier by sending connection initiation messages with a forged source of the victim. The server then sends its next message (in DTLS, a Certificate message, which can be quite large) to the victim machine, thus flooding it.",
      "ja": "2.攻撃者が被害者の偽造ソースとの接続開始メッセージを送信することにより、増幅器としてサーバーを使用することができます。その後、サーバーはこれを洪水、被害者のマシンに（DTLSで、非常に大きくなることがCertificateメッセージ、）その次のメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "In order to counter both of these attacks, DTLS borrows the stateless cookie technique used by Photuris [PHOTURIS] and IKE [IKEv2]. When the client sends its ClientHello message to the server, the server MAY respond with a HelloVerifyRequest message. This message contains a stateless cookie generated using the technique of [PHOTURIS]. The client MUST retransmit the ClientHello with the cookie added. The server then verifies the cookie and proceeds with the handshake only if it is valid. This mechanism forces the attacker/client to be able to receive the cookie, which makes DoS attacks with spoofed IP addresses difficult. This mechanism does not provide any defense against DoS attacks mounted from valid IP addresses.",
      "ja": "これらの攻撃の両方に対抗するために、DTLSはPhoturis [PHOTURIS]とIKE [IKEv2の]で使用されるステートレスクッキー技術を借用します。クライアントがサーバへのClientHelloメッセージを送信すると、サーバーはHelloVerifyRequestメッセージで応答することができます。このメッセージは、[PHOTURIS]の手法を用いて生成されたステートレスクッキーを含んでいます。クライアントは、追加のCookieとのClientHelloを再送しなければなりません。その後、サーバーはクッキーを検証し、それが有効である場合にのみ、握手して進めます。このメカニズムは、偽装されたIPアドレスを持つDoS攻撃を困難にクッキーを受信できるように、攻撃者/クライアントを強制します。このメカニズムは、有効なIPアドレスから搭載されたDoS攻撃に対する任意の防衛を提供していません。"
    },
    {
      "indent": 3,
      "text": "The exchange is shown below:",
      "ja": "交換は以下の通りであります："
    },
    {
      "indent": 6,
      "text": "Client                                   Server\n------                                   ------\nClientHello           ------>",
      "raw": true
    },
    {
      "indent": 28,
      "text": "<----- HelloVerifyRequest\n       (contains cookie)",
      "raw": true
    },
    {
      "indent": 6,
      "text": "ClientHello           ------>\n(with cookie)",
      "raw": true
    },
    {
      "indent": 6,
      "text": "[Rest of handshake]",
      "ja": "[握手のレスト]"
    },
    {
      "indent": 3,
      "text": "DTLS therefore modifies the ClientHello message to add the cookie value.",
      "ja": "DTLSは、したがって、クッキーの値を追加するためにClientHelloメッセージを変更します。"
    },
    {
      "indent": 3,
      "text": "struct {\n  ProtocolVersion client_version;\n  Random random;\n  SessionID session_id;\n  opaque cookie<0..2^8-1>;                             // New field\n  CipherSuite cipher_suites<2..2^16-1>;\n        CompressionMethod compression_methods<1..2^8-1>;\n} ClientHello;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When sending the first ClientHello, the client does not have a cookie yet; in this case, the Cookie field is left empty (zero length).",
      "ja": "最初のClientHelloを送信する場合、クライアントはまだクッキーを持っていません。この場合には、クッキーフィールドは、空（ゼロ長さ）が残されます。"
    },
    {
      "indent": 3,
      "text": "The definition of HelloVerifyRequest is as follows:",
      "ja": "次のようにHelloVerifyRequestの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "struct {\n  ProtocolVersion server_version;\n  opaque cookie<0..2^8-1>;\n} HelloVerifyRequest;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The HelloVerifyRequest message type is hello_verify_request(3).",
      "ja": "HelloVerifyRequestメッセージタイプはhello_verify_requestである（3）。"
    },
    {
      "indent": 3,
      "text": "The server_version field has the same syntax as in TLS. However, in order to avoid the requirement to do version negotiation in the initial handshake, DTLS 1.2 server implementations SHOULD use DTLS version 1.0 regardless of the version of TLS that is expected to be negotiated. DTLS 1.2 and 1.0 clients MUST use the version solely to indicate packet formatting (which is the same in both DTLS 1.2 and 1.0) and not as part of version negotiation. In particular, DTLS 1.2 clients MUST NOT assume that because the server uses version 1.0 in the HelloVerifyRequest that the server is not DTLS 1.2 or that it will eventually negotiate DTLS 1.0 rather than DTLS 1.2.",
      "ja": "SERVER_VERSIONフィールドは、TLSと同じ構文を持っています。しかし、最初のハンドシェイクにバージョン交渉を行うための要件を避けるために、1.2サーバの実装にかかわらず、交渉されると予想されるTLSのバージョンのDTLSバージョン1.0を使用すべきであるDTLS。 DTLS 1.2と1.0のクライアントはなくバージョン交渉の一環として（両方DTLS 1.2と1.0で同じである）パケットのフォーマットを示すためにのみバージョンを使用する必要があります。具体的には、1.2クライアントは、サーバがサーバが1.2をDTLSか、それが最終的にではなくDTLS 1.2よりDTLS 1.0を交渉することをされていないことをHelloVerifyRequestでバージョン1.0を使用しているためと仮定してはいけませんDTLS。"
    },
    {
      "indent": 3,
      "text": "When responding to a HelloVerifyRequest, the client MUST use the same parameter values (version, random, session_id, cipher_suites, compression_method) as it did in the original ClientHello. The server SHOULD use those values to generate its cookie and verify that they are correct upon cookie receipt. The server MUST use the same version number in the HelloVerifyRequest that it would use when sending a ServerHello. Upon receipt of the ServerHello, the client MUST verify that the server version values match. In order to avoid sequence number duplication in case of multiple HelloVerifyRequests, the server MUST use the record sequence number in the ClientHello as the record sequence number in the HelloVerifyRequest.",
      "ja": "HelloVerifyRequestに応答するとき、それは元のClientHelloで行ったように、クライアントは、同じパラメータ値（バージョン、ランダム、SESSION_ID、cipher_suites、圧縮_）を使用する必要があります。サーバーは、そのクッキーを生成し、それらがクッキーの受信時に正しいことを確認するために、これらの値を使用すべきです。サーバはServerHelloメッセージを送信するときに、それが使用することをHelloVerifyRequestで同じバージョン番号を使用しなければなりません。 ServerHelloを受信すると、クライアントは、サーバのバージョン値が一致していることを確かめなければなりません。複数HelloVerifyRequestsの場合には、シーケンス番号の重複を避けるために、サーバはHelloVerifyRequestのレコードシーケンス番号としてのClientHelloのレコードシーケンス番号を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: This specification increases the cookie size limit to 255 bytes for greater future flexibility. The limit remains 32 for previous versions of DTLS.",
      "ja": "注：この仕様は大きな将来の柔軟性のために255バイトにクッキーのサイズ制限を増加させます。限界はDTLSの以前のバージョンの32のままです。"
    },
    {
      "indent": 3,
      "text": "The DTLS server SHOULD generate cookies in such a way that they can be verified without retaining any per-client state on the server. One technique is to have a randomly generated secret and generate cookies as:",
      "ja": "DTLSサーバーは、サーバー上で任意のクライアントごとの状態を保持せずに検証することができるようにクッキーを生成する必要があります。一つの技術は、ランダムに生成された秘密を持っているとして、クッキーを生成することです。"
    },
    {
      "indent": 6,
      "text": "Cookie = HMAC(Secret, Client-IP, Client-Parameters)",
      "ja": "クッキー= HMAC（シークレット、クライアントIP、クライアントのパラメータ）"
    },
    {
      "indent": 3,
      "text": "When the second ClientHello is received, the server can verify that the Cookie is valid and that the client can receive packets at the given IP address. In order to avoid sequence number duplication in case of multiple cookie exchanges, the server MUST use the record sequence number in the ClientHello as the record sequence number in its initial ServerHello. Subsequent ServerHellos will only be sent after the server has created state and MUST increment normally.",
      "ja": "第二のClientHelloを受信した場合、サーバーはクッキーが有効であることを確認することができ、クライアントが指定したIPアドレスのパケットを受信できること。複数のクッキー交換の場合には、シーケンス番号の重複を避けるために、サーバは、その初期のServerHelloのレコードシーケンス番号としてのClientHelloのレコードシーケンス番号を使用しなければなりません。後続のServerHellosは、サーバが状態を作成した後にのみ送信され、正常に増加しなければなりません。"
    },
    {
      "indent": 3,
      "text": "One potential attack on this scheme is for the attacker to collect a number of cookies from different addresses and then reuse them to attack the server. The server can defend against this attack by changing the Secret value frequently, thus invalidating those cookies. If the server wishes that legitimate clients be able to handshake through the transition (e.g., they received a cookie with Secret 1 and then sent the second ClientHello after the server has changed to Secret 2), the server can have a limited window during which it accepts both secrets. [IKEv2] suggests adding a version number to cookies to detect this case. An alternative approach is simply to try verifying with both secrets.",
      "ja": "攻撃者が別のアドレスからのCookieの数を収集し、サーバーを攻撃するためにそれらを再利用するために、このスキームの一つの潜在的な攻撃です。サーバーは、このように、これらのクッキーを無効にする、頻繁に秘密の値を変更することによって、この攻撃を防御することができます。サーバは（例えば、彼らは秘密の1でクッキーを受け取った後、サーバは秘密の2に変更された後、第2のClientHelloを送った）正当なクライアントは、移行を通じてハンドシェイクすることができることを希望する場合、サーバーは、それの間に限定されたウィンドウを持つことができます両方の秘密を受け入れます。 【のIKEv2この場合を検出するためにクッキーにバージョン番号を追加することを示唆しています。別のアプローチは、両方の秘密を検証しようとするだけです。"
    },
    {
      "indent": 3,
      "text": "DTLS servers SHOULD perform a cookie exchange whenever a new handshake is being performed. If the server is being operated in an environment where amplification is not a problem, the server MAY be configured not to perform a cookie exchange. The default SHOULD be that the exchange is performed, however. In addition, the server MAY choose not to do a cookie exchange when a session is resumed. Clients MUST be prepared to do a cookie exchange with every handshake.",
      "ja": "新しいハンドシェイクが実行されるたびにDTLSサーバは、クッキー交換を実行する必要があります。サーバは増幅が問題ではありません環境で動作している場合、サーバーはクッキー交換を行わないように構成されるかもしれません。デフォルトでは、しかし、交換が行われていることであるべきです。また、サーバは、セッションが再開されたときにクッキー交換を行うにはないことを選択することができます。クライアントは、すべてのハンドシェークとクッキー交換を行うために準備しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If HelloVerifyRequest is used, the initial ClientHello and HelloVerifyRequest are not included in the calculation of the handshake_messages (for the CertificateVerify message) and verify_data (for the Finished message).",
      "ja": "HelloVerifyRequestが使用される場合、初期のClientHelloとHelloVerifyRequestは（CertificateVerifyメッセージの）握手及び（Finishedメッセージ用）verify_dataの計算には含まれません。"
    },
    {
      "indent": 3,
      "text": "If a server receives a ClientHello with an invalid cookie, it SHOULD treat it the same as a ClientHello with no cookie. This avoids race/deadlock conditions if the client somehow gets a bad cookie (e.g., because the server changes its cookie signing key).",
      "ja": "サーバーが無効なクッキーとのClientHelloを受信した場合、それはそれをクッキーなしでのClientHelloと同じように扱うべきです。 （サーバがそのクッキーの署名キーが変更されるため、例えば）クライアントは何とか悪いクッキーを取得する場合、これはレース/デッドロック状態を回避することができます。"
    },
    {
      "indent": 3,
      "text": "Note to implementors: This may result in clients receiving multiple HelloVerifyRequest messages with different cookies. Clients SHOULD handle this by sending a new ClientHello with a cookie in response to the new HelloVerifyRequest.",
      "ja": "実装者への注意：これは、異なるクッキーを持つ複数のHelloVerifyRequestメッセージを受信して​​いるクライアントになることがあります。クライアントは、新しいHelloVerifyRequestに応じて、クッキーと新しいのClientHelloを送信することで、これを処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Handshake Message Format",
      "section_title": true,
      "ja": "4.2.2。ハンドシェイクメッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "In order to support message loss, reordering, and message fragmentation, DTLS modifies the TLS 1.2 handshake header:",
      "ja": "メッセージの損失、並び替え、およびメッセージの断片化をサポートするために、DTLSは、TLSハンドシェイク1.2ヘッダを変更します。"
    },
    {
      "indent": 3,
      "text": "struct {\n  HandshakeType msg_type;\n  uint24 length;\n  uint16 message_seq;                               // New field\n  uint24 fragment_offset;                           // New field\n  uint24 fragment_length;                           // New field\n  select (HandshakeType) {\n    case hello_request: HelloRequest;\n    case client_hello:  ClientHello;\n    case hello_verify_request: HelloVerifyRequest;  // New type\n    case server_hello:  ServerHello;\n    case certificate:Certificate;\n    case server_key_exchange: ServerKeyExchange;\n    case certificate_request: CertificateRequest;\n    case server_hello_done:ServerHelloDone;\n    case certificate_verify:  CertificateVerify;\n    case client_key_exchange: ClientKeyExchange;\n    case finished: Finished;\n  } body;\n} Handshake;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first message each side transmits in each handshake always has message_seq = 0. Whenever each new message is generated, the message_seq value is incremented by one. Note that in the case of a rehandshake, this implies that the HelloRequest will have message_seq = 0 and the ServerHello will have message_seq = 1. When a message is retransmitted, the same message_seq value is used. For example:",
      "ja": "各側は各握手に送信する最初のメッセージは、常にそれぞれの新しいメッセージが生成されるたびに、message_seq値が1だけインクリメントさmessage_seq = 0を有します。再ハンドシェイクの場合、これはHelloRequestはmessage_seq = 0を有することになるとのServerHelloメッセージが再送信される場合message_seqは= 1、同じmessage_seq値が使用されなければならないことを意味することに注意してください。例えば："
    },
    {
      "indent": 9,
      "text": "Client                             Server\n------                             ------\nClientHello (seq=0)  ------>",
      "raw": true
    },
    {
      "indent": 33,
      "text": "X<-- HelloVerifyRequest (seq=0)\n                (lost)",
      "raw": true
    },
    {
      "indent": 9,
      "text": "[Timer Expires]",
      "ja": "【タイマが終了します】"
    },
    {
      "indent": 9,
      "text": "ClientHello (seq=0)  ------>\n(retransmit)",
      "raw": true
    },
    {
      "indent": 30,
      "text": "<------ HelloVerifyRequest (seq=0)",
      "raw": true
    },
    {
      "indent": 9,
      "text": "ClientHello (seq=1)  ------>\n(with cookie)",
      "raw": true
    },
    {
      "indent": 30,
      "text": "<------        ServerHello (seq=1)\n<------        Certificate (seq=2)\n<------    ServerHelloDone (seq=3)",
      "raw": true
    },
    {
      "indent": 9,
      "text": "[Rest of handshake]",
      "ja": "[握手のレスト]"
    },
    {
      "indent": 3,
      "text": "Note, however, that from the perspective of the DTLS record layer, the retransmission is a new record. This record will have a new DTLSPlaintext.sequence_number value.",
      "ja": "DTLS記録層の観点から、再送が新しいレコードであること、しかし、注意してください。このレコードは新しいDTLSPlaintext.sequence_number値を持つことになります。"
    },
    {
      "indent": 3,
      "text": "DTLS implementations maintain (at least notionally) a next_receive_seq counter. This counter is initially set to zero. When a message is received, if its sequence number matches next_receive_seq, next_receive_seq is incremented and the message is processed. If the sequence number is less than next_receive_seq, the message MUST be discarded. If the sequence number is greater than next_receive_seq, the implementation SHOULD queue the message but MAY discard it. (This is a simple space/bandwidth tradeoff).",
      "ja": "DTLS実装は（少なくとも概念的に）next_receive_seqカウンタを維持します。このカウンタはゼロに初期設定されています。メッセージが受信されると、そのシーケンス番号が一致next_receive_seq、next_receive_seqインクリメントされた場合、メッセージが処理されます。シーケンス番号がnext_receive_seq未満の場合、メッセージは捨てなければなりません。シーケンス番号がnext_receive_seqよりも大きい場合、実装はメッセージをキューすべきであるが、それを捨てるかもしれ。 （これは、単純なスペース/帯域幅のトレードオフです）。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Handshake Message Fragmentation and Reassembly",
      "section_title": true,
      "ja": "4.2.3。ハンドシェイクメッセージフラグメンテーションおよび再構成"
    },
    {
      "indent": 3,
      "text": "As noted in Section 4.1.1, each DTLS message MUST fit within a single transport layer datagram. However, handshake messages are potentially bigger than the maximum record size. Therefore, DTLS provides a mechanism for fragmenting a handshake message over a number of records, each of which can be transmitted separately, thus avoiding IP fragmentation.",
      "ja": "セクション4.1.1で述べたように、各DTLSメッセージは、単一のトランスポート層データグラム内に収まらなければなりません。しかし、握手メッセージは最大レコード・サイズよりも潜在的に大きなされています。したがって、DTLSは、このようにIP断片化を回避する、別々に送信されることができるそれぞれがレコードの数、オーバーハンドシェイクメッセージを断片化するための機構を提供します。"
    },
    {
      "indent": 3,
      "text": "When transmitting the handshake message, the sender divides the message into a series of N contiguous data ranges. These ranges MUST NOT be larger than the maximum handshake fragment size and MUST jointly contain the entire handshake message. The ranges SHOULD NOT overlap. The sender then creates N handshake messages, all with the same message_seq value as the original handshake message. Each new message is labeled with the fragment_offset (the number of bytes contained in previous fragments) and the fragment_length (the length of this fragment). The length field in all messages is the same as the length field of the original message. An unfragmented message is a degenerate case with fragment_offset=0 and fragment_length=length.",
      "ja": "ハンドシェイクメッセージを送信する場合、送信側は、N個の連続データ範囲のシリーズにメッセージを分割します。これらの範囲は最大ハンドシェーク断片サイズよりも大きくてはならず、共同全体のハンドシェイクメッセージを含まなければなりません。範囲が重複しないようにしてください。送信者は、すべての元のハンドシェークメッセージと同じmessage_seq値と、Nのハンドシェイクメッセージを作成します。それぞれの新しいメッセージはfragment_offset（以前のフラグメントに含まれるバイト数）とfragment_length（この断片の長さ）で標識されます。すべてのメッセージの長さフィールドは、元のメッセージの長さフィールドと同じです。非断片化メッセージはfragment_offset = 0とfragment_length =長さを有する縮退ケースです。"
    },
    {
      "indent": 3,
      "text": "When a DTLS implementation receives a handshake message fragment, it MUST buffer it until it has the entire handshake message. DTLS implementations MUST be able to handle overlapping fragment ranges. This allows senders to retransmit handshake messages with smaller fragment sizes if the PMTU estimate changes.",
      "ja": "DTLS実装がハンドシェイクメッセージフラグメントを受信したとき、それは全体のハンドシェイクメッセージになるまで、それをバッファリングしなければなりません。 DTLS実装は重複断片範囲を扱うことができなければなりません。これは、PMTU推定値が変化した場合、送信者は、小さいフラグメントサイズでハンドシェイクメッセージを再送することができます。"
    },
    {
      "indent": 3,
      "text": "Note that as with TLS, multiple handshake messages may be placed in the same DTLS record, provided that there is room and that they are part of the same flight. Thus, there are two acceptable ways to pack two DTLS messages into the same datagram: in the same record or in separate records.",
      "ja": "TLSのように、複数のハンドシェークメッセージが部屋であり、それらが同じ飛行の一部であることという条件で、同じDTLSレコードに置かれてもよいことに留意されたいです。同じレコード内または別のレコード内：このように、同じデータグラムに2つのDTLSメッセージをパックするには、2つの許容可能な方法があります。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Timeout and Retransmission",
      "section_title": true,
      "ja": "4.2.4。タイムアウトと再送信"
    },
    {
      "indent": 3,
      "text": "DTLS messages are grouped into a series of message flights, according to the diagrams below. Although each flight of messages may consist of a number of messages, they should be viewed as monolithic for the purpose of timeout and retransmission.",
      "ja": "DTLSメッセージは、以下の図によれば、メッセージの航空券の系列にグループ化されます。メッセージの各フライトは、メッセージの数からなっていてもよいが、それらは、タイムアウトおよび再送信のためにモノリシックとして見られるべきです。"
    },
    {
      "indent": 3,
      "text": "Client                                          Server\n------                                          ------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ClientHello             -------->                           Flight 1",
      "raw": true
    },
    {
      "indent": 27,
      "text": "<-------    HelloVerifyRequest      Flight 2",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ClientHello             -------->                           Flight 3",
      "raw": true
    },
    {
      "indent": 27,
      "text": "                   ServerHello    \\\n                  Certificate*     \\\n            ServerKeyExchange*      Flight 4\n           CertificateRequest*     /\n<--------      ServerHelloDone    /",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Certificate*                                              \\\nClientKeyExchange                                          \\\nCertificateVerify*                                          Flight 5\n[ChangeCipherSpec]                                         /\nFinished                -------->                         /",
      "raw": true
    },
    {
      "indent": 27,
      "text": "            [ChangeCipherSpec]    \\ Flight 6\n<--------             Finished    /",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 1. Message Flights for Full Handshake",
      "ja": "完全なハンドシェイク図1.メッセージへの航空券"
    },
    {
      "indent": 3,
      "text": "Client                                           Server\n------                                           ------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ClientHello             -------->                          Flight 1",
      "raw": true
    },
    {
      "indent": 28,
      "text": "                  ServerHello    \\\n           [ChangeCipherSpec]     Flight 2\n<--------             Finished    /",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[ChangeCipherSpec]                                         \\Flight 3\nFinished                 -------->                         /",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 2. Message Flights for Session-Resuming Handshake\n                  (No Cookie Exchange)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DTLS uses a simple timeout and retransmission scheme with the following state machine. Because DTLS clients send the first message (ClientHello), they start in the PREPARING state. DTLS servers start in the WAITING state, but with empty buffers and no retransmit timer.",
      "ja": "DTLSは、次のステートマシンを持つ単純なタイムアウトと再送方式を使用しています。 DTLSクライアントが最初のメッセージ（のClientHello）を送信するので、彼らは準備中状態で開始します。 DTLSサーバは待ち状態ではなく、空のバッファなし再送信タイマーを開始します。"
    },
    {
      "indent": 8,
      "text": "              +-----------+\n              | PREPARING |\n        +---> |           | <--------------------+\n        |     |           |                      |\n        |     +-----------+                      |\n        |           |                            |\n        |           | Buffer next flight         |\n        |           |                            |\n        |          \\|/                           |\n        |     +-----------+                      |\n        |     |           |                      |\n        |     |  SENDING  |<------------------+  |\n        |     |           |                   |  | Send\n        |     +-----------+                   |  | HelloRequest\nReceive |           |                         |  |\n   next |           | Send flight             |  | or\n flight |  +--------+                         |  |\n        |  |        | Set retransmit timer    |  | Receive\n        |  |       \\|/                        |  | HelloRequest\n        |  |  +-----------+                   |  | Send\n        |  |  |           |                   |  | ClientHello\n        +--)--|  WAITING  |-------------------+  |\n        |  |  |           |   Timer expires   |  |\n        |  |  +-----------+                   |  |\n        |  |         |                        |  |\n        |  |         |                        |  |\n        |  |         +------------------------+  |\n        |  |                Read retransmit      |\nReceive |  |                                     |\n   last |  |                                     |\n flight |  |                                     |\n        |  |                                     |\n       \\|/\\|/                                    |\n                                                 |\n    +-----------+                                |\n    |           |                                |\n    | FINISHED  | -------------------------------+\n    |           |\n    +-----------+\n         |  /|\\\n         |   |\n         |   |\n         +---+",
      "raw": true
    },
    {
      "indent": 11,
      "text": " Read retransmit Retransmit last flight",
      "ja": "再送を再送最後の飛行を読みます"
    },
    {
      "indent": 10,
      "text": "Figure 3. DTLS Timeout and Retransmission State Machine",
      "ja": "図3. DTLSタイムアウトおよび再送信ステートマシン"
    },
    {
      "indent": 3,
      "text": "The state machine has three basic states.",
      "ja": "ステートマシンは、3つの基本的な状態を持ちます。"
    },
    {
      "indent": 3,
      "text": "In the PREPARING state, the implementation does whatever computations are necessary to prepare the next flight of messages. It then buffers them up for transmission (emptying the buffer first) and enters the SENDING state.",
      "ja": "準備状態では、実装は、計算は、メッセージの次のフライトを用意する必要があるものは何でもありません。その後、（第一のバッファを空に）送信のためにそれらをバッファと送信状態に入ります。"
    },
    {
      "indent": 3,
      "text": "In the SENDING state, the implementation transmits the buffered flight of messages. Once the messages have been sent, the implementation then enters the FINISHED state if this is the last flight in the handshake. Or, if the implementation expects to receive more messages, it sets a retransmit timer and then enters the WAITING state.",
      "ja": "派遣国では、実装は、メッセージのバッファリング飛行を送信します。メッセージが送信されると、これはハンドシェイクの最後のフライトの場合、実装は、FINISHED状態になります。または、実装は複数のメッセージを受信することを期待あれば、それは再送信タイマーを設定し、待ち状態に入ります。"
    },
    {
      "indent": 3,
      "text": "There are three ways to exit the WAITING state:",
      "ja": "待ち状態を終了するには、3つの方法があります。"
    },
    {
      "indent": 3,
      "text": "1. The retransmit timer expires: the implementation transitions to the SENDING state, where it retransmits the flight, resets the retransmit timer, and returns to the WAITING state.",
      "ja": "1.再送信タイマーが満了した：それは、飛行を再送する再送タイマーをリセットし、待ち状態に戻り派遣国へのインプリメンテーションに遷移。"
    },
    {
      "indent": 3,
      "text": "2. The implementation reads a retransmitted flight from the peer: the implementation transitions to the SENDING state, where it retransmits the flight, resets the retransmit timer, and returns to the WAITING state. The rationale here is that the receipt of a duplicate message is the likely result of timer expiry on the peer and therefore suggests that part of one's previous flight was lost.",
      "ja": "、派遣国への実装遷移、それは飛行を再送する再送タイマーをリセットし、待ち状態に戻ります。2.実装は、ピアから再送飛行を読み込みます。ここでの理論的根拠は、重複メッセージの受信がピアのタイマー期限切れの可能性が高い結果であるため、自分の前便の一部が失われたことを示唆しているということです。"
    },
    {
      "indent": 3,
      "text": "3. The implementation receives the next flight of messages: if this is the final flight of messages, the implementation transitions to FINISHED. If the implementation needs to send a new flight, it transitions to the PREPARING state. Partial reads (whether partial messages or only some of the messages in the flight) do not cause state transitions or timer resets.",
      "ja": "3.実装では、メッセージの次のフライトを受信します。これは、メッセージの最後の飛行である場合、実装は、完成に移行します。実装は新しいフライトを送信する必要がある場合、それは準備中状態に遷移します。部分的な読み取り（一部のメッセージのみを飛行中のメッセージのいくつかは、かどうか）状態遷移やタイマーのリセットが発生することはありません。"
    },
    {
      "indent": 3,
      "text": "Because DTLS clients send the first message (ClientHello), they start in the PREPARING state. DTLS servers start in the WAITING state, but with empty buffers and no retransmit timer.",
      "ja": "DTLSクライアントが最初のメッセージ（のClientHello）を送信するので、彼らは準備中状態で開始します。 DTLSサーバは待ち状態ではなく、空のバッファなし再送信タイマーを開始します。"
    },
    {
      "indent": 3,
      "text": "When the server desires a rehandshake, it transitions from the FINISHED state to the PREPARING state to transmit the HelloRequest. When the client receives a HelloRequest, it transitions from FINISHED to PREPARING to transmit the ClientHello.",
      "ja": "サーバが再ハンドシェイクを希望する場合は、HelloRequestを送信するための準備状態に仕上げ状態から遷移します。クライアントがHelloRequestを受信すると、それは、完成からのClientHelloを送信するための準備に移行します。"
    },
    {
      "indent": 3,
      "text": "In addition, for at least twice the default MSL defined for [TCP], when in the FINISHED state, the node that transmits the last flight (the server in an ordinary handshake or the client in a resumed handshake) MUST respond to a retransmit of the peer's last flight with a retransmit of the last flight. This avoids deadlock conditions if the last flight gets lost. This requirement applies to DTLS 1.0 as well, and though not explicit in [DTLS1], it was always required for the state machine to function correctly. To see why this is necessary, consider what happens in an ordinary handshake if the server's Finished message is lost: the server believes the handshake is complete but it actually is not. As the client is waiting for the Finished message, the client's retransmit timer will fire and it will retransmit the client's Finished message. This will cause the server to respond with its own Finished message, completing the handshake. The same logic applies on the server side for the resumed handshake.",
      "ja": "また、少なくとも二回のデフォルトMSLは、[TCP]のために定義され、完成状態で、最後の飛行（通常ハンドシェークにおけるサーバ又は再開ハンドシェーククライアント）を送信ノードは再送のに応答しなければならないときのために最終便の再送とピアの最終便。これが最後の飛行が失われる場合の条件をデッドロック回避します。この要件は、同様にDTLS 1.0に適用され、[DTLS1]で明示していないが、状態マシンが正しく機能するために、それが常に必要とされました。これが必要な理由を確認するには、サーバーのFinishedメッセージが失われた場合、通常の握手に何が起こるかを考えてみます。サーバはハンドシェイクが完了したと考えているが、それは実際にはありません。クライアントは、Finishedメッセージを待っているように、クライアントの再送信タイマーが発動すると、それは、クライアントのFinishedメッセージを再送します。これは、サーバがハンドシェイクを完了し、独自のFinishedメッセージで応答するようになります。同じ論理が再開握手のためにサーバ側で適用されます。"
    },
    {
      "indent": 3,
      "text": "Note that because of packet loss, it is possible for one side to be sending application data even though the other side has not received the first side's Finished message. Implementations MUST either discard or buffer all application data packets for the new epoch until they have received the Finished message for that epoch. Implementations MAY treat receipt of application data with a new epoch prior to receipt of the corresponding Finished message as evidence of reordering or packet loss and retransmit their final flight immediately, shortcutting the retransmission timer.",
      "ja": "一方が他方の側は第一の側のFinishedメッセージを受信して​​いないにもかかわらず、アプリケーションデータの送信であるためにパケット損失のため、それが可能であることに留意されたいです。実装は破棄するか、彼らはそのエポックのためにFinishedメッセージを受信するまで、新しい時代のために、すべてのアプリケーションデータパケットをバッファリングする必要があります。実装は、前の並べ替えやパケットロスの証拠として対応するFinishedメッセージの受信に新しいエポックとアプリケーションデータの受信を治療し、再送タイマをshortcutting、すぐに彼らの最後の飛行を再送信することができます。"
    },
    {
      "indent": 0,
      "text": "4.2.4.1. Timer Values",
      "section_title": true,
      "ja": "4.2.4.1。タイマー値"
    },
    {
      "indent": 3,
      "text": "Though timer values are the choice of the implementation, mishandling of the timer can lead to serious congestion problems; for example, if many instances of a DTLS time out early and retransmit too quickly on a congested link. Implementations SHOULD use an initial timer value of 1 second (the minimum defined in RFC 6298 [RFC6298]) and double the value at each retransmission, up to no less than the RFC 6298 maximum of 60 seconds. Note that we recommend a 1-second timer rather than the 3-second RFC 6298 default in order to improve latency for time-sensitive applications. Because DTLS only uses retransmission for handshake and not dataflow, the effect on congestion should be minimal.",
      "ja": "タイマー値は、実装の選択であるが、タイマーの取り扱いを誤ると、深刻な渋滞の問題につながることができます。例えば、初期のDTLSの時間の多くの事例が出​​ている場合や、混雑リンクをあまりにも早く再送信します。実装は、1秒（RFC 6298で定義された最小の[RFC6298]）の初期タイマ値を使用し、60秒のRFC 6298最大未満ないまで、各再送時の値を倍にすべきです。我々は時間に敏感なアプリケーションのための待ち時間を改善するために、1秒タイマーではなく、3秒RFC 6298のデフォルトを推奨していることに注意してください。 DTLSだけで握手していないデータフローの再送信を使用しているため、混雑への影響は最小限でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD retain the current timer value until a transmission without loss occurs, at which time the value may be reset to the initial value. After a long period of idleness, no less than 10 times the current timer value, implementations may reset the timer to the initial value. One situation where this might occur is when a rehandshake is used after substantial data transfer.",
      "ja": "損失なく伝送が発生するまでの実装は、その時点で値が初期値にリセットすることができ、現在のタイマ値を保持すべきです。怠惰、無未満、10倍現在のタイマ値の長い期間の後、実装が初期値にタイマーをリセットしてもよいです。再ハンドシェイクが実質的なデータ転送後に使用されるとき、これが発生する可能性のある一つの状況があります。"
    },
    {
      "indent": 0,
      "text": "4.2.5. ChangeCipherSpec",
      "section_title": true,
      "ja": "4.2.5。 ChangeCipherSpecを"
    },
    {
      "indent": 3,
      "text": "As with TLS, the ChangeCipherSpec message is not technically a handshake message but MUST be treated as part of the same flight as the associated Finished message for the purposes of timeout and retransmission. This creates a potential ambiguity because the order of the ChangeCipherSpec cannot be established unambiguously with respect to the handshake messages in case of message loss.",
      "ja": "TLSと同様に、ChangeCipherSpecをメッセージには、技術的にハンドシェイクメッセージではなく、タイムアウトおよび再送信の目的のために関連したFinishedメッセージと同じフライトの一部として扱われなければなりません。 ChangeCipherSpecを順序がメッセージの損失の場合にハンドシェイクメッセージに対して明確に確立することができないので、これは潜在的なあいまいさを作成します。"
    },
    {
      "indent": 3,
      "text": "This is not a problem with any current TLS mode because the expected set of handshake messages logically preceeding the ChangeCipherSpec is predictable from the rest of the handshake state. However, future modes MUST take care to avoid creating ambiguity.",
      "ja": "論理的にChangeCipherSpecをを先行握手メッセージの予想セットは握手状態の残りの部分から予測可能であるので、これは任意の現在のTLSモードの問題ではありません。しかし、将来のモードは、あいまいさを作成しないように注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.6. CertificateVerify and Finished Messages",
      "section_title": true,
      "ja": "4.2.6。 CertificateVerifyとFinishedメッセージ"
    },
    {
      "indent": 3,
      "text": "CertificateVerify and Finished messages have the same format as in TLS. Hash calculations include entire handshake messages, including DTLS-specific fields: message_seq, fragment_offset, and fragment_length. However, in order to remove sensitivity to handshake message fragmentation, the Finished MAC MUST be computed as if each handshake message had been sent as a single fragment. Note that in cases where the cookie exchange is used, the initial ClientHello and HelloVerifyRequest MUST NOT be included in the CertificateVerify or Finished MAC computations.",
      "ja": "CertificateVerifyとFinishedメッセージは、TLSと同じフォーマットを有します。 message_seq、fragment_offset、およびfragment_length：ハッシュ計算はDTLS固有のフィールドを含む全体のハンドシェイクメッセージが含まれます。各ハンドシェイクメッセージは、単一の断片として送信されたかのようしかし、メッセージの断片化をハンドシェイクに対する感度を除去するために、完成MACが計算されなければなりません。クッキー交換が使用されている場合には、初期のClientHelloとHelloVerifyRequestはCertificateVerifyまたは完成MACの計算に含めてはならないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.2.7. Alert Messages",
      "section_title": true,
      "ja": "4.2.7。警告メッセージ"
    },
    {
      "indent": 3,
      "text": "Note that Alert messages are not retransmitted at all, even when they occur in the context of a handshake. However, a DTLS implementation which would ordinarily issue an alert SHOULD generate a new alert message if the offending record is received again (e.g., as a retransmitted handshake message). Implementations SHOULD detect when a peer is persistently sending bad messages and terminate the local connection state after such misbehavior is detected.",
      "ja": "彼らは握手のコンテキストで発生した場合でも、警告メッセージがすべてで再送信されていないことに注意してください。問題のあるレコードが（例えば、再送されたハンドシェイクメッセージとして）再び受信した場合は、通常は警告を発行しDTLS実装は、新しい警告メッセージを生成する必要があります。実装は、ピアが持続悪いメッセージを送信しているときを検出し、そのような不正行為が検出された後にローカル接続状態を終了すべきです。"
    },
    {
      "indent": 0,
      "text": "4.2.8. Establishing New Associations with Existing Parameters",
      "section_title": true,
      "ja": "4.2.8。既存のパラメータで新団体を設立"
    },
    {
      "indent": 3,
      "text": "If a DTLS client-server pair is configured in such a way that repeated connections happen on the same host/port quartet, then it is possible that a client will silently abandon one connection and then initiate another with the same parameters (e.g., after a reboot). This will appear to the server as a new handshake with epoch=0. In cases where a server believes it has an existing association on a given host/port quartet and it receives an epoch=0 ClientHello, it SHOULD proceed with a new handshake but MUST NOT destroy the existing association until the client has demonstrated reachability either by completing a cookie exchange or by completing a complete handshake including delivering a verifiable Finished message. After a correct Finished message is received, the server MUST abandon the previous association to avoid confusion between two valid associations with overlapping epochs. The reachability requirement prevents off-path/blind attackers from destroying associations merely by sending forged ClientHellos.",
      "ja": "DTLSクライアントサーバペアは接続が同じホスト/ポートカルテットに起こる繰り返しように構成されている場合、クライアントが黙っつの接続を放棄して、後に、例えば同じパラメータ（と別のを開始することが可能ですリブート）。これはエポック= 0を持つ新しいハンドシェイクとしてサーバーに表示されます。サーバは、それが特定のホスト/ポートカルテット上の既存の関連付けを持っており、それがエポック= 0のClientHelloを受けると考えている場合には、それは新しい握手を進める必要がありますが、クライアントが完了することにより、いずれかの到達可能性を実証したまでは既存の関連付けを破壊してはなりませんクッキー交換又は検証完成メッセージを配信するなど、完全なハンドシェイクを完了することもできます。正しいFinishedメッセージを受信すると、サーバは、重複エポックを持つ2つの有効な団体間の混乱を避けるために、以前の関連付けを放棄しなければなりません。到達可能性要件は、単に偽造ClientHellosを送信することにより、関連付けを破壊するからオフパス/ブラインド攻撃を防ぐことができます。"
    },
    {
      "indent": 0,
      "text": "4.3. Summary of New Syntax",
      "section_title": true,
      "ja": "4.3。新しい構文の概要"
    },
    {
      "indent": 3,
      "text": "This section includes specifications for the data structures that have changed between TLS 1.2 and DTLS 1.2. See [TLS12] for the definition of this syntax.",
      "ja": "このセクションでは、TLS 1.2およびDTLS 1.2の間で変更されているデータ構造の仕様が含まれています。この構文の定義について[TLS12]を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Record Layer",
      "section_title": true,
      "ja": "4.3.1。レコード層"
    },
    {
      "indent": 3,
      "text": "struct {\n     ContentType type;\n     ProtocolVersion version;\n     uint16 epoch;                                     // New field\n     uint48 sequence_number;                           // New field\n     uint16 length;\n     opaque fragment[DTLSPlaintext.length];\n   } DTLSPlaintext;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct {\n  ContentType type;\n  ProtocolVersion version;\n  uint16 epoch;                                     // New field\n  uint48 sequence_number;                           // New field\n  uint16 length;\n  opaque fragment[DTLSCompressed.length];\n} DTLSCompressed;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct {\n  ContentType type;\n  ProtocolVersion version;\n  uint16 epoch;                                     // New field\n  uint48 sequence_number;                           // New field\n  uint16 length;\n  select (CipherSpec.cipher_type) {\n    case block:  GenericBlockCipher;\n    case aead:   GenericAEADCipher;                 // New field\n  } fragment;\n} DTLSCiphertext;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3.2. Handshake Protocol",
      "section_title": true,
      "ja": "4.3.2。ハンドシェイクプロトコル"
    },
    {
      "indent": 3,
      "text": "enum {\n  hello_request(0), client_hello(1), server_hello(2),\n  hello_verify_request(3),                          // New field\n  certificate(11), server_key_exchange (12),\n  certificate_request(13), server_hello_done(14),\n  certificate_verify(15), client_key_exchange(16),\n  finished(20), (255) } HandshakeType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct {\n  HandshakeType msg_type;\n  uint24 length;\n  uint16 message_seq;                               // New field\n  uint24 fragment_offset;                           // New field\n  uint24 fragment_length;                           // New field\n  select (HandshakeType) {\n    case hello_request: HelloRequest;\n    case client_hello:  ClientHello;\n    case server_hello:  ServerHello;\n    case hello_verify_request: HelloVerifyRequest;  // New field\n    case certificate:Certificate;\n    case server_key_exchange: ServerKeyExchange;\n    case certificate_request: CertificateRequest;\n    case server_hello_done:ServerHelloDone;\n    case certificate_verify:  CertificateVerify;\n    case client_key_exchange: ClientKeyExchange;\n    case finished: Finished;\n  } body; } Handshake;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct {\n  ProtocolVersion client_version;\n  Random random;\n  SessionID session_id;\n  opaque cookie<0..2^8-1>;                             // New field\n  CipherSuite cipher_suites<2..2^16-1>;\n  CompressionMethod compression_methods<1..2^8-1>; } ClientHello;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct {\n  ProtocolVersion server_version;\n  opaque cookie<0..2^8-1>; } HelloVerifyRequest;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This document describes a variant of TLS 1.2; therefore, most of the security considerations are the same as those of TLS 1.2 [TLS12], described in Appendices D, E, and F.",
      "ja": "このドキュメントは、TLS 1.2の変形を説明します。従って、セキュリティ問題のほとんどは、付録D、E、およびFに記載され、TLS 1.2 [TLS12]のものと同じです"
    },
    {
      "indent": 3,
      "text": "The primary additional security consideration raised by DTLS is that of denial of service. DTLS includes a cookie exchange designed to protect against denial of service. However, implementations that do not use this cookie exchange are still vulnerable to DoS. In particular, DTLS servers that do not use the cookie exchange may be used as attack amplifiers even if they themselves are not experiencing DoS. Therefore, DTLS servers SHOULD use the cookie exchange unless there is good reason to believe that amplification is not a threat in their environment. Clients MUST be prepared to do a cookie exchange with every handshake.",
      "ja": "DTLSが提起した主な追加のセキュリティの考慮事項は、サービス拒否のものです。 DTLSは、サービス拒否から保護するために設計されたクッキーの交換が含まれています。しかし、このクッキー交換を使用していない実装はまだDoS攻撃に対して脆弱です。彼ら自身がDoS攻撃を経験していない場合でも具体的には、クッキー交換を使用していないDTLSサーバは、攻撃アンプとして使用することができます。増幅は、その環境での脅威ではないことを信じる十分な理由がある場合を除きしたがって、DTLSサーバは、クッキー交換を使用すべきです。クライアントは、すべてのハンドシェークとクッキー交換を行うために準備しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Unlike TLS implementations, DTLS implementations SHOULD NOT respond to invalid records by terminating the connection. See Section 4.1.2.7 for details on this.",
      "ja": "TLSの実装とは異なり、DTLS実装は、接続を終了することによって無効なレコードに応答すべきでありません。この詳細については、セクション4.1.2.7を参照してください。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgments",
      "section_title": true,
      "ja": "6.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Dan Boneh, Eu-Jin Goh, Russ Housley, Constantine Sapuntzakis, and Hovav Shacham for discussions and comments on the design of DTLS. Thanks to the anonymous NDSS reviewers of our original NDSS paper on DTLS [DTLS] for their comments. Also, thanks to Steve Kent for feedback that helped clarify many points. The section on PMTU was cribbed from the DCCP specification [DCCP]. Pasi Eronen provided a detailed review of this specification. Peter Saint-Andre provided the list of changes in Section 8. Helpful comments on the document were also received from Mark Allman, Jari Arkko, Mohamed Badra, Michael D'Errico, Adrian Farrell, Joel Halpern, Ted Hardie, Charlia Kaufman, Pekka Savola, Allison Mankin, Nikos Mavrogiannopoulos, Alexey Melnikov, Robin Seggelmann, Michael Tuexen, Juho Vaha-Herttua, and Florian Weimer.",
      "ja": "著者は、DTLSの設計に関する議論やコメントのためにダン・ボネ、Euのジンゴー、ラスHousley、コンスタンティンSapuntzakis、およびホバフ・シャチャムに感謝したいと思います。彼らのコメントのためにDTLS [DTLS]に独自のNDSS紙の匿名のNDSSの審査に感謝します。また、多くのポイントを明確に助けたフィードバックのためのスティーブ・ケントに感謝。 PMTUのセクションはDCCP仕様[DCCP]からcribbedました。パシEronenは、本明細書の詳細なレビューを提供します。ピーターサンアンドレは、文書8.参考意見もマーク・オールマン、ヤリArkko、モハメドBadra、マイケルD'エリコ、エイドリアン・ファレル、ジョエル・ハルパーン、テッドハーディー、Charliaカウフマン、ペッカSavolaから受信したセクションでの変更のリストを提供しました、アリソンマンキン、ニコスMavrogiannopoulos、アレクセイ・メルニコフ、ロビンSeggelmann、マイケルTuexen、たJuho Vaha-Herttua、フロリアンWeimerさん。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document uses the same identifier space as TLS [TLS12], so no new IANA registries are required. When new identifiers are assigned for TLS, authors MUST specify whether they are suitable for DTLS. IANA has modified all TLS parameter registries to add a DTLS-OK flag, indicating whether the specification may be used with DTLS. At the time of publication, all of the [TLS12] registrations except the following are suitable for DTLS. The full table of registrations is available at [IANA].",
      "ja": "この文書では、TLS [TLS12]と同じ識別子空間を使用するため、新たなIANAレジストリは必要ありません。新しい識別子がTLS用に割り当てられている場合は、著者は、彼らがDTLSに適しているかどうかを指定しなければなりません。 IANAは、仕様がDTLSと共に使用することができるか否かを示す、DTLS-OKフラグを追加するために、すべてのTLSパラメータレジストリを変更しました。出版時に、以下を除いて[TLS12]登録の全てはDTLSに適しています。登録の完全なテーブルは、[IANA]でご利用いただけます。"
    },
    {
      "indent": 3,
      "text": "From the TLS Cipher Suite Registry:",
      "ja": "TLS暗号スイートレジストリから："
    },
    {
      "indent": 6,
      "text": "0x00,0x03 TLS_RSA_EXPORT_WITH_RC4_40_MD5 [RFC4346] 0x00,0x04 TLS_RSA_WITH_RC4_128_MD5 [RFC5246] 0x00,0x05 TLS_RSA_WITH_RC4_128_SHA [RFC5246] 0x00,0x17 TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 [RFC4346]",
      "ja": "0x00,0x03 TLS_RSA_EXPORT_WITH_RC4_40_MD5 [RFC4346] 0x00,0x04 TLS_RSA_WITH_RC4_128_MD5 [RFC5246] 0x00,0x05 TLS_RSA_WITH_RC4_128_SHA [RFC5246] 0x00,0x17 TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 [RFC4346]"
    },
    {
      "indent": 6,
      "text": "0x00,0x18 TLS_DH_anon_WITH_RC4_128_MD5 [RFC5246] 0x00,0x20 TLS_KRB5_WITH_RC4_128_SHA [RFC2712] 0x00,0x24 TLS_KRB5_WITH_RC4_128_MD5 [RFC2712] 0x00,0x28 TLS_KRB5_EXPORT_WITH_RC4_40_SHA [RFC2712] 0x00,0x2B TLS_KRB5_EXPORT_WITH_RC4_40_MD5 [RFC2712] 0x00,0x8A TLS_PSK_WITH_RC4_128_SHA [RFC4279] 0x00,0x8E TLS_DHE_PSK_WITH_RC4_128_SHA [RFC4279] 0x00,0x92 TLS_RSA_PSK_WITH_RC4_128_SHA [RFC4279] 0xC0,0x02 TLS_ECDH_ECDSA_WITH_RC4_128_SHA [RFC4492] 0xC0,0x07 TLS_ECDHE_ECDSA_WITH_RC4_128_SHA [RFC4492] 0xC0,0x0C TLS_ECDH_RSA_WITH_RC4_128_SHA [RFC4492] 0xC0,0x11 TLS_ECDHE_RSA_WITH_RC4_128_SHA [RFC4492] 0xC0,0x16 TLS_ECDH_anon_WITH_RC4_128_SHA [RFC4492] 0xC0,0x33 TLS_ECDHE_PSK_WITH_RC4_128_SHA [RFC5489]",
      "ja": "0x00,0x18 TLS_DH_anon_WITH_RC4_128_MD5 [RFC5246] 0x00,0x20 TLS_KRB5_WITH_RC4_128_SHA [RFC2712] 0x00,0x24 TLS_KRB5_WITH_RC4_128_MD5 [RFC2712] 0x00,0x28 TLS_KRB5_EXPORT_WITH_RC4_40_SHA [RFC2712] 0x00,0x2B TLS_KRB5_EXPORT_WITH_RC4_40_MD5 [RFC2712] 0x00,0x8A TLS_PSK_WITH_RC4_128_SHA [RFC4279] 0x00,0x8E TLS_DHE_PSK_WITH_RC4_128_SHA [RFC4279]は0x00 、0x92 TLS_RSA_PSK_WITH_RC4_128_SHA [RFC4279] 0xC0,0x02 TLS_ECDH_ECDSA_WITH_RC4_128_SHA [RFC4492] 0xC0,0x07 TLS_ECDHE_ECDSA_WITH_RC4_128_SHA [RFC4492] 0xC0,0x0C TLS_ECDH_RSA_WITH_RC4_128_SHA [RFC4492] 0xC0,0x11 TLS_ECDHE_RSA_WITH_RC4_128_SHA [RFC4492] 0xC0,0x16 TLS_ECDH_anon_WITH_RC4_128_SHA [RFC4492] 0xC0,0x33 TLS_ECDHE_PSK_WITH_RC4_128_SHA [RFC5489]"
    },
    {
      "indent": 3,
      "text": "From the TLS Exporter Label Registry:",
      "ja": "TLS輸出ラベルレジストリから："
    },
    {
      "indent": 6,
      "text": "client EAP encryption [RFC5216] ttls keying material [RFC5281] ttls challenge [RFC5281]",
      "ja": "クライアントEAP暗号化鍵材料を、[RFC5216] TTLS [RFC5281] TTLS挑戦[RFC5281]"
    },
    {
      "indent": 3,
      "text": "This document defines a new handshake message, hello_verify_request, whose value has been allocated from the TLS HandshakeType registry defined in [TLS12]. The value \"3\" has been assigned by the IANA.",
      "ja": "この文書では、その値は[TLS12]で定義されたTLS HandshakeTypeレジストリから割り当てられた新しいハンドシェイクメッセージ、hello_verify_requestを、定義します。値「3」は、IANAによって割り当てられています。"
    },
    {
      "indent": 0,
      "text": "8. Changes since DTLS 1.0",
      "section_title": true,
      "ja": "8.変更DTLS 1.0以降"
    },
    {
      "indent": 3,
      "text": "This document reflects the following changes since DTLS 1.0 [DTLS1].",
      "ja": "この文書では、DTLS 1.0 [DTLS1]から以下の変更が反映されます。"
    },
    {
      "indent": 3,
      "text": "- Updated to match TLS 1.2 [TLS12].",
      "ja": " -  TLS 1.2 [TLS12]に一致するように更新しました。"
    },
    {
      "indent": 3,
      "text": "- Addition of AEAD Ciphers in Section 4.1.2.3 (tracking changes in TLS 1.2.",
      "ja": " - セクション4.1.2.3でAEAD暗号の追加（TLS 1.2での変更を追跡します。"
    },
    {
      "indent": 3,
      "text": "- Clarifications regarding sequence numbers and epochs in Section 4.1 and a clear procedure for dealing with state loss in Section 4.2.8.",
      "ja": " - セクション4.1と4.2.8の状態損失に対処するための明確な手順のシーケンス番号とエポックに関する明確化。"
    },
    {
      "indent": 3,
      "text": "- Clarifications and more detailed rules regarding Path MTU issues in Section 4.1.1.1. Clarification of the fragmentation text throughout.",
      "ja": " - セクション4.1.1.1でのパスMTUの問題について明確化し、より詳細なルール。全体で断片化テキストの明確化。"
    },
    {
      "indent": 3,
      "text": "- Clarifications regarding handling of invalid records in Section 4.1.2.7.",
      "ja": " - セクション4.1.2.7で無効なレコードの取り扱いについて明確化。"
    },
    {
      "indent": 3,
      "text": "- A new paragraph describing handling of invalid cookies at the end of Section 4.2.1.",
      "ja": " -  4.2.1節の最後に無効なクッキーの取り扱いを記述する新しい段落。"
    },
    {
      "indent": 3,
      "text": "- Some new text describing how to avoid handshake deadlock conditions at the end of Section 4.2.4.",
      "ja": " -  4.2.4項の最後に握手デッドロック状態を回避する方法を説明するいくつかの新しいテキスト。"
    },
    {
      "indent": 3,
      "text": "- Some new text about CertificateVerify messages in Section 4.2.6.",
      "ja": " - セクション4.2.6でCertificateVerifyメッセージについてのいくつかの新しいテキスト。"
    },
    {
      "indent": 3,
      "text": "- A prohibition on epoch wrapping in Section 4.1.",
      "ja": " - セクション4.1におけるエポックの折り返しの禁止。"
    },
    {
      "indent": 3,
      "text": "- Clarification of the IANA requirements and the explicit requirement for a new IANA registration flag for each parameter.",
      "ja": " -  IANAの要件の明確化と、各パラメータのための新しいIANA登録フラグの明示的な要件。"
    },
    {
      "indent": 3,
      "text": "- Added a record sequence number mirroring technique for handling repeated ClientHello messages.",
      "ja": " - 繰り返したClientHelloメッセージを処理するための技術をミラーリングレコードのシーケンス番号を追加しました。"
    },
    {
      "indent": 3,
      "text": "- Recommend a fixed version number for HelloVerifyRequest.",
      "ja": " -  HelloVerifyRequestのための固定のバージョン番号をオススメ。"
    },
    {
      "indent": 3,
      "text": "- Numerous editorial changes.",
      "ja": " - 多くの編集上の変更。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[REQ] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[REQ]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, November 1990.",
      "ja": "[RFC1191]ムガール人、J.とS.デアリング、 \"パスMTUディスカバリ\"、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[RFC4301]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4443] Conta, A., Deering, S., and M. Gupta, Ed., \"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification\", RFC 4443, March 2006.",
      "ja": "[RFC4443]コンタ、A.、デアリング、S.、およびM.グプタ、エド。、 \"インターネット制御メッセージプロトコル（ICMPv6の）インターネットプロトコルバージョン6（IPv6）の仕様について\"、RFC 4443、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, March 2007.",
      "ja": "[RFC4821]マシス、M.とJ. Heffner、 \"パケット化レイヤのパスMTUディスカバリ\"、RFC 4821、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, June 2011.",
      "ja": "[RFC6298]パクソン、V.、オールマン、M.、チュー、J.、およびM.サージェント、 \"コンピューティングTCPの再送信タイマー\"、RFC 6298、2011年6月。"
    },
    {
      "indent": 3,
      "text": "[RSAGCM] Salowey, J., Choudhury, A., and D. McGrew, \"AES Galois Counter Mode (GCM) Cipher Suites for TLS\", RFC 5288, August 2008.",
      "ja": "【RSAGCM] Salowey、J.、チョードリー、A.、およびD.マグリュー、 \"TLSのためのAESガロア・カウンタ・モード（GCM）暗号スイート\"、RFC 5288、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[TCP] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[TCP]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[TLS12] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[TLS12]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[DCCP] Kohler, E., Handley, M., and S. Floyd, \"Datagram Congestion Control Protocol (DCCP)\", RFC 4340, March 2006.",
      "ja": "[DCCP]コーラー、E.、ハンドリー、M.、およびS.フロイド、 \"データグラム輻輳制御プロトコル（DCCP）\"、RFC 4340、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[DCCPDTLS] Phelan, T., \"Datagram Transport Layer Security (DTLS) over the Datagram Congestion Control Protocol (DCCP)\", RFC 5238, May 2008.",
      "ja": "[DCCPDTLS]フェラン、T.、RFC 5238、2008年5月、 \"データグラム輻輳制御プロトコル（DCCP）を超えるデータグラムトランスポート層セキュリティ（DTLS）\"。"
    },
    {
      "indent": 3,
      "text": "[DTLS] Modadugu, N. and E. Rescorla, \"The Design and Implementation of Datagram TLS\", Proceedings of ISOC NDSS 2004, February 2004.",
      "ja": "[DTLS] Modadugu、N.とE.レスコラ、 \"データグラムTLSの設計と実装\"、ISOC NDSS 2004、2004年2月の議事。"
    },
    {
      "indent": 3,
      "text": "[DTLS1] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security\", RFC 4347, April 2006.",
      "ja": "[DTLS1]レスコラ、E.およびN. Modadugu、 \"データグラムトランスポート層セキュリティ\"、RFC 4347、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[ECCGCM] Rescorla, E., \"TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)\", RFC 5289, August 2008.",
      "ja": "【ECCGCM]レスコラ、E.、 \"SHA-384分の256とTLS楕円曲線暗号スイートとAESガロア・カウンタ・モード（GCM）\"、RFC 5289、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[ESP] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "ja": "[ESP]ケント、S.、 \"IPカプセル化セキュリティペイロード（ESP）\"、RFC 4303、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[IANA] IANA, \"Transport Layer Security (TLS) Parameters\", http://www.iana.org/assignments/tls-parameters.",
      "ja": "[IANA] IANA、 \"トランスポート層セキュリティ（TLS）パラメータ\"、http://www.iana.org/assignments/tls-parameters。"
    },
    {
      "indent": 3,
      "text": "[IKEv2] Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", RFC 5996, September 2010.",
      "ja": "[IKEv2の]カウフマン、C.、ホフマン、P.、ニール、Y.、およびP. Eronen、 \"インターネット鍵交換プロトコルバージョン2（IKEv2の）\"、RFC 5996、2010年9月。"
    },
    {
      "indent": 3,
      "text": "[IMAP] Crispin, M., \"INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1\", RFC 3501, March 2003.",
      "ja": "[IMAP]クリスピン、M.、 \"インターネットメッセージアクセスプロトコル - バージョン4rev1\"、RFC 3501、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[PHOTURIS] Karn, P. and W. Simpson, \"Photuris: Session-Key Management Protocol\", RFC 2522, March 1999.",
      "ja": "[PHOTURIS]カーン、P.とW.シンプソン、 \"Photuris：セッション鍵管理プロトコル\"、RFC 2522、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[POP] Myers, J. and M. Rose, \"Post Office Protocol - Version 3\", STD 53, RFC 1939, May 1996.",
      "ja": "[POP]マイヤーズ、J.とM.ローズ、 \"ポストオフィスプロトコル - バージョン3\"、STD 53、RFC 1939、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[SIP] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[SIP]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 \"SIP：セッション開始プロトコル\" 、RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[TLS] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[TLS]ダークス、T.とC.アレン、 \"TLSプロトコルバージョン1.0\"、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[TLS11] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.1\", RFC 4346, April 2006.",
      "ja": "[TLS11]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.1\"、RFC 4346、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[WHYIPSEC] Bellovin, S., \"Guidelines for Specifying the Use of IPsec Version 2\", BCP 146, RFC 5406, February 2009.",
      "ja": "[WHYIPSEC] Bellovin氏、S.、 \"IPsecのバージョン2の使用を指定するためのガイドライン\"、BCP 146、RFC 5406、2009年2月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Eric Rescorla RTFM, Inc. 2064 Edgewood Drive Palo Alto, CA 94303",
      "ja": "エリックレスコラRTFM、Inc.の2064エッジウッドドライブパロアルト、CA 94303"
    },
    {
      "indent": 3,
      "text": "EMail: ekr@rtfm.com",
      "ja": "メールアドレス：ekr@rtfm.com"
    },
    {
      "indent": 3,
      "text": "Nagendra Modadugu Google, Inc.",
      "ja": "Nagendra Modaduguグーグル株式会社"
    },
    {
      "indent": 3,
      "text": "EMail: nagendra@cs.stanford.edu",
      "ja": "メールアドレス：nagendra@cs.stanford.edu"
    }
  ]
}