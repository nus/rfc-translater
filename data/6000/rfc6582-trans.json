{
  "title": {
    "text": "RFC 6582 - The NewReno Modification to TCP's Fast Recovery Algorithm",
    "ja": "RFC 6582 - TCPの高速回復アルゴリズムへのNewRenoの変更"
  },
  "number": 6582,
  "created_at": "2019-10-28 01:27:16.175862+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                      T. Henderson\nRequest for Comments: 6582                                        Boeing\nObsoletes: 3782                                                 S. Floyd\nCategory: Standards Track                                           ICSI\nISSN: 2070-1721                                                A. Gurtov\n                                                      University of Oulu\n                                                              Y. Nishida\n                                                            WIDE Project\n                                                              April 2012",
      "raw": true
    },
    {
      "indent": 7,
      "text": "The NewReno Modification to TCP's Fast Recovery Algorithm",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery. RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to \"partial acknowledgments\" (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK. This document describes a specific algorithm for responding to partial acknowledgments, referred to as \"NewReno\". This response to partial acknowledgments was first proposed by Janey Hoe. This document obsoletes RFC 3782.",
      "ja": "スロースタート、輻輳回避、高速再送、高速回復：RFC 5681は、次の4つの絡み合ったTCPの輻輳制御アルゴリズムを説明します。 RFC 5681には、明示的にTCP選択確認応答（SACK）オプション（RFC 2883）を使用して修正を含むこれらのアルゴリズムの特定の改変を可能にし、「部分的確認応答」（新データをカバーするのACKはなく、優れたすべてのデータへの対応の変更損失は​​、SACKの非存在下で）検出されました。この文書では、部分的確認応答に対応するための特定のアルゴリズムを説明し、「NewRenoの」と呼ばれます。部分的確認応答にこの応答は、最初Janey鍬によって提案されました。この文書はRFC 3782を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6582.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6582で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2012 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2012 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "For the typical implementation of the TCP fast recovery algorithm described in [RFC5681] (first implemented in the 1990 BSD Reno release, and referred to as the \"Reno algorithm\" in [FF96]), the TCP data sender only retransmits a packet after a retransmit timeout has occurred, or after three duplicate acknowledgments have arrived triggering the fast retransmit algorithm. A single retransmit timeout might result in the retransmission of several data packets, but each invocation of the fast retransmit algorithm in RFC 5681 leads to the retransmission of only a single data packet.",
      "ja": "[RFC5681]で説明TCP高速回復アルゴリズム（第1990 BSDリノリリースで実装され、[FF96]における「リノアルゴリズム」と呼ぶ）の代表的な実施のため、TCPデータ送信側は後にのみパケットを再送します再送タイムアウトが発生している、または3の後の重複確認応答が高速再送アルゴリズムをトリガ到着しました。単一再送タイムアウトは、いくつかのデータパケットの再送信につながるかもしれないが、RFC 5681での高速再送アルゴリズムの各呼び出しは、単一のデータ・パケットの再送信につながります。"
    },
    {
      "indent": 3,
      "text": "Two problems arise with Reno TCP when multiple packet losses occur in a single window. First, Reno will often take a timeout, as has been documented in [Hoe95]. Second, even if a retransmission timeout is avoided, multiple fast retransmits and window reductions can occur, as documented in [F94]. When multiple packet losses occur, if the SACK option [RFC2883] is available, the TCP sender has the information to make intelligent decisions about which packets to retransmit and which packets not to retransmit during fast recovery.",
      "ja": "複数のパケット損失が1つのウィンドウに発生したときに二つの問題がリノTCPで発生します。 [Hoe95]に記載されているように、まず、リノは、多くの場合、タイムアウトを取ります。第二に、再送タイムアウトが回避された場合でも、複数の高速再送信し、ウィンドウの削減は、[F94]に記載されているように、発生する可能性があります。複数のパケットロスが発生した場合、SACKオプション[RFC2883]が使用可能な場合、TCPの送信者は、パケットを再送するかについて知的な意思決定を行うための情報を持っており、高速復旧中に再送信しないようにどのパケット。"
    },
    {
      "indent": 3,
      "text": "This document applies to TCP connections that are unable to use the TCP Selective Acknowledgment (SACK) option, either because the option is not locally supported or because the TCP peer did not indicate a willingness to use SACK.",
      "ja": "このドキュメントでは、TCP選択確認応答（SACK）オプションを使用することができないTCP接続に適用され、いずれかのTCPピアはSACKを使用する意欲を示すものではありませんでしたので、オプションは、ローカルサポートやされていないため。"
    },
    {
      "indent": 3,
      "text": "In the absence of SACK, there is little information available to the TCP sender in making retransmission decisions during fast recovery. From the three duplicate acknowledgments, the sender infers a packet loss, and retransmits the indicated packet. After this, the data sender could receive additional duplicate acknowledgments, as the data receiver acknowledges additional data packets that were already in flight when the sender entered fast retransmit.",
      "ja": "SACKがない場合には、高速回復中に再送意思決定におけるTCPの送信者が利用可能な情報はほとんどありません。 3つの重複確認応答からは、送信側はパケットロスを推測し、指示されたパケットを再送します。データ受信機は、送信者が高速再送に入ったとき、飛行中に存在していた追加のデータパケットを認識し、この後、データ送信者は、追加の重複確認応答を受け取ることができます。"
    },
    {
      "indent": 3,
      "text": "In the case of multiple packets dropped from a single window of data, the first new information available to the sender comes when the sender receives an acknowledgment for the retransmitted packet (that is, the packet retransmitted when fast retransmit was first entered). If there is a single packet drop and no reordering, then the acknowledgment for this packet will acknowledge all of the packets transmitted before fast retransmit was entered. However, if there are multiple packet drops, then the acknowledgment for the retransmitted packet will acknowledge some but not all of the packets transmitted before the fast retransmit. We call this acknowledgment a partial acknowledgment.",
      "ja": "複数のパケットの場合、データの単一の窓から落とさ送信者は（つまり、高速再送が最初に入力されたとき、再送パケットである）再送パケットに対する確認応答を受信すると、送信者が利用可能な最初の新しい情報が来ます。単一パケットドロップなし並べ替えがある場合は高速再送が入力された前に、このパケットの確認応答が送信されたパケットの全てを承認します。複数のパケットドロップがある場合は、その後、再送パケットに対する肯定応答は、いくつかのではなく、高速再送する前に送信したパケットの全てを確認します。我々は、部分的な承認この承認を呼び出します。"
    },
    {
      "indent": 3,
      "text": "Along with several other suggestions, [Hoe95] suggested that during fast recovery the TCP data sender respond to a partial acknowledgment by inferring that the next in-sequence packet has been lost and retransmitting that packet. This document describes a modification to the fast recovery algorithm in RFC 5681 that incorporates a response to partial acknowledgments received during fast recovery. We call this modified fast recovery algorithm NewReno, because it is a slight but significant variation of the behavior that has been historically referred to as Reno. This document does not discuss the other suggestions in [Hoe95] and [Hoe96], such as a change to the ssthresh parameter during slow start, or the proposal to send a new packet for every two duplicate acknowledgments during fast recovery. The version of NewReno in this document also draws on other discussions of NewReno in the literature [LM97] [Hen98].",
      "ja": "他のいくつかの提案に加えて、[Hoe95]高速回復中にTCPデータの送信者は、次のインシーケンスパケットが失われたことを推測し、そのパケットを再送することにより、部分的確認応答に応じることが示唆されました。この文書では、高速復旧中に受信した部分の確認応答に対する応答を組み込んだRFC 5681での高速回復アルゴリズムへの変更について説明します。それは歴史的にリノと呼ばれている行動のわずかではあるが有意な変動であるので、私たちは、この修正された高速回復アルゴリズムNewRenoのを呼び出します。この文書では、このようなスロースタート時のSSTHRESHパラメータの変更、または高速リカバリ中に2つのずつの重複確認応答のための新しいパケットを送信するための提案として、[Hoe96] [Hoe95]で他の提案を議論していません。この文書に記載されているNewRenoのバージョンも文献[LM97] [Hen98]でNewRenoの他の議論を描画します。"
    },
    {
      "indent": 3,
      "text": "We do not claim that the NewReno version of fast recovery described here is an optimal modification of fast recovery for responding to partial acknowledgments, for TCP connections that are unable to use SACK. Based on our experiences with the NewReno modification in the network simulator known as ns-2 [NS] and with numerous implementations of NewReno, we believe that this modification improves the performance of the fast retransmit and fast recovery algorithms in a wide variety of scenarios. Previous versions of this RFC [RFC2582] [RFC3782] provide simulation-based evidence of the possible performance gains.",
      "ja": "私たちは、ここで説明する高速回復のNewRenoのバージョンはSACKを使用することができないのTCP接続のために、部分的確認応答に対応するための高速リカバリの最適な修正であることを主張しません。 NS-2として知られているネットワークシミュレータにおけるNewRenoの変更[NS]とし、NewRenoの多数の実装と私たちの経験に基づいて、我々はこの変更は、さまざまなシナリオでの高速再送と高速回復アルゴリズムの性能を向上させると信じています。このRFCの以前のバージョン[RFC2582] [RFC3782]は可能な性能向上のシミュレーションベースの証拠を提供します。"
    },
    {
      "indent": 0,
      "text": "2. Terminology and Definitions",
      "section_title": true,
      "ja": "2.用語と定義"
    },
    {
      "indent": 3,
      "text": "This document assumes that the reader is familiar with the terms SENDER MAXIMUM SEGMENT SIZE (SMSS), CONGESTION WINDOW (cwnd), and FLIGHT SIZE (FlightSize) defined in [RFC5681].",
      "ja": "この文書は、読者が[RFC5681]で定義された用語SENDER最大セグメントサイズ（SMSS）、輻輳ウィンドウ（CWND）、飛行SIZE（FlightSize）に精通していることを前提としています。"
    },
    {
      "indent": 3,
      "text": "This document defines an additional sender-side state variable called \"recover\":",
      "ja": "この文書は、「回復」と呼ばれる追加の送信側の状態変数を定義しています。"
    },
    {
      "indent": 6,
      "text": "recover: When in fast recovery, this variable records the send sequence number that must be acknowledged before the fast recovery procedure is declared to be over.",
      "ja": "回復：高速リカバリでは、この変数は、高速回復手順は以上であると宣言される前に確認する必要があります送信シーケンス番号を記録する場合。"
    },
    {
      "indent": 0,
      "text": "3. The Fast Retransmit and Fast Recovery Algorithms in NewReno",
      "section_title": true,
      "ja": "NewRenoの中3.高速再送と高速リカバリアルゴリズム"
    },
    {
      "indent": 0,
      "text": "3.1. Protocol Overview",
      "section_title": true,
      "ja": "3.1. プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The basic idea of these extensions to the fast retransmit and fast recovery algorithms described in Section 3.2 of [RFC5681] is as follows. The TCP sender can infer, from the arrival of duplicate acknowledgments, whether multiple losses in the same window of data have most likely occurred, and avoid taking a retransmit timeout or making multiple congestion window reductions due to such an event.",
      "ja": "次のように高速再送と[RFC5681]の3.2節で説明した高速回復アルゴリズムへのこれらの拡張機能の基本的な考え方です。 TCPの送信者は、データの同じウィンドウ内に複数の損失が最も可能性の高い発生したかどうか、重複確認応答の到着から、推測、および再送タイムアウトを取るか、このようなイベントのために、複数の輻輳ウィンドウの減少を避けることができます。"
    },
    {
      "indent": 3,
      "text": "The NewReno modification applies to the fast recovery procedure that begins when three duplicate ACKs are received and ends when either a retransmission timeout occurs or an ACK arrives that acknowledges all of the data up to and including the data that was outstanding when the fast recovery procedure began.",
      "ja": "NewRenoの変更は3つの重複ACKを受信したときに始まる高速リカバリ手順に適用され、再送タイムアウトのいずれかが発生したときに終了するかACKはそれが最大と高速回復手順が始まったときに優れたデータを含むデータのすべてを認めて到着します。"
    },
    {
      "indent": 0,
      "text": "3.2. Specification",
      "section_title": true,
      "ja": "3.2. 仕様"
    },
    {
      "indent": 3,
      "text": "The procedures specified in Section 3.2 of [RFC5681] are followed, with the modifications listed below. Note that this specification avoids the use of the key words defined in RFC 2119 [RFC2119], since it mainly provides sender-side implementation guidance for performance improvement, and does not affect interoperability.",
      "ja": "[RFC5681]のセクション3.2で指定された手順は下記の変更を加えて、続いています。この仕様が、それは主にパフォーマンス向上のために、送信者側の実装のガイダンスを提供するので、RFC 2119 [RFC2119]で定義されたキーの単語の使用を避け、および相互運用性に影響しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "1) Initialization of TCP protocol control block: When the TCP protocol control block is initialized, recover is set to the initial send sequence number.",
      "ja": "TCPプロトコル制御ブロックの1）初期化：TCPプロトコル制御ブロックが初期化されると、回復は、初期送信シーケンス番号に設定されています。"
    },
    {
      "indent": 3,
      "text": "2) Three duplicate ACKs: When the third duplicate ACK is received, the TCP sender first checks the value of recover to see if the Cumulative Acknowledgment field covers more than recover. If so, the value of recover is incremented to the value of the highest sequence number transmitted by the TCP so far. The TCP then enters fast retransmit (step 2 of Section 3.2 of [RFC5681]). If not, the TCP does not enter fast retransmit and does not reset ssthresh.",
      "ja": "2）三個の重複ACK：第三の重複ACKが受信されると、TCP送信者は、第一累積確認応答フィールドが回復以上を覆っているかどうかを確認するために回復の値をチェックします。その場合は、回復の値は、これまでにTCPが送信したシーケンス番号が最大の値に増加されます。 TCPは、次に、高速再送信（[RFC5681]のセクション3.2のステップ2）に入ります。ない場合は、TCPは、高速再送を入力しないとSSTHRESHリセットされません。"
    },
    {
      "indent": 3,
      "text": "3) Response to newly acknowledged data: Step 6 of [RFC5681] specifies the response to the next ACK that acknowledges previously unacknowledged data. When an ACK arrives that acknowledges new data, this ACK could be the acknowledgment elicited by the initial retransmission from fast retransmit, or elicited by a later retransmission. There are two cases:",
      "ja": "3）新たに受け付けたデータに応答：[RFC5681]のステップ6は、以前に不承認のデータを承認次ACKに対する応答を指定します。 ACKは、それが新しいデータを認める到着すると、このACKは確認応答が高速再送からの最初の再送により誘発される、以降の再送信によって誘発することができます。 2つのケースがあります。"
    },
    {
      "indent": 7,
      "text": "Full acknowledgments:\nIf this ACK acknowledges all of the data up to and including\nrecover, then the ACK acknowledges all the intermediate segments\nsent between the original transmission of the lost segment and\nthe receipt of the third duplicate ACK.  Set cwnd to either (1)\nmin (ssthresh, max(FlightSize, SMSS) + SMSS) or (2) ssthresh,\nwhere ssthresh is the value set when fast retransmit was entered,\nand where FlightSize in (1) is the amount of data presently\noutstanding.  This is termed \"deflating\" the window.  If the\nsecond option is selected, the implementation is encouraged to\ntake measures to avoid a possible burst of data, in case the\namount of data outstanding in the network is much less than the\nnew congestion window allows.  A simple mechanism is to limit the\nnumber of data packets that can be sent in response to a single\nacknowledgment.  Exit the fast recovery procedure.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Partial acknowledgments: If this ACK does *not* acknowledge all of the data up to and including recover, then this is a partial ACK. In this case, retransmit the first unacknowledged segment. Deflate the congestion window by the amount of new data acknowledged by the Cumulative Acknowledgment field. If the partial ACK acknowledges at least one SMSS of new data, then add back SMSS bytes to the congestion window. This artificially inflates the congestion window in order to reflect the additional segment that has left the network. Send a new segment if permitted by the new value of cwnd. This \"partial window deflation\" attempts to ensure that, when fast recovery eventually ends, approximately ssthresh amount of data will be outstanding in the network. Do not exit the fast recovery procedure (i.e., if any duplicate ACKs subsequently arrive, execute step 4 of Section 3.2 of [RFC5681]).",
      "ja": "部分的な謝辞：このACKは* *までのすべてのデータを確認し、回復を含めていない場合、これは部分的ACKです。この場合、最初の不承認のセグメントを再送します。累積確認応答フィールドによって認め、新たなデータの量によって輻輳ウィンドウを収縮。パーシャルACKが新しいデータの少なくとも1 SMSSを認める場合には、輻輳ウィンドウにSMSSバイトを再度追加。これは人為的にネットワークから離脱した追加のセグメントを反映するために、輻輳ウィンドウを膨張させます。 cwndの新しい値によって許可されている場合、新しいセグメントを送信します。この「部分ウィンドウデフレは、」高速回復は、最終的にデータの約SSTHRESH量は、ネットワークに優れなり、終了したときに、それを確保しようとします。 （重複ACKが続いて到着した場合、すなわち、[RFC5681]のセクション3.2のステップ4を実行する）高速回復手順を終了していません。"
    },
    {
      "indent": 7,
      "text": "For the first partial ACK that arrives during fast recovery, also reset the retransmit timer. Timer management is discussed in more detail in Section 4.",
      "ja": "高速回復中に到着した最初の部分ACKのために、また、再送信タイマーをリセットします。タイマ管理は、第4章で詳しく説明されています。"
    },
    {
      "indent": 3,
      "text": "4) Retransmit timeouts: After a retransmit timeout, record the highest sequence number transmitted in the variable recover, and exit the fast recovery procedure if applicable.",
      "ja": "4）再送信のタイムアウト：再送タイムアウトの後、変数に送信され、最も高いシーケンス番号が回復し、該当する場合は高速回復手順を終了し、記録します。"
    },
    {
      "indent": 3,
      "text": "Step 2 above specifies a check that the Cumulative Acknowledgment field covers more than recover. Because the acknowledgment field contains the sequence number that the sender next expects to receive, the acknowledgment \"ack_number\" covers more than recover when",
      "ja": "ステップ2は、上記の累積確認応答フィールドが回復する以上のものをカバーするチェックを指定します。確認応答フィールドは、送信者が次の、承認を受ける「ack_number」ことを期待シーケンス番号が含まれているためときに回復よりも多くをカバー"
    },
    {
      "indent": 6,
      "text": "ack_number - 1 > recover;",
      "ja": "ack_number  -  1>回復。"
    },
    {
      "indent": 3,
      "text": "i.e., at least one byte more of data is acknowledged beyond the highest byte that was outstanding when fast retransmit was last entered.",
      "ja": "すなわち、データのより少なくとも1バイトは高速再送が最後に入力されたときに優れた最上位バイトを超えて認められています。"
    },
    {
      "indent": 3,
      "text": "Note that in step 3 above, the congestion window is deflated after a partial acknowledgment is received. The congestion window was likely to have been inflated considerably when the partial acknowledgment was received. In addition, depending on the original pattern of packet losses, the partial acknowledgment might acknowledge nearly a window of data. In this case, if the congestion window was not deflated, the data sender might be able to send nearly a window of data back-to-back.",
      "ja": "部分的確認応答が受信された後に上記ステップ3において、輻輳ウィンドウが収縮されることに注意してください。輻輳ウィンドウは、部分的な承認を受けたときはかなり膨張されている可能性が高いでした。また、パケットロスの元のパターンに応じて、部分的な承認は、データのほとんど窓を認める場合があります。輻輳ウィンドウが収縮されなかった場合は、この場合には、データの送信者は、バックツーバック近いデータのウィンドウを送信することができるかもしれません。"
    },
    {
      "indent": 3,
      "text": "This document does not specify the sender's response to duplicate ACKs when the fast retransmit/fast recovery algorithm is not invoked. This is addressed in other documents, such as those describing the Limited Transmit procedure [RFC3042]. This document also does not address issues of adjusting the duplicate acknowledgment threshold, but assumes the threshold specified in the IETF standards; the current standard is [RFC5681], which specifies a threshold of three duplicate acknowledgments.",
      "ja": "この文書では、高速再送/高速回復アルゴリズムが呼び出されていない場合のACKを複製するために、送信者の応答を指定しません。これは、限定の送信手順を説明するものなどの他のドキュメント、[RFC3042]でアドレス指定されます。この文書はまた、重複確認応答のしきい値を調整する問題に対処するが、IETF標準で指定されたしきい値を負いません。現在の標準は、三の重複確認応答のしきい値を指定し、[RFC5681]です。"
    },
    {
      "indent": 3,
      "text": "As a final note, we would observe that in the absence of the SACK option, the data sender is working from limited information. When the issue of recovery from multiple dropped packets from a single window of data is of particular importance, the best alternative would be to use the SACK option.",
      "ja": "最後の注意として、私たちはSACKオプションが存在しない場合に、データの送信者が限られた情報から作業されていることを確認します。複数からの回復の問題は特に重要であるデータの単一のウィンドウからのパケットをドロップすると、最善の選択肢は、SACKオプションを使用することです。"
    },
    {
      "indent": 0,
      "text": "4. Handling Duplicate Acknowledgments after a Timeout",
      "section_title": true,
      "ja": "4.タイムアウト後に重複謝辞の取り扱い"
    },
    {
      "indent": 3,
      "text": "After each retransmit timeout, the highest sequence number transmitted so far is recorded in the variable recover. If, after a retransmit timeout, the TCP data sender retransmits three consecutive packets that have already been received by the data receiver, then the TCP data sender will receive three duplicate acknowledgments that do not cover more than recover. In this case, the duplicate acknowledgments are not an indication of a new instance of congestion. They are simply an indication that the sender has unnecessarily retransmitted at least three packets.",
      "ja": "各再送タイムアウトの後、これまでに送信され、最高のシーケンス番号を変数に回復記録されています。 、再送タイムアウトの後、TCPデータ送信側は、既にデータ受信機によって受信された三つの連続するパケットを再送する場合は、TCPデータの送信者が回復する以上のものをカバーしていない3つの重複確認応答を受信します。この場合には、重複確認応答は、輻輳の新しいインスタンスの指標ではありません。彼らは、単に送信者が不必要に少なくとも3つのパケットを再送信していることを示しています。"
    },
    {
      "indent": 3,
      "text": "However, when a retransmitted packet is itself dropped, the sender can also receive three duplicate acknowledgments that do not cover more than recover. In this case, the sender would have been better off if it had initiated fast retransmit. For a TCP sender that implements the algorithm specified in Section 3.2 of this document, the sender does not infer a packet drop from duplicate acknowledgments in this scenario. As always, the retransmit timer is the backup mechanism for inferring packet loss in this case.",
      "ja": "再送パケット自体が低下したときただし、送信者はまた、回復よりも多くをカバーしていない3つの重複確認応答を受け取ることができます。それは、高速再送信を開始した場合この場合、送信者は裕福だったでしょう。このドキュメントのセクション3.2で指定したアルゴリズムを実装するTCP送信側では、送信者は、このシナリオでは、重複確認応答のパケットドロップを推測することはありません。いつものように、再送信タイマは、この場合には、パケットロスを推測するためのバックアップメカニズムです。"
    },
    {
      "indent": 3,
      "text": "There are several heuristics, based on timestamps or on the amount of advancement of the Cumulative Acknowledgment field, that allow the sender to distinguish, in some cases, between three duplicate acknowledgments following a retransmitted packet that was dropped, and three duplicate acknowledgments from the unnecessary retransmission of three packets [Gur03] [GF04]. The TCP sender may use such a heuristic to decide to invoke a fast retransmit in some cases, even when the three duplicate acknowledgments do not cover more than recover.",
      "ja": "送信者が区別できるようにするタイムスタンプにまたは累積謝辞分野の進歩の量に基づいていくつかの経験則では、ドロップされた再送パケットを次の三つの重複確認応答、および不要の3つの重複確認応答の間、いくつかのケースではありますが、 3個のパケット[Gur03] [GF04]の再送信。 TCPの送信者は3つの重複確認応答が回復する以上のものをカバーしていない場合でも、いくつかのケースで高速再送を起動することを決定するために、このようなヒューリスティックを使用することができます。"
    },
    {
      "indent": 3,
      "text": "For example, when three duplicate acknowledgments are caused by the unnecessary retransmission of three packets, this is likely to be accompanied by the Cumulative Acknowledgment field advancing by at least four segments. Similarly, a heuristic based on timestamps uses the fact that when there is a hole in the sequence space, the timestamp echoed in the duplicate acknowledgment is the timestamp of the most recent data packet that advanced the Cumulative Acknowledgment field [RFC1323]. If timestamps are used, and the sender stores the timestamp of the last acknowledged segment, then the timestamp echoed by duplicate acknowledgments can be used to distinguish between a retransmitted packet that was dropped and three duplicate acknowledgments from the unnecessary retransmission of three packets.",
      "ja": "3つの重複確認応答が3つのパケットの不必要な再送信によって引き起こされる場合、例えば、これは、少なくとも4つのセグメントにより前進累積確認応答フィールドが付随する可能性があります。同様に、タイムスタンプに基づいてヒューリスティックは、シーケンス空間に穴がある場合、重複確認応答にエコータイムスタンプが累積確認応答フィールド[RFC1323]を高度な最新のデータパケットのタイムスタンプであるという事実を使用しています。タイムスタンプが最後に認めセグメントのタイムスタンプを使用し、送信元の店舗されている場合は、重複確認応答でエコータイムスタンプがドロップされた再送パケットと3つのパケットの不必要な再送信から3つの重複確認応答を区別するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.1. ACK Heuristic",
      "section_title": true,
      "ja": "4.1.  ACKヒューリスティック"
    },
    {
      "indent": 3,
      "text": "If the ACK-based heuristic is used, then following the advancement of the Cumulative Acknowledgment field, the sender stores the value of the previous cumulative acknowledgment as prev_highest_ack, and stores the latest cumulative ACK as highest_ack. In addition, the following check is performed if, in step 2 of Section 3.2, the Cumulative Acknowledgment field does not cover more than recover.",
      "ja": "ACKベースのヒューリスティックが使用されている場合には、累積確認応答フィールドの進歩以下、送信元の店舗prev_highest_ackとして以前の累積的な承認の値、およびhighest_ackなど最新の累積ACKを格納します。また、次のチェックは、セクション3.2のステップ2で、累積確認応答フィールドが回復する以上をカバーしていない、場合に行われます。"
    },
    {
      "indent": 3,
      "text": "2*) If the Cumulative Acknowledgment field didn't cover more than recover, check to see if the congestion window is greater than SMSS bytes and the difference between highest_ack and prev_highest_ack is at most 4*SMSS bytes. If true, duplicate ACKs indicate a lost segment (enter fast retransmit). Otherwise, duplicate ACKs likely result from unnecessary retransmissions (do not enter fast retransmit).",
      "ja": "累積確認応答フィールドが回復以上をカバーしていない場合は2 *）、輻輳ウィンドウは、SMSSバイトよりも大きく、highest_ackとprev_highest_ack間の差はほとんど4 *のSMSSバイトであるかどうかを確認します。真、重複ACKが失われたセグメントを示している場合（高速再送信を入力してください）。それ以外の場合は、不要な再送信（高速再送信を入力しない）からのA​​CKそうな結果を複製します。"
    },
    {
      "indent": 3,
      "text": "The congestion window check serves to protect against fast retransmit immediately after a retransmit timeout.",
      "ja": "輻輳ウィンドウのチェックは、直ちに再送タイムアウト後に高速再送から保護するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "If several ACKs are lost, the sender can see a jump in the cumulative ACK of more than three segments, and the heuristic can fail. [RFC5681] recommends that a receiver should send duplicate ACKs for every out-of-order data packet, such as a data packet received during fast recovery. The ACK heuristic is more likely to fail if the receiver does not follow this advice, because then a smaller number of ACK losses are needed to produce a sufficient jump in the cumulative ACK.",
      "ja": "いくつかのACKが失われた場合、送信者は以上の三つのセグメントの累積ACKでジャンプを見ることができる、とヒューリスティックは失敗する可能性があります。 [RFC5681]は、受信機が、このような高速回復中に受信したデータパケットとして、すべてのアウトオブオーダーデータパケットの重複ACKを送信する必要がありますことをお勧めします。 ACKヒューリスティックは、ACK損失の少ない数は累積ACKで十分なジャンプを生成するために必要とされているため、受信機は、このアドバイスに従わない場合は失敗する可能性が高いです。"
    },
    {
      "indent": 0,
      "text": "4.2. Timestamp Heuristic",
      "section_title": true,
      "ja": "4.2. タイムスタンプヒューリスティック"
    },
    {
      "indent": 3,
      "text": "If this heuristic is used, the sender stores the timestamp of the last acknowledged segment. In addition, the last sentence of step 2 in Section 3.2 of this document is replaced as follows:",
      "ja": "このヒューリスティックを使用する場合、送信側は最後認めセグメントのタイムスタンプを格納します。次のように加えて、このドキュメントのセクション3.2のステップ2の最後の文が置き換えられます。"
    },
    {
      "indent": 3,
      "text": "2**) If the Cumulative Acknowledgment field didn't cover more than recover, check to see if the echoed timestamp in the last non-duplicate acknowledgment equals the stored timestamp. If true, duplicate ACKs indicate a lost segment (enter fast retransmit). Otherwise, duplicate ACKs likely result from unnecessary retransmissions (do not enter fast retransmit).",
      "ja": "2 **）累積確認応答フィールドが回復以上をカバーしていない場合は、最後の非重複確認応答におけるエコータイムスタンプが保存されたタイムスタンプと等しいかどうかを確認します。真、重複ACKが失われたセグメントを示している場合（高速再送信を入力してください）。それ以外の場合は、不要な再送信（高速再送信を入力しない）からのA​​CKそうな結果を複製します。"
    },
    {
      "indent": 3,
      "text": "The timestamp heuristic works correctly, both when the receiver echoes timestamps, as specified by [RFC1323], and by its revision attempts. However, if the receiver arbitrarily echoes timestamps, the heuristic can fail. The heuristic can also fail if a timeout was spurious and returning ACKs are not from retransmitted segments. This can be prevented by detection algorithms such as the Eifel detection algorithm [RFC3522].",
      "ja": "タイムスタンプヒューリスティックが正常に動作し、両方の[RFC1323]によって、およびその改訂試行によって指定されるように、受信機は、タイムスタンプをエコーし​​ます。受信機が任意にタイムスタンプをエコーする場合は、ヒューリスティックは失敗する可能性があります。タイムアウトがスプリアスた場合ヒューリスティックも失敗することができますし、戻ってACKが再送されたセグメントからではありません。これは、アイフェル検出アルゴリズム[RFC3522]として検出アルゴリズムによって防止することができます。"
    },
    {
      "indent": 0,
      "text": "5. Implementation Issues for the Data Receiver",
      "section_title": true,
      "ja": "データ受信のため5.実装の問題"
    },
    {
      "indent": 3,
      "text": "[RFC5681] specifies that \"Out-of-order data segments SHOULD be acknowledged immediately, in order to accelerate loss recovery\". Neal Cardwell has noted that some data receivers do not send an immediate acknowledgment when they send a partial acknowledgment, but instead wait first for their delayed acknowledgment timer to expire [C98]. As [C98] notes, this severely limits the potential benefit of NewReno by delaying the receipt of the partial acknowledgment at the data sender. Echoing [RFC5681], our recommendation is that the data receiver send an immediate acknowledgment for an out-of-order segment, even when that out-of-order segment fills a hole in the buffer.",
      "ja": "[RFC5681]は、「アウト・オブ・オーダーのデータセグメントが損失回復を促進するために、すぐに認められるべきである」ことを指定します。ニールカードウェルは、いくつかのデータ受信機は、彼らが部分的に確認応答を送信するときにすぐに確認応答を送信、代わりに期限切れにその遅延確認応答タイマー[C98]のための最初の待機していないことを指摘しています。 [C98]のノートのように、これは深刻なデータ送信側で部分的確認応答の受信を遅延させることによりNewRenoのの潜在的な利点を制限します。 [RFC5681]をエコー、我々の推奨は、アウト・オブ・オーダのセグメントは、バッファ内の穴を充填する場合にも、データ受信機は、アウト・オブ・オーダのセグメントのための即時の確認応答を送信することです。"
    },
    {
      "indent": 0,
      "text": "6. Implementation Issues for the Data Sender",
      "section_title": true,
      "ja": "データ送信側6.実装の問題"
    },
    {
      "indent": 3,
      "text": "In Section 3.2, step 3 above, it is noted that implementations should take measures to avoid a possible burst of data when leaving fast recovery, in case the amount of new data that the sender is eligible to send due to the new value of the congestion window is large. This can arise during NewReno when ACKs are lost or treated as pure window updates, thereby causing the sender to underestimate the number of new segments that can be sent during the recovery procedure. Specifically, bursts can occur when the FlightSize is much less than the new congestion window when exiting from fast recovery. One simple mechanism to avoid a burst of data when leaving fast recovery is to limit the number of data packets that can be sent in response to a single acknowledgment. (This is known as \"maxburst_\" in ns-2 [NS].) Other possible mechanisms for avoiding bursts include rate-based pacing, or setting the slow start threshold to the resultant congestion window and then resetting the congestion window to FlightSize. A recommendation on the general mechanism to avoid excessively bursty sending patterns is outside the scope of this document.",
      "ja": "3.2節では、上記のステップ3は、高速回復を離れる際に実装が送信者は輻輳の新しい値に送信する資格である場合には、新しいデータの量をデータの可能性のあるバーストを回避するための措置をとるべきであることに留意されたいです窓が大きいです。 ACKがそれによって回復手順中に送信することができる新たなセグメントの数を過小評価するために、送信者を引き起こして、失われたまたは純粋なウィンドウの更新として扱われるとき、これはNewRenoの間に生じ得ます。高速リカバリから出たときにFlightSizeが新しい輻輳ウィンドウよりもはるかに小さい場合に具体的に、バーストが発生する可能性があります。高速リカバリを離れる際にデータのバーストを回避する1つの単純なメカニズムは、単一の確認応答に応答して送信できるデータパケットの数を制限することです。 （これは、NS-2 [NS]に「maxburst_」として知られている。）バーストを回避するための他の可能なメカニズムは、レートベースのペーシングを含む、または得られた混雑ウィンドウにスロースタート閾値を設定し、次にFlightSizeに輻輳ウィンドウをリセットします。過剰バースト性送信パターンを回避するための一般的な機構に推薦は、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "An implementation may want to use a separate flag to record whether or not it is presently in the fast recovery procedure. The use of the value of the duplicate acknowledgment counter for this purpose is not reliable, because it can be reset upon window updates and out-of-order acknowledgments.",
      "ja": "実装は、それが高速回復手順に現在あるかどうかを記録するために別のフラグを使用することをお勧めします。それは、ウィンドウの更新やアウトオブオーダー確認応答時にリセットすることができますので、この目的のために重複確認応答カウンタの値を使用することは、信頼できるものではありません。"
    },
    {
      "indent": 3,
      "text": "When updating the Cumulative Acknowledgment field outside of fast recovery, the state variable recover may also need to be updated in order to continue to permit possible entry into fast recovery (Section 3.2, step 2). This issue arises when an update of the Cumulative Acknowledgment field results in a sequence wraparound that affects the ordering between the Cumulative Acknowledgment field and the state variable recover. Entry into fast recovery is only possible when the Cumulative Acknowledgment field covers more than the state variable recover.",
      "ja": "高速リカバリの外累積確認応答フィールドを更新すると、状態変数は、回復も速い回復（3.2節、ステップ2）に変換することも可能エントリを可能にするために継続するために更新する必要があります。この問題は、累積確認応答フィールド間の順序に影響を与え、状態変数が回復シーケンスラップアラウンドにおける累積確認応答フィールド結果の時に更新を発生します。累積確認応答フィールドは、状態変数が回復するよりも多くをカバーしていたときに高速回復への参入にのみ可能です。"
    },
    {
      "indent": 3,
      "text": "It is important for the sender to respond correctly to duplicate ACKs received when the sender is no longer in fast recovery (e.g., because of a retransmit timeout). The Limited Transmit procedure [RFC3042] describes possible responses to the first and second duplicate acknowledgments. When three or more duplicate acknowledgments are received, the Cumulative Acknowledgment field doesn't cover more than recover, and a new fast recovery is not invoked, the sender should follow the guidance in Section 4. Otherwise, the sender could end up in a chain of spurious timeouts. We mention this only because several NewReno implementations had this bug, including the implementation in ns-2 [NS].",
      "ja": "送信者は送信者が（理由は再送タイムアウトの、例えば）高速リカバリされなくなったときにACKが受信複製しないように正しく応答することが重要です。限定送信手順[RFC3042]は第一および第二の重複確認応答に可能な応答を記述する。三の以上の重複確認応答が受信されると、累積確認応答フィールドが回復する以上をカバーしていない、と新しい高速リカバリが起動されていない、送信者はそうでない場合は、セクション4のガイダンスに従うべきで、送信者がチェーンに終わる可能性スプリアスタイムアウトの。我々はいくつかのNewRenoの実装はNS-2 [NS]で実施を含め、このバグを持っていたという理由だけでこれを言及します。"
    },
    {
      "indent": 3,
      "text": "It has been observed that some TCP implementations enter a slow start or congestion avoidance window updating algorithm immediately after the cwnd is set by the equation found in Section 3.2, step 3, even without a new external event generating the cwnd change. Note that after cwnd is set based on the procedure for exiting fast recovery (Section 3.2, step 3), cwnd should not be updated until a further event occurs (e.g., arrival of an ack, or timeout) after this adjustment.",
      "ja": "cwndのは、セクション3.2、ステップ3で見つかった式で設定された後、いくつかのTCP実装がさえたcwndの変更を生成し、新たな外部イベントせずに、すぐにスロースタートや輻輳回避窓更新アルゴリズムを入力することが観察されています。 CWNDが高速リカバリ（セクション3.2、工程3）を出射するための手順に基づいて設定された後、さらにイベントが発生するまで、CWNDが更新されるべきではないことに留意されたい（例えば、ACK、またはタイムアウトの到着）この調整後。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "[RFC5681] discusses general security considerations concerning TCP congestion control. This document describes a specific algorithm that conforms with the congestion control requirements of [RFC5681], and so those considerations apply to this algorithm, too. There are no known additional security concerns for this specific algorithm.",
      "ja": "[RFC5681]はTCPの輻輳制御に関する一般的なセキュリティの考慮事項について説明します。この文書では、[RFC5681]の輻輳制御要件に準拠する特定のアルゴリズムを記述し、そのため、これらの考慮事項は、あまりにも、このアルゴリズムに適用されます。この特定のアルゴリズムには知られている追加のセキュリティ上の懸念はありません。"
    },
    {
      "indent": 0,
      "text": "8. Conclusions",
      "section_title": true,
      "ja": "8.結論"
    },
    {
      "indent": 3,
      "text": "This document specifies the NewReno fast retransmit and fast recovery algorithms for TCP. This NewReno modification to TCP can even be important for TCP implementations that support the SACK option, because the SACK option can only be used for TCP connections when both TCP end-nodes support the SACK option. NewReno performs better than Reno in a number of scenarios discussed in previous versions of this RFC ([RFC2582] [RFC3782]).",
      "ja": "この文書では、TCPのためのNewRenoの高速再送と高速回復アルゴリズムを指定します。 TCPの両方のエンドノードがSACKオプションをサポートするときSACKオプションのみのTCP接続のために使用することができるので、TCPこのNewRenoの変更であっても、SACKオプションをサポートするTCP実装のために重要であり得ます。 NewRenoのこのRFCの以前のバージョン（[RFC2582]、[RFC3782]）で説明したシナリオの数にリノより良好に機能します。"
    },
    {
      "indent": 3,
      "text": "A number of options for the basic algorithms presented in Section 3 are also referenced in Appendix A of this document. These include the handling of the retransmission timer, the response to partial acknowledgments, and whether or not the sender must maintain a state variable called recover. Our belief is that the differences between these variants of NewReno are small compared to the differences between Reno and NewReno. That is, the important thing is to implement NewReno instead of Reno for a TCP connection without SACK; it is less important exactly which variant of NewReno is implemented.",
      "ja": "第3節で提示し、基本的なアルゴリズムの選択肢の数も、このドキュメントの付録Aで参照されています。これらは、再送タイマの取り扱い、部分的確認応答に応じて、送信者が回復すると呼ばれる状態変数を維持する必要があるかどうかが含まれます。私たちの信念はNewRenoののこれらの変異体の違いはリノとNewRenoの間の違いに比べて小さいということです。それは重要なことは、SACKなしのTCP接続の代わりにリノのNewRenoのを実装することで、あります。それはNewRenoののバリアントが実装されているかを正確にそれほど重要ではありません。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgments",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "Many thanks to Anil Agarwal, Mark Allman, Armando Caro, Jeffrey Hsu, Vern Paxson, Kacheong Poon, Keyur Shah, and Bernie Volz for detailed feedback on the precursor RFCs 2582 and 3782. Jeffrey Hsu provided clarifications on the handling of the variable recover; these clarifications were applied to RFC 3782 via an erratum and are incorporated into the text of Section 6 of this document. Yoshifumi Nishida contributed a modification to the fast recovery algorithm to account for the case in which FlightSize is 0 when the TCP sender leaves fast recovery and the TCP receiver uses delayed acknowledgments. Alexander Zimmermann provided several suggestions to improve the clarity of the document.",
      "ja": "ジェフリー・スーは、変数の取り扱いについて明確化を提供する前駆体のRFC 2582と3782.の詳細なフィードバックのためのアニルAgarwalさん、マーク・オールマン、アルマンドカロ、ジェフリー・スー、バーン・パクソン、Kacheongプーン、Keyurシャー、バーニーフォルツに感謝回復。これらの明確化はエラータを経由して、RFC 3782に適用し、このドキュメントのセクション6のテキストに組み込まれています。西田佳史は、TCPの送信側が高速リカバリを出て、TCP受信機が遅延確認応答を使用する場合FlightSizeが0である場合を考慮して高速回復アルゴリズムに変更を貢献しました。アレクサンダー・ツィンマーマンは、文書の明瞭度を改善するために、いくつかの提案を提供しました。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, September 2009.",
      "ja": "[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 \"TCP輻輳制御\"、RFC 5681、2009年9月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[C98] Cardwell, N., \"delayed ACKs for retransmitted packets: ouch!\". November 1998, Email to the tcpimpl mailing list, archived at <http://groups.yahoo.com/group/tcp-impl/message/1428>.",
      "ja": "[C98]カードウェル、N.は、 \"再送パケットのためのACKを遅らせ：痛いです！\"。 1998年11月、<http://groups.yahoo.com/group/tcp-impl/message/1428>にアーカイブtcpimplメーリングリスト、メールで送信。"
    },
    {
      "indent": 3,
      "text": "[F94] Floyd, S., \"TCP and Successive Fast Retransmits\", Technical report, May 1995. <ftp://ftp.ee.lbl.gov/papers/fastretrans.ps>.",
      "ja": "[F94]フロイド、S.、 \"TCPおよび連続高速再送信\"、技術報告、月1995 <ftp://ftp.ee.lbl.gov/papers/fastretrans.ps>。"
    },
    {
      "indent": 3,
      "text": "[FF96] Fall, K. and S. Floyd, \"Simulation-based Comparisons of Tahoe, Reno and SACK TCP\", Computer Communication Review, July 1996. <ftp://ftp.ee.lbl.gov/papers/sacks.ps.Z>.",
      "ja": "[FF96]秋、K.およびS.フロイド、コンピュータコミュニケーションレビュー、1996年7月<ftp://ftp.ee.lbl.gov/papers/sacks「タホ、リノとSACK TCPのシミュレーションベースの比較」。 ps.Z>。"
    },
    {
      "indent": 3,
      "text": "[GF04] Gurtov, A. and S. Floyd, \"Resolving Acknowledgment Ambiguity in non-SACK TCP\", NExt Generation Teletraffic and Wired/Wireless Advanced Networking (NEW2AN'04), February 2004. <http://www.cs.helsinki.fi/u/gurtov/ papers/heuristics.html>.",
      "ja": "[GF04] Gurtov、A.とS.フロイド、 \"非SACKのTCPでの解決謝辞あいまいさ\"、次世代トラヒック及び有線/無線高度なネットワーク（NEW2AN'04）、2004年2月<のhttp：//www.cs。 helsinki.fi/u/gurtov/論文/ heuristics.html>。"
    },
    {
      "indent": 3,
      "text": "[Gur03] Gurtov, A., \"[Tsvwg] resolving the problem of unnecessary fast retransmits in go-back-N\", email to the tsvwg mailing list, July 28, 2003. <http://www.ietf.org/mail-archive/ web/tsvwg/current/msg04334.html>.",
      "ja": "[Gur03] Gurtov、A.、 \"[TSVWG]ゴーバック-Nに不要の高速再送信の問題を解決する\"、TSVWGメーリングリスト、7月28日に電子メール、2003年<http://www.ietf.org/メールアーカイブ/ウェブ/ TSVWG /現在/ msg04334.html>。"
    },
    {
      "indent": 3,
      "text": "[Hen98] Henderson, T., \"Re: NewReno and the 2001 Revision\", September 1998. Email to the tcpimpl mailing list, archived at <http://groups.yahoo.com/group/tcp-impl/message/1321>.",
      "ja": "[Hen98]ヘンダーソン、T.、「再：NewRenoのと2001年改訂版」、<http://groups.yahoo.com/group/tcp-impl/message/1321にアーカイブtcpimplメーリングリストへ1998年9月の電子メール、 >。"
    },
    {
      "indent": 3,
      "text": "[Hoe95] Hoe, J., \"Startup Dynamics of TCP's Congestion Control and Avoidance Schemes\", Master's Thesis, MIT, June 1995.",
      "ja": "[Hoe95]鍬、J.、「TCPの輻輳制御と回避スキームのスタートアップダイナミクス」、修士論文、MIT、1995年6月。"
    },
    {
      "indent": 3,
      "text": "[Hoe96] Hoe, J., \"Improving the Start-up Behavior of a Congestion Control Scheme for TCP\", ACM SIGCOMM, August 1996. <http://ccr.sigcomm.org/archive/1996/conf/hoe.pdf>.",
      "ja": "[Hoe96]鍬、J.、ACM SIGCOMM「TCP輻輳制御方式のスタートアップ行動の改善」、1996年8月<http://ccr.sigcomm.org/archive/1996/conf/hoe.pdf >。"
    },
    {
      "indent": 3,
      "text": "[LM97] Lin, D. and R. Morris, \"Dynamics of Random Early Detection\", SIGCOMM 97, October 1997.",
      "ja": "[LM97]林、D.とR.モリス、 \"ランダム早期検出のダイナミクス\"、SIGCOMM 97、1997年10月。"
    },
    {
      "indent": 3,
      "text": "[NS] \"The Network Simulator version 2 (ns-2)\", <http://www.isi.edu/nsnam/ns/>.",
      "ja": "[NS] \"ネットワークシミュレータバージョン2（NS-2）\"、<http://www.isi.edu/nsnam/ns/>。"
    },
    {
      "indent": 3,
      "text": "[RFC1323] Jacobson, V., Braden, R., and D. Borman, \"TCP Extensions for High Performance\", RFC 1323, May 1992.",
      "ja": "[RFC1323]ジェーコブソン、V.、ブレーデン、R.、およびD.ボーマン、 \"ハイパフォーマンスのためのTCP拡張\"、RFC 1323、1992年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2582] Floyd, S. and T. Henderson, \"The NewReno Modification to TCP's Fast Recovery Algorithm\", RFC 2582, April 1999.",
      "ja": "[RFC2582]フロイド、S.とT.ヘンダーソン、 \"TCPの高速回復アルゴリズムにNewRenoの変更\"、RFC 2582、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, \"An Extension to the Selective Acknowledgement (SACK) Option for TCP\", RFC 2883, July 2000.",
      "ja": "[RFC2883]フロイド、S.、Mahdavi、J.、マティス、M.、およびM.ポドルスキー、RFC 2883、2000年7月 \"TCPのための選択的確認応答（SACK）オプションの拡張\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3042] Allman, M., Balakrishnan, H., and S. Floyd, \"Enhancing TCP's Loss Recovery Using Limited Transmit\", RFC 3042, January 2001.",
      "ja": "[RFC3042]オールマン、M.、バラクリシュナン、H.、およびS.フロイド、 \"株式会社トランスミットを使用したTCPの損失回復の強化\"、RFC 3042、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3522] Ludwig, R. and M. Meyer, \"The Eifel Detection Algorithm for TCP\", RFC 3522, April 2003.",
      "ja": "[RFC3522]ルートヴィヒ、R.及びM.マイヤー、 \"TCPのためのアイフェル検出アルゴリズム\"、RFC 3522、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3782] Floyd, S., Henderson, T., and A. Gurtov, \"The NewReno Modification to TCP's Fast Recovery Algorithm\", RFC 3782, April 2004.",
      "ja": "[RFC3782]フロイド、S.、ヘンダーソン、T.、およびA. Gurtov、RFC 3782、2004年4月 \"TCPの高速回復アルゴリズムにNewRenoの変更\"。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Additional Information",
      "ja": "付録A.追加情報"
    },
    {
      "indent": 3,
      "text": "Previous versions of this RFC ([RFC2582] [RFC3782]) contained additional informative material on the following subjects, and may be consulted by readers who may want more information about possible variants to the algorithms and who may want references to specific [NS] simulations that provide NewReno test cases.",
      "ja": "このRFC（[RFC2582] [RFC3782]）の以前のバージョンは、次の科目に追加有益な材料を含有し、特定の参照[NS]のシミュレーションをすることができアルゴリズムと人への可能な変形の詳細をすることが読者によって相談することができますそれはNewRenoのテストケースを提供しています。"
    },
    {
      "indent": 3,
      "text": "Section 4 of [RFC3782] discusses some alternative behaviors for resetting the retransmit timer after a partial acknowledgment.",
      "ja": "[RFC3782]のセクション4は、部分的に承認した後に再送信タイマーをリセットするためのいくつかの別の行動を説明します。"
    },
    {
      "indent": 3,
      "text": "Section 5 of [RFC3782] discusses some alternative behaviors for performing retransmission after a partial acknowledgment.",
      "ja": "[RFC3782]のセクション5は、部分的に承認した後に再送を実行するためのいくつかの別の行動を説明します。"
    },
    {
      "indent": 3,
      "text": "Section 6 of [RFC3782] describes more information about the motivation for the sender's state variable recover.",
      "ja": "[RFC3782]のセクション6は、送信者の状態変数の回復のための動機について詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "Section 9 of [RFC3782] introduces some NS simulation test suites for NewReno. In addition, references to simulation results can be found throughout [RFC3782].",
      "ja": "[RFC3782]のセクション9は、NewRenoのためのいくつかのNSシミュレーション・テスト・スイートを導入しています。また、シミュレーション結果を参照するには、[RFC3782]で発見することができます。"
    },
    {
      "indent": 3,
      "text": "Section 10 of [RFC3782] provides a comparison of Reno and NewReno TCP.",
      "ja": "[RFC3782]のセクション10はリノとNewRenoのTCPの比較を提供します。"
    },
    {
      "indent": 3,
      "text": "Section 11 of [RFC3782] lists changes relative to [RFC2582].",
      "ja": "[RFC3782]のセクション11は、[RFC2582]への相対的な変化を示しています。"
    },
    {
      "indent": 1,
      "text": "Appendix B. Changes Relative to",
      "ja": "付録B.への相対的な変化します"
    },
    {
      "indent": 3,
      "text": "In [RFC3782], the cwnd after Full ACK reception will be set to (1) min (ssthresh, FlightSize + SMSS) or (2) ssthresh. However, the first option carries a risk of performance degradation: With the first option, if FlightSize is zero, the result will be 1 SMSS. This means TCP can transmit only 1 segment at that moment, which can cause a delay in ACK transmission at the receiver due to a delayed ACK algorithm.",
      "ja": "[RFC3782]に、フルACKの受信後CWNDは、（1）分（SSTHRESH、FlightSize + SMSS）または（2）SSTHRESHに設定されます。しかし、最初のオプションは、性能低下のリスクを運ぶ：FlightSizeがゼロである場合は、最初のオプションでは、結果は、1 SMSSであろう。これは、TCPが原因遅延ACKアルゴリズムに受信機にACK伝送の遅延を引き起こすことができ、その時点で1つだけのセグメントを送信することができることを意味します。"
    },
    {
      "indent": 3,
      "text": "The FlightSize on Full ACK reception can be zero in some situations. A typical example is where the sending window size during fast recovery is small. In this case, the retransmitted packet and new data packets can be transmitted within a short interval. If all these packets successfully arrive, the receiver may generate a Full ACK that acknowledges all outstanding data. Even if the window size is not small, loss of ACK packets or a receive buffer shortage during fast recovery can also increase the possibility of falling into this situation.",
      "ja": "全ACKの受信にFlightSizeは、いくつかの状況ではゼロになることができます。高速リカバリ時の送信ウィンドウサイズが小さい場合の典型的な例があります。この場合、再送パケットと新規データパケットは、短い間隔内に送信することができます。これらすべてのパケットが正常に到着した場合、受信機は、すべての未処理データを承認全ACKを生成してもよいです。ウィンドウサイズが小さくない場合でも、高速リカバリ時のACKパケットの損失や受信バッファ不足も、このような状況に陥る可能性を高めることができます。"
    },
    {
      "indent": 3,
      "text": "The proposed fix in this document, which sets cwnd to at least 2*SMSS if the implementation uses option 1 in the Full ACK case (Section 3.2, step 3, option 1), ensures that the sender TCP transmits at least two segments on Full ACK reception.",
      "ja": "実装フルACKの場合（3.2節、ステップ3、オプション1）にオプション1を使用する場合、少なくとも2 * SMSSにCWNDを設定し、この文書で提案された修正は、送信側TCPは完全に少なくとも二つのセグメントを送信することを保証しますACK受信。"
    },
    {
      "indent": 3,
      "text": "In addition, an erratum was reported for RFC 3782 (an editorial clarification to Section 8); this erratum has been addressed in Section 6 of this document.",
      "ja": "さらに、エラッタは、RFC 3782（セクション8に編集明確化）のために報告されました。このエラータは、このドキュメントのセクション6で解決されています。"
    },
    {
      "indent": 3,
      "text": "The specification text (Section 3.2 herein) was rewritten to more closely track Section 3.2 of [RFC5681].",
      "ja": "仕様テキスト（本明細書のセクション3.2）がより密接に[RFC5681]のセクション3.2を追跡するために書き直されました。"
    },
    {
      "indent": 3,
      "text": "Sections 4, 5, and 9-11 of [RFC3782] were removed, and instead Appendix A of this document was added to back-reference this informative material. A few references that have no citation in the main body of the document have been removed.",
      "ja": "セクション4,5、及び[RFC3782]の9-11を除去し、その代わりに、このドキュメントの付録Aは、この有益な物質を基準にバックアップするために加えました。文書の本体には引用を持っていないいくつかの参照が削除されました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Tom Henderson The Boeing Company",
      "ja": "トム・ヘンダーソンザ・ボーイング・カンパニー"
    },
    {
      "indent": 3,
      "text": "EMail: thomas.r.henderson@boeing.com",
      "ja": "メールアドレス：thomas.r.henderson@boeing.com"
    },
    {
      "indent": 3,
      "text": "Sally Floyd International Computer Science Institute",
      "ja": "サリーフロイド国際コンピュータサイエンス研究所"
    },
    {
      "indent": 3,
      "text": "Phone: +1 (510) 666-2989 EMail: floyd@acm.org URL: http://www.icir.org/floyd/",
      "ja": "電話：+1（510）666-2989 Eメール：floyd@acm.org URL：http://www.icir.org/floyd/"
    },
    {
      "indent": 3,
      "text": "Andrei Gurtov University of Oulu Centre for Wireless Communications CWC P.O. Box 4500 FI-90014 University of Oulu Finland",
      "ja": "無線通信CWCの私書箱のためのオウルセンターのアンドレイGurtov大学オウル、フィンランドのボックス4500 FI-90014大学"
    },
    {
      "indent": 3,
      "text": "EMail: gurtov@ee.oulu.fi",
      "ja": "メールアドレス：gurtov@ee.oulu.fi"
    },
    {
      "indent": 3,
      "text": "Yoshifumi Nishida WIDE Project Endo 5322 Fujisawa, Kanagawa 252-8520 Japan",
      "ja": "よしふみ にしだ うぃで Ｐろじぇｃｔ えんど ５３２２ ふじさわ、 かながわ ２５２ー８５２０ じゃぱん"
    },
    {
      "indent": 3,
      "text": "EMail: nishida@wide.ad.jp",
      "ja": "メールアドレス：nishida@wide.ad.jp"
    }
  ]
}