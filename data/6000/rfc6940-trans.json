{
  "title": {
    "text": "RFC 6940 - REsource LOcation And Discovery (RELOAD) Base Protocol",
    "ja": "RFC 6940 - リソースの場所と発見（RELOAD）基本プロトコル"
  },
  "number": 6940,
  "created_at": "2019-11-01 20:53:46.810443+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       C. Jennings\nRequest for Comments: 6940                                         Cisco\nCategory: Standards Track                               B. Lowekamp, Ed.\nISSN: 2070-1721                                                    Skype\n                                                             E. Rescorla\n                                                              RTFM, Inc.\n                                                                S. Baset\n                                                          H. Schulzrinne\n                                                     Columbia University\n                                                            January 2014",
      "raw": true
    },
    {
      "indent": 9,
      "text": "REsource LOcation And Discovery (RELOAD) Base Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This specification defines REsource LOcation And Discovery (RELOAD), a peer-to-peer (P2P) signaling protocol for use on the Internet. A P2P signaling protocol provides its clients with an abstract storage and messaging service between a set of cooperating peers that form the overlay network. RELOAD is designed to support a P2P Session Initiation Protocol (P2PSIP) network, but can be utilized by other applications with similar requirements by defining new usages that specify the Kinds of data that need to be stored for a particular application. RELOAD defines a security model based on a certificate enrollment service that provides unique identities. NAT traversal is a fundamental service of the protocol. RELOAD also allows access from \"client\" nodes that do not need to route traffic or store data for others.",
      "ja": "この仕様は、リソースロケーションとディスカバリー（リロード）、ピア・ツー・ピア（P2P）は、インターネット上で使用するためのシグナリングプロトコルを定義します。 P2Pシグナリングプロトコルは、オーバーレイネットワークを形成ピア協働のセットとの間の抽象ストレージとメッセージングサービスを顧客に提供します。リロードがP2Pセッション開始プロトコル（P2PSIP）ネットワークをサポートするように設計されているが、特定の用途のために保存する必要があるデータの種類を指定する新たな用途を定義することによって、同様の要件を持つ他のアプリケーションで利用することができます。 RELOADは、ユニークなIDを提供し、証明書の登録サービスに基づいたセキュリティモデルを定義します。 NATトラバーサルは、プロトコルの基本的なサービスです。 RELOADまた、トラフィックのルーティングや他人のためにデータを格納する必要はありません「クライアント」のノードからのアクセスを可能にします。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6940.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6940で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   7\n  1.1.  Basic Setting . . . . . . . . . . . . . . . . . . . . . .   8\n  1.2.  Architecture  . . . . . . . . . . . . . . . . . . . . . .  10\n    1.2.1.  Usage Layer . . . . . . . . . . . . . . . . . . . . .  13\n    1.2.2.  Message Transport . . . . . . . . . . . . . . . . . .  13\n    1.2.3.  Storage . . . . . . . . . . . . . . . . . . . . . . .  14\n    1.2.4.  Topology Plug-in  . . . . . . . . . . . . . . . . . .  15\n    1.2.5.  Forwarding and Link Management Layer  . . . . . . . .  16\n  1.3.  Security  . . . . . . . . . . . . . . . . . . . . . . . .  16\n  1.4.  Structure of This Document  . . . . . . . . . . . . . . .  17\n2.  Requirements Language . . . . . . . . . . . . . . . . . . . .  18\n3.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  18\n4.  Overlay Management Overview . . . . . . . . . . . . . . . . .  21\n  4.1.  Security and Identification . . . . . . . . . . . . . . .  21\n    4.1.1.  Shared-Key Security . . . . . . . . . . . . . . . . .  23\n  4.2.  Clients . . . . . . . . . . . . . . . . . . . . . . . . .  23\n    4.2.1.  Client Routing  . . . . . . . . . . . . . . . . . . .  24\n    4.2.2.  Minimum Functionality Requirements for Clients  . . .  25\n  4.3.  Routing . . . . . . . . . . . . . . . . . . . . . . . . .  25",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  4.4.  Connectivity Management . . . . . . . . . . . . . . . . .  29\n  4.5.  Overlay Algorithm Support . . . . . . . . . . . . . . . .  30\n    4.5.1.  Support for Pluggable Overlay Algorithms  . . . . . .  30\n    4.5.2.  Joining, Leaving, and Maintenance Overview  . . . . .  30\n  4.6.  First-Time Setup  . . . . . . . . . . . . . . . . . . . .  32\n    4.6.1.  Initial Configuration . . . . . . . . . . . . . . . .  32\n    4.6.2.  Enrollment  . . . . . . . . . . . . . . . . . . . . .  32\n    4.6.3.  Diagnostics . . . . . . . . . . . . . . . . . . . . .  33\n5.  Application Support Overview  . . . . . . . . . . . . . . . .  33\n  5.1.  Data Storage  . . . . . . . . . . . . . . . . . . . . . .  33\n    5.1.1.  Storage Permissions . . . . . . . . . . . . . . . . .  34\n    5.1.2.  Replication . . . . . . . . . . . . . . . . . . . . .  35\n  5.2.  Usages  . . . . . . . . . . . . . . . . . . . . . . . . .  36\n  5.3.  Service Discovery . . . . . . . . . . . . . . . . . . . .  36\n  5.4.  Application Connectivity  . . . . . . . . . . . . . . . .  36\n6.  Overlay Management Protocol . . . . . . . . . . . . . . . . .  37\n  6.1.  Message Receipt and Forwarding  . . . . . . . . . . . . .  37\n    6.1.1.  Responsible ID  . . . . . . . . . . . . . . . . . . .  38\n    6.1.2.  Other ID  . . . . . . . . . . . . . . . . . . . . . .  38\n    6.1.3.  Opaque ID . . . . . . . . . . . . . . . . . . . . . .  40\n  6.2.  Symmetric Recursive Routing . . . . . . . . . . . . . . .  41\n    6.2.1.  Request Origination . . . . . . . . . . . . . . . . .  41\n    6.2.2.  Response Origination  . . . . . . . . . . . . . . . .  42\n  6.3.  Message Structure . . . . . . . . . . . . . . . . . . . .  42\n    6.3.1.  Presentation Language . . . . . . . . . . . . . . . .  43\n      6.3.1.1.  Common Definitions  . . . . . . . . . . . . . . .  44\n    6.3.2.  Forwarding Header . . . . . . . . . . . . . . . . . .  46\n      6.3.2.1.  Processing Configuration Sequence Numbers . . . .  49\n      6.3.2.2.  Destination and Via Lists . . . . . . . . . . . .  50\n      6.3.2.3.  Forwarding Option . . . . . . . . . . . . . . . .  52\n    6.3.3.  Message Contents Format . . . . . . . . . . . . . . .  53\n      6.3.3.1.  Response Codes and Response Errors  . . . . . . .  54\n    6.3.4.  Security Block  . . . . . . . . . . . . . . . . . . .  57\n  6.4.  Overlay Topology  . . . . . . . . . . . . . . . . . . . .  60\n    6.4.1.  Topology Plug-in Requirements . . . . . . . . . . . .  60\n    6.4.2.  Methods and Types for Use by Topology Plug-ins  . . .  61\n      6.4.2.1.  Join  . . . . . . . . . . . . . . . . . . . . . .  61\n      6.4.2.2.  Leave . . . . . . . . . . . . . . . . . . . . . .  62\n      6.4.2.3.  Update  . . . . . . . . . . . . . . . . . . . . .  63\n      6.4.2.4.  RouteQuery  . . . . . . . . . . . . . . . . . . .  63\n      6.4.2.5.  Probe . . . . . . . . . . . . . . . . . . . . . .  65\n  6.5.  Forwarding and Link Management Layer  . . . . . . . . . .  67\n    6.5.1.  Attach  . . . . . . . . . . . . . . . . . . . . . . .  67\n      6.5.1.1.  Request Definition  . . . . . . . . . . . . . . .  68\n      6.5.1.2.  Response Definition . . . . . . . . . . . . . . .  70\n      6.5.1.3.  Using ICE with RELOAD . . . . . . . . . . . . . .  71\n      6.5.1.4.  Collecting STUN Servers . . . . . . . . . . . . .  71\n      6.5.1.5.  Gathering Candidates  . . . . . . . . . . . . . .  72",
      "raw": true
    },
    {
      "indent": 3,
      "text": "      6.5.1.6.  Prioritizing Candidates . . . . . . . . . . . . .  72\n      6.5.1.7.  Encoding the Attach Message . . . . . . . . . . .  73\n      6.5.1.8.  Verifying ICE Support . . . . . . . . . . . . . .  74\n      6.5.1.9.  Role Determination  . . . . . . . . . . . . . . .  74\n      6.5.1.10. Full ICE  . . . . . . . . . . . . . . . . . . . .  74\n      6.5.1.11. No-ICE  . . . . . . . . . . . . . . . . . . . . .  75\n      6.5.1.12. Subsequent Offers and Answers . . . . . . . . . .  75\n      6.5.1.13. Sending Media . . . . . . . . . . . . . . . . . .  75\n      6.5.1.14. Receiving Media . . . . . . . . . . . . . . . . .  75\n    6.5.2.  AppAttach . . . . . . . . . . . . . . . . . . . . . .  75\n      6.5.2.1.  Request Definition  . . . . . . . . . . . . . . .  76\n      6.5.2.2.  Response Definition . . . . . . . . . . . . . . .  77\n    6.5.3.  Ping  . . . . . . . . . . . . . . . . . . . . . . . .  77\n      6.5.3.1.  Request Definition  . . . . . . . . . . . . . . .  77\n      6.5.3.2.  Response Definition . . . . . . . . . . . . . . .  77\n    6.5.4.  ConfigUpdate  . . . . . . . . . . . . . . . . . . . .  78\n      6.5.4.1.  Request Definition  . . . . . . . . . . . . . . .  78\n      6.5.4.2.  Response Definition . . . . . . . . . . . . . . .  79\n  6.6.  Overlay Link Layer  . . . . . . . . . . . . . . . . . . .  80\n    6.6.1.  Future Overlay Link Protocols . . . . . . . . . . . .  81\n      6.6.1.1.  HIP . . . . . . . . . . . . . . . . . . . . . . .  82\n      6.6.1.2.  ICE-TCP . . . . . . . . . . . . . . . . . . . . .  82\n      6.6.1.3.  Message-Oriented Transports . . . . . . . . . . .  82\n      6.6.1.4.  Tunneled Transports . . . . . . . . . . . . . . .  82\n    6.6.2.  Framing Header  . . . . . . . . . . . . . . . . . . .  83\n    6.6.3.  Simple Reliability  . . . . . . . . . . . . . . . . .  84\n      6.6.3.1.  Stop and Wait Sender Algorithm  . . . . . . . . .  85\n    6.6.4.  DTLS/UDP with SR  . . . . . . . . . . . . . . . . . .  86\n    6.6.5.  TLS/TCP with FH, No-ICE . . . . . . . . . . . . . . .  86\n    6.6.6.  DTLS/UDP with SR, No-ICE  . . . . . . . . . . . . . .  87\n  6.7.  Fragmentation and Reassembly  . . . . . . . . . . . . . .  87\n7.  Data Storage Protocol . . . . . . . . . . . . . . . . . . . .  88\n  7.1.  Data Signature Computation  . . . . . . . . . . . . . . .  90\n  7.2.  Data Models . . . . . . . . . . . . . . . . . . . . . . .  91\n    7.2.1.  Single Value  . . . . . . . . . . . . . . . . . . . .  91\n    7.2.2.  Array . . . . . . . . . . . . . . . . . . . . . . . .  92\n    7.2.3.  Dictionary  . . . . . . . . . . . . . . . . . . . . .  92\n  7.3.  Access Control Policies . . . . . . . . . . . . . . . . .  93\n    7.3.1.  USER-MATCH  . . . . . . . . . . . . . . . . . . . . .  93\n    7.3.2.  NODE-MATCH  . . . . . . . . . . . . . . . . . . . . .  93\n    7.3.3.  USER-NODE-MATCH . . . . . . . . . . . . . . . . . . .  93\n    7.3.4.  NODE-MULTIPLE . . . . . . . . . . . . . . . . . . . .  94\n  7.4.  Data Storage Methods  . . . . . . . . . . . . . . . . . .  94\n    7.4.1.  Store . . . . . . . . . . . . . . . . . . . . . . . .  94\n      7.4.1.1.  Request Definition  . . . . . . . . . . . . . . .  94\n      7.4.1.2.  Response Definition . . . . . . . . . . . . . . . 100\n      7.4.1.3.  Removing Values . . . . . . . . . . . . . . . . . 101",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    7.4.2.  Fetch . . . . . . . . . . . . . . . . . . . . . . . . 102\n      7.4.2.1.  Request Definition  . . . . . . . . . . . . . . . 102\n      7.4.2.2.  Response Definition . . . . . . . . . . . . . . . 104\n    7.4.3.  Stat  . . . . . . . . . . . . . . . . . . . . . . . . 105\n      7.4.3.1.  Request Definition  . . . . . . . . . . . . . . . 105\n      7.4.3.2.  Response Definition . . . . . . . . . . . . . . . 106\n    7.4.4.  Find  . . . . . . . . . . . . . . . . . . . . . . . . 107\n      7.4.4.1.  Request Definition  . . . . . . . . . . . . . . . 108\n      7.4.4.2.  Response Definition . . . . . . . . . . . . . . . 108\n    7.4.5.  Defining New Kinds  . . . . . . . . . . . . . . . . . 109\n8.  Certificate Store Usage . . . . . . . . . . . . . . . . . . . 110\n9.  TURN Server Usage . . . . . . . . . . . . . . . . . . . . . . 110\n10. Chord Algorithm . . . . . . . . . . . . . . . . . . . . . . . 112\n  10.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . 113\n  10.2.  Hash Function  . . . . . . . . . . . . . . . . . . . . . 114\n  10.3.  Routing  . . . . . . . . . . . . . . . . . . . . . . . . 114\n  10.4.  Redundancy . . . . . . . . . . . . . . . . . . . . . . . 114\n  10.5.  Joining  . . . . . . . . . . . . . . . . . . . . . . . . 115\n  10.6.  Routing Attaches . . . . . . . . . . . . . . . . . . . . 116\n  10.7.  Updates  . . . . . . . . . . . . . . . . . . . . . . . . 117\n    10.7.1.  Handling Neighbor Failures . . . . . . . . . . . . . 118\n    10.7.2.  Handling Finger Table Entry Failure  . . . . . . . . 119\n    10.7.3.  Receiving Updates  . . . . . . . . . . . . . . . . . 119\n    10.7.4.  Stabilization  . . . . . . . . . . . . . . . . . . . 120\n      10.7.4.1.  Updating the Neighbor Table  . . . . . . . . . . 120\n      10.7.4.2.  Refreshing the Finger Table  . . . . . . . . . . 121\n      10.7.4.3.  Adjusting Finger Table Size  . . . . . . . . . . 122\n      10.7.4.4.  Detecting Partitioning . . . . . . . . . . . . . 122\n  10.8.  Route Query  . . . . . . . . . . . . . . . . . . . . . . 123\n  10.9.  Leaving  . . . . . . . . . . . . . . . . . . . . . . . . 123\n11. Enrollment and Bootstrap  . . . . . . . . . . . . . . . . . . 124\n  11.1.  Overlay Configuration  . . . . . . . . . . . . . . . . . 124\n    11.1.1.  RELAX NG Grammar . . . . . . . . . . . . . . . . . . 132\n  11.2.  Discovery through Configuration Server . . . . . . . . . 134\n  11.3.  Credentials  . . . . . . . . . . . . . . . . . . . . . . 135\n    11.3.1.  Self-Generated Credentials . . . . . . . . . . . . . 137\n  11.4.  Contacting a Bootstrap Node  . . . . . . . . . . . . . . 138\n12. Message Flow Example  . . . . . . . . . . . . . . . . . . . . 138\n13. Security Considerations . . . . . . . . . . . . . . . . . . . 144\n  13.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . 144\n  13.2.  Attacks on P2P Overlays  . . . . . . . . . . . . . . . . 145\n  13.3.  Certificate-Based Security . . . . . . . . . . . . . . . 145\n  13.4.  Shared-Secret Security . . . . . . . . . . . . . . . . . 147\n  13.5.  Storage Security . . . . . . . . . . . . . . . . . . . . 147\n    13.5.1.  Authorization  . . . . . . . . . . . . . . . . . . . 147\n    13.5.2.  Distributed Quota  . . . . . . . . . . . . . . . . . 148\n    13.5.3.  Correctness  . . . . . . . . . . . . . . . . . . . . 148\n    13.5.4.  Residual Attacks . . . . . . . . . . . . . . . . . . 149",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  13.6.  Routing Security . . . . . . . . . . . . . . . . . . . . 149\n    13.6.1.  Background . . . . . . . . . . . . . . . . . . . . . 150\n    13.6.2.  Admissions Control . . . . . . . . . . . . . . . . . 150\n    13.6.3.  Peer Identification and Authentication . . . . . . . 151\n    13.6.4.  Protecting the Signaling . . . . . . . . . . . . . . 151\n    13.6.5.  Routing Loops and DoS Attacks  . . . . . . . . . . . 152\n    13.6.6.  Residual Attacks . . . . . . . . . . . . . . . . . . 152\n14. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 153\n  14.1.  Well-Known URI Registration  . . . . . . . . . . . . . . 153\n  14.2.  Port Registrations . . . . . . . . . . . . . . . . . . . 153\n  14.3.  Overlay Algorithm Types  . . . . . . . . . . . . . . . . 154\n  14.4.  Access Control Policies  . . . . . . . . . . . . . . . . 154\n  14.5.  Application-ID . . . . . . . . . . . . . . . . . . . . . 155\n  14.6.  Data Kind-ID . . . . . . . . . . . . . . . . . . . . . . 155\n  14.7.  Data Model . . . . . . . . . . . . . . . . . . . . . . . 156\n  14.8.  Message Codes  . . . . . . . . . . . . . . . . . . . . . 156\n  14.9.  Error Codes  . . . . . . . . . . . . . . . . . . . . . . 158\n  14.10. Overlay Link Types . . . . . . . . . . . . . . . . . . . 159\n  14.11. Overlay Link Protocols . . . . . . . . . . . . . . . . . 159\n  14.12. Forwarding Options . . . . . . . . . . . . . . . . . . . 160\n  14.13. Probe Information Types  . . . . . . . . . . . . . . . . 160\n  14.14. Message Extensions . . . . . . . . . . . . . . . . . . . 161\n  14.15. Reload URI Scheme  . . . . . . . . . . . . . . . . . . . 161\n    14.15.1.  URI Registration  . . . . . . . . . . . . . . . . . 162\n  14.16. Media Type Registration  . . . . . . . . . . . . . . . . 162\n  14.17. XML Namespace Registration . . . . . . . . . . . . . . . 163\n    14.17.1.  Config URL  . . . . . . . . . . . . . . . . . . . . 164\n    14.17.2.  Config Chord URL  . . . . . . . . . . . . . . . . . 164\n15. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . 164\n16. References  . . . . . . . . . . . . . . . . . . . . . . . . . 165\n  16.1.  Normative References . . . . . . . . . . . . . . . . . . 165\n  16.2.  Informative References . . . . . . . . . . . . . . . . . 167\nAppendix A.  Routing Alternatives . . . . . . . . . . . . . . . . 171\n  A.1.  Iterative vs. Recursive . . . . . . . . . . . . . . . . . 171\n  A.2.  Symmetric vs. Forward Response  . . . . . . . . . . . . . 171\n  A.3.  Direct Response . . . . . . . . . . . . . . . . . . . . . 172\n  A.4.  Relay Peers . . . . . . . . . . . . . . . . . . . . . . . 173\n  A.5.  Symmetric Route Stability . . . . . . . . . . . . . . . . 173\nAppendix B.  Why Clients? . . . . . . . . . . . . . . . . . . . . 174\n  B.1.  Why Not Only Peers? . . . . . . . . . . . . . . . . . . . 174\n  B.2.  Clients as Application-Level Agents . . . . . . . . . . . 175",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document defines REsource LOcation And Discovery (RELOAD), a peer-to-peer (P2P) signaling protocol for use on the Internet. RELOAD provides a generic, self-organizing overlay network service, allowing nodes to route messages to other nodes and to store and retrieve data in the overlay. RELOAD provides several features that are critical for a successful P2P protocol for the Internet:",
      "ja": "この文書は、リソースロケーションとディスカバリー（リロード）、ピア・ツー・ピア（P2P）は、インターネット上で使用するためのシグナリングプロトコルを定義します。 RELOADは、一般的な、自己組織化オーバレイネットワークサービスを提供して他のノードにメッセージをルーティングノードを可能とオーバーレイ内のデータを格納および取得します。 RELOADは、インターネットのための成功したP2Pプロトコルのための重要ないくつかの機能を提供します。"
    },
    {
      "indent": 3,
      "text": "Security Framework: A P2P network will often be established among a set of peers that do not trust each other. RELOAD leverages a central enrollment server to provide credentials for each peer, which can then be used to authenticate each operation. This greatly reduces the possible attack surface.",
      "ja": "セキュリティフレームワーク：P2Pネットワークは、多くの場合、お互いを信頼していないピアのセットの中で確立されます。リロードが各操作を認証するために使用することができ、各ピアの資格情報を提供するために、中央登録サーバを活用します。これは非常に可能性攻撃面を減らします。"
    },
    {
      "indent": 3,
      "text": "Usage Model: RELOAD is designed to support a variety of applications, including P2P multimedia communications with the Session Initiation Protocol (SIP) [SIP-RELOAD]. RELOAD allows the definition of new application usages, each of which can define its own data types, along with the rules for their use. This allows RELOAD to be used with new applications through a simple documentation process that supplies the details for each application.",
      "ja": "使用モデル：リロードは、セッション開始プロトコル（SIP）[SIPリロード]を有するP2Pマルチメディア通信を含む様々なアプリケーションをサポートするように設計されています。 RELOADは、それらの使用のためのルールと一緒に、独自のデータ型を定義することができますそれぞれの新しいアプリケーション用法、を定義できます。これは、RELOADは、各アプリケーションの詳細を提供する簡単な文書化プロセスを通じて、新たなアプリケーションで使用することができます。"
    },
    {
      "indent": 3,
      "text": "NAT Traversal: RELOAD is designed to function in environments where many, if not most, of the nodes are behind NATs or firewalls. Operations for NAT traversal are part of the base design, including using Interactive Connectivity Establishment (ICE) [RFC5245] to establish new RELOAD or application protocol connections.",
      "ja": "NATトラバーサル：RELOADは、ノードの多く、そうでない場合は、ほとんどがNATのか、ファイアウォールの背後にある環境で機能するように設計されています。 NATトラバーサルのための操作が新しいリロードまたはアプリケーションプロトコル接続を確立するためにインタラクティブ接続確立（ICE）[RFC5245]を使用することを含む、ベースの設計の一部です。"
    },
    {
      "indent": 3,
      "text": "Optimized Routing: The very nature of overlay algorithms introduces a requirement that peers participating in the P2P network route requests on behalf of other peers in the network. This introduces a load on those other peers in the form of bandwidth and processing power. RELOAD has been defined with a simple, lightweight forwarding header, thus minimizing the amount of effort for intermediate peers.",
      "ja": "最適化されたルーティング：オーバーレイアルゴリズムの本質は、ネットワーク内の他のピアに代わってP2Pネットワークのルート要求に参加しているピアの要件を紹介します。これは、帯域幅および処理能力の形態のものの他のピアの負荷を導入します。リロードは、このように中間ピアの努力の量を最小限に抑える、簡単、軽量転送ヘッダで定義されています。"
    },
    {
      "indent": 3,
      "text": "Pluggable Overlay Algorithms: RELOAD has been designed with an abstract interface to the overlay layer to simplify implementing a variety of structured (e.g., distributed hash tables (DHTs)) and unstructured overlay algorithms. The idea here is that RELOAD provides a generic structure that can fit most types of overlay topologies (ring, hyperspace, etc.). To instantiate an actual network, you combine RELOAD with a specific overlay algorithm, which defines how to construct the overlay topology and route messages efficiently within it. This specification also defines how RELOAD is used with the Chord-based [Chord] DHT algorithm, which is mandatory to implement. Specifying a default \"mandatory-to-implement\" overlay algorithm promotes interoperability, while extensibility allows selection of overlay algorithms optimized for a particular application.",
      "ja": "プラグ可能なオーバーレイアルゴリズム：リロードが構造化された（例えば、分散ハッシュテーブル（のDHT））および非構造化オーバーレイアルゴリズムの様々な実施簡素化するオーバレイ層に抽象インターフェースで設計されています。ここでの考え方は、RELOADは、オーバーレイ・トポロジー（リング、ハイパースペース、など）のほとんどの種類を収めることができ、一般的な構造を提供することです。実際のネットワークをインスタンス化するには、効率的にその中にオーバーレイ・トポロジーやルート、メッセージを構築する方法を定義し、特定のオーバーレイ・アルゴリズム、とRELOADを兼ね備えています。本明細書はまた、リロードを実装するために必須であるコードベースの[コード] DHTアルゴリズムと一緒に使用される方法を定義します。拡張性は、特定のアプリケーション用に最適化されたオーバーレイアルゴリズムの選択を可能にしながら、デフォルトの「実装に必須の」オーバーレイアルゴリズムを指定すると、相互運用性を促進します。"
    },
    {
      "indent": 3,
      "text": "Support for Clients: RELOAD clients differ from RELOAD peers primarily in that they do not store information on behalf of other nodes in the overlay. Rather, they use the overlay only to locate users and resources, as well as to store information and to contact other nodes.",
      "ja": "クライアントのサポート：RELOADクライアントは主に、彼らは、オーバーレイ内の他のノードに代わって情報を格納しないことにRELOADピアとは異なります。むしろ、彼らは唯一のユーザーとリソースを検索するだけでなく、情報を保存するために、他のノードに連絡するオーバーレイを使用しています。"
    },
    {
      "indent": 3,
      "text": "These properties were designed specifically to meet the requirements for a P2P protocol to support SIP. This document defines the base protocol for the distributed storage and location service, as well as critical usage for NAT traversal. The SIP Usage itself is described separately in [SIP-RELOAD]. RELOAD is not limited to usage by SIP and could serve as a tool for supporting other P2P applications with similar needs.",
      "ja": "これらのプロパティは、SIPをサポートするためのP2Pプロトコルのための要件を満たすために特別に設計されました。この文書は、基本分散ストレージおよび位置サービスのためのプロトコル、ならびにNATトラバーサルのための重要な使用法を定義します。 SIPの使用自体は、[SIPリロード]に別々に記載されています。 RELOADはSIPでの使用に限定されるものではなく、同様のニーズに合わせて他のP2Pアプリケーションをサポートするためのツールとして役立ち得ます。"
    },
    {
      "indent": 0,
      "text": "1.1. Basic Setting",
      "section_title": true,
      "ja": "1.1。標準設定"
    },
    {
      "indent": 3,
      "text": "In this section, we provide a brief overview of the operational setting for RELOAD. A RELOAD Overlay Instance consists of a set of nodes arranged in a partly connected graph. Each node in the overlay is assigned a numeric Node-ID for the lifetime of the node, which, together with the specific overlay algorithm in use, determines its position in the graph and the set of nodes it connects to. The Node-ID is also tightly coupled to the certificate (see Section 13.3). The figure below shows a trivial example which isn't drawn from any particular overlay algorithm, but was chosen for convenience of representation.",
      "ja": "このセクションでは、RELOADのための動作設定の概要を説明します。 RELOADオーバーレイインスタンスは、部分的に接続されたグラフに配置されたノードのセットからなります。オーバーレイ内の各ノードは、一緒になって、使用中の特定のオーバーレイアルゴリズムと、そのグラフ中の位置と、それが接続するノードの集合を決定し、ノードの寿命の数値ノードIDが割り当てられます。ノードIDもしっかり証明書に結合される（セクション13.3を参照）。以下の図は、任意の特定のオーバーレイアルゴリズムから引き出されていない簡単な例を示しているが、表現の便宜のために選択しました。"
    },
    {
      "indent": 6,
      "text": "+--------+              +--------+              +--------+\n| Node 10|--------------| Node 20|--------------| Node 30|\n+--------+              +--------+              +--------+\n    |                       |                       |\n    |                       |                       |\n+--------+              +--------+              +--------+\n| Node 40|--------------| Node 50|--------------| Node 60|\n+--------+              +--------+              +--------+\n    |                       |                       |\n    |                       |                       |\n+--------+              +--------+              +--------+\n| Node 70|--------------| Node 80|--------------| Node 90|\n+--------+              +--------+              +--------+\n                            |\n                            |\n                        +--------+\n                        | Node 85|\n                        |(Client)|\n                        +--------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Because the graph is not fully connected, when a node wants to send a message to another node, it may need to route it through the network. For instance, Node 10 can talk directly to nodes 20 and 40, but not to Node 70. In order to send a message to Node 70, it would first send it to Node 40, with instructions to pass it along to Node 70. Different overlay algorithms will have different connectivity graphs, but the general idea behind all of them is to allow any node in the graph to efficiently reach every other node within a small number of hops.",
      "ja": "グラフは、ノードが別のノードにメッセージを送信したいとき、それはネットワークを介してルーティングすることが必要になる場合があり、完全に接続されていないため。それは最初のノードの異なる70に沿って通過させるように指示して、40をノードに送信し、例えば、ノード10は、ノード20及び40に直接話すことができるではなく、70をノードにメッセージを送信するために70のノードにオーバーレイアルゴリズムが異なる接続グラフを持っていますが、それらのすべての背後にある一般的な考え方は、グラフ内の任意のノードを効率的にホップ数の少ない内他のすべてのノードに到達できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "The RELOAD network is not only a messaging network. It is also a storage network, albeit one designed for small-scale transient storage rather than for bulk storage of large objects. Records are stored under numeric addresses, called Resource-IDs, which occupy the same space as node identifiers. Peers are responsible for storing the data associated with some set of addresses, as determined by their Node-ID. For instance, we might say that every peer is responsible for storing any data value which has an address less than or equal to its own Node-ID, but greater than the next lowest Node-ID. Thus, Node 20 would be responsible for storing values 11-20.",
      "ja": "RELOADネットワークだけでなく、メッセージングネットワークです。これは、小規模な一過性記憶のためにではなく、大きなオブジェクトのバルク・ストレージ用に設計された1つあるが、また、ストレージネットワークです。レコードは、数値アドレスの下に格納され、ノード識別子と同じスペースを占有リソース-IDは、と呼ばれます。そのノードIDによって決定されたピアは、アドレスの一部のセットに関連するデータを格納するための責任があります。例えば、我々は、すべてのピアが未満か、自身のノードIDと同じアドレスを持つ任意のデータ値を格納するための責任が、次に低いノードIDよりも大きいことを言うかもしれません。したがって、ノード20は、値11-20を格納するための責任を負うことになります。"
    },
    {
      "indent": 3,
      "text": "RELOAD also supports clients. These are nodes which have Node-IDs but do not participate in routing or storage. For instance, in the figure above, Node 85 is a client. It can route to the rest of the RELOAD network via Node 80, but no other node will route through it, and Node 90 is still responsible for addresses in the range [81..90]. We refer to non-client nodes as peers.",
      "ja": "RELOADもクライアントをサポートします。これらは、ノードIDを持っていますが、ルーティングやストレージに参加しないノードです。例えば、上の図では、ノード85は、クライアントです。これはノード80を介してリロードネットワークの残りの部分へのルートができ、それを介して他のノードをルーティング、およびノー​​ド90は依然として範囲[81..90]のアドレスの原因です。私たちは、ピアとして非クライアント・ノードを参照してください。"
    },
    {
      "indent": 3,
      "text": "Other applications (for instance, SIP) can be defined on top of RELOAD and can use these two basic RELOAD services to provide their own services.",
      "ja": "（例えば、SIPのための）他のアプリケーションは、RELOADの上に定義することができ、独自のサービスを提供するために、これらの二つの基本的なRELOADサービスを使用することができます。"
    },
    {
      "indent": 0,
      "text": "1.2. Architecture",
      "section_title": true,
      "ja": "1.2。建築"
    },
    {
      "indent": 3,
      "text": "RELOAD is fundamentally an overlay network. The following figure shows the layered RELOAD architecture.",
      "ja": "RELOADは、基本的にオーバーレイネットワークです。次の図は、層状リロードアーキテクチャを示しています。"
    },
    {
      "indent": 12,
      "text": "Application",
      "ja": "応用"
    },
    {
      "indent": 4,
      "text": "    +-------+  +-------+\n    | SIP   |  | XMPP  |  ...\n    | Usage |  | Usage |\n    +-------+  +-------+\n------------------------------------ Messaging Service Boundary\n+------------------+     +---------+\n|     Message      |<--->| Storage |\n|    Transport     |     +---------+\n+------------------+           ^\n       ^       ^               |\n       |       v               v\n       |     +-------------------+\n       |     |    Topology       |\n       |     |    Plug-in        |\n       |     +-------------------+\n       |         ^\n       v         v\n    +------------------+\n    |  Forwarding &    |\n    | Link Management  |\n    +------------------+\n------------------------------------ Overlay Link Service Boundary\n     +-------+  +-------+\n     |TLS    |  |DTLS   |  ...\n     |Overlay|  |Overlay|\n     |Link   |  |Link   |\n     +-------+  +-------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The major components of RELOAD are:",
      "ja": "RELOADの主要なコンポーネントは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Usage Layer: Each application defines a RELOAD Usage, which is a set of data Kinds and behaviors which describe how to use the services provided by RELOAD. These usages all talk to RELOAD through a common Message Transport Service.",
      "ja": "用法・レイヤー：各アプリケーションにはRELOADが提供するサービスを利用する方法を説明し、データの種類や行動のセットですRELOAD使用状況を、定義されています。これらの用途は、すべての話は、共通のメッセージ・トランスポートサービスを通じてリロードします。"
    },
    {
      "indent": 3,
      "text": "Message Transport: Handles end-to-end reliability, manages request state for the usages, and forwards Store and Fetch operations to the Storage component. It delivers message responses to the component initiating the request.",
      "ja": "メッセージトランスポートは：、エンドツーエンドの信頼性を処理する用途に要求状態を管理し、転送ストレージコンポーネントに操作を保存し、取得します。これは、要求を開始するコンポーネントにメッセージ応答を実現します。"
    },
    {
      "indent": 3,
      "text": "Storage: The Storage component is responsible for processing messages relating to the storage and retrieval of data. It talks directly to the Topology Plug-in to manage data replication and migration, and it talks to the Message Transport component to send and receive messages.",
      "ja": "ストレージ：ストレージコンポーネントは、データの記憶および検索に関連するメッセージを処理する責任があります。これは、データの複製や移行を管理するためのトポロジプラグインに直接話し、それがメッセージを送受信するメッセージ・トランスポート・コンポーネントに話しています。"
    },
    {
      "indent": 3,
      "text": "Topology Plug-in: The Topology Plug-in is responsible for implementing the specific overlay algorithm being used. It uses the Message Transport component to send and receive overlay management messages, the Storage component to manage data replication, and the Forwarding Layer to control hop-by-hop message forwarding. This component superficially parallels conventional routing algorithms, but is more tightly coupled to the Forwarding Layer, because there is no single \"Routing Table\" equivalent used by all overlay algorithms. The Topology Plug-in has two functions: constructing the local forwarding instructions and selecting the operational topology (i.e., creating links by sending overlay management messages).",
      "ja": "トポロジプラグイン：トポロジプラグインが使用されている特定のオーバーレイ・アルゴリズムを実装するための責任があります。これは、ホップバイホップのメッセージの転送を制御するために、オーバーレイ管理メッセージを送受信するメッセージ・トランスポート・コンポーネント、データ・レプリケーションを管理するためのストレージ・コンポーネント、および転送レイヤを使用しています。すべてのオーバーレイアルゴリズムによって使用される単一の「ルーティングテーブル」と等価が存在しないため、このコンポーネントは、表面的に従来のルーティングアルゴリズムに匹敵するが、より緊密に転送レイヤに結合されています。トポロジプラグインは、2つの機能を持っている：ローカルフォワーディング指示を構築し、運用トポロジー（すなわち、オーバーレイ管理メッセージを送信することにより、リンクを作成する）を選択します。"
    },
    {
      "indent": 3,
      "text": "Forwarding and Link Management Layer: Stores and implements the Routing Table by providing packet forwarding services between nodes. It also handles establishing new links between nodes, including setting up connections for overlay links across NATs using ICE.",
      "ja": "レイヤを転送し、リンク管理：店舗とノード間でパケット転送サービスを提供することにより、ルーティングテーブルを実装します。また、ICEを使用してNATを越えオーバーレイリンクの接続を設定するなど、ノード間の新しいリンクを確立する処理します。"
    },
    {
      "indent": 3,
      "text": "Overlay Link Layer: Responsible for actually transporting traffic directly between nodes. Transport Layer Security (TLS) [RFC5246] and Datagram Transport Layer Security (DTLS) [RFC6347] are the currently defined \"overlay link layer\" protocols used by RELOAD for hop-by-hop communication. Each such protocol includes the appropriate provisions for per-hop framing and hop-by-hop ACKs needed by unreliable underlying transports. New protocols can be defined, as described in Sections 6.6.1 and 11.1. As this document defines only TLS and DTLS, we use those terms throughout the remainder of the document with the understanding that some future specification may add new overlay link layers.",
      "ja": "オーバーレイリンク層：実際には、ノード間で直接トラフィックを輸送するための責任。トランスポート層セキュリティ（TLS）[RFC5246]及びデータグラムトランスポート層セキュリティ（DTLS）[RFC6347]はホップバイホップ通信のリロードで使用される、現在定義された「オーバーレイリンク層」プロトコルです。各そのようなプロトコルは、信頼性の低い基礎となるトランスポートによって必要とされるホップ毎フレーミングおよびホップバイホップのACKのための適切な規定を含みます。セクション6.6.1と11.1で説明したように、新しいプロトコルは、定義することができます。この文書は唯一のTLSとDTLSを定義するように、我々はいくつかの将来の仕様は、新たなオーバーレイリンクレイヤを追加することも理解した上で、文書の残りの部分でこれらの用語を使用します。"
    },
    {
      "indent": 3,
      "text": "To further clarify the roles of the various layers, the following figure parallels the architecture with each layer's role from an overlay perspective and implementation layer in the Internet:",
      "ja": "さらに様々な層の役割を明確にするために、次の図は、インターネットでのオーバーレイの視点と実装層から各層の役割を持つアーキテクチャに匹敵します："
    },
    {
      "indent": 3,
      "text": " Internet    | Internet Model  |\n Model       |   Equivalent    |          Reload\n             |   in Overlay    |       Architecture\n-------------+-----------------+------------------------------------\n             |                 |    +-------+  +-------+\n             |  Application    |    | SIP   |  | XMPP  |  ...\n             |                 |    | Usage |  | Usage |\n             |                 |    +-------+  +-------+\n             |                 |  ----------------------------------\n             |                 |+------------------+     +---------+\n             |   Transport     ||     Message      |<--->| Storage |\n             |                 ||    Transport     |     +---------+\n             |                 |+------------------+           ^\n             |                 |       ^       ^               |\n             |                 |       |       v               v\nApplication  |                 |       |     +-------------------+\n             |   (Routing)     |       |     |     Topology      |\n             |                 |       |     |     Plug-in       |\n             |                 |       |     +-------------------+\n             |                 |       |         ^\n             |                 |       v         v\n             |    Network      |    +------------------+\n             |                 |    |  Forwarding &    |\n             |                 |    | Link Management  |\n             |                 |    +------------------+\n             |                 |  ----------------------------------\nTransport    |      Link       |     +-------+  +------+\n             |                 |     |TLS    |  |DTLS  |  ...\n             |                 |     +-------+  +------+\n-------------+-----------------+------------------------------------\n  Network    |\n             |\n    Link     |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In addition to the above components, nodes may communicate with a central provisioning infrastructure (not shown) to get configuration information, authentication credentials, and the initial set of nodes to communicate with to join the overlay.",
      "ja": "上記成分に加えて、ノードは、設定情報、認証証明書、およびオーバーレイに参加すると通信するノードの初期セットを取得する（図示せず）の中央プロビジョニングインフラストラクチャと通信することができます。"
    },
    {
      "indent": 0,
      "text": "1.2.1. Usage Layer",
      "section_title": true,
      "ja": "1.2.1。使い方レイヤー"
    },
    {
      "indent": 3,
      "text": "The top layer, called the Usage Layer, has application usages, such as the SIP Registration Usage [SIP-RELOAD], that use the abstract Message Transport Service provided by RELOAD. The goal of this layer is to implement application-specific usages of the generic overlay services provided by RELOAD. The Usage defines how a specific application maps its data into something that can be stored in the overlay, where to store the data, how to secure the data, and finally how applications can retrieve and use the data.",
      "ja": "トップ層は、RELOAD提供する抽象メッセージトランスポートサービスを使用するようにSIP登録使い方などのアプリケーション用法、[SIP-RELOAD]を、持っている、使用レイヤと呼ばれます。この層の目的は、RELOADによって提供される汎用オーバーレイ・サービスのアプリケーション固有の用法を実装することです。使用法は、特定のアプリケーションは、アプリケーションがデータを取得して使用することができますどのように最終的にデータを保護する方法、データを格納するためのオーバーレイに格納することができ、何かにそのデータをマップする方法を定義します。"
    },
    {
      "indent": 3,
      "text": "The architecture diagram shows both a SIP Usage and an XMPP Usage. A single application may require multiple usages; for example, a voicemail feature in a softphone application that stores links to the messages in the overlay would require a different usage than the type of rendezvous service of XMPP or SIP. A usage may define multiple Kinds of data that are stored in the overlay and may also rely on Kinds originally defined by other usages.",
      "ja": "アーキテクチャ図は、SIPの使用とXMPPの使用の両方を示しています。単一アプリケーションは、複数の用途を必要とするかもしれません。例えば、オーバーレイ内のメッセージへのリンクを保存するソフトフォンアプリケーションでのボイスメール機能は、XMPPまたはSIPのランデブーサービスの種類とは異なる用法を必要とします。用法は、オーバーレイに格納され、また、もともと他の用途によって規定される種類に依存することができるデータの複数種類を定義することができます。"
    },
    {
      "indent": 3,
      "text": "Because the security and storage policies for each Kind are dictated by the usage defining the Kind, the usages may be coupled with the Storage component to provide security policy enforcement and to implement appropriate storage strategies according to the needs of the usage. The exact implementation of such an interface is outside the scope of this specification.",
      "ja": "各種類のセキュリティ、そしてストレージポリシーが種類を定義し、使用によって決定されるため、使用法は、セキュリティポリシーの適用を提供し、利用状況のニーズに応じて適切なストレージ戦略を実行するためにストレージ・コンポーネントと結合することができます。そのようなインタフェースの正確な実装は、本明細書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "1.2.2. Message Transport",
      "section_title": true,
      "ja": "1.2.2。メッセージトランスポート"
    },
    {
      "indent": 3,
      "text": "The Message Transport component provides a generic message routing service for the overlay. The Message Transport layer is responsible for end-to-end message transactions. Each peer is identified by its location in the overlay, as determined by its Node-ID. A component that is a client of the Message Transport can perform two basic functions:",
      "ja": "メッセージトランスポートコンポーネントは、オーバーレイのための一般的なメッセージルーティングサービスを提供します。メッセージ・トランスポート・レイヤは、エンドツーエンドのメッセージトランザクションを担当しています。そのノードIDによって決定されるように、各ピアは、オーバレイにおけるその位置によって識別されます。メッセージ交通のクライアントであるコンポーネントは、2つの基本的な機能を実行することができます。"
    },
    {
      "indent": 3,
      "text": "o Send a message to a given peer specified by Node-ID or to the peer responsible for a particular Resource-ID.",
      "ja": "OノードIDによって、または特定のリソース-IDを担当するピアに指定された指定されたピアにメッセージを送ります。"
    },
    {
      "indent": 3,
      "text": "o Receive messages that other peers sent to a Node-ID or Resource-ID for which the receiving peer is responsible.",
      "ja": "O他のピアが受信ピアが担当するノードIDまたはリソース-IDに送信されたメッセージを受信します。"
    },
    {
      "indent": 3,
      "text": "All usages rely on the Message Transport component to send and receive messages from peers. For instance, when a usage wants to store data, it does so by sending Store requests. Note that the Storage component and the Topology Plug-in are themselves clients of the Message Transport, because they need to send and receive messages from other peers.",
      "ja": "すべての用法がピアからメッセージを送受信するメッセージ・トランスポート・コンポーネントに依存しています。たとえば、ときの使用は、それがストアリクエストを送信することで、データを保存したいと考えています。彼らは他のピアからのメッセージを送受信する必要があるため、ストレージ・コンポーネントとトポロジプラグインは、自分自身のメッセージ交通のクライアントであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The Message Transport Service is responsible for end-to-end reliability, which is accomplished by timer-based retransmissions. Unlike the Internet transport layer, however, this layer does not provide congestion control. RELOAD is a request-response protocol, with no more than two pairs of request-response messages used in typical transactions between pairs of nodes; therefore, there are no opportunities to observe and react to end-to-end congestion. As with all Internet applications, implementers are strongly discouraged from writing applications that react to loss by immediately retrying the transaction.",
      "ja": "メッセージ・トランスポートサービスは、タイマーベースの再送信することによって達成されるエンドツーエンドの信頼性、責任があります。インターネット輸送層とは異なり、しかし、この層は、輻輳制御を提供していません。リロードは、ノードの対の間の典型的なトランザクションで使用要求応答メッセージの2つ以下の対と、要求 - 応答プロトコルです。そのため、エンド・ツー・エンドする輻輳を観察し、反応するいかなる機会はありません。すべてのインターネットアプリケーションと同様に、実装者は強く、すぐに再試行するトランザクションによって損失に反応するアプリケーションを書くことから落胆されています。"
    },
    {
      "indent": 3,
      "text": "The Message Transport Service is similar to those described as providing \"key-based routing\" (KBR) [wikiKBR], although as RELOAD supports different overlay algorithms (including non-DHT overlay algorithms) that calculate keys (storage indices, not encryption keys) in different ways, the actual interface needs to accept Resource Names rather than actual keys.",
      "ja": "リロードキー（ストレージ指標ではなく、暗号鍵）を計算（非DHTオーバーレイ・アルゴリズムを含む）は、異なるオーバーレイ・アルゴリズムをサポートしているがメッセージ・トランスポート・サービスは、「キーベースのルーティング」（KBR）wikiKBR]提供するものとして記載したものと同様ですさまざまな方法で、実際のインターフェースはリソース名ではなく、実際のキーを受け入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "The Forwarding and Link Management layers are responsible for maintaining the overlay in the face of changes in the available nodes and underlying network supporting the overlay (the Internet). They also handle congestion control between overlay neighbors, and exchange routing updates and data replicas in addition to forwarding end-to-end messages.",
      "ja": "転送とリンク管理層は、使用可能なノードとオーバーレイ（インターネット）をサポートする基礎となるネットワークの変化に直面してオーバーレイを維持する責任があります。彼らはまた、エンドツーエンドのメッセージの転送に加えて、オーバーレイ近隣諸国との間の輻輳制御、およびExchangeルーティングアップデートやデータの複製を処理します。"
    },
    {
      "indent": 3,
      "text": "Real-world experience has shown that a fixed timeout for the end-to-end retransmission timer is sufficient for practical overlay networks. This timer is adjustable via the overlay configuration. As the overlay configuration can be rapidly updated, this value could be dynamically adjusted at coarse time scales, although algorithms for determining how to accomplish this are beyond the scope of this specification. In many cases, however, other means of improving network performance, such as having the Topology Plug-in remove lossy links from use in overlay routing or reducing the overall hop count of end-to-end paths, will be more effective than simply increasing the retransmission timer.",
      "ja": "実世界での経験は、エンドツーエンド再送タイマの固定タイムアウトが実用的なオーバーレイネットワークのために十分であることが示されています。このタイマーは、オーバーレイの設定を介して調節可能です。オーバーレイの設定を迅速に更新することができるようにこれを達成する方法を決定するためのアルゴリズムは、本明細書の範囲外であるが、この値は、動的に、粗い時間スケールで調整することができます。しかし、多くの場合、そのようなトポロジプラグインは、オーバーレイルーティングまたはエンドツーエンドパスの全体的なホップ数を減少させるのに使用から損失性リンクを削除有するようなネットワークパフォーマンスを向上させる他の手段は、単に増加よりも効果的であろう再送タイマ。"
    },
    {
      "indent": 0,
      "text": "1.2.3. Storage",
      "section_title": true,
      "ja": "1.2.3。ストレージ"
    },
    {
      "indent": 3,
      "text": "One of the major functions of RELOAD is storage of data, that is, allowing nodes to store data in the overlay and to retrieve data stored by other nodes or by themselves. The Storage component is responsible for processing data storage and retrieval messages. For instance, the Storage component might receive a Store request for a given resource from the Message Transport. It would then query the appropriate usage before storing the data value(s) in its local data store and sending a response to the Message Transport for delivery to the requesting node. Typically, these messages will come from other nodes, but depending on the overlay topology, a node might be responsible for storing data for itself as well, especially if the overlay is small.",
      "ja": "リロードの主要な機能の一つは、ノードがオーバーレイにデータを格納するために、他のノードによって、またはそれ自体によって格納されたデータを取得することを可能にする、である、データの記憶装置です。ストレージ・コンポーネントは、データの格納と取得メッセージを処理する責任があります。例えば、ストレージ・コンポーネントは、Message交通から与えられたリソースのためのストア要求を受け取ることがあります。これは、そのローカル・データ・ストア内のデータ値（S）を格納し、要求ノードに配信するためにメッセージ・トランスポートへの応答を送信する前に、適切な使用を問い合わせることになります。典型的には、これらのメッセージは、他のノードから来るが、オーバーレイ・トポロジによって、ノードは、オーバーレイが小さい場合は特に、同様に自身のデータを格納するための責任を負うかもしれません。"
    },
    {
      "indent": 3,
      "text": "A peer's Node-ID determines the set of resources that it will be responsible for storing. However, the exact mapping between these is determined by the overlay algorithm in use. The Storage component will only receive a Store request from the Message Transport if this peer is responsible for that Resource-ID. The Storage component is notified by the Topology Plug-in when the Resource-IDs for which it is responsible change, and the Storage component is then responsible for migrating resources to other peers.",
      "ja": "ピアのノードIDは、それが保存を担当するリソースのセットを決定します。しかし、これらの間の正確なマッピングは、使用中のオーバーレイアルゴリズムによって決定されます。このピアがそのリソース-IDに責任がある場合のストレージ・コンポーネントは、メッセージ転送からのストア要求を受け取ることになります。リソース-IDは、それが責任の変更であるため、およびストレージ・コンポーネントは、他のピアにリソースを移行するための責任があるとき、ストレージ・コンポーネントは、トポロジプラグインで通知されます。"
    },
    {
      "indent": 0,
      "text": "1.2.4. Topology Plug-in",
      "section_title": true,
      "ja": "1.2.4。トポロジプラグイン"
    },
    {
      "indent": 3,
      "text": "RELOAD is explicitly designed to work with a variety of overlay algorithms. In order to facilitate this, the overlay algorithm implementation is provided by a Topology Plug-in so that each overlay can select an appropriate overlay algorithm that relies on the common RELOAD core protocols and code.",
      "ja": "RELOADは、明示的にオーバーレイの様々なアルゴリズムで動作するように設計されています。各オーバーレイは、共通RELOADコアプロトコル、コードに依存して適切なオーバーレイアルゴリズムを選択できるようにこれを容易にするために、オーバーレイ・アルゴリズムの実装は、トポロジプラグインによって提供されます。"
    },
    {
      "indent": 3,
      "text": "The Topology Plug-in is responsible for maintaining the overlay algorithm Routing Table, which is consulted by the Forwarding and Link Management Layer before routing a message. When connections are made or broken, the Forwarding and Link Management Layer notifies the Topology Plug-in, which adjusts the Routing Table as appropriate. The Topology Plug-in will also instruct the Forwarding and Link Management Layer to form new connections as dictated by the requirements of the overlay algorithm Topology. The Topology Plug-in issues periodic update requests through Message Transport to maintain and update its Routing Table.",
      "ja": "トポロジプラグインは、メッセージをルーティングする前に、転送とリンク管理レイヤから相談されたオーバーレイアルゴリズムルーティングテーブルを維持する責任があります。接続が行わまたは壊れている場合は、転送とリンク管理層は、トポロジプラグイン、適切にルーティングテーブルを調整通知します。トポロジプラグインも、オーバーレイアルゴリズムトポロジの要件によって指示されるように、新たな接続を形成するために、転送とリンク管理レイヤを指示します。トポロジのプラグインのルーティングテーブルを維持し、更新するためのメッセージ・トランスポートを介して定期的に更新要求を発行。"
    },
    {
      "indent": 3,
      "text": "As peers enter and leave, resources may be stored on different peers, so the Topology Plug-in also keeps track of which peers are responsible for which resources. As peers join and leave, the Topology Plug-in instructs the Storage component to issue resource migration requests as appropriate, in order to ensure that other peers have whatever resources they are now responsible for. The Topology Plug-in is also responsible for providing for redundant data storage to protect against loss of information in the event of a peer failure and to protect against compromised or subversive peers.",
      "ja": "ピアが出入りとして、リソースが異なるピアに格納することができるので、トポロジプラグインも、ピアがどのリソースに責任があるかを追跡します。ピアが参加したままとして、トポロジプラグインは、他のピアは、彼らが今を担当しているどんなリソースがあることを確認するために、必要に応じてリソースの移行要求を発行するストレージ・コンポーネントに指示します。トポロジプラグインはまた、ピアの障害発生時に情報の損失から保護するため、および損傷し又は破壊ピアから保護するための冗長データ記憶を提供する責任があります。"
    },
    {
      "indent": 0,
      "text": "1.2.5. Forwarding and Link Management Layer",
      "section_title": true,
      "ja": "1.2.5。転送とリンク管理レイヤ"
    },
    {
      "indent": 3,
      "text": "The Forwarding and Link Management Layer is responsible for getting a message to the next peer, as determined by the Topology Plug-in. This layer establishes and maintains the network connections as needed by the Topology Plug-in. This layer is also responsible for setting up connections to other peers through NATs and firewalls using ICE, and it can elect to forward traffic using relays for NAT and firewall traversal.",
      "ja": "転送とリンク管理層は、トポロジプラグインによって決定されるように、次のピアにメッセージを取得するための責任があります。この層は、確立し、トポロジプラグインにより、必要に応じてネットワーク接続を維持します。この層はまた、ICEを使用してNATのファイアウォールを介して他のピアへの接続を設定するための責任があり、そしてそれはNATやファイアウォール越えのためのリレーを使用してトラフィックを転送することを選択することができます。"
    },
    {
      "indent": 3,
      "text": "Congestion control is implemented at this layer to protect the Internet paths used to form the link in the overlay. Additionally, retransmission is performed to improve the reliability of end-to-end transactions. The relation of this layer to the Message Transport Layer can be likened to the relation of the link-level congestion control and retransmission in modern wireless networks ` to Internet transport protocols.",
      "ja": "輻輳制御は、オーバーレイにリンクを形成するために使用されるインターネット・パスを保護するために、この層に実装されています。また、再送信は、エンドツーエンドのトランザクションの信頼性を向上させるために行われます。メッセージトランスポート層にこの層の関係は、インターネットトランスポートプロトコルに近代的な無線ネットワークにおけるリンク・レベルの輻輳制御と再送の関係 `に例えることができます。"
    },
    {
      "indent": 3,
      "text": "This layer provides a generic interface that allows the Topology Plug-in to control the overlay and resource operations and messages. Because each overlay algorithm is defined and functions differently, we generically refer to the table of other peers that the overlay algorithm maintains and uses to route requests as a Routing Table. The Topology Plug-in actually owns the Routing Table, and forwarding decisions are made by querying the Topology Plug-in for the next hop for a particular Node-ID or Resource-ID. If this node is the destination of the message, the message is delivered to the Message Transport.",
      "ja": "この層は、トポロジプラグインがオーバーレイやリソース操作とメッセージを制御することを可能にする一般的なインタフェースを提供します。各オーバーレイアルゴリズムは異なって定義及び関数されているので、我々は、一般的にオーバーレイアルゴリズムがルーティングテーブルとしてルート要求に維持し、使用している他のピアのテーブルを参照します。トポロジプラグインは、実際には、ルーティングテーブルを所有し、転送の決定は、特定のノードIDまたはリソース-IDのための次のホップのトポロジプラグイン照会することによって行われます。このノードは、メッセージの宛先である場合、メッセージは、メッセージトランスポートに送達されます。"
    },
    {
      "indent": 3,
      "text": "This layer also utilizes a framing header to encapsulate messages as they are forwarded along each hop. This header aids reliability congestion control, flow control, etc. It has meaning only in the context of that individual link.",
      "ja": "この層はまた、それらが各ホップに沿って転送されるメッセージをカプセル化するフレーミングヘッダを利用します。それだけで、個々のリンクの文脈で意味があり、このヘッダ補助信頼輻輳制御、フロー制御、等。"
    },
    {
      "indent": 3,
      "text": "The Forwarding and Link Management Layer sits on top of the Overlay Link Layer protocols that carry the actual traffic. This specification defines how to use DTLS and TLS protocols to carry RELOAD messages.",
      "ja": "転送とリンク管理層は、実際のトラフィックを運ぶオーバーレイリンク層プロトコルの上に座っています。この仕様は、RELOADメッセージを運ぶためにDTLSとTLSプロトコルを使用する方法を定義します。"
    },
    {
      "indent": 0,
      "text": "1.3. Security",
      "section_title": true,
      "ja": "1.3。セキュリティ"
    },
    {
      "indent": 3,
      "text": "RELOAD's security model is based on each node having one or more public key certificates. In general, these certificates will be assigned by a central server, which also assigns Node-IDs, although self-signed certificates can be used in closed networks. These credentials can be leveraged to provide communications security for RELOAD messages. RELOAD provides communications security at three levels:",
      "ja": "RELOADのセキュリティモデルは、一つ以上の公開鍵証明書を持つ各ノードに基づいています。自己署名証明書が閉じたネットワークで使用することができるが、一般的に、これらの証明書は、また、ノードIDを割り当てる中央サーバによって割り当てられます。これらの資格情報は、RELOADメッセージ用の通信セキュリティを提供するために活用することができます。 RELOADは3つのレベルで通信のセキュリティを提供します。"
    },
    {
      "indent": 3,
      "text": "Connection level: Connections between nodes are secured with TLS, DTLS, or potentially some to-be-defined future protocol.",
      "ja": "接続レベル：ノード間の接続はTLS、DTLSで固定された、または潜在的将来のプロトコルには、定義されます。"
    },
    {
      "indent": 3,
      "text": "Message level: Each RELOAD message is signed.",
      "ja": "メッセージレベル：各リロードメッセージが署名されています。"
    },
    {
      "indent": 3,
      "text": "Object Level: Stored objects are signed by the creating node.",
      "ja": "オブジェクト・レベル：格納されたオブジェクトを作成ノードによって署名されます。"
    },
    {
      "indent": 3,
      "text": "These three levels of security work together to allow nodes to verify the origin and correctness of data they receive from other nodes, even in the face of malicious activity by other nodes in the overlay. RELOAD also provides access control built on top of these communications security features. Because the peer responsible for storing a piece of data can validate the signature on the data being stored, it can determine whether or not a given operation is permitted.",
      "ja": "一緒にセキュリティの仕事のこれらの3つのレベルは、ノードがオーバーレイ内の他のノードでも、悪質な行為に直面して、彼らは他のノードから受信したデータの起源と正しいかどうかを検証できるようにします。 RELOADはまた、これらの通信のセキュリティ機能の上に構築されたアクセス制御を提供します。データの一部を格納する責任ピアが格納されたデータに署名を検証することができるので、特定の操作が許可されているか否かを判断することができます。"
    },
    {
      "indent": 3,
      "text": "RELOAD also provides an optional shared-secret-based admission control feature using shared secrets and TLS pre-shared keys (PSK) or TLS Secure Remote Password (SRP). In order to form a TLS connection to any node in the overlay, a new node needs to know the shared overlay key, thus restricting access to authorized users only. This feature is used together with certificate-based access control, not as a replacement for it. It is typically used when self-signed certificates are being used but would generally not be used when the certificates were all signed by an enrollment server.",
      "ja": "リモート・パスワード（SRP）を確保共有秘密とTLS事前共有鍵（PSK）を使用して、オプションの共有秘密ベースのアドミッション制御機能を提供するか、TLSもリロードします。オーバーレイ内の任意のノードへのTLS接続を形成するためには、新しいノードは、このように許可されたユーザーのみにアクセスを制限する、共有オーバーレイキーを知る必要があります。この機能はありません、それに代わるものとして、証明書ベースのアクセスコントロールと一緒に使用されています。これは、自己署名証明書を使用している際に一般的に使用されますが、証明書はすべての登録サーバによって署名された際に一般的に使用されないであろう。"
    },
    {
      "indent": 0,
      "text": "1.4. Structure of This Document",
      "section_title": true,
      "ja": "1.4。このドキュメントの構造"
    },
    {
      "indent": 3,
      "text": "The remainder of this document is structured as follows.",
      "ja": "次のように、この文書の残りの部分は構成されています。"
    },
    {
      "indent": 3,
      "text": "o Section 3 provides definitions of terms used in this document.",
      "ja": "O第3節では、本書で使用される用語の定義を提供します。"
    },
    {
      "indent": 3,
      "text": "o Section 4 provides an overview of the mechanisms used to establish and maintain the overlay.",
      "ja": "O部4は、オーバーレイを確立し、維持するために使用されるメカニズムの概要を提供します。"
    },
    {
      "indent": 3,
      "text": "o Section 5 provides an overview of the mechanism RELOAD provides to support other applications.",
      "ja": "O第5節では、RELOADは、他のアプリケーションをサポートするために提供メカニズムの概要を説明します。"
    },
    {
      "indent": 3,
      "text": "o Section 6 defines the protocol messages that RELOAD uses to establish and maintain the overlay.",
      "ja": "O部6は、リロードがオーバーレイを確立し、維持するために使用するプロトコルのメッセージを定義します。"
    },
    {
      "indent": 3,
      "text": "o Section 7 defines the protocol messages that are used to store and retrieve data using RELOAD.",
      "ja": "O部7は、リロードを使用してデータを格納および検索するために使用されたプロトコルメッセージを定義します。"
    },
    {
      "indent": 3,
      "text": "o Section 8 defines the Certificate Store Usages.",
      "ja": "O部8には、証明書ストアの用途を定義します。"
    },
    {
      "indent": 3,
      "text": "o Section 9 defines the TURN Server Usage needed to locate TURN (Traversal Using Relays around NAT) servers for NAT traversal.",
      "ja": "O部9は、NATトラバーサルのために（トラバーサルがNATの周りにリレーを使用して）サーバをTURNを見つけるために必要なTURNサーバーの使用法を定義します。"
    },
    {
      "indent": 3,
      "text": "o Section 10 defines a specific Topology Plug-in using a Chord-based algorithm.",
      "ja": "O部10は、特定のトポロジプラグインを定義するコードベースのアルゴリズムを使用して。"
    },
    {
      "indent": 3,
      "text": "o Section 11 defines the mechanisms that new RELOAD nodes use to join the overlay for the first time.",
      "ja": "O部11は、新たなリロードノードが初めてオーバーレイを結合するために使用するメカニズムを定義します。"
    },
    {
      "indent": 3,
      "text": "o Section 12 provides an extended example.",
      "ja": "O部12は、拡張された例を提供します。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Language",
      "section_title": true,
      "ja": "2.必要な言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3.用語"
    },
    {
      "indent": 3,
      "text": "Terms in this document are defined in-line when used and are also defined below for reference. The definitions in this section use terminology and concepts that are not explained until later in the specification.",
      "ja": "この文書に記載されている用語を使用するときにインライン定義され、また、参考のために以下に定義されています。このセクションの定義は後明細書にまで説明されていない用語や概念を使用します。"
    },
    {
      "indent": 3,
      "text": "Admitting Peer (AP): A peer in the overlay which helps the Joining Node join the Overlay.",
      "ja": "参加するノードがオーバーレイに参加役立つオーバーレイ内のピア：ピア（AP）を認めます。"
    },
    {
      "indent": 3,
      "text": "Bootstrap Node: A network node used by Joining Nodes to help locate the Admitting Peer.",
      "ja": "ブートストラップノード：認めるピアを見つけやすくするためにノードの参加が使用するネットワークノード。"
    },
    {
      "indent": 3,
      "text": "Client: A host that is able to store data in and retrieve data from the overlay, but does not participate in routing or data storage for the overlay.",
      "ja": "クライアント：にデータを格納し、オーバーレイからデータを取得することができますが、オーバーレイのためのルーティングやデータストレージに参加していないホスト。"
    },
    {
      "indent": 3,
      "text": "Configuration Document: An XML document containing all the Overlay Parameters for one overlay instance.",
      "ja": "設定文書：1つのオーバーレイインスタンスのすべてのオーバーレイパラメータを含むXML文書。"
    },
    {
      "indent": 3,
      "text": "Connection Table: Contains connection information for the set of nodes to which a node is directly connected, which include nodes that are not yet available for routing.",
      "ja": "接続テーブルは：まだルーティングのために利用できないノードを含むノードが直接接続されたノードのセットの接続情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "Destination List: A list of Node-IDs, Resource-IDs, and Opaque IDs through which a message is to be routed, in strict order. A single Node-ID, Resource-ID, or Opaque ID is a trivial form of Destination List. When multiple Node-IDs are specified, a Destination List is a loose source route. The list is reduced hop by hop, and does not include the source but does include the destination.",
      "ja": "宛先リスト：メッセージは、厳密な順序で、ルーティングされる、それを通してノードIDは、リソース-ID、および不透明IDのリスト。単一ノードID、リソース-ID、または不透明なIDは、宛先リストの些細な形です。複数のノードのIDが指定されている場合は、送信先リストには、ルーズソースルートです。リストには、ホップでホップを低減し、かつソースが含まれていませんが、先が含まれません。"
    },
    {
      "indent": 3,
      "text": "DHT: A distributed hash table. A DHT is an abstract storage service realized by storing the contents of the hash table across a set of peers.",
      "ja": "DHT：分散ハッシュテーブル。 DHTは、ピアのセットにわたってハッシュテーブルの内容を格納することによって実現する抽象ストレージサービスです。"
    },
    {
      "indent": 3,
      "text": "ID: A generic term for any kind of identifiers in an Overlay. This document specifies an ID as being an Application-ID, a Kind-ID, a Node-ID, a transaction ID, a component ID, a response ID, a Resource-ID, or an Opaque ID.",
      "ja": "ID：オーバーレイ中の識別子のいずれかの種類の総称。この文書は、アプリケーションID、種類-ID、ノードID、トランザクションID、部品ID、応答ID、リソース-ID、または不透明なIDであるとIDを指定します。"
    },
    {
      "indent": 3,
      "text": "Joining Node (JN): A node that is attempting to become a peer in a particular Overlay.",
      "ja": "特定のオーバーレイ内のピアになることを試みているノード：ノード（IN）を接合。"
    },
    {
      "indent": 3,
      "text": "Kind: A Kind defines a particular type of data that can be stored in the overlay. Applications define new Kinds to store the data they use. Each Kind is identified with a unique integer called a Kind-ID.",
      "ja": "種類：種類は、オーバーレイに格納できるデータの特定のタイプを定義します。アプリケーションは、彼らが使用するデータを格納するための新しい種類を定義します。各種類は、種類-IDと呼ばれる固有の整数で識別されます。"
    },
    {
      "indent": 3,
      "text": "Kind-ID: A unique 32-bit value identifying a Kind. Kind-IDs are either private or allocated by IANA (see Section 14.6).",
      "ja": "種類-ID：種類を識別する一意の32ビット値。種類-IDは、プライベートまたはIANA（14.6節を参照）によって割り当てられたいずれかです。"
    },
    {
      "indent": 3,
      "text": "Maximum Request Lifetime: The maximum time a request will wait for a response. This value is equal to the value of the overlay reliability value (defined in Section 11.1) multiplied by the number of transmissions (defined in Section 6.2.1), and so defaults to 15 seconds.",
      "ja": "最大要求の有効期間：要求が応答を待つ最大時間。この値は、（セクション6.2.1で定義された）送信の数を乗じた（セクション11.1で定義された）オーバーレイ信頼度の値に等しく、15秒そうデフォルト。"
    },
    {
      "indent": 3,
      "text": "Node: The term \"node\" refers to a host that may be either a peer or a client. Because RELOAD uses the same protocol for both clients and peers, much of the text applies equally to both. Therefore, we use \"node\" when the text applies to both clients and peers, and we use the more specific term (i.e., \"client\" or \"peer\") when the text applies only to clients or only to peers.",
      "ja": "ノード：用語「ノード」は、ピアまたはクライアントのいずれかとすることができるホストを指します。 RELOADは、クライアントとピアの両方で同じプロトコルを使用しているため、テキストの多くは両方にも同様に適用されます。したがって、テキストは、クライアント及びピアの両方に適用されたときに、我々は、「ノード」を使用し、テキストのみをクライアントにのみピアに適用されたときに、我々は、より具体的な用語（すなわち、「クライアント」または「ピア」）を使用します。"
    },
    {
      "indent": 3,
      "text": "Node-ID: A value of fixed but configurable length that uniquely identifies a node. Node-IDs of all 0s and all 1s are reserved. A value of 0 is not used in the wire protocol, but can be used to indicate an invalid node in implementations and APIs. The Node-ID of all 1s is used on the wire protocol as a wildcard.",
      "ja": "ノードID：一意のノードを識別する固定の値が、設定可能な長さ。すべて0とすべて1のノードIDが予約されています。 0の値は、ワイヤプロトコルで使用されていないが、実装およびAPIに無効なノードを示すために使用することができます。すべて1のノードIDは、ワイルドカードとしてワイヤプロトコルに使用されます。"
    },
    {
      "indent": 3,
      "text": "Overlay Algorithm: An overlay algorithm defines the rules for determining which peers in an overlay store a particular piece of data and for determining a topology of interconnections amongst peers in order to find a piece of data.",
      "ja": "オーバーレイアルゴリズム：オーバーレイ・アルゴリズムは、オーバーレイ内のピアは、特定のデータを格納するかを決定するために、データの一部を見つけるためにピア間の相互接続のトポロジーを決定するための規則を定義します。"
    },
    {
      "indent": 3,
      "text": "Overlay Instance: A specific overlay algorithm and the collection of peers that are collaborating to provide read and write access to it. Any number of overlay instances can be running in an IP network at a time, and each operates in isolation of the others.",
      "ja": "オーバーレイインスタンス：特定のオーバーレイアルゴリズムと読んで、それへの書き込みアクセスを提供するために協力している仲間の集まり。オーバーレイインスタンスの任意の数は、一度に、IPネットワークで実行することができ、それぞれが他の分離で動作します。"
    },
    {
      "indent": 3,
      "text": "Overlay Parameters: A set of values that are shared among all nodes in an overlay. The overlay parameters are distributed in an XML document called the Configuration Document.",
      "ja": "オーバーレイパラメータ：オーバレイ内のすべてのノード間で共有されている値のセット。オーバーレイパラメータを設定文書と呼ばれるXML文書で配布されています。"
    },
    {
      "indent": 3,
      "text": "Peer: A host that is participating in the overlay. Peers are responsible for holding some portion of the data that has been stored in the overlay, and they are responsible for routing messages on behalf of other hosts as needed by the Overlay Algorithm.",
      "ja": "ピア：オーバーレイに参加しているホスト。ピアは、オーバーレイに格納されたデータの一部を保持するための責任がある、と彼らはオーバーレイアルゴリズムにより、必要に応じて他のホストの代わりにメッセージをルーティングする責任があります。"
    },
    {
      "indent": 3,
      "text": "Peer Admission: The act of admitting a node (the Joining Node) into an Overlay. After the admission process is over, the Joining Node is a fully functional peer of the overlay. During the admission process, the Joining Node may need to present credentials to prove that it has sufficient authority to join the overlay.",
      "ja": "ピア入場​​：オーバーレイ内のノード（参加するノード）を認める行為。入場処理が終わった後、参加するノードは、オーバーレイの完全に機能するピアです。入学プロセス中、参加ノードは、それがオーバーレイに参加するための十分な権限を持っていることを証明するための資格情報を提示する必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Resource: An object or group of objects stored in a P2P network.",
      "ja": "リソース：P2Pネットワークに格納されたオブジェクトまたはオブジェクトのグループ。"
    },
    {
      "indent": 3,
      "text": "Resource-ID: A value that identifies some resources and which is used as a key for storing and retrieving the resource. Often this is not human friendly/readable. One way to generate a Resource-ID is by applying a mapping function to some other unique name (e.g., user name or service name) for the resource. The Resource-ID is used by the distributed database algorithm to determine the peer or peers that are responsible for storing the data for the overlay. In structured P2P networks, Resource-IDs are generally fixed length and are formed by hashing the Resource Name. In unstructured networks, Resource Names may be used directly as Resource-IDs and may be of variable length.",
      "ja": "リソースID：いくつかのリソースを識別する値とどのは、リソースを保存し、検索するためのキーとして使用されます。多くの場合、これは、読み出し/優しい人間ではありません。リソース-IDを生成するための一つの方法は、リソースのためのいくつかの他の一意の名前（例えば、ユーザ名、またはサービス名）にマッピング関数を適用することによってです。リソース-IDは、オーバーレイのためのデータを格納するための責任があるピアまたはピアを決定するために、分散データベース・アルゴリズムによって使用されます。構造化P2Pネットワークでは、リソース-IDは、一般的に長さが固定されており、リソース名をハッシュすることによって形成されています。構造化されていないネットワークでは、リソース名は、リソースIDとして直接使用することができる可変長であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Resource Name: The name by which a resource is identified. In unstructured P2P networks, the Resource Name is sometimes used directly as a Resource-ID. In structured P2P networks, the Resource Name is typically mapped into a Resource-ID by using the string as the input to hash function. Structured and unstructured P2P networks are described in [RFC5694]. A SIP resource, for example, is often identified by its AOR (address-of-record), which is an example of a Resource Name.",
      "ja": "リソース名：リソースを識別するための名前。非構造化P2Pネットワークでは、リソース名は、時々、リソース-IDとして直接使用されます。構造化P2Pネットワークでは、リソース名は、典型的には、関数をハッシュするために、入力として文字列を使用して、リソース-IDにマッピングされます。構造化および非構造化P2Pネットワークは、[RFC5694]に記載されています。 SIPリソースは、例えば、多くの場合、リソース名の例であり、そのAOR（アドレス・オブ・レコード）によって識別されます。"
    },
    {
      "indent": 3,
      "text": "Responsible Peer: The peer that is responsible for a specific resource, as defined by the Topology Plug-in algorithm.",
      "ja": "責任ピア：トポロジプラグインアルゴリズムによって定義されるように、特定のリソースを担当するピア。"
    },
    {
      "indent": 3,
      "text": "Routing Table: The set of directly connected peers which a node can use to forward overlay messages. In normal operation, these peers will all be in the Connection Table, but not vice versa, because some peers may not yet be available for routing. Peers may send messages directly to peers that are in their Connection Tables, but may forward messages to peers that are not in their Connection Table only through peers that are in the Routing Table.",
      "ja": "ルーティングテーブル：ノードはオーバーレイメッセージを転送するために使用することができ、直接接続されたピアのセット。いくつかのピアがまだルーティングのために利用可能ではないかもしれないので、通常の動作では、これらのピアは、全てではなく、その逆、接続テーブルであろう。ピアはその接続テーブルにあるピアに直接メッセージを送ることが、唯一のルーティングテーブルにあるピアを通じて接続テーブルにないピアにメッセージを転送することができます。"
    },
    {
      "indent": 3,
      "text": "Successor Replacement Hold-Down Time: The amount of time to wait before starting replication when a new successor is found; it defaults to 30 seconds.",
      "ja": "後継交換ホールドダウンタイム：新しい後継者が発見された場合、レプリケーションを開始するまでの待機時間。それは30秒にデフォルト設定されています。"
    },
    {
      "indent": 3,
      "text": "Transaction ID: A randomly chosen identifier selected by the originator of a request that is used to correlate requests and responses.",
      "ja": "トランザクションID：要求と応答を相関させるために使用される要求の発信者によって選択されたランダムに選択された識別子。"
    },
    {
      "indent": 3,
      "text": "Usage: The definition of a set of data structures (data Kinds) that an application wants to store in the overlay. A usage may also define a set of network protocols (Application IDs) that can be tunneled over TLS or DTLS direct connections between nodes. For example, the SIP Usage defines a SIP registration data Kind, which contains information on how to reach a SIP endpoint, and two Application IDs corresponding to the SIP and SIPS protocols.",
      "ja": "使用法：アプリケーションがオーバーレイに保存したいデータ構造（データ種類）のセットの定義。用法はまた、ノード間のTLSまたはDTLS直接接続を介してトンネリングすることができるネットワークプロトコル（アプリケーションのID）のセットを定義することができます。例えば、SIPの使用は、SIPエンドポイントに到達する方法についての情報が含まSIP登録データの種類を定義し、SIPに対応する2つのアプリケーションIDおよびプロトコルをSIPS。"
    },
    {
      "indent": 3,
      "text": "User: A physical person identified by the certificates assigned to them.",
      "ja": "ユーザー：自分に割り当てられた証明書によって識別される物理人物。"
    },
    {
      "indent": 3,
      "text": "User Name: A name identifying a user of the overlay, typically used as a Resource Name or as a label on a resource that identifies the user owning the resource.",
      "ja": "ユーザ名：一般的にリソース名として、またはリソースを所有するユーザを識別するリソース上のラベルとして使用されるオーバーレイのユーザを識別する名前。"
    },
    {
      "indent": 0,
      "text": "4. Overlay Management Overview",
      "section_title": true,
      "ja": "4.オーバーレイ管理の概要"
    },
    {
      "indent": 3,
      "text": "The most basic function of RELOAD is as a generic overlay network. Nodes need to be able to join the overlay, form connections to other nodes, and route messages through the overlay to nodes to which they are not directly connected. This section provides an overview of the mechanisms that perform these functions.",
      "ja": "RELOADの最も基本的な機能は、一般的なオーバーレイネットワークとしてあります。ノードは、それらが直接接続されていないためにノードにオーバーレイを介してオーバーレイ、他のノードへのフォームの接続、およびルーティングメッセージに参加できるようにする必要があります。このセクションでは、これらの機能を実行するメカニズムの概要を提供します。"
    },
    {
      "indent": 0,
      "text": "4.1. Security and Identification",
      "section_title": true,
      "ja": "4.1。セキュリティと識別"
    },
    {
      "indent": 3,
      "text": "The overlay parameters are specified in a Configuration Document. Because the parameters include security-critical information, such as the certificate signing trust anchors, the Configuration Document needs to be retrieved securely. The initial Configuration Document is either initially fetched over HTTPS or manually provisioned. Subsequent Configuration Document updates are received either as a result of being refreshed periodically by the configuration server, or, more commonly, by being flood-filled through the overlay, which allows for fast propagation once an update is pushed. In the latter case, updates are via digital signatures that trace back to the initial Configuration Document.",
      "ja": "オーバーレイパラメータを設定文書で指定されています。パラメータは、このような証明書の署名信頼アンカーとしてセキュリティ上重要な情報が含まれているため、構成ドキュメントを安全に取得する必要があります。初期設定文書は、最初はHTTPS経由で取得するか、手動でプロビジョニングのどちらかです。後続の構成ドキュメントの更新は、いずれかの更新が押されると、高速増殖を可能にオーバーレイを介してフラッド充填されることによって、より一般的には、コンフィギュレーション・サーバによって定期的にリフレッシュ、またはされた結果として受信されます。後者の場合、更新は初期設定文書に遡るデジタル署名を介してです。"
    },
    {
      "indent": 3,
      "text": "Every node in the RELOAD overlay is identified by a Node-ID. The Node-ID is used for three major purposes:",
      "ja": "RELOADオーバーレイ内のすべてのノードは、ノードIDで識別されます。ノードIDは、三つの主要な目的のために使用されます。"
    },
    {
      "indent": 3,
      "text": "o To address the node itself.",
      "ja": "oはノード自体に対処するために。"
    },
    {
      "indent": 3,
      "text": "o To determine the node's position in the overlay topology (if the overlay is structured; overlays do not need to be structured).",
      "ja": "オーバーレイ・トポロジ内のノードの位置を決定するために、O（オーバーレイが構成されている場合は、オーバーレイを構造化する必要はありません）。"
    },
    {
      "indent": 3,
      "text": "o To determine the set of resources for which the node is responsible.",
      "ja": "oは、ノードが担当するリソースのセットを決定するには。"
    },
    {
      "indent": 3,
      "text": "Each node has a certificate [RFC5280] containing its Node-ID in a subjectAltName extension, which is unique within an overlay instance.",
      "ja": "各ノードは、オーバーレイ・インスタンス内で一意であるsubjectAltName拡張にそのノードIDを含む証明書[RFC5280]を有します。"
    },
    {
      "indent": 3,
      "text": "The certificate serves multiple purposes:",
      "ja": "証明書は、複数の目的を果たします："
    },
    {
      "indent": 3,
      "text": "o It entitles the user to store data at specific locations in the Overlay Instance. Each data Kind defines the specific rules for determining which certificates can access each Resource-ID/Kind-ID pair. For instance, some Kinds might allow anyone to write at a given location, whereas others might restrict writes to the owner of a single certificate.",
      "ja": "Oそれはオーバーレイインスタンス内の特定の場所にデータを保存するために、ユーザー資格を与えます。各データ種類は、各リソース-ID /種類-IDのペアにアクセスすることができる証明書を決定するための特定の規則を定義します。例えば、いくつかの種類は、他の人が単一の証明書の所有者への書き込みを制限する可能性がある一方で、誰もが、与えられた場所に書き込むことができる場合があります。"
    },
    {
      "indent": 3,
      "text": "o It entitles the user to operate a node that has a Node-ID found in the certificate. When the node forms a connection to another peer, it uses this certificate so that a node connecting to it knows it is connected to the correct node. (Technically, a TLS or DTLS association with client authentication is formed.) In addition, the node can sign messages, thus providing integrity and authentication for messages which are sent from the node.",
      "ja": "Oそれは、証明書に見出されるノードIDを有するノードを操作するユーザが権利を与え。ノードが別のピアへの接続を形成する場合、それに接続するノードは、それが正しいノードに接続されている知っているように、この証明書を使用します。 （技術的には、クライアント認証を有するTLSまたはDTLS関連付けが形成されている。）また、ノードは、このように、ノードから送信されるメッセージの完全性及び認証を提供する、メッセージに署名することができます。"
    },
    {
      "indent": 3,
      "text": "o It entitles the user to use the user name found in the certificate.",
      "ja": "Oそれは証明書で見つかったユーザー名を使用するユーザー資格を与えます。"
    },
    {
      "indent": 3,
      "text": "If a user has more than one device, typically they would get one certificate for each device. This allows each device to act as a separate peer.",
      "ja": "ユーザーが複数のデバイスを持っている場合は、通常、彼らは各デバイスの証明書を1つになるだろう。これは、各装置が別個のピアとして動作することを可能にします。"
    },
    {
      "indent": 3,
      "text": "RELOAD supports multiple certificate issuance models. The first is based on a central enrollment process, which allocates a unique name and Node-ID and puts them in a certificate for the user. All peers in a particular Overlay Instance have the enrollment server as a trust anchor and so can verify any other peer's certificate.",
      "ja": "RELOADは、複数の証明書発行のモデルをサポートしています。最初は、一意の名前とノードIDを割り当て、ユーザーの証明書でそれらを置く中央の登録プロセスに基づいています。特にオーバーレイインスタンスのすべてのピアは、トラストアンカーとして登録サーバーを持っているので、他のピアの証明書を確認することができます。"
    },
    {
      "indent": 3,
      "text": "The second model is useful in settings, when a group of users want to set up an overlay network but are not concerned about attack by other users in the network. For instance, users on a LAN might want to set up a short-term ad hoc network without going to the trouble of setting up an enrollment server. RELOAD supports the use of self-generated, self-signed certificates. When self-signed certificates are used, the node also generates its own Node-ID and user name. The Node-ID is computed as a digest of the public key, to prevent Node-ID theft. Note that the relevant cryptographic property for the digest is partial preimage resistance. Collision resistance is not needed, because an attacker who can create two nodes with the same Node-ID but a different public key obtains no advantage. This model is still subject to a number of known attacks (most notably, Sybil attacks [Sybil]) and can be safely used only in closed networks where users are mutually trusting. Another drawback of this approach is that the user's data is then tied to their key, so if a key is changed, any data stored under their Node-ID needs to be re-stored. This is not an issue for centrally issued Node-IDs provided that the Certification Authority (CA) reissues the same Node-ID when a new certificate is generated.",
      "ja": "ユーザーのグループは、オーバーレイネットワークを設定したいが、ネットワーク内の他のユーザーによる攻撃を懸念していないときに、第2のモデルは、設定に有用です。たとえば、LAN上のユーザは、登録サーバーをセットアップのトラブルに行かずにアドホックネットワークの短期を設定することもできます。 RELOADは自己生成、自己署名証明書の使用をサポートしています。自己署名証明書が使用される場合、ノードは、自身のノードID及びユーザ名を生成します。ノードIDは、ノードIDの盗難を防止するために、公開鍵のダイジェストとして計算されます。ダイジェストに関連する暗号化プロパティは、部分的なプリイメージ抵抗であることに注意してください。同じノードIDを持つ2つのノードを作成しますが、異なる公開鍵は何の利点を得ることができない攻撃者ので、衝突抵抗は、必要とされていません。このモデルは、依然として既知の攻撃（特に、シビル攻撃[シビル]）の数の対象であり、安全にのみ、ユーザーが互いに信頼している閉じたネットワークで使用することができます。キーが変更されるので、もしこのアプローチの別の欠点は、ユーザーのデータは、その後、そのキーに結び付けられていることを、自分のノードIDの下で保存されたデータを再保存する必要があります。これは、新しい証明書が生成されると、証明機関（CA）が同じノードIDを再発行することを提供一元発行ノードIDの問題ではありません。"
    },
    {
      "indent": 3,
      "text": "The general principle here is that the security mechanisms (TLS or DTLS at the data link layer and message signatures at the message transport layer) are always used, even if the certificates are self-signed. This allows for a single set of code paths in the systems, with the only difference being whether certificate verification is used to chain to a single root of trust.",
      "ja": "ここで一般的な原理は、証明書は自己署名された場合でも、セキュリティ・メカニズム（メッセージのトランスポート層のデータリンク層及びメッセージ署名でTLSまたはDTLS）が常に使用されるということです。これは、唯一の違いは、証明書の検証は、信頼の単一ルートにチェーンに使用されているかどうかであると、システム内のコードパスの単一のセットを可能にします。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Shared-Key Security",
      "section_title": true,
      "ja": "4.1.1。共有鍵セキュリティ"
    },
    {
      "indent": 3,
      "text": "RELOAD also provides an admission control system based on shared keys. In this model, the peers all share a single key which is used to authenticate the peer-to-peer connections via TLS-PSK [RFC4279] or TLS-SRP [RFC5054].",
      "ja": "リロードは、共有鍵に基づいてアドミッション制御システムを提供します。 TLS-PSK [RFC4279]またはTLS-SRP [RFC5054]を介してピア・ツー・ピア接続を認証するために使用され、このモデルにおいて、ピアすべての共有単一のキー。"
    },
    {
      "indent": 0,
      "text": "4.2. Clients",
      "section_title": true,
      "ja": "4.2。クライアント"
    },
    {
      "indent": 3,
      "text": "RELOAD defines a single protocol that is used both as the peer protocol and as the client protocol for the overlay. Having a single protocol simplifies implementation, particularly for devices that may act in either role, and allows clients to inject messages directly into the overlay.",
      "ja": "リロードピアプロトコルとして、およびオーバーレイのクライアントプロトコルの両方として使用される単一のプロトコルを定義します。単一のプロトコルを有することは、特にいずれかの役割で作用することができる装置のために、実装を簡素化し、そしてクライアントがオーバーレイに直接メッセージを注入することを可能にします。"
    },
    {
      "indent": 3,
      "text": "We use the term \"peer\" to identify a node in the overlay that routes messages for nodes other than those to which it is directly connected. Peers also have storage responsibilities. We use the term \"client\" to refer to nodes that do not have routing or storage responsibilities. When text applies to both peers and clients, we will simply refer to such devices as \"nodes\".",
      "ja": "我々は、それが直接接続されているもの以外の他のノードのルートメッセージことオーバーレイ内のノードを識別するために、用語「ピア」を使用します。ピアは、ストレージの責任を持っています。私たちは、ルーティングやストレージの責任を持たないノードを参照するために、「クライアント」という用語を使用します。テキストは、ピアとクライアントの両方に適用された場合、我々は単に「ノード」などのデバイスを指します。"
    },
    {
      "indent": 3,
      "text": "RELOAD's client support allows nodes that are not participating in the overlay as peers to utilize the same implementation and to benefit from the same security mechanisms as the peers. Clients possess and use certificates that authorize the user to store data at certain locations in the overlay. The Node-ID in the certificate is used to identify the particular client as a member of the overlay and to authenticate its messages.",
      "ja": "RELOADのクライアントサポートはピアとしてオーバーレイに参加していないノードが同じ実装を利用すると、ピアと同じセキュリティ・メカニズムの恩恵を受けることができます。クライアントは、オーバーレイ内の特定の場所にデータを保存するために、ユーザーを認証する証明書を所有し、使用しています。証明書内のノードIDは、オーバーレイのメンバとして特定のクライアントを識別し、そのメッセージを認証するために使用されます。"
    },
    {
      "indent": 3,
      "text": "In RELOAD, unlike some other designs, clients are not first-class entities. From the perspective of a peer, a client is a node that has connected to the overlay, but that has not yet taken steps to insert itself into the overlay topology. It might never do so (if it's a client), or it might eventually do so (if it's just a node that is taking a long time to join). The routing and storage rules for RELOAD provide for correct behavior by peers regardless of whether other nodes attached to them are clients or peers. Of course, a client implementation needs to know that it intends to be a client, but this localizes complexity only to that node.",
      "ja": "RELOADでは、いくつかの他のデザインとは異なり、クライアントは、ファーストクラスのエンティティではありません。ピアの観点から、クライアントは、オーバーレイに接続されたノードであり、それはまだオーバーレイ・トポロジに自身を挿入するための措置を講じていません。それは（それがクライアントの場合）ので、決してしないかもしれない、またはそれは最終的に（それが参加するのに長い時間がかかっているだけのノードの場合）そうかもしれません。リロードのルーティングおよびストレージ・ルールに関係なく、それらに取り付けられた他のノードがクライアントまたはピアであるかどうかのピアによって正しい動作を提供します。もちろん、クライアントの実装は、それがクライアントになろうとすることを知っている必要がありますが、これはそのノードのみを複雑に局在化します。"
    },
    {
      "indent": 3,
      "text": "For more discussion about the motivation for RELOAD's client support, see Appendix B.",
      "ja": "RELOADのクライアントをサポートするためのモチベーションについての詳細な議論については、付録Bを参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Client Routing",
      "section_title": true,
      "ja": "4.2.1。クライアントのルーティング"
    },
    {
      "indent": 3,
      "text": "Clients may insert themselves in the overlay in two ways:",
      "ja": "クライアントは、2つの方法でオーバーレイで自分自身を挿入することがあります。"
    },
    {
      "indent": 3,
      "text": "o Establish a connection to the peer responsible for the client's Node-ID in the overlay. Then, requests may be sent from/to the client using its Node-ID in the same manner as if it were a peer, because the responsible peer in the overlay will handle the final step of routing to the client. This may require a TURN [RFC5766] relay in cases where NATs or firewalls prevent a client from forming a direct connection with its responsible peer. Note that clients that choose this option need to process Update messages from the peer (Section 6.4.2.3). These updates can indicate that the peer is no longer responsible for the client's Node-ID. The client would then need to form a connection to the appropriate peer. Failure to do so will result in the client no longer receiving messages.",
      "ja": "Oオーバーレイで、クライアントのノードIDを担当するピアへの接続を確立します。オーバーレイに責任ピアはクライアントへのルーティングの最終ステップを処理するため、次に、要求は、それがピアであるかのように同じ方法で、そのノードIDを使用して、クライアントへ/から送信されても​​よいです。これは、のNATまたはファイアウォールがその責任ピアとの直接接続を形成することからクライアントを防ぐ場合にTURN [RFC5766]中継を必要とするかもしれません。このオプションを選択し、クライアントがピア（セクション6.4.2.3）からの更新メッセージを処理する必要があることに注意してください。これらのアップデートは、ピアは、もはやクライアントのノードIDの責任であることを示すことはできません。クライアントは、適切なピアへの接続を形成する必要があります。そうしないと、メッセージを受信しなくなったクライアントになりません。"
    },
    {
      "indent": 3,
      "text": "o Establish a connection with an arbitrary peer in the overlay (perhaps based on network proximity or an inability to establish a direct connection with the responsible peer). In this case, the client will rely on RELOAD's Destination List feature (Section 6.3.2.2) to ensure reachability. The client can initiate requests, and any node in the overlay that knows the Destination List to its current location can reach it, but the client is not directly reachable using only its Node-ID. If the client is to receive incoming requests from other members of the overlay, the Destination List needed to reach the client needs to be learnable via other mechanisms, such as being stored in the overlay by a usage. A client connected this way using a certificate with only a single Node-ID can proceed to use the connection without performing an Attach (Section 6.5.1). A client wishing to connect using this mechanism with a certificate with multiple Node-IDs can use a Ping (Section 6.5.3) to probe the Node-ID of the node to which it is connected before performing the Attach.",
      "ja": "O（おそらくネットワーク近接又は責任ピアと直接接続を確立できないことに基づいて）オーバーレイの任意のピアとの接続を確立します。この場合、クライアントは、到達可能性を確保するために、RELOADの送信先リスト機能（6.3.2.2項）に依存しています。クライアントが要求を開始することができ、かつ、現在の場所に宛先リストを知っているオーバーレイ内の任意のノードは、それに到達することができますが、クライアントはそのノードIDを使用して、直接到達できません。クライアントは、オーバーレイの他のメンバーからの着信要求を受信する場合は、クライアントに到達するために必要な宛先リストは、このような使用によってオーバーレイに格納されているなど、他のメカニズムを介して学習可能である必要があります。クライアント（セクション6.5.1）に取り付け行うことなく接続を使用するように進むことができ、単一のノードIDと証明書を使用して、このように接続されています。ノードのノードIDをプローブするためのPing（セクション6.5.3）を使用することができ、複数のノードIDを持つ証明書を使用してこのメ​​カニズムを使用して接続することを望むクライアントは、それが取り付け行う前に接続されます。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Minimum Functionality Requirements for Clients",
      "section_title": true,
      "ja": "4.2.2。クライアントの最小機能要件"
    },
    {
      "indent": 3,
      "text": "A node may act as a client simply because it does not have the capacity or need to act as a peer in the overlay, or because it does not even have an implementation of the Topology Plug-in defined in Section 6.4.1, needed to act as a peer in the overlay. In order to exchange RELOAD messages with a peer, a client needs to meet a minimum level of functionality. Such a client will:",
      "ja": "ノードは、それが能力を持っているか、オーバーレイ内のピアとして機能する必要はありませんという理由だけで、クライアントとして動作することができる、またはそれもトポロジプラグインに必要な6.4.1項で定義されているの実装を持っていないため、オーバーレイ内のピアとして動作します。ピアとRELOADメッセージを交換するためには、クライアントは、機能の最小レベルを満たしている必要があります。このようなクライアントは以下となります。"
    },
    {
      "indent": 3,
      "text": "o Implement RELOAD's connection-management operations that are used to establish the connection with the peer.",
      "ja": "Oピアとの接続を確立するために使用されているRELOADの接続管理操作を実装します。"
    },
    {
      "indent": 3,
      "text": "o Implement RELOAD's data retrieval methods (with client functionality).",
      "ja": "O（クライアント機能付き）RELOADのデータ検索メソッドを実装します。"
    },
    {
      "indent": 3,
      "text": "o Be able to calculate Resource-IDs used by the overlay.",
      "ja": "Oオーバーレイで使用される資源のIDを計算することができます。"
    },
    {
      "indent": 3,
      "text": "o Possess security credentials needed by the overlay that it is implementing.",
      "ja": "Oそれが実装されるオーバーレイで必要なセキュリティ資格情報を持っています。"
    },
    {
      "indent": 3,
      "text": "A client speaks the same protocol as the peers, knows how to calculate Resource-IDs, and signs its requests in the same manner as peers. While a client does not necessarily require a full implementation of the overlay algorithm, calculating the Resource-ID requires an implementation of an appropriate algorithm for the overlay.",
      "ja": "クライアントは、ピアと同じプロトコルを話す資源のIDを計算する方法を知っている、とピアと同様にその要求に署名します。クライアントは必ずしもオーバーレイアルゴリズムの完全な実装を必要としませんが、リソース-IDを計算することは、オーバーレイのための適切なアルゴリズムを実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. Routing",
      "section_title": true,
      "ja": "4.3。ルーティング"
    },
    {
      "indent": 3,
      "text": "This section discusses the capabilities of RELOAD's routing layer and the protocol features used to implement the capabilities, and provides a brief overview of how they are used. Appendix A discusses some alternative designs and the trade-offs that would be necessary to support them.",
      "ja": "このセクションでは、RELOADのルーティング層の能力と機能を実装するために使用されるプロトコルの機能について説明し、その使用方法の概要を簡単に説明します。付録Aには、それらをサポートするために必要であろういくつかの代替設計とのトレードオフについて説明します。"
    },
    {
      "indent": 3,
      "text": "RELOAD's routing provides the following capabilities:",
      "ja": "RELOADのルーティングには、次の機能を提供します。"
    },
    {
      "indent": 3,
      "text": "Resource-based Routing: RELOAD supports routing messages based solely on the name of the resource. Such messages are delivered to a node that is responsible for that resource. Both structured and unstructured overlays are supported, so the route may not be deterministic for all Topology Plug-ins.",
      "ja": "リソースベースのルーティング：RELOADは、リソースの名前のみに基づいてルーティングメッセージをサポートしています。このようなメッセージは、そのリソースを担当するノードに配信されます。ルートは、すべてのトポロジプラグインのための決定論的ではないかもしれないので、どちらも構造化および非構造化オーバーレイは、サポートされています。"
    },
    {
      "indent": 3,
      "text": "Node-based Routing: RELOAD supports routing messages to a specific node in the overlay.",
      "ja": "ノードベースのルーティング：RELOADオーバーレイ内の特定のノードへのメッセージのルーティングをサポートしています。"
    },
    {
      "indent": 3,
      "text": "Clients: RELOAD supports requests from and to clients that do not participate in overlay routing. The clients are located via either of the mechanisms described above.",
      "ja": "クライアント：RELOADは、オーバーレイルーティングに参加していないクライアントからとへの要求をサポートしています。クライアントは、上述の機構のいずれかを介して配置されています。"
    },
    {
      "indent": 3,
      "text": "NAT Traversal: RELOAD supports establishing and using connections between nodes separated by one or more NATs, including locating peers behind NATs for those overlays allowing/requiring it.",
      "ja": "NATトラバーサル：リロードが確立し、それを必要とする/許可これらのオーバーレイのためのNATの背後のピアを突き止めるなど、一つ以上のNATにより分離ノード間の接続を使用してサポート。"
    },
    {
      "indent": 3,
      "text": "Low State: RELOAD's routing algorithms do not require significant state (i.e., state linear or greater in the number of outstanding messages that have passed through it) to be stored on intermediate peers.",
      "ja": "ロー状態：リロードのルーティングアルゴリズムは、中間ピアに保存する（それを通過した未処理のメッセージの数、すなわち、状態の線形以上）有意な状態を必要としません。"
    },
    {
      "indent": 3,
      "text": "Routability in Unstable Topologies: Overlay topology changes constantly in an overlay of moderate size due to the failure of individual nodes and links in the system. RELOAD's routing allows peers to reroute messages when a failure is detected, and replies can be returned to the requesting node as long as the peers that originally forwarded the successful request do not fail before the response is returned.",
      "ja": "不安定なトポロジでのルータビリティ：システム内の個々のノードやリンクの故障による適度なサイズのオーバーレイで常にオーバーレイトポロジの変更。 RELOADのルーティングは、障害が検出されたときにピアがメッセージを再ルーティングすることを可能にする、との回答はもともと、応答が返される前に失敗しない成功した要求を転送しピア限り、要求元のノードに戻すことができます。"
    },
    {
      "indent": 3,
      "text": "RELOAD's routing utilizes three basic mechanisms:",
      "ja": "RELOADのルーティングは、3つの基本的なメカニズムを利用します。"
    },
    {
      "indent": 3,
      "text": "Destination Lists: While, in principle, it is possible to just inject a message into the overlay with a single Node-ID as the destination, RELOAD provides a source-routing capability in the form of \"Destination Lists\". A Destination List provides a list of the nodes through which a message flows in order (i.e., it is loose source routed). The minimal Destination List contains just a single value.",
      "ja": "宛先リスト：、原理的には、それだけ先として単一ノードIDとオーバーレイにメッセージを注入することは可能であるが、リロードが「宛先リスト」の形でソースルーティング機能を提供します。宛先リストは、メッセージが順に流れるノード（すなわち、それがルーティングルーズソースである）のリストを提供します。最小限の宛先リストは、単に単一の値が含まれています。"
    },
    {
      "indent": 3,
      "text": "Via Lists: In order to allow responses to follow the same path as requests, each message also contains a \"Via List\", which is appended to by each node a message traverses. This Via List can then be inverted and used as a Destination List for the response.",
      "ja": "リストを介し：応答が要求と同じ経路に従うことを可能にするために、各メッセージは、メッセージが通過する各ノードによって付加された「を介してリスト」が含ま。この経由リストは、その後反転して、応答の宛先リストとして使用することができます。"
    },
    {
      "indent": 3,
      "text": "RouteQuery: The RouteQuery method allows a node to query a peer for the next hop it will use to route a message. This method is useful for diagnostics and for iterative routing (see Section 6.4.2.4).",
      "ja": "RouteQuery：RouteQuery方法ノードがルートにメッセージを使用する次のホップのピアを照会することを可能にします。この方法は、診断のための反復ルーティングのために有用である（6.4.2.4項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "The basic routing mechanism that RELOAD uses is symmetric recursive. We will first describe symmetric recursive routing and then discuss its advantages in terms of the requirements discussed above.",
      "ja": "リロードが使用する基本的なルーティングメカニズムは、対称再帰的です。まず、対称再帰ルーティングを説明した後、上述の要件の点でその利点について説明します。"
    },
    {
      "indent": 3,
      "text": "Symmetric recursive routing requires that a request message follow a path through the overlay to the destination: each peer forwards the message closer to its destination. The return path of the response goes through the same nodes as the request (though it may also go through some new intermediate nodes due to topology changes). Note that a failure on the reverse path caused by a topology change after the request was sent will be handled by the end-to-end retransmission of the response as described in Section 6.2.1. For example, the following figure shows a message following a route from A to Z through B and X:",
      "ja": "各ピアは、近い目的地へメッセージを転送：対称再帰ルーティング要求メッセージは宛先へのオーバーレイを通る経路をたどることが必要です。 （それはまた、トポロジの変更に起因するいくつかの新しい中間ノードを経由するかもしれないが）、応答のリターンパスは、要求と同じノードを経由します。セクション6.2.1に記載したように、要求が送信された後、トポロジ変化による逆の経路上の障害が応答のエンド・ツー・エンドの再送によって処理されることに留意されたいです。たとえば、次の図は、BおよびXを介してAからZまでの経路を、次のメッセージを示しています。"
    },
    {
      "indent": 3,
      "text": "A         B         X         Z\n-------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------->\nDest=Z\n         ---------->\n         Via=A\n         Dest=Z\n                   ---------->\n                   Via=A,B\n                   Dest=Z",
      "raw": true
    },
    {
      "indent": 3,
      "text": "                   <----------\n                    Dest=X,B,A\n         <----------\n            Dest=B,A\n<----------\n     Dest=A",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that this figure does not indicate whether A is a client or peer. A forwards its request to B, and the response is returned to A in the same manner regardless of A's role in the overlay.",
      "ja": "この図は、Aは、クライアントまたはピアであるかを示すものではありませんので注意してください。 Bへ転送し、その要求、および応答に関係なく、オーバーレイにおけるAの役割のと同じ方法で、Aに返されます。"
    },
    {
      "indent": 3,
      "text": "This figure shows use of full Via Lists by intermediate peers B and X. However, if B and/or X are willing to store state, then they may elect to truncate the lists and save the truncated information internally using the transaction ID as a key to allow it to be retrieved later. Later, when the response message arrives, the transaction ID would be used to recover the truncated information and return the response message along the path from which the request arrived. This option requires a greater amount of state to be stored on intermediate peers, but saves a small amount of bandwidth and reduces the need for modifying the message en route. Selection of this mode of operation is a choice for the individual peer; the techniques are interoperable even on a single message. The figure below shows B using full Via Lists, but X truncating them to X1 and saving the state internally.",
      "ja": "この図は、Bおよび/またはXは、状態を保存するために喜んでいる場合は、その後、彼らはリストを切り捨てることを選ぶことができるし、キーとしてトランザクションIDを使用して、内部で切り捨てられた情報を保存し、中間ピアBおよびXで表示されますフル経由の使用を示しそれは、後で取得できるようにします。応答メッセージが到着したときに、後で、トランザクションIDは、切り捨てられた情報を回復し、要求が到着し、そこからパスに沿って応答メッセージを返すために使用されます。このオプションは、中間ピアに格納される状態のより多くの量を必要とするが、少量の帯域幅を節約し、途中でメッセージを修正するための必要性を低減します。この動作モードの選択は、個々のピアのための選択です。技術は、1つでもメッセージの相互運用が可能です。下の図は、フル経由リストを使用してBを示しているが、Xは、X1にそれらを切り捨て、内部状態を保存します。"
    },
    {
      "indent": 3,
      "text": "A         B         X         Z\n-------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "---------->\nDest=Z\n         ---------->\n         Via=A\n         Dest=Z\n                   ---------->\n                   Via=X1\n                   Dest=Z",
      "raw": true
    },
    {
      "indent": 3,
      "text": "                   <----------\n                     Dest=X,X1\n           <----------\n              Dest=B,A\n<----------\n     Dest=A",
      "raw": true
    },
    {
      "indent": 3,
      "text": "As before, when B receives the message, B creates a Via List consisting of [A]. However, instead of sending [A, B], X creates an opaque ID X1 which maps internally to [A, B] (perhaps by being an encryption of [A, B]) and then forwards to Z with only X1 as the Via List. When the response arrives at X, it maps X1 back to [A, B], then inverts it to produce the new Destination List [B, A], and finally routes it to B.",
      "ja": "Bがメッセージを受信したときに前のように、Bは、ビアリスト[A]からなる生成します。しかし、代わりに[A、B]を送信する、Xは、ビアとしてのみX1とZに転送し、[A、B]（おそらく[A、B]の暗号化であることによる）の内部マッピング不透明IDのX1を作成リスト。応答がXに到着すると、それは、バック[A、B]にX1をマッピングし、新しい宛先リストを生成するために、それを反転させ、[B、A]、そして最終的にBへのルートを"
    },
    {
      "indent": 3,
      "text": "RELOAD also supports a basic iterative \"routing\" mode, in which the intermediate peers merely return a response indicating the next hop, but do not actually forward the message to that next hop themselves. Iterative routing is implemented using the RouteQuery method (see Section 6.4.2.4), which requests this behavior. Note that iterative routing is selected only by the initiating node.",
      "ja": "RELOADは、中間ピアは単にネクストホップを示す応答を返しますが、実際に自分自身を次のようにメッセージを転送ホップしないで基本的な反復「ルーティング」モードをサポートしています。反復ルーティングは、この動作を要求RouteQuery法（セクション6.4.2.4を参照）を用いて実装されます。反復ルーティングのみ開始ノードによって選択されることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "4.4. Connectivity Management",
      "section_title": true,
      "ja": "4.4。接続の管理"
    },
    {
      "indent": 3,
      "text": "In order to provide efficient routing, a peer needs to maintain a set of direct connections to other peers in the Overlay Instance. Due to the presence of NATs, these connections often cannot be formed directly. Instead, we use the Attach request to establish a connection. Attach uses Interactive Connectivity Establishment (ICE) [RFC5245] to establish the connection. It is assumed that the reader is familiar with ICE.",
      "ja": "効率的なルーティングを提供するために、ピアは、オーバーレイ・インスタンス内の他のピアへの直接接続のセットを維持する必要があります。原因のNATが存在するため、これらの接続は、多くの場合、直接形成することはできません。代わりに、我々は、接続を確立するためにアタッチ要求を使用します。取り付けは、接続を確立するためにインタラクティブ接続確立（ICE）[RFC5245]を使用しています。読者はICEに精通していることを想定しています。"
    },
    {
      "indent": 3,
      "text": "Say that peer A wishes to form a direct connection to peer B, either to join the overlay or to add more connections in its Routing Table. It gathers ICE candidates and packages them up in an Attach request, which it sends to B through usual overlay routing procedures. B does its own candidate gathering and sends back a response with its candidates. A and B then do ICE connectivity checks on the candidate pairs. The result is a connection between A and B. At this point, A and B MAY send messages directly between themselves without going through other overlay peers. In other words, A and B are in each other's Connection Tables. They MAY then execute an Update process, resulting in additions to each other's Routing Tables, and may then become able to route messages through each other to other overlay nodes.",
      "ja": "そのピアAがBをピアへの直接接続を形成するために、いずれかのオーバーレイに参加する、またはそのルーティングテーブル内の複数の接続を追加したいと言います。これは、ICE候補を収集し、それが通常のオーバーレイルーティング手続きを経てBに送信アタッチ要求、でそれらをパッケージ化します。 Bは、独自候補の収集を行い、その候補者との応答を返します。 AとBは、候補対上のICE接続性チェックを行います。結果はこの時点で、AとBの間の接続で、AとBは、他のオーバーレイ・ピアを経由せず、直接自分たちの間でメッセージを送信することができます。換言すれば、A及びBは、互いの接続テーブルです。そして、彼らは互いのルーティングテーブルへの追加をもたらす、更新処理を実行してもよいし、次いで他のオーバレイノードに互いに介してメッセージをルーティングできるようになることができます。"
    },
    {
      "indent": 3,
      "text": "There are two cases where Attach is not used. The first is when a peer is joining the overlay and is not connected to any peers. In order to support this case, a small number of bootstrap nodes typically need to be publicly accessible so that new peers can directly connect to them. Section 11 contains more detail on this. The second case is when a client connects to a peer at an arbitrary IP address, rather than to its responsible peer, as described in the second bullet point of Section 4.2.1.",
      "ja": "使用されていない取り付け2つのケースがあります。最初は、ピアがオーバレイに参加して、任意のピアに接続されていない場合です。新しいピアはそれらに直接接続することができるように、このケースをサポートするために、ブートストラップ・ノードの数が少ない一般的にパブリックにアクセスする必要があります。第11節は、この上の詳細が含まれています。セクション4.2.1の2番目の箇条書きに記載されているように、クライアントは、任意のIPアドレスのピアにはなく、その責任を負うピアに接続するときに、第2の場合です。"
    },
    {
      "indent": 3,
      "text": "In general, a peer needs to maintain connections to all of the peers near it in the Overlay Instance and to enough other peers to have efficient routing (the details on what \"enough\" and \"near\" mean depend on the specific overlay). If a peer cannot form a connection to some other peer, this is not necessarily a disaster; overlays can route correctly even without fully connected links. However, a peer needs to try to maintain the specified Routing Table defined by the Topology Plug-in algorithm and needs to form new connections if it detects that it has fewer direct connections than specified by the algorithm. This also implies that peers, in accordance with the Topology Plug-in algorithm, need to periodically verify that the connected peers are still alive and, if not, need to try to re-form the connections or form alternate ones. See Section 10.7.4.3 for an example on how a specific overlay algorithm implements these constraints.",
      "ja": "一般的には、ピアは、効率的なルーティング（「十分」と「近い」は、特定のオーバーレイに依存意味内容の詳細を）持っているオーバーレイインスタンスで十分な他のピアへのそれに近いピアのすべてへの接続を維持する必要があります。ピアが他のピアへの接続を形成することができない場合は、これは必ずしも災害ではありません。オーバーレイでも完全に接続されたリンクのない正しくルーティングすることができます。しかし、ピアはトポロジープラグインアルゴリズムによって定義され、それがアルゴリズムによって指定されたよりも少ないの直接接続を持っていることを検出した場合、新たな接続を形成する必要がある指定されたルーティングテーブルを維持しようとする必要があります。これはまた、ピアは、トポロジプラグインアルゴリズムに従って、定期的に接続されたピアがまだ生きていると、そうでない場合は、再形成接続しようとするか、別のものを形成する必要があることを確認する必要があることを意味します。特定のオーバーレイ・アルゴリズムは、これらの制約を実装方法の例については、セクション10.7.4.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.5. Overlay Algorithm Support",
      "section_title": true,
      "ja": "4.5。オーバーレイアルゴリズムのサポート"
    },
    {
      "indent": 3,
      "text": "The Topology Plug-in allows RELOAD to support a variety of overlay algorithms. This specification defines a DHT based on Chord, which is mandatory to implement, but the base RELOAD protocol is designed to support a variety of overlay algorithms. The information needed to implement this DHT is fully contained in this specification, but it is easier to understand if you are familiar with Chord-based [Chord] DHTs. A nice tutorial can be found at [wikiChord].",
      "ja": "トポロジプラグインは、RELOADは、オーバーレイの様々なアルゴリズムをサポートすることができます。この仕様は、実装するために必須であるコードに基づいてDHTを定義するが、ベースリロードプロトコルは、オーバーレイ・アルゴリズムの様々なサポートするように設計されています。このDHTを実装するために必要な情報は完全にこの仕様に含まれているが、あなたがコードベースの[コード]のDHTに精通している場合は理解しやすいです。すてきなチュートリアルでは、[wikiChord]で見つけることができます。"
    },
    {
      "indent": 0,
      "text": "4.5.1. Support for Pluggable Overlay Algorithms",
      "section_title": true,
      "ja": "4.5.1。プラグイン可能なオーバーレイアルゴリズムのサポート"
    },
    {
      "indent": 3,
      "text": "RELOAD defines three methods for overlay maintenance: Join, Update, and Leave. However, the contents of these messages, when they are sent, and their precise semantics are specified by the actual overlay algorithm, which is specified by configuration for all nodes in the overlay and thus is known to nodes before they attempt to join the overlay. RELOAD merely provides a framework of commonly needed methods that provide uniformity of notation (and ease of debugging) for a variety of overlay algorithms.",
      "ja": "参加Update、および残す：RELOADはオーバーレイメンテナンスのための3つのメソッドを定義します。しかし、それらが送信され、その正確な意味は、オーバーレイ内のすべてのノードの設定によって指定されたので、彼らは、オーバーレイに参加する前のノードに知られている実際のオーバーレイアルゴリズムによって指定されているこれらのメッセージの内容。 RELOAD単にオーバーレイアルゴリズムの様々な表記（およびデバッグの容易さ）の均一性を提供する一般的必要なメソッドのフレームワークを提供します。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Joining, Leaving, and Maintenance Overview",
      "section_title": true,
      "ja": "4.5.2。 、参加残し、およびメンテナンスの概要"
    },
    {
      "indent": 3,
      "text": "When a new peer wishes to join the Overlay Instance, it will need a Node-ID that it is allowed to use and a set of credentials which match that Node-ID. When an enrollment server is used, the Node-ID used is the one found in the certificate received from the enrollment server. The details of the joining procedure are defined by the overlay algorithm, but the general steps for joining an Overlay Instance are:",
      "ja": "新しいピアがオーバーレイインスタンスへの参加を希望する場合、使用を許可されているノードIDとそのノードIDと一致する資格情報のセットが必要になります。登録サーバを使用した場合、ノードID使用は、登録サーバから受信した証明書に見出されるものです。接合手順の詳細は、オーバーレイ・アルゴリズムによって定義されるが、オーバーレイインスタンスを結合するための一般的な手順がされています。"
    },
    {
      "indent": 3,
      "text": "o Form connections to some other peers.",
      "ja": "Oいくつかの他のピアへの接続を形成します。"
    },
    {
      "indent": 3,
      "text": "o Acquire the data values this peer is responsible for storing.",
      "ja": "Oこのピアが格納するための責任があるデータ値を取得します。"
    },
    {
      "indent": 3,
      "text": "o Inform the other peers which were previously responsible for that data that this peer has taken over responsibility.",
      "ja": "O以前にこのピアが責任を引き継いだそのデータを担当した他のピアに通知します。"
    },
    {
      "indent": 3,
      "text": "The first thing the peer needs to do is to form a connection to some bootstrap node. Because this is the first connection the peer makes, these nodes will need public IP addresses so that they can be connected to directly. Once a peer has connected to one or more bootstrap nodes, it can form connections in the usual way, by routing Attach messages through the overlay to other nodes. After a peer has connected to the overlay for the first time, it can cache the set of past adjacencies which have public IP addresses and can attempt to use them as future bootstrap nodes. Note that this requires some notion of which addresses are likely to be public as discussed in Section 9.",
      "ja": "ピアが行う必要がある最初の事はいくつかのブートストラップノードへの接続を形成することです。これは、ピアが行う最初の接続であるため、彼らは直接に接続することができるように、これらのノードは、パブリックIPアドレスが必要になります。ピアは、1つまたは複数のブートストラップノードに接続されたならば、それは他のノードへのオーバーレイを介してメッセージを添付ルーティングすることによって、通常の方法で接続を形成することができます。ピアが初めてのオーバーレイに接続した後、それはパブリックIPアドレスを持っているし、将来のブートストラップ・ノードとしてそれらを使用しようとすることができ、過去隣接のセットをキャッシュすることができます。これは、アドレスが9節で説明したように、公開する可能性があるそのうちのいくつかの概念が必要であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "After a peer has connected to a bootstrap node, it then needs to take up its appropriate place in the overlay. This requires two major operations:",
      "ja": "ピアは、ブートストラップノードに接続された後、それは、オーバーレイ内の適切な場所を取る必要があります。これは、2つの主要な操作を必要とします。"
    },
    {
      "indent": 3,
      "text": "o Form connections to other peers in the overlay to populate its Routing Table.",
      "ja": "Oそのルーティングテーブルを取り込むために、オーバーレイ内の他のピアへの接続を形成します。"
    },
    {
      "indent": 3,
      "text": "o Get a copy of the data it is now responsible for storing, and assume responsibility for that data.",
      "ja": "Oそれは今で格納するための責任があるデータのコピーを取得し、そのデータの責任を負います。"
    },
    {
      "indent": 3,
      "text": "The second operation is performed by contacting the Admitting Peer (AP), the node which is currently responsible for the relevant section of the overlay.",
      "ja": "第2の動作を認めるピア（AP）、現在のオーバーレイの関連部分を担っているノードを接触させることによって行われます。"
    },
    {
      "indent": 3,
      "text": "The details of this operation depend mostly on the overlay algorithm involved, but a typical case would be:",
      "ja": "この動作の詳細は、関連するオーバーレイ・アルゴリズムに主に依存するが、典型的なケースは次のようになります。"
    },
    {
      "indent": 3,
      "text": "1. JN sends a Join request to AP announcing its intention to join.",
      "section_title": true,
      "ja": "1. JN参加する意向を発表APへの参加要求を送信します。"
    },
    {
      "indent": 3,
      "text": "2. AP sends a Join response.",
      "section_title": true,
      "ja": "2. APは、参加応答を送信します。"
    },
    {
      "indent": 3,
      "text": "3. AP does a sequence of Stores to JN to give it the data it will need.",
      "ja": "3. APはそれにそれが必要とするデータを与えることJNに店舗のシーケンスを行います。"
    },
    {
      "indent": 3,
      "text": "4. AP does Updates to JN and to other peers to tell them about its own Routing Table. At this point, both JN and AP consider JN responsible for some section of the Overlay Instance.",
      "ja": "4. APは、自身のルーティングテーブルについて、それらを伝えるためにJNにし、他のピアにアップデートを行います。この時点で、JNとAPの両方がオーバーレイインスタンスのいくつかのセクションのためのJNが責任を考えます。"
    },
    {
      "indent": 3,
      "text": "5. JN makes its own connections to the appropriate peers in the Overlay Instance.",
      "ja": "5. JNは、オーバーレイのインスタンス内の適切なピアへの独自の接続を確立します。"
    },
    {
      "indent": 3,
      "text": "After this process completes, JN is a full member of the Overlay Instance and can process Store/Fetch requests.",
      "ja": "このプロセスが完了した後、JNはオーバーレイインスタンスのフルメンバーであり、要求をフェッチ/ストアを処理することができます。"
    },
    {
      "indent": 3,
      "text": "Note that the first node is a special case. When ordinary nodes cannot form connections to the bootstrap nodes, then they are not part of the overlay. However, the first node in the overlay can obviously not connect to other nodes. In order to support this case, potential first nodes (which can also initially serve as bootstrap nodes) need to somehow be instructed that they are the entire overlay, rather than part of an existing overlay (e.g., by comparing their IP address to the bootstrap IP addresses in the configuration file).",
      "ja": "最初のノードが、特別な場合であることに留意されたいです。通常のノードは、ブートストラップ・ノードへの接続を形成することができない場合には、それらは、オーバーレイの一部ではありません。しかし、オーバーレイ内の最初のノードは、明らかに他のノードに接続できません。このケースをサポートするために、（また、最初にブートストラップノードを提供することができます）潜在的な最初のノードが何らかの形でブートストラップに自分のIPアドレスを比較することで、彼らは全体のオーバーレイではなく、既存のオーバーレイ（例えばの一部であることを指示する必要がありますコンフィギュレーションファイル内のIPアドレス）。"
    },
    {
      "indent": 3,
      "text": "Note that clients do not perform either of these operations.",
      "ja": "クライアントはこれらのいずれかの操作を実行しないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.6. First-Time Setup",
      "section_title": true,
      "ja": "4.6。初回のセットアップ"
    },
    {
      "indent": 3,
      "text": "Previous sections addressed how RELOAD works after a node has connected. This section provides an overview of how users get connected to the overlay for the first time. RELOAD is designed so that users can start with the name of the overlay they wish to join and perhaps an account name and password, and can leverage these into having a working peer with minimal user intervention. This helps avoid the problems that have been experienced with conventional SIP clients in which users need to manually configure a large number of settings.",
      "ja": "前のセクションでは、ノードが接続された後RELOADがどのように機能するかを扱いました。このセクションでは、ユーザーが最初にオーバーレイに接続されている取得する方法の概要を説明します。ユーザーは、おそらくアカウント名とパスワードを参加したいオーバーレイの名前で開始することができ、かつ最小限のユーザー介入で作業ピアを持つにこれらを活用することができるようにRELOADに設計されています。これにより、ユーザーは手動での設定の大規模な数を設定する必要のある従来のSIPクライアントで経験されてきた問題を回避するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Initial Configuration",
      "section_title": true,
      "ja": "4.6.1。初期設定"
    },
    {
      "indent": 3,
      "text": "In the first phase of the setup process, the user starts with the name of the overlay and uses it to download an initial set of overlay configuration parameters. The node does a DNS SRV [RFC2782] lookup on the overlay name to get the address of a configuration server. It can then connect to this server with HTTPS [RFC2818] to download a Configuration Document which contains the basic overlay configuration parameters as well as a set of bootstrap nodes which can be used to join the overlay. The details of the relationships between names in the HTTPS certificates and the overlay names are described in Section 11.2.",
      "ja": "セットアッププロセスの最初の段階では、ユーザがオーバーレイの名前で始まり、オーバーレイの設定パラメータの初期セットをダウンロードするためにそれを使用しています。ノードは、コンフィギュレーションサーバのアドレスを取得するには、オーバーレイ名のDNS SRV [RFC2782]のルックアップを行います。その後、基本的なオーバーレイの設定パラメータと同様にオーバーレイを結合するために使用することができ、ブートストラップ・ノードのセットが含まれている構成ドキュメントをダウンロードするにはHTTPS [RFC2818]で、このサーバーに接続することができます。 HTTPS証明書とオーバーレイ名に名との間の関係の詳細については、セクション11.2で説明されています。"
    },
    {
      "indent": 3,
      "text": "If a node already has the valid Configuration Document that it received by an out-of-band method, this step can be skipped. Note that this out-of-band method needs to provide authentication and integrity, because the Configuration Document contains the trust anchors used by the overlay.",
      "ja": "ノードがすでにそれはアウトオブバンド方式で受信した有効な設定文書を持っている場合は、このステップをスキップすることができます。設定文書がオーバーレイで使用されるトラストアンカーが含まれているため、このアウトオブバンド方式は、認証と完全性を提供する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.6.2. Enrollment",
      "section_title": true,
      "ja": "4.6.2。入会"
    },
    {
      "indent": 3,
      "text": "If the overlay is using centralized enrollment, then a user needs to acquire a certificate before joining the overlay. The certificate attests both to the user's name within the overlay and to the Node-IDs which they are permitted to operate. In this case, the Configuration Document will contain the address of an enrollment server which can be used to obtain such a certificate and will also contain the trust anchor, so this document must be retrieved securely (see Section 11.2). The enrollment server may (and probably will) require some sort of account name for the user and a password before issuing the certificate. The enrollment server's ability to ensure attackers cannot get a large number of certificates for the overlay is one of the cornerstones of RELOAD's security.",
      "ja": "オーバーレイは、中央集中型の登録を使用している場合、ユーザーはオーバーレイに参加する前に、証明書を取得する必要があります。証明書は、オーバーレイ内およびそれらが動作することが許可されているノードIDにユーザー名の両方を証明しています。この場合、構成ドキュメントは、そのような証明書を取得するために使用することができ、また、トラストアンカーが含まれていますので、この文書は（11.2節を参照してください）しっかりと検索しなければならない登録サーバーのアドレスが含まれます。登録サーバは（おそらくます）ユーザーのアカウント名のいくつかの並べ替えや、証明書を発行する前にパスワードが必要な場合があります。オーバーレイのための多数の証明書を取得することはできません攻撃者を確保するための登録サーバーの能力はRELOADのセキュリティの基礎の一つです。"
    },
    {
      "indent": 0,
      "text": "4.6.3. Diagnostics",
      "section_title": true,
      "ja": "4.6.3。診断"
    },
    {
      "indent": 3,
      "text": "Significant advice around managing a RELOAD overlay and extensions for diagnostics are described in [P2P-DIAGNOSTICS].",
      "ja": "診断のためのRELOADオーバーレイと拡張を管理周りの重要なアドバイスは、[P2P-DIAGNOSTICS]で説明されています。"
    },
    {
      "indent": 0,
      "text": "5. Application Support Overview",
      "section_title": true,
      "ja": "5.アプリケーションサポートの概要"
    },
    {
      "indent": 3,
      "text": "RELOAD is not intended to be used alone, but rather as a substrate for other applications. These applications can use RELOAD for a variety of purposes:",
      "ja": "RELOADはなく、むしろ、他のアプリケーションのための基質として、単独で使用されるものではありません。これらのアプリケーションは、様々な目的のためにRELOADを使用することができます。"
    },
    {
      "indent": 3,
      "text": "o To store data in the overlay and to retrieve data stored by other nodes.",
      "ja": "オーバーレイ内のデータを格納するために、他のノードにより格納されたデータを取得するために、O。"
    },
    {
      "indent": 3,
      "text": "o As a discovery mechanism for services such as TURN.",
      "ja": "このようTURNなどのサービスのための検出メカニズムとして、O。"
    },
    {
      "indent": 3,
      "text": "o To form direct connections which can be used to transmit application-level messages without using the overlay.",
      "ja": "オーバーレイを使用することなく、アプリケーションレベルのメッセージを送信するために使用することができる直接接続を形成するために、O。"
    },
    {
      "indent": 3,
      "text": "This section provides an overview of these services.",
      "ja": "このセクションでは、これらのサービスの概要を説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Data Storage",
      "section_title": true,
      "ja": "5.1。データストレージ"
    },
    {
      "indent": 3,
      "text": "RELOAD provides operations to Store and Fetch data. Each location in the Overlay Instance is referenced by a Resource-ID. However, each location may contain data elements corresponding to multiple Kinds (e.g., certificate and SIP registration). Similarly, there may be multiple elements of a given Kind, as shown below:",
      "ja": "RELOADは、データを格納し、取得するための操作を提供します。オーバーレイ・インスタンス内の各位置は、リソース-IDによって参照されます。しかし、各位置は、複数の種類（例えば、証明書及びSIP登録）に対応するデータ要素を含んでいてもよいです。以下に示すように、同様に、特定の種類の複数の要素が存在してもよいです。"
    },
    {
      "indent": 22,
      "text": "+--------------------------------+\n|            Resource-ID         |\n|                                |\n| +------------+  +------------+ |\n| |   Kind 1   |  |   Kind 2   | |\n| |            |  |            | |\n| | +--------+ |  | +--------+ | |\n| | | Value  | |  | | Value  | | |\n| | +--------+ |  | +--------+ | |\n| |            |  |            | |\n| | +--------+ |  | +--------+ | |\n| | | Value  | |  | | Value  | | |\n| | +--------+ |  | +--------+ | |\n| |            |  +------------+ |\n| | +--------+ |                 |\n| | | Value  | |                 |\n| | +--------+ |                 |\n| +------------+                 |\n+--------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each Kind is identified by a Kind-ID, which is a code point either assigned by IANA or allocated out of a private range. As part of the Kind definition, protocol designers may define constraints (such as limits on size) on the values which may be stored. For many Kinds, the set may be restricted to a single value, while some sets may be allowed to contain multiple identical items, and others may have only unique items. Note that a Kind may be employed by multiple usages, and new usages are encouraged to use previously defined Kinds where possible. We define the following data models in this document, although other usages can define their own structures:",
      "ja": "各種類は、種類-ID、コード点IANAによって割り当てられた、またはプライベート範囲の外に割り当てられているいずれかによって識別されます。種類の定義の一部として、プロトコル設計者は、記憶されてもよい値に（例えば、サイズの制限などの）制約を定義することができます。多くの種類のために、いくつかのセットは、複数の同一の項目を含有させることができるがセットには、単一の値に制限することができる、他のものは唯一のユニークなアイテムを持っていることがあります。種類が複数の用途で採用されてもよい、および新しい用途を可能な限り先に定義された種類を使用することが推奨されることに留意されたいです。他の用途は、独自の構造を定義することができますが、私たちは、この文書に以下のデータモデルを定義します。"
    },
    {
      "indent": 3,
      "text": "single value: There can be at most one item in the set, and any value overwrites the previous item.",
      "ja": "単一の値は：セットの中で最もつの項目が存在することができ、任意の値は、前の項目を上書きします。"
    },
    {
      "indent": 3,
      "text": "array: Many values can be stored and addressed by a numeric index.",
      "ja": "配列：多くの値が保存され、数値インデックスによって対処することができます。"
    },
    {
      "indent": 3,
      "text": "dictionary: The values stored are indexed by a key. Often, this key is one of the values from the certificate of the peer sending the Store request.",
      "ja": "辞書：キーでインデックス化されて格納された値。多くの場合、このキーは、ストアリクエストを送信ピアの証明書のいずれかの値です。"
    },
    {
      "indent": 3,
      "text": "In order to protect stored data from tampering by other nodes, each stored value is individually digitally signed by the node which created it. When a value is retrieved, the digital signature can be verified to detect tampering. If the certificate used to verify the stored value signature expires, the value can no longer be retrieved (although it may not be immediately garbage collected by the storing node), and the creating node will need to store the value again if it desires that the stored value continue to be available.",
      "ja": "他のノードによって改ざんから格納されたデータを保護するために、各格納された値は、個々にデジタルそれを作成したノードによって署名されます。値が取得されると、デジタル署名は、改ざんを検出するために検証することができます。証明書が格納された値の署名が期限切れに検証するために使用される場合（それは記憶ノードによって収集直ちにごみではないかもしれないが）、値はもはや取得することができない、そしてそれが望む場合に作成ノードは再び値を格納する必要があります保存された値が利用可能であり続けます。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Storage Permissions",
      "section_title": true,
      "ja": "5.1.1。ストレージの権限"
    },
    {
      "indent": 3,
      "text": "A major issue in peer-to-peer storage networks is minimizing the burden of becoming a peer and, in particular, minimizing the amount of data which any peer needs to store for other nodes. RELOAD addresses this issue by allowing any given node to store data only at a small number of locations in the overlay, with those locations being determined by the node's certificate. When a peer uses a Store request to place data at a location authorized by its certificate, it signs that data with the private key that corresponds to its certificate. Then the peer responsible for storing the data is able to verify that the peer issuing the request is authorized to make that request. Each data Kind defines the exact rules for determining what certificate is appropriate.",
      "ja": "ピアツーピアストレージネットワークにおける大きな課題は、ピアになる負担を最小限に抑え、特に、任意のピアが他のノードのために保存する必要があるデータの量を最小化されます。これらの位置は、ノードの証明書によって決定されると、のみオーバーレイ内の位置の小さな数のデータを格納するための任意のノードを可能にすることによって、アドレスにこの問題をリロード。ピアは、その証明書が承認した場所にデータを配置するストア要求を使用すると、その証明書に対応する秘密鍵を使用して、そのデータに署名します。そして、データを格納するための責任を負うピアが要求を発行するピアがその要求をするために許可されていることを確認することができます。各データ種類は、証明書が適切であるかを決定するための正確な規則を定義します。"
    },
    {
      "indent": 3,
      "text": "The most natural rule is that a certificate authorizes a user to store data keyed with their user name X. Thus, only a user with a certificate for \"alice@example.org\" could write to that location in the overlay (see Section 11.3). However, other usages can define any rules they choose, including publicly writable values.",
      "ja": "最も自然なルールは、証明書はこのように自分のユーザー名Xでキーデータを格納するためのユーザを許可、「alice@example.org」のための証明書を持つユーザーだけがオーバーレイでその場所に書き込むことができることである（11.3節を参照してください） 。しかし、他の用途には、公に書き込み可能な値を含めて、彼らが選択した任意のルールを定義することができます。"
    },
    {
      "indent": 3,
      "text": "The digital signature over the data serves two purposes. First, it allows the peer responsible for storing the data to verify that this Store is authorized. Second, it provides integrity for the data. The signature is saved along with the data value (or values) so that any reader can verify the integrity of the data. Of course, the responsible peer can \"lose\" the value, but it cannot undetectably modify it.",
      "ja": "データに対するデジタル署名は2つの目的を果たします。まず、それはこのお店が許可されていることを確認するために、データを格納するためのピアが責任を負うことができます。第二に、それはデータの整合性を提供します。任意のリーダがデータの整合性を検証することができるように、署名は、データ値（または値）と一緒に保存されています。もちろん、責任ピアは値を「失う」ことができますが、それは検出できない、それを変更することはできません。"
    },
    {
      "indent": 3,
      "text": "The size requirements of the data being stored in the overlay are variable. For instance, a SIP AOR and voicemail differ widely in the storage size. RELOAD leaves it to the usage and overlay configuration to limit size imbalances of various Kinds.",
      "ja": "オーバーレイに格納されるデータのサイズ要件が可変です。例えば、SIP AORとボイスメールは、記憶サイズが大きく異なります。リロードは、各種のサイズの不均衡を制限するために使用し、オーバーレイの設定にそれを残します。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Replication",
      "section_title": true,
      "ja": "5.1.2。レプリケーション"
    },
    {
      "indent": 3,
      "text": "Replication in P2P overlays can be used to provide:",
      "ja": "P2Pオーバーレイでのレプリケーションは、提供するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "persistence: if the responsible peer crashes and/or if the storing peer leaves the overlay",
      "ja": "持続性：責任あるピアがクラッシュした場合、および/または保存するピアがオーバーレイを離れた場合"
    },
    {
      "indent": 3,
      "text": "security: to guard against DoS attacks by the responsible peer or routing attacks to that responsible peer",
      "ja": "セキュリティ：その責任を負うピアに責任ピアまたはルーティング攻撃によるDoS攻撃を防ぐために"
    },
    {
      "indent": 3,
      "text": "load balancing: to balance the load of queries for popular resources",
      "ja": "ロードバランシング：人気のリソースのためのクエリの負荷を分散します"
    },
    {
      "indent": 3,
      "text": "A variety of schemes are used in P2P overlays to achieve some of these goals. Common techniques include replicating on neighbors of the responsible peer, randomly locating replicas around the overlay, and replicating along the path to the responsible peer.",
      "ja": "様々なスキームは、これらの目標の一部を達成するためにP2Pオーバーレイで使用されています。一般的な技術は、責任あるピアの隣人に複製ランダムオーバーレイの周りのレプリカを見つけ、そして責任あるピアへの経路に沿って複製します。"
    },
    {
      "indent": 3,
      "text": "The core RELOAD specification does not specify a particular replication strategy. Instead, the first level of replication strategies is determined by the overlay algorithm, which can base the replication strategy on its particular topology. For example, Chord places replicas on successor peers, which will take over responsibility if the responsible peer fails [Chord].",
      "ja": "コアRELOAD仕様は、特定のレプリケーション戦略を指定していません。代わりに、複製戦略の最初のレベルは、その特定のトポロジーに複製戦略の基礎ができるオーバーレイアルゴリズムによって決定されます。例えば、コードは、責任ピアが[コード]失敗した場合に責任を引き継ぐ後継ピア、上のレプリカを配置します。"
    },
    {
      "indent": 3,
      "text": "If additional replication is needed, for example, if data persistence is particularly important for a particular usage, then that usage may specify additional replication, such as implementing random replications by inserting a different well-known constant into the Resource Name used to store each replicated copy of the resource. Such replication strategies can be added independently of the underlying algorithm, and their usage can be determined based on the needs of the particular usage.",
      "ja": "追加の複製が必要な場合、データの永続性は、特定の使用のために特に重要である場合、例えば、その使用は、そのような挿入することによってランダム複製を実現するように、追加の複製を指定することができるリソース名に定数が各複製を記憶するために使用される周知の異なりますリソースのコピー。このような複製戦略は根本的なアルゴリズムとは独立して追加することができ、その使用方法は、特定の使用の必要性に基づいて決定することができます。"
    },
    {
      "indent": 0,
      "text": "5.2. Usages",
      "section_title": true,
      "ja": "5.2。用途"
    },
    {
      "indent": 3,
      "text": "By itself, the distributed storage layer provides only the infrastructure on which applications are built. In order to do anything useful, a usage needs to be defined. Each usage needs to specify several things:",
      "ja": "単独で、分散ストレージ層は、アプリケーションが構築されているだけのインフラストラクチャを提供します。便利な何かをするためには、使用法を定義する必要があります。それぞれの使用量は、いくつかのものを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Register Kind-ID code points for any Kinds that the usage defines (Section 14.6).",
      "ja": "使用定義（セクション14.6）、任意の種類のOレジスタ種類-IDコードポイント。"
    },
    {
      "indent": 3,
      "text": "o Define the data structure for each of the Kinds (the value member in Section 7.2). If the data structure contains character strings, conversion rules between characters and the binary storage need to be specified.",
      "ja": "O種類（セクション7.2の値部材）のそれぞれのためのデータ構造を定義します。データ構造は文字列が含まれている場合は、文字とバイナリストレージ間の変換規則を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Define access control rules for each of the Kinds (Section 7.3).",
      "ja": "O種類（7.3節）のそれぞれについて、アクセス制御ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "o Define how the Resource Name is used to form the Resource-ID where each Kind is stored.",
      "ja": "Oリソース名は、それぞれの種類が格納されているリソース-IDを形成するために使用される方法を定義します。"
    },
    {
      "indent": 3,
      "text": "o Describe how values will be merged when a network partition is being healed.",
      "ja": "Oネットワークパーティションが癒されているときの値をマージする方法を説明してください。"
    },
    {
      "indent": 3,
      "text": "The Kinds defined by a usage may also be applied to other usages. However, a need for different parameters, such as a different access control model, would imply the need to create a new Kind.",
      "ja": "用法によって定義種類は、他の用途にも適用することができます。しかし、必要性は、異なるアクセス制御モデルなど、さまざまなパラメータのために、新しい種類を作成する必要性を暗示します。"
    },
    {
      "indent": 0,
      "text": "5.3. Service Discovery",
      "section_title": true,
      "ja": "5.3。サービス検出"
    },
    {
      "indent": 3,
      "text": "RELOAD does not currently define a generic service discovery algorithm as part of the base protocol, although a simplistic TURN-specific discovery mechanism is provided. A variety of service discovery algorithms can be implemented as extensions to the base protocol, such as the service discovery algorithm ReDIR [opendht-sigcomm05] and [REDIR-RELOAD].",
      "ja": "単純TURN固有ディスカバリ機構が設けられているがリロードは、現在、基本プロトコルの一部として汎用サービス発見アルゴリズムを定義していません。サービス発見アルゴリズムの様々なそのようなサービス発見アルゴリズムREDIR [opendht-sigcomm05]および[REDIRリロード]などの基本プロトコルの拡張として実装することができます。"
    },
    {
      "indent": 0,
      "text": "5.4. Application Connectivity",
      "section_title": true,
      "ja": "5.4。アプリケーション接続"
    },
    {
      "indent": 3,
      "text": "There is no requirement that a RELOAD Usage needs to use RELOAD's primitives for establishing its own communication if it already possesses its own means of establishing connections. For example, one could design a RELOAD-based resource discovery protocol which used HTTP to retrieve the actual data.",
      "ja": "RELOADの使用は、それがすでに接続を確立する独自の手段を持っている場合は、独自の通信を確立するためRELOADのプリミティブを使用する必要がある必要はありません。例えば、一方が実際のデータを取得するためにHTTPを使用RELOADベースのリソースディスカバリプロトコルを設計することができました。"
    },
    {
      "indent": 3,
      "text": "For more common situations, however, it is the overlay itself -- rather than an external authority such as DNS -- which is used to establish a connection. RELOAD provides connectivity to applications using the AppAttach method. For example, if a P2PSIP node wishes to establish a SIP dialog with another P2PSIP node, it will use AppAttach to establish a direct connection with the other node. This new connection is separate from the peer protocol connection. It is a dedicated DTLS or TLS flow used only for the SIP dialog.",
      "ja": "いうよりも、DNSなどの外部の権威 -   - 接続を確立するために使用される、より一般的な状況では、しかし、それはオーバーレイそのものです。 RELOADはAppAttachメソッドを使用してアプリケーションへの接続を提供します。 P2PSIPノードが別のP2PSIPノードとのSIPダイアログを確立することを希望する場合、それは他のノードとの直接接続を確立するためにAppAttachを使用します。この新しい接続はピアプロトコル接続から分離されています。これは、SIPダイアログのためにのみ使用される専用DTLSまたはTLSの流れです。"
    },
    {
      "indent": 0,
      "text": "6. Overlay Management Protocol",
      "section_title": true,
      "ja": "6.オーバーレイ管理プロトコル"
    },
    {
      "indent": 3,
      "text": "This section defines the basic protocols used to create, maintain, and use the RELOAD overlay network. We start by defining the basic concept of how message destinations are interpreted when routing messages. We then describe the symmetric recursive routing model, which is RELOAD's default routing algorithm. Finally, we define the message structure and the messages used to join and maintain the overlay.",
      "ja": "このセクションでは、作成、保守、およびRELOADのオーバーレイネットワークを使用するために使用される基本的なプロトコルを定義します。私たちは、メッセージをルーティングするときにメッセージの送信先がどのように解釈されるかの基本的な概念を定義することから始めます。私たちは、その後、RELOADのデフォルトのルーティングアルゴリズムである対称再帰ルーティングモデルを、説明します。最後に、私たちは、メッセージ構造およびオーバーレイに参加し、維持するために使用されるメッセージを定義します。"
    },
    {
      "indent": 0,
      "text": "6.1. Message Receipt and Forwarding",
      "section_title": true,
      "ja": "6.1。メッセージ受信および転送"
    },
    {
      "indent": 3,
      "text": "When a node receives a message, it first examines the overlay, version, and other header fields to determine whether the message is one it can process. If any of these are incorrect, as defined in Section 6.3.2, it is an error and the message MUST be discarded. The peer SHOULD generate an appropriate error, but local policy can override this and cause the message to be silently dropped.",
      "ja": "ノードがメッセージを受信すると、最初のメッセージは、それが処理できるものであるかどうかを決定するためにオーバーレイ、バージョン、及び他のヘッダフィールドを検査します。これらのいずれかが正しくない場合は、6.3.2項で定義されるように、それは誤りであるとのメッセージを捨てなければなりません。ピアは、適切なエラーを生成する必要がありますが、ローカルポリシーは、このメソッドをオーバーライドし、静かに落下するメッセージを引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "Once the peer has determined that the message is correctly formatted (note that this does not include signature-checking on intermediate nodes as the message may be fragmented), it examines the first entry on the Destination List. There are three possible cases here:",
      "ja": "ピアは、メッセージが正しくフォーマットされていることを決定すると、宛先リストの最初のエントリを調べ、（メッセージが断片化されるように、これは中間ノードの署名チェックを含まないことに留意されたいです）。ここでは三つの可能なケースがあります。"
    },
    {
      "indent": 3,
      "text": "o The first entry on the Destination List is an ID for which the peer is responsible. A peer is always responsible for the wildcard Node-ID. Handling of this case is described in Section 6.1.1.",
      "ja": "oを宛先リストの最初のエントリは、ピアが担当するIDです。ピアは、常にワイルドカードノードIDを担当しています。この場合の取扱いは、6.1.1項で説明されています。"
    },
    {
      "indent": 3,
      "text": "o The first entry on the Destination List is an ID for which another peer is responsible. Handling of this case is described in Section 6.1.2.",
      "ja": "oを宛先リストの最初のエントリは、別のピアが担当するIDです。この場合の取扱いは、セクション6.1.2に記載されています。"
    },
    {
      "indent": 3,
      "text": "o The first entry on the Destination List is an opaque ID that is being used for Destination List compression. Handling of this case is described in Section 6.1.3. Note that opaque IDs can be distinguished from Node-IDs and Resource-IDs on the wire as described in Section 6.3.2.2.",
      "ja": "oを送信先リスト上の最初のエントリは、宛先リスト圧縮のために使用されている不透明なIDです。この場合の取扱いは、6.1.3項で説明されています。セクション6.3.2.2に記載されるように、不透明なIDがワイヤにノードIDおよびリソース-IDを区別することができることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "These cases are handled as discussed below.",
      "ja": "これらの場合は、後述するように処理されます。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Responsible ID",
      "section_title": true,
      "ja": "6.1.1。責任ID"
    },
    {
      "indent": 3,
      "text": "If the first entry on the Destination List is an ID for which the peer is responsible, there are several (mutually exclusive) subcases to consider.",
      "ja": "宛先リストの最初のエントリは、ピアが担当するIDであれば、考慮すべきいくつかの（相互に排他的）サブケースがあります。"
    },
    {
      "indent": 3,
      "text": "o If the entry is a Resource-ID, then it MUST be the only entry on the Destination List. If there are other entries, the message MUST be silently dropped. Otherwise, the message is destined for this node, so the node MUST verify the signature as described in Section 7.1 and MUST pass it to the upper layers. \"Upper layers\" is used here to mean the components above the \"Overlay Link Service Boundary\" line in the figure in Section 1.2.",
      "ja": "エントリは、リソース-IDである場合は、O、それは宛先リストの唯一のエントリでなければなりません。他のエントリが存在する場合、メッセージは静かに下げなければなりません。そうでない場合、メッセージはこのノードを宛先とするため、ノードは、セクション7.1で説明したように、署名を検証しなければならなくて、上位層に渡す必要があります。 「上位層は」1.2節では、図中の「オーバーレイリンクサービス境界」行以上の成分を意味するために使用されます。"
    },
    {
      "indent": 3,
      "text": "o If the entry is a Node-ID which equals this node's Node-ID, then the message is destined for this node. If it is the only entry on the Destination List, the message is destined for this node and so the node passes it to the upper layers. Otherwise, the node removes the entry from the Destination List and repeats the routing process with the next entry on the Destination List. If the message is a response and list compression was used, then the node first modifies the Destination List to reinsert the saved state, e.g., by unpacking any opaque IDs.",
      "ja": "エントリは、このノードのノードIDに等しいノードIDである場合、O、メッセージは、このノードに宛てています。それは先リスト上の唯一のエントリがある場合は、メッセージがこのノードに宛てので、ノードが上位層に渡しています。そうしないと、ノードは宛先リストからエントリを削除し、宛先リストに次のエントリを持つルーティング処理を繰り返します。メッセージが応答して、リスト圧縮が使用された場合は、ノードは、最初の任意の不透明なIDをアンパックすることにより、例えば、保存された状態を再挿入するために宛先リストを変更します。"
    },
    {
      "indent": 3,
      "text": "o If the entry is the wildcard Node-ID (all \"1\"s), the message is destined for this node, and the node passes the message to the upper layers. A message with a wildcard Node-ID as its first entry is never forwarded; it is consumed locally.",
      "ja": "エントリは、ワイルドカードノードID（全て「1」）である場合、O、メッセージがこのノード宛の、及びノードが上位層にメッセージを渡しています。その最初のエントリとしてワイルドカードノードIDを持つメッセージが転送されることはありません。それがローカルに消費されます。"
    },
    {
      "indent": 3,
      "text": "o If the entry is a Node-ID which is not equal to this node, then the node MUST drop the message silently unless the Node-ID corresponds to a node which is directly connected to this node (i.e., a client). In the latter case, the node MUST attempt to forward the message to the destination node as described in the next section (though this may fail for connectivity reasons, because the TTL has expired, or because of some other error.)",
      "ja": "エントリは、ノードIDこのノードに等しくない場合、ノードIDは、直接ノード（すなわち、クライアント）に接続されているノードに対応しない限り、O、ノードは静かにメッセージを削除する必要があります。後者の場合、ノードは、次のセクションで説明したように、宛先ノードにメッセージを転送しようとしなければならない（これが原因でいくつかの他のエラーのTTLが満了したため、接続の理由で失敗する、またはかもしれません。）"
    },
    {
      "indent": 3,
      "text": "Note that this process implies that in order to address a message to \"the peer that controls region X\", a sender sends to Resource-ID X, not Node-ID X.",
      "ja": "このプロセスは、「領域Xを制御ピア」にメッセージをアドレス指定するために、送信者がリソースIDするX、ないノードID Xを送信することを意味することに注意してください"
    },
    {
      "indent": 0,
      "text": "6.1.2. Other ID",
      "section_title": true,
      "ja": "6.1.2。他のID"
    },
    {
      "indent": 3,
      "text": "If the first entry on the Destination List is neither an opaque ID nor an ID the peer is responsible for, then the peer MUST forward the message towards that entry. This means that it MUST select one of the peers to which it is connected and which is most likely to be responsible (according to the Topology Plug-in) for the first entry on the Destination List. For the CHORD-RELOAD topology, the routing to the most likely responsible node is explained in Section 10.3. If the first entry on the Destination List is in the peer's Connection Table, the peer MUST forward the message to that peer directly. Otherwise, the peer consults the Routing Table to forward the message.",
      "ja": "宛先リストの最初のエントリは、不透明なIDやピアが担当するIDでもない場合、ピアは、そのエントリに向けてメッセージを転送しなければなりません。これは、それが接続されている送信先リストの最初のエントリのために（トポロジプラグインに応じて）責任がある可能性が最も高いであるピアの1つを選択しなければならないことを意味します。 CHORD-RELOADトポロジの場合は、最も可能性の高い責任のノードへのルーティングは、セクション10.3で説明されています。宛先リストの最初のエントリは、ピアの接続テーブル内にある場合、ピアは直接そのピアにメッセージを転送しなければなりません。そうでない場合、ピアは、メッセージを転送するルーティングテーブルを参照します。"
    },
    {
      "indent": 3,
      "text": "Any intermediate peer which forwards a RELOAD request MUST ensure that if it receives a response to that message, the response can be routed back through the set of nodes through which the request passed. The peer selects one of these approaches:",
      "ja": "リロード要求を転送する任意の中間ピアは、それがそのメッセージに対する応答を受信した場合、応答は要求が通過したノードのセットを戻すことができることを確認しなければなりません。ピアは、これらのアプローチのいずれかを選択します。"
    },
    {
      "indent": 3,
      "text": "o The peer can add an entry to the Via List in the forwarding header that will enable it to determine the correct node. This is done by appending to the Via List the Node-ID of the node from which the request was received.",
      "ja": "Oピアは正しいノードを決定することを可能にする転送ヘッダINを介してリストにエントリを追加することができます。これは、経由リストへのリクエストを受信したノードのノードIDを追加することで行われます。"
    },
    {
      "indent": 3,
      "text": "o The peer can keep per-transaction state which will allow it to determine the correct node.",
      "ja": "Oピアは、それが正しいノードを決定することを可能にするごとトランザクション状態を維持することができます。"
    },
    {
      "indent": 3,
      "text": "As an example of the first strategy, consider an example with nodes A, B, C, D, and E. If node D receives a message from node C with Via List [A, B], then D would forward to the next node E with Via List [A, B, C]. Now, if E wants to respond to the message, it reverses the Via List to produce the Destination List, resulting in [D, C, B, A]. When D forwards the response to C, the Destination List will contain [C, B, A].",
      "ja": "ノードDを経由リスト[A、B]と、ノードCからのメッセージを受信した場合、最初の戦略の一例としては、Dが次のノードに転送するであろう、ノードA、B、C、D、およびEを用いて例を考えます経由一覧[A、B、C]とE。 Eは、メッセージに応答したい場合さて、それは[D、C、B、A]が得られ、宛先リストを生成するために経由リストを反転させます。 DがCに応答を転送する場合、送信先リストは[C、B、A]を含有するであろう。"
    },
    {
      "indent": 3,
      "text": "As an example of the second strategy, if node D receives a message from node C with transaction ID X (as assigned by A) and Via List [A, B], it could store [X, C] in its state database and forward the message with the Via List unchanged. When D receives the response, it consults its state database for transaction ID X, determines that the request came from C, and forwards the response to C.",
      "ja": "ノードDは、トランザクションID X（Aによって割り当てられる）を介してリスト[A、B]と、ノードCからのメッセージを受信した場合に、第2の戦略の一例として、これは、その状態データベースと前方に[X、C]を記憶することができます経由リストとメッセージ変わりません。 Dは、応答を受信すると、それは、トランザクションID Xのためにその状態データベースを参照要求がCから来たと判断し、Cに応答を転送します"
    },
    {
      "indent": 3,
      "text": "Intermediate peers which modify the Via List are not required to simply add entries. The only requirement is that the peer MUST be able to reconstruct the correct Destination List on the return route. RELOAD provides explicit support for this functionality in the form of opaque IDs, which can replace any number of Via List entries.",
      "ja": "経由リストを変更する中間ピアは、単純にエントリを追加する必要はありません。唯一の要件は、ピアが復路上の正しい宛先リストを再構築することができなければならないということです。 RELOADは、経由リストの項目の任意の数を置き換えることができ、不透明のID、の形でこの機能を明示的にサポートを提供します。"
    },
    {
      "indent": 3,
      "text": "For instance, in the above example, Node D might send E a Via List containing only the opaque ID I. E would then use the Destination List [D, I] to send its return message. When D processes this Destination List, it would detect that I is an opaque ID, recover the Via List [A, B, C], and reverse that to produce the correct Destination List [C, B, A] before sending it to C. This feature is called \"list compression\". Possibilities for an opaque ID include a compressed and/or encrypted version of the original Via List and an index into a state database containing the original Via List, but the details are a local matter.",
      "ja": "例えば、上記の例では、ノードDは、不透明なIDのI. Eを含む経由リストはそのリターン・メッセージを送信するために[私は、D]宛先リストを使用するEを送信することがあります。 Dは、この宛先リストを処理するとき、それは、私が不透明IDであることを検出経由リスト[A、B、C]を回復、及びCに送信する前に、正しい宛先リスト[C、B、A]を生成するためにその逆になります。この機能は、「リスト圧縮」と呼ばれています。不透明なIDの可能性は、元の経由リストの圧縮および/または暗号化されたバージョンとオリジナルの経由リストを含む状態データベースへのインデックスが含まれるが、詳細はローカルの問題です。"
    },
    {
      "indent": 3,
      "text": "No matter what mechanism for storing Via List state is used, if an intermediate peer exits the overlay, then on the return trip the message cannot be forwarded and will be dropped. The ordinary timeout and retransmission mechanisms provide stability over this type of failure.",
      "ja": "中間ピアがメッセージを転送することはできません帰りに、その後、オーバーレイを終了し、削除されます場合はどんなに経由リストの状態を格納するためのどのようなメカニズムは、使用されません。通常、タイムアウトおよび再送信メカニズムは、このタイプの障害の上に安定性を提供します。"
    },
    {
      "indent": 3,
      "text": "Note that if an intermediate peer retains per-transaction state instead of modifying the Via List, it needs some mechanism for timing out that state; otherwise, its state database will grow without bound. Whatever algorithm is used, unless a FORWARD_CRITICAL forwarding option (Section 6.3.2.3) or an overlay configuration option explicitly indicates this state is not needed, the state MUST be maintained for at least the value of the overlay-reliability-timer configuration parameter and MAY be kept longer. Future extensions, such as [P2PSIP-RELAY], may define mechanisms for determining when this state does not need to be retained.",
      "ja": "中間ピアが経由リストを修正するのではなく、トランザクションごとの状態を保持している場合、それはその状態をタイミングするためのいくつかのメカニズムを必要とすることに注意してください。そうでない場合は、その状態データベースは無制限に大きくなります。 FORWARD_CRITICAL転送オプション（セクション6.3.2.3）またはオーバーレイの設定オプションが明示的状態は、少なくともオーバーレイ信頼タイマー設定パラメータの値もよく維持されなければならない、この状態が必要でないことを示さない限り、使用されるどのようなアルゴリズム長く保持すること。このような[P2PSIPリレー]などの将来の拡張は、この状態を保持する必要がない場合を決定するためのメカニズムを定義することができます。"
    },
    {
      "indent": 3,
      "text": "There is no requirement to ensure that a request issued after the receipt of a response follows the same path as the response. As a consequence, there is no requirement to use either of the mechanisms described above (Via List or state retention) when processing a response message.",
      "ja": "応答の受領後に発行された要求は応答と同じ経路をたどることを確実にする必要はありません。その結果、応答メッセージを処理するとき（VIAリストまたは状態保持）上述したメカニズムのいずれかを使用する必要はありません。"
    },
    {
      "indent": 3,
      "text": "A node receiving a request from another node MUST ensure that any response to that request exits that node with a Destination List equal to the concatenation of the Node-ID of the node from which the request was received with the Via List in the original request. The intermediate node normally learns the Node-ID that the other node is using via an Attach, but a node using a certificate with a single Node-ID MAY elect not to send an Attach (see Section 4.2.1, bullet 2). If a node with a certificate with multiple Node-IDs attempts to route a message other than a Ping or Attach through a node without performing an Attach, the receiving node MUST reject the request with an Error_Forbidden error. The node MUST implement support for returning responses to a Ping or Attach request made by a Joining Node Attaching to its responsible peer.",
      "ja": "他のノードからの要求を受信したノードは、その要求に対する応答が要求元の要求のViaリストで受信されたノードのノードIDの連結に等しい宛先リストと、そのノードから出ることを確実にしなければなりません。中間ノードは、通常アタッチを介して他のノードが使用しているノードIDを学習するが、単一のノードIDと証明書を使用して、ノードが（、弾丸2セクション4.2.1を参照）を添付送信しないように選択することができます。複数のノードIDを持つ証明書を使用してノードをルートするには、ping以外のメッセージを試みるか、取り付け行うことなく、ノードを介して接続した場合、受信ノードはError_Forbiddenエラーで要求を拒絶しなければなりません。ノードがpingに応答を返すためのサポートを実装するか、その責任のピアへの接続、参加するノードからの要求を添付する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Opaque ID",
      "section_title": true,
      "ja": "6.1.3。不透明なID"
    },
    {
      "indent": 3,
      "text": "If the first entry on the Destination List is an opaque ID (e.g., a compressed Via List), the peer MUST replace the entry with the original Via List that it replaced and then re-examine the Destination List to determine which of the three cases in Section 6.1 now applies.",
      "ja": "宛先リストの最初のエントリは、不透明なID（例えば、圧縮経由リスト）である場合、ピアは3例どれを決定するために再検討宛先リスト、それを交換することを本来の経由リストのエントリを交換しなければなりません。 6.1節で今適用されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Symmetric Recursive Routing",
      "section_title": true,
      "ja": "6.2。対称再帰ルーティング"
    },
    {
      "indent": 3,
      "text": "This section defines RELOAD's Symmetric Recursive Routing algorithm, which is the default algorithm used by nodes to route messages through the overlay. All implementations MUST implement this routing algorithm. An overlay MAY be configured to use alternative routing algorithms, and alternative routing algorithms MAY be selected on a per-message basis. That is, a node in an overlay which supports Symmetric Recursive Routing and some other routing algorithm called XXX might use Symmetric Recursive Routing some of the time and XXX at other times.",
      "ja": "このセクションでは、オーバーレイを介してメッセージをルーティングするためにノードによって使用される既定のアルゴリズムであるリロードの対称再帰ルーティング・アルゴリズムを定義します。すべての実装は、このルーティングアルゴリズムを実装しなければなりません。オーバーレイは、代替ルーティングアルゴリズムを使用するように構成されてもよく、別のルーティングアルゴリズムは、メッセージ毎に選択することができます。つまり、対称再帰ルーティングをサポートし、オーバーレイ内のノードであるとXXXと呼ばれるいくつかの他のルーティングアルゴリズムは、他の回で対称再帰ルーティングの時間とXXXの一部を使用することがあります。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Request Origination",
      "section_title": true,
      "ja": "6.2.1。リクエストオリジ"
    },
    {
      "indent": 3,
      "text": "In order to originate a message to a given Node-ID or Resource-ID, a node MUST construct an appropriate Destination List. The simplest such Destination List is a single entry containing the Node-ID or Resource-ID. The resulting message MUST be forwarded to its destination via the normal overlay routing mechanisms. The node MAY also construct a more complicated Destination List for source routing.",
      "ja": "所定のノードIDまたはリソース-IDにメッセージを発信するために、ノードは、適切な宛先のリストを構築しなければなりません。最も単純な宛先リストは、ノードIDまたはリソース-IDを含む単一のエントリです。得られたメッセージは、通常のオーバーレイルーティングメカニズムを介して宛先に転送されなければなりません。ノードは、ソースルーティングのためのより複雑な送信先リストを構築することができます。"
    },
    {
      "indent": 3,
      "text": "Once the message is constructed, the node sends the message to an adjacent peer. If the first entry on the Destination List is directly connected, then the message MUST be routed down that connection. Otherwise, the Topology Plug-in MUST be consulted to determine the appropriate next hop.",
      "ja": "メッセージが構築されると、ノードは、隣接ピアにメッセージを送信します。宛先リストの最初のエントリが直接接続されている場合は、そのメッセージは、その接続ダウンルーティングする必要があります。それ以外の場合は、トポロジプラグインは、適切な次のホップを決定するために相談しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Parallel requests for a resource are a common solution to improve reliability in the face of churn or subversive peers. Parallel searches for usage-specified replicas are managed by the usage layer, for instance, by having the usage store data at multiple Resource-IDs, with the requesting node sending requests to each of those Resource-IDs. However, a single request MAY also be routed through multiple adjacent peers, even when they are known to be suboptimal, to improve reliability [vulnerabilities-acsac04]. Such parallel searches MAY be specified by the Topology Plug-in, in which case it would return multiple next hops and the request would be routed to all of them.",
      "ja": "リソースの並列要求が解約又は破壊仲間の顔の信頼性を向上させるための一般的なソリューションです。利用指定レプリカの並列検索は、例えば、それらのリソース-IDのそれぞれに要求を送信する要求ノードと、複数の資源のIDで利用ストアデータを有することにより、使用層によって管理されています。しかし、単一の要求は、[脆弱性-acsac04】信頼性を向上させるために、それらは準最適であることが知られている場合でも、複数の隣接ピアを介してルーティングすることができます。このような並列検索は、それが複数の次のホップを返すと、要求はそれらのすべてにルーティングされ、その場合には、トポロジプラグインで指定することができます。"
    },
    {
      "indent": 3,
      "text": "Because messages can be lost in transit through the overlay, RELOAD incorporates an end-to-end reliability mechanism. When an originating node transmits a request, it MUST set a timer to the current overlay-reliability-timer. If a response has not been received when the timer fires, the request MUST be retransmitted with the same transaction identifier. The request MAY be retransmitted up to 4 times, for a total of 5 messages. After the timer for the fifth transmission fires, the message MUST be considered to have failed.",
      "ja": "メッセージは、オーバーレイを通じて輸送中に失われる可能性があるため、RELOADは、エンドツーエンドの信頼性のメカニズムが組み込まれています。発信元ノードが要求を送信すると、それは現在のオーバーレイ信頼性タイマーにタイマーを設定しなければなりません。とき、タイマーが起動応答が受信されていない場合、要求は同じトランザクション識別子を再送信しなければなりません。要求は5つのメッセージの合計のために、4回まで再送信されることができます。第五の伝送火災のためのタイマーの後、メッセージが失敗したと考えなければなりません。"
    },
    {
      "indent": 3,
      "text": "Although the originating node will be doing both end-to-end and hop-by-hop retransmissions, the end-by-end retransmission procedure is not followed by intermediate nodes. They follow the hop-by-hop reliability procedure described in Section 6.6.3.",
      "ja": "発信元ノードは、両方のエンド・ツー・エンドとホップバイホップ再送を行うことになるが、エンド・バイ・エンド再送手順は、中間ノードが続きません。彼らは、セクション6.6.3で説明したホップバイホップ信頼性の手順に従ってください。"
    },
    {
      "indent": 3,
      "text": "The above algorithm can result in multiple requests being delivered to a node. Receiving nodes MUST generate semantically equivalent responses to retransmissions of the same request (this can be determined by the transaction ID) if the request is received within the maximum request lifetime (15 seconds). For some requests (e.g., Fetch), this can be accomplished merely by processing the request again. For other requests (e.g., Store), it may be necessary to maintain state for the duration of the request lifetime.",
      "ja": "上記のアルゴリズムは、ノードに配信される複数の要求をもたらすことができます。受信ノードは、同じ要求の再送要求が最大リクエストライフタイム（15秒）内に受信された場合（これは、トランザクションIDによって決定することができる）と意味的に同等の応答を生成しなければなりません。いくつかの要求（例えば、フェッチ）のために、これは再び要求を処理するだけで達成することができます。他の要求（例えば、ストア）のために、要求寿命の期間の状態を維持する必要があるかもしれません。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Response Origination",
      "section_title": true,
      "ja": "6.2.2。レスポンスオリジ"
    },
    {
      "indent": 3,
      "text": "When a peer sends a response to a request using this routing algorithm, it MUST construct the Destination List by reversing the order of the entries on the Via List. This has the result that the response traverses the same peers as the request traversed, except in reverse order (symmetric routing) and possibly with extra nodes (loose routing).",
      "ja": "ピアがこのルーティングアルゴリズムを使用して要求に対する応答を送信すると、それは経由リスト上のエントリの順序を逆にすることによって宛先リストを作成する必要があります。この応答は、逆の順序（対称ルーティング）およびおそらく余分なノードと（ルーズルーティング）を除いて、要求が横断同じピアを横断するという結果を有します。"
    },
    {
      "indent": 0,
      "text": "6.3. Message Structure",
      "section_title": true,
      "ja": "6.3。メッセージ構造"
    },
    {
      "indent": 3,
      "text": "RELOAD is a message-oriented request/response protocol. The messages are encoded using binary fields. All integers are represented in network byte order. The general philosophy behind the design was to use Type, Length, Value (TLV) fields to allow for extensibility. However, for the parts of a structure that were required in all messages, we just define these in a fixed position, as adding a type and length for them is unnecessary and would only increase bandwidth and introduce new potential interoperability issues.",
      "ja": "リロードがメッセージ指向要求/応答プロトコルです。メッセージは、バイナリフィールドを使用してエンコードされています。すべての整数はネットワークバイトオーダーで表されます。デザインの背後にある一般的な哲学は、拡張性を可能にするタイプ、長さ、値（TLV）フィールドを使用することでした。しかし、すべてのメッセージに必要とされた構造の部品のために、私たちはこれらが彼らのためにタイプと長さを追加するなど、一定の位置に定義することは不要であり、唯一の帯域幅を増加し、新たな可能性、相互運用性の問題を導入します。"
    },
    {
      "indent": 3,
      "text": "Each message has three parts, which are concatenated, as shown below:",
      "ja": "各メッセージは、以下に示すように、連結された3つの部分を有しています。"
    },
    {
      "indent": 5,
      "text": "+-------------------------+\n|    Forwarding Header    |\n+-------------------------+\n|    Message Contents     |\n+-------------------------+\n|     Security Block      |\n+-------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of these parts are as follows:",
      "ja": "次のようにこれらの部品の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Forwarding Header: Each message has a generic header which is used to forward the message between peers and to its final destination. This header is the only information that an intermediate peer (i.e., one that is not the target of a message) needs to examine. Section 6.3.2 describes the format of this part.",
      "ja": "転送ヘッダ：各メッセージは、ピア間で、その最終的な宛先にメッセージを転送するために使用される一般的なヘッダを有しています。このヘッダは、中間ピア（すなわち、メッセージの対象ではないもの）を調べる必要がある唯一の情報です。 6.3.2項では、この部分の形式について説明します。"
    },
    {
      "indent": 3,
      "text": "Message Contents: The message being delivered between the peers. From the perspective of the forwarding layer, the contents are opaque; however, they are interpreted by the higher layers. Section 6.3.3 describes the format of this part.",
      "ja": "メッセージ内容：メッセージは、ピア間で配信されます。転送レイヤの観点から、コンテンツは不透明です。しかし、彼らは、上位層によって解釈されます。 6.3.3項では、この部分の形式について説明します。"
    },
    {
      "indent": 3,
      "text": "Security Block: A security block containing certificates and a digital signature over the \"Message Contents\" section. Note that this signature can be computed without parsing the message contents. All messages MUST be signed by their originator. Section 6.3.4 describes the format of this part.",
      "ja": "セキュリティブロック：「メッセージの内容」セクションの上に証明書とデジタル署名を含むセキュリティブロック。この署名は、メッセージの内容を解析することなく計算することができることに留意されたいです。すべてのメッセージは、その発信元によって署名されなければなりません。 6.3.4項では、この部分の形式について説明します。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Presentation Language",
      "section_title": true,
      "ja": "6.3.1。プレゼンテーション言語"
    },
    {
      "indent": 3,
      "text": "The structures defined in this document are defined using a C-like syntax based on the presentation language used to define TLS [RFC5246]. Advantages of this style include:",
      "ja": "この文書で定義された構造は、TLS [RFC5246]を定義するために使用されるプレゼンテーション言語に基づいて、Cのような構文を使用して定義されています。このスタイルの利点は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o It is familiar enough that most readers can grasp it quickly.",
      "ja": "Oほとんどの読者はすぐにそれを把握することができることを十分に熟知しています。"
    },
    {
      "indent": 3,
      "text": "o The ability to define nested structures allows a separation between high-level and low-level message structures.",
      "ja": "ネストされた構造を定義する能力oをハイレベルとローレベルのメッセージ構造との間の分離を可能にします。"
    },
    {
      "indent": 3,
      "text": "o It has a straightforward wire encoding that allows quick implementation, but the structures can be comprehended without knowing the encoding.",
      "ja": "Oそれは迅速な実装を可能にする簡単なワイヤエンコーディングを持っていますが、構造は、エンコーディングを知らなくても把握することができます。"
    },
    {
      "indent": 3,
      "text": "o It is possible to mechanically compile encoders and decoders.",
      "ja": "O機械的にエンコーダとデコーダをコンパイルすることが可能です。"
    },
    {
      "indent": 3,
      "text": "Several idiosyncrasies of this language are worth noting:",
      "ja": "この言語のいくつかの特異性は注目に値します。"
    },
    {
      "indent": 3,
      "text": "o All lengths are denoted in bytes, not objects.",
      "ja": "Oすべての長さはバイトではなく、オブジェクトで表されています。"
    },
    {
      "indent": 3,
      "text": "o Variable-length values are denoted like arrays, with angle brackets.",
      "ja": "O可変長値は角括弧で、アレイのように示されています。"
    },
    {
      "indent": 3,
      "text": "o \"select\" is used to indicate variant structures.",
      "ja": "O「を選択し、」バリアントの構造を示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "For instance, \"uint16 array<0..2^8-2>;\" represents up to 254 bytes, which corresponds to up to 127 values of two bytes (16 bits) each.",
      "ja": "例えば、 \"uint16の配列<0..2 ^ 8-2>;\" 2バイト（16ビット）毎の最大値127に相当する254のバイトまでを表します。"
    },
    {
      "indent": 3,
      "text": "A repetitive structure member shares a common notation with a member containing a variable-length block of data. The latter always starts with \"opaque\", whereas the former does not. For instance, the following denotes a variable block of data:",
      "ja": "繰り返し構造部材を共有データの可変長ブロックを含む部材と共通の表記法。前者はないのに対し、後者は常に、「不透明」で始まります。例えば、以下は、データの可変長ブロックを表します。"
    },
    {
      "indent": 21,
      "text": "opaque data<0..2^32-1>;",
      "ja": "不透明なデータ<0..2 ^ 32-1>;"
    },
    {
      "indent": 3,
      "text": "whereas the following denotes a list of 0, 1, or more instances of the Name element:",
      "ja": "以下は、Name要素の0、1、または複数のインスタンスのリストを示し、一方。"
    },
    {
      "indent": 21,
      "text": "Name names<0..2^32-1>;",
      "ja": "名前に名前を付け、<0..2 ^ 32-1>;"
    },
    {
      "indent": 0,
      "text": "6.3.1.1. Common Definitions",
      "section_title": true,
      "ja": "6.3.1.1。共通の定義"
    },
    {
      "indent": 3,
      "text": "This section provides an introduction to the presentation language used throughout RELOAD.",
      "ja": "このセクションでは、RELOAD全体で使用されるプレゼンテーション言語を紹介します。"
    },
    {
      "indent": 3,
      "text": "An enum represents an enumerated type. The values associated with each possibility are represented in parentheses, and the maximum value is represented as a nameless value, for purposes of describing the width of the containing integral type. For instance, Boolean represents a true or false:",
      "ja": "列挙型は、列挙型を表します。各可能性に関連する値は括弧内に表され、そして最大値を含む一体型の幅を説明するために、無名の値として表されます。例えば、ブールは、真または偽を表します。"
    },
    {
      "indent": 9,
      "text": "enum { false(0), true(1), (255) } Boolean;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A boolean value is either a 1 or a 0. The max value of 255 indicates that this is represented as a single byte on the wire.",
      "ja": "ブール値は、255の最大値は、これは、ワイヤ上の単一バイトとして表されていることを示す1または0のいずれかです。"
    },
    {
      "indent": 3,
      "text": "The NodeId, shown below, represents a single Node-ID.",
      "ja": "以下に示すNODEIDは、単一のノードIDを表します。"
    },
    {
      "indent": 13,
      "text": "typedef opaque NodeId[NodeIdLength];",
      "ja": "typedefの不透明NODEID [NodeIdLength]。"
    },
    {
      "indent": 3,
      "text": "A NodeId is a fixed-length structure represented as a series of bytes, with the most significant byte first. The length is set on a per-overlay basis within the range of 16-20 bytes (128 to 160 bits). (See Section 11.1 for how NodeIdLength is set.) Note that the use of \"typedef\" here is an extension to the TLS language, but its meaning should be relatively obvious. Also note that the [ size ] syntax defines a fixed-length element that does not include the length of the element in the on-the-wire encoding.",
      "ja": "NODEIDは、最上位バイトと、バイト列として表される固定長の構造です。長さは、16〜20バイト（128〜160ビット）の範囲内当たりオーバーレイに基づいて設定されます。 （NodeIdLengthの設定方法については、セクション11.1を参照してください。）「のtypedef」の使用は、ここでTLS言語への拡張であるが、その意味は、比較的明白でなければならないことに注意してください。また、[サイズ]構文はオン・ザ・ワイヤエンコーディングの要素の長さを含んでいない固定長の要素を定義することに注意してください。"
    },
    {
      "indent": 3,
      "text": "A ResourceId, shown below, represents a single Resource-ID.",
      "ja": "以下に示すRESOURCEIDは、単一のリソース-IDを表します。"
    },
    {
      "indent": 13,
      "text": "typedef opaque ResourceId<0..2^8-1>;",
      "ja": "typedefの不透明RESOURCEID <0..2 ^ 8-1>。"
    },
    {
      "indent": 3,
      "text": "Like a NodeId, a ResourceId is an opaque string of bytes, but unlike NodeIds, ResourceIds are variable length, up to 254 bytes (2040 bits) in length. On the wire, each ResourceId is preceded by a single length byte (allowing lengths up to 255 bytes). Thus, the 3-byte value \"FOO\" would be encoded as: 03 46 4f 4f. Note the < range > syntax defines a variable length element that includes the length of the element in the on-the-wire encoding. The number of bytes to encode the length on the wire is derived by range; i.e., it is the minimum number of bytes which can encode the largest range value.",
      "ja": "NODEIDように、RESOURCEIDバイトの不透明な文字列であるが、ノード識別子とは異なり、ResourceIdsは、長さが254バイト（2040ビット）まで、可変長です。ワイヤ上の、各RESOURCEIDは、（255バイトまでの長さを可能にする）単一の長さのバイトが先行します。 03 46 4F 4F：したがって、3バイトの値「FOO」はとして符号化されるであろう。 <範囲>構文がオン・ザ・ワイヤ符号化における要素の長さを含む可変長の要素を定義する注意。バイト数は、範囲によって導出されたワイヤ上の長さを符号化します。すなわち、それは、最大範囲値を符号化することができる最小バイト数です。"
    },
    {
      "indent": 3,
      "text": "A more complicated example is IpAddressPort, which represents a network address and can be used to carry either an IPv6 or IPv4 address:",
      "ja": "より複雑な例では、ネットワークアドレスを表すとIPv6又はIPv4アドレスのどちらかを運ぶために使用することができるIpAddressPort、です。"
    },
    {
      "indent": 8,
      "text": "enum { invalidAddressType(0), ipv4_address(1), ipv6_address(2),\n     (255) } AddressType;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  uint32                  addr;\n  uint16                  port;\n} IPv4AddrPort;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  uint128                 addr;\n  uint16                  port;\n} IPv6AddrPort;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  AddressType             type;\n  uint8                   length;",
      "raw": true
    },
    {
      "indent": 10,
      "text": "select (type) { case ipv4_address: IPv4AddrPort v4addr_port;",
      "ja": "（タイプ）{ケースipv4_address選択：IPv4AddrPortのv4addr_portと、"
    },
    {
      "indent": 12,
      "text": "case ipv6_address: IPv6AddrPort v6addr_port;",
      "ja": "ケースはipv6_address：IPv6AddrPortのv6addr_portを。"
    },
    {
      "indent": 8,
      "text": "    /* This structure can be extended */\n  };\n} IpAddressPort;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first two fields in the structure are the same no matter what kind of address is being represented:",
      "ja": "構造体の最初の2つのフィールドが表現されているアドレスの種類に関係なく、同じではありません。"
    },
    {
      "indent": 3,
      "text": "type: The type of address (IPv4 or IPv6).",
      "ja": "タイプ：アドレスのタイプ（IPv4またはIPv6）。"
    },
    {
      "indent": 3,
      "text": "length: The length of the rest of the structure.",
      "ja": "長さ：構造体の残りの部分の長さ。"
    },
    {
      "indent": 3,
      "text": "By having the type and the length appear at the beginning of the structure regardless of the kind of address being represented, an implementation which does not understand new address type X can still parse the IpAddressPort field and then discard it if it is not needed.",
      "ja": "タイプと長さを有することによりかかわらず、新しいアドレスタイプXはまだIpAddressPortフィールドを解析し、それが必要とされていない場合は、それを破棄することができます理解していない実装を表現しているアドレスの種類の構造の先頭に表示されます。"
    },
    {
      "indent": 3,
      "text": "The rest of the IpAddressPort structure is either an IPv4AddrPort or an IPv6AddrPort. Both of these simply consist of an address represented as an integer and a 16-bit port. As an example, here is the wire representation of the IPv4 address \"192.0.2.1\" with port \"6084\".",
      "ja": "IpAddressPort構造の残りの部分はIPv4AddrPortかIPv6AddrPortのいずれかです。これらの両方は、単に整数と16ビットポートとして表されるアドレスから成ります。一例として、ここではポート「6084」のIPv4アドレス「192.0.2.1」のワイヤ表現です。"
    },
    {
      "indent": 13,
      "text": "01           ; type    = IPv4\n06           ; length  = 6\nc0 00 02 01  ; address = 192.0.2.1\n17 c4        ; port    = 6084",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Unless a given structure that uses a select explicitly allows for unknown types in the select, any unknown type SHOULD be treated as a parsing error, and the whole message SHOULD be discarded with no response.",
      "ja": "選択を使用し、所与の構造が明示的に選択中の未知のタイプを可能にしない限り、任意の未知のタイプは、解析エラーとして扱われるべきであり、メッセージ全体が応答なしで廃棄されるべきです。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Forwarding Header",
      "section_title": true,
      "ja": "6.3.2。転送ヘッダ"
    },
    {
      "indent": 3,
      "text": "The forwarding header is defined as a ForwardingHeader structure, as shown below.",
      "ja": "以下に示すように、転送ヘッダは、ForwardingHeader構造として定義されます。"
    },
    {
      "indent": 8,
      "text": "struct {\n  uint32             relo_token;\n  uint32             overlay;\n  uint16             configuration_sequence;\n  uint8              version;\n  uint8              ttl;\n  uint32             fragment;\n  uint32             length;\n  uint64             transaction_id;\n  uint32             max_response_length;\n  uint16             via_list_length;\n  uint16             destination_list_length;\n  uint16             options_length;\n  Destination        via_list[via_list_length];\n  Destination        destination_list\n                       [destination_list_length];\n  ForwardingOption   options[options_length];\n} ForwardingHeader;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of the structure are:",
      "ja": "構造体の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "relo_token: The first four bytes identify this message as a RELOAD message. This field MUST contain the value 0xd2454c4f (the string \"RELO\" with the high bit of the first byte set).",
      "ja": "relo_token：最初の4つのバイトは、リロードメッセージとしてメッセージを識別する。このフィールドには値0xd2454c4f（最初のバイトのセットの高ビットの文字列「RELO」）を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "overlay: The 32-bit checksum/hash of the overlay being used. This MUST be formed by taking the lower 32 bits of the SHA-1 [RFC3174] hash of the overlay name. The purpose of this field is to allow nodes to participate in multiple overlays and to detect accidental misconfiguration. This is not a security-critical function. The overlay name MUST consist of a sequence of characters that would be allowable as a DNS name. Specifically, as it is used in a DNS lookup, it will need to be compliant with the grammar for the domain as specified in Section 2.3.1 of [RFC1035].",
      "ja": "オーバーレイ：オーバーレイの32ビットチェックサム/ハッシュが使用されています。これは、オーバーレイ名のSHA-1 [RFC3174]ハッシュの下位32ビットを取ることによって形成されなければなりません。このフィールドの目的は、ノードが複数のオーバーレイに参加すると、偶然の設定ミスを検出することができるようにすることです。これは、セキュリティ上重要な機能ではありません。オーバーレイ名がDNS名として許容だろう文字の並びで構成する必要があります。それはDNSルックアップで使用されるよう具体的には、[RFC1035]のセクション2.3.1で指定されたドメインの文法に準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "configuration_sequence: The sequence number of the configuration file. See Section 6.3.2.1 for details.",
      "ja": "configuration_sequence：設定ファイルのシーケンス番号。詳細については、6.3.2.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "version: The version of the RELOAD protocol being used times 10. RELOAD version numbers are fixed-point decimal numbers between fixed-point integer between 0.1 and 25.4. This document describes version 1.0, with a value of 0x0a. (Note that versions used prior to the publication of this RFC used version number 0.1.) Nodes MUST reject messages with other versions.",
      "ja": "バージョン：リロードプロトコルのバージョンが回使用されている10.リロードバージョン番号0.1と25.4との間の固定小数点整数との間の固定小数点小数番号です。この文書では、0x0Aの値と、バージョン1.0について説明します。 （従来、このRFCの出版物に使用されるバージョンは、バージョン番号0.1を使用することに留意されたい。）ノードは、他のバージョンでメッセージを拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "ttl: An 8-bit field indicating the number of iterations, or hops, a message can experience before it is discarded. The TTL (time-to-live) value MUST be decremented by one at every hop along the route the message traverses just before transmission. If a received message has a TTL of 0 and the message is not destined for the receiving node, then the message MUST NOT be propagated further, and an Error_TTL_Exceeded error should be generated. The initial value of the TTL SHOULD be 100 and MUST NOT exceed 100 unless defined otherwise by the overlay configuration. Implementations which receive messages with a TTL greater than the current value of initial-ttl (or the default of 100) MUST discard the message and send an Error_TTL_Exceeded error.",
      "ja": "TTL：反復、またはホップの数を示す8ビットのフィールドは、その前に体験することができ、メッセージは破棄されます。 TTL（生存時間）値は、メッセージが単に送信する前に横断する経路に沿ったすべてのホップに1ずつデクリメントされなければなりません。受信したメッセージが0のTTLを有し、メッセージが受信ノードに宛てていない場合、メッセージはさらに伝播してはいけません、そしてError_TTL_Exceededエラーが発生しなければなりません。 TTLの初期値は100であるべきであり、オーバーレイ構成によって特に定義されない限り、100を超えてはなりません。初期TTL（又は100のデフォルト）の現在の値よりも大きいTTLと共にメッセージを受信する実装は、メッセージを破棄してError_TTL_Exceededエラーを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "fragment: This field is used to handle fragmentation. The high bit (0x80000000) MUST be set for historical reasons. If the next bit (0x40000000) is set to 1, it indicates that this is the last (or only) fragment. The next six bits (0x20000000 through 0x01000000) are reserved and SHOULD be set to zero. The remainder of the field is used to indicate the fragment offset; see Section 6.7 for details.",
      "ja": "フラグメント：このフィールドは、断片化を処理するために使用されます。高ビット（0×80000000）は、歴史的な理由のために設定しなければなりません。次のビット（0x40000000から）が1に設定されている場合、これが最後の（または唯一の）断片であることを示しています。次の6ビット（が0x01000000スルー0x20000000）が予約され、ゼロに設定されるべきです。フィールドの残りの部分は、フラグメントオフセットを示すために使用されます。詳細については、セクション6.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "length: The count in bytes of the size of the message, including the header, after the eventual fragmentation.",
      "ja": "長さ：ヘッダを含むメッセージのサイズのバイトのカウント、最終的な断片化後。"
    },
    {
      "indent": 3,
      "text": "transaction_id: A unique 64-bit number that identifies this transaction and also allows receivers to disambiguate transactions which are otherwise identical. In order to provide a high probability that transaction IDs are unique, they MUST be randomly generated. Responses use the same transaction ID as the request to which they correspond. Transaction IDs are also used for fragment reassembly. See Section 6.7 for details.",
      "ja": "TRANSACTION_ID：このトランザクションを識別し、また、受信機が他の点では同一である取引を明確にすることを可能にする固有の64ビット数。トランザクションIDが一意であることを高い確率を提供するために、彼らはランダムに生成されなければなりません。応答は、彼らが対応する要求と同じトランザクションIDを使用します。トランザクションIDはまた、フラグメント再構成のために使用されています。詳細については、セクション6.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "max_response_length: The maximum size in bytes of a response. This is used by requesting nodes to avoid receiving (unexpected) very large responses. If this value is non-zero, responding peers MUST check that any response would not exceed it and if so generate an Error_Incompatible_with_Overlay value. This value SHOULD be set to zero for responses.",
      "ja": "max_response_length：応答のバイト単位の最大サイズ。これは、（予期しない）非常に大きな応答を受信しないようにするためにノードに要求することによって使用されています。この値がゼロ以外の場合は、応答ピアはそうError_Incompatible_with_Overlay値を生成する場合は任意の応答はそれを超えないことをチェックしなければなりません。この値は、応答のためにゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "via_list_length: The length of the Via List in bytes. Note that in this field and the following two length fields, we depart from the usual variable-length convention of having the length immediately precede the value, in order to make it easier for hardware decoding engines to quickly determine the length of the header.",
      "ja": "via_list_length：バイト単位経由リストの長さ。このフィールド次の2つの長さフィールドに、我々はそれが簡単にハードウェア復号化エンジンを迅速ヘッダの長さを決定するために作るためには、長さがすぐ値の前に有する通常の可変長規則から逸脱することに注意してください。"
    },
    {
      "indent": 3,
      "text": "destination_list_length: The length of the Destination List in bytes.",
      "ja": "destination_list_length：バイト単位の送信先リストの長さ。"
    },
    {
      "indent": 3,
      "text": "options_length: The length of the header options in bytes.",
      "ja": "options_length：バイトのヘッダオプションの長さ。"
    },
    {
      "indent": 3,
      "text": "via_list: The via_list contains the sequence of destinations through which the message has passed. The via_list starts out empty and grows as the message traverses each peer. In stateless cases, the previous hop that the message is from is appended to the Via List as specified in Section 6.1.2.",
      "ja": "via_list：via_listは、メッセージが通過した目的地の配列を含みます。 via_listは空から始まり、メッセージが各ピアを横断するように成長します。ステートレスな場合には、6.1.2項で指定されたメッセージは、経由リストに追加されたからである前のホップ。"
    },
    {
      "indent": 3,
      "text": "destination_list: The destination_list contains a sequence of destinations through which the message should pass. The Destination List is constructed by the message originator. The first element on the Destination List is where the message goes next. Generally, the list shrinks as the message traverses each listed peer, though if list compression is used, this may not be true.",
      "ja": "destination_list：destination_listは、メッセージが通過する必要があり、それを通して目的地の配列を含みます。宛先リストは、メッセージの発信者によって構成されています。メッセージは次の行くところ宛先リストの最初の要素があります。リスト圧縮が使用される場合、これは真ではないかもしれないけれども、メッセージは、リストされた各ピアを横断するように、一般的に、リストが収縮します。"
    },
    {
      "indent": 3,
      "text": "options: Contains a series of ForwardingOption entries. See Section 6.3.2.3.",
      "ja": "オプション：ForwardingOptionの一連のエントリが含まれています。 6.3.2.3項を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.3.2.1. Processing Configuration Sequence Numbers",
      "section_title": true,
      "ja": "6.3.2.1。処理構成のシーケンス番号"
    },
    {
      "indent": 3,
      "text": "In order to be part of the overlay, a node MUST have a copy of the overlay Configuration Document. In order to allow for configuration document changes, each version of the Configuration Document MUST contain a sequence number which MUST be monotonically increasing mod 65535. Because the sequence number may, in principle, wrap, greater than or less than are interpreted by modulo arithmetic as in TCP.",
      "ja": "オーバーレイの一部であるために、ノードは、オーバーレイ設定文書のコピーが必要です。シーケンス番号は、原則的に包むことができるので、構成ドキュメントの変更を可能にするために、設定文書の各バージョンは、以上のようにモジュロ演算によって解釈されるよりも、単調MOD 65535を増加しなければならないシーケンス番号を含まなければなりませんTCPインチ"
    },
    {
      "indent": 3,
      "text": "When a destination node receives a request, it MUST check that the configuration_sequence field is equal to its own configuration sequence number. If they do not match, the node MUST generate an error, either Error_Config_Too_Old or Error_Config_Too_New. In addition, if the configuration file in the request is too old, the node MUST generate a ConfigUpdate message to update the requesting node. This allows new Configuration Documents to propagate quickly throughout the system. The one exception to this rule is that if the configuration_sequence field is equal to 65535 and the message type is ConfigUpdate, then the message MUST be accepted regardless of the receiving node's configuration sequence number. Since 65535 is a special value, peers sending a new configuration when the configuration sequence is currently 65534 MUST set the configuration sequence number to 0 when they send a new configuration.",
      "ja": "宛先ノードが要求を受信すると、configuration_sequenceフィールドは、独自の設定のシーケンス番号と等しいことをチェックしなければなりません。彼らが一致しない場合、ノードは、Error_Config_Too_OldまたはError_Config_Too_Newのいずれかを、エラーを発生させなければなりません。リクエストで設定ファイルが古すぎる場合また、ノードが要求ノードを更新するためにあるConfigUpdateメッセージを発生させなければなりません。これは、新しい構成文書がシステム全体に急速に伝播することができます。このルールの唯一の例外はconfiguration_sequenceフィールドが65535に等しく、メッセージの種類があるConfigUpdateである場合、メッセージは関係なく、受信ノードの構成シーケンス番号の受け入れなければならないことです。 65535は特別な値であるので、彼らは新しい構成を送信するときに、コンフィギュレーション・シーケンスは現在65534のときに新しい設定を送信するピアは0に設定シーケンス番号を設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.3.2.2. Destination and Via Lists",
      "section_title": true,
      "ja": "6.3.2.2。目的地や経由リスト"
    },
    {
      "indent": 3,
      "text": "The Destination List and Via List are sequences of Destination values:",
      "ja": "宛先リストを介して一覧デスティネーション値の配列であります："
    },
    {
      "indent": 5,
      "text": "enum { invalidDestinationType(0), node(1), resource(2),\n       opaque_id_type(3), /* 128-255 not allowed */ (255) }\n     DestinationType;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "select (destination_type) { case node: NodeId node_id;",
      "ja": "選択（destination_type）{ケースノード：NODEID NODE_ID。"
    },
    {
      "indent": 6,
      "text": "case resource: ResourceId resource_id;",
      "ja": "ケースの資源：RESOURCEID RESOURCE_ID。"
    },
    {
      "indent": 6,
      "text": "case opaque_id_type: opaque opaque_id<0..2^8-1>;",
      "ja": "ケースopaque_id_type：不透明opaque_id <0..2 ^ 8-1>。"
    },
    {
      "indent": 5,
      "text": "     /* This structure may be extended with new types */\n} DestinationData;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "struct {\n   DestinationType         type;\n   uint8                   length;\n   DestinationData         destination_data;\n} Destination;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "struct {\n   uint16               opaque_id; /* Top bit MUST be 1 */\n} Destination;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the destination structure is a 16-bit integer, then the first bit MUST be set to 1, and it MUST be treated as if it were a full structure with a DestinationType of opaque_id_type and an opaque_id that was 2 bytes long with the value of the 16-bit integer. If the destination structure starts with DestinationType, then the first bit MUST be set to 0, and the destination structure must use a TLV structure with the following contents:",
      "ja": "先の構造は、16ビットの整数である場合、最初のビットが1に設定しなければなりません、そして、それはopaque_id_typeのおよびDestinationTypeの値と2バイト長であったopaque_idと完全構造であったかのように扱われなければなりません16ビット整数。先の構造は、およびDestinationTypeで始まる場合、最初のビットが0に設定しなければなりません、宛先構造は、次の内容でTLV構造を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "type The type of the DestinationData Payload Data Unit (PDU). It may be one of \"node\", \"resource\", or \"opaque_id_type\".",
      "ja": "DestinationDataペイロードデータユニット（PDU）のタイプを入力します。これは、「ノード」、「リソース」、または「opaque_id_type」のいずれであってもよいです。"
    },
    {
      "indent": 3,
      "text": "length The length of the destination_data.",
      "ja": "長さdestination_dataの長さ。"
    },
    {
      "indent": 3,
      "text": "destination_data The destination value itself, which is an encoded DestinationData structure that depends on the value of \"type\".",
      "ja": "「タイプ」の値に依存する符号化されたDestinationData構造である宛先値そのもの、destination_data。"
    },
    {
      "indent": 3,
      "text": "Note that the destination structure encodes a Type, Length, Value. The Length field specifies the length of the DestinationData values, which allows the addition of new DestinationTypes. It also allows an implementation which does not understand a given DestinationType to skip over it.",
      "ja": "先の構造は、タイプ、長さ、値をコード化することに留意されたいです。 Lengthフィールドは、新しいDestinationTypesの追加を可能にする、DestinationData値の長さを指定します。また、それをスキップするために与えられたおよびDestinationTypeを理解していない実装することができます。"
    },
    {
      "indent": 3,
      "text": "A DestinationData can be one of three types:",
      "ja": "DestinationDataは、3種類のいずれかになります。"
    },
    {
      "indent": 3,
      "text": "node A Node-ID.",
      "ja": "ノードIDをノード。"
    },
    {
      "indent": 3,
      "text": "opaque A compressed list of Node-IDs and an eventual Resource-ID. Because this value has been compressed by one of the peers, it is meaningful only to that peer and cannot be decoded by other peers. Thus, it is represented as an opaque string.",
      "ja": "ノードIDの不透明圧縮リストと最終的な資源ID。この値は、ピアの1つによって圧縮されているため、それだけでそのピアに有意義であり、他のピアによって復号することができません。したがって、不透明な文字列として表現されます。"
    },
    {
      "indent": 3,
      "text": "resource The Resource-ID of the resource which is desired. This type MUST appear only in the final location of a Destination List and MUST NOT appear in a Via List. It is meaningless to try to route through a resource.",
      "ja": "所望されるリソースのリソース-IDリソース。このタイプは、唯一の宛先リストの最終的な場所に現れなければならないし、経由リストに現れてはいけません。リソースを経由するようにしようとすることは無意味です。"
    },
    {
      "indent": 3,
      "text": "One possible encoding of the 16-bit integer version as an opaque identifier is to encode an index into a Connection Table. To avoid misrouting responses in the event a response is delayed and the Connection Table entry has changed, the identifier SHOULD be split between an index and a generation counter for that index. When a Node first joins the overlay, the generation counters SHOULD be initialized to random values. An implementation MAY use 12 bits for the Connection Table index and 3 bits for the generation counter. (Note that this does not suggest a 4096-entry Connection Table for every peer, only the ability to encode for a larger Connection Table.) When a Connection Table slot is used for a new connection, the generation counter is incremented (with wrapping). Connection Table slots are used on a rotating basis to maximize the time interval between uses of the same slot for different connections. When routing a message to an entry in the Destination List encoding a Connection Table entry, the peer MUST confirm that the generation counter matches the current generation counter of that index before forwarding the message. If it does not match, the message MUST be silently dropped.",
      "ja": "不透明な識別子として16ビット整数バージョンの一つの可能​​な符号化は、接続テーブルへのインデックスを符号化することです。応答が遅延され、接続テーブルエントリが変更された場合にmisrouting応答を回避するために、識別子は、そのインデックスのインデックスと生成カウンタ間で分割されるべきです。ノードは最初のオーバーレイに参加すると、生成カウンタは、ランダムな値に初期化する必要があります。実装は、世代カウンタの接続テーブルインデックスの12ビットと3ビットを使用するかもしれません。接続テーブルスロットが新しい接続に使用されている場合（これは、すべてのピアの大きい接続テーブルをコードする唯一の能力を4096エントリ接続テーブルを示唆していないことに留意されたい。）、世代カウンタが（ラップで）増分されます。接続テーブルスロットは、異なる接続のために同じスロットの使用の間の時間間隔を最大にするために回転的に使用されます。接続テーブルエントリをコードする送信先リストのエントリにメッセージをルーティングする場合、ピアは、世代カウンタがメッセージを転送する前にそのインデックスの現在の世代カウンターと一致することを確認しなければなりません。それが一致しない場合、メッセージは静かに下げなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.3.2.3. Forwarding Option",
      "section_title": true,
      "ja": "6.3.2.3。転送オプション"
    },
    {
      "indent": 3,
      "text": "The Forwarding header can be extended with forwarding header options, which are a series of ForwardingOption structures:",
      "ja": "転送ヘッダはForwardingOption構造のシリーズである転送ヘッダ・オプションと拡張することができます。"
    },
    {
      "indent": 4,
      "text": "enum { invalidForwardingOptionType(0), (255) }\n  ForwardingOptionType;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "struct {\n  ForwardingOptionType      type;\n  uint8                     flags;\n  uint16                    length;\n  select (type) {\n        /* This type may be extended */\n  };\n} ForwardingOption;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each ForwardingOption consists of the following values:",
      "ja": "各ForwardingOptionは、以下の値で構成されています。"
    },
    {
      "indent": 3,
      "text": "type The type of the option. This structure allows for unknown options types.",
      "ja": "オプションの種類を入力します。この構造は、未知のオプションタイプが可能になります。"
    },
    {
      "indent": 3,
      "text": "flags Three flags are defined: FORWARD_CRITICAL(0x01), DESTINATION_CRITICAL(0x02), and RESPONSE_COPY(0x04). These flags MUST NOT be set in a response. If the FORWARD_CRITICAL flag is set, any peer that would forward the message but does not understand this option MUST reject the request with an Error_Unsupported_Forwarding_Option error response. If the DESTINATION_CRITICAL flag is set, any node that generates a response to the message but does not understand the forwarding option MUST reject the request with an Error_Unsupported_Forwarding_Option error response. If the RESPONSE_COPY flag is set, any node generating a response MUST copy the option from the request to the response except that the RESPONSE_COPY, FORWARD_CRITICAL, and DESTINATION_CRITICAL flags MUST be cleared.",
      "ja": "フラグ3つのフラグが定義されています。FORWARD_CRITICAL（0x01の）、DESTINATION_CRITICAL（0×02）、及びRESPONSE_COPY（0×04）。これらのフラグは対応して設定してはいけません。 FORWARD_CRITICALフラグが設定されている場合は、メッセージを転送しますが、このオプションを理解していない任意のピアはError_Unsupported_Forwarding_Optionエラー応答で要求を拒絶しなければなりません。 DESTINATION_CRITICALフラグが設定されている場合、メッセージへの応答を生成するが、転送オプションを理解していない任意のノードがError_Unsupported_Forwarding_Optionエラー応答で要求を拒絶しなければなりません。 RESPONSE_COPYフラグが設定されている場合、応答を生成する任意のノードは、リクエストからRESPONSE_COPY、FORWARD_CRITICAL、及びDESTINATION_CRITICALフラグがクリアされなければならないことを除いて応答するためのオプションをコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "length The length of the rest of the structure. Note that a 0 length may be reasonable if the mere presence of the option is meaningful and no value is required.",
      "ja": "長構造の残りの部分の長さ。オプションの単なる存在は有意義であり、値が必要とされない場合は0の長さが妥当であってもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "option The option value.",
      "ja": "オプションオプションの値。"
    },
    {
      "indent": 0,
      "text": "6.3.3. Message Contents Format",
      "section_title": true,
      "ja": "6.3.3。メッセージ内容のフォーマット"
    },
    {
      "indent": 3,
      "text": "The second major part of a RELOAD message is the contents part, which is defined by MessageContents:",
      "ja": "リロードメッセージの第二の主要な部分はMessageContentsによって定義されるコンテンツの一部です。"
    },
    {
      "indent": 3,
      "text": "enum { invalidMessageExtensionType(0),\n       (2^16-1) } MessageExtensionType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct {\n  MessageExtensionType  type;\n  Boolean               critical;\n  opaque                extension_contents<0..2^32-1>;\n} MessageExtension;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct {\n  uint16                 message_code;\n  opaque                 message_body<0..2^32-1>;\n  MessageExtension       extensions<0..2^32-1>;\n} MessageContents;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of this structure are as follows:",
      "ja": "次のようにこの構造体の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "message_code This indicates the message that is being sent. The code space is broken up as follows:",
      "ja": "これは、送信されるメッセージを示しmessage_codeに。次のようにコードスペースを分割されます。"
    },
    {
      "indent": 6,
      "text": "0x0 Invalid Message Code. This code will never be assigned.",
      "ja": "0x0の無効なメッセージコード。このコードは、割り当てられたことはありません。"
    },
    {
      "indent": 6,
      "text": "0x1 .. 0x7FFF Requests and responses. These code points are always paired, with requests being an odd value and the corresponding response being the request code plus 1. Thus, \"probe_request\" (the Probe request) has the value 1 and \"probe_answer\" (the Probe response) has the value 2",
      "ja": "0x1の... 0x7FFFの要求と応答。これらのコードポイントは常に要求が奇数値であると、対応する応答がこのよう要求コード1を加えた状態で、対になっている、「プローブリクエスト」（プローブリクエスト）が値1を有し、「probe_answer」（プローブ応答）の値を有します2"
    },
    {
      "indent": 6,
      "text": "0x8000 .. 0xFFFE Reserved",
      "ja": "0x8000の.. 0xFFFEという予約"
    },
    {
      "indent": 6,
      "text": "0xFFFF Error",
      "ja": "エラーが0xFFFF"
    },
    {
      "indent": 6,
      "text": "The message codes are defined in Section 14.8.",
      "ja": "メッセージコードは、セクション14.8で定義されています。"
    },
    {
      "indent": 3,
      "text": "message_body The message body itself, represented as a variable-length string of bytes. The bytes themselves are dependent on the code value. See the sections describing the various RELOAD methods (Join, Update, Attach, Store, Fetch, etc.) for the definitions of the payload contents.",
      "ja": "バイトの可変長文字列として表され、メッセージ本体自体を、MESSAGE_BODY。バイト自体はコード値に依存しています。ペイロードの内容の定義について（など、フェッチ、アタッチ、ストアを更新しよう）、各種RELOAD方法を記述したセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "extensions Extensions to the message. Currently no extensions are defined, but new extensions can be defined by the process described in Section 14.14.",
      "ja": "メッセージの拡張機能拡張機能。現在のところ、拡張が定義されていないが、新しい拡張機能は、セクション14.14に記載の方法で定義することができます。"
    },
    {
      "indent": 3,
      "text": "All extensions have the following form:",
      "ja": "すべての拡張機能は次の形式を持っています："
    },
    {
      "indent": 3,
      "text": "type The extension type.",
      "ja": "拡張タイプを入力します。"
    },
    {
      "indent": 3,
      "text": "critical Whether this extension needs to be understood in order to process the message. If critical = True and the recipient does not understand the message, it MUST generate an Error_Unknown_Extension error. If critical = False, the recipient MAY choose to process the message even if it does not understand the extension.",
      "ja": "この拡張機能は、メッセージを処理するために理解する必要があるかどうかを重要。 =重要な真と受信者がメッセージを理解していない場合、それはError_Unknown_Extensionエラーを発生させなければなりません。重要= Falseの場合、受信者は、それが拡張を理解していない場合でも、メッセージを処理するために選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "extension_contents The contents of the extension (which are extension dependent).",
      "ja": "（拡張依存している）拡張の内容をextension_contents。"
    },
    {
      "indent": 3,
      "text": "The subsections 6.4.2, 6.5, and 7 describe structures that are inserted inside the message_body member, depending on the value of the message_code value. For example, a message_code value of join_req means that the structure named JoinReq is inserted inside message_body. This document does not contain a mapping between message_code values and structure names, as the conversion between the two is obvious.",
      "ja": "サブセクション6.4.2、6.5、および7はmessage_codeに値の値に応じMESSAGE_BODY部材の内部に挿入される構造を記述する。例えば、join_reqのmessage_codeに値がJoinReq命名構造がMESSAGE_BODYの内側に挿入されることを意味します。両者の間の変換は明らかなようにこの文書は、message_codeに値と構造体名の間のマッピングが含まれていません。"
    },
    {
      "indent": 3,
      "text": "Similarly, this document uses the name of the structure without the \"Req\" or \"Ans\" suffix to mean the execution of a transaction consisting of the matching request and answer. For example, when the text says \"perform an Attach\", it must be understood as performing a transaction composed of an AttachReq and an AttachAns.",
      "ja": "同様に、このドキュメントは、マッチング要求と回答からなるトランザクションの実行を意味する「必須」または「答」接尾辞なしで構造体の名前を使用しています。たとえば、テキストは言うとき、それはAttachReqとAttachAnsで構成されるトランザクションを実行するものとして理解されなければならない、「アタッチを実行」。"
    },
    {
      "indent": 0,
      "text": "6.3.3.1. Response Codes and Response Errors",
      "section_title": true,
      "ja": "6.3.3.1。レスポンスコードとレスポンスのエラー"
    },
    {
      "indent": 3,
      "text": "A node processing a request MUST return its status in the message_code field. If the request was a success, then the message code MUST be set to the response code that matches the request (i.e., the next code up). The response payload is then as defined in the request/response descriptions.",
      "ja": "要求を処理ノードはmessage_codeにフィールドにそのステータスを返さなければなりません。リクエストが成功した場合は、メッセージコードは、要求（すなわち、次のコードまで）と一致する応答コードに設定しなければなりません。要求/応答記述で定義された応答ペイロードは次にあります。"
    },
    {
      "indent": 3,
      "text": "If the request has failed, then the message code MUST be set to 0xffff (error) and the payload MUST be an error_response message, as shown below.",
      "ja": "要求が失敗した場合、メッセージコードが0xffffの（エラー）に設定しなければならなくて、以下に示すように、ペイロードは、error_responseメッセージでなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the message code is 0xFFFF, the payload MUST be an ErrorResponse:",
      "ja": "メッセージコードが0xFFFFである場合、ペイロードははErrorResponseなければなりません。"
    },
    {
      "indent": 9,
      "text": "public struct {\n  uint16             error_code;\n  opaque             error_info<0..2^16-1>;\n} ErrorResponse;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of this structure are as follows:",
      "ja": "次のようにこの構造体の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "error_code A numeric error code indicating the error that occurred.",
      "ja": "発生したエラーを示す数値エラーコードをERROR_CODE。"
    },
    {
      "indent": 3,
      "text": "error_info An optional arbitrary byte string. Unless otherwise specified, this will be a UTF-8 text string that provides further information about what went wrong. Developers are encouraged to include enough diagnostic information to be useful in error_info. The specific text to be used and any relevant language or encoding thereof is left to the implementation.",
      "ja": "オプションの任意のバイトの文字列をERROR_INFO。特に指定しない限り、これは何が悪かったのかについての更なる情報を提供してUTF-8のテキスト文字列になります。開発者は、ERROR_INFOに有用であることが十分な診断情報を含めることをお勧めします。使用する特定のテキストおよび任意の関連する言語またはそのコードは、実装に委ねられます。"
    },
    {
      "indent": 3,
      "text": "The following error code values are defined. The numeric values for these are defined in Section 14.9.",
      "ja": "以下のエラーコード値が定義されています。これらの数値の値は、セクション14.9で定義されています。"
    },
    {
      "indent": 3,
      "text": "Error_Forbidden The requesting node does not have permission to make this request.",
      "ja": "Error_Forbidden要求ノードは、この要求をする権限がありません。"
    },
    {
      "indent": 3,
      "text": "Error_Not_Found The resource or node cannot be found or does not exist.",
      "ja": "ERROR_NOT_FOUNDリソースまたはノードが見つからないか、存在しません。"
    },
    {
      "indent": 3,
      "text": "Error_Request_Timeout A response to the request has not been received in a suitable amount of time. The requesting node MAY resend the request at a later time.",
      "ja": "要求に対する応答Error_Request_Timeout時間の適切な量で受信されていません。要求ノードは、後で要求を再送信することができます。"
    },
    {
      "indent": 3,
      "text": "Error_Data_Too_Old A store cannot be completed because the storage_time precedes the existing value.",
      "ja": "storage_timeは、既存の値の前にあるため店を完了することができませんError_Data_Too_Old。"
    },
    {
      "indent": 3,
      "text": "Error_Data_Too_Large A store cannot be completed because the requested object exceeds the size limits for that Kind.",
      "ja": "要求されたオブジェクトは、その種のサイズ制限を超えているためError_Data_Too_Largeストアが完了することはできません。"
    },
    {
      "indent": 3,
      "text": "Error_Generation_Counter_Too_Low A store cannot be completed because the generation counter precedes the existing value.",
      "ja": "生成カウンタは、既存の値の前にあるためError_Generation_Counter_Too_Lowストアが完了することができません。"
    },
    {
      "indent": 3,
      "text": "Error_Incompatible_with_Overlay A peer receiving the request is using a different overlay, overlay algorithm, or hash algorithm, or some other parameter that is inconsistent with the overlay configuration.",
      "ja": "要求を受信Error_Incompatible_with_Overlayピアは異なるオーバーレイ、オーバーレイアルゴリズムまたはハッシュアルゴリズム、またはオーバーレイの設定と矛盾しているいくつかの他のパラメータを使用しています。"
    },
    {
      "indent": 3,
      "text": "Error_Unsupported_Forwarding_Option A node received the request with a forwarding options flagged as critical, but the node does not support this option. See Section 6.3.2.3.",
      "ja": "Error_Unsupported_Forwarding_Optionノードは、重要としてフラグ付け転送オプションで要求を受けたが、ノードは、このオプションをサポートしていません。 6.3.2.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_TTL_Exceeded A peer received the request in which the TTL was decremented to zero. See Section 6.3.2.",
      "ja": "Error_TTL_Exceededピアは、TTLがゼロにデクリメントされた要求を受信しました。 6.3.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_Message_Too_Large A peer received a request that was too large. See Section 6.6.",
      "ja": "Error_Message_Too_Largeピアが大きすぎたリクエストを受けました。 6.6節を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_Response_Too_Large A node would have generated a response that is too large per the max_response_length field.",
      "ja": "Error_Response_Too_Largeノードはmax_response_lengthフィールドごとに大きすぎる応答を生成しているだろう。"
    },
    {
      "indent": 3,
      "text": "Error_Config_Too_Old A destination node received a request with a configuration sequence that is too old. See Section 6.3.2.1.",
      "ja": "宛先ノードが古すぎる設定シーケンスで要求を受けError_Config_Too_Old。 6.3.2.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_Config_Too_New A destination node received a request with a configuration sequence that is too new. See Section 6.3.2.1.",
      "ja": "Error_Config_Too_New宛先ノードが新しすぎる設定シーケンスで要求を受信しました。 6.3.2.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_Unknown_Kind A destination peer received a request with an unknown Kind-ID. See Section 7.4.1.2.",
      "ja": "Error_Unknown_Kind宛先ピアは、未知の種類-IDで要求を受信しました。セクション7.4.1.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_In_Progress An Attach to this peer is already in progress. See Section 6.5.1.2.",
      "ja": "Error_In_Progress Anがこのピアにアタッチすでに進行中です。 6.5.1.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Error_Unknown_Extension A destination node received a request with an unknown extension.",
      "ja": "Error_Unknown_Extension宛先ノードは、未知の拡張子を持つ要求を受信しました。"
    },
    {
      "indent": 3,
      "text": "Error_Invalid_Message Something about this message is invalid, but it does not fit the other error codes. When this message is sent, implementations SHOULD provide some meaningful description in error_info to aid in debugging.",
      "ja": "このメッセージに関するError_Invalid_Messageの何かが無効であるが、それは他のエラーコードが適合しません。このメッセージが送信されると、実装は、デバッグを支援するためにERROR_INFOにいくつかの意味のある説明を提供すべきです。"
    },
    {
      "indent": 3,
      "text": "Error_Exp_A For the purposes of experimentation. It is not meant for vendor-specific use of any sort and MUST NOT be used for operational deployments.",
      "ja": "実験の目的のためにError_Exp_A。これは、あらゆる種類のベンダー固有の使用のために意図されていないと業務展開のために使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "Error_Exp_B For the purposes of experimentation. It is not meant for vendor-specific use of any sort and MUST NOT be used for operational deployments.",
      "ja": "実験の目的のためにError_Exp_B。これは、あらゆる種類のベンダー固有の使用のために意図されていないと業務展開のために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "6.3.4. Security Block",
      "section_title": true,
      "ja": "6.3.4。セキュリティブロック"
    },
    {
      "indent": 3,
      "text": "The third part of a RELOAD message is the security block. The security block is represented by a SecurityBlock structure:",
      "ja": "リロードメッセージの第3の部分は、セキュリティブロックです。セキュリティブロックはSecurityBlock構造によって表されます："
    },
    {
      "indent": 3,
      "text": "struct {\n   CertificateType     type;   // From RFC 6091\n   opaque              certificate<0..2^16-1>;\n} GenericCertificate;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct {\n   GenericCertificate certificates<0..2^16-1>;\n   Signature          signature;\n} SecurityBlock;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of this structure are:",
      "ja": "この構造体の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "certificates A bucket of certificates.",
      "ja": "証明書証明書のバケツ。"
    },
    {
      "indent": 3,
      "text": "signature A signature.",
      "ja": "署名署名。"
    },
    {
      "indent": 3,
      "text": "The certificates bucket SHOULD contain all the certificates necessary to verify every signature in both the message and the internal message objects, except for those certificates in a root-cert element of the current configuration file. This is the only location in the message which contains certificates, thus allowing only a single copy of each certificate to be sent. In systems that have an alternative certificate distribution mechanism, some certificates MAY be omitted. However, unless an alternative mechanism for immediately generating certificates, such as shared secret security (Section 13.4) is used, implementers MUST include all referenced certificates.",
      "ja": "証明書のバケットは、現在の構成ファイルのルート証明書の要素にこれらの証明書を除き、メッセージおよび内部メッセージオブジェクトの両方のすべての署名を検証するために必要なすべての証明書を、含むべきです。これにより、各証明書の単一のコピーが送信されることを可能にする、証明書を含むメッセージの唯一の場所です。代替証明書配布メカニズムを持っているシステムでは、いくつかの証明書は省略されるかもしれません。そのような共有秘密セキュリティ（セクション13.4）として直ちに発生証明書のための別の機構が使用されていない限りしかし、実装者は、すべての参照証明書を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "NOTE TO IMPLEMENTERS: This requirement implies that a peer storing data is obligated to retain certificates for the data that it holds.",
      "ja": "実装者への注意：この要件は、ピア格納したデータは、それが保持するデータの証明書を保持する義務があることを意味します。"
    },
    {
      "indent": 3,
      "text": "Each certificate is represented by a GenericCertificate structure, which has the following contents:",
      "ja": "各証明書は以下の内容を有するGenericCertificate構造、によって表されます。"
    },
    {
      "indent": 3,
      "text": "type The type of the certificate, as defined in [RFC6091]. Only the use of X.509 certificates is defined in this document.",
      "ja": "[RFC6091]で定義されるように、証明書の種類を入力します。 X.509証明書の使用は、本文書で定義されているだけです。"
    },
    {
      "indent": 3,
      "text": "certificate The encoded version of the certificate. For X.509 certificates, it is the Distinguished Encoding Rules (DER) form.",
      "ja": "証明書証明書の符号化されたバージョン。 X.509証明書の場合は、識別符号化規則（DER）の形です。"
    },
    {
      "indent": 3,
      "text": "The signature is computed over the payload and parts of the forwarding header. In case of a Store, the payload MUST contain an additional signature computed as described in Section 7.1. All signatures MUST be formatted using the Signature element. This element is also used in other contexts where signatures are needed. The input structure to the signature computation MAY vary depending on the data element being signed.",
      "ja": "署名は、ペイロードと転送ヘッダの部分にわたって計算されます。店の場合には、ペイロードは、セクション7.1で説明したように計算された追加の署名を含まなければなりません。すべての署名は、署名要素を使用してフォーマットされなければなりません。この要素はまた、署名が必要とされている他の文脈で使用されています。署名計算への入力構造は、署名されるデータ要素に依存して変化し得ます。"
    },
    {
      "indent": 5,
      "text": "enum { invalidSignerIdentityType(0),\n       cert_hash(1), cert_hash_node_id(2),\n       none(3)\n       (255) } SignerIdentityType;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "struct {\n  select (identity_type) {",
      "raw": true
    },
    {
      "indent": 9,
      "text": "case cert_hash;\n  HashAlgorithm      hash_alg;              // From TLS\n  opaque             certificate_hash<0..2^8-1>;",
      "raw": true
    },
    {
      "indent": 9,
      "text": "case cert_hash_node_id: HashAlgorithm hash_alg; // From TLS opaque certificate_node_id_hash<0..2^8-1>;",
      "ja": "ケースcert_hash_node_id：HashAlgorithmのhash_alg。 // TLS不透明certificate_node_id_hashから<0..2 ^ 8-1>。"
    },
    {
      "indent": 5,
      "text": "    case none:\n      /* empty */\n    /* This structure may be extended with new types if necessary*/\n  };\n} SignerIdentityValue;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "struct {\n  SignerIdentityType     identity_type;\n  uint16                 length;\n  SignerIdentityValue    identity[SignerIdentity.length];\n} SignerIdentity;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "struct {\n   SignatureAndHashAlgorithm     algorithm;   // From TLS\n   SignerIdentity                identity;\n   opaque                        signature_value<0..2^16-1>;\n} Signature;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Signature construct contains the following values:",
      "ja": "シグネチャー構築物は、以下の値が含まれます。"
    },
    {
      "indent": 3,
      "text": "algorithm The signature algorithm in use. The algorithm definitions are found in the IANA TLS SignatureAlgorithm and HashAlgorithm registries. All implementations MUST support RSASSA-PKCS1-v1_5 [RFC3447] signatures with SHA-256 hashes [RFC6234].",
      "ja": "使用中の署名アルゴリズムをアルゴリズムです。アルゴリズムの定義は、IANA TLSのsignatureAlgorithmとHashAlgorithmレジストリで発見されています。すべての実装は、SHA-256ハッシュ[RFC6234]とRSASSA-PKCS1-v1_5の[RFC3447]の署名をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "identity The identity, as defined in the two paragraphs following this list, used to form the signature.",
      "ja": "アイデンティティアイデンティティ、署名を形成するために使用されるこのリストは、次の2つの段落で定義された通りです。"
    },
    {
      "indent": 3,
      "text": "signature_value The value of the signature.",
      "ja": "署名の値をsignature_value。"
    },
    {
      "indent": 6,
      "text": "Note that storage operations allow for special values of algorithm and identity. See the Store Request definition (Section 7.4.1.1) and the Fetch Response definition (Section 7.4.2.2).",
      "ja": "ストレージ操作がアルゴリズムとアイデンティティの特別な値を許容することに注意してください。ストア要求の定義（セクション7.4.1.1）とフェッチ応答の定義（7.4.2.2項）を参照してください。"
    },
    {
      "indent": 3,
      "text": "There are two permitted identity formats, one for a certificate with only one Node-ID and one for a certificate with multiple Node-IDs. In the first case, the cert_hash type MUST be used. The hash_alg field is used to indicate the algorithm used to produce the hash. The certificate_hash contains the hash of the certificate object (i.e., the DER-encoded certificate).",
      "ja": "2つの許可アイデンティティ形式、唯一1つのノードIDを持つ証明書用と複数のNode-IDを持つ証明書のための1があります。最初のケースでは、cert_hashタイプが使用されなければなりません。 hash_algフィールドは、ハッシュを生成するために使用するアルゴリズムを示すために使用されます。 certificate_hash証明書オブジェクト（すなわち、DER符号化された証明書）のハッシュを含んでいます。"
    },
    {
      "indent": 3,
      "text": "In the second case, the cert_hash_node_id type MUST be used. The hash_alg is as in cert_hash, but the cert_hash_node_id is computed over the NodeId used to sign concatenated with the certificate; i.e., H(NodeId || certificate). The NodeId is represented without any framing or length fields, as simple raw bytes. This is safe because NodeIds are a fixed length for a given overlay.",
      "ja": "後者の場合、cert_hash_node_idタイプが使用されなければなりません。 hash_algはcert_hashと同様であるが、cert_hash_node_idは、証明書と連結署名するために使用NODEIDにわたって計算されます。即ち、H（NODEID ||証明書）。 NODEIDは、単純な生のバイトとして、任意のフレーミングまたは長さフィールドなしで表されています。ノード識別子が与えられたオーバーレイの固定長であるため、これは安全です。"
    },
    {
      "indent": 3,
      "text": "For signatures over messages, the input to the signature is computed over:",
      "ja": "メッセージ上の署名は、署名への入力は上に計算されます。"
    },
    {
      "indent": 6,
      "text": "overlay || transaction_id || MessageContents || SignerIdentity",
      "ja": "オーバーレイ|| TRANSACTION_ID || MessageContents || SignerIdentity"
    },
    {
      "indent": 3,
      "text": "where overlay and transaction_id come from the forwarding header and || indicates concatenation.",
      "ja": "ここで、オーバーレイとは、転送ヘッダから来るTRANSACTION_ID ||連結を示します。"
    },
    {
      "indent": 3,
      "text": "The input to signatures over data values is different and is described in Section 7.1.",
      "ja": "データ値上の署名の入力は異なり、セクション7.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "All RELOAD messages MUST be signed. Intermediate nodes do not verify signatures. Upon receipt (and fragment reassembly, if needed), the destination node MUST verify the signature and the authorizing certificate. If the signature fails, the implementation SHOULD simply drop the message and MUST NOT process it. This check provides a minimal level of assurance that the sending node is a valid part of the overlay, and it provides cryptographic authentication of the sending node. In addition, responses MUST be checked as follows by the requesting node:",
      "ja": "すべてRELOADメッセージが署名する必要があります。中間ノードは、署名を検証しません。 （必要な場合及び断片再組み立て）を受信すると、宛先ノードは、署名および認可証明書を検証しなければなりません。署名が失敗した場合、実装は単にメッセージをドロップする必要があり、それを処理してはいけません。このチェックは、送信ノードは、オーバーレイの有効な部分であり、それは、送信ノードの暗号認証を提供することを保証する最低限のレベルを提供します。要求ノードで次のように加えて、応答がチェックしなければなりません。"
    },
    {
      "indent": 3,
      "text": "1. The response to a message sent to a Node-ID MUST have been sent by that Node-ID unless the response has been sent to the wildcard Node-ID.",
      "ja": "応答がワイルドカードノードIDに送信されていない限り、1ノードIDに送信されたメッセージへの応答は、そのノードIDによって送信されていなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. The response to a message sent to a Resource-ID MUST have been sent by a Node-ID which is at least as close to the target Resource-ID as any node in the requesting node's Neighbor Table.",
      "ja": "2.リソース-IDに送信されたメッセージへの応答は、要求ノードのネイバーテーブル内の任意のノードとターゲットリソース-IDと少なくとも限り近いノードIDによって送信されていなければなりません。"
    },
    {
      "indent": 3,
      "text": "The second condition serves as a primitive check for responses from wildly wrong nodes but is not a complete check. Note that in periods of churn, it is possible for the requesting node to obtain a closer neighbor while the request is outstanding. This will cause the response to be rejected and the request to be retransmitted.",
      "ja": "第2の条件は、乱暴に間違ったノードからの応答のための原始的なチェックとして機能しますが、完全なチェックではありません。要求が未処理であるが、要求ノードが近い隣人を得るための解約の期間において、それが可能であることに留意されたいです。これは、応答が拒否され、要求が再送されることになります。"
    },
    {
      "indent": 3,
      "text": "In addition, some methods (especially Store) have additional authentication requirements, which are described in the sections covering those methods.",
      "ja": "加えて、いくつかの方法（特に店）これらのメソッドをカバーするセクションで説明される追加の認証要件を有します。"
    },
    {
      "indent": 0,
      "text": "6.4. Overlay Topology",
      "section_title": true,
      "ja": "6.4。オーバーレイトポロジ"
    },
    {
      "indent": 3,
      "text": "As discussed in previous sections, RELOAD defines a default overlay topology (CHORD-RELOAD) but allows for other topologies through the use of Topology Plug-ins. This section describes the requirements for new Topology Plug-ins and the methods that RELOAD provides for overlay topology maintenance.",
      "ja": "前のセクションで説明したように、リロードが既定のオーバレイ・トポロジー（CHORDリロード）を定義が、トポロジ・プラグインの使用を介して他のトポロジを可能にします。このセクションでは、新しいトポロジプラグインおよびRELOADは、オーバーレイ・トポロジーの維持を提供する方法のための要件について説明します。"
    },
    {
      "indent": 0,
      "text": "6.4.1. Topology Plug-in Requirements",
      "section_title": true,
      "ja": "6.4.1。トポロジプラグインの要件"
    },
    {
      "indent": 3,
      "text": "When specifying a new overlay algorithm, at least the following MUST be described:",
      "ja": "新しいオーバーレイアルゴリズムを指定する場合、少なくとも次のように説明しなければなりません："
    },
    {
      "indent": 3,
      "text": "o Joining procedures, including the contents of the Join message.",
      "ja": "O Joinメッセージの内容を含む、手続きに参加します。"
    },
    {
      "indent": 3,
      "text": "o Stabilization procedures, including the contents of the Update message, the frequency of topology probes and keepalives, and the mechanism used to detect when peers have disconnected.",
      "ja": "更新メッセージの内容、トポロジープローブとキープアライブの頻度、およびピアが切断しているときを検出するために使用する機構を備えO安定化手順。"
    },
    {
      "indent": 3,
      "text": "o Exit procedures, including the contents of the Leave message.",
      "ja": "Leaveメッセージの内容を含むOの終了手続き、。"
    },
    {
      "indent": 3,
      "text": "o The length of the Resource-IDs and for DHTs the hash algorithm to compute the hash of an identifier.",
      "ja": "リソース-IDの長さOとのDHTsの識別子のハッシュを計算するハッシュアルゴリズム。"
    },
    {
      "indent": 3,
      "text": "o The procedures that peers use to route messages.",
      "ja": "ピアがメッセージをルーティングするために使用するプロシージャO。"
    },
    {
      "indent": 3,
      "text": "o The replication strategy used to ensure data redundancy.",
      "ja": "データの冗長性を確保するために使用、複製戦略O。"
    },
    {
      "indent": 3,
      "text": "All overlay algorithms MUST specify maintenance procedures that send Updates to clients and peers that have established connections to the peer responsible for a particular ID when the responsibility for that ID changes. Because tracking this information is difficult, overlay algorithms MAY simply specify that an Update is sent to all members of the Connection Table whenever the range of IDs for which the peer is responsible changes.",
      "ja": "すべてのオーバーレイ・アルゴリズムは、特定のIDを担当するピアへの接続を確立しているクライアントとピアにアップデートを送信する保守手順を指定しなければならないときにIDの変更のための責任。この情報を追跡することは困難であるため、オーバーレイアルゴリズムは単にピアが担当変更IDの範囲をされているときはいつでも更新を接続テーブルのすべてのメンバーに送信されることを指定することができます。"
    },
    {
      "indent": 0,
      "text": "6.4.2. Methods and Types for Use by Topology Plug-ins",
      "section_title": true,
      "ja": "6.4.2。トポロジプラグインによる使用のための方法およびタイプ"
    },
    {
      "indent": 3,
      "text": "This section describes the methods that Topology Plug-ins use to join, leave, and maintain the overlay.",
      "ja": "このセクションでは、トポロジプラグインは、参加したまま、およびオーバーレイを維持するために使用する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "6.4.2.1. Join",
      "section_title": true,
      "ja": "6.4.2.1。加わります"
    },
    {
      "indent": 3,
      "text": "A new peer (which already has credentials) uses the JoinReq message to join the overlay. The JoinReq is sent to the responsible peer depending on the routing mechanism described in the Topology Plug-in. This message notifies the responsible peer that the new peer is taking over some of the overlay and that it needs to synchronize its state.",
      "ja": "（すでに資格情報を持つ）新しいピアは、オーバーレイに参加するJoinReqメッセージを使用しています。 JoinReqはトポロジプラグインに記載のルーティングメカニズムに応じて責任をピアに送信されます。このメッセージは、新しいピアは、オーバーレイの一部の上に、それはその状態を同期する必要があることを取っている責任をピアに通知します。"
    },
    {
      "indent": 9,
      "text": "struct {\n   NodeId                joining_peer_id;\n   opaque                overlay_specific_data<0..2^16-1>;\n} JoinReq;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The minimal JoinReq contains only the Node-ID which the sending peer wishes to assume. Overlay algorithms MAY specify other data to appear in this request. Receivers of the JoinReq MUST verify that the joining_peer_id field matches the Node-ID used to sign the message and, if not, the message MUST be rejected with an Error_Forbidden error.",
      "ja": "最小JoinReqは送信ピアが想定したいだけのNode-IDを含んでいます。オーバーレイアルゴリズムは、この要求に表示される他のデータを指定するかもしれません。メッセージがError_Forbiddenエラーで拒否されなければならないない場合JoinReqの受信機は、joining_peer_idフィールドがメッセージに署名するために使用される-IDは、ノードと一致することを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Because joins may be executed only between nodes which are directly adjacent, receiving peers MUST verify that any JoinReq they receive arrives from a transport channel that is bound to the Node-ID to be assumed by the Joining Node. Implementations MUST use DTLS anti-replay mechanisms, thus preventing replay attacks.",
      "ja": "唯一の直接隣接するノード間で実行され得る参加ので、受信ピアは、それらが受け取る任意JoinReqは、参加するノードが想定されるノードIDにバインドされたトランスポートチャネルから到来することを確かめなければなりません。実装は、このようにリプレイ攻撃を防ぐ、DTLSアンチリプレイメカニズムを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the request succeeds, the responding peer responds with a JoinAns message, as defined below:",
      "ja": "リクエストが成功した場合、以下に定義されるように、応答ピアが、JoinAnsメッセージで応答します。"
    },
    {
      "indent": 9,
      "text": "struct {\n   opaque                overlay_specific_data<0..2^16-1>;\n} JoinAns;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the request succeeds, the responding peer MUST follow up by executing the right sequence of Stores and Updates to transfer the appropriate section of the overlay space to the Joining Node. In addition, overlay algorithms MAY define data to appear in the response payload that provides additional information.",
      "ja": "リクエストが成功した場合は、応答するピアは、参加するノードにオーバーレイスペースの適切なセクションを転送する店舗やアップデートの権利シーケンスを実行することでフォローアップしなければなりません。また、オーバーレイアルゴリズムは、追加情報を提供する応答ペイロードに表示するデータを定義することができます。"
    },
    {
      "indent": 3,
      "text": "Joining Nodes MUST verify that the signature on the JoinAns message matches the expected target (i.e., the adjacency over which they are joining). If not, they MUST discard the message.",
      "ja": "参加ノードはJoinAnsメッセージ上の署名が（すなわち、隣接がその上、それらが接合されている）、予想される標的と一致していることを確認しなければなりません。そうでない場合、彼らはメッセージを捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "In general, nodes which cannot form connections SHOULD report an error to the user. However, implementations MUST provide some mechanism whereby nodes can determine that they are potentially the first node and can take responsibility for the overlay. (The idea is to avoid having ordinary nodes try to become responsible for the entire overlay during a partition.) This specification does not mandate any particular mechanism, but a configuration flag or setting seems appropriate.",
      "ja": "一般に、接続を形成することができないノードは、ユーザにエラーを報告しなければなりません。ノードは、それらが、潜在的に、最初のノードであり、オーバーレイのための責任を取ることができると判断できるが、実装は、いくつかのメカニズムを提供しなければなりません。この仕様は、任意の特定のメカニズムを強制しません（アイデアは。通常のノードがパーティションの間にオーバーレイ全体の責任になることを試みることを避けるためにある）が、構成フラグや設定が適切であるように思われます。"
    },
    {
      "indent": 0,
      "text": "6.4.2.2. Leave",
      "section_title": true,
      "ja": "6.4.2.2。去ります"
    },
    {
      "indent": 3,
      "text": "The LeaveReq message is used to indicate that a node is exiting the overlay. A node SHOULD send this message to each peer with which it is directly connected prior to exiting the overlay.",
      "ja": "LeaveReqメッセージは、ノードがオーバーレイを出ていることを示すために使用されます。ノードは、それが直接オーバーレイを出る前に接続している各ピアにこのメッセージを送信すべきです。"
    },
    {
      "indent": 9,
      "text": "struct {\n   NodeId                leaving_peer_id;\n   opaque                overlay_specific_data<0..2^16-1>;\n} LeaveReq;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "LeaveReq contains only the Node-ID of the leaving peer. Overlay algorithms MAY specify other data to appear in this request. Receivers of the LeaveReq MUST verify that the leaving_peer_id field matches the Node-ID used to sign the message and, if not, the message MUST be rejected with an Error_Forbidden error.",
      "ja": "LeaveReqは残して、ピアの唯一のノードIDが含まれています。オーバーレイアルゴリズムは、この要求に表示される他のデータを指定するかもしれません。メッセージがError_Forbiddenエラーで拒否されなければならないない場合LeaveReqの受信機は、leaving_peer_idフィールドがメッセージに署名するために使用される-IDは、ノードと一致することを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Because leaves may be executed only between nodes which are directly adjacent, receiving peers MUST verify that any LeaveReq they receive arrives from a transport channel that is bound to the Node-ID to be assumed by the leaving peer. This also prevents replay attacks, provided that DTLS anti-replay is used.",
      "ja": "葉のみ直接隣接するノード間で実行されてもよいので、受信ピアは、それらが受け取る任意LeaveReqは離脱ピアによって想定されるノードIDにバインドされたトランスポートチャネルから到来することを確かめなければなりません。これはまた、DTLSアンチリプレイが使用されていることを提供し、リプレイ攻撃を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "Upon receiving a Leave request, a peer MUST update its own Routing Table and send the appropriate Store/Update sequences to re-stabilize the overlay.",
      "ja": "離脱要求を受信すると、ピアは、自身のルーティングテーブルを更新し、オーバーレイを再安定化するために、適切な保存/更新シーケンスを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "LeaveAns is an empty message.",
      "ja": "LeaveAnsは空のメッセージです。"
    },
    {
      "indent": 0,
      "text": "6.4.2.3. Update",
      "section_title": true,
      "ja": "6.4.2.3。更新"
    },
    {
      "indent": 3,
      "text": "Update is the primary overlay-specific maintenance message. It is used by the sender to notify the recipient of the sender's view of the current state of the overlay (that is, its routing state), and it is up to the recipient to take whatever actions are appropriate to deal with the state change. In general, peers send Update messages to all their adjacencies whenever they detect a topology shift.",
      "ja": "更新は、プライマリオーバーレイ固有のメンテナンスメッセージで。 （つまり、そのルーティング状態である）オーバーレイの現在の状態の送信者の表示の受信者に通知するために送信者によって使用され、それが状態変化に対処するために適切などんな行動取るように受け手次第です。彼らはトポロジーシフトを検出するたびに一般的には、ピアは、すべての隣接に更新メッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "When a peer receives an Attach request with the send_update flag set to True (Section 6.4.2.4.1), it MUST send an Update message back to the sender of the Attach request after completion of the corresponding ICE check and TLS connection. Note that the sender of such an Attach request may not have joined the overlay yet.",
      "ja": "ピアが真（セクション6.4.2.4.1）に設定send_updateフラグをアタッチ要求を受信した場合は、対応するICEチェックとのTLS接続の完了後、バックアタッチ要求の送信元に更新メッセージを送らなければなりません。そのようなANアタッチ要求の送信者がまだオーバーレイに参加していないかもしれないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "When a peer detects through an Update that it is no longer responsible for any data value it is storing, it MUST attempt to Store a copy to the correct node unless it knows the newly responsible node already has a copy of the data. This prevents data loss during large-scale topology shifts, such as the merging of partitioned overlays.",
      "ja": "ピアは、それはもはやそれが保存されている任意のデータ値を担当していないUpdateを通じて検出すると、それはすでに、新たに担当するノードを認識しているデータのコピーを持っていない限り、それが正しいノードにコピーを保存しようとしなければなりません。これは、パーティション・オーバーレイのマージとして、大規模なトポロジーシフト時のデータ損失を防止します。"
    },
    {
      "indent": 3,
      "text": "The contents of the UpdateReq message are completely overlay specific. The UpdateAns response is expected to be either success or an error.",
      "ja": "UpdateReqメッセージの内容が完全にオーバーレイ特異的です。 UpdateAns応答が成功またはエラーのいずれかであることが予想されます。"
    },
    {
      "indent": 0,
      "text": "6.4.2.4. RouteQuery",
      "section_title": true,
      "ja": "6.4.2.4。 RouteQuery"
    },
    {
      "indent": 3,
      "text": "The RouteQuery request allows the sender to ask a peer where they would route a message directed to a given destination. In other words, a RouteQuery for a destination X requests the Node-ID for the node that the receiving peer would next route to in order to get to X. A RouteQuery can also request that the receiving peer initiate an Update request to transfer the receiving peer's Routing Table.",
      "ja": "RouteQuery要求は、送信者が、彼らが経路指定された宛先に向けられたメッセージを希望ピアを依頼することを可能にします。換言すれば、先XのためRouteQueryは、受信ピアが受信ピアが受信を転送するために更新要求をも要求することができるX. A RouteQueryに到達するために、次のルートを開始するであろう、そのノードのノードIDを要求しますピアのルーティングテーブル。"
    },
    {
      "indent": 3,
      "text": "One important use of the RouteQuery request is to support iterative routing. The sender selects one of the peers in its Routing Table and sends it a RouteQuery message with the destination field set to the Node-ID or Resource-ID to which it wishes to route. The receiving peer responds with information about the peers to which the request would be routed. The sending peer MAY then use the Attach method to attach to that peer(s) and repeat the RouteQuery. Eventually, the sender gets a response from a peer that is closest to the identifier in the destination field as determined by the Topology Plug-in. At that point, the sender can send messages directly to that peer.",
      "ja": "RouteQuery要求の一つの重要な用途は、反復ルーティングをサポートすることです。送信者は、そのルーティングテーブル内のピアの1つを選択し、それを、それが経路を希望するノードIDまたはリソース-IDに設定された宛先フィールドを有するRouteQueryメッセージを送信します。受信ピアは、要求がルーティングされるであろうにピアに関する情報で応答します。送信ピアは、そのピア（複数）に付着しRouteQueryを繰り返す取り付け方法を使用することができます。最終的に、送信者は、トポロジプラグインによって決定される宛先フィールド内の識別子に最も近いピアから応答を取得します。その時点で、送信者はそのピアに直接メッセージを送ることができます。"
    },
    {
      "indent": 0,
      "text": "6.4.2.4.1. Request Definition",
      "section_title": true,
      "ja": "6.4.2.4.1。要求定義"
    },
    {
      "indent": 3,
      "text": "A RouteQueryReq message indicates the peer or resource that the requesting node is interested in. It also contains a \"send_update\" option that allows the requesting node to request a full copy of the other peer's Routing Table.",
      "ja": "RouteQueryReqメッセージは、要求ノードが興味を持っているピアまたはリソースを示しています。また、要求ノードは、他のピアのルーティングテーブルの完全なコピーを要求することを可能にする「send_update」オプションが含まれています。"
    },
    {
      "indent": 9,
      "text": "struct {\n  Boolean                send_update;\n  Destination            destination;\n  opaque                 overlay_specific_data<0..2^16-1>;\n} RouteQueryReq;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of the RouteQueryReq message are as follows:",
      "ja": "次のようにRouteQueryReqメッセージの内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "send_update A single byte. This may be set to True to indicate that the requester wishes the responder to initiate an Update request immediately. Otherwise, this value MUST be set to False.",
      "ja": "1バイトをsend_update。これは、要求者がすぐに更新要求を開始するレスポンダを望んでいることを示すために、Trueに設定することができます。それ以外の場合、この値はfalseに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "destination The destination which the requester is interested in. This may be any valid destination object, including a Node-ID, opaque ID, or Resource-ID. Note: If implementations are using opaque IDs for privacy purposes, answering RouteQueryReqs for opaque IDs will allow the requester to translate an opaque ID. Implementations MAY wish to consider limiting the use of RouteQuery for opaque IDs in such cases.",
      "ja": "先要求者が興味を持っている宛先が、これは、ノードID、不透明なID、またはリソース-IDを含む、任意の有効な宛先オブジェクトであってもよいです。注意：実装は、プライバシーのために不透明なIDを使用している場合は、不透明なIDのRouteQueryReqsに答えることは要求者が不透明なIDを変換することができます。実装は、このようなケースでは、不透明なIDのRouteQueryの使用を制限することを検討してすることもできます。"
    },
    {
      "indent": 3,
      "text": "overlay_specific_data Other data as appropriate for the overlay.",
      "ja": "オーバーレイのための適切な他のデータoverlay_specific_data。"
    },
    {
      "indent": 0,
      "text": "6.4.2.4.2. Response Definition",
      "section_title": true,
      "ja": "6.4.2.4.2。レスポンスの定義"
    },
    {
      "indent": 3,
      "text": "A response to a successful RouteQueryReq request is a RouteQueryAns message. This message is completely overlay specific.",
      "ja": "成功RouteQueryReq要求に対する応答はRouteQueryAnsメッセージです。このメッセージは、完全にオーバーレイ固有のものです。"
    },
    {
      "indent": 0,
      "text": "6.4.2.5. Probe",
      "section_title": true,
      "ja": "6.4.2.5。調査"
    },
    {
      "indent": 3,
      "text": "Probe provides primitive \"exploration\" services: it allows a node to determine which resources another node is responsible for. A probe can be addressed to a specific Node-ID or to the peer controlling a given location (by using a Resource-ID). In either case, the target node responds with a simple response containing some status information.",
      "ja": "プローブは、原始的な「探査」のサービスを提供します。それは、ノードが他のノードが担当しているリソースを決定することができます。プローブは、特定のノードIDまたは（リソース-IDを使用して）指定された位置を制御ピアにア​​ドレス指定することができます。いずれの場合においても、ターゲット・ノードは、いくつかのステータス情報を含む単純な応答で応答します。"
    },
    {
      "indent": 0,
      "text": "6.4.2.5.1. Request Definition",
      "section_title": true,
      "ja": "6.4.2.5.1。要求定義"
    },
    {
      "indent": 3,
      "text": "The ProbeReq message contains a list (potentially empty) of the pieces of status information that the requester would like the responder to provide.",
      "ja": "ProbeReqメッセージは、要求が応答を提供したいとステータス情報のリスト（潜在的に空の）を含みます。"
    },
    {
      "indent": 8,
      "text": "enum { invalidProbeInformationType(0), responsible_set(1),\n       num_resources(2), uptime(3), (255) }\n     ProbeInformationType;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  ProbeInformationType     requested_info<0..2^8-1>;\n} ProbeReq;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The currently defined values for ProbeInformationType are:",
      "ja": "ProbeInformationTypeのための現在定義されている値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "responsible_set Indicates that the peer should Respond with the fraction of the overlay for which the responding peer is responsible.",
      "ja": "responsible_setは、ピアが応答するピアが責任を負うオーバーレイの割合で応答すべきであることを示します。"
    },
    {
      "indent": 3,
      "text": "num_resources Indicates that the peer should Respond with the number of resources currently being stored by the peer. Note that multiple values under the same Resource-ID are counted only once.",
      "ja": "num_resourcesは、ピアが現在のピアによって格納されているリソースの数で応答すべきであることを示します。同じリソース-IDの下の複数の値を一度だけカウントされることに注意してください。"
    },
    {
      "indent": 3,
      "text": "uptime Indicates that the peer should Respond with how long the peer has been up, in seconds.",
      "ja": "稼働時間は、ピアがピアが秒にアップしているどのくらいの時間で応答すべきであることを示します。"
    },
    {
      "indent": 0,
      "text": "6.4.2.5.2. Response Definition",
      "section_title": true,
      "ja": "6.4.2.5.2。レスポンスの定義"
    },
    {
      "indent": 3,
      "text": "A successful ProbeAns response contains the information elements requested by the peer.",
      "ja": "成功ProbeAns応答は、ピアによって要求された情報要素が含まれています。"
    },
    {
      "indent": 9,
      "text": "struct {\n  select (type) {\n    case responsible_set:\n      uint32             responsible_ppb;",
      "raw": true
    },
    {
      "indent": 13,
      "text": "case num_resources:\n  uint32             num_resources;",
      "raw": true
    },
    {
      "indent": 13,
      "text": "case uptime: uint32 uptime;",
      "ja": "ケースの稼働時間：UINT32稼働時間。"
    },
    {
      "indent": 9,
      "text": "    /* This type may be extended */\n  };\n} ProbeInformationData;",
      "raw": true
    },
    {
      "indent": 9,
      "text": "struct {\n  ProbeInformationType    type;\n  uint8                   length;\n  ProbeInformationData    value;\n} ProbeInformation;",
      "raw": true
    },
    {
      "indent": 9,
      "text": "struct {\n  ProbeInformation        probe_info<0..2^16-1>;\n} ProbeAns;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A ProbeAns message contains a sequence of ProbeInformation structures. Each has a \"length\" indicating the length of the following value field. This structure allows for unknown option types.",
      "ja": "ProbeAnsメッセージはProbeInformation構造体の配列を含みます。それぞれが次の値フィールドの長さを示す「長さ」を有します。この構造体は、未知のオプションタイプが可能になります。"
    },
    {
      "indent": 3,
      "text": "Each of the current possible Probe information types is a 32-bit unsigned integer. For type \"responsible_ppb\", it is the fraction of the overlay for which the peer is responsible, in parts per billion. For type \"num_resources\", it is the number of resources the peer is storing. For the type \"uptime\", it is the number of seconds the peer has been up.",
      "ja": "現在可能なプローブ情報タイプの各々は、32ビットの符号なし整数です。タイプ「responsible_ppb」の場合は、ピアは10億分の1で、担当するオーバーレイの割合です。タイプ「num_resources」の場合は、ピアが保存されるリソースの数です。タイプ「稼働時間」のために、それはピアがアップされている秒数です。"
    },
    {
      "indent": 3,
      "text": "The responding peer SHOULD include any values that the requesting node requested and that it recognizes. They SHOULD be returned in the requested order. Any other values MUST NOT be returned.",
      "ja": "応答するピアは、要求側ノードが要求された任意の値を含み、それは認識するべきです。彼らは、要求された順序で返されるべきです。その他の値が返されてはなりません。"
    },
    {
      "indent": 0,
      "text": "6.5. Forwarding and Link Management Layer",
      "section_title": true,
      "ja": "6.5。転送とリンク管理レイヤ"
    },
    {
      "indent": 3,
      "text": "Each node maintains connections to a set of other nodes defined by the Topology Plug-in. This section defines the methods RELOAD uses to form and maintain connections between nodes in the overlay. Three methods are defined:",
      "ja": "各ノードは、トポロジプラグインによって定義された他のノードのセットへの接続を維持します。このセクションでは、リロードが形成し、オーバーレイ内のノード間の接続を維持するために使用するメソッドを定義します。 3つの方法が定義されています。"
    },
    {
      "indent": 3,
      "text": "Attach Used to form RELOAD connections between nodes using ICE for NAT traversal. When node A wants to connect to node B, it sends an Attach message to node B through the overlay. The Attach contains A's ICE parameters. B responds with its ICE parameters, and the two nodes perform ICE to form connection. Attach also allows two nodes to connect via No-ICE instead of full ICE.",
      "ja": "NATトラバーサルのためのICEを使用してノード間のRELOAD接続を形成するために用いられる取り付けます。ノードAがノードBに接続したい場合には、オーバレイを介してノードBにメッセージを添付し送信します。アタッチAのICEパラメータが含まれています。 Bは、そのICEパラメータで応答し、そして2つのノードは接続を形成するために、ICEを行います。取り付けはまた、2つのノードが代わりにフルICEの無ICE経由で接続することができます。"
    },
    {
      "indent": 3,
      "text": "AppAttach Used to form application-layer connections between nodes.",
      "ja": "AppAttachは、ノード間のアプリケーション層の接続を形成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Ping A simple request/response which is used to verify connectivity of the target peer.",
      "ja": "ピングターゲットピアの接続を確認するために使用される単純な要求/応答。"
    },
    {
      "indent": 0,
      "text": "6.5.1. Attach",
      "section_title": true,
      "ja": "6.5.1。アタッチ"
    },
    {
      "indent": 3,
      "text": "A node sends an Attach request when it wishes to establish a direct Overlay Link connection to another node for the purpose of sending RELOAD messages. A client that can establish a connection directly need not send an Attach, as described in the second bullet of Section 4.2.1.",
      "ja": "ノードは、それがRELOADメッセージを送信する目的のために別のノードへの直接オーバーレイのリンク接続を確立したい場合、要求を添付し送信します。接続を確立することができ、クライアントは、直接4.2.1節の第二箇条書きで説明したように、添付し送信する必要はありません。"
    },
    {
      "indent": 3,
      "text": "As described in Section 6.1, an Attach may be routed to either a Node-ID or a Resource-ID. An Attach routed to a specific Node-ID will fail if that node is not reached. An Attach routed to a Resource-ID will establish a connection with the peer currently responsible for that Resource-ID, which may be useful in establishing a direct connection to the responsible peer for use with frequent or large resource updates.",
      "ja": "6.1節で述べたように、アタッチノードIDまたはリソース-IDのいずれかにルーティングすることができます。そのノードに到達していない場合に失敗します。特定のノードIDにルーティング接続します。アタッチリソース-IDにルーティングは、頻繁または大規模なリソースの更新で使用するための責任を負うピアへの直接接続を確立するのに有用であり得る、そのリソース-IDのために、現在担当するピアとの接続を確立します。"
    },
    {
      "indent": 3,
      "text": "An Attach, in and of itself, does not result in updating the Routing Table of either node. That function is performed by Updates. If node A has Attached to node B, but has not received any Updates from B, it MAY route messages which are directly addressed to B through that channel, but it MUST NOT route messages through B to other peers via that channel. The process of Attaching is separate from the process of becoming a peer (using Join and Update), to prevent half-open states where a node has started to form connections but is not really ready to act as a peer. Thus, clients (unlike peers) can simply Attach without sending Join or Update.",
      "ja": "それ自体は、いずれかのノードのルーティングテーブルを更新することにはなりません、アタッチ。この関数は、アップデートによって行われます。ノードAがノードBに取り付けられているが、Bから更新を受信して​​いない場合、そのMAY経路直接そのチャネルを介してBにアドレス指定されるメッセージが、それMUST NOT、そのチャネルを介して他のピアにBを通るルートメッセージ。取り付ける工程は、ノードが接続を形成するために始めたが、実際には、ピアとして機能する準備ができていないたハーフオープン状態を防ぐために（参加し、Updateを使用して）ピア、なるためのプロセスから分離されています。このように、（ピアとは違って）クライアントは、単に参加したり更新送信せずに接続することができます。"
    },
    {
      "indent": 0,
      "text": "6.5.1.1. Request Definition",
      "section_title": true,
      "ja": "6.5.1.1。要求定義"
    },
    {
      "indent": 3,
      "text": "An Attach request message contains the requesting node ICE connection parameters formatted into a binary structure.",
      "ja": "アタッチ要求メッセージは、バイナリ構造にフォーマット要求ノードICE接続パラメータを含んでいます。"
    },
    {
      "indent": 8,
      "text": "enum { invalidOverlayLinkType(0), DTLS-UDP-SR(1),\n       DTLS-UDP-SR-NO-ICE(3), TLS-TCP-FH-NO-ICE(4),\n       (255) } OverlayLinkType;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "enum { invalidCandType(0),\n       host(1), srflx(2), /* RESERVED(3), */ relay(4),\n       (255) } CandType;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  opaque                name<0..2^16-1>;\n  opaque                value<0..2^16-1>;\n} IceExtension;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  IpAddressPort         addr_port;\n  OverlayLinkType       overlay_link;\n  opaque                foundation<0..255>;\n  uint32                priority;\n  CandType              type;\n  select (type) {\n    case host:\n      ;          /* Empty */\n    case srflx:\n    case relay:\n      IpAddressPort     rel_addr_port;\n  };\n  IceExtension          extensions<0..2^16-1>;\n} IceCandidate;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  opaque                ufrag<0..2^8-1>;\n  opaque                password<0..2^8-1>;\n  opaque                role<0..2^8-1>;\n  IceCandidate          candidates<0..2^16-1>;\n  Boolean               send_update;\n} AttachReqAns;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The values contained in AttachReqAns are:",
      "ja": "AttachReqAnsに含まれる値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "ufrag The username fragment (from ICE).",
      "ja": "（ICE）からユーザ名フラグメントをufrag。"
    },
    {
      "indent": 3,
      "text": "password The ICE password.",
      "ja": "パスワードICEのパスワード。"
    },
    {
      "indent": 3,
      "text": "role An active/passive/actpass attribute from RFC 4145 [RFC4145]. This value MUST be \"passive\" for the offerer (the peer sending the Attach request) and \"active\" for the answerer (the peer sending the Attach response).",
      "ja": "役割RFC 4145 [RFC4145]からアクティブ/パッシブ/ actpass属性。この値は、回答（アタッチ応答を送信したピア）用の申出は、「受動的」（ピアがアタッチ要求を送信）と「アクティブ」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "candidates One or more ICE candidate values, as described below.",
      "ja": "候補者一の以上のICE候補値を、以下に説明するように。"
    },
    {
      "indent": 3,
      "text": "send_update Has the same meaning as the send_update field in RouteQueryReq.",
      "ja": "send_updateはRouteQueryReqでsend_updateフィールドと同じ意味を持ちます。"
    },
    {
      "indent": 3,
      "text": "Each ICE candidate is represented as an IceCandidate structure, which is a direct translation of the information from the ICE string structures, with the exception of the component ID. Since there is only one component, it is always 1, and thus left out of the structure. The remaining values are specified as follows:",
      "ja": "各ICE候補を構成要素IDを除いて、ICE列構造からの情報の直接変換であるIceCandidate構造として表されます。唯一つの成分があるので、それは常に1であるため、構造の外に放置しました。次のように残りの値が指定されています。"
    },
    {
      "indent": 3,
      "text": "addr_port Corresponds to the ICE connection-address and port productions.",
      "ja": "addr_portはICE接続アドレスとポートの制作に対応します。"
    },
    {
      "indent": 3,
      "text": "overlay_link Corresponds to the ICE transport production. Overlay Link protocols used with No-ICE MUST specify \"No-ICE\" in their description. Future overlay link values can be added by defining new OverlayLinkType values in the IANA registry as described in Section 14.10. Future extensions to the encapsulation or framing that provide for backward compatibility with the previously specified encapsulation or framing values MUST use the same OverlayLinkType value that was previously defined. OverlayLinkType protocols are defined in Section 6.6",
      "ja": "overlay_linkはICE輸送生産に対応します。無ICEで使用されるオーバレイリンクプロトコルは、その説明に「いいえ-ICE」を指定してはなりません。将来のオーバーレイリンク値は、セクション14.10で説明したようにIANAレジストリに新しいOverlayLinkType値を定義することで追加することができます。以前に指定されたカプセル化やフレーミングの値との下位互換性を提供するカプセル化やフレーミングに将来の拡張は、以前に定義されたのと同じOverlayLinkType値を使用しなければなりません。 OverlayLinkTypeプロトコルは6.6節で定義されています"
    },
    {
      "indent": 6,
      "text": "A single AttachReqAns MUST NOT include both candidates whose OverlayLinkType protocols use ICE (the default) and candidates that specify \"No-ICE\".",
      "ja": "シングルAttachReqAnsが「NO-ICE」を指定しない両方そのOverlayLinkTypeプロトコルICE（デフォルト）を使用して候補者と候補者を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "foundation Corresponds to the ICE foundation production.",
      "ja": "財団は、ICEの基礎生産に対応します。"
    },
    {
      "indent": 3,
      "text": "priority Corresponds to the ICE priority production.",
      "ja": "優先順位は、ICEの優先順位の生産に対応します。"
    },
    {
      "indent": 3,
      "text": "type Corresponds to the ICE cand-type production.",
      "ja": "タイプは、ICEのCAND型の生産に対応します。"
    },
    {
      "indent": 3,
      "text": "rel_addr_port Corresponds to the ICE rel-addr and rel-port productions. It is present only for types \"relay\", \"prfix\", and \"srflx\".",
      "ja": "rel_addr_portは、ICEのREL-addrとREL-ポート制作に対応します。それが唯一のタイプの「リレー」、「prfix」、および「srflx」のために存在しています。"
    },
    {
      "indent": 3,
      "text": "extensions ICE extensions. The name and value fields correspond to binary translations of the equivalent fields in the ICE extensions.",
      "ja": "拡張ICE拡張。名前と値のフィールドは、ICE拡張の等価フィールドのバイナリ翻訳に対応しています。"
    },
    {
      "indent": 3,
      "text": "These values should be generated using the procedures described in Section 6.5.1.3.",
      "ja": "これらの値は、セクション6.5.1.3に記載された手順を使用して生成されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.5.1.2. Response Definition",
      "section_title": true,
      "ja": "6.5.1.2。レスポンスの定義"
    },
    {
      "indent": 3,
      "text": "If a peer receives an Attach request, it MUST determine how to process the request as follows:",
      "ja": "ピアがアタッチ要求を受信した場合、それは次のように要求を処理する方法を決定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the peer has not initiated an Attach request to the originating peer of this Attach request, it MUST process this request and SHOULD generate its own response with an AttachReqAns. It should then begin ICE checks.",
      "ja": "ピアが開始されていない場合は、O、それはこの要求を処理しなければならないとAttachReqAnsを持つ独自の応答を生成する必要があります、このアタッチ要求の元のピアに要求を取り付けます。その後、ICEのチェックを開始する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the peer has already sent an Attach request to and received the response from the originating peer of this Attach request and, as a result, an ICE check and TLS connection are in progress, then it SHOULD generate an Error_In_Progress error instead of an AttachReqAns.",
      "ja": "Oピアがすでににリクエストを取り付け、この発信元ピアから応答を受信したリクエストを接続し、その結果、ICEチェック及びTLS接続が進行中であり、それは代わりAttachReqAnsのError_In_Progressエラーを生成する必要が送信された場合。"
    },
    {
      "indent": 3,
      "text": "o If the peer has already sent an Attach request to but not yet received the response from the originating peer of this Attach request, it SHOULD apply the following tie-breaker heuristic to determine how to handle this Attach request and the incomplete Attach request it has sent out:",
      "ja": "Oピアがすでにまだこのアタッチ要求の発信元ピアから応答を受信して​​いないけれども、それはこのアタッチ要求し、それが有する不完全アタッチ要求の処理方法を決定するために、次のタイブレーカのヒューリスティックを適用する必要に接続要求を送信した場合送り出さ："
    },
    {
      "indent": 6,
      "text": "* If the peer's own Node-ID is smaller when compared as big-endian unsigned integers, it MUST cancel retransmission of its own incomplete Attach request. It MUST then process this Attach request, generate an AttachReqAns response, and proceed with the corresponding ICE check.",
      "ja": "*ビッグエンディアン符号なし整数として比較したときに、ピア自身のノードIDが小さい場合、それは独自の取り付けの不完全な要求の再送信をキャンセルする必要があります。それは、これは、要求を取り付けAttachReqAns応答を生成し、対応するICEチェックを続行処理しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the peer's own Node-ID is larger when compared as big-endian unsigned integers, it MUST generate an Error_In_Progress error to this Attach request, and then proceed to wait for and complete the Attach and the corresponding ICE check it has originated.",
      "ja": "ビッグエンディアン符号なし整数として比較したときに、ピア自身のノードIDが大きい場合*は、このアタッチ要求にError_In_Progressエラーを生成し、次に待つために進み、取り付け、対応するICEは、それが発信したチェック完了する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the peer is overloaded or detects some other kind of error, it MAY generate an error instead of an AttachReqAns.",
      "ja": "ピアが過負荷状態やエラーのいくつかの他の種類を検出している場合は、O、それは代わりにAttachReqAnsのエラーを生成することがあります。"
    },
    {
      "indent": 3,
      "text": "When a peer receives an Attach response, it SHOULD parse the response and begin its own ICE checks.",
      "ja": "ピアがアタッチ応答を受信すると、応答を解析し、独自のICEチェックを開始する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5.1.3. Using ICE with RELOAD",
      "section_title": true,
      "ja": "6.5.1.3。 RELOADとICEを使用して"
    },
    {
      "indent": 3,
      "text": "This section describes the profile of ICE that is used with RELOAD. RELOAD implementations MUST implement full ICE.",
      "ja": "このセクションでは、RELOADで使用されているICEのプロファイルを記述する。 RELOAD実装はフルICEを実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In ICE, as defined by [RFC5245], the Session Description Protocol (SDP) is used to carry the ICE parameters. In RELOAD, this function is performed by a binary encoding in the Attach method. This encoding is more restricted than the SDP encoding because the RELOAD environment is simpler:",
      "ja": "[RFC5245]で定義されるようにICEに、セッション記述プロトコル（SDP）は、ICEパラメータを搬送するために使用されます。 RELOADにおいて、この機能は、取り付け方法で二進符号化することによって行われます。 RELOAD環境が単純であるため、このエンコーディングは、SDPのエンコードよりも制限されます。"
    },
    {
      "indent": 3,
      "text": "o Only a single media stream is supported.",
      "ja": "Oのみ単一のメディアストリームがサポートされています。"
    },
    {
      "indent": 3,
      "text": "o In this case, the \"stream\" refers not to RTP or other types of media, but rather to a connection for RELOAD itself or other application-layer protocols, such as SIP.",
      "ja": "Oここで、「ストリーム」がないRTP又は他のタイプのメディアに、むしろSIPなどリロード自体または他のアプリケーション層プロトコルのための接続を指します。"
    },
    {
      "indent": 3,
      "text": "o RELOAD allows only for a single offer/answer exchange. Unlike the usage of ICE within SIP, there is never a need to send a subsequent offer to update the default candidates to match the ones selected by ICE.",
      "ja": "O RELOADは、単一のオファー/アンサー交換が可能になります。 SIP内のICEの使用方法とは異なり、ICEによって選択されたものと一致するように、デフォルトの候補を更新するために、後続のオファーを送信する必要は決してありません。"
    },
    {
      "indent": 3,
      "text": "An agent follows the ICE specification as described in [RFC5245] with the changes and additional procedures described in the subsections below.",
      "ja": "以下のサブセクションで説明する変更と追加手順と[RFC5245]に記載されているように、エージェントは、ICEの仕様に従います。"
    },
    {
      "indent": 0,
      "text": "6.5.1.4. Collecting STUN Servers",
      "section_title": true,
      "ja": "6.5.1.4。 STUNサーバーの収集"
    },
    {
      "indent": 3,
      "text": "ICE relies on the node having one or more Session Traversal Utilities for NAT (STUN) servers to use. In conventional ICE, it is assumed that nodes are configured with one or more STUN servers through some out-of-band mechanism. This is still possible in RELOAD, but RELOAD also learns STUN servers as it connects to other peers.",
      "ja": "ICEは、一つ以上を使用するNATのセッショントラバーサルユーティリティ（STUN）は、サーバを有するノードに依存しています。従来のICEにおいては、ノードは、いくつかのアウトオブバンド機構を介して1つまたは複数のSTUNサーバで構成されているものとします。これは、RELOADには可能ですが、それは他のピアに接続するようRELOADもSTUNサーバを学習します。"
    },
    {
      "indent": 3,
      "text": "A peer on a well-provisioned wide-area overlay will be configured with one or more bootstrap nodes. These nodes make an initial list of STUN servers. However, as the peer forms connections with additional peers, it builds more peers that it can use like STUN servers.",
      "ja": "よくプロビジョニング広域オーバーレイ上のピアは、一つ以上のブートストラップ・ノードで構成されます。これらのノードはSTUNサーバの初期リストを作成します。しかし、追加のピアとのピアフォーム接続として、それはSTUNサーバのように使用することができるという多くのピアを構築します。"
    },
    {
      "indent": 3,
      "text": "Because complicated NAT topologies are possible, a peer may need more than one STUN server. Specifically, a peer that is behind a single NAT will typically observe only two IP addresses in its STUN checks: its local address and its server reflexive address from a STUN server outside its NAT. However, if more NATs are involved, a peer may learn additional server reflexive addresses (which vary based on where in the topology the STUN server is). To maximize the chance of achieving a direct connection, a peer SHOULD group other peers by the peer-reflexive addresses it discovers through them. It SHOULD then select one peer from each group to use as a STUN server for future connections.",
      "ja": "複雑なNATトポロジが可能であるため、ピアは、複数のSTUNサーバーが必要な場合があります。そのローカルアドレスとNATの外側STUNサーバーからそのサーバー再帰アドレス：具体的には、単一のNATの背後にあるピアは、典型的には、そのSTUNチェックで唯一の2つのIPアドレスを観察します。複数のNATが含まれる場合は、ピアは、（トポロジでSTUNサーバがどこに基づいて変化する）追加のサーバ再帰アドレスを学習することができます。直接接続を達成するための機会を最大化するために、ピアはそれがそれらを介して、ピア再帰アドレスによるグループ他のピアを発見するべきです。これは、将来の接続のためのSTUNサーバーとして使用するために、各グループから1つのピアを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "Only peers to which the peer currently has connections may be used. If the connection to that host is lost, it MUST be removed from the list of STUN servers, and a new server from the same group MUST be selected unless there are no others servers in the group, in which case some other peer MAY be used.",
      "ja": "ピアは、現在の接続を使用することができる持っているにピアのみ。そのホストへの接続が失われた場合、それはSTUNサーバのリストから削除されなければならない、と何も他のサーバがグループ内に存在しない場合を除き、同じグループから新しいサーバーは、いくつかの他のピアが使用される場合には、選択する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5.1.5. Gathering Candidates",
      "section_title": true,
      "ja": "6.5.1.5。候補者を集めます"
    },
    {
      "indent": 3,
      "text": "When a node wishes to establish a connection for the purposes of RELOAD signaling or application signaling, it follows the process of gathering candidates as described in Section 4 of ICE [RFC5245]. RELOAD utilizes a single component. Consequently, gathering for these \"streams\" requires a single component. In the case where a node has not yet found a TURN server, the agent would not include a relayed candidate.",
      "ja": "ノードリロードシグナリングまたはアプリケーションシグナリングの目的のための接続を確立することを望む場合には、ICE [RFC5245]のセクション4で説明したように候補を収集するプロセスに従います。 RELOADは、単一のコンポーネントを利用しています。したがって、これらの「ストリーム」を集め、単一の構成要素を必要とします。ノードがまだTURNサーバを発見していない場合には、薬剤は、中継候補が含まれないであろう。"
    },
    {
      "indent": 3,
      "text": "The ICE specification assumes that an ICE agent is configured with, or somehow knows of, TURN and STUN servers. RELOAD provides a way for an agent to learn these by querying the overlay, as described in Sections 6.5.1.4 and 9.",
      "ja": "ICE仕様では、ICEエージェントがで構成されていることを前提とし、または何らかの形で、TURNとSTUNサーバを知っています。リロード剤は、セクション6.5.1.4および9に記載されているように、オーバーレイを照会することによって、これらを学習するための方法を提供します。"
    },
    {
      "indent": 3,
      "text": "The default candidate selection described in Section 4.1.4 of ICE is ignored; defaults are not signaled or utilized by RELOAD.",
      "ja": "ICEの第4.1.4項で説明するデフォルトの候補の選択は無視されます。デフォルトはシグナリングまたはリロードすることによって利用されません。"
    },
    {
      "indent": 3,
      "text": "An alternative to using the full ICE supported by the Attach request is to use the No-ICE mechanism by providing candidates with \"No-ICE\" Overlay Link protocols. Configuration for the overlay indicates whether or not these Overlay Link protocols can be used. An overlay MUST be either all ICE or all No-ICE.",
      "ja": "アタッチ要求でサポートされているフルICEを使用する代わりに、「いいえ-ICE」オーバーレイリンクプロトコルで候補者を提供することにより、無ICEメカニズムを使用することです。オーバーレイの設定は、これらのオーバーレイリンクプロトコルが使用可能かどうかを示します。オーバーレイは、すべてのICEまたは全てノー-ICEのいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "No-ICE will not work in all the scenarios where ICE would work, but in some cases, particularly those with no NATs or firewalls, it will work.",
      "ja": "無ICEは、ICEが働くだろうすべてのシナリオでは動作しませんしませんが、いくつかのケースでは、特になしのNATやファイアウォールを持つものは、それが動作します。"
    },
    {
      "indent": 0,
      "text": "6.5.1.6. Prioritizing Candidates",
      "section_title": true,
      "ja": "6.5.1.6。優先順位付け候補"
    },
    {
      "indent": 3,
      "text": "Standardization of additional protocols for use with ICE is expected, including TCP [RFC6544] and protocols such as the Stream Control Transmission Protocol (SCTP) [RFC4960] and Datagram Congestion Control Protocol (DCCP) [RFC4340]. UDP encapsulations for SCTP and DCCP would expand the Overlay Link protocols available for RELOAD.",
      "ja": "ICEで使用するための追加のプロトコルの標準化は、TCP [RFC6544]及びそのようなストリーム制御伝送プロトコル（SCTP）[RFC4960]及びデータグラム輻輳制御プロトコル（DCCP）[RFC4340]などのプロトコルを含め、期待されています。 SCTPやDCCPのためのUDPカプセル化は、RELOADために利用可能なオーバーレイリンクプロトコルを拡張します。"
    },
    {
      "indent": 3,
      "text": "When additional protocols are available, the following prioritization is RECOMMENDED:",
      "ja": "追加のプロトコルが使用可能な場合は、以下の優先順位付けをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o Highest priority is assigned to protocols that offer well-understood congestion and flow control without head-of-line blocking, for example, SCTP without message ordering, DCCP, and those protocols encapsulated using UDP.",
      "ja": "O最高優先度は十分に理解輻輳を提供し、メッセージの順序、DCCPことなく、例えば、ヘッドオブラインブロッキングなしSCTPをフロー制御プロトコルに割り当てられ、これらのプロトコルは、UDPを使用してカプセル化されます。"
    },
    {
      "indent": 3,
      "text": "o Second highest priority is assigned to protocols that offer well-understood congestion and flow control, but that have head-of-line blocking, such as TCP.",
      "ja": "O次の優先順位は、よく理解さ輻輳を提供し、フロー制御プロトコルに割り当てられ、それはTCPのようなヘッドオブラインブロッキングを有しています。"
    },
    {
      "indent": 3,
      "text": "o Lowest priority is assigned to protocols encapsulated over UDP that do not implement well-established congestion control algorithms. The DTLS/UDP with Simple Reliability (SR) overlay link protocol is an example of such a protocol.",
      "ja": "O最低優先順位が十分に確立さ輻輳制御アルゴリズムを実装していないUDP上でカプセル化プロトコルに割り当てられています。単純な信頼性（SR）オーバーレイリンクプロトコルDTLS / UDPは、このようなプロトコルの一例です。"
    },
    {
      "indent": 3,
      "text": "Head-of-line blocking is undesirable in an Overlay Link protocol, because the messages carried on a RELOAD link are independent, rather than stream-oriented. Therefore, if message N on a link is lost, delaying message N+1 on that same link until N is successfully retransmitted does nothing other than increase the latency for the transaction of message N+1, as they are unrelated to each other. Therefore, while the high quality, performance, and availability of modern TCP implementations makes them very attractive, their performance as Overlay Link protocols is not optimal.",
      "ja": "RELOADリンクで運ばメッセージは独立した、というよりストリーム指向であるため、ヘッドオブラインブロッキングは、オーバーレイリンクプロトコルでは望ましくありません。したがって、リンク上のメッセージNが失われた場合、Nが正常に再送信されるまで、同じリンク上のメッセージN + 1を遅らせる彼らはお互いに関係のないよう、メッセージのトランザクションのための待ち時間を増やす以外に何もN + 1もしません。現代のTCP実装の高品質、パフォーマンス、可用性、それらは非常に魅力的つつ、オーバーレイリンクプロトコルとしてのパフォーマンスが最適ではありません。"
    },
    {
      "indent": 3,
      "text": "Note that none of the protocols defined in this document meets these conditions, but it is expected that new Overlay Link protocols defined in the future will fill this gap.",
      "ja": "この文書で定義されたプロトコルのどれもが、これらの条件を満たしていないことに注意してください、将来的に定義された新しいオーバーレイリンクプロトコルは、このギャップを埋めることが期待されます。"
    },
    {
      "indent": 0,
      "text": "6.5.1.7. Encoding the Attach Message",
      "section_title": true,
      "ja": "6.5.1.7。アタッチメッセージを符号化"
    },
    {
      "indent": 3,
      "text": "Section 4.3 of ICE describes procedures for encoding the SDP for conveying RELOAD candidates. Instead of actually encoding an SDP message, the candidate information (IP address and port and transport protocol, priority, foundation, type, and related address) is carried within the attributes of the Attach request or its response. Similarly, the username fragment and password are carried in the Attach message or its response. Section 6.5.1 describes the detailed attribute encoding for Attach. The Attach request and its response do not contain any default candidates or the ice-lite attribute, as these features of ICE are not used by RELOAD.",
      "ja": "ICEの4.3節には、RELOAD候補を搬送するためのSDPを符号化するための手順を説明します。代わりに、実際にSDPメッセージを符号化する、候補情報（IPアドレス、ポートおよびトランスポートプロトコル、優先順位、ファンデーション、タイプ、および関連するアドレス）アタッチ要求やその応答の属性の中に運ばれます。同様に、ユーザ名断片とパスワードが添付メッセージまたはその応答で搬送されています。セクション6.5.1は、取り付けのための詳細な属性のエンコーディングを示しています。リクエストを取り付け、ICEのこれらの機能はRELOADによって使用されないように、その応答は、任意のデフォルトの候補や氷-liteの属性が含まれていません。"
    },
    {
      "indent": 3,
      "text": "Since the Attach request contains the candidate information and short term credentials, it is considered as an offer for a single media stream that happens to be encoded in a format different than SDP, but is otherwise considered a valid offer for the purposes of following the ICE specification. Similarly, the Attach response is considered a valid answer for the purposes of following the ICE specification.",
      "ja": "リクエストを接続候補情報と短期資格情報が含まれているので、SDPとは異なるフォーマットでエンコードされたまたま単一のメディアストリームのための提供であると考えられるが、それ以外ICEを以下の目的のために有効なオファーを考えられています仕様。同様に、アタッチ応答は、ICEの仕様を以下の目的のために有効な回答と考えられています。"
    },
    {
      "indent": 0,
      "text": "6.5.1.8. Verifying ICE Support",
      "section_title": true,
      "ja": "6.5.1.8。確認ICEのサポート"
    },
    {
      "indent": 3,
      "text": "An agent MUST skip the verification procedures in Sections 5.1 and 6.1 of ICE. Since RELOAD requires full ICE from all agents, this check is not required.",
      "ja": "エージェントは、セクション5.1とICEの6.1での検証手順をスキップしなければなりません。 RELOADは、すべてのエージェントからのフルICEを必要とするので、このチェックは必要ありません。"
    },
    {
      "indent": 0,
      "text": "6.5.1.9. Role Determination",
      "section_title": true,
      "ja": "6.5.1.9。役割決定"
    },
    {
      "indent": 3,
      "text": "The roles of controlling and controlled, as described in Section 5.2 of ICE, are still utilized with RELOAD. However, the offerer (the entity sending the Attach request) will always be controlling, and the answerer (the entity sending the Attach response) will always be controlled. The connectivity checks MUST still contain the ICE-CONTROLLED and ICE-CONTROLLING attributes, however, even though the role reversal capability for which they are defined will never be needed with RELOAD. This is to allow for a common codebase between ICE for RELOAD and ICE for SDP.",
      "ja": "ICEのセクション5.2で説明したように、制御および制御の役割は、まだリロードして利用されています。しかし、提供者（アタッチ要求を送信するエンティティ）は常に制御され、回答（アタッチ応答を送信するエンティティ）は常に制御されます。接続性チェックは、まだ彼らが定義されている役割の反転能力はRELOADを必要とすることはありませんにもかかわらず、しかし、ICE-制御され、ICE制御属性を含まなければなりません。これは、SDPのためにRELOADとICEのためのICEとの間で共通のコードベースを可能にすることです。"
    },
    {
      "indent": 0,
      "text": "6.5.1.10. Full ICE",
      "section_title": true,
      "ja": "6.5.1.10。フルICE"
    },
    {
      "indent": 3,
      "text": "When the overlay uses ICE, connectivity checks and nominations are used as in regular ICE.",
      "ja": "オーバーレイは、ICEを使用する場合、接続性チェックと指名は通常のICEのように使用されています。"
    },
    {
      "indent": 0,
      "text": "6.5.1.10.1. Connectivity Checks",
      "section_title": true,
      "ja": "6.5.1.10.1。接続性チェック"
    },
    {
      "indent": 3,
      "text": "The processes of forming check lists in Section 5.7 of ICE, scheduling checks in Section 5.8, and checking connectivity checks in Section 7 are used with RELOAD without change.",
      "ja": "、ICEの5.7節にチェックリストを構成するセクション5.8にチェックをスケジュールし、セクション7で接続性チェックをチェックするプロセスは変更せずにRELOADと一緒に使用されています。"
    },
    {
      "indent": 0,
      "text": "6.5.1.10.2. Concluding ICE",
      "section_title": true,
      "ja": "6.5.1.10.2。結論ICE"
    },
    {
      "indent": 3,
      "text": "The procedures in Section 8 of ICE are followed to conclude ICE, with the following exceptions:",
      "ja": "ICEの第8章の手順は、以下の例外を除いて、ICEを締結するために従わされています。"
    },
    {
      "indent": 3,
      "text": "o The controlling agent MUST NOT attempt to send an updated offer once the state of its single media stream reaches Completed.",
      "ja": "O制御剤は、単一のメディアストリームの状態が完了に達すると、更新のオファーを送信することを試みてはいけません。"
    },
    {
      "indent": 3,
      "text": "o Once the state of ICE reaches Completed, the agent can immediately free all unused candidates. This is because RELOAD does not have the concept of forking, and thus the three-second delay in Section 8.3 of ICE does not apply.",
      "ja": "ICEが到達の状態が完了したら、O、エージェントは、すべての未使用の候補すぐに解放することができます。 RELOADはフォークの概念がないので、ICEのセクション8.3で3秒の遅延が適用されないためです。"
    },
    {
      "indent": 0,
      "text": "6.5.1.10.3. Media Keepalives",
      "section_title": true,
      "ja": "6.5.1.10.3。メディアキープアライブ"
    },
    {
      "indent": 3,
      "text": "STUN MUST be utilized for the keepalives described in Section 10 of ICE.",
      "ja": "STUNは、ICEのセクション10に記載のキープアライブするために利用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.5.1.11. No-ICE",
      "section_title": true,
      "ja": "6.5.1.11。無ICEありません"
    },
    {
      "indent": 3,
      "text": "No-ICE is selected when either side has provided \"no ICE\" Overlay Link candidates. STUN is not used for connectivity checks when doing No-ICE; instead, the DTLS or TLS handshake (or similar security layer of future overlay link protocols) forms the connectivity check. The certificate exchanged during the TLS or DTLS handshake MUST match the node which sent the AttachReqAns, and if it does not, the connection MUST be closed.",
      "ja": "どちらかの側が「ノーICE」オーバーレイリンクの候補を提供した際ませ-ICEが選択されていません。無ICEをやっていないとき、STUNは、接続性チェックのために使用されていません。代わりに、DTLSまたはTLSハンドシェイク（または将来のオーバーレイリンク・プロトコルの同様のセキュリティ層）が接続性チェックを形成しています。証明書はAttachReqAnsを送信したノードと一致しなければならないTLSまたはDTLSハンドシェーク中に交換し、そうでない場合は、接続が閉じられなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.5.1.12. Subsequent Offers and Answers",
      "section_title": true,
      "ja": "6.5.1.12。その後のオファーと回答"
    },
    {
      "indent": 3,
      "text": "An agent MUST NOT send a subsequent offer or answer. Thus, the procedures in Section 9 of ICE MUST be ignored.",
      "ja": "エージェントは、その後の申し出または回答を送ってはいけません。このように、ICEの第9節の手順を無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.5.1.13. Sending Media",
      "section_title": true,
      "ja": "6.5.1.13。送信するメディア"
    },
    {
      "indent": 3,
      "text": "The procedures of Section 11 of ICE apply to RELOAD as well. However, in this case, the \"media\" takes the form of application-layer protocols (e.g., RELOAD) over TLS or DTLS. Consequently, once ICE processing completes, the agent will begin TLS or DTLS procedures to establish a secure connection. The node that sent the Attach request MUST be the TLS server. The other node MUST be the TLS client. The server MUST request TLS client authentication. The nodes MUST verify that the certificate presented in the handshake matches the identity of the other peer as found in the Attach message. Once the TLS or DTLS signaling is complete, the application protocol is free to use the connection.",
      "ja": "ICEのセクション11の手順は、同様にリロードする適用されます。しかし、この場合には、「メディア」は、TLSまたはDTLSオーバーアプリケーション層プロトコル（例えば、RELOAD）の形をとります。 ICEの処理が完了すると結果的に、エージェントは、安全な接続を確立するために、TLSまたはDTLS手続きを開始します。アタッチ要求を送信したノードは、TLSサーバでなければなりません。他のノードは、TLSクライアントでなければなりません。サーバはTLSクライアント認証を要求しなければなりません。ノードがアタッチメッセージで見られるようなハンドシェイクに提示された証明書は、他のピアのアイデンティティと一致することを確認しなければなりません。 TLSまたはDTLSシグナリングが完了すると、アプリケーションプロトコルは、接続を使用して自由です。"
    },
    {
      "indent": 3,
      "text": "The concept of a previous selected pair for a component does not apply to RELOAD, since ICE restarts are not possible with RELOAD.",
      "ja": "ICEの再起動がRELOADでは不可能なので、コンポーネントの前の選択されたペアの概念は、RELOADには適用されません。"
    },
    {
      "indent": 0,
      "text": "6.5.1.14. Receiving Media",
      "section_title": true,
      "ja": "6.5.1.14。受信メディア"
    },
    {
      "indent": 3,
      "text": "An agent MUST be prepared to receive packets for the application protocol (TLS or DTLS carrying RELOAD) at any time. The jitter and RTP considerations in Section 11 of ICE do not apply to RELOAD.",
      "ja": "エージェントは、いつでもアプリケーションプロトコル（TLSまたはリロードを運ぶDTLS）のためのパケットを受信するように準備しなければなりません。 ICEの第11節で、ジッタとRTPの考慮事項がRELOADには適用されません。"
    },
    {
      "indent": 0,
      "text": "6.5.2. AppAttach",
      "section_title": true,
      "ja": "6.5.2。 Appattac"
    },
    {
      "indent": 3,
      "text": "A node sends an AppAttach request when it wishes to establish a direct connection to another node for the purposes of sending application-layer messages. AppAttach is nearly identical to Attach, except for the purpose of the connection: it is used to transport non-RELOAD \"media\". A separate request is used to avoid implementer confusion between the two methods (this was found to be a real problem with initial implementations). The AppAttach request and its response contain an application attribute, which indicates what protocol is to be run over the connection.",
      "ja": "それはアプリケーション層メッセージを送信する目的のために別のノードへの直接接続を確立することを望む場合、ノードはAppAttach要求を送信します。 AppAttachは、接続の目的を除いて、アタッチとほぼ同じである：非RELOAD「メディア」を輸送するのに使用されます。別リクエストは2つの方法の間の実装の混乱を避けるために使用される（これは初期の実装と実際の問題であることが判明しました）。 AppAttach要求とその応答は、プロトコルが接続を介して実行されるかを示すアプリケーション属性が含まれています。"
    },
    {
      "indent": 0,
      "text": "6.5.2.1. Request Definition",
      "section_title": true,
      "ja": "6.5.2.1。要求定義"
    },
    {
      "indent": 3,
      "text": "An AppAttachReq message contains the requesting node's ICE connection parameters formatted into a binary structure.",
      "ja": "AppAttachReqメッセージは、バイナリ構造にフォーマット要求ノードのICE接続パラメータを含んでいます。"
    },
    {
      "indent": 8,
      "text": "struct {\n  opaque                  ufrag<0..2^8-1>;\n  opaque                  password<0..2^8-1>;\n  uint16                  application;\n  opaque                  role<0..2^8-1>;\n  IceCandidate            candidates<0..2^16-1>;\n} AppAttachReq;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The values contained in AppAttachReq and AppAttachAns are:",
      "ja": "AppAttachReqとAppAttachAnsに含まれる値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "ufrag The username fragment (from ICE).",
      "ja": "（ICE）からユーザ名フラグメントをufrag。"
    },
    {
      "indent": 3,
      "text": "password The ICE password.",
      "ja": "パスワードICEのパスワード。"
    },
    {
      "indent": 3,
      "text": "application A 16-bit Application-ID, as defined in the Section 14.5. This number represents the IANA-registered application that is going to send data on this connection.",
      "ja": "アプリケーションA 16ビットアプリケーションID、セクション14.5で定義された通りです。この数は、この接続でデータを送信するために起こっているIANA-登録されたアプリケーションを表します。"
    },
    {
      "indent": 3,
      "text": "role An active/passive/actpass attribute from RFC 4145 [RFC4145].",
      "ja": "役割RFC 4145 [RFC4145]からアクティブ/パッシブ/ actpass属性。"
    },
    {
      "indent": 3,
      "text": "candidates One or more ICE candidate values.",
      "ja": "候補者一つ以上のICE候補値。"
    },
    {
      "indent": 3,
      "text": "The application using the connection that is set up with this request is responsible for providing traffic of sufficient frequency to keep the NAT and Firewall binding alive. Applications will often send traffic every 25 seconds to ensure this.",
      "ja": "この要求で設定された接続を使用しているアプリケーションは、NATを維持するために十分な周波数のトラフィックを提供し、ファイアウォールが生きて結合する責任があります。アプリケーションは、多くの場合、これを確実にするために25秒ごとにトラフィックを送信します。"
    },
    {
      "indent": 0,
      "text": "6.5.2.2. Response Definition",
      "section_title": true,
      "ja": "6.5.2.2。レスポンスの定義"
    },
    {
      "indent": 3,
      "text": "If a peer receives an AppAttach request, it SHOULD process the request and generate its own response with a AppAttachAns. It should then begin ICE checks. When a peer receives an AppAttach response, it SHOULD parse the response and begin its own ICE checks. If the Application ID is not supported, the peer MUST reply with an Error_Not_Found error.",
      "ja": "ピアがAppAttach要求を受信した場合、その要求を処理しAppAttachAnsを持つ独自の応答を生成する必要があります。その後、ICEのチェックを開始する必要があります。ピアがAppAttach応答を受信すると、応答を解析し、独自のICEチェックを開始する必要があります。アプリケーションIDがサポートされていない場合、ピアはERROR_NOT_FOUNDエラーで応答しなければなりません。"
    },
    {
      "indent": 8,
      "text": "struct {\n  opaque                  ufrag<0..2^8-1>;\n  opaque                  password<0..2^8-1>;\n  uint16                  application;\n  opaque                  role<0..2^8-1>;\n  IceCandidate            candidates<0..2^16-1>;\n} AppAttachAns;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The meaning of the fields is the same as in the AppAttachReq.",
      "ja": "フィールドの意味はAppAttachReqと同じです。"
    },
    {
      "indent": 0,
      "text": "6.5.3. Ping",
      "section_title": true,
      "ja": "6.5.3。 Pingの"
    },
    {
      "indent": 3,
      "text": "Ping is used to test connectivity along a path. A ping can be addressed to a specific Node-ID, to the peer controlling a given location (by using a Resource-ID), or to the wildcard Node-ID.",
      "ja": "Pingのは、パスに沿って接続性をテストするために使用されます。 pingが（リソース-IDを使用して）、またはワイルドカードノードIDに付与された位置を制御するピアに、特定のノードIDに対処することができます。"
    },
    {
      "indent": 0,
      "text": "6.5.3.1. Request Definition",
      "section_title": true,
      "ja": "6.5.3.1。要求定義"
    },
    {
      "indent": 3,
      "text": "The PingReq structure is used to make a Ping request.",
      "ja": "PingReq構造は、Ping要求を行うために使用されます。"
    },
    {
      "indent": 8,
      "text": "struct {\n  opaque<0..2^16-1> padding;\n} PingReq;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Ping request is empty of meaningful contents. However, it may contain up to 65535 bytes of padding to facilitate the discovery of overlay maximum packet sizes.",
      "ja": "Ping要求は、意味のある内容の空です。しかし、それはオーバーレイ最大パケットサイズの発見を容易にするために、パディングの最大65535のバイトが含まれていてもよいです。"
    },
    {
      "indent": 0,
      "text": "6.5.3.2. Response Definition",
      "section_title": true,
      "ja": "6.5.3.2。レスポンスの定義"
    },
    {
      "indent": 3,
      "text": "A successful PingAns response contains the information elements requested by the peer.",
      "ja": "成功PingAns応答は、ピアによって要求された情報要素が含まれています。"
    },
    {
      "indent": 9,
      "text": "struct {\n  uint64                 response_id;\n  uint64                 time;\n} PingAns;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A PingAns message contains the following elements:",
      "ja": "PingAnsメッセージには、次の要素が含まれます。"
    },
    {
      "indent": 3,
      "text": "response_id A randomly generated 64-bit response ID. This is used to distinguish Ping responses.",
      "ja": "ランダムに生成された64ビットの応答IDをRESPONSE_ID。これは、pingの応答を区別するために使用されます。"
    },
    {
      "indent": 3,
      "text": "time The time when the Ping response was created, represented in the same way as storage_time, defined in Section 7.",
      "ja": "時間のPing応答が作成された時間は、7節で定義されたstorage_time、同じ方法で表現しました。"
    },
    {
      "indent": 0,
      "text": "6.5.4. ConfigUpdate",
      "section_title": true,
      "ja": "6.5.4。あるConfigUpdate"
    },
    {
      "indent": 3,
      "text": "The ConfigUpdate method is used to push updated configuration data across the overlay. Whenever a node detects that another node has old configuration data, it MUST generate a ConfigUpdate request. The ConfigUpdate request allows updating of two kinds of data: the configuration data (Section 6.3.2.1) and the Kind information (Section 7.4.1.1).",
      "ja": "あるConfigUpdate方法は、オーバーレイ全体で更新された設定データをプッシュするために使用されます。ノードが別のノードが古い構成データを持っていることを検出するたびに、それはあるConfigUpdate要求を発生させなければなりません。構成データ（セクション6.3.2.1）と種類の情報（セクション7.4.1.1）：あるConfigUpdate要求は、2種類のデータの更新を可能にします。"
    },
    {
      "indent": 0,
      "text": "6.5.4.1. Request Definition",
      "section_title": true,
      "ja": "6.5.4.1。要求定義"
    },
    {
      "indent": 3,
      "text": "The ConfigUpdateReq structure is used to provide updated configuration information.",
      "ja": "ConfigUpdateReq構造が更新された構成情報を提供するために使用されます。"
    },
    {
      "indent": 8,
      "text": "enum { invalidConfigUpdateType(0), config(1), kind(2), (255) }\n     ConfigUpdateType;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "typedef uint32           KindId;\ntypedef opaque           KindDescription<0..2^16-1>;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  ConfigUpdateType       type;\n  uint32                 length;",
      "raw": true
    },
    {
      "indent": 10,
      "text": "select (type) { case config: opaque config_data<0..2^24-1>;",
      "ja": "（タイプ）{ケースの設定選択：不透明CONFIG_DATA <0..2 ^ 24-1>。"
    },
    {
      "indent": 12,
      "text": "case kind: KindDescription kinds<0..2^24-1>;",
      "ja": "ケースの種類：KindDescriptionの種類<0..2 ^ 24-1>;"
    },
    {
      "indent": 8,
      "text": "    /* This structure may be extended with new types */\n  };\n} ConfigUpdateReq;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The ConfigUpdateReq message contains the following elements:",
      "ja": "ConfigUpdateReqメッセージには、次の要素が含まれます。"
    },
    {
      "indent": 3,
      "text": "type The type of the contents of the message. This structure allows for unknown content types.",
      "ja": "メッセージの内容の種類を入力します。この構造は、未知のコンテンツタイプが可能になります。"
    },
    {
      "indent": 3,
      "text": "length The length of the remainder of the message. This is included to preserve backward compatibility and is 32 bits instead of 24 to facilitate easy conversion between network and host byte order.",
      "ja": "長メッセージの残りの長さ。これは、下位互換性を維持するために含まれ、代わりに24の32ビットがネットワークとホストバイトオーダーとの間の容易な変換を容易にするためです。"
    },
    {
      "indent": 3,
      "text": "config_data (type==config) The contents of the Configuration Document.",
      "ja": "CONFIG_DATA（タイプ==設定）設定文書の内容。"
    },
    {
      "indent": 3,
      "text": "kinds (type==kind) One or more XML kind-block productions (see Section 11.1). These MUST be encoded with UTF-8 and assume a default namespace of \"urn:ietf:params:xml:ns:p2p:config-base\".",
      "ja": "種類（タイプ==一種）は、1つまたは複数のXML種類ブロックプロダクション（11.1節を参照してください）。これらは、UTF-8でエンコードされ、 \"壷：IETF：のparams：XML：NS：P2Pます。config-ベース\" のデフォルトの名前空間を想定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.5.4.2. Response Definition",
      "section_title": true,
      "ja": "6.5.4.2。レスポンスの定義"
    },
    {
      "indent": 3,
      "text": "The ConfigUpdateAns structure is used to respond to a ConfigUpdateReq request.",
      "ja": "ConfigUpdateAns構造はConfigUpdateReq要求に応答するために使用されます。"
    },
    {
      "indent": 8,
      "text": "struct {\n} ConfigUpdateAns;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the ConfigUpdateReq is of type \"config\", it MUST be processed only if all the following are true:",
      "ja": "：ConfigUpdateReqはタイプ「設定」である場合、すべて、以下に該当する場合にのみ、処理しなければなりません"
    },
    {
      "indent": 3,
      "text": "o The sequence number in the document is greater than the current configuration sequence number.",
      "ja": "O文書内のシーケンス番号は、現在のコンフィギュレーション・シーケンス番号よりも大きいです。"
    },
    {
      "indent": 3,
      "text": "o The Configuration Document is correctly digitally signed (see Section 11 for details on signatures).",
      "ja": "O設定文書が正しくデジタル（署名の詳細については、セクション11を参照）が署名されています。"
    },
    {
      "indent": 3,
      "text": "Otherwise, appropriate errors MUST be generated.",
      "ja": "そうでない場合、適切なエラーが生成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the ConfigUpdateReq is of type \"kind\", it MUST be processed only if it is correctly digitally signed by an acceptable Kind signer (i.e., one listed in the current configuration file). Details on the kind-signer field in the configuration file are described in Section 11.1. In addition, if the Kind update conflicts with an existing known Kind (i.e., it is signed by a different signer), then it should be rejected with an Error_Forbidden error. This should not happen in correctly functioning overlays.",
      "ja": "ConfigUpdateReqタイプ「種類」である場合、それが正しくデジタル的に許容される種類署名者により署名されている場合、それは唯一の処理されなければならない（すなわち、現在の設定ファイルにリストされているもの）。設定ファイルの種類、署名者のフィールドの詳細については、セクション11.1で説明されています。加えて、既存の知られている種類（すなわち、それは異なる署名者によって署名されている）を有する種類の更新の競合場合、それはError_Forbiddenエラーで拒否されるべきです。これが正常に機能オーバーレイでは発生しないはずです。"
    },
    {
      "indent": 3,
      "text": "If the update is acceptable, then the node MUST reconfigure itself to match the new information. This may include adding permissions for new Kinds, deleting old Kinds, or even, in extreme circumstances, exiting and re-entering the overlay, if, for instance, the DHT algorithm has changed.",
      "ja": "更新が許容可能である場合、ノードは、新しい情報に一致するように自分自身を再構成する必要があります。これは、例えば、DHTアルゴリズムが変更された場合など、新たな種類のアクセス権を追加古い種類の削除、あるいは、極端な状況では、オーバーレイを終了し、再入力含むことができます。"
    },
    {
      "indent": 3,
      "text": "If an implementation misses enough ConfigUpdates that include key changes, it is possible that it will no longer be able to verify new valid ConfigUpdates. In this case, the only available recovery mechanism is to attempt to retrieve a new Configuration Document, typically by the mechanisms used for initial bootstrapping. It is up to implementers whether or how to decide to employ this sort of recovery mechanism.",
      "ja": "実装は、キーの変更を含め、十分なConfigUpdatesをミスした場合、もはや新しい有効なConfigUpdatesを確認することができなくなる可能性があります。この場合は、のみ利用可能なリカバリメカニズムは、典型的には、初期ブートストラップに使用されるメカニズムによって、新しい設定文書を取得しようとすることです。これは、回復メカニズムのこの種を採用することを決定するために、実装までかどうか方法です。"
    },
    {
      "indent": 3,
      "text": "The response for ConfigUpdate is empty.",
      "ja": "あるConfigUpdateの応答は空です。"
    },
    {
      "indent": 0,
      "text": "6.6. Overlay Link Layer",
      "section_title": true,
      "ja": "6.6。オーバーレイリンク層"
    },
    {
      "indent": 3,
      "text": "RELOAD can use multiple Overlay Link protocols to send its messages. Because ICE is used to establish connections (see Section 6.5.1.3), RELOAD nodes are able to detect which Overlay Link protocols are offered by other nodes and establish connections between them. Any link protocol needs to be able to establish a secure, authenticated connection and to provide data origin authentication and message integrity for individual data elements. RELOAD currently supports three Overlay Link protocols:",
      "ja": "RELOADは、そのメッセージを送信するために、複数のオーバーレイ・リンク・プロトコルを使用することができます。 ICEは（セクション6.5.1.3を参照）接続を確立するために使用されているので、RELOADノードは、オーバーレイリンクプロトコルは、他のノードによって提供されると、それらの間の接続を確立しているかを検出することができます。任意のリンクプロトコルは、セキュア、認証された接続を確立するために、個々のデータ要素のためのデータ発信元認証とメッセージの完全性を提供するために、できるようにする必要があります。 RELOADは現在、3つのオーバーレイリンクプロトコルをサポートしています。"
    },
    {
      "indent": 3,
      "text": "o DTLS [RFC6347] over UDP with Simple Reliability (SR) (OverlayLinkType=DTLS-UDP-SR)",
      "ja": "単純な信頼性（SR）とUDP上O DTLS [RFC6347]（OverlayLinkType = DTLS-UDP-SR）"
    },
    {
      "indent": 3,
      "text": "o TLS [RFC5246] over TCP with Framing Header, No-ICE (OverlayLinkType=TLS-TCP-FH-NO-ICE)",
      "ja": "フレーミングヘッダ、無氷TCPオーバーO TLS [RFC5246]（OverlayLinkType = TLS-TCP-FH-NO-ICE）"
    },
    {
      "indent": 3,
      "text": "o DTLS [RFC6347] over UDP with SR, No-ICE (OverlayLinkType=DTLS-UDP-SR-NO-ICE)",
      "ja": "O DTLS SRとUDPオーバー[RFC6347]、無ICE（OverlayLinkType = DTLS-UDP-SR-NO-ICE）"
    },
    {
      "indent": 3,
      "text": "Note that although UDP does not properly have \"connections\", both TLS and DTLS have a handshake that establishes a similar, stateful association. We refer to these as \"connections\" for the purposes of this document.",
      "ja": "UDPは適切に「接続」を持っていませんが、TLSとDTLSの両方が同様の、ステートフルな関連付けを確立ハンドシェイクを持っていることに注意してください。私たちは、この文書の目的のための「接続」としてこれらを参照してください。"
    },
    {
      "indent": 3,
      "text": "If a peer receives a message that is larger than the value of max-message-size defined in the overlay configuration, the peer SHOULD send an Error_Message_Too_Large error and then close the TLS or DTLS session from which the message was received. Note that this error can be sent and the session closed before the peer receives the complete message. If the forwarding header is larger than the max- message-size, the receiver SHOULD close the TLS or DTLS session without sending an error.",
      "ja": "ピアがオーバーレイ構成で定義された最大メッセージサイズの値よりも大きいメッセージを受信した場合、ピアはError_Message_Too_Largeエラーを送信し、そのメッセージを受信したTLSまたはDTLSセッションを閉じる必要があります。このエラーが送信され、ピアが完全なメッセージを受け取る前にセッションを閉じることができることに注意してください。転送ヘッダは、MAX-メッセージサイズより大きい場合、受信機はエラーを送信することなく、TLSまたはDTLSセッションを閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "The RELOAD mechanism requires that failed links be quickly removed from the Routing Table so end-to-end retransmission can handle lost messages. Overlay Link protocols MUST be designed with a mechanism that quickly signals a likely failure, and implementations SHOULD quickly act to remove a failed link from the Routing Table when receiving this signal. The entry can be restored if it proves to resume functioning, or it can be replaced at some point in the future if necessary. Section 10.7.2 contains more details specific to the CHORD-RELOAD Topology Plug-in.",
      "ja": "RELOADメカニズムが失敗したリンクはすぐにそうエンドツーエンド再送が失われたメッセージを処理することができますルーティングテーブルから削除されている必要があります。オーバーレイリンクプロトコルは迅速おそらく失敗したことを知らせる機構を設計する必要があり、かつ実装が迅速にこの信号を受信した場合にルーティングテーブルから、故障したリンクを削除するように行動しなければなりません。それが機能して再開することを証明している場合は、エントリを復元することができ、または必要であれば、それは将来のある時点で交換することができます。セクション10.7.2は、CHORD-RELOADトポロジプラグインに固有の詳細が含まれています。"
    },
    {
      "indent": 3,
      "text": "The Framing Header (FH) is used to frame messages and provide timing when used on a reliable stream-based transport protocol. Simple Reliability (SR) uses the FH to provide congestion control and partial reliability when using unreliable message-oriented transport protocols. We will first define each of these algorithms in Sections 6.6.2 and 6.6.3, and then define Overlay Link protocols that use them in Sections 6.6.4, 6.6.5, and 6.6.6.",
      "ja": "フレーミングヘッダ（FH）は、メッセージフレームで信頼性の高いストリームベースのトランスポートプロトコルに使用されたときのタイミングを提供するために使用されます。単純な信頼性（SR）は、信頼できないメッセージ指向のトランスポートプロトコルを使用する場合、輻輳制御と部分的信頼性を提供するために、FHを使用します。私たちは、最初のセクション6.6.2と6.6.3でこれらのアルゴリズムのそれぞれを定義し、セクション6.6.4、6.6.5、および6.6.6でそれらを使用するオーバーレイリンクプロトコルを定義します。"
    },
    {
      "indent": 3,
      "text": "Note: We expect future Overlay Link protocols to define replacements for all components of these protocols, including the Framing Header. The three protocols that we will discuss have been chosen for simplicity of implementation and reasonable performance.",
      "ja": "注意：私たちは、フレーミングヘッダを含むこれらのプロトコルのすべてのコンポーネントのための代替品を定義するために、将来のオーバーレイリンクプロトコルを期待しています。私たちが議論する3つのプロトコルを実装し、妥当なパフォーマンスを簡単にするために選択されています。"
    },
    {
      "indent": 0,
      "text": "6.6.1. Future Overlay Link Protocols",
      "section_title": true,
      "ja": "6.6.1。今後のオーバーレイリンクプロトコル"
    },
    {
      "indent": 3,
      "text": "It is possible to define new link-layer protocols and apply them to a new overlay using the \"overlay-link-protocol\" configuration directive (see Section 11.1.). However, any new protocols MUST meet the following requirements:",
      "ja": "新しいリンク層プロトコルを定義し、「オーバーレイ・リンク・プロトコル」の設定ディレクティブを使用して、新しいオーバーレイに適用することが可能である（11.1節を参照してください。）。しかし、任意の新しいプロトコルは、次の要件を満たす必要があります。"
    },
    {
      "indent": 3,
      "text": "Endpoint authentication: When a node forms an association with another endpoint, it MUST be possible to cryptographically verify that the endpoint has a given Node-ID.",
      "ja": "エンドポイント認証：ノードが別のエンドポイントとのアソシエーションを形成する場合、それはエンドポイントが与えられたノードIDを有していることを確認暗号ことができなければなりません。"
    },
    {
      "indent": 3,
      "text": "Traffic origin authentication and integrity: When a node receives traffic from another endpoint, it MUST be possible to cryptographically verify that the traffic came from a given association and that it has not been modified in transit from the other endpoint in the association. The overlay link protocol MUST also provide replay prevention/detection.",
      "ja": "トラフィック送信元認証と完全性：ノードが別のエンドポイントからのトラフィックを受信した場合、トラフィックが特定の団体から来て、それが関連して、他のエンドポイントからのトランジットで変更されていないことことを確認し、暗号が可能でなければなりません。オーバーレイ・リンクプロトコルはまた、リプレイ防止/検出を提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Traffic confidentiality: When a node sends traffic to another endpoint, it MUST NOT be possible for a third party that is not involved in the association to determine the contents of that traffic.",
      "ja": "トラフィックの機密性：ノードが別のエンドポイントにトラフィックを送信すると関連して関与しない第三者がそのトラフィックの内容を決定するために、それが可能にすることはできません。"
    },
    {
      "indent": 3,
      "text": "Any new overlay protocol MUST be defined via Standards Action [RFC5226]. See Section 14.11.",
      "ja": "すべての新しいオーバーレイプロトコルが標準化アクション[RFC5226]で定義されなければなりません。セクション14.11を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.6.1.1. HIP",
      "section_title": true,
      "ja": "6.6.1.1。 HIP"
    },
    {
      "indent": 3,
      "text": "In a Host Identity Protocol Based Overlay Networking Environment (HIP BONE) [RFC6079], HIP [RFC5201] provides connection management (e.g., NAT traversal and mobility) and security for the overlay network. The P2PSIP Working Group has expressed interest in supporting a HIP-based link protocol. Such support would require specifying such details as:",
      "ja": "ホストアイデンティティプロトコルベースのオーバレイネットワーク環境（寛骨）[RFC6079]、HIP [RFC5201]にオーバーレイ・ネットワークの接続管理（例えば、NATトラバーサル及び移動度）とセキュリティを提供します。 P2PSIPワーキンググループでは、HIPベースのリンクプロトコルをサポートすることに関心を表明しています。このようなサポートは、このような詳細を指定する必要になります。"
    },
    {
      "indent": 3,
      "text": "o How to issue certificates which provide identities meaningful to the HIP base exchange. We anticipate that this would require a mapping between Overlay Routable Cryptographic Hash Identifiers (ORCHIDs) and NodeIds.",
      "ja": "O HIPベース交換に意味のあるIDを提供証明書を発行する方法。これはオーバーレイルーティング可能な暗号学的ハッシュ識別子（蘭）とノード識別子との間のマッピングが必要となることを期待しています。"
    },
    {
      "indent": 3,
      "text": "o How to carry the HIP I1 and I2 messages.",
      "ja": "O HIP I1とI2のメッセージを伝える方法。"
    },
    {
      "indent": 3,
      "text": "o How to carry RELOAD messages over HIP.",
      "ja": "O HIP上RELOADメッセージを伝える方法。"
    },
    {
      "indent": 3,
      "text": "[HIP-RELOAD] documents work in progress on using RELOAD with the HIP BONE.",
      "ja": "[HIP-RELOAD]文書は、股関節の骨とRELOADを使用して進行中の作業します。"
    },
    {
      "indent": 0,
      "text": "6.6.1.2. ICE-TCP",
      "section_title": true,
      "ja": "6.6.1.2。 ICE-TCP"
    },
    {
      "indent": 3,
      "text": "The ICE-TCP RFC [RFC6544] allows TCP to be supported as an Overlay Link protocol that can be added using ICE.",
      "ja": "ICE-TCP RFC [RFC6544]はTCPがICEを使用して追加することができるオーバーレイリンク・プロトコルとしてサポートすることを可能にします。"
    },
    {
      "indent": 0,
      "text": "6.6.1.3. Message-Oriented Transports",
      "section_title": true,
      "ja": "6.6.1.3。メッセージ指向トランスポート"
    },
    {
      "indent": 3,
      "text": "Modern message-oriented transports offer high performance and good congestion control, and they avoid head-of-line blocking in case of lost data. These characteristics make them preferable as underlying transport protocols for RELOAD links. SCTP without message ordering and DCCP are two examples of such protocols. However, currently they are not well-supported by commonly available NATs, and specifications for ICE session establishment are not available.",
      "ja": "近代的なメッセージ指向のトランスポートは、高い性能と優れた輻輳制御を提供し、彼らは失われたデータの場合にはヘッドオブラインブロッキングを避けます。これらの特性は、RELOADリンクの基礎となるトランスポートプロトコル、それらに好適にします。メッセージの順序とDCCPのないSCTPは、そのようなプロトコルの2つの例です。しかし、現在、彼らは一般的に利用可能なNATのことで、よくサポートされていない、とICEのセッション確立のための仕様は使用できません。"
    },
    {
      "indent": 0,
      "text": "6.6.1.4. Tunneled Transports",
      "section_title": true,
      "ja": "6.6.1.4。トンネル化トランスポート"
    },
    {
      "indent": 3,
      "text": "As of the time of this writing, there is significant interest in the IETF community in tunneling other transports over UDP, which is motivated by the situation that UDP is well-supported by modern NAT hardware and by the fact that performance similar to a native implementation can be achieved. Currently, SCTP, DCCP, and a generic tunneling extension are being proposed for message-oriented protocols. Once ICE traversal has been specified for these tunneled protocols, they should be straightforward to support as overlay link protocols.",
      "ja": "これを書いている時点では、ネイティブ実装と同等の性能UDPは、近代的なNATのハードウェアによって、実際によくサポートされている状況によって動機づけされるUDP、オーバートンネリング他のトランスポートでのIETFコミュニティに大きな関心があります達成することができます。現在、SCTP、DCCP、および一般的なトンネリングの拡張子は、メッセージ指向のプロトコルのために提案されています。 ICEトラバーサルは、これらのトンネリングプロトコル用に指定されていたら、彼らはのように、オーバーレイリンクプロトコルをサポートするのは簡単でなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.6.2. Framing Header",
      "section_title": true,
      "ja": "6.6.2。フレーミングヘッダー"
    },
    {
      "indent": 3,
      "text": "In order to support unreliable links and to allow for quick detection of link failures when using reliable end-to-end transports, each message is wrapped in a very simple framing layer (FramedMessage), which is used only for each hop. This layer contains a sequence number which can then be used for ACKs. The same header is used for both reliable and unreliable transports for simplicity of implementation.",
      "ja": "信頼できないリンクをサポートし、信頼性の高いエンドツーエンドのトランスポートを使用している場合、リンク障害の迅速な検出を可能にするために、各メッセージは、唯一の各ホップのために使用されている非常にシンプルなフレーミング層（FramedMessage）、に包まれています。この層は、その後のACKのために使用することができるシーケンス番号が含まれています。同じヘッダは、実装を簡単にするために信頼性が高く信頼性の低いトランスポートの両方に使用されます。"
    },
    {
      "indent": 3,
      "text": "The definition of FramedMessage is:",
      "ja": "FramedMessageの定義は次のとおりです。"
    },
    {
      "indent": 8,
      "text": "enum { data(128), ack(129), (255) } FramedMessageType;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  FramedMessageType       type;",
      "raw": true
    },
    {
      "indent": 10,
      "text": "select (type) {\n  case data:\n    uint32              sequence;\n    opaque              message<0..2^24-1>;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "    case ack:\n      uint32              ack_sequence;\n      uint32              received;\n  };\n} FramedMessage;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The type field of the PDU is set to indicate whether the message is data or an acknowledgement.",
      "ja": "PDUのタイプフィールドは、メッセージがデータ又は確認応答であるかどうかを示すために設定されています。"
    },
    {
      "indent": 3,
      "text": "If the message is of type \"data\", then the remainder of the PDU is as follows:",
      "ja": "メッセージのタイプが「データ」である場合、次のようにPDUの残りの部分です。"
    },
    {
      "indent": 3,
      "text": "sequence The sequence number. This increments by one for each framed message sent over this transport session.",
      "ja": "シーケンス番号をシーケンス。これは、このトランスポート・セッションを介して送信される各フレームのメッセージに1つずつ増加します。"
    },
    {
      "indent": 3,
      "text": "message The message that is being transmitted.",
      "ja": "メッセージが送信されるメッセージ。"
    },
    {
      "indent": 3,
      "text": "Each connection has it own sequence number space. Initially, the value is zero, and it increments by exactly one for each message sent over that connection.",
      "ja": "各接続は、それ自身のシーケンス番号空間があります。最初に、値はゼロであり、それは、その接続を介して送信されるメッセージごとに正確に1つ増分します。"
    },
    {
      "indent": 3,
      "text": "When the receiver receives a message, it SHOULD immediately send an ACK message. The receiver MUST keep track of the 32 most recent sequence numbers received on this association in order to generate the appropriate ACK.",
      "ja": "受信者がメッセージを受信すると、それはすぐにACKメッセージを送るべきです。受信機は、適切なACKを生成するために、この関連で受信された32個の最新のシーケンス番号を追跡する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the PDU is of type \"ack\", the contents are as follows:",
      "ja": "PDUはタイプ「ACK」である場合は、次のように内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "ack_sequence The sequence number of the message being acknowledged.",
      "ja": "認知されたメッセージのシーケンス番号をack_sequence。"
    },
    {
      "indent": 3,
      "text": "received A bitmask indicating if each of the previous 32 sequence numbers before this packet has been among the 32 packets most recently received on this connection. When a packet is received with a sequence number N, the receiver looks at the sequence number of the 32 previously received packets on this connection. We call the previously received packet number M. For each of the previous 32 packets, if the sequence number M is less than N but greater than N-32, the N-M bit of the received bitmask is set to one; otherwise, it is set to zero. Note that a bit being set to one indicates positively that a particular packet was received, but a bit being set to zero means only that it is unknown whether or not the packet has been received, because it might have been received before the 32 most recently received packets.",
      "ja": "以前の32個のシーケンス番号のそれぞれは、このパケットは最も最近、この接続上で受信されたパケットのうち32される前かどうかを示すビットマスクを受信しました。パケットは、シーケンス番号Nで受信された場合、受信機は、この接続上で32の以前に受信したパケットのシーケンス番号を調べ。シーケンス番号MがNよりも小さいが、N-32よりも大きい場合、我々は、受信したビットマスクのN-Mビットが1にセットされ、前の32のパケットの各々について、以前に受信したパケットの数Mを呼び出します。それ以外の場合はゼロに設定されています。 1に設定されているビットは、特定のパケットを受信したことを確実に示しますが、ゼロに設定されているビットは、それが最近32前に受信されている場合がありますので、パケットを受信したか否かは不明であるだけ、ということを意味します受信したパケット。"
    },
    {
      "indent": 3,
      "text": "The received field bits in the ACK provide a high degree of redundancy so that the sender can figure out which packets the receiver has received and can then estimate packet loss rates. If the sender also keeps track of the time at which recent sequence numbers have been sent, the RTT (round-trip time) can be estimated.",
      "ja": "送信者が受信した受信機をパケットと、パケット損失率を推定することができる把握できるように、ACKにおける受信電界ビットは、冗長性の高い程度を提供します。送信者はまた、最近のシーケンス番号が送られてきたした時間を追跡した場合は、RTT（ラウンドトリップ時間）を推定することができます。"
    },
    {
      "indent": 3,
      "text": "Note that because retransmissions receive new sequence numbers, multiple ACKs may be received for the same message. This approach provides more information than traditional TCP sequence numbers, but care must be taken when applying algorithms designed based on TCP's stream-oriented sequence number.",
      "ja": "再送信は、新しいシーケンス番号を受け取るために、複数のACKが同じメッセージのために受信することができることに注意してください。このアプローチは、従来のTCPシーケンス番号よりも多くの情報を提供しますが、TCPのストリーム指向のシーケンス番号に基づいて設計されたアルゴリズムを適用する際には注意が必要です。"
    },
    {
      "indent": 0,
      "text": "6.6.3. Simple Reliability",
      "section_title": true,
      "ja": "6.6.3。シンプルな信頼性"
    },
    {
      "indent": 3,
      "text": "When RELOAD is carried over DTLS or another unreliable link protocol, it needs to be used with a reliability and congestion control mechanism, which is provided on a hop-by-hop basis. The basic principle is that each message, regardless of whether or not it carries a request or response, will get an ACK and be reliably retransmitted. The receiver's job is very simple, and is limited to just sending ACKs. All the complexity is at the sender side. This allows the sending implementation to trade off performance versus implementation complexity without affecting the wire protocol.",
      "ja": "リロードがDTLSまたは別の信頼できないリンクプロトコルを介して搬送されるとき、それはホップバイホップベースで提供される信頼性と輻輳制御機構と共に使用する必要があります。基本的な原理は、各メッセージが、関係なく、それは、要求または応答を運ぶかどうかの、ACKを取得し、確実に再送信されるということです。受信機の仕事は非常に簡単で、単にACKを送信することに限定されています。すべての複雑さは、送信側です。これは、送信の実装は、ワイヤプロトコルに影響を与えることなく、実装の複雑さ対性能のトレードオフすることができます。"
    },
    {
      "indent": 3,
      "text": "Because the receiver's role is limited to providing packet acknowledgements, a wide variety of congestion control algorithms can be implemented on the sender side while using the same basic wire protocol. The sender algorithm used MUST meet the requirements of [RFC5405].",
      "ja": "受信機の役割がパケットの確認応答を提供することに限られているため、同じ基本的なワイヤプロトコルを使用しながら、輻輳制御アルゴリズムの多様な送信側で実現することができます。 [RFC5405]の要件を満たす必要があります使用差出人アルゴリズム。"
    },
    {
      "indent": 0,
      "text": "6.6.3.1. Stop and Wait Sender Algorithm",
      "section_title": true,
      "ja": "6.6.3.1。送信者のアルゴリズムを停止して待って"
    },
    {
      "indent": 3,
      "text": "This section describes one possible implementation of a sender algorithm for Simple Reliability. It is adequate for overlays running on underlying networks with low latency and loss (LANs) or low-traffic overlays on the Internet.",
      "ja": "このセクションでは、簡単な信頼性のために、送信者のアルゴリズムの一つの可能​​な実装について説明します。これは、インターネット上で低遅延と損失（のLAN）または低トラフィックのオーバーレイを持つネットワークの基礎となる上で実行されているオーバーレイには十分です。"
    },
    {
      "indent": 3,
      "text": "A node MUST NOT have more than one unacknowledged message on the DTLS connection at a time. Note that because retransmissions of the same message are given new sequence numbers, there may be multiple unacknowledged sequence numbers in use.",
      "ja": "ノードは、一度にDTLS接続で複数の未確認のメッセージを持ってはいけません。同じメッセージの再送が新しいシーケンス番号が付与されているので、使用中の複数の未確認のシーケンス番号があるかもしれないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The RTO (Retransmission TimeOut) is based on an estimate of the RTT. The value for RTO is calculated separately for each DTLS session. Implementations can use a static value for RTO or a dynamic estimate, which will result in better performance. For implementations that use a static value, the default value for RTO is 500 ms. Nodes MAY use smaller values of RTO if it is known that all nodes are within the local network. The default RTO MAY be set to a larger value, which is RECOMMENDED if it is known in advance (such as on high-latency access links) that the RTT is larger.",
      "ja": "RTO（再送タイムアウト）RTTの推定値に基づいています。 RTOの値は、各DTLSセッションに対して別々に計算されます。実装は、より良い性能をもたらすRTOまたは動的推定のために静的な値を、使用することができます。静的な値を使用して実装するため、RTOのデフォルト値は500ミリ秒です。すべてのノードがローカルネットワーク内にあることが知られている場合、ノードは、RTOの小さい値を使用することができます。デフォルトRTOは、RTTが大きいこと（このような高レイテンシアクセスリンク上など）が予め分かっている場合に推奨されるより大きな値とすることができます。"
    },
    {
      "indent": 3,
      "text": "Implementations that use a dynamic estimate to compute the RTO MUST use the algorithm described in RFC 6298 [RFC6298], with the exception that the value of RTO SHOULD NOT be rounded up to the nearest second, but instead rounded up to the nearest millisecond. The RTT of a successful STUN transaction from the ICE stage is used as the initial measurement for formula 2.2 of RFC 6298. The sender keeps track of the time each message was sent for all recently sent messages. Any time an ACK is received, the sender can compute the RTT for that message by looking at the time the ACK was received and the time when the message was sent. This is used as a subsequent RTT measurement for formula 2.3 of RFC 6298 to update the RTO estimate. (Note that because retransmissions receive new sequence numbers, all received ACKs are used.)",
      "ja": "RTOを計算するために動的推定値を使用する実装はRTOの値は最も近い秒に丸め、その代わりに、最も近いミリ秒単位に切り上げされるべきではないことを除いて、RFC 6298 [RFC6298]に記載されたアルゴリズムを使用しなければなりません。 ICE段階から成功したSTUNトランザクションのRTTは、RFC 6298.の式2.2送信者が各メッセージはすべて、最近送信されたメッセージを送った時間を追跡のための初期測定値として使用されます。 ACKが受信されるときはいつでも、送信側はACKを受信した時刻とメッセージが送信された時点で見ることにより、そのメッセージのRTTを計算することができます。これはRTO推定値を更新するために、RFC 6298の式2.3のための後続のRTT測定値として使用されます。 （再送信は、新しいシーケンス番号を受け取るために、受信したすべてのACKが使用されていることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "An initiating node SHOULD retransmit a message if it has not received an ACK after an interval of RTO (transit nodes do not retransmit at this layer). The node MUST double the time to wait after each retransmission. For each retransmission, the sequence number MUST be incremented.",
      "ja": "それはRTOの間隔（トランジットノードは、この層で再送信していない）の後にACKを受信しなかった場合、開始ノードがメッセージを再送信すべきです。ノードは、各再送信後の待機時間を倍にしなければなりません。各再送信のために、シーケンス番号がインクリメントされなければなりません。"
    },
    {
      "indent": 3,
      "text": "Retransmissions continue until a response is received, until a total of 5 requests have been sent, until there has been a hard ICMP error [RFC1122], or until a TLS alert indicating the end of the connection has been sent or received. The sender knows a response was received when it receives an ACK with a sequence number that indicates it is a response to one of the transmissions of this message. For example, assuming an RTO of 500 ms, requests would be sent at times 0 ms, 500 ms, 1500 ms, 3500 ms, and 7500 ms. If all retransmissions for a message fail, then the sending node SHOULD close the connection routing the message.",
      "ja": "応答が受信されるまで、ハードICMPエラー[RFC1122]があったまで5つの要求の合計は、送信されるまで、または接続の終了を示すTLSアラートが送信または受信されるまで再送信は、継続します。送信者は、それはそれは、このメッセージの送信の1への応答であることを示しているシーケンス番号を持つACKを受信したときに応答が受信された知っています。例えば、500ミリ秒のRTOを仮定すると、要求は時間0ミリ秒、500ミリ秒、1500ミリ秒、3500ミリ秒、7500ミリ秒で送信されることになります。メッセージのすべての再送信が失敗した場合、送信ノードは、メッセージをルーティングする接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "To determine when a link might be failing without waiting for the final timeout, observe when no ACKs have been received for an entire RTO interval, and then wait for three retransmissions to occur beyond that point. If no ACKs have been received by the time the third retransmission occurs, it is RECOMMENDED that the link be removed from the Routing Table. The link MAY be restored to the Routing Table if ACKs resume before the connection is closed, as described above.",
      "ja": "リンクは、最終的なタイムアウトを待たずに失敗する可能性がある場合を判断するには、no ACKが全体のRTO間隔のために受信していないし、そのポイントを超えて発生するために、3つの再送信を待つされていたときに観察します。何らのACKが3回目の再送が発生した時間によって受信されていない場合は、リンクはルーティングテーブルから削除することを推奨されています。接続前のACK再開が閉じている場合、上述のように、リンクは、ルーティングテーブルを復元することができます。"
    },
    {
      "indent": 3,
      "text": "A sender MUST wait 10 ms between receipt of an ACK and transmission of the next message.",
      "ja": "送信側は、ACKを受信すると、次のメッセージの送信の間に10ミリ秒待たなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.6.4. DTLS/UDP with SR",
      "section_title": true,
      "ja": "6.6.4。 SRとDTLS / UDP"
    },
    {
      "indent": 3,
      "text": "This overlay link protocol consists of DTLS over UDP while implementing the SR protocol. STUN connectivity checks and keepalives are used. Any compliant sender algorithm may be used.",
      "ja": "SRプロトコルを実装しながら、このオーバーレイリンクプロトコルはUDP上でDTLSで構成されています。 STUN接続性チェックとキープアライブが使用されています。どれ準拠した送信者のアルゴリズムを使用することができます。"
    },
    {
      "indent": 0,
      "text": "6.6.5. TLS/TCP with FH, No-ICE",
      "section_title": true,
      "ja": "6.6.5。 FH、無ICEとのTLS / TCP"
    },
    {
      "indent": 3,
      "text": "This overlay link protocol consists of TLS over TCP with the framing header. Because ICE is not used, STUN connectivity checks are not used upon establishing the TCP connection, nor are they used for keepalives.",
      "ja": "このオーバーレイ・リンク・プロトコルは、フレーミングヘッダとTCP上TLSから成ります。 ICEが使用されていないので、STUNの接続性チェックは、TCP接続を確立するときに使用されていない、また彼らは、キープアライブのために使用されています。"
    },
    {
      "indent": 3,
      "text": "Because the TCP layer's application-level timeout is too slow to be useful for overlay routing, the Overlay Link implementation MUST use the framing header to measure the RTT of the connection and calculate an RTO as specified in Section 2 of [RFC6298]. The resulting RTO is not used for retransmissions, but rather as a timeout to indicate when the link SHOULD be removed from the Routing Table. It is RECOMMENDED that such a connection be retained for 30 seconds to determine if the failure was transient before concluding the link has failed permanently.",
      "ja": "TCPレイヤのアプリケーションレベルのタイムアウトがオーバーレイルーティングのために有用であるには余りにも遅いため、オーバーレイリンクの実装は、[RFC6298]のセクション2で指定されるように接続のRTTを測定し、RTOを算出するフレーミングヘッダを使用しなければなりません。得られたRTOは再送のためではなく、リンクはルーティングテーブルから除去されるべきであるときを示すためのタイムアウトとして使用されていません。障害がリンクを締結する前に、一過性でかどうかを判断するために30秒間保持され、このような接続は永久に失敗したことが推奨されます。"
    },
    {
      "indent": 3,
      "text": "When sending candidates for TLS/TCP with FH, No-ICE, a passive candidate MUST be provided.",
      "ja": "FH、無ICEとのTLS / TCPの候補を送信する場合、パッシブ候補が提供されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.6.6. DTLS/UDP with SR, No-ICE",
      "section_title": true,
      "ja": "6.6.6。 SRとDTLS / UDP、無ICE"
    },
    {
      "indent": 3,
      "text": "This overlay link protocol consists of DTLS over UDP while implementing the Simple Reliability protocol. Because ICE is not used, no STUN connectivity checks or keepalives are used.",
      "ja": "シンプルな信頼性プロトコルを実装しながら、このオーバーレイリンクプロトコルはUDP上でDTLSで構成されています。 ICEが使用されていないので、何のSTUNの接続性チェックやキープアライブは使用されません。"
    },
    {
      "indent": 0,
      "text": "6.7. Fragmentation and Reassembly",
      "section_title": true,
      "ja": "6.7。フラグメンテーションおよび再構成"
    },
    {
      "indent": 3,
      "text": "In order to allow transmission over datagram protocols such as DTLS, RELOAD messages may be fragmented.",
      "ja": "例えばDTLSとしてデータグラムプロトコル上での伝送を可能にするために、リロードメッセージを断片化することができます。"
    },
    {
      "indent": 3,
      "text": "Any node along the path can fragment the message, but only the final destination reassembles the fragments. When a node takes a packet and fragments it, each fragment has a full copy of the forwarding header, but the data after the forwarding header is broken up into appropriately sized chunks. The size of the payload chunks needs to take into account space to allow the Via and Destination Lists to grow. Each fragment MUST contain a full copy of the Via List, Destination List, and ForwardingOptions and MUST contain at least 256 bytes of the message body. If these elements cannot fit within the MTU of the underlying datagram protocol, RELOAD fragmentation is not performed, and IP-layer fragmentation is allowed to occur. The length field MUST contain the size of the message after fragmentation. When a message MUST be fragmented, it SHOULD be split into equal-sized fragments that are no larger than the Path MTU (PMTU) of the next overlay link minus 32 bytes. This is to allow the Via List to grow before further fragmentation is required.",
      "ja": "経路に沿った任意のノードは、メッセージを断片化することができるが、唯一の最終的な宛先は、断片を再構成します。ノードがパケットおよびフラグメントをとるとき、各フラグメントは、転送ヘッダの完全なコピーを有しているが、転送ヘッダの後のデータは適切なサイズのチャンクに分割されます。ペイロードチャンクのサイズは、ビアと宛先リストが成長できるように、アカウントのスペースを考慮する必要があります。各フラグメントは経由リスト、送信先リスト、およびForwardingOptionsの完全なコピーを含まなければならないし、メッセージ本体の少なくとも256のバイトを含まなければなりません。これらの要素は、基礎となるデータグラムプロトコルのMTUに収まることができない場合は、RELOADの断片化は行われず、IP層の断片化が発生することが許可されています。長さフィールドは、断片化した後、メッセージのサイズを含まなければなりません。メッセージが断片化する必要がある場合、それは次のオーバーレイリンクマイナス32バイトのパスMTU（PMTU）よりも大きくない同じサイズの断片に分割されるべきです。これは、さらに断片化が必要とされる前に、経由リストが成長できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "Note that this fragmentation is not optimal for the end-to-end path -- a message may be refragmented multiple times as it traverses the overlay, but it is assembled only at the final destination. This option has been chosen as it is far easier to implement than end-to-end (e2e) PMTU discovery across an ever-changing overlay and it effectively addresses the reliability issues of relying on IP-layer fragmentation. However, Ping can be used to allow e2e PMTU discovery to be implemented if desired.",
      "ja": "この断片化は、エンドツーエンドのパスのための最適ではないことに注意してください - メッセージは、オーバーレイを横断するように複数回refragmentedてもよいが、それが唯一の最終目的地で組み立てられます。刻々と変化するオーバーレイ全体のエンド・ツー・エンド（E2E）PMTU発見よりも実装がはるかに簡単であるため、このオプションが選択されていて、それが効果的にIP層の断片化に頼るの信頼性の問題に対処しています。ただし、Pingが必要であればE2E PMTU検出を実施することができるようにするために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a fragmented message by the intended peer, the peer holds the fragments in a holding buffer until the entire message has been received. The message is then reassembled into a single message and processed. In order to mitigate denial-of-service (DoS) attacks, receivers SHOULD time out incomplete fragments after the maximum request lifetime (15 seconds). This time was derived from looking at the end-to-end retransmission time and saving fragments long enough for the full end-to-end retransmissions to take place. Ideally, the receiver would have enough buffer space to deal with as many fragments as can arrive in the maximum request lifetime. However, if the receiver runs out of buffer space to reassemble a message, it MUST drop the message.",
      "ja": "メッセージ全体が受信されるまで意図ピアによって断片化されたメッセージを受信すると、ピアは、保持バッファ内の断片を保持します。メッセージが単一のメッセージに再構築され処理されます。サービス拒否（DoS）攻撃を軽減するために、受信機は、最大要求寿命（15秒）の後に、不完全な断片をタイムアウトすべきです。この時間は、エンドツーエンドの再送信時間を見て、完全なエンドツーエンドの再送信が行われるようにするために十分な長さの断片を保存するに由来するものでした。理想的には、受信機は、最大要求寿命に到着できる限り多くの断片に対処するために十分なバッファ領域を持っているでしょう。受信者がメッセージを再構築するために、バッファ領域が不足している場合しかし、それはメッセージを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "The fragment field of the forwarding header is used to encode fragmentation information. The offset is the number of bytes between the end of the forwarding header and the start of the data. The first fragment therefore has an offset of 0. The last fragment indicator MUST be appropriately set. If the message is not fragmented, it is simply treated as if it is the only fragment: the last fragment bit is set and the offset is 0, resulting in a fragment value of 0xC0000000.",
      "ja": "転送ヘッダのフラグメント領域は断片化情報を符号化するために使用されます。オフセットは、転送ヘッダの終わりとデータの開始との間のバイト数です。最初のフラグメントは、したがって最後のフラグメント指標を適切に設定する必要があり、0のオフセットを有します。 0xC0000000の断片値が得られ、0最後のフラグメントビットがセットされ、オフセットである：メッセージが断片化されていない場合、それが唯一のフラグメントであるかのように、単に処理されます。"
    },
    {
      "indent": 3,
      "text": "Note: The reason for this definition of the fragment field is that originally, the high bit was defined in part of the specification as \"is fragmented\", so there was some specification ambiguity about how to encode messages with only one fragment. This ambiguity was resolved in favor of always encoding as the \"last\" fragment with offset 0, thus simplifying the receiver code path, but resulting in the high bit being redundant. Because messages MUST be set with the high bit set to 1, implementations SHOULD discard any message with it set to 0. Implementations (presumably legacy ones) which choose to accept such messages MUST either ignore the remaining bits or ensure that they are 0. They MUST NOT try to interpret as fragmented messages with the high bit set low.",
      "ja": "注：フラグメントフィールドのこの定義理由は本来、高ビットが「断片化されている」と本明細書の一部に定義されているので、一つの断片でメッセージをエンコードする方法のいくつかの仕様の曖昧さが存在したということです。この曖昧さは、このように受信機のコードパスを簡略化するが、高ビットが冗長であることになり、オフセット0で常に「最後」断片としてコードを支持して解決しました。メッセージが1に設定された高ビットで設定しなければならないので、それは残りのビットを無視するか、確保しなければならないのいずれかで、このようなメッセージを受け入れることを選択0実装（おそらく従来のもの）に設定し、実装は、それらが0であることを、任意のメッセージを破棄すべきである彼ら低設定された高ビットと同じように断片化されたメッセージを解釈しようとしてはなりません。"
    },
    {
      "indent": 0,
      "text": "7. Data Storage Protocol",
      "section_title": true,
      "ja": "7.データストレージプロトコル"
    },
    {
      "indent": 3,
      "text": "RELOAD provides a set of generic mechanisms for storing and retrieving data in the Overlay Instance. These mechanisms can be used for new applications simply by defining new code points and a small set of rules. No new protocol mechanisms are required.",
      "ja": "リロードがオーバーレイインスタンスにデータを格納し検索するための一般的な機構のセットを提供します。これらのメカニズムは単に新しいコードポイントとルールの小さなセットを定義することにより、新たな用途に使用することができます。新しいプロトコルメカニズムは必要ありません。"
    },
    {
      "indent": 3,
      "text": "The basic unit of stored data is a single StoredData structure:",
      "ja": "格納されたデータの基本単位は、単一StoredData構造です。"
    },
    {
      "indent": 8,
      "text": "struct {\n  uint32                  length;\n  uint64                  storage_time;\n  uint32                  lifetime;\n  StoredDataValue         value;\n  Signature               signature;\n} StoredData;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of this structure are as follows:",
      "ja": "次のようにこの構造体の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "length The size of the StoredData structure, in bytes, excluding the size of length itself.",
      "ja": "長さ自体のサイズを除くバイト長StoredData構造のサイズ、。"
    },
    {
      "indent": 3,
      "text": "storage_time The time when the data was stored, represented as the number of milliseconds elapsed since midnight Jan 1, 1970 UTC, not counting leap seconds. This will have the same values for seconds as standard UNIX or POSIX time. More information can be found at [UnixTime]. Any attempt to store a data value with a storage time before that of a value already stored at this location MUST generate an Error_Data_Too_Old error. This prevents rollback attacks. The node SHOULD make a best-effort attempt to use a correct clock to determine this number. However, the protocol does not require synchronized clocks: the receiving peer uses the storage time in the previous store, not its own clock. Clock values are used so that when clocks are generally synchronized, data may be stored in a single transaction, rather than querying for the value of a counter before the actual store.",
      "ja": "データが格納されていた時間をstorage_time、うるう秒をカウントしない、深夜1970年1月1日UTCからの経過ミリ秒数として表現。これは、標準のUNIXまたはPOSIX時間秒に同じ値を持つことになります。詳しくは、[UnixTime]で見ることができます。既にこの場所に格納された値の前の蓄積時間でデータ値を格納しようとすると、Error_Data_Too_Oldエラーが発生しなければなりません。これは、ロールバック攻撃を防ぐことができます。ノードは、この番号を決定するために、正しいクロックを使用するためのベストエフォート型試みを行う必要があります。しかし、このプロトコルは同期したクロックを必要としない：受信ピアは、前の店ではなく、自身のクロックで蓄積時間を使用しています。クロックは、一般的に同期している場合、データはなく、実際の店舗の前にカウンタの値をクエリよりも、単一のトランザクション内に格納することができるように、クロックの値が使用されています。"
    },
    {
      "indent": 6,
      "text": "If a node attempting to store new data in response to a user request (rather than as an overlay maintenance operation such as occurs when healing the overlay from a partition) is rejected with an Error_Data_Too_Old error, the node MAY elect to perform its store using a storage_time that increments the value used with the previous store (this may be obtained by doing a Fetch). This situation may occur when the clocks of nodes storing to this location are not properly synchronized.",
      "ja": "（そのようなパーティションからオーバーレイを治癒するときに発生としてではなく、オーバーレイ・メンテナンス操作のような）ユーザ要求に応答して新たなデータを格納しようとするノードがError_Data_Too_Oldエラーで拒否された場合、ノードが使用して、ストアを実行することを選択することができます以前のストア（これはフェッチを行うことによって得ることができる）で使用される値をインクリメントstorage_time。この場所に格納するノードのクロックが適切に同期されていない場合、このような状況が発生することがあります。"
    },
    {
      "indent": 3,
      "text": "lifetime The validity period for the data, in seconds, starting from the time the peer receives the StoreReq.",
      "ja": "寿命データの有効期間は、秒単位で、ピアがStoreReqを受信した時点から始まります。"
    },
    {
      "indent": 3,
      "text": "value The data value itself, as described in Section 7.2.",
      "ja": "セクション7.2で説明したように、データ値自体を重視。"
    },
    {
      "indent": 3,
      "text": "signature A signature, as defined in Section 7.1.",
      "ja": "セクション7.1で定義されるように署名の署名、。"
    },
    {
      "indent": 3,
      "text": "Each Resource-ID specifies a single location in the Overlay Instance. However, each location may contain multiple StoredData values, distinguished by Kind-ID. The definition of a Kind describes both the data values which may be stored and the data model of the data. Some data models allow multiple values to be stored under the same Kind-ID. Section 7.2 describes the available data models. Thus, for instance, a given Resource-ID might contain a single-value element stored under Kind-ID X and an array containing multiple values stored under Kind-ID Y.",
      "ja": "各リソース-IDは、オーバーレイインスタンス内の単一の場所を指定します。しかし、各位置は親切-IDによって識別複数StoredData値を含んでいてもよいです。種類の定義が格納され得るデータ値及びデータのデータ・モデルの両方を記載しています。一部のデータモデルは、複数の値が同じ種類-IDの下で保存することを可能にします。 7.2節では、利用可能なデータモデルについて簡単に説明します。したがって、例えば、特定のリソース-IDは親切-ID Y.下で保存種類-ID X下で保存単一値要素と複数の値を含む配列を含むかもしれません"
    },
    {
      "indent": 0,
      "text": "7.1. Data Signature Computation",
      "section_title": true,
      "ja": "7.1。データ署名の計算"
    },
    {
      "indent": 3,
      "text": "Each StoredData element is individually signed. However, the signature also must be self-contained and must cover the Kind-ID and Resource-ID, even though they are not present in the StoredData structure. The input to the signature algorithm is:",
      "ja": "各StoredData要素を個別に署名されています。ただし、署名はまた、彼らはStoredData構造に存在しないにもかかわらず、自己完結型でなければならず、種類-IDとリソースIDをカバーしなければなりません。署名アルゴリズムに入力されます。"
    },
    {
      "indent": 6,
      "text": "resource_id || kind || storage_time || StoredDataValue || SignerIdentity",
      "ja": "RESOURCE_ID ||種類|| storage_time || StoredDataValue || SignerIdentity"
    },
    {
      "indent": 3,
      "text": "where || indicates concatenation and where these values are:",
      "ja": "どこ||連結を示し、これらの値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "resource_id The Resource-ID where this data is stored.",
      "ja": "このデータが格納されているリソース-IDをRESOURCE_ID。"
    },
    {
      "indent": 3,
      "text": "kind The Kind-ID for this data.",
      "ja": "種類このデータの種類-ID。"
    },
    {
      "indent": 3,
      "text": "storage_time The contents of the storage_time data value.",
      "ja": "storage_timeデータ値の内容をstorage_time。"
    },
    {
      "indent": 3,
      "text": "StoredDataValue The contents of the stored data value, as described in the previous sections.",
      "ja": "前のセクションで説明したように、記憶されたデータ値の内容をStoredDataValue。"
    },
    {
      "indent": 3,
      "text": "SignerIdentity The signer identity, as defined in Section 6.3.4.",
      "ja": "6.3.4項で定義されているようSignerIdentity署名者の身元、。"
    },
    {
      "indent": 3,
      "text": "Once the signature has been computed, the signature is represented using a signature element, as described in Section 6.3.4.",
      "ja": "署名が計算されると、セクション6.3.4に記載したように、署名は、署名要素を用いて表現されます。"
    },
    {
      "indent": 3,
      "text": "Note that there is no necessary relationship between the validity window of a certificate and the expiry of the data it is authenticating. When signatures are verified, the current time MUST be compared to the certificate validity period. Stored data MAY be set to expire after the signing certificate's validity period. Such signatures are not considered valid after the signing certificate expires. Implementations may \"garbage collect\" such data at their convenience, either by purging it automatically (perhaps by setting the upper bound on data storage to the lifetime of the signing certificate) or by simply leaving it in place until it expires naturally and relying on users of that data to notice the expired signing certificate.",
      "ja": "証明書の有効性ウィンドウとそれが認証しているデータの有効期限の間に必要な関係が存在しないことに注意してください。署名が検証される場合、現在時刻が証明書の有効期間と比較されなければなりません。保存されたデータは、署名証明書の有効期間後に失効するように設定することができます。署名証明書の有効期限が切れた後にこのような署名が有効と見なされません。実装は（おそらく署名証明書の有効期間にデータストレージの上限を設定することで）自動的にパージすることによって、あるいは単にそれが自然に切れるまでの場所でそれを残して、ユーザーに頼るのいずれかによって、自分の都合の良いときに、このようなデータを「ごみ収集」も期限切れの署名証明書を気づくためにそのデータの。"
    },
    {
      "indent": 0,
      "text": "7.2. Data Models",
      "section_title": true,
      "ja": "7.2。データモデル"
    },
    {
      "indent": 3,
      "text": "The protocol currently defines the following data models:",
      "ja": "プロトコルは、現在、以下のデータモデルを定義しています。"
    },
    {
      "indent": 3,
      "text": "o single value",
      "ja": "単一の値O"
    },
    {
      "indent": 3,
      "text": "o array",
      "ja": "配列"
    },
    {
      "indent": 3,
      "text": "o dictionary",
      "ja": "O辞書"
    },
    {
      "indent": 3,
      "text": "These are represented with the StoredDataValue structure. The actual data model is known from the Kind being stored.",
      "ja": "これらは、StoredDataValue構造で表現されています。実際のデータモデルが格納されている種類から知られています。"
    },
    {
      "indent": 8,
      "text": "struct {\n  Boolean                exists;\n  opaque                 value<0..2^32-1>;\n} DataValue;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  select (DataModel) {\n    case single_value:\n      DataValue             single_value_entry;",
      "raw": true
    },
    {
      "indent": 12,
      "text": "case array:\n  ArrayEntry            array_entry;",
      "raw": true
    },
    {
      "indent": 12,
      "text": "case dictionary: DictionaryEntry dictionary_entry;",
      "ja": "ケース辞書：DictionaryEntryのdictionary_entry。"
    },
    {
      "indent": 8,
      "text": "    /* This structure may be extended */\n  };\n} StoredDataValue;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following sections discuss the properties of each data model.",
      "ja": "次のセクションでは、各データモデルの性質を議論します。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Single Value",
      "section_title": true,
      "ja": "7.2.1。単一値"
    },
    {
      "indent": 3,
      "text": "A single-value element is a simple sequence of bytes. There may be only one single-value element for each Resource-ID, Kind-ID pair.",
      "ja": "単一値要素には、バイトの単純な配列です。各リソース-ID、種類-IDのペアのためにただ1つの値の要素があってもよいです。"
    },
    {
      "indent": 3,
      "text": "A single value element is represented as a DataValue, which contains the following two elements:",
      "ja": "単一値の要素は、次の2つの要素を含むDataValueは、のように表されます。"
    },
    {
      "indent": 3,
      "text": "exists This value indicates whether the value exists at all. If it is set to False, it means that no value is present. If it is True, this means that a value is present. This gives the protocol a mechanism for indicating nonexistence as opposed to emptiness.",
      "ja": "この値は、値がまったく存在するかどうかを示す存在します。それがFalseに設定されている場合は、値が存在しないことを意味します。それがTrueの場合、この値が存在することを意味します。これは、プロトコルを空虚とは対照的に存在しないことを示すための機構を与えます。"
    },
    {
      "indent": 3,
      "text": "value The stored data.",
      "ja": "格納されたデータを評価。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Array",
      "section_title": true,
      "ja": "7.2.2。アレイ"
    },
    {
      "indent": 3,
      "text": "An array is a set of opaque values addressed by an integer index. Arrays are zero based. Note that arrays can be sparse. For instance, a Store of \"X\" at index 2 in an empty array produces an array with the values [ NA, NA, \"X\"]. Future attempts to fetch elements at index 0 or 1 will return values with \"exists\" set to False.",
      "ja": "アレイは、整数インデックスによってアドレス指定不透明値のセットです。配列はゼロベースです。配列はスパースできることに注意してください。例えば、空の配列のインデックス2に「X」のストア値[NA、NA、「X」]の配列を生成します。インデックス0または1で要素をフェッチする将来の試みがFalseに設定された「存在する」との値を返します。"
    },
    {
      "indent": 3,
      "text": "An array element is represented as an ArrayEntry:",
      "ja": "アレイ素子はArrayEntryとして表されます。"
    },
    {
      "indent": 9,
      "text": "struct {\n  uint32                  index;\n  DataValue               value;\n} ArrayEntry;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of this structure are:",
      "ja": "この構造体の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "index The index of the data element in the array.",
      "ja": "索引配列内のデータ要素のインデックス。"
    },
    {
      "indent": 3,
      "text": "value The stored data.",
      "ja": "格納されたデータを評価。"
    },
    {
      "indent": 0,
      "text": "7.2.3. Dictionary",
      "section_title": true,
      "ja": "7.2.3。辞書"
    },
    {
      "indent": 3,
      "text": "A dictionary is a set of opaque values indexed by an opaque key, with one value for each key. A single dictionary entry is represented as a DictionaryEntry:",
      "ja": "辞書は、各キーに対して1つの値と、不透明な鍵によってインデックスさ不透明値のセットです。単一の辞書エントリはDictionaryEntryのように表されます。"
    },
    {
      "indent": 9,
      "text": "typedef opaque DictionaryKey<0..2^16-1>;",
      "ja": "不透明DictionaryKey <0..2 ^ 16-1>のtypedef。"
    },
    {
      "indent": 9,
      "text": "struct {\n  DictionaryKey          key;\n  DataValue              value;\n} DictionaryEntry;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of this structure are:",
      "ja": "この構造体の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "key The dictionary key for this value.",
      "ja": "この値の辞書キーをキーを押します。"
    },
    {
      "indent": 3,
      "text": "value The stored data.",
      "ja": "格納されたデータを評価。"
    },
    {
      "indent": 0,
      "text": "7.3. Access Control Policies",
      "section_title": true,
      "ja": "7.3。アクセス制御ポリシー"
    },
    {
      "indent": 3,
      "text": "Every Kind which is storable in an overlay MUST be associated with an access control policy. This policy defines whether a request from a given node to operate on a given value should succeed or fail. It is anticipated that only a small number of generic access control policies are required. To that end, this section describes a small set of such policies, and Section 14.4 establishes a registry for new policies, if required. Each policy has a short string identifier which is used to reference it in the Configuration Document.",
      "ja": "オーバーレイに保存可能であるあらゆる種類は、アクセス制御ポリシーに関連付ける必要があります。このポリシーは、指定された値で動作する所与のノードからの要求が成功するか失敗するかどうかを定義します。一般的なアクセス制御ポリシーのほんの数が必要であることが予想されます。そのために、このセクションでは、このような政策の小さなセットを説明し、必要に応じてセクション14.4には、新しいポリシーのレジストリを確立します。各ポリシーは、設定文書で参照するために使用される短い文字列の識別子を有します。"
    },
    {
      "indent": 3,
      "text": "In the following policies, the term \"signer\" refers to the signer of the StoredValue object and, in the case of non-replica stores, to the signer of the StoreReq message. That is, in a non-replica store, both the signer of the StoredValue and the signer of the StoreReq MUST conform to the policy. In the case of a replica store, the signer of the StoredValue MUST conform to the policy, and the StoreReq itself MUST be checked as described in Section 7.4.1.1.",
      "ja": "次のポリシーでは、用語「署名者」はStoredValueオブジェクトの署名者に及び、非レプリカ店舗の場合には、StoreReqメッセージの署名者を指します。すなわち、非レプリカ店においては、両方StoredValueの署名者とStoreReqの署名者は、ポリシーに準拠しなければなりません。レプリカ・ストアの場合には、StoredValueの署名者は、ポリシーに準拠しなければならない、そして、セクション7.4.1.1に記載されるようにStoreReq自身がチェックしなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.3.1. USER-MATCH",
      "section_title": true,
      "ja": "7.3.1。 USER-MATCH"
    },
    {
      "indent": 3,
      "text": "In the USER-MATCH policy, a given value MUST be written (or overwritten) if and only if the signer's certificate has a user name which hashes (using the hash function for the overlay) to the Resource-ID for the resource. Recall that the certificate may, depending on the overlay configuration, be self-signed.",
      "ja": "USER-MATCHポリシーで、指定された値が書き込まれた（または上書き）しなければならない場合と署名者の証明書は、リソースのリソース-IDに（オーバーレイのハッシュ関数を使用して）ハッシュユーザー名を持っている場合のみ。証明書は、オーバーレイの構成に応じて、自己署名することができることを想起されたいです。"
    },
    {
      "indent": 0,
      "text": "7.3.2. NODE-MATCH",
      "section_title": true,
      "ja": "7.3.2。 NODE-MATCH"
    },
    {
      "indent": 3,
      "text": "In the NODE-MATCH policy, a given value MUST be written (or overwritten) if and only if the signer's certificate has a specified Node-ID which hashes (using the hash function for the overlay) to the Resource-ID for the resource and that Node-ID is the one indicated in the SignerIdentity value cert_hash.",
      "ja": "NODE-MATCHポリシーで、所定の値（または上書き）が書き込まなければならない場合と署名者の証明書は、リソースのリソース-IDに（オーバーレイのためのハッシュ関数を用いて）ハッシュ指定されたノード-IDを有する場合にのみ、及びそのノードIDはSignerIdentity値cert_hashに示されるものです。"
    },
    {
      "indent": 0,
      "text": "7.3.3. USER-NODE-MATCH",
      "section_title": true,
      "ja": "7.3.3。 USER-NODE-MATCH"
    },
    {
      "indent": 3,
      "text": "The USER-NODE-MATCH policy may be used only with dictionary types. In the USER-NODE-MATCH policy, a given value MUST be written (or overwritten) if and only if the signer's certificate has a user name which hashes (using the hash function for the overlay) to the Resource-ID for the resource. In addition, the dictionary key MUST be equal to the Node-ID in the certificate, and that Node-ID MUST be the one indicated in the SignerIdentity value cert_hash.",
      "ja": "USER-NODE-MATCH政策は、辞書型で使用することができます。 USER-NODE-MATCHポリシーで、指定された値が書き込まれた（または上書き）しなければならない場合と署名者の証明書は、リソースのリソース-IDに（オーバーレイのハッシュ関数を使用して）ハッシュユーザー名を持っている場合のみ。また、辞書のキーは、証明書内のノードIDに等しくなければならず、そのノードIDはSignerIdentity値cert_hashに示されているものでなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.3.4. NODE-MULTIPLE",
      "section_title": true,
      "ja": "7.3.4。 NODE-MULTIPLE"
    },
    {
      "indent": 3,
      "text": "In the NODE-MULTIPLE policy, a given value MUST be written (or overwritten) if and only if the signer's certificate contains a Node-ID such that H(Node-ID || i) is equal to the Resource-ID for some small integer value of i and that Node-ID is the one indicated in the SignerIdentity value cert_hash. When this policy is in use, the maximum value of i MUST be specified in the Kind definition.",
      "ja": "NODE-複数のポリシーでは、指定された値が書き込まれた（または上書き）しなければならない場合と署名者の証明書が含まれている場合にのみ、ノードID Hは（ノードID || i）は、いくつかの小規模のリソース-IDに等しくなるようにiとそのノードIDの整数値はSignerIdentity値cert_hashに示されるものです。このポリシーを使用している場合は、私の最大値は、種類の定義で指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that because i is not carried on the wire, the verifier MUST iterate through potential i values, up to the maximum value, to determine whether a store is acceptable.",
      "ja": "iは、ワイヤ上に担持されていないため、検証者は、潜在的なi値を反復しなければならないことに注意し、最大値まで、ストアが許容可能であるかどうかを決定します。"
    },
    {
      "indent": 0,
      "text": "7.4. Data Storage Methods",
      "section_title": true,
      "ja": "7.4。データストレージメソッド"
    },
    {
      "indent": 3,
      "text": "RELOAD provides several methods for storing and retrieving data:",
      "ja": "RELOADは、データを格納および取得するためのいくつかのメソッドを提供します。"
    },
    {
      "indent": 3,
      "text": "o Store values in the overlay.",
      "ja": "オーバーレイ中のOストアの値。"
    },
    {
      "indent": 3,
      "text": "o Fetch values from the overlay.",
      "ja": "Oオーバーレイから値を取得します。"
    },
    {
      "indent": 3,
      "text": "o Stat: Get metadata about values in the overlay.",
      "ja": "O統計：オーバーレイの値についてのメタデータを取得します。"
    },
    {
      "indent": 3,
      "text": "o Find the values stored at an individual peer.",
      "ja": "O個々のピアに格納された値を検索します。"
    },
    {
      "indent": 3,
      "text": "These methods are described in the following sections.",
      "ja": "これらのメソッドは、次のセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "7.4.1. Store",
      "section_title": true,
      "ja": "7.4.1。格納"
    },
    {
      "indent": 3,
      "text": "The Store method is used to store data in the overlay. The format of the Store request depends on the data model, which is determined by the Kind.",
      "ja": "店舗方法は、オーバーレイ内のデータを格納するために使用されます。ストア要求のフォーマットは種類によって決定されたデータモデルに依存します。"
    },
    {
      "indent": 0,
      "text": "7.4.1.1. Request Definition",
      "section_title": true,
      "ja": "7.4.1.1。要求定義"
    },
    {
      "indent": 3,
      "text": "A StoreReq message is a sequence of StoreKindData values, each of which represents a sequence of stored values for a given Kind. The same Kind-ID MUST NOT be used twice in a given store request. Each value is then processed in turn. These operations MUST be atomic. If any operation fails, the state MUST be rolled back to what it was before the request was received.",
      "ja": "StoreReqメッセージは、特定の種類のために格納された値のシーケンスを表すそれぞれがStoreKindData値のシーケンスです。同じ種類-IDは、与えられたストアリクエストで二回使用してはいけません。各値は、順番に処理されます。これらの操作はアトミックでなければなりません。すべての操作が失敗した場合、状態は要求が受信される前にそれが何だったかにロールバックする必要があります。"
    },
    {
      "indent": 3,
      "text": "The store request is defined by the StoreReq structure:",
      "ja": "ストア要求はStoreReq構造によって定義されます。"
    },
    {
      "indent": 7,
      "text": "struct {\n    KindId                 kind;\n    uint64                 generation_counter;\n    StoredData             values<0..2^32-1>;\n} StoreKindData;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "struct {\n    ResourceId             resource;\n    uint8                  replica_number;\n    StoreKindData          kind_data<0..2^32-1>;\n} StoreReq;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A single Store request stores data of a number of Kinds to a single resource location. The contents of the structure are:",
      "ja": "単一のリソース・ロケーションへ種類数の単一のストアリクエストデータを格納します。構造体の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "resource The resource at which to store.",
      "ja": "保存するのリソースをリソース。"
    },
    {
      "indent": 3,
      "text": "replica_number The number of this replica. When a storing peer saves replicas to other peers, each peer is assigned a replica number, starting from 1, that is sent in the Store message. This field is set to 0 when a node is storing its own data. This allows peers to distinguish replica writes from original writes. Different topologies may choose to allocate or interpret the replica number differently (see Section 10.4).",
      "ja": "このレプリカの数をreplica_number。格納ピアが他のピアへのレプリカを保存すると、各ピアは、それがストアメッセージで送信され、1から出発して、レプリカ番号が割り当てられます。ノードは、自身のデータを記憶している場合、このフィールドは0に設定されています。これは、ピアがレプリカがオリジナルの書き込みから書き込みを区別することができます。異なるトポロジー（項10.4を参照）、異なるレプリカ番号を割り当てるか、解釈することもできます。"
    },
    {
      "indent": 3,
      "text": "kind_data A series of elements, one for each Kind of data to be stored.",
      "ja": "kind_data要素の系列は、データの種類毎に一つが格納されます。"
    },
    {
      "indent": 3,
      "text": "The peer MUST check that it is responsible for the resource if the replica number is zero; if it is not, the peer must reject the request. The peer MUST check that it expects to be a replica for the resource and that the request sender is consistent with being the responsible node (i.e., that the receiving peer does not know of a better node) if the replica number is nonzero; if the request sender is not consistent, it should reject the request.",
      "ja": "ピアは、レプリカの数がゼロであれば、それは資源のために責任があることをチェックしなければなりません。そうでない場合、ピアは要求を拒否しなければなりません。ピアは、それがリソースの要求の送信者が担当ノードであると一貫していることをレプリカであると想定していることを確認しなければならない（即ち、受信ピアは、より良いノードを知っていないこと）レプリカ数がゼロであれば、リクエストの送信者が一貫していない場合、それは要求を拒否しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each StoreKindData element represents the data to be stored for a single Kind-ID. The contents of the element are:",
      "ja": "各StoreKindData要素は、単一種類-IDのために格納されるデータを表します。要素の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "kind The Kind-ID. Implementations MUST reject requests corresponding to unknown Kinds.",
      "ja": "種類種類-ID。実装は、未知の種類に対応する要求を拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "generation_counter The expected current state of the generation counter (approximately the number of times that this object has been written; see below for details).",
      "ja": "生成カウンタの予想される現在の状態generation_counter（このオブジェクトが書き込まれたこと回数の約数と、詳細については以下を参照されたいです）。"
    },
    {
      "indent": 3,
      "text": "values The value or values to be stored. This may contain one or more stored_data values, depending on the data model associated with each Kind.",
      "ja": "値または値の値が格納されます。これは、各種類に関連付けられたデータ・モデルに応じて、1つ以上のstored_data値を含んでいてもよいです。"
    },
    {
      "indent": 3,
      "text": "The peer MUST perform the following checks:",
      "ja": "ピアは、以下のチェックを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The Kind-ID is known and supported.",
      "ja": "O種類-IDが知られており、サポートされています。"
    },
    {
      "indent": 3,
      "text": "o The signatures over each individual data element, if any, are valid. If this check fails, the request MUST be rejected with an Error_Forbidden error.",
      "ja": "各個々のデータ要素上の署名O、もしあれば、有効です。このチェックが失敗した場合、要求はError_Forbiddenエラーで拒否されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Each element is signed by a credential which is authorized to write this Kind at this Resource-ID. If this check fails, the request MUST be rejected with an Error_Forbidden error.",
      "ja": "Oの各要素は、このリソース-IDにこの種の書き込みを許可されている資格情報によって署名されています。このチェックが失敗した場合、要求はError_Forbiddenエラーで拒否されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o For original (non-replica) stores, the StoreReq is signed by a credential which is authorized to write this Kind at this Resource-ID. If this check fails, the request MUST be rejected with an Error_Forbidden error.",
      "ja": "O元の（非レプリカ）を格納するために、StoreReqこのリソース-IDにこの種の書き込みを許可されている資格情報によって署名されています。このチェックが失敗した場合、要求はError_Forbiddenエラーで拒否されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o For replica stores, the StoreReq is signed by a Node-ID which is a plausible node to either have originally stored the value or have been in the replica set. What this means is overlay specific, but in the case of the Chord-based DHT defined in this specification, replica StoreReqs MUST come from nodes which are either in the known replica set for a given resource or which are closer than some node in the replica set. If this check fails, the request MUST be rejected with an Error_Forbidden error.",
      "ja": "Oレプリカを格納するため、StoreReqは、いずれかの妥当ノードが本来の値を記憶されているか、レプリカセットにされているあるノードIDによって署名されています。これが意味することは、特定のオーバーレイであるが、本明細書で定義されているコードベースのDHTの場合には、レプリカStoreReqsは、与えられたリソースまたはそのレプリカにいくつかのノードよりも近くにあるために知られている複製セットのいずれかのノードから来なければなりませんセットする。このチェックが失敗した場合、要求はError_Forbiddenエラーで拒否されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o For original (non-replica) stores, the peer MUST check that if the generation counter is nonzero, it equals the current value of the generation counter for this Kind. This feature allows the generation counter to be used in a way similar to the HTTP ETag feature.",
      "ja": "O元の（非レプリカ）を格納するために、ピアは、世代カウンタがゼロ以外の場合、それはこの種の生成カウンタの現在の値に等しいことをチェックしなければなりません。この機能は、生成カウンタは、HTTPのETag機能と同様に使用することが可能になります。"
    },
    {
      "indent": 3,
      "text": "o For replica Stores, the peer MUST set the generation counter to match the generation counter in the message and MUST NOT check the generation counter against the current value. Replica Stores MUST NOT use a generation counter of 0.",
      "ja": "レプリカストアのO、ピアがメッセージに生成カウンタに一致するように世代カウンタを設定しなければならないと現在の値に対して生成カウンタをチェックしてはいけません。レプリカの店舗は0の世代カウンタを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "o The storage time values are greater than that of any values which would be replaced by this Store.",
      "ja": "ストレージoを時間の値は、このお店によって置換される任意の値よりも大きいです。"
    },
    {
      "indent": 3,
      "text": "o The size and number of the stored values are consistent with the limits specified in the overlay configuration.",
      "ja": "格納された値の大きさと数oをオーバーレイ設定で指定された範囲と一致しています。"
    },
    {
      "indent": 3,
      "text": "o If the data is signed with identity_type set to \"none\" and/or SignatureAndHashAlgorithm values set to {0, 0} (\"anonymous\" and \"none\"), the StoreReq MUST be rejected with an Error_forbidden error. Only synthesized data returned by the storage can use these values (see Section 7.4.2.2)",
      "ja": "データが「なし」及び/又は{0,0}（「匿名」と「なし」）に設定SignatureAndHashAlgorithm値に設定identity_typeで署名されている場合は、O、StoreReqはError_forbiddenエラーで拒否されなければなりません。ストレージによって返さのみ合成されたデータは、これらの値を使用することができます（7.4.2.2項を参照してください）"
    },
    {
      "indent": 3,
      "text": "If all these checks succeed, the peer MUST attempt to store the data values. For non-replica stores, if the store succeeds and the data is changed, then the peer MUST increase the generation counter by at least 1. If there are multiple stored values in a single StoreKindData, it is permissible for the peer to increase the generation counter by only 1 for the entire Kind-ID or by 1 or more than 1 for each value. Accordingly, all stored data values MUST have a generation counter of 1 or greater. 0 is used in the Store request to indicate that the generation counter should be ignored for processing this request. However, the responsible peer should increase the stored generation counter and should return the correct generation counter in the response.",
      "ja": "これらすべてのチェックが成功した場合、ピアは、データ値を格納しようとしなければなりません。ストアが成功し、データが変更された場合、単一StoreKindDataに複数記憶された値がある場合、ピアは、少なくとも1で生成カウンタを増やす必要があり、ピアが生成を増加させるための非レプリカ格納するため、それは許容されます唯一1全体種類-IDまたは1もしくは各値に対して1以上によって、カウンタ。したがって、すべての記憶されたデータ値は、1以上の世代カウンタを持たなければなりません。 0が生成カウンタは、この要求を処理するために無視されるべきであることを示すためにストア要求で使用されています。しかし、責任あるピアが保​​存された世代カウンタを増やす必要があり、それに応じて正しい生成カウンタを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "When a peer stores data previously stored by another node (e.g., for replicas or topology shifts), it MUST adjust the lifetime value downward to reflect the amount of time the value was stored at the peer. The adjustment SHOULD be implemented by an algorithm equivalent to the following: at the time the peer initially receives the StoreReq, it notes the local time T. When it then attempts to do a StoreReq to another node, it should decrement the lifetime value by the difference between the current local time and T.",
      "ja": "ピア格納データが以前に別のノードにより格納された場合（例えば、複製またはトポロジシフトのために）、その値は、ピアで保存した時間の量を反映するように下方にライフタイム値を調整する必要があります。調整は次のようなアルゴリズムと同等によって実施されるべきである：ピアは、最初StoreReqを受信する時、それは、別のノードにStoreReqを実行しようとローカル時間Tノート、それはによって寿命値をデクリメントする必要があり現在のローカル時間とT.との違い"
    },
    {
      "indent": 3,
      "text": "Unless otherwise specified by the usage, if a peer attempts to store data previously stored by another node (e.g., for replicas or topology shifts) and that store fails with either an Error_Generation_Counter_Too_Low or an Error_Data_Too_Old error, the peer MUST fetch the newer data from the peer generating the error and use that to replace its own copy. This rule allows resynchronization after partitions heal.",
      "ja": "ピアが以前に（複製またはトポロジシフト用など、）別のノードにより格納されたデータを格納しようとし、そのストアがError_Generation_Counter_Too_Low又はError_Data_Too_Oldエラーのいずれかで失敗し、ピアから新しいデータを取得する必要がある場合はそうでなければ、使用することによって指定されない限りエラーを生成するピアと、自身のコピーを置き換えるためにそれを使用。この規則は、パーティションが治癒した後に再同期することができます。"
    },
    {
      "indent": 3,
      "text": "When a network partition is being healed and unless otherwise specified, the default merging rule is to act as if all the values that need to be merged were stored and as if the order they were stored in corresponds to the stored time values associated with (and carried in) their values. Because the stored time values are those associated with the peer which did the writing, clock skew is generally not an issue. If two nodes are on different partitions, write to the same location, and have clock skew, this can create merge conflicts. However, because RELOAD deliberately segregates storage so that data from different users and peers is stored in different locations, and a single peer will typically only be in a single network partition, this case will generally not arise.",
      "ja": "ネットワークパーティションが癒されていると、特に指定のない限り、デフォルトのマージルールがマージされる必要があるすべての値が格納されているかのように、オーダーは、それらが関連付けられて保存された時間値に対応して格納されているかのよう行動するときに（とそれらの値）で実施しました。保存された時間値は、書き込みをしたピアに関連するものであるため、クロック・スキューは、一般的に問題ではありません。 2つのノードが異なるパーティション上にある場合は、同じ場所に書き込み、およびクロック・スキューを持っている、これは、マージの競合を作成することができます。リロードが意図的にストレージを分離するため、異なるユーザとピアからのデータは、異なる場所に格納され、単一のピアは、典型的には、単一のネットワーク・パーティションになるようしかし、この場合は、一般的に発生しないであろう。"
    },
    {
      "indent": 3,
      "text": "The properties of stores for each data model are as follows:",
      "ja": "次のように各データ・モデルの格納の特性は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "single-value: A store of a new single-value element creates the element if it does not exist and overwrites any existing value with the new value.",
      "ja": "単一値：新しい単一値要素のストアが存在しない場合、要素を作成し、新しい値で既存の値を上書きします。"
    },
    {
      "indent": 3,
      "text": "array: A store of an array entry replaces (or inserts) the given value at the location specified by the index. Because arrays are sparse, a store past the end of the array extends it with nonexistent values (exists = False) as required. A store at index 0xffffffff places the new value at the end of the array, regardless of the length of the array. The resulting StoredData has the correct index value when it is subsequently fetched.",
      "ja": "アレイ：アレイエントリのストアは、インデックスにより指定された位置に指定された値を置換（または挿入）。アレイが疎であるため、必要に応じて、アレイの端過去ストアが存在しない値（偽=存在）でそれを拡張します。インデックスは0xFFFFFFFFでストアにかかわらず、配列の長さの、アレイの末尾に新たな値を置きます。それは続いてフェッチされるときに得StoredData正しいインデックス値を有しています。"
    },
    {
      "indent": 3,
      "text": "dictionary: A store of a dictionary entry replaces (or inserts) the given value at the location specified by the dictionary key.",
      "ja": "辞書：辞書エントリのストアは、辞書キーで指定された位置に指定された値を置換（または挿入）。"
    },
    {
      "indent": 3,
      "text": "The following figure shows the relationship between these structures for an example store which stores the following values at resource \"1234\":",
      "ja": "次の図は、リソース「1234」で、以下の値を記憶する例えば記憶装置のためのこれらの構造との関係を示しています。"
    },
    {
      "indent": 3,
      "text": "o The value \"abc\" is in the single-value location for Kind X.",
      "ja": "O値「ABC」が種類Xの単一の値の場所にあります"
    },
    {
      "indent": 3,
      "text": "o The value \"foo\" at index 0 is in the array for Kind Y.",
      "ja": "Oインデックス0の値「fooが」種類Y.の配列であります"
    },
    {
      "indent": 3,
      "text": "o The value \"bar\" at index 1 is in the array for Kind Y.",
      "ja": "Oインデックス1の値「バー」が種類Y.の配列であります"
    },
    {
      "indent": 13,
      "text": "                        Store\n                   resource=1234\n                 replica_number = 0\n                      /      \\\n                     /        \\\n         StoreKindData        StoreKindData\n     kind=X (Single-Value)    kind=Y (Array)\n   generation_counter = 99    generation_counter = 107\n              |                    /\\\n              |                   /  \\\n          StoredData             /    \\\nstorage_time = xxxxxxx          /      \\\n      lifetime = 86400         /        \\\n      signature = XXXX        /          \\\n              |               |           |\n              |        StoredData       StoredData\n              |    storage_time =       storage_time =\n              |          yyyyyyyy       zzzzzzz\n              |  lifetime = 86400       lifetime = 33200\n              |  signature = YYYY       signature = ZZZZ\n              |               |           |\n       StoredDataValue        |           |\n        value=\"abc\"           |           |\n                              |           |\n                     StoredDataValue  StoredDataValue\n                           index=0      index=1\n                        value=\"foo\"    value=\"bar\"",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.4.1.2. Response Definition",
      "section_title": true,
      "ja": "7.4.1.2。レスポンスの定義"
    },
    {
      "indent": 3,
      "text": "In response to a successful Store request, the peer MUST return a StoreAns message containing a series of StoreKindResponse elements, which contains the current value of the generation counter for each Kind-ID, as well as a list of the peers where the data will be replicated by the node processing the request.",
      "ja": "成功したストア要求に応答して、ピアは各種類-IDの生成カウンタの現在の値を含むStoreKindResponseエレメントのシリーズを含むStoreAnsメッセージ、並びにデータがされるピアのリストを返さなければなりません要求を処理ノードによって複製しました。"
    },
    {
      "indent": 8,
      "text": "struct {\n  KindId                  kind;\n  uint64                  generation_counter;\n  NodeId                  replicas<0..2^16-1>;\n} StoreKindResponse;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  StoreKindResponse       kind_responses<0..2^16-1>;\n} StoreAns;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of each StoreKindResponse are:",
      "ja": "各StoreKindResponseの内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "kind The Kind-ID being represented.",
      "ja": "種類種類-IDが表されています。"
    },
    {
      "indent": 3,
      "text": "generation_counter The current value of the generation counter for that Kind-ID.",
      "ja": "この種-IDの生成カウンタの現在の値をgeneration_counter。"
    },
    {
      "indent": 3,
      "text": "replicas The list of other peers at which the data was/will be replicated. In overlays and applications where the responsible peer is intended to store redundant copies, this allows the storing node to independently verify that the replicas have in fact been stored. It does this verification by using the Stat method (see Section 7.4.3). Note that the storing node is not required to perform this verification.",
      "ja": "データは/複製されたときの他のピアのリストをレプリカ。オーバーレイ責任ピアが冗長コピーを格納することが意図されているアプリケーションでは、これは記憶ノードは、独立してレプリカが実際に格納されていることを確認することを可能にします。これは、統計法を用いて、この検証を行います（セクション7.4.3を参照してください）。保存するノードは、この検証を実行するために必要とされていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The response itself is just StoreKindResponse values packed end to end.",
      "ja": "応答自体は、エンドツーエンドを詰めだけStoreKindResponse値です。"
    },
    {
      "indent": 3,
      "text": "If any of the generation counters in the request precede the corresponding stored generation counter, then the peer MUST fail the entire request and respond with an Error_Generation_Counter_Too_Low error. The error_info in the ErrorResponse MUST be a StoreAns response containing the correct generation counter for each Kind and the replica list, which will be empty. For original (non-replica) stores, a node which receives such an error SHOULD attempt to fetch the data and, if the storage_time value is newer, replace its own data with that newer data. This rule improves data consistency in the case of partitions and merges.",
      "ja": "要求で生成カウンターのいずれかが、対応する記憶された世代カウンタの前にいる場合、ピアは、要求全体が失敗しError_Generation_Counter_Too_Lowエラーで応答しなければなりません。 ErrorResponseにERROR_INFOは空になり、各種類の正しい世代カウンタとレプリカリストを含むStoreAns応答でなければなりません。元の（非レプリカ）を格納するために、そのようなエラーを受信したノードはstorage_time値の方が新しい場合は、その新しいデータに独自のデータを交換し、データをフェッチしようとすべきです。この規則は、パーティションとマージした場合のデータの一貫性を向上させます。"
    },
    {
      "indent": 3,
      "text": "If the data being stored is too large for the allowed limit by the given usage, then the peer MUST fail the request and generate an Error_Data_Too_Large error.",
      "ja": "格納されたデータは、所与の使用によって許容される限界のために大きすぎる場合には、ピアは、要求を失敗とError_Data_Too_Largeエラーが発生しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If any type of request tries to access a data Kind that the peer does not know about, the peer MUST fail the request and generate an Error_Unknown_Kind error. The error_info in the Error_Response is:",
      "ja": "要求のいずれかのタイプは、ピアが認識できないデータの種類にアクセスしようとすると、ピアは、要求を失敗し、Error_Unknown_Kindエラーを発生させなければなりません。 Error_ResponseでERROR_INFOは以下のとおりです。"
    },
    {
      "indent": 14,
      "text": "KindId unknown_kinds<0..2^8-1>;",
      "ja": "KindId unknown_kinds <0..2 ^ 8-1>。"
    },
    {
      "indent": 3,
      "text": "which lists all the Kinds that were unrecognized. A node which receives this error MUST generate a ConfigUpdate message which contains the appropriate Kind definition (assuming which, in fact, a Kind which was defined in the configuration document was used).",
      "ja": "これは、未認識だったすべての種類を示しています。このエラーを受信したノードは、（実際には、構成ドキュメントに定義された種類を使用した、と仮定して）適切な種類の定義が含まれているあるConfigUpdateメッセージを生成しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.4.1.3. Removing Values",
      "section_title": true,
      "ja": "7.4.1.3。値を削除します"
    },
    {
      "indent": 3,
      "text": "RELOAD does not have an explicit Remove operation. Rather, values are Removed by storing \"nonexistent\" values in their place. Each DataValue contains a boolean value called \"exists\" which indicates whether a value is present at that location. In order to effectively remove a value, the owner stores a new DataValue with \"exists\" set to False:",
      "ja": "RELOADは、明示的な削除操作を持っていません。むしろ、値がその場所に「存在しない」値を格納することによって除去されます。各DataValueは値がその位置に存在するか否かを示す「存在」と呼ばれるブール値を含みます。効果的に値を除去するために、所有者がFalseに設定された「存在」で新しいDataValueはを格納します。"
    },
    {
      "indent": 6,
      "text": "exists = False",
      "ja": "= Falseの存在"
    },
    {
      "indent": 6,
      "text": "value = {} (0 length)",
      "ja": "値= {}（0長さ）"
    },
    {
      "indent": 3,
      "text": "The owner SHOULD use a lifetime for the nonexistent value that is at least as long as the remainder of the lifetime of the value it is replacing. Otherwise, it is possible for the original value to be accidentally or maliciously re-stored after the storing node has expired it. Note that a window of vulnerability for replay attack still exists after the original lifetime has expired (as with any store). This attack can be mitigated by doing a nonexistent store with a very long lifetime.",
      "ja": "所有者は、それが置換されている値の寿命の残りの部分と少なくとも同じ長さで存在しない値の有効期間を使用すべきです。それ以外の場合は、記憶ノードは、それが満了した後に元の値が誤って又は故意に再格納することが可能です。オリジナルの寿命は、（任意の店舗と同じように）有効期限が切れた後にリプレイ攻撃の脆弱性のウィンドウがまだ存在することに注意してください。この攻撃は、非常に長い寿命と、存在しない店舗を行うことによって緩和することができます。"
    },
    {
      "indent": 3,
      "text": "Storing nodes MUST treat these nonexistent values the same way they treat any other stored value, including overwriting the existing value, replicating them, and aging them out as necessary when the lifetime expires. When a stored nonexistent value's lifetime expires, it is simply removed from the storing node, as happens when any other stored value expires.",
      "ja": "保存ノードは、これらの存在しない値に彼らは、既存の値を上書きし、それらを複製し、寿命が満了したときに、必要に応じてそれらを老化含む他の格納された値を、治療と同じように扱わなければなりません。格納され、存在しない値の寿命が満了すると、他の記憶された値が期限切れになったときに起こるように、単に、記憶ノードから除去されます。"
    },
    {
      "indent": 3,
      "text": "Note that in the case of arrays and dictionaries, expiration may create an implicit, unsigned \"nonexistent\" value to represent a gap in the data structure, as might happen when any value is aged out.",
      "ja": "いずれかの値が期限切れになるときに起こるかもしれないように配列及び辞書の場合には、有効期限は、データ構造内のギャップを表す暗黙の、符号なしの「存在しない」値を作成してもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "However, this value isn't persistent, nor is it replicated. It is simply synthesized by the storing node.",
      "ja": "ただし、この値は永続的ではない、またそれが複製されます。単に記憶ノードによって合成されます。"
    },
    {
      "indent": 0,
      "text": "7.4.2. Fetch",
      "section_title": true,
      "ja": "7.4.2。フェッチ"
    },
    {
      "indent": 3,
      "text": "The Fetch request retrieves one or more data elements stored at a given Resource-ID. A single Fetch request can retrieve multiple different Kinds.",
      "ja": "フェッチ要求は、特定のリソース-IDに格納された1つの以上のデータ要素を検索します。 1回のフェッチ要求は、複数の異なる種類を取得することができます。"
    },
    {
      "indent": 0,
      "text": "7.4.2.1. Request Definition",
      "section_title": true,
      "ja": "7.4.2.1。要求定義"
    },
    {
      "indent": 3,
      "text": "Fetch requests are defined by the FetchReq structure:",
      "ja": "フェッチ要求はFetchReq構造によって定義されています。"
    },
    {
      "indent": 8,
      "text": "struct {\n  int32            first;\n  int32            last;\n} ArrayRange;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  KindId                  kind;\n  uint64                  generation;\n  uint16                  length;",
      "raw": true
    },
    {
      "indent": 10,
      "text": "select (DataModel) {\n  case single_value: ;    /* Empty */",
      "raw": true
    },
    {
      "indent": 12,
      "text": "case array: ArrayRange indices<0..2^16-1>;",
      "ja": "ケース配列：ArrayRangeインデックス<0..2 ^ 16-1>。"
    },
    {
      "indent": 12,
      "text": "case dictionary: DictionaryKey keys<0..2^16-1>;",
      "ja": "ケース辞書：DictionaryKeyキー<0..2 ^ 16-1>;"
    },
    {
      "indent": 12,
      "text": "/* This structure may be extended */",
      "raw": true
    },
    {
      "indent": 8,
      "text": "  } model_specifier;\n} StoredDataSpecifier;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  ResourceId              resource;\n  StoredDataSpecifier     specifiers<0..2^16-1>;\n} FetchReq;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of the Fetch requests are as follows:",
      "ja": "次のように取得要求の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "resource The Resource-ID to fetch from.",
      "ja": "リソース-IDから取得するリソース。"
    },
    {
      "indent": 3,
      "text": "specifiers A sequence of StoredDataSpecifier values, each specifying some of the data values to retrieve.",
      "ja": "StoredDataSpecifier値のシーケンスを指定子、データ値の一部を特定それぞれ取得します。"
    },
    {
      "indent": 3,
      "text": "Each StoredDataSpecifier specifies a single Kind of data to retrieve and, if appropriate, the subset of values that are to be retrieved. The contents of the StoredDataSpecifier structure are as follows:",
      "ja": "各StoredDataSpecifierは、適切な場合には、取得したいデータの一種類、取得される値のサブセットを指定します。次のようにStoredDataSpecifier構造体の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "kind The Kind-ID of the data being fetched. Implementations SHOULD reject requests corresponding to unknown Kinds unless specifically configured otherwise.",
      "ja": "種類データの種類-IDがフェッチされます。実装は、特に他に設定されていない限り、未知の種類に対応する要求を拒否すべきです。"
    },
    {
      "indent": 3,
      "text": "DataModel The data model of the data. This is not transmitted on the wire, but comes from the definition of the Kind.",
      "ja": "データのDataModelはデータモデル。これは、ワイヤ上で送信されますが、種類の定義から来ていません。"
    },
    {
      "indent": 3,
      "text": "generation The last generation counter that the requesting node saw. This may be used to avoid unnecessary fetches, or it may be set to zero.",
      "ja": "世代要求ノードが見たことを最後の世代カウンター。これにより、不要なフェッチを回避するために使用することができる、またはそれはゼロに設定されてもよいです。"
    },
    {
      "indent": 3,
      "text": "length The length of the rest of the structure, thus allowing extensibility.",
      "ja": "長さは構造の残りの部分の長さは、このような拡張を可能にします。"
    },
    {
      "indent": 3,
      "text": "model_specifier A reference to the data value being requested within the data model specified for the Kind. For instance, if the data model is \"array\", it might specify some subset of the values.",
      "ja": "model_specifierデータ値への言及は、種類に指定されたデータモデル内で要求されています。データモデルは、「アレイ」である場合例えば、それはいくつかの値のサブセットを指定することができます。"
    },
    {
      "indent": 3,
      "text": "The model_specifier is as follows:",
      "ja": "次のようにmodel_specifierは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the data model is single value, the specifier is empty.",
      "ja": "データモデルは、単一の値である場合には、O、指定子は空です。"
    },
    {
      "indent": 3,
      "text": "o If the data model is array, the specifier contains a list of ArrayRange elements, each of which contains two integers. The first integer is the beginning of the range, and the second is the end of the range. 0 is used to indicate the first element, and 0xffffffff is used to indicate the final element. The first integer MUST be less than or equal to the second. While multiple ranges MAY be specified, they MUST NOT overlap.",
      "ja": "データモデルはアレイの場合、O、指定子は2つの整数を含んでいるそれぞれが、ArrayRange要素のリストを含みます。最初の整数は、範囲の始まりであり、第二は、範囲の端部です。 0は、最初の要素を示すために使用され、0xFFFFFFFFのは、最終要素を示すために使用されます。最初の整数は、第二のより小さいか等しくなければなりません。複数の範囲を指定することができるが、彼らは重複してはなりません。"
    },
    {
      "indent": 3,
      "text": "o If the data model is dictionary, then the specifier contains a list of the dictionary keys being requested. If no keys are specified, then this is a wildcard fetch and all key-value pairs are returned.",
      "ja": "データモデルは辞書であればO、そして指定子は、要求されている辞書のキーのリストが含まれています。何のキーが指定されていない場合、これは、ワイルドカードがフェッチされ、すべてのキーと値のペアが返されます。"
    },
    {
      "indent": 3,
      "text": "The generation counter is used to indicate the requester's expected state of the storing peer. If the generation counter in the request matches the stored counter, then the storing peer returns a response with no StoredData values.",
      "ja": "世代カウンタが記憶ピアの要求者の期待される状態を示すために使用されます。要求で生成カウンタが格納されているカウンタと一致した場合、記憶ピアはないStoredData値を有する応答を返します。"
    },
    {
      "indent": 0,
      "text": "7.4.2.2. Response Definition",
      "section_title": true,
      "ja": "7.4.2.2。レスポンスの定義"
    },
    {
      "indent": 3,
      "text": "The response to a successful Fetch request is a FetchAns message containing the data requested by the requester.",
      "ja": "成功したフェッチ要求に対する応答は、要求者から要求されたデータを含むFetchAnsメッセージです。"
    },
    {
      "indent": 9,
      "text": "struct {\n  KindId                 kind;\n  uint64                 generation;\n  StoredData             values<0..2^32-1>;\n} FetchKindResponse;",
      "raw": true
    },
    {
      "indent": 9,
      "text": "struct {\n  FetchKindResponse      kind_responses<0..2^32-1>;\n} FetchAns;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The FetchAns structure contains a series of FetchKindResponse structures. There MUST be one FetchKindResponse element for each Kind-ID in the request.",
      "ja": "FetchAns構造はFetchKindResponse構造のシリーズが含まれています。各種類-ID要求の中に1つのFetchKindResponse要素があるに違いありません。"
    },
    {
      "indent": 3,
      "text": "The contents of the FetchKindResponse structure are as follows:",
      "ja": "次のようにFetchKindResponse構造体の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "kind The Kind that this structure is for.",
      "ja": "この構造がためのものであること種類種類。"
    },
    {
      "indent": 3,
      "text": "generation The generation counter for this Kind.",
      "ja": "この種の生成生成カウンタを。"
    },
    {
      "indent": 3,
      "text": "values The relevant values. If the generation counter in the request matches the generation counter in the stored data, then no StoredData values are returned. Otherwise, all relevant data values MUST be returned. A nonexistent value (i.e., one which the node has no knowledge of) is represented by a synthetic value with \"exists\" set to False and has an empty signature. Specifically, the identity_type is set to \"none\", the SignatureAndHashAlgorithm values are set to {0, 0} (\"anonymous\" and \"none\", respectively), and the signature value is of zero length. This removes the need for the responding node to do signatures for values which do not exist. These signatures are unnecessary, as the entire response is signed by that node. Note that entries which have been removed by the procedure given in Section 7.4.1.3 and which have not yet expired also have exists = False, but have valid signatures from the node which did the store.",
      "ja": "関連する値を値。要求で生成カウンタが格納されたデータで生成カウンタと一致する場合、次に何StoredData値が返されません。それ以外の場合は、関連するすべてのデータ値を返さなければなりません。存在しない値（ノードの知識を持たない、すなわち、1）がFalseに設定され、空の署名を持っている「存在」を有する合成値で表されます。具体的には、identity_typeが「なし」に設定されている、SignatureAndHashAlgorithm値を（それぞれ、「匿名」と「なし」）{0,0}に設定し、署名値はゼロ長であるれています。これは、存在しない値のための署名を行うには応答ノードの必要性を取り除きます。全体の応答は、そのノードによって署名されているように、これらの署名は、不要です。節7.4.1.3に与えられた手順で削除されていると、まだまた、期限が切れていないそのエントリは= Falseの存在持っていますが、店舗をしたノードから有効な署名を持っていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a FetchAns message, nodes MUST verify the signatures on all the received values. Any values with invalid signatures (including expired certificates) MUST be discarded. Note that this implies that implementations which wish to store data for long periods of time must have certificates with appropriate expiration dates or must re-store periodically. Implementations MAY return the subset of values with valid signatures, but in that case, they SHOULD somehow signal to the application that a partial response was received.",
      "ja": "FetchAnsメッセージを受信すると、ノードが全ての受信値に対して署名を検証しなければなりません。 （期限切れの証明書を含む）無効な署名を持つ任意の値は捨てなければなりません。これは長期間のデータを保存したいの実装は、適切な有効期限を持つ証明書を持っている必要がありますか、定期的に再格納しなければならないことを意味することに注意してください。実装は、有効な署名を持つ値のサブセットを返してもよいが、その場合には、彼らは何とかパーシャルレスポンスを受信したアプリケーションに知らせるべきです。"
    },
    {
      "indent": 3,
      "text": "There is one subtle point about signature computation on arrays. If the storing node uses the append feature (where the index=0xffffffff), then the index in the StoredData that is returned will not match that used by the storing node, which would break the signature. In order to avoid this issue, the index value in the array is set to zero before the signature is computed. This implies that malicious storing nodes can reorder array entries without being detected.",
      "ja": "アレイ上の署名演算約微妙な点があります。記憶ノードは、追記機能（インデックス= 0xFFFFFFFFの）を使用している場合、返されるStoredDataのインデックスは、署名を破ることになる記憶ノードによって使用されるものと一致しないであろう。署名が計算される前に、この問題を回避するために、配列のインデックス値はゼロに設定されています。これは、悪意のある記憶ノードが検出されることなく、アレイエントリを並べ替えることができることを意味します。"
    },
    {
      "indent": 0,
      "text": "7.4.3. Stat",
      "section_title": true,
      "ja": "7.4.3。状態"
    },
    {
      "indent": 3,
      "text": "The Stat request is used to get metadata (length, generation counter, digest, etc.) for a stored element without retrieving the element itself. The name is from the UNIX stat(2) system call, which performs a similar function for files in a file system. It also allows the requesting node to get a list of matching elements without requesting the entire element.",
      "ja": "スタット要求は素子自体を取得することなく、格納された要素の（など、長さ、世代カウンタダイジェスト）メタデータを取得するために使用されます。名前は、ファイルシステム内のファイルに対して同様の機能を実行するUNIXのstat（2）システムコールからです。それはまた、要求ノードが全体の要素を要求することなく、一致する要素のリストを取得することを可能にします。"
    },
    {
      "indent": 0,
      "text": "7.4.3.1. Request Definition",
      "section_title": true,
      "ja": "7.4.3.1。要求定義"
    },
    {
      "indent": 3,
      "text": "The Stat request is identical to the Fetch request. It simply specifies the elements to get metadata about.",
      "ja": "Statの要求がフェッチ要求と同じです。これは、単にに関するメタデータを取得するための要素を指定します。"
    },
    {
      "indent": 8,
      "text": "struct {\n  ResourceId              resource;\n  StoredDataSpecifier     specifiers<0..2^16-1>;\n} StatReq;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.4.3.2. Response Definition",
      "section_title": true,
      "ja": "7.4.3.2。レスポンスの定義"
    },
    {
      "indent": 3,
      "text": "The Stat response contains the same sort of entries that a Fetch response would contain. However, instead of containing the element data, it contains metadata.",
      "ja": "スタット応答は、フェッチ応答が含まれますエントリの同じ種類が含まれています。しかし、代わりに要素データを含んでいると、それはメタデータが含まれています。"
    },
    {
      "indent": 8,
      "text": "struct {\n  Boolean                exists;\n  uint32                 value_length;\n  HashAlgorithm          hash_algorithm;\n  opaque                 hash_value<0..255>;\n} MetaData;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  uint32                 index;\n  MetaData               value;\n} ArrayEntryMeta;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  DictionaryKey          key;\n  MetaData               value;\n} DictionaryEntryMeta;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  select (DataModel) {\n    case single_value:\n      MetaData              single_value_entry;",
      "raw": true
    },
    {
      "indent": 12,
      "text": "case array:\n  ArrayEntryMeta        array_entry;",
      "raw": true
    },
    {
      "indent": 12,
      "text": "case dictionary: DictionaryEntryMeta dictionary_entry;",
      "ja": "ケース辞書：DictionaryEntryMetaのdictionary_entry。"
    },
    {
      "indent": 8,
      "text": "    /* This structure may be extended */\n  };\n} MetaDataValue;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  uint32                  value_length;\n  uint64                  storage_time;\n  uint32                  lifetime;\n  MetaDataValue           metadata;\n} StoredMetaData;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  KindId                 kind;\n  uint64                 generation;\n  StoredMetaData         values<0..2^32-1>;\n} StatKindResponse;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n  StatKindResponse      kind_responses<0..2^32-1>;\n} StatAns;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The structures used in StatAns parallel those used in FetchAns: a response consists of multiple StatKindResponse values, one for each Kind that was in the request. The contents of the StatKindResponse are the same as those in the FetchKindResponse, except that the values list contains StoredMetaData entries instead of StoredData entries.",
      "ja": "StatAnsに使用される構造はFetchAnsに使用されるものを平行：応答は、複数StatKindResponse値から構成要求にあった各種類に対して1つ。 StatKindResponseの内容は、値リストではなくStoredDataエントリのStoredMetaDataのエントリが含まれていることを除いて、FetchKindResponseと同じです。"
    },
    {
      "indent": 3,
      "text": "The contents of the StoredMetaData structure are the same as the corresponding fields in StoredData, except that there is no signature field and the value is a MetaDataValue rather than a StoredDataValue.",
      "ja": "StoredMetaData構造の内容は、そこには、署名フィールドがないと値がMetaDataValueなくStoredDataValueであることを除いて、StoredDataの対応するフィールドと同じです。"
    },
    {
      "indent": 3,
      "text": "A MetaDataValue is a variant structure, like a StoredDataValue, except for the types of each arm, which replace DataValue with MetaData.",
      "ja": "MetaDataValueは、メタデータとDataValueはを置き換える各アームの種類を除いて、StoredDataValueように、変異体構造です。"
    },
    {
      "indent": 3,
      "text": "The only new structure is MetaData, which has the following contents:",
      "ja": "唯一の新しい構造は、以下の内容を持つメタデータ、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "exists Same as in DataValue.",
      "ja": "DataValueは内と同じ存在します。"
    },
    {
      "indent": 3,
      "text": "value_length The length of the stored value.",
      "ja": "格納された値の長さをvalue_length。"
    },
    {
      "indent": 3,
      "text": "hash_algorithm The hash algorithm used to perform the digest of the value.",
      "ja": "値のダイジェストを実行するために使用されるハッシュアルゴリズムをhash_algorithm。"
    },
    {
      "indent": 3,
      "text": "hash_value A digest using hash_algorithm on the value field of the DataValue, including its 4 leading length bytes.",
      "ja": "その4つの先頭の長さバイトを含むDataValueはの値フィールド、上hash_algorithmを用いHASH_VALUE Aダイジェスト。"
    },
    {
      "indent": 0,
      "text": "7.4.4. Find",
      "section_title": true,
      "ja": "7.4.4。見つける"
    },
    {
      "indent": 3,
      "text": "The Find request can be used to explore the Overlay Instance. A Find request for a Resource-ID R and a Kind-ID T retrieves the Resource-ID, if any, of the resource of Kind T known to the target peer which is closest to R. This method can be used to walk the Overlay Instance by iteratively fetching R_n+1=nearest(1 + R_n).",
      "ja": "検索要求は、オーバーレイインスタンスを探索するために使用することができます。リソースID-Rや種類-IDがあればTは、この方法は、オーバーレイを歩くために使用することができるR.に最も近いターゲットピアに知られている種類Tのリソースを、リソース-IDを検索するための検索要求繰り返しフェッチによってインスタンスたR_n + 1 =最も近い（1 +たR_n）。"
    },
    {
      "indent": 0,
      "text": "7.4.4.1. Request Definition",
      "section_title": true,
      "ja": "7.4.4.1。要求定義"
    },
    {
      "indent": 3,
      "text": "The FindReq message contains a Resource-ID and a series of Kind-IDs identifying the resource the peer is interested in.",
      "ja": "FindReqメッセージは、リソースID及びピアが興味のあるリソースを識別する品種IDの系列を含んでいます。"
    },
    {
      "indent": 5,
      "text": "struct {\n  ResourceId                 resource;\n  KindId                     kinds<0..2^8-1>;\n} FindReq;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The request contains a list of Kind-IDs which the Find is for, as indicated below:",
      "ja": "リクエストは、以下に示すように、検索は、のためにある種類-IDのリストが含まれています。"
    },
    {
      "indent": 3,
      "text": "resource The desired Resource-ID.",
      "ja": "目的のリソース-IDリソース。"
    },
    {
      "indent": 3,
      "text": "kinds The desired Kind-IDs. Each value MUST appear only once. Otherwise, the request MUST be rejected with an error.",
      "ja": "種類、所望の品種IDは。各値は、一度だけ現れなければなりません。そうしないと、要求はエラーで拒絶しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.4.4.2. Response Definition",
      "section_title": true,
      "ja": "7.4.4.2。レスポンスの定義"
    },
    {
      "indent": 3,
      "text": "A response to a successful Find request is a FindAns message containing the closest Resource-ID on the peer for each Kind specified in the request.",
      "ja": "成功した検索要求に対する応答は、要求で指定された各種類のピアに最も近いリソース-IDを含むFindAnsメッセージです。"
    },
    {
      "indent": 4,
      "text": "struct {\n  KindId                      kind;\n  ResourceId                  closest;\n} FindKindData;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "struct {\n  FindKindData                results<0..2^16-1>;\n} FindAns;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the processing peer is not responsible for the specified Resource-ID, it SHOULD return an Error_Not_Found error code.",
      "ja": "処理ピアが指定されたリソース-IDの責任ではない場合、それはERROR_NOT_FOUNDエラーコードを返すべきです。"
    },
    {
      "indent": 3,
      "text": "For each Kind-ID in the request, the response MUST contain a FindKindData indicating the closest Resource-ID for that Kind-ID, unless the Kind is not allowed to be used with Find, in which case a FindKindData for that Kind-ID MUST NOT be included in the response. If a Kind-ID is not known, then the corresponding Resource-ID MUST be 0. Note that different Kind-IDs may have different closest Resource-IDs.",
      "ja": "種類が検索で使用することを許可されていない場合を除き、各種類-ID要求では、応答は、その種類-ID、最も近いリソース-IDを示すFindKindDataを含まなければならない、場合FindKindDataその種類-IDのための絶対必要応答に含まれていません。種類-IDが知られていない場合は、対応するリソース-IDは、異なる種類-IDが最も近い異なるリソース-IDを有していてもよいことが0注意していなければなりません。"
    },
    {
      "indent": 3,
      "text": "The response is simply a series of FindKindData elements, one per Kind, concatenated end to end. The contents of each element are:",
      "ja": "応答は、単にFindKindData要素、種類ごとに、端部に連結端の系列です。各要素の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "kind The Kind-ID.",
      "ja": "種類種類-ID。"
    },
    {
      "indent": 3,
      "text": "closest The closest Resource-ID to the specified Resource-ID. It is 0 if no Resource-ID is known.",
      "ja": "指定されたリソース-IDに最も近い最も近いリソース-ID。何のリソース-IDが知られていない場合は0です。"
    },
    {
      "indent": 3,
      "text": "Note that the response does not contain the contents of the data stored at these Resource-IDs. If the requester wants this, it must retrieve it using Fetch.",
      "ja": "応答は、これらの資源のIDで保存されたデータの内容が含まれていないことに注意してください。依頼者がこれを望んでいるなら、それはフェッチ使用して、それを取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.4.5. Defining New Kinds",
      "section_title": true,
      "ja": "7.4.5。新しい種類の定義"
    },
    {
      "indent": 3,
      "text": "There are two ways to define a new Kind. The first is by writing a document and registering the Kind-ID with IANA. This is the preferred method for Kinds which may be widely used and reused. The second method is to simply define the Kind and its parameters in the Configuration Document using the section of Kind-ID space set aside for private use. This method MAY be used to define ad hoc Kinds in new overlays.",
      "ja": "新しい種類を定義する2つの方法があります。最初は、ドキュメントを書くとIANAと種類-IDを登録することです。これは、広く使用され、再使用することができる種類の好ましい方法です。第二の方法は、単に種類、私的使用のために確保した種類-ID空間の部分を使用して設定文書でそのパラメータを定義することです。このメソッドは、新しいオーバーレイでアドホック種類を定義するために使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "However a Kind is defined, the definition MUST include:",
      "ja": "種類が定義されているが、定義が含まれている必要があります"
    },
    {
      "indent": 3,
      "text": "o The meaning of the data to be stored (in some textual form).",
      "ja": "（いくつかのテキスト形式で）格納されるデータの意味O。"
    },
    {
      "indent": 3,
      "text": "o The Kind-ID.",
      "ja": "種類-ID O。"
    },
    {
      "indent": 3,
      "text": "o The data model (single value, array, dictionary, etc.).",
      "ja": "Oデータ・モデル（単一値、アレイ、辞書、等）。"
    },
    {
      "indent": 3,
      "text": "o The access control model.",
      "ja": "アクセス制御モデルO。"
    },
    {
      "indent": 3,
      "text": "In addition, when Kinds are registered with IANA, each Kind is assigned a short string name which is used to refer to it in Configuration Documents.",
      "ja": "種類のIANAに登録されている場合に加えて、各種類の構成ドキュメントにそれを参照するために使用される短い文字列名が割り当てられています。"
    },
    {
      "indent": 3,
      "text": "While each Kind needs to define what data model is used for its data, this does not mean that it must define new data models. Where practical, Kinds should use the existing data models. The intention is that the basic data model set be sufficient for most applications/ usages.",
      "ja": "各種類は、そのデータに使用されるどのようなデータモデルを定義する必要がありますが、これは新しいデータモデルを定義しなければならないという意味ではありません。どこに実用的な、種類は、既存のデータモデルを使用する必要があります。その意図は、基本的なデータモデルセットは、ほとんどのアプリケーション/用途のために十分であることです。"
    },
    {
      "indent": 0,
      "text": "8. Certificate Store Usage",
      "section_title": true,
      "ja": "8. [証明書ストアの使用状況"
    },
    {
      "indent": 3,
      "text": "The Certificate Store Usage allows a node to store its certificate in the overlay.",
      "ja": "証明書ストアの使用状況は、ノードがオーバーレイでその証明書を保存することができます。"
    },
    {
      "indent": 3,
      "text": "A user/node MUST store its certificate at Resource-IDs derived from two Resource Names:",
      "ja": "ユーザ/ノードは、2つのリソースの名前に由来する資源のIDでその証明書を格納しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The user name in the certificate.",
      "ja": "証明書内のユーザー名O。"
    },
    {
      "indent": 3,
      "text": "o The Node-ID in the certificate.",
      "ja": "ノードID証明書中のO。"
    },
    {
      "indent": 3,
      "text": "Note that in the second case, the certificate for a peer is not stored at its Node-ID but rather at a hash of its Node-ID. The intention here (as is common throughout RELOAD) is to avoid making a peer responsible for its own data.",
      "ja": "第二の場合には、ピアの証明書は、そのノードIDではなく、むしろ、そのノードIDのハッシュに格納されていないことに留意されたいです。ここでの意図は、（RELOADを通じて一般的であるように）独自のデータを担当するピアを避けることです。"
    },
    {
      "indent": 3,
      "text": "New certificates are stored at the end of the list. This structure allows users to store an old and a new certificate that both have the same Node-ID, which allows for migration of certificates when they are renewed.",
      "ja": "新しい証明書は、リストの最後に格納されています。この構造は、ユーザーが古いとの両方が同じノードID、それらが更新されたときに、証明書の移行を可能にした新しい証明書を保存することができます。"
    },
    {
      "indent": 3,
      "text": "This usage defines the following Kinds:",
      "ja": "この使用法は、次の種類が定義されています。"
    },
    {
      "indent": 3,
      "text": "Name: CERTIFICATE_BY_NODE",
      "ja": "名前：CERTIFICATE_BY_NODE"
    },
    {
      "indent": 3,
      "text": "Data Model: The data model for CERTIFICATE_BY_NODE data is array.",
      "ja": "データモデル：CERTIFICATE_BY_NODEデータのためのデータモデルは、配列です。"
    },
    {
      "indent": 3,
      "text": "Access Control: NODE-MATCH",
      "ja": "アクセス制御：NODE-MATCH"
    },
    {
      "indent": 3,
      "text": "Name: CERTIFICATE_BY_USER",
      "ja": "名前：CERTIFICATE_BY_USER"
    },
    {
      "indent": 3,
      "text": "Data Model: The data model for CERTIFICATE_BY_USER data is array.",
      "ja": "データモデル：CERTIFICATE_BY_USERデータのためのデータモデルは、配列です。"
    },
    {
      "indent": 3,
      "text": "Access Control: USER-MATCH",
      "ja": "アクセスコントロール：USER-MATCH"
    },
    {
      "indent": 0,
      "text": "9. TURN Server Usage",
      "section_title": true,
      "ja": "9. TURNサーバーの使用法"
    },
    {
      "indent": 3,
      "text": "The TURN Server Usage allows a RELOAD peer to advertise that it is prepared to be a TURN server, as defined in [RFC5766]. When a node starts up, it joins the overlay network and forms several connections in the process. If the ICE stage in any of these connections returns a reflexive address that is not the same as the peer's perceived address, then the peer is behind a NAT and SHOULD NOT be a candidate for a TURN server. Additionally, if the peer's IP address is in the private address space range as defined by [RFC1918], then it is also",
      "ja": "TURNサーバの使用リロードピアが[RFC5766]で定義されるように、TURNサーバであるように準備されることをアドバタイズすることを可能にします。ノードは、起動時には、オーバーレイネットワークに参加し、その過程でいくつかの接続を形成しています。これらの接続のいずれかのICEステージは、ピアの認知アドレスと同じではありません再帰のアドレスを返す場合、ピアはNATの背後にあるとTURNサーバーの候補べきではありません。 [RFC1918]で定義されているピアのIPアドレスがプライベートアドレス空間の範囲内にある場合はさらに、それはまたです"
    },
    {
      "indent": 3,
      "text": "SHOULD NOT be a candidate for a TURN server. Otherwise, the peer SHOULD assume that it is a potential TURN server and follow the procedures below.",
      "ja": "TURNサーバの候補とすべきではありません。そうでない場合、ピアは、それが潜在的なTURNサーバであることを前提とすべきであり、以下の手順に従ってください。"
    },
    {
      "indent": 3,
      "text": "If the node is a candidate for a TURN server, it will insert some pointers in the overlay so that other peers can find it. The overlay configuration file specifies a turn-density parameter that indicates how many times each TURN server SHOULD record itself in the overlay. Typically, this should be set to the reciprocal of the estimate of what percentage of peers will act as TURN servers. If the turn-density is not set to zero, for each value, called d, between 1 and turn-density, the peer forms a Resource Name by concatenating its Node-ID and the value d. This Resource Name is hashed to form a Resource-ID. The address of the peer is stored at that Resource-ID using type TURN-SERVICE and the TurnServer object:",
      "ja": "ノードがTURNサーバーの候補である場合には、他のピアがそれを見つけることができるように、それはオーバーレイでいくつかのポインタを挿入します。オーバーレイ設定ファイルには、各TURNサーバーがオーバーレイで自分自身を記録する回数を示しターン密度パラメータを指定します。通常、これはTURNサーバとして動作するピアの何パーセントの推定値の逆数に設定する必要があります。ターン密度がゼロに設定されていない場合、各値に対して、1およびターン密度と、Dと呼ばれ、ピアは、そのノードIDおよび値Dを連結することによって、リソース名を形成します。このリソース名は、リソースIDを形成するためにハッシュされます。ピアのアドレスは、タイプTURN-SERVICEとTurnServerオブジェクトを使用して、そのリソース-IDに格納されています。"
    },
    {
      "indent": 8,
      "text": "struct {\n  uint8                   iteration;\n  IpAddressPort           server_address;\n} TurnServer;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of this structure are as follows:",
      "ja": "次のようにこの構造体の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "iteration The d value.",
      "ja": "d値の繰り返し。"
    },
    {
      "indent": 3,
      "text": "server_address The address at which the TURN server can be contacted.",
      "ja": "TURNサーバが連絡可能なアドレスSERVER_ADDRESS。"
    },
    {
      "indent": 3,
      "text": "Note: Correct functioning of this algorithm depends on having turn-density be a reasonable estimate of the reciprocal of the proportion of nodes in the overlay that can act as TURN servers. If the turn-density value in the configuration file is too low, the process of finding TURN servers becomes more expensive, as multiple candidate Resource-IDs must be probed to find a TURN server.",
      "ja": "注意：このアルゴリズムが正しく機能は、ターン密度がTURNサーバとして機能することができ、オーバーレイ内のノードの割合の逆数の合理的な見積りも持つに依存します。設定ファイルのターン濃度値が低すぎる場合は、複数の候補リソース-IDがTURNサーバーを見つけるために精査しなければならないとして、TURNサーバを見つけるプロセスは、より高価になります。"
    },
    {
      "indent": 3,
      "text": "Peers that provide this service need to support the TURN extensions to STUN for media relay, as defined in [RFC5766].",
      "ja": "このサービスを提供するピアは、[RFC5766]で定義されるように、メディアリレーのためにSTUNするTURN拡張をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "This usage defines the following Kind to indicate that a peer is willing to act as a TURN server:",
      "ja": "この使用は、ピアは、TURNサーバとして機能する意思があることを示すために、次の種類を定義しています。"
    },
    {
      "indent": 3,
      "text": "Name: TURN-SERVICE",
      "ja": "名前：TURN-SERVICE"
    },
    {
      "indent": 3,
      "text": "Data Model: The TURN-SERVICE Kind stores a single value for each Resource-ID.",
      "ja": "データモデル：TURN-サービス種別は、各リソース-IDのための単一の値を格納します。"
    },
    {
      "indent": 3,
      "text": "Access Control: NODE-MULTIPLE, with a maximum iteration of counter 20.",
      "ja": "アクセス制御：NODE-MULTIPLE、カウンタ20の最大反復を有します。"
    },
    {
      "indent": 3,
      "text": "Peers MAY find other servers by selecting a random Resource-ID and then doing a Find request for the appropriate Kind-ID with that Resource-ID. The Find request gets routed to a random peer based on the Resource-ID. If that peer knows of any servers, they will be returned. The returned response may be empty if the peer does not know of any servers, in which case the process gets repeated with some other random Resource-ID. As long as the ratio of servers relative to peers is not too low, this approach will result in finding a server relatively quickly.",
      "ja": "ピアは、ランダムなリソース-IDを選択し、そのリソース-IDとの適切な種類-IDのための検索要求を行うことによって、他のサーバーを見つけることができます。検索要求は、リソース-IDに基づいて、ランダムなピアにルーティングされます。そのピアは、すべてのサーバーを知っているならば、彼らが返されます。ピアは、プロセスが他のいくつかのランダムなリソース-IDを用いて繰り返します。その場合には任意のサーバ、を知っていない場合に返されるレスポンスは空になることがあります。限りピアに対するサーバの比率が低すぎないように、このアプローチは、比較的速く、サーバーを見つけることになります。"
    },
    {
      "indent": 3,
      "text": "Note to implementers: The certificates used by TurnServer entries need to be retained, as described in Section 6.3.4.",
      "ja": "実装者への注意：TurnServerエントリによって使用される証明書は、セクション6.3.4で説明したように、保持する必要があります。"
    },
    {
      "indent": 0,
      "text": "10. Chord Algorithm",
      "section_title": true,
      "ja": "10.コードアルゴリズム"
    },
    {
      "indent": 3,
      "text": "This algorithm is assigned the name CHORD-RELOAD to indicate that it is an adaptation of the basic Chord-based DHT algorithm.",
      "ja": "このアルゴリズムは、それが基本的なコードベースのDHTアルゴリズムの適応であることを示すために名前CHORD-RELOADが割り当てられます。"
    },
    {
      "indent": 3,
      "text": "This algorithm differs from the Chord algorithm that was originally presented in [Chord]. It has been updated based on more recent research results and implementation experiences, and to adapt it to the RELOAD protocol. Here is a short list of differences:",
      "ja": "このアルゴリズムは、もともと[コード]で提示されたコード・アルゴリズムとは異なります。これは、より多くの最近の研究成果や実装の経験に基づいて更新されている、とRELOADプロトコルに適合するように。ここでの違いの短いリストは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The original Chord algorithm specified that a single predecessor and a successor list be stored. The CHORD-RELOAD algorithm attempts to have more than one predecessor and successor. The predecessor sets help other neighbors learn their successor list.",
      "ja": "Oオリジナルコードのアルゴリズムは、単一の先行および後続リストが格納されることを指定しました。 CHORD-RELOADアルゴリズムは、複数の前任者と後継者を持ってしようとします。前身のセットは、他の隣人が自分の後継者リストを学ぶのを助けます。"
    },
    {
      "indent": 3,
      "text": "o The original Chord specification and analysis called for iterative routing. RELOAD specifies recursive routing. In addition to the performance implications, the cost of NAT traversal dictates recursive routing.",
      "ja": "反復ルーティングを求め、元のコードの仕様及び分析O。 RELOADは、再帰的なルーティングを指定します。パフォーマンスへの影響に加えて、NATトラバーサルのコストは、再帰的なルーティングを決定します。"
    },
    {
      "indent": 3,
      "text": "o Finger Table entries are indexed in the opposite order. Original Chord specifies finger[0] as the immediate successor of the peer. CHORD-RELOAD specifies finger[0] as the peer 180 degrees around the ring from the peer. This change was made to simplify discussion and implementation of variable-sized Finger Tables. However, with either approach, no more than O(log N) entries should typically be stored in a Finger Table.",
      "ja": "Oフィンガーテーブルエントリは、逆の順序で索引付けされています。オリジナルコードは[0]ピアの直接の後継者として指を指定します。 CHORDリロード180度ピアからリングの周りにピアとして[0]指を指定します。この変更は、可変サイズのフィンガーテーブルの議論と実装を簡素化するために作られました。しかし、O超えないアプローチ、のいずれかで（Nログ）エントリは、典型的には、フィンガーテーブルに格納されるべきです。"
    },
    {
      "indent": 3,
      "text": "o The stabilize() and fix_fingers() algorithms in the original Chord algorithm are merged into a single periodic process. Stabilization is implemented slightly differently because of the larger neighborhood, and fix_fingers is not as aggressive to reduce load, nor does it search for optimal matches of the Finger Table entries.",
      "ja": "安定化（）とfix_fingers O（元のコード・アルゴリズムで）アルゴリズムは、単一の周期的プロセスにマージされます。安定化があるため、より大きな近所の若干異なる実装されており、fix_fingersは、負荷を軽減するなど積極的ではない、またそれは、フィンガーテーブルエントリの最適な一致を検索しません。"
    },
    {
      "indent": 3,
      "text": "o RELOAD allows for a 128-bit hash instead of a 160-bit hash, as RELOAD is not designed to be used in networks with close to or more than 2^128 nodes or objects (and it is hard to see how one would assemble such a network).",
      "ja": "Oリロードリロードが1がアセンブルする方法を参照するに近い又は2つの以上^ 128のノードまたはオブジェクト（およびそれが困難であるとネットワークで使用されるように設計されていないように、代わりに160ビットのハッシュの128ビットのハッシュを可能にしますそのようなネットワーク）。"
    },
    {
      "indent": 3,
      "text": "o RELOAD uses randomized finger entries, as described in Section 10.7.4.2.",
      "ja": "セクション10.7.4.2で説明したように、O RELOADは、無作為化、指のエントリを使用しています。"
    },
    {
      "indent": 3,
      "text": "o The CHORD-RELOAD algorithm allows the use of either reactive or periodic recovery. The original Chord paper used periodic recovery. Reactive recovery provides better performance in small overlays, but is believed to be unstable in large overlays (greater than 1000) with high levels of churn [handling-churn-usenix04]. The overlay configuration file specifies a \"chord-reactive\" element that indicates whether reactive recovery should be used.",
      "ja": "O CHORD-RELOADアルゴリズムは、いずれかの反応性または定期的な回復を使用することができます。オリジナルのコード・ペーパーでは、定期的な回復を使用しました。反応性の回復は[取り扱い-チャーン-usenix04]小さなオーバーレイでより良い性能を提供するが、解約の高レベルの大きいオーバーレイ（1000より大きい）で不安定であると考えられます。オーバーレイの設定ファイルは、反応性の回復を使用するかどうかを示す「和音反応性」の要素を指定します。"
    },
    {
      "indent": 0,
      "text": "10.1. Overview",
      "section_title": true,
      "ja": "10.1。概要"
    },
    {
      "indent": 3,
      "text": "The algorithm described here, CHORD-RELOAD, is a modified version of the Chord algorithm. In Chord (and in the algorithm described here), nodes are arranged in a ring, with node n being adjacent to nodes n-1 and n+1 and with all arithmetic being done modulo 2^{k}, where k is the length of the Node-ID in bits, so that node 2^{k} - 1 is directly before node 0.",
      "ja": "ここで説明するアルゴリズムは、CHORDリロードは、コード・アルゴリズムの修正版です。コード内の（およびここで説明されたアルゴリズムに）、ノードはノードと、リング状に配置されたn個のノードに隣接するN-1及びN + 1と全ての演算は、kは長さ2 ^ {K}モジュロ行われるとされビットにおけるノードID、その結果、ノード2 ^ {K}の -  1ノード0の直前にあります。"
    },
    {
      "indent": 3,
      "text": "Each peer keeps track of a Finger Table and a Neighbor Table. The Neighbor Table contains at least the three peers before and after this peer in the DHT ring. There may not be three entries in all cases, such as small rings or while the ring topology is changing. The first entry in the Finger Table contains the peer halfway around the ring from this peer, the second entry contains the peer that is 1/4th of the way around, the third entry contains the peer that is 1/8th of the way around, and so on. Fundamentally, the Chord DHT can be thought of as a doubly linked list formed by knowing the successors and predecessor peers in the Neighbor Table, sorted by the Node-ID. As long as the successor peers are correct, the DHT will return the correct result. The pointers to the prior peers are kept to enable the insertion of new peers into the list structure. Keeping multiple predecessor and successor pointers makes it possible to maintain the integrity of the data structure even when consecutive peers simultaneously fail. The Finger Table forms a skip list [wikiSkiplist] so that entries in the linked list can be found in O(log(N)) time instead of the typical O(N) time that a linked list would provide, where N represents the number of nodes in the DHT.",
      "ja": "各ピアは指表とネイバーテーブルを追跡します。ネイバーテーブルは、DHTリングで、このピアの前と後の少なくとも3つのピアが含まれています。リングトポロジが変化している間あり、このような小さなリングなど、すべての場合に3つのエントリ、であってもなくてもよいです。フィンガーテーブルの最初のエントリは、このピアからのリングの周りピア途中を含み、第2のエントリは、回避する方法の1/4であるピアが含まれ、3番目のエントリは、回避する方法の1/8であるピアが含ま等々。基本的に、コードDHTは、ノードIDでソート、ネイバーテーブルに後継と先行ピアを知ることによって形成される二重リンクリストとして考えることができます。限り後継ピアが正しいとして、DHTは、正しい結果を返します。前のピアへのポインタは、リスト構造に新しいピアの挿入を可能にするために保管されています。複数の前任者と後継者のポインタを維持する連続したピアが同時に故障してもデータ構造の整合性を維持することが可能となります。フィンガーテーブルNが数を表すリンクされたリスト内のエントリがOで見つけることができることをスキップリスト[wikiSkiplist]ので（ログ（N））にリンクされたリストを提供する代わりに、典型的なO（N）時間の時間を、形成しますDHT内のノードの。"
    },
    {
      "indent": 3,
      "text": "The Neighbor Table and Finger Table entries contain logical Node-IDs as values, but the actual mapping of an IP level addressing information to reach that Node-ID is kept in the Connection Table.",
      "ja": "ネイバーテーブルとフィンガーテーブルエントリは、値として、論理ノードIDを含むが、そのノードIDに到達するアドレス情報をIPレベルの実際のマッピングは、接続テーブルに保持されています。"
    },
    {
      "indent": 3,
      "text": "A peer, x, is responsible for a particular Resource-ID, k, if k is less than or equal to x and k is greater than p, where p is the Node-ID of the previous peer in the Neighbor Table. Care must be taken when computing to note that all math is modulo 2^128.",
      "ja": "kがx以下であり、kは、pはネイバーテーブル内の前のピアのノードIDであるPよりも大きい場合、ピア、xは、特定のリソース-ID、Kの責任です。すべての数学は、法2 ^ 128であることに注意することは計算するときには注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2. Hash Function",
      "section_title": true,
      "ja": "10.2。ハッシュ関数"
    },
    {
      "indent": 3,
      "text": "For this Chord-based Topology Plug-in, the size of the Resource-ID is 128 bits. The hash of a Resource-ID MUST be computed using SHA-1 [RFC3174], and then the SHA-1 result MUST be truncated to the most significant 128 bits.",
      "ja": "このコードベースのトポロジプラグインのために、リソース-IDのサイズは128ビットです。リソース-IDのハッシュは、SHA-1 [RFC3174]を使用して計算しなければなりません、そして、次にSHA-1の結果は、最上位128ビットに切り詰めなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.3. Routing",
      "section_title": true,
      "ja": "10.3。ルーティング"
    },
    {
      "indent": 3,
      "text": "The Routing Table is conceptually the union of the Neighbor Table and the Finger Table.",
      "ja": "ルーティングテーブルは、概念的にはネイバーテーブルと指表の労働組合です。"
    },
    {
      "indent": 3,
      "text": "If a peer is not responsible for a Resource-ID k, but is directly connected to a node with Node-ID k, then it MUST route the message to that node. Otherwise, it MUST route the request to the peer in the Routing Table that has the largest Node-ID that is in the interval between the peer and k. If no such node is found, the peer finds the smallest Node-ID that is greater than k and MUST route the message to that node.",
      "ja": "ピアは、リソースID Kを担当していない場合、しかし、直接ノードID kにノードに接続され、それは、そのノードへのルートメッセージをなければなりません。それ以外の場合は、ピアとkとの間隔である最大ノードIDを有するルーティングテーブル内のピアへのルートリクエストをする必要があります。そのようなノードが見つからない場合、ピアは、そのノードにメッセージKなければならず、ルートよりも大きい最小ノードIDを見つけます。"
    },
    {
      "indent": 0,
      "text": "10.4. Redundancy",
      "section_title": true,
      "ja": "10.4。冗長性"
    },
    {
      "indent": 3,
      "text": "When a peer receives a Store request for Resource-ID k and it is responsible for Resource-ID k, it MUST store the data and return a success response. It MUST then send a Store request to its successor in the Neighbor Table and to that peer's successor, incrementing the replica number for each successor. Note that these Store requests are addressed to those specific peers, even though the Resource-ID they are being asked to store is outside the range that they are responsible for. The peers receiving these SHOULD check that they came from an appropriate predecessor in their Neighbor Table and that they are in a range that this predecessor is responsible for. Then, they MUST store the data. They do not themselves perform further Stores, because they can determine that they are not responsible for the Resource-ID.",
      "ja": "ピアがリソース-ID kのストア要求を受信し、それが資源-ID kの責任がある場合は、データを保存し、成功応答を返さなければなりません。その後、各後継者のためのレプリカ番号をインクリメント、ネイバーテーブルにそのピアの後継者にその後継にストア要求を送らなければなりません。これらのストア要求は、彼らが店に求められているリソース-IDは、彼らが担当している範囲外であっても、それらの特定のピアに対処していることに注意してください。これらを受けたピアは、彼らが自分のネイバーテーブルに、彼らはこの前任者が担当する範囲内にあることを適切な前任者からのものであることを確認する必要があります。その後、彼らはデータを保存しなければなりません。彼らは資源-IDについては責任を負いませんことを確認することができますので、彼ら自身が、さらに店舗を実行しないでください。"
    },
    {
      "indent": 3,
      "text": "Note that this Topology Plug-in does not use the replica number for purposes other than knowing the difference between a replica and a non-replica.",
      "ja": "このトポロジプラグインは、レプリカと非レプリカの違いを知ること以外の目的でのレプリカ番号を使用していないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Managing replicas as the overlay changes is described in Section 10.7.3.",
      "ja": "オーバーレイの変更などの管理レプリカは、セクション10.7.3に記載されています。"
    },
    {
      "indent": 3,
      "text": "The sequential replicas used in this overlay algorithm protect against peer failure but not against malicious peers. Additional replication from the Usage is required to protect resources from such attacks, as discussed in Section 13.5.4.",
      "ja": "このオーバーレイアルゴリズムで使用されるシーケンシャルレプリカがピア障害に対してではなく、悪意のあるピアから守ります。セクション13.5.4で説明したように使用からの追加の複製は、このような攻撃からリソースを保護する必要があります。"
    },
    {
      "indent": 0,
      "text": "10.5. Joining",
      "section_title": true,
      "ja": "10.5。接合"
    },
    {
      "indent": 3,
      "text": "The join process for a Joining Node (JN) with Node-ID n is as follows:",
      "ja": "ノードID nに参加するノード（JN）のためのプロセスに参加以下の通りであります："
    },
    {
      "indent": 3,
      "text": "1. JN MUST connect to its chosen bootstrap node, as specified in Section 11.4.",
      "ja": "1. JNは、セクション11.4で指定されるように、その選択されたブートストラップ・ノードに接続する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. JN SHOULD send an Attach request to the Admitting Peer (AP) for Resource-ID n+1. The \"send_update\" flag can be used to acquire the Routing Table of AP.",
      "ja": "2. JNは、リソースID N + 1のために認めるピア（AP）に接続要求を送信すべきです。 「send_update」フラグは、APのルーティングテーブルを取得するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "3. JN SHOULD send Attach requests to initiate connections to each of the peers in the Neighbor Table as well as to the desired peers in the Finger Table. Note that this does not populate their Routing Tables, but only their Connection Tables, so JN will not get messages that it is expected to route to other nodes.",
      "ja": "3. JNは、ネイバーテーブル内のピアの各々に、ならびにフィンガーテーブル内の所望のピアへの接続を開始する要求を取り付け送ります。 JNは、それが他のノードへの経路に期待されているメッセージを取得することはできませんので、これは自分のルーティングテーブルが、唯一その接続テーブルを移入しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "4. JN MUST enter into its Routing Table all the peers that it has successfully contacted.",
      "ja": "4. JNは、そのルーティングテーブルにそれが正常に接触したことを、すべてのピアを入力する必要があります。"
    },
    {
      "indent": 3,
      "text": "5. JN MUST send a Join to AP. The AP MUST send the response to the Join.",
      "ja": "5. JNは、APへの参加を送らなければなりません。 APは、参加への応答を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "6. AP MUST do a series of Store requests to JN to store the data that JN will be responsible for.",
      "ja": "6. APはJNが担当となり、データを保存するためにJNにストア一連の要求を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "7. AP MUST send JN an Update explicitly labeling JN as its predecessor. At this point, JN is part of the ring and is responsible for a section of the overlay. AP MAY now forget any data which is assigned to JN and not AP. AP SHOULD NOT forget any data where AP is the replica set for the data.",
      "ja": "7. APはJNに明示的にその前身としてJNを標識するアップデートを送らなければなりません。この時点で、JNはリングの一部であり、オーバーレイのセクションを担当しています。 APは現在、JNはなくAPに割り当てられているすべてのデータを忘れる可能性。 APは、APがデータのレプリカセットで任意のデータを忘れてはなりません。"
    },
    {
      "indent": 3,
      "text": "8. The AP MUST send an Update to all of its neighbors (including JN) with the new values of its neighbor set (including JN).",
      "ja": "8. APは、（JN含む）その隣接セットの新しい値（JN含む）その隣人のすべてにアップデートを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "9. JN MUST send Updates to all of the peers in its Neighbor Table.",
      "section_title": true,
      "ja": "9. JNは、そのネイバーテーブル内のピアのすべての更新を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If JN sends an Attach to AP with send_update, it immediately knows most of its expected neighbors from AP's Routing Table update and MAY directly connect to them. This is the RECOMMENDED procedure.",
      "ja": "JNはsend_updateでAPへのアタッチを送信した場合、それはすぐにAPのルーティングテーブルの更新からその期待隣人のほとんどを知っているし、それらに直接接続することができます。これは推奨手順です。"
    },
    {
      "indent": 3,
      "text": "If for some reason JN does not get AP's Routing Table, it MAY still populate its Neighbor Table incrementally. It SHOULD send a Ping directed at Resource-ID n+1 (directly after its own Resource-ID). This allows JN to discover its own successor. Call that node p0. JN then SHOULD send a Ping to p0+1 to discover its successor (p1). This process MAY be repeated to discover as many successors as desired. The values for the two peers before p will be found at a later stage, when n receives an Update. An alternate procedure is to send Attaches to those nodes rather than Pings, which form the connections immediately, but may be slower if the nodes need to collect ICE candidates.",
      "ja": "何らかの理由でJNはAPのルーティングテーブルを取得していない場合、それはまだインクリメンタルそのネイバーテーブルを移入するかもしれません。これは、（直接、独自のリソース-ID後）リソース-ID N + 1に向けピングを送ります。これは、JNは、自身の後継者を発見することができます。そのノードP0を呼び出します。 JNは、その後継者（P1）を発見するために、P0 + 1へのPingを送信すべきです。このプロセスは、必要な数の後継者を発見するために繰り返してもよいです。 nが更新を受信したとき、P前の2つのピアの値は、後の段階で発見されます。別の手法はすぐに接続を形成するというよりピングそれらのノードにアタッチを送信するが、ノードはICE候補を収集する必要がある場合に遅くなることができます。"
    },
    {
      "indent": 3,
      "text": "In order to set up its i'th Finger Table entry, JN MUST send an Attach to peer n+2^(128-i). This will be routed to a peer in approximately the right location around the ring. (Note that the first entry in the Finger Table has i=1 and not i=0 in this formulation.)",
      "ja": "そのi番目のフィンガーテーブルエントリを設定するために、JNは、n + 2 ^（128-i）をピアにアタッチ送らなければなりません。これは、リングの周りに約右の場所でのピアにルーティングされます。 （フィンガーテーブルの最初のエントリは、この製剤中、I = 1としない、I = 0を有することに留意されたいです。）"
    },
    {
      "indent": 3,
      "text": "The Joining Node MUST NOT send any Update message placing itself in the overlay until it has successfully completed an Attach with each peer that should be in its Neighbor Table.",
      "ja": "それはそのネイバーテーブルにする必要があり、各ピアで接続し正常に完了するまで、参加するノードは、オーバーレイで自分自身を配置する任意のUpdateメッセージを送ってはいけません。"
    },
    {
      "indent": 0,
      "text": "10.6. Routing Attaches",
      "section_title": true,
      "ja": "10.6。ルーティングアタッチ"
    },
    {
      "indent": 3,
      "text": "When a peer needs to Attach to a new peer in its Neighbor Table, it MUST source-route the Attach request through the peer from which it learned the new peer's Node-ID. Source-routing these requests allows the overlay to recover from instability.",
      "ja": "ピアがネイバーテーブルに新しいピアにアタッチする必要がある場合、ソースルートをしなければならない、それは新しいピアのノードIDを学習したピアを通じて要求を取り付けます。ソースルーティングこれらの要求は、オーバーレイが不安定から回復することができます。"
    },
    {
      "indent": 3,
      "text": "All other Attach requests, such as those for new Finger Table entries, are routed conventionally through the overlay.",
      "ja": "他のすべては、このような新しいフィンガーテーブルエントリのものとの要求を、アタッチ、オーバーレイを通じて従来ルーティングされます。"
    },
    {
      "indent": 0,
      "text": "10.7. Updates",
      "section_title": true,
      "ja": "10.7。アップデート"
    },
    {
      "indent": 3,
      "text": "An Update for this DHT is defined as:",
      "ja": "このDHTの更新は、以下のように定義されています。"
    },
    {
      "indent": 8,
      "text": "enum { invalidChordUpdateType(0),\n       peer_ready(1), neighbors(2), full(3), (255) }\n     ChordUpdateType;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "struct {\n   uint32                 uptime;\n   ChordUpdateType        type;\n   select (type){\n    case peer_ready:                   /* Empty */\n      ;",
      "raw": true
    },
    {
      "indent": 12,
      "text": "case neighbors:\n  NodeId              predecessors<0..2^16-1>;\n  NodeId              successors<0..2^16-1>;",
      "raw": true
    },
    {
      "indent": 8,
      "text": "    case full:\n      NodeId              predecessors<0..2^16-1>;\n      NodeId              successors<0..2^16-1>;\n      NodeId              fingers<0..2^16-1>;\n  };\n} ChordUpdate;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"uptime\" field contains the time this peer has been up in seconds.",
      "ja": "「稼働時間」フィールドは、このピアが秒にアップしていた時間が含まれています。"
    },
    {
      "indent": 3,
      "text": "The \"type\" field contains the type of the update, which depends on the reason the update was sent.",
      "ja": "「タイプ」フィールドには、アップデートが送信された理由によって異なり、更新の種類が含まれています。"
    },
    {
      "indent": 3,
      "text": "peer_ready This peer is ready to receive messages. This message is used to indicate that a node which has Attached is a peer and can be routed through. It is also used as a connectivity check to non-neighbor peers.",
      "ja": "peer_readyこのピアは、メッセージを受信する準備ができています。このメッセージは、添付したノードがピアとを介してルーティングすることができることを示すために使用されます。また、非隣接ピアへの接続性チェックとして使用されています。"
    },
    {
      "indent": 3,
      "text": "neighbors This version is sent to members of the Chord Neighbor Table.",
      "ja": "隣人はこのバージョンでは、コード・ネイバーテーブルのメンバーに送信されます。"
    },
    {
      "indent": 3,
      "text": "full This version is sent to peers which request an Update with a RouteQueryReq.",
      "ja": "フルこのバージョンはRouteQueryReqで更新を要求するピアに送信されます。"
    },
    {
      "indent": 3,
      "text": "If the message is of type \"neighbors\", then the contents of the message will be:",
      "ja": "メッセージは、タイプ「隣人」である場合には、メッセージの内容は次のようになります。"
    },
    {
      "indent": 3,
      "text": "predecessors The predecessor set of the Updating peer.",
      "ja": "前任更新ピアの前身セット。"
    },
    {
      "indent": 3,
      "text": "successors The successor set of the Updating peer.",
      "ja": "後継更新ピアの後継セット。"
    },
    {
      "indent": 3,
      "text": "If the message is of type \"full\", then the contents of the message will be:",
      "ja": "メッセージは、「完全な」型である場合には、メッセージの内容は次のようになります。"
    },
    {
      "indent": 3,
      "text": "predecessors The predecessor set of the Updating peer.",
      "ja": "前任更新ピアの前身セット。"
    },
    {
      "indent": 3,
      "text": "successors The successor set of the Updating peer.",
      "ja": "後継更新ピアの後継セット。"
    },
    {
      "indent": 3,
      "text": "fingers The Finger Table of the Updating peer, in numerically ascending order.",
      "ja": "指数値的に昇順で更新ピアの指表、。"
    },
    {
      "indent": 3,
      "text": "A peer MUST maintain an association (via Attach) to every member of its neighbor set. A peer MUST attempt to maintain at least three predecessors and three successors, even though this will not be possible if the ring is very small. It is RECOMMENDED that O(log(N)) predecessors and successors be maintained in the neighbor set. There are many ways to estimate N, some of which are discussed in [DHT-RELOAD].",
      "ja": "ピアは、その隣接セットのすべてのメンバーに（経由アタッチ）アソシエーションを維持しなければなりません。ピアは、リングが非常に小さい場合、これはできませんにもかかわらず、少なくとも3人の前任者と後継者3を維持しようとしなければなりません。 O（ログ（N））前任者と後継者が近隣セット内に維持されることが推奨されます。 [DHTリロード]で議論されているいくつかのNを推定する多くの方法があります。"
    },
    {
      "indent": 0,
      "text": "10.7.1. Handling Neighbor Failures",
      "section_title": true,
      "ja": "10.7.1。近隣障害の処理"
    },
    {
      "indent": 3,
      "text": "Every time a connection to a peer in the Neighbor Table is lost (as determined by connectivity pings or the failure of some request), the peer MUST remove the entry from its Neighbor Table and replace it with the best match it has from the other peers in its Routing Table. If using reactive recovery, the peer MUST send an immediate Update to all nodes in its Neighbor Table. The update will contain all the Node-IDs of the current entries of the table (after the failed one has been removed). Note that when replacing a successor, the peer SHOULD delay the creation of new replicas for the successor replacement hold-down time (30 seconds) after removing the failed entry from its Neighbor Table in order to allow a triggered update to inform it of a better match for its Neighbor Table.",
      "ja": "（接続のpingまたはいくつかの要求の失敗によって決定される）ネイバーテーブル内のピアへの接続が失われるたびに、ピアはそのネイバーテーブルからエントリを削除し、それが他のピアから持っている最高の試合と交換する必要がありますそのルーティングテーブルインチ反応性の回復を使用している場合、ピアはそのネイバーテーブル内のすべてのノードへの即時更新を送らなければなりません。更新は、テーブルの現在のエントリすべてのNode-IDが含まれます（失敗した1が除去された後）。後継者を交換する際、ピアはトリガー更新が良いのそれを通知することを可能にするためにそのネイバーテーブルから失敗したエントリを削除した後に後継交換ホールドダウンタイム（30秒）のための新しいレプリカの作成を遅らせるべきであることに注意してくださいそのネイバーテーブルに一致します。"
    },
    {
      "indent": 3,
      "text": "If the neighbor failure affects the peer's range of responsible IDs, then the Update MUST be sent to all nodes in its Connection Table.",
      "ja": "隣人の失敗が責任IDのピアの範囲に影響を与えている場合、アップデートはその接続テーブル内のすべてのノードに送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "A peer MAY attempt to reestablish connectivity with a lost neighbor either by waiting additional time to see if connectivity returns or by actively routing a new Attach to the lost peer. Details for these procedures are beyond the scope of this document. In the case of an attempt to reestablish connectivity with a lost neighbor, the peer MUST be removed from the Neighbor Table. Such a peer is returned to the Neighbor Table once connectivity is reestablished.",
      "ja": "ピアは、失われた隣人のいずれかの接続が戻るか、積極的に失われたピアへのアタッチ新しいをルーティングすることによりかどうかを確認するための追加の時間を待って接続を再確立しようとすることができます。これらの手順の詳細は、このドキュメントの範囲を超えています。失われたネイバーとの接続を再確立しようとする試みの場合には、ピアは、ネイバーテーブルから除去されなければなりません。接続が再確立されると、このようなピアはネイバーテーブルに返されます。"
    },
    {
      "indent": 3,
      "text": "If connectivity is lost to all successor peers in the Neighbor Table, then this peer SHOULD behave as if it is joining the network and MUST use Pings to find a peer and send it a Join. If connectivity is lost to all the peers in the Finger Table, this peer SHOULD assume that it has been disconnected from the rest of the network, and it SHOULD periodically try to join the DHT.",
      "ja": "接続がネイバーテーブル内のすべての後継者ピアに失われた場合、このピアは、それがネットワークに参加しているかのように振る舞うべきとピアを見つけて参加し、それを送信するためにpingを使用しなければなりません。接続が指表内のすべてのピアに失われた場合、このピアは、それが残りのネットワークから切断されていると仮定すべきで、それが定期的にDHTに参加してみてください。"
    },
    {
      "indent": 0,
      "text": "10.7.2. Handling Finger Table Entry Failure",
      "section_title": true,
      "ja": "10.7.2。フィンガーテーブルエントリの失敗の取り扱い"
    },
    {
      "indent": 3,
      "text": "If a Finger Table entry is found to have failed (as determined by connectivity pings or the failure of some request), all references to the failed peer MUST be removed from the Finger Table and replaced with the closest preceding peer from the Finger Table or Neighbor Table.",
      "ja": "フィンガーテーブルエントリが（接続のpingまたはいくつかの要求の失敗によって決定されるように）失敗したと判明した場合、失敗したピアへのすべての参照は、フィンガーテーブルから削除し、最も近い先行フィンガーテーブルからピアまたは近隣に置き換える必要がありますテーブル。"
    },
    {
      "indent": 3,
      "text": "If using reactive recovery, the peer MUST initiate a search for a new Finger Table entry, as described below.",
      "ja": "反応性の回復を使用している場合は、以下に説明するように、ピアは、新しいフィンガーテーブルエントリの検索を開始しなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.7.3. Receiving Updates",
      "section_title": true,
      "ja": "10.7.3。更新を受け取ります"
    },
    {
      "indent": 3,
      "text": "When a peer x receives an Update request, it examines the Node-IDs in the UpdateReq and at its Neighbor Table and decides if this UpdateReq would change its Neighbor Table. This is done by taking the set of peers currently in the Neighbor Table and comparing them to the peers in the Update request. There are two major cases:",
      "ja": "ピアxが更新要求を受信すると、それはUpdateReqに、そのネイバーテーブルにノードIDを調べ、このUpdateReqそのネイバーテーブルを変更するかどうかを決定します。これは、ネイバーテーブルに、現在のピアのセットを取り、更新要求にピアにそれらを比較することによって行われます。二つの主要なケースがあります。"
    },
    {
      "indent": 3,
      "text": "o The UpdateReq contains peers that match x's Neighbor Table, so no change is needed to the neighbor set.",
      "ja": "UpdateReq oをそう何の変化が隣接セットに必要とされていない、ピアに一致するXのネイバーテーブルが含まれています。"
    },
    {
      "indent": 3,
      "text": "o The UpdateReq contains peers that x does not know about that should be in x's Neighbor Table; i.e., they are closer than entries in the Neighbor Table.",
      "ja": "UpdateReq oをxがそれについて知っていないことをピアがXのネイバーテーブルに含まれていなければなりません。すなわち、それらは、ネイバーテーブル内のエントリよりも近いです。"
    },
    {
      "indent": 3,
      "text": "In the first case, no change is needed.",
      "ja": "最初のケースでは、変更は必要ありません。"
    },
    {
      "indent": 3,
      "text": "In the second case, x MUST attempt to Attach to the new peers, and if it is successful, it MUST adjust its neighbor set accordingly. Note that x can maintain the now inferior peers as neighbors, but it MUST remember the closer ones.",
      "ja": "後者の場合、xは新しいピアにアタッチしようとしなければならない、そしてそれが成功した場合、それはその隣人がそれに応じて設定を調整しなければなりません。 xは隣人として今劣るピアを維持できることに注意してください、それが近いものを覚えておく必要があります。"
    },
    {
      "indent": 3,
      "text": "After any Pings and Attaches are done, if the Neighbor Table changes and the peer is using reactive recovery, the peer MUST send an Update request to each member of its Connection Table. These Update requests are what end up filling in the predecessor/successor tables of peers that this peer is a neighbor to. A peer MUST NOT enter itself in its successor or predecessor table and instead should leave the entries empty.",
      "ja": "任意ピング及び付着が行われた後ネイバーテーブルの変更及びピアが、反応性の回復を使用している場合、ピアは、接続テーブルの各メンバーに更新要求を送信しなければなりません。これらの更新要求は、このピアがネイバーがあることが、ピアの前身/後継テーブルを埋め終わるものです。ピアは、その後継者や前身のテーブルで自分自身を入力してはならないし、代わりに空のエントリを残す必要があります。"
    },
    {
      "indent": 3,
      "text": "If peer x is responsible for a Resource-ID R and x discovers that the replica set for R (the next two nodes in its successor set) has changed, it MUST send a Store for any data associated with R to any new node in the replica set. It SHOULD NOT delete data from peers which have left the replica set.",
      "ja": "ピアxがリソース-IDのRの責任であり、xはR（その後継セット内の次の二つのノード）に設定されたレプリカが変更されたことを検出した場合、それは任意の新しいノードにRに関連する任意のデータのためのストアを送らなければなりませんレプリカセット。これは、レプリカセットを残してきたピアからデータを削除しないでください。"
    },
    {
      "indent": 3,
      "text": "When peer x detects that it is no longer in the replica set for a resource R (i.e., there are three predecessors between x and R), it SHOULD delete all data associated with R from its local store.",
      "ja": "ピアXは、それがリソースRのためのレプリカセットにもはやであることを検出しない場合（すなわち、XとRの間に3つの先行がある）は、そのローカルストアからRに関連するすべてのデータを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a peer discovers that its range of responsible IDs has changed, it MUST send an Update to all entries in its Connection Table.",
      "ja": "ピアが責任IDのその範囲が変更されたことを検出すると、その接続テーブル内のすべてのエントリへの更新を送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.7.4. Stabilization",
      "section_title": true,
      "ja": "10.7.4。安定"
    },
    {
      "indent": 3,
      "text": "There are four components to stabilization:",
      "ja": "安定化の4つのコンポーネントがあります。"
    },
    {
      "indent": 3,
      "text": "1. Exchange Updates with all peers in its Neighbor Table to exchange state.",
      "ja": "そのネイバーテーブル内のすべてのピアと1交流更新が状態を交換します。"
    },
    {
      "indent": 3,
      "text": "2. Search for better peers to place in its Finger Table.",
      "section_title": true,
      "ja": "その指表に配置するより良いピア2.検索。"
    },
    {
      "indent": 3,
      "text": "3. Search to determine if the current Finger Table size is sufficiently large.",
      "ja": "現在のフィンガーテーブルのサイズが十分に大きいかどうかを決定する3.検索。"
    },
    {
      "indent": 3,
      "text": "4. Search to determine if the overlay has partitioned and needs to recover.",
      "ja": "オーバーレイが分割して回復する必要がありましたかどうかを判断する4.検索。"
    },
    {
      "indent": 0,
      "text": "10.7.4.1. Updating the Neighbor Table",
      "section_title": true,
      "ja": "10.7.4.1。ネイバーテーブルを更新します"
    },
    {
      "indent": 3,
      "text": "A peer MUST periodically send an Update request to every peer in its Neighbor Table. The purpose of this is to keep the predecessor and successor lists up to date and to detect failed peers. The default time is about every ten minutes, but the configuration server SHOULD set this in the Configuration Document using the \"chord-update-interval\" element (denominated in seconds). A peer SHOULD randomly offset these Update requests so they do not occur all at once.",
      "ja": "ピアは、定期的にそのネイバーテーブル内のすべてのピアへの更新要求を送らなければなりません。この目的は、前任者と後継最新のリストを維持するために、失敗したピアを検出することです。デフォルトの時間は約10分ごとですが、コンフィギュレーションサーバは、（秒建て）「和音更新間隔」要素を使用して設定文書でこれを設定すべきです。彼らは一度にすべてを発生しないので、ピアはランダムにこれらのアップデート要求を相殺すべきです。"
    },
    {
      "indent": 0,
      "text": "10.7.4.2. Refreshing the Finger Table",
      "section_title": true,
      "ja": "10.7.4.2。指表を更新"
    },
    {
      "indent": 3,
      "text": "A peer MUST periodically search for new peers to replace invalid entries in the Finger Table. For peer x, the i'th Finger Table entry is valid if it is in the range [ x+2^( 128-i ), x+2^( 128-(i-1) )-1 ]. Invalid entries occur in the Finger Table when a previous Finger Table entry has failed or when no peer has been found in that range.",
      "ja": "ピアは定期的に指表に無効なエントリを置き換えるために、新しい仲間を探さなければなりません。それが範囲内にある場合、ピアXは、i番目のフィンガーテーブルエントリが有効である[X + 2 ^（128-I）中、X + 2 ^（128（I-1））-1]。以前のフィンガーテーブルエントリが失敗した場合、または全くピアがその範囲内に見つかりませんでしたときに無効なエントリは、フィンガーテーブルにおいて生じます。"
    },
    {
      "indent": 3,
      "text": "Two possible methods for searching for new peers for the Finger Table entries are presented:",
      "ja": "フィンガーテーブルエントリのための新たなピアを検索するための2つの方法が提示されています。"
    },
    {
      "indent": 3,
      "text": "Alternative 1: A peer selects one entry in the Finger Table from among the invalid entries. It pings for a new peer for that Finger Table entry. The selection SHOULD be exponentially weighted to attempt to replace earlier (lower i) entries in the Finger Table. A simple way to implement this selection is to search through the Finger Table entries from i=1, and each time an invalid entry is encountered, send a Ping to replace that entry with probability 0.5.",
      "ja": "1代替：ピアが無効なエントリの中からフィンガーテーブル内の1つのエントリを選択します。これは、そのフィンガーテーブルエントリのための新しいピアのためにpingします。選択は、指数関数的に指表に以前（下I）のエントリを交換しようとして重み付けされるべきである（SHOULD）。この選択を実装するための簡単な方法は、I = 1からフィンガーテーブルエントリを検索することで、無効なエントリが検出されるたびに、確率0.5でそのエントリを交換するには、pingを送信します。"
    },
    {
      "indent": 3,
      "text": "Alternative 2: A peer monitors the Update messages received from its connections to observe when an Update indicates a peer that would be used to replace an invalid Finger Table entry, i, and flags that entry in the Finger Table. Every \"chord-ping-interval\" seconds, the peer selects from among those flagged candidates using an exponentially weighted probability, as above.",
      "ja": "2代替：更新が無効フィンガーテーブルエントリ、I、およびフラグフィンガーテーブル内のエントリを置き換えるために使用されるピアを示している場合、ピアが観察するその接続から受信した更新メッセージを監視します。すべての「弦のping間隔」秒、ピアは上記のように、指数関数的に重み付けされた確率を使用して候補者をフラグが立てられたものの中から選択します。"
    },
    {
      "indent": 3,
      "text": "When searching for a better entry, the peer SHOULD send the Ping to a Node-ID selected randomly from that range. Random selection is preferred over a search for strictly spaced entries to minimize the effect of churn on overlay routing [minimizing-churn-sigcomm06]. An implementation or subsequent specification MAY choose a method for selecting Finger Table entries other than choosing randomly within the range. Any such alternate methods SHOULD be employed only on Finger Table stabilization and not for the selection of initial Finger Table entries unless the alternative method is faster and imposes less overhead on the overlay.",
      "ja": "より良好なエントリを検索する場合、ピアは、その範囲からランダムに選択されたノードIDに対するpingを送信すべきです。ランダム選択は、[最小限 - チャーン -  sigcomm06]オーバーレイルーティングに解約の影響を最小限にするために、厳密に離間エントリを検索するよりも好ましいです。実装またはその後の仕様の範囲内でランダムに選択する以外のフィンガーテーブルエントリを選択する方法を選択することができます。別の方法は、高速で、オーバーレイ上のより少ないオーバーヘッドを課すしない限り、任意のそのような代替的な方法は、フィンガーテーブル安定ではなく、最初のフィンガーテーブルエントリの選択のために使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "A peer SHOULD NOT send Ping requests looking for new finger table entries more often than the configuration element \"chord-ping-interval\", which defaults to 3600 seconds (one per hour).",
      "ja": "ピアは、Pingのがより頻繁にされ、3600秒（1時間に1）デフォルトの設定要素「弦のping間隔」、より新しいフィンガーテーブルのエントリを探していたリクエスト送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "A peer MAY choose to keep connections to multiple peers that can act for a given Finger Table entry.",
      "ja": "ピアは、与えられたフィンガーテーブルエントリのために行動することができます複数のピアへの接続を維持するために選ぶかもしれません。"
    },
    {
      "indent": 0,
      "text": "10.7.4.3. Adjusting Finger Table Size",
      "section_title": true,
      "ja": "10.7.4.3。フィンガーテーブルサイズの調整"
    },
    {
      "indent": 3,
      "text": "If the Finger Table has fewer than 16 entries, the node SHOULD attempt to discover more fingers to grow the size of the table to 16. The value 16 was chosen to ensure high odds of a node maintaining connectivity to the overlay even with strange network partitions.",
      "ja": "指表が16個の未満のエントリがある場合は、ノードは16に値16を、テーブルのサイズを拡張するために複数の指を発見しようとすべきであるにも奇妙なネットワークパーティションでオーバーレイへの接続を維持したノードの高確率を確実にするために選ばれました。"
    },
    {
      "indent": 3,
      "text": "For many overlays, 16 Finger Table entries will be enough, but as an overlay grows very large, more than 16 entries may be required in the Finger Table for efficient routing. An implementation SHOULD be capable of increasing the number of entries in the Finger Table to 128 entries.",
      "ja": "多くのオーバーレイのために、16フィンガーテーブルエントリは十分であるが、オーバーレイが非常に大きくなるように、16のを超えるエントリは、効率的なルーティングのためのフィンガーテーブルにおいて必要とされてもよいです。実装は、128個のエントリにフィンガーテーブル内のエントリの数を増加させることができなければなりません。"
    },
    {
      "indent": 3,
      "text": "Although log(N) entries are all that are required for optimal performance, careful implementation of stabilization will result in no additional traffic being generated when maintaining a Finger Table larger than log(N) entries. Implementers are encouraged to make use of RouteQuery and algorithms for determining where new Finger Table entries may be found. Complete details of possible implementations are outside the scope of this specification.",
      "ja": "ログ（N）のエントリは、最適なパフォーマンスのために必要とされる全てであるが、安定化の慎重な実装は、エントリ（N）ログより大きいフィンガーテーブルを維持するときに生成されない追加のトラフィックをもたらすであろう。実装者は、新たなフィンガーテーブルエントリは見つけることができる場所を決定するためのRouteQueryとアルゴリズムを利用するように奨励されています。可能な実施形態の完全な詳細は、本明細書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "A simple approach to sizing the Finger Table is to ensure that the Finger Table is large enough to contain at least the final successor in the peer's Neighbor Table.",
      "ja": "指表サイジングへの単純なアプローチは、指の表は、ピアのネイバーテーブルに少なくとも最後の後継者を収容するのに十分な大きさであることを確認することです。"
    },
    {
      "indent": 0,
      "text": "10.7.4.4. Detecting Partitioning",
      "section_title": true,
      "ja": "10.7.4.4。パーティションを検出"
    },
    {
      "indent": 3,
      "text": "To detect that a partitioning has occurred and to heal the overlay, a peer P MUST periodically repeat the discovery process used in the initial join for the overlay to locate an appropriate bootstrap node, B. P SHOULD then send a Ping for its own Node-ID routed through B. If a response is received from peer S', which is not P's successor, then the overlay is partitioned and P SHOULD send an Attach to S' routed through B, followed by an Update sent to S'. (Note that S' may not be in P's Neighbor Table once the overlay is healed, but the connection will allow S' to discover appropriate neighbor entries for itself via its own stabilization.)",
      "ja": "パーティショニングが発生したことを検出すると、オーバーレイを癒すために、ピアPは、定期的に適切なブートストラップノードを検索するオーバーレイの参加最初に使用される発見プロセスを繰り返す必要があり、B. Pはその後、自身のノード - のためのPingを送信すべきです応答がピアSから受信した場合B.を介してルーティングID 'Pの後継者ではない、その後、オーバーレイが分配され、Pは、Sに取り付け送ります「Sに送られた更新を行い、Bを介してルーティング。 （つまり、Sなお、「オーバーレイが治癒されるとPのネイバーテーブルにないかもしれませんが、接続はSができるようになります」独自の安定化を介して、自分自身のための適切なネイバーエントリを発見します。）"
    },
    {
      "indent": 3,
      "text": "Future specifications may describe alternative mechanisms for determining when to repeat the discovery process.",
      "ja": "将来の仕様は、検出プロセスを繰り返すときを決定するための代替メカニズムを記述することができます。"
    },
    {
      "indent": 0,
      "text": "10.8. Route Query f.in 3",
      "section_title": true,
      "ja": "10.8。ルートクエリは、3 f.in"
    },
    {
      "indent": 7,
      "text": "For CHORD-RELOAD, the RouteQueryReq contains no additional\ninformation.  The RouteQueryAns contains the single Node-ID of\nthe next peer to which the responding peer would have routed the\nrequest message in recursive routing:",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct {\n   NodeId                  next_peer;\n} ChordRouteQueryAns;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The contents of this structure are as follows:",
      "ja": "次のようにこの構造体の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "next_peer The peer to which the responding peer would route the message in order to deliver it to the destination listed in the request.",
      "ja": "next_peerにピア応答するピアルート要求に記載されている宛先に配信するためにメッセージになります。"
    },
    {
      "indent": 3,
      "text": "If the requester has set the send_update flag, the responder SHOULD initiate an Update immediately after sending the RouteQueryAns.",
      "ja": "リクエスタがsend_updateフラグを設定している場合、応答者はすぐにRouteQueryAnsを送信した後、アップデートを開始すべきです。"
    },
    {
      "indent": 0,
      "text": "10.9. Leaving",
      "section_title": true,
      "ja": "10.9。退出"
    },
    {
      "indent": 3,
      "text": "To support extensions, such as [DHT-RELOAD], peers SHOULD send a Leave request to all members of their Neighbor Table before exiting the Overlay Instance. The overlay_specific_data field MUST contain the ChordLeaveData structure, defined below:",
      "ja": "こうした[DHT-RELOAD]などの拡張機能をサポートするために、ピアはオーバーレイのインスタンスを終了する前に自分のネイバーテーブルのすべてのメンバーに離脱要求を送るべきです。 overlay_specific_dataフィールドは、以下のように定義さ、ChordLeaveData構造を含まなければなりません："
    },
    {
      "indent": 14,
      "text": "enum { invalidChordLeaveType(0),\n        from_succ(1), from_pred(2), (255) }\n      ChordLeaveType;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "struct {\n  ChordLeaveType         type;",
      "raw": true
    },
    {
      "indent": 18,
      "text": "select (type) { case from_succ: NodeId successors<0..2^16-1>;",
      "ja": "（タイプ）{ケースfrom_succ選択：NODEID後継<0..2 ^ 16-1>。"
    },
    {
      "indent": 15,
      "text": "     case from_pred:\n       NodeId           predecessors<0..2^16-1>;\n   };\n} ChordLeaveData;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"type\" field indicates whether the Leave request was sent by a predecessor or a successor of the recipient:",
      "ja": "「タイプ」フィールドは、休暇要求が前身または受信者の後継者によって送信されたかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "from_succ The Leave request was sent by a successor.",
      "ja": "離脱要求from_succ後継者によって送信されました。"
    },
    {
      "indent": 3,
      "text": "from_pred The Leave request was sent by a predecessor.",
      "ja": "from_pred離脱要求は、前任者によって送信されました。"
    },
    {
      "indent": 3,
      "text": "If the type of the request is \"from_succ\", the contents will be:",
      "ja": "要求のタイプは「from_succ」である場合、その内容は次のようになります。"
    },
    {
      "indent": 3,
      "text": "successors The sender's successor list.",
      "ja": "送信者の後継者リストを後継者。"
    },
    {
      "indent": 3,
      "text": "If the type of the request is \"from_pred\", the contents will be:",
      "ja": "要求のタイプは「from_pred」である場合、その内容は次のようになります。"
    },
    {
      "indent": 3,
      "text": "predecessors The sender's predecessor list.",
      "ja": "送信者の前任者のリストを前任者。"
    },
    {
      "indent": 3,
      "text": "Any peer which receives a Leave for a peer n in its neighbor set MUST follow procedures as if it had detected a peer failure as described in Section 10.7.1.",
      "ja": "セクション10.7.1に記載されているように、それはピア障害を検出したかのようにその隣接セット内のピアnの脱退を受信する任意のピアは、手順に従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "11. Enrollment and Bootstrap",
      "section_title": true,
      "ja": "11.登録とブートストラップ"
    },
    {
      "indent": 3,
      "text": "The section defines the format of the configuration data as well the process to join a new overlay.",
      "ja": "セクションは、プロセスが新しいオーバーレイに参加するだけでなく、構成データのフォーマットを定義します。"
    },
    {
      "indent": 0,
      "text": "11.1. Overlay Configuration",
      "section_title": true,
      "ja": "11.1。オーバーレイの設定"
    },
    {
      "indent": 3,
      "text": "This specification defines a new content type \"application/p2p-overlay+xml\" for a MIME entity that contains overlay information. An example document is shown below:",
      "ja": "この仕様は、オーバーレイ情報が含まれているMIMEエンティティのための新しいコンテンツタイプ「アプリケーション/ P2Pオーバーレイ+ XML」を定義します。文書例を以下に示します。"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <overlay xmlns=\"urn:ietf:params:xml:ns:p2p:config-base\" xmlns:ext=\"urn:ietf:params:xml:ns:p2p:config-ext1\" xmlns:chord=\"urn:ietf:params:xml:ns:p2p:config-chord\"> <configuration instance-name=\"overlay.example.org\" sequence=\"22\" expiration=\"2002-10-10T07:00:00Z\" ext:ext-example=\"stuff\" > <topology-plugin> CHORD-RELOAD </topology-plugin> <node-id-length>16</node-id-length> <root-cert> MIIDJDCCAo2gAwIBAgIBADANBgkqhkiG9w0BAQUFADBwMQswCQYDVQQGEwJVUzET MBEGA1UECBMKQ2FsaWZvcm5pYTERMA8GA1UEBxMIU2FuIEpvc2UxDjAMBgNVBAoT BXNpcGl0MSkwJwYDVQQLEyBTaXBpdCBUZXN0IENlcnRpZmljYXRlIEF1dGhvcml0 eTAeFw0wMzA3MTgxMjIxNTJaFw0xMzA3MTUxMjIxNTJaMHAxCzAJBgNVBAYTAlVT MRMwEQYDVQQIEwpDYWxpZm9ybmlhMREwDwYDVQQHEwhTYW4gSm9zZTEOMAwGA1UE",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <オーバーレイのxmlns = \"壷：IETF：のparams：XML：NS：P2Pます。config-ベース\" のxmlns：EXT = \"壷：IETF：のparams：XML ：NS：P2P：CONFIG-EXT1\" のxmlns：コード= \"URN：IETF：paramsは：XML：NS：P2P：CONFIG-コード\"> <構成インスタンス名= \"overlay.example.org\" 配列= \"22\" 満了= \"2002-10-10T07：00：00Z\" EXT：EXT-例= \"もの\"> <トポロジ・プラグイン> CHORDリロード</トポロジ・プラグイン> <ノードID、長さ> 16 </ノードID-長さ> <ルート証明書> MIIDJDCCAo2gAwIBAgIBADANBgkqhkiG9w0BAQUFADBwMQswCQYDVQQGEwJVUzET MBEGA1UECBMKQ2FsaWZvcm5pYTERMA8GA1UEBxMIU2FuIEpvc2UxDjAMBgNVBAoT BXNpcGl0MSkwJwYDVQQLEyBTaXBpdCBUZXN0IENlcnRpZmljYXRlIEF1dGhvcml0 eTAeFw0wMzA3MTgxMjIxNTJaFw0xMzA3MTUxMjIxNTJaMHAxCzAJBgNVBAYTAlVT MRMwEQYDVQQIEwpDYWxpZm9ybmlhMREwDwYDVQQHEwhTYW4gSm9zZTEOMAwGA1UE"
    },
    {
      "indent": 3,
      "text": "ChMFc2lwaXQxKTAnBgNVBAsTIFNpcGl0IFRlc3QgQ2VydGlmaWNhdGUgQXV0aG9y aXR5MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDIh6DkcUDLDyK9BEUxkud +nJ4xrCVGKfgjHm6XaSuHiEtnfELHM+9WymzkBNzZpJu30yzsxwfKoIKugdNUrD4 N3viCicwcN35LgP/KnbN34cavXHr4ZlqxH+OdKB3hQTpQa38A7YXdaoz6goW2ft5 Mi74z03GNKP/G9BoKOGd5QIDAQABo4HNMIHKMB0GA1UdDgQWBBRrRhcU6pR2JYBU bhNU2qHjVBShtjCBmgYDVR0jBIGSMIGPgBRrRhcU6pR2JYBUbhNU2qHjVBShtqF0 pHIwcDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExETAPBgNVBAcT CFNhbiBKb3NlMQ4wDAYDVQQKEwVzaXBpdDEpMCcGA1UECxMgU2lwaXQgVGVzdCBD ZXJ0aWZpY2F0ZSBBdXRob3JpdHmCAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0B AQUFAAOBgQCWbRvv1ZGTRXxbH8/EqkdSCzSoUPrs+rQqR0xdQac9wNY/nlZbkR3O qAezG6Sfmklvf+DOg5RxQq/+Y6I03LRepc7KeVDpaplMFGnpfKsibETMipwzayNQ QgUf4cKBiF+65Ue7hZuDJa2EMv8qW4twEhGDYclpFU9YozyS1OhvUg== </root-cert> <root-cert> YmFkIGNlcnQK </root-cert> <enrollment-server>https://example.org</enrollment-server> <enrollment-server>https://example.net</enrollment-server> <self-signed-permitted digest=\"sha1\">false</self-signed-permitted> <bootstrap-node address=\"192.0.0.1\" port=\"6084\" /> <bootstrap-node address=\"192.0.2.2\" port=\"6084\" /> <bootstrap-node address=\"2001:DB8::1\" port=\"6084\" /> <turn-density> 20 </turn-density> <clients-permitted> false </clients-permitted> <no-ice> false </no-ice> <chord:chord-update-interval> 400</chord:chord-update-interval> <chord:chord-ping-interval>30</chord:chord-ping-interval> <chord:chord-reactive> true </chord:chord-reactive> <shared-secret> password </shared-secret> <max-message-size>4000</max-message-size> <initial-ttl> 30 </initial-ttl> <overlay-reliability-timer> 3000 </overlay-reliability-timer> <overlay-link-protocol>TLS</overlay-link-protocol> <configuration-signer>47112162e84c69ba</configuration-signer> <kind-signer> 47112162e84c69ba </kind-signer> <kind-signer> 6eba45d31a900c06 </kind-signer> <bad-node> 6ebc45d31a900c06 </bad-node> <bad-node> 6ebc45d31a900ca6 </bad-node>",
      "ja": "ChMFc2lwaXQxKTAnBgNVBAsTIFNpcGl0IFRlc3QgQ2VydGlmaWNhdGUgQXV0aG9y aXR5MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDIh6DkcUDLDyK9BEUxkud + nJ4xrCVGKfgjHm6XaSuHiEtnfELHM + 9WymzkBNzZpJu30yzsxwfKoIKugdNUrD4 N3viCicwcN35LgP / KnbN34cavXHr4ZlqxH + OdKB3hQTpQa38A7YXdaoz6goW2ft5 Mi74z03GNKP / G9BoKOGd5QIDAQABo4HNMIHKMB0GA1UdDgQWBBRrRhcU6pR2JYBU bhNU2qHjVBShtjCBmgYDVR0jBIGSMIGPgBRrRhcU6pR2JYBUbhNU2qHjVBShtqF0 pHIwcDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExETAPBgNVBAcT CFNhbiBKb3NlMQ4wDAYDVQQKEwVzaXBpdDEpMCcGA1UECxMgU2lwaXQgVGVzdCBD ZXJ0aWZpY2F0ZSBBdXRob3JpdHmCAQAwDAYDVR0TBAUwAwEB / zANBgkqhkiG9w0B AQUFAAOBgQCWbRvv1ZGTRXxbH8 / EqkdSCzSoUPrs + rQqR0xdQac9wNY / nlZbkR3O qAezG6Sfmklvf + DOg5RxQq / + Y6I03LRepc7KeVDpaplMFGnpfKsibETMipwzayNQ QgUf4cKBiF + 65Ue7hZuDJa2EMv8qW4twEhGDYclpFU9YozyS1OhvUg == </ルート証明書> <ルート証明書> YmFkIGNlcnQK </ルート証明書> <登録サーバ> https://example.org </登録サーバ> <登録サーバ> https://example.net </登録サーバ> <自己署名許可ダイジェスト= \"SHA1\">偽</自己署名-あたりmitted> <ブートストラップ・ノードアドレス= \"192.0.0.1\" ポート= \"6084\" /> <ブートストラップ・ノードアドレス= \"192.0.2.2\" ポート= \"6084\" /> <ブートストラップ・ノードアドレス= \"2001：DB8 :: 1\" ポート= \"6084\" /> <ターン密度> 20 </ターン密度> <クライアント許可>偽</クライアント許可> <無氷> <偽/無氷> <和音：chord-更新間隔> 400 </コード：コード更新間隔> <コード：コードのping間隔> 30 </コード：コードのping間隔> <コード：コード反応>真</コード：コード反応> <共有秘密>パスワード</共有秘密> <最大メッセージサイズ> 4000 </最大メッセージサイズ> <初期-TTL> 30 </初期-TTL> <オーバーレイ・信頼性・タイマー> 3000 < /オーバーレイ信頼性タイマー> <オーバーレイリンクプロトコル> TLS </オーバーレイリンクプロトコル> <構成-署名> 47112162e84c69ba </構成-署名> <種類-署名> 47112162e84c69ba </種類-署名> <kind-署名者> 6eba45d31a900c06 </種類-署名> <悪いノード> 6ebc45d31a900c06 </不良ノード> <悪いノード> 6ebc45d31a900ca6 </不良ノード>"
    },
    {
      "indent": 10,
      "text": "<ext:example-extension> foo </ext:example-extension>",
      "ja": "<EXT：例拡張> FOO </ EXT：たとえば、拡張>"
    },
    {
      "indent": 10,
      "text": "<mandatory-extension> urn:ietf:params:xml:ns:p2p:config-ext1 </mandatory-extension>",
      "ja": "<必須の拡張> URN：IETF：paramsは：XML：NS：P2P：CONFIG-EXT1 </必須の拡張>"
    },
    {
      "indent": 10,
      "text": "<required-kinds> <kind-block> <kind name=\"SIP-REGISTRATION\">",
      "ja": "<所要の種類> <種類のブロック> <種類名= \"SIP-REGISTRATION\">"
    },
    {
      "indent": 6,
      "text": " <data-model>SINGLE</data-model> <access-control>USER-MATCH</access-control> <max-count>1</max-count> <max-size>100</max-size> </kind> <kind-signature> VGhpcyBpcyBub3QgcmlnaHQhCg== </kind-signature> </kind-block> <kind-block> <kind id=\"2000\"> <data-model>ARRAY</data-model> <access-control>NODE-MULTIPLE</access-control> <max-node-multiple>3</max-node-multiple> <max-count>22</max-count> <max-size>4</max-size> <ext:example-kind-extension> 1 </ext:example-kind-extension> </kind> <kind-signature> VGhpcyBpcyBub3QgcmlnaHQhCg== </kind-signature> </kind-block> </required-kinds> </configuration> <signature> VGhpcyBpcyBub3QgcmlnaHQhCg== </signature>",
      "ja": "<データモデル>単一の</データモデル> <アクセス制御> USER-MATCH </アクセス制御> <MAX-カウント> 1 </最大カウント> <最大サイズ> 100 </最大サイズ> </種類> <種類署名> VGhpcyBpcyBub3QgcmlnaHQhCg == </種類署名> </一種ブロック> <種類のブロック> <種類ID = \"2000\"> <データモデル> ARRAY </データモデル> <アクセス制御> NODE-複数の</アクセス制御> <MAX-ノード多> 3 </ MAX-ノード多重> <MAX-カウント> 22 </最大カウント> <最大サイズ> 4 </最大-size> <EXT：例種延長> 1 </ EXT：例種延長> </種類> <種類署名> VGhpcyBpcyBub3QgcmlnaHQhCg == </種類署名> </一種ブロック> </必要-kinds> </構成> <署名> VGhpcyBpcyBub3QgcmlnaHQhCg == </署名>"
    },
    {
      "indent": 6,
      "text": "<configuration instance-name=\"other.example.net\"> </configuration> <signature> VGhpcyBpcyBub3QgcmlnaHQhCg== </signature>",
      "ja": "<構成インスタンス名= \"other.example.net\"> </構成> <署名> VGhpcyBpcyBub3QgcmlnaHQhCg == </署名>"
    },
    {
      "indent": 4,
      "text": "</overlay>",
      "ja": "</オーバーレイ>"
    },
    {
      "indent": 3,
      "text": "The file MUST be a well-formed XML document, and it SHOULD contain an encoding declaration in the XML declaration. The file MUST use the UTF-8 character encoding. The namespaces for the elements defined in this specification are urn:ietf:params:xml:ns:p2p:config-base and urn:ietf:params:xml:ns:p2p:config-chord.",
      "ja": "ファイルは、整形式XML文書でなければなりません、そして、それはXML宣言にエンコーディング宣言を含むべきです。ファイルはUTF-8文字エンコーディングを使用しなければなりません。本明細書で定義された要素のためのネームスペースはURNである：IETF：paramsは：XML：NS：P2P：CONFIG-ベースとURN：IETF：paramsは：XML：NS：P2P：CONFIG-コード。"
    },
    {
      "indent": 3,
      "text": "Note that elements or attributes that are defined as type xsd:boolean in the RELAX NG schema (Section 11.1.1) have two lexical representations, \"1\" or \"true\" for the concept true, and \"0\" or \"false\" for the concept false. Whitespace and case processing follows the rules of [OASIS.relax_ng] and XML Schema Datatypes [W3C.REC-xmlschema-2-20041028].",
      "ja": "、RELAX NGスキーマ（セクション11.1.1）のboolean 2つの語彙表現を持っている「1」または「真」真の概念のために、「0」または「false」の場合：要素または属性型XSDとして定義されていることに注意してくださいコンセプトはfalse。空白とケース処理のルール[OASIS.relax_ng]及びXMLスキーマデータ型を次の[W3C.REC-XMLSCHEMA-2から20041028]。"
    },
    {
      "indent": 3,
      "text": "The file MAY contain multiple \"configuration\" elements, where each one contains the configuration information for a different overlay. Each configuration element MAY be followed by signature elements that provide a signature over the preceding configuration element. Each configuration element has the following attributes:",
      "ja": "ファイルには、それぞれが異なるオーバーレイの設定情報が含まれている複数の「設定」の要素を含んでいてもよいです。各構成要素は、前述の構成要素の上に署名を提供する署名要素が続いてもよいです。各構成要素は次の属性があります。"
    },
    {
      "indent": 3,
      "text": "instance-name The name of the overlay (referred to as \"overlay name\" in this specification)",
      "ja": "オーバーレイ（本明細書では「オーバーレイ名」という。）の名称をインスタンス名"
    },
    {
      "indent": 3,
      "text": "expiration Time in the future at which this overlay configuration is no longer valid. The node SHOULD retrieve a new copy of the configuration at a randomly selected time that is before the expiration time. Note that if the certificates expire before a new configuration is retried, the node will not be able to validate the configuration file. All times MUST conform to the Internet date/time format defined in [RFC3339] and be specified using UTC.",
      "ja": "将来的には有効期限はどの時にこのオーバーレイの設定が有効ではありません。ノードは、有効期限の前にあるランダムに選択された時点での構成の新しいコピーを取得する必要があります。新しい設定を再試行する前に、証明書の有効期限が切れた場合、ノードは、構成ファイルを検証することはできないことに注意してください。すべての回は、[RFC3339]で定義されたインターネットの日付/時刻形式に従わなければなりませんし、UTCを使用して指定します。"
    },
    {
      "indent": 3,
      "text": "sequence A monotonically increasing sequence number between 0 and 2^16-2.",
      "ja": "シーケンス0から2 ^ 16-2の間で単調に増加するシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "Inside each overlay element, the following elements can occur:",
      "ja": "各オーバーレイ要素の内部では、以下の要素が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "topology-plug-in This element defines the overlay algorithm being used. If missing, the default is \"CHORD-RELOAD\".",
      "ja": "トポロジ・プラグインこの要素は使用されているオーバーレイアルゴリズムを定義します。不足している場合は、デフォルトでは「CHORD-RELOAD」です。"
    },
    {
      "indent": 3,
      "text": "node-id-length This element contains the length of a NodeId (NodeIdLength), in bytes. This value MUST be between 16 (128 bits) and 20 (160 bits). If this element is not present, the default of 16 is used.",
      "ja": "ノードIDの長さは、この要素はバイト単位で、NODEID（NodeIdLength）の長さを含みます。この値は16（128ビット）および20（160ビット）の間でなければなりません。この要素が存在しない場合、16のデフォルトが使用されます。"
    },
    {
      "indent": 3,
      "text": "root-cert This element contains a base-64-encoded X.509v3 certificate that is a root trust anchor used to sign all certificates in this overlay. There can be more than one root-cert element.",
      "ja": "この要素をルート証明書ルートトラストアンカーは、このオーバーレイですべての証明書に署名するために使用されたBase 64エンコードX.509v3証明書が含まれています。複数のルート証明書の要素が存在する場合があります。"
    },
    {
      "indent": 3,
      "text": "enrollment-server This element contains the URL at which the enrollment server can be reached in a \"url\" element. This URL MUST be of type \"https:\". More than one enrollment-server element MAY be present. Note that there is no necessary relationship between the overlay name/ configuration server name and the enrollment server name.",
      "ja": "登録サーバは、この要素は、登録サーバは、「URL」要素に到達可能なURLが含まれています。このURLは型でなければなりません「HTTPS：」。複数の登録-server要素が存在してもよいです。オーバーレイ名/コンフィギュレーション・サーバ名と登録サーバ名の間には、必要な関係が存在しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "self-signed-permitted This element indicates whether self-signed certificates are permitted. If it is set to \"true\", then self-signed certificates are allowed, in which case the enrollment-server and root-cert elements MAY be absent. Otherwise, it SHOULD be absent, but MAY be set to \"false\". This element also contains an attribute \"digest\", which indicates the digest to be used to compute the Node-ID. Valid values for this parameter are \"sha1\" and \"sha256\", representing SHA-1 [RFC3174] and SHA-256 [RFC6234], respectively. Implementations MUST support both of these algorithms.",
      "ja": "自己署名許可この要素は、自己署名証明書が許可されているかどうかを示します。それが「真」に設定されている場合、自己署名証明書は、その場合には、登録サーバとルート証明書の要素が存在しなくてもよく、許可されています。それ以外の場合は不在である必要がありますが、「偽」に設定することができます。この要素はまた、ノードIDを計算するために使用されるダイジェストを示しており、「ダイジェスト」属性が含まれています。このパラメータの有効な値は、それぞれ、SHA-1 [RFC3174]及びSHA-256 [RFC6234]を表す \"SHA1\" および \"SHA256\" です。実装は、これらのアルゴリズムの両方をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "bootstrap-node This element represents the address of one of the bootstrap nodes. It has an attribute called \"address\" that represents the IP address (either IPv4 or IPv6, since they can be distinguished) and an optional attribute called \"port\" that represents the port and defaults to 6084. The IPv6 address is in typical hexadecimal form using standard period and colon separators as specified in [RFC5952]. More than one bootstrap-node element MAY be present.",
      "ja": "ブートストラップノードこの要素は、ブートストラップノードのいずれかのアドレスを表します。 （それらは区別することができるので、IPv4またはIPv6のいずれか）には、IPアドレスを示す「アドレス」と呼ばれる属性を有し、6084.ザIPv6アドレスのポートと既定値を表し、「ポート」と呼ばれるオプションの属性は、典型的な16進形式であります[RFC5952]で指定されるように、標準的な期間及び結腸セパレータを使用。複数のブートストラップノードの要素が存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "turn-density This element is a positive integer that represents the approximate reciprocal of density of nodes that can act as TURN servers. For example, if 5% of the nodes can act as TURN servers, this element would be set to 20. If it is not present, the default value is 1. If there are no TURN servers in the overlay, it is set to zero.",
      "ja": "ターン密度をこの要素は、TURNサーバとして機能できるノードの密度の近似逆数を表す正の整数です。ノードの5％TURNサーバとして機能することができる場合、それが存在しない場合、例えば、この要素は、オーバーレイにはTURNサーバが存在しない場合、デフォルト値は、それがゼロに設定されている、1で20に設定されます。"
    },
    {
      "indent": 3,
      "text": "clients-permitted This element represents whether clients are permitted or whether all nodes must be peers. If clients are permitted, the element MUST be set to \"true\" or be absent. If the nodes are not allowed to remain clients after the initial join, the element MUST be set to \"false\". There is currently no way for the overlay to enforce this.",
      "ja": "この要素は、クライアントが許可されるかどうか、またはすべてのノードがピアでなければならないか否かを示すクライアントが許可します。クライアントが許可されている場合は、要素が「真」に設定するか、または存在しないことがなければなりません。初期に参加した後、ノードがクライアントままに許可されていない場合は、要素が「偽」に設定しなければなりません。オーバーレイはこれを強制するための方法はありません。"
    },
    {
      "indent": 3,
      "text": "no-ice This element represents whether nodes are REQUIRED to use the \"No-ICE\" Overlay Link protocols in this overlay. If it is absent, it is treated as if it were set to \"false\".",
      "ja": "無氷は、この要素は、ノードは、このオーバーレイで「いいえ-ICE」オーバーレイ・リンク・プロトコルを使用する必要があるかどうかを表していません。それが存在しない場合は、それが「偽」に設定されているかのように扱われています。"
    },
    {
      "indent": 3,
      "text": "chord-update-interval The update frequency for the CHORD-RELOAD Topology Plug-in (see Section 10).",
      "ja": "コード更新間隔CHORDリロードトポロジプラグインの更新頻度（セクション10を参照）。"
    },
    {
      "indent": 3,
      "text": "chord-ping-interval The Ping frequency for the CHORD-RELOAD Topology Plug-in (see Section 10).",
      "ja": "和音のping間隔CHORD-RELOADトポロジプラグイン（セクション10を参照）のためのPingの頻度。"
    },
    {
      "indent": 3,
      "text": "chord-reactive Whether reactive recovery SHOULD be used for this overlay. It is set to \"true\" or \"false\". If missing, the default is \"true\" (see Section 10).",
      "ja": "和音反応性反応性回復は、このオーバーレイのために使用すべきかどうか。それは、「true」または「false」に設定されています。不足している場合は、デフォルトが「真」である（セクション10を参照）。"
    },
    {
      "indent": 3,
      "text": "shared-secret If shared secret mode is used, this element contains the shared secret. The security guarantee here is that any agent which is able to access the Configuration Document (presumably protected by some sort of HTTP access control or network topology) is able to recover the shared secret and hence join the overlay.",
      "ja": "共有秘密共有秘密モードを使用する場合は、この要素は、共有秘密が含まれています。ここでは、セキュリティの保証は（おそらくHTTPアクセス制御やネットワークトポロジのいくつかの並べ替えで保護）設定文書にアクセスすることができる任意の薬剤は、共有秘密を回復するので、オーバーレイに参加することが可能であることです。"
    },
    {
      "indent": 3,
      "text": "max-message-size Maximum size, in bytes, of any message in the overlay. If this value is not present, the default is 5000.",
      "ja": "最大メッセージサイズの最大サイズ（バイト単位）、オーバーレイ内の任意のメッセージ。この値が存在しない場合、デフォルトは5000です。"
    },
    {
      "indent": 3,
      "text": "initial-ttl Initial default TTL for messages (see Section 6.3.2). If this value is not present, the default is 100.",
      "ja": "メッセージのための初期-TTL初期のデフォルトTTL（セクション6.3.2を参照してください）。この値が存在しない場合、デフォルトは100です。"
    },
    {
      "indent": 3,
      "text": "overlay-reliability-timer Default value for the end-to-end retransmission timer for messages, in milliseconds. If not present, the default value is 3000. The value MUST be at least 200 milliseconds, which means the minimum time delay before dropping a link is 1000 milliseconds.",
      "ja": "ミリ秒単位でのメッセージのエンドツーエンド再送タイマー、のオーバーレイ・信頼性・タイマーのデフォルト値。存在しない場合、デフォルト値は3000である値は、リンクを削除する前に、最小の遅延時間が1000ミリ秒であることを意味している、少なくとも200ミリ秒でなければなりません。"
    },
    {
      "indent": 3,
      "text": "overlay-link-protocol Indicates a permissible overlay link protocol (see Section 6.6.1 for requirements for such protocols). An arbitrary number of these elements may appear. If none appear, then this implies the default value, \"TLS\", which refers to the use of TLS and DTLS. If one or more elements appear, then no default value applies.",
      "ja": "オーバーレイ・リンク・プロトコルは、（そのようなプロトコルのための要件については、6.6.1項を参照）、許容オーバーレイリンクプロトコルを示します。これらの要素の任意の数が表示されてもよいです。何も表示されない場合、これはTLSとDTLSの使用を意味するデフォルト値、「TLS」を、意味しています。一個の以上の要素が表示された場合は、デフォルト値は適用されません。"
    },
    {
      "indent": 3,
      "text": "kind-signer This contains a single Node-ID in hexadecimal and indicates that the certificate with this Node-ID is allowed to sign Kinds. Identifying kind-signer by Node-ID instead of certificate allows the use of short-lived certificates without constantly having to provide an updated configuration file.",
      "ja": "種類、署名者は、これは16進数で単一のノードIDが含まれており、このノードIDを持つ証明書は種類に署名するために許可されていることを示しています。代わりに、証明書のノードIDによって特定の種類、署名者は、常に更新された設定ファイルを提供することなく、短命の証明書を使用することができます。"
    },
    {
      "indent": 3,
      "text": "configuration-signer This contains a single Node-ID in hexadecimal and indicates that the certificate with this Node-ID is allowed to sign configurations for this instance-name. Identifying the signer by Node-ID instead of certificate allows the use of short-lived certificates without constantly having to provide an updated configuration file.",
      "ja": "構成、署名者は、これは16進数で単一のノードIDが含まれており、このノードIDを持つ証明書は、このインスタンス名の構成を署名するために許可されていることを示しています。代わりに、証明書のノードIDによって署名者を特定することは常に更新された設定ファイルを提供することなく、短命の証明書を使用することができます。"
    },
    {
      "indent": 3,
      "text": "bad-node This contains a single Node-ID in hexadecimal and indicates that the certificate with this Node-ID MUST NOT be considered valid. This allows certificate revocation. An arbitrary number of these elements can be provided. Note that because certificates may expire, bad-node entries need be present only for the lifetime of the certificate. Technically speaking, bad Node-IDs may be reused after their certificates have expired. The requirement for Node-IDs to be pseudorandomly generated gives this event a vanishing probability.",
      "ja": "悪いノードこれは16進数で、単一ノードIDが含まれており、このノードIDを持つ証明書が有効と見なされてはならないことを示しています。これは、証明書の失効を可能にします。これらの要素の任意の数を設けることができます。証明書の期限が切れる可能性があるため、不正なノードのエントリが唯一の証明書の有効期間のために存在する必要があります。その証明書の期限が切れた後に技術的に言えば、悪いノードIDは再利用してもよいです。疑似ランダムに生成されるノードIDの要件は、このイベントに消失確率を与えます。"
    },
    {
      "indent": 3,
      "text": "mandatory-extension This element contains the name of an XML namespace that a node joining the overlay MUST support. The presence of a mandatory-extension element does not require the extension to be used in the current configuration file, but can indicate that it may be used in the future. Note that the namespace is case-sensitive, as specified in Section 2.3 of [w3c-xml-namespaces]. More than one mandatory-extension element MAY be present.",
      "ja": "必須拡張この要素は、オーバーレイに参加するノードがサポートしなければならないXML名前空間の名前が含まれています。必須の伸長要素の存在は、現在の構成ファイルで使用される拡張を必要としないが、それは将来的に使用することができることを示すことができます。 [W3C-XML-名前空間]のセクション2.3で指定された名前空間は、大文字と小文字が区別されることに留意されたいです。複数の必須拡張要素が存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "Inside each configuration element, the required-kinds element MAY also occur. This element indicates the Kinds that members MUST support and contains multiple kind-block elements that each define a single Kind that MUST be supported by nodes in the overlay. Each kind-block consists of a single kind element and a kind-signature. The kind element defines the Kind. The kind-signature is the signature computed over the kind element.",
      "ja": "各構成要素の中では、必要な-種類の要素も発生することがあります。この要素は、メンバーがサポートしなければならないの種類を示し、各オーバーレイ内のノードによってサポートされなければならない一種類を定義する複数種類のブロック要素を含みます。各種類のブロックは、一種類の元素と種類署名から成ります。親切な要素は、種類を定義します。種類署名は、一種の元素に対して計算署名です。"
    },
    {
      "indent": 3,
      "text": "Each kind element has either an id attribute or a name attribute. The name attribute is a string representing the Kind (the name registered to IANA), while the id is an integer Kind-ID allocated out of private space.",
      "ja": "各種類の要素にはid属性やname属性のいずれかを持っています。 IDは整数種類-IDプライベート空間の外に割り当てられている間name属性は、種類（IANAに登録された名前）を表す文字列です。"
    },
    {
      "indent": 3,
      "text": "In addition, the kind element MUST contain the following elements:",
      "ja": "また、親切な要素は、以下の要素を含まなければなりません："
    },
    {
      "indent": 3,
      "text": "max-count The maximum number of values which members of the overlay must support.",
      "ja": "オーバーレイのメンバーがサポートしなければならない値の最大数を最大カウント。"
    },
    {
      "indent": 3,
      "text": "data-model The data model to be used.",
      "ja": "使用するデータ・モデルのデータモデル。"
    },
    {
      "indent": 3,
      "text": "max-size The maximum size of individual values.",
      "ja": "個々の値の最大サイズ最大サイズ。"
    },
    {
      "indent": 3,
      "text": "access-control The access control model to be used.",
      "ja": "使用するアクセス制御モデルをアクセス制御します。"
    },
    {
      "indent": 3,
      "text": "The kind element MAY also contain the following element:",
      "ja": "親切な要素は、次の要素が含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "max-node-multiple If the access control is NODE-MULTIPLE, this element MUST be included. This indicates the maximum value for the i counter. It MUST be an integer greater than 0.",
      "ja": "MAX-ノード多重アクセス制御はNODE-MULTIPLEの場合、この要素を含まなければなりません。これは私カウンタの最大値を示します。これは、0より大きい整数でなければなりません。"
    },
    {
      "indent": 3,
      "text": "All of the non-optional values MUST be provided. If the Kind is registered with IANA, the data-model and access-control elements MUST match those in the Kind registration, and clients MUST ignore them in favor of the IANA versions. Multiple kind-block elements MAY be present.",
      "ja": "非オプション値のすべてが提供されなければなりません。種類は、IANAに登録されている場合は、データ・モデルおよびアクセス制御要素は、種類登録のものと一致しなければならない、とクライアントは、IANAのバージョンの賛成でそれらを無視しなければなりません。複数種類のブロック要素が存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "The kind-block element also MUST contain a \"kind-signature\" element. This signature is computed across the kind element from the beginning of the first < of the kind element to the end of the last > of the kind element in the same way as the signature element described later in this section. kind-block elements MUST be signed by a node listed in the kind-signers block of the current configuration. Receivers MUST verify the signature prior to accepting a kind-block.",
      "ja": "種類ブロック要素は、「種類署名」要素を含まなければなりません。この署名は、このセクションで後述する署名要素と同様に、種類要素の最初の開始から<種類の要素の最後の最後に>一種要素を横切って計算されます。種類ブロック要素は、現在の構成の種類、署名者のブロックにリストされたノードによって署名されなければなりません。受信機は、従来品種ブロックを受け入れるに署名を検証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The configuration element MUST be treated as a binary blob that cannot be changed -- including any whitespace changes -- or the signature will break. The signature MUST be computed by taking each configuration element and starting from, and including, the first < at the start of <configuration> up to and including the > in </ configuration> and treating this as a binary blob that MUST be signed using the standard SecurityBlock defined in Section 6.3.4. The SecurityBlock MUST be base-64 encoded using the base64 alphabet from [RFC4648] and MUST be put in the signature element following the configuration object in the configuration file. Any configuration file MUST be signed by one of the configuration-signer elements from the previous extant configuration. Recipients MUST verify the signature prior to accepting the configuration file.",
      "ja": "空白の変更を含む -   - 構成要素を変更することはできないバイナリBLOBとして扱わなければならない、または署名が解除されます。署名は、各構成要素を取り、から出発し、そしてなど、最初の<まで<構成>の開始時を含む>に</構成>と使用して署名されなければならないバイナリブロブとしてこれを処理することによって計算されなければなりません6.3.4項で定義された標準SecurityBlock。 SecurityBlockは[RFC4648]からBASE64アルファベットを使用して、BASE64符号化されなければならないと、構成ファイル内の構成オブジェクト以下の署名要素に入れなければなりません。任意のコンフィギュレーション・ファイルは、前の現存構成からの構成、署名要素のいずれかによって署名されなければなりません。受信者は、従来の設定ファイルを受け入れるに署名を検証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a node receives a new configuration file, it MUST change its configuration to meet the new requirements. This may require the node to exit the DHT and rejoin. If a node is not capable of supporting the new requirements, it MUST exit the overlay. If some information about a particular Kind changes from what the node previously knew about the Kind (for example, the max size), the new information in the configuration files overrides any previously learned information. If any Kind data was signed by a node that is no longer allowed to sign Kinds, that Kind MUST be discarded along with any stored information of that Kind. Note that forcing an avalanche restart of the overlay with a configuration change that requires rejoining the overlay may result in serious performance problems, including total collapse of the network if configuration parameters are not properly considered. Such an event may be necessary in case of a compromised CA or similar problem, but for large overlays, it should be avoided in almost all circumstances.",
      "ja": "ノードは、新しい設定ファイルを受信すると、それは新しい要件を満たすために、その構成を変更する必要があります。これは、DHTを終了し、再参加するノードが必要な場合があります。ノードが新しい要件をサポートすることができない場合は、オーバーレイを終了する必要があります。ノードは、以前種類（例えば、最大サイズ）について知っていたから、特定の種類の変更に関するいくつかの情報場合は、コンフィギュレーションファイルに新しい情報が、以前に学習した情報を上書きします。あらゆる種類のデータがもはや種類の署名を許可されたノードによって署名された場合、その種類は、その種の任意の格納された情報と一緒に廃棄しなければなりません。設定パラメータが適切に考慮されていない場合は、オーバーレイを再結合すると、ネットワーク全体の崩壊を含め、深刻なパフォーマンスの問題をもたらす可能性が必要で、構成変更にオーバーレイの雪崩の再起動を強制することに注意してください。そのようなイベントが損なわCAまたは類似の問題が発生した場合に必要であるかもしれないが、大きなオーバーレイのために、それはほとんどすべての状況で避けるべきです。"
    },
    {
      "indent": 0,
      "text": "11.1.1. RELAX NG Grammar",
      "section_title": true,
      "ja": "11.1.1。 NG文法をRELAX"
    },
    {
      "indent": 3,
      "text": "The grammar for the configuration data is:",
      "ja": "コンフィギュレーション・データのための文法は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "namespace chord = \"urn:ietf:params:xml:ns:p2p:config-chord\" namespace local = \"\" default namespace p2pcf = \"urn:ietf:params:xml:ns:p2p:config-base\" namespace rng = \"http://relaxng.org/ns/structure/1.0\"",
      "ja": "名前空間和音= \"壷：IETF：のparams：XML：NS：P2Pます。config-和音\" 名前空間ローカル= \"\" デフォルトの名前空間p2pcf = \"壷：IETF：のparams：XML：NS：P2Pます。config-ベース\" の名前空間RNG = \" http://relaxng.org/ns/structure/1.0\""
    },
    {
      "indent": 3,
      "text": "anything = (element * { anything } | attribute * { text } | text)*",
      "ja": "何も=（要素* {何} |属性* {テキスト} |テキスト）*"
    },
    {
      "indent": 3,
      "text": "foreign-elements = element * - (p2pcf:* | local:* | chord:*) { anything }* foreign-attributes = attribute * - (p2pcf:*|local:*|chord:*) { text }* foreign-nodes = (foreign-attributes | foreign-elements)*",
      "ja": "外国要素=エレメント*  - （p2pcf：* |ローカル：* |和音：*）{何} *外国属性=属性*  - （p2pcf：* |ローカル：* |和音：*）{テキスト} * foreign-ノード=（外国属性|外国要素）*"
    },
    {
      "indent": 3,
      "text": "start = element p2pcf:overlay { overlay-element }",
      "ja": "=エレメントp2pcfを開始しますオーバーレイ{オーバーレイ要素}"
    },
    {
      "indent": 3,
      "text": "overlay-element &= element configuration { attribute instance-name { xsd:string }, attribute expiration { xsd:dateTime }?, attribute sequence { xsd:long }?, foreign-attributes*, parameter }+ overlay-element &= element signature { attribute algorithm { signature-algorithm-type }?, xsd:base64Binary }*",
      "ja": "オーバーレイ要素＆=素子の構成{インスタンス名{XSD属性：文字列を}、属性の有効期限{XSD：外国属性*長い}？、パラメータ：dateTimeの}？属性配列{XSD} +オーバーレイ要素＆=エレメント署名{属性アルゴリズム{署名アルゴリズムタイプ}？のxsd：base64Binaryの} *"
    },
    {
      "indent": 3,
      "text": "signature-algorithm-type |= \"rsa-sha1\" signature-algorithm-type |= xsd:string # signature alg extensions",
      "ja": "署名アルゴリズム型| = \"RSA-SHA1\" 署名アルゴリズム型| =のxsd：文字列＃署名ALG機能拡張"
    },
    {
      "indent": 3,
      "text": "parameter &= element topology-plugin { topology-plugin-type }? topology-plugin-type |= xsd:string # topo plugin extensions parameter &= element max-message-size { xsd:unsignedInt }? parameter &= element initial-ttl { xsd:int }? parameter &= element root-cert { xsd:base64Binary }* parameter &= element required-kinds { kind-block* }? parameter &= element enrollment-server { xsd:anyURI }* parameter &= element kind-signer { xsd:string }* parameter &= element configuration-signer { xsd:string }* parameter &= element bad-node { xsd:string }* parameter &= element no-ice { xsd:boolean }? parameter &= element shared-secret { xsd:string }? parameter &= element overlay-link-protocol { xsd:string }* parameter &= element clients-permitted { xsd:boolean }? parameter &= element turn-density { xsd:unsignedByte }? parameter &= element node-id-length { xsd:int }? parameter &= element mandatory-extension { xsd:string }* parameter &= foreign-elements*",
      "ja": "パラメーター＆=要素トポロジプラグイン{トポロジ・プラグインタイプ}？トポロジ・プラグイン型| =のxsd：文字列＃トポプラグイン拡張パラメータ＆=要素の最大メッセージサイズ{のxsd：unsignedInt型}？パラメーター＆=エレメント初期TTL {XSD：INT}？パラメーター＆=エレメントルート証明書{XSD：base64Binaryの} *パラメータ＆=エレメント所要種類{種類ブロック*}？パラメーター＆=エレメント登録サーバ{XSD：anyURIの} *パラメータ＆=要素の種類、署名者{XSD：文字列} *パラメータ＆=要素の構成、署名者{XSD：文字列} *パラメータ＆=エレメント悪いノード{XSD：列} *パラメータ＆=エレメント無氷{XSD：ブール}？パラメーター＆=エレメント共有秘密{XSD：文字列}？パラメーター＆=要素オーバーレイリンクプロトコル{XSD：文字列} *パラメータ＆=エレメントクライアント許可{XSD：ブール}？パラメーター＆=エレメントターン密度{XSD：なunsignedByte}？パラメーター＆=要素ノードID長{XSD：INT}？パラメーター＆=エレメント必須の拡張{XSD：文字列} *パラメータ＆=外国要素*"
    },
    {
      "indent": 3,
      "text": "parameter &= element self-signed-permitted { attribute digest { self-signed-digest-type }, xsd:boolean }? self-signed-digest-type |= \"sha1\" self-signed-digest-type |= xsd:string # signature digest extensions",
      "ja": "パラメーター＆=素子の自己署名許可は、{：ブール、{自己署名ダイジェスト型}ダイジェストXSD属性}？自己署名ダイジェスト型| =「SHA1」自己署名ダイジェスト型| =のxsd：文字列＃署名は、拡張をダイジェスト"
    },
    {
      "indent": 3,
      "text": "parameter &= element bootstrap-node { attribute address { xsd:string }, attribute port { xsd:int }? }*",
      "ja": "パラメーター＆=エレメントブートストラップノード{属性アドレス{XSD：INT}：文字列}、ポート{XSD属性？ } *"
    },
    {
      "indent": 3,
      "text": "kind-block = element kind-block { element kind { ( attribute name { kind-names } | attribute id { xsd:unsignedInt } ), kind-parameter } & element kind-signature { attribute algorithm { signature-algorithm-type }?, xsd:base64Binary }? }",
      "ja": "種類ブロック=エレメント種類ブロック{要素は一種{（}品種名{属性名|属性ID {XSD：unsignedInt型}）、種別パラメータ}＆素子種類署名{属性アルゴリズム{署名アルゴリズムタイプ}？ 、XSD：base64Binaryの}？ }"
    },
    {
      "indent": 3,
      "text": "kind-parameter &= element max-count { xsd:int } kind-parameter &= element max-size { xsd:int } kind-parameter &= element max-node-multiple { xsd:int }?",
      "ja": "種別パラメータ＆=エレメント最大カウント{XSD：INT}種類パラメータ＆=要素の最大サイズ{XSD：INT}種類パラメータ＆=エレメントMAX-ノード複数{XSD：INT}？"
    },
    {
      "indent": 3,
      "text": "kind-parameter &= element data-model { data-model-type } data-model-type |= \"SINGLE\" data-model-type |= \"ARRAY\" data-model-type |= \"DICTIONARY\" data-model-type |= xsd:string # data model extensions kind-parameter &= element access-control { access-control-type } access-control-type |= \"USER-MATCH\" access-control-type |= \"NODE-MATCH\" access-control-type |= \"USER-NODE-MATCH\" access-control-type |= \"NODE-MULTIPLE\" access-control-type |= xsd:string # access control extensions",
      "ja": "種別パラメータ＆=要素データモデル{データ機種}データモデル型| =「SINGLE」データモデル型| =「アレイ」データモデル型| =「辞書」データモデル - タイプ| =のxsd：文字列＃データモデルの拡張種類パラメータ＆=要素アクセス制御{アクセス制御型}アクセス制御型| = \"USER-MATCH\" アクセス制御型| = \"NODE-MATCH\"アクセス制御型| = \"USER-NODE-MATCH\" アクセス制御型| = \"NODE-複数の\" アクセス制御型| =のxsd：文字列＃アクセス制御の拡張"
    },
    {
      "indent": 3,
      "text": "kind-parameter &= foreign-elements*",
      "ja": "種類パラメータ＆=外国要素*"
    },
    {
      "indent": 3,
      "text": "kind-names |= \"TURN-SERVICE\" kind-names |= \"CERTIFICATE_BY_NODE\" kind-names |= \"CERTIFICATE_BY_USER\" kind-names |= xsd:string # kind extensions",
      "ja": "種類・名称| = \"TURN-SERVICE\" の種類・名称| = \"CERTIFICATE_BY_NODE\" 親切-名| = \"CERTIFICATE_BY_USER\" 親切-名| =のxsd：文字列＃1種類の拡張子"
    },
    {
      "indent": 3,
      "text": "# Chord specific parameters topology-plugin-type |= \"CHORD-RELOAD\" parameter &= element chord:chord-ping-interval { xsd:int }? parameter &= element chord:chord-update-interval { xsd:int }? parameter &= element chord:chord-reactive { xsd:boolean }?",
      "ja": "＃コード固有のパラメータ・トポロジー・プラグイン型| = \"CHORDリロード\" パラメータ＆=エレメントコード：コードのping間隔{XSD：INT}？パラメーター＆=エレメントコード：コード更新間隔{XSD：INT}？パラメーター＆=エレメントコード：コード反応{XSD：ブール}？"
    },
    {
      "indent": 0,
      "text": "11.2. Discovery through Configuration Server",
      "section_title": true,
      "ja": "11.2。コンフィギュレーション・サーバを通じて発見"
    },
    {
      "indent": 3,
      "text": "When a node first enrolls in a new overlay, it starts with a discovery process to find a configuration server.",
      "ja": "ノードは、最初に新しいオーバーレイに入学すると、それは構成サーバーを見つけるために、検出プロセスを開始します。"
    },
    {
      "indent": 3,
      "text": "The node MAY start by determining the overlay name. This value MUST be provided by the user or some other out-of-band provisioning mechanism. The out-of-band mechanism MAY also provide an optional URL for the configuration server. If a URL for the configuration server is not provided, the node MUST do a DNS SRV query using a Service name of \"reload-config\" and a protocol of TCP to find a configuration server and form the URL by appending a path of \"/.well-known/reload-config\" to the overlay name. This uses the \"well-known URI\" framework defined in [RFC5785]. For example, if the overlay name was example.com, the URL would be \"https://example.com/.well-known/reload-config\".",
      "ja": "ノードは、オーバーレイ名を決定することにより開始することができます。この値は、ユーザまたは他の何らかのアウトオブバンドプロビジョニングメカニズムによって提供されなければなりません。アウトオブバンドメカニズムは、コンフィギュレーションサーバ用のオプションのURLを提供することができます。コンフィギュレーションサーバのURLが提供されていない場合、ノードが構成サーバーを見つけ、/」のパスを追加することによって、URLを形成するために、「リロード-config設定を」のサービス名とTCPのプロトコルを使用してDNS SRVのクエリを実行しなければなりませんオーバーレイ名に/リロード-config設定を」.well知られています。これは[RFC5785]で定義された「よく知られているURI」フレームワークを使用します。オーバーレイ名がexample.comだった場合、URLは「https://example.com/.well-known/reload-config」になります。"
    },
    {
      "indent": 3,
      "text": "Once an address and URL for the configuration server are determined, the peer MUST form an HTTPS connection to that IP address. If an optional URL for the configuration server was provided, the certificate MUST match the domain name from the URL as described in [RFC2818]; otherwise, the certificate MUST match the overlay name as described in [RFC2818]. If the HTTPS certificates pass the name matching, the node MUST fetch a new copy of the configuration file. To do this, the peer performs a GET to the URL. The result of the HTTP GET is an XML configuration file described above. If the XML is not valid or the instance-name attribute of the overlay-element in the XML does not match the overlay name, this configurations file",
      "ja": "コンフィギュレーションサーバのアドレスやURLが決定されると、ピアはそのIPアドレスへのHTTPS接続を形成しなければなりません。コンフィギュレーション・サーバのための任意のURLが提供された場合、証明書は、[RFC2818]に記載されているようにURLからのドメイン名と一致しなければなりません。 [RFC2818]に記載されているようにそうでなければ、証明書は、オーバーレイ名と一致しなければなりません。 HTTPS証明書は、名前の一致を渡すと、ノードは、構成ファイルの新しいコピーを取得しなければなりません。これを行うには、ピアは、URLにGETを実行します。 HTTPのGETの結果は、上記のXML設定ファイルです。 XMLが有効ではありませんか、XMLでのオーバーレイ要素のインスタンス名属性がオーバーレイ名と一致しない、これはファイルを構成した場合"
    },
    {
      "indent": 3,
      "text": "SHOULD be discarded. Otherwise, the new configuration MUST replace any previously learned configuration file for this overlay.",
      "ja": "廃棄すべき。そうでない場合は、新しいコンフィギュレーションは、このオーバーレイの任意の以前に学んだ設定ファイルを置き換える必要があります。"
    },
    {
      "indent": 3,
      "text": "For overlays that do not use a configuration server, nodes MUST obtain the configuration information needed to join the overlay through some out-of-band approach, such as an XML configuration file sent over email.",
      "ja": "構成サーバーを使用しないオーバーレイの場合は、ノードは、電子メールを介して送信されるXML設定ファイルなどの一部のアウトオブバンドアプローチを通じて、オーバーレイに参加するために必要な設定情報を取得する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.3. Credentials",
      "section_title": true,
      "ja": "11.3。資格情報"
    },
    {
      "indent": 3,
      "text": "If the Configuration Document contains an enrollment-server element, credentials are REQUIRED to join the Overlay Instance. A peer which does not yet have credentials MUST contact the enrollment server to acquire them.",
      "ja": "設定文書が登録-server要素が含まれている場合、資格情報がオーバーレイインスタンスに参加するために必要とされています。まだ資格情報を持っていないピアは、それらを取得するために登録サーバに接続しなければなりません。"
    },
    {
      "indent": 3,
      "text": "RELOAD defines its own trivial certificate request protocol. We would have liked to have used an existing protocol, but were concerned about the implementation burden of even the simplest of those protocols, such as [RFC5272] and [RFC5273]. The objective was to have a protocol which could be easily implemented in a Web server which the operator did not control (e.g., in a hosted service) and which was compatible with the existing certificate-handling tooling as used with the Web certificate infrastructure. This means accepting bare PKCS#10 requests and returning a single bare X.509 certificate. Although the MIME types for these objects are defined, none of the existing protocols support exactly this model.",
      "ja": "RELOADは、独自の些細な証明書の要求のプロトコルを定義します。私たちは、既存のプロトコルを使用していると言っていますが、そのような[RFC5272]と[RFC5273]のように、これらのプロトコルの最も単純なの実装の負担を懸念しているだろう。目的は、容易に（ホスティングサービスで、例えば）オペレータは制御しなかったWebサーバに実装することができ、ウェブ証明書インフラストラクチャで使用されるように、既存の証明書ハンドリングツールと互換性があったプロトコルを持っていることでした。これは、裸のPKCS＃10の要求を受け入れ、単一の裸のX.509証明書を返すことを意味します。これらのオブジェクトのMIMEタイプが定義されていますが、既存のプロトコルのいずれもが、まさにこのモデルをサポートしていません。"
    },
    {
      "indent": 3,
      "text": "The certificate request protocol MUST be performed over HTTPS. The server certificate MUST match the overlay name as described in [RFC2818]. The request MUST be an HTTP POST with the parameters encoded as described in [RFC2388] and with the following properties:",
      "ja": "証明書要求プロトコルはHTTPS上で実行されなければなりません。 [RFC2818]に記載されているように、サーバ証明書は、オーバーレイ名と一致しなければなりません。要求は、[RFC2388]に、次のプロパティで説明したようにエンコードされたパラメータを持つHTTP POSTでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If authentication is required, there MUST be form parameters of \"password\" and \"username\" containing the user's account name and password in the clear (hence the need for HTTPS). The username and password strings MUST be UTF-8 strings compared as binary objects. Applications using RELOAD SHOULD define any needed string preparation as per [RFC4013] or its successor documents.",
      "ja": "認証が必要な場合は、O、「パスワード」およびクリア（HTTPS用故に必要）で、ユーザーのアカウント名とパスワードを含む「ユーザー名」の形式のパラメータがあるに違いありません。ユーザー名とパスワードの文字列はバイナリオブジェクトとして比較UTF-8文字列でなければなりません。 RELOADを使用するアプリケーションは、[RFC4013]やその後継文書ごとに、必要な文字列の準備を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If more than one Node-ID is required, there MUST be a form parameter of \"nodeids\" containing the number of Node-IDs required.",
      "ja": "複数のノードIDが必要な場合はO、必要なノードIDの数を含む「ノード識別子」の形式パラメータがなければなりません。"
    },
    {
      "indent": 3,
      "text": "o There MUST be a form parameter of \"csr\" with a content type of \"application/pkcs10\", as defined in [RFC2311], that contains the certificate signing request (CSR).",
      "ja": "[RFC2311]で定義されるように、O、「アプリケーション/ PKCS10」のコンテンツタイプの「CSR」のフォームパラメータが存在しなければならないことは、証明書署名要求（CSR）を含みます。"
    },
    {
      "indent": 3,
      "text": "o The Accept header MUST contain the type \"application/pkix-cert\", indicating the type that is expected in the response.",
      "ja": "O受け入れヘッダが応答して予想されるタイプを示す、タイプ「アプリケーション/ PKIX-CERT」を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The enrollment server MUST authenticate the request using the provided account name and password. The reason for using the RFC 2388 \"multipart/form-data\" encoding is so that the password parameter will not be encoded in the URL, to reduce the chance of accidental leakage of the password. If the authentication succeeds and the requested user name in the CSR is acceptable, the server MUST generate and return a certificate for the CSR in the \"csr\" parameter of the request. The SubjectAltName field in the certificate MUST contain the following values:",
      "ja": "登録サーバは、提供されたアカウント名とパスワードを使用して要求を認証しなければなりません。パスワードパラメータは、パスワードの偶発漏れの可能性を減らすために、URLにエンコードされないように、RFC 2388「マルチパート/フォームデータ」エンコーディングを使用する理由はあります。認証が成功し、CSRにおける要求されたユーザ名が許容される場合は、サーバが生成し、リクエストの「CSR」パラメータでCSRの証明書を返さなければなりません。証明書のSubjectAltNameフィールドには、次の値を含まなければなりません："
    },
    {
      "indent": 3,
      "text": "o One or more Node-IDs which MUST be cryptographically random [RFC4086]. Each MUST be chosen by the enrollment server in such a way that it is unpredictable to the requesting user. For example, the user MUST NOT be informed of potential (random) Node-IDs prior to authenticating. Each is placed in the subjectAltName using the uniformResourceIdentifier type, each MUST contain RELOAD URI, as described in Section 14.15, and each MUST contain a Destination List with a single entry of type \"node_id\". The enrollment server SHOULD maintain a mapping of users to Node-IDs and if the same user returns (e.g., to have their certificate re-issued), the enrollment server should return the same Node-IDs, thus avoiding the need for implementations to re-store all their data when their certificates expire.",
      "ja": "暗号ランダム[RFC4086]されなければならない1つまたは複数のノードIDは、O。それぞれは、それが要求しているユーザに予測不可能であるような方法で登録サーバによって選択されなければなりません。たとえば、ユーザーが認証する前に潜在的な（ランダム）ノードのIDを知らされてはなりません。各々がuniformResourceIdentifierでタイプを使用してのsubjectAltNameに配置され、セクション14.15に記載されているようにそれぞれが、リロードURIを含まなければなりません、そして各タイプの単一のエントリ「NODE_ID」と宛先リストを含まなければなりません。登録サーバーは-IDのノードへのユーザーのマッピングを維持する必要がありますし、同じユーザーが戻るが、（例えば、その証明書の再発行を持っている）場合、登録サーバーは、実装が再するため、必要性を回避、同じノードIDを返す必要があります-storeその証明書の有効期限が切れるすべてのデータ。"
    },
    {
      "indent": 3,
      "text": "o A single name (the \"user name\") that this user is allowed to use in the overlay, using type rfc822Name. Enrollment servers SHOULD take care to allow only legal characters in the name (e.g., no embedded NULs), rather than simply accepting any name provided by",
      "ja": "このユーザーがタイプrfc822Nameでを使用して、オーバーレイでの使用を許可されている単一の名前（「ユーザ名」）O。登録サーバは、単にが提供する任意の名前を受け入れるのではなく、名前でのみ有効な文字（例えば、埋め込まれていないNULs）を許可するように注意する必要があります"
    },
    {
      "indent": 6,
      "text": "the user. In some usages, the right side of the user name will match the overlay name, but there is no requirement for this match in this specification. Applications using this specification MAY define such a requirement or MAY otherwise limit the allowed range of allowed user names.",
      "ja": "ユーザー。いくつかの用途では、ユーザー名の右側には、オーバーレイ名と一致しますが、この仕様では、この試合のための必要はありません。この仕様を使用するアプリケーションは、このような要件を定義するか、またはそうでなければ許可されたユーザ名の許容範囲を制限することができます。"
    },
    {
      "indent": 3,
      "text": "The SubjectAltName field in the certificate MUST NOT contain any identities other than those listed above. The subject distinguished name in the certificate MUST be empty.",
      "ja": "証明書のSubjectAltNameフィールドには、上記以外のアイデンティティを含めることはできません。証明書のサブジェクト識別名は空でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The certificate MUST be returned as type \"application/pkix-cert\", as defined in [RFC2585], with an HTTP status code of 200 OK.",
      "ja": "[RFC2585]で定義されるように証明書が200 OKのHTTPステータスコードと、タイプ「アプリケーション/ PKIX-CERT」として返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Certificate processing errors SHOULD result in an HTTP return code of 403 Forbidden, along with a body of type \"text/plain\" and body that consists of one of the tokens defined in the following list:",
      "ja": "証明書処理エラーは、次のリストに定義されたトークンのいずれかから成るタイプのボディ「text / plainの」とボディと一緒に、禁断403のHTTPリターンコードをもたらすはずです。"
    },
    {
      "indent": 3,
      "text": "failed_authentication The account name and password combination used in the HTTPS request was not valid.",
      "ja": "HTTPSリクエストで使用したアカウント名とパスワードの組み合わせが有効ではありませんでしたfailed_authentication。"
    },
    {
      "indent": 3,
      "text": "username_not_available The requested user name in the CSR was not acceptable.",
      "ja": "CSRに要求されたユーザ名をusername_not_availableは受け入れませんでした。"
    },
    {
      "indent": 3,
      "text": "Node-IDs_not_available The number of Node-IDs requested was not acceptable.",
      "ja": "ノードIDの数は、要求されたノードIDs_not_availableは受け入れませんでした。"
    },
    {
      "indent": 3,
      "text": "bad_CSR There was some other problem with the CSR.",
      "ja": "bad_CSR CSRと他のいくつかの問題が発生しました。"
    },
    {
      "indent": 3,
      "text": "If the client receives an unknown token in the body, it SHOULD treat it as a failure for an unknown reason.",
      "ja": "クライアントが体内に不明なトークンを受信した場合、それが原因不明の障害として扱うべきです。"
    },
    {
      "indent": 3,
      "text": "The client MUST check that the returned certificate chains back to one of the certificates received in the \"root-cert\" list of the overlay configuration data (including PKIX BasicConstraints checks). The node then reads the certificate to find the Node-ID it can use.",
      "ja": "クライアントは、バック（PKIXの基本制約チェックを含む）オーバーレイ設定データの「ルート証明書」リストで受信した証明書のいずれかにその返された証明書チェーンをチェックしなければなりません。ノードは、それが使用できるノードIDを検索し、証明書を読み込みます。"
    },
    {
      "indent": 0,
      "text": "11.3.1. Self-Generated Credentials",
      "section_title": true,
      "ja": "11.3.1。自己生成の資格情報"
    },
    {
      "indent": 3,
      "text": "If the \"self-signed-permitted\" element is present in the configuration and is set to \"true\", then a node MUST generate its own self-signed certificate to join the overlay. The self-signed certificate MAY contain any user name of the user's choice.",
      "ja": "「自己署名許可」要素は、構成内に存在し、「真」に設定されている場合、ノードはオーバーレイに参加する独自の自己署名証明書を生成しなければなりません。自己署名証明書は、ユーザが選択した任意のユーザ名を含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "For self-signed certificates containing only one Node-ID, the Node-ID MUST be computed by applying the digest specified in the self-signed-permitted element to the DER representation of the user's public key (more specifically, the subjectPublicKeyInfo) and taking the high-order bits. For self-signed certificates containing multiple Node-IDs, the index of the Node-ID (from 1 to the number of Node-IDs needed) must be prepended as a 4-byte big-endian integer to the DER representation of the user's public key and taking the high-order bits. When accepting a self-signed certificate, nodes MUST check that the Node-ID and public keys match. This prevents Node-ID theft.",
      "ja": "唯一のノードIDを含む自己署名証明書のために、ノードIDは、ユーザの公開鍵（より具体的には、SubjectPublicKeyInfoで）のDER表現に自己署名許可要素で指定されたダイジェストを適用しとることによって計算されなければなりません上位ビット。複数のノードIDを含む自己署名証明書のために、ノードID（1から必要なノードIDの数まで）のインデックスは、ユーザの公開のDER表現に4バイトのビッグエンディアン整数として付加されなければなりませんキーと上位ビットを取ります。自己署名証明書を受け付けると、ノードは、ノードIDおよび公開鍵が一致していることを確認しなければなりません。これは、ノードIDの盗難を防止します。"
    },
    {
      "indent": 3,
      "text": "Once the node has constructed a self-signed certificate, it MAY join the overlay. It MUST store its certificate in the overlay (Section 8), but SHOULD look to see if the user name is already taken and, if so, choose another user name. Note that this provides protection only against accidental name collisions. Name theft is still possible. If protection against name theft is desired, then the enrollment service MUST be used.",
      "ja": "ノードは、自己署名証明書を作成したら、それはオーバーレイに参加することができます。これは、オーバーレイ（8節）にその証明書を保存しなければなりませんが、ユーザー名がすでに使用されているかどうかを確認して、そうであれば、別のユーザー名を選択することになります。これが唯一の偶然の名前の衝突に対する保護を提供することに注意してください。名前の盗難はまだ可能です。名前の盗難に対する保護を希望する場合には、登録サービスを使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.4. Contacting a Bootstrap Node",
      "section_title": true,
      "ja": "11.4。ブートストラップノードへの問い合わせ"
    },
    {
      "indent": 3,
      "text": "In order to join the overlay, the Joining Node MUST contact a node in the overlay. Typically this means contacting the bootstrap nodes, since they are reachable by the local peer or have public IP addresses. If the Joining Node has cached a list of peers that it has previously been connected with in this overlay, as an optimization it MAY attempt to use one or more of them as bootstrap nodes before falling back to the bootstrap nodes listed in the configuration file.",
      "ja": "オーバレイに参加するために、参加するノードは、オーバーレイ内のノードに連絡しなければなりません。彼らはローカルピアによって到達可能であるか、パブリックIPアドレスを持っているので、通常、これは、ブートストラップ・ノードを接触させることを意味します。参加ノードは、それ以前にこのオーバーレイにして接続されたことをピアのリストをキャッシュしている場合は、最適化としてはバックコンフィギュレーションファイルにリストされたブートストラップ・ノードに落ちる前に、ブートストラップ・ノードとしてそれらの一つ以上を使用しようとするかもしれません。"
    },
    {
      "indent": 3,
      "text": "When contacting a bootstrap node, the Joining Node MUST first form the DTLS or TLS connection to the bootstrap node and then send an Attach request over this connection with the destination Resource-ID set to the Joining Node's Node-ID plus 1.",
      "ja": "ブートストラップ・ノードに接触するとき、参加するノードは、最初のブートストラップノードにDTLSまたはTLS接続を形成した後、先リソース-IDを使用してこの接続を介してアタッチ要求を送信しなければならない参加するノードのノードIDプラス1に設定。"
    },
    {
      "indent": 3,
      "text": "When the requester node finally does receive a response from some responding node, it MUST use the Node-ID in the response to start sending requests to join the Overlay Instance as described in Section 6.4.",
      "ja": "要求ノードが最終的にいくつかの応答ノードからの応答を受信した場合、それは、6.4節で説明したようにオーバーレイインスタンスに参加するリクエストの送信を開始するために応答してノードIDを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "After a node has successfully joined the overlay network, it will have direct connections to several peers. Some MAY be added to the cached bootstrap nodes list and used in future boots. Peers that are not directly connected MUST NOT be cached. The suggested number of peers to cache is 10. Algorithms for determining which peers to cache are beyond the scope of this specification.",
      "ja": "ノードが正常にオーバーレイネットワークに参加した後、それはいくつかのピアへの直接接続を持っています。いくつかは、キャッシュされたブートストラップ・ノードのリストに追加され、将来のブーツに使用されるかもしれません。直接接続されていないピアは、キャッシュされてはなりません。キャッシュへのピアの提案数は、本明細書の範囲を超えてキャッシュするためにどのピアを決定するための10のアルゴリズムです。"
    },
    {
      "indent": 0,
      "text": "12. Message Flow Example",
      "section_title": true,
      "ja": "12.メッセージフロー例"
    },
    {
      "indent": 3,
      "text": "The following abbreviations are used in the message flow diagrams: JN = Joining Node, AP = Admitting Peer, NP = next peer after the AP, NNP = next next peer which is the peer after NP, PP = previous peer before the AP, PPP = previous previous peer which is the peer before the PP, BP = bootstrap node.",
      "ja": "以下の略語は、メッセージフロー図で使用されている：JN =ノードの参加、APはAP前NP、PP =前ピア後ピアであるAP、NNP =次の次のピア後ピア、NP =次のピアを認める= PPPは= PP、BP =ブートストラップノードの前にピアである前前ピア。"
    },
    {
      "indent": 3,
      "text": "In the following example, we assume that JN has formed a connection to one of the bootstrap nodes. JN then sends an Attach through that peer to a Resource-ID of itself plus 1 (JN+1). It gets routed to the AP, because JN is not yet part of the overlay. When AP responds, JN and the AP use ICE to set up a connection and then set up DTLS. Once AP has connected to JN, AP sends to JN an Update to populate its Routing Table. The following example shows the Update happening after the DTLS connection is formed, but it could also happen before, in which case the Update would often be routed through other nodes.",
      "ja": "次の例では、JNは、ブートストラップノードの一つへの接続を形成していると仮定する。 JNは、次いで、それ自体のリソース-IDプラス1（JN + 1）へのピアを介して接続し送信します。 JNはまだオーバーレイの一部ではないので、それは、APにルーティングされます。 APが応答すると、JNとAPは、接続を設定するためにICEを使用して、DTLSを設定します。 APはJNに接続したら、APは、そのルーティングテーブルを移入するアップデートをJNに送ります。次の例では、DTLS接続が形成された後の更新が起こって示しているが、また、アップデートは、多くの場合、他のノードを経由してルーティングされるであろう場合には、前に発生する可能性があります。"
    },
    {
      "indent": 7,
      "text": "JN        PPP       PP        AP        NP        NNP       BP\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |AttachReq Dest=JN+1|         |         |         |         |\n |---------------------------------------------------------->|\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |AttachReq Dest=JN+1|         |\n |         |         |         |<----------------------------|\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |AttachAns          |         |\n |         |         |         |---------------------------->|\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |AttachAns          |         |         |         |         |\n |<----------------------------------------------------------|\n |         |         |         |         |         |         |\n |ICE      |         |         |         |         |         |\n |<===========================>|         |         |         |\n |         |         |         |         |         |         |\n |TLS      |         |         |         |         |         |\n |<...........................>|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateReq|         |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateAns|         |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "The JN then forms connections to the appropriate neighbors, such as NP, by sending an Attach which gets routed via other nodes. When NP responds, JN and NP use ICE and DTLS to set up a connection.",
      "ja": "JNは、他のノードを介してルーティングされた添付を送信することによって、このようなNPのような適切な近隣への接続を形成します。 NPが応答すると、JN及びNPは、接続を設定するためにICEとDTLSを使用します。"
    },
    {
      "indent": 7,
      "text": "JN        PPP       PP        AP        NP        NNP       BP\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |AttachReq NP       |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |AttachReq NP       |         |\n |         |         |         |-------->|         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |AttachAns|         |         |\n |         |         |         |<--------|         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |AttachAns|         |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |ICE      |         |         |         |         |         |\n |<=====================================>|         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |TLS      |         |         |         |         |         |\n |<.....................................>|         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 3,
      "text": "The JN also needs to populate its Finger Table (for the Chord-based DHT). It issues an Attach to a variety of locations around the overlay. The diagram below shows JN sending an Attach halfway around the Chord ring to the JN + 2^127.",
      "ja": "JNは、（コードベースのDHTのために）、そのフィンガーテーブルを移入する必要があります。これは、オーバーレイ各地のさまざまな取り付けを発行します。以下の図は、JN + 2 ^ 127 JNにChordリングの周りに半添付の送信を示しています。"
    },
    {
      "indent": 7,
      "text": "JN        NP        XX        TP\n |         |         |         |\n |         |         |         |\n |         |         |         |\n |AttachReq JN+2<<126|         |\n |-------->|         |         |\n |         |         |         |\n |         |         |         |\n |         |AttachReq JN+2<<126|\n |         |-------->|         |\n |         |         |         |\n |         |         |         |\n |         |         |AttachReq JN+2<<126\n |         |         |-------->|\n |         |         |         |\n |         |         |         |\n |         |         |AttachAns|\n |         |         |<--------|\n |         |         |         |\n |         |         |         |\n |         |AttachAns|         |\n |         |<--------|         |\n |         |         |         |\n |         |         |         |\n |AttachAns|         |         |\n |<--------|         |         |\n |         |         |         |\n |ICE      |         |         |\n |<===========================>|\n |         |         |         |\n |TLS      |         |         |\n |<...........................>|\n |         |         |         |\n |         |         |         |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 3,
      "text": "Once JN has a reasonable set of connections, it is ready to take its place in the DHT. It does this by sending a Join to AP. AP sends a series of Store requests to JN to store the data that JN will be responsible for. AP then sends JN an Update that explicitly labels JN as its predecessor. At this point, JN is part of the ring and is responsible for a section of the overlay. AP can now forget any data which is assigned to JN and not to AP.",
      "ja": "JNは、接続の合理的なセットを持っていたら、DHTでその場所を取る準備ができています。これは、APへの参加を送信することでこれを行います。 APは、JNはを担当するデータを格納するためのJNにストア一連の要求を送信します。 APは、JN明示的にその前身としてJNのラベルの更新を送信します。この時点で、JNはリングの一部であり、オーバーレイのセクションを担当しています。 APは現在、JNにしていないAPに割り当てられているすべてのデータを忘れることができます。"
    },
    {
      "indent": 7,
      "text": "JN        PPP       PP        AP        NP        NNP       BP\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |JoinReq  |         |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |JoinAns  |         |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |StoreReq Data A    |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |StoreAns |         |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |StoreReq Data B    |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |StoreAns |         |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateReq|         |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateAns|         |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 3,
      "text": "In Chord, JN's Neighbor Table needs to contain its own predecessors. It couldn't connect to them previously, because it did not yet know their addresses. However, now that it has received an Update from AP, as in the previous diagram, it has AP's predecessors, which are also its own, so it sends Attaches to them. Below, it is shown connecting only to AP's closest predecessor, PP.",
      "ja": "コードでは、JNのネイバーテーブルには、独自の前任者を含める必要があります。それはまだ自分のアドレスを知らなかったので、それは、以前にそれらに接続できませんでした。しかし、今では前回の図のように、APから更新を受け取ったこと、それはまた、自身のあるAPの前任者を、持っているので、それらに添付し送信します。以下は、それが唯一のAPの最も近い前身、PPに接続されているように。"
    },
    {
      "indent": 7,
      "text": "JN        PPP       PP        AP        NP        NNP       BP\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |AttachReq Dest=PP  |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |AttachReq Dest=PP  |         |         |\n |         |         |<--------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |AttachAns|         |         |         |\n |         |         |-------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |AttachAns|         |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |TLS      |         |         |         |         |         |\n |...................|         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateReq|         |         |         |         |         |\n |------------------>|         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateAns|         |         |         |         |         |\n |<------------------|         |         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateReq|         |         |         |         |         |\n |---------------------------->|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateAns|         |         |         |         |         |\n |<----------------------------|         |         |         |\n |         |         |         |         |         |         |\n |         |         |         |         |         |         |\n |UpdateReq|         |         |         |         |         |",
      "raw": true
    },
    {
      "indent": 8,
      "text": "|-------------------------------------->|         |         |\n|         |         |         |         |         |         |\n|         |         |         |         |         |         |\n|UpdateAns|         |         |         |         |         |\n|<--------------------------------------|         |         |\n|         |         |         |         |         |         |\n|         |         |         |         |         |         |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 5",
      "ja": "図5"
    },
    {
      "indent": 3,
      "text": "Finally, now that JN has a copy of all the data and is ready to route messages and receive requests, it sends Updates to everyone in its Routing Table to tell them it is ready to go. Below, it is shown sending such an update to TP.",
      "ja": "最後に、今JNは、すべてのデータのコピーを持っており、メッセージをルーティング準備ができているとの要求を受け取ること、行く準備ができて、それらを伝えるために、そのルーティングテーブルの全員に更新を送信します。以下は、そのTPに、このような更新を送信して示されています。"
    },
    {
      "indent": 11,
      "text": "JN        NP        XX        TP\n |         |         |         |\n |         |         |         |\n |         |         |         |\n |UpdateReq|         |         |\n |---------------------------->|\n |         |         |         |\n |         |         |         |\n |UpdateAns|         |         |\n |<----------------------------|\n |         |         |         |\n |         |         |         |\n |         |         |         |\n |         |         |         |",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 6",
      "ja": "図6"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "13.1. Overview",
      "section_title": true,
      "ja": "13.1。概要"
    },
    {
      "indent": 3,
      "text": "RELOAD provides a generic storage service, albeit one designed to be useful for P2PSIP. In this section, we discuss security issues that are likely to be relevant to any usage of RELOAD. More background information can be found in [RFC5765].",
      "ja": "RELOADはP2PSIPのために有用であるように設計された1つはいえ、一般的なストレージ・サービスを提供しています。このセクションでは、RELOADのいずれかの使用方法に関連する可能性のあるセキュリティ上の問題を議論します。より多くの背景情報は、[RFC5765]に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "In any Overlay Instance, any given user depends on a number of peers with which they have no well-defined relationship except that they are fellow members of the Overlay Instance. In practice, these other nodes may be friendly, lazy, curious, or outright malicious. No security system can provide complete protection in an environment where most nodes are malicious. The goal of security in RELOAD is to provide strong security guarantees of some properties even in the face of a large number of malicious nodes and to allow the overlay to function correctly in the face of a modest number of malicious nodes.",
      "ja": "いずれのオーバーレイインスタンスでは、任意のユーザーは、彼らがオーバーレイインスタンスの仲間のメンバーであることを除いてノー明確に定義された関係を持っているとピアの数に依存します。実際には、これらの他のノードは、フレンドリー怠惰な、好奇心、あるいはあからさまな悪意があるかもしれません。いいえ、セキュリティシステムは、ほとんどのノードが悪意のある環境の中で完全な保護を提供することはできません。 RELOADにおけるセキュリティの目標は、さえ悪意のあるノードの多数の顔にいくつかのプロパティの強力なセキュリティ保証を提供し、オーバーレイが悪意のあるノードのささやかな数の顔に正しく機能できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "P2PSIP deployments require the ability to authenticate both peers and resources (users) without the active presence of a trusted entity in the system. We describe two mechanisms. The first mechanism is based on public key certificates and is suitable for general deployments. The second is an admission control mechanism based on an overlay-wide shared symmetric key.",
      "ja": "P2PSIPの展開は、システム内の信頼できるエンティティの積極的な存在なしのピアとリソース（ユーザー）の両方を認証する機能を必要とします。我々は2つのメカニズムを説明します。第1の機構は、公開鍵証明書に基づいており、一般的な展開に適しています。第二は、オーバーレイ全体の共有対称鍵に基づいたアドミッション制御メカニズムです。"
    },
    {
      "indent": 0,
      "text": "13.2. Attacks on P2P Overlays",
      "section_title": true,
      "ja": "13.2。 P2Pオーバーレイに対する攻撃"
    },
    {
      "indent": 3,
      "text": "The two basic functions provided by overlay nodes are storage and routing: some peer is responsible for storing a node's data and for allowing a third node to fetch this stored data, while other peers are responsible for routing messages to and from the storing nodes. Each of these issues is covered in the following sections.",
      "ja": "オーバレイノードによって提供される2つの基本機能は、ストレージ及びルーティングである：いくつかのピアがノードのデータを格納するため、および他のピアは、および記憶ノードからのメッセージをルーティングする責任がありながら、第3のノードは、この格納されたデータをフェッチすることを可能にする責任があります。これらの問題のそれぞれは、次のセクションで覆われています。"
    },
    {
      "indent": 3,
      "text": "P2P overlays are subject to attacks by subversive nodes that may attempt to disrupt routing, corrupt or remove user registrations, or eavesdrop on signaling. The certificate-based security algorithms we describe in this specification are intended to protect overlay routing and user registration information in RELOAD messages.",
      "ja": "P2Pオーバーレイは、ルーティングを破壊破損またはユーザ登録を削除する、またはシグナル伝達を盗聴しようと試みることができる破壊ノードによる攻撃を受けやすいです。私たちはこの仕様で説明した証明書ベースのセキュリティアルゴリズムはRELOADメッセージにオーバーレイルーティングとユーザ登録情報を保護することを意図しています。"
    },
    {
      "indent": 3,
      "text": "To protect the signaling from attackers pretending to be valid nodes (or nodes other than themselves), the first requirement is to ensure that all messages are received from authorized members of the overlay. For this reason, RELOAD MUST transport all messages over a secure channel (TLS and DTLS are defined in this document) which provides message integrity and authentication of the directly communicating peer. In addition, messages and data MUST be digitally signed with the sender's private key, providing end-to-end security for communications.",
      "ja": "有効なノード（または自分以外のノード）のふりをし、攻撃者からのシグナリングを保護するために、最初の要件は、すべてのメッセージがオーバーレイの認可メンバーから受信されることを保証することです。この理由のため、リロードは、メッセージの完全性と直接通信するピアの認証を提供するセキュアチャネル（TLSとDTLSこの文書で定義されている）上のすべてのメッセージを転送しなければなりません。また、メッセージやデータをデジタル通信用のエンドツーエンドのセキュリティを提供し、送信者の秘密鍵で署名されなければなりません。"
    },
    {
      "indent": 0,
      "text": "13.3. Certificate-Based Security",
      "section_title": true,
      "ja": "13.3。証明書ベースのセキュリティ"
    },
    {
      "indent": 3,
      "text": "This specification stores users' registrations and possibly other data in an overlay network. This requires a solution both to securing this data and to securing, as well as possible, the routing in the overlay. Both types of security are based on requiring that every entity in the system (whether user or peer) authenticate cryptographically using an asymmetric key pair tied to a certificate.",
      "ja": "この仕様は、オーバーレイネットワークにユーザの登録およびおそらく他のデータを格納します。これは、このデータを保護および固定の両方のソリューションを必要とするだけでなく、可能な限り、オーバーレイにルーティング。セキュリティの両方のタイプは、システム内のすべてのエンティティ（ユーザまたはピアかどうか）は暗号証明書に関連付けられて非対称鍵ペアを使用して認証することを要求に基づいています。"
    },
    {
      "indent": 3,
      "text": "When a user enrolls in the Overlay Instance, they request or are assigned a unique name, such as \"alice@dht.example.net\". These names MUST be unique and are meant to be chosen and used by humans much like a SIP address-of-record (AOR) or an email address. The user",
      "ja": "ユーザーがオーバーレイインスタンスに登録するとき、彼らは要求したり、そのような「alice@dht.example.net」として、ユニークな名前が割り当てられています。これらの名前は一意である必要があり、選ばれたとSIPアドレス・オブ・レコード（AOR）または電子メールアドレスなどの多くの人が使用することを意図しています。ユーザー"
    },
    {
      "indent": 3,
      "text": "MUST also be assigned one or more Node-IDs by the central enrollment authority. Both the name and the Node-IDs are placed in the certificate, along with the user's public key.",
      "ja": "また、中央の登録機関によって一つ以上のNode-IDを割り当てなければなりません。名前とノードIDの両方が利用者の公開鍵と一緒に、証明書に配置されています。"
    },
    {
      "indent": 3,
      "text": "Each certificate enables an entity to act in two sorts of roles:",
      "ja": "各証明書は、役割の2種類で行動するエンティティを可能にします："
    },
    {
      "indent": 3,
      "text": "o As a user, storing data at specific Resource-IDs in the Overlay Instance corresponding to the user name.",
      "ja": "ユーザーとしてO、ユーザー名に対応するオーバーレイインスタンスの特定の資源のIDでデータを記憶します。"
    },
    {
      "indent": 3,
      "text": "o As a overlay peer with the Node-IDs listed in the certificate.",
      "ja": "証明書に記載されているノードIDを持つオーバーレイピアとしてO。"
    },
    {
      "indent": 3,
      "text": "Note that since only users of this Overlay Instance need to validate a certificate, this usage does not require a global Public Key Infrastructure (PKI). Instead, certificates MUST be signed by a central enrollment authority which acts as the certificate authority for the Overlay Instance. This authority signs each node's certificate. Because each node possesses the CA's certificate (which they receive upon enrollment), they can verify the certificates of the other entities in the overlay without further communication. Because the certificates contain the user's/node's public key, communications from the user/node can, in turn, be verified.",
      "ja": "このオーバーレイインスタンスのユーザーのみが証明書を検証する必要があるため、この使用方法は、グローバルな公開鍵基盤（PKI）を必要としないことに注意してください。代わりに、証明書はオーバーレイインスタンスの認証局として機能し、中央登録機関によって署名されなければなりません。この権限は、各ノードの証明書に署名します。各ノードは、（彼らは入学時に受信）CAの証明書を持っているので、彼らはさらに通信せずに、オーバーレイ内の他のエンティティの証明書を検証することができます。証明書は、ユーザーの/ノードの公開鍵が含まれているため、ユーザ/ノードからの通信は、順番に、確認することができます。"
    },
    {
      "indent": 3,
      "text": "If self-signed certificates are used, then the security provided is significantly decreased, since attackers can mount Sybil attacks. In addition, attackers cannot trust the user names in certificates (although they can trust the Node-IDs, because they are cryptographically verifiable). This scheme may be appropriate for some small deployments, such as a small office or an ad hoc overlay set up among participants in a meeting where all hosts on the network are trusted. Some additional security can be provided by using the shared secret admission control scheme as well.",
      "ja": "自己署名証明書が使用されている場合、攻撃者は、シビル攻撃をマウントすることができるので、その後、提供されるセキュリティは、大幅に減少しています。 （彼らはノードIDを信頼することができますが、彼らは暗号的に検証されているので、）また、攻撃者は、証明書でユーザー名を信頼することはできません。この方式では、このような小規模オフィスやネットワーク上のすべてのホストが信頼されている会議の参加者の間で設定するアドホックオーバーレイなどの一部の小規模な展開のために適切かもしれません。いくつかの追加のセキュリティだけでなく、共有秘密受付制御方式を使用することにより提供することができます。"
    },
    {
      "indent": 3,
      "text": "Because all stored data is signed by the owner of the data, the storing node can verify that the storer is authorized to perform a store at that Resource-ID and also can allow any consumer of the data to verify the provenance and integrity of the data when it retrieves it.",
      "ja": "すべての記憶されたデータは、データの所有者によって署名されているため、記憶ノードは、記憶手段がそのリソース-IDで保存の実行を許可されていることを確認することができ、また、データの任意の消費者は、データの出所と整合性を検証できるようにすることができとき、それはそれを取得します。"
    },
    {
      "indent": 3,
      "text": "Note that RELOAD does not itself provide a revocation/status mechanism (although certificates may, of course, include Online Certificate Status Protocol [OCSP] responder information). Thus, certificate lifetimes SHOULD be chosen to balance the compromise window versus the cost of certificate renewal. Because RELOAD is already designed to operate in the face of some fraction of malicious nodes, this form of compromise is not fatal.",
      "ja": "（証明書は、当然のことながら、[OCSP]情報のレスポンダオンライン証明書状態プロトコル挙げられるが）をRELOAD自体が失効/ステータスメカニズムを提供しないことに注意してください。このように、証明書の有効期限は、証明書の更新の費用対妥協ウィンドウのバランスをとるように選択する必要があります。 RELOADはすでに悪意のあるノードのいくつかの画分の顔で動作するように設計されているので、妥協のこの形式は致命的ではありません。"
    },
    {
      "indent": 3,
      "text": "All implementations MUST implement certificate-based security.",
      "ja": "すべての実装は、証明書ベースのセキュリティを実装しなければなりません。"
    },
    {
      "indent": 0,
      "text": "13.4. Shared-Secret Security",
      "section_title": true,
      "ja": "13.4。共有秘密のセキュリティ"
    },
    {
      "indent": 3,
      "text": "RELOAD also supports a shared secret admission control scheme that relies on a single key that is shared among all members of the overlay. It is appropriate for small groups that wish to form a private network without complexity. In shared secret mode, all the peers MUST share a single symmetric key which is used to key TLS-PSK or TLS-SRP mode. A peer which does not know the key cannot form TLS connections with any other peer and therefore cannot join the overlay.",
      "ja": "RELOADもオーバーレイのすべてのメンバー間で共有される単一のキーに依存している共有秘密受付制御方式をサポートしています。これは、複雑させずにプライベートネットワークを形成したい小グループに適しています。共有シークレットモードでは、すべてのピアは、鍵TLS-PSKまたはTLS-SRPモードに使用される単一の対称鍵を共有しなければなりません。鍵を知らないピアは他のピアとのTLS接続を形成することができないため、オーバーレイに参加することはできません。"
    },
    {
      "indent": 3,
      "text": "One natural approach to a shared-secret scheme is to use a user-entered password as the key. The difficulty with this is that in TLS-PSK mode, such keys are very susceptible to dictionary attacks. If passwords are used as the source of shared keys, then TLS-SRP is a superior choice, because it is not subject to dictionary attacks.",
      "ja": "共有秘密スキームに対する一つの自然なアプローチをキーとして、ユーザが入力したパスワードを使用することです。これの難しさは、TLS-PSKモードでは、このようなキーは辞書攻撃に非常に敏感であるということです。パスワードが共有鍵のソースとして使用している場合、それは辞書攻撃の対象ではないので、その後、TLS-SRPは、優れた選択肢です。"
    },
    {
      "indent": 0,
      "text": "13.5. Storage Security",
      "section_title": true,
      "ja": "13.5。ストレージセキュリティ"
    },
    {
      "indent": 3,
      "text": "When certificate-based security is used in RELOAD, any given Resource-ID/Kind-ID pair is bound to some small set of certificates. In order to write data, the writer must prove possession of the private key for one of those certificates. Moreover, all data is stored, signed with the same private key that was used to authorize the storage. This set of rules makes questions of authorization and data integrity, which have historically been thorny for overlays, relatively simple.",
      "ja": "証明書ベースのセキュリティがRELOADに使用されている場合は、任意のリソース-ID /種類-IDのペアは、証明書のいくつかの小さなセットにバインドされています。データを書き込むために、ライターは、それらの証明書のいずれかの秘密鍵の所有を証明しなければなりません。また、すべてのデータが、記憶された記憶装置を認証するために使用された同じプライベートキーで署名されています。ルールのこのセットは、歴史的にオーバーレイのために厄介なされている認証とデータの整合性の問題は、比較的簡単になります。"
    },
    {
      "indent": 0,
      "text": "13.5.1. Authorization",
      "section_title": true,
      "ja": "13.5.1。認定"
    },
    {
      "indent": 3,
      "text": "When a node wants to store some value, it MUST first digitally sign the value with its own private key. It then sends a Store request that contains both the value and the signature towards the storing peer (which is defined by the Resource Name construction algorithm for that particular Kind of value).",
      "ja": "ノードは、いくつかの値を格納したい場合は、最初にデジタル自身の秘密鍵で値を署名する必要があります。次に、（値の特定の種類のリソース名構築アルゴリズムによって定義される）を記憶するピアに向かっ値と署名の両方を含む記憶要求を送信します。"
    },
    {
      "indent": 3,
      "text": "When the storing peer receives the request, it MUST determine whether the storing node is authorized to store at this Resource-ID/Kind-ID pair. Determining this requires comparing the user's identity to the requirements of the access control model (see Section 7.3). If it satisfies those requirements, the user is authorized to write, pending quota checks, as described in the next section.",
      "ja": "格納ピアが要求を受信すると、記憶ノードはこのリソース-ID /種類-IDペアで保存することを許可されているかどうかを決定しなければなりません。これを決定すること（セクション7.3を参照）アクセス制御モデルの要件にユーザーのIDを比較することが必要です。それはこれらの要件を満たす場合、ユーザは、次のセクションで説明したように、クォータチェックペンディング、書き込みを許可されています。"
    },
    {
      "indent": 3,
      "text": "For example, consider a certificate with the following properties:",
      "ja": "たとえば、次のプロパティを持つ証明書を検討してください。"
    },
    {
      "indent": 10,
      "text": "User name: alice@dht.example.com\nNode-ID:   013456789abcdef\nSerial:    1234",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If Alice wishes to Store a value of the \"SIP Location\" Kind, the Resource Name will be the SIP AOR \"sip:alice@dht.example.com\". The Resource-ID will be determined by hashing the Resource Name. Because SIP Location uses the USER-NODE-MATCH policy, it first verifies that the user name in the certificate hashes to the requested Resource-ID. It then verifies that the Node-ID in the certificate matches the dictionary key being used for the store. If both of these checks succeed, the Store is authorized. Note that because the access control model is different for different Kinds, the exact set of checks will vary.",
      "ja": "アリスは、「SIP場所」種類の値を格納したい場合は、リソース名は、SIP AOR「：alice@dht.example.com SIP」になります。リソース-IDは、リソース名をハッシュすることによって決定されます。 SIP場所は、USER-NODE-MATCHポリシーを使用しているので、それは最初に要求されたリソース-IDに証明書ハッシュにそのユーザー名を確認します。その後、ノードID証明書ストアに使用されている辞書のキーと一致することを確認します。これらのチェックの両方が成功した場合、ストアが許可されています。アクセス制御モデルは、異なる種類の異なるため、検査の正確なセットが変化することに注意してください。"
    },
    {
      "indent": 0,
      "text": "13.5.2. Distributed Quota",
      "section_title": true,
      "ja": "13.5.2。分散クォータ"
    },
    {
      "indent": 3,
      "text": "Being a peer in an Overlay Instance carries with it the responsibility to store data for a given region of the Overlay Instance. However, allowing nodes to store unlimited amounts of data would create unacceptable burdens on peers and would also enable trivial denial-of-service (DoS) attacks. RELOAD addresses this issue by requiring configurations to define maximum sizes for each Kind of stored data. Attempts to store values exceeding this size MUST be rejected. (If peers are inconsistent about this, then strange artifacts will happen when the zone of responsibility shifts and a different peer becomes responsible for overlarge data.) Because each Resource-ID/Kind-ID pair is bound to a small set of certificates, these size restrictions also create a distributed quota mechanism, with the quotas administered by the central configuration server.",
      "ja": "オーバーレイ・インスタンス内のピアであることは、それにオーバーレイインスタンスの所定の領域のデータを格納するための責任を運びます。しかし、許可のノードがピアで許容できない負担を作成し、データの無制限の量を格納するためにも些細なサービス拒否（DoS）攻撃を可能にします。格納されたデータの種類毎に最大サイズを定義するために構成を要求することによって、アドレスにこの問題をリロード。このサイズを超える値を格納するための試みは拒絶しなければなりません。 （ピアはこのことについて矛盾している場合は責任シフトのゾーンと異なるピアがoverlargeデータの責任になった場合、その後、奇妙なアーティファクトが発生します。）各リソース-ID /種類-IDのペアは、証明書の小さなセットにバインドされているため、これらのサイズ制限は、中央構成サーバによって投与クォータと、分散クォータ機構を作成します。"
    },
    {
      "indent": 3,
      "text": "Allowing different Kinds of data to have different size restrictions allows new usages the flexibility to define limits that fit their needs without requiring all usages to have expansive limits.",
      "ja": "異なるサイズの制限を持つように異なる種類のデータを許可すると、新たな用法に広大な限界を持っているすべての使用を必要とせずに自分のニーズに合わせて制限を定義するための柔軟性を可能にします。"
    },
    {
      "indent": 0,
      "text": "13.5.3. Correctness",
      "section_title": true,
      "ja": "13.5.3。正しいこと"
    },
    {
      "indent": 3,
      "text": "Because each stored value is signed, it is trivial for any retrieving node to verify the integrity of the stored value. More care needs to be taken to prevent version rollback attacks. Rollback attacks on storage are prevented by the use of store times and lifetime values in each store. A lifetime represents the latest time at which the data is valid and thus limits (although does not completely prevent) the ability of the storing node to perform a rollback attack on retrievers. In order to prevent a rollback attack at the time of the Store request, it is REQUIRED that storage times be monotonically increasing. Storing peers MUST reject Store requests with storage times smaller than or equal to those that they are currently storing. In addition, a fetching node which receives a data value with a storage time older than the result of the previous fetch knows that a rollback has occurred.",
      "ja": "各格納された値が署名されているため、任意の検索ノードが格納された値の整合性を検証することは自明です。より多くの注意がバージョンロールバック攻撃を防ぐために取られる必要があります。ストレージ上のロールバック攻撃は、各店舗で店舗時間および寿命値を使用することによって防止されます。寿命は、データが有効であり、従って制限された最新の時間（完全に防止しないが）レトリバーにロールバック攻撃を実行するために記憶ノードの能力を表します。ストア要求時のロールバックの攻撃を防ぐためには、その保存時間が単調に増加することが必要です。保存ピアは、現在保存されているものに格納倍以下としてストア要求を拒絶しなければなりません。また、蓄積時間と前の結果フェッチより古いデータ値を受信フェッチノードは、ロールバックが発生したことを知ります。"
    },
    {
      "indent": 0,
      "text": "13.5.4. Residual Attacks",
      "section_title": true,
      "ja": "13.5.4。残留攻撃"
    },
    {
      "indent": 3,
      "text": "The mechanisms described here provide a high degree of security, but some attacks remain possible. Most simply, it is possible for storing peers to refuse to store a value (i.e., they reject any request). In addition, a storing peer can deny knowledge of values which it has previously accepted. To some extent, these attacks can be ameliorated by attempting to store to and retrieve from replicas, but a retrieving node does not know whether or not it should try this, as there is a cost to doing so.",
      "ja": "ここで説明するメカニズムは、高度のセキュリティを提供しますが、いくつかの攻撃が可能に残ります。最も単純に、それは（つまり、彼らはすべての要求を拒否）値を格納することを拒否するためにピアを格納することも可能です。また、記憶ピアは、それが以前に受け入れられた値の知識を拒否することができます。ある程度、これらの攻撃は、に保管し、レプリカから取得しようとすることによって改善することができますが、検索ノードは、そうすることにコストがあるとして、それは、これを試す必要があるかどうか分かりません。"
    },
    {
      "indent": 3,
      "text": "The certificate-based authentication scheme prevents a single peer from being able to forge data owned by other peers. Furthermore, although a subversive peer can refuse to return data resources for which it is responsible, it cannot return forged data, because it cannot provide authentication for such registrations. Therefore, parallel searches for redundant registrations can mitigate most of the effects of a compromised peer. The ultimate reliability of such an overlay is a statistical question based on the replication factor and the percentage of compromised peers.",
      "ja": "証明書ベースの認証方式は、他のピアが所有するデータを偽造することができることから、単一のピアを防止します。破壊ピアは、それが担当するデータリソースを返すことを拒否することができますが、それは、そのような登録のための認証を提供することができないので、さらに、それは、偽造データを返すことはできません。したがって、冗長登録のための並列検索は損なわピアの効果のほとんどを軽減することができます。そのようなオーバーレイの究極の信頼性は、複製因子と妥協ピアの割合に基づいて統計的な質問です。"
    },
    {
      "indent": 3,
      "text": "In addition, when a Kind is multivalued (e.g., an array data model), the storing peer can return only some subset of the values, thus biasing its responses. This can be countered by using single values rather than sets, but that makes coordination between multiple storing agents much more difficult. This is a trade-off that must be made when designing any usage.",
      "ja": "種類（例えば、配列データ・モデル）多値された場合に加えて、格納ピアは、このようにその応答をバイアス値の一部のみのサブセットを返すことができます。これは、単一の値ではなく、セットを使用することによって対抗することができ、それは、複数の収納エージェント間の調整がはるかに困難になります。これは、任意の使用を設計する際に行わなければならないトレードオフです。"
    },
    {
      "indent": 0,
      "text": "13.6. Routing Security",
      "section_title": true,
      "ja": "13.6。ルーティングセキュリティ"
    },
    {
      "indent": 3,
      "text": "Because the storage security system guarantees (within limits) the integrity of the stored data, routing security focuses on stopping the attacker from performing a DoS attack that misroutes requests in the overlay. There are a few obvious observations to make about this. First, it is easy to ensure that an attacker is at least a valid node in the Overlay Instance. Second, this is a DoS attack only. Third, if a large percentage of the nodes on the Overlay Instance are controlled by the attacker, it is probably impossible to perfectly secure against this.",
      "ja": "ストレージ・セキュリティ・システムは、（制限内で）格納されたデータの整合性を保証するため、ルーティングのセキュリティは、オーバーレイに要求をmisroutes DoS攻撃を行う攻撃者を停止するに焦点を当てています。これについて作るためにいくつかの明白な観察があります。まず、攻撃者は、少なくともオーバーレイインスタンスで有効なノードであることを保証するのは簡単です。第二に、これが唯一のDoS攻撃です。オーバーレイインスタンス上のノードの大部分は、攻撃者によって制御されている場合には第三に、それはおそらく、このに対して完全に安全なのは不可能です。"
    },
    {
      "indent": 0,
      "text": "13.6.1. Background",
      "section_title": true,
      "ja": "13.6.1。バックグラウンド"
    },
    {
      "indent": 3,
      "text": "In general, attacks on DHT routing are mounted by the attacker arranging to route traffic through one or two nodes that it controls. In the Eclipse attack [Eclipse], the attacker tampers with messages to and from nodes for which it is on-path with respect to a given victim node. This allows it to pretend to be all the nodes that are reachable through it. In the Sybil attack [Sybil], the attacker registers a large number of nodes and is therefore able to capture a large amount of the traffic through the DHT.",
      "ja": "一般的に、DHTルーティング上の攻撃はそれが制御する一つ又は二つのノードを介してトラフィックをルーティングに配置する攻撃者によって実装されています。 Eclipseの攻撃[エクリプス]において、攻撃者は、所与の犠牲者ノードに対してオンパスされたノードへ及びからのメッセージを改ざん。これは、それを介して到達可能なすべてのノードのふりをすることができます。シビル攻撃[シビル]において、攻撃者は、多数のノードを登録し、従って、DHTを介して大量のトラフィックをキャプチャすることが可能です。"
    },
    {
      "indent": 3,
      "text": "Both the Eclipse and Sybil attacks require the attacker to be able to exercise control over her Node-IDs. The Sybil attack requires the creation of a large number of peers. The Eclipse attack requires that the attacker be able to impersonate specific peers. In both cases, RELOAD attempts to mitigate these attacks by the use of centralized, certificate-based admission control.",
      "ja": "どちらもEclipseとシビル攻撃は彼女のノードIDが支配力を行使することができるように、攻撃者が必要です。シビル攻撃は、多数のピアを作成する必要があります。 Eclipseの攻撃は、攻撃者が特定のピアを偽装できることが必要です。両方の場合において、集中、証明書ベースのアドミッション制御を使用することによってこれらの攻撃を軽減する試みをリロード。"
    },
    {
      "indent": 0,
      "text": "13.6.2. Admissions Control",
      "section_title": true,
      "ja": "13.6.2。入学コントロール"
    },
    {
      "indent": 3,
      "text": "Admission to a RELOAD Overlay Instance is controlled by requiring that each peer have a certificate containing its Node-ID. The requirement to have a certificate is enforced by using certificate-based mutual authentication on each connection. (Note: the following applies only when self-signed certificates are not used.) Whenever a peer connects to another peer, each side automatically checks that the other has a suitable certificate. These Node-IDs MUST be randomly assigned by the central enrollment server. This has two benefits:",
      "ja": "RELOADオーバーレイインスタンスへの入場は、それぞれ、そのノードIDを含む証明書を持っているピアことを要求することによって制御されます。証明書を持っている必要は各接続に証明書ベースの相互認証を使用して実施されます。 （注：以下に、自己署名証明書が使用されていない場合にのみ適用される）ピアが別のピアに接続するたびに、それぞれの側は、自動的に他の適切な証明書を持っていることをチェックします。これらのノードIDは、ランダムに中央登録サーバによって割り当てられなければなりません。これには2つの利点があります。"
    },
    {
      "indent": 3,
      "text": "o It allows the enrollment server to limit the number of Node-IDs issued to any individual user.",
      "ja": "Oこれは、登録サーバは個々のユーザーに対して発行されたノードIDの数を制限することができます。"
    },
    {
      "indent": 3,
      "text": "o It prevents the attacker from choosing specific Node-IDs.",
      "ja": "Oそれは、特定のノードのIDを選択するから、攻撃者を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "The first property allows protection against Sybil attacks (provided that the enrollment server uses strict rate-limiting policies). The second property deters but does not completely prevent Eclipse attacks. Because an Eclipse attacker must impersonate peers on the other side of the attacker, the attacker must have a certificate for suitable Node-IDs, which requires him to repeatedly query the enrollment server for new certificates, which will match only by chance. From the attacker's perspective, the difficulty is that if the attacker has only a small number of certificates, the region of the Overlay Instance he is impersonating appears to be very sparsely populated by comparison to the victim's local region.",
      "ja": "最初のプロパティは、（登録サーバは、厳密なレート制限ポリシーを使用している場合）シビル攻撃に対する保護を可能にします。第二の特性を抑止するが、完全にEclipseの攻撃を防ぐことはできません。 Eclipseの攻撃者は、攻撃者の反対側のピアを偽装する必要があるため、攻撃者は何度だけ偶然一致する新しい証明書、入学のためのサーバーを照会するために彼を必要とする適切なノードIDの証明書を持っている必要があります。攻撃者は、証明書のほんの数を持っている場合、攻撃者の視点から、難しさは、彼が偽装されたオーバーレイインスタンスの領域は非常にまばらに被害者の地元地域との比較によって移植されるように見えるということです。"
    },
    {
      "indent": 0,
      "text": "13.6.3. Peer Identification and Authentication",
      "section_title": true,
      "ja": "13.6.3。識別と認証ピア"
    },
    {
      "indent": 3,
      "text": "In general, whenever a peer engages in overlay activity that might affect the Routing Table, it must establish its identity. This happens in two ways. First, whenever a peer establishes a direct connection to another peer, it authenticates via certificate-based mutual authentication. All messages between peers are sent over this protected channel, and therefore the peers can verify the data origin of the last-hop peer for requests and responses without further cryptography.",
      "ja": "一般的には、ピアはルーティングテーブルに影響を与える可能性があることオーバーレイ活動に従事したときに、それはそのアイデンティティを確立する必要があります。これは、2つの方法で行われます。ピアが別のピアへの直接接続を確立するたびに、まず、それが証明書ベースの相互認証を介して認証します。ピア間のすべてのメッセージは、この保護されたチャネルを介して送信されますので、ピアはさらに、暗号化せずに、要求と応答のための最後のホップピアのデータ発信元を確認することができます。"
    },
    {
      "indent": 3,
      "text": "In some situations, however, it is desirable to be able to establish the identity of a peer with whom one is not directly connected. The most natural case is when a peer Updates its state. At this point, other peers may need to update their view of the overlay structure, but they need to verify that the Update message came from the actual peer rather than from an attacker. To prevent having a peer accept Update messages from an attacker, all overlay routing messages are signed by the peer that generated them.",
      "ja": "いくつかの状況では、しかし、1が直接接続されていない人とピアのアイデンティティを確立することができることが望ましいです。ピアがその状態を更新したときに最も自然なケースがあります。この時点で、他のピアは、オーバーレイ構造のビューを更新する必要があるかもしれないが、彼らは、Updateメッセージは、実際のピアからではなく、攻撃者から来ていることを確認する必要があります。ピアが攻撃者からの更新メッセージを受け入れる有する防ぐために、すべてのオーバーレイルーティングメッセージは、それらを生成したピアによって署名されます。"
    },
    {
      "indent": 3,
      "text": "For messages that impact the topology of the overlay, replay is typically prevented by having the information come directly from, or be verified by, the nodes that claimed to have generated the update. Data storage replay detection is done by signing the time of the node that generated the signature on the Store request, thus providing a time-based replay protection, but the time synchronization is needed only between peers that can write to the same location.",
      "ja": "オーバーレイのトポロジーに影響を与えるメッセージの場合、再生は、典型的には、情報を持っていることによって阻止されるから直接、または更新が発生したと主張ノードによって検証されます。データ・ストレージ・リプレイ検出は、このように時間ベースのリプレイ保護を提供し、ストア要求の署名を生成したノードの時間に署名することによって行われるが、時間同期は、同じ場所に書き込むことができるピア間で必要とされています。"
    },
    {
      "indent": 0,
      "text": "13.6.4. Protecting the Signaling",
      "section_title": true,
      "ja": "13.6.4。シグナリングの保護"
    },
    {
      "indent": 3,
      "text": "The goal here is to stop an attacker from knowing who is signaling what to whom. An attacker is unlikely to be able to observe the activities of a specific individual, given the randomization of IDs and routing based on the present peers discussed above. Furthermore, because messages can be routed using only the header information, the actual body of the RELOAD message can be encrypted during transmission.",
      "ja": "ここでの目標は、どのような誰にシグナリングをしている人を知ってからの攻撃を停止することです。攻撃者は、上述した本ピアに基づいて、IDおよびルーティングのランダム化を考慮すると、特定の個人の活動を観察することはできそうにありません。メッセージは、ヘッダ情報のみを使用してルーティングすることができるのでさらに、リロードメッセージの実際のボディは、送信時に暗号化することができます。"
    },
    {
      "indent": 3,
      "text": "There are two lines of defense here. The first is the use of TLS or DTLS for each communications link between peers. This provides protection against attackers who are not members of the overlay. The second line of defense is to digitally sign each message. This prevents adversarial peers from modifying messages in flight, even if they are on the routing path.",
      "ja": "ここでは、防衛の2行があります。最初は、ピア間の各通信リンクのためのTLSまたはDTLSを使用することです。これは、オーバーレイのメンバーではない攻撃者に対する保護を提供します。防衛の2行目は、デジタル各メッセージに署名することです。これは、彼らがルーティングパス上にある場合でも、飛行中のメッセージを修正するから敵対ピアを防ぐことができます。"
    },
    {
      "indent": 0,
      "text": "13.6.5. Routing Loops and DoS Attacks",
      "section_title": true,
      "ja": "13.6.5。ルーティングループやDoS攻撃"
    },
    {
      "indent": 3,
      "text": "Source-routing mechanisms are known to create the possibility for DoS amplification, especially by the induction of routing loops [RFC5095]. In order to limit amplification, the initial-ttl value in the configuration file SHOULD be set to a value slightly larger than the longest expected path through the network. For Chord, experience has shown that log(2) of the number of nodes in the network + 5 is a safe bound. Because nodes are required to enforce the initial-ttl as the maximum value, an attacker cannot achieve an amplification factor greater than initial-ttl, thus limiting the additional capabilities provided by source routing.",
      "ja": "ソースルーティングメカニズムは、特にルーティングループ[RFC5095]の誘導により、DoSの増幅のための可能性を作成することが知られています。増幅を制限するために、構成ファイル内の初期TTL値は、ネットワークを介して最長の予想経路よりも僅かに大きい値に設定する必要があります。コードのために、経験は、ネットワーク+ 5内のノードの数のログ（2）安全で結合している示されています。ノードは最大値として初期TTLを適用する必要があるため、攻撃者は、このようにソースルーティングによって提供される追加機能を制限する、初期TTLよりも大きい増幅率を達成することができません。"
    },
    {
      "indent": 3,
      "text": "In order to prevent the use of loops for targeted implementation attacks, implementations SHOULD check the Destination List for duplicate entries and discard such records with an \"Error_Invalid_Message\" error. This does not completely prevent loops, but it does require that at least one attacker node be part of the loop.",
      "ja": "目標実現の攻撃のためのループの使用を防ぐために、実装は、重複したエントリの宛先リストを確認する必要がありますし、「Error_Invalid_Message」エラーで、このようなレコードを破棄します。これは、完全にループを妨げないが、それは、少なくとも一つの攻撃ノードがループの一部であることを必要はありません。"
    },
    {
      "indent": 0,
      "text": "13.6.6. Residual Attacks",
      "section_title": true,
      "ja": "13.6.6。残留攻撃"
    },
    {
      "indent": 3,
      "text": "The routing security mechanisms in RELOAD are designed to contain rather than eliminate attacks on routing. It is still possible for an attacker to mount a variety of attacks. In particular, if an attacker is able to take up a position on the overlay routing between A and B, it can make it appear as if B does not exist or is disconnected. It can also advertise false network metrics in an attempt to reroute traffic. However, these are primarily DoS attacks.",
      "ja": "RELOAD内のルーティングセキュリティメカニズムが含まれているのではなく、ルーティングへの攻撃を排除するために設計されています。攻撃者は、攻撃の様々なマウントすることは可能です。具体的には、攻撃者はAとBとの間のルーティングオーバレイ上の位置を取ることができる場合、それはBが存在しないか、切断されたかのように見せることができます。また、トラフィックを再ルーティングするための試みで、偽のネットワークメトリックをアドバタイズできます。しかし、これらは主にDoS攻撃です。"
    },
    {
      "indent": 3,
      "text": "The certificate-based security scheme secures the namespace, but if an individual peer is compromised or if an attacker obtains a certificate from the CA, then a number of subversive peers can still appear in the overlay. While these peers cannot falsify responses to resource queries, they can respond with error messages, effecting a DoS attack on the resource registration. They can also subvert routing to other compromised peers. To defend against such attacks, a resource search must still consist of parallel searches for replicated registrations.",
      "ja": "証明書ベースのセキュリティスキームは、名前空間を確保しますが、個々のピアが侵害された場合や、攻撃者がCAから証明書を取得した場合、その後、破壊ピアの数はまだオーバーレイで表示されます。これらのピアがクエリをリソースへの回答を改ざんすることはできませんが、彼らは、リソース登録にDoS攻撃を行うと、エラーメッセージで応答することができます。彼らはまた、他の妥協のピアへのルーティング覆すことができます。このような攻撃を防御するには、リソース検索は、まだ複製され、登録のための並列検索で構成する必要があります。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section contains the new code points registered by this document.",
      "ja": "このセクションでは、この文書が登録した新しいコードポイントが含まれています。"
    },
    {
      "indent": 0,
      "text": "14.1. Well-Known URI Registration",
      "section_title": true,
      "ja": "14.1。よく知られているURIの登録"
    },
    {
      "indent": 3,
      "text": "IANA has registered a \"well-known URI\" as described in [RFC5785]:",
      "ja": "[RFC5785]に記載されているようにIANA「は、周知のURI」を登録しました。"
    },
    {
      "indent": 11,
      "text": "+----------------------------+----------------------+\n| URI suffix:                | reload-config        |\n| Change controller:         | IETF <iesg@ietf.org> |\n| Specification document(s): | RFC 6940             |\n| Related information:       | None                 |\n+----------------------------+----------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "14.2. Port Registrations",
      "section_title": true,
      "ja": "14.2。ポートの登録"
    },
    {
      "indent": 3,
      "text": "IANA has already allocated a TCP port for the main peer-to-peer protocol. This port had the name p2psip-enroll and the port number of 6084. Per this document, IANA has updated this registration to change the service name to reload-config.",
      "ja": "IANAは既にメインピア・ツー・ピア・プロトコルのTCPポートを割り当てました。このポートは、名前のP2PSIP-登録し、この文書毎6084.のポート番号を持っていた、IANAは-config設定を再ロードするためにサービス名を変更するには、この登録を更新しました。"
    },
    {
      "indent": 3,
      "text": "IANA has made the following port registration:",
      "ja": "IANAは、次のポートの登録を行いました。"
    },
    {
      "indent": 3,
      "text": "+-----------------------------+-------------------------------------+\n| Registration Technical      | IETF Chair <chair@ietf.org>         |\n| Contact                     |                                     |\n| Registration Owner          | IETF <iesg@ietf.org>                |\n| Transport Protocol          | TCP                                 |\n| Port Number                 | 6084                                |\n| Service Name                | reload-config                       |\n| Description                 | Peer-to-Peer Infrastructure         |\n|                             | Configuration                       |\n+-----------------------------+-------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "14.3. Overlay Algorithm Types",
      "section_title": true,
      "ja": "14.3。オーバーレイのアルゴリズムタイプ"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Overlay Algorithm Types\" Registry. Entries in this registry are strings denoting the names of overlay algorithms, as described in Section 11.1 of [RFC6940]. The registration policy for this registry is \"IETF Review\" [RFC522]. The initial contents of this registry are:",
      "ja": "IANAは、「RELOADオーバーレイアルゴリズムの種類」レジストリを作成しました。 [RFC6940]のセクション11.1で説明したように、このレジストリのエントリは、オーバーレイアルゴリズムの名前を表す文字列です。このレジストリの登録ポリシーは、「IETFレビュー」[RFC522]です。このレジストリの初期の内容は以下のとおりです。"
    },
    {
      "indent": 22,
      "text": "+----------------+-----------+\n| Algorithm Name | Reference |\n+----------------+-----------+\n| CHORD-RELOAD   |  RFC 6940 |\n| EXP-OVERLAY    |  RFC 6940 |\n+----------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value EXP-OVERLAY has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "値EXP-OVERLAYは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "14.4. Access Control Policies",
      "section_title": true,
      "ja": "14.4。アクセス制御ポリシー"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Access Control Policies\" Registry. Entries in this registry are strings denoting access control policies, as described in Section 7.3 of [RFC6940]. New entries in this registry SHALL be registered via Standards Action [RFC5226]. The initial contents of this registry are:",
      "ja": "IANAは、「RELOADアクセス制御ポリシー」レジストリを作成しました。 [RFC6940]のセクション7.3で説明したように、このレジストリのエントリは、アクセス制御ポリシーを表す文字列です。このレジストリ内の新しいエントリは、標準アクション[RFC5226]を経由して登録するものとします。このレジストリの初期の内容は以下のとおりです。"
    },
    {
      "indent": 22,
      "text": "+-----------------+-----------+\n| Access Policy   | Reference |\n+-----------------+-----------+\n| USER-MATCH      |  RFC 6940 |\n| NODE-MATCH      |  RFC 6940 |\n| USER-NODE-MATCH |  RFC 6940 |\n| NODE-MULTIPLE   |  RFC 6940 |\n| EXP-MATCH       |  RFC 6940 |\n+-----------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value EXP-MATCH has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "値EXP-MATCHは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "14.5. Application-ID",
      "section_title": true,
      "ja": "14.5。アプリケーションID"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Application-ID\" Registry. Entries in this registry are 16-bit integers denoting Application-IDs, as described in Section 6.5.2 of [RFC6940]. Code points in the range 1 to 32767 SHALL be registered via Standards Action [RFC5226]. Code points in the range 32768 to 61440 SHALL be registered via Expert Review [RFC5226]. Code points in the range 61441 to 65534 are reserved for private use. The initial contents of this registry are:",
      "ja": "IANAは、「RELOADアプリケーションID」レジストリを作成しました。 [RFC6940]のセクション6.5.2に記載したように、このレジストリのエントリは、アプリケーションIDを表す16ビットの整数です。 32767の範囲1のコードポイントは標準アクション[RFC5226]を介して、登記しなければなりません。 61440の範囲32768のコードポイントがエキスパートレビュー[RFC5226]を介して、登記しなければなりません。範囲内のコードポイント61441〜65534は、私的使用のために予約されています。このレジストリの初期の内容は以下のとおりです。"
    },
    {
      "indent": 5,
      "text": "+-------------+----------------+-------------------------------+\n| Application | Application-ID |                 Specification |\n+-------------+----------------+-------------------------------+\n| INVALID     |              0 |                      RFC 6940 |\n| SIP         |           5060 | Reserved for use by SIP Usage |\n| SIP         |           5061 | Reserved for use by SIP Usage |\n| Reserved    |          65535 |                      RFC 6940 |\n+-------------+----------------+-------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "14.6. Data Kind-ID",
      "section_title": true,
      "ja": "14.6。データ種類-ID"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Data Kind-ID\" registry. Entries in this registry are 32-bit integers denoting data Kinds, as described in Section 5.2 of [RFC6940]. Code points in the range 0x00000001 to 0x7FFFFFFF SHALL be registered via Standards Action [RFC5226]. Code points in the range 0x8000000 to 0xF0000000 SHALL be registered via Expert Review [RFC5226]. Code points in the range 0xF0000001 to 0xFFFFFFFE are reserved for private use via the Kind description mechanism described in Section 11 of [RFC6940]. The initial contents of this registry are:",
      "ja": "IANAは、「RELOADデータ種類-ID」のレジストリを作成しました。 [RFC6940]のセクション5.2に記載したように、このレジストリ内のエントリは、データの種類を示す32ビット整数です。 0x7FFFFFFFでの範囲は0x00000001のコードポイントが標準アクション[RFC5226]を介して、登記しなければなりません。 0xf0000000の範囲0x8000000のコードポイントはエキスパートレビュー[RFC5226]を介して、登記しなければなりません。 0xFFFFFFFEの範囲0xF0000001のコードポイントは、[RFC6940]のセクション11に記載された種類の説明機構を介して私的使用のために予約されています。このレジストリの初期の内容は以下のとおりです。"
    },
    {
      "indent": 13,
      "text": "+---------------------+------------+-----------+\n| Kind                |    Kind-ID | Reference |\n+---------------------+------------+-----------+\n| INVALID             |        0x0 |  RFC 6940 |\n| TURN-SERVICE        |        0x2 |  RFC 6940 |\n| CERTIFICATE_BY_NODE |        0x3 |  RFC 6940 |\n| CERTIFICATE_BY_USER |       0x10 |  RFC 6940 |\n| Reserved            | 0x7fffffff |  RFC 6940 |\n| Reserved            | 0xfffffffe |  RFC 6940 |\n+---------------------+------------+-----------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "14.7. Data Model",
      "section_title": true,
      "ja": "14.7。データ・モデル"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Data Model\" registry. Entries in this registry are strings denoting data models, as described in Section 7.2 of [RFC6940]. New entries in this registry SHALL be registered via Standards Action [RFC5226]. The initial contents of this registry are:",
      "ja": "IANAは、「RELOADデータモデル」のレジストリを作成しました。 [RFC6940]のセクション7.2に記載したように、このレジストリ内のエントリは、データ・モデルを表す文字列です。このレジストリ内の新しいエントリは、標準アクション[RFC5226]を経由して登録するものとします。このレジストリの初期の内容は以下のとおりです。"
    },
    {
      "indent": 24,
      "text": "+------------+-----------+\n| Data Model | Reference |\n+------------+-----------+\n| INVALID    |  RFC 6940 |\n| SINGLE     |  RFC 6940 |\n| ARRAY      |  RFC 6940 |\n| DICTIONARY |  RFC 6940 |\n| EXP-DATA   |  RFC 6940 |\n| RESERVED   |  RFC 6940 |\n+------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value EXP-DATA has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "値EXP-DATAは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "14.8. Message Codes",
      "section_title": true,
      "ja": "14.8。メッセージコード"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Message Codes\" registry. Entries in this registry are 16-bit integers denoting method codes, as described in Section 6.3.3 of [RFC6940]. These codes SHALL be registered via Standards Action [RFC5226]. The initial contents of this registry are:",
      "ja": "IANAは、「RELOADメッセージ・コード」のレジストリを作成しました。 [RFC6940]のセクション6.3.3に記載したように、このレジストリのエントリは、メソッドコードを表す16ビットの整数です。これらのコードは、標準アクション[RFC5226]を経由して登録するものとします。このレジストリの初期の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------------+----------------+-----------+\n| Message Code Name                   |     Code Value | Reference |\n+-------------------------------------+----------------+-----------+\n| invalidMessageCode                  |            0x0 |  RFC 6940 |\n| probe_req                           |            0x1 |  RFC 6940 |\n| probe_ans                           |            0x2 |  RFC 6940 |\n| attach_req                          |            0x3 |  RFC 6940 |\n| attach_ans                          |            0x4 |  RFC 6940 |\n| Unassigned                          |            0x5 |           |\n| Unassigned                          |            0x6 |           |\n| store_req                           |            0x7 |  RFC 6940 |\n| store_ans                           |            0x8 |  RFC 6940 |\n| fetch_req                           |            0x9 |  RFC 6940 |\n| fetch_ans                           |            0xA |  RFC 6940 |\n| Unassigned (was remove_req)         |            0xB |  RFC 6940 |\n| Unassigned (was remove_ans)         |            0xC |  RFC 6940 |\n| find_req                            |            0xD |  RFC 6940 |\n| find_ans                            |            0xE |  RFC 6940 |\n| join_req                            |            0xF |  RFC 6940 |\n| join_ans                            |           0x10 |  RFC 6940 |\n| leave_req                           |           0x11 |  RFC 6940 |\n| leave_ans                           |           0x12 |  RFC 6940 |\n| update_req                          |           0x13 |  RFC 6940 |\n| update_ans                          |           0x14 |  RFC 6940 |\n| route_query_req                     |           0x15 |  RFC 6940 |\n| route_query_ans                     |           0x16 |  RFC 6940 |\n| ping_req                            |           0x17 |  RFC 6940 |\n| ping_ans                            |           0x18 |  RFC 6940 |\n| stat_req                            |           0x19 |  RFC 6940 |\n| stat_ans                            |           0x1A |  RFC 6940 |\n| Unassigned (was attachlite_req)     |           0x1B |  RFC 6940 |\n| Unassigned (was attachlite_ans)     |           0x1C |  RFC 6940 |\n| app_attach_req                      |           0x1D |  RFC 6940 |\n| app_attach_ans                      |           0x1E |  RFC 6940 |\n| Unassigned (was app_attachlite_req) |           0x1F |  RFC 6940 |\n| Unassigned (was app_attachlite_ans) |           0x20 |  RFC 6940 |\n| config_update_req                   |           0x21 |  RFC 6940 |\n| config_update_ans                   |           0x22 |  RFC 6940 |\n| exp_a_req                           |           0x23 |  RFC 6940 |\n| exp_a_ans                           |           0x24 |  RFC 6940 |\n| exp_b_req                           |           0x25 |  RFC 6940 |\n| exp_b_ans                           |           0x26 |  RFC 6940 |\n| Reserved                            | 0x8000..0xFFFE |  RFC 6940 |\n| error                               |         0xFFFF |  RFC 6940 |\n+-------------------------------------+----------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The values exp_a_req, exp_a_ans, exp_b_req, and exp_b_ans have been made available for the purposes of experimentation. These values are not meant for vendor-specific use of any sort, and they MUST NOT be used for operational deployments.",
      "ja": "値exp_a_req、exp_a_ans、exp_b_req、およびexp_b_ansは、実験の目的のために利用可能になっています。これらの値は、あらゆる種類のベンダー固有の使用のために意図されていない、と彼らは業務展開のために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "14.9. Error Codes",
      "section_title": true,
      "ja": "14.9。エラーコード"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Error Code\" registry. Entries in this registry are 16-bit integers denoting error codes, as described in Section 6.3.3.1 of [RFC6940]. New entries SHALL be defined via Standards Action [RFC5226]. The initial contents of this registry are:",
      "ja": "IANAは、「RELOADエラーコード」レジストリを作成しました。 [RFC6940]のセクション6.3.3.1に記載されているように、このレジストリのエントリは、エラーコードを表す16ビットの整数です。新しいエントリは標準アクション[RFC5226]で定義されるものとする（SHALL）。このレジストリの初期の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------------+----------------+-----------+\n| Error Code Name                     |     Code Value | Reference |\n+-------------------------------------+----------------+-----------+\n| invalidErrorCode                    |            0x0 |  RFC 6940 |\n| Unassigned                          |            0x1 |           |\n| Error_Forbidden                     |            0x2 |  RFC 6940 |\n| Error_Not_Found                     |            0x3 |  RFC 6940 |\n| Error_Request_Timeout               |            0x4 |  RFC 6940 |\n| Error_Generation_Counter_Too_Low    |            0x5 |  RFC 6940 |\n| Error_Incompatible_with_Overlay     |            0x6 |  RFC 6940 |\n| Error_Unsupported_Forwarding_Option |            0x7 |  RFC 6940 |\n| Error_Data_Too_Large                |            0x8 |  RFC 6940 |\n| Error_Data_Too_Old                  |            0x9 |  RFC 6940 |\n| Error_TTL_Exceeded                  |            0xA |  RFC 6940 |\n| Error_Message_Too_Large             |            0xB |  RFC 6940 |\n| Error_Unknown_Kind                  |            0xC |  RFC 6940 |\n| Error_Unknown_Extension             |            0xD |  RFC 6940 |\n| Error_Response_Too_Large            |            0xE |  RFC 6940 |\n| Error_Config_Too_Old                |            0xF |  RFC 6940 |\n| Error_Config_Too_New                |           0x10 |  RFC 6940 |\n| Error_In_Progress                   |           0x11 |  RFC 6940 |\n| Error_Exp_A                         |           0x12 |  RFC 6940 |\n| Error_Exp_B                         |           0x13 |  RFC 6940 |\n| Error_Invalid_Message               |           0x14 |  RFC 6940 |\n| Reserved                            | 0x8000..0xFFFE |  RFC 6940 |\n+-------------------------------------+----------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The values Error_Exp_A and Error_Exp_B have been made available for the purposes of experimentation. These values are not meant for vendor-specific use of any sort, and they MUST NOT be used for operational deployments.",
      "ja": "値Error_Exp_AとError_Exp_Bは、実験の目的のために利用可能になっています。これらの値は、あらゆる種類のベンダー固有の使用のために意図されていない、と彼らは業務展開のために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "14.10. Overlay Link Types",
      "section_title": true,
      "ja": "14.10。オーバーレイリンク・タイプ"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Overlay Link Registry\". Entries in this registry are 8-bit integers, as described in Section 6.5.1.1 of [RFC6940]. For more information on the link types defined here, see Section 6.6 of [RFC6940]. New entries SHALL be defined via Standards Action [RFC5226]. This registry has been initially populated with the following values:",
      "ja": "IANAは、「RELOADオーバーレイリンクレジストリ」を作成しました。 [RFC6940]のセクション6.5.1.1に記載されているように、このレジストリのエントリは、8ビットの整数です。ここで定義されたリンクの種類の詳細については、[RFC6940]のセクション6.6を参照してください。新しいエントリは標準アクション[RFC5226]で定義されるものとする（SHALL）。このレジストリは、最初は以下の値が移入されています。"
    },
    {
      "indent": 17,
      "text": "+--------------------+------+-----------+\n| Protocol           | Code | Reference |\n+--------------------+------+-----------+\n| INVALID-PROTOCOL   |    0 |  RFC 6940 |\n| DTLS-UDP-SR        |    1 |  RFC 6940 |\n| DTLS-UDP-SR-NO-ICE |    3 |  RFC 6940 |\n| TLS-TCP-FH-NO-ICE  |    4 |  RFC 6940 |\n| EXP-LINK           |    5 |  RFC 6940 |\n| Reserved           |  255 |  RFC 6940 |\n+--------------------+------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value EXP-LINK has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "値EXP-LINKは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "14.11. Overlay Link Protocols",
      "section_title": true,
      "ja": "14.11。オーバーレイリンクプロトコル"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Overlay Link Protocol Registry\". Entries in this registry are strings denoting protocols as described in Section 11.1 of this document and SHALL be defined via Standards Action [RFC5226]. This registry has been initially populated with the following values:",
      "ja": "IANAは、「RELOADオーバーレイリンクプロトコルレジストリ」を作成しました。このレジストリのエントリはこのドキュメントのセクション11.1に記載されており、標準アクション[RFC5226]で定義されるものとする（SHALL）などのプロトコルを示す文字列です。このレジストリは、最初は以下の値が移入されています。"
    },
    {
      "indent": 23,
      "text": "+---------------+-----------+\n| Link Protocol | Reference |\n+---------------+-----------+\n| TLS           |  RFC 6940 |\n| EXP-PROTOCOL  |  RFC 6940 |\n+---------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value EXP-PROTOCOL has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "値EXP-PROTOCOLは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "14.12. Forwarding Options",
      "section_title": true,
      "ja": "14.12。転送オプション"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Forwarding Option Registry\". Entries in this registry are 8-bit integers denoting options, as described in Section 6.3.2.3 of [RFC6940]. Values between 1 and 127 SHALL be defined via Standards Action [RFC5226]. Entries in this registry between 128 and 254 SHALL be defined via Specification Required [RFC5226]. This registry has been initially populated with the following values:",
      "ja": "IANAは、「RELOAD転送オプションレジストリ」を作成しました。 [RFC6940]のセクション6.3.2.3に記載されているように、このレジストリのエントリは、オプションを表す8ビットの整数です。 1と127の間の値は、標準アクション[RFC5226]を介して定義されなければなりません。 128と254の間のこのレジストリのエントリは、仕様が必要[RFC5226]を介して定義されなければなりません。このレジストリは、最初は以下の値が移入されています。"
    },
    {
      "indent": 14,
      "text": "+-------------------------+------+-----------+\n| Forwarding Option       | Code | Reference |\n+-------------------------+------+-----------+\n| invalidForwardingOption |    0 |  RFC 6940 |\n| exp-forward             |    1 |  RFC 6940 |\n| Reserved                |  255 |  RFC 6940 |\n+-------------------------+------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value exp-forward has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "値EXPフォワードは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "14.13. Probe Information Types",
      "section_title": true,
      "ja": "14.13。プローブ情報の種類"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Probe Information Type Registry\". Entries are 8-bit integers denoting types as described in Section 6.4.2.5.1 of [RFC6940] and SHALL be defined via Standards Action [RFC5226]. This registry has been initially populated with the following values:",
      "ja": "IANAは、「RELOADプローブ情報タイプレジストリ」を作成しました。エントリは、[RFC6940]のセクション6.4.2.5.1に記載されており、標準アクション[RFC5226]で定義されるとおりでなければならないタイプを示す8ビットの整数です。このレジストリは、最初は以下の値が移入されています。"
    },
    {
      "indent": 17,
      "text": "+--------------------+------+-----------+\n| Probe Option       | Code | Reference |\n+--------------------+------+-----------+\n| invalidProbeOption |    0 |  RFC 6940 |\n| responsible_set    |    1 |  RFC 6940 |\n| num_resources      |    2 |  RFC 6940 |\n| uptime             |    3 |  RFC 6940 |\n| exp-probe          |    4 |  RFC 6940 |\n| Reserved           |  255 |  RFC 6940 |\n+--------------------+------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value exp-probe has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "値EXP-プローブは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "14.14. Message Extensions",
      "section_title": true,
      "ja": "14.14。メッセージ拡張機能"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Extensions Registry\". Entries in this registry are 8-bit integers denoting extensions as described in Section 6.3.3 of [RFC6940] and SHALL be defined via Specification Required [RFC5226]. This registry has been initially populated with the following values:",
      "ja": "IANAは、「RELOAD拡張レジストリ」を作成しました。このレジストリのエントリは、[RFC6940]のセクション6.3.3に記載した仕様が必要[RFC5226]で定義されるとおりでなければならない拡張機能を示す8ビットの整数です。このレジストリは、最初は以下の値が移入されています。"
    },
    {
      "indent": 11,
      "text": "+-----------------------------+--------+-----------+\n| Extensions Name             |   Code | Reference |\n+-----------------------------+--------+-----------+\n| invalidMessageExtensionType |    0x0 |  RFC 6940 |\n| exp-ext                     |    0x1 |  RFC 6940 |\n| Reserved                    | 0xFFFF |  RFC 6940 |\n+-----------------------------+--------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value exp-ext has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.",
      "ja": "値EXP-extは、実験の目的のために利用可能になっています。この値は、任意の並べ替えのベンダー固有の使用のために意図されていない、それは運用の展開のために使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "14.15. Reload URI Scheme",
      "section_title": true,
      "ja": "14.15。 URIスキームをリロード"
    },
    {
      "indent": 3,
      "text": "This section describes the scheme for a reload URI, which can be used to refer to either:",
      "ja": "このセクションでは、いずれかを指すために使用することができるリロードURIのためのスキームを示します。"
    },
    {
      "indent": 3,
      "text": "o A peer, e.g., as used in a certificate (see Section 11.3 of [RFC6940]).",
      "ja": "ピアO、例えば、証明書で使用される（[RFC6940]のセクション11.3を参照）。"
    },
    {
      "indent": 3,
      "text": "o A resource inside a peer.",
      "ja": "ピア内部リソースO。"
    },
    {
      "indent": 3,
      "text": "The reload URI is defined using a subset of the URI schema specified in Appendix A of RFC 3986 [RFC3986] and the associated URI Guidelines [RFC4395] per the following ABNF syntax:",
      "ja": "リロードURIは、以下のABNF構文ごとにRFC 3986 [RFC3986]の付録Aおよび関連するURIガイドライン[RFC4395]で指定されたURIスキーマのサブセットを使用して定義されます。"
    },
    {
      "indent": 6,
      "text": "RELOAD-URI = \"reload://\" destination \"@\" overlay \"/\" [specifier] destination = 1*HEXDIG overlay = reg-name specifier = 1*HEXDIG",
      "ja": "RELOAD-URI = \"リロード：//\" 先 \"@\" オーバーレイ \"/\" [指定]先= 1 * HEXDIGオーバーレイ= REG-名指定子= 1 * HEXDIG"
    },
    {
      "indent": 3,
      "text": "The definitions of these productions are as follows:",
      "ja": "次のようにこれらの作品の定義は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "destination A hexadecimal-encoded Destination List object (i.e., multiple concatenated Destination objects with no length prefix prior to the object as a whole).",
      "ja": "先進符号化された宛先リストオブジェクト（前全体としてオブジェクトにない長さプレフィックス付き即ち、複数の連結された宛先オブジェクト）。"
    },
    {
      "indent": 3,
      "text": "overlay The name of the overlay.",
      "ja": "オーバーレイの名前をオーバーレイ。"
    },
    {
      "indent": 3,
      "text": "specifier A hexadecimal-encoded StoredDataSpecifier indicating the data element.",
      "ja": "データ要素を表す16進符号化されたStoredDataSpecifierを指定。"
    },
    {
      "indent": 3,
      "text": "If no specifier is present, this URI addresses the peer which can be reached via the indicated Destination List at the indicated overlay name. If a specifier is present, the URI addresses the data value.",
      "ja": "何も指定子が存在しない場合は、このURIが示されたオーバーレイ名で指示された宛先リストを介して到達することができ、ピアに対応しています。指定子が存在する場合、URIは、データ値に対応しています。"
    },
    {
      "indent": 0,
      "text": "14.15.1. URI Registration",
      "section_title": true,
      "ja": "14.15.1。 URIの登録"
    },
    {
      "indent": 3,
      "text": "The following summarizes the information necessary to register the reload URI.",
      "ja": "以下は、リロードURIを登録するために必要な情報をまとめたもの。"
    },
    {
      "indent": 3,
      "text": "URI Scheme Name: reload",
      "ja": "URIスキーム名：リロード"
    },
    {
      "indent": 3,
      "text": "Status: permanent",
      "ja": "ステータス：永久"
    },
    {
      "indent": 3,
      "text": "URI Scheme Syntax: see Section 14.15 of RFC 6940",
      "ja": "URIスキーム構文：RFC 6940のセクション14.15を参照してください"
    },
    {
      "indent": 3,
      "text": "URI Scheme Semantics: The reload URI is intended to be used as a reference to a RELOAD peer or resource.",
      "ja": "URIスキーム意味：リロードURIをリロードピアまたはリソースへの参照として使用されることが意図されています。"
    },
    {
      "indent": 3,
      "text": "Encoding Considerations: The reload URI is not intended to be human-readable text, so it is encoded entirely in US-ASCII.",
      "ja": "エンコーディングに関する注意事項：それはUS-ASCIIで完全にエンコードされているので、リロードURIは、人間が読めるテキストであることを意図したものではありません。"
    },
    {
      "indent": 3,
      "text": "Applications/protocols that Use this URI Scheme: The RELOAD protocol described in RFC 6940.",
      "ja": "このURIスキームを使用するアプリケーション/プロトコル：RFC 6940で説明RELOADプロトコル。"
    },
    {
      "indent": 3,
      "text": "Interoperability Considerations: See RFC 6940.",
      "ja": "相互運用性に関する注意事項：RFC 6940を参照してください。"
    },
    {
      "indent": 3,
      "text": "Security Considerations: See RFC 6940",
      "ja": "セキュリティの考慮事項：参照してください。RFC 6940"
    },
    {
      "indent": 3,
      "text": "Contact: Cullen Jennings <fluffy@cisco.com>",
      "ja": "連絡先：カレン・ジェニングス<fluffy@cisco.com>"
    },
    {
      "indent": 3,
      "text": "Author/Change Controller: IESG",
      "ja": "著者/変更コントローラ：IESG"
    },
    {
      "indent": 3,
      "text": "References: RFC 6940",
      "ja": "参考文献：RFC 6940"
    },
    {
      "indent": 0,
      "text": "14.16. Media Type Registration",
      "section_title": true,
      "ja": "14.16。メディアタイプ登録"
    },
    {
      "indent": 3,
      "text": "Type Name: application",
      "ja": "タイプ名：アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype Name: p2p-overlay+xml",
      "ja": "サブタイプ名：P2Pオーバーレイ+ xmlの"
    },
    {
      "indent": 3,
      "text": "Required Parameters: none",
      "ja": "必要なパラメータ：なし"
    },
    {
      "indent": 3,
      "text": "Optional Parameters: none",
      "ja": "オプションパラメータ：なし"
    },
    {
      "indent": 3,
      "text": "Encoding Considerations: Must be binary encoded.",
      "ja": "留意事項をコードする：バイナリエンコードする必要があります。"
    },
    {
      "indent": 3,
      "text": "Security Considerations: This media type is typically not used to transport information that needs to be kept confidential. However, there are cases where it is integrity of the information is important. For these cases, using a digital signature is RECOMMENDED. One way of doing this is specified in RFC 6940. In the case when the media includes a shared-secret element, the contents of the file MUST be kept confidential or else anyone who can see the shared secret can affect the RELOAD overlay network.",
      "ja": "セキュリティの考慮：このメディアタイプは、一般的に機密を維持する必要がある情報を輸送するのに使用されていません。しかし、それは情報の整合性が重要である場合があります。このような場合のために、デジタル署名を使用することは推奨されています。これを行う1つの方法は、メディアが共有秘密要素を含む場合にはRFC 6940.に指定され、ファイルの内容が秘密にしなければならないか、または他の共有秘密を見ることができる誰もがRELOADオーバレイネットワークに影響を与えることができます。"
    },
    {
      "indent": 3,
      "text": "Interoperability Considerations: No known interoperability consideration beyond those identified for application/xml in [RFC3023].",
      "ja": "相互運用性に関する注意事項：[RFC3023]でアプリケーション/ xmlのために特定されたものを超えない既知の相互運用性の検討。"
    },
    {
      "indent": 3,
      "text": "Published Specification: RFC 6940",
      "ja": "公開された仕様：RFC 6940"
    },
    {
      "indent": 3,
      "text": "Applications that Use this Media Type: The type is used to configure the peer-to-peer overlay networks defined in RFC 6940.",
      "ja": "このメディアタイプを使用するアプリケーション：タイプは、RFC 6940で定義されたピア・ツー・ピアオーバーレイネットワークを構成するために使用されています。"
    },
    {
      "indent": 3,
      "text": "Additional Information: The syntax for this media type is specified in Section 11.1 of [RFC6940]. The contents MUST be valid XML that is compliant with the RELAX NG grammar specified in RFC 6940 and that use the UTF-8[RFC3629] character encoding.",
      "ja": "追加情報：このメディアタイプの構文は、[RFC6940]のセクション11.1に指定されています。内容は、RFC 6940で指定されたRELAX NG文法に準拠しており、それはUTF-8 [RFC3629]の文字エンコードを使用し、有効なXMLでなければなりません。"
    },
    {
      "indent": 6,
      "text": "Magic Number(s): none",
      "ja": "マジックナンバー（S）：なし"
    },
    {
      "indent": 6,
      "text": "File Extension(s): relo",
      "ja": "RELO：拡張（複数可）ファイル"
    },
    {
      "indent": 6,
      "text": "Macintosh File Type Code(s): none",
      "ja": "Macintoshのファイルタイプコード（S）：なし"
    },
    {
      "indent": 3,
      "text": "Person & Email Address to Contact for Further Information: Cullen Jennings <fluffy@cisco.com>",
      "ja": "人と詳細のために連絡するEメー​​ルアドレス：カレン・ジェニングス<fluffy@cisco.com>"
    },
    {
      "indent": 3,
      "text": "Intended Usage: COMMON",
      "ja": "意図した使用法：COMMON"
    },
    {
      "indent": 3,
      "text": "Restrictions on Usage: None",
      "ja": "使用上の制限：なし"
    },
    {
      "indent": 3,
      "text": "Author: Cullen Jennings <fluffy@cisco.com>",
      "ja": "著者：カレン・ジェニングス<fluffy@cisco.com>"
    },
    {
      "indent": 3,
      "text": "Change Controller: IESG",
      "ja": "変更コントローラ：IESG"
    },
    {
      "indent": 0,
      "text": "14.17. XML Namespace Registration",
      "section_title": true,
      "ja": "14.17。 XML名前空間の登録"
    },
    {
      "indent": 3,
      "text": "This document registers two URIs for the config and config-chord XML namespaces in the IETF XML registry defined in [RFC3688].",
      "ja": "このドキュメントは[RFC3688]で定義されたIETF XMLレジストリの設定とCONFIG-コードXML名前空間のための2つのURIを登録します。"
    },
    {
      "indent": 0,
      "text": "14.17.1. Config URL",
      "section_title": true,
      "ja": "14.17.1。コンフィグURL"
    },
    {
      "indent": 3,
      "text": "URI: urn:ietf:params:xml:ns:p2p:config-base",
      "ja": "URI：URN：IETF：のparams：XML：NS：P2Pます。config-ベース"
    },
    {
      "indent": 3,
      "text": "Registrant Contact: IESG.",
      "ja": "登録者連絡先：IESG。"
    },
    {
      "indent": 3,
      "text": "XML: N/A, the requested URIs are XML namespaces",
      "ja": "XML：N / A、要求されたURIは、XML名前空間です"
    },
    {
      "indent": 0,
      "text": "14.17.2. Config Chord URL",
      "section_title": true,
      "ja": "14.17.2。コンフィグ和音URL"
    },
    {
      "indent": 3,
      "text": "URI: urn:ietf:params:xml:ns:p2p:config-chord",
      "ja": "URI：URN：IETF：のparams：XML：NS：P2Pます。config-和音"
    },
    {
      "indent": 3,
      "text": "Registrant Contact: The IESG.",
      "ja": "登録者連絡先：IESG。"
    },
    {
      "indent": 3,
      "text": "XML: N/A, the requested URIs are XML namespaces",
      "ja": "XML：N / A、要求されたURIは、XML名前空間です"
    },
    {
      "indent": 0,
      "text": "15. Acknowledgments",
      "section_title": true,
      "ja": "15.謝辞"
    },
    {
      "indent": 3,
      "text": "This specification is a merge of the \"REsource LOcation And Discovery (RELOAD)\" document by David A. Bryan, Marcia Zangrilli, and Bruce B. Lowekamp; the \"Address Settlement by Peer to Peer\" document by Cullen Jennings, Jonathan Rosenberg, and Eric Rescorla; the \"Security Extensions for RELOAD\" document by Bruce B. Lowekamp and James Deverick; the \"A Chord-based DHT for Resource Lookup in P2PSIP\" by Marcia Zangrilli and David A. Bryan; and the Peer-to-Peer Protocol (P2PP) document by Salman A. Baset, Henning Schulzrinne, and Marcin Matuszewski. Thanks to the authors of [RFC5389] for text included from that document. Vidya Narayanan provided many comments and improvements.",
      "ja": "この仕様は、デビッド・A・ブライアン、マーシャZangrilli、そしてブルースB. Lowekampによる「資源の場所とディスカバリー（RELOAD）」文書のマージです。カレンジェニングス、ジョナサン・ローゼンバーグ、そしてエリックレスコラ、文書を「ピアツーピアによるアドレス決済」。ブルースB. LowekampとジェームズDeverickによる「セキュリティ拡張機能RELOADための」文書。マーシャZangrilliとDavid A.ブライアンによる「P2PSIPにおけるリソースのルックアップのためのAコードベースのDHT」。そしてサルマンA. BASET、ヘンイング・シュルツリン、及びマルチンMatuszewskiによるピア・ツー・ピア・プロトコル（P2PP）ドキュメント。テキストのための[RFC5389]の作者のおかげでその文書から含まれています。 Vidyaナラヤナンは多くのコメントや改善を提供します。"
    },
    {
      "indent": 3,
      "text": "The ideas and text for the Chord-specific extension data to the Leave mechanisms were provided by Jouni Maenpaa, Gonzalo Camarillo, and Jani Hautakorpi.",
      "ja": "休暇メカニズムに和音固有の拡張データのためのアイデアやテキストはJouni Maenpaa、ゴンサロ・カマリロ、およびヤニHautakorpiによって提供されました。"
    },
    {
      "indent": 3,
      "text": "Thanks to the many people who contributed, including Ted Hardie, Michael Chen, Dan York, Das Saumitra, Lyndsay Campbell, Brian Rosen, David Bryan, Dave Craig, and Julian Cain. Extensive last call comments were provided by Jouni Maenpaa, Roni Even, Gonzalo Camarillo, Ari Keranen, John Buford, Michael Chen, Frederic-Philippe Met, Mary Barnes, Roland Bless, David Bryan, and Polina Goltsman. Special thanks to Marc Petit-Huguenin, who provided an amazing amount of detailed review.",
      "ja": "テッド・ハーディ、マイケル・チェン、ダン・ニューヨーク、ダスSaumitra、リンゼー・キャンベル、ブライアン・ローゼン、デヴィッド・ブライアン、デイブ・クレイグ、そしてジュリアン・カインを含む貢献し、多くの人々に感謝します。豊富なラストコールコメントはJouni Maenpaa、ロニでも、ゴンサロ・カマリロ、アリKeranen、ジョン・ビュフォード、マイケル・チェン、フレデリック・フィリップメット、メアリー・バーンズ、ローランドが祝福、デヴィッド・ブライアン、およびポリーナGoltsmanによって提供されました。詳細なレビューの驚くべき量を提供マルク・プティ・Huguenin、に感謝します。"
    },
    {
      "indent": 3,
      "text": "Dean Willis and Marc Petit-Huguenin helped resolve and provided text to fix many comments received during the IESG review.",
      "ja": "ディーンウィリスとマルク・プティ・Hugueninは解決助けとIESGレビュー中に受信した多くのコメントを修正するためのテキストを提供しました。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16.参考文献"
    },
    {
      "indent": 0,
      "text": "16.1. Normative References",
      "section_title": true,
      "ja": "16.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[OASIS.relax_ng] Bray, T. and M. Murata, \"RELAX NG Specification\", December 2001.",
      "ja": "【OASIS.relax_ng]ブレイ、T.及びM.村田、2001年12月 \"NG仕様RELAX\"。"
    },
    {
      "indent": 3,
      "text": "[RFC1918] Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and E. Lear, \"Address Allocation for Private Internets\", BCP 5, RFC 1918, February 1996.",
      "ja": "[RFC1918] Rekhter、Y.、モスコウィッツ、R.、Karrenberg、D.、グルート、G.、およびE.リア、 \"個人的なインターネットのための配分\"、BCP 5、RFC 1918、1996年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2388] Masinter, L., \"Returning Values from Forms: multipart/ form-data\", RFC 2388, August 1998.",
      "ja": "[RFC2388] Masinter、L.、 \"フォームからの値返す：multipart / form-data\" を、RFC 2388、1998年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2585] Housley, R. and P. Hoffman, \"Internet X.509 Public Key Infrastructure Operational Protocols: FTP and HTTP\", RFC 2585, May 1999.",
      "ja": "[RFC2585] Housley氏、R.とP.ホフマン、 \"インターネットX.509公開鍵基盤運用プロトコル：FTPやHTTP\"、RFC 2585、1999年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, February 2000.",
      "ja": "[RFC2782] Gulbrandsenの、A.、いるVixie、P.、およびL. Esibov、 \"サービスの場所を特定するためのDNS RR（DNSのSRV）\"、RFC 2782、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.",
      "ja": "[RFC2818]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3023] Murata, M., St. Laurent, S., and D. Kohn, \"XML Media Types\", RFC 3023, January 2001.",
      "ja": "[RFC3023]村田、M.、サンローラン、S.、およびD.コーン、 \"XMLのメディアタイプ\"、RFC 3023、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3174] Eastlake, D. and P. Jones, \"US Secure Hash Algorithm 1 (SHA1)\", RFC 3174, September 2001.",
      "ja": "[RFC3174]イーストレイク、D.とP.ジョーンズは、 \"米国は、ハッシュアルゴリズム1（SHA1）を確保\"、RFC 3174、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3339] Klyne, G., Ed. and C. Newman, \"Date and Time on the Internet: Timestamps\", RFC 3339, July 2002.",
      "ja": "[RFC3339] Klyne、G.、エド。そして、C.ニューマン、「インターネット上の日付と時刻：タイムスタンプ」、RFC 3339、2002年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003.",
      "ja": "[RFC3447]ジョンソン、J.とB. Kaliski、 \"公開鍵暗号規格（PKCS）＃1：RSA暗号仕様バージョン2.1\"、RFC 3447、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4279] Eronen, P. and H. Tschofenig, \"Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)\", RFC 4279, December 2005.",
      "ja": "[RFC4279] Eronen、P.とH. Tschofenig、RFC 4279 \"トランスポート層セキュリティ（TLS）のための事前共有鍵暗号の組み合わせ\"、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4395] Hansen, T., Hardie, T., and L. Masinter, \"Guidelines and Registration Procedures for New URI Schemes\", BCP 35, RFC 4395, February 2006.",
      "ja": "[RFC4395]ハンセン、T.、ハーディ、T.、およびL. Masinter、 \"新しいURIスキームのためのガイドラインと登録手順\"、BCP 35、RFC 4395、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、2006年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5245] Rosenberg, J., \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols\", RFC 5245, April 2010.",
      "ja": "[RFC5245]ローゼンバーグ、J.、 \"インタラクティブ接続確立（ICE）：オファー/回答プロトコルのためのネットワークアドレス変換（NAT）トラバーサルのための議定書\"、RFC 5245、2010年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5272] Schaad, J. and M. Myers, \"Certificate Management over CMS (CMC)\", RFC 5272, June 2008.",
      "ja": "[RFC5272] Schaad、J.とM.マイヤーズ、 \"CMSオーバー証明書の管理（CMC）\"、RFC 5272、2008年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5273] Schaad, J. and M. Myers, \"Certificate Management over CMS (CMC): Transport Protocols\", RFC 5273, June 2008.",
      "ja": "[RFC5273] Schaad、J.とM.マイヤーズ、 \"CMS（CMC）以上の証明書の管理：トランスポートプロトコル\"、RFC 5273、2008年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, \"Session Traversal Utilities for NAT (STUN)\", RFC 5389, October 2008.",
      "ja": "[RFC5389]ローゼンバーグ、J.、マーイ、R.、マシューズ、P.、およびD.翼、 \"NAT（STUN）のセッショントラバーサルユーティリティ\"、RFC 5389、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5405] Eggert, L. and G. Fairhurst, \"Unicast UDP Usage Guidelines for Application Designers\", BCP 145, RFC 5405, November 2008.",
      "ja": "[RFC5405]エッゲルト、L.とG. Fairhurst、 \"アプリケーションデザイナーのためのユニキャストUDPの使用上の注意事項\"、BCP 145、RFC 5405、2008年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5766] Mahy, R., Matthews, P., and J. Rosenberg, \"Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)\", RFC 5766, April 2010.",
      "ja": "[RFC5766]マーイ、R.、マシューズ、P.、およびJ.ローゼンバーグ、 \"トラバーサルNAT（TURN）の周りにリレーを使用してリレー拡張NAT（STUN）のセッショントラバーサルユーティリティに\"、RFC 5766、2010年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5952] Kawamura, S. and M. Kawashima, \"A Recommendation for IPv6 Address Text Representation\", RFC 5952, August 2010.",
      "ja": "[RFC5952]川村、S.とM.川島、RFC 5952、2010年8月、 \"IPv6アドレスのテキスト表現のための勧告\"。"
    },
    {
      "indent": 3,
      "text": "[RFC6091] Mavrogiannopoulos, N. and D. Gillmor, \"Using OpenPGP Keys for Transport Layer Security (TLS) Authentication\", RFC 6091, February 2011.",
      "ja": "[RFC6091] Mavrogiannopoulos、N.およびD. Gillmor氏、RFC 6091、2011年2月 \"トランスポート層セキュリティ（TLS）認証のためのOpenPGPキーの使用\"。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, May 2011.",
      "ja": "[RFC6234]イーストレイク、D.とT.ハンセンは、 \"米国は、ハッシュアルゴリズム（SHAとSHAベースのHMACとHKDF）を確保\"、RFC 6234、2011年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, June 2011.",
      "ja": "[RFC6298]パクソン、V.、オールマン、M.、チュー、J.、およびM.サージェント、 \"コンピューティングTCPの再送信タイマー\"、RFC 6298、2011年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, January 2012.",
      "ja": "[RFC6347]レスコラ、E.およびN. Modadugu、 \"データグラムトランスポート層セキュリティバージョン1.2\"、RFC 6347、2012年1月。"
    },
    {
      "indent": 3,
      "text": "[W3C.REC-xmlschema-2-20041028] Malhotra, A. and P. Biron, \"XML Schema Part 2: Datatypes Second Edition\", World Wide Web Consortium Recommendation REC-xmlschema-2-20041028, October 2004, <http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.",
      "ja": "[W3C.REC-XMLSCHEMA-2から20041028]マルホトラ、A.、およびP.ビロン、 \"XMLスキーマパート2：データ型第二版\"、World Wide Web Consortium（W3C）の勧告REC-XMLSCHEMA-2から20041028、2004年10月、<のhttp： //www.w3.org/TR/2004/REC-xmlschema-2-20041028>。"
    },
    {
      "indent": 3,
      "text": "[w3c-xml-namespaces] Bray, T., Hollander, D., Layman, A., Tobin, R., and University of Edinburgh and W3C, \"Namespaces in XML 1.0 (Third Edition)\", December 2008.",
      "ja": "[W3C-XML-名前空間]ブレイ、T.、オランダ、D.、素人、A.、トービン、R.、エディンバラとW3Cの大学、 \"XML 1.0での名前空間（第3版）\"、2008年12月。"
    },
    {
      "indent": 0,
      "text": "16.2. Informative References",
      "section_title": true,
      "ja": "16.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[Chord] Stoica, I., Morris, R., Liben-Nowell, D., Karger, D., Kaashoek, M., Dabek, F., and H. Balakrishnan, \"Chord: A Scalable Peer-to-peer Lookup Protocol for Internet Applications\", IEEE/ACM Transactions on Networking Volume 11, Issue 1, 17-32, Feb 2003, 2001.",
      "ja": "[コード] Stoicaの、I.、モリス、R.、リベニ-Nowell、D.、カーガー、D.、Kaashoek、M.、Dabek、F.、及びH.バラクリシュナン、「コード：スケーラブルなピアツーピアネットワーク11巻、1号、17-32、2003年2月、2001年のインターネットアプリケーション」、IEEE / ACM取引のためのルックアップのプロトコル。"
    },
    {
      "indent": 3,
      "text": "[DHT-RELOAD] Maenpaa, J. and G. Camarillo, \"A Self-tuning Distributed Hash Table (DHT) for REsource LOcation And Discovery (RELOAD)\", Work in Progress, August 2013.",
      "ja": "[DHTリロード] Maenpaa、J.及びG.カマリロ、進歩、2013年8月に働いて「リソースロケーションとディスカバリー（リロード）するためのハッシュテーブル（DHT）分散セルフチューニング」。"
    },
    {
      "indent": 3,
      "text": "[Eclipse] Singh, A., Ngan, T., Druschel, T., and D. Wallach, \"Eclipse Attacks on Overlay Networks: Threats and Defenses\", INFOCOM 2006, April 2006.",
      "ja": "[Eclipseの]シン、A.、ンガン、T.、Druschel、T.、およびD.ウォラック、 \"オーバレイネットワーク上のEclipseの攻撃：脅威と防御\"、インフォコム2006年、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[P2P-DIAGNOSTICS] Song, H., Jiang, X., Even, R., and D. Bryan, \"P2P Overlay Diagnostics\", Work in Progress, August 2013.",
      "ja": "[P2P-DIAGNOSTICS]ソング、H.、江、X.、でも、R.、およびD.ブライアン、 \"P2Pオーバーレイ診断\"、進歩、2013年8月での作業。"
    },
    {
      "indent": 3,
      "text": "[P2PSIP-RELAY] Zong, N., Jiang, X., Even, R., and Y. Zhang, \"An extension to RELOAD to support Relay Peer Routing\", Work in Progress, October 2013.",
      "ja": "[P2PSIP-RELAY]宗、N.、江、X.、でも、R.、およびY.チャンは、進歩、2013年10月に、ワーク \"拡張子が中継ピアのルーティングをサポートするためにリロードします\"。"
    },
    {
      "indent": 3,
      "text": "[REDIR-RELOAD] Maenpaa, J. and G. Camarillo, \"Service Discovery Usage for REsource LOcation And Discovery (RELOAD)\", Work in Progress, August 2013.",
      "ja": "[REDIRリロード] Maenpaa、J.およびG.キャマリロ、「リソースロケーションとディスカバリー（リロード）するためのサービス発見の使用」、進歩、2013年8月に働いています。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, November 1987.",
      "ja": "[RFC1035] Mockapetris、P.、 \"ドメイン名 - 実装及び仕様\"、STD 13、RFC 1035、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122]ブレーデン、R.、 \"インターネットホストのための要件 - 通信層\"、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2311] Dusse, S., Hoffman, P., Ramsdell, B., Lundblade, L., and L. Repka, \"S/MIME Version 2 Message Specification\", RFC 2311, March 1998.",
      "ja": "[RFC2311] Dusse、S.、ホフマン、P.、Ramsdell、B.、Lundblade、L.、及びL. Repka、 \"S / MIMEバージョン2メッセージ仕様\"、RFC 2311、1998年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3688] Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, January 2004.",
      "ja": "[RFC3688] Mealling、M.、 \"IETF XMLレジストリ\"、BCP 81、RFC 3688、2004年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4013] Zeilenga, K., \"SASLprep: Stringprep Profile for User Names and Passwords\", RFC 4013, February 2005.",
      "ja": "[RFC4013] Zeilenga、K.、 \"SASLprep：ユーザ名とパスワードのためのstringprepプロフィール\"、RFC 4013、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4145] Yon, D. and G. Camarillo, \"TCP-Based Media Transport in the Session Description Protocol (SDP)\", RFC 4145, September 2005.",
      "ja": "[RFC4145]ヨン、D.とG.カマリロ、 \"TCPベースのセッション記述プロトコル（SDP）にメディアトランスポート\"、RFC 4145、2005年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4340] Kohler, E., Handley, M., and S. Floyd, \"Datagram Congestion Control Protocol (DCCP)\", RFC 4340, March 2006.",
      "ja": "[RFC4340]コーラー、E.、ハンドリー、M.、およびS.フロイド、 \"データグラム輻輳制御プロトコル（DCCP）\"、RFC 4340、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4787] Audet, F. and C. Jennings, \"Network Address Translation (NAT) Behavioral Requirements for Unicast UDP\", BCP 127, RFC 4787, January 2007.",
      "ja": "[RFC4787] Audet、F.とC.ジェニングス、 \"ネットワークアドレス変換（NAT）ユニキャストUDPのための行動の要件\"、BCP 127、RFC 4787、2007年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., \"Stream Control Transmission Protocol\", RFC 4960, September 2007.",
      "ja": "[RFC4960]スチュワート、R.、 \"ストリーム制御伝送プロトコル\"、RFC 4960、2007年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5054] Taylor, D., Wu, T., Mavrogiannopoulos, N., and T. Perrin, \"Using the Secure Remote Password (SRP) Protocol for TLS Authentication\", RFC 5054, November 2007.",
      "ja": "[RFC5054]テイラー、D.、呉、T.、Mavrogiannopoulos、N.、およびT.ペリン、 \"セキュアリモートパスワードの使い方（SRP）TLS認証のためのプロトコル\"、RFC 5054、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5095] Abley, J., Savola, P., and G. Neville-Neil, \"Deprecation of Type 0 Routing Headers in IPv6\", RFC 5095, December 2007.",
      "ja": "[RFC5095] Abley、J.、Savola、P.、およびG.ネビル・ニール、RFC 5095、2007年12月の \"IPv6におけるタイプ0ルーティングヘッダの廃止\"。"
    },
    {
      "indent": 3,
      "text": "[RFC5201] Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, \"Host Identity Protocol\", RFC 5201, April 2008.",
      "ja": "[RFC5201]モスコウィッツ、R.、Nikander、P.、Jokela、P.、およびT.ヘンダーソン、 \"ホストアイデンティティプロトコル\"、RFC 5201、2008年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5694] Camarillo, G., Ed., and IAB, \"Peer-to-Peer (P2P) Architecture: Definition, Taxonomies, Examples, and Applicability\", RFC 5694, November 2009.",
      "ja": "[RFC5694]キャマリロ、G.、エド、およびIAB、 \"ピア・ツー・ピア（P2P）アーキテクチャ：定義、分類法、例、および適用性\"、RFC 5694、2009年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5765] Schulzrinne, H., Marocco, E., and E. Ivov, \"Security Issues and Solutions in Peer-to-Peer Systems for Realtime Communications\", RFC 5765, February 2010.",
      "ja": "[RFC5765] Schulzrinneと、H.、Marocco、E.、およびE. Ivov、 \"セキュリティの問題やリアルタイムコミュニケーションのためのピア・ツー・ピアシステムにおけるソリューション\"、RFC 5765、2010年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC5785] Nottingham, M. and E. Hammer-Lahav, \"Defining Well-Known Uniform Resource Identifiers (URIs)\", RFC 5785, April 2010.",
      "ja": "[RFC5785]ノッティンガム、M.とE.ハンマー -  Lahav、 \"既知のUniform Resource Identifier（URI）を定義\"、RFC 5785、2010年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC6079] Camarillo, G., Nikander, P., Hautakorpi, J., Keranen, A., and A. Johnston, \"HIP BONE: Host Identity Protocol (HIP) Based Overlay Networking Environment (BONE)\", RFC 6079, January 2011.",
      "ja": "[RFC6079]キャマリロ、G.、Nikander、P.、Hautakorpi、J.、Keranen、A.、およびA.ジョンストン、 \"HIP骨：ホストアイデンティティプロトコル（HIP）ベースのオーバレイネットワーク環境（骨）\"、RFC 6079、 2011年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6544] Rosenberg, J., Keranen, A., Lowekamp, B., and A. Roach, \"TCP Candidates with Interactive Connectivity Establishment (ICE)\", RFC 6544, March 2012.",
      "ja": "[RFC6544]ローゼンバーグ、J.、Keranen、A.、Lowekamp、B.、およびA.ローチ、RFC 6544、2012年3月 \"インタラクティブ接続確立（ICE）とTCP候補\"。"
    },
    {
      "indent": 3,
      "text": "[RFC7086] Keranen, A., Camarillo, G., and J. Maenpaa, \"Host Identity Protocol-Based Overlay Networking Environment (HIP BONE) Instance Specification for REsource LOcation And Discovery (RELOAD)\", RFC 7086, January 2014.",
      "ja": "[RFC7086] Keranen、A.、カマリロ、G.、およびJ. Maenpaa、 \"ホストアイデンティティプロトコルベースのオーバレイネットワーク環境（寛骨）リソースロケーションと発見のためのインスタンス仕様（リロード）\"、RFC 7086、2014年1月。"
    },
    {
      "indent": 3,
      "text": "[SIP-RELOAD] Jennings, C., Lowekamp, B., Rescorla, E., Baset, S., Schulzrinne, H., and T. Schmidt, \"A SIP Usage for RELOAD\", Work in Progress, July 2013.",
      "ja": "[SIPリロード]ジェニングス、C.、Lowekamp、B.、レスコラ、E.、BASET、S.、Schulzrinneと、H.、およびT.シュミット、 \"リロードのSIPの使用\"、進歩、2013年7月に働いています。"
    },
    {
      "indent": 3,
      "text": "[Sybil] Douceur, J., \"The Sybil Attack\", IPTPS 02, March 2002.",
      "ja": "[シビル]ドゥスール、J.、 \"シビル・アタック\"、2002年3月、02 IPTPS。"
    },
    {
      "indent": 3,
      "text": "[UnixTime] Wikipedia, \"Unix Time\", 2013, <http://en.wikipedia.org/w/ index.php?title=Unix_time&oldid=551527446>.",
      "ja": "[UnixTime]ウィキペディア、 \"Unixの時間\"、2013年、<http://en.wikipedia.org/w/のindex.php？タイトル= UNIX_TIME＆oldid = 551527446>。"
    },
    {
      "indent": 3,
      "text": "[bryan-design-hotp2p08] Bryan, D., Lowekamp, B., and M. Zangrilli, \"The Design of a Versatile, Secure P2PSIP Communications Architecture for the Public Internet\", Hot-P2P'08, 2008.",
      "ja": "[ブライアン・デザインhotp2p08]ブライアン、D.、Lowekamp、B.、およびM. Zangrilli、「万能の設計、公衆インターネットのためのセキュアなP2PSIPコミュニケーションアーキテクチャ」、ホットP2P'08、2008。"
    },
    {
      "indent": 3,
      "text": "[handling-churn-usenix04] Rhea, S., Geels, D., Roscoe, T., and J. Kubiatowicz, \"Handling Churn in a DHT\", In Proc. of the USENIX Annual Technical Conference June 2004 USENIX 2004, 2004.",
      "ja": "[処理 - チャーン -  usenix04]レア、S.、Geels、D.、ロスコー、T.、およびJ. Kubiatowiczは、PROCで、 \"DHTにチャーンを処理します\"。 USENIX年次専門技術セミナー2004年6月USENIX 2004、2004。"
    },
    {
      "indent": 3,
      "text": "[lookups-churn-p2p06] Wu, D., Tian, Y., and K. Ng, \"Analytical Study on Improving DHT Lookup Performance under Churn\", IEEE P2P'06, 2006.",
      "ja": "[検索-解約-p2p06]呉、D.、天、Y.、およびK.ン、 \"解約下DHTルックアップパフォーマンスの向上に関する解析的検討\"、IEEE P2P'06、2006。"
    },
    {
      "indent": 3,
      "text": "[minimizing-churn-sigcomm06] Godfrey, P., Shenker, S., and I. Stoica, \"Minimizing Churn in Distributed Systems\", SIGCOMM 2006, 2006.",
      "ja": "[最小限 - チャーン -  sigcomm06]ゴッド、P.、Shenker、S.、およびI.ストイカ、 \"分散システムにおける最小化チャーン\"、SIGCOMM 2006 2006"
    },
    {
      "indent": 3,
      "text": "[non-transitive-dhts-worlds05] Freedman, M., Lakshminarayanan, K., Rhea, S., and I. Stoica, \"Non-Transitive Connectivity and DHTs\", WORLDS'05, 2005.",
      "ja": "[非推移-のDHT-worlds05]フリードマン、M.、Lakshminarayanan、K.、レア、S.、およびI.ストイカ、 \"非推移コネクタとのDHT\"、WORLDS'05 2005。"
    },
    {
      "indent": 3,
      "text": "[opendht-sigcomm05] Rhea, S., Godfrey, B., Karp, B., Kubiatowicz, J., Ratnasamy, S., Shenker, S., Stoica, I., and H. Yu, \"OpenDHT: A Public DHT and its Uses\", SIGCOMM'05, 2005.",
      "ja": "[opendht-sigcomm05]レア、S.、ゴッド、B.、カープ、B.、Kubiatowicz、J.、Ratnasamy、S.、Shenker、S.、ストイカ、I.、およびH.優、「OpenDHT：公共DHTおよびその使用方法」、SIGCOMM'05、2005。"
    },
    {
      "indent": 3,
      "text": "[vulnerabilities-acsac04] Srivatsa, M. and L. Liu, \"Vulnerabilities and Security Threats in Structured Peer-to-Peer Systems: A Quantitative Analysis\", ACSAC 2004, 2004.",
      "ja": "[脆弱性-acsac04] Srivatsa、M.およびL.劉、 \"構造化ピアツーピアシステムの脆弱性とセキュリティの脅威：定量的分析\"、ACSAC 2004、2004。"
    },
    {
      "indent": 3,
      "text": "[wikiChord] Wikipedia, \"Chord (peer-to-peer)\", 2013, <http://en.wikipedia.org/w/ index.php?title=Chord_%28peer-to-peer%29&oldid=549516287>.",
      "ja": "【wikiChord]ウィキペディア、 \"コード（ピア・ツー・ピア）\" 2013年、<http://en.wikipedia.org/w/ index.phpを？タイトル= Chord_％28peerツー・ピア％29＆oldid = 549516287>。"
    },
    {
      "indent": 3,
      "text": "[wikiKBR] Wikipedia, \"Key-based routing\", 2013, <en.wikipedia.org/w/ index.php?title=Key-based_routing&oldid=543850833>.",
      "ja": "[wikiKBR]ウィキペディア、 \"キーベースのルーティング\"、2013年、<en.wikipedia.org/w/のindex.php？タイトル=キーbased_routing＆oldid = 543850833>。"
    },
    {
      "indent": 3,
      "text": "[wikiSkiplist] Wikipedia, \"Skip list\", 2013, <http://en.wikipedia.org/w/ index.php?title=Skip_list&oldid=551304213>.",
      "ja": "[wikiSkiplist]ウィキペディアは、2013年、 \"リストをスキップ\" <http://en.wikipedia.org/w/のindex.php？タイトル= Skip_list＆oldid = 551304213>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Routing Alternatives",
      "ja": "付録A.ルーティング代替"
    },
    {
      "indent": 3,
      "text": "Significant discussion has been focused on the selection of a routing algorithm for P2PSIP. This section discusses the motivations for selecting symmetric recursive routing for RELOAD and describes the extensions that would be required to support additional routing algorithms.",
      "ja": "重要な議論がP2PSIPのルーティングアルゴリズムの選択が注目されています。このセクションでは、RELOADのための対称再帰ルーティングを選択するための動機を説明し、追加のルーティングアルゴリズムをサポートするために必要となる拡張機能について説明します。"
    },
    {
      "indent": 0,
      "text": "A.1. Iterative vs. Recursive",
      "ja": "A.1。再帰対反復"
    },
    {
      "indent": 3,
      "text": "Iterative routing has a number of advantages. It is easier to debug, consumes fewer resources on intermediate peers, and allows the querying peer to identify and route around misbehaving peers [non-transitive-dhts-worlds05]. However, in the presence of NATs, iterative routing is intolerably expensive, because a new connection must be established for each hop (using ICE) [bryan-design-hotp2p08].",
      "ja": "反復ルーティングは多くの利点を有します。これは、デバッグが容易である中間ピアに、より少ないリソースを消費し、クエリピアがピアを誤動作周り[非推移-のDHT-worlds05]を識別して経路を可能にします。新しい接続が（ICEを使用して）各ホップのために確立されなければならないのでしかし、NATの存在下で、反復ルーティングは[ブライアン・デザインhotp2p08]、耐えられないほど高価です。"
    },
    {
      "indent": 3,
      "text": "Iterative routing is supported through the RouteQuery mechanism and is primarily intended for debugging. It also allows the querying peer to evaluate the routing decisions made by the peers at each hop, consider alternatives, and perhaps detect at what point the forwarding path fails.",
      "ja": "反復ルーティングはRouteQuery機構を介して支持され、主にデバッグのために意図されています。また、各ホップでピアによって作られたルーティング決定を評価する代替案を検討し、そしておそらく転送パスに障害が発生したどの地点で検出するための照会ピアすることができます。"
    },
    {
      "indent": 0,
      "text": "A.2. Symmetric vs. Forward Response",
      "ja": "A.2。フォワードレスポンス対対称"
    },
    {
      "indent": 3,
      "text": "An alternative to the symmetric recursive routing method used by RELOAD is forward-only routing, where the response is routed to the requester as if it were a new message initiated by the responder. (In the previous example, Z sends the response to A as if it were sending a request.) Forward-only routing requires no state in either the message or intermediate peers.",
      "ja": "リロードで使用される対称再帰ルーティング法に代わるものは、それが応答によって開始さ新しいメッセージであるかのように応答を要求者に送られる順方向専用ルーティングです。 （それは、要求を送信したかのように、前の例では、Zは、への応答を送信する。）順方向専用ルーティングは、メッセージまたは中間ピアのいずれかでない状態を必要としません。"
    },
    {
      "indent": 3,
      "text": "The drawback of forward-only routing is that it does not work when the overlay is unstable. For example, if A is in the process of joining the overlay and is sending a Join request to Z, it is not yet reachable via forward-only routing. Even if it is established in the overlay, if network failures produce temporary instability, A may not be reachable (and may be trying to stabilize its network connectivity via Attach messages).",
      "ja": "前方のみのルーティングの欠点は、オーバーレイが不安定な場合、それは動作しないということです。 Aは、オーバレイに参加する過程であり、Zへの参加要求を送信している場合、例えば、それはまだ前方にのみルーティングを介して到達可能ではありません。それは、オーバーレイで確立されている場合でも、ネットワーク障害が一時的な不安定性をもたらすならば、Aは到達可能ではないかもしれない（と添付したメッセージを経由して、ネットワークの接続性を安定させるためにしようとすることができます）。"
    },
    {
      "indent": 3,
      "text": "Furthermore, forward-only responses are less likely to reach the querying peer than symmetric recursive ones are, because the forward path is more likely to have a failed peer than is the request path (which was just tested to route the request) [non-transitive-dhts-worlds05].",
      "ja": "フォワードパスは、[非（単にルート要求に試験された）要求パスがより失敗したピアを持っている可能性が高いため、さらに、前方のみ応答は、対称的な再帰的なものでより問合せピアに到達する可能性が低いです推移-のDHT-worlds05]。"
    },
    {
      "indent": 3,
      "text": "An extension to RELOAD that supports forward-only routing but relies on symmetric responses as a fallback would be possible, but due to the complexities of determining when to use forward-only routing and when to fallback to symmetric routing, we have chosen not to include it as an option at this point.",
      "ja": "それをリロードする拡張機能は、順方向専用のルーティングをサポートしていますが、フォールバックが可能なように、対称応答に依存しているが、原因前方のみのルーティングを使用するかを決定し、とき対称ルーティングにフォールバックするの複雑さに、私たちは含めないことを選択しましたそれこの時点でオプションとして。"
    },
    {
      "indent": 0,
      "text": "A.3. Direct Response",
      "ja": "A.3。ダイレクトレスポンス"
    },
    {
      "indent": 3,
      "text": "Another routing option is direct response routing, in which the response is returned directly to the querying node. In the previous example, if A encodes its IP address in the request, then Z can simply deliver the response directly to A. In the absence of NATs or other connectivity issues, this is the optimal routing technique.",
      "ja": "別のルーティングオプションは、応答が照会ノードに直接戻される直接応答ルーティング、です。前の例では、Aは、要求にそのIPアドレスを符号化する場合、Zは、単にのNATまたは他の接続の問題が存在しない場合にはAに直接応答を提供することができ、これは、最適なルーティング技術です。"
    },
    {
      "indent": 3,
      "text": "The challenge of implementing direct response routing is the presence of NATs. There are a number of complexities that must be addressed. In this discussion, we will continue our assumption that A issued the request and Z is generating the response.",
      "ja": "ダイレクトレスポンスルーティングを実装するという課題は、NATの存在です。取り組まなければならない複雑さの数があります。この議論では、Aは、要求を発行し、Zは、応答を生成している私たちの仮定を継続していきます。"
    },
    {
      "indent": 3,
      "text": "o The IP address listed by A may be unreachable, either due to NAT or firewall rules. Therefore, a direct response technique must fallback to symmetric response [non-transitive-dhts-worlds05]. The hop-by-hop ACKs used by RELOAD allow Z to determine when A has received the message (and the TLS negotiation will provide earlier confirmation that A is reachable), but this fallback requires a timeout that will increase the response latency whenever A is not reachable from Z.",
      "ja": "O Aによって記載されているIPアドレスは、どちらかによるNATやファイアウォールのルールに到達できないことがあります。したがって、ダイレクトレスポンス技術は、対称応答[非推移-のDHT-worlds05]にフォールバックしなければなりません。リロードで使用されるホップバイホップACKはZ Aがメッセージを受信したときを決定するために（およびTLSネゴシエーションは、Aが到達可能であることは、以前の確認を提供することになる）可能に、このフォールバックがAであるときはいつでも応答待ち時間を増加するタイムアウトを必要とZ.から到達できません"
    },
    {
      "indent": 3,
      "text": "o Whenever A is behind a NAT it, will have multiple candidate IP addresses, each of which must be advertised to ensure connectivity. Therefore, Z will need to attempt multiple connections to deliver the response.",
      "ja": "Aは、NATの背後にあるときはいつでもOそれは、接続性を確保するために宣伝されている必要があり、それぞれが、複数の候補のIPアドレスを持つことになります。したがって、Zは、応答を提供するために複数の接続を試みる必要があります。"
    },
    {
      "indent": 3,
      "text": "o One (or all) of A's candidate addresses may route from Z to a different device on the Internet. In the worst case, these nodes may actually be running RELOAD on the same port. Therefore, it is absolutely necessary to establish a secure connection to authenticate A before delivering the response. This step diminishes the efficiency of direct response routing, because multiple round-trips are required before the message can be delivered.",
      "ja": "Aの候補アドレスのいずれか（またはすべて）O経路Zからインターネット上の別のデバイスにしてもよいです。最悪の場合には、これらのノードは、実際には同じポートでRELOADを実行することができます。したがって、応答を配信する前に認証するためのセキュアな接続を確立するために絶対に必要です。メッセージが配信される前に、複数のラウンドトリップを必要とするため、この手順は、直接応答ルーティングの効率を減少させます。"
    },
    {
      "indent": 3,
      "text": "o If A is behind a NAT and does not have a connection already established with Z, there are only two ways the direct response will work. The first is that A and Z must both be behind the same NAT, in which case the NAT is not involved. In the more common case, when Z is outside A's NAT, the response will be received only if A's NAT implements endpoint-independent filtering. As the choice of filtering mode conflates application transparency with security [RFC4787] and no clear recommendation is available, the prevalence of this feature in future devices remains unclear.",
      "ja": "O AがNATの背後にあると、既にZで確立された接続を持っていない場合は、直接の応答が動作する唯一の2つの方法があります。最初は、AとZの両方NATが関与していない場合には、同じNATの背後でなければならないことです。 ZがAのNATの外側にある場合に、より一般的なケースでは、応答は、AのNATがエンドポイント非依存フィルタリングを実装した場合にのみ受信されます。フィルタリングモードの選択は、[RFC4787]と明確な勧告が利用可能であるセキュリティとアプリケーションの透明性を融合しますと、将来のデバイスでは、この機能の有病率は依然として不明です。"
    },
    {
      "indent": 3,
      "text": "An extension to RELOAD that supports direct response routing but relies on symmetric responses as a fallback would be possible, but due to the complexities of determining when to use direct response routing and when to fallback to symmetric routing, and the reduced performance for responses to peers behind restrictive NATs, we have chosen not to include it as an option at this point.",
      "ja": "それをリロードする拡張子は直接応答ルーティングをサポートするが、代替が可能であるように対称的な応答に依存しているが、原因決定の複雑さにするとき、対称ルーティングにフォールバックに直接応答ルーティングとを使用する場合、およびピアへの応答のための性能低下制限NATの背後に、我々はこの時点ではオプションとして、それを含めるしないことを選択しました。"
    },
    {
      "indent": 0,
      "text": "A.4. Relay Peers",
      "ja": "A.4。リレーピア"
    },
    {
      "indent": 3,
      "text": "[P2PSIP-RELAY] has proposed implementing a form of direct response by having A identify a peer, Q, that will be directly reachable by any other peer. A uses Attach to establish a connection with Q and advertises Q's IP address in the request sent to Z. Z sends the response to Q, which relays it to A. This then reduces the latency to two hops, and Z is negotiating a secure connection to Q.",
      "ja": "[P2PSIPリレー]は、他のピアによって直接到達可能になり、ピア、Qを、特定有することによって直接応答の形式を実装提案しています。用途はQとの接続を確立するために取り付け、Z. Zに送信された要求におけるQのIPアドレスは、2つのホップに待ち時間を短縮これA.に中継Qに対する応答を送信アドバタイズ、およびZは、安全な接続を交渉していますQ.へ"
    },
    {
      "indent": 3,
      "text": "This technique relies on the relative population of nodes such as A that require relay peers and peers such as Q that are capable of serving as a relay peer. It also requires nodes to be able to identify which category they are in. This identification problem has turned out to be hard to solve and is still an open area of exploration.",
      "ja": "この技術は、中継ピアとして機能することが可能であるようなQとして中継ピアとのピアを必要とするノードの相対的な集団に依存しています。それはまた、彼らはしているどのカテゴリに識別できるようにするには、ノードが必要です。この識別問題を解決するのは難しいことが判明し、まだ探査の開口面積でいます。"
    },
    {
      "indent": 3,
      "text": "An extension to RELOAD that supports relay peers is possible, but due to the complexities of implementing such an alternative, we have not added such a feature to RELOAD at this point.",
      "ja": "それをリロードする拡張機能は、リレーのピアが可能ですサポートしていますが、そのような代替の実装の複雑さのために、我々はこの時点でリロードするなどの機能を追加していません。"
    },
    {
      "indent": 3,
      "text": "A concept similar to relay peers, essentially choosing a relay peer at random, has previously been suggested to solve problems of pair-wise non-transitivity [non-transitive-dhts-worlds05], but deterministic filtering provided by NATs makes random relay peers no more likely to work than the responding peer.",
      "ja": "本質的にランダムで中継ピアを選択するピアを中継する同様の概念は、以前に[非推移-のDHT-worlds05]ペアワイズ非推移の問題を解決するために提案されているが、NATのが提供する確定的なフィルタリングが無いランダムリレーピアを作ります応答側のピアよりも動作する可能性が高いです。"
    },
    {
      "indent": 0,
      "text": "A.5. Symmetric Route Stability",
      "ja": "A.5。対称ルートの安定性"
    },
    {
      "indent": 3,
      "text": "A common concern about symmetric recursive routing has been that one or more peers along the request path may fail before the response is received. The significance of this problem essentially depends on the response latency of the overlay. An overlay that produces slow responses will be vulnerable to churn, whereas responses that are delivered very quickly are vulnerable only to failures that occur over that small interval.",
      "ja": "対称再帰ルーティングに関する一般的な懸念は、応答が受信される前に、要求パスに沿った1つ以上のピアが失敗することがありました。この問題の重要性は、本質的に、オーバーレイの応答の待ち時間に依存します。非常に迅速に配信された応答は、それだけで小さな間隔で発生する障害に対して脆弱であるのに対し、遅い応答を生成し、オーバーレイは、解約する脆弱になります。"
    },
    {
      "indent": 3,
      "text": "The other aspect of this issue is whether the request itself can be successfully delivered. Assuming typical connection maintenance intervals, the time period between the last maintenance and the request being sent will be orders of magnitude greater than the delay between the request being forwarded and the response being received. Therefore, if the path was stable enough to be available to route the request, it is almost certainly going to remain available to route the response.",
      "ja": "この問題の他の側面は、要求自体が正常に配信することができるかどうかです。代表的な接続メンテナンス間隔を仮定すると、最後のメンテナンスおよび送信される要求の間の時間期間は、転送される要求及び受信される応答との間の遅延よりも大きい大きさのオーダーであろう。パスがルート要求に利用できるようにするために十分安定していた場合はそのため、ほぼ確実にルーティングするために応答可能なままになるだろう。"
    },
    {
      "indent": 3,
      "text": "An overlay that is unstable enough to suffer this type of failure frequently is unlikely to be able to support reliable functionality regardless of the routing mechanism. However, regardless of the stability of the return path, studies show that in the event of high churn, iterative routing is a better solution to ensure request completion [lookups-churn-p2p06] [non-transitive-dhts-worlds05]",
      "ja": "このタイプの障害を受けるに十分に不安定であるオーバーレイは頻繁にかかわらず、ルーティングメカニズムの信頼性の高い機能をサポートすることができることはほとんどありません。しかし、関係なく、復路の安定性、研究が高い解約の場合には、反復ルーティングは要求の完了を確保するためのより良い解決策であることを示す[ルックアップ・チャーン-p2p06] [非推移-のDHT-worlds05]"
    },
    {
      "indent": 3,
      "text": "Finally, because RELOAD retries the end-to-end request, that retry will address the issues of churn that remain.",
      "ja": "RELOADは、エンドツーエンドの要求を再試行するため、最後に、そのリトライが残るチャーンの問題に対処します。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Why Clients?",
      "ja": "付録B.なぜクライアント？"
    },
    {
      "indent": 3,
      "text": "There are a wide variety of reasons a node may act as a client rather than as a peer. This section outlines some of those scenarios and how the client's behavior changes based on its capabilities.",
      "ja": "ノードがクライアントとしてではなく、ピアとして作用することができる理由のさまざまながあります。このセクションでは、これらのシナリオのいくつかを概説し、どのようにクライアントの動作の変更、その能力に基づきます。"
    },
    {
      "indent": 0,
      "text": "B.1. Why Not Only Peers?",
      "ja": "B.1。なぜピアだけ？"
    },
    {
      "indent": 3,
      "text": "For a number of reasons, a particular node may be forced to act as a client even though it is willing to act as a peer. These include:",
      "ja": "多くの理由により、特定のノードは、ピアとして機能して喜んであってもクライアントとして動作するように強制することができます。これらは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The node does not have appropriate network connectivity, typically because it has a low-bandwidth network connection.",
      "ja": "Oノードは、それが低帯域幅のネットワーク接続を持っている一般的にあるため、適切なネットワーク接続を持っていません。"
    },
    {
      "indent": 3,
      "text": "o The node may not have sufficient resources, such as computing power, storage space, or battery power.",
      "ja": "Oノードは、計算能力、記憶容量、またはバッテリ電源として十分なリソースを有していなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "o The overlay algorithm may dictate specific requirements for peer selection. These may include participating in the overlay to determine trustworthiness, controlling the number of peers in the overlay to reduce overly long routing paths, and ensuring minimum application uptime before a node can join as a peer.",
      "ja": "Oオーバーレイアルゴリズムは、ピア選択のための特定の要件を指示することができます。これらは、信頼性を決定するために、オーバーレイに参加過度に長いルーティング経路を減少させるために、オーバーレイ内のピアの数を制御し、ノードがピアとして参加する前に、最小のアプリケーションの稼働時間を確保含むことができます。"
    },
    {
      "indent": 3,
      "text": "The ultimate criteria for a node to become a peer are determined by the overlay algorithm and specific deployment. A node acting as a client that has a full implementation of RELOAD and the appropriate overlay algorithm is capable of locating its responsible peer in the overlay and using Attach to establish a direct connection to that peer. In that way, it may elect to be reachable under either of the routing approaches listed above. Particularly for overlay algorithms that elect nodes to serve as peers based on trustworthiness or population, the overlay algorithm may require such a client to locate itself at a particular place in the overlay.",
      "ja": "ピアになるノードのための究極の基準は、オーバーレイアルゴリズムと特定の展開によって決定されます。リロードの完全な実装を持ち、適切なオーバーレイアルゴリズムがオーバーレイでその責任ピアの位置を特定し、そのピアへの直接接続を確立するために取り付け使用することができるクライアントとして動作するノード。そのようにして、上記ルーティングアプローチのいずれかの下に到達することを選択することができます。特に信頼性や人口に基づいてピアとして機能するノードを選出オーバーレイアルゴリズムのために、オーバーレイ・アルゴリズムは、オーバーレイ内の特定の場所で自分自身を見つけるために、このようなクライアントが必要な場合があります。"
    },
    {
      "indent": 0,
      "text": "B.2. Clients as Application-Level Agents",
      "ja": "B.2。アプリケーションレベルのエージェントとしてのクライアント"
    },
    {
      "indent": 3,
      "text": "SIP defines an extensive protocol for registration and security between a client and its registrar/proxy server(s). Any SIP device can act as a client of a RELOAD-based P2PSIP overlay if it contacts a peer that implements the server-side functionality required by the SIP protocol. In this case, the peer would be acting as if it were the user's peer and would need the appropriate credentials for that user.",
      "ja": "SIPは、クライアントとそのレジストラ/プロキシサーバー（複数可）との間の登録及びセキュリティのための広範なプロトコルを定義します。接触SIPプロトコルによって必要とされるサーバ側の機能を実装した場合、ピア任意のSIPデバイスリロードベースP2PSIPオーバーレイのクライアントとして動作することができます。この場合、ピアは、それがユーザーのピアであるかのように働くことになると、そのユーザーの適切な資格情報が必要になります。"
    },
    {
      "indent": 3,
      "text": "Application-level support for clients is defined by a usage. A usage offering support for application-level clients should specify how the security of the system is maintained when the data is moved between the application and RELOAD layers.",
      "ja": "クライアントのためのアプリケーションレベルのサポートは、使用によって定義されます。アプリケーションレベルのクライアントのためのサポートを提供する使用は、データがアプリケーションとリロード層との間を移動する際に、システムのセキュリティが維持される方法を指定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Cullen Jennings Cisco 400 3rd Avenue SW, Suite 350 Calgary Canada",
      "ja": "カレン・ジェニングスのCisco 400第三アベニューSW、スイート350カナダカルガリー"
    },
    {
      "indent": 3,
      "text": "EMail: fluffy@cisco.com",
      "ja": "メールアドレス：fluffy@cisco.com"
    },
    {
      "indent": 3,
      "text": "Bruce B. Lowekamp (editor) Skype Palo Alto, CA USA",
      "ja": "ブルースB. Lowekamp（エディタ）スカイプパロアルト、CA USA"
    },
    {
      "indent": 3,
      "text": "EMail: bbl@lowekamp.net",
      "ja": "メールアドレス：bbl@lowekamp.net"
    },
    {
      "indent": 3,
      "text": "Eric Rescorla RTFM, Inc. 2064 Edgewood Drive Palo Alto, CA 94303 USA",
      "ja": "エリックレスコラRTFM、Inc.の2064エッジウッドドライブパロアルト、CA 94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 678 2350 EMail: ekr@rtfm.com",
      "ja": "電話：+1 650 678 2350 Eメール：ekr@rtfm.com"
    },
    {
      "indent": 3,
      "text": "Salman A. Baset Columbia University 1214 Amsterdam Avenue New York, NY USA",
      "ja": "サルマンA. BASETコロンビア大学1214アムステルダムアベニューニューヨーク、NY USA"
    },
    {
      "indent": 3,
      "text": "EMail: salman@cs.columbia.edu",
      "ja": "メールアドレス：salman@cs.columbia.edu"
    },
    {
      "indent": 3,
      "text": "Henning Schulzrinne Columbia University 1214 Amsterdam Avenue New York, NY USA",
      "ja": "ヘニングSchulzrinneとコロンビア大学1214アムステルダムアベニューニューヨーク、NY USA"
    },
    {
      "indent": 3,
      "text": "EMail: hgs@cs.columbia.edu",
      "ja": "メールアドレス：hgs@cs.columbia.edu"
    }
  ]
}