{
  "title": {
    "text": "RFC 6287 - OCRA: OATH Challenge-Response Algorithm",
    "ja": "RFC 6287 - OCRA：OATHのチャレンジ・レスポンスアルゴリズム"
  },
  "number": 6287,
  "created_at": "2019-11-01 19:28:40.842402+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        D. M'Raihi\nRequest for Comments: 6287                                Verisign, Inc.\nCategory: Informational                                        J. Rydell\nISSN: 2070-1721                                           Portwise, Inc.\n                                                                S. Bajaj\n                                                          Symantec Corp.\n                                                              S. Machani\n                                                        Diversinet Corp.\n                                                             D. Naccache\n                                                Ecole Normale Superieure\n                                                               June 2011",
      "raw": true
    },
    {
      "indent": 16,
      "text": "OCRA: OATH Challenge-Response Algorithm",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes an algorithm for challenge-response authentication developed by the Initiative for Open Authentication (OATH). The specified mechanisms leverage the HMAC-based One-Time Password (HOTP) algorithm and offer one-way and mutual authentication, and electronic signature capabilities.",
      "ja": "この文書では、オープン認証のためのイニシアティブ（OATH）によって開発されたチャレンジレスポンス認証のためのアルゴリズムを説明します。指定されたメカニズムは、HMACベースのワンタイムパスワード（HOTP）アルゴリズムを活用し、一方向および相互認証、および電子署名機能を提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6287.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6287で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2011 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Notation and Terminology ........................................3\n3. Algorithm Requirements ..........................................3\n4. OCRA Background .................................................4\n   4.1. HOTP Algorithm .............................................4\n5. Definition of OCRA ..............................................5\n   5.1. DataInput Parameters .......................................5\n   5.2. CryptoFunction .............................................7\n6. The OCRASuite ...................................................8\n   6.1. Algorithm ..................................................9\n   6.2. CryptoFunction .............................................9\n   6.3. DataInput ..................................................9\n   6.4. OCRASuite Examples ........................................10\n7. Algorithm Modes for Authentication .............................10\n   7.1. One-Way Challenge-Response ................................11\n   7.2. Mutual Challenge-Response .................................12\n   7.3. Algorithm Modes for Signature .............................13\n        7.3.1. Plain Signature ....................................13\n        7.3.2. Signature with Server Authentication ...............14\n8. Security Considerations ........................................16\n   8.1. Security Analysis of OCRA .................................16\n   8.2. Implementation Considerations .............................17\n9. Conclusion .....................................................18\n10. Acknowledgements ..............................................18\n11. References ....................................................19\n   11.1. Normative References .....................................19\n   11.2. Informative References ...................................19\nAppendix A. Reference Implementation ..............................20\nAppendix B. Test Vectors Generation ...............................26\nAppendix C. Test Vectors ..........................................33\n  C.1. One-Way Challenge Response .................................34\n  C.2. Mutual Challenge-Response ..................................35\n  C.3. Plain Signature ............................................37",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The Initiative for Open Authentication (OATH) [OATH] has identified several use cases and scenarios that require an asynchronous variant to accommodate users who do not want to maintain a synchronized authentication system. A commonly accepted method for this is to use a challenge-response scheme.",
      "ja": "オープン認証（OATH）[OATH]のためのイニシアティブは、同期認証システムを維持したくないユーザーに対応するために、非同期バリアントを必要とする複数のユースケースとシナリオを特定しています。このため一般的に受け入れられている方法は、チャレンジ・レスポンス方式を使用することです。"
    },
    {
      "indent": 3,
      "text": "Such a challenge-response mode of authentication is widely adopted in the industry. Several vendors already offer software applications and hardware devices implementing challenge-response -- but each of those uses vendor-specific proprietary algorithms. For the benefits of users there is a need for a standardized challenge-response algorithm that allows multi-sourcing of token purchases and validation systems to facilitate the democratization of strong authentication.",
      "ja": "認証のようなチャレンジ・レスポンスモードは、業界で広く採用されています。いくつかのベンダーは、既にチャレンジ・レスポンスを実現するソフトウェアアプリケーションおよびハードウェアデバイスを提供します - しかし、それらのそれぞれは、ベンダー固有の独自のアルゴリズムを使用しています。ユーザーの利益のためにトークンの購入および検証システムのマルチソーシングは、強力な認証の民主化を促進することを可能にする標準化されたチャレンジレスポンスアルゴリズムの必要性があります。"
    },
    {
      "indent": 3,
      "text": "Additionally, this specification describes the means to create symmetric key-based short 'electronic signatures'. Such signatures are variants of challenge-response mode where the data to be signed becomes the challenge or is used to derive the challenge. Note that the term 'electronic signature' and 'signature' are used interchangeably in this document.",
      "ja": "また、本明細書では、対称鍵ベースのショート「電子署名」を作成するための手段を記載します。そのような署名は、署名されるべきデータが課題となっ又はチャレンジを導出するために使用されるチャレンジ・レスポンス方式の変異体です。用語「電子署名」と「署名」は本書では互換的に使用されることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "2. Notation and Terminology",
      "section_title": true,
      "ja": "2.表記と用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Algorithm Requirements",
      "section_title": true,
      "ja": "3.アルゴリズムの要件"
    },
    {
      "indent": 3,
      "text": "This section presents the main requirements that drove this algorithm design. A lot of emphasis was placed on flexibility and usability, under the constraints and specificity of the HMAC-based One-Time Password (HOTP) algorithm [RFC4226] and hardware token capabilities.",
      "ja": "このセクションでは、このアルゴリズムの設計を運転した主な要件を提示します。重点の多くは、HMACベースのワンタイムパスワード（HOTP）アルゴリズム[RFC4226]とハードウェアトークン機能の制約と特異性の下で、柔軟性と使いやすさの上に置きました。"
    },
    {
      "indent": 3,
      "text": "R1 - The algorithm MUST support challenge-response-based authentication.",
      "ja": "R1  - アルゴリズムは、チャレンジ・レスポンスベースの認証をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "R2 - The algorithm MUST be capable of supporting symmetric key-based short electronic signatures. Essentially, this is a variation of challenge-response where the challenge is derived from the data that needs to be signed.",
      "ja": "R2  - アルゴリズムは、対称鍵ベースの短い電子署名をサポートすることができなければなりません。本質的に、これは、チャレンジに署名する必要があるデータから導出されたチャレンジ - 応答の変化です。"
    },
    {
      "indent": 3,
      "text": "R3 - The algorithm MUST be capable of supporting server authentication, whereby the user can verify that he/she is talking to a trusted server.",
      "ja": "R3は - アルゴリズムは、ユーザが彼/彼女が信頼できるサーバに話していることを確認できる、サーバー認証をサポートすることができなければなりません。"
    },
    {
      "indent": 3,
      "text": "R4 - The algorithm SHOULD use HOTP [RFC4226] as a key building block.",
      "ja": "R4  - アルゴリズムが重要なビルディングブロックとしてHOTP [RFC4226]を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "R5 - The length and format of the input challenge SHOULD be configurable.",
      "ja": "R5  - 入力チャレンジの長さと形式は設定可能べきです。"
    },
    {
      "indent": 3,
      "text": "R6 - The output length and format of the generated response SHOULD be configurable.",
      "ja": "R6  - 生成された応答の出力長さと形式は設定可能べきです。"
    },
    {
      "indent": 3,
      "text": "R7 - The challenge MAY be generated with integrity checking (e.g., parity bits). This will allow tokens with pin pads to perform simple error checking when the user enters the challenge value into a token.",
      "ja": "R7  - 課題は、整合性チェック（例えば、パリティビット）を生成することができます。これにより、ユーザーはトークンにチャレンジ値を入力したときにピンパッドとトークンは、簡単なエラーチェックを実行することができます。"
    },
    {
      "indent": 3,
      "text": "R8 - There MUST be a unique secret (key) for each token/soft token that is shared between the token and the authentication server. The keys MUST be randomly generated or derived using a key derivation algorithm.",
      "ja": "R8は - トークンと認証サーバとの間で共有されている各トークン/ソフトトークンの一意の秘密（キー）が存在でなければなりません。キーは、ランダムに生成又はキー導出アルゴリズムを用いて導出されなければなりません。"
    },
    {
      "indent": 3,
      "text": "R9 - The algorithm MAY enable additional data attributes such as a timestamp or session information to be included in the computation. These data inputs MAY be used individually or all together.",
      "ja": "R9  - アルゴリズムは、計算に含まれるタイムスタンプまたはセッション情報などの追加のデータ属性を可能にすることができます。これらのデータ入力は、個別に、またはすべて一緒に使用することができます。"
    },
    {
      "indent": 0,
      "text": "4. OCRA Background",
      "section_title": true,
      "ja": "4. OCRAの背景"
    },
    {
      "indent": 3,
      "text": "OATH introduced the HOTP algorithm as a first open, freely available building block towards strengthening authentication for end-users in a variety of applications. One-time passwords are very efficient at solving specific security issues thanks to the dynamic nature of OTP computations.",
      "ja": "OATHは、様々な用途にエンドユーザの認証の強化に向けてブロックを構築し、最初のオープンとして自由に利用できるHOTPアルゴリズムを導入します。ワンタイムパスワードは、OTP計算の動的な性質のために、特定のセキュリティ問題のおかげで解決するのに非常に効率的です。"
    },
    {
      "indent": 3,
      "text": "After carefully analyzing different use cases, OATH came to the conclusion that providing for extensions to the HOTP algorithms was important. A very natural extension is to introduce a challenge mode for computing HOTP values based on random questions. Equally beneficial is being able to perform mutual authentication between two parties, or short-signature computation for authenticating transaction to improve the security of e-commerce applications.",
      "ja": "慎重に異なるユースケースを分析した後、OATHはHOTPアルゴリズムへの拡張のために提供することが重要だったという結論に達しました。非常に自然な拡張は、ランダムな質問に基づいて、HOTP値を計算するためのチャレンジモードを導入することです。等しく有益な電子商取引アプリケーションのセキュリティを向上させるために、トランザクションを認証するための2つのパーティ、または短い署名計算との間で相互認証を行うことができることです。"
    },
    {
      "indent": 0,
      "text": "4.1. HOTP Algorithm",
      "section_title": true,
      "ja": "4.1。 HOTPアルゴリズム"
    },
    {
      "indent": 3,
      "text": "The HOTP algorithm, as defined in [RFC4226], is based on an increasing counter value and a static symmetric key known only to the prover and verifier parties.",
      "ja": "HOTPアルゴリズムは、[RFC4226]で定義されるように、増加するカウンタ値と、証明者と検証者にのみ知られている静的対称鍵に基づいています。"
    },
    {
      "indent": 3,
      "text": "As a reminder: HOTP(K,C) = Truncate(HMAC-SHA1(K,C))",
      "ja": "HOTP（K、C）=切捨て（HMAC-SHA1（K、C））：リマインダーとして"
    },
    {
      "indent": 3,
      "text": "where Truncate represents the function that converts an HMAC-SHA-1 value into an HOTP value.",
      "ja": "切り捨ては、HOTP値にHMAC-SHA-1値を変換する関数を表します。"
    },
    {
      "indent": 3,
      "text": "We refer the reader to [RFC4226] for the full description and further details on the rationale and security analysis of HOTP.",
      "ja": "私たちは、完全な説明とHOTPの根拠とセキュリティ分析の詳細については[RFC4226]を読者に参照してください。"
    },
    {
      "indent": 3,
      "text": "The present document describes the different variants based on similar constructions as HOTP.",
      "ja": "現在のドキュメントはHOTPと同様の構造に基づいて種々の変形を説明します。"
    },
    {
      "indent": 0,
      "text": "5. Definition of OCRA",
      "section_title": true,
      "ja": "OCRAの5.定義"
    },
    {
      "indent": 3,
      "text": "The OATH Challenge-Response Algorithm (OCRA) is a generalization of HOTP with variable data inputs not solely based on an incremented counter and secret key values.",
      "ja": "OATHチャレンジ・レスポンスアルゴリズム（OCRA）はもっぱらインクリメントカウンタと秘密キーの値に基づいていない変数のデータ入力とHOTPの一般化です。"
    },
    {
      "indent": 3,
      "text": "The definition of OCRA requires a cryptographic function, a key K and a set of DataInput parameters. This section first formally introduces OCRA and then introduces the definitions and default values recommended for all parameters.",
      "ja": "OCRAの定義は、暗号化関数、鍵KとDataInput内のパラメータのセットを必要とします。このセクションでは、最初の正式OCRAを紹介し、すべてのパラメータの推奨定義とデフォルト値が導入されました。"
    },
    {
      "indent": 3,
      "text": "In a nutshell, OCRA = CryptoFunction(K, DataInput)",
      "ja": "一言で言えば、OCRA = CryptoFunction（K、DataInput内）"
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "どこ："
    },
    {
      "indent": 3,
      "text": "o K: a shared secret key known to both parties",
      "ja": "O K：両当事者に知られている共有秘密鍵"
    },
    {
      "indent": 3,
      "text": "o DataInput: a structure that contains the concatenation of the various input data values defined in details in section 5.1",
      "ja": "O DataInput内：セクション5.1で詳細に定義された様々な入力データ値の連結を含む構造"
    },
    {
      "indent": 3,
      "text": "o CryptoFunction: this is the function performing the OCRA computation from the secret key K and the DataInput material;",
      "ja": "O CryptoFunction：これは秘密鍵KとDataInput内の材料からOCRA演算を行う関数です。"
    },
    {
      "indent": 3,
      "text": "CryptoFunction is described in details in Section 5.2",
      "ja": "CryptoFunctionは、5.2節で詳細に記述されています"
    },
    {
      "indent": 0,
      "text": "5.1. DataInput Parameters",
      "section_title": true,
      "ja": "5.1。 DataInput内のパラメータ"
    },
    {
      "indent": 3,
      "text": "This structure is the concatenation over byte array of the OCRASuite value as defined in section 6 with the different parameters used in the computation, save for the secret key K.",
      "ja": "計算に使用される異なるパラメータでセクション6で定義されるように、この構造は、秘密鍵Kのために保存し、OCRASuite値のバイト配列上連結され"
    },
    {
      "indent": 3,
      "text": "DataInput = {OCRASuite | 00 | C | Q | P | S | T} where:",
      "ja": "DataInput内= {OCRASuite | 00 | C | Q | P | S | T}："
    },
    {
      "indent": 3,
      "text": "o OCRASuite is a value representing the suite of operations to compute an OCRA response",
      "ja": "O OCRASuiteはOCRA応答を計算するための操作のスイートを表す値であります"
    },
    {
      "indent": 3,
      "text": "o 00 is a byte value used as a separator o C is an unsigned 8-byte counter value processed high-order bit first, and MUST be synchronized between all parties; It loops around from \"{Hex}0\" to \"{Hex}FFFFFFFFFFFFFFFF\" and then starts over at \"{Hex}0\". Note that 'C' is optional for all OCRA modes described in this document.",
      "ja": "O 00は、C、Oセパレータは第一上位ビットを処理し、すべての当事者の間で同期されなければならない、符号なし8バイトのカウンタ値であるとして使用されるバイト値です。これは、「{}ヘキサFFFFFFFFFFFFFFFF」に「{}ヘキサ0」からの周りにループし、「{}ヘキサ0」でオーバー開始します。 「C」は、この文書に記載されているすべてのOCRAモードのオプションであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "o Q, mandatory, is a 128-byte list of (concatenated) challenge question(s) generated by the parties; if Q is less than 128 bytes, then it should be padded with zeroes to the right",
      "ja": "O Qは、必須、当事者によって生成された（連結）チャレンジ質問（複数可）の128バイトのリストです。 Qが128バイト未満であれば、それは右に0でパディングされなければなりません"
    },
    {
      "indent": 3,
      "text": "o P is a hash (SHA-1 [RFC3174], SHA-256 and SHA-512 [SHA2] are supported) value of PIN/password that is known to all parties during the execution of the algorithm; the length of P will depend on the hash function that is used",
      "ja": "O Pがハッシュである（SHA-1 [RFC3174]、SHA-256およびSHA-512 [SHA2]サポートされている）アルゴリズムの実行中にすべての関係者には知られているPIN /パスワードの値。 Pの長さは、使用されるハッシュ関数に依存するであろう"
    },
    {
      "indent": 3,
      "text": "o S is a UTF-8 [RFC3629] encoded string of length up to 512 bytes that contains information about the current session; the length of S is defined in the OCRASuite string",
      "ja": "O Sは、現在のセッションについての情報を含む512バイトの長さまでのUTF-8 [RFC3629]エンコードされた文字列です。 Sの長さはOCRASuite文字列で定義されています"
    },
    {
      "indent": 3,
      "text": "o T is an 8-byte unsigned integer in big-endian order (i.e., network byte order) representing the number of time-steps (seconds, minutes, hours, or days depending on the specified granularity) since midnight UTC of January 1, 1970 [UT]. More specifically, if the OCRA computation includes a timestamp T, you should first convert your current local time to UTC time; you can then derive the UTC time in the proper format (i.e., seconds, minutes, hours, or days elapsed from epoch time); the size of the time-step is specified in the OCRASuite string as described in Section 6.3",
      "ja": "O Tは、1月1日の深夜UTC以来の（指定した粒度に応じて、秒、分、時間、または日）時間ステップの数を表すビッグエンディアン順（すなわち、ネットワークバイト順）で8バイトの符号なし整数です1970 [UT]。 OCRAの計算は、タイムスタンプTが含まれている場合は具体的には、最初にUTC時刻に現在のローカル時間に変換する必要があります。あなたがして（すなわち、秒、分、時間、またはエポック時刻からの経過日数）適切な形式でUTC時刻を導出することができます。セクション6.3で説明したように、時間ステップのサイズはOCRASuite文字列で指定されています"
    },
    {
      "indent": 3,
      "text": "When computing a response, the concatenation order is always the following:",
      "ja": "応答を計算すると、連結順序は常に以下のとおりであります："
    },
    {
      "indent": 36,
      "text": "C |",
      "ja": "C |"
    },
    {
      "indent": 16,
      "text": "OTHER-PARTY-GENERATED-CHALLENGE-QUESTION |",
      "ja": "OTHER-PARTY-GENERATED-CHALLENGE-QUESTION |"
    },
    {
      "indent": 20,
      "text": "YOUR-GENERATED-CHALLENGE-QUESTION |",
      "ja": "YOUR-GENERATED-CHALLENGE-QUESTION |"
    },
    {
      "indent": 33,
      "text": "P| S | T",
      "ja": "P | S | T"
    },
    {
      "indent": 3,
      "text": "If a value is empty (i.e., a certain input is not used in the computation) then the value is simply not represented in the string.",
      "ja": "値が空の場合、値は単に文字列で表現されていない（すなわち、特定の入力は、計算に使用されていません）。"
    },
    {
      "indent": 3,
      "text": "The counter on the token or client MUST be incremented every time a new computation is requested by the user. The server's counter value MUST only be incremented after a successful OCRA authentication.",
      "ja": "トークンまたはクライアント上のカウンタは、新たな計算は、ユーザによって要求されるたびに増加しなければなりません。サーバのカウンタ値は唯一の成功OCRAの認証後に増加しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2. CryptoFunction",
      "section_title": true,
      "ja": "5.2。 CryptoFunction"
    },
    {
      "indent": 3,
      "text": "The default CryptoFunction is HOTP-SHA1-6, i.e., the default mode of computation for OCRA is HOTP with the default 6-digit dynamic truncation and a combination of DataInput values as the message to compute the HMAC-SHA1 digest.",
      "ja": "デフォルトCryptoFunctionはHOTP-SHA1-6である、すなわち、OCRAの計算のデフォルトモードはデフォルト6桁のダイナミック切り捨てとHMAC-SHA1ダイジェストを計算するためのメッセージとしてDataInput内の値の組み合わせとHOTPあります。"
    },
    {
      "indent": 3,
      "text": "We denote t as the length in decimal digits of the truncation output. For instance, if t = 6, then the output of the truncation is a 6-digit (decimal) value.",
      "ja": "我々は切り捨て出力の桁の長さとしてトンを示します。 tが6 =あれば、例えば、次に切り捨ての出力は、6桁（10進数）の値です。"
    },
    {
      "indent": 3,
      "text": "We define the HOTP family of functions as an extension to HOTP:",
      "ja": "私たちは、HOTPへの拡張としての機能のHOTPファミリを定義します。"
    },
    {
      "indent": 3,
      "text": "1. HOTP-H-t: these are the different possible truncated versions of HOTP, using the dynamic truncation method for extracting an HOTP value from the HMAC output",
      "ja": "1. HOTP-H-T：これらは、HMAC出力からHOTP値を抽出するための動的トランケーション方法を用いて、HOTPの異なる可能な切断型であります"
    },
    {
      "indent": 3,
      "text": "2. We will denote HOTP-H-t as the realization of an HOTP function that uses an HMAC function with the hash function H, and the dynamic truncation as described in [RFC4226] to extract a t-digit value",
      "ja": "T桁の値を抽出するために、[RFC4226]に記載されているように2我々は、ハッシュ関数Hを用いてHMAC関数を使用HOTP機能の実現、及び動的切り捨てとしてHOTP-H-Tを示します"
    },
    {
      "indent": 3,
      "text": "3. t=0 means that no truncation is performed and the full HMAC value is used for authentication purposes",
      "ja": "3. T = 0は切り捨てが行われず、フルHMAC値が認証のために使用されることを意味します"
    },
    {
      "indent": 3,
      "text": "We list the following preferred modes of computation, where * denotes the default CryptoFunction:",
      "ja": "私たちは、*は、デフォルトのCryptoFunctionを示し、計算、以下の好ましいモードをリスト："
    },
    {
      "indent": 3,
      "text": "o HOTP-SHA1-4: HOTP with SHA-1 as the hash function for HMAC and a dynamic truncation to a 4-digit value; this mode is not recommended in the general case, but it can be useful when a very short authentication code is needed by an application",
      "ja": "O HOTP-SHA1-4：HMACのハッシュ関数と4桁の値に動的切り捨てとしてSHA-1を有するHOTP。このモードは、一般的なケースで推奨されていませんが、非常に短い認証コードがアプリケーションによって必要とされるとき、それは便利です"
    },
    {
      "indent": 3,
      "text": "o HOTP-SHA1-6: HOTP with SHA-1 as the hash function for HMAC and a dynamic truncation to a 6-digit value",
      "ja": "O HOTP-SHA1-6：HMACのハッシュ関数と6桁の値に動的切り捨てとしてSHA-1を有するHOTP"
    },
    {
      "indent": 3,
      "text": "o HOTP-SHA1-8: HOTP with SHA-1 as the hash function for HMAC and a dynamic truncation to an 8-digit value",
      "ja": "O HOTP-SHA1-8：HMACのハッシュ関数と8桁の値に動的切り捨てとしてSHA-1を有するHOTP"
    },
    {
      "indent": 3,
      "text": "o HOTP-SHA256-6: HOTP with SHA-256 as the hash function for HMAC and a dynamic truncation to a 6-digit value",
      "ja": "O HOTP-SHA256-6：HMACのハッシュ関数と6桁の値に動的切り捨てとしてSHA-256とHOTP"
    },
    {
      "indent": 3,
      "text": "o HOTP-SHA512-6: HOTP with SHA-512 as the hash function for HMAC and a dynamic truncation to a 6-digit value",
      "ja": "O HOTP-SHA512-6：HMACのハッシュ関数と6桁の値に動的切り捨てとしてSHA-512とHOTP"
    },
    {
      "indent": 3,
      "text": "This table summarizes all possible values for the CryptoFunction:",
      "ja": "このテーブルには、CryptoFunctionのためのすべての可能な値をまとめたものです。"
    },
    {
      "indent": 5,
      "text": "+---------------+--------------------+-------------------------+\n|      Name     | HMAC Function Used |  Size of Truncation (t) |\n+---------------+--------------------+-------------------------+\n|  HOTP-SHA1-t  |      HMAC-SHA1     | 0 (no truncation), 4-10 |\n| HOTP-SHA256-t |     HMAC-SHA256    | 0 (no truncation), 4-10 |\n| HOTP-SHA512-t |     HMAC-SHA512    | 0 (no truncation), 4-10 |\n+---------------+--------------------+-------------------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 1: CryptoFunction Table",
      "ja": "表1：CryptoFunction表"
    },
    {
      "indent": 0,
      "text": "6. The OCRASuite",
      "section_title": true,
      "ja": "6. OCRASuite"
    },
    {
      "indent": 3,
      "text": "An OCRASuite value is a text string that captures one mode of operation for OCRA, completely specifying the various options for that computation. An OCRASuite value is represented as follows:",
      "ja": "OCRASuite値は、完全にその計算のための様々なオプションを指定して、OCRAための動作の一つのモードを捕捉するテキスト文字列です。次のようにOCRASuite値が表現されます。"
    },
    {
      "indent": 18,
      "text": "<Algorithm>:<CryptoFunction>:<DataInput>",
      "ja": "<アルゴリズム>：<CryptoFunction>：<DataInput内>"
    },
    {
      "indent": 3,
      "text": "The OCRASuite value is the concatenation of three sub-components that are described below. Some example OCRASuite strings are described in Section 6.4.",
      "ja": "OCRASuite値は、以下に説明される3つのサブコンポーネントの連結です。いくつかの例OCRASuite文字列は6.4節で説明されています。"
    },
    {
      "indent": 3,
      "text": "The client and server need to agree on one or two values of OCRASuite. These values may be agreed upon at the time of token provisioning or, for more sophisticated client-server interactions, these values may be negotiated for every transaction.",
      "ja": "クライアントとサーバは、OCRASuiteの一つまたは二つの値に同意する必要があります。これらの値は、トークンのプロビジョニング時に合意することができるか、より洗練されたクライアント - サーバー間の相互作用のために、これらの値は、すべてのトランザクションのために交渉することができます。"
    },
    {
      "indent": 3,
      "text": "The provisioning of OCRA keys and related metadata such as OCRASuite is out of scope for this document. [RFC6030] specifies one key container specification that facilitates provisioning of such data between the client and the server.",
      "ja": "例えばOCRASuiteとしてOCRAキーと関連するメタデータのプロビジョニングは、この文書の範囲外です。 [RFC6030]は、クライアントとサーバの間でこのようなデータのプロビジョニングを容易に一つのキーコンテナの仕様を指定します。"
    },
    {
      "indent": 3,
      "text": "Note that for Mutual Challenge-Response or Signature with Server Authentication modes, the client and server will need to agree on two values of OCRASuite -- one for server computation and another for client computation.",
      "ja": "サーバー計算用とクライアントの計算のための別の - サーバー認証モードとの相互のチャレンジ・レスポンスや署名のために、クライアントとサーバがOCRASuiteの二つの値に同意する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "6.1. Algorithm",
      "section_title": true,
      "ja": "6.1。アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Description: Indicates the version of OCRA.",
      "ja": "説明：OCRAのバージョンを示します。"
    },
    {
      "indent": 3,
      "text": "Values: OCRA-v where v represents the version number (e.g., 1, 2). This document specifies version 1 of OCRA.",
      "ja": "値：OCRA-V vはバージョン番号を表す（例えば、1、2）。このドキュメントでは、OCRAのバージョン1を指定します。"
    },
    {
      "indent": 0,
      "text": "6.2. CryptoFunction",
      "section_title": true,
      "ja": "6.2。 CryptoFunction"
    },
    {
      "indent": 3,
      "text": "Description: Indicates the function used to compute OCRA values",
      "ja": "説明：OCRA値を計算するために使用される機能を示します"
    },
    {
      "indent": 3,
      "text": "Values: Permitted values are described in Section 5.2.",
      "ja": "値：許可された値は、5.2節で説明されています。"
    },
    {
      "indent": 0,
      "text": "6.3. DataInput",
      "section_title": true,
      "ja": "6.3。データ入力"
    },
    {
      "indent": 3,
      "text": "Description: This component of the OCRASuite string captures the list of valid inputs for that computation; [] indicates a value is optional:",
      "ja": "説明：OCRASuite文字列のこのコンポーネントは、その計算のための有効な入力のリストを取り込み、 []の値がオプションであることを示します。"
    },
    {
      "indent": 3,
      "text": "[C] | QFxx | [PH | Snnn | TG] : Challenge-Response computation",
      "ja": "[C] | QFxx | [PH | Snnn | TG]：チャレンジ・レスポンスの計算"
    },
    {
      "indent": 3,
      "text": "[C] | QFxx | [PH | TG] : Plain Signature computation",
      "ja": "[C] | QFxx | [PH | TG]：プレーン署名計算"
    },
    {
      "indent": 3,
      "text": "Each input that is used for the computation is represented by a single letter (except Q), and they are separated by a hyphen.",
      "ja": "計算のために使用される各入力は、（Q除く）単一文字で表され、それらはハイフンによって分離されています。"
    },
    {
      "indent": 3,
      "text": "The input for challenge is further qualified by the formats supported by the client for challenge question(s). Supported values can be:",
      "ja": "挑戦のための入力は、チャレンジ質問（複数可）のために、クライアントによってサポートされる形式によってさらに修飾されています。サポートされる値は指定できます"
    },
    {
      "indent": 17,
      "text": "+------------------+-------------------+\n|    Format (F)    | Up to Length (xx) |\n+------------------+-------------------+\n| A (alphanumeric) |       04-64       |\n|    N (numeric)   |       04-64       |\n|  H (hexadecimal) |       04-64       |\n+------------------+-------------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Table 2: Challenge Format Table",
      "ja": "表2：チャレンジフォーマット表"
    },
    {
      "indent": 3,
      "text": "The default challenge format is N08, numeric and up to 8 digits.",
      "ja": "デフォルトの挑戦フォーマットはN08、数値と8桁までです。"
    },
    {
      "indent": 3,
      "text": "The input for P is further qualified by the hash function used for the PIN/password. Supported values for hash function can be:",
      "ja": "Pの入力は、PIN /パスワードに使用されるハッシュ関数によってさらに修飾されます。ハッシュ関数でサポートされる値は、ことができます："
    },
    {
      "indent": 3,
      "text": "Hash function (H) - SHA1, SHA256, SHA512.",
      "ja": "ハッシュ関数（H） -  SHA1、SHA256、SHA512。"
    },
    {
      "indent": 3,
      "text": "The default hash function for P is SHA1.",
      "ja": "Pのデフォルトのハッシュ関数はSHA1です。"
    },
    {
      "indent": 3,
      "text": "The input for S is further qualified by the length of the session data in bytes. The client and server could agree to any length but the typical values are:",
      "ja": "Sの入力は、バイト単位でのセッションデータの長さによってさらに修飾されます。クライアントとサーバーは、任意の長さに同意でしたが、典型的な値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Length (nnn) - 064, 128, 256, and 512.",
      "ja": "長さ（NNN） -  064、128、256、および512。"
    },
    {
      "indent": 3,
      "text": "The default length is 064 bytes.",
      "ja": "デフォルトの長さは064バイトです。"
    },
    {
      "indent": 3,
      "text": "The input for timestamps is further qualified by G, size of the time-step. G can be specified in number of seconds, minutes, or hours:",
      "ja": "タイムスタンプのための入力はさらにG、タイムステップの大きさによって修飾されます。 Gは、秒、分、または時間数で指定することができます。"
    },
    {
      "indent": 11,
      "text": "+--------------------+------------------------------+\n| Time-Step Size (G) |           Examples           |\n+--------------------+------------------------------+\n|       [1-59]S      | number of seconds, e.g., 20S |\n|       [1-59]M      |  number of minutes, e.g., 5M |\n|       [0-48]H      |  number of hours, e.g., 24H  |\n+--------------------+------------------------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 3: Time-step Size Table",
      "ja": "表3：時間ステップサイズ表"
    },
    {
      "indent": 3,
      "text": "Default value for G is 1M, i.e., time-step size is one minute and the T represents the number of minutes since epoch time [UT].",
      "ja": "Gのデフォルト値、すなわち、時間ステップサイズは1分であり、Tは、エポック時間[UT]からの分数を表し、1Mです。"
    },
    {
      "indent": 0,
      "text": "6.4. OCRASuite Examples",
      "section_title": true,
      "ja": "6.4。 OCRASuite例"
    },
    {
      "indent": 3,
      "text": "Here are some examples of OCRASuite strings:",
      "ja": "ここでOCRASuite文字列のいくつかの例は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o \"OCRA-1:HOTP-SHA512-8:C-QN08-PSHA1\" means version 1 of OCRA with HMAC-SHA512 function, truncated to an 8-digit value, using the counter, a random challenge, and a SHA1 digest of the PIN/password as parameters. It also indicates that the client supports only numeric challenge up to 8 digits in length",
      "ja": "O \"OCRA-1：HOTP-SHA512-8：C-QN08-PSHA1\" はカウンタ、ランダムチャレンジとのSHA1ダイジェストを使用して、8桁の値に切り捨てられたHMAC-SHA512機能とOCRAのバージョン1を意味しますパラメータとしてPIN /パスワード。また、クライアントの長さは8桁までの数字のみの挑戦をサポートしていることを示し"
    },
    {
      "indent": 3,
      "text": "o \"OCRA-1:HOTP-SHA256-6:QA10-T1M\" means version 1 of OCRA with HMAC-SHA256 function, truncated to a 6-digit value, using a random alphanumeric challenge up to 10 characters in length and a timestamp in number of minutes since epoch time",
      "ja": "O「OCRA-1：HOTP-SHA256-6：QA10-T1Mは」10個の長さの文字とのタイムスタンプまでのランダムな英数字のチャレンジを使用して、6桁の値に切り捨てられたHMAC-SHA256機能とOCRAのバージョン1を意味しますエポックタイムからの分数"
    },
    {
      "indent": 3,
      "text": "o \"OCRA-1:HOTP-SHA1-4:QH8-S512\" means version 1 of OCRA with HMAC-SHA1 function, truncated to a 4-digit value, using a random hexadecimal challenge up to 8 nibbles and a session value of 512 bytes",
      "ja": "O「OCRA-1：HOTP-SHA1-4：QH8-S512」は8つのニブル512のセッションの値までランダム進チャレンジを使用して、4桁の値に切り捨てられたHMAC-SHA1機能付きOCRAのバージョン1を意味しますバイト"
    },
    {
      "indent": 0,
      "text": "7. Algorithm Modes for Authentication",
      "section_title": true,
      "ja": "認証のための7.アルゴリズムモード"
    },
    {
      "indent": 3,
      "text": "This section describes the typical modes in which the above defined computation can be used for authentication.",
      "ja": "このセクションでは、上記で定義された計算は、認証のために使用することができる典型的な態様を説明しています。"
    },
    {
      "indent": 0,
      "text": "7.1. One-Way Challenge-Response",
      "section_title": true,
      "ja": "7.1。ワンウェイチャレンジ - レスポンス"
    },
    {
      "indent": 3,
      "text": "A challenge-response is a security mechanism in which the verifier presents a question (challenge) to the prover, who must provide a valid answer (response) to be authenticated.",
      "ja": "チャレンジ・レスポンスは、検証が認証されるべき有効な回答（応答）を提供しなければならない証明に質問（チャレンジ）を提示しているセキュリティ・メカニズムです。"
    },
    {
      "indent": 3,
      "text": "To use this algorithm for a one-way challenge-response, the verifier will communicate a challenge value (typically randomly generated) to the prover. The prover will use the challenge in the computation as described above. The prover then communicates the response to the verifier to authenticate.",
      "ja": "一方向のチャレンジ - 応答のためのこのアルゴリズムを使用するには、検証者が証明者に（典型的にはランダムに生成された）チャレンジ値を通信します。上記のように証明者が計算に挑戦を使用します。証明は、認証するための検証への応答を通信します。"
    },
    {
      "indent": 3,
      "text": "Therefore in this mode, the typical data inputs will be:",
      "ja": "したがって、このモードでは、典型的なデータ入力は次のようになります。"
    },
    {
      "indent": 6,
      "text": "C - Counter, optional.",
      "ja": "C  - カウンター、オプション。"
    },
    {
      "indent": 6,
      "text": "Q - Challenge question, mandatory, supplied by the verifier.",
      "ja": "Q  - 検証により供給された必須の挑戦の質問、。"
    },
    {
      "indent": 6,
      "text": "P - Hashed version of PIN/password, optional.",
      "ja": "P  -  PIN /パスワードのハッシュ化されたバージョン、オプション。"
    },
    {
      "indent": 6,
      "text": "S - Session information, optional.",
      "ja": "S  - セッション情報、オプション。"
    },
    {
      "indent": 6,
      "text": "T - Timestamp, optional.",
      "ja": "T  - タイムスタンプ、オプション。"
    },
    {
      "indent": 3,
      "text": "The diagram below shows the message exchange between the client (prover) and the server (verifier) to complete a one-way challenge-response authentication.",
      "ja": "以下の図は、一方向チャレンジレスポンス認証を完了するためにクライアント（証明）とサーバ（検証者）との間のメッセージ交換を示しています。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the client and server have a pre-shared key K that is used for the computation.",
      "ja": "クライアントとサーバーが計算に使用される事前共有鍵Kを持っていることを想定しています。"
    },
    {
      "indent": 13,
      "text": " CLIENT                                   SERVER\n(PROVER)                                 VERIFIER)\n   |                                        |\n   |   Verifier sends challenge to prover   |\n   |   Challenge = Q                        |\n   |<---------------------------------------|\n   |                                        |\n   |   Prover Computes Response             |\n   |   R = OCRA(K, {[C] | Q | [P | S | T]}) |\n   |   Prover sends Response = R            |\n   |--------------------------------------->|\n   |                                        |\n   |  Verifier Validates Response           |\n   |  If Response is valid, Server sends OK |\n   |  If Response is not,  Server sends NOK |\n   |<---------------------------------------|\n   |                                        |",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2. Mutual Challenge-Response",
      "section_title": true,
      "ja": "7.2。相互チャレンジ - レスポンス"
    },
    {
      "indent": 3,
      "text": "Mutual challenge-response is a variation of one-way challenge-response where both the client and server mutually authenticate each other.",
      "ja": "相互チャレンジ・レスポンスは、クライアントとサーバーの両方が相互に認証一方向のチャレンジレスポンスの変化です。"
    },
    {
      "indent": 3,
      "text": "To use this algorithm, the client will first send a random client-challenge to the server. The server computes the server-response and sends it to the client along with a server-challenge.",
      "ja": "このアルゴリズムを使用するには、クライアントが最初のサーバにランダムクライアントチャレンジを送信します。サーバーは、サーバーの応答を計算し、サーバーチャレンジと一緒にクライアントに送信します。"
    },
    {
      "indent": 3,
      "text": "The client will first verify the server-response to be assured that it is talking to a valid server. It will then compute the client-response and send it to the server to authenticate. The server verifies the client-response to complete the two-way authentication process.",
      "ja": "クライアントは、まず、それが有効なサーバーに話していることを保証するサーバ応答を検証します。その後、クライアントの応答を計算し、認証するためにサーバーに送信します。サーバーは双方向の認証プロセスを完了するために、クライアントの応答を検証します。"
    },
    {
      "indent": 3,
      "text": "In this mode there are two computations: client-response and server-response. There are two separate challenge questions, generated by both parties. We denote these challenge questions Q1 and Q2.",
      "ja": "クライアント応答およびサーバーの応答：このモードでは2回の計算があります。両当事者によって生成された2つの別々のチャレンジ質問があります。我々は、これらのチャレンジ質問Q1とQ2を示します。"
    },
    {
      "indent": 3,
      "text": "Typical data inputs for server-response computation will be:",
      "ja": "サーバー応答計算のための典型的なデータ入力は次のようになります。"
    },
    {
      "indent": 6,
      "text": "C - Counter, optional.",
      "ja": "C  - カウンター、オプション。"
    },
    {
      "indent": 6,
      "text": "QC - Challenge question, mandatory, supplied by the client.",
      "ja": "QC  - クライアントが供給する義務チャレンジ質問、。"
    },
    {
      "indent": 6,
      "text": "QS - Challenge question, mandatory, supplied by the server.",
      "ja": "QS  - サーバーによって提供される必須チャレンジ質問、。"
    },
    {
      "indent": 6,
      "text": "S - Session information, optional.",
      "ja": "S  - セッション情報、オプション。"
    },
    {
      "indent": 6,
      "text": "T - Timestamp, optional.",
      "ja": "T  - タイムスタンプ、オプション。"
    },
    {
      "indent": 3,
      "text": "Typical data inputs for client-response computation will be:",
      "ja": "クライアント応答の計算のための典型的なデータ入力は次のようになります。"
    },
    {
      "indent": 6,
      "text": "C - Counter, optional.",
      "ja": "C  - カウンター、オプション。"
    },
    {
      "indent": 6,
      "text": "QS - Challenge question, mandatory, supplied by the server.",
      "ja": "QS  - サーバーによって提供される必須チャレンジ質問、。"
    },
    {
      "indent": 6,
      "text": "QC - Challenge question, mandatory, supplied by the client.",
      "ja": "QC  - クライアントが供給する義務チャレンジ質問、。"
    },
    {
      "indent": 6,
      "text": "P - Hashed version of PIN/password, optional.",
      "ja": "P  -  PIN /パスワードのハッシュ化されたバージョン、オプション。"
    },
    {
      "indent": 6,
      "text": "S - Session information, optional.",
      "ja": "S  - セッション情報、オプション。"
    },
    {
      "indent": 6,
      "text": "T - Timestamp, optional.",
      "ja": "T  - タイムスタンプ、オプション。"
    },
    {
      "indent": 3,
      "text": "The following diagram shows the messages that are exchanged between the client and the server to complete a two-way mutual challenge-response authentication.",
      "ja": "次の図は、双方向の相互チャレンジレスポンス認証を完了するために、クライアントとサーバ間で交換されるメッセージを示しています。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the client and server have a pre-shared key K (or pair of keys if using dual-key mode of computation) that is used for the computation.",
      "ja": "クライアントとサーバが計算に使用される（計算のデュアルキーモードを使用する場合のキーまたは対）事前共有鍵Kを有すると仮定する。"
    },
    {
      "indent": 8,
      "text": " CLIENT                                             SERVER\n(PROVER)                                          (VERIFIER)\n   |                                                  |\n   |   1. Client sends client-challenge               |\n   |   QC = Client-challenge                          |\n   |------------------------------------------------->|\n   |                                                  |\n   |   2. Server computes server-response             |\n   |      and sends server-challenge                  |\n   |   RS = OCRA(K, [C] | QC | QS | [S | T])          |\n   |   QS = Server-challenge                          |\n   |   Response = RS, QS                              |\n   |<-------------------------------------------------|\n   |                                                  |\n   |   3. Client verifies server-response             |\n   |      and computes client-response                |\n   |   OCRA(K, [C] | QC | QS | [S | T]) != RS -> STOP |\n   |   RC = OCRA(K, [C] | QS | QC | [P | S | T])      |\n   |   Response = RC                                  |\n   |------------------------------------------------->|\n   |                                                  |\n   |   4. Server verifies client-response             |\n   |   OCRA(K, [C] | QS | QC | [P|S|T]) != RC -> STOP |\n   |   Response = OK                                  |\n   |<-------------------------------------------------|\n   |                                                  |",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3. Algorithm Modes for Signature",
      "section_title": true,
      "ja": "7.3。署名のためのアルゴリズムモード"
    },
    {
      "indent": 3,
      "text": "In this section we describe the typical modes in which the above defined computation can be used for electronic signatures.",
      "ja": "このセクションでは、上記で定義された計算は、電子署名のために使用することができる典型的な態様を記載します。"
    },
    {
      "indent": 0,
      "text": "7.3.1. Plain Signature",
      "section_title": true,
      "ja": "7.3.1。平野署名"
    },
    {
      "indent": 3,
      "text": "To use this algorithm in plain signature mode, the server will communicate a signature-challenge value to the client (signer). The signature-challenge is either the data to be signed or derived from the data to be signed using a hash function, for example.",
      "ja": "平野署名モードでこのアルゴリズムを使用するには、サーバはクライアント（署名者）に署名チャレンジ値を通信します。署名の課題は、データは署名または、例えば、ハッシュ関数を使用して署名されるべきデータに由来するとされますか。"
    },
    {
      "indent": 3,
      "text": "The client will use the signature-challenge in the computation as described above. The client then communicates the signature value (response) to the server to authenticate.",
      "ja": "前述したように、クライアントは、計算に署名チャレンジを使用します。その後、クライアントは、認証するためにサーバに署名値（応答）を伝達します。"
    },
    {
      "indent": 3,
      "text": "Therefore in this mode, the data inputs will be:",
      "ja": "したがって、このモードでは、データ入力は次のようになります。"
    },
    {
      "indent": 6,
      "text": "C - Counter, optional.",
      "ja": "C  - カウンター、オプション。"
    },
    {
      "indent": 6,
      "text": "QS - Signature-challenge, mandatory, supplied by the server.",
      "ja": "QS  - 署名 - 挑戦、必須、サーバーによって提供されます。"
    },
    {
      "indent": 6,
      "text": "P - Hashed version of PIN/password, optional.",
      "ja": "P  -  PIN /パスワードのハッシュ化されたバージョン、オプション。"
    },
    {
      "indent": 6,
      "text": "T - Timestamp, optional.",
      "ja": "T  - タイムスタンプ、オプション。"
    },
    {
      "indent": 3,
      "text": "The picture below shows the messages that are exchanged between the client (prover) and the server (verifier) to complete a plain signature operation.",
      "ja": "下の写真は、プレーン署名操作を完了するためにクライアント（証明）とサーバ（検証者）間で交換されるメッセージを示しています。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the client and server have a pre-shared key K that is used for the computation.",
      "ja": "クライアントとサーバーが計算に使用される事前共有鍵Kを持っていることを想定しています。"
    },
    {
      "indent": 12,
      "text": " CLIENT                                     SERVER\n(PROVER)                                  (VERIFIER)\n   |                                           |\n   |    Verifier sends signature-challenge     |\n   |    Challenge = QS                         |\n   |<------------------------------------------|\n   |                                           |\n   |    Client Computes Response               |\n   |    SIGN = OCRA(K, [C] | QS | [P | T])     |\n   |    Response = SIGN                        |\n   |------------------------------------------>|\n   |                                           |\n   |    Verifier Validates Response            |\n   |    Response = OK                          |\n   |<------------------------------------------|\n   |                                           |",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2. Signature with Server Authentication",
      "section_title": true,
      "ja": "7.3.2。サーバー認証と署名"
    },
    {
      "indent": 3,
      "text": "This mode is a variation of the plain signature mode where the client can first authenticate the server before generating a electronic signature.",
      "ja": "このモードでは、クライアントが最初に電子署名を生成する前に、サーバーを認証することができ、プレーン署名モードのバリエーションです。"
    },
    {
      "indent": 3,
      "text": "To use this algorithm, the client will first send a random client-challenge to the server. The server computes the server-response and sends it to the client along with a signature-challenge.",
      "ja": "このアルゴリズムを使用するには、クライアントが最初のサーバにランダムクライアントチャレンジを送信します。サーバーは、サーバーの応答を計算し、署名チャレンジと一緒にクライアントに送信します。"
    },
    {
      "indent": 3,
      "text": "The client will first verify the server-response to authenticate that it is talking to a valid server. It will then compute the signature and send it to the server.",
      "ja": "クライアントは、まず、それが有効なサーバーに話していることを認証するために、サーバーの応答を確認します。その後、署名を計算し、それをサーバに送信します。"
    },
    {
      "indent": 3,
      "text": "In this mode there are two computations: client-signature and server-response.",
      "ja": "クライアント署名とサーバーの応答：このモードでは2回の計算があります。"
    },
    {
      "indent": 3,
      "text": "Typical data inputs for server-response computation will be:",
      "ja": "サーバー応答計算のための典型的なデータ入力は次のようになります。"
    },
    {
      "indent": 6,
      "text": "C - Counter, optional.",
      "ja": "C  - カウンター、オプション。"
    },
    {
      "indent": 6,
      "text": "QC - Challenge question, mandatory, supplied by the client.",
      "ja": "QC  - クライアントが供給する義務チャレンジ質問、。"
    },
    {
      "indent": 6,
      "text": "QS - Signature-challenge, mandatory, supplied by the server.",
      "ja": "QS  - 署名 - 挑戦、必須、サーバーによって提供されます。"
    },
    {
      "indent": 6,
      "text": "T - Timestamp, optional.",
      "ja": "T  - タイムスタンプ、オプション。"
    },
    {
      "indent": 3,
      "text": "Typical data inputs for client-signature computation will be:",
      "ja": "クライアント署名の計算のための典型的なデータ入力は次のようになります。"
    },
    {
      "indent": 6,
      "text": "C - Counter, optional.",
      "ja": "C  - カウンター、オプション。"
    },
    {
      "indent": 6,
      "text": "QC - Challenge question, mandatory, supplied by the client.",
      "ja": "QC  - クライアントが供給する義務チャレンジ質問、。"
    },
    {
      "indent": 6,
      "text": "QS - Signature-challenge, mandatory, supplied by the server.",
      "ja": "QS  - 署名 - 挑戦、必須、サーバーによって提供されます。"
    },
    {
      "indent": 6,
      "text": "P - Hashed version of PIN/password, optional.",
      "ja": "P  -  PIN /パスワードのハッシュ化されたバージョン、オプション。"
    },
    {
      "indent": 6,
      "text": "T - Timestamp, optional.",
      "ja": "T  - タイムスタンプ、オプション。"
    },
    {
      "indent": 3,
      "text": "The diagram below shows the messages that are exchanged between the client and the server to complete a signature with server authentication transaction.",
      "ja": "下の図は、サーバーの認証トランザクションと署名を完了するために、クライアントとサーバ間で交換されるメッセージを示しています。"
    },
    {
      "indent": 3,
      "text": "It is assumed that the client and server have a pre-shared key K (or pair of keys if using dual-key mode of computation) that is used for the computation.",
      "ja": "クライアントとサーバが計算に使用される（計算のデュアルキーモードを使用する場合のキーまたは対）事前共有鍵Kを有すると仮定する。"
    },
    {
      "indent": 7,
      "text": " CLIENT                                              SERVER\n(PROVER)                                            VERIFIER)\n   |                                                   |\n   |    1. Client sends client-challenge               |\n   |    QC = Client-challenge                          |\n   |-------------------------------------------------->|\n   |                                                   |\n   |    2. Server computes server-response             |\n   |       and sends signature-challenge               |\n   |    RS = OCRA(K, [C] | QC | QS | [T])              |\n   |    QS = signature-challenge                       |\n   |    Response = RS, QS                              |\n   |<--------------------------------------------------|\n   |                                                   |\n   |    3. Client verifies server-response             |\n   |       and computes signature                      |\n   |    OCRA(K, [C] | QC | QS | [T]) != RS -> STOP     |\n   |    SIGN = OCRA( K, [C] | QS | QC | [P | T])       |\n   |    Response = SIGN                                |\n   |-------------------------------------------------->|\n   |                                                   |\n   |    4. Server verifies Signature                   |\n   |    OCRA(K, [C] | QS | QC | [P|T]) != SIGN -> STOP |\n   |    Response = OK                                  |\n   |<--------------------------------------------------|\n   |                                                   |",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Any algorithm is only as secure as the application and the authentication protocols that implement it. Therefore, this section discusses the critical security requirements that our choice of algorithm imposes on the authentication protocol and validation software.",
      "ja": "任意のアルゴリズムを適用し、それを実装する認証プロトコルと同じくらい安全です。したがって、このセクションでは、アルゴリズムの私達の選択は、認証プロトコルと検証ソフトウェアに課す重要なセキュリティ要件について説明します。"
    },
    {
      "indent": 0,
      "text": "8.1. Security Analysis of OCRA",
      "section_title": true,
      "ja": "8.1。 OCRAのセキュリティ分析"
    },
    {
      "indent": 3,
      "text": "The security and strength of this algorithm depend on the properties of the underlying building block HOTP, which is a construction based on HMAC [RFC2104] using SHA-1 [RFC3174] (or SHA-256 or SHA-512 [SHA2]) as the hash function.",
      "ja": "このアルゴリズムのセキュリティ強度がHMACとしてSHA-1 [RFC3174]（またはSHA-256やSHA-512 [SHA2]）を使用して、[RFC2104]に基づいて構築され、基礎となるビルディングブロックHOTPの特性に依存しますハッシュ関数。"
    },
    {
      "indent": 3,
      "text": "The conclusion of the security analysis detailed in [RFC4226] is that, for all practical purposes, the outputs of the dynamic truncation on distinct counter inputs are uniformly and independently distributed strings.",
      "ja": "[RFC4226]に詳細なセキュリティ解析の結論は、すべての実用的な目的のために、別個のカウンタ入力に動的トランケーションの出力が一様にかつ独立して文字列を分散している、ということです。"
    },
    {
      "indent": 3,
      "text": "The analysis demonstrates that the best possible attack against the HOTP function is the brute force attack.",
      "ja": "分析は、HOTP機能に対する最善の攻撃はブルートフォース攻撃であることを示しています。"
    },
    {
      "indent": 0,
      "text": "8.2. Implementation Considerations",
      "section_title": true,
      "ja": "8.2。実装に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "IC1 - In the authentication mode, the client MUST support two-factor authentication, i.e., the communication and verification of something you know (secret code such as a password, pass phrase, PIN code, etc.) and something you have (token). The secret code is known only to the user and usually entered with the Response value for authentication purpose (two-factor authentication). Alternatively, instead of sending something you know to the server, the client may use a hash of the password or PIN code in the computation itself, thus implicitly enabling two-factor authentication.",
      "ja": "IC1  - あなたが知っている何か（パスワードなどの秘密のコードなどのフレーズ、PINコードを、合格）とあなたが持っている何か（トークン）の認証モードでは、クライアントは、二要素認証をサポートしなければならない、すなわち、通信および検証。シークレットコードは、ユーザーに知られており、通常、認証目的（二要素認証）の応答値が入力されます。また、代わりにサーバーにあなたが知っている何かを送信すると、クライアントは、このように暗黙のうちに二要素認証を有効にする、計算自体にパスワードのハッシュまたはPINコードを使用することができます。"
    },
    {
      "indent": 3,
      "text": "IC2 - Keys SHOULD be of the length of the CryptoFunction output to facilitate interoperability.",
      "ja": "IC2  - キーは相互運用性を促進するためにCryptoFunction出力の長さであるべきです。"
    },
    {
      "indent": 3,
      "text": "IC3 - Keys SHOULD be chosen at random or using a cryptographically strong pseudo-random generator properly seeded with a random value. We RECOMMEND following the recommendations in [RFC4086] for all pseudo-random and random generations. The pseudo-random numbers used for generating the keys SHOULD successfully pass the randomness test specified in [CN].",
      "ja": "IC3は、 - キーは、ランダムに選択されたか、正しくランダム値を播種暗号的に強い疑似乱数発生器を使用する必要があります。我々は、すべての擬似ランダムおよびランダム世代のために[RFC4086]の推奨事項に従うことを推奨します。キーを生成するために使用される擬似乱数が正常[CN]で指定されたランダム性試験に合格すべきです。"
    },
    {
      "indent": 3,
      "text": "IC4 - Challenge questions SHOULD be 20-byte values and MUST be at least t-byte values where t stands for the digit-length of the OCRA truncation output.",
      "ja": "IC4  - チャレンジ質問は、20バイト値であるべきであり、そしてtはOCRA切り捨て出力の桁の長さを表し、少なくともTバイトの値でなければなりません。"
    },
    {
      "indent": 3,
      "text": "IC5 - On the client side, the keys SHOULD be embedded in a tamper-resistant device or securely implemented in a software application. Additionally, by embedding the keys in a hardware device, you also have the advantage of improving the flexibility (mobility) of the authentication system.",
      "ja": "IC5は、 - クライアント側では、鍵は耐タンパデバイス内に埋め込まするか安全ソフトウェアアプリケーションで実現します。また、ハードウェアデバイスに鍵を埋め込むことによって、あなたはまた、認証システムの柔軟性（移動性）を改善するという利点を持っています。"
    },
    {
      "indent": 3,
      "text": "IC6 - All the communications SHOULD take place over a secure channel, e.g., SSL/TLS [RFC5246], IPsec connections.",
      "ja": "IC6  - すべての通信は、例えば、SSL / TLS [RFC5246]、安全なチャネルを介してIPsec接続を行うべきです。"
    },
    {
      "indent": 3,
      "text": "IC7 - OCRA, when used in mutual authentication mode or in signature with server authentication mode, MAY use dual-key mode -- i.e., there are two keys that are shared between the client and the server. One shared key is used to generate the server response on the server side and to verify it on the client side. The other key is used to create the response or signature on the client side and to verify it on the server side.",
      "ja": "IC7  -  OCRAは、相互認証モードまたはサーバー認証モードに署名に使用される場合、デュアルモードキーを使用するかもしれ - すなわち、クライアントとサーバの間で共有される2つのキーがあります。一つの共有キーは、サーバー側のサーバの応答を生成し、クライアント側でそれを確認するために使用されます。他のキーは、クライアント側の応答または署名を作成すると、サーバー側でそれを確認するために使用されます。"
    },
    {
      "indent": 3,
      "text": "IC8 - We recommend that implementations MAY use the session information, S, as an additional input in the computation. For example, S could be the session identifier from the TLS session.",
      "ja": "IC8は - 私たちは、実装は、計算で追加の入力として、セッション情報、Sを使用するかもしれないことをお勧めします。例えば、Sは、TLSセッションからセッション識別子である可能性があります。"
    },
    {
      "indent": 3,
      "text": "This will mitigate against certain types of man-in-the-middle attacks. However, this will introduce the additional dependency that first of all the prover needs to have access to the session identifier to compute the response and the verifier will need access to the session identifier to verify the response. [RFC5056] contains a relevant discussion of using Channel Bindings to Secure Channels.",
      "ja": "これは、man-in-the-middle攻撃の特定の種類を軽減します。しかし、これは最初にすべての証明の応答と応答を確認するために、セッション識別子へのアクセスを必要とする検証を計算するためにセッション識別子へのアクセス権を持っている必要があり、追加の依存関係を紹介します。 [RFC5056]はチャンネルを確保するためにチャネルバインディングを使用しての関連する議論が含まれています。"
    },
    {
      "indent": 3,
      "text": "IC9 - In the signature mode, whenever the counter or time (defined as optional elements) are not used in the computation, there might be a risk of replay attack and the implementers should carefully consider this issue in the light of their specific application requirements and security guidelines. The server SHOULD also provide whenever possible a mean for the client (if able) to verify the validity of the signature challenge.",
      "ja": "IC9  - （オプションの要素として定義される）カウンターや時間が計算に使用されていない時はいつでも署名モードでは、リプレイ攻撃や実装のリスクがあるかもしれませんが、慎重に彼らの特定のアプリケーションの要件に照らして、この問題を検討すべきであるとセキュリティガイドライン。クライアントの平均は、（可能ならば）署名挑戦の妥当性を検証するために、可能な限りサーバーも提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "IC10 - We also RECOMMEND storing the keys securely in the validation system, and more specifically, encrypting them using tamper-resistant hardware encryption and exposing them only when required: for example, the key is decrypted when needed to verify an OCRA response, and re-encrypted immediately to limit exposure in the RAM for a short period of time. The key store MUST be in a secure area, to avoid as much as possible direct attack on the validation system and secrets database. Particularly, access to the key material should be limited to programs and processes required by the validation system only.",
      "ja": "OCRAの応答を確認するために必要な場合、例えば、鍵が解読され、再： -  IC10はまた、耐タンパ性ハードウェア暗号化を使用して暗号化し、必要な場合にのみ、それらを露光、より具体的に検証システムに安全に鍵を格納する勧め、及び短時間のRAMで露出を制限するために、すぐに-encrypted。キーストアは、検証システムと秘密データベース上で可能な直接攻撃な限り避けるために、安全な場所になければなりません。特に、キーマテリアルへのアクセスは、検証システムで必要なプログラムやプロセスに限定されるべきです。"
    },
    {
      "indent": 0,
      "text": "9. Conclusion",
      "section_title": true,
      "ja": "9.おわり"
    },
    {
      "indent": 3,
      "text": "This document introduced several variants of HOTP for challenge-response-based authentication and short signature-like computations.",
      "ja": "この文書では、チャレンジ・レスポンスベースの認証と短い署名のような計算のためにHOTPのいくつかの変種を導入しました。"
    },
    {
      "indent": 3,
      "text": "The OCRASuite provides for an easy integration and support of different flavors within an authentication and validation system.",
      "ja": "OCRASuiteは、認証および検証システム内の異なる味の容易な統合とサポートを提供します。"
    },
    {
      "indent": 3,
      "text": "Finally, OCRA should enable mutual authentication both in connected and off-line modes, with the support of different response sizes and mode of operations.",
      "ja": "最後に、OCRAは異なる応答サイズ及び操作のモードをサポートして、両方の接続とオフラインモードで相互認証を可能にすべきです。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgements",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Jeff Burstein, Shuh Chang, Oanh Hoang, Philip Hoyer, Jon Martinsson, Frederik Mennes, Mingliang Pei, Jonathan Tuliani, Stu Vaeth, Enrique Rodriguez, and Robert Zuccherato for their comments and suggestions to improve this document.",
      "ja": "私たちは、この文書を改善するために、自分の意見や提案のためにジェフ・バースタイン、Shuhチャン、Oanhホアン、フィリップ・ホイヤー、ジョンMartinsson、フレデリックMENNES、Mingliangペイ、ジョナサンTuliani、ステューVaeth、エンリケ・ロドリゲス、そしてロバートZuccheratoに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3174] Eastlake, D. and P. Jones, \"US Secure Hash Algorithm 1 (SHA1)\", RFC 3174, September 2001.",
      "ja": "[RFC3174]イーストレイク、D.とP.ジョーンズは、 \"米国は、ハッシュアルゴリズム1（SHA1）を確保\"、RFC 3174、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4226] M'Raihi, D., Bellare, M., Hoornaert, F., Naccache, D., and O. Ranen, \"HOTP: An HMAC-Based One-Time Password Algorithm\", RFC 4226, December 2005.",
      "ja": "[RFC4226] M'Raihi、D.、ベラー、M.、Hoornaert、F.、Naccache、D.、およびO. Ranen、 \"HOTP：HMACベースのワンタイムパスワードアルゴリズム\"、RFC 4226、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[SHA2] NIST, \"FIPS PUB 180-3: Secure Hash Standard (SHS)\", October 2008, <http://csrc.nist.gov/publications/fips/ fips180-3/fips180-3_final.pdf>.",
      "ja": "[SHA2] NIST、 \"FIPS PUB 180-3の：セキュアハッシュ標準（SHS）\"、2008年10月、<http://csrc.nist.gov/publications/fips/ fips180-3 / fips180-3_final.pdf>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[CN] Coron, J. and D. Naccache, \"An accurate evaluation of Maurer's universal test\", LNCS 1556, February 1999, <http: //www.gemplus.com/smart/rd/publications/pdf/CN99maur.pdf>.",
      "ja": "[CN]コロン、J.とD. Naccache、 \"マウラーのユニバーサルテストの正確な評価\"、LNCS 1556、1999年2月、<のhttp：//www.gemplus.com/smart/rd/publications/pdf/CN99maur.pdf >。"
    },
    {
      "indent": 3,
      "text": "[OATH] Initiative for Open Authentication, \"OATH Vision\", <http://www.openauthentication.org/about>.",
      "ja": "[OATH]イニシアティブオープン認証のため、 \"OATHビジョン\"、<http://www.openauthentication.org/about>。"
    },
    {
      "indent": 3,
      "text": "[RFC5056] Williams, N., \"On the Use of Channel Bindings to Secure Channels\", RFC 5056, November 2007.",
      "ja": "\"チャネルを確保するチャネルバインディングの使用について\" [RFC5056]ウィリアムズ、N.、RFC 5056、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6030] Hoyer, P., Pei, M., and S. Machani, \"Portable Symmetric Key Container (PSKC)\", RFC 6030, October 2010.",
      "ja": "[RFC6030]ホイヤー、P.、ペイ、M.、およびS. Machani、 \"ポータブル対称キーコンテナ（PSKC）\"、RFC 6030、2010年10月。"
    },
    {
      "indent": 3,
      "text": "[UT] Wikipedia, \"Unix time\", <http://en.wikipedia.org/wiki/Unix_time>.",
      "ja": "[UT]ウィキペディア、 \"Unixの時間\"、<http://en.wikipedia.org/wiki/Unix_time>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Reference Implementation",
      "ja": "付録A.リファレンス実装"
    },
    {
      "indent": 2,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 2,
      "text": "/**\n   Copyright (c) 2011 IETF Trust and the persons identified as\n   authors of the code. All rights reserved.",
      "raw": true
    },
    {
      "indent": 3,
      "text": " Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info). */",
      "ja": "、に基づき許可されており、中に含まれるライセンス条項に従う、簡体BSDライセンスは、IETFドキュメントに関連IETFトラストの法律規定（のセクション4.Cに記載されている変更の有無にかかわらず、ソースおよびバイナリ形式での再配布および使用http://trustee.ietf.org/license-info）。 * /"
    },
    {
      "indent": 2,
      "text": "import javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.math.BigInteger;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "/**\n * This an example implementation of OCRA.\n * Visit www.openauthentication.org for more information.\n *\n * @author Johan Rydell, PortWise\n */\npublic class OCRA {",
      "raw": true
    },
    {
      "indent": 6,
      "text": "private OCRA() {}",
      "ja": "プライベートOCRA（）{}"
    },
    {
      "indent": 6,
      "text": "/**\n * This method uses the JCE to provide the crypto\n * algorithm.\n * HMAC computes a Hashed Message Authentication Code with the\n * crypto hash algorithm as a parameter.\n *\n * @param crypto     the crypto algorithm (HmacSHA1, HmacSHA256,\n *                                   HmacSHA512)\n * @param keyBytes   the bytes to use for the HMAC key\n * @param text       the message or text to be authenticated.\n */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "private static byte[] hmac_sha1(String crypto,\n                 byte[] keyBytes, byte[] text){\n    Mac hmac = null;\n    try {\n        hmac = Mac.getInstance(crypto);\n        SecretKeySpec macKey =\n            new SecretKeySpec(keyBytes, \"RAW\");",
      "raw": true
    },
    {
      "indent": 6,
      "text": "        hmac.init(macKey);\n        return hmac.doFinal(text);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "private static final int[] DIGITS_POWER // 0 1 2 3 4 5 6 7 8 = {1,10,100,1000,10000,100000,1000000,10000000,100000000 };",
      "ja": "プライベート静的最終int型= {1,10,100,1000,10000,100000,1000000,10000000,100000000} // 0 1 2 3 4 5 6 7 8 [] DIGITS_POWER。"
    },
    {
      "indent": 6,
      "text": "/**\n * This method converts HEX string to Byte[]\n *\n * @param hex   the HEX string\n *\n * @return      A byte array\n */\nprivate static byte[] hexStr2Bytes(String hex){\n    // Adding one byte to get the right conversion\n    // values starting with \"0\" can be converted\n    byte[] bArray = new BigInteger(\"10\" + hex,16).toByteArray();",
      "raw": true
    },
    {
      "indent": 6,
      "text": "    // Copy all the REAL bytes, not the \"first\"\n    byte[] ret = new byte[bArray.length - 1];\n    System.arraycopy(bArray, 1, ret, 0, ret.length);\n    return ret;\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "/**\n * This method generates an OCRA HOTP value for the given\n * set of parameters.\n *\n * @param ocraSuite    the OCRA Suite\n * @param key          the shared secret, HEX encoded\n * @param counter      the counter that changes on a per use\n *                     basis, HEX encoded\n * @param question     the challenge question, HEX encoded\n * @param password     a password that can be used, HEX encoded\n * @param sessionInformation Static information that identifies\n *                     the current session, Hex encoded\n * @param timeStamp    a value that reflects a time\n *\n * @return A numeric String in base 10 that includes\n * {@link truncationDigits} digits",
      "raw": true
    },
    {
      "indent": 6,
      "text": " */ static public String generateOCRA(String ocraSuite, String key, String counter, String question, String password, String sessionInformation, String timeStamp){",
      "ja": "* /静的パブリック文字列generateOCRA（文字ocraSuite、文字列のキー、文字列のカウンター、文字列の質問、文字列のパスワード、文字列セッション情報、文字列のtimeStampに）{"
    },
    {
      "indent": 10,
      "text": "int codeDigits = 0;\nString crypto = \"\";\nString result = null;\nint ocraSuiteLength = (ocraSuite.getBytes()).length;\nint counterLength = 0;\nint questionLength = 0;\nint passwordLength = 0;\nint sessionInformationLength = 0;\nint timeStampLength = 0;",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// The OCRASuites components\nString CryptoFunction = ocraSuite.split(\":\")[1];\nString DataInput = ocraSuite.split(\":\")[2];",
      "raw": true
    },
    {
      "indent": 10,
      "text": "if(CryptoFunction.toLowerCase().indexOf(\"sha1\") > 1)\n    crypto = \"HmacSHA1\";\nif(CryptoFunction.toLowerCase().indexOf(\"sha256\") > 1)\n    crypto = \"HmacSHA256\";\nif(CryptoFunction.toLowerCase().indexOf(\"sha512\") > 1)\n    crypto = \"HmacSHA512\";",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// How many digits should we return codeDigits = Integer.decode(CryptoFunction.substring( CryptoFunction.lastIndexOf(\"-\")+1));",
      "ja": "//どのように多くの桁が、我々は返す必要がありますcodeDigits = Integer.decode（CryptoFunction.substring（CryptoFunction.lastIndexOf（ \" - \"）+ 1））;"
    },
    {
      "indent": 10,
      "text": "// The size of the byte array message to be encrypted\n// Counter\nif(DataInput.toLowerCase().startsWith(\"c\")) {\n    // Fix the length of the HEX string\n    while(counter.length() < 16)\n        counter = \"0\" + counter;\n    counterLength=8;\n}\n// Question - always 128 bytes\nif(DataInput.toLowerCase().startsWith(\"q\") ||\n        (DataInput.toLowerCase().indexOf(\"-q\") >= 0)) {\n    while(question.length() < 256)\n        question = question + \"0\";",
      "raw": true
    },
    {
      "indent": 10,
      "text": " questionLength=128; }",
      "ja": "questionLength = 128。 }"
    },
    {
      "indent": 10,
      "text": "// Password - sha1\nif(DataInput.toLowerCase().indexOf(\"psha1\") > 1){\n    while(password.length() < 40)\n        password = \"0\" + password;\n    passwordLength=20;\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// Password - sha256\nif(DataInput.toLowerCase().indexOf(\"psha256\") > 1){\n    while(password.length() < 64)\n        password = \"0\" + password;\n    passwordLength=32;\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// Password - sha512\nif(DataInput.toLowerCase().indexOf(\"psha512\") > 1){\n    while(password.length() < 128)\n        password = \"0\" + password;\n    passwordLength=64;\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// sessionInformation - s064\nif(DataInput.toLowerCase().indexOf(\"s064\") > 1){\n    while(sessionInformation.length() < 128)\n        sessionInformation = \"0\" + sessionInformation;\n    sessionInformationLength=64;\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// sessionInformation - s128\nif(DataInput.toLowerCase().indexOf(\"s128\") > 1){\n    while(sessionInformation.length() < 256)\n        sessionInformation = \"0\" + sessionInformation;\n    sessionInformationLength=128;\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// sessionInformation - s256\nif(DataInput.toLowerCase().indexOf(\"s256\") > 1){\n    while(sessionInformation.length() < 512)\n        sessionInformation = \"0\" + sessionInformation;\n    sessionInformationLength=256;\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// sessionInformation - s512 if(DataInput.toLowerCase().indexOf(\"s512\") > 1){ while(sessionInformation.length() < 1024)",
      "ja": "//セッション情報 -  S512 IF（。DataInput.toLowerCase（）のindexOf（ \"S512\"）> 1）{（sessionInformation.length（）<1024）、一方"
    },
    {
      "indent": 10,
      "text": "        sessionInformation = \"0\" + sessionInformation;\n    sessionInformationLength=512;\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// TimeStamp\nif(DataInput.toLowerCase().startsWith(\"t\") ||\n        (DataInput.toLowerCase().indexOf(\"-t\") > 1)){\n    while(timeStamp.length() < 16)\n        timeStamp = \"0\" + timeStamp;\n    timeStampLength=8;\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// Remember to add \"1\" for the \"00\" byte delimiter byte[] msg = new byte[ocraSuiteLength + counterLength + questionLength + passwordLength + sessionInformationLength + timeStampLength + 1];",
      "ja": "// \"00\" バイトの区切りバイトのために \"1\" を追加してください[] MSG =新しいバイト[ocraSuiteLength + counterLength + questionLength + passwordLength + sessionInformationLength + timeStampLength + 1];"
    },
    {
      "indent": 10,
      "text": "// Put the bytes of \"ocraSuite\" parameters into the message\nbyte[] bArray = ocraSuite.getBytes();\nSystem.arraycopy(bArray, 0, msg, 0, bArray.length);",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// Delimiter msg[bArray.length] = 0x00;",
      "ja": "//デリミタMSG [bArray.length] = 0x00で、"
    },
    {
      "indent": 10,
      "text": "// Put the bytes of \"Counter\" to the message\n// Input is HEX encoded\nif(counterLength > 0 ){\n    bArray = hexStr2Bytes(counter);\n    System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1,\n            bArray.length);\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// Put the bytes of \"question\" to the message\n// Input is text encoded\nif(questionLength > 0 ){\n    bArray = hexStr2Bytes(question);\n    System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +\n            counterLength, bArray.length);\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// Put the bytes of \"password\" to the message\n// Input is HEX encoded if(passwordLength > 0){\n    bArray = hexStr2Bytes(password);\n    System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +\n            counterLength +    questionLength, bArray.length);",
      "raw": true
    },
    {
      "indent": 10,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 10,
      "text": "// Put the bytes of \"sessionInformation\" to the message\n// Input is text encoded\nif(sessionInformationLength > 0 ){\n    bArray = hexStr2Bytes(sessionInformation);\n    System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +\n            counterLength +     questionLength +\n            passwordLength, bArray.length);\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "// Put the bytes of \"time\" to the message\n// Input is text value of minutes\nif(timeStampLength > 0){\n    bArray = hexStr2Bytes(timeStamp);\n    System.arraycopy(bArray, 0, msg, ocraSuiteLength + 1 +\n            counterLength + questionLength +\n            passwordLength + sessionInformationLength,\n            bArray.length);\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "bArray = hexStr2Bytes(key);",
      "ja": "= hexStr2Bytesは（キー）に教示しました。"
    },
    {
      "indent": 10,
      "text": "byte[] hash = hmac_sha1(crypto, bArray, msg);",
      "ja": "バイト[]ハッシュ= HMAC_SHA1（暗号、bArray、MSG）。"
    },
    {
      "indent": 10,
      "text": "// put selected bytes into result int int offset = hash[hash.length - 1] & 0xf;",
      "ja": "//は、結果INT INTオフセット=ハッシュ[hash.length  -  1]に選択されたバイトを入れ＆0xFの。"
    },
    {
      "indent": 10,
      "text": "int binary = ((hash[offset] & 0x7f) << 24) | ((hash[offset + 1] & 0xff) << 16) | ((hash[offset + 2] & 0xff) << 8) | (hash[offset + 3] & 0xff);",
      "ja": "int型のバイナリ=（（ハッシュ[オフセット]＆から0x7f）<< 24）| （（ハッシュ0xffの＆[+ 1オフセット]）<< 16）| （（ハッシュ[+ 2オフセット]＆0xffの）<< 8）| （ハッシュ[+ 3のオフセット]＆0xffで）。"
    },
    {
      "indent": 10,
      "text": "int otp = binary % DIGITS_POWER[codeDigits];",
      "ja": "INT OTP =バイナリ％DIGITS_POWER [codeDigits]。"
    },
    {
      "indent": 2,
      "text": "        result = Integer.toString(otp);\n        while (result.length() < codeDigits) {\n            result = \"0\" + result;\n        }\n        return result;\n    }\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 0,
      "text": "Appendix B. Test Vectors Generation",
      "ja": "付録B.テストベクトルの生成"
    },
    {
      "indent": 2,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 2,
      "text": "/**\n   Copyright (c) 2011 IETF Trust and the persons identified as\n   authors of the code. All rights reserved.",
      "raw": true
    },
    {
      "indent": 3,
      "text": " Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info). */",
      "ja": "、に基づき許可されており、中に含まれるライセンス条項に従う、簡体BSDライセンスは、IETFドキュメントに関連IETFトラストの法律規定（のセクション4.Cに記載されている変更の有無にかかわらず、ソースおよびバイナリ形式での再配布および使用http://trustee.ietf.org/license-info）。 * /"
    },
    {
      "indent": 2,
      "text": "import java.math.BigInteger;\nimport java.util.*;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "public class TestOCRA {",
      "ja": "{publicクラスTestOCRA"
    },
    {
      "indent": 2,
      "text": "public static String asHex (byte buf[]) {\n    StringBuffer strbuf = new StringBuffer(buf.length * 2);\n    int i;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "    for (i = 0; i < buf.length; i++) {\n        if (((int) buf[i] & 0xff) < 0x10)\n            strbuf.append(\"0\");\n        strbuf.append(Long.toString((int) buf[i] & 0xff, 16));\n    }\n    return strbuf.toString();\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "/**\n * @param args\n */\npublic static void main(String[] args) {",
      "raw": true
    },
    {
      "indent": 6,
      "text": "String ocra = \"\";\nString seed = \"\";\nString ocraSuite = \"\";\nString counter = \"\";\nString password = \"\";\nString sessionInformation = \"\";\nString question = \"\";",
      "raw": true
    },
    {
      "indent": 6,
      "text": "String qHex = \"\";\nString timeStamp = \"\";",
      "raw": true
    },
    {
      "indent": 6,
      "text": "// PASS1234 is SHA1 hash of \"1234\" String PASS1234 = \"7110eda4d09e062aa5e4a390b0a572ac0d2c0220\";",
      "ja": "// PASS1234は、 \"1234\" の文字列PASS1234 = \"7110eda4d09e062aa5e4a390b0a572ac0d2c0220\" のSHA1ハッシュです。"
    },
    {
      "indent": 6,
      "text": "String SEED = \"3132333435363738393031323334353637383930\";\nString SEED32 = \"31323334353637383930313233343536373839\" +\n    \"30313233343536373839303132\";\nString SEED64 = \"31323334353637383930313233343536373839\" +\n    \"3031323334353637383930313233343536373839\" +\n    \"3031323334353637383930313233343536373839\" +\n    \"3031323334\";\nint STOP = 5;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Date myDate = Calendar.getInstance().getTime();\nBigInteger b = new BigInteger(\"0\");\nString sDate = \"Mar 25 2008, 12:06:30 GMT\";",
      "raw": true
    },
    {
      "indent": 6,
      "text": "try{\n    DateFormat df =\n        new SimpleDateFormat(\"MMM dd yyyy, HH:mm:ss zzz\");\n    myDate = df.parse(sDate);\n    b = new BigInteger(\"0\" + myDate.getTime());\n    b = b.divide(new BigInteger(\"60000\"));",
      "raw": true
    },
    {
      "indent": 10,
      "text": "System.out.println(\"Time of \\\"\" + sDate + \"\\\" is in\");\nSystem.out.println(\"milli sec: \" + myDate.getTime());\nSystem.out.println(\"minutes: \" + b.toString());\nSystem.out.println(\"minutes (HEX encoded): \"\n    + b.toString(16).toUpperCase());\nSystem.out.println(\"Time of \\\"\" + sDate\n    + \"\\\" is the same as this localized\");\nSystem.out.println(\"time, \\\"\"\n    + new Date(myDate.getTime()) + \"\\\"\");",
      "raw": true
    },
    {
      "indent": 10,
      "text": "System.out.println();\nSystem.out.println(\"Standard 20Byte key: \" +\n    \"3132333435363738393031323334353637383930\");\nSystem.out.println(\"Standard 32Byte key: \" +\n    \"3132333435363738393031323334353637383930\");\nSystem.out.println(\"                     \" +\n    \"313233343536373839303132\");\nSystem.out.println(\"Standard 64Byte key: 313233343536373839\"\n    + \"3031323334353637383930\");\nSystem.out.println(\"                     313233343536373839\"\n    + \"3031323334353637383930\");",
      "raw": true
    },
    {
      "indent": 10,
      "text": "System.out.println(\"                     313233343536373839\"\n    + \"3031323334353637383930\");\nSystem.out.println(\"                     31323334\");",
      "raw": true
    },
    {
      "indent": 10,
      "text": "System.out.println();\nSystem.out.println(\"Plain challenge response\");\nSystem.out.println(\"========================\");\nSystem.out.println();",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA1-6:QN08\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"=======================\");\nseed = SEED;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < 10; i++){\n    question = \"\" + i + i + i + i + i + i + i + i;\n    qHex = new String((new BigInteger(question,10))\n               .toString(16)).toUpperCase();\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n                   qHex,password,\n                   sessionInformation,timeStamp);\n     System.out.println(\"Key: Standard 20Byte  Q: \"\n            + question + \"  OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA256-8:C-QN08-PSHA1\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"=================================\");\nseed = SEED32;\ncounter = \"\";\nquestion = \"12345678\";\npassword = PASS1234;\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < 10; i++){\n    counter = \"\" + i;\n    qHex = new String((new BigInteger(question,10))\n               .toString(16)).toUpperCase();\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n               qHex,password,sessionInformation,timeStamp);\n    System.out.println(\"Key: Standard 32Byte  C: \"\n                 + counter + \"  Q: \"\n                 + question + \"  PIN(1234): \");",
      "raw": true
    },
    {
      "indent": 10,
      "text": "    System.out.println(password + \"  OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA256-8:QN08-PSHA1\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"===============================\");\nseed = SEED32;\ncounter = \"\";\nquestion = \"\";\npassword = PASS1234;\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < STOP; i++){\n    question = \"\" + i + i + i + i + i + i + i + i;",
      "raw": true
    },
    {
      "indent": 10,
      "text": "    qHex = new String((new BigInteger(question,10))\n                .toString(16)).toUpperCase();\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n             qHex,password,sessionInformation,timeStamp);\n    System.out.println(\"Key: Standard 32Byte  Q: \"\n                + question + \"  PIN(1234): \");\n    System.out.println(password + \"  OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA512-8:C-QN08\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"===========================\");\nseed = SEED64;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < 10; i++){\n    question = \"\" + i + i + i + i + i + i + i + i;\n    qHex = new String((new BigInteger(question,10))\n                .toString(16)).toUpperCase();\n    counter = \"0000\" + i;\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n             qHex,password,sessionInformation,timeStamp);\n    System.out.println(\"Key: Standard 64Byte  C: \"\n             + counter + \"  Q: \"\n             + question + \"  OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA512-8:QN08-T1M\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"=============================\");\nseed = SEED64;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = b.toString(16);\nfor(int i=0; i < STOP; i++){\n    question = \"\" + i + i + i + i + i + i + i + i;\n    counter = \"\";\n    qHex = new String((new BigInteger(question,10))\n                .toString(16)).toUpperCase();\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n             qHex,password,sessionInformation,timeStamp);",
      "raw": true
    },
    {
      "indent": 10,
      "text": "    System.out.println(\"Key: Standard 64Byte  Q: \"\n                + question +\"  T: \"\n                  + timeStamp.toUpperCase()\n                + \"  OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true
    },
    {
      "indent": 10,
      "text": "System.out.println();\nSystem.out.println(\"Mutual Challenge Response\");\nSystem.out.println(\"=========================\");\nSystem.out.println();",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA256-8:QA08\";\nSystem.out.println(\"OCRASuite (server computation) = \"\n                   + ocraSuite);\nSystem.out.println(\"OCRASuite (client computation) = \"\n                   + ocraSuite);\nSystem.out.println(\"===============================\" +\n    \"===========================\");\nseed = SEED32;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < STOP; i++){\n    question = \"CLI2222\" + i + \"SRV1111\" + i;\n    qHex = asHex(question.getBytes());\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n                 password,sessionInformation,timeStamp);\n    System.out.println(",
      "raw": true
    },
    {
      "indent": 10,
      "text": "             \"(server)Key: Standard 32Byte  Q: \"\n             + question + \"  OCRA: \"\n             + ocra);\n    question = \"SRV1111\" + i + \"CLI2222\" + i;\n    qHex = asHex(question.getBytes());\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n                 password,sessionInformation,timeStamp);\n    System.out.println(\n             \"(client)Key: Standard 32Byte  Q: \"\n             + question + \"  OCRA: \"\n             + ocra);\n}\nSystem.out.println();",
      "raw": true
    },
    {
      "indent": 10,
      "text": "String ocraSuite1 = \"OCRA-1:HOTP-SHA512-8:QA08\";\nString ocraSuite2 = \"OCRA-1:HOTP-SHA512-8:QA08-PSHA1\";\nSystem.out.println(\"OCRASuite (server computation) = \"\n                   + ocraSuite1);\nSystem.out.println(\"OCRASuite (client computation) = \"\n                   + ocraSuite2);\nSystem.out.println(\"===============================\" +\n    \"=================================\");\nocraSuite = \"\";\nseed = SEED64;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < STOP; i++){\n    ocraSuite = ocraSuite1;\n    question = \"CLI2222\" + i + \"SRV1111\" + i;\n    qHex = asHex(question.getBytes());\n    password = \"\";\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n                 password,sessionInformation,timeStamp);\n    System.out.println(\n                \"(server)Key: Standard 64Byte  Q: \"\n                + question + \"  OCRA: \"\n                + ocra);\n    ocraSuite = ocraSuite2;\n    question = \"SRV1111\" + i + \"CLI2222\" + i;\n    qHex = asHex(question.getBytes());\n    password = PASS1234;\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n                 password,sessionInformation,timeStamp);\n    System.out.println(\"(client)Key: Standard 64Byte  Q: \"\n                 + question);",
      "raw": true
    },
    {
      "indent": 10,
      "text": "    System.out.println(\"P: \" + password.toUpperCase()\n                 + \"  OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true
    },
    {
      "indent": 10,
      "text": "System.out.println();\nSystem.out.println(\"Plain Signature\");\nSystem.out.println(\"===============\");\nSystem.out.println();\nocraSuite = \"OCRA-1:HOTP-SHA256-8:QA08\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"=========================\");\nseed = SEED32;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = \"\";\nfor(int i=0; i < STOP; i++){\n    question = \"SIG1\" + i + \"000\";\n    qHex = asHex(question.getBytes());\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,qHex,\n                 password,sessionInformation,timeStamp);\n    System.out.println(\n            \"Key: Standard 32Byte  Q(Signature challenge): \"\n            + question);\n    System.out.println(\"   OCRA: \" + ocra);\n}\nSystem.out.println();",
      "raw": true
    },
    {
      "indent": 10,
      "text": "ocraSuite = \"OCRA-1:HOTP-SHA512-8:QA10-T1M\";\nSystem.out.println(ocraSuite);\nSystem.out.println(\"=============================\");\nseed = SEED64;\ncounter = \"\";\nquestion = \"\";\npassword = \"\";\nsessionInformation = \"\";\ntimeStamp = b.toString(16);\nfor(int i=0; i < STOP; i++){\n    question = \"SIG1\" + i + \"00000\";\n    qHex = asHex(question.getBytes());\n    ocra = OCRA.generateOCRA(ocraSuite,seed,counter,\n                 qHex,password,sessionInformation,timeStamp);\n    System.out.println(\n            \"Key: Standard 64Byte  Q(Signature challenge): \"\n            + question);\n    System.out.println(\"   T: \"",
      "raw": true
    },
    {
      "indent": 10,
      "text": " + timeStamp.toUpperCase() + \" OCRA: \" + ocra); }",
      "ja": "TimeStamp.toUpperCase +（）+ \"OCRA\" +黄土）。 }"
    },
    {
      "indent": 2,
      "text": " }catch (Exception e){ System.out.println(\"Error : \" + e); } } } <CODE ENDS>",
      "ja": "}キャッチ（例外e）{System.out.printlnは（ \"エラー：\" + E）。 }}} <CODEを終了します>"
    },
    {
      "indent": 0,
      "text": "Appendix C. Test Vectors",
      "ja": "付録C.テストベクトル"
    },
    {
      "indent": 3,
      "text": "This section provides test values that can be used for the OCRA interoperability test.",
      "ja": "このセクションでは、OCRAの相互運用性のテストのために使用することができるテスト値を提供します。"
    },
    {
      "indent": 3,
      "text": "Standard 20Byte key:",
      "ja": "標準20Byteキー："
    },
    {
      "indent": 3,
      "text": "3132333435363738393031323334353637383930",
      "ja": "３１３２３３３４３５３６３７３８３９３０３１３２３３３４３５３６３７３８３９３０"
    },
    {
      "indent": 3,
      "text": "Standard 32Byte key:",
      "ja": "標準的な32バイトのキー："
    },
    {
      "indent": 3,
      "text": "3132333435363738393031323334353637383930313233343536373839303132",
      "ja": "３１３２３３３４３５３６３７３８３９３０３１３２３３３４３５３６３７３８３９３０３１３２３３３４３５３６３７３８３９３０３１３２"
    },
    {
      "indent": 3,
      "text": "Standard 64Byte key:",
      "ja": "標準的な64バイトのキー："
    },
    {
      "indent": 3,
      "text": "313233343536373839303132333435363738393031323334353637383930313233343 53637383930313233343536373839303132333435363738393031323334",
      "ja": "３１３２３３３４３５３６３７３８３９３０３１３２３３３４３５３６３７３８３９３０３１３２３３３４３５３６３７３８３９３０３１３２３３３４３ ５３６３７３８３９３０３１３２３３３４３５３６３７３８３９３０３１３２３３３４３５３６３７３８３９３０３１３２３３３４"
    },
    {
      "indent": 3,
      "text": "PIN (1234) SHA1 hash value:",
      "ja": "PIN（1234）SHA1ハッシュ値："
    },
    {
      "indent": 3,
      "text": "7110eda4d09e062aa5e4a390b0a572ac0d2c0220",
      "ja": "7110eda4d09e062aa5e4a390b0a572ac0d2c0220"
    },
    {
      "indent": 0,
      "text": "C.1. One-Way Challenge Response",
      "ja": "C.1。ワンウェイチャレンジレスポンス"
    },
    {
      "indent": 16,
      "text": "+-----------------+----------+------------+\n|       Key       |     Q    | OCRA Value |\n+-----------------+----------+------------+\n| Standard 20Byte | 00000000 |   237653   |\n| Standard 20Byte | 11111111 |   243178   |\n| Standard 20Byte | 22222222 |   653583   |\n| Standard 20Byte | 33333333 |   740991   |\n| Standard 20Byte | 44444444 |   608993   |\n| Standard 20Byte | 55555555 |   388898   |\n| Standard 20Byte | 66666666 |   816933   |\n| Standard 20Byte | 77777777 |   224598   |\n| Standard 20Byte | 88888888 |   750600   |\n| Standard 20Byte | 99999999 |   294470   |\n+-----------------+----------+------------+",
      "raw": true
    },
    {
      "indent": 26,
      "text": "OCRA-1:HOTP-SHA1-6:QN08",
      "ja": "OCRA-1：HOTP-SHA1-6：QN08"
    },
    {
      "indent": 14,
      "text": "+-----------------+---+----------+------------+\n|       Key       | C |     Q    | OCRA Value |\n+-----------------+---+----------+------------+\n| Standard 32Byte | 0 | 12345678 |  65347737  |\n| Standard 32Byte | 1 | 12345678 |  86775851  |\n| Standard 32Byte | 2 | 12345678 |  78192410  |\n| Standard 32Byte | 3 | 12345678 |  71565254  |\n| Standard 32Byte | 4 | 12345678 |  10104329  |\n| Standard 32Byte | 5 | 12345678 |  65983500  |\n| Standard 32Byte | 6 | 12345678 |  70069104  |\n| Standard 32Byte | 7 | 12345678 |  91771096  |\n| Standard 32Byte | 8 | 12345678 |  75011558  |\n| Standard 32Byte | 9 | 12345678 |  08522129  |\n+-----------------+---+----------+------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "OCRA-1:HOTP-SHA256-8:C-QN08-PSHA1",
      "ja": "OCRA-1：HOTP-SHA256-8：C-QN08-PSHA1"
    },
    {
      "indent": 16,
      "text": "+-----------------+----------+------------+\n|       Key       |     Q    | OCRA Value |\n+-----------------+----------+------------+\n| Standard 32Byte | 00000000 |  83238735  |\n| Standard 32Byte | 11111111 |  01501458  |\n| Standard 32Byte | 22222222 |  17957585  |\n| Standard 32Byte | 33333333 |  86776967  |\n| Standard 32Byte | 44444444 |  86807031  |\n+-----------------+----------+------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "OCRA-1:HOTP-SHA256-8:QN08-PSHA1",
      "ja": "OCRA-1：HOTP-SHA256-8：QN08-PSHA1"
    },
    {
      "indent": 12,
      "text": "+-----------------+-------+----------+------------+\n|       Key       |   C   |     Q    | OCRA Value |\n+-----------------+-------+----------+------------+\n| Standard 64Byte | 00000 | 00000000 |  07016083  |\n| Standard 64Byte | 00001 | 11111111 |  63947962  |\n| Standard 64Byte | 00002 | 22222222 |  70123924  |\n| Standard 64Byte | 00003 | 33333333 |  25341727  |\n| Standard 64Byte | 00004 | 44444444 |  33203315  |\n| Standard 64Byte | 00005 | 55555555 |  34205738  |\n| Standard 64Byte | 00006 | 66666666 |  44343969  |\n| Standard 64Byte | 00007 | 77777777 |  51946085  |\n| Standard 64Byte | 00008 | 88888888 |  20403879  |\n| Standard 64Byte | 00009 | 99999999 |  31409299  |\n+-----------------+-------+----------+------------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "OCRA-1:HOTP-SHA512-8:C-QN08",
      "ja": "OCRA-1：HOTP-SHA512-8：C-QN08"
    },
    {
      "indent": 11,
      "text": "+-----------------+----------+---------+------------+\n|       Key       |     Q    |    T    | OCRA Value |\n+-----------------+----------+---------+------------+\n| Standard 64Byte | 00000000 | 132d0b6 |  95209754  |\n| Standard 64Byte | 11111111 | 132d0b6 |  55907591  |\n| Standard 64Byte | 22222222 | 132d0b6 |  22048402  |\n| Standard 64Byte | 33333333 | 132d0b6 |  24218844  |\n| Standard 64Byte | 44444444 | 132d0b6 |  36209546  |\n+-----------------+----------+---------+------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "OCRA-1:HOTP-SHA512-8:QN08-T1M",
      "ja": "OCRA-1：HOTP-SHA512-8：QN08-T1M"
    },
    {
      "indent": 0,
      "text": "C.2. Mutual Challenge-Response",
      "ja": "C.2。相互チャレンジ - レスポンス"
    },
    {
      "indent": 3,
      "text": "OCRASuite (server computation) = OCRA-1:HOTP-SHA256-8:QA08",
      "ja": "OCRASuite（計算サーバ）OCRA-1 =：HOTP-SHA256-8：QA08"
    },
    {
      "indent": 3,
      "text": "OCRASuite (client computation) = OCRA-1:HOTP-SHA256-8:QA08",
      "ja": "OCRASuite（計算クライアント）OCRA-1 =：HOTP-SHA256-8：QA08"
    },
    {
      "indent": 12,
      "text": "+-----------------+------------------+------------+\n|       Key       |         Q        | OCRA Value |\n+-----------------+------------------+------------+\n| Standard 32Byte | CLI22220SRV11110 |  28247970  |\n| Standard 32Byte | CLI22221SRV11111 |  01984843  |\n| Standard 32Byte | CLI22222SRV11112 |  65387857  |\n| Standard 32Byte | CLI22223SRV11113 |  03351211  |\n| Standard 32Byte | CLI22224SRV11114 |  83412541  |\n+-----------------+------------------+------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Server -- OCRA-1:HOTP-SHA256-8:QA08",
      "ja": "サーバ -  OCRA-1：HOTP-SHA256-8：QA08"
    },
    {
      "indent": 12,
      "text": "+-----------------+------------------+------------+\n|       Key       |         Q        | OCRA Value |\n+-----------------+------------------+------------+\n| Standard 32Byte | SRV11110CLI22220 |  15510767  |\n| Standard 32Byte | SRV11111CLI22221 |  90175646  |\n| Standard 32Byte | SRV11112CLI22222 |  33777207  |\n| Standard 32Byte | SRV11113CLI22223 |  95285278  |\n| Standard 32Byte | SRV11114CLI22224 |  28934924  |\n+-----------------+------------------+------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Client -- OCRA-1:HOTP-SHA256-8:QA08",
      "ja": "クライアント -  OCRA-1：HOTP-SHA256-8：QA08"
    },
    {
      "indent": 3,
      "text": "OCRASuite (server computation) = OCRA-1:HOTP-SHA512-8:QA08",
      "ja": "OCRASuite（計算サーバ）OCRA-1 =：HOTP-SHA512-8：QA08"
    },
    {
      "indent": 3,
      "text": "OCRASuite (client computation) = OCRA-1:HOTP-SHA512-8:QA08-PSHA1",
      "ja": "HOTP-SHA512-8：QA08-PSHA1 OCRASuite（計算クライアント）OCRA-1 ="
    },
    {
      "indent": 12,
      "text": "+-----------------+------------------+------------+\n|       Key       |         Q        | OCRA Value |\n+-----------------+------------------+------------+\n| Standard 64Byte | CLI22220SRV11110 |  79496648  |\n| Standard 64Byte | CLI22221SRV11111 |  76831980  |\n| Standard 64Byte | CLI22222SRV11112 |  12250499  |\n| Standard 64Byte | CLI22223SRV11113 |  90856481  |\n| Standard 64Byte | CLI22224SRV11114 |  12761449  |\n+-----------------+------------------+------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Server -- OCRA-1:HOTP-SHA512-8:QA08",
      "ja": "サーバ -  OCRA-1：HOTP-SHA512-8：QA08"
    },
    {
      "indent": 12,
      "text": "+-----------------+------------------+------------+\n|       Key       |         Q        | OCRA Value |\n+-----------------+------------------+------------+\n| Standard 64Byte | SRV11110CLI22220 |  18806276  |\n| Standard 64Byte | SRV11111CLI22221 |  70020315  |\n| Standard 64Byte | SRV11112CLI22222 |  01600026  |\n| Standard 64Byte | SRV11113CLI22223 |  18951020  |\n| Standard 64Byte | SRV11114CLI22224 |  32528969  |\n+-----------------+------------------+------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Client -- OCRA-1:HOTP-SHA512-8:QA08-PSHA1",
      "ja": "クライアント -  OCRA-1：HOTP-SHA512-8：QA08-PSHA1"
    },
    {
      "indent": 0,
      "text": "C.3. Plain Signature",
      "ja": "C.3。平野署名"
    },
    {
      "indent": 3,
      "text": "In this mode of operation, Q represents the signature challenge.",
      "ja": "この動作モードでは、Qは、署名の挑戦を表します。"
    },
    {
      "indent": 16,
      "text": "+-----------------+----------+------------+\n|       Key       |     Q    | OCRA Value |\n+-----------------+----------+------------+\n| Standard 32Byte | SIG10000 |  53095496  |\n| Standard 32Byte | SIG11000 |  04110475  |\n| Standard 32Byte | SIG12000 |  31331128  |\n| Standard 32Byte | SIG13000 |  76028668  |\n| Standard 32Byte | SIG14000 |  46554205  |\n+-----------------+----------+------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "OCRA-1:HOTP-SHA256-8:QA08",
      "ja": "OCRA-1：HOTP-SHA256-8：QA08"
    },
    {
      "indent": 10,
      "text": "+-----------------+------------+---------+------------+\n|       Key       |      Q     |    T    | OCRA Value |\n+-----------------+------------+---------+------------+\n| Standard 64Byte | SIG1000000 | 132d0b6 |  77537423  |\n| Standard 64Byte | SIG1100000 | 132d0b6 |  31970405  |\n| Standard 64Byte | SIG1200000 | 132d0b6 |  10235557  |\n| Standard 64Byte | SIG1300000 | 132d0b6 |  95213541  |\n| Standard 64Byte | SIG1400000 | 132d0b6 |  65360607  |\n+-----------------+------------+---------+------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "OCRA-1:HOTP-SHA512-8:QA10-T1M",
      "ja": "OCRA-1：HOTP-SHA512-8：QA10-T1M"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "David M'Raihi Verisign, Inc. 487 E. Middlefield Road Mountain View, CA 94043 USA",
      "ja": "デビッドM'Raihiベリサイン社487 E.ミドルロード、マウンテンビュー、CA 94043 USA"
    },
    {
      "indent": 3,
      "text": "EMail: davidietf@gmail.com",
      "ja": "メールアドレス：davidietf@gmail.com"
    },
    {
      "indent": 3,
      "text": "Johan Rydell Portwise, Inc. 275 Hawthorne Ave, Suite 119 Palo Alto, CA 94301 USA",
      "ja": "ヨハン・ライデルPortwise、Inc.の275ホーソーンアベニュー、スイート119パロアルト、CA 94301 USA"
    },
    {
      "indent": 3,
      "text": "EMail: johanietf@gmail.com",
      "ja": "メールアドレス：johanietf@gmail.com"
    },
    {
      "indent": 3,
      "text": "Siddharth Bajaj Symantec Corp. 350 Ellis Street Mountain View, CA 94043 USA",
      "ja": "シッダールタバジャジシマンテック350エリスストリートマウンテンビュー、CA 94043 USA"
    },
    {
      "indent": 3,
      "text": "EMail: siddharthietf@gmail.com",
      "ja": "メールアドレス：siddharthietf@gmail.com"
    },
    {
      "indent": 3,
      "text": "Salah Machani Diversinet Corp. 2225 Sheppard Avenue East, Suite 1801 Toronto, Ontario M2J 5C2 Canada",
      "ja": "サラMachani Diversinet社2225シェパードアベニューイースト、スイート1801トロント、オンタリオM2J 5C2カナダ"
    },
    {
      "indent": 3,
      "text": "EMail: smachani@diversinet.com",
      "ja": "メールアドレス：smachani@diversinet.com"
    },
    {
      "indent": 3,
      "text": "David Naccache Ecole Normale Superieure ENS DI, 45 rue d'Ulm Paris, 75005 France",
      "ja": "デイビット・ナキャッシュ高等師範学校DI ENS、45 RUE D'ウルムパリ、75005フランス"
    },
    {
      "indent": 3,
      "text": "EMail: david.naccache@ens.fr",
      "ja": "メールアドレス：david.naccache@ens.fr"
    }
  ]
}