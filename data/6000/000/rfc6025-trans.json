{
  "title": {
    "text": "RFC 6025 - ASN.1 Translation",
    "ja": "RFC 6025 - ASN.1の翻訳"
  },
  "number": 6025,
  "created_at": "2019-10-27 03:14:06.787907+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        C. Wallace\nRequest for Comments: 6025                            Cygnacom Solutions\nCategory: Informational                                      C. Gardiner\nISSN: 2070-1721                                         BBN Technologies\n                                                            October 2010",
      "raw": true
    },
    {
      "indent": 27,
      "text": "ASN.1 Translation",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Abstract Syntax Notation One (ASN.1) is widely used throughout the IETF Security Area and has been for many years. Some specifications were written using a now deprecated version of ASN.1 and some were written using the current version of ASN.1. Not all ASN.1 compilers support both older and current syntax. This document is intended to provide guidance to specification authors and to implementers converting ASN.1 modules from one version of ASN.1 to another version without causing changes to the \"bits on the wire\". This document does not provide a comprehensive tutorial of any version of ASN.1. Instead, it addresses ASN.1 features that are used in IETF Security Area specifications with a focus on items that vary with the ASN.1 version.",
      "ja": "抽象構文記法1（ASN.1）が広くIETFセキュリティエリア全体で使用されており、長年にわたってされています。いくつかの仕様は、ASN.1の廃止バージョンを使用して書かれていたし、いくつかは、ASN.1の現在のバージョンを使用して書かれていました。すべてではないASN.1コンパイラは古く、現在の構文の両方をサポートしています。この文書は、本明細書の著者および「ワイヤ上のビット」に変化を引き起こすことなく、別のバージョンにASN.1のバージョンからASN.1モジュール変換実装にガイダンスを提供することを意図しています。このドキュメントは、ASN.1のいずれかのバージョンの総合的なチュートリアルを提供していません。その代わりに、ASN.1のバージョンによって変わるアイテムを中心としたIETFセキュリティエリアの仕様で使用されているASN.1の機能に対応しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6025.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6025で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2010 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n  1.1.  Terminology  . . . . . . . . . . . . . . . . . . . . . . .  3\n2.  ASN.1 Design Elements  . . . . . . . . . . . . . . . . . . . .  3\n  2.1.  Open Types . . . . . . . . . . . . . . . . . . . . . . . .  3\n    2.1.1.  ANY DEFINED BY . . . . . . . . . . . . . . . . . . . .  4\n    2.1.2.  OCTET STRINGs and BIT STRINGs  . . . . . . . . . . . .  5\n    2.1.3.  Information Object Classes . . . . . . . . . . . . . .  5\n  2.2.  Constraints  . . . . . . . . . . . . . . . . . . . . . . .  8\n    2.2.1.  Simple Table Constraints . . . . . . . . . . . . . . .  8\n    2.2.2.  Component Relation Constraints . . . . . . . . . . . .  9\n    2.2.3.  Content Constraints  . . . . . . . . . . . . . . . . . 11\n  2.3.  Parameterization . . . . . . . . . . . . . . . . . . . . . 12\n  2.4.  Versioning and Extensibility . . . . . . . . . . . . . . . 13\n    2.4.1.  Extension Markers  . . . . . . . . . . . . . . . . . . 14\n    2.4.2.  Version Brackets . . . . . . . . . . . . . . . . . . . 14\n3.  Character Set Differences  . . . . . . . . . . . . . . . . . . 15\n4.  ASN.1 Translation  . . . . . . . . . . . . . . . . . . . . . . 16\n  4.1.  Downgrading from X.68x to X.208  . . . . . . . . . . . . . 16\n  4.2.  Upgrading from X.208 to X.68x  . . . . . . . . . . . . . . 16\n5.  Security Considerations  . . . . . . . . . . . . . . . . . . . 17\n6.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n  6.1.  Normative References . . . . . . . . . . . . . . . . . . . 18\n  6.2.  Informative References . . . . . . . . . . . . . . . . . . 18",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document is intended to serve as a tutorial for converting ASN.1 modules written using [CCITT.X208.1988] to [CCITT.X680.2002], or vice versa. Preparation of this document was motivated by [RFC5911] and [RFC5912], which provide updated ASN.1 modules for a number of RFCs.",
      "ja": "この文書は、[CCITT.X208.1988] [CCITT.X680.2002]に、またはその逆を使用して書かれたASN.1モジュールを変換するためのチュートリアルとして役立つことを意図しています。この文書の調製は、RFCの数に更新ASN.1モジュールを提供する[RFC5911]及び[RFC5912]、によって動機付けました。"
    },
    {
      "indent": 3,
      "text": "The intent of this specification is to assist with translation of ASN.1 from one version to another without resulting in any changes to the encoded results when using the Basic Encoding Rules or Distinguished Encoding Rules [CCITT.X209.1988] [CCITT.X690.2002]. Other encoding rules were not considered.",
      "ja": "本明細書の目的は、基本符号化規則または識別符号化規則[CCITT.X209.1988] [CCITT.X690を使用する場合に符号化された結果に変更を生じることなく、1つのバージョンから別のASN.1の翻訳を支援することです。 2002]。他の符号化規則は考慮されませんでした。"
    },
    {
      "indent": 3,
      "text": "Transforming a new ASN.1 module to an older ASN.1 module can be performed in a fairly mechanical manner; much of the transformation consists of deleting new constructs. Transforming an older ASN.1 module to a newer ASN.1 module can also be done fairly mechanically, if one does not wish to move many of the constraints that are contained in the prose into the ASN.1 module. If the constraints are to be added, then the conversion can be a complex process.",
      "ja": "古いASN.1モジュールに新しいASN.1モジュールを変換することは、かなり機械的な方法で実行することができます。変換の多くは新しい構造を削除するので構成されています。 1は、ASN.1モジュールに散文に含まれている制約の多くを移動したくない場合は、新しいASN.1モジュールに古いASN.1モジュールを変換することも、かなり機械的に行うことができます。制約が追加される場合、変換は複雑なプロセスであることができます。"
    },
    {
      "indent": 0,
      "text": "1.1. Terminology",
      "section_title": true,
      "ja": "1.1。用語"
    },
    {
      "indent": 3,
      "text": "This document addresses two different versions of ASN.1. The old (1988) version was defined in a single document (X.208) and the newer (1998, 2002) version is defined in a series of documents (X.680, X.681, X.682, and X.683). For convenience, the series of documents is henceforth referred to as X.68x. Specific documents from the series are referenced by name where appropriate.",
      "ja": "この文書では、ASN.1の2つの異なるバージョンに対応しています。古い（1988）バージョン単一の文書（X.208）で定義された以降（1998、2002）バージョンは、一連の文書（X.680、X.681、X.682、およびX.683に定義されています）。便宜上、一連の文書は、今後X.68xと呼ばれています。シリーズからの特定の文書が適切な場合には名前で参照されています。"
    },
    {
      "indent": 0,
      "text": "2. ASN.1 Design Elements",
      "section_title": true,
      "ja": "2. ASN.1設計要素"
    },
    {
      "indent": 3,
      "text": "When translating an ASN.1 module from X.208 syntax to X.68x syntax, or vice versa, many definitions do not require or benefit from change. Review of the original ASN.1 modules updated by [RFC5911] and [RFC5912] and the revised modules included in those documents indicates that most changes can be sorted into one of a few categories. This section describes these categories.",
      "ja": "X.68x構文、またはその逆へのX.208構文からASN.1モジュールを翻訳すると、多くの定義が必要とするか、または変更の恩恵を受けません。 [RFC5911]と[RFC5912]およびそれらの文書に含ま改訂モジュールによって更新され、元のASN.1モジュールの見直しはほとんど変化が少数のいずれかのカテゴリに分類できることを示します。このセクションでは、これらのカテゴリを記述する。"
    },
    {
      "indent": 0,
      "text": "2.1. Open Types",
      "section_title": true,
      "ja": "2.1。オープンタイプ"
    },
    {
      "indent": 3,
      "text": "Protocols often feature flexible designs that enable other (later) specifications to define the syntax and semantics of some features. For example, [RFC5280] includes the definition of the Extension structure. There are many instances of extensions defined in other specifications. Several mechanisms to accommodate this practice are available in X.208, X.68x, or both, as described below.",
      "ja": "プロトコルは、多くの場合、一部の機能の構文とセマンティクスを定義するための他の（後）の仕様を可能にする柔軟なデザインを備えています。例えば、[RFC5280]は拡張構造の定義を含んでいます。他の仕様で定義された拡張の多くのインスタンスがあります。後述のようにこのような行為に対応するためにいくつかのメカニズムは、X.208、X.68x、またはその両方で利用可能です。"
    },
    {
      "indent": 0,
      "text": "2.1.1. ANY DEFINED BY",
      "section_title": true,
      "ja": "2.1.1。によって定義されました"
    },
    {
      "indent": 3,
      "text": "X.208 defines the ANY DEFINED BY production for specifying open types. This typically appears in a SEQUENCE along with an OBJECT IDENTIFIER that indicates the type of object that is encoded. The ContentInfo structure, shown below from [RFC5652], uses ANY DEFINED BY along with an OBJECT IDENTIFIER field to identify and convey arbitrary types of data. Each content type to be wrapped in a ContentInfo is assigned a unique OBJECT IDENTIFIER, such as the id-signedData shown below. However, X.208 does not provide a formal means for establishing a relationship between a type and the type identifier. Any associations are done in the comments of the module and/or the text of the associated document.",
      "ja": "X.208は、オープンタイプを指定するための生産によって定義されたが定義されています。これは、典型的には、符号化されるオブジェクトのタイプを示すオブジェクト識別子と共にシーケンスで現れます。 [RFC5652]から、以下に示すContentInfo構造は、データの任意のタイプを識別し、伝達するために沿って物体識別子フィールドとによって定義される任意のものを使用します。 ContentInfoに包まれるべき各コンテンツタイプは、以下に示すようなID-たsignedDataとして一意のオブジェクト識別子を割り当てられます。ただし、X.208タイプとタイプ識別子との間の関係を確立するための正式な手段を提供していません。任意の関連付けは、モジュールおよび/または関連する文書のテキストのコメントで行われます。"
    },
    {
      "indent": 3,
      "text": "-- from RFC 5652\nContentInfo ::= SEQUENCE {\n    contentType ContentType,\n    content [0] EXPLICIT ANY DEFINED BY contentType }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ContentType ::= OBJECT IDENTIFIER",
      "raw": true
    },
    {
      "indent": 3,
      "text": "id-signedData OBJECT IDENTIFIER ::= { iso(1) member-body(2)\n   us(840) rsadsi(113549) pkcs(1) pkcs7(7) 2 }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ANY DEFINED BY may also appear using an INTEGER to indicate the type of object that is encoded, as shown in the following example from [RFC5280].",
      "ja": "定義されたいずれも[RFC5280]から、次の例に示すように、符号化されるオブジェクトのタイプを示す整数を使用して表示されることがあります。"
    },
    {
      "indent": 3,
      "text": "-- from RFC 5280\nExtensionAttribute ::=  SEQUENCE {\n    extension-attribute-type [0] IMPLICIT INTEGER\n        (0..ub-extension-attributes),\n    extension-attribute-value [1]\n        ANY DEFINED BY extension-attribute-type }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Though the usage of ANY DEFINED BY was deprecated in 1994, it appears in some active specifications. The AttributeValue definition in [RFC5280] uses ANY with a DEFINED BY comment to bind the value to a type identifier field.",
      "ja": "ANY DEFINED BYの使用は1994年に廃止されましたが、それはいくつかのアクティブな仕様に表示されます。 [RFC5280]でAttributeValueの定義は、タイプ識別子フィールドに値をバインドするコメントによって定義されると任意のものを使用します。"
    },
    {
      "indent": 3,
      "text": "-- from RFC 5280\nAttributeTypeAndValue ::= SEQUENCE {\n    type     AttributeType,\n    value    AttributeValue }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "AttributeType ::= OBJECT IDENTIFIER",
      "raw": true
    },
    {
      "indent": 3,
      "text": "AttributeValue ::= ANY -- DEFINED BY AttributeType",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.1.2. OCTET STRINGs and BIT STRINGs",
      "section_title": true,
      "ja": "2.1.2。オクテット文字列とビット列"
    },
    {
      "indent": 3,
      "text": "Both X.208 and X.68x allow open types to be implemented using OCTET STRINGs and BIT STRINGs as containers. The definitions of Extension and SubjectPublicKeyInfo in [RFC5280] demonstrate the usage of OCTET STRING and BIT STRING, respectively, to convey information that is further defined using ASN.1.",
      "ja": "X.208とX.68x両方がオープンタイプのコンテナとしてオクテット文字列とビット列を使用して実装されることを可能にします。 [RFC5280]での拡張とSubjectPublicKeyInfoでの定義はさらにASN.1を使用して定義された情報を伝達するために、それぞれ、オクテット文字列とビット列の使用を実証します。"
    },
    {
      "indent": 3,
      "text": "-- from RFC 5280\nExtension  ::=  SEQUENCE  {\n    extnID      OBJECT IDENTIFIER,\n    critical    BOOLEAN DEFAULT FALSE,\n    extnValue   OCTET STRING\n    -- contains the DER encoding of an ASN.1 value\n    -- corresponding to the extension type identified\n    -- by extnID\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SubjectPublicKeyInfo  ::=  SEQUENCE  {\n     algorithm            AlgorithmIdentifier,\n     subjectPublicKey     BIT STRING  }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In both cases, the prose of the specification describes that the adjacent OBJECT IDENTIFIER value indicates the type of structure within the value of the primitive OCTET STRING or BIT STRING type. For example, where an extnID field contains the value id-ce-basicConstraints, the extnValue field contains an encoded BasicConstraints as the value of the OCTET STRING, as shown in the dump of an encoded extension below.",
      "ja": "いずれの場合においても、仕様の散文は、隣接するオブジェクト識別子の値がプリミティブオクテットストリングまたはビット列タイプの値内の構造のタイプを示すことが記載されています。 extnIDフィールドが値ID-CE-basicConstraintsのを含む場合、以下に符号化された拡張のダンプに示すように、例えば、extnValueフィールドは、オクテット文字列の値としてエンコード基本制約を含んでいます。"
    },
    {
      "indent": 3,
      "text": "Tag Length Value 30 15: SEQUENCE { 06 3: OBJECT IDENTIFIER basicConstraints (2 5 29 19) 01 1: BOOLEAN TRUE 04 5: OCTET STRING, encapsulates { 30 3: SEQUENCE { 01 1: BOOLEAN TRUE : } : } : }",
      "ja": "タグ長さ値30 15：SEQUENCE {06 3：オブジェクト識別子basicConstraintsの（2 5 29 19）01 1：BOOLEAN TRUE 04 5：OCTET STRINGをカプセル化{30：3 SEQUENCE {01 1：TRUE BOOLEAN：}}}"
    },
    {
      "indent": 0,
      "text": "2.1.3. Information Object Classes",
      "section_title": true,
      "ja": "2.1.3。情報オブジェクトクラス"
    },
    {
      "indent": 3,
      "text": "Information object classes are defined in [CCITT.X681.2002]. Object classes allow protocol designers to relate pieces of data that are in some way associated. In the most generic of terms, an Information Object class can be thought of as a database schema, with Information Object Sets being instances of the databases.",
      "ja": "情報オブジェクトクラスは[CCITT.X681.2002]で定義されています。オブジェクトクラスは、プロトコル設計者は関連するいくつかの方法であり、データの部分を関連付けることを可能にします。用語の最も一般的なでは、情報オブジェクトクラスは、情報オブジェクトセットは、データベースのインスタンスであることで、データベーススキーマと考えることができます。"
    },
    {
      "indent": 3,
      "text": "Unlike type definitions, object classes with the same structure are not equivalent. Thus, if you have:",
      "ja": "型定義とは異なり、同じ構造を持つオブジェクトクラスが同じではありません。このように、あなたが持っている場合："
    },
    {
      "indent": 6,
      "text": "FOO ::= TYPE-IDENTIFIER",
      "raw": true
    },
    {
      "indent": 6,
      "text": "BAR ::= TYPE-IDENTIFIER",
      "raw": true
    },
    {
      "indent": 3,
      "text": "FOO and BAR are not interchangeable.",
      "ja": "FOOとBARは互換性がありません。"
    },
    {
      "indent": 3,
      "text": "TYPE-IDENTIFIER is one of the predefined information object classes in Annex A of [CCITT.X681.2002]. This provides for a simple mapping from an OBJECT IDENTIFIER to a data type. The tag UNIQUE on &id means that this value may appear only once in an Information Object Set; however, multiple objects can be defined with the same &id value.",
      "ja": "TYPE識別子は、[CCITT.X681.2002]の附属書Aで定義済みの情報オブジェクトクラスの一つです。これは、データ型にオブジェクト識別子からの単純なマッピングのために用意されています。上のUNIQUE＆IDタグは、この値は情報オブジェクトセットに一度だけ表示される場合がありますことを意味します。しかし、複数のオブジェクトが同じ＆ID値で定義することができます。"
    },
    {
      "indent": 3,
      "text": "[RFC5911] uses the TYPE-IDENTIFIER construction to update the definition of ContentInfo, as shown below.",
      "ja": "以下に示すように[RFC5911]は、ContentInfoの定義を更新するために、TYPE-識別子構造を使用します。"
    },
    {
      "indent": 3,
      "text": "-- TYPE-IDENTIFIER definition from X.681\nTYPE-IDENTIFIER ::= CLASS\n{\n    &id OBJECT IDENTIFIER UNIQUE,\n    &Type\n}\nWITH SYNTAX {&Type IDENTIFIED BY &id}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- from updated RFC 5652 module in [RFC5911]\nCONTENT-TYPE ::= TYPE-IDENTIFIER\nContentType ::= CONTENT-TYPE.&id",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ContentInfo ::= SEQUENCE {\n    contentType        CONTENT-TYPE.\n                    &id({ContentSet}),\n    content            [0] EXPLICIT CONTENT-TYPE.\n                    &Type({ContentSet}{@contentType})}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ContentSet CONTENT-TYPE ::= {\n    --  Define the set of content types to be recognized.\n    ct-Data | ct-SignedData | ct-EncryptedData | ct-EnvelopedData |\n    ct-AuthenticatedData | ct-DigestedData, ... }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- other CONTENT-TYPE instances not shown for brevity\nct-SignedData CONTENT-TYPE ::=\n     { SignedData IDENTIFIED BY id-signedData}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This example illustrates the following:",
      "ja": "この例では、次を示しています。"
    },
    {
      "indent": 3,
      "text": "o Definition of an information object class: TYPE-IDENTIFIER and CONTENT-TYPE are information object classes.",
      "ja": "情報オブジェクトクラスのO定義：TYPE-IDENTIFIERとCONTENT-TYPEは、情報オブジェクトクラスです。"
    },
    {
      "indent": 3,
      "text": "o Definition of an information object, or an instance of an information object class: ct-SignedData is an information object.",
      "ja": "O情報オブジェクトの定義、または情報オブジェクトクラスのインスタンス：CT-のSignedDataは、情報オブジェクトです。"
    },
    {
      "indent": 3,
      "text": "o Definition of an information object set: ContentSet is an information object set.",
      "ja": "情報オブジェクトセットのO定義：ContentSetは、情報オブジェクトのセットです。"
    },
    {
      "indent": 3,
      "text": "o Usage of an information object: The definition of ContentInfo uses information from the CONTENT-TYPE information object class.",
      "ja": "O情報オブジェクトの使用法：ContentInfoの定義は、コンテンツ・タイプ情報オブジェクトクラスからの情報を使用します。"
    },
    {
      "indent": 3,
      "text": "o Defining constraints using an object set: Both the contentType and content fields are constrained by ContentSet.",
      "ja": "contentType及びコンテンツフィールドの両方がContentSetによって制約されている：Oオブジェクトセットを使用して制約を定義します。"
    },
    {
      "indent": 3,
      "text": "As noted above, TYPE-IDENTIFIER simply associates an OBJECT IDENTIFIER with an arbitrary data type. CONTENT-TYPE is a TYPE-IDENTIFIER. The WITH SYNTAX component allows for a more natural language expression of information object definitions.",
      "ja": "上述したように、TYPE識別子は、単に任意のデータ型を持つオブジェクト識別子を関連付けます。 CONTENT-TYPEは、TYPE-識別子です。 WITH SYNTAXコンポーネントは、情報オブジェクト定義のより自然言語表現を可能にします。"
    },
    {
      "indent": 3,
      "text": "ct-SignedData is the name of an information object that associated the identifier id-signedData with the data type SignedData. It is an instance of the CONTENT-TYPE information object class. The &Type field is assigned the value SignedData, and the &id field is assigned the value id-signedData. The example above uses the syntax provided by the WITH SYNTAX component of the TYPE-IDENTIFIER definition. An equivalent definition that does not use the provided syntax is as follows:",
      "ja": "CT-のSignedDataは、データタイプのSignedDataと識別子ID-たsignedData関連情報オブジェクトの名前です。それはCONTENT-TYPE情報オブジェクトクラスのインスタンスです。 ＆Typeフィールドは、値のSignedDataを割り当てられ、＆IDフィールドが値ID-たsignedDataが割り当てられます。上記の例では、TYPE-識別子定義のWITH構文要素によって提供される構文を使用します。次のように提供する構文を使用していない同等の定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "ct-SignedData CONTENT-TYPE ::=\n{\n    &id id-signedData,\n    &Type SignedData\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ContentSet is the name of a set of information objects derived from the CONTENT-TYPE information object class. The set contains six information objects and is extensible, as indicated by the ellipsis (see Section 2.4, \"Versioning and Extensibility\").",
      "ja": "ContentSetは、コンテンツ・タイプ情報オブジェクトクラスから派生した情報オブジェクトのセットの名前です。セットは、6つの情報オブジェクトが含まれており、拡張可能であり、省略記号によって示されるように（セクション2.4、「バージョンと拡張」を参照）。"
    },
    {
      "indent": 3,
      "text": "ContentInfo is defined using type information from an information object, i.e., the type of the contentType field is that of the &id field from CONTENT-TYPE. An equivalent definition is as follows:",
      "ja": "ContentInfoは即ち、contentTypeのフィールドのタイプはコンテンツタイプから＆IDフィールドのものであり、情報オブジェクトからタイプ情報を使用して定義されます。次のように同等の定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "ContentType ::= OBJECT IDENTIFIER",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Both fields in ContentInfo are constrained. The contentType field is constrained using a simple table constraint that restricts the values to those from the corresponding field of the objects in ContentSet. The content field is constrained using a component relationship constraint. Constraints are discussed in the next section.",
      "ja": "ContentInfoの両方のフィールドが拘束されています。 contentTypeのフィールドはContentSetにおけるオブジェクトの対応するフィールドからのものに値を制限する簡単なテーブル制約を用いて制約されます。コンテンツフィールドは、コンポーネントの関係の制約を用いて制約されます。制約は、次のセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "2.2. Constraints",
      "section_title": true,
      "ja": "2.2。制約"
    },
    {
      "indent": 3,
      "text": "The X.68x versions of the ASN.1 specifications introduced the ability to use the object information sets as part of the constraint on the values that a field can take. Simple table constraints are used to restrict the set of values that can occur in a field. Component relation constraints allow for the restriction of a field based on contents of other fields in the type.",
      "ja": "ASN.1仕様のX.68xバージョンは、フィールドが取り得る値の制約の一部としてオブジェクト情報セットを使用する能力を導入します。シンプルなテーブル制約は、フィールドで発生する可能性があります値のセットを制限するために使用されています。コンポーネント関係制約は、型内の他のフィールドの内容に基づいてフィールドの制限を可能にします。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Simple Table Constraints",
      "section_title": true,
      "ja": "2.2.1。シンプルなテーブル制約"
    },
    {
      "indent": 3,
      "text": "Simple table constraints are widely used in [RFC5911] and [RFC5912] to limit implementer options (although the constraints are almost always followed by or include extensibility markers, which make the parameters serve as information not as limitations). Table constraints are defined in [CCITT.X682.2002].",
      "ja": "単純なテーブル制約は広く（制約はほとんど常に続い又はパラメータが情報としてない制限として機能する拡張マーカーを含むされているが）実装オプションを制限するために[RFC5911]及び[RFC5912]に使用されています。テーブル制約は[CCITT.X682.2002]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Some ASN.1 compilers have the ability to use the simple table constraint to check that a field contains one of the legal values.",
      "ja": "いくつかのASN.1コンパイラは、フィールドが正当な値の1が含まれていることを確認するために、簡単なテーブル制約を使用する能力を持っています。"
    },
    {
      "indent": 3,
      "text": "The following example from [RFC5911] demonstrates using table constraints to clarify the intended usage of a particular field. The parameters indicate the types of attributes that are typically found in the signedAttrs and unsignedAttrs fields. In this example, the object sets are disjoint but this is not required. For example, in [RFC5912], there is some overlap between the CertExtensions and CrlExtensions sets.",
      "ja": "次の例は[RFC5911]特定のフィールドの使用目的を明確にするために、テーブル制約を使用して実証します。パラメータは、一般的にsignedAttrsとunsignedAttrs分野で発見された属性の種類を示しています。この例では、オブジェクトセットは互いに素であるが、これは必須ではありません。例えば、[RFC5912]に、CertExtensionsとCrlExtensionsセット間のいくらかの重複があります。"
    },
    {
      "indent": 3,
      "text": "-- from updated RFC 5652 module in [RFC5911]\nSignerInfo ::= SEQUENCE {\n    version CMSVersion,\n    sid SignerIdentifier,\n    digestAlgorithm DigestAlgorithmIdentifier,\n    signedAttrs [0] IMPLICIT SignedAttributes OPTIONAL,\n    signatureAlgorithm SignatureAlgorithmIdentifier,\n    signature SignatureValue,\n    unsignedAttrs [1] IMPLICIT Attributes\n         {{UnsignedAttributes}} OPTIONAL }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SignedAttributes ::= Attributes {{ SignedAttributesSet }}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SignedAttributesSet ATTRIBUTE ::=\n       { aa-signingTime | aa-messageDigest | aa-contentType, ... }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "UnsignedAttributes ATTRIBUTE ::= { aa-countersignature, ... }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.2.2. Component Relation Constraints",
      "section_title": true,
      "ja": "2.2.2。コンポーネントの関係の制約"
    },
    {
      "indent": 3,
      "text": "Component relation constraints are often used to bind the type field of an open type to the identifier field. Using the binding in this way allows a compiler to immediately decode the associated type when the containing structure is defined. The following example from [RFC2560] as updated in [RFC5912] demonstrates this usage.",
      "ja": "コンポーネントの関係の制約は、多くの場合、識別子フィールドに開放型のタイプフィールドをバインドするために使用されています。このようにバインディングを使用することを含む構造が定義されている場合、コンパイラは直ちに関連するタイプをデコードすることを可能にします。 [RFC5912]に更新される[RFC2560]から次の例では、この使用方法を示しています。"
    },
    {
      "indent": 3,
      "text": "-- from updated RFC 2560 module in [RFC5912]\nRESPONSE ::= TYPE-IDENTIFIER",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ResponseSet RESPONSE ::= {basicResponse, ...}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "ResponseBytes ::=       SEQUENCE {\n    responseType        RESPONSE.\n                            &id ({ResponseSet}),\n    response            OCTET STRING (CONTAINING RESPONSE.\n                            &Type({ResponseSet}{@responseType}))}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In this example, the response field is constrained to contain a type identified by the responseType field. The controlling field is identified using atNotation, e.g., \"@responseType\". atNotation can be defined relative to the outermost SEQUENCE, SET, or CHOICE or relative to the field with which the atNotation is associated. When there is no '.' immediately after the '@', the field appears as a member of the outermost SEQUENCE, SET, or CHOICE. When there is a '.' immediately after the '@', each '.' represents a SEQUENCE, SET, or CHOICE starting with the SEQUENCE, SET, or CHOICE that contains the field with which the atNotation is associated. For example, ResponseBytes could have been written as shown below. In this case, the syntax is very similar since the innermost and outermost SEQUENCE, SET, or CHOICE are the same.",
      "ja": "この例では、応答フィールドはresponseTypeフィールドによって識別されたタイプを含むように制約されます。制御フィールドはatNotation、例えば、「@responseType」を用いて識別されます。 atNotationは、最も外側SEQUENCE、SET、またはCHOICEまたはatNotationが関連付けられているフィールドに対してに対して定義することができます。何も存在しない場合は「」すぐに「@」の後に、フィールドは、最も外側のSEQUENCE、SET、またはCHOICEのメンバーとして表示されます。ときにそこにあります「」すぐに、それぞれの「@」の後に「」 atNotationが関連付けられているフィールドを含むシーケンス、SET、またはCHOICE始まるSEQUENCE、SET、またはCHOICEを表します。例えば、ResponseBytesは、以下のように書かれている可能性があります。最内外SEQUENCE、SET、またはCHOICEが同じであるので、この場合、構文は非常に類似しています。"
    },
    {
      "indent": 3,
      "text": "ResponseBytes ::=       SEQUENCE {\n    responseType        RESPONSE.\n                            &id ({ResponseSet}),\n    response            OCTET STRING (CONTAINING RESPONSE.\n                            &Type({ResponseSet}{@.responseType}))}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The TaggedRequest example from [RFC5912] provides an example where the outermost and innermost SEQUENCE, SET, or CHOICE are different. Relative to the atNotation included in the definition of the requestMessageValue field, the outermost SEQUENCE, SET, or CHOICE is TaggedRequest, and the innermost is the SEQUENCE used to define the orm field.",
      "ja": "[RFC5912]からTaggedRequest例では、最も外側及び最も内側のSEQUENCE、SET、またはCHOICEが異なる例を提供します。 atNotationに対してはrequestMessageValueフィールドの定義に含まれ、最も外側のSEQUENCE、SET、またはCHOICEはTaggedRequestであり、そして最も内側のORMフィールドを定義するために使用される配列です。"
    },
    {
      "indent": 3,
      "text": "TaggedRequest ::= CHOICE {\n   tcr               [0] TaggedCertificationRequest,\n   crm               [1] CertReqMsg,\n   orm               [2] SEQUENCE {\n       bodyPartID            BodyPartID,\n       requestMessageType    OTHER-REQUEST.&id({OtherRequests}),\n       requestMessageValue   OTHER-REQUEST.&Type({OtherRequests}\n                                 {@.requestMessageType})\n   }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "When referencing a field using atNotation, the definition of the field must be included within the outermost SEQUENCE, SET, or CHOICE. References to fields within structures that are defined separately are not allowed. For example, the following example includes invalid atNotation in the definition of the signature field within the SIGNED parameterized type.",
      "ja": "atNotationを使用してフィールドを参照する場合、フィールドの定義は、最も外側のSEQUENCE、SET、またはCHOICE内に含まれなければなりません。個別に定義されている構造内のフィールドへの参照は許可されていません。例えば、次の例では、署名されたパラメータ化された型内の署名フィールドの定義で無効atNotationを含みます。"
    },
    {
      "indent": 3,
      "text": "AlgorithmIdentifier{ALGORITHM-TYPE, ALGORITHM-TYPE:AlgorithmSet} ::=\n          SEQUENCE {\n              algorithm   ALGORITHM-TYPE.&id({AlgorithmSet}),\n              parameters  ALGORITHM-TYPE.\n                     &Params({AlgorithmSet}{@algorithm}) OPTIONAL\n          }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- example containing invalid atNotation\nSIGNED{ToBeSigned} ::= SEQUENCE {\n   toBeSigned           ToBeSigned,\n   algorithmIdentifier  AlgorithmIdentifier\n                            { SIGNATURE-ALGORITHM, {...}}\n   },\n   signature BIT STRING (CONTAINING SIGNATURE-ALGORITHM.&Value(\n                            {SignatureAlgorithms}\n                            {@algorithmIdentifier.algorithm}))\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Alternatively, the above example could be written with correct atNotation as follows, with the definition of the algorithm field included within ToBeSigned.",
      "ja": "次のように別の方法として、上記の例ではToBeSigned内に含まれるアルゴリズムフィールドの定義と、正しいatNotationで記述することができます。"
    },
    {
      "indent": 5,
      "text": "SIGNED{ToBeSigned} ::= SEQUENCE {\n   toBeSigned           ToBeSigned,\n   algorithmIdentifier  SEQUENCE {\n       algorithm        SIGNATURE-ALGORITHM.\n                            &id({SignatureAlgorithms}),\n       parameters       SIGNATURE-ALGORITHM.\n                            &Params({SignatureAlgorithms}\n                                {@algorithmIdentifier.algorithm})\n   },\n   signature BIT STRING (CONTAINING SIGNATURE-ALGORITHM.&Value(\n                            {SignatureAlgorithms}\n                            {@algorithmIdentifier.algorithm}))\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the above example, the outermost SEQUENCE, SET, or CHOICE relative to the parameters field is the SIGNED parameterized type. The innermost structure is the SEQUENCE used as the type for the algorithmIdentifier field. The atNotation for the parameters field could be expressed using any of the following representations:",
      "ja": "上記の例では、パラメータフィールドに最も外側のSEQUENCE、SET、またはCHOICEに対しては、署名されたパラメータ化された型です。最も内側の構造は、のAlgorithmIdentifierフィールドのタイプとして使用される配列です。パラメータフィールドのatNotationは、以下の表現のいずれかを使用して表現することができます。"
    },
    {
      "indent": 6,
      "text": "@algorithmIdentifier.algorithm",
      "ja": "@ algorithmIdentifier.algorithm"
    },
    {
      "indent": 6,
      "text": "@.algorithm",
      "ja": "@。アルゴリズム"
    },
    {
      "indent": 3,
      "text": "The atNotation for the signature field has only one representation.",
      "ja": "署名フィールドのためのatNotationは1つの表現を持っています。"
    },
    {
      "indent": 0,
      "text": "2.2.3. Content Constraints",
      "section_title": true,
      "ja": "2.2.3。コンテンツ制約"
    },
    {
      "indent": 3,
      "text": "Open types implemented as OCTET STRINGs or BIT STRINGs can be constrained using the contents constraints syntax defined in [CCITT.X682.2002]. Below are the revised definitions from [RFC5911] and [RFC5912]. These show usage of OCTET STRING and BIT STRING along with constrained sets of identifiers. The Extension definition uses a content constraint that requires the value of the OCTET STRING to be an encoding of the type associated with the information object selected from the ExtensionSet object set using the value of the extnID field. For reasons described in Section 2.2.2, \"Component Relation Constraints\", the SubjectPublicKeyInfo definition relies on prose to bind the BIT STRING to the type identifier because it is not possible to express a content constraint that includes a component relationship constraint to bind the type value within the algorithm field to the subjectPublicKey field.",
      "ja": "オクテットストリングまたはビット列として実装オープン型は、[CCITT.X682.2002]で定義されたコンテンツの制約構文を使用して制約することができます。以下は、[RFC5911]と[RFC5912]からの改訂の定義があります。これらは、識別子の制約のセットと一緒にオクテット文字列とビット列の使用方法を示しています。拡張定義はextnIDフィールドの値を使用してExtensionSetオブジェクトセットから選択された情報オブジェクトに関連付けられているタイプの符号化であることがオクテット文字列の値を必要とするコンテンツ制約を用います。 2.2.2項で説明する理由のために、「コンポーネント関係の制約」、SubjectPublicKeyInfoで定義は、型に結合する成分の関係制約を含むコンテンツの制約を表現することは不可能であるため、タイプ識別子のビット列を結合するために散文に依存していますsubjectPublicKeyフィールドにアルゴリズムフィールド内の値。"
    },
    {
      "indent": 3,
      "text": "-- from updated RFC 5280 module in [RFC5912]\nExtension{EXTENSION:ExtensionSet} ::= SEQUENCE {\n    extnID      EXTENSION.&id({ExtensionSet}),\n    critical    BOOLEAN\n    -- (EXTENSION.&Critical({ExtensionSet}{@extnID}))\n                       DEFAULT FALSE,\n    extnValue   OCTET STRING (CONTAINING\n                  EXTENSION.&ExtnType({ExtensionSet}{@extnID}))\n                  --  contains the DER encoding of the ASN.1 value\n                  --  corresponding to the extension type identified\n                  --  by extnID\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SubjectPublicKeyInfo  ::=  SEQUENCE  {\n    algorithm            AlgorithmIdentifier{PUBLIC-KEY,\n                             {PublicKeyAlgorithms}},\n    subjectPublicKey     BIT STRING\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.3. Parameterization",
      "section_title": true,
      "ja": "2.3。パラメータ化"
    },
    {
      "indent": 3,
      "text": "Parameterization is defined in [CCITT.X683.2002] and can also be used to define new types in a way similar to the macro notation described in Annex A of X.208. The following example from [RFC5912] shows this usage. The toBeSigned field takes the type passed as a parameter.",
      "ja": "パラメータは[CCITT.X683.2002]で定義されており、また、X.208の附属書Aに記載のマクロ表記と同様に、新しいタイプを定義するために使用することができます。 [RFC5912]から次の例は、この使用方法を示しています。 toBeSignedフィールドがパラメータとして渡された型を取ります。"
    },
    {
      "indent": 3,
      "text": "-- from [RFC5912]\nSIGNED{ToBeSigned} ::= SEQUENCE {\n    toBeSigned  ToBeSigned,\n    algorithm   AlgorithmIdentifier{SIGNATURE-ALGORITHM,\n                    {SignatureAlgorithms}},\n    signature   BIT STRING\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- from updated RFC5280 module in [RFC5912]\nCertificate  ::=  SIGNED{TBSCertificate}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Parameters need not be simple types. The following example demonstrates the usage of an information object class and an information object set as parameters. The first parameter in the definition of AlgorithmIdentifier is an information object class. Information object classes used for this parameter must have &id and &Params fields, which determine the type of the algorithm and parameters fields. Other fields may be present in the information object class, but they are not used by the definition of AlgorithmIdentifier, as demonstrated by the SIGNATURE-ALGORITHM class shown below. The second parameter is an information object set that is used to constrain the values that appear in the algorithm and parameters fields.",
      "ja": "パラメータは単純型である必要はありません。次の例では、情報オブジェクトクラスとパラメータとして設定された情報オブジェクトの使用を示します。 AlgorithmIdentifierの定義の最初のパラメータは、情報オブジェクトクラスです。このパラメータに使用される情報のオブジェクトクラスは、アルゴリズムのタイプを決定し、フィールドをパラメータIDと＆PARAMS＆フィールドを、持っている必要があります。他のフィールドは、情報オブジェクトクラスに存在してもよいが、以下に示す署名アルゴリズムのクラスによって示されるように、それらは、のAlgorithmIdentifierの定義で使用されていません。第2のパラメータは、アルゴリズムとパラメータフィールドに表示される値を制約するために使用される情報オブジェクトセットです。"
    },
    {
      "indent": 3,
      "text": "-- from [RFC5912]\nAlgorithmIdentifier{ALGORITHM-TYPE, ALGORITHM-TYPE:AlgorithmSet}\n    ::= SEQUENCE\n{\n    algorithm   ALGORITHM-TYPE.&id({AlgorithmSet}),\n    parameters  ALGORITHM-TYPE.&Params\n                  ({AlgorithmSet}{@algorithm}) OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "SIGNATURE-ALGORITHM ::= CLASS {\n    &id             OBJECT IDENTIFIER,\n    &Params         OPTIONAL,\n    &Value          OPTIONAL,\n    &paramPresence  ParamOptions DEFAULT absent,\n    &HashSet        DIGEST-ALGORITHM OPTIONAL,\n    &PublicKeySet   PUBLIC-KEY OPTIONAL,\n    &smimeCaps      SMIME-CAPS OPTIONAL\n} WITH SYNTAX {\n    IDENTIFIER &id\n    [VALUE &Value]\n    [PARAMS [TYPE &Params] ARE &paramPresence ]\n    [HASHES &HashSet]\n    [PUBLIC KEYS &PublicKeySet]\n    [SMIME CAPS &smimeCaps]\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- from updated RFC 2560 module in [RFC5912]\nBasicOCSPResponse       ::= SEQUENCE {\n    tbsResponseData      ResponseData,\n    signatureAlgorithm   AlgorithmIdentifier{SIGNATURE-ALGORITHM,\n                          {sa-dsaWithSHA1 | sa-rsaWithSHA1 |\n                               sa-rsaWithMD5 | sa-rsaWithMD2, ...}},\n    signature            BIT STRING,\n    certs            [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.4. Versioning and Extensibility",
      "section_title": true,
      "ja": "2.4。バージョン管理と拡張性"
    },
    {
      "indent": 3,
      "text": "Specifications are often revised and ASN.1 modules updated to include new components. [CCITT.X681.2002] provides two mechanisms useful in supporting extensibility: extension markers and version brackets.",
      "ja": "仕様は、多くの場合、改訂され、ASN.1モジュールは、新しいコンポーネントを含むように更新されます。拡張マーカーおよびバージョン括弧：[CCITT.X681.2002]拡張を支援するのに有用な2つのメカニズムを提供します。"
    },
    {
      "indent": 0,
      "text": "2.4.1. Extension Markers",
      "section_title": true,
      "ja": "2.4.1。拡張マーカー"
    },
    {
      "indent": 3,
      "text": "An extension marker is represented by an ellipsis (i.e., three adjacent periods). Extension markers are included in specifications at points where the protocol designer anticipates future changes. This can also be achieved by including EXTENSIBILITY IMPLIED in the ASN.1 module definition. EXTENSIBILITY IMPLIED is the equivalent to including an extension marker in each type defined in the ASN.1 module. Extensibility markers are used throughout [RFC5911] and [RFC5912] where object sets are defined. In other instances, the updated modules retroactively added extension markers where fields were added to an earlier version by an update, as shown in the CertificateChoices example below.",
      "ja": "拡張マーカーは省略記号（すなわち、隣接する3つの周期）で表されます。拡張マーカーは、プロトコル設計者が将来の変化を予測点での仕様に含まれています。これはまた、ASN.1モジュール定義に黙示の拡張を含むことによって達成することができます。黙示拡張はASN.1モジュールで定義された各タイプに拡張マーカーを含むと等価です。拡張マーカーはオブジェクトセットが定義されている[RFC5911]及び[RFC5912]で使用されています。他の例では、更新されたモジュールは、遡及以下CertificateChoices例に示すように、フィールドは、アップデートにより、以前のバージョンに追加された拡張マーカーを追加します。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "-- from updated RFC 3370 module in [RFC5911]\nKeyAgreementAlgs KEY-AGREE ::= { kaa-esdh | kaa-ssdh, ...}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "-- from updated RFC 5652 module in [RFC5911]\nCertificateChoices ::= CHOICE {\n    certificate Certificate,\n    extendedCertificate [0] IMPLICIT ExtendedCertificate,\n         -- Obsolete\n    ...,\n    [[3: v1AttrCert [1] IMPLICIT AttributeCertificateV1]],\n         -- Obsolete\n    [[4: v2AttrCert [2] IMPLICIT AttributeCertificateV2]],\n    [[5: other      [3] IMPLICIT OtherCertificateFormat]]\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Protocol designers should use extension markers within definitions that are likely to change. For example, extensibility markers should be used when enumerating error values.",
      "ja": "プロトコルの設計者は、変更する可能性がある定義に拡張マーカーを使用する必要があります。エラー値を列挙するとき、例えば、拡張マーカーが使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "2.4.2. Version Brackets",
      "section_title": true,
      "ja": "2.4.2。バージョンブラケット"
    },
    {
      "indent": 3,
      "text": "Version brackets can be used to indicate features that are available in later versions of an ASN.1 module but not in earlier versions. [RFC5912] added version brackets to the definition of TBSCertificate to illustrate the addition of the issuerUniqueID, subjectUniqueID, and extensions fields, as shown below.",
      "ja": "バージョンブラケットは、ASN.1モジュールのそれ以降のバージョンでは使用できなく以前のバージョンである特徴を示すために使用することができます。 [RFC5912]は、以下に示すように、issuerUniqueID、subjectUniqueID、及び拡張フィールドの追加を例示するたtbsCertificateの定義にバージョンブラケットを追加しました。"
    },
    {
      "indent": 3,
      "text": "-- from updated RFC 5280 module in [RFC5912]\nTBSCertificate  ::=  SEQUENCE  {\n    version         [0]  Version DEFAULT v1,\n    serialNumber         CertificateSerialNumber,\n    signature            AlgorithmIdentifier{SIGNATURE-ALGORITHM,\n                              {SignatureAlgorithms}},\n    issuer               Name,\n    validity             Validity,\n    subject              Name,\n    subjectPublicKeyInfo SubjectPublicKeyInfo,\n    ... ,\n    [[2:               -- If present, version MUST be v2\n    issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,\n    subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL\n    ]],\n    [[3:               -- If present, version MUST be v3 --\n    extensions      [3]  ExtensionSet{{CertExtensions}} OPTIONAL\n    ]], ... }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3. Character Set Differences",
      "section_title": true,
      "ja": "3.文字セットの違い"
    },
    {
      "indent": 3,
      "text": "X.68s uses a character set that is a superset of the character set defined in X.208. The character set defined in X.208 includes the following:",
      "ja": "X.68sは、X.208で定義された文字セットのスーパーセットである文字セットを使用しています。 X.208で定義された文字セットは、次のものが含まれます。"
    },
    {
      "indent": 6,
      "text": "A to Z",
      "ja": "Zへ"
    },
    {
      "indent": 6,
      "text": "a to z",
      "ja": "この"
    },
    {
      "indent": 6,
      "text": "0 to 9",
      "ja": "０ と ９"
    },
    {
      "indent": 6,
      "text": ":=,{}<.",
      "ja": "：＝、｛｝＜。"
    },
    {
      "indent": 6,
      "text": "()[]-'\"",
      "ja": "（）「」ー’”"
    },
    {
      "indent": 3,
      "text": "The character set in X.68x additionally includes the following:",
      "ja": "X.68xに設定された文字は、さらに次のものが含まれます。"
    },
    {
      "indent": 6,
      "text": "!&*/;>@^_|",
      "ja": "！＆＊／；＞＠＾＿｜"
    },
    {
      "indent": 3,
      "text": "The > and | characters can also be used in X.208 syntax in macro definitions.",
      "ja": ">と|文字もマクロ定義でX.208構文で使用することができます。"
    },
    {
      "indent": 0,
      "text": "4. ASN.1 Translation",
      "section_title": true,
      "ja": "4. ASN.1翻訳"
    },
    {
      "indent": 0,
      "text": "4.1. Downgrading from X.68x to X.208",
      "section_title": true,
      "ja": "4.1。 X.68xからX.208へのダウングレード"
    },
    {
      "indent": 3,
      "text": "At a minimum, downgrading an ASN.1 module from X.68x syntax to X.208 requires the removal of features not supported by X.208. As indicated above, the features most commonly used in IETF Security Area ASN.1 modules are information object classes (and object sets), content constraints, parameterization, extension markers, and version brackets. Extension markers and version brackets can simply be deleted (or commented out). The definitions for information object classes and object sets can also be deleted or commented out, as these will not be used. The following checklist can be used in most cases:",
      "ja": "最低でも、X.208にX.68x構文からASN.1モジュールをダウングレードすることはX.208でサポートされていない機能を除去する必要があります。上記に示したように、最も一般的にIETFセキュリティエリアASN.1モジュールに使用される機能は、情報オブジェクトクラス（オブジェクトセット）、コンテンツの制約、パラメータ、拡張マーカー、およびバージョンブラケットです。拡張マーカーおよびバージョンブラケットは単に削除（またはコメントアウト）することができます。これらは使用されませんよう、情報オブジェクトクラスとオブジェクトセットの定義はまた、削除またはコメントアウトすることができます。次のチェックリストは、ほとんどのケースで使用することができます。"
    },
    {
      "indent": 3,
      "text": "o Remove all Information Set Class, Information Set Object, and Information Set Object Set definitions and imports from the file.",
      "ja": "Oファイルからすべての情報セットクラス、情報セットオブジェクト、および情報集合オブジェクトセットの定義と輸入を削除します。"
    },
    {
      "indent": 3,
      "text": "o Replace all fixed Type Information Set Class element references with the fixed type. (That is, replace FOO.&id with OBJECT IDENTIFIER.)",
      "ja": "O固定タイプのすべての固定型情報セットクラス要素の参照を交換してください。 （これはFOOを交換してください。＆IDオブジェクト識別子で、です。）"
    },
    {
      "indent": 3,
      "text": "o Delete all simple constraints.",
      "ja": "Oすべての単純な制約を削除します。"
    },
    {
      "indent": 3,
      "text": "o Delete all CONTAINING statements.",
      "ja": "Oすべて含有する文を削除します。"
    },
    {
      "indent": 3,
      "text": "o Replace all variable Type Information Set Class element references with either ANY or ANY DEFINED BY statements.",
      "ja": "O ANYまたは文によって定義されたいずれかで、すべての変数の型情報セットクラス要素の参照を交換してください。"
    },
    {
      "indent": 3,
      "text": "o Remove version and extension markers.",
      "ja": "バージョンと拡張マーカーを削除します。"
    },
    {
      "indent": 3,
      "text": "o Manually enforce all instances of parameterized types.",
      "ja": "O手動でパラメータ化された型のすべてのインスタンスを施行。"
    },
    {
      "indent": 0,
      "text": "4.2. Upgrading from X.208 to X.68x",
      "section_title": true,
      "ja": "4.2。 X.208からX.68xへのアップグレード"
    },
    {
      "indent": 3,
      "text": "The amount of change associated with upgrading from X.208 syntax to X.68x syntax is dependent on the reasons for changing and personal style. A minimalist approach could consist of altering any deprecated features, most commonly ANY DEFINED BY, and adding any necessary extensibility markers. A more comprehensive approach may include the introduction of constraints, parameterization, versioning, extensibility, etc.",
      "ja": "X.68x構文にX.208構文からのアップグレードに関連した変化量が変化し、個人的なスタイルの理由に依存しています。ミニマリストのアプローチは、最も一般的にいずれかによって定義された任意の推奨されない機能を、変更、および任意の必要な拡張マーカーを追加することで構成できました。より包括的なアプローチが等制約の導入、パラメータ、バージョン管理、拡張を含んでいてもよいです"
    },
    {
      "indent": 3,
      "text": "The following checklist can be used when upgrading a module without introducing constraints:",
      "ja": "モジュールをアップグレードする場合は、次のチェックリストは、制約を導入することなく使用することができます。"
    },
    {
      "indent": 6,
      "text": "Use TYPE-IDENTIFIER.&Type for \"ANY\".",
      "ja": "TYPE-IDを使用します。＆タイプ \"ANY\" のために。"
    },
    {
      "indent": 6,
      "text": "Use TYPE-IDENTIFIER.&Type for \"ANY DEFINED BY ...\".",
      "ja": "TYPE-IDを使用します。＆Typeに \"ANYで定義されて...\"。"
    },
    {
      "indent": 3,
      "text": "When constraints are introduced during an upgrade, additional steps are necessary:",
      "ja": "制約がアップグレード中に導入される場合、追加の手順が必要です："
    },
    {
      "indent": 3,
      "text": "1. Identify each unique class that should be defined based on what types of things exist.",
      "ja": "1.物事の種類が存在するものに基づいて定義されている必要があり、それぞれ一意のクラスを識別します。"
    },
    {
      "indent": 3,
      "text": "2. Define an Information Object Class for each of the classes above with the appropriate elements.",
      "ja": "2.適切な要素と上記のクラスの各々の情報オブジェクトクラスを定義します。"
    },
    {
      "indent": 3,
      "text": "3. Define all of the appropriate Information Object Sets based on the classes defined in step 2 along with the different places that they should be used.",
      "ja": "3.彼らが使用されるべき別の場所と一緒にステップ2で定義されたクラスに基づいて、適切な情報オブジェクトセットのすべてを定義します。"
    },
    {
      "indent": 3,
      "text": "4. Replace ANY by the appropriate class and variable type element.",
      "section_title": true,
      "ja": "4.適切なクラスや変数の型要素によってANYを交換してください。"
    },
    {
      "indent": 3,
      "text": "5. Replace ANY DEFINED BY with the appropriate variable type element and the components constraint. Replace the element used in the constraint with the appropriate fixed type element and simple constraint.",
      "ja": "5.適切な可変型の素子および構成要素制約とによって定義される任意のものを交換してください。適切な固定型要素と単純制約と制約で使用される要素を置き換えます。"
    },
    {
      "indent": 3,
      "text": "6. Add any simple constraints as appropriate.",
      "section_title": true,
      "ja": "6.必要に応じて、任意の単純な制約を追加します。"
    },
    {
      "indent": 3,
      "text": "7. Define any objects and fill in elements for object sets as appropriate.",
      "ja": "7.すべてのオブジェクトを定義し、必要に応じてオブジェクトのセットの要素で埋めます。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "Where a module is downgraded from X.68x syntax to X.208 there is loss of potential automated enforcement of constraints expressed by the author of the module being downgraded. These constraints should be captured in prose or ASN.1 comments and enforced through other means, as necessary.",
      "ja": "モジュールはX.208にX.68x構文から格下げされた場合は格下げされているモジュールの作者によって表現された制約の潜在的な自動化施行の損失があります。これらの制約は、散文またはASN.1コメントで捕捉され、必要に応じて、他の手段によって実施されるべきです。"
    },
    {
      "indent": 3,
      "text": "Depending on the feature set of the ASN.1 compiler being used, the code to enforce and use constraints may be generated automatically or may require the programmer to do this independently. It is the responsibility of the programmer to ensure that the constraints on the ASN.1 expressed either in prose or in the ASN.1 module are actually enforced.",
      "ja": "使用されているASN.1コンパイラの機能セットによっては、制約を強制し、使用するコードを自動的に生成してもよいし、独立して、これを行うために、プログラマが必要な場合があります。散文やASN.1モジュールのいずれかで表されるASN.1上の制約が実際に施行されることを保証するために、プログラマの責任です。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[CCITT.X208.1988] International Telephone and Telegraph Consultative Committee, \"Specification of Abstract Syntax Notation One (ASN.1)\", CCITT Recommendation X.208, November 1988.",
      "ja": "[CCITT.X208.1988]国際電信電話諮問委員会、「抽象構文記法1（ASN.1）の仕様」、CCITT勧告X.208、1988年11月。"
    },
    {
      "indent": 3,
      "text": "[CCITT.X680.2002] International Telephone and Telegraph Consultative Committee, \"Abstract Syntax Notation One (ASN.1): Specification of basic notation\", CCITT Recommendation X.680, July 2002.",
      "ja": "[CCITT.X680.2002]国際電信電話諮問委員会、「抽象構文記法1（ASN.1）：基本的な表記法の仕様」、CCITT勧告X.680、2002年7月。"
    },
    {
      "indent": 3,
      "text": "[CCITT.X681.2002] International Telephone and Telegraph Consultative Committee, \"Abstract Syntax Notation One (ASN.1): Information object specification\", CCITT Recommendation X.681, July 2002.",
      "ja": "[CCITT.X681.2002]国際電信電話諮問委員会、「抽象構文記法1（ASN.1）：情報オブジェクトの仕様」、CCITT勧告X.681、2002年7月。"
    },
    {
      "indent": 3,
      "text": "[CCITT.X682.2002] International Telephone and Telegraph Consultative Committee, \"Abstract Syntax Notation One (ASN.1): Constraint specification\", CCITT Recommendation X.682, July 2002.",
      "ja": "[CCITT.X682.2002]国際電信電話諮問委員会、「抽象構文記法1（ASN.1）：制約の指定」、CCITT勧告X.682、2002年7月。"
    },
    {
      "indent": 3,
      "text": "[CCITT.X683.2002] International Telephone and Telegraph Consultative Committee, \"Abstract Syntax Notation One (ASN.1): Parameterization of ASN.1 specifications\", CCITT Recommendation X.683, July 2002.",
      "ja": "[CCITT.X683.2002]国際電信電話諮問委員会、「抽象構文記法1（ASN.1）：ASN.1仕様のパラメータ化」、CCITT勧告X.683、2002年7月。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[CCITT.X209.1988] International Telephone and Telegraph Consultative Committee, \"Specification of Basic Encoding Rules for Abstract Syntax Notation One (ASN.1)\", CCITT Recommendation X.209, 1988.",
      "ja": "[CCITT.X209.1988]国際電信電話諮問委員会、CCITT勧告X. 209、1988、「抽象構文記法1（ASN.1）のための基本的な符号化規則の仕様」。"
    },
    {
      "indent": 3,
      "text": "[CCITT.X690.2002] International Telephone and Telegraph Consultative Committee, \"ASN.1 encoding rules: Specification of basic encoding Rules (BER), Canonical encoding rules (CER) and Distinguished encoding rules (DER)\", CCITT Recommendation X.690, July 2002.",
      "ja": "[CCITT.X690.2002]国際電信電話諮問委員会、「ASN.1エンコーディング規則：基本的な符号化規則（BER）、Canonicalの符号化規則（CER）との識別符号化規則（DER）の仕様」、CCITT勧告X.690 、2002年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC2560] Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, \"X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP\", RFC 2560, June 1999.",
      "ja": "[RFC2560]マイヤーズ、M.、Ankney、R.、Malpani、A.、Galperin、S.、およびC.アダムス、 \"X.509のインターネット公開鍵暗号基盤のオンライン証明書状態プロトコル -  OCSP\"、RFC 2560、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5652] Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70, RFC 5652, September 2009.",
      "ja": "[RFC5652] Housley氏、R.、 \"暗号メッセージ構文（CMS）\"、STD 70、RFC 5652、2009年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5911] Hoffman, P. and J. Schaad, \"New ASN.1 Modules for Cryptographic Message Syntax (CMS) and S/MIME\", RFC 5911, June 2010.",
      "ja": "[RFC5911]ホフマン、P.及びJ. Schaad、 \"暗号メッセージ構文（CMS）とS / MIMEのための新しいASN.1モジュール\"、RFC 5911、2010年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5912] Hoffman, P. and J. Schaad, \"New ASN.1 Modules for the Public Key Infrastructure Using X.509 (PKIX)\", RFC 5912, June 2010.",
      "ja": "[RFC5912]ホフマン、P.およびJ. Schaad、RFC 5912、2010年6月 \"公開鍵インフラストラクチャの使用X.509（PKIX）のための新しいASN.1モジュール\"。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Carl Wallace Cygnacom Solutions Suite 5400 7925 Jones Branch Drive McLean, VA 22102",
      "ja": "カール・ウォレスCygnacomソリューションスイート5400 7925ジョーンズ支店ドライブマクリーン、VA 22102"
    },
    {
      "indent": 3,
      "text": "EMail: cwallace@cygnacom.com",
      "ja": "メールアドレス：cwallace@cygnacom.com"
    },
    {
      "indent": 3,
      "text": "Charles Gardiner BBN Technologies 10 Moulton Street Cambridge, MA 02138",
      "ja": "チャールズ・ガーディナーBBNテクノロジーズ10モールトンストリートケンブリッジ、MA 02138"
    },
    {
      "indent": 3,
      "text": "EMail: gardiner@bbn.com",
      "ja": "メールアドレス：gardiner@bbn.com"
    }
  ]
}