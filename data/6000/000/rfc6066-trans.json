{
  "title": {
    "text": "RFC 6066 - Transport Layer Security (TLS) Extensions: Extension Definitions",
    "ja": "RFC 6066 - トランスポート層セキュリティ（TLS）拡張機能：拡張定義"
  },
  "number": 6066,
  "created_at": "2019-10-27 17:10:25.749887+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                   D. Eastlake 3rd\nRequest for Comments: 6066                                        Huawei\nObsoletes: 4366                                             January 2011\nCategory: Standards Track\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Transport Layer Security (TLS) Extensions: Extension Definitions",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document provides specifications for existing TLS extensions. It is a companion document for RFC 5246, \"The Transport Layer Security (TLS) Protocol Version 1.2\". The extensions specified are server_name, max_fragment_length, client_certificate_url, trusted_ca_keys, truncated_hmac, and status_request.",
      "ja": "この文書では、既存のTLS拡張機能の仕様を提供します。これは、RFC 5246のための仲間ドキュメントである「トランスポート層セキュリティ（TLS）プロトコルバージョン1.2」。指定された拡張子はサーバー名、max_fragment_length、client_certificate_url、trusted_ca_keys、truncated_hmac、およびstatus_requestです。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6066.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6066で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2011 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Specific Extensions Covered ................................3\n   1.2. Conventions Used in This Document ..........................5\n2. Extensions to the Handshake Protocol ............................5\n3. Server Name Indication ..........................................6\n4. Maximum Fragment Length Negotiation .............................8\n5. Client Certificate URLs .........................................9\n6. Trusted CA Indication ..........................................12\n7. Truncated HMAC .................................................13\n8. Certificate Status Request .....................................14\n9. Error Alerts ...................................................16\n10. IANA Considerations ...........................................17\n   10.1. pkipath MIME Type Registration ...........................17\n   10.2. Reference for TLS Alerts, TLS HandshakeTypes, and\n         ExtensionTypes ...........................................19\n11. Security Considerations .......................................19\n   11.1. Security Considerations for server_name ..................19\n   11.2. Security Considerations for max_fragment_length ..........20\n   11.3. Security Considerations for client_certificate_url .......20\n   11.4. Security Considerations for trusted_ca_keys ..............21\n   11.5. Security Considerations for truncated_hmac ...............21\n   11.6. Security Considerations for status_request ...............22\n12. Normative References ..........................................22\n13. Informative References ........................................23\nAppendix A. Changes from RFC 4366 .................................24\nAppendix B. Acknowledgements ......................................25",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The Transport Layer Security (TLS) Protocol Version 1.2 is specified in [RFC5246]. That specification includes the framework for extensions to TLS, considerations in designing such extensions (see Section 7.4.1.4 of [RFC5246]), and IANA Considerations for the allocation of new extension code points; however, it does not specify any particular extensions other than Signature Algorithms (see Section 7.4.1.4.1 of [RFC5246]).",
      "ja": "トランスポート層セキュリティ（TLS）プロトコルバージョン1.2は、[RFC5246]で指定されています。その仕様は、TLSへの拡張のためのフレームワーク、そのような拡張を設計する際の考慮事項（[RFC5246]のセクション7.4.1.4を参照）、新しい拡張コードポイントの割り当てのためのIANAの考慮事項を含みます。しかし、それは署名アルゴリズム以外の任意の特定の拡張子を指定しない（[RFC5246]のセクション7.4.1.4.1を参照）。"
    },
    {
      "indent": 3,
      "text": "This document provides the specifications for existing TLS extensions. It is, for the most part, the adaptation and editing of material from RFC 4366, which covered TLS extensions for TLS 1.0 (RFC 2246) and TLS 1.1 (RFC 4346).",
      "ja": "この文書では、既存のTLS拡張機能の仕様を提供します。これは、TLS 1.0（RF​​C 2246）およびTLS 1.1（RFC 4346）のためのTLS拡張をカバーしている、ほとんどの部分は、RFC 4366からの材料の適応と編集です。"
    },
    {
      "indent": 0,
      "text": "1.1. Specific Extensions Covered",
      "section_title": true,
      "ja": "1.1。具体的な拡張対象"
    },
    {
      "indent": 3,
      "text": "The extensions described here focus on extending the functionality provided by the TLS protocol message formats. Other issues, such as the addition of new cipher suites, are deferred.",
      "ja": "ここで説明する拡張は、TLSプロトコルメッセージフォーマットで提供される機能を拡張するに焦点を当てます。新たな暗号スイートの追加などの他の問題は、延期されています。"
    },
    {
      "indent": 3,
      "text": "The extension types defined in this document are:",
      "ja": "この文書で定義された拡張タイプは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "enum {\n    server_name(0), max_fragment_length(1),\n    client_certificate_url(2), trusted_ca_keys(3),\n    truncated_hmac(4), status_request(5), (65535)\n} ExtensionType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Specifically, the extensions described in this document:",
      "ja": "具体的には、拡張子は、この文書で説明します："
    },
    {
      "indent": 3,
      "text": "- Allow TLS clients to provide to the TLS server the name of the server they are contacting. This functionality is desirable in order to facilitate secure connections to servers that host multiple 'virtual' servers at a single underlying network address.",
      "ja": " -  TLSクライアントはTLSサーバに、彼らが接触しているサーバーの名前を提供することを許可します。この機能は、単一の基盤となるネットワークアドレスに複数の「仮想」サーバをホストするサーバーへのセキュアな接続を容易にするために望ましいです。"
    },
    {
      "indent": 3,
      "text": "- Allow TLS clients and servers to negotiate the maximum fragment length to be sent. This functionality is desirable as a result of memory constraints among some clients, and bandwidth constraints among some access networks.",
      "ja": " -  TLSクライアントとサーバが送信する最大フラグメント長を交渉することを許可します。この機能は、いくつかのアクセスネットワークの中で、いくつかのクライアントの間でメモリ制約、および帯域幅の制約の結果として望ましいです。"
    },
    {
      "indent": 3,
      "text": "- Allow TLS clients and servers to negotiate the use of client certificate URLs. This functionality is desirable in order to conserve memory on constrained clients.",
      "ja": " -  TLSクライアントとサーバは、クライアント証明書のURLの使用を交渉することを許可します。この機能は、制約のクライアントでメモリを節約するために望ましいです。"
    },
    {
      "indent": 3,
      "text": "- Allow TLS clients to indicate to TLS servers which certification authority (CA) root keys they possess. This functionality is desirable in order to prevent multiple handshake failures involving TLS clients that are only able to store a small number of CA root keys due to memory limitations.",
      "ja": " -  TLSクライアントは、彼らが持っている認証局（CA）ルートキーTLSサーバに指示することを許可します。この機能は、メモリの制限のためにCAルート鍵の小さな番号を保存することができますTLSクライアントを含む複数のハンドシェイクの失敗を防ぐために望ましいです。"
    },
    {
      "indent": 3,
      "text": "- Allow TLS clients and servers to negotiate the use of truncated Message Authentication Codes (MACs). This functionality is desirable in order to conserve bandwidth in constrained access networks.",
      "ja": " -  TLSクライアントとサーバが切り捨てメッセージ認証コード（MAC）の使用を交渉することを許可します。この機能は、制約されたアクセスネットワークにおける帯域幅を節約するために望ましいです。"
    },
    {
      "indent": 3,
      "text": "- Allow TLS clients and servers to negotiate that the server sends the client certificate status information (e.g., an Online Certificate Status Protocol (OCSP) [RFC2560] response) during a TLS handshake. This functionality is desirable in order to avoid sending a Certificate Revocation List (CRL) over a constrained access network and therefore saving bandwidth.",
      "ja": " -  TLSクライアントとサーバがTLSハンドシェイク中にサーバがクライアント証明書のステータス情報を送信する（例えば、オンライン証明書状態プロトコル（OCSP）[RFC2560]応答）を交渉することを許可します。この機能は、制約されたアクセスネットワーク上で証明書失効リスト（CRL）を送信するので、帯域幅を節約避けるために望ましいです。"
    },
    {
      "indent": 3,
      "text": "TLS clients and servers may use the extensions described in this document. The extensions are designed to be backwards compatible, meaning that TLS clients that support the extensions can talk to TLS servers that do not support the extensions, and vice versa.",
      "ja": "TLSクライアントとサーバは、この文書で説明する機能拡張を使用することができます。拡張は拡張をサポートするTLSクライアントが拡張をサポートしていないTLSサーバ、およびその逆に話すことができることを意味し、後方互換性を持つように設計されています。"
    },
    {
      "indent": 3,
      "text": "Note that any messages associated with these extensions that are sent during the TLS handshake MUST be included in the hash calculations involved in \"Finished\" messages.",
      "ja": "TLSハンドシェイク中に送信されたこれらの拡張子に関連付けられたすべてのメッセージは、「完了」のメッセージに関与ハッシュ計算に含めなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note also that all the extensions defined in this document are relevant only when a session is initiated. A client that requests session resumption does not in general know whether the server will accept this request, and therefore it SHOULD send the same extensions as it would send if it were not attempting resumption. When a client includes one or more of the defined extension types in an extended client hello while requesting session resumption:",
      "ja": "この文書で定義されたすべての拡張機能は、セッションが開始されている場合にのみ関連していることにも注意してください。セッション再開を要求するクライアントは、一般的には、サーバがこの要求を受け入れるかどうかわからないので、それが再開を試みていなかったならば、それは送るのと同じ拡張子を送るべきです。セッションの再開を要求しながら、クライアントが拡張されたクライアントハローで定義された拡張タイプの一つ以上を含む場合。"
    },
    {
      "indent": 3,
      "text": "- The server name indication extension MAY be used by the server when deciding whether or not to resume a session as described in Section 3.",
      "ja": " - 第3節で説明したように、セッションを再開するかどうかを決定する場合、サーバー名の表示の拡張子はサーバーによって使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "- If the resumption request is denied, the use of the extensions is negotiated as normal.",
      "ja": " - 再開要求が拒否された場合、拡張の使用は、通常のように交渉されます。"
    },
    {
      "indent": 3,
      "text": "- If, on the other hand, the older session is resumed, then the server MUST ignore the extensions and send a server hello containing none of the extension types. In this case, the functionality of these extensions negotiated during the original session initiation is applied to the resumed session.",
      "ja": " - 一方で、古いセッションが再開されている場合は、サーバー拡張機能を無視して、拡張型のいずれも含有しない、サーバーハローを送らなければなりません。この場合、元のセッション開始時にネゴシエートされたこれらの拡張機能は、再開セッションに適用されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.2。このドキュメントの表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL 「本書では[RFC2119]で説明されるように解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "2. Extensions to the Handshake Protocol",
      "section_title": true,
      "ja": "ハンドシェイクプロトコル2.拡張"
    },
    {
      "indent": 3,
      "text": "This document specifies the use of two new handshake messages, \"CertificateURL\" and \"CertificateStatus\". These messages are described in Sections 5 and 8, respectively. The new handshake message structure therefore becomes:",
      "ja": "この文書では、2つの新しいハンドシェイクメッセージ、「CertificateURL」と「CertificateStatus」の使用を指定します。これらのメッセージはそれぞれ、セクション5及び8に記載されています。新しいハンドシェイクメッセージの構造は、したがって、次のようになります。"
    },
    {
      "indent": 3,
      "text": "enum {\n    hello_request(0), client_hello(1), server_hello(2),\n    certificate(11), server_key_exchange (12),\n    certificate_request(13), server_hello_done(14),\n    certificate_verify(15), client_key_exchange(16),\n    finished(20), certificate_url(21), certificate_status(22),\n    (255)\n} HandshakeType;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct {\n    HandshakeType msg_type;    /* handshake type */\n    uint24 length;             /* bytes in message */\n    select (HandshakeType) {\n        case hello_request:       HelloRequest;\n        case client_hello:        ClientHello;\n        case server_hello:        ServerHello;\n        case certificate:         Certificate;\n        case server_key_exchange: ServerKeyExchange;\n        case certificate_request: CertificateRequest;\n        case server_hello_done:   ServerHelloDone;\n        case certificate_verify:  CertificateVerify;\n        case client_key_exchange: ClientKeyExchange;\n        case finished:            Finished;\n        case certificate_url:     CertificateURL;\n        case certificate_status:  CertificateStatus;\n    } body;\n} Handshake;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3. Server Name Indication",
      "section_title": true,
      "ja": "3.サーバー名の表示"
    },
    {
      "indent": 3,
      "text": "TLS does not provide a mechanism for a client to tell a server the name of the server it is contacting. It may be desirable for clients to provide this information to facilitate secure connections to servers that host multiple 'virtual' servers at a single underlying network address.",
      "ja": "TLSは、サーバーにそれが接触しているサーバーの名前を伝えるために、クライアントのためのメカニズムを提供しません。クライアントは、単一の基盤となるネットワークアドレスに複数の「仮想」サーバをホストするサーバーへのセキュアな接続を容易にするために、この情報を提供することが望ましい場合があります。"
    },
    {
      "indent": 3,
      "text": "In order to provide any of the server names, clients MAY include an extension of type \"server_name\" in the (extended) client hello. The \"extension_data\" field of this extension SHALL contain \"ServerNameList\" where:",
      "ja": "サーバー名のいずれかを提供するために、クライアントは（拡張）クライアントのhelloを入力し、「サーバー名」の拡張子を含むかもしれません。この拡張機能の「拡大」フィールドが「ServerNameList」を含まなければなりません："
    },
    {
      "indent": 6,
      "text": "struct {\n    NameType name_type;\n    select (name_type) {\n        case host_name: HostName;\n    } name;\n} ServerName;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "enum {\n    host_name(0), (255)\n} NameType;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "opaque HostName<1..2^16-1>;",
      "ja": "不透明なホスト名<1..2 ^ 16-1>;"
    },
    {
      "indent": 6,
      "text": "struct {\n    ServerName server_name_list<1..2^16-1>\n} ServerNameList;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The ServerNameList MUST NOT contain more than one name of the same name_type. If the server understood the ClientHello extension but does not recognize the server name, the server SHOULD take one of two actions: either abort the handshake by sending a fatal-level unrecognized_name(112) alert or continue the handshake. It is NOT RECOMMENDED to send a warning-level unrecognized_name(112) alert, because the client's behavior in response to warning-level alerts is unpredictable. If there is a mismatch between the server name used by the client application and the server name of the credential chosen by the server, this mismatch will become apparent when the client application performs the server endpoint identification, at which point the client application will have to decide whether to proceed with the communication. TLS implementations are encouraged to make information available to application callers about warning-level alerts that were received or sent during a TLS handshake. Such information can be useful for diagnostic purposes.",
      "ja": "ServerNameListは同じname_typeの複数の名前を含めることはできません。サーバはのClientHelloエクステンションを理解しますが、サーバー名を認識しない場合は、サーバーは、2つのいずれかのアクションを取る必要があります：致命的なレベルunrecognized_name（112）アラートを送信することにより、ハンドシェイクを中止したり握手を続けるのいずれか。警告レベルのアラートに応じて、クライアントの行動は予測不可能であるため、警告レベルのunrecognized_name（112）アラートを送信することが推奨されていません。クライアント・アプリケーションとサーバーによって選択された信用証明書のサーバ名によって使用されるサーバ名の間に不一致がある場合、クライアントアプリケーションは、クライアント・アプリケーションがなければならないその時点でサーバのエンドポイント識別を行う場合、この不一致が明らかとなるであろう通信を続行するかどうかを決定します。 TLSの実装は、TLSハンドシェイク中に受信または送信された警告レベルのアラートについてアプリケーションの発信者に情報を利用できるようにすることをお勧めします。そのような情報は、診断目的のために有用であり得ます。"
    },
    {
      "indent": 6,
      "text": "Note: Earlier versions of this specification permitted multiple names of the same name_type. In practice, current client implementations only send one name, and the client cannot necessarily find out which name the server selected. Multiple names of the same name_type are therefore now prohibited.",
      "ja": "注意：この仕様の以前のバージョンでは、同じname_typeの複数の名前を許可します。実際には、現在のクライアントの実装は、1つの名前のみを送信し、クライアントは必ずしもサーバが選択されている名前を見つけることができません。同じname_typeの複数の名前は、したがって、今禁止されています。"
    },
    {
      "indent": 3,
      "text": "Currently, the only server names supported are DNS hostnames; however, this does not imply any dependency of TLS on DNS, and other name types may be added in the future (by an RFC that updates this document). The data structure associated with the host_name NameType is a variable-length vector that begins with a 16-bit length. For backward compatibility, all future data structures associated with new NameTypes MUST begin with a 16-bit length field. TLS MAY treat provided server names as opaque data and pass the names and types to the application.",
      "ja": "現在、サポートされている唯一のサーバー名がDNSホスト名です。しかしながら、これは、DNS上のTLSの任意の依存性を意味するものではない、と他の名前の種類（この文書を更新するRFCにより）将来的に添加してもよいです。 HOST_NAMEのNAMETYPEに関連付けられたデータ構造は、16ビット長で始まり、可変長ベクトルです。下位互換性のために、新しいNameTypesに関連するすべての将来のデータ構造は、16ビット長のフィールドで開始する必要があります。 TLSは、不透明なデータとして提供するサーバー名を扱い、アプリケーションに名前と型を渡すことができます。"
    },
    {
      "indent": 3,
      "text": "\"HostName\" contains the fully qualified DNS hostname of the server, as understood by the client. The hostname is represented as a byte string using ASCII encoding without a trailing dot. This allows the support of internationalized domain names through the use of A-labels defined in [RFC5890]. DNS hostnames are case-insensitive. The algorithm to compare hostnames is described in [RFC5890], Section 2.3.2.4.",
      "ja": "「ホスト名は」クライアントによって理解されるよう、サーバーの完全修飾DNSホスト名が含まれています。ホスト名は末尾のドットなしASCIIエンコーディングを使用して、バイト文字列として表現されます。これは、[RFC5890]で定義され、ラベルを使用して国際化ドメイン名のサポートを可能にします。 DNSホスト名は大文字と小文字を区別しません。ホスト名を比較するためのアルゴリズムは[RFC5890]、セクション2.3.2.4に記載されています。"
    },
    {
      "indent": 3,
      "text": "Literal IPv4 and IPv6 addresses are not permitted in \"HostName\".",
      "ja": "リテラルIPv4アドレスとIPv6アドレスは、「ホスト名」には許可されていません。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that clients include an extension of type \"server_name\" in the client hello whenever they locate a server by a supported name type.",
      "ja": "彼らがサポート名前の種類によってサーバーを見つけるたび、クライアントがクライアントのhelloを入力し、「サーバー名」の拡張子を含めることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "A server that receives a client hello containing the \"server_name\" extension MAY use the information contained in the extension to guide its selection of an appropriate certificate to return to the client, and/or other aspects of security policy. In this event, the server SHALL include an extension of type \"server_name\" in the (extended) server hello. The \"extension_data\" field of this extension SHALL be empty.",
      "ja": "セキュリティポリシーのおよび/または他の側面、クライアントに返すために適切な証明書のその選択をガイドするための拡張に含まれている情報を使用するかもしれ「サーバー名」の拡張子を含むクライアントのhelloを受信するサーバー。この場合、サーバは、（拡張）サーバハロータイプの拡張子「サーバ名」を含むものとします。この拡張機能の「拡大」フィールドが空にされなければなりません。"
    },
    {
      "indent": 3,
      "text": "When the server is deciding whether or not to accept a request to resume a session, the contents of a server_name extension MAY be used in the lookup of the session in the session cache. The client SHOULD include the same server_name extension in the session resumption request as it did in the full handshake that established the session. A server that implements this extension MUST NOT accept the request to resume the session if the server_name extension contains a different name. Instead, it proceeds with a full handshake to establish a new session. When resuming a session, the server MUST NOT include a server_name extension in the server hello.",
      "ja": "サーバーがセッションを再開するための要求を受諾するかどうかを決定した場合、サーバー名の拡張子の内容は、セッションキャッシュ内のセッションのルックアップで使用されるかもしれません。それは、セッションを確立し、完全な握手で行ったように、クライアントは、セッション再開要求で同じサーバー名の拡張子を含めるべきです。 SERVER_NAMEの拡張子が別の名前が含まれている場合、この拡張機能を実装してサーバがセッションを再開するための要求を受け入れてはいけません。代わりに、それは新しいセッションを確立するために、完全な握手して進めます。セッションを再開すると、サーバは、サーバのハローでサーバー名拡張子を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "If an application negotiates a server name using an application protocol and then upgrades to TLS, and if a server_name extension is sent, then the extension SHOULD contain the same name that was negotiated in the application protocol. If the server_name is established in the TLS session handshake, the client SHOULD NOT attempt to request a different server name at the application layer.",
      "ja": "アプリケーションは、アプリケーションプロトコルを使用してサーバー名を交渉した場合はTLSへのアップグレード、およびサーバー名の拡張子が送信された場合、その後の拡張は、アプリケーションプロトコルで交渉されたのと同じ名前を含むべきです。 SERVER_NAMEはTLSセッションハンドシェイクで確立された場合、クライアントは、アプリケーション層で別のサーバー名を要求するように試みるべきではありません。"
    },
    {
      "indent": 0,
      "text": "4. Maximum Fragment Length Negotiation",
      "section_title": true,
      "ja": "4.最大フラグメント長交渉"
    },
    {
      "indent": 3,
      "text": "Without this extension, TLS specifies a fixed maximum plaintext fragment length of 2^14 bytes. It may be desirable for constrained clients to negotiate a smaller maximum fragment length due to memory limitations or bandwidth limitations.",
      "ja": "この拡張せず、TLSは、2 ^ 14バイトの固定最大平文断片の長さを指定します。制約クライアントがメモリ制限または帯域幅制限による小さい最大フラグメント長を交渉することが望ましいかもしれません。"
    },
    {
      "indent": 3,
      "text": "In order to negotiate smaller maximum fragment lengths, clients MAY include an extension of type \"max_fragment_length\" in the (extended) client hello. The \"extension_data\" field of this extension SHALL contain:",
      "ja": "より小さい最大フラグメント長を交渉するために、クライアントは、（拡張）クライアントハロータイプの拡張子「max_fragment_lengthを」を含むことができます。この拡張機能の「拡大」フィールドが含まれていなければなりません。"
    },
    {
      "indent": 6,
      "text": "enum{ 2^9(1), 2^10(2), 2^11(3), 2^12(4), (255) } MaxFragmentLength;",
      "ja": "列挙{2 ^ 9（1）、2 ^ 10（2）、2 ^ 11（3）、2 ^ 12（4）、（255）} MaxFragmentLength。"
    },
    {
      "indent": 3,
      "text": "whose value is the desired maximum fragment length. The allowed values for this field are: 2^9, 2^10, 2^11, and 2^12.",
      "ja": "その値は所望の最大フラグメント長です。このフィールドの許容値は：^ 9 2、^ 10 2、^ 11 2、および2 ^ 12。"
    },
    {
      "indent": 3,
      "text": "Servers that receive an extended client hello containing a \"max_fragment_length\" extension MAY accept the requested maximum fragment length by including an extension of type \"max_fragment_length\" in the (extended) server hello. The \"extension_data\" field of this extension SHALL contain a \"MaxFragmentLength\" whose value is the same as the requested maximum fragment length.",
      "ja": "「max_fragment_length」拡張を含む拡張されたクライアントハローを受信サーバー（拡張）サーバタイプの拡張子を含むことにより、要求された最大の断片長を受け付けるようにしてもよい「max_fragment_length」こんにちは。この拡張の「拡大」フィールドは、値が要求された最大フラグメント長さと同じである「MaxFragmentLength」を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a server receives a maximum fragment length negotiation request for a value other than the allowed values, it MUST abort the handshake with an \"illegal_parameter\" alert. Similarly, if a client receives a maximum fragment length negotiation response that differs from the length it requested, it MUST also abort the handshake with an \"illegal_parameter\" alert.",
      "ja": "サーバーが許可された値以外の値の最大フラグメント長交渉要求を受信した場合、それは「illegal_parameter」アラートに握手を中止しなければなりません。クライアントが要求された長さとは異なり、最大フラグメント長交渉応答を受信した場合同様に、それはまた、「illegal_parameter」アラートに握手を中止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once a maximum fragment length other than 2^14 has been successfully negotiated, the client and server MUST immediately begin fragmenting messages (including handshake messages) to ensure that no fragment larger than the negotiated length is sent. Note that TLS already requires clients and servers to support fragmentation of handshake messages.",
      "ja": "2 ^ 14以外の最大フラグメント長さが正常にネゴシエートされた後、クライアントとサーバーは直ちにネゴシエート長さよりも大きくないフラグメントが送信されないことを保証するために、（ハンドシェイク・メッセージを含む）メッセージを断片化開始しなければなりません。 TLSは、すでにハンドシェイクメッセージの断片化をサポートするために、クライアントとサーバが必要であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The negotiated length applies for the duration of the session including session resumptions.",
      "ja": "交渉さ長さは、セッションコンテニューを含むセッションの間に適用されます。"
    },
    {
      "indent": 3,
      "text": "The negotiated length limits the input that the record layer may process without fragmentation (that is, the maximum value of TLSPlaintext.length; see [RFC5246], Section 6.2.1). Note that the output of the record layer may be larger. For example, if the negotiated length is 2^9=512, then, when using currently defined cipher suites (those defined in [RFC5246] and [RFC2712]) and null compression, the record-layer output can be at most 805 bytes: 5 bytes of headers, 512 bytes of application data, 256 bytes of padding, and 32 bytes of MAC. This means that in this event a TLS record-layer peer receiving a TLS record-layer message larger than 805 bytes MUST discard the message and send a \"record_overflow\" alert, without decrypting the message. When this extension is used with Datagram Transport Layer Security (DTLS), implementations SHOULD NOT generate record_overflow alerts unless the packet passes message authentication.",
      "ja": "ネゴシエートされた長さ（すなわち、TLSPlaintext.lengthの最大値であり、[RFC5246]、セクション6.2.1を参照）記録層が断片化することなく処理することができること入力を制限します。記録層の出力が大きくてもよいことに留意されたいです。ネゴシエートされた長さが2 ^ 9 = 512である場合、現在定義されている暗号スイート（[RFC5246]及び[RFC2712]で定義されたもの）とヌル圧縮を使用する場合、例えば、その後、記録層の出力は、ほとんどの805バイトであることができます。ヘッダの5バイト、アプリケーションデータの512バイト、パディングの256バイト、およびMACの32バイト。これは、このイベントにTLSレコード層ピアより大きい805のバイトはメッセージを破棄してメッセージを復号化することなく、「record_overflow」アラートを送信しなければならないTLSレコード層メッセージを受信することを意味します。この拡張機能は、データグラムトランスポート層セキュリティ（DTLS）を使用した場合、パケットがメッセージ認証を通過しない限り、実装はrecord_overflowアラートを生成するべきではありません。"
    },
    {
      "indent": 0,
      "text": "5. Client Certificate URLs",
      "section_title": true,
      "ja": "5.クライアント証明書のURL"
    },
    {
      "indent": 3,
      "text": "Without this extension, TLS specifies that when client authentication is performed, client certificates are sent by clients to servers during the TLS handshake. It may be desirable for constrained clients to send certificate URLs in place of certificates, so that they do not need to store their certificates and can therefore save memory.",
      "ja": "この拡張機能がないと、TLSは、クライアント認証が行われた場合、クライアント証明書は、TLSハンドシェイク中にサーバにクライアントから送信されることを指定します。彼らは自分の証明書を格納する必要がないため、メモリを節約することができるように拘束されたクライアントは、証明書の代わりに証明書のURLを送信することが望ましい場合があります。"
    },
    {
      "indent": 3,
      "text": "In order to negotiate sending certificate URLs to a server, clients MAY include an extension of type \"client_certificate_url\" in the (extended) client hello. The \"extension_data\" field of this extension SHALL be empty.",
      "ja": "サーバーに証明書のURLを送る交渉するためには、クライアントは（拡張）クライアントのhelloを入力し、「client_certificate_url」の拡張子を含むかもしれません。この拡張機能の「拡大」フィールドが空にされなければなりません。"
    },
    {
      "indent": 3,
      "text": "(Note that it is necessary to negotiate the use of client certificate URLs in order to avoid \"breaking\" existing TLS servers.)",
      "ja": "（既存のTLSサーバを「破壊」を避けるために、クライアント証明書のURLの使用を交渉する必要があることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "Servers that receive an extended client hello containing a \"client_certificate_url\" extension MAY indicate that they are willing to accept certificate URLs by including an extension of type \"client_certificate_url\" in the (extended) server hello. The \"extension_data\" field of this extension SHALL be empty.",
      "ja": "「client_certificate_url」拡張を含む拡張クライアントのhelloを受け取るサーバは、彼らが（拡張）サーバーこんにちはにおけるタイプ「client_certificate_url」の拡張子を含めることにより、証明書のURLを受け入れて喜んでであることを示してもよいです。この拡張機能の「拡大」フィールドが空にされなければなりません。"
    },
    {
      "indent": 3,
      "text": "After negotiation of the use of client certificate URLs has been successfully completed (by exchanging hellos including \"client_certificate_url\" extensions), clients MAY send a \"CertificateURL\" message in place of a \"Certificate\" message as follows (see also Section 2):",
      "ja": "クライアント証明書URLの使用の交渉は成功し、次のようにクライアントが「証明書」のメッセージの代わりに「CertificateURL」メッセージを送信することができる、（「client_certificate_url」拡張を含むhelloを交換することで）完了した後（また、第2節を参照してください）："
    },
    {
      "indent": 6,
      "text": "enum {\n    individual_certs(0), pkipath(1), (255)\n} CertChainType;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct {\n    CertChainType type;\n    URLAndHash url_and_hash_list<1..2^16-1>;\n} CertificateURL;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct {\n    opaque url<1..2^16-1>;\n    unint8 padding;\n    opaque SHA1Hash[20];\n} URLAndHash;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here, \"url_and_hash_list\" contains a sequence of URLs and hashes. Each \"url\" MUST be an absolute URI reference according to [RFC3986] that can be immediately used to fetch the certificate(s).",
      "ja": "ここで、「url_and_hash_listは、」URLとハッシュの配列を含みます。各「URL」は、直ちに証明書をフェッチするために使用することができる[RFC3986]に記載の絶対URI参照でなければなりません。"
    },
    {
      "indent": 3,
      "text": "When X.509 certificates are used, there are two possibilities:",
      "ja": "X.509証明書を使用する場合には、2つの可能性があります。"
    },
    {
      "indent": 3,
      "text": "- If CertificateURL.type is \"individual_certs\", each URL refers to a single DER-encoded X.509v3 certificate, with the URL for the client's certificate first.",
      "ja": " -  CertificateURL.typeは「individual_certs」である場合は、各URLは、最初にクライアントの証明書のためのURLと、シングルDERで符号化されたX.509v3証明書を指します。"
    },
    {
      "indent": 3,
      "text": "- If CertificateURL.type is \"pkipath\", the list contains a single URL referring to a DER-encoded certificate chain, using the type PkiPath described in Section 10.1.",
      "ja": " -  CertificateURL.typeは「pkipath」である場合、リストには、セクション10.1に記載されているタイプのPkiPathを使用して、DERでエンコードされた証明書チェーンを参照する単一のURLが含まれています。"
    },
    {
      "indent": 3,
      "text": "When any other certificate format is used, the specification that describes use of that format in TLS should define the encoding format of certificates or certificate chains, and any constraint on their ordering.",
      "ja": "他の証明書のフォーマットを使用する場合は、TLSでその形式の使用が記載されている仕様は、証明書または証明書チェーンのエンコード形式、およびその順序上の任意の制約を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"padding\" byte MUST be 0x01. It is present to make the structure backwards compatible.",
      "ja": "「パディング」バイトが0x01でなければなりません。構造が後方互換性を持たせるために存在しています。"
    },
    {
      "indent": 3,
      "text": "The hash corresponding to each URL is the SHA-1 hash of the certificate or certificate chain (in the case of X.509 certificates, the DER-encoded certificate or the DER-encoded PkiPath).",
      "ja": "各URLに対応するハッシュは、（X.509証明書の場合には、DER符号化された証明書またはDERエンコードPkiPath）証明書または証明書チェーンのSHA-1ハッシュです。"
    },
    {
      "indent": 3,
      "text": "Note that when a list of URLs for X.509 certificates is used, the ordering of URLs is the same as that used in the TLS Certificate message (see [RFC5246], Section 7.4.2), but opposite to the order in which certificates are encoded in PkiPath. In either case, the self-signed root certificate MAY be omitted from the chain, under the assumption that the server must already possess it in order to validate it.",
      "ja": "X.509証明書のURLのリストを使用する場合、URLの順序は、TLS証明書メッセージに使用されるものと同じであることに注意してください（セクション7.4.2を[RFC5246]を参照）が、順序内の証明書とは反対PkiPathでエンコードされています。いずれの場合も、自己署名ルート証明書は、サーバーがそれを検証するために、それをすでに所有していなければならないという仮定の下で、チェーンから省略されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Servers receiving \"CertificateURL\" SHALL attempt to retrieve the client's certificate chain from the URLs and then process the certificate chain as usual. A cached copy of the content of any URL in the chain MAY be used, provided that the SHA-1 hash matches the hash of the cached copy.",
      "ja": "「CertificateURL」を受信サーバーは、URLからクライアントの証明書チェーンを取得し、いつものように証明書チェーンを処理しようとしないものとします。チェーン内のURLのコンテンツのキャッシュされたコピーは、SHA-1ハッシュがキャッシュされたコピーのハッシュと一致することを提供し、使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Servers that support this extension MUST support the 'http' URI scheme for certificate URLs and MAY support other schemes. Use of other schemes than 'http', 'https', or 'ftp' may create unexpected problems.",
      "ja": "この拡張機能をサポートするサーバーは、証明書のURLの「HTTP」URIスキームをサポートしなければならないし、他のスキームをサポートするかもしれません。 「HTTP」、「HTTPS」、または「FTP」以外のスキームを使用すると、予期しない問題を作成することがあります。"
    },
    {
      "indent": 3,
      "text": "If the protocol used is HTTP, then the HTTP server can be configured to use the Cache-Control and Expires directives described in [RFC2616] to specify whether and for how long certificates or certificate chains should be cached.",
      "ja": "使用されるプロトコルがHTTPの場合、HTTPサーバは、キャッシュ・コントロールを使用するように設定しているかどうかと、キャッシュする必要があるどのくらいの証明書または証明書チェーンに指定し、[RFC2616]で説明したディレクティブを期限切れにすることができます。"
    },
    {
      "indent": 3,
      "text": "The TLS server MUST NOT follow HTTP redirects when retrieving the certificates or certificate chain. The URLs used in this extension MUST NOT be chosen to depend on such redirects.",
      "ja": "TLSサーバは、証明書または証明書チェーンを取得する際にHTTPリダイレクトを辿るてはなりません。この拡張で使用されるURLは、リダイレクトに依存することを選択してはなりません。"
    },
    {
      "indent": 3,
      "text": "If the protocol used to retrieve certificates or certificate chains returns a MIME-formatted response (as HTTP does), then the following MIME Content-Types SHALL be used: when a single X.509v3 certificate is returned, the Content-Type is \"application/pkix-cert\" [RFC2585], and when a chain of X.509v3 certificates is returned, the Content-Type is \"application/pkix-pkipath\" (Section 10.1).",
      "ja": "証明書または証明書チェーンを取得するために使用されるプロトコルは、（HTTPがするように）MIME形式の応答を返した場合は、次のMIMEコンテンツタイプを使用しなければならない：単一X.509v3証明書が返されたときに、Content-Typeのは、「アプリケーションです/ PKIX-CERT」[RFC2585]とのX.509v3証明書のチェーンが返された場合、コンテンツタイプが \"アプリケーション/ PKIX-pkipath\"（セクション10.1）。"
    },
    {
      "indent": 3,
      "text": "The server MUST check that the SHA-1 hash of the contents of the object retrieved from that URL (after decoding any MIME Content-Transfer-Encoding) matches the given hash. If any retrieved object does not have the correct SHA-1 hash, the server MUST abort the handshake with a bad_certificate_hash_value(114) alert. This alert is always fatal.",
      "ja": "サーバは、（任意のMIMEコンテンツ転送エンコードをデコードした後）、そのURLから取得したオブジェクトのコンテンツのSHA-1ハッシュが所定のハッシュと一致することをチェックしなければなりません。任意の検索されたオブジェクトが正しいSHA-1ハッシュを持っていない場合、サーバはbad_certificate_hash_value（114）アラートとのハンドシェイクを中止しなければなりません。このアラートは常にfatalです。"
    },
    {
      "indent": 3,
      "text": "Clients may choose to send either \"Certificate\" or \"CertificateURL\" after successfully negotiating the option to send certificate URLs. The option to send a certificate is included to provide flexibility to clients possessing multiple certificates.",
      "ja": "クライアントが成功した証明書のURLを送信するオプションを交渉した後、「証明書」または「CertificateURL」のいずれかを送信することもできます。証明書を送信するためのオプションは、複数の証明書を持つクライアントに柔軟性を提供するために含まれています。"
    },
    {
      "indent": 3,
      "text": "If a server is unable to obtain certificates in a given CertificateURL, it MUST send a fatal certificate_unobtainable(111) alert if it requires the certificates to complete the handshake. If the server does not require the certificates, then the server continues the handshake. The server MAY send a warning-level alert in this case. Clients receiving such an alert SHOULD log the alert and continue with the handshake if possible.",
      "ja": "サーバは与えられたCertificateURLで証明書を取得できない場合、それはハンドシェイクを完了するために、証明書を必要とする場合、それは警告致命的なcertificate_unobtainable（111）を送らなければなりません。サーバーが証明書を必要としない場合、サーバーはハンドシェイクを続けています。サーバーは、この場合には警告レベルのアラートを送るかもしれません。そのような警告を受けたクライアントは警告をログに記録し、可能な場合は握手を継続する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Trusted CA Indication",
      "section_title": true,
      "ja": "6.信頼できるCAの表示"
    },
    {
      "indent": 3,
      "text": "Constrained clients that, due to memory limitations, possess only a small number of CA root keys may wish to indicate to servers which root keys they possess, in order to avoid repeated handshake failures.",
      "ja": "メモリの制限のために、CAルート鍵のほんの数を所有し、制約付きのクライアントが繰り返さハンドシェイクの失敗を避けるために、彼らが持っているルートキーサーバに指示することを望むかもしれません。"
    },
    {
      "indent": 3,
      "text": "In order to indicate which CA root keys they possess, clients MAY include an extension of type \"trusted_ca_keys\" in the (extended) client hello. The \"extension_data\" field of this extension SHALL contain \"TrustedAuthorities\" where:",
      "ja": "彼らが持っているCAルート鍵を示すために、クライアントは（拡張）クライアントのhelloを入力し、「trusted_ca_keys」の拡張子を含むかもしれません。この拡張機能の「拡大」フィールドが「TrustedAuthorities」を含まなければなりません："
    },
    {
      "indent": 6,
      "text": "struct {\n    TrustedAuthority trusted_authorities_list<0..2^16-1>;\n} TrustedAuthorities;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct {\n    IdentifierType identifier_type;\n    select (identifier_type) {\n        case pre_agreed: struct {};\n        case key_sha1_hash: SHA1Hash;\n        case x509_name: DistinguishedName;\n        case cert_sha1_hash: SHA1Hash;\n    } identifier;\n} TrustedAuthority;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "enum {\n    pre_agreed(0), key_sha1_hash(1), x509_name(2),\n    cert_sha1_hash(3), (255)\n} IdentifierType;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "opaque DistinguishedName<1..2^16-1>;",
      "ja": "不透明な識別名<1..2 ^ 16-1>;"
    },
    {
      "indent": 3,
      "text": "Here, \"TrustedAuthorities\" provides a list of CA root key identifiers that the client possesses. Each CA root key is identified via either:",
      "ja": "ここで、「TrustedAuthoritiesは、」クライアントが保有するCAルート鍵識別子のリストを提供します。各CAのルートキーのいずれかを経由して識別されます。"
    },
    {
      "indent": 3,
      "text": "- \"pre_agreed\": no CA root key identity supplied.",
      "ja": " - 「pre_agreed」：なしCAルートキーIDが供給されていません。"
    },
    {
      "indent": 3,
      "text": "- \"key_sha1_hash\": contains the SHA-1 hash of the CA root key. For Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA) keys, this is the hash of the \"subjectPublicKey\" value. For RSA keys, the hash is of the big-endian byte string representation of the modulus without any initial zero-valued bytes. (This copies the key hash formats deployed in other environments.)",
      "ja": " -  \"key_sha1_hash\"：CAのルート鍵のSHA-1ハッシュが含まれています。デジタル署名アルゴリズム（DSA）と楕円曲線デジタル署名アルゴリズム（ECDSA）キーの場合、これは「のsubjectPublicKey」値のハッシュです。 RSA鍵の場合、ハッシュは、任意の初期ゼロ値のバイトをすることなく、弾性係数のビッグエンディアンバイトの文字列表現です。 （このコピーキーハッシュ形式は、他の環境で展開します。）"
    },
    {
      "indent": 3,
      "text": "- \"x509_name\": contains the DER-encoded X.509 DistinguishedName of the CA.",
      "ja": " - 「x509_nameは」：CAのDERでエンコードされたX.509識別名が含まれています"
    },
    {
      "indent": 3,
      "text": "- \"cert_sha1_hash\": contains the SHA-1 hash of a DER-encoded Certificate containing the CA root key.",
      "ja": " - 「cert_sha1_hash」：CAのルートキーを含むDERでエンコードされた証明書のSHA-1ハッシュが含まれています。"
    },
    {
      "indent": 3,
      "text": "Note that clients may include none, some, or all of the CA root keys they possess in this extension.",
      "ja": "クライアントはどれも、いくつか、または彼らは、この拡張に持っCAルート鍵の全てを含まなくてもよいことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note also that it is possible that a key hash or a Distinguished Name alone may not uniquely identify a certificate issuer (for example, if a particular CA has multiple key pairs). However, here we assume this is the case following the use of Distinguished Names to identify certificate issuers in TLS.",
      "ja": "（特定のCAが複数の鍵ペアを持っている場合など）単独キーハッシュまたは識別名が一意の証明書発行者を識別しない可能性があることにも留意されたいです。しかし、ここでは、これがTLSでの証明書発行者を識別するための識別名を使用する次のような場合であると仮定します。"
    },
    {
      "indent": 3,
      "text": "The option to include no CA root keys is included to allow the client to indicate possession of some pre-defined set of CA root keys.",
      "ja": "何のCAルート鍵を含まないためのオプションは、クライアントがCAルート鍵のいくつかの事前定義されたセットの所有権を示すことができるように含まれています。"
    },
    {
      "indent": 3,
      "text": "Servers that receive a client hello containing the \"trusted_ca_keys\" extension MAY use the information contained in the extension to guide their selection of an appropriate certificate chain to return to the client. In this event, the server SHALL include an extension of type \"trusted_ca_keys\" in the (extended) server hello. The \"extension_data\" field of this extension SHALL be empty.",
      "ja": "「trusted_ca_keys」拡張子を含むクライアントのhelloを受け取るサーバは、クライアントに返すために、適切な証明書チェーンの彼らの選択を導くために拡張に含まれる情報を使用することができます。この場合、サーバは、（拡張）サーバハローにおけるタイプ「trusted_ca_keys」の拡張子を含まなければなりません。この拡張機能の「拡大」フィールドが空にされなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Truncated HMAC",
      "section_title": true,
      "ja": "7.切り捨てHMAC"
    },
    {
      "indent": 3,
      "text": "Currently defined TLS cipher suites use the MAC construction HMAC [RFC2104] to authenticate record-layer communications. In TLS, the entire output of the hash function is used as the MAC tag. However, it may be desirable in constrained environments to save bandwidth by truncating the output of the hash function to 80 bits when forming MAC tags.",
      "ja": "現在、定義されたTLS暗号スイートは、記録層の通信を認証するためにMAC建設HMAC [RFC2104]を使用します。 TLSでは、ハッシュ関数の出力全体は、MACタグとして使用されます。しかし、MACタグを形成する際に80ビットのハッシュ関数の出力を切り捨てることによって帯域幅を節約するために制約のある環境に望ましいかもしれません。"
    },
    {
      "indent": 3,
      "text": "In order to negotiate the use of 80-bit truncated HMAC, clients MAY include an extension of type \"truncated_hmac\" in the extended client hello. The \"extension_data\" field of this extension SHALL be empty.",
      "ja": "80ビット切り捨てHMACの使用を交渉するためには、クライアントは、ハロー拡張クライアントタイプ「truncated_hmac」の拡張子を含むかもしれません。この拡張機能の「拡大」フィールドが空にされなければなりません。"
    },
    {
      "indent": 3,
      "text": "Servers that receive an extended hello containing a \"truncated_hmac\" extension MAY agree to use a truncated HMAC by including an extension of type \"truncated_hmac\", with empty \"extension_data\", in the extended server hello.",
      "ja": "「truncated_hmac」拡張を含む拡張こんにちはを受け取るサーバーはハロー拡張サーバーで、空の「拡大」で、「truncated_hmac」タイプの拡張子を含むことによって切り捨てHMACを使用することに同意することができます。"
    },
    {
      "indent": 3,
      "text": "Note that if new cipher suites are added that do not use HMAC, and the session negotiates one of these cipher suites, this extension will have no effect. It is strongly recommended that any new cipher suites using other MACs consider the MAC size an integral part of the cipher suite definition, taking into account both security and bandwidth considerations.",
      "ja": "新しい暗号スイートがHMACを使用していないが追加され、セッションはこれらの暗号スイートの1交渉する場合は、この拡張は効果がありませんので注意してください。他のMacを使用して、任意の新しい暗号スイートは、アカウントに両方のセキュリティと帯域幅の考慮を取って、MACサイズ暗号スイート定義の不可欠な部分を検討することを強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "If HMAC truncation has been successfully negotiated during a TLS handshake, and the negotiated cipher suite uses HMAC, both the client and the server pass this fact to the TLS record layer along with the other negotiated security parameters. Subsequently during the session, clients and servers MUST use truncated HMACs, calculated as specified in [RFC2104]. That is, SecurityParameters.mac_length is 10 bytes, and only the first 10 bytes of the HMAC output are transmitted and checked. Note that this extension does not affect the calculation of the pseudo-random function (PRF) as part of handshaking or key derivation.",
      "ja": "HMACの切り詰めが正常にTLSハンドシェイク中に交渉されてきた、と交渉した暗号スイートがHMACを使用する場合は、クライアントとサーバの両方が、他の交渉されたセキュリティパラメータと共にTLSレコード層にこの事実を渡します。その後、セッション中に、クライアントとサーバは、[RFC2104]で指定されているように計算切り捨てHMACsを、使用しなければなりません。すなわちSecurityParameters.mac_lengthが10バイトであり、HMAC出力の最初の10のバイトが送信され、チェックされます。この拡張は、ハンドシェイク又は鍵導出の一部として、擬似ランダム関数（PRF）の計算に影響を及ぼさないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The negotiated HMAC truncation size applies for the duration of the session including session resumptions.",
      "ja": "交渉さHMACの切り捨てサイズは、セッションコンテニューを含むセッションの間に適用されます。"
    },
    {
      "indent": 0,
      "text": "8. Certificate Status Request",
      "section_title": true,
      "ja": "8.証明書のステータス要求"
    },
    {
      "indent": 3,
      "text": "Constrained clients may wish to use a certificate-status protocol such as OCSP [RFC2560] to check the validity of server certificates, in order to avoid transmission of CRLs and therefore save bandwidth on constrained networks. This extension allows for such information to be sent in the TLS handshake, saving roundtrips and resources.",
      "ja": "制約付きのクライアントは、CRLの伝送を避けるため、制約ネットワーク上の帯域幅を節約するために、サーバ証明書の有効性を確認するために、このようなOCSP [RFC2560]として証明書ステータスプロトコルを使用することをお勧めします。この拡張は、往復とリソースを節約、TLSハンドシェイク中に送信されるような情報が可能になります。"
    },
    {
      "indent": 3,
      "text": "In order to indicate their desire to receive certificate status information, clients MAY include an extension of type \"status_request\" in the (extended) client hello. The \"extension_data\" field of this extension SHALL contain \"CertificateStatusRequest\" where:",
      "ja": "証明書のステータス情報を受信する意欲を示すために、クライアントはハロー（拡張）クライアントタイプ「status_request」の拡張子を含むかもしれません。この拡張機能の「拡大」フィールドが「CertificateStatusRequest」を含まなければなりません："
    },
    {
      "indent": 6,
      "text": "struct {\n    CertificateStatusType status_type;\n    select (status_type) {\n        case ocsp: OCSPStatusRequest;\n    } request;\n} CertificateStatusRequest;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "enum { ocsp(1), (255) } CertificateStatusType;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "struct {\n    ResponderID responder_id_list<0..2^16-1>;\n    Extensions  request_extensions;\n} OCSPStatusRequest;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "opaque ResponderID<1..2^16-1>;\nopaque Extensions<0..2^16-1>;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the OCSPStatusRequest, the \"ResponderIDs\" provides a list of OCSP responders that the client trusts. A zero-length \"responder_id_list\" sequence has the special meaning that the responders are implicitly known to the server, e.g., by prior arrangement. \"Extensions\" is a DER encoding of OCSP request extensions.",
      "ja": "OCSPStatusRequestでは、「ResponderIDsは、」OCSPレスポンダクライアントが信頼のリストを提供します。ゼロ長「responder_id_list」配列は、応答が暗黙的に事前配置することによって、例えば、サーバに知られていることを特別な意味を有しています。 「拡張機能」OCSPリクエストエクステンションのDERエンコーディングです。"
    },
    {
      "indent": 3,
      "text": "Both \"ResponderID\" and \"Extensions\" are DER-encoded ASN.1 types as defined in [RFC2560]. \"Extensions\" is imported from [RFC5280]. A zero-length \"request_extensions\" value means that there are no extensions (as opposed to a zero-length ASN.1 SEQUENCE, which is not valid for the \"Extensions\" type).",
      "ja": "「ResponderID」と「拡張」の両方は、[RFC2560]で定義されるようにDER符号化されたASN.1タイプです。 「機能拡張」は、[RFC5280]からインポートされます。ゼロ長「request_extensions」値（「拡張」型に対して有効でない長さゼロのASN.1配列とは対照的に）は拡張が存在しないことを意味します。"
    },
    {
      "indent": 3,
      "text": "In the case of the \"id-pkix-ocsp-nonce\" OCSP extension, [RFC2560] is unclear about its encoding; for clarification, the nonce MUST be a DER-encoded OCTET STRING, which is encapsulated as another OCTET STRING (note that implementations based on an existing OCSP client will need to be checked for conformance to this requirement).",
      "ja": "「ID-PKIX-OCSP-ノンス」OCSP拡張の場合には、[RFC2560]は、その符号化については不明です。明確化のために、nonceが別のOCTET STRINGとしてカプセル化されているDER符号化されたOCTET STRINGでなければならない（既存のOCSPクライアントに基づく実装はこの要件に適合するためにチェックする必要があることに注意）。"
    },
    {
      "indent": 3,
      "text": "Servers that receive a client hello containing the \"status_request\" extension MAY return a suitable certificate status response to the client along with their certificate. If OCSP is requested, they SHOULD use the information contained in the extension when selecting an OCSP responder and SHOULD include request_extensions in the OCSP request.",
      "ja": "「status_request」拡張子を含むクライアントのhelloを受け取るサーバはその証明書を使用してクライアントに適した証明書状態応答を一緒に返してもよいです。 OCSPが要求された場合は、OCSPレスポンダを選択する際の拡張に含まれている情報を使用すべきであるし、OCSP要求にrequest_extensionsを含むべきです。"
    },
    {
      "indent": 3,
      "text": "Servers return a certificate response along with their certificate by sending a \"CertificateStatus\" message immediately after the \"Certificate\" message (and before any \"ServerKeyExchange\" or \"CertificateRequest\" messages). If a server returns a \"CertificateStatus\" message, then the server MUST have included an extension of type \"status_request\" with empty \"extension_data\" in the extended server hello. The \"CertificateStatus\" message is conveyed using the handshake message type \"certificate_status\" as follows (see also Section 2):",
      "ja": "サーバーは、「証明書」のメッセージの直後に「CertificateStatus」メッセージを送信することにより、その証明書（および任意の「ServerKeyExchange」または「CertificateRequest」メッセージの前に）と一緒に証明書応答を返します。サーバが「CertificateStatus」メッセージを返した場合、サーバは、拡張サーバハロータイプの拡張空の「拡大」と「status_request」を含んでいなければなりません。次のように「CertificateStatus」メッセージ（セクション2を参照）ハンドシェークメッセージタイプ「certificate_status」を使用して搬送されます。"
    },
    {
      "indent": 6,
      "text": "struct {\n    CertificateStatusType status_type;\n    select (status_type) {\n        case ocsp: OCSPResponse;\n    } response;\n} CertificateStatus;",
      "raw": true
    },
    {
      "indent": 6,
      "text": "opaque OCSPResponse<1..2^24-1>;",
      "ja": "不透明OCSPResponse <1..2 ^ 24-1>;"
    },
    {
      "indent": 3,
      "text": "An \"ocsp_response\" contains a complete, DER-encoded OCSP response (using the ASN.1 type OCSPResponse defined in [RFC2560]). Only one OCSP response may be sent.",
      "ja": "「ocsp_response」は、完全な、DER符号化されたOCSP応答含有（[RFC2560]で定義されたASN.1型OCSPResponseを使用して）。唯一のOCSP応答を送信することができます。"
    },
    {
      "indent": 3,
      "text": "Note that a server MAY also choose not to send a \"CertificateStatus\" message, even if has received a \"status_request\" extension in the client hello message and has sent a \"status_request\" extension in the server hello message.",
      "ja": "サーバは、クライアントハローメッセージで「status_request」の拡張子を受けていると、サーバハローメッセージで「status_request」の拡張子を送信した場合でも、「CertificateStatus」メッセージを送信しないことを選択することができることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note in addition that a server MUST NOT send the \"CertificateStatus\" message unless it received a \"status_request\" extension in the client hello message and sent a \"status_request\" extension in the server hello message.",
      "ja": "それは、クライアントのhelloメッセージで「status_request」の拡張子を受け、サーバハローメッセージで「status_request」の拡張子を送らない限り、サーバは「CertificateStatus」メッセージを送ってはいけないことに加えて、注意してください。"
    },
    {
      "indent": 3,
      "text": "Clients requesting an OCSP response and receiving an OCSP response in a \"CertificateStatus\" message MUST check the OCSP response and abort the handshake if the response is not satisfactory with bad_certificate_status_response(113) alert. This alert is always fatal.",
      "ja": "OCSP応答を要求し、応答がbad_certificate_status_response（113）警報と満足のいくものではない場合はOCSP応答をチェックして、握手を中止しなければなりません「CertificateStatus」メッセージ中のOCSP応答を受信して​​いるクライアント。このアラートは常にfatalです。"
    },
    {
      "indent": 0,
      "text": "9. Error Alerts",
      "section_title": true,
      "ja": "9.エラーアラート"
    },
    {
      "indent": 3,
      "text": "Four new error alerts are defined for use with the TLS extensions defined in this document. To avoid \"breaking\" existing clients and servers, these alerts MUST NOT be sent unless the sending party has received an extended hello message from the party they are communicating with. These error alerts are conveyed using the following syntax. The new alerts are the last four, as indicated by the comments on the same line as the error alert number.",
      "ja": "四つの新しいエラーアラートがこの文書で定義されたTLS拡張で使用するために定義されています。送信側は、彼らが通信している相手からの拡張helloメッセージを受信した場合を除き、既存のクライアントとサーバを「破壊」を回避するには、これらのアラートを送ってはいけません。これらのエラーアラートは、次の構文を使用して搬送されます。エラーアラートの数と同じ行にコメントで示されるように、新たなアラートが、最後の4です。"
    },
    {
      "indent": 6,
      "text": "enum {\n    close_notify(0),\n    unexpected_message(10),\n    bad_record_mac(20),\n    decryption_failed(21),\n    record_overflow(22),\n    decompression_failure(30),\n    handshake_failure(40),\n    /* 41 is not defined, for historical reasons */\n    bad_certificate(42),\n    unsupported_certificate(43),\n    certificate_revoked(44),\n    certificate_expired(45),\n    certificate_unknown(46),\n    illegal_parameter(47),\n    unknown_ca(48),\n    access_denied(49),\n    decode_error(50),\n    decrypt_error(51),\n    export_restriction(60),\n    protocol_version(70),\n    insufficient_security(71), internal_error(80),\n    user_canceled(90),\n    no_renegotiation(100),\n    unsupported_extension(110),\n    certificate_unobtainable(111),        /* new */\n    unrecognized_name(112),               /* new */\n    bad_certificate_status_response(113), /* new */\n    bad_certificate_hash_value(114),      /* new */\n    (255)\n} AlertDescription;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "\"certificate_unobtainable\" is described in Section 5. \"unrecognized_name\" is described in Section 3. \"bad_certificate_status_response\" is described in Section 8. \"bad_certificate_hash_value\" is described in Section 5.",
      "ja": "「certificate_unobtainableは」5「unrecognized_nameが」3「bad_certificate_status_responseが」8「bad_certificate_hash_value」はセクション5で説明されているセクションに記載されているセクションに記載されているセクションに記載されています。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA Considerations for TLS extensions and the creation of a registry are covered in Section 12 of [RFC5246] except for the registration of MIME type application/pkix-pkipath, which appears below.",
      "ja": "TLS拡張機能や、レジストリを作成するためのIANAの考慮事項を以下に示しますMIMEタイプapplication / PKIX-pkipathの登録を除き、[RFC5246]のセクション12で覆われています。"
    },
    {
      "indent": 3,
      "text": "The IANA TLS extensions and MIME type application/pkix-pkipath registry entries that reference RFC 4366 have been updated to reference this document.",
      "ja": "RFC 4366を参照するIANA TLS拡張子とMIMEタイプのアプリケーション/ PKIX-pkipathのレジストリエントリは、この文書を参照するように更新されました。"
    },
    {
      "indent": 0,
      "text": "10.1. pkipath MIME Type Registration",
      "section_title": true,
      "ja": "10.1。 pkipath MIMEタイプ登録"
    },
    {
      "indent": 3,
      "text": "MIME media type name: application MIME subtype name: pkix-pkipath Required parameters: none",
      "ja": "MIMEメディアタイプ名：application MIMEサブタイプ名：PKIX-pkipath必須パラメーター：なし"
    },
    {
      "indent": 3,
      "text": "Optional parameters: version (default value is \"1\")",
      "ja": "オプションのパラメータ：バージョン（デフォルト値は「1」です）"
    },
    {
      "indent": 3,
      "text": "Encoding considerations:\n   Binary; this MIME type is a DER encoding of the ASN.1 type\n   PkiPath, defined as follows:\n     PkiPath ::= SEQUENCE OF Certificate\n     PkiPath is used to represent a certification path.  Within the\n     sequence, the order of certificates is such that the subject of\n     the first certificate is the issuer of the second certificate,\n     etc.\n   This is identical to the definition published in [X509-4th-TC1];\n   note that it is different from that in [X509-4th].",
      "raw": true
    },
    {
      "indent": 6,
      "text": "All Certificates MUST conform to [RFC5280]. (This should be interpreted as a requirement to encode only PKIX-conformant certificates using this type. It does not necessarily require that all certificates that are not strictly PKIX-conformant must be rejected by relying parties, although the security consequences of accepting any such certificates should be considered carefully.)",
      "ja": "すべての証明書は、[RFC5280]に従わなければなりません。 （これは、このタイプを使用してのみPKIX準拠の証明書をエンコードするための要件として解釈されるべきである。それは、必ずしも厳密PKIX-準拠していないすべての証明書はどのような証明書を受け入れるのセキュリティへの影響が、依拠当事者によって拒否されなければならないことを必要としません慎重に検討する必要があります。）"
    },
    {
      "indent": 6,
      "text": "DER (as opposed to BER) encoding MUST be used. If this type is sent over a 7-bit transport, base64 encoding SHOULD be used.",
      "ja": "DER（BERとは対照的に）符号化を使用しなければなりません。このタイプは、7ビットのトランスポートを介して送信される場合、base64エンコーディングを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Security considerations: The security considerations of [X509-4th] and [RFC5280] (or any updates to them) apply, as well as those of any protocol that uses this type (e.g., TLS).",
      "ja": "セキュリティの考慮事項：のセキュリティ上の考慮事項[X509-4th]と[RFC5280]（またはそれらの任意の更新）は、このタイプ（例えば、TLS）を使用する任意のプロトコルのものと同様に、適用します。"
    },
    {
      "indent": 6,
      "text": "Note that this type only specifies a certificate chain that can be assessed for validity according to the relying party's existing configuration of trusted CAs; it is not intended to be used to specify any change to that configuration.",
      "ja": "このタイプは、唯一の信頼できるCAの証明書利用者の既存の構成に応じて有効性について評価することができる証明書チェーンを指定することに注意してください。その構成に変更を指定するために使用されるものではありません。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: No specific interoperability problems are known with this type, but for recommendations relating to X.509 certificates in general, see [RFC5280].",
      "ja": "相互運用性に関する注意事項：いいえ、特定の相互運用性の問題は、このタイプで知られているが、一般的にX.509証明書に関する推奨事項については、[RFC5280]を参照しています。"
    },
    {
      "indent": 3,
      "text": "Published specification: This document and [RFC5280].",
      "ja": "公開された仕様：このドキュメントと[RFC5280]。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: TLS. It may also be used by other protocols or for general interchange of PKIX certificate chains.",
      "ja": "TLS：このメディアタイプを使用するアプリケーション。また、他のプロトコルにより又はPKIX証明書チェーンの一般的な交換のために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Additional information: Magic number(s): DER-encoded ASN.1 can be easily recognized. Further parsing is required to distinguish it from other ASN.1 types. File extension(s): .pkipath Macintosh File Type Code(s): not specified",
      "ja": "追加情報：マジックナンバー（S）：DER符号化されたASN.1を容易に認識することができます。さらに、解析は他のASN.1タイプと区別するために必要とされます。ファイルの拡張子（S）：.pkipath Macintoshファイルタイプコード（S）：指定されていません"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: Magnus Nystrom <mnystrom@microsoft.com>",
      "ja": "人とEメールアドレスは、詳細のために連絡する：マグナスNystrom <mnystrom@microsoft.com>"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図している用法：COMMON"
    },
    {
      "indent": 3,
      "text": "Change controller: IESG <iesg@ietf.org>",
      "ja": "変更コントローラ：IESG <iesg@ietf.org>"
    },
    {
      "indent": 0,
      "text": "10.2. Reference for TLS Alerts, TLS HandshakeTypes, and ExtensionTypes",
      "section_title": true,
      "ja": "10.2。 TLSアラート、TLS HandshakeTypes、およびExtensionTypesのためのリファレンス"
    },
    {
      "indent": 3,
      "text": "The following values in the TLS Alert Registry have been updated to reference this document:",
      "ja": "TLSアラートレジストリに次の値は、このドキュメントを参照するように更新されました："
    },
    {
      "indent": 6,
      "text": "111 certificate_unobtainable 112 unrecognized_name 113 bad_certificate_status_response 114 bad_certificate_hash_value",
      "ja": "111 certificate_unobtainable 112 unrecognized_name 113 bad_certificate_status_response 114 bad_certificate_hash_value"
    },
    {
      "indent": 3,
      "text": "The following values in the TLS HandshakeType Registry have been updated to reference this document:",
      "ja": "TLS HandshakeTypeレジストリに次の値は、このドキュメントを参照するように更新されました："
    },
    {
      "indent": 6,
      "text": "21 certificate_url 22 certificate_status",
      "ja": "21 certificate_url 22 certificate_status"
    },
    {
      "indent": 3,
      "text": "The following ExtensionType values have been updated to reference this document:",
      "ja": "以下ExtensionType値は、この文書を参照するように更新されました："
    },
    {
      "indent": 6,
      "text": "0 server_name 1 max_fragment_length 2 client_certificate_url 3 trusted_ca_keys 4 truncated_hmac 5 status_request",
      "ja": "0 SERVER_NAME 1 max_fragment_length 2 client_certificate_url 3 trusted_ca_keys 4 truncated_hmac 5 status_request"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "General security considerations for TLS extensions are covered in [RFC5246]. Security Considerations for particular extensions specified in this document are given below.",
      "ja": "TLS拡張のための一般的なセキュリティ上の考慮事項は、[RFC5246]でカバーされています。この文書で指定された特定の拡張子のセキュリティに関する注意点は以下の通りです。"
    },
    {
      "indent": 3,
      "text": "In general, implementers should continue to monitor the state of the art and address any weaknesses identified.",
      "ja": "一般的には、実装者は、芸術の状態を監視し、特定された弱点に対処し続けなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.1. Security Considerations for server_name",
      "section_title": true,
      "ja": "11.1。 server_nameのセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "If a single server hosts several domains, then clearly it is necessary for the owners of each domain to ensure that this satisfies their security needs. Apart from this, server_name does not appear to introduce significant security issues.",
      "ja": "単一のサーバが複数のドメインをホストする場合は、各ドメインの所有者が、これはそれぞれのセキュリティニーズを満たすことを確実にするためにのために、そして明確にそれが必要です。これとは別に、server_nameは重大なセキュリティ上の問題を紹介して表示されません。"
    },
    {
      "indent": 3,
      "text": "Since it is possible for a client to present a different server_name in the application protocol, application server implementations that rely upon these names being the same MUST check to make sure the client did not present a different name in the application protocol.",
      "ja": "クライアントは、アプリケーションプロトコルの異なるサーバー名を提示することが可能であるので、これらの名前が同じであることに依存しているアプリケーションサーバの実装は、クライアントがアプリケーションプロトコルに別の名前を提示しなかったことを確認するためにチェックしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST ensure that a buffer overflow does not occur, whatever the values of the length fields in server_name.",
      "ja": "実装は、サーバー名の長さフィールドのどの値が、バッファ・オーバーフローが発生しないことを保証しなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.2. Security Considerations for max_fragment_length",
      "section_title": true,
      "ja": "11.2。 max_fragment_lengthのセキュリティに関する注意点"
    },
    {
      "indent": 3,
      "text": "The maximum fragment length takes effect immediately, including for handshake messages. However, that does not introduce any security complications that are not already present in TLS, since TLS requires implementations to be able to handle fragmented handshake messages.",
      "ja": "最大フラグメント長は、ハンドシェイク・メッセージを含む、すぐに有効になります。 TLSは、断片化されたハンドシェイクメッセージを処理できるように実装を必要とするためしかし、それは、TLSには既に存在していない任意のセキュリティ合併症を導入していません。"
    },
    {
      "indent": 3,
      "text": "Note that, as described in Section 4, once a non-null cipher suite has been activated, the effective maximum fragment length depends on the cipher suite and compression method, as well as on the negotiated max_fragment_length. This must be taken into account when sizing buffers and checking for buffer overflow.",
      "ja": "非ヌル暗号スイートが起動された後、セクション4で説明したように、なお、有効な最大の断片の長さは、同様にネゴシエートmax_fragment_lengthに暗号スイートと圧縮方式に依存します。バッファのサイズを設定し、バッファオーバーフローをチェックするときにこれが考慮されなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.3. Security Considerations for client_certificate_url",
      "section_title": true,
      "ja": "11.3。 client_certificate_urlのセキュリティに関する注意点"
    },
    {
      "indent": 3,
      "text": "Support for client_certificate_url involves the server's acting as a client in another URI-scheme-dependent protocol. The server therefore becomes subject to many of the same security concerns that clients of the URI scheme are subject to, with the added concern that the client can attempt to prompt the server to connect to some (possibly weird-looking) URL.",
      "ja": "client_certificate_urlのサポートは別のURI-の方式に依存したプロトコルで、クライアントとしてサーバーの演技を必要とします。サーバーは、したがって、URIスキームのクライアントは、クライアントは、いくつかの（おそらく奇妙に見える）URLに接続するようにサーバーを促すために試みることができると付け加えた懸念で、対象としているのと同じセキュリティ上の懸念の多くの対象になります。"
    },
    {
      "indent": 3,
      "text": "In general, this issue means that an attacker might use the server to indirectly attack another host that is vulnerable to some security flaw. It also introduces the possibility of denial-of-service attacks in which an attacker makes many connections to the server, each of which results in the server's attempting a connection to the target of the attack.",
      "ja": "一般に、この問題は、攻撃者が間接的にいくつかのセキュリティ上の欠陥に対して脆弱である別のホストを攻撃するためにサーバーを使用する可能性があることを意味します。また、攻撃者は、攻撃のターゲットへのサーバの接続しようとし、その結果それぞれのサーバに多くの接続を行っているサービス拒否攻撃の可能性を紹介します。"
    },
    {
      "indent": 3,
      "text": "Note that the server may be behind a firewall or otherwise able to access hosts that would not be directly accessible from the public Internet. This could exacerbate the potential security and denial-of-service problems described above, as well as allow the existence of internal hosts to be confirmed when they would otherwise be hidden.",
      "ja": "サーバーがパブリックインターネットから直接アクセスではないでしょうホストにアクセスできるようにファイアウォールまたはその他の背後にあってもよいことに注意してください。これは、上述の潜在的なセキュリティおよびサービス拒否問題を悪化させるだけでなく、彼らはそれ以外の場合は非表示にするだろうというとき、内部ホストの存在が確認される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The detailed security concerns involved will depend on the URI schemes supported by the server. In the case of HTTP, the concerns are similar to those that apply to a publicly accessible HTTP proxy server. In the case of HTTPS, loops and deadlocks may be created, and this should be addressed. In the case of FTP, attacks arise that are similar to FTP bounce attacks.",
      "ja": "関連する詳細なセキュリティ上の問題は、サーバーでサポートされているURIスキームに依存します。 HTTPの場合、懸念が公的にアクセス可能なHTTPプロキシサーバに適用されるものと同様です。 HTTPSの場合、ループおよびデッドロックが作成されることがあり、これに対処しなければなりません。 FTPの場合、攻撃はFTPバウンス攻撃に類似していることが生じます。"
    },
    {
      "indent": 3,
      "text": "As a result of this issue, it is RECOMMENDED that the client_certificate_url extension should have to be specifically enabled by a server administrator, rather than be enabled by default. It is also RECOMMENDED that URI schemes be enabled by the administrator individually, and only a minimal set of schemes be enabled. Unusual protocols that offer limited security or whose security is not well understood SHOULD be avoided.",
      "ja": "この問題の結果として、client_certificate_url拡張子は特にサーバー管理者によって有効にする必要があります、というよりも、デフォルトで有効にすることを推奨します。また、URIスキームを個別に管理者が有効にされ、スキームの唯一の最小セットを有効にすることを推奨します。またはセキュリティ十分に理解されていない回避するべきである限定されたセキュリティを提供します異常なプロトコル。"
    },
    {
      "indent": 3,
      "text": "As discussed in [RFC3986], URLs that specify ports other than the default may cause problems, as may very long URLs (which are more likely to be useful in exploiting buffer overflow bugs).",
      "ja": "[RFC3986]で説明したように（バッファオーバーフローのバグを利用するのに有用である可能性が高い）非常に長いURLを得るように、デフォルト以外のポートを指定するURLは、問題を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "This extension continues to use SHA-1 (as in RFC 4366) and does not provide algorithm agility. The property required of SHA-1 in this case is second pre-image resistance, not collision resistance. Furthermore, even if second pre-image attacks against SHA-1 are found in the future, an attack against client_certificate_url would require a second pre-image that is accepted as a valid certificate by the server and contains the same public key.",
      "ja": "この拡張は、（RFC 4366のように）SHA-1を使用し続けると、アルゴリズムの俊敏性を提供しません。この場合にはSHA-1の必要性は、第二のプリイメージ耐性ではなく、衝突耐性です。さらに、SHA-1に対する第2プリイメージ攻撃は、将来的に発見された場合でも、client_certificate_urlに対する攻撃は、サーバによって有効な証明書として受け入れと同じ公開鍵を含んでいる第2プリ画像が必要となります。"
    },
    {
      "indent": 3,
      "text": "Also note that HTTP caching proxies are common on the Internet, and some proxies do not check for the latest version of an object correctly. If a request using HTTP (or another caching protocol) goes through a misconfigured or otherwise broken proxy, the proxy may return an out-of-date response.",
      "ja": "また、HTTPキャッシングプロキシは、インターネット上で共通していることに注意してください、といくつかのプロキシは正しくオブジェクトの最新バージョンをチェックしません。 HTTP（または他のキャッシュプロトコル）を使用して要求が誤って設定または他の方法で破損プロキシを通過する場合、プロキシは、期限切れの応答を返すことができます。"
    },
    {
      "indent": 0,
      "text": "11.4. Security Considerations for trusted_ca_keys",
      "section_title": true,
      "ja": "11.4。 trusted_ca_keysのセキュリティに関する注意点"
    },
    {
      "indent": 3,
      "text": "Potentially, the CA root keys a client possesses could be regarded as confidential information. As a result, the CA root key indication extension should be used with care.",
      "ja": "潜在的に、クライアントが所有しているCAルート鍵は、機密情報とみなすことができます。その結果、CAルートキー表示の拡張子は注意して使用してください。"
    },
    {
      "indent": 3,
      "text": "The use of the SHA-1 certificate hash alternative ensures that each certificate is specified unambiguously. This context does not require a cryptographic hash function, so the use of SHA-1 is considered acceptable, and no algorithm agility is provided.",
      "ja": "SHA-1証明書ハッシュ代替の使用は、各証明書が明確に指定されることを保証します。 SHA-1の使用が許容されるとみなされ、いかなるアルゴリズムアジリティが設けられていないので、この文脈では、暗号ハッシュ関数を必要としません。"
    },
    {
      "indent": 0,
      "text": "11.5. Security Considerations for truncated_hmac",
      "section_title": true,
      "ja": "11.5。 truncated_hmacのセキュリティに関する注意点"
    },
    {
      "indent": 3,
      "text": "It is possible that truncated MACs are weaker than \"un-truncated\" MACs. However, no significant weaknesses are currently known or expected to exist for HMAC with MD5 or SHA-1, truncated to 80 bits.",
      "ja": "切り捨てMACは「非切り捨て」のMACよりも弱いことも可能です。しかし、有意な弱点は、現在知られていないか、MD5またはSHA-1、80ビットに切り捨てとHMACのために存在すると予想されます。"
    },
    {
      "indent": 3,
      "text": "Note that the output length of a MAC need not be as long as the length of a symmetric cipher key, since forging of MAC values cannot be done off-line: in TLS, a single failed MAC guess will cause the immediate termination of the TLS session.",
      "ja": "単一障害が発生したMACは、TLSの即時停止を引き起こします、TLSに推測：MAC値の鍛造がオフラインで行うことができないので、MACの出力長は、対称暗号鍵の長さが限りである必要はないことに注意してくださいセッション。"
    },
    {
      "indent": 3,
      "text": "Since the MAC algorithm only takes effect after all handshake messages that affect extension parameters have been authenticated by the hashes in the Finished messages, it is not possible for an active attacker to force negotiation of the truncated HMAC extension where it would not otherwise be used (to the extent that the handshake authentication is secure). Therefore, in the event that any security problems were found with truncated HMAC in the future, if either the client or the server for a given session were updated to take the problem into account, it would be able to veto use of this extension.",
      "ja": "MACアルゴリズムは唯一の拡張パラメータがFinishedメッセージでハッシュによって認証されている影響を与えるすべてのハンドシェイクメッセージの後に有効になりますので、アクティブな攻撃者は、それがそうでなければ使用できません切り捨てHMAC延長の交渉を強制するために、それは（可能ではありません程度のハンドシェイク認証）が安全であること。クライアントまたは特定のセッションのためのサーバーのいずれかのアカウントに問題を取るために更新された場合そのため、どのようなセキュリティ上の問題は、将来的に切り捨てHMACで発見されたことをイベントでは、この拡張機能の使用を拒否することができるだろう。"
    },
    {
      "indent": 0,
      "text": "11.6. Security Considerations for status_request",
      "section_title": true,
      "ja": "11.6。 status_requestのセキュリティに関する注意点"
    },
    {
      "indent": 3,
      "text": "If a client requests an OCSP response, it must take into account that an attacker's server using a compromised key could (and probably would) pretend not to support the extension. In this case, a client that requires OCSP validation of certificates SHOULD either contact the OCSP server directly or abort the handshake.",
      "ja": "クライアントは、OCSP応答を要求した場合、それは攻撃者のサーバが（そしておそらくでしょう）拡張をサポートしないふり妥協キーを使用していることを考慮に入れる必要があります。この場合、証明書のOCSP検証を必要とするクライアントは、直接OCSPサーバーに連絡するか、握手を中止すべきであるのいずれか。"
    },
    {
      "indent": 3,
      "text": "Use of the OCSP nonce request extension (id-pkix-ocsp-nonce) may improve security against attacks that attempt to replay OCSP responses; see Section 4.4.1 of [RFC2560] for further details.",
      "ja": "OCSPナンス要求拡張（ID-PKIX-OCSP-ナンス）の使用は、OCSP応答を再生しようとする攻撃に対するセキュリティを向上させること。詳細については、[RFC2560]のセクション4.4.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "12. Normative References",
      "section_title": true,
      "ja": "12.引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2560] Myers, M., Ankney, R., Malpani, A., Galperin, S., and C. Adams, \"X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP\", RFC 2560, June 1999.",
      "ja": "[RFC2560]マイヤーズ、M.、Ankney、R.、Malpani、A.、Galperin、S.、およびC.アダムス、 \"X.509のインターネット公開鍵暗号基盤のオンライン証明書状態プロトコル -  OCSP\"、RFC 2560、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2585] Housley, R. and P. Hoffman, \"Internet X.509 Public Key Infrastructure Operational Protocols: FTP and HTTP\", RFC 2585, May 1999.",
      "ja": "[RFC2585] Housley氏、R.とP.ホフマン、 \"インターネットX.509公開鍵基盤運用プロトコル：FTPやHTTP\"、RFC 2585、1999年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5890] Klensin, J., \"Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework\", RFC 5890, August 2010.",
      "ja": "[RFC5890] Klensin、J.、 \"アプリケーション（IDNA）のための国際化ドメイン名：定義とドキュメントフレームワーク\"、RFC 5890、2010年8月。"
    },
    {
      "indent": 0,
      "text": "13. Informative References",
      "section_title": true,
      "ja": "13.参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC2712] Medvinsky, A. and M. Hur, \"Addition of Kerberos Cipher Suites to Transport Layer Security (TLS)\", RFC 2712, October 1999.",
      "ja": "[RFC2712] Medvinsky、A.とM.ハー、RFC 2712、1999年10月 \"Layer Security（TLS）を輸送するためのケルベロス暗号スイートの追加\"。"
    },
    {
      "indent": 3,
      "text": "[X509-4th] ITU-T Recommendation X.509 (2000) | ISO/IEC 9594-8:2001, \"Information Systems - Open Systems Interconnection - The Directory: Public key and attribute certificate frameworks\".",
      "ja": "[X509-4th] ITU-T勧告X.509（2000）| ISO / IEC 9594から8：2001、「情報システム - オープンシステムインターコネクション - ディレクトリ：公開鍵と属性証明書の枠組み」。"
    },
    {
      "indent": 3,
      "text": "[X509-4th-TC1] ITU-T Recommendation X.509(2000) Corrigendum 1(2001) | ISO/IEC 9594-8:2001/Cor.1:2002, Technical Corrigendum 1 to ISO/IEC 9594:8:2001.",
      "ja": "[X509-4th-TC1] ITU-T勧告X.509（2000）追補1（2001）| ISO / IEC 9594から8：2001 / Cor.1、2002年、技術的な改正1 ISO / IEC 9594：8、2001。"
    },
    {
      "indent": 1,
      "text": "Appendix A. Changes from",
      "ja": "付録A.からの変更点"
    },
    {
      "indent": 3,
      "text": "The significant changes between RFC 4366 and this document are described below.",
      "ja": "RFC 4366と本書の間に有意な変化は、以下に説明されています。"
    },
    {
      "indent": 3,
      "text": "RFC 4366 described both general extension mechanisms (for the TLS handshake and client and server hellos) as well as specific extensions. RFC 4366 was associated with RFC 4346, TLS 1.1. The client and server hello extension mechanisms have been moved into RFC 5246, TLS 1.2, so this document, which is associated with RFC 5246, includes only the handshake extension mechanisms and the specific extensions from RFC 4366. RFC 5246 also specifies the unknown extension error and new extension specification considerations, so that material has been removed from this document.",
      "ja": "RFC 4366は、同様に特定の拡張（TLSハンドシェイクと、クライアントとサーバのhelloのため）の両方の一般的な拡張メカニズムを説明しました。 RFC 4366は、RFC 4346、TLS 1.1に関連していました。クライアントとサーバハロー拡張メカニズムは、TLS 1.2、RFC 5246に移動されましたので、RFC 5246に関連付けられているこの文書では、唯一のハンドシェイクの拡張メカニズムおよびRFC 4366. RFC 5246から特定の拡張子が含まれても、未知の拡張エラーを指定しますそして新しい拡張仕様の検討事項は、そのため材料は、この文書から削除されました。"
    },
    {
      "indent": 3,
      "text": "The Server Name extension now specifies only ASCII representation, eliminating UTF-8. It is provided that the ServerNameList can contain more than only one name of any particular name_type. If a server name is provided but not recognized, the server should either continue the handshake without an error or send a fatal error. Sending a warning-level message is not recommended because client behavior will be unpredictable. Provision was added for the user using the server_name extension in deciding whether or not to resume a session. Furthermore, this extension should be the same in a session resumption request as it was in the full handshake that established the session. Such a resumption request must not be accepted if the server_name extension is different, but instead a full handshake must be done to possibly establish a new session.",
      "ja": "サーバ名の拡張子は現在、UTF-8を排除し、唯一のASCII表現を指定します。 ServerNameListは、任意の特定のname_typeの唯一の名前以上のものを含むことができるとされています。サーバー名が提供したが認識されない場合は、サーバがエラーなしで握手を続けるか、致命的なエラーを送信する必要がありますどちらか。クライアントの動作が予測不能になりますので、警告レベルのメッセージを送信することは推奨されません。提供は、セッションを再開するかどうかを決定する際にサーバー名の拡張子を使用して、ユーザーのために追加されました。それは、セッションを確立し、完全なハンドシェイクであったようにさらに、この拡張は、セッション再開要求で同じにする必要があります。サーバー名拡張子が異なっているが、代わりに完全なハンドシェイクはおそらく新しいセッションを確立するために行われなければならない場合、このような再開要求を受け入れてはいけません。"
    },
    {
      "indent": 3,
      "text": "The Client Certificate URLs extension has been changed to make the presence of a hash mandatory.",
      "ja": "クライアント証明書のURLの拡張子は必須ハッシュの存在を作るために変更されました。"
    },
    {
      "indent": 3,
      "text": "For the case of DTLS, the requirement to report an overflow of the negotiated maximum fragment length is made conditional on passing authentication.",
      "ja": "DTLSの場合について、ネゴシエート最大フラグメント長のオーバーフローを報告するための要件は、認証を通過したことを条件なります。"
    },
    {
      "indent": 3,
      "text": "TLS servers are now prohibited from following HTTP redirects when retrieving certificates.",
      "ja": "TLSサーバは、現在の証明書を取得する際にHTTPリダイレクトを次の中から禁止されています。"
    },
    {
      "indent": 3,
      "text": "The material was also re-organized in minor ways. For example, information as to which errors are fatal is moved from the \"Error Alerts\" section to the individual extension specifications.",
      "ja": "材料はまたマイナーな方法で再編成されました。たとえば、エラーは致命的であるとの情報は、個々の拡張仕様「エラーアラート」セクションから移動されます。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Acknowledgements",
      "ja": "付録B.謝辞"
    },
    {
      "indent": 3,
      "text": "This document is based on material from RFC 4366 for which the authors were S. Blake-Wilson, M. Nystrom, D. Hopwood, J. Mikkelsen, and T. Wright. Other contributors include Joseph Salowey, Alexey Melnikov, Peter Saint-Andre, and Adrian Farrel.",
      "ja": "この文書は、作者がS.ブレーク - ウィルソン、M. Nystrom、D.ホップウッド、J.ミケルセン、およびT.ライトたれるRFC 4366からの材料に基づいています。その他の貢献者はジョセフSalowey、アレクセイ・メルニコフ、ピーター・サン・アンドレ、およびエードリアンファレルが含まれます。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Donald Eastlake 3rd Huawei 155 Beaver Street Milford, MA 01757 USA",
      "ja": "ドナルドイーストレイク第三華為155ビーバー通りミルフォード、MA 01757 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1-508-333-2270 EMail: d3e3e3@gmail.com",
      "ja": "電話：+ 1-508-333-2270 Eメール：d3e3e3@gmail.com"
    }
  ]
}