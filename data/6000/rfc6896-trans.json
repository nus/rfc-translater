{
  "title": {
    "text": "RFC 6896 - SCS: KoanLogic's Secure Cookie Sessions for HTTP",
    "ja": "RFC 6896 - SCS：HTTP用KoanLogicのセキュアなクッキーセッション"
  },
  "number": 6896,
  "created_at": "2019-11-01 08:25:03.905007+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                        S. Barbato\nRequest for Comments: 6896                                  S. Dorigotti\nCategory: Informational                                  T. Fossati, Ed.\nISSN: 2070-1721                                                KoanLogic\n                                                              March 2013",
      "raw": true
    },
    {
      "indent": 12,
      "text": "SCS: KoanLogic's Secure Cookie Sessions for HTTP",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo defines a generic URI and HTTP-header-friendly envelope for carrying symmetrically encrypted, authenticated, and origin-timestamped tokens. It also describes one possible usage of such tokens via a simple protocol based on HTTP cookies.",
      "ja": "このメモは対称的に、暗号化、認証、および原点タイムスタンプトークンを運ぶための汎用的なURIとHTTPヘッダに優しいエンベロープを定義します。また、HTTPクッキーに基づく単純なプロトコルを経由して、このようなトークンの一つの可能​​な使用法を説明します。"
    },
    {
      "indent": 3,
      "text": "Secure Cookie Session (SCS) use cases cover a wide spectrum of applications, ranging from distribution of authorized content via HTTP (e.g., with out-of-band signed URIs) to securing browser sessions with diskless embedded devices (e.g., Small Office, Home Office (SOHO) routers) or web servers with high availability or load-balancing requirements that may want to delegate the handling of the application state to clients instead of using shared storage or forced peering.",
      "ja": "クッキーセッション（SCS）は例を使用してセキュアディスクレス組み込みデバイス（例えば、スモールオフィス、ホームでのブラウザセッションを確保する（アウト・オブ・バンドでURIを締結し、例えば）HTTP経由で許可されたコンテンツの配信に至るまで、アプリケーションの広いスペクトルをカバー高可用性または代わりに、共有ストレージまたは強制ピアリングを使用してのクライアントにアプリケーションの状態の取り扱いを委任することもできますロードバランシングの要件を持つオフィス（SOHO）ルータ）またはウェブサーバ。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "これは、独立して、他のRFCストリームの、RFCシリーズへの貢献です。 RFC Editorはその裁量でこの文書を公開することを選択し、実装や展開のためにその値についての声明を出すていません。 RFC編集者によって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6896.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6896で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n2. Requirements Language ...........................................4\n3. SCS Protocol ....................................................5\n   3.1. SCS Cookie Description .....................................5\n        3.1.1. ATIME ...............................................6\n        3.1.2. DATA ................................................6\n        3.1.3. TID .................................................7\n        3.1.4. IV ..................................................7\n        3.1.5. AUTHTAG .............................................7\n   3.2. Crypto Transform ...........................................8\n        3.2.1. Choice and Role of the Framing Symbol ...............8\n        3.2.2. Cipher Set ..........................................9\n        3.2.3. Compression .........................................9\n        3.2.4. Cookie Encoding .....................................9\n        3.2.5. Outbound Transform ..................................9\n        3.2.6. Inbound Transform ..................................10\n   3.3. PDU Exchange ..............................................12\n        3.3.1. Cookie Attributes ..................................12\n               3.3.1.1. Expires ...................................12\n               3.3.1.2. Max-Age ...................................12\n               3.3.1.3. Domain ....................................13\n               3.3.1.4. Secure ....................................13\n               3.3.1.5. HttpOnly ..................................13\n4. Key Management and Session State ...............................13\n5. Cookie Size Considerations .....................................15\n6. Acknowledgements ...............................................15\n7. Security Considerations ........................................15\n   7.1. Security of the Cryptographic Protocol ....................15\n   7.2. Impact of the SCS Cookie Model ............................16\n        7.2.1. Old Cookie Replay ..................................16\n        7.2.2. Cookie Deletion ....................................17\n        7.2.3. Cookie Sharing or Theft ............................18\n        7.2.4. Session Fixation ...................................18\n   7.3. Advantages of SCS over Server-Side Sessions ...............19\n8. References .....................................................20\n   8.1. Normative References ......................................20\n   8.2. Informative References ....................................20\nAppendix A. Examples ..............................................22\n   A.1. No Compression ............................................22\n   A.2. Use Compression ...........................................22",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This memo defines a generic URI and HTTP-header-friendly envelope for carrying symmetrically encrypted, authenticated, and origin-timestamped tokens.",
      "ja": "このメモは対称的に、暗号化、認証、および原点タイムスタンプトークンを運ぶための汎用的なURIとHTTPヘッダに優しいエンベロープを定義します。"
    },
    {
      "indent": 3,
      "text": "It is generic in that it does not force any specific format upon the authenticated information, which makes SCS tokens flexible, easy, and secure to use in many different scenarios.",
      "ja": "それはSCSは、多くの異なるシナリオで使用するために、柔軟に簡単、かつ安全なトークンになり、認証された情報、時に特定のフォーマットを強制しないことで汎用的です。"
    },
    {
      "indent": 3,
      "text": "It is URI and HTTP header friendly, as it has been explicitly designed to be compatible with both the ABNF \"token\" syntax [RFC2616] (the one used for, e.g., Set-Cookie and Cookie headers) and the path or query syntax of HTTP URIs.",
      "ja": "明示的ABNF「トークン」構文[RFC2616]（のために使用されるもの、例えば、セット - クッキーおよびクッキーヘッダ）とのパスまたはクエリ構文の両方に適合するように設計されているように、それは、URIやHTTPヘッダに優しいですHTTPのURI。"
    },
    {
      "indent": 3,
      "text": "This memo also describes one possible usage of such tokens via a simple protocol based on HTTP cookies that allows the establishment of \"client mode\" sessions. This is not their sole possible use. While no other operational patterns are outlined here, it is expected that SCS tokens may be easily employed as a building block for other types of HTTP-based applications that need to carry in-band secured information.",
      "ja": "また、このメモは、「クライアントモード」セッションの確立を可能にするHTTPクッキーに基づく単純なプロトコルを経由して、このようなトークンの一つの可能​​な使用法を説明します。これは彼らの唯一の可能な用途ではありません。他の動作パターンはここで説明されていないが、SCSトークンを容易にバンド保護された情報を運ぶために必要HTTPベースのアプリケーションの他のタイプのビルディングブロックとして使用されてもよいことが予想されます。"
    },
    {
      "indent": 3,
      "text": "When SCS tokens are used to implement client-mode cookie sessions, the SCS implementer must fully understand the security implications entailed by the act of delegating the whole application state to the client (browser). In this regard, some hopefully useful security considerations have been collected in Section 7.2. However, please note that they may not cover all possible scenarios; therefore, they must be weighed carefully against the specific application threat model.",
      "ja": "SCSトークンはクライアントモードのクッキーセッションを実装するために使用されている場合は、SCSの実装は完全にクライアント（ブラウザ）にアプリケーション全体の状態を委任行為にともなうセキュリティへの影響を理解する必要があります。この点で、いくつかうまくいけば便利なセキュリティ上の考慮事項は、7.2節で収集されています。しかし、彼らはすべての可能なシナリオをカバーしていない場合がありますのでご注意ください。そのため、彼らは、特定のアプリケーションの脅威モデルに対して慎重に検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "An SCS server may be implemented within a web application by means of a user library that exposes the core SCS functionality and leaves explicit control over SCS tokens to the programmer, or transparently, by hiding a \"diskless session\" facility behind a generic session API abstraction, for example. SCS implementers are free to choose the model that best suits their needs.",
      "ja": "SCSサーバーは、一般的なセッションAPIの抽象化の後ろに「ディスクレスセッション」機能を非表示にすることにより、透過的にコアSCSの機能を公開し、プログラマにSCSトークンを明示的に制御を残し、またはユーザーのライブラリーを用いて、Webアプリケーション内に実装することができます、 例えば。 SCSの実装は、最高の自分のニーズに合ったモデルを自由に選択できます。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Language",
      "section_title": true,
      "ja": "2.必要な言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. SCS Protocol",
      "section_title": true,
      "ja": "3. SCSプロトコル"
    },
    {
      "indent": 3,
      "text": "The SCS protocol defines:",
      "ja": "SCSプロトコルが定義されています。"
    },
    {
      "indent": 3,
      "text": "o the SCS cookie structure and encoding (Section 3.1);",
      "ja": "SCSクッキー構造および符号化（セクション3.1）O。"
    },
    {
      "indent": 3,
      "text": "o the cryptographic transformations involved in SCS cookie creation and verification (Section 3.2);",
      "ja": "SCSクッキーの作成と検証（3.2節）に関与した暗号変換O;"
    },
    {
      "indent": 3,
      "text": "o the HTTP-based PDU exchange that uses the Set-Cookie and Cookie HTTP headers (Section 3.3);",
      "ja": "OのSet-CookieおよびクッキーHTTPヘッダを使用してHTTPベースのPDU交換（3.3節）。"
    },
    {
      "indent": 3,
      "text": "o the underlying key management model (Section 4).",
      "ja": "基本的な鍵管理モデル（第4節）、O。"
    },
    {
      "indent": 3,
      "text": "Note that the PDU is transmitted to the client as an opaque data block; hence, no interpretation nor validation is necessary. The single requirement for client-side support of SCS is cookie activation on the user agent. The origin server is the sole actor involved in the PDU manipulation process, which greatly simplifies the crypto operations -- especially key management, which is usually a pesky task.",
      "ja": "PDUは、不透明なデータブロックとしてクライアントに送信されることに留意されたいです。したがって、何の解釈も検証は必要ありません。 SCSのクライアント側のサポートのための単一の要件は、ユーザーエージェントのクッキーの活性化です。特に鍵管理、通常は厄介な作業です - オリジンサーバが大幅に暗号化の操作を簡素化PDU操作プロセスに関与する唯一の俳優、です。"
    },
    {
      "indent": 3,
      "text": "In the following sections, we assume S to be one or more interchangeable HTTP server entities (e.g., a server pool in a load-balanced or high-availability environment) and C to be the client with a cookie-enabled browser or any user agent with equivalent capabilities.",
      "ja": "次のセクションでは、我々はクッキー対応のブラウザを使用して、クライアントまたは任意のユーザエージェントであることをSは、1つまたは複数の交換可能なHTTPサーバエンティティ（例えば、ロードバランスや高可用性環境でのサーバー・プール）であることを前提とし、C同等の機能を持ちます。"
    },
    {
      "indent": 0,
      "text": "3.1. SCS Cookie Description",
      "section_title": true,
      "ja": "3.1.  SCSクッキー説明"
    },
    {
      "indent": 3,
      "text": "S and C exchange a cookie (Section 3.3) whose cookie value consists of a sequence of adjacent non-empty values, each of which is the 'URL and Filename safe' Base64 encoding [RFC4648] of a specific SCS field.",
      "ja": "S及びC交換そのクッキー値SCS特定フィールドの「URLとファイル名安全」Base64エンコーディング[RFC4648]は、それぞれが隣接する非空の値のシーケンスからなるクッキー（3.3節）。"
    },
    {
      "indent": 3,
      "text": "(Hereafter, the encoded and raw versions of each SCS field are distinguished based on the presence, or lack thereof, of the 'e' prefix in their name, e.g., eATIME and ATIME.)",
      "ja": "（例えば、eATIMEとATIME、以下、各SCSフィールドの符号化および生バージョンは区別存在に基づいている、またはその名前に「E」の接頭辞のその欠如）。"
    },
    {
      "indent": 3,
      "text": "Each SCS field is separated by its left and/or right sibling by means of the %x7c ASCII character (i.e., '|'), as follows: scs-cookie = scs-cookie-name \"=\" scs-cookie-value scs-cookie-name = token scs-cookie-value = eDATA \"|\" eATIME \"|\" eTID \"|\" eIV \"|\" eAUTHTAG eDATA = 1*base64url-character eATIME = 1*base64url-character eTID = 1*base64url-character eIV = 1*base64url-character eAUTHTAG = 1*base64url-character",
      "ja": "各SCSフィールドは、％x7cのASCII文字によってその左および/または右の兄弟によって分離されている（すなわち、「|」）、次のように：SCS-クッキー= SCS-クッキー名「=」SCS-クッキー値SCSを-cookie名= SCS-クッキー値をトークン= EDATA \"|\" eATIME \"|\" ETID \"|\" EIV \"|\" eAUTHTAG EDATA = 1 * base64url文字eATIME = 1 * base64url文字ETID = 1 * base64url文字EIV = 1 * base64url文字eAUTHTAG = 1 * base64url文字"
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "Confidentiality is limited to the application-state information (i.e., the DATA field), while integrity and authentication apply to the entire cookie value.",
      "ja": "整合性と認証全体クッキー値に適用しながら、機密性は、アプリケーション状態情報（すなわち、データフィールド）に限られています。"
    },
    {
      "indent": 3,
      "text": "The following subsections describe the syntax and semantics of each SCS cookie field.",
      "ja": "以下のサブセクションでは、各SCSクッキーフィールドの構文と意味を説明します。"
    },
    {
      "indent": 0,
      "text": "3.1.1. ATIME",
      "section_title": true,
      "ja": "3.1.1. 時間"
    },
    {
      "indent": 3,
      "text": "Absolute timestamp relating to the last read or write operation performed on session DATA, encoded as a HEX string holding the number of seconds since the UNIX epoch (i.e., since 00:00:00, Jan 1 1970).",
      "ja": "UNIXエポックからの秒数を保持する16進文字列として符号化セッションデータに対して実行された最後の読み出しまたは書き込み動作に関連する絶対タイムスタンプ、（すなわち、00:00:00から、1970年1月1日）。"
    },
    {
      "indent": 3,
      "text": "This value is updated with each client contact and is used to identify expired sessions. If the delta between the received ATIME value and the current time on S is larger than a predefined \"session_max_age\" (which is chosen by S as an application-level parameter), a session is considered to be no longer valid, and is therefore rejected.",
      "ja": "この値は、各クライアントの連絡先で更新され、期限切れのセッションを識別するために使用されます。受信ATIME値とSの現在の時刻との間のデルタは、（アプリケーションレベルのパラメータとしてSによって選択される）事前定義された「session_max_age」よりも大きい場合、セッションはもはや有効でないと考えられるので、拒否され。"
    },
    {
      "indent": 3,
      "text": "Such an expiration error may be used to force user logout from an SCS-cookie-based session, or hooked in the web application logic to display an HTML form requiring revalidation of user credentials.",
      "ja": "そのような有効期限エラーがSCS-クッキーベースのセッションからユーザのログアウトを強制するために使用される、またはユーザーの資格情報の再検証を必要とするHTMLフォームを表示するWebアプリケーションロジックに引っ掛けることができます。"
    },
    {
      "indent": 0,
      "text": "3.1.2. DATA",
      "section_title": true,
      "ja": "3.1.2. データ"
    },
    {
      "indent": 3,
      "text": "Block of encrypted and optionally compressed data, possibly containing the current session state. Note that no restriction is imposed on the cleartext structure: the protocol is completely agnostic as to inner data layout.",
      "ja": "暗号化および必要に応じて圧縮データのブロック、おそらくは現在のセッション状態を含みます。制限は平文構造に課されていないことに注意：プロトコルは内部データ・レイアウトと全くとらわれません。"
    },
    {
      "indent": 3,
      "text": "Generally speaking, the plaintext is the \"normal\" cookie that would have been exchanged by S and C if SCS had not been used.",
      "ja": "一般的に言えば、平文はSCSが使用されていない場合はSとCによって交換されていたであろう「普通」のクッキーです。"
    },
    {
      "indent": 0,
      "text": "3.1.3. TID",
      "section_title": true,
      "ja": "3.1.3.  TIME"
    },
    {
      "indent": 3,
      "text": "This identifier is equivalent to a Security Parameter Index (SPI) in a Data Security SA [RFC3740]) and consists of an ASCII string that uniquely identifies the transform set (keys and algorithms) used to generate this SCS cookie.",
      "ja": "この識別子は、データセキュリティSA [RFC3740]でセキュリティパラメータインデックス（SPI）と等価である）と一意に（鍵およびアルゴリズムセット変換識別するASCII文字列からなる）、このSCSクッキーを生成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "SCS assumes that a key-agreement/distribution mechanism exists for environments in which S consists of multiple servers that provide a unique external identifier for each transform set shared amongst pool members.",
      "ja": "SCSは、キー合意/分配機構Sは、プールメンバ間で共有セットを変換するごとに一意の外部識別子を提供する複数のサーバで構成されている環境のために存在すると仮定しています。"
    },
    {
      "indent": 3,
      "text": "Such a mechanism may safely downgrade to a periodic key refresh, if there is only one server in the pool and the key is generated in place -- i.e., it is not handled by an external source.",
      "ja": "すなわち、それは外部ソースによって処理されていない - が、プール内の唯一のサーバであり、鍵が所定の位置に生成される場合、このようなメカニズムは安全に、定期的な鍵更新にダウングレードしてもよいです。"
    },
    {
      "indent": 3,
      "text": "However, when many servers act concurrently upon the same pool, a more sophisticated protocol, whose specification is out of the scope of the present document, must be devised (ideally, one that is able to handle key agreement for dynamic peer groups in a secure and efficient way, e.g., [CLIQUES] or [Steiner]).",
      "ja": "多くのサーバーが同じプール時に同時に行動するときしかし、その仕様より洗練されたプロトコルは、現在のドキュメントの範囲外である、（理想的には、安全なダイナミックピアグループのためのキー合意を扱うことができるものを考案する必要がありますそして効率的な方法、例えば、[派閥]または[シュタイナー]）。"
    },
    {
      "indent": 0,
      "text": "3.1.4. IV",
      "section_title": true,
      "ja": "3.1.4.  IV"
    },
    {
      "indent": 3,
      "text": "Initialization Vector used for the encryption algorithm (see Section 3.2).",
      "ja": "初期ベクトルは、暗号化アルゴリズムを使用（3.2節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "In order to avoid providing correlation information to a possible attacker with access to a sample of SCS cookies created using the same TID, the IV MUST be created randomly for each SCS cookie.",
      "ja": "同じTIDを使用して作成したSCSのクッキーのサンプルにアクセスすることができ、攻撃者に相関情報を提供しないようにするためには、IVは、各SCSクッキーのために、ランダムに作成する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.5. AUTHTAG",
      "section_title": true,
      "ja": "3.1.5.  AUTHTAG"
    },
    {
      "indent": 3,
      "text": "Authentication tag that is based on the plain string concatenation of the base64url-encoded DATA, ATIME, TID, and IV fields and is framed by the \"|\" separator (see also the definition of the Box() function in Section 3.2):",
      "ja": "「|」base64url符号化されたデータ、ATIME、TID、およびIVフィールドのプレーンな文字列の連結に基づいており、囲まれている認証タグセパレーター（また、3.2節でボックス（）関数の定義を参照してください）："
    },
    {
      "indent": 3,
      "text": "AUTHTAG = HMAC(base64url(DATA) \"|\" base64url(ATIME) \"|\" base64url(TID) \"|\" base64url(IV))",
      "ja": "AUTHTAG = HMAC（base64url（DATA） \"|\" base64url（atimeが） \"|\" base64url（TID） \"|\" base64url（IV））"
    },
    {
      "indent": 3,
      "text": "Note that, from a cryptographic point of view, the \"|\" character provides explicit authentication of the length of each supplied field, which results in a robust countermeasure against splicing attacks.",
      "ja": "なお、ビューの暗号化の点から、「|」文字は、スプライシング攻撃に対する強固な対策になり、各供給フィールドの長さ、の明示的な認証を提供します。"
    },
    {
      "indent": 0,
      "text": "3.2. Crypto Transform",
      "section_title": true,
      "ja": "3.2. 変換CRYPTO"
    },
    {
      "indent": 3,
      "text": "SCS could potentially use any combination of primitives capable of performing authenticated encryption. In practice, an encrypt-then-MAC approach [Kohno] with encryption utilizing the Cipher Block Chaining (CBC) mode and Hashed Message Authentication Code (HMAC) [RFC2104] authentication was chosen.",
      "ja": "SCSは、潜在的に認証された暗号化を行うことが可能なプリミティブの任意の組み合わせを使用することができます。実際には、暗号化-THEN-MACアプローチ[河野】暗号ブロック連鎖（CBC）モード、ハッシュメッセージ認証コード（HMAC）[RFC2104]認証が選択された利用暗号化。"
    },
    {
      "indent": 3,
      "text": "The two algorithms MUST be associated with two independent keys.",
      "ja": "2つのアルゴリズムは、2つの独立したキーに関連付けられなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following conventions will be used in the algorithm description (Sections 3.2.5 and 3.2.6):",
      "ja": "次の規則は、アルゴリズム記述（セクション3.2.5と3.2.6）で使用されます。"
    },
    {
      "indent": 3,
      "text": "o Enc/Dec(): block encryption/decryption functions (Section 3.2.2);",
      "ja": "なお、Enc O / 12月（）：ブロック暗号化/復号化機能（セクション3.2.2）。"
    },
    {
      "indent": 3,
      "text": "o HMAC(): authentication function (Section 3.2.2);",
      "ja": "O HMAC（）：認証機能（3.2.2項）。"
    },
    {
      "indent": 3,
      "text": "o Comp/Uncomp(): compression/decompression functions (Section 3.2.3);",
      "ja": "O COMP / Uncomp（）：圧縮/解凍機能（セクション3.2.3）。"
    },
    {
      "indent": 3,
      "text": "o e/d(): cookie-value encoding/decoding functions (Section 3.2.4);",
      "ja": "O E / D（）：クッキー値の符号化/復号化機能（セクション3.2.4）。"
    },
    {
      "indent": 3,
      "text": "o RAND(): random number generator [RFC4086];",
      "ja": "O RAND（）：乱数発生器[RFC4086]。"
    },
    {
      "indent": 3,
      "text": "o Box(): string boxing function. It takes an arbitrary number of base64url-encoded strings and returns the string obtained by concatenating each input in the exact order in which they are listed, separated by the \"|\" char. For example:",
      "ja": "Oボックス（）：文字列ボクシング機能。 「|」それはによって分離それらがリストされている正確な順序で各入力を連結した文字列を、base64urlエンコードされた文字列の任意の数をとり、戻り文字。例えば："
    },
    {
      "indent": 9,
      "text": "Box(\"akxI\", \"MTM\", \"Hadvo\") = \"akxI|MTM|Hadvo\".",
      "ja": "ボックス（ \"完了\"、 \"MTM\"、 \"Hadvo\"）= \"済| MTM | Hadvo\"。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Choice and Role of the Framing Symbol",
      "section_title": true,
      "ja": "3.2.1. フレーミング記号の選択と役割"
    },
    {
      "indent": 3,
      "text": "Note that the adoption of \"|\" as the framing symbol in the Box() function is arbitrary: any char allowed by the cookie-value ABNF in [RFC6265] is safe to be used as long it has empty intersection with the base64url alphabet.",
      "ja": "なお、採択の「|」ボックス（）関数におけるフレーミングシンボルとして任意である：[RFC6265]でクッキー値ABNFによって許可任意の文字であればbase64urlアルファベットを持つ空の交差点を有する使用するのに安全です。"
    },
    {
      "indent": 3,
      "text": "It is also worth noting that the role of the framing symbol, which provides an implicit length indicator for each of the atoms, is key to the accuracy and security of SCS.",
      "ja": "原子の各々のための暗黙の長さインジケータを提供フレーミングシンボルの役割は、SCSの正確さとセキュリティの鍵であることも注目に値します。"
    },
    {
      "indent": 3,
      "text": "This is especially relevant when the authentication tag is computed (see Section 3.1.5). More specifically, the explicit inclusion of the framing symbol within the HMAC input seals the integrity of the blob as a whole together with each of its composing atoms in their exact position.",
      "ja": "これは、認証タグが計算される場合に特に関連性がある（3.1.5項を参照してください）。具体的には、HMAC入力内のフレーミングシンボルを明示的に含めることは、それらの正確な位置にその構成原子のそれぞれと一緒に全体としてブロブの完全性をシール。"
    },
    {
      "indent": 3,
      "text": "This feature makes the protocol robust against attacks aimed at disrupting the security of SCS PDUs by freely moving boundaries between adjacent atoms.",
      "ja": "この機能は、自由に隣接する原子間の境界を移動することにより、SCS PDUのセキュリティをかく乱を狙った攻撃に対して頑健なプロトコルになります。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Cipher Set",
      "section_title": true,
      "ja": "3.2.2. 暗号設定"
    },
    {
      "indent": 3,
      "text": "Implementers MUST support at least the following algorithms:",
      "ja": "実装者は、少なくとも次のアルゴリズムをサポートしなければなりません："
    },
    {
      "indent": 3,
      "text": "o AES-CBC-128 for encryption [NIST-AES];",
      "ja": "暗号化のためのAES-CBC-128 O [NIST-AES]。"
    },
    {
      "indent": 3,
      "text": "o HMAC-SHA1 with a 128-bit key for authenticity and integrity,",
      "ja": "O信憑性と整合性のために128ビットの鍵とHMAC-SHA1、"
    },
    {
      "indent": 3,
      "text": "which appear to be sufficiently secure in a broad range of use cases ([Bellare] [RFC6194]), are widely available, and can be implemented in a few kilobytes of memory, providing an extremely valuable feature for constrained devices.",
      "ja": "ユースケースの広い範囲で十分に安全であると思われる（[ベラー] [RFC6194]）、広く入手可能であり、及び拘束装置のための非常に貴重な機能を提供し、メモリの数キロバイトで実施することができます。"
    },
    {
      "indent": 3,
      "text": "One should consider using larger cryptographic key lengths (192- or 256-bit) according to the actual security and overall system performance requirements.",
      "ja": "一つは、実際のセキュリティとシステム全体の性能要件に応じて、より大きな暗号鍵の長さ（192または256ビット）を使用して検討すべきです。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Compression",
      "section_title": true,
      "ja": "3.2.3. 圧縮"
    },
    {
      "indent": 3,
      "text": "Compression, which may be useful or even necessary when handling large quantities of data, is not compulsory (in such a case, Comp/ Uncomp is replaced by an identity matrix). If this function is enabled, the DEFLATE [RFC1951] format MUST be supported.",
      "ja": "大量のデータを扱う場合に有用、あるいは必要であり得る圧縮は、（そのような場合には、COMP / Uncompは恒等行列で置き換えられている）必須ではありません。この機能が有効になっている場合は、DEFLATE [RFC1951]フォーマットをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Some advice to SCS users: compression should not be enabled when handling relatively short and entropic state, such as pseudorandom session identifiers. Instead, large and quite regular state blobs could get a significant boost when compressed.",
      "ja": "SCSユーザーにいくつかのアドバイス：比較的短いとエントロピー状態を取り扱う際の圧縮は、このような擬似ランダムセッション識別子として、有効にしないでください。圧縮されたときに代わりに、大きな、非常に定期的な状態の塊は大きな後押しを得ることができます。"
    },
    {
      "indent": 0,
      "text": "3.2.4. Cookie Encoding",
      "section_title": true,
      "ja": "3.2.4.  Cookieのエンコーディング"
    },
    {
      "indent": 3,
      "text": "SCS cookie values MUST be encoded using the alphabet that is URL and filename safe (i.e., base64url) defined in Section 5 of Base64 [RFC4648]. This encoding is very widespread, falls smoothly into the encoding rules defined in Section 4.1.1 of [RFC6265], and can be safely used to supply SCS-based authorization tokens within a URI (e.g., in a query string or straight into a path segment).",
      "ja": "SCSクッキー値はBase64で[RFC4648]のセクション5で定義されたURLやファイル名を安全な（すなわち、base64url）であるアルファベットを使用して符号化されなければなりません。この符号化は、非常に普及している[RFC6265]のセクション4.1.1で定義された符号化規則に円滑に低下し、安全にクエリ文字列または直線路に、例えば、URI（内SCSベースの認証トークンを供給するために使用することができますセグメント）。"
    },
    {
      "indent": 0,
      "text": "3.2.5. Outbound Transform",
      "section_title": true,
      "ja": "3.2.5. 変換アウトバウンド"
    },
    {
      "indent": 3,
      "text": "The output data transformation, as seen by the server (the only actor that explicitly manipulates SCS cookies), is illustrated by the pseudocode in Figure 2.",
      "ja": "出力データ変換は、サーバ（明示SCSクッキーを操作のみアクター）によって見られるように、図2の擬似コードによって示されています。"
    },
    {
      "indent": 9,
      "text": "1.  IV := RAND()\n2.  ATIME := NOW\n3.  DATA := Enc(Comp(plain-text-cookie-value), IV)\n4.  AUTHTAG := HMAC(Box(e(DATA), e(ATIME), e(TID), e(IV)))",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 3,
      "text": "A new Initialization Vector is randomly picked (step 1). As previously mentioned (Section 3.1.4), this step is necessary to avoid providing correlation information to an attacker.",
      "ja": "新たな初期化ベクトルは、ランダムに（ステップ1）に取り出されます。以前に（セクション3.1.4）に述べたように、このステップは、攻撃者に関連情報を提供しないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "A new ATIME value is taken as the current timestamp according to the server clock (step 2).",
      "ja": "新しいATIME値は、サーバクロック（ステップ2）に従って、現在のタイムスタンプとします。"
    },
    {
      "indent": 3,
      "text": "Since the only user of the ATIME field is the server, it is unnecessary for it to be synchronized with the client -- though it needs to use a fairly stable clock. However, if multiple servers are active in a load-balancing configuration, clocks SHOULD be synchronized to avoid errors in the calculation of session expiry.",
      "ja": "ATIMEフィールドの唯一のユーザがサーバであるので、それはクライアントと同期させるために、それが不要である - それはかなり安定したクロックを使用する必要があるけれども。複数のサーバがロードバランシング設定でアクティブになっている場合は、クロックは、セッションの有効期限の計算にエラーを回避するために同期する必要があります。"
    },
    {
      "indent": 3,
      "text": "The plaintext cookie value is then compressed (if needed) and encrypted by using the key-set identified by TID (step 3).",
      "ja": "平文クッキー値は、圧縮された（必要な場合）およびTID（ステップ3）で識別キーセットを使用して暗号化されます。"
    },
    {
      "indent": 3,
      "text": "If the length of (compressed) state is not a multiple of the block size, its value MUST be filled with as many padding bytes of equal value as the pad length -- as defined by the scheme given in Section 6.3 of [RFC5652].",
      "ja": "（圧縮）状態の長さがブロックサイズの倍数でない場合、その値は、パッドの長さと同等の値のような多くのパディングバイトで埋めなければならない -  [RFC5652]のセクション6.3で与えられたスキームによって定義されます。"
    },
    {
      "indent": 3,
      "text": "Then, the authentication tag, which encompasses each SCS field (along with lengths and relative positions), is computed by HMAC'ing the \"|\"-separated concatenation of their base64url representations using the key-set identified by TID (step 4).",
      "ja": "「|」TID（ステップ4）で識別キーセットを使用してbase64url表現の区切られ連結次いで、（長さおよび相対位置と共に）各SCSフィールドを含む認証タグは、HMAC'ingによって計算されます。"
    },
    {
      "indent": 3,
      "text": "Finally, the SCS-cookie-value is created as follows:",
      "ja": "次のように最後に、SCS-クッキー値が作成されます。"
    },
    {
      "indent": 6,
      "text": "scs-cookie-value = Box(e(DATA), e(ATIME), e(TID), e(IV), e(AUTHTAG))",
      "ja": "SCS-クッキー値=ボックス（E（DATA）、E（ATIME）、E（TID）、E（IV）、E（AUTHTAG））"
    },
    {
      "indent": 0,
      "text": "3.2.6. Inbound Transform",
      "section_title": true,
      "ja": "3.2.6. インバウンド変換します"
    },
    {
      "indent": 3,
      "text": "The inbound transformation is described in Figure 3. Each of the 'e'-prefixed names shown has to be interpreted as the base64url-encoded value of the corresponding SCS field.",
      "ja": "インバウンド変換が示さ「E'-接頭辞名の各々は、対応するSCSフィールドのbase64urlエンコード値として解釈されなければならない。図3に記載されています。"
    },
    {
      "indent": 11,
      "text": "0.  If (split_fields(scs-cookie-value) == ok)\n1.      tid' := d(eTID)\n2.      If (tid' is available)\n3.          tag' := d(eAUTHTAG)\n4.          tag := HMAC(Box(eDATA, eATIME, eTID, eIV))\n5.          If (tag = tag')\n6.              atime' := d(eATIME)\n7.              If (NOW - atime' <= session_max_age)\n8.                  iv' := d(eIV)\n                    data' := d(eDATA)\n9.                  state := Uncomp(Dec(data', iv'))\n10.             Else discard PDU\n11.         Else discard PDU\n12.     Else discard PDU\n13. Else discard PDU",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 3,
      "text": "First, the inbound scs-cookie-value is broken into its component fields, which MUST be exactly 5, and each at least the minimum length specified in Figure 3 (step 0). In case any of these preliminary checks fails, the PDU is discarded (step 13); else, TID is decoded to allow key-set lookup (step 1).",
      "ja": "まず、インバウンドSCS-クッキー値を正確5、および各図3（ステップ0）で指定された少なくとも最小の長さでなければなりませんそのコンポーネントフィールドに分割されます。これらの予備検査のいずれか失敗を場合に、PDUは（ステップ13）、廃棄されます。他に、TIDは、キーセットの検索（ステップ1）を許可するためにデコードされます。"
    },
    {
      "indent": 3,
      "text": "If the cryptographic credentials (encryption and authentication algorithms and keys identified by TID) are unavailable (step 12), the inbound SCS cookie is discarded since its value has no chance to be interpreted correctly. This may happen for several reasons: e.g., if a device without storage has been reset and loses the credentials stored in RAM, if a server pool node desynchronizes, or in case of a key compromise that forces the invalidation of all current TIDs, etc.",
      "ja": "（TIDで識別される暗号化および認証アルゴリズムと鍵）暗号化証明書が利用できない（ステップ12）している場合は、その値が正しく解釈すべき機会を持っていないので、インバウンドSCSクッキーは破棄されます。これはいくつかの理由のために起こることがあります。例えば、ストレージなしのデバイスがリセットされて、RAMに記憶された認証情報を失った場合、サーバ・プール・ノードdesynchronizes場合、またはすべての現在のTIDの無効化を強制的に主要な感染の場合には、等"
    },
    {
      "indent": 3,
      "text": "When a valid key-set is found (step 2), the AUTHTAG field is decoded (step 3) and the (still) encoded DATA, ATIME, TID, and IV fields are supplied to the primitive that computes the authentication tag (step 4).",
      "ja": "有効なキー・セットは（ステップ2）発見された場合、AUTHTAGフィールドが復号される（ステップ3）、（静止）ATIME、TID、及びIVフィールドは（認証タグを計算し、そのプリミティブステップ4に供給され、符号化データを）。"
    },
    {
      "indent": 3,
      "text": "If the tag computed using the local key-set matches the one carried by the supplied SCS cookie, we can be confident that the cookie carries authentic material; otherwise, the SCS cookie is discarded (step 11).",
      "ja": "ローカル鍵セットを使用して計算されたタグが供給されるSCSクッキーによって運ばれるものと一致した場合、我々は、クッキーが本物材料を運ぶことを確信することができます。そうでない場合、SCSクッキーは（ステップ11）、廃棄されます。"
    },
    {
      "indent": 3,
      "text": "Then the age of the SCS cookie (as deduced by ATIME field value and current time provided by the server clock) is decoded and compared to the maximum time-to-live (TTL) defined by the session_max_age parameter.",
      "ja": "次いで、（ATIMEフィールド値とサーバクロックによって供給される電流の時間によって推定されるように）SCSクッキーの年齢は、デコードされた最大生存時間（TTL）session_max_ageパラメータによって定義と比較されます。"
    },
    {
      "indent": 3,
      "text": "If the \"age\" check passes, the DATA and IV fields are finally decoded (step 8), so that the original plaintext data can be extracted from the encrypted, and optionally compressed, blob (step 9).",
      "ja": "「年齢」のチェックに合格した場合、元の平文データが暗号化され、そして必要に応じて圧縮され、BLOB（ステップ9）から抽出することができるように、DATA及びIVのフィールドは最終的に、（ステップ8）、復号されます。"
    },
    {
      "indent": 3,
      "text": "Note that steps 5 and 7 allow any altered packets or expired sessions to be discarded, hence avoiding unnecessary state decryption and decompression.",
      "ja": "従って、不要な状態解読および解凍を避け、5及び7は、任意の変更されたパケットまたは期限切れのセッションが破棄されることを可能にするステップ音符。"
    },
    {
      "indent": 0,
      "text": "3.3. PDU Exchange",
      "section_title": true,
      "ja": "3.3.  PDU交換"
    },
    {
      "indent": 3,
      "text": "SCS can be modeled in the same manner as a typical store-and-forward protocol in which the endpoints are S, consisting of one or more HTTP servers and the client C, an intermediate node used to \"temporarily\" store the data to be successively forwarded to S.",
      "ja": "SCSは、エンドポイントは、1つまたは複数のHTTPサーバとクライアントCからなる、Sである、典型的なストアアンドフォワードプロトコル、「一時的」連続するデータを格納するために使用される中間ノードと同様にモデル化することができます。 S.に転送"
    },
    {
      "indent": 3,
      "text": "In brief, S and C exchange an immutable cookie data block (Section 3.1): the state is stored on the client at the first hop and then restored on the server at the second, as in Figure 4.",
      "ja": "簡潔、S及びC交換に不変クッキーデータブロック（セクション3.1）。図4のように、状態は、最初のホップのクライアントに格納された後、第2のサーバに復元します。"
    },
    {
      "indent": 5,
      "text": "1. dump-state: S --> C Set-Cookie: ANY_COOKIE_NAME=KrdPagFes_5ma-ZUluMsww|MTM0... Expires=...; Path=...; Domain=...;",
      "ja": "1.ダンプ状態：S  - > CのSet-Cookie：ANY_COOKIE_NAME = KrdPagFes_5ma-ZUluMsww | MTM0 ...有効期限= ...;パス= ...;ドメイン= ...;"
    },
    {
      "indent": 5,
      "text": "2. restore-state: C --> S Cookie: ANY_COOKIE_NAME=KrdPagFes_5ma-ZUluMsww|MTM0...",
      "ja": "2.復元状態：C  - > Sクッキー：ANY_COOKIE_NAME = KrdPagFes_5ma-ZUluMsww | MTM0を..."
    },
    {
      "indent": 33,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 0,
      "text": "3.3.1. Cookie Attributes",
      "section_title": true,
      "ja": "3.3.1. クッキーの属性"
    },
    {
      "indent": 3,
      "text": "In the following subsections, a series of recommendations is provided in order to maximize SCS PDU fitness in the generic cookie ecosystem.",
      "ja": "以下のサブセクションでは、一連の勧告は、一般的なクッキーのエコシステムにSCS PDUの適応度を最大化するために設けられています。"
    },
    {
      "indent": 0,
      "text": "3.3.1.1. Expires",
      "section_title": true,
      "ja": "3.3.1.1。有効期限"
    },
    {
      "indent": 3,
      "text": "If an SCS cookie includes an Expires attribute, then the attribute MUST be set to a value consistent with session_max_age.",
      "ja": "SCS Cookieは属性が有効期限が含まれている場合、その属性はsession_max_ageと一致した値に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For maximum compatibility with existing user agents, the timestamp value MUST be encoded in rfc1123-date format, which requires a 4-digit year.",
      "ja": "既存のユーザエージェントとの最大の互換性のために、タイムスタンプ値は、4桁の年を必要とRFC1123、日付形式で符号化されなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3.1.2. Max-Age",
      "section_title": true,
      "ja": "3.3.1.2。マックスエイジ"
    },
    {
      "indent": 3,
      "text": "Since not all User Agents (UAs) support this attribute, it MUST NOT be present in any SCS cookie.",
      "ja": "いないすべてのユーザーエージェント（UAが）この属性をサポートしているので、それがどのSCSクッキーに存在してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.3.1.3. Domain",
      "section_title": true,
      "ja": "3.3.1.3。ドメイン"
    },
    {
      "indent": 3,
      "text": "SCS cookies MUST include a Domain attribute compatible with application usage.",
      "ja": "SCSのクッキーは、ドメインのアプリケーションの使用状況に対応して属性を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "A trailing '.' MUST NOT be present in order to minimize the possibility of a user agent ignoring the attribute value.",
      "ja": "末尾の「」属性値を無視してユーザエージェントの可能性を最小限にするために存在してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.3.1.4. Secure",
      "section_title": true,
      "ja": "3.3.1.4。確保します"
    },
    {
      "indent": 3,
      "text": "This attribute MUST always be asserted when SCS sessions are carried over a Transport Layer Security (TLS) channel.",
      "ja": "SCSセッションはトランスポート層セキュリティ（TLS）チャネルを介して搬送される際に、この属性は常にアサートする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.1.5. HttpOnly",
      "section_title": true,
      "ja": "3.3.1.5。 HTTPのみ"
    },
    {
      "indent": 3,
      "text": "This attribute SHOULD always be asserted.",
      "ja": "この属性は常にアサートする必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Key Management and Session State",
      "section_title": true,
      "ja": "4.キー管理とセッション状態"
    },
    {
      "indent": 3,
      "text": "This specification provides some common recommendations and practices relevant to cryptographic key management.",
      "ja": "この仕様は、暗号鍵の管理に関連するいくつかの共通お薦めやプラクティスを提供します。"
    },
    {
      "indent": 3,
      "text": "In the following, the term 'key' references both encryption and HMAC keys.",
      "ja": "以下、用語「キー」参照暗号化およびHMACキーの両方で。"
    },
    {
      "indent": 3,
      "text": "o The key SHOULD be generated securely following the randomness recommendations in [RFC4086];",
      "ja": "Oキーは、[RFC4086]で乱数推奨に従って確実に生成されるべきです。"
    },
    {
      "indent": 3,
      "text": "o the key SHOULD only be used to generate and verify SCS PDUs;",
      "ja": "OキーのみSCS PDUを生成し、検証するために使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "o the key SHOULD be replaced regularly as well as any time the format of SCS PDUs or cryptographic algorithms changes.",
      "ja": "Oキーは、任意の時間だけでなく、定期的にSCS PDUのか、暗号化アルゴリズムの変更の形式を交換する必要があります。"
    },
    {
      "indent": 3,
      "text": "Furthermore, to preserve the validity of active HTTP sessions upon renewal of cryptographic credentials (whenever the value of TID changes), an SCS server MUST be capable of managing at least two transforms contemporarily: the currently instantiated one and its predecessor.",
      "ja": "また、暗号クレデンシャル（たびTIDの値が変更された）の更新時にアクティブなHTTPセッションの有効性を維持するために、SCSサーバは、現代的な少なくとも2つの変換を管理することができなければなりません：現在一方とその前身をインスタンス化。"
    },
    {
      "indent": 3,
      "text": "Each transform set SHOULD be associated with an attribute pair, \"refresh\" and \"expiry\", which is used to identify the exposure limits (in terms of time or quantity of encrypted and/or authenticated bytes, etc.) of related cryptographic material.",
      "ja": "各トランスフォームセットは、関連する暗号化材料の（時間または暗号化および/または認証されたバイト数などの量の点で）暴露限界を識別するために使用される属性の組、「リフレッシュ」および「有効期限」に関連付けられるべきです。"
    },
    {
      "indent": 3,
      "text": "In particular, the \"refresh\" attribute specifies the time limit for substitution of transform set T with new material T'. From that moment onwards, and for an amount of time determined by \"expiry\", all new sessions will be created using T', while the active T-protected ones go through a translation phase in which:",
      "ja": "具体的には、「リフレッシュ」属性は、新素材のT」とセット変換Tの置換のための時間制限を指定します。アクティブT-保護されたものが内変換フェーズを通過しながら、以降その瞬間から、及び「有効期限」によって決定された時間の量のために、すべての新しいセッションでは、T「を使用して作成されます。"
    },
    {
      "indent": 3,
      "text": "o the inbound transformation authenticates and decrypts/decompresses using T (identified by TID);",
      "ja": "インバウンド変換は、認証及び/は（TIDによって識別される）Tを使用して伸張復号Oであり;"
    },
    {
      "indent": 3,
      "text": "o the outbound transformation encrypts/compresses and authenticates using T'.",
      "ja": "アウトバウンド変換oを暗号化/圧縮し、」Tを使用して認証します。"
    },
    {
      "indent": 8,
      "text": "T' {not valid yet} |---------------------|----------------\n                   |  translation stage  |\nT  ----------------|---------------------| {no longer valid}\n                 refresh         refresh + expiry",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 5",
      "ja": "図5"
    },
    {
      "indent": 3,
      "text": "As shown in Figure 5, the duration of the HTTP session MUST fit within the lifetime of a given transform set (i.e., from creation time until \"refresh\" + \"expiry\").",
      "ja": "図5に示すように、HTTPセッションの継続時間は、所定の寿命内に収まる必要があります（作成時刻から「リフレッシュ」+「有効期限」まで、すなわち、）セットを変換します。"
    },
    {
      "indent": 3,
      "text": "In practice, this should not be an obstacle because the longevity of the two entities (HTTP session and SCS transform set) should differ by one or two orders of magnitude.",
      "ja": "2つのエンティティの寿命（HTTPセッションおよびSCSトランスフォームセット）が1桁から2桁異なる必要があるため実際には、これは障害ではありません。"
    },
    {
      "indent": 3,
      "text": "An SCS server may take this into account by determining the duration of a session adaptively according to the expected deletion time of the active T, or by setting the \"expiry\" value to at least the maximum lifetime allowed by an HTTP session.",
      "ja": "SCSサーバーは、またはHTTPセッションで許可される少なくとも最大寿命に「有効期限」の値を設定することにより、適応的に活性Tの予想削除時間に応じてセッションの継続時間を決定することによって、これを考慮してもよいです。"
    },
    {
      "indent": 3,
      "text": "Since there is also only one refresh attribute in situations with more than one key (e.g., one for encryption and one for authentication) within the same T, the smallest value is chosen.",
      "ja": "また、同じT内に複数のキー（例えば、認証のための暗号化のため1つずつ）を持つ状況でのみ1回のリフレッシュ属性があるので、最小値が選択されます。"
    },
    {
      "indent": 3,
      "text": "It is critical for the correctness of the protocol that in case multiple equivalent SCS servers are used in a pool, all of them share the same view of time (see also Section 3.2.5) and keying material.",
      "ja": "それは場合には、複数の同等のSCSサーバーは、それらのすべてが時間の同じビューを共有し、プールで使用されているプロトコルの正しさのために重要であり、鍵材料（セクション3.2.5を参照してください）。"
    },
    {
      "indent": 3,
      "text": "As far as the latter is concerned, SCS does not mandate the use of any specific key-sharing mechanism, and will keep working correctly as long as the said mechanism is able to provide a single, coherent view of the keys shared by pool members -- while conforming to the recommendations given in this section.",
      "ja": "限り後者に関しては、SCSは、任意の特定のキー共有メカニズムの使用を強制しない、と限り言っメカニズムは、プールのメンバーによって共有鍵のシングル、一貫したビューを提供することができるよう正しく動作し続けます -  - このセクションに記載された勧告に準拠しています。"
    },
    {
      "indent": 0,
      "text": "5. Cookie Size Considerations",
      "section_title": true,
      "ja": "5.クッキーサイズの考慮事項"
    },
    {
      "indent": 3,
      "text": "In general, SCS cookies are bigger than their plaintext counterparts. This is due to the following reasons:",
      "ja": "一般的には、SCSのクッキーは、その平文の対応よりも大きくなっています。これは、次のような理由によるものです。"
    },
    {
      "indent": 3,
      "text": "o inflation of the Base64 encoding of state data (approximately 1.4 times the original size, including the encryption padding);",
      "ja": "状態データ（暗号化パディングを含む約1.4倍のサイズ）のBase64エンコーディングのOインフレーション。"
    },
    {
      "indent": 3,
      "text": "o the fixed size increment (approximately 80/90 bytes) caused by SCS fields and framing overhead.",
      "ja": "固定サイズの増加（約90分の80バイト）SCSフィールドフレーミングオーバーヘッドに起因するO。"
    },
    {
      "indent": 3,
      "text": "While the former is a price the user must always pay proportionally to the original data size, the latter is a fixed quantum, which can be huge on small amounts of data but is quickly absorbed as soon as data becomes big enough.",
      "ja": "前者は、ユーザは常に元のデータのサイズに比例して支払わなければならない価格ですが、後者は、少量のデータに大きなことができますが、データが十分な大きさになるとすぐに、すぐに吸収される固定量子、です。"
    },
    {
      "indent": 3,
      "text": "The following table compares byte lengths of SCS cookies (with a four-byte TID) and corresponding plaintext cookies in a worst-case scenario, i.e., when no compression is in use (or applicable).",
      "ja": "次の表には圧縮が使用（または適用）になっていないと、最悪の場合のシナリオで平文クッキー対応する、すなわち、（4バイトTIDと）SCSクッキーのバイト長を比較します。"
    },
    {
      "indent": 31,
      "text": "plain |  SCS\n-------+-------\n  11  |  128\n 102  |  256\n 285  |  512\n 651  | 1024\n1382  | 2048\n2842  | 4096",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The largest uncompressed cookie value that can be safely supplied to SCS is about 2.8 KB.",
      "ja": "安全SCSに供給することができる最大の圧縮されていないクッキーの値は約2.8 KBです。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgements",
      "section_title": true,
      "ja": "6.謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Jim Schaad, David Wagner, Lorenzo Cavallaro, Willy Tarreau, Tobias Gondrom, John Michener, Sean Turner, Barry Leiba, Robert Sparks, Stephen Farrell, Stewart Bryant, and Nevil Brownlee for their valuable feedback on this document.",
      "ja": "私たちは、このドキュメントの彼らの貴重なフィードバックのためにジムSchaad、デビッド・ワグナー、ロレンツォ・キャバレロ、ウィリーTarreau、トビアスGondrom、ジョン・ミッチェナー、ショーン・ターナー、バリー・レイバ、ロバート・スパークス、スティーブン・ファレル、スチュワートブライアント、およびNevilブラウンリーに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. Security of the Cryptographic Protocol",
      "section_title": true,
      "ja": "7.1. 暗号プロトコルのセキュリティ"
    },
    {
      "indent": 3,
      "text": "From a cryptographic architecture perspective, the described mechanism can be easily traced to an \"encode then encrypt-then-MAC\" scheme (Encode-then-EtM) as described in [Kohno].",
      "ja": "暗号アーキテクチャの観点から、説明されたメカニズムは容易[河野]に記載されているように、「次に、暗号化-THEN-MACをコード」方式（エンコード-THEN-ETM）にさかのぼることができます。"
    },
    {
      "indent": 3,
      "text": "Given a \"provably-secure\" encryption scheme and MAC (as for the algorithms mandated in Section 3.2.2), the authors of [Kohno] demonstrate that their composition results in a secure authenticated encryption scheme.",
      "ja": "（3.2.2項で義務付けアルゴリズムのような）「証明可能安全」暗号化方式とMACを考えると、[河野]の著者は、安全な認証された暗号化方式では、その組成の結果ことを示しています。"
    },
    {
      "indent": 0,
      "text": "7.2. Impact of the SCS Cookie Model",
      "section_title": true,
      "ja": "7.2.  SCSクッキーモデルのインパクト"
    },
    {
      "indent": 3,
      "text": "The fact that the server does not own the cookie it produces, gives rise to a series of consequences that must be clearly understood when one envisages the use of SCS as a cookie provider and validator for his/her application.",
      "ja": "サーバはそれが生成するクッキーを所有していないという事実は、人は彼/彼女のアプリケーションのためのクッキープロバイダやバリデータとしてSCSの使用を想定したときに明確に理解されなければならない結果のシリーズを生じさせます。"
    },
    {
      "indent": 3,
      "text": "In the following subsections, a set of different attack scenarios (together with corresponding countermeasures where applicable) are identified and analyzed.",
      "ja": "以下のサブセクションでは、異なる攻撃シナリオの組（共に対応策とは、該当する場合）が同定され、分析されます。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Old Cookie Replay",
      "section_title": true,
      "ja": "7.2.1. 古いクッキーリプレイ"
    },
    {
      "indent": 3,
      "text": "SCS doesn't address replay of old cookie values.",
      "ja": "SCSは、古いクッキー値の再生には対応していません。"
    },
    {
      "indent": 3,
      "text": "In fact, there is nothing that assures an SCS application about the client having returned the most recent version of the cookie.",
      "ja": "実際には、クッキーの最新バージョンを返されたクライアントに関するSCSのアプリケーションを保証は何もありません。"
    },
    {
      "indent": 3,
      "text": "As with \"server-side\" sessions, if an attacker gains possession of a given user's cookies -- via simple passive interception or another technique -- he/she will always be able to restore the state of an intercepted session by representing the captured data to the server.",
      "ja": "「サーバー側」のセッションと同じように、与えられたユーザーのクッキーの攻撃者の所持場合 - シンプルな受動的傍受または他の技術を介した - 彼/彼女は常に撮影したデータを表すことによって傍受セッションの状態を復元することができますサーバーへ。"
    },
    {
      "indent": 3,
      "text": "The ATIME value, along with the session_max_age configuration parameter, allows SCS to mitigate the chances of an attack (by forcing a time window outside of which a given cookie is no longer valid) but cannot exclude it completely.",
      "ja": "ATIME値は、session_max_age設定パラメータとともに、（与えられたクッキーは、もはや有効であるの外で時間ウィンドウを強制しないことで）SCSは、攻撃の可能性を軽減することができますが、それを完全に除外することはできません。"
    },
    {
      "indent": 3,
      "text": "A countermeasure against the \"passive interception and replay\" scenario can be applied at transport/network level using the anti-replay services provided by e.g., Secure Socket Layer/Transport Layer Security (SSL/TLS) [RFC5246] or IPsec [RFC4301].",
      "ja": "「受動的傍受及び再生」シナリオ対策は、例えば、セキュアソケットレイヤ/トランスポートレイヤセキュリティ（SSL / TLS）[RFC5246]やIPsec [RFC4301]によって提供アンチリプレイサービスを使用して、トランスポート/ネットワークレベルで適用することができます。"
    },
    {
      "indent": 3,
      "text": "A native solution is not in scope with the security properties inherent to an SCS cookie. Hence, an application wishing to be replay-resistant must put in place some ad hoc mechanism to prevent clients (both rogue and legitimate) from (a) being able to replay old cookies as valid credentials and/or (b) getting any advantage by replaying them.",
      "ja": "ネイティブのソリューションは、SCSのクッキーに固有のセキュリティプロパティを持つスコープではありません。したがって、リプレイ耐性であることを希望するアプリケーションは、ことによって、任意の利点を所定の位置に（a）の有効な資格情報として古いクッキーを再生することができることから、（不正と正当両方）のクライアントを防ぐために、いくつかのアドホックなメカニズムを置くおよび/または（b）取得しなければなりませんそれらを再生します。"
    },
    {
      "indent": 3,
      "text": "The following illustrate some typical use cases:",
      "ja": "以下は、いくつかの典型的な使用例を示しています。"
    },
    {
      "indent": 3,
      "text": "o Session inactivity timeout scenario (implicit invalidation): use the session_max_age parameter if a global setting is viable, else place an explicit TTL in the cookie (e.g., validity_period=\"start_time, duration\") that can be verified by the application each time the client presents the SCS cookie.",
      "ja": "セッション無活動タイムアウトのシナリオ（暗黙の無効化）○：グローバル設定は、アプリケーションによって検証することができます実行可能な、他の場所のクッキーで明示的なTTL（例えば、validity_period =「のstart_time、継続時間」）であればsession_max_ageパラメータを使用するたびにクライアントは、SCSのクッキーを提示します。"
    },
    {
      "indent": 3,
      "text": "o Session voidance scenario (explicit invalidation): put a randomly chosen string into each SCS cookie (cid=\"$(random())\") and keep a list of valid session cids against which the SCS cookie presented by the client can be checked. When a cookie needs to be invalidated, delete the corresponding cid from the list. The described method has the drawback that, in case a non-permanent storage is used to archive valid cids, a reboot/restart would invalidate all sessions (it can't be used when |S| > 1).",
      "ja": "セッションvoidanceシナリオ（明示的に無効化）○：（CID =「$（ランダム（））」）各SCSクッキーの中にランダムに選ばれた文字列を入れて、クライアントによって提示されたSCSのクッキーを確認することができ、それに対して有効なセッションCIDのリストを保ちます。クッキーを無効にする必要がある場合は、リストから該当するCIDを削除します。 （それはときに使用することはできません| S |> 1）に記載の方法は、すべてのセッションを無効になり、再起動/再起動が場合に非永続ストレージが有効なCIDをアーカイブするために使用される、という欠点があります。"
    },
    {
      "indent": 3,
      "text": "o One-shot transaction scenario (ephemeral): this is a variation on the previous theme when sessions are consumed within a single request/response. Put a nonce=\"$(random())\" within the state information and keep a list of not-yet-consumed nonces in RAM. Once the client presents its cookie credential, the embodied nonce is deleted from the list and will be therefore discarded whenever replayed.",
      "ja": "O（はかない）ワンショット・トランザクションのシナリオは：これはセッションが単一の要求/応答内で消費されている以前のテーマにばらつきがあります。ナンス=「$（ランダム（））」内の状態情報を入れて、RAMにおける未消費ナンスのリストを保持します。クライアントはそのクッキーの資格を提示したら、具現化ナンスがリストから削除され、再生時はいつでもので、破棄されます。"
    },
    {
      "indent": 3,
      "text": "o TLS binding scenario: the server application must run on TLS, be able to extract information related to the current TLS session, and store it in the DATA field of the SCS cookie itself [RFC5056]. The establishment of this secure channel binding prevents any third party from reusing the SCS cookie, and drops its value altogether after the TLS session is terminated -- regardless of the lifetime of the cookie. This approach suffers a scalability problem in that it requires each SCS session to be handled by the same client-server pair. However, it provides a robust model and an affordable compromise when security of the session is exceptionally valuable (e.g., a user interacting with his/her online banking site).",
      "ja": "O TLSバインディングシナリオ：サーバーアプリケーションは、現在のTLSセッションに関連する情報を抽出することができ、TLS上で実行され、SCSクッキー自体[RFC5056]のデータフィールドに格納しなければなりません。この結合のセキュアチャネルの確立は、SCSのクッキーを再利用するから第三者を防ぎ、およびTLSセッションが終了した後、完全にその値をドロップ - かかわらず、クッキーの寿命。このアプローチは、それが同じクライアント・サーバペアによって処理される各SCSセッションを必要とするというスケーラビリティの問題がで苦しんでいます。セッションのセキュリティは非常に貴重であるときしかし、それは堅牢なモデルと手頃な価格の妥協を提供（例えば、ユーザーは、彼/彼女のオンラインバンキングサイトとの相互作用します）。"
    },
    {
      "indent": 3,
      "text": "It is worth noting that in all but the latter scenario, if an attacker is able to use the cookie before the legitimate client gets a chance to, then the impersonation attack will always succeed.",
      "ja": "攻撃者は正当なクライアントは、その後、偽装攻撃は常に成功するための機会を得る前に、クッキーを使用することができる場合には、すべてが、後者のシナリオでことは注目に値します。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Cookie Deletion",
      "section_title": true,
      "ja": "7.2.2. クッキーの削除"
    },
    {
      "indent": 3,
      "text": "A direct and important consequence of the missing owner role in SCS is that a client could intentionally delete its cookie and return nothing.",
      "ja": "SCSで不足している所有者の役割の直接的かつ重要な結果は、クライアントが意図的にそのクッキーを削除し、何も返さない可能性があることです。"
    },
    {
      "indent": 3,
      "text": "The application protocol has to be designed so there is no incentive to do so, for instance:",
      "ja": "例えば、そうするインセンティブがないので、アプリケーションプロトコルを設計する必要があります。"
    },
    {
      "indent": 3,
      "text": "o it is safe for the cookie to represent some kind of positive capability -- the possession of which increases the client's powers;",
      "ja": "クッキーは、正の機能のいくつかの種類を表すためにのためにOそれは安全である - クライアントの力を増加させるの所持を。"
    },
    {
      "indent": 3,
      "text": "o it is not safe to use the cookie to represent negative capabilities -- where possession reduces the client's powers -- or for revocation.",
      "ja": "所持がクライアントの権限を減らす -   - または取り消しをO負の機能を表現するためにクッキーを使用することは安全ではありません。"
    },
    {
      "indent": 3,
      "text": "Note that this behavior is not equivalent to cookie removal in the \"server-side\" cookie model, because in case of missing cookie backup by other parties (e.g., the application using SCS), the client could simply make it disappear once and for all.",
      "ja": "他の当事者（例えば、SCSを使用して、アプリケーション）によってクッキーのバックアップを行方不明の場合には、クライアントは単にそれはきっぱりと消えるように可能性があるため、この動作は、「サーバー側の」クッキーモデルのクッキーの削除と等価ではないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "7.2.3. Cookie Sharing or Theft",
      "section_title": true,
      "ja": "7.2.3. クッキーの共有または盗難"
    },
    {
      "indent": 3,
      "text": "Just like with plain cookies, SCS doesn't prevent sharing (both voluntary and illegitimate) of cookies between multiple clients.",
      "ja": "ただのクッキーと同じように、SCSは、複数のクライアント間でのクッキーの（自発的および非嫡出の両方）の共有を防ぐことはできません。"
    },
    {
      "indent": 3,
      "text": "In the context of voluntary cookie sharing, using HTTPS only as a separate secure transport provider is useless: in fact, client certificates are just as shareable as cookies. Instead, using some form of secure channel binding (as illustrated in Section 7.2.1) may cancel this risk.",
      "ja": "自主的なクッキーの共有の文脈では、唯一の独立したセキュアなトランスポートプロバイダとしてHTTPSを使用することは無意味です：実際には、クライアント証明書には、クッキーと同じように共有可能です。代わりに、（セクション7.2.1に示すように）結合セキュアチャネルのいくつかのフォームを使用すると、このリスクを取り消すことができます。"
    },
    {
      "indent": 3,
      "text": "The risk of theft could be mitigated by securing the wire (e.g., via HTTPS, IPsec, VPN, etc.), thus reducing the opportunity of cookie stealing to a successful attack on the protocol endpoints.",
      "ja": "盗難のリスクは、このように、プロトコルエンドポイントに成功した攻撃にクッキー盗難の機会を減少させる、（HTTPSなど、IPsecの、VPNを介して、例えば）のワイヤを固定することによって軽減することができます。"
    },
    {
      "indent": 3,
      "text": "In order to reduce the attack window on stolen cookies, an application may choose to generate cookies whose lifetime is upper bounded by the browsing session lifetime (i.e., by not attaching an Expires attribute to them.)",
      "ja": "盗まれたクッキーの攻撃ウィンドウを小さくするために、アプリケーションがその生涯のブラウジングセッションの寿命によって上位囲まれているクッキーを生成することもできます（つまり、接続しないで、それらに属性有効期限。）"
    },
    {
      "indent": 0,
      "text": "7.2.4. Session Fixation",
      "section_title": true,
      "ja": "7.2.4. セッション固定"
    },
    {
      "indent": 3,
      "text": "Session fixation vulnerabilities [Kolsec] are not addressed by SCS.",
      "ja": "セッション固定の脆弱性[Kolsec] SCSによって対処されていません。"
    },
    {
      "indent": 3,
      "text": "A more sophisticated protocol involving active participation of the UA in the SCS cookie manipulation process would be needed: e.g., some form of challenge/response exchange initiated by the server in the HTTP response and replied to by the UA in the next chained HTTP request.",
      "ja": "SCSクッキーの操作過程でUAの積極的な参加を含む、より洗練されたプロトコルが必要とされるであろう：例えば、チャレンジ/レスポンス交換のいくつかのフォームは、HTTP応答でサーバーによって開始され、次の連鎖HTTPリクエストにUAによって答えました。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, the present specification, which is based on [RFC6265], sees the UA as a completely passive actor whose role is to blindly paste the cookie value set by the server.",
      "ja": "残念ながら、[RFC6265]に基づいており、本明細書が、その役割は盲目的にサーバによって設定されたクッキー値を貼り付けることで、完全に受動的な俳優としてUAを見ています。"
    },
    {
      "indent": 3,
      "text": "Nevertheless, the SCS cookies wrapping mechanism may be used in the future as a building block for a more robust HTTP state management protocol.",
      "ja": "それにも関わらず、SCSクッキーラッピングメカニズムは、より堅牢なHTTP状態管理プロトコルのためのビルディングブロックとして、将来的に使用することができます。"
    },
    {
      "indent": 0,
      "text": "7.3. Advantages of SCS over Server-Side Sessions",
      "section_title": true,
      "ja": "7.3. サーバー側のセッションでSCSの利点"
    },
    {
      "indent": 3,
      "text": "Note that all the above-mentioned vulnerabilities also apply to plain cookies, making SCS at least as secure, but there are a few good reasons to consider its security level enhanced.",
      "ja": "上記のすべての脆弱性がまたSCSは、少なくともとして安全にする、プレーンなクッキーに適用されますが、そのセキュリティレベルを向上させる検討するいくつかの理由があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "First of all, the confidentiality and authentication features provided by SCS protect the cookie value, which is normally plaintext and tamperable.",
      "ja": "まず第一に、SCSが提供する機密性と認証機能が正常に平文と改ざんされたクッキーの値を、守ります。"
    },
    {
      "indent": 3,
      "text": "Furthermore, neither of the common vulnerabilities of server-side sessions (session identifier (SID) prediction and SID brute-forcing) can be exploited when using SCS, unless the attacker possesses encryption and HMAC keys (both current ones and those relating to the previous set of credentials).",
      "ja": "また、サーバ側セッションの一般的な脆弱性のいずれも（セッション識別子（SID）予測とSIDブルート強制）SCSを使用する場合、攻撃者は、暗号化およびHMACキー（現在のものの両方を所有しない限り、利用することができ、それらの前に関連資格情報のセット）。"
    },
    {
      "indent": 3,
      "text": "More in general, no slicing nor altering operations can be done over an SCS PDU without controlling the cryptographic key-set.",
      "ja": "より一般的には、何も変更スライシング操作は、暗号鍵セットを制御することなくSCS PDUにわたって行うことができません。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[NIST-AES] National Institute of Standards and Technology, \"Advanced Encryption Standard (AES)\", FIPS PUB 197, November 2001, <http://csrc.nist.gov/publications/fips/fips197/ fips-197.pdf>.",
      "ja": "[NIST-AES]米国国立標準技術研究所、 \"高度暗号化標準（AES）\"、FIPS PUBの197、2001年11月、<http://csrc.nist.gov/publications/fips/fips197/ FIPS-197.pdf >。"
    },
    {
      "indent": 3,
      "text": "[RFC1951] Deutsch, P., \"DEFLATE Compressed Data Format Specification version 1.3\", RFC 1951, May 1996.",
      "ja": "[RFC1951]ドイツ、P.、 \"DEFLATE圧縮データフォーマット仕様バージョン1.3\"、RFC 1951、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、2006年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5652] Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70, RFC 5652, September 2009.",
      "ja": "[RFC5652] Housley氏、R.、 \"暗号メッセージ構文（CMS）\"、STD 70、RFC 5652、2009年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC6194] Polk, T., Chen, L., Turner, S., and P. Hoffman, \"Security Considerations for the SHA-0 and SHA-1 Message-Digest Algorithms\", RFC 6194, March 2011.",
      "ja": "[RFC6194]ポーク、T.、陳、L.、ターナー、S.、およびP.ホフマン、 \"SHA-0およびSHA-1メッセージダイジェストアルゴリズムのためのセキュリティの考慮事項\"、RFC 6194、2011年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC6265] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, April 2011.",
      "ja": "[RFC6265]バース、A.、 \"HTTP状態管理機構\"、RFC 6265、2011年4月。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[Bellare] Bellare, M., \"New Proofs for NMAC and HMAC: Security Without Collision-Resistance\", 2006.",
      "ja": "[ベラー]ベラー、M.、「NMACおよびHMACのための新しい証明：衝突、抵抗なくセキュリティ」、2006年。"
    },
    {
      "indent": 3,
      "text": "[CLIQUES] Steiner, M., Tsudik, G., and M. Waidner, \"Cliques: A New Approach to Group Key Agreement\", 1996.",
      "ja": "[派閥]シュタイナー、M.、Tsudik、G.、およびM. Waidner、 \"派閥：グループ鍵共有への新しいアプローチ\"、1996年。"
    },
    {
      "indent": 3,
      "text": "[Kohno] Kohno, T., Palacio, A., and J. Black, \"Building Secure Cryptographic Transforms, or How to Encrypt and MAC\", 2003.",
      "ja": "[河野]河野、T.、パラシオ、A.、およびJ.ブラック、 \"安全な暗号トランスフォームの構築、またはどのように暗号化してMacに\"、2003年。"
    },
    {
      "indent": 3,
      "text": "[Kolsec] Kolsec, M., \"Session Fixation Vulnerability in Web-based Applications\", 2002.",
      "ja": "[Kolsec] Kolsec、M.、2002年の \"Webベースのアプリケーションにおけるセッション固定の脆弱性\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3740] Hardjono, T. and B. Weis, \"The Multicast Group Security Architecture\", RFC 3740, March 2004.",
      "ja": "[RFC3740] Hardjono、T.とB.ウィス、 \"マルチキャストグループのセキュリティアーキテクチャ\"、RFC 3740、2004年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[RFC4301]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5056] Williams, N., \"On the Use of Channel Bindings to Secure Channels\", RFC 5056, November 2007.",
      "ja": "\"チャネルを確保するチャネルバインディングの使用について\" [RFC5056]ウィリアムズ、N.、RFC 5056、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[Steiner] Steiner, M., Tsudik, G., and M. Waidner, \"Diffie-Hellman Key Distribution Extended to Group Communication\", 1996.",
      "ja": "[シュタイナー]シュタイナー、M.、Tsudik、G.、およびM. Waidner、 \"グループ通信への拡張のDiffie-Hellman鍵の配布\"、1996年。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Examples",
      "ja": "付録A.例"
    },
    {
      "indent": 3,
      "text": "The examples in this section have been created using the 'scs' test tool bundled with LibSCS, a free and opensource reference implementation of the SCS protocol that can be found at (http://github.com/koanlogic/libscs).",
      "ja": "このセクションの例はLibSCS、（http://github.com/koanlogic/libscs）で見つけることができSCSプロトコルの自由とオープンソースリファレンス実装にバンドル「SCS」テストツールを使用して作成されています。"
    },
    {
      "indent": 0,
      "text": "A.1. No Compression",
      "ja": "A.1。圧縮なしません"
    },
    {
      "indent": 3,
      "text": "The following parameters:",
      "ja": "以下のパラメータ："
    },
    {
      "indent": 3,
      "text": "o Plaintext cookie: \"a state string\"",
      "ja": "O平文クッキー：「状態列」"
    },
    {
      "indent": 3,
      "text": "o AES-CBC-128 key: \"123456789abcdef\"",
      "ja": "O AES-CBC-128キー： \"123456789abcdef\""
    },
    {
      "indent": 3,
      "text": "o HMAC-SHA1 key: \"12345678901234567890\"",
      "ja": "O HMAC-SHA1キー： \"12345678901234567890\""
    },
    {
      "indent": 3,
      "text": "o TID: \"tid\"",
      "ja": "O TIME： \"時間\""
    },
    {
      "indent": 3,
      "text": "o ATIME: 1347265955",
      "ja": "atimeの：1347265955"
    },
    {
      "indent": 3,
      "text": "o IV: \\xb4\\xbd\\xe5\\x24\\xf7\\xf6\\x9d\\x44\\x85\\x30\\xde\\x9d\\xb5\\x55\\xc9\\x4f",
      "ja": "IV O：\\ XB4 \\ XBD \\ xe5 \\ X24 \\ XF7 \\ XF6 \\ x9d \\ X44 \\ X85 \\ X30 \\ XDE \\ x9d \\ XB5 \\ X55 \\ xc9 \\ x4f"
    },
    {
      "indent": 3,
      "text": "produce the following tokens:",
      "ja": "次のトークンを生成します。"
    },
    {
      "indent": 3,
      "text": "o DATA: DqfW4SFqcjBXqSTvF2qnRA",
      "ja": "Oデータ：DqfW4SFqcjBXqSTvF2qnRA"
    },
    {
      "indent": 3,
      "text": "o ATIME: MTM0NzI2NTk1NQ",
      "ja": "O ATIME：MTM0NzI2NTk1NQ"
    },
    {
      "indent": 3,
      "text": "o TID: OHU7M1cqdDQt",
      "ja": "O時間：OHU7M1cqdDQt"
    },
    {
      "indent": 3,
      "text": "o IV: tL3lJPf2nUSFMN6dtVXJTw",
      "ja": "OのIV：tL3lJPf2nUSFMN6dtVXJTw"
    },
    {
      "indent": 3,
      "text": "o AUTHTAG: AznYHKga9mLL8ioi3If_1iy2KSA",
      "ja": "O AUTHTAG：AznYHKga9mLL8ioi3If_1iy2KSA"
    },
    {
      "indent": 0,
      "text": "A.2. Use Compression",
      "ja": "A.2。圧縮を使用"
    },
    {
      "indent": 3,
      "text": "The same parameters as above, except ATIME and IV:",
      "ja": "ATIMEおよびIV以外は上記と同じパラメータ、："
    },
    {
      "indent": 3,
      "text": "o Plaintext cookie: \"a state string\"",
      "ja": "O平文クッキー：「状態列」"
    },
    {
      "indent": 3,
      "text": "o AES-CBC-128 key: \"123456789abcdef\"",
      "ja": "O AES-CBC-128キー： \"123456789abcdef\""
    },
    {
      "indent": 3,
      "text": "o HMAC-SHA1 key: \"12345678901234567890\"",
      "ja": "O HMAC-SHA1キー： \"12345678901234567890\""
    },
    {
      "indent": 3,
      "text": "o TID: \"tid\" o ATIME: 1347281709",
      "ja": "O TIME： \"時間\" Oのatimeが：1347281709"
    },
    {
      "indent": 3,
      "text": "o IV: \\x1d\\xa7\\x6f\\xa0\\xff\\x11\\xd7\\x95\\xe3\\x4b\\xfb\\xa9\\xff\\x65\\xf9\\xc7",
      "ja": "O IV：\\ X1D \\ xa7 \\ x6f \\ XA0 \\ XFF \\ x11の\\ XD7 \\ X95 \\ XE3 \\ x4b \\ XFB \\ xa9 \\ XFF \\ X65 \\ xf9 \\ xc7"
    },
    {
      "indent": 3,
      "text": "produce the following tokens:",
      "ja": "次のトークンを生成します。"
    },
    {
      "indent": 3,
      "text": "o DATA: PbE-ypmQ43M8LzKZ6fMwFg-COrLP2l-Bvgs",
      "ja": "Oデータ：PBE-ypmQ43M8LzKZ6fMwFg-COrLP2l-Bvgs"
    },
    {
      "indent": 3,
      "text": "o ATIME: MTM0NzI4MTcwOQ",
      "ja": "O ATIME：MTM0NzI4MTcwOQ"
    },
    {
      "indent": 3,
      "text": "o TID: akxIKmhbMTE8",
      "ja": "O TIME：akxIKmhbMTE8"
    },
    {
      "indent": 3,
      "text": "o IV: HadvoP8R15XjS_up_2X5xw",
      "ja": "IV HadvoP8R15XjS_up_2X5xw"
    },
    {
      "indent": 3,
      "text": "o AUTHTAG: A6qevPr-ugHQChlr_EiKYWPvpB0",
      "ja": "O AUTHTAG：A6qevPr-ugHQChlr_EiKYWPvpB0"
    },
    {
      "indent": 3,
      "text": "In both cases, the resulting SCS cookie is obtained via ordered concatenation of the produced tokens, as described in Section 3.1.",
      "ja": "セクション3.1で説明したように、両方の場合において、得られたSCSクッキーは、生成トークンの順序付けられた連結を介して得られます。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Stefano Barbato KoanLogic Via Marmolada, 4 Vitorchiano (VT), 01030 Italy",
      "ja": "ステファノBarbato KoanLogic経由マルモラダ、4ヴィトルキアーノ（VT）、イタリア01030"
    },
    {
      "indent": 3,
      "text": "EMail: tat@koanlogic.com",
      "ja": "メールアドレス：tat@koanlogic.com"
    },
    {
      "indent": 3,
      "text": "Steven Dorigotti KoanLogic Via Maso della Pieve 25/C Bolzano, 39100 Italy",
      "ja": "スティーブンDorigotti KoanLogic経由マソデッラ​​・ピエーヴェ25 / Cボルツァーノ、イタリア39100"
    },
    {
      "indent": 3,
      "text": "EMail: stewy@koanlogic.com",
      "ja": "メールアドレス：stewy@koanlogic.com"
    },
    {
      "indent": 3,
      "text": "Thomas Fossati (editor) KoanLogic Via di Sabbiuno 11/5 Bologna, 40136 Italy",
      "ja": "フォッサーティ・トーマス（エディタ）KoanLogicストリートSabbiuno 11/5ボローニャ、イタリア40136"
    },
    {
      "indent": 3,
      "text": "EMail: tho@koanlogic.com",
      "ja": "メールアドレス：tho@koanlogic.com"
    }
  ]
}