{
  "title": {
    "text": "RFC 6455 - The WebSocket Protocol",
    "ja": "RFC 6455 - WebSocketのプロトコル"
  },
  "number": 6455,
  "created_at": "2019-10-31 09:06:16.324070+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          I. Fette\nRequest for Comments: 6455                                  Google, Inc.\nCategory: Standards Track                                    A. Melnikov\nISSN: 2070-1721                                               Isode Ltd.\n                                                           December 2011",
      "raw": true
    },
    {
      "indent": 25,
      "text": "The WebSocket Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host that has opted-in to communications from that code. The security model used for this is the origin-based security model commonly used by web browsers. The protocol consists of an opening handshake followed by basic message framing, layered over TCP. The goal of this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g., using XMLHttpRequest or <iframe>s and long polling).",
      "ja": "WebSocketのプロトコルはオプトインでいるそのコードからの通信にリモート・ホストに制御された環境で信頼できないコードを実行するクライアントとの間の双方向通信を可能にします。このために使用されるセキュリティモデルは、一般的なWebブラウザで使用される起源ベースのセキュリティモデルです。プロトコルはTCP上に積層基本メッセージフレーミング、続いて開口ハンドシェークから成ります。この技術の目的は、複数のHTTP接続を開くことに依存しないサーバとの双方向通信を必要とするブラウザベースのアプリケーションのためのメカニズムを提供することである（例えば、XMLHttpRequestのか、<iframe>のSとロングポーリングを使用）。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6455.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc6455で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2011 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n  1.1.  Background . . . . . . . . . . . . . . . . . . . . . . . .  4\n  1.2.  Protocol Overview  . . . . . . . . . . . . . . . . . . . .  5\n  1.3.  Opening Handshake  . . . . . . . . . . . . . . . . . . . .  6\n  1.4.  Closing Handshake  . . . . . . . . . . . . . . . . . . . .  9\n  1.5.  Design Philosophy  . . . . . . . . . . . . . . . . . . . .  9\n  1.6.  Security Model . . . . . . . . . . . . . . . . . . . . . . 10\n  1.7.  Relationship to TCP and HTTP . . . . . . . . . . . . . . . 11\n  1.8.  Establishing a Connection  . . . . . . . . . . . . . . . . 11\n  1.9.  Subprotocols Using the WebSocket Protocol  . . . . . . . . 12\n2.  Conformance Requirements . . . . . . . . . . . . . . . . . . . 12\n  2.1.  Terminology and Other Conventions  . . . . . . . . . . . . 13\n3.  WebSocket URIs . . . . . . . . . . . . . . . . . . . . . . . . 14\n4.  Opening Handshake  . . . . . . . . . . . . . . . . . . . . . . 14\n  4.1.  Client Requirements  . . . . . . . . . . . . . . . . . . . 14\n  4.2.  Server-Side Requirements . . . . . . . . . . . . . . . . . 20\n    4.2.1.  Reading the Client's Opening Handshake . . . . . . . . 21\n    4.2.2.  Sending the Server's Opening Handshake . . . . . . . . 22\n  4.3.  Collected ABNF for New Header Fields Used in Handshake . . 25\n  4.4.  Supporting Multiple Versions of WebSocket Protocol . . . . 26\n5.  Data Framing . . . . . . . . . . . . . . . . . . . . . . . . . 27\n  5.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . 27\n  5.2.  Base Framing Protocol  . . . . . . . . . . . . . . . . . . 28\n  5.3.  Client-to-Server Masking . . . . . . . . . . . . . . . . . 32\n  5.4.  Fragmentation  . . . . . . . . . . . . . . . . . . . . . . 33\n  5.5.  Control Frames . . . . . . . . . . . . . . . . . . . . . . 36\n    5.5.1.  Close  . . . . . . . . . . . . . . . . . . . . . . . . 36\n    5.5.2.  Ping . . . . . . . . . . . . . . . . . . . . . . . . . 37\n    5.5.3.  Pong . . . . . . . . . . . . . . . . . . . . . . . . . 37\n  5.6.  Data Frames  . . . . . . . . . . . . . . . . . . . . . . . 38\n  5.7.  Examples . . . . . . . . . . . . . . . . . . . . . . . . . 38\n  5.8.  Extensibility  . . . . . . . . . . . . . . . . . . . . . . 39\n6.  Sending and Receiving Data . . . . . . . . . . . . . . . . . . 39\n  6.1.  Sending Data . . . . . . . . . . . . . . . . . . . . . . . 39\n  6.2.  Receiving Data . . . . . . . . . . . . . . . . . . . . . . 40\n7.  Closing the Connection . . . . . . . . . . . . . . . . . . . . 41\n  7.1.  Definitions  . . . . . . . . . . . . . . . . . . . . . . . 41\n    7.1.1.  Close the WebSocket Connection . . . . . . . . . . . . 41\n    7.1.2.  Start the WebSocket Closing Handshake  . . . . . . . . 42\n    7.1.3.  The WebSocket Closing Handshake is Started . . . . . . 42\n    7.1.4.  The WebSocket Connection is Closed . . . . . . . . . . 42\n    7.1.5.  The WebSocket Connection Close Code  . . . . . . . . . 42",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    7.1.6.  The WebSocket Connection Close Reason  . . . . . . . . 43\n    7.1.7.  Fail the WebSocket Connection  . . . . . . . . . . . . 43\n  7.2.  Abnormal Closures  . . . . . . . . . . . . . . . . . . . . 44\n    7.2.1.  Client-Initiated Closure . . . . . . . . . . . . . . . 44\n    7.2.2.  Server-Initiated Closure . . . . . . . . . . . . . . . 44\n    7.2.3.  Recovering from Abnormal Closure . . . . . . . . . . . 44\n  7.3.  Normal Closure of Connections  . . . . . . . . . . . . . . 45\n  7.4.  Status Codes . . . . . . . . . . . . . . . . . . . . . . . 45\n    7.4.1.  Defined Status Codes . . . . . . . . . . . . . . . . . 45\n    7.4.2.  Reserved Status Code Ranges  . . . . . . . . . . . . . 47\n8.  Error Handling . . . . . . . . . . . . . . . . . . . . . . . . 48\n  8.1.  Handling Errors in UTF-8-Encoded Data  . . . . . . . . . . 48\n9.  Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . 48\n  9.1.  Negotiating Extensions . . . . . . . . . . . . . . . . . . 48\n  9.2.  Known Extensions . . . . . . . . . . . . . . . . . . . . . 50\n10. Security Considerations  . . . . . . . . . . . . . . . . . . . 50\n  10.1. Non-Browser Clients  . . . . . . . . . . . . . . . . . . . 50\n  10.2. Origin Considerations  . . . . . . . . . . . . . . . . . . 50\n  10.3. Attacks On Infrastructure (Masking)  . . . . . . . . . . . 51\n  10.4. Implementation-Specific Limits . . . . . . . . . . . . . . 52\n  10.5. WebSocket Client Authentication  . . . . . . . . . . . . . 53\n  10.6. Connection Confidentiality and Integrity . . . . . . . . . 53\n  10.7. Handling of Invalid Data . . . . . . . . . . . . . . . . . 53\n  10.8. Use of SHA-1 by the WebSocket Handshake  . . . . . . . . . 54\n11. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 54\n  11.1. Registration of New URI Schemes  . . . . . . . . . . . . . 54\n    11.1.1. Registration of \"ws\" Scheme  . . . . . . . . . . . . . 54\n    11.1.2. Registration of \"wss\" Scheme . . . . . . . . . . . . . 55\n  11.2. Registration of the \"WebSocket\" HTTP Upgrade Keyword . . . 56\n  11.3. Registration of New HTTP Header Fields . . . . . . . . . . 57\n    11.3.1. Sec-WebSocket-Key  . . . . . . . . . . . . . . . . . . 57\n    11.3.2. Sec-WebSocket-Extensions . . . . . . . . . . . . . . . 58\n    11.3.3. Sec-WebSocket-Accept . . . . . . . . . . . . . . . . . 58\n    11.3.4. Sec-WebSocket-Protocol . . . . . . . . . . . . . . . . 59\n    11.3.5. Sec-WebSocket-Version  . . . . . . . . . . . . . . . . 60\n  11.4. WebSocket Extension Name Registry  . . . . . . . . . . . . 61\n  11.5. WebSocket Subprotocol Name Registry  . . . . . . . . . . . 61\n  11.6. WebSocket Version Number Registry  . . . . . . . . . . . . 62\n  11.7. WebSocket Close Code Number Registry . . . . . . . . . . . 64\n  11.8. WebSocket Opcode Registry  . . . . . . . . . . . . . . . . 65\n  11.9. WebSocket Framing Header Bits Registry . . . . . . . . . . 66\n12. Using the WebSocket Protocol from Other Specifications . . . . 66\n13. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 67\n14. References . . . . . . . . . . . . . . . . . . . . . . . . . . 68\n  14.1. Normative References . . . . . . . . . . . . . . . . . . . 68\n  14.2. Informative References . . . . . . . . . . . . . . . . . . 69",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. Background",
      "section_title": true,
      "ja": "1.1. バックグラウンド"
    },
    {
      "indent": 3,
      "text": "_This section is non-normative._",
      "ja": "_thisセクションでは、非normative._です"
    },
    {
      "indent": 3,
      "text": "Historically, creating web applications that need bidirectional communication between a client and a server (e.g., instant messaging and gaming applications) has required an abuse of HTTP to poll the server for updates while sending upstream notifications as distinct HTTP calls [RFC6202].",
      "ja": "歴史的には、クライアントとサーバの間で双方向通信を必要とするWebアプリケーションを作成する（例えば、インスタントメッセージング、ゲームアプリケーション）が異なるHTTPコール[RFC6202]として上流通知を送信しながら、更新のためにサーバをポーリングするHTTPの不正使用を必要としています。"
    },
    {
      "indent": 3,
      "text": "This results in a variety of problems:",
      "ja": "これは、さまざまな問題になり："
    },
    {
      "indent": 3,
      "text": "o The server is forced to use a number of different underlying TCP connections for each client: one for sending information to the client and a new one for each incoming message.",
      "ja": "クライアントと各着信メッセージのために新しいものに情報を送信するために1：Oサーバは、クライアントごとに異なる基本的なTCP接続の数を使用するように強制されます。"
    },
    {
      "indent": 3,
      "text": "o The wire protocol has a high overhead, with each client-to-server message having an HTTP header.",
      "ja": "ワイヤプロトコルoを各クライアントからサーバーへのメッセージは、HTTPヘッダーを有する、高いオーバーヘッドを有しています。"
    },
    {
      "indent": 3,
      "text": "o The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.",
      "ja": "Oクライアント側のスクリプトが応答を追跡するための着信接続への発信接続からのマッピングを維持することを余儀なくされます。"
    },
    {
      "indent": 3,
      "text": "A simpler solution would be to use a single TCP connection for traffic in both directions. This is what the WebSocket Protocol provides. Combined with the WebSocket API [WSAPI], it provides an alternative to HTTP polling for two-way communication from a web page to a remote server.",
      "ja": "簡単な解決策は、両方向のトラフィックのための単一のTCP接続を使用することです。これは、WebSocketのプロトコルが提供するものです。 WebSocket API [WSAPI]と組み合わせることで、それは、リモートサーバーへのWebページから双方向通信のためのHTTPポーリングの代替手段を提供します。"
    },
    {
      "indent": 3,
      "text": "The same technique can be used for a variety of web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.",
      "ja": "同じテクニックは、Webアプリケーションのさまざまな使用することができます：ゲームなど、株価表示、同時編集とマルチユーザアプリケーション、リアルタイムでサーバー側のサービスを公開するユーザインタフェース、"
    },
    {
      "indent": 3,
      "text": "The WebSocket Protocol is designed to supersede existing bidirectional communication technologies that use HTTP as a transport layer to benefit from existing infrastructure (proxies, filtering, authentication). Such technologies were implemented as trade-offs between efficiency and reliability because HTTP was not initially meant to be used for bidirectional communication (see [RFC6202] for further discussion). The WebSocket Protocol attempts to address the goals of existing bidirectional HTTP technologies in the context of the existing HTTP infrastructure; as such, it is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries, even if this implies some complexity specific to the current environment. However, the design does not limit WebSocket to HTTP, and future implementations could use a simpler handshake over a dedicated port without reinventing the entire protocol. This last point is important because the traffic patterns of interactive messaging do not closely match standard HTTP traffic and can induce unusual loads on some components.",
      "ja": "WebSocketのプロトコルは、既存のインフラストラクチャ（プロキシ、フィルタリング、認証）から利益を得るために、トランスポート層としてHTTPを使用する既存の双方向通信技術に取って代わるように設計されています。 HTTPは、最初に（さらなる議論のために[RFC6202]を参照）、双方向通信のために使用されることを意図していなかったので、このような技術は、効率と信頼性との間のトレードオフとして実施されました。 WebSocketプロトコルは、既存のHTTPインフラストラクチャのコンテキスト内の既存の双方向のHTTP技術の目標に対処しようとします。以下のような、現在の環境に固有のいくつかの複雑さを暗示していても、HTTPポート80および443で動作するようにだけでなく、HTTPプロキシおよび仲介をサポートするように設計されています。しかし、デザインはHTTPへのWebSocketを限定するものではなく、将来の実装は、プロトコル全体を再発明することなく、専用のポートを介してシンプルなハンドシェイクを使用することができます。インタラクティブメッセージングのトラフィックパターンが密接に標準のHTTPトラフィックと一致しないと、いくつかのコンポーネントに珍しい負荷を誘導することができるので、この最後の点は重要です。"
    },
    {
      "indent": 0,
      "text": "1.2. Protocol Overview",
      "section_title": true,
      "ja": "1.2. プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "_This section is non-normative._",
      "ja": "_thisセクションでは、非normative._です"
    },
    {
      "indent": 3,
      "text": "The protocol has two parts: a handshake and the data transfer.",
      "ja": "ハンドシェークデータ転送：プロトコルは、2つの部分を有しています。"
    },
    {
      "indent": 3,
      "text": "The handshake from the client looks as follows:",
      "ja": "次のようにクライアントからのハンドシェイクが見えます："
    },
    {
      "indent": 8,
      "text": "GET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nOrigin: http://example.com\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The handshake from the server looks as follows:",
      "ja": "次のようにサーバーからのハンドシェイクが見えます："
    },
    {
      "indent": 8,
      "text": "HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\nSec-WebSocket-Protocol: chat",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The leading line from the client follows the Request-Line format. The leading line from the server follows the Status-Line format. The Request-Line and Status-Line productions are defined in [RFC2616].",
      "ja": "クライアントからの引き出し線は、Request-ラインのフォーマットに従っています。サーバーからの引き出し線は、ステータスラインのフォーマットに従っています。リクエストラインとステータスラインの生産は、[RFC2616]で定義されています。"
    },
    {
      "indent": 3,
      "text": "An unordered set of header fields comes after the leading line in both cases. The meaning of these header fields is specified in Section 4 of this document. Additional header fields may also be present, such as cookies [RFC6265]. The format and parsing of headers is as defined in [RFC2616].",
      "ja": "ヘッダフィールドの順不同のセットは、いずれの場合も、大手行の後に来ます。これらのヘッダーフィールドの意味は、このドキュメントのセクション4で指定されています。追加のヘッダフィールドはまた、クッキー[RFC6265]として、存在してもよいです。ヘッダのフォーマット及び解析は[RFC2616]で定義される通りです。"
    },
    {
      "indent": 3,
      "text": "Once the client and server have both sent their handshakes, and if the handshake was successful, then the data transfer part starts. This is a two-way communication channel where each side can, independently from the other, send data at will.",
      "ja": "いったんクライアントとサーバはその握手を送ってきたの両方、およびハンドシェイクが成功した場合、データ転送部が開始されます。これは、各辺が、互いに独立してから、自由にデータを送信することができる双方向通信チャネルです。"
    },
    {
      "indent": 3,
      "text": "After a successful handshake, clients and servers transfer data back and forth in conceptual units referred to in this specification as \"messages\". On the wire, a message is composed of one or more frames. The WebSocket message does not necessarily correspond to a particular network layer framing, as a fragmented message may be coalesced or split by an intermediary.",
      "ja": "成功した握手の後、クライアントとサーバは、「メッセージ」として、本明細書でいう概念単位で前後にデータを転送します。ワイヤ上の、メッセージは、1つ以上のフレームから構成されています。断片化されたメッセージは、仲介によって合体または分割することができるようなWebSocketメッセージは、必ずしも、特定のネットワークレイヤフレーミングに対応しません。"
    },
    {
      "indent": 3,
      "text": "A frame has an associated type. Each frame belonging to the same message contains the same type of data. Broadly speaking, there are types for textual data (which is interpreted as UTF-8 [RFC3629] text), binary data (whose interpretation is left up to the application), and control frames (which are not intended to carry data for the application but instead for protocol-level signaling, such as to signal that the connection should be closed). This version of the protocol defines six frame types and leaves ten reserved for future use.",
      "ja": "フレームは、関連付けられたタイプを有しています。同じメッセージに属する各フレームは、同じタイプのデータが含まれています。大まかに言えば、アプリケーションのためのデータを搬送することを意図していない（UTF-8 [RFC3629]テキストとして解釈される）テキストデータのタイプ（その解釈はアプリケーションに任されている）、バイナリデータ、および制御フレームは、（存在しますその代わりに、このような接続がクローズされるべきであることを通知するように、プロトコルレベルのシグナリングのために）。プロトコルのこのバージョンでは、6つのフレームタイプを定義し、将来の使用のために予約10を残します。"
    },
    {
      "indent": 0,
      "text": "1.3. Opening Handshake",
      "section_title": true,
      "ja": "1.3. ハンドシェイクを開きます"
    },
    {
      "indent": 3,
      "text": "_This section is non-normative._",
      "ja": "_thisセクションでは、非normative._です"
    },
    {
      "indent": 3,
      "text": "The opening handshake is intended to be compatible with HTTP-based server-side software and intermediaries, so that a single port can be used by both HTTP clients talking to that server and WebSocket clients talking to that server. To this end, the WebSocket client's handshake is an HTTP Upgrade request:",
      "ja": "開口ハンドシェイクは、単一のポートがそのサーバに話し、そのサーバーとのWebSocketクライアントに話両方のHTTPクライアントが使用できるように、HTTPベースのサーバー側のソフトウェア及び媒体と互換性があるように意図されています。このため、WebSocketのクライアントのハンドシェイクがHTTPのアップグレード要求であります："
    },
    {
      "indent": 8,
      "text": "GET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\nOrigin: http://example.com\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In compliance with [RFC2616], header fields in the handshake may be sent by the client in any order, so the order in which different header fields are received is not significant.",
      "ja": "[RFC2616]に準拠して、ハンドシェイクのヘッダフィールドは、任意の順序でクライアントによって送信されることができるので、異なるヘッダフィールドが受信される順序は重要ではありません。"
    },
    {
      "indent": 3,
      "text": "The \"Request-URI\" of the GET method [RFC2616] is used to identify the endpoint of the WebSocket connection, both to allow multiple domains to be served from one IP address and to allow multiple WebSocket endpoints to be served by a single server.",
      "ja": "GETメソッド[RFC2616]の「リクエストURIは」両方が複数のドメイン1つのIPアドレスから提供されることを可能にし、複数のWebSocketエンドポイントは、単一のサーバによって提供されるように、WebSocketの接続のエンドポイントを識別するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The client includes the hostname in the |Host| header field of its handshake as per [RFC2616], so that both the client and the server can verify that they agree on which host is in use.",
      "ja": "|ホスト|クライアントがでホスト名を含んでいますクライアントとサーバーの両方が、彼らが同意することを確認できるように、[RFC2616]あたりとしてのハンドシェイクのヘッダフィールドは、どのホストが使用されています。"
    },
    {
      "indent": 3,
      "text": "Additional header fields are used to select options in the WebSocket Protocol. Typical options available in this version are the subprotocol selector (|Sec-WebSocket-Protocol|), list of extensions support by the client (|Sec-WebSocket-Extensions|), |Origin| header field, etc. The |Sec-WebSocket-Protocol| request-header field can be used to indicate what subprotocols (application-level protocols layered over the WebSocket Protocol) are acceptable to the client. The server selects one or none of the acceptable protocols and echoes that value in its handshake to indicate that it has selected that protocol.",
      "ja": "追加のヘッダフィールドはのWebSocketプロトコルのオプションを選択するために使用されています。 （|秒-のWebSocket-プロトコル|）、クライアントによる拡張サポートのリスト（|秒-のWebSocket-拡張機能|）、|起源このバージョンで利用可能な一般的なオプションは、サブプロトコルセレクタです|ヘッダフィールドなど|秒-のWebSocket-プロトコル|リクエストヘッダフィールドは、サブプロトコル（のWebSocketプロトコル上に積層アプリケーションレベルのプロトコル）がクライアントに許容可能であるかを示すために使用することができます。サーバは、許容可能なプロトコルの一つまたはどれを選択して、そのプロトコルを選択したことを示すために、そのハンドシェイクでその値をエコー。"
    },
    {
      "indent": 8,
      "text": "Sec-WebSocket-Protocol: chat",
      "ja": "SEC-のWebSocket-プロトコル：チャット"
    },
    {
      "indent": 3,
      "text": "The |Origin| header field [RFC6454] is used to protect against unauthorized cross-origin use of a WebSocket server by scripts using the WebSocket API in a web browser. The server is informed of the script origin generating the WebSocket connection request. If the server does not wish to accept connections from this origin, it can choose to reject the connection by sending an appropriate HTTP error code. This header field is sent by browser clients; for non-browser clients, this header field may be sent if it makes sense in the context of those clients.",
      "ja": "|起源|ヘッダフィールド[RFC6454]は、WebブラウザでのWebSocket APIを使用してスクリプトでのWebSocketサーバの不正クロスオリジンの使用から保護するために使用されています。サーバーはWebSocketの接続要求を生成するスクリプト起源が通知されます。サーバはこの原点からの接続を受け入れたくない場合は、適切なHTTPエラーコードを送信することにより、接続を拒否するかを選択することができます。このヘッダーフィールドは、ブラウザクライアントによって送信されます。それはそれらのクライアントのコンテキストで理にかなっている場合は、ブラウザ以外のクライアントのために、このヘッダフィールドが送信されることがあります。"
    },
    {
      "indent": 3,
      "text": "Finally, the server has to prove to the client that it received the client's WebSocket handshake, so that the server doesn't accept connections that are not WebSocket connections. This prevents an attacker from tricking a WebSocket server by sending it carefully crafted packets using XMLHttpRequest [XMLHttpRequest] or a form submission.",
      "ja": "最後に、サーバは、サーバが接続をWebSocketをされていない接続を受け付けないように、それは、クライアントののWebSocketハンドシェイクを受信したクライアントに証明しなければなりません。これは、XMLHttpRequestの[のXMLHttpRequest]またはフォームの送信を使用して巧妙に作成されたパケットを送信することでのWebSocketサーバーをだましからの攻撃を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "To prove that the handshake was received, the server has to take two pieces of information and combine them to form a response. The first piece of information comes from the |Sec-WebSocket-Key| header field in the client handshake:",
      "ja": "ハンドシェイクを受信したことを証明するために、サーバーは、2つの情報を取得し、応答を形成するためにそれらを結合する必要があります。秒-のWebSocketキー|最初の情報はから来ています|クライアントハンドシェークのヘッダフィールド："
    },
    {
      "indent": 8,
      "text": "Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==",
      "ja": "SEC-のWebSocket-キー：dGhlIHNhbXBsZSBub25jZQ =="
    },
    {
      "indent": 3,
      "text": "For this header field, the server has to take the value (as present in the header field, e.g., the base64-encoded [RFC4648] version minus any leading and trailing whitespace) and concatenate this with the Globally Unique Identifier (GUID, [RFC4122]) \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\" in string form, which is unlikely to be used by network endpoints that do not understand the WebSocket Protocol. A SHA-1 hash (160 bits) [FIPS.180-3], base64-encoded (see Section 4 of [RFC4648]), of this concatenation is then returned in the server's handshake.",
      "ja": "このヘッダフィールドに、サーバは、グローバル一意識別子（GUID、[RFC4122でこれを（例えば、base64エンコード[RFC4648]バージョンマイナス任意の先頭と末尾の空白ヘッダフィールド内に存在するように）値を取ると連結しなければなりません]）「258EAFA5-E914-47DA-95CA-C5AB0DC85B11」のWebSocketプロトコルを理解していないネットワークエンドポイントで使用されにくい文字列形式、インチSHA-1ハッシュ（160ビット）[FIPS.180-3]、base64エンコード（[RFC4648]のセクション4を参照）、この連結のは、サーバのハンドシェークに返されます。"
    },
    {
      "indent": 3,
      "text": "Concretely, if as in the example above, the |Sec-WebSocket-Key| header field had the value \"dGhlIHNhbXBsZSBub25jZQ==\", the server would concatenate the string \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\" to form the string \"dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11\". The server would then take the SHA-1 hash of this, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded (see Section 4 of [RFC4648]), to give the value \"s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\". This value would then be echoed in the |Sec-WebSocket-Accept| header field.",
      "ja": "具体的には、もし、上記の例のように|秒-のWebSocketキー|ヘッダフィールドは、文字列 \"dGhlIHNhbXBsZSBub25jZQ == 258EAFA5-E914-47DA-95CA-C5AB0DC85B11\" を形成するために、サーバは、文字列を連結することになる、 \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11を\" 値 \"dGhlIHNhbXBsZSBub25jZQ ==\" を有していました。サーバは、値0xb3 0x7Aの0x4f 0x2c 0xc0から0x62 0x16 0x90を0x4f 0xf6 0x46の0x06で0xcf 0x38 0x59 0x45コード（0xB2）0xbe 0xc4 0xeaを与え、これのSHA-1ハッシュを取るだろう。この値は、base64エンコード（[RFC4648]のセクション4を参照）、値を与える「s3pPLMBiTxaQ9kYGzzhZRbK + xOo =」です。秒-のWebSocket-受け入れ|この値は、その後にエコーされます|ヘッダフィールド。"
    },
    {
      "indent": 3,
      "text": "The handshake from the server is much simpler than the client handshake. The first line is an HTTP Status-Line, with the status code 101:",
      "ja": "サーバーからのハンドシェイクは、クライアントハンドシェークよりもはるかに簡単です。最初の行はステータスコード101と、HTTPステータスラインです。"
    },
    {
      "indent": 8,
      "text": "HTTP/1.1 101 Switching Protocols",
      "ja": "HTTP / 1.1 101スイッチングプロトコル"
    },
    {
      "indent": 3,
      "text": "Any status code other than 101 indicates that the WebSocket handshake has not completed and that the semantics of HTTP still apply. The headers follow the status code.",
      "ja": "101以外のステータスコードは、のWebSocketハンドシェイクが完了していないことやHTTPのセマンティクスがまだ適用されていることを示しています。ヘッダは、ステータスコードに従ってください。"
    },
    {
      "indent": 3,
      "text": "The |Connection| and |Upgrade| header fields complete the HTTP Upgrade. The |Sec-WebSocket-Accept| header field indicates whether the server is willing to accept the connection. If present, this header field must include a hash of the client's nonce sent in |Sec-WebSocket-Key| along with a predefined GUID. Any other value must not be interpreted as an acceptance of the connection by the server.",
      "ja": "|接続|そして|アップグレード|ヘッダフィールドは、HTTPのアップグレードを完了します。 |秒-のWebSocket-受け入れ|ヘッダフィールドは、サーバが接続を受け入れるかどうかを示します。存在する場合、このヘッダフィールドが送られてきたクライアントのナンスのハッシュを含める必要があります|秒-のWebSocketキー|事前に定義されたGUIDと一緒に。他の値は、サーバによる接続の受け入れと解釈してはなりません。"
    },
    {
      "indent": 8,
      "text": "HTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=",
      "raw": true
    },
    {
      "indent": 3,
      "text": "These fields are checked by the WebSocket client for scripted pages. If the |Sec-WebSocket-Accept| value does not match the expected value, if the header field is missing, or if the HTTP status code is not 101, the connection will not be established, and WebSocket frames will not be sent.",
      "ja": "これらのフィールドは、スクリプトページのためのWebSocketクライアントによってチェックされます。もし|秒-のWebSocket-受け入れ|ヘッダフィールドが欠落している場合、値は、期待値と一致しない、またはHTTPステータスコードが101でない場合、接続が確立されないであろう、とのWebSocketフレームが送信されません。"
    },
    {
      "indent": 3,
      "text": "Option fields can also be included. In this version of the protocol, the main option field is |Sec-WebSocket-Protocol|, which indicates the subprotocol that the server has selected. WebSocket clients verify that the server included one of the values that was specified in the WebSocket client's handshake. A server that speaks multiple subprotocols has to make sure it selects one based on the client's handshake and specifies it in its handshake.",
      "ja": "オプションフィールドを含めることもできます。秒-のWebSocket-Protocolは| |、サーバーが選択したサブプロトコルを示しているプロトコルのこのバージョンでは、メインオプションフィールドがあります。 WebSocketのクライアントは、サーバがクライアントのWebSocketの握手で指定された値のいずれかが含まれることを確認します。複数のサブプロトコルを話すサーバは、クライアントの握手に基づいて一方を選択し、その握手でそれを指定することを確認する必要があります。"
    },
    {
      "indent": 8,
      "text": "Sec-WebSocket-Protocol: chat",
      "ja": "SEC-のWebSocket-プロトコル：チャット"
    },
    {
      "indent": 3,
      "text": "The server can also set cookie-related option fields to _set_ cookies, as described in [RFC6265].",
      "ja": "[RFC6265]で説明したように、サーバはまた、クッキーを_set_するためにクッキー関連のオプションフィールドを設定することができます。"
    },
    {
      "indent": 0,
      "text": "1.4. Closing Handshake",
      "section_title": true,
      "ja": "1.4. ハンドシェイクを閉じます"
    },
    {
      "indent": 3,
      "text": "_This section is non-normative._",
      "ja": "_thisセクションでは、非normative._です"
    },
    {
      "indent": 3,
      "text": "The closing handshake is far simpler than the opening handshake.",
      "ja": "クロージングハンドシェイクは、開口部の握手よりもはるかに簡単です。"
    },
    {
      "indent": 3,
      "text": "Either peer can send a control frame with data containing a specified control sequence to begin the closing handshake (detailed in Section 5.5.1). Upon receiving such a frame, the other peer sends a Close frame in response, if it hasn't already sent one. Upon receiving _that_ control frame, the first peer then closes the connection, safe in the knowledge that no further data is forthcoming.",
      "ja": "いずれかのピアは、（5.5.1項で詳述）閉鎖ハンドシェイクを開始するために、指定された制御配列を含むデータと制御フレームを送信することができます。既にいずれかを送信していない場合、そのようなフレームを受信すると、他のピアは、応答して閉じるフレームを送信します。 _that_制御フレームを受信すると、最初のピアは、その後さらなるデータが用意されていない知識で安全な接続を閉じます。"
    },
    {
      "indent": 3,
      "text": "After sending a control frame indicating the connection should be closed, a peer does not send any further data; after receiving a control frame indicating the connection should be closed, a peer discards any further data received.",
      "ja": "閉鎖されなければならない接続を示す制御フレームを送信した後、ピアは、任意のさらなるデータを送信しません。閉鎖されなければならない接続を示す制御フレームを受信した後、ピアは、受信したさらなるデータを破棄する。"
    },
    {
      "indent": 3,
      "text": "It is safe for both peers to initiate this handshake simultaneously.",
      "ja": "両方のピアが同時にこのハンドシェイクを開始することは安全です。"
    },
    {
      "indent": 3,
      "text": "The closing handshake is intended to complement the TCP closing handshake (FIN/ACK), on the basis that the TCP closing handshake is not always reliable end-to-end, especially in the presence of intercepting proxies and other intermediaries.",
      "ja": "クロージングハンドシェイクは、TCP閉鎖ハンドシェイクが、特にプロキシやその他の仲介を傍受の存在下で、常に信頼性の高いエンドツーエンドではないということに基づいて、TCP閉鎖ハンドシェイク（FIN / ACK）を補完することを意図しています。"
    },
    {
      "indent": 3,
      "text": "By sending a Close frame and waiting for a Close frame in response, certain cases are avoided where data may be unnecessarily lost. For instance, on some platforms, if a socket is closed with data in the receive queue, a RST packet is sent, which will then cause recv() to fail for the party that received the RST, even if there was data waiting to be read.",
      "ja": "データが不必要に失われる可能性がどこ閉じるフレームを送信し、それに応答して閉じるフレームを待っていることで、特定のケースが回避されます。例えばソケットが受信キュー内のデータと閉じている場合、一部のプラットフォームでは、RSTパケットが送信され、その後、（RECVの原因となる）RSTを受けたパーティーのために失敗する、ことを待っているデータがあった場合でも、読む。"
    },
    {
      "indent": 0,
      "text": "1.5. Design Philosophy",
      "section_title": true,
      "ja": "1.5. デザイン哲学"
    },
    {
      "indent": 3,
      "text": "_This section is non-normative._",
      "ja": "_thisセクションでは、非normative._です"
    },
    {
      "indent": 3,
      "text": "The WebSocket Protocol is designed on the principle that there should be minimal framing (the only framing that exists is to make the protocol frame-based instead of stream-based and to support a distinction between Unicode text and binary frames). It is expected that metadata would be layered on top of WebSocket by the application layer, in the same way that metadata is layered on top of TCP by the application layer (e.g., HTTP).",
      "ja": "WebSocketのプロトコルが最小フレーミングがあるべきであるという原則に基づいて設計されている（存在のみフレーミングプロトコル・フレームベースの代わりにストリームベースおよびユニコードテキストとバイナリフレーム間の区別をサポートするようにすることです）。メタデータは、メタデータは、アプリケーション層（例えば、HTTP）によってTCPの上部に積層されるのと同じように、アプリケーション層でのWebSocketの上部に積層されることが期待されます。"
    },
    {
      "indent": 3,
      "text": "Conceptually, WebSocket is really just a layer on top of TCP that does the following:",
      "ja": "概念的には、WebSocketのは本当に、次んTCPの上だけの層です。"
    },
    {
      "indent": 3,
      "text": "o adds a web origin-based security model for browsers",
      "ja": "oはブラウザのウェブ起源ベースのセキュリティモデルを追加します"
    },
    {
      "indent": 3,
      "text": "o adds an addressing and protocol naming mechanism to support multiple services on one port and multiple host names on one IP address",
      "ja": "oは1つのIPアドレスを1つのポートと複数のホスト名に複数のサービスをサポートするためのアドレッシングおよびプロトコル命名メカニズムを追加します"
    },
    {
      "indent": 3,
      "text": "o layers a framing mechanism on top of TCP to get back to the IP packet mechanism that TCP is built on, but without length limits",
      "ja": "層バックTCPが上に構築されたIPパケットのメカニズムに取得するTCPの上のフレーミングメカニズムが、長さ制限なしO"
    },
    {
      "indent": 3,
      "text": "o includes an additional closing handshake in-band that is designed to work in the presence of proxies and other intermediaries",
      "ja": "oはプロキシと他の媒体の存在下で動作するように設計された帯域内の追加の閉鎖ハンドシェイクを含みます"
    },
    {
      "indent": 3,
      "text": "Other than that, WebSocket adds nothing. Basically it is intended to be as close to just exposing raw TCP to script as possible given the constraints of the Web. It's also designed in such a way that its servers can share a port with HTTP servers, by having its handshake be a valid HTTP Upgrade request. One could conceptually use other protocols to establish client-server messaging, but the intent of WebSockets is to provide a relatively simple protocol that can coexist with HTTP and deployed HTTP infrastructure (such as proxies) and that is as close to TCP as is safe for use with such infrastructure given security considerations, with targeted additions to simplify usage and keep simple things simple (such as the addition of message semantics).",
      "ja": "それ以外は、WebSocketのは、何も加えません。基本的には、Webの制約を与えることができ、スクリプトにちょうどさらす生のTCPに近いことを意図しています。また、そのサーバがそのハンドシェイクが有効なHTTPのアップグレード要求であることによって、HTTPサーバとポートを共有できるように設計されています。一つは、概念的には、クライアント - サーバメッセージングを確立するために、他のプロトコルを使用することができますが、WebSocketをの意図は、HTTPと共存することができ、比較的単純なプロトコルを提供することにある（たとえば、プロキシなど）HTTPインフラストラクチャを展開し、それがために安全であるとして、TCPに近いです使用方法を簡素化し、（このようなメッセージの意味論の追加など）の単純な物事をシンプルに保つために標的に追加して、セキュリティ上の配慮を与え、そのようなインフラストラクチャで使用しています。"
    },
    {
      "indent": 3,
      "text": "The protocol is intended to be extensible; future versions will likely introduce additional concepts such as multiplexing.",
      "ja": "プロトコルは拡張可能であることが意図されています。将来のバージョンは、おそらく、このような多重化などの追加の概念を紹介します。"
    },
    {
      "indent": 0,
      "text": "1.6. Security Model",
      "section_title": true,
      "ja": "1.6. セキュリティモデル"
    },
    {
      "indent": 3,
      "text": "_This section is non-normative._",
      "ja": "_thisセクションでは、非normative._です"
    },
    {
      "indent": 3,
      "text": "The WebSocket Protocol uses the origin model used by web browsers to restrict which web pages can contact a WebSocket server when the WebSocket Protocol is used from a web page. Naturally, when the WebSocket Protocol is used by a dedicated client directly (i.e., not from a web page through a web browser), the origin model is not useful, as the client can provide any arbitrary origin string.",
      "ja": "WebSocketプロトコルのWebSocketプロトコルは、Webページから使用されたときにWebページがWebSocketのサーバーに接続できるかを制限するために、Webブラウザで使用する原点モデルを使用しています。 WebSocketのプロトコルが直接専用クライアントで使用される場合、クライアントは、任意の起源の文字列を提供することができるように当然のことながら、（すなわち、しないウェブブラウザを介してウェブページから）、原点モデルは、有用ではありません。"
    },
    {
      "indent": 3,
      "text": "This protocol is intended to fail to establish a connection with servers of pre-existing protocols like SMTP [RFC5321] and HTTP, while allowing HTTP servers to opt-in to supporting this protocol if desired. This is achieved by having a strict and elaborate handshake and by limiting the data that can be inserted into the connection before the handshake is finished (thus limiting how much the server can be influenced).",
      "ja": "HTTPサーバはオプトインしたい場合は、このプロトコルをサポートすることを可能にしながら、このプロトコルは、SMTP [RFC5321]とHTTPなどの既存のプロトコルのサーバとの接続を確立するために失敗することを意図しています。これは、厳格かつ精巧なハンドシェイクを有することとハンドシェイクが（したがって、サーバーが影響を受ける可能性がどのくらいの制限）が終了する前に、接続中に挿入することができるデータを制限することによって達成されます。"
    },
    {
      "indent": 3,
      "text": "It is similarly intended to fail to establish a connection when data from other protocols, especially HTTP, is sent to a WebSocket server, for example, as might happen if an HTML \"form\" were submitted to a WebSocket server. This is primarily achieved by requiring that the server prove that it read the handshake, which it can only do if the handshake contains the appropriate parts, which can only be sent by a WebSocket client. In particular, at the time of writing of this specification, fields starting with |Sec-| cannot be set by an attacker from a web browser using only HTML and JavaScript APIs such as XMLHttpRequest [XMLHttpRequest].",
      "ja": "同様に他のプロトコル、特にHTTPからのデータは、例えば、WebSocketのサーバーに送信されたときにHTML「フォーム」がWebSocketのサーバーに提出された場合に発生する可能性があるとして、接続を確立するために失敗することを意図しています。これは主に、サーバーが、それは握手だけのWebSocketクライアントによって送信することができ、適切な部品を、含まれている場合にのみ行うことができますハンドシェイクを、読んでいることを証明することを要求することによって達成されます。 SEC-| |特に、この仕様書の執筆時点では、フィールドが始まりますこのようにXMLHttpRequest [XMLHttpRequestの]としてのみHTMLやJavaScriptのAPIを使用して、Webブラウザからの攻撃者によって設定することはできません。"
    },
    {
      "indent": 0,
      "text": "1.7. Relationship to TCP and HTTP",
      "section_title": true,
      "ja": "1.7.  TCPとHTTPとの関係"
    },
    {
      "indent": 3,
      "text": "_This section is non-normative._",
      "ja": "_thisセクションでは、非normative._です"
    },
    {
      "indent": 3,
      "text": "The WebSocket Protocol is an independent TCP-based protocol. Its only relationship to HTTP is that its handshake is interpreted by HTTP servers as an Upgrade request.",
      "ja": "WebSocketプロトコルは、独立したTCPベースのプロトコルです。 HTTPへの唯一の関係は、そのハンドシェイクがアップグレード要求としてHTTPサーバによって解釈されていることです。"
    },
    {
      "indent": 3,
      "text": "By default, the WebSocket Protocol uses port 80 for regular WebSocket connections and port 443 for WebSocket connections tunneled over Transport Layer Security (TLS) [RFC2818].",
      "ja": "デフォルトでは、WebSocketのプロトコルは、通常のWebSocket接続およびTransport Layer Security（TLS）[RFC2818]でトンネリングのWebSocket接続用のポート443用のポート80を使用しています。"
    },
    {
      "indent": 0,
      "text": "1.8. Establishing a Connection",
      "section_title": true,
      "ja": "1.8. 接続の確立"
    },
    {
      "indent": 3,
      "text": "_This section is non-normative._",
      "ja": "_thisセクションでは、非normative._です"
    },
    {
      "indent": 3,
      "text": "When a connection is to be made to a port that is shared by an HTTP server (a situation that is quite likely to occur with traffic to ports 80 and 443), the connection will appear to the HTTP server to be a regular GET request with an Upgrade offer. In relatively simple setups with just one IP address and a single server for all traffic to a single hostname, this might allow a practical way for systems based on the WebSocket Protocol to be deployed. In more elaborate setups (e.g., with load balancers and multiple servers), a dedicated set of hosts for WebSocket connections separate from the HTTP servers is probably easier to manage. At the time of writing of this specification, it should be noted that connections on ports 80 and 443 have significantly different success rates, with connections on port 443 being significantly more likely to succeed, though this may change with time.",
      "ja": "接続はHTTPサーバ（ポート80および443へのトラフィックで発生するのは非常に可能性のある状況）によって共有されているポートに行われるべきときに、接続はとの定期的なGETリクエストするHTTPサーバに表示されますアップグレードの提供。ただ一つのIPアドレスおよび単一のホスト名へのすべてのトラフィックのための単一のサーバで、比較的簡単なセットアップでは、これが展開されるのWebSocketプロトコルに基づいたシステムのための実用的な方法が可能かもしれません。 （ロードバランサと複数のサーバと、例えば、）より精巧なセットアップ、のWebSocket接続のホストの専用セットにHTTPサーバとは別の、おそらく管理が容易です。この仕様書の執筆時点では、時間とともに変化するかもしれませんが、ポート80と443の接続は、ポート443上の接続が成功する可能性が有意に高かっことで、大幅に異なる成功率を持っていることに留意すべきです。"
    },
    {
      "indent": 0,
      "text": "1.9. Subprotocols Using the WebSocket Protocol",
      "section_title": true,
      "ja": "1.9.  WebSocketプロトコルを使用したサブプロトコル"
    },
    {
      "indent": 3,
      "text": "_This section is non-normative._",
      "ja": "_thisセクションでは、非normative._です"
    },
    {
      "indent": 3,
      "text": "The client can request that the server use a specific subprotocol by including the |Sec-WebSocket-Protocol| field in its handshake. If it is specified, the server needs to include the same field and one of the selected subprotocol values in its response for the connection to be established.",
      "ja": "秒-のWebSocket-プロトコル|クライアントは、サーバを含むことによって、特定のサブプロトコルを使用するように要求することができます|その握手のフィールド。それが指定されている場合、サーバーは、同じフィールドと確立する接続用の応答に選択されたサブプロトコル値のいずれかを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "These subprotocol names should be registered as per Section 11.5. To avoid potential collisions, it is recommended to use names that contain the ASCII version of the domain name of the subprotocol's originator. For example, if Example Corporation were to create a Chat subprotocol to be implemented by many servers around the Web, they could name it \"chat.example.com\". If the Example Organization called their competing subprotocol \"chat.example.org\", then the two subprotocols could be implemented by servers simultaneously, with the server dynamically selecting which subprotocol to use based on the value sent by the client.",
      "ja": "これらのサブプロトコル名は、11.5節ごとに登録する必要があります。潜在的な衝突を回避するために、サブプロトコルの発信元のドメイン名のASCIIバージョンを含む名前を使用することをお勧めします。例株式会社は、Webを中心に多くのサーバによって実装されるチャットのサブプロトコルを作成した場合たとえば、彼らは「chat.example.com」という名前を付けできます。例の組織は、彼らの競争サブプロトコル「chat.example.org」と呼ばれる場合、2つのサブプロトコルは、サーバが動的にクライアントから送信された値に基づいて、使用するサブプロトコルを選択して、同時にサーバで実現することができます。"
    },
    {
      "indent": 3,
      "text": "Subprotocols can be versioned in backward-incompatible ways by changing the subprotocol name, e.g., going from \"bookings.example.net\" to \"v2.bookings.example.net\". These subprotocols would be considered completely separate by WebSocket clients. Backward-compatible versioning can be implemented by reusing the same subprotocol string but carefully designing the actual subprotocol to support this kind of extensibility.",
      "ja": "サブプロトコルは、「v2.bookings.example.net」に「bookings.example.net」から行く、例えば、サブプロトコル名を変更することにより、下位互換性のない方法でバージョン管理することができます。これらのサブプロトコルは、WebSocketのクライアントによって完全に分離と考えられます。下位互換性バージョン管理は、同じサブプロトコル文字列を再利用しますが、慎重に拡張性のこの種をサポートするために、実際のサブプロトコルを設計することで実現できます。"
    },
    {
      "indent": 0,
      "text": "2. Conformance Requirements",
      "section_title": true,
      "ja": "2.適合性要件"
    },
    {
      "indent": 3,
      "text": "All diagrams, examples, and notes in this specification are non-normative, as are all sections explicitly marked non-normative. Everything else in this specification is normative.",
      "ja": "明示的に非規範的マークされたすべての部分であるとして本明細書中のすべての図、例、およびノー​​トは、非規範的です。本明細書における他のすべては規範的です。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Requirements phrased in the imperative as part of algorithms (such as \"strip any leading space characters\" or \"return false and abort these steps\") are to be interpreted with the meaning of the key word (\"MUST\", \"SHOULD\", \"MAY\", etc.) used in introducing the algorithm.",
      "ja": "（例えば、「任意の先頭の空白文字を削除」または「falseを返し、これらの手順を中止します」など）のアルゴリズムの一部として不可欠に言葉で表現要件のキーワード（「MUST」、「SHOULD」の意味に解釈されるべきです、 \" MAY」、など）は、アルゴリズムの導入に使用されます。"
    },
    {
      "indent": 3,
      "text": "Conformance requirements phrased as algorithms or specific steps MAY be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow and not intended to be performant.)",
      "ja": "アルゴリズムや特定の手順と言う適合要件があれば、最終結果は同等であるように、任意の方法で実施することができます。 （特に、本明細書で定義されたアルゴリズムは、パフォーマンスであることを意図追従しやすいように意図されていません。）"
    },
    {
      "indent": 0,
      "text": "2.1. Terminology and Other Conventions",
      "section_title": true,
      "ja": "2.1. 用語およびその他の規則"
    },
    {
      "indent": 3,
      "text": "_ASCII_ shall mean the character-encoding scheme defined in [ANSI.X3-4.1986].",
      "ja": "_ASCII_は[ANSI.X3-4.1986]で定義された文字符号化方式を意味します。"
    },
    {
      "indent": 3,
      "text": "This document makes reference to UTF-8 values and uses UTF-8 notational formats as defined in STD 63 [RFC3629].",
      "ja": "この文書では、UTF-8の値を参照するとSTD 63 [RFC3629]で定義されるようにUTF-8の表記形式を使用します。"
    },
    {
      "indent": 3,
      "text": "Key terms such as named algorithms or definitions are indicated like _this_.",
      "ja": "そのような名前のアルゴリズムや定義などの主要な用語は_this_のように示されています。"
    },
    {
      "indent": 3,
      "text": "Names of header fields or variables are indicated like |this|.",
      "ja": "|この|ヘッダフィールドや変数の名前は次のように示されています。"
    },
    {
      "indent": 3,
      "text": "Variable values are indicated like /this/.",
      "ja": "変数の値は、この/ /のように示されています。"
    },
    {
      "indent": 3,
      "text": "This document references the procedure to _Fail the WebSocket Connection_. This procedure is defined in Section 7.1.7.",
      "ja": "この文書では、WebSocketをConnection_を_Failする手順を参照します。この手順は、7.1.7項で定義されています。"
    },
    {
      "indent": 3,
      "text": "_Converting a string to ASCII lowercase_ means replacing all characters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) with the corresponding characters in the range U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL LETTER Z).",
      "ja": "文字列を_Convertingするlowercase_はU + 0041 U + 005Aまでの範囲内のすべての文字を置き換える手段ASCIIに（すなわち、LATIN CAPITAL LETTER Zにラテン大文字A）、すなわちU + 0061 U + 007Aまでの範囲内の対応する文字で（、ラテン文字Zにラテン小文字のA）。"
    },
    {
      "indent": 3,
      "text": "Comparing two strings in an _ASCII case-insensitive_ manner means comparing them exactly, code point for code point, except that the characters in the range U+0041 to U+005A (i.e., LATIN CAPITAL LETTER A to LATIN CAPITAL LETTER Z) and the corresponding characters in the range U+0061 to U+007A (i.e., LATIN SMALL LETTER A to LATIN SMALL LETTER Z) are considered to also match.",
      "ja": "除いて、コードポイントのために、正確にコードポイントを、それらを比較_ASCIIケースinsensitive_方法で2つの文字列を意味する比較し、その範囲内の文字U + 005AにU + 0041（すなわち、LATIN CAPITAL LETTER Zにラテン大文字A）とU + 007A（ラテン小文字Zに、すなわち、ラテン小文字のA）までの範囲内の対応する文字U + 0061も一致すると考えられます。"
    },
    {
      "indent": 3,
      "text": "The term \"URI\" is used in this document as defined in [RFC3986].",
      "ja": "[RFC3986]で定義されるように、用語「URI」は本書で使用されています。"
    },
    {
      "indent": 3,
      "text": "When an implementation is required to _send_ data as part of the WebSocket Protocol, the implementation MAY delay the actual transmission arbitrarily, e.g., buffering data so as to send fewer IP packets.",
      "ja": "実装はWebSocketのプロトコルの一部としてデータを_send_する必要がある場合、実装は、より少ないIPパケットを送信するためにデータをバッファ、例えば、任意の実際の送信を遅延させることができます。"
    },
    {
      "indent": 3,
      "text": "Note that this document uses both [RFC5234] and [RFC2616] variants of ABNF in different sections.",
      "ja": "この文書は、異なるセクションのABNFの両方の[RFC5234]及び[RFC2616]バリアントを使用することに注意してください。"
    },
    {
      "indent": 0,
      "text": "3. WebSocket URIs",
      "section_title": true,
      "ja": "3.のWebSocketのURI"
    },
    {
      "indent": 3,
      "text": "This specification defines two URI schemes, using the ABNF syntax defined in RFC 5234 [RFC5234], and terminology and ABNF productions defined by the URI specification RFC 3986 [RFC3986].",
      "ja": "この仕様は、URI仕様RFC 3986 [RFC3986]で定義されたABNFのRFC 5234 [RFC5234]で定義された構文、及び用語とABNFプロダクションを使用して、2つのURIスキームを定義します。"
    },
    {
      "indent": 10,
      "text": "ws-URI = \"ws:\" \"//\" host [ \":\" port ] path [ \"?\" query ]\nwss-URI = \"wss:\" \"//\" host [ \":\" port ] path [ \"?\" query ]",
      "raw": true
    },
    {
      "indent": 10,
      "text": "host = <host, defined in [RFC3986], Section 3.2.2> port = <port, defined in [RFC3986], Section 3.2.3> path = <path-abempty, defined in [RFC3986], Section 3.3> query = <query, defined in [RFC3986], Section 3.4>",
      "ja": "ホスト= <ホスト、[RFC3986]、セクション3.2.2で定義された> <[RFC3986]で定義されたポート、3.2.3>ポート=パス= <パスabempty、[RFC3986]、セクション3.3で定義され>クエリ= <クエリ、[RFC3986]で定義され、セクション3.4>"
    },
    {
      "indent": 3,
      "text": "The port component is OPTIONAL; the default for \"ws\" is port 80, while the default for \"wss\" is port 443.",
      "ja": "ポートコンポーネントはオプションです。 「WSS」のデフォルトはポート443である一方、「WS」のデフォルトは、80ポートです。"
    },
    {
      "indent": 3,
      "text": "The URI is called \"secure\" (and it is said that \"the secure flag is set\") if the scheme component matches \"wss\" case-insensitively.",
      "ja": "URIは、「安全な」と呼ばれている（「安全なフラグが設定されている」と言われている）方式成分「WSS」大文字と小文字を区別せずに一致する場合。"
    },
    {
      "indent": 3,
      "text": "The \"resource-name\" (also known as /resource name/ in Section 4.1) can be constructed by concatenating the following:",
      "ja": "（セクション4.1のリソース名/ /としても知られる）「リソース名」は、以下を連結することによって構築することができます。"
    },
    {
      "indent": 3,
      "text": "o \"/\" if the path component is empty",
      "ja": "O「/」パスコンポーネントが空の場合"
    },
    {
      "indent": 3,
      "text": "o the path component",
      "ja": "パスコンポーネントO"
    },
    {
      "indent": 3,
      "text": "o \"?\" if the query component is non-empty",
      "ja": "O \"？\"クエリコンポーネントは非空の場合"
    },
    {
      "indent": 3,
      "text": "o the query component",
      "ja": "クエリコンポーネントO"
    },
    {
      "indent": 3,
      "text": "Fragment identifiers are meaningless in the context of WebSocket URIs and MUST NOT be used on these URIs. As with any URI scheme, the character \"#\", when not indicating the start of a fragment, MUST be escaped as %23.",
      "ja": "フラグメント識別子は、WebSocketのURIのコンテキストで無意味であり、これらのURIに使用してはいけません。フラグメントの開始を示していない任意のURIスキーム、文字「＃」、と同じように、％23としてエスケープしなければなりません。"
    },
    {
      "indent": 0,
      "text": "4. Opening Handshake",
      "section_title": true,
      "ja": "4.オープニングハンドシェイク"
    },
    {
      "indent": 0,
      "text": "4.1. Client Requirements",
      "section_title": true,
      "ja": "4.1. クライアントの要件"
    },
    {
      "indent": 3,
      "text": "To _Establish a WebSocket Connection_, a client opens a connection and sends a handshake as defined in this section. A connection is defined to initially be in a CONNECTING state. A client will need to supply a /host/, /port/, /resource name/, and a /secure/ flag, which are the components of a WebSocket URI as discussed in Section 3, along with a list of /protocols/ and /extensions/ to be used. Additionally, if the client is a web browser, it supplies /origin/.",
      "ja": "_EstablishのWebSocket Connection_に、クライアントが接続を開き、このセクションで定義されたハンドシェイクを送信します。接続が最初に接続状態であると定義されます。クライアントが提供する必要があります/ホスト/、/ポート/、/リソース名/、および第3節で説明したようにのリストと共に、WebSocketのURIの構成要素である/セキュア/フラグ/プロトコル/及び使用する/拡張/。クライアントは、Webブラウザの場合はさらに、それは/原点/を提供しています。"
    },
    {
      "indent": 3,
      "text": "Clients running in controlled environments, e.g., browsers on mobile handsets tied to specific carriers, MAY offload the management of the connection to another agent on the network. In such a situation, the client for the purposes of this specification is considered to include both the handset software and any such agents.",
      "ja": "管理された環境で実行して、例えば、特定のキャリアに縛ら携帯電話にブラウザクライアントは、ネットワーク上の他のエージェントへの接続の管理負荷を軽減するかもしれません。このような状況では、本明細書の目的のために、クライアントは、携帯電話のソフトウェアとどのような薬剤の両方を含むと考えられています。"
    },
    {
      "indent": 3,
      "text": "When the client is to _Establish a WebSocket Connection_ given a set of (/host/, /port/, /resource name/, and /secure/ flag), along with a list of /protocols/ and /extensions/ to be used, and an /origin/ in the case of web browsers, it MUST open a connection, send an opening handshake, and read the server's handshake in response. The exact requirements of how the connection should be opened, what should be sent in the opening handshake, and how the server's response should be interpreted are as follows in this section. In the following text, we will use terms from Section 3, such as \"/host/\" and \"/secure/ flag\" as defined in that section.",
      "ja": "クライアントは/プロトコル/と/使用される拡張子/のリストとともに、一連の（/ホスト/、/ポート/、/リソース名/、および/安全な/フラグ）与えられた_EstablishへのWebSocket Connection_である場合には、および/原点は/ Webブラウザの場合には、それは、接続を開くオープニングハンドシェイクを送信し、応答して、サーバのハンドシェイクを読まなければなりません。このセクションでは、次のように接続が開放ハンドシェイク中に送信されるべきか、開かれるべきであり、どのようにサーバの応答をどのように解釈するかの正確な要件があります。そのセクションで定義された以下のテキストでは、我々は、このような「/ホスト/」のように、第3の用語を使用し、「安全/ /フラグ」。"
    },
    {
      "indent": 3,
      "text": "1. The components of the WebSocket URI passed into this algorithm (/host/, /port/, /resource name/, and /secure/ flag) MUST be valid according to the specification of WebSocket URIs specified in Section 3. If any of the components are invalid, the client MUST _Fail the WebSocket Connection_ and abort these steps.",
      "ja": "1のWebSocket URIの構成要素は、任意の場合のWebSocket URIの仕様に応じて有効でなければなりません、セクション3で指定されたこのアルゴリズム（/ホスト/、/ポート/、/リソース名/、および/セキュア/フラグ）に渡されますコンポーネントが無効で、クライアントは、WebSocketをConnection_を_Failし、これらの手順を中止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If the client already has a WebSocket connection to the remote host (IP address) identified by /host/ and port /port/ pair, even if the remote host is known by another name, the client MUST wait until that connection has been established or for that connection to have failed. There MUST be no more than one connection in a CONNECTING state. If multiple connections to the same IP address are attempted simultaneously, the client MUST serialize them so that there is no more than one connection at a time running through the following steps.",
      "ja": "2.クライアントがすでにその接続がされるまで、リモートホストが別の名前で知られていても、クライアントは待たなければなりません、/ホスト/ポート/ポート/ペアによって識別されるリモートホスト（IPアドレス）へのWebSocket接続されている場合確立またはその接続のために失敗しました。接続状態には複数の接続があってはなりません。同じIPアドレスに複数の接続が同時に試行されている場合は、次の手順を実行している時には1個以下の接続があるように、クライアントがそれらをシリアル化する必要があります。"
    },
    {
      "indent": 7,
      "text": "If the client cannot determine the IP address of the remote host\n(for example, because all communication is being done through a\nproxy server that performs DNS queries itself), then the client\nMUST assume for the purposes of this step that each host name\nrefers to a distinct remote host, and instead the client SHOULD\nlimit the total number of simultaneous pending connections to a\nreasonably low number (e.g., the client might allow simultaneous\npending connections to a.example.com and b.example.com, but if\nthirty simultaneous connections to a single host are requested,\nthat may not be allowed).  For example, in a web browser context,\nthe client needs to consider the number of tabs the user has open\nin setting a limit to the number of simultaneous pending\nconnections.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "NOTE: This makes it harder for a script to perform a denial-of-service attack by just opening a large number of WebSocket connections to a remote host. A server can further reduce the load on itself when attacked by pausing before closing the connection, as that will reduce the rate at which the client reconnects.",
      "ja": "注：これはちょうど、リモートホストへのWebSocket多数の接続を開くことにより、サービス拒否攻撃を実行するためのスクリプトのことが難しくなります。接続を閉じる前に一時停止に襲われたときには、クライアントが再接続する速度を低下するため、サーバはさらに、自身の負荷を軽減することができます。"
    },
    {
      "indent": 7,
      "text": "NOTE: There is no limit to the number of established WebSocket connections a client can have with a single remote host. Servers can refuse to accept connections from hosts/IP addresses with an excessive number of existing connections or disconnect resource-hogging connections when suffering high load.",
      "ja": "注：クライアントは、単一のリモートホストと持つことができます確立のWebSocket接続数に制限はありません。サーバは高負荷に苦しんでたときに既存の接続や切断リソース占有接続の過剰な数とホスト/ IPアドレスからの接続を受け入れることを拒否することができます。"
    },
    {
      "indent": 3,
      "text": "3. _Proxy Usage_: If the client is configured to use a proxy when using the WebSocket Protocol to connect to host /host/ and port /port/, then the client SHOULD connect to that proxy and ask it to open a TCP connection to the host given by /host/ and the port given by /port/.",
      "ja": "3. _Proxy Usage_：クライアントが/ホスト/ポート/ポート/ホストに接続するのWebSocketプロトコルを使用している場合、プロキシを使用するように設定されている場合、クライアントはそのプロキシに接続し、へのTCP接続を開くためにそれを頼むべきです/ホスト/と/ポート/で指定したポートによって与えられたホスト。"
    },
    {
      "indent": 10,
      "text": "EXAMPLE: For example, if the client uses an HTTP proxy for all\ntraffic, then if it was to try to connect to port 80 on server\nexample.com, it might send the following lines to the proxy\nserver:",
      "raw": true
    },
    {
      "indent": 14,
      "text": "CONNECT example.com:80 HTTP/1.1\nHost: example.com",
      "raw": true
    },
    {
      "indent": 10,
      "text": "If there was a password, the connection might look like:",
      "ja": "パスワードがあった場合、接続は次のようになります。"
    },
    {
      "indent": 14,
      "text": "CONNECT example.com:80 HTTP/1.1\nHost: example.com\nProxy-authorization: Basic ZWRuYW1vZGU6bm9jYXBlcyE=",
      "raw": true
    },
    {
      "indent": 7,
      "text": "If the client is not configured to use a proxy, then a direct TCP connection SHOULD be opened to the host given by /host/ and the port given by /port/.",
      "ja": "クライアントがプロキシを使用するように設定されていない場合は、直接TCP接続は/ホストによって与えられたホスト/と/ポート/によって与えられたポートに開かれるべきです。"
    },
    {
      "indent": 7,
      "text": "NOTE: Implementations that do not expose explicit UI for selecting a proxy for WebSocket connections separate from other proxies are encouraged to use a SOCKS5 [RFC1928] proxy for WebSocket connections, if available, or failing that, to prefer the proxy configured for HTTPS connections over the proxy configured for HTTP connections.",
      "ja": "注：WebSocketの接続にプロキシを選択するための明示的なUIを公開しない実装他のプロキシから分離が可能な場合は、のWebSocket接続用のSOCKS5 [RFC1928]プロキシを使用することが推奨されている、または上のHTTPS接続用に設定されたプロキシを好む、ということができませんプロキシは、HTTP接続用に構成します。"
    },
    {
      "indent": 7,
      "text": "For the purpose of proxy autoconfiguration scripts, the URI to pass the function MUST be constructed from /host/, /port/, /resource name/, and the /secure/ flag using the definition of a WebSocket URI as given in Section 3.",
      "ja": "プロキシ自動設定スクリプトの目的のために、URIは関数を渡すために、セクション3で与えられるようなWebSocket URIの定義を使用してホスト/、/ポート/、/リソース名/、および/セキュア/フラグ/から構成されなければなりません。"
    },
    {
      "indent": 7,
      "text": "NOTE: The WebSocket Protocol can be identified in proxy autoconfiguration scripts from the scheme (\"ws\" for unencrypted connections and \"wss\" for encrypted connections).",
      "ja": "注：のWebSocketプロトコルスキーム（暗号化されていない接続のための「WS」および暗号化された接続のための「WSS」）からプロキシ自動設定スクリプト内で識別することができます。"
    },
    {
      "indent": 3,
      "text": "4. If the connection could not be opened, either because a direct connection failed or because any proxy used returned an error, then the client MUST _Fail the WebSocket Connection_ and abort the connection attempt.",
      "ja": "4.直接接続が失敗したか、または使用されるすべてのプロキシがエラーを返したため、その後、クライアントはWebSocketをConnection_を_Failと、接続の試行を中止しなければなりませんので、接続はどちらか、開くことができなかった場合。"
    },
    {
      "indent": 3,
      "text": "5. If /secure/ is true, the client MUST perform a TLS handshake over the connection after opening the connection and before sending the handshake data [RFC2818]. If this fails (e.g., the server's certificate could not be verified), then the client MUST _Fail the WebSocket Connection_ and abort the connection. Otherwise, all further communication on this channel MUST run through the encrypted tunnel [RFC5246].",
      "ja": "5.安全/ / trueの場合、クライアントが接続を開いた後、ハンドシェイクデータを送信する前に、接続[RFC2818]の上にTLSハンドシェイクを実行しなければなりません。これは、（例えば、サーバの証明書を検証することができませんでした）失敗した場合、クライアントは、WebSocketをConnection_を_Failとの接続を中止しなければなりません。そうでない場合は、このチャネル上のすべての通信は暗号化されたトンネル[RFC5246]を介して実行する必要があります。"
    },
    {
      "indent": 7,
      "text": "Clients MUST use the Server Name Indication extension in the TLS\nhandshake [RFC6066].",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Once a connection to the server has been established (including a connection via a proxy or over a TLS-encrypted tunnel), the client MUST send an opening handshake to the server. The handshake consists of an HTTP Upgrade request, along with a list of required and optional header fields. The requirements for this handshake are as follows.",
      "ja": "サーバーへの接続は、（プロキシを介して、またはTLS暗号化トンネルを介して接続を含む）が確立された後、クライアントは、サーバに開口ハンドシェークを送信しなければなりません。ハンドシェイクが必要とオプションヘッダフィールドのリストと共に、HTTPアップグレード要求から成ります。次のようにこのハンドシェイクのための要件が​​あります。"
    },
    {
      "indent": 3,
      "text": "1. The handshake MUST be a valid HTTP request as specified by [RFC2616].",
      "ja": "[RFC2616]で指定された1ハンドシェイクが有効なHTTPリクエストでなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. The method of the request MUST be GET, and the HTTP version MUST be at least 1.1.",
      "ja": "2.リクエストの方法は、GETでなければなりません、およびHTTPのバージョンが少なくとも1.1でなければなりません。"
    },
    {
      "indent": 8,
      "text": "For example, if the WebSocket URI is \"ws://example.com/chat\",\nthe first line sent should be \"GET /chat HTTP/1.1\".",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. The \"Request-URI\" part of the request MUST match the /resource name/ defined in Section 3 (a relative URI) or be an absolute http/https URI that, when parsed, has a /resource name/, /host/, and /port/ that match the corresponding ws/wss URI.",
      "ja": "3.リクエストの「リクエストURI」部分は、セクション3（相対URI）で定義された/リソース名/一致または絶対HTTP / HTTPS URIすなわち、解析され、持ち/リソース名/、/ホストでなければなりません対応するWS / WSS URIと一致/、および/ポート/。"
    },
    {
      "indent": 3,
      "text": "4. The request MUST contain a |Host| header field whose value contains /host/ plus optionally \":\" followed by /port/ (when not using the default port).",
      "ja": "ホスト| 4.要求が含まれていなければなりません|その値/ホスト/プラス任意に含むヘッダフィールド「：」（デフォルトのポートを使用しない場合）/ポート/続きます。"
    },
    {
      "indent": 3,
      "text": "5. The request MUST contain an |Upgrade| header field whose value MUST include the \"websocket\" keyword.",
      "ja": "5.要求は含まなければならない|アップグレード|その値は、ヘッダフィールドは「のWebSocket」キーワードを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "6. The request MUST contain a |Connection| header field whose value MUST include the \"Upgrade\" token.",
      "ja": "接続| 6.要求が含まれていなければなりません|その値が「アップグレード」トークンを含まなければならないヘッダフィールド。"
    },
    {
      "indent": 3,
      "text": "7. The request MUST include a header field with the name |Sec-WebSocket-Key|. The value of this header field MUST be a nonce consisting of a randomly selected 16-byte value that has been base64-encoded (see Section 4 of [RFC4648]). The nonce MUST be selected randomly for each connection.",
      "ja": "|秒-のWebSocketキー| 7.要求は名前のヘッダフィールドを含まなければなりません。このヘッダーフィールドの値は、base64エンコード（[RFC4648]のセクション4を参照）であったランダムに選択された16バイトの値からなるノンスなければなりません。ノンスは、接続ごとにランダムに選択されなければなりません。"
    },
    {
      "indent": 8,
      "text": "NOTE: As an example, if the randomly selected value was the\nsequence of bytes 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09\n0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10, the value of the header\nfield would be \"AQIDBAUGBwgJCgsMDQ4PEC==\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8. The request MUST include a header field with the name |Origin| [RFC6454] if the request is coming from a browser client. If the connection is from a non-browser client, the request MAY include this header field if the semantics of that client match the use-case described here for browser clients. The value of this header field is the ASCII serialization of origin of the context in which the code establishing the connection is running. See [RFC6454] for the details of how this header field value is constructed.",
      "ja": "起源| 8.要求は名前のヘッダフィールドを含まなければなりません| [RFC6454]リクエストがブラウザクライアントから来ている場合。接続は、ブラウザ以外のクライアントからのものであれば、そのクライアントのセマンティクスは、ブラウザのクライアントのためにここで説明するユースケースと一致した場合、要求はこのヘッダーフィールドを含んでいてもよいです。このヘッダーフィールドの値は、接続を確立するコードが実行されているコンテキストの原点のASCIIシリアライゼーションです。このヘッダフィールド値を構成する方法の詳細については、[RFC6454]を参照。"
    },
    {
      "indent": 8,
      "text": "As an example, if code downloaded from www.example.com attempts\nto establish a connection to ww2.example.com, the value of the\nheader field would be \"http://www.example.com\".",
      "raw": true
    },
    {
      "indent": 3,
      "text": "9. The request MUST include a header field with the name |Sec-WebSocket-Version|. The value of this header field MUST be 13.",
      "ja": "|秒-のWebSocket-バージョン| 9.要求は名前のヘッダフィールドを含まなければなりません。このヘッダーフィールドの値は13でなければなりません。"
    },
    {
      "indent": 8,
      "text": "NOTE: Although draft versions of this document (-09, -10, -11,\nand -12) were posted (they were mostly comprised of editorial\nchanges and clarifications and not changes to the wire\nprotocol), values 9, 10, 11, and 12 were not used as valid\nvalues for Sec-WebSocket-Version.  These values were reserved in\nthe IANA registry but were not and will not be used.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "10. The request MAY include a header field with the name |Sec-WebSocket-Protocol|. If present, this value indicates one or more comma-separated subprotocol the client wishes to speak, ordered by preference. The elements that comprise this value MUST be non-empty strings with characters in the range U+0021 to U+007E not including separator characters as defined in [RFC2616] and MUST all be unique strings. The ABNF for the value of this header field is 1#token, where the definitions of constructs and rules are as given in [RFC2616].",
      "ja": "秒-のWebSocket-プロトコル| | 10.要求は、名前のヘッダフィールドを含んでいてもよいです。現在は、この値は、1つまたは複数のカンマで区切られたサブプロトコルを示している場合、クライアントは好みによって命じ、話すことを希望します。 [RFC2616]で定義されるように、この値を含む要素はU + 007Eの範囲の文字U + 0021を有する非空の文字列でなければなりません区切り文字を含まない、すべての一意の文字列でなければなりません。このヘッダフィールドの値のためのABNFは、[RFC2616]で与えられる構築物の定義及び規則は、1〜＃トークンです。"
    },
    {
      "indent": 3,
      "text": "11. The request MAY include a header field with the name |Sec-WebSocket-Extensions|. If present, this value indicates the protocol-level extension(s) the client wishes to speak. The interpretation and format of this header field is described in Section 9.1.",
      "ja": "秒-のWebSocket-拡張機能| | 11.要求は名前のヘッダフィールドを含んでいてもよいです。存在する場合、この値は、クライアントが話すことを望むプロトコルレベルの拡張（S）を示します。このヘッダフィールドの解釈とフォーマットはセクション9.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "12. The request MAY include any other header fields, for example, cookies [RFC6265] and/or authentication-related header fields such as the |Authorization| header field [RFC2616], which are processed according to documents that define them.",
      "ja": "認可| 12.要求は、他のヘッダフィールド、例えば、クッキー[RFC6265]、および/または例えば認証関連ヘッダフィールドを含むかもしれ|それらを定義文書に従って処理されたヘッダフィールド[RFC2616]。"
    },
    {
      "indent": 3,
      "text": "Once the client's opening handshake has been sent, the client MUST wait for a response from the server before sending any further data. The client MUST validate the server's response as follows:",
      "ja": "クライアントのオープニングハンドシェイクが送信されると、クライアントはそれ以上のデータを送信する前に、サーバーからの応答を待たなければなりません。次のようにクライアントは、サーバの応答を検証しなければなりません："
    },
    {
      "indent": 3,
      "text": "1. If the status code received from the server is not 101, the client handles the response per HTTP [RFC2616] procedures. In particular, the client might perform authentication if it receives a 401 status code; the server might redirect the client using a 3xx status code (but clients are not required to follow them), etc. Otherwise, proceed as follows.",
      "ja": "サーバから受信したステータスコードが101でない場合は1、クライアントはHTTP [RFC2616]手順に従って応答を処理します。それが401のステータスコードを受信した場合、特に、クライアントが認証を行うかもしれません。サーバが3xxのステータスコードを使用してクライアントをリダイレクトする可能性がある（ただし、クライアントはそれに従うことを要求されない）、などそれ以外の場合は、次のように進みます。"
    },
    {
      "indent": 3,
      "text": "2. If the response lacks an |Upgrade| header field or the |Upgrade| header field contains a value that is not an ASCII case-insensitive match for the value \"websocket\", the client MUST _Fail the WebSocket Connection_.",
      "ja": "2.応答が不足している場合|アップグレード|ヘッダフィールドや|アップグレード|ヘッダフィールドは、クライアントがWebSocketをConnection_を_Failしなければならない、値「のWebSocket」のASCII大文字と小文字を区別しない一致しない値が含まれています。"
    },
    {
      "indent": 3,
      "text": "3. If the response lacks a |Connection| header field or the |Connection| header field doesn't contain a token that is an ASCII case-insensitive match for the value \"Upgrade\", the client MUST _Fail the WebSocket Connection_.",
      "ja": "3.応答が不足している場合は|接続|ヘッダフィールドや|接続|ヘッダフィールドは、クライアントがWebSocketをConnection_を_Failしなければならない、「アップグレード」値のASCII大文字と小文字を区別しない一致するトークンが含まれていません。"
    },
    {
      "indent": 3,
      "text": "4. If the response lacks a |Sec-WebSocket-Accept| header field or the |Sec-WebSocket-Accept| contains a value other than the base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-Key| (as a string, not base64-decoded) with the string \"258EAFA5- E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and trailing whitespace, the client MUST _Fail the WebSocket Connection_.",
      "ja": "4.応答が不足している場合| SECは-のWebSocket-受け入れ|ヘッダフィールドや|秒-のWebSocket-受け入れ| |秒-のWebSocketキー| Base64でエンコードされたSHA-1の連結の以外の値が含まれています文字列「258EAFA5- E914-47DA-95CA-C5AB0DC85B11」と（文字列ではなく、base64でデコードされるように）が、任意の先頭と末尾の空白を無視して、クライアントがのWebSocket Connection_を_Failしなければなりません。"
    },
    {
      "indent": 3,
      "text": "5. If the response includes a |Sec-WebSocket-Extensions| header field and this header field indicates the use of an extension that was not present in the client's handshake (the server has indicated an extension not requested by the client), the client MUST _Fail the WebSocket Connection_. (The parsing of this header field to determine which extensions are requested is discussed in Section 9.1.)",
      "ja": "5.応答が含まれている場合|秒-のWebSocket-拡張機能|ヘッダフィールドと、このヘッダフィールドは、（サーバがクライアントによって要求されていない拡張を示している）、クライアントのWebSocket Connection_を_Failしなければならないクライアントのハンドシェイク中に存在しなかった拡張の使用を示しています。 （拡張機能が要求されるかを決定するために、このヘッダフィールドの構文解析は、セクション9.1で議論されています。）"
    },
    {
      "indent": 3,
      "text": "6. If the response includes a |Sec-WebSocket-Protocol| header field and this header field indicates the use of a subprotocol that was not present in the client's handshake (the server has indicated a subprotocol not requested by the client), the client MUST _Fail the WebSocket Connection_.",
      "ja": "6.応答が含まれている場合|秒-のWebSocket-Protocolの|ヘッダフィールドと、このヘッダフィールドは、クライアントのハンドシェイク中に存在していなかったサブプロトコルを使用することを示し、クライアントのWebSocket Connection_を_Failしなければならない（サーバがクライアントによって要求されていないサブプロトコルを示しています）。"
    },
    {
      "indent": 3,
      "text": "If the server's response does not conform to the requirements for the server's handshake as defined in this section and in Section 4.2.2, the client MUST _Fail the WebSocket Connection_.",
      "ja": "このセクションでは、セクション4.2.2で定義されているサーバの応答がサーバの握手のための要件に準拠していない場合、クライアントは、WebSocketをConnection_を_Failしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Please note that according to [RFC2616], all header field names in both HTTP requests and HTTP responses are case-insensitive.",
      "ja": "[RFC2616]によると、HTTP要求とHTTP応答の両方のすべてのヘッダーフィールド名は大文字と小文字は区別されませんのでご注意ください。"
    },
    {
      "indent": 3,
      "text": "If the server's response is validated as provided for above, it is said that _The WebSocket Connection is Established_ and that the WebSocket Connection is in the OPEN state. The _Extensions In Use_ is defined to be a (possibly empty) string, the value of which is equal to the value of the |Sec-WebSocket-Extensions| header field supplied by the server's handshake or the null value if that header field was not present in the server's handshake. The _Subprotocol In Use_ is defined to be the value of the |Sec-WebSocket-Protocol| header field in the server's handshake or the null value if that header field was not present in the server's handshake. Additionally, if any header fields in the server's handshake indicate that cookies should be set (as defined by [RFC6265]), these cookies are referred to as _Cookies Set During the Server's Opening Handshake_.",
      "ja": "上記のために提供されるサーバの応答が検証されている場合は、_TheのWebSocket接続がのWebSocketコネクションがOPEN状態であることをEstablished_であると言われています。秒-のWebSocket-拡張| USE_において_Extensionsは、の値に等しい値れた（おそらく空の）文字列として定義され|そのヘッダフィールドは、サーバのハンドシェイク中に存在しなかった場合、ヘッダフィールドは、サーバのハンドシェーク又はヌル値によって供給されます。秒-のWebSocket-プロトコル| USE_で_Subprotocolはの値になるように定義されて|ヘッダサーバのハンドシェーク内のフィールドまたはそのヘッダフィールドは、サーバのハンドシェイク中に存在しなかった場合はnull値。サーバのハンドシェークの任意のヘッダーフィールドは、（[RFC6265]で定義されるような）クッキーが設定されるべきであることを示す場合に加えて、これらのクッキーは、サーバのオープンHandshake_中_Cookiesセットと呼ばれます。"
    },
    {
      "indent": 0,
      "text": "4.2. Server-Side Requirements",
      "section_title": true,
      "ja": "4.2. サーバー側の要件"
    },
    {
      "indent": 3,
      "text": "Servers MAY offload the management of the connection to other agents on the network, for example, load balancers and reverse proxies. In such a situation, the server for the purposes of this specification is considered to include all parts of the server-side infrastructure from the first device to terminate the TCP connection all the way to the server that processes requests and sends responses.",
      "ja": "サーバは、例えば、ネットワーク上の他のエージェントへの接続の管理をオフロードロードバランサとリバースプロキシするかもしれません。このような状況において、本明細書の目的のために、サーバは、すべての方法の要求を処理し、応答を送信するサーバへのTCP接続を終了するために第1のデバイスからサーバ側インフラのすべての部分を含むように考えられています。"
    },
    {
      "indent": 3,
      "text": "EXAMPLE: A data center might have a server that responds to WebSocket requests with an appropriate handshake and then passes the connection to another server to actually process the data frames. For the purposes of this specification, the \"server\" is the combination of both computers.",
      "ja": "例：データセンターは、適切なハンドシェーク要求をWebSocketのに応答して、実際にデータフレームを処理するために、別のサーバーへの接続を渡しサーバーを持っているかもしれません。本明細書の目的のために、「サーバ」、両方のコンピュータを組み合わせたものです。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Reading the Client's Opening Handshake",
      "section_title": true,
      "ja": "4.2.1. クライアントのオープニングハンドシェイクを読みます"
    },
    {
      "indent": 3,
      "text": "When a client starts a WebSocket connection, it sends its part of the opening handshake. The server must parse at least part of this handshake in order to obtain the necessary information to generate the server part of the handshake.",
      "ja": "クライアントがWebSocketの接続を開始すると、オープニングハンドシェイクのその一部を送信します。サーバは、ハンドシェイクのサーバー部分を生成するために必要な情報を得るために、このハンドシェイクの少なくとも一部を解析しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client's opening handshake consists of the following parts. If the server, while reading the handshake, finds that the client did not send a handshake that matches the description below (note that as per [RFC2616], the order of the header fields is not important), including but not limited to any violations of the ABNF grammar specified for the components of the handshake, the server MUST stop processing the client's handshake and return an HTTP response with an appropriate error code (such as 400 Bad Request).",
      "ja": "クライアントのオープニングハンドシェイクは以下の部分から構成されています。サーバは、握手を読みながら、違反を含むがこれらに限定されない、（[RFC2616]のとおり、ヘッダフィールドの順序は重要ではないことに注意してください）クライアントは、以下の記述と一致するハンドシェイクを送信しなかったことを発見した場合ハンドシェークのコンポーネントの指定されたABNF文法の、サーバはクライアントのハンドシェークの処理を停止し、適切なエラー・コード（例えば、400不正な要求）とHTTPレスポンスを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "1. An HTTP/1.1 or higher GET request, including a \"Request-URI\" [RFC2616] that should be interpreted as a /resource name/ defined in Section 3 (or an absolute HTTP/HTTPS URI containing the /resource name/).",
      "ja": "セクション3で定義された/リソース名として解釈されるべきである「リクエストURI」[RFC2616] /を含む1 HTTP / 1.1以上GETリクエスト（または絶対的なHTTP / HTTPS URI /リソース名を含みます/） 。"
    },
    {
      "indent": 3,
      "text": "2. A |Host| header field containing the server's authority.",
      "section_title": true,
      "ja": "2. A |ホスト|サーバの権限を含むヘッダフィールド。"
    },
    {
      "indent": 3,
      "text": "3. An |Upgrade| header field containing the value \"websocket\", treated as an ASCII case-insensitive value.",
      "ja": "3.アン|アップグレード| ASCIIの大文字と小文字を区別しない値として扱わ値「のWebSocket」を含むヘッダフィールド。"
    },
    {
      "indent": 3,
      "text": "4. A |Connection| header field that includes the token \"Upgrade\", treated as an ASCII case-insensitive value.",
      "ja": "4. A |接続| ASCIIの大文字と小文字を区別しない値として扱わトークン「アップグレード」を含むヘッダフィールド。"
    },
    {
      "indent": 3,
      "text": "5. A |Sec-WebSocket-Key| header field with a base64-encoded (see Section 4 of [RFC4648]) value that, when decoded, is 16 bytes in length.",
      "ja": "5. A |秒-のWebSocketキー| base64エンコード（[RFC4648]のセクション4を参照）デコード、値を持つヘッダフィールドの長さは16バイトです。"
    },
    {
      "indent": 3,
      "text": "6. A |Sec-WebSocket-Version| header field, with a value of 13.",
      "section_title": true,
      "ja": "6. A |秒-のWebSocket-バージョン| 13の値と、フィールドヘッダ。"
    },
    {
      "indent": 3,
      "text": "7. Optionally, an |Origin| header field. This header field is sent by all browser clients. A connection attempt lacking this header field SHOULD NOT be interpreted as coming from a browser client.",
      "ja": "7.必要に応じて、|起源|ヘッダフィールド。このヘッダーフィールドは、すべてのブラウザクライアントによって送信されます。このヘッダフィールドを欠く接続試行はブラウザクライアントから来るものと解釈すべきではありません。"
    },
    {
      "indent": 3,
      "text": "8. Optionally, a |Sec-WebSocket-Protocol| header field, with a list of values indicating which protocols the client would like to speak, ordered by preference.",
      "ja": "8.必要に応じて、|秒-のWebSocket-プロトコル|示す値のリストを有するヘッダーフィールドは、クライアントが優先順に並べられ、話したいプロトコル。"
    },
    {
      "indent": 3,
      "text": "9. Optionally, a |Sec-WebSocket-Extensions| header field, with a list of values indicating which extensions the client would like to speak. The interpretation of this header field is discussed in Section 9.1.",
      "ja": "9.必要に応じて、|秒-のWebSocket-拡張機能|示す値のリストを持つヘッダフィールドは、クライアントが話したい拡張子を示します。このヘッダフィールドの解釈は、セクション9.1で議論されています。"
    },
    {
      "indent": 3,
      "text": "10. Optionally, other header fields, such as those used to send cookies or request authentication to a server. Unknown header fields are ignored, as per [RFC2616].",
      "ja": "10.必要に応じて、そのようなサーバにクッキーまたは要求認証を送信するために使用されるもののような他のヘッダフィールド。未知のヘッダーフィールドは、[RFC2616]に従って、無視されます。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Sending the Server's Opening Handshake",
      "section_title": true,
      "ja": "4.2.2. サーバーのオープニングハンドシェイクを送信"
    },
    {
      "indent": 3,
      "text": "When a client establishes a WebSocket connection to a server, the server MUST complete the following steps to accept the connection and send the server's opening handshake.",
      "ja": "クライアントがサーバーへのWebSocket接続を確立すると、サーバーは接続を受け入れ、サーバーのオープニングハンドシェイクを送信するには、以下の手順を完了する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. If the connection is happening on an HTTPS (HTTP-over-TLS) port, perform a TLS handshake over the connection. If this fails (e.g., the client indicated a host name in the extended client hello \"server_name\" extension that the server does not host), then close the connection; otherwise, all further communication for the connection (including the server's handshake) MUST run through the encrypted tunnel [RFC5246].",
      "ja": "1.接続は、接続を介してTLSハンドシェイクを実行し、HTTPS（HTTPオーバーTLS）ポート上で起こっている場合。これが失敗した場合（例えば、クライアントはサーバがホストしていないことを「サーバー名」の拡張子こんにちは、拡張クライアントのホスト名を示す）は、その後、接続を閉じます。そうでない場合は、（サーバのハンドシェイクを含む）を接続するためのすべての通信は暗号化されたトンネル[RFC5246]を介して実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The server can perform additional client authentication, for example, by returning a 401 status code with the corresponding |WWW-Authenticate| header field as described in [RFC2616].",
      "ja": "WWW認証| 2.サーバーは、例えば、対応する401のステータスコードを返すことによって、追加のクライアント認証を行うことができます| [RFC2616]で説明されるようにヘッダーフィールド。"
    },
    {
      "indent": 3,
      "text": "3. The server MAY redirect the client using a 3xx status code [RFC2616]. Note that this step can happen together with, before, or after the optional authentication step described above.",
      "ja": "3.サーバが3xxのステータスコード[RFC2616]を使用してクライアントをリダイレクトすることができます。このステップは、前に、または上記任意の認証ステップの後、一緒に起こることができることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "4. Establish the following information:",
      "section_title": true,
      "ja": "4.次の情報を確立します。"
    },
    {
      "indent": 7,
      "text": "/origin/\n   The |Origin| header field in the client's handshake indicates\n   the origin of the script establishing the connection.  The\n   origin is serialized to ASCII and converted to lowercase.  The\n   server MAY use this information as part of a determination of\n   whether to accept the incoming connection.  If the server does\n   not validate the origin, it will accept connections from\n   anywhere.  If the server does not wish to accept this\n   connection, it MUST return an appropriate HTTP error code\n   (e.g., 403 Forbidden) and abort the WebSocket handshake\n   described in this section.  For more detail, refer to\n   Section 10.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "/key/ The |Sec-WebSocket-Key| header field in the client's handshake includes a base64-encoded value that, if decoded, is 16 bytes in length. This (encoded) value is used in the creation of the server's handshake to indicate an acceptance of the connection. It is not necessary for the server to base64- decode the |Sec-WebSocket-Key| value.",
      "ja": "/キー/ |秒-のWebSocketキー|クライアントのハンドシェイクのヘッダーフィールドは、復号化された場合、長さは16バイトであるbase64エンコード値を含みます。この（エンコード）値は、接続の受け入れを示すために、サーバのハンドシェイクの作成に使用されています。秒-のWebSocketキー|サーバが解読base64-する必要はありません|値。"
    },
    {
      "indent": 7,
      "text": "/version/ The |Sec-WebSocket-Version| header field in the client's handshake includes the version of the WebSocket Protocol with which the client is attempting to communicate. If this version does not match a version understood by the server, the server MUST abort the WebSocket handshake described in this section and instead send an appropriate HTTP error code (such as 426 Upgrade Required) and a |Sec-WebSocket-Version| header field indicating the version(s) the server is capable of understanding.",
      "ja": "/バージョン/ |秒-のWebSocket-バージョン|クライアントのハンドシェイクでのヘッダフィールドは、クライアントが通信しようとしているのWebSocketプロトコルのバージョンが含まれています。このバージョンでは、サーバーが理解バージョンと一致しない場合、サーバーは、このセクションで説明するのWebSocketハンドシェイクを中止し、代わりに適切なHTTPエラーコード（のような426のアップグレードが必要）と送らなければなりません|秒-のWebSocket-バージョン|バージョン（S）サーバを示すヘッダフィールドが理解することが可能です。"
    },
    {
      "indent": 7,
      "text": "/resource name/ An identifier for the service provided by the server. If the server provides multiple services, then the value should be derived from the resource name given in the client's handshake in the \"Request-URI\" [RFC2616] of the GET method. If the requested service is not available, the server MUST send an appropriate HTTP error code (such as 404 Not Found) and abort the WebSocket handshake.",
      "ja": "/リソース名/サーバーによって提供されるサービスのための識別子。サーバが複数のサービスを提供する場合、その値は、GETメソッドの「要求URI」[RFC2616]で、クライアントの握手で与えられたリソース名から派生する必要があります。要求されたサービスが利用できない場合、サーバーは、適切なHTTPエラーコード（見つかりませんでした404など）を送信し、WebSocketをハンドシェイクを中止しなければなりません。"
    },
    {
      "indent": 7,
      "text": "/subprotocol/ Either a single value representing the subprotocol the server is ready to use or null. The value chosen MUST be derived from the client's handshake, specifically by selecting one of the values from the |Sec-WebSocket-Protocol| field that the server is willing to use for this connection (if any). If the client's handshake did not contain such a header field or if the server does not agree to any of the client's requested subprotocols, the only acceptable value is null. The absence of such a field is equivalent to the null value (meaning that if the server does not wish to agree to one of the suggested subprotocols, it MUST NOT send back a |Sec-WebSocket-Protocol| header field in its response). The empty string is not the same as the null value for these purposes and is not a legal value for this field. The ABNF for the value of this header field is (token), where the definitions of constructs and rules are as given in [RFC2616].",
      "ja": "/サブプロトコル/どちらのサーバを使用する準備ができてまたはヌルのサブプロトコルを表す単一の値。 |秒-のWebSocket-プロトコル|選択された値は、特にからの値のいずれかを選択することで、クライアントの握手に由来しなければなりませんサーバーは、この接続（もしあれば）のために使用しても構わないと思っているフィールド。クライアントのハンドシェイクは、このようなヘッダフィールドが含まれていなかったか、サーバーがクライアントの要求されたサブプロトコルのいずれかに同意しない場合は、唯一の許容値がnullの場合。 （そのレスポンスのヘッダフィールド| |秒-のWebSocket-プロトコルサーバが提案サブプロトコルのいずれかに同意したくない場合は、それが戻って送ってはならないことを意味する）、そのようなフィールドが存在しない場合は、NULL値と同等です。空の文字列は、これらの目的のためにNULL値と同じではありませんし、このフィールドの有効な値ではありません。このヘッダフィールドの値のためのABNFは、[RFC2616]で与えられる構築物の定義及び規則は、（トークン）です。"
    },
    {
      "indent": 7,
      "text": "/extensions/ A (possibly empty) list representing the protocol-level extensions the server is ready to use. If the server supports multiple extensions, then the value MUST be derived from the client's handshake, specifically by selecting one or more of the values from the |Sec-WebSocket-Extensions| field. The absence of such a field is equivalent to the null value. The empty string is not the same as the null value for these purposes. Extensions not listed by the client MUST NOT be listed. The method by which these values should be selected and interpreted is discussed in Section 9.1.",
      "ja": "サーバが使用する準備ができているプロトコルレベルの拡張を表す/エクステンション/（おそらく空の）リスト。秒-のWebSocket-拡張機能|サーバが複数の拡張子をサポートしている場合、その値は、特にからの値の一つ以上を選択することで、クライアントの握手に由来しなければなりません|フィールド。そのようなフィールドが存在しない場合はNULL値と同等です。空の文字列は、これらの目的のためにNULL値と同じではありません。クライアントがリストされていない拡張がリストされてはなりません。これらの値が選択され、解釈されるべきれる方法は、セクション9.1で議論されています。"
    },
    {
      "indent": 3,
      "text": "5. If the server chooses to accept the incoming connection, it MUST reply with a valid HTTP response indicating the following.",
      "ja": "5.サーバが着信接続を受け入れることを選択した場合、それは以下のことを示す有効なHTTP応答で応答しなければなりません。"
    },
    {
      "indent": 7,
      "text": "1.  A Status-Line with a 101 response code as per RFC 2616\n    [RFC2616].  Such a response could look like \"HTTP/1.1 101\n    Switching Protocols\".",
      "raw": true
    },
    {
      "indent": 7,
      "text": "2. An |Upgrade| header field with value \"websocket\" as per RFC 2616 [RFC2616].",
      "ja": "【請求項2】|アップグレード| RFC 2616 [RFC2616]の通りの値 \"のWebSocket\" のヘッダフィールド。"
    },
    {
      "indent": 7,
      "text": "3. A |Connection| header field with value \"Upgrade\".",
      "section_title": true,
      "ja": "3. A |接続|値を持つヘッダフィールド「アップグレード」。"
    },
    {
      "indent": 7,
      "text": "4. A |Sec-WebSocket-Accept| header field. The value of this header field is constructed by concatenating /key/, defined above in step 4 in Section 4.2.2, with the string \"258EAFA5- E914-47DA-95CA-C5AB0DC85B11\", taking the SHA-1 hash of this concatenated value to obtain a 20-byte value and base64- encoding (see Section 4 of [RFC4648]) this 20-byte hash.",
      "ja": "4. A |秒-のWebSocket-受け入れ|ヘッダフィールド。このヘッダーフィールドの値は、この連結値のSHA-1ハッシュを取って、文字列「258EAFA5- E914-47DA-95CA-C5AB0DC85B11」と、4.2.2項のステップ4において上で定義/キー/を連結することによって構成されています20バイトの値とbase64-エンコーディングを取得するために、この20バイト・ハッシュ（[RFC4648]のセクション4を参照）。"
    },
    {
      "indent": 11,
      "text": "The ABNF [RFC2616] of this header field is defined as\nfollows:",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Sec-WebSocket-Accept = base64-value-non-empty base64-value-non-empty = (1*base64-data [ base64-padding ]) | base64-padding base64-data = 4base64-character base64-padding = (2base64-character \"==\") | (3base64-character \"=\") base64-character = ALPHA | DIGIT | \"+\" | \"/\"",
      "ja": "SEC-のWebSocket-受け入れ= BASE64値非空BASE64値 - 非空=（1 * BASE64データ[BASE64パディング]）| base64でパディングbase64でデータ= 4base64文字のbase64でパディング=（2base64文字 \"==\"）| （3base64文字 \"=\"）base64で文字= ALPHA | DIGIT | \"+\" | \"/\""
    },
    {
      "indent": 3,
      "text": "NOTE: As an example, if the value of the |Sec-WebSocket-Key| header field in the client's handshake were \"dGhlIHNhbXBsZSBub25jZQ==\", the server would append the string \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\" to form the string \"dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11\". The server would then take the SHA-1 hash of this string, giving the value 0xb3 0x7a 0x4f 0x2c 0xc0 0x62 0x4f 0x16 0x90 0xf6 0x46 0x06 0xcf 0x38 0x59 0x45 0xb2 0xbe 0xc4 0xea. This value is then base64-encoded, to give the value \"s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\", which would be returned in the |Sec-WebSocket-Accept| header field.",
      "ja": "注：例として、の値|秒-のWebSocketキー|クライアントのハンドシェイクでのヘッダーフィールドが \"dGhlIHNhbXBsZSBub25jZQ ==\" だった、サーバーは、文字列を追加します \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\" 文字列 \"dGhlIHNhbXBsZSBub25jZQ == 258EAFA5-E914-47DA-95CA-C5AB0DC85B11\" を形成します。サーバは、値0xb3 0x7Aの0x4f 0x2c 0xc0から0x62 0x16 0x90を0x4f 0xf6 0x46の0x06で0xcf 0x38 0x59 0x45コード（0xB2）0xbe 0xc4 0xeaを与えて、この文字列のSHA-1ハッシュを取るだろう。この値は、で返される値は「s3pPLMBiTxaQ9kYGzzhZRbK + xOo =」を与えるために、その後、base64エンコードされ|秒-のWebSocket-受け入れ|ヘッダフィールド。"
    },
    {
      "indent": 7,
      "text": "5.  Optionally, a |Sec-WebSocket-Protocol| header field, with a\n    value /subprotocol/ as defined in step 4 in Section 4.2.2.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "6. Optionally, a |Sec-WebSocket-Extensions| header field, with a value /extensions/ as defined in step 4 in Section 4.2.2. If multiple extensions are to be used, they can all be listed in a single |Sec-WebSocket-Extensions| header field or split between multiple instances of the |Sec-WebSocket-Extensions| header field.",
      "ja": "6.必要に応じて、|秒-のWebSocket-拡張機能|ヘッダフィールド、値/拡張子/ 4.2.2におけるステップ4で定義した通りです。秒-のWebSocket-拡張機能|複数の拡張子を使用する場合、それらはすべて、単一に記載されていることができます|秒-のWebSocket-拡張機能|の複数のインスタンス間のヘッダフィールドまたは分割|ヘッダフィールド。"
    },
    {
      "indent": 3,
      "text": "This completes the server's handshake. If the server finishes these steps without aborting the WebSocket handshake, the server considers the WebSocket connection to be established and that the WebSocket connection is in the OPEN state. At this point, the server may begin sending (and receiving) data.",
      "ja": "これは、サーバーのハンドシェイクを完了します。サーバーはWebSocketをハンドシェイクを中断せずにこれらのステップを終了した場合、サーバーは、確立されたとのWebSocket接続がOPEN状態にあることをするのWebSocket接続を考慮します。この時点で、サーバがデータを送信（および受信）を開始することがあります。"
    },
    {
      "indent": 0,
      "text": "4.3. Collected ABNF for New Header Fields Used in Handshake",
      "section_title": true,
      "ja": "4.3. ハンドシェイクで使用される新しいヘッダフィールドのために収集ABNF"
    },
    {
      "indent": 3,
      "text": "This section is using ABNF syntax/rules from Section 2.1 of [RFC2616], including the \"implied *LWS rule\".",
      "ja": "このセクションでは、「暗黙* LWSルール」を含む、[RFC2616]のセクション2.1からABNF構文/規則を使用しています。"
    },
    {
      "indent": 3,
      "text": "Note that the following ABNF conventions are used in this section. Some names of the rules correspond to names of the corresponding header fields. Such rules express values of the corresponding header fields, for example, the Sec-WebSocket-Key ABNF rule describes syntax of the |Sec-WebSocket-Key| header field value. ABNF rules with the \"-Client\" suffix in the name are only used in requests sent by the client to the server; ABNF rules with the \"-Server\" suffix in the name are only used in responses sent by the server to the client. For example, the ABNF rule Sec-WebSocket-Protocol-Client describes syntax of the |Sec-WebSocket-Protocol| header field value sent by the client to the server.",
      "ja": "以下のABNF規則は、このセクションで使用されていることに注意してください。ルールのいくつかの名前は、対応するヘッダフィールドの名前に対応します。 |秒-のWebSocketキー|そのようなルールは、例えば、秒-のWebSocketキーABNF規則はの構文を記述する、対応するヘッダフィールドの値を表しますヘッダフィールド値。名前に「いるクライアント」接尾辞ABNF規則は、のみ、クライアントからサーバに送信された要求で使用されています。名前に「-Server」サフィックスを持つABNF規則は、唯一のサーバからクライアントに送信された応答に使用されています。 |秒-のWebSocket-プロトコル|例えば、ABNFは、SEC-のWebSocket-プロトコル - クライアントがの構文について説明ルールクライアントからサーバに送信されたヘッダフィールドの値。"
    },
    {
      "indent": 3,
      "text": "The following new header fields can be sent during the handshake from the client to the server:",
      "ja": "次の新しいヘッダフィールドは、クライアントからサーバへのハンドシェイク中に送信することができます。"
    },
    {
      "indent": 6,
      "text": "Sec-WebSocket-Key = base64-value-non-empty Sec-WebSocket-Extensions = extension-list Sec-WebSocket-Protocol-Client = 1#token Sec-WebSocket-Version-Client = version",
      "ja": "SEC-のWebSocket-キー= base64で値 - 非空秒-のWebSocket-拡張=拡張子リスト秒-のWebSocket-プロトコルクライアント= 1＃トークン秒-のWebSocket-バージョン - クライアント=バージョン"
    },
    {
      "indent": 6,
      "text": "base64-value-non-empty = (1*base64-data [ base64-padding ]) | base64-padding base64-data = 4base64-character base64-padding = (2base64-character \"==\") | (3base64-character \"=\") base64-character = ALPHA | DIGIT | \"+\" | \"/\" extension-list = 1#extension extension = extension-token *( \";\" extension-param ) extension-token = registered-token registered-token = token extension-param = token [ \"=\" (token | quoted-string) ] ; When using the quoted-string syntax variant, the value ; after quoted-string unescaping MUST conform to the ; 'token' ABNF. NZDIGIT = \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" version = DIGIT | (NZDIGIT DIGIT) | (\"1\" DIGIT DIGIT) | (\"2\" DIGIT DIGIT) ; Limited to 0-255 range, with no leading zeros",
      "ja": "BASE64値 - 非空=（1 * BASE64データ[BASE64パディング]）| base64でパディングbase64でデータ= 4base64文字のbase64でパディング=（2base64文字 \"==\"）| （3base64文字 \"=\"）base64で文字= ALPHA | DIGIT | \"+\" | \"/\" 拡張リスト= 1つの＃拡張延長=拡張トークン*（ \";\" 拡張-PARAM）拡張トークン=登録トークン登録トークン=トークン拡張-PARAM =トークン[ \"=\"（トークン| quoted-文字列）];引用符で囲まれた文字列の構文バリアントを使用して、値。引用符で囲まれた文字列のアンエスケープの後に従わなければなりません。 'トークン' ABNF。 NZDIGIT = \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" バージョン= DIGIT | （NZDIGITのDIGIT）| （ \"1\" DIGITのDIGIT）| （ \"2\" の数字DIGIT）。無先行ゼロで、0〜255の範囲に限定"
    },
    {
      "indent": 3,
      "text": "The following new header fields can be sent during the handshake from the server to the client:",
      "ja": "次の新しいヘッダフィールドは、サーバからクライアントにハンドシェイク中に送信することができます。"
    },
    {
      "indent": 6,
      "text": "Sec-WebSocket-Extensions = extension-list Sec-WebSocket-Accept = base64-value-non-empty Sec-WebSocket-Protocol-Server = token Sec-WebSocket-Version-Server = 1#version",
      "ja": "SEC-のWebSocket-拡張=拡張子リスト秒-のWebSocket-受け入れ= base64で値 - 非空秒-のWebSocket-プロトコルサーバーを=トークン秒-のWebSocket-バージョン-サーバ= 1つの＃バージョン"
    },
    {
      "indent": 0,
      "text": "4.4. Supporting Multiple Versions of WebSocket Protocol",
      "section_title": true,
      "ja": "4.4.  WebSocketプロトコルの複数のバージョンをサポート"
    },
    {
      "indent": 3,
      "text": "This section provides some guidance on supporting multiple versions of the WebSocket Protocol in clients and servers.",
      "ja": "このセクションでは、クライアントとサーバーでのWebSocketプロトコルの複数のバージョンをサポートする上でいくつかのガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "Using the WebSocket version advertisement capability (the |Sec-WebSocket-Version| header field), a client can initially request the version of the WebSocket Protocol that it prefers (which doesn't necessarily have to be the latest supported by the client). If the server supports the requested version and the handshake message is otherwise valid, the server will accept that version. If the server doesn't support the requested version, it MUST respond with a |Sec-WebSocket-Version| header field (or multiple |Sec-WebSocket-Version| header fields) containing all versions it is willing to use. At this point, if the client supports one of the advertised versions, it can repeat the WebSocket handshake using a new version value.",
      "ja": "（|秒-のWebSocket-バージョン|ヘッダフィールド）のWebSocket版の広告機能を使用して、クライアントが最初に（必ずしもクライアントがサポートする最新である必要はありません）それが好むのWebSocketプロトコルのバージョンを要求することができます。サーバは要求されたバージョンをサポートしており、ハンドシェイクメッセージがそれ以外有効な場合、サーバーはそのバージョンを受け入れます。サーバは要求されたバージョンをサポートしていない場合、それは応じなければなりません|秒-のWebSocket-バージョン|使用して喜んでいるすべてのバージョンを含むヘッダフィールド（ヘッダフィールドや複数| |秒-のWebSocket-版）。クライアントは、アドバタイズされたバージョンのいずれかをサポートしている場合は、この時点で、それは新しいバージョンの値を使用してのWebSocketハンドシェイクを繰り返すことができます。"
    },
    {
      "indent": 3,
      "text": "The following example demonstrates version negotiation described above:",
      "ja": "次の例では、上記のバージョン交渉を示しています。"
    },
    {
      "indent": 6,
      "text": "GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade ... Sec-WebSocket-Version: 25",
      "ja": "server.example.comアップグレード：WebSocketの接続：...秒-のWebSocket-バージョンをアップグレード：25 / HTTP / 1.1ホストをチャットGET"
    },
    {
      "indent": 3,
      "text": "The response from the server might look as follows:",
      "ja": "次のようにサーバからの応答が見えるかもしれません。"
    },
    {
      "indent": 6,
      "text": "HTTP/1.1 400 Bad Request ... Sec-WebSocket-Version: 13, 8, 7",
      "ja": "HTTP / 1.1 400不正な要求...秒-のWebSocket-バージョン：13、8、7"
    },
    {
      "indent": 3,
      "text": "Note that the last response from the server might also look like:",
      "ja": "サーバーからの最後の応答はまた、のように見えるかもしれないことに注意してください："
    },
    {
      "indent": 6,
      "text": "HTTP/1.1 400 Bad Request ... Sec-WebSocket-Version: 13 Sec-WebSocket-Version: 8, 7",
      "ja": "HTTP / 1.1 400不正な要求...秒-のWebSocket-バージョン：13秒-のWebSocket-バージョン：8、7"
    },
    {
      "indent": 3,
      "text": "The client now repeats the handshake that conforms to version 13:",
      "ja": "クライアントは、バージョン13に準拠して握手を繰り返し："
    },
    {
      "indent": 6,
      "text": "GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade ... Sec-WebSocket-Version: 13",
      "ja": "server.example.comアップグレード：WebSocketの接続：...秒-のWebSocket-バージョンをアップグレード：13 / HTTP / 1.1ホストをチャットGET"
    },
    {
      "indent": 0,
      "text": "5. Data Framing",
      "section_title": true,
      "ja": "5.データフレーミング"
    },
    {
      "indent": 0,
      "text": "5.1. Overview",
      "section_title": true,
      "ja": "5.1. 概要"
    },
    {
      "indent": 3,
      "text": "In the WebSocket Protocol, data is transmitted using a sequence of frames. To avoid confusing network intermediaries (such as intercepting proxies) and for security reasons that are further discussed in Section 10.3, a client MUST mask all frames that it sends to the server (see Section 5.3 for further details). (Note that masking is done whether or not the WebSocket Protocol is running over TLS.) The server MUST close the connection upon receiving a frame that is not masked. In this case, a server MAY send a Close frame with a status code of 1002 (protocol error) as defined in Section 7.4.1. A server MUST NOT mask any frames that it sends to the client. A client MUST close a connection if it detects a masked frame. In this case, it MAY use the status code 1002 (protocol error) as defined in Section 7.4.1. (These rules might be relaxed in a future specification.)",
      "ja": "WebSocketのプロトコルでは、データは、フレームのシーケンスを用いて送信されます。 （そのようなプロキシを遮断するなど）、さらに、セクション10.3で議論されているセキュリティ上の理由により、混乱のネットワーク仲介を避けるために、それをサーバーに送信するすべてのフレームをマスクしなければならないクライアントが（詳細は5.3節を参照してください）。 （マスキングがのWebSocketプロトコルTLS上で実行されているか否かで行われることに注意してください。）サーバがマスクされていないフレームを受信すると、接続を閉じる必要があります。 7.4.1項で定義されるように、この場合に、サーバ1002のステータスコード（プロトコルエラー）との緊密なフレームを送信することができます。サーバはそれがクライアントに送信することを任意のフレームを隠してはなりません。それがマスクされたフレームを検出した場合、クライアントは接続を閉じる必要があります。 7.4.1項で定義されるように、この場合には、ステータスコード1002（プロトコルエラー）を使用することができます。 （これらのルールは、将来の仕様で緩和されるかもしれません。）"
    },
    {
      "indent": 3,
      "text": "The base framing protocol defines a frame type with an opcode, a payload length, and designated locations for \"Extension data\" and \"Application data\", which together define the \"Payload data\". Certain bits and opcodes are reserved for future expansion of the protocol.",
      "ja": "ベースフレーミングプロトコルは、オペコードと、フレームタイプ、ペイロード長、及び「拡張データ」と一緒に「ペイロードデータ」を定義する「アプリケーションデータ」、のために指定された場所を定義します。特定のビット及びオプコードは、プロトコルの将来の拡張のために予約されています。"
    },
    {
      "indent": 3,
      "text": "A data frame MAY be transmitted by either the client or the server at any time after opening handshake completion and before that endpoint has sent a Close frame (Section 5.5.1).",
      "ja": "データフレームは、ハンドシェイク完了を開いた後の任意の時点で、クライアントまたはサーバのいずれかによって送信されても​​よく、そのエンドポイントの前に（セクション5.5.1）閉じるフレームを送信しました。"
    },
    {
      "indent": 0,
      "text": "5.2. Base Framing Protocol",
      "section_title": true,
      "ja": "5.2. 基本フレーミングプロトコル"
    },
    {
      "indent": 3,
      "text": "This wire format for the data transfer part is described by the ABNF [RFC5234] given in detail in this section. (Note that, unlike in other sections of this document, the ABNF in this section is operating on groups of bits. The length of each group of bits is indicated in a comment. When encoded on the wire, the most significant bit is the leftmost in the ABNF). A high-level overview of the framing is given in the following figure. In a case of conflict between the figure below and the ABNF specified later in this section, the figure is authoritative.",
      "ja": "データ転送部については、このワイヤフォーマットは、このセクションで詳細に説明ABNF [RFC5234]に記載されています。 （この文書の他のセクションとは異なり、このセクションのABNFは、ビットのグループで動作していることに留意されたい。ビットの各グループの長さは、コメントに示されている。ワイヤ上に符号化する場合、最上位ビットは最も左のありますABNFで）。フレーミングの高レベルの概要を次の図に示されています。以下の図およびそれ以降このセクションで指定されたABNFとの間に矛盾する場合には、図は、権威あります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-------+-+-------------+-------------------------------+\n|F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n|N|V|V|V|       |S|             |   (if payload len==126/127)   |\n| |1|2|3|       |K|             |                               |\n+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n|     Extended payload length continued, if payload len == 127  |\n+ - - - - - - - - - - - - - - - +-------------------------------+\n|                               |Masking-key, if MASK set to 1  |\n+-------------------------------+-------------------------------+\n| Masking-key (continued)       |          Payload Data         |\n+-------------------------------- - - - - - - - - - - - - - - - +\n:                     Payload Data continued ...                :\n+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n|                     Payload Data continued ...                |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "FIN: 1 bit",
      "ja": "FIN：1ビット"
    },
    {
      "indent": 6,
      "text": "Indicates that this is the final fragment in a message. The first fragment MAY also be the final fragment.",
      "ja": "これはメッセージの最後のフラグメントであることを示しています。最初のフラグメントはまた、最終的な断片であってもよいです。"
    },
    {
      "indent": 3,
      "text": "RSV1, RSV2, RSV3: 1 bit each",
      "ja": "RSV1、RSV2、RSV3：1ビット毎"
    },
    {
      "indent": 6,
      "text": "MUST be 0 unless an extension is negotiated that defines meanings for non-zero values. If a nonzero value is received and none of the negotiated extensions defines the meaning of such a nonzero value, the receiving endpoint MUST _Fail the WebSocket Connection_.",
      "ja": "拡張子が非ゼロ値のための意味を定義する交渉されない限り、0でなければなりません。ゼロ以外の値を受信し、ネゴシエートされた拡張機能のいずれも、そのようなゼロ以外の値の意味を定義していない場合、受信エンドポイントのWebSocket Connection_を_Failしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Opcode: 4 bits",
      "ja": "オペコード：4ビット"
    },
    {
      "indent": 6,
      "text": "Defines the interpretation of the \"Payload data\". If an unknown opcode is received, the receiving endpoint MUST _Fail the WebSocket Connection_. The following values are defined.",
      "ja": "「ペイロードデータ」の解釈を定義します。不明なオペコードを受信した場合、受信側のエンドポイントは、WebSocketをConnection_を_Failしなければなりません。次の値が定義されています。"
    },
    {
      "indent": 6,
      "text": "* %x0 denotes a continuation frame",
      "ja": "*％のx0が継続フレームを表し、"
    },
    {
      "indent": 6,
      "text": "* %x1 denotes a text frame",
      "ja": "*％x1がテキストフレームを表し、"
    },
    {
      "indent": 6,
      "text": "* %x2 denotes a binary frame",
      "ja": "*％X2はバイナリフレームを表し、"
    },
    {
      "indent": 6,
      "text": "* %x3-7 are reserved for further non-control frames",
      "ja": "*％のx3-7は、非制御フレーム用に予約されてい"
    },
    {
      "indent": 6,
      "text": "* %x8 denotes a connection close",
      "ja": "*％のX8は、接続クローズを表し、"
    },
    {
      "indent": 6,
      "text": "* %x9 denotes a ping",
      "ja": "*％のX9にpingを表し、"
    },
    {
      "indent": 6,
      "text": "* %xA denotes a pong",
      "ja": "XAの％*は、ピンポンを表し、"
    },
    {
      "indent": 6,
      "text": "* %xB-F are reserved for further control frames",
      "ja": "*％XB-Fは、さらに制御フレーム用に予約されてい"
    },
    {
      "indent": 3,
      "text": "Mask: 1 bit",
      "ja": "マスク：1ビット"
    },
    {
      "indent": 6,
      "text": "Defines whether the \"Payload data\" is masked. If set to 1, a masking key is present in masking-key, and this is used to unmask the \"Payload data\" as per Section 5.3. All frames sent from client to server have this bit set to 1.",
      "ja": "「ペイロードデータが」マスクされているかどうかを定義します。 1に設定すると、マスキングキーはマスキングキーに存在し、これは5.3節ごとに「ペイロードデータ」をアンマスクするために使用されます。クライアントからサーバーに送信されたすべてのフレームは、このビットが1に設定されています。"
    },
    {
      "indent": 3,
      "text": "Payload length: 7 bits, 7+16 bits, or 7+64 bits",
      "ja": "ペイロード長：7ビット、7 + 16ビット、または7 + 64ビット"
    },
    {
      "indent": 6,
      "text": "The length of the \"Payload data\", in bytes: if 0-125, that is the payload length. If 126, the following 2 bytes interpreted as a 16-bit unsigned integer are the payload length. If 127, the following 8 bytes interpreted as a 64-bit unsigned integer (the most significant bit MUST be 0) are the payload length. Multibyte length quantities are expressed in network byte order. Note that in all cases, the minimal number of bytes MUST be used to encode the length, for example, the length of a 124-byte-long string can't be encoded as the sequence 126, 0, 124. The payload length is the length of the \"Extension data\" + the length of the \"Application data\". The length of the \"Extension data\" may be zero, in which case the payload length is the length of the \"Application data\".",
      "ja": "バイトの「ペイロードデータ」の長さ：0から125あれば、それはペイロード長です。 126場合は、16ビットの符号なし整数として解釈以下の2つのバイトは、ペイロードの長さです。 127、次の8つのバイトは、64ビットの符号なし整数として解釈された場合、ペイロード長さ（最上位ビットが0でなければなりません）。マルチバイト長数量は、ネットワークバイト順で表現されます。 、124ペイロード長は、全ての場合において、バイトの最小数は、例えば、124バイト長の文字列の長さは、配列126、0としてエンコードすることができない、長さを符号化するために使用する必要があります「拡張データ」+「アプリケーションデータ」の長さの長さ。 「拡張データ」の長さは、ペイロード長は、「アプリケーションデータ」の長さである場合には、ゼロであってもよいです。"
    },
    {
      "indent": 3,
      "text": "Masking-key: 0 or 4 bytes",
      "ja": "マスキングキー：0または4バイト"
    },
    {
      "indent": 6,
      "text": "All frames sent from the client to the server are masked by a 32-bit value that is contained within the frame. This field is present if the mask bit is set to 1 and is absent if the mask bit is set to 0. See Section 5.3 for further information on client-to-server masking.",
      "ja": "クライアントからサーバに送信されるすべてのフレームは、フレーム内に含まれる32ビットの値によりマスクされます。このフィールドは、マスクビットが1に設定されている場合に存在し、マスクビットは、クライアントからサーバーへのマスキングの詳細については0参照セクション5.3に設定されている場合は存在しません。"
    },
    {
      "indent": 3,
      "text": "Payload data: (x+y) bytes",
      "ja": "ペイロードデータ（X + Y）バイト"
    },
    {
      "indent": 6,
      "text": "The \"Payload data\" is defined as \"Extension data\" concatenated with \"Application data\".",
      "ja": "「ペイロードデータ」は、「拡張データ」、「アプリケーションデータ」との連結として定義されます。"
    },
    {
      "indent": 3,
      "text": "Extension data: x bytes",
      "ja": "拡張データ：xバイト"
    },
    {
      "indent": 6,
      "text": "The \"Extension data\" is 0 bytes unless an extension has been negotiated. Any extension MUST specify the length of the \"Extension data\", or how that length may be calculated, and how the extension use MUST be negotiated during the opening handshake. If present, the \"Extension data\" is included in the total payload length.",
      "ja": "拡張子が交渉されていない限り、「拡張データが」0バイトです。任意の拡張子は「拡張データ」、またはどのようにその長さを計算することができる方法、および拡張用開口ハンドシェーク中にネゴシエートされなければならないの長さを指定しなければなりません。存在する場合、「拡張データ」は総ペイロード長に含まれています。"
    },
    {
      "indent": 3,
      "text": "Application data: y bytes",
      "ja": "アプリケーションデータ：Yバイト"
    },
    {
      "indent": 6,
      "text": "Arbitrary \"Application data\", taking up the remainder of the frame after any \"Extension data\". The length of the \"Application data\" is equal to the payload length minus the length of the \"Extension data\".",
      "ja": "任意の「拡張データ」の後のフレームの残りの部分を巻き取る任意の「アプリケーションデータ」、。 「アプリケーションデータ」の長さは、ペイロード長マイナス「拡張データ」の長さに等しいです。"
    },
    {
      "indent": 3,
      "text": "The base framing protocol is formally defined by the following ABNF [RFC5234]. It is important to note that the representation of this data is binary, not ASCII characters. As such, a field with a length of 1 bit that takes values %x0 / %x1 is represented as a single bit whose value is 0 or 1, not a full byte (octet) that stands for the characters \"0\" or \"1\" in the ASCII encoding. A field with a length of 4 bits with values between %x0-F again is represented by 4 bits, again NOT by an ASCII character or full byte (octet) with these values. [RFC5234] does not specify a character encoding: \"Rules resolve into a string of terminal values, sometimes called characters. In ABNF, a character is merely a non-negative integer. In certain contexts, a specific mapping (encoding) of values into a character set (such as ASCII) will be specified.\" Here, the specified encoding is a binary encoding where each terminal value is encoded in the specified number of bits, which varies for each field.",
      "ja": "ベースフレーミングプロトコルは正式以下ABNF [RFC5234]で定義されます。このデータの表現はバイナリではなくASCII文字であることに注意することが重要です。 ％X0 /％X1は文字を表し、その値が0または1であり、完全ではないバイト（オクテット）単一ビットとして表され、「0」又は「1値をとる1ビットの長さのような、フィールドと「ASCIIエンコーディングインチ％のX0-Fの間の値を有する4ビットの長さフィールドは、再び、これらの値とNOT ASCII文字または完全なバイト（オクテット）で再度、4ビットで表現されます。 [RFC5234]の文字エンコーディングを指定しない：「ルールは、端末値、とも呼ばれる文字の文字列に解決をABNFでは、文字は単に負でない整数である特定の状況では、値の特定のマッピング（エンコーディング）に。 （ASCIIなど）文字セットが指定されます。」ここで、指定されたエンコーディングは、各端末値をフィールド毎に異なり指定したビット数に符号化されるバイナリエンコーディングです。"
    },
    {
      "indent": 4,
      "text": "ws-frame = frame-fin ; 1 bit in length frame-rsv1 ; 1 bit in length frame-rsv2 ; 1 bit in length frame-rsv3 ; 1 bit in length frame-opcode ; 4 bits in length frame-masked ; 1 bit in length frame-payload-length ; either 7, 7+16, ; or 7+64 bits in ; length [ frame-masking-key ] ; 32 bits in length frame-payload-data ; n*8 bits in ; length, where ; n >= 0",
      "ja": "WS-フレーム=フレームフィン。長フレームRSV1 1ビット。長フレームRSV2 1ビット。長フレームRSV3 1ビット。長フレームオペコードに1ビット。長フレームマスクされた4ビット。長フレームペイロード長が1ビット; 7,7 + 16、のいずれか。あるいは7 + 64ビットで、長さ[フレームマスキングキー]。長フレームペイロード・データは32ビット、 N * 8ビットで。長さ; N> = 0"
    },
    {
      "indent": 4,
      "text": "frame-fin = %x0 ; more frames of this message follow / %x1 ; final frame of this message ; 1 bit in length",
      "ja": "フレームフィン=％のX0。このメッセージのフォロー/％X1のより多くのフレーム。このメッセージの最後のフレームと長さが1ビット"
    },
    {
      "indent": 4,
      "text": "frame-rsv1 = %x0 / %x1 ; 1 bit in length, MUST be 0 unless ; negotiated otherwise",
      "ja": "フレームRSV1 =％のX0 /％×1。長さが1ビットがない限り、0でなければなりません。そうでない場合は、ネゴシエート"
    },
    {
      "indent": 4,
      "text": "frame-rsv2 = %x0 / %x1 ; 1 bit in length, MUST be 0 unless ; negotiated otherwise",
      "ja": "フレームRSV2 =％のX0 /％×1。長さが1ビットがない限り、0でなければなりません。そうでない場合は、ネゴシエート"
    },
    {
      "indent": 4,
      "text": "frame-rsv3 = %x0 / %x1 ; 1 bit in length, MUST be 0 unless ; negotiated otherwise",
      "ja": "フレームRSV3 =％のX0 /％×1。長さが1ビットがない限り、0でなければなりません。そうでない場合は、ネゴシエート"
    },
    {
      "indent": 4,
      "text": "frame-opcode = frame-opcode-non-control / frame-opcode-control / frame-opcode-cont",
      "ja": "フレームオペコード=フレームオペコード非制御/フレームオペコードコントロール/フレームオペコード-CONT"
    },
    {
      "indent": 4,
      "text": "frame-opcode-cont = %x0 ; frame continuation",
      "ja": "フレームオペコード-CONT =％X0。フレーム継続"
    },
    {
      "indent": 4,
      "text": "frame-opcode-non-control= %x1 ; text frame / %x2 ; binary frame / %x3-7 ; 4 bits in length, ; reserved for further non-control frames",
      "ja": "フレームオペコード非制御=％×1。テキストフレーム/％×2。バイナリフレーム/％x3-7。長さが4ビット、。さらに、非制御フレーム用に予約"
    },
    {
      "indent": 4,
      "text": "frame-opcode-control = %x8 ; connection close / %x9 ; ping / %xA ; pong / %xB-F ; reserved for further control ; frames ; 4 bits in length",
      "ja": "フレームオペコードコントロール=％のX8。接続クローズ/％のX9。ピング/％をxA;ピンポン/％XB-F。さらに制御するために予約。フレーム;長さが4ビット"
    },
    {
      "indent": 4,
      "text": "frame-masked = %x0 ; frame is not masked, no frame-masking-key / %x1 ; frame is masked, frame-masking-key present ; 1 bit in length",
      "ja": "フレームマスキング=％のX0。フレームマスクされていない、ノーフレームマスキングキー/％×1。フレームは、フレームマスキング鍵存在をマスクされます。長さが1ビット"
    },
    {
      "indent": 4,
      "text": "frame-payload-length = ( %x00-7D ) / ( %x7E frame-payload-length-16 ) / ( %x7F frame-payload-length-63 ) ; 7, 7+16, or 7+64 bits in length, ; respectively",
      "ja": "フレームペイロード長=（％のx00-7D）/（％x7Eフレームペイロード長-16）/（％x7Fフレームペイロード長-63）; 7、+ 16 7、または長さが7 + 64ビット、。各々"
    },
    {
      "indent": 4,
      "text": "frame-payload-length-16 = %x0000-FFFF ; 16 bits in length",
      "ja": "フレームペイロード長-16 =％X0000-FFFF。長さが16ビット"
    },
    {
      "indent": 4,
      "text": "frame-payload-length-63 = %x0000000000000000-7FFFFFFFFFFFFFFF ; 64 bits in length",
      "ja": "フレームペイロード長-63 =％x0000000000000000-7FFFFFFFFFFFFFFF。長さが64ビット"
    },
    {
      "indent": 4,
      "text": "frame-masking-key = 4( %x00-FF ) ; present only if frame-masked is 1 ; 32 bits in length",
      "ja": "フレームマスキングキー= 4（％のX00-FF）。フレーム・マスクが1である場合にのみ存在。長さが32ビット"
    },
    {
      "indent": 4,
      "text": "frame-payload-data = (frame-masked-extension-data frame-masked-application-data) ; when frame-masked is 1 / (frame-unmasked-extension-data frame-unmasked-application-data) ; when frame-masked is 0",
      "ja": "フレームペイロードデータ=（フレーム・マスク・拡張データフレームのマスクされたアプリケーションデータ）。フレームマスキングは、1 /（フレーム・マスクされていない拡張データフレームマスクされていないアプリケーション・データ）である場合、フレームマスキングが0のとき"
    },
    {
      "indent": 4,
      "text": "frame-masked-extension-data = *( %x00-FF ) ; reserved for future extensibility ; n*8 bits in length, where n >= 0",
      "ja": "フレーム・マスク拡張データ= *（％のX00-FF）。将来の拡張のために予約。長さN * 8ビット、N> = 0"
    },
    {
      "indent": 4,
      "text": "frame-masked-application-data = *( %x00-FF ) ; n*8 bits in length, where n >= 0",
      "ja": "フレーム・マスク・アプリケーション・データ= *（％のX00-FF）。長さN * 8ビット、N> = 0"
    },
    {
      "indent": 4,
      "text": "frame-unmasked-extension-data = *( %x00-FF ) ; reserved for future extensibility ; n*8 bits in length, where n >= 0",
      "ja": "フレームマスクされていない拡張データ= *（％のX00-FF）。将来の拡張のために予約。長さN * 8ビット、N> = 0"
    },
    {
      "indent": 4,
      "text": "frame-unmasked-application-data = *( %x00-FF ) ; n*8 bits in length, where n >= 0",
      "ja": "フレームマスクされていないアプリケーションデータ= *（％のX00-FF）。長さN * 8ビット、N> = 0"
    },
    {
      "indent": 0,
      "text": "5.3. Client-to-Server Masking",
      "section_title": true,
      "ja": "5.3. クライアントとサーバーのマスキング"
    },
    {
      "indent": 3,
      "text": "A masked frame MUST have the field frame-masked set to 1, as defined in Section 5.2.",
      "ja": "マスキングされたフレームは、セクション5.2で定義されるように、1フィールドのフレーム・マスクセットがなければなりません。"
    },
    {
      "indent": 3,
      "text": "The masking key is contained completely within the frame, as defined in Section 5.2 as frame-masking-key. It is used to mask the \"Payload data\" defined in the same section as frame-payload-data, which includes \"Extension data\" and \"Application data\".",
      "ja": "フレームマスキングキーとして、セクション5.2で定義されるようにマスキング鍵は、フレーム内に完全に収容されています。 「拡張データ」と「アプリケーションデータ」を含むフレームペイロードデータと同一のセクションで定義された「ペイロードデータ」を、マスクするために使用されます。"
    },
    {
      "indent": 3,
      "text": "The masking key is a 32-bit value chosen at random by the client. When preparing a masked frame, the client MUST pick a fresh masking key from the set of allowed 32-bit values. The masking key needs to be unpredictable; thus, the masking key MUST be derived from a strong source of entropy, and the masking key for a given frame MUST NOT make it simple for a server/proxy to predict the masking key for a subsequent frame. The unpredictability of the masking key is essential to prevent authors of malicious applications from selecting the bytes that appear on the wire. RFC 4086 [RFC4086] discusses what entails a suitable source of entropy for security-sensitive applications.",
      "ja": "マスキング鍵は、クライアントによってランダムに選択された32ビットの値です。マスクされたフレームを製造する場合、クライアントが許可さ32ビット値のセットからの新鮮なマスキングキーを選択しなければなりません。マスキング鍵は予測不可能である必要があります。従って、マスキング鍵は、エントロピーの強力な供給源に由来しなければならない、と指定されたフレームのマスキング鍵は、それが単純なサーバ/プロキシは、後続のフレームのためのマスキングキーを予測するためてはなりません。マスキングキーの予測不可能性は、ワイヤ上に表示されたバイトを選択するから悪質なアプリケーションの作成者を防ぐために不可欠です。 RFC 4086 [RFC4086]は、セキュリティに敏感なアプリケーションのためのエントロピーの適切な供給源を必要とするものについて説明します。"
    },
    {
      "indent": 3,
      "text": "The masking does not affect the length of the \"Payload data\". To convert masked data into unmasked data, or vice versa, the following algorithm is applied. The same algorithm applies regardless of the direction of the translation, e.g., the same steps are applied to mask the data as to unmask the data.",
      "ja": "マスキングは、「ペイロードデータ」の長さに影響を与えることはありません。マスクされていないデータ、又はその逆にマスクされたデータを変換するために、以下のアルゴリズムが適用されます。同じアルゴリズムは関係なく、並進方向の適用、例えば、同一のステップは、データのマスクを解除するようにデータをマスクするために適用されます。"
    },
    {
      "indent": 3,
      "text": "Octet i of the transformed data (\"transformed-octet-i\") is the XOR of octet i of the original data (\"original-octet-i\") with octet at index i modulo 4 of the masking key (\"masking-key-octet-j\"):",
      "ja": "変換されたデータのオクテットiが（「形質転換されたオクテット-I」）私はマスキングキー（「マスキングキー4を法とするインデックスでオクテットと、元のデータ（「元のオクテット-I」）のオクテットIのXORであります-octet-J」）："
    },
    {
      "indent": 5,
      "text": "j = i MOD 4 transformed-octet-i = original-octet-i XOR masking-key-octet-j",
      "ja": "J = MOD 4形質オクテット-I =オリジナルオクテット-I XORマスキング鍵オクテット-J"
    },
    {
      "indent": 3,
      "text": "The payload length, indicated in the framing as frame-payload-length, does NOT include the length of the masking key. It is the length of the \"Payload data\", e.g., the number of bytes following the masking key.",
      "ja": "フレームペイロード長などのフレーミングに示されるペイロード長は、マスキングキーの長さを含んでいません。これは、例えば、マスキングキーを以下のバイト数「ペイロードデータ」の長さです。"
    },
    {
      "indent": 0,
      "text": "5.4. Fragmentation",
      "section_title": true,
      "ja": "5.4. フラグメンテーション"
    },
    {
      "indent": 3,
      "text": "The primary purpose of fragmentation is to allow sending a message that is of unknown size when the message is started without having to buffer that message. If messages couldn't be fragmented, then an endpoint would have to buffer the entire message so its length could be counted before the first byte is sent. With fragmentation, a server or intermediary may choose a reasonable size buffer and, when the buffer is full, write a fragment to the network.",
      "ja": "断片化の主な目的は、メッセージがそのメッセージをバッファリングすることなく開始されたときに、未知の大きさでメッセージを送信できるようにすることです。メッセージは断片化できなかった場合、エンドポイントは、最初のバイトが送信される前に、その長さをカウントすることができるよう、メッセージ全体をバッファリングする必要があります。フラグメンテーションと、サーバまたは仲介者は、合理的なサイズのバッファを選択することと、バッファがいっぱいになると、ネットワークへの断片を書き込みます。"
    },
    {
      "indent": 3,
      "text": "A secondary use-case for fragmentation is for multiplexing, where it is not desirable for a large message on one logical channel to monopolize the output channel, so the multiplexing needs to be free to split the message into smaller fragments to better share the output channel. (Note that the multiplexing extension is not described in this document.)",
      "ja": "断片化のための二次利用の場合は、一つの論理チャネルに大きなメッセージが出力チャネルを独占することは望ましくない多重化するためのものであるので、多重化は、より良好な出力チャネルを共有する小さな断片にメッセージを分割して自由にする必要があります。 （多重化拡張が本文書に記載されていないことに注意してください。）"
    },
    {
      "indent": 3,
      "text": "Unless specified otherwise by an extension, frames have no semantic meaning. An intermediary might coalesce and/or split frames, if no extensions were negotiated by the client and the server or if some extensions were negotiated, but the intermediary understood all the extensions negotiated and knows how to coalesce and/or split frames in the presence of these extensions. One implication of this is that in absence of extensions, senders and receivers must not depend on the presence of specific frame boundaries.",
      "ja": "拡張子で特に指定がない限り、フレームが何の意味論的な意味を持ちません。何の拡張は、クライアントとサーバーまたはいくつかの拡張が交渉された場合には交渉しませんが、仲介は、すべての拡張機能が交渉との存在下でフレームを合体および/または分割する方法を知って理解された場合の仲介は、合体および/または分割フレームかもしれませんこれらの拡張機能。これの一つの含意は、拡張機能、送信者と受信者が存在しない状態で特定のフレーム境界の存在に依存してはならないということです。"
    },
    {
      "indent": 3,
      "text": "The following rules apply to fragmentation:",
      "ja": "次の規則が断片化に適用されます。"
    },
    {
      "indent": 3,
      "text": "o An unfragmented message consists of a single frame with the FIN bit set (Section 5.2) and an opcode other than 0.",
      "ja": "O非断片化メッセージがFINビットセット（セクション5.2）と0以外のオペコードを有する単一のフレームで構成されています。"
    },
    {
      "indent": 3,
      "text": "o A fragmented message consists of a single frame with the FIN bit clear and an opcode other than 0, followed by zero or more frames with the FIN bit clear and the opcode set to 0, and terminated by a single frame with the FIN bit set and an opcode of 0. A fragmented message is conceptually equivalent to a single larger message whose payload is equal to the concatenation of the payloads of the fragments in order; however, in the presence of extensions, this may not hold true as the extension defines the interpretation of the \"Extension data\" present. For instance, \"Extension data\" may only be present at the beginning of the first fragment and apply to subsequent fragments, or there may be \"Extension data\" present in each of the fragments that applies only to that particular fragment. In the absence of \"Extension data\", the following example demonstrates how fragmentation works.",
      "ja": "断片化されたメッセージは、FINビットクリアとFINビットクリア、0に設定オペコードゼロ以上のフレームに続く0以外のオペコードを有する単一のフレームで構成され、FINビットセットで単一のフレームによって終了oをおよび0.1のオペコードは、断片化されたメッセージは、そのペイロードの順序でフラグメントのペイロードの連結に等しい単一の大きいメッセージに概念的に等価です。拡張子は「拡張データ」とは、本の解釈を定義するようしかし、拡張の存在下では、これは当てはまらないかもしれません。例えば、「拡張データ」は、最初のフラグメントの先頭に存在してもよく、後続のフラグメントに適用する、またはその特定のフラグメントに適用された断片のそれぞれにおける「拡張データ」が存在してもよいです。 「拡張データ」が存在しない場合には、次の例では、断片化がどのように動作するかを示しています。"
    },
    {
      "indent": 6,
      "text": "EXAMPLE: For a text message sent as three fragments, the first fragment would have an opcode of 0x1 and a FIN bit clear, the second fragment would have an opcode of 0x0 and a FIN bit clear, and the third fragment would have an opcode of 0x0 and a FIN bit that is set.",
      "ja": "例：3つの断片として送られるテキストメッセージのため、最初のフラグメントは、0x1ののオペコードとクリアFINビットを持つことになり、第2の断片は、明らかは0x0のオペコードとFINビットを有するであろう、そして第三の断片は、オペコードを有するであろう0x0と設定されているFINビット。"
    },
    {
      "indent": 3,
      "text": "o Control frames (see Section 5.5) MAY be injected in the middle of a fragmented message. Control frames themselves MUST NOT be fragmented.",
      "ja": "Oコントロールフレーム（セクション5.5を参照）断片化メッセージの中央に注入してもよいです。コントロール自体が断片化してはいけませんフレーム。"
    },
    {
      "indent": 3,
      "text": "o Message fragments MUST be delivered to the recipient in the order sent by the sender.",
      "ja": "Oメッセージ断片は、送信者によって送信されたために、受信者に配信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The fragments of one message MUST NOT be interleaved between the fragments of another message unless an extension has been negotiated that can interpret the interleaving.",
      "ja": "拡張子が交渉されていない限り、一つのメッセージの断片が別のメッセージのフラグメント間でインターリーブされてはならないoをインタリーブを解釈することができます。"
    },
    {
      "indent": 3,
      "text": "o An endpoint MUST be capable of handling control frames in the middle of a fragmented message.",
      "ja": "Oエンドポイントは、断片化されたメッセージの途中で制御フレームを処理することができなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A sender MAY create fragments of any size for non-control messages.",
      "ja": "O送信者は、非制御メッセージのための任意のサイズの断片を作成することができます。"
    },
    {
      "indent": 3,
      "text": "o Clients and servers MUST support receiving both fragmented and unfragmented messages.",
      "ja": "Oクライアントとサーバーは両方の断片化と断片化されていないメッセージを受信して​​サポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "o As control frames cannot be fragmented, an intermediary MUST NOT attempt to change the fragmentation of a control frame.",
      "ja": "制御フレームが断片化することができないようにO、仲介者は、制御フレームのフラグメンテーションを変更しようとしてはいけません。"
    },
    {
      "indent": 3,
      "text": "o An intermediary MUST NOT change the fragmentation of a message if any reserved bit values are used and the meaning of these values is not known to the intermediary.",
      "ja": "任意の予約ビットの値が使用され、これらの値の意味は、中間に知られていない場合はO仲介は、メッセージの断片化を変更しないでください。"
    },
    {
      "indent": 3,
      "text": "o An intermediary MUST NOT change the fragmentation of any message in the context of a connection where extensions have been negotiated and the intermediary is not aware of the semantics of the negotiated extensions. Similarly, an intermediary that didn't see the WebSocket handshake (and wasn't notified about its content) that resulted in a WebSocket connection MUST NOT change the fragmentation of any message of such connection.",
      "ja": "O仲介は、拡張子が交渉されているとの仲介が交渉の拡張子の意味を認識していない接続のコンテキストで任意のメッセージの断片化を変更しないでください。同様に、WebSocketの接続が生じたのWebSocketハンドシェイクを見ていない（とその内容について通知されませんでした）仲介者は、そのような接続のいずれかのメッセージの断片化を変更しないでください。"
    },
    {
      "indent": 3,
      "text": "o As a consequence of these rules, all fragments of a message are of the same type, as set by the first fragment's opcode. Since control frames cannot be fragmented, the type for all fragments in a message MUST be either text, binary, or one of the reserved opcodes.",
      "ja": "これらのルールの結果としてO、メッセージのすべてのフラグメントが最初のフラグメントのオペコードによって設定され、同じタイプのものです。制御フレームが断片化することができないので、メッセージ内のすべての断片の型のいずれかのテキスト、バイナリ、または予約オペコードのいずれかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "NOTE: If control frames could not be interjected, the latency of a ping, for example, would be very long if behind a large message. Hence, the requirement of handling control frames in the middle of a fragmented message.",
      "ja": "注：制御フレームがinterjectedすることができなかった場合は、大きなメッセージの背後にある場合は、pingの待ち時間は、例えば、非常に長くなります。従って、断片化されたメッセージの途中で制御フレームを処理する要件。"
    },
    {
      "indent": 3,
      "text": "IMPLEMENTATION NOTE: In the absence of any extension, a receiver doesn't have to buffer the whole frame in order to process it. For example, if a streaming API is used, a part of a frame can be delivered to the application. However, note that this assumption might not hold true for all future WebSocket extensions.",
      "ja": "実装注：任意の拡張子が存在しない場合、受信機は、それを処理するためにフレーム全体をバッファリングする必要はありません。ストリーミングAPIを使用する場合、例えば、フレームの一部は、アプリケーションに送達することができます。しかし、この仮定は、将来のすべてのWebSocketの拡張のために当てはまらない場合がありますので注意してください。"
    },
    {
      "indent": 0,
      "text": "5.5. Control Frames",
      "section_title": true,
      "ja": "5.5. 制御フレーム"
    },
    {
      "indent": 3,
      "text": "Control frames are identified by opcodes where the most significant bit of the opcode is 1. Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong). Opcodes 0xB-0xF are reserved for further control frames yet to be defined.",
      "ja": "制御フレームは、オペコードの最上位ビットが制御フレーム1.現在定義されたオペコードは、0x8という（閉じる）、0x9（PING）、及び0xAが（ポン）を含んでオペコードによって識別されます。オペコード0xB-0xFのは、まだ定義される別の制御フレーム用に予約されています。"
    },
    {
      "indent": 3,
      "text": "Control frames are used to communicate state about the WebSocket. Control frames can be interjected in the middle of a fragmented message.",
      "ja": "制御フレームは、のWebSocketに関する状態を通信するために使用されます。制御フレームが断片化されたメッセージの途中でinterjectedすることができます。"
    },
    {
      "indent": 3,
      "text": "All control frames MUST have a payload length of 125 bytes or less and MUST NOT be fragmented.",
      "ja": "すべての制御フレームは、125バイト以下のペイロードの長さを有していなければならず、断片化してはいけません。"
    },
    {
      "indent": 0,
      "text": "5.5.1. Close",
      "section_title": true,
      "ja": "5.5.1. 閉じる"
    },
    {
      "indent": 3,
      "text": "The Close frame contains an opcode of 0x8.",
      "ja": "閉じるフレームは、0x8というのオペコードが含まれています。"
    },
    {
      "indent": 3,
      "text": "The Close frame MAY contain a body (the \"Application data\" portion of the frame) that indicates a reason for closing, such as an endpoint shutting down, an endpoint having received a frame too large, or an endpoint having received a frame that does not conform to the format expected by the endpoint. If there is a body, the first two bytes of the body MUST be a 2-byte unsigned integer (in network byte order) representing a status code with value /code/ defined in Section 7.4. Following the 2-byte integer, the body MAY contain UTF-8-encoded data with value /reason/, the interpretation of which is not defined by this specification. This data is not necessarily human readable but may be useful for debugging or passing information relevant to the script that opened the connection. As the data is not guaranteed to be human readable, clients MUST NOT show it to end users.",
      "ja": "閉じるフレームは、停止エンドポイント、大きすぎるフレームを受信したエンドポイント、又はないフレームを受信したエンドポイントとして、閉鎖の理由を示し、本体（フレームの「アプリケーションデータ」部分）を含んでいてもよいですエンドポイントによって期待される形式に準拠していません。体が存在する場合、体の最初の2つのバイトは、セクション7.4で定義された値/コード/とステータスコードを表す（ネットワークバイト順）2バイトの符号なし整数でなければなりません。 2バイトの整数以下、本体値/理由がUTF-8でエンコードされたデータを含むことができる/、の解釈はこの仕様で定義されていません。このデータは必ずしも読みやすい人間ではなく、デバッグまたは接続を開いたスクリプトに関連する情報を渡すために有用である可能性があります。データが読める人間であることが保証されていないため、クライアントはエンドユーザーにそれを示してはなりません。"
    },
    {
      "indent": 3,
      "text": "Close frames sent from client to server must be masked as per Section 5.3.",
      "ja": "クライアントからサーバーに送信閉じるフレームは、5.3節ごとにマスクする必要があります。"
    },
    {
      "indent": 3,
      "text": "The application MUST NOT send any more data frames after sending a Close frame.",
      "ja": "アプリケーションが閉じるフレームを送信した後に、それ以上のデータフレームを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives a Close frame and did not previously send a Close frame, the endpoint MUST send a Close frame in response. (When sending a Close frame in response, the endpoint typically echos the status code it received.) It SHOULD do so as soon as practical. An endpoint MAY delay sending a Close frame until its current message is sent (for instance, if the majority of a fragmented message is already sent, an endpoint MAY send the remaining fragments before sending a Close frame). However, there is no guarantee that the endpoint that has already sent a Close frame will continue to process data.",
      "ja": "エンドポイントがクローズフレームを受信して​​、以前に閉じるフレームを送信しなかった場合、エンドポイントは応答して閉じるフレームを送らなければなりません。 （レスポンス閉じるフレームを送信する場合、エンドポイントは、通常、それが受信したステータスコードをエコー表示。）これは、実用的なように、すぐに行う必要があります。エンドポイントは、現在のメッセージが送信されるまで（断片化メッセージの大部分が既に送信された場合、例えば、エンドポイントが閉じるフレームを送信する前に残りのフラグメントを送ることができる）を閉じるフレームの送信を遅延させることができます。しかし、すでにクローズフレームを送信したエンドポイントがデータを処理し続けるという保証はありません。"
    },
    {
      "indent": 3,
      "text": "After both sending and receiving a Close message, an endpoint considers the WebSocket connection closed and MUST close the underlying TCP connection. The server MUST close the underlying TCP connection immediately; the client SHOULD wait for the server to close the connection but MAY close the connection at any time after sending and receiving a Close message, e.g., if it has not received a TCP Close from the server in a reasonable time period.",
      "ja": "両方の送信と閉じるメッセージを受信した後、エンドポイントは閉じ用WebSocketの接続を考慮し、基礎となるTCP接続を閉じる必要があります。サーバーは、直下TCPコネクションを閉じる必要があります。クライアントが接続を閉じるには、サーバーのを待つ必要がありますが、それが合理的な期間内にサーバからTCPクローズを受信して​​いない場合、例えば、送信して閉じるメッセージを受け取った後、いつでも接続を終えるかもしれません。"
    },
    {
      "indent": 3,
      "text": "If a client and server both send a Close message at the same time, both endpoints will have sent and received a Close message and should consider the WebSocket connection closed and close the underlying TCP connection.",
      "ja": "クライアントとサーバーの両方が同時に閉じるメッセージを送信する場合は、両方のエンドポイントが送信され、クローズメッセージを受信し、閉じた状態のWebSocket接続を考慮し、基本的なTCP接続を閉じる必要がありますしています。"
    },
    {
      "indent": 0,
      "text": "5.5.2. Ping",
      "section_title": true,
      "ja": "5.5.2.  Pingの"
    },
    {
      "indent": 3,
      "text": "The Ping frame contains an opcode of 0x9.",
      "ja": "Pingフレームは、0x9のオペコードが含まれています。"
    },
    {
      "indent": 3,
      "text": "A Ping frame MAY include \"Application data\".",
      "ja": "Pingフレームは、「アプリケーションデータ」を含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in response, unless it already received a Close frame. It SHOULD respond with Pong frame as soon as is practical. Pong frames are discussed in Section 5.5.3.",
      "ja": "それはすでにクローズフレームを受信しない限り、Pingフレームを受信すると、エンドポイントは、応答でポンフレームを送らなければなりません。これは実用的であるとすぐにポンフレームで応答する必要があります。ポン・フレームは、セクション5.5.3で説明されています。"
    },
    {
      "indent": 3,
      "text": "An endpoint MAY send a Ping frame any time after the connection is established and before the connection is closed.",
      "ja": "接続が確立された後、接続が閉じられる前に、エンドポイントは、Pingフレームをいつでも送るかもしれません。"
    },
    {
      "indent": 3,
      "text": "NOTE: A Ping frame may serve either as a keepalive or as a means to verify that the remote endpoint is still responsive.",
      "ja": "注：Pingフレームがキープアライブとして、またはリモートエンドポイントがまだ応答性であることを確認するための手段としてのいずれかで機能することができます。"
    },
    {
      "indent": 0,
      "text": "5.5.3. Pong",
      "section_title": true,
      "ja": "5.5.3. ポン"
    },
    {
      "indent": 3,
      "text": "The Pong frame contains an opcode of 0xA.",
      "ja": "ポンフレームは0xAがのオペコードが含まれています。"
    },
    {
      "indent": 3,
      "text": "Section 5.5.2 details requirements that apply to both Ping and Pong frames.",
      "ja": "5.5.2詳細の両方のPingとPongのフレームに適用される要件。"
    },
    {
      "indent": 3,
      "text": "A Pong frame sent in response to a Ping frame must have identical \"Application data\" as found in the message body of the Ping frame being replied to.",
      "ja": "へ返信されるPingフレームのメッセージ本文に見られるようPingフレームに応答して送信されたポンフレームは、同一の「アプリケーションデータ」を有していなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives a Ping frame and has not yet sent Pong frame(s) in response to previous Ping frame(s), the endpoint MAY elect to send a Pong frame for only the most recently processed Ping frame.",
      "ja": "エンドポイントは、Pingフレームを受信して​​、まだ以前のPingフレーム（複数可）に応じて、ポンフレーム（複数可）を送信していない場合、エンドポイントは、唯一の最も最近処理Pingフレームのためにポンフレームを送信するために選ぶことができます。"
    },
    {
      "indent": 3,
      "text": "A Pong frame MAY be sent unsolicited. This serves as a unidirectional heartbeat. A response to an unsolicited Pong frame is not expected.",
      "ja": "ポン・フレームは、迷惑送るかもしれません。これは一方向のハートビートとして機能します。迷惑ポンフレームに対する応答が期待されていません。"
    },
    {
      "indent": 0,
      "text": "5.6. Data Frames",
      "section_title": true,
      "ja": "5.6. データフレーム"
    },
    {
      "indent": 3,
      "text": "Data frames (e.g., non-control frames) are identified by opcodes where the most significant bit of the opcode is 0. Currently defined opcodes for data frames include 0x1 (Text), 0x2 (Binary). Opcodes 0x3-0x7 are reserved for further non-control frames yet to be defined.",
      "ja": "データフレーム（例えば、非制御フレーム）はオペコードの最上位ビットは、データフレームのために0で現在定義されオペコードは、0x1の（テキスト）を0x2（バイナリ）が含まれている命令コードによって識別されます。さらに別の非制御フレームのために予約され0x3-0x7オペコードを定義します。"
    },
    {
      "indent": 3,
      "text": "Data frames carry application-layer and/or extension-layer data. The opcode determines the interpretation of the data:",
      "ja": "データフレームは、アプリケーション層及び/又は拡張層データを搬送します。オペコードは、データの解釈を決定します。"
    },
    {
      "indent": 3,
      "text": "Text",
      "ja": "テキスト"
    },
    {
      "indent": 6,
      "text": "The \"Payload data\" is text data encoded as UTF-8. Note that a particular text frame might include a partial UTF-8 sequence; however, the whole message MUST contain valid UTF-8. Invalid UTF-8 in reassembled messages is handled as described in Section 8.1.",
      "ja": "「ペイロードデータは、」UTF-8としてエンコードテキストデータです。特定のテキストフレームが部分的UTF-8配列を含む可能性があることに注意してください。しかし、全体のメッセージが有効なUTF-8を含まなければなりません。 8.1節で説明したように、無効なUTF-8再構築さメッセージには、処理されます。"
    },
    {
      "indent": 3,
      "text": "Binary",
      "ja": "バイナリ"
    },
    {
      "indent": 6,
      "text": "The \"Payload data\" is arbitrary binary data whose interpretation is solely up to the application layer.",
      "ja": "「ペイロードデータ」とは、その解釈は単にアプリケーション層までで任意のバイナリデータです。"
    },
    {
      "indent": 0,
      "text": "5.7. Examples",
      "section_title": true,
      "ja": "5.7. 例"
    },
    {
      "indent": 3,
      "text": "o A single-frame unmasked text message",
      "ja": "単一フレームマスクされていないテキスト・メッセージO"
    },
    {
      "indent": 6,
      "text": "* 0x81 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains \"Hello\")",
      "ja": "* 0x81と0x05を0x48 0x65 0x6c 0x6c 0x6f（ \"こんにちは\" が含まれます）"
    },
    {
      "indent": 3,
      "text": "o A single-frame masked text message",
      "ja": "O単一フレームマスキングされたテキストメッセージ"
    },
    {
      "indent": 6,
      "text": "* 0x81 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains \"Hello\")",
      "ja": "* 0x81と0x85 0x37は0xfa 0x21で0x3dから0x7f 0x9f 0x4d 0x51 0x58（ \"こんにちは\" が含まれます）"
    },
    {
      "indent": 3,
      "text": "o A fragmented unmasked text message",
      "ja": "断片化されたマスクされていないテキストメッセージO"
    },
    {
      "indent": 6,
      "text": "* 0x01 0x03 0x48 0x65 0x6c (contains \"Hel\")",
      "ja": "* 0x01の0x03の0x48 0x65 0x6c（ \"ヘル\" が含まれています）"
    },
    {
      "indent": 6,
      "text": "* 0x80 0x02 0x6c 0x6f (contains \"lo\")",
      "ja": "* 0x80と0x02の0x6c 0x6f（ \"LO\" が含まれます）"
    },
    {
      "indent": 3,
      "text": "o Unmasked Ping request and masked Ping response",
      "ja": "OマスクされていないPing要求とマスクされたpingの応答"
    },
    {
      "indent": 6,
      "text": "* 0x89 0x05 0x48 0x65 0x6c 0x6c 0x6f (contains a body of \"Hello\", but the contents of the body are arbitrary)",
      "ja": "* 0x89 0x05を0x48 0x65 0x6c 0x6c 0x6f（「こんにちは」のボディが含まれていますが、体の内容は任意です）"
    },
    {
      "indent": 6,
      "text": "* 0x8a 0x85 0x37 0xfa 0x21 0x3d 0x7f 0x9f 0x4d 0x51 0x58 (contains a body of \"Hello\", matching the body of the ping)",
      "ja": "* 0x8a 0x85 0x37は0xfa 0x21で0x3dから0x7f 0x9f 0x4d 0x51 0x58（ピングのボディにマッチする、 \"こんにちは\" の本体が含まれています）"
    },
    {
      "indent": 3,
      "text": "o 256 bytes binary message in a single unmasked frame",
      "ja": "単一のマスクされていないフレーム内の256バイトのバイナリメッセージをO"
    },
    {
      "indent": 6,
      "text": "* 0x82 0x7E 0x0100 [256 bytes of binary data]",
      "ja": "* 0x82と0x7Eには0x0100 [バイナリデータの256のバイト]"
    },
    {
      "indent": 3,
      "text": "o 64KiB binary message in a single unmasked frame",
      "ja": "単一のマスクされていないフレーム中のOの64KiBバイナリメッセージ"
    },
    {
      "indent": 6,
      "text": "* 0x82 0x7F 0x0000000000010000 [65536 bytes of binary data]",
      "ja": "* 0x82と0x7Fの0x0000000000010000 [バイナリデータの65536のバイト]"
    },
    {
      "indent": 0,
      "text": "5.8. Extensibility",
      "section_title": true,
      "ja": "5.8. 拡張性"
    },
    {
      "indent": 3,
      "text": "The protocol is designed to allow for extensions, which will add capabilities to the base protocol. The endpoints of a connection MUST negotiate the use of any extensions during the opening handshake. This specification provides opcodes 0x3 through 0x7 and 0xB through 0xF, the \"Extension data\" field, and the frame-rsv1, frame-rsv2, and frame-rsv3 bits of the frame header for use by extensions. The negotiation of extensions is discussed in further detail in Section 9.1. Below are some anticipated uses of extensions. This list is neither complete nor prescriptive.",
      "ja": "プロトコルは、基本プロトコルに機能を追加する拡張機能、を可能にするように設計されています。接続のエンドポイントは、オープニングハンドシェイク中に任意の拡張子の使用を交渉しなければなりません。この仕様は、0xFのを通して0x7の及び0xBを通じて「拡張データ」フィールド、およびフレームRSV1、フレームRSV2、および拡張による使用のためにフレームヘッダのフレームRSV3ビットオペコードの0x3のを提供します。拡張の交渉は、セクション9.1でさらに詳細に議論されます。以下は、機能拡張の一部予想される用途はあります。このリストは完全でも規範的でもありません。"
    },
    {
      "indent": 3,
      "text": "o \"Extension data\" may be placed in the \"Payload data\" before the \"Application data\".",
      "ja": "O「拡張データ」は、「アプリケーションデータ」の前に「ペイロードデータ」に配置することができます。"
    },
    {
      "indent": 3,
      "text": "o Reserved bits can be allocated for per-frame needs.",
      "ja": "O予約ビットは、フレーム毎のニーズに割り当てることができます。"
    },
    {
      "indent": 3,
      "text": "o Reserved opcode values can be defined.",
      "ja": "O予約オペコード値を定義することができます。"
    },
    {
      "indent": 3,
      "text": "o Reserved bits can be allocated to the opcode field if more opcode values are needed.",
      "ja": "よりオペコード値が必要な場合、O予約ビットopcodeフィールドに割り当てることができます。"
    },
    {
      "indent": 3,
      "text": "o A reserved bit or an \"extension\" opcode can be defined that allocates additional bits out of the \"Payload data\" to define larger opcodes or more per-frame bits.",
      "ja": "O予約ビットまたは「拡張」オペコードが「ペイロードデータ」のうち、付加ビットを割り当て、より大きなオペコード以上のフレーム毎のビットを定義するように定義することができます。"
    },
    {
      "indent": 0,
      "text": "6. Sending and Receiving Data",
      "section_title": true,
      "ja": "6.データの送受信"
    },
    {
      "indent": 0,
      "text": "6.1. Sending Data",
      "section_title": true,
      "ja": "6.1. データの送信"
    },
    {
      "indent": 3,
      "text": "To _Send a WebSocket Message_ comprising of /data/ over a WebSocket connection, an endpoint MUST perform the following steps.",
      "ja": "データ/を含むのWebSocketメッセージ_を_Sendする/のWebSocket接続を介して、エンドポイントは、以下のステップを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. The endpoint MUST ensure the WebSocket connection is in the OPEN state (cf. Sections 4.1 and 4.2.2.) If at any point the state of the WebSocket connection changes, the endpoint MUST abort the following steps.",
      "ja": "任意の時点でのWebSocket接続の状態が変化するが、エンドポイントは、以下の手順を中止する必要がある場合1のWebSocket接続を確保しなければならないエンドポイントは、（参照セクション4.1及び4.2.2。）開状態です。"
    },
    {
      "indent": 3,
      "text": "2. An endpoint MUST encapsulate the /data/ in a WebSocket frame as defined in Section 5.2. If the data to be sent is large or if the data is not available in its entirety at the point the endpoint wishes to begin sending the data, the endpoint MAY alternately encapsulate the data in a series of frames as defined in Section 5.4.",
      "ja": "セクション5.2で定義されるように前記エンドポイントはWebSocketのフレーム内/ /データをカプセル化しなければなりません。データを送信する場合は大きい場合や、データがエンドポイントがデータの送信を開始したい時点でその全体が使用できない場合は、セクション5.4で定義されるように、エンドポイントは、交互に一連のフレーム内のデータをカプセル化することができます。"
    },
    {
      "indent": 3,
      "text": "3. The opcode (frame-opcode) of the first frame containing the data MUST be set to the appropriate value from Section 5.2 for data that is to be interpreted by the recipient as text or binary data.",
      "ja": "3.データを含む最初のフレームのオペコード（フレームオペコード）がテキストまたはバイナリデータとして受信者によって解釈されるデータについては、セクション5.2からの適切な値に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. The FIN bit (frame-fin) of the last frame containing the data MUST be set to 1 as defined in Section 5.2.",
      "ja": "セクション5.2で定義されるように前記データを含む最後のフレームのFINビット（フレームフィン）を1に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "5. If the data is being sent by the client, the frame(s) MUST be masked as defined in Section 5.3.",
      "ja": "5.データがクライアントによって送信されている場合、セクション5.3で定義されるように、フレーム（複数可）がマスクされなければなりません。"
    },
    {
      "indent": 3,
      "text": "6. If any extensions (Section 9) have been negotiated for the WebSocket connection, additional considerations may apply as per the definition of those extensions.",
      "ja": "任意の拡張子（第9節）はWebSocketの接続のために交渉されている6.場合は、追加の考慮事項は、これらの拡張子の定義に従って適用される場合があります。"
    },
    {
      "indent": 3,
      "text": "7. The frame(s) that have been formed MUST be transmitted over the underlying network connection.",
      "ja": "7.形成されたフレーム（複数可）は、基礎となるネットワーク接続を介して送信されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2. Receiving Data",
      "section_title": true,
      "ja": "6.2. データ受信中"
    },
    {
      "indent": 3,
      "text": "To receive WebSocket data, an endpoint listens on the underlying network connection. Incoming data MUST be parsed as WebSocket frames as defined in Section 5.2. If a control frame (Section 5.5) is received, the frame MUST be handled as defined by Section 5.5. Upon receiving a data frame (Section 5.6), the endpoint MUST note the /type/ of the data as defined by the opcode (frame-opcode) from Section 5.2. The \"Application data\" from this frame is defined as the /data/ of the message. If the frame comprises an unfragmented message (Section 5.4), it is said that _A WebSocket Message Has Been Received_ with type /type/ and data /data/. If the frame is part of a fragmented message, the \"Application data\" of the subsequent data frames is concatenated to form the /data/. When the last fragment is received as indicated by the FIN bit (frame-fin), it is said that _A WebSocket Message Has Been Received_ with data /data/ (comprised of the concatenation of the \"Application data\" of the fragments) and type /type/ (noted from the first frame of the fragmented message). Subsequent data frames MUST be interpreted as belonging to a new WebSocket message.",
      "ja": "WebSocketのデータを受信するには、エンドポイントは、基礎となるネットワーク接続をリッスンします。セクション5.2で定義されるように、入ってくるデータは、WebSocketのフレームとして解析されなければなりません。制御フレーム（第5.5節）を受信した場合、セクション5.5で定義されているように、フレームが処理されなければなりません。セクション5.2からのオペコード（フレームオペコード）によって定義されたデータ・フレーム（5.6節）を受信すると、エンドポイントは、データの/タイプ/に注意しなければなりません。このフレームから、「アプリケーションデータ」は、メッセージの/データ/として定義されます。フレームが断片化されていないメッセージ（セクション5.4）を含む場合、_AのWebSocketメッセージタイプ/タイプ/データ/データ/でReceived_されていると言われています。フレームが断片化されたメッセージの一部である場合、後続のデータ・フレームの「アプリケーションデータ」/データ/を形成するために連結されています。 FINビット（フレーム・フィン）によって示されるように、最後のフラグメントが受信されると、_AのWebSocketメッセージデータ/データとReceived_ /（フラグメントの「アプリケーションデータ」の連結からなる）とタイプされていると言われています（断片化されたメッセージの最初のフレームから注目）/タイプ/。後続のデータフレームは、新規のWebSocketメッセージに属するものとして解釈されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Extensions (Section 9) MAY change the semantics of how data is read, specifically including what comprises a message boundary. Extensions, in addition to adding \"Extension data\" before the \"Application data\" in a payload, MAY also modify the \"Application data\" (such as by compressing it).",
      "ja": "拡張機能（第9節）は、特にメッセージの境界を備えるものを含めて、データが読み込まれるかのセマンティクスを変更することがあります。拡張機能は、ペイロード内の「アプリケーションデータ」の前に「拡張データ」を追加することに加えて、（例えば、それを圧縮することによって）「アプリケーションデータ」を変更することができます。"
    },
    {
      "indent": 3,
      "text": "A server MUST remove masking for data frames received from a client as described in Section 5.3.",
      "ja": "サーバは、セクション5.3で説明したように、クライアントから受信したデータフレームに対するマスキング除去しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Closing the Connection",
      "section_title": true,
      "ja": "7.接続を閉じます"
    },
    {
      "indent": 0,
      "text": "7.1. Definitions",
      "section_title": true,
      "ja": "7.1. 定義"
    },
    {
      "indent": 0,
      "text": "7.1.1. Close the WebSocket Connection",
      "section_title": true,
      "ja": "7.1.1.  WebSocketの接続を閉じます"
    },
    {
      "indent": 3,
      "text": "To _Close the WebSocket Connection_, an endpoint closes the underlying TCP connection. An endpoint SHOULD use a method that cleanly closes the TCP connection, as well as the TLS session, if applicable, discarding any trailing bytes that may have been received. An endpoint MAY close the connection via any means available when necessary, such as when under attack.",
      "ja": "WebSocketをConnection_を_closeするために、エンドポイントは、基礎となるTCP接続を終了します。該当する場合、エンドポイントが受信された可能性のある後続のバイトを破棄し、きれいにTCP接続をクローズする方法、ならびにTLSセッションを使用すべきです。エンドポイントは、このような時に攻撃を受けて、必要に応じて利用可能な任意の手段を経由して接続を閉じます。"
    },
    {
      "indent": 3,
      "text": "The underlying TCP connection, in most normal cases, SHOULD be closed first by the server, so that it holds the TIME_WAIT state and not the client (as this would prevent it from re-opening the connection for 2 maximum segment lifetimes (2MSL), while there is no corresponding server impact as a TIME_WAIT connection is immediately reopened upon a new SYN with a higher seq number). In abnormal cases (such as not having received a TCP Close from the server after a reasonable amount of time) a client MAY initiate the TCP Close. As such, when a server is instructed to _Close the WebSocket Connection_ it SHOULD initiate a TCP Close immediately, and when a client is instructed to do the same, it SHOULD wait for a TCP Close from the server.",
      "ja": "これは2つの最大セグメント寿命（2MSL）のための接続を再度開くことを妨げるように、それは（TIME_WAIT状態としないクライアントを保持するように、基礎となるTCP接続は、ほとんどの正常な場合には、、、サーバによって最初に閉じられるべきですTIME_WAIT接続が直ちにより高い配列番号を有する新しいSYN際に再び開かれるように該当するサーバへの影響）が存在しませんでした。 （例えば、妥当な時間後にサーバから閉じるTCPを受信しないように）異常なケースでは、クライアントは、TCPクローズを開始することができます。サーバーはWebSocketをConnection_を_closeするように指示されたときにこのように、それはすぐにTCPクローズを開始すべきである、とクライアントが同じことを行うように指示された場合、それはサーバーから閉じるTCPを待つべき。"
    },
    {
      "indent": 3,
      "text": "As an example of how to obtain a clean closure in C using Berkeley sockets, one would call shutdown() with SHUT_WR on the socket, call recv() until obtaining a return value of 0 indicating that the peer has also performed an orderly shutdown, and finally call close() on the socket.",
      "ja": "バークレーソケットを使用してCで清浄な閉鎖を取得する方法の一例として、一つのソケットにSHUT_WRとシャットダウン（）を呼び出すことになる、ピアはまた、正常なシャットダウンを実行したことを示す0の戻り値を得るまで（）RECVを呼び出し、そして最終的にはソケットのクローズ（）を呼び出します。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Start the WebSocket Closing Handshake",
      "section_title": true,
      "ja": "7.1.2. ハンドシェイクを閉じるのWebSocketを開始"
    },
    {
      "indent": 3,
      "text": "To _Start the WebSocket Closing Handshake_ with a status code (Section 7.4) /code/ and an optional close reason (Section 7.1.6) /reason/, an endpoint MUST send a Close control frame, as described in Section 5.5.1, whose status code is set to /code/ and whose close reason is set to /reason/. Once an endpoint has both sent and received a Close control frame, that endpoint SHOULD _Close the WebSocket Connection_ as defined in Section 7.1.1.",
      "ja": "そのセクション5.5.1に記載のステータスコード（セクション7.4）/コード/及び任意近い理由（セクション7.1.6）/理由/とHandshake_を閉じるのWebSocketを_startするために、エンドポイントは、クローズ制御フレームを送信しなければなりませんステータスコードは/コード/及びその近く理由/理由/に設定されているに設定されています。エンドポイントが送信して閉じる制御フレームを受信した後、両方のセクション7.1.1で定義されるように、そのエンドポイントは、のWebSocket Connection_を_closeべきです。"
    },
    {
      "indent": 0,
      "text": "7.1.3. The WebSocket Closing Handshake is Started",
      "section_title": true,
      "ja": "7.1.3. ハンドシェイクを閉じるのWebSocketが開始され"
    },
    {
      "indent": 3,
      "text": "Upon either sending or receiving a Close control frame, it is said that _The WebSocket Closing Handshake is Started_ and that the WebSocket connection is in the CLOSING state.",
      "ja": "閉じる制御フレームを送信または受信のいずれかの際に、_TheのWebSocketは、ハンドシェイクを閉じることStarted_とのWebSocket接続が閉状態にあることと言われています。"
    },
    {
      "indent": 0,
      "text": "7.1.4. The WebSocket Connection is Closed",
      "section_title": true,
      "ja": "7.1.4.  WebSocketの接続は閉じられ"
    },
    {
      "indent": 3,
      "text": "When the underlying TCP connection is closed, it is said that _The WebSocket Connection is Closed_ and that the WebSocket connection is in the CLOSED state. If the TCP connection was closed after the WebSocket closing handshake was completed, the WebSocket connection is said to have been closed _cleanly_.",
      "ja": "基礎となるTCP接続が閉じているとき、_TheのWebSocket接続がWebSocketの接続がCLOSED状態にあることをClosed_であると言われています。 WebSocketを閉鎖ハンドシェイクが完了した後にTCP接続がクローズされた場合は、WebSocketの接続が閉じられた_cleanly_ていたと言われています。"
    },
    {
      "indent": 3,
      "text": "If the WebSocket connection could not be established, it is also said that _The WebSocket Connection is Closed_, but not _cleanly_.",
      "ja": "WebSocketの接続が確立できなかった場合、また、_TheのWebSocketコネクションがClosed_ですが、_cleanly_ないと言われています。"
    },
    {
      "indent": 0,
      "text": "7.1.5. The WebSocket Connection Close Code",
      "section_title": true,
      "ja": "7.1.5.  WebSocketの接続を閉じるコード"
    },
    {
      "indent": 3,
      "text": "As defined in Sections 5.5.1 and 7.4, a Close control frame may contain a status code indicating a reason for closure. A closing of the WebSocket connection may be initiated by either endpoint, potentially simultaneously. _The WebSocket Connection Close Code_ is defined as the status code (Section 7.4) contained in the first Close control frame received by the application implementing this protocol. If this Close control frame contains no status code, _The WebSocket Connection Close Code_ is considered to be 1005. If _The WebSocket Connection is Closed_ and no Close control frame was received by the endpoint (such as could occur if the underlying transport connection is lost), _The WebSocket Connection Close Code_ is considered to be 1006.",
      "ja": "セクション5.5.1及び7.4で定義されているように、閉じる制御フレームは、閉鎖の理由を示すステータスコードを含んでいてもよいです。 WebSocketの接続の閉鎖は、潜在的に同時に、いずれかのエンドポイントによって開始されてもよいです。 _TheのWebSocket接続閉じるCode_は、このプロトコルを実装するアプリケーションによって受信された第1の閉じた制御フレームに含まれるステータスコード（セクション7.4）のように定義されます。この閉じる制御フレームがない状態コードが含まれていない場合、_TheのWebSocket接続閉じるCode_は_TheのWebSocket接続がClosed_と全く閉じる制御フレームが（例えば、基礎となるトランスポート接続が失われた場合に起こり得るように）エンドポイントによって受信されなかった場合は1005であると考えられています、_TheのWebSocketコネクションを閉じるCode_は1006年であると考えられています。"
    },
    {
      "indent": 3,
      "text": "NOTE: Two endpoints may not agree on the value of _The WebSocket Connection Close Code_. As an example, if the remote endpoint sent a Close frame but the local application has not yet read the data containing the Close frame from its socket's receive buffer, and the local application independently decided to close the connection and send a Close frame, both endpoints will have sent and received a",
      "ja": "注：2つのエンドポイントは、_The用WebSocket接続を閉じるCode_の値に一致しない場合があります。例として、リモートエンドポイント閉じるフレームを送信したが、まだ受信バッファ、およびローカルアプリケーションソケット年代から閉じるフレームを含むデータの読み出していないローカルアプリケーションは、独立して、両方のエンドポイントの接続を閉じ、閉じたフレームを送信することを決定しました送信され、受信しています"
    },
    {
      "indent": 3,
      "text": "Close frame and will not send further Close frames. Each endpoint will see the status code sent by the other end as _The WebSocket Connection Close Code_. As such, it is possible that the two endpoints may not agree on the value of _The WebSocket Connection Close Code_ in the case that both endpoints _Start the WebSocket Closing Handshake_ independently and at roughly the same time.",
      "ja": "クローズフレームとさらに密接なフレームを送信しません。各エンドポイントは、_TheのWebSocketコネクションを閉じるCode_としてもう一方の端によって送信されたステータスコードが表示されます。このように、2つのエンドポイントは、WebSocketの_Start両方のエンドポイントが独立してほぼ同時にHandshake_を閉じる場合に_The用WebSocket接続を閉じるCode_の値に一致しない可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.1.6. The WebSocket Connection Close Reason",
      "section_title": true,
      "ja": "7.1.6.  WebSocketの接続を閉じる理由"
    },
    {
      "indent": 3,
      "text": "As defined in Sections 5.5.1 and 7.4, a Close control frame may contain a status code indicating a reason for closure, followed by UTF-8-encoded data, the interpretation of said data being left to the endpoints and not defined by this protocol. A closing of the WebSocket connection may be initiated by either endpoint, potentially simultaneously. _The WebSocket Connection Close Reason_ is defined as the UTF-8-encoded data following the status code (Section 7.4) contained in the first Close control frame received by the application implementing this protocol. If there is no such data in the Close control frame, _The WebSocket Connection Close Reason_ is the empty string.",
      "ja": "セクション5.5.1及び7.4で定義されているように、閉じる制御フレームはUTF-8でエンコードされたデータに続いて閉鎖理由を示すステータスコードを含んでいてもよい、の解釈は、データがエンドポイントに左と、このプロトコルによって定義されていないであることを特徴と。 WebSocketの接続の閉鎖は、潜在的に同時に、いずれかのエンドポイントによって開始されてもよいです。 _TheのWebSocket接続閉じるReason_は、このプロトコルを実装するアプリケーションによって受信された第1の閉じた制御フレームに含まれるステータスコード（セクション7.4）以下のUTF-8でエンコードされたデータとして定義されます。閉じる制御フレームには、そのようなデータが存在しない場合は、_TheのWebSocket接続を閉じるReason_は空の文字列です。"
    },
    {
      "indent": 3,
      "text": "NOTE: Following the same logic as noted in Section 7.1.5, two endpoints may not agree on _The WebSocket Connection Close Reason_.",
      "ja": "注：同じロジック次のセクション7.1.5で述べたように、2つのエンドポイントは、_TheのWebSocket接続を閉じるReason_に同意しない場合があります。"
    },
    {
      "indent": 0,
      "text": "7.1.7. Fail the WebSocket Connection",
      "section_title": true,
      "ja": "7.1.7.  WebSocketの接続の失敗"
    },
    {
      "indent": 3,
      "text": "Certain algorithms and specifications require an endpoint to _Fail the WebSocket Connection_. To do so, the client MUST _Close the WebSocket Connection_, and MAY report the problem to the user (which would be especially useful for developers) in an appropriate manner. Similarly, to do so, the server MUST _Close the WebSocket Connection_, and SHOULD log the problem.",
      "ja": "特定のアルゴリズムと仕様はWebSocketをConnection_を_Failするエンドポイントが必要です。そのためには、クライアントは、WebSocketをConnection_を_closeしなければならないし、適切な方法で（開発者にとって特に有用であろう）、ユーザーに問題を報告することがあります。同様に、そうするために、サーバーはWebSocketをConnection_を_closeしなければならない、と問題をログインする必要があります。"
    },
    {
      "indent": 3,
      "text": "If _The WebSocket Connection is Established_ prior to the point where the endpoint is required to _Fail the WebSocket Connection_, the endpoint SHOULD send a Close frame with an appropriate status code (Section 7.4) before proceeding to _Close the WebSocket Connection_. An endpoint MAY omit sending a Close frame if it believes the other side is unlikely to be able to receive and process the Close frame, due to the nature of the error that led the WebSocket connection to fail in the first place. An endpoint MUST NOT continue to attempt to process data (including a responding Close frame) from the remote endpoint after being instructed to _Fail the WebSocket Connection_.",
      "ja": "_TheのWebSocket接続は、エンドポイントが用WebSocket Connection_を_Failする必要がある点に先立っEstablished_である場合、エンドポイントはのWebSocket Connection_を_closeに進む前に、適切なステータスコード（セクション7.4）との緊密なフレームを送信すべきです。エンドポイントは、それが他の側が最初の場所で失敗するのWebSocket接続を率いて、エラーの性質のために近くのフレームを受信して​​処理することができそうにないと考えている場合は閉じるフレームの送信を省略することができます。エンドポイントは、WebSocketをConnection_を_Failするように指示された後、リモートエンドポイントからの（応答閉じるフレームを含む）のデータを処理しようとし続けてはなりません。"
    },
    {
      "indent": 3,
      "text": "Except as indicated above or as specified by the application layer (e.g., a script using the WebSocket API), clients SHOULD NOT close the connection.",
      "ja": "上またはアプリケーション層（例えば、のWebSocketのAPIを使用してスクリプト）によって指定されるように示される場合を除き、クライアントが接続を閉じるべきではありません。"
    },
    {
      "indent": 0,
      "text": "7.2. Abnormal Closures",
      "section_title": true,
      "ja": "7.2. 異常なクロージャ"
    },
    {
      "indent": 0,
      "text": "7.2.1. Client-Initiated Closure",
      "section_title": true,
      "ja": "7.2.1. クライアントが開始クロージャー"
    },
    {
      "indent": 3,
      "text": "Certain algorithms, in particular during the opening handshake, require the client to _Fail the WebSocket Connection_. To do so, the client MUST _Fail the WebSocket Connection_ as defined in Section 7.1.7.",
      "ja": "特定のアルゴリズムは、オープニングハンドシェイク中に、特に、WebSocketをConnection_を_Failするクライアントを必要としています。 7.1.7項で定義されるようにこれを行うには、クライアントは、WebSocketをConnection_を_Failしなければなりません。"
    },
    {
      "indent": 3,
      "text": "If at any point the underlying transport layer connection is unexpectedly lost, the client MUST _Fail the WebSocket Connection_.",
      "ja": "任意の時点で基礎となるトランスポート層接続が予期せずに失われた場合、クライアントは、WebSocketをConnection_を_Failしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Except as indicated above or as specified by the application layer (e.g., a script using the WebSocket API), clients SHOULD NOT close the connection.",
      "ja": "上またはアプリケーション層（例えば、のWebSocketのAPIを使用してスクリプト）によって指定されるように示される場合を除き、クライアントが接続を閉じるべきではありません。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Server-Initiated Closure",
      "section_title": true,
      "ja": "7.2.2. サーバ起動閉鎖"
    },
    {
      "indent": 3,
      "text": "Certain algorithms require or recommend that the server _Abort the WebSocket Connection_ during the opening handshake. To do so, the server MUST simply _Close the WebSocket Connection_ (Section 7.1.1).",
      "ja": "特定のアルゴリズムが必要とするか、またはオープンハンドシェイク中のWebSocket Connection_ _abortサーバーことをお勧めします。そうするために、サーバは単にのWebSocket Connection_（セクション7.1.1）を_closeしなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.2.3. Recovering from Abnormal Closure",
      "section_title": true,
      "ja": "7.2.3. 異常な閉鎖からの回復"
    },
    {
      "indent": 3,
      "text": "Abnormal closures may be caused by any number of reasons. Such closures could be the result of a transient error, in which case reconnecting may lead to a good connection and a resumption of normal operations. Such closures may also be the result of a nontransient problem, in which case if each deployed client experiences an abnormal closure and immediately and persistently tries to reconnect, the server may experience what amounts to a denial-of-service attack by a large number of clients trying to reconnect. The end result of such a scenario could be that the service is unable to recover in a timely manner or recovery is made much more difficult.",
      "ja": "異常なクロージャは、理由の任意の数によって引き起こされ得ます。そのようなクロージャは、ケースの再接続は、良好な接続と通常動作の再開につながる可能性のある一時的なエラーの結果であり得ます。このようなクロージャは、各展開し、クライアントが異常な閉鎖を経験し、すぐに永続的に再接続しようとする場合、サーバは多数により、サービス拒否攻撃になるものを体験することがあり、その場合には一時的でない問題の結果である可能性がありますクライアントが再接続しようとしています。このようなシナリオの最終結果は、サービスをタイムリーに回復することができないか、回復がはるかに困難になることが考えられます。"
    },
    {
      "indent": 3,
      "text": "To prevent this, clients SHOULD use some form of backoff when trying to reconnect after abnormal closures as described in this section.",
      "ja": "このセクションで説明するように異常な閉鎖後に再接続しようとしたときにこれを防ぐために、クライアントがバックオフのいくつかのフォームを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "The first reconnect attempt SHOULD be delayed by a random amount of time. The parameters by which this random delay is chosen are left to the client to decide; a value chosen randomly between 0 and 5 seconds is a reasonable initial delay though clients MAY choose a different interval from which to select a delay length based on implementation experience and particular application.",
      "ja": "最初の再接続の試行は、ランダムな時間だけ遅延させるべきです。このランダム遅延が選択されることにより、パラメータが決定するために、クライアントに残されています。 0〜5秒の間でランダムに選択された値は、クライアントが実装経験、特定の用途に基づいて、遅延の長さを選択し、そこから異なる間隔を選択できるが、妥当な初期遅延です。"
    },
    {
      "indent": 3,
      "text": "Should the first reconnect attempt fail, subsequent reconnect attempts SHOULD be delayed by increasingly longer amounts of time, using a method such as truncated binary exponential backoff.",
      "ja": "最初の再接続の試みが失敗した場合、その後の再接続の試行は、切頭二進指数バックオフのような方法を用いて、時間のますます長い量だけ遅延されるべきです。"
    },
    {
      "indent": 0,
      "text": "7.3. Normal Closure of Connections",
      "section_title": true,
      "ja": "7.3. 接続の通常の閉鎖"
    },
    {
      "indent": 3,
      "text": "Servers MAY close the WebSocket connection whenever desired. Clients SHOULD NOT close the WebSocket connection arbitrarily. In either case, an endpoint initiates a closure by following the procedures to _Start the WebSocket Closing Handshake_ (Section 7.1.2).",
      "ja": "希望いつでもサーバーはWebSocketの接続を閉じます。クライアントは、任意のWebSocket接続をクローズすべきではありません。いずれの場合においても、エンドポイントはHandshake_（7.1.2項）を閉じるのWebSocketを_startする手順に従うことにより、閉鎖を開始します。"
    },
    {
      "indent": 0,
      "text": "7.4. Status Codes",
      "section_title": true,
      "ja": "7.4. ステータスコード"
    },
    {
      "indent": 3,
      "text": "When closing an established connection (e.g., when sending a Close frame, after the opening handshake has completed), an endpoint MAY indicate a reason for closure. The interpretation of this reason by an endpoint, and the action an endpoint should take given this reason, are left undefined by this specification. This specification defines a set of pre-defined status codes and specifies which ranges may be used by extensions, frameworks, and end applications. The status code and any associated textual message are optional components of a Close frame.",
      "ja": "確立された接続を閉じるときに（開口ハンドシェイクが完了した後、閉じるフレームを送信する場合など）、エンドポイントは、閉鎖の理由を示すことができます。エンドポイントによって、この理由の解釈、およびエンドポイントは、この理由を与えて取るべきアクションは、この仕様で未定義のままされています。この仕様は、事前定義されたステータスコードのセットを定義し、拡張機能、フレームワーク、およびエンドアプリケーションによって使用することができる範囲を指定します。ステータスコードおよび関連するテキストメッセージ閉じるフレームの任意成分です。"
    },
    {
      "indent": 0,
      "text": "7.4.1. Defined Status Codes",
      "section_title": true,
      "ja": "7.4.1. 定義されたステータスコード"
    },
    {
      "indent": 3,
      "text": "Endpoints MAY use the following pre-defined status codes when sending a Close frame.",
      "ja": "閉じるフレームを送信するときに、エンドポイントは、以下の事前定義されたステータスコードを使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "1000",
      "ja": "１０００"
    },
    {
      "indent": 6,
      "text": "1000 indicates a normal closure, meaning that the purpose for which the connection was established has been fulfilled.",
      "ja": "1000は、接続が確立された目的が満たされていることを意味し、通常の閉鎖を示します。"
    },
    {
      "indent": 3,
      "text": "1001",
      "ja": "１００１"
    },
    {
      "indent": 6,
      "text": "1001 indicates that an endpoint is \"going away\", such as a server going down or a browser having navigated away from a page.",
      "ja": "1001は、エンドポイントは、サーバーがダウンして行くか、ブラウザがそのページから去るナビゲートしたものとして、「離れていく」されていることを示しています。"
    },
    {
      "indent": 3,
      "text": "1002",
      "ja": "１００２"
    },
    {
      "indent": 6,
      "text": "1002 indicates that an endpoint is terminating the connection due to a protocol error.",
      "ja": "1002は、エンドポイントは、プロトコルエラーに起因する接続を終了していることを示します。"
    },
    {
      "indent": 3,
      "text": "1003",
      "ja": "１００３"
    },
    {
      "indent": 6,
      "text": "1003 indicates that an endpoint is terminating the connection because it has received a type of data it cannot accept (e.g., an endpoint that understands only text data MAY send this if it receives a binary message).",
      "ja": "1003は、それが受け入れることができないデータのタイプを受信して​​いるため、エンドポイントが接続を終了していることを示す（これはバイナリメッセージを受信した場合、例えば、テキストデータのみを理解し、エンドポイントはこれを送信してもよいです）。"
    },
    {
      "indent": 3,
      "text": "1004",
      "ja": "１００４"
    },
    {
      "indent": 6,
      "text": "Reserved. The specific meaning might be defined in the future.",
      "ja": "予約済み。具体的な意味は、将来的に定義される可能性があります。"
    },
    {
      "indent": 3,
      "text": "1005",
      "ja": "１００５"
    },
    {
      "indent": 6,
      "text": "1005 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that no status code was actually present.",
      "ja": "1005は予約値であり、エンドポイントによって閉じる制御フレームにステータスコードとして設定してはいけません。それは何のステータスコードは実際には存在しないことを示すステータスコードを期待するアプリケーションで使用するために指定されています。"
    },
    {
      "indent": 3,
      "text": "1006",
      "ja": "１００６"
    },
    {
      "indent": 6,
      "text": "1006 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that the connection was closed abnormally, e.g., without sending or receiving a Close control frame.",
      "ja": "1006は予約値であり、エンドポイントによって閉じる制御フレームにステータスコードとして設定してはいけません。これは、接続が閉じる制御フレームを送信または受信することなく、例えば、異常に閉じられたことを示すステータスコードを期待するアプリケーションで使用するために指定されています。"
    },
    {
      "indent": 3,
      "text": "1007",
      "ja": "１００７"
    },
    {
      "indent": 6,
      "text": "1007 indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [RFC3629] data within a text message).",
      "ja": "1007は、メッセージ（テキストメッセージ内の、例えば、非UTF-8 [RFC3629]データ）のタイプと一致しなかったメッセージ内のデータを受信したため、エンドポイントが接続を終了していることを示します。"
    },
    {
      "indent": 3,
      "text": "1008",
      "ja": "１００８"
    },
    {
      "indent": 6,
      "text": "1008 indicates that an endpoint is terminating the connection because it has received a message that violates its policy. This is a generic status code that can be returned when there is no other more suitable status code (e.g., 1003 or 1009) or if there is a need to hide specific details about the policy.",
      "ja": "1008は、そのポリシーに違反するメッセージを受信したため、エンドポイントが接続を終了していることを示します。これは、他のより適切なステータスコード（例えば、1003又は1009）がない場合、またはポリシーについての具体的な詳細を非表示にする必要がある場合に戻すことができる一般的なステータス・コードです。"
    },
    {
      "indent": 3,
      "text": "1009",
      "ja": "１００９"
    },
    {
      "indent": 6,
      "text": "1009 indicates that an endpoint is terminating the connection because it has received a message that is too big for it to process.",
      "ja": "1009は、それが処理するために大きすぎるメッセージを受信したため、エンドポイントが接続を終了していることを示します。"
    },
    {
      "indent": 3,
      "text": "1010",
      "ja": "１０１０"
    },
    {
      "indent": 6,
      "text": "1010 indicates that an endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, but the server didn't return them in the response message of the WebSocket handshake. The list of extensions that are needed SHOULD appear in the /reason/ part of the Close frame. Note that this status code is not used by the server, because it can fail the WebSocket handshake instead.",
      "ja": "1010年には、それは、サーバーが1つ以上の延長を交渉することが予想されたため、エンドポイント（クライアント）の接続を終了していますが、サーバーはWebSocketをハンドシェイクの応答メッセージでそれらを返さなかったことを示しています。必要とされている拡張機能の一覧は/理由/閉じるフレームの一部に表示されます。それは代わりのWebSocketハンドシェイクを失敗する可能性があるため、このステータスコードがサーバーによって使用されていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "1011",
      "ja": "１０１１"
    },
    {
      "indent": 6,
      "text": "1011 indicates that a server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.",
      "ja": "1011は、要求を満たすことを妨げる予期しない状態が発生したため、サーバーは接続を終了していることを示しています。"
    },
    {
      "indent": 3,
      "text": "1015",
      "ja": "１０１５"
    },
    {
      "indent": 6,
      "text": "1015 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified).",
      "ja": "1015は予約値であり、エンドポイントによって閉じる制御フレームにステータスコードとして設定してはいけません。これは、接続が原因TLSハンドシェイクを実行する失敗に閉鎖されたことを示すステータスコードを期待するアプリケーションに使用するために指定されている（例えば、サーバ証明書を検証することはできません）。"
    },
    {
      "indent": 0,
      "text": "7.4.2. Reserved Status Code Ranges",
      "section_title": true,
      "ja": "7.4.2. 予約ステータスコード範囲"
    },
    {
      "indent": 3,
      "text": "0-999",
      "ja": "０ー９９９"
    },
    {
      "indent": 6,
      "text": "Status codes in the range 0-999 are not used.",
      "ja": "範囲0〜999のステータスコードが使用されていません。"
    },
    {
      "indent": 3,
      "text": "1000-2999",
      "ja": "１０００ー２９９９"
    },
    {
      "indent": 6,
      "text": "Status codes in the range 1000-2999 are reserved for definition by this protocol, its future revisions, and extensions specified in a permanent and readily available public specification.",
      "ja": "範囲1000-2999でのステータスコードは、このプロトコル、その将来の改訂、および恒久的かつ容易に入手可能な公開された仕様で指定された拡張子で定義のために予約されています。"
    },
    {
      "indent": 3,
      "text": "3000-3999",
      "ja": "３０００ー３９９９"
    },
    {
      "indent": 6,
      "text": "Status codes in the range 3000-3999 are reserved for use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by this protocol.",
      "ja": "範囲3000-3999でのステータスコードは、ライブラリ、フレームワーク、およびアプリケーションで使用するために予約されています。これらのステータスコードは、IANAに直接登録されています。これらのコードの解釈は、このプロトコルで定義されていません。"
    },
    {
      "indent": 3,
      "text": "4000-4999",
      "ja": "４０００ー４９９９"
    },
    {
      "indent": 6,
      "text": "Status codes in the range 4000-4999 are reserved for private use and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by this protocol.",
      "ja": "範囲4000-4999でのステータスコードは、私的使用のために予約されているので、登録することはできません。そのようなコードは、WebSocketのアプリケーション間の事前の合意によって使用することができます。これらのコードの解釈は、このプロトコルで定義されていません。"
    },
    {
      "indent": 0,
      "text": "8. Error Handling",
      "section_title": true,
      "ja": "8.エラー処理"
    },
    {
      "indent": 0,
      "text": "8.1. Handling Errors in UTF-8-Encoded Data",
      "section_title": true,
      "ja": "8.1.  UTF-8でエンコードされたデータのエラーの処理"
    },
    {
      "indent": 3,
      "text": "When an endpoint is to interpret a byte stream as UTF-8 but finds that the byte stream is not, in fact, a valid UTF-8 stream, that endpoint MUST _Fail the WebSocket Connection_. This rule applies both during the opening handshake and during subsequent data exchange.",
      "ja": "エンドポイントはUTF-8などのバイトストリームを解釈するのですが、バイトストリームは、実際には、有効なUTF-8ストリームではないことを発見した場合、そのエンドポイントは、WebSocketをConnection_を_Failしなければなりません。この規則は、開口部ハンドシェーク時以降のデータ交換中の両方に適用されます。"
    },
    {
      "indent": 0,
      "text": "9. Extensions",
      "section_title": true,
      "ja": "9.拡張機能"
    },
    {
      "indent": 3,
      "text": "WebSocket clients MAY request extensions to this specification, and WebSocket servers MAY accept some or all extensions requested by the client. A server MUST NOT respond with any extension not requested by the client. If extension parameters are included in negotiations between the client and the server, those parameters MUST be chosen in accordance with the specification of the extension to which the parameters apply.",
      "ja": "WebSocketのクライアントは、この仕様に拡張を要求することができる、とのWebSocketサーバは、クライアントから要求された一部またはすべての拡張機能を受け入れることができます。サーバは、クライアントから要求されていない任意の拡張子を持つ応じてはいけません。拡張パラメータは、クライアントとサーバとの間の交渉に含まれている場合、これらのパラメータは、パラメータが適用される拡張の仕様に応じて選択されなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.1. Negotiating Extensions",
      "section_title": true,
      "ja": "9.1. 交渉の拡張機能"
    },
    {
      "indent": 3,
      "text": "A client requests extensions by including a |Sec-WebSocket-Extensions| header field, which follows the normal rules for HTTP header fields (see [RFC2616], Section 4.2) and the value of the header field is defined by the following ABNF [RFC2616]. Note that this section is using ABNF syntax/rules from [RFC2616], including the \"implied *LWS rule\". If a value is received by either the client or the server during negotiation that does not conform to the ABNF below, the recipient of such malformed data MUST immediately _Fail the WebSocket Connection_.",
      "ja": "|秒-のWebSocket-拡張機能|クライアントは含めることによって拡張を要求しますHTTPヘッダフィールドの通常の規則に従う（[RFC2616]、セクション4.2を参照）、ヘッダフィールドの値は以下のABNF [RFC2616]で定義されたヘッダフィールド、。このセクションは、「暗黙* LWSルール」を含む、[RFC2616]のABNF構文/規則を使用していることに注意してください。値は以下のABNFに準拠していないネゴシエーション中に、クライアントまたはサーバによって受信された場合には、そのような不正な形式のデータの受信者はすぐWebSocketをConnection_ _Fail必要があります。"
    },
    {
      "indent": 9,
      "text": "Sec-WebSocket-Extensions = extension-list\nextension-list = 1#extension\nextension = extension-token *( \";\" extension-param )\nextension-token = registered-token\nregistered-token = token\nextension-param = token [ \"=\" (token | quoted-string) ]\n    ;When using the quoted-string syntax variant, the value\n    ;after quoted-string unescaping MUST conform to the\n    ;'token' ABNF.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that like other HTTP header fields, this header field MAY be split or combined across multiple lines. Ergo, the following are equivalent:",
      "ja": "他のHTTPヘッダフィールドのように、このヘッダフィールドは、複数の行に分割または組み合わせてもよいことに留意されたいです。エルゴ、以下は等価です。"
    },
    {
      "indent": 9,
      "text": "Sec-WebSocket-Extensions: foo\nSec-WebSocket-Extensions: bar; baz=2",
      "raw": true
    },
    {
      "indent": 3,
      "text": "is exactly equivalent to",
      "ja": "とまったく同じです"
    },
    {
      "indent": 9,
      "text": "Sec-WebSocket-Extensions: foo, bar; baz=2",
      "ja": "SEC-のWebSocket-拡張機能：FOO、バー。バズ= 2"
    },
    {
      "indent": 3,
      "text": "Any extension-token used MUST be a registered token (see Section 11.4). The parameters supplied with any given extension MUST be defined for that extension. Note that the client is only offering to use any advertised extensions and MUST NOT use them unless the server indicates that it wishes to use the extension.",
      "ja": "使用されるすべての拡張トークンは、登録されたトークン（11.4節を参照）でなければなりません。任意の拡張子で指定されたパラメータは、その拡張のために定義されなければなりません。クライアントのみを任意の広告を出して拡張機能を使用するために提供されており、サーバが拡張を使用したいことを示していない限り、それらを使用してはならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note that the order of extensions is significant. Any interactions between multiple extensions MAY be defined in the documents defining the extensions. In the absence of such definitions, the interpretation is that the header fields listed by the client in its request represent a preference of the header fields it wishes to use, with the first options listed being most preferable. The extensions listed by the server in response represent the extensions actually in use for the connection. Should the extensions modify the data and/or framing, the order of operations on the data should be assumed to be the same as the order in which the extensions are listed in the server's response in the opening handshake.",
      "ja": "拡張子の順序が重要であることに注意してください。複数の拡張子の間の任意の相互作用は、拡張子を定義する文書で定義されてもよいです。そのような定義が存在しない場合に、解釈は、その要求にクライアントがリストされているヘッダフィールドが最も好ましいリストされた最初のオプションで、それが使用したいヘッダフィールドの嗜好を表すことです。応じてサーバによって記載されている拡張子は、接続のために実際に使用さ拡張を表します。拡張子は、データおよび/またはフレーミングを変更する必要があり、データに対する操作の順序は、拡張子がオープニングハンドシェイクでのサーバーの応答に示されている順序と同じであると仮定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, if there are two extensions \"foo\" and \"bar\" and if the header field |Sec-WebSocket-Extensions| sent by the server has the value \"foo, bar\", then operations on the data will be made as bar(foo(data)), be those changes to the data itself (such as compression) or changes to the framing that may \"stack\".",
      "ja": "秒-のWebSocket-拡張機能|例えば、2つの拡張「foo」と「bar」とあればヘッダフィールドが存在する場合|サーバによって送信された値は、データの操作をバー（FOO（データ））として説明する「FOO、BAR」、（圧縮など）、データ自体にそれらの変更であるか、またはそれよいフレーミングへの変更」を有しますスタック\"。"
    },
    {
      "indent": 3,
      "text": "Non-normative examples of acceptable extension header fields (note that long lines are folded for readability):",
      "ja": "許容される拡張ヘッダフィールドの非規範的な例（長い行を読みやすくするために折り畳まれていることに注意してください）。"
    },
    {
      "indent": 9,
      "text": "Sec-WebSocket-Extensions: deflate-stream\nSec-WebSocket-Extensions: mux; max-channels=4; flow-control,\n deflate-stream\nSec-WebSocket-Extensions: private-extension",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A server accepts one or more extensions by including a |Sec-WebSocket-Extensions| header field containing one or more extensions that were requested by the client. The interpretation of any extension parameters, and what constitutes a valid response by a server to a requested set of parameters by a client, will be defined by each such extension.",
      "ja": "|秒-のWebSocket-拡張機能|サーバーは、以下を含むことによって、1つ以上の拡張を受け入れますクライアントによって要求された一の以上の拡張機能を含むヘッダフィールド。任意の拡張パラメータの解釈、そしてどのようなクライアントによるパラメータの要求セットにサーバーによって有効な応答を構成するには、各ような拡張によって定義されます。"
    },
    {
      "indent": 0,
      "text": "9.2. Known Extensions",
      "section_title": true,
      "ja": "9.2. 既知の拡張機能"
    },
    {
      "indent": 3,
      "text": "Extensions provide a mechanism for implementations to opt-in to additional protocol features. This document doesn't define any extension, but implementations MAY use extensions defined separately.",
      "ja": "拡張機能は、オプトインするための追加のプロトコル機能を実装するためのメカニズムを提供します。このドキュメントは、任意の拡張子を定義していませんが、実装が個別に定義された拡張機能を使用するかもしれません。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section describes some security considerations applicable to the WebSocket Protocol. Specific security considerations are described in subsections of this section.",
      "ja": "このセクションでは、WebSocketのプロトコルに適用されるいくつかのセキュリティの考慮事項について説明します。特定のセキュリティの考慮事項は、このセクションのサブセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "10.1. Non-Browser Clients",
      "section_title": true,
      "ja": "10.1. 非ブラウザクライアント"
    },
    {
      "indent": 3,
      "text": "The WebSocket Protocol protects against malicious JavaScript running inside a trusted application such as a web browser, for example, by checking of the |Origin| header field (see below). See Section 1.6 for additional details. Such assumptions don't hold true in the case of a more-capable client.",
      "ja": "|起源|のWebSocketプロトコルを確認することで、例えば、Webブラウザなどの信頼できるアプリケーション内で実行されている悪質なJavaScriptのを防御しますヘッダフィールド（下記参照）。詳細については、セクション1.6を参照してください。このような仮定は、より対応クライアントの場合には当てはまらないでください。"
    },
    {
      "indent": 3,
      "text": "While this protocol is intended to be used by scripts in web pages, it can also be used directly by hosts. Such hosts are acting on their own behalf and can therefore send fake |Origin| header fields, misleading the server. Servers should therefore be careful about assuming that they are talking directly to scripts from known origins and must consider that they might be accessed in unexpected ways. In particular, a server should not trust that any input is valid.",
      "ja": "このプロトコルは、Webページ内のスクリプトによって使用されることを意図しているが、それはまた、ホストが直接使用することができます。このようなホストは、自らのために行動しているため、偽の送信することができます|起源を|サーバー誤解を招くヘッダフィールド、。サーバーは、したがって、彼らは知ら起源からスクリプトに直接話していると、彼らは予想外の方法でアクセスされる可能性があることを考慮しなければならないことを前提に注意する必要があります。具体的には、サーバは、任意の入力が有効であることを信用してはいけません。"
    },
    {
      "indent": 3,
      "text": "EXAMPLE: If the server uses input as part of SQL queries, all input text should be escaped before being passed to the SQL server, lest the server be susceptible to SQL injection.",
      "ja": "例：サーバがSQLクエリの一部として入力を使用する場合は、サーバーがSQLインジェクションの影響を受けやすいことがないように、すべての入力テキストは、SQLサーバに渡される前にエスケープする必要があります。"
    },
    {
      "indent": 0,
      "text": "10.2. Origin Considerations",
      "section_title": true,
      "ja": "10.2. 起源の考慮事項"
    },
    {
      "indent": 3,
      "text": "Servers that are not intended to process input from any web page but only for certain sites SHOULD verify the |Origin| field is an origin they expect. If the origin indicated is unacceptable to the server, then it SHOULD respond to the WebSocket handshake with a reply containing HTTP 403 Forbidden status code.",
      "ja": "起源|任意のWebページからの入力を処理するために意図したものではなく、唯一の特定のサイトのためにされていないサーバは、検証すべきです|フィールドは、彼らが期待する原点です。示された原点は、サーバに受け入れられない場合、それはHTTP 403禁止ステータスコードを含む応答でのWebSocketハンドシェイクに応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "The |Origin| header field protects from the attack cases when the untrusted party is typically the author of a JavaScript application that is executing in the context of the trusted client. The client itself can contact the server and, via the mechanism of the |Origin| header field, determine whether to extend those communication privileges to the JavaScript application. The intent is not to prevent non-browsers from establishing connections but rather to ensure that trusted browsers under the control of potentially malicious JavaScript cannot fake a WebSocket handshake.",
      "ja": "|起源|信頼できない当事者は通常、信頼できるクライアントのコンテキストで実行されるJavaScriptアプリケーションの作者であるとき、ヘッダフィールドには、攻撃の例から保護します。起源|クライアント自体は、のメカニズムを介して、サーバに接続してすることができます|フィールドヘッダ、JavaScriptアプリケーションにそれらの通信特権を拡張するかどうかを決定します。その意図は、接続を確立するから非ブラウザを防ぐためではなく、悪意のあるJavaScriptを制御下に信頼されるブラウザは、偽のWebSocketハンドシェイクできないことを保証するものではありません。"
    },
    {
      "indent": 0,
      "text": "10.3. Attacks On Infrastructure (Masking)",
      "section_title": true,
      "ja": "10.3. インフラへの攻撃（マスキング）"
    },
    {
      "indent": 3,
      "text": "In addition to endpoints being the target of attacks via WebSockets, other parts of web infrastructure, such as proxies, may be the subject of an attack.",
      "ja": "WebSocketを介して攻撃の対象となるエンドポイントに加えて、そのようなプロキシとしてWebインフラストラクチャの他の部分は、攻撃の対象となり得ます。"
    },
    {
      "indent": 3,
      "text": "As this protocol was being developed, an experiment was conducted to demonstrate a class of attacks on proxies that led to the poisoning of caching proxies deployed in the wild [TALKING]. The general form of the attack was to establish a connection to a server under the \"attacker's\" control, perform an UPGRADE on the HTTP connection similar to what the WebSocket Protocol does to establish a connection, and subsequently send data over that UPGRADEd connection that looked like a GET request for a specific known resource (which in an attack would likely be something like a widely deployed script for tracking hits or a resource on an ad-serving network). The remote server would respond with something that looked like a response to the fake GET request, and this response would be cached by a nonzero percentage of deployed intermediaries, thus poisoning the cache. The net effect of this attack would be that if a user could be convinced to visit a website the attacker controlled, the attacker could potentially poison the cache for that user and other users behind the same cache and run malicious script on other origins, compromising the web security model.",
      "ja": "このプロトコルが開発されていたとして、実験は[TALKING]野生で展開キャッシングプロキシの中毒につながったプロキシへの攻撃のクラスを実証するために実施しました。攻撃の一般的な形式は、「攻撃者の」制御下サーバーへの接続を確立するのWebSocketプロトコルは、接続を確立するために何に似てHTTP接続でアップグレードを実行し、その後に見えたそのアップグレードされた接続を介してデータを送信することでした（攻撃中にありそうなヒットや広告配信ネットワーク上のリソースを追跡するために広く展開されたスクリプトのようなものになるだろう）、特定の既知のリソースに対するGETリクエストなどがあります。リモートサーバーは、偽のGET要求に対する応答のように見えたし、この応答は、このようにキャッシュをポイズニング、展開仲介の非ゼロの割合でキャッシュされる何かで応答することになります。この攻撃の正味の効果は、ユーザーが攻撃者が制御し、ウェブサイトを訪問することを確信しできれば、攻撃者は潜在的に危険にさらす、同じキャッシュの後ろに、そのユーザーと他のユーザーのためのキャッシュを汚染し、他の起源に悪質なスクリプトを実行することができることになりますウェブセキュリティモデル。"
    },
    {
      "indent": 3,
      "text": "To avoid such attacks on deployed intermediaries, it is not sufficient to prefix application-supplied data with framing that is not compliant with HTTP, as it is not possible to exhaustively discover and test that each nonconformant intermediary does not skip such non-HTTP framing and act incorrectly on the frame payload. Thus, the defense adopted is to mask all data from the client to the server, so that the remote script (attacker) does not have control over how the data being sent appears on the wire and thus cannot construct a message that could be misinterpreted by an intermediary as an HTTP request.",
      "ja": "展開仲介のような攻撃を回避するために、徹底的に各不適合の仲介は、このような非HTTPフレーミングをスキップしていないことを発見し、テストすることはできないとして、HTTPに対応していないフレーミングとプレフィックスアプリケーションが提供するデータには十分ではありませんフレームペイロードに間違って行動します。したがって、採用防衛は、リモートスクリプト（攻撃者）が送信されたデータは、ワイヤーに表示され、これによって誤って解釈される可能性がメッセージを作成することはできませんかを制御できないように、クライアントからサーバにすべてのデータをマスクすることですHTTPリクエストとして仲介。"
    },
    {
      "indent": 3,
      "text": "Clients MUST choose a new masking key for each frame, using an algorithm that cannot be predicted by end applications that provide data. For example, each masking could be drawn from a cryptographically strong random number generator. If the same key is used or a decipherable pattern exists for how the next key is chosen, the attacker can send a message that, when masked, could appear to be an HTTP request (by taking the message the attacker wishes to see on the wire and masking it with the next masking key to be used, the masking key will effectively unmask the data when the client applies it).",
      "ja": "クライアントは、データを提供するエンド・アプリケーションによって予測することができないアルゴリズムを使用して、各フレームのための新たなマスキングキーを選択する必要があります。例えば、各マスクは、暗号的に強い乱数発生器から引き出すことができました。同じ鍵が使用されるか、または次のキーが選択されている方法、攻撃者は、攻撃者がワイヤ上で見ることを望むメッセージを取ることによって（マスクされたとき、HTTPリクエストであるように見える可能性があり、そのメッセージを送信することができるため解読パターンが存在している場合クライアントがそれを適用する際に使用される次のマスキングキーでそれをマスキング、マスキングキーを効果的）データのマスクを解除します。"
    },
    {
      "indent": 3,
      "text": "It is also necessary that once the transmission of a frame from a client has begun, the payload (application-supplied data) of that frame must not be capable of being modified by the application. Otherwise, an attacker could send a long frame where the initial data was a known value (such as all zeros), compute the masking key being used upon receipt of the first part of the data, and then modify the data that is yet to be sent in the frame to appear as an HTTP request when masked. (This is essentially the same problem described in the previous paragraph with using a known or predictable masking key.) If additional data is to be sent or data to be sent is somehow changed, that new or changed data must be sent in a new frame and thus with a new masking key. In short, once transmission of a frame begins, the contents must not be modifiable by the remote script (application).",
      "ja": "クライアントからのフレームの送信が開始された後、そのフレームのペイロード（アプリケーションが提供するデータ）はアプリケーションによって変更されることが可能であってはならないことも必要です。そうでなければ、攻撃者は、初期データ（例えば全てゼロのような）既知の値であった長いフレームを送信するデータの最初の部分の受信の際に使用されるマスキング鍵を計算し、次にであることがまだあるデータを修正することができマスクされたときにHTTPリクエストとして表示されるフレームで送信されました。 （これは本質的に知られている、または予測可能なマスキングキーを使用して、前の段落で説明したのと同じ問題です。）追加データが新規または変更されたデータは、新しいフレームで送らなければならないことを、送信するか、データが何らかの方法で変更されて送信される場合したがって、新しいマスキングキーを持ちます。フレームの送信が始まると要するに、コンテンツがリモートスクリプト（アプリケーション）によって変更可能であってはなりません。"
    },
    {
      "indent": 3,
      "text": "The threat model being protected against is one in which the client sends data that appears to be an HTTP request. As such, the channel that needs to be masked is the data from the client to the server. The data from the server to the client can be made to look like a response, but to accomplish this request, the client must also be able to forge a request. As such, it was not deemed necessary to mask data in both directions (the data from the server to the client is not masked).",
      "ja": "脅威モデルは、クライアントがHTTPリクエストのように見えるデータを送信しているものであるから保護されています。そのため、マスクされる必要があるチャネルは、クライアントからサーバーへのデータです。サーバーからクライアントへのデータは、応答のように見えるようにすることができますが、この要求を達成するために、クライアントは、リクエストを偽造することができなければなりません。このように、それが両方向（サーバからクライアントへのデータはマスクされていない）内のデータをマスクするために必要と判断されませんでした。"
    },
    {
      "indent": 3,
      "text": "Despite the protection provided by masking, non-compliant HTTP proxies will still be vulnerable to poisoning attacks of this type by clients and servers that do not apply masking.",
      "ja": "マスキングによる保護にもかかわらず、非準拠HTTPプロキシは、まだマスクを適用していないクライアントとサーバによって、この種の毒攻撃に対して脆弱になります。"
    },
    {
      "indent": 0,
      "text": "10.4. Implementation-Specific Limits",
      "section_title": true,
      "ja": "10.4. 実装固有の制限"
    },
    {
      "indent": 3,
      "text": "Implementations that have implementation- and/or platform-specific limitations regarding the frame size or total message size after reassembly from multiple frames MUST protect themselves against exceeding those limits. (For example, a malicious endpoint can try to exhaust its peer's memory or mount a denial-of-service attack by sending either a single big frame (e.g., of size 2**60) or by sending a long stream of small frames that are a part of a fragmented message.) Such an implementation SHOULD impose a limit on frame sizes and the total message size after reassembly from multiple frames.",
      "ja": "複数のフレームから再組立後のフレームサイズやメッセージの合計サイズについて、実装および/またはプラットフォーム固有の制限がある実装は、これらの限界を超えるに対して自身を保護しなければなりません。 （例えば、悪質なエンドポイントは、そのピアのメモリを使い果たすか、サイズ2 ** 60の単一の大きなフレーム（例えば、）のいずれかを送信したりすることを小さなフレームの長いストリームを送信することにより、サービス拒否攻撃をマウントしようとすることができます断片化されたメッセージの一部である。）このような実装は、複数のフレームから再組立後のフレームサイズおよびメッセージの合計サイズに制限を課すべきです。"
    },
    {
      "indent": 0,
      "text": "10.5. WebSocket Client Authentication",
      "section_title": true,
      "ja": "10.5.  WebSocketのクライアント認証"
    },
    {
      "indent": 3,
      "text": "This protocol doesn't prescribe any particular way that servers can authenticate clients during the WebSocket handshake. The WebSocket server can use any client authentication mechanism available to a generic HTTP server, such as cookies, HTTP authentication, or TLS authentication.",
      "ja": "このプロトコルは、サーバがのWebSocketハンドシェイク中にクライアントを認証することができます任意の特定の方法を規定していません。 WebSocketのサーバは、クッキー、HTTP認証、またはTLS認証など、一般的なHTTPサーバに利用可能なクライアント認証メカニズムを使用することができます。"
    },
    {
      "indent": 0,
      "text": "10.6. Connection Confidentiality and Integrity",
      "section_title": true,
      "ja": "10.6. 接続の機密性と完全性"
    },
    {
      "indent": 3,
      "text": "Connection confidentiality and integrity is provided by running the WebSocket Protocol over TLS (wss URIs). WebSocket implementations MUST support TLS and SHOULD employ it when communicating with their peers.",
      "ja": "接続の機密性と完全性は、TLS経由のWebSocketプロトコル（WSSのURI）を実行することによって提供されます。 WebSocketの実装は、TLSをサポートしなければならないし、仲間と通信するとき、それを採用すべきです。"
    },
    {
      "indent": 3,
      "text": "For connections using TLS, the amount of benefit provided by TLS depends greatly on the strength of the algorithms negotiated during the TLS handshake. For example, some TLS cipher mechanisms don't provide connection confidentiality. To achieve reasonable levels of protection, clients should use only Strong TLS algorithms. \"Web Security Context: User Interface Guidelines\" [W3C.REC-wsc-ui-20100812] discusses what constitutes Strong TLS algorithms. [RFC5246] provides additional guidance in Appendix A.5 and Appendix D.3.",
      "ja": "TLSを使用して接続するために、TLSによって提供される利点の量は、TLSハンドシェーク中にネゴシエートアルゴリズムの強度に大きく依存します。例えば、いくつかのTLS暗号メカニズムは、接続の機密性を提供していません。保護の合理的なレベルを達成するために、クライアントが強いだけTLSアルゴリズムを使用する必要があります。 \"ウェブセキュリティコンテキスト：ユーザーインターフェイスガイドラインは、\" [W3C.REC-WSC-UI-20100812]強力なTLSアルゴリズムを構成するものについて説明します。 [RFC5246]は付録A.5および付録D.3に追加のガイダンスを提供します。"
    },
    {
      "indent": 0,
      "text": "10.7. Handling of Invalid Data",
      "section_title": true,
      "ja": "10.7. 無効なデータの取り扱い"
    },
    {
      "indent": 3,
      "text": "Incoming data MUST always be validated by both clients and servers. If, at any time, an endpoint is faced with data that it does not understand or that violates some criteria by which the endpoint determines safety of input, or when the endpoint sees an opening handshake that does not correspond to the values it is expecting (e.g., incorrect path or origin in the client request), the endpoint MAY drop the TCP connection. If the invalid data was received after a successful WebSocket handshake, the endpoint SHOULD send a Close frame with an appropriate status code (Section 7.4) before proceeding to _Close the WebSocket Connection_. Use of a Close frame with an appropriate status code can help in diagnosing the problem. If the invalid data is sent during the WebSocket handshake, the server SHOULD return an appropriate HTTP [RFC2616] status code.",
      "ja": "着信データは常にクライアントとサーバーの両方で検証されなければなりません。 、任意の時点で、エンドポイントは、それが理解できないことがデータに直面するか、またはエンドポイントが、入力の安全性を決定することにより、いくつかの基準に違反している場合、またはエンドポイントは、それが期待されている値に対応していない開口ハンドシェークを（見たとき例えば、クライアントの要求で不正なパスまたは起源）、エンドポイントはTCPコネクションを低下することがあります。無効なデータが成功のWebSocketハンドシェイクの後に受信された場合、エンドポイントのWebSocket Connection_を_closeに進む前に、適切なステータスコード（セクション7.4）との緊密なフレームを送信すべきです。適切なステータスコードで閉じるフレームの使用は、問題の診断に役立つことができます。無効なデータが用WebSocketハンドシェイク中に送信された場合、サーバは、適切なHTTP [RFC2616]ステータスコードを返すべきです。"
    },
    {
      "indent": 3,
      "text": "A common class of security problems arises when sending text data using the wrong encoding. This protocol specifies that messages with a Text data type (as opposed to Binary or other types) contain UTF-8- encoded data. Although the length is still indicated and applications implementing this protocol should use the length to determine where the frame actually ends, sending data in an improper encoding may still break assumptions that applications built on top of this protocol may make, leading to anything from misinterpretation of data to loss of data or potential security bugs.",
      "ja": "間違ったエンコーディングを使用してテキストデータを送信する際に、セキュリティ上の問題の一般的なクラスが生じます。このプロトコルは、（バイナリまたは他のタイプではなく）テキストデータ型のメッセージはUTF-8エンコードされたデータが含まれていることを指定します。長さはまだ示されており、このプロトコルを実装するアプリケーションは、不適切な符号化のデータは依然としての誤解から何かをもたらす、このプロトコルの上に構築されたアプリケーションが行うことができる仮定を破ることができる送信、フレームが実際に終了する場所を決定するために長さを使用する必要があるがデータまたは潜在的なセキュリティバグの損失へのデータ。"
    },
    {
      "indent": 0,
      "text": "10.8. Use of SHA-1 by the WebSocket Handshake",
      "section_title": true,
      "ja": "10.8.  WebSocketのハンドシェイクによってSHA-1の使用"
    },
    {
      "indent": 3,
      "text": "The WebSocket handshake described in this document doesn't depend on any security properties of SHA-1, such as collision resistance or resistance to the second pre-image attack (as described in [RFC4270]).",
      "ja": "本書では説明のWebSocketハンドシェイクは、第2のプリイメージ攻撃に対する衝突耐性または抵抗としてSHA-1のいずれかのセキュリティ特性、（[RFC4270]に記載されているように）に依存しません。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "11.1. Registration of New URI Schemes",
      "section_title": true,
      "ja": "11.1. 新しいURIスキームの登録"
    },
    {
      "indent": 0,
      "text": "11.1.1. Registration of \"ws\" Scheme",
      "section_title": true,
      "ja": "11.1.1.  「WS」スキームの登録"
    },
    {
      "indent": 3,
      "text": "A |ws| URI identifies a WebSocket server and resource name.",
      "ja": "| WS | URIは、WebSocketのサーバーとリソースの名前を識別します。"
    },
    {
      "indent": 3,
      "text": "URI scheme name ws",
      "ja": "URIスキーム名のWS"
    },
    {
      "indent": 3,
      "text": "Status Permanent",
      "ja": "ステータス常設"
    },
    {
      "indent": 3,
      "text": "URI scheme syntax Using the ABNF [RFC5234] syntax and ABNF terminals from the URI specification [RFC3986]:",
      "ja": "URI仕様[RFC3986]のABNF [RFC5234]構文とABNF端末を用いURIスキームの構文："
    },
    {
      "indent": 11,
      "text": "\"ws:\" \"//\" authority path-abempty [ \"?\" query ]",
      "ja": "\"WS：\" \"//\" 権威パスabemptyの[ \"\"？クエリ]"
    },
    {
      "indent": 3,
      "text": "The <path-abempty> and <query> [RFC3986] components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in [RFC3986].",
      "ja": "<パスabempty>と<照会> [RFC3986]の成分は、所望のサービスの種類を識別するためにサーバに送信されたリソースの名前を形成します。他のコンポーネントは、[RFC3986]に記載された意味を有します。"
    },
    {
      "indent": 3,
      "text": "URI scheme semantics The only operation for this scheme is to open a connection using the WebSocket Protocol.",
      "ja": "このスキームのURIスキームのセマンティクスのみ操作がのWebSocketプロトコルを使用して接続を開くことです。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations Characters in the host component that are excluded by the syntax defined above MUST be converted from Unicode to ASCII as specified in [RFC3987] or its replacement. For the purposes of scheme-based normalization, Internationalized Domain Name (IDN) forms of the host component and their conversions to punycode are considered equivalent (see Section 5.3.3 of [RFC3987]).",
      "ja": "[RFC3987]またはその置換で指定されるように上記で定義されたシンタックスによって除外されたホストコンポーネント内のコード考慮文字はユニコードからASCIIに変換されなければなりません。スキームに基づく正規化の目的のために、Punycodeでホスト成分およびその変換の国際化ドメイン名（IDN）の形態は、（[RFC3987]のセクション5.3.3を参照）と同等であると考えられます。"
    },
    {
      "indent": 6,
      "text": "Characters in other components that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI [RFC3986] and Internationalized Resource Identifier (IRI) [RFC3987] specifications.",
      "ja": "上記で定義されたシンタックスによって除外されている他の構成要素内の文字は、UTF-8などの文字を符号化し、その後、URIで定義されるように、それらのパーセントエンコード形式を使用して、対応するバイトを交換する最初の[RFC3986]及び国際によってUnicodeからASCIIに変換されなければなりませんリソース識別子（IRI）[RFC3987]の仕様。"
    },
    {
      "indent": 3,
      "text": "Applications/protocols that use this URI scheme name WebSocket Protocol",
      "ja": "このURIスキーム名用WebSocketプロトコルを使用するアプリケーション/プロトコル"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations Use of WebSocket requires use of HTTP version 1.1 or higher.",
      "ja": "相互運用性の考慮のWebSocketを使用すると、HTTPのバージョン1.1以上を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Security considerations See \"Security Considerations\" section.",
      "ja": "セキュリティに関する注意事項は、「セキュリティの考慮事項」を参照してください。"
    },
    {
      "indent": 3,
      "text": "Contact HYBI WG <hybi@ietf.org>",
      "ja": "連絡先HYBI WG <hybi@ietf.org>"
    },
    {
      "indent": 3,
      "text": "Author/Change controller IETF <iesg@ietf.org>",
      "ja": "著者/変更コントローラIETF <iesg@ietf.org>"
    },
    {
      "indent": 3,
      "text": "References RFC 6455",
      "ja": "参考文献RFC 6455"
    },
    {
      "indent": 0,
      "text": "11.1.2. Registration of \"wss\" Scheme",
      "section_title": true,
      "ja": "11.1.2.  「WSS」スキームの登録"
    },
    {
      "indent": 3,
      "text": "A |wss| URI identifies a WebSocket server and resource name and indicates that traffic over that connection is to be protected via TLS (including standard benefits of TLS such as data confidentiality and integrity and endpoint authentication).",
      "ja": "| WSS | URIは、WebSocketのサーバーとリソース名を識別し、その接続を介してトラフィックが（そのようなデータの機密性と整合性およびエンドポイント認証などTLSの標準の利点を含む）TLSによって保護されるべきであることを示しています。"
    },
    {
      "indent": 3,
      "text": "URI scheme name wss",
      "ja": "URIスキーム名WSS"
    },
    {
      "indent": 3,
      "text": "Status Permanent",
      "ja": "ステータス常設"
    },
    {
      "indent": 3,
      "text": "URI scheme syntax Using the ABNF [RFC5234] syntax and ABNF terminals from the URI specification [RFC3986]:",
      "ja": "URI仕様[RFC3986]のABNF [RFC5234]構文とABNF端末を用いURIスキームの構文："
    },
    {
      "indent": 11,
      "text": "\"wss:\" \"//\" authority path-abempty [ \"?\" query ]",
      "ja": "\"WSS：\" \"//\" 権威パスabemptyの[ \"\"？クエリ]"
    },
    {
      "indent": 3,
      "text": "The <path-abempty> and <query> components form the resource name sent to the server to identify the kind of service desired. Other components have the meanings described in [RFC3986].",
      "ja": "<パスabempty>と<照会>成分は、所望のサービスの種類を識別するためにサーバに送信されたリソースの名前を形成します。他のコンポーネントは、[RFC3986]に記載された意味を有します。"
    },
    {
      "indent": 3,
      "text": "URI scheme semantics The only operation for this scheme is to open a connection using the WebSocket Protocol, encrypted using TLS.",
      "ja": "このスキームのURIスキームのセマンティクスのみ操作はTLSを使用して暗号化のWebSocketプロトコルを使用して、接続を開くことです。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations Characters in the host component that are excluded by the syntax defined above MUST be converted from Unicode to ASCII as specified in [RFC3987] or its replacement. For the purposes of scheme-based normalization IDN forms of the host component and their conversions to punycode are considered equivalent (see Section 5.3.3 of [RFC3987]).",
      "ja": "[RFC3987]またはその置換で指定されるように上記で定義されたシンタックスによって除外されたホストコンポーネント内のコード考慮文字はユニコードからASCIIに変換されなければなりません。 Punycodeでホスト成分およびその変換の方式に基づく正規IDN形態の目的のために（[RFC3987]のセクション5.3.3を参照）と同等であると考えられます。"
    },
    {
      "indent": 6,
      "text": "Characters in other components that are excluded by the syntax defined above MUST be converted from Unicode to ASCII by first encoding the characters as UTF-8 and then replacing the corresponding bytes using their percent-encoded form as defined in the URI [RFC3986] and IRI [RFC3987] specifications.",
      "ja": "上記で定義されたシンタックスによって除外されている他の成分に文字が最初のUTF-8として文字をコードし、次いでURI [RFC3986]及びIRIで定義されるように、それらのパーセントエンコード形式を使用して、対応するバイトを交換することによりUnicodeからASCIIに変換されなければなりません[RFC3987]の仕様。"
    },
    {
      "indent": 3,
      "text": "Applications/protocols that use this URI scheme name WebSocket Protocol over TLS",
      "ja": "TLS上で、このURIのスキーム名のWebSocketプロトコルを使用するアプリケーション/プロトコル"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations Use of WebSocket requires use of HTTP version 1.1 or higher.",
      "ja": "相互運用性の考慮のWebSocketを使用すると、HTTPのバージョン1.1以上を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Security considerations See \"Security Considerations\" section.",
      "ja": "セキュリティに関する注意事項は、「セキュリティの考慮事項」を参照してください。"
    },
    {
      "indent": 3,
      "text": "Contact HYBI WG <hybi@ietf.org>",
      "ja": "連絡先HYBI WG <hybi@ietf.org>"
    },
    {
      "indent": 3,
      "text": "Author/Change controller IETF <iesg@ietf.org>",
      "ja": "著者/変更コントローラIETF <iesg@ietf.org>"
    },
    {
      "indent": 3,
      "text": "References RFC 6455",
      "ja": "参考文献RFC 6455"
    },
    {
      "indent": 0,
      "text": "11.2. Registration of the \"WebSocket\" HTTP Upgrade Keyword",
      "section_title": true,
      "ja": "11.2.  「WebSocketの」HTTPの登録キーワードをアップグレード"
    },
    {
      "indent": 3,
      "text": "This section defines a keyword registered in the HTTP Upgrade Tokens Registry as per RFC 2817 [RFC2817].",
      "ja": "このセクションでは、RFC 2817 [RFC2817]に従ってトークンレジストリアップグレードHTTPに登録されたキーワードを定義します。"
    },
    {
      "indent": 3,
      "text": "Name of token WebSocket",
      "ja": "トークンのWebSocketの名前"
    },
    {
      "indent": 3,
      "text": "Author/Change controller IETF <iesg@ietf.org>",
      "ja": "著者/変更コントローラIETF <iesg@ietf.org>"
    },
    {
      "indent": 3,
      "text": "Contact HYBI <hybi@ietf.org>",
      "ja": "連絡先HYBI <hybi@ietf.org>"
    },
    {
      "indent": 3,
      "text": "References RFC 6455",
      "ja": "参考文献RFC 6455"
    },
    {
      "indent": 0,
      "text": "11.3. Registration of New HTTP Header Fields",
      "section_title": true,
      "ja": "11.3. 新しいHTTPヘッダフィールドの登録"
    },
    {
      "indent": 0,
      "text": "11.3.1. Sec-WebSocket-Key",
      "section_title": true,
      "ja": "11.3.1.  SEC-のWebSocketキー"
    },
    {
      "indent": 3,
      "text": "This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].",
      "ja": "このセクションでは、永続的メッセージヘッダフィールド名レジストリ[RFC3864]に登録されているヘッダフィールドを記述する。"
    },
    {
      "indent": 3,
      "text": "Header field name Sec-WebSocket-Key",
      "ja": "ヘッダフィールド名秒-のWebSocketキー"
    },
    {
      "indent": 3,
      "text": "Applicable protocol http",
      "ja": "該当するプロトコルHTTP"
    },
    {
      "indent": 3,
      "text": "Status standard",
      "ja": "ステータス標準"
    },
    {
      "indent": 3,
      "text": "Author/Change controller IETF",
      "ja": "著者/変更コントローラIETF"
    },
    {
      "indent": 3,
      "text": "Specification document(s) RFC 6455",
      "ja": "仕様書（s）はRFC 6455"
    },
    {
      "indent": 3,
      "text": "Related information This header field is only used for WebSocket opening handshake.",
      "ja": "関連情報は、このヘッダーフィールドは唯一のWebSocket開口ハンドシェイクのために使用されます。"
    },
    {
      "indent": 3,
      "text": "The |Sec-WebSocket-Key| header field is used in the WebSocket opening handshake. It is sent from the client to the server to provide part of the information used by the server to prove that it received a valid WebSocket opening handshake. This helps ensure that the server does not accept connections from non-WebSocket clients (e.g., HTTP clients) that are being abused to send data to unsuspecting WebSocket servers.",
      "ja": "|秒-のWebSocketキー|ヘッダフィールドは、WebSocketの開口ハンドシェークに使用されます。それが有効なのWebSocket開口ハンドシェイクを受けたことを証明するために、サーバによって使用される情報の一部を提供するために、クライアントからサーバーに送信されます。これは、サーバーが疑うことを知らないのWebSocketサーバにデータを送信するために虐待されている非のWebSocketクライアント（例えば、HTTPクライアント）からの接続を受け付けないようにします。"
    },
    {
      "indent": 3,
      "text": "The |Sec-WebSocket-Key| header field MUST NOT appear more than once in an HTTP request.",
      "ja": "|秒-のWebSocketキー|ヘッダフィールドは、HTTPリクエストで複数回出現することはできません。"
    },
    {
      "indent": 0,
      "text": "11.3.2. Sec-WebSocket-Extensions",
      "section_title": true,
      "ja": "11.3.2.  SEC-のWebSocket-拡張機能"
    },
    {
      "indent": 3,
      "text": "This section describes a header field for registration in the Permanent Message Header Field Names registry [RFC3864].",
      "ja": "このセクションでは、永続的メッセージヘッダフィールド名レジストリ[RFC3864]に登録するためのヘッダーフィールドを記述する。"
    },
    {
      "indent": 3,
      "text": "Header field name Sec-WebSocket-Extensions",
      "ja": "ヘッダフィールド名秒-のWebSocket-拡張機能"
    },
    {
      "indent": 3,
      "text": "Applicable protocol http",
      "ja": "該当するプロトコルHTTP"
    },
    {
      "indent": 3,
      "text": "Status standard",
      "ja": "ステータス標準"
    },
    {
      "indent": 3,
      "text": "Author/Change controller IETF",
      "ja": "著者/変更コントローラIETF"
    },
    {
      "indent": 3,
      "text": "Specification document(s) RFC 6455",
      "ja": "仕様書（s）はRFC 6455"
    },
    {
      "indent": 3,
      "text": "Related information This header field is only used for WebSocket opening handshake.",
      "ja": "関連情報は、このヘッダーフィールドは唯一のWebSocket開口ハンドシェイクのために使用されます。"
    },
    {
      "indent": 3,
      "text": "The |Sec-WebSocket-Extensions| header field is used in the WebSocket opening handshake. It is initially sent from the client to the server, and then subsequently sent from the server to the client, to agree on a set of protocol-level extensions to use for the duration of the connection.",
      "ja": "|秒-のWebSocket-拡張機能|ヘッダフィールドは、WebSocketの開口ハンドシェークに使用されます。当初はクライアントからサーバに送信され、その後、接続の期間中に使用するプロトコルレベルの拡張機能のセットに同意し、サーバからクライアントに送信されます。"
    },
    {
      "indent": 3,
      "text": "The |Sec-WebSocket-Extensions| header field MAY appear multiple times in an HTTP request (which is logically the same as a single |Sec-WebSocket-Extensions| header field that contains all values. However, the |Sec-WebSocket-Extensions| header field MUST NOT appear more than once in an HTTP response.",
      "ja": "|秒-のWebSocket-拡張機能|すべての値が含まれているヘッダフィールドしかし、| |秒-のWebSocket-拡張機能|ヘッダフィールドは、論理的に単一と同じであるHTTPリクエスト（に複数回表示されることがあります。秒-のWebSocket-拡張機能|ヘッダフィールドはより多く見えてはいけませんHTTPレスポンスで一回。"
    },
    {
      "indent": 0,
      "text": "11.3.3. Sec-WebSocket-Accept",
      "section_title": true,
      "ja": "11.3.3.  SEC-のWebSocket-受け入れ"
    },
    {
      "indent": 3,
      "text": "This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].",
      "ja": "このセクションでは、永続的メッセージヘッダフィールド名レジストリ[RFC3864]に登録されているヘッダフィールドを記述する。"
    },
    {
      "indent": 3,
      "text": "Header field name Sec-WebSocket-Accept",
      "ja": "ヘッダフィールド名秒-のWebSocket-受け入れ"
    },
    {
      "indent": 3,
      "text": "Applicable protocol http",
      "ja": "該当するプロトコルHTTP"
    },
    {
      "indent": 3,
      "text": "Status standard",
      "ja": "ステータス標準"
    },
    {
      "indent": 3,
      "text": "Author/Change controller IETF",
      "ja": "著者/変更コントローラIETF"
    },
    {
      "indent": 3,
      "text": "Specification document(s) RFC 6455",
      "ja": "仕様書（s）はRFC 6455"
    },
    {
      "indent": 3,
      "text": "Related information This header field is only used for the WebSocket opening handshake.",
      "ja": "関連情報は、このヘッダーフィールドは唯一のWebSocket開口ハンドシェイクのために使用されます。"
    },
    {
      "indent": 3,
      "text": "The |Sec-WebSocket-Accept| header field is used in the WebSocket opening handshake. It is sent from the server to the client to confirm that the server is willing to initiate the WebSocket connection.",
      "ja": "|秒-のWebSocket-受け入れ|ヘッダフィールドは、WebSocketの開口ハンドシェークに使用されます。サーバーがWebSocketの接続を開始する意志があることを確認するために、サーバからクライアントに送信されます。"
    },
    {
      "indent": 3,
      "text": "The |Sec-WebSocket-Accept| header MUST NOT appear more than once in an HTTP response.",
      "ja": "|秒-のWebSocket-受け入れ|ヘッダは、HTTPレスポンスに一度より多く見えてはいけません。"
    },
    {
      "indent": 0,
      "text": "11.3.4. Sec-WebSocket-Protocol",
      "section_title": true,
      "ja": "11.3.4.  SEC-のWebSocketプロトコル-"
    },
    {
      "indent": 3,
      "text": "This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].",
      "ja": "このセクションでは、永続的メッセージヘッダフィールド名レジストリ[RFC3864]に登録されているヘッダフィールドを記述する。"
    },
    {
      "indent": 3,
      "text": "Header field name Sec-WebSocket-Protocol",
      "ja": "ヘッダフィールド名秒-のWebSocketプロトコル-"
    },
    {
      "indent": 3,
      "text": "Applicable protocol http",
      "ja": "該当するプロトコルHTTP"
    },
    {
      "indent": 3,
      "text": "Status standard",
      "ja": "ステータス標準"
    },
    {
      "indent": 3,
      "text": "Author/Change controller IETF",
      "ja": "著者/変更コントローラIETF"
    },
    {
      "indent": 3,
      "text": "Specification document(s) RFC 6455",
      "ja": "仕様書（s）はRFC 6455"
    },
    {
      "indent": 3,
      "text": "Related information This header field is only used for the WebSocket opening handshake.",
      "ja": "関連情報は、このヘッダーフィールドは唯一のWebSocket開口ハンドシェイクのために使用されます。"
    },
    {
      "indent": 3,
      "text": "The |Sec-WebSocket-Protocol| header field is used in the WebSocket opening handshake. It is sent from the client to the server and back from the server to the client to confirm the subprotocol of the connection. This enables scripts to both select a subprotocol and be sure that the server agreed to serve that subprotocol.",
      "ja": "|秒-のWebSocket-プロトコル|ヘッダフィールドは、WebSocketの開口ハンドシェークに使用されます。接続のサブプロトコルを確認するためにクライアントにサーバーからクライアントからサーバに送信されています。これは、両方のサブプロトコルを選択し、サーバがそのサブプロトコルを提供することに合意したことを確認するためのスクリプトを可能にします。"
    },
    {
      "indent": 3,
      "text": "The |Sec-WebSocket-Protocol| header field MAY appear multiple times in an HTTP request (which is logically the same as a single |Sec-WebSocket-Protocol| header field that contains all values). However, the |Sec-WebSocket-Protocol| header field MUST NOT appear more than once in an HTTP response.",
      "ja": "|秒-のWebSocket-プロトコル|ヘッダフィールドは、（|秒-のWebSocket-プロトコル|すべての値を含むヘッダフィールド論理的に単一のと同じである）HTTPリクエストで複数回表示されることがあります。しかし、|秒-のWebSocket-プロトコル|ヘッダフィールドは、HTTPレスポンスに一度より多く見えてはいけません。"
    },
    {
      "indent": 0,
      "text": "11.3.5. Sec-WebSocket-Version",
      "section_title": true,
      "ja": "11.3.5.  SEC-のWebSocket-バージョン"
    },
    {
      "indent": 3,
      "text": "This section describes a header field registered in the Permanent Message Header Field Names registry [RFC3864].",
      "ja": "このセクションでは、永続的メッセージヘッダフィールド名レジストリ[RFC3864]に登録されているヘッダフィールドを記述する。"
    },
    {
      "indent": 3,
      "text": "Header field name Sec-WebSocket-Version",
      "ja": "ヘッダフィールド名秒-のWebSocket-バージョン"
    },
    {
      "indent": 3,
      "text": "Applicable protocol http",
      "ja": "該当するプロトコルHTTP"
    },
    {
      "indent": 3,
      "text": "Status standard",
      "ja": "ステータス標準"
    },
    {
      "indent": 3,
      "text": "Author/Change controller IETF",
      "ja": "著者/変更コントローラIETF"
    },
    {
      "indent": 3,
      "text": "Specification document(s) RFC 6455",
      "ja": "仕様書（s）はRFC 6455"
    },
    {
      "indent": 3,
      "text": "Related information This header field is only used for the WebSocket opening handshake.",
      "ja": "関連情報は、このヘッダーフィールドは唯一のWebSocket開口ハンドシェイクのために使用されます。"
    },
    {
      "indent": 3,
      "text": "The |Sec-WebSocket-Version| header field is used in the WebSocket opening handshake. It is sent from the client to the server to indicate the protocol version of the connection. This enables servers to correctly interpret the opening handshake and subsequent data being sent from the data, and close the connection if the server cannot interpret that data in a safe manner. The |Sec-WebSocket-Version| header field is also sent from the server to the client on WebSocket handshake error, when the version received from the client does not match a version understood by the server. In such a case, the header field includes the protocol version(s) supported by the server.",
      "ja": "|秒-のWebSocket-バージョン|ヘッダフィールドは、WebSocketの開口ハンドシェークに使用されます。接続のプロトコルバージョンを示すために、クライアントからサーバーに送信されます。これは正しくオープニングハンドシェイクとデータから送信された後続のデータを解釈し、サーバは安全な方法でそのデータを解釈できない場合は、接続を閉じるには、サーバを可能にします。 |秒-のWebSocket-バージョン|クライアントから受信したバージョンは、サーバによって理解されるバージョンと一致しない場合ヘッダフィールドはまた、のWebSocketハンドシェイクエラーにサーバからクライアントに送信されます。このような場合には、ヘッダフィールドは、サーバでサポートされているプロトコルのバージョン（複数可）を含みます。"
    },
    {
      "indent": 3,
      "text": "Note that there is no expectation that higher version numbers are necessarily backward compatible with lower version numbers.",
      "ja": "より高いバージョン番号が必ずしも低いバージョン番号との下位互換性があるという期待が存在しないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The |Sec-WebSocket-Version| header field MAY appear multiple times in an HTTP response (which is logically the same as a single |Sec-WebSocket-Version| header field that contains all values). However, the |Sec-WebSocket-Version| header field MUST NOT appear more than once in an HTTP request.",
      "ja": "|秒-のWebSocket-バージョン| （すべての値を含むヘッダフィールド| |秒-のWebSocket-バージョン、論理的に単一と同じである）ヘッダフィールドは、HTTPレスポンスに複数回表示されることがあります。しかし、|秒-のWebSocket-バージョン|ヘッダフィールドは、HTTPリクエストで複数回出現することはできません。"
    },
    {
      "indent": 0,
      "text": "11.4. WebSocket Extension Name Registry",
      "section_title": true,
      "ja": "11.4.  WebSocketの拡張名のレジストリ"
    },
    {
      "indent": 3,
      "text": "This specification creates a new IANA registry for WebSocket Extension names to be used with the WebSocket Protocol in accordance with the principles set out in RFC 5226 [RFC5226].",
      "ja": "この仕様はRFC 5226 [RFC5226]に定める原則に従ってのWebSocketプロトコルで使用するのWebSocket拡張子名のための新しいIANAレジストリを作成します。"
    },
    {
      "indent": 3,
      "text": "As part of this registry, IANA maintains the following information:",
      "ja": "このレジストリの一環として、IANAは、以下の情報を保持しています。"
    },
    {
      "indent": 3,
      "text": "Extension Identifier The identifier of the extension, as will be used in the |Sec-WebSocket-Extensions| header field registered in Section 11.3.2 of this specification. The value must conform to the requirements for an extension-token as defined in Section 9.1 of this specification.",
      "ja": "拡張識別子で使用されるように、延長の識別子、|秒-のWebSocket-拡張機能|ヘッダフィールドは、この仕様のセクション11.3.2に登録されています。本明細書のセクション9.1で定義された値は、拡張トークンの要件に適合しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Extension Common Name The name of the extension, as the extension is generally referred to.",
      "ja": "拡張共通名の拡張子は一般的に呼ばれているとして、拡張の名前、。"
    },
    {
      "indent": 3,
      "text": "Extension Definition A reference to the document in which the extension being used with the WebSocket Protocol is defined.",
      "ja": "拡張定義のWebSocketプロトコルで使用されている拡張機能が定義されている文書を参照します。"
    },
    {
      "indent": 3,
      "text": "Known Incompatible Extensions A list of extension identifiers with which this extension is known to be incompatible.",
      "ja": "互換性のない拡張機能にこの拡張子が不適合であることが知られていると拡張識別子のリストを知られています。"
    },
    {
      "indent": 3,
      "text": "WebSocket Extension names are to be subject to the \"First Come First Served\" IANA registration policy [RFC5226].",
      "ja": "WebSocketの拡張子名は「まず第一に役立っ是非」IANA登録ポリシー[RFC5226]の対象とします。"
    },
    {
      "indent": 3,
      "text": "There are no initial values in this registry.",
      "ja": "このレジストリには初期値がありません。"
    },
    {
      "indent": 0,
      "text": "11.5. WebSocket Subprotocol Name Registry",
      "section_title": true,
      "ja": "11.5.  WebSocketのサブプロトコル名のレジストリ"
    },
    {
      "indent": 3,
      "text": "This specification creates a new IANA registry for WebSocket Subprotocol names to be used with the WebSocket Protocol in accordance with the principles set out in RFC 5226 [RFC5226].",
      "ja": "この仕様はRFC 5226 [RFC5226]に定める原則に従ってのWebSocketプロトコルで使用するのWebSocketサブプロトコル名の新しいIANAレジストリを作成します。"
    },
    {
      "indent": 3,
      "text": "As part of this registry, IANA maintains the following information:",
      "ja": "このレジストリの一環として、IANAは、以下の情報を保持しています。"
    },
    {
      "indent": 3,
      "text": "Subprotocol Identifier The identifier of the subprotocol, as will be used in the |Sec-WebSocket-Protocol| header field registered in Section 11.3.4 of this specification. The value must conform to the requirements given in item 10 of Section 4.1 of this specification -- namely, the value must be a token as defined by RFC 2616 [RFC2616].",
      "ja": "サブプロトコル識別子で使用されるように、サブプロトコルの識別子、|秒-のWebSocket-プロトコル|ヘッダフィールドは、この仕様のセクション11.3.4に登録されています。値は、本明細書のセクション4.1の項目10に与えられた要件に適合しなければならない -  RFC 2616 [RFC2616]で定義されるように、すなわち、値がトークンでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Subprotocol Common Name The name of the subprotocol, as the subprotocol is generally referred to.",
      "ja": "サブプロトコル共通名サブプロトコルの名前、サブプロトコルは、一般的に呼ばれているよう。"
    },
    {
      "indent": 3,
      "text": "Subprotocol Definition A reference to the document in which the subprotocol being used with the WebSocket Protocol is defined.",
      "ja": "サブプロトコル定義のWebSocketプロトコルで使用されるサブプロトコルが定義されている文書を参照します。"
    },
    {
      "indent": 3,
      "text": "WebSocket Subprotocol names are to be subject to the \"First Come First Served\" IANA registration policy [RFC5226].",
      "ja": "WebSocketのサブプロトコル名は「まず第一に役立っ是非」IANA登録ポリシー[RFC5226]の対象とします。"
    },
    {
      "indent": 0,
      "text": "11.6. WebSocket Version Number Registry",
      "section_title": true,
      "ja": "11.6.  WebSocketのバージョン番号のレジストリ"
    },
    {
      "indent": 3,
      "text": "This specification creates a new IANA registry for WebSocket Version Numbers to be used with the WebSocket Protocol in accordance with the principles set out in RFC 5226 [RFC5226].",
      "ja": "この仕様はRFC 5226 [RFC5226]に定める原則に従ってのWebSocketプロトコルで使用するのWebSocketのバージョン番号に新しいIANAレジストリを作成します。"
    },
    {
      "indent": 3,
      "text": "As part of this registry, IANA maintains the following information:",
      "ja": "このレジストリの一環として、IANAは、以下の情報を保持しています。"
    },
    {
      "indent": 3,
      "text": "Version Number The version number to be used in the |Sec-WebSocket-Version| is specified in Section 4.1 of this specification. The value must be a non-negative integer in the range between 0 and 255 (inclusive).",
      "ja": "バージョン番号バージョン番号がで使用する|秒-のWebSocket-バージョン|この仕様書の4.1節で指定されています。値は0から255（両端を含む）の範囲の負でない整数でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Reference The RFC requesting a new version number or a draft name with version number (see below).",
      "ja": "新しいバージョン番号またはバージョン番号（下記参照）とドラフト名を要求するRFCを参照します。"
    },
    {
      "indent": 3,
      "text": "Status Either \"Interim\" or \"Standard\". See below for description.",
      "ja": "ステータスの「中間」または「標準」のどちらか。詳細については、以下を参照してください。"
    },
    {
      "indent": 3,
      "text": "A version number is designated as either \"Interim\" or \"Standard\".",
      "ja": "バージョン番号は「中間」または「標準」のいずれかに指定されています。"
    },
    {
      "indent": 3,
      "text": "A \"Standard\" version number is documented in an RFC and used to identify a major, stable version of the WebSocket protocol, such as the version defined by this RFC. \"Standard\" version numbers are subject to the \"IETF Review\" IANA registration policy [RFC5226].",
      "ja": "「標準」バージョン番号はRFCに文書化され、例えば、このRFCによって定義されたバージョンとのWebSocketプロトコルの主要な、安定したバージョンを識別するために使用されます。 「標準」バージョン番号は、「IETFレビュー」IANA登録ポリシー[RFC5226]の対象となっています。"
    },
    {
      "indent": 3,
      "text": "An \"Interim\" version number is documented in an Internet-Draft and used to help implementors identify and interoperate with deployed versions of the WebSocket protocol, such as versions developed before the publication of this RFC. \"Interim\" version numbers are subject to the \"Expert Review\" IANA registration policy [RFC5226], with the chairs of the HYBI Working Group (or, if the working group closes, the Area Directors for the IETF Applications Area) being the initial Designated Experts.",
      "ja": "「中間」バージョン番号はインターネットドラフトに記載さ及び実装を特定し、そのような本RFCの出版前に開発されたバージョンとのWebSocketプロトコルの展開バージョンとの相互運用を助けるために使用されます。 「暫定」のバージョン番号はHYBIワーキンググループ（または、ワーキンググループが閉じた場合、IETFアプリケーションエリアのエリアディレクター）の椅子が指定初期ことで、「エキスパートレビュー」IANA登録ポリシー[RFC5226]の対象となります専門家。"
    },
    {
      "indent": 3,
      "text": "IANA has added initial values to the registry as follows.",
      "ja": "次のようにIANAレジストリに初期値を追加しました。"
    },
    {
      "indent": 3,
      "text": "+--------+-----------------------------------------+----------+\n|Version |                Reference                |  Status  |\n| Number |                                         |          |\n+--------+-----------------------------------------+----------+\n| 0      + draft-ietf-hybi-thewebsocketprotocol-00 | Interim  |\n+--------+-----------------------------------------+----------+\n| 1      + draft-ietf-hybi-thewebsocketprotocol-01 | Interim  |\n+--------+-----------------------------------------+----------+\n| 2      + draft-ietf-hybi-thewebsocketprotocol-02 | Interim  |\n+--------+-----------------------------------------+----------+\n| 3      + draft-ietf-hybi-thewebsocketprotocol-03 | Interim  |\n+--------+-----------------------------------------+----------+\n| 4      + draft-ietf-hybi-thewebsocketprotocol-04 | Interim  |\n+--------+-----------------------------------------+----------+\n| 5      + draft-ietf-hybi-thewebsocketprotocol-05 | Interim  |\n+--------+-----------------------------------------+----------+\n| 6      + draft-ietf-hybi-thewebsocketprotocol-06 | Interim  |\n+--------+-----------------------------------------+----------+\n| 7      + draft-ietf-hybi-thewebsocketprotocol-07 | Interim  |\n+--------+-----------------------------------------+----------+\n| 8      + draft-ietf-hybi-thewebsocketprotocol-08 | Interim  |\n+--------+-----------------------------------------+----------+\n| 9      +                Reserved                 |          |\n+--------+-----------------------------------------+----------+\n| 10     +                Reserved                 |          |\n+--------+-----------------------------------------+----------+\n| 11     +                Reserved                 |          |\n+--------+-----------------------------------------+----------+\n| 12     +                Reserved                 |          |\n+--------+-----------------------------------------+----------+\n| 13     +                RFC 6455                 | Standard |\n+--------+-----------------------------------------+----------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.7. WebSocket Close Code Number Registry",
      "section_title": true,
      "ja": "11.7.  WebSocketを閉じるコード番号レジストリ"
    },
    {
      "indent": 3,
      "text": "This specification creates a new IANA registry for WebSocket Connection Close Code Numbers in accordance with the principles set out in RFC 5226 [RFC5226].",
      "ja": "この仕様はRFC 5226 [RFC5226]に定める原則に従ってのWebSocket接続を閉じるコード番号のための新しいIANAレジストリを作成します。"
    },
    {
      "indent": 3,
      "text": "As part of this registry, IANA maintains the following information:",
      "ja": "このレジストリの一環として、IANAは、以下の情報を保持しています。"
    },
    {
      "indent": 3,
      "text": "Status Code The Status Code denotes a reason for a WebSocket connection closure as per Section 7.4 of this document. The status code is an integer number between 1000 and 4999 (inclusive).",
      "ja": "ステータスコードはステータスコードは、このドキュメントのセクション7.4あたりとのWebSocket接続の閉鎖の理由を示しています。ステータスコードは1000 4999（両端を含む）の間の整数です。"
    },
    {
      "indent": 3,
      "text": "Meaning The meaning of the status code. Each status code has to have a unique meaning.",
      "ja": "ステータスコードの意味を意味。各ステータスコードはユニークな意味を持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "Contact A contact for the entity reserving the status code.",
      "ja": "ステータスコードを予約するエンティティのための連絡先にお問い合わせください。"
    },
    {
      "indent": 3,
      "text": "Reference The stable document requesting the status codes and defining their meaning. This is required for status codes in the range 1000-2999 and recommended for status codes in the range 3000-3999.",
      "ja": "ステータスコードを要求し、その意味を定義し、安定した文書を参照します。これは、1000年から2999年の範囲でステータスコードのために必要な範囲3000から3999にステータスコードをお勧めします。"
    },
    {
      "indent": 3,
      "text": "WebSocket Close Code Numbers are subject to different registration requirements depending on their range. Requests for status codes for use by this protocol and its subsequent versions or extensions are subject to any one of the \"Standards Action\", \"Specification Required\" (which implies \"Designated Expert\"), or \"IESG Review\" IANA registration policies and should be granted in the range 1000-2999. Requests for status codes for use by libraries, frameworks, and applications are subject to the \"First Come First Served\" IANA registration policy and should be granted in the range 3000-3999. The range of status codes from 4000-4999 is designated for Private Use. Requests should indicate whether they are requesting status codes for use by the WebSocket Protocol (or a future version of the protocol), by extensions, or by libraries/frameworks/applications.",
      "ja": "WebSocketを閉じるコード番号は、その範囲に応じて異なる登録要件の対象となっています。このプロトコルで使用するためのステータスコードについての要求とその後続バージョンまたは拡張は、（「指定エキスパート」を意味する）「仕様が必要」、または「IESGレビュー」IANA登録ポリシー「標準アクション」のいずれかを受けているとすべき範囲1000-2999で付与されます。ライブラリ、フレームワーク、およびアプリケーションで使用するためのステータスコードについての要求は、「まず第一に役立っ是非」IANA登録ポリシーの対象であり、範囲3000から3999に付与する必要があります。 4000-4999からステータスコードの範囲は、私的使用のために指定されています。要求は、機能拡張によって、またはライブラリ/フレームワーク/アプリケーションによって、彼らは状況のWebSocketプロトコルで使用するためのコード（またはプロトコルの将来のバージョン）を要求しているかどうかを示す必要があります。"
    },
    {
      "indent": 3,
      "text": "IANA has added initial values to the registry as follows.",
      "ja": "次のようにIANAレジストリに初期値を追加しました。"
    },
    {
      "indent": 4,
      "text": " |Status Code | Meaning         | Contact       | Reference |\n-+------------+-----------------+---------------+-----------|\n | 1000       | Normal Closure  | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1001       | Going Away      | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1002       | Protocol error  | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1003       | Unsupported Data| hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1004       | ---Reserved---- | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1005       | No Status Rcvd  | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1006       | Abnormal Closure| hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1007       | Invalid frame   | hybi@ietf.org | RFC 6455  |\n |            | payload data    |               |           |\n-+------------+-----------------+---------------+-----------|\n | 1008       | Policy Violation| hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1009       | Message Too Big | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1010       | Mandatory Ext.  | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|\n | 1011       | Internal Server | hybi@ietf.org | RFC 6455  |\n |            | Error           |               |           |\n-+------------+-----------------+---------------+-----------|\n | 1015       | TLS handshake   | hybi@ietf.org | RFC 6455  |\n-+------------+-----------------+---------------+-----------|",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.8. WebSocket Opcode Registry",
      "section_title": true,
      "ja": "11.8.  WebSocketのオペコードレジストリ"
    },
    {
      "indent": 3,
      "text": "This specification creates a new IANA registry for WebSocket Opcodes in accordance with the principles set out in RFC 5226 [RFC5226].",
      "ja": "この仕様はRFC 5226 [RFC5226]に定める原則に従ってのWebSocketオペコードのための新しいIANAレジストリを作成します。"
    },
    {
      "indent": 3,
      "text": "As part of this registry, IANA maintains the following information:",
      "ja": "このレジストリの一環として、IANAは、以下の情報を保持しています。"
    },
    {
      "indent": 3,
      "text": "Opcode The opcode denotes the frame type of the WebSocket frame, as defined in Section 5.2. The opcode is an integer number between 0 and 15, inclusive.",
      "ja": "セクション5.2で定義されるようにオペコードが、WebSocketのフレームのフレームタイプを表すオペコード。オペコードは、0〜15までの間の整数です。"
    },
    {
      "indent": 3,
      "text": "Meaning The meaning of the opcode value.",
      "ja": "オペコード値の意味を意味。"
    },
    {
      "indent": 3,
      "text": "Reference The specification requesting the opcode.",
      "ja": "オペコードを要求する仕様を参照します。"
    },
    {
      "indent": 3,
      "text": "WebSocket Opcode numbers are subject to the \"Standards Action\" IANA registration policy [RFC5226].",
      "ja": "WebSocketのオペコード番号は、「標準アクション」IANA登録ポリシー[RFC5226]の対象となっています。"
    },
    {
      "indent": 3,
      "text": "IANA has added initial values to the registry as follows.",
      "ja": "次のようにIANAレジストリに初期値を追加しました。"
    },
    {
      "indent": 4,
      "text": " |Opcode  | Meaning                             | Reference |\n-+--------+-------------------------------------+-----------|\n | 0      | Continuation Frame                  | RFC 6455  |\n-+--------+-------------------------------------+-----------|\n | 1      | Text Frame                          | RFC 6455  |\n-+--------+-------------------------------------+-----------|\n | 2      | Binary Frame                        | RFC 6455  |\n-+--------+-------------------------------------+-----------|\n | 8      | Connection Close Frame              | RFC 6455  |\n-+--------+-------------------------------------+-----------|\n | 9      | Ping Frame                          | RFC 6455  |\n-+--------+-------------------------------------+-----------|\n | 10     | Pong Frame                          | RFC 6455  |\n-+--------+-------------------------------------+-----------|",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.9. WebSocket Framing Header Bits Registry",
      "section_title": true,
      "ja": "11.9.  WebSocketのフレーミングヘッダービットレジストリ"
    },
    {
      "indent": 3,
      "text": "This specification creates a new IANA registry for WebSocket Framing Header Bits in accordance with the principles set out in RFC 5226 [RFC5226]. This registry controls assignment of the bits marked RSV1, RSV2, and RSV3 in Section 5.2.",
      "ja": "この仕様は、RFC 5226 [RFC5226]に記載された原理に従ってのWebSocketフレーミングヘッダビットに対する新しいIANAレジストリを作成します。このレジストリは、ビットの割り当ては、5.2節でRSV1、RSV2、およびRSV3をマークし制御します。"
    },
    {
      "indent": 3,
      "text": "These bits are reserved for future versions or extensions of this specification.",
      "ja": "これらのビットは将来のバージョンまたはこの仕様の拡張のために予約されています。"
    },
    {
      "indent": 3,
      "text": "WebSocket Framing Header Bits assignments are subject to the \"Standards Action\" IANA registration policy [RFC5226].",
      "ja": "WebSocketのフレーミングヘッダービットの割り当ては、「標準アクション」IANA登録ポリシー[RFC5226]の対象となっています。"
    },
    {
      "indent": 0,
      "text": "12. Using the WebSocket Protocol from Other Specifications",
      "section_title": true,
      "ja": "その他の仕様からのWebSocketプロトコルを使用して12"
    },
    {
      "indent": 3,
      "text": "The WebSocket Protocol is intended to be used by another specification to provide a generic mechanism for dynamic author-defined content, e.g., in a specification defining a scripted API.",
      "ja": "WebSocketのプロトコルは、スクリプトAPIを定義する仕様で、例えば、ダイナミック作成者定義のコンテンツのための一般的なメカニズムを提供する別の仕様で使用されることが意図されます。"
    },
    {
      "indent": 3,
      "text": "Such a specification first needs to _Establish a WebSocket Connection_, providing that algorithm with:",
      "ja": "このような仕様は、最初にそのアルゴリズムを提供し、_EstablishのWebSocket Connection_する必要があります："
    },
    {
      "indent": 3,
      "text": "o The destination, consisting of a /host/ and a /port/.",
      "ja": "/ホスト/及びA /ポート/成る、宛先O。"
    },
    {
      "indent": 3,
      "text": "o A /resource name/, which allows for multiple services to be identified at one host and port.",
      "ja": "複数のサービスを1台のホストとポートで識別されるようにすることができますO A /リソース名/、。"
    },
    {
      "indent": 3,
      "text": "o A /secure/ flag, which is true if the connection is to be encrypted and false otherwise.",
      "ja": "接続は、そうでない場合は、暗号化と偽される場合も同様であるO A /セキュア/フラグ。"
    },
    {
      "indent": 3,
      "text": "o An ASCII serialization of an origin [RFC6454] that is being made responsible for the connection.",
      "ja": "O接続に責任を作られているの起源[RFC6454]のASCIIのシリアライゼーション。"
    },
    {
      "indent": 3,
      "text": "o Optionally, a string identifying a protocol that is to be layered over the WebSocket connection.",
      "ja": "O必要に応じて、WebSocketの接続を介して積層されるプロトコルを識別する文字列。"
    },
    {
      "indent": 3,
      "text": "The /host/, /port/, /resource name/, and /secure/ flag are usually obtained from a URI using the steps to parse a WebSocket URI's components. These steps fail if the URI does not specify a WebSocket.",
      "ja": "/ホスト/、/ポート/、/リソース名/、および/セキュア/フラグは、通常のWebSocket URIの成分を解析する手順を使用してURIから得られます。 URIは、WebSocketを指定しない場合、これらの手順が失敗します。"
    },
    {
      "indent": 3,
      "text": "If at any time the connection is to be closed, then the specification needs to use the _Close the WebSocket Connection_ algorithm (Section 7.1.1).",
      "ja": "任意の時点で接続がクローズされる場合、明細書は_closeのWebSocket Connection_アルゴリズム（セクション7.1.1）を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 7.1.4 defines when _The WebSocket Connection is Closed_.",
      "ja": "WebSocketの接続が閉じられるとき、セクション7.1.4で定義されています。"
    },
    {
      "indent": 3,
      "text": "While a connection is open, the specification will need to handle the cases when _A WebSocket Message Has Been Received_ (Section 6.2).",
      "ja": "接続が開いている間、仕様が_AのWebSocketメッセージReceived_（6.2節）された際にケースを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "To send some data /data/ to an open connection, the specification needs to _Send a WebSocket Message_ (Section 6.1).",
      "ja": "オープン接続に/いくつかのデータ/データを送信するには、仕様がWebSocketのメッセージ_（6.1節）を_Sendする必要があります。"
    },
    {
      "indent": 0,
      "text": "13. Acknowledgements",
      "section_title": true,
      "ja": "13.謝辞"
    },
    {
      "indent": 3,
      "text": "Special thanks are due to Ian Hickson, who was the original author and editor of this protocol. The initial design of this specification benefitted from the participation of many people in the WHATWG and WHATWG mailing list. Contributions to that specification are not tracked by section, but a list of all who contributed to that specification is given in the WHATWG HTML specification at http://whatwg.org/html5.",
      "ja": "特別な感謝は、原作者とこのプロトコルの編集者だったイアン・ヒクソン、によるものです。 WHATWGとWHATWGメーリングリストの多くの人々の参加の恩恵を受け、この仕様の初期設計。その仕様への貢献は、セクションによって追跡されていませんが、その仕様に貢献したすべてのリストがhttp://whatwg.org/html5でWHATWG HTML仕様書に記載されています。"
    },
    {
      "indent": 3,
      "text": "Special thanks also to John Tamplin for providing a significant amount of text for the \"Data Framing\" section of this specification.",
      "ja": "この仕様の「データフレーミング」セクションのテキスト、かなりの量を提供するためにも、ジョンTamplinに感謝します。"
    },
    {
      "indent": 3,
      "text": "Special thanks also to Adam Barth for providing a significant amount of text and background research for the \"Data Masking\" section of this specification.",
      "ja": "この仕様の「データ・マスキング」セクションのテキストと背景の研究にかなりの量を提供するためのアダム・バースにも感謝します。"
    },
    {
      "indent": 3,
      "text": "Special thanks to Lisa Dusseault for the Apps Area review (and for helping to start this work), Richard Barnes for the Gen-Art review, and Magnus Westerlund for the Transport Area Review. Special thanks to HYBI WG past and present WG chairs who tirelessly worked behind the scene to move this work toward completion: Joe Hildebrand, Salvatore Loreto, and Gabriel Montenegro. And last but not least, special thank you to the responsible Area Director Peter Saint-Andre.",
      "ja": "特別ジェンアートレビューのためのアプリエリアの見直しのためのリサDusseaultのおかげで（と、この作業を開始するために支援するため）、リチャード・バーンズ、交通エリアレビューのためのマグヌスウェスター。疲れを知らずに完成に向かって、この作品を移動するシーンの背後に働いHYBI WGの過去と現在のWGいすに感謝：ジョー・ヒルデブラント、サルヴァトーレロレート、とガブリエルモンテネグロ。そして、少なくとも最後のではなく、特別な責任エリアディレクターピーターサンアンドレをお願い致します。"
    },
    {
      "indent": 3,
      "text": "Thank you to the following people who participated in discussions on the HYBI WG mailing list and contributed ideas and/or provided detailed reviews (the list is likely to be incomplete): Greg Wilkins, John Tamplin, Willy Tarreau, Maciej Stachowiak, Jamie Lokier, Scott Ferguson, Bjoern Hoehrmann, Julian Reschke, Dave Cridland, Andy Green, Eric Rescorla, Inaki Baz Castillo, Martin Thomson, Roberto Peon, Patrick McManus, Zhong Yu, Bruce Atherton, Takeshi Yoshino, Martin J. Duerst, James Graham, Simon Pieters, Roy T. Fielding, Mykyta Yevstifeyev, Len Holgate, Paul Colomiets, Piotr Kulaga, Brian Raymor, Jan Koehler, Joonas Lehtolahti, Sylvain Hellegouarch, Stephen Farrell, Sean Turner, Pete Resnick, Peter Thorson, Joe Mason, John Fallows, and Alexander Philippou. Note that people listed above didn't necessarily endorse the end result of this work.",
      "ja": "グレッグ・ウィルキンス、ジョンTamplin、ウィリーTarreau、マシエジ・スタチョウィアック、ジェイミーLokier、：（リストは不完全である可能性が高い）HYBI WGメーリングリストでの議論に参加し、アイデアを貢献し、および/または詳細なレビューを提供し、次の人に感謝しますスコット・ファーガソン、ビョルンHoehrmann、ジュリアンReschke、デイブCridland、アンディ・グリーン、エリックレスコラ、イニャキバズカスティーヨ、マーティン・トムソン、ロベルトペオン、パトリック・マクマナス、忠ゆう、ブルース・アサートン、武吉野、マーティン・J. Duerst、ジェームズ・グラハム、サイモン・ピータース、ロイ・T.フィールディング、Mykyta Yevstifeyev、レンホルゲート、ポールColomiets、ピョートルKulaga、ブライアンRaymor、ヤンケーラー、Joonas Lehtolahti、シルヴァンHellegouarch、スティーブン・ファレル、ショーン・ターナー、ピート・レズニック、ピーター・ソーソン、ジョー・メイソン、ジョンファローズ、アレクサンドルPhilippou。上に挙げた人が、必ずしもこの作業の最終結果を保証するものではありませんでしたことに注意してください。"
    },
    {
      "indent": 0,
      "text": "14. References",
      "section_title": true,
      "ja": "14.参考文献"
    },
    {
      "indent": 0,
      "text": "14.1. Normative References",
      "section_title": true,
      "ja": "14.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[ANSI.X3-4.1986] American National Standards Institute, \"Coded Character Set - 7-bit American Standard Code for Information Interchange\", ANSI X3.4, 1986.",
      "ja": "「 - 情報交換のための7ビットの米国標準コードコード化文字セット」、ANSI X3.4、1986 [ANSI.X3-4.1986]米国規格協会、。"
    },
    {
      "indent": 3,
      "text": "[FIPS.180-3] National Institute of Standards and Technology, \"Secure Hash Standard\", FIPS PUB 180-3, October 2008, <http://csrc.nist.gov/publications/fips/fips180-3/ fips180-3_final.pdf>.",
      "ja": "[FIPS.180-3]アメリカ国立標準技術研究所、 \"セキュアハッシュ標準\"、FIPS PUB 180-3の、2008年10月、<http://csrc.nist.gov/publications/fips/fips180-3/ fips180- 3_final.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC1928] Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, \"SOCKS Protocol Version 5\", RFC 1928, March 1996.",
      "ja": "[RFC1928]リーチ、M.、Ganis、M.、リー、Y.、Kuris、R.、Koblas、D.、およびL.ジョーンズ、 \"SOCKSプロトコルバージョン5\"、RFC 1928、1996年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2817] Khare, R. and S. Lawrence, \"Upgrading to TLS Within HTTP/1.1\", RFC 2817, May 2000.",
      "ja": "[RFC2817] Khare、R.およびS.ローレンス、 \"HTTP / 1.1内でTLSへのアップグレード\"、RFC 2817、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.",
      "ja": "[RFC2818]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3864] Klyne, G., Nottingham, M., and J. Mogul, \"Registration Procedures for Message Header Fields\", BCP 90, RFC 3864, September 2004.",
      "ja": "[RFC3864] Klyne、G.、ノッティンガム、M.、およびJ.モーグル、BCP 90、RFC 3864、2004年9月 \"メッセージヘッダフィールドの登録手順\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3987] Duerst, M. and M. Suignard, \"Internationalized Resource Identifiers (IRIs)\", RFC 3987, January 2005.",
      "ja": "[RFC3987] Duerst、M.およびM. Suignard、 \"国際化リソース識別Fiers（IRI）\"、RFC 3987、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086]イーストレーク、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、2006年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, January 2011.",
      "ja": "[RFC6066]イーストレイク、D.、 \"トランスポート層セキュリティ（TLS）拡張機能：拡張定義\"、RFC 6066、2011年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6454] Barth, A., \"The Web Origin Concept\", RFC 6454, December 2011.",
      "ja": "[RFC6454]バース、A.、 \"ウェブ起源コンセプト\"、RFC 6454、2011年12月。"
    },
    {
      "indent": 0,
      "text": "14.2. Informative References",
      "section_title": true,
      "ja": "14.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC4122] Leach, P., Mealling, M., and R. Salz, \"A Universally Unique IDentifier (UUID) URN Namespace\", RFC 4122, July 2005.",
      "ja": "[RFC4122]リーチ、P.、Mealling、M.、およびR. Salzの、 \"汎用一意識別子（UUID）URN名前空間\"、RFC 4122、2005年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4270] Hoffman, P. and B. Schneier, \"Attacks on Cryptographic Hashes in Internet Protocols\", RFC 4270, November 2005.",
      "ja": "[RFC4270]ホフマン、P.とB.シュナイアー、 \"インターネットプロトコルで暗号化ハッシュに対する攻撃\"、RFC 4270、2005年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5321] Klensin, J., \"Simple Mail Transfer Protocol\", RFC 5321, October 2008.",
      "ja": "[RFC5321] Klensin、J.、 \"簡易メール転送プロトコル\"、RFC 5321、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC6202] Loreto, S., Saint-Andre, P., Salsano, S., and G. Wilkins, \"Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP\", RFC 6202, April 2011.",
      "ja": "[RFC6202]ロレート、S.、サン・アンドレ、P.、Salsano、S.、およびG.ウィルキンスは、「既知の問題とロングポーリングおよびストリーミング双方向HTTPでの使用のためのベスト・プラクティス」、RFC 6202、2011年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC6265] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, April 2011.",
      "ja": "[RFC6265]バース、A.、 \"HTTP状態管理機構\"、RFC 6265、2011年4月。"
    },
    {
      "indent": 3,
      "text": "[TALKING] Huang, L-S., Chen, E., Barth, A., Rescorla, E., and C. Jackson, \"Talking to Yourself for Fun and Profit\", 2010, <http://w2spconf.com/2011/papers/websocket.pdf>.",
      "ja": "[TALKING]黄、LS。、チェン、E.、バース、A.、 \"楽しさと利益のために自分自身に話す\" レスコラ、E.、およびC.ジャクソン、2010年、<http://w2spconf.com/2011 /papers/websocket.pdf>。"
    },
    {
      "indent": 3,
      "text": "[W3C.REC-wsc-ui-20100812] Roessler, T. and A. Saldhana, \"Web Security Context: User Interface Guidelines\", World Wide Web Consortium Recommendation REC-wsc-ui-20100812, August 2010, <http://www.w3.org/TR/2010/REC-wsc-ui-20100812/>.",
      "ja": "[W3C.REC-WSC-UI-20100812]レスラー、T.とA. Saldhana、 \"Webセキュリティコンテキスト：ユーザーインターフェイスガイドライン\"、World Wide Web Consortium（W3C）の勧告REC-WSC-UI-20100812、2010年8月、<のhttp：/ /www.w3.org/TR/2010/REC-wsc-ui-20100812/>。"
    },
    {
      "indent": 14,
      "text": "Latest version available at\n<http://www.w3.org/TR/wsc-ui/>.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[WSAPI] Hickson, I., \"The WebSocket API\", W3C Working Draft WD-websockets-20110929, September 2011, <http://www.w3.org/TR/2011/WD-websockets-20110929/>.",
      "ja": "[WSAPI]ヒクソン、I.、 \"のWebSocket API\"、W3CワーキングドラフトWD-WebSocketを-20110929、2011年9月、<http://www.w3.org/TR/2011/WD-websockets-20110929/>。"
    },
    {
      "indent": 14,
      "text": "Latest version available at\n<http://www.w3.org/TR/websockets/>.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[XMLHttpRequest] van Kesteren, A., Ed., \"XMLHttpRequest\", W3C Candidate Recommendation CR-XMLHttpRequest-20100803, August 2010, <http://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/>.",
      "ja": "【のXMLHttpRequest】バンKesteren氏、A.編、 \"のXMLHttpRequest\"、W3C勧告候補CR-のXMLHttpRequest-20100803、2010年8月、<http://www.w3.org/TR/2010/CR-XMLHttpRequest-20100803/> 。"
    },
    {
      "indent": 14,
      "text": "Latest version available at\n<http://www.w3.org/TR/XMLHttpRequest/>.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ian Fette Google, Inc.",
      "ja": "イアンたFetteグーグル株式会社"
    },
    {
      "indent": 3,
      "text": "EMail: ifette+ietf@google.com URI: http://www.ianfette.com/",
      "ja": "電子メール：ifette+ietf@google.com URI：http://www.ianfette.com/"
    },
    {
      "indent": 3,
      "text": "Alexey Melnikov Isode Ltd. 5 Castle Business Village 36 Station Road Hampton, Middlesex TW12 2BX UK",
      "ja": "アレクセイ・メルニコフISODE株式会社5キャッスルビジネス村の36の駅道ハンプトン、ミドルTW12 2BX英国"
    },
    {
      "indent": 3,
      "text": "EMail: Alexey.Melnikov@isode.com",
      "ja": "メールアドレス：Alexey.Melnikov@isode.com"
    }
  ]
}